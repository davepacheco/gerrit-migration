commit ebe4a54b6e4d011aad0c7f43dc9bb0db20a6997c (refs/changes/40/3240/4)
Author: Mike Gerdts <mike.gerdts@joyent.com>
Date:   2018-02-06T19:26:19+00:00 (1 year, 8 months ago)
    
    OS-6465 add iasl

diff --git a/manifest b/manifest
index fd110c1e7b..445650f3f6 100644
--- a/manifest
+++ b/manifest
@@ -10359,6 +10359,7 @@ f usr/sbin/gsscred 0555 root sys
 f usr/sbin/halt 0755 root bin
 s usr/sbin/hostconfig=../../sbin/hostconfig
 f usr/sbin/hotplug 0555 root bin
+f usr/sbin/iasl 0555 root bin
 d usr/sbin/i86 0755 root bin
 f usr/sbin/idmap 0555 root bin
 f usr/sbin/if_mpadm 0555 root bin
diff --git a/usr/src/Makefile.master b/usr/src/Makefile.master
index 253211f50c..a9a5af2d06 100644
--- a/usr/src/Makefile.master
+++ b/usr/src/Makefile.master
@@ -27,6 +27,7 @@
 # Copyright 2015 Gary Mills
 # Copyright 2015 Igor Kozhukhov <ikozhukhov@gmail.com>
 # Copyright 2016 Toomas Soome <tsoome@me.com>
+# Copyright 2017 Joyent, Inc.
 #
 
 #
@@ -156,10 +157,12 @@ MCS=		/usr/ccs/bin/mcs
 CAT=            /usr/bin/cat
 ELFDUMP=	/usr/ccs/bin/elfdump
 M4=		/usr/bin/m4
+GM4=		/usr/bin/gm4
 STRIP=		/usr/ccs/bin/strip
 LEX=		/usr/ccs/bin/lex
 FLEX=		/usr/bin/flex
 YACC=		/usr/ccs/bin/yacc
+BISON=		/usr/bin/bison
 CPP=		/usr/lib/cpp
 JAVAC=		$(JAVA_ROOT)/bin/javac
 JAVAH=		$(JAVA_ROOT)/bin/javah
diff --git a/usr/src/cmd/acpi/Makefile b/usr/src/cmd/acpi/Makefile
index 0e59da4aa6..ce78ff94c0 100644
--- a/usr/src/cmd/acpi/Makefile
+++ b/usr/src/cmd/acpi/Makefile
@@ -8,12 +8,12 @@
 # source.  A copy of the CDDL is also available via the Internet at
 # http://www.illumos.org/license/CDDL.
 #
-# Copyright 2016 Joyent, Inc.
+# Copyright (c) 2018, Joyent, Inc.
 #
 
 include ../Makefile.cmd
 
-SUBDIRS= acpidump acpixtract
+SUBDIRS= acpidump acpixtract iasl
 
 all:=		TARGET= all
 install:=	TARGET= install
@@ -39,10 +39,7 @@ clobber: $(SUBDIRS)
 
 lint:
 
-$(SUBDIRS): common FRC
-	@cd $@; pwd; $(MAKE) $(MFLAGS) $(TARGET)
-
-common: FRC
+$(SUBDIRS): FRC
 	@cd $@; pwd; $(MAKE) $(MFLAGS) $(TARGET)
 
 FRC:
diff --git a/usr/src/cmd/acpi/Readme b/usr/src/cmd/acpi/Readme
index 86e502a917..953d0254e9 100644
--- a/usr/src/cmd/acpi/Readme
+++ b/usr/src/cmd/acpi/Readme
@@ -1,7 +1,48 @@
-The ACPI utilities are based on the Intel ACPI source code drops. No changes
-are made to Intel-provided source code. Most of the ACPI lives in the kernel
-under usr/src/uts/intel/io/acpica and usr/src/uts/intel/sys/acpi.
+This file and its contents are supplied under the terms of the
+Common Development and Distribution License ("CDDL"), version 1.0.
+You may only use this file in accordance with the terms of version
+1.0 of the CDDL.
 
-The assembler/disassembler (iasl) is currently not being built here, but it
-can be used on the dumped tables from within a non-native environment, such
-as within an lx-branded zone.
+A full copy of the text of the CDDL should have accompanied this
+source.  A copy of the CDDL is also available via the Internet at
+http://www.illumos.org/license/CDDL.
+
+Copyright (c) 2018, Joyent, Inc.
+
+---
+
+The ACPI utilities are based on the Intel ACPI source code drops.  Aside from
+notes in Readme.resync files, no changes are made to Intel-provided source code.
+Most of the ACPI source code lives in
+the following directories:
+
+   usr/src/uts/common/acpica		Common to kernel and commands
+   usr/src/uts/intel/io/acpica		Kernel
+   usr/src/uts/intel/sys/acpi		Headers
+   usr/src/cmd/acpi			Commands
+
+The acpica-update script in this directory can serve as a guide for performing
+updates.  It is expected that it will need to be tweaked as the upstream acpica
+software evolves.
+
+The expected workflow for updating is
+
+1. Clone the appropriate acpica workspace from github.  Until such a time
+   as Joyent's changes to acpica are in the Intel distribution, this probably
+   means:
+
+     git clone -b smartos git@github.com:joyent/acpica.git
+
+2. Do any required development work in the workspace checked out in step 1.
+   This probably includes rebasing Joyent's changes on the latest release.
+   Don't forget to push these to github and submit a pull request if
+   appropriate.
+
+3. Build and test the modified acpica disto as described in the documentation
+   in that workspace.
+
+4. Run acpica-update from within an illumos workspace.  That is:
+
+     ./acpica-update ~/acpica
+
+5. Build, test, code review, etc.
diff --git a/usr/src/cmd/acpi/acpica-update b/usr/src/cmd/acpi/acpica-update
new file mode 100755
index 0000000000..f814917df0
--- /dev/null
+++ b/usr/src/cmd/acpi/acpica-update
@@ -0,0 +1,251 @@
+#!/bin/ksh -e
+#
+# This file and its contents are supplied under the terms of the
+# Common Development and Distribution License ("CDDL"), version 1.0.
+# You may only use this file in accordance with the terms of version
+# 1.0 of the CDDL.
+#
+# A full copy of the text of the CDDL should have accompanied this
+# source.  A copy of the CDDL is also available via the Internet at
+# http://www.illumos.org/license/CDDL.
+#
+# Copyright (c) 2018, Joyent, Inc.
+#
+
+export PATH=/usr/bin:/usr/sbin:$PATH
+
+# Comment this when you are ready to run it for real.
+dry_run=--dry-run
+
+# This uses rsync.  Trailing slashes are signficant.
+function sync {		# srcdir dstdir [excludepatterns]
+	set -e
+	typeset src=$1
+	typeset dst=$2
+	typeset -a exclude
+	typeset readme=Readme.resync
+
+	shift 2
+	for arg in "$@"; do
+		exclude+=( --exclude "$arg" )
+	done
+
+	echo ""
+	echo "sync $src"
+	echo "  to: $dst"
+	if (( $# > 0 )); then
+		echo "  excluding: $@"
+	fi
+
+	add_files "$dst"
+
+	rsync $dry_run --out-format '%i %n' -r \
+	    --checksum --delete --exclude "$readme" "${exclude[@]}" \
+	    "$src" "$dst"
+
+	if [[ -f $dst/$readme ]]; then
+		typeset ws_readme
+		ws_readme=$(ws_path "${dst%%/}/$readme")
+		if grep '^@@ ' "$ws_readme" >/dev/null 2>&1; then
+			if [[ -z $dry_run ]]; then
+				echo "Applying patch in $ws_readme"
+				if patch -f -p1 < "$ws_readme"; then
+					readmes["$ws_readme"]="Patch Applied"
+				else
+					readmes["$ws_readme"]="Patch FAILED"
+				fi
+			else
+				echo "Patch in $ws_readme"
+				if [[ -n $diffstat ]]; then
+					diffstat < $ws_readme
+				fi
+				readmes["$ws_readme"]="Has Patch"
+			fi
+		else
+			echo "Important resync info in $ws_readme:"
+			cat "$ws_readme"
+			readmes["$ws_readme"]="MUST READ"
+		fi
+	fi
+}
+
+function copy {		# srcfile dst{file|dir}
+	typeset src=$1
+	typeset dst=$2
+
+	if [[ -d "$dst" ]]; then
+		add_files "$dst"
+	else
+		add_files "$(dirname "$dst")"
+	fi
+
+	if diff "$src" "$dst" >/dev/null 2>&1; then
+		echo ""
+		echo "copy $src"
+		echo "  to: $dst"
+		if [[ -z $dry_run ]]; then
+			cp "$src" "$dst" || return $?
+		fi
+	fi
+	return 0
+}
+
+function add_files {	# dir
+	typeset dir=$(ws_path "$1")
+	typeset file
+
+	if [[ -n ${alldirs["$dir"]} ]]; then
+		return
+	fi
+	alldirs["$dir"]=added
+
+	find "$dir" -type f | while read file; do
+		skip_file "$file" && continue
+		[[ -n ${allfiles["$file"]} ]] && continue
+		set -- $(md5sum "$file")
+		allfiles["$file"]="md5:$1"
+	done
+}
+
+function compare_files {
+	typeset dir
+	typeset file
+	typeset ufile
+	typeset header="\nThe following file changes happened:"
+
+	for dir in ${!alldirs[@]}; do
+		find "$dir" -type f | while read file; do
+			skip_file "$file" && continue
+			if [[ -z ${allfiles["$file"]} ]]; then
+				allfiles["$file"]=new
+				continue
+			fi
+			set -- $(md5sum "$file")
+			if [[ ${allfiles["$file"]} == "md5:$1" ]]; then
+				allfiles["$file"]=same
+				continue
+			fi
+			allfiles["$file"]=modified
+		done
+	done
+	for ufile in "${!allfiles[@]}"; do
+		echo "$ufile"
+	done | sort | while read file; do
+		typeset val=${allfiles["$file"]}
+
+		[[ $val == same ]] && continue
+		[[ $val == md5:* ]] && val=removed
+
+		if [[ -n $header ]]; then
+			print "$header"
+			header=
+		fi
+		printf "  %-12s %s\n" "$val" "$file"
+	done
+}
+
+function skip_file {	# filename
+	typeset file=$1
+
+	# Remember reserved meaning of return codes
+	[[ $file == *.o ]] && return 0
+	[[ $file == *.rej ]] && return 0
+	[[ $file == *.orig ]] && return 0
+	[[ $(file "$file") == *ELF* ]] && return 0
+
+	return 1
+}
+
+# Translate absolute path into one relative to $ws_top
+function ws_path {	# path
+	typeset path=$1
+
+	if [[ $path != /* ]]; then
+		print -u2 "ws_path: bad absolute path: '%s'"
+		exit 1
+	fi
+
+	# Strip excessive leading and all trailing slashes
+	path=${path%%/}
+	path=/${path##/}
+
+	echo "${path#$ws_top/}"
+}
+
+#
+# First argument is the acpica source directory
+#
+if [[ $1 != /* || ! -d $1 ]]; then
+	print -u2 "Usage: $0 <acpica-git-directory>"
+	exit 1
+fi
+ac_top=$1
+
+ac_source=$ac_top/source
+ac_include=$ac_source/include
+ac_components=$ac_source/components
+
+ws_top=${CODEMGR_WS:-$(git rev-parse --show-toplevel)}
+ws_common=$ws_top/usr/src/common/acpica
+ws_include=$ws_top/usr/src/uts/intel/sys/acpi
+ws_cmd=$ws_top/usr/src/cmd/acpi
+
+cd "$ws_top"
+
+typeset -A readmes
+typeset -A alldirs
+typeset -A allfiles
+diffstat=$(type -p diffstat 2>/dev/null)
+
+#
+# Sync acpica/source/comonents/<comp> to illumos/usr/src/common/acpica/<comp>
+#
+for dir in disassembler dispatcher events executer hardware \
+    namespace parser resources tables utilities; do
+	sync "$ac_components/$dir/" "$ws_common/$dir/"
+done
+
+#
+# Sync acpica/source/include to illumos/usr/src/uts/intel/sys/acpi
+#
+sync "$ac_include/" "$ws_include/" acsolaris.h acpi_pci.h acpi_enum.h
+
+#
+# Sync some acpica/source/tools/<tool> to usr/src/cmd/acpi/<tool>
+# acpidump requires some special treatment because of OS-specific files.
+#
+sync "$ac_source/tools/acpidump/" "$ws_cmd/acpidump/" \
+    Makefile osillumostbl.c osunixdir.c
+copy "$ac_source/os_specific/service_layers/osunixdir.c" "$ws_cmd/acpidump/"
+sync "$ac_source/tools/acpixtract/" "$ws_cmd/acpixtract/" \
+    Makefile
+
+#
+# Sync iasl from acpica/source/compiler to usr/src/cmd/acpi/iasl
+#
+sync "$ac_source/compiler/" "$ws_cmd/iasl/" \
+    Makefile
+
+#
+# Sync common user space code from acpica/source/common to
+# usr/src/cmd/acpi/comon
+#
+sync "$ac_source/common/" "$ws_cmd/common/" osl.c osunixxf.c
+copy "$ac_source/os_specific/service_layers/osunixxf.c" "$ws_cmd/common/"
+
+if [[ -n $dry_run ]]; then
+	echo ""
+	echo "NOTICE: That was a dry run: nothing was changed."
+fi
+
+if (( ${#readmes[@]} != 0 )); then
+	echo ""
+	echo "NOTICE: You read the Readme.resync files, right?"
+	for file in "${!readmes[@]}"; do
+		printf "   %-12s %s\n" "${readmes["$file"]}" "$file"
+	done
+fi
+
+compare_files
+
+exit 0
diff --git a/usr/src/cmd/acpi/acpidump/Makefile b/usr/src/cmd/acpi/acpidump/Makefile
index 5c9b24ccbe..50d08269c3 100644
--- a/usr/src/cmd/acpi/acpidump/Makefile
+++ b/usr/src/cmd/acpi/acpidump/Makefile
@@ -8,7 +8,7 @@
 # source.  A copy of the CDDL is also available via the Internet at
 # http://www.illumos.org/license/CDDL.
 #
-# Copyright 2016 Joyent, Inc.
+# Copyright (c) 2018, Joyent, Inc.
 # Copyright 2016 RackTop Systems.
 #
 
@@ -17,10 +17,13 @@ PROG=		acpidump
 include ../../Makefile.cmd
 include ../../Makefile.ctf
 
-OBJS= apmain.o apdump.o apfiles.o tbprint.o tbxfroot.o osillumostbl.o \
-	utbuffer.o osunixdir.o
+OBJS= apmain.o apdump.o apfiles.o getopt.o tbprint.o tbxfroot.o osillumostbl.o \
+	utascii.o utbuffer.o utdebug.o utexcep.o utmath.o utnonansi.o \
+	utxferror.o utglobal.o utprint.o osunixdir.o osl.o osunixxf.o
 SRCS = $(OBJS:.o=.c)
 
+VPATH = ../common:$(SRC)/common/acpica/utilities:$(SRC)/common/acpica/tables
+
 CERRWARN += -_gcc=-Wno-unused-function
 
 CPPFLAGS += -I$(SRC)/uts/intel/sys/acpi -DACPI_DUMP_APP
@@ -32,13 +35,13 @@ LDLIBS += -ldevinfo
 all: $(PROG)
 
 $(PROG): $(OBJS)
-	$(LINK.c) -o $@ $(OBJS) ../common/acpi.a $(LDLIBS)
+	$(LINK.c) -o $@ $(OBJS) $(LDLIBS)
 	$(POST_PROCESS)
 
 install: all $(ROOTUSRSBINPROG)
 
 clean:
-	$(RM) $(OBJS)
+	$(RM) $(OBJS) $(PROG)
 
 lint:	lint_SRCS
 
diff --git a/usr/src/cmd/acpi/acpidump/acpidump.h b/usr/src/cmd/acpi/acpidump/acpidump.h
index f36c853875..0817338dac 100644
--- a/usr/src/cmd/acpi/acpidump/acpidump.h
+++ b/usr/src/cmd/acpi/acpidump/acpidump.h
@@ -60,7 +60,6 @@
 #include <fcntl.h>
 #include <errno.h>
 #include <sys/stat.h>
-#include <strings.h>
 
 
 /* Globals */
diff --git a/usr/src/cmd/acpi/acpidump/osillumostbl.c b/usr/src/cmd/acpi/acpidump/osillumostbl.c
index 12bf145f7e..2ccde61c9c 100644
--- a/usr/src/cmd/acpi/acpidump/osillumostbl.c
+++ b/usr/src/cmd/acpi/acpidump/osillumostbl.c
@@ -43,7 +43,7 @@
  */
 
 /*
- * Copyright 2016 Joyent, Inc.
+ * Copyright (c) 2018, Joyent, Inc.
  */
 
 #include <stdarg.h>
@@ -1003,57 +1003,6 @@ OslTableNameFromFile(char *Filename, char *Signature, UINT32 *Instance)
 	return (AE_OK);
 }
 
-UINT32
-CmGetFileSize(ACPI_FILE File)
-{
-	int fd;
-	struct stat sb;
-
-	fd = fileno(File);
-	if (fstat(fd, &sb) != 0)
-		return (ACPI_UINT32_MAX);
-	return ((UINT32)sb.st_size);
-}
-
-void *
-AcpiOsAllocateZeroed(ACPI_SIZE Size)
-{
-	return (calloc(1, Size));
-}
-
-void
-AcpiOsFree(void *p)
-{
-	free(p);
-}
-
-ACPI_FILE
-AcpiOsOpenFile(const char *Path, UINT8 Modes)
-{
-	char mode[3];
-
-	bzero(mode, sizeof (mode));
-	if ((Modes & ACPI_FILE_READING) != 0)
-		(void) strlcat(mode, "r", sizeof (mode));
-
-	if ((Modes & ACPI_FILE_WRITING) != 0)
-		(void) strlcat(mode, "w", sizeof (mode));
-
-	return (fopen(Path, mode));
-}
-
-void
-AcpiOsCloseFile(ACPI_FILE File)
-{
-	fclose(File);
-}
-
-int
-AcpiOsReadFile(ACPI_FILE File, void *Buffer, ACPI_SIZE Size, ACPI_SIZE Count)
-{
-	return (fread(Buffer, Size, Count, File));
-}
-
 void *
 AcpiOsMapMemory(ACPI_PHYSICAL_ADDRESS Where, ACPI_SIZE Length)
 {
diff --git a/usr/src/cmd/acpi/acpixtract/Makefile b/usr/src/cmd/acpi/acpixtract/Makefile
index deba09c0cc..f2204b9941 100644
--- a/usr/src/cmd/acpi/acpixtract/Makefile
+++ b/usr/src/cmd/acpi/acpixtract/Makefile
@@ -8,7 +8,7 @@
 # source.  A copy of the CDDL is also available via the Internet at
 # http://www.illumos.org/license/CDDL.
 #
-# Copyright 2016 Joyent, Inc.
+# Copyright (c) 2018, Joyent, Inc.
 # Copyright 2016 RackTop Systems.
 #
 
@@ -17,9 +17,13 @@ PROG=		acpixtract
 include ../../Makefile.cmd
 include ../../Makefile.ctf
 
-OBJS= axmain.o acpixtract.o axutils.o
+OBJS =	axmain.o acpixtract.o axutils.o osunixxf.o utglobal.o getopt.o \
+	utdebug.o utprint.o osl.o utascii.o utmath.o utxferror.o utnonansi.o \
+	utexcep.o
 SRCS = $(OBJS:.o=.c)
 
+VPATH = ../common:$(SRC)/common/acpica/utilities
+
 CERRWARN += -_gcc=-Wno-unused-function
 
 CPPFLAGS += -I$(SRC)/uts/intel/sys/acpi -DACPI_XTRACT_APP
@@ -29,13 +33,13 @@ CPPFLAGS += -I$(SRC)/uts/intel/sys/acpi -DACPI_XTRACT_APP
 all: $(PROG)
 
 $(PROG): $(OBJS)
-	$(LINK.c) -o $@ $(OBJS) ../common/acpi.a $(LDLIBS)
+	$(LINK.c) -o $@ $(OBJS) $(LDLIBS)
 	$(POST_PROCESS)
 
 install: all $(ROOTUSRSBINPROG)
 
 clean:
-	$(RM) $(OBJS)
+	$(RM) $(OBJS) $(PROG)
 
 lint:	lint_SRCS
 
diff --git a/usr/src/cmd/acpi/common/Makefile b/usr/src/cmd/acpi/common/Makefile
deleted file mode 100644
index 9053fe061b..0000000000
--- a/usr/src/cmd/acpi/common/Makefile
+++ /dev/null
@@ -1,39 +0,0 @@
-#
-# This file and its contents are supplied under the terms of the
-# Common Development and Distribution License ("CDDL"), version 1.0.
-# You may only use this file in accordance with the terms of version
-# 1.0 of the CDDL.
-#
-# A full copy of the text of the CDDL should have accompanied this
-# source.  A copy of the CDDL is also available via the Internet at
-# http://www.illumos.org/license/CDDL.
-#
-# Copyright 2016 Joyent, Inc.
-#
-
-LIBRARY =	acpi.a
-
-include	$(SRC)/lib/Makefile.lib
-
-OBJECTS= getopt.o osl.o utascii.o utdebug.o utexcep.o utglobal.o  utmath.o \
-	utnonansi.o utprint.o utxferror.o
-SRCS = $(OBJECTS:.o=.c)
-
-CERRWARN += -_gcc=-Wno-unused-function
-
-CPPFLAGS += -I$(SRC)/uts/intel/sys/acpi -DACPI_APPLICATION
-
-LDLIBS += -lc
-
-HSONAME=
-MAPFILES = mapfile-vers
-
-CLOBBERFILES= $(LIBRARY)
-
-.KEEP_STATE:
-
-all: $(LIBRARY)
-
-install: all
-
-include $(SRC)/lib/Makefile.targ
diff --git a/usr/src/cmd/acpi/common/acfileio.c b/usr/src/cmd/acpi/common/acfileio.c
new file mode 100644
index 0000000000..589eaea263
--- /dev/null
+++ b/usr/src/cmd/acpi/common/acfileio.c
@@ -0,0 +1,538 @@
+/******************************************************************************
+ *
+ * Module Name: acfileio - Get ACPI tables from file
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2016, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include "acpi.h"
+#include "accommon.h"
+#include "acapps.h"
+#include "actables.h"
+#include "acutils.h"
+#include <errno.h>
+
+#define _COMPONENT          ACPI_UTILITIES
+        ACPI_MODULE_NAME    ("acfileio")
+
+
+/* Local prototypes */
+
+static ACPI_STATUS
+AcGetOneTableFromFile (
+    char                    *Filename,
+    FILE                    *File,
+    UINT8                   GetOnlyAmlTables,
+    ACPI_TABLE_HEADER       **Table);
+
+static ACPI_STATUS
+AcCheckTextModeCorruption (
+    ACPI_TABLE_HEADER       *Table);
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcGetAllTablesFromFile
+ *
+ * PARAMETERS:  Filename            - Table filename
+ *              GetOnlyAmlTables    - TRUE if the tables must be AML tables
+ *              ReturnListHead      - Where table list is returned
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Get all ACPI tables from within a single file.
+ *
+ ******************************************************************************/
+
+ACPI_STATUS
+AcGetAllTablesFromFile (
+    char                    *Filename,
+    UINT8                   GetOnlyAmlTables,
+    ACPI_NEW_TABLE_DESC     **ReturnListHead)
+{
+    ACPI_NEW_TABLE_DESC     *ListHead = NULL;
+    ACPI_NEW_TABLE_DESC     *ListTail = NULL;
+    ACPI_NEW_TABLE_DESC     *TableDesc;
+    FILE                    *File;
+    ACPI_TABLE_HEADER       *Table = NULL;
+    UINT32                  FileSize;
+    ACPI_STATUS             Status = AE_OK;
+
+
+    File = fopen (Filename, "rb");
+    if (!File)
+    {
+        perror ("Could not open input file");
+        if (errno == ENOENT)
+        {
+            return (AE_NOT_EXIST);
+        }
+
+        return (AE_ERROR);
+    }
+
+    /* Get the file size */
+
+    FileSize = CmGetFileSize (File);
+    if (FileSize == ACPI_UINT32_MAX)
+    {
+        Status = AE_ERROR;
+        goto ErrorExit;
+    }
+
+    fprintf (stderr,
+        "Input file %s, Length 0x%X (%u) bytes\n",
+        Filename, FileSize, FileSize);
+
+    /* We must have at least one ACPI table header */
+
+    if (FileSize < sizeof (ACPI_TABLE_HEADER))
+    {
+        Status = AE_BAD_HEADER;
+        goto ErrorExit;
+    }
+
+    /* Check for an non-binary file */
+
+    if (!AcIsFileBinary (File))
+    {
+        fprintf (stderr,
+            "    %s: File does not appear to contain a valid AML table\n",
+            Filename);
+        return (AE_TYPE);
+    }
+
+    /* Read all tables within the file */
+
+    while (ACPI_SUCCESS (Status))
+    {
+        /* Get one entire ACPI table */
+
+        Status = AcGetOneTableFromFile (
+            Filename, File, GetOnlyAmlTables, &Table);
+
+        if (Status == AE_CTRL_TERMINATE)
+        {
+            Status = AE_OK;
+            break;
+        }
+        else if (Status == AE_TYPE)
+        {
+            return (AE_OK);
+        }
+        else if (ACPI_FAILURE (Status))
+        {
+            goto ErrorExit;
+        }
+
+        /* Print table header for iASL/disassembler only */
+
+#ifdef ACPI_ASL_COMPILER
+
+            AcpiTbPrintTableHeader (0, Table);
+#endif
+
+        /* Allocate and link a table descriptor */
+
+        TableDesc = AcpiOsAllocate (sizeof (ACPI_NEW_TABLE_DESC));
+        TableDesc->Table = Table;
+        TableDesc->Next = NULL;
+
+        /* Link at the end of the local table list */
+
+        if (!ListHead)
+        {
+            ListHead = TableDesc;
+            ListTail = TableDesc;
+        }
+        else
+        {
+            ListTail->Next = TableDesc;
+            ListTail = TableDesc;
+        }
+    }
+
+    /* Add the local table list to the end of the global list */
+
+    if (*ReturnListHead)
+    {
+        ListTail = *ReturnListHead;
+        while (ListTail->Next)
+        {
+            ListTail = ListTail->Next;
+        }
+
+        ListTail->Next = ListHead;
+    }
+    else
+    {
+        *ReturnListHead = ListHead;
+    }
+
+ErrorExit:
+    fclose(File);
+    return (Status);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcGetOneTableFromFile
+ *
+ * PARAMETERS:  Filename            - File where table is located
+ *              File                - Open FILE pointer to Filename
+ *              GetOnlyAmlTables    - TRUE if the tables must be AML tables.
+ *              ReturnTable         - Where a pointer to the table is returned
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Read the next ACPI table from a file. Implements support
+ *              for multiple tables within a single file. File must already
+ *              be open.
+ *
+ * Note: Loading an RSDP is not supported.
+ *
+ ******************************************************************************/
+
+static ACPI_STATUS
+AcGetOneTableFromFile (
+    char                    *Filename,
+    FILE                    *File,
+    UINT8                   GetOnlyAmlTables,
+    ACPI_TABLE_HEADER       **ReturnTable)
+{
+    ACPI_STATUS             Status = AE_OK;
+    ACPI_TABLE_HEADER       TableHeader;
+    ACPI_TABLE_HEADER       *Table;
+    INT32                   Count;
+    long                    TableOffset;
+
+
+    *ReturnTable = NULL;
+
+    /* Get the table header to examine signature and length */
+
+    TableOffset = ftell (File);
+    Count = fread (&TableHeader, 1, sizeof (ACPI_TABLE_HEADER), File);
+    if (Count != sizeof (ACPI_TABLE_HEADER))
+    {
+        return (AE_CTRL_TERMINATE);
+    }
+
+    /* Validate the table signature/header (limited ASCII chars) */
+
+    Status = AcValidateTableHeader (File, TableOffset);
+    if (ACPI_FAILURE (Status))
+    {
+        return (Status);
+    }
+
+    if (GetOnlyAmlTables)
+    {
+        /* Table must be an AML table (DSDT/SSDT) or FADT */
+
+        if (!ACPI_COMPARE_NAME (TableHeader.Signature, ACPI_SIG_FADT) &&
+            !AcpiUtIsAmlTable (&TableHeader))
+        {
+            fprintf (stderr,
+                "    %s: Table [%4.4s] is not an AML table - ignoring\n",
+                Filename, TableHeader.Signature);
+
+            return (AE_TYPE);
+        }
+    }
+
+    /* Allocate a buffer for the entire table */
+
+    Table = AcpiOsAllocate ((size_t) TableHeader.Length);
+    if (!Table)
+    {
+        return (AE_NO_MEMORY);
+    }
+
+    /* Read the entire ACPI table, including header */
+
+    fseek (File, TableOffset, SEEK_SET);
+
+    Count = fread (Table, 1, TableHeader.Length, File);
+    if (Count != (INT32) TableHeader.Length)
+    {
+        Status = AE_ERROR;
+        goto ErrorExit;
+    }
+
+    /* Validate the checksum (just issue a warning) */
+
+    Status = AcpiTbVerifyChecksum (Table, TableHeader.Length);
+    if (ACPI_FAILURE (Status))
+    {
+        Status = AcCheckTextModeCorruption (Table);
+        if (ACPI_FAILURE (Status))
+        {
+            goto ErrorExit;
+        }
+    }
+
+    *ReturnTable = Table;
+    return (AE_OK);
+
+
+ErrorExit:
+    AcpiOsFree (Table);
+    return (Status);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcIsFileBinary
+ *
+ * PARAMETERS:  File                - Open input file
+ *
+ * RETURN:      TRUE if file appears to be binary
+ *
+ * DESCRIPTION: Scan a file for any non-ASCII bytes.
+ *
+ * Note: Maintains current file position.
+ *
+ ******************************************************************************/
+
+BOOLEAN
+AcIsFileBinary (
+    FILE                    *File)
+{
+    UINT8                   Byte;
+    BOOLEAN                 IsBinary = FALSE;
+    long                    FileOffset;
+
+
+    /* Scan entire file for any non-ASCII bytes */
+
+    FileOffset = ftell (File);
+    while (fread (&Byte, 1, 1, File) == 1)
+    {
+        if (!isprint (Byte) && !isspace (Byte))
+        {
+            IsBinary = TRUE;
+            goto Exit;
+        }
+    }
+
+Exit:
+    fseek (File, FileOffset, SEEK_SET);
+    return (IsBinary);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcValidateTableHeader
+ *
+ * PARAMETERS:  File                - Open input file
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Determine if a file seems to contain one or more binary ACPI
+ *              tables, via the
+ *              following checks on what would be the table header:
+ *              1) File must be at least as long as an ACPI_TABLE_HEADER
+ *              2) There must be enough room in the file to hold entire table
+ *              3) Signature, OemId, OemTableId, AslCompilerId must be ASCII
+ *
+ * Note: There can be multiple definition blocks per file, so we cannot
+ * expect/compare the file size to be equal to the table length. 12/2015.
+ *
+ * Note: Maintains current file position.
+ *
+ ******************************************************************************/
+
+ACPI_STATUS
+AcValidateTableHeader (
+    FILE                    *File,
+    long                    TableOffset)
+{
+    ACPI_TABLE_HEADER       TableHeader;
+    size_t                  Actual;
+    long                    OriginalOffset;
+    UINT32                  FileSize;
+    UINT32                  i;
+
+
+    ACPI_FUNCTION_TRACE ("AcValidateTableHeader");
+
+
+    /* Read a potential table header */
+
+    OriginalOffset = ftell (File);
+    fseek (File, TableOffset, SEEK_SET);
+
+    Actual = fread (&TableHeader, 1, sizeof (ACPI_TABLE_HEADER), File);
+    fseek (File, OriginalOffset, SEEK_SET);
+
+    if (Actual < sizeof (ACPI_TABLE_HEADER))
+    {
+        return (AE_ERROR);
+    }
+
+    /* Validate the signature (limited ASCII chars) */
+
+    if (!AcpiUtValidNameseg (TableHeader.Signature))
+    {
+        fprintf (stderr, "Invalid table signature: 0x%8.8X\n",
+            *ACPI_CAST_PTR (UINT32, TableHeader.Signature));
+        return (AE_BAD_SIGNATURE);
+    }
+
+    /* Validate table length against bytes remaining in the file */
+
+    FileSize = CmGetFileSize (File);
+    if (TableHeader.Length > (UINT32) (FileSize - TableOffset))
+    {
+        fprintf (stderr, "Table [%4.4s] is too long for file - "
+            "needs: 0x%.2X, remaining in file: 0x%.2X\n",
+            TableHeader.Signature, TableHeader.Length,
+            (UINT32) (FileSize - TableOffset));
+        return (AE_BAD_HEADER);
+    }
+
+    /*
+     * These fields must be ASCII: OemId, OemTableId, AslCompilerId.
+     * We allow a NULL terminator in OemId and OemTableId.
+     */
+    for (i = 0; i < ACPI_NAME_SIZE; i++)
+    {
+        if (!ACPI_IS_ASCII ((UINT8) TableHeader.AslCompilerId[i]))
+        {
+            goto BadCharacters;
+        }
+    }
+
+    for (i = 0; (i < ACPI_OEM_ID_SIZE) && (TableHeader.OemId[i]); i++)
+    {
+        if (!ACPI_IS_ASCII ((UINT8) TableHeader.OemId[i]))
+        {
+            goto BadCharacters;
+        }
+    }
+
+    for (i = 0; (i < ACPI_OEM_TABLE_ID_SIZE) && (TableHeader.OemTableId[i]); i++)
+    {
+        if (!ACPI_IS_ASCII ((UINT8) TableHeader.OemTableId[i]))
+        {
+            goto BadCharacters;
+        }
+    }
+
+    return (AE_OK);
+
+
+BadCharacters:
+
+    ACPI_WARNING ((AE_INFO,
+        "Table header for [%4.4s] has invalid ASCII character(s)",
+        TableHeader.Signature));
+    return (AE_OK);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcCheckTextModeCorruption
+ *
+ * PARAMETERS:  Table           - Table buffer starting with table header
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Check table for text mode file corruption where all linefeed
+ *              characters (LF) have been replaced by carriage return linefeed
+ *              pairs (CR/LF).
+ *
+ ******************************************************************************/
+
+static ACPI_STATUS
+AcCheckTextModeCorruption (
+    ACPI_TABLE_HEADER       *Table)
+{
+    UINT32                  i;
+    UINT32                  Pairs = 0;
+    UINT8                   *Buffer = ACPI_CAST_PTR (UINT8, Table);
+
+
+    /* Scan entire table to determine if each LF has been prefixed with a CR */
+
+    for (i = 1; i < Table->Length; i++)
+    {
+        if (Buffer[i] == 0x0A)
+        {
+            if (Buffer[i - 1] != 0x0D)
+            {
+                /* The LF does not have a preceding CR, table not corrupted */
+
+                return (AE_OK);
+            }
+            else
+            {
+                /* Found a CR/LF pair */
+
+                Pairs++;
+            }
+
+            i++;
+        }
+    }
+
+    if (!Pairs)
+    {
+        return (AE_OK);
+    }
+
+    /*
+     * Entire table scanned, each CR is part of a CR/LF pair --
+     * meaning that the table was treated as a text file somewhere.
+     *
+     * NOTE: We can't "fix" the table, because any existing CR/LF pairs in the
+     * original table are left untouched by the text conversion process --
+     * meaning that we cannot simply replace CR/LF pairs with LFs.
+     */
+    AcpiOsPrintf ("Table has been corrupted by text mode conversion\n");
+    AcpiOsPrintf ("All LFs (%u) were changed to CR/LF pairs\n", Pairs);
+    AcpiOsPrintf ("Table cannot be repaired!\n");
+
+    return (AE_BAD_VALUE);
+}
diff --git a/usr/src/cmd/acpi/common/acgetline.c b/usr/src/cmd/acpi/common/acgetline.c
new file mode 100644
index 0000000000..b08fb637d0
--- /dev/null
+++ b/usr/src/cmd/acpi/common/acgetline.c
@@ -0,0 +1,441 @@
+/******************************************************************************
+ *
+ * Module Name: acgetline - local line editing
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2016, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include "acpi.h"
+#include "accommon.h"
+#include "amlcode.h"
+#include "acparser.h"
+#include "acdebug.h"
+
+#include <stdio.h>
+
+/*
+ * This is an os-independent implementation of line-editing services needed
+ * by the AcpiExec utility. It uses getchar() and putchar() and the existing
+ * history support provided by the AML debugger. It assumes that the terminal
+ * is in the correct line-editing mode such as raw and noecho. The OSL
+ * interface AcpiOsInitialize should do this. AcpiOsTerminate should put the
+ * terminal back into the original mode.
+ */
+#define _COMPONENT          ACPI_OS_SERVICES
+        ACPI_MODULE_NAME    ("acgetline")
+
+
+/* Local prototypes */
+
+static void
+AcpiAcClearLine (
+    UINT32                  EndOfLine,
+    UINT32                  CursorPosition);
+
+/* Various ASCII constants */
+
+#define _ASCII_NUL                  0
+#define _ASCII_BACKSPACE            0x08
+#define _ASCII_TAB                  0x09
+#define _ASCII_ESCAPE               0x1B
+#define _ASCII_SPACE                0x20
+#define _ASCII_LEFT_BRACKET         0x5B
+#define _ASCII_DEL                  0x7F
+#define _ASCII_UP_ARROW             'A'
+#define _ASCII_DOWN_ARROW           'B'
+#define _ASCII_RIGHT_ARROW          'C'
+#define _ASCII_LEFT_ARROW           'D'
+#define _ASCII_NEWLINE              '\n'
+
+extern UINT32               AcpiGbl_NextCmdNum;
+
+/* Erase a single character on the input command line */
+
+#define ACPI_CLEAR_CHAR() \
+    putchar (_ASCII_BACKSPACE); \
+    putchar (_ASCII_SPACE); \
+    putchar (_ASCII_BACKSPACE);
+
+/* Backup cursor by Count positions */
+
+#define ACPI_BACKUP_CURSOR(i, Count) \
+    for (i = 0; i < (Count); i++) \
+        {putchar (_ASCII_BACKSPACE);}
+
+
+/******************************************************************************
+ *
+ * FUNCTION:    AcpiAcClearLine
+ *
+ * PARAMETERS:  EndOfLine           - Current end-of-line index
+ *              CursorPosition      - Current cursor position within line
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Clear the entire command line the hard way, but probably the
+ *              most portable.
+ *
+ *****************************************************************************/
+
+static void
+AcpiAcClearLine (
+    UINT32                  EndOfLine,
+    UINT32                  CursorPosition)
+{
+    UINT32                  i;
+
+
+    if (CursorPosition < EndOfLine)
+    {
+        /* Clear line from current position to end of line */
+
+        for (i = 0; i < (EndOfLine - CursorPosition); i++)
+        {
+            putchar (' ');
+        }
+    }
+
+    /* Clear the entire line */
+
+    for (; EndOfLine > 0; EndOfLine--)
+    {
+        ACPI_CLEAR_CHAR ();
+    }
+}
+
+
+/******************************************************************************
+ *
+ * FUNCTION:    AcpiOsGetLine
+ *
+ * PARAMETERS:  Buffer              - Where to return the command line
+ *              BufferLength        - Maximum length of Buffer
+ *              BytesRead           - Where the actual byte count is returned
+ *
+ * RETURN:      Status and actual bytes read
+ *
+ * DESCRIPTION: Get the next input line from the terminal. NOTE: terminal
+ *              is expected to be in a mode that supports line-editing (raw,
+ *              noecho). This function is intended to be very portable. Also,
+ *              it uses the history support implemented in the AML debugger.
+ *
+ *****************************************************************************/
+
+ACPI_STATUS
+AcpiOsGetLine (
+    char                    *Buffer,
+    UINT32                  BufferLength,
+    UINT32                  *BytesRead)
+{
+    char                    *NextCommand;
+    UINT32                  MaxCommandIndex = AcpiGbl_NextCmdNum - 1;
+    UINT32                  CurrentCommandIndex = MaxCommandIndex;
+    UINT32                  PreviousCommandIndex = MaxCommandIndex;
+    int                     InputChar;
+    UINT32                  CursorPosition = 0;
+    UINT32                  EndOfLine = 0;
+    UINT32                  i;
+
+
+    /* Always clear the line buffer before we read a new line */
+
+    memset (Buffer, 0, BufferLength);
+
+    /*
+     * This loop gets one character at a time (except for esc sequences)
+     * until a newline or error is detected.
+     *
+     * Note: Don't attempt to write terminal control ESC sequences, even
+     * though it makes certain things more difficult.
+     */
+    while (1)
+    {
+        if (EndOfLine >= (BufferLength - 1))
+        {
+            return (AE_BUFFER_OVERFLOW);
+        }
+
+        InputChar = getchar ();
+        switch (InputChar)
+        {
+        default: /* This is the normal character case */
+
+            /* Echo the character (at EOL) and copy it to the line buffer */
+
+            if (EndOfLine == CursorPosition)
+            {
+                putchar (InputChar);
+                Buffer[EndOfLine] = (char) InputChar;
+
+                EndOfLine++;
+                CursorPosition++;
+                Buffer[EndOfLine] = 0;
+                continue;
+            }
+
+            /* Insert character into the middle of the buffer */
+
+            memmove (&Buffer[CursorPosition + 1], &Buffer[CursorPosition],
+                (EndOfLine - CursorPosition + 1));
+
+            Buffer [CursorPosition] = (char) InputChar;
+            Buffer [EndOfLine + 1] = 0;
+
+            /* Display the new part of line starting at the new character */
+
+            fprintf (stdout, "%s", &Buffer[CursorPosition]);
+
+            /* Restore cursor */
+
+            ACPI_BACKUP_CURSOR (i, EndOfLine - CursorPosition);
+            CursorPosition++;
+            EndOfLine++;
+            continue;
+
+        case _ASCII_DEL: /* Backspace key */
+
+            if (!EndOfLine) /* Any characters on the command line? */
+            {
+                continue;
+            }
+
+            if (EndOfLine == CursorPosition) /* Erase the final character */
+            {
+                ACPI_CLEAR_CHAR ();
+                EndOfLine--;
+                CursorPosition--;
+                continue;
+            }
+
+            if (!CursorPosition) /* Do not backup beyond start of line */
+            {
+                continue;
+            }
+
+            /* Remove the character from the line */
+
+            memmove (&Buffer[CursorPosition - 1], &Buffer[CursorPosition],
+                (EndOfLine - CursorPosition + 1));
+
+            /* Display the new part of line starting at the new character */
+
+            putchar (_ASCII_BACKSPACE);
+            fprintf (stdout, "%s ", &Buffer[CursorPosition - 1]);
+
+            /* Restore cursor */
+
+            ACPI_BACKUP_CURSOR (i, EndOfLine - CursorPosition + 1);
+            EndOfLine--;
+
+            if (CursorPosition > 0)
+            {
+                CursorPosition--;
+            }
+            continue;
+
+        case _ASCII_NEWLINE: /* Normal exit case at end of command line */
+        case _ASCII_NUL:
+
+            /* Return the number of bytes in the command line string */
+
+            if (BytesRead)
+            {
+                *BytesRead = EndOfLine;
+            }
+
+            /* Echo, terminate string buffer, and exit */
+
+            putchar (InputChar);
+            Buffer[EndOfLine] = 0;
+            return (AE_OK);
+
+        case _ASCII_TAB:
+
+            /* Ignore */
+
+            continue;
+
+        case EOF:
+
+            return (AE_ERROR);
+
+        case _ASCII_ESCAPE:
+
+            /* Check for escape sequences of the form "ESC[x" */
+
+            InputChar = getchar ();
+            if (InputChar != _ASCII_LEFT_BRACKET)
+            {
+                continue; /* Ignore this ESC, does not have the '[' */
+            }
+
+            /* Get the code following the ESC [ */
+
+            InputChar = getchar (); /* Backup one character */
+            switch (InputChar)
+            {
+            case _ASCII_LEFT_ARROW:
+
+                if (CursorPosition > 0)
+                {
+                    putchar (_ASCII_BACKSPACE);
+                    CursorPosition--;
+                }
+                continue;
+
+            case _ASCII_RIGHT_ARROW:
+                /*
+                 * Move one character forward. Do this without sending
+                 * ESC sequence to the terminal for max portability.
+                 */
+                if (CursorPosition < EndOfLine)
+                {
+                    /* Backup to start of line and print the entire line */
+
+                    ACPI_BACKUP_CURSOR (i, CursorPosition);
+                    fprintf (stdout, "%s", Buffer);
+
+                    /* Backup to where the cursor should be */
+
+                    CursorPosition++;
+                    ACPI_BACKUP_CURSOR (i, EndOfLine - CursorPosition);
+                }
+                continue;
+
+            case _ASCII_UP_ARROW:
+
+                /* If no commands available or at start of history list, ignore */
+
+                if (!CurrentCommandIndex)
+                {
+                    continue;
+                }
+
+                /* Manage our up/down progress */
+
+                if (CurrentCommandIndex > PreviousCommandIndex)
+                {
+                    CurrentCommandIndex = PreviousCommandIndex;
+                }
+
+                /* Get the historical command from the debugger */
+
+                NextCommand = AcpiDbGetHistoryByIndex (CurrentCommandIndex);
+                if (!NextCommand)
+                {
+                    return (AE_ERROR);
+                }
+
+                /* Make this the active command and echo it */
+
+                AcpiAcClearLine (EndOfLine, CursorPosition);
+                strcpy (Buffer, NextCommand);
+                fprintf (stdout, "%s", Buffer);
+                EndOfLine = CursorPosition = strlen (Buffer);
+
+                PreviousCommandIndex = CurrentCommandIndex;
+                CurrentCommandIndex--;
+                continue;
+
+            case _ASCII_DOWN_ARROW:
+
+                if (!MaxCommandIndex) /* Any commands available? */
+                {
+                    continue;
+                }
+
+                /* Manage our up/down progress */
+
+                if (CurrentCommandIndex < PreviousCommandIndex)
+                {
+                    CurrentCommandIndex = PreviousCommandIndex;
+                }
+
+                /* If we are the end of the history list, output a clear new line */
+
+                if ((CurrentCommandIndex + 1) > MaxCommandIndex)
+                {
+                    AcpiAcClearLine (EndOfLine, CursorPosition);
+                    EndOfLine = CursorPosition = 0;
+                    PreviousCommandIndex = CurrentCommandIndex;
+                    continue;
+                }
+
+                PreviousCommandIndex = CurrentCommandIndex;
+                CurrentCommandIndex++;
+
+                 /* Get the historical command from the debugger */
+
+                NextCommand = AcpiDbGetHistoryByIndex (CurrentCommandIndex);
+                if (!NextCommand)
+                {
+                    return (AE_ERROR);
+                }
+
+                /* Make this the active command and echo it */
+
+                AcpiAcClearLine (EndOfLine, CursorPosition);
+                strcpy (Buffer, NextCommand);
+                fprintf (stdout, "%s", Buffer);
+                EndOfLine = CursorPosition = strlen (Buffer);
+                continue;
+
+            case 0x31:
+            case 0x32:
+            case 0x33:
+            case 0x34:
+            case 0x35:
+            case 0x36:
+                /*
+                 * Ignore the various keys like insert/delete/home/end, etc.
+                 * But we must eat the final character of the ESC sequence.
+                 */
+                InputChar = getchar ();
+                continue;
+
+            default:
+
+                /* Ignore random escape sequences that we don't care about */
+
+                continue;
+            }
+            continue;
+        }
+    }
+}
diff --git a/usr/src/cmd/acpi/common/adfile.c b/usr/src/cmd/acpi/common/adfile.c
new file mode 100644
index 0000000000..78f29fd9f5
--- /dev/null
+++ b/usr/src/cmd/acpi/common/adfile.c
@@ -0,0 +1,358 @@
+/******************************************************************************
+ *
+ * Module Name: adfile - Application-level disassembler file support routines
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2016, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include "aslcompiler.h"
+#include "acpi.h"
+#include "accommon.h"
+#include "acapps.h"
+
+#include <stdio.h>
+
+
+#define _COMPONENT          ACPI_TOOLS
+        ACPI_MODULE_NAME    ("adfile")
+
+/* Local prototypes */
+
+static INT32
+AdWriteBuffer (
+    char                    *Filename,
+    char                    *Buffer,
+    UINT32                  Length);
+
+static char                 FilenameBuf[20];
+
+
+/******************************************************************************
+ *
+ * FUNCTION:    AfGenerateFilename
+ *
+ * PARAMETERS:  Prefix              - prefix string
+ *              TableId             - The table ID
+ *
+ * RETURN:      Pointer to the completed string
+ *
+ * DESCRIPTION: Build an output filename from an ACPI table ID string
+ *
+ ******************************************************************************/
+
+char *
+AdGenerateFilename (
+    char                    *Prefix,
+    char                    *TableId)
+{
+    UINT32                  i;
+    UINT32                  j;
+
+
+    for (i = 0; Prefix[i]; i++)
+    {
+        FilenameBuf[i] = Prefix[i];
+    }
+
+    FilenameBuf[i] = '_';
+    i++;
+
+    for (j = 0; j < 8 && (TableId[j] != ' ') && (TableId[j] != 0); i++, j++)
+    {
+        FilenameBuf[i] = TableId[j];
+    }
+
+    FilenameBuf[i] = 0;
+    strcat (FilenameBuf, FILE_SUFFIX_BINARY_TABLE);
+    return (FilenameBuf);
+}
+
+
+/******************************************************************************
+ *
+ * FUNCTION:    AfWriteBuffer
+ *
+ * PARAMETERS:  Filename            - name of file
+ *              Buffer              - data to write
+ *              Length              - length of data
+ *
+ * RETURN:      Actual number of bytes written
+ *
+ * DESCRIPTION: Open a file and write out a single buffer
+ *
+ ******************************************************************************/
+
+static INT32
+AdWriteBuffer (
+    char                    *Filename,
+    char                    *Buffer,
+    UINT32                  Length)
+{
+    FILE                    *File;
+    ACPI_SIZE               Actual;
+
+
+    File = fopen (Filename, "wb");
+    if (!File)
+    {
+        printf ("Could not open file %s\n", Filename);
+        return (-1);
+    }
+
+    Actual = fwrite (Buffer, 1, (size_t) Length, File);
+    if (Actual != Length)
+    {
+        printf ("Could not write to file %s\n", Filename);
+    }
+
+    fclose (File);
+    return ((INT32) Actual);
+}
+
+
+/******************************************************************************
+ *
+ * FUNCTION:    AfWriteTable
+ *
+ * PARAMETERS:  Table               - pointer to the ACPI table
+ *              Length              - length of the table
+ *              TableName           - the table signature
+ *              OemTableID          - from the table header
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Dump the loaded tables to a file (or files)
+ *
+ ******************************************************************************/
+
+void
+AdWriteTable (
+    ACPI_TABLE_HEADER       *Table,
+    UINT32                  Length,
+    char                    *TableName,
+    char                    *OemTableId)
+{
+    char                    *Filename;
+
+
+    Filename = AdGenerateFilename (TableName, OemTableId);
+    AdWriteBuffer (Filename, (char *) Table, Length);
+
+    AcpiOsPrintf ("Table [%s] written to \"%s\"\n", TableName, Filename);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    FlGenerateFilename
+ *
+ * PARAMETERS:  InputFilename       - Original ASL source filename
+ *              Suffix              - New extension.
+ *
+ * RETURN:      New filename containing the original base + the new suffix
+ *
+ * DESCRIPTION: Generate a new filename from the ASL source filename and a new
+ *              extension. Used to create the *.LST, *.TXT, etc. files.
+ *
+ ******************************************************************************/
+
+char *
+FlGenerateFilename (
+    char                    *InputFilename,
+    char                    *Suffix)
+{
+    char                    *Position;
+    char                    *NewFilename;
+    char                    *DirectoryPosition;
+
+
+    /*
+     * Copy the original filename to a new buffer. Leave room for the worst
+     * case where we append the suffix, an added dot and the null terminator.
+     */
+    NewFilename = UtStringCacheCalloc ((ACPI_SIZE)
+        strlen (InputFilename) + strlen (Suffix) + 2);
+    if (!NewFilename)
+    {
+        return (NULL);
+    }
+
+    strcpy (NewFilename, InputFilename);
+
+    /* Try to find the last dot in the filename */
+
+    DirectoryPosition = strrchr (NewFilename, '/');
+    Position = strrchr (NewFilename, '.');
+
+    if (Position && (Position > DirectoryPosition))
+    {
+        /* Tack on the new suffix */
+
+        Position++;
+        *Position = 0;
+        strcat (Position, Suffix);
+    }
+    else
+    {
+        /* No dot, add one and then the suffix */
+
+        strcat (NewFilename, ".");
+        strcat (NewFilename, Suffix);
+    }
+
+    return (NewFilename);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    FlStrdup
+ *
+ * DESCRIPTION: Local strdup function
+ *
+ ******************************************************************************/
+
+static char *
+FlStrdup (
+    char                *String)
+{
+    char                *NewString;
+
+
+    NewString = UtStringCacheCalloc ((ACPI_SIZE) strlen (String) + 1);
+    if (!NewString)
+    {
+        return (NULL);
+    }
+
+    strcpy (NewString, String);
+    return (NewString);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    FlSplitInputPathname
+ *
+ * PARAMETERS:  InputFilename       - The user-specified ASL source file to be
+ *                                    compiled
+ *              OutDirectoryPath    - Where the directory path prefix is
+ *                                    returned
+ *              OutFilename         - Where the filename part is returned
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Split the input path into a directory and filename part
+ *              1) Directory part used to open include files
+ *              2) Filename part used to generate output filenames
+ *
+ ******************************************************************************/
+
+ACPI_STATUS
+FlSplitInputPathname (
+    char                    *InputPath,
+    char                    **OutDirectoryPath,
+    char                    **OutFilename)
+{
+    char                    *Substring;
+    char                    *DirectoryPath;
+    char                    *Filename;
+
+
+    if (OutDirectoryPath)
+    {
+        *OutDirectoryPath = NULL;
+    }
+
+    if (!InputPath)
+    {
+        return (AE_OK);
+    }
+
+    /* Get the path to the input filename's directory */
+
+    DirectoryPath = FlStrdup (InputPath);
+    if (!DirectoryPath)
+    {
+        return (AE_NO_MEMORY);
+    }
+
+    /* Convert backslashes to slashes in the entire path */
+
+    UtConvertBackslashes (DirectoryPath);
+
+    /* Backup to last slash or colon */
+
+    Substring = strrchr (DirectoryPath, '/');
+    if (!Substring)
+    {
+        Substring = strrchr (DirectoryPath, ':');
+    }
+
+    /* Extract the simple filename */
+
+    if (!Substring)
+    {
+        Filename = FlStrdup (DirectoryPath);
+        DirectoryPath[0] = 0;
+    }
+    else
+    {
+        Filename = FlStrdup (Substring + 1);
+        *(Substring+1) = 0;
+    }
+
+    if (!Filename)
+    {
+        return (AE_NO_MEMORY);
+    }
+
+    if (OutDirectoryPath)
+    {
+        *OutDirectoryPath = DirectoryPath;
+    }
+
+    if (OutFilename)
+    {
+        *OutFilename = Filename;
+        return (AE_OK);
+    }
+
+    return (AE_OK);
+}
diff --git a/usr/src/cmd/acpi/common/adisasm.c b/usr/src/cmd/acpi/common/adisasm.c
new file mode 100644
index 0000000000..bb83ab6f4c
--- /dev/null
+++ b/usr/src/cmd/acpi/common/adisasm.c
@@ -0,0 +1,656 @@
+/******************************************************************************
+ *
+ * Module Name: adisasm - Application-level disassembler routines
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2016, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include "aslcompiler.h"
+#include "amlcode.h"
+#include "acdisasm.h"
+#include "acdispat.h"
+#include "acnamesp.h"
+#include "acparser.h"
+#include "acapps.h"
+
+#include <stdio.h>
+
+
+#define _COMPONENT          ACPI_TOOLS
+        ACPI_MODULE_NAME    ("adisasm")
+
+/* Local prototypes */
+
+static ACPI_STATUS
+AdDoExternalFileList (
+    char                    *Filename);
+
+static ACPI_STATUS
+AdDisassembleOneTable (
+    ACPI_TABLE_HEADER       *Table,
+    FILE                    *File,
+    char                    *Filename,
+    char                    *DisasmFilename);
+
+static ACPI_STATUS
+AdReparseOneTable (
+    ACPI_TABLE_HEADER       *Table,
+    FILE                    *File,
+    ACPI_OWNER_ID           OwnerId);
+
+
+ACPI_TABLE_DESC             LocalTables[1];
+ACPI_PARSE_OBJECT           *AcpiGbl_ParseOpRoot;
+
+
+/* Stubs for everything except ASL compiler */
+
+#ifndef ACPI_ASL_COMPILER
+BOOLEAN
+AcpiDsIsResultUsed (
+    ACPI_PARSE_OBJECT       *Op,
+    ACPI_WALK_STATE         *WalkState)
+{
+    return (TRUE);
+}
+
+ACPI_STATUS
+AcpiDsMethodError (
+    ACPI_STATUS             Status,
+    ACPI_WALK_STATE         *WalkState)
+{
+    return (Status);
+}
+#endif
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AdInitialize
+ *
+ * PARAMETERS:  None
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: ACPICA and local initialization
+ *
+ ******************************************************************************/
+
+ACPI_STATUS
+AdInitialize (
+    void)
+{
+    ACPI_STATUS             Status;
+
+
+    /* ACPICA subsystem initialization */
+
+    Status = AcpiOsInitialize ();
+    if (ACPI_FAILURE (Status))
+    {
+        return (Status);
+    }
+
+    Status = AcpiUtInitGlobals ();
+    if (ACPI_FAILURE (Status))
+    {
+        return (Status);
+    }
+
+    Status = AcpiUtMutexInitialize ();
+    if (ACPI_FAILURE (Status))
+    {
+        return (Status);
+    }
+
+    Status = AcpiNsRootInitialize ();
+    if (ACPI_FAILURE (Status))
+    {
+        return (Status);
+    }
+
+    /* Setup the Table Manager (cheat - there is no RSDT) */
+
+    AcpiGbl_RootTableList.MaxTableCount = 1;
+    AcpiGbl_RootTableList.CurrentTableCount = 0;
+    AcpiGbl_RootTableList.Tables = LocalTables;
+
+    return (Status);
+}
+
+
+/******************************************************************************
+ *
+ * FUNCTION:    AdAmlDisassemble
+ *
+ * PARAMETERS:  Filename            - AML input filename
+ *              OutToFile           - TRUE if output should go to a file
+ *              Prefix              - Path prefix for output
+ *              OutFilename         - where the filename is returned
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Disassembler entry point. Disassemble an entire ACPI table.
+ *
+ *****************************************************************************/
+
+ACPI_STATUS
+AdAmlDisassemble (
+    BOOLEAN                 OutToFile,
+    char                    *Filename,
+    char                    *Prefix,
+    char                    **OutFilename)
+{
+    ACPI_STATUS             Status;
+    char                    *DisasmFilename = NULL;
+    FILE                    *File = NULL;
+    ACPI_TABLE_HEADER       *Table = NULL;
+    ACPI_NEW_TABLE_DESC     *ListHead = NULL;
+
+
+    /*
+     * Input: AML code from either a file or via GetTables (memory or
+     * registry)
+     */
+    if (Filename)
+    {
+        /* Get the list of all AML tables in the file */
+
+        Status = AcGetAllTablesFromFile (Filename,
+            ACPI_GET_ALL_TABLES, &ListHead);
+        if (ACPI_FAILURE (Status))
+        {
+            AcpiOsPrintf ("Could not get ACPI tables from %s, %s\n",
+                Filename, AcpiFormatException (Status));
+            return (Status);
+        }
+
+        /* Process any user-specified files for external objects */
+
+        Status = AdDoExternalFileList (Filename);
+        if (ACPI_FAILURE (Status))
+        {
+            return (Status);
+        }
+    }
+    else
+    {
+        Status = AdGetLocalTables ();
+        if (ACPI_FAILURE (Status))
+        {
+            AcpiOsPrintf ("Could not get ACPI tables, %s\n",
+                AcpiFormatException (Status));
+            return (Status);
+        }
+
+        if (!AcpiGbl_DmOpt_Disasm)
+        {
+            return (AE_OK);
+        }
+
+        /* Obtained the local tables, just disassemble the DSDT */
+
+        Status = AcpiGetTable (ACPI_SIG_DSDT, 0, &Table);
+        if (ACPI_FAILURE (Status))
+        {
+            AcpiOsPrintf ("Could not get DSDT, %s\n",
+                AcpiFormatException (Status));
+            return (Status);
+        }
+
+        AcpiOsPrintf ("\nDisassembly of DSDT\n");
+        Prefix = AdGenerateFilename ("dsdt", Table->OemTableId);
+    }
+
+    /*
+     * Output: ASL code. Redirect to a file if requested
+     */
+    if (OutToFile)
+    {
+        /* Create/Open a disassembly output file */
+
+        DisasmFilename = FlGenerateFilename (Prefix, FILE_SUFFIX_DISASSEMBLY);
+        if (!DisasmFilename)
+        {
+            fprintf (stderr, "Could not generate output filename\n");
+            Status = AE_ERROR;
+            goto Cleanup;
+        }
+
+        File = fopen (DisasmFilename, "w+");
+        if (!File)
+        {
+            fprintf (stderr, "Could not open output file %s\n",
+                DisasmFilename);
+            Status = AE_ERROR;
+            goto Cleanup;
+        }
+
+        AcpiOsRedirectOutput (File);
+    }
+
+    *OutFilename = DisasmFilename;
+
+    /* Disassemble all AML tables within the file */
+
+    while (ListHead)
+    {
+        Status = AdDisassembleOneTable (ListHead->Table,
+            File, Filename, DisasmFilename);
+        if (ACPI_FAILURE (Status))
+        {
+            break;
+        }
+
+        ListHead = ListHead->Next;
+    }
+
+Cleanup:
+
+    if (Table &&
+        !AcpiGbl_ForceAmlDisassembly &&
+        !AcpiUtIsAmlTable (Table))
+    {
+        ACPI_FREE (Table);
+    }
+
+    if (File)
+    {
+        fclose (File);
+        AcpiOsRedirectOutput (stdout);
+    }
+
+    AcpiPsDeleteParseTree (AcpiGbl_ParseOpRoot);
+    AcpiGbl_ParseOpRoot = NULL;
+    return (Status);
+}
+
+
+/******************************************************************************
+ *
+ * FUNCTION:    AdDisassembleOneTable
+ *
+ * PARAMETERS:  Table               - Raw AML table
+ *              File                - Pointer for the input file
+ *              Filename            - AML input filename
+ *              DisasmFilename      - Output filename
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Disassemble a single ACPI table. AML or data table.
+ *
+ *****************************************************************************/
+
+static ACPI_STATUS
+AdDisassembleOneTable (
+    ACPI_TABLE_HEADER       *Table,
+    FILE                    *File,
+    char                    *Filename,
+    char                    *DisasmFilename)
+{
+    ACPI_STATUS             Status;
+    ACPI_OWNER_ID           OwnerId;
+
+
+    /* ForceAmlDisassembly means to assume the table contains valid AML */
+
+    if (!AcpiGbl_ForceAmlDisassembly && !AcpiUtIsAmlTable (Table))
+    {
+        AdDisassemblerHeader (Filename, ACPI_IS_DATA_TABLE);
+
+        /* This is a "Data Table" (non-AML table) */
+
+        AcpiOsPrintf (" * ACPI Data Table [%4.4s]\n *\n",
+            Table->Signature);
+        AcpiOsPrintf (" * Format: [HexOffset DecimalOffset ByteLength]  "
+            "FieldName : FieldValue\n */\n\n");
+
+        AcpiDmDumpDataTable (Table);
+        fprintf (stderr, "Acpi Data Table [%4.4s] decoded\n",
+            Table->Signature);
+
+        if (File)
+        {
+            fprintf (stderr, "Formatted output:  %s - %u bytes\n",
+                DisasmFilename, CmGetFileSize (File));
+        }
+
+        return (AE_OK);
+    }
+
+    /*
+     * This is an AML table (DSDT or SSDT).
+     * Always parse the tables, only option is what to display
+     */
+    Status = AdParseTable (Table, &OwnerId, TRUE, FALSE);
+    if (ACPI_FAILURE (Status))
+    {
+        AcpiOsPrintf ("Could not parse ACPI tables, %s\n",
+            AcpiFormatException (Status));
+        return (Status);
+    }
+
+    /* Debug output, namespace and parse tree */
+
+    if (AslCompilerdebug && File)
+    {
+        AcpiOsPrintf ("/**** Before second load\n");
+
+        NsSetupNamespaceListing (File);
+        NsDisplayNamespace ();
+
+        AcpiOsPrintf ("*****/\n");
+    }
+
+    /* Load namespace from names created within control methods */
+
+    AcpiDmFinishNamespaceLoad (AcpiGbl_ParseOpRoot,
+        AcpiGbl_RootNode, OwnerId);
+
+    /*
+     * Cross reference the namespace here, in order to
+     * generate External() statements
+     */
+    AcpiDmCrossReferenceNamespace (AcpiGbl_ParseOpRoot,
+        AcpiGbl_RootNode, OwnerId);
+
+    if (AslCompilerdebug)
+    {
+        AcpiDmDumpTree (AcpiGbl_ParseOpRoot);
+    }
+
+    /* Find possible calls to external control methods */
+
+    AcpiDmFindOrphanMethods (AcpiGbl_ParseOpRoot);
+
+    /*
+     * If we found any external control methods, we must reparse
+     * the entire tree with the new information (namely, the
+     * number of arguments per method)
+     */
+    if (AcpiDmGetExternalMethodCount ())
+    {
+        Status = AdReparseOneTable (Table, File, OwnerId);
+        if (ACPI_FAILURE (Status))
+        {
+            return (Status);
+        }
+    }
+
+    /*
+     * Now that the namespace is finalized, we can perform namespace
+     * transforms.
+     *
+     * 1) Convert fixed-offset references to resource descriptors
+     *    to symbolic references (Note: modifies namespace)
+     */
+    AcpiDmConvertResourceIndexes (AcpiGbl_ParseOpRoot, AcpiGbl_RootNode);
+
+    /* Optional displays */
+
+    if (AcpiGbl_DmOpt_Disasm)
+    {
+        /* This is the real disassembly */
+
+        AdDisplayTables (Filename, Table);
+
+        /* Dump hex table if requested (-vt) */
+
+        AcpiDmDumpDataTable (Table);
+
+        fprintf (stderr, "Disassembly completed\n");
+        if (File)
+        {
+            fprintf (stderr, "ASL Output:    %s - %u bytes\n",
+                DisasmFilename, CmGetFileSize (File));
+        }
+
+        if (Gbl_MapfileFlag)
+        {
+            fprintf (stderr, "%14s %s - %u bytes\n",
+                Gbl_Files[ASL_FILE_MAP_OUTPUT].ShortDescription,
+                Gbl_Files[ASL_FILE_MAP_OUTPUT].Filename,
+                FlGetFileSize (ASL_FILE_MAP_OUTPUT));
+        }
+    }
+
+    return (AE_OK);
+}
+
+
+/******************************************************************************
+ *
+ * FUNCTION:    AdReparseOneTable
+ *
+ * PARAMETERS:  Table               - Raw AML table
+ *              File                - Pointer for the input file
+ *              OwnerId             - ID for this table
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Reparse a table that has already been loaded. Used to
+ *              integrate information about external control methods.
+ *              These methods may have been previously parsed incorrectly.
+ *
+ *****************************************************************************/
+
+static ACPI_STATUS
+AdReparseOneTable (
+    ACPI_TABLE_HEADER       *Table,
+    FILE                    *File,
+    ACPI_OWNER_ID           OwnerId)
+{
+    ACPI_STATUS             Status;
+
+
+    fprintf (stderr,
+        "\nFound %u external control methods, "
+        "reparsing with new information\n",
+        AcpiDmGetExternalMethodCount ());
+
+    /* Reparse, rebuild namespace */
+
+    AcpiPsDeleteParseTree (AcpiGbl_ParseOpRoot);
+    AcpiGbl_ParseOpRoot = NULL;
+    AcpiNsDeleteNamespaceSubtree (AcpiGbl_RootNode);
+
+    AcpiGbl_RootNode                    = NULL;
+    AcpiGbl_RootNodeStruct.Name.Integer = ACPI_ROOT_NAME;
+    AcpiGbl_RootNodeStruct.DescriptorType = ACPI_DESC_TYPE_NAMED;
+    AcpiGbl_RootNodeStruct.Type         = ACPI_TYPE_DEVICE;
+    AcpiGbl_RootNodeStruct.Parent       = NULL;
+    AcpiGbl_RootNodeStruct.Child        = NULL;
+    AcpiGbl_RootNodeStruct.Peer         = NULL;
+    AcpiGbl_RootNodeStruct.Object       = NULL;
+    AcpiGbl_RootNodeStruct.Flags        = 0;
+
+    Status = AcpiNsRootInitialize ();
+    if (ACPI_FAILURE (Status))
+    {
+        return (Status);
+    }
+
+    /* New namespace, add the external definitions first */
+
+    AcpiDmAddExternalsToNamespace ();
+
+    /* Parse the table again. No need to reload it, however */
+
+    Status = AdParseTable (Table, NULL, FALSE, FALSE);
+    if (ACPI_FAILURE (Status))
+    {
+        AcpiOsPrintf ("Could not parse ACPI tables, %s\n",
+            AcpiFormatException (Status));
+        return (Status);
+    }
+
+    /* Cross reference the namespace again */
+
+    AcpiDmFinishNamespaceLoad (AcpiGbl_ParseOpRoot,
+        AcpiGbl_RootNode, OwnerId);
+
+    AcpiDmCrossReferenceNamespace (AcpiGbl_ParseOpRoot,
+        AcpiGbl_RootNode, OwnerId);
+
+    /* Debug output - namespace and parse tree */
+
+    if (AslCompilerdebug)
+    {
+        AcpiOsPrintf ("/**** After second load and resource conversion\n");
+        if (File)
+        {
+            NsSetupNamespaceListing (File);
+            NsDisplayNamespace ();
+        }
+
+        AcpiOsPrintf ("*****/\n");
+        AcpiDmDumpTree (AcpiGbl_ParseOpRoot);
+    }
+
+    return (AE_OK);
+}
+
+
+/******************************************************************************
+ *
+ * FUNCTION:    AdDoExternalFileList
+ *
+ * PARAMETERS:  Filename            - Input file for the table
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Process all tables found in the -e external files list
+ *
+ *****************************************************************************/
+
+static ACPI_STATUS
+AdDoExternalFileList (
+    char                    *Filename)
+{
+    ACPI_EXTERNAL_FILE      *ExternalFileList;
+    char                    *ExternalFilename;
+    ACPI_NEW_TABLE_DESC     *ExternalListHead = NULL;
+    ACPI_STATUS             Status;
+    ACPI_STATUS             GlobalStatus = AE_OK;
+    ACPI_OWNER_ID           OwnerId;
+
+
+    /*
+     * External filenames are specified on the command line like this:
+     * Example: iasl -e file1,file2,file3 -d xxx.aml
+     */
+    ExternalFileList = AcpiGbl_ExternalFileList;
+
+    /* Process each external file */
+
+    while (ExternalFileList)
+    {
+        ExternalFilename = ExternalFileList->Path;
+        if (!strcmp (ExternalFilename, Filename))
+        {
+            /* Next external file */
+
+            ExternalFileList = ExternalFileList->Next;
+            continue;
+        }
+
+        AcpiOsPrintf ("External object resolution file %16s\n",
+            ExternalFilename);
+
+        Status = AcGetAllTablesFromFile (
+            ExternalFilename, ACPI_GET_ONLY_AML_TABLES, &ExternalListHead);
+        if (ACPI_FAILURE (Status))
+        {
+            if (Status == AE_TYPE)
+            {
+                ExternalFileList = ExternalFileList->Next;
+                GlobalStatus = AE_TYPE;
+                Status = AE_OK;
+                continue;
+            }
+
+            return (Status);
+        }
+
+        /* Load external tables for symbol resolution */
+
+        while (ExternalListHead)
+        {
+            Status = AdParseTable (
+                ExternalListHead->Table, &OwnerId, TRUE, TRUE);
+            if (ACPI_FAILURE (Status))
+            {
+                AcpiOsPrintf ("Could not parse external ACPI tables, %s\n",
+                    AcpiFormatException (Status));
+                return (Status);
+            }
+
+            /*
+             * Load namespace from names created within control methods
+             * Set owner id of nodes in external table
+             */
+            AcpiDmFinishNamespaceLoad (AcpiGbl_ParseOpRoot,
+                AcpiGbl_RootNode, OwnerId);
+            AcpiPsDeleteParseTree (AcpiGbl_ParseOpRoot);
+
+            ExternalListHead = ExternalListHead->Next;
+        }
+
+        /* Next external file */
+
+        ExternalFileList = ExternalFileList->Next;
+    }
+
+    if (ACPI_FAILURE (GlobalStatus))
+    {
+        return (GlobalStatus);
+    }
+
+    /* Clear external list generated by Scope in external tables */
+
+    if (AcpiGbl_ExternalFileList)
+    {
+        AcpiDmClearExternalList ();
+    }
+
+    /* Load any externals defined in the optional external ref file */
+
+    AcpiDmGetExternalsFromFile ();
+    return (AE_OK);
+}
diff --git a/usr/src/cmd/acpi/common/adwalk.c b/usr/src/cmd/acpi/common/adwalk.c
new file mode 100644
index 0000000000..714d837d5e
--- /dev/null
+++ b/usr/src/cmd/acpi/common/adwalk.c
@@ -0,0 +1,1138 @@
+/******************************************************************************
+ *
+ * Module Name: adwalk - Application-level disassembler parse tree walk routines
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2016, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include "acpi.h"
+#include "accommon.h"
+#include "acparser.h"
+#include "amlcode.h"
+#include "acdisasm.h"
+#include "acdispat.h"
+#include "acnamesp.h"
+#include "acapps.h"
+
+
+#define _COMPONENT          ACPI_TOOLS
+        ACPI_MODULE_NAME    ("adwalk")
+
+/*
+ * aslmap - opcode mappings and reserved method names
+ */
+ACPI_OBJECT_TYPE
+AslMapNamedOpcodeToDataType (
+    UINT16                  Opcode);
+
+/* Local prototypes */
+
+static ACPI_STATUS
+AcpiDmFindOrphanDescending (
+    ACPI_PARSE_OBJECT       *Op,
+    UINT32                  Level,
+    void                    *Context);
+
+static ACPI_STATUS
+AcpiDmDumpDescending (
+    ACPI_PARSE_OBJECT       *Op,
+    UINT32                  Level,
+    void                    *Context);
+
+static ACPI_STATUS
+AcpiDmXrefDescendingOp (
+    ACPI_PARSE_OBJECT       *Op,
+    UINT32                  Level,
+    void                    *Context);
+
+static ACPI_STATUS
+AcpiDmCommonAscendingOp (
+    ACPI_PARSE_OBJECT       *Op,
+    UINT32                  Level,
+    void                    *Context);
+
+static ACPI_STATUS
+AcpiDmLoadDescendingOp (
+    ACPI_PARSE_OBJECT       *Op,
+    UINT32                  Level,
+    void                    *Context);
+
+static UINT32
+AcpiDmInspectPossibleArgs (
+    UINT32                  CurrentOpArgCount,
+    UINT32                  TargetCount,
+    ACPI_PARSE_OBJECT       *Op);
+
+static ACPI_STATUS
+AcpiDmResourceDescendingOp (
+    ACPI_PARSE_OBJECT       *Op,
+    UINT32                  Level,
+    void                    *Context);
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiDmDumpTree
+ *
+ * PARAMETERS:  Origin              - Starting object
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Parse tree walk to format and output the nodes
+ *
+ ******************************************************************************/
+
+void
+AcpiDmDumpTree (
+    ACPI_PARSE_OBJECT       *Origin)
+{
+    ACPI_OP_WALK_INFO       Info;
+
+
+    if (!Origin)
+    {
+        return;
+    }
+
+    AcpiOsPrintf ("/*\nAML Parse Tree\n\n");
+    Info.Flags = 0;
+    Info.Count = 0;
+    Info.Level = 0;
+    Info.WalkState = NULL;
+
+    AcpiDmWalkParseTree (Origin, AcpiDmDumpDescending, NULL, &Info);
+    AcpiOsPrintf ("*/\n\n");
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiDmFindOrphanMethods
+ *
+ * PARAMETERS:  Origin              - Starting object
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Parse tree walk to find "orphaned" method invocations -- methods
+ *              that are not resolved in the namespace
+ *
+ ******************************************************************************/
+
+void
+AcpiDmFindOrphanMethods (
+    ACPI_PARSE_OBJECT       *Origin)
+{
+    ACPI_OP_WALK_INFO       Info;
+
+
+    if (!Origin)
+    {
+        return;
+    }
+
+    Info.Flags = 0;
+    Info.Level = 0;
+    Info.WalkState = NULL;
+
+    AcpiDmWalkParseTree (Origin, AcpiDmFindOrphanDescending, NULL, &Info);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiDmFinishNamespaceLoad
+ *
+ * PARAMETERS:  ParseTreeRoot       - Root of the parse tree
+ *              NamespaceRoot       - Root of the internal namespace
+ *              OwnerId             - OwnerId of the table to be disassembled
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Load all namespace items that are created within control
+ *              methods. Used before namespace cross reference
+ *
+ ******************************************************************************/
+
+void
+AcpiDmFinishNamespaceLoad (
+    ACPI_PARSE_OBJECT       *ParseTreeRoot,
+    ACPI_NAMESPACE_NODE     *NamespaceRoot,
+    ACPI_OWNER_ID           OwnerId)
+{
+    ACPI_STATUS             Status;
+    ACPI_OP_WALK_INFO       Info;
+    ACPI_WALK_STATE         *WalkState;
+
+
+    if (!ParseTreeRoot)
+    {
+        return;
+    }
+
+    /* Create and initialize a new walk state */
+
+    WalkState = AcpiDsCreateWalkState (OwnerId, ParseTreeRoot, NULL, NULL);
+    if (!WalkState)
+    {
+        return;
+    }
+
+    Status = AcpiDsScopeStackPush (NamespaceRoot, NamespaceRoot->Type,
+        WalkState);
+    if (ACPI_FAILURE (Status))
+    {
+        return;
+    }
+
+    Info.Flags = 0;
+    Info.Level = 0;
+    Info.WalkState = WalkState;
+
+    AcpiDmWalkParseTree (ParseTreeRoot, AcpiDmLoadDescendingOp,
+        AcpiDmCommonAscendingOp, &Info);
+    ACPI_FREE (WalkState);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiDmCrossReferenceNamespace
+ *
+ * PARAMETERS:  ParseTreeRoot       - Root of the parse tree
+ *              NamespaceRoot       - Root of the internal namespace
+ *              OwnerId             - OwnerId of the table to be disassembled
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Cross reference the namespace to create externals
+ *
+ ******************************************************************************/
+
+void
+AcpiDmCrossReferenceNamespace (
+    ACPI_PARSE_OBJECT       *ParseTreeRoot,
+    ACPI_NAMESPACE_NODE     *NamespaceRoot,
+    ACPI_OWNER_ID           OwnerId)
+{
+    ACPI_STATUS             Status;
+    ACPI_OP_WALK_INFO       Info;
+    ACPI_WALK_STATE         *WalkState;
+
+
+    if (!ParseTreeRoot)
+    {
+        return;
+    }
+
+    /* Create and initialize a new walk state */
+
+    WalkState = AcpiDsCreateWalkState (OwnerId, ParseTreeRoot, NULL, NULL);
+    if (!WalkState)
+    {
+        return;
+    }
+
+    Status = AcpiDsScopeStackPush (NamespaceRoot, NamespaceRoot->Type,
+        WalkState);
+    if (ACPI_FAILURE (Status))
+    {
+        return;
+    }
+
+    Info.Flags = 0;
+    Info.Level = 0;
+    Info.WalkState = WalkState;
+
+    AcpiDmWalkParseTree (ParseTreeRoot, AcpiDmXrefDescendingOp,
+        AcpiDmCommonAscendingOp, &Info);
+    ACPI_FREE (WalkState);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiDmConvertResourceIndexes
+ *
+ * PARAMETERS:  ParseTreeRoot       - Root of the parse tree
+ *              NamespaceRoot       - Root of the internal namespace
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Convert fixed-offset references to resource descriptors to
+ *              symbolic references. Should only be called after namespace has
+ *              been cross referenced.
+ *
+ ******************************************************************************/
+
+void
+AcpiDmConvertResourceIndexes (
+    ACPI_PARSE_OBJECT       *ParseTreeRoot,
+    ACPI_NAMESPACE_NODE     *NamespaceRoot)
+{
+    ACPI_STATUS             Status;
+    ACPI_OP_WALK_INFO       Info;
+    ACPI_WALK_STATE         *WalkState;
+
+
+    if (!ParseTreeRoot)
+    {
+        return;
+    }
+
+    /* Create and initialize a new walk state */
+
+    WalkState = AcpiDsCreateWalkState (0, ParseTreeRoot, NULL, NULL);
+    if (!WalkState)
+    {
+        return;
+    }
+
+    Status = AcpiDsScopeStackPush (NamespaceRoot, NamespaceRoot->Type,
+        WalkState);
+    if (ACPI_FAILURE (Status))
+    {
+        ACPI_FREE (WalkState);
+        return;
+    }
+
+    Info.Flags = 0;
+    Info.Level = 0;
+    Info.WalkState = WalkState;
+
+    AcpiDmWalkParseTree (ParseTreeRoot, AcpiDmResourceDescendingOp,
+        AcpiDmCommonAscendingOp, &Info);
+    ACPI_FREE (WalkState);
+    return;
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiDmDumpDescending
+ *
+ * PARAMETERS:  ASL_WALK_CALLBACK
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Format and print contents of one parse Op.
+ *
+ ******************************************************************************/
+
+static ACPI_STATUS
+AcpiDmDumpDescending (
+    ACPI_PARSE_OBJECT       *Op,
+    UINT32                  Level,
+    void                    *Context)
+{
+    ACPI_OP_WALK_INFO       *Info = Context;
+    char                    *Path;
+
+
+    if (!Op)
+    {
+        return (AE_OK);
+    }
+
+    /* Most of the information (count, level, name) here */
+
+    Info->Count++;
+    AcpiOsPrintf ("% 5d [%2.2d] ", Info->Count, Level);
+    AcpiDmIndent (Level);
+    AcpiOsPrintf ("%-28s", AcpiPsGetOpcodeName (Op->Common.AmlOpcode));
+
+    /* Extra info is helpful */
+
+    switch (Op->Common.AmlOpcode)
+    {
+    case AML_BYTE_OP:
+
+        AcpiOsPrintf ("%2.2X", (UINT32) Op->Common.Value.Integer);
+        break;
+
+    case AML_WORD_OP:
+
+        AcpiOsPrintf ("%4.4X", (UINT32) Op->Common.Value.Integer);
+        break;
+
+    case AML_DWORD_OP:
+
+        AcpiOsPrintf ("%8.8X", (UINT32) Op->Common.Value.Integer);
+        break;
+
+    case AML_QWORD_OP:
+
+        AcpiOsPrintf ("%8.8X%8.8X", ACPI_FORMAT_UINT64 (Op->Common.Value.Integer));
+        break;
+
+    case AML_INT_NAMEPATH_OP:
+
+        if (Op->Common.Value.String)
+        {
+            AcpiNsExternalizeName (ACPI_UINT32_MAX, Op->Common.Value.String,
+                NULL, &Path);
+            AcpiOsPrintf ("%s %p", Path, Op->Common.Node);
+            ACPI_FREE (Path);
+        }
+        else
+        {
+            AcpiOsPrintf ("[NULL]");
+        }
+        break;
+
+    case AML_NAME_OP:
+    case AML_METHOD_OP:
+    case AML_DEVICE_OP:
+    case AML_INT_NAMEDFIELD_OP:
+
+        AcpiOsPrintf ("%4.4s", ACPI_CAST_PTR (char, &Op->Named.Name));
+        break;
+
+    default:
+
+        break;
+    }
+
+    AcpiOsPrintf ("\n");
+    return (AE_OK);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiDmFindOrphanDescending
+ *
+ * PARAMETERS:  ASL_WALK_CALLBACK
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Check namepath Ops for orphaned method invocations
+ *
+ * Note: Parts of this are experimental, under possible further development.
+ *
+ ******************************************************************************/
+
+static ACPI_STATUS
+AcpiDmFindOrphanDescending (
+    ACPI_PARSE_OBJECT       *Op,
+    UINT32                  Level,
+    void                    *Context)
+{
+    const ACPI_OPCODE_INFO  *OpInfo;
+    ACPI_PARSE_OBJECT       *ChildOp;
+    ACPI_PARSE_OBJECT       *NextOp;
+    ACPI_PARSE_OBJECT       *ParentOp;
+    UINT32                  ArgCount;
+
+
+    if (!Op)
+    {
+        return (AE_OK);
+    }
+
+    OpInfo = AcpiPsGetOpcodeInfo (Op->Common.AmlOpcode);
+
+    switch (Op->Common.AmlOpcode)
+    {
+#ifdef ACPI_UNDER_DEVELOPMENT
+    case AML_ADD_OP:
+
+        ChildOp = Op->Common.Value.Arg;
+        if ((ChildOp->Common.AmlOpcode == AML_INT_NAMEPATH_OP) &&
+            !ChildOp->Common.Node)
+        {
+            AcpiNsExternalizeName (ACPI_UINT32_MAX, ChildOp->Common.Value.String,
+                NULL, &Path);
+            AcpiOsPrintf ("/* %-16s A-NAMEPATH: %s  */\n",
+                Op->Common.AmlOpName, Path);
+            ACPI_FREE (Path);
+
+            NextOp = Op->Common.Next;
+            if (!NextOp)
+            {
+                /* This NamePath has no args, assume it is an integer */
+
+                AcpiDmAddOpToExternalList (ChildOp,
+                    ChildOp->Common.Value.String, ACPI_TYPE_INTEGER, 0, 0);
+                return (AE_OK);
+            }
+
+            ArgCount = AcpiDmInspectPossibleArgs (3, 1, NextOp);
+            AcpiOsPrintf ("/* A-CHILDREN: %u Actual %u */\n",
+                ArgCount, AcpiDmCountChildren (Op));
+
+            if (ArgCount < 1)
+            {
+                /* One Arg means this is just a Store(Name,Target) */
+
+                AcpiDmAddOpToExternalList (ChildOp,
+                    ChildOp->Common.Value.String, ACPI_TYPE_INTEGER, 0, 0);
+                return (AE_OK);
+            }
+
+            AcpiDmAddOpToExternalList (ChildOp,
+                ChildOp->Common.Value.String, ACPI_TYPE_METHOD, ArgCount, 0);
+        }
+        break;
+
+#endif
+
+    case AML_STORE_OP:
+
+        ChildOp = Op->Common.Value.Arg;
+        if ((ChildOp->Common.AmlOpcode == AML_INT_NAMEPATH_OP) &&
+            !ChildOp->Common.Node)
+        {
+            NextOp = Op->Common.Next;
+            if (!NextOp)
+            {
+                /* This NamePath has no args, assume it is an integer */
+
+                AcpiDmAddOpToExternalList (ChildOp,
+                    ChildOp->Common.Value.String, ACPI_TYPE_INTEGER, 0, 0);
+                return (AE_OK);
+            }
+
+            ArgCount = AcpiDmInspectPossibleArgs (2, 1, NextOp);
+            if (ArgCount <= 1)
+            {
+                /* One Arg means this is just a Store(Name,Target) */
+
+                AcpiDmAddOpToExternalList (ChildOp,
+                    ChildOp->Common.Value.String, ACPI_TYPE_INTEGER, ArgCount, 0);
+                return (AE_OK);
+            }
+
+            AcpiDmAddOpToExternalList (ChildOp,
+                ChildOp->Common.Value.String, ACPI_TYPE_METHOD, ArgCount, 0);
+        }
+        break;
+
+    case AML_INT_NAMEPATH_OP:
+
+        /* Must examine parent to see if this namepath is an argument */
+
+        ParentOp = Op->Common.Parent;
+        OpInfo = AcpiPsGetOpcodeInfo (ParentOp->Common.AmlOpcode);
+
+        if ((OpInfo->Class != AML_CLASS_EXECUTE) &&
+            (OpInfo->Class != AML_CLASS_CREATE) &&
+            (OpInfo->ObjectType != ACPI_TYPE_LOCAL_ALIAS) &&
+            (ParentOp->Common.AmlOpcode != AML_INT_METHODCALL_OP) &&
+            !Op->Common.Node)
+        {
+            ArgCount = AcpiDmInspectPossibleArgs (0, 0, Op);
+
+            /*
+             * Check if namepath is a predicate for if/while or lone parameter to
+             * a return.
+             */
+            if (ArgCount == 0)
+            {
+                if (((ParentOp->Common.AmlOpcode == AML_IF_OP) ||
+                     (ParentOp->Common.AmlOpcode == AML_WHILE_OP) ||
+                     (ParentOp->Common.AmlOpcode == AML_RETURN_OP)) &&
+
+                     /* And namepath is the first argument */
+                     (ParentOp->Common.Value.Arg == Op))
+                {
+                    AcpiDmAddOpToExternalList (Op,
+                        Op->Common.Value.String, ACPI_TYPE_INTEGER, 0, 0);
+                    break;
+                }
+            }
+
+            /*
+             * This is a standalone namestring (not a parameter to another
+             * operator) - it *must* be a method invocation, nothing else is
+             * grammatically possible.
+             */
+            AcpiDmAddOpToExternalList (Op,
+                Op->Common.Value.String, ACPI_TYPE_METHOD, ArgCount, 0);
+        }
+        break;
+
+    default:
+
+        break;
+    }
+
+    return (AE_OK);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiDmLoadDescendingOp
+ *
+ * PARAMETERS:  ASL_WALK_CALLBACK
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Descending handler for namespace control method object load
+ *
+ ******************************************************************************/
+
+static ACPI_STATUS
+AcpiDmLoadDescendingOp (
+    ACPI_PARSE_OBJECT       *Op,
+    UINT32                  Level,
+    void                    *Context)
+{
+    ACPI_OP_WALK_INFO       *Info = Context;
+    const ACPI_OPCODE_INFO  *OpInfo;
+    ACPI_WALK_STATE         *WalkState;
+    ACPI_OBJECT_TYPE        ObjectType;
+    ACPI_STATUS             Status;
+    char                    *Path = NULL;
+    ACPI_PARSE_OBJECT       *NextOp;
+    ACPI_NAMESPACE_NODE     *Node;
+    char                    FieldPath[5];
+    BOOLEAN                 PreDefined = FALSE;
+    UINT8                   PreDefineIndex = 0;
+
+
+    WalkState = Info->WalkState;
+    OpInfo = AcpiPsGetOpcodeInfo (Op->Common.AmlOpcode);
+    ObjectType = OpInfo->ObjectType;
+    ObjectType = AslMapNamedOpcodeToDataType (Op->Asl.AmlOpcode);
+
+    /* Only interested in operators that create new names */
+
+    if (!(OpInfo->Flags & AML_NAMED) &&
+        !(OpInfo->Flags & AML_CREATE))
+    {
+        goto Exit;
+    }
+
+    /* Get the NamePath from the appropriate place */
+
+    if (OpInfo->Flags & AML_NAMED)
+    {
+        /* For all named operators, get the new name */
+
+        Path = (char *) Op->Named.Path;
+
+        if (!Path && Op->Common.AmlOpcode == AML_INT_NAMEDFIELD_OP)
+        {
+            *ACPI_CAST_PTR (UINT32, &FieldPath[0]) = Op->Named.Name;
+            FieldPath[4] = 0;
+            Path = FieldPath;
+        }
+    }
+    else if (OpInfo->Flags & AML_CREATE)
+    {
+        /* New name is the last child */
+
+        NextOp = Op->Common.Value.Arg;
+
+        while (NextOp->Common.Next)
+        {
+            NextOp = NextOp->Common.Next;
+        }
+
+        Path = NextOp->Common.Value.String;
+    }
+
+    if (!Path)
+    {
+        goto Exit;
+    }
+
+    /* Insert the name into the namespace */
+
+    Status = AcpiNsLookup (WalkState->ScopeInfo, Path, ObjectType,
+        ACPI_IMODE_LOAD_PASS2, ACPI_NS_DONT_OPEN_SCOPE,
+        WalkState, &Node);
+
+    Op->Common.Node = Node;
+
+    if (ACPI_SUCCESS (Status))
+    {
+        /* Check if it's a predefined node */
+
+        while (AcpiGbl_PreDefinedNames[PreDefineIndex].Name)
+        {
+            if (ACPI_COMPARE_NAME (Node->Name.Ascii,
+                AcpiGbl_PreDefinedNames[PreDefineIndex].Name))
+            {
+                PreDefined = TRUE;
+                break;
+            }
+
+            PreDefineIndex++;
+        }
+
+        /*
+         * Set node owner id if it satisfies all the following conditions:
+         * 1) Not a predefined node, _SB_ etc
+         * 2) Not the root node
+         * 3) Not a node created by Scope
+         */
+
+        if (!PreDefined && Node != AcpiGbl_RootNode &&
+            Op->Common.AmlOpcode != AML_SCOPE_OP)
+        {
+            Node->OwnerId = WalkState->OwnerId;
+        }
+    }
+
+
+Exit:
+
+    if (AcpiNsOpensScope (ObjectType))
+    {
+        if (Op->Common.Node)
+        {
+            Status = AcpiDsScopeStackPush (Op->Common.Node, ObjectType,
+                WalkState);
+            if (ACPI_FAILURE (Status))
+            {
+                return (Status);
+            }
+        }
+    }
+
+    return (AE_OK);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiDmXrefDescendingOp
+ *
+ * PARAMETERS:  ASL_WALK_CALLBACK
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Descending handler for namespace cross reference
+ *
+ ******************************************************************************/
+
+static ACPI_STATUS
+AcpiDmXrefDescendingOp (
+    ACPI_PARSE_OBJECT       *Op,
+    UINT32                  Level,
+    void                    *Context)
+{
+    ACPI_OP_WALK_INFO       *Info = Context;
+    const ACPI_OPCODE_INFO  *OpInfo;
+    ACPI_WALK_STATE         *WalkState;
+    ACPI_OBJECT_TYPE        ObjectType;
+    ACPI_OBJECT_TYPE        ObjectType2;
+    ACPI_STATUS             Status;
+    char                    *Path = NULL;
+    ACPI_PARSE_OBJECT       *NextOp;
+    ACPI_NAMESPACE_NODE     *Node;
+    ACPI_OPERAND_OBJECT     *Object;
+    UINT32                  ParamCount = 0;
+    char                    *Pathname;
+    UINT16                  Flags = 0;
+
+
+    WalkState = Info->WalkState;
+    OpInfo = AcpiPsGetOpcodeInfo (Op->Common.AmlOpcode);
+    ObjectType = OpInfo->ObjectType;
+    ObjectType = AslMapNamedOpcodeToDataType (Op->Asl.AmlOpcode);
+
+    if ((!(OpInfo->Flags & AML_NAMED)) &&
+        (!(OpInfo->Flags & AML_CREATE)) &&
+        (Op->Common.AmlOpcode != AML_INT_NAMEPATH_OP) &&
+        (Op->Common.AmlOpcode != AML_NOTIFY_OP))
+    {
+        goto Exit;
+    }
+    else if (Op->Common.Parent &&
+             Op->Common.Parent->Common.AmlOpcode == AML_EXTERNAL_OP)
+    {
+        /* External() NamePath */
+
+        Path = Op->Common.Value.String;
+        ObjectType = (ACPI_OBJECT_TYPE) Op->Common.Next->Common.Value.Integer;
+        if (ObjectType == ACPI_TYPE_METHOD)
+        {
+            ParamCount = (UINT32)
+                Op->Common.Next->Common.Next->Common.Value.Integer;
+        }
+
+        Flags |= ACPI_EXT_RESOLVED_REFERENCE | ACPI_EXT_ORIGIN_FROM_OPCODE;
+        AcpiDmAddOpToExternalList (Op, Path,
+            (UINT8) ObjectType, ParamCount, Flags);
+
+        goto Exit;
+    }
+
+    /* Get the NamePath from the appropriate place */
+
+    if (OpInfo->Flags & AML_NAMED)
+    {
+        /*
+         * Only these two operators (Alias, Scope) refer to an existing
+         * name, it is the first argument
+         */
+        if (Op->Common.AmlOpcode == AML_ALIAS_OP)
+        {
+            ObjectType = ACPI_TYPE_ANY;
+
+            NextOp = Op->Common.Value.Arg;
+            NextOp = NextOp->Common.Value.Arg;
+            if (NextOp->Common.AmlOpcode == AML_INT_NAMEPATH_OP)
+            {
+                Path = NextOp->Common.Value.String;
+            }
+        }
+        else if (Op->Common.AmlOpcode == AML_SCOPE_OP)
+        {
+            Path = (char *) Op->Named.Path;
+        }
+    }
+    else if (OpInfo->Flags & AML_CREATE)
+    {
+        /* Referenced Buffer Name is the first child */
+
+        ObjectType = ACPI_TYPE_BUFFER; /* Change from TYPE_BUFFER_FIELD */
+
+        NextOp = Op->Common.Value.Arg;
+        if (NextOp->Common.AmlOpcode == AML_INT_NAMEPATH_OP)
+        {
+            Path = NextOp->Common.Value.String;
+        }
+    }
+    else if (Op->Common.AmlOpcode == AML_NOTIFY_OP)
+    {
+        Path = Op->Common.Value.Arg->Asl.Value.String;
+    }
+    else
+    {
+        Path = Op->Common.Value.String;
+    }
+
+    if (!Path)
+    {
+        goto Exit;
+    }
+
+    /*
+     * Lookup the name in the namespace. Name must exist at this point, or it
+     * is an invalid reference.
+     *
+     * The namespace is also used as a lookup table for references to resource
+     * descriptors and the fields within them.
+     */
+    Node = NULL;
+    Status = AcpiNsLookup (WalkState->ScopeInfo, Path, ACPI_TYPE_ANY,
+        ACPI_IMODE_EXECUTE, ACPI_NS_SEARCH_PARENT | ACPI_NS_DONT_OPEN_SCOPE,
+        WalkState, &Node);
+
+    if (ACPI_SUCCESS (Status) && (Node->Flags & ANOBJ_IS_EXTERNAL))
+    {
+        /* Node was created by an External() statement */
+
+        Status = AE_NOT_FOUND;
+    }
+
+    if (ACPI_FAILURE (Status))
+    {
+        if (Status == AE_NOT_FOUND)
+        {
+            /*
+             * Add this symbol as an external declaration, except if the
+             * parent is a CondRefOf operator. For this operator, we do not
+             * need an external, nor do we want one, since this can cause
+             * disassembly problems if the symbol is actually a control
+             * method.
+             */
+            if (!(Op->Asl.Parent &&
+                (Op->Asl.Parent->Asl.AmlOpcode == AML_COND_REF_OF_OP)))
+            {
+                if (Node)
+                {
+                    AcpiDmAddNodeToExternalList (Node,
+                        (UINT8) ObjectType, 7, Flags);
+                }
+                else
+                {
+                    AcpiDmAddOpToExternalList (Op, Path,
+                        (UINT8) ObjectType, 7, Flags);
+                }
+            }
+        }
+    }
+
+    /*
+     * Found the node, but check if it came from an external table.
+     * Add it to external list. Note: Node->OwnerId == 0 indicates
+     * one of the built-in ACPI Names (_OS_ etc.) which can safely
+     * be ignored.
+     */
+    else if (Node->OwnerId &&
+            (WalkState->OwnerId != Node->OwnerId))
+    {
+        ObjectType2 = ObjectType;
+
+        Object = AcpiNsGetAttachedObject (Node);
+        if (Object)
+        {
+            ObjectType2 = Object->Common.Type;
+            if (ObjectType2 == ACPI_TYPE_METHOD)
+            {
+                ParamCount = Object->Method.ParamCount;
+            }
+        }
+
+        Pathname = AcpiNsGetExternalPathname (Node);
+        if (!Pathname)
+        {
+            return (AE_NO_MEMORY);
+        }
+
+        AcpiDmAddNodeToExternalList (Node, (UINT8) ObjectType2,
+            ParamCount, ACPI_EXT_RESOLVED_REFERENCE);
+
+        ACPI_FREE (Pathname);
+        Op->Common.Node = Node;
+    }
+    else
+    {
+        Op->Common.Node = Node;
+    }
+
+
+Exit:
+    /* Open new scope if necessary */
+
+    if (AcpiNsOpensScope (ObjectType))
+    {
+        if (Op->Common.Node)
+        {
+            Status = AcpiDsScopeStackPush (Op->Common.Node, ObjectType,
+                WalkState);
+            if (ACPI_FAILURE (Status))
+            {
+                return (Status);
+            }
+        }
+    }
+
+    return (AE_OK);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiDmResourceDescendingOp
+ *
+ * PARAMETERS:  ASL_WALK_CALLBACK
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Process one parse op during symbolic resource index conversion.
+ *
+ ******************************************************************************/
+
+static ACPI_STATUS
+AcpiDmResourceDescendingOp (
+    ACPI_PARSE_OBJECT       *Op,
+    UINT32                  Level,
+    void                    *Context)
+{
+    ACPI_OP_WALK_INFO       *Info = Context;
+    const ACPI_OPCODE_INFO  *OpInfo;
+    ACPI_WALK_STATE         *WalkState;
+    ACPI_OBJECT_TYPE        ObjectType;
+    ACPI_STATUS             Status;
+
+
+    WalkState = Info->WalkState;
+    OpInfo = AcpiPsGetOpcodeInfo (Op->Common.AmlOpcode);
+
+    /* Open new scope if necessary */
+
+    ObjectType = OpInfo->ObjectType;
+    if (AcpiNsOpensScope (ObjectType))
+    {
+        if (Op->Common.Node)
+        {
+
+            Status = AcpiDsScopeStackPush (Op->Common.Node, ObjectType,
+                WalkState);
+            if (ACPI_FAILURE (Status))
+            {
+                return (Status);
+            }
+        }
+    }
+
+    /*
+     * Check if this operator contains a reference to a resource descriptor.
+     * If so, convert the reference into a symbolic reference.
+     */
+    AcpiDmCheckResourceReference (Op, WalkState);
+    return (AE_OK);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiDmCommonAscendingOp
+ *
+ * PARAMETERS:  ASL_WALK_CALLBACK
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Ascending handler for combined parse/namespace walks. Closes
+ *              scope if necessary.
+ *
+ ******************************************************************************/
+
+static ACPI_STATUS
+AcpiDmCommonAscendingOp (
+    ACPI_PARSE_OBJECT       *Op,
+    UINT32                  Level,
+    void                    *Context)
+{
+    ACPI_OP_WALK_INFO       *Info = Context;
+    const ACPI_OPCODE_INFO  *OpInfo;
+    ACPI_OBJECT_TYPE        ObjectType;
+
+
+    /* Close scope if necessary */
+
+    OpInfo = AcpiPsGetOpcodeInfo (Op->Common.AmlOpcode);
+    ObjectType = OpInfo->ObjectType;
+    ObjectType = AslMapNamedOpcodeToDataType (Op->Asl.AmlOpcode);
+
+    if (AcpiNsOpensScope (ObjectType))
+    {
+        (void) AcpiDsScopeStackPop (Info->WalkState);
+    }
+
+    return (AE_OK);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiDmInspectPossibleArgs
+ *
+ * PARAMETERS:  CurrentOpArgCount   - Which arg of the current op was the
+ *                                    possible method invocation found
+ *              TargetCount         - Number of targets (0,1,2) for this op
+ *              Op                  - Parse op
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Examine following args and next ops for possible arguments
+ *              for an unrecognized method invocation.
+ *
+ ******************************************************************************/
+
+static UINT32
+AcpiDmInspectPossibleArgs (
+    UINT32                  CurrentOpArgCount,
+    UINT32                  TargetCount,
+    ACPI_PARSE_OBJECT       *Op)
+{
+    const ACPI_OPCODE_INFO  *OpInfo;
+    UINT32                  i;
+    UINT32                  ArgumentCount = 0;
+    ACPI_PARSE_OBJECT       *NextOp;
+    ACPI_PARSE_OBJECT       *ExecuteOp;
+
+
+    if (!Op)
+    {
+        return (0);
+    }
+
+    /* Lookahead for the maximum number of possible arguments */
+
+    NextOp = Op->Common.Next;
+
+    for (i = 0; (i < ACPI_METHOD_NUM_ARGS) && NextOp; i++)
+    {
+        OpInfo = AcpiPsGetOpcodeInfo (NextOp->Common.AmlOpcode);
+
+        /* Any one of these operators is "very probably" not a method arg */
+
+        if ((NextOp->Common.AmlOpcode == AML_STORE_OP) ||
+            (NextOp->Common.AmlOpcode == AML_NOTIFY_OP) ||
+            (OpInfo->Class == AML_CLASS_CONTROL) ||
+            (OpInfo->Class == AML_CLASS_CREATE) ||
+            (OpInfo->Class == AML_CLASS_NAMED_OBJECT))
+        {
+            break;
+        }
+
+        if (OpInfo->Class == AML_CLASS_EXECUTE)
+        {
+            /* Probable that this is method arg if there is no target */
+
+            ExecuteOp = NextOp->Common.Value.Arg;
+            while (ExecuteOp)
+            {
+                if ((ExecuteOp->Common.AmlOpcode == AML_INT_NAMEPATH_OP) &&
+                    (ExecuteOp->Common.Value.Arg == NULL))
+                {
+                    /* No target, could be a method arg */
+
+                    break;
+                }
+
+                if (NextOp->Common.AmlOpcode == AML_REF_OF_OP)
+                {
+                    break;
+                }
+
+                ExecuteOp = ExecuteOp->Common.Next;
+            }
+
+            if (!ExecuteOp)
+            {
+                /* Has a target, not method arg */
+
+                return (ArgumentCount);
+            }
+        }
+
+        ArgumentCount++;
+        NextOp = NextOp->Common.Next;
+    }
+
+    return (ArgumentCount);
+}
diff --git a/usr/src/cmd/acpi/common/ahids.c b/usr/src/cmd/acpi/common/ahids.c
new file mode 100644
index 0000000000..51dc8dc803
--- /dev/null
+++ b/usr/src/cmd/acpi/common/ahids.c
@@ -0,0 +1,245 @@
+/******************************************************************************
+ *
+ * Module Name: ahids - Table of ACPI/PNP _HID/_CID values
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2016, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include "acpi.h"
+#include "accommon.h"
+
+#define _COMPONENT          ACPI_UTILITIES
+        ACPI_MODULE_NAME    ("ahids")
+
+
+/*
+ * ACPI/PNP Device IDs with description strings
+ */
+const AH_DEVICE_ID  AslDeviceIds[] =
+{
+    {"10EC5640",    "Realtek I2S Audio Codec"},
+    {"80860F09",    "Intel PWM Controller"},
+    {"80860F0A",    "Intel Atom UART Controller"},
+    {"80860F0E",    "Intel SPI Controller"},
+    {"80860F14",    "Intel Baytrail SDIO/MMC Host Controller"},
+    {"80860F28",    "Intel SST Audio DSP"},
+    {"80860F41",    "Intel Baytrail I2C Host Controller"},
+    {"ACPI0001",    "SMBus 1.0 Host Controller"},
+    {"ACPI0002",    "Smart Battery Subsystem"},
+    {"ACPI0003",    "Power Source Device"},
+    {"ACPI0004",    "Module Device"},
+    {"ACPI0005",    "SMBus 2.0 Host Controller"},
+    {"ACPI0006",    "GPE Block Device"},
+    {"ACPI0007",    "Processor Device"},
+    {"ACPI0008",    "Ambient Light Sensor Device"},
+    {"ACPI0009",    "I/O xAPIC Device"},
+    {"ACPI000A",    "I/O APIC Device"},
+    {"ACPI000B",    "I/O SAPIC Device"},
+    {"ACPI000C",    "Processor Aggregator Device"},
+    {"ACPI000D",    "Power Meter Device"},
+    {"ACPI000E",    "Time and Alarm Device"},
+    {"ACPI000F",    "User Presence Detection Device"},
+    {"ACPI0010",    "Processor Container Device"},
+    {"ACPI0011",    "Generic Buttons Device"},
+    {"ACPI0012",    "NVDIMM Root Device"},
+    {"ACPI0013",    "Generic Event Device"},
+    {"ADMA0F28",    "Intel Audio DMA"},
+    {"AMCR0F28",    "Intel Audio Machine Driver"},
+    {"ATK4001",     "Asus Radio Control Button"},
+    {"ATML1000",    "Atmel Touchscreen Controller"},
+    {"AUTH2750",    "AuthenTec AES2750"},
+    {"BCM2E39",     "Broadcom BT Serial Bus Driver over UART Bus Enumerator"},
+    {"BCM4752E",    "Broadcom GPS Controller"},
+    {"BMG0160",     "Bosch Gyro Sensor"},
+    {"CPLM3218",    "Capella Micro CM3218x Ambient Light Sensor"},
+    {"DELLABCE",    "Dell Airplane Mode Switch Driver"},
+    {"DLAC3002",    "Qualcomm Atheros Bluetooth UART Transport"},
+    {"FTTH5506",    "FocalTech 5506 Touch Controller"},
+    {"HAD0F28",     "Intel HDMI Audio Driver"},
+    {"INBC0000",    "GPIO Expander"},
+    {"INT0002",     "Virtual GPIO Controller"},
+    {"INT0800",     "Intel 82802 Firmware Hub Device"},
+    {"INT3394",     "ACPI System Fan"},
+    {"INT3396",     "Standard Power Management Controller"},
+    {"INT33A0",     "Intel Smart Connect Technology Device"},
+    {"INT33A1",     "Intel Power Engine"},
+    {"INT33BB",     "Intel Baytrail SD Host Controller"},
+    {"INT33BD",     "Intel Baytrail Mailbox Device"},
+    {"INT33BE",     "Camera Sensor OV5693"},
+    {"INT33C0",     "Intel Serial I/O SPI Host Controller"},
+    {"INT33C1",     "Intel Serial I/O SPI Host Controller"},
+    {"INT33C2",     "Intel Serial I/O I2C Host Controller"},
+    {"INT33C3",     "Intel Serial I/O I2C Host Controller"},
+    {"INT33C4",     "Intel Serial I/O UART Host Controller"},
+    {"INT33C5",     "Intel Serial I/O UART Host Controller"},
+    {"INT33C6",     "Intel SD Host Controller"},
+    {"INT33C7",     "Intel Serial I/O GPIO Host Controller"},
+    {"INT33C8",     "Intel Smart Sound Technology Host Controller"},
+    {"INT33C9",     "Wolfson Microelectronics Audio WM5102"},
+    {"INT33CA",     "Intel SPB Peripheral"},
+    {"INT33CB",     "Intel Smart Sound Technology Audio Codec"},
+    {"INT33D1",     "Intel GPIO Buttons"},
+    {"INT33D2",     "Intel GPIO Buttons"},
+    {"INT33D3",     "Intel GPIO Buttons"},
+    {"INT33D4",     "Intel GPIO Buttons"},
+    {"INT33D6",     "Intel Virtual Buttons Device"},
+    {"INT33F0",     "Camera Sensor MT9M114"},
+    {"INT33F4",     "XPOWER PMIC Controller"},
+    {"INT33F5",     "TI PMIC Controller"},
+    {"INT33FB",     "MIPI-CSI Camera Sensor OV2722"},
+    {"INT33FC",     "Intel Baytrail GPIO Controller"},
+    {"INT33FD",     "Intel Baytrail Power Management IC"},
+    {"INT33FE",     "XPOWER Battery Device"},
+    {"INT3400",     "Intel Dynamic Power Performance Management"},
+    {"INT3401",     "Intel Extended Thermal Model CPU"},
+    {"INT3403",     "DPTF Temperature Sensor"},
+    {"INT3406",     "Intel Dynamic Platform & Thermal Framework Display Participant"},
+    {"INT3407",     "DPTF Platform Power Meter"},
+    {"INT340E",     "Motherboard Resources"},
+    {"INT3420",     "Intel Bluetooth RF Kill"},
+    {"INT3F0D",     "ACPI Motherboard Resources"},
+    {"INTCF1A",     "Sony IMX175 Camera Sensor"},
+    {"INTCFD9",     "Intel Baytrail SOC GPIO Controller"},
+    {"INTL9C60",    "Intel Baytrail SOC DMA Controller"},
+    {"INVN6500",    "InvenSense MPU-6500 Six Axis Gyroscope and Accelerometer"},
+    {"LNXCPU",      "Linux Logical CPU"},
+    {"LNXPOWER",    "ACPI Power Resource (power gating)"},
+    {"LNXPWRBN",    "System Power Button"},
+    {"LNXSYBUS",    "System Bus"},
+    {"LNXSYSTM",    "ACPI Root Node"},
+    {"LNXTHERM",    "ACPI Thermal Zone"},
+    {"LNXVIDEO",    "ACPI Video Controller"},
+    {"MAX17047",    "Fuel Gauge Controller"},
+    {"MSFT0101",    "TPM 2.0 Security Device"},
+    {"NXP5442",     "NXP 5442 Near Field Communications Controller"},
+    {"NXP5472",     "NXP NFC"},
+    {"PNP0000",     "8259-compatible Programmable Interrupt Controller"},
+    {"PNP0001",     "EISA Interrupt Controller"},
+    {"PNP0002",     "MCA Interrupt Controller"},
+    {"PNP0003",     "IO-APIC Interrupt Controller"},
+    {"PNP0100",     "PC-class System Timer"},
+    {"PNP0103",     "HPET System Timer"},
+    {"PNP0200",     "PC-class DMA Controller"},
+    {"PNP0300",     "IBM PC/XT Keyboard Controller (83 key)"},
+    {"PNP0301",     "IBM PC/XT Keyboard Controller (86 key)"},
+    {"PNP0302",     "IBM PC/XT Keyboard Controller (84 key)"},
+    {"PNP0303",     "IBM Enhanced Keyboard (101/102-key, PS/2 Mouse)"},
+    {"PNP0400",     "Standard LPT Parallel Port"},
+    {"PNP0401",     "ECP Parallel Port"},
+    {"PNP0500",     "Standard PC COM Serial Port"},
+    {"PNP0501",     "16550A-compatible COM Serial Port"},
+    {"PNP0510",     "Generic IRDA-compatible Device"},
+    {"PNP0800",     "Microsoft Sound System Compatible Device"},
+    {"PNP0A03",     "PCI Bus"},
+    {"PNP0A05",     "Generic Container Device"},
+    {"PNP0A06",     "Generic Container Device"},
+    {"PNP0A08",     "PCI Express Bus"},
+    {"PNP0B00",     "AT Real-Time Clock"},
+    {"PNP0B01",     "Intel PIIX4-compatible RTC/CMOS Device"},
+    {"PNP0B02",     "Dallas Semiconductor-compatible RTC/CMOS Device"},
+    {"PNP0C01",     "System Board"},
+    {"PNP0C02",     "PNP Motherboard Resources"},
+    {"PNP0C04",     "x87-compatible Floating Point Processing Unit"},
+    {"PNP0C08",     "ACPI Core Hardware"},
+    {"PNP0C09",     "Embedded Controller Device"},
+    {"PNP0C0A",     "Control Method Battery"},
+    {"PNP0C0B",     "Fan (Thermal Solution)"},
+    {"PNP0C0C",     "Power Button Device"},
+    {"PNP0C0D",     "Lid Device"},
+    {"PNP0C0E",     "Sleep Button Device"},
+    {"PNP0C0F",     "PCI Interrupt Link Device"},
+    {"PNP0C10",     "System Indicator Device"},
+    {"PNP0C11",     "Thermal Zone"},
+    {"PNP0C12",     "Device Bay Controller"},
+    {"PNP0C14",     "Windows Management Instrumentation Device"},
+    {"PNP0C15",     "Docking Station"},
+    {"PNP0C33",     "Error Device"},
+    {"PNP0C40",     "Standard Button Controller"},
+    {"PNP0C50",     "HID Protocol Device (I2C bus)"},
+    {"PNP0C60",     "Display Sensor Device"},
+    {"PNP0C70",     "Dock Sensor Device"},
+    {"PNP0C80",     "Memory Device"},
+    {"PNP0D10",     "XHCI USB Controller with debug"},
+    {"PNP0D15",     "XHCI USB Controller without debug"},
+    {"PNP0D20",     "EHCI USB Controller without debug"},
+    {"PNP0D25",     "EHCI USB Controller with debug"},
+    {"PNP0D40",     "SDA Standard Compliant SD Host Controller"},
+    {"PNP0D80",     "Windows-compatible System Power Management Controller"},
+    {"PNP0F03",     "Microsoft PS/2-style Mouse"},
+    {"PNP0F13",     "PS/2 Mouse"},
+    {"RTL8723",     "Realtek Wireless Controller"},
+    {"SMB0349",     "Charger"},
+    {"SMO91D0",     "Sensor Hub"},
+    {"SMSC3750",    "SMSC 3750 USB MUX"},
+    {"SSPX0000",    "Intel SSP Device"},
+    {"TBQ24296",    "Charger"},
+
+    {NULL, NULL}
+};
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiAhMatchHardwareId
+ *
+ * PARAMETERS:  HardwareId          - String representation of an _HID or _CID
+ *
+ * RETURN:      ID info struct. NULL if HardwareId is not found
+ *
+ * DESCRIPTION: Lookup an _HID/_CID in the device ID table
+ *
+ ******************************************************************************/
+
+const AH_DEVICE_ID *
+AcpiAhMatchHardwareId (
+    char                    *HardwareId)
+{
+    const AH_DEVICE_ID      *Info;
+
+
+    for (Info = AslDeviceIds; Info->Name; Info++)
+    {
+        if (!strcmp (HardwareId, Info->Name))
+        {
+            return (Info);
+        }
+    }
+
+    return (NULL);
+}
diff --git a/usr/src/cmd/acpi/common/ahpredef.c b/usr/src/cmd/acpi/common/ahpredef.c
new file mode 100644
index 0000000000..c3991be3a2
--- /dev/null
+++ b/usr/src/cmd/acpi/common/ahpredef.c
@@ -0,0 +1,372 @@
+/******************************************************************************
+ *
+ * Module Name: ahpredef - Table of all known ACPI predefined names
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2016, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include "acpi.h"
+#include "accommon.h"
+
+#define _COMPONENT          ACPI_UTILITIES
+        ACPI_MODULE_NAME    ("ahpredef")
+
+/*
+ * iASL only needs a partial table (short descriptions only).
+ * AcpiHelp needs the full table.
+ */
+#ifdef ACPI_ASL_COMPILER
+#define AH_PREDEF(Name, ShortDesc, LongDesc) {Name, ShortDesc}
+#else
+#define AH_PREDEF(Name, ShortDesc, LongDesc) {Name, ShortDesc, LongDesc}
+#endif
+
+/*
+ * Predefined ACPI names, with short description and return value.
+ * This table was extracted directly from the ACPI specification.
+ */
+const AH_PREDEFINED_NAME    AslPredefinedInfo[] =
+{
+    AH_PREDEF ("_ACx",    "Active Cooling", "Returns the active cooling policy threshold values"),
+    AH_PREDEF ("_ADR",    "Address", "Returns address of a device on parent bus, and resource field"),
+    AH_PREDEF ("_AEI",    "ACPI Event Interrupts", "Returns a list of GPIO events to be used as ACPI events"),
+    AH_PREDEF ("_ALC",    "Ambient Light Chromaticity", "Returns the ambient light color chromaticity"),
+    AH_PREDEF ("_ALI",    "Ambient Light Illuminance", "Returns the ambient light brightness"),
+    AH_PREDEF ("_ALN",    "Alignment", "Base alignment, Resource Descriptor field"),
+    AH_PREDEF ("_ALP",    "Ambient Light Polling", "Returns the ambient light sensor polling frequency"),
+    AH_PREDEF ("_ALR",    "Ambient Light Response", "Returns the ambient light brightness to display brightness mappings"),
+    AH_PREDEF ("_ALT",    "Ambient Light Temperature", "Returns the ambient light color temperature"),
+    AH_PREDEF ("_ALx",    "Active List", "Returns a list of active cooling device objects"),
+    AH_PREDEF ("_ART",    "Active Cooling Relationship Table", "Returns thermal relationship information between platform devices and fan devices"),
+    AH_PREDEF ("_ASI",    "Address Space Id", "Resource Descriptor field"),
+    AH_PREDEF ("_ASZ",    "Access Size", "Resource Descriptor field"),
+    AH_PREDEF ("_ATT",    "Type-Specific Attribute", "Resource Descriptor field"),
+    AH_PREDEF ("_BAS",    "Base Address", "Range base address, Resource Descriptor field"),
+    AH_PREDEF ("_BBN",    "BIOS Bus Number", "Returns the PCI bus number returned by the BIOS"),
+    AH_PREDEF ("_BCL",    "Brightness Control Levels", "Returns a list of supported brightness control levels"),
+    AH_PREDEF ("_BCM",    "Brightness Control Method", "Sets the brightness level of the display device"),
+    AH_PREDEF ("_BCT",    "Battery Charge Time", "Returns time remaining to complete charging battery"),
+    AH_PREDEF ("_BDN",    "BIOS Dock Name", "Returns the Dock ID returned by the BIOS"),
+    AH_PREDEF ("_BFS",    "Back From Sleep", "Inform AML of a wake event"),
+    AH_PREDEF ("_BIF",    "Battery Information", "Returns a Control Method Battery information block"),
+    AH_PREDEF ("_BIX",    "Battery Information Extended", "Returns a Control Method Battery extended information block"),
+    AH_PREDEF ("_BLT",    "Battery Level Threshold", "Set battery level threshold preferences"),
+    AH_PREDEF ("_BM_",    "Bus Master", "Resource Descriptor field"),
+    AH_PREDEF ("_BMA",    "Battery Measurement Averaging Interval", "Sets battery measurement averaging interval"),
+    AH_PREDEF ("_BMC",    "Battery Maintenance Control", "Sets battery maintenance and control features"),
+    AH_PREDEF ("_BMD",    "Battery Maintenance Data", "Returns battery maintenance, control, and state data"),
+    AH_PREDEF ("_BMS",    "Battery Measurement Sampling Time", "Sets the battery measurement sampling time"),
+    AH_PREDEF ("_BQC",    "Brightness Query Current", "Returns the current display brightness level"),
+    AH_PREDEF ("_BST",    "Battery Status", "Returns a Control Method Battery status block"),
+    AH_PREDEF ("_BTH",    "Battery Throttle Limit", "Thermal limit for charging and discharging"),
+    AH_PREDEF ("_BTM",    "Battery Time", "Returns the battery runtime"),
+    AH_PREDEF ("_BTP",    "Battery Trip Point", "Sets a Control Method Battery trip point"),
+    AH_PREDEF ("_CBA",    "Configuration Base Address", "Sets the base address for a PCI Express host bridge"),
+    AH_PREDEF ("_CCA",    "Cache Coherency Attribute", "Returns a device's support level for cache coherency"),
+    AH_PREDEF ("_CDM",    "Clock Domain", "Returns a logical processor's clock domain identifier"),
+    AH_PREDEF ("_CID",    "Compatible ID", "Returns a device's Plug and Play Compatible ID list"),
+    AH_PREDEF ("_CLS",    "Class Code", "Returns PCI class code and subclass"),
+    AH_PREDEF ("_CPC",    "Continuous Performance Control", "Returns a list of performance control interfaces"),
+    AH_PREDEF ("_CR3",    "Warm/Standby Temperature", "Temperature for a fast low power state"),
+    AH_PREDEF ("_CRS",    "Current Resource Settings", "Returns the current resource settings for a device"),
+    AH_PREDEF ("_CRT",    "Critical Temperature", "Returns the shutdown critical temperature"),
+    AH_PREDEF ("_CSD",    "C-State Dependencies", "Returns a list of C-state dependencies"),
+    AH_PREDEF ("_CST",    "C-States", "Returns a list of supported C-states"),
+    AH_PREDEF ("_CWS",    "Clear Wake Alarm Status", "Clear the status of wake alarms"),
+    AH_PREDEF ("_DBT",    "Debounce Timeout", "Timeout value, Resource Descriptor field"),
+    AH_PREDEF ("_DCK",    "Dock Present", "Sets docking isolation. Presence indicates device is a docking station"),
+    AH_PREDEF ("_DCS",    "Display Current Status", "Returns status of the display output device"),
+    AH_PREDEF ("_DDC",    "Display Data Current", "Returns the EDID for the display output device"),
+    AH_PREDEF ("_DDN",    "DOS Device Name", "Returns a device logical name"),
+    AH_PREDEF ("_DEC",    "Decode", "Device decoding type, Resource Descriptor field"),
+    AH_PREDEF ("_DEP",    "Dependencies", "Returns a list of operation region dependencies"),
+    AH_PREDEF ("_DGS",    "Display Graphics State", "Return the current state of the output device"),
+    AH_PREDEF ("_DIS",    "Disable Device", "Disables a device"),
+    AH_PREDEF ("_DLM",    "Device Lock Mutex", "Defines mutex for OS/AML sharing"),
+    AH_PREDEF ("_DMA",    "Direct Memory Access", "Returns device current resources for DMA transactions, and resource field"),
+    AH_PREDEF ("_DOD",    "Display Output Devices", "Enumerate all devices attached to the display adapter"),
+    AH_PREDEF ("_DOS",    "Disable Output Switching", "Sets the display output switching mode"),
+    AH_PREDEF ("_DPL",    "Device Selection Polarity", "Polarity of Device Selection signal, Resource Descriptor field"),
+    AH_PREDEF ("_DRS",    "Drive Strength", "Drive Strength setting for GPIO connection, Resource Descriptor field"),
+    AH_PREDEF ("_DSD",    "Device-Specific Data", "Returns a list of device property information"),
+    AH_PREDEF ("_DSM",    "Device-Specific Method", "Executes device-specific functions"),
+    AH_PREDEF ("_DSS",    "Device Set State", "Sets the display device state"),
+    AH_PREDEF ("_DSW",    "Device Sleep Wake", "Sets the sleep and wake transition states for a device"),
+    AH_PREDEF ("_DTI",    "Device Temperature Indication", "Conveys native device temperature to the platform"),
+    AH_PREDEF ("_Exx",    "Edge-Triggered GPE", "Method executed as a result of a general-purpose event"),
+    AH_PREDEF ("_EC_",    "Embedded Controller", "returns EC offset and query information"),
+    AH_PREDEF ("_EDL",    "Eject Device List", "Returns a list of devices that are dependent on a device (docking)"),
+    AH_PREDEF ("_EJD",    "Ejection Dependent Device", "Returns the name of dependent (parent) device (docking)"),
+    AH_PREDEF ("_EJx",    "Eject Device", "Begin or cancel a device ejection request (docking)"),
+    AH_PREDEF ("_END",    "Endianness", "Endian orientation, Resource Descriptor field"),
+    AH_PREDEF ("_EVT",    "Event", "Event method for GPIO events"),
+    AH_PREDEF ("_FDE",    "Floppy Disk Enumerate", "Returns floppy disk configuration information"),
+    AH_PREDEF ("_FDI",    "Floppy Drive Information", "Returns a floppy drive information block"),
+    AH_PREDEF ("_FDM",    "Floppy Drive Mode", "Sets a floppy drive speed"),
+    AH_PREDEF ("_FIF",    "Fan Information", "Returns fan device information"),
+    AH_PREDEF ("_FIT",    "Firmware Interface Table", "Returns a list of NFIT structures"),
+    AH_PREDEF ("_FIX",    "Fixed Register Resource Provider", "Returns a list of devices that implement FADT register blocks"),
+    AH_PREDEF ("_FLC",    "Flow Control", "Flow control, Resource Descriptor field"),
+    AH_PREDEF ("_FPS",    "Fan Performance States", "Returns a list of supported fan performance states"),
+    AH_PREDEF ("_FSL",    "Fan Set Level", "Control method that sets the fan device's speed level (performance state)"),
+    AH_PREDEF ("_FST",    "Fan Status", "Returns current status information for a fan device"),
+    AH_PREDEF ("_GAI",    "Get Averaging Interval", "Returns the power meter averaging interval"),
+    AH_PREDEF ("_GCP",    "Get Capabilities", "Get device time capabilities"),
+    AH_PREDEF ("_GHL",    "Get Hardware Limit", "Returns the hardware limit enforced by the power meter"),
+    AH_PREDEF ("_GL_",    "Global Lock", "OS-defined Global Lock mutex object"),
+    AH_PREDEF ("_GLK",    "Get Global Lock Requirement", "Returns a device's Global Lock requirement for device access"),
+    AH_PREDEF ("_GPD",    "Get Post Data", "Returns the value of the VGA device that will be posted at boot"),
+    AH_PREDEF ("_GPE",    "General Purpose Events", "Predefined scope (\\_GPE) or SCI number for EC"),
+    AH_PREDEF ("_GRA",    "Granularity", "Address space granularity, Resource Descriptor field"),
+    AH_PREDEF ("_GRT",    "Get Real Time", "Returns current time-of-day from a time/alarm device"),
+    AH_PREDEF ("_GSB",    "Global System Interrupt Base", "Returns the GSB for a I/O APIC device"),
+    AH_PREDEF ("_GTF",    "Get Task File", "Returns a list of ATA commands to restore a drive to default state"),
+    AH_PREDEF ("_GTM",    "Get Timing Mode", "Returns a list of IDE controller timing information"),
+    AH_PREDEF ("_GTS",    "Going To Sleep", "Inform AML of pending sleep"),
+    AH_PREDEF ("_GWS",    "Get Wake Status", "Return status of wake alarms"),
+    AH_PREDEF ("_HE_",    "High-Edge", "Interrupt triggering, Resource Descriptor field"),
+    AH_PREDEF ("_HID",    "Hardware ID", "Returns a device's Plug and Play Hardware ID"),
+    AH_PREDEF ("_HOT",    "Hot Temperature", "Returns the critical temperature for sleep (entry to S4)"),
+    AH_PREDEF ("_HPP",    "Hot Plug Parameters", "Returns a list of hot-plug information for a PCI device"),
+    AH_PREDEF ("_HPX",    "Hot Plug Parameter Extensions", "Returns a list of hot-plug information for a PCI device. Supersedes _HPP"),
+    AH_PREDEF ("_HRV",    "Hardware Revision", "Returns a hardware revision value"),
+    AH_PREDEF ("_IFT",    "IPMI Interface Type", "See the Intelligent Platform Management Interface Specification"),
+    AH_PREDEF ("_INI",    "Initialize", "Performs device specific initialization"),
+    AH_PREDEF ("_INT",    "Interrupts", "Interrupt mask bits, Resource Descriptor field"),
+    AH_PREDEF ("_IOR",    "I/O Restriction", "Restriction type, Resource Descriptor field"),
+    AH_PREDEF ("_IRC",    "Inrush Current", "Presence indicates that a device has a significant inrush current draw"),
+    AH_PREDEF ("_Lxx",    "Level-Triggered GPE", "Control method executed as a result of a general-purpose event"),
+    AH_PREDEF ("_LCK",    "Lock Device", "Locks or unlocks a device (docking)"),
+    AH_PREDEF ("_LEN",    "Length", "Range length, Resource Descriptor field"),
+    AH_PREDEF ("_LID",    "Lid Status", "Returns the open/closed status of the lid on a mobile system"),
+    AH_PREDEF ("_LIN",    "Lines In Use", "Handshake lines, Resource Descriptor field"),
+    AH_PREDEF ("_LL_",    "Low Level", "Interrupt polarity, Resource Descriptor field"),
+    AH_PREDEF ("_LPD",    "Low Power Dependencies", "Returns a list of dependencies for low power idle entry"),
+    AH_PREDEF ("_LPI",    "Low Power Idle States", "Returns a list of supported low power idle states"),
+    AH_PREDEF ("_MAF",    "Maximum Address Fixed", "Resource Descriptor field"),
+    AH_PREDEF ("_MAT",    "Multiple APIC Table Entry", "Returns a list of MADT APIC structure entries"),
+    AH_PREDEF ("_MAX",    "Maximum Base Address", "Resource Descriptor field"),
+    AH_PREDEF ("_MBM",    "Memory Bandwidth Monitoring Data", "Returns bandwidth monitoring data for a memory device"),
+    AH_PREDEF ("_MEM",    "Memory Attributes", "Resource Descriptor field"),
+    AH_PREDEF ("_MIF",    "Minimum Address Fixed", "Resource Descriptor field"),
+    AH_PREDEF ("_MIN",    "Minimum Base Address", "Resource Descriptor field"),
+    AH_PREDEF ("_MLS",    "Multiple Language String", "Returns a device description in multiple languages"),
+    AH_PREDEF ("_MOD",    "Mode", "Interrupt mode, Resource Descriptor field"),
+    AH_PREDEF ("_MSG",    "Message", "Sets the system message waiting status indicator"),
+    AH_PREDEF ("_MSM",    "Memory Set Monitoring", "Sets bandwidth monitoring parameters for a memory device"),
+    AH_PREDEF ("_MTL",    "Minimum Throttle Limit", "Returns the minimum throttle limit for a thermal zone"),
+    AH_PREDEF ("_MTP",    "Memory Type", "Resource Descriptor field"),
+    AH_PREDEF ("_NTT",    "Notification Temperature Threshold", "Returns a threshold for device temperature change that requires platform notification"),
+    AH_PREDEF ("_OFF",    "Power Off", "Sets a power resource to the off state"),
+    AH_PREDEF ("_ON_",    "Power On", "Sets a power resource to the on state"),
+    AH_PREDEF ("_OS_",    "Operating System", "Returns a string that identifies the operating system"),
+    AH_PREDEF ("_OSC",    "Operating System Capabilities", "Inform AML of host features and capabilities"),
+    AH_PREDEF ("_OSI",    "Operating System Interfaces", "Returns supported interfaces, behaviors, and features"),
+    AH_PREDEF ("_OST",    "OSPM Status Indication", "Inform AML of event processing status"),
+    AH_PREDEF ("_PAI",    "Power Averaging Interval", "Sets the averaging interval for a power meter"),
+    AH_PREDEF ("_PAR",    "Parity", "Parity bits, Resource Descriptor field"),
+    AH_PREDEF ("_PCL",    "Power Consumer List", "Returns a list of devices powered by a power source"),
+    AH_PREDEF ("_PCT",    "Performance Control", "Returns processor performance control and status registers"),
+    AH_PREDEF ("_PDC",    "Processor Driver Capabilities", "Inform AML of processor driver capabilities"),
+    AH_PREDEF ("_PDL",    "P-state Depth Limit", "Returns the lowest available performance P-state"),
+    AH_PREDEF ("_PHA",    "Clock Phase", "Clock phase, Resource Descriptor field"),
+    AH_PREDEF ("_PIC",    "Interrupt Model", "Inform AML of the interrupt model in use"),
+    AH_PREDEF ("_PIF",    "Power Source Information", "Returns a Power Source information block"),
+    AH_PREDEF ("_PIN",    "Pin List", "Pin list, Resource Descriptor field"),
+    AH_PREDEF ("_PLD",    "Physical Location of Device", "Returns a device's physical location information"),
+    AH_PREDEF ("_PMC",    "Power Meter Capabilities", "Returns a list of Power Meter capabilities info"),
+    AH_PREDEF ("_PMD",    "Power Metered Devices", "Returns a list of devices that are measured by the power meter device"),
+    AH_PREDEF ("_PMM",    "Power Meter Measurement", "Returns the current value of the Power Meter"),
+    AH_PREDEF ("_POL",    "Polarity", "Interrupt polarity, Resource Descriptor field"),
+    AH_PREDEF ("_PPC",    "Performance Present Capabilities", "Returns a list of the performance states currently supported by the platform"),
+    AH_PREDEF ("_PPE",    "Polling for Platform Error", "Returns the polling interval to retrieve Corrected Platform Error information"),
+    AH_PREDEF ("_PPI",    "Pin Configuration", "Resource Descriptor field"),
+    AH_PREDEF ("_PR",     "Processor", "Predefined scope for processor objects"),
+    AH_PREDEF ("_PR0",    "Power Resources for D0", "Returns a list of dependent power resources to enter state D0 (fully on)"),
+    AH_PREDEF ("_PR1",    "Power Resources for D1", "Returns a list of dependent power resources to enter state D1"),
+    AH_PREDEF ("_PR2",    "Power Resources for D2", "Returns a list of dependent power resources to enter state D2"),
+    AH_PREDEF ("_PR3",    "Power Resources for D3hot", "Returns a list of dependent power resources to enter state D3hot"),
+    AH_PREDEF ("_PRE",    "Power Resources for Enumeration", "Returns a list of dependent power resources to enumerate devices on a bus"),
+    AH_PREDEF ("_PRL",    "Power Source Redundancy List", "Returns a list of power source devices in the same redundancy grouping"),
+    AH_PREDEF ("_PRR",    "Power Resource for Reset", "Execute a reset on a device"),
+    AH_PREDEF ("_PRS",    "Possible Resource Settings", "Returns a list of a device's possible resource settings"),
+    AH_PREDEF ("_PRT",    "PCI Routing Table", "Returns a list of PCI interrupt mappings"),
+    AH_PREDEF ("_PRW",    "Power Resources for Wake", "Returns a list of dependent power resources for waking"),
+    AH_PREDEF ("_PS0",    "Power State 0", "Sets a device's power state to D0 (device fully on)"),
+    AH_PREDEF ("_PS1",    "Power State 1", "Sets a device's power state to D1"),
+    AH_PREDEF ("_PS2",    "Power State 2", "Sets a device's power state to D2"),
+    AH_PREDEF ("_PS3",    "Power State 3", "Sets a device's power state to D3 (device off)"),
+    AH_PREDEF ("_PSC",    "Power State Current", "Returns a device's current power state"),
+    AH_PREDEF ("_PSD",    "Power State Dependencies", "Returns processor P-State dependencies"),
+    AH_PREDEF ("_PSE",    "Power State for Enumeration", "Put a bus into enumeration power mode"),
+    AH_PREDEF ("_PSL",    "Passive List", "Returns a list of passive cooling device objects"),
+    AH_PREDEF ("_PSR",    "Power Source", "Returns the power source device currently in use"),
+    AH_PREDEF ("_PSS",    "Performance Supported States", "Returns a list of supported processor performance states"),
+    AH_PREDEF ("_PSV",    "Passive Temperature", "Returns the passive trip point temperature"),
+    AH_PREDEF ("_PSW",    "Power State Wake", "Sets a device's wake function"),
+    AH_PREDEF ("_PTC",    "Processor Throttling Control", "Returns throttling control and status registers"),
+    AH_PREDEF ("_PTP",    "Power Trip Points", "Sets trip points for the Power Meter device"),
+    AH_PREDEF ("_PTS",    "Prepare To Sleep", "Inform the platform of an impending sleep transition"),
+    AH_PREDEF ("_PUR",    "Processor Utilization Request", "Returns the number of processors that the platform would like to idle"),
+    AH_PREDEF ("_PXM",    "Device Proximity", "Returns a device's proximity domain identifier"),
+    AH_PREDEF ("_Qxx",    "EC Query", "Embedded Controller query and SMBus Alarm control method"),
+    AH_PREDEF ("_RBO",    "Register Bit Offset", "Resource Descriptor field"),
+    AH_PREDEF ("_RBW",    "Register Bit Width", "Resource Descriptor field"),
+    AH_PREDEF ("_RDI",    "Resource Dependencies for Idle", "Returns a list of dependencies for idle states"),
+    AH_PREDEF ("_REG",    "Region Availability", "Inform AML code of an operation region availability change"),
+    AH_PREDEF ("_REV",    "Supported Integer Width", "Returns the supported integer width (<= 1: 32 bits only, >=2: both 32 and 64 bits"),
+    AH_PREDEF ("_RMV",    "Removal Status", "Returns a device's removal ability status (docking)"),
+    AH_PREDEF ("_RNG",    "Range", "Memory range type, Resource Descriptor field"),
+    AH_PREDEF ("_RST",    "Device Reset", "Executes a reset on a device"),
+    AH_PREDEF ("_ROM",    "Read-Only Memory", "Returns a copy of the ROM data for a display device"),
+    AH_PREDEF ("_RT_",    "Resource Type", "Resource Descriptor field"),
+    AH_PREDEF ("_RTV",    "Relative Temperature Values", "Returns temperature value information"),
+    AH_PREDEF ("_RW_",    "Read-Write Status", "Resource Descriptor field"),
+    AH_PREDEF ("_RXL",    "Receive Buffer Size", "Serial channel buffer, Resource Descriptor field"),
+    AH_PREDEF ("_S0_",    "S0 System State", "Returns values to enter the system into the S0 state"),
+    AH_PREDEF ("_S1_",    "S1 System State", "Returns values to enter the system into the S1 state"),
+    AH_PREDEF ("_S2_",    "S2 System State", "Returns values to enter the system into the S2 state"),
+    AH_PREDEF ("_S3_",    "S3 System State", "Returns values to enter the system into the S3 state"),
+    AH_PREDEF ("_S4_",    "S4 System State", "Returns values to enter the system into the S4 state"),
+    AH_PREDEF ("_S5_",    "S5 System State", "Returns values to enter the system into the S5 state"),
+    AH_PREDEF ("_S1D",    "S1 Device State", "Returns the highest D-state supported by a device when in the S1 state"),
+    AH_PREDEF ("_S2D",    "S2 Device State", "Returns the highest D-state supported by a device when in the S2 state"),
+    AH_PREDEF ("_S3D",    "S3 Device State", "Returns the highest D-state supported by a device when in the S3 state"),
+    AH_PREDEF ("_S4D",    "S4 Device State", "Returns the highest D-state supported by a device when in the S4 state"),
+    AH_PREDEF ("_S0W",    "S0 Device Wake State", "Returns the lowest D-state that the device can wake itself from S0"),
+    AH_PREDEF ("_S1W",    "S1 Device Wake State", "Returns the lowest D-state for this device that can wake the system from S1"),
+    AH_PREDEF ("_S2W",    "S2 Device Wake State", "Returns the lowest D-state for this device that can wake the system from S2"),
+    AH_PREDEF ("_S3W",    "S3 Device Wake State", "Returns the lowest D-state for this device that can wake the system from S3"),
+    AH_PREDEF ("_S4W",    "S4 Device Wake State", "Returns the lowest D-state for this device that can wake the system from S4"),
+    AH_PREDEF ("_SB_",    "System Bus", "Predefined scope for device and bus objects"),
+    AH_PREDEF ("_SBS",    "Smart Battery Subsystem", "Returns the subsystem configuration"),
+    AH_PREDEF ("_SCP",    "Set Cooling Policy", "Sets the cooling policy (active or passive)"),
+    AH_PREDEF ("_SDD",    "Set Device Data", "Sets data for a SATA device"),
+    AH_PREDEF ("_SEG",    "PCI Segment", "Returns a device's PCI Segment Group number"),
+    AH_PREDEF ("_SHL",    "Set Hardware Limit", "Sets the hardware limit enforced by the Power Meter"),
+    AH_PREDEF ("_SHR",    "Sharable", "Interrupt share status, Resource Descriptor field"),
+    AH_PREDEF ("_SI_",    "System Indicators", "Predefined scope"),
+    AH_PREDEF ("_SIZ",    "Size", "DMA transfer size, Resource Descriptor field"),
+    AH_PREDEF ("_SLI",    "System Locality Information", "Returns a list of NUMA system localities"),
+    AH_PREDEF ("_SLV",    "Slave Mode", "Mode setting, Resource Descriptor field"),
+    AH_PREDEF ("_SPD",    "Set Post Device", "Sets which video device will be posted at boot"),
+    AH_PREDEF ("_SPE",    "Speed", "Connection speed, Resource Descriptor field"),
+    AH_PREDEF ("_SRS",    "Set Resource Settings", "Sets a device's resource allocation"),
+    AH_PREDEF ("_SRT",    "Set Real Time", "Sets the current time for a time/alarm device"),
+    AH_PREDEF ("_SRV",    "IPMI Spec Revision", "See the Intelligent Platform Management Interface Specification"),
+    AH_PREDEF ("_SST",    "System Status", "Sets the system status indicator"),
+    AH_PREDEF ("_STA",    "Status", "Returns the current status of a Device or Power Resource"),
+    AH_PREDEF ("_STB",    "Stop Bits", "Serial channel stop bits, Resource Descriptor field"),
+    AH_PREDEF ("_STM",    "Set Timing Mode", "Sets an IDE controller transfer timings"),
+    AH_PREDEF ("_STP",    "Set Expired Timer Wake Policy", "Sets expired timer policies of the wake alarm device"),
+    AH_PREDEF ("_STR",    "Description String", "Returns a device's description string"),
+    AH_PREDEF ("_STV",    "Set Timer Value", "Set timer values of the wake alarm device"),
+    AH_PREDEF ("_SUB",    "Subsystem ID", "Returns the subsystem ID for a device"),
+    AH_PREDEF ("_SUN",    "Slot User Number", "Returns the slot unique ID number"),
+    AH_PREDEF ("_SWS",    "System Wake Source", "Returns the source event that caused the system to wake"),
+    AH_PREDEF ("_T_x",    "Emitted by ASL Compiler", "Reserved for use by ASL compilers"),
+    AH_PREDEF ("_TC1",    "Thermal Constant 1", "Returns TC1 for the passive cooling formula"),
+    AH_PREDEF ("_TC2",    "Thermal Constant 2", "Returns TC2 for the passive cooling formula"),
+    AH_PREDEF ("_TDL",    "T-State Depth Limit", "Returns the _TSS entry number of the lowest power throttling state"),
+    AH_PREDEF ("_TFP",    "Thermal Fast Sampling Period", "Returns the sampling period for passive cooling"),
+    AH_PREDEF ("_TIP",    "Expired Timer Wake Policy", "Returns timer policies of the wake alarm device"),
+    AH_PREDEF ("_TIV",    "Timer Values", "Returns remaining time of the wake alarm device"),
+    AH_PREDEF ("_TMP",    "Temperature", "Returns a thermal zone's current temperature"),
+    AH_PREDEF ("_TPC",    "Throttling Present Capabilities", "Returns the current number of supported throttling states"),
+    AH_PREDEF ("_TPT",    "Trip Point Temperature", "Inform AML that a device's embedded temperature sensor has crossed a temperature trip point"),
+    AH_PREDEF ("_TRA",    "Translation", "Address translation offset, Resource Descriptor field"),
+    AH_PREDEF ("_TRS",    "Translation Sparse", "Sparse/dense flag, Resource Descriptor field"),
+    AH_PREDEF ("_TRT",    "Thermal Relationship Table", "Returns thermal relationships between platform devices"),
+    AH_PREDEF ("_TSD",    "Throttling State Dependencies", "Returns a list of T-state dependencies"),
+    AH_PREDEF ("_TSF",    "Type-Specific Flags", "Resource Descriptor field"),
+    AH_PREDEF ("_TSN",    "Thermal Sensor Device", "Returns a reference to a thermal sensor"),
+    AH_PREDEF ("_TSP",    "Thermal Sampling Period", "Returns the thermal sampling period for passive cooling"),
+    AH_PREDEF ("_TSS",    "Throttling Supported States", "Returns supported throttling state information"),
+    AH_PREDEF ("_TST",    "Temperature Sensor Threshold", "Returns the minimum separation for a device's temperature trip points"),
+    AH_PREDEF ("_TTP",    "Translation Type", "Translation/static flag, Resource Descriptor field"),
+    AH_PREDEF ("_TTS",    "Transition To State", "Inform AML of an S-state transition"),
+    AH_PREDEF ("_TXL",    "Transmit Buffer Size", "Serial Channel buffer, Resource Descriptor field"),
+    AH_PREDEF ("_TYP",    "Type", "DMA channel type (speed), Resource Descriptor field"),
+    AH_PREDEF ("_TZ_",    "Thermal Zone", "Predefined scope: ACPI 1.0"),
+    AH_PREDEF ("_TZD",    "Thermal Zone Devices", "Returns a list of device names associated with a Thermal Zone"),
+    AH_PREDEF ("_TZM",    "Thermal Zone Member", "Returns a reference to the thermal zone of which a device is a member"),
+    AH_PREDEF ("_TZP",    "Thermal Zone Polling", "Returns a Thermal zone's polling frequency"),
+    AH_PREDEF ("_UID",    "Unique ID", "Return a device's unique persistent ID"),
+    AH_PREDEF ("_UPC",    "USB Port Capabilities", "Returns a list of USB port capabilities"),
+    AH_PREDEF ("_UPD",    "User Presence Detect", "Returns user detection information"),
+    AH_PREDEF ("_UPP",    "User Presence Polling", "Returns the recommended user presence polling interval"),
+    AH_PREDEF ("_VEN",    "Vendor Data", "Resource Descriptor field"),
+    AH_PREDEF ("_VPO",    "Video Post Options", "Returns the implemented video post options"),
+    AH_PREDEF ("_Wxx",    "Wake Event", "Method executed as a result of a wake event"),
+    AH_PREDEF ("_WAK",    "Wake", "Inform AML that the system has just awakened"),
+    AH_PREDEF ("_WPC",    "Wireless Power Calibration", "Calibrate power and notify wireless device"),
+    AH_PREDEF ("_WPP",    "Wireless Power Polling", "Get recommended polling interval"),
+    AH_PREDEF (NULL,      NULL, NULL)
+};
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiAhMatchPredefinedName
+ *
+ * PARAMETERS:  Nameseg                 - Predefined name string
+ *
+ * RETURN:      ID info struct. NULL if Nameseg not found
+ *
+ * DESCRIPTION: Lookup a predefined name.
+ *
+ ******************************************************************************/
+
+const AH_PREDEFINED_NAME *
+AcpiAhMatchPredefinedName (
+    char                        *Nameseg)
+{
+    const AH_PREDEFINED_NAME    *Info;
+
+
+    for (Info = AslPredefinedInfo; Info->Name; Info++)
+    {
+        if (ACPI_COMPARE_NAME (Nameseg, Info->Name))
+        {
+            return (Info);
+        }
+    }
+
+    return (NULL);
+}
diff --git a/usr/src/cmd/acpi/common/ahtable.c b/usr/src/cmd/acpi/common/ahtable.c
new file mode 100644
index 0000000000..beb64c85ed
--- /dev/null
+++ b/usr/src/cmd/acpi/common/ahtable.c
@@ -0,0 +1,150 @@
+/******************************************************************************
+ *
+ * Module Name: ahtable - Table of known ACPI tables with descriptions
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2016, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include "acpi.h"
+#include "accommon.h"
+
+
+/* Local prototypes */
+
+const AH_TABLE *
+AcpiAhGetTableInfo (
+    char                    *Signature);
+
+extern const AH_TABLE      AcpiSupportedTables[];
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiAhGetTableInfo
+ *
+ * PARAMETERS:  Signature           - ACPI signature (4 chars) to match
+ *
+ * RETURN:      Pointer to a valid AH_TABLE. Null if no match found.
+ *
+ * DESCRIPTION: Find a match in the "help" table of supported ACPI tables
+ *
+ ******************************************************************************/
+
+const AH_TABLE *
+AcpiAhGetTableInfo (
+    char                    *Signature)
+{
+    const AH_TABLE      *Info;
+
+
+    for (Info = AcpiSupportedTables; Info->Signature; Info++)
+    {
+        if (ACPI_COMPARE_NAME (Signature, Info->Signature))
+        {
+            return (Info);
+        }
+    }
+
+    return (NULL);
+}
+
+
+/*
+ * Note: Any tables added here should be duplicated within AcpiDmTableData
+ * in the file common/dmtable.c
+ */
+const AH_TABLE      AcpiSupportedTables[] =
+{
+    {ACPI_SIG_ASF,  "Alert Standard Format table"},
+    {ACPI_SIG_BERT, "Boot Error Record Table"},
+    {ACPI_SIG_BGRT, "Boot Graphics Resource Table"},
+    {ACPI_SIG_BOOT, "Simple Boot Flag Table"},
+    {ACPI_SIG_CPEP, "Corrected Platform Error Polling table"},
+    {ACPI_SIG_CSRT, "Core System Resource Table"},
+    {ACPI_SIG_DBG2, "Debug Port table type 2"},
+    {ACPI_SIG_DBGP, "Debug Port table"},
+    {ACPI_SIG_DMAR, "DMA Remapping table"},
+    {ACPI_SIG_DRTM, "Dynamic Root of Trust for Measurement table"},
+    {ACPI_SIG_DSDT, "Differentiated System Description Table (AML table)"},
+    {ACPI_SIG_ECDT, "Embedded Controller Boot Resources Table"},
+    {ACPI_SIG_EINJ, "Error Injection table"},
+    {ACPI_SIG_ERST, "Error Record Serialization Table"},
+    {ACPI_SIG_FACS, "Firmware ACPI Control Structure"},
+    {ACPI_SIG_FADT, "Fixed ACPI Description Table (FADT)"},
+    {ACPI_SIG_FPDT, "Firmware Performance Data Table"},
+    {ACPI_SIG_GTDT, "Generic Timer Description Table"},
+    {ACPI_SIG_HEST, "Hardware Error Source Table"},
+    {ACPI_SIG_HPET, "High Precision Event Timer table"},
+    {ACPI_SIG_IORT, "IO Remapping Table"},
+    {ACPI_SIG_IVRS, "I/O Virtualization Reporting Structure"},
+    {ACPI_SIG_LPIT, "Low Power Idle Table"},
+    {ACPI_SIG_MADT, "Multiple APIC Description Table (MADT)"},
+    {ACPI_SIG_MCFG, "Memory Mapped Configuration table"},
+    {ACPI_SIG_MCHI, "Management Controller Host Interface table"},
+    {ACPI_SIG_MPST, "Memory Power State Table"},
+    {ACPI_SIG_MSCT, "Maximum System Characteristics Table"},
+    {ACPI_SIG_MSDM, "Microsoft Data Management table"},
+    {ACPI_SIG_MTMR, "MID Timer Table"},
+    {ACPI_SIG_NFIT, "NVDIMM Firmware Interface Table"},
+    {ACPI_SIG_PCCT, "Platform Communications Channel Table"},
+    {ACPI_SIG_PMTT, "Platform Memory Topology Table"},
+    {ACPI_RSDP_NAME,"Root System Description Pointer"},
+    {ACPI_SIG_RSDT, "Root System Description Table"},
+    {ACPI_SIG_S3PT, "S3 Performance Table"},
+    {ACPI_SIG_SBST, "Smart Battery Specification Table"},
+    {ACPI_SIG_SLIC, "Software Licensing Description Table"},
+    {ACPI_SIG_SLIT, "System Locality Information Table"},
+    {ACPI_SIG_SPCR, "Serial Port Console Redirection table"},
+    {ACPI_SIG_SPMI, "Server Platform Management Interface table"},
+    {ACPI_SIG_SRAT, "System Resource Affinity Table"},
+    {ACPI_SIG_SSDT, "Secondary System Description Table (AML table)"},
+    {ACPI_SIG_STAO, "Status Override table"},
+    {ACPI_SIG_TCPA, "Trusted Computing Platform Alliance table"},
+    {ACPI_SIG_TPM2, "Trusted Platform Module hardware interface table"},
+    {ACPI_SIG_UEFI, "UEFI Boot Optimization Table"},
+    {ACPI_SIG_VRTC, "Virtual Real-Time Clock Table"},
+    {ACPI_SIG_WAET, "Windows ACPI Emulated Devices Table"},
+    {ACPI_SIG_WDAT, "Watchdog Action Table"},
+    {ACPI_SIG_WDDT, "Watchdog Description Table"},
+    {ACPI_SIG_WDRT, "Watchdog Resource Table"},
+    {ACPI_SIG_WPBT, "Windows Platform Binary Table"},
+    {ACPI_SIG_XENV, "Xen Environment table"},
+    {ACPI_SIG_XSDT, "Extended System Description Table"},
+    {NULL,          NULL}
+};
diff --git a/usr/src/cmd/acpi/common/ahuuids.c b/usr/src/cmd/acpi/common/ahuuids.c
new file mode 100644
index 0000000000..ec75624d46
--- /dev/null
+++ b/usr/src/cmd/acpi/common/ahuuids.c
@@ -0,0 +1,133 @@
+/******************************************************************************
+ *
+ * Module Name: ahuuids - Table of known ACPI-related UUIDs
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2016, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include "acpi.h"
+#include "accommon.h"
+#include "acuuid.h"
+
+#define _COMPONENT          ACPI_UTILITIES
+        ACPI_MODULE_NAME    ("ahuuids")
+
+
+/*
+ * Table of "known" (ACPI-related) UUIDs
+ */
+const AH_UUID  AcpiUuids[] =
+{
+    {"[Controllers]",               NULL},
+    {"GPIO Controller",             UUID_GPIO_CONTROLLER},
+    {"USB Controller",              UUID_USB_CONTROLLER},
+    {"SATA Controller",             UUID_SATA_CONTROLLER},
+
+    {"[Devices]",                   NULL},
+    {"PCI Host Bridge Device",      UUID_PCI_HOST_BRIDGE},
+    {"HID I2C Device",              UUID_I2C_DEVICE},
+    {"Power Button Device",         UUID_POWER_BUTTON},
+
+    {"[Interfaces]",                NULL},
+    {"Device Labeling Interface",   UUID_DEVICE_LABELING},
+    {"Physical Presence Interface", UUID_PHYSICAL_PRESENCE},
+
+    {"[Non-volatile DIMM and NFIT table]",       NULL},
+    {"Volatile Memory Region",      UUID_VOLATILE_MEMORY},
+    {"Persistent Memory Region",    UUID_PERSISTENT_MEMORY},
+    {"NVDIMM Control Region",       UUID_CONTROL_REGION},
+    {"NVDIMM Data Region",          UUID_DATA_REGION},
+    {"Volatile Virtual Disk",       UUID_VOLATILE_VIRTUAL_DISK},
+    {"Volatile Virtual CD",         UUID_VOLATILE_VIRTUAL_CD},
+    {"Persistent Virtual Disk",     UUID_PERSISTENT_VIRTUAL_DISK},
+    {"Persistent Virtual CD",       UUID_PERSISTENT_VIRTUAL_CD},
+
+    {"[Miscellaneous]",             NULL},
+    {"Platform-wide Capabilities",  UUID_PLATFORM_CAPABILITIES},
+    {"Dynamic Enumeration",         UUID_DYNAMIC_ENUMERATION},
+    {"Battery Thermal Limit",       UUID_BATTERY_THERMAL_LIMIT},
+    {"Thermal Extensions",          UUID_THERMAL_EXTENSIONS},
+    {"Device Properties for _DSD",  UUID_DEVICE_PROPERTIES},
+
+    {NULL, NULL}
+};
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiAhMatchUuid
+ *
+ * PARAMETERS:  Data                - Data buffer containing a UUID
+ *
+ * RETURN:      ASCII description string for the UUID if it is found.
+ *
+ * DESCRIPTION: Returns a description string for "known" UUIDs, which are
+ *              are UUIDs that are related to ACPI in some way.
+ *
+ ******************************************************************************/
+
+const char *
+AcpiAhMatchUuid (
+    UINT8                   *Data)
+{
+    const AH_UUID           *Info;
+    UINT8                   UuidBuffer[UUID_BUFFER_LENGTH];
+
+
+    /* Walk the table of known ACPI-related UUIDs */
+
+    for (Info = AcpiUuids; Info->Description; Info++)
+    {
+        /* Null string means desciption is a UUID class */
+
+        if (!Info->String)
+        {
+            continue;
+        }
+
+        AcpiUtConvertStringToUuid (Info->String, UuidBuffer);
+
+        if (!memcmp (Data, UuidBuffer, UUID_BUFFER_LENGTH))
+        {
+            return (Info->Description);
+        }
+    }
+
+    return (NULL);
+}
diff --git a/usr/src/cmd/acpi/common/cmfsize.c b/usr/src/cmd/acpi/common/cmfsize.c
new file mode 100644
index 0000000000..d9df6bc06c
--- /dev/null
+++ b/usr/src/cmd/acpi/common/cmfsize.c
@@ -0,0 +1,113 @@
+/******************************************************************************
+ *
+ * Module Name: cfsize - Common get file size function
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2016, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include "acpi.h"
+#include "accommon.h"
+#include "acapps.h"
+#include <stdio.h>
+
+#define _COMPONENT          ACPI_TOOLS
+        ACPI_MODULE_NAME    ("cmfsize")
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    CmGetFileSize
+ *
+ * PARAMETERS:  File                    - Open file descriptor
+ *
+ * RETURN:      File Size. On error, -1 (ACPI_UINT32_MAX)
+ *
+ * DESCRIPTION: Get the size of a file. Uses seek-to-EOF. File must be open.
+ *              Does not disturb the current file pointer.
+ *
+ ******************************************************************************/
+
+UINT32
+CmGetFileSize (
+    ACPI_FILE               File)
+{
+    long                    FileSize;
+    long                    CurrentOffset;
+    ACPI_STATUS             Status;
+
+
+    /* Save the current file pointer, seek to EOF to obtain file size */
+
+    CurrentOffset = AcpiOsGetFileOffset (File);
+    if (CurrentOffset < 0)
+    {
+        goto OffsetError;
+    }
+
+    Status = AcpiOsSetFileOffset (File, 0, ACPI_FILE_END);
+    if (ACPI_FAILURE (Status))
+    {
+        goto SeekError;
+    }
+
+    FileSize = AcpiOsGetFileOffset (File);
+    if (FileSize < 0)
+    {
+        goto OffsetError;
+    }
+
+    /* Restore original file pointer */
+
+    Status = AcpiOsSetFileOffset (File, CurrentOffset, ACPI_FILE_BEGIN);
+    if (ACPI_FAILURE (Status))
+    {
+        goto SeekError;
+    }
+
+    return ((UINT32) FileSize);
+
+
+OffsetError:
+    AcpiLogError ("Could not get file offset");
+    return (ACPI_UINT32_MAX);
+
+SeekError:
+    AcpiLogError ("Could not set file offset");
+    return (ACPI_UINT32_MAX);
+}
diff --git a/usr/src/cmd/acpi/common/dmextern.c b/usr/src/cmd/acpi/common/dmextern.c
new file mode 100644
index 0000000000..d1a6755791
--- /dev/null
+++ b/usr/src/cmd/acpi/common/dmextern.c
@@ -0,0 +1,1352 @@
+/******************************************************************************
+ *
+ * Module Name: dmextern - Support for External() ASL statements
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2016, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include "acpi.h"
+#include "accommon.h"
+#include "amlcode.h"
+#include "acnamesp.h"
+#include "acdisasm.h"
+#include "aslcompiler.h"
+#include <stdio.h>
+#include <errno.h>
+
+
+/*
+ * This module is used for application-level code (iASL disassembler) only.
+ *
+ * It contains the code to create and emit any necessary External() ASL
+ * statements for the module being disassembled.
+ */
+#define _COMPONENT          ACPI_CA_DISASSEMBLER
+        ACPI_MODULE_NAME    ("dmextern")
+
+
+/*
+ * This table maps ACPI_OBJECT_TYPEs to the corresponding ASL
+ * ObjectTypeKeyword. Used to generate typed external declarations
+ */
+static const char           *AcpiGbl_DmTypeNames[] =
+{
+    /* 00 */ ", UnknownObj",        /* Type ANY */
+    /* 01 */ ", IntObj",
+    /* 02 */ ", StrObj",
+    /* 03 */ ", BuffObj",
+    /* 04 */ ", PkgObj",
+    /* 05 */ ", FieldUnitObj",
+    /* 06 */ ", DeviceObj",
+    /* 07 */ ", EventObj",
+    /* 08 */ ", MethodObj",
+    /* 09 */ ", MutexObj",
+    /* 10 */ ", OpRegionObj",
+    /* 11 */ ", PowerResObj",
+    /* 12 */ ", ProcessorObj",
+    /* 13 */ ", ThermalZoneObj",
+    /* 14 */ ", BuffFieldObj",
+    /* 15 */ ", DDBHandleObj",
+    /* 16 */ "",                    /* Debug object */
+    /* 17 */ ", FieldUnitObj",
+    /* 18 */ ", FieldUnitObj",
+    /* 19 */ ", FieldUnitObj"
+};
+
+#define METHOD_SEPARATORS           " \t,()\n"
+
+
+/* Local prototypes */
+
+static const char *
+AcpiDmGetObjectTypeName (
+    ACPI_OBJECT_TYPE        Type);
+
+static char *
+AcpiDmNormalizeParentPrefix (
+    ACPI_PARSE_OBJECT       *Op,
+    char                    *Path);
+
+static void
+AcpiDmAddPathToExternalList (
+    char                    *Path,
+    UINT8                   Type,
+    UINT32                  Value,
+    UINT16                  Flags);
+
+static ACPI_STATUS
+AcpiDmCreateNewExternal (
+    char                    *ExternalPath,
+    char                    *InternalPath,
+    UINT8                   Type,
+    UINT32                  Value,
+    UINT16                  Flags);
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiDmGetObjectTypeName
+ *
+ * PARAMETERS:  Type                - An ACPI_OBJECT_TYPE
+ *
+ * RETURN:      Pointer to a string
+ *
+ * DESCRIPTION: Map an object type to the ASL object type string.
+ *
+ ******************************************************************************/
+
+static const char *
+AcpiDmGetObjectTypeName (
+    ACPI_OBJECT_TYPE        Type)
+{
+
+    if (Type == ACPI_TYPE_LOCAL_SCOPE)
+    {
+        Type = ACPI_TYPE_DEVICE;
+    }
+    else if (Type > ACPI_TYPE_LOCAL_INDEX_FIELD)
+    {
+        return ("");
+    }
+
+    return (AcpiGbl_DmTypeNames[Type]);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiDmNormalizeParentPrefix
+ *
+ * PARAMETERS:  Op                  - Parse op
+ *              Path                - Path with parent prefix
+ *
+ * RETURN:      The full pathname to the object (from the namespace root)
+ *
+ * DESCRIPTION: Returns the full pathname of a path with parent prefix
+ *              The caller must free the fullpath returned.
+ *
+ ******************************************************************************/
+
+static char *
+AcpiDmNormalizeParentPrefix (
+    ACPI_PARSE_OBJECT       *Op,
+    char                    *Path)
+{
+    ACPI_NAMESPACE_NODE     *Node;
+    char                    *Fullpath;
+    char                    *ParentPath;
+    ACPI_SIZE               Length;
+    UINT32                  Index = 0;
+
+
+    if (!Op)
+    {
+        return (NULL);
+    }
+
+    /* Search upwards in the parse tree until we reach the next namespace node */
+
+    Op = Op->Common.Parent;
+    while (Op)
+    {
+        if (Op->Common.Node)
+        {
+            break;
+        }
+
+        Op = Op->Common.Parent;
+    }
+
+    if (!Op)
+    {
+        return (NULL);
+    }
+
+    /*
+     * Find the actual parent node for the reference:
+     * Remove all carat prefixes from the input path.
+     * There may be multiple parent prefixes (For example, ^^^M000)
+     */
+    Node = Op->Common.Node;
+    while (Node && (*Path == (UINT8) AML_PARENT_PREFIX))
+    {
+        Node = Node->Parent;
+        Path++;
+    }
+
+    if (!Node)
+    {
+        return (NULL);
+    }
+
+    /* Get the full pathname for the parent node */
+
+    ParentPath = AcpiNsGetExternalPathname (Node);
+    if (!ParentPath)
+    {
+        return (NULL);
+    }
+
+    Length = (strlen (ParentPath) + strlen (Path) + 1);
+    if (ParentPath[1])
+    {
+        /*
+         * If ParentPath is not just a simple '\', increment the length
+         * for the required dot separator (ParentPath.Path)
+         */
+        Length++;
+
+        /* For External() statements, we do not want a leading '\' */
+
+        if (*ParentPath == AML_ROOT_PREFIX)
+        {
+            Index = 1;
+        }
+    }
+
+    Fullpath = ACPI_ALLOCATE_ZEROED (Length);
+    if (!Fullpath)
+    {
+        goto Cleanup;
+    }
+
+    /*
+     * Concatenate parent fullpath and path. For example,
+     * parent fullpath "\_SB_", Path "^INIT", Fullpath "\_SB_.INIT"
+     *
+     * Copy the parent path
+     */
+    strcpy (Fullpath, &ParentPath[Index]);
+
+    /*
+     * Add dot separator
+     * (don't need dot if parent fullpath is a single backslash)
+     */
+    if (ParentPath[1])
+    {
+        strcat (Fullpath, ".");
+    }
+
+    /* Copy child path (carat parent prefix(es) were skipped above) */
+
+    strcat (Fullpath, Path);
+
+Cleanup:
+    ACPI_FREE (ParentPath);
+    return (Fullpath);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiDmAddToExternalFileList
+ *
+ * PARAMETERS:  PathList            - Single path or list separated by comma
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Add external files to global list
+ *
+ ******************************************************************************/
+
+ACPI_STATUS
+AcpiDmAddToExternalFileList (
+    char                    *Pathname)
+{
+    ACPI_EXTERNAL_FILE      *ExternalFile;
+    char                    *LocalPathname;
+
+
+    if (!Pathname)
+    {
+        return (AE_OK);
+    }
+
+    LocalPathname = ACPI_ALLOCATE (strlen (Pathname) + 1);
+    if (!LocalPathname)
+    {
+        return (AE_NO_MEMORY);
+    }
+
+    ExternalFile = ACPI_ALLOCATE_ZEROED (sizeof (ACPI_EXTERNAL_FILE));
+    if (!ExternalFile)
+    {
+        ACPI_FREE (LocalPathname);
+        return (AE_NO_MEMORY);
+    }
+
+    /* Take a copy of the file pathname */
+
+    strcpy (LocalPathname, Pathname);
+    ExternalFile->Path = LocalPathname;
+
+    if (AcpiGbl_ExternalFileList)
+    {
+        ExternalFile->Next = AcpiGbl_ExternalFileList;
+    }
+
+    AcpiGbl_ExternalFileList = ExternalFile;
+    return (AE_OK);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiDmClearExternalFileList
+ *
+ * PARAMETERS:  None
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Clear the external file list
+ *
+ ******************************************************************************/
+
+void
+AcpiDmClearExternalFileList (
+    void)
+{
+    ACPI_EXTERNAL_FILE      *NextExternal;
+
+
+    while (AcpiGbl_ExternalFileList)
+    {
+        NextExternal = AcpiGbl_ExternalFileList->Next;
+        ACPI_FREE (AcpiGbl_ExternalFileList->Path);
+        ACPI_FREE (AcpiGbl_ExternalFileList);
+        AcpiGbl_ExternalFileList = NextExternal;
+    }
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiDmGetExternalsFromFile
+ *
+ * PARAMETERS:  None
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Process the optional external reference file.
+ *
+ * Each line in the file should be of the form:
+ *      External (<Method namepath>, MethodObj, <ArgCount>)
+ *
+ * Example:
+ *      External (_SB_.PCI0.XHC_.PS0X, MethodObj, 4)
+ *
+ ******************************************************************************/
+
+void
+AcpiDmGetExternalsFromFile (
+    void)
+{
+    FILE                    *ExternalRefFile;
+    char                    *Token;
+    char                    *MethodName;
+    UINT32                  ArgCount;
+    UINT32                  ImportCount = 0;
+
+
+    if (!Gbl_ExternalRefFilename)
+    {
+        return;
+    }
+
+    /* Open the file */
+
+    ExternalRefFile = fopen (Gbl_ExternalRefFilename, "r");
+    if (!ExternalRefFile)
+    {
+        fprintf (stderr, "Could not open external reference file \"%s\"\n",
+            Gbl_ExternalRefFilename);
+        AslAbort ();
+        return;
+    }
+
+    /* Each line defines a method */
+
+    while (fgets (StringBuffer, ASL_MSG_BUFFER_SIZE, ExternalRefFile))
+    {
+        Token = strtok (StringBuffer, METHOD_SEPARATORS);   /* "External" */
+        if (!Token)
+        {
+            continue;
+        }
+
+        if (strcmp (Token, "External"))
+        {
+            continue;
+        }
+
+        MethodName = strtok (NULL, METHOD_SEPARATORS);      /* Method namepath */
+        if (!MethodName)
+        {
+            continue;
+        }
+
+        Token = strtok (NULL, METHOD_SEPARATORS);           /* "MethodObj" */
+        if (!Token)
+        {
+            continue;
+        }
+
+        if (strcmp (Token, "MethodObj"))
+        {
+            continue;
+        }
+
+        Token = strtok (NULL, METHOD_SEPARATORS);           /* Arg count */
+        if (!Token)
+        {
+            continue;
+        }
+
+        /* Convert arg count string to an integer */
+
+        errno = 0;
+        ArgCount = strtoul (Token, NULL, 0);
+        if (errno)
+        {
+            fprintf (stderr, "Invalid argument count (%s)\n", Token);
+            continue;
+        }
+
+        if (ArgCount > 7)
+        {
+            fprintf (stderr, "Invalid argument count (%u)\n", ArgCount);
+            continue;
+        }
+
+        /* Add this external to the global list */
+
+        AcpiOsPrintf ("%s: Importing method external (%u arguments) %s\n",
+            Gbl_ExternalRefFilename, ArgCount, MethodName);
+
+        AcpiDmAddPathToExternalList (MethodName, ACPI_TYPE_METHOD,
+            ArgCount, (ACPI_EXT_RESOLVED_REFERENCE | ACPI_EXT_ORIGIN_FROM_FILE));
+        ImportCount++;
+    }
+
+    if (!ImportCount)
+    {
+        fprintf (stderr,
+            "Did not find any external methods in reference file \"%s\"\n",
+            Gbl_ExternalRefFilename);
+    }
+    else
+    {
+        /* Add the external(s) to the namespace */
+
+        AcpiDmAddExternalsToNamespace ();
+
+        AcpiOsPrintf ("%s: Imported %u external method definitions\n",
+            Gbl_ExternalRefFilename, ImportCount);
+    }
+
+    fclose (ExternalRefFile);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiDmAddOpToExternalList
+ *
+ * PARAMETERS:  Op                  - Current parser Op
+ *              Path                - Internal (AML) path to the object
+ *              Type                - ACPI object type to be added
+ *              Value               - Arg count if adding a Method object
+ *              Flags               - To be passed to the external object
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Insert a new name into the global list of Externals which
+ *              will in turn be later emitted as an External() declaration
+ *              in the disassembled output.
+ *
+ *              This function handles the most common case where the referenced
+ *              name is simply not found in the constructed namespace.
+ *
+ ******************************************************************************/
+
+void
+AcpiDmAddOpToExternalList (
+    ACPI_PARSE_OBJECT       *Op,
+    char                    *Path,
+    UINT8                   Type,
+    UINT32                  Value,
+    UINT16                  Flags)
+{
+    char                    *ExternalPath;
+    char                    *InternalPath = Path;
+    char                    *Temp;
+    ACPI_STATUS             Status;
+
+
+    ACPI_FUNCTION_TRACE (DmAddOpToExternalList);
+
+
+    if (!Path)
+    {
+        return_VOID;
+    }
+
+    /* Remove a root backslash if present */
+
+    if ((*Path == AML_ROOT_PREFIX) && (Path[1]))
+    {
+        Path++;
+    }
+
+    /* Externalize the pathname */
+
+    Status = AcpiNsExternalizeName (ACPI_UINT32_MAX, Path,
+        NULL, &ExternalPath);
+    if (ACPI_FAILURE (Status))
+    {
+        return_VOID;
+    }
+
+    /*
+     * Get the full pathname from the root if "Path" has one or more
+     * parent prefixes (^). Note: path will not contain a leading '\'.
+     */
+    if (*Path == (UINT8) AML_PARENT_PREFIX)
+    {
+        Temp = AcpiDmNormalizeParentPrefix (Op, ExternalPath);
+
+        /* Set new external path */
+
+        ACPI_FREE (ExternalPath);
+        ExternalPath = Temp;
+        if (!Temp)
+        {
+            return_VOID;
+        }
+
+        /* Create the new internal pathname */
+
+        Flags |= ACPI_EXT_INTERNAL_PATH_ALLOCATED;
+        Status = AcpiNsInternalizeName (ExternalPath, &InternalPath);
+        if (ACPI_FAILURE (Status))
+        {
+            ACPI_FREE (ExternalPath);
+            return_VOID;
+        }
+    }
+
+    /* Create the new External() declaration node */
+
+    Status = AcpiDmCreateNewExternal (ExternalPath, InternalPath,
+        Type, Value, Flags);
+    if (ACPI_FAILURE (Status))
+    {
+        ACPI_FREE (ExternalPath);
+        if (Flags & ACPI_EXT_INTERNAL_PATH_ALLOCATED)
+        {
+            ACPI_FREE (InternalPath);
+        }
+    }
+
+    return_VOID;
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiDmAddNodeToExternalList
+ *
+ * PARAMETERS:  Node                - Namespace node for object to be added
+ *              Type                - ACPI object type to be added
+ *              Value               - Arg count if adding a Method object
+ *              Flags               - To be passed to the external object
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Insert a new name into the global list of Externals which
+ *              will in turn be later emitted as an External() declaration
+ *              in the disassembled output.
+ *
+ *              This function handles the case where the referenced name has
+ *              been found in the namespace, but the name originated in a
+ *              table other than the one that is being disassembled (such
+ *              as a table that is added via the iASL -e option).
+ *
+ ******************************************************************************/
+
+void
+AcpiDmAddNodeToExternalList (
+    ACPI_NAMESPACE_NODE     *Node,
+    UINT8                   Type,
+    UINT32                  Value,
+    UINT16                  Flags)
+{
+    char                    *ExternalPath;
+    char                    *InternalPath;
+    char                    *Temp;
+    ACPI_STATUS             Status;
+
+
+    ACPI_FUNCTION_TRACE (DmAddNodeToExternalList);
+
+
+    if (!Node)
+    {
+        return_VOID;
+    }
+
+    /* Get the full external and internal pathnames to the node */
+
+    ExternalPath = AcpiNsGetExternalPathname (Node);
+    if (!ExternalPath)
+    {
+        return_VOID;
+    }
+
+    Status = AcpiNsInternalizeName (ExternalPath, &InternalPath);
+    if (ACPI_FAILURE (Status))
+    {
+        ACPI_FREE (ExternalPath);
+        return_VOID;
+    }
+
+    /* Remove the root backslash */
+
+    if ((*ExternalPath == AML_ROOT_PREFIX) && (ExternalPath[1]))
+    {
+        Temp = ACPI_ALLOCATE_ZEROED (strlen (ExternalPath) + 1);
+        if (!Temp)
+        {
+            return_VOID;
+        }
+
+        strcpy (Temp, &ExternalPath[1]);
+        ACPI_FREE (ExternalPath);
+        ExternalPath = Temp;
+    }
+
+    /* Create the new External() declaration node */
+
+    Status = AcpiDmCreateNewExternal (ExternalPath, InternalPath, Type,
+        Value, (Flags | ACPI_EXT_INTERNAL_PATH_ALLOCATED));
+    if (ACPI_FAILURE (Status))
+    {
+        ACPI_FREE (ExternalPath);
+        ACPI_FREE (InternalPath);
+    }
+
+    return_VOID;
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiDmAddPathToExternalList
+ *
+ * PARAMETERS:  Path                - External name of the object to be added
+ *              Type                - ACPI object type to be added
+ *              Value               - Arg count if adding a Method object
+ *              Flags               - To be passed to the external object
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Insert a new name into the global list of Externals which
+ *              will in turn be later emitted as an External() declaration
+ *              in the disassembled output.
+ *
+ *              This function currently is used to add externals via a
+ *              reference file (via the -fe iASL option).
+ *
+ ******************************************************************************/
+
+static void
+AcpiDmAddPathToExternalList (
+    char                    *Path,
+    UINT8                   Type,
+    UINT32                  Value,
+    UINT16                  Flags)
+{
+    char                    *InternalPath;
+    char                    *ExternalPath;
+    ACPI_STATUS             Status;
+
+
+    ACPI_FUNCTION_TRACE (DmAddPathToExternalList);
+
+
+    if (!Path)
+    {
+        return_VOID;
+    }
+
+    /* Remove a root backslash if present */
+
+    if ((*Path == AML_ROOT_PREFIX) && (Path[1]))
+    {
+        Path++;
+    }
+
+    /* Create the internal and external pathnames */
+
+    Status = AcpiNsInternalizeName (Path, &InternalPath);
+    if (ACPI_FAILURE (Status))
+    {
+        return_VOID;
+    }
+
+    Status = AcpiNsExternalizeName (ACPI_UINT32_MAX, InternalPath,
+        NULL, &ExternalPath);
+    if (ACPI_FAILURE (Status))
+    {
+        ACPI_FREE (InternalPath);
+        return_VOID;
+    }
+
+    /* Create the new External() declaration node */
+
+    Status = AcpiDmCreateNewExternal (ExternalPath, InternalPath,
+        Type, Value, (Flags | ACPI_EXT_INTERNAL_PATH_ALLOCATED));
+    if (ACPI_FAILURE (Status))
+    {
+        ACPI_FREE (ExternalPath);
+        ACPI_FREE (InternalPath);
+    }
+
+    return_VOID;
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiDmCreateNewExternal
+ *
+ * PARAMETERS:  ExternalPath        - External path to the object
+ *              InternalPath        - Internal (AML) path to the object
+ *              Type                - ACPI object type to be added
+ *              Value               - Arg count if adding a Method object
+ *              Flags               - To be passed to the external object
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Common low-level function to insert a new name into the global
+ *              list of Externals which will in turn be later emitted as
+ *              External() declarations in the disassembled output.
+ *
+ *              Note: The external name should not include a root prefix
+ *              (backslash). We do not want External() statements to contain
+ *              a leading '\', as this prevents duplicate external statements
+ *              of the form:
+ *
+ *                  External (\ABCD)
+ *                  External (ABCD)
+ *
+ *              This would cause a compile time error when the disassembled
+ *              output file is recompiled.
+ *
+ *              There are two cases that are handled here. For both, we emit
+ *              an External() statement:
+ *              1) The name was simply not found in the namespace.
+ *              2) The name was found, but it originated in a table other than
+ *              the table that is being disassembled.
+ *
+ ******************************************************************************/
+
+static ACPI_STATUS
+AcpiDmCreateNewExternal (
+    char                    *ExternalPath,
+    char                    *InternalPath,
+    UINT8                   Type,
+    UINT32                  Value,
+    UINT16                  Flags)
+{
+    ACPI_EXTERNAL_LIST      *NewExternal;
+    ACPI_EXTERNAL_LIST      *NextExternal;
+    ACPI_EXTERNAL_LIST      *PrevExternal = NULL;
+
+
+    ACPI_FUNCTION_TRACE (DmCreateNewExternal);
+
+
+    /* Check all existing externals to ensure no duplicates */
+
+    NextExternal = AcpiGbl_ExternalList;
+    while (NextExternal)
+    {
+        /* Check for duplicates */
+
+        if (!strcmp (ExternalPath, NextExternal->Path))
+        {
+            /*
+             * If this external came from an External() opcode, we are
+             * finished with this one. (No need to check any further).
+             */
+            if (NextExternal->Flags & ACPI_EXT_ORIGIN_FROM_OPCODE)
+            {
+                return_ACPI_STATUS (AE_ALREADY_EXISTS);
+            }
+
+            /* Allow upgrade of type from ANY */
+
+            else if ((NextExternal->Type == ACPI_TYPE_ANY) &&
+                (Type != ACPI_TYPE_ANY))
+            {
+                NextExternal->Type = Type;
+            }
+
+            /* Update the argument count as necessary */
+
+            if (Value < NextExternal->Value)
+            {
+                NextExternal->Value = Value;
+            }
+
+            /* Update flags. */
+
+            NextExternal->Flags |= Flags;
+            NextExternal->Flags &= ~ACPI_EXT_INTERNAL_PATH_ALLOCATED;
+
+            return_ACPI_STATUS (AE_ALREADY_EXISTS);
+        }
+
+        NextExternal = NextExternal->Next;
+    }
+
+    /* Allocate and init a new External() descriptor */
+
+    NewExternal = ACPI_ALLOCATE_ZEROED (sizeof (ACPI_EXTERNAL_LIST));
+    if (!NewExternal)
+    {
+        return_ACPI_STATUS (AE_NO_MEMORY);
+    }
+
+    ACPI_DEBUG_PRINT ((ACPI_DB_NAMES,
+        "Adding external reference node (%s) type [%s]\n",
+        ExternalPath, AcpiUtGetTypeName (Type)));
+
+    NewExternal->Flags = Flags;
+    NewExternal->Value = Value;
+    NewExternal->Path = ExternalPath;
+    NewExternal->Type = Type;
+    NewExternal->Length = (UINT16) strlen (ExternalPath);
+    NewExternal->InternalPath = InternalPath;
+
+    /* Link the new descriptor into the global list, alphabetically ordered */
+
+    NextExternal = AcpiGbl_ExternalList;
+    while (NextExternal)
+    {
+        if (AcpiUtStricmp (NewExternal->Path, NextExternal->Path) < 0)
+        {
+            if (PrevExternal)
+            {
+                PrevExternal->Next = NewExternal;
+            }
+            else
+            {
+                AcpiGbl_ExternalList = NewExternal;
+            }
+
+            NewExternal->Next = NextExternal;
+            return_ACPI_STATUS (AE_OK);
+        }
+
+        PrevExternal = NextExternal;
+        NextExternal = NextExternal->Next;
+    }
+
+    if (PrevExternal)
+    {
+        PrevExternal->Next = NewExternal;
+    }
+    else
+    {
+        AcpiGbl_ExternalList = NewExternal;
+    }
+
+    return_ACPI_STATUS (AE_OK);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiDmAddExternalsToNamespace
+ *
+ * PARAMETERS:  None
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Add all externals to the namespace. Allows externals to be
+ *              "resolved".
+ *
+ ******************************************************************************/
+
+void
+AcpiDmAddExternalsToNamespace (
+    void)
+{
+    ACPI_STATUS             Status;
+    ACPI_NAMESPACE_NODE     *Node;
+    ACPI_OPERAND_OBJECT     *ObjDesc;
+    ACPI_EXTERNAL_LIST      *External = AcpiGbl_ExternalList;
+
+
+    while (External)
+    {
+        /* Add the external name (object) into the namespace */
+
+        Status = AcpiNsLookup (NULL, External->InternalPath, External->Type,
+            ACPI_IMODE_LOAD_PASS1,
+            ACPI_NS_ERROR_IF_FOUND | ACPI_NS_EXTERNAL | ACPI_NS_DONT_OPEN_SCOPE,
+            NULL, &Node);
+
+        if (ACPI_FAILURE (Status))
+        {
+            ACPI_EXCEPTION ((AE_INFO, Status,
+                "while adding external to namespace [%s]",
+                External->Path));
+        }
+
+        else switch (External->Type)
+        {
+        case ACPI_TYPE_METHOD:
+
+            /* For methods, we need to save the argument count */
+
+            ObjDesc = AcpiUtCreateInternalObject (ACPI_TYPE_METHOD);
+            ObjDesc->Method.ParamCount = (UINT8) External->Value;
+            Node->Object = ObjDesc;
+            break;
+
+        case ACPI_TYPE_REGION:
+
+            /* Regions require a region sub-object */
+
+            ObjDesc = AcpiUtCreateInternalObject (ACPI_TYPE_REGION);
+            ObjDesc->Region.Node = Node;
+            Node->Object = ObjDesc;
+            break;
+
+        default:
+
+            break;
+        }
+
+        External = External->Next;
+    }
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiDmGetExternalMethodCount
+ *
+ * PARAMETERS:  None
+ *
+ * RETURN:      The number of control method externals in the external list
+ *
+ * DESCRIPTION: Return the number of method externals that have been generated.
+ *              If any control method externals have been found, we must
+ *              re-parse the entire definition block with the new information
+ *              (number of arguments for the methods.) This is limitation of
+ *              AML, we don't know the number of arguments from the control
+ *              method invocation itself.
+ *
+ ******************************************************************************/
+
+UINT32
+AcpiDmGetExternalMethodCount (
+    void)
+{
+    ACPI_EXTERNAL_LIST      *External = AcpiGbl_ExternalList;
+    UINT32                  Count = 0;
+
+
+    while (External)
+    {
+        if (External->Type == ACPI_TYPE_METHOD)
+        {
+            Count++;
+        }
+
+        External = External->Next;
+    }
+
+    return (Count);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiDmClearExternalList
+ *
+ * PARAMETERS:  None
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Free the entire External info list
+ *
+ ******************************************************************************/
+
+void
+AcpiDmClearExternalList (
+    void)
+{
+    ACPI_EXTERNAL_LIST      *NextExternal;
+
+
+    while (AcpiGbl_ExternalList)
+    {
+        NextExternal = AcpiGbl_ExternalList->Next;
+        ACPI_FREE (AcpiGbl_ExternalList->Path);
+        ACPI_FREE (AcpiGbl_ExternalList);
+        AcpiGbl_ExternalList = NextExternal;
+    }
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiDmEmitExternals
+ *
+ * PARAMETERS:  None
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Emit an External() ASL statement for each of the externals in
+ *              the global external info list.
+ *
+ ******************************************************************************/
+
+void
+AcpiDmEmitExternals (
+    void)
+{
+    ACPI_EXTERNAL_LIST      *NextExternal;
+
+
+    if (!AcpiGbl_ExternalList)
+    {
+        return;
+    }
+
+    /*
+     * Determine the number of control methods in the external list, and
+     * also how many of those externals were resolved via the namespace.
+     */
+    NextExternal = AcpiGbl_ExternalList;
+    while (NextExternal)
+    {
+        if (NextExternal->Type == ACPI_TYPE_METHOD)
+        {
+            AcpiGbl_NumExternalMethods++;
+            if (NextExternal->Flags & ACPI_EXT_RESOLVED_REFERENCE)
+            {
+                AcpiGbl_ResolvedExternalMethods++;
+            }
+        }
+
+        NextExternal = NextExternal->Next;
+    }
+
+    /* Check if any control methods were unresolved */
+
+    AcpiDmUnresolvedWarning (1);
+
+    if (Gbl_ExternalRefFilename)
+    {
+        AcpiOsPrintf (
+            "    /*\n     * External declarations were imported from\n"
+            "     * a reference file -- %s\n     */\n\n",
+            Gbl_ExternalRefFilename);
+    }
+
+    /*
+     * Walk and emit the list of externals found during the AML parsing
+     */
+    while (AcpiGbl_ExternalList)
+    {
+        if (!(AcpiGbl_ExternalList->Flags & ACPI_EXT_EXTERNAL_EMITTED))
+        {
+            AcpiOsPrintf ("    External (%s%s)",
+                AcpiGbl_ExternalList->Path,
+                AcpiDmGetObjectTypeName (AcpiGbl_ExternalList->Type));
+
+            /* Check for "unresolved" method reference */
+
+            if ((AcpiGbl_ExternalList->Type == ACPI_TYPE_METHOD) &&
+                (!(AcpiGbl_ExternalList->Flags & ACPI_EXT_RESOLVED_REFERENCE)))
+            {
+                AcpiOsPrintf ("    // Warning: Unknown method, "
+                    "guessing %u arguments",
+                    AcpiGbl_ExternalList->Value);
+            }
+
+            /* Check for external from a external references file */
+
+            else if (AcpiGbl_ExternalList->Flags & ACPI_EXT_ORIGIN_FROM_FILE)
+            {
+                if (AcpiGbl_ExternalList->Type == ACPI_TYPE_METHOD)
+                {
+                    AcpiOsPrintf ("    // %u Arguments",
+                        AcpiGbl_ExternalList->Value);
+                }
+
+                AcpiOsPrintf ("    // From external reference file");
+            }
+
+            /* This is the normal external case */
+
+            else
+            {
+                /* For methods, add a comment with the number of arguments */
+
+                if (AcpiGbl_ExternalList->Type == ACPI_TYPE_METHOD)
+                {
+                    AcpiOsPrintf ("    // %u Arguments",
+                        AcpiGbl_ExternalList->Value);
+                }
+            }
+
+            AcpiOsPrintf ("\n");
+        }
+
+        /* Free this external info block and move on to next external */
+
+        NextExternal = AcpiGbl_ExternalList->Next;
+        if (AcpiGbl_ExternalList->Flags & ACPI_EXT_INTERNAL_PATH_ALLOCATED)
+        {
+            ACPI_FREE (AcpiGbl_ExternalList->InternalPath);
+        }
+
+        ACPI_FREE (AcpiGbl_ExternalList->Path);
+        ACPI_FREE (AcpiGbl_ExternalList);
+        AcpiGbl_ExternalList = NextExternal;
+    }
+
+    AcpiOsPrintf ("\n");
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiDmUnresolvedWarning
+ *
+ * PARAMETERS:  Type                - Where to output the warning.
+ *                                    0 means write to stderr
+ *                                    1 means write to AcpiOsPrintf
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Issue warning message if there are unresolved external control
+ *              methods within the disassembly.
+ *
+ ******************************************************************************/
+
+#if 0
+Summary of the external control method problem:
+
+When the -e option is used with disassembly, the various SSDTs are simply
+loaded into a global namespace for the disassembler to use in order to
+resolve control method references (invocations).
+
+The disassembler tracks any such references, and will emit an External()
+statement for these types of methods, with the proper number of arguments .
+
+Without the SSDTs, the AML does not contain enough information to properly
+disassemble the control method invocation -- because the disassembler does
+not know how many arguments to parse.
+
+An example: Assume we have two control methods. ABCD has one argument, and
+EFGH has zero arguments. Further, we have two additional control methods
+that invoke ABCD and EFGH, named T1 and T2:
+
+    Method (ABCD, 1)
+    {
+    }
+    Method (EFGH, 0)
+    {
+    }
+    Method (T1)
+    {
+        ABCD (Add (2, 7, Local0))
+    }
+    Method (T2)
+    {
+        EFGH ()
+        Add (2, 7, Local0)
+    }
+
+Here is the AML code that is generated for T1 and T2:
+
+     185:      Method (T1)
+
+0000034C:  14 10 54 31 5F 5F 00 ...    "..T1__."
+
+     186:      {
+     187:          ABCD (Add (2, 7, Local0))
+
+00000353:  41 42 43 44 ............    "ABCD"
+00000357:  72 0A 02 0A 07 60 ......    "r....`"
+
+     188:      }
+
+     190:      Method (T2)
+
+0000035D:  14 10 54 32 5F 5F 00 ...    "..T2__."
+
+     191:      {
+     192:          EFGH ()
+
+00000364:  45 46 47 48 ............    "EFGH"
+
+     193:          Add (2, 7, Local0)
+
+00000368:  72 0A 02 0A 07 60 ......    "r....`"
+     194:      }
+
+Note that the AML code for T1 and T2 is essentially identical. When
+disassembling this code, the methods ABCD and EFGH must be known to the
+disassembler, otherwise it does not know how to handle the method invocations.
+
+In other words, if ABCD and EFGH are actually external control methods
+appearing in an SSDT, the disassembler does not know what to do unless
+the owning SSDT has been loaded via the -e option.
+#endif
+
+static char             ExternalWarningPart1[600];
+static char             ExternalWarningPart2[400];
+static char             ExternalWarningPart3[400];
+static char             ExternalWarningPart4[200];
+
+void
+AcpiDmUnresolvedWarning (
+    UINT8                   Type)
+{
+    char                    *Format;
+    char                    Pad[] = "     *";
+    char                    NoPad[] = "";
+
+
+    if (!AcpiGbl_NumExternalMethods)
+    {
+        return;
+    }
+
+    if (AcpiGbl_NumExternalMethods == AcpiGbl_ResolvedExternalMethods)
+    {
+        return;
+    }
+
+    Format = Type ? Pad : NoPad;
+
+    sprintf (ExternalWarningPart1,
+        "%s iASL Warning: There %s %u external control method%s found during\n"
+        "%s disassembly, but only %u %s resolved (%u unresolved). Additional\n"
+        "%s ACPI tables may be required to properly disassemble the code. This\n"
+        "%s resulting disassembler output file may not compile because the\n"
+        "%s disassembler did not know how many arguments to assign to the\n"
+        "%s unresolved methods. Note: SSDTs can be dynamically loaded at\n"
+        "%s runtime and may or may not be available via the host OS.\n",
+        Format, (AcpiGbl_NumExternalMethods != 1 ? "were" : "was"),
+        AcpiGbl_NumExternalMethods, (AcpiGbl_NumExternalMethods != 1 ? "s" : ""),
+        Format, AcpiGbl_ResolvedExternalMethods,
+        (AcpiGbl_ResolvedExternalMethods != 1 ? "were" : "was"),
+        (AcpiGbl_NumExternalMethods - AcpiGbl_ResolvedExternalMethods),
+        Format, Format, Format, Format, Format);
+
+    sprintf (ExternalWarningPart2,
+        "%s To specify the tables needed to resolve external control method\n"
+        "%s references, the -e option can be used to specify the filenames.\n"
+        "%s Example iASL invocations:\n"
+        "%s     iasl -e ssdt1.aml ssdt2.aml ssdt3.aml -d dsdt.aml\n"
+        "%s     iasl -e dsdt.aml ssdt2.aml -d ssdt1.aml\n"
+        "%s     iasl -e ssdt*.aml -d dsdt.aml\n",
+        Format, Format, Format, Format, Format, Format);
+
+    sprintf (ExternalWarningPart3,
+        "%s In addition, the -fe option can be used to specify a file containing\n"
+        "%s control method external declarations with the associated method\n"
+        "%s argument counts. Each line of the file must be of the form:\n"
+        "%s     External (<method pathname>, MethodObj, <argument count>)\n"
+        "%s Invocation:\n"
+        "%s     iasl -fe refs.txt -d dsdt.aml\n",
+        Format, Format, Format, Format, Format, Format);
+
+    sprintf (ExternalWarningPart4,
+        "%s The following methods were unresolved and many not compile properly\n"
+        "%s because the disassembler had to guess at the number of arguments\n"
+        "%s required for each:\n",
+        Format, Format, Format);
+
+    if (Type)
+    {
+        if (!AcpiGbl_ExternalFileList)
+        {
+            /* The -e option was not specified */
+
+           AcpiOsPrintf ("    /*\n%s     *\n%s     *\n%s     *\n%s     */\n",
+               ExternalWarningPart1, ExternalWarningPart2, ExternalWarningPart3,
+               ExternalWarningPart4);
+        }
+        else
+        {
+            /* The -e option was specified, but there are still some unresolved externals */
+
+            AcpiOsPrintf ("    /*\n%s     *\n%s     *\n%s     */\n",
+               ExternalWarningPart1, ExternalWarningPart3, ExternalWarningPart4);
+        }
+    }
+    else
+    {
+        if (!AcpiGbl_ExternalFileList)
+        {
+            /* The -e option was not specified */
+
+            fprintf (stderr, "\n%s\n%s\n%s\n",
+               ExternalWarningPart1, ExternalWarningPart2, ExternalWarningPart3);
+        }
+        else
+        {
+            /* The -e option was specified, but there are still some unresolved externals */
+
+            fprintf (stderr, "\n%s\n%s\n",
+               ExternalWarningPart1, ExternalWarningPart3);
+        }
+    }
+}
diff --git a/usr/src/cmd/acpi/common/dmrestag.c b/usr/src/cmd/acpi/common/dmrestag.c
new file mode 100644
index 0000000000..bfeb2833aa
--- /dev/null
+++ b/usr/src/cmd/acpi/common/dmrestag.c
@@ -0,0 +1,1052 @@
+/******************************************************************************
+ *
+ * Module Name: dmrestag - Add tags to resource descriptors (Application-level)
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2016, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include "acpi.h"
+#include "accommon.h"
+#include "acparser.h"
+#include "acdisasm.h"
+#include "acnamesp.h"
+#include "amlcode.h"
+
+/* This module used for application-level code only */
+
+#define _COMPONENT          ACPI_CA_DISASSEMBLER
+        ACPI_MODULE_NAME    ("dmrestag")
+
+/* Local prototypes */
+
+static void
+AcpiDmUpdateResourceName (
+    ACPI_NAMESPACE_NODE     *ResourceNode);
+
+static char *
+AcpiDmSearchTagList (
+    UINT32                  BitIndex,
+    const ACPI_RESOURCE_TAG *TagList);
+
+static char *
+AcpiDmGetResourceTag (
+    UINT32                  BitIndex,
+    AML_RESOURCE            *Resource,
+    UINT8                   ResourceIndex);
+
+static char *
+AcpiGetTagPathname (
+    ACPI_PARSE_OBJECT       *Op,
+    ACPI_NAMESPACE_NODE     *BufferNode,
+    ACPI_NAMESPACE_NODE     *ResourceNode,
+    UINT32                  BitIndex);
+
+static ACPI_NAMESPACE_NODE *
+AcpiDmGetResourceNode (
+    ACPI_NAMESPACE_NODE     *BufferNode,
+    UINT32                  BitIndex);
+
+static ACPI_STATUS
+AcpiDmAddResourceToNamespace (
+    UINT8                   *Aml,
+    UINT32                  Length,
+    UINT32                  Offset,
+    UINT8                   ResourceIndex,
+    void                    **Context);
+
+static void
+AcpiDmAddResourcesToNamespace (
+    ACPI_NAMESPACE_NODE     *BufferNode,
+    ACPI_PARSE_OBJECT       *Op);
+
+
+/******************************************************************************
+ *
+ * Resource Tag tables
+ *
+ * These are the predefined tags that refer to elements of a resource
+ * descriptor. Each name and offset is defined in the ACPI specification.
+ *
+ * Each table entry contains the bit offset of the field and the associated
+ * name.
+ *
+ ******************************************************************************/
+
+static const ACPI_RESOURCE_TAG      AcpiDmIrqTags[] =
+{
+    {( 1 * 8),      ACPI_RESTAG_INTERRUPT},
+    {( 3 * 8) + 0,  ACPI_RESTAG_INTERRUPTTYPE},
+    {( 3 * 8) + 3,  ACPI_RESTAG_INTERRUPTLEVEL},
+    {( 3 * 8) + 4,  ACPI_RESTAG_INTERRUPTSHARE},
+    {0,             NULL}
+};
+
+static const ACPI_RESOURCE_TAG      AcpiDmDmaTags[] =
+{
+    {( 1 * 8),      ACPI_RESTAG_DMA},
+    {( 2 * 8) + 0,  ACPI_RESTAG_XFERTYPE},
+    {( 2 * 8) + 2,  ACPI_RESTAG_BUSMASTER},
+    {( 2 * 8) + 5,  ACPI_RESTAG_DMATYPE},
+    {0,             NULL}
+};
+
+static const ACPI_RESOURCE_TAG      AcpiDmIoTags[] =
+{
+    {( 1 * 8) + 0,  ACPI_RESTAG_DECODE},
+    {( 2 * 8),      ACPI_RESTAG_MINADDR},
+    {( 4 * 8),      ACPI_RESTAG_MAXADDR},
+    {( 6 * 8),      ACPI_RESTAG_ALIGNMENT},
+    {( 7 * 8),      ACPI_RESTAG_LENGTH},
+    {0,             NULL}
+};
+
+static const ACPI_RESOURCE_TAG      AcpiDmFixedIoTags[] =
+{
+    {( 1 * 8),      ACPI_RESTAG_BASEADDRESS},
+    {( 3 * 8),      ACPI_RESTAG_LENGTH},
+    {0,             NULL}
+};
+
+static const ACPI_RESOURCE_TAG      AcpiDmFixedDmaTags[] =
+{
+    {( 1 * 8),      ACPI_RESTAG_DMA},
+    {( 3 * 8),      ACPI_RESTAG_DMATYPE},
+    {( 5 * 8),      ACPI_RESTAG_XFERTYPE},
+    {0,             NULL}
+};
+
+static const ACPI_RESOURCE_TAG      AcpiDmMemory24Tags[] =
+{
+    {( 3 * 8) + 0,  ACPI_RESTAG_READWRITETYPE},
+    {( 4 * 8),      ACPI_RESTAG_MINADDR},
+    {( 6 * 8),      ACPI_RESTAG_MAXADDR},
+    {( 8 * 8),      ACPI_RESTAG_ALIGNMENT},
+    {(10 * 8),      ACPI_RESTAG_LENGTH},
+    {0,             NULL}
+};
+
+static const ACPI_RESOURCE_TAG      AcpiDmRegisterTags[] =
+{
+    {( 3 * 8),      ACPI_RESTAG_ADDRESSSPACE},
+    {( 4 * 8),      ACPI_RESTAG_REGISTERBITWIDTH},
+    {( 5 * 8),      ACPI_RESTAG_REGISTERBITOFFSET},
+    {( 6 * 8),      ACPI_RESTAG_ACCESSSIZE},
+    {( 7 * 8),      ACPI_RESTAG_ADDRESS},
+    {0,             NULL}
+};
+
+static const ACPI_RESOURCE_TAG      AcpiDmMemory32Tags[] =
+{
+    {( 3 * 8) + 0,  ACPI_RESTAG_READWRITETYPE},
+    {( 4 * 8),      ACPI_RESTAG_MINADDR},
+    {( 8 * 8),      ACPI_RESTAG_MAXADDR},
+    {(12 * 8),      ACPI_RESTAG_ALIGNMENT},
+    {(16 * 8),      ACPI_RESTAG_LENGTH},
+    {0,             NULL}
+};
+
+static const ACPI_RESOURCE_TAG      AcpiDmFixedMemory32Tags[] =
+{
+    {( 3 * 8) + 0,  ACPI_RESTAG_READWRITETYPE},
+    {( 4 * 8),      ACPI_RESTAG_BASEADDRESS},
+    {( 8 * 8),      ACPI_RESTAG_LENGTH},
+    {0,             NULL}
+};
+
+static const ACPI_RESOURCE_TAG      AcpiDmInterruptTags[] =
+{
+    {( 3 * 8) + 1,  ACPI_RESTAG_INTERRUPTTYPE},
+    {( 3 * 8) + 2,  ACPI_RESTAG_INTERRUPTLEVEL},
+    {( 3 * 8) + 3,  ACPI_RESTAG_INTERRUPTSHARE},
+    {( 5 * 8),      ACPI_RESTAG_INTERRUPT},
+    {0,             NULL}
+};
+
+static const ACPI_RESOURCE_TAG      AcpiDmAddress16Tags[] =
+{
+    {( 4 * 8) + 1,  ACPI_RESTAG_DECODE},
+    {( 4 * 8) + 2,  ACPI_RESTAG_MINTYPE},
+    {( 4 * 8) + 3,  ACPI_RESTAG_MAXTYPE},
+    {( 6 * 8),      ACPI_RESTAG_GRANULARITY},
+    {( 8 * 8),      ACPI_RESTAG_MINADDR},
+    {(10 * 8),      ACPI_RESTAG_MAXADDR},
+    {(12 * 8),      ACPI_RESTAG_TRANSLATION},
+    {(14 * 8),      ACPI_RESTAG_LENGTH},
+    {0,             NULL}
+};
+
+static const ACPI_RESOURCE_TAG      AcpiDmAddress32Tags[] =
+{
+    {( 4 * 8) + 1,  ACPI_RESTAG_DECODE},
+    {( 4 * 8) + 2,  ACPI_RESTAG_MINTYPE},
+    {( 4 * 8) + 3,  ACPI_RESTAG_MAXTYPE},
+    {( 6 * 8),      ACPI_RESTAG_GRANULARITY},
+    {(10 * 8),      ACPI_RESTAG_MINADDR},
+    {(14 * 8),      ACPI_RESTAG_MAXADDR},
+    {(18 * 8),      ACPI_RESTAG_TRANSLATION},
+    {(22 * 8),      ACPI_RESTAG_LENGTH},
+    {0,             NULL}
+};
+
+static const ACPI_RESOURCE_TAG      AcpiDmAddress64Tags[] =
+{
+    {( 4 * 8) + 1,  ACPI_RESTAG_DECODE},
+    {( 4 * 8) + 2,  ACPI_RESTAG_MINTYPE},
+    {( 4 * 8) + 3,  ACPI_RESTAG_MAXTYPE},
+    {( 6 * 8),      ACPI_RESTAG_GRANULARITY},
+    {(14 * 8),      ACPI_RESTAG_MINADDR},
+    {(22 * 8),      ACPI_RESTAG_MAXADDR},
+    {(30 * 8),      ACPI_RESTAG_TRANSLATION},
+    {(38 * 8),      ACPI_RESTAG_LENGTH},
+    {0,             NULL}
+};
+
+static const ACPI_RESOURCE_TAG      AcpiDmExtendedAddressTags[] =
+{
+    {( 4 * 8) + 1,  ACPI_RESTAG_DECODE},
+    {( 4 * 8) + 2,  ACPI_RESTAG_MINTYPE},
+    {( 4 * 8) + 3,  ACPI_RESTAG_MAXTYPE},
+    {( 8 * 8),      ACPI_RESTAG_GRANULARITY},
+    {(16 * 8),      ACPI_RESTAG_MINADDR},
+    {(24 * 8),      ACPI_RESTAG_MAXADDR},
+    {(32 * 8),      ACPI_RESTAG_TRANSLATION},
+    {(40 * 8),      ACPI_RESTAG_LENGTH},
+    {(48 * 8),      ACPI_RESTAG_TYPESPECIFICATTRIBUTES},
+    {0,             NULL}
+};
+
+/* Subtype tables for GPIO descriptors */
+
+static const ACPI_RESOURCE_TAG      AcpiDmGpioIntTags[] =
+{
+    {( 7 * 8) + 0,  ACPI_RESTAG_MODE},
+    {( 7 * 8) + 1,  ACPI_RESTAG_POLARITY},
+    {( 7 * 8) + 3,  ACPI_RESTAG_INTERRUPTSHARE},
+    {( 9 * 8),      ACPI_RESTAG_PINCONFIG},
+    {(10 * 8),      ACPI_RESTAG_DRIVESTRENGTH},
+    {(12 * 8),      ACPI_RESTAG_DEBOUNCETIME},
+    {0,             NULL}
+};
+
+static const ACPI_RESOURCE_TAG      AcpiDmGpioIoTags[] =
+{
+    {( 7 * 8) + 0,  ACPI_RESTAG_IORESTRICTION},
+    {( 7 * 8) + 3,  ACPI_RESTAG_INTERRUPTSHARE},
+    {( 9 * 8),      ACPI_RESTAG_PINCONFIG},
+    {(10 * 8),      ACPI_RESTAG_DRIVESTRENGTH},
+    {(12 * 8),      ACPI_RESTAG_DEBOUNCETIME},
+    {0,             NULL}
+};
+
+/* Subtype tables for SerialBus descriptors */
+
+static const ACPI_RESOURCE_TAG      AcpiDmI2cSerialBusTags[] =
+{
+    {( 6 * 8) + 0,  ACPI_RESTAG_SLAVEMODE},
+    {( 6 * 8) + 2,  ACPI_RESTAG_INTERRUPTSHARE},    /* V2 - ACPI 6.0 */
+    {( 7 * 8) + 0,  ACPI_RESTAG_MODE},
+    {(12 * 8),      ACPI_RESTAG_SPEED},
+    {(16 * 8),      ACPI_RESTAG_ADDRESS},
+    {0,             NULL}
+};
+
+static const ACPI_RESOURCE_TAG      AcpiDmSpiSerialBusTags[] =
+{
+    {( 6 * 8) + 0,  ACPI_RESTAG_SLAVEMODE},
+    {( 6 * 8) + 2,  ACPI_RESTAG_INTERRUPTSHARE},    /* V2 - ACPI 6.0 */
+    {( 7 * 8) + 0,  ACPI_RESTAG_MODE},
+    {( 7 * 8) + 1,  ACPI_RESTAG_DEVICEPOLARITY},
+    {(12 * 8),      ACPI_RESTAG_SPEED},
+    {(16 * 8),      ACPI_RESTAG_LENGTH},
+    {(17 * 8),      ACPI_RESTAG_PHASE},
+    {(18 * 8),      ACPI_RESTAG_POLARITY},
+    {(19 * 8),      ACPI_RESTAG_ADDRESS},
+    {0,             NULL}
+};
+
+static const ACPI_RESOURCE_TAG      AcpiDmUartSerialBusTags[] =
+{
+    {( 6 * 8) + 0,  ACPI_RESTAG_SLAVEMODE},         /* Note: not part of original macro */
+    {( 6 * 8) + 2,  ACPI_RESTAG_INTERRUPTSHARE},    /* V2 - ACPI 6.0 */
+    {( 7 * 8) + 0,  ACPI_RESTAG_FLOWCONTROL},
+    {( 7 * 8) + 2,  ACPI_RESTAG_STOPBITS},
+    {( 7 * 8) + 4,  ACPI_RESTAG_LENGTH},
+    {( 7 * 8) + 7,  ACPI_RESTAG_ENDIANNESS},
+    {(12 * 8),      ACPI_RESTAG_SPEED},
+    {(16 * 8),      ACPI_RESTAG_LENGTH_RX},
+    {(18 * 8),      ACPI_RESTAG_LENGTH_TX},
+    {(20 * 8),      ACPI_RESTAG_PARITY},
+    {(21 * 8),      ACPI_RESTAG_LINE},
+    {0,             NULL}
+};
+
+/* Subtype tables for Address descriptor type-specific flags */
+
+static const ACPI_RESOURCE_TAG      AcpiDmMemoryFlagTags[] =
+{
+    {( 5 * 8) + 0,  ACPI_RESTAG_READWRITETYPE},
+    {( 5 * 8) + 1,  ACPI_RESTAG_MEMTYPE},
+    {( 5 * 8) + 3,  ACPI_RESTAG_MEMATTRIBUTES},
+    {( 5 * 8) + 5,  ACPI_RESTAG_TYPE},
+    {0,             NULL}
+};
+
+static const ACPI_RESOURCE_TAG      AcpiDmIoFlagTags[] =
+{
+    {( 5 * 8) + 0,  ACPI_RESTAG_RANGETYPE},
+    {( 5 * 8) + 4,  ACPI_RESTAG_TYPE},
+    {( 5 * 8) + 5,  ACPI_RESTAG_TRANSTYPE},
+    {0,             NULL}
+};
+
+
+/*
+ * Dispatch table used to obtain the correct tag table for a descriptor.
+ *
+ * A NULL in this table means one of three things:
+ * 1) The descriptor ID is reserved and invalid
+ * 2) The descriptor has no tags associated with it
+ * 3) The descriptor has subtypes and a separate table will be used.
+ */
+static const ACPI_RESOURCE_TAG      *AcpiGbl_ResourceTags[] =
+{
+    /* Small descriptors */
+
+    NULL,                           /* 0x00, Reserved */
+    NULL,                           /* 0x01, Reserved */
+    NULL,                           /* 0x02, Reserved */
+    NULL,                           /* 0x03, Reserved */
+    AcpiDmIrqTags,                  /* 0x04, ACPI_RESOURCE_NAME_IRQ_FORMAT */
+    AcpiDmDmaTags,                  /* 0x05, ACPI_RESOURCE_NAME_DMA_FORMAT */
+    NULL,                           /* 0x06, ACPI_RESOURCE_NAME_START_DEPENDENT */
+    NULL,                           /* 0x07, ACPI_RESOURCE_NAME_END_DEPENDENT */
+    AcpiDmIoTags,                   /* 0x08, ACPI_RESOURCE_NAME_IO_PORT */
+    AcpiDmFixedIoTags,              /* 0x09, ACPI_RESOURCE_NAME_FIXED_IO_PORT */
+    AcpiDmFixedDmaTags,             /* 0x0A, ACPI_RESOURCE_NAME_FIXED_DMA */
+    NULL,                           /* 0x0B, Reserved */
+    NULL,                           /* 0x0C, Reserved */
+    NULL,                           /* 0x0D, Reserved */
+    NULL,                           /* 0x0E, ACPI_RESOURCE_NAME_SMALL_VENDOR */
+    NULL,                           /* 0x0F, ACPI_RESOURCE_NAME_END_TAG (not used) */
+
+    /* Large descriptors */
+
+    NULL,                           /* 0x00, Reserved */
+    AcpiDmMemory24Tags,             /* 0x01, ACPI_RESOURCE_NAME_MEMORY_24 */
+    AcpiDmRegisterTags,             /* 0x02, ACPI_RESOURCE_NAME_GENERIC_REGISTER */
+    NULL,                           /* 0x03, Reserved */
+    NULL,                           /* 0x04, ACPI_RESOURCE_NAME_LARGE_VENDOR */
+    AcpiDmMemory32Tags,             /* 0x05, ACPI_RESOURCE_NAME_MEMORY_32 */
+    AcpiDmFixedMemory32Tags,        /* 0x06, ACPI_RESOURCE_NAME_FIXED_MEMORY_32 */
+    AcpiDmAddress32Tags,            /* 0x07, ACPI_RESOURCE_NAME_DWORD_ADDRESS_SPACE */
+    AcpiDmAddress16Tags,            /* 0x08, ACPI_RESOURCE_NAME_WORD_ADDRESS_SPACE */
+    AcpiDmInterruptTags,            /* 0x09, ACPI_RESOURCE_NAME_EXTENDED_XRUPT */
+    AcpiDmAddress64Tags,            /* 0x0A, ACPI_RESOURCE_NAME_QWORD_ADDRESS_SPACE */
+    AcpiDmExtendedAddressTags,      /* 0x0B, ACPI_RESOURCE_NAME_EXTENDED_ADDRESS_SPACE */
+    NULL,                           /* 0x0C, ACPI_RESOURCE_NAME_GPIO - Use Subtype table below */
+    NULL,                           /* 0x0D, Reserved */
+    NULL                            /* 0x0E, ACPI_RESOURCE_NAME_SERIAL_BUS - Use Subtype table below */
+};
+
+/* GPIO Subtypes */
+
+static const ACPI_RESOURCE_TAG      *AcpiGbl_GpioResourceTags[] =
+{
+    AcpiDmGpioIntTags,              /* 0x00 Interrupt Connection */
+    AcpiDmGpioIoTags                /* 0x01 I/O Connection */
+};
+
+/* Serial Bus Subtypes */
+
+static const ACPI_RESOURCE_TAG      *AcpiGbl_SerialResourceTags[] =
+{
+    NULL,                           /* 0x00 Reserved */
+    AcpiDmI2cSerialBusTags,         /* 0x01 I2C SerialBus */
+    AcpiDmSpiSerialBusTags,         /* 0x02 SPI SerialBus */
+    AcpiDmUartSerialBusTags         /* 0x03 UART SerialBus */
+};
+
+/*
+ * Globals used to generate unique resource descriptor names. We use names that
+ * start with underscore and a prefix letter that is not used by other ACPI
+ * reserved names. To this, we append hex 0x00 through 0xFF. These 5 prefixes
+ * allow for 5*256 = 1280 unique names, probably sufficient for any single ASL
+ * file. If this becomes too small, we can use alpha+numerals for a total
+ * of 5*36*36 = 6480.
+ */
+#define ACPI_NUM_RES_PREFIX     5
+
+static UINT32                   AcpiGbl_NextResourceId = 0;
+static UINT8                    AcpiGbl_NextPrefix = 0;
+static char                     AcpiGbl_Prefix[ACPI_NUM_RES_PREFIX] =
+                                    {'Y','Z','J','K','X'};
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiDmCheckResourceReference
+ *
+ * PARAMETERS:  Op                  - Parse Op for the AML opcode
+ *              WalkState           - Current walk state (with valid scope)
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Convert a reference to a resource descriptor to a symbolic
+ *              reference if possible
+ *
+ * NOTE:        Bit index is used to transparently handle both resource bit
+ *              fields and byte fields.
+ *
+ ******************************************************************************/
+
+void
+AcpiDmCheckResourceReference (
+    ACPI_PARSE_OBJECT       *Op,
+    ACPI_WALK_STATE         *WalkState)
+{
+    ACPI_STATUS             Status;
+    ACPI_PARSE_OBJECT       *BufferNameOp;
+    ACPI_PARSE_OBJECT       *IndexOp;
+    ACPI_NAMESPACE_NODE     *BufferNode;
+    ACPI_NAMESPACE_NODE     *ResourceNode;
+    const ACPI_OPCODE_INFO  *OpInfo;
+    UINT32                  BitIndex;
+
+
+    /* We are only interested in the CreateXxxxField opcodes */
+
+    OpInfo = AcpiPsGetOpcodeInfo (Op->Common.AmlOpcode);
+    if (OpInfo->Type != AML_TYPE_CREATE_FIELD)
+    {
+        return;
+    }
+
+    /* Get the buffer term operand */
+
+    BufferNameOp = AcpiPsGetDepthNext (NULL, Op);
+
+    /* Must be a named buffer, not an arg or local or method call */
+
+    if (BufferNameOp->Common.AmlOpcode != AML_INT_NAMEPATH_OP)
+    {
+        return;
+    }
+
+    /* Get the Index term, must be an integer constant to convert */
+
+    IndexOp = BufferNameOp->Common.Next;
+
+    /* Major cheat: The Node field is also used for the Tag ptr. Clear it now */
+
+    IndexOp->Common.Node = NULL;
+
+    OpInfo = AcpiPsGetOpcodeInfo (IndexOp->Common.AmlOpcode);
+    if (OpInfo->ObjectType != ACPI_TYPE_INTEGER)
+    {
+        return;
+    }
+
+    /* Get the bit offset of the descriptor within the buffer */
+
+    if ((Op->Common.AmlOpcode == AML_CREATE_BIT_FIELD_OP) ||
+        (Op->Common.AmlOpcode == AML_CREATE_FIELD_OP))
+    {
+        /* Index operand is a bit offset */
+
+        BitIndex = (UINT32) IndexOp->Common.Value.Integer;
+    }
+    else
+    {
+        /* Index operand is a byte offset, convert to bits */
+
+        BitIndex = (UINT32) ACPI_MUL_8 (IndexOp->Common.Value.Integer);
+    }
+
+    /* Lookup the buffer in the namespace */
+
+    Status = AcpiNsLookup (WalkState->ScopeInfo,
+        BufferNameOp->Common.Value.String, ACPI_TYPE_BUFFER,
+        ACPI_IMODE_EXECUTE, ACPI_NS_SEARCH_PARENT, WalkState,
+        &BufferNode);
+    if (ACPI_FAILURE (Status))
+    {
+        return;
+    }
+
+    /* Validate object type, we must have a buffer */
+
+    if (BufferNode->Type != ACPI_TYPE_BUFFER)
+    {
+        return;
+    }
+
+    /* Find the resource descriptor node corresponding to the index */
+
+    ResourceNode = AcpiDmGetResourceNode (BufferNode, BitIndex);
+    if (!ResourceNode)
+    {
+        return;
+    }
+
+    /* Translate the Index to a resource tag pathname */
+
+    AcpiGetTagPathname (IndexOp, BufferNode, ResourceNode, BitIndex);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiDmGetResourceNode
+ *
+ * PARAMETERS:  BufferNode          - Node for the parent buffer
+ *              BitIndex            - Index into the resource descriptor
+ *
+ * RETURN:      Namespace node for the resource descriptor. NULL if not found
+ *
+ * DESCRIPTION: Find a resource descriptor that corresponds to the bit index
+ *
+ ******************************************************************************/
+
+static ACPI_NAMESPACE_NODE *
+AcpiDmGetResourceNode (
+    ACPI_NAMESPACE_NODE     *BufferNode,
+    UINT32                  BitIndex)
+{
+    ACPI_NAMESPACE_NODE     *Node;
+    UINT32                  ByteIndex = ACPI_DIV_8 (BitIndex);
+
+
+    /*
+     * Child list contains an entry for each resource descriptor. Find
+     * the descriptor that corresponds to the Index.
+     *
+     * If there are no children, this is not a resource template
+     */
+    Node = BufferNode->Child;
+    while (Node)
+    {
+        /*
+         * Check if the Index falls within this resource.
+         *
+         * Value contains the resource offset, Object contains the resource
+         * length (both in bytes)
+         */
+        if ((ByteIndex >= Node->Value) &&
+            (ByteIndex < (Node->Value + Node->Length)))
+        {
+            return (Node);
+        }
+
+        Node = Node->Peer;
+    }
+
+    return (NULL);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiGetTagPathname
+ *
+ * PARAMETERS:  BufferNode          - Node for the parent buffer
+ *              ResourceNode        - Node for a resource descriptor
+ *              BitIndex            - Index into the resource descriptor
+ *
+ * RETURN:      Full pathname for a resource tag. NULL if no match.
+ *              Path is returned in AML (packed) format.
+ *
+ * DESCRIPTION: Convert a BitIndex into a symbolic resource tag (full pathname)
+ *
+ ******************************************************************************/
+
+static char *
+AcpiGetTagPathname (
+    ACPI_PARSE_OBJECT       *IndexOp,
+    ACPI_NAMESPACE_NODE     *BufferNode,
+    ACPI_NAMESPACE_NODE     *ResourceNode,
+    UINT32                  BitIndex)
+{
+    ACPI_STATUS             Status;
+    UINT32                  ResourceBitIndex;
+    UINT8                   ResourceTableIndex;
+    ACPI_SIZE               RequiredSize;
+    char                    *Pathname;
+    AML_RESOURCE            *Aml;
+    ACPI_PARSE_OBJECT       *Op;
+    char                    *InternalPath;
+    char                    *Tag;
+
+
+    /* Get the Op that contains the actual buffer data */
+
+    Op = BufferNode->Op->Common.Value.Arg;
+    Op = Op->Common.Next;
+    if (!Op)
+    {
+        return (NULL);
+    }
+
+    /* Get the individual resource descriptor and validate it */
+
+    Aml = ACPI_CAST_PTR (
+        AML_RESOURCE, &Op->Named.Data[ResourceNode->Value]);
+
+    Status = AcpiUtValidateResource (NULL, Aml, &ResourceTableIndex);
+    if (ACPI_FAILURE (Status))
+    {
+        return (NULL);
+    }
+
+    /* Get offset into this descriptor (from offset into entire buffer) */
+
+    ResourceBitIndex = BitIndex - ACPI_MUL_8 (ResourceNode->Value);
+
+    /* Get the tag associated with this resource descriptor and offset */
+
+    Tag = AcpiDmGetResourceTag (ResourceBitIndex, Aml, ResourceTableIndex);
+    if (!Tag)
+    {
+        return (NULL);
+    }
+
+    /*
+     * Now that we know that we have a reference that can be converted to a
+     * symbol, change the name of the resource to a unique name.
+     */
+    AcpiDmUpdateResourceName (ResourceNode);
+
+    /* Get the full pathname to the parent buffer */
+
+    RequiredSize = AcpiNsBuildNormalizedPath (BufferNode, NULL, 0, FALSE);
+    if (!RequiredSize)
+    {
+        return (NULL);
+    }
+
+    Pathname = ACPI_ALLOCATE_ZEROED (RequiredSize + ACPI_PATH_SEGMENT_LENGTH);
+    if (!Pathname)
+    {
+        return (NULL);
+    }
+
+    (void) AcpiNsBuildNormalizedPath (BufferNode, Pathname,
+        RequiredSize, FALSE);
+
+    /*
+     * Create the full path to the resource and tag by: remove the buffer name,
+     * append the resource descriptor name, append a dot, append the tag name.
+     *
+     * TBD: Always using the full path is a bit brute force, the path can be
+     * often be optimized with carats (if the original buffer namepath is a
+     * single nameseg). This doesn't really matter, because these paths do not
+     * end up in the final compiled AML, it's just an appearance issue for the
+     * disassembled code.
+     */
+    Pathname[strlen (Pathname) - ACPI_NAME_SIZE] = 0;
+    strncat (Pathname, ResourceNode->Name.Ascii, ACPI_NAME_SIZE);
+    strcat (Pathname, ".");
+    strncat (Pathname, Tag, ACPI_NAME_SIZE);
+
+    /* Internalize the namepath to AML format */
+
+    AcpiNsInternalizeName (Pathname, &InternalPath);
+    ACPI_FREE (Pathname);
+
+    /* Update the Op with the symbol */
+
+    AcpiPsInitOp (IndexOp, AML_INT_NAMEPATH_OP);
+    IndexOp->Common.Value.String = InternalPath;
+
+    /* We will need the tag later. Cheat by putting it in the Node field */
+
+    IndexOp->Common.Node = ACPI_CAST_PTR (ACPI_NAMESPACE_NODE, Tag);
+    return (InternalPath);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiDmUpdateResourceName
+ *
+ * PARAMETERS:  ResourceNode        - Node for a resource descriptor
+ *
+ * RETURN:      Stores new name in the ResourceNode
+ *
+ * DESCRIPTION: Create a new, unique name for a resource descriptor. Used by
+ *              both the disassembly of the descriptor itself and any symbolic
+ *              references to the descriptor. Ignored if a unique name has
+ *              already been assigned to the resource.
+ *
+ * NOTE: Single threaded, suitable for applications only!
+ *
+ ******************************************************************************/
+
+static void
+AcpiDmUpdateResourceName (
+    ACPI_NAMESPACE_NODE     *ResourceNode)
+{
+    char                    Name[ACPI_NAME_SIZE];
+
+
+    /* Ignore if a unique name has already been assigned */
+
+    if (ResourceNode->Name.Integer != ACPI_DEFAULT_RESNAME)
+    {
+        return;
+    }
+
+    /* Generate a new ACPI name for the descriptor */
+
+    Name[0] = '_';
+    Name[1] = AcpiGbl_Prefix[AcpiGbl_NextPrefix];
+    Name[2] = AcpiUtHexToAsciiChar ((UINT64) AcpiGbl_NextResourceId, 4);
+    Name[3] = AcpiUtHexToAsciiChar ((UINT64) AcpiGbl_NextResourceId, 0);
+
+    /* Update globals for next name */
+
+    AcpiGbl_NextResourceId++;
+    if (AcpiGbl_NextResourceId >= 256)
+    {
+        AcpiGbl_NextResourceId = 0;
+        AcpiGbl_NextPrefix++;
+
+        if (AcpiGbl_NextPrefix > ACPI_NUM_RES_PREFIX)
+        {
+            AcpiGbl_NextPrefix = 0;
+        }
+    }
+
+    /* Change the resource descriptor name */
+
+    ResourceNode->Name.Integer = *ACPI_CAST_PTR (UINT32, &Name[0]);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiDmGetResourceTag
+ *
+ * PARAMETERS:  BitIndex            - Index into the resource descriptor
+ *              Resource            - Pointer to the raw resource data
+ *              ResourceIndex       - Index correspoinding to the resource type
+ *
+ * RETURN:      Pointer to the resource tag (ACPI_NAME). NULL if no match.
+ *
+ * DESCRIPTION: Convert a BitIndex into a symbolic resource tag.
+ *
+ * Note: ResourceIndex should be previously validated and guaranteed to ve
+ *       valid.
+ *
+ ******************************************************************************/
+
+static char *
+AcpiDmGetResourceTag (
+    UINT32                  BitIndex,
+    AML_RESOURCE            *Resource,
+    UINT8                   ResourceIndex)
+{
+    const ACPI_RESOURCE_TAG *TagList;
+    char                    *Tag = NULL;
+
+
+    /* Get the tag list for this resource descriptor type */
+
+    TagList = AcpiGbl_ResourceTags[ResourceIndex];
+
+    /*
+     * Handle descriptors that have multiple subtypes
+     */
+    switch (Resource->DescriptorType)
+    {
+    case ACPI_RESOURCE_NAME_ADDRESS16:
+    case ACPI_RESOURCE_NAME_ADDRESS32:
+    case ACPI_RESOURCE_NAME_ADDRESS64:
+    case ACPI_RESOURCE_NAME_EXTENDED_ADDRESS64:
+        /*
+         * Subtype differentiation is the flags.
+         * Kindof brute force, but just blindly search for an index match
+         */
+        if (Resource->Address.ResourceType == ACPI_ADDRESS_TYPE_MEMORY_RANGE)
+        {
+            Tag = AcpiDmSearchTagList (BitIndex, AcpiDmMemoryFlagTags);
+        }
+        else if (Resource->Address.ResourceType == ACPI_ADDRESS_TYPE_IO_RANGE)
+        {
+            Tag = AcpiDmSearchTagList (BitIndex, AcpiDmIoFlagTags);
+        }
+
+        /* If we found a match, all done. Else, drop to normal search below */
+
+        if (Tag)
+        {
+            return (Tag);
+        }
+        break;
+
+    case ACPI_RESOURCE_NAME_GPIO:
+
+        /* GPIO connection has 2 subtypes: Interrupt and I/O */
+
+        if (Resource->Gpio.ConnectionType > AML_RESOURCE_MAX_GPIOTYPE)
+        {
+            return (NULL);
+        }
+
+        TagList = AcpiGbl_GpioResourceTags[Resource->Gpio.ConnectionType];
+        break;
+
+    case ACPI_RESOURCE_NAME_SERIAL_BUS:
+
+        /* SerialBus has 3 subtypes: I2C, SPI, and UART */
+
+        if ((Resource->CommonSerialBus.Type == 0) ||
+            (Resource->CommonSerialBus.Type > AML_RESOURCE_MAX_SERIALBUSTYPE))
+        {
+            return (NULL);
+        }
+
+        TagList = AcpiGbl_SerialResourceTags[Resource->CommonSerialBus.Type];
+        break;
+
+    default:
+
+        break;
+    }
+
+    /* Search for a match against the BitIndex */
+
+    if (TagList)
+    {
+        Tag = AcpiDmSearchTagList (BitIndex, TagList);
+    }
+
+    return (Tag);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiDmSearchTagList
+ *
+ * PARAMETERS:  BitIndex            - Index into the resource descriptor
+ *              TagList             - List to search
+ *
+ * RETURN:      Pointer to a tag (ACPI_NAME). NULL if no match found.
+ *
+ * DESCRIPTION: Search a tag list for a match to the input BitIndex. Matches
+ *              a fixed offset to a symbolic resource tag name.
+ *
+ ******************************************************************************/
+
+static char *
+AcpiDmSearchTagList (
+    UINT32                  BitIndex,
+    const ACPI_RESOURCE_TAG *TagList)
+{
+
+    /*
+     * Walk the null-terminated tag list to find a matching bit offset.
+     * We are looking for an exact match.
+     */
+    for ( ; TagList->Tag; TagList++)
+    {
+        if (BitIndex == TagList->BitIndex)
+        {
+            return (TagList->Tag);
+        }
+    }
+
+    /* A matching offset was not found */
+
+    return (NULL);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiDmFindResources
+ *
+ * PARAMETERS:  Root                - Root of the parse tree
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Add all ResourceTemplate declarations to the namespace. Each
+ *              resource descriptor in each template is given a node -- used
+ *              for later conversion of resource references to symbolic refs.
+ *
+ ******************************************************************************/
+
+void
+AcpiDmFindResources (
+    ACPI_PARSE_OBJECT       *Root)
+{
+    ACPI_PARSE_OBJECT       *Op = Root;
+    ACPI_PARSE_OBJECT       *Parent;
+
+
+    /* Walk the entire parse tree */
+
+    while (Op)
+    {
+        /* We are interested in Buffer() declarations */
+
+        if (Op->Common.AmlOpcode == AML_BUFFER_OP)
+        {
+            /* And only declarations of the form Name (XXXX, Buffer()... ) */
+
+            Parent = Op->Common.Parent;
+            if (Parent->Common.AmlOpcode == AML_NAME_OP)
+            {
+                /*
+                 * If the buffer is a resource template, add the individual
+                 * resource descriptors to the namespace, as children of the
+                 * buffer node.
+                 */
+                if (ACPI_SUCCESS (AcpiDmIsResourceTemplate (NULL, Op)))
+                {
+                    Op->Common.DisasmOpcode = ACPI_DASM_RESOURCE;
+                    AcpiDmAddResourcesToNamespace (Parent->Common.Node, Op);
+                }
+            }
+        }
+
+        Op = AcpiPsGetDepthNext (Root, Op);
+    }
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiDmAddResourcesToNamespace
+ *
+ * PARAMETERS:  BufferNode          - Node for the parent buffer
+ *              Op                  - Parse op for the buffer
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Add an entire resource template to the namespace. Each
+ *              resource descriptor is added as a namespace node.
+ *
+ ******************************************************************************/
+
+static void
+AcpiDmAddResourcesToNamespace (
+    ACPI_NAMESPACE_NODE     *BufferNode,
+    ACPI_PARSE_OBJECT       *Op)
+{
+    ACPI_PARSE_OBJECT       *NextOp;
+
+
+    /* Get to the ByteData list */
+
+    NextOp = Op->Common.Value.Arg;
+    NextOp = NextOp->Common.Next;
+    if (!NextOp)
+    {
+        return;
+    }
+
+    /* Set Node and Op to point to each other */
+
+    BufferNode->Op = Op;
+    Op->Common.Node = BufferNode;
+
+    /*
+     * Insert each resource into the namespace
+     * NextOp contains the Aml pointer and the Aml length
+     */
+    AcpiUtWalkAmlResources (NULL, (UINT8 *) NextOp->Named.Data,
+        (ACPI_SIZE) NextOp->Common.Value.Integer,
+        AcpiDmAddResourceToNamespace, (void **) BufferNode);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiDmAddResourceToNamespace
+ *
+ * PARAMETERS:  ACPI_WALK_AML_CALLBACK
+ *              BufferNode              - Node for the parent buffer
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Add one resource descriptor to the namespace as a child of the
+ *              parent buffer. The same name is used for each descriptor. This
+ *              is changed later to a unique name if the resource is actually
+ *              referenced by an AML operator.
+ *
+ ******************************************************************************/
+
+static ACPI_STATUS
+AcpiDmAddResourceToNamespace (
+    UINT8                   *Aml,
+    UINT32                  Length,
+    UINT32                  Offset,
+    UINT8                   ResourceIndex,
+    void                    **Context)
+{
+    ACPI_STATUS             Status;
+    ACPI_GENERIC_STATE      ScopeInfo;
+    ACPI_NAMESPACE_NODE     *Node;
+
+
+    /* TBD: Don't need to add descriptors that have no tags defined? */
+
+    /* Add the resource to the namespace, as child of the buffer */
+
+    ScopeInfo.Scope.Node = ACPI_CAST_PTR (ACPI_NAMESPACE_NODE, Context);
+    Status = AcpiNsLookup (&ScopeInfo, "_TMP", ACPI_TYPE_LOCAL_RESOURCE,
+        ACPI_IMODE_LOAD_PASS2,
+        ACPI_NS_NO_UPSEARCH | ACPI_NS_DONT_OPEN_SCOPE | ACPI_NS_PREFIX_IS_SCOPE,
+        NULL, &Node);
+    if (ACPI_FAILURE (Status))
+    {
+        return (AE_OK);
+    }
+
+    /* Set the name to the default, changed later if resource is referenced */
+
+    Node->Name.Integer = ACPI_DEFAULT_RESNAME;
+
+    /* Save the offset of the descriptor (within the original buffer) */
+
+    Node->Value = Offset;
+    Node->Length = Length;
+    return (AE_OK);
+}
diff --git a/usr/src/cmd/acpi/common/dmtable.c b/usr/src/cmd/acpi/common/dmtable.c
new file mode 100644
index 0000000000..5ad46e9ff4
--- /dev/null
+++ b/usr/src/cmd/acpi/common/dmtable.c
@@ -0,0 +1,1484 @@
+/******************************************************************************
+ *
+ * Module Name: dmtable - Support for ACPI tables that contain no AML code
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2016, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include "acpi.h"
+#include "accommon.h"
+#include "acdisasm.h"
+#include "actables.h"
+#include "aslcompiler.h"
+#include "dtcompiler.h"
+
+/* This module used for application-level code only */
+
+#define _COMPONENT          ACPI_CA_DISASSEMBLER
+        ACPI_MODULE_NAME    ("dmtable")
+
+const AH_TABLE *
+AcpiAhGetTableInfo (
+    char                    *Signature);
+
+
+/* Common format strings for commented values */
+
+#define UINT8_FORMAT        "%2.2X [%s]\n"
+#define UINT16_FORMAT       "%4.4X [%s]\n"
+#define UINT32_FORMAT       "%8.8X [%s]\n"
+#define STRING_FORMAT       "[%s]\n"
+
+/* These tables map a subtable type to a description string */
+
+static const char           *AcpiDmAsfSubnames[] =
+{
+    "ASF Information",
+    "ASF Alerts",
+    "ASF Remote Control",
+    "ASF RMCP Boot Options",
+    "ASF Address",
+    "Unknown Subtable Type"         /* Reserved */
+};
+
+static const char           *AcpiDmDmarSubnames[] =
+{
+    "Hardware Unit Definition",
+    "Reserved Memory Region",
+    "Root Port ATS Capability",
+    "Remapping Hardware Static Affinity",
+    "ACPI Namespace Device Declaration",
+    "Unknown Subtable Type"         /* Reserved */
+};
+
+static const char           *AcpiDmDmarScope[] =
+{
+    "Reserved value",
+    "PCI Endpoint Device",
+    "PCI Bridge Device",
+    "IOAPIC Device",
+    "Message-capable HPET Device",
+    "Namespace Device",
+    "Unknown Scope Type"            /* Reserved */
+};
+
+static const char           *AcpiDmEinjActions[] =
+{
+    "Begin Operation",
+    "Get Trigger Table",
+    "Set Error Type",
+    "Get Error Type",
+    "End Operation",
+    "Execute Operation",
+    "Check Busy Status",
+    "Get Command Status",
+    "Set Error Type With Address",
+    "Get Execute Timings",
+    "Unknown Action"
+};
+
+static const char           *AcpiDmEinjInstructions[] =
+{
+    "Read Register",
+    "Read Register Value",
+    "Write Register",
+    "Write Register Value",
+    "Noop",
+    "Flush Cacheline",
+    "Unknown Instruction"
+};
+
+static const char           *AcpiDmErstActions[] =
+{
+    "Begin Write Operation",
+    "Begin Read Operation",
+    "Begin Clear Operation",
+    "End Operation",
+    "Set Record Offset",
+    "Execute Operation",
+    "Check Busy Status",
+    "Get Command Status",
+    "Get Record Identifier",
+    "Set Record Identifier",
+    "Get Record Count",
+    "Begin Dummy Write",
+    "Unused/Unknown Action",
+    "Get Error Address Range",
+    "Get Error Address Length",
+    "Get Error Attributes",
+    "Execute Timings",
+    "Unknown Action"
+};
+
+static const char           *AcpiDmErstInstructions[] =
+{
+    "Read Register",
+    "Read Register Value",
+    "Write Register",
+    "Write Register Value",
+    "Noop",
+    "Load Var1",
+    "Load Var2",
+    "Store Var1",
+    "Add",
+    "Subtract",
+    "Add Value",
+    "Subtract Value",
+    "Stall",
+    "Stall While True",
+    "Skip Next If True",
+    "GoTo",
+    "Set Source Address",
+    "Set Destination Address",
+    "Move Data",
+    "Unknown Instruction"
+};
+
+static const char           *AcpiDmGtdtSubnames[] =
+{
+    "Generic Timer Block",
+    "Generic Watchdog Timer",
+    "Unknown Subtable Type"         /* Reserved */
+};
+
+static const char           *AcpiDmHestSubnames[] =
+{
+    "IA-32 Machine Check Exception",
+    "IA-32 Corrected Machine Check",
+    "IA-32 Non-Maskable Interrupt",
+    "Unknown SubTable Type",        /* 3 - Reserved */
+    "Unknown SubTable Type",        /* 4 - Reserved */
+    "Unknown SubTable Type",        /* 5 - Reserved */
+    "PCI Express Root Port AER",
+    "PCI Express AER (AER Endpoint)",
+    "PCI Express/PCI-X Bridge AER",
+    "Generic Hardware Error Source",
+    "Generic Hardware Error Source V2",
+    "Unknown Subtable Type"         /* Reserved */
+};
+
+static const char           *AcpiDmHestNotifySubnames[] =
+{
+    "Polled",
+    "External Interrupt",
+    "Local Interrupt",
+    "SCI",
+    "NMI",
+    "CMCI",                         /* ACPI 5.0 */
+    "MCE",                          /* ACPI 5.0 */
+    "GPIO",                         /* ACPI 6.0 */
+    "SEA",                          /* ACPI 6.1 */
+    "SEI",                          /* ACPI 6.1 */
+    "GSIV",                         /* ACPI 6.1 */
+    "Unknown Notify Type"           /* Reserved */
+};
+
+static const char           *AcpiDmMadtSubnames[] =
+{
+    "Processor Local APIC",             /* ACPI_MADT_TYPE_LOCAL_APIC */
+    "I/O APIC",                         /* ACPI_MADT_TYPE_IO_APIC */
+    "Interrupt Source Override",        /* ACPI_MADT_TYPE_INTERRUPT_OVERRIDE */
+    "NMI Source",                       /* ACPI_MADT_TYPE_NMI_SOURCE */
+    "Local APIC NMI",                   /* ACPI_MADT_TYPE_LOCAL_APIC_NMI */
+    "Local APIC Address Override",      /* ACPI_MADT_TYPE_LOCAL_APIC_OVERRIDE */
+    "I/O SAPIC",                        /* ACPI_MADT_TYPE_IO_SAPIC */
+    "Local SAPIC",                      /* ACPI_MADT_TYPE_LOCAL_SAPIC */
+    "Platform Interrupt Sources",       /* ACPI_MADT_TYPE_INTERRUPT_SOURCE */
+    "Processor Local x2APIC",           /* ACPI_MADT_TYPE_LOCAL_X2APIC */
+    "Local x2APIC NMI",                 /* ACPI_MADT_TYPE_LOCAL_X2APIC_NMI */
+    "Generic Interrupt Controller",     /* ACPI_MADT_GENERIC_INTERRUPT */
+    "Generic Interrupt Distributor",    /* ACPI_MADT_GENERIC_DISTRIBUTOR */
+    "Generic MSI Frame",                /* ACPI_MADT_GENERIC_MSI_FRAME */
+    "Generic Interrupt Redistributor",  /* ACPI_MADT_GENERIC_REDISTRIBUTOR */
+    "Generic Interrupt Translator",     /* ACPI_MADT_GENERIC_TRANSLATOR */
+    "Unknown Subtable Type"             /* Reserved */
+};
+
+static const char           *AcpiDmNfitSubnames[] =
+{
+    "System Physical Address Range",    /* ACPI_NFIT_TYPE_SYSTEM_ADDRESS */
+    "Memory Range Map",                 /* ACPI_NFIT_TYPE_MEMORY_MAP */
+    "Interleave Info",                  /* ACPI_NFIT_TYPE_INTERLEAVE */
+    "SMBIOS Information",               /* ACPI_NFIT_TYPE_SMBIOS */
+    "NVDIMM Control Region",            /* ACPI_NFIT_TYPE_CONTROL_REGION */
+    "NVDIMM Block Data Window Region",  /* ACPI_NFIT_TYPE_DATA_REGION */
+    "Flush Hint Address",               /* ACPI_NFIT_TYPE_FLUSH_ADDRESS */
+    "Unknown Subtable Type"             /* Reserved */
+};
+
+static const char           *AcpiDmPcctSubnames[] =
+{
+    "Generic Communications Subspace",  /* ACPI_PCCT_TYPE_GENERIC_SUBSPACE */
+    "HW-Reduced Comm Subspace",         /* ACPI_PCCT_TYPE_HW_REDUCED_SUBSPACE */
+    "HW-Reduced Comm Subspace Type2",   /* ACPI_PCCT_TYPE_HW_REDUCED_SUBSPACE_TYPE2 */
+    "Unknown Subtable Type"             /* Reserved */
+};
+
+static const char           *AcpiDmPmttSubnames[] =
+{
+    "Socket",                       /* ACPI_PMTT_TYPE_SOCKET */
+    "Memory Controller",            /* ACPI_PMTT_TYPE_CONTROLLER */
+    "Physical Component (DIMM)",    /* ACPI_PMTT_TYPE_DIMM  */
+    "Unknown Subtable Type"         /* Reserved */
+};
+
+static const char           *AcpiDmSratSubnames[] =
+{
+    "Processor Local APIC/SAPIC Affinity",
+    "Memory Affinity",
+    "Processor Local x2APIC Affinity",
+    "GICC Affinity",
+    "Unknown Subtable Type"         /* Reserved */
+};
+
+static const char           *AcpiDmIvrsSubnames[] =
+{
+    "Hardware Definition Block",
+    "Memory Definition Block",
+    "Unknown Subtable Type"         /* Reserved */
+};
+
+static const char           *AcpiDmLpitSubnames[] =
+{
+    "Native C-state Idle Structure",
+    "Unknown Subtable Type"         /* Reserved */
+};
+
+#define ACPI_FADT_PM_RESERVED       9
+
+static const char           *AcpiDmFadtProfiles[] =
+{
+    "Unspecified",
+    "Desktop",
+    "Mobile",
+    "Workstation",
+    "Enterprise Server",
+    "SOHO Server",
+    "Appliance PC",
+    "Performance Server",
+    "Tablet",
+    "Unknown Profile Type"
+};
+
+#define ACPI_GAS_WIDTH_RESERVED     5
+
+static const char           *AcpiDmGasAccessWidth[] =
+{
+    "Undefined/Legacy",
+    "Byte Access:8",
+    "Word Access:16",
+    "DWord Access:32",
+    "QWord Access:64",
+    "Unknown Width Encoding"
+};
+
+
+/*******************************************************************************
+ *
+ * ACPI Table Data, indexed by signature.
+ *
+ * Each entry contains: Signature, Table Info, Handler, DtHandler,
+ *  Template, Description
+ *
+ * Simple tables have only a TableInfo structure, complex tables have a
+ * handler. This table must be NULL terminated. RSDP and FACS are
+ * special-cased elsewhere.
+ *
+ * Note: Any tables added here should be duplicated within AcpiSupportedTables
+ * in the file common/ahtable.c
+ *
+ ******************************************************************************/
+
+const ACPI_DMTABLE_DATA     AcpiDmTableData[] =
+{
+    {ACPI_SIG_ASF,  NULL,                   AcpiDmDumpAsf,  DtCompileAsf,   TemplateAsf},
+    {ACPI_SIG_BERT, AcpiDmTableInfoBert,    NULL,           NULL,           TemplateBert},
+    {ACPI_SIG_BGRT, AcpiDmTableInfoBgrt,    NULL,           NULL,           TemplateBgrt},
+    {ACPI_SIG_BOOT, AcpiDmTableInfoBoot,    NULL,           NULL,           TemplateBoot},
+    {ACPI_SIG_CPEP, NULL,                   AcpiDmDumpCpep, DtCompileCpep,  TemplateCpep},
+    {ACPI_SIG_CSRT, NULL,                   AcpiDmDumpCsrt, DtCompileCsrt,  TemplateCsrt},
+    {ACPI_SIG_DBG2, AcpiDmTableInfoDbg2,    AcpiDmDumpDbg2, DtCompileDbg2,  TemplateDbg2},
+    {ACPI_SIG_DBGP, AcpiDmTableInfoDbgp,    NULL,           NULL,           TemplateDbgp},
+    {ACPI_SIG_DMAR, NULL,                   AcpiDmDumpDmar, DtCompileDmar,  TemplateDmar},
+    {ACPI_SIG_DRTM, NULL,                   AcpiDmDumpDrtm, DtCompileDrtm,  TemplateDrtm},
+    {ACPI_SIG_ECDT, AcpiDmTableInfoEcdt,    NULL,           NULL,           TemplateEcdt},
+    {ACPI_SIG_EINJ, NULL,                   AcpiDmDumpEinj, DtCompileEinj,  TemplateEinj},
+    {ACPI_SIG_ERST, NULL,                   AcpiDmDumpErst, DtCompileErst,  TemplateErst},
+    {ACPI_SIG_FADT, NULL,                   AcpiDmDumpFadt, DtCompileFadt,  TemplateFadt},
+    {ACPI_SIG_FPDT, NULL,                   AcpiDmDumpFpdt, DtCompileFpdt,  TemplateFpdt},
+    {ACPI_SIG_GTDT, NULL,                   AcpiDmDumpGtdt, DtCompileGtdt,  TemplateGtdt},
+    {ACPI_SIG_HEST, NULL,                   AcpiDmDumpHest, DtCompileHest,  TemplateHest},
+    {ACPI_SIG_HPET, AcpiDmTableInfoHpet,    NULL,           NULL,           TemplateHpet},
+    {ACPI_SIG_IORT, NULL,                   AcpiDmDumpIort, DtCompileIort,  TemplateIort},
+    {ACPI_SIG_IVRS, NULL,                   AcpiDmDumpIvrs, DtCompileIvrs,  TemplateIvrs},
+    {ACPI_SIG_LPIT, NULL,                   AcpiDmDumpLpit, DtCompileLpit,  TemplateLpit},
+    {ACPI_SIG_MADT, NULL,                   AcpiDmDumpMadt, DtCompileMadt,  TemplateMadt},
+    {ACPI_SIG_MCFG, NULL,                   AcpiDmDumpMcfg, DtCompileMcfg,  TemplateMcfg},
+    {ACPI_SIG_MCHI, AcpiDmTableInfoMchi,    NULL,           NULL,           TemplateMchi},
+    {ACPI_SIG_MPST, AcpiDmTableInfoMpst,    AcpiDmDumpMpst, DtCompileMpst,  TemplateMpst},
+    {ACPI_SIG_MSCT, NULL,                   AcpiDmDumpMsct, DtCompileMsct,  TemplateMsct},
+    {ACPI_SIG_MSDM, NULL,                   AcpiDmDumpSlic, DtCompileSlic,  TemplateMsdm},
+    {ACPI_SIG_MTMR, NULL,                   AcpiDmDumpMtmr, DtCompileMtmr,  TemplateMtmr},
+    {ACPI_SIG_NFIT, AcpiDmTableInfoNfit,    AcpiDmDumpNfit, DtCompileNfit,  TemplateNfit},
+    {ACPI_SIG_PCCT, AcpiDmTableInfoPcct,    AcpiDmDumpPcct, DtCompilePcct,  TemplatePcct},
+    {ACPI_SIG_PMTT, NULL,                   AcpiDmDumpPmtt, DtCompilePmtt,  TemplatePmtt},
+    {ACPI_SIG_RSDT, NULL,                   AcpiDmDumpRsdt, DtCompileRsdt,  TemplateRsdt},
+    {ACPI_SIG_S3PT, NULL,                   NULL,           NULL,           TemplateS3pt},
+    {ACPI_SIG_SBST, AcpiDmTableInfoSbst,    NULL,           NULL,           TemplateSbst},
+    {ACPI_SIG_SLIC, NULL,                   AcpiDmDumpSlic, DtCompileSlic,  TemplateSlic},
+    {ACPI_SIG_SLIT, NULL,                   AcpiDmDumpSlit, DtCompileSlit,  TemplateSlit},
+    {ACPI_SIG_SPCR, AcpiDmTableInfoSpcr,    NULL,           NULL,           TemplateSpcr},
+    {ACPI_SIG_SPMI, AcpiDmTableInfoSpmi,    NULL,           NULL,           TemplateSpmi},
+    {ACPI_SIG_SRAT, NULL,                   AcpiDmDumpSrat, DtCompileSrat,  TemplateSrat},
+    {ACPI_SIG_STAO, NULL,                   AcpiDmDumpStao, DtCompileStao,  TemplateStao},
+    {ACPI_SIG_TCPA, NULL,                   AcpiDmDumpTcpa, DtCompileTcpa,  TemplateTcpa},
+    {ACPI_SIG_TPM2, AcpiDmTableInfoTpm2,    NULL,           NULL,           TemplateTpm2},
+    {ACPI_SIG_UEFI, AcpiDmTableInfoUefi,    NULL,           DtCompileUefi,  TemplateUefi},
+    {ACPI_SIG_VRTC, AcpiDmTableInfoVrtc,    AcpiDmDumpVrtc, DtCompileVrtc,  TemplateVrtc},
+    {ACPI_SIG_WAET, AcpiDmTableInfoWaet,    NULL,           NULL,           TemplateWaet},
+    {ACPI_SIG_WDAT, NULL,                   AcpiDmDumpWdat, DtCompileWdat,  TemplateWdat},
+    {ACPI_SIG_WDDT, AcpiDmTableInfoWddt,    NULL,           NULL,           TemplateWddt},
+    {ACPI_SIG_WDRT, AcpiDmTableInfoWdrt,    NULL,           NULL,           TemplateWdrt},
+    {ACPI_SIG_WPBT, NULL,                   AcpiDmDumpWpbt, DtCompileWpbt,  TemplateWpbt},
+    {ACPI_SIG_XENV, AcpiDmTableInfoXenv,    NULL,           NULL,           TemplateXenv},
+    {ACPI_SIG_XSDT, NULL,                   AcpiDmDumpXsdt, DtCompileXsdt,  TemplateXsdt},
+    {NULL,          NULL,                   NULL,           NULL,           NULL}
+};
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiDmGenerateChecksum
+ *
+ * PARAMETERS:  Table               - Pointer to table to be checksummed
+ *              Length              - Length of the table
+ *              OriginalChecksum    - Value of the checksum field
+ *
+ * RETURN:      8 bit checksum of buffer
+ *
+ * DESCRIPTION: Computes an 8 bit checksum of the table.
+ *
+ ******************************************************************************/
+
+UINT8
+AcpiDmGenerateChecksum (
+    void                    *Table,
+    UINT32                  Length,
+    UINT8                   OriginalChecksum)
+{
+    UINT8                   Checksum;
+
+
+    /* Sum the entire table as-is */
+
+    Checksum = AcpiTbChecksum ((UINT8 *) Table, Length);
+
+    /* Subtract off the existing checksum value in the table */
+
+    Checksum = (UINT8) (Checksum - OriginalChecksum);
+
+    /* Compute the final checksum */
+
+    Checksum = (UINT8) (0 - Checksum);
+    return (Checksum);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiDmGetTableData
+ *
+ * PARAMETERS:  Signature           - ACPI signature (4 chars) to match
+ *
+ * RETURN:      Pointer to a valid ACPI_DMTABLE_DATA. Null if no match found.
+ *
+ * DESCRIPTION: Find a match in the global table of supported ACPI tables
+ *
+ ******************************************************************************/
+
+const ACPI_DMTABLE_DATA *
+AcpiDmGetTableData (
+    char                    *Signature)
+{
+    const ACPI_DMTABLE_DATA *Info;
+
+
+    for (Info = AcpiDmTableData; Info->Signature; Info++)
+    {
+        if (ACPI_COMPARE_NAME (Signature, Info->Signature))
+        {
+            return (Info);
+        }
+    }
+
+    return (NULL);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiDmDumpDataTable
+ *
+ * PARAMETERS:  Table               - An ACPI table
+ *
+ * RETURN:      None.
+ *
+ * DESCRIPTION: Format the contents of an ACPI data table (any table other
+ *              than an SSDT or DSDT that does not contain executable AML code)
+ *
+ ******************************************************************************/
+
+void
+AcpiDmDumpDataTable (
+    ACPI_TABLE_HEADER       *Table)
+{
+    ACPI_STATUS             Status;
+    const ACPI_DMTABLE_DATA *TableData;
+    UINT32                  Length;
+
+
+    /* Ignore tables that contain AML */
+
+    if (AcpiUtIsAmlTable (Table))
+    {
+        if (Gbl_VerboseTemplates)
+        {
+            /* Dump the raw table data */
+
+            Length = Table->Length;
+
+            AcpiOsPrintf ("\n/*\n%s: Length %d (0x%X)\n\n",
+                ACPI_RAW_TABLE_DATA_HEADER, Length, Length);
+            AcpiUtDumpBuffer (ACPI_CAST_PTR (UINT8, Table),
+                Length, DB_BYTE_DISPLAY, 0);
+            AcpiOsPrintf (" */\n");
+        }
+        return;
+    }
+
+    /*
+     * Handle tables that don't use the common ACPI table header structure.
+     * Currently, these are the FACS, RSDP, and S3PT.
+     */
+    if (ACPI_COMPARE_NAME (Table->Signature, ACPI_SIG_FACS))
+    {
+        Length = Table->Length;
+        Status = AcpiDmDumpTable (Length, 0, Table, 0, AcpiDmTableInfoFacs);
+        if (ACPI_FAILURE (Status))
+        {
+            return;
+        }
+    }
+    else if (ACPI_VALIDATE_RSDP_SIG (Table->Signature))
+    {
+        Length = AcpiDmDumpRsdp (Table);
+    }
+    else if (ACPI_COMPARE_NAME (Table->Signature, ACPI_SIG_S3PT))
+    {
+        Length = AcpiDmDumpS3pt (Table);
+    }
+    else
+    {
+        /*
+         * All other tables must use the common ACPI table header, dump it now
+         */
+        Length = Table->Length;
+        Status = AcpiDmDumpTable (Length, 0, Table, 0, AcpiDmTableInfoHeader);
+        if (ACPI_FAILURE (Status))
+        {
+            return;
+        }
+        AcpiOsPrintf ("\n");
+
+        /* Match signature and dispatch appropriately */
+
+        TableData = AcpiDmGetTableData (Table->Signature);
+        if (!TableData)
+        {
+            if (!strncmp (Table->Signature, "OEM", 3))
+            {
+                AcpiOsPrintf ("\n**** OEM-defined ACPI table [%4.4s], unknown contents\n\n",
+                    Table->Signature);
+            }
+            else
+            {
+                AcpiOsPrintf ("\n**** Unknown ACPI table signature [%4.4s]\n\n",
+                    Table->Signature);
+
+                fprintf (stderr, "Unknown ACPI table signature [%4.4s], ",
+                    Table->Signature);
+
+                if (!AcpiGbl_ForceAmlDisassembly)
+                {
+                    fprintf (stderr, "decoding ACPI table header only\n");
+                }
+                else
+                {
+                    fprintf (stderr, "assuming table contains valid AML code\n");
+                }
+            }
+        }
+        else if (TableData->TableHandler)
+        {
+            /* Complex table, has a handler */
+
+            TableData->TableHandler (Table);
+        }
+        else if (TableData->TableInfo)
+        {
+            /* Simple table, just walk the info table */
+
+            Status = AcpiDmDumpTable (Length, 0, Table, 0, TableData->TableInfo);
+            if (ACPI_FAILURE (Status))
+            {
+                return;
+            }
+        }
+    }
+
+    if (!Gbl_DoTemplates || Gbl_VerboseTemplates)
+    {
+        /* Dump the raw table data */
+
+        AcpiOsPrintf ("\n%s: Length %d (0x%X)\n\n",
+            ACPI_RAW_TABLE_DATA_HEADER, Length, Length);
+        AcpiUtDumpBuffer (ACPI_CAST_PTR (UINT8, Table),
+            Length, DB_BYTE_DISPLAY, 0);
+    }
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiDmLineHeader
+ *
+ * PARAMETERS:  Offset              - Current byte offset, from table start
+ *              ByteLength          - Length of the field in bytes, 0 for flags
+ *              Name                - Name of this field
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Utility routines for formatting output lines. Displays the
+ *              current table offset in hex and decimal, the field length,
+ *              and the field name.
+ *
+ ******************************************************************************/
+
+void
+AcpiDmLineHeader (
+    UINT32                  Offset,
+    UINT32                  ByteLength,
+    char                    *Name)
+{
+
+    /* Allow a null name for fields that span multiple lines (large buffers) */
+
+    if (!Name)
+    {
+        Name = "";
+    }
+
+    if (Gbl_DoTemplates && !Gbl_VerboseTemplates) /* Terse template */
+    {
+        if (ByteLength)
+        {
+            AcpiOsPrintf ("[%.4d] %34s : ", ByteLength, Name);
+        }
+        else
+        {
+            if (*Name)
+            {
+                AcpiOsPrintf ("%41s : ", Name);
+            }
+            else
+            {
+                AcpiOsPrintf ("%41s   ", Name);
+            }
+        }
+    }
+    else /* Normal disassembler or verbose template */
+    {
+        if (ByteLength)
+        {
+            AcpiOsPrintf ("[%3.3Xh %4.4d% 4d] %28s : ",
+                Offset, Offset, ByteLength, Name);
+        }
+        else
+        {
+            if (*Name)
+            {
+                AcpiOsPrintf ("%44s : ", Name);
+            }
+            else
+            {
+                AcpiOsPrintf ("%44s   ", Name);
+            }
+        }
+    }
+}
+
+void
+AcpiDmLineHeader2 (
+    UINT32                  Offset,
+    UINT32                  ByteLength,
+    char                    *Name,
+    UINT32                  Value)
+{
+
+    if (Gbl_DoTemplates && !Gbl_VerboseTemplates) /* Terse template */
+    {
+        if (ByteLength)
+        {
+            AcpiOsPrintf ("[%.4d] %30s %3d : ",
+                ByteLength, Name, Value);
+        }
+        else
+        {
+            AcpiOsPrintf ("%36s % 3d : ",
+                Name, Value);
+        }
+    }
+    else /* Normal disassembler or verbose template */
+    {
+        if (ByteLength)
+        {
+            AcpiOsPrintf ("[%3.3Xh %4.4d %3d] %24s %3d : ",
+                Offset, Offset, ByteLength, Name, Value);
+        }
+        else
+        {
+            AcpiOsPrintf ("[%3.3Xh %4.4d   ] %24s %3d : ",
+                Offset, Offset, Name, Value);
+        }
+    }
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiDmDumpTable
+ *
+ * PARAMETERS:  TableLength         - Length of the entire ACPI table
+ *              TableOffset         - Starting offset within the table for this
+ *                                    sub-descriptor (0 if main table)
+ *              Table               - The ACPI table
+ *              SubtableLength      - Length of this sub-descriptor
+ *              Info                - Info table for this ACPI table
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Display ACPI table contents by walking the Info table.
+ *
+ * Note: This function must remain in sync with DtGetFieldLength.
+ *
+ ******************************************************************************/
+
+ACPI_STATUS
+AcpiDmDumpTable (
+    UINT32                  TableLength,
+    UINT32                  TableOffset,
+    void                    *Table,
+    UINT32                  SubtableLength,
+    ACPI_DMTABLE_INFO       *Info)
+{
+    UINT8                   *Target;
+    UINT32                  CurrentOffset;
+    UINT32                  ByteLength;
+    UINT8                   Temp8;
+    UINT16                  Temp16;
+    UINT32                  Temp32;
+    UINT64                  Value;
+    const AH_TABLE          *TableData;
+    const char              *Name;
+    BOOLEAN                 LastOutputBlankLine = FALSE;
+    ACPI_STATUS             Status;
+    char                    RepairedName[8];
+
+
+    if (!Info)
+    {
+        AcpiOsPrintf ("Display not implemented\n");
+        return (AE_NOT_IMPLEMENTED);
+    }
+
+    /* Walk entire Info table; Null name terminates */
+
+    for (; Info->Name; Info++)
+    {
+        /*
+         * Target points to the field within the ACPI Table. CurrentOffset is
+         * the offset of the field from the start of the main table.
+         */
+        Target = ACPI_ADD_PTR (UINT8, Table, Info->Offset);
+        CurrentOffset = TableOffset + Info->Offset;
+
+        /* Check for beyond subtable end or (worse) beyond EOT */
+
+        if (SubtableLength && (Info->Offset >= SubtableLength))
+        {
+            AcpiOsPrintf (
+                "/**** ACPI subtable terminates early - "
+                "may be older version (dump table) */\n");
+
+            /* Move on to next subtable */
+
+            return (AE_OK);
+        }
+
+        if (CurrentOffset >= TableLength)
+        {
+            AcpiOsPrintf (
+                "/**** ACPI table terminates "
+                "in the middle of a data structure! (dump table) */\n");
+            return (AE_BAD_DATA);
+        }
+
+        /* Generate the byte length for this field */
+
+        switch (Info->Opcode)
+        {
+        case ACPI_DMT_UINT8:
+        case ACPI_DMT_CHKSUM:
+        case ACPI_DMT_SPACEID:
+        case ACPI_DMT_ACCWIDTH:
+        case ACPI_DMT_IVRS:
+        case ACPI_DMT_GTDT:
+        case ACPI_DMT_MADT:
+        case ACPI_DMT_PCCT:
+        case ACPI_DMT_PMTT:
+        case ACPI_DMT_SRAT:
+        case ACPI_DMT_ASF:
+        case ACPI_DMT_HESTNTYP:
+        case ACPI_DMT_FADTPM:
+        case ACPI_DMT_EINJACT:
+        case ACPI_DMT_EINJINST:
+        case ACPI_DMT_ERSTACT:
+        case ACPI_DMT_ERSTINST:
+        case ACPI_DMT_DMAR_SCOPE:
+
+            ByteLength = 1;
+            break;
+
+        case ACPI_DMT_UINT16:
+        case ACPI_DMT_DMAR:
+        case ACPI_DMT_HEST:
+        case ACPI_DMT_NFIT:
+
+            ByteLength = 2;
+            break;
+
+        case ACPI_DMT_UINT24:
+
+            ByteLength = 3;
+            break;
+
+        case ACPI_DMT_UINT32:
+        case ACPI_DMT_NAME4:
+        case ACPI_DMT_SIG:
+        case ACPI_DMT_LPIT:
+
+            ByteLength = 4;
+            break;
+
+        case ACPI_DMT_UINT40:
+
+            ByteLength = 5;
+            break;
+
+        case ACPI_DMT_UINT48:
+        case ACPI_DMT_NAME6:
+
+            ByteLength = 6;
+            break;
+
+        case ACPI_DMT_UINT56:
+        case ACPI_DMT_BUF7:
+
+            ByteLength = 7;
+            break;
+
+        case ACPI_DMT_UINT64:
+        case ACPI_DMT_NAME8:
+
+            ByteLength = 8;
+            break;
+
+        case ACPI_DMT_BUF10:
+
+            ByteLength = 10;
+            break;
+
+        case ACPI_DMT_BUF16:
+        case ACPI_DMT_UUID:
+
+            ByteLength = 16;
+            break;
+
+        case ACPI_DMT_BUF128:
+
+            ByteLength = 128;
+            break;
+
+        case ACPI_DMT_UNICODE:
+        case ACPI_DMT_BUFFER:
+        case ACPI_DMT_RAW_BUFFER:
+
+            ByteLength = SubtableLength;
+            break;
+
+        case ACPI_DMT_STRING:
+
+            ByteLength = strlen (ACPI_CAST_PTR (char, Target)) + 1;
+            break;
+
+        case ACPI_DMT_GAS:
+
+            if (!LastOutputBlankLine)
+            {
+                AcpiOsPrintf ("\n");
+                LastOutputBlankLine = TRUE;
+            }
+
+            ByteLength = sizeof (ACPI_GENERIC_ADDRESS);
+            break;
+
+        case ACPI_DMT_HESTNTFY:
+
+            if (!LastOutputBlankLine)
+            {
+                AcpiOsPrintf ("\n");
+                LastOutputBlankLine = TRUE;
+            }
+
+            ByteLength = sizeof (ACPI_HEST_NOTIFY);
+            break;
+
+        case ACPI_DMT_IORTMEM:
+
+            if (!LastOutputBlankLine)
+            {
+                LastOutputBlankLine = FALSE;
+            }
+
+            ByteLength = sizeof (ACPI_IORT_MEMORY_ACCESS);
+            break;
+
+        default:
+
+            ByteLength = 0;
+            break;
+        }
+
+        /* Check if we are beyond a subtable, or (worse) beyond EOT */
+
+        if (CurrentOffset + ByteLength > TableLength)
+        {
+            if (SubtableLength)
+            {
+                AcpiOsPrintf (
+                    "/**** ACPI subtable terminates early - "
+                    "may be older version (dump table) */\n");
+
+                /* Move on to next subtable */
+
+                return (AE_OK);
+            }
+
+            AcpiOsPrintf (
+                "/**** ACPI table terminates "
+                "in the middle of a data structure! */\n");
+            return (AE_BAD_DATA);
+        }
+
+        if (Info->Opcode == ACPI_DMT_EXTRA_TEXT)
+        {
+            AcpiOsPrintf ("%s", Info->Name);
+            continue;
+        }
+
+        /* Start a new line and decode the opcode */
+
+        AcpiDmLineHeader (CurrentOffset, ByteLength, Info->Name);
+
+        switch (Info->Opcode)
+        {
+        /* Single-bit Flag fields. Note: Opcode is the bit position */
+
+        case ACPI_DMT_FLAG0:
+        case ACPI_DMT_FLAG1:
+        case ACPI_DMT_FLAG2:
+        case ACPI_DMT_FLAG3:
+        case ACPI_DMT_FLAG4:
+        case ACPI_DMT_FLAG5:
+        case ACPI_DMT_FLAG6:
+        case ACPI_DMT_FLAG7:
+
+            AcpiOsPrintf ("%1.1X\n", (*Target >> Info->Opcode) & 0x01);
+            break;
+
+        /* 2-bit Flag fields */
+
+        case ACPI_DMT_FLAGS0:
+
+            AcpiOsPrintf ("%1.1X\n", *Target & 0x03);
+            break;
+
+        case ACPI_DMT_FLAGS1:
+
+            AcpiOsPrintf ("%1.1X\n", (*Target >> 1) & 0x03);
+            break;
+
+        case ACPI_DMT_FLAGS2:
+
+            AcpiOsPrintf ("%1.1X\n", (*Target >> 2) & 0x03);
+            break;
+
+        case ACPI_DMT_FLAGS4:
+
+            AcpiOsPrintf ("%1.1X\n", (*Target >> 4) & 0x03);
+            break;
+
+        /* Integer Data Types */
+
+        case ACPI_DMT_UINT8:
+        case ACPI_DMT_UINT16:
+        case ACPI_DMT_UINT24:
+        case ACPI_DMT_UINT32:
+        case ACPI_DMT_UINT40:
+        case ACPI_DMT_UINT48:
+        case ACPI_DMT_UINT56:
+        case ACPI_DMT_UINT64:
+            /*
+             * Dump bytes - high byte first, low byte last.
+             * Note: All ACPI tables are little-endian.
+             */
+            Value = 0;
+            for (Temp8 = (UINT8) ByteLength; Temp8 > 0; Temp8--)
+            {
+                AcpiOsPrintf ("%2.2X", Target[Temp8 - 1]);
+                Value |= Target[Temp8 - 1];
+                Value <<= 8;
+            }
+
+            if (!Value && (Info->Flags & DT_DESCRIBES_OPTIONAL))
+            {
+                AcpiOsPrintf (" [Optional field not present]");
+            }
+
+            AcpiOsPrintf ("\n");
+            break;
+
+        case ACPI_DMT_BUF7:
+        case ACPI_DMT_BUF10:
+        case ACPI_DMT_BUF16:
+        case ACPI_DMT_BUF128:
+            /*
+             * Buffer: Size depends on the opcode and was set above.
+             * Each hex byte is separated with a space.
+             * Multiple lines are separated by line continuation char.
+             */
+            for (Temp16 = 0; Temp16 < ByteLength; Temp16++)
+            {
+                AcpiOsPrintf ("%2.2X", Target[Temp16]);
+                if ((UINT32) (Temp16 + 1) < ByteLength)
+                {
+                    if ((Temp16 > 0) && (!((Temp16+1) % 16)))
+                    {
+                        AcpiOsPrintf (" \\\n"); /* Line continuation */
+                        AcpiDmLineHeader (0, 0, NULL);
+                    }
+                    else
+                    {
+                        AcpiOsPrintf (" ");
+                    }
+                }
+            }
+
+            AcpiOsPrintf ("\n");
+            break;
+
+        case ACPI_DMT_UUID:
+
+            /* Convert 16-byte UUID buffer to 36-byte formatted UUID string */
+
+            (void) AuConvertUuidToString ((char *) Target, MsgBuffer);
+
+            AcpiOsPrintf ("%s\n", MsgBuffer);
+            break;
+
+        case ACPI_DMT_STRING:
+
+            AcpiOsPrintf ("\"%s\"\n", ACPI_CAST_PTR (char, Target));
+            break;
+
+        /* Fixed length ASCII name fields */
+
+        case ACPI_DMT_SIG:
+
+            AcpiUtCheckAndRepairAscii (Target, RepairedName, 4);
+            AcpiOsPrintf ("\"%.4s\"    ", RepairedName);
+
+            TableData = AcpiAhGetTableInfo (ACPI_CAST_PTR (char, Target));
+            if (TableData)
+            {
+                AcpiOsPrintf (STRING_FORMAT, TableData->Description);
+            }
+            else
+            {
+                AcpiOsPrintf ("\n");
+            }
+            break;
+
+        case ACPI_DMT_NAME4:
+
+            AcpiUtCheckAndRepairAscii (Target, RepairedName, 4);
+            AcpiOsPrintf ("\"%.4s\"\n", RepairedName);
+            break;
+
+        case ACPI_DMT_NAME6:
+
+            AcpiUtCheckAndRepairAscii (Target, RepairedName, 6);
+            AcpiOsPrintf ("\"%.6s\"\n", RepairedName);
+            break;
+
+        case ACPI_DMT_NAME8:
+
+            AcpiUtCheckAndRepairAscii (Target, RepairedName, 8);
+            AcpiOsPrintf ("\"%.8s\"\n", RepairedName);
+            break;
+
+        /* Special Data Types */
+
+        case ACPI_DMT_CHKSUM:
+
+            /* Checksum, display and validate */
+
+            AcpiOsPrintf ("%2.2X", *Target);
+            Temp8 = AcpiDmGenerateChecksum (Table,
+                ACPI_CAST_PTR (ACPI_TABLE_HEADER, Table)->Length,
+                ACPI_CAST_PTR (ACPI_TABLE_HEADER, Table)->Checksum);
+
+            if (Temp8 != ACPI_CAST_PTR (ACPI_TABLE_HEADER, Table)->Checksum)
+            {
+                AcpiOsPrintf (
+                    "     /* Incorrect checksum, should be %2.2X */", Temp8);
+            }
+
+            AcpiOsPrintf ("\n");
+            break;
+
+        case ACPI_DMT_SPACEID:
+
+            /* Address Space ID */
+
+            AcpiOsPrintf (UINT8_FORMAT, *Target, AcpiUtGetRegionName (*Target));
+            break;
+
+        case ACPI_DMT_ACCWIDTH:
+
+            /* Encoded Access Width */
+
+            Temp8 = *Target;
+            if (Temp8 > ACPI_GAS_WIDTH_RESERVED)
+            {
+                Temp8 = ACPI_GAS_WIDTH_RESERVED;
+            }
+
+            AcpiOsPrintf (UINT8_FORMAT, *Target, AcpiDmGasAccessWidth[Temp8]);
+            break;
+
+        case ACPI_DMT_GAS:
+
+            /* Generic Address Structure */
+
+            AcpiOsPrintf (STRING_FORMAT, "Generic Address Structure");
+            Status = AcpiDmDumpTable (TableLength, CurrentOffset, Target,
+                sizeof (ACPI_GENERIC_ADDRESS), AcpiDmTableInfoGas);
+            if (ACPI_FAILURE (Status))
+            {
+                return (Status);
+            }
+
+            AcpiOsPrintf ("\n");
+            LastOutputBlankLine = TRUE;
+            break;
+
+        case ACPI_DMT_ASF:
+
+            /* ASF subtable types */
+
+            Temp16 = (UINT16) ((*Target) & 0x7F);  /* Top bit can be zero or one */
+            if (Temp16 > ACPI_ASF_TYPE_RESERVED)
+            {
+                Temp16 = ACPI_ASF_TYPE_RESERVED;
+            }
+
+            AcpiOsPrintf (UINT8_FORMAT, *Target, AcpiDmAsfSubnames[Temp16]);
+            break;
+
+        case ACPI_DMT_DMAR:
+
+            /* DMAR subtable types */
+
+            Temp16 = ACPI_GET16 (Target);
+            if (Temp16 > ACPI_DMAR_TYPE_RESERVED)
+            {
+                Temp16 = ACPI_DMAR_TYPE_RESERVED;
+            }
+
+            AcpiOsPrintf (UINT16_FORMAT, ACPI_GET16 (Target),
+                AcpiDmDmarSubnames[Temp16]);
+            break;
+
+        case ACPI_DMT_DMAR_SCOPE:
+
+            /* DMAR device scope types */
+
+            Temp8 = *Target;
+            if (Temp8 > ACPI_DMAR_SCOPE_TYPE_RESERVED)
+            {
+                Temp8 = ACPI_DMAR_SCOPE_TYPE_RESERVED;
+            }
+
+            AcpiOsPrintf (UINT8_FORMAT, *Target,
+                AcpiDmDmarScope[Temp8]);
+            break;
+
+        case ACPI_DMT_EINJACT:
+
+            /* EINJ Action types */
+
+            Temp8 = *Target;
+            if (Temp8 > ACPI_EINJ_ACTION_RESERVED)
+            {
+                Temp8 = ACPI_EINJ_ACTION_RESERVED;
+            }
+
+            AcpiOsPrintf (UINT8_FORMAT, *Target,
+                AcpiDmEinjActions[Temp8]);
+            break;
+
+        case ACPI_DMT_EINJINST:
+
+            /* EINJ Instruction types */
+
+            Temp8 = *Target;
+            if (Temp8 > ACPI_EINJ_INSTRUCTION_RESERVED)
+            {
+                Temp8 = ACPI_EINJ_INSTRUCTION_RESERVED;
+            }
+
+            AcpiOsPrintf (UINT8_FORMAT, *Target,
+                AcpiDmEinjInstructions[Temp8]);
+            break;
+
+        case ACPI_DMT_ERSTACT:
+
+            /* ERST Action types */
+
+            Temp8 = *Target;
+            if (Temp8 > ACPI_ERST_ACTION_RESERVED)
+            {
+                Temp8 = ACPI_ERST_ACTION_RESERVED;
+            }
+
+            AcpiOsPrintf (UINT8_FORMAT, *Target,
+                AcpiDmErstActions[Temp8]);
+            break;
+
+        case ACPI_DMT_ERSTINST:
+
+            /* ERST Instruction types */
+
+            Temp8 = *Target;
+            if (Temp8 > ACPI_ERST_INSTRUCTION_RESERVED)
+            {
+                Temp8 = ACPI_ERST_INSTRUCTION_RESERVED;
+            }
+
+            AcpiOsPrintf (UINT8_FORMAT, *Target,
+                AcpiDmErstInstructions[Temp8]);
+            break;
+
+        case ACPI_DMT_GTDT:
+
+            /* GTDT subtable types */
+
+            Temp8 = *Target;
+            if (Temp8 > ACPI_GTDT_TYPE_RESERVED)
+            {
+                Temp8 = ACPI_GTDT_TYPE_RESERVED;
+            }
+
+            AcpiOsPrintf (UINT8_FORMAT, *Target,
+                AcpiDmGtdtSubnames[Temp8]);
+            break;
+
+        case ACPI_DMT_HEST:
+
+            /* HEST subtable types */
+
+            Temp16 = ACPI_GET16 (Target);
+            if (Temp16 > ACPI_HEST_TYPE_RESERVED)
+            {
+                Temp16 = ACPI_HEST_TYPE_RESERVED;
+            }
+
+            AcpiOsPrintf (UINT16_FORMAT, ACPI_GET16 (Target),
+                AcpiDmHestSubnames[Temp16]);
+            break;
+
+        case ACPI_DMT_HESTNTFY:
+
+            AcpiOsPrintf (STRING_FORMAT,
+                "Hardware Error Notification Structure");
+
+            Status = AcpiDmDumpTable (TableLength, CurrentOffset, Target,
+                sizeof (ACPI_HEST_NOTIFY), AcpiDmTableInfoHestNotify);
+            if (ACPI_FAILURE (Status))
+            {
+                return (Status);
+            }
+
+            AcpiOsPrintf ("\n");
+            LastOutputBlankLine = TRUE;
+            break;
+
+        case ACPI_DMT_HESTNTYP:
+
+            /* HEST Notify types */
+
+            Temp8 = *Target;
+            if (Temp8 > ACPI_HEST_NOTIFY_RESERVED)
+            {
+                Temp8 = ACPI_HEST_NOTIFY_RESERVED;
+            }
+
+            AcpiOsPrintf (UINT8_FORMAT, *Target,
+                AcpiDmHestNotifySubnames[Temp8]);
+            break;
+
+        case ACPI_DMT_IORTMEM:
+
+            AcpiOsPrintf (STRING_FORMAT,
+                "IORT Memory Access Properties");
+
+            Status = AcpiDmDumpTable (TableLength, CurrentOffset, Target,
+                sizeof (ACPI_IORT_MEMORY_ACCESS), AcpiDmTableInfoIortAcc);
+            if (ACPI_FAILURE (Status))
+            {
+                return (Status);
+            }
+
+            LastOutputBlankLine = TRUE;
+            break;
+
+        case ACPI_DMT_MADT:
+
+            /* MADT subtable types */
+
+            Temp8 = *Target;
+            if (Temp8 > ACPI_MADT_TYPE_RESERVED)
+            {
+                Temp8 = ACPI_MADT_TYPE_RESERVED;
+            }
+
+            AcpiOsPrintf (UINT8_FORMAT, *Target,
+                AcpiDmMadtSubnames[Temp8]);
+            break;
+
+        case ACPI_DMT_NFIT:
+
+            /* NFIT subtable types */
+
+            Temp16 = ACPI_GET16 (Target);
+            if (Temp16 > ACPI_NFIT_TYPE_RESERVED)
+            {
+                Temp16 = ACPI_NFIT_TYPE_RESERVED;
+            }
+
+            AcpiOsPrintf (UINT16_FORMAT, ACPI_GET16 (Target),
+                AcpiDmNfitSubnames[Temp16]);
+            break;
+
+        case ACPI_DMT_PCCT:
+
+            /* PCCT subtable types */
+
+            Temp8 = *Target;
+            if (Temp8 > ACPI_PCCT_TYPE_RESERVED)
+            {
+                Temp8 = ACPI_PCCT_TYPE_RESERVED;
+            }
+
+            AcpiOsPrintf (UINT8_FORMAT, *Target,
+                AcpiDmPcctSubnames[Temp8]);
+            break;
+
+        case ACPI_DMT_PMTT:
+
+            /* PMTT subtable types */
+
+            Temp8 = *Target;
+            if (Temp8 > ACPI_PMTT_TYPE_RESERVED)
+            {
+                Temp8 = ACPI_PMTT_TYPE_RESERVED;
+            }
+
+            AcpiOsPrintf (UINT8_FORMAT, *Target,
+                AcpiDmPmttSubnames[Temp8]);
+            break;
+
+        case ACPI_DMT_UNICODE:
+
+            if (ByteLength == 0)
+            {
+                AcpiOsPrintf ("/* Zero-length Data */\n");
+                break;
+            }
+
+            AcpiDmDumpUnicode (Table, CurrentOffset, ByteLength);
+            break;
+
+        case ACPI_DMT_RAW_BUFFER:
+
+            if (ByteLength == 0)
+            {
+                AcpiOsPrintf ("/* Zero-length Data */\n");
+                break;
+            }
+
+            AcpiDmDumpBuffer (Table, CurrentOffset, ByteLength,
+                CurrentOffset, NULL);
+            break;
+
+        case ACPI_DMT_SRAT:
+
+            /* SRAT subtable types */
+
+            Temp8 = *Target;
+            if (Temp8 > ACPI_SRAT_TYPE_RESERVED)
+            {
+                Temp8 = ACPI_SRAT_TYPE_RESERVED;
+            }
+
+            AcpiOsPrintf (UINT8_FORMAT, *Target,
+                AcpiDmSratSubnames[Temp8]);
+            break;
+
+        case ACPI_DMT_FADTPM:
+
+            /* FADT Preferred PM Profile names */
+
+            Temp8 = *Target;
+            if (Temp8 > ACPI_FADT_PM_RESERVED)
+            {
+                Temp8 = ACPI_FADT_PM_RESERVED;
+            }
+
+            AcpiOsPrintf (UINT8_FORMAT, *Target,
+                AcpiDmFadtProfiles[Temp8]);
+            break;
+
+        case ACPI_DMT_IVRS:
+
+            /* IVRS subtable types */
+
+            Temp8 = *Target;
+            switch (Temp8)
+            {
+            case ACPI_IVRS_TYPE_HARDWARE:
+
+                Name = AcpiDmIvrsSubnames[0];
+                break;
+
+            case ACPI_IVRS_TYPE_MEMORY1:
+            case ACPI_IVRS_TYPE_MEMORY2:
+            case ACPI_IVRS_TYPE_MEMORY3:
+
+                Name = AcpiDmIvrsSubnames[1];
+                break;
+
+            default:
+
+                Name = AcpiDmIvrsSubnames[2];
+                break;
+            }
+
+            AcpiOsPrintf (UINT8_FORMAT, *Target, Name);
+            break;
+
+        case ACPI_DMT_LPIT:
+
+            /* LPIT subtable types */
+
+            Temp32 = ACPI_GET32 (Target);
+            if (Temp32 > ACPI_LPIT_TYPE_RESERVED)
+            {
+                Temp32 = ACPI_LPIT_TYPE_RESERVED;
+            }
+
+            AcpiOsPrintf (UINT32_FORMAT, ACPI_GET32 (Target),
+                AcpiDmLpitSubnames[Temp32]);
+            break;
+
+        case ACPI_DMT_EXIT:
+
+            return (AE_OK);
+
+        default:
+
+            ACPI_ERROR ((AE_INFO,
+                "**** Invalid table opcode [0x%X] ****\n", Info->Opcode));
+            return (AE_SUPPORT);
+        }
+    }
+
+    if (TableOffset && !SubtableLength)
+    {
+        /*
+         * If this table is not the main table, the subtable must have a
+         * valid length
+         */
+        AcpiOsPrintf ("Invalid zero length subtable\n");
+        return (AE_BAD_DATA);
+    }
+
+    return (AE_OK);
+}
diff --git a/usr/src/cmd/acpi/common/dmtables.c b/usr/src/cmd/acpi/common/dmtables.c
new file mode 100644
index 0000000000..85abfe7e7f
--- /dev/null
+++ b/usr/src/cmd/acpi/common/dmtables.c
@@ -0,0 +1,485 @@
+/******************************************************************************
+ *
+ * Module Name: dmtables - disassembler ACPI table support
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2016, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include "aslcompiler.h"
+#include "acapps.h"
+#include "acdispat.h"
+#include "acnamesp.h"
+#include "actables.h"
+#include "acparser.h"
+
+#include <stdio.h>
+#include <time.h>
+
+#define _COMPONENT          ACPI_TOOLS
+        ACPI_MODULE_NAME    ("dmtables")
+
+
+/* Local prototypes */
+
+static void
+AdCreateTableHeader (
+    char                    *Filename,
+    ACPI_TABLE_HEADER       *Table);
+
+static ACPI_STATUS
+AdStoreTable (
+    ACPI_TABLE_HEADER       *Table,
+    UINT32                  *TableIndex);
+
+
+extern ACPI_TABLE_DESC      LocalTables[1];
+extern ACPI_PARSE_OBJECT    *AcpiGbl_ParseOpRoot;
+
+
+/******************************************************************************
+ *
+ * FUNCTION:    AdDisassemblerHeader
+ *
+ * PARAMETERS:  Filename            - Input file for the table
+ *              TableType           - Either AML or DataTable
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Create the disassembler header, including ACPICA signon with
+ *              current time and date.
+ *
+ *****************************************************************************/
+
+void
+AdDisassemblerHeader (
+    char                    *Filename,
+    UINT8                   TableType)
+{
+    time_t                  Timer;
+
+
+    time (&Timer);
+
+    /* Header and input table info */
+
+    AcpiOsPrintf ("/*\n");
+    AcpiOsPrintf (ACPI_COMMON_HEADER (AML_DISASSEMBLER_NAME, " * "));
+
+    if (TableType == ACPI_IS_AML_TABLE)
+    {
+        if (AcpiGbl_CstyleDisassembly)
+        {
+            AcpiOsPrintf (
+                " * Disassembling to symbolic ASL+ operators\n"
+                " *\n");
+        }
+        else
+        {
+            AcpiOsPrintf (
+                " * Disassembling to non-symbolic legacy ASL operators\n"
+                " *\n");
+        }
+    }
+
+    AcpiOsPrintf (" * Disassembly of %s, %s", Filename, ctime (&Timer));
+    AcpiOsPrintf (" *\n");
+}
+
+
+/******************************************************************************
+ *
+ * FUNCTION:    AdCreateTableHeader
+ *
+ * PARAMETERS:  Filename            - Input file for the table
+ *              Table               - Pointer to the raw table
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Create the ASL table header, including ACPICA signon with
+ *              current time and date.
+ *
+ *****************************************************************************/
+
+static void
+AdCreateTableHeader (
+    char                    *Filename,
+    ACPI_TABLE_HEADER       *Table)
+{
+    UINT8                   Checksum;
+
+
+    /* Reset globals for External statements */
+
+    AcpiGbl_NumExternalMethods = 0;
+    AcpiGbl_ResolvedExternalMethods = 0;
+
+    /*
+     * Print file header and dump original table header
+     */
+    AdDisassemblerHeader (Filename, ACPI_IS_AML_TABLE);
+
+    AcpiOsPrintf (" * Original Table Header:\n");
+    AcpiOsPrintf (" *     Signature        \"%4.4s\"\n",    Table->Signature);
+    AcpiOsPrintf (" *     Length           0x%8.8X (%u)\n", Table->Length, Table->Length);
+
+    /* Print and validate the revision */
+
+    AcpiOsPrintf (" *     Revision         0x%2.2X",      Table->Revision);
+
+    switch (Table->Revision)
+    {
+    case 0:
+
+        AcpiOsPrintf (" **** Invalid Revision");
+        break;
+
+    case 1:
+
+        /* Revision of DSDT controls the ACPI integer width */
+
+        if (ACPI_COMPARE_NAME (Table->Signature, ACPI_SIG_DSDT))
+        {
+            AcpiOsPrintf (" **** 32-bit table (V1), no 64-bit math support");
+        }
+        break;
+
+    default:
+
+        break;
+    }
+
+    /* Print and validate the table checksum */
+
+    AcpiOsPrintf ("\n *     Checksum         0x%2.2X",        Table->Checksum);
+
+    Checksum = AcpiTbChecksum (ACPI_CAST_PTR (UINT8, Table), Table->Length);
+    if (Checksum)
+    {
+        AcpiOsPrintf (" **** Incorrect checksum, should be 0x%2.2X",
+            (UINT8) (Table->Checksum - Checksum));
+    }
+
+    AcpiOsPrintf ("\n");
+    AcpiOsPrintf (" *     OEM ID           \"%.6s\"\n",     Table->OemId);
+    AcpiOsPrintf (" *     OEM Table ID     \"%.8s\"\n",     Table->OemTableId);
+    AcpiOsPrintf (" *     OEM Revision     0x%8.8X (%u)\n", Table->OemRevision, Table->OemRevision);
+    AcpiOsPrintf (" *     Compiler ID      \"%.4s\"\n",     Table->AslCompilerId);
+    AcpiOsPrintf (" *     Compiler Version 0x%8.8X (%u)\n", Table->AslCompilerRevision, Table->AslCompilerRevision);
+    AcpiOsPrintf (" */\n");
+
+    /*
+     * Open the ASL definition block.
+     *
+     * Note: the AMLFilename string is left zero-length in order to just let
+     * the compiler create it when the disassembled file is compiled. This
+     * makes it easier to rename the disassembled ASL file if needed.
+     */
+    AcpiOsPrintf (
+        "DefinitionBlock (\"\", \"%4.4s\", %hu, \"%.6s\", \"%.8s\", 0x%8.8X)\n",
+        Table->Signature, Table->Revision,
+        Table->OemId, Table->OemTableId, Table->OemRevision);
+}
+
+
+/******************************************************************************
+ *
+ * FUNCTION:    AdDisplayTables
+ *
+ * PARAMETERS:  Filename            - Input file for the table
+ *              Table               - Pointer to the raw table
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Display (disassemble) loaded tables and dump raw tables
+ *
+ *****************************************************************************/
+
+ACPI_STATUS
+AdDisplayTables (
+    char                    *Filename,
+    ACPI_TABLE_HEADER       *Table)
+{
+
+
+    if (!AcpiGbl_ParseOpRoot)
+    {
+        return (AE_NOT_EXIST);
+    }
+
+    if (!AcpiGbl_DmOpt_Listing)
+    {
+        AdCreateTableHeader (Filename, Table);
+    }
+
+    AcpiDmDisassemble (NULL, AcpiGbl_ParseOpRoot, ACPI_UINT32_MAX);
+    MpEmitMappingInfo ();
+
+    if (AcpiGbl_DmOpt_Listing)
+    {
+        AcpiOsPrintf ("\n\nTable Header:\n");
+        AcpiUtDebugDumpBuffer ((UINT8 *) Table, sizeof (ACPI_TABLE_HEADER),
+            DB_BYTE_DISPLAY, ACPI_UINT32_MAX);
+
+        AcpiOsPrintf ("Table Body (Length 0x%X)\n", Table->Length);
+        AcpiUtDebugDumpBuffer (((UINT8 *) Table + sizeof (ACPI_TABLE_HEADER)),
+            Table->Length, DB_BYTE_DISPLAY, ACPI_UINT32_MAX);
+    }
+
+    return (AE_OK);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AdStoreTable
+ *
+ * PARAMETERS:  Table               - Table header
+ *              TableIndex          - Where the table index is returned
+ *
+ * RETURN:      Status and table index.
+ *
+ * DESCRIPTION: Add an ACPI table to the global table list
+ *
+ ******************************************************************************/
+
+static ACPI_STATUS
+AdStoreTable (
+    ACPI_TABLE_HEADER       *Table,
+    UINT32                  *TableIndex)
+{
+    ACPI_STATUS             Status;
+    ACPI_TABLE_DESC         *TableDesc;
+
+
+    Status = AcpiTbGetNextTableDescriptor (TableIndex, &TableDesc);
+    if (ACPI_FAILURE (Status))
+    {
+        return (Status);
+    }
+
+    /* Initialize added table */
+
+    AcpiTbInitTableDescriptor (TableDesc, ACPI_PTR_TO_PHYSADDR (Table),
+        ACPI_TABLE_ORIGIN_INTERNAL_VIRTUAL, Table);
+    Status = AcpiTbValidateTable (TableDesc);
+    return (Status);
+}
+
+
+/******************************************************************************
+ *
+ * FUNCTION:    AdGetLocalTables
+ *
+ * PARAMETERS:  None
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Get the ACPI tables from either memory or a file
+ *
+ *****************************************************************************/
+
+ACPI_STATUS
+AdGetLocalTables (
+    void)
+{
+    ACPI_STATUS             Status;
+    ACPI_TABLE_HEADER       TableHeader;
+    ACPI_TABLE_HEADER       *NewTable;
+    UINT32                  TableIndex;
+
+
+    /* Get the DSDT via table override */
+
+    ACPI_MOVE_32_TO_32 (TableHeader.Signature, ACPI_SIG_DSDT);
+    AcpiOsTableOverride (&TableHeader, &NewTable);
+    if (!NewTable)
+    {
+        fprintf (stderr, "Could not obtain DSDT\n");
+        return (AE_NO_ACPI_TABLES);
+    }
+
+    AdWriteTable (NewTable, NewTable->Length,
+        ACPI_SIG_DSDT, NewTable->OemTableId);
+
+    /* Store DSDT in the Table Manager */
+
+    Status = AdStoreTable (NewTable, &TableIndex);
+    if (ACPI_FAILURE (Status))
+    {
+        fprintf (stderr, "Could not store DSDT\n");
+        return (AE_NO_ACPI_TABLES);
+    }
+
+    return (AE_OK);
+}
+
+
+/******************************************************************************
+ *
+ * FUNCTION:    AdParseTable
+ *
+ * PARAMETERS:  Table               - Pointer to the raw table
+ *              OwnerId             - Returned OwnerId of the table
+ *              LoadTable           - If add table to the global table list
+ *              External            - If this is an external table
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Parse an ACPI AML table
+ *
+ *****************************************************************************/
+
+ACPI_STATUS
+AdParseTable (
+    ACPI_TABLE_HEADER       *Table,
+    ACPI_OWNER_ID           *OwnerId,
+    BOOLEAN                 LoadTable,
+    BOOLEAN                 External)
+{
+    ACPI_STATUS             Status = AE_OK;
+    ACPI_WALK_STATE         *WalkState;
+    UINT8                   *AmlStart;
+    UINT32                  AmlLength;
+    UINT32                  TableIndex;
+
+
+    if (!Table)
+    {
+        return (AE_NOT_EXIST);
+    }
+
+    /* Pass 1:  Parse everything except control method bodies */
+
+    fprintf (stderr, "Pass 1 parse of [%4.4s]\n", (char *) Table->Signature);
+
+    AmlLength = Table->Length - sizeof (ACPI_TABLE_HEADER);
+    AmlStart = ((UINT8 *) Table + sizeof (ACPI_TABLE_HEADER));
+
+    /* Create the root object */
+
+    AcpiGbl_ParseOpRoot = AcpiPsCreateScopeOp (AmlStart);
+    if (!AcpiGbl_ParseOpRoot)
+    {
+        return (AE_NO_MEMORY);
+    }
+
+    /* Create and initialize a new walk state */
+
+    WalkState = AcpiDsCreateWalkState (0, AcpiGbl_ParseOpRoot, NULL, NULL);
+    if (!WalkState)
+    {
+        return (AE_NO_MEMORY);
+    }
+
+    Status = AcpiDsInitAmlWalk (WalkState, AcpiGbl_ParseOpRoot,
+        NULL, AmlStart, AmlLength, NULL, ACPI_IMODE_LOAD_PASS1);
+    if (ACPI_FAILURE (Status))
+    {
+        return (Status);
+    }
+
+    WalkState->ParseFlags &= ~ACPI_PARSE_DELETE_TREE;
+    WalkState->ParseFlags |= ACPI_PARSE_DISASSEMBLE;
+
+    Status = AcpiPsParseAml (WalkState);
+    if (ACPI_FAILURE (Status))
+    {
+        return (Status);
+    }
+
+    /* If LoadTable is FALSE, we are parsing the last loaded table */
+
+    TableIndex = AcpiGbl_RootTableList.CurrentTableCount - 1;
+
+    /* Pass 2 */
+
+    if (LoadTable)
+    {
+        Status = AdStoreTable (Table, &TableIndex);
+        if (ACPI_FAILURE (Status))
+        {
+            return (Status);
+        }
+        Status = AcpiTbAllocateOwnerId (TableIndex);
+        if (ACPI_FAILURE (Status))
+        {
+            return (Status);
+        }
+        if (OwnerId)
+        {
+            Status = AcpiTbGetOwnerId (TableIndex, OwnerId);
+            if (ACPI_FAILURE (Status))
+            {
+                return (Status);
+            }
+        }
+    }
+
+    fprintf (stderr, "Pass 2 parse of [%4.4s]\n", (char *) Table->Signature);
+
+    Status = AcpiNsOneCompleteParse (ACPI_IMODE_LOAD_PASS2, TableIndex, NULL);
+    if (ACPI_FAILURE (Status))
+    {
+        return (Status);
+    }
+
+    /* No need to parse control methods of external table */
+
+    if (External)
+    {
+        return (AE_OK);
+    }
+
+    /*
+     * Pass 3: Parse control methods and link their parse trees
+     * into the main parse tree
+     */
+    fprintf (stderr,
+        "Parsing Deferred Opcodes (Methods/Buffers/Packages/Regions)\n");
+
+    Status = AcpiDmParseDeferredOps (AcpiGbl_ParseOpRoot);
+    fprintf (stderr, "\n");
+
+    /* Process Resource Templates */
+
+    AcpiDmFindResources (AcpiGbl_ParseOpRoot);
+
+    fprintf (stderr, "Parsing completed\n");
+    return (AE_OK);
+}
diff --git a/usr/src/cmd/acpi/common/dmtbdump.c b/usr/src/cmd/acpi/common/dmtbdump.c
new file mode 100644
index 0000000000..789256c12d
--- /dev/null
+++ b/usr/src/cmd/acpi/common/dmtbdump.c
@@ -0,0 +1,3692 @@
+/******************************************************************************
+ *
+ * Module Name: dmtbdump - Dump ACPI data tables that contain no AML code
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2016, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include "acpi.h"
+#include "accommon.h"
+#include "acdisasm.h"
+#include "actables.h"
+
+/* This module used for application-level code only */
+
+#define _COMPONENT          ACPI_CA_DISASSEMBLER
+        ACPI_MODULE_NAME    ("dmtbdump")
+
+
+/* Local prototypes */
+
+static void
+AcpiDmValidateFadtLength (
+    UINT32                  Revision,
+    UINT32                  Length);
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiDmDumpBuffer
+ *
+ * PARAMETERS:  Table               - ACPI Table or subtable
+ *              BufferOffset        - Offset of buffer from Table above
+ *              Length              - Length of the buffer
+ *              AbsoluteOffset      - Offset of buffer in the main ACPI table
+ *              Header              - Name of the buffer field (printed on the
+ *                                    first line only.)
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Format the contents of an arbitrary length data buffer (in the
+ *              disassembler output format.)
+ *
+ ******************************************************************************/
+
+void
+AcpiDmDumpBuffer (
+    void                    *Table,
+    UINT32                  BufferOffset,
+    UINT32                  Length,
+    UINT32                  AbsoluteOffset,
+    char                    *Header)
+{
+    UINT8                   *Buffer;
+    UINT32                  i;
+
+
+    if (!Length)
+    {
+        return;
+    }
+
+    Buffer = ACPI_CAST_PTR (UINT8, Table) + BufferOffset;
+    i = 0;
+
+    while (i < Length)
+    {
+        if (!(i % 16))
+        {
+            /* Insert a backslash - line continuation character */
+
+            if (Length > 16)
+            {
+                AcpiOsPrintf ("\\\n    ");
+            }
+        }
+
+        AcpiOsPrintf ("%.02X ", *Buffer);
+        i++;
+        Buffer++;
+        AbsoluteOffset++;
+    }
+
+    AcpiOsPrintf ("\n");
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiDmDumpUnicode
+ *
+ * PARAMETERS:  Table               - ACPI Table or subtable
+ *              BufferOffset        - Offset of buffer from Table above
+ *              ByteLength          - Length of the buffer
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Validate and dump the contents of a buffer that contains
+ *              unicode data. The output is a standard ASCII string. If it
+ *              appears that the data is not unicode, the buffer is dumped
+ *              as hex characters.
+ *
+ ******************************************************************************/
+
+void
+AcpiDmDumpUnicode (
+    void                    *Table,
+    UINT32                  BufferOffset,
+    UINT32                  ByteLength)
+{
+    UINT8                   *Buffer;
+    UINT32                  Length;
+    UINT32                  i;
+
+
+    Buffer = ((UINT8 *) Table) + BufferOffset;
+    Length = ByteLength - 2; /* Last two bytes are the null terminator */
+
+    /* Ensure all low bytes are entirely printable ASCII */
+
+    for (i = 0; i < Length; i += 2)
+    {
+        if (!isprint (Buffer[i]))
+        {
+            goto DumpRawBuffer;
+        }
+    }
+
+    /* Ensure all high bytes are zero */
+
+    for (i = 1; i < Length; i += 2)
+    {
+        if (Buffer[i])
+        {
+            goto DumpRawBuffer;
+        }
+    }
+
+    /* Dump the buffer as a normal string */
+
+    AcpiOsPrintf ("\"");
+    for (i = 0; i < Length; i += 2)
+    {
+        AcpiOsPrintf ("%c", Buffer[i]);
+    }
+
+    AcpiOsPrintf ("\"\n");
+    return;
+
+DumpRawBuffer:
+    AcpiDmDumpBuffer (Table, BufferOffset, ByteLength,
+        BufferOffset, NULL);
+    AcpiOsPrintf ("\n");
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiDmDumpRsdp
+ *
+ * PARAMETERS:  Table               - A RSDP
+ *
+ * RETURN:      Length of the table (there is not always a length field,
+ *              use revision or length if available (ACPI 2.0+))
+ *
+ * DESCRIPTION: Format the contents of a RSDP
+ *
+ ******************************************************************************/
+
+UINT32
+AcpiDmDumpRsdp (
+    ACPI_TABLE_HEADER       *Table)
+{
+    ACPI_TABLE_RSDP         *Rsdp = ACPI_CAST_PTR (ACPI_TABLE_RSDP, Table);
+    UINT32                  Length = sizeof (ACPI_RSDP_COMMON);
+    UINT8                   Checksum;
+    ACPI_STATUS             Status;
+
+
+    /* Dump the common ACPI 1.0 portion */
+
+    Status = AcpiDmDumpTable (Length, 0, Table, 0, AcpiDmTableInfoRsdp1);
+    if (ACPI_FAILURE (Status))
+    {
+        return (Length);
+    }
+
+    /* Validate the first checksum */
+
+    Checksum = AcpiDmGenerateChecksum (Rsdp, sizeof (ACPI_RSDP_COMMON),
+        Rsdp->Checksum);
+    if (Checksum != Rsdp->Checksum)
+    {
+        AcpiOsPrintf ("/* Incorrect Checksum above, should be 0x%2.2X */\n",
+            Checksum);
+    }
+
+    /* The RSDP for ACPI 2.0+ contains more data and has a Length field */
+
+    if (Rsdp->Revision > 0)
+    {
+        Length = Rsdp->Length;
+        Status = AcpiDmDumpTable (Length, 0, Table, 0, AcpiDmTableInfoRsdp2);
+        if (ACPI_FAILURE (Status))
+        {
+            return (Length);
+        }
+
+        /* Validate the extended checksum over entire RSDP */
+
+        Checksum = AcpiDmGenerateChecksum (Rsdp, sizeof (ACPI_TABLE_RSDP),
+            Rsdp->ExtendedChecksum);
+        if (Checksum != Rsdp->ExtendedChecksum)
+        {
+            AcpiOsPrintf (
+                "/* Incorrect Extended Checksum above, should be 0x%2.2X */\n",
+                Checksum);
+        }
+    }
+
+    return (Length);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiDmDumpRsdt
+ *
+ * PARAMETERS:  Table               - A RSDT
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Format the contents of a RSDT
+ *
+ ******************************************************************************/
+
+void
+AcpiDmDumpRsdt (
+    ACPI_TABLE_HEADER       *Table)
+{
+    UINT32                  *Array;
+    UINT32                  Entries;
+    UINT32                  Offset;
+    UINT32                  i;
+
+
+    /* Point to start of table pointer array */
+
+    Array = ACPI_CAST_PTR (ACPI_TABLE_RSDT, Table)->TableOffsetEntry;
+    Offset = sizeof (ACPI_TABLE_HEADER);
+
+    /* RSDT uses 32-bit pointers */
+
+    Entries = (Table->Length - sizeof (ACPI_TABLE_HEADER)) / sizeof (UINT32);
+
+    for (i = 0; i < Entries; i++)
+    {
+        AcpiDmLineHeader2 (Offset, sizeof (UINT32), "ACPI Table Address", i);
+        AcpiOsPrintf ("%8.8X\n", Array[i]);
+        Offset += sizeof (UINT32);
+    }
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiDmDumpXsdt
+ *
+ * PARAMETERS:  Table               - A XSDT
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Format the contents of a XSDT
+ *
+ ******************************************************************************/
+
+void
+AcpiDmDumpXsdt (
+    ACPI_TABLE_HEADER       *Table)
+{
+    UINT64                  *Array;
+    UINT32                  Entries;
+    UINT32                  Offset;
+    UINT32                  i;
+
+
+    /* Point to start of table pointer array */
+
+    Array = ACPI_CAST_PTR (ACPI_TABLE_XSDT, Table)->TableOffsetEntry;
+    Offset = sizeof (ACPI_TABLE_HEADER);
+
+    /* XSDT uses 64-bit pointers */
+
+    Entries = (Table->Length - sizeof (ACPI_TABLE_HEADER)) / sizeof (UINT64);
+
+    for (i = 0; i < Entries; i++)
+    {
+        AcpiDmLineHeader2 (Offset, sizeof (UINT64), "ACPI Table Address", i);
+        AcpiOsPrintf ("%8.8X%8.8X\n", ACPI_FORMAT_UINT64 (Array[i]));
+        Offset += sizeof (UINT64);
+    }
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiDmDumpFadt
+ *
+ * PARAMETERS:  Table               - A FADT
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Format the contents of a FADT
+ *
+ * NOTE:        We cannot depend on the FADT version to indicate the actual
+ *              contents of the FADT because of BIOS bugs. The table length
+ *              is the only reliable indicator.
+ *
+ ******************************************************************************/
+
+void
+AcpiDmDumpFadt (
+    ACPI_TABLE_HEADER       *Table)
+{
+    ACPI_STATUS             Status;
+
+
+    /* Always dump the minimum FADT revision 1 fields (ACPI 1.0) */
+
+    Status = AcpiDmDumpTable (Table->Length, 0, Table, 0,
+        AcpiDmTableInfoFadt1);
+    if (ACPI_FAILURE (Status))
+    {
+        return;
+    }
+
+    /* Check for FADT revision 2 fields (ACPI 1.0B MS extensions) */
+
+    if ((Table->Length > ACPI_FADT_V1_SIZE) &&
+        (Table->Length <= ACPI_FADT_V2_SIZE))
+    {
+        Status = AcpiDmDumpTable (Table->Length, 0, Table, 0,
+            AcpiDmTableInfoFadt2);
+        if (ACPI_FAILURE (Status))
+        {
+            return;
+        }
+    }
+
+    /* Check for FADT revision 3/4 fields and up (ACPI 2.0+ extended data) */
+
+    else if (Table->Length > ACPI_FADT_V2_SIZE)
+    {
+        Status = AcpiDmDumpTable (Table->Length, 0, Table, 0,
+            AcpiDmTableInfoFadt3);
+        if (ACPI_FAILURE (Status))
+        {
+            return;
+        }
+
+        /* Check for FADT revision 5 fields and up (ACPI 5.0+) */
+
+        if (Table->Length > ACPI_FADT_V3_SIZE)
+        {
+            Status = AcpiDmDumpTable (Table->Length, 0, Table, 0,
+                AcpiDmTableInfoFadt5);
+            if (ACPI_FAILURE (Status))
+            {
+                return;
+            }
+        }
+
+        /* Check for FADT revision 6 fields and up (ACPI 6.0+) */
+
+        if (Table->Length > ACPI_FADT_V3_SIZE)
+        {
+            Status = AcpiDmDumpTable (Table->Length, 0, Table, 0,
+                AcpiDmTableInfoFadt6);
+            if (ACPI_FAILURE (Status))
+            {
+                return;
+            }
+        }
+    }
+
+    /* Validate various fields in the FADT, including length */
+
+    AcpiTbCreateLocalFadt (Table, Table->Length);
+
+    /* Validate FADT length against the revision */
+
+    AcpiDmValidateFadtLength (Table->Revision, Table->Length);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiDmValidateFadtLength
+ *
+ * PARAMETERS:  Revision            - FADT revision (Header->Revision)
+ *              Length              - FADT length (Header->Length
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Check the FADT revision against the expected table length for
+ *              that revision. Issue a warning if the length is not what was
+ *              expected. This seems to be such a common BIOS bug that the
+ *              FADT revision has been rendered virtually meaningless.
+ *
+ ******************************************************************************/
+
+static void
+AcpiDmValidateFadtLength (
+    UINT32                  Revision,
+    UINT32                  Length)
+{
+    UINT32                  ExpectedLength;
+
+
+    switch (Revision)
+    {
+    case 0:
+
+        AcpiOsPrintf ("// ACPI Warning: Invalid FADT revision: 0\n");
+        return;
+
+    case 1:
+
+        ExpectedLength = ACPI_FADT_V1_SIZE;
+        break;
+
+    case 2:
+
+        ExpectedLength = ACPI_FADT_V2_SIZE;
+        break;
+
+    case 3:
+    case 4:
+
+        ExpectedLength = ACPI_FADT_V3_SIZE;
+        break;
+
+    case 5:
+
+        ExpectedLength = ACPI_FADT_V5_SIZE;
+        break;
+
+    default:
+
+        return;
+    }
+
+    if (Length == ExpectedLength)
+    {
+        return;
+    }
+
+    AcpiOsPrintf (
+        "\n// ACPI Warning: FADT revision %X does not match length: "
+        "found %X expected %X\n",
+        Revision, Length, ExpectedLength);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiDmDumpAsf
+ *
+ * PARAMETERS:  Table               - A ASF table
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Format the contents of a ASF table
+ *
+ ******************************************************************************/
+
+void
+AcpiDmDumpAsf (
+    ACPI_TABLE_HEADER       *Table)
+{
+    ACPI_STATUS             Status;
+    UINT32                  Offset = sizeof (ACPI_TABLE_HEADER);
+    ACPI_ASF_INFO           *SubTable;
+    ACPI_DMTABLE_INFO       *InfoTable;
+    ACPI_DMTABLE_INFO       *DataInfoTable = NULL;
+    UINT8                   *DataTable = NULL;
+    UINT32                  DataCount = 0;
+    UINT32                  DataLength = 0;
+    UINT32                  DataOffset = 0;
+    UINT32                  i;
+    UINT8                   Type;
+
+
+    /* No main table, only subtables */
+
+    SubTable = ACPI_ADD_PTR (ACPI_ASF_INFO, Table, Offset);
+    while (Offset < Table->Length)
+    {
+        /* Common subtable header */
+
+        Status = AcpiDmDumpTable (Table->Length, Offset, SubTable,
+            SubTable->Header.Length, AcpiDmTableInfoAsfHdr);
+        if (ACPI_FAILURE (Status))
+        {
+            return;
+        }
+
+        /* The actual type is the lower 7 bits of Type */
+
+        Type = (UINT8) (SubTable->Header.Type & 0x7F);
+
+        switch (Type)
+        {
+        case ACPI_ASF_TYPE_INFO:
+
+            InfoTable = AcpiDmTableInfoAsf0;
+            break;
+
+        case ACPI_ASF_TYPE_ALERT:
+
+            InfoTable = AcpiDmTableInfoAsf1;
+            DataInfoTable = AcpiDmTableInfoAsf1a;
+            DataTable = ACPI_ADD_PTR (UINT8, SubTable, sizeof (ACPI_ASF_ALERT));
+            DataCount = ACPI_CAST_PTR (ACPI_ASF_ALERT, SubTable)->Alerts;
+            DataLength = ACPI_CAST_PTR (ACPI_ASF_ALERT, SubTable)->DataLength;
+            DataOffset = Offset + sizeof (ACPI_ASF_ALERT);
+            break;
+
+        case ACPI_ASF_TYPE_CONTROL:
+
+            InfoTable = AcpiDmTableInfoAsf2;
+            DataInfoTable = AcpiDmTableInfoAsf2a;
+            DataTable = ACPI_ADD_PTR (UINT8, SubTable, sizeof (ACPI_ASF_REMOTE));
+            DataCount = ACPI_CAST_PTR (ACPI_ASF_REMOTE, SubTable)->Controls;
+            DataLength = ACPI_CAST_PTR (ACPI_ASF_REMOTE, SubTable)->DataLength;
+            DataOffset = Offset + sizeof (ACPI_ASF_REMOTE);
+            break;
+
+        case ACPI_ASF_TYPE_BOOT:
+
+            InfoTable = AcpiDmTableInfoAsf3;
+            break;
+
+        case ACPI_ASF_TYPE_ADDRESS:
+
+            InfoTable = AcpiDmTableInfoAsf4;
+            DataTable = ACPI_ADD_PTR (UINT8, SubTable, sizeof (ACPI_ASF_ADDRESS));
+            DataLength = ACPI_CAST_PTR (ACPI_ASF_ADDRESS, SubTable)->Devices;
+            DataOffset = Offset + sizeof (ACPI_ASF_ADDRESS);
+            break;
+
+        default:
+
+            AcpiOsPrintf ("\n**** Unknown ASF subtable type 0x%X\n",
+                SubTable->Header.Type);
+            return;
+        }
+
+        Status = AcpiDmDumpTable (Table->Length, Offset, SubTable,
+            SubTable->Header.Length, InfoTable);
+        if (ACPI_FAILURE (Status))
+        {
+            return;
+        }
+
+        /* Dump variable-length extra data */
+
+        switch (Type)
+        {
+        case ACPI_ASF_TYPE_ALERT:
+        case ACPI_ASF_TYPE_CONTROL:
+
+            for (i = 0; i < DataCount; i++)
+            {
+                AcpiOsPrintf ("\n");
+                Status = AcpiDmDumpTable (Table->Length, DataOffset,
+                    DataTable, DataLength, DataInfoTable);
+                if (ACPI_FAILURE (Status))
+                {
+                    return;
+                }
+
+                DataTable = ACPI_ADD_PTR (UINT8, DataTable, DataLength);
+                DataOffset += DataLength;
+            }
+            break;
+
+        case ACPI_ASF_TYPE_ADDRESS:
+
+            for (i = 0; i < DataLength; i++)
+            {
+                if (!(i % 16))
+                {
+                    AcpiDmLineHeader (DataOffset, 1, "Addresses");
+                }
+
+                AcpiOsPrintf ("%2.2X ", *DataTable);
+                DataTable++;
+                DataOffset++;
+
+                if (DataOffset > Table->Length)
+                {
+                    AcpiOsPrintf (
+                        "**** ACPI table terminates in the middle of a "
+                        "data structure! (ASF! table)\n");
+                    return;
+                }
+            }
+
+            AcpiOsPrintf ("\n");
+            break;
+
+        default:
+
+            break;
+        }
+
+        AcpiOsPrintf ("\n");
+
+        /* Point to next subtable */
+
+        if (!SubTable->Header.Length)
+        {
+            AcpiOsPrintf ("Invalid zero subtable header length\n");
+            return;
+        }
+
+        Offset += SubTable->Header.Length;
+        SubTable = ACPI_ADD_PTR (ACPI_ASF_INFO, SubTable,
+            SubTable->Header.Length);
+    }
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiDmDumpCpep
+ *
+ * PARAMETERS:  Table               - A CPEP table
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Format the contents of a CPEP. This table type consists
+ *              of an open-ended number of subtables.
+ *
+ ******************************************************************************/
+
+void
+AcpiDmDumpCpep (
+    ACPI_TABLE_HEADER       *Table)
+{
+    ACPI_STATUS             Status;
+    ACPI_CPEP_POLLING       *SubTable;
+    UINT32                  Length = Table->Length;
+    UINT32                  Offset = sizeof (ACPI_TABLE_CPEP);
+
+
+    /* Main table */
+
+    Status = AcpiDmDumpTable (Length, 0, Table, 0, AcpiDmTableInfoCpep);
+    if (ACPI_FAILURE (Status))
+    {
+        return;
+    }
+
+    /* Subtables */
+
+    SubTable = ACPI_ADD_PTR (ACPI_CPEP_POLLING, Table, Offset);
+    while (Offset < Table->Length)
+    {
+        AcpiOsPrintf ("\n");
+        Status = AcpiDmDumpTable (Length, Offset, SubTable,
+            SubTable->Header.Length, AcpiDmTableInfoCpep0);
+        if (ACPI_FAILURE (Status))
+        {
+            return;
+        }
+
+        /* Point to next subtable */
+
+        Offset += SubTable->Header.Length;
+        SubTable = ACPI_ADD_PTR (ACPI_CPEP_POLLING, SubTable,
+            SubTable->Header.Length);
+    }
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiDmDumpCsrt
+ *
+ * PARAMETERS:  Table               - A CSRT table
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Format the contents of a CSRT. This table type consists
+ *              of an open-ended number of subtables.
+ *
+ ******************************************************************************/
+
+void
+AcpiDmDumpCsrt (
+    ACPI_TABLE_HEADER       *Table)
+{
+    ACPI_STATUS             Status;
+    ACPI_CSRT_GROUP         *SubTable;
+    ACPI_CSRT_SHARED_INFO   *SharedInfoTable;
+    ACPI_CSRT_DESCRIPTOR    *SubSubTable;
+    UINT32                  Length = Table->Length;
+    UINT32                  Offset = sizeof (ACPI_TABLE_CSRT);
+    UINT32                  SubOffset;
+    UINT32                  SubSubOffset;
+    UINT32                  InfoLength;
+
+
+    /* The main table only contains the ACPI header, thus already handled */
+
+    /* Subtables (Resource Groups) */
+
+    SubTable = ACPI_ADD_PTR (ACPI_CSRT_GROUP, Table, Offset);
+    while (Offset < Table->Length)
+    {
+        /* Resource group subtable */
+
+        AcpiOsPrintf ("\n");
+        Status = AcpiDmDumpTable (Length, Offset, SubTable,
+            SubTable->Length, AcpiDmTableInfoCsrt0);
+        if (ACPI_FAILURE (Status))
+        {
+            return;
+        }
+
+        /* Shared info subtable (One per resource group) */
+
+        SubOffset = sizeof (ACPI_CSRT_GROUP);
+        SharedInfoTable = ACPI_ADD_PTR (ACPI_CSRT_SHARED_INFO, Table,
+            Offset + SubOffset);
+
+        AcpiOsPrintf ("\n");
+        Status = AcpiDmDumpTable (Length, Offset + SubOffset, SharedInfoTable,
+            sizeof (ACPI_CSRT_SHARED_INFO), AcpiDmTableInfoCsrt1);
+        if (ACPI_FAILURE (Status))
+        {
+            return;
+        }
+
+        SubOffset += SubTable->SharedInfoLength;
+
+        /* Sub-Subtables (Resource Descriptors) */
+
+        SubSubTable = ACPI_ADD_PTR (ACPI_CSRT_DESCRIPTOR, Table,
+            Offset + SubOffset);
+
+        while ((SubOffset < SubTable->Length) &&
+              ((Offset + SubOffset) < Table->Length))
+        {
+            AcpiOsPrintf ("\n");
+            Status = AcpiDmDumpTable (Length, Offset + SubOffset, SubSubTable,
+                SubSubTable->Length, AcpiDmTableInfoCsrt2);
+            if (ACPI_FAILURE (Status))
+            {
+                return;
+            }
+
+            SubSubOffset = sizeof (ACPI_CSRT_DESCRIPTOR);
+
+            /* Resource-specific info buffer */
+
+            InfoLength = SubSubTable->Length - SubSubOffset;
+            if (InfoLength)
+            {
+                Status = AcpiDmDumpTable (Length,
+                    Offset + SubOffset + SubSubOffset, Table,
+                    InfoLength, AcpiDmTableInfoCsrt2a);
+                if (ACPI_FAILURE (Status))
+                {
+                    return;
+                }
+                SubSubOffset += InfoLength;
+            }
+
+            /* Point to next sub-subtable */
+
+            SubOffset += SubSubTable->Length;
+            SubSubTable = ACPI_ADD_PTR (ACPI_CSRT_DESCRIPTOR, SubSubTable,
+                SubSubTable->Length);
+        }
+
+        /* Point to next subtable */
+
+        Offset += SubTable->Length;
+        SubTable = ACPI_ADD_PTR (ACPI_CSRT_GROUP, SubTable,
+            SubTable->Length);
+    }
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiDmDumpDbg2
+ *
+ * PARAMETERS:  Table               - A DBG2 table
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Format the contents of a DBG2. This table type consists
+ *              of an open-ended number of subtables.
+ *
+ ******************************************************************************/
+
+void
+AcpiDmDumpDbg2 (
+    ACPI_TABLE_HEADER       *Table)
+{
+    ACPI_STATUS             Status;
+    ACPI_DBG2_DEVICE        *SubTable;
+    UINT32                  Length = Table->Length;
+    UINT32                  Offset = sizeof (ACPI_TABLE_DBG2);
+    UINT32                  i;
+    UINT32                  ArrayOffset;
+    UINT32                  AbsoluteOffset;
+    UINT8                   *Array;
+
+
+    /* Main table */
+
+    Status = AcpiDmDumpTable (Length, 0, Table, 0, AcpiDmTableInfoDbg2);
+    if (ACPI_FAILURE (Status))
+    {
+        return;
+    }
+
+    /* Subtables */
+
+    SubTable = ACPI_ADD_PTR (ACPI_DBG2_DEVICE, Table, Offset);
+    while (Offset < Table->Length)
+    {
+        AcpiOsPrintf ("\n");
+        Status = AcpiDmDumpTable (Length, Offset, SubTable,
+            SubTable->Length, AcpiDmTableInfoDbg2Device);
+        if (ACPI_FAILURE (Status))
+        {
+            return;
+        }
+
+        /* Dump the BaseAddress array */
+
+        for (i = 0; i < SubTable->RegisterCount; i++)
+        {
+            ArrayOffset = SubTable->BaseAddressOffset +
+                (sizeof (ACPI_GENERIC_ADDRESS) * i);
+            AbsoluteOffset = Offset + ArrayOffset;
+            Array = (UINT8 *) SubTable + ArrayOffset;
+
+            Status = AcpiDmDumpTable (Length, AbsoluteOffset, Array,
+                SubTable->Length, AcpiDmTableInfoDbg2Addr);
+            if (ACPI_FAILURE (Status))
+            {
+                return;
+            }
+        }
+
+        /* Dump the AddressSize array */
+
+        for (i = 0; i < SubTable->RegisterCount; i++)
+        {
+            ArrayOffset = SubTable->AddressSizeOffset +
+                (sizeof (UINT32) * i);
+            AbsoluteOffset = Offset + ArrayOffset;
+            Array = (UINT8 *) SubTable + ArrayOffset;
+
+            Status = AcpiDmDumpTable (Length, AbsoluteOffset, Array,
+                SubTable->Length, AcpiDmTableInfoDbg2Size);
+            if (ACPI_FAILURE (Status))
+            {
+                return;
+            }
+        }
+
+        /* Dump the Namestring (required) */
+
+        AcpiOsPrintf ("\n");
+        ArrayOffset = SubTable->NamepathOffset;
+        AbsoluteOffset = Offset + ArrayOffset;
+        Array = (UINT8 *) SubTable + ArrayOffset;
+
+        Status = AcpiDmDumpTable (Length, AbsoluteOffset, Array,
+            SubTable->Length, AcpiDmTableInfoDbg2Name);
+        if (ACPI_FAILURE (Status))
+        {
+            return;
+        }
+
+        /* Dump the OemData (optional) */
+
+        if (SubTable->OemDataOffset)
+        {
+            Status = AcpiDmDumpTable (Length, Offset + SubTable->OemDataOffset,
+                Table, SubTable->OemDataLength,
+                AcpiDmTableInfoDbg2OemData);
+            if (ACPI_FAILURE (Status))
+            {
+                return;
+            }
+        }
+
+        /* Point to next subtable */
+
+        Offset += SubTable->Length;
+        SubTable = ACPI_ADD_PTR (ACPI_DBG2_DEVICE, SubTable,
+            SubTable->Length);
+    }
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiDmDumpDmar
+ *
+ * PARAMETERS:  Table               - A DMAR table
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Format the contents of a DMAR. This table type consists
+ *              of an open-ended number of subtables.
+ *
+ ******************************************************************************/
+
+void
+AcpiDmDumpDmar (
+    ACPI_TABLE_HEADER       *Table)
+{
+    ACPI_STATUS             Status;
+    ACPI_DMAR_HEADER        *SubTable;
+    UINT32                  Length = Table->Length;
+    UINT32                  Offset = sizeof (ACPI_TABLE_DMAR);
+    ACPI_DMTABLE_INFO       *InfoTable;
+    ACPI_DMAR_DEVICE_SCOPE  *ScopeTable;
+    UINT32                  ScopeOffset;
+    UINT8                   *PciPath;
+    UINT32                  PathOffset;
+
+
+    /* Main table */
+
+    Status = AcpiDmDumpTable (Length, 0, Table, 0, AcpiDmTableInfoDmar);
+    if (ACPI_FAILURE (Status))
+    {
+        return;
+    }
+
+    /* Subtables */
+
+    SubTable = ACPI_ADD_PTR (ACPI_DMAR_HEADER, Table, Offset);
+    while (Offset < Table->Length)
+    {
+        /* Common subtable header */
+
+        AcpiOsPrintf ("\n");
+        Status = AcpiDmDumpTable (Length, Offset, SubTable,
+            SubTable->Length, AcpiDmTableInfoDmarHdr);
+        if (ACPI_FAILURE (Status))
+        {
+            return;
+        }
+
+        AcpiOsPrintf ("\n");
+
+        switch (SubTable->Type)
+        {
+        case ACPI_DMAR_TYPE_HARDWARE_UNIT:
+
+            InfoTable = AcpiDmTableInfoDmar0;
+            ScopeOffset = sizeof (ACPI_DMAR_HARDWARE_UNIT);
+            break;
+
+        case ACPI_DMAR_TYPE_RESERVED_MEMORY:
+
+            InfoTable = AcpiDmTableInfoDmar1;
+            ScopeOffset = sizeof (ACPI_DMAR_RESERVED_MEMORY);
+            break;
+
+        case ACPI_DMAR_TYPE_ROOT_ATS:
+
+            InfoTable = AcpiDmTableInfoDmar2;
+            ScopeOffset = sizeof (ACPI_DMAR_ATSR);
+            break;
+
+        case ACPI_DMAR_TYPE_HARDWARE_AFFINITY:
+
+            InfoTable = AcpiDmTableInfoDmar3;
+            ScopeOffset = sizeof (ACPI_DMAR_RHSA);
+            break;
+
+        case ACPI_DMAR_TYPE_NAMESPACE:
+
+            InfoTable = AcpiDmTableInfoDmar4;
+            ScopeOffset = sizeof (ACPI_DMAR_ANDD);
+            break;
+
+        default:
+
+            AcpiOsPrintf ("\n**** Unknown DMAR subtable type 0x%X\n\n",
+                SubTable->Type);
+            return;
+        }
+
+        Status = AcpiDmDumpTable (Length, Offset, SubTable,
+            SubTable->Length, InfoTable);
+        if (ACPI_FAILURE (Status))
+        {
+            return;
+        }
+
+        /*
+         * Dump the optional device scope entries
+         */
+        if ((SubTable->Type == ACPI_DMAR_TYPE_HARDWARE_AFFINITY) ||
+            (SubTable->Type == ACPI_DMAR_TYPE_NAMESPACE))
+        {
+            /* These types do not support device scopes */
+
+            goto NextSubtable;
+        }
+
+        ScopeTable = ACPI_ADD_PTR (ACPI_DMAR_DEVICE_SCOPE, SubTable, ScopeOffset);
+        while (ScopeOffset < SubTable->Length)
+        {
+            AcpiOsPrintf ("\n");
+            Status = AcpiDmDumpTable (Length, Offset + ScopeOffset, ScopeTable,
+                ScopeTable->Length, AcpiDmTableInfoDmarScope);
+            if (ACPI_FAILURE (Status))
+            {
+                return;
+            }
+            AcpiOsPrintf ("\n");
+
+            /* Dump the PCI Path entries for this device scope */
+
+            PathOffset = sizeof (ACPI_DMAR_DEVICE_SCOPE); /* Path entries start at this offset */
+
+            PciPath = ACPI_ADD_PTR (UINT8, ScopeTable,
+                sizeof (ACPI_DMAR_DEVICE_SCOPE));
+
+            while (PathOffset < ScopeTable->Length)
+            {
+                AcpiDmLineHeader ((PathOffset + ScopeOffset + Offset), 2,
+                    "PCI Path");
+                AcpiOsPrintf ("%2.2X,%2.2X\n", PciPath[0], PciPath[1]);
+
+                /* Point to next PCI Path entry */
+
+                PathOffset += 2;
+                PciPath += 2;
+                AcpiOsPrintf ("\n");
+            }
+
+            /* Point to next device scope entry */
+
+            ScopeOffset += ScopeTable->Length;
+            ScopeTable = ACPI_ADD_PTR (ACPI_DMAR_DEVICE_SCOPE,
+                ScopeTable, ScopeTable->Length);
+        }
+
+NextSubtable:
+        /* Point to next subtable */
+
+        Offset += SubTable->Length;
+        SubTable = ACPI_ADD_PTR (ACPI_DMAR_HEADER, SubTable,
+            SubTable->Length);
+    }
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiDmDumpDrtm
+ *
+ * PARAMETERS:  Table               - A DRTM table
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Format the contents of a DRTM.
+ *
+ ******************************************************************************/
+
+void
+AcpiDmDumpDrtm (
+    ACPI_TABLE_HEADER       *Table)
+{
+    ACPI_STATUS             Status;
+    UINT32                  Offset;
+    ACPI_DRTM_VTABLE_LIST   *DrtmVtl;
+    ACPI_DRTM_RESOURCE_LIST *DrtmRl;
+    ACPI_DRTM_DPS_ID        *DrtmDps;
+    UINT32                  Count;
+
+
+    /* Main table */
+
+    Status = AcpiDmDumpTable (Table->Length, 0, Table, 0,
+        AcpiDmTableInfoDrtm);
+    if (ACPI_FAILURE (Status))
+    {
+        return;
+    }
+
+    Offset = sizeof (ACPI_TABLE_DRTM);
+
+    /* Sub-tables */
+
+    /* Dump ValidatedTable length */
+
+    DrtmVtl = ACPI_ADD_PTR (ACPI_DRTM_VTABLE_LIST, Table, Offset);
+    AcpiOsPrintf ("\n");
+    Status = AcpiDmDumpTable (Table->Length, Offset,
+        DrtmVtl, ACPI_OFFSET (ACPI_DRTM_VTABLE_LIST, ValidatedTables),
+        AcpiDmTableInfoDrtm0);
+    if (ACPI_FAILURE (Status))
+    {
+            return;
+    }
+
+    Offset += ACPI_OFFSET (ACPI_DRTM_VTABLE_LIST, ValidatedTables);
+
+    /* Dump Validated table addresses */
+
+    Count = 0;
+    while ((Offset < Table->Length) &&
+            (DrtmVtl->ValidatedTableCount > Count))
+    {
+        Status = AcpiDmDumpTable (Table->Length, Offset,
+            ACPI_ADD_PTR (void, Table, Offset), sizeof (UINT64),
+            AcpiDmTableInfoDrtm0a);
+        if (ACPI_FAILURE (Status))
+        {
+            return;
+        }
+
+        Offset += sizeof (UINT64);
+        Count++;
+    }
+
+    /* Dump ResourceList length */
+
+    DrtmRl = ACPI_ADD_PTR (ACPI_DRTM_RESOURCE_LIST, Table, Offset);
+    AcpiOsPrintf ("\n");
+    Status = AcpiDmDumpTable (Table->Length, Offset,
+        DrtmRl, ACPI_OFFSET (ACPI_DRTM_RESOURCE_LIST, Resources),
+        AcpiDmTableInfoDrtm1);
+    if (ACPI_FAILURE (Status))
+    {
+        return;
+    }
+
+    Offset += ACPI_OFFSET (ACPI_DRTM_RESOURCE_LIST, Resources);
+
+    /* Dump the Resource List */
+
+    Count = 0;
+    while ((Offset < Table->Length) &&
+           (DrtmRl->ResourceCount > Count))
+    {
+        Status = AcpiDmDumpTable (Table->Length, Offset,
+            ACPI_ADD_PTR (void, Table, Offset),
+            sizeof (ACPI_DRTM_RESOURCE), AcpiDmTableInfoDrtm1a);
+        if (ACPI_FAILURE (Status))
+        {
+            return;
+        }
+
+        Offset += sizeof (ACPI_DRTM_RESOURCE);
+        Count++;
+    }
+
+    /* Dump DPS */
+
+    DrtmDps = ACPI_ADD_PTR (ACPI_DRTM_DPS_ID, Table, Offset);
+    AcpiOsPrintf ("\n");
+    (void) AcpiDmDumpTable (Table->Length, Offset,
+        DrtmDps, sizeof (ACPI_DRTM_DPS_ID), AcpiDmTableInfoDrtm2);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiDmDumpEinj
+ *
+ * PARAMETERS:  Table               - A EINJ table
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Format the contents of a EINJ. This table type consists
+ *              of an open-ended number of subtables.
+ *
+ ******************************************************************************/
+
+void
+AcpiDmDumpEinj (
+    ACPI_TABLE_HEADER       *Table)
+{
+    ACPI_STATUS             Status;
+    ACPI_WHEA_HEADER        *SubTable;
+    UINT32                  Length = Table->Length;
+    UINT32                  Offset = sizeof (ACPI_TABLE_EINJ);
+
+
+    /* Main table */
+
+    Status = AcpiDmDumpTable (Length, 0, Table, 0, AcpiDmTableInfoEinj);
+    if (ACPI_FAILURE (Status))
+    {
+        return;
+    }
+
+    /* Subtables */
+
+    SubTable = ACPI_ADD_PTR (ACPI_WHEA_HEADER, Table, Offset);
+    while (Offset < Table->Length)
+    {
+        AcpiOsPrintf ("\n");
+        Status = AcpiDmDumpTable (Length, Offset, SubTable,
+            sizeof (ACPI_WHEA_HEADER), AcpiDmTableInfoEinj0);
+        if (ACPI_FAILURE (Status))
+        {
+            return;
+        }
+
+        /* Point to next subtable (each subtable is of fixed length) */
+
+        Offset += sizeof (ACPI_WHEA_HEADER);
+        SubTable = ACPI_ADD_PTR (ACPI_WHEA_HEADER, SubTable,
+            sizeof (ACPI_WHEA_HEADER));
+    }
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiDmDumpErst
+ *
+ * PARAMETERS:  Table               - A ERST table
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Format the contents of a ERST. This table type consists
+ *              of an open-ended number of subtables.
+ *
+ ******************************************************************************/
+
+void
+AcpiDmDumpErst (
+    ACPI_TABLE_HEADER       *Table)
+{
+    ACPI_STATUS             Status;
+    ACPI_WHEA_HEADER        *SubTable;
+    UINT32                  Length = Table->Length;
+    UINT32                  Offset = sizeof (ACPI_TABLE_ERST);
+
+
+    /* Main table */
+
+    Status = AcpiDmDumpTable (Length, 0, Table, 0, AcpiDmTableInfoErst);
+    if (ACPI_FAILURE (Status))
+    {
+        return;
+    }
+
+    /* Subtables */
+
+    SubTable = ACPI_ADD_PTR (ACPI_WHEA_HEADER, Table, Offset);
+    while (Offset < Table->Length)
+    {
+        AcpiOsPrintf ("\n");
+        Status = AcpiDmDumpTable (Length, Offset, SubTable,
+            sizeof (ACPI_WHEA_HEADER), AcpiDmTableInfoErst0);
+        if (ACPI_FAILURE (Status))
+        {
+            return;
+        }
+
+        /* Point to next subtable (each subtable is of fixed length) */
+
+        Offset += sizeof (ACPI_WHEA_HEADER);
+        SubTable = ACPI_ADD_PTR (ACPI_WHEA_HEADER, SubTable,
+            sizeof (ACPI_WHEA_HEADER));
+    }
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiDmDumpFpdt
+ *
+ * PARAMETERS:  Table               - A FPDT table
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Format the contents of a FPDT. This table type consists
+ *              of an open-ended number of subtables.
+ *
+ ******************************************************************************/
+
+void
+AcpiDmDumpFpdt (
+    ACPI_TABLE_HEADER       *Table)
+{
+    ACPI_STATUS             Status;
+    ACPI_FPDT_HEADER        *SubTable;
+    UINT32                  Length = Table->Length;
+    UINT32                  Offset = sizeof (ACPI_TABLE_FPDT);
+    ACPI_DMTABLE_INFO       *InfoTable;
+
+
+    /* There is no main table (other than the standard ACPI header) */
+
+    /* Subtables */
+
+    SubTable = ACPI_ADD_PTR (ACPI_FPDT_HEADER, Table, Offset);
+    while (Offset < Table->Length)
+    {
+        /* Common subtable header */
+
+        AcpiOsPrintf ("\n");
+        Status = AcpiDmDumpTable (Length, Offset, SubTable,
+            SubTable->Length, AcpiDmTableInfoFpdtHdr);
+        if (ACPI_FAILURE (Status))
+        {
+            return;
+        }
+
+        switch (SubTable->Type)
+        {
+        case ACPI_FPDT_TYPE_BOOT:
+
+            InfoTable = AcpiDmTableInfoFpdt0;
+            break;
+
+        case ACPI_FPDT_TYPE_S3PERF:
+
+            InfoTable = AcpiDmTableInfoFpdt1;
+            break;
+
+        default:
+
+            AcpiOsPrintf ("\n**** Unknown FPDT subtable type 0x%X\n\n",
+                SubTable->Type);
+
+            /* Attempt to continue */
+
+            if (!SubTable->Length)
+            {
+                AcpiOsPrintf ("Invalid zero length subtable\n");
+                return;
+            }
+            goto NextSubTable;
+        }
+
+        Status = AcpiDmDumpTable (Length, Offset, SubTable,
+            SubTable->Length, InfoTable);
+        if (ACPI_FAILURE (Status))
+        {
+            return;
+        }
+
+NextSubTable:
+        /* Point to next subtable */
+
+        Offset += SubTable->Length;
+        SubTable = ACPI_ADD_PTR (ACPI_FPDT_HEADER, SubTable,
+            SubTable->Length);
+    }
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiDmDumpGtdt
+ *
+ * PARAMETERS:  Table               - A GTDT table
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Format the contents of a GTDT. This table type consists
+ *              of an open-ended number of subtables.
+ *
+ ******************************************************************************/
+
+void
+AcpiDmDumpGtdt (
+    ACPI_TABLE_HEADER       *Table)
+{
+    ACPI_STATUS             Status;
+    ACPI_GTDT_HEADER        *SubTable;
+    UINT32                  Length = Table->Length;
+    UINT32                  Offset = sizeof (ACPI_TABLE_GTDT);
+    ACPI_DMTABLE_INFO       *InfoTable;
+    UINT32                  SubTableLength;
+    UINT32                  GtCount;
+    ACPI_GTDT_TIMER_ENTRY   *GtxTable;
+
+
+    /* Main table */
+
+    Status = AcpiDmDumpTable (Length, 0, Table, 0, AcpiDmTableInfoGtdt);
+    if (ACPI_FAILURE (Status))
+    {
+        return;
+    }
+
+    /* Subtables */
+
+    SubTable = ACPI_ADD_PTR (ACPI_GTDT_HEADER, Table, Offset);
+    while (Offset < Table->Length)
+    {
+        /* Common subtable header */
+
+        AcpiOsPrintf ("\n");
+        Status = AcpiDmDumpTable (Length, Offset, SubTable,
+            SubTable->Length, AcpiDmTableInfoGtdtHdr);
+        if (ACPI_FAILURE (Status))
+        {
+            return;
+        }
+
+        GtCount = 0;
+        switch (SubTable->Type)
+        {
+        case ACPI_GTDT_TYPE_TIMER_BLOCK:
+
+            SubTableLength = sizeof (ACPI_GTDT_TIMER_BLOCK);
+            GtCount = (ACPI_CAST_PTR (ACPI_GTDT_TIMER_BLOCK,
+                SubTable))->TimerCount;
+
+            InfoTable = AcpiDmTableInfoGtdt0;
+            break;
+
+        case ACPI_GTDT_TYPE_WATCHDOG:
+
+            SubTableLength = sizeof (ACPI_GTDT_WATCHDOG);
+
+            InfoTable = AcpiDmTableInfoGtdt1;
+            break;
+
+        default:
+
+            /* Cannot continue on unknown type - no length */
+
+            AcpiOsPrintf ("\n**** Unknown GTDT subtable type 0x%X\n",
+                SubTable->Type);
+            return;
+        }
+
+        Status = AcpiDmDumpTable (Length, Offset, SubTable,
+            SubTable->Length, InfoTable);
+        if (ACPI_FAILURE (Status))
+        {
+            return;
+        }
+
+        /* Point to end of current subtable (each subtable above is of fixed length) */
+
+        Offset += SubTableLength;
+
+        /* If there are any Gt Timer Blocks from above, dump them now */
+
+        if (GtCount)
+        {
+            GtxTable = ACPI_ADD_PTR (
+                ACPI_GTDT_TIMER_ENTRY, SubTable, SubTableLength);
+            SubTableLength += GtCount * sizeof (ACPI_GTDT_TIMER_ENTRY);
+
+            while (GtCount)
+            {
+                AcpiOsPrintf ("\n");
+                Status = AcpiDmDumpTable (Length, Offset, GtxTable,
+                    sizeof (ACPI_GTDT_TIMER_ENTRY), AcpiDmTableInfoGtdt0a);
+                if (ACPI_FAILURE (Status))
+                {
+                    return;
+                }
+                Offset += sizeof (ACPI_GTDT_TIMER_ENTRY);
+                GtxTable++;
+                GtCount--;
+            }
+        }
+
+        /* Point to next subtable */
+
+        SubTable = ACPI_ADD_PTR (ACPI_GTDT_HEADER, SubTable, SubTableLength);
+    }
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiDmDumpHest
+ *
+ * PARAMETERS:  Table               - A HEST table
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Format the contents of a HEST. This table type consists
+ *              of an open-ended number of subtables.
+ *
+ ******************************************************************************/
+
+void
+AcpiDmDumpHest (
+    ACPI_TABLE_HEADER       *Table)
+{
+    ACPI_STATUS             Status;
+    ACPI_HEST_HEADER        *SubTable;
+    UINT32                  Length = Table->Length;
+    UINT32                  Offset = sizeof (ACPI_TABLE_HEST);
+    ACPI_DMTABLE_INFO       *InfoTable;
+    UINT32                  SubTableLength;
+    UINT32                  BankCount;
+    ACPI_HEST_IA_ERROR_BANK *BankTable;
+
+
+    /* Main table */
+
+    Status = AcpiDmDumpTable (Length, 0, Table, 0, AcpiDmTableInfoHest);
+    if (ACPI_FAILURE (Status))
+    {
+        return;
+    }
+
+    /* Subtables */
+
+    SubTable = ACPI_ADD_PTR (ACPI_HEST_HEADER, Table, Offset);
+    while (Offset < Table->Length)
+    {
+        BankCount = 0;
+        switch (SubTable->Type)
+        {
+        case ACPI_HEST_TYPE_IA32_CHECK:
+
+            InfoTable = AcpiDmTableInfoHest0;
+            SubTableLength = sizeof (ACPI_HEST_IA_MACHINE_CHECK);
+            BankCount = (ACPI_CAST_PTR (ACPI_HEST_IA_MACHINE_CHECK,
+                SubTable))->NumHardwareBanks;
+            break;
+
+        case ACPI_HEST_TYPE_IA32_CORRECTED_CHECK:
+
+            InfoTable = AcpiDmTableInfoHest1;
+            SubTableLength = sizeof (ACPI_HEST_IA_CORRECTED);
+            BankCount = (ACPI_CAST_PTR (ACPI_HEST_IA_CORRECTED,
+                SubTable))->NumHardwareBanks;
+            break;
+
+        case ACPI_HEST_TYPE_IA32_NMI:
+
+            InfoTable = AcpiDmTableInfoHest2;
+            SubTableLength = sizeof (ACPI_HEST_IA_NMI);
+            break;
+
+        case ACPI_HEST_TYPE_AER_ROOT_PORT:
+
+            InfoTable = AcpiDmTableInfoHest6;
+            SubTableLength = sizeof (ACPI_HEST_AER_ROOT);
+            break;
+
+        case ACPI_HEST_TYPE_AER_ENDPOINT:
+
+            InfoTable = AcpiDmTableInfoHest7;
+            SubTableLength = sizeof (ACPI_HEST_AER);
+            break;
+
+        case ACPI_HEST_TYPE_AER_BRIDGE:
+
+            InfoTable = AcpiDmTableInfoHest8;
+            SubTableLength = sizeof (ACPI_HEST_AER_BRIDGE);
+            break;
+
+        case ACPI_HEST_TYPE_GENERIC_ERROR:
+
+            InfoTable = AcpiDmTableInfoHest9;
+            SubTableLength = sizeof (ACPI_HEST_GENERIC);
+            break;
+
+        case ACPI_HEST_TYPE_GENERIC_ERROR_V2:
+
+            InfoTable = AcpiDmTableInfoHest10;
+            SubTableLength = sizeof (ACPI_HEST_GENERIC_V2);
+            break;
+
+        default:
+
+            /* Cannot continue on unknown type - no length */
+
+            AcpiOsPrintf ("\n**** Unknown HEST subtable type 0x%X\n",
+                SubTable->Type);
+            return;
+        }
+
+        AcpiOsPrintf ("\n");
+        Status = AcpiDmDumpTable (Length, Offset, SubTable,
+            SubTableLength, InfoTable);
+        if (ACPI_FAILURE (Status))
+        {
+            return;
+        }
+
+        /* Point to end of current subtable (each subtable above is of fixed length) */
+
+        Offset += SubTableLength;
+
+        /* If there are any (fixed-length) Error Banks from above, dump them now */
+
+        if (BankCount)
+        {
+            BankTable = ACPI_ADD_PTR (ACPI_HEST_IA_ERROR_BANK, SubTable,
+                SubTableLength);
+            SubTableLength += BankCount * sizeof (ACPI_HEST_IA_ERROR_BANK);
+
+            while (BankCount)
+            {
+                AcpiOsPrintf ("\n");
+                Status = AcpiDmDumpTable (Length, Offset, BankTable,
+                    sizeof (ACPI_HEST_IA_ERROR_BANK), AcpiDmTableInfoHestBank);
+                if (ACPI_FAILURE (Status))
+                {
+                    return;
+                }
+
+                Offset += sizeof (ACPI_HEST_IA_ERROR_BANK);
+                BankTable++;
+                BankCount--;
+            }
+        }
+
+        /* Point to next subtable */
+
+        SubTable = ACPI_ADD_PTR (ACPI_HEST_HEADER, SubTable, SubTableLength);
+    }
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiDmDumpIort
+ *
+ * PARAMETERS:  Table               - A IORT table
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Format the contents of a IORT
+ *
+ ******************************************************************************/
+
+void
+AcpiDmDumpIort (
+    ACPI_TABLE_HEADER       *Table)
+{
+    ACPI_STATUS             Status;
+    ACPI_TABLE_IORT         *Iort;
+    ACPI_IORT_NODE          *IortNode;
+    ACPI_IORT_ITS_GROUP     *IortItsGroup = NULL;
+    ACPI_IORT_SMMU          *IortSmmu = NULL;
+    UINT32                  Offset;
+    UINT32                  NodeOffset;
+    UINT32                  Length;
+    ACPI_DMTABLE_INFO       *InfoTable;
+    char                    *String;
+    UINT32                  i;
+
+
+    /* Main table */
+
+    Status = AcpiDmDumpTable (Table->Length, 0, Table, 0, AcpiDmTableInfoIort);
+    if (ACPI_FAILURE (Status))
+    {
+        return;
+    }
+
+    Iort = ACPI_CAST_PTR (ACPI_TABLE_IORT, Table);
+    Offset = sizeof (ACPI_TABLE_IORT);
+
+    /* Dump the OptionalPadding (optional) */
+
+    if (Iort->NodeOffset > Offset)
+    {
+        Status = AcpiDmDumpTable (Table->Length, Offset, Table,
+            Iort->NodeOffset - Offset, AcpiDmTableInfoIortPad);
+        if (ACPI_FAILURE (Status))
+        {
+            return;
+        }
+    }
+
+    Offset = Iort->NodeOffset;
+    while (Offset < Table->Length)
+    {
+        /* Common subtable header */
+
+        IortNode = ACPI_ADD_PTR (ACPI_IORT_NODE, Table, Offset);
+        AcpiOsPrintf ("\n");
+        Length = ACPI_OFFSET (ACPI_IORT_NODE, NodeData);
+        Status = AcpiDmDumpTable (Table->Length, Offset,
+            IortNode, Length, AcpiDmTableInfoIortHdr);
+        if (ACPI_FAILURE (Status))
+        {
+            return;
+        }
+
+        NodeOffset = Length;
+
+        switch (IortNode->Type)
+        {
+        case ACPI_IORT_NODE_ITS_GROUP:
+
+            InfoTable = AcpiDmTableInfoIort0;
+            Length = ACPI_OFFSET (ACPI_IORT_ITS_GROUP, Identifiers);
+            IortItsGroup = ACPI_ADD_PTR (ACPI_IORT_ITS_GROUP, IortNode, NodeOffset);
+            break;
+
+        case ACPI_IORT_NODE_NAMED_COMPONENT:
+
+            InfoTable = AcpiDmTableInfoIort1;
+            Length = ACPI_OFFSET (ACPI_IORT_NAMED_COMPONENT, DeviceName);
+            String = ACPI_ADD_PTR (char, IortNode, NodeOffset + Length);
+            Length += strlen (String) + 1;
+            break;
+
+        case ACPI_IORT_NODE_PCI_ROOT_COMPLEX:
+
+            InfoTable = AcpiDmTableInfoIort2;
+            Length = IortNode->Length - NodeOffset;
+            break;
+
+        case ACPI_IORT_NODE_SMMU:
+
+            InfoTable = AcpiDmTableInfoIort3;
+            Length = ACPI_OFFSET (ACPI_IORT_SMMU, Interrupts);
+            IortSmmu = ACPI_ADD_PTR (ACPI_IORT_SMMU, IortNode, NodeOffset);
+            break;
+
+        case ACPI_IORT_NODE_SMMU_V3:
+
+            InfoTable = AcpiDmTableInfoIort4;
+            Length = IortNode->Length - NodeOffset;
+            break;
+
+        default:
+
+            AcpiOsPrintf ("\n**** Unknown IORT node type 0x%X\n",
+                IortNode->Type);
+
+            /* Attempt to continue */
+
+            if (!IortNode->Length)
+            {
+                AcpiOsPrintf ("Invalid zero length IORT node\n");
+                return;
+            }
+            goto NextSubTable;
+        }
+
+        /* Dump the node subtable header */
+
+        AcpiOsPrintf ("\n");
+        Status = AcpiDmDumpTable (Table->Length, Offset + NodeOffset,
+            ACPI_ADD_PTR (ACPI_IORT_NODE, IortNode, NodeOffset),
+            Length, InfoTable);
+        if (ACPI_FAILURE (Status))
+        {
+            return;
+        }
+
+        NodeOffset += Length;
+
+        /* Dump the node specific data */
+
+        switch (IortNode->Type)
+        {
+        case ACPI_IORT_NODE_ITS_GROUP:
+
+            /* Validate IortItsGroup to avoid compiler warnings */
+
+            if (IortItsGroup)
+            {
+                for (i = 0; i < IortItsGroup->ItsCount; i++)
+                {
+                    Status = AcpiDmDumpTable (Table->Length, Offset + NodeOffset,
+                        ACPI_ADD_PTR (ACPI_IORT_NODE, IortNode, NodeOffset),
+                        4, AcpiDmTableInfoIort0a);
+                    NodeOffset += 4;
+                }
+            }
+            break;
+
+        case ACPI_IORT_NODE_NAMED_COMPONENT:
+
+            /* Dump the Padding (optional) */
+
+            if (IortNode->Length > NodeOffset)
+            {
+                Status = AcpiDmDumpTable (Table->Length, Offset + NodeOffset,
+                    Table, IortNode->Length - NodeOffset,
+                    AcpiDmTableInfoIort1a);
+                if (ACPI_FAILURE (Status))
+                {
+                    return;
+                }
+            }
+            break;
+
+        case ACPI_IORT_NODE_SMMU:
+
+            AcpiOsPrintf ("\n");
+
+            /* Validate IortSmmu to avoid compiler warnings */
+
+            if (IortSmmu)
+            {
+                Length = 2 * sizeof (UINT64);
+                NodeOffset = IortSmmu->GlobalInterruptOffset;
+                Status = AcpiDmDumpTable (Table->Length, Offset + NodeOffset,
+                    ACPI_ADD_PTR (ACPI_IORT_NODE, IortNode, NodeOffset),
+                    Length, AcpiDmTableInfoIort3a);
+                if (ACPI_FAILURE (Status))
+                {
+                    return;
+                }
+
+                NodeOffset = IortSmmu->ContextInterruptOffset;
+                for (i = 0; i < IortSmmu->ContextInterruptCount; i++)
+                {
+                    Status = AcpiDmDumpTable (Table->Length, Offset + NodeOffset,
+                        ACPI_ADD_PTR (ACPI_IORT_NODE, IortNode, NodeOffset),
+                        8, AcpiDmTableInfoIort3b);
+                    if (ACPI_FAILURE (Status))
+                    {
+                        return;
+                    }
+
+                    NodeOffset += 8;
+                }
+
+                NodeOffset = IortSmmu->PmuInterruptOffset;
+                for (i = 0; i < IortSmmu->PmuInterruptCount; i++)
+                {
+                    Status = AcpiDmDumpTable (Table->Length, Offset + NodeOffset,
+                        ACPI_ADD_PTR (ACPI_IORT_NODE, IortNode, NodeOffset),
+                        8, AcpiDmTableInfoIort3c);
+                    if (ACPI_FAILURE (Status))
+                    {
+                        return;
+                    }
+
+                    NodeOffset += 8;
+                }
+            }
+            break;
+
+        default:
+
+            break;
+        }
+
+        /* Dump the ID mappings */
+
+        NodeOffset = IortNode->MappingOffset;
+        for (i = 0; i < IortNode->MappingCount; i++)
+        {
+            AcpiOsPrintf ("\n");
+            Length = sizeof (ACPI_IORT_ID_MAPPING);
+            Status = AcpiDmDumpTable (Table->Length, Offset + NodeOffset,
+                ACPI_ADD_PTR (ACPI_IORT_NODE, IortNode, NodeOffset),
+                Length, AcpiDmTableInfoIortMap);
+            if (ACPI_FAILURE (Status))
+            {
+                return;
+            }
+
+            NodeOffset += Length;
+        }
+
+NextSubTable:
+        /* Point to next node subtable */
+
+        Offset += IortNode->Length;
+        IortNode = ACPI_ADD_PTR (ACPI_IORT_NODE, IortNode, IortNode->Length);
+    }
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiDmDumpIvrs
+ *
+ * PARAMETERS:  Table               - A IVRS table
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Format the contents of a IVRS
+ *
+ ******************************************************************************/
+
+static UINT8 EntrySizes[] = {4,8,16,32};
+
+void
+AcpiDmDumpIvrs (
+    ACPI_TABLE_HEADER       *Table)
+{
+    ACPI_STATUS             Status;
+    UINT32                  Offset = sizeof (ACPI_TABLE_IVRS);
+    UINT32                  EntryOffset;
+    UINT32                  EntryLength;
+    UINT32                  EntryType;
+    ACPI_IVRS_DE_HEADER     *DeviceEntry;
+    ACPI_IVRS_HEADER        *SubTable;
+    ACPI_DMTABLE_INFO       *InfoTable;
+
+
+    /* Main table */
+
+    Status = AcpiDmDumpTable (Table->Length, 0, Table, 0, AcpiDmTableInfoIvrs);
+    if (ACPI_FAILURE (Status))
+    {
+        return;
+    }
+
+    /* Subtables */
+
+    SubTable = ACPI_ADD_PTR (ACPI_IVRS_HEADER, Table, Offset);
+    while (Offset < Table->Length)
+    {
+        /* Common subtable header */
+
+        AcpiOsPrintf ("\n");
+        Status = AcpiDmDumpTable (Table->Length, Offset, SubTable,
+            SubTable->Length, AcpiDmTableInfoIvrsHdr);
+        if (ACPI_FAILURE (Status))
+        {
+            return;
+        }
+
+        switch (SubTable->Type)
+        {
+        case ACPI_IVRS_TYPE_HARDWARE:
+
+            InfoTable = AcpiDmTableInfoIvrs0;
+            break;
+
+        case ACPI_IVRS_TYPE_MEMORY1:
+        case ACPI_IVRS_TYPE_MEMORY2:
+        case ACPI_IVRS_TYPE_MEMORY3:
+
+            InfoTable = AcpiDmTableInfoIvrs1;
+            break;
+
+        default:
+
+            AcpiOsPrintf ("\n**** Unknown IVRS subtable type 0x%X\n",
+                SubTable->Type);
+
+            /* Attempt to continue */
+
+            if (!SubTable->Length)
+            {
+                AcpiOsPrintf ("Invalid zero length subtable\n");
+                return;
+            }
+            goto NextSubTable;
+        }
+
+        /* Dump the subtable */
+
+        AcpiOsPrintf ("\n");
+        Status = AcpiDmDumpTable (Table->Length, Offset, SubTable,
+            SubTable->Length, InfoTable);
+        if (ACPI_FAILURE (Status))
+        {
+            return;
+        }
+
+        /* The hardware subtable can contain multiple device entries */
+
+        if (SubTable->Type == ACPI_IVRS_TYPE_HARDWARE)
+        {
+            EntryOffset = Offset + sizeof (ACPI_IVRS_HARDWARE);
+            DeviceEntry = ACPI_ADD_PTR (ACPI_IVRS_DE_HEADER, SubTable,
+                sizeof (ACPI_IVRS_HARDWARE));
+
+            while (EntryOffset < (Offset + SubTable->Length))
+            {
+                AcpiOsPrintf ("\n");
+                /*
+                 * Upper 2 bits of Type encode the length of the device entry
+                 *
+                 * 00 = 4 byte
+                 * 01 = 8 byte
+                 * 10 = 16 byte - currently no entries defined
+                 * 11 = 32 byte - currently no entries defined
+                 */
+                EntryType = DeviceEntry->Type;
+                EntryLength = EntrySizes [EntryType >> 6];
+
+                switch (EntryType)
+                {
+                /* 4-byte device entries */
+
+                case ACPI_IVRS_TYPE_PAD4:
+                case ACPI_IVRS_TYPE_ALL:
+                case ACPI_IVRS_TYPE_SELECT:
+                case ACPI_IVRS_TYPE_START:
+                case ACPI_IVRS_TYPE_END:
+
+                    InfoTable = AcpiDmTableInfoIvrs4;
+                    break;
+
+                /* 8-byte entries, type A */
+
+                case ACPI_IVRS_TYPE_ALIAS_SELECT:
+                case ACPI_IVRS_TYPE_ALIAS_START:
+
+                    InfoTable = AcpiDmTableInfoIvrs8a;
+                    break;
+
+                /* 8-byte entries, type B */
+
+                case ACPI_IVRS_TYPE_PAD8:
+                case ACPI_IVRS_TYPE_EXT_SELECT:
+                case ACPI_IVRS_TYPE_EXT_START:
+
+                    InfoTable = AcpiDmTableInfoIvrs8b;
+                    break;
+
+                /* 8-byte entries, type C */
+
+                case ACPI_IVRS_TYPE_SPECIAL:
+
+                    InfoTable = AcpiDmTableInfoIvrs8c;
+                    break;
+
+                default:
+                    InfoTable = AcpiDmTableInfoIvrs4;
+                    AcpiOsPrintf (
+                        "\n**** Unknown IVRS device entry type/length: "
+                        "0x%.2X/0x%X at offset 0x%.4X: (header below)\n",
+                        EntryType, EntryLength, EntryOffset);
+                    break;
+                }
+
+                /* Dump the Device Entry */
+
+                Status = AcpiDmDumpTable (Table->Length, EntryOffset,
+                    DeviceEntry, EntryLength, InfoTable);
+                if (ACPI_FAILURE (Status))
+                {
+                    return;
+                }
+
+                EntryOffset += EntryLength;
+                DeviceEntry = ACPI_ADD_PTR (ACPI_IVRS_DE_HEADER, DeviceEntry,
+                    EntryLength);
+            }
+        }
+
+NextSubTable:
+        /* Point to next subtable */
+
+        Offset += SubTable->Length;
+        SubTable = ACPI_ADD_PTR (ACPI_IVRS_HEADER, SubTable, SubTable->Length);
+    }
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiDmDumpLpit
+ *
+ * PARAMETERS:  Table               - A LPIT table
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Format the contents of a LPIT. This table type consists
+ *              of an open-ended number of subtables. Note: There are no
+ *              entries in the main table. An LPIT consists of the table
+ *              header and then subtables only.
+ *
+ ******************************************************************************/
+
+void
+AcpiDmDumpLpit (
+    ACPI_TABLE_HEADER       *Table)
+{
+    ACPI_STATUS             Status;
+    ACPI_LPIT_HEADER        *SubTable;
+    UINT32                  Length = Table->Length;
+    UINT32                  Offset = sizeof (ACPI_TABLE_LPIT);
+    ACPI_DMTABLE_INFO       *InfoTable;
+    UINT32                  SubTableLength;
+
+
+    /* Subtables */
+
+    SubTable = ACPI_ADD_PTR (ACPI_LPIT_HEADER, Table, Offset);
+    while (Offset < Table->Length)
+    {
+        /* Common subtable header */
+
+        Status = AcpiDmDumpTable (Length, Offset, SubTable,
+            sizeof (ACPI_LPIT_HEADER), AcpiDmTableInfoLpitHdr);
+        if (ACPI_FAILURE (Status))
+        {
+            return;
+        }
+
+        switch (SubTable->Type)
+        {
+        case ACPI_LPIT_TYPE_NATIVE_CSTATE:
+
+            InfoTable = AcpiDmTableInfoLpit0;
+            SubTableLength = sizeof (ACPI_LPIT_NATIVE);
+            break;
+
+        default:
+
+            /* Cannot continue on unknown type - no length */
+
+            AcpiOsPrintf ("\n**** Unknown LPIT subtable type 0x%X\n",
+                SubTable->Type);
+            return;
+        }
+
+        Status = AcpiDmDumpTable (Length, Offset, SubTable,
+            SubTableLength, InfoTable);
+        if (ACPI_FAILURE (Status))
+        {
+            return;
+        }
+
+        AcpiOsPrintf ("\n");
+
+        /* Point to next subtable */
+
+        Offset += SubTableLength;
+        SubTable = ACPI_ADD_PTR (ACPI_LPIT_HEADER, SubTable, SubTableLength);
+    }
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiDmDumpMadt
+ *
+ * PARAMETERS:  Table               - A MADT table
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Format the contents of a MADT. This table type consists
+ *              of an open-ended number of subtables.
+ *
+ ******************************************************************************/
+
+void
+AcpiDmDumpMadt (
+    ACPI_TABLE_HEADER       *Table)
+{
+    ACPI_STATUS             Status;
+    ACPI_SUBTABLE_HEADER    *SubTable;
+    UINT32                  Length = Table->Length;
+    UINT32                  Offset = sizeof (ACPI_TABLE_MADT);
+    ACPI_DMTABLE_INFO       *InfoTable;
+
+
+    /* Main table */
+
+    Status = AcpiDmDumpTable (Length, 0, Table, 0, AcpiDmTableInfoMadt);
+    if (ACPI_FAILURE (Status))
+    {
+        return;
+    }
+
+    /* Subtables */
+
+    SubTable = ACPI_ADD_PTR (ACPI_SUBTABLE_HEADER, Table, Offset);
+    while (Offset < Table->Length)
+    {
+        /* Common subtable header */
+
+        AcpiOsPrintf ("\n");
+        Status = AcpiDmDumpTable (Length, Offset, SubTable,
+            SubTable->Length, AcpiDmTableInfoMadtHdr);
+        if (ACPI_FAILURE (Status))
+        {
+            return;
+        }
+
+        switch (SubTable->Type)
+        {
+        case ACPI_MADT_TYPE_LOCAL_APIC:
+
+            InfoTable = AcpiDmTableInfoMadt0;
+            break;
+
+        case ACPI_MADT_TYPE_IO_APIC:
+
+            InfoTable = AcpiDmTableInfoMadt1;
+            break;
+
+        case ACPI_MADT_TYPE_INTERRUPT_OVERRIDE:
+
+            InfoTable = AcpiDmTableInfoMadt2;
+            break;
+
+        case ACPI_MADT_TYPE_NMI_SOURCE:
+
+            InfoTable = AcpiDmTableInfoMadt3;
+            break;
+
+        case ACPI_MADT_TYPE_LOCAL_APIC_NMI:
+
+            InfoTable = AcpiDmTableInfoMadt4;
+            break;
+
+        case ACPI_MADT_TYPE_LOCAL_APIC_OVERRIDE:
+
+            InfoTable = AcpiDmTableInfoMadt5;
+            break;
+
+        case ACPI_MADT_TYPE_IO_SAPIC:
+
+            InfoTable = AcpiDmTableInfoMadt6;
+            break;
+
+        case ACPI_MADT_TYPE_LOCAL_SAPIC:
+
+            InfoTable = AcpiDmTableInfoMadt7;
+            break;
+
+        case ACPI_MADT_TYPE_INTERRUPT_SOURCE:
+
+            InfoTable = AcpiDmTableInfoMadt8;
+            break;
+
+        case ACPI_MADT_TYPE_LOCAL_X2APIC:
+
+            InfoTable = AcpiDmTableInfoMadt9;
+            break;
+
+        case ACPI_MADT_TYPE_LOCAL_X2APIC_NMI:
+
+            InfoTable = AcpiDmTableInfoMadt10;
+            break;
+
+        case ACPI_MADT_TYPE_GENERIC_INTERRUPT:
+
+            InfoTable = AcpiDmTableInfoMadt11;
+            break;
+
+        case ACPI_MADT_TYPE_GENERIC_DISTRIBUTOR:
+
+            InfoTable = AcpiDmTableInfoMadt12;
+            break;
+
+        case ACPI_MADT_TYPE_GENERIC_MSI_FRAME:
+
+            InfoTable = AcpiDmTableInfoMadt13;
+            break;
+
+        case ACPI_MADT_TYPE_GENERIC_REDISTRIBUTOR:
+
+            InfoTable = AcpiDmTableInfoMadt14;
+            break;
+
+        case ACPI_MADT_TYPE_GENERIC_TRANSLATOR:
+
+            InfoTable = AcpiDmTableInfoMadt15;
+            break;
+
+        default:
+
+            AcpiOsPrintf ("\n**** Unknown MADT subtable type 0x%X\n\n",
+                SubTable->Type);
+
+            /* Attempt to continue */
+
+            if (!SubTable->Length)
+            {
+                AcpiOsPrintf ("Invalid zero length subtable\n");
+                return;
+            }
+
+            goto NextSubTable;
+        }
+
+        Status = AcpiDmDumpTable (Length, Offset, SubTable,
+            SubTable->Length, InfoTable);
+        if (ACPI_FAILURE (Status))
+        {
+            return;
+        }
+
+NextSubTable:
+        /* Point to next subtable */
+
+        Offset += SubTable->Length;
+        SubTable = ACPI_ADD_PTR (ACPI_SUBTABLE_HEADER, SubTable,
+            SubTable->Length);
+    }
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiDmDumpMcfg
+ *
+ * PARAMETERS:  Table               - A MCFG Table
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Format the contents of a MCFG table
+ *
+ ******************************************************************************/
+
+void
+AcpiDmDumpMcfg (
+    ACPI_TABLE_HEADER       *Table)
+{
+    ACPI_STATUS             Status;
+    UINT32                  Offset = sizeof (ACPI_TABLE_MCFG);
+    ACPI_MCFG_ALLOCATION    *SubTable;
+
+
+    /* Main table */
+
+    Status = AcpiDmDumpTable (Table->Length, 0, Table, 0, AcpiDmTableInfoMcfg);
+    if (ACPI_FAILURE (Status))
+    {
+        return;
+    }
+
+    /* Subtables */
+
+    SubTable = ACPI_ADD_PTR (ACPI_MCFG_ALLOCATION, Table, Offset);
+    while (Offset < Table->Length)
+    {
+        if (Offset + sizeof (ACPI_MCFG_ALLOCATION) > Table->Length)
+        {
+            AcpiOsPrintf ("Warning: there are %u invalid trailing bytes\n",
+                sizeof (ACPI_MCFG_ALLOCATION) - (Offset - Table->Length));
+            return;
+        }
+
+        AcpiOsPrintf ("\n");
+        Status = AcpiDmDumpTable (Table->Length, Offset, SubTable,
+            sizeof (ACPI_MCFG_ALLOCATION), AcpiDmTableInfoMcfg0);
+        if (ACPI_FAILURE (Status))
+        {
+            return;
+        }
+
+        /* Point to next subtable (each subtable is of fixed length) */
+
+        Offset += sizeof (ACPI_MCFG_ALLOCATION);
+        SubTable = ACPI_ADD_PTR (ACPI_MCFG_ALLOCATION, SubTable,
+            sizeof (ACPI_MCFG_ALLOCATION));
+    }
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiDmDumpMpst
+ *
+ * PARAMETERS:  Table               - A MPST Table
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Format the contents of a MPST table
+ *
+ ******************************************************************************/
+
+void
+AcpiDmDumpMpst (
+    ACPI_TABLE_HEADER       *Table)
+{
+    ACPI_STATUS             Status;
+    UINT32                  Offset = sizeof (ACPI_TABLE_MPST);
+    ACPI_MPST_POWER_NODE    *SubTable0;
+    ACPI_MPST_POWER_STATE   *SubTable0A;
+    ACPI_MPST_COMPONENT     *SubTable0B;
+    ACPI_MPST_DATA_HDR      *SubTable1;
+    ACPI_MPST_POWER_DATA    *SubTable2;
+    UINT16                  SubtableCount;
+    UINT32                  PowerStateCount;
+    UINT32                  ComponentCount;
+
+
+    /* Main table */
+
+    Status = AcpiDmDumpTable (Table->Length, 0, Table, 0, AcpiDmTableInfoMpst);
+    if (ACPI_FAILURE (Status))
+    {
+        return;
+    }
+
+    /* Subtable: Memory Power Node(s) */
+
+    SubtableCount = (ACPI_CAST_PTR (ACPI_TABLE_MPST, Table))->PowerNodeCount;
+    SubTable0 = ACPI_ADD_PTR (ACPI_MPST_POWER_NODE, Table, Offset);
+
+    while ((Offset < Table->Length) && SubtableCount)
+    {
+        AcpiOsPrintf ("\n");
+        Status = AcpiDmDumpTable (Table->Length, Offset, SubTable0,
+            sizeof (ACPI_MPST_POWER_NODE), AcpiDmTableInfoMpst0);
+        if (ACPI_FAILURE (Status))
+        {
+            return;
+        }
+
+        /* Extract the sub-subtable counts */
+
+        PowerStateCount = SubTable0->NumPowerStates;
+        ComponentCount = SubTable0->NumPhysicalComponents;
+        Offset += sizeof (ACPI_MPST_POWER_NODE);
+
+        /* Sub-subtables - Memory Power State Structure(s) */
+
+        SubTable0A = ACPI_ADD_PTR (ACPI_MPST_POWER_STATE, SubTable0,
+            sizeof (ACPI_MPST_POWER_NODE));
+
+        while (PowerStateCount)
+        {
+            AcpiOsPrintf ("\n");
+            Status = AcpiDmDumpTable (Table->Length, Offset, SubTable0A,
+                sizeof (ACPI_MPST_POWER_STATE), AcpiDmTableInfoMpst0A);
+            if (ACPI_FAILURE (Status))
+            {
+                return;
+            }
+
+            SubTable0A++;
+            PowerStateCount--;
+            Offset += sizeof (ACPI_MPST_POWER_STATE);
+       }
+
+        /* Sub-subtables - Physical Component ID Structure(s) */
+
+        SubTable0B = ACPI_CAST_PTR (ACPI_MPST_COMPONENT, SubTable0A);
+
+        if (ComponentCount)
+        {
+            AcpiOsPrintf ("\n");
+        }
+
+        while (ComponentCount)
+        {
+            Status = AcpiDmDumpTable (Table->Length, Offset, SubTable0B,
+                sizeof (ACPI_MPST_COMPONENT), AcpiDmTableInfoMpst0B);
+            if (ACPI_FAILURE (Status))
+            {
+                return;
+            }
+
+            SubTable0B++;
+            ComponentCount--;
+            Offset += sizeof (ACPI_MPST_COMPONENT);
+        }
+
+        /* Point to next Memory Power Node subtable */
+
+        SubtableCount--;
+        SubTable0 = ACPI_ADD_PTR (ACPI_MPST_POWER_NODE, SubTable0,
+            sizeof (ACPI_MPST_POWER_NODE) +
+            (sizeof (ACPI_MPST_POWER_STATE) * SubTable0->NumPowerStates) +
+            (sizeof (ACPI_MPST_COMPONENT) * SubTable0->NumPhysicalComponents));
+    }
+
+    /* Subtable: Count of Memory Power State Characteristic structures */
+
+    AcpiOsPrintf ("\n");
+    SubTable1 = ACPI_CAST_PTR (ACPI_MPST_DATA_HDR, SubTable0);
+    Status = AcpiDmDumpTable (Table->Length, Offset, SubTable1,
+        sizeof (ACPI_MPST_DATA_HDR), AcpiDmTableInfoMpst1);
+    if (ACPI_FAILURE (Status))
+    {
+        return;
+    }
+
+    SubtableCount = SubTable1->CharacteristicsCount;
+    Offset += sizeof (ACPI_MPST_DATA_HDR);
+
+    /* Subtable: Memory Power State Characteristics structure(s) */
+
+    SubTable2 = ACPI_ADD_PTR (ACPI_MPST_POWER_DATA, SubTable1,
+        sizeof (ACPI_MPST_DATA_HDR));
+
+    while ((Offset < Table->Length) && SubtableCount)
+    {
+        AcpiOsPrintf ("\n");
+        Status = AcpiDmDumpTable (Table->Length, Offset, SubTable2,
+            sizeof (ACPI_MPST_POWER_DATA), AcpiDmTableInfoMpst2);
+        if (ACPI_FAILURE (Status))
+        {
+            return;
+        }
+
+        SubTable2++;
+        SubtableCount--;
+        Offset += sizeof (ACPI_MPST_POWER_DATA);
+    }
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiDmDumpMsct
+ *
+ * PARAMETERS:  Table               - A MSCT table
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Format the contents of a MSCT
+ *
+ ******************************************************************************/
+
+void
+AcpiDmDumpMsct (
+    ACPI_TABLE_HEADER       *Table)
+{
+    ACPI_STATUS             Status;
+    UINT32                  Offset = sizeof (ACPI_TABLE_MSCT);
+    ACPI_MSCT_PROXIMITY     *SubTable;
+
+
+    /* Main table */
+
+    Status = AcpiDmDumpTable (Table->Length, 0, Table, 0, AcpiDmTableInfoMsct);
+    if (ACPI_FAILURE (Status))
+    {
+        return;
+    }
+
+    /* Subtables */
+
+    SubTable = ACPI_ADD_PTR (ACPI_MSCT_PROXIMITY, Table, Offset);
+    while (Offset < Table->Length)
+    {
+        /* Common subtable header */
+
+        AcpiOsPrintf ("\n");
+        Status = AcpiDmDumpTable (Table->Length, Offset, SubTable,
+            sizeof (ACPI_MSCT_PROXIMITY), AcpiDmTableInfoMsct0);
+        if (ACPI_FAILURE (Status))
+        {
+            return;
+        }
+
+        /* Point to next subtable */
+
+        Offset += sizeof (ACPI_MSCT_PROXIMITY);
+        SubTable = ACPI_ADD_PTR (ACPI_MSCT_PROXIMITY, SubTable,
+            sizeof (ACPI_MSCT_PROXIMITY));
+    }
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiDmDumpMtmr
+ *
+ * PARAMETERS:  Table               - A MTMR table
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Format the contents of a MTMR
+ *
+ ******************************************************************************/
+
+void
+AcpiDmDumpMtmr (
+    ACPI_TABLE_HEADER       *Table)
+{
+    ACPI_STATUS             Status;
+    UINT32                  Offset = sizeof (ACPI_TABLE_MTMR);
+    ACPI_MTMR_ENTRY         *SubTable;
+
+
+    /* Main table */
+
+    Status = AcpiDmDumpTable (Table->Length, 0, Table, 0, AcpiDmTableInfoMtmr);
+    if (ACPI_FAILURE (Status))
+    {
+        return;
+    }
+
+    /* Subtables */
+
+    SubTable = ACPI_ADD_PTR (ACPI_MTMR_ENTRY, Table, Offset);
+    while (Offset < Table->Length)
+    {
+        /* Common subtable header */
+
+        AcpiOsPrintf ("\n");
+        Status = AcpiDmDumpTable (Table->Length, Offset, SubTable,
+            sizeof (ACPI_MTMR_ENTRY), AcpiDmTableInfoMtmr0);
+        if (ACPI_FAILURE (Status))
+        {
+            return;
+        }
+
+        /* Point to next subtable */
+
+        Offset += sizeof (ACPI_MTMR_ENTRY);
+        SubTable = ACPI_ADD_PTR (ACPI_MTMR_ENTRY, SubTable,
+            sizeof (ACPI_MTMR_ENTRY));
+    }
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiDmDumpNfit
+ *
+ * PARAMETERS:  Table               - A NFIT table
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Format the contents of an NFIT.
+ *
+ ******************************************************************************/
+
+void
+AcpiDmDumpNfit (
+    ACPI_TABLE_HEADER       *Table)
+{
+    ACPI_STATUS             Status;
+    UINT32                  Offset = sizeof (ACPI_TABLE_NFIT);
+    UINT32                  FieldOffset = 0;
+    UINT32                  Length;
+    ACPI_NFIT_HEADER        *SubTable;
+    ACPI_DMTABLE_INFO       *InfoTable;
+    ACPI_NFIT_INTERLEAVE    *Interleave = NULL;
+    ACPI_NFIT_SMBIOS        *SmbiosInfo = NULL;
+    ACPI_NFIT_FLUSH_ADDRESS *Hint = NULL;
+    UINT32                  i;
+
+
+    /* Main table */
+
+    Status = AcpiDmDumpTable (Table->Length, 0, Table, 0, AcpiDmTableInfoNfit);
+    if (ACPI_FAILURE (Status))
+    {
+        return;
+    }
+
+    /* Subtables */
+
+    SubTable = ACPI_ADD_PTR (ACPI_NFIT_HEADER, Table, Offset);
+    while (Offset < Table->Length)
+    {
+        /* NFIT subtable header */
+
+        AcpiOsPrintf ("\n");
+        Status = AcpiDmDumpTable (Table->Length, Offset, SubTable,
+            SubTable->Length, AcpiDmTableInfoNfitHdr);
+        if (ACPI_FAILURE (Status))
+        {
+            return;
+        }
+
+        switch (SubTable->Type)
+        {
+        case ACPI_NFIT_TYPE_SYSTEM_ADDRESS:
+
+            InfoTable = AcpiDmTableInfoNfit0;
+            break;
+
+        case ACPI_NFIT_TYPE_MEMORY_MAP:
+
+            InfoTable = AcpiDmTableInfoNfit1;
+            break;
+
+        case ACPI_NFIT_TYPE_INTERLEAVE:
+
+            /* Has a variable number of 32-bit values at the end */
+
+            InfoTable = AcpiDmTableInfoNfit2;
+            Interleave = ACPI_CAST_PTR (ACPI_NFIT_INTERLEAVE, SubTable);
+            FieldOffset = sizeof (ACPI_NFIT_INTERLEAVE);
+            break;
+
+        case ACPI_NFIT_TYPE_SMBIOS:
+
+            SmbiosInfo = ACPI_CAST_PTR (ACPI_NFIT_SMBIOS, SubTable);
+            InfoTable = AcpiDmTableInfoNfit3;
+            break;
+
+        case ACPI_NFIT_TYPE_CONTROL_REGION:
+
+            InfoTable = AcpiDmTableInfoNfit4;
+            break;
+
+        case ACPI_NFIT_TYPE_DATA_REGION:
+
+            InfoTable = AcpiDmTableInfoNfit5;
+            break;
+
+        case ACPI_NFIT_TYPE_FLUSH_ADDRESS:
+
+            /* Has a variable number of 64-bit addresses at the end */
+
+            InfoTable = AcpiDmTableInfoNfit6;
+            Hint = ACPI_CAST_PTR (ACPI_NFIT_FLUSH_ADDRESS, SubTable);
+            FieldOffset = sizeof (ACPI_NFIT_FLUSH_ADDRESS) - sizeof (UINT64);
+            break;
+
+        default:
+            AcpiOsPrintf ("\n**** Unknown NFIT subtable type 0x%X\n",
+                SubTable->Type);
+
+            /* Attempt to continue */
+
+            if (!SubTable->Length)
+            {
+                AcpiOsPrintf ("Invalid zero length subtable\n");
+                return;
+            }
+            goto NextSubTable;
+        }
+
+        AcpiOsPrintf ("\n");
+        Status = AcpiDmDumpTable (Table->Length, Offset, SubTable,
+            SubTable->Length, InfoTable);
+        if (ACPI_FAILURE (Status))
+        {
+            return;
+        }
+
+        /* Per-subtable variable-length fields */
+
+        switch (SubTable->Type)
+        {
+        case ACPI_NFIT_TYPE_INTERLEAVE:
+
+            for (i = 0; i < Interleave->LineCount; i++)
+            {
+                Status = AcpiDmDumpTable (Table->Length, Offset + FieldOffset,
+                    &Interleave->LineOffset[i],
+                    sizeof (UINT32), AcpiDmTableInfoNfit2a);
+                if (ACPI_FAILURE (Status))
+                {
+                    return;
+                }
+
+                FieldOffset += sizeof (UINT32);
+            }
+            break;
+
+        case ACPI_NFIT_TYPE_SMBIOS:
+
+            Length = SubTable->Length -
+                sizeof (ACPI_NFIT_SMBIOS) + sizeof (UINT8);
+
+            if (Length)
+            {
+                Status = AcpiDmDumpTable (Table->Length,
+                    sizeof (ACPI_NFIT_SMBIOS) - sizeof (UINT8),
+                    SmbiosInfo,
+                    Length, AcpiDmTableInfoNfit3a);
+                if (ACPI_FAILURE (Status))
+                {
+                    return;
+                }
+            }
+
+            break;
+
+        case ACPI_NFIT_TYPE_FLUSH_ADDRESS:
+
+            for (i = 0; i < Hint->HintCount; i++)
+            {
+                Status = AcpiDmDumpTable (Table->Length, Offset + FieldOffset,
+                    &Hint->HintAddress[i],
+                    sizeof (UINT64), AcpiDmTableInfoNfit6a);
+                if (ACPI_FAILURE (Status))
+                {
+                    return;
+                }
+
+                FieldOffset += sizeof (UINT64);
+            }
+            break;
+
+        default:
+            break;
+        }
+
+NextSubTable:
+        /* Point to next subtable */
+
+        Offset += SubTable->Length;
+        SubTable = ACPI_ADD_PTR (ACPI_NFIT_HEADER, SubTable, SubTable->Length);
+    }
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiDmDumpPcct
+ *
+ * PARAMETERS:  Table               - A PCCT table
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Format the contents of a PCCT. This table type consists
+ *              of an open-ended number of subtables.
+ *
+ ******************************************************************************/
+
+void
+AcpiDmDumpPcct (
+    ACPI_TABLE_HEADER       *Table)
+{
+    ACPI_STATUS             Status;
+    ACPI_PCCT_SUBSPACE      *SubTable;
+    ACPI_DMTABLE_INFO       *InfoTable;
+    UINT32                  Length = Table->Length;
+    UINT32                  Offset = sizeof (ACPI_TABLE_PCCT);
+
+
+    /* Main table */
+
+    Status = AcpiDmDumpTable (Length, 0, Table, 0, AcpiDmTableInfoPcct);
+    if (ACPI_FAILURE (Status))
+    {
+        return;
+    }
+
+    /* Subtables */
+
+    SubTable = ACPI_ADD_PTR (ACPI_PCCT_SUBSPACE, Table, Offset);
+    while (Offset < Table->Length)
+    {
+        /* Common subtable header */
+
+        AcpiOsPrintf ("\n");
+        Status = AcpiDmDumpTable (Length, Offset, SubTable,
+            SubTable->Header.Length, AcpiDmTableInfoPcctHdr);
+        if (ACPI_FAILURE (Status))
+        {
+            return;
+        }
+
+        switch (SubTable->Header.Type)
+        {
+        case ACPI_PCCT_TYPE_GENERIC_SUBSPACE:
+
+            InfoTable = AcpiDmTableInfoPcct0;
+            break;
+
+        case ACPI_PCCT_TYPE_HW_REDUCED_SUBSPACE:
+
+            InfoTable = AcpiDmTableInfoPcct1;
+            break;
+
+        case ACPI_PCCT_TYPE_HW_REDUCED_SUBSPACE_TYPE2:
+
+            InfoTable = AcpiDmTableInfoPcct2;
+            break;
+
+        default:
+
+            AcpiOsPrintf (
+                "\n**** Unexpected or unknown PCCT subtable type 0x%X\n\n",
+                SubTable->Header.Type);
+            return;
+        }
+
+        AcpiOsPrintf ("\n");
+        Status = AcpiDmDumpTable (Length, Offset, SubTable,
+            SubTable->Header.Length, InfoTable);
+        if (ACPI_FAILURE (Status))
+        {
+            return;
+        }
+
+        /* Point to next subtable */
+
+        Offset += SubTable->Header.Length;
+        SubTable = ACPI_ADD_PTR (ACPI_PCCT_SUBSPACE, SubTable,
+            SubTable->Header.Length);
+    }
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiDmDumpPmtt
+ *
+ * PARAMETERS:  Table               - A PMTT table
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Format the contents of a PMTT. This table type consists
+ *              of an open-ended number of subtables.
+ *
+ ******************************************************************************/
+
+void
+AcpiDmDumpPmtt (
+    ACPI_TABLE_HEADER       *Table)
+{
+    ACPI_STATUS             Status;
+    ACPI_PMTT_HEADER        *SubTable;
+    ACPI_PMTT_HEADER        *MemSubTable;
+    ACPI_PMTT_HEADER        *DimmSubTable;
+    ACPI_PMTT_DOMAIN        *DomainArray;
+    UINT32                  Length = Table->Length;
+    UINT32                  Offset = sizeof (ACPI_TABLE_PMTT);
+    UINT32                  MemOffset;
+    UINT32                  DimmOffset;
+    UINT32                  DomainOffset;
+    UINT32                  DomainCount;
+
+
+    /* Main table */
+
+    Status = AcpiDmDumpTable (Length, 0, Table, 0, AcpiDmTableInfoPmtt);
+    if (ACPI_FAILURE (Status))
+    {
+        return;
+    }
+
+    /* Subtables */
+
+    SubTable = ACPI_ADD_PTR (ACPI_PMTT_HEADER, Table, Offset);
+    while (Offset < Table->Length)
+    {
+        /* Common subtable header */
+
+        AcpiOsPrintf ("\n");
+        Status = AcpiDmDumpTable (Length, Offset, SubTable,
+            SubTable->Length, AcpiDmTableInfoPmttHdr);
+        if (ACPI_FAILURE (Status))
+        {
+            return;
+        }
+
+        /* Only Socket subtables are expected at this level */
+
+        if (SubTable->Type != ACPI_PMTT_TYPE_SOCKET)
+        {
+            AcpiOsPrintf (
+                "\n**** Unexpected or unknown PMTT subtable type 0x%X\n\n",
+                SubTable->Type);
+            return;
+        }
+
+        /* Dump the fixed-length portion of the subtable */
+
+        Status = AcpiDmDumpTable (Length, Offset, SubTable,
+            SubTable->Length, AcpiDmTableInfoPmtt0);
+        if (ACPI_FAILURE (Status))
+        {
+            return;
+        }
+
+        /* Walk the memory controller subtables */
+
+        MemOffset = sizeof (ACPI_PMTT_SOCKET);
+        MemSubTable = ACPI_ADD_PTR (ACPI_PMTT_HEADER, SubTable,
+            sizeof (ACPI_PMTT_SOCKET));
+
+        while (((Offset + MemOffset) < Table->Length) &&
+            (MemOffset < SubTable->Length))
+        {
+            /* Common subtable header */
+
+            AcpiOsPrintf ("\n");
+            Status = AcpiDmDumpTable (Length,
+                Offset + MemOffset, MemSubTable,
+                MemSubTable->Length, AcpiDmTableInfoPmttHdr);
+            if (ACPI_FAILURE (Status))
+            {
+                return;
+            }
+
+            /* Only memory controller subtables are expected at this level */
+
+            if (MemSubTable->Type != ACPI_PMTT_TYPE_CONTROLLER)
+            {
+                AcpiOsPrintf (
+                    "\n**** Unexpected or unknown PMTT subtable type 0x%X\n\n",
+                    MemSubTable->Type);
+                return;
+            }
+
+            /* Dump the fixed-length portion of the controller subtable */
+
+            Status = AcpiDmDumpTable (Length,
+                Offset + MemOffset, MemSubTable,
+                MemSubTable->Length, AcpiDmTableInfoPmtt1);
+            if (ACPI_FAILURE (Status))
+            {
+                return;
+            }
+
+            /* Walk the variable count of proximity domains */
+
+            DomainCount = ((ACPI_PMTT_CONTROLLER *) MemSubTable)->DomainCount;
+            DomainOffset = sizeof (ACPI_PMTT_CONTROLLER);
+            DomainArray = ACPI_ADD_PTR (ACPI_PMTT_DOMAIN, MemSubTable,
+                sizeof (ACPI_PMTT_CONTROLLER));
+
+            while (((Offset + MemOffset + DomainOffset) < Table->Length) &&
+                ((MemOffset + DomainOffset) < SubTable->Length) &&
+                DomainCount)
+            {
+                Status = AcpiDmDumpTable (Length,
+                    Offset + MemOffset + DomainOffset, DomainArray,
+                    sizeof (ACPI_PMTT_DOMAIN), AcpiDmTableInfoPmtt1a);
+                if (ACPI_FAILURE (Status))
+                {
+                    return;
+                }
+
+                DomainOffset += sizeof (ACPI_PMTT_DOMAIN);
+                DomainArray++;
+                DomainCount--;
+            }
+
+            if (DomainCount)
+            {
+                AcpiOsPrintf (
+                    "\n**** DomainCount exceeds subtable length\n\n");
+            }
+
+            /* Walk the physical component (DIMM) subtables */
+
+            DimmOffset = DomainOffset;
+            DimmSubTable = ACPI_ADD_PTR (ACPI_PMTT_HEADER, MemSubTable,
+                DomainOffset);
+
+            while (((Offset + MemOffset + DimmOffset) < Table->Length) &&
+                (DimmOffset < MemSubTable->Length))
+            {
+                /* Common subtable header */
+
+                AcpiOsPrintf ("\n");
+                Status = AcpiDmDumpTable (Length,
+                    Offset + MemOffset + DimmOffset, DimmSubTable,
+                    DimmSubTable->Length, AcpiDmTableInfoPmttHdr);
+                if (ACPI_FAILURE (Status))
+                {
+                    return;
+                }
+
+                /* Only DIMM subtables are expected at this level */
+
+                if (DimmSubTable->Type != ACPI_PMTT_TYPE_DIMM)
+                {
+                    AcpiOsPrintf (
+                        "\n**** Unexpected or unknown PMTT subtable type 0x%X\n\n",
+                        DimmSubTable->Type);
+                    return;
+                }
+
+                /* Dump the fixed-length DIMM subtable */
+
+                Status = AcpiDmDumpTable (Length,
+                    Offset + MemOffset + DimmOffset, DimmSubTable,
+                    DimmSubTable->Length, AcpiDmTableInfoPmtt2);
+                if (ACPI_FAILURE (Status))
+                {
+                    return;
+                }
+
+                /* Point to next DIMM subtable */
+
+                DimmOffset += DimmSubTable->Length;
+                DimmSubTable = ACPI_ADD_PTR (ACPI_PMTT_HEADER,
+                    DimmSubTable, DimmSubTable->Length);
+            }
+
+            /* Point to next Controller subtable */
+
+            MemOffset += MemSubTable->Length;
+            MemSubTable = ACPI_ADD_PTR (ACPI_PMTT_HEADER,
+                MemSubTable, MemSubTable->Length);
+        }
+
+        /* Point to next Socket subtable */
+
+        Offset += SubTable->Length;
+        SubTable = ACPI_ADD_PTR (ACPI_PMTT_HEADER,
+            SubTable, SubTable->Length);
+    }
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiDmDumpS3pt
+ *
+ * PARAMETERS:  Table               - A S3PT table
+ *
+ * RETURN:      Length of the table
+ *
+ * DESCRIPTION: Format the contents of a S3PT
+ *
+ ******************************************************************************/
+
+UINT32
+AcpiDmDumpS3pt (
+    ACPI_TABLE_HEADER       *Tables)
+{
+    ACPI_STATUS             Status;
+    UINT32                  Offset = sizeof (ACPI_TABLE_S3PT);
+    ACPI_FPDT_HEADER        *SubTable;
+    ACPI_DMTABLE_INFO       *InfoTable;
+    ACPI_TABLE_S3PT         *S3ptTable = ACPI_CAST_PTR (ACPI_TABLE_S3PT, Tables);
+
+
+    /* Main table */
+
+    Status = AcpiDmDumpTable (Offset, 0, S3ptTable, 0, AcpiDmTableInfoS3pt);
+    if (ACPI_FAILURE (Status))
+    {
+        return 0;
+    }
+
+    SubTable = ACPI_ADD_PTR (ACPI_FPDT_HEADER, S3ptTable, Offset);
+    while (Offset < S3ptTable->Length)
+    {
+        /* Common subtable header */
+
+        AcpiOsPrintf ("\n");
+        Status = AcpiDmDumpTable (S3ptTable->Length, Offset, SubTable,
+            SubTable->Length, AcpiDmTableInfoS3ptHdr);
+        if (ACPI_FAILURE (Status))
+        {
+            return 0;
+        }
+
+        switch (SubTable->Type)
+        {
+        case ACPI_S3PT_TYPE_RESUME:
+
+            InfoTable = AcpiDmTableInfoS3pt0;
+            break;
+
+        case ACPI_S3PT_TYPE_SUSPEND:
+
+            InfoTable = AcpiDmTableInfoS3pt1;
+            break;
+
+        default:
+
+            AcpiOsPrintf ("\n**** Unknown S3PT subtable type 0x%X\n",
+                SubTable->Type);
+
+            /* Attempt to continue */
+
+            if (!SubTable->Length)
+            {
+                AcpiOsPrintf ("Invalid zero length subtable\n");
+                return 0;
+            }
+            goto NextSubTable;
+        }
+
+        AcpiOsPrintf ("\n");
+        Status = AcpiDmDumpTable (S3ptTable->Length, Offset, SubTable,
+            SubTable->Length, InfoTable);
+        if (ACPI_FAILURE (Status))
+        {
+            return 0;
+        }
+
+NextSubTable:
+        /* Point to next subtable */
+
+        Offset += SubTable->Length;
+        SubTable = ACPI_ADD_PTR (ACPI_FPDT_HEADER, SubTable, SubTable->Length);
+    }
+
+    return (S3ptTable->Length);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiDmDumpSlic
+ *
+ * PARAMETERS:  Table               - A SLIC table
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Format the contents of a SLIC
+ *
+ ******************************************************************************/
+
+void
+AcpiDmDumpSlic (
+    ACPI_TABLE_HEADER       *Table)
+{
+
+    (void) AcpiDmDumpTable (Table->Length, sizeof (ACPI_TABLE_HEADER), Table,
+        Table->Length - sizeof (*Table), AcpiDmTableInfoSlic);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiDmDumpSlit
+ *
+ * PARAMETERS:  Table               - An SLIT
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Format the contents of a SLIT
+ *
+ ******************************************************************************/
+
+void
+AcpiDmDumpSlit (
+    ACPI_TABLE_HEADER       *Table)
+{
+    ACPI_STATUS             Status;
+    UINT32                  Offset;
+    UINT8                   *Row;
+    UINT32                  Localities;
+    UINT32                  i;
+    UINT32                  j;
+
+
+    /* Main table */
+
+    Status = AcpiDmDumpTable (Table->Length, 0, Table, 0, AcpiDmTableInfoSlit);
+    if (ACPI_FAILURE (Status))
+    {
+        return;
+    }
+
+    /* Display the Locality NxN Matrix */
+
+    Localities = (UINT32) ACPI_CAST_PTR (ACPI_TABLE_SLIT, Table)->LocalityCount;
+    Offset = ACPI_OFFSET (ACPI_TABLE_SLIT, Entry[0]);
+    Row = (UINT8 *) ACPI_CAST_PTR (ACPI_TABLE_SLIT, Table)->Entry;
+
+    for (i = 0; i < Localities; i++)
+    {
+        /* Display one row of the matrix */
+
+        AcpiDmLineHeader2 (Offset, Localities, "Locality", i);
+        for  (j = 0; j < Localities; j++)
+        {
+            /* Check for beyond EOT */
+
+            if (Offset >= Table->Length)
+            {
+                AcpiOsPrintf (
+                    "\n**** Not enough room in table for all localities\n");
+                return;
+            }
+
+            AcpiOsPrintf ("%2.2X", Row[j]);
+            Offset++;
+
+            /* Display up to 16 bytes per output row */
+
+            if ((j+1) < Localities)
+            {
+                AcpiOsPrintf (" ");
+
+                if (j && (((j+1) % 16) == 0))
+                {
+                    AcpiOsPrintf ("\\\n"); /* With line continuation char */
+                    AcpiDmLineHeader (Offset, 0, NULL);
+                }
+            }
+        }
+
+        /* Point to next row */
+
+        AcpiOsPrintf ("\n");
+        Row += Localities;
+    }
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiDmDumpSrat
+ *
+ * PARAMETERS:  Table               - A SRAT table
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Format the contents of a SRAT
+ *
+ ******************************************************************************/
+
+void
+AcpiDmDumpSrat (
+    ACPI_TABLE_HEADER       *Table)
+{
+    ACPI_STATUS             Status;
+    UINT32                  Offset = sizeof (ACPI_TABLE_SRAT);
+    ACPI_SUBTABLE_HEADER    *SubTable;
+    ACPI_DMTABLE_INFO       *InfoTable;
+
+
+    /* Main table */
+
+    Status = AcpiDmDumpTable (Table->Length, 0, Table, 0, AcpiDmTableInfoSrat);
+    if (ACPI_FAILURE (Status))
+    {
+        return;
+    }
+
+    /* Subtables */
+
+    SubTable = ACPI_ADD_PTR (ACPI_SUBTABLE_HEADER, Table, Offset);
+    while (Offset < Table->Length)
+    {
+        /* Common subtable header */
+
+        AcpiOsPrintf ("\n");
+        Status = AcpiDmDumpTable (Table->Length, Offset, SubTable,
+            SubTable->Length, AcpiDmTableInfoSratHdr);
+        if (ACPI_FAILURE (Status))
+        {
+            return;
+        }
+
+        switch (SubTable->Type)
+        {
+        case ACPI_SRAT_TYPE_CPU_AFFINITY:
+
+            InfoTable = AcpiDmTableInfoSrat0;
+            break;
+
+        case ACPI_SRAT_TYPE_MEMORY_AFFINITY:
+
+            InfoTable = AcpiDmTableInfoSrat1;
+            break;
+
+        case ACPI_SRAT_TYPE_X2APIC_CPU_AFFINITY:
+
+            InfoTable = AcpiDmTableInfoSrat2;
+            break;
+
+        case ACPI_SRAT_TYPE_GICC_AFFINITY:
+
+            InfoTable = AcpiDmTableInfoSrat3;
+            break;
+
+        default:
+            AcpiOsPrintf ("\n**** Unknown SRAT subtable type 0x%X\n",
+                SubTable->Type);
+
+            /* Attempt to continue */
+
+            if (!SubTable->Length)
+            {
+                AcpiOsPrintf ("Invalid zero length subtable\n");
+                return;
+            }
+            goto NextSubTable;
+        }
+
+        AcpiOsPrintf ("\n");
+        Status = AcpiDmDumpTable (Table->Length, Offset, SubTable,
+            SubTable->Length, InfoTable);
+        if (ACPI_FAILURE (Status))
+        {
+            return;
+        }
+
+NextSubTable:
+        /* Point to next subtable */
+
+        Offset += SubTable->Length;
+        SubTable = ACPI_ADD_PTR (ACPI_SUBTABLE_HEADER, SubTable,
+            SubTable->Length);
+    }
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiDmDumpStao
+ *
+ * PARAMETERS:  Table               - A STAO table
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Format the contents of a STAO. This is a variable-length
+ *              table that contains an open-ended number of ASCII strings
+ *              at the end of the table.
+ *
+ ******************************************************************************/
+
+void
+AcpiDmDumpStao (
+    ACPI_TABLE_HEADER       *Table)
+{
+    ACPI_STATUS             Status;
+    char                    *Namepath;
+    UINT32                  Length = Table->Length;
+    UINT32                  StringLength;
+    UINT32                  Offset = sizeof (ACPI_TABLE_STAO);
+
+
+    /* Main table */
+
+    Status = AcpiDmDumpTable (Length, 0, Table, 0, AcpiDmTableInfoStao);
+    if (ACPI_FAILURE (Status))
+    {
+        return;
+    }
+
+    /* The rest of the table consists of Namepath strings */
+
+    while (Offset < Table->Length)
+    {
+        Namepath = ACPI_ADD_PTR (char, Table, Offset);
+        StringLength = strlen (Namepath) + 1;
+
+        AcpiDmLineHeader (Offset, StringLength, "Namestring");
+        AcpiOsPrintf ("\"%s\"\n", Namepath);
+
+        /* Point to next namepath */
+
+        Offset += StringLength;
+    }
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiDmDumpTcpa
+ *
+ * PARAMETERS:  Table               - A TCPA table
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Format the contents of a TCPA.
+ *
+ * NOTE:        There are two versions of the table with the same signature:
+ *              the client version and the server version. The common
+ *              PlatformClass field is used to differentiate the two types of
+ *              tables.
+ *
+ ******************************************************************************/
+
+void
+AcpiDmDumpTcpa (
+    ACPI_TABLE_HEADER       *Table)
+{
+    UINT32                  Offset = sizeof (ACPI_TABLE_TCPA_HDR);
+    ACPI_TABLE_TCPA_HDR     *CommonHeader = ACPI_CAST_PTR (
+                                ACPI_TABLE_TCPA_HDR, Table);
+    ACPI_TABLE_TCPA_HDR     *SubTable = ACPI_ADD_PTR (
+                                ACPI_TABLE_TCPA_HDR, Table, Offset);
+    ACPI_STATUS             Status;
+
+
+    /* Main table */
+
+    Status = AcpiDmDumpTable (Table->Length, 0, Table,
+        0, AcpiDmTableInfoTcpaHdr);
+    if (ACPI_FAILURE (Status))
+    {
+        return;
+    }
+
+    /*
+     * Examine the PlatformClass field to determine the table type.
+     * Either a client or server table. Only one.
+     */
+    switch (CommonHeader->PlatformClass)
+    {
+    case ACPI_TCPA_CLIENT_TABLE:
+
+        Status = AcpiDmDumpTable (Table->Length, Offset, SubTable,
+            Table->Length - Offset, AcpiDmTableInfoTcpaClient);
+        break;
+
+    case ACPI_TCPA_SERVER_TABLE:
+
+        Status = AcpiDmDumpTable (Table->Length, Offset, SubTable,
+            Table->Length - Offset, AcpiDmTableInfoTcpaServer);
+        break;
+
+    default:
+
+        AcpiOsPrintf ("\n**** Unknown TCPA Platform Class 0x%X\n",
+            CommonHeader->PlatformClass);
+        Status = AE_ERROR;
+        break;
+    }
+
+    if (ACPI_FAILURE (Status))
+    {
+        AcpiOsPrintf ("\n**** Cannot disassemble TCPA table\n");
+    }
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiDmDumpVrtc
+ *
+ * PARAMETERS:  Table               - A VRTC table
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Format the contents of a VRTC
+ *
+ ******************************************************************************/
+
+void
+AcpiDmDumpVrtc (
+    ACPI_TABLE_HEADER       *Table)
+{
+    ACPI_STATUS             Status;
+    UINT32                  Offset = sizeof (ACPI_TABLE_VRTC);
+    ACPI_VRTC_ENTRY         *SubTable;
+
+
+    /* Main table */
+
+    Status = AcpiDmDumpTable (Table->Length, 0, Table, 0, AcpiDmTableInfoVrtc);
+    if (ACPI_FAILURE (Status))
+    {
+        return;
+    }
+
+    /* Subtables */
+
+    SubTable = ACPI_ADD_PTR (ACPI_VRTC_ENTRY, Table, Offset);
+    while (Offset < Table->Length)
+    {
+        /* Common subtable header */
+
+        AcpiOsPrintf ("\n");
+        Status = AcpiDmDumpTable (Table->Length, Offset, SubTable,
+            sizeof (ACPI_VRTC_ENTRY), AcpiDmTableInfoVrtc0);
+        if (ACPI_FAILURE (Status))
+        {
+            return;
+        }
+
+        /* Point to next subtable */
+
+        Offset += sizeof (ACPI_VRTC_ENTRY);
+        SubTable = ACPI_ADD_PTR (ACPI_VRTC_ENTRY, SubTable,
+            sizeof (ACPI_VRTC_ENTRY));
+    }
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiDmDumpWdat
+ *
+ * PARAMETERS:  Table               - A WDAT table
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Format the contents of a WDAT
+ *
+ ******************************************************************************/
+
+void
+AcpiDmDumpWdat (
+    ACPI_TABLE_HEADER       *Table)
+{
+    ACPI_STATUS             Status;
+    UINT32                  Offset = sizeof (ACPI_TABLE_WDAT);
+    ACPI_WDAT_ENTRY         *SubTable;
+
+
+    /* Main table */
+
+    Status = AcpiDmDumpTable (Table->Length, 0, Table, 0, AcpiDmTableInfoWdat);
+    if (ACPI_FAILURE (Status))
+    {
+        return;
+    }
+
+    /* Subtables */
+
+    SubTable = ACPI_ADD_PTR (ACPI_WDAT_ENTRY, Table, Offset);
+    while (Offset < Table->Length)
+    {
+        /* Common subtable header */
+
+        AcpiOsPrintf ("\n");
+        Status = AcpiDmDumpTable (Table->Length, Offset, SubTable,
+            sizeof (ACPI_WDAT_ENTRY), AcpiDmTableInfoWdat0);
+        if (ACPI_FAILURE (Status))
+        {
+            return;
+        }
+
+        /* Point to next subtable */
+
+        Offset += sizeof (ACPI_WDAT_ENTRY);
+        SubTable = ACPI_ADD_PTR (ACPI_WDAT_ENTRY, SubTable,
+            sizeof (ACPI_WDAT_ENTRY));
+    }
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiDmDumpWpbt
+ *
+ * PARAMETERS:  Table               - A WPBT table
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Format the contents of a WPBT. This table type consists
+ *              of an open-ended arguments buffer at the end of the table.
+ *
+ ******************************************************************************/
+
+void
+AcpiDmDumpWpbt (
+    ACPI_TABLE_HEADER       *Table)
+{
+    ACPI_STATUS             Status;
+    ACPI_TABLE_WPBT         *SubTable;
+    UINT32                  Length = Table->Length;
+    UINT16                  ArgumentsLength;
+
+
+    /* Dump the main table */
+
+    Status = AcpiDmDumpTable (Length, 0, Table, 0, AcpiDmTableInfoWpbt);
+    if (ACPI_FAILURE (Status))
+    {
+        return;
+    }
+
+    /* Extract the arguments buffer length from the main table */
+
+    SubTable = ACPI_CAST_PTR (ACPI_TABLE_WPBT, Table);
+    ArgumentsLength = SubTable->ArgumentsLength;
+
+    /* Dump the arguments buffer */
+
+    (void) AcpiDmDumpTable (Table->Length, 0, Table, ArgumentsLength,
+        AcpiDmTableInfoWpbt0);
+}
diff --git a/usr/src/cmd/acpi/common/dmtbinfo.c b/usr/src/cmd/acpi/common/dmtbinfo.c
new file mode 100644
index 0000000000..2ae6594d25
--- /dev/null
+++ b/usr/src/cmd/acpi/common/dmtbinfo.c
@@ -0,0 +1,2991 @@
+/******************************************************************************
+ *
+ * Module Name: dmtbinfo - Table info for non-AML tables
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2016, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include "acpi.h"
+#include "accommon.h"
+#include "acdisasm.h"
+
+/* This module used for application-level code only */
+
+#define _COMPONENT          ACPI_CA_DISASSEMBLER
+        ACPI_MODULE_NAME    ("dmtbinfo")
+
+/*
+ * How to add a new table:
+ *
+ * - Add the C table definition to the actbl1.h or actbl2.h header.
+ * - Add ACPI_xxxx_OFFSET macro(s) for the table (and subtables) to list below.
+ * - Define the table in this file (for the disassembler). If any
+ *   new data types are required (ACPI_DMT_*), see below.
+ * - Add an external declaration for the new table definition (AcpiDmTableInfo*)
+ *     in acdisam.h
+ * - Add new table definition to the dispatch table in dmtable.c (AcpiDmTableData)
+ *     If a simple table (with no subtables), no disassembly code is needed.
+ *     Otherwise, create the AcpiDmDump* function for to disassemble the table
+ *     and add it to the dmtbdump.c file.
+ * - Add an external declaration for the new AcpiDmDump* function in acdisasm.h
+ * - Add the new AcpiDmDump* function to the dispatch table in dmtable.c
+ * - Create a template for the new table
+ * - Add data table compiler support
+ *
+ * How to add a new data type (ACPI_DMT_*):
+ *
+ * - Add new type at the end of the ACPI_DMT list in acdisasm.h
+ * - Add length and implementation cases in dmtable.c  (disassembler)
+ * - Add type and length cases in dtutils.c (DT compiler)
+ */
+
+/*
+ * Macros used to generate offsets to specific table fields
+ */
+#define ACPI_FACS_OFFSET(f)             (UINT16) ACPI_OFFSET (ACPI_TABLE_FACS,f)
+#define ACPI_GAS_OFFSET(f)              (UINT16) ACPI_OFFSET (ACPI_GENERIC_ADDRESS,f)
+#define ACPI_HDR_OFFSET(f)              (UINT16) ACPI_OFFSET (ACPI_TABLE_HEADER,f)
+#define ACPI_RSDP_OFFSET(f)             (UINT16) ACPI_OFFSET (ACPI_TABLE_RSDP,f)
+#define ACPI_BERT_OFFSET(f)             (UINT16) ACPI_OFFSET (ACPI_TABLE_BERT,f)
+#define ACPI_BGRT_OFFSET(f)             (UINT16) ACPI_OFFSET (ACPI_TABLE_BGRT,f)
+#define ACPI_BOOT_OFFSET(f)             (UINT16) ACPI_OFFSET (ACPI_TABLE_BOOT,f)
+#define ACPI_CPEP_OFFSET(f)             (UINT16) ACPI_OFFSET (ACPI_TABLE_CPEP,f)
+#define ACPI_DBG2_OFFSET(f)             (UINT16) ACPI_OFFSET (ACPI_TABLE_DBG2,f)
+#define ACPI_DBGP_OFFSET(f)             (UINT16) ACPI_OFFSET (ACPI_TABLE_DBGP,f)
+#define ACPI_DMAR_OFFSET(f)             (UINT16) ACPI_OFFSET (ACPI_TABLE_DMAR,f)
+#define ACPI_DRTM_OFFSET(f)             (UINT16) ACPI_OFFSET (ACPI_TABLE_DRTM,f)
+#define ACPI_ECDT_OFFSET(f)             (UINT16) ACPI_OFFSET (ACPI_TABLE_ECDT,f)
+#define ACPI_EINJ_OFFSET(f)             (UINT16) ACPI_OFFSET (ACPI_TABLE_EINJ,f)
+#define ACPI_ERST_OFFSET(f)             (UINT16) ACPI_OFFSET (ACPI_TABLE_ERST,f)
+#define ACPI_GTDT_OFFSET(f)             (UINT16) ACPI_OFFSET (ACPI_TABLE_GTDT,f)
+#define ACPI_HEST_OFFSET(f)             (UINT16) ACPI_OFFSET (ACPI_TABLE_HEST,f)
+#define ACPI_HPET_OFFSET(f)             (UINT16) ACPI_OFFSET (ACPI_TABLE_HPET,f)
+#define ACPI_IORT_OFFSET(f)             (UINT16) ACPI_OFFSET (ACPI_TABLE_IORT,f)
+#define ACPI_IVRS_OFFSET(f)             (UINT16) ACPI_OFFSET (ACPI_TABLE_IVRS,f)
+#define ACPI_MADT_OFFSET(f)             (UINT16) ACPI_OFFSET (ACPI_TABLE_MADT,f)
+#define ACPI_MCFG_OFFSET(f)             (UINT16) ACPI_OFFSET (ACPI_TABLE_MCFG,f)
+#define ACPI_MCHI_OFFSET(f)             (UINT16) ACPI_OFFSET (ACPI_TABLE_MCHI,f)
+#define ACPI_MPST_OFFSET(f)             (UINT16) ACPI_OFFSET (ACPI_TABLE_MPST,f)
+#define ACPI_MSCT_OFFSET(f)             (UINT16) ACPI_OFFSET (ACPI_TABLE_MSCT,f)
+#define ACPI_NFIT_OFFSET(f)             (UINT16) ACPI_OFFSET (ACPI_TABLE_NFIT,f)
+#define ACPI_PCCT_OFFSET(f)             (UINT16) ACPI_OFFSET (ACPI_TABLE_PCCT,f)
+#define ACPI_PMTT_OFFSET(f)             (UINT16) ACPI_OFFSET (ACPI_TABLE_PMTT,f)
+#define ACPI_S3PT_OFFSET(f)             (UINT16) ACPI_OFFSET (ACPI_TABLE_S3PT,f)
+#define ACPI_SBST_OFFSET(f)             (UINT16) ACPI_OFFSET (ACPI_TABLE_SBST,f)
+#define ACPI_SLIT_OFFSET(f)             (UINT16) ACPI_OFFSET (ACPI_TABLE_SLIT,f)
+#define ACPI_SPCR_OFFSET(f)             (UINT16) ACPI_OFFSET (ACPI_TABLE_SPCR,f)
+#define ACPI_SPMI_OFFSET(f)             (UINT16) ACPI_OFFSET (ACPI_TABLE_SPMI,f)
+#define ACPI_SRAT_OFFSET(f)             (UINT16) ACPI_OFFSET (ACPI_TABLE_SRAT,f)
+#define ACPI_STAO_OFFSET(f)             (UINT16) ACPI_OFFSET (ACPI_TABLE_STAO,f)
+#define ACPI_TCPA_OFFSET(f)             (UINT16) ACPI_OFFSET (ACPI_TABLE_TCPA_HDR,f)
+#define ACPI_TPM2_OFFSET(f)             (UINT16) ACPI_OFFSET (ACPI_TABLE_TPM2,f)
+#define ACPI_UEFI_OFFSET(f)             (UINT16) ACPI_OFFSET (ACPI_TABLE_UEFI,f)
+#define ACPI_WAET_OFFSET(f)             (UINT16) ACPI_OFFSET (ACPI_TABLE_WAET,f)
+#define ACPI_WDAT_OFFSET(f)             (UINT16) ACPI_OFFSET (ACPI_TABLE_WDAT,f)
+#define ACPI_WDDT_OFFSET(f)             (UINT16) ACPI_OFFSET (ACPI_TABLE_WDDT,f)
+#define ACPI_WDRT_OFFSET(f)             (UINT16) ACPI_OFFSET (ACPI_TABLE_WDRT,f)
+#define ACPI_WPBT_OFFSET(f)             (UINT16) ACPI_OFFSET (ACPI_TABLE_WPBT,f)
+#define ACPI_XENV_OFFSET(f)             (UINT16) ACPI_OFFSET (ACPI_TABLE_XENV,f)
+
+/* Subtables */
+
+#define ACPI_ASF0_OFFSET(f)             (UINT16) ACPI_OFFSET (ACPI_ASF_INFO,f)
+#define ACPI_ASF1_OFFSET(f)             (UINT16) ACPI_OFFSET (ACPI_ASF_ALERT,f)
+#define ACPI_ASF1a_OFFSET(f)            (UINT16) ACPI_OFFSET (ACPI_ASF_ALERT_DATA,f)
+#define ACPI_ASF2_OFFSET(f)             (UINT16) ACPI_OFFSET (ACPI_ASF_REMOTE,f)
+#define ACPI_ASF2a_OFFSET(f)            (UINT16) ACPI_OFFSET (ACPI_ASF_CONTROL_DATA,f)
+#define ACPI_ASF3_OFFSET(f)             (UINT16) ACPI_OFFSET (ACPI_ASF_RMCP,f)
+#define ACPI_ASF4_OFFSET(f)             (UINT16) ACPI_OFFSET (ACPI_ASF_ADDRESS,f)
+#define ACPI_CPEP0_OFFSET(f)            (UINT16) ACPI_OFFSET (ACPI_CPEP_POLLING,f)
+#define ACPI_CSRT0_OFFSET(f)            (UINT16) ACPI_OFFSET (ACPI_CSRT_GROUP,f)
+#define ACPI_CSRT1_OFFSET(f)            (UINT16) ACPI_OFFSET (ACPI_CSRT_SHARED_INFO,f)
+#define ACPI_CSRT2_OFFSET(f)            (UINT16) ACPI_OFFSET (ACPI_CSRT_DESCRIPTOR,f)
+#define ACPI_DBG20_OFFSET(f)            (UINT16) ACPI_OFFSET (ACPI_DBG2_DEVICE,f)
+#define ACPI_DMARS_OFFSET(f)            (UINT16) ACPI_OFFSET (ACPI_DMAR_DEVICE_SCOPE,f)
+#define ACPI_DMAR0_OFFSET(f)            (UINT16) ACPI_OFFSET (ACPI_DMAR_HARDWARE_UNIT,f)
+#define ACPI_DMAR1_OFFSET(f)            (UINT16) ACPI_OFFSET (ACPI_DMAR_RESERVED_MEMORY,f)
+#define ACPI_DMAR2_OFFSET(f)            (UINT16) ACPI_OFFSET (ACPI_DMAR_ATSR,f)
+#define ACPI_DMAR3_OFFSET(f)            (UINT16) ACPI_OFFSET (ACPI_DMAR_RHSA,f)
+#define ACPI_DMAR4_OFFSET(f)            (UINT16) ACPI_OFFSET (ACPI_DMAR_ANDD,f)
+#define ACPI_DRTM0_OFFSET(f)            (UINT16) ACPI_OFFSET (ACPI_DRTM_VTABLE_LIST,f)
+#define ACPI_DRTM1_OFFSET(f)            (UINT16) ACPI_OFFSET (ACPI_DRTM_RESOURCE_LIST,f)
+#define ACPI_DRTM1a_OFFSET(f)           (UINT16) ACPI_OFFSET (ACPI_DRTM_RESOURCE,f)
+#define ACPI_DRTM2_OFFSET(f)            (UINT16) ACPI_OFFSET (ACPI_DRTM_DPS_ID,f)
+#define ACPI_EINJ0_OFFSET(f)            (UINT16) ACPI_OFFSET (ACPI_WHEA_HEADER,f)
+#define ACPI_ERST0_OFFSET(f)            (UINT16) ACPI_OFFSET (ACPI_WHEA_HEADER,f)
+#define ACPI_FPDTH_OFFSET(f)            (UINT16) ACPI_OFFSET (ACPI_FPDT_HEADER,f)
+#define ACPI_FPDT0_OFFSET(f)            (UINT16) ACPI_OFFSET (ACPI_FPDT_BOOT_POINTER,f)
+#define ACPI_FPDT1_OFFSET(f)            (UINT16) ACPI_OFFSET (ACPI_FPDT_S3PT_POINTER,f)
+#define ACPI_GTDT0_OFFSET(f)            (UINT16) ACPI_OFFSET (ACPI_GTDT_TIMER_BLOCK,f)
+#define ACPI_GTDT0a_OFFSET(f)           (UINT16) ACPI_OFFSET (ACPI_GTDT_TIMER_ENTRY,f)
+#define ACPI_GTDT1_OFFSET(f)            (UINT16) ACPI_OFFSET (ACPI_GTDT_WATCHDOG,f)
+#define ACPI_GTDTH_OFFSET(f)            (UINT16) ACPI_OFFSET (ACPI_GTDT_HEADER,f)
+#define ACPI_HEST0_OFFSET(f)            (UINT16) ACPI_OFFSET (ACPI_HEST_IA_MACHINE_CHECK,f)
+#define ACPI_HEST1_OFFSET(f)            (UINT16) ACPI_OFFSET (ACPI_HEST_IA_CORRECTED,f)
+#define ACPI_HEST2_OFFSET(f)            (UINT16) ACPI_OFFSET (ACPI_HEST_IA_NMI,f)
+#define ACPI_HEST6_OFFSET(f)            (UINT16) ACPI_OFFSET (ACPI_HEST_AER_ROOT,f)
+#define ACPI_HEST7_OFFSET(f)            (UINT16) ACPI_OFFSET (ACPI_HEST_AER,f)
+#define ACPI_HEST8_OFFSET(f)            (UINT16) ACPI_OFFSET (ACPI_HEST_AER_BRIDGE,f)
+#define ACPI_HEST9_OFFSET(f)            (UINT16) ACPI_OFFSET (ACPI_HEST_GENERIC,f)
+#define ACPI_HEST10_OFFSET(f)           (UINT16) ACPI_OFFSET (ACPI_HEST_GENERIC_V2,f)
+#define ACPI_HESTN_OFFSET(f)            (UINT16) ACPI_OFFSET (ACPI_HEST_NOTIFY,f)
+#define ACPI_HESTB_OFFSET(f)            (UINT16) ACPI_OFFSET (ACPI_HEST_IA_ERROR_BANK,f)
+#define ACPI_IORT0_OFFSET(f)            (UINT16) ACPI_OFFSET (ACPI_IORT_ITS_GROUP,f)
+#define ACPI_IORT1_OFFSET(f)            (UINT16) ACPI_OFFSET (ACPI_IORT_NAMED_COMPONENT,f)
+#define ACPI_IORT2_OFFSET(f)            (UINT16) ACPI_OFFSET (ACPI_IORT_ROOT_COMPLEX,f)
+#define ACPI_IORT3_OFFSET(f)            (UINT16) ACPI_OFFSET (ACPI_IORT_SMMU,f)
+#define ACPI_IORT4_OFFSET(f)            (UINT16) ACPI_OFFSET (ACPI_IORT_SMMU_V3,f)
+#define ACPI_IORTA_OFFSET(f)            (UINT16) ACPI_OFFSET (ACPI_IORT_MEMORY_ACCESS,f)
+#define ACPI_IORTH_OFFSET(f)            (UINT16) ACPI_OFFSET (ACPI_IORT_NODE,f)
+#define ACPI_IORTM_OFFSET(f)            (UINT16) ACPI_OFFSET (ACPI_IORT_ID_MAPPING,f)
+#define ACPI_IVRSH_OFFSET(f)            (UINT16) ACPI_OFFSET (ACPI_IVRS_HEADER,f)
+#define ACPI_IVRS0_OFFSET(f)            (UINT16) ACPI_OFFSET (ACPI_IVRS_HARDWARE,f)
+#define ACPI_IVRS1_OFFSET(f)            (UINT16) ACPI_OFFSET (ACPI_IVRS_MEMORY,f)
+#define ACPI_IVRSD_OFFSET(f)            (UINT16) ACPI_OFFSET (ACPI_IVRS_DE_HEADER,f)
+#define ACPI_IVRS8A_OFFSET(f)           (UINT16) ACPI_OFFSET (ACPI_IVRS_DEVICE8A,f)
+#define ACPI_IVRS8B_OFFSET(f)           (UINT16) ACPI_OFFSET (ACPI_IVRS_DEVICE8B,f)
+#define ACPI_IVRS8C_OFFSET(f)           (UINT16) ACPI_OFFSET (ACPI_IVRS_DEVICE8C,f)
+#define ACPI_LPITH_OFFSET(f)            (UINT16) ACPI_OFFSET (ACPI_LPIT_HEADER,f)
+#define ACPI_LPIT0_OFFSET(f)            (UINT16) ACPI_OFFSET (ACPI_LPIT_NATIVE,f)
+#define ACPI_MADT0_OFFSET(f)            (UINT16) ACPI_OFFSET (ACPI_MADT_LOCAL_APIC,f)
+#define ACPI_MADT1_OFFSET(f)            (UINT16) ACPI_OFFSET (ACPI_MADT_IO_APIC,f)
+#define ACPI_MADT2_OFFSET(f)            (UINT16) ACPI_OFFSET (ACPI_MADT_INTERRUPT_OVERRIDE,f)
+#define ACPI_MADT3_OFFSET(f)            (UINT16) ACPI_OFFSET (ACPI_MADT_NMI_SOURCE,f)
+#define ACPI_MADT4_OFFSET(f)            (UINT16) ACPI_OFFSET (ACPI_MADT_LOCAL_APIC_NMI,f)
+#define ACPI_MADT5_OFFSET(f)            (UINT16) ACPI_OFFSET (ACPI_MADT_LOCAL_APIC_OVERRIDE,f)
+#define ACPI_MADT6_OFFSET(f)            (UINT16) ACPI_OFFSET (ACPI_MADT_IO_SAPIC,f)
+#define ACPI_MADT7_OFFSET(f)            (UINT16) ACPI_OFFSET (ACPI_MADT_LOCAL_SAPIC,f)
+#define ACPI_MADT8_OFFSET(f)            (UINT16) ACPI_OFFSET (ACPI_MADT_INTERRUPT_SOURCE,f)
+#define ACPI_MADT9_OFFSET(f)            (UINT16) ACPI_OFFSET (ACPI_MADT_LOCAL_X2APIC,f)
+#define ACPI_MADT10_OFFSET(f)           (UINT16) ACPI_OFFSET (ACPI_MADT_LOCAL_X2APIC_NMI,f)
+#define ACPI_MADT11_OFFSET(f)           (UINT16) ACPI_OFFSET (ACPI_MADT_GENERIC_INTERRUPT,f)
+#define ACPI_MADT12_OFFSET(f)           (UINT16) ACPI_OFFSET (ACPI_MADT_GENERIC_DISTRIBUTOR,f)
+#define ACPI_MADT13_OFFSET(f)           (UINT16) ACPI_OFFSET (ACPI_MADT_GENERIC_MSI_FRAME,f)
+#define ACPI_MADT14_OFFSET(f)           (UINT16) ACPI_OFFSET (ACPI_MADT_GENERIC_REDISTRIBUTOR,f)
+#define ACPI_MADT15_OFFSET(f)           (UINT16) ACPI_OFFSET (ACPI_MADT_GENERIC_TRANSLATOR,f)
+#define ACPI_MADTH_OFFSET(f)            (UINT16) ACPI_OFFSET (ACPI_SUBTABLE_HEADER,f)
+#define ACPI_MCFG0_OFFSET(f)            (UINT16) ACPI_OFFSET (ACPI_MCFG_ALLOCATION,f)
+#define ACPI_MPST0_OFFSET(f)            (UINT16) ACPI_OFFSET (ACPI_MPST_POWER_NODE,f)
+#define ACPI_MPST0A_OFFSET(f)           (UINT16) ACPI_OFFSET (ACPI_MPST_POWER_STATE,f)
+#define ACPI_MPST0B_OFFSET(f)           (UINT16) ACPI_OFFSET (ACPI_MPST_COMPONENT,f)
+#define ACPI_MPST1_OFFSET(f)            (UINT16) ACPI_OFFSET (ACPI_MPST_DATA_HDR,f)
+#define ACPI_MPST2_OFFSET(f)            (UINT16) ACPI_OFFSET (ACPI_MPST_POWER_DATA,f)
+#define ACPI_MSCT0_OFFSET(f)            (UINT16) ACPI_OFFSET (ACPI_MSCT_PROXIMITY,f)
+#define ACPI_MTMR0_OFFSET(f)            (UINT16) ACPI_OFFSET (ACPI_MTMR_ENTRY,f)
+#define ACPI_NFITH_OFFSET(f)            (UINT16) ACPI_OFFSET (ACPI_NFIT_HEADER,f)
+#define ACPI_NFIT0_OFFSET(f)            (UINT16) ACPI_OFFSET (ACPI_NFIT_SYSTEM_ADDRESS,f)
+#define ACPI_NFIT1_OFFSET(f)            (UINT16) ACPI_OFFSET (ACPI_NFIT_MEMORY_MAP,f)
+#define ACPI_NFIT2_OFFSET(f)            (UINT16) ACPI_OFFSET (ACPI_NFIT_INTERLEAVE,f)
+#define ACPI_NFIT3_OFFSET(f)            (UINT16) ACPI_OFFSET (ACPI_NFIT_SMBIOS,f)
+#define ACPI_NFIT4_OFFSET(f)            (UINT16) ACPI_OFFSET (ACPI_NFIT_CONTROL_REGION,f)
+#define ACPI_NFIT5_OFFSET(f)            (UINT16) ACPI_OFFSET (ACPI_NFIT_DATA_REGION,f)
+#define ACPI_NFIT6_OFFSET(f)            (UINT16) ACPI_OFFSET (ACPI_NFIT_FLUSH_ADDRESS,f)
+#define ACPI_PCCT0_OFFSET(f)            (UINT16) ACPI_OFFSET (ACPI_PCCT_SUBSPACE,f)
+#define ACPI_PCCT1_OFFSET(f)            (UINT16) ACPI_OFFSET (ACPI_PCCT_HW_REDUCED,f)
+#define ACPI_PCCT2_OFFSET(f)            (UINT16) ACPI_OFFSET (ACPI_PCCT_HW_REDUCED_TYPE2,f)
+#define ACPI_PMTT0_OFFSET(f)            (UINT16) ACPI_OFFSET (ACPI_PMTT_SOCKET,f)
+#define ACPI_PMTT1_OFFSET(f)            (UINT16) ACPI_OFFSET (ACPI_PMTT_CONTROLLER,f)
+#define ACPI_PMTT1A_OFFSET(f)           (UINT16) ACPI_OFFSET (ACPI_PMTT_DOMAIN,f)
+#define ACPI_PMTT2_OFFSET(f)            (UINT16) ACPI_OFFSET (ACPI_PMTT_PHYSICAL_COMPONENT,f)
+#define ACPI_PMTTH_OFFSET(f)            (UINT16) ACPI_OFFSET (ACPI_PMTT_HEADER,f)
+#define ACPI_S3PTH_OFFSET(f)            (UINT16) ACPI_OFFSET (ACPI_FPDT_HEADER,f)
+#define ACPI_S3PT0_OFFSET(f)            (UINT16) ACPI_OFFSET (ACPI_S3PT_RESUME,f)
+#define ACPI_S3PT1_OFFSET(f)            (UINT16) ACPI_OFFSET (ACPI_S3PT_SUSPEND,f)
+#define ACPI_SLIC_OFFSET(f)             (UINT16) ACPI_OFFSET (ACPI_TABLE_SLIC,f)
+#define ACPI_SRATH_OFFSET(f)            (UINT16) ACPI_OFFSET (ACPI_SUBTABLE_HEADER,f)
+#define ACPI_SRAT0_OFFSET(f)            (UINT16) ACPI_OFFSET (ACPI_SRAT_CPU_AFFINITY,f)
+#define ACPI_SRAT1_OFFSET(f)            (UINT16) ACPI_OFFSET (ACPI_SRAT_MEM_AFFINITY,f)
+#define ACPI_SRAT2_OFFSET(f)            (UINT16) ACPI_OFFSET (ACPI_SRAT_X2APIC_CPU_AFFINITY,f)
+#define ACPI_SRAT3_OFFSET(f)            (UINT16) ACPI_OFFSET (ACPI_SRAT_GICC_AFFINITY,f)
+#define ACPI_TCPA_CLIENT_OFFSET(f)      (UINT16) ACPI_OFFSET (ACPI_TABLE_TCPA_CLIENT,f)
+#define ACPI_TCPA_SERVER_OFFSET(f)      (UINT16) ACPI_OFFSET (ACPI_TABLE_TCPA_SERVER,f)
+#define ACPI_VRTC0_OFFSET(f)            (UINT16) ACPI_OFFSET (ACPI_VRTC_ENTRY,f)
+#define ACPI_WDAT0_OFFSET(f)            (UINT16) ACPI_OFFSET (ACPI_WDAT_ENTRY,f)
+
+/*
+ * Simplify access to flag fields by breaking them up into bytes
+ */
+#define ACPI_FLAG_OFFSET(d,f,o)         (UINT16) (ACPI_OFFSET (d,f) + o)
+
+/* Flags */
+
+#define ACPI_DRTM_FLAG_OFFSET(f,o)      ACPI_FLAG_OFFSET (ACPI_TABLE_DRTM,f,o)
+#define ACPI_DRTM1a_FLAG_OFFSET(f,o)    ACPI_FLAG_OFFSET (ACPI_DRTM_RESOURCE,f,o)
+#define ACPI_FADT_FLAG_OFFSET(f,o)      ACPI_FLAG_OFFSET (ACPI_TABLE_FADT,f,o)
+#define ACPI_FACS_FLAG_OFFSET(f,o)      ACPI_FLAG_OFFSET (ACPI_TABLE_FACS,f,o)
+#define ACPI_HPET_FLAG_OFFSET(f,o)      ACPI_FLAG_OFFSET (ACPI_TABLE_HPET,f,o)
+#define ACPI_SRAT0_FLAG_OFFSET(f,o)     ACPI_FLAG_OFFSET (ACPI_SRAT_CPU_AFFINITY,f,o)
+#define ACPI_SRAT1_FLAG_OFFSET(f,o)     ACPI_FLAG_OFFSET (ACPI_SRAT_MEM_AFFINITY,f,o)
+#define ACPI_SRAT2_FLAG_OFFSET(f,o)     ACPI_FLAG_OFFSET (ACPI_SRAT_X2APIC_CPU_AFFINITY,f,o)
+#define ACPI_SRAT3_FLAG_OFFSET(f,o)     ACPI_FLAG_OFFSET (ACPI_SRAT_GICC_AFFINITY,f,o)
+#define ACPI_GTDT_FLAG_OFFSET(f,o)      ACPI_FLAG_OFFSET (ACPI_TABLE_GTDT,f,o)
+#define ACPI_GTDT0a_FLAG_OFFSET(f,o)    ACPI_FLAG_OFFSET (ACPI_GTDT_TIMER_ENTRY,f,o)
+#define ACPI_GTDT1_FLAG_OFFSET(f,o)     ACPI_FLAG_OFFSET (ACPI_GTDT_WATCHDOG,f,o)
+#define ACPI_IORT3_FLAG_OFFSET(f,o)     ACPI_FLAG_OFFSET (ACPI_IORT_SMMU,f,o)
+#define ACPI_IORT4_FLAG_OFFSET(f,o)     ACPI_FLAG_OFFSET (ACPI_IORT_SMMU_V3,f,o)
+#define ACPI_IORTA_FLAG_OFFSET(f,o)     ACPI_FLAG_OFFSET (ACPI_IORT_MEMORY_ACCESS,f,o)
+#define ACPI_IORTM_FLAG_OFFSET(f,o)     ACPI_FLAG_OFFSET (ACPI_IORT_ID_MAPPING,f,o)
+#define ACPI_LPITH_FLAG_OFFSET(f,o)     ACPI_FLAG_OFFSET (ACPI_LPIT_HEADER,f,o)
+#define ACPI_MADT_FLAG_OFFSET(f,o)      ACPI_FLAG_OFFSET (ACPI_TABLE_MADT,f,o)
+#define ACPI_MADT0_FLAG_OFFSET(f,o)     ACPI_FLAG_OFFSET (ACPI_MADT_LOCAL_APIC,f,o)
+#define ACPI_MADT2_FLAG_OFFSET(f,o)     ACPI_FLAG_OFFSET (ACPI_MADT_INTERRUPT_OVERRIDE,f,o)
+#define ACPI_MADT3_FLAG_OFFSET(f,o)     ACPI_FLAG_OFFSET (ACPI_MADT_NMI_SOURCE,f,o)
+#define ACPI_MADT4_FLAG_OFFSET(f,o)     ACPI_FLAG_OFFSET (ACPI_MADT_LOCAL_APIC_NMI,f,o)
+#define ACPI_MADT7_FLAG_OFFSET(f,o)     ACPI_FLAG_OFFSET (ACPI_MADT_LOCAL_SAPIC,f,o)
+#define ACPI_MADT8_FLAG_OFFSET(f,o)     ACPI_FLAG_OFFSET (ACPI_MADT_INTERRUPT_SOURCE,f,o)
+#define ACPI_MADT9_FLAG_OFFSET(f,o)     ACPI_FLAG_OFFSET (ACPI_MADT_LOCAL_X2APIC,f,o)
+#define ACPI_MADT10_FLAG_OFFSET(f,o)    ACPI_FLAG_OFFSET (ACPI_MADT_LOCAL_X2APIC_NMI,f,o)
+#define ACPI_MADT11_FLAG_OFFSET(f,o)    ACPI_FLAG_OFFSET (ACPI_MADT_GENERIC_INTERRUPT,f,o)
+#define ACPI_MADT13_FLAG_OFFSET(f,o)    ACPI_FLAG_OFFSET (ACPI_MADT_GENERIC_MSI_FRAME,f,o)
+#define ACPI_MPST0_FLAG_OFFSET(f,o)     ACPI_FLAG_OFFSET (ACPI_MPST_POWER_NODE,f,o)
+#define ACPI_MPST2_FLAG_OFFSET(f,o)     ACPI_FLAG_OFFSET (ACPI_MPST_POWER_DATA,f,o)
+#define ACPI_NFIT0_FLAG_OFFSET(f,o)     ACPI_FLAG_OFFSET (ACPI_NFIT_SYSTEM_ADDRESS,f,o)
+#define ACPI_NFIT1_FLAG_OFFSET(f,o)     ACPI_FLAG_OFFSET (ACPI_NFIT_MEMORY_MAP,f,o)
+#define ACPI_NFIT4_FLAG_OFFSET(f,o)     ACPI_FLAG_OFFSET (ACPI_NFIT_CONTROL_REGION,f,o)
+#define ACPI_PCCT_FLAG_OFFSET(f,o)      ACPI_FLAG_OFFSET (ACPI_TABLE_PCCT,f,o)
+#define ACPI_PCCT1_FLAG_OFFSET(f,o)     ACPI_FLAG_OFFSET (ACPI_PCCT_HW_REDUCED,f,o)
+#define ACPI_PCCT2_FLAG_OFFSET(f,o)     ACPI_FLAG_OFFSET (ACPI_PCCT_HW_REDUCED_TYPE2,f,o)
+#define ACPI_PMTTH_FLAG_OFFSET(f,o)     ACPI_FLAG_OFFSET (ACPI_PMTT_HEADER,f,o)
+#define ACPI_WDDT_FLAG_OFFSET(f,o)      ACPI_FLAG_OFFSET (ACPI_TABLE_WDDT,f,o)
+#define ACPI_EINJ0_FLAG_OFFSET(f,o)     ACPI_FLAG_OFFSET (ACPI_WHEA_HEADER,f,o)
+#define ACPI_ERST0_FLAG_OFFSET(f,o)     ACPI_FLAG_OFFSET (ACPI_WHEA_HEADER,f,o)
+#define ACPI_HEST0_FLAG_OFFSET(f,o)     ACPI_FLAG_OFFSET (ACPI_HEST_IA_MACHINE_CHECK,f,o)
+#define ACPI_HEST1_FLAG_OFFSET(f,o)     ACPI_FLAG_OFFSET (ACPI_HEST_IA_CORRECTED,f,o)
+#define ACPI_HEST6_FLAG_OFFSET(f,o)     ACPI_FLAG_OFFSET (ACPI_HEST_AER_ROOT,f,o)
+
+/*
+ * Required terminator for all tables below
+ */
+#define ACPI_DMT_TERMINATOR             {ACPI_DMT_EXIT, 0, NULL, 0}
+#define ACPI_DMT_NEW_LINE               {ACPI_DMT_EXTRA_TEXT, 0, "\n", 0}
+
+
+/*
+ * ACPI Table Information, used to dump formatted ACPI tables
+ *
+ * Each entry is of the form:  <Field Type, Field Offset, Field Name>
+ */
+
+/*******************************************************************************
+ *
+ * Common ACPI table header
+ *
+ ******************************************************************************/
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoHeader[] =
+{
+    {ACPI_DMT_SIG,      ACPI_HDR_OFFSET (Signature[0]),             "Signature", 0},
+    {ACPI_DMT_UINT32,   ACPI_HDR_OFFSET (Length),                   "Table Length", DT_LENGTH},
+    {ACPI_DMT_UINT8,    ACPI_HDR_OFFSET (Revision),                 "Revision", 0},
+    {ACPI_DMT_CHKSUM,   ACPI_HDR_OFFSET (Checksum),                 "Checksum", 0},
+    {ACPI_DMT_NAME6,    ACPI_HDR_OFFSET (OemId[0]),                 "Oem ID", 0},
+    {ACPI_DMT_NAME8,    ACPI_HDR_OFFSET (OemTableId[0]),            "Oem Table ID", 0},
+    {ACPI_DMT_UINT32,   ACPI_HDR_OFFSET (OemRevision),              "Oem Revision", 0},
+    {ACPI_DMT_NAME4,    ACPI_HDR_OFFSET (AslCompilerId[0]),         "Asl Compiler ID", 0},
+    {ACPI_DMT_UINT32,   ACPI_HDR_OFFSET (AslCompilerRevision),      "Asl Compiler Revision", 0},
+    ACPI_DMT_TERMINATOR
+};
+
+
+/*******************************************************************************
+ *
+ * GAS - Generic Address Structure
+ *
+ ******************************************************************************/
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoGas[] =
+{
+    {ACPI_DMT_SPACEID,  ACPI_GAS_OFFSET (SpaceId),                  "Space ID", 0},
+    {ACPI_DMT_UINT8,    ACPI_GAS_OFFSET (BitWidth),                 "Bit Width", 0},
+    {ACPI_DMT_UINT8,    ACPI_GAS_OFFSET (BitOffset),                "Bit Offset", 0},
+    {ACPI_DMT_ACCWIDTH, ACPI_GAS_OFFSET (AccessWidth),              "Encoded Access Width", 0},
+    {ACPI_DMT_UINT64,   ACPI_GAS_OFFSET (Address),                  "Address", 0},
+    ACPI_DMT_TERMINATOR
+};
+
+
+/*******************************************************************************
+ *
+ * RSDP - Root System Description Pointer (Signature is "RSD PTR ")
+ *
+ ******************************************************************************/
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoRsdp1[] =
+{
+    {ACPI_DMT_NAME8,    ACPI_RSDP_OFFSET (Signature[0]),            "Signature", 0},
+    {ACPI_DMT_UINT8,    ACPI_RSDP_OFFSET (Checksum),                "Checksum", 0},
+    {ACPI_DMT_NAME6,    ACPI_RSDP_OFFSET (OemId[0]),                "Oem ID", 0},
+    {ACPI_DMT_UINT8,    ACPI_RSDP_OFFSET (Revision),                "Revision", 0},
+    {ACPI_DMT_UINT32,   ACPI_RSDP_OFFSET (RsdtPhysicalAddress),     "RSDT Address", 0},
+    ACPI_DMT_TERMINATOR
+};
+
+/* ACPI 2.0+ Extensions */
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoRsdp2[] =
+{
+    {ACPI_DMT_UINT32,   ACPI_RSDP_OFFSET (Length),                  "Length", DT_LENGTH},
+    {ACPI_DMT_UINT64,   ACPI_RSDP_OFFSET (XsdtPhysicalAddress),     "XSDT Address", 0},
+    {ACPI_DMT_UINT8,    ACPI_RSDP_OFFSET (ExtendedChecksum),        "Extended Checksum", 0},
+    {ACPI_DMT_UINT24,   ACPI_RSDP_OFFSET (Reserved[0]),             "Reserved", 0},
+    ACPI_DMT_TERMINATOR
+};
+
+
+/*******************************************************************************
+ *
+ * FACS - Firmware ACPI Control Structure
+ *
+ ******************************************************************************/
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoFacs[] =
+{
+    {ACPI_DMT_NAME4,    ACPI_FACS_OFFSET (Signature[0]),            "Signature", 0},
+    {ACPI_DMT_UINT32,   ACPI_FACS_OFFSET (Length),                  "Length", DT_LENGTH},
+    {ACPI_DMT_UINT32,   ACPI_FACS_OFFSET (HardwareSignature),       "Hardware Signature", 0},
+    {ACPI_DMT_UINT32,   ACPI_FACS_OFFSET (FirmwareWakingVector),    "32 Firmware Waking Vector", 0},
+    {ACPI_DMT_UINT32,   ACPI_FACS_OFFSET (GlobalLock),              "Global Lock", 0},
+    {ACPI_DMT_UINT32,   ACPI_FACS_OFFSET (Flags),                   "Flags (decoded below)", DT_FLAG},
+    {ACPI_DMT_FLAG0,    ACPI_FACS_FLAG_OFFSET (Flags,0),            "S4BIOS Support Present", 0},
+    {ACPI_DMT_FLAG1,    ACPI_FACS_FLAG_OFFSET (Flags,0),            "64-bit Wake Supported (V2)", 0},
+    {ACPI_DMT_UINT64,   ACPI_FACS_OFFSET (XFirmwareWakingVector),   "64 Firmware Waking Vector", 0},
+    {ACPI_DMT_UINT8,    ACPI_FACS_OFFSET (Version),                 "Version", 0},
+    {ACPI_DMT_UINT24,   ACPI_FACS_OFFSET (Reserved[0]),             "Reserved", 0},
+    {ACPI_DMT_UINT32,   ACPI_FACS_OFFSET (OspmFlags),               "OspmFlags (decoded below)", DT_FLAG},
+    {ACPI_DMT_FLAG0,    ACPI_FACS_FLAG_OFFSET (OspmFlags,0),        "64-bit Wake Env Required (V2)", 0},
+    ACPI_DMT_TERMINATOR
+};
+
+
+/*******************************************************************************
+ *
+ * FADT - Fixed ACPI Description Table (Signature is FACP)
+ *
+ ******************************************************************************/
+
+/* ACPI 1.0 FADT (Version 1) */
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoFadt1[] =
+{
+    {ACPI_DMT_UINT32,   ACPI_FADT_OFFSET (Facs),                    "FACS Address", 0},
+    {ACPI_DMT_UINT32,   ACPI_FADT_OFFSET (Dsdt),                    "DSDT Address", DT_NON_ZERO},
+    {ACPI_DMT_UINT8,    ACPI_FADT_OFFSET (Model),                   "Model", 0},
+    {ACPI_DMT_FADTPM,   ACPI_FADT_OFFSET (PreferredProfile),        "PM Profile", 0},
+    {ACPI_DMT_UINT16,   ACPI_FADT_OFFSET (SciInterrupt),            "SCI Interrupt", 0},
+    {ACPI_DMT_UINT32,   ACPI_FADT_OFFSET (SmiCommand),              "SMI Command Port", 0},
+    {ACPI_DMT_UINT8,    ACPI_FADT_OFFSET (AcpiEnable),              "ACPI Enable Value", 0},
+    {ACPI_DMT_UINT8,    ACPI_FADT_OFFSET (AcpiDisable),             "ACPI Disable Value", 0},
+    {ACPI_DMT_UINT8,    ACPI_FADT_OFFSET (S4BiosRequest),           "S4BIOS Command", 0},
+    {ACPI_DMT_UINT8,    ACPI_FADT_OFFSET (PstateControl),           "P-State Control", 0},
+    {ACPI_DMT_UINT32,   ACPI_FADT_OFFSET (Pm1aEventBlock),          "PM1A Event Block Address", 0},
+    {ACPI_DMT_UINT32,   ACPI_FADT_OFFSET (Pm1bEventBlock),          "PM1B Event Block Address", 0},
+    {ACPI_DMT_UINT32,   ACPI_FADT_OFFSET (Pm1aControlBlock),        "PM1A Control Block Address", 0},
+    {ACPI_DMT_UINT32,   ACPI_FADT_OFFSET (Pm1bControlBlock),        "PM1B Control Block Address", 0},
+    {ACPI_DMT_UINT32,   ACPI_FADT_OFFSET (Pm2ControlBlock),         "PM2 Control Block Address", 0},
+    {ACPI_DMT_UINT32,   ACPI_FADT_OFFSET (PmTimerBlock),            "PM Timer Block Address", 0},
+    {ACPI_DMT_UINT32,   ACPI_FADT_OFFSET (Gpe0Block),               "GPE0 Block Address", 0},
+    {ACPI_DMT_UINT32,   ACPI_FADT_OFFSET (Gpe1Block),               "GPE1 Block Address", 0},
+    {ACPI_DMT_UINT8,    ACPI_FADT_OFFSET (Pm1EventLength),          "PM1 Event Block Length", 0},
+    {ACPI_DMT_UINT8,    ACPI_FADT_OFFSET (Pm1ControlLength),        "PM1 Control Block Length", 0},
+    {ACPI_DMT_UINT8,    ACPI_FADT_OFFSET (Pm2ControlLength),        "PM2 Control Block Length", 0},
+    {ACPI_DMT_UINT8,    ACPI_FADT_OFFSET (PmTimerLength),           "PM Timer Block Length", 0},
+    {ACPI_DMT_UINT8,    ACPI_FADT_OFFSET (Gpe0BlockLength),         "GPE0 Block Length", 0},
+    {ACPI_DMT_UINT8,    ACPI_FADT_OFFSET (Gpe1BlockLength),         "GPE1 Block Length", 0},
+    {ACPI_DMT_UINT8,    ACPI_FADT_OFFSET (Gpe1Base),                "GPE1 Base Offset", 0},
+    {ACPI_DMT_UINT8,    ACPI_FADT_OFFSET (CstControl),              "_CST Support", 0},
+    {ACPI_DMT_UINT16,   ACPI_FADT_OFFSET (C2Latency),               "C2 Latency", 0},
+    {ACPI_DMT_UINT16,   ACPI_FADT_OFFSET (C3Latency),               "C3 Latency", 0},
+    {ACPI_DMT_UINT16,   ACPI_FADT_OFFSET (FlushSize),               "CPU Cache Size", 0},
+    {ACPI_DMT_UINT16,   ACPI_FADT_OFFSET (FlushStride),             "Cache Flush Stride", 0},
+    {ACPI_DMT_UINT8,    ACPI_FADT_OFFSET (DutyOffset),              "Duty Cycle Offset", 0},
+    {ACPI_DMT_UINT8,    ACPI_FADT_OFFSET (DutyWidth),               "Duty Cycle Width", 0},
+    {ACPI_DMT_UINT8,    ACPI_FADT_OFFSET (DayAlarm),                "RTC Day Alarm Index", 0},
+    {ACPI_DMT_UINT8,    ACPI_FADT_OFFSET (MonthAlarm),              "RTC Month Alarm Index", 0},
+    {ACPI_DMT_UINT8,    ACPI_FADT_OFFSET (Century),                 "RTC Century Index", 0},
+    {ACPI_DMT_UINT16,   ACPI_FADT_OFFSET (BootFlags),               "Boot Flags (decoded below)", DT_FLAG},
+
+    /* Boot Architecture Flags byte 0 */
+
+    {ACPI_DMT_FLAG0,    ACPI_FADT_FLAG_OFFSET (BootFlags,0),        "Legacy Devices Supported (V2)", 0},
+    {ACPI_DMT_FLAG1,    ACPI_FADT_FLAG_OFFSET (BootFlags,0),        "8042 Present on ports 60/64 (V2)", 0},
+    {ACPI_DMT_FLAG2,    ACPI_FADT_FLAG_OFFSET (BootFlags,0),        "VGA Not Present (V4)", 0},
+    {ACPI_DMT_FLAG3,    ACPI_FADT_FLAG_OFFSET (BootFlags,0),        "MSI Not Supported (V4)", 0},
+    {ACPI_DMT_FLAG4,    ACPI_FADT_FLAG_OFFSET (BootFlags,0),        "PCIe ASPM Not Supported (V4)", 0},
+    {ACPI_DMT_FLAG5,    ACPI_FADT_FLAG_OFFSET (BootFlags,0),        "CMOS RTC Not Present (V5)", 0},
+
+    {ACPI_DMT_UINT8,    ACPI_FADT_OFFSET (Reserved),                "Reserved", 0},
+    {ACPI_DMT_UINT32,   ACPI_FADT_OFFSET (Flags),                   "Flags (decoded below)", DT_FLAG},
+
+    /* Flags byte 0 */
+
+    {ACPI_DMT_FLAG0,    ACPI_FADT_FLAG_OFFSET (Flags,0),            "WBINVD instruction is operational (V1)", 0},
+    {ACPI_DMT_FLAG1,    ACPI_FADT_FLAG_OFFSET (Flags,0),            "WBINVD flushes all caches (V1)", 0},
+    {ACPI_DMT_FLAG2,    ACPI_FADT_FLAG_OFFSET (Flags,0),            "All CPUs support C1 (V1)", 0},
+    {ACPI_DMT_FLAG3,    ACPI_FADT_FLAG_OFFSET (Flags,0),            "C2 works on MP system (V1)", 0},
+    {ACPI_DMT_FLAG4,    ACPI_FADT_FLAG_OFFSET (Flags,0),            "Control Method Power Button (V1)", 0},
+    {ACPI_DMT_FLAG5,    ACPI_FADT_FLAG_OFFSET (Flags,0),            "Control Method Sleep Button (V1)", 0},
+    {ACPI_DMT_FLAG6,    ACPI_FADT_FLAG_OFFSET (Flags,0),            "RTC wake not in fixed reg space (V1)", 0},
+    {ACPI_DMT_FLAG7,    ACPI_FADT_FLAG_OFFSET (Flags,0),            "RTC can wake system from S4 (V1)", 0},
+
+    /* Flags byte 1 */
+
+    {ACPI_DMT_FLAG0,    ACPI_FADT_FLAG_OFFSET (Flags,1),            "32-bit PM Timer (V1)", 0},
+    {ACPI_DMT_FLAG1,    ACPI_FADT_FLAG_OFFSET (Flags,1),            "Docking Supported (V1)", 0},
+    {ACPI_DMT_FLAG2,    ACPI_FADT_FLAG_OFFSET (Flags,1),            "Reset Register Supported (V2)", 0},
+    {ACPI_DMT_FLAG3,    ACPI_FADT_FLAG_OFFSET (Flags,1),            "Sealed Case (V3)", 0},
+    {ACPI_DMT_FLAG4,    ACPI_FADT_FLAG_OFFSET (Flags,1),            "Headless - No Video (V3)", 0},
+    {ACPI_DMT_FLAG5,    ACPI_FADT_FLAG_OFFSET (Flags,1),            "Use native instr after SLP_TYPx (V3)", 0},
+    {ACPI_DMT_FLAG6,    ACPI_FADT_FLAG_OFFSET (Flags,1),            "PCIEXP_WAK Bits Supported (V4)", 0},
+    {ACPI_DMT_FLAG7,    ACPI_FADT_FLAG_OFFSET (Flags,1),            "Use Platform Timer (V4)", 0},
+
+    /* Flags byte 2 */
+
+    {ACPI_DMT_FLAG0,    ACPI_FADT_FLAG_OFFSET (Flags,2),            "RTC_STS valid on S4 wake (V4)", 0},
+    {ACPI_DMT_FLAG1,    ACPI_FADT_FLAG_OFFSET (Flags,2),            "Remote Power-on capable (V4)", 0},
+    {ACPI_DMT_FLAG2,    ACPI_FADT_FLAG_OFFSET (Flags,2),            "Use APIC Cluster Model (V4)", 0},
+    {ACPI_DMT_FLAG3,    ACPI_FADT_FLAG_OFFSET (Flags,2),            "Use APIC Physical Destination Mode (V4)", 0},
+    {ACPI_DMT_FLAG4,    ACPI_FADT_FLAG_OFFSET (Flags,2),            "Hardware Reduced (V5)", 0},
+    {ACPI_DMT_FLAG5,    ACPI_FADT_FLAG_OFFSET (Flags,2),            "Low Power S0 Idle (V5)", 0},
+    ACPI_DMT_TERMINATOR
+};
+
+/* ACPI 1.0 MS Extensions (FADT version 2) */
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoFadt2[] =
+{
+    {ACPI_DMT_GAS,      ACPI_FADT_OFFSET (ResetRegister),           "Reset Register", 0},
+    {ACPI_DMT_UINT8,    ACPI_FADT_OFFSET (ResetValue),              "Value to cause reset", 0},
+    {ACPI_DMT_UINT16,   ACPI_FADT_OFFSET (ArmBootFlags),            "Reserved", 0},
+    {ACPI_DMT_UINT8,    ACPI_FADT_OFFSET (MinorRevision),           "Reserved", 0},
+    ACPI_DMT_TERMINATOR
+};
+
+/* ACPI 2.0+ Extensions (FADT version 3, 4, and 5) */
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoFadt3[] =
+{
+    {ACPI_DMT_GAS,      ACPI_FADT_OFFSET (ResetRegister),           "Reset Register", 0},
+    {ACPI_DMT_UINT8,    ACPI_FADT_OFFSET (ResetValue),              "Value to cause reset", 0},
+    {ACPI_DMT_UINT16,   ACPI_FADT_OFFSET (ArmBootFlags),            "ARM Flags (decoded below)", DT_FLAG},
+    {ACPI_DMT_FLAG0,    ACPI_FADT_FLAG_OFFSET(ArmBootFlags,0),      "PSCI Compliant", 0},
+    {ACPI_DMT_FLAG1,    ACPI_FADT_FLAG_OFFSET(ArmBootFlags,0),      "Must use HVC for PSCI", 0},
+    ACPI_DMT_NEW_LINE,
+    {ACPI_DMT_UINT8,    ACPI_FADT_OFFSET (MinorRevision),           "FADT Minor Revision", 0},
+    {ACPI_DMT_UINT64,   ACPI_FADT_OFFSET (XFacs),                   "FACS Address", 0},
+    {ACPI_DMT_UINT64,   ACPI_FADT_OFFSET (XDsdt),                   "DSDT Address", 0},
+    {ACPI_DMT_GAS,      ACPI_FADT_OFFSET (XPm1aEventBlock),         "PM1A Event Block", 0},
+    {ACPI_DMT_GAS,      ACPI_FADT_OFFSET (XPm1bEventBlock),         "PM1B Event Block", 0},
+    {ACPI_DMT_GAS,      ACPI_FADT_OFFSET (XPm1aControlBlock),       "PM1A Control Block", 0},
+    {ACPI_DMT_GAS,      ACPI_FADT_OFFSET (XPm1bControlBlock),       "PM1B Control Block", 0},
+    {ACPI_DMT_GAS,      ACPI_FADT_OFFSET (XPm2ControlBlock),        "PM2 Control Block", 0},
+    {ACPI_DMT_GAS,      ACPI_FADT_OFFSET (XPmTimerBlock),           "PM Timer Block", 0},
+    {ACPI_DMT_GAS,      ACPI_FADT_OFFSET (XGpe0Block),              "GPE0 Block", 0},
+    {ACPI_DMT_GAS,      ACPI_FADT_OFFSET (XGpe1Block),              "GPE1 Block", 0},
+    ACPI_DMT_TERMINATOR
+};
+
+/* ACPI 5.0 Extensions (FADT version 5) */
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoFadt5[] =
+{
+    {ACPI_DMT_GAS,      ACPI_FADT_OFFSET (SleepControl),            "Sleep Control Register", 0},
+    {ACPI_DMT_GAS,      ACPI_FADT_OFFSET (SleepStatus),             "Sleep Status Register", 0},
+    ACPI_DMT_TERMINATOR
+};
+
+/* ACPI 6.0 Extensions (FADT version 6) */
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoFadt6[] =
+{
+    {ACPI_DMT_UINT64,   ACPI_FADT_OFFSET (HypervisorId),            "Hypervisor ID", 0},
+    ACPI_DMT_TERMINATOR
+};
+
+
+/*
+ * Remaining tables are not consumed directly by the ACPICA subsystem
+ */
+
+/*******************************************************************************
+ *
+ * ASF - Alert Standard Format table (Signature "ASF!")
+ *
+ ******************************************************************************/
+
+/* Common Subtable header (one per Subtable) */
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoAsfHdr[] =
+{
+    {ACPI_DMT_ASF,      ACPI_ASF0_OFFSET (Header.Type),             "Subtable Type", 0},
+    {ACPI_DMT_UINT8,    ACPI_ASF0_OFFSET (Header.Reserved),         "Reserved", 0},
+    {ACPI_DMT_UINT16,   ACPI_ASF0_OFFSET (Header.Length),           "Length", DT_LENGTH},
+    ACPI_DMT_TERMINATOR
+};
+
+/* 0: ASF Information */
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoAsf0[] =
+{
+    {ACPI_DMT_UINT8,    ACPI_ASF0_OFFSET (MinResetValue),           "Minimum Reset Value", 0},
+    {ACPI_DMT_UINT8,    ACPI_ASF0_OFFSET (MinPollInterval),         "Minimum Polling Interval", 0},
+    {ACPI_DMT_UINT16,   ACPI_ASF0_OFFSET (SystemId),                "System ID", 0},
+    {ACPI_DMT_UINT32,   ACPI_ASF0_OFFSET (MfgId),                   "Manufacturer ID", 0},
+    {ACPI_DMT_UINT8,    ACPI_ASF0_OFFSET (Flags),                   "Flags", 0},
+    {ACPI_DMT_UINT24,   ACPI_ASF0_OFFSET (Reserved2[0]),            "Reserved", 0},
+    ACPI_DMT_TERMINATOR
+};
+
+/* 1: ASF Alerts */
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoAsf1[] =
+{
+    {ACPI_DMT_UINT8,    ACPI_ASF1_OFFSET (AssertMask),              "AssertMask", 0},
+    {ACPI_DMT_UINT8,    ACPI_ASF1_OFFSET (DeassertMask),            "DeassertMask", 0},
+    {ACPI_DMT_UINT8,    ACPI_ASF1_OFFSET (Alerts),                  "Alert Count", 0},
+    {ACPI_DMT_UINT8,    ACPI_ASF1_OFFSET (DataLength),              "Alert Data Length", 0},
+    ACPI_DMT_TERMINATOR
+};
+
+/* 1a: ASF Alert data */
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoAsf1a[] =
+{
+    {ACPI_DMT_UINT8,    ACPI_ASF1a_OFFSET (Address),                "Address", 0},
+    {ACPI_DMT_UINT8,    ACPI_ASF1a_OFFSET (Command),                "Command", 0},
+    {ACPI_DMT_UINT8,    ACPI_ASF1a_OFFSET (Mask),                   "Mask", 0},
+    {ACPI_DMT_UINT8,    ACPI_ASF1a_OFFSET (Value),                  "Value", 0},
+    {ACPI_DMT_UINT8,    ACPI_ASF1a_OFFSET (SensorType),             "SensorType", 0},
+    {ACPI_DMT_UINT8,    ACPI_ASF1a_OFFSET (Type),                   "Type", 0},
+    {ACPI_DMT_UINT8,    ACPI_ASF1a_OFFSET (Offset),                 "Offset", 0},
+    {ACPI_DMT_UINT8,    ACPI_ASF1a_OFFSET (SourceType),             "SourceType", 0},
+    {ACPI_DMT_UINT8,    ACPI_ASF1a_OFFSET (Severity),               "Severity", 0},
+    {ACPI_DMT_UINT8,    ACPI_ASF1a_OFFSET (SensorNumber),           "SensorNumber", 0},
+    {ACPI_DMT_UINT8,    ACPI_ASF1a_OFFSET (Entity),                 "Entity", 0},
+    {ACPI_DMT_UINT8,    ACPI_ASF1a_OFFSET (Instance),               "Instance", 0},
+    ACPI_DMT_TERMINATOR
+};
+
+/* 2: ASF Remote Control */
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoAsf2[] =
+{
+    {ACPI_DMT_UINT8,    ACPI_ASF2_OFFSET (Controls),                "Control Count", 0},
+    {ACPI_DMT_UINT8,    ACPI_ASF2_OFFSET (DataLength),              "Control Data Length", 0},
+    {ACPI_DMT_UINT16,   ACPI_ASF2_OFFSET (Reserved2),               "Reserved", 0},
+    ACPI_DMT_TERMINATOR
+};
+
+/* 2a: ASF Control data */
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoAsf2a[] =
+{
+    {ACPI_DMT_UINT8,    ACPI_ASF2a_OFFSET (Function),               "Function", 0},
+    {ACPI_DMT_UINT8,    ACPI_ASF2a_OFFSET (Address),                "Address", 0},
+    {ACPI_DMT_UINT8,    ACPI_ASF2a_OFFSET (Command),                "Command", 0},
+    {ACPI_DMT_UINT8,    ACPI_ASF2a_OFFSET (Value),                  "Value", 0},
+    ACPI_DMT_TERMINATOR
+};
+
+/* 3: ASF RMCP Boot Options */
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoAsf3[] =
+{
+    {ACPI_DMT_BUF7,     ACPI_ASF3_OFFSET (Capabilities[0]),         "Capabilities", 0},
+    {ACPI_DMT_UINT8,    ACPI_ASF3_OFFSET (CompletionCode),          "Completion Code", 0},
+    {ACPI_DMT_UINT32,   ACPI_ASF3_OFFSET (EnterpriseId),            "Enterprise ID", 0},
+    {ACPI_DMT_UINT8,    ACPI_ASF3_OFFSET (Command),                 "Command", 0},
+    {ACPI_DMT_UINT16,   ACPI_ASF3_OFFSET (Parameter),               "Parameter", 0},
+    {ACPI_DMT_UINT16,   ACPI_ASF3_OFFSET (BootOptions),             "Boot Options", 0},
+    {ACPI_DMT_UINT16,   ACPI_ASF3_OFFSET (OemParameters),           "Oem Parameters", 0},
+    ACPI_DMT_TERMINATOR
+};
+
+/* 4: ASF Address */
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoAsf4[] =
+{
+    {ACPI_DMT_UINT8,    ACPI_ASF4_OFFSET (EpromAddress),            "Eprom Address", 0},
+    {ACPI_DMT_UINT8,    ACPI_ASF4_OFFSET (Devices),                 "Device Count", DT_COUNT},
+    ACPI_DMT_TERMINATOR
+};
+
+
+/*******************************************************************************
+ *
+ * BERT -  Boot Error Record table
+ *
+ ******************************************************************************/
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoBert[] =
+{
+    {ACPI_DMT_UINT32,   ACPI_BERT_OFFSET (RegionLength),            "Boot Error Region Length", 0},
+    {ACPI_DMT_UINT64,   ACPI_BERT_OFFSET (Address),                 "Boot Error Region Address", 0},
+    ACPI_DMT_TERMINATOR
+};
+
+
+/*******************************************************************************
+ *
+ * BGRT -  Boot Graphics Resource Table (ACPI 5.0)
+ *
+ ******************************************************************************/
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoBgrt[] =
+{
+    {ACPI_DMT_UINT16,   ACPI_BGRT_OFFSET (Version),                 "Version", 0},
+    {ACPI_DMT_UINT8,    ACPI_BGRT_OFFSET (Status),                  "Status", 0},
+    {ACPI_DMT_UINT8,    ACPI_BGRT_OFFSET (ImageType),               "Image Type", 0},
+    {ACPI_DMT_UINT64,   ACPI_BGRT_OFFSET (ImageAddress),            "Image Address", 0},
+    {ACPI_DMT_UINT32,   ACPI_BGRT_OFFSET (ImageOffsetX),            "Image OffsetX", 0},
+    {ACPI_DMT_UINT32,   ACPI_BGRT_OFFSET (ImageOffsetY),            "Image OffsetY", 0},
+    ACPI_DMT_TERMINATOR
+};
+
+
+/*******************************************************************************
+ *
+ * BOOT - Simple Boot Flag Table
+ *
+ ******************************************************************************/
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoBoot[] =
+{
+    {ACPI_DMT_UINT8,    ACPI_BOOT_OFFSET (CmosIndex),               "Boot Register Index", 0},
+    {ACPI_DMT_UINT24,   ACPI_BOOT_OFFSET (Reserved[0]),             "Reserved", 0},
+    ACPI_DMT_TERMINATOR
+};
+
+
+/*******************************************************************************
+ *
+ * CPEP - Corrected Platform Error Polling table
+ *
+ ******************************************************************************/
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoCpep[] =
+{
+    {ACPI_DMT_UINT64,   ACPI_CPEP_OFFSET (Reserved),                "Reserved", 0},
+    ACPI_DMT_TERMINATOR
+};
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoCpep0[] =
+{
+    {ACPI_DMT_UINT8,    ACPI_CPEP0_OFFSET (Header.Type),            "Subtable Type", 0},
+    {ACPI_DMT_UINT8,    ACPI_CPEP0_OFFSET (Header.Length),          "Length", DT_LENGTH},
+    {ACPI_DMT_UINT8,    ACPI_CPEP0_OFFSET (Id),                     "Processor ID", 0},
+    {ACPI_DMT_UINT8,    ACPI_CPEP0_OFFSET (Eid),                    "Processor EID", 0},
+    {ACPI_DMT_UINT32,   ACPI_CPEP0_OFFSET (Interval),               "Polling Interval", 0},
+    ACPI_DMT_TERMINATOR
+};
+
+
+/*******************************************************************************
+ *
+ * CSRT - Core System Resource Table
+ *
+ ******************************************************************************/
+
+/* Main table consists only of the standard ACPI table header */
+
+/* Resource Group subtable */
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoCsrt0[] =
+{
+    {ACPI_DMT_UINT32,   ACPI_CSRT0_OFFSET (Length),                 "Length", DT_LENGTH},
+    {ACPI_DMT_UINT32,   ACPI_CSRT0_OFFSET (VendorId),               "Vendor ID", 0},
+    {ACPI_DMT_UINT32,   ACPI_CSRT0_OFFSET (SubvendorId),            "Subvendor ID", 0},
+    {ACPI_DMT_UINT16,   ACPI_CSRT0_OFFSET (DeviceId),               "Device ID", 0},
+    {ACPI_DMT_UINT16,   ACPI_CSRT0_OFFSET (SubdeviceId),            "Subdevice ID", 0},
+    {ACPI_DMT_UINT16,   ACPI_CSRT0_OFFSET (Revision),               "Revision", 0},
+    {ACPI_DMT_UINT16,   ACPI_CSRT0_OFFSET (Reserved),               "Reserved", 0},
+    {ACPI_DMT_UINT32,   ACPI_CSRT0_OFFSET (SharedInfoLength),       "Shared Info Length", 0},
+    ACPI_DMT_TERMINATOR
+};
+
+/* Shared Info subtable */
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoCsrt1[] =
+{
+    {ACPI_DMT_UINT16,   ACPI_CSRT1_OFFSET (MajorVersion),           "Major Version", 0},
+    {ACPI_DMT_UINT16,   ACPI_CSRT1_OFFSET (MinorVersion),           "Minor Version", 0},
+    {ACPI_DMT_UINT32,   ACPI_CSRT1_OFFSET (MmioBaseLow),            "MMIO Base Address Low", 0},
+    {ACPI_DMT_UINT32,   ACPI_CSRT1_OFFSET (MmioBaseHigh),           "MMIO Base Address High", 0},
+    {ACPI_DMT_UINT32,   ACPI_CSRT1_OFFSET (GsiInterrupt),           "GSI Interrupt", 0},
+    {ACPI_DMT_UINT8,    ACPI_CSRT1_OFFSET (InterruptPolarity),      "Interrupt Polarity", 0},
+    {ACPI_DMT_UINT8,    ACPI_CSRT1_OFFSET (InterruptMode),          "Interrupt Mode", 0},
+    {ACPI_DMT_UINT8,    ACPI_CSRT1_OFFSET (NumChannels),            "Num Channels", 0},
+    {ACPI_DMT_UINT8,    ACPI_CSRT1_OFFSET (DmaAddressWidth),        "DMA Address Width", 0},
+    {ACPI_DMT_UINT16,   ACPI_CSRT1_OFFSET (BaseRequestLine),        "Base Request Line", 0},
+    {ACPI_DMT_UINT16,   ACPI_CSRT1_OFFSET (NumHandshakeSignals),    "Num Handshake Signals", 0},
+    {ACPI_DMT_UINT32,   ACPI_CSRT1_OFFSET (MaxBlockSize),           "Max Block Size", 0},
+    ACPI_DMT_TERMINATOR
+};
+
+
+/* Resource Descriptor subtable */
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoCsrt2[] =
+{
+    {ACPI_DMT_UINT32,   ACPI_CSRT2_OFFSET (Length),                 "Length", DT_LENGTH},
+    {ACPI_DMT_UINT16,   ACPI_CSRT2_OFFSET (Type),                   "Type", 0},
+    {ACPI_DMT_UINT16,   ACPI_CSRT2_OFFSET (Subtype),                "Subtype", 0},
+    {ACPI_DMT_UINT32,   ACPI_CSRT2_OFFSET (Uid),                    "UID", 0},
+    ACPI_DMT_TERMINATOR
+};
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoCsrt2a[] =
+{
+    {ACPI_DMT_RAW_BUFFER, 0,                                        "ResourceInfo", DT_OPTIONAL},
+    ACPI_DMT_TERMINATOR
+};
+
+
+/*******************************************************************************
+ *
+ * DBG2 - Debug Port Table 2
+ *
+ ******************************************************************************/
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoDbg2[] =
+{
+    {ACPI_DMT_UINT32,   ACPI_DBG2_OFFSET (InfoOffset),              "Info Offset", 0},
+    {ACPI_DMT_UINT32,   ACPI_DBG2_OFFSET (InfoCount),               "Info Count", 0},
+    ACPI_DMT_TERMINATOR
+};
+
+/* Debug Device Information Subtable */
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoDbg2Device[] =
+{
+    {ACPI_DMT_UINT8,    ACPI_DBG20_OFFSET (Revision),               "Revision", 0},
+    {ACPI_DMT_UINT16,   ACPI_DBG20_OFFSET (Length),                 "Length", DT_LENGTH},
+    {ACPI_DMT_UINT8,    ACPI_DBG20_OFFSET (RegisterCount),          "Register Count", 0},
+    {ACPI_DMT_UINT16,   ACPI_DBG20_OFFSET (NamepathLength),         "Namepath Length", 0},
+    {ACPI_DMT_UINT16,   ACPI_DBG20_OFFSET (NamepathOffset),         "Namepath Offset", 0},
+    {ACPI_DMT_UINT16,   ACPI_DBG20_OFFSET (OemDataLength),          "OEM Data Length", DT_DESCRIBES_OPTIONAL},
+    {ACPI_DMT_UINT16,   ACPI_DBG20_OFFSET (OemDataOffset),          "OEM Data Offset", DT_DESCRIBES_OPTIONAL},
+    {ACPI_DMT_UINT16,   ACPI_DBG20_OFFSET (PortType),               "Port Type", 0},
+    {ACPI_DMT_UINT16,   ACPI_DBG20_OFFSET (PortSubtype),            "Port Subtype", 0},
+    {ACPI_DMT_UINT16,   ACPI_DBG20_OFFSET (Reserved),               "Reserved", 0},
+    {ACPI_DMT_UINT16,   ACPI_DBG20_OFFSET (BaseAddressOffset),      "Base Address Offset", 0},
+    {ACPI_DMT_UINT16,   ACPI_DBG20_OFFSET (AddressSizeOffset),      "Address Size Offset", 0},
+    ACPI_DMT_TERMINATOR
+};
+
+/* Variable-length data for the subtable */
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoDbg2Addr[] =
+{
+    {ACPI_DMT_GAS,      0,                                          "Base Address Register", 0},
+    ACPI_DMT_TERMINATOR
+};
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoDbg2Size[] =
+{
+    {ACPI_DMT_UINT32,   0,                                          "Address Size", 0},
+    ACPI_DMT_TERMINATOR
+};
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoDbg2Name[] =
+{
+    {ACPI_DMT_STRING,   0,                                          "Namepath", 0},
+    ACPI_DMT_TERMINATOR
+};
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoDbg2OemData[] =
+{
+    {ACPI_DMT_RAW_BUFFER, 0,                                        "OEM Data", DT_OPTIONAL},
+    ACPI_DMT_TERMINATOR
+};
+
+
+/*******************************************************************************
+ *
+ * DBGP - Debug Port
+ *
+ ******************************************************************************/
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoDbgp[] =
+{
+    {ACPI_DMT_UINT8,    ACPI_DBGP_OFFSET (Type),                    "Interface Type", 0},
+    {ACPI_DMT_UINT24,   ACPI_DBGP_OFFSET (Reserved[0]),             "Reserved", 0},
+    {ACPI_DMT_GAS,      ACPI_DBGP_OFFSET (DebugPort),               "Debug Port Register", 0},
+    ACPI_DMT_TERMINATOR
+};
+
+
+/*******************************************************************************
+ *
+ * DMAR - DMA Remapping table
+ *
+ ******************************************************************************/
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoDmar[] =
+{
+    {ACPI_DMT_UINT8,    ACPI_DMAR_OFFSET (Width),                   "Host Address Width", 0},
+    {ACPI_DMT_UINT8,    ACPI_DMAR_OFFSET (Flags),                   "Flags", 0},
+    {ACPI_DMT_BUF10,    ACPI_DMAR_OFFSET (Reserved[0]),             "Reserved", 0},
+    ACPI_DMT_TERMINATOR
+};
+
+/* Common Subtable header (one per Subtable) */
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoDmarHdr[] =
+{
+    {ACPI_DMT_DMAR,     ACPI_DMAR0_OFFSET (Header.Type),            "Subtable Type", 0},
+    {ACPI_DMT_UINT16,   ACPI_DMAR0_OFFSET (Header.Length),          "Length", DT_LENGTH},
+    ACPI_DMT_TERMINATOR
+};
+
+/* Common device scope entry */
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoDmarScope[] =
+{
+    {ACPI_DMT_DMAR_SCOPE, ACPI_DMARS_OFFSET (EntryType),            "Device Scope Type", 0},
+    {ACPI_DMT_UINT8,    ACPI_DMARS_OFFSET (Length),                 "Entry Length", DT_LENGTH},
+    {ACPI_DMT_UINT16,   ACPI_DMARS_OFFSET (Reserved),               "Reserved", 0},
+    {ACPI_DMT_UINT8,    ACPI_DMARS_OFFSET (EnumerationId),          "Enumeration ID", 0},
+    {ACPI_DMT_UINT8,    ACPI_DMARS_OFFSET (Bus),                    "PCI Bus Number", 0},
+    ACPI_DMT_TERMINATOR
+};
+
+/* DMAR Subtables */
+
+/* 0: Hardware Unit Definition */
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoDmar0[] =
+{
+    {ACPI_DMT_UINT8,    ACPI_DMAR0_OFFSET (Flags),                  "Flags", 0},
+    {ACPI_DMT_UINT8,    ACPI_DMAR0_OFFSET (Reserved),               "Reserved", 0},
+    {ACPI_DMT_UINT16,   ACPI_DMAR0_OFFSET (Segment),                "PCI Segment Number", 0},
+    {ACPI_DMT_UINT64,   ACPI_DMAR0_OFFSET (Address),                "Register Base Address", 0},
+    ACPI_DMT_TERMINATOR
+};
+
+/* 1: Reserved Memory Definition */
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoDmar1[] =
+{
+    {ACPI_DMT_UINT16,   ACPI_DMAR1_OFFSET (Reserved),               "Reserved", 0},
+    {ACPI_DMT_UINT16,   ACPI_DMAR1_OFFSET (Segment),                "PCI Segment Number", 0},
+    {ACPI_DMT_UINT64,   ACPI_DMAR1_OFFSET (BaseAddress),            "Base Address", 0},
+    {ACPI_DMT_UINT64,   ACPI_DMAR1_OFFSET (EndAddress),             "End Address (limit)", 0},
+    ACPI_DMT_TERMINATOR
+};
+
+/* 2: Root Port ATS Capability Definition */
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoDmar2[] =
+{
+    {ACPI_DMT_UINT8,    ACPI_DMAR2_OFFSET (Flags),                  "Flags", 0},
+    {ACPI_DMT_UINT8,    ACPI_DMAR2_OFFSET (Reserved),               "Reserved", 0},
+    {ACPI_DMT_UINT16,   ACPI_DMAR2_OFFSET (Segment),                "PCI Segment Number", 0},
+    ACPI_DMT_TERMINATOR
+};
+
+/* 3: Remapping Hardware Static Affinity Structure */
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoDmar3[] =
+{
+    {ACPI_DMT_UINT32,   ACPI_DMAR3_OFFSET (Reserved),               "Reserved", 0},
+    {ACPI_DMT_UINT64,   ACPI_DMAR3_OFFSET (BaseAddress),            "Base Address", 0},
+    {ACPI_DMT_UINT32,   ACPI_DMAR3_OFFSET (ProximityDomain),        "Proximity Domain", 0},
+    ACPI_DMT_TERMINATOR
+};
+
+/* 4: ACPI Namespace Device Declaration Structure */
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoDmar4[] =
+{
+    {ACPI_DMT_UINT24,   ACPI_DMAR4_OFFSET (Reserved[0]),            "Reserved", 0},
+    {ACPI_DMT_UINT8,    ACPI_DMAR4_OFFSET (DeviceNumber),           "Device Number", 0},
+    {ACPI_DMT_STRING,   ACPI_DMAR4_OFFSET (DeviceName[0]),          "Device Name", 0},
+    ACPI_DMT_TERMINATOR
+};
+
+
+/*******************************************************************************
+ *
+ * DRTM - Dynamic Root of Trust for Measurement table
+ *
+ ******************************************************************************/
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoDrtm[] =
+{
+    {ACPI_DMT_UINT64,   ACPI_DRTM_OFFSET (EntryBaseAddress),        "Entry Base Address", 0},
+    {ACPI_DMT_UINT64,   ACPI_DRTM_OFFSET (EntryLength),             "Entry Length", 0},
+    {ACPI_DMT_UINT32,   ACPI_DRTM_OFFSET (EntryAddress32),          "Entry 32", 0},
+    {ACPI_DMT_UINT64,   ACPI_DRTM_OFFSET (EntryAddress64),          "Entry 64", 0},
+    {ACPI_DMT_UINT64,   ACPI_DRTM_OFFSET (ExitAddress),             "Exit Address", 0},
+    {ACPI_DMT_UINT64,   ACPI_DRTM_OFFSET (LogAreaAddress),          "Log Area Start", 0},
+    {ACPI_DMT_UINT32,   ACPI_DRTM_OFFSET (LogAreaLength),           "Log Area Length", 0},
+    {ACPI_DMT_UINT64,   ACPI_DRTM_OFFSET (ArchDependentAddress),    "Arch Dependent Address", 0},
+    {ACPI_DMT_UINT32,   ACPI_DRTM_OFFSET (Flags),                   "Flags (decoded below)", 0},
+    {ACPI_DMT_FLAG0,    ACPI_DRTM_FLAG_OFFSET (Flags, 0),           "Namespace in TCB", 0},
+    {ACPI_DMT_FLAG1,    ACPI_DRTM_FLAG_OFFSET (Flags, 0),           "Gap Code on S3 Resume", 0},
+    {ACPI_DMT_FLAG2,    ACPI_DRTM_FLAG_OFFSET (Flags, 0),           "Gap Code on DLME_Exit", 0},
+    {ACPI_DMT_FLAG3,    ACPI_DRTM_FLAG_OFFSET (Flags, 0),           "PCR_Authorities Changed", 0},
+    ACPI_DMT_TERMINATOR
+};
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoDrtm0[] =
+{
+    {ACPI_DMT_UINT32,   ACPI_DRTM0_OFFSET (ValidatedTableCount),    "Validated Table Count", DT_COUNT},
+    ACPI_DMT_TERMINATOR
+};
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoDrtm0a[] =
+{
+    {ACPI_DMT_UINT64,   0,                                          "Table Address", DT_OPTIONAL},
+    ACPI_DMT_TERMINATOR
+};
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoDrtm1[] =
+{
+    {ACPI_DMT_UINT32,   ACPI_DRTM1_OFFSET (ResourceCount),          "Resource Count", DT_COUNT},
+    ACPI_DMT_TERMINATOR
+};
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoDrtm1a[] =
+{
+    {ACPI_DMT_UINT56,   ACPI_DRTM1a_OFFSET (Size[0]),               "Size", DT_OPTIONAL},
+    {ACPI_DMT_UINT8,    ACPI_DRTM1a_OFFSET (Type),                  "Type", 0},
+    {ACPI_DMT_FLAG0,    ACPI_DRTM1a_FLAG_OFFSET (Type, 0),          "Resource Type", 0},
+    {ACPI_DMT_FLAG7,    ACPI_DRTM1a_FLAG_OFFSET (Type, 0),          "Protections", 0},
+    {ACPI_DMT_UINT64,   ACPI_DRTM1a_OFFSET (Address),               "Address", 0},
+    ACPI_DMT_TERMINATOR
+};
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoDrtm2[] =
+{
+    {ACPI_DMT_UINT32,   ACPI_DRTM2_OFFSET (DpsIdLength),            "DLME Platform Id Length", DT_COUNT},
+    {ACPI_DMT_BUF16,    ACPI_DRTM2_OFFSET (DpsId),                  "DLME Platform Id", DT_COUNT},
+    ACPI_DMT_TERMINATOR
+};
+
+
+/*******************************************************************************
+ *
+ * ECDT - Embedded Controller Boot Resources Table
+ *
+ ******************************************************************************/
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoEcdt[] =
+{
+    {ACPI_DMT_GAS,      ACPI_ECDT_OFFSET (Control),                 "Command/Status Register", 0},
+    {ACPI_DMT_GAS,      ACPI_ECDT_OFFSET (Data),                    "Data Register", 0},
+    {ACPI_DMT_UINT32,   ACPI_ECDT_OFFSET (Uid),                     "UID", 0},
+    {ACPI_DMT_UINT8,    ACPI_ECDT_OFFSET (Gpe),                     "GPE Number", 0},
+    {ACPI_DMT_STRING,   ACPI_ECDT_OFFSET (Id[0]),                   "Namepath", 0},
+    ACPI_DMT_TERMINATOR
+};
+
+
+/*******************************************************************************
+ *
+ * EINJ - Error Injection table
+ *
+ ******************************************************************************/
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoEinj[] =
+{
+    {ACPI_DMT_UINT32,   ACPI_EINJ_OFFSET (HeaderLength),            "Injection Header Length", 0},
+    {ACPI_DMT_UINT8,    ACPI_EINJ_OFFSET (Flags),                   "Flags", 0},
+    {ACPI_DMT_UINT24,   ACPI_EINJ_OFFSET (Reserved[0]),             "Reserved", 0},
+    {ACPI_DMT_UINT32,   ACPI_EINJ_OFFSET (Entries),                 "Injection Entry Count", 0},
+    ACPI_DMT_TERMINATOR
+};
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoEinj0[] =
+{
+    {ACPI_DMT_EINJACT,  ACPI_EINJ0_OFFSET (Action),                 "Action", 0},
+    {ACPI_DMT_EINJINST, ACPI_EINJ0_OFFSET (Instruction),            "Instruction", 0},
+    {ACPI_DMT_UINT8,    ACPI_EINJ0_OFFSET (Flags),                  "Flags (decoded below)", DT_FLAG},
+    {ACPI_DMT_FLAG0,    ACPI_EINJ0_FLAG_OFFSET (Flags,0),           "Preserve Register Bits", 0},
+
+    {ACPI_DMT_UINT8,    ACPI_EINJ0_OFFSET (Reserved),               "Reserved", 0},
+    {ACPI_DMT_GAS,      ACPI_EINJ0_OFFSET (RegisterRegion),         "Register Region", 0},
+    {ACPI_DMT_UINT64,   ACPI_EINJ0_OFFSET (Value),                  "Value", 0},
+    {ACPI_DMT_UINT64,   ACPI_EINJ0_OFFSET (Mask),                   "Mask", 0},
+    ACPI_DMT_TERMINATOR
+};
+
+
+/*******************************************************************************
+ *
+ * ERST - Error Record Serialization table
+ *
+ ******************************************************************************/
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoErst[] =
+{
+    {ACPI_DMT_UINT32,   ACPI_ERST_OFFSET (HeaderLength),            "Serialization Header Length", 0},
+    {ACPI_DMT_UINT32,   ACPI_ERST_OFFSET (Reserved),                "Reserved", 0},
+    {ACPI_DMT_UINT32,   ACPI_ERST_OFFSET (Entries),                 "Instruction Entry Count", 0},
+    ACPI_DMT_TERMINATOR
+};
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoErst0[] =
+{
+    {ACPI_DMT_ERSTACT,  ACPI_ERST0_OFFSET (Action),                 "Action", 0},
+    {ACPI_DMT_ERSTINST, ACPI_ERST0_OFFSET (Instruction),            "Instruction", 0},
+    {ACPI_DMT_UINT8,    ACPI_ERST0_OFFSET (Flags),                  "Flags (decoded below)", DT_FLAG},
+    {ACPI_DMT_FLAG0,    ACPI_ERST0_FLAG_OFFSET (Flags,0),           "Preserve Register Bits", 0},
+
+    {ACPI_DMT_UINT8,    ACPI_ERST0_OFFSET (Reserved),               "Reserved", 0},
+    {ACPI_DMT_GAS,      ACPI_ERST0_OFFSET (RegisterRegion),         "Register Region", 0},
+    {ACPI_DMT_UINT64,   ACPI_ERST0_OFFSET (Value),                  "Value", 0},
+    {ACPI_DMT_UINT64,   ACPI_ERST0_OFFSET (Mask),                   "Mask", 0},
+    ACPI_DMT_TERMINATOR
+};
+
+
+/*******************************************************************************
+ *
+ * FPDT - Firmware Performance Data Table (ACPI 5.0)
+ *
+ ******************************************************************************/
+
+/* Main table consists of only the standard ACPI header - subtables follow */
+
+/* FPDT subtable header */
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoFpdtHdr[] =
+{
+    {ACPI_DMT_UINT16,   ACPI_FPDTH_OFFSET (Type),                   "Subtable Type", 0},
+    {ACPI_DMT_UINT8,    ACPI_FPDTH_OFFSET (Length),                 "Length", DT_LENGTH},
+    {ACPI_DMT_UINT8,    ACPI_FPDTH_OFFSET (Revision),               "Revision", 0},
+    ACPI_DMT_TERMINATOR
+};
+
+/* 0: Firmware Basic Boot Performance Record */
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoFpdt0[] =
+{
+    {ACPI_DMT_UINT32,   ACPI_FPDT0_OFFSET (Reserved),               "Reserved", 0},
+    {ACPI_DMT_UINT64,   ACPI_FPDT1_OFFSET (Address),                "FPDT Boot Record Address", 0},
+    ACPI_DMT_TERMINATOR
+};
+
+/* 1: S3 Performance Table Pointer Record */
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoFpdt1[] =
+{
+    {ACPI_DMT_UINT32,   ACPI_FPDT1_OFFSET (Reserved),               "Reserved", 0},
+    {ACPI_DMT_UINT64,   ACPI_FPDT1_OFFSET (Address),                "S3PT Record Address", 0},
+    ACPI_DMT_TERMINATOR
+};
+
+#if 0
+    /* Boot Performance Record, not supported at this time. */
+    {ACPI_DMT_UINT64,   ACPI_FPDT0_OFFSET (ResetEnd),               "Reset End", 0},
+    {ACPI_DMT_UINT64,   ACPI_FPDT0_OFFSET (LoadStart),              "Load Image Start", 0},
+    {ACPI_DMT_UINT64,   ACPI_FPDT0_OFFSET (StartupStart),           "Start Image Start", 0},
+    {ACPI_DMT_UINT64,   ACPI_FPDT0_OFFSET (ExitServicesEntry),      "Exit Services Entry", 0},
+    {ACPI_DMT_UINT64,   ACPI_FPDT0_OFFSET (ExitServicesExit),       "Exit Services Exit", 0},
+#endif
+
+/*******************************************************************************
+ *
+ * GTDT - Generic Timer Description Table
+ *
+ ******************************************************************************/
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoGtdt[] =
+{
+    {ACPI_DMT_UINT64,   ACPI_GTDT_OFFSET (CounterBlockAddresss),    "Counter Block Address", 0},
+    {ACPI_DMT_UINT32,   ACPI_GTDT_OFFSET (Reserved),                "Reserved", 0},
+    ACPI_DMT_NEW_LINE,
+    {ACPI_DMT_UINT32,   ACPI_GTDT_OFFSET (SecureEl1Interrupt),      "Secure EL1 Interrupt", 0},
+    {ACPI_DMT_UINT32,   ACPI_GTDT_OFFSET (SecureEl1Flags),          "EL1 Flags (decoded below)", DT_FLAG},
+    {ACPI_DMT_FLAG0,    ACPI_GTDT_FLAG_OFFSET (SecureEl1Flags,0),   "Trigger Mode", 0},
+    {ACPI_DMT_FLAG1,    ACPI_GTDT_FLAG_OFFSET (SecureEl1Flags,0),   "Polarity", 0},
+    {ACPI_DMT_FLAG2,    ACPI_GTDT_FLAG_OFFSET (SecureEl1Flags,0),   "Always On", 0},
+    ACPI_DMT_NEW_LINE,
+    {ACPI_DMT_UINT32,   ACPI_GTDT_OFFSET (NonSecureEl1Interrupt),   "Non-Secure EL1 Interrupt", 0},
+    {ACPI_DMT_UINT32,   ACPI_GTDT_OFFSET (NonSecureEl1Flags),       "NEL1 Flags (decoded below)", DT_FLAG},
+    {ACPI_DMT_FLAG0,    ACPI_GTDT_FLAG_OFFSET (NonSecureEl1Flags,0),"Trigger Mode", 0},
+    {ACPI_DMT_FLAG1,    ACPI_GTDT_FLAG_OFFSET (NonSecureEl1Flags,0),"Polarity", 0},
+    {ACPI_DMT_FLAG2,    ACPI_GTDT_FLAG_OFFSET (NonSecureEl1Flags,0),"Always On", 0},
+    ACPI_DMT_NEW_LINE,
+    {ACPI_DMT_UINT32,   ACPI_GTDT_OFFSET (VirtualTimerInterrupt),   "Virtual Timer Interrupt", 0},
+    {ACPI_DMT_UINT32,   ACPI_GTDT_OFFSET (VirtualTimerFlags),       "VT Flags (decoded below)", DT_FLAG},
+    {ACPI_DMT_FLAG0,    ACPI_GTDT_FLAG_OFFSET (VirtualTimerFlags,0),"Trigger Mode", 0},
+    {ACPI_DMT_FLAG1,    ACPI_GTDT_FLAG_OFFSET (VirtualTimerFlags,0),"Polarity", 0},
+    {ACPI_DMT_FLAG2,    ACPI_GTDT_FLAG_OFFSET (VirtualTimerFlags,0),"Always On", 0},
+    ACPI_DMT_NEW_LINE,
+    {ACPI_DMT_UINT32,   ACPI_GTDT_OFFSET (NonSecureEl2Interrupt),   "Non-Secure EL2 Interrupt", 0},
+    {ACPI_DMT_UINT32,   ACPI_GTDT_OFFSET (NonSecureEl2Flags),       "NEL2 Flags (decoded below)", DT_FLAG},
+    {ACPI_DMT_FLAG0,    ACPI_GTDT_FLAG_OFFSET (NonSecureEl2Flags,0),"Trigger Mode", 0},
+    {ACPI_DMT_FLAG1,    ACPI_GTDT_FLAG_OFFSET (NonSecureEl2Flags,0),"Polarity", 0},
+    {ACPI_DMT_FLAG2,    ACPI_GTDT_FLAG_OFFSET (NonSecureEl2Flags,0),"Always On", 0},
+    {ACPI_DMT_UINT64,   ACPI_GTDT_OFFSET (CounterReadBlockAddress), "Counter Read Block Address", 0},
+    ACPI_DMT_NEW_LINE,
+    {ACPI_DMT_UINT32,   ACPI_GTDT_OFFSET (PlatformTimerCount),      "Platform Timer Count", 0},
+    {ACPI_DMT_UINT32,   ACPI_GTDT_OFFSET (PlatformTimerOffset),     "Platform Timer Offset", 0},
+    ACPI_DMT_TERMINATOR
+};
+
+/* GTDT Subtable header (one per Subtable) */
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoGtdtHdr[] =
+{
+    {ACPI_DMT_GTDT,     ACPI_GTDTH_OFFSET (Type),                   "Subtable Type", 0},
+    {ACPI_DMT_UINT16,   ACPI_GTDTH_OFFSET (Length),                 "Length", DT_LENGTH},
+    ACPI_DMT_TERMINATOR
+};
+
+/* GTDT Subtables */
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoGtdt0[] =
+{
+    {ACPI_DMT_UINT8,    ACPI_GTDT0_OFFSET (Reserved),               "Reserved", 0},
+    {ACPI_DMT_UINT64,   ACPI_GTDT0_OFFSET (BlockAddress),           "Block Address", 0},
+    {ACPI_DMT_UINT32,   ACPI_GTDT0_OFFSET (TimerCount),             "Timer Count", 0},
+    {ACPI_DMT_UINT32,   ACPI_GTDT0_OFFSET (TimerOffset),            "Timer Offset", 0},
+    ACPI_DMT_TERMINATOR
+};
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoGtdt0a[] =
+{
+    {ACPI_DMT_UINT8 ,   ACPI_GTDT0a_OFFSET (FrameNumber),               "Frame Number", 0},
+    {ACPI_DMT_UINT24,   ACPI_GTDT0a_OFFSET (Reserved[0]),               "Reserved", 0},
+    {ACPI_DMT_UINT64,   ACPI_GTDT0a_OFFSET (BaseAddress),               "Base Address", 0},
+    {ACPI_DMT_UINT64,   ACPI_GTDT0a_OFFSET (El0BaseAddress),            "EL0 Base Address", 0},
+    {ACPI_DMT_UINT32,   ACPI_GTDT0a_OFFSET (TimerInterrupt),            "Timer Interrupt", 0},
+    {ACPI_DMT_UINT32,   ACPI_GTDT0a_OFFSET (TimerFlags),                "Timer Flags (decoded below)", 0},
+    {ACPI_DMT_FLAG0,    ACPI_GTDT0a_FLAG_OFFSET (TimerFlags,0),         "Trigger Mode", 0},
+    {ACPI_DMT_FLAG1,    ACPI_GTDT0a_FLAG_OFFSET (TimerFlags,0),         "Polarity", 0},
+    {ACPI_DMT_UINT32,   ACPI_GTDT0a_OFFSET (VirtualTimerInterrupt),     "Virtual Timer Interrupt", 0},
+    {ACPI_DMT_UINT32,   ACPI_GTDT0a_OFFSET (VirtualTimerFlags),         "Virtual Timer Flags (decoded below)", 0},
+    {ACPI_DMT_FLAG0,    ACPI_GTDT0a_FLAG_OFFSET (VirtualTimerFlags,0),  "Trigger Mode", 0},
+    {ACPI_DMT_FLAG1,    ACPI_GTDT0a_FLAG_OFFSET (VirtualTimerFlags,0),  "Polarity", 0},
+    {ACPI_DMT_UINT32,   ACPI_GTDT0a_OFFSET (CommonFlags),               "Common Flags (decoded below)", 0},
+    {ACPI_DMT_FLAG0,    ACPI_GTDT0a_FLAG_OFFSET (CommonFlags,0),        "Secure", 0},
+    {ACPI_DMT_FLAG1,    ACPI_GTDT0a_FLAG_OFFSET (CommonFlags,0),        "Always On", 0},
+    ACPI_DMT_TERMINATOR
+};
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoGtdt1[] =
+{
+    {ACPI_DMT_UINT8,    ACPI_GTDT1_OFFSET (Reserved),               "Reserved", 0},
+    {ACPI_DMT_UINT64,   ACPI_GTDT1_OFFSET (RefreshFrameAddress),    "Refresh Frame Address", 0},
+    {ACPI_DMT_UINT64,   ACPI_GTDT1_OFFSET (ControlFrameAddress),    "Control Frame Address", 0},
+    {ACPI_DMT_UINT32,   ACPI_GTDT1_OFFSET (TimerInterrupt),         "Timer Interrupt", 0},
+    {ACPI_DMT_UINT32,   ACPI_GTDT1_OFFSET (TimerFlags),             "Timer Flags (decoded below)", DT_FLAG},
+    {ACPI_DMT_FLAG0,    ACPI_GTDT1_FLAG_OFFSET (TimerFlags,0),      "Trigger Mode", 0},
+    {ACPI_DMT_FLAG1,    ACPI_GTDT1_FLAG_OFFSET (TimerFlags,0),      "Polarity", 0},
+    {ACPI_DMT_FLAG2,    ACPI_GTDT1_FLAG_OFFSET (TimerFlags,0),      "Security", 0},
+    ACPI_DMT_TERMINATOR
+};
+
+
+/*******************************************************************************
+ *
+ * HEST - Hardware Error Source table
+ *
+ ******************************************************************************/
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoHest[] =
+{
+    {ACPI_DMT_UINT32,   ACPI_HEST_OFFSET (ErrorSourceCount),        "Error Source Count", 0},
+    ACPI_DMT_TERMINATOR
+};
+
+/* Common HEST structures for subtables */
+
+#define ACPI_DM_HEST_HEADER \
+    {ACPI_DMT_HEST,     ACPI_HEST0_OFFSET (Header.Type),            "Subtable Type", 0}, \
+    {ACPI_DMT_UINT16,   ACPI_HEST0_OFFSET (Header.SourceId),        "Source Id", 0}
+
+#define ACPI_DM_HEST_AER \
+    {ACPI_DMT_UINT16,   ACPI_HEST6_OFFSET (Aer.Reserved1),              "Reserved", 0}, \
+    {ACPI_DMT_UINT8,    ACPI_HEST6_OFFSET (Aer.Flags),                  "Flags (decoded below)", DT_FLAG}, \
+    {ACPI_DMT_FLAG0,    ACPI_HEST6_FLAG_OFFSET (Aer.Flags,0),           "Firmware First", 0}, \
+    {ACPI_DMT_UINT8,    ACPI_HEST6_OFFSET (Aer.Enabled),                "Enabled", 0}, \
+    {ACPI_DMT_UINT32,   ACPI_HEST6_OFFSET (Aer.RecordsToPreallocate),   "Records To Preallocate", 0}, \
+    {ACPI_DMT_UINT32,   ACPI_HEST6_OFFSET (Aer.MaxSectionsPerRecord),   "Max Sections Per Record", 0}, \
+    {ACPI_DMT_UINT32,   ACPI_HEST6_OFFSET (Aer.Bus),                    "Bus", 0}, \
+    {ACPI_DMT_UINT16,   ACPI_HEST6_OFFSET (Aer.Device),                 "Device", 0}, \
+    {ACPI_DMT_UINT16,   ACPI_HEST6_OFFSET (Aer.Function),               "Function", 0}, \
+    {ACPI_DMT_UINT16,   ACPI_HEST6_OFFSET (Aer.DeviceControl),          "DeviceControl", 0}, \
+    {ACPI_DMT_UINT16,   ACPI_HEST6_OFFSET (Aer.Reserved2),              "Reserved", 0}, \
+    {ACPI_DMT_UINT32,   ACPI_HEST6_OFFSET (Aer.UncorrectableMask),      "Uncorrectable Mask", 0}, \
+    {ACPI_DMT_UINT32,   ACPI_HEST6_OFFSET (Aer.UncorrectableSeverity),  "Uncorrectable Severity", 0}, \
+    {ACPI_DMT_UINT32,   ACPI_HEST6_OFFSET (Aer.CorrectableMask),        "Correctable Mask", 0}, \
+    {ACPI_DMT_UINT32,   ACPI_HEST6_OFFSET (Aer.AdvancedCapabilities),   "Advanced Capabilities", 0}
+
+
+/* HEST Subtables */
+
+/* 0: IA32 Machine Check Exception */
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoHest0[] =
+{
+    ACPI_DM_HEST_HEADER,
+    {ACPI_DMT_UINT16,   ACPI_HEST0_OFFSET (Reserved1),              "Reserved1", 0},
+    {ACPI_DMT_UINT8,    ACPI_HEST0_OFFSET (Flags),                  "Flags (decoded below)", DT_FLAG},
+    {ACPI_DMT_FLAG0,    ACPI_HEST0_FLAG_OFFSET (Flags,0),           "Firmware First", 0},
+
+    {ACPI_DMT_UINT8,    ACPI_HEST0_OFFSET (Enabled),                "Enabled", 0},
+    {ACPI_DMT_UINT32,   ACPI_HEST0_OFFSET (RecordsToPreallocate),   "Records To Preallocate", 0},
+    {ACPI_DMT_UINT32,   ACPI_HEST0_OFFSET (MaxSectionsPerRecord),   "Max Sections Per Record", 0},
+    {ACPI_DMT_UINT64,   ACPI_HEST0_OFFSET (GlobalCapabilityData),   "Global Capability Data", 0},
+    {ACPI_DMT_UINT64,   ACPI_HEST0_OFFSET (GlobalControlData),      "Global Control Data", 0},
+    {ACPI_DMT_UINT8,    ACPI_HEST0_OFFSET (NumHardwareBanks),       "Num Hardware Banks", 0},
+    {ACPI_DMT_UINT56,   ACPI_HEST0_OFFSET (Reserved3[0]),           "Reserved2", 0},
+    ACPI_DMT_TERMINATOR
+};
+
+/* 1: IA32 Corrected Machine Check */
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoHest1[] =
+{
+    ACPI_DM_HEST_HEADER,
+    {ACPI_DMT_UINT16,   ACPI_HEST1_OFFSET (Reserved1),              "Reserved1", 0},
+    {ACPI_DMT_UINT8,    ACPI_HEST1_OFFSET (Flags),                  "Flags (decoded below)", DT_FLAG},
+    {ACPI_DMT_FLAG0,    ACPI_HEST1_FLAG_OFFSET (Flags,0),           "Firmware First", 0},
+
+    {ACPI_DMT_UINT8,    ACPI_HEST1_OFFSET (Enabled),                "Enabled", 0},
+    {ACPI_DMT_UINT32,   ACPI_HEST1_OFFSET (RecordsToPreallocate),   "Records To Preallocate", 0},
+    {ACPI_DMT_UINT32,   ACPI_HEST1_OFFSET (MaxSectionsPerRecord),   "Max Sections Per Record", 0},
+    {ACPI_DMT_HESTNTFY, ACPI_HEST1_OFFSET (Notify),                 "Notify", 0},
+    {ACPI_DMT_UINT8,    ACPI_HEST1_OFFSET (NumHardwareBanks),       "Num Hardware Banks", 0},
+    {ACPI_DMT_UINT24,   ACPI_HEST1_OFFSET (Reserved2[0]),           "Reserved2", 0},
+    ACPI_DMT_TERMINATOR
+};
+
+/* 2: IA32 Non-Maskable Interrupt */
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoHest2[] =
+{
+    ACPI_DM_HEST_HEADER,
+    {ACPI_DMT_UINT32,   ACPI_HEST2_OFFSET (Reserved),               "Reserved", 0},
+    {ACPI_DMT_UINT32,   ACPI_HEST2_OFFSET (RecordsToPreallocate),   "Records To Preallocate", 0},
+    {ACPI_DMT_UINT32,   ACPI_HEST2_OFFSET (MaxSectionsPerRecord),   "Max Sections Per Record", 0},
+    {ACPI_DMT_UINT32,   ACPI_HEST2_OFFSET (MaxRawDataLength),       "Max Raw Data Length", 0},
+    ACPI_DMT_TERMINATOR
+};
+
+/* 6: PCI Express Root Port AER */
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoHest6[] =
+{
+    ACPI_DM_HEST_HEADER,
+    ACPI_DM_HEST_AER,
+    {ACPI_DMT_UINT32,   ACPI_HEST6_OFFSET (RootErrorCommand),       "Root Error Command", 0},
+    ACPI_DMT_TERMINATOR
+};
+
+/* 7: PCI Express AER (AER Endpoint) */
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoHest7[] =
+{
+    ACPI_DM_HEST_HEADER,
+    ACPI_DM_HEST_AER,
+    ACPI_DMT_TERMINATOR
+};
+
+/* 8: PCI Express/PCI-X Bridge AER */
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoHest8[] =
+{
+    ACPI_DM_HEST_HEADER,
+    ACPI_DM_HEST_AER,
+    {ACPI_DMT_UINT32,   ACPI_HEST8_OFFSET (UncorrectableMask2),     "2nd Uncorrectable Mask", 0},
+    {ACPI_DMT_UINT32,   ACPI_HEST8_OFFSET (UncorrectableSeverity2), "2nd Uncorrectable Severity", 0},
+    {ACPI_DMT_UINT32,   ACPI_HEST8_OFFSET (AdvancedCapabilities2),  "2nd Advanced Capabilities", 0},
+    ACPI_DMT_TERMINATOR
+};
+
+/* 9: Generic Hardware Error Source */
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoHest9[] =
+{
+    ACPI_DM_HEST_HEADER,
+    {ACPI_DMT_UINT16,   ACPI_HEST9_OFFSET (RelatedSourceId),        "Related Source Id", 0},
+    {ACPI_DMT_UINT8,    ACPI_HEST9_OFFSET (Reserved),               "Reserved", 0},
+    {ACPI_DMT_UINT8,    ACPI_HEST9_OFFSET (Enabled),                "Enabled", 0},
+    {ACPI_DMT_UINT32,   ACPI_HEST9_OFFSET (RecordsToPreallocate),   "Records To Preallocate", 0},
+    {ACPI_DMT_UINT32,   ACPI_HEST9_OFFSET (MaxSectionsPerRecord),   "Max Sections Per Record", 0},
+    {ACPI_DMT_UINT32,   ACPI_HEST9_OFFSET (MaxRawDataLength),       "Max Raw Data Length", 0},
+    {ACPI_DMT_GAS,      ACPI_HEST9_OFFSET (ErrorStatusAddress),     "Error Status Address", 0},
+    {ACPI_DMT_HESTNTFY, ACPI_HEST9_OFFSET (Notify),                 "Notify", 0},
+    {ACPI_DMT_UINT32,   ACPI_HEST9_OFFSET (ErrorBlockLength),       "Error Status Block Length", 0},
+    ACPI_DMT_TERMINATOR
+};
+
+/* 10: Generic Hardware Error Source - Version 2 */
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoHest10[] =
+{
+    ACPI_DM_HEST_HEADER,
+    {ACPI_DMT_UINT16,   ACPI_HEST10_OFFSET (RelatedSourceId),       "Related Source Id", 0},
+    {ACPI_DMT_UINT8,    ACPI_HEST10_OFFSET (Reserved),              "Reserved", 0},
+    {ACPI_DMT_UINT8,    ACPI_HEST10_OFFSET (Enabled),               "Enabled", 0},
+    {ACPI_DMT_UINT32,   ACPI_HEST10_OFFSET (RecordsToPreallocate),  "Records To Preallocate", 0},
+    {ACPI_DMT_UINT32,   ACPI_HEST10_OFFSET (MaxSectionsPerRecord),  "Max Sections Per Record", 0},
+    {ACPI_DMT_UINT32,   ACPI_HEST10_OFFSET (MaxRawDataLength),      "Max Raw Data Length", 0},
+    {ACPI_DMT_GAS,      ACPI_HEST10_OFFSET (ErrorStatusAddress),    "Error Status Address", 0},
+    {ACPI_DMT_HESTNTFY, ACPI_HEST10_OFFSET (Notify),                "Notify", 0},
+    {ACPI_DMT_UINT32,   ACPI_HEST10_OFFSET (ErrorBlockLength),      "Error Status Block Length", 0},
+    {ACPI_DMT_GAS,      ACPI_HEST10_OFFSET (ReadAckRegister),       "Read Ack Register", 0},
+    {ACPI_DMT_UINT64,   ACPI_HEST10_OFFSET (ReadAckPreserve),       "Read Ack Preserve", 0},
+    {ACPI_DMT_UINT64,   ACPI_HEST10_OFFSET (ReadAckWrite),          "Read Ack Write", 0},
+    ACPI_DMT_TERMINATOR
+};
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoHestNotify[] =
+{
+    {ACPI_DMT_HESTNTYP, ACPI_HESTN_OFFSET (Type),                   "Notify Type", 0},
+    {ACPI_DMT_UINT8,    ACPI_HESTN_OFFSET (Length),                 "Notify Length", DT_LENGTH},
+    {ACPI_DMT_UINT16,   ACPI_HESTN_OFFSET (ConfigWriteEnable),      "Configuration Write Enable", 0},
+    {ACPI_DMT_UINT32,   ACPI_HESTN_OFFSET (PollInterval),           "PollInterval", 0},
+    {ACPI_DMT_UINT32,   ACPI_HESTN_OFFSET (Vector),                 "Vector", 0},
+    {ACPI_DMT_UINT32,   ACPI_HESTN_OFFSET (PollingThresholdValue),  "Polling Threshold Value", 0},
+    {ACPI_DMT_UINT32,   ACPI_HESTN_OFFSET (PollingThresholdWindow), "Polling Threshold Window", 0},
+    {ACPI_DMT_UINT32,   ACPI_HESTN_OFFSET (ErrorThresholdValue),    "Error Threshold Value", 0},
+    {ACPI_DMT_UINT32,   ACPI_HESTN_OFFSET (ErrorThresholdWindow),   "Error Threshold Window", 0},
+    ACPI_DMT_TERMINATOR
+};
+
+
+/*
+ * IA32 Error Bank(s) - Follows the ACPI_HEST_IA_MACHINE_CHECK and
+ * ACPI_HEST_IA_CORRECTED structures.
+ */
+ACPI_DMTABLE_INFO           AcpiDmTableInfoHestBank[] =
+{
+    {ACPI_DMT_UINT8,    ACPI_HESTB_OFFSET (BankNumber),             "Bank Number", 0},
+    {ACPI_DMT_UINT8,    ACPI_HESTB_OFFSET (ClearStatusOnInit),      "Clear Status On Init", 0},
+    {ACPI_DMT_UINT8,    ACPI_HESTB_OFFSET (StatusFormat),           "Status Format", 0},
+    {ACPI_DMT_UINT8,    ACPI_HESTB_OFFSET (Reserved),               "Reserved", 0},
+    {ACPI_DMT_UINT32,   ACPI_HESTB_OFFSET (ControlRegister),        "Control Register", 0},
+    {ACPI_DMT_UINT64,   ACPI_HESTB_OFFSET (ControlData),            "Control Data", 0},
+    {ACPI_DMT_UINT32,   ACPI_HESTB_OFFSET (StatusRegister),         "Status Register", 0},
+    {ACPI_DMT_UINT32,   ACPI_HESTB_OFFSET (AddressRegister),        "Address Register", 0},
+    {ACPI_DMT_UINT32,   ACPI_HESTB_OFFSET (MiscRegister),           "Misc Register", 0},
+    ACPI_DMT_TERMINATOR
+};
+
+
+/*******************************************************************************
+ *
+ * HPET - High Precision Event Timer table
+ *
+ ******************************************************************************/
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoHpet[] =
+{
+    {ACPI_DMT_UINT32,   ACPI_HPET_OFFSET (Id),                      "Hardware Block ID", 0},
+    {ACPI_DMT_GAS,      ACPI_HPET_OFFSET (Address),                 "Timer Block Register", 0},
+    {ACPI_DMT_UINT8,    ACPI_HPET_OFFSET (Sequence),                "Sequence Number", 0},
+    {ACPI_DMT_UINT16,   ACPI_HPET_OFFSET (MinimumTick),             "Minimum Clock Ticks", 0},
+    {ACPI_DMT_UINT8,    ACPI_HPET_OFFSET (Flags),                   "Flags (decoded below)", DT_FLAG},
+    {ACPI_DMT_FLAG0,    ACPI_HPET_FLAG_OFFSET (Flags,0),            "4K Page Protect", 0},
+    {ACPI_DMT_FLAG1,    ACPI_HPET_FLAG_OFFSET (Flags,0),            "64K Page Protect", 0},
+    ACPI_DMT_TERMINATOR
+};
+
+
+/*******************************************************************************
+ *
+ * IORT - IO Remapping Table
+ *
+ ******************************************************************************/
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoIort[] =
+{
+    {ACPI_DMT_UINT32,   ACPI_IORT_OFFSET (NodeCount),               "Node Count", 0},
+    {ACPI_DMT_UINT32,   ACPI_IORT_OFFSET (NodeOffset),              "Node Offset", 0},
+    {ACPI_DMT_UINT32,   ACPI_IORT_OFFSET (Reserved),                "Reserved", 0},
+    ACPI_DMT_TERMINATOR
+};
+
+/* Optional padding field */
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoIortPad[] =
+{
+    {ACPI_DMT_RAW_BUFFER, 0,                                        "Optional Padding", DT_OPTIONAL},
+    ACPI_DMT_TERMINATOR
+};
+
+/* Common Subtable header (one per Subtable) */
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoIortHdr[] =
+{
+    {ACPI_DMT_UINT8,    ACPI_IORTH_OFFSET (Type),                   "Type", 0},
+    {ACPI_DMT_UINT16,   ACPI_IORTH_OFFSET (Length),                 "Length", DT_LENGTH},
+    {ACPI_DMT_UINT8,    ACPI_IORTH_OFFSET (Revision),               "Revision", 0},
+    {ACPI_DMT_UINT32,   ACPI_IORTH_OFFSET (Reserved),               "Reserved", 0},
+    {ACPI_DMT_UINT32,   ACPI_IORTH_OFFSET (MappingCount),           "Mapping Count", 0},
+    {ACPI_DMT_UINT32,   ACPI_IORTH_OFFSET (MappingOffset),          "Mapping Offset", 0},
+    ACPI_DMT_TERMINATOR
+};
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoIortMap[] =
+{
+    {ACPI_DMT_UINT32,   ACPI_IORTM_OFFSET (InputBase),              "Input base", DT_OPTIONAL},
+    {ACPI_DMT_UINT32,   ACPI_IORTM_OFFSET (IdCount),                "ID Count", 0},
+    {ACPI_DMT_UINT32,   ACPI_IORTM_OFFSET (OutputBase),             "Output Base", 0},
+    {ACPI_DMT_UINT32,   ACPI_IORTM_OFFSET (OutputReference),        "Output Reference", 0},
+    {ACPI_DMT_UINT32,   ACPI_IORTM_OFFSET (Flags),                  "Flags (decoded below)", 0},
+    {ACPI_DMT_FLAG0,    ACPI_IORTM_FLAG_OFFSET (Flags, 0),          "Single Mapping", 0},
+    ACPI_DMT_TERMINATOR
+};
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoIortAcc[] =
+{
+    {ACPI_DMT_UINT32,   ACPI_IORTA_OFFSET (CacheCoherency),         "Cache Coherency", 0},
+    {ACPI_DMT_UINT8,    ACPI_IORTA_OFFSET (Hints),                  "Hints (decoded below)", 0},
+    {ACPI_DMT_FLAG0,    ACPI_IORTA_FLAG_OFFSET (Hints, 0),          "Transient", 0},
+    {ACPI_DMT_FLAG1,    ACPI_IORTA_FLAG_OFFSET (Hints, 0),          "Write Allocate", 0},
+    {ACPI_DMT_FLAG2,    ACPI_IORTA_FLAG_OFFSET (Hints, 0),          "Read Allocate", 0},
+    {ACPI_DMT_FLAG3,    ACPI_IORTA_FLAG_OFFSET (Hints, 0),          "Override", 0},
+    {ACPI_DMT_UINT16,   ACPI_IORTA_OFFSET (Reserved),               "Reserved", 0},
+    {ACPI_DMT_UINT8,    ACPI_IORTA_OFFSET (MemoryFlags),            "Memory Flags (decoded below)", 0},
+    {ACPI_DMT_FLAG0,    ACPI_IORTA_FLAG_OFFSET (MemoryFlags, 0),    "Coherency", 0},
+    {ACPI_DMT_FLAG1,    ACPI_IORTA_FLAG_OFFSET (MemoryFlags, 0),    "Device Attribute", 0},
+    ACPI_DMT_TERMINATOR
+};
+
+/* IORT subtables */
+
+/* 0x00: ITS Group */
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoIort0[] =
+{
+    {ACPI_DMT_UINT32,   ACPI_IORT0_OFFSET (ItsCount),               "ItsCount", 0},
+    ACPI_DMT_TERMINATOR
+};
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoIort0a[] =
+{
+    {ACPI_DMT_UINT32,   0,                                          "Identifiers", DT_OPTIONAL},
+    ACPI_DMT_TERMINATOR
+};
+
+/* 0x01: Named Component */
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoIort1[] =
+{
+    {ACPI_DMT_UINT32,   ACPI_IORT1_OFFSET (NodeFlags),              "Node Flags", 0},
+    {ACPI_DMT_IORTMEM,  ACPI_IORT1_OFFSET (MemoryProperties),       "Memory Properties", 0},
+    {ACPI_DMT_UINT8,    ACPI_IORT1_OFFSET (MemoryAddressLimit),     "Memory Size Limit", 0},
+    {ACPI_DMT_STRING,   ACPI_IORT1_OFFSET (DeviceName[0]),          "Device Name", 0},
+    ACPI_DMT_TERMINATOR
+};
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoIort1a[] =
+{
+    {ACPI_DMT_RAW_BUFFER, 0,                                        "Padding", DT_OPTIONAL},
+    ACPI_DMT_TERMINATOR
+};
+
+/* 0x02: PCI Root Complex */
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoIort2[] =
+{
+    {ACPI_DMT_IORTMEM,  ACPI_IORT2_OFFSET (MemoryProperties),       "Memory Properties", 0},
+    {ACPI_DMT_UINT32,   ACPI_IORT2_OFFSET (AtsAttribute),           "ATS Attribute", 0},
+    {ACPI_DMT_UINT32,   ACPI_IORT2_OFFSET (PciSegmentNumber),       "PCI Segment Number", 0},
+    ACPI_DMT_TERMINATOR
+};
+
+/* 0x03: SMMUv1/2 */
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoIort3[] =
+{
+    {ACPI_DMT_UINT64,   ACPI_IORT3_OFFSET (BaseAddress),            "Base Address", 0},
+    {ACPI_DMT_UINT64,   ACPI_IORT3_OFFSET (Span),                   "Span", 0},
+    {ACPI_DMT_UINT32,   ACPI_IORT3_OFFSET (Model),                  "Model", 0},
+    {ACPI_DMT_UINT32,   ACPI_IORT3_OFFSET (Flags),                  "Flags (decoded below)", 0},
+    {ACPI_DMT_FLAG0,    ACPI_IORT3_FLAG_OFFSET (Flags, 0),          "DVM Supported", 0},
+    {ACPI_DMT_FLAG1,    ACPI_IORT3_FLAG_OFFSET (Flags, 0),          "Coherent Walk", 0},
+    {ACPI_DMT_UINT32,   ACPI_IORT3_OFFSET (GlobalInterruptOffset),  "Global Interrupt Offset", 0},
+    {ACPI_DMT_UINT32,   ACPI_IORT3_OFFSET (ContextInterruptCount),  "Context Interrupt Count", 0},
+    {ACPI_DMT_UINT32,   ACPI_IORT3_OFFSET (ContextInterruptOffset), "Context Interrupt Offset", 0},
+    {ACPI_DMT_UINT32,   ACPI_IORT3_OFFSET (PmuInterruptCount),      "PMU Interrupt Count", 0},
+    {ACPI_DMT_UINT32,   ACPI_IORT3_OFFSET (PmuInterruptOffset),     "PMU Interrupt Offset", 0},
+    ACPI_DMT_TERMINATOR
+};
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoIort3a[] =
+{
+    {ACPI_DMT_UINT64,   0,                                          "SMMU_NSgIrpt Interrupt", 0},
+    {ACPI_DMT_UINT64,   0,                                          "SMMU_NSgCfgIrpt Interrupt", 0},
+    ACPI_DMT_TERMINATOR
+};
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoIort3b[] =
+{
+    {ACPI_DMT_UINT64,   0,                                          "Context Interrupt", DT_OPTIONAL},
+    ACPI_DMT_TERMINATOR
+};
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoIort3c[] =
+{
+    {ACPI_DMT_UINT64,   0,                                          "PMU Interrupt", DT_OPTIONAL},
+    ACPI_DMT_TERMINATOR
+};
+
+/* 0x04: SMMUv3 */
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoIort4[] =
+{
+    {ACPI_DMT_UINT64,   ACPI_IORT4_OFFSET (BaseAddress),            "Base Address", 0},
+    {ACPI_DMT_UINT32,   ACPI_IORT4_OFFSET (Flags),                  "Flags (decoded below)", 0},
+    {ACPI_DMT_FLAG0,    ACPI_IORT4_FLAG_OFFSET (Flags, 0),          "COHACC Override", 0},
+    {ACPI_DMT_FLAG1,    ACPI_IORT4_FLAG_OFFSET (Flags, 0),          "HTTU Override", 0},
+    {ACPI_DMT_UINT32,   ACPI_IORT4_OFFSET (Reserved),               "Reserved", 0},
+    {ACPI_DMT_UINT64,   ACPI_IORT4_OFFSET (VatosAddress),           "VATOS Address", 0},
+    {ACPI_DMT_UINT32,   ACPI_IORT4_OFFSET (Model),                  "Model", 0},
+    {ACPI_DMT_UINT32,   ACPI_IORT4_OFFSET (EventGsiv),              "Event GSIV", 0},
+    {ACPI_DMT_UINT32,   ACPI_IORT4_OFFSET (PriGsiv),                "PRI GSIV", 0},
+    {ACPI_DMT_UINT32,   ACPI_IORT4_OFFSET (GerrGsiv),               "GERR GSIV", 0},
+    {ACPI_DMT_UINT32,   ACPI_IORT4_OFFSET (SyncGsiv),               "Sync GSIV", 0},
+    ACPI_DMT_TERMINATOR
+};
+
+/*******************************************************************************
+ *
+ * IVRS - I/O Virtualization Reporting Structure
+ *
+ ******************************************************************************/
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoIvrs[] =
+{
+    {ACPI_DMT_UINT32,   ACPI_IVRS_OFFSET (Info),                    "Virtualization Info", 0},
+    {ACPI_DMT_UINT64,   ACPI_IVRS_OFFSET (Reserved),                "Reserved", 0},
+    ACPI_DMT_TERMINATOR
+};
+
+/* Common Subtable header (one per Subtable) */
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoIvrsHdr[] =
+{
+    {ACPI_DMT_IVRS,     ACPI_IVRSH_OFFSET (Type),                   "Subtable Type", 0},
+    {ACPI_DMT_UINT8,    ACPI_IVRSH_OFFSET (Flags),                  "Flags", 0},
+    {ACPI_DMT_UINT16,   ACPI_IVRSH_OFFSET (Length),                 "Length", DT_LENGTH},
+    {ACPI_DMT_UINT16,   ACPI_IVRSH_OFFSET (DeviceId),               "DeviceId", 0},
+    ACPI_DMT_TERMINATOR
+};
+
+/* IVRS subtables */
+
+/* 0x10: I/O Virtualization Hardware Definition (IVHD) Block */
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoIvrs0[] =
+{
+    {ACPI_DMT_UINT16,   ACPI_IVRS0_OFFSET (CapabilityOffset),       "Capability Offset", 0},
+    {ACPI_DMT_UINT64,   ACPI_IVRS0_OFFSET (BaseAddress),            "Base Address", 0},
+    {ACPI_DMT_UINT16,   ACPI_IVRS0_OFFSET (PciSegmentGroup),        "PCI Segment Group", 0},
+    {ACPI_DMT_UINT16,   ACPI_IVRS0_OFFSET (Info),                   "Virtualization Info", 0},
+    {ACPI_DMT_UINT32,   ACPI_IVRS0_OFFSET (Reserved),               "Reserved", 0},
+    ACPI_DMT_TERMINATOR
+};
+
+/* 0x20, 0x21, 0x22: I/O Virtualization Memory Definition (IVMD) Block */
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoIvrs1[] =
+{
+    {ACPI_DMT_UINT16,   ACPI_IVRS1_OFFSET (AuxData),                "Auxiliary Data", 0},
+    {ACPI_DMT_UINT64,   ACPI_IVRS1_OFFSET (Reserved),               "Reserved", 0},
+    {ACPI_DMT_UINT64,   ACPI_IVRS1_OFFSET (StartAddress),           "Start Address", 0},
+    {ACPI_DMT_UINT64,   ACPI_IVRS1_OFFSET (MemoryLength),           "Memory Length", 0},
+    ACPI_DMT_TERMINATOR
+};
+
+/* Device entry header for IVHD block */
+
+#define ACPI_DMT_IVRS_DE_HEADER \
+    {ACPI_DMT_UINT8,    ACPI_IVRSD_OFFSET (Type),                   "Entry Type", 0}, \
+    {ACPI_DMT_UINT16,   ACPI_IVRSD_OFFSET (Id),                     "Device ID", 0}, \
+    {ACPI_DMT_UINT8,    ACPI_IVRSD_OFFSET (DataSetting),            "Data Setting", 0}
+
+/* 4-byte device entry */
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoIvrs4[] =
+{
+    ACPI_DMT_IVRS_DE_HEADER,
+    {ACPI_DMT_EXIT,     0,                                          NULL, 0},
+};
+
+/* 8-byte device entry */
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoIvrs8a[] =
+{
+    ACPI_DMT_IVRS_DE_HEADER,
+    {ACPI_DMT_UINT8,    ACPI_IVRS8A_OFFSET (Reserved1),             "Reserved", 0},
+    {ACPI_DMT_UINT16,   ACPI_IVRS8A_OFFSET (UsedId),                "Source Used Device ID", 0},
+    {ACPI_DMT_UINT8,    ACPI_IVRS8A_OFFSET (Reserved2),             "Reserved", 0},
+    ACPI_DMT_TERMINATOR
+};
+
+/* 8-byte device entry */
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoIvrs8b[] =
+{
+    ACPI_DMT_IVRS_DE_HEADER,
+    {ACPI_DMT_UINT32,   ACPI_IVRS8B_OFFSET (ExtendedData),          "Extended Data", 0},
+    ACPI_DMT_TERMINATOR
+};
+
+/* 8-byte device entry */
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoIvrs8c[] =
+{
+    ACPI_DMT_IVRS_DE_HEADER,
+    {ACPI_DMT_UINT8,    ACPI_IVRS8C_OFFSET (Handle),                "Handle", 0},
+    {ACPI_DMT_UINT16,   ACPI_IVRS8C_OFFSET (UsedId),                "Source Used Device ID", 0},
+    {ACPI_DMT_UINT8,    ACPI_IVRS8C_OFFSET (Variety),               "Variety", 0},
+    ACPI_DMT_TERMINATOR
+};
+
+
+/*******************************************************************************
+ *
+ * LPIT - Low Power Idle Table
+ *
+ ******************************************************************************/
+
+/* Main table consists only of the standard ACPI table header */
+
+/* Common Subtable header (one per Subtable) */
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoLpitHdr[] =
+{
+    {ACPI_DMT_LPIT,     ACPI_LPITH_OFFSET (Type),                   "Subtable Type", 0},
+    {ACPI_DMT_UINT32,   ACPI_LPITH_OFFSET (Length),                 "Length", DT_LENGTH},
+    {ACPI_DMT_UINT16,   ACPI_LPITH_OFFSET (UniqueId),               "Unique ID", 0},
+    {ACPI_DMT_UINT16,   ACPI_LPITH_OFFSET (Reserved),               "Reserved", 0},
+    {ACPI_DMT_UINT32,   ACPI_LPITH_OFFSET (Flags),                  "Flags (decoded below)", DT_FLAG},
+    {ACPI_DMT_FLAG0,    ACPI_LPITH_FLAG_OFFSET (Flags, 0),          "State Disabled", 0},
+    {ACPI_DMT_FLAG1,    ACPI_LPITH_FLAG_OFFSET (Flags, 0),          "No Counter", 0},
+    ACPI_DMT_TERMINATOR
+};
+
+/* LPIT Subtables */
+
+/* 0: Native C-state */
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoLpit0[] =
+{
+    {ACPI_DMT_GAS,      ACPI_LPIT0_OFFSET (EntryTrigger),           "Entry Trigger", 0},
+    {ACPI_DMT_UINT32,   ACPI_LPIT0_OFFSET (Residency),              "Residency", 0},
+    {ACPI_DMT_UINT32,   ACPI_LPIT0_OFFSET (Latency),                "Latency", 0},
+    {ACPI_DMT_GAS,      ACPI_LPIT0_OFFSET (ResidencyCounter),       "Residency Counter", 0},
+    {ACPI_DMT_UINT64,   ACPI_LPIT0_OFFSET (CounterFrequency),       "Counter Frequency", 0},
+    ACPI_DMT_TERMINATOR
+};
+
+
+/*******************************************************************************
+ *
+ * MADT - Multiple APIC Description Table and subtables
+ *
+ ******************************************************************************/
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoMadt[] =
+{
+    {ACPI_DMT_UINT32,   ACPI_MADT_OFFSET (Address),                 "Local Apic Address", 0},
+    {ACPI_DMT_UINT32,   ACPI_MADT_OFFSET (Flags),                   "Flags (decoded below)", DT_FLAG},
+    {ACPI_DMT_FLAG0,    ACPI_MADT_FLAG_OFFSET (Flags,0),            "PC-AT Compatibility", 0},
+    ACPI_DMT_TERMINATOR
+};
+
+/* Common Subtable header (one per Subtable) */
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoMadtHdr[] =
+{
+    {ACPI_DMT_MADT,     ACPI_MADTH_OFFSET (Type),                   "Subtable Type", 0},
+    {ACPI_DMT_UINT8,    ACPI_MADTH_OFFSET (Length),                 "Length", DT_LENGTH},
+    ACPI_DMT_TERMINATOR
+};
+
+/* MADT Subtables */
+
+/* 0: processor APIC */
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoMadt0[] =
+{
+    {ACPI_DMT_UINT8,    ACPI_MADT0_OFFSET (ProcessorId),            "Processor ID", 0},
+    {ACPI_DMT_UINT8,    ACPI_MADT0_OFFSET (Id),                     "Local Apic ID", 0},
+    {ACPI_DMT_UINT32,   ACPI_MADT0_OFFSET (LapicFlags),             "Flags (decoded below)", DT_FLAG},
+    {ACPI_DMT_FLAG0,    ACPI_MADT0_FLAG_OFFSET (LapicFlags,0),      "Processor Enabled", 0},
+    ACPI_DMT_TERMINATOR
+};
+
+/* 1: IO APIC */
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoMadt1[] =
+{
+    {ACPI_DMT_UINT8,    ACPI_MADT1_OFFSET (Id),                     "I/O Apic ID", 0},
+    {ACPI_DMT_UINT8,    ACPI_MADT1_OFFSET (Reserved),               "Reserved", 0},
+    {ACPI_DMT_UINT32,   ACPI_MADT1_OFFSET (Address),                "Address", 0},
+    {ACPI_DMT_UINT32,   ACPI_MADT1_OFFSET (GlobalIrqBase),          "Interrupt", 0},
+    ACPI_DMT_TERMINATOR
+};
+
+/* 2: Interrupt Override */
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoMadt2[] =
+{
+    {ACPI_DMT_UINT8,    ACPI_MADT2_OFFSET (Bus),                    "Bus", 0},
+    {ACPI_DMT_UINT8,    ACPI_MADT2_OFFSET (SourceIrq),              "Source", 0},
+    {ACPI_DMT_UINT32,   ACPI_MADT2_OFFSET (GlobalIrq),              "Interrupt", 0},
+    {ACPI_DMT_UINT16,   ACPI_MADT2_OFFSET (IntiFlags),              "Flags (decoded below)", DT_FLAG},
+    {ACPI_DMT_FLAGS0,   ACPI_MADT2_FLAG_OFFSET (IntiFlags,0),       "Polarity", 0},
+    {ACPI_DMT_FLAGS2,   ACPI_MADT2_FLAG_OFFSET (IntiFlags,0),       "Trigger Mode", 0},
+    ACPI_DMT_TERMINATOR
+};
+
+/* 3: NMI Sources */
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoMadt3[] =
+{
+    {ACPI_DMT_UINT16,   ACPI_MADT3_OFFSET (IntiFlags),              "Flags (decoded below)", DT_FLAG},
+    {ACPI_DMT_FLAGS0,   ACPI_MADT3_FLAG_OFFSET (IntiFlags,0),       "Polarity", 0},
+    {ACPI_DMT_FLAGS2,   ACPI_MADT3_FLAG_OFFSET (IntiFlags,0),       "Trigger Mode", 0},
+    {ACPI_DMT_UINT32,   ACPI_MADT3_OFFSET (GlobalIrq),              "Interrupt", 0},
+    ACPI_DMT_TERMINATOR
+};
+
+/* 4: Local APIC NMI */
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoMadt4[] =
+{
+    {ACPI_DMT_UINT8,    ACPI_MADT4_OFFSET (ProcessorId),            "Processor ID", 0},
+    {ACPI_DMT_UINT16,   ACPI_MADT4_OFFSET (IntiFlags),              "Flags (decoded below)", DT_FLAG},
+    {ACPI_DMT_FLAGS0,   ACPI_MADT4_FLAG_OFFSET (IntiFlags,0),       "Polarity", 0},
+    {ACPI_DMT_FLAGS2,   ACPI_MADT4_FLAG_OFFSET (IntiFlags,0),       "Trigger Mode", 0},
+    {ACPI_DMT_UINT8,    ACPI_MADT4_OFFSET (Lint),                   "Interrupt Input LINT", 0},
+    ACPI_DMT_TERMINATOR
+};
+
+/* 5: Address Override */
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoMadt5[] =
+{
+    {ACPI_DMT_UINT16,   ACPI_MADT5_OFFSET (Reserved),               "Reserved", 0},
+    {ACPI_DMT_UINT64,   ACPI_MADT5_OFFSET (Address),                "APIC Address", 0},
+    ACPI_DMT_TERMINATOR
+};
+
+/* 6: I/O Sapic */
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoMadt6[] =
+{
+    {ACPI_DMT_UINT8,    ACPI_MADT6_OFFSET (Id),                     "I/O Sapic ID", 0},
+    {ACPI_DMT_UINT8,    ACPI_MADT6_OFFSET (Reserved),               "Reserved", 0},
+    {ACPI_DMT_UINT32,   ACPI_MADT6_OFFSET (GlobalIrqBase),          "Interrupt Base", 0},
+    {ACPI_DMT_UINT64,   ACPI_MADT6_OFFSET (Address),                "Address", 0},
+    ACPI_DMT_TERMINATOR
+};
+
+/* 7: Local Sapic */
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoMadt7[] =
+{
+    {ACPI_DMT_UINT8,    ACPI_MADT7_OFFSET (ProcessorId),            "Processor ID", 0},
+    {ACPI_DMT_UINT8,    ACPI_MADT7_OFFSET (Id),                     "Local Sapic ID", 0},
+    {ACPI_DMT_UINT8,    ACPI_MADT7_OFFSET (Eid),                    "Local Sapic EID", 0},
+    {ACPI_DMT_UINT24,   ACPI_MADT7_OFFSET (Reserved[0]),            "Reserved", 0},
+    {ACPI_DMT_UINT32,   ACPI_MADT7_OFFSET (LapicFlags),             "Flags (decoded below)", DT_FLAG},
+    {ACPI_DMT_FLAG0,    ACPI_MADT7_FLAG_OFFSET (LapicFlags,0),      "Processor Enabled", 0},
+    {ACPI_DMT_UINT32,   ACPI_MADT7_OFFSET (Uid),                    "Processor UID", 0},
+    {ACPI_DMT_STRING,   ACPI_MADT7_OFFSET (UidString[0]),           "Processor UID String", 0},
+    ACPI_DMT_TERMINATOR
+};
+
+/* 8: Platform Interrupt Source */
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoMadt8[] =
+{
+    {ACPI_DMT_UINT16,   ACPI_MADT8_OFFSET (IntiFlags),              "Flags (decoded below)", DT_FLAG},
+    {ACPI_DMT_FLAGS0,   ACPI_MADT8_FLAG_OFFSET (IntiFlags,0),       "Polarity", 0},
+    {ACPI_DMT_FLAGS2,   ACPI_MADT8_FLAG_OFFSET (IntiFlags,0),       "Trigger Mode", 0},
+    {ACPI_DMT_UINT8,    ACPI_MADT8_OFFSET (Type),                   "InterruptType", 0},
+    {ACPI_DMT_UINT8,    ACPI_MADT8_OFFSET (Id),                     "Processor ID", 0},
+    {ACPI_DMT_UINT8,    ACPI_MADT8_OFFSET (Eid),                    "Processor EID", 0},
+    {ACPI_DMT_UINT8,    ACPI_MADT8_OFFSET (IoSapicVector),          "I/O Sapic Vector", 0},
+    {ACPI_DMT_UINT32,   ACPI_MADT8_OFFSET (GlobalIrq),              "Interrupt", 0},
+    {ACPI_DMT_UINT32,   ACPI_MADT8_OFFSET (Flags),                  "Flags (decoded below)", DT_FLAG},
+    {ACPI_DMT_FLAG0,    ACPI_MADT8_OFFSET (Flags),                  "CPEI Override", 0},
+    ACPI_DMT_TERMINATOR
+};
+
+/* 9: Processor Local X2_APIC (ACPI 4.0) */
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoMadt9[] =
+{
+    {ACPI_DMT_UINT16,   ACPI_MADT9_OFFSET (Reserved),               "Reserved", 0},
+    {ACPI_DMT_UINT32,   ACPI_MADT9_OFFSET (LocalApicId),            "Processor x2Apic ID", 0},
+    {ACPI_DMT_UINT32,   ACPI_MADT9_OFFSET (LapicFlags),             "Flags (decoded below)", DT_FLAG},
+    {ACPI_DMT_FLAG0,    ACPI_MADT9_FLAG_OFFSET (LapicFlags,0),      "Processor Enabled", 0},
+    {ACPI_DMT_UINT32,   ACPI_MADT9_OFFSET (Uid),                    "Processor UID", 0},
+    ACPI_DMT_TERMINATOR
+};
+
+/* 10: Local X2_APIC NMI (ACPI 4.0) */
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoMadt10[] =
+{
+    {ACPI_DMT_UINT16,   ACPI_MADT10_OFFSET (IntiFlags),             "Flags (decoded below)", DT_FLAG},
+    {ACPI_DMT_FLAGS0,   ACPI_MADT10_FLAG_OFFSET (IntiFlags,0),      "Polarity", 0},
+    {ACPI_DMT_FLAGS2,   ACPI_MADT10_FLAG_OFFSET (IntiFlags,0),      "Trigger Mode", 0},
+    {ACPI_DMT_UINT32,   ACPI_MADT10_OFFSET (Uid),                   "Processor UID", 0},
+    {ACPI_DMT_UINT8,    ACPI_MADT10_OFFSET (Lint),                  "Interrupt Input LINT", 0},
+    {ACPI_DMT_UINT24,   ACPI_MADT10_OFFSET (Reserved[0]),           "Reserved", 0},
+    ACPI_DMT_TERMINATOR
+};
+
+/* 11: Generic Interrupt Controller (ACPI 5.0) */
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoMadt11[] =
+{
+    {ACPI_DMT_UINT16,   ACPI_MADT11_OFFSET (Reserved),              "Reserved", 0},
+    {ACPI_DMT_UINT32,   ACPI_MADT11_OFFSET (CpuInterfaceNumber),    "CPU Interface Number", 0},
+    {ACPI_DMT_UINT32,   ACPI_MADT11_OFFSET (Uid),                   "Processor UID", 0},
+    {ACPI_DMT_UINT32,   ACPI_MADT11_OFFSET (Flags),                 "Flags (decoded below)", DT_FLAG},
+    {ACPI_DMT_FLAG0,    ACPI_MADT11_FLAG_OFFSET (Flags,0),          "Processor Enabled", 0},
+    {ACPI_DMT_FLAG1,    ACPI_MADT11_FLAG_OFFSET (Flags,0),          "Performance Interrupt Trigger Mode", 0},
+    {ACPI_DMT_FLAG2,    ACPI_MADT11_FLAG_OFFSET (Flags,0),          "Virtual GIC Interrupt Trigger Mode", 0},
+    {ACPI_DMT_UINT32,   ACPI_MADT11_OFFSET (ParkingVersion),        "Parking Protocol Version", 0},
+    {ACPI_DMT_UINT32,   ACPI_MADT11_OFFSET (PerformanceInterrupt),  "Performance Interrupt", 0},
+    {ACPI_DMT_UINT64,   ACPI_MADT11_OFFSET (ParkedAddress),         "Parked Address", 0},
+    {ACPI_DMT_UINT64,   ACPI_MADT11_OFFSET (BaseAddress),           "Base Address", 0},
+    {ACPI_DMT_UINT64,   ACPI_MADT11_OFFSET (GicvBaseAddress),       "Virtual GIC Base Address", 0},
+    {ACPI_DMT_UINT64,   ACPI_MADT11_OFFSET (GichBaseAddress),       "Hypervisor GIC Base Address", 0},
+    {ACPI_DMT_UINT32,   ACPI_MADT11_OFFSET (VgicInterrupt),         "Virtual GIC Interrupt", 0},
+    {ACPI_DMT_UINT64,   ACPI_MADT11_OFFSET (GicrBaseAddress),       "Redistributor Base Address", 0},
+    {ACPI_DMT_UINT64,   ACPI_MADT11_OFFSET (ArmMpidr),              "ARM MPIDR", 0},
+    {ACPI_DMT_UINT8,    ACPI_MADT11_OFFSET (EfficiencyClass),       "Efficiency Class", 0},
+    {ACPI_DMT_UINT24,   ACPI_MADT11_OFFSET (Reserved2[0]),          "Reserved", 0},
+    ACPI_DMT_TERMINATOR
+};
+
+/* 12: Generic Interrupt Distributor (ACPI 5.0) */
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoMadt12[] =
+{
+    {ACPI_DMT_UINT16,   ACPI_MADT12_OFFSET (Reserved),              "Reserved", 0},
+    {ACPI_DMT_UINT32,   ACPI_MADT12_OFFSET (GicId),                 "Local GIC Hardware ID", 0},
+    {ACPI_DMT_UINT64,   ACPI_MADT12_OFFSET (BaseAddress),           "Base Address", 0},
+    {ACPI_DMT_UINT32,   ACPI_MADT12_OFFSET (GlobalIrqBase),         "Interrupt Base", 0},
+    {ACPI_DMT_UINT8,    ACPI_MADT12_OFFSET (Version),               "Version", 0},
+    {ACPI_DMT_UINT24,   ACPI_MADT12_OFFSET (Reserved2[0]),          "Reserved", 0},
+   ACPI_DMT_TERMINATOR
+};
+
+/* 13: Generic MSI Frame (ACPI 5.1) */
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoMadt13[] =
+{
+    {ACPI_DMT_UINT16,   ACPI_MADT13_OFFSET (Reserved),              "Reserved", 0},
+    {ACPI_DMT_UINT32,   ACPI_MADT13_OFFSET (MsiFrameId),            "MSI Frame ID", 0},
+    {ACPI_DMT_UINT64,   ACPI_MADT13_OFFSET (BaseAddress),           "Base Address", 0},
+    {ACPI_DMT_UINT32,   ACPI_MADT13_OFFSET (Flags),                 "Flags (decoded below)", DT_FLAG},
+    {ACPI_DMT_FLAG0,    ACPI_MADT13_FLAG_OFFSET (Flags,0),          "Select SPI", 0},
+    {ACPI_DMT_UINT16,   ACPI_MADT13_OFFSET (SpiCount),              "SPI Count", 0},
+    {ACPI_DMT_UINT16,   ACPI_MADT13_OFFSET (SpiBase),               "SPI Base", 0},
+   ACPI_DMT_TERMINATOR
+};
+
+/* 14: Generic Redistributor (ACPI 5.1) */
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoMadt14[] =
+{
+    {ACPI_DMT_UINT16,   ACPI_MADT14_OFFSET (Reserved),              "Reserved", 0},
+    {ACPI_DMT_UINT64,   ACPI_MADT14_OFFSET (BaseAddress),           "Base Address", 0},
+    {ACPI_DMT_UINT32,   ACPI_MADT14_OFFSET (Length),                "Length", 0},
+   ACPI_DMT_TERMINATOR
+};
+
+/* 15: Generic Translator (ACPI 6.0) */
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoMadt15[] =
+{
+    {ACPI_DMT_UINT16,   ACPI_MADT15_OFFSET (Reserved),              "Reserved", 0},
+    {ACPI_DMT_UINT32,   ACPI_MADT15_OFFSET (TranslationId),         "Translation ID", 0},
+    {ACPI_DMT_UINT64,   ACPI_MADT15_OFFSET (BaseAddress),           "Base Address", 0},
+    {ACPI_DMT_UINT32,   ACPI_MADT15_OFFSET (Reserved2),             "Reserved", 0},
+   ACPI_DMT_TERMINATOR
+};
+
+/*******************************************************************************
+ *
+ * MCFG - PCI Memory Mapped Configuration table and Subtable
+ *
+ ******************************************************************************/
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoMcfg[] =
+{
+    {ACPI_DMT_UINT64,   ACPI_MCFG_OFFSET (Reserved[0]),             "Reserved", 0},
+    ACPI_DMT_TERMINATOR
+};
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoMcfg0[] =
+{
+    {ACPI_DMT_UINT64,   ACPI_MCFG0_OFFSET (Address),                "Base Address", 0},
+    {ACPI_DMT_UINT16,   ACPI_MCFG0_OFFSET (PciSegment),             "Segment Group Number", 0},
+    {ACPI_DMT_UINT8,    ACPI_MCFG0_OFFSET (StartBusNumber),         "Start Bus Number", 0},
+    {ACPI_DMT_UINT8,    ACPI_MCFG0_OFFSET (EndBusNumber),           "End Bus Number", 0},
+    {ACPI_DMT_UINT32,   ACPI_MCFG0_OFFSET (Reserved),               "Reserved", 0},
+    ACPI_DMT_TERMINATOR
+};
+
+
+/*******************************************************************************
+ *
+ * MCHI - Management Controller Host Interface table
+ *
+ ******************************************************************************/
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoMchi[] =
+{
+    {ACPI_DMT_UINT8,    ACPI_MCHI_OFFSET (InterfaceType),           "Interface Type", 0},
+    {ACPI_DMT_UINT8,    ACPI_MCHI_OFFSET (Protocol),                "Protocol", 0},
+    {ACPI_DMT_UINT64,   ACPI_MCHI_OFFSET (ProtocolData),            "Protocol Data", 0},
+    {ACPI_DMT_UINT8,    ACPI_MCHI_OFFSET (InterruptType),           "Interrupt Type", 0},
+    {ACPI_DMT_UINT8,    ACPI_MCHI_OFFSET (Gpe),                     "Gpe", 0},
+    {ACPI_DMT_UINT8,    ACPI_MCHI_OFFSET (PciDeviceFlag),           "Pci Device Flag", 0},
+    {ACPI_DMT_UINT32,   ACPI_MCHI_OFFSET (GlobalInterrupt),         "Global Interrupt", 0},
+    {ACPI_DMT_GAS,      ACPI_MCHI_OFFSET (ControlRegister),         "Control Register", 0},
+    {ACPI_DMT_UINT8,    ACPI_MCHI_OFFSET (PciSegment),              "Pci Segment", 0},
+    {ACPI_DMT_UINT8,    ACPI_MCHI_OFFSET (PciBus),                  "Pci Bus", 0},
+    {ACPI_DMT_UINT8,    ACPI_MCHI_OFFSET (PciDevice),               "Pci Device", 0},
+    {ACPI_DMT_UINT8,    ACPI_MCHI_OFFSET (PciFunction),             "Pci Function", 0},
+    ACPI_DMT_TERMINATOR
+};
+
+
+/*******************************************************************************
+ *
+ * MPST - Memory Power State Table
+ *
+ ******************************************************************************/
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoMpst[] =
+{
+    {ACPI_DMT_UINT8,    ACPI_MPST_OFFSET (ChannelId),               "Channel ID", 0},
+    {ACPI_DMT_UINT24,   ACPI_MPST_OFFSET (Reserved1[0]),            "Reserved", 0},
+    {ACPI_DMT_UINT16,   ACPI_MPST_OFFSET (PowerNodeCount),          "Power Node Count", 0},
+    {ACPI_DMT_UINT16,   ACPI_MPST_OFFSET (Reserved2),               "Reserved", 0},
+    ACPI_DMT_TERMINATOR
+};
+
+/* MPST subtables */
+
+/* 0: Memory Power Node Structure */
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoMpst0[] =
+{
+    {ACPI_DMT_UINT8,    ACPI_MPST0_OFFSET (Flags),                  "Flags (decoded below)", DT_FLAG},
+    {ACPI_DMT_FLAG0,    ACPI_MPST0_FLAG_OFFSET (Flags,0),           "Node Enabled", 0},
+    {ACPI_DMT_FLAG1,    ACPI_MPST0_FLAG_OFFSET (Flags,0),           "Power Managed", 0},
+    {ACPI_DMT_FLAG2,    ACPI_MPST0_FLAG_OFFSET (Flags,0),           "Hot Plug Capable", 0},
+
+    {ACPI_DMT_UINT8,    ACPI_MPST0_OFFSET (Reserved1),              "Reserved", 0},
+    {ACPI_DMT_UINT16,   ACPI_MPST0_OFFSET (NodeId),                 "Node ID", 0},
+    {ACPI_DMT_UINT32,   ACPI_MPST0_OFFSET (Length),                 "Length", 0},
+    {ACPI_DMT_UINT64,   ACPI_MPST0_OFFSET (RangeAddress),           "Range Address", 0},
+    {ACPI_DMT_UINT64,   ACPI_MPST0_OFFSET (RangeLength),            "Range Length", 0},
+    {ACPI_DMT_UINT32,   ACPI_MPST0_OFFSET (NumPowerStates),         "Num Power States", 0},
+    {ACPI_DMT_UINT32,   ACPI_MPST0_OFFSET (NumPhysicalComponents),  "Num Physical Components", 0},
+    ACPI_DMT_TERMINATOR
+};
+
+/* 0A: Sub-subtable - Memory Power State Structure (follows Memory Power Node above) */
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoMpst0A[] =
+{
+    {ACPI_DMT_UINT8,    ACPI_MPST0A_OFFSET (PowerState),            "Power State", 0},
+    {ACPI_DMT_UINT8,    ACPI_MPST0A_OFFSET (InfoIndex),             "InfoIndex", 0},
+    ACPI_DMT_TERMINATOR
+};
+
+/* 0B: Sub-subtable - Physical Component ID Structure (follows Memory Power State(s) above) */
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoMpst0B[] =
+{
+    {ACPI_DMT_UINT16,   ACPI_MPST0B_OFFSET (ComponentId),           "Component Id", 0},
+    ACPI_DMT_TERMINATOR
+};
+
+/* 01: Power Characteristics Count (follows all Power Node(s) above) */
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoMpst1[] =
+{
+    {ACPI_DMT_UINT16,   ACPI_MPST1_OFFSET (CharacteristicsCount),   "Characteristics Count", 0},
+    {ACPI_DMT_UINT16,   ACPI_MPST1_OFFSET (Reserved),               "Reserved", 0},
+    ACPI_DMT_TERMINATOR
+};
+
+/* 02: Memory Power State Characteristics Structure */
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoMpst2[] =
+{
+    {ACPI_DMT_UINT8,    ACPI_MPST2_OFFSET (StructureId),            "Structure ID", 0},
+    {ACPI_DMT_UINT8,    ACPI_MPST2_OFFSET (Flags),                  "Flags (decoded below)", DT_FLAG},
+    {ACPI_DMT_FLAG0,    ACPI_MPST2_FLAG_OFFSET (Flags,0),           "Memory Preserved", 0},
+    {ACPI_DMT_FLAG1,    ACPI_MPST2_FLAG_OFFSET (Flags,0),           "Auto Entry", 0},
+    {ACPI_DMT_FLAG2,    ACPI_MPST2_FLAG_OFFSET (Flags,0),           "Auto Exit", 0},
+
+    {ACPI_DMT_UINT16,   ACPI_MPST2_OFFSET (Reserved1),              "Reserved", 0},
+    {ACPI_DMT_UINT32,   ACPI_MPST2_OFFSET (AveragePower),           "Average Power", 0},
+    {ACPI_DMT_UINT32,   ACPI_MPST2_OFFSET (PowerSaving),            "Power Saving", 0},
+    {ACPI_DMT_UINT64,   ACPI_MPST2_OFFSET (ExitLatency),            "Exit Latency", 0},
+    {ACPI_DMT_UINT64,   ACPI_MPST2_OFFSET (Reserved2),              "Reserved", 0},
+    ACPI_DMT_TERMINATOR
+};
+
+
+/*******************************************************************************
+ *
+ * MSCT - Maximum System Characteristics Table (ACPI 4.0)
+ *
+ ******************************************************************************/
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoMsct[] =
+{
+    {ACPI_DMT_UINT32,   ACPI_MSCT_OFFSET (ProximityOffset),         "Proximity Offset", 0},
+    {ACPI_DMT_UINT32,   ACPI_MSCT_OFFSET (MaxProximityDomains),     "Max Proximity Domains", 0},
+    {ACPI_DMT_UINT32,   ACPI_MSCT_OFFSET (MaxClockDomains),         "Max Clock Domains", 0},
+    {ACPI_DMT_UINT64,   ACPI_MSCT_OFFSET (MaxAddress),              "Max Physical Address", 0},
+    ACPI_DMT_TERMINATOR
+};
+
+/* Subtable - Maximum Proximity Domain Information. Version 1 */
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoMsct0[] =
+{
+    {ACPI_DMT_UINT8,    ACPI_MSCT0_OFFSET (Revision),               "Revision", 0},
+    {ACPI_DMT_UINT8,    ACPI_MSCT0_OFFSET (Length),                 "Length", DT_LENGTH},
+    {ACPI_DMT_UINT32,   ACPI_MSCT0_OFFSET (RangeStart),             "Domain Range Start", 0},
+    {ACPI_DMT_UINT32,   ACPI_MSCT0_OFFSET (RangeEnd),               "Domain Range End", 0},
+    {ACPI_DMT_UINT32,   ACPI_MSCT0_OFFSET (ProcessorCapacity),      "Processor Capacity", 0},
+    {ACPI_DMT_UINT64,   ACPI_MSCT0_OFFSET (MemoryCapacity),         "Memory Capacity", 0},
+    ACPI_DMT_TERMINATOR
+};
+
+
+/*******************************************************************************
+ *
+ * MTMR - MID Timer Table
+ *
+ ******************************************************************************/
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoMtmr[] =
+{
+    ACPI_DMT_TERMINATOR
+};
+
+/* MTMR Subtables - MTMR Entry */
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoMtmr0[] =
+{
+    {ACPI_DMT_GAS,      ACPI_MTMR0_OFFSET (PhysicalAddress),        "PhysicalAddress", 0},
+    {ACPI_DMT_UINT32,   ACPI_MTMR0_OFFSET (Frequency),              "Frequency", 0},
+    {ACPI_DMT_UINT32,   ACPI_MTMR0_OFFSET (Irq),                    "IRQ", 0},
+    ACPI_DMT_TERMINATOR
+};
+
+
+/*******************************************************************************
+ *
+ * NFIT - NVDIMM Firmware Interface Table and Subtables - (ACPI 6.0)
+ *
+ ******************************************************************************/
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoNfit[] =
+{
+    {ACPI_DMT_UINT32,   ACPI_NFIT_OFFSET (Reserved),                "Reserved", 0},
+    ACPI_DMT_TERMINATOR
+};
+
+/* Common Subtable header */
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoNfitHdr[] =
+{
+    {ACPI_DMT_NFIT,     ACPI_NFITH_OFFSET (Type),                   "Subtable Type", 0},
+    {ACPI_DMT_UINT16,   ACPI_NFITH_OFFSET (Length),                 "Length", DT_LENGTH},
+    ACPI_DMT_TERMINATOR
+};
+
+/* 0: System Physical Address Range Structure */
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoNfit0[] =
+{
+    {ACPI_DMT_UINT16,   ACPI_NFIT0_OFFSET (RangeIndex),             "Range Index", 0},
+    {ACPI_DMT_UINT16,   ACPI_NFIT0_OFFSET (Flags),                  "Flags (decoded below)", DT_FLAG},
+    {ACPI_DMT_FLAG0,    ACPI_NFIT0_FLAG_OFFSET (Flags,0),           "Add/Online Operation Only", 0},
+    {ACPI_DMT_FLAG1,    ACPI_NFIT0_FLAG_OFFSET (Flags,0),           "Proximity Domain Valid", 0},
+    {ACPI_DMT_UINT32,   ACPI_NFIT0_OFFSET (Reserved),               "Reserved", 0},
+    {ACPI_DMT_UINT32,   ACPI_NFIT0_OFFSET (ProximityDomain),        "Proximity Domain", 0},
+    {ACPI_DMT_UUID,     ACPI_NFIT0_OFFSET (RangeGuid[0]),           "Address Range GUID", 0},
+    {ACPI_DMT_UINT64,   ACPI_NFIT0_OFFSET (Address),                "Address Range Base", 0},
+    {ACPI_DMT_UINT64,   ACPI_NFIT0_OFFSET (Length),                 "Address Range Length", 0},
+    {ACPI_DMT_UINT64,   ACPI_NFIT0_OFFSET (MemoryMapping),          "Memory Map Attribute", 0},
+    ACPI_DMT_TERMINATOR
+};
+
+/* 1: Memory Device to System Address Range Map Structure */
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoNfit1[] =
+{
+    {ACPI_DMT_UINT32,   ACPI_NFIT1_OFFSET (DeviceHandle),           "Device Handle", 0},
+    {ACPI_DMT_UINT16,   ACPI_NFIT1_OFFSET (PhysicalId),             "Physical Id", 0},
+    {ACPI_DMT_UINT16,   ACPI_NFIT1_OFFSET (RegionId),               "Region Id", 0},
+    {ACPI_DMT_UINT16,   ACPI_NFIT1_OFFSET (RangeIndex),             "Range Index", 0},
+    {ACPI_DMT_UINT16,   ACPI_NFIT1_OFFSET (RegionIndex),            "Control Region Index", 0},
+    {ACPI_DMT_UINT64,   ACPI_NFIT1_OFFSET (RegionSize),             "Region Size", 0},
+    {ACPI_DMT_UINT64,   ACPI_NFIT1_OFFSET (RegionOffset),           "Region Offset", 0},
+    {ACPI_DMT_UINT64,   ACPI_NFIT1_OFFSET (Address),                "Address Region Base", 0},
+    {ACPI_DMT_UINT16,   ACPI_NFIT1_OFFSET (InterleaveIndex),        "Interleave Index", 0},
+    {ACPI_DMT_UINT16,   ACPI_NFIT1_OFFSET (InterleaveWays),         "Interleave Ways", 0},
+    {ACPI_DMT_UINT16,   ACPI_NFIT1_OFFSET (Flags),                  "Flags", DT_FLAG},
+    {ACPI_DMT_FLAG0,    ACPI_NFIT1_FLAG_OFFSET (Flags,0),           "Save to device failed", 0},
+    {ACPI_DMT_FLAG1,    ACPI_NFIT1_FLAG_OFFSET (Flags,0),           "Restore from device failed", 0},
+    {ACPI_DMT_FLAG2,    ACPI_NFIT1_FLAG_OFFSET (Flags,0),           "Platform flush failed", 0},
+    {ACPI_DMT_FLAG3,    ACPI_NFIT1_FLAG_OFFSET (Flags,0),           "Device not armed", 0},
+    {ACPI_DMT_FLAG4,    ACPI_NFIT1_FLAG_OFFSET (Flags,0),           "Health events observed", 0},
+    {ACPI_DMT_FLAG5,    ACPI_NFIT1_FLAG_OFFSET (Flags,0),           "Health events enabled", 0},
+    {ACPI_DMT_FLAG6,    ACPI_NFIT1_FLAG_OFFSET (Flags,0),           "Mapping failed", 0},
+    {ACPI_DMT_UINT16,   ACPI_NFIT1_OFFSET (Reserved),               "Reserved", 0},
+    ACPI_DMT_TERMINATOR
+};
+
+/* 2: Interleave Structure */
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoNfit2[] =
+{
+    {ACPI_DMT_UINT16,   ACPI_NFIT2_OFFSET (InterleaveIndex),        "Interleave Index", 0},
+    {ACPI_DMT_UINT16,   ACPI_NFIT2_OFFSET (Reserved),               "Reserved", 0},
+    {ACPI_DMT_UINT32,   ACPI_NFIT2_OFFSET (LineCount),              "Line Count", 0},
+    {ACPI_DMT_UINT32,   ACPI_NFIT2_OFFSET (LineSize),               "Line Size", 0},
+    ACPI_DMT_TERMINATOR
+};
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoNfit2a[] =
+{
+    {ACPI_DMT_UINT32,   0,                                          "Line Offset", DT_OPTIONAL},
+    ACPI_DMT_TERMINATOR
+};
+
+/* 3: SMBIOS Management Information Structure */
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoNfit3[] =
+{
+    {ACPI_DMT_UINT32,   ACPI_NFIT3_OFFSET (Reserved),               "Reserved", 0},
+    ACPI_DMT_TERMINATOR
+};
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoNfit3a[] =
+{
+    {ACPI_DMT_RAW_BUFFER, 0,                                        "SMBIOS Table Entries", DT_OPTIONAL},
+    ACPI_DMT_TERMINATOR
+};
+
+/* 4: NVDIMM Control Region Structure */
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoNfit4[] =
+{
+    {ACPI_DMT_UINT16,   ACPI_NFIT4_OFFSET (RegionIndex),            "Region Index", 0},
+    {ACPI_DMT_UINT16,   ACPI_NFIT4_OFFSET (VendorId),               "Vendor Id", 0},
+    {ACPI_DMT_UINT16,   ACPI_NFIT4_OFFSET (DeviceId),               "Device Id", 0},
+    {ACPI_DMT_UINT16,   ACPI_NFIT4_OFFSET (RevisionId),             "Revision Id", 0},
+    {ACPI_DMT_UINT16,   ACPI_NFIT4_OFFSET (SubsystemVendorId),      "Subsystem Vendor Id", 0},
+    {ACPI_DMT_UINT16,   ACPI_NFIT4_OFFSET (SubsystemDeviceId),      "Subsystem Device Id", 0},
+    {ACPI_DMT_UINT16,   ACPI_NFIT4_OFFSET (SubsystemRevisionId),    "Subsystem Revision Id", 0},
+    {ACPI_DMT_UINT8,    ACPI_NFIT4_OFFSET (ValidFields),            "Valid Fields", 0},
+    {ACPI_DMT_UINT8,    ACPI_NFIT4_OFFSET (ManufacturingLocation),  "Manufacturing Location", 0},
+    {ACPI_DMT_UINT16,   ACPI_NFIT4_OFFSET (ManufacturingDate),      "Manufacturing Date", 0},
+    {ACPI_DMT_UINT16,   ACPI_NFIT4_OFFSET (Reserved[0]),            "Reserved", 0},
+    {ACPI_DMT_UINT32,   ACPI_NFIT4_OFFSET (SerialNumber),           "Serial Number", 0},
+    {ACPI_DMT_UINT16,   ACPI_NFIT4_OFFSET (Code),                   "Code", 0},
+    {ACPI_DMT_UINT16,   ACPI_NFIT4_OFFSET (Windows),                "Window Count", 0},
+    {ACPI_DMT_UINT64,   ACPI_NFIT4_OFFSET (WindowSize),             "Window Size", 0},
+    {ACPI_DMT_UINT64,   ACPI_NFIT4_OFFSET (CommandOffset),          "Command Offset", 0},
+    {ACPI_DMT_UINT64,   ACPI_NFIT4_OFFSET (CommandSize),            "Command Size", 0},
+    {ACPI_DMT_UINT64,   ACPI_NFIT4_OFFSET (StatusOffset),           "Status Offset", 0},
+    {ACPI_DMT_UINT64,   ACPI_NFIT4_OFFSET (StatusSize),             "Status Size", 0},
+    {ACPI_DMT_UINT16,   ACPI_NFIT4_OFFSET (Flags),                  "Flags", DT_FLAG},
+    {ACPI_DMT_FLAG0,    ACPI_NFIT4_FLAG_OFFSET (Flags,0),           "Windows buffered", 0},
+    {ACPI_DMT_UINT48,   ACPI_NFIT4_OFFSET (Reserved1[0]),           "Reserved1", 0},
+    ACPI_DMT_TERMINATOR
+};
+
+/* 5: NVDIMM Block Data Window Region Structure */
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoNfit5[] =
+{
+    {ACPI_DMT_UINT16,   ACPI_NFIT5_OFFSET (RegionIndex),            "Region Index", 0},
+    {ACPI_DMT_UINT16,   ACPI_NFIT5_OFFSET (Windows),                "Window Count", 0},
+    {ACPI_DMT_UINT64,   ACPI_NFIT5_OFFSET (Offset),                 "Offset", 0},
+    {ACPI_DMT_UINT64,   ACPI_NFIT5_OFFSET (Size),                   "Size", 0},
+    {ACPI_DMT_UINT64,   ACPI_NFIT5_OFFSET (Capacity),               "Capacity", 0},
+    {ACPI_DMT_UINT64,   ACPI_NFIT5_OFFSET (StartAddress),           "Start Address", 0},
+    ACPI_DMT_TERMINATOR
+};
+
+/* 6: Flush Hint Address Structure */
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoNfit6[] =
+{
+    {ACPI_DMT_UINT32,   ACPI_NFIT6_OFFSET (DeviceHandle),           "Device Handle", 0},
+    {ACPI_DMT_UINT16,   ACPI_NFIT6_OFFSET (HintCount),              "Hint Count", 0},
+    {ACPI_DMT_UINT48,   ACPI_NFIT6_OFFSET (Reserved[0]),            "Reserved", 0},
+    ACPI_DMT_TERMINATOR
+};
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoNfit6a[] =
+{
+    {ACPI_DMT_UINT64,   0,                                          "Hint Address", DT_OPTIONAL},
+    ACPI_DMT_TERMINATOR
+};
+
+
+/*******************************************************************************
+ *
+ * PCCT - Platform Communications Channel Table (ACPI 5.0)
+ *
+ ******************************************************************************/
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoPcct[] =
+{
+    {ACPI_DMT_UINT32,   ACPI_PCCT_OFFSET (Flags),                   "Flags (decoded below)", DT_FLAG},
+    {ACPI_DMT_FLAG0,    ACPI_PCCT_FLAG_OFFSET (Flags,0),            "Doorbell", 0},
+    {ACPI_DMT_UINT64,   ACPI_PCCT_OFFSET (Reserved),                "Reserved", 0},
+    ACPI_DMT_TERMINATOR
+};
+
+/* PCCT subtables */
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoPcctHdr[] =
+{
+    {ACPI_DMT_PCCT,     ACPI_PCCT0_OFFSET (Header.Type),            "Subtable Type", 0},
+    {ACPI_DMT_UINT8,    ACPI_PCCT0_OFFSET (Header.Length),          "Length", DT_LENGTH},
+    ACPI_DMT_TERMINATOR
+};
+
+/* 0: Generic Communications Subspace */
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoPcct0[] =
+{
+    {ACPI_DMT_UINT48,   ACPI_PCCT0_OFFSET (Reserved[0]),            "Reserved", 0},
+    {ACPI_DMT_UINT64,   ACPI_PCCT0_OFFSET (BaseAddress),            "Base Address", 0},
+    {ACPI_DMT_UINT64,   ACPI_PCCT0_OFFSET (Length),                 "Address Length", 0},
+    {ACPI_DMT_GAS,      ACPI_PCCT0_OFFSET (DoorbellRegister),       "Doorbell Register", 0},
+    {ACPI_DMT_UINT64,   ACPI_PCCT0_OFFSET (PreserveMask),           "Preserve Mask", 0},
+    {ACPI_DMT_UINT64,   ACPI_PCCT0_OFFSET (WriteMask),              "Write Mask", 0},
+    {ACPI_DMT_UINT32,   ACPI_PCCT0_OFFSET (Latency),                "Command Latency", 0},
+    {ACPI_DMT_UINT32,   ACPI_PCCT0_OFFSET (MaxAccessRate),          "Maximum Access Rate", 0},
+    {ACPI_DMT_UINT16,   ACPI_PCCT0_OFFSET (MinTurnaroundTime),      "Minimum Turnaround Time", 0},
+    ACPI_DMT_TERMINATOR
+};
+
+/* 1: HW-reduced Communications Subspace (ACPI 5.1) */
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoPcct1[] =
+{
+    {ACPI_DMT_UINT32,   ACPI_PCCT1_OFFSET (DoorbellInterrupt),      "Doorbell Interrupt", 0},
+    {ACPI_DMT_UINT8,    ACPI_PCCT1_OFFSET (Flags),                  "Flags (Decoded Below)", DT_FLAG},
+    {ACPI_DMT_FLAG0,    ACPI_PCCT1_FLAG_OFFSET (Flags,0),           "Polarity", 0},
+    {ACPI_DMT_FLAG1,    ACPI_PCCT1_FLAG_OFFSET (Flags,0),           "Mode", 0},
+    {ACPI_DMT_UINT8,    ACPI_PCCT1_OFFSET (Reserved),               "Reserved", 0},
+    {ACPI_DMT_UINT64,   ACPI_PCCT1_OFFSET (BaseAddress),            "Base Address", 0},
+    {ACPI_DMT_UINT64,   ACPI_PCCT1_OFFSET (Length),                 "Address Length", 0},
+    {ACPI_DMT_GAS,      ACPI_PCCT1_OFFSET (DoorbellRegister),       "Doorbell Register", 0},
+    {ACPI_DMT_UINT64,   ACPI_PCCT1_OFFSET (PreserveMask),           "Preserve Mask", 0},
+    {ACPI_DMT_UINT64,   ACPI_PCCT1_OFFSET (WriteMask),              "Write Mask", 0},
+    {ACPI_DMT_UINT32,   ACPI_PCCT1_OFFSET (Latency),                "Command Latency", 0},
+    {ACPI_DMT_UINT32,   ACPI_PCCT1_OFFSET (MaxAccessRate),          "Maximum Access Rate", 0},
+    {ACPI_DMT_UINT16,   ACPI_PCCT1_OFFSET (MinTurnaroundTime),      "Minimum Turnaround Time", 0},
+    ACPI_DMT_TERMINATOR
+};
+
+/* 2: HW-reduced Communications Subspace Type 2 (ACPI 6.1) */
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoPcct2[] =
+{
+    {ACPI_DMT_UINT32,   ACPI_PCCT2_OFFSET (DoorbellInterrupt),      "Doorbell Interrupt", 0},
+    {ACPI_DMT_UINT8,    ACPI_PCCT2_OFFSET (Flags),                  "Flags (Decoded Below)", DT_FLAG},
+    {ACPI_DMT_FLAG0,    ACPI_PCCT2_FLAG_OFFSET (Flags,0),           "Polarity", 0},
+    {ACPI_DMT_FLAG1,    ACPI_PCCT2_FLAG_OFFSET (Flags,0),           "Mode", 0},
+    {ACPI_DMT_UINT8,    ACPI_PCCT2_OFFSET (Reserved),               "Reserved", 0},
+    {ACPI_DMT_UINT64,   ACPI_PCCT2_OFFSET (BaseAddress),            "Base Address", 0},
+    {ACPI_DMT_UINT64,   ACPI_PCCT2_OFFSET (Length),                 "Address Length", 0},
+    {ACPI_DMT_GAS,      ACPI_PCCT2_OFFSET (DoorbellRegister),       "Doorbell Register", 0},
+    {ACPI_DMT_UINT64,   ACPI_PCCT2_OFFSET (PreserveMask),           "Preserve Mask", 0},
+    {ACPI_DMT_UINT64,   ACPI_PCCT2_OFFSET (WriteMask),              "Write Mask", 0},
+    {ACPI_DMT_UINT32,   ACPI_PCCT2_OFFSET (Latency),                "Command Latency", 0},
+    {ACPI_DMT_UINT32,   ACPI_PCCT2_OFFSET (MaxAccessRate),          "Maximum Access Rate", 0},
+    {ACPI_DMT_UINT16,   ACPI_PCCT2_OFFSET (MinTurnaroundTime),      "Minimum Turnaround Time", 0},
+    {ACPI_DMT_GAS,      ACPI_PCCT2_OFFSET (DoorbellAckRegister),    "Doorbell ACK Register", 0},
+    {ACPI_DMT_UINT64,   ACPI_PCCT2_OFFSET (AckPreserveMask),        "ACK Preserve Mask", 0},
+    {ACPI_DMT_UINT64,   ACPI_PCCT2_OFFSET (AckWriteMask),           "ACK Write Mask", 0},
+    ACPI_DMT_TERMINATOR
+};
+
+
+/*******************************************************************************
+ *
+ * PMTT - Platform Memory Topology Table
+ *
+ ******************************************************************************/
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoPmtt[] =
+{
+    {ACPI_DMT_UINT32,   ACPI_PMTT_OFFSET (Reserved),                "Reserved", 0},
+    ACPI_DMT_TERMINATOR
+};
+
+/* Common Subtable header (one per Subtable) */
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoPmttHdr[] =
+{
+    {ACPI_DMT_PMTT,     ACPI_PMTTH_OFFSET (Type),                   "Subtable Type", 0},
+    {ACPI_DMT_UINT8,    ACPI_PMTTH_OFFSET (Reserved1),              "Reserved", 0},
+    {ACPI_DMT_UINT16,   ACPI_PMTTH_OFFSET (Length),                 "Length", DT_LENGTH},
+    {ACPI_DMT_UINT16,   ACPI_PMTTH_OFFSET (Flags),                  "Flags (decoded below)", DT_FLAG},
+    {ACPI_DMT_FLAG0,    ACPI_PMTTH_FLAG_OFFSET (Flags,0),           "Top-level Device", 0},
+    {ACPI_DMT_FLAG1,    ACPI_PMTTH_FLAG_OFFSET (Flags,0),           "Physical Element", 0},
+    {ACPI_DMT_FLAGS2,   ACPI_PMTTH_FLAG_OFFSET (Flags,0),           "Memory Type", 0},
+    {ACPI_DMT_UINT16,   ACPI_PMTTH_OFFSET (Reserved2),              "Reserved", 0},
+    ACPI_DMT_TERMINATOR
+};
+
+/* PMTT Subtables */
+
+/* 0: Socket */
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoPmtt0[] =
+{
+    {ACPI_DMT_UINT16,   ACPI_PMTT0_OFFSET (SocketId),               "Socket ID", 0},
+    {ACPI_DMT_UINT16,   ACPI_PMTT0_OFFSET (Reserved),               "Reserved", 0},
+    ACPI_DMT_TERMINATOR
+};
+
+/* 1: Memory Controller */
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoPmtt1[] =
+{
+    {ACPI_DMT_UINT32,   ACPI_PMTT1_OFFSET (ReadLatency),            "Read Latency", 0},
+    {ACPI_DMT_UINT32,   ACPI_PMTT1_OFFSET (WriteLatency),           "Write Latency", 0},
+    {ACPI_DMT_UINT32,   ACPI_PMTT1_OFFSET (ReadBandwidth),          "Read Bandwidth", 0},
+    {ACPI_DMT_UINT32,   ACPI_PMTT1_OFFSET (WriteBandwidth),         "Write Bandwidth", 0},
+    {ACPI_DMT_UINT16,   ACPI_PMTT1_OFFSET (AccessWidth),            "Access Width", 0},
+    {ACPI_DMT_UINT16,   ACPI_PMTT1_OFFSET (Alignment),              "Alignment", 0},
+    {ACPI_DMT_UINT16,   ACPI_PMTT1_OFFSET (Reserved),               "Reserved", 0},
+    {ACPI_DMT_UINT16,   ACPI_PMTT1_OFFSET (DomainCount),            "Domain Count", 0},
+    ACPI_DMT_TERMINATOR
+};
+
+/* 1a: Proximity Domain */
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoPmtt1a[] =
+{
+    {ACPI_DMT_UINT32,   ACPI_PMTT1A_OFFSET (ProximityDomain),       "Proximity Domain", 0},
+    ACPI_DMT_TERMINATOR
+};
+
+/* 2: Physical Component */
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoPmtt2[] =
+{
+    {ACPI_DMT_UINT16,   ACPI_PMTT2_OFFSET (ComponentId),            "Component ID", 0},
+    {ACPI_DMT_UINT16,   ACPI_PMTT2_OFFSET (Reserved),               "Reserved", 0},
+    {ACPI_DMT_UINT32,   ACPI_PMTT2_OFFSET (MemorySize),             "Memory Size", 0},
+    {ACPI_DMT_UINT32,   ACPI_PMTT2_OFFSET (BiosHandle),             "Bios Handle", 0},
+    ACPI_DMT_TERMINATOR
+};
+
+
+/*******************************************************************************
+ *
+ * S3PT - S3 Performance Table
+ *
+ ******************************************************************************/
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoS3pt[] =
+{
+    {ACPI_DMT_SIG,     ACPI_S3PT_OFFSET (Signature[0]),             "Signature", 0},
+    {ACPI_DMT_UINT32,  ACPI_S3PT_OFFSET (Length),                   "Length", DT_LENGTH},
+    ACPI_DMT_TERMINATOR
+};
+
+/* S3PT subtable header */
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoS3ptHdr[] =
+{
+    {ACPI_DMT_UINT16,  ACPI_S3PTH_OFFSET (Type),                    "Type", 0},
+    {ACPI_DMT_UINT8,   ACPI_S3PTH_OFFSET (Length),                  "Length", DT_LENGTH},
+    {ACPI_DMT_UINT8,   ACPI_S3PTH_OFFSET (Revision),                "Revision", 0},
+    ACPI_DMT_TERMINATOR
+};
+
+/* 0: Basic S3 Resume Performance Record */
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoS3pt0[] =
+{
+    {ACPI_DMT_UINT32,  ACPI_S3PT0_OFFSET (ResumeCount),             "Resume Count", 0},
+    {ACPI_DMT_UINT64,  ACPI_S3PT0_OFFSET (FullResume),              "Full Resume", 0},
+    {ACPI_DMT_UINT64,  ACPI_S3PT0_OFFSET (AverageResume),           "Average Resume", 0},
+    ACPI_DMT_TERMINATOR
+};
+
+/* 1: Basic S3 Suspend Performance Record */
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoS3pt1[] =
+{
+    {ACPI_DMT_UINT64,  ACPI_S3PT1_OFFSET (SuspendStart),            "Suspend Start", 0},
+    {ACPI_DMT_UINT64,  ACPI_S3PT1_OFFSET (SuspendEnd),              "Suspend End", 0},
+    ACPI_DMT_TERMINATOR
+};
+
+
+/*******************************************************************************
+ *
+ * SBST - Smart Battery Specification Table
+ *
+ ******************************************************************************/
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoSbst[] =
+{
+    {ACPI_DMT_UINT32,   ACPI_SBST_OFFSET (WarningLevel),            "Warning Level", 0},
+    {ACPI_DMT_UINT32,   ACPI_SBST_OFFSET (LowLevel),                "Low Level", 0},
+    {ACPI_DMT_UINT32,   ACPI_SBST_OFFSET (CriticalLevel),           "Critical Level", 0},
+    ACPI_DMT_TERMINATOR
+};
+
+
+/*******************************************************************************
+ *
+ * SLIC - Software Licensing Description Table. This table contains the standard
+ * ACPI header followed by proprietary data structures
+ *
+ ******************************************************************************/
+
+/* Single subtable, a proprietary format, so treat it as a buffer */
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoSlic[] =
+{
+    {ACPI_DMT_RAW_BUFFER, 0,                                        "Software Licensing Structure", 0},
+    ACPI_DMT_TERMINATOR
+};
+
+
+/*******************************************************************************
+ *
+ * SLIT - System Locality Information Table
+ *
+ ******************************************************************************/
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoSlit[] =
+{
+    {ACPI_DMT_UINT64,   ACPI_SLIT_OFFSET (LocalityCount),           "Localities", 0},
+    ACPI_DMT_TERMINATOR
+};
+
+
+/*******************************************************************************
+ *
+ * SPCR - Serial Port Console Redirection table
+ *
+ ******************************************************************************/
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoSpcr[] =
+{
+    {ACPI_DMT_UINT8,    ACPI_SPCR_OFFSET (InterfaceType),           "Interface Type", 0},
+    {ACPI_DMT_UINT24,   ACPI_SPCR_OFFSET (Reserved[0]),             "Reserved", 0},
+    {ACPI_DMT_GAS,      ACPI_SPCR_OFFSET (SerialPort),              "Serial Port Register", 0},
+    {ACPI_DMT_UINT8,    ACPI_SPCR_OFFSET (InterruptType),           "Interrupt Type", 0},
+    {ACPI_DMT_UINT8,    ACPI_SPCR_OFFSET (PcInterrupt),             "PCAT-compatible IRQ", 0},
+    {ACPI_DMT_UINT32,   ACPI_SPCR_OFFSET (Interrupt),               "Interrupt", 0},
+    {ACPI_DMT_UINT8,    ACPI_SPCR_OFFSET (BaudRate),                "Baud Rate", 0},
+    {ACPI_DMT_UINT8,    ACPI_SPCR_OFFSET (Parity),                  "Parity", 0},
+    {ACPI_DMT_UINT8,    ACPI_SPCR_OFFSET (StopBits),                "Stop Bits", 0},
+    {ACPI_DMT_UINT8,    ACPI_SPCR_OFFSET (FlowControl),             "Flow Control", 0},
+    {ACPI_DMT_UINT8,    ACPI_SPCR_OFFSET (TerminalType),            "Terminal Type", 0},
+    {ACPI_DMT_UINT8,    ACPI_SPCR_OFFSET (Reserved2),               "Reserved", 0},
+    {ACPI_DMT_UINT16,   ACPI_SPCR_OFFSET (PciDeviceId),             "PCI Device ID", 0},
+    {ACPI_DMT_UINT16,   ACPI_SPCR_OFFSET (PciVendorId),             "PCI Vendor ID", 0},
+    {ACPI_DMT_UINT8,    ACPI_SPCR_OFFSET (PciBus),                  "PCI Bus", 0},
+    {ACPI_DMT_UINT8,    ACPI_SPCR_OFFSET (PciDevice),               "PCI Device", 0},
+    {ACPI_DMT_UINT8,    ACPI_SPCR_OFFSET (PciFunction),             "PCI Function", 0},
+    {ACPI_DMT_UINT32,   ACPI_SPCR_OFFSET (PciFlags),                "PCI Flags", 0},
+    {ACPI_DMT_UINT8,    ACPI_SPCR_OFFSET (PciSegment),              "PCI Segment", 0},
+    {ACPI_DMT_UINT32,   ACPI_SPCR_OFFSET (Reserved2),               "Reserved", 0},
+    ACPI_DMT_TERMINATOR
+};
+
+
+/*******************************************************************************
+ *
+ * SPMI - Server Platform Management Interface table
+ *
+ ******************************************************************************/
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoSpmi[] =
+{
+    {ACPI_DMT_UINT8,    ACPI_SPMI_OFFSET (InterfaceType),           "Interface Type", 0},
+    {ACPI_DMT_UINT8,    ACPI_SPMI_OFFSET (Reserved),                "Reserved", DT_NON_ZERO}, /* Value must be 1 */
+    {ACPI_DMT_UINT16,   ACPI_SPMI_OFFSET (SpecRevision),            "IPMI Spec Version", 0},
+    {ACPI_DMT_UINT8,    ACPI_SPMI_OFFSET (InterruptType),           "Interrupt Type", 0},
+    {ACPI_DMT_UINT8,    ACPI_SPMI_OFFSET (GpeNumber),               "GPE Number", 0},
+    {ACPI_DMT_UINT8,    ACPI_SPMI_OFFSET (Reserved1),               "Reserved", 0},
+    {ACPI_DMT_UINT8,    ACPI_SPMI_OFFSET (PciDeviceFlag),           "PCI Device Flag", 0},
+    {ACPI_DMT_UINT32,   ACPI_SPMI_OFFSET (Interrupt),               "Interrupt", 0},
+    {ACPI_DMT_GAS,      ACPI_SPMI_OFFSET (IpmiRegister),            "IPMI Register", 0},
+    {ACPI_DMT_UINT8,    ACPI_SPMI_OFFSET (PciSegment),              "PCI Segment", 0},
+    {ACPI_DMT_UINT8,    ACPI_SPMI_OFFSET (PciBus),                  "PCI Bus", 0},
+    {ACPI_DMT_UINT8,    ACPI_SPMI_OFFSET (PciDevice),               "PCI Device", 0},
+    {ACPI_DMT_UINT8,    ACPI_SPMI_OFFSET (PciFunction),             "PCI Function", 0},
+    {ACPI_DMT_UINT8,    ACPI_SPMI_OFFSET (Reserved2),               "Reserved", 0},
+    ACPI_DMT_TERMINATOR
+};
+
+
+/*******************************************************************************
+ *
+ * SRAT - System Resource Affinity Table and Subtables
+ *
+ ******************************************************************************/
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoSrat[] =
+{
+    {ACPI_DMT_UINT32,   ACPI_SRAT_OFFSET (TableRevision),           "Table Revision", 0},
+    {ACPI_DMT_UINT64,   ACPI_SRAT_OFFSET (Reserved),                "Reserved", 0},
+    ACPI_DMT_TERMINATOR
+};
+
+/* Common Subtable header (one per Subtable) */
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoSratHdr[] =
+{
+    {ACPI_DMT_SRAT,     ACPI_SRATH_OFFSET (Type),                   "Subtable Type", 0},
+    {ACPI_DMT_UINT8,    ACPI_SRATH_OFFSET (Length),                 "Length", DT_LENGTH},
+    ACPI_DMT_TERMINATOR
+};
+
+/* SRAT Subtables */
+
+/* 0: Processor Local APIC/SAPIC Affinity */
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoSrat0[] =
+{
+    {ACPI_DMT_UINT8,    ACPI_SRAT0_OFFSET (ProximityDomainLo),      "Proximity Domain Low(8)", 0},
+    {ACPI_DMT_UINT8,    ACPI_SRAT0_OFFSET (ApicId),                 "Apic ID", 0},
+    {ACPI_DMT_UINT32,   ACPI_SRAT0_OFFSET (Flags),                  "Flags (decoded below)", DT_FLAG},
+    {ACPI_DMT_FLAG0,    ACPI_SRAT0_FLAG_OFFSET (Flags,0),           "Enabled", 0},
+    {ACPI_DMT_UINT8,    ACPI_SRAT0_OFFSET (LocalSapicEid),          "Local Sapic EID", 0},
+    {ACPI_DMT_UINT24,   ACPI_SRAT0_OFFSET (ProximityDomainHi[0]),   "Proximity Domain High(24)", 0},
+    {ACPI_DMT_UINT32,   ACPI_SRAT0_OFFSET (ClockDomain),            "Clock Domain", 0},
+    ACPI_DMT_TERMINATOR
+};
+
+/* 1: Memory Affinity */
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoSrat1[] =
+{
+    {ACPI_DMT_UINT32,   ACPI_SRAT1_OFFSET (ProximityDomain),        "Proximity Domain", 0},
+    {ACPI_DMT_UINT16,   ACPI_SRAT1_OFFSET (Reserved),               "Reserved1", 0},
+    {ACPI_DMT_UINT64,   ACPI_SRAT1_OFFSET (BaseAddress),            "Base Address", 0},
+    {ACPI_DMT_UINT64,   ACPI_SRAT1_OFFSET (Length),                 "Address Length", 0},
+    {ACPI_DMT_UINT32,   ACPI_SRAT1_OFFSET (Reserved1),              "Reserved2", 0},
+    {ACPI_DMT_UINT32,   ACPI_SRAT1_OFFSET (Flags),                  "Flags (decoded below)", DT_FLAG},
+    {ACPI_DMT_FLAG0,    ACPI_SRAT1_FLAG_OFFSET (Flags,0),           "Enabled", 0},
+    {ACPI_DMT_FLAG1,    ACPI_SRAT1_FLAG_OFFSET (Flags,0),           "Hot Pluggable", 0},
+    {ACPI_DMT_FLAG2,    ACPI_SRAT1_FLAG_OFFSET (Flags,0),           "Non-Volatile", 0},
+    {ACPI_DMT_UINT64,   ACPI_SRAT1_OFFSET (Reserved2),              "Reserved3", 0},
+    ACPI_DMT_TERMINATOR
+};
+
+/* 2: Processor Local X2_APIC Affinity (ACPI 4.0) */
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoSrat2[] =
+{
+    {ACPI_DMT_UINT16,   ACPI_SRAT2_OFFSET (Reserved),               "Reserved1", 0},
+    {ACPI_DMT_UINT32,   ACPI_SRAT2_OFFSET (ProximityDomain),        "Proximity Domain", 0},
+    {ACPI_DMT_UINT32,   ACPI_SRAT2_OFFSET (ApicId),                 "Apic ID", 0},
+    {ACPI_DMT_UINT32,   ACPI_SRAT2_OFFSET (Flags),                  "Flags (decoded below)", DT_FLAG},
+    {ACPI_DMT_FLAG0,    ACPI_SRAT2_FLAG_OFFSET (Flags,0),           "Enabled", 0},
+    {ACPI_DMT_UINT32,   ACPI_SRAT2_OFFSET (ClockDomain),            "Clock Domain", 0},
+    {ACPI_DMT_UINT32,   ACPI_SRAT2_OFFSET (Reserved2),              "Reserved2", 0},
+    ACPI_DMT_TERMINATOR
+};
+
+/* : GICC Affinity (ACPI 5.1) */
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoSrat3[] =
+{
+    {ACPI_DMT_UINT32,   ACPI_SRAT3_OFFSET (ProximityDomain),        "Proximity Domain", 0},
+    {ACPI_DMT_UINT32,   ACPI_SRAT3_OFFSET (AcpiProcessorUid),       "Acpi Processor UID", 0},
+    {ACPI_DMT_UINT32,   ACPI_SRAT3_OFFSET (Flags),                  "Flags (decoded below)", DT_FLAG},
+    {ACPI_DMT_FLAG0,    ACPI_SRAT3_FLAG_OFFSET (Flags,0),           "Enabled", 0},
+    {ACPI_DMT_UINT32,   ACPI_SRAT3_OFFSET (ClockDomain),            "Clock Domain", 0},
+    ACPI_DMT_TERMINATOR
+};
+
+
+/*******************************************************************************
+ *
+ * STAO - Status Override Table (_STA override) - ACPI 6.0
+ *
+ ******************************************************************************/
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoStao[] =
+{
+    {ACPI_DMT_UINT8,    ACPI_STAO_OFFSET (IgnoreUart),              "Ignore UART", 0},
+    ACPI_DMT_TERMINATOR
+};
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoStaoStr[] =
+{
+    {ACPI_DMT_STRING,   0,                                          "Namepath", 0},
+    ACPI_DMT_TERMINATOR
+};
+
+
+/*******************************************************************************
+ *
+ * TCPA - Trusted Computing Platform Alliance table (Client)
+ *
+ * NOTE: There are two versions of the table with the same signature --
+ * the client version and the server version. The common PlatformClass
+ * field is used to differentiate the two types of tables.
+ *
+ ******************************************************************************/
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoTcpaHdr[] =
+{
+    {ACPI_DMT_UINT16,   ACPI_TCPA_OFFSET (PlatformClass),           "Platform Class", 0},
+    ACPI_DMT_TERMINATOR
+};
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoTcpaClient[] =
+{
+    {ACPI_DMT_UINT32,   ACPI_TCPA_CLIENT_OFFSET (MinimumLogLength), "Min Event Log Length", 0},
+    {ACPI_DMT_UINT64,   ACPI_TCPA_CLIENT_OFFSET (LogAddress),       "Event Log Address", 0},
+    ACPI_DMT_TERMINATOR
+};
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoTcpaServer[] =
+{
+    {ACPI_DMT_UINT16,   ACPI_TCPA_SERVER_OFFSET (Reserved),         "Reserved", 0},
+    {ACPI_DMT_UINT64,   ACPI_TCPA_SERVER_OFFSET (MinimumLogLength), "Min Event Log Length", 0},
+    {ACPI_DMT_UINT64,   ACPI_TCPA_SERVER_OFFSET (LogAddress),       "Event Log Address", 0},
+    {ACPI_DMT_UINT16,   ACPI_TCPA_SERVER_OFFSET (SpecRevision),     "Specification Revision", 0},
+    {ACPI_DMT_UINT8,    ACPI_TCPA_SERVER_OFFSET (DeviceFlags),      "Device Flags (decoded below)", DT_FLAG},
+    {ACPI_DMT_FLAG0,    ACPI_TCPA_SERVER_OFFSET (DeviceFlags),      "Pci Device", 0},
+    {ACPI_DMT_FLAG1,    ACPI_TCPA_SERVER_OFFSET (DeviceFlags),      "Bus is Pnp", 0},
+    {ACPI_DMT_FLAG2,    ACPI_TCPA_SERVER_OFFSET (DeviceFlags),      "Address Valid", 0},
+    {ACPI_DMT_UINT8,    ACPI_TCPA_SERVER_OFFSET (InterruptFlags),   "Interrupt Flags (decoded below)", DT_FLAG},
+    {ACPI_DMT_FLAG0,    ACPI_TCPA_SERVER_OFFSET (InterruptFlags),   "Mode", 0},
+    {ACPI_DMT_FLAG1,    ACPI_TCPA_SERVER_OFFSET (InterruptFlags),   "Polarity", 0},
+    {ACPI_DMT_FLAG2,    ACPI_TCPA_SERVER_OFFSET (InterruptFlags),   "GPE SCI Triggered", 0},
+    {ACPI_DMT_FLAG3,    ACPI_TCPA_SERVER_OFFSET (InterruptFlags),   "Global System Interrupt", 0},
+    {ACPI_DMT_UINT8,    ACPI_TCPA_SERVER_OFFSET (GpeNumber),        "Gpe Number", 0},
+    {ACPI_DMT_UINT24,   ACPI_TCPA_SERVER_OFFSET (Reserved2[0]),     "Reserved", 0},
+    {ACPI_DMT_UINT32,   ACPI_TCPA_SERVER_OFFSET (GlobalInterrupt),  "Global Interrupt", 0},
+    {ACPI_DMT_GAS,      ACPI_TCPA_SERVER_OFFSET (Address),          "Address", 0},
+    {ACPI_DMT_UINT32,   ACPI_TCPA_SERVER_OFFSET (Reserved3),        "Reserved", 0},
+    {ACPI_DMT_GAS,      ACPI_TCPA_SERVER_OFFSET (ConfigAddress),    "Configuration Address", 0},
+    {ACPI_DMT_UINT8,    ACPI_TCPA_SERVER_OFFSET (Group),            "Pci Group", 0},
+    {ACPI_DMT_UINT8,    ACPI_TCPA_SERVER_OFFSET (Bus),              "Pci Bus", 0},
+    {ACPI_DMT_UINT8,    ACPI_TCPA_SERVER_OFFSET (Device),           "Pci Device", 0},
+    {ACPI_DMT_UINT8,    ACPI_TCPA_SERVER_OFFSET (Function),         "Pci Function", 0},
+    ACPI_DMT_TERMINATOR
+};
+
+
+/*******************************************************************************
+ *
+ * TPM2 - Trusted Platform Module (TPM) 2.0 Hardware Interface Table
+ *
+ ******************************************************************************/
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoTpm2[] =
+{
+    {ACPI_DMT_UINT16,   ACPI_TPM2_OFFSET (PlatformClass),           "Platform Class", 0},
+    {ACPI_DMT_UINT16,   ACPI_TPM2_OFFSET (Reserved),                "Reserved", 0},
+    {ACPI_DMT_UINT64,   ACPI_TPM2_OFFSET (ControlAddress),          "Control Address", 0},
+    {ACPI_DMT_UINT32,   ACPI_TPM2_OFFSET (StartMethod),             "Start Method", 0},
+    ACPI_DMT_TERMINATOR
+};
+
+
+/*******************************************************************************
+ *
+ * UEFI - UEFI Boot optimization Table
+ *
+ ******************************************************************************/
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoUefi[] =
+{
+    {ACPI_DMT_UUID,     ACPI_UEFI_OFFSET (Identifier[0]),           "UUID Identifier", 0},
+    {ACPI_DMT_UINT16,   ACPI_UEFI_OFFSET (DataOffset),              "Data Offset", 0},
+    ACPI_DMT_TERMINATOR
+};
+
+
+/*******************************************************************************
+ *
+ * VRTC - Virtual Real Time Clock Table
+ *
+ ******************************************************************************/
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoVrtc[] =
+{
+    ACPI_DMT_TERMINATOR
+};
+
+/* VRTC Subtables - VRTC Entry */
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoVrtc0[] =
+{
+    {ACPI_DMT_GAS,      ACPI_VRTC0_OFFSET (PhysicalAddress),        "PhysicalAddress", 0},
+    {ACPI_DMT_UINT32,   ACPI_VRTC0_OFFSET (Irq),                    "IRQ", 0},
+    ACPI_DMT_TERMINATOR
+};
+
+
+/*******************************************************************************
+ *
+ * WAET - Windows ACPI Emulated devices Table
+ *
+ ******************************************************************************/
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoWaet[] =
+{
+    {ACPI_DMT_UINT32,   ACPI_WAET_OFFSET (Flags),                   "Flags (decoded below)", DT_FLAG},
+    {ACPI_DMT_FLAG0,    ACPI_WAET_OFFSET (Flags),                   "RTC needs no INT ack", 0},
+    {ACPI_DMT_FLAG1,    ACPI_WAET_OFFSET (Flags),                   "PM timer, one read only", 0},
+    ACPI_DMT_TERMINATOR
+};
+
+
+/*******************************************************************************
+ *
+ * WDAT - Watchdog Action Table
+ *
+ ******************************************************************************/
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoWdat[] =
+{
+    {ACPI_DMT_UINT32,   ACPI_WDAT_OFFSET (HeaderLength),            "Header Length", DT_LENGTH},
+    {ACPI_DMT_UINT16,   ACPI_WDAT_OFFSET (PciSegment),              "PCI Segment", 0},
+    {ACPI_DMT_UINT8,    ACPI_WDAT_OFFSET (PciBus),                  "PCI Bus", 0},
+    {ACPI_DMT_UINT8,    ACPI_WDAT_OFFSET (PciDevice),               "PCI Device", 0},
+    {ACPI_DMT_UINT8,    ACPI_WDAT_OFFSET (PciFunction),             "PCI Function", 0},
+    {ACPI_DMT_UINT24,   ACPI_WDAT_OFFSET (Reserved[0]),             "Reserved", 0},
+    {ACPI_DMT_UINT32,   ACPI_WDAT_OFFSET (TimerPeriod),             "Timer Period", 0},
+    {ACPI_DMT_UINT32,   ACPI_WDAT_OFFSET (MaxCount),                "Max Count", 0},
+    {ACPI_DMT_UINT32,   ACPI_WDAT_OFFSET (MinCount),                "Min Count", 0},
+    {ACPI_DMT_UINT8,    ACPI_WDAT_OFFSET (Flags),                   "Flags (decoded below)", DT_FLAG},
+    {ACPI_DMT_FLAG0,    ACPI_WDAT_OFFSET (Flags),                   "Enabled", 0},
+    {ACPI_DMT_FLAG7,    ACPI_WDAT_OFFSET (Flags),                   "Stopped When Asleep", 0},
+    {ACPI_DMT_UINT24,   ACPI_WDAT_OFFSET (Reserved2[0]),            "Reserved", 0},
+    {ACPI_DMT_UINT32,   ACPI_WDAT_OFFSET (Entries),                 "Watchdog Entry Count", 0},
+    ACPI_DMT_TERMINATOR
+};
+
+/* WDAT Subtables - Watchdog Instruction Entries */
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoWdat0[] =
+{
+    {ACPI_DMT_UINT8,    ACPI_WDAT0_OFFSET (Action),                 "Watchdog Action", 0},
+    {ACPI_DMT_UINT8,    ACPI_WDAT0_OFFSET (Instruction),            "Instruction", 0},
+    {ACPI_DMT_UINT16,   ACPI_WDAT0_OFFSET (Reserved),               "Reserved", 0},
+    {ACPI_DMT_GAS,      ACPI_WDAT0_OFFSET (RegisterRegion),         "Register Region", 0},
+    {ACPI_DMT_UINT32,   ACPI_WDAT0_OFFSET (Value),                  "Value", 0},
+    {ACPI_DMT_UINT32,   ACPI_WDAT0_OFFSET (Mask),                   "Register Mask", 0},
+    ACPI_DMT_TERMINATOR
+};
+
+
+/*******************************************************************************
+ *
+ * WDDT - Watchdog Description Table
+ *
+ ******************************************************************************/
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoWddt[] =
+{
+    {ACPI_DMT_UINT16,   ACPI_WDDT_OFFSET (SpecVersion),             "Specification Version", 0},
+    {ACPI_DMT_UINT16,   ACPI_WDDT_OFFSET (TableVersion),            "Table Version", 0},
+    {ACPI_DMT_UINT16,   ACPI_WDDT_OFFSET (PciVendorId),             "PCI Vendor ID", 0},
+    {ACPI_DMT_GAS,      ACPI_WDDT_OFFSET (Address),                 "Timer Register", 0},
+    {ACPI_DMT_UINT16,   ACPI_WDDT_OFFSET (MaxCount),                "Max Count", 0},
+    {ACPI_DMT_UINT16,   ACPI_WDDT_OFFSET (MinCount),                "Min Count", 0},
+    {ACPI_DMT_UINT16,   ACPI_WDDT_OFFSET (Period),                  "Period", 0},
+    {ACPI_DMT_UINT16,   ACPI_WDDT_OFFSET (Status),                  "Status (decoded below)", 0},
+
+    /* Status Flags byte 0 */
+
+    {ACPI_DMT_FLAG0,    ACPI_WDDT_FLAG_OFFSET (Status,0),           "Available", 0},
+    {ACPI_DMT_FLAG1,    ACPI_WDDT_FLAG_OFFSET (Status,0),           "Active", 0},
+    {ACPI_DMT_FLAG2,    ACPI_WDDT_FLAG_OFFSET (Status,0),           "OS Owns", 0},
+
+    /* Status Flags byte 1 */
+
+    {ACPI_DMT_FLAG3,    ACPI_WDDT_FLAG_OFFSET (Status,1),           "User Reset", 0},
+    {ACPI_DMT_FLAG4,    ACPI_WDDT_FLAG_OFFSET (Status,1),           "Timeout Reset", 0},
+    {ACPI_DMT_FLAG5,    ACPI_WDDT_FLAG_OFFSET (Status,1),           "Power Fail Reset", 0},
+    {ACPI_DMT_FLAG6,    ACPI_WDDT_FLAG_OFFSET (Status,1),           "Unknown Reset", 0},
+
+    {ACPI_DMT_UINT16,   ACPI_WDDT_OFFSET (Capability),              "Capability (decoded below)", 0},
+
+    /* Capability Flags byte 0 */
+
+    {ACPI_DMT_FLAG0,    ACPI_WDDT_FLAG_OFFSET (Capability,0),       "Auto Reset", 0},
+    {ACPI_DMT_FLAG1,    ACPI_WDDT_FLAG_OFFSET (Capability,0),       "Timeout Alert", 0},
+    ACPI_DMT_TERMINATOR
+};
+
+
+/*******************************************************************************
+ *
+ * WDRT - Watchdog Resource Table
+ *
+ ******************************************************************************/
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoWdrt[] =
+{
+    {ACPI_DMT_GAS,      ACPI_WDRT_OFFSET (ControlRegister),         "Control Register", 0},
+    {ACPI_DMT_GAS,      ACPI_WDRT_OFFSET (CountRegister),           "Count Register", 0},
+    {ACPI_DMT_UINT16,   ACPI_WDRT_OFFSET (PciDeviceId),             "PCI Device ID", 0},
+    {ACPI_DMT_UINT16,   ACPI_WDRT_OFFSET (PciVendorId),             "PCI Vendor ID", 0},
+    {ACPI_DMT_UINT8,    ACPI_WDRT_OFFSET (PciBus),                  "PCI Bus", 0},
+    {ACPI_DMT_UINT8,    ACPI_WDRT_OFFSET (PciDevice),               "PCI Device", 0},
+    {ACPI_DMT_UINT8,    ACPI_WDRT_OFFSET (PciFunction),             "PCI Function", 0},
+    {ACPI_DMT_UINT8,    ACPI_WDRT_OFFSET (PciSegment),              "PCI Segment", 0},
+    {ACPI_DMT_UINT16,   ACPI_WDRT_OFFSET (MaxCount),                "Max Count", 0},
+    {ACPI_DMT_UINT8,    ACPI_WDRT_OFFSET (Units),                   "Counter Units", 0},
+    ACPI_DMT_TERMINATOR
+};
+
+
+/*******************************************************************************
+ *
+ * WPBT - Windows Platform Environment Table (ACPI 6.0)
+ *        Version 1
+ *
+ * Conforms to "Windows Platform Binary Table (WPBT)" 29 November 2011
+ *
+ ******************************************************************************/
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoWpbt[] =
+{
+    {ACPI_DMT_UINT32,      ACPI_WPBT_OFFSET (HandoffSize),          "Handoff Size", 0},
+    {ACPI_DMT_UINT64,      ACPI_WPBT_OFFSET (HandoffAddress),       "Handoff Address", 0},
+    {ACPI_DMT_UINT8,       ACPI_WPBT_OFFSET (Layout),               "Layout", 0},
+    {ACPI_DMT_UINT8,       ACPI_WPBT_OFFSET (Type),                 "Type", 0},
+    {ACPI_DMT_UINT16,      ACPI_WPBT_OFFSET (ArgumentsLength),      "Arguments Length", 0},
+    ACPI_DMT_TERMINATOR
+};
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoWpbt0[] =
+{
+    {ACPI_DMT_UNICODE,     sizeof (ACPI_TABLE_WPBT),                "Command-line Arguments", 0},
+    ACPI_DMT_TERMINATOR
+};
+
+
+/*******************************************************************************
+ *
+ * XENV -  Xen Environment table (ACPI 6.0)
+ *
+ ******************************************************************************/
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoXenv[] =
+{
+    {ACPI_DMT_UINT64,   ACPI_XENV_OFFSET (GrantTableAddress),       "Grant Table Address", 0},
+    {ACPI_DMT_UINT64,   ACPI_XENV_OFFSET (GrantTableSize),          "Grant Table Size", 0},
+    {ACPI_DMT_UINT32,   ACPI_XENV_OFFSET (EventInterrupt),          "Event Interrupt", 0},
+    {ACPI_DMT_UINT8,    ACPI_XENV_OFFSET (EventFlags),              "Event Flags", 0},
+    ACPI_DMT_TERMINATOR
+};
+
+
+/*! [Begin] no source code translation */
+
+/*
+ * Generic types (used in UEFI and custom tables)
+ *
+ * Examples:
+ *
+ *     Buffer : cc 04 ff bb
+ *      UINT8 : 11
+ *     UINT16 : 1122
+ *     UINT24 : 112233
+ *     UINT32 : 11223344
+ *     UINT56 : 11223344556677
+ *     UINT64 : 1122334455667788
+ *
+ *     String : "This is string"
+ *    Unicode : "This string encoded to Unicode"
+ *
+ *       GUID : 11223344-5566-7788-99aa-bbccddeeff00
+ * DevicePath : "\PciRoot(0)\Pci(0x1f,1)\Usb(0,0)"
+ */
+
+#define ACPI_DM_GENERIC_ENTRY(FieldType, FieldName) \
+    {{FieldType, 0, FieldName, 0}, ACPI_DMT_TERMINATOR}
+
+ACPI_DMTABLE_INFO           AcpiDmTableInfoGeneric[][2] =
+{
+    ACPI_DM_GENERIC_ENTRY (ACPI_DMT_UINT8,      "UINT8"),
+    ACPI_DM_GENERIC_ENTRY (ACPI_DMT_UINT16,     "UINT16"),
+    ACPI_DM_GENERIC_ENTRY (ACPI_DMT_UINT24,     "UINT24"),
+    ACPI_DM_GENERIC_ENTRY (ACPI_DMT_UINT32,     "UINT32"),
+    ACPI_DM_GENERIC_ENTRY (ACPI_DMT_UINT40,     "UINT40"),
+    ACPI_DM_GENERIC_ENTRY (ACPI_DMT_UINT48,     "UINT48"),
+    ACPI_DM_GENERIC_ENTRY (ACPI_DMT_UINT56,     "UINT56"),
+    ACPI_DM_GENERIC_ENTRY (ACPI_DMT_UINT64,     "UINT64"),
+    ACPI_DM_GENERIC_ENTRY (ACPI_DMT_STRING,     "String"),
+    ACPI_DM_GENERIC_ENTRY (ACPI_DMT_UNICODE,    "Unicode"),
+    ACPI_DM_GENERIC_ENTRY (ACPI_DMT_BUFFER,     "Buffer"),
+    ACPI_DM_GENERIC_ENTRY (ACPI_DMT_UUID,       "GUID"),
+    ACPI_DM_GENERIC_ENTRY (ACPI_DMT_STRING,     "DevicePath"),
+    ACPI_DM_GENERIC_ENTRY (ACPI_DMT_LABEL,      "Label"),
+    {ACPI_DMT_TERMINATOR}
+};
+/*! [End] no source code translation !*/
diff --git a/usr/src/cmd/acpi/common/osl.c b/usr/src/cmd/acpi/common/osl.c
index 599592b6de..f7e00ad757 100644
--- a/usr/src/cmd/acpi/common/osl.c
+++ b/usr/src/cmd/acpi/common/osl.c
@@ -10,55 +10,60 @@
  */
 
 /*
- * Copyright 2016 Joyent, Inc.
+ * Copyright (c) 2018, Joyent, Inc.
  */
 
-#include <stdio.h>
+#include <fcntl.h>
 #include <stdarg.h>
+#include <stdio.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <unistd.h>
+
 #include "acpi.h"
 #include "accommon.h"
 
-ACPI_STATUS
-AcpiOsInitialize(void)
+UINT32
+CmGetFileSize(ACPI_FILE File)
 {
-	return (AE_OK);
-}
+	int fd;
+	struct stat sb;
 
-/*
- * The locking functions are no-ops because the application tools that use
- * these are all single threaded. However, due to the common code base that we
- * pull in from Intel, these functions are also called when the software is
- * compiled into the kernel, where it does need to do locking.
- */
-ACPI_CPU_FLAGS
-AcpiOsAcquireLock(ACPI_HANDLE Handle)
-{
-	return (AE_OK);
+	fd = fileno(File);
+	if (fstat(fd, &sb) != 0)
+		return (ACPI_UINT32_MAX);
+	return ((UINT32)sb.st_size);
 }
 
-void
-AcpiOsReleaseLock(ACPI_HANDLE Handle, ACPI_CPU_FLAGS Flags)
+int
+AcpiOsWriteFile(ACPI_FILE File, void *Buffer, ACPI_SIZE Size, ACPI_SIZE Count)
 {
+	return (fwrite(Buffer, Size, Count, File));
 }
 
-void
-AcpiOsVprintf(const char *Format, va_list Args)
+ACPI_FILE
+AcpiOsOpenFile(const char *Path, UINT8 Modes)
 {
-	vprintf(Format, Args);
+	char mode[3];
+
+	bzero(mode, sizeof (mode));
+	if ((Modes & ACPI_FILE_READING) != 0)
+		(void) strlcat(mode, "r", sizeof (mode));
+
+	if ((Modes & ACPI_FILE_WRITING) != 0)
+		(void) strlcat(mode, "w", sizeof (mode));
+
+	return (fopen(Path, mode));
 }
 
-void ACPI_INTERNAL_VAR_XFACE
-AcpiOsPrintf(const char *Format, ...)
+void
+AcpiOsCloseFile(ACPI_FILE File)
 {
-	va_list ap;
-
-	va_start(ap, Format);
-	AcpiOsVprintf(Format, ap);
-	va_end(ap);
+	fclose(File);
 }
 
 int
-AcpiOsWriteFile(ACPI_FILE File, void *Buffer, ACPI_SIZE Size, ACPI_SIZE Count)
+AcpiOsReadFile(ACPI_FILE File, void *Buffer, ACPI_SIZE Size, ACPI_SIZE Count)
 {
-	return (fwrite(Buffer, Size, Count, File));
+	return (fread(Buffer, Size, Count, File));
 }
diff --git a/usr/src/cmd/acpi/common/osunixxf.c b/usr/src/cmd/acpi/common/osunixxf.c
new file mode 100644
index 0000000000..21ac91d847
--- /dev/null
+++ b/usr/src/cmd/acpi/common/osunixxf.c
@@ -0,0 +1,1540 @@
+/******************************************************************************
+ *
+ * Module Name: osunixxf - UNIX OSL interfaces
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2016, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+/*
+ * These interfaces are required in order to compile the ASL compiler and the
+ * various ACPICA tools under Linux or other Unix-like system.
+ */
+#include "acpi.h"
+#include "accommon.h"
+#include "amlcode.h"
+#include "acparser.h"
+#include "acdebug.h"
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdarg.h>
+#include <unistd.h>
+#include <sys/time.h>
+#include <semaphore.h>
+#include <pthread.h>
+#include <errno.h>
+
+#define _COMPONENT          ACPI_OS_SERVICES
+        ACPI_MODULE_NAME    ("osunixxf")
+
+
+BOOLEAN                        AcpiGbl_DebugTimeout = FALSE;
+
+
+/* Upcalls to AcpiExec */
+
+void
+AeTableOverride (
+    ACPI_TABLE_HEADER       *ExistingTable,
+    ACPI_TABLE_HEADER       **NewTable);
+
+typedef void* (*PTHREAD_CALLBACK) (void *);
+
+/* Buffer used by AcpiOsVprintf */
+
+#define ACPI_VPRINTF_BUFFER_SIZE    512
+#define _ASCII_NEWLINE              '\n'
+
+/* Terminal support for AcpiExec only */
+
+#ifdef ACPI_EXEC_APP
+#include <termios.h>
+
+struct termios              OriginalTermAttributes;
+int                         TermAttributesWereSet = 0;
+
+ACPI_STATUS
+AcpiUtReadLine (
+    char                    *Buffer,
+    UINT32                  BufferLength,
+    UINT32                  *BytesRead);
+
+static void
+OsEnterLineEditMode (
+    void);
+
+static void
+OsExitLineEditMode (
+    void);
+
+
+/******************************************************************************
+ *
+ * FUNCTION:    OsEnterLineEditMode, OsExitLineEditMode
+ *
+ * PARAMETERS:  None
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Enter/Exit the raw character input mode for the terminal.
+ *
+ * Interactive line-editing support for the AML debugger. Used with the
+ * common/acgetline module.
+ *
+ * readline() is not used because of non-portability. It is not available
+ * on all systems, and if it is, often the package must be manually installed.
+ *
+ * Therefore, we use the POSIX tcgetattr/tcsetattr and do the minimal line
+ * editing that we need in AcpiOsGetLine.
+ *
+ * If the POSIX tcgetattr/tcsetattr interfaces are unavailable, these
+ * calls will also work:
+ *     For OsEnterLineEditMode: system ("stty cbreak -echo")
+ *     For OsExitLineEditMode:  system ("stty cooked echo")
+ *
+ *****************************************************************************/
+
+static void
+OsEnterLineEditMode (
+    void)
+{
+    struct termios          LocalTermAttributes;
+
+
+    TermAttributesWereSet = 0;
+
+    /* STDIN must be a terminal */
+
+    if (!isatty (STDIN_FILENO))
+    {
+        return;
+    }
+
+    /* Get and keep the original attributes */
+
+    if (tcgetattr (STDIN_FILENO, &OriginalTermAttributes))
+    {
+        fprintf (stderr, "Could not get terminal attributes!\n");
+        return;
+    }
+
+    /* Set the new attributes to enable raw character input */
+
+    memcpy (&LocalTermAttributes, &OriginalTermAttributes,
+        sizeof (struct termios));
+
+    LocalTermAttributes.c_lflag &= ~(ICANON | ECHO);
+    LocalTermAttributes.c_cc[VMIN] = 1;
+    LocalTermAttributes.c_cc[VTIME] = 0;
+
+    if (tcsetattr (STDIN_FILENO, TCSANOW, &LocalTermAttributes))
+    {
+        fprintf (stderr, "Could not set terminal attributes!\n");
+        return;
+    }
+
+    TermAttributesWereSet = 1;
+}
+
+
+static void
+OsExitLineEditMode (
+    void)
+{
+
+    if (!TermAttributesWereSet)
+    {
+        return;
+    }
+
+    /* Set terminal attributes back to the original values */
+
+    if (tcsetattr (STDIN_FILENO, TCSANOW, &OriginalTermAttributes))
+    {
+        fprintf (stderr, "Could not restore terminal attributes!\n");
+    }
+}
+
+
+#else
+
+/* These functions are not needed for other ACPICA utilities */
+
+#define OsEnterLineEditMode()
+#define OsExitLineEditMode()
+#endif
+
+
+/******************************************************************************
+ *
+ * FUNCTION:    AcpiOsInitialize, AcpiOsTerminate
+ *
+ * PARAMETERS:  None
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Initialize and terminate this module.
+ *
+ *****************************************************************************/
+
+ACPI_STATUS
+AcpiOsInitialize (
+    void)
+{
+    ACPI_STATUS            Status;
+
+
+    AcpiGbl_OutputFile = stdout;
+
+    OsEnterLineEditMode ();
+
+    Status = AcpiOsCreateLock (&AcpiGbl_PrintLock);
+    if (ACPI_FAILURE (Status))
+    {
+        return (Status);
+    }
+
+    return (AE_OK);
+}
+
+ACPI_STATUS
+AcpiOsTerminate (
+    void)
+{
+
+    OsExitLineEditMode ();
+    return (AE_OK);
+}
+
+
+#ifndef ACPI_USE_NATIVE_RSDP_POINTER
+/******************************************************************************
+ *
+ * FUNCTION:    AcpiOsGetRootPointer
+ *
+ * PARAMETERS:  None
+ *
+ * RETURN:      RSDP physical address
+ *
+ * DESCRIPTION: Gets the ACPI root pointer (RSDP)
+ *
+ *****************************************************************************/
+
+ACPI_PHYSICAL_ADDRESS
+AcpiOsGetRootPointer (
+    void)
+{
+
+    return (0);
+}
+#endif
+
+
+/******************************************************************************
+ *
+ * FUNCTION:    AcpiOsPredefinedOverride
+ *
+ * PARAMETERS:  InitVal             - Initial value of the predefined object
+ *              NewVal              - The new value for the object
+ *
+ * RETURN:      Status, pointer to value. Null pointer returned if not
+ *              overriding.
+ *
+ * DESCRIPTION: Allow the OS to override predefined names
+ *
+ *****************************************************************************/
+
+ACPI_STATUS
+AcpiOsPredefinedOverride (
+    const ACPI_PREDEFINED_NAMES *InitVal,
+    ACPI_STRING                 *NewVal)
+{
+
+    if (!InitVal || !NewVal)
+    {
+        return (AE_BAD_PARAMETER);
+    }
+
+    *NewVal = NULL;
+    return (AE_OK);
+}
+
+
+/******************************************************************************
+ *
+ * FUNCTION:    AcpiOsTableOverride
+ *
+ * PARAMETERS:  ExistingTable       - Header of current table (probably
+ *                                    firmware)
+ *              NewTable            - Where an entire new table is returned.
+ *
+ * RETURN:      Status, pointer to new table. Null pointer returned if no
+ *              table is available to override
+ *
+ * DESCRIPTION: Return a different version of a table if one is available
+ *
+ *****************************************************************************/
+
+ACPI_STATUS
+AcpiOsTableOverride (
+    ACPI_TABLE_HEADER       *ExistingTable,
+    ACPI_TABLE_HEADER       **NewTable)
+{
+
+    if (!ExistingTable || !NewTable)
+    {
+        return (AE_BAD_PARAMETER);
+    }
+
+    *NewTable = NULL;
+
+#ifdef ACPI_EXEC_APP
+
+    AeTableOverride (ExistingTable, NewTable);
+    return (AE_OK);
+#else
+
+    return (AE_NO_ACPI_TABLES);
+#endif
+}
+
+
+/******************************************************************************
+ *
+ * FUNCTION:    AcpiOsPhysicalTableOverride
+ *
+ * PARAMETERS:  ExistingTable       - Header of current table (probably firmware)
+ *              NewAddress          - Where new table address is returned
+ *                                    (Physical address)
+ *              NewTableLength      - Where new table length is returned
+ *
+ * RETURN:      Status, address/length of new table. Null pointer returned
+ *              if no table is available to override.
+ *
+ * DESCRIPTION: Returns AE_SUPPORT, function not used in user space.
+ *
+ *****************************************************************************/
+
+ACPI_STATUS
+AcpiOsPhysicalTableOverride (
+    ACPI_TABLE_HEADER       *ExistingTable,
+    ACPI_PHYSICAL_ADDRESS   *NewAddress,
+    UINT32                  *NewTableLength)
+{
+
+    return (AE_SUPPORT);
+}
+
+
+/******************************************************************************
+ *
+ * FUNCTION:    AcpiOsRedirectOutput
+ *
+ * PARAMETERS:  Destination         - An open file handle/pointer
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Causes redirect of AcpiOsPrintf and AcpiOsVprintf
+ *
+ *****************************************************************************/
+
+void
+AcpiOsRedirectOutput (
+    void                    *Destination)
+{
+
+    AcpiGbl_OutputFile = Destination;
+}
+
+
+/******************************************************************************
+ *
+ * FUNCTION:    AcpiOsPrintf
+ *
+ * PARAMETERS:  fmt, ...            - Standard printf format
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Formatted output. Note: very similar to AcpiOsVprintf
+ *              (performance), changes should be tracked in both functions.
+ *
+ *****************************************************************************/
+
+void ACPI_INTERNAL_VAR_XFACE
+AcpiOsPrintf (
+    const char              *Fmt,
+    ...)
+{
+    va_list                 Args;
+    UINT8                   Flags;
+
+
+    Flags = AcpiGbl_DbOutputFlags;
+    if (Flags & ACPI_DB_REDIRECTABLE_OUTPUT)
+    {
+        /* Output is directable to either a file (if open) or the console */
+
+        if (AcpiGbl_DebugFile)
+        {
+            /* Output file is open, send the output there */
+
+            va_start (Args, Fmt);
+            vfprintf (AcpiGbl_DebugFile, Fmt, Args);
+            va_end (Args);
+        }
+        else
+        {
+            /* No redirection, send output to console (once only!) */
+
+            Flags |= ACPI_DB_CONSOLE_OUTPUT;
+        }
+    }
+
+    if (Flags & ACPI_DB_CONSOLE_OUTPUT)
+    {
+        va_start (Args, Fmt);
+        vfprintf (AcpiGbl_OutputFile, Fmt, Args);
+        va_end (Args);
+    }
+}
+
+
+/******************************************************************************
+ *
+ * FUNCTION:    AcpiOsVprintf
+ *
+ * PARAMETERS:  fmt                 - Standard printf format
+ *              args                - Argument list
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Formatted output with argument list pointer. Note: very
+ *              similar to AcpiOsPrintf, changes should be tracked in both
+ *              functions.
+ *
+ *****************************************************************************/
+
+void
+AcpiOsVprintf (
+    const char              *Fmt,
+    va_list                 Args)
+{
+    UINT8                   Flags;
+    char                    Buffer[ACPI_VPRINTF_BUFFER_SIZE];
+
+
+    /*
+     * We build the output string in a local buffer because we may be
+     * outputting the buffer twice. Using vfprintf is problematic because
+     * some implementations modify the args pointer/structure during
+     * execution. Thus, we use the local buffer for portability.
+     *
+     * Note: Since this module is intended for use by the various ACPICA
+     * utilities/applications, we can safely declare the buffer on the stack.
+     * Also, This function is used for relatively small error messages only.
+     */
+    vsnprintf (Buffer, ACPI_VPRINTF_BUFFER_SIZE, Fmt, Args);
+
+    Flags = AcpiGbl_DbOutputFlags;
+    if (Flags & ACPI_DB_REDIRECTABLE_OUTPUT)
+    {
+        /* Output is directable to either a file (if open) or the console */
+
+        if (AcpiGbl_DebugFile)
+        {
+            /* Output file is open, send the output there */
+
+            fputs (Buffer, AcpiGbl_DebugFile);
+        }
+        else
+        {
+            /* No redirection, send output to console (once only!) */
+
+            Flags |= ACPI_DB_CONSOLE_OUTPUT;
+        }
+    }
+
+    if (Flags & ACPI_DB_CONSOLE_OUTPUT)
+    {
+        fputs (Buffer, AcpiGbl_OutputFile);
+    }
+}
+
+
+#ifndef ACPI_EXEC_APP
+/******************************************************************************
+ *
+ * FUNCTION:    AcpiOsGetLine
+ *
+ * PARAMETERS:  Buffer              - Where to return the command line
+ *              BufferLength        - Maximum length of Buffer
+ *              BytesRead           - Where the actual byte count is returned
+ *
+ * RETURN:      Status and actual bytes read
+ *
+ * DESCRIPTION: Get the next input line from the terminal. NOTE: For the
+ *              AcpiExec utility, we use the acgetline module instead to
+ *              provide line-editing and history support.
+ *
+ *****************************************************************************/
+
+ACPI_STATUS
+AcpiOsGetLine (
+    char                    *Buffer,
+    UINT32                  BufferLength,
+    UINT32                  *BytesRead)
+{
+    int                     InputChar;
+    UINT32                  EndOfLine;
+
+
+    /* Standard AcpiOsGetLine for all utilities except AcpiExec */
+
+    for (EndOfLine = 0; ; EndOfLine++)
+    {
+        if (EndOfLine >= BufferLength)
+        {
+            return (AE_BUFFER_OVERFLOW);
+        }
+
+        if ((InputChar = getchar ()) == EOF)
+        {
+            return (AE_ERROR);
+        }
+
+        if (!InputChar || InputChar == _ASCII_NEWLINE)
+        {
+            break;
+        }
+
+        Buffer[EndOfLine] = (char) InputChar;
+    }
+
+    /* Null terminate the buffer */
+
+    Buffer[EndOfLine] = 0;
+
+    /* Return the number of bytes in the string */
+
+    if (BytesRead)
+    {
+        *BytesRead = EndOfLine;
+    }
+
+    return (AE_OK);
+}
+#endif
+
+
+#ifndef ACPI_USE_NATIVE_MEMORY_MAPPING
+/******************************************************************************
+ *
+ * FUNCTION:    AcpiOsMapMemory
+ *
+ * PARAMETERS:  where               - Physical address of memory to be mapped
+ *              length              - How much memory to map
+ *
+ * RETURN:      Pointer to mapped memory. Null on error.
+ *
+ * DESCRIPTION: Map physical memory into caller's address space
+ *
+ *****************************************************************************/
+
+void *
+AcpiOsMapMemory (
+    ACPI_PHYSICAL_ADDRESS   where,
+    ACPI_SIZE               length)
+{
+
+    return (ACPI_TO_POINTER ((ACPI_SIZE) where));
+}
+
+
+/******************************************************************************
+ *
+ * FUNCTION:    AcpiOsUnmapMemory
+ *
+ * PARAMETERS:  where               - Logical address of memory to be unmapped
+ *              length              - How much memory to unmap
+ *
+ * RETURN:      None.
+ *
+ * DESCRIPTION: Delete a previously created mapping. Where and Length must
+ *              correspond to a previous mapping exactly.
+ *
+ *****************************************************************************/
+
+void
+AcpiOsUnmapMemory (
+    void                    *where,
+    ACPI_SIZE               length)
+{
+
+    return;
+}
+#endif
+
+
+/******************************************************************************
+ *
+ * FUNCTION:    AcpiOsAllocate
+ *
+ * PARAMETERS:  Size                - Amount to allocate, in bytes
+ *
+ * RETURN:      Pointer to the new allocation. Null on error.
+ *
+ * DESCRIPTION: Allocate memory. Algorithm is dependent on the OS.
+ *
+ *****************************************************************************/
+
+void *
+AcpiOsAllocate (
+    ACPI_SIZE               size)
+{
+    void                    *Mem;
+
+
+    Mem = (void *) malloc ((size_t) size);
+    return (Mem);
+}
+
+
+#ifdef USE_NATIVE_ALLOCATE_ZEROED
+/******************************************************************************
+ *
+ * FUNCTION:    AcpiOsAllocateZeroed
+ *
+ * PARAMETERS:  Size                - Amount to allocate, in bytes
+ *
+ * RETURN:      Pointer to the new allocation. Null on error.
+ *
+ * DESCRIPTION: Allocate and zero memory. Algorithm is dependent on the OS.
+ *
+ *****************************************************************************/
+
+void *
+AcpiOsAllocateZeroed (
+    ACPI_SIZE               size)
+{
+    void                    *Mem;
+
+
+    Mem = (void *) calloc (1, (size_t) size);
+    return (Mem);
+}
+#endif
+
+
+/******************************************************************************
+ *
+ * FUNCTION:    AcpiOsFree
+ *
+ * PARAMETERS:  mem                 - Pointer to previously allocated memory
+ *
+ * RETURN:      None.
+ *
+ * DESCRIPTION: Free memory allocated via AcpiOsAllocate
+ *
+ *****************************************************************************/
+
+void
+AcpiOsFree (
+    void                    *mem)
+{
+
+    free (mem);
+}
+
+
+#ifdef ACPI_SINGLE_THREADED
+/******************************************************************************
+ *
+ * FUNCTION:    Semaphore stub functions
+ *
+ * DESCRIPTION: Stub functions used for single-thread applications that do
+ *              not require semaphore synchronization. Full implementations
+ *              of these functions appear after the stubs.
+ *
+ *****************************************************************************/
+
+ACPI_STATUS
+AcpiOsCreateSemaphore (
+    UINT32              MaxUnits,
+    UINT32              InitialUnits,
+    ACPI_HANDLE         *OutHandle)
+{
+    *OutHandle = (ACPI_HANDLE) 1;
+    return (AE_OK);
+}
+
+ACPI_STATUS
+AcpiOsDeleteSemaphore (
+    ACPI_HANDLE         Handle)
+{
+    return (AE_OK);
+}
+
+ACPI_STATUS
+AcpiOsWaitSemaphore (
+    ACPI_HANDLE         Handle,
+    UINT32              Units,
+    UINT16              Timeout)
+{
+    return (AE_OK);
+}
+
+ACPI_STATUS
+AcpiOsSignalSemaphore (
+    ACPI_HANDLE         Handle,
+    UINT32              Units)
+{
+    return (AE_OK);
+}
+
+#else
+/******************************************************************************
+ *
+ * FUNCTION:    AcpiOsCreateSemaphore
+ *
+ * PARAMETERS:  InitialUnits        - Units to be assigned to the new semaphore
+ *              OutHandle           - Where a handle will be returned
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Create an OS semaphore
+ *
+ *****************************************************************************/
+
+ACPI_STATUS
+AcpiOsCreateSemaphore (
+    UINT32              MaxUnits,
+    UINT32              InitialUnits,
+    ACPI_HANDLE         *OutHandle)
+{
+    sem_t               *Sem;
+
+
+    if (!OutHandle)
+    {
+        return (AE_BAD_PARAMETER);
+    }
+
+#ifdef __APPLE__
+    {
+        char            *SemaphoreName = tmpnam (NULL);
+
+        Sem = sem_open (SemaphoreName, O_EXCL|O_CREAT, 0755, InitialUnits);
+        if (!Sem)
+        {
+            return (AE_NO_MEMORY);
+        }
+        sem_unlink (SemaphoreName); /* This just deletes the name */
+    }
+
+#else
+    Sem = AcpiOsAllocate (sizeof (sem_t));
+    if (!Sem)
+    {
+        return (AE_NO_MEMORY);
+    }
+
+    if (sem_init (Sem, 0, InitialUnits) == -1)
+    {
+        AcpiOsFree (Sem);
+        return (AE_BAD_PARAMETER);
+    }
+#endif
+
+    *OutHandle = (ACPI_HANDLE) Sem;
+    return (AE_OK);
+}
+
+
+/******************************************************************************
+ *
+ * FUNCTION:    AcpiOsDeleteSemaphore
+ *
+ * PARAMETERS:  Handle              - Handle returned by AcpiOsCreateSemaphore
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Delete an OS semaphore
+ *
+ *****************************************************************************/
+
+ACPI_STATUS
+AcpiOsDeleteSemaphore (
+    ACPI_HANDLE         Handle)
+{
+    sem_t               *Sem = (sem_t *) Handle;
+
+
+    if (!Sem)
+    {
+        return (AE_BAD_PARAMETER);
+    }
+
+    if (sem_destroy (Sem) == -1)
+    {
+        return (AE_BAD_PARAMETER);
+    }
+
+    return (AE_OK);
+}
+
+
+/******************************************************************************
+ *
+ * FUNCTION:    AcpiOsWaitSemaphore
+ *
+ * PARAMETERS:  Handle              - Handle returned by AcpiOsCreateSemaphore
+ *              Units               - How many units to wait for
+ *              MsecTimeout         - How long to wait (milliseconds)
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Wait for units
+ *
+ *****************************************************************************/
+
+ACPI_STATUS
+AcpiOsWaitSemaphore (
+    ACPI_HANDLE         Handle,
+    UINT32              Units,
+    UINT16              MsecTimeout)
+{
+    ACPI_STATUS         Status = AE_OK;
+    sem_t               *Sem = (sem_t *) Handle;
+#ifndef ACPI_USE_ALTERNATE_TIMEOUT
+    struct timespec     Time;
+    int                 RetVal;
+#endif
+
+
+    if (!Sem)
+    {
+        return (AE_BAD_PARAMETER);
+    }
+
+    switch (MsecTimeout)
+    {
+    /*
+     * No Wait:
+     * --------
+     * A zero timeout value indicates that we shouldn't wait - just
+     * acquire the semaphore if available otherwise return AE_TIME
+     * (a.k.a. 'would block').
+     */
+    case 0:
+
+        if (sem_trywait(Sem) == -1)
+        {
+            Status = (AE_TIME);
+        }
+        break;
+
+    /* Wait Indefinitely */
+
+    case ACPI_WAIT_FOREVER:
+
+        if (sem_wait (Sem))
+        {
+            Status = (AE_TIME);
+        }
+        break;
+
+    /* Wait with MsecTimeout */
+
+    default:
+
+#ifdef ACPI_USE_ALTERNATE_TIMEOUT
+        /*
+         * Alternate timeout mechanism for environments where
+         * sem_timedwait is not available or does not work properly.
+         */
+        while (MsecTimeout)
+        {
+            if (sem_trywait (Sem) == 0)
+            {
+                /* Got the semaphore */
+                return (AE_OK);
+            }
+
+            if (MsecTimeout >= 10)
+            {
+                MsecTimeout -= 10;
+                usleep (10 * ACPI_USEC_PER_MSEC); /* ten milliseconds */
+            }
+            else
+            {
+                MsecTimeout--;
+                usleep (ACPI_USEC_PER_MSEC); /* one millisecond */
+            }
+        }
+        Status = (AE_TIME);
+#else
+        /*
+         * The interface to sem_timedwait is an absolute time, so we need to
+         * get the current time, then add in the millisecond Timeout value.
+         */
+        if (clock_gettime (CLOCK_REALTIME, &Time) == -1)
+        {
+            perror ("clock_gettime");
+            return (AE_TIME);
+        }
+
+        Time.tv_sec += (MsecTimeout / ACPI_MSEC_PER_SEC);
+        Time.tv_nsec += ((MsecTimeout % ACPI_MSEC_PER_SEC) * ACPI_NSEC_PER_MSEC);
+
+        /* Handle nanosecond overflow (field must be less than one second) */
+
+        if (Time.tv_nsec >= ACPI_NSEC_PER_SEC)
+        {
+            Time.tv_sec += (Time.tv_nsec / ACPI_NSEC_PER_SEC);
+            Time.tv_nsec = (Time.tv_nsec % ACPI_NSEC_PER_SEC);
+        }
+
+        while (((RetVal = sem_timedwait (Sem, &Time)) == -1) && (errno == EINTR))
+        {
+            continue;
+        }
+
+        if (RetVal != 0)
+        {
+            if (errno != ETIMEDOUT)
+            {
+                perror ("sem_timedwait");
+            }
+            Status = (AE_TIME);
+        }
+#endif
+        break;
+    }
+
+    return (Status);
+}
+
+
+/******************************************************************************
+ *
+ * FUNCTION:    AcpiOsSignalSemaphore
+ *
+ * PARAMETERS:  Handle              - Handle returned by AcpiOsCreateSemaphore
+ *              Units               - Number of units to send
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Send units
+ *
+ *****************************************************************************/
+
+ACPI_STATUS
+AcpiOsSignalSemaphore (
+    ACPI_HANDLE         Handle,
+    UINT32              Units)
+{
+    sem_t               *Sem = (sem_t *)Handle;
+
+
+    if (!Sem)
+    {
+        return (AE_BAD_PARAMETER);
+    }
+
+    if (sem_post (Sem) == -1)
+    {
+        return (AE_LIMIT);
+    }
+
+    return (AE_OK);
+}
+
+#endif /* ACPI_SINGLE_THREADED */
+
+
+/******************************************************************************
+ *
+ * FUNCTION:    Spinlock interfaces
+ *
+ * DESCRIPTION: Map these interfaces to semaphore interfaces
+ *
+ *****************************************************************************/
+
+ACPI_STATUS
+AcpiOsCreateLock (
+    ACPI_SPINLOCK           *OutHandle)
+{
+
+    return (AcpiOsCreateSemaphore (1, 1, OutHandle));
+}
+
+
+void
+AcpiOsDeleteLock (
+    ACPI_SPINLOCK           Handle)
+{
+    AcpiOsDeleteSemaphore (Handle);
+}
+
+
+ACPI_CPU_FLAGS
+AcpiOsAcquireLock (
+    ACPI_HANDLE             Handle)
+{
+    AcpiOsWaitSemaphore (Handle, 1, 0xFFFF);
+    return (0);
+}
+
+
+void
+AcpiOsReleaseLock (
+    ACPI_SPINLOCK           Handle,
+    ACPI_CPU_FLAGS          Flags)
+{
+    AcpiOsSignalSemaphore (Handle, 1);
+}
+
+
+/******************************************************************************
+ *
+ * FUNCTION:    AcpiOsInstallInterruptHandler
+ *
+ * PARAMETERS:  InterruptNumber     - Level handler should respond to.
+ *              Isr                 - Address of the ACPI interrupt handler
+ *              ExceptPtr           - Where status is returned
+ *
+ * RETURN:      Handle to the newly installed handler.
+ *
+ * DESCRIPTION: Install an interrupt handler. Used to install the ACPI
+ *              OS-independent handler.
+ *
+ *****************************************************************************/
+
+UINT32
+AcpiOsInstallInterruptHandler (
+    UINT32                  InterruptNumber,
+    ACPI_OSD_HANDLER        ServiceRoutine,
+    void                    *Context)
+{
+
+    return (AE_OK);
+}
+
+
+/******************************************************************************
+ *
+ * FUNCTION:    AcpiOsRemoveInterruptHandler
+ *
+ * PARAMETERS:  Handle              - Returned when handler was installed
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Uninstalls an interrupt handler.
+ *
+ *****************************************************************************/
+
+ACPI_STATUS
+AcpiOsRemoveInterruptHandler (
+    UINT32                  InterruptNumber,
+    ACPI_OSD_HANDLER        ServiceRoutine)
+{
+
+    return (AE_OK);
+}
+
+
+/******************************************************************************
+ *
+ * FUNCTION:    AcpiOsStall
+ *
+ * PARAMETERS:  microseconds        - Time to sleep
+ *
+ * RETURN:      Blocks until sleep is completed.
+ *
+ * DESCRIPTION: Sleep at microsecond granularity
+ *
+ *****************************************************************************/
+
+void
+AcpiOsStall (
+    UINT32                  microseconds)
+{
+
+    if (microseconds)
+    {
+        usleep (microseconds);
+    }
+}
+
+
+/******************************************************************************
+ *
+ * FUNCTION:    AcpiOsSleep
+ *
+ * PARAMETERS:  milliseconds        - Time to sleep
+ *
+ * RETURN:      Blocks until sleep is completed.
+ *
+ * DESCRIPTION: Sleep at millisecond granularity
+ *
+ *****************************************************************************/
+
+void
+AcpiOsSleep (
+    UINT64                  milliseconds)
+{
+
+    /* Sleep for whole seconds */
+
+    sleep (milliseconds / ACPI_MSEC_PER_SEC);
+
+    /*
+     * Sleep for remaining microseconds.
+     * Arg to usleep() is in usecs and must be less than 1,000,000 (1 second).
+     */
+    usleep ((milliseconds % ACPI_MSEC_PER_SEC) * ACPI_USEC_PER_MSEC);
+}
+
+
+/******************************************************************************
+ *
+ * FUNCTION:    AcpiOsGetTimer
+ *
+ * PARAMETERS:  None
+ *
+ * RETURN:      Current time in 100 nanosecond units
+ *
+ * DESCRIPTION: Get the current system time
+ *
+ *****************************************************************************/
+
+UINT64
+AcpiOsGetTimer (
+    void)
+{
+    struct timeval          time;
+
+
+    /* This timer has sufficient resolution for user-space application code */
+
+    gettimeofday (&time, NULL);
+
+    /* (Seconds * 10^7 = 100ns(10^-7)) + (Microseconds(10^-6) * 10^1 = 100ns) */
+
+    return (((UINT64) time.tv_sec * ACPI_100NSEC_PER_SEC) +
+            ((UINT64) time.tv_usec * ACPI_100NSEC_PER_USEC));
+}
+
+
+/******************************************************************************
+ *
+ * FUNCTION:    AcpiOsReadPciConfiguration
+ *
+ * PARAMETERS:  PciId               - Seg/Bus/Dev
+ *              PciRegister         - Device Register
+ *              Value               - Buffer where value is placed
+ *              Width               - Number of bits
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Read data from PCI configuration space
+ *
+ *****************************************************************************/
+
+ACPI_STATUS
+AcpiOsReadPciConfiguration (
+    ACPI_PCI_ID             *PciId,
+    UINT32                  PciRegister,
+    UINT64                  *Value,
+    UINT32                  Width)
+{
+
+    *Value = 0;
+    return (AE_OK);
+}
+
+
+/******************************************************************************
+ *
+ * FUNCTION:    AcpiOsWritePciConfiguration
+ *
+ * PARAMETERS:  PciId               - Seg/Bus/Dev
+ *              PciRegister         - Device Register
+ *              Value               - Value to be written
+ *              Width               - Number of bits
+ *
+ * RETURN:      Status.
+ *
+ * DESCRIPTION: Write data to PCI configuration space
+ *
+ *****************************************************************************/
+
+ACPI_STATUS
+AcpiOsWritePciConfiguration (
+    ACPI_PCI_ID             *PciId,
+    UINT32                  PciRegister,
+    UINT64                  Value,
+    UINT32                  Width)
+{
+
+    return (AE_OK);
+}
+
+
+/******************************************************************************
+ *
+ * FUNCTION:    AcpiOsReadPort
+ *
+ * PARAMETERS:  Address             - Address of I/O port/register to read
+ *              Value               - Where value is placed
+ *              Width               - Number of bits
+ *
+ * RETURN:      Value read from port
+ *
+ * DESCRIPTION: Read data from an I/O port or register
+ *
+ *****************************************************************************/
+
+ACPI_STATUS
+AcpiOsReadPort (
+    ACPI_IO_ADDRESS         Address,
+    UINT32                  *Value,
+    UINT32                  Width)
+{
+
+    switch (Width)
+    {
+    case 8:
+
+        *Value = 0xFF;
+        break;
+
+    case 16:
+
+        *Value = 0xFFFF;
+        break;
+
+    case 32:
+
+        *Value = 0xFFFFFFFF;
+        break;
+
+    default:
+
+        return (AE_BAD_PARAMETER);
+    }
+
+    return (AE_OK);
+}
+
+
+/******************************************************************************
+ *
+ * FUNCTION:    AcpiOsWritePort
+ *
+ * PARAMETERS:  Address             - Address of I/O port/register to write
+ *              Value               - Value to write
+ *              Width               - Number of bits
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Write data to an I/O port or register
+ *
+ *****************************************************************************/
+
+ACPI_STATUS
+AcpiOsWritePort (
+    ACPI_IO_ADDRESS         Address,
+    UINT32                  Value,
+    UINT32                  Width)
+{
+
+    return (AE_OK);
+}
+
+
+/******************************************************************************
+ *
+ * FUNCTION:    AcpiOsReadMemory
+ *
+ * PARAMETERS:  Address             - Physical Memory Address to read
+ *              Value               - Where value is placed
+ *              Width               - Number of bits (8,16,32, or 64)
+ *
+ * RETURN:      Value read from physical memory address. Always returned
+ *              as a 64-bit integer, regardless of the read width.
+ *
+ * DESCRIPTION: Read data from a physical memory address
+ *
+ *****************************************************************************/
+
+ACPI_STATUS
+AcpiOsReadMemory (
+    ACPI_PHYSICAL_ADDRESS   Address,
+    UINT64                  *Value,
+    UINT32                  Width)
+{
+
+    switch (Width)
+    {
+    case 8:
+    case 16:
+    case 32:
+    case 64:
+
+        *Value = 0;
+        break;
+
+    default:
+
+        return (AE_BAD_PARAMETER);
+    }
+    return (AE_OK);
+}
+
+
+/******************************************************************************
+ *
+ * FUNCTION:    AcpiOsWriteMemory
+ *
+ * PARAMETERS:  Address             - Physical Memory Address to write
+ *              Value               - Value to write
+ *              Width               - Number of bits (8,16,32, or 64)
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Write data to a physical memory address
+ *
+ *****************************************************************************/
+
+ACPI_STATUS
+AcpiOsWriteMemory (
+    ACPI_PHYSICAL_ADDRESS   Address,
+    UINT64                  Value,
+    UINT32                  Width)
+{
+
+    return (AE_OK);
+}
+
+
+/******************************************************************************
+ *
+ * FUNCTION:    AcpiOsReadable
+ *
+ * PARAMETERS:  Pointer             - Area to be verified
+ *              Length              - Size of area
+ *
+ * RETURN:      TRUE if readable for entire length
+ *
+ * DESCRIPTION: Verify that a pointer is valid for reading
+ *
+ *****************************************************************************/
+
+BOOLEAN
+AcpiOsReadable (
+    void                    *Pointer,
+    ACPI_SIZE               Length)
+{
+
+    return (TRUE);
+}
+
+
+/******************************************************************************
+ *
+ * FUNCTION:    AcpiOsWritable
+ *
+ * PARAMETERS:  Pointer             - Area to be verified
+ *              Length              - Size of area
+ *
+ * RETURN:      TRUE if writable for entire length
+ *
+ * DESCRIPTION: Verify that a pointer is valid for writing
+ *
+ *****************************************************************************/
+
+BOOLEAN
+AcpiOsWritable (
+    void                    *Pointer,
+    ACPI_SIZE               Length)
+{
+
+    return (TRUE);
+}
+
+
+/******************************************************************************
+ *
+ * FUNCTION:    AcpiOsSignal
+ *
+ * PARAMETERS:  Function            - ACPI A signal function code
+ *              Info                - Pointer to function-dependent structure
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Miscellaneous functions. Example implementation only.
+ *
+ *****************************************************************************/
+
+ACPI_STATUS
+AcpiOsSignal (
+    UINT32                  Function,
+    void                    *Info)
+{
+
+    switch (Function)
+    {
+    case ACPI_SIGNAL_FATAL:
+
+        break;
+
+    case ACPI_SIGNAL_BREAKPOINT:
+
+        break;
+
+    default:
+
+        break;
+    }
+
+    return (AE_OK);
+}
+
+/* Optional multi-thread support */
+
+#ifndef ACPI_SINGLE_THREADED
+/******************************************************************************
+ *
+ * FUNCTION:    AcpiOsGetThreadId
+ *
+ * PARAMETERS:  None
+ *
+ * RETURN:      Id of the running thread
+ *
+ * DESCRIPTION: Get the ID of the current (running) thread
+ *
+ *****************************************************************************/
+
+ACPI_THREAD_ID
+AcpiOsGetThreadId (
+    void)
+{
+    pthread_t               thread;
+
+
+    thread = pthread_self();
+    return (ACPI_CAST_PTHREAD_T (thread));
+}
+
+
+/******************************************************************************
+ *
+ * FUNCTION:    AcpiOsExecute
+ *
+ * PARAMETERS:  Type                - Type of execution
+ *              Function            - Address of the function to execute
+ *              Context             - Passed as a parameter to the function
+ *
+ * RETURN:      Status.
+ *
+ * DESCRIPTION: Execute a new thread
+ *
+ *****************************************************************************/
+
+ACPI_STATUS
+AcpiOsExecute (
+    ACPI_EXECUTE_TYPE       Type,
+    ACPI_OSD_EXEC_CALLBACK  Function,
+    void                    *Context)
+{
+    pthread_t               thread;
+    int                     ret;
+
+
+    ret = pthread_create (&thread, NULL, (PTHREAD_CALLBACK) Function, Context);
+    if (ret)
+    {
+        AcpiOsPrintf("Create thread failed");
+    }
+    return (0);
+}
+
+#else /* ACPI_SINGLE_THREADED */
+ACPI_THREAD_ID
+AcpiOsGetThreadId (
+    void)
+{
+    return (1);
+}
+
+ACPI_STATUS
+AcpiOsExecute (
+    ACPI_EXECUTE_TYPE       Type,
+    ACPI_OSD_EXEC_CALLBACK  Function,
+    void                    *Context)
+{
+
+    Function (Context);
+
+    return (AE_OK);
+}
+
+#endif /* ACPI_SINGLE_THREADED */
+
+
+/******************************************************************************
+ *
+ * FUNCTION:    AcpiOsWaitEventsComplete
+ *
+ * PARAMETERS:  None
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Wait for all asynchronous events to complete. This
+ *              implementation does nothing.
+ *
+ *****************************************************************************/
+
+void
+AcpiOsWaitEventsComplete (
+    void)
+{
+    return;
+}
diff --git a/usr/src/cmd/acpi/iasl/Makefile b/usr/src/cmd/acpi/iasl/Makefile
new file mode 100644
index 0000000000..eb09b61e8c
--- /dev/null
+++ b/usr/src/cmd/acpi/iasl/Makefile
@@ -0,0 +1,160 @@
+#
+# This file and its contents are supplied under the terms of the
+# Common Development and Distribution License ("CDDL"), version 1.0.
+# You may only use this file in accordance with the terms of version
+# 1.0 of the CDDL.
+#
+# A full copy of the text of the CDDL should have accompanied this
+# source.  A copy of the CDDL is also available via the Internet at
+# http://www.illumos.org/license/CDDL.
+#
+# Copyright (c) 2018, Joyent, Inc.
+#
+# Adapted from acpica/generate/unix/iasl/Makefile, which lacked a copyright
+# notice.
+#
+PROG=		iasl
+
+include ../../Makefile.cmd
+include ../../Makefile.cmd.64
+include ../../Makefile.ctf
+
+OBJS =	aslanalyze.o aslascii.o aslbtypes.o aslcodegen.o aslcompile.o \
+	asldebug.o aslerror.o aslexternal.o aslfileio.o \
+	aslfiles.o aslfold.o aslhex.o asllength.o asllisting.o asllistsup.o \
+	aslload.o asllookup.o aslmain.o aslmap.o aslmapenter.o aslmapoutput.o \
+	aslmaputils.o aslmessages.o aslmethod.o aslnamesp.o asloffset.o \
+	aslopcodes.o asloperands.o aslopt.o asloptions.o aslpld.o aslpredef.o \
+	aslprepkg.o aslprintf.o aslprune.o aslresource.o aslrestype1.o \
+	aslrestype1i.o aslrestype2.o aslrestype2d.o aslrestype2e.o \
+	aslrestype2q.o aslrestype2s.o aslrestype2w.o aslstartup.o aslstubs.o \
+	asltransform.o asltree.o aslutils.o asluuid.o aslwalks.o aslxref.o \
+	aslxrefout.o dtcompile.o dtexpress.o dtfield.o dtio.o \
+	dtsubtable.o dttable.o dttable1.o dttable2.o dttemplate.o dtutils.o \
+	prexpress.o prmacros.o prscan.o prutils.o
+# ../common
+OBJS +=	adfile.o acfileio.o adisasm.o adwalk.o ahids.o ahtable.o ahpredef.o \
+	ahuuids.o dmextern.o dmrestag.o dmtbinfo.o dmtable.o dmtbdump.o \
+	getopt.o osl.o osunixxf.o
+# usr/src/common/acpica/disassembler
+OBJS += dmbuffer.o dmcstyle.o dmdeferred.o dmnames.o dmopcode.o dmresrc.o \
+	dmresrcl.o dmresrcl2.o dmresrcs.o dmtables.o dmutils.o dmwalk.o
+# usr/src/common/acpica/dispatcher
+OBJS += dsargs.o dscontrol.o dsfield.o dsobject.o dsopcode.o dsutils.o \
+	dswload.o dswload2.o dswexec.o dswscope.o dswstate.o
+# usr/src/common/acpica/executer
+OBJS += exconcat.o exconvrt.o excreate.o exdump.o exmisc.o exmutex.o exnames.o \
+	exoparg1.o exoparg2.o exoparg3.o exoparg6.o exprep.o exresolv.o \
+	exresop.o exresnte.o exstore.o exstoren.o exstorob.o exsystem.o \
+	exutils.o
+# usr/src/common/acpica/namespace
+OBJS += nsaccess.o nsalloc.o nsdump.o nsnames.o nsobject.o nsparse.o \
+	nssearch.o nsutils.o nswalk.o
+# usr/src/common/acpica/parser
+OBJS += psargs.o psloop.o psobject.o psopcode.o psopinfo.o psparse.o psscope.o pstree.o \
+	psutils.o pswalk.o
+# usr/src/common/acpica/tables
+OBJS +=	tbdata.o tbfadt.o tbinstal.o tbprint.o tbutils.o tbxface.o
+# usr/src/common/acpica/utilities
+OBJS += utaddress.o utalloc.o utascii.o utbuffer.o utcache.o utcopy.o \
+	utdebug.o utdecode.o utdelete.o uterror.o utexcep.o utglobal.o uthex.o \
+	utinit.o utlock.o utmath.o utmisc.o utmutex.o utnonansi.o utobject.o \
+	utownerid.o utpredef.o utprint.o utresrc.o utstate.o utstring.o \
+	utuuid.o utxface.o utxferror.o
+
+SRCS = $(OBJS:.o=.c)
+
+ACPI_CMN_SRC		= $(SRC)/common/acpica
+
+# Source used only by iasl
+ASL_COMPILER		= compiler
+ACPICA_DEBUGGER		= debugger
+# Source used by kernel module and iasl
+ACPICA_DISASSEMBLER	= $(ACPI_CMN_SRC)/disassembler
+ACPICA_DISPATCHER	= $(ACPI_CMN_SRC)/dispatcher
+ACPICA_EXECUTER		= $(ACPI_CMN_SRC)/executer
+ACPICA_NAMESPACE	= $(ACPI_CMN_SRC)/namespace
+ACPICA_PARSER		= $(ACPI_CMN_SRC)/parser
+ACPICA_TABLES		= $(ACPI_CMN_SRC)/tables
+ACPICA_UTILITIES	= $(ACPI_CMN_SRC)/utilities
+# Source used by other programs and iasl
+ACPICA_COMMON		= ../common
+
+VPATH = $(ACPICA_DEBUGGER):$(ACPICA_DISASSEMBLER):\
+	$(ACPICA_DISPATCHER):$(ACPICA_EXECUTER):$(ACPICA_NAMESPACE):\
+	$(ACPICA_PARSER):$(ACPICA_TABLES):$(ACPICA_UTILITIES):\
+	$(ACPICA_COMMON):$(ACPICA_OSL)
+
+INTERMEDIATES = \
+	aslcompiler.y \
+	aslcompilerlex.c \
+	aslcompilerparse.c \
+	dtparserlex.c \
+	dtparserparse.c \
+	prparserlex.c \
+	prparserparse.c \
+	aslcompiler.y.h \
+	dtparser.y.h \
+	prparser.y.h
+
+CERRWARN += -_gcc=-Wno-unused-function
+
+CPPFLAGS += -I$(SRC)/uts/intel/sys/acpi -DACPI_ASL_COMPILER -I.
+
+LEX_C_FILES = aslcompilerlex.c dtparserlex.c prparserlex.c
+YACC_C_FILES = aslcompilerparse.c dtparserparse.c prparserparse.c
+YACC_H_FILES = aslcompiler.y.h dtparser.y.h prparser.y.h
+YACC_FILES = $(YACC_C_FILES) $(YACC_H_FILES)
+
+aslcompilerlex.c aslcompilerparse.c aslcompiler.y.h := PARSER = AslCompiler
+aslcompilerlex.c aslcompilerparse.c aslcompiler.y.h := LY_BASE = aslcompiler
+
+dtparserlex.c dtparserparse.c dtparser.y.h := PARSER = DtParser
+dtparserlex.c dtparserparse.c dtparser.y.h := LY_BASE = dtparser
+
+prparserlex.c prparserparse.c prparser.y.h := PARSER = PrParser
+prparserlex.c prparserparse.c prparser.y.h := LY_BASE = prparser
+
+$(LEX_C_FILES) := LEXFILE = $(LY_BASE).l
+$(LEX_C_FILES) := LEXFILE = $(LY_BASE).l
+$(YACC_FILES) := YTABC = $(LY_BASE)parse.c
+
+OBJS += $(LEX_C_FILES:.c=.o) $(YACC_C_FILES:.c=.o)
+
+GM4FLAGS = -P
+LFLAGS = -i -s
+
+.KEEP_STATE:
+
+all: $(YACC_FILES) .WAIT $(PROG)
+
+aslcompiler.y: aslparser.y
+	$(GM4) $(GM4FLAGS) aslparser.y > $@
+
+$(LEX_C_FILES):
+	$(FLEX) $(LFLAGS) -P$(PARSER) -o $@ $(LEXFILE)
+
+%parse.h: %parse.c
+
+%parse.c %.y.h: %.y
+	_suffix=`echo $@ | awk -F. '{print $$NF}'` && \
+	_d=`mktemp -d $(PARSER).XXXXXX` && \
+	(cd $$_d && $(BISON) -y -v -d -p$(PARSER) ../$(LY_BASE).y) && \
+	mv $$_d/y.tab.$$_suffix $@; \
+	_ret=$$?; \
+	rm -rf $$_d; \
+	exit $$_ret
+
+$(PROG): $(OBJS)
+	$(LINK.c) -o $@ $(OBJS) $(LDLIBS)
+	$(POST_PROCESS)
+
+install: all $(ROOTUSRSBINPROG)
+
+clean:
+	$(RM) $(OBJS) $(INTERMEDIATES) $(PROG)
+	$(RM) -r AslCompiler.?????? DtParser.?????? PrParser.??????
+
+lint:	lint_SRCS
+
+include ../../Makefile.targ
diff --git a/usr/src/cmd/acpi/iasl/aslanalyze.c b/usr/src/cmd/acpi/iasl/aslanalyze.c
new file mode 100644
index 0000000000..bf5b37cdef
--- /dev/null
+++ b/usr/src/cmd/acpi/iasl/aslanalyze.c
@@ -0,0 +1,736 @@
+/******************************************************************************
+ *
+ * Module Name: aslanalyze.c - Support functions for parse tree walks
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2016, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include "aslcompiler.h"
+#include "aslcompiler.y.h"
+#include <string.h>
+
+
+#define _COMPONENT          ACPI_COMPILER
+        ACPI_MODULE_NAME    ("aslanalyze")
+
+
+/* Local Prototypes */
+
+static ACPI_STATUS
+ApDeviceSubtreeWalk (
+    ACPI_PARSE_OBJECT       *Op,
+    UINT32                  Level,
+    void                    *Context);
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AnIsInternalMethod
+ *
+ * PARAMETERS:  Op                  - Current op
+ *
+ * RETURN:      Boolean
+ *
+ * DESCRIPTION: Check for an internal control method.
+ *
+ ******************************************************************************/
+
+BOOLEAN
+AnIsInternalMethod (
+    ACPI_PARSE_OBJECT       *Op)
+{
+
+    if ((!strcmp (Op->Asl.ExternalName, "\\_OSI")) ||
+        (!strcmp (Op->Asl.ExternalName, "_OSI")))
+    {
+        return (TRUE);
+    }
+
+    return (FALSE);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AnGetInternalMethodReturnType
+ *
+ * PARAMETERS:  Op                  - Current op
+ *
+ * RETURN:      Btype
+ *
+ * DESCRIPTION: Get the return type of an internal method
+ *
+ ******************************************************************************/
+
+UINT32
+AnGetInternalMethodReturnType (
+    ACPI_PARSE_OBJECT       *Op)
+{
+
+    if ((!strcmp (Op->Asl.ExternalName, "\\_OSI")) ||
+        (!strcmp (Op->Asl.ExternalName, "_OSI")))
+    {
+        return (ACPI_BTYPE_STRING);
+    }
+
+    return (0);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AnCheckId
+ *
+ * PARAMETERS:  Op                  - Current parse op
+ *              Type                - HID or CID
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Perform various checks on _HID and _CID strings. Only limited
+ *              checks can be performed on _CID strings.
+ *
+ ******************************************************************************/
+
+void
+AnCheckId (
+    ACPI_PARSE_OBJECT       *Op,
+    ACPI_NAME               Type)
+{
+    UINT32                  i;
+    ACPI_SIZE               Length;
+
+
+    /* Only care about string versions of _HID/_CID (integers are legal) */
+
+    if (Op->Asl.ParseOpcode != PARSEOP_STRING_LITERAL)
+    {
+        return;
+    }
+
+    /* For both _HID and _CID, the string must be non-null */
+
+    Length = strlen (Op->Asl.Value.String);
+    if (!Length)
+    {
+        AslError (ASL_ERROR, ASL_MSG_NULL_STRING, Op, NULL);
+        return;
+    }
+
+    /*
+     * One of the things we want to catch here is the use of a leading
+     * asterisk in the string -- an odd construct that certain platform
+     * manufacturers are fond of. Technically, a leading asterisk is OK
+     * for _CID, but a valid use of this has not been seen.
+     */
+    if (*Op->Asl.Value.String == '*')
+    {
+        AslError (ASL_ERROR, ASL_MSG_LEADING_ASTERISK,
+            Op, Op->Asl.Value.String);
+        return;
+    }
+
+    /* _CID strings are bus-specific, no more checks can be performed */
+
+    if (Type == ASL_TYPE_CID)
+    {
+        return;
+    }
+
+    /* For _HID, all characters must be alphanumeric */
+
+    for (i = 0; Op->Asl.Value.String[i]; i++)
+    {
+        if (!isalnum ((int) Op->Asl.Value.String[i]))
+        {
+            AslError (ASL_ERROR, ASL_MSG_ALPHANUMERIC_STRING,
+                Op, Op->Asl.Value.String);
+            return;
+        }
+    }
+
+    /*
+     * _HID String must be one of these forms:
+     *
+     * "AAA####"    A is an uppercase letter and # is a hex digit
+     * "ACPI####"   # is a hex digit
+     * "NNNN####"   N is an uppercase letter or decimal digit (0-9)
+     *              # is a hex digit (ACPI 5.0)
+     */
+    if ((Length < 7) || (Length > 8))
+    {
+        AslError (ASL_ERROR, ASL_MSG_HID_LENGTH,
+            Op, Op->Asl.Value.String);
+        return;
+    }
+
+    /* _HID Length is valid (7 or 8), now check prefix (first 3 or 4 chars) */
+
+    if (Length == 7)
+    {
+        /* AAA####: Ensure the alphabetic prefix is all uppercase */
+
+        for (i = 0; i < 3; i++)
+        {
+            if (!isupper ((int) Op->Asl.Value.String[i]))
+            {
+                AslError (ASL_ERROR, ASL_MSG_UPPER_CASE,
+                    Op, &Op->Asl.Value.String[i]);
+                return;
+            }
+        }
+    }
+    else /* Length == 8 */
+    {
+        /*
+         * ACPI#### or NNNN####:
+         * Ensure the prefix contains only uppercase alpha or decimal digits
+         */
+        for (i = 0; i < 4; i++)
+        {
+            if (!isupper ((int) Op->Asl.Value.String[i]) &&
+                !isdigit ((int) Op->Asl.Value.String[i]))
+            {
+                AslError (ASL_ERROR, ASL_MSG_HID_PREFIX,
+                    Op, &Op->Asl.Value.String[i]);
+                return;
+            }
+        }
+    }
+
+    /* Remaining characters (suffix) must be hex digits */
+
+    for (; i < Length; i++)
+    {
+        if (!isxdigit ((int) Op->Asl.Value.String[i]))
+        {
+            AslError (ASL_ERROR, ASL_MSG_HID_SUFFIX,
+                Op, &Op->Asl.Value.String[i]);
+            break;
+        }
+    }
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AnLastStatementIsReturn
+ *
+ * PARAMETERS:  Op                  - A method parse node
+ *
+ * RETURN:      TRUE if last statement is an ASL RETURN. False otherwise
+ *
+ * DESCRIPTION: Walk down the list of top level statements within a method
+ *              to find the last one. Check if that last statement is in
+ *              fact a RETURN statement.
+ *
+ ******************************************************************************/
+
+BOOLEAN
+AnLastStatementIsReturn (
+    ACPI_PARSE_OBJECT       *Op)
+{
+    ACPI_PARSE_OBJECT       *Next;
+
+
+    /* Check if last statement is a return */
+
+    Next = ASL_GET_CHILD_NODE (Op);
+    while (Next)
+    {
+        if ((!Next->Asl.Next) &&
+            (Next->Asl.ParseOpcode == PARSEOP_RETURN))
+        {
+            return (TRUE);
+        }
+
+        Next = ASL_GET_PEER_NODE (Next);
+    }
+
+    return (FALSE);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AnCheckMethodReturnValue
+ *
+ * PARAMETERS:  Op                  - Parent
+ *              OpInfo              - Parent info
+ *              ArgOp               - Method invocation op
+ *              RequiredBtypes      - What caller requires
+ *              ThisNodeBtype       - What this node returns (if anything)
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Check a method invocation for 1) A return value and if it does
+ *              in fact return a value, 2) check the type of the return value.
+ *
+ ******************************************************************************/
+
+void
+AnCheckMethodReturnValue (
+    ACPI_PARSE_OBJECT       *Op,
+    const ACPI_OPCODE_INFO  *OpInfo,
+    ACPI_PARSE_OBJECT       *ArgOp,
+    UINT32                  RequiredBtypes,
+    UINT32                  ThisNodeBtype)
+{
+    ACPI_PARSE_OBJECT       *OwningOp;
+    ACPI_NAMESPACE_NODE     *Node;
+
+
+    Node = ArgOp->Asl.Node;
+
+    if (!Node)
+    {
+        /* No error message, this can happen and is OK */
+
+        return;
+    }
+
+    /* Examine the parent op of this method */
+
+    OwningOp = Node->Op;
+    if (OwningOp->Asl.CompileFlags & NODE_METHOD_NO_RETVAL)
+    {
+        /* Method NEVER returns a value */
+
+        AslError (ASL_ERROR, ASL_MSG_NO_RETVAL, Op, Op->Asl.ExternalName);
+    }
+    else if (OwningOp->Asl.CompileFlags & NODE_METHOD_SOME_NO_RETVAL)
+    {
+        /* Method SOMETIMES returns a value, SOMETIMES not */
+
+        AslError (ASL_WARNING, ASL_MSG_SOME_NO_RETVAL,
+            Op, Op->Asl.ExternalName);
+    }
+    else if (!(ThisNodeBtype & RequiredBtypes))
+    {
+        /* Method returns a value, but the type is wrong */
+
+        AnFormatBtype (StringBuffer, ThisNodeBtype);
+        AnFormatBtype (StringBuffer2, RequiredBtypes);
+
+        /*
+         * The case where the method does not return any value at all
+         * was already handled in the namespace cross reference
+         * -- Only issue an error if the method in fact returns a value,
+         * but it is of the wrong type
+         */
+        if (ThisNodeBtype != 0)
+        {
+            sprintf (MsgBuffer,
+                "Method returns [%s], %s operator requires [%s]",
+                StringBuffer, OpInfo->Name, StringBuffer2);
+
+            AslError (ASL_ERROR, ASL_MSG_INVALID_TYPE, ArgOp, MsgBuffer);
+        }
+    }
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AnIsResultUsed
+ *
+ * PARAMETERS:  Op                  - Parent op for the operator
+ *
+ * RETURN:      TRUE if result from this operation is actually consumed
+ *
+ * DESCRIPTION: Determine if the function result value from an operator is
+ *              used.
+ *
+ ******************************************************************************/
+
+BOOLEAN
+AnIsResultUsed (
+    ACPI_PARSE_OBJECT       *Op)
+{
+    ACPI_PARSE_OBJECT       *Parent;
+
+
+    switch (Op->Asl.ParseOpcode)
+    {
+    case PARSEOP_INCREMENT:
+    case PARSEOP_DECREMENT:
+
+        /* These are standalone operators, no return value */
+
+        return (TRUE);
+
+    default:
+
+        break;
+    }
+
+    /* Examine parent to determine if the return value is used */
+
+    Parent = Op->Asl.Parent;
+    switch (Parent->Asl.ParseOpcode)
+    {
+    /* If/While - check if the operator is the predicate */
+
+    case PARSEOP_IF:
+    case PARSEOP_WHILE:
+
+        /* First child is the predicate */
+
+        if (Parent->Asl.Child == Op)
+        {
+            return (TRUE);
+        }
+
+        return (FALSE);
+
+    /* Not used if one of these is the parent */
+
+    case PARSEOP_METHOD:
+    case PARSEOP_DEFINITION_BLOCK:
+    case PARSEOP_ELSE:
+
+        return (FALSE);
+
+    default:
+
+        /* Any other type of parent means that the result is used */
+
+        return (TRUE);
+    }
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    ApCheckForGpeNameConflict
+ *
+ * PARAMETERS:  Op                  - Current parse op
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Check for a conflict between GPE names within this scope.
+ *              Conflict means two GPE names with the same GPE number, but
+ *              different types -- such as _L1C and _E1C.
+ *
+ ******************************************************************************/
+
+void
+ApCheckForGpeNameConflict (
+    ACPI_PARSE_OBJECT       *Op)
+{
+    ACPI_PARSE_OBJECT       *NextOp;
+    UINT32                  GpeNumber;
+    char                    Name[ACPI_NAME_SIZE + 1];
+    char                    Target[ACPI_NAME_SIZE];
+
+
+    /* Need a null-terminated string version of NameSeg */
+
+    ACPI_MOVE_32_TO_32 (Name, &Op->Asl.NameSeg);
+    Name[ACPI_NAME_SIZE] = 0;
+
+    /*
+     * For a GPE method:
+     * 1st char must be underscore
+     * 2nd char must be L or E
+     * 3rd/4th chars must be a hex number
+     */
+    if ((Name[0] != '_') ||
+       ((Name[1] != 'L') && (Name[1] != 'E')))
+    {
+        return;
+    }
+
+    /* Verify 3rd/4th chars are a valid hex value */
+
+    GpeNumber = strtoul (&Name[2], NULL, 16);
+    if (GpeNumber == ACPI_UINT32_MAX)
+    {
+        return;
+    }
+
+    /*
+     * We are now sure we have an _Lxx or _Exx.
+     * Create the target name that would cause collision (Flip E/L)
+     */
+    ACPI_MOVE_32_TO_32 (Target, Name);
+
+    /* Inject opposite letter ("L" versus "E") */
+
+    if (Name[1] == 'L')
+    {
+        Target[1] = 'E';
+    }
+    else /* Name[1] == 'E' */
+    {
+        Target[1] = 'L';
+    }
+
+    /* Search all peers (objects within this scope) for target match */
+
+    NextOp = Op->Asl.Next;
+    while (NextOp)
+    {
+        /*
+         * We mostly care about methods, but check Name() constructs also,
+         * even though they will get another error for not being a method.
+         * All GPE names must be defined as control methods.
+         */
+        if ((NextOp->Asl.ParseOpcode == PARSEOP_METHOD) ||
+            (NextOp->Asl.ParseOpcode == PARSEOP_NAME))
+        {
+            if (ACPI_COMPARE_NAME (Target, NextOp->Asl.NameSeg))
+            {
+                /* Found both _Exy and _Lxy in the same scope, error */
+
+                AslError (ASL_ERROR, ASL_MSG_GPE_NAME_CONFLICT, NextOp,
+                    Name);
+                return;
+            }
+        }
+
+        NextOp = NextOp->Asl.Next;
+    }
+
+    /* OK, no conflict found */
+
+    return;
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    ApCheckRegMethod
+ *
+ * PARAMETERS:  Op                  - Current parse op
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Ensure that a _REG method has a corresponding Operation
+ *              Region declaration within the same scope. Note: _REG is defined
+ *              to have two arguments and must therefore be defined as a
+ *              control method.
+ *
+ ******************************************************************************/
+
+void
+ApCheckRegMethod (
+    ACPI_PARSE_OBJECT       *Op)
+{
+    ACPI_PARSE_OBJECT       *Next;
+    ACPI_PARSE_OBJECT       *Parent;
+
+
+    /* We are only interested in _REG methods */
+
+    if (!ACPI_COMPARE_NAME (METHOD_NAME__REG, &Op->Asl.NameSeg))
+    {
+        return;
+    }
+
+    /* Get the start of the current scope */
+
+    Parent = Op->Asl.Parent;
+    Next = Parent->Asl.Child;
+
+    /* Search entire scope for an operation region declaration */
+
+    while (Next)
+    {
+        if (Next->Asl.ParseOpcode == PARSEOP_OPERATIONREGION)
+        {
+            return; /* Found region, OK */
+        }
+
+        Next = Next->Asl.Next;
+    }
+
+    /* No region found, issue warning */
+
+    AslError (ASL_WARNING, ASL_MSG_NO_REGION, Op, NULL);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    ApFindNameInDeviceTree
+ *
+ * PARAMETERS:  Name                - Name to search for
+ *              Op                  - Current parse op
+ *
+ * RETURN:      TRUE if name found in the same scope as Op.
+ *
+ * DESCRIPTION: Determine if a name appears in the same scope as Op, as either
+ *              a Method() or a Name(). "Same scope" can mean under an If or
+ *              Else statement.
+ *
+ * NOTE: Detects _HID/_ADR in this type of construct (legal in ACPI 6.1+)
+ *
+ * Scope (\_SB.PCI0)
+ * {
+ *     Device (I2C0)
+ *     {
+ *         If (SMD0 != 4) {
+ *             Name (_HID, "INT3442")
+ *         } Else {
+ *             Name (_ADR, 0x400)
+ *         }
+ *     }
+ * }
+ ******************************************************************************/
+
+BOOLEAN
+ApFindNameInDeviceTree (
+    char                    *Name,
+    ACPI_PARSE_OBJECT       *Op)
+{
+    ACPI_STATUS             Status;
+
+
+    Status = TrWalkParseTree (Op, ASL_WALK_VISIT_DOWNWARD,
+        ApDeviceSubtreeWalk, NULL, Name);
+
+    if (Status == AE_CTRL_TRUE)
+    {
+        return (TRUE);  /* Found a match */
+    }
+
+    return (FALSE);
+}
+
+
+/* Callback function for interface above */
+
+static ACPI_STATUS
+ApDeviceSubtreeWalk (
+    ACPI_PARSE_OBJECT       *Op,
+    UINT32                  Level,
+    void                    *Context)
+{
+    char                    *Name = ACPI_CAST_PTR (char, Context);
+
+
+    switch (Op->Asl.ParseOpcode)
+    {
+    case PARSEOP_DEVICE:
+
+        /* Level 0 is the starting device, ignore it */
+
+        if (Level > 0)
+        {
+            /* Ignore sub-devices */
+
+            return (AE_CTRL_DEPTH);
+        }
+        break;
+
+    case PARSEOP_NAME:
+    case PARSEOP_METHOD:
+
+        /* These are what we are looking for */
+
+        if (ACPI_COMPARE_NAME (Name, Op->Asl.NameSeg))
+        {
+            return (AE_CTRL_TRUE);
+        }
+        return (AE_CTRL_DEPTH);
+
+    case PARSEOP_SCOPE:
+    case PARSEOP_FIELD:
+    case PARSEOP_OPERATIONREGION:
+
+        /*
+         * We want to ignore these, because either they can be large
+         * subtrees or open a scope to somewhere else.
+         */
+        return (AE_CTRL_DEPTH);
+
+    default:
+        break;
+    }
+
+    return (AE_OK);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    ApFindNameInScope
+ *
+ * PARAMETERS:  Name                - Name to search for
+ *              Op                  - Current parse op
+ *
+ * RETURN:      TRUE if name found in the same scope as Op.
+ *
+ * DESCRIPTION: Determine if a name appears in the same scope as Op, as either
+ *              a Method() or a Name().
+ *
+ ******************************************************************************/
+
+BOOLEAN
+ApFindNameInScope (
+    char                    *Name,
+    ACPI_PARSE_OBJECT       *Op)
+{
+    ACPI_PARSE_OBJECT       *Next;
+    ACPI_PARSE_OBJECT       *Parent;
+
+
+    /* Get the start of the current scope */
+
+    Parent = Op->Asl.Parent;
+    Next = Parent->Asl.Child;
+
+    /* Search entire scope for a match to the name */
+
+    while (Next)
+    {
+        if ((Next->Asl.ParseOpcode == PARSEOP_METHOD) ||
+            (Next->Asl.ParseOpcode == PARSEOP_NAME))
+        {
+            if (ACPI_COMPARE_NAME (Name, Next->Asl.NameSeg))
+            {
+                return (TRUE);
+            }
+        }
+
+        Next = Next->Asl.Next;
+    }
+
+    return (FALSE);
+}
diff --git a/usr/src/cmd/acpi/iasl/aslascii.c b/usr/src/cmd/acpi/iasl/aslascii.c
new file mode 100644
index 0000000000..8a1d57dccc
--- /dev/null
+++ b/usr/src/cmd/acpi/iasl/aslascii.c
@@ -0,0 +1,288 @@
+/******************************************************************************
+ *
+ * Module Name: aslascii - ASCII detection and support routines
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2016, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include "aslcompiler.h"
+#include <actables.h>
+#include <acapps.h>
+
+#define _COMPONENT          ACPI_COMPILER
+        ACPI_MODULE_NAME    ("aslascii")
+
+
+/* Local prototypes */
+
+static void
+FlConsumeAnsiComment (
+    FILE                    *Handle,
+    ASL_FILE_STATUS         *Status);
+
+static void
+FlConsumeNewComment (
+    FILE                    *Handle,
+    ASL_FILE_STATUS         *Status);
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    FlIsFileAsciiSource
+ *
+ * PARAMETERS:  Filename            - Full input filename
+ *              DisplayErrors       - TRUE if error messages desired
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Verify that the input file is entirely ASCII. Ignores characters
+ *              within comments. Note: does not handle nested comments and does
+ *              not handle comment delimiters within string literals. However,
+ *              on the rare chance this happens and an invalid character is
+ *              missed, the parser will catch the error by failing in some
+ *              spectactular manner.
+ *
+ ******************************************************************************/
+
+ACPI_STATUS
+FlIsFileAsciiSource (
+    char                    *Filename,
+    BOOLEAN                 DisplayErrors)
+{
+    UINT8                   Byte;
+    ACPI_SIZE               BadBytes = 0;
+    BOOLEAN                 OpeningComment = FALSE;
+    ASL_FILE_STATUS         Status;
+    FILE                    *Handle;
+
+
+    /* Open file in text mode so file offset is always accurate */
+
+    Handle = fopen (Filename, "rb");
+    if (!Handle)
+    {
+        perror ("Could not open input file");
+        return (AE_ERROR);
+    }
+
+    Status.Line = 1;
+    Status.Offset = 0;
+
+    /* Read the entire file */
+
+    while (fread (&Byte, 1, 1, Handle) == 1)
+    {
+        /* Ignore comment fields (allow non-ascii within) */
+
+        if (OpeningComment)
+        {
+            /* Check for second comment open delimiter */
+
+            if (Byte == '*')
+            {
+                FlConsumeAnsiComment (Handle, &Status);
+            }
+
+            if (Byte == '/')
+            {
+                FlConsumeNewComment (Handle, &Status);
+            }
+
+            /* Reset */
+
+            OpeningComment = FALSE;
+        }
+        else if (Byte == '/')
+        {
+            OpeningComment = TRUE;
+        }
+
+        /* Check for an ASCII character */
+
+        if (!ACPI_IS_ASCII (Byte))
+        {
+            if ((BadBytes < 10) && (DisplayErrors))
+            {
+                AcpiOsPrintf (
+                    "Found non-ASCII character in source text: "
+                    "0x%2.2X in line %u, file offset 0x%2.2X\n",
+                    Byte, Status.Line, Status.Offset);
+            }
+            BadBytes++;
+        }
+
+        /* Ensure character is either printable or a "space" char */
+
+        else if (!isprint (Byte) && !isspace (Byte))
+        {
+            if ((BadBytes < 10) && (DisplayErrors))
+            {
+                AcpiOsPrintf (
+                    "Found invalid character in source text: "
+                    "0x%2.2X in line %u, file offset 0x%2.2X\n",
+                    Byte, Status.Line, Status.Offset);
+            }
+            BadBytes++;
+        }
+
+        /* Update line counter as necessary */
+
+        if (Byte == 0x0A)
+        {
+            Status.Line++;
+        }
+
+        Status.Offset++;
+    }
+
+    fclose (Handle);
+
+    /* Were there any non-ASCII characters in the file? */
+
+    if (BadBytes)
+    {
+        if (DisplayErrors)
+        {
+            AcpiOsPrintf (
+                "Total %u invalid characters found in input source text, "
+                "could be a binary file\n", BadBytes);
+            AslError (ASL_ERROR, ASL_MSG_NON_ASCII, NULL, Filename);
+        }
+
+        return (AE_BAD_CHARACTER);
+    }
+
+    /* File is OK (100% ASCII) */
+
+    return (AE_OK);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    FlConsumeAnsiComment
+ *
+ * PARAMETERS:  Handle              - Open input file
+ *              Status              - File current status struct
+ *
+ * RETURN:      Number of lines consumed
+ *
+ * DESCRIPTION: Step over a normal slash-star type comment
+ *
+ ******************************************************************************/
+
+static void
+FlConsumeAnsiComment (
+    FILE                    *Handle,
+    ASL_FILE_STATUS         *Status)
+{
+    UINT8                   Byte;
+    BOOLEAN                 ClosingComment = FALSE;
+
+
+    while (fread (&Byte, 1, 1, Handle) == 1)
+    {
+        /* Scan until comment close is found */
+
+        if (ClosingComment)
+        {
+            if (Byte == '/')
+            {
+                Status->Offset++;
+                return;
+            }
+
+            if (Byte != '*')
+            {
+                /* Reset */
+
+                ClosingComment = FALSE;
+            }
+        }
+        else if (Byte == '*')
+        {
+            ClosingComment = TRUE;
+        }
+
+        /* Maintain line count */
+
+        if (Byte == 0x0A)
+        {
+            Status->Line++;
+        }
+
+        Status->Offset++;
+    }
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    FlConsumeNewComment
+ *
+ * PARAMETERS:  Handle              - Open input file
+ *              Status              - File current status struct
+ *
+ * RETURN:      Number of lines consumed
+ *
+ * DESCRIPTION: Step over a slash-slash type of comment
+ *
+ ******************************************************************************/
+
+static void
+FlConsumeNewComment (
+    FILE                    *Handle,
+    ASL_FILE_STATUS         *Status)
+{
+    UINT8                   Byte;
+
+
+    while (fread (&Byte, 1, 1, Handle) == 1)
+    {
+        Status->Offset++;
+
+        /* Comment ends at newline */
+
+        if (Byte == 0x0A)
+        {
+            Status->Line++;
+            return;
+        }
+    }
+}
diff --git a/usr/src/cmd/acpi/iasl/aslbtypes.c b/usr/src/cmd/acpi/iasl/aslbtypes.c
new file mode 100644
index 0000000000..c956516f8b
--- /dev/null
+++ b/usr/src/cmd/acpi/iasl/aslbtypes.c
@@ -0,0 +1,595 @@
+/******************************************************************************
+ *
+ * Module Name: aslbtypes - Support for bitfield types
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2016, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include "aslcompiler.h"
+#include "aslcompiler.y.h"
+#include "amlcode.h"
+
+
+#define _COMPONENT          ACPI_COMPILER
+        ACPI_MODULE_NAME    ("aslbtypes")
+
+/* Local prototypes */
+
+static UINT32
+AnMapEtypeToBtype (
+    UINT32                  Etype);
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AnMapArgTypeToBtype
+ *
+ * PARAMETERS:  ArgType             - The ARGI required type(s) for this
+ *                                    argument, from the opcode info table
+ *
+ * RETURN:      The corresponding Bit-encoded types
+ *
+ * DESCRIPTION: Convert an encoded ARGI required argument type code into a
+ *              bitfield type code. Implements the implicit source conversion
+ *              rules.
+ *
+ ******************************************************************************/
+
+UINT32
+AnMapArgTypeToBtype (
+    UINT32                  ArgType)
+{
+
+    switch (ArgType)
+    {
+    /* Simple types */
+
+    case ARGI_ANYTYPE:
+
+        return (ACPI_BTYPE_OBJECTS_AND_REFS);
+
+    case ARGI_PACKAGE:
+
+        return (ACPI_BTYPE_PACKAGE);
+
+    case ARGI_EVENT:
+
+        return (ACPI_BTYPE_EVENT);
+
+    case ARGI_MUTEX:
+
+        return (ACPI_BTYPE_MUTEX);
+
+    case ARGI_DDBHANDLE:
+        /*
+         * DDBHandleObject := SuperName
+         * ACPI_BTYPE_REFERENCE_OBJECT:
+         *      Index reference as parameter of Load/Unload
+         */
+        return (ACPI_BTYPE_DDB_HANDLE | ACPI_BTYPE_REFERENCE_OBJECT);
+
+    /* Interchangeable types */
+    /*
+     * Source conversion rules:
+     * Integer, String, and Buffer are all interchangeable
+     */
+    case ARGI_INTEGER:
+    case ARGI_STRING:
+    case ARGI_BUFFER:
+    case ARGI_BUFFER_OR_STRING:
+    case ARGI_COMPUTEDATA:
+
+        return (ACPI_BTYPE_COMPUTE_DATA);
+
+    /* References */
+
+    case ARGI_INTEGER_REF:
+
+        return (ACPI_BTYPE_INTEGER);
+
+    case ARGI_OBJECT_REF:
+
+        return (ACPI_BTYPE_ALL_OBJECTS);
+
+    case ARGI_DEVICE_REF:
+
+        return (ACPI_BTYPE_DEVICE_OBJECTS);
+
+    case ARGI_REFERENCE:
+
+        return (ACPI_BTYPE_NAMED_REFERENCE); /* Name or Namestring */
+
+    case ARGI_TARGETREF:
+
+        /*
+         * Target operand for most math and logic operators.
+         * Package objects not allowed as target.
+         */
+        return (ACPI_BTYPE_COMPUTE_DATA | ACPI_BTYPE_DEBUG_OBJECT |
+            ACPI_BTYPE_REFERENCE_OBJECT);
+
+    case ARGI_STORE_TARGET:
+
+        /* Special target for Store(), includes packages */
+
+        return (ACPI_BTYPE_DATA | ACPI_BTYPE_DEBUG_OBJECT |
+            ACPI_BTYPE_REFERENCE_OBJECT);
+
+    case ARGI_FIXED_TARGET:
+    case ARGI_SIMPLE_TARGET:
+
+        return (ACPI_BTYPE_OBJECTS_AND_REFS);
+
+    /* Complex types */
+
+    case ARGI_DATAOBJECT:
+        /*
+         * Buffer, string, package or reference to a Op -
+         * Used only by SizeOf operator
+         */
+        return (ACPI_BTYPE_STRING | ACPI_BTYPE_BUFFER |
+            ACPI_BTYPE_PACKAGE | ACPI_BTYPE_REFERENCE_OBJECT);
+
+    case ARGI_COMPLEXOBJ:
+
+        /* Buffer, String, or package */
+
+        return (ACPI_BTYPE_STRING | ACPI_BTYPE_BUFFER |
+            ACPI_BTYPE_PACKAGE);
+
+    case ARGI_REF_OR_STRING:
+
+        /* Used by DeRefOf operator only */
+
+        return (ACPI_BTYPE_STRING | ACPI_BTYPE_REFERENCE_OBJECT);
+
+    case ARGI_REGION_OR_BUFFER:
+
+        /* Used by Load() only. Allow buffers in addition to regions/fields */
+
+        return (ACPI_BTYPE_REGION | ACPI_BTYPE_BUFFER |
+            ACPI_BTYPE_FIELD_UNIT);
+
+    case ARGI_DATAREFOBJ:
+
+        /* Used by Store() only, as the source operand */
+
+        return (ACPI_BTYPE_DATA_REFERENCE | ACPI_BTYPE_REFERENCE_OBJECT);
+
+    default:
+
+        break;
+    }
+
+    return (ACPI_BTYPE_OBJECTS_AND_REFS);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AnMapEtypeToBtype
+ *
+ * PARAMETERS:  Etype               - Encoded ACPI Type
+ *
+ * RETURN:      Btype corresponding to the Etype
+ *
+ * DESCRIPTION: Convert an encoded ACPI type to a bitfield type applying the
+ *              operand conversion rules. In other words, returns the type(s)
+ *              this Etype is implicitly converted to during interpretation.
+ *
+ ******************************************************************************/
+
+static UINT32
+AnMapEtypeToBtype (
+    UINT32                  Etype)
+{
+
+    if (Etype == ACPI_TYPE_ANY)
+    {
+        return (ACPI_BTYPE_OBJECTS_AND_REFS);
+    }
+
+    /* Try the standard ACPI data types */
+
+    if (Etype <= ACPI_TYPE_EXTERNAL_MAX)
+    {
+        /*
+         * This switch statement implements the allowed operand conversion
+         * rules as per the "ASL Data Types" section of the ACPI
+         * specification.
+         */
+        switch (Etype)
+        {
+        case ACPI_TYPE_INTEGER:
+
+            return (ACPI_BTYPE_COMPUTE_DATA | ACPI_BTYPE_DDB_HANDLE);
+
+        case ACPI_TYPE_STRING:
+        case ACPI_TYPE_BUFFER:
+
+            return (ACPI_BTYPE_COMPUTE_DATA);
+
+        case ACPI_TYPE_PACKAGE:
+
+            return (ACPI_BTYPE_PACKAGE);
+
+        case ACPI_TYPE_FIELD_UNIT:
+
+            return (ACPI_BTYPE_COMPUTE_DATA | ACPI_BTYPE_FIELD_UNIT);
+
+        case ACPI_TYPE_BUFFER_FIELD:
+
+            return (ACPI_BTYPE_COMPUTE_DATA | ACPI_BTYPE_BUFFER_FIELD);
+
+        case ACPI_TYPE_DDB_HANDLE:
+
+            return (ACPI_BTYPE_INTEGER | ACPI_BTYPE_DDB_HANDLE);
+
+        case ACPI_TYPE_DEBUG_OBJECT:
+
+            /* Cannot be used as a source operand */
+
+            return (0);
+
+        default:
+
+            return (1 << (Etype - 1));
+        }
+    }
+
+    /* Try the internal data types */
+
+    switch (Etype)
+    {
+    case ACPI_TYPE_LOCAL_REGION_FIELD:
+    case ACPI_TYPE_LOCAL_BANK_FIELD:
+    case ACPI_TYPE_LOCAL_INDEX_FIELD:
+
+        /* Named fields can be either Integer/Buffer/String */
+
+        return (ACPI_BTYPE_COMPUTE_DATA | ACPI_BTYPE_FIELD_UNIT);
+
+    case ACPI_TYPE_LOCAL_ALIAS:
+
+        return (ACPI_BTYPE_INTEGER);
+
+
+    case ACPI_TYPE_LOCAL_RESOURCE:
+    case ACPI_TYPE_LOCAL_RESOURCE_FIELD:
+
+        return (ACPI_BTYPE_REFERENCE_OBJECT);
+
+    default:
+
+        printf ("Unhandled encoded type: %X\n", Etype);
+        return (0);
+    }
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AnFormatBtype
+ *
+ * PARAMETERS:  Btype               - Bitfield of ACPI types
+ *              Buffer              - Where to put the ascii string
+ *
+ * RETURN:      None.
+ *
+ * DESCRIPTION: Convert a Btype to a string of ACPI types
+ *
+ ******************************************************************************/
+
+void
+AnFormatBtype (
+    char                    *Buffer,
+    UINT32                  Btype)
+{
+    UINT32                  Type;
+    BOOLEAN                 First = TRUE;
+
+
+    *Buffer = 0;
+    if (Btype == 0)
+    {
+        strcat (Buffer, "NoReturnValue");
+        return;
+    }
+
+    for (Type = 1; Type <= ACPI_TYPE_EXTERNAL_MAX; Type++)
+    {
+        if (Btype & 0x00000001)
+        {
+            if (!First)
+            {
+                strcat (Buffer, "|");
+            }
+
+            First = FALSE;
+            strcat (Buffer, AcpiUtGetTypeName (Type));
+        }
+        Btype >>= 1;
+    }
+
+    if (Btype & 0x00000001)
+    {
+        if (!First)
+        {
+            strcat (Buffer, "|");
+        }
+
+        First = FALSE;
+        strcat (Buffer, "Reference");
+    }
+
+    Btype >>= 1;
+    if (Btype & 0x00000001)
+    {
+        if (!First)
+        {
+            strcat (Buffer, "|");
+        }
+
+        First = FALSE;
+        strcat (Buffer, "Resource");
+    }
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AnGetBtype
+ *
+ * PARAMETERS:  Op                  - Parse node whose type will be returned.
+ *
+ * RETURN:      The Btype associated with the Op.
+ *
+ * DESCRIPTION: Get the (bitfield) ACPI type associated with the parse node.
+ *              Handles the case where the node is a name or method call and
+ *              the actual type must be obtained from the namespace node.
+ *
+ ******************************************************************************/
+
+UINT32
+AnGetBtype (
+    ACPI_PARSE_OBJECT       *Op)
+{
+    ACPI_NAMESPACE_NODE     *Node;
+    ACPI_PARSE_OBJECT       *ReferencedNode;
+    UINT32                  ThisNodeBtype = 0;
+
+
+    if (!Op)
+    {
+        AcpiOsPrintf ("Null Op in AnGetBtype\n");
+        return (ACPI_UINT32_MAX);
+    }
+
+    if ((Op->Asl.ParseOpcode == PARSEOP_NAMESEG)     ||
+        (Op->Asl.ParseOpcode == PARSEOP_NAMESTRING)  ||
+        (Op->Asl.ParseOpcode == PARSEOP_METHODCALL))
+    {
+        Node = Op->Asl.Node;
+        if (!Node)
+        {
+            /* These are not expected to have a node at this time */
+
+            if ((Op->Asl.Parent->Asl.ParseOpcode == PARSEOP_CREATEWORDFIELD) ||
+                (Op->Asl.Parent->Asl.ParseOpcode == PARSEOP_CREATEDWORDFIELD) ||
+                (Op->Asl.Parent->Asl.ParseOpcode == PARSEOP_CREATEQWORDFIELD) ||
+                (Op->Asl.Parent->Asl.ParseOpcode == PARSEOP_CREATEBYTEFIELD) ||
+                (Op->Asl.Parent->Asl.ParseOpcode == PARSEOP_CREATEBITFIELD) ||
+                (Op->Asl.Parent->Asl.ParseOpcode == PARSEOP_CREATEFIELD)    ||
+                (Op->Asl.Parent->Asl.ParseOpcode == PARSEOP_CONDREFOF))
+            {
+                return (ACPI_UINT32_MAX - 1);
+            }
+
+            DbgPrint (ASL_DEBUG_OUTPUT,
+                "No attached Nsnode: [%s] at line %u name [%s], "
+                "ignoring typecheck. Parent [%s]\n",
+                Op->Asl.ParseOpName, Op->Asl.LineNumber,
+                Op->Asl.ExternalName, Op->Asl.Parent->Asl.ParseOpName);
+            return (ACPI_UINT32_MAX - 1);
+        }
+
+        ThisNodeBtype = AnMapEtypeToBtype (Node->Type);
+        if (!ThisNodeBtype)
+        {
+            AslError (ASL_ERROR, ASL_MSG_COMPILER_INTERNAL, Op,
+                "could not map type");
+        }
+
+        if (Op->Asl.ParseOpcode == PARSEOP_METHODCALL)
+        {
+            ReferencedNode = Node->Op;
+            if (!ReferencedNode)
+            {
+                /* Check for an internal method */
+
+                if (AnIsInternalMethod (Op))
+                {
+                    return (AnGetInternalMethodReturnType (Op));
+                }
+
+                AslError (ASL_ERROR, ASL_MSG_COMPILER_INTERNAL, Op,
+                    "null Op pointer");
+                return (ACPI_UINT32_MAX);
+            }
+
+            if (ReferencedNode->Asl.CompileFlags & NODE_METHOD_TYPED)
+            {
+                ThisNodeBtype = ReferencedNode->Asl.AcpiBtype;
+            }
+            else
+            {
+                return (ACPI_UINT32_MAX -1);
+            }
+        }
+    }
+    else
+    {
+        ThisNodeBtype = Op->Asl.AcpiBtype;
+    }
+
+    return (ThisNodeBtype);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AnMapObjTypeToBtype
+ *
+ * PARAMETERS:  Op                  - A parse node
+ *
+ * RETURN:      A Btype
+ *
+ * DESCRIPTION: Map object to the associated "Btype"
+ *
+ ******************************************************************************/
+
+UINT32
+AnMapObjTypeToBtype (
+    ACPI_PARSE_OBJECT       *Op)
+{
+
+    switch (Op->Asl.ParseOpcode)
+    {
+    case PARSEOP_OBJECTTYPE_BFF:        /* "BuffFieldObj" */
+
+        return (ACPI_BTYPE_BUFFER_FIELD);
+
+    case PARSEOP_OBJECTTYPE_BUF:        /* "BuffObj" */
+
+        return (ACPI_BTYPE_BUFFER);
+
+    case PARSEOP_OBJECTTYPE_DDB:        /* "DDBHandleObj" */
+
+        return (ACPI_BTYPE_DDB_HANDLE);
+
+    case PARSEOP_OBJECTTYPE_DEV:        /* "DeviceObj" */
+
+        return (ACPI_BTYPE_DEVICE);
+
+    case PARSEOP_OBJECTTYPE_EVT:        /* "EventObj" */
+
+        return (ACPI_BTYPE_EVENT);
+
+    case PARSEOP_OBJECTTYPE_FLD:        /* "FieldUnitObj" */
+
+        return (ACPI_BTYPE_FIELD_UNIT);
+
+    case PARSEOP_OBJECTTYPE_INT:        /* "IntObj" */
+
+        return (ACPI_BTYPE_INTEGER);
+
+    case PARSEOP_OBJECTTYPE_MTH:        /* "MethodObj" */
+
+        return (ACPI_BTYPE_METHOD);
+
+    case PARSEOP_OBJECTTYPE_MTX:        /* "MutexObj" */
+
+        return (ACPI_BTYPE_MUTEX);
+
+    case PARSEOP_OBJECTTYPE_OPR:        /* "OpRegionObj" */
+
+        return (ACPI_BTYPE_REGION);
+
+    case PARSEOP_OBJECTTYPE_PKG:        /* "PkgObj" */
+
+        return (ACPI_BTYPE_PACKAGE);
+
+    case PARSEOP_OBJECTTYPE_POW:        /* "PowerResObj" */
+
+        return (ACPI_BTYPE_POWER);
+
+    case PARSEOP_OBJECTTYPE_STR:        /* "StrObj" */
+
+        return (ACPI_BTYPE_STRING);
+
+    case PARSEOP_OBJECTTYPE_THZ:        /* "ThermalZoneObj" */
+
+        return (ACPI_BTYPE_THERMAL);
+
+    case PARSEOP_OBJECTTYPE_UNK:        /* "UnknownObj" */
+
+        return (ACPI_BTYPE_OBJECTS_AND_REFS);
+
+    default:
+
+        return (0);
+    }
+}
+
+
+#ifdef ACPI_OBSOLETE_FUNCTIONS
+/*******************************************************************************
+ *
+ * FUNCTION:    AnMapBtypeToEtype
+ *
+ * PARAMETERS:  Btype               - Bitfield of ACPI types
+ *
+ * RETURN:      The Etype corresponding the the Btype
+ *
+ * DESCRIPTION: Convert a bitfield type to an encoded type
+ *
+ ******************************************************************************/
+
+UINT32
+AnMapBtypeToEtype (
+    UINT32              Btype)
+{
+    UINT32              i;
+    UINT32              Etype;
+
+
+    if (Btype == 0)
+    {
+        return (0);
+    }
+
+    Etype = 1;
+    for (i = 1; i < Btype; i *= 2)
+    {
+        Etype++;
+    }
+
+    return (Etype);
+}
+#endif
diff --git a/usr/src/cmd/acpi/iasl/aslcodegen.c b/usr/src/cmd/acpi/iasl/aslcodegen.c
new file mode 100644
index 0000000000..30e79841a2
--- /dev/null
+++ b/usr/src/cmd/acpi/iasl/aslcodegen.c
@@ -0,0 +1,658 @@
+/******************************************************************************
+ *
+ * Module Name: aslcodegen - AML code generation
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2016, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include "aslcompiler.h"
+#include "aslcompiler.y.h"
+#include "amlcode.h"
+
+#define _COMPONENT          ACPI_COMPILER
+        ACPI_MODULE_NAME    ("aslcodegen")
+
+/* Local prototypes */
+
+static ACPI_STATUS
+CgAmlWriteWalk (
+    ACPI_PARSE_OBJECT       *Op,
+    UINT32                  Level,
+    void                    *Context);
+
+static void
+CgLocalWriteAmlData (
+    ACPI_PARSE_OBJECT       *Op,
+    void                    *Buffer,
+    UINT32                  Length);
+
+static void
+CgWriteAmlOpcode (
+    ACPI_PARSE_OBJECT       *Op);
+
+static void
+CgWriteTableHeader (
+    ACPI_PARSE_OBJECT       *Op);
+
+static void
+CgCloseTable (
+    void);
+
+static void
+CgWriteNode (
+    ACPI_PARSE_OBJECT       *Op);
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    CgGenerateAmlOutput
+ *
+ * PARAMETERS:  None.
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Generate AML code. Currently generates the listing file
+ *              simultaneously.
+ *
+ ******************************************************************************/
+
+void
+CgGenerateAmlOutput (
+    void)
+{
+
+    /* Generate the AML output file */
+
+    FlSeekFile (ASL_FILE_SOURCE_OUTPUT, 0);
+    Gbl_SourceLine = 0;
+    Gbl_NextError = Gbl_ErrorLog;
+
+    TrWalkParseTree (Gbl_ParseTreeRoot, ASL_WALK_VISIT_DOWNWARD,
+        CgAmlWriteWalk, NULL, NULL);
+
+    DbgPrint (ASL_TREE_OUTPUT, ASL_PARSE_TREE_HEADER2);
+    CgCloseTable ();
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    CgAmlWriteWalk
+ *
+ * PARAMETERS:  ASL_WALK_CALLBACK
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Parse tree walk to generate the AML code.
+ *
+ ******************************************************************************/
+
+static ACPI_STATUS
+CgAmlWriteWalk (
+    ACPI_PARSE_OBJECT       *Op,
+    UINT32                  Level,
+    void                    *Context)
+{
+
+    /* Generate the AML for this node */
+
+    CgWriteNode (Op);
+
+    if (!Gbl_DebugFlag)
+    {
+        return (AE_OK);
+    }
+
+    /* Print header at level 0. Alignment assumes 32-bit pointers */
+
+    if (!Level)
+    {
+        DbgPrint (ASL_TREE_OUTPUT,
+            "\nFinal parse tree used for AML output:\n");
+        DbgPrint (ASL_TREE_OUTPUT, ASL_PARSE_TREE_HEADER2);
+    }
+
+    /* Dump ParseOp name and possible value */
+
+    switch (Op->Asl.ParseOpcode)
+    {
+    case PARSEOP_NAMESEG:
+    case PARSEOP_NAMESTRING:
+    case PARSEOP_METHODCALL:
+    case PARSEOP_STRING_LITERAL:
+
+        UtDumpStringOp (Op, Level);
+        break;
+
+    default:
+
+        UtDumpBasicOp (Op, Level);
+        break;
+    }
+
+    DbgPrint (ASL_TREE_OUTPUT, ASL_PARSE_TREE_DEBUG2,
+        /* 1  */ (UINT32) Op->Asl.Value.Integer,
+        /* 2  */ Op->Asl.ParseOpcode,
+        /* 3  */ Op->Asl.AmlOpcode,
+        /* 4  */ Op->Asl.AmlOpcodeLength,
+        /* 5  */ Op->Asl.AmlPkgLenBytes,
+        /* 6  */ Op->Asl.AmlLength,
+        /* 7  */ Op->Asl.AmlSubtreeLength,
+        /* 8  */ Op->Asl.Parent ? Op->Asl.Parent->Asl.AmlSubtreeLength : 0,
+        /* 9  */ Op,
+        /* 10 */ Op->Asl.Parent,
+        /* 11 */ Op->Asl.Child,
+        /* 12 */ Op->Asl.Next,
+        /* 13 */ Op->Asl.CompileFlags,
+        /* 14 */ Op->Asl.AcpiBtype,
+        /* 15 */ Op->Asl.FinalAmlLength,
+        /* 16 */ Op->Asl.Column,
+        /* 17 */ Op->Asl.LineNumber,
+        /* 18 */ Op->Asl.EndLine,
+        /* 19 */ Op->Asl.LogicalLineNumber,
+        /* 20 */ Op->Asl.EndLogicalLine);
+
+    return (AE_OK);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    CgLocalWriteAmlData
+ *
+ * PARAMETERS:  Op              - Current parse op
+ *              Buffer          - Buffer to write
+ *              Length          - Size of data in buffer
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Write a buffer of AML data to the AML output file.
+ *
+ ******************************************************************************/
+
+static void
+CgLocalWriteAmlData (
+    ACPI_PARSE_OBJECT       *Op,
+    void                    *Buffer,
+    UINT32                  Length)
+{
+
+    /* Write the raw data to the AML file */
+
+    FlWriteFile (ASL_FILE_AML_OUTPUT, Buffer, Length);
+
+    /* Update the final AML length for this node (used for listings) */
+
+    if (Op)
+    {
+        Op->Asl.FinalAmlLength += Length;
+    }
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    CgWriteAmlOpcode
+ *
+ * PARAMETERS:  Op            - Parse node with an AML opcode
+ *
+ * RETURN:      None.
+ *
+ * DESCRIPTION: Write the AML opcode corresponding to a parse node.
+ *
+ ******************************************************************************/
+
+static void
+CgWriteAmlOpcode (
+    ACPI_PARSE_OBJECT       *Op)
+{
+    UINT8                   PkgLenFirstByte;
+    UINT32                  i;
+    union {
+        UINT16                  Opcode;
+        UINT8                   OpcodeBytes[2];
+    } Aml;
+    union {
+        UINT32                  Len;
+        UINT8                   LenBytes[4];
+    } PkgLen;
+
+
+    /* We expect some DEFAULT_ARGs, just ignore them */
+
+    if (Op->Asl.ParseOpcode == PARSEOP_DEFAULT_ARG)
+    {
+        return;
+    }
+
+    switch (Op->Asl.AmlOpcode)
+    {
+    case AML_UNASSIGNED_OPCODE:
+
+        /* These opcodes should not get here */
+
+        printf ("Found a node with an unassigned AML opcode\n");
+        FlPrintFile (ASL_FILE_STDERR,
+            "Found a node with an unassigned AML opcode\n");
+        return;
+
+    case AML_INT_RESERVEDFIELD_OP:
+
+        /* Special opcodes for within a field definition */
+
+        Aml.Opcode = AML_FIELD_OFFSET_OP;
+        break;
+
+    case AML_INT_ACCESSFIELD_OP:
+
+        Aml.Opcode = AML_FIELD_ACCESS_OP;
+        break;
+
+    case AML_INT_CONNECTION_OP:
+
+        Aml.Opcode = AML_FIELD_CONNECTION_OP;
+        break;
+
+    default:
+
+        Aml.Opcode = Op->Asl.AmlOpcode;
+        break;
+    }
+
+
+    switch (Aml.Opcode)
+    {
+    case AML_PACKAGE_LENGTH:
+
+        /* Value is the length to be encoded (Used in field definitions) */
+
+        PkgLen.Len = (UINT32) Op->Asl.Value.Integer;
+        break;
+
+    default:
+
+        /* Check for two-byte opcode */
+
+        if (Aml.Opcode > 0x00FF)
+        {
+            /* Write the high byte first */
+
+            CgLocalWriteAmlData (Op, &Aml.OpcodeBytes[1], 1);
+        }
+
+        CgLocalWriteAmlData (Op, &Aml.OpcodeBytes[0], 1);
+
+        /* Subtreelength doesn't include length of package length bytes */
+
+        PkgLen.Len = Op->Asl.AmlSubtreeLength + Op->Asl.AmlPkgLenBytes;
+        break;
+    }
+
+    /* Does this opcode have an associated "PackageLength" field? */
+
+    if (Op->Asl.CompileFlags & NODE_AML_PACKAGE)
+    {
+        if (Op->Asl.AmlPkgLenBytes == 1)
+        {
+            /* Simplest case -- no bytes to follow, just write the count */
+
+            CgLocalWriteAmlData (Op, &PkgLen.LenBytes[0], 1);
+        }
+        else if (Op->Asl.AmlPkgLenBytes != 0)
+        {
+            /*
+             * Encode the "bytes to follow" in the first byte, top two bits.
+             * The low-order nybble of the length is in the bottom 4 bits
+             */
+            PkgLenFirstByte = (UINT8)
+                (((UINT32) (Op->Asl.AmlPkgLenBytes - 1) << 6) |
+                (PkgLen.LenBytes[0] & 0x0F));
+
+            CgLocalWriteAmlData (Op, &PkgLenFirstByte, 1);
+
+            /*
+             * Shift the length over by the 4 bits we just stuffed
+             * in the first byte
+             */
+            PkgLen.Len >>= 4;
+
+            /*
+             * Now we can write the remaining bytes -
+             * either 1, 2, or 3 bytes
+             */
+            for (i = 0; i < (UINT32) (Op->Asl.AmlPkgLenBytes - 1); i++)
+            {
+                CgLocalWriteAmlData (Op, &PkgLen.LenBytes[i], 1);
+            }
+        }
+    }
+
+    switch (Aml.Opcode)
+    {
+    case AML_BYTE_OP:
+
+        CgLocalWriteAmlData (Op, &Op->Asl.Value.Integer, 1);
+        break;
+
+    case AML_WORD_OP:
+
+        CgLocalWriteAmlData (Op, &Op->Asl.Value.Integer, 2);
+       break;
+
+    case AML_DWORD_OP:
+
+        CgLocalWriteAmlData (Op, &Op->Asl.Value.Integer, 4);
+        break;
+
+    case AML_QWORD_OP:
+
+        CgLocalWriteAmlData (Op, &Op->Asl.Value.Integer, 8);
+        break;
+
+    case AML_STRING_OP:
+
+        CgLocalWriteAmlData (Op, Op->Asl.Value.String, Op->Asl.AmlLength);
+        break;
+
+    default:
+
+        /* All data opcodes must appear above */
+
+        break;
+    }
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    CgWriteTableHeader
+ *
+ * PARAMETERS:  Op        - The DEFINITIONBLOCK node
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Write a table header corresponding to the DEFINITIONBLOCK
+ *
+ ******************************************************************************/
+
+static void
+CgWriteTableHeader (
+    ACPI_PARSE_OBJECT       *Op)
+{
+    ACPI_PARSE_OBJECT       *Child;
+
+
+    /* AML filename */
+
+    Child = Op->Asl.Child;
+
+    /* Signature */
+
+    Child = Child->Asl.Next;
+    strncpy (TableHeader.Signature, Child->Asl.Value.String, 4);
+
+    /* Revision */
+
+    Child = Child->Asl.Next;
+    TableHeader.Revision = (UINT8) Child->Asl.Value.Integer;
+
+    /* Command-line Revision override */
+
+    if (Gbl_RevisionOverride)
+    {
+        TableHeader.Revision = Gbl_RevisionOverride;
+    }
+
+    /* OEMID */
+
+    Child = Child->Asl.Next;
+    strncpy (TableHeader.OemId, Child->Asl.Value.String, 6);
+
+    /* OEM TableID */
+
+    Child = Child->Asl.Next;
+    strncpy (TableHeader.OemTableId, Child->Asl.Value.String, 8);
+
+    /* OEM Revision */
+
+    Child = Child->Asl.Next;
+    TableHeader.OemRevision = (UINT32) Child->Asl.Value.Integer;
+
+    /* Compiler ID */
+
+    ACPI_MOVE_NAME (TableHeader.AslCompilerId, ASL_CREATOR_ID);
+
+    /* Compiler version */
+
+    TableHeader.AslCompilerRevision = ACPI_CA_VERSION;
+
+    /* Table length. Checksum zero for now, will rewrite later */
+
+    TableHeader.Length = sizeof (ACPI_TABLE_HEADER) +
+        Op->Asl.AmlSubtreeLength;
+    TableHeader.Checksum = 0;
+
+    Op->Asl.FinalAmlOffset = ftell (Gbl_Files[ASL_FILE_AML_OUTPUT].Handle);
+
+    /* Write entire header and clear the table header global */
+
+    CgLocalWriteAmlData (Op, &TableHeader, sizeof (ACPI_TABLE_HEADER));
+    memset (&TableHeader, 0, sizeof (ACPI_TABLE_HEADER));
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    CgUpdateHeader
+ *
+ * PARAMETERS:  Op                  - Op for the Definition Block
+ *
+ * RETURN:      None.
+ *
+ * DESCRIPTION: Complete the ACPI table by calculating the checksum and
+ *              re-writing the header for the input definition block
+ *
+ ******************************************************************************/
+
+static void
+CgUpdateHeader (
+    ACPI_PARSE_OBJECT   *Op)
+{
+    signed char         Sum;
+    UINT32              i;
+    UINT32              Length;
+    UINT8               FileByte;
+    UINT8               Checksum;
+
+
+    /* Calculate the checksum over the entire definition block */
+
+    Sum = 0;
+    Length = sizeof (ACPI_TABLE_HEADER) + Op->Asl.AmlSubtreeLength;
+    FlSeekFile (ASL_FILE_AML_OUTPUT, Op->Asl.FinalAmlOffset);
+
+    for (i = 0; i < Length; i++)
+    {
+        if (FlReadFile (ASL_FILE_AML_OUTPUT, &FileByte, 1) != AE_OK)
+        {
+            printf ("EOF while reading checksum bytes\n");
+            return;
+        }
+
+        Sum = (signed char) (Sum + FileByte);
+    }
+
+    Checksum = (UINT8) (0 - Sum);
+
+    /* Re-write the the checksum byte */
+
+    FlSeekFile (ASL_FILE_AML_OUTPUT, Op->Asl.FinalAmlOffset +
+        ACPI_OFFSET (ACPI_TABLE_HEADER, Checksum));
+
+    FlWriteFile (ASL_FILE_AML_OUTPUT, &Checksum, 1);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    CgCloseTable
+ *
+ * PARAMETERS:  None.
+ *
+ * RETURN:      None.
+ *
+ * DESCRIPTION: Complete the ACPI table by calculating the checksum and
+ *              re-writing each table header. This allows support for
+ *              multiple definition blocks in a single source file.
+ *
+ ******************************************************************************/
+
+static void
+CgCloseTable (
+    void)
+{
+    ACPI_PARSE_OBJECT   *Op;
+
+
+    /* Process all definition blocks */
+
+    Op = Gbl_ParseTreeRoot->Asl.Child;
+    while (Op)
+    {
+        CgUpdateHeader (Op);
+        Op = Op->Asl.Next;
+    }
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    CgWriteNode
+ *
+ * PARAMETERS:  Op            - Parse node to write.
+ *
+ * RETURN:      None.
+ *
+ * DESCRIPTION: Write the AML that corresponds to a parse node.
+ *
+ ******************************************************************************/
+
+static void
+CgWriteNode (
+    ACPI_PARSE_OBJECT       *Op)
+{
+    ASL_RESOURCE_NODE       *Rnode;
+
+
+    /* Always check for DEFAULT_ARG and other "Noop" nodes */
+    /* TBD: this may not be the best place for this check */
+
+    if ((Op->Asl.ParseOpcode == PARSEOP_DEFAULT_ARG)  ||
+        (Op->Asl.ParseOpcode == PARSEOP_INCLUDE)      ||
+        (Op->Asl.ParseOpcode == PARSEOP_INCLUDE_END))
+    {
+        return;
+    }
+
+    if ((Op->Asl.ParseOpcode == PARSEOP_EXTERNAL) &&
+        Gbl_DoExternals == FALSE)
+    {
+        return;
+    }
+
+    Op->Asl.FinalAmlLength = 0;
+
+    switch (Op->Asl.AmlOpcode)
+    {
+    case AML_RAW_DATA_BYTE:
+    case AML_RAW_DATA_WORD:
+    case AML_RAW_DATA_DWORD:
+    case AML_RAW_DATA_QWORD:
+
+        CgLocalWriteAmlData (Op, &Op->Asl.Value.Integer, Op->Asl.AmlLength);
+        return;
+
+
+    case AML_RAW_DATA_BUFFER:
+
+        CgLocalWriteAmlData (Op, Op->Asl.Value.Buffer, Op->Asl.AmlLength);
+        return;
+
+
+    case AML_RAW_DATA_CHAIN:
+
+        Rnode = ACPI_CAST_PTR (ASL_RESOURCE_NODE, Op->Asl.Value.Buffer);
+        while (Rnode)
+        {
+            CgLocalWriteAmlData (Op, Rnode->Buffer, Rnode->BufferLength);
+            Rnode = Rnode->Next;
+        }
+        return;
+
+    default:
+
+        /* Internal data opcodes must all appear above */
+
+        break;
+    }
+
+    switch (Op->Asl.ParseOpcode)
+    {
+    case PARSEOP_DEFAULT_ARG:
+
+        break;
+
+    case PARSEOP_DEFINITION_BLOCK:
+
+        CgWriteTableHeader (Op);
+        break;
+
+    case PARSEOP_NAMESEG:
+    case PARSEOP_NAMESTRING:
+    case PARSEOP_METHODCALL:
+
+        CgLocalWriteAmlData (Op, Op->Asl.Value.String, Op->Asl.AmlLength);
+        break;
+
+    default:
+
+        CgWriteAmlOpcode (Op);
+        break;
+    }
+}
diff --git a/usr/src/cmd/acpi/iasl/aslcompile.c b/usr/src/cmd/acpi/iasl/aslcompile.c
new file mode 100644
index 0000000000..ce070ef511
--- /dev/null
+++ b/usr/src/cmd/acpi/iasl/aslcompile.c
@@ -0,0 +1,867 @@
+/******************************************************************************
+ *
+ * Module Name: aslcompile - top level compile module
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2016, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include "aslcompiler.h"
+#include "dtcompiler.h"
+#include "acnamesp.h"
+
+#include <stdio.h>
+#include <time.h>
+#include <acapps.h>
+
+#define _COMPONENT          ACPI_COMPILER
+        ACPI_MODULE_NAME    ("aslcompile")
+
+/*
+ * Main parser entry
+ * External is here in case the parser emits the same external in the
+ * generated header. (Newer versions of Bison)
+ */
+int
+AslCompilerparse(
+    void);
+
+/* Local prototypes */
+
+static void
+CmFlushSourceCode (
+    void);
+
+static void
+CmDumpAllEvents (
+    void);
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    CmDoCompile
+ *
+ * PARAMETERS:  None
+ *
+ * RETURN:      Status (0 = OK)
+ *
+ * DESCRIPTION: This procedure performs the entire compile
+ *
+ ******************************************************************************/
+
+int
+CmDoCompile (
+    void)
+{
+    ACPI_STATUS             Status;
+    UINT8                   FullCompile;
+    UINT8                   Event;
+
+
+    FullCompile = UtBeginEvent ("*** Total Compile time ***");
+    Event = UtBeginEvent ("Open input and output files");
+    UtEndEvent (Event);
+
+    Event = UtBeginEvent ("Preprocess input file");
+    if (Gbl_PreprocessFlag)
+    {
+        /* Enter compiler name as a #define */
+
+        PrAddDefine (ASL_DEFINE, "", FALSE);
+
+        /* Preprocessor */
+
+        PrDoPreprocess ();
+        Gbl_CurrentLineNumber = 1;
+        Gbl_LogicalLineNumber = 1;
+
+        if (Gbl_PreprocessOnly)
+        {
+            UtEndEvent (Event);
+            CmCleanupAndExit ();
+            return (0);
+        }
+    }
+    UtEndEvent (Event);
+
+
+    /* Build the parse tree */
+
+    Event = UtBeginEvent ("Parse source code and build parse tree");
+    AslCompilerparse();
+    UtEndEvent (Event);
+
+    /* Check for parser-detected syntax errors */
+
+    if (Gbl_SyntaxError)
+    {
+        fprintf (stderr,
+            "Compiler aborting due to parser-detected syntax error(s)\n");
+        LsDumpParseTree ();
+        goto ErrorExit;
+    }
+
+    /* Did the parse tree get successfully constructed? */
+
+    if (!Gbl_ParseTreeRoot)
+    {
+        /*
+         * If there are no errors, then we have some sort of
+         * internal problem.
+         */
+        AslError (ASL_ERROR, ASL_MSG_COMPILER_INTERNAL,
+            NULL, "- Could not resolve parse tree root node");
+
+        goto ErrorExit;
+    }
+
+    /* Flush out any remaining source after parse tree is complete */
+
+    Event = UtBeginEvent ("Flush source input");
+    CmFlushSourceCode ();
+
+    /* Prune the parse tree if requested (debug purposes only) */
+
+    if (Gbl_PruneParseTree)
+    {
+        AslPruneParseTree (Gbl_PruneDepth, Gbl_PruneType);
+    }
+
+    /* Optional parse tree dump, compiler debug output only */
+
+    LsDumpParseTree ();
+
+    OpcGetIntegerWidth (Gbl_ParseTreeRoot->Asl.Child);
+    UtEndEvent (Event);
+
+    /* Pre-process parse tree for any operator transforms */
+
+    Event = UtBeginEvent ("Parse tree transforms");
+    DbgPrint (ASL_DEBUG_OUTPUT, "\nParse tree transforms\n\n");
+    TrWalkParseTree (Gbl_ParseTreeRoot, ASL_WALK_VISIT_TWICE,
+        TrAmlTransformWalkBegin, TrAmlTransformWalkEnd, NULL);
+    UtEndEvent (Event);
+
+    /* Generate AML opcodes corresponding to the parse tokens */
+
+    Event = UtBeginEvent ("Generate AML opcodes");
+    DbgPrint (ASL_DEBUG_OUTPUT, "Generating AML opcodes\n\n");
+    TrWalkParseTree (Gbl_ParseTreeRoot, ASL_WALK_VISIT_UPWARD, NULL,
+        OpcAmlOpcodeWalk, NULL);
+    UtEndEvent (Event);
+
+    /*
+     * Now that the input is parsed, we can open the AML output file.
+     * Note: by default, the name of this file comes from the table
+     * descriptor within the input file.
+     */
+    Event = UtBeginEvent ("Open AML output file");
+    Status = FlOpenAmlOutputFile (Gbl_OutputFilenamePrefix);
+    UtEndEvent (Event);
+    if (ACPI_FAILURE (Status))
+    {
+        AePrintErrorLog (ASL_FILE_STDERR);
+        return (-1);
+    }
+
+    /* Interpret and generate all compile-time constants */
+
+    Event = UtBeginEvent ("Constant folding via AML interpreter");
+    DbgPrint (ASL_DEBUG_OUTPUT,
+        "Interpreting compile-time constant expressions\n\n");
+
+    if (Gbl_FoldConstants)
+    {
+        TrWalkParseTree (Gbl_ParseTreeRoot, ASL_WALK_VISIT_UPWARD,
+            NULL, OpcAmlConstantWalk, NULL);
+    }
+    else
+    {
+        DbgPrint (ASL_PARSE_OUTPUT, "    Optional folding disabled\n");
+    }
+    UtEndEvent (Event);
+
+    /* Update AML opcodes if necessary, after constant folding */
+
+    Event = UtBeginEvent ("Updating AML opcodes after constant folding");
+    DbgPrint (ASL_DEBUG_OUTPUT,
+        "Updating AML opcodes after constant folding\n\n");
+    TrWalkParseTree (Gbl_ParseTreeRoot, ASL_WALK_VISIT_UPWARD,
+        NULL, OpcAmlOpcodeUpdateWalk, NULL);
+    UtEndEvent (Event);
+
+    /* Calculate all AML package lengths */
+
+    Event = UtBeginEvent ("Generate AML package lengths");
+    DbgPrint (ASL_DEBUG_OUTPUT, "Generating Package lengths\n\n");
+    TrWalkParseTree (Gbl_ParseTreeRoot, ASL_WALK_VISIT_UPWARD, NULL,
+        LnPackageLengthWalk, NULL);
+    UtEndEvent (Event);
+
+    if (Gbl_ParseOnlyFlag)
+    {
+        AePrintErrorLog (ASL_FILE_STDERR);
+        UtDisplaySummary (ASL_FILE_STDERR);
+        if (Gbl_DebugFlag)
+        {
+            /* Print error summary to the stdout also */
+
+            AePrintErrorLog (ASL_FILE_STDOUT);
+            UtDisplaySummary (ASL_FILE_STDOUT);
+        }
+        UtEndEvent (FullCompile);
+        return (0);
+    }
+
+    /*
+     * Create an internal namespace and use it as a symbol table
+     */
+
+    /* Namespace loading */
+
+    Event = UtBeginEvent ("Create ACPI Namespace");
+    DbgPrint (ASL_DEBUG_OUTPUT, "Creating ACPI Namespace\n\n");
+    Status = LdLoadNamespace (Gbl_ParseTreeRoot);
+    UtEndEvent (Event);
+    if (ACPI_FAILURE (Status))
+    {
+        goto ErrorExit;
+    }
+
+    /* Namespace cross-reference */
+
+    AslGbl_NamespaceEvent = UtBeginEvent (
+        "Cross reference parse tree and Namespace");
+    DbgPrint (ASL_DEBUG_OUTPUT, "Cross referencing namespace\n\n");
+    Status = XfCrossReferenceNamespace ();
+    if (ACPI_FAILURE (Status))
+    {
+        goto ErrorExit;
+    }
+
+    /* Namespace - Check for non-referenced objects */
+
+    LkFindUnreferencedObjects ();
+    UtEndEvent (AslGbl_NamespaceEvent);
+
+    /* Resolve External Declarations */
+
+    if (Gbl_DoExternals)
+    {
+        Event = UtBeginEvent ("Resolve all Externals");
+        DbgPrint (ASL_DEBUG_OUTPUT, "\nResolve Externals\n\n");
+        TrWalkParseTree (Gbl_ParseTreeRoot, ASL_WALK_VISIT_TWICE,
+            ExAmlExternalWalkBegin, ExAmlExternalWalkEnd, NULL);
+        UtEndEvent (Event);
+    }
+
+    /*
+     * Semantic analysis. This can happen only after the
+     * namespace has been loaded and cross-referenced.
+     *
+     * part one - check control methods
+     */
+    Event = UtBeginEvent ("Analyze control method return types");
+    AnalysisWalkInfo.MethodStack = NULL;
+
+    DbgPrint (ASL_DEBUG_OUTPUT, "Semantic analysis - Method analysis\n\n");
+
+    if (Gbl_CrossReferenceOutput)
+    {
+        OtPrintHeaders ("Part 1: Object Reference Map "
+            "(Object references from within each control method)");
+    }
+
+    TrWalkParseTree (Gbl_ParseTreeRoot, ASL_WALK_VISIT_TWICE,
+        MtMethodAnalysisWalkBegin,
+        MtMethodAnalysisWalkEnd, &AnalysisWalkInfo);
+    UtEndEvent (Event);
+
+    /* Generate the object cross-reference file if requested */
+
+    Event = UtBeginEvent ("Generate cross-reference file");
+    OtCreateXrefFile ();
+    UtEndEvent (Event);
+
+    /* Semantic error checking part two - typing of method returns */
+
+    Event = UtBeginEvent ("Determine object types returned by methods");
+    DbgPrint (ASL_DEBUG_OUTPUT, "Semantic analysis - Method typing\n\n");
+    TrWalkParseTree (Gbl_ParseTreeRoot, ASL_WALK_VISIT_UPWARD,
+        NULL, AnMethodTypingWalkEnd, NULL);
+    UtEndEvent (Event);
+
+    /* Semantic error checking part three - operand type checking */
+
+    Event = UtBeginEvent ("Analyze AML operand types");
+    DbgPrint (ASL_DEBUG_OUTPUT,
+        "Semantic analysis - Operand type checking\n\n");
+    if (Gbl_DoTypechecking)
+    {
+        TrWalkParseTree (Gbl_ParseTreeRoot, ASL_WALK_VISIT_UPWARD,
+            NULL, AnOperandTypecheckWalkEnd, &AnalysisWalkInfo);
+    }
+    UtEndEvent (Event);
+
+    /* Semantic error checking part four - other miscellaneous checks */
+
+    Event = UtBeginEvent ("Miscellaneous analysis");
+    DbgPrint (ASL_DEBUG_OUTPUT, "Semantic analysis - miscellaneous\n\n");
+    TrWalkParseTree (Gbl_ParseTreeRoot, ASL_WALK_VISIT_DOWNWARD,
+        AnOtherSemanticAnalysisWalkBegin,
+        NULL, &AnalysisWalkInfo);
+    UtEndEvent (Event);
+
+    /* Calculate all AML package lengths */
+
+    Event = UtBeginEvent ("Finish AML package length generation");
+    DbgPrint (ASL_DEBUG_OUTPUT, "Generating Package lengths\n\n");
+    TrWalkParseTree (Gbl_ParseTreeRoot, ASL_WALK_VISIT_UPWARD, NULL,
+        LnInitLengthsWalk, NULL);
+    TrWalkParseTree (Gbl_ParseTreeRoot, ASL_WALK_VISIT_UPWARD, NULL,
+        LnPackageLengthWalk, NULL);
+    UtEndEvent (Event);
+
+    /* Code generation - emit the AML */
+
+    Event = UtBeginEvent ("Generate AML code and write output files");
+    DbgPrint (ASL_DEBUG_OUTPUT, "Writing AML byte code\n\n");
+    CgGenerateAmlOutput ();
+    UtEndEvent (Event);
+
+    Event = UtBeginEvent ("Write optional output files");
+    CmDoOutputFiles ();
+    UtEndEvent (Event);
+
+    UtEndEvent (FullCompile);
+    CmCleanupAndExit ();
+    return (0);
+
+ErrorExit:
+    UtEndEvent (FullCompile);
+    CmCleanupAndExit ();
+    return (-1);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AslCompilerSignon
+ *
+ * PARAMETERS:  FileId      - ID of the output file
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Display compiler signon
+ *
+ ******************************************************************************/
+
+void
+AslCompilerSignon (
+    UINT32                  FileId)
+{
+    char                    *Prefix = "";
+    char                    *UtilityName;
+
+
+    /* Set line prefix depending on the destination file type */
+
+    switch (FileId)
+    {
+    case ASL_FILE_ASM_SOURCE_OUTPUT:
+    case ASL_FILE_ASM_INCLUDE_OUTPUT:
+
+        Prefix = "; ";
+        break;
+
+    case ASL_FILE_HEX_OUTPUT:
+
+        if (Gbl_HexOutputFlag == HEX_OUTPUT_ASM)
+        {
+            Prefix = "; ";
+        }
+        else if ((Gbl_HexOutputFlag == HEX_OUTPUT_C) ||
+                 (Gbl_HexOutputFlag == HEX_OUTPUT_ASL))
+        {
+            FlPrintFile (ASL_FILE_HEX_OUTPUT, "/*\n");
+            Prefix = " * ";
+        }
+        break;
+
+    case ASL_FILE_C_SOURCE_OUTPUT:
+    case ASL_FILE_C_OFFSET_OUTPUT:
+    case ASL_FILE_C_INCLUDE_OUTPUT:
+
+        Prefix = " * ";
+        break;
+
+    default:
+
+        /* No other output types supported */
+
+        break;
+    }
+
+    /* Running compiler or disassembler? */
+
+    if (Gbl_DisasmFlag)
+    {
+        UtilityName = AML_DISASSEMBLER_NAME;
+    }
+    else
+    {
+        UtilityName = ASL_COMPILER_NAME;
+    }
+
+    /* Compiler signon with copyright */
+
+    FlPrintFile (FileId, "%s\n", Prefix);
+    FlPrintFile (FileId, ACPI_COMMON_HEADER (UtilityName, Prefix));
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AslCompilerFileHeader
+ *
+ * PARAMETERS:  FileId      - ID of the output file
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Header used at the beginning of output files
+ *
+ ******************************************************************************/
+
+void
+AslCompilerFileHeader (
+    UINT32                  FileId)
+{
+    struct tm               *NewTime;
+    time_t                  Aclock;
+    char                    *Prefix = "";
+
+
+    /* Set line prefix depending on the destination file type */
+
+    switch (FileId)
+    {
+    case ASL_FILE_ASM_SOURCE_OUTPUT:
+    case ASL_FILE_ASM_INCLUDE_OUTPUT:
+
+        Prefix = "; ";
+        break;
+
+    case ASL_FILE_HEX_OUTPUT:
+
+        if (Gbl_HexOutputFlag == HEX_OUTPUT_ASM)
+        {
+            Prefix = "; ";
+        }
+        else if ((Gbl_HexOutputFlag == HEX_OUTPUT_C) ||
+                 (Gbl_HexOutputFlag == HEX_OUTPUT_ASL))
+        {
+            Prefix = " * ";
+        }
+        break;
+
+    case ASL_FILE_C_SOURCE_OUTPUT:
+    case ASL_FILE_C_OFFSET_OUTPUT:
+    case ASL_FILE_C_INCLUDE_OUTPUT:
+
+        Prefix = " * ";
+        break;
+
+    default:
+
+        /* No other output types supported */
+
+        break;
+    }
+
+    /* Compilation header with timestamp */
+
+    (void) time (&Aclock);
+    NewTime = localtime (&Aclock);
+
+    FlPrintFile (FileId,
+        "%sCompilation of \"%s\" - %s%s\n",
+        Prefix, Gbl_Files[ASL_FILE_INPUT].Filename, asctime (NewTime),
+        Prefix);
+
+    switch (FileId)
+    {
+    case ASL_FILE_C_SOURCE_OUTPUT:
+    case ASL_FILE_C_OFFSET_OUTPUT:
+    case ASL_FILE_C_INCLUDE_OUTPUT:
+
+        FlPrintFile (FileId, " */\n");
+        break;
+
+    default:
+
+        /* Nothing to do for other output types */
+
+        break;
+    }
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    CmFlushSourceCode
+ *
+ * PARAMETERS:  None
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Read in any remaining source code after the parse tree
+ *              has been constructed.
+ *
+ ******************************************************************************/
+
+static void
+CmFlushSourceCode (
+    void)
+{
+    char                    Buffer;
+
+
+    while (FlReadFile (ASL_FILE_INPUT, &Buffer, 1) != AE_ERROR)
+    {
+        AslInsertLineBuffer ((int) Buffer);
+    }
+
+    AslResetCurrentLineBuffer ();
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    CmDoOutputFiles
+ *
+ * PARAMETERS:  None
+ *
+ * RETURN:      None.
+ *
+ * DESCRIPTION: Create all "listing" type files
+ *
+ ******************************************************************************/
+
+void
+CmDoOutputFiles (
+    void)
+{
+
+    /* Create listings and hex files */
+
+    LsDoListings ();
+    HxDoHexOutput ();
+
+    /* Dump the namespace to the .nsp file if requested */
+
+    (void) NsDisplayNamespace ();
+
+    /* Dump the device mapping file */
+
+    MpEmitMappingInfo ();
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    CmDumpAllEvents
+ *
+ * PARAMETERS:  None
+ *
+ * RETURN:      None.
+ *
+ * DESCRIPTION: Dump all compiler events
+ *
+ ******************************************************************************/
+
+static void
+CmDumpAllEvents (
+    void)
+{
+    ASL_EVENT_INFO          *Event;
+    UINT32                  Delta;
+    UINT32                  MicroSeconds;
+    UINT32                  MilliSeconds;
+    UINT32                  i;
+
+
+    Event = AslGbl_Events;
+
+    DbgPrint (ASL_DEBUG_OUTPUT, "\n\nElapsed time for major events\n\n");
+    if (Gbl_CompileTimesFlag)
+    {
+        printf ("\nElapsed time for major events\n\n");
+    }
+
+    for (i = 0; i < AslGbl_NextEvent; i++)
+    {
+        if (Event->Valid)
+        {
+            /* Delta will be in 100-nanosecond units */
+
+            Delta = (UINT32) (Event->EndTime - Event->StartTime);
+
+            MicroSeconds = Delta / ACPI_100NSEC_PER_USEC;
+            MilliSeconds = Delta / ACPI_100NSEC_PER_MSEC;
+
+            /* Round milliseconds up */
+
+            if ((MicroSeconds - (MilliSeconds * ACPI_USEC_PER_MSEC)) >= 500)
+            {
+                MilliSeconds++;
+            }
+
+            DbgPrint (ASL_DEBUG_OUTPUT, "%8u usec %8u msec - %s\n",
+                MicroSeconds, MilliSeconds, Event->EventName);
+
+            if (Gbl_CompileTimesFlag)
+            {
+                printf ("%8u usec %8u msec - %s\n",
+                    MicroSeconds, MilliSeconds, Event->EventName);
+            }
+        }
+
+        Event++;
+    }
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    CmCleanupAndExit
+ *
+ * PARAMETERS:  None
+ *
+ * RETURN:      None.
+ *
+ * DESCRIPTION: Close all open files and exit the compiler
+ *
+ ******************************************************************************/
+
+void
+CmCleanupAndExit (
+    void)
+{
+    UINT32                  i;
+    BOOLEAN                 DeleteAmlFile = FALSE;
+
+
+    AePrintErrorLog (ASL_FILE_STDERR);
+    if (Gbl_DebugFlag)
+    {
+        /* Print error summary to stdout also */
+
+        AePrintErrorLog (ASL_FILE_STDOUT);
+    }
+
+    /* Emit compile times if enabled */
+
+    CmDumpAllEvents ();
+
+    if (Gbl_CompileTimesFlag)
+    {
+        printf ("\nMiscellaneous compile statistics\n\n");
+        printf ("%11u : %s\n", TotalParseNodes, "Parse nodes");
+        printf ("%11u : %s\n", Gbl_NsLookupCount, "Namespace searches");
+        printf ("%11u : %s\n", TotalNamedObjects, "Named objects");
+        printf ("%11u : %s\n", TotalMethods, "Control methods");
+        printf ("%11u : %s\n", TotalAllocations, "Memory Allocations");
+        printf ("%11u : %s\n", TotalAllocated, "Total allocated memory");
+        printf ("%11u : %s\n", TotalFolds, "Constant subtrees folded");
+        printf ("\n");
+    }
+
+    if (Gbl_NsLookupCount)
+    {
+        DbgPrint (ASL_DEBUG_OUTPUT,
+            "\n\nMiscellaneous compile statistics\n\n");
+
+        DbgPrint (ASL_DEBUG_OUTPUT,
+            "%32s : %u\n", "Total Namespace searches",
+            Gbl_NsLookupCount);
+
+        DbgPrint (ASL_DEBUG_OUTPUT,
+            "%32s : %u usec\n", "Time per search", ((UINT32)
+            (AslGbl_Events[AslGbl_NamespaceEvent].EndTime -
+                AslGbl_Events[AslGbl_NamespaceEvent].StartTime) / 10) /
+                Gbl_NsLookupCount);
+    }
+
+    if (Gbl_ExceptionCount[ASL_ERROR] > ASL_MAX_ERROR_COUNT)
+    {
+        printf ("\nMaximum error count (%u) exceeded\n",
+            ASL_MAX_ERROR_COUNT);
+    }
+
+    UtDisplaySummary (ASL_FILE_STDOUT);
+
+    /*
+     * We will delete the AML file if there are errors and the
+     * force AML output option has not been used.
+     */
+    if ((Gbl_ExceptionCount[ASL_ERROR] > 0) &&
+        (!Gbl_IgnoreErrors) &&
+        Gbl_Files[ASL_FILE_AML_OUTPUT].Handle)
+    {
+        DeleteAmlFile = TRUE;
+    }
+
+    /* Close all open files */
+
+    /*
+     * Take care with the preprocessor file (.pre), it might be the same
+     * as the "input" file, depending on where the compiler has terminated
+     * or aborted. Prevent attempt to close the same file twice in
+     * loop below.
+     */
+    if (Gbl_Files[ASL_FILE_PREPROCESSOR].Handle ==
+        Gbl_Files[ASL_FILE_INPUT].Handle)
+    {
+        Gbl_Files[ASL_FILE_PREPROCESSOR].Handle = NULL;
+    }
+
+    /* Close the standard I/O files */
+
+    for (i = ASL_FILE_INPUT; i < ASL_MAX_FILE_TYPE; i++)
+    {
+        FlCloseFile (i);
+    }
+
+    /* Delete AML file if there are errors */
+
+    if (DeleteAmlFile)
+    {
+        FlDeleteFile (ASL_FILE_AML_OUTPUT);
+    }
+
+    /* Delete the preprocessor temp file unless full debug was specified */
+
+    if (Gbl_PreprocessFlag && !Gbl_KeepPreprocessorTempFile)
+    {
+        FlDeleteFile (ASL_FILE_PREPROCESSOR);
+    }
+
+    /*
+     * Delete intermediate ("combined") source file (if -ls flag not set)
+     * This file is created during normal ASL/AML compiles. It is not
+     * created by the data table compiler.
+     *
+     * If the -ls flag is set, then the .SRC file should not be deleted.
+     * In this case, Gbl_SourceOutputFlag is set to TRUE.
+     *
+     * Note: Handles are cleared by FlCloseFile above, so we look at the
+     * filename instead, to determine if the .SRC file was actually
+     * created.
+     */
+    if (!Gbl_SourceOutputFlag)
+    {
+        FlDeleteFile (ASL_FILE_SOURCE_OUTPUT);
+    }
+
+    /* Final cleanup after compiling one file */
+
+    CmDeleteCaches ();
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    CmDeleteCaches
+ *
+ * PARAMETERS:  None
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Delete all local cache buffer blocks
+ *
+ ******************************************************************************/
+
+void
+CmDeleteCaches (
+    void)
+{
+    UINT32                  BufferCount;
+    ASL_CACHE_INFO          *Next;
+
+
+    /* Parse Op cache */
+
+    BufferCount = 0;
+    while (Gbl_ParseOpCacheList)
+    {
+        Next = Gbl_ParseOpCacheList->Next;
+        ACPI_FREE (Gbl_ParseOpCacheList);
+        Gbl_ParseOpCacheList = Next;
+        BufferCount++;
+    }
+
+    DbgPrint (ASL_DEBUG_OUTPUT,
+        "%u ParseOps, Buffer size: %u ops (%u bytes), %u Buffers\n",
+        Gbl_ParseOpCount, ASL_PARSEOP_CACHE_SIZE,
+        (sizeof (ACPI_PARSE_OBJECT) * ASL_PARSEOP_CACHE_SIZE), BufferCount);
+
+    Gbl_ParseOpCount = 0;
+    Gbl_ParseOpCacheNext = NULL;
+    Gbl_ParseOpCacheLast = NULL;
+    Gbl_ParseTreeRoot = NULL;
+
+    /* Generic string cache */
+
+    BufferCount = 0;
+    while (Gbl_StringCacheList)
+    {
+        Next = Gbl_StringCacheList->Next;
+        ACPI_FREE (Gbl_StringCacheList);
+        Gbl_StringCacheList = Next;
+        BufferCount++;
+    }
+
+    DbgPrint (ASL_DEBUG_OUTPUT,
+        "%u Strings (%u bytes), Buffer size: %u bytes, %u Buffers\n",
+        Gbl_StringCount, Gbl_StringSize, ASL_STRING_CACHE_SIZE, BufferCount);
+
+    Gbl_StringSize = 0;
+    Gbl_StringCount = 0;
+    Gbl_StringCacheNext = NULL;
+    Gbl_StringCacheLast = NULL;
+}
diff --git a/usr/src/cmd/acpi/iasl/aslcompiler.h b/usr/src/cmd/acpi/iasl/aslcompiler.h
new file mode 100644
index 0000000000..b34686325f
--- /dev/null
+++ b/usr/src/cmd/acpi/iasl/aslcompiler.h
@@ -0,0 +1,1359 @@
+/******************************************************************************
+ *
+ * Module Name: aslcompiler.h - common include file for iASL
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2016, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#ifndef __ASLCOMPILER_H
+#define __ASLCOMPILER_H
+
+#include "acpi.h"
+#include "accommon.h"
+#include "amlresrc.h"
+#include "acdebug.h"
+
+/* Microsoft-specific */
+
+#if (defined WIN32 || defined WIN64)
+
+/* warn : used #pragma pack */
+#pragma warning(disable:4103)
+
+/* warn : named type definition in parentheses */
+#pragma warning(disable:4115)
+#endif
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdarg.h>
+#include <string.h>
+#include <errno.h>
+#include <ctype.h>
+
+/* Compiler headers */
+
+#include "asldefine.h"
+#include "asltypes.h"
+#include "aslmessages.h"
+#include "aslglobal.h"
+#include "preprocess.h"
+
+
+/*******************************************************************************
+ *
+ * Compiler prototypes
+ *
+ ******************************************************************************/
+
+/*
+ * Main ASL parser - generated from flex/bison, lex/yacc, etc.
+ */
+ACPI_PARSE_OBJECT *
+AslDoError (
+    void);
+
+int
+AslCompilerlex(
+    void);
+
+void
+AslResetCurrentLineBuffer (
+    void);
+
+void
+AslInsertLineBuffer (
+    int                     SourceChar);
+
+int
+AslPopInputFileStack (
+    void);
+
+void
+AslPushInputFileStack (
+    FILE                    *InputFile,
+    char                    *Filename);
+
+void
+AslParserCleanup (
+    void);
+
+
+/*
+ * aslstartup - entered from main()
+ */
+void
+AslInitializeGlobals (
+    void);
+
+typedef
+ACPI_STATUS (*ASL_PATHNAME_CALLBACK) (
+    char *);
+
+ACPI_STATUS
+AslDoOneFile (
+    char                    *Filename);
+
+ACPI_STATUS
+AslCheckForErrorExit (
+    void);
+
+
+/*
+ * aslcompile - compile mainline
+ */
+void
+AslCompilerSignon (
+    UINT32                  FileId);
+
+void
+AslCompilerFileHeader (
+    UINT32                  FileId);
+
+int
+CmDoCompile (
+    void);
+
+void
+CmDoOutputFiles (
+    void);
+
+void
+CmCleanupAndExit (
+    void);
+
+void
+CmDeleteCaches (
+    void);
+
+
+/*
+ * aslascii - ascii support
+ */
+ACPI_STATUS
+FlIsFileAsciiSource (
+    char                    *Filename,
+    BOOLEAN                 DisplayErrors);
+
+
+/*
+ * aslwalks - semantic analysis and parse tree walks
+ */
+ACPI_STATUS
+AnOtherSemanticAnalysisWalkBegin (
+    ACPI_PARSE_OBJECT       *Op,
+    UINT32                  Level,
+    void                    *Context);
+
+ACPI_STATUS
+AnOtherSemanticAnalysisWalkEnd (
+    ACPI_PARSE_OBJECT       *Op,
+    UINT32                  Level,
+    void                    *Context);
+
+ACPI_STATUS
+AnOperandTypecheckWalkEnd (
+    ACPI_PARSE_OBJECT       *Op,
+    UINT32                  Level,
+    void                    *Context);
+
+ACPI_STATUS
+AnMethodTypingWalkEnd (
+    ACPI_PARSE_OBJECT       *Op,
+    UINT32                  Level,
+    void                    *Context);
+
+
+/*
+ * aslmethod - Control method analysis walk
+ */
+ACPI_STATUS
+MtMethodAnalysisWalkBegin (
+    ACPI_PARSE_OBJECT       *Op,
+    UINT32                  Level,
+    void                    *Context);
+
+ACPI_STATUS
+MtMethodAnalysisWalkEnd (
+    ACPI_PARSE_OBJECT       *Op,
+    UINT32                  Level,
+    void                    *Context);
+
+
+/*
+ * aslbtypes - bitfield data types
+ */
+UINT32
+AnMapObjTypeToBtype (
+    ACPI_PARSE_OBJECT       *Op);
+
+UINT32
+AnMapArgTypeToBtype (
+    UINT32                  ArgType);
+
+UINT32
+AnGetBtype (
+    ACPI_PARSE_OBJECT       *Op);
+
+void
+AnFormatBtype (
+    char                    *Buffer,
+    UINT32                  Btype);
+
+
+/*
+ * aslanalyze - Support functions for parse tree walks
+ */
+void
+AnCheckId (
+    ACPI_PARSE_OBJECT       *Op,
+    ACPI_NAME               Type);
+
+/* Values for Type argument above */
+
+#define ASL_TYPE_HID        0
+#define ASL_TYPE_CID        1
+
+BOOLEAN
+AnIsInternalMethod (
+    ACPI_PARSE_OBJECT       *Op);
+
+UINT32
+AnGetInternalMethodReturnType (
+    ACPI_PARSE_OBJECT       *Op);
+
+BOOLEAN
+AnLastStatementIsReturn (
+    ACPI_PARSE_OBJECT       *Op);
+
+void
+AnCheckMethodReturnValue (
+    ACPI_PARSE_OBJECT       *Op,
+    const ACPI_OPCODE_INFO  *OpInfo,
+    ACPI_PARSE_OBJECT       *ArgOp,
+    UINT32                  RequiredBtypes,
+    UINT32                  ThisNodeBtype);
+
+BOOLEAN
+AnIsResultUsed (
+    ACPI_PARSE_OBJECT       *Op);
+
+void
+ApCheckForGpeNameConflict (
+    ACPI_PARSE_OBJECT       *Op);
+
+void
+ApCheckRegMethod (
+    ACPI_PARSE_OBJECT       *Op);
+
+BOOLEAN
+ApFindNameInScope (
+    char                    *Name,
+    ACPI_PARSE_OBJECT       *Op);
+
+BOOLEAN
+ApFindNameInDeviceTree (
+    char                    *Name,
+    ACPI_PARSE_OBJECT       *Op);
+
+/*
+ * aslerror - error handling/reporting
+ */
+void
+AslAbort (
+    void);
+
+void
+AslError (
+    UINT8                   Level,
+    UINT16                  MessageId,
+    ACPI_PARSE_OBJECT       *Op,
+    char                    *ExtraMessage);
+
+ACPI_STATUS
+AslDisableException (
+    char                    *MessageIdString);
+
+BOOLEAN
+AslIsExceptionDisabled (
+    UINT8                   Level,
+    UINT16                  MessageId);
+
+void
+AslCoreSubsystemError (
+    ACPI_PARSE_OBJECT       *Op,
+    ACPI_STATUS             Status,
+    char                    *ExtraMessage,
+    BOOLEAN                 Abort);
+
+int
+AslCompilererror(
+    const char              *s);
+
+void
+AslCommonError (
+    UINT8                   Level,
+    UINT16                  MessageId,
+    UINT32                  CurrentLineNumber,
+    UINT32                  LogicalLineNumber,
+    UINT32                  LogicalByteOffset,
+    UINT32                  Column,
+    char                    *Filename,
+    char                    *ExtraMessage);
+
+void
+AslCommonError2 (
+    UINT8                   Level,
+    UINT16                  MessageId,
+    UINT32                  LineNumber,
+    UINT32                  Column,
+    char                    *SourceLine,
+    char                    *Filename,
+    char                    *ExtraMessage);
+
+void
+AePrintException (
+    UINT32                  FileId,
+    ASL_ERROR_MSG           *Enode,
+    char                    *Header);
+
+void
+AePrintErrorLog (
+    UINT32                  FileId);
+
+void
+AeClearErrorLog (
+    void);
+
+
+/*
+ * asllisting - generate all "listing" type files
+ */
+void
+LsDoListings (
+    void);
+
+void
+LsWriteNodeToAsmListing (
+    ACPI_PARSE_OBJECT       *Op);
+
+void
+LsWriteNode (
+    ACPI_PARSE_OBJECT       *Op,
+    UINT32                  FileId);
+
+void
+LsDumpParseTree (
+    void);
+
+
+/*
+ * asllistsup - Listing file support utilities
+ */
+void
+LsDumpAscii (
+    UINT32                  FileId,
+    UINT32                  Count,
+    UINT8                   *Buffer);
+
+void
+LsDumpAsciiInComment (
+    UINT32                  FileId,
+    UINT32                  Count,
+    UINT8                   *Buffer);
+
+void
+LsCheckException (
+    UINT32                  LineNumber,
+    UINT32                  FileId);
+
+void
+LsFlushListingBuffer (
+    UINT32                  FileId);
+
+void
+LsWriteListingHexBytes (
+    UINT8                   *Buffer,
+    UINT32                  Length,
+    UINT32                  FileId);
+
+void
+LsWriteSourceLines (
+    UINT32                  ToLineNumber,
+    UINT32                  ToLogicalLineNumber,
+    UINT32                  FileId);
+
+UINT32
+LsWriteOneSourceLine (
+    UINT32                  FileId);
+
+void
+LsPushNode (
+    char                    *Filename);
+
+ASL_LISTING_NODE *
+LsPopNode (
+    void);
+
+
+/*
+ * aslhex - generate all "hex" output files (C, ASM, ASL)
+ */
+void
+HxDoHexOutput (
+    void);
+
+
+/*
+ * aslfold - constant folding
+ */
+ACPI_STATUS
+OpcAmlConstantWalk (
+    ACPI_PARSE_OBJECT       *Op,
+    UINT32                  Level,
+    void                    *Context);
+
+
+/*
+ * aslmessages - exception strings
+ */
+const char *
+AeDecodeMessageId (
+    UINT16                  MessageId);
+
+const char *
+AeDecodeExceptionLevel (
+    UINT8                   Level);
+
+UINT16
+AeBuildFullExceptionCode (
+    UINT8                   Level,
+    UINT16                  MessageId);
+
+/*
+ * asloffset - generate C offset file for BIOS support
+ */
+ACPI_STATUS
+LsAmlOffsetWalk (
+    ACPI_PARSE_OBJECT       *Op,
+    UINT32                  Level,
+    void                    *Context);
+
+void
+LsDoOffsetTableHeader (
+    UINT32                  FileId);
+
+void
+LsDoOffsetTableFooter (
+    UINT32                  FileId);
+
+
+/*
+ * aslopcodes - generate AML opcodes
+ */
+ACPI_STATUS
+OpcAmlOpcodeWalk (
+    ACPI_PARSE_OBJECT       *Op,
+    UINT32                  Level,
+    void                    *Context);
+
+ACPI_STATUS
+OpcAmlOpcodeUpdateWalk (
+    ACPI_PARSE_OBJECT       *Op,
+    UINT32                  Level,
+    void                    *Context);
+
+void
+OpcGenerateAmlOpcode (
+    ACPI_PARSE_OBJECT       *Op);
+
+UINT32
+OpcSetOptimalIntegerSize (
+    ACPI_PARSE_OBJECT       *Op);
+
+void
+OpcGetIntegerWidth (
+    ACPI_PARSE_OBJECT       *Op);
+
+
+/*
+ * asloperands - generate AML operands for the AML opcodes
+ */
+ACPI_PARSE_OBJECT  *
+UtGetArg (
+    ACPI_PARSE_OBJECT       *Op,
+    UINT32                  Argn);
+
+void
+OpnGenerateAmlOperands (
+    ACPI_PARSE_OBJECT       *Op);
+
+void
+OpnDoPackage (
+    ACPI_PARSE_OBJECT       *Op);
+
+
+/*
+ * aslopt - optmization
+ */
+void
+OptOptimizeNamePath (
+    ACPI_PARSE_OBJECT       *Op,
+    UINT32                  Flags,
+    ACPI_WALK_STATE         *WalkState,
+    char                    *AmlNameString,
+    ACPI_NAMESPACE_NODE     *TargetNode);
+
+
+/*
+ * aslpld - ToPLD macro support
+ */
+void
+OpcDoPld (
+    ACPI_PARSE_OBJECT       *Op);
+
+
+/*
+ * aslprintf - Printf/Fprintf macros
+ */
+void
+OpcDoPrintf (
+    ACPI_PARSE_OBJECT       *Op);
+
+void
+OpcDoFprintf (
+    ACPI_PARSE_OBJECT       *Op);
+
+
+/*
+ * aslprune - parse tree pruner
+ */
+void
+AslPruneParseTree (
+    UINT32                  PruneDepth,
+    UINT32                  Type);
+
+
+/*
+ * aslcodegen - code generation
+ */
+void
+CgGenerateAmlOutput (
+    void);
+
+
+/*
+ * aslfile
+ */
+void
+FlOpenFile (
+    UINT32                  FileId,
+    char                    *Filename,
+    char                    *Mode);
+
+
+/*
+ * asllength - calculate/adjust AML package lengths
+ */
+ACPI_STATUS
+LnPackageLengthWalk (
+    ACPI_PARSE_OBJECT       *Op,
+    UINT32                  Level,
+    void                    *Context);
+
+ACPI_STATUS
+LnInitLengthsWalk (
+    ACPI_PARSE_OBJECT       *Op,
+    UINT32                  Level,
+    void                    *Context);
+
+void
+CgGenerateAmlLengths (
+    ACPI_PARSE_OBJECT       *Op);
+
+
+/*
+ * aslmap - opcode mappings and reserved method names
+ */
+ACPI_OBJECT_TYPE
+AslMapNamedOpcodeToDataType (
+    UINT16                  Opcode);
+
+
+/*
+ * aslpredef - ACPI predefined names support
+ */
+BOOLEAN
+ApCheckForPredefinedMethod (
+    ACPI_PARSE_OBJECT       *Op,
+    ASL_METHOD_INFO         *MethodInfo);
+
+void
+ApCheckPredefinedReturnValue (
+    ACPI_PARSE_OBJECT       *Op,
+    ASL_METHOD_INFO         *MethodInfo);
+
+UINT32
+ApCheckForPredefinedName (
+    ACPI_PARSE_OBJECT       *Op,
+    char                    *Name);
+
+void
+ApCheckForPredefinedObject (
+    ACPI_PARSE_OBJECT       *Op,
+    char                    *Name);
+
+ACPI_STATUS
+ApCheckObjectType (
+    const char              *PredefinedName,
+    ACPI_PARSE_OBJECT       *Op,
+    UINT32                  ExpectedBtypes,
+    UINT32                  PackageIndex);
+
+void
+ApDisplayReservedNames (
+    void);
+
+
+/*
+ * aslprepkg - ACPI predefined names support for packages
+ */
+void
+ApCheckPackage (
+    ACPI_PARSE_OBJECT           *ParentOp,
+    const ACPI_PREDEFINED_INFO  *Predefined);
+
+
+/*
+ * asltransform - parse tree transformations
+ */
+ACPI_STATUS
+TrAmlTransformWalkBegin (
+    ACPI_PARSE_OBJECT       *Op,
+    UINT32                  Level,
+    void                    *Context);
+
+ACPI_STATUS
+TrAmlTransformWalkEnd (
+    ACPI_PARSE_OBJECT       *Op,
+    UINT32                  Level,
+    void                    *Context);
+
+
+/*
+ * asltree - parse tree support
+ */
+ACPI_STATUS
+TrWalkParseTree (
+    ACPI_PARSE_OBJECT       *Op,
+    UINT32                  Visitation,
+    ASL_WALK_CALLBACK       DescendingCallback,
+    ASL_WALK_CALLBACK       AscendingCallback,
+    void                    *Context);
+
+/*
+ * aslexternal - External opcode support
+ */
+ACPI_STATUS
+ExAmlExternalWalkBegin (
+    ACPI_PARSE_OBJECT       *Op,
+    UINT32                  Level,
+    void                    *Context);
+
+ACPI_STATUS
+ExAmlExternalWalkEnd (
+    ACPI_PARSE_OBJECT       *Op,
+    UINT32                  Level,
+    void                    *Context);
+
+void
+ExDoExternal (
+    ACPI_PARSE_OBJECT       *Op);
+
+/* Values for "Visitation" parameter above */
+
+#define ASL_WALK_VISIT_DOWNWARD     0x01
+#define ASL_WALK_VISIT_UPWARD       0x02
+#define ASL_WALK_VISIT_TWICE        (ASL_WALK_VISIT_DOWNWARD | ASL_WALK_VISIT_UPWARD)
+
+
+void
+TrSetParent (
+    ACPI_PARSE_OBJECT       *Op,
+    ACPI_PARSE_OBJECT       *ParentOp);
+
+ACPI_PARSE_OBJECT *
+TrAllocateNode (
+    UINT32                  ParseOpcode);
+
+void
+TrPrintNodeCompileFlags (
+    UINT32                  Flags);
+
+void
+TrReleaseNode (
+    ACPI_PARSE_OBJECT       *Op);
+
+ACPI_PARSE_OBJECT *
+TrUpdateNode (
+    UINT32                  ParseOpcode,
+    ACPI_PARSE_OBJECT       *Op);
+
+ACPI_PARSE_OBJECT *
+TrCreateNode (
+    UINT32                  ParseOpcode,
+    UINT32                  NumChildren,
+    ...);
+
+ACPI_PARSE_OBJECT *
+TrCreateLeafNode (
+    UINT32                  ParseOpcode);
+
+ACPI_PARSE_OBJECT *
+TrCreateNullTarget (
+    void);
+
+ACPI_PARSE_OBJECT *
+TrCreateAssignmentNode (
+    ACPI_PARSE_OBJECT       *Target,
+    ACPI_PARSE_OBJECT       *Source);
+
+ACPI_PARSE_OBJECT *
+TrCreateTargetOperand (
+    ACPI_PARSE_OBJECT       *OriginalOp,
+    ACPI_PARSE_OBJECT       *ParentOp);
+
+ACPI_PARSE_OBJECT *
+TrCreateValuedLeafNode (
+    UINT32                  ParseOpcode,
+    UINT64                  Value);
+
+ACPI_PARSE_OBJECT *
+TrCreateConstantLeafNode (
+    UINT32                  ParseOpcode);
+
+ACPI_PARSE_OBJECT *
+TrLinkChildren (
+    ACPI_PARSE_OBJECT       *Op,
+    UINT32                  NumChildren,
+    ...);
+
+void
+TrSetEndLineNumber (
+    ACPI_PARSE_OBJECT       *Op);
+
+void
+TrSetCurrentFilename (
+    ACPI_PARSE_OBJECT       *Op);
+
+void
+TrWalkTree (
+    void);
+
+ACPI_PARSE_OBJECT *
+TrLinkPeerNode (
+    ACPI_PARSE_OBJECT       *Op1,
+    ACPI_PARSE_OBJECT       *Op2);
+
+ACPI_PARSE_OBJECT *
+TrLinkChildNode (
+    ACPI_PARSE_OBJECT       *Op1,
+    ACPI_PARSE_OBJECT       *Op2);
+
+ACPI_PARSE_OBJECT *
+TrSetNodeFlags (
+    ACPI_PARSE_OBJECT       *Op,
+    UINT32                  Flags);
+
+ACPI_PARSE_OBJECT *
+TrSetNodeAmlLength (
+    ACPI_PARSE_OBJECT       *Op,
+    UINT32                  Length);
+
+ACPI_PARSE_OBJECT *
+TrLinkPeerNodes (
+    UINT32                  NumPeers,
+    ...);
+
+
+/*
+ * aslfiles - File I/O support
+ */
+void
+FlAddIncludeDirectory (
+    char                    *Dir);
+
+char *
+FlMergePathnames (
+    char                    *PrefixDir,
+    char                    *FilePathname);
+
+void
+FlOpenIncludeFile (
+    ACPI_PARSE_OBJECT       *Op);
+
+void
+FlFileError (
+    UINT32                  FileId,
+    UINT8                   ErrorId);
+
+UINT32
+FlGetFileSize (
+    UINT32                  FileId);
+
+ACPI_STATUS
+FlReadFile (
+    UINT32                  FileId,
+    void                    *Buffer,
+    UINT32                  Length);
+
+void
+FlWriteFile (
+    UINT32                  FileId,
+    void                    *Buffer,
+    UINT32                  Length);
+
+void
+FlSeekFile (
+    UINT32                  FileId,
+    long                    Offset);
+
+void
+FlCloseFile (
+    UINT32                  FileId);
+
+void
+FlPrintFile (
+    UINT32                  FileId,
+    char                    *Format,
+    ...);
+
+void
+FlDeleteFile (
+    UINT32                  FileId);
+
+void
+FlSetLineNumber (
+    UINT32                  LineNumber);
+
+void
+FlSetFilename (
+    char                    *Filename);
+
+ACPI_STATUS
+FlOpenInputFile (
+    char                    *InputFilename);
+
+ACPI_STATUS
+FlOpenAmlOutputFile (
+    char                    *InputFilename);
+
+ACPI_STATUS
+FlOpenMiscOutputFiles (
+    char                    *InputFilename);
+
+/*
+ * aslhwmap - hardware map summary
+ */
+void
+MpEmitMappingInfo (
+    void);
+
+
+/*
+ * asload - load namespace in prep for cross reference
+ */
+ACPI_STATUS
+LdLoadNamespace (
+    ACPI_PARSE_OBJECT       *RootOp);
+
+
+/*
+ * asllookup - namespace lookup functions
+ */
+void
+LkFindUnreferencedObjects (
+    void);
+
+/*
+ * aslmain - startup
+ */
+void
+Usage (
+    void);
+
+void
+AslFilenameHelp (
+    void);
+
+
+/*
+ * aslnamesp - namespace output file generation
+ */
+ACPI_STATUS
+NsDisplayNamespace (
+    void);
+
+void
+NsSetupNamespaceListing (
+    void                    *Handle);
+
+/*
+ * asloptions - command line processing
+ */
+int
+AslCommandLine (
+    int                     argc,
+    char                    **argv);
+
+/*
+ * aslxref - namespace cross reference
+ */
+ACPI_STATUS
+XfCrossReferenceNamespace (
+    void);
+
+
+/*
+ * aslxrefout
+ */
+void
+OtPrintHeaders (
+    char                    *Message);
+
+void
+OtCreateXrefFile (
+    void);
+
+void
+OtXrefWalkPart1 (
+    ACPI_PARSE_OBJECT       *Op,
+    UINT32                  Level,
+    ASL_METHOD_INFO         *MethodInfo);
+
+
+/*
+ * aslutils - common compiler utilites
+ */
+void
+DbgPrint (
+    UINT32                  Type,
+    char                    *Format,
+    ...);
+
+/* Type values for above */
+
+#define ASL_DEBUG_OUTPUT    0
+#define ASL_PARSE_OUTPUT    1
+#define ASL_TREE_OUTPUT     2
+
+UINT8
+UtIsBigEndianMachine (
+    void);
+
+BOOLEAN
+UtQueryForOverwrite (
+    char                    *Pathname);
+
+void
+UtDumpStringOp (
+    ACPI_PARSE_OBJECT       *Op,
+    UINT32                  Level);
+
+void
+UtDumpIntegerOp (
+    ACPI_PARSE_OBJECT       *Op,
+    UINT32                  Level,
+    UINT32                  IntegerLength);
+
+void
+UtDumpBasicOp (
+    ACPI_PARSE_OBJECT       *Op,
+    UINT32                  Level);
+
+void
+UtDisplaySupportedTables (
+    void);
+
+void
+UtDisplayConstantOpcodes (
+    void);
+
+UINT8
+UtBeginEvent (
+    char                    *Name);
+
+void
+UtEndEvent (
+    UINT8                   Event);
+
+void *
+UtLocalCalloc (
+    UINT32                  Size);
+
+void
+UtDisplaySummary (
+    UINT32                  FileId);
+
+void
+UtConvertByteToHex (
+    UINT8                   RawByte,
+    UINT8                   *Buffer);
+
+void
+UtConvertByteToAsmHex (
+    UINT8                   RawByte,
+    UINT8                   *Buffer);
+
+char *
+UtGetOpName (
+    UINT32                  ParseOpcode);
+
+void
+UtSetParseOpName (
+    ACPI_PARSE_OBJECT       *Op);
+
+char *
+UtStringCacheCalloc (
+    UINT32                  Length);
+
+void
+UtExpandLineBuffers (
+    void);
+
+void
+UtFreeLineBuffers (
+    void);
+
+ACPI_STATUS
+UtInternalizeName (
+    char                    *ExternalName,
+    char                    **ConvertedName);
+
+void
+UtAttachNamepathToOwner (
+    ACPI_PARSE_OBJECT       *Op,
+    ACPI_PARSE_OBJECT       *NameNode);
+
+ACPI_PARSE_OBJECT *
+UtCheckIntegerRange (
+    ACPI_PARSE_OBJECT       *Op,
+    UINT32                  LowValue,
+    UINT32                  HighValue);
+
+UINT64
+UtDoConstant (
+    char                    *String);
+
+
+/*
+ * asluuid - UUID support
+ */
+ACPI_STATUS
+AuValidateUuid (
+    char                    *InString);
+
+ACPI_STATUS
+AuConvertUuidToString (
+    char                    *UuIdBuffer,
+    char                    *OutString);
+
+/*
+ * aslresource - Resource template generation utilities
+ */
+void
+RsSmallAddressCheck (
+    UINT8                   Type,
+    UINT32                  Minimum,
+    UINT32                  Maximum,
+    UINT32                  Length,
+    UINT32                  Alignment,
+    ACPI_PARSE_OBJECT       *MinOp,
+    ACPI_PARSE_OBJECT       *MaxOp,
+    ACPI_PARSE_OBJECT       *LengthOp,
+    ACPI_PARSE_OBJECT       *AlignOp,
+    ACPI_PARSE_OBJECT       *Op);
+
+void
+RsLargeAddressCheck (
+    UINT64                  Minimum,
+    UINT64                  Maximum,
+    UINT64                  Length,
+    UINT64                  Granularity,
+    UINT8                   Flags,
+    ACPI_PARSE_OBJECT       *MinOp,
+    ACPI_PARSE_OBJECT       *MaxOp,
+    ACPI_PARSE_OBJECT       *LengthOp,
+    ACPI_PARSE_OBJECT       *GranOp,
+    ACPI_PARSE_OBJECT       *Op);
+
+UINT16
+RsGetStringDataLength (
+    ACPI_PARSE_OBJECT       *InitializerOp);
+
+ASL_RESOURCE_NODE *
+RsAllocateResourceNode (
+    UINT32                  Size);
+
+void
+RsCreateResourceField (
+    ACPI_PARSE_OBJECT       *Op,
+    char                    *Name,
+    UINT32                  ByteOffset,
+    UINT32                  BitOffset,
+    UINT32                  BitLength);
+
+void
+RsSetFlagBits (
+    UINT8                   *Flags,
+    ACPI_PARSE_OBJECT       *Op,
+    UINT8                   Position,
+    UINT8                   DefaultBit);
+
+void
+RsSetFlagBits16 (
+    UINT16                  *Flags,
+    ACPI_PARSE_OBJECT       *Op,
+    UINT8                   Position,
+    UINT8                   DefaultBit);
+
+ACPI_PARSE_OBJECT *
+RsCompleteNodeAndGetNext (
+    ACPI_PARSE_OBJECT       *Op);
+
+void
+RsCheckListForDuplicates (
+    ACPI_PARSE_OBJECT       *Op);
+
+ASL_RESOURCE_NODE *
+RsDoOneResourceDescriptor (
+    ASL_RESOURCE_INFO       *Info,
+    UINT8                   *State);
+
+/* Values for State above */
+
+#define ACPI_RSTATE_NORMAL              0
+#define ACPI_RSTATE_START_DEPENDENT     1
+#define ACPI_RSTATE_DEPENDENT_LIST      2
+
+UINT32
+RsLinkDescriptorChain (
+    ASL_RESOURCE_NODE       **PreviousRnode,
+    ASL_RESOURCE_NODE       *Rnode);
+
+void
+RsDoResourceTemplate (
+    ACPI_PARSE_OBJECT       *Op);
+
+
+/*
+ * aslrestype1 - Miscellaneous Small descriptors
+ */
+ASL_RESOURCE_NODE *
+RsDoEndTagDescriptor (
+    ASL_RESOURCE_INFO       *Info);
+
+ASL_RESOURCE_NODE *
+RsDoEndDependentDescriptor (
+    ASL_RESOURCE_INFO       *Info);
+
+ASL_RESOURCE_NODE *
+RsDoMemory24Descriptor (
+    ASL_RESOURCE_INFO       *Info);
+
+ASL_RESOURCE_NODE *
+RsDoMemory32Descriptor (
+    ASL_RESOURCE_INFO       *Info);
+
+ASL_RESOURCE_NODE *
+RsDoMemory32FixedDescriptor (
+    ASL_RESOURCE_INFO       *Info);
+
+ASL_RESOURCE_NODE *
+RsDoStartDependentDescriptor (
+    ASL_RESOURCE_INFO       *Info);
+
+ASL_RESOURCE_NODE *
+RsDoStartDependentNoPriDescriptor (
+    ASL_RESOURCE_INFO       *Info);
+
+ASL_RESOURCE_NODE *
+RsDoVendorSmallDescriptor (
+    ASL_RESOURCE_INFO       *Info);
+
+
+/*
+ * aslrestype1i - I/O-related Small descriptors
+ */
+ASL_RESOURCE_NODE *
+RsDoDmaDescriptor (
+    ASL_RESOURCE_INFO       *Info);
+
+ASL_RESOURCE_NODE *
+RsDoFixedDmaDescriptor (
+    ASL_RESOURCE_INFO       *Info);
+
+ASL_RESOURCE_NODE *
+RsDoFixedIoDescriptor (
+    ASL_RESOURCE_INFO       *Info);
+
+ASL_RESOURCE_NODE *
+RsDoIoDescriptor (
+    ASL_RESOURCE_INFO       *Info);
+
+ASL_RESOURCE_NODE *
+RsDoIrqDescriptor (
+    ASL_RESOURCE_INFO       *Info);
+
+ASL_RESOURCE_NODE *
+RsDoIrqNoFlagsDescriptor (
+    ASL_RESOURCE_INFO       *Info);
+
+
+/*
+ * aslrestype2 - Large resource descriptors
+ */
+ASL_RESOURCE_NODE *
+RsDoInterruptDescriptor (
+    ASL_RESOURCE_INFO       *Info);
+
+ASL_RESOURCE_NODE *
+RsDoVendorLargeDescriptor (
+    ASL_RESOURCE_INFO       *Info);
+
+ASL_RESOURCE_NODE *
+RsDoGeneralRegisterDescriptor (
+    ASL_RESOURCE_INFO       *Info);
+
+ASL_RESOURCE_NODE *
+RsDoGpioIntDescriptor (
+    ASL_RESOURCE_INFO       *Info);
+
+ASL_RESOURCE_NODE *
+RsDoGpioIoDescriptor (
+    ASL_RESOURCE_INFO       *Info);
+
+ASL_RESOURCE_NODE *
+RsDoI2cSerialBusDescriptor (
+    ASL_RESOURCE_INFO       *Info);
+
+ASL_RESOURCE_NODE *
+RsDoSpiSerialBusDescriptor (
+    ASL_RESOURCE_INFO       *Info);
+
+ASL_RESOURCE_NODE *
+RsDoUartSerialBusDescriptor (
+    ASL_RESOURCE_INFO       *Info);
+
+/*
+ * aslrestype2d - DWord address descriptors
+ */
+ASL_RESOURCE_NODE *
+RsDoDwordIoDescriptor (
+    ASL_RESOURCE_INFO       *Info);
+
+ASL_RESOURCE_NODE *
+RsDoDwordMemoryDescriptor (
+    ASL_RESOURCE_INFO       *Info);
+
+ASL_RESOURCE_NODE *
+RsDoDwordSpaceDescriptor (
+    ASL_RESOURCE_INFO       *Info);
+
+
+/*
+ * aslrestype2e - Extended address descriptors
+ */
+ASL_RESOURCE_NODE *
+RsDoExtendedIoDescriptor (
+    ASL_RESOURCE_INFO       *Info);
+
+ASL_RESOURCE_NODE *
+RsDoExtendedMemoryDescriptor (
+    ASL_RESOURCE_INFO       *Info);
+
+ASL_RESOURCE_NODE *
+RsDoExtendedSpaceDescriptor (
+    ASL_RESOURCE_INFO       *Info);
+
+
+/*
+ * aslrestype2q - QWord address descriptors
+ */
+ASL_RESOURCE_NODE *
+RsDoQwordIoDescriptor (
+    ASL_RESOURCE_INFO       *Info);
+
+ASL_RESOURCE_NODE *
+RsDoQwordMemoryDescriptor (
+    ASL_RESOURCE_INFO       *Info);
+
+ASL_RESOURCE_NODE *
+RsDoQwordSpaceDescriptor (
+    ASL_RESOURCE_INFO       *Info);
+
+
+/*
+ * aslrestype2w - Word address descriptors
+ */
+ASL_RESOURCE_NODE *
+RsDoWordIoDescriptor (
+    ASL_RESOURCE_INFO       *Info);
+
+ASL_RESOURCE_NODE *
+RsDoWordSpaceDescriptor (
+    ASL_RESOURCE_INFO       *Info);
+
+ASL_RESOURCE_NODE *
+RsDoWordBusNumberDescriptor (
+    ASL_RESOURCE_INFO       *Info);
+
+
+/*
+ * Entry to data table compiler subsystem
+ */
+ACPI_STATUS
+DtDoCompile(
+    void);
+
+ACPI_STATUS
+DtCreateTemplates (
+    char                    **argv);
+
+#endif /*  __ASLCOMPILER_H */
diff --git a/usr/src/cmd/acpi/iasl/aslcompiler.l b/usr/src/cmd/acpi/iasl/aslcompiler.l
new file mode 100644
index 0000000000..15c9dae0d1
--- /dev/null
+++ b/usr/src/cmd/acpi/iasl/aslcompiler.l
@@ -0,0 +1,749 @@
+%{
+/******************************************************************************
+ *
+ * Module Name: aslcompiler.l - Flex/lex input file
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2016, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include "aslcompiler.h"
+#include "aslcompiler.y.h"
+
+#include <stdlib.h>
+#include <string.h>
+YYSTYPE AslCompilerlval;
+
+/*
+ * Generation:  Use the following command line:
+ *
+ * flex.exe -PAslCompiler -i -o$(InputPath).c $(InputPath)
+ *
+ * -i: Scanner must be case-insensitive
+ */
+
+#define _COMPONENT          ACPI_COMPILER
+        ACPI_MODULE_NAME    ("aslscanner")
+
+
+/* Local prototypes */
+
+static void
+AslDoLineDirective (void);
+
+static char
+AslDoComment (void);
+
+static char
+AslDoCommentType2 (void);
+
+static char
+AslDoStringLiteral (void);
+
+static void
+count (int type);
+
+
+/*! [Begin] no source code translation */
+
+%}
+    /* Definitions */
+
+LeadNameChar                [A-Za-z_]
+DigitChar                   [0-9]
+HexDigitChar                [A-Fa-f0-9]
+RootChar                    [\\]
+Nothing                     []
+
+NameChar                    [A-Za-z_0-9]
+NameSeg1                    {LeadNameChar}{NameChar}
+NameSeg2                    {LeadNameChar}{NameChar}{NameChar}
+NameSeg3                    {LeadNameChar}{NameChar}{NameChar}{NameChar}
+NameSeg                     {LeadNameChar}|{NameSeg1}|{NameSeg2}|{NameSeg3}
+
+NameString                  {RootChar}|{RootChar}{NamePath}|[\^]+{NamePath}|{NonEmptyNamePath}
+NamePath                    {NonEmptyNamePath}?
+NonEmptyNamePath            {NameSeg}{NamePathTail}*
+NamePathTail                [.]{NameSeg}
+
+%%
+    /* Rules */
+
+[ ]                         { count (0); }
+[\n]                        { count (0); } /* Handle files with both LF and CR/LF */
+[\r]                        { count (0); } /* termination on both Unix and Windows */
+[ \t]                       { count (0); }
+
+
+"/*"                        { if (!AslDoComment ()) {yyterminate ();} }
+"//"                        { if (!AslDoCommentType2 ()) {yyterminate ();} }
+
+"\""                        { if (AslDoStringLiteral ()) {return (PARSEOP_STRING_LITERAL);}
+                              else {yyterminate ();} }
+";"                         { count (0); return(';'); }
+
+    /* ASL Extension: Standard C operators */
+
+"~"                         { count (3); return (PARSEOP_EXP_NOT); }
+"!"                         { count (3); return (PARSEOP_EXP_LOGICAL_NOT); }
+"*"                         { count (3); return (PARSEOP_EXP_MULTIPLY); }
+"/"                         { count (3); return (PARSEOP_EXP_DIVIDE); }
+"%"                         { count (3); return (PARSEOP_EXP_MODULO); }
+"+"                         { count (3); return (PARSEOP_EXP_ADD); }
+"-"                         { count (3); return (PARSEOP_EXP_SUBTRACT); }
+">>"                        { count (3); return (PARSEOP_EXP_SHIFT_RIGHT); }
+"<<"                        { count (3); return (PARSEOP_EXP_SHIFT_LEFT); }
+"<"                         { count (3); return (PARSEOP_EXP_LESS); }
+">"                         { count (3); return (PARSEOP_EXP_GREATER); }
+"&"                         { count (3); return (PARSEOP_EXP_AND); }
+"<="                        { count (3); return (PARSEOP_EXP_LESS_EQUAL); }
+">="                        { count (3); return (PARSEOP_EXP_GREATER_EQUAL); }
+"=="                        { count (3); return (PARSEOP_EXP_EQUAL); }
+"!="                        { count (3); return (PARSEOP_EXP_NOT_EQUAL); }
+"|"                         { count (3); return (PARSEOP_EXP_OR); }
+"&&"                        { count (3); return (PARSEOP_EXP_LOGICAL_AND); }
+"||"                        { count (3); return (PARSEOP_EXP_LOGICAL_OR); }
+"++"                        { count (3); return (PARSEOP_EXP_INCREMENT); }
+"--"                        { count (3); return (PARSEOP_EXP_DECREMENT); }
+"^ "                        { count (3); return (PARSEOP_EXP_XOR); }
+
+    /* ASL Extension: Standard C assignment operators */
+
+"="                         { count (3); return (PARSEOP_EXP_EQUALS); }
+"+="                        { count (3); return (PARSEOP_EXP_ADD_EQ); }
+"-="                        { count (3); return (PARSEOP_EXP_SUB_EQ); }
+"*="                        { count (3); return (PARSEOP_EXP_MUL_EQ); }
+"/="                        { count (3); return (PARSEOP_EXP_DIV_EQ); }
+"%="                        { count (3); return (PARSEOP_EXP_MOD_EQ); }
+"<<="                       { count (3); return (PARSEOP_EXP_SHL_EQ); }
+">>="                       { count (3); return (PARSEOP_EXP_SHR_EQ); }
+"&="                        { count (3); return (PARSEOP_EXP_AND_EQ); }
+"^="                        { count (3); return (PARSEOP_EXP_XOR_EQ); }
+"|="                        { count (3); return (PARSEOP_EXP_OR_EQ); }
+
+"["                         { count (3); return(PARSEOP_EXP_INDEX_LEFT); }
+"]"                         { count (0); return(PARSEOP_EXP_INDEX_RIGHT); }
+
+
+    /*
+     * Begin standard ASL grammar
+     */
+0[xX]{HexDigitChar}+ |
+{DigitChar}+                { AslCompilerlval.i = UtDoConstant ((char *) AslCompilertext);
+                                count (1); return (PARSEOP_INTEGER); }
+
+"Include"                   { count (1); return (PARSEOP_INCLUDE); }
+"External"                  { count (1); return (PARSEOP_EXTERNAL); }
+
+ /*
+  * The #line directive is emitted by the preprocessor and handled
+  * here in the main iASL lexer - simply set the line number and
+  * optionally the current filename.
+  */
+"#line"                     { AslDoLineDirective ();}
+
+
+ /****************************************************************************
+  *
+  * Main ASL operators
+  *
+  ****************************************************************************/
+
+"AccessAs"                  { count (1); return (PARSEOP_ACCESSAS); }
+"Acquire"                   { count (3); return (PARSEOP_ACQUIRE); }
+"Add"                       { count (3); return (PARSEOP_ADD); }
+"Alias"                     { count (2); return (PARSEOP_ALIAS); }
+"And"                       { count (3); return (PARSEOP_AND); }
+"BankField"                 { count (2); return (PARSEOP_BANKFIELD); }
+"Break"                     { count (3); return (PARSEOP_BREAK); }
+"BreakPoint"                { count (3); return (PARSEOP_BREAKPOINT); }
+"Buffer"                    { count (1); return (PARSEOP_BUFFER); }
+"Case"                      { count (3); return (PARSEOP_CASE); }
+"Concatenate"               { count (3); return (PARSEOP_CONCATENATE); }
+"ConcatenateResTemplate"    { count (3); return (PARSEOP_CONCATENATERESTEMPLATE); }
+"CondRefOf"                 { count (3); return (PARSEOP_CONDREFOF); }
+"Connection"                { count (2); return (PARSEOP_CONNECTION); }
+"Continue"                  { count (3); return (PARSEOP_CONTINUE); }
+"CopyObject"                { count (3); return (PARSEOP_COPYOBJECT); }
+"CreateBitField"            { count (2); return (PARSEOP_CREATEBITFIELD); }
+"CreateByteField"           { count (2); return (PARSEOP_CREATEBYTEFIELD); }
+"CreateDWordField"          { count (2); return (PARSEOP_CREATEDWORDFIELD); }
+"CreateField"               { count (2); return (PARSEOP_CREATEFIELD); }
+"CreateQWordField"          { count (2); return (PARSEOP_CREATEQWORDFIELD); }
+"CreateWordField"           { count (2); return (PARSEOP_CREATEWORDFIELD); }
+"DataTableRegion"           { count (2); return (PARSEOP_DATATABLEREGION); }
+"Debug"                     { count (1); return (PARSEOP_DEBUG); }
+"Decrement"                 { count (3); return (PARSEOP_DECREMENT); }
+"Default"                   { count (3); return (PARSEOP_DEFAULT); }
+"DefinitionBlock"           { count (1); return (PARSEOP_DEFINITION_BLOCK); }
+"DeRefOf"                   { count (3); return (PARSEOP_DEREFOF); }
+"Device"                    { count (2); return (PARSEOP_DEVICE); }
+"Divide"                    { count (3); return (PARSEOP_DIVIDE); }
+"Eisaid"                    { count (1); return (PARSEOP_EISAID); }
+"Else"                      { count (3); return (PARSEOP_ELSE); }
+"ElseIf"                    { count (3); return (PARSEOP_ELSEIF); }
+"Event"                     { count (2); return (PARSEOP_EVENT); }
+"Fatal"                     { count (3); return (PARSEOP_FATAL); }
+"Field"                     { count (2); return (PARSEOP_FIELD); }
+"FindSetLeftBit"            { count (3); return (PARSEOP_FINDSETLEFTBIT); }
+"FindSetRightBit"           { count (3); return (PARSEOP_FINDSETRIGHTBIT); }
+"FromBcd"                   { count (3); return (PARSEOP_FROMBCD); }
+"Function"                  { count (2); return (PARSEOP_FUNCTION); }
+"If"                        { count (3); return (PARSEOP_IF); }
+"Increment"                 { count (3); return (PARSEOP_INCREMENT); }
+"Index"                     { count (3); return (PARSEOP_INDEX); }
+"IndexField"                { count (2); return (PARSEOP_INDEXFIELD); }
+"LAnd"                      { count (3); return (PARSEOP_LAND); }
+"LEqual"                    { count (3); return (PARSEOP_LEQUAL); }
+"LGreater"                  { count (3); return (PARSEOP_LGREATER); }
+"LGreaterEqual"             { count (3); return (PARSEOP_LGREATEREQUAL); }
+"LLess"                     { count (3); return (PARSEOP_LLESS); }
+"LLessEqual"                { count (3); return (PARSEOP_LLESSEQUAL); }
+"LNot"                      { count (3); return (PARSEOP_LNOT); }
+"LNotEqual"                 { count (3); return (PARSEOP_LNOTEQUAL); }
+"Load"                      { count (3); return (PARSEOP_LOAD); }
+"LoadTable"                 { count (3); return (PARSEOP_LOADTABLE); }
+"LOr"                       { count (3); return (PARSEOP_LOR); }
+"Match"                     { count (3); return (PARSEOP_MATCH); }
+"Method"                    { count (2); return (PARSEOP_METHOD); }
+"Mid"                       { count (3); return (PARSEOP_MID); }
+"Mod"                       { count (3); return (PARSEOP_MOD); }
+"Multiply"                  { count (3); return (PARSEOP_MULTIPLY); }
+"Mutex"                     { count (2); return (PARSEOP_MUTEX); }
+"Name"                      { count (2); return (PARSEOP_NAME); }
+"NAnd"                      { count (3); return (PARSEOP_NAND); }
+"Noop"                      { if (!AcpiGbl_IgnoreNoopOperator) {count (3); return (PARSEOP_NOOP);} }
+"NOr"                       { count (3); return (PARSEOP_NOR); }
+"Not"                       { count (3); return (PARSEOP_NOT); }
+"Notify"                    { count (3); return (PARSEOP_NOTIFY); }
+"ObjectType"                { count (3); return (PARSEOP_OBJECTTYPE); }
+"Offset"                    { count (1); return (PARSEOP_OFFSET); }
+"One"                       { count (1); return (PARSEOP_ONE); }
+"Ones"                      { count (1); return (PARSEOP_ONES); }
+"OperationRegion"           { count (2); return (PARSEOP_OPERATIONREGION); }
+"Or"                        { count (3); return (PARSEOP_OR); }
+"Package"                   { count (1); return (PARSEOP_PACKAGE); }
+"PowerResource"             { count (2); return (PARSEOP_POWERRESOURCE); }
+"Processor"                 { count (2); return (PARSEOP_PROCESSOR); }
+"RefOf"                     { count (3); return (PARSEOP_REFOF); }
+"Release"                   { count (3); return (PARSEOP_RELEASE); }
+"Reset"                     { count (3); return (PARSEOP_RESET); }
+"Return"                    { count (3); return (PARSEOP_RETURN); }
+"Revision"                  { count (1); return (PARSEOP_REVISION); }
+"Scope"                     { count (2); return (PARSEOP_SCOPE); }
+"ShiftLeft"                 { count (3); return (PARSEOP_SHIFTLEFT); }
+"ShiftRight"                { count (3); return (PARSEOP_SHIFTRIGHT); }
+"Signal"                    { count (3); return (PARSEOP_SIGNAL); }
+"SizeOf"                    { count (3); return (PARSEOP_SIZEOF); }
+"Sleep"                     { count (3); return (PARSEOP_SLEEP); }
+"Stall"                     { count (3); return (PARSEOP_STALL); }
+"Store"                     { count (3); return (PARSEOP_STORE); }
+"Subtract"                  { count (3); return (PARSEOP_SUBTRACT); }
+"Switch"                    { count (3); return (PARSEOP_SWITCH); }
+"ThermalZone"               { count (2); return (PARSEOP_THERMALZONE); }
+"Timer"                     { count (3); return (PARSEOP_TIMER); }
+"ToBcd"                     { count (3); return (PARSEOP_TOBCD); }
+"ToBuffer"                  { count (3); return (PARSEOP_TOBUFFER); }
+"ToDecimalString"           { count (3); return (PARSEOP_TODECIMALSTRING); }
+"ToHexString"               { count (3); return (PARSEOP_TOHEXSTRING); }
+"ToInteger"                 { count (3); return (PARSEOP_TOINTEGER); }
+"ToString"                  { count (3); return (PARSEOP_TOSTRING); }
+"ToUuid"                    { count (1); return (PARSEOP_TOUUID); }
+"Unicode"                   { count (1); return (PARSEOP_UNICODE); }
+"Unload"                    { count (3); return (PARSEOP_UNLOAD); }
+"Wait"                      { count (3); return (PARSEOP_WAIT); }
+"While"                     { count (3); return (PARSEOP_WHILE); }
+"XOr"                       { count (3); return (PARSEOP_XOR); }
+"Zero"                      { count (1); return (PARSEOP_ZERO); }
+
+    /* Control method arguments and locals */
+
+"Arg0"                      { count (1); return (PARSEOP_ARG0); }
+"Arg1"                      { count (1); return (PARSEOP_ARG1); }
+"Arg2"                      { count (1); return (PARSEOP_ARG2); }
+"Arg3"                      { count (1); return (PARSEOP_ARG3); }
+"Arg4"                      { count (1); return (PARSEOP_ARG4); }
+"Arg5"                      { count (1); return (PARSEOP_ARG5); }
+"Arg6"                      { count (1); return (PARSEOP_ARG6); }
+"Local0"                    { count (1); return (PARSEOP_LOCAL0); }
+"Local1"                    { count (1); return (PARSEOP_LOCAL1); }
+"Local2"                    { count (1); return (PARSEOP_LOCAL2); }
+"Local3"                    { count (1); return (PARSEOP_LOCAL3); }
+"Local4"                    { count (1); return (PARSEOP_LOCAL4); }
+"Local5"                    { count (1); return (PARSEOP_LOCAL5); }
+"Local6"                    { count (1); return (PARSEOP_LOCAL6); }
+"Local7"                    { count (1); return (PARSEOP_LOCAL7); }
+
+
+ /****************************************************************************
+  *
+  * Resource Descriptor macros
+  *
+  ****************************************************************************/
+
+"ResourceTemplate"          { count (1); return (PARSEOP_RESOURCETEMPLATE); }
+"RawDataBuffer"             { count (1); return (PARSEOP_DATABUFFER); }
+
+"DMA"                       { count (1); return (PARSEOP_DMA); }
+"DWordIO"                   { count (1); return (PARSEOP_DWORDIO); }
+"DWordMemory"               { count (1); return (PARSEOP_DWORDMEMORY); }
+"DWordSpace"                { count (1); return (PARSEOP_DWORDSPACE); }
+"EndDependentFn"            { count (1); return (PARSEOP_ENDDEPENDENTFN); }
+"ExtendedIO"                { count (1); return (PARSEOP_EXTENDEDIO); }
+"ExtendedMemory"            { count (1); return (PARSEOP_EXTENDEDMEMORY); }
+"ExtendedSpace"             { count (1); return (PARSEOP_EXTENDEDSPACE); }
+"FixedDma"                  { count (1); return (PARSEOP_FIXEDDMA); }
+"FixedIO"                   { count (1); return (PARSEOP_FIXEDIO); }
+"GpioInt"                   { count (1); return (PARSEOP_GPIO_INT); }
+"GpioIo"                    { count (1); return (PARSEOP_GPIO_IO); }
+"I2cSerialBus"              { count (1); return (PARSEOP_I2C_SERIALBUS); }
+"I2cSerialBusV2"            { count (1); return (PARSEOP_I2C_SERIALBUS_V2); }
+"Interrupt"                 { count (1); return (PARSEOP_INTERRUPT); }
+"IO"                        { count (1); return (PARSEOP_IO); }
+"IRQ"                       { count (1); return (PARSEOP_IRQ); }
+"IRQNoFlags"                { count (1); return (PARSEOP_IRQNOFLAGS); }
+"Memory24"                  { count (1); return (PARSEOP_MEMORY24); }
+"Memory32"                  { count (1); return (PARSEOP_MEMORY32); }
+"Memory32Fixed"             { count (1); return (PARSEOP_MEMORY32FIXED); }
+"QWordIO"                   { count (1); return (PARSEOP_QWORDIO); }
+"QWordMemory"               { count (1); return (PARSEOP_QWORDMEMORY); }
+"QWordSpace"                { count (1); return (PARSEOP_QWORDSPACE); }
+"Register"                  { count (1); return (PARSEOP_REGISTER); }
+"SpiSerialBus"              { count (1); return (PARSEOP_SPI_SERIALBUS); }
+"SpiSerialBusV2"            { count (1); return (PARSEOP_SPI_SERIALBUS_V2); }
+"StartDependentFn"          { count (1); return (PARSEOP_STARTDEPENDENTFN); }
+"StartDependentFnNoPri"     { count (1); return (PARSEOP_STARTDEPENDENTFN_NOPRI); }
+"UartSerialBus"             { count (1); return (PARSEOP_UART_SERIALBUS); }
+"UartSerialBusV2"           { count (1); return (PARSEOP_UART_SERIALBUS_V2); }
+"VendorLong"                { count (1); return (PARSEOP_VENDORLONG); }
+"VendorShort"               { count (1); return (PARSEOP_VENDORSHORT); }
+"WordBusNumber"             { count (1); return (PARSEOP_WORDBUSNUMBER); }
+"WordIO"                    { count (1); return (PARSEOP_WORDIO); }
+"WordSpace"                 { count (1); return (PARSEOP_WORDSPACE); }
+
+
+ /****************************************************************************
+  *
+  * Keywords used as arguments to ASL operators and macros
+  *
+  ****************************************************************************/
+
+    /*  AccessAttribKeyword: Serial Bus Attributes (ACPI 5.0) */
+
+"AttribQuick"               { count (0); return (PARSEOP_ACCESSATTRIB_QUICK); }
+"AttribSendReceive"         { count (0); return (PARSEOP_ACCESSATTRIB_SND_RCV); }
+"AttribByte"                { count (0); return (PARSEOP_ACCESSATTRIB_BYTE); }
+"AttribWord"                { count (0); return (PARSEOP_ACCESSATTRIB_WORD); }
+"AttribBlock"               { count (0); return (PARSEOP_ACCESSATTRIB_BLOCK); }
+"AttribProcessCall"         { count (0); return (PARSEOP_ACCESSATTRIB_WORD_CALL); }
+"AttribBlockProcessCall"    { count (0); return (PARSEOP_ACCESSATTRIB_BLOCK_CALL); }
+
+    /* AccessAttribKeyword: Legacy synonyms for above (pre-ACPI 5.0) */
+
+"SMBQuick"                  { count (0); return (PARSEOP_ACCESSATTRIB_QUICK); }
+"SMBSendReceive"            { count (0); return (PARSEOP_ACCESSATTRIB_SND_RCV); }
+"SMBByte"                   { count (0); return (PARSEOP_ACCESSATTRIB_BYTE); }
+"SMBWord"                   { count (0); return (PARSEOP_ACCESSATTRIB_WORD); }
+"SMBBlock"                  { count (0); return (PARSEOP_ACCESSATTRIB_BLOCK); }
+"SMBProcessCall"            { count (0); return (PARSEOP_ACCESSATTRIB_WORD_CALL); }
+"SMBBlockProcessCall"       { count (0); return (PARSEOP_ACCESSATTRIB_BLOCK_CALL); }
+
+    /* AccessTypeKeyword: Field Access Types */
+
+"AnyAcc"                    { count (0); return (PARSEOP_ACCESSTYPE_ANY); }
+"ByteAcc"                   { count (0); return (PARSEOP_ACCESSTYPE_BYTE); }
+"WordAcc"                   { count (0); return (PARSEOP_ACCESSTYPE_WORD); }
+"DWordAcc"                  { count (0); return (PARSEOP_ACCESSTYPE_DWORD); }
+"QWordAcc"                  { count (0); return (PARSEOP_ACCESSTYPE_QWORD); }
+"BufferAcc"                 { count (0); return (PARSEOP_ACCESSTYPE_BUF); }
+
+    /* AddressingModeKeyword: Mode - Resource Descriptors (ACPI 5.0) */
+
+"AddressingMode7Bit"        { count (0); return (PARSEOP_ADDRESSINGMODE_7BIT); }
+"AddressingMode10Bit"       { count (0); return (PARSEOP_ADDRESSINGMODE_10BIT); }
+
+    /* AddressKeyword: ACPI memory range types */
+
+"AddressRangeMemory"        { count (0); return (PARSEOP_ADDRESSTYPE_MEMORY); }
+"AddressRangeReserved"      { count (0); return (PARSEOP_ADDRESSTYPE_RESERVED); }
+"AddressRangeNVS"           { count (0); return (PARSEOP_ADDRESSTYPE_NVS); }
+"AddressRangeACPI"          { count (0); return (PARSEOP_ADDRESSTYPE_ACPI); }
+
+    /* BusMasterKeyword: DMA Bus Mastering */
+
+"BusMaster"                 { count (0); return (PARSEOP_BUSMASTERTYPE_MASTER); }
+"NotBusMaster"              { count (0); return (PARSEOP_BUSMASTERTYPE_NOTMASTER); }
+
+    /* ByteLengthKeyword: Bits per Byte - Resource Descriptors (ACPI 5.0) */
+
+"DataBitsFive"              { count (0); return (PARSEOP_BITSPERBYTE_FIVE); }
+"DataBitsSix"               { count (0); return (PARSEOP_BITSPERBYTE_SIX); }
+"DataBitsSeven"             { count (0); return (PARSEOP_BITSPERBYTE_SEVEN); }
+"DataBitsEight"             { count (0); return (PARSEOP_BITSPERBYTE_EIGHT); }
+"DataBitsNine"              { count (0); return (PARSEOP_BITSPERBYTE_NINE); }
+
+    /* ClockPhaseKeyword: Resource Descriptors (ACPI 5.0) */
+
+"ClockPhaseFirst"           { count (0); return (PARSEOP_CLOCKPHASE_FIRST); }
+"ClockPhaseSecond"          { count (0); return (PARSEOP_CLOCKPHASE_SECOND); }
+
+    /* ClockPolarityKeyword: Resource Descriptors (ACPI 5.0) */
+
+"ClockPolarityLow"          { count (0); return (PARSEOP_CLOCKPOLARITY_LOW); }
+"ClockPolarityHigh"         { count (0); return (PARSEOP_CLOCKPOLARITY_HIGH); }
+
+    /* DecodeKeyword: Type of Memory Decoding - Resource Descriptors */
+
+"PosDecode"                 { count (0); return (PARSEOP_DECODETYPE_POS); }
+"SubDecode"                 { count (0); return (PARSEOP_DECODETYPE_SUB); }
+
+    /* DmaTypeKeyword: DMA Types - DMA Resource Descriptor */
+
+"Compatibility"             { count (0); return (PARSEOP_DMATYPE_COMPATIBILITY); }
+"TypeA"                     { count (0); return (PARSEOP_DMATYPE_A); }
+"TypeB"                     { count (0); return (PARSEOP_DMATYPE_B); }
+"TypeF"                     { count (0); return (PARSEOP_DMATYPE_F); }
+
+    /* EndianKeyword: Endian type - Resource Descriptor (ACPI 5.0) */
+
+"LittleEndian"              { count (0); return (PARSEOP_ENDIAN_LITTLE); }
+"BigEndian"                 { count (0); return (PARSEOP_ENDIAN_BIG); }
+
+    /* ExtendedAttribKeyword: Bus attributes, AccessAs operator (ACPI 5.0) */
+
+"AttribBytes"               { count (0); return (PARSEOP_ACCESSATTRIB_MULTIBYTE); }
+"AttribRawBytes"            { count (0); return (PARSEOP_ACCESSATTRIB_RAW_BYTES); }
+"AttribRawProcessBytes"     { count (0); return (PARSEOP_ACCESSATTRIB_RAW_PROCESS); }
+
+    /* FlowControlKeyword: Resource Descriptors (ACPI 5.0) */
+
+"FlowControlHardware"       { count (0); return (PARSEOP_FLOWCONTROL_HW); }
+"FlowControlNone"           { count (0); return (PARSEOP_FLOWCONTROL_NONE); }
+"FlowControlXon"            { count (0); return (PARSEOP_FLOWCONTROL_SW); }
+
+    /* InterruptLevelKeyword: Interrupt Active Types */
+
+"ActiveBoth"                { count (0); return (PARSEOP_INTLEVEL_ACTIVEBOTH); }
+"ActiveHigh"                { count (0); return (PARSEOP_INTLEVEL_ACTIVEHIGH); }
+"ActiveLow"                 { count (0); return (PARSEOP_INTLEVEL_ACTIVELOW); }
+
+    /* InterruptTypeKeyword: Interrupt Types */
+
+"Edge"                      { count (0); return (PARSEOP_INTTYPE_EDGE); }
+"Level"                     { count (0); return (PARSEOP_INTTYPE_LEVEL); }
+
+    /* IoDecodeKeyword: Type of Memory Decoding - Resource Descriptors */
+
+"Decode10"                  { count (0); return (PARSEOP_IODECODETYPE_10); }
+"Decode16"                  { count (0); return (PARSEOP_IODECODETYPE_16); }
+
+    /* IoRestrictionKeyword: I/O Restriction - GPIO Resource Descriptors (ACPI 5.0) */
+
+"IoRestrictionNone"         { count (0); return (PARSEOP_IORESTRICT_NONE); }
+"IoRestrictionInputOnly"    { count (0); return (PARSEOP_IORESTRICT_IN); }
+"IoRestrictionOutputOnly"   { count (0); return (PARSEOP_IORESTRICT_OUT); }
+"IoRestrictionNoneAndPreserve"   { count (0); return (PARSEOP_IORESTRICT_PRESERVE); }
+
+    /* LockRuleKeyword: Global Lock use for Field Operator */
+
+"Lock"                      { count (0); return (PARSEOP_LOCKRULE_LOCK); }
+"NoLock"                    { count (0); return (PARSEOP_LOCKRULE_NOLOCK); }
+
+    /* MatchOpKeyword: Types for Match Operator */
+
+"MTR"                       { count (0); return (PARSEOP_MATCHTYPE_MTR); }
+"MEQ"                       { count (0); return (PARSEOP_MATCHTYPE_MEQ); }
+"MLE"                       { count (0); return (PARSEOP_MATCHTYPE_MLE); }
+"MLT"                       { count (0); return (PARSEOP_MATCHTYPE_MLT); }
+"MGE"                       { count (0); return (PARSEOP_MATCHTYPE_MGE); }
+"MGT"                       { count (0); return (PARSEOP_MATCHTYPE_MGT); }
+
+    /* MaxKeyword: Max Range Type - Resource Descriptors */
+
+"MaxFixed"                  { count (0); return (PARSEOP_MAXTYPE_FIXED); }
+"MaxNotFixed"               { count (0); return (PARSEOP_MAXTYPE_NOTFIXED); }
+
+    /* MemTypeKeyword: Memory Types - Resource Descriptors */
+
+"Cacheable"                 { count (0); return (PARSEOP_MEMTYPE_CACHEABLE); }
+"WriteCombining"            { count (0); return (PARSEOP_MEMTYPE_WRITECOMBINING); }
+"Prefetchable"              { count (0); return (PARSEOP_MEMTYPE_PREFETCHABLE); }
+"NonCacheable"              { count (0); return (PARSEOP_MEMTYPE_NONCACHEABLE); }
+
+    /* MinKeyword: Min Range Type - Resource Descriptors */
+
+"MinFixed"                  { count (0); return (PARSEOP_MINTYPE_FIXED); }
+"MinNotFixed"               { count (0); return (PARSEOP_MINTYPE_NOTFIXED); }
+
+    /* ObjectTypeKeyword: ACPI Object Types */
+
+"UnknownObj"                { count (0); return (PARSEOP_OBJECTTYPE_UNK); }
+"IntObj"                    { count (0); return (PARSEOP_OBJECTTYPE_INT); }
+"StrObj"                    { count (0); return (PARSEOP_OBJECTTYPE_STR); }
+"BuffObj"                   { count (0); return (PARSEOP_OBJECTTYPE_BUF); }
+"PkgObj"                    { count (0); return (PARSEOP_OBJECTTYPE_PKG); }
+"FieldUnitObj"              { count (0); return (PARSEOP_OBJECTTYPE_FLD); }
+"DeviceObj"                 { count (0); return (PARSEOP_OBJECTTYPE_DEV); }
+"EventObj"                  { count (0); return (PARSEOP_OBJECTTYPE_EVT); }
+"MethodObj"                 { count (0); return (PARSEOP_OBJECTTYPE_MTH); }
+"MutexObj"                  { count (0); return (PARSEOP_OBJECTTYPE_MTX); }
+"OpRegionObj"               { count (0); return (PARSEOP_OBJECTTYPE_OPR); }
+"PowerResObj"               { count (0); return (PARSEOP_OBJECTTYPE_POW); }
+"ProcessorObj"              { count (0); return (PARSEOP_OBJECTTYPE_PRO); }
+"ThermalZoneObj"            { count (0); return (PARSEOP_OBJECTTYPE_THZ); }
+"BuffFieldObj"              { count (0); return (PARSEOP_OBJECTTYPE_BFF); }
+"DDBHandleObj"              { count (0); return (PARSEOP_OBJECTTYPE_DDB); }
+
+    /* ParityKeyword: Resource Descriptors (ACPI 5.0) */
+
+"ParityTypeSpace"           { count (0); return (PARSEOP_PARITYTYPE_SPACE); }
+"ParityTypeMark"            { count (0); return (PARSEOP_PARITYTYPE_MARK); }
+"ParityTypeOdd"             { count (0); return (PARSEOP_PARITYTYPE_ODD); }
+"ParityTypeEven"            { count (0); return (PARSEOP_PARITYTYPE_EVEN); }
+"ParityTypeNone"            { count (0); return (PARSEOP_PARITYTYPE_NONE); }
+
+    /* PinConfigKeyword: Pin Configuration - GPIO Resource Descriptors (ACPI 5.0) */
+
+"PullDefault"               { count (0); return (PARSEOP_PIN_PULLDEFAULT); }
+"PullUp"                    { count (0); return (PARSEOP_PIN_PULLUP); }
+"PullDown"                  { count (0); return (PARSEOP_PIN_PULLDOWN); }
+"PullNone"                  { count (0); return (PARSEOP_PIN_NOPULL); }
+
+    /* PolarityKeyword: Resource Descriptors (ACPI 5.0) */
+
+"PolarityLow"               { count (0); return (PARSEOP_DEVICEPOLARITY_LOW); }
+"PolarityHigh"              { count (0); return (PARSEOP_DEVICEPOLARITY_HIGH); }
+
+    /* RangeTypeKeyword: I/O Range Types - Resource Descriptors */
+
+"ISAOnlyRanges"             { count (0); return (PARSEOP_RANGETYPE_ISAONLY); }
+"NonISAOnlyRanges"          { count (0); return (PARSEOP_RANGETYPE_NONISAONLY); }
+"EntireRange"               { count (0); return (PARSEOP_RANGETYPE_ENTIRE); }
+
+    /* ReadWriteKeyword: Memory Access Types - Resource Descriptors */
+
+"ReadWrite"                 { count (0); return (PARSEOP_READWRITETYPE_BOTH); }
+"ReadOnly"                  { count (0); return (PARSEOP_READWRITETYPE_READONLY); }
+
+    /* RegionSpaceKeyword: Operation Region Address Space Types */
+
+"SystemIO"                  { count (0); return (PARSEOP_REGIONSPACE_IO); }
+"SystemMemory"              { count (0); return (PARSEOP_REGIONSPACE_MEM); }
+"PCI_Config"                { count (0); return (PARSEOP_REGIONSPACE_PCI); }
+"EmbeddedControl"           { count (0); return (PARSEOP_REGIONSPACE_EC); }
+"SMBus"                     { count (0); return (PARSEOP_REGIONSPACE_SMBUS); }
+"SystemCMOS"                { count (0); return (PARSEOP_REGIONSPACE_CMOS); }
+"PciBarTarget"              { count (0); return (PARSEOP_REGIONSPACE_PCIBAR); }
+"IPMI"                      { count (0); return (PARSEOP_REGIONSPACE_IPMI); }
+"GeneralPurposeIo"          { count (0); return (PARSEOP_REGIONSPACE_GPIO); }       /* ACPI 5.0 */
+"GenericSerialBus"          { count (0); return (PARSEOP_REGIONSPACE_GSBUS); }      /* ACPI 5.0 */
+"PCC"                       { count (0); return (PARSEOP_REGIONSPACE_PCC); }        /* ACPI 5.0 */
+"FFixedHW"                  { count (0); return (PARSEOP_REGIONSPACE_FFIXEDHW); }
+
+    /* ResourceTypeKeyword: Resource Usage - Resource Descriptors */
+
+"ResourceConsumer"          { count (0); return (PARSEOP_RESOURCETYPE_CONSUMER); }
+"ResourceProducer"          { count (0); return (PARSEOP_RESOURCETYPE_PRODUCER); }
+
+    /* SerializeRuleKeyword: Control Method Serialization */
+
+"Serialized"                { count (0); return (PARSEOP_SERIALIZERULE_SERIAL); }
+"NotSerialized"             { count (0); return (PARSEOP_SERIALIZERULE_NOTSERIAL); }
+
+    /* ShareTypeKeyword: Interrupt Sharing - Resource Descriptors */
+
+"Shared"                    { count (0); return (PARSEOP_SHARETYPE_SHARED); }
+"Exclusive"                 { count (0); return (PARSEOP_SHARETYPE_EXCLUSIVE); }
+"SharedAndWake"             { count (0); return (PARSEOP_SHARETYPE_SHAREDWAKE); }       /* ACPI 5.0 */
+"ExclusiveAndWake"          { count (0); return (PARSEOP_SHARETYPE_EXCLUSIVEWAKE); }    /* ACPI 5.0 */
+
+    /* SlaveModeKeyword: Resource Descriptors (ACPI 5.0) */
+
+"ControllerInitiated"       { count (0); return (PARSEOP_SLAVEMODE_CONTROLLERINIT); }
+"DeviceInitiated"           { count (0); return (PARSEOP_SLAVEMODE_DEVICEINIT); }
+
+    /* StopBitsKeyword: Resource Descriptors (ACPI 5.0) */
+
+"StopBitsOne"               { count (0); return (PARSEOP_STOPBITS_ONE); }
+"StopBitsOnePlusHalf"       { count (0); return (PARSEOP_STOPBITS_ONEPLUSHALF); }
+"StopBitsTwo"               { count (0); return (PARSEOP_STOPBITS_TWO); }
+"StopBitsZero"              { count (0); return (PARSEOP_STOPBITS_ZERO); }
+
+    /* TransferWidthKeyword: DMA Widths - Fixed DMA Resource Descriptor (ACPI 5.0) */
+
+"Width8bit"                 { count (0); return (PARSEOP_XFERSIZE_8); }
+"Width16bit"                { count (0); return (PARSEOP_XFERSIZE_16); }
+"Width32bit"                { count (0); return (PARSEOP_XFERSIZE_32); }
+"Width64bit"                { count (0); return (PARSEOP_XFERSIZE_64); }
+"Width128bit"               { count (0); return (PARSEOP_XFERSIZE_128); }
+"Width256bit"               { count (0); return (PARSEOP_XFERSIZE_256); }
+
+    /* TranslationKeyword: Translation Density Types - Resource Descriptors */
+
+"SparseTranslation"         { count (0); return (PARSEOP_TRANSLATIONTYPE_SPARSE); }
+"DenseTranslation"          { count (0); return (PARSEOP_TRANSLATIONTYPE_DENSE); }
+
+    /* TypeKeyword: Translation Types - Resource Descriptors */
+
+"TypeTranslation"           { count (0); return (PARSEOP_TYPE_TRANSLATION); }
+"TypeStatic"                { count (0); return (PARSEOP_TYPE_STATIC); }
+
+    /* UpdateRuleKeyword: Field Update Rules */
+
+"Preserve"                  { count (0); return (PARSEOP_UPDATERULE_PRESERVE); }
+"WriteAsOnes"               { count (0); return (PARSEOP_UPDATERULE_ONES); }
+"WriteAsZeros"              { count (0); return (PARSEOP_UPDATERULE_ZEROS); }
+
+    /* WireModeKeyword: SPI Wire Mode - Resource Descriptors (ACPI 5.0) */
+
+"FourWireMode"              { count (0); return (PARSEOP_WIREMODE_FOUR); }
+"ThreeWireMode"             { count (0); return (PARSEOP_WIREMODE_THREE); }
+
+    /* XferTypeKeyword: DMA Transfer Types */
+
+"Transfer8"                 { count (0); return (PARSEOP_XFERTYPE_8); }
+"Transfer8_16"              { count (0); return (PARSEOP_XFERTYPE_8_16); }
+"Transfer16"                { count (0); return (PARSEOP_XFERTYPE_16); }
+
+    /* ToPld macro */
+
+"ToPLD"                     { count (0); return (PARSEOP_TOPLD); }
+
+"PLD_Revision"              { count (0); return (PARSEOP_PLD_REVISION); }
+"PLD_IgnoreColor"           { count (0); return (PARSEOP_PLD_IGNORECOLOR); }
+"PLD_Red"                   { count (0); return (PARSEOP_PLD_RED); }
+"PLD_Green"                 { count (0); return (PARSEOP_PLD_GREEN); }
+"PLD_Blue"                  { count (0); return (PARSEOP_PLD_BLUE); }
+"PLD_Width"                 { count (0); return (PARSEOP_PLD_WIDTH); }
+"PLD_Height"                { count (0); return (PARSEOP_PLD_HEIGHT); }
+"PLD_UserVisible"           { count (0); return (PARSEOP_PLD_USERVISIBLE); }
+"PLD_Dock"                  { count (0); return (PARSEOP_PLD_DOCK); }
+"PLD_Lid"                   { count (0); return (PARSEOP_PLD_LID); }
+"PLD_Panel"                 { count (0); return (PARSEOP_PLD_PANEL); }
+"PLD_VerticalPosition"      { count (0); return (PARSEOP_PLD_VERTICALPOSITION); }
+"PLD_HorizontalPosition"    { count (0); return (PARSEOP_PLD_HORIZONTALPOSITION); }
+"PLD_Shape"                 { count (0); return (PARSEOP_PLD_SHAPE); }
+"PLD_GroupOrientation"      { count (0); return (PARSEOP_PLD_GROUPORIENTATION); }
+"PLD_GroupToken"            { count (0); return (PARSEOP_PLD_GROUPTOKEN); }
+"PLD_GroupPosition"         { count (0); return (PARSEOP_PLD_GROUPPOSITION); }
+"PLD_Bay"                   { count (0); return (PARSEOP_PLD_BAY); }
+"PLD_Ejectable"             { count (0); return (PARSEOP_PLD_EJECTABLE); }
+"PLD_EjectRequired"         { count (0); return (PARSEOP_PLD_EJECTREQUIRED); }
+"PLD_CabinetNumber"         { count (0); return (PARSEOP_PLD_CABINETNUMBER); }
+"PLD_CardCageNumber"        { count (0); return (PARSEOP_PLD_CARDCAGENUMBER); }
+"PLD_Reference"             { count (0); return (PARSEOP_PLD_REFERENCE); }
+"PLD_Rotation"              { count (0); return (PARSEOP_PLD_ROTATION); }
+"PLD_Order"                 { count (0); return (PARSEOP_PLD_ORDER); }
+"PLD_Reserved"              { count (0); return (PARSEOP_PLD_RESERVED); }
+"PLD_VerticalOffset"        { count (0); return (PARSEOP_PLD_VERTICALOFFSET); }
+"PLD_HorizontalOffset"      { count (0); return (PARSEOP_PLD_HORIZONTALOFFSET); }
+
+
+    /* printf debug macros */
+
+"printf"                    { count (0); return (PARSEOP_PRINTF); }
+"fprintf"                   { count (0); return (PARSEOP_FPRINTF); }
+
+    /* Other macros */
+
+"For"                       { count (0); return (PARSEOP_FOR); }
+
+    /* Predefined compiler names */
+
+"__DATE__"                  { count (0); return (PARSEOP___DATE__); }
+"__FILE__"                  { count (0); return (PARSEOP___FILE__); }
+"__LINE__"                  { count (0); return (PARSEOP___LINE__); }
+"__PATH__"                  { count (0); return (PARSEOP___PATH__); }
+
+
+"{"                         { count (0); return('{'); }
+"}"                         { count (0); return('}'); }
+","                         { count (0); return(','); }
+"("                         { count (0); return('('); }
+")"                         { count (0); return(')'); }
+
+{NameSeg}                   { char *s;
+                                count (0);
+                                s=UtStringCacheCalloc (ACPI_NAME_SIZE + 1);
+                                if (strcmp (AslCompilertext, "\\"))
+                                {
+                                    strcpy (s, "____");
+                                    AcpiUtStrupr (AslCompilertext);
+                                }
+                                memcpy (s, AslCompilertext, strlen (AslCompilertext));
+                                AslCompilerlval.s = s;
+                                DbgPrint (ASL_PARSE_OUTPUT, "NameSeg: %s\n", s);
+                                return (PARSEOP_NAMESEG); }
+
+{NameString}                { char *s;
+                                count (0);
+                                s=UtStringCacheCalloc (strlen (AslCompilertext)+1);
+                                AcpiUtStrupr (AslCompilertext);
+                                strcpy (s, AslCompilertext);
+                                AslCompilerlval.s = s;
+                                DbgPrint (ASL_PARSE_OUTPUT, "NameString: %s\n", s);
+                                return (PARSEOP_NAMESTRING); }
+
+.                           { count (1);
+                                if (isprint ((int) *AslCompilertext))
+                                {
+                                    sprintf (MsgBuffer,
+                                        "Invalid character (%c), expecting ASL keyword or name",
+                                        *AslCompilertext);
+                                }
+                                else
+                                {
+                                    sprintf (MsgBuffer,
+                                        "Invalid character (0x%2.2X), expecting ASL keyword or name",
+                                        *AslCompilertext);
+                                }
+                                AslCompilererror (MsgBuffer);}
+
+<<EOF>>                     { if (AslPopInputFileStack ())
+                                {yyterminate();}
+                              else
+                                {return (PARSEOP_INCLUDE_END);} };
+
+%%
+
+/*! [End] no source code translation !*/
+
+/*
+ * Bring in the scanner support routines
+ */
+#include "aslsupport.l"
diff --git a/usr/src/cmd/acpi/iasl/aslcstyle.y b/usr/src/cmd/acpi/iasl/aslcstyle.y
new file mode 100644
index 0000000000..62a7b65f76
--- /dev/null
+++ b/usr/src/cmd/acpi/iasl/aslcstyle.y
@@ -0,0 +1,209 @@
+NoEcho('
+/******************************************************************************
+ *
+ * Module Name: aslcstyle.y - Production rules for symbolic operators
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2016, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+')
+
+/*******************************************************************************
+ *
+ * Production rules for the symbolic (c-style) operators
+ *
+ ******************************************************************************/
+
+/*
+ * ASL Extensions: C-style math/logical operators and expressions.
+ * The implementation transforms these operators into the standard
+ * AML opcodes and syntax.
+ *
+ * Supported operators and precedence rules (high-to-low)
+ *
+ * NOTE: The operator precedence and associativity rules are
+ * implemented by the tokens in asltokens.y
+ *
+ * (left-to-right):
+ *  1)      ( ) expr++ expr--
+ *
+ * (right-to-left):
+ *  2)      ! ~
+ *
+ * (left-to-right):
+ *  3)      *   /   %
+ *  4)      +   -
+ *  5)      >>  <<
+ *  6)      <   >   <=  >=
+ *  7)      ==  !=
+ *  8)      &
+ *  9)      ^
+ *  10)     |
+ *  11)     &&
+ *  12)     ||
+ *
+ * (right-to-left):
+ *  13)     = += -= *= /= %= <<= >>= &= ^= |=
+ */
+
+Expression
+
+    /* Unary operators */
+
+    : PARSEOP_EXP_LOGICAL_NOT           {$<n>$ = TrCreateLeafNode (PARSEOP_LNOT);}
+        TermArg                         {$$ = TrLinkChildren ($<n>2,1,$3);}
+    | PARSEOP_EXP_NOT                   {$<n>$ = TrCreateLeafNode (PARSEOP_NOT);}
+        TermArg                         {$$ = TrLinkChildren ($<n>2,2,$3,TrCreateNullTarget ());}
+
+    | SuperName PARSEOP_EXP_INCREMENT   {$<n>$ = TrCreateLeafNode (PARSEOP_INCREMENT);}
+                                        {$$ = TrLinkChildren ($<n>3,1,$1);}
+    | SuperName PARSEOP_EXP_DECREMENT   {$<n>$ = TrCreateLeafNode (PARSEOP_DECREMENT);}
+                                        {$$ = TrLinkChildren ($<n>3,1,$1);}
+
+    /* Binary operators: math and logical */
+
+    | TermArg PARSEOP_EXP_ADD           {$<n>$ = TrCreateLeafNode (PARSEOP_ADD);}
+        TermArg                         {$$ = TrLinkChildren ($<n>3,3,$1,$4,TrCreateNullTarget ());}
+    | TermArg PARSEOP_EXP_DIVIDE        {$<n>$ = TrCreateLeafNode (PARSEOP_DIVIDE);}
+        TermArg                         {$$ = TrLinkChildren ($<n>3,4,$1,$4,TrCreateNullTarget (),
+                                            TrCreateNullTarget ());}
+    | TermArg PARSEOP_EXP_MODULO        {$<n>$ = TrCreateLeafNode (PARSEOP_MOD);}
+        TermArg                         {$$ = TrLinkChildren ($<n>3,3,$1,$4,TrCreateNullTarget ());}
+    | TermArg PARSEOP_EXP_MULTIPLY      {$<n>$ = TrCreateLeafNode (PARSEOP_MULTIPLY);}
+        TermArg                         {$$ = TrLinkChildren ($<n>3,3,$1,$4,TrCreateNullTarget ());}
+    | TermArg PARSEOP_EXP_SHIFT_LEFT    {$<n>$ = TrCreateLeafNode (PARSEOP_SHIFTLEFT);}
+        TermArg                         {$$ = TrLinkChildren ($<n>3,3,$1,$4,TrCreateNullTarget ());}
+    | TermArg PARSEOP_EXP_SHIFT_RIGHT   {$<n>$ = TrCreateLeafNode (PARSEOP_SHIFTRIGHT);}
+        TermArg                         {$$ = TrLinkChildren ($<n>3,3,$1,$4,TrCreateNullTarget ());}
+    | TermArg PARSEOP_EXP_SUBTRACT      {$<n>$ = TrCreateLeafNode (PARSEOP_SUBTRACT);}
+        TermArg                         {$$ = TrLinkChildren ($<n>3,3,$1,$4,TrCreateNullTarget ());}
+
+    | TermArg PARSEOP_EXP_AND           {$<n>$ = TrCreateLeafNode (PARSEOP_AND);}
+        TermArg                         {$$ = TrLinkChildren ($<n>3,3,$1,$4,TrCreateNullTarget ());}
+    | TermArg PARSEOP_EXP_OR            {$<n>$ = TrCreateLeafNode (PARSEOP_OR);}
+        TermArg                         {$$ = TrLinkChildren ($<n>3,3,$1,$4,TrCreateNullTarget ());}
+    | TermArg PARSEOP_EXP_XOR           {$<n>$ = TrCreateLeafNode (PARSEOP_XOR);}
+        TermArg                         {$$ = TrLinkChildren ($<n>3,3,$1,$4,TrCreateNullTarget ());}
+
+    | TermArg PARSEOP_EXP_GREATER       {$<n>$ = TrCreateLeafNode (PARSEOP_LGREATER);}
+        TermArg                         {$$ = TrLinkChildren ($<n>3,2,$1,$4);}
+    | TermArg PARSEOP_EXP_GREATER_EQUAL {$<n>$ = TrCreateLeafNode (PARSEOP_LGREATEREQUAL);}
+        TermArg                         {$$ = TrLinkChildren ($<n>3,2,$1,$4);}
+    | TermArg PARSEOP_EXP_LESS          {$<n>$ = TrCreateLeafNode (PARSEOP_LLESS);}
+        TermArg                         {$$ = TrLinkChildren ($<n>3,2,$1,$4);}
+    | TermArg PARSEOP_EXP_LESS_EQUAL    {$<n>$ = TrCreateLeafNode (PARSEOP_LLESSEQUAL);}
+        TermArg                         {$$ = TrLinkChildren ($<n>3,2,$1,$4);}
+
+    | TermArg PARSEOP_EXP_EQUAL         {$<n>$ = TrCreateLeafNode (PARSEOP_LEQUAL);}
+        TermArg                         {$$ = TrLinkChildren ($<n>3,2,$1,$4);}
+    | TermArg PARSEOP_EXP_NOT_EQUAL     {$<n>$ = TrCreateLeafNode (PARSEOP_LNOTEQUAL);}
+        TermArg                         {$$ = TrLinkChildren ($<n>3,2,$1,$4);}
+
+    | TermArg PARSEOP_EXP_LOGICAL_AND   {$<n>$ = TrCreateLeafNode (PARSEOP_LAND);}
+        TermArg                         {$$ = TrLinkChildren ($<n>3,2,$1,$4);}
+    | TermArg PARSEOP_EXP_LOGICAL_OR    {$<n>$ = TrCreateLeafNode (PARSEOP_LOR);}
+        TermArg                         {$$ = TrLinkChildren ($<n>3,2,$1,$4);}
+
+        /* Parentheses */
+
+    | '(' TermArg ')'                   { $$ = $2;}
+
+        /* Index term -- "= BUF1[5]" on right-hand side of an equals (source) */
+
+    | SuperName PARSEOP_EXP_INDEX_LEFT TermArg PARSEOP_EXP_INDEX_RIGHT
+                                        {$$ = TrCreateLeafNode (PARSEOP_INDEX);
+                                        TrLinkChildren ($$,3,$1,$3,TrCreateNullTarget ());}
+    ;
+
+        /* Index term -- "BUF1[5] = " on left-hand side of an equals (target) */
+
+IndexExpTerm
+
+    : SuperName PARSEOP_EXP_INDEX_LEFT TermArg PARSEOP_EXP_INDEX_RIGHT
+                                        {$$ = TrCreateLeafNode (PARSEOP_INDEX);
+                                        TrLinkChildren ($$,3,$1,$3,TrCreateNullTarget ());}
+    ;
+
+EqualsTerm
+
+    /* All assignment-type operations */
+
+    : SuperName PARSEOP_EXP_EQUALS
+        TermArg                         {$$ = TrCreateAssignmentNode ($1, $3);}
+
+    | TermArg PARSEOP_EXP_ADD_EQ        {$<n>$ = TrCreateLeafNode (PARSEOP_ADD);}
+        TermArg                         {$$ = TrLinkChildren ($<n>3,3,$1,$4,
+                                            TrSetNodeFlags (TrCreateTargetOperand ($1, NULL), NODE_IS_TARGET));}
+
+    | TermArg PARSEOP_EXP_DIV_EQ        {$<n>$ = TrCreateLeafNode (PARSEOP_DIVIDE);}
+        TermArg                         {$$ = TrLinkChildren ($<n>3,4,$1,$4,TrCreateNullTarget (),
+                                            TrSetNodeFlags (TrCreateTargetOperand ($1, NULL), NODE_IS_TARGET));}
+
+    | TermArg PARSEOP_EXP_MOD_EQ        {$<n>$ = TrCreateLeafNode (PARSEOP_MOD);}
+        TermArg                         {$$ = TrLinkChildren ($<n>3,3,$1,$4,
+                                            TrSetNodeFlags (TrCreateTargetOperand ($1, NULL), NODE_IS_TARGET));}
+
+    | TermArg PARSEOP_EXP_MUL_EQ        {$<n>$ = TrCreateLeafNode (PARSEOP_MULTIPLY);}
+        TermArg                         {$$ = TrLinkChildren ($<n>3,3,$1,$4,
+                                            TrSetNodeFlags (TrCreateTargetOperand ($1, NULL), NODE_IS_TARGET));}
+
+    | TermArg PARSEOP_EXP_SHL_EQ        {$<n>$ = TrCreateLeafNode (PARSEOP_SHIFTLEFT);}
+        TermArg                         {$$ = TrLinkChildren ($<n>3,3,$1,$4,
+                                            TrSetNodeFlags (TrCreateTargetOperand ($1, NULL), NODE_IS_TARGET));}
+
+    | TermArg PARSEOP_EXP_SHR_EQ        {$<n>$ = TrCreateLeafNode (PARSEOP_SHIFTRIGHT);}
+        TermArg                         {$$ = TrLinkChildren ($<n>3,3,$1,$4,
+                                            TrSetNodeFlags (TrCreateTargetOperand ($1, NULL), NODE_IS_TARGET));}
+
+    | TermArg PARSEOP_EXP_SUB_EQ        {$<n>$ = TrCreateLeafNode (PARSEOP_SUBTRACT);}
+        TermArg                         {$$ = TrLinkChildren ($<n>3,3,$1,$4,
+                                            TrSetNodeFlags (TrCreateTargetOperand ($1, NULL), NODE_IS_TARGET));}
+
+    | TermArg PARSEOP_EXP_AND_EQ        {$<n>$ = TrCreateLeafNode (PARSEOP_AND);}
+        TermArg                         {$$ = TrLinkChildren ($<n>3,3,$1,$4,
+                                            TrSetNodeFlags (TrCreateTargetOperand ($1, NULL), NODE_IS_TARGET));}
+
+    | TermArg PARSEOP_EXP_OR_EQ         {$<n>$ = TrCreateLeafNode (PARSEOP_OR);}
+        TermArg                         {$$ = TrLinkChildren ($<n>3,3,$1,$4,
+                                            TrSetNodeFlags (TrCreateTargetOperand ($1, NULL), NODE_IS_TARGET));}
+
+    | TermArg PARSEOP_EXP_XOR_EQ        {$<n>$ = TrCreateLeafNode (PARSEOP_XOR);}
+        TermArg                         {$$ = TrLinkChildren ($<n>3,3,$1,$4,
+                                            TrSetNodeFlags (TrCreateTargetOperand ($1, NULL), NODE_IS_TARGET));}
+    ;
diff --git a/usr/src/cmd/acpi/iasl/asldebug.c b/usr/src/cmd/acpi/iasl/asldebug.c
new file mode 100644
index 0000000000..6ba60668b1
--- /dev/null
+++ b/usr/src/cmd/acpi/iasl/asldebug.c
@@ -0,0 +1,253 @@
+/******************************************************************************
+ *
+ * Module Name: asldebug -- Debug output support
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2016, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include "aslcompiler.h"
+#include "aslcompiler.y.h"
+
+
+#define _COMPONENT          ACPI_COMPILER
+        ACPI_MODULE_NAME    ("asldebug")
+
+
+/* Local prototypes */
+
+static void
+UtDumpParseOpName (
+    ACPI_PARSE_OBJECT       *Op,
+    UINT32                  Level,
+    UINT32                  DataLength);
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    UtDumpIntegerOp
+ *
+ * PARAMETERS:  Op                  - Current parse op
+ *              Level               - Current output indentation level
+ *              IntegerLength       - Output length of the integer (2/4/8/16)
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Emit formatted debug output for "integer" ops.
+ *              Note: IntegerLength must be one of 2,4,8,16.
+ *
+ ******************************************************************************/
+
+void
+UtDumpIntegerOp (
+    ACPI_PARSE_OBJECT       *Op,
+    UINT32                  Level,
+    UINT32                  IntegerLength)
+{
+
+    /* Emit the ParseOp name, leaving room for the integer */
+
+    UtDumpParseOpName (Op, Level, IntegerLength);
+
+    /* Emit the integer based upon length */
+
+    switch (IntegerLength)
+    {
+    case 2: /* Byte */
+    case 4: /* Word */
+    case 8: /* Dword */
+
+        DbgPrint (ASL_TREE_OUTPUT,
+            "%*.*X", IntegerLength, IntegerLength, Op->Asl.Value.Integer);
+        break;
+
+    case 16: /* Qword and Integer */
+
+        DbgPrint (ASL_TREE_OUTPUT,
+            "%8.8X%8.8X", ACPI_FORMAT_UINT64 (Op->Asl.Value.Integer));
+        break;
+
+    default:
+        break;
+    }
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    UtDumpStringOp
+ *
+ * PARAMETERS:  Op                  - Current parse op
+ *              Level               - Current output indentation level
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Emit formatted debug output for String/Pathname ops.
+ *
+ ******************************************************************************/
+
+void
+UtDumpStringOp (
+    ACPI_PARSE_OBJECT       *Op,
+    UINT32                  Level)
+{
+    char                    *String;
+
+
+    String = Op->Asl.Value.String;
+
+    if (Op->Asl.ParseOpcode != PARSEOP_STRING_LITERAL)
+    {
+        /*
+         * For the "path" ops NAMEPATH, NAMESEG, METHODCALL -- if the
+         * ExternalName is valid, it takes precedence. In these cases the
+         * Value.String is the raw "internal" name from the AML code, which
+         * we don't want to use, because it contains non-ascii characters.
+         */
+        if (Op->Asl.ExternalName)
+        {
+            String = Op->Asl.ExternalName;
+        }
+    }
+
+    if (!String)
+    {
+        DbgPrint (ASL_TREE_OUTPUT,
+            " ERROR: Could not find a valid String/Path pointer\n");
+        return;
+    }
+
+    /* Emit the ParseOp name, leaving room for the string */
+
+    UtDumpParseOpName (Op, Level, strlen (String));
+    DbgPrint (ASL_TREE_OUTPUT, "%s", String);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    UtDumpBasicOp
+ *
+ * PARAMETERS:  Op                  - Current parse op
+ *              Level               - Current output indentation level
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Generic formatted debug output for "basic" ops that have no
+ *              associated strings or integer values.
+ *
+ ******************************************************************************/
+
+void
+UtDumpBasicOp (
+    ACPI_PARSE_OBJECT       *Op,
+    UINT32                  Level)
+{
+
+    /* Just print out the ParseOp name, there is no extra data */
+
+    UtDumpParseOpName (Op, Level, 0);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    UtDumpParseOpName
+ *
+ * PARAMETERS:  Op                  - Current parse op
+ *              Level               - Current output indentation level
+ *              DataLength          - Length of data to appear after the name
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Indent and emit the ascii ParseOp name for the op
+ *
+ ******************************************************************************/
+
+static void
+UtDumpParseOpName (
+    ACPI_PARSE_OBJECT       *Op,
+    UINT32                  Level,
+    UINT32                  DataLength)
+{
+    char                    *ParseOpName;
+    UINT32                  IndentLength;
+    UINT32                  NameLength;
+    UINT32                  LineLength;
+    UINT32                  PaddingLength;
+
+
+    /* Emit the LineNumber/IndentLevel prefix on each output line */
+
+    DbgPrint (ASL_TREE_OUTPUT,
+        "%5.5d [%2d]", Op->Asl.LogicalLineNumber, Level);
+
+    ParseOpName = UtGetOpName (Op->Asl.ParseOpcode);
+
+    /* Calculate various lengths for output alignment */
+
+    IndentLength = Level * DEBUG_SPACES_PER_INDENT;
+    NameLength = strlen (ParseOpName);
+    LineLength = IndentLength + 1 + NameLength + 1 + DataLength;
+    PaddingLength = (DEBUG_MAX_LINE_LENGTH + 1) - LineLength;
+
+    /* Parse tree indentation is based upon the nesting/indent level */
+
+    if (Level)
+    {
+        DbgPrint (ASL_TREE_OUTPUT, "%*s", IndentLength, " ");
+    }
+
+    /* Emit the actual name here */
+
+    DbgPrint (ASL_TREE_OUTPUT, " %s", ParseOpName);
+
+    /* Emit extra padding blanks for alignment of later data items */
+
+    if (LineLength > DEBUG_MAX_LINE_LENGTH)
+    {
+        /* Split a long line immediately after the ParseOpName string */
+
+        DbgPrint (ASL_TREE_OUTPUT, "\n%*s",
+            (DEBUG_FULL_LINE_LENGTH - DataLength), " ");
+    }
+    else
+    {
+        DbgPrint (ASL_TREE_OUTPUT, "%*s", PaddingLength, " ");
+    }
+}
diff --git a/usr/src/cmd/acpi/iasl/asldefine.h b/usr/src/cmd/acpi/iasl/asldefine.h
new file mode 100644
index 0000000000..f615cb2195
--- /dev/null
+++ b/usr/src/cmd/acpi/iasl/asldefine.h
@@ -0,0 +1,188 @@
+/******************************************************************************
+ *
+ * Module Name: asldefine.h - Common defines for the iASL compiler
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2016, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#ifndef __ASLDEFINE_H
+#define __ASLDEFINE_H
+
+
+/*
+ * Compiler versions and names
+ */
+#define ASL_COMPILER_NAME           "ASL+ Optimizing Compiler"
+#define AML_DISASSEMBLER_NAME       "AML/ASL+ Disassembler"
+#define ASL_INVOCATION_NAME         "iasl"
+#define ASL_CREATOR_ID              "INTL"
+#define ASL_DEFINE                  "__IASL__"
+
+#define ASL_COMPLIANCE              "Supports ACPI Specification Revision 6.1"
+
+
+/* Configuration constants */
+
+#define ASL_MAX_ERROR_COUNT         200
+#define ASL_PARSEOP_CACHE_SIZE      (1024 * 16)
+#define ASL_STRING_CACHE_SIZE       (1024 * 64)
+
+#define ASL_FIRST_PARSE_OPCODE      PARSEOP_ACCESSAS
+#define ASL_PARSE_OPCODE_BASE       PARSEOP_ACCESSAS        /* First Lex type */
+
+
+/*
+ * Per-parser-generator configuration. These values are used to cheat and
+ * directly access the bison/yacc token name table (yyname or yytname).
+ * Note: These values are the index in yyname for the first lex token
+ * (PARSEOP_ACCCESSAS).
+ */
+#if defined (YYBISON)
+#define ASL_YYTNAME_START           3   /* Bison */
+#elif defined (YYBYACC)
+#define ASL_YYTNAME_START           257 /* Berkeley yacc */
+#endif
+
+
+/*
+ * Macros
+ */
+#define ASL_RESDESC_OFFSET(m)       ACPI_OFFSET (AML_RESOURCE, m)
+#define ASL_PTR_DIFF(a,b)           ((UINT8 *)(b) - (UINT8 *)(a))
+#define ASL_PTR_ADD(a,b)            ((UINT8 *)(a) = ((UINT8 *)(a) + (b)))
+#define ASL_GET_CHILD_NODE(a)       (a)->Asl.Child
+#define ASL_GET_PEER_NODE(a)        (a)->Asl.Next
+#define OP_TABLE_ENTRY(a,b,c,d)     {b,d,a,c}
+
+
+/* Internal AML opcodes */
+
+#define AML_RAW_DATA_BYTE           (UINT16) 0xAA01 /* write one raw byte */
+#define AML_RAW_DATA_WORD           (UINT16) 0xAA02 /* write 2 raw bytes */
+#define AML_RAW_DATA_DWORD          (UINT16) 0xAA04 /* write 4 raw bytes */
+#define AML_RAW_DATA_QWORD          (UINT16) 0xAA08 /* write 8 raw bytes */
+#define AML_RAW_DATA_BUFFER         (UINT16) 0xAA0B /* raw buffer with length */
+#define AML_RAW_DATA_CHAIN          (UINT16) 0xAA0C /* chain of raw buffers */
+#define AML_PACKAGE_LENGTH          (UINT16) 0xAA10
+#define AML_UNASSIGNED_OPCODE       (UINT16) 0xEEEE
+#define AML_DEFAULT_ARG_OP          (UINT16) 0xDDDD
+
+
+/* Types for input files */
+
+#define ASL_INPUT_TYPE_BINARY               0
+#define ASL_INPUT_TYPE_BINARY_ACPI_TABLE    1
+#define ASL_INPUT_TYPE_ASCII_ASL            2
+#define ASL_INPUT_TYPE_ASCII_DATA           3
+
+
+/* Misc */
+
+#define ASL_EXTERNAL_METHOD         255
+#define ASL_ABORT                   TRUE
+#define ASL_NO_ABORT                FALSE
+#define ASL_EOF                     ACPI_UINT32_MAX
+#define ASL_IGNORE_LINE            (ACPI_UINT32_MAX -1)
+
+
+/* Listings */
+
+#define ASL_LISTING_LINE_PREFIX         ":  "
+
+
+/* Support for reserved method names */
+
+#define ACPI_VALID_RESERVED_NAME_MAX    0x80000000
+#define ACPI_NOT_RESERVED_NAME          ACPI_UINT32_MAX
+#define ACPI_PREDEFINED_NAME            (ACPI_UINT32_MAX - 1)
+#define ACPI_EVENT_RESERVED_NAME        (ACPI_UINT32_MAX - 2)
+#define ACPI_COMPILER_RESERVED_NAME     (ACPI_UINT32_MAX - 3)
+
+
+/* Helper macros for resource tag creation */
+
+#define RsCreateMultiBitField \
+    RsCreateResourceField
+
+#define RsCreateBitField(Op, Name, ByteOffset, BitOffset) \
+    RsCreateResourceField (Op, Name, ByteOffset, BitOffset, 1)
+
+#define RsCreateByteField(Op, Name, ByteOffset) \
+    RsCreateResourceField (Op, Name, ByteOffset, 0, 8);
+
+#define RsCreateWordField(Op, Name, ByteOffset) \
+    RsCreateResourceField (Op, Name, ByteOffset, 0, 16);
+
+#define RsCreateDwordField(Op, Name, ByteOffset) \
+    RsCreateResourceField (Op, Name, ByteOffset, 0, 32);
+
+#define RsCreateQwordField(Op, Name, ByteOffset) \
+    RsCreateResourceField (Op, Name, ByteOffset, 0, 64);
+
+
+/*
+ * Macros for debug output
+ */
+
+#define DEBUG_MAX_LINE_LENGTH       61
+#define DEBUG_SPACES_PER_INDENT     3
+#define DEBUG_FULL_LINE_LENGTH      71
+
+#define ASL_PARSE_TREE_FULL_LINE    "\n%71.71s"
+
+/* Header/Trailer for original parse tree directly from the parser */
+
+#define ASL_PARSE_TREE_HEADER1 \
+    "%*s Value P_Op Flags     Line#  End# LogL# EndL#\n", 65, " "
+
+#define ASL_PARSE_TREE_DEBUG1 \
+    " %4.4X %8.8X %5d %5d %5d %5d"
+
+/* Header/Trailer for processed parse tree used for AML generation */
+
+#define ASL_PARSE_TREE_HEADER2 \
+    "%*s NameString Value    P_Op A_Op OpLen PByts Len  SubLen PSubLen OpPtr"\
+    "    Parent   Child    Next     Flags    AcTyp    Final Col"\
+    " Line#  End# LogL# EndL#\n", 60, " "
+
+#define ASL_PARSE_TREE_DEBUG2 \
+    " %08X %04X %04X %01X     %04X  %04X %05X  %05X   "\
+    "%08X %08X %08X %08X %08X %08X %04X  %02d  %5d %5d %5d %5d\n"
+
+#endif /* ASLDEFINE.H */
diff --git a/usr/src/cmd/acpi/iasl/aslerror.c b/usr/src/cmd/acpi/iasl/aslerror.c
new file mode 100644
index 0000000000..dfb6676f18
--- /dev/null
+++ b/usr/src/cmd/acpi/iasl/aslerror.c
@@ -0,0 +1,932 @@
+/******************************************************************************
+ *
+ * Module Name: aslerror - Error handling and statistics
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2016, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include "aslcompiler.h"
+
+#define _COMPONENT          ACPI_COMPILER
+        ACPI_MODULE_NAME    ("aslerror")
+
+/* Local prototypes */
+
+static void
+AeAddToErrorLog (
+    ASL_ERROR_MSG           *Enode);
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AslAbort
+ *
+ * PARAMETERS:  None
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Dump the error log and abort the compiler. Used for serious
+ *              I/O errors.
+ *
+ ******************************************************************************/
+
+void
+AslAbort (
+    void)
+{
+
+    AePrintErrorLog (ASL_FILE_STDERR);
+    if (Gbl_DebugFlag)
+    {
+        /* Print error summary to stdout also */
+
+        AePrintErrorLog (ASL_FILE_STDOUT);
+    }
+
+    exit (1);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AeClearErrorLog
+ *
+ * PARAMETERS:  None
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Empty the error list
+ *
+ ******************************************************************************/
+
+void
+AeClearErrorLog (
+    void)
+{
+    ASL_ERROR_MSG           *Enode = Gbl_ErrorLog;
+    ASL_ERROR_MSG           *Next;
+
+    /* Walk the error node list */
+
+    while (Enode)
+    {
+        Next = Enode->Next;
+        ACPI_FREE (Enode);
+        Enode = Next;
+    }
+
+    Gbl_ErrorLog = NULL;
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AeAddToErrorLog
+ *
+ * PARAMETERS:  Enode       - An error node to add to the log
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Add a new error node to the error log. The error log is
+ *              ordered by the "logical" line number (cumulative line number
+ *              including all include files.)
+ *
+ ******************************************************************************/
+
+static void
+AeAddToErrorLog (
+    ASL_ERROR_MSG           *Enode)
+{
+    ASL_ERROR_MSG           *Next;
+    ASL_ERROR_MSG           *Prev;
+
+
+    /* If Gbl_ErrorLog is null, this is the first error node */
+
+    if (!Gbl_ErrorLog)
+    {
+        Gbl_ErrorLog = Enode;
+        return;
+    }
+
+    /*
+     * Walk error list until we find a line number greater than ours.
+     * List is sorted according to line number.
+     */
+    Prev = NULL;
+    Next = Gbl_ErrorLog;
+
+    while ((Next) &&
+           (Next->LogicalLineNumber <= Enode->LogicalLineNumber))
+    {
+        Prev = Next;
+        Next = Next->Next;
+    }
+
+    /* Found our place in the list */
+
+    Enode->Next = Next;
+
+    if (Prev)
+    {
+        Prev->Next = Enode;
+    }
+    else
+    {
+        Gbl_ErrorLog = Enode;
+    }
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AePrintException
+ *
+ * PARAMETERS:  FileId          - ID of output file
+ *              Enode           - Error node to print
+ *              Header          - Additional text before each message
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Print the contents of an error node.
+ *
+ * NOTE:        We don't use the FlxxxFile I/O functions here because on error
+ *              they abort the compiler and call this function!  Since we
+ *              are reporting errors here, we ignore most output errors and
+ *              just try to get out as much as we can.
+ *
+ ******************************************************************************/
+
+void
+AePrintException (
+    UINT32                  FileId,
+    ASL_ERROR_MSG           *Enode,
+    char                    *Header)
+{
+    UINT8                   SourceByte;
+    int                     Actual;
+    size_t                  RActual;
+    UINT32                  MsgLength;
+    const char              *MainMessage;
+    char                    *ExtraMessage;
+    UINT32                  SourceColumn;
+    UINT32                  ErrorColumn;
+    FILE                    *OutputFile;
+    FILE                    *SourceFile = NULL;
+    long                    FileSize;
+    BOOLEAN                 PrematureEOF = FALSE;
+    UINT32                  Total = 0;
+
+
+    if (Gbl_NoErrors)
+    {
+        return;
+    }
+
+    /*
+     * Only listing files have a header, and remarks/optimizations
+     * are always output
+     */
+    if (!Header)
+    {
+        /* Ignore remarks if requested */
+
+        switch (Enode->Level)
+        {
+        case ASL_WARNING:
+        case ASL_WARNING2:
+        case ASL_WARNING3:
+
+            if (!Gbl_DisplayWarnings)
+            {
+                return;
+            }
+            break;
+
+        case ASL_REMARK:
+
+            if (!Gbl_DisplayRemarks)
+            {
+                return;
+            }
+            break;
+
+        case ASL_OPTIMIZATION:
+
+            if (!Gbl_DisplayOptimizations)
+            {
+                return;
+            }
+            break;
+
+        default:
+
+            break;
+        }
+    }
+
+    /* Get the various required file handles */
+
+    OutputFile = Gbl_Files[FileId].Handle;
+
+    if (!Enode->SourceLine)
+    {
+        /*
+         * Use the merged header/source file if present, otherwise
+         * use input file
+         */
+        SourceFile = Gbl_Files[ASL_FILE_SOURCE_OUTPUT].Handle;
+        if (!SourceFile)
+        {
+            SourceFile = Gbl_Files[ASL_FILE_INPUT].Handle;
+        }
+
+        if (SourceFile)
+        {
+            /* Determine if the error occurred at source file EOF */
+
+            fseek (SourceFile, 0, SEEK_END);
+            FileSize = ftell (SourceFile);
+
+            if ((long) Enode->LogicalByteOffset >= FileSize)
+            {
+                PrematureEOF = TRUE;
+            }
+        }
+    }
+
+    if (Header)
+    {
+        fprintf (OutputFile, "%s", Header);
+    }
+
+    /* Print filename and line number if present and valid */
+
+    if (Enode->Filename)
+    {
+        if (Gbl_VerboseErrors)
+        {
+            fprintf (OutputFile, "%-8s", Enode->Filename);
+
+            if (Enode->LineNumber)
+            {
+                if (Enode->SourceLine)
+                {
+                    fprintf (OutputFile, " %6u: %s",
+                        Enode->LineNumber, Enode->SourceLine);
+                }
+                else
+                {
+                    fprintf (OutputFile, " %6u: ", Enode->LineNumber);
+
+                    /*
+                     * If not at EOF, get the corresponding source code line
+                     * and display it. Don't attempt this if we have a
+                     * premature EOF condition.
+                     */
+                    if (!PrematureEOF)
+                    {
+                        /*
+                         * Seek to the offset in the combined source file,
+                         * read the source line, and write it to the output.
+                         */
+                        Actual = fseek (SourceFile,
+                            (long) Enode->LogicalByteOffset, (int) SEEK_SET);
+                        if (Actual)
+                        {
+                            fprintf (OutputFile,
+                                "[*** iASL: Seek error on source code temp file %s ***]",
+                                Gbl_Files[ASL_FILE_SOURCE_OUTPUT].Filename);
+                        }
+                        else
+                        {
+                            RActual = fread (&SourceByte, 1, 1, SourceFile);
+                            if (RActual != 1)
+                            {
+                                fprintf (OutputFile,
+                                    "[*** iASL: Read error on source code temp file %s ***]",
+                                    Gbl_Files[ASL_FILE_SOURCE_OUTPUT].Filename);
+                            }
+                            else
+                            {
+                                /* Read/write the source line, up to the maximum line length */
+
+                                while (RActual && SourceByte && (SourceByte != '\n'))
+                                {
+                                    if (Total < 256)
+                                    {
+                                        /* After the max line length, we will just read the line, no write */
+
+                                        if (fwrite (&SourceByte, 1, 1, OutputFile) != 1)
+                                        {
+                                            printf ("[*** iASL: Write error on output file ***]\n");
+                                            return;
+                                        }
+                                    }
+                                    else if (Total == 256)
+                                    {
+                                        fprintf (OutputFile,
+                                            "\n[*** iASL: Very long input line, message below refers to column %u ***]",
+                                            Enode->Column);
+                                    }
+
+                                    RActual = fread (&SourceByte, 1, 1, SourceFile);
+                                    if (RActual != 1)
+                                    {
+                                        fprintf (OutputFile,
+                                            "[*** iASL: Read error on source code temp file %s ***]",
+                                            Gbl_Files[ASL_FILE_SOURCE_OUTPUT].Filename);
+                                        return;
+                                    }
+                                    Total++;
+                                }
+                            }
+                        }
+                    }
+
+                    fprintf (OutputFile, "\n");
+                }
+            }
+        }
+        else
+        {
+            /*
+             * Less verbose version of the error message, enabled via the
+             * -vi switch. The format is compatible with MS Visual Studio.
+             */
+            fprintf (OutputFile, "%s", Enode->Filename);
+
+            if (Enode->LineNumber)
+            {
+                fprintf (OutputFile, "(%u) : ",
+                    Enode->LineNumber);
+            }
+        }
+    }
+
+    /* If a NULL message ID, just print the raw message */
+
+    if (Enode->MessageId == 0)
+    {
+        fprintf (OutputFile, "%s\n", Enode->Message);
+        return;
+    }
+
+    /* Decode the message ID */
+
+    fprintf (OutputFile, "%s %4.4d -",
+        AeDecodeExceptionLevel (Enode->Level),
+        AeBuildFullExceptionCode (Enode->Level, Enode->MessageId));
+
+    MainMessage = AeDecodeMessageId (Enode->MessageId);
+    ExtraMessage = Enode->Message;
+
+    /* If a NULL line number, just print the decoded message */
+
+    if (!Enode->LineNumber)
+    {
+        fprintf (OutputFile, " %s %s\n\n", MainMessage, ExtraMessage);
+        return;
+    }
+
+    MsgLength = strlen (MainMessage);
+    if (MsgLength == 0)
+    {
+        /* Use the secondary/extra message as main message */
+
+        MainMessage = Enode->Message;
+        if (!MainMessage)
+        {
+            MainMessage = "";
+        }
+
+        MsgLength = strlen (MainMessage);
+        ExtraMessage = NULL;
+    }
+
+    if (Gbl_VerboseErrors && !PrematureEOF)
+    {
+        if (Total >= 256)
+        {
+            fprintf (OutputFile, "    %s",
+                MainMessage);
+        }
+        else
+        {
+            SourceColumn = Enode->Column + Enode->FilenameLength + 6 + 2;
+            ErrorColumn = ASL_ERROR_LEVEL_LENGTH + 5 + 2 + 1;
+
+            if ((MsgLength + ErrorColumn) < (SourceColumn - 1))
+            {
+                fprintf (OutputFile, "%*s%s",
+                    (int) ((SourceColumn - 1) - ErrorColumn),
+                    MainMessage, " ^ ");
+            }
+            else
+            {
+                fprintf (OutputFile, "%*s %s",
+                    (int) ((SourceColumn - ErrorColumn) + 1), "^",
+                    MainMessage);
+            }
+        }
+    }
+    else
+    {
+        fprintf (OutputFile, " %s", MainMessage);
+    }
+
+    /* Print the extra info message if present */
+
+    if (ExtraMessage)
+    {
+        fprintf (OutputFile, " (%s)", ExtraMessage);
+    }
+
+    if (PrematureEOF)
+    {
+        fprintf (OutputFile, " and premature End-Of-File");
+    }
+
+    fprintf (OutputFile, "\n");
+    if (Gbl_VerboseErrors)
+    {
+        fprintf (OutputFile, "\n");
+    }
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AePrintErrorLog
+ *
+ * PARAMETERS:  FileId           - Where to output the error log
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Print the entire contents of the error log
+ *
+ ******************************************************************************/
+
+void
+AePrintErrorLog (
+    UINT32                  FileId)
+{
+    ASL_ERROR_MSG           *Enode = Gbl_ErrorLog;
+
+
+    /* Walk the error node list */
+
+    while (Enode)
+    {
+        AePrintException (FileId, Enode, NULL);
+        Enode = Enode->Next;
+    }
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AslCommonError2
+ *
+ * PARAMETERS:  Level               - Seriousness (Warning/error, etc.)
+ *              MessageId           - Index into global message buffer
+ *              LineNumber          - Actual file line number
+ *              Column              - Column in current line
+ *              SourceLine          - Actual source code line
+ *              Filename            - source filename
+ *              ExtraMessage        - additional error message
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Create a new error node and add it to the error log
+ *
+ ******************************************************************************/
+
+void
+AslCommonError2 (
+    UINT8                   Level,
+    UINT16                  MessageId,
+    UINT32                  LineNumber,
+    UINT32                  Column,
+    char                    *SourceLine,
+    char                    *Filename,
+    char                    *ExtraMessage)
+{
+    char                    *MessageBuffer = NULL;
+    char                    *LineBuffer;
+    ASL_ERROR_MSG           *Enode;
+
+
+    Enode = UtLocalCalloc (sizeof (ASL_ERROR_MSG));
+
+    if (ExtraMessage)
+    {
+        /* Allocate a buffer for the message and a new error node */
+
+        MessageBuffer = UtStringCacheCalloc (strlen (ExtraMessage) + 1);
+
+        /* Keep a copy of the extra message */
+
+        strcpy (MessageBuffer, ExtraMessage);
+    }
+
+    LineBuffer = UtLocalCalloc (strlen (SourceLine) + 1);
+    strcpy (LineBuffer, SourceLine);
+
+    /* Initialize the error node */
+
+    if (Filename)
+    {
+        Enode->Filename = Filename;
+        Enode->FilenameLength = strlen (Filename);
+        if (Enode->FilenameLength < 6)
+        {
+            Enode->FilenameLength = 6;
+        }
+    }
+
+    Enode->MessageId            = MessageId;
+    Enode->Level                = Level;
+    Enode->LineNumber           = LineNumber;
+    Enode->LogicalLineNumber    = LineNumber;
+    Enode->LogicalByteOffset    = 0;
+    Enode->Column               = Column;
+    Enode->Message              = MessageBuffer;
+    Enode->SourceLine           = LineBuffer;
+
+    /* Add the new node to the error node list */
+
+    AeAddToErrorLog (Enode);
+
+    if (Gbl_DebugFlag)
+    {
+        /* stderr is a file, send error to it immediately */
+
+        AePrintException (ASL_FILE_STDERR, Enode, NULL);
+    }
+
+    Gbl_ExceptionCount[Level]++;
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AslCommonError
+ *
+ * PARAMETERS:  Level               - Seriousness (Warning/error, etc.)
+ *              MessageId           - Index into global message buffer
+ *              CurrentLineNumber   - Actual file line number
+ *              LogicalLineNumber   - Cumulative line number
+ *              LogicalByteOffset   - Byte offset in source file
+ *              Column              - Column in current line
+ *              Filename            - source filename
+ *              ExtraMessage        - additional error message
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Create a new error node and add it to the error log
+ *
+ ******************************************************************************/
+
+void
+AslCommonError (
+    UINT8                   Level,
+    UINT16                  MessageId,
+    UINT32                  CurrentLineNumber,
+    UINT32                  LogicalLineNumber,
+    UINT32                  LogicalByteOffset,
+    UINT32                  Column,
+    char                    *Filename,
+    char                    *ExtraMessage)
+{
+    char                    *MessageBuffer = NULL;
+    ASL_ERROR_MSG           *Enode;
+
+
+    Enode = UtLocalCalloc (sizeof (ASL_ERROR_MSG));
+
+    if (ExtraMessage)
+    {
+        /* Allocate a buffer for the message and a new error node */
+
+        MessageBuffer = UtStringCacheCalloc (strlen (ExtraMessage) + 1);
+
+        /* Keep a copy of the extra message */
+
+        strcpy (MessageBuffer, ExtraMessage);
+    }
+
+    /* Initialize the error node */
+
+    if (Filename)
+    {
+        Enode->Filename = Filename;
+        Enode->FilenameLength = strlen (Filename);
+        if (Enode->FilenameLength < 6)
+        {
+            Enode->FilenameLength = 6;
+        }
+    }
+
+    Enode->MessageId            = MessageId;
+    Enode->Level                = Level;
+    Enode->LineNumber           = CurrentLineNumber;
+    Enode->LogicalLineNumber    = LogicalLineNumber;
+    Enode->LogicalByteOffset    = LogicalByteOffset;
+    Enode->Column               = Column;
+    Enode->Message              = MessageBuffer;
+    Enode->SourceLine           = NULL;
+
+    /* Add the new node to the error node list */
+
+    AeAddToErrorLog (Enode);
+
+    if (Gbl_DebugFlag)
+    {
+        /* stderr is a file, send error to it immediately */
+
+        AePrintException (ASL_FILE_STDERR, Enode, NULL);
+    }
+
+    Gbl_ExceptionCount[Level]++;
+    if (Gbl_ExceptionCount[ASL_ERROR] > ASL_MAX_ERROR_COUNT)
+    {
+        printf ("\nMaximum error count (%u) exceeded\n", ASL_MAX_ERROR_COUNT);
+
+        Gbl_SourceLine = 0;
+        Gbl_NextError = Gbl_ErrorLog;
+        CmCleanupAndExit ();
+        exit(1);
+    }
+
+    return;
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AslDisableException
+ *
+ * PARAMETERS:  MessageIdString     - ID to be disabled
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Enter a message ID into the global disabled messages table
+ *
+ ******************************************************************************/
+
+ACPI_STATUS
+AslDisableException (
+    char                    *MessageIdString)
+{
+    UINT32                  MessageId;
+
+
+    /* Convert argument to an integer and validate it */
+
+    MessageId = (UINT32) strtoul (MessageIdString, NULL, 0);
+
+    if ((MessageId < 2000) || (MessageId > 5999))
+    {
+        printf ("\"%s\" is not a valid warning/remark ID\n",
+            MessageIdString);
+        return (AE_BAD_PARAMETER);
+    }
+
+    /* Insert value into the global disabled message array */
+
+    if (Gbl_DisabledMessagesIndex >= ASL_MAX_DISABLED_MESSAGES)
+    {
+        printf ("Too many messages have been disabled (max %u)\n",
+            ASL_MAX_DISABLED_MESSAGES);
+        return (AE_LIMIT);
+    }
+
+    Gbl_DisabledMessages[Gbl_DisabledMessagesIndex] = MessageId;
+    Gbl_DisabledMessagesIndex++;
+    return (AE_OK);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AslIsExceptionDisabled
+ *
+ * PARAMETERS:  Level               - Seriousness (Warning/error, etc.)
+ *              MessageId           - Index into global message buffer
+ *
+ * RETURN:      TRUE if exception/message should be ignored
+ *
+ * DESCRIPTION: Check if the user has specified options such that this
+ *              exception should be ignored
+ *
+ ******************************************************************************/
+
+BOOLEAN
+AslIsExceptionDisabled (
+    UINT8                   Level,
+    UINT16                  MessageId)
+{
+    UINT32                  EncodedMessageId;
+    UINT32                  i;
+
+
+    switch (Level)
+    {
+    case ASL_WARNING2:
+    case ASL_WARNING3:
+
+        /* Check for global disable via -w1/-w2/-w3 options */
+
+        if (Level > Gbl_WarningLevel)
+        {
+            return (TRUE);
+        }
+        /* Fall through */
+
+    case ASL_WARNING:
+    case ASL_REMARK:
+        /*
+         * Ignore this warning/remark if it has been disabled by
+         * the user (-vw option)
+         */
+        EncodedMessageId = AeBuildFullExceptionCode (Level, MessageId);
+        for (i = 0; i < Gbl_DisabledMessagesIndex; i++)
+        {
+            /* Simple implementation via fixed array */
+
+            if (EncodedMessageId == Gbl_DisabledMessages[i])
+            {
+                return (TRUE);
+            }
+        }
+        break;
+
+    default:
+        break;
+    }
+
+    return (FALSE);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AslError
+ *
+ * PARAMETERS:  Level               - Seriousness (Warning/error, etc.)
+ *              MessageId           - Index into global message buffer
+ *              Op                  - Parse node where error happened
+ *              ExtraMessage        - additional error message
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Main error reporting routine for the ASL compiler (all code
+ *              except the parser.)
+ *
+ ******************************************************************************/
+
+void
+AslError (
+    UINT8                   Level,
+    UINT16                  MessageId,
+    ACPI_PARSE_OBJECT       *Op,
+    char                    *ExtraMessage)
+{
+
+    /* Check if user wants to ignore this exception */
+
+    if (Gbl_AllExceptionsDisabled ||
+        AslIsExceptionDisabled (Level, MessageId))
+    {
+        return;
+    }
+
+    if (Op)
+    {
+        AslCommonError (Level, MessageId, Op->Asl.LineNumber,
+            Op->Asl.LogicalLineNumber,
+            Op->Asl.LogicalByteOffset,
+            Op->Asl.Column,
+            Op->Asl.Filename, ExtraMessage);
+    }
+    else
+    {
+        AslCommonError (Level, MessageId, 0,
+            0, 0, 0, NULL, ExtraMessage);
+    }
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AslCoreSubsystemError
+ *
+ * PARAMETERS:  Op                  - Parse node where error happened
+ *              Status              - The ACPICA Exception
+ *              ExtraMessage        - additional error message
+ *              Abort               - TRUE -> Abort compilation
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Error reporting routine for exceptions returned by the ACPICA
+ *              core subsystem.
+ *
+ ******************************************************************************/
+
+void
+AslCoreSubsystemError (
+    ACPI_PARSE_OBJECT       *Op,
+    ACPI_STATUS             Status,
+    char                    *ExtraMessage,
+    BOOLEAN                 Abort)
+{
+
+    sprintf (MsgBuffer, "%s %s", AcpiFormatException (Status), ExtraMessage);
+
+    if (Op)
+    {
+        AslCommonError (ASL_ERROR, ASL_MSG_CORE_EXCEPTION,
+            Op->Asl.LineNumber,
+            Op->Asl.LogicalLineNumber,
+            Op->Asl.LogicalByteOffset,
+            Op->Asl.Column,
+            Op->Asl.Filename, MsgBuffer);
+    }
+    else
+    {
+        AslCommonError (ASL_ERROR, ASL_MSG_CORE_EXCEPTION,
+            0, 0, 0, 0, NULL, MsgBuffer);
+    }
+
+    if (Abort)
+    {
+        AslAbort ();
+    }
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AslCompilererror
+ *
+ * PARAMETERS:  CompilerMessage         - Error message from the parser
+ *
+ * RETURN:      Status (0 for now)
+ *
+ * DESCRIPTION: Report an error situation discovered in a production
+ *              NOTE: don't change the name of this function, it is called
+ *              from the auto-generated parser.
+ *
+ ******************************************************************************/
+
+int
+AslCompilererror (
+    const char              *CompilerMessage)
+{
+
+    Gbl_SyntaxError++;
+
+    AslCommonError (ASL_ERROR, ASL_MSG_SYNTAX, Gbl_CurrentLineNumber,
+        Gbl_LogicalLineNumber, Gbl_CurrentLineOffset,
+        Gbl_CurrentColumn, Gbl_Files[ASL_FILE_INPUT].Filename,
+        ACPI_CAST_PTR (char, CompilerMessage));
+
+    return (0);
+}
diff --git a/usr/src/cmd/acpi/iasl/aslexternal.c b/usr/src/cmd/acpi/iasl/aslexternal.c
new file mode 100644
index 0000000000..a814efddd5
--- /dev/null
+++ b/usr/src/cmd/acpi/iasl/aslexternal.c
@@ -0,0 +1,498 @@
+/******************************************************************************
+ *
+ * Module Name: aslexternal - ASL External opcode compiler support
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2016, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include "aslcompiler.h"
+#include "aslcompiler.y.h"
+#include "acparser.h"
+#include "amlcode.h"
+#include "acnamesp.h"
+
+
+#define _COMPONENT          ACPI_COMPILER
+        ACPI_MODULE_NAME    ("aslexternal")
+
+
+/* Local prototypes */
+
+static void
+ExInsertArgCount (
+    ACPI_PARSE_OBJECT       *Op);
+
+static void
+ExMoveExternals (
+    ACPI_PARSE_OBJECT       *DefinitionBlockOp);
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    ExDoExternal
+ *
+ * PARAMETERS:  Op                  - Current Parse node
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Add an External() definition to the global list. This list
+ *              is used to generate External opcodes.
+ *
+ ******************************************************************************/
+
+void
+ExDoExternal (
+    ACPI_PARSE_OBJECT       *Op)
+{
+    ACPI_PARSE_OBJECT       *ListOp;
+    ACPI_PARSE_OBJECT       *Prev;
+    ACPI_PARSE_OBJECT       *Next;
+    ACPI_PARSE_OBJECT       *ArgCountOp;
+
+
+    ArgCountOp = Op->Asl.Child->Asl.Next->Asl.Next;
+    ArgCountOp->Asl.AmlOpcode = AML_RAW_DATA_BYTE;
+    ArgCountOp->Asl.ParseOpcode = PARSEOP_BYTECONST;
+    ArgCountOp->Asl.Value.Integer = 0;
+    UtSetParseOpName (ArgCountOp);
+
+    /* Create new list node of arbitrary type */
+
+    ListOp = TrAllocateNode (PARSEOP_DEFAULT_ARG);
+
+    /* Store External node as child */
+
+    ListOp->Asl.Child = Op;
+    ListOp->Asl.Next = NULL;
+
+    if (Gbl_ExternalsListHead)
+    {
+        /* Link new External to end of list */
+
+        Prev = Gbl_ExternalsListHead;
+        Next = Prev;
+        while (Next)
+        {
+            Prev = Next;
+            Next = Next->Asl.Next;
+        }
+
+        Prev->Asl.Next = ListOp;
+    }
+    else
+    {
+        Gbl_ExternalsListHead = ListOp;
+    }
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    ExInsertArgCount
+ *
+ * PARAMETERS:  Op              - Op for a method invocation
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Obtain the number of arguments for a control method -- from
+ *              the actual invocation.
+ *
+ ******************************************************************************/
+
+static void
+ExInsertArgCount (
+    ACPI_PARSE_OBJECT       *Op)
+{
+    ACPI_PARSE_OBJECT       *Next;
+    ACPI_PARSE_OBJECT       *NameOp;
+    ACPI_PARSE_OBJECT       *Child;
+    ACPI_PARSE_OBJECT       *ArgCountOp;
+    char *                  ExternalName;
+    char *                  CallName;
+    UINT16                  ArgCount = 0;
+    ACPI_STATUS             Status;
+
+
+    CallName = AcpiNsGetNormalizedPathname (Op->Asl.Node, TRUE);
+
+    Next = Gbl_ExternalsListHead;
+    while (Next)
+    {
+        ArgCount = 0;
+
+        /* Skip if External node already handled */
+
+        if (Next->Asl.Child->Asl.CompileFlags & NODE_VISITED)
+        {
+            Next = Next->Asl.Next;
+            continue;
+        }
+
+        NameOp = Next->Asl.Child->Asl.Child;
+        ExternalName = AcpiNsGetNormalizedPathname (NameOp->Asl.Node, TRUE);
+
+        if (strcmp (CallName, ExternalName))
+        {
+            ACPI_FREE (ExternalName);
+            Next = Next->Asl.Next;
+            continue;
+        }
+
+        Next->Asl.Child->Asl.CompileFlags |= NODE_VISITED;
+
+        /*
+         * Since we will reposition Externals to the Root, set Namepath
+         * to the fully qualified name and recalculate the aml length
+         */
+        Status = UtInternalizeName (ExternalName,
+            &NameOp->Asl.Value.String);
+
+        ACPI_FREE (ExternalName);
+        if (ACPI_FAILURE (Status))
+        {
+            AslError (ASL_ERROR, ASL_MSG_COMPILER_INTERNAL,
+                NULL, "- Could not Internalize External");
+            break;
+        }
+
+        NameOp->Asl.AmlLength = strlen (NameOp->Asl.Value.String);
+
+        /* Get argument count */
+
+        Child = Op->Asl.Child;
+        while (Child)
+        {
+            ArgCount++;
+            Child = Child->Asl.Next;
+        }
+
+        /* Setup ArgCount operand */
+
+        ArgCountOp = Next->Asl.Child->Asl.Child->Asl.Next->Asl.Next;
+        ArgCountOp->Asl.Value.Integer = ArgCount;
+        break;
+    }
+
+    ACPI_FREE (CallName);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    ExAmlExternalWalkBegin
+ *
+ * PARAMETERS:  ASL_WALK_CALLBACK
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Parse tree walk to create external opcode list for methods.
+ *
+ ******************************************************************************/
+
+ACPI_STATUS
+ExAmlExternalWalkBegin (
+    ACPI_PARSE_OBJECT       *Op,
+    UINT32                  Level,
+    void                    *Context)
+{
+
+    /* External list head saved in the definition block op */
+
+    if (Op->Asl.ParseOpcode == PARSEOP_DEFINITION_BLOCK)
+    {
+        Gbl_ExternalsListHead = Op->Asl.Value.Arg;
+    }
+
+    if (!Gbl_ExternalsListHead)
+    {
+        return (AE_OK);
+    }
+
+    if (Op->Asl.ParseOpcode != PARSEOP_METHODCALL)
+    {
+        return (AE_OK);
+    }
+
+    /*
+     * The NameOp child under an ExternalOp gets turned into PARSE_METHODCALL
+     * by XfNamespaceLocateBegin(). Ignore these.
+     */
+    if (Op->Asl.Parent &&
+        Op->Asl.Parent->Asl.ParseOpcode == PARSEOP_EXTERNAL)
+    {
+        return (AE_OK);
+    }
+
+    ExInsertArgCount (Op);
+    return (AE_OK);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    ExAmlExternalWalkEnd
+ *
+ * PARAMETERS:  ASL_WALK_CALLBACK
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Parse tree walk to create external opcode list for methods.
+ *              Here, we just want to catch the case where a definition block
+ *              has been completed. Then we move all of the externals into
+ *              a single block in the parse tree and thus the AML code.
+ *
+ ******************************************************************************/
+
+ACPI_STATUS
+ExAmlExternalWalkEnd (
+    ACPI_PARSE_OBJECT       *Op,
+    UINT32                  Level,
+    void                    *Context)
+{
+
+    if (Op->Asl.ParseOpcode == PARSEOP_DEFINITION_BLOCK)
+    {
+        /*
+         * Process any existing external list. (Support for
+         * multiple definition blocks in a single file/compile)
+         */
+        ExMoveExternals (Op);
+        Gbl_ExternalsListHead = NULL;
+    }
+
+    return (AE_OK);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    ExMoveExternals
+ *
+ * PARAMETERS:  DefinitionBlockOp       - Op for current definition block
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Move all externals present in the source file into a single
+ *              block of AML code, surrounded by an "If (0)" to prevent
+ *              AML interpreters from attempting to execute the External
+ *              opcodes.
+ *
+ ******************************************************************************/
+
+static void
+ExMoveExternals (
+    ACPI_PARSE_OBJECT       *DefinitionBlockOp)
+{
+    ACPI_PARSE_OBJECT       *ParentOp;
+    ACPI_PARSE_OBJECT       *ExternalOp;
+    ACPI_PARSE_OBJECT       *PredicateOp;
+    ACPI_PARSE_OBJECT       *NextOp;
+    ACPI_PARSE_OBJECT       *Prev;
+    ACPI_PARSE_OBJECT       *Next;
+    ACPI_OBJECT_TYPE        ObjType;
+    UINT32                  i;
+
+
+    if (!Gbl_ExternalsListHead)
+    {
+        return;
+    }
+
+    /* Remove the External nodes from the tree */
+
+    NextOp = Gbl_ExternalsListHead;
+    while (NextOp)
+    {
+        /*
+         * The External is stored in child pointer of each node in the
+         * list
+         */
+        ExternalOp = NextOp->Asl.Child;
+
+        /* Set line numbers (for listings, etc.) */
+
+        ExternalOp->Asl.LineNumber = 0;
+        ExternalOp->Asl.LogicalLineNumber = 0;
+
+        Next = ExternalOp->Asl.Child;
+        Next->Asl.LineNumber = 0;
+        Next->Asl.LogicalLineNumber = 0;
+
+        Next = Next->Asl.Next;
+        Next->Asl.LineNumber = 0;
+        Next->Asl.LogicalLineNumber = 0;
+
+        Next = Next->Asl.Next;
+        Next->Asl.LineNumber = 0;
+        Next->Asl.LogicalLineNumber = 0;
+
+        Next = Next->Asl.Next;
+        Next->Asl.LineNumber = 0;
+        Next->Asl.LogicalLineNumber = 0;
+
+        ParentOp = ExternalOp->Asl.Parent;
+        Prev = Next = ParentOp->Asl.Child;
+
+        /* Now find the External node's position in parse tree */
+
+        while (Next != ExternalOp)
+        {
+            Prev = Next;
+            Next = Next->Asl.Next;
+        }
+
+        /* Remove the External from the parse tree */
+
+        if (Prev == ExternalOp)
+        {
+            /* External was the first child node */
+
+            ParentOp->Asl.Child = ExternalOp->Asl.Next;
+        }
+
+        Prev->Asl.Next = ExternalOp->Asl.Next;
+        ExternalOp->Asl.Next = NULL;
+        ExternalOp->Asl.Parent = Gbl_ExternalsListHead;
+
+        /* Point the External to the next in the list */
+
+        if (NextOp->Asl.Next)
+        {
+            ExternalOp->Asl.Next = NextOp->Asl.Next->Asl.Child;
+        }
+
+        NextOp = NextOp->Asl.Next;
+    }
+
+    /*
+     * Loop again to remove MethodObj Externals for which
+     * a MethodCall was not found (dead external reference)
+     */
+    Prev = Gbl_ExternalsListHead->Asl.Child;
+    Next = Prev;
+    while (Next)
+    {
+        ObjType = (ACPI_OBJECT_TYPE)
+            Next->Asl.Child->Asl.Next->Asl.Value.Integer;
+
+        if (ObjType == ACPI_TYPE_METHOD &&
+            !(Next->Asl.CompileFlags & NODE_VISITED))
+        {
+            if (Next == Prev)
+            {
+                Gbl_ExternalsListHead->Asl.Child = Next->Asl.Next;
+                Next->Asl.Next = NULL;
+                Prev = Gbl_ExternalsListHead->Asl.Child;
+                Next = Prev;
+                continue;
+            }
+            else
+            {
+                Prev->Asl.Next = Next->Asl.Next;
+                Next->Asl.Next = NULL;
+                Next = Prev->Asl.Next;
+                continue;
+            }
+        }
+
+        Prev = Next;
+        Next = Next->Asl.Next;
+    }
+
+    /* If list is now empty, don't bother to make If (0) block */
+
+    if (!Gbl_ExternalsListHead->Asl.Child)
+    {
+        return;
+    }
+
+    /* Convert Gbl_ExternalsListHead parent to If(). */
+
+    Gbl_ExternalsListHead->Asl.ParseOpcode = PARSEOP_IF;
+    Gbl_ExternalsListHead->Asl.AmlOpcode = AML_IF_OP;
+    Gbl_ExternalsListHead->Asl.CompileFlags = NODE_AML_PACKAGE;
+    UtSetParseOpName (Gbl_ExternalsListHead);
+
+    /* Create a Zero op for the If predicate */
+
+    PredicateOp = TrAllocateNode (PARSEOP_ZERO);
+    PredicateOp->Asl.AmlOpcode = AML_ZERO_OP;
+
+    PredicateOp->Asl.Parent = Gbl_ExternalsListHead;
+    PredicateOp->Asl.Child = NULL;
+    PredicateOp->Asl.Next = Gbl_ExternalsListHead->Asl.Child;
+    Gbl_ExternalsListHead->Asl.Child = PredicateOp;
+
+    /* Set line numbers (for listings, etc.) */
+
+    Gbl_ExternalsListHead->Asl.LineNumber = 0;
+    Gbl_ExternalsListHead->Asl.LogicalLineNumber = 0;
+
+    PredicateOp->Asl.LineNumber = 0;
+    PredicateOp->Asl.LogicalLineNumber = 0;
+
+    /* Insert block back in the list */
+
+    Prev = DefinitionBlockOp->Asl.Child;
+    Next = Prev;
+
+    /* Find last default arg */
+
+    for (i = 0; i < 6; i++)
+    {
+        Prev = Next;
+        Next = Prev->Asl.Next;
+    }
+
+    if (Next)
+    {
+        /* Definition Block is not empty */
+
+        Gbl_ExternalsListHead->Asl.Next = Next;
+    }
+    else
+    {
+        /* Definition Block is empty. */
+
+        Gbl_ExternalsListHead->Asl.Next = NULL;
+    }
+
+    Prev->Asl.Next = Gbl_ExternalsListHead;
+    Gbl_ExternalsListHead->Asl.Parent = Prev->Asl.Parent;
+}
diff --git a/usr/src/cmd/acpi/iasl/aslfileio.c b/usr/src/cmd/acpi/iasl/aslfileio.c
new file mode 100644
index 0000000000..40f3562c0e
--- /dev/null
+++ b/usr/src/cmd/acpi/iasl/aslfileio.c
@@ -0,0 +1,401 @@
+/******************************************************************************
+ *
+ * Module Name: aslfileio - File I/O support
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2016, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include "aslcompiler.h"
+#include "acapps.h"
+
+#define _COMPONENT          ACPI_COMPILER
+        ACPI_MODULE_NAME    ("aslfileio")
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    FlFileError
+ *
+ * PARAMETERS:  FileId              - Index into file info array
+ *              ErrorId             - Index into error message array
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Decode errno to an error message and add the entire error
+ *              to the error log.
+ *
+ ******************************************************************************/
+
+void
+FlFileError (
+    UINT32                  FileId,
+    UINT8                   ErrorId)
+{
+
+    sprintf (MsgBuffer, "\"%s\" (%s) - %s", Gbl_Files[FileId].Filename,
+        Gbl_Files[FileId].Description, strerror (errno));
+
+    AslCommonError (ASL_ERROR, ErrorId, 0, 0, 0, 0, NULL, MsgBuffer);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    FlOpenFile
+ *
+ * PARAMETERS:  FileId              - Index into file info array
+ *              Filename            - file pathname to open
+ *              Mode                - Open mode for fopen
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Open a file.
+ *              NOTE: Aborts compiler on any error.
+ *
+ ******************************************************************************/
+
+void
+FlOpenFile (
+    UINT32                  FileId,
+    char                    *Filename,
+    char                    *Mode)
+{
+    FILE                    *File;
+
+
+    Gbl_Files[FileId].Filename = Filename;
+    Gbl_Files[FileId].Handle = NULL;
+
+    File = fopen (Filename, Mode);
+    if (!File)
+    {
+        FlFileError (FileId, ASL_MSG_OPEN);
+        AslAbort ();
+    }
+
+    Gbl_Files[FileId].Handle = File;
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    FlGetFileSize
+ *
+ * PARAMETERS:  FileId              - Index into file info array
+ *
+ * RETURN:      File Size
+ *
+ * DESCRIPTION: Get current file size. Uses common seek-to-EOF function.
+ *              File must be open. Aborts compiler on error.
+ *
+ ******************************************************************************/
+
+UINT32
+FlGetFileSize (
+    UINT32                  FileId)
+{
+    UINT32                  FileSize;
+
+
+    FileSize = CmGetFileSize (Gbl_Files[FileId].Handle);
+    if (FileSize == ACPI_UINT32_MAX)
+    {
+        AslAbort();
+    }
+
+    return (FileSize);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    FlReadFile
+ *
+ * PARAMETERS:  FileId              - Index into file info array
+ *              Buffer              - Where to place the data
+ *              Length              - Amount to read
+ *
+ * RETURN:      Status. AE_ERROR indicates EOF.
+ *
+ * DESCRIPTION: Read data from an open file.
+ *              NOTE: Aborts compiler on any error.
+ *
+ ******************************************************************************/
+
+ACPI_STATUS
+FlReadFile (
+    UINT32                  FileId,
+    void                    *Buffer,
+    UINT32                  Length)
+{
+    UINT32                  Actual;
+
+
+    /* Read and check for error */
+
+    Actual = fread (Buffer, 1, Length, Gbl_Files[FileId].Handle);
+    if (Actual < Length)
+    {
+        if (feof (Gbl_Files[FileId].Handle))
+        {
+            /* End-of-file, just return error */
+
+            return (AE_ERROR);
+        }
+
+        FlFileError (FileId, ASL_MSG_READ);
+        AslAbort ();
+    }
+
+    return (AE_OK);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    FlWriteFile
+ *
+ * PARAMETERS:  FileId              - Index into file info array
+ *              Buffer              - Data to write
+ *              Length              - Amount of data to write
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Write data to an open file.
+ *              NOTE: Aborts compiler on any error.
+ *
+ ******************************************************************************/
+
+void
+FlWriteFile (
+    UINT32                  FileId,
+    void                    *Buffer,
+    UINT32                  Length)
+{
+    UINT32                  Actual;
+
+
+    /* Write and check for error */
+
+    Actual = fwrite ((char *) Buffer, 1, Length, Gbl_Files[FileId].Handle);
+    if (Actual != Length)
+    {
+        FlFileError (FileId, ASL_MSG_WRITE);
+        AslAbort ();
+    }
+
+    if ((FileId == ASL_FILE_PREPROCESSOR) && Gbl_PreprocessorOutputFlag)
+    {
+        /* Duplicate the output to the user preprocessor (.i) file */
+
+        Actual = fwrite ((char *) Buffer, 1, Length,
+            Gbl_Files[ASL_FILE_PREPROCESSOR_USER].Handle);
+        if (Actual != Length)
+        {
+            FlFileError (FileId, ASL_MSG_WRITE);
+            AslAbort ();
+        }
+    }
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    FlPrintFile
+ *
+ * PARAMETERS:  FileId              - Index into file info array
+ *              Format              - Printf format string
+ *              ...                 - Printf arguments
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Formatted write to an open file.
+ *              NOTE: Aborts compiler on any error.
+ *
+ ******************************************************************************/
+
+void
+FlPrintFile (
+    UINT32                  FileId,
+    char                    *Format,
+    ...)
+{
+    INT32                   Actual;
+    va_list                 Args;
+
+
+    va_start (Args, Format);
+    Actual = vfprintf (Gbl_Files[FileId].Handle, Format, Args);
+    va_end (Args);
+
+    if (Actual == -1)
+    {
+        FlFileError (FileId, ASL_MSG_WRITE);
+        AslAbort ();
+    }
+
+    if ((FileId == ASL_FILE_PREPROCESSOR) &&
+        Gbl_PreprocessorOutputFlag)
+    {
+        /*
+         * Duplicate the output to the user preprocessor (.i) file,
+         * except: no #line directives.
+         */
+        if (!strncmp (Format, "#line", 5))
+        {
+            return;
+        }
+
+        va_start (Args, Format);
+        Actual = vfprintf (Gbl_Files[ASL_FILE_PREPROCESSOR_USER].Handle,
+            Format, Args);
+        va_end (Args);
+
+        if (Actual == -1)
+        {
+            FlFileError (FileId, ASL_MSG_WRITE);
+            AslAbort ();
+        }
+    }
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    FlSeekFile
+ *
+ * PARAMETERS:  FileId              - Index into file info array
+ *              Offset              - Absolute byte offset in file
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Seek to absolute offset.
+ *              NOTE: Aborts compiler on any error.
+ *
+ ******************************************************************************/
+
+void
+FlSeekFile (
+    UINT32                  FileId,
+    long                    Offset)
+{
+    int                     Error;
+
+
+    Error = fseek (Gbl_Files[FileId].Handle, Offset, SEEK_SET);
+    if (Error)
+    {
+        FlFileError (FileId, ASL_MSG_SEEK);
+        AslAbort ();
+    }
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    FlCloseFile
+ *
+ * PARAMETERS:  FileId              - Index into file info array
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Close an open file. Aborts compiler on error
+ *
+ ******************************************************************************/
+
+void
+FlCloseFile (
+    UINT32                  FileId)
+{
+    int                     Error;
+
+
+    if (!Gbl_Files[FileId].Handle)
+    {
+        return;
+    }
+
+    Error = fclose (Gbl_Files[FileId].Handle);
+    if (Error)
+    {
+        FlFileError (FileId, ASL_MSG_CLOSE);
+        AslAbort ();
+    }
+
+    /* Do not clear/free the filename string */
+
+    Gbl_Files[FileId].Handle = NULL;
+    return;
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    FlDeleteFile
+ *
+ * PARAMETERS:  FileId              - Index into file info array
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Delete a file.
+ *
+ ******************************************************************************/
+
+void
+FlDeleteFile (
+    UINT32                  FileId)
+{
+    ASL_FILE_INFO           *Info = &Gbl_Files[FileId];
+
+
+    if (!Info->Filename)
+    {
+        return;
+    }
+
+    if (remove (Info->Filename))
+    {
+        printf ("%s (%s file) ",
+            Info->Filename, Info->Description);
+        perror ("Could not delete");
+    }
+
+    Info->Filename = NULL;
+    return;
+}
diff --git a/usr/src/cmd/acpi/iasl/aslfiles.c b/usr/src/cmd/acpi/iasl/aslfiles.c
new file mode 100644
index 0000000000..52939f433d
--- /dev/null
+++ b/usr/src/cmd/acpi/iasl/aslfiles.c
@@ -0,0 +1,927 @@
+/******************************************************************************
+ *
+ * Module Name: aslfiles - File support functions
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2016, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include "aslcompiler.h"
+#include "acapps.h"
+#include "dtcompiler.h"
+
+#define _COMPONENT          ACPI_COMPILER
+        ACPI_MODULE_NAME    ("aslfiles")
+
+/* Local prototypes */
+
+static FILE *
+FlOpenIncludeWithPrefix (
+    char                    *PrefixDir,
+    ACPI_PARSE_OBJECT       *Op,
+    char                    *Filename);
+
+#ifdef ACPI_OBSOLETE_FUNCTIONS
+ACPI_STATUS
+FlParseInputPathname (
+    char                    *InputFilename);
+#endif
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    FlSetLineNumber
+ *
+ * PARAMETERS:  Op        - Parse node for the LINE asl statement
+ *
+ * RETURN:      None.
+ *
+ * DESCRIPTION: Set the current line number
+ *
+ ******************************************************************************/
+
+void
+FlSetLineNumber (
+    UINT32                  LineNumber)
+{
+
+    DbgPrint (ASL_PARSE_OUTPUT, "\n#line: New line number %u (old %u)\n",
+         LineNumber, Gbl_LogicalLineNumber);
+
+    Gbl_CurrentLineNumber = LineNumber;
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    FlSetFilename
+ *
+ * PARAMETERS:  Op        - Parse node for the LINE asl statement
+ *
+ * RETURN:      None.
+ *
+ * DESCRIPTION: Set the current filename
+ *
+ ******************************************************************************/
+
+void
+FlSetFilename (
+    char                    *Filename)
+{
+
+    DbgPrint (ASL_PARSE_OUTPUT, "\n#line: New filename %s (old %s)\n",
+         Filename, Gbl_Files[ASL_FILE_INPUT].Filename);
+
+    /* No need to free any existing filename */
+
+    Gbl_Files[ASL_FILE_INPUT].Filename = Filename;
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    FlAddIncludeDirectory
+ *
+ * PARAMETERS:  Dir             - Directory pathname string
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Add a directory the list of include prefix directories.
+ *
+ ******************************************************************************/
+
+void
+FlAddIncludeDirectory (
+    char                    *Dir)
+{
+    ASL_INCLUDE_DIR         *NewDir;
+    ASL_INCLUDE_DIR         *NextDir;
+    ASL_INCLUDE_DIR         *PrevDir = NULL;
+    UINT32                  NeedsSeparator = 0;
+    size_t                  DirLength;
+
+
+    DirLength = strlen (Dir);
+    if (!DirLength)
+    {
+        return;
+    }
+
+    /* Make sure that the pathname ends with a path separator */
+
+    if ((Dir[DirLength-1] != '/') &&
+        (Dir[DirLength-1] != '\\'))
+    {
+        NeedsSeparator = 1;
+    }
+
+    NewDir = ACPI_ALLOCATE_ZEROED (sizeof (ASL_INCLUDE_DIR));
+    NewDir->Dir = ACPI_ALLOCATE (DirLength + 1 + NeedsSeparator);
+    strcpy (NewDir->Dir, Dir);
+    if (NeedsSeparator)
+    {
+        strcat (NewDir->Dir, "/");
+    }
+
+    /*
+     * Preserve command line ordering of -I options by adding new elements
+     * at the end of the list
+     */
+    NextDir = Gbl_IncludeDirList;
+    while (NextDir)
+    {
+        PrevDir = NextDir;
+        NextDir = NextDir->Next;
+    }
+
+    if (PrevDir)
+    {
+        PrevDir->Next = NewDir;
+    }
+    else
+    {
+        Gbl_IncludeDirList = NewDir;
+    }
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    FlMergePathnames
+ *
+ * PARAMETERS:  PrefixDir       - Prefix directory pathname. Can be NULL or
+ *                                a zero length string.
+ *              FilePathname    - The include filename from the source ASL.
+ *
+ * RETURN:      Merged pathname string
+ *
+ * DESCRIPTION: Merge two pathnames that (probably) have common elements, to
+ *              arrive at a minimal length string. Merge can occur if the
+ *              FilePathname is relative to the PrefixDir.
+ *
+ ******************************************************************************/
+
+char *
+FlMergePathnames (
+    char                    *PrefixDir,
+    char                    *FilePathname)
+{
+    char                    *CommonPath;
+    char                    *Pathname;
+    char                    *LastElement;
+
+
+    DbgPrint (ASL_PARSE_OUTPUT, "Include: Prefix path - \"%s\"\n"
+        "Include: FilePathname - \"%s\"\n",
+         PrefixDir, FilePathname);
+
+    /*
+     * If there is no prefix directory or if the file pathname is absolute,
+     * just return the original file pathname
+     */
+    if (!PrefixDir || (!*PrefixDir) ||
+        (*FilePathname == '/') ||
+         (FilePathname[1] == ':'))
+    {
+        Pathname = UtStringCacheCalloc (strlen (FilePathname) + 1);
+        strcpy (Pathname, FilePathname);
+        goto ConvertBackslashes;
+    }
+
+    /* Need a local copy of the prefix directory path */
+
+    CommonPath = UtStringCacheCalloc (strlen (PrefixDir) + 1);
+    strcpy (CommonPath, PrefixDir);
+
+    /*
+     * Walk forward through the file path, and simultaneously backward
+     * through the prefix directory path until there are no more
+     * relative references at the start of the file path.
+     */
+    while (*FilePathname && (!strncmp (FilePathname, "../", 3)))
+    {
+        /* Remove last element of the prefix directory path */
+
+        LastElement = strrchr (CommonPath, '/');
+        if (!LastElement)
+        {
+            goto ConcatenatePaths;
+        }
+
+        *LastElement = 0;   /* Terminate CommonPath string */
+        FilePathname += 3;  /* Point to next path element */
+    }
+
+    /*
+     * Remove the last element of the prefix directory path (it is the same as
+     * the first element of the file pathname), and build the final merged
+     * pathname.
+     */
+    LastElement = strrchr (CommonPath, '/');
+    if (LastElement)
+    {
+        *LastElement = 0;
+    }
+
+    /* Build the final merged pathname */
+
+ConcatenatePaths:
+    Pathname = UtStringCacheCalloc (
+        strlen (CommonPath) + strlen (FilePathname) + 2);
+    if (LastElement && *CommonPath)
+    {
+        strcpy (Pathname, CommonPath);
+        strcat (Pathname, "/");
+    }
+    strcat (Pathname, FilePathname);
+
+    /* Convert all backslashes to normal slashes */
+
+ConvertBackslashes:
+    UtConvertBackslashes (Pathname);
+
+    DbgPrint (ASL_PARSE_OUTPUT, "Include: Merged Pathname - \"%s\"\n",
+         Pathname);
+    return (Pathname);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    FlOpenIncludeWithPrefix
+ *
+ * PARAMETERS:  PrefixDir       - Prefix directory pathname. Can be a zero
+ *                                length string.
+ *              Filename        - The include filename from the source ASL.
+ *
+ * RETURN:      Valid file descriptor if successful. Null otherwise.
+ *
+ * DESCRIPTION: Open an include file and push it on the input file stack.
+ *
+ ******************************************************************************/
+
+static FILE *
+FlOpenIncludeWithPrefix (
+    char                    *PrefixDir,
+    ACPI_PARSE_OBJECT       *Op,
+    char                    *Filename)
+{
+    FILE                    *IncludeFile;
+    char                    *Pathname;
+    UINT32                  OriginalLineNumber;
+
+
+    /* Build the full pathname to the file */
+
+    Pathname = FlMergePathnames (PrefixDir, Filename);
+
+    DbgPrint (ASL_PARSE_OUTPUT, "Include: Opening file - \"%s\"\n\n",
+        Pathname);
+
+    /* Attempt to open the file, push if successful */
+
+    IncludeFile = fopen (Pathname, "r");
+    if (!IncludeFile)
+    {
+        fprintf (stderr, "Could not open include file %s\n", Pathname);
+        ACPI_FREE (Pathname);
+        return (NULL);
+    }
+
+    /*
+     * Check the entire include file for any # preprocessor directives.
+     * This is because there may be some confusion between the #include
+     * preprocessor directive and the ASL Include statement. A file included
+     * by the ASL include cannot contain preprocessor directives because
+     * the preprocessor has already run by the time the ASL include is
+     * recognized (by the compiler, not the preprocessor.)
+     *
+     * Note: DtGetNextLine strips/ignores comments.
+     * Save current line number since DtGetNextLine modifies it.
+     */
+    Gbl_CurrentLineNumber--;
+    OriginalLineNumber = Gbl_CurrentLineNumber;
+
+    while (DtGetNextLine (IncludeFile, DT_ALLOW_MULTILINE_QUOTES) != ASL_EOF)
+    {
+        if (Gbl_CurrentLineBuffer[0] == '#')
+        {
+            AslError (ASL_ERROR, ASL_MSG_INCLUDE_FILE,
+                Op, "use #include instead");
+        }
+    }
+
+    Gbl_CurrentLineNumber = OriginalLineNumber;
+
+    /* Must seek back to the start of the file */
+
+    fseek (IncludeFile, 0, SEEK_SET);
+
+    /* Push the include file on the open input file stack */
+
+    AslPushInputFileStack (IncludeFile, Pathname);
+    return (IncludeFile);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    FlOpenIncludeFile
+ *
+ * PARAMETERS:  Op        - Parse node for the INCLUDE ASL statement
+ *
+ * RETURN:      None.
+ *
+ * DESCRIPTION: Open an include file and push it on the input file stack.
+ *
+ ******************************************************************************/
+
+void
+FlOpenIncludeFile (
+    ACPI_PARSE_OBJECT       *Op)
+{
+    FILE                    *IncludeFile;
+    ASL_INCLUDE_DIR         *NextDir;
+
+
+    /* Op must be valid */
+
+    if (!Op)
+    {
+        AslCommonError (ASL_ERROR, ASL_MSG_INCLUDE_FILE_OPEN,
+            Gbl_CurrentLineNumber, Gbl_LogicalLineNumber,
+            Gbl_InputByteCount, Gbl_CurrentColumn,
+            Gbl_Files[ASL_FILE_INPUT].Filename, " - Null parse node");
+
+        return;
+    }
+
+    /*
+     * Flush out the "include ()" statement on this line, start
+     * the actual include file on the next line
+     */
+    AslResetCurrentLineBuffer ();
+    FlPrintFile (ASL_FILE_SOURCE_OUTPUT, "\n");
+    Gbl_CurrentLineOffset++;
+
+
+    /* Attempt to open the include file */
+
+    /* If the file specifies an absolute path, just open it */
+
+    if ((Op->Asl.Value.String[0] == '/')  ||
+        (Op->Asl.Value.String[0] == '\\') ||
+        (Op->Asl.Value.String[1] == ':'))
+    {
+        IncludeFile = FlOpenIncludeWithPrefix ("", Op, Op->Asl.Value.String);
+        if (!IncludeFile)
+        {
+            goto ErrorExit;
+        }
+        return;
+    }
+
+    /*
+     * The include filename is not an absolute path.
+     *
+     * First, search for the file within the "local" directory -- meaning
+     * the same directory that contains the source file.
+     *
+     * Construct the file pathname from the global directory name.
+     */
+    IncludeFile = FlOpenIncludeWithPrefix (
+        Gbl_DirectoryPath, Op, Op->Asl.Value.String);
+    if (IncludeFile)
+    {
+        return;
+    }
+
+    /*
+     * Second, search for the file within the (possibly multiple) directories
+     * specified by the -I option on the command line.
+     */
+    NextDir = Gbl_IncludeDirList;
+    while (NextDir)
+    {
+        IncludeFile = FlOpenIncludeWithPrefix (
+            NextDir->Dir, Op, Op->Asl.Value.String);
+        if (IncludeFile)
+        {
+            return;
+        }
+
+        NextDir = NextDir->Next;
+    }
+
+    /* We could not open the include file after trying very hard */
+
+ErrorExit:
+    sprintf (MsgBuffer, "%s, %s", Op->Asl.Value.String, strerror (errno));
+    AslError (ASL_ERROR, ASL_MSG_INCLUDE_FILE_OPEN, Op, MsgBuffer);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    FlOpenInputFile
+ *
+ * PARAMETERS:  InputFilename       - The user-specified ASL source file to be
+ *                                    compiled
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Open the specified input file, and save the directory path to
+ *              the file so that include files can be opened in
+ *              the same directory.
+ *
+ ******************************************************************************/
+
+ACPI_STATUS
+FlOpenInputFile (
+    char                    *InputFilename)
+{
+
+    /* Open the input ASL file, text mode */
+
+    FlOpenFile (ASL_FILE_INPUT, InputFilename, "rt");
+    AslCompilerin = Gbl_Files[ASL_FILE_INPUT].Handle;
+
+    return (AE_OK);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    FlOpenAmlOutputFile
+ *
+ * PARAMETERS:  FilenamePrefix       - The user-specified ASL source file
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Create the output filename (*.AML) and open the file. The file
+ *              is created in the same directory as the parent input file.
+ *
+ ******************************************************************************/
+
+ACPI_STATUS
+FlOpenAmlOutputFile (
+    char                    *FilenamePrefix)
+{
+    char                    *Filename;
+
+
+    /* Output filename usually comes from the ASL itself */
+
+    Filename = Gbl_Files[ASL_FILE_AML_OUTPUT].Filename;
+    if (!Filename)
+    {
+        /* Create the output AML filename */
+
+        Filename = FlGenerateFilename (FilenamePrefix, FILE_SUFFIX_AML_CODE);
+        if (!Filename)
+        {
+            AslCommonError (ASL_ERROR, ASL_MSG_OUTPUT_FILENAME,
+                0, 0, 0, 0, NULL, NULL);
+            return (AE_ERROR);
+        }
+
+        Gbl_Files[ASL_FILE_AML_OUTPUT].Filename = Filename;
+    }
+
+    /* Open the output AML file in binary mode */
+
+    FlOpenFile (ASL_FILE_AML_OUTPUT, Filename, "w+b");
+    return (AE_OK);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    FlOpenMiscOutputFiles
+ *
+ * PARAMETERS:  FilenamePrefix       - The user-specified ASL source file
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Create and open the various output files needed, depending on
+ *              the command line options
+ *
+ ******************************************************************************/
+
+ACPI_STATUS
+FlOpenMiscOutputFiles (
+    char                    *FilenamePrefix)
+{
+    char                    *Filename;
+
+
+     /* Create/Open a map file if requested */
+
+    if (Gbl_MapfileFlag)
+    {
+        Filename = FlGenerateFilename (FilenamePrefix, FILE_SUFFIX_MAP);
+        if (!Filename)
+        {
+            AslCommonError (ASL_ERROR, ASL_MSG_LISTING_FILENAME,
+                0, 0, 0, 0, NULL, NULL);
+            return (AE_ERROR);
+        }
+
+        /* Open the hex file, text mode (closed at compiler exit) */
+
+        FlOpenFile (ASL_FILE_MAP_OUTPUT, Filename, "w+t");
+
+        AslCompilerSignon (ASL_FILE_MAP_OUTPUT);
+        AslCompilerFileHeader (ASL_FILE_MAP_OUTPUT);
+    }
+
+    /* All done for disassembler */
+
+    if (Gbl_FileType == ASL_INPUT_TYPE_BINARY_ACPI_TABLE)
+    {
+        return (AE_OK);
+    }
+
+    /* Create/Open a hex output file if asked */
+
+    if (Gbl_HexOutputFlag)
+    {
+        Filename = FlGenerateFilename (FilenamePrefix, FILE_SUFFIX_HEX_DUMP);
+        if (!Filename)
+        {
+            AslCommonError (ASL_ERROR, ASL_MSG_LISTING_FILENAME,
+                0, 0, 0, 0, NULL, NULL);
+            return (AE_ERROR);
+        }
+
+        /* Open the hex file, text mode */
+
+        FlOpenFile (ASL_FILE_HEX_OUTPUT, Filename, "w+t");
+
+        AslCompilerSignon (ASL_FILE_HEX_OUTPUT);
+        AslCompilerFileHeader (ASL_FILE_HEX_OUTPUT);
+    }
+
+    /* Create/Open a debug output file if asked */
+
+    if (Gbl_DebugFlag)
+    {
+        Filename = FlGenerateFilename (FilenamePrefix, FILE_SUFFIX_DEBUG);
+        if (!Filename)
+        {
+            AslCommonError (ASL_ERROR, ASL_MSG_DEBUG_FILENAME,
+                0, 0, 0, 0, NULL, NULL);
+            return (AE_ERROR);
+        }
+
+        /* Open the debug file as STDERR, text mode */
+
+        Gbl_Files[ASL_FILE_DEBUG_OUTPUT].Filename = Filename;
+        Gbl_Files[ASL_FILE_DEBUG_OUTPUT].Handle =
+            freopen (Filename, "w+t", stderr);
+
+        if (!Gbl_Files[ASL_FILE_DEBUG_OUTPUT].Handle)
+        {
+            /*
+             * A problem with freopen is that on error, we no longer
+             * have stderr and cannot emit normal error messages.
+             * Emit error to stdout, close files, and exit.
+             */
+            fprintf (stdout,
+                "\nCould not open debug output file: %s\n\n", Filename);
+
+            CmCleanupAndExit ();
+            exit (1);
+        }
+
+        AslCompilerSignon (ASL_FILE_DEBUG_OUTPUT);
+        AslCompilerFileHeader (ASL_FILE_DEBUG_OUTPUT);
+    }
+
+    /* Create/Open a cross-reference output file if asked */
+
+    if (Gbl_CrossReferenceOutput)
+    {
+        Filename = FlGenerateFilename (FilenamePrefix, FILE_SUFFIX_XREF);
+        if (!Filename)
+        {
+            AslCommonError (ASL_ERROR, ASL_MSG_DEBUG_FILENAME,
+                0, 0, 0, 0, NULL, NULL);
+            return (AE_ERROR);
+        }
+
+        FlOpenFile (ASL_FILE_XREF_OUTPUT, Filename, "w+t");
+
+        AslCompilerSignon (ASL_FILE_XREF_OUTPUT);
+        AslCompilerFileHeader (ASL_FILE_XREF_OUTPUT);
+    }
+
+    /* Create/Open a listing output file if asked */
+
+    if (Gbl_ListingFlag)
+    {
+        Filename = FlGenerateFilename (FilenamePrefix, FILE_SUFFIX_LISTING);
+        if (!Filename)
+        {
+            AslCommonError (ASL_ERROR, ASL_MSG_LISTING_FILENAME,
+                0, 0, 0, 0, NULL, NULL);
+            return (AE_ERROR);
+        }
+
+        /* Open the listing file, text mode */
+
+        FlOpenFile (ASL_FILE_LISTING_OUTPUT, Filename, "w+t");
+
+        AslCompilerSignon (ASL_FILE_LISTING_OUTPUT);
+        AslCompilerFileHeader (ASL_FILE_LISTING_OUTPUT);
+    }
+
+    /* Create the preprocessor output temp file if preprocessor enabled */
+
+    if (Gbl_PreprocessFlag)
+    {
+        Filename = FlGenerateFilename (FilenamePrefix, FILE_SUFFIX_PREPROCESSOR);
+        if (!Filename)
+        {
+            AslCommonError (ASL_ERROR, ASL_MSG_PREPROCESSOR_FILENAME,
+                0, 0, 0, 0, NULL, NULL);
+            return (AE_ERROR);
+        }
+
+        FlOpenFile (ASL_FILE_PREPROCESSOR, Filename, "w+t");
+    }
+
+    /*
+     * Create the "user" preprocessor output file if -li flag set.
+     * Note, this file contains no embedded #line directives.
+     */
+    if (Gbl_PreprocessorOutputFlag)
+    {
+        Filename = FlGenerateFilename (FilenamePrefix, FILE_SUFFIX_PREPROC_USER);
+        if (!Filename)
+        {
+            AslCommonError (ASL_ERROR, ASL_MSG_PREPROCESSOR_FILENAME,
+                0, 0, 0, 0, NULL, NULL);
+            return (AE_ERROR);
+        }
+
+        FlOpenFile (ASL_FILE_PREPROCESSOR_USER, Filename, "w+t");
+    }
+
+    /* All done for data table compiler */
+
+    if (Gbl_FileType == ASL_INPUT_TYPE_ASCII_DATA)
+    {
+        return (AE_OK);
+    }
+
+    /* Create/Open a combined source output file */
+
+    Filename = FlGenerateFilename (FilenamePrefix, FILE_SUFFIX_SOURCE);
+    if (!Filename)
+    {
+        AslCommonError (ASL_ERROR, ASL_MSG_LISTING_FILENAME,
+            0, 0, 0, 0, NULL, NULL);
+        return (AE_ERROR);
+    }
+
+    /*
+     * Open the source output file, binary mode (so that LF does not get
+     * expanded to CR/LF on some systems, messing up our seek
+     * calculations.)
+     */
+    FlOpenFile (ASL_FILE_SOURCE_OUTPUT, Filename, "w+b");
+
+/*
+// TBD: TEMP
+//    AslCompilerin = Gbl_Files[ASL_FILE_SOURCE_OUTPUT].Handle;
+*/
+    /* Create/Open a assembly code source output file if asked */
+
+    if (Gbl_AsmOutputFlag)
+    {
+        Filename = FlGenerateFilename (FilenamePrefix, FILE_SUFFIX_ASM_SOURCE);
+        if (!Filename)
+        {
+            AslCommonError (ASL_ERROR, ASL_MSG_LISTING_FILENAME,
+                0, 0, 0, 0, NULL, NULL);
+            return (AE_ERROR);
+        }
+
+        /* Open the assembly code source file, text mode */
+
+        FlOpenFile (ASL_FILE_ASM_SOURCE_OUTPUT, Filename, "w+t");
+
+        AslCompilerSignon (ASL_FILE_ASM_SOURCE_OUTPUT);
+        AslCompilerFileHeader (ASL_FILE_ASM_SOURCE_OUTPUT);
+    }
+
+    /* Create/Open a C code source output file if asked */
+
+    if (Gbl_C_OutputFlag)
+    {
+        Filename = FlGenerateFilename (FilenamePrefix, FILE_SUFFIX_C_SOURCE);
+        if (!Filename)
+        {
+            AslCommonError (ASL_ERROR, ASL_MSG_LISTING_FILENAME,
+                0, 0, 0, 0, NULL, NULL);
+            return (AE_ERROR);
+        }
+
+        /* Open the C code source file, text mode */
+
+        FlOpenFile (ASL_FILE_C_SOURCE_OUTPUT, Filename, "w+t");
+
+        FlPrintFile (ASL_FILE_C_SOURCE_OUTPUT, "/*\n");
+        AslCompilerSignon (ASL_FILE_C_SOURCE_OUTPUT);
+        AslCompilerFileHeader (ASL_FILE_C_SOURCE_OUTPUT);
+    }
+
+    /* Create/Open a C code source output file for the offset table if asked */
+
+    if (Gbl_C_OffsetTableFlag)
+    {
+        Filename = FlGenerateFilename (FilenamePrefix, FILE_SUFFIX_C_OFFSET);
+        if (!Filename)
+        {
+            AslCommonError (ASL_ERROR, ASL_MSG_LISTING_FILENAME,
+                0, 0, 0, 0, NULL, NULL);
+            return (AE_ERROR);
+        }
+
+        /* Open the C code source file, text mode */
+
+        FlOpenFile (ASL_FILE_C_OFFSET_OUTPUT, Filename, "w+t");
+
+        FlPrintFile (ASL_FILE_C_OFFSET_OUTPUT, "/*\n");
+        AslCompilerSignon (ASL_FILE_C_OFFSET_OUTPUT);
+        AslCompilerFileHeader (ASL_FILE_C_OFFSET_OUTPUT);
+    }
+
+    /* Create/Open a assembly include output file if asked */
+
+    if (Gbl_AsmIncludeOutputFlag)
+    {
+        Filename = FlGenerateFilename (FilenamePrefix, FILE_SUFFIX_ASM_INCLUDE);
+        if (!Filename)
+        {
+            AslCommonError (ASL_ERROR, ASL_MSG_LISTING_FILENAME,
+                0, 0, 0, 0, NULL, NULL);
+            return (AE_ERROR);
+        }
+
+        /* Open the assembly include file, text mode */
+
+        FlOpenFile (ASL_FILE_ASM_INCLUDE_OUTPUT, Filename, "w+t");
+
+        AslCompilerSignon (ASL_FILE_ASM_INCLUDE_OUTPUT);
+        AslCompilerFileHeader (ASL_FILE_ASM_INCLUDE_OUTPUT);
+    }
+
+    /* Create/Open a C include output file if asked */
+
+    if (Gbl_C_IncludeOutputFlag)
+    {
+        Filename = FlGenerateFilename (FilenamePrefix, FILE_SUFFIX_C_INCLUDE);
+        if (!Filename)
+        {
+            AslCommonError (ASL_ERROR, ASL_MSG_LISTING_FILENAME,
+                0, 0, 0, 0, NULL, NULL);
+            return (AE_ERROR);
+        }
+
+        /* Open the C include file, text mode */
+
+        FlOpenFile (ASL_FILE_C_INCLUDE_OUTPUT, Filename, "w+t");
+
+        FlPrintFile (ASL_FILE_C_INCLUDE_OUTPUT, "/*\n");
+        AslCompilerSignon (ASL_FILE_C_INCLUDE_OUTPUT);
+        AslCompilerFileHeader (ASL_FILE_C_INCLUDE_OUTPUT);
+    }
+
+    /* Create a namespace output file if asked */
+
+    if (Gbl_NsOutputFlag)
+    {
+        Filename = FlGenerateFilename (FilenamePrefix, FILE_SUFFIX_NAMESPACE);
+        if (!Filename)
+        {
+            AslCommonError (ASL_ERROR, ASL_MSG_LISTING_FILENAME,
+                0, 0, 0, 0, NULL, NULL);
+            return (AE_ERROR);
+        }
+
+        /* Open the namespace file, text mode */
+
+        FlOpenFile (ASL_FILE_NAMESPACE_OUTPUT, Filename, "w+t");
+
+        AslCompilerSignon (ASL_FILE_NAMESPACE_OUTPUT);
+        AslCompilerFileHeader (ASL_FILE_NAMESPACE_OUTPUT);
+    }
+
+    return (AE_OK);
+}
+
+
+#ifdef ACPI_OBSOLETE_FUNCTIONS
+/*******************************************************************************
+ *
+ * FUNCTION:    FlParseInputPathname
+ *
+ * PARAMETERS:  InputFilename       - The user-specified ASL source file to be
+ *                                    compiled
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Split the input path into a directory and filename part
+ *              1) Directory part used to open include files
+ *              2) Filename part used to generate output filenames
+ *
+ ******************************************************************************/
+
+ACPI_STATUS
+FlParseInputPathname (
+    char                    *InputFilename)
+{
+    char                    *Substring;
+
+
+    if (!InputFilename)
+    {
+        return (AE_OK);
+    }
+
+    /* Get the path to the input filename's directory */
+
+    Gbl_DirectoryPath = strdup (InputFilename);
+    if (!Gbl_DirectoryPath)
+    {
+        return (AE_NO_MEMORY);
+    }
+
+    Substring = strrchr (Gbl_DirectoryPath, '\\');
+    if (!Substring)
+    {
+        Substring = strrchr (Gbl_DirectoryPath, '/');
+        if (!Substring)
+        {
+            Substring = strrchr (Gbl_DirectoryPath, ':');
+        }
+    }
+
+    if (!Substring)
+    {
+        Gbl_DirectoryPath[0] = 0;
+        if (Gbl_UseDefaultAmlFilename)
+        {
+            Gbl_OutputFilenamePrefix = strdup (InputFilename);
+        }
+    }
+    else
+    {
+        if (Gbl_UseDefaultAmlFilename)
+        {
+            Gbl_OutputFilenamePrefix = strdup (Substring + 1);
+        }
+        *(Substring+1) = 0;
+    }
+
+    UtConvertBackslashes (Gbl_OutputFilenamePrefix);
+    return (AE_OK);
+}
+#endif
diff --git a/usr/src/cmd/acpi/iasl/aslfold.c b/usr/src/cmd/acpi/iasl/aslfold.c
new file mode 100644
index 0000000000..93b49b0515
--- /dev/null
+++ b/usr/src/cmd/acpi/iasl/aslfold.c
@@ -0,0 +1,884 @@
+/******************************************************************************
+ *
+ * Module Name: aslfold - Constant folding
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2016, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include "aslcompiler.h"
+#include "aslcompiler.y.h"
+#include "amlcode.h"
+
+#include "acdispat.h"
+#include "acparser.h"
+
+#define _COMPONENT          ACPI_COMPILER
+        ACPI_MODULE_NAME    ("aslfold")
+
+/* Local prototypes */
+
+static ACPI_STATUS
+OpcAmlEvaluationWalk1 (
+    ACPI_PARSE_OBJECT       *Op,
+    UINT32                  Level,
+    void                    *Context);
+
+static ACPI_STATUS
+OpcAmlEvaluationWalk2 (
+    ACPI_PARSE_OBJECT       *Op,
+    UINT32                  Level,
+    void                    *Context);
+
+static ACPI_STATUS
+OpcAmlCheckForConstant (
+    ACPI_PARSE_OBJECT       *Op,
+    UINT32                  Level,
+    void                    *Context);
+
+static void
+OpcUpdateIntegerNode (
+    ACPI_PARSE_OBJECT       *Op,
+    UINT64                  Value);
+
+static ACPI_STATUS
+TrTransformToStoreOp (
+    ACPI_PARSE_OBJECT       *Op,
+    ACPI_WALK_STATE         *WalkState);
+
+static ACPI_STATUS
+TrSimpleConstantReduction (
+    ACPI_PARSE_OBJECT       *Op,
+    ACPI_WALK_STATE         *WalkState);
+
+static void
+TrInstallReducedConstant (
+    ACPI_PARSE_OBJECT       *Op,
+    ACPI_OPERAND_OBJECT     *ObjDesc);
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    OpcAmlConstantWalk
+ *
+ * PARAMETERS:  ASL_WALK_CALLBACK
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Reduce an Op and its subtree to a constant if possible.
+ *              Called during ascent of the parse tree.
+ *
+ ******************************************************************************/
+
+ACPI_STATUS
+OpcAmlConstantWalk (
+    ACPI_PARSE_OBJECT       *Op,
+    UINT32                  Level,
+    void                    *Context)
+{
+    ACPI_WALK_STATE         *WalkState;
+    ACPI_STATUS             Status = AE_OK;
+
+
+    if (Op->Asl.CompileFlags == 0)
+    {
+        return (AE_OK);
+    }
+
+    /*
+     * Only interested in subtrees that could possibly contain
+     * expressions that can be evaluated at this time
+     */
+    if ((!(Op->Asl.CompileFlags & NODE_COMPILE_TIME_CONST)) ||
+          (Op->Asl.CompileFlags & NODE_IS_TARGET))
+    {
+        return (AE_OK);
+    }
+
+    /* Create a new walk state */
+
+    WalkState = AcpiDsCreateWalkState (0, NULL, NULL, NULL);
+    if (!WalkState)
+    {
+        return (AE_NO_MEMORY);
+    }
+
+    WalkState->NextOp = NULL;
+    WalkState->Params = NULL;
+
+    /*
+     * Examine the entire subtree -- all nodes must be constants
+     * or type 3/4/5 opcodes
+     */
+    Status = TrWalkParseTree (Op, ASL_WALK_VISIT_DOWNWARD,
+        OpcAmlCheckForConstant, NULL, WalkState);
+
+    /*
+     * Did we find an entire subtree that contains all constants
+     * and type 3/4/5 opcodes?
+     */
+    switch (Status)
+    {
+    case AE_OK:
+
+        /* Simple case, like Add(3,4) -> 7 */
+
+        Status = TrSimpleConstantReduction (Op, WalkState);
+        break;
+
+    case AE_CTRL_RETURN_VALUE:
+
+        /* More complex case, like Add(3,4,Local0) -> Store(7,Local0) */
+
+        Status = TrTransformToStoreOp (Op, WalkState);
+        break;
+
+    case AE_TYPE:
+
+        AcpiDsDeleteWalkState (WalkState);
+        return (AE_OK);
+
+    default:
+        AcpiDsDeleteWalkState (WalkState);
+        break;
+    }
+
+    if (ACPI_FAILURE (Status))
+    {
+        DbgPrint (ASL_PARSE_OUTPUT, "Cannot resolve, %s\n",
+            AcpiFormatException (Status));
+
+        /* We could not resolve the subtree for some reason */
+
+        AslError (ASL_ERROR, ASL_MSG_CONSTANT_EVALUATION, Op,
+            (char *) AcpiFormatException (Status));
+
+        /* Set the subtree value to ZERO anyway. Eliminates further errors */
+
+        OpcUpdateIntegerNode (Op, 0);
+    }
+
+    return (AE_OK);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    OpcAmlCheckForConstant
+ *
+ * PARAMETERS:  ASL_WALK_CALLBACK
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Check one Op for a reducible type 3/4/5 AML opcode.
+ *              This is performed via an upward walk of the parse subtree.
+ *
+ ******************************************************************************/
+
+static ACPI_STATUS
+OpcAmlCheckForConstant (
+    ACPI_PARSE_OBJECT       *Op,
+    UINT32                  Level,
+    void                    *Context)
+{
+    ACPI_WALK_STATE         *WalkState = Context;
+    ACPI_STATUS             Status = AE_OK;
+    ACPI_PARSE_OBJECT       *NextOp;
+    const ACPI_OPCODE_INFO  *OpInfo;
+
+
+    WalkState->Op = Op;
+    WalkState->Opcode = Op->Common.AmlOpcode;
+    WalkState->OpInfo = AcpiPsGetOpcodeInfo (Op->Common.AmlOpcode);
+
+    DbgPrint (ASL_PARSE_OUTPUT, "[%.4d] Opcode: %12.12s ",
+        Op->Asl.LogicalLineNumber, Op->Asl.ParseOpName);
+
+    /*
+     * These opcodes do not appear in the OpcodeInfo table, but
+     * they represent constants, so abort the constant walk now.
+     */
+    if ((WalkState->Opcode == AML_RAW_DATA_BYTE) ||
+        (WalkState->Opcode == AML_RAW_DATA_WORD) ||
+        (WalkState->Opcode == AML_RAW_DATA_DWORD) ||
+        (WalkState->Opcode == AML_RAW_DATA_QWORD))
+    {
+        DbgPrint (ASL_PARSE_OUTPUT, "RAW DATA");
+        Status = AE_TYPE;
+        goto CleanupAndExit;
+    }
+
+    /*
+     * Search upwards for a possible Name() operator. This is done
+     * because a type 3/4/5 opcode within a Name() expression
+     * MUST be reduced to a simple constant.
+     */
+    NextOp = Op->Asl.Parent;
+    while (NextOp)
+    {
+        /* Finished if we find a Name() opcode */
+
+        if (NextOp->Asl.AmlOpcode == AML_NAME_OP)
+        {
+            break;
+        }
+
+        /*
+         * Any "deferred" opcodes contain one or more TermArg parameters,
+         * and thus are not required to be folded to constants at compile
+         * time. This affects things like Buffer() and Package() objects.
+         * We just ignore them here. However, any sub-expressions can and
+         * will still be typechecked. Note: These are called the
+         * "deferred" opcodes in the AML interpreter.
+         */
+        OpInfo = AcpiPsGetOpcodeInfo (NextOp->Common.AmlOpcode);
+        if (OpInfo->Flags & AML_DEFER)
+        {
+            NextOp = NULL;
+            break;
+        }
+
+        NextOp = NextOp->Asl.Parent;
+    }
+
+    /* Type 3/4/5 opcodes have the AML_CONSTANT flag set */
+
+    if (!(WalkState->OpInfo->Flags & AML_CONSTANT))
+    {
+        /*
+         * From the ACPI specification:
+         *
+         * "The Type 3/4/5 opcodes return a value and can be used in an
+         * expression that evaluates to a constant. These opcodes may be
+         * evaluated at ASL compile-time. To ensure that these opcodes
+         * will evaluate to a constant, the following rules apply: The
+         * term cannot have a destination (target) operand, and must have
+         * either a Type3Opcode, Type4Opcode, Type5Opcode, ConstExprTerm,
+         * Integer, BufferTerm, Package, or String for all arguments."
+         */
+
+        /*
+         * The value (second) operand for the Name() operator MUST
+         * reduce to a single constant, as per the ACPI specification
+         * (the operand is a DataObject). This also implies that there
+         * can be no target operand. Name() is the only ASL operator
+         * with a "DataObject" as an operand and is thus special-
+         * cased here.
+         */
+        if (NextOp) /* Inspect a Name() operator */
+        {
+            /* Error if there is a target operand */
+
+            if (Op->Asl.CompileFlags & NODE_IS_TARGET)
+            {
+                AslError (ASL_ERROR, ASL_MSG_INVALID_TARGET, Op, NULL);
+                Status = AE_TYPE;
+            }
+
+            /* Error if expression cannot be reduced (folded) */
+
+            if (!(NextOp->Asl.CompileFlags & NODE_COULD_NOT_REDUCE))
+            {
+                /* Ensure only one error message per statement */
+
+                NextOp->Asl.CompileFlags |= NODE_COULD_NOT_REDUCE;
+                DbgPrint (ASL_PARSE_OUTPUT,
+                    "**** Could not reduce operands for NAME opcode ****\n");
+
+                AslError (ASL_ERROR, ASL_MSG_CONSTANT_REQUIRED, Op,
+                    "Constant is required for Name operator");
+                Status = AE_TYPE;
+            }
+        }
+
+        if (ACPI_FAILURE (Status))
+        {
+            goto CleanupAndExit;
+        }
+
+        /* This is not a 3/4/5 opcode, but maybe can convert to STORE */
+
+        if (Op->Asl.CompileFlags & NODE_IS_TARGET)
+        {
+            DbgPrint (ASL_PARSE_OUTPUT,
+                "**** Valid Target, transform to Store ****\n");
+            return (AE_CTRL_RETURN_VALUE);
+        }
+
+        /* Expression cannot be reduced */
+
+        DbgPrint (ASL_PARSE_OUTPUT,
+            "**** Not a Type 3/4/5 opcode or cannot reduce/fold (%s) ****\n",
+             Op->Asl.ParseOpName);
+
+        Status = AE_TYPE;
+        goto CleanupAndExit;
+    }
+
+    /*
+     * TBD: Ignore buffer constants for now. The problem is that these
+     * constants have been transformed into RAW_DATA at this point, from
+     * the parse tree transform process which currently happens before
+     * the constant folding process. We may need to defer this transform
+     * for buffer until after the constant folding.
+     */
+    if (WalkState->Opcode == AML_BUFFER_OP)
+    {
+        DbgPrint (ASL_PARSE_OUTPUT,
+            "\nBuffer constant reduction is not supported yet\n");
+
+        if (NextOp) /* Found a Name() operator, error */
+        {
+            AslError (ASL_ERROR, ASL_MSG_UNSUPPORTED, Op,
+                "Buffer expression cannot be reduced");
+        }
+
+        Status = AE_TYPE;
+        goto CleanupAndExit;
+    }
+
+    /* Debug output */
+
+    DbgPrint (ASL_PARSE_OUTPUT, "TYPE_345");
+
+    if (Op->Asl.CompileFlags & NODE_IS_TARGET)
+    {
+        if (Op->Asl.ParseOpcode == PARSEOP_ZERO)
+        {
+            DbgPrint (ASL_PARSE_OUTPUT, "%-16s", " NULL TARGET");
+        }
+        else
+        {
+            DbgPrint (ASL_PARSE_OUTPUT, "%-16s", " VALID TARGET");
+        }
+    }
+
+    if (Op->Asl.CompileFlags & NODE_IS_TERM_ARG)
+    {
+        DbgPrint (ASL_PARSE_OUTPUT, "%-16s", " TERMARG");
+    }
+
+CleanupAndExit:
+
+    /* Dump the node compile flags also */
+
+    TrPrintNodeCompileFlags (Op->Asl.CompileFlags);
+    DbgPrint (ASL_PARSE_OUTPUT, "\n");
+    return (Status);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    TrSimpleConstantReduction
+ *
+ * PARAMETERS:  Op                  - Parent operator to be transformed
+ *              WalkState           - Current walk state
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Reduce an entire AML operation to a single constant. The
+ *              operation must not have a target operand.
+ *
+ *              Add (32,64) --> 96
+ *
+ ******************************************************************************/
+
+static ACPI_STATUS
+TrSimpleConstantReduction (
+    ACPI_PARSE_OBJECT       *Op,
+    ACPI_WALK_STATE         *WalkState)
+{
+    ACPI_PARSE_OBJECT       *RootOp;
+    ACPI_PARSE_OBJECT       *OriginalParentOp;
+    ACPI_OPERAND_OBJECT     *ObjDesc;
+    ACPI_STATUS             Status;
+
+
+    DbgPrint (ASL_PARSE_OUTPUT,
+        "Simple subtree constant reduction, operator to constant\n");
+
+    /* Allocate a new temporary root for this subtree */
+
+    RootOp = TrAllocateNode (PARSEOP_INTEGER);
+    if (!RootOp)
+    {
+        return (AE_NO_MEMORY);
+    }
+
+    RootOp->Common.AmlOpcode = AML_INT_EVAL_SUBTREE_OP;
+
+    OriginalParentOp = Op->Common.Parent;
+    Op->Common.Parent = RootOp;
+
+    /* Hand off the subtree to the AML interpreter */
+
+    WalkState->CallerReturnDesc = &ObjDesc;
+
+    Status = TrWalkParseTree (Op, ASL_WALK_VISIT_TWICE,
+        OpcAmlEvaluationWalk1, OpcAmlEvaluationWalk2, WalkState);
+
+    /* Restore original parse tree */
+
+    Op->Common.Parent = OriginalParentOp;
+
+    if (ACPI_FAILURE (Status))
+    {
+        DbgPrint (ASL_PARSE_OUTPUT,
+            "Constant Subtree evaluation(1), %s\n",
+            AcpiFormatException (Status));
+        return (Status);
+    }
+
+    /* Get the final result */
+
+    Status = AcpiDsResultPop (&ObjDesc, WalkState);
+    if (ACPI_FAILURE (Status))
+    {
+        DbgPrint (ASL_PARSE_OUTPUT,
+            "Constant Subtree evaluation(2), %s\n",
+            AcpiFormatException (Status));
+        return (Status);
+    }
+
+    /* Disconnect any existing children, install new constant */
+
+    Op->Asl.Child = NULL;
+    TrInstallReducedConstant (Op, ObjDesc);
+
+    UtSetParseOpName (Op);
+    return (AE_OK);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    TrTransformToStoreOp
+ *
+ * PARAMETERS:  Op                  - Parent operator to be transformed
+ *              WalkState           - Current walk state
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Transforms a single AML operation with a constant and target
+ *              to a simple store operation:
+ *
+ *              Add (32,64,DATA) --> Store (96,DATA)
+ *
+ ******************************************************************************/
+
+static ACPI_STATUS
+TrTransformToStoreOp (
+    ACPI_PARSE_OBJECT       *Op,
+    ACPI_WALK_STATE         *WalkState)
+{
+    ACPI_PARSE_OBJECT       *OriginalTarget;
+    ACPI_PARSE_OBJECT       *NewTarget;
+    ACPI_PARSE_OBJECT       *Child1;
+    ACPI_PARSE_OBJECT       *Child2;
+    ACPI_OPERAND_OBJECT     *ObjDesc;
+    ACPI_PARSE_OBJECT       *NewParent;
+    ACPI_PARSE_OBJECT       *OriginalParent;
+    ACPI_STATUS             Status;
+
+
+    /* Extract the operands */
+
+    Child1 = Op->Asl.Child;
+    Child2 = Child1->Asl.Next;
+
+    /*
+     * Special case for DIVIDE -- it has two targets. The first
+     * is for the remainder and if present, we will not attempt
+     * to reduce the expression.
+     */
+    if (Op->Asl.ParseOpcode == PARSEOP_DIVIDE)
+    {
+        Child2 = Child2->Asl.Next;
+        if (Child2->Asl.ParseOpcode != PARSEOP_ZERO)
+        {
+            DbgPrint (ASL_PARSE_OUTPUT,
+                "Cannot reduce DIVIDE - has two targets\n\n");
+            return (AE_OK);
+        }
+    }
+
+    DbgPrint (ASL_PARSE_OUTPUT,
+        "Reduction/Transform to StoreOp: Store(%s, %s)\n",
+        Child1->Asl.ParseOpName, Child2->Asl.ParseOpName);
+
+    /*
+     * Create a NULL (zero) target so that we can use the
+     * interpreter to evaluate the expression.
+     */
+    NewTarget = TrCreateNullTarget ();
+    NewTarget->Common.AmlOpcode = AML_INT_NAMEPATH_OP;
+
+    /* Handle one-operand cases (NOT, TOBCD, etc.) */
+
+    if (!Child2->Asl.Next)
+    {
+        Child2 = Child1;
+    }
+
+    /* Link in new NULL target as the last operand */
+
+    OriginalTarget = Child2->Asl.Next;
+    Child2->Asl.Next = NewTarget;
+    NewTarget->Asl.Parent = OriginalTarget->Asl.Parent;
+
+    NewParent = TrAllocateNode (PARSEOP_INTEGER);
+    NewParent->Common.AmlOpcode = AML_INT_EVAL_SUBTREE_OP;
+
+    OriginalParent = Op->Common.Parent;
+    Op->Common.Parent = NewParent;
+
+    /* Hand off the subtree to the AML interpreter */
+
+    WalkState->CallerReturnDesc = &ObjDesc;
+
+    Status = TrWalkParseTree (Op, ASL_WALK_VISIT_TWICE,
+        OpcAmlEvaluationWalk1, OpcAmlEvaluationWalk2, WalkState);
+    if (ACPI_FAILURE (Status))
+    {
+        DbgPrint (ASL_PARSE_OUTPUT,
+            "Constant Subtree evaluation(3), %s\n",
+            AcpiFormatException (Status));
+        goto EvalError;
+    }
+
+    /* Get the final result */
+
+    Status = AcpiDsResultPop (&ObjDesc, WalkState);
+    if (ACPI_FAILURE (Status))
+    {
+        DbgPrint (ASL_PARSE_OUTPUT,
+            "Constant Subtree evaluation(4), %s\n",
+            AcpiFormatException (Status));
+        goto EvalError;
+    }
+
+    /* Truncate any subtree expressions, they have been evaluated */
+
+    Child1->Asl.Child = NULL;
+
+    /* Folded constant is in ObjDesc, store into Child1 */
+
+    TrInstallReducedConstant (Child1, ObjDesc);
+
+    /* Convert operator to STORE */
+
+    Op->Asl.ParseOpcode = PARSEOP_STORE;
+    Op->Asl.AmlOpcode = AML_STORE_OP;
+    UtSetParseOpName (Op);
+    Op->Common.Parent = OriginalParent;
+
+    /* First child is the folded constant */
+
+    /* Second child will be the target */
+
+    Child1->Asl.Next = OriginalTarget;
+    return (AE_OK);
+
+
+EvalError:
+
+    /* Restore original links */
+
+    Op->Common.Parent = OriginalParent;
+    Child2->Asl.Next = OriginalTarget;
+    return (Status);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    TrInstallReducedConstant
+ *
+ * PARAMETERS:  Op                  - Parent operator to be transformed
+ *              ObjDesc             - Reduced constant to be installed
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Transform the original operator to a simple constant.
+ *              Handles Integers, Strings, and Buffers.
+ *
+ ******************************************************************************/
+
+static void
+TrInstallReducedConstant (
+    ACPI_PARSE_OBJECT       *Op,
+    ACPI_OPERAND_OBJECT     *ObjDesc)
+{
+    ACPI_PARSE_OBJECT       *LengthOp;
+    ACPI_PARSE_OBJECT       *DataOp;
+
+
+    TotalFolds++;
+    AslError (ASL_OPTIMIZATION, ASL_MSG_CONSTANT_FOLDED, Op,
+        Op->Asl.ParseOpName);
+
+    /*
+     * Because we know we executed type 3/4/5 opcodes above, we know that
+     * the result must be either an Integer, String, or Buffer.
+     */
+    switch (ObjDesc->Common.Type)
+    {
+    case ACPI_TYPE_INTEGER:
+
+        OpcUpdateIntegerNode (Op, ObjDesc->Integer.Value);
+
+        DbgPrint (ASL_PARSE_OUTPUT,
+            "Constant expression reduced to (%s) %8.8X%8.8X\n\n",
+            Op->Asl.ParseOpName,
+            ACPI_FORMAT_UINT64 (Op->Common.Value.Integer));
+        break;
+
+    case ACPI_TYPE_STRING:
+
+        Op->Asl.ParseOpcode = PARSEOP_STRING_LITERAL;
+        Op->Common.AmlOpcode = AML_STRING_OP;
+        Op->Asl.AmlLength = strlen (ObjDesc->String.Pointer) + 1;
+        Op->Common.Value.String = ObjDesc->String.Pointer;
+
+        DbgPrint (ASL_PARSE_OUTPUT,
+            "Constant expression reduced to (STRING) %s\n\n",
+            Op->Common.Value.String);
+        break;
+
+    case ACPI_TYPE_BUFFER:
+        /*
+         * Create a new parse subtree of the form:
+         *
+         * BUFFER (Buffer AML opcode)
+         *    INTEGER (Buffer length in bytes)
+         *    RAW_DATA (Buffer byte data)
+         */
+        Op->Asl.ParseOpcode = PARSEOP_BUFFER;
+        Op->Common.AmlOpcode = AML_BUFFER_OP;
+        Op->Asl.CompileFlags = NODE_AML_PACKAGE;
+        UtSetParseOpName (Op);
+
+        /* Child node is the buffer length */
+
+        LengthOp = TrAllocateNode (PARSEOP_INTEGER);
+
+        LengthOp->Asl.AmlOpcode = AML_DWORD_OP;
+        LengthOp->Asl.Value.Integer = ObjDesc->Buffer.Length;
+        LengthOp->Asl.Parent = Op;
+        (void) OpcSetOptimalIntegerSize (LengthOp);
+
+        Op->Asl.Child = LengthOp;
+
+        /* Next child is the raw buffer data */
+
+        DataOp = TrAllocateNode (PARSEOP_RAW_DATA);
+        DataOp->Asl.AmlOpcode = AML_RAW_DATA_BUFFER;
+        DataOp->Asl.AmlLength = ObjDesc->Buffer.Length;
+        DataOp->Asl.Value.String = (char *) ObjDesc->Buffer.Pointer;
+        DataOp->Asl.Parent = Op;
+
+        LengthOp->Asl.Next = DataOp;
+
+        DbgPrint (ASL_PARSE_OUTPUT,
+            "Constant expression reduced to (BUFFER) length %X\n\n",
+            ObjDesc->Buffer.Length);
+        break;
+
+    default:
+        break;
+    }
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    OpcUpdateIntegerNode
+ *
+ * PARAMETERS:  Op                  - Current parse object
+ *              Value               - Value for the integer op
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Update node to the correct Integer type and value
+ *
+ ******************************************************************************/
+
+static void
+OpcUpdateIntegerNode (
+    ACPI_PARSE_OBJECT       *Op,
+    UINT64                  Value)
+{
+
+    Op->Common.Value.Integer = Value;
+
+    /*
+     * The AmlLength is used by the parser to indicate a constant,
+     * (if non-zero). Length is either (1/2/4/8)
+     */
+    switch (Op->Asl.AmlLength)
+    {
+    case 1:
+
+        TrUpdateNode (PARSEOP_BYTECONST, Op);
+        Op->Asl.AmlOpcode = AML_RAW_DATA_BYTE;
+        break;
+
+    case 2:
+
+        TrUpdateNode (PARSEOP_WORDCONST, Op);
+        Op->Asl.AmlOpcode = AML_RAW_DATA_WORD;
+        break;
+
+    case 4:
+
+        TrUpdateNode (PARSEOP_DWORDCONST, Op);
+        Op->Asl.AmlOpcode = AML_RAW_DATA_DWORD;
+        break;
+
+    case 8:
+
+        TrUpdateNode (PARSEOP_QWORDCONST, Op);
+        Op->Asl.AmlOpcode = AML_RAW_DATA_QWORD;
+        break;
+
+    case 0:
+    default:
+
+        OpcSetOptimalIntegerSize (Op);
+        TrUpdateNode (PARSEOP_INTEGER, Op);
+        break;
+    }
+
+    Op->Asl.AmlLength = 0;
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    OpcAmlEvaluationWalk1
+ *
+ * PARAMETERS:  ASL_WALK_CALLBACK
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Descending callback for AML execution of constant subtrees
+ *
+ ******************************************************************************/
+
+static ACPI_STATUS
+OpcAmlEvaluationWalk1 (
+    ACPI_PARSE_OBJECT       *Op,
+    UINT32                  Level,
+    void                    *Context)
+{
+    ACPI_WALK_STATE         *WalkState = Context;
+    ACPI_STATUS             Status;
+    ACPI_PARSE_OBJECT       *OutOp;
+
+
+    WalkState->Op = Op;
+    WalkState->Opcode = Op->Common.AmlOpcode;
+    WalkState->OpInfo = AcpiPsGetOpcodeInfo (Op->Common.AmlOpcode);
+
+    /* Copy child pointer to Arg for compatibility with Interpreter */
+
+    if (Op->Asl.Child)
+    {
+        Op->Common.Value.Arg = Op->Asl.Child;
+    }
+
+    /* Call AML dispatcher */
+
+    Status = AcpiDsExecBeginOp (WalkState, &OutOp);
+    if (ACPI_FAILURE (Status))
+    {
+        DbgPrint (ASL_PARSE_OUTPUT,
+            "%s Constant interpretation failed (1) - %s\n",
+            Op->Asl.ParseOpName, AcpiFormatException (Status));
+    }
+
+    return (Status);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    OpcAmlEvaluationWalk2
+ *
+ * PARAMETERS:  ASL_WALK_CALLBACK
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Ascending callback for AML execution of constant subtrees
+ *
+ ******************************************************************************/
+
+static ACPI_STATUS
+OpcAmlEvaluationWalk2 (
+    ACPI_PARSE_OBJECT       *Op,
+    UINT32                  Level,
+    void                    *Context)
+{
+    ACPI_WALK_STATE         *WalkState = Context;
+    ACPI_STATUS             Status;
+
+
+    WalkState->Op = Op;
+    WalkState->Opcode = Op->Common.AmlOpcode;
+    WalkState->OpInfo = AcpiPsGetOpcodeInfo (Op->Common.AmlOpcode);
+
+    /* Copy child pointer to Arg for compatibility with Interpreter */
+
+    if (Op->Asl.Child)
+    {
+        Op->Common.Value.Arg = Op->Asl.Child;
+    }
+
+    /* Call AML dispatcher */
+
+    Status = AcpiDsExecEndOp (WalkState);
+    if (ACPI_FAILURE (Status))
+    {
+        DbgPrint (ASL_PARSE_OUTPUT,
+            "%s: Constant interpretation failed (2) - %s\n",
+            Op->Asl.ParseOpName, AcpiFormatException (Status));
+    }
+
+    return (Status);
+}
diff --git a/usr/src/cmd/acpi/iasl/aslglobal.h b/usr/src/cmd/acpi/iasl/aslglobal.h
new file mode 100644
index 0000000000..6f35c248ec
--- /dev/null
+++ b/usr/src/cmd/acpi/iasl/aslglobal.h
@@ -0,0 +1,290 @@
+/******************************************************************************
+ *
+ * Module Name: aslglobal.h - Global variable definitions
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2016, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#ifndef __ASLGLOBAL_H
+#define __ASLGLOBAL_H
+
+
+/*
+ * Global variables. Defined in aslmain.c only, externed in all other files
+ */
+
+#undef ASL_EXTERN
+
+#ifdef _DECLARE_GLOBALS
+#define ASL_EXTERN
+#define ASL_INIT_GLOBAL(a,b)        (a)=(b)
+#else
+#define ASL_EXTERN                  extern
+#define ASL_INIT_GLOBAL(a,b)        (a)
+#endif
+
+
+#ifdef _DECLARE_GLOBALS
+UINT32                              Gbl_ExceptionCount[ASL_NUM_REPORT_LEVELS] = {0,0,0,0,0,0};
+
+/* Table below must match ASL_FILE_TYPES in asltypes.h */
+
+ASL_FILE_INFO                       Gbl_Files [ASL_NUM_FILES] =
+{
+    {NULL, NULL, "stdout:       ", "Standard Output"},
+    {NULL, NULL, "stderr:       ", "Standard Error"},
+    {NULL, NULL, "Table Input:  ", "Source Input"},
+    {NULL, NULL, "Binary Output:", "AML Output"},
+    {NULL, NULL, "Source Output:", "Source Output"},
+    {NULL, NULL, "Preprocessor: ", "Preprocessor Output"},
+    {NULL, NULL, "Preprocessor: ", "Preprocessor Temp File"},
+    {NULL, NULL, "Listing File: ", "Listing Output"},
+    {NULL, NULL, "Hex Dump:     ", "Hex Table Output"},
+    {NULL, NULL, "Namespace:    ", "Namespace Output"},
+    {NULL, NULL, "Debug File:   ", "Debug Output"},
+    {NULL, NULL, "ASM Source:   ", "Assembly Code Output"},
+    {NULL, NULL, "C Source:     ", "C Code Output"},
+    {NULL, NULL, "ASM Include:  ", "Assembly Header Output"},
+    {NULL, NULL, "C Include:    ", "C Header Output"},
+    {NULL, NULL, "Offset Table: ", "C Offset Table Output"},
+    {NULL, NULL, "Device Map:   ", "Device Map Output"},
+    {NULL, NULL, "Cross Ref:    ", "Cross-reference Output"}
+};
+
+#else
+extern UINT32                       Gbl_ExceptionCount[ASL_NUM_REPORT_LEVELS];
+extern ASL_FILE_INFO                Gbl_Files [ASL_NUM_FILES];
+#endif
+
+
+/*
+ * Parser and other externals
+ */
+extern int                          yydebug;
+extern FILE                         *AslCompilerin;
+extern int                          DtParserdebug;
+extern int                          PrParserdebug;
+extern const ASL_MAPPING_ENTRY      AslKeywordMapping[];
+extern char                         *AslCompilertext;
+
+/*
+ * Older versions of Bison won't emit this external in the generated header.
+ * Newer versions do emit the external, so we don't need to do it.
+ */
+#ifndef ASLCOMPILER_ASLCOMPILERPARSE_H
+extern int                  AslCompilerdebug;
+#endif
+
+
+#define ASL_DEFAULT_LINE_BUFFER_SIZE    (1024 * 32) /* 32K */
+#define ASL_MSG_BUFFER_SIZE             4096
+#define ASL_MAX_DISABLED_MESSAGES       32
+#define HEX_TABLE_LINE_SIZE             8
+#define HEX_LISTING_LINE_SIZE           8
+
+
+/* Source code buffers and pointers for error reporting */
+
+ASL_EXTERN char                     ASL_INIT_GLOBAL (*Gbl_CurrentLineBuffer, NULL);
+ASL_EXTERN char                     ASL_INIT_GLOBAL (*Gbl_LineBufPtr, NULL);
+ASL_EXTERN UINT32                   ASL_INIT_GLOBAL (Gbl_LineBufferSize, ASL_DEFAULT_LINE_BUFFER_SIZE);
+ASL_EXTERN UINT32                   ASL_INIT_GLOBAL (Gbl_CurrentColumn, 0);
+ASL_EXTERN UINT32                   ASL_INIT_GLOBAL (Gbl_CurrentLineNumber, 1);
+ASL_EXTERN UINT32                   ASL_INIT_GLOBAL (Gbl_LogicalLineNumber, 1);
+ASL_EXTERN UINT32                   ASL_INIT_GLOBAL (Gbl_CurrentLineOffset, 0);
+ASL_EXTERN UINT32                   ASL_INIT_GLOBAL (Gbl_OriginalInputFileSize, 0);
+ASL_EXTERN UINT8                    ASL_INIT_GLOBAL (Gbl_SyntaxError, 0);
+
+/* Exception reporting */
+
+ASL_EXTERN ASL_ERROR_MSG            ASL_INIT_GLOBAL (*Gbl_ErrorLog,NULL);
+ASL_EXTERN ASL_ERROR_MSG            ASL_INIT_GLOBAL (*Gbl_NextError,NULL);
+
+/* Option flags */
+
+ASL_EXTERN BOOLEAN                  ASL_INIT_GLOBAL (Gbl_DoCompile, TRUE);
+ASL_EXTERN BOOLEAN                  ASL_INIT_GLOBAL (Gbl_DoSignon, TRUE);
+ASL_EXTERN BOOLEAN                  ASL_INIT_GLOBAL (Gbl_PreprocessOnly, FALSE);
+ASL_EXTERN BOOLEAN                  ASL_INIT_GLOBAL (Gbl_PreprocessFlag, TRUE);
+ASL_EXTERN BOOLEAN                  ASL_INIT_GLOBAL (Gbl_DisassembleAll, FALSE);
+
+ASL_EXTERN BOOLEAN                  ASL_INIT_GLOBAL (Gbl_UseDefaultAmlFilename, TRUE);
+ASL_EXTERN BOOLEAN                  ASL_INIT_GLOBAL (Gbl_MapfileFlag, FALSE);
+ASL_EXTERN BOOLEAN                  ASL_INIT_GLOBAL (Gbl_NsOutputFlag, FALSE);
+ASL_EXTERN BOOLEAN                  ASL_INIT_GLOBAL (Gbl_PreprocessorOutputFlag, FALSE);
+ASL_EXTERN BOOLEAN                  ASL_INIT_GLOBAL (Gbl_KeepPreprocessorTempFile, FALSE);
+ASL_EXTERN BOOLEAN                  ASL_INIT_GLOBAL (Gbl_DebugFlag, FALSE);
+ASL_EXTERN BOOLEAN                  ASL_INIT_GLOBAL (Gbl_CrossReferenceOutput, FALSE);
+ASL_EXTERN BOOLEAN                  ASL_INIT_GLOBAL (Gbl_AsmOutputFlag, FALSE);
+ASL_EXTERN BOOLEAN                  ASL_INIT_GLOBAL (Gbl_C_OutputFlag, FALSE);
+ASL_EXTERN BOOLEAN                  ASL_INIT_GLOBAL (Gbl_C_OffsetTableFlag, FALSE);
+ASL_EXTERN BOOLEAN                  ASL_INIT_GLOBAL (Gbl_AsmIncludeOutputFlag, FALSE);
+ASL_EXTERN BOOLEAN                  ASL_INIT_GLOBAL (Gbl_C_IncludeOutputFlag, FALSE);
+ASL_EXTERN BOOLEAN                  ASL_INIT_GLOBAL (Gbl_ListingFlag, FALSE);
+ASL_EXTERN BOOLEAN                  ASL_INIT_GLOBAL (Gbl_IgnoreErrors, FALSE);
+ASL_EXTERN BOOLEAN                  ASL_INIT_GLOBAL (Gbl_SourceOutputFlag, FALSE);
+ASL_EXTERN BOOLEAN                  ASL_INIT_GLOBAL (Gbl_ParseOnlyFlag, FALSE);
+ASL_EXTERN BOOLEAN                  ASL_INIT_GLOBAL (Gbl_CompileTimesFlag, FALSE);
+ASL_EXTERN BOOLEAN                  ASL_INIT_GLOBAL (Gbl_FoldConstants, TRUE);
+ASL_EXTERN BOOLEAN                  ASL_INIT_GLOBAL (Gbl_VerboseErrors, TRUE);
+ASL_EXTERN BOOLEAN                  ASL_INIT_GLOBAL (Gbl_NoErrors, FALSE);
+ASL_EXTERN BOOLEAN                  ASL_INIT_GLOBAL (Gbl_WarningsAsErrors, FALSE);
+ASL_EXTERN BOOLEAN                  ASL_INIT_GLOBAL (Gbl_NoResourceChecking, FALSE);
+ASL_EXTERN BOOLEAN                  ASL_INIT_GLOBAL (Gbl_DisasmFlag, FALSE);
+ASL_EXTERN BOOLEAN                  ASL_INIT_GLOBAL (Gbl_IntegerOptimizationFlag, TRUE);
+ASL_EXTERN BOOLEAN                  ASL_INIT_GLOBAL (Gbl_ReferenceOptimizationFlag, TRUE);
+ASL_EXTERN BOOLEAN                  ASL_INIT_GLOBAL (Gbl_DisplayRemarks, TRUE);
+ASL_EXTERN BOOLEAN                  ASL_INIT_GLOBAL (Gbl_DisplayWarnings, TRUE);
+ASL_EXTERN BOOLEAN                  ASL_INIT_GLOBAL (Gbl_DisplayOptimizations, FALSE);
+ASL_EXTERN UINT8                    ASL_INIT_GLOBAL (Gbl_WarningLevel, ASL_WARNING);
+ASL_EXTERN BOOLEAN                  ASL_INIT_GLOBAL (Gbl_UseOriginalCompilerId, FALSE);
+ASL_EXTERN BOOLEAN                  ASL_INIT_GLOBAL (Gbl_VerboseTemplates, FALSE);
+ASL_EXTERN BOOLEAN                  ASL_INIT_GLOBAL (Gbl_DoTemplates, FALSE);
+ASL_EXTERN BOOLEAN                  ASL_INIT_GLOBAL (Gbl_CompileGeneric, FALSE);
+ASL_EXTERN BOOLEAN                  ASL_INIT_GLOBAL (Gbl_AllExceptionsDisabled, FALSE);
+ASL_EXTERN BOOLEAN                  ASL_INIT_GLOBAL (Gbl_PruneParseTree, FALSE);
+ASL_EXTERN BOOLEAN                  ASL_INIT_GLOBAL (Gbl_DoTypechecking, TRUE);
+ASL_EXTERN BOOLEAN                  ASL_INIT_GLOBAL (Gbl_EnableReferenceTypechecking, FALSE);
+ASL_EXTERN BOOLEAN                  ASL_INIT_GLOBAL (Gbl_DoExternals, TRUE);
+
+
+#define HEX_OUTPUT_NONE             0
+#define HEX_OUTPUT_C                1
+#define HEX_OUTPUT_ASM              2
+#define HEX_OUTPUT_ASL              3
+
+ASL_EXTERN BOOLEAN                  ASL_INIT_GLOBAL (Gbl_HexOutputFlag, HEX_OUTPUT_NONE);
+
+
+/* Files */
+
+ASL_EXTERN char                     *Gbl_DirectoryPath;
+ASL_EXTERN char                     ASL_INIT_GLOBAL (*Gbl_IncludeFilename, NULL);
+ASL_EXTERN char                     ASL_INIT_GLOBAL (*Gbl_OutputFilenamePrefix, NULL);
+ASL_EXTERN ASL_INCLUDE_DIR          ASL_INIT_GLOBAL (*Gbl_IncludeDirList, NULL);
+ASL_EXTERN char                     *Gbl_CurrentInputFilename;
+ASL_EXTERN char                     ASL_INIT_GLOBAL (*Gbl_ExternalRefFilename, NULL);
+ASL_EXTERN char                     ASL_INIT_GLOBAL (*Gbl_PreviousIncludeFilename, NULL);
+
+ASL_EXTERN BOOLEAN                  ASL_INIT_GLOBAL (Gbl_HasIncludeFiles, FALSE);
+
+
+/* Statistics */
+
+ASL_EXTERN UINT32                   ASL_INIT_GLOBAL (Gbl_InputByteCount, 0);
+ASL_EXTERN UINT32                   ASL_INIT_GLOBAL (Gbl_InputFieldCount, 0);
+ASL_EXTERN UINT32                   ASL_INIT_GLOBAL (Gbl_NsLookupCount, 0);
+ASL_EXTERN UINT32                   ASL_INIT_GLOBAL (TotalKeywords, 0);
+ASL_EXTERN UINT32                   ASL_INIT_GLOBAL (TotalNamedObjects, 0);
+ASL_EXTERN UINT32                   ASL_INIT_GLOBAL (TotalExecutableOpcodes, 0);
+ASL_EXTERN UINT32                   ASL_INIT_GLOBAL (TotalParseNodes, 0);
+ASL_EXTERN UINT32                   ASL_INIT_GLOBAL (TotalMethods, 0);
+ASL_EXTERN UINT32                   ASL_INIT_GLOBAL (TotalAllocations, 0);
+ASL_EXTERN UINT32                   ASL_INIT_GLOBAL (TotalAllocated, 0);
+ASL_EXTERN UINT32                   ASL_INIT_GLOBAL (TotalFolds, 0);
+
+
+/* Local caches */
+
+ASL_EXTERN UINT32                   ASL_INIT_GLOBAL (Gbl_ParseOpCount, 0);
+ASL_EXTERN ASL_CACHE_INFO           ASL_INIT_GLOBAL (*Gbl_ParseOpCacheList, NULL);
+ASL_EXTERN ACPI_PARSE_OBJECT        ASL_INIT_GLOBAL (*Gbl_ParseOpCacheNext, NULL);
+ASL_EXTERN ACPI_PARSE_OBJECT        ASL_INIT_GLOBAL (*Gbl_ParseOpCacheLast, NULL);
+
+ASL_EXTERN UINT32                   ASL_INIT_GLOBAL (Gbl_StringCount, 0);
+ASL_EXTERN UINT32                   ASL_INIT_GLOBAL (Gbl_StringSize, 0);
+ASL_EXTERN ASL_CACHE_INFO           ASL_INIT_GLOBAL (*Gbl_StringCacheList, NULL);
+ASL_EXTERN char                     ASL_INIT_GLOBAL (*Gbl_StringCacheNext, NULL);
+ASL_EXTERN char                     ASL_INIT_GLOBAL (*Gbl_StringCacheLast, NULL);
+
+/* Map file */
+
+ASL_EXTERN ACPI_GPIO_INFO           ASL_INIT_GLOBAL (*Gbl_GpioList, NULL);
+ASL_EXTERN ACPI_SERIAL_INFO         ASL_INIT_GLOBAL (*Gbl_SerialList, NULL);
+
+
+/* Misc */
+
+ASL_EXTERN UINT8                    ASL_INIT_GLOBAL (Gbl_RevisionOverride, 0);
+ASL_EXTERN UINT8                    ASL_INIT_GLOBAL (Gbl_TempCount, 0);
+ASL_EXTERN ACPI_PARSE_OBJECT        ASL_INIT_GLOBAL (*Gbl_ParseTreeRoot, NULL);
+ASL_EXTERN ACPI_PARSE_OBJECT        ASL_INIT_GLOBAL (*Gbl_ExternalsListHead, NULL);
+ASL_EXTERN UINT32                   ASL_INIT_GLOBAL (Gbl_TableLength, 0);
+ASL_EXTERN UINT32                   ASL_INIT_GLOBAL (Gbl_SourceLine, 0);
+ASL_EXTERN ASL_LISTING_NODE         ASL_INIT_GLOBAL (*Gbl_ListingNode, NULL);
+ASL_EXTERN UINT8                    ASL_INIT_GLOBAL (Gbl_FileType, 0);
+ASL_EXTERN char                     ASL_INIT_GLOBAL (*Gbl_Signature, NULL);
+
+ASL_EXTERN ACPI_PARSE_OBJECT        *Gbl_FirstLevelInsertionNode;
+
+ASL_EXTERN UINT32                   ASL_INIT_GLOBAL (Gbl_CurrentHexColumn, 0);
+ASL_EXTERN UINT32                   ASL_INIT_GLOBAL (Gbl_CurrentAmlOffset, 0);
+ASL_EXTERN UINT32                   ASL_INIT_GLOBAL (Gbl_CurrentLine, 0);
+ASL_EXTERN UINT32                   ASL_INIT_GLOBAL (Gbl_DisabledMessagesIndex, 0);
+ASL_EXTERN UINT8                    ASL_INIT_GLOBAL (Gbl_HexBytesWereWritten, FALSE);
+ASL_EXTERN UINT32                   ASL_INIT_GLOBAL (Gbl_NumNamespaceObjects, 0);
+ASL_EXTERN UINT32                   ASL_INIT_GLOBAL (Gbl_ReservedMethods, 0);
+ASL_EXTERN char                     ASL_INIT_GLOBAL (*Gbl_TableSignature, "NO_SIG");
+ASL_EXTERN char                     ASL_INIT_GLOBAL (*Gbl_TableId, "NO_ID");
+ASL_EXTERN UINT8                    ASL_INIT_GLOBAL (Gbl_PruneDepth, 0);
+ASL_EXTERN UINT16                   ASL_INIT_GLOBAL (Gbl_PruneType, 0);
+
+
+/* Static structures */
+
+ASL_EXTERN ASL_ANALYSIS_WALK_INFO   AnalysisWalkInfo;
+ASL_EXTERN ACPI_TABLE_HEADER        TableHeader;
+
+/* Event timing */
+
+#define ASL_NUM_EVENTS              24
+ASL_EXTERN ASL_EVENT_INFO           AslGbl_Events[ASL_NUM_EVENTS];
+ASL_EXTERN UINT8                    AslGbl_NextEvent;
+ASL_EXTERN UINT8                    AslGbl_NamespaceEvent;
+
+/* Scratch buffers */
+
+ASL_EXTERN UINT8                    Gbl_AmlBuffer[HEX_LISTING_LINE_SIZE];
+ASL_EXTERN char                     MsgBuffer[ASL_MSG_BUFFER_SIZE];
+ASL_EXTERN char                     StringBuffer[ASL_MSG_BUFFER_SIZE];
+ASL_EXTERN char                     StringBuffer2[ASL_MSG_BUFFER_SIZE];
+ASL_EXTERN UINT32                   Gbl_DisabledMessages[ASL_MAX_DISABLED_MESSAGES];
+
+
+#endif /* __ASLGLOBAL_H */
diff --git a/usr/src/cmd/acpi/iasl/aslhex.c b/usr/src/cmd/acpi/iasl/aslhex.c
new file mode 100644
index 0000000000..afa395e97e
--- /dev/null
+++ b/usr/src/cmd/acpi/iasl/aslhex.c
@@ -0,0 +1,404 @@
+/******************************************************************************
+ *
+ * Module Name: aslhex - ASCII hex output file generation (C, ASM, and ASL)
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2016, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include "aslcompiler.h"
+
+#define _COMPONENT          ACPI_COMPILER
+        ACPI_MODULE_NAME    ("ashex")
+
+/*
+ * This module emits ASCII hex output files in either C, ASM, or ASL format
+ */
+
+/* Local prototypes */
+
+static void
+HxDoHexOutputC (
+    void);
+
+static void
+HxDoHexOutputAsl (
+    void);
+
+static void
+HxDoHexOutputAsm (
+    void);
+
+static UINT32
+HxReadAmlOutputFile (
+    UINT8                   *Buffer);
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    HxDoHexOutput
+ *
+ * PARAMETERS:  None
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Create the hex output file. Note: data is obtained by reading
+ *              the entire AML output file that was previously generated.
+ *
+ ******************************************************************************/
+
+void
+HxDoHexOutput (
+    void)
+{
+
+    switch (Gbl_HexOutputFlag)
+    {
+    case HEX_OUTPUT_C:
+
+        HxDoHexOutputC ();
+        break;
+
+    case HEX_OUTPUT_ASM:
+
+        HxDoHexOutputAsm ();
+        break;
+
+    case HEX_OUTPUT_ASL:
+
+        HxDoHexOutputAsl ();
+        break;
+
+    default:
+
+        /* No other output types supported */
+
+        break;
+    }
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    HxReadAmlOutputFile
+ *
+ * PARAMETERS:  Buffer              - Where to return data
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Read a line of the AML output prior to formatting the data
+ *
+ ******************************************************************************/
+
+static UINT32
+HxReadAmlOutputFile (
+    UINT8                   *Buffer)
+{
+    UINT32                  Actual;
+
+
+    Actual = fread (Buffer, 1, HEX_TABLE_LINE_SIZE,
+        Gbl_Files[ASL_FILE_AML_OUTPUT].Handle);
+
+    if (ferror (Gbl_Files[ASL_FILE_AML_OUTPUT].Handle))
+    {
+        FlFileError (ASL_FILE_AML_OUTPUT, ASL_MSG_READ);
+        AslAbort ();
+    }
+
+    return (Actual);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    HxDoHexOutputC
+ *
+ * PARAMETERS:  None
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Create the hex output file. This is the same data as the AML
+ *              output file, but formatted into hex/ascii bytes suitable for
+ *              inclusion into a C source file.
+ *
+ ******************************************************************************/
+
+static void
+HxDoHexOutputC (
+    void)
+{
+    UINT8                   FileData[HEX_TABLE_LINE_SIZE];
+    UINT32                  LineLength;
+    UINT32                  Offset = 0;
+    UINT32                  AmlFileSize;
+    UINT32                  i;
+
+
+    /* Get AML size, seek back to start */
+
+    AmlFileSize = FlGetFileSize (ASL_FILE_AML_OUTPUT);
+    FlSeekFile (ASL_FILE_AML_OUTPUT, 0);
+
+    FlPrintFile (ASL_FILE_HEX_OUTPUT, " * C source code output\n");
+    FlPrintFile (ASL_FILE_HEX_OUTPUT, " * AML code block contains 0x%X bytes\n *\n */\n",
+        AmlFileSize);
+    FlPrintFile (ASL_FILE_HEX_OUTPUT, "unsigned char AmlCode[] =\n{\n");
+
+    while (Offset < AmlFileSize)
+    {
+        /* Read enough bytes needed for one output line */
+
+        LineLength = HxReadAmlOutputFile (FileData);
+        if (!LineLength)
+        {
+            break;
+        }
+
+        FlPrintFile (ASL_FILE_HEX_OUTPUT, "    ");
+
+        for (i = 0; i < LineLength; i++)
+        {
+            /*
+             * Print each hex byte.
+             * Add a comma until the very last byte of the AML file
+             * (Some C compilers complain about a trailing comma)
+             */
+            FlPrintFile (ASL_FILE_HEX_OUTPUT, "0x%2.2X", FileData[i]);
+            if ((Offset + i + 1) < AmlFileSize)
+            {
+                FlPrintFile (ASL_FILE_HEX_OUTPUT, ",");
+            }
+            else
+            {
+                FlPrintFile (ASL_FILE_HEX_OUTPUT, " ");
+            }
+        }
+
+        /* Add fill spaces if needed for last line */
+
+        if (LineLength < HEX_TABLE_LINE_SIZE)
+        {
+            FlPrintFile (ASL_FILE_HEX_OUTPUT, "%*s",
+                5 * (HEX_TABLE_LINE_SIZE - LineLength), " ");
+        }
+
+        /* Emit the offset and ascii dump for the entire line */
+
+        FlPrintFile (ASL_FILE_HEX_OUTPUT, "  /* %8.8X", Offset);
+        LsDumpAsciiInComment (ASL_FILE_HEX_OUTPUT, LineLength, FileData);
+
+        FlPrintFile (ASL_FILE_HEX_OUTPUT, "%*s*/\n",
+            HEX_TABLE_LINE_SIZE - LineLength + 1, " ");
+
+        Offset += LineLength;
+    }
+
+    FlPrintFile (ASL_FILE_HEX_OUTPUT, "};\n");
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    HxDoHexOutputAsl
+ *
+ * PARAMETERS:  None
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Create the hex output file. This is the same data as the AML
+ *              output file, but formatted into hex/ascii bytes suitable for
+ *              inclusion into a C source file.
+ *
+ ******************************************************************************/
+
+static void
+HxDoHexOutputAsl (
+    void)
+{
+    UINT8                   FileData[HEX_TABLE_LINE_SIZE];
+    UINT32                  LineLength;
+    UINT32                  Offset = 0;
+    UINT32                  AmlFileSize;
+    UINT32                  i;
+
+
+    /* Get AML size, seek back to start */
+
+    AmlFileSize = FlGetFileSize (ASL_FILE_AML_OUTPUT);
+    FlSeekFile (ASL_FILE_AML_OUTPUT, 0);
+
+    FlPrintFile (ASL_FILE_HEX_OUTPUT, " * ASL source code output\n");
+    FlPrintFile (ASL_FILE_HEX_OUTPUT, " * AML code block contains 0x%X bytes\n *\n */\n",
+        AmlFileSize);
+    FlPrintFile (ASL_FILE_HEX_OUTPUT, "    Name (BUF1, Buffer()\n    {\n");
+
+    while (Offset < AmlFileSize)
+    {
+        /* Read enough bytes needed for one output line */
+
+        LineLength = HxReadAmlOutputFile (FileData);
+        if (!LineLength)
+        {
+            break;
+        }
+
+        FlPrintFile (ASL_FILE_HEX_OUTPUT, "        ");
+
+        for (i = 0; i < LineLength; i++)
+        {
+            /*
+             * Print each hex byte.
+             * Add a comma until the very last byte of the AML file
+             * (Some C compilers complain about a trailing comma)
+             */
+            FlPrintFile (ASL_FILE_HEX_OUTPUT, "0x%2.2X", FileData[i]);
+            if ((Offset + i + 1) < AmlFileSize)
+            {
+                FlPrintFile (ASL_FILE_HEX_OUTPUT, ",");
+            }
+            else
+            {
+                FlPrintFile (ASL_FILE_HEX_OUTPUT, " ");
+            }
+        }
+
+        /* Add fill spaces if needed for last line */
+
+        if (LineLength < HEX_TABLE_LINE_SIZE)
+        {
+            FlPrintFile (ASL_FILE_HEX_OUTPUT, "%*s",
+                5 * (HEX_TABLE_LINE_SIZE - LineLength), " ");
+        }
+
+        /* Emit the offset and ascii dump for the entire line */
+
+        FlPrintFile (ASL_FILE_HEX_OUTPUT, "  /* %8.8X", Offset);
+        LsDumpAsciiInComment (ASL_FILE_HEX_OUTPUT, LineLength, FileData);
+
+        FlPrintFile (ASL_FILE_HEX_OUTPUT, "%*s*/\n",
+            HEX_TABLE_LINE_SIZE - LineLength + 1, " ");
+
+        Offset += LineLength;
+    }
+
+    FlPrintFile (ASL_FILE_HEX_OUTPUT, "    })\n");
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    HxDoHexOutputAsm
+ *
+ * PARAMETERS:  None
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Create the hex output file. This is the same data as the AML
+ *              output file, but formatted into hex/ascii bytes suitable for
+ *              inclusion into a ASM source file.
+ *
+ ******************************************************************************/
+
+static void
+HxDoHexOutputAsm (
+    void)
+{
+    UINT8                   FileData[HEX_TABLE_LINE_SIZE];
+    UINT32                  LineLength;
+    UINT32                  Offset = 0;
+    UINT32                  AmlFileSize;
+    UINT32                  i;
+
+
+    /* Get AML size, seek back to start */
+
+    AmlFileSize = FlGetFileSize (ASL_FILE_AML_OUTPUT);
+    FlSeekFile (ASL_FILE_AML_OUTPUT, 0);
+
+    FlPrintFile (ASL_FILE_HEX_OUTPUT, "; Assembly code source output\n");
+    FlPrintFile (ASL_FILE_HEX_OUTPUT, "; AML code block contains 0x%X bytes\n;\n",
+        AmlFileSize);
+
+    while (Offset < AmlFileSize)
+    {
+        /* Read enough bytes needed for one output line */
+
+        LineLength = HxReadAmlOutputFile (FileData);
+        if (!LineLength)
+        {
+            break;
+        }
+
+        FlPrintFile (ASL_FILE_HEX_OUTPUT, "  db  ");
+
+        for (i = 0; i < LineLength; i++)
+        {
+            /*
+             * Print each hex byte.
+             * Add a comma until the last byte of the line
+             */
+            FlPrintFile (ASL_FILE_HEX_OUTPUT, "0%2.2Xh", FileData[i]);
+            if ((i + 1) < LineLength)
+            {
+                FlPrintFile (ASL_FILE_HEX_OUTPUT, ",");
+            }
+        }
+
+        FlPrintFile (ASL_FILE_HEX_OUTPUT, " ");
+
+        /* Add fill spaces if needed for last line */
+
+        if (LineLength < HEX_TABLE_LINE_SIZE)
+        {
+            FlPrintFile (ASL_FILE_HEX_OUTPUT, "%*s",
+                5 * (HEX_TABLE_LINE_SIZE - LineLength), " ");
+        }
+
+        /* Emit the offset and ascii dump for the entire line */
+
+        FlPrintFile (ASL_FILE_HEX_OUTPUT, "  ; %8.8X", Offset);
+        LsDumpAsciiInComment (ASL_FILE_HEX_OUTPUT, LineLength, FileData);
+
+        FlPrintFile (ASL_FILE_HEX_OUTPUT, "\n");
+
+        Offset += LineLength;
+    }
+
+    FlPrintFile (ASL_FILE_HEX_OUTPUT, "\n");
+}
diff --git a/usr/src/cmd/acpi/iasl/asllength.c b/usr/src/cmd/acpi/iasl/asllength.c
new file mode 100644
index 0000000000..626c2e7f3e
--- /dev/null
+++ b/usr/src/cmd/acpi/iasl/asllength.c
@@ -0,0 +1,462 @@
+/******************************************************************************
+ *
+ * Module Name: asllength - Tree walk to determine package and opcode lengths
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2016, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include "aslcompiler.h"
+#include "aslcompiler.y.h"
+#include "amlcode.h"
+
+
+#define _COMPONENT          ACPI_COMPILER
+        ACPI_MODULE_NAME    ("asllength")
+
+/* Local prototypes */
+
+static UINT8
+CgGetPackageLenByteCount (
+    ACPI_PARSE_OBJECT       *Op,
+    UINT32                  PackageLength);
+
+static void
+CgGenerateAmlOpcodeLength (
+    ACPI_PARSE_OBJECT       *Op);
+
+
+#ifdef ACPI_OBSOLETE_FUNCTIONS
+void
+LnAdjustLengthToRoot (
+    ACPI_PARSE_OBJECT       *Op,
+    UINT32                  LengthDelta);
+#endif
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    LnInitLengthsWalk
+ *
+ * PARAMETERS:  ASL_WALK_CALLBACK
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Walk callback to initialize (and re-initialize) the node
+ *              subtree length(s) to zero. The Subtree lengths are bubbled
+ *              up to the root node in order to get a total AML length.
+ *
+ ******************************************************************************/
+
+ACPI_STATUS
+LnInitLengthsWalk (
+    ACPI_PARSE_OBJECT       *Op,
+    UINT32                  Level,
+    void                    *Context)
+{
+
+    Op->Asl.AmlSubtreeLength = 0;
+    return (AE_OK);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    LnPackageLengthWalk
+ *
+ * PARAMETERS:  ASL_WALK_CALLBACK
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Walk callback to calculate the total AML length.
+ *              1) Calculate the AML lengths (opcode, package length, etc.) for
+ *                 THIS node.
+ *              2) Bubbble up all of these lengths to the parent node by summing
+ *                 them all into the parent subtree length.
+ *
+ * Note:  The SubtreeLength represents the total AML length of all child nodes
+ *        in all subtrees under a given node. Therefore, once this walk is
+ *        complete, the Root Node subtree length is the AML length of the entire
+ *        tree (and thus, the entire ACPI table)
+ *
+ ******************************************************************************/
+
+ACPI_STATUS
+LnPackageLengthWalk (
+    ACPI_PARSE_OBJECT       *Op,
+    UINT32                  Level,
+    void                    *Context)
+{
+
+    /* Generate the AML lengths for this node */
+
+    CgGenerateAmlLengths (Op);
+
+    /* Bubble up all lengths (this node and all below it) to the parent */
+
+    if ((Op->Asl.Parent) &&
+        (Op->Asl.ParseOpcode != PARSEOP_DEFAULT_ARG))
+    {
+        Op->Asl.Parent->Asl.AmlSubtreeLength += (
+            Op->Asl.AmlLength +
+            Op->Asl.AmlOpcodeLength +
+            Op->Asl.AmlPkgLenBytes +
+            Op->Asl.AmlSubtreeLength);
+    }
+    return (AE_OK);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    CgGetPackageLenByteCount
+ *
+ * PARAMETERS:  Op              - Parse node
+ *              PackageLength   - Length to be encoded
+ *
+ * RETURN:      Required length of the package length encoding
+ *
+ * DESCRIPTION: Calculate the number of bytes required to encode the given
+ *              package length.
+ *
+ ******************************************************************************/
+
+static UINT8
+CgGetPackageLenByteCount (
+    ACPI_PARSE_OBJECT       *Op,
+    UINT32                  PackageLength)
+{
+
+    /*
+     * Determine the number of bytes required to encode the package length
+     * Note: the package length includes the number of bytes used to encode
+     * the package length, so we must account for this also.
+     */
+    if (PackageLength <= (0x0000003F - 1))
+    {
+        return (1);
+    }
+    else if (PackageLength <= (0x00000FFF - 2))
+    {
+        return (2);
+    }
+    else if (PackageLength <= (0x000FFFFF - 3))
+    {
+        return (3);
+    }
+    else if (PackageLength <= (0x0FFFFFFF - 4))
+    {
+        return (4);
+    }
+    else
+    {
+        /* Fatal error - the package length is too large to encode */
+
+        AslError (ASL_ERROR, ASL_MSG_ENCODING_LENGTH, Op, NULL);
+    }
+
+    return (0);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    CgGenerateAmlOpcodeLength
+ *
+ * PARAMETERS:  Op          - Parse node whose AML opcode lengths will be
+ *                            calculated
+ *
+ * RETURN:      None.
+ *
+ * DESCRIPTION: Calculate the AmlOpcodeLength, AmlPkgLenBytes, and AmlLength
+ *              fields for this node.
+ *
+ ******************************************************************************/
+
+static void
+CgGenerateAmlOpcodeLength (
+    ACPI_PARSE_OBJECT       *Op)
+{
+
+    /* Check for two-byte opcode */
+
+    if (Op->Asl.AmlOpcode > 0x00FF)
+    {
+        Op->Asl.AmlOpcodeLength = 2;
+    }
+    else
+    {
+        Op->Asl.AmlOpcodeLength = 1;
+    }
+
+    /* Does this opcode have an associated "PackageLength" field? */
+
+    Op->Asl.AmlPkgLenBytes = 0;
+    if (Op->Asl.CompileFlags & NODE_AML_PACKAGE)
+    {
+        Op->Asl.AmlPkgLenBytes = CgGetPackageLenByteCount (
+            Op, Op->Asl.AmlSubtreeLength);
+    }
+
+    /* Data opcode lengths are easy */
+
+    switch (Op->Asl.AmlOpcode)
+    {
+    case AML_BYTE_OP:
+
+        Op->Asl.AmlLength = 1;
+        break;
+
+    case AML_WORD_OP:
+
+        Op->Asl.AmlLength = 2;
+        break;
+
+    case AML_DWORD_OP:
+
+        Op->Asl.AmlLength = 4;
+        break;
+
+    case AML_QWORD_OP:
+
+        Op->Asl.AmlLength = 8;
+        break;
+
+    default:
+
+        /* All data opcodes must be above */
+        break;
+    }
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    CgGenerateAmlLengths
+ *
+ * PARAMETERS:  Op        - Parse node
+ *
+ * RETURN:      None.
+ *
+ * DESCRIPTION: Generate internal length fields based on the AML opcode or
+ *              parse opcode.
+ *
+ ******************************************************************************/
+
+void
+CgGenerateAmlLengths (
+    ACPI_PARSE_OBJECT       *Op)
+{
+    char                    *Buffer;
+    ACPI_STATUS             Status;
+
+
+    switch (Op->Asl.AmlOpcode)
+    {
+    case AML_RAW_DATA_BYTE:
+
+        Op->Asl.AmlOpcodeLength = 0;
+        Op->Asl.AmlLength = 1;
+        return;
+
+    case AML_RAW_DATA_WORD:
+
+        Op->Asl.AmlOpcodeLength = 0;
+        Op->Asl.AmlLength = 2;
+        return;
+
+    case AML_RAW_DATA_DWORD:
+
+        Op->Asl.AmlOpcodeLength = 0;
+        Op->Asl.AmlLength = 4;
+        return;
+
+    case AML_RAW_DATA_QWORD:
+
+        Op->Asl.AmlOpcodeLength = 0;
+        Op->Asl.AmlLength = 8;
+        return;
+
+    case AML_RAW_DATA_BUFFER:
+
+        /* Aml length is/was set by creator */
+
+        Op->Asl.AmlOpcodeLength = 0;
+        return;
+
+    case AML_RAW_DATA_CHAIN:
+
+        /* Aml length is/was set by creator */
+
+        Op->Asl.AmlOpcodeLength = 0;
+        return;
+
+    default:
+
+        break;
+    }
+
+    switch (Op->Asl.ParseOpcode)
+    {
+    case PARSEOP_DEFINITION_BLOCK:
+
+        Gbl_TableLength = sizeof (ACPI_TABLE_HEADER) + Op->Asl.AmlSubtreeLength;
+        break;
+
+    case PARSEOP_NAMESEG:
+
+        Op->Asl.AmlOpcodeLength = 0;
+        Op->Asl.AmlLength = 4;
+        Op->Asl.ExternalName = Op->Asl.Value.String;
+        break;
+
+    case PARSEOP_NAMESTRING:
+    case PARSEOP_METHODCALL:
+
+        if (Op->Asl.CompileFlags & NODE_NAME_INTERNALIZED)
+        {
+            break;
+        }
+
+        Op->Asl.AmlOpcodeLength = 0;
+        Status = UtInternalizeName (Op->Asl.Value.String, &Buffer);
+        if (ACPI_FAILURE (Status))
+        {
+            DbgPrint (ASL_DEBUG_OUTPUT,
+                "Failure from internalize name %X\n", Status);
+            break;
+        }
+
+        Op->Asl.ExternalName = Op->Asl.Value.String;
+        Op->Asl.Value.String = Buffer;
+        Op->Asl.CompileFlags |= NODE_NAME_INTERNALIZED;
+        Op->Asl.AmlLength = strlen (Buffer);
+
+        /*
+         * Check for single backslash reference to root,
+         * make it a null terminated string in the AML
+         */
+        if (Op->Asl.AmlLength == 1)
+        {
+            Op->Asl.AmlLength = 2;
+        }
+        break;
+
+    case PARSEOP_STRING_LITERAL:
+
+        Op->Asl.AmlOpcodeLength = 1;
+
+        /* Get null terminator */
+
+        Op->Asl.AmlLength = strlen (Op->Asl.Value.String) + 1;
+        break;
+
+    case PARSEOP_PACKAGE_LENGTH:
+
+        Op->Asl.AmlOpcodeLength = 0;
+        Op->Asl.AmlPkgLenBytes = CgGetPackageLenByteCount (Op,
+            (UINT32) Op->Asl.Value.Integer);
+        break;
+
+    case PARSEOP_RAW_DATA:
+
+        Op->Asl.AmlOpcodeLength = 0;
+        break;
+
+    case PARSEOP_DEFAULT_ARG:
+    case PARSEOP_INCLUDE:
+    case PARSEOP_INCLUDE_END:
+
+        /* Ignore the "default arg" nodes, they are extraneous at this point */
+
+        break;
+
+    case PARSEOP_EXTERNAL:
+
+        if (Gbl_DoExternals == TRUE)
+        {
+            CgGenerateAmlOpcodeLength (Op);
+        }
+        break;
+
+    default:
+
+        CgGenerateAmlOpcodeLength (Op);
+        break;
+    }
+}
+
+
+#ifdef ACPI_OBSOLETE_FUNCTIONS
+/*******************************************************************************
+ *
+ * FUNCTION:    LnAdjustLengthToRoot
+ *
+ * PARAMETERS:  Op      - Node whose Length was changed
+ *
+ * RETURN:      None.
+ *
+ * DESCRIPTION: Change the Subtree length of the given node, and bubble the
+ *              change all the way up to the root node. This allows for
+ *              last second changes to a package length (for example, if the
+ *              package length encoding gets shorter or longer.)
+ *
+ ******************************************************************************/
+
+void
+LnAdjustLengthToRoot (
+    ACPI_PARSE_OBJECT       *SubtreeOp,
+    UINT32                  LengthDelta)
+{
+    ACPI_PARSE_OBJECT       *Op;
+
+
+    /* Adjust all subtree lengths up to the root */
+
+    Op = SubtreeOp->Asl.Parent;
+    while (Op)
+    {
+        Op->Asl.AmlSubtreeLength -= LengthDelta;
+        Op = Op->Asl.Parent;
+    }
+
+    /* Adjust the global table length */
+
+    Gbl_TableLength -= LengthDelta;
+}
+#endif
diff --git a/usr/src/cmd/acpi/iasl/asllisting.c b/usr/src/cmd/acpi/iasl/asllisting.c
new file mode 100644
index 0000000000..692d199e35
--- /dev/null
+++ b/usr/src/cmd/acpi/iasl/asllisting.c
@@ -0,0 +1,745 @@
+/******************************************************************************
+ *
+ * Module Name: asllisting - Listing file generation
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2016, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include "aslcompiler.h"
+#include "aslcompiler.y.h"
+#include "amlcode.h"
+#include "acparser.h"
+#include "acnamesp.h"
+
+
+#define _COMPONENT          ACPI_COMPILER
+        ACPI_MODULE_NAME    ("asllisting")
+
+
+/* Local prototypes */
+
+static void
+LsGenerateListing (
+    UINT32                  FileId);
+
+static ACPI_STATUS
+LsAmlListingWalk (
+    ACPI_PARSE_OBJECT       *Op,
+    UINT32                  Level,
+    void                    *Context);
+
+static ACPI_STATUS
+LsTreeWriteWalk (
+    ACPI_PARSE_OBJECT       *Op,
+    UINT32                  Level,
+    void                    *Context);
+
+static void
+LsWriteNodeToListing (
+    ACPI_PARSE_OBJECT       *Op,
+    UINT32                  FileId);
+
+static void
+LsFinishSourceListing (
+    UINT32                  FileId);
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    LsDoListings
+ *
+ * PARAMETERS:  None. Examines the various output file global flags.
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Generate all requested listing files.
+ *
+ ******************************************************************************/
+
+void
+LsDoListings (
+    void)
+{
+
+    if (Gbl_C_OutputFlag)
+    {
+        LsGenerateListing (ASL_FILE_C_SOURCE_OUTPUT);
+    }
+
+    if (Gbl_ListingFlag)
+    {
+        LsGenerateListing (ASL_FILE_LISTING_OUTPUT);
+    }
+
+    if (Gbl_AsmOutputFlag)
+    {
+        LsGenerateListing (ASL_FILE_ASM_SOURCE_OUTPUT);
+    }
+
+    if (Gbl_C_IncludeOutputFlag)
+    {
+        LsGenerateListing (ASL_FILE_C_INCLUDE_OUTPUT);
+    }
+
+    if (Gbl_AsmIncludeOutputFlag)
+    {
+        LsGenerateListing (ASL_FILE_ASM_INCLUDE_OUTPUT);
+    }
+
+    if (Gbl_C_OffsetTableFlag)
+    {
+        LsGenerateListing (ASL_FILE_C_OFFSET_OUTPUT);
+    }
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    LsGenerateListing
+ *
+ * PARAMETERS:  FileId      - ID of listing file
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Generate a listing file. This can be one of the several types
+ *              of "listings" supported.
+ *
+ ******************************************************************************/
+
+static void
+LsGenerateListing (
+    UINT32                  FileId)
+{
+
+    /* Start at the beginning of both the source and AML files */
+
+    FlSeekFile (ASL_FILE_SOURCE_OUTPUT, 0);
+    FlSeekFile (ASL_FILE_AML_OUTPUT, 0);
+    Gbl_SourceLine = 0;
+    Gbl_CurrentHexColumn = 0;
+    LsPushNode (Gbl_Files[ASL_FILE_INPUT].Filename);
+
+    if (FileId == ASL_FILE_C_OFFSET_OUTPUT)
+    {
+        Gbl_CurrentAmlOffset = 0;
+
+        /* Offset table file has a special header and footer */
+
+        LsDoOffsetTableHeader (FileId);
+
+        TrWalkParseTree (Gbl_ParseTreeRoot, ASL_WALK_VISIT_DOWNWARD,
+            LsAmlOffsetWalk, NULL, (void *) ACPI_TO_POINTER (FileId));
+        LsDoOffsetTableFooter (FileId);
+        return;
+    }
+
+    /* Process all parse nodes */
+
+    TrWalkParseTree (Gbl_ParseTreeRoot, ASL_WALK_VISIT_DOWNWARD,
+        LsAmlListingWalk, NULL, (void *) ACPI_TO_POINTER (FileId));
+
+    /* Final processing */
+
+    LsFinishSourceListing (FileId);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    LsAmlListingWalk
+ *
+ * PARAMETERS:  ASL_WALK_CALLBACK
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Process one node during a listing file generation.
+ *
+ ******************************************************************************/
+
+static ACPI_STATUS
+LsAmlListingWalk (
+    ACPI_PARSE_OBJECT       *Op,
+    UINT32                  Level,
+    void                    *Context)
+{
+    UINT8                   FileByte;
+    UINT32                  i;
+    UINT32                  FileId = (UINT32) ACPI_TO_INTEGER (Context);
+
+
+    LsWriteNodeToListing (Op, FileId);
+
+    if (Op->Asl.CompileFlags & NODE_IS_RESOURCE_DATA)
+    {
+        /* Buffer is a resource template, don't dump the data all at once */
+
+        return (AE_OK);
+    }
+
+    if ((FileId == ASL_FILE_ASM_INCLUDE_OUTPUT) ||
+        (FileId == ASL_FILE_C_INCLUDE_OUTPUT))
+    {
+        return (AE_OK);
+    }
+
+    /* Write the hex bytes to the listing file(s) (if requested) */
+
+    for (i = 0; i < Op->Asl.FinalAmlLength; i++)
+    {
+        if (ACPI_FAILURE (FlReadFile (ASL_FILE_AML_OUTPUT, &FileByte, 1)))
+        {
+            FlFileError (ASL_FILE_AML_OUTPUT, ASL_MSG_READ);
+            AslAbort ();
+        }
+
+        LsWriteListingHexBytes (&FileByte, 1, FileId);
+    }
+
+    return (AE_OK);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    LsDumpParseTree, LsTreeWriteWalk
+ *
+ * PARAMETERS:  None
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Dump entire parse tree, for compiler debug only
+ *
+ ******************************************************************************/
+
+void
+LsDumpParseTree (
+    void)
+{
+
+    if (!Gbl_DebugFlag)
+    {
+        return;
+    }
+
+    DbgPrint (ASL_TREE_OUTPUT, "\nOriginal parse tree from parser:\n\n");
+    DbgPrint (ASL_TREE_OUTPUT, ASL_PARSE_TREE_HEADER1);
+
+    TrWalkParseTree (Gbl_ParseTreeRoot, ASL_WALK_VISIT_DOWNWARD,
+        LsTreeWriteWalk, NULL, NULL);
+
+    DbgPrint (ASL_TREE_OUTPUT, ASL_PARSE_TREE_HEADER1);
+}
+
+
+static ACPI_STATUS
+LsTreeWriteWalk (
+    ACPI_PARSE_OBJECT       *Op,
+    UINT32                  Level,
+    void                    *Context)
+{
+
+    /* Dump ParseOp name and possible value */
+
+    switch (Op->Asl.ParseOpcode)
+    {
+        case PARSEOP_NAMESEG:
+        case PARSEOP_NAMESTRING:
+        case PARSEOP_METHODCALL:
+        case PARSEOP_STRING_LITERAL:
+
+        UtDumpStringOp (Op, Level);
+        break;
+
+    case PARSEOP_BYTECONST:
+
+        UtDumpIntegerOp (Op, Level, 2);
+        break;
+
+    case PARSEOP_WORDCONST:
+    case PARSEOP_PACKAGE_LENGTH:
+
+        UtDumpIntegerOp (Op, Level, 4);
+        break;
+
+    case PARSEOP_DWORDCONST:
+    case PARSEOP_EISAID:
+
+        UtDumpIntegerOp (Op, Level, 8);
+        break;
+
+    case PARSEOP_QWORDCONST:
+    case PARSEOP_INTEGER:
+    case PARSEOP_ONE:
+    case PARSEOP_ZERO:
+    case PARSEOP_ONES:
+
+        UtDumpIntegerOp (Op, Level, 16);
+        break;
+
+    case PARSEOP_INCLUDE:
+
+        DbgPrint (ASL_TREE_OUTPUT,
+            "Open: %s\n", Op->Asl.Value.String);
+        return (AE_OK);
+
+    case PARSEOP_INCLUDE_END:
+
+        DbgPrint (ASL_TREE_OUTPUT,
+            "Close: %s\n", Op->Asl.Filename);
+        return (AE_OK);
+
+    default:
+
+        UtDumpBasicOp (Op, Level);
+        break;
+    }
+
+    /* Dump the remaining data */
+
+    DbgPrint (ASL_TREE_OUTPUT, ASL_PARSE_TREE_DEBUG1,
+        Op->Asl.ParseOpcode, Op->Asl.CompileFlags,
+        Op->Asl.LineNumber, Op->Asl.EndLine,
+        Op->Asl.LogicalLineNumber, Op->Asl.EndLogicalLine);
+
+    TrPrintNodeCompileFlags (Op->Asl.CompileFlags);
+    DbgPrint (ASL_TREE_OUTPUT, "\n");
+    return (AE_OK);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    LsWriteNodeToListing
+ *
+ * PARAMETERS:  Op              - Parse node to write to the listing file.
+ *              FileId          - ID of current listing file
+ *
+ * RETURN:      None.
+ *
+ * DESCRIPTION: Write "a node" to the listing file. This means to
+ *              1) Write out all of the source text associated with the node
+ *              2) Write out all of the AML bytes associated with the node
+ *              3) Write any compiler exceptions associated with the node
+ *
+ ******************************************************************************/
+
+static void
+LsWriteNodeToListing (
+    ACPI_PARSE_OBJECT       *Op,
+    UINT32                  FileId)
+{
+    const ACPI_OPCODE_INFO  *OpInfo;
+    UINT32                  OpClass;
+    char                    *Pathname;
+    UINT32                  Length;
+    UINT32                  i;
+
+
+    OpInfo  = AcpiPsGetOpcodeInfo (Op->Asl.AmlOpcode);
+    OpClass = OpInfo->Class;
+
+    /* TBD: clean this up with a single flag that says:
+     * I start a named output block
+     */
+    if (FileId == ASL_FILE_C_SOURCE_OUTPUT)
+    {
+        switch (Op->Asl.ParseOpcode)
+        {
+        case PARSEOP_DEFINITION_BLOCK:
+        case PARSEOP_METHODCALL:
+        case PARSEOP_INCLUDE:
+        case PARSEOP_INCLUDE_END:
+        case PARSEOP_DEFAULT_ARG:
+
+            break;
+
+        default:
+
+            switch (OpClass)
+            {
+            case AML_CLASS_NAMED_OBJECT:
+
+                switch (Op->Asl.AmlOpcode)
+                {
+                case AML_SCOPE_OP:
+                case AML_ALIAS_OP:
+
+                    break;
+
+                default:
+
+                    if (Op->Asl.ExternalName)
+                    {
+                        LsFlushListingBuffer (FileId);
+                        FlPrintFile (FileId, "    };\n");
+                    }
+                    break;
+                }
+                break;
+
+            default:
+
+                /* Don't care about other objects */
+
+                break;
+            }
+            break;
+        }
+    }
+
+    /* These cases do not have a corresponding AML opcode */
+
+    switch (Op->Asl.ParseOpcode)
+    {
+    case PARSEOP_DEFINITION_BLOCK:
+
+        /* Always start a definition block at AML offset zero */
+
+        Gbl_CurrentAmlOffset = 0;
+        LsWriteSourceLines (Op->Asl.EndLine, Op->Asl.EndLogicalLine, FileId);
+
+        /* Use the table Signature and TableId to build a unique name */
+
+        switch (FileId)
+        {
+        case ASL_FILE_ASM_SOURCE_OUTPUT:
+
+            FlPrintFile (FileId,
+                "%s_%s_Header \\\n",
+                Gbl_TableSignature, Gbl_TableId);
+            break;
+
+        case ASL_FILE_C_SOURCE_OUTPUT:
+
+            FlPrintFile (FileId,
+                "    unsigned char    %s_%s_Header [] =\n    {\n",
+                Gbl_TableSignature, Gbl_TableId);
+            break;
+
+        case ASL_FILE_ASM_INCLUDE_OUTPUT:
+
+            FlPrintFile (FileId,
+                "extrn %s_%s_Header : byte\n",
+                Gbl_TableSignature, Gbl_TableId);
+            break;
+
+        case ASL_FILE_C_INCLUDE_OUTPUT:
+
+            FlPrintFile (FileId,
+                "extern unsigned char    %s_%s_Header [];\n",
+                Gbl_TableSignature, Gbl_TableId);
+            break;
+
+        default:
+            break;
+        }
+
+        return;
+
+
+    case PARSEOP_METHODCALL:
+
+        LsWriteSourceLines (Op->Asl.LineNumber, Op->Asl.LogicalLineNumber,
+            FileId);
+        return;
+
+
+    case PARSEOP_INCLUDE:
+
+        /* Flush everything up to and including the include source line */
+
+        LsWriteSourceLines (Op->Asl.LineNumber, Op->Asl.LogicalLineNumber,
+            FileId);
+
+        /* Create a new listing node and push it */
+
+        LsPushNode (Op->Asl.Value.String);
+        return;
+
+
+    case PARSEOP_INCLUDE_END:
+
+        /* Flush out the rest of the include file */
+
+        LsWriteSourceLines (Op->Asl.LineNumber, Op->Asl.LogicalLineNumber,
+            FileId);
+
+        /* Pop off this listing node and go back to the parent file */
+
+        (void) LsPopNode ();
+        return;
+
+
+    case PARSEOP_DEFAULT_ARG:
+
+        if (Op->Asl.CompileFlags & NODE_IS_RESOURCE_DESC)
+        {
+            LsWriteSourceLines (Op->Asl.LineNumber, Op->Asl.EndLogicalLine,
+                FileId);
+        }
+        return;
+
+
+    default:
+
+        /* All other opcodes have an AML opcode */
+
+        break;
+    }
+
+    /*
+     * Otherwise, we look at the AML opcode because we can
+     * switch on the opcode type, getting an entire class
+     * at once
+     */
+    switch (OpClass)
+    {
+    case AML_CLASS_ARGUMENT:       /* argument type only */
+    case AML_CLASS_INTERNAL:
+
+        break;
+
+    case AML_CLASS_NAMED_OBJECT:
+
+        switch (Op->Asl.AmlOpcode)
+        {
+        case AML_FIELD_OP:
+        case AML_INDEX_FIELD_OP:
+        case AML_BANK_FIELD_OP:
+            /*
+             * For fields, we want to dump all the AML after the
+             * entire definition
+             */
+            LsWriteSourceLines (Op->Asl.EndLine, Op->Asl.EndLogicalLine,
+                FileId);
+            break;
+
+        case AML_NAME_OP:
+
+            if (Op->Asl.CompileFlags & NODE_IS_RESOURCE_DESC)
+            {
+                LsWriteSourceLines (Op->Asl.LineNumber, Op->Asl.LogicalLineNumber,
+                    FileId);
+            }
+            else
+            {
+                /*
+                 * For fields, we want to dump all the AML after the
+                 * entire definition
+                 */
+                LsWriteSourceLines (Op->Asl.EndLine, Op->Asl.EndLogicalLine,
+                    FileId);
+            }
+            break;
+
+        default:
+
+            LsWriteSourceLines (Op->Asl.LineNumber, Op->Asl.LogicalLineNumber,
+                FileId);
+            break;
+        }
+
+        switch (Op->Asl.AmlOpcode)
+        {
+        case AML_SCOPE_OP:
+        case AML_ALIAS_OP:
+
+            /* These opcodes do not declare a new object, ignore them */
+
+            break;
+
+        default:
+
+            /* All other named object opcodes come here */
+
+            switch (FileId)
+            {
+            case ASL_FILE_ASM_SOURCE_OUTPUT:
+            case ASL_FILE_C_SOURCE_OUTPUT:
+            case ASL_FILE_ASM_INCLUDE_OUTPUT:
+            case ASL_FILE_C_INCLUDE_OUTPUT:
+                /*
+                 * For named objects, we will create a valid symbol so that the
+                 * AML code can be referenced from C or ASM
+                 */
+                if (Op->Asl.ExternalName)
+                {
+                    /* Get the full pathname associated with this node */
+
+                    Pathname = AcpiNsGetExternalPathname (Op->Asl.Node);
+                    Length = strlen (Pathname);
+                    if (Length >= 4)
+                    {
+                        /* Convert all dots in the path to underscores */
+
+                        for (i = 0; i < Length; i++)
+                        {
+                            if (Pathname[i] == '.')
+                            {
+                                Pathname[i] = '_';
+                            }
+                        }
+
+                        /* Create the appropriate symbol in the output file */
+
+                        switch (FileId)
+                        {
+                        case ASL_FILE_ASM_SOURCE_OUTPUT:
+
+                            FlPrintFile (FileId,
+                                "%s_%s_%s  \\\n",
+                                Gbl_TableSignature, Gbl_TableId, &Pathname[1]);
+                            break;
+
+                        case ASL_FILE_C_SOURCE_OUTPUT:
+
+                            FlPrintFile (FileId,
+                                "    unsigned char    %s_%s_%s [] =\n    {\n",
+                                Gbl_TableSignature, Gbl_TableId, &Pathname[1]);
+                            break;
+
+                        case ASL_FILE_ASM_INCLUDE_OUTPUT:
+
+                            FlPrintFile (FileId,
+                                "extrn %s_%s_%s : byte\n",
+                                Gbl_TableSignature, Gbl_TableId, &Pathname[1]);
+                            break;
+
+                        case ASL_FILE_C_INCLUDE_OUTPUT:
+
+                            FlPrintFile (FileId,
+                                "extern unsigned char    %s_%s_%s [];\n",
+                                Gbl_TableSignature, Gbl_TableId, &Pathname[1]);
+                            break;
+
+                        default:
+                            break;
+                        }
+                    }
+
+                    ACPI_FREE (Pathname);
+                }
+                break;
+
+            default:
+
+                /* Nothing to do for listing file */
+
+                break;
+            }
+        }
+        break;
+
+    case AML_CLASS_EXECUTE:
+    case AML_CLASS_CREATE:
+    default:
+
+        if ((Op->Asl.ParseOpcode == PARSEOP_BUFFER) &&
+            (Op->Asl.CompileFlags & NODE_IS_RESOURCE_DESC))
+        {
+            return;
+        }
+
+        LsWriteSourceLines (Op->Asl.LineNumber, Op->Asl.LogicalLineNumber,
+            FileId);
+        break;
+
+    case AML_CLASS_UNKNOWN:
+
+        break;
+    }
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    LsFinishSourceListing
+ *
+ * PARAMETERS:  FileId          - ID of current listing file.
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Cleanup routine for the listing file. Flush the hex AML
+ *              listing buffer, and flush out any remaining lines in the
+ *              source input file.
+ *
+ ******************************************************************************/
+
+static void
+LsFinishSourceListing (
+    UINT32                  FileId)
+{
+
+    if ((FileId == ASL_FILE_ASM_INCLUDE_OUTPUT) ||
+        (FileId == ASL_FILE_C_INCLUDE_OUTPUT))
+    {
+        return;
+    }
+
+    LsFlushListingBuffer (FileId);
+    Gbl_CurrentAmlOffset = 0;
+
+    /* Flush any remaining text in the source file */
+
+    if (FileId == ASL_FILE_C_SOURCE_OUTPUT)
+    {
+        FlPrintFile (FileId, "    /*\n");
+    }
+
+    while (LsWriteOneSourceLine (FileId))
+    { ; }
+
+    if (FileId == ASL_FILE_C_SOURCE_OUTPUT)
+    {
+        FlPrintFile (FileId, "\n     */\n    };\n");
+    }
+
+    FlPrintFile (FileId, "\n");
+
+    if (FileId == ASL_FILE_LISTING_OUTPUT)
+    {
+        /* Print a summary of the compile exceptions */
+
+        FlPrintFile (FileId, "\n\nSummary of errors and warnings\n\n");
+        AePrintErrorLog (FileId);
+        FlPrintFile (FileId, "\n");
+        UtDisplaySummary (FileId);
+        FlPrintFile (FileId, "\n");
+    }
+}
diff --git a/usr/src/cmd/acpi/iasl/asllistsup.c b/usr/src/cmd/acpi/iasl/asllistsup.c
new file mode 100644
index 0000000000..daae21b959
--- /dev/null
+++ b/usr/src/cmd/acpi/iasl/asllistsup.c
@@ -0,0 +1,711 @@
+/******************************************************************************
+ *
+ * Module Name: asllistsup - Listing file support utilities
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2016, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include "aslcompiler.h"
+#include "aslcompiler.y.h"
+
+
+#define _COMPONENT          ACPI_COMPILER
+        ACPI_MODULE_NAME    ("aslistsup")
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    LsDumpAscii
+ *
+ * PARAMETERS:  FileId          - ID of current listing file
+ *              Count           - Number of bytes to convert
+ *              Buffer          - Buffer of bytes to convert
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Convert hex bytes to ascii
+ *
+ ******************************************************************************/
+
+void
+LsDumpAscii (
+    UINT32                  FileId,
+    UINT32                  Count,
+    UINT8                   *Buffer)
+{
+    UINT8                   BufChar;
+    UINT32                  i;
+
+
+    FlPrintFile (FileId, "    \"");
+    for (i = 0; i < Count; i++)
+    {
+        BufChar = Buffer[i];
+        if (isprint (BufChar))
+        {
+            FlPrintFile (FileId, "%c", BufChar);
+        }
+        else
+        {
+            /* Not a printable character, just put out a dot */
+
+            FlPrintFile (FileId, ".");
+        }
+    }
+
+    FlPrintFile (FileId, "\"");
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    LsDumpAsciiInComment
+ *
+ * PARAMETERS:  FileId          - ID of current listing file
+ *              Count           - Number of bytes to convert
+ *              Buffer          - Buffer of bytes to convert
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Convert hex bytes to ascii
+ *
+ ******************************************************************************/
+
+void
+LsDumpAsciiInComment (
+    UINT32                  FileId,
+    UINT32                  Count,
+    UINT8                   *Buffer)
+{
+    UINT8                   BufChar = 0;
+    UINT8                   LastChar;
+    UINT32                  i;
+
+
+    FlPrintFile (FileId, "    \"");
+    for (i = 0; i < Count; i++)
+    {
+        LastChar = BufChar;
+        BufChar = Buffer[i];
+
+        if (isprint (BufChar))
+        {
+            /* Handle embedded C comment sequences */
+
+            if (((LastChar == '*') && (BufChar == '/')) ||
+                ((LastChar == '/') && (BufChar == '*')))
+            {
+                /* Insert a space to break the sequence */
+
+                FlPrintFile (FileId, ".", BufChar);
+            }
+
+            FlPrintFile (FileId, "%c", BufChar);
+        }
+        else
+        {
+            /* Not a printable character, just put out a dot */
+
+            FlPrintFile (FileId, ".");
+        }
+    }
+
+    FlPrintFile (FileId, "\"");
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    LsCheckException
+ *
+ * PARAMETERS:  LineNumber          - Current logical (cumulative) line #
+ *              FileId              - ID of output listing file
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Check if there is an exception for this line, and if there is,
+ *              put it in the listing immediately. Handles multiple errors
+ *              per line. Gbl_NextError points to the next error in the
+ *              sorted (by line #) list of compile errors/warnings.
+ *
+ ******************************************************************************/
+
+void
+LsCheckException (
+    UINT32                  LineNumber,
+    UINT32                  FileId)
+{
+
+    if ((!Gbl_NextError) ||
+        (LineNumber < Gbl_NextError->LogicalLineNumber ))
+    {
+        return;
+    }
+
+    /* Handle multiple errors per line */
+
+    if (FileId == ASL_FILE_LISTING_OUTPUT)
+    {
+        while (Gbl_NextError &&
+              (LineNumber >= Gbl_NextError->LogicalLineNumber))
+        {
+            AePrintException (FileId, Gbl_NextError, "\n[****iasl****]\n");
+            Gbl_NextError = Gbl_NextError->Next;
+        }
+
+        FlPrintFile (FileId, "\n");
+    }
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    LsWriteListingHexBytes
+ *
+ * PARAMETERS:  Buffer          - AML code buffer
+ *              Length          - Number of AML bytes to write
+ *              FileId          - ID of current listing file.
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Write the contents of the AML buffer to the listing file via
+ *              the listing buffer. The listing buffer is flushed every 16
+ *              AML bytes.
+ *
+ ******************************************************************************/
+
+void
+LsWriteListingHexBytes (
+    UINT8                   *Buffer,
+    UINT32                  Length,
+    UINT32                  FileId)
+{
+    UINT32                  i;
+
+
+    /* Transfer all requested bytes */
+
+    for (i = 0; i < Length; i++)
+    {
+        /* Print line header when buffer is empty */
+
+        if (Gbl_CurrentHexColumn == 0)
+        {
+            if (Gbl_HasIncludeFiles)
+            {
+                FlPrintFile (FileId, "%*s", 10, " ");
+            }
+
+            switch (FileId)
+            {
+            case ASL_FILE_LISTING_OUTPUT:
+
+                FlPrintFile (FileId, "%8.8X%s", Gbl_CurrentAmlOffset,
+                    ASL_LISTING_LINE_PREFIX);
+                break;
+
+            case ASL_FILE_ASM_SOURCE_OUTPUT:
+
+                FlPrintFile (FileId, "    db ");
+                break;
+
+            case ASL_FILE_C_SOURCE_OUTPUT:
+
+                FlPrintFile (FileId, "        ");
+                break;
+
+            default:
+
+                /* No other types supported */
+
+                return;
+            }
+        }
+
+        /* Transfer AML byte and update counts */
+
+        Gbl_AmlBuffer[Gbl_CurrentHexColumn] = Buffer[i];
+
+        Gbl_CurrentHexColumn++;
+        Gbl_CurrentAmlOffset++;
+
+        /* Flush buffer when it is full */
+
+        if (Gbl_CurrentHexColumn >= HEX_LISTING_LINE_SIZE)
+        {
+            LsFlushListingBuffer (FileId);
+        }
+    }
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    LsWriteSourceLines
+ *
+ * PARAMETERS:  ToLineNumber            -
+ *              ToLogicalLineNumber     - Write up to this source line number
+ *              FileId                  - ID of current listing file
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Read then write source lines to the listing file until we have
+ *              reached the specified logical (cumulative) line number. This
+ *              automatically echos out comment blocks and other non-AML
+ *              generating text until we get to the actual AML-generating line
+ *              of ASL code specified by the logical line number.
+ *
+ ******************************************************************************/
+
+void
+LsWriteSourceLines (
+    UINT32                  ToLineNumber,
+    UINT32                  ToLogicalLineNumber,
+    UINT32                  FileId)
+{
+
+    /* Nothing to do for these file types */
+
+    if ((FileId == ASL_FILE_ASM_INCLUDE_OUTPUT) ||
+        (FileId == ASL_FILE_C_INCLUDE_OUTPUT))
+    {
+        return;
+    }
+
+    Gbl_CurrentLine = ToLogicalLineNumber;
+
+    /* Flush any hex bytes remaining from the last opcode */
+
+    LsFlushListingBuffer (FileId);
+
+    /* Read lines and write them as long as we are not caught up */
+
+    if (Gbl_SourceLine < Gbl_CurrentLine)
+    {
+        /*
+         * If we just completed writing some AML hex bytes, output a linefeed
+         * to add some whitespace for readability.
+         */
+        if (Gbl_HexBytesWereWritten)
+        {
+            FlPrintFile (FileId, "\n");
+            Gbl_HexBytesWereWritten = FALSE;
+        }
+
+        if (FileId == ASL_FILE_C_SOURCE_OUTPUT)
+        {
+            FlPrintFile (FileId, "    /*\n");
+        }
+
+        /* Write one line at a time until we have reached the target line # */
+
+        while ((Gbl_SourceLine < Gbl_CurrentLine) &&
+                LsWriteOneSourceLine (FileId))
+        { ; }
+
+        if (FileId == ASL_FILE_C_SOURCE_OUTPUT)
+        {
+            FlPrintFile (FileId, "     */");
+        }
+
+        FlPrintFile (FileId, "\n");
+    }
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    LsWriteOneSourceLine
+ *
+ * PARAMETERS:  FileId          - ID of current listing file
+ *
+ * RETURN:      FALSE on EOF (input source file), TRUE otherwise
+ *
+ * DESCRIPTION: Read one line from the input source file and echo it to the
+ *              listing file, prefixed with the line number, and if the source
+ *              file contains include files, prefixed with the current filename
+ *
+ ******************************************************************************/
+
+UINT32
+LsWriteOneSourceLine (
+    UINT32                  FileId)
+{
+    UINT8                   FileByte;
+    UINT32                  Column = 0;
+    UINT32                  Index = 16;
+    BOOLEAN                 StartOfLine = FALSE;
+    BOOLEAN                 ProcessLongLine = FALSE;
+
+
+    Gbl_SourceLine++;
+    Gbl_ListingNode->LineNumber++;
+
+    /* Ignore lines that are completely blank (but count the line above) */
+
+    if (FlReadFile (ASL_FILE_SOURCE_OUTPUT, &FileByte, 1) != AE_OK)
+    {
+        return (0);
+    }
+    if (FileByte == '\n')
+    {
+        return (1);
+    }
+
+    /*
+     * This is a non-empty line, we will print the entire line with
+     * the line number and possibly other prefixes and transforms.
+     */
+
+    /* Line prefixes for special files, C and ASM output */
+
+    if (FileId == ASL_FILE_C_SOURCE_OUTPUT)
+    {
+        FlPrintFile (FileId, "     *");
+    }
+    if (FileId == ASL_FILE_ASM_SOURCE_OUTPUT)
+    {
+        FlPrintFile (FileId, "; ");
+    }
+
+    if (Gbl_HasIncludeFiles)
+    {
+        /*
+         * This file contains "include" statements, print the current
+         * filename and line number within the current file
+         */
+        FlPrintFile (FileId, "%12s %5d%s",
+            Gbl_ListingNode->Filename, Gbl_ListingNode->LineNumber,
+            ASL_LISTING_LINE_PREFIX);
+    }
+    else
+    {
+        /* No include files, just print the line number */
+
+        FlPrintFile (FileId, "%8u%s", Gbl_SourceLine,
+            ASL_LISTING_LINE_PREFIX);
+    }
+
+    /* Read the rest of this line (up to a newline or EOF) */
+
+    do
+    {
+        if (FileId == ASL_FILE_C_SOURCE_OUTPUT)
+        {
+            if (FileByte == '/')
+            {
+                FileByte = '*';
+            }
+        }
+
+        /* Split long input lines for readability in the listing */
+
+        Column++;
+        if (Column >= 128)
+        {
+            if (!ProcessLongLine)
+            {
+                if ((FileByte != '}') &&
+                    (FileByte != '{'))
+                {
+                    goto WriteByte;
+                }
+
+                ProcessLongLine = TRUE;
+            }
+
+            if (FileByte == '{')
+            {
+                FlPrintFile (FileId, "\n%*s{\n", Index, " ");
+                StartOfLine = TRUE;
+                Index += 4;
+                continue;
+            }
+
+            else if (FileByte == '}')
+            {
+                if (!StartOfLine)
+                {
+                    FlPrintFile (FileId, "\n");
+                }
+
+                StartOfLine = TRUE;
+                Index -= 4;
+                FlPrintFile (FileId, "%*s}\n", Index, " ");
+                continue;
+            }
+
+            /* Ignore spaces/tabs at the start of line */
+
+            else if ((FileByte == ' ') && StartOfLine)
+            {
+                continue;
+            }
+
+            else if (StartOfLine)
+            {
+                StartOfLine = FALSE;
+                FlPrintFile (FileId, "%*s", Index, " ");
+            }
+
+WriteByte:
+            FlWriteFile (FileId, &FileByte, 1);
+            if (FileByte == '\n')
+            {
+                /*
+                 * This line has been completed.
+                 * Check if an error occurred on this source line during the compile.
+                 * If so, we print the error message after the source line.
+                 */
+                LsCheckException (Gbl_SourceLine, FileId);
+                return (1);
+            }
+        }
+        else
+        {
+            FlWriteFile (FileId, &FileByte, 1);
+            if (FileByte == '\n')
+            {
+                /*
+                 * This line has been completed.
+                 * Check if an error occurred on this source line during the compile.
+                 * If so, we print the error message after the source line.
+                 */
+                LsCheckException (Gbl_SourceLine, FileId);
+                return (1);
+            }
+        }
+
+    } while (FlReadFile (ASL_FILE_SOURCE_OUTPUT, &FileByte, 1) == AE_OK);
+
+    /* EOF on the input file was reached */
+
+    return (0);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    LsFlushListingBuffer
+ *
+ * PARAMETERS:  FileId          - ID of the listing file
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Flush out the current contents of the 16-byte hex AML code
+ *              buffer. Usually called at the termination of a single line
+ *              of source code or when the buffer is full.
+ *
+ ******************************************************************************/
+
+void
+LsFlushListingBuffer (
+    UINT32                  FileId)
+{
+    UINT32                  i;
+
+
+    if (Gbl_CurrentHexColumn == 0)
+    {
+        return;
+    }
+
+    /* Write the hex bytes */
+
+    switch (FileId)
+    {
+    case ASL_FILE_LISTING_OUTPUT:
+
+        for (i = 0; i < Gbl_CurrentHexColumn; i++)
+        {
+            FlPrintFile (FileId, "%2.2X ", Gbl_AmlBuffer[i]);
+        }
+
+        for (i = 0; i < ((HEX_LISTING_LINE_SIZE - Gbl_CurrentHexColumn) * 3); i++)
+        {
+            FlWriteFile (FileId, ".", 1);
+        }
+
+        /* Write the ASCII character associated with each of the bytes */
+
+        LsDumpAscii (FileId, Gbl_CurrentHexColumn, Gbl_AmlBuffer);
+        break;
+
+
+    case ASL_FILE_ASM_SOURCE_OUTPUT:
+
+        for (i = 0; i < Gbl_CurrentHexColumn; i++)
+        {
+            if (i > 0)
+            {
+                FlPrintFile (FileId, ",");
+            }
+
+            FlPrintFile (FileId, "0%2.2Xh", Gbl_AmlBuffer[i]);
+        }
+
+        for (i = 0; i < ((HEX_LISTING_LINE_SIZE - Gbl_CurrentHexColumn) * 5); i++)
+        {
+            FlWriteFile (FileId, " ", 1);
+        }
+
+        FlPrintFile (FileId, "  ;%8.8X",
+            Gbl_CurrentAmlOffset - HEX_LISTING_LINE_SIZE);
+
+        /* Write the ASCII character associated with each of the bytes */
+
+        LsDumpAscii (FileId, Gbl_CurrentHexColumn, Gbl_AmlBuffer);
+        break;
+
+
+    case ASL_FILE_C_SOURCE_OUTPUT:
+
+        for (i = 0; i < Gbl_CurrentHexColumn; i++)
+        {
+            FlPrintFile (FileId, "0x%2.2X,", Gbl_AmlBuffer[i]);
+        }
+
+        /* Pad hex output with spaces if line is shorter than max line size */
+
+        for (i = 0; i < ((HEX_LISTING_LINE_SIZE - Gbl_CurrentHexColumn) * 5); i++)
+        {
+            FlWriteFile (FileId, " ", 1);
+        }
+
+        /* AML offset for the start of the line */
+
+        FlPrintFile (FileId, "    /* %8.8X",
+            Gbl_CurrentAmlOffset - Gbl_CurrentHexColumn);
+
+        /* Write the ASCII character associated with each of the bytes */
+
+        LsDumpAsciiInComment (FileId, Gbl_CurrentHexColumn, Gbl_AmlBuffer);
+        FlPrintFile (FileId, " */");
+        break;
+
+    default:
+
+        /* No other types supported */
+
+        return;
+    }
+
+    FlPrintFile (FileId, "\n");
+
+    Gbl_CurrentHexColumn = 0;
+    Gbl_HexBytesWereWritten = TRUE;
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    LsPushNode
+ *
+ * PARAMETERS:  Filename        - Pointer to the include filename
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Push a listing node on the listing/include file stack. This
+ *              stack enables tracking of include files (infinitely nested)
+ *              and resumption of the listing of the parent file when the
+ *              include file is finished.
+ *
+ ******************************************************************************/
+
+void
+LsPushNode (
+    char                    *Filename)
+{
+    ASL_LISTING_NODE        *Lnode;
+
+
+    /* Create a new node */
+
+    Lnode = UtLocalCalloc (sizeof (ASL_LISTING_NODE));
+
+    /* Initialize */
+
+    Lnode->Filename = Filename;
+    Lnode->LineNumber = 0;
+
+    /* Link (push) */
+
+    Lnode->Next = Gbl_ListingNode;
+    Gbl_ListingNode = Lnode;
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    LsPopNode
+ *
+ * PARAMETERS:  None
+ *
+ * RETURN:      List head after current head is popped off
+ *
+ * DESCRIPTION: Pop the current head of the list, free it, and return the
+ *              next node on the stack (the new current node).
+ *
+ ******************************************************************************/
+
+ASL_LISTING_NODE *
+LsPopNode (
+    void)
+{
+    ASL_LISTING_NODE        *Lnode;
+
+
+    /* Just grab the node at the head of the list */
+
+    Lnode = Gbl_ListingNode;
+    if ((!Lnode) ||
+        (!Lnode->Next))
+    {
+        AslError (ASL_ERROR, ASL_MSG_COMPILER_INTERNAL, NULL,
+            "Could not pop empty listing stack");
+        return (Gbl_ListingNode);
+    }
+
+    Gbl_ListingNode = Lnode->Next;
+    ACPI_FREE (Lnode);
+
+    /* New "Current" node is the new head */
+
+    return (Gbl_ListingNode);
+}
diff --git a/usr/src/cmd/acpi/iasl/aslload.c b/usr/src/cmd/acpi/iasl/aslload.c
new file mode 100644
index 0000000000..99ec1bfe06
--- /dev/null
+++ b/usr/src/cmd/acpi/iasl/aslload.c
@@ -0,0 +1,982 @@
+/******************************************************************************
+ *
+ * Module Name: dswload - Dispatcher namespace load callbacks
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2016, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include "aslcompiler.h"
+#include "amlcode.h"
+#include "acdispat.h"
+#include "acnamesp.h"
+
+#include "aslcompiler.y.h"
+
+#define _COMPONENT          ACPI_COMPILER
+        ACPI_MODULE_NAME    ("aslload")
+
+/* Local prototypes */
+
+static ACPI_STATUS
+LdLoadFieldElements (
+    ACPI_PARSE_OBJECT       *Op,
+    ACPI_WALK_STATE         *WalkState);
+
+static ACPI_STATUS
+LdLoadResourceElements (
+    ACPI_PARSE_OBJECT       *Op,
+    ACPI_WALK_STATE         *WalkState);
+
+static ACPI_STATUS
+LdNamespace1Begin (
+    ACPI_PARSE_OBJECT       *Op,
+    UINT32                  Level,
+    void                    *Context);
+
+static ACPI_STATUS
+LdNamespace2Begin (
+    ACPI_PARSE_OBJECT       *Op,
+    UINT32                  Level,
+    void                    *Context);
+
+static ACPI_STATUS
+LdCommonNamespaceEnd (
+    ACPI_PARSE_OBJECT       *Op,
+    UINT32                  Level,
+    void                    *Context);
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    LdLoadNamespace
+ *
+ * PARAMETERS:  RootOp      - Root of the parse tree
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Perform a walk of the parse tree that in turn loads all of the
+ *              named ASL/AML objects into the namespace. The namespace is
+ *              constructed in order to resolve named references and references
+ *              to named fields within resource templates/descriptors.
+ *
+ ******************************************************************************/
+
+ACPI_STATUS
+LdLoadNamespace (
+    ACPI_PARSE_OBJECT       *RootOp)
+{
+    ACPI_WALK_STATE         *WalkState;
+
+
+    /* Create a new walk state */
+
+    WalkState = AcpiDsCreateWalkState (0, NULL, NULL, NULL);
+    if (!WalkState)
+    {
+        return (AE_NO_MEMORY);
+    }
+
+    /* Walk the entire parse tree, first pass */
+
+    TrWalkParseTree (RootOp, ASL_WALK_VISIT_TWICE, LdNamespace1Begin,
+        LdCommonNamespaceEnd, WalkState);
+
+    /* Second pass to handle forward references */
+
+    TrWalkParseTree (RootOp, ASL_WALK_VISIT_TWICE, LdNamespace2Begin,
+        LdCommonNamespaceEnd, WalkState);
+
+    /* Dump the namespace if debug is enabled */
+
+    AcpiNsDumpTables (ACPI_NS_ALL, ACPI_UINT32_MAX);
+    ACPI_FREE (WalkState);
+    return (AE_OK);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    LdLoadFieldElements
+ *
+ * PARAMETERS:  Op              - Parent node (Field)
+ *              WalkState       - Current walk state
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Enter the named elements of the field (children of the parent)
+ *              into the namespace.
+ *
+ ******************************************************************************/
+
+static ACPI_STATUS
+LdLoadFieldElements (
+    ACPI_PARSE_OBJECT       *Op,
+    ACPI_WALK_STATE         *WalkState)
+{
+    ACPI_PARSE_OBJECT       *Child = NULL;
+    ACPI_NAMESPACE_NODE     *Node;
+    ACPI_STATUS             Status;
+
+
+    /* Get the first named field element */
+
+    switch (Op->Asl.AmlOpcode)
+    {
+    case AML_BANK_FIELD_OP:
+
+        Child = UtGetArg (Op, 6);
+        break;
+
+    case AML_INDEX_FIELD_OP:
+
+        Child = UtGetArg (Op, 5);
+        break;
+
+    case AML_FIELD_OP:
+
+        Child = UtGetArg (Op, 4);
+        break;
+
+    default:
+
+        /* No other opcodes should arrive here */
+
+        return (AE_BAD_PARAMETER);
+    }
+
+    /* Enter all elements into the namespace */
+
+    while (Child)
+    {
+        switch (Child->Asl.AmlOpcode)
+        {
+        case AML_INT_RESERVEDFIELD_OP:
+        case AML_INT_ACCESSFIELD_OP:
+        case AML_INT_CONNECTION_OP:
+            break;
+
+        default:
+
+            Status = AcpiNsLookup (WalkState->ScopeInfo,
+                Child->Asl.Value.String,
+                ACPI_TYPE_LOCAL_REGION_FIELD,
+                ACPI_IMODE_LOAD_PASS1,
+                ACPI_NS_NO_UPSEARCH | ACPI_NS_DONT_OPEN_SCOPE |
+                    ACPI_NS_ERROR_IF_FOUND, NULL, &Node);
+            if (ACPI_FAILURE (Status))
+            {
+                if (Status != AE_ALREADY_EXISTS)
+                {
+                    AslError (ASL_ERROR, ASL_MSG_CORE_EXCEPTION, Child,
+                        Child->Asl.Value.String);
+                    return (Status);
+                }
+
+                /*
+                 * The name already exists in this scope
+                 * But continue processing the elements
+                 */
+                AslError (ASL_ERROR, ASL_MSG_NAME_EXISTS, Child,
+                    Child->Asl.Value.String);
+            }
+            else
+            {
+                Child->Asl.Node = Node;
+                Node->Op = Child;
+            }
+            break;
+        }
+
+        Child = Child->Asl.Next;
+    }
+
+    return (AE_OK);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    LdLoadResourceElements
+ *
+ * PARAMETERS:  Op              - Parent node (Resource Descriptor)
+ *              WalkState       - Current walk state
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Enter the named elements of the resource descriptor (children
+ *              of the parent) into the namespace.
+ *
+ * NOTE: In the real AML namespace, these named elements never exist. But
+ *       we simply use the namespace here as a symbol table so we can look
+ *       them up as they are referenced.
+ *
+ ******************************************************************************/
+
+static ACPI_STATUS
+LdLoadResourceElements (
+    ACPI_PARSE_OBJECT       *Op,
+    ACPI_WALK_STATE         *WalkState)
+{
+    ACPI_PARSE_OBJECT       *InitializerOp = NULL;
+    ACPI_NAMESPACE_NODE     *Node;
+    ACPI_STATUS             Status;
+
+
+    /*
+     * Enter the resource name into the namespace. Name must not already exist.
+     * This opens a scope, so later field names are guaranteed to be new/unique.
+     */
+    Status = AcpiNsLookup (WalkState->ScopeInfo, Op->Asl.Namepath,
+        ACPI_TYPE_LOCAL_RESOURCE, ACPI_IMODE_LOAD_PASS1,
+        ACPI_NS_NO_UPSEARCH | ACPI_NS_ERROR_IF_FOUND,
+        WalkState, &Node);
+    if (ACPI_FAILURE (Status))
+    {
+        if (Status == AE_ALREADY_EXISTS)
+        {
+            /* Actual node causing the error was saved in ParentMethod */
+
+            AslError (ASL_ERROR, ASL_MSG_NAME_EXISTS,
+                (ACPI_PARSE_OBJECT *) Op->Asl.ParentMethod, Op->Asl.Namepath);
+            return (AE_OK);
+        }
+        return (Status);
+    }
+
+    Node->Value = (UINT32) Op->Asl.Value.Integer;
+    Node->Op = Op;
+    Op->Asl.Node = Node;
+
+    /*
+     * Now enter the predefined fields, for easy lookup when referenced
+     * by the source ASL
+     */
+    InitializerOp = ASL_GET_CHILD_NODE (Op);
+    while (InitializerOp)
+    {
+        if (InitializerOp->Asl.ExternalName)
+        {
+            Status = AcpiNsLookup (WalkState->ScopeInfo,
+                InitializerOp->Asl.ExternalName,
+                ACPI_TYPE_LOCAL_RESOURCE_FIELD,
+                ACPI_IMODE_LOAD_PASS1,
+                ACPI_NS_NO_UPSEARCH | ACPI_NS_DONT_OPEN_SCOPE,
+                NULL, &Node);
+            if (ACPI_FAILURE (Status))
+            {
+                return (Status);
+            }
+
+            /*
+             * Store the field offset and length in the namespace node
+             * so it can be used when the field is referenced
+             */
+            Node->Value = InitializerOp->Asl.Value.Tag.BitOffset;
+            Node->Length = InitializerOp->Asl.Value.Tag.BitLength;
+            InitializerOp->Asl.Node = Node;
+            Node->Op = InitializerOp;
+        }
+
+        InitializerOp = ASL_GET_PEER_NODE (InitializerOp);
+    }
+
+    return (AE_OK);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    LdNamespace1Begin
+ *
+ * PARAMETERS:  ASL_WALK_CALLBACK
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Descending callback used during the parse tree walk. If this
+ *              is a named AML opcode, enter into the namespace
+ *
+ ******************************************************************************/
+
+static ACPI_STATUS
+LdNamespace1Begin (
+    ACPI_PARSE_OBJECT       *Op,
+    UINT32                  Level,
+    void                    *Context)
+{
+    ACPI_WALK_STATE         *WalkState = (ACPI_WALK_STATE *) Context;
+    ACPI_NAMESPACE_NODE     *Node;
+    ACPI_PARSE_OBJECT       *MethodOp;
+    ACPI_STATUS             Status;
+    ACPI_OBJECT_TYPE        ObjectType;
+    ACPI_OBJECT_TYPE        ActualObjectType = ACPI_TYPE_ANY;
+    char                    *Path;
+    UINT32                  Flags = ACPI_NS_NO_UPSEARCH;
+    ACPI_PARSE_OBJECT       *Arg;
+    UINT32                  i;
+    BOOLEAN                 ForceNewScope = FALSE;
+
+
+    ACPI_FUNCTION_NAME (LdNamespace1Begin);
+    ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH, "Op %p [%s]\n",
+        Op, Op->Asl.ParseOpName));
+
+    /*
+     * We are only interested in opcodes that have an associated name
+     * (or multiple names)
+     */
+    switch (Op->Asl.AmlOpcode)
+    {
+    case AML_BANK_FIELD_OP:
+    case AML_INDEX_FIELD_OP:
+    case AML_FIELD_OP:
+
+        Status = LdLoadFieldElements (Op, WalkState);
+        return (Status);
+
+    case AML_INT_CONNECTION_OP:
+
+
+        if (Op->Asl.Child->Asl.AmlOpcode != AML_INT_NAMEPATH_OP)
+        {
+            break;
+        }
+        Arg = Op->Asl.Child;
+
+        Status = AcpiNsLookup (WalkState->ScopeInfo, Arg->Asl.ExternalName,
+            ACPI_TYPE_ANY, ACPI_IMODE_EXECUTE, ACPI_NS_SEARCH_PARENT,
+            WalkState, &Node);
+        if (ACPI_FAILURE (Status))
+        {
+            break;
+        }
+
+        if (Node->Type == ACPI_TYPE_BUFFER)
+        {
+            Arg->Asl.Node = Node;
+
+            Arg = Node->Op->Asl.Child;  /* Get namepath */
+            Arg = Arg->Asl.Next;        /* Get actual buffer */
+            Arg = Arg->Asl.Child;       /* Buffer length */
+            Arg = Arg->Asl.Next;        /* RAW_DATA buffer */
+        }
+        break;
+
+    default:
+
+        /* All other opcodes go below */
+
+        break;
+    }
+
+    /* Check if this object has already been installed in the namespace */
+
+    if (Op->Asl.Node)
+    {
+        return (AE_OK);
+    }
+
+    Path = Op->Asl.Namepath;
+    if (!Path)
+    {
+        return (AE_OK);
+    }
+
+    /* Map the raw opcode into an internal object type */
+
+    switch (Op->Asl.ParseOpcode)
+    {
+    case PARSEOP_NAME:
+
+        Arg = Op->Asl.Child;  /* Get the NameSeg/NameString node */
+        Arg = Arg->Asl.Next;  /* First peer is the object to be associated with the name */
+
+        /*
+         * If this name refers to a ResourceTemplate, we will need to open
+         * a new scope so that the resource subfield names can be entered into
+         * the namespace underneath this name
+         */
+        if (Op->Asl.CompileFlags & NODE_IS_RESOURCE_DESC)
+        {
+            ForceNewScope = TRUE;
+        }
+
+        /* Get the data type associated with the named object, not the name itself */
+
+        /* Log2 loop to convert from Btype (binary) to Etype (encoded) */
+
+        ObjectType = 1;
+        for (i = 1; i < Arg->Asl.AcpiBtype; i *= 2)
+        {
+            ObjectType++;
+        }
+        break;
+
+
+    case PARSEOP_EXTERNAL:
+        /*
+         * "External" simply enters a name and type into the namespace.
+         * We must be careful to not open a new scope, however, no matter
+         * what type the external name refers to (e.g., a method)
+         *
+         * first child is name, next child is ObjectType
+         */
+        ActualObjectType = (UINT8) Op->Asl.Child->Asl.Next->Asl.Value.Integer;
+        ObjectType = ACPI_TYPE_ANY;
+
+        /*
+         * We will mark every new node along the path as "External". This
+         * allows some or all of the nodes to be created later in the ASL
+         * code. Handles cases like this:
+         *
+         *   External (\_SB_.PCI0.ABCD, IntObj)
+         *   Scope (_SB_)
+         *   {
+         *       Device (PCI0)
+         *       {
+         *       }
+         *   }
+         *   Method (X)
+         *   {
+         *       Store (\_SB_.PCI0.ABCD, Local0)
+         *   }
+         */
+        Flags |= ACPI_NS_EXTERNAL;
+        break;
+
+    case PARSEOP_DEFAULT_ARG:
+
+        if (Op->Asl.CompileFlags == NODE_IS_RESOURCE_DESC)
+        {
+            Status = LdLoadResourceElements (Op, WalkState);
+            return_ACPI_STATUS (Status);
+        }
+
+        ObjectType = AslMapNamedOpcodeToDataType (Op->Asl.AmlOpcode);
+        break;
+
+    case PARSEOP_SCOPE:
+        /*
+         * The name referenced by Scope(Name) must already exist at this point.
+         * In other words, forward references for Scope() are not supported.
+         * The only real reason for this is that the MS interpreter cannot
+         * handle this case. Perhaps someday this case can go away.
+         */
+        Status = AcpiNsLookup (WalkState->ScopeInfo, Path, ACPI_TYPE_ANY,
+            ACPI_IMODE_EXECUTE, ACPI_NS_SEARCH_PARENT,
+            WalkState, &(Node));
+        if (ACPI_FAILURE (Status))
+        {
+            if (Status == AE_NOT_FOUND)
+            {
+                /* The name was not found, go ahead and create it */
+
+                Status = AcpiNsLookup (WalkState->ScopeInfo, Path,
+                    ACPI_TYPE_LOCAL_SCOPE,
+                    ACPI_IMODE_LOAD_PASS1, Flags,
+                    WalkState, &(Node));
+                if (ACPI_FAILURE (Status))
+                {
+                    return_ACPI_STATUS (Status);
+                }
+
+                /*
+                 * However, this is an error -- primarily because the MS
+                 * interpreter can't handle a forward reference from the
+                 * Scope() operator.
+                 */
+                AslError (ASL_ERROR, ASL_MSG_NOT_FOUND, Op,
+                    Op->Asl.ExternalName);
+                AslError (ASL_ERROR, ASL_MSG_SCOPE_FWD_REF, Op,
+                    Op->Asl.ExternalName);
+                goto FinishNode;
+            }
+
+            AslCoreSubsystemError (Op, Status,
+                "Failure from namespace lookup", FALSE);
+
+            return_ACPI_STATUS (Status);
+        }
+        else /* Status AE_OK */
+        {
+            /*
+             * Do not allow references to external scopes from the DSDT.
+             * This is because the DSDT is always loaded first, and the
+             * external reference cannot be resolved -- causing a runtime
+             * error because Scope() must be resolved immediately.
+             * 10/2015.
+             */
+            if ((Node->Flags & ANOBJ_IS_EXTERNAL) &&
+                (ACPI_COMPARE_NAME (Gbl_TableSignature, "DSDT")))
+            {
+                /* However, allowed if the reference is within a method */
+
+                MethodOp = Op->Asl.Parent;
+                while (MethodOp &&
+                      (MethodOp->Asl.ParseOpcode != PARSEOP_METHOD))
+                {
+                    MethodOp = MethodOp->Asl.Parent;
+                }
+
+                if (!MethodOp)
+                {
+                    /* Not in a control method, error */
+
+                    AslError (ASL_ERROR, ASL_MSG_CROSS_TABLE_SCOPE, Op, NULL);
+                }
+            }
+        }
+
+        /* We found a node with this name, now check the type */
+
+        switch (Node->Type)
+        {
+        case ACPI_TYPE_LOCAL_SCOPE:
+        case ACPI_TYPE_DEVICE:
+        case ACPI_TYPE_POWER:
+        case ACPI_TYPE_PROCESSOR:
+        case ACPI_TYPE_THERMAL:
+
+            /* These are acceptable types - they all open a new scope */
+            break;
+
+        case ACPI_TYPE_INTEGER:
+        case ACPI_TYPE_STRING:
+        case ACPI_TYPE_BUFFER:
+            /*
+             * These types we will allow, but we will change the type.
+             * This enables some existing code of the form:
+             *
+             *  Name (DEB, 0)
+             *  Scope (DEB) { ... }
+             *
+             * Which is used to workaround the fact that the MS interpreter
+             * does not allow Scope() forward references.
+             */
+            sprintf (MsgBuffer, "%s [%s], changing type to [Scope]",
+                Op->Asl.ExternalName, AcpiUtGetTypeName (Node->Type));
+            AslError (ASL_REMARK, ASL_MSG_SCOPE_TYPE, Op, MsgBuffer);
+
+            /* Switch the type to scope, open the new scope */
+
+            Node->Type = ACPI_TYPE_LOCAL_SCOPE;
+            Status = AcpiDsScopeStackPush (Node, ACPI_TYPE_LOCAL_SCOPE,
+                WalkState);
+            if (ACPI_FAILURE (Status))
+            {
+                return_ACPI_STATUS (Status);
+            }
+            break;
+
+        default:
+
+            /* All other types are an error */
+
+            sprintf (MsgBuffer, "%s [%s]", Op->Asl.ExternalName,
+                AcpiUtGetTypeName (Node->Type));
+            AslError (ASL_ERROR, ASL_MSG_SCOPE_TYPE, Op, MsgBuffer);
+
+            /*
+             * However, switch the type to be an actual scope so
+             * that compilation can continue without generating a whole
+             * cascade of additional errors. Open the new scope.
+             */
+            Node->Type = ACPI_TYPE_LOCAL_SCOPE;
+            Status = AcpiDsScopeStackPush (Node, ACPI_TYPE_LOCAL_SCOPE,
+                WalkState);
+            if (ACPI_FAILURE (Status))
+            {
+                return_ACPI_STATUS (Status);
+            }
+            break;
+        }
+
+        Status = AE_OK;
+        goto FinishNode;
+
+
+    default:
+
+        ObjectType = AslMapNamedOpcodeToDataType (Op->Asl.AmlOpcode);
+        break;
+    }
+
+
+    ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH, "Loading name: %s, (%s)\n",
+        Op->Asl.ExternalName, AcpiUtGetTypeName (ObjectType)));
+
+    /* The name must not already exist */
+
+    Flags |= ACPI_NS_ERROR_IF_FOUND;
+
+    /*
+     * Enter the named type into the internal namespace. We enter the name
+     * as we go downward in the parse tree. Any necessary subobjects that
+     * involve arguments to the opcode must be created as we go back up the
+     * parse tree later.
+     */
+    Status = AcpiNsLookup (WalkState->ScopeInfo, Path, ObjectType,
+        ACPI_IMODE_LOAD_PASS1, Flags, WalkState, &Node);
+    if (ACPI_FAILURE (Status))
+    {
+        if (Status == AE_ALREADY_EXISTS)
+        {
+            /* The name already exists in this scope */
+
+            if (Node->Type == ACPI_TYPE_LOCAL_SCOPE)
+            {
+                /* Allow multiple references to the same scope */
+
+                Node->Type = (UINT8) ObjectType;
+                Status = AE_OK;
+            }
+            else if ((Node->Flags & ANOBJ_IS_EXTERNAL) &&
+                     (Op->Asl.ParseOpcode != PARSEOP_EXTERNAL))
+            {
+                /*
+                 * Allow one create on an object or segment that was
+                 * previously declared External
+                 */
+                Node->Flags &= ~ANOBJ_IS_EXTERNAL;
+                Node->Type = (UINT8) ObjectType;
+
+                /* Just retyped a node, probably will need to open a scope */
+
+                if (AcpiNsOpensScope (ObjectType))
+                {
+                    Status = AcpiDsScopeStackPush (Node, ObjectType, WalkState);
+                    if (ACPI_FAILURE (Status))
+                    {
+                        return_ACPI_STATUS (Status);
+                    }
+                }
+
+                Status = AE_OK;
+            }
+            else if (!(Node->Flags & ANOBJ_IS_EXTERNAL) &&
+                     (Op->Asl.ParseOpcode == PARSEOP_EXTERNAL))
+            {
+                /*
+                 * Allow externals in same scope as the definition of the
+                 * actual object. Similar to C. Allows multiple definition
+                 * blocks that refer to each other in the same file.
+                 */
+                Status = AE_OK;
+            }
+            else if ((Node->Flags & ANOBJ_IS_EXTERNAL) &&
+                     (Op->Asl.ParseOpcode == PARSEOP_EXTERNAL) &&
+                     (ObjectType == ACPI_TYPE_ANY))
+            {
+                /* Allow update of externals of unknown type. */
+
+                if (AcpiNsOpensScope (ActualObjectType))
+                {
+                    Node->Type = (UINT8) ActualObjectType;
+                    Status = AE_OK;
+                }
+                else
+                {
+                    sprintf (MsgBuffer, "%s [%s]", Op->Asl.ExternalName,
+                        AcpiUtGetTypeName (Node->Type));
+                    AslError (ASL_ERROR, ASL_MSG_SCOPE_TYPE, Op, MsgBuffer);
+                    return_ACPI_STATUS (AE_OK);
+                }
+            }
+            else
+            {
+                /* Valid error, object already exists */
+
+                AslError (ASL_ERROR, ASL_MSG_NAME_EXISTS, Op,
+                    Op->Asl.ExternalName);
+                return_ACPI_STATUS (AE_OK);
+            }
+        }
+        else
+        {
+            AslCoreSubsystemError (Op, Status,
+                "Failure from namespace lookup", FALSE);
+            return_ACPI_STATUS (Status);
+        }
+    }
+
+    if (ForceNewScope)
+    {
+        Status = AcpiDsScopeStackPush (Node, ObjectType, WalkState);
+        if (ACPI_FAILURE (Status))
+        {
+            return_ACPI_STATUS (Status);
+        }
+    }
+
+FinishNode:
+    /*
+     * Point the parse node to the new namespace node, and point
+     * the Node back to the original Parse node
+     */
+    Op->Asl.Node = Node;
+    Node->Op = Op;
+
+    /* Set the actual data type if appropriate (EXTERNAL term only) */
+
+    if (ActualObjectType != ACPI_TYPE_ANY)
+    {
+        Node->Type = (UINT8) ActualObjectType;
+        Node->Value = ASL_EXTERNAL_METHOD;
+    }
+
+    if (Op->Asl.ParseOpcode == PARSEOP_METHOD)
+    {
+        /*
+         * Get the method argument count from "Extra" and save
+         * it in the namespace node
+         */
+        Node->Value = (UINT32) Op->Asl.Extra;
+    }
+
+    return_ACPI_STATUS (Status);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    LdNamespace2Begin
+ *
+ * PARAMETERS:  ASL_WALK_CALLBACK
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Descending callback used during the pass 2 parse tree walk.
+ *              Second pass resolves some forward references.
+ *
+ * Notes:
+ * Currently only needs to handle the Alias operator.
+ * Could be used to allow forward references from the Scope() operator, but
+ * the MS interpreter does not allow this, so this compiler does not either.
+ *
+ ******************************************************************************/
+
+static ACPI_STATUS
+LdNamespace2Begin (
+    ACPI_PARSE_OBJECT       *Op,
+    UINT32                  Level,
+    void                    *Context)
+{
+    ACPI_WALK_STATE         *WalkState = (ACPI_WALK_STATE *) Context;
+    ACPI_STATUS             Status;
+    ACPI_NAMESPACE_NODE     *Node;
+    ACPI_OBJECT_TYPE        ObjectType;
+    BOOLEAN                 ForceNewScope = FALSE;
+    ACPI_PARSE_OBJECT       *Arg;
+    char                    *Path;
+    ACPI_NAMESPACE_NODE     *TargetNode;
+
+
+    ACPI_FUNCTION_NAME (LdNamespace2Begin);
+    ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH, "Op %p [%s]\n",
+        Op, Op->Asl.ParseOpName));
+
+
+    /* Ignore Ops with no namespace node */
+
+    Node = Op->Asl.Node;
+    if (!Node)
+    {
+        return (AE_OK);
+    }
+
+    /* Get the type to determine if we should push the scope */
+
+    if ((Op->Asl.ParseOpcode == PARSEOP_DEFAULT_ARG) &&
+        (Op->Asl.CompileFlags == NODE_IS_RESOURCE_DESC))
+    {
+        ObjectType = ACPI_TYPE_LOCAL_RESOURCE;
+    }
+    else
+    {
+        ObjectType = AslMapNamedOpcodeToDataType (Op->Asl.AmlOpcode);
+    }
+
+    /* Push scope for Resource Templates */
+
+    if (Op->Asl.ParseOpcode == PARSEOP_NAME)
+    {
+        if (Op->Asl.CompileFlags & NODE_IS_RESOURCE_DESC)
+        {
+            ForceNewScope = TRUE;
+        }
+    }
+
+    /* Push the scope stack */
+
+    if (ForceNewScope || AcpiNsOpensScope (ObjectType))
+    {
+        Status = AcpiDsScopeStackPush (Node, ObjectType, WalkState);
+        if (ACPI_FAILURE (Status))
+        {
+            return_ACPI_STATUS (Status);
+        }
+    }
+
+    if (Op->Asl.ParseOpcode == PARSEOP_ALIAS)
+    {
+        /* Complete the alias node by getting and saving the target node */
+
+        /* First child is the alias target */
+
+        Arg = Op->Asl.Child;
+
+        /* Get the target pathname */
+
+        Path = Arg->Asl.Namepath;
+        if (!Path)
+        {
+            Status = UtInternalizeName (Arg->Asl.ExternalName, &Path);
+            if (ACPI_FAILURE (Status))
+            {
+                return (Status);
+            }
+        }
+
+        /* Get the NS node associated with the target. It must exist. */
+
+        Status = AcpiNsLookup (WalkState->ScopeInfo, Path, ACPI_TYPE_ANY,
+            ACPI_IMODE_EXECUTE, ACPI_NS_SEARCH_PARENT | ACPI_NS_DONT_OPEN_SCOPE,
+            WalkState, &TargetNode);
+        if (ACPI_FAILURE (Status))
+        {
+            if (Status == AE_NOT_FOUND)
+            {
+                AslError (ASL_ERROR, ASL_MSG_NOT_FOUND, Op,
+                    Op->Asl.ExternalName);
+
+                /*
+                 * The name was not found, go ahead and create it.
+                 * This prevents more errors later.
+                 */
+                Status = AcpiNsLookup (WalkState->ScopeInfo, Path,
+                    ACPI_TYPE_ANY,
+                    ACPI_IMODE_LOAD_PASS1, ACPI_NS_NO_UPSEARCH,
+                    WalkState, &(Node));
+                return (AE_OK);
+            }
+
+            AslCoreSubsystemError (Op, Status,
+                "Failure from namespace lookup", FALSE);
+            return (AE_OK);
+        }
+
+        /* Save the target node within the alias node */
+
+        Node->Object = ACPI_CAST_PTR (ACPI_OPERAND_OBJECT, TargetNode);
+    }
+
+    return (AE_OK);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    LdCommonNamespaceEnd
+ *
+ * PARAMETERS:  ASL_WALK_CALLBACK
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Ascending callback used during the loading of the namespace,
+ *              We only need to worry about managing the scope stack here.
+ *
+ ******************************************************************************/
+
+static ACPI_STATUS
+LdCommonNamespaceEnd (
+    ACPI_PARSE_OBJECT       *Op,
+    UINT32                  Level,
+    void                    *Context)
+{
+    ACPI_WALK_STATE         *WalkState = (ACPI_WALK_STATE *) Context;
+    ACPI_OBJECT_TYPE        ObjectType;
+    BOOLEAN                 ForceNewScope = FALSE;
+
+
+    ACPI_FUNCTION_NAME (LdCommonNamespaceEnd);
+
+
+    /* We are only interested in opcodes that have an associated name */
+
+    if (!Op->Asl.Namepath)
+    {
+        return (AE_OK);
+    }
+
+    /* Get the type to determine if we should pop the scope */
+
+    if ((Op->Asl.ParseOpcode == PARSEOP_DEFAULT_ARG) &&
+        (Op->Asl.CompileFlags == NODE_IS_RESOURCE_DESC))
+    {
+        /* TBD: Merge into AcpiDsMapNamedOpcodeToDataType */
+
+        ObjectType = ACPI_TYPE_LOCAL_RESOURCE;
+    }
+    else
+    {
+        ObjectType = AslMapNamedOpcodeToDataType (Op->Asl.AmlOpcode);
+    }
+
+    /* Pop scope that was pushed for Resource Templates */
+
+    if (Op->Asl.ParseOpcode == PARSEOP_NAME)
+    {
+        if (Op->Asl.CompileFlags & NODE_IS_RESOURCE_DESC)
+        {
+            ForceNewScope = TRUE;
+        }
+    }
+
+    /* Pop the scope stack */
+
+    if (ForceNewScope || AcpiNsOpensScope (ObjectType))
+    {
+        ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH,
+            "(%s): Popping scope for Op [%s] %p\n",
+            AcpiUtGetTypeName (ObjectType), Op->Asl.ParseOpName, Op));
+
+        (void) AcpiDsScopeStackPop (WalkState);
+    }
+
+    return (AE_OK);
+}
diff --git a/usr/src/cmd/acpi/iasl/asllookup.c b/usr/src/cmd/acpi/iasl/asllookup.c
new file mode 100644
index 0000000000..fed35fd787
--- /dev/null
+++ b/usr/src/cmd/acpi/iasl/asllookup.c
@@ -0,0 +1,315 @@
+/******************************************************************************
+ *
+ * Module Name: asllookup- Namespace lookup functions
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2016, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include "aslcompiler.h"
+#include "aslcompiler.y.h"
+#include "acparser.h"
+#include "amlcode.h"
+#include "acnamesp.h"
+#include "acdispat.h"
+
+
+#define _COMPONENT          ACPI_COMPILER
+        ACPI_MODULE_NAME    ("asllookup")
+
+/* Local prototypes */
+
+static ACPI_STATUS
+LkIsObjectUsed (
+    ACPI_HANDLE             ObjHandle,
+    UINT32                  Level,
+    void                    *Context,
+    void                    **ReturnValue);
+
+static ACPI_PARSE_OBJECT *
+LkGetNameOp (
+    ACPI_PARSE_OBJECT       *Op);
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    LkFindUnreferencedObjects
+ *
+ * PARAMETERS:  None
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Namespace walk to find objects that are not referenced in any
+ *              way. Must be called after the namespace has been cross
+ *              referenced.
+ *
+ ******************************************************************************/
+
+void
+LkFindUnreferencedObjects (
+    void)
+{
+
+    /* Walk entire namespace from the supplied root */
+
+    (void) AcpiNsWalkNamespace (ACPI_TYPE_ANY, ACPI_ROOT_OBJECT,
+                ACPI_UINT32_MAX, FALSE, LkIsObjectUsed, NULL,
+                NULL, NULL);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    LkIsObjectUsed
+ *
+ * PARAMETERS:  ACPI_WALK_CALLBACK
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Check for an unreferenced namespace object and emit a warning.
+ *              We have to be careful, because some types and names are
+ *              typically or always unreferenced, we don't want to issue
+ *              excessive warnings. Note: Names that are declared within a
+ *              control method are temporary, so we always issue a remark
+ *              if they are not referenced.
+ *
+ ******************************************************************************/
+
+static ACPI_STATUS
+LkIsObjectUsed (
+    ACPI_HANDLE             ObjHandle,
+    UINT32                  Level,
+    void                    *Context,
+    void                    **ReturnValue)
+{
+    ACPI_NAMESPACE_NODE     *Node = ACPI_CAST_PTR (ACPI_NAMESPACE_NODE, ObjHandle);
+    ACPI_NAMESPACE_NODE     *Next;
+    ASL_METHOD_LOCAL        *MethodLocals;
+    ASL_METHOD_LOCAL        *MethodArgs;
+    UINT32                  i;
+
+
+    if (Node->Type == ACPI_TYPE_METHOD)
+    {
+        if (!Node->Op || !Node->MethodLocals)
+        {
+            return (AE_OK);
+        }
+
+        MethodLocals = (ASL_METHOD_LOCAL *) Node->MethodLocals;
+        MethodArgs = (ASL_METHOD_LOCAL *) Node->MethodArgs;
+
+        /*
+         * Analysis of LocalX variables
+         */
+        for (i = 0; i < ACPI_METHOD_NUM_LOCALS; i++)
+        {
+            /* Warn for Locals that are set but never referenced */
+
+            if ((MethodLocals[i].Flags & ASL_LOCAL_INITIALIZED) &&
+                (!(MethodLocals[i].Flags & ASL_LOCAL_REFERENCED)))
+            {
+                sprintf (MsgBuffer, "Local%u", i);
+                AslError (ASL_WARNING, ASL_MSG_LOCAL_NOT_USED,
+                    MethodLocals[i].Op, MsgBuffer);
+            }
+        }
+
+        /*
+         * Analysis of ArgX variables (standard method arguments,
+         * and remaining unused ArgX can also be used as locals)
+         */
+        for (i = 0; i < ACPI_METHOD_NUM_ARGS; i++)
+        {
+            if (MethodArgs[i].Flags & ASL_ARG_IS_LOCAL)
+            {
+                /* Warn if ArgX is being used as a local, but not referenced */
+
+                if ((MethodArgs[i].Flags & ASL_ARG_INITIALIZED) &&
+                    (!(MethodArgs[i].Flags & ASL_ARG_REFERENCED)))
+                {
+                    sprintf (MsgBuffer, "Arg%u", i);
+                    AslError (ASL_WARNING, ASL_MSG_ARG_AS_LOCAL_NOT_USED,
+                        MethodArgs[i].Op, MsgBuffer);
+                }
+            }
+            else
+            {
+                /*
+                 * Remark if a normal method ArgX is not referenced.
+                 * We ignore the predefined methods since often, not
+                 * all arguments are needed or used.
+                 */
+                if ((Node->Name.Ascii[0] != '_') &&
+                    (!(MethodArgs[i].Flags & ASL_ARG_REFERENCED)))
+                {
+                    sprintf (MsgBuffer, "Arg%u", i);
+                    AslError (ASL_REMARK, ASL_MSG_ARG_NOT_USED,
+                        MethodArgs[i].Op, MsgBuffer);
+                }
+            }
+        }
+    }
+
+    /* Referenced flag is set during the namespace xref */
+
+    if (Node->Flags & ANOBJ_IS_REFERENCED)
+    {
+        return (AE_OK);
+    }
+
+    if (!Node->Op)
+    {
+        return (AE_OK);
+    }
+
+    /* These types are typically never directly referenced, ignore them */
+
+    switch (Node->Type)
+    {
+    case ACPI_TYPE_DEVICE:
+    case ACPI_TYPE_PROCESSOR:
+    case ACPI_TYPE_POWER:
+    case ACPI_TYPE_THERMAL:
+    case ACPI_TYPE_LOCAL_RESOURCE:
+    case ACPI_TYPE_LOCAL_RESOURCE_FIELD: /* Names assigned to descriptor elements */
+
+        return (AE_OK);
+
+    default:
+
+        break;
+    }
+
+    /* Determine if the name is within a control method */
+
+    Next = Node->Parent;
+    while (Next)
+    {
+        if (Next->Type == ACPI_TYPE_METHOD)
+        {
+            /*
+             * Name is within a method, therefore it is temporary.
+             * Issue a remark even if it is a reserved name (starts
+             * with an underscore).
+             */
+            sprintf (MsgBuffer, "Name [%4.4s] is within a method [%4.4s]",
+                Node->Name.Ascii, Next->Name.Ascii);
+            AslError (ASL_REMARK, ASL_MSG_NOT_REFERENCED,
+                LkGetNameOp (Node->Op), MsgBuffer);
+            return (AE_OK);
+        }
+
+        Next = Next->Parent;
+    }
+
+    /* The name is not within a control method */
+
+    /*
+     * Ignore names that start with an underscore. These are the reserved
+     * ACPI names and are typically not referenced since they are meant
+     * to be called by the host OS.
+     */
+    if (Node->Name.Ascii[0] == '_')
+    {
+        return (AE_OK);
+    }
+
+    /*
+     * What remains is an unresolved user name that is not within a method.
+     * However, the object could be referenced via another table, so issue
+     * the warning at level 2.
+     */
+    AslError (ASL_WARNING2, ASL_MSG_NOT_REFERENCED,
+        LkGetNameOp (Node->Op), NULL);
+    return (AE_OK);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    LkGetNameOp
+ *
+ * PARAMETERS:  Op              - Current Op
+ *
+ * RETURN:      NameOp associated with the input op
+ *
+ * DESCRIPTION: Find the name declaration op associated with the operator
+ *
+ ******************************************************************************/
+
+static ACPI_PARSE_OBJECT *
+LkGetNameOp (
+    ACPI_PARSE_OBJECT       *Op)
+{
+    const ACPI_OPCODE_INFO  *OpInfo;
+    ACPI_PARSE_OBJECT       *NameOp = Op;
+
+
+    OpInfo = AcpiPsGetOpcodeInfo (Op->Asl.AmlOpcode);
+
+
+    /* Get the NamePath from the appropriate place */
+
+    if (OpInfo->Flags & AML_NAMED)
+    {
+        /* For nearly all NAMED operators, the name reference is the first child */
+
+        NameOp = Op->Asl.Child;
+        if (Op->Asl.AmlOpcode == AML_ALIAS_OP)
+        {
+            /*
+             * ALIAS is the only oddball opcode, the name declaration
+             * (alias name) is the second operand
+             */
+            NameOp = Op->Asl.Child->Asl.Next;
+        }
+    }
+    else if (OpInfo->Flags & AML_CREATE)
+    {
+        /* Name must appear as the last parameter */
+
+        NameOp = Op->Asl.Child;
+        while (!(NameOp->Asl.CompileFlags & NODE_IS_NAME_DECLARATION))
+        {
+            NameOp = NameOp->Asl.Next;
+        }
+    }
+
+    return (NameOp);
+}
diff --git a/usr/src/cmd/acpi/iasl/aslmain.c b/usr/src/cmd/acpi/iasl/aslmain.c
new file mode 100644
index 0000000000..064e790a59
--- /dev/null
+++ b/usr/src/cmd/acpi/iasl/aslmain.c
@@ -0,0 +1,403 @@
+/******************************************************************************
+ *
+ * Module Name: aslmain - compiler main and utilities
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2016, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#define _DECLARE_GLOBALS
+
+#include "aslcompiler.h"
+#include "acapps.h"
+#include "acdisasm.h"
+#include <signal.h>
+
+#define _COMPONENT          ACPI_COMPILER
+        ACPI_MODULE_NAME    ("aslmain")
+
+/*
+ * Main routine for the iASL compiler.
+ *
+ * Portability note: The compiler depends upon the host for command-line
+ * wildcard support - it is not implemented locally. For example:
+ *
+ * Linux/Unix systems: Shell expands wildcards automatically.
+ *
+ * Windows: The setargv.obj module must be linked in to automatically
+ * expand wildcards.
+ */
+
+/* Local prototypes */
+
+static void ACPI_SYSTEM_XFACE
+AslSignalHandler (
+    int                     Sig);
+
+static void
+AslInitialize (
+    void);
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    Usage
+ *
+ * PARAMETERS:  None
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Display option help message.
+ *              Optional items in square brackets.
+ *
+ ******************************************************************************/
+
+void
+Usage (
+    void)
+{
+    printf ("%s\n\n", ASL_COMPLIANCE);
+    ACPI_USAGE_HEADER ("iasl [Options] [Files]");
+
+    printf ("\nGeneral:\n");
+    ACPI_OPTION ("-@ <file>",       "Specify command file");
+    ACPI_OPTION ("-I <dir>",        "Specify additional include directory");
+    ACPI_OPTION ("-T <sig list>|ALL",   "Create ACPI table template/example files");
+    ACPI_OPTION ("-T <count>",      "Emit DSDT and <count> SSDTs to same file");
+    ACPI_OPTION ("-p <prefix>",     "Specify path/filename prefix for all output files");
+    ACPI_OPTION ("-v",              "Display compiler version");
+    ACPI_OPTION ("-vo",             "Enable optimization comments");
+    ACPI_OPTION ("-vs",             "Disable signon");
+
+    printf ("\nHelp:\n");
+    ACPI_OPTION ("-h",              "This message");
+    ACPI_OPTION ("-hc",             "Display operators allowed in constant expressions");
+    ACPI_OPTION ("-hf",             "Display help for output filename generation");
+    ACPI_OPTION ("-hr",             "Display ACPI reserved method names");
+    ACPI_OPTION ("-ht",             "Display currently supported ACPI table names");
+
+    printf ("\nPreprocessor:\n");
+    ACPI_OPTION ("-D <symbol>",     "Define symbol for preprocessor use");
+    ACPI_OPTION ("-li",             "Create preprocessed output file (*.i)");
+    ACPI_OPTION ("-P",              "Preprocess only and create preprocessor output file (*.i)");
+    ACPI_OPTION ("-Pn",             "Disable preprocessor");
+
+    printf ("\nErrors, Warnings, and Remarks:\n");
+    ACPI_OPTION ("-va",             "Disable all errors/warnings/remarks");
+    ACPI_OPTION ("-ve",             "Report only errors (ignore warnings and remarks)");
+    ACPI_OPTION ("-vi",             "Less verbose errors and warnings for use with IDEs");
+    ACPI_OPTION ("-vr",             "Disable remarks");
+    ACPI_OPTION ("-vw <messageid>", "Disable specific warning or remark");
+    ACPI_OPTION ("-w1 -w2 -w3",     "Set warning reporting level");
+    ACPI_OPTION ("-we",             "Report warnings as errors");
+
+    printf ("\nAML Code Generation (*.aml):\n");
+    ACPI_OPTION ("-oa",             "Disable all optimizations (compatibility mode)");
+    ACPI_OPTION ("-of",             "Disable constant folding");
+    ACPI_OPTION ("-oi",             "Disable integer optimization to Zero/One/Ones");
+    ACPI_OPTION ("-on",             "Disable named reference string optimization");
+    ACPI_OPTION ("-ot",             "Disable typechecking");
+    ACPI_OPTION ("-cr",             "Disable Resource Descriptor error checking");
+    ACPI_OPTION ("-in",             "Ignore NoOp operators");
+    ACPI_OPTION ("-r <revision>",   "Override table header Revision (1-255)");
+
+    printf ("\nOptional Source Code Output Files:\n");
+    ACPI_OPTION ("-sc -sa",         "Create source file in C or assembler (*.c or *.asm)");
+    ACPI_OPTION ("-ic -ia",         "Create include file in C or assembler (*.h or *.inc)");
+    ACPI_OPTION ("-tc -ta -ts",     "Create hex AML table in C, assembler, or ASL (*.hex)");
+    ACPI_OPTION ("-so",             "Create offset table in C (*.offset.h)");
+
+    printf ("\nOptional Listing Files:\n");
+    ACPI_OPTION ("-l",              "Create mixed listing file (ASL source and AML) (*.lst)");
+    ACPI_OPTION ("-lm",             "Create hardware summary map file (*.map)");
+    ACPI_OPTION ("-ln",             "Create namespace file (*.nsp)");
+    ACPI_OPTION ("-ls",             "Create combined source file (expanded includes) (*.src)");
+    ACPI_OPTION ("-lx",             "Create cross-reference file (*.xrf)");
+
+    printf ("\nData Table Compiler:\n");
+    ACPI_OPTION ("-G",              "Compile custom table that contains generic operators");
+    ACPI_OPTION ("-vt",             "Create verbose template files (full disassembly)");
+
+    printf ("\nAML Disassembler:\n");
+    ACPI_OPTION ("-d  <f1 f2 ...>", "Disassemble or decode binary ACPI tables to file (*.dsl)");
+    ACPI_OPTION ("",                "  (Optional, file type is automatically detected)");
+    ACPI_OPTION ("-da <f1 f2 ...>", "Disassemble multiple tables from single namespace");
+    ACPI_OPTION ("-db",             "Do not translate Buffers to Resource Templates");
+    ACPI_OPTION ("-dc <f1 f2 ...>", "Disassemble AML and immediately compile it");
+    ACPI_OPTION ("",                "  (Obtain DSDT from current system if no input file)");
+    ACPI_OPTION ("-df",             "Force disassembler to assume table contains valid AML");
+    ACPI_OPTION ("-dl",             "Emit legacy ASL code only (no C-style operators)");
+    ACPI_OPTION ("-e  <f1 f2 ...>", "Include ACPI table(s) for external symbol resolution");
+    ACPI_OPTION ("-fe <file>",      "Specify external symbol declaration file");
+    ACPI_OPTION ("-in",             "Ignore NoOp opcodes");
+    ACPI_OPTION ("-l",              "Disassemble to mixed ASL and AML code");
+    ACPI_OPTION ("-vt",             "Dump binary table data in hex format within output file");
+
+    printf ("\nDebug Options:\n");
+    ACPI_OPTION ("-bf",             "Create debug file (full output) (*.txt)");
+    ACPI_OPTION ("-bs",             "Create debug file (parse tree only) (*.txt)");
+    ACPI_OPTION ("-bp <depth>",     "Prune ASL parse tree");
+    ACPI_OPTION ("-bt <type>",      "Object type to be pruned from the parse tree");
+    ACPI_OPTION ("-f",              "Ignore errors, force creation of AML output file(s)");
+    ACPI_OPTION ("-m <size>",       "Set internal line buffer size (in Kbytes)");
+    ACPI_OPTION ("-n",              "Parse only, no output generation");
+    ACPI_OPTION ("-oc",             "Display compile times and statistics");
+    ACPI_OPTION ("-x <level>",      "Set debug level for trace output");
+    ACPI_OPTION ("-z",              "Do not insert new compiler ID for DataTables");
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    FilenameHelp
+ *
+ * PARAMETERS:  None
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Display help message for output filename generation
+ *
+ ******************************************************************************/
+
+void
+AslFilenameHelp (
+    void)
+{
+
+    printf ("\nAML output filename generation:\n");
+    printf ("  Output filenames are generated by appending an extension to a common\n");
+    printf ("  filename prefix. The filename prefix is obtained via one of the\n");
+    printf ("  following methods (in priority order):\n");
+    printf ("    1) The -p option specifies the prefix\n");
+    printf ("    2) The prefix of the AMLFileName in the ASL Definition Block\n");
+    printf ("    3) The prefix of the input filename\n");
+    printf ("\n");
+}
+
+
+/******************************************************************************
+ *
+ * FUNCTION:    AslSignalHandler
+ *
+ * PARAMETERS:  Sig                 - Signal that invoked this handler
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Control-C handler. Delete any intermediate files and any
+ *              output files that may be left in an indeterminate state.
+ *
+ *****************************************************************************/
+
+static void ACPI_SYSTEM_XFACE
+AslSignalHandler (
+    int                     Sig)
+{
+    UINT32                  i;
+
+
+    signal (Sig, SIG_IGN);
+    printf ("Aborting\n\n");
+
+    /* Close all open files */
+
+    Gbl_Files[ASL_FILE_PREPROCESSOR].Handle = NULL; /* the .pre file is same as source file */
+
+    for (i = ASL_FILE_INPUT; i < ASL_MAX_FILE_TYPE; i++)
+    {
+        FlCloseFile (i);
+    }
+
+    /* Delete any output files */
+
+    for (i = ASL_FILE_AML_OUTPUT; i < ASL_MAX_FILE_TYPE; i++)
+    {
+        FlDeleteFile (i);
+    }
+
+    exit (0);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AslInitialize
+ *
+ * PARAMETERS:  None
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Initialize compiler globals
+ *
+ ******************************************************************************/
+
+static void
+AslInitialize (
+    void)
+{
+    UINT32                  i;
+
+
+    AcpiGbl_DmOpt_Verbose = FALSE;
+
+    /* Default integer width is 64 bits */
+
+    AcpiGbl_IntegerBitWidth = 64;
+    AcpiGbl_IntegerNybbleWidth = 16;
+    AcpiGbl_IntegerByteWidth = 8;
+
+    for (i = 0; i < ASL_NUM_FILES; i++)
+    {
+        Gbl_Files[i].Handle = NULL;
+        Gbl_Files[i].Filename = NULL;
+    }
+
+    Gbl_Files[ASL_FILE_STDOUT].Handle   = stdout;
+    Gbl_Files[ASL_FILE_STDOUT].Filename = "STDOUT";
+
+    Gbl_Files[ASL_FILE_STDERR].Handle   = stderr;
+    Gbl_Files[ASL_FILE_STDERR].Filename = "STDERR";
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    main
+ *
+ * PARAMETERS:  Standard argc/argv
+ *
+ * RETURN:      Program termination code
+ *
+ * DESCRIPTION: C main routine for the Asl Compiler. Handle command line
+ *              options and begin the compile for each file on the command line
+ *
+ ******************************************************************************/
+
+int ACPI_SYSTEM_XFACE
+main (
+    int                     argc,
+    char                    **argv)
+{
+    ACPI_STATUS             Status;
+    int                     Index1;
+    int                     Index2;
+    int                     ReturnStatus = 0;
+
+
+    /*
+     * Big-endian machines are not currently supported. ACPI tables must
+     * be little-endian, and support for big-endian machines needs to
+     * be implemented.
+     */
+    if (UtIsBigEndianMachine ())
+    {
+        fprintf (stderr,
+            "iASL is not currently supported on big-endian machines.\n");
+        return (-1);
+    }
+
+    AcpiOsInitialize ();
+    ACPI_DEBUG_INITIALIZE (); /* For debug version only */
+
+    /* Initialize preprocessor and compiler before command line processing */
+
+    signal (SIGINT, AslSignalHandler);
+    AcpiGbl_ExternalFileList = NULL;
+    AcpiDbgLevel = 0;
+    PrInitializePreprocessor ();
+    AslInitialize ();
+
+    Index1 = Index2 = AslCommandLine (argc, argv);
+
+    /* Allocate the line buffer(s), must be after command line */
+
+    Gbl_LineBufferSize /= 2;
+    UtExpandLineBuffers ();
+
+    /* Perform global actions first/only */
+
+    if (Gbl_DisassembleAll)
+    {
+        while (argv[Index1])
+        {
+            Status = AcpiDmAddToExternalFileList (argv[Index1]);
+            if (ACPI_FAILURE (Status))
+            {
+                return (-1);
+            }
+
+            Index1++;
+        }
+    }
+
+    /* Process each pathname/filename in the list, with possible wildcards */
+
+    while (argv[Index2])
+    {
+        /*
+         * If -p not specified, we will use the input filename as the
+         * output filename prefix
+         */
+        if (Gbl_UseDefaultAmlFilename)
+        {
+            Gbl_OutputFilenamePrefix = argv[Index2];
+            UtConvertBackslashes (Gbl_OutputFilenamePrefix);
+        }
+
+        Status = AslDoOneFile (argv[Index2]);
+        if (ACPI_FAILURE (Status))
+        {
+            ReturnStatus = -1;
+            goto CleanupAndExit;
+        }
+
+        Index2++;
+    }
+
+
+CleanupAndExit:
+
+    UtFreeLineBuffers ();
+    AslParserCleanup ();
+
+    if (AcpiGbl_ExternalFileList)
+    {
+        AcpiDmClearExternalFileList();
+    }
+
+    return (ReturnStatus);
+}
diff --git a/usr/src/cmd/acpi/iasl/aslmap.c b/usr/src/cmd/acpi/iasl/aslmap.c
new file mode 100644
index 0000000000..78756216a6
--- /dev/null
+++ b/usr/src/cmd/acpi/iasl/aslmap.c
@@ -0,0 +1,488 @@
+/******************************************************************************
+ *
+ * Module Name: aslmap - parser to AML opcode mapping table
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2016, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include "aslcompiler.h"
+#include "amlcode.h"
+#include "acparser.h"
+
+
+#define _COMPONENT          ACPI_COMPILER
+        ACPI_MODULE_NAME    ("aslmap")
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AslMapNamedOpcodeToDataType
+ *
+ * PARAMETERS:  Opcode              - The Named AML opcode to map
+ *
+ * RETURN:      The ACPI type associated with the named opcode
+ *
+ * DESCRIPTION: Convert a raw Named AML opcode to the associated data type.
+ *              Named opcodes are a subset of the AML opcodes.
+ *
+ ******************************************************************************/
+
+ACPI_OBJECT_TYPE
+AslMapNamedOpcodeToDataType (
+    UINT16                  Opcode)
+{
+    const ACPI_OPCODE_INFO  *OpInfo;
+
+
+    /*
+     * There are some differences from the opcode table types, we
+     * catch them here.
+     */
+    OpInfo = AcpiPsGetOpcodeInfo (Opcode);
+
+    if (Opcode == AML_INT_NAMEPATH_OP)
+    {
+        return (ACPI_TYPE_ANY);
+    }
+
+    if (Opcode == AML_INT_METHODCALL_OP)
+    {
+        return (ACPI_TYPE_ANY);
+    }
+
+    if (OpInfo->Flags & AML_NSOBJECT)
+    {
+        return (OpInfo->ObjectType);
+    }
+
+    return (ACPI_TYPE_ANY);
+}
+
+
+/*******************************************************************************
+ *
+ * DATA STRUCTURE:  AslKeywordMapping
+ *
+ * DESCRIPTION:     Maps the ParseOpcode to the actual AML opcode. The parse
+ *                  opcodes are generated from Bison, and this table must
+ *                  track any additions to them.
+ *
+ * Each entry in the table contains the following items:
+ *
+ * AML opcode   - Opcode that is written to the AML file
+ * Value        - Value of the object to be written (if applicable)
+ * Flags        - 1) Whether this opcode opens an AML "package".
+ *
+ ******************************************************************************/
+/*
+ * TBD:
+ * AccessAttrib
+ * AccessType
+ * AMlop for DMA?
+ * ObjectType keywords
+ * Register
+ */
+
+const ASL_MAPPING_ENTRY     AslKeywordMapping [] =
+{
+/*! [Begin] no source code translation (keep the table structure) */
+
+                                            /*  AML Opcode                  Value                           Flags               Btype */
+
+/* ACCESSAS */                  OP_TABLE_ENTRY (AML_INT_ACCESSFIELD_OP,     0,                              0,                  0),
+/* ACCESSATTRIB_BLOCK */        OP_TABLE_ENTRY (AML_BYTE_OP,                AML_FIELD_ATTRIB_BLOCK,         0,                  0),
+/* ACCESSATTRIB_BLOCK_CALL */   OP_TABLE_ENTRY (AML_BYTE_OP,                AML_FIELD_ATTRIB_BLOCK_CALL,    0,                  0),
+/* ACCESSATTRIB_BYTE */         OP_TABLE_ENTRY (AML_BYTE_OP,                AML_FIELD_ATTRIB_BYTE,          0,                  0),
+/* ACCESSATTRIB_MULTIBYTE */    OP_TABLE_ENTRY (AML_BYTE_OP,                AML_FIELD_ATTRIB_MULTIBYTE,     0,                  0),
+/* ACCESSATTRIB_QUICK */        OP_TABLE_ENTRY (AML_BYTE_OP,                AML_FIELD_ATTRIB_QUICK,         0,                  0),
+/* ACCESSATTRIB_RAW_BYTES */    OP_TABLE_ENTRY (AML_BYTE_OP,                AML_FIELD_ATTRIB_RAW_BYTES,     0,                  0),
+/* ACCESSATTRIB_RAW_PROCESS */  OP_TABLE_ENTRY (AML_BYTE_OP,                AML_FIELD_ATTRIB_RAW_PROCESS,   0,                  0),
+/* ACCESSATTRIB_SND_RCV */      OP_TABLE_ENTRY (AML_BYTE_OP,                AML_FIELD_ATTRIB_SEND_RCV,      0,                  0),
+/* ACCESSATTRIB_WORD */         OP_TABLE_ENTRY (AML_BYTE_OP,                AML_FIELD_ATTRIB_WORD,          0,                  0),
+/* ACCESSATTRIB_WORD_CALL */    OP_TABLE_ENTRY (AML_BYTE_OP,                AML_FIELD_ATTRIB_WORD_CALL,     0,                  0),
+/* ACCESSTYPE_ANY */            OP_TABLE_ENTRY (AML_BYTE_OP,                AML_FIELD_ACCESS_ANY,           0,                  0),
+/* ACCESSTYPE_BUF */            OP_TABLE_ENTRY (AML_BYTE_OP,                AML_FIELD_ACCESS_BUFFER,        0,                  0),
+/* ACCESSTYPE_BYTE */           OP_TABLE_ENTRY (AML_BYTE_OP,                AML_FIELD_ACCESS_BYTE,          0,                  0),
+/* ACCESSTYPE_DWORD */          OP_TABLE_ENTRY (AML_BYTE_OP,                AML_FIELD_ACCESS_DWORD,         0,                  0),
+/* ACCESSTYPE_QWORD */          OP_TABLE_ENTRY (AML_BYTE_OP,                AML_FIELD_ACCESS_QWORD,         0,                  0),
+/* ACCESSTYPE_WORD */           OP_TABLE_ENTRY (AML_BYTE_OP,                AML_FIELD_ACCESS_WORD,          0,                  0),
+/* ACQUIRE */                   OP_TABLE_ENTRY (AML_ACQUIRE_OP,             0,                              0,                  ACPI_BTYPE_INTEGER),
+/* ADD */                       OP_TABLE_ENTRY (AML_ADD_OP,                 0,                              0,                  ACPI_BTYPE_INTEGER),
+/* ADDRESSINGMODE_7BIT */       OP_TABLE_ENTRY (AML_BYTE_OP,                0,                              0,                  0),
+/* ADDRESSINGMODE_10BIT */      OP_TABLE_ENTRY (AML_BYTE_OP,                1,                              0,                  0),
+/* ADDRESSTYPE_ACPI */          OP_TABLE_ENTRY (AML_BYTE_OP,                2,                              0,                  0),
+/* ADDRESSTYPE_MEMORY */        OP_TABLE_ENTRY (AML_BYTE_OP,                0,                              0,                  0),
+/* ADDRESSTYPE_NVS */           OP_TABLE_ENTRY (AML_BYTE_OP,                3,                              0,                  0),
+/* ADDRESSTYPE_RESERVED */      OP_TABLE_ENTRY (AML_BYTE_OP,                1,                              0,                  0),
+/* ALIAS */                     OP_TABLE_ENTRY (AML_ALIAS_OP,               0,                              0,                  0),
+/* AND */                       OP_TABLE_ENTRY (AML_BIT_AND_OP,             0,                              0,                  ACPI_BTYPE_INTEGER),
+/* ARG0 */                      OP_TABLE_ENTRY (AML_ARG0,                   0,                              0,                  ACPI_BTYPE_OBJECTS_AND_REFS),
+/* ARG1 */                      OP_TABLE_ENTRY (AML_ARG1,                   0,                              0,                  ACPI_BTYPE_OBJECTS_AND_REFS),
+/* ARG2 */                      OP_TABLE_ENTRY (AML_ARG2,                   0,                              0,                  ACPI_BTYPE_OBJECTS_AND_REFS),
+/* ARG3 */                      OP_TABLE_ENTRY (AML_ARG3,                   0,                              0,                  ACPI_BTYPE_OBJECTS_AND_REFS),
+/* ARG4 */                      OP_TABLE_ENTRY (AML_ARG4,                   0,                              0,                  ACPI_BTYPE_OBJECTS_AND_REFS),
+/* ARG5 */                      OP_TABLE_ENTRY (AML_ARG5,                   0,                              0,                  ACPI_BTYPE_OBJECTS_AND_REFS),
+/* ARG6 */                      OP_TABLE_ENTRY (AML_ARG6,                   0,                              0,                  ACPI_BTYPE_OBJECTS_AND_REFS),
+/* BANKFIELD */                 OP_TABLE_ENTRY (AML_BANK_FIELD_OP,          0,                              NODE_AML_PACKAGE,   0),
+/* BITSPERBYTE_EIGHT */         OP_TABLE_ENTRY (AML_BYTE_OP,                3,                              0,                  0),
+/* BITSPERBYTE_FIVE */          OP_TABLE_ENTRY (AML_BYTE_OP,                0,                              0,                  0),
+/* BITSPERBYTE_NINE */          OP_TABLE_ENTRY (AML_BYTE_OP,                4,                              0,                  0),
+/* BITSPERBYTE_SEVEN */         OP_TABLE_ENTRY (AML_BYTE_OP,                2,                              0,                  0),
+/* BITSPERBYTE_SIX */           OP_TABLE_ENTRY (AML_BYTE_OP,                1,                              0,                  0),
+/* BREAK */                     OP_TABLE_ENTRY (AML_BREAK_OP,               0,                              0,                  0),
+/* BREAKPOINT */                OP_TABLE_ENTRY (AML_BREAK_POINT_OP,         0,                              0,                  0),
+/* BUFFER */                    OP_TABLE_ENTRY (AML_BUFFER_OP,              0,                              NODE_AML_PACKAGE,   ACPI_BTYPE_BUFFER),
+/* BUSMASTERTYPE_MASTER */      OP_TABLE_ENTRY (AML_BYTE_OP,                1,                              0,                  0),
+/* BUSMASTERTYPE_NOTMASTER */   OP_TABLE_ENTRY (AML_BYTE_OP,                0,                              0,                  0),
+/* BYTECONST */                 OP_TABLE_ENTRY (AML_RAW_DATA_BYTE,          0,                              0,                  ACPI_BTYPE_INTEGER),
+/* CASE */                      OP_TABLE_ENTRY (AML_DEFAULT_ARG_OP,         0,                              0,                  0),
+/* CLOCKPHASE_FIRST */          OP_TABLE_ENTRY (AML_BYTE_OP,                0,                              0,                  0),
+/* CLOCKPHASE_SECOND */         OP_TABLE_ENTRY (AML_BYTE_OP,                1,                              0,                  0),
+/* CLOCKPOLARITY_HIGH */        OP_TABLE_ENTRY (AML_BYTE_OP,                1,                              0,                  0),
+/* CLOCKPOLARITY_LOW */         OP_TABLE_ENTRY (AML_BYTE_OP,                0,                              0,                  0),
+/* CONCATENATE */               OP_TABLE_ENTRY (AML_CONCAT_OP,              0,                              0,                  ACPI_BTYPE_COMPUTE_DATA),
+/* CONCATENATERESTEMPLATE */    OP_TABLE_ENTRY (AML_CONCAT_RES_OP,          0,                              0,                  ACPI_BTYPE_BUFFER),
+/* CONDREFOF */                 OP_TABLE_ENTRY (AML_COND_REF_OF_OP,         0,                              0,                  ACPI_BTYPE_INTEGER),
+/* CONNECTION */                OP_TABLE_ENTRY (AML_INT_CONNECTION_OP,      0,                              0,                  0),
+/* CONTINUE */                  OP_TABLE_ENTRY (AML_CONTINUE_OP,            0,                              0,                  0),
+/* COPY */                      OP_TABLE_ENTRY (AML_COPY_OP,                0,                              0,                  ACPI_BTYPE_DATA_REFERENCE),
+/* CREATEBITFIELD */            OP_TABLE_ENTRY (AML_CREATE_BIT_FIELD_OP,    0,                              0,                  0),
+/* CREATEBYTEFIELD */           OP_TABLE_ENTRY (AML_CREATE_BYTE_FIELD_OP,   0,                              0,                  0),
+/* CREATEDWORDFIELD */          OP_TABLE_ENTRY (AML_CREATE_DWORD_FIELD_OP,  0,                              0,                  0),
+/* CREATEFIELD */               OP_TABLE_ENTRY (AML_CREATE_FIELD_OP,        0,                              0,                  0),
+/* CREATEQWORDFIELD */          OP_TABLE_ENTRY (AML_CREATE_QWORD_FIELD_OP,  0,                              0,                  0),
+/* CREATEWORDFIELD */           OP_TABLE_ENTRY (AML_CREATE_WORD_FIELD_OP,   0,                              0,                  0),
+/* DATABUFFER */                OP_TABLE_ENTRY (AML_DEFAULT_ARG_OP,         0,                              0,                  0),
+/* DATATABLEREGION */           OP_TABLE_ENTRY (AML_DATA_REGION_OP,         0,                              0,                  0),
+/* DEBUG */                     OP_TABLE_ENTRY (AML_DEBUG_OP,               0,                              0,                  ACPI_BTYPE_DEBUG_OBJECT),
+/* DECODETYPE_POS */            OP_TABLE_ENTRY (AML_BYTE_OP,                0,                              0,                  0),
+/* DECODETYPE_SUB */            OP_TABLE_ENTRY (AML_BYTE_OP,                1,                              0,                  0),
+/* DECREMENT */                 OP_TABLE_ENTRY (AML_DECREMENT_OP,           0,                              0,                  ACPI_BTYPE_INTEGER),
+/* DEFAULT */                   OP_TABLE_ENTRY (AML_DEFAULT_ARG_OP,         0,                              0,                  0),
+/* DEFAULT_ARG */               OP_TABLE_ENTRY (AML_DEFAULT_ARG_OP,         0,                              0,                  0),
+/* DEFINITIONBLOCK */           OP_TABLE_ENTRY (AML_DEFAULT_ARG_OP,         0,                              0,                  0),
+/* DEREFOF */                   OP_TABLE_ENTRY (AML_DEREF_OF_OP,            0,                              0,                  ACPI_BTYPE_DATA_REFERENCE | ACPI_BTYPE_STRING),
+/* DEVICE */                    OP_TABLE_ENTRY (AML_DEVICE_OP,              0,                              NODE_AML_PACKAGE,   0),
+/* DEVICEPOLARITY_HIGH */       OP_TABLE_ENTRY (AML_BYTE_OP,                1,                              0,                  0),
+/* DEVICEPOLARITY_LOW */        OP_TABLE_ENTRY (AML_BYTE_OP,                0,                              0,                  0),
+/* DIVIDE */                    OP_TABLE_ENTRY (AML_DIVIDE_OP,              0,                              0,                  ACPI_BTYPE_INTEGER),
+/* DMA */                       OP_TABLE_ENTRY (AML_DEFAULT_ARG_OP,         0,                              0,                  0),
+/* DMATYPE_A */                 OP_TABLE_ENTRY (AML_BYTE_OP,                1,                              0,                  0),
+/* DMATYPE_COMPATIBILITY */     OP_TABLE_ENTRY (AML_BYTE_OP,                0,                              0,                  0),
+/* DMATYPE_B */                 OP_TABLE_ENTRY (AML_BYTE_OP,                2,                              0,                  0),
+/* DMATYPE_F */                 OP_TABLE_ENTRY (AML_BYTE_OP,                3,                              0,                  0),
+/* DWORDCONST */                OP_TABLE_ENTRY (AML_RAW_DATA_DWORD,         0,                              0,                  ACPI_BTYPE_INTEGER),
+/* DWORDIO */                   OP_TABLE_ENTRY (AML_DEFAULT_ARG_OP,         0,                              0,                  0),
+/* DWORDMEMORY */               OP_TABLE_ENTRY (AML_DEFAULT_ARG_OP,         0,                              0,                  0),
+/* DWORDSPACE */                OP_TABLE_ENTRY (AML_BYTE_OP,                0,                              0,                  0),
+/* EISAID */                    OP_TABLE_ENTRY (AML_DWORD_OP,               0,                              0,                  ACPI_BTYPE_INTEGER),
+/* ELSE */                      OP_TABLE_ENTRY (AML_ELSE_OP,                0,                              NODE_AML_PACKAGE,   0),
+/* ELSEIF */                    OP_TABLE_ENTRY (AML_DEFAULT_ARG_OP,         0,                              NODE_AML_PACKAGE,   0),
+/* ENDDEPENDENTFN */            OP_TABLE_ENTRY (AML_DEFAULT_ARG_OP,         0,                              0,                  0),
+/* ENDIAN_BIG */                OP_TABLE_ENTRY (AML_BYTE_OP,                1,                              0,                  0),
+/* ENDIAN_LITTLE */             OP_TABLE_ENTRY (AML_BYTE_OP,                0,                              0,                  0),
+/* ENDTAG */                    OP_TABLE_ENTRY (AML_DEFAULT_ARG_OP,         0,                              0,                  0),
+/* ERRORNODE */                 OP_TABLE_ENTRY (AML_NOOP_OP,                0,                              0,                  0),
+/* EVENT */                     OP_TABLE_ENTRY (AML_EVENT_OP,               0,                              0,                  0),
+/* EXTENDEDIO */                OP_TABLE_ENTRY (AML_BYTE_OP,                0,                              0,                  0),
+/* EXTENDEDMEMORY */            OP_TABLE_ENTRY (AML_BYTE_OP,                0,                              0,                  0),
+/* EXTENDEDSPACE */             OP_TABLE_ENTRY (AML_RAW_DATA_QWORD,         0,                              0,                  ACPI_BTYPE_INTEGER),
+/* EXTERNAL */                  OP_TABLE_ENTRY (AML_EXTERNAL_OP,            0,                              0,                  0),
+/* FATAL */                     OP_TABLE_ENTRY (AML_FATAL_OP,               0,                              0,                  0),
+/* FIELD */                     OP_TABLE_ENTRY (AML_FIELD_OP,               0,                              NODE_AML_PACKAGE,   0),
+/* FINDSETLEFTBIT */            OP_TABLE_ENTRY (AML_FIND_SET_LEFT_BIT_OP,   0,                              0,                  ACPI_BTYPE_INTEGER),
+/* FINDSETRIGHTBIT */           OP_TABLE_ENTRY (AML_FIND_SET_RIGHT_BIT_OP,  0,                              0,                  ACPI_BTYPE_INTEGER),
+/* FIXEDDMA */                  OP_TABLE_ENTRY (AML_DEFAULT_ARG_OP,         0,                              0,                  0),
+/* FIXEDIO */                   OP_TABLE_ENTRY (AML_DEFAULT_ARG_OP,         0,                              0,                  0),
+/* FLOWCONTROL_HW */            OP_TABLE_ENTRY (AML_BYTE_OP,                1,                              0,                  0),
+/* FLOWCONTROL_NONE */          OP_TABLE_ENTRY (AML_BYTE_OP,                0,                              0,                  0),
+/* FLOWCONTROL_SW */            OP_TABLE_ENTRY (AML_BYTE_OP,                2,                              0,                  0),
+/* FROMBCD */                   OP_TABLE_ENTRY (AML_FROM_BCD_OP,            0,                              0,                  ACPI_BTYPE_INTEGER),
+/* FUNCTION */                  OP_TABLE_ENTRY (AML_METHOD_OP,              0,                              NODE_AML_PACKAGE,   0),
+/* GPIOINT */                   OP_TABLE_ENTRY (AML_DEFAULT_ARG_OP,         0,                              0,                  0),
+/* GPIOIO */                    OP_TABLE_ENTRY (AML_DEFAULT_ARG_OP,         0,                              0,                  0),
+/* I2CSERIALBUS */              OP_TABLE_ENTRY (AML_DEFAULT_ARG_OP,         0,                              0,                  0),
+/* I2CSERIALBUSV2 */            OP_TABLE_ENTRY (AML_DEFAULT_ARG_OP,         0,                              0,                  0),
+/* IF */                        OP_TABLE_ENTRY (AML_IF_OP,                  0,                              NODE_AML_PACKAGE,   0),
+/* INCLUDE */                   OP_TABLE_ENTRY (AML_DEFAULT_ARG_OP,         0,                              0,                  0),
+/* INCLUDE_END */               OP_TABLE_ENTRY (AML_DEFAULT_ARG_OP,         0,                              0,                  0),
+/* INCREMENT */                 OP_TABLE_ENTRY (AML_INCREMENT_OP,           0,                              0,                  ACPI_BTYPE_INTEGER),
+/* INDEX */                     OP_TABLE_ENTRY (AML_INDEX_OP,               0,                              0,                  ACPI_BTYPE_REFERENCE_OBJECT),
+/* INDEXFIELD */                OP_TABLE_ENTRY (AML_INDEX_FIELD_OP,         0,                              NODE_AML_PACKAGE,   0),
+/* INTEGER */                   OP_TABLE_ENTRY (AML_BYTE_OP,                0,                              0,                  ACPI_BTYPE_INTEGER),
+/* INTERRUPT */                 OP_TABLE_ENTRY (AML_DEFAULT_ARG_OP,         0,                              0,                  0),
+/* INTLEVEL_ACTIVEBOTH */       OP_TABLE_ENTRY (AML_BYTE_OP,                2,                              0,                  0),
+/* INTLEVEL_ACTIVEHIGH */       OP_TABLE_ENTRY (AML_BYTE_OP,                0,                              0,                  0),
+/* INTLEVEL_ACTIVELOW */        OP_TABLE_ENTRY (AML_BYTE_OP,                1,                              0,                  0),
+/* INTTYPE_EDGE */              OP_TABLE_ENTRY (AML_BYTE_OP,                1,                              0,                  0),
+/* INTTYPE_LEVEL */             OP_TABLE_ENTRY (AML_BYTE_OP,                0,                              0,                  0),
+/* IO */                        OP_TABLE_ENTRY (AML_DEFAULT_ARG_OP,         0,                              0,                  0),
+/* IODECODETYPE_10 */           OP_TABLE_ENTRY (AML_BYTE_OP,                0,                              0,                  0),
+/* IODECODETYPE_16 */           OP_TABLE_ENTRY (AML_BYTE_OP,                1,                              0,                  0),
+/* IORESTRICT_IN */             OP_TABLE_ENTRY (AML_BYTE_OP,                1,                              0,                  0),
+/* IORESTRICT_NONE */           OP_TABLE_ENTRY (AML_BYTE_OP,                0,                              0,                  0),
+/* IORESTRICT_OUT */            OP_TABLE_ENTRY (AML_BYTE_OP,                2,                              0,                  0),
+/* IORESTRICT_PRESERVE */       OP_TABLE_ENTRY (AML_BYTE_OP,                3,                              0,                  0),
+/* IRQ */                       OP_TABLE_ENTRY (AML_DEFAULT_ARG_OP,         0,                              0,                  0),
+/* IRQNOFLAGS */                OP_TABLE_ENTRY (AML_DEFAULT_ARG_OP,         0,                              0,                  0),
+/* LAND */                      OP_TABLE_ENTRY (AML_LAND_OP,                0,                              0,                  ACPI_BTYPE_INTEGER),
+/* LEQUAL */                    OP_TABLE_ENTRY (AML_LEQUAL_OP,              0,                              0,                  ACPI_BTYPE_INTEGER),
+/* LGREATER */                  OP_TABLE_ENTRY (AML_LGREATER_OP,            0,                              0,                  ACPI_BTYPE_INTEGER),
+/* LGREATEREQUAL */             OP_TABLE_ENTRY (AML_LGREATEREQUAL_OP,       0,                              0,                  ACPI_BTYPE_INTEGER),
+/* LLESS */                     OP_TABLE_ENTRY (AML_LLESS_OP,               0,                              0,                  ACPI_BTYPE_INTEGER),
+/* LLESSEQUAL */                OP_TABLE_ENTRY (AML_LLESSEQUAL_OP,          0,                              0,                  ACPI_BTYPE_INTEGER),
+/* LNOT */                      OP_TABLE_ENTRY (AML_LNOT_OP,                0,                              0,                  ACPI_BTYPE_INTEGER),
+/* LNOTEQUAL */                 OP_TABLE_ENTRY (AML_LNOTEQUAL_OP,           0,                              0,                  ACPI_BTYPE_INTEGER),
+/* LOAD */                      OP_TABLE_ENTRY (AML_LOAD_OP,                0,                              0,                  0),
+/* LOADTABLE */                 OP_TABLE_ENTRY (AML_LOAD_TABLE_OP,          0,                              0,                  ACPI_BTYPE_DDB_HANDLE),
+/* LOCAL0 */                    OP_TABLE_ENTRY (AML_LOCAL0,                 0,                              0,                  ACPI_BTYPE_OBJECTS_AND_REFS),
+/* LOCAL1 */                    OP_TABLE_ENTRY (AML_LOCAL1,                 0,                              0,                  ACPI_BTYPE_OBJECTS_AND_REFS),
+/* LOCAL2 */                    OP_TABLE_ENTRY (AML_LOCAL2,                 0,                              0,                  ACPI_BTYPE_OBJECTS_AND_REFS),
+/* LOCAL3 */                    OP_TABLE_ENTRY (AML_LOCAL3,                 0,                              0,                  ACPI_BTYPE_OBJECTS_AND_REFS),
+/* LOCAL4 */                    OP_TABLE_ENTRY (AML_LOCAL4,                 0,                              0,                  ACPI_BTYPE_OBJECTS_AND_REFS),
+/* LOCAL5 */                    OP_TABLE_ENTRY (AML_LOCAL5,                 0,                              0,                  ACPI_BTYPE_OBJECTS_AND_REFS),
+/* LOCAL6 */                    OP_TABLE_ENTRY (AML_LOCAL6,                 0,                              0,                  ACPI_BTYPE_OBJECTS_AND_REFS),
+/* LOCAL7 */                    OP_TABLE_ENTRY (AML_LOCAL7,                 0,                              0,                  ACPI_BTYPE_OBJECTS_AND_REFS),
+/* LOCKRULE_LOCK */             OP_TABLE_ENTRY (AML_BYTE_OP,                AML_FIELD_LOCK_ALWAYS,          0,                  0),
+/* LOCKRULE_NOLOCK */           OP_TABLE_ENTRY (AML_BYTE_OP,                AML_FIELD_LOCK_NEVER,           0,                  0),
+/* LOR */                       OP_TABLE_ENTRY (AML_LOR_OP,                 0,                              0,                  ACPI_BTYPE_INTEGER),
+/* MATCH */                     OP_TABLE_ENTRY (AML_MATCH_OP,               0,                              0,                  ACPI_BTYPE_INTEGER),
+/* MATCHTYPE_MEQ */             OP_TABLE_ENTRY (AML_RAW_DATA_BYTE,          MATCH_MEQ,                      0,                  ACPI_BTYPE_INTEGER),
+/* MATCHTYPE_MGE */             OP_TABLE_ENTRY (AML_RAW_DATA_BYTE,          MATCH_MGE,                      0,                  ACPI_BTYPE_INTEGER),
+/* MATCHTYPE_MGT */             OP_TABLE_ENTRY (AML_RAW_DATA_BYTE,          MATCH_MGT,                      0,                  ACPI_BTYPE_INTEGER),
+/* MATCHTYPE_MLE */             OP_TABLE_ENTRY (AML_RAW_DATA_BYTE,          MATCH_MLE,                      0,                  ACPI_BTYPE_INTEGER),
+/* MATCHTYPE_MLT */             OP_TABLE_ENTRY (AML_RAW_DATA_BYTE,          MATCH_MLT,                      0,                  ACPI_BTYPE_INTEGER),
+/* MATCHTYPE_MTR */             OP_TABLE_ENTRY (AML_RAW_DATA_BYTE,          MATCH_MTR,                      0,                  ACPI_BTYPE_INTEGER),
+/* MAXTYPE_FIXED */             OP_TABLE_ENTRY (AML_BYTE_OP,                1,                              0,                  0),
+/* MAXTYPE_NOTFIXED */          OP_TABLE_ENTRY (AML_BYTE_OP,                0,                              0,                  0),
+/* MEMORY24 */                  OP_TABLE_ENTRY (AML_DEFAULT_ARG_OP,         0,                              0,                  0),
+/* MEMORY32 */                  OP_TABLE_ENTRY (AML_DEFAULT_ARG_OP,         0,                              0,                  0),
+/* MEMORY32FIXED */             OP_TABLE_ENTRY (AML_DEFAULT_ARG_OP,         0,                              0,                  0),
+/* MEMTYPE_CACHEABLE */         OP_TABLE_ENTRY (AML_BYTE_OP,                1,                              0,                  0),
+/* MEMTYPE_NONCACHEABLE */      OP_TABLE_ENTRY (AML_BYTE_OP,                0,                              0,                  0),
+/* MEMTYPE_PREFETCHABLE */      OP_TABLE_ENTRY (AML_BYTE_OP,                3,                              0,                  0),
+/* MEMTYPE_WRITECOMBINING */    OP_TABLE_ENTRY (AML_BYTE_OP,                2,                              0,                  0),
+/* METHOD */                    OP_TABLE_ENTRY (AML_METHOD_OP,              0,                              NODE_AML_PACKAGE,   0),
+/* METHODCALL */                OP_TABLE_ENTRY (AML_INT_METHODCALL_OP,      0,                              0,                  ACPI_BTYPE_OBJECTS_AND_REFS),
+/* MID */                       OP_TABLE_ENTRY (AML_MID_OP,                 0,                              0,                  ACPI_BTYPE_STRING | ACPI_BTYPE_BUFFER),
+/* MINTYPE_FIXED */             OP_TABLE_ENTRY (AML_BYTE_OP,                1,                              0,                  0),
+/* MINTYPE_NOTFIXED */          OP_TABLE_ENTRY (AML_BYTE_OP,                0,                              0,                  0),
+/* MOD */                       OP_TABLE_ENTRY (AML_MOD_OP,                 0,                              0,                  ACPI_BTYPE_INTEGER),
+/* MULTIPLY */                  OP_TABLE_ENTRY (AML_MULTIPLY_OP,            0,                              0,                  ACPI_BTYPE_INTEGER),
+/* MUTEX */                     OP_TABLE_ENTRY (AML_MUTEX_OP,               0,                              0,                  0),
+/* NAME */                      OP_TABLE_ENTRY (AML_NAME_OP,                0,                              0,                  0),
+/* NAMESEG */                   OP_TABLE_ENTRY (AML_INT_NAMEPATH_OP,        0,                              0,                  0),
+/* NAMESTRING */                OP_TABLE_ENTRY (AML_INT_NAMEPATH_OP,        0,                              0,                  0),
+/* NAND */                      OP_TABLE_ENTRY (AML_BIT_NAND_OP,            0,                              0,                  ACPI_BTYPE_INTEGER),
+/* NOOP */                      OP_TABLE_ENTRY (AML_NOOP_OP,                0,                              0,                  0),
+/* NOR */                       OP_TABLE_ENTRY (AML_BIT_NOR_OP,             0,                              0,                  ACPI_BTYPE_INTEGER),
+/* NOT */                       OP_TABLE_ENTRY (AML_BIT_NOT_OP,             0,                              0,                  ACPI_BTYPE_INTEGER),
+/* NOTIFY */                    OP_TABLE_ENTRY (AML_NOTIFY_OP,              0,                              0,                  0),
+/* OBJECTTYPE */                OP_TABLE_ENTRY (AML_OBJECT_TYPE_OP,         0,                              0,                  ACPI_BTYPE_INTEGER),
+/* OBJECTTYPE_BFF */            OP_TABLE_ENTRY (AML_RAW_DATA_BYTE,          ACPI_TYPE_BUFFER_FIELD,         0,                  0),
+/* OBJECTTYPE_BUF */            OP_TABLE_ENTRY (AML_RAW_DATA_BYTE,          ACPI_TYPE_BUFFER,               0,                  0),
+/* OBJECTTYPE_DDB */            OP_TABLE_ENTRY (AML_RAW_DATA_BYTE,          ACPI_TYPE_DDB_HANDLE,           0,                  0),
+/* OBJECTTYPE_DEV */            OP_TABLE_ENTRY (AML_RAW_DATA_BYTE,          ACPI_TYPE_DEVICE,               0,                  0),
+/* OBJECTTYPE_EVT */            OP_TABLE_ENTRY (AML_RAW_DATA_BYTE,          ACPI_TYPE_EVENT,                0,                  0),
+/* OBJECTTYPE_FLD */            OP_TABLE_ENTRY (AML_RAW_DATA_BYTE,          ACPI_TYPE_FIELD_UNIT,           0,                  0),
+/* OBJECTTYPE_INT */            OP_TABLE_ENTRY (AML_RAW_DATA_BYTE,          ACPI_TYPE_INTEGER,              0,                  0),
+/* OBJECTTYPE_MTH */            OP_TABLE_ENTRY (AML_RAW_DATA_BYTE,          ACPI_TYPE_METHOD,               0,                  0),
+/* OBJECTTYPE_MTX */            OP_TABLE_ENTRY (AML_RAW_DATA_BYTE,          ACPI_TYPE_MUTEX,                0,                  0),
+/* OBJECTTYPE_OPR */            OP_TABLE_ENTRY (AML_RAW_DATA_BYTE,          ACPI_TYPE_REGION,               0,                  0),
+/* OBJECTTYPE_PKG */            OP_TABLE_ENTRY (AML_RAW_DATA_BYTE,          ACPI_TYPE_PACKAGE,              0,                  0),
+/* OBJECTTYPE_POW */            OP_TABLE_ENTRY (AML_RAW_DATA_BYTE,          ACPI_TYPE_POWER,                0,                  0),
+/* OBJECTTYPE_PRO */            OP_TABLE_ENTRY (AML_RAW_DATA_BYTE,          ACPI_TYPE_PROCESSOR,            0,                  0),
+/* OBJECTTYPE_STR */            OP_TABLE_ENTRY (AML_RAW_DATA_BYTE,          ACPI_TYPE_STRING,               0,                  0),
+/* OBJECTTYPE_THZ */            OP_TABLE_ENTRY (AML_RAW_DATA_BYTE,          ACPI_TYPE_THERMAL,              0,                  0),
+/* OBJECTTYPE_UNK */            OP_TABLE_ENTRY (AML_RAW_DATA_BYTE,          ACPI_TYPE_ANY,                  0,                  0),
+/* OFFSET */                    OP_TABLE_ENTRY (AML_INT_RESERVEDFIELD_OP,   0,                              0,                  0),
+/* ONE */                       OP_TABLE_ENTRY (AML_ONE_OP,                 0,                              0,                  ACPI_BTYPE_INTEGER),
+/* ONES */                      OP_TABLE_ENTRY (AML_ONES_OP,                0,                              0,                  ACPI_BTYPE_INTEGER),
+/* OPERATIONREGION */           OP_TABLE_ENTRY (AML_REGION_OP,              0,                              0,                  0),
+/* OR */                        OP_TABLE_ENTRY (AML_BIT_OR_OP,              0,                              0,                  ACPI_BTYPE_INTEGER),
+/* PACKAGE */                   OP_TABLE_ENTRY (AML_PACKAGE_OP,             0,                              NODE_AML_PACKAGE,   ACPI_BTYPE_PACKAGE),
+/* PACKAGEP_LENGTH */           OP_TABLE_ENTRY (AML_PACKAGE_LENGTH,         0,                              NODE_AML_PACKAGE,   0),
+/* PARITYTYPE_EVEN */           OP_TABLE_ENTRY (AML_BYTE_OP,                1,                              0,                  0),
+/* PARITYTYPE_MARK */           OP_TABLE_ENTRY (AML_BYTE_OP,                3,                              0,                  0),
+/* PARITYTYPE_NONE */           OP_TABLE_ENTRY (AML_BYTE_OP,                0,                              0,                  0),
+/* PARITYTYPE_ODD */            OP_TABLE_ENTRY (AML_BYTE_OP,                2,                              0,                  0),
+/* PARITYTYPE_SPACE */          OP_TABLE_ENTRY (AML_BYTE_OP,                4,                              0,                  0),
+/* PIN_NOPULL */                OP_TABLE_ENTRY (AML_BYTE_OP,                3,                              0,                  0),
+/* PIN_PULLDEFAULT */           OP_TABLE_ENTRY (AML_BYTE_OP,                0,                              0,                  0),
+/* PIN_PULLDOWN */              OP_TABLE_ENTRY (AML_BYTE_OP,                2,                              0,                  0),
+/* PIN_PULLUP */                OP_TABLE_ENTRY (AML_BYTE_OP,                1,                              0,                  0),
+/* POWERRESOURCE */             OP_TABLE_ENTRY (AML_POWER_RES_OP,           0,                              NODE_AML_PACKAGE,   0),
+/* PROCESSOR */                 OP_TABLE_ENTRY (AML_PROCESSOR_OP,           0,                              NODE_AML_PACKAGE,   0),
+/* QWORDCONST */                OP_TABLE_ENTRY (AML_RAW_DATA_QWORD,         0,                              0,                  ACPI_BTYPE_INTEGER),
+/* QWORDIO */                   OP_TABLE_ENTRY (AML_BYTE_OP,                0,                              0,                  0),
+/* QWORDMEMORY */               OP_TABLE_ENTRY (AML_BYTE_OP,                0,                              0,                  0),
+/* QWORDSPACE */                OP_TABLE_ENTRY (AML_BYTE_OP,                0,                              0,                  0),
+/* RANGE_TYPE_ENTIRE */         OP_TABLE_ENTRY (AML_BYTE_OP,                3,                              0,                  0),
+/* RANGE_TYPE_ISAONLY */        OP_TABLE_ENTRY (AML_BYTE_OP,                2,                              0,                  0),
+/* RANGE_TYPE_NONISAONLY */     OP_TABLE_ENTRY (AML_BYTE_OP,                1,                              0,                  0),
+/* RAW_DATA */                  OP_TABLE_ENTRY (AML_BYTE_OP,                0,                              0,                  0),
+/* READWRITETYPE_BOTH */        OP_TABLE_ENTRY (AML_BYTE_OP,                1,                              0,                  0),
+/* READWRITETYPE_READONLY */    OP_TABLE_ENTRY (AML_BYTE_OP,                0,                              0,                  0),
+/* REFOF */                     OP_TABLE_ENTRY (AML_REF_OF_OP,              0,                              0,                  ACPI_BTYPE_REFERENCE_OBJECT),
+/* REGIONSPACE_CMOS */          OP_TABLE_ENTRY (AML_RAW_DATA_BYTE,          ACPI_ADR_SPACE_CMOS,            0,                  0),
+/* REGIONSPACE_EC */            OP_TABLE_ENTRY (AML_RAW_DATA_BYTE,          ACPI_ADR_SPACE_EC,              0,                  0),
+/* REGIONSPACE_FFIXEDHW */      OP_TABLE_ENTRY (AML_RAW_DATA_BYTE,          ACPI_ADR_SPACE_FIXED_HARDWARE,  0,                  0),
+/* REGIONSPACE_GPIO */          OP_TABLE_ENTRY (AML_RAW_DATA_BYTE,          ACPI_ADR_SPACE_GPIO,            0,                  0),
+/* REGIONSPACE_GSBUS */         OP_TABLE_ENTRY (AML_RAW_DATA_BYTE,          ACPI_ADR_SPACE_GSBUS,           0,                  0),
+/* REGIONSPACE_IO */            OP_TABLE_ENTRY (AML_RAW_DATA_BYTE,          ACPI_ADR_SPACE_SYSTEM_IO,       0,                  0),
+/* REGIONSPACE_IPMI */          OP_TABLE_ENTRY (AML_RAW_DATA_BYTE,          ACPI_ADR_SPACE_IPMI,            0,                  0),
+/* REGIONSPACE_MEM */           OP_TABLE_ENTRY (AML_RAW_DATA_BYTE,          ACPI_ADR_SPACE_SYSTEM_MEMORY,   0,                  0),
+/* REGIONSPACE_PCC */           OP_TABLE_ENTRY (AML_RAW_DATA_BYTE,          ACPI_ADR_SPACE_PLATFORM_COMM,   0,                  0),
+/* REGIONSPACE_PCI */           OP_TABLE_ENTRY (AML_RAW_DATA_BYTE,          ACPI_ADR_SPACE_PCI_CONFIG,      0,                  0),
+/* REGIONSPACE_PCIBAR */        OP_TABLE_ENTRY (AML_RAW_DATA_BYTE,          ACPI_ADR_SPACE_PCI_BAR_TARGET,  0,                  0),
+/* REGIONSPACE_SMBUS */         OP_TABLE_ENTRY (AML_RAW_DATA_BYTE,          ACPI_ADR_SPACE_SMBUS,           0,                  0),
+/* REGISTER */                  OP_TABLE_ENTRY (AML_BYTE_OP,                0,                              0,                  0),
+/* RELEASE */                   OP_TABLE_ENTRY (AML_RELEASE_OP,             0,                              0,                  0),
+/* RESERVED_BYTES */            OP_TABLE_ENTRY (AML_INT_RESERVEDFIELD_OP,   0,                              0,                  0),
+/* RESET */                     OP_TABLE_ENTRY (AML_RESET_OP,               0,                              0,                  0),
+/* RESOURCETEMPLATE */          OP_TABLE_ENTRY (AML_BUFFER_OP,              0,                              0,                  ACPI_BTYPE_BUFFER),
+/* RESOURCETYPE_CONSUMER */     OP_TABLE_ENTRY (AML_BYTE_OP,                1,                              0,                  0),
+/* RESOURCETYPE_PRODUCER */     OP_TABLE_ENTRY (AML_BYTE_OP,                0,                              0,                  0),
+/* RETURN */                    OP_TABLE_ENTRY (AML_RETURN_OP,              0,                              0,                  0),
+/* REVISION */                  OP_TABLE_ENTRY (AML_REVISION_OP,            0,                              0,                  ACPI_BTYPE_INTEGER),
+/* SCOPE */                     OP_TABLE_ENTRY (AML_SCOPE_OP,               0,                              NODE_AML_PACKAGE,   0),
+/* SERIALIZERULE_NOTSERIAL */   OP_TABLE_ENTRY (AML_BYTE_OP,                0,                              0,                  0),
+/* SERIALIZERULE_SERIAL */      OP_TABLE_ENTRY (AML_BYTE_OP,                1,                              0,                  0),
+/* SHARETYPE_EXCLUSIVE */       OP_TABLE_ENTRY (AML_BYTE_OP,                0,                              0,                  0),
+/* SHARETYPE_EXCLUSIVEWAKE */   OP_TABLE_ENTRY (AML_BYTE_OP,                2,                              0,                  0),
+/* SHARETYPE_SHARED */          OP_TABLE_ENTRY (AML_BYTE_OP,                1,                              0,                  0),
+/* SHARETYPE_SHAREDWAKE */      OP_TABLE_ENTRY (AML_BYTE_OP,                3,                              0,                  0),
+/* SHIFTLEFT */                 OP_TABLE_ENTRY (AML_SHIFT_LEFT_OP,          0,                              0,                  ACPI_BTYPE_INTEGER),
+/* SHIFTRIGHT */                OP_TABLE_ENTRY (AML_SHIFT_RIGHT_OP,         0,                              0,                  ACPI_BTYPE_INTEGER),
+/* SIGNAL */                    OP_TABLE_ENTRY (AML_SIGNAL_OP,              0,                              0,                  0),
+/* SIZEOF */                    OP_TABLE_ENTRY (AML_SIZE_OF_OP,             0,                              0,                  ACPI_BTYPE_INTEGER),
+/* SLAVEMODE_CONTROLLERINIT */  OP_TABLE_ENTRY (AML_BYTE_OP,                0,                              0,                  0),
+/* SLAVEMODE_DEVICEINIT */      OP_TABLE_ENTRY (AML_BYTE_OP,                1,                              0,                  0),
+/* SLEEP */                     OP_TABLE_ENTRY (AML_SLEEP_OP,               0,                              0,                  0),
+/* SPISERIALBUS */              OP_TABLE_ENTRY (AML_DEFAULT_ARG_OP,         0,                              0,                  0),
+/* SPISERIALBUSV2 */            OP_TABLE_ENTRY (AML_DEFAULT_ARG_OP,         0,                              0,                  0),
+/* STALL */                     OP_TABLE_ENTRY (AML_STALL_OP,               0,                              0,                  0),
+/* STARTDEPENDENTFN */          OP_TABLE_ENTRY (AML_BYTE_OP,                0,                              0,                  0),
+/* STARTDEPENDENTFN_NOPRI */    OP_TABLE_ENTRY (AML_BYTE_OP,                0,                              0,                  0),
+/* STOPBITS_ONE */              OP_TABLE_ENTRY (AML_BYTE_OP,                1,                              0,                  0),
+/* STOPBITS_ONEPLUSHALF */      OP_TABLE_ENTRY (AML_BYTE_OP,                2,                              0,                  0),
+/* STOPBITS_TWO */              OP_TABLE_ENTRY (AML_BYTE_OP,                3,                              0,                  0),
+/* STOPBITS_ZERO */             OP_TABLE_ENTRY (AML_BYTE_OP,                0,                              0,                  0),
+/* STORE */                     OP_TABLE_ENTRY (AML_STORE_OP,               0,                              0,                  ACPI_BTYPE_DATA_REFERENCE),
+/* STRING_LITERAL */            OP_TABLE_ENTRY (AML_STRING_OP,              0,                              0,                  ACPI_BTYPE_STRING),
+/* SUBTRACT */                  OP_TABLE_ENTRY (AML_SUBTRACT_OP,            0,                              0,                  ACPI_BTYPE_INTEGER),
+/* SWITCH */                    OP_TABLE_ENTRY (AML_DEFAULT_ARG_OP,         0,                              0,                  0),
+/* THERMALZONE */               OP_TABLE_ENTRY (AML_THERMAL_ZONE_OP,        0,                              NODE_AML_PACKAGE,   0),
+/* TIMER */                     OP_TABLE_ENTRY (AML_TIMER_OP,               0,                              0,                  ACPI_BTYPE_INTEGER),
+/* TOBCD */                     OP_TABLE_ENTRY (AML_TO_BCD_OP,              0,                              0,                  ACPI_BTYPE_INTEGER),
+/* TOBUFFER */                  OP_TABLE_ENTRY (AML_TO_BUFFER_OP,           0,                              0,                  ACPI_BTYPE_BUFFER),
+/* TODECIMALSTRING */           OP_TABLE_ENTRY (AML_TO_DECSTRING_OP,        0,                              0,                  ACPI_BTYPE_STRING),
+/* TOHEXSTRING */               OP_TABLE_ENTRY (AML_TO_HEXSTRING_OP,        0,                              0,                  ACPI_BTYPE_STRING),
+/* TOINTEGER */                 OP_TABLE_ENTRY (AML_TO_INTEGER_OP,          0,                              0,                  ACPI_BTYPE_INTEGER),
+/* TOSTRING */                  OP_TABLE_ENTRY (AML_TO_STRING_OP,           0,                              0,                  ACPI_BTYPE_STRING),
+/* TOUUID */                    OP_TABLE_ENTRY (AML_DWORD_OP,               0,                              NODE_AML_PACKAGE,   ACPI_BTYPE_INTEGER),
+/* TRANSLATIONTYPE_DENSE */     OP_TABLE_ENTRY (AML_BYTE_OP,                0,                              0,                  0),
+/* TRANSLATIONTYPE_SPARSE */    OP_TABLE_ENTRY (AML_BYTE_OP,                1,                              0,                  0),
+/* TYPE_STATIC */               OP_TABLE_ENTRY (AML_BYTE_OP,                0,                              0,                  0),
+/* TYPE_TRANSLATION */          OP_TABLE_ENTRY (AML_BYTE_OP,                1,                              0,                  0),
+/* UART_SERIALBUS */            OP_TABLE_ENTRY (AML_DEFAULT_ARG_OP,         0,                              0,                  0),
+/* UART_SERIALBUSV2 */          OP_TABLE_ENTRY (AML_DEFAULT_ARG_OP,         0,                              0,                  0),
+/* UNICODE */                   OP_TABLE_ENTRY (AML_BUFFER_OP,              0,                              NODE_AML_PACKAGE,   0),
+/* UNLOAD */                    OP_TABLE_ENTRY (AML_UNLOAD_OP,              0,                              0,                  0),
+/* UPDATERULE_ONES */           OP_TABLE_ENTRY (AML_BYTE_OP,                AML_FIELD_UPDATE_WRITE_AS_ONES, 0,                  0),
+/* UPDATERULE_PRESERVE */       OP_TABLE_ENTRY (AML_BYTE_OP,                AML_FIELD_UPDATE_PRESERVE,      0,                  0),
+/* UPDATERULE_ZEROS */          OP_TABLE_ENTRY (AML_BYTE_OP,                AML_FIELD_UPDATE_WRITE_AS_ZEROS,0,                  0),
+/* VAR_PACKAGE */               OP_TABLE_ENTRY (AML_VAR_PACKAGE_OP,         0,                              NODE_AML_PACKAGE,   ACPI_BTYPE_PACKAGE),
+/* VENDORLONG */                OP_TABLE_ENTRY (AML_BYTE_OP,                0,                              0,                  0),
+/* VENDORSHORT */               OP_TABLE_ENTRY (AML_BYTE_OP,                0,                              0,                  0),
+/* WAIT */                      OP_TABLE_ENTRY (AML_WAIT_OP,                0,                              0,                  ACPI_BTYPE_INTEGER),
+/* WHILE */                     OP_TABLE_ENTRY (AML_WHILE_OP,               0,                              NODE_AML_PACKAGE,   0),
+/* WIREMODE_FOUR */             OP_TABLE_ENTRY (AML_BYTE_OP,                0,                              0,                  0),
+/* WIREMODE_THREE */            OP_TABLE_ENTRY (AML_BYTE_OP,                1,                              0,                  0),
+/* WORDBUSNUMBER */             OP_TABLE_ENTRY (AML_BYTE_OP,                0,                              0,                  0),
+/* WORDCONST */                 OP_TABLE_ENTRY (AML_RAW_DATA_WORD,          0,                              0,                  ACPI_BTYPE_INTEGER),
+/* WORDIO */                    OP_TABLE_ENTRY (AML_BYTE_OP,                0,                              0,                  0),
+/* WORDSPACE */                 OP_TABLE_ENTRY (AML_BYTE_OP,                0,                              0,                  0),
+/* XFERSIZE_8 */                OP_TABLE_ENTRY (AML_BYTE_OP,                0,                              0,                  0),
+/* XFERSIZE_16 */               OP_TABLE_ENTRY (AML_BYTE_OP,                0,                              0,                  0),
+/* XFERSIZE_32 */               OP_TABLE_ENTRY (AML_BYTE_OP,                0,                              0,                  0),
+/* XFERSIZE_64 */               OP_TABLE_ENTRY (AML_BYTE_OP,                0,                              0,                  0),
+/* XFERSIZE_128 */              OP_TABLE_ENTRY (AML_BYTE_OP,                0,                              0,                  0),
+/* XFERSIZE_256 */              OP_TABLE_ENTRY (AML_BYTE_OP,                0,                              0,                  0),
+/* XFERTYPE_8 */                OP_TABLE_ENTRY (AML_BYTE_OP,                0,                              0,                  0),
+/* XFERTYPE_8_16 */             OP_TABLE_ENTRY (AML_BYTE_OP,                1,                              0,                  0),
+/* XFERTYPE_16 */               OP_TABLE_ENTRY (AML_BYTE_OP,                2,                              0,                  0),
+/* XOR */                       OP_TABLE_ENTRY (AML_BIT_XOR_OP,             0,                              0,                  ACPI_BTYPE_INTEGER),
+/* ZERO */                      OP_TABLE_ENTRY (AML_ZERO_OP,                0,                              0,                  ACPI_BTYPE_INTEGER),
+/* TOPLD */                     OP_TABLE_ENTRY (AML_DWORD_OP,               0,                              NODE_AML_PACKAGE,   ACPI_BTYPE_INTEGER),
+/* XFERSIZE_128 */              OP_TABLE_ENTRY (AML_BYTE_OP,                0,                              0,                  0),
+/* REVISION */                  OP_TABLE_ENTRY (AML_BYTE_OP,                0,                              0,                  0),
+/* IGNORECOLOR */               OP_TABLE_ENTRY (AML_BYTE_OP,                0,                              0,                  0),
+/* RED */                       OP_TABLE_ENTRY (AML_BYTE_OP,                0,                              0,                  0),
+/* GREEN */                     OP_TABLE_ENTRY (AML_BYTE_OP,                0,                              0,                  0),
+/* BLUE */                      OP_TABLE_ENTRY (AML_BYTE_OP,                0,                              0,                  0),
+/* WIDTH */                     OP_TABLE_ENTRY (AML_BYTE_OP,                0,                              0,                  0),
+/* HEIGHT */                    OP_TABLE_ENTRY (AML_BYTE_OP,                0,                              0,                  0),
+/* USERVISIBLE */               OP_TABLE_ENTRY (AML_BYTE_OP,                0,                              0,                  0),
+/* DOCK */                      OP_TABLE_ENTRY (AML_BYTE_OP,                0,                              0,                  0),
+/* LID */                       OP_TABLE_ENTRY (AML_BYTE_OP,                0,                              0,                  0),
+/* PANEL */                     OP_TABLE_ENTRY (AML_BYTE_OP,                0,                              0,                  0),
+/* VERTICALPOSITION */          OP_TABLE_ENTRY (AML_BYTE_OP,                0,                              0,                  0),
+/* HORIZONTALPOSITION */        OP_TABLE_ENTRY (AML_BYTE_OP,                0,                              0,                  0),
+/* SHAPE */                     OP_TABLE_ENTRY (AML_BYTE_OP,                0,                              0,                  0),
+/* GROUPORIENTATION */          OP_TABLE_ENTRY (AML_BYTE_OP,                0,                              0,                  0),
+/* GROUPTOKEN */                OP_TABLE_ENTRY (AML_BYTE_OP,                0,                              0,                  0),
+/* GROUPPOSITION */             OP_TABLE_ENTRY (AML_BYTE_OP,                0,                              0,                  0),
+/* BAY */                       OP_TABLE_ENTRY (AML_BYTE_OP,                0,                              0,                  0),
+/* EJECTABLE */                 OP_TABLE_ENTRY (AML_BYTE_OP,                0,                              0,                  0),
+/* EJECTREQUIRED */             OP_TABLE_ENTRY (AML_BYTE_OP,                0,                              0,                  0),
+/* CABINETNUMBER */             OP_TABLE_ENTRY (AML_BYTE_OP,                0,                              0,                  0),
+/* CARDCAGENUMBER */            OP_TABLE_ENTRY (AML_BYTE_OP,                0,                              0,                  0),
+/* REFERENCE */                 OP_TABLE_ENTRY (AML_BYTE_OP,                0,                              0,                  0),
+/* ROTATION */                  OP_TABLE_ENTRY (AML_BYTE_OP,                0,                              0,                  0),
+/* ORDER */                     OP_TABLE_ENTRY (AML_BYTE_OP,                0,                              0,                  0),
+/* RESERVED */                  OP_TABLE_ENTRY (AML_BYTE_OP,                0,                              0,                  0),
+/* VERTICALOFFSET */            OP_TABLE_ENTRY (AML_BYTE_OP,                0,                              0,                  0),
+/* HORIZONTALOFFSET */          OP_TABLE_ENTRY (AML_BYTE_OP,                0,                              0,                  0),
+/* PRINTF */                    OP_TABLE_ENTRY (AML_STORE_OP,               0,                              0,                  ACPI_BTYPE_DATA_REFERENCE),
+/* FPRINTF */                   OP_TABLE_ENTRY (AML_STORE_OP,               0,                              0,                  ACPI_BTYPE_DATA_REFERENCE),
+/* ASLCODE  */                  OP_TABLE_ENTRY (0,                          0,                              0,                  0)
+/*! [End] no source code translation !*/
+
+};
diff --git a/usr/src/cmd/acpi/iasl/aslmapenter.c b/usr/src/cmd/acpi/iasl/aslmapenter.c
new file mode 100644
index 0000000000..e4ab4f25d9
--- /dev/null
+++ b/usr/src/cmd/acpi/iasl/aslmapenter.c
@@ -0,0 +1,348 @@
+/******************************************************************************
+ *
+ * Module Name: aslmapenter - Build resource descriptor/device maps
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2016, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include "acpi.h"
+#include "accommon.h"
+#include "acapps.h"
+#include "aslcompiler.h"
+
+/* This module used for application-level code only */
+
+#define _COMPONENT          ACPI_COMPILER
+        ACPI_MODULE_NAME    ("aslmapenter")
+
+/* Local prototypes */
+
+static ACPI_GPIO_INFO *
+MpCreateGpioInfo (
+    UINT16                  PinNumber,
+    char                    *DeviceName);
+
+static ACPI_SERIAL_INFO *
+MpCreateSerialInfo (
+    char                    *DeviceName,
+    UINT16                  Address);
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    MpSaveGpioInfo
+ *
+ * PARAMETERS:  Resource                - GPIO resource descriptor
+ *              PinCount                - From GPIO descriptor
+ *              PinList                 - From GPIO descriptor
+ *              DeviceName              - The "ResourceSource" name
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: External Interface.
+ *              Save GPIO resource descriptor information.
+ *              Creates new GPIO info blocks, one for each pin defined by the
+ *              GPIO descriptor.
+ *
+ ******************************************************************************/
+
+void
+MpSaveGpioInfo (
+    ACPI_PARSE_OBJECT       *Op,
+    AML_RESOURCE            *Resource,
+    UINT32                  PinCount,
+    UINT16                  *PinList,
+    char                    *DeviceName)
+{
+    ACPI_GPIO_INFO          *Info;
+    UINT32                  i;
+
+
+    /* Mapfile option enabled? */
+
+    if (!Gbl_MapfileFlag)
+    {
+        return;
+    }
+
+    /* Create an info block for each pin defined in the descriptor */
+
+    for (i = 0; i < PinCount; i++)
+    {
+        Info = MpCreateGpioInfo (PinList[i], DeviceName);
+
+        Info->Op = Op;
+        Info->DeviceName = DeviceName;
+        Info->PinCount = PinCount;
+        Info->PinIndex = i;
+        Info->PinNumber = PinList[i];
+        Info->Type = Resource->Gpio.ConnectionType;
+        Info->Direction = (UINT8) (Resource->Gpio.IntFlags & 0x0003);       /* _IOR, for IO descriptor */
+        Info->Polarity = (UINT8) ((Resource->Gpio.IntFlags >> 1) & 0x0003); /* _POL, for INT descriptor */
+    }
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    MpSaveSerialInfo
+ *
+ * PARAMETERS:  Resource                - A Serial resource descriptor
+ *              DeviceName              - The "ResourceSource" name.
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: External Interface.
+ *              Save serial resource descriptor information.
+ *              Creates a new serial info block.
+ *
+ ******************************************************************************/
+
+void
+MpSaveSerialInfo (
+    ACPI_PARSE_OBJECT       *Op,
+    AML_RESOURCE            *Resource,
+    char                    *DeviceName)
+{
+    ACPI_SERIAL_INFO        *Info;
+    UINT16                  Address;
+    UINT32                  Speed;
+
+
+    /* Mapfile option enabled? */
+
+    if (!Gbl_MapfileFlag)
+    {
+        return;
+    }
+
+    if (Resource->DescriptorType != ACPI_RESOURCE_NAME_SERIAL_BUS)
+    {
+        return;
+    }
+
+    /* Extract address and speed from the resource descriptor */
+
+    switch (Resource->CommonSerialBus.Type)
+    {
+    case AML_RESOURCE_I2C_SERIALBUSTYPE:
+
+        Address = Resource->I2cSerialBus.SlaveAddress;
+        Speed = Resource->I2cSerialBus.ConnectionSpeed;
+        break;
+
+    case AML_RESOURCE_SPI_SERIALBUSTYPE:
+
+        Address = Resource->SpiSerialBus.DeviceSelection;
+        Speed = Resource->SpiSerialBus.ConnectionSpeed;
+        break;
+
+    case AML_RESOURCE_UART_SERIALBUSTYPE:
+
+        Address = 0;
+        Speed = Resource->UartSerialBus.DefaultBaudRate;
+        break;
+
+    default:    /* Invalid bus subtype */
+        return;
+    }
+
+    Info = MpCreateSerialInfo (DeviceName, Address);
+
+    Info->Op = Op;
+    Info->DeviceName = DeviceName;
+    Info->Resource = Resource;
+    Info->Address = Address;
+    Info->Speed = Speed;
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    MpCreateGpioInfo
+ *
+ * PARAMETERS:  PinNumber               - GPIO pin number
+ *              DeviceName              - The "ResourceSource" name
+ *
+ * RETURN:      New GPIO info block.
+ *
+ * DESCRIPTION: Create a new GPIO info block and place it on the global list.
+ *              The list is sorted by GPIO device names first, and pin numbers
+ *              secondarily.
+ *
+ ******************************************************************************/
+
+static ACPI_GPIO_INFO *
+MpCreateGpioInfo (
+    UINT16                  PinNumber,
+    char                    *DeviceName)
+{
+    ACPI_GPIO_INFO          *Info;
+    ACPI_GPIO_INFO          *NextGpio;
+    ACPI_GPIO_INFO          *PrevGpio;
+    char                    *Buffer;
+
+
+    /*
+     * Allocate a new info block and insert it into the global GPIO list
+     * sorted by both source device name and then the pin number. There is
+     * one block per pin.
+     */
+    Buffer = UtStringCacheCalloc (sizeof (ACPI_GPIO_INFO));
+    Info = ACPI_CAST_PTR (ACPI_GPIO_INFO, Buffer);
+
+    NextGpio = Gbl_GpioList;
+    PrevGpio = NULL;
+    if (!Gbl_GpioList)
+    {
+        Gbl_GpioList = Info;
+        Info->Next = NULL;
+        return (Info);
+    }
+
+    /* Sort on source DeviceName first */
+
+    while (NextGpio &&
+        (strcmp (DeviceName, NextGpio->DeviceName) > 0))
+    {
+        PrevGpio = NextGpio;
+        NextGpio = NextGpio->Next;
+    }
+
+    /* Now sort on the PinNumber */
+
+    while (NextGpio &&
+        (NextGpio->PinNumber < PinNumber) &&
+        !strcmp (DeviceName, NextGpio->DeviceName))
+    {
+        PrevGpio = NextGpio;
+        NextGpio = NextGpio->Next;
+    }
+
+    /* Finish the list insertion */
+
+    if (PrevGpio)
+    {
+        PrevGpio->Next = Info;
+    }
+    else
+    {
+        Gbl_GpioList = Info;
+    }
+
+    Info->Next = NextGpio;
+    return (Info);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    MpCreateSerialInfo
+ *
+ * PARAMETERS:  DeviceName              - The "ResourceSource" name.
+ *              Address                 - Physical address for the device
+ *
+ * RETURN:      New Serial info block.
+ *
+ * DESCRIPTION: Create a new Serial info block and place it on the global list.
+ *              The list is sorted by Serial device names first, and addresses
+ *              secondarily.
+ *
+ ******************************************************************************/
+
+static ACPI_SERIAL_INFO *
+MpCreateSerialInfo (
+    char                    *DeviceName,
+    UINT16                  Address)
+{
+    ACPI_SERIAL_INFO        *Info;
+    ACPI_SERIAL_INFO        *NextSerial;
+    ACPI_SERIAL_INFO        *PrevSerial;
+    char                    *Buffer;
+
+
+    /*
+     * Allocate a new info block and insert it into the global Serial list
+     * sorted by both source device name and then the address.
+     */
+    Buffer = UtStringCacheCalloc (sizeof (ACPI_SERIAL_INFO));
+    Info = ACPI_CAST_PTR (ACPI_SERIAL_INFO, Buffer);
+
+    NextSerial = Gbl_SerialList;
+    PrevSerial = NULL;
+    if (!Gbl_SerialList)
+    {
+        Gbl_SerialList = Info;
+        Info->Next = NULL;
+        return (Info);
+    }
+
+    /* Sort on source DeviceName */
+
+    while (NextSerial &&
+        (strcmp (DeviceName, NextSerial->DeviceName) > 0))
+    {
+        PrevSerial = NextSerial;
+        NextSerial = NextSerial->Next;
+    }
+
+    /* Now sort on the Address */
+
+    while (NextSerial &&
+        (NextSerial->Address < Address) &&
+        !strcmp (DeviceName, NextSerial->DeviceName))
+    {
+        PrevSerial = NextSerial;
+        NextSerial = NextSerial->Next;
+    }
+
+    /* Finish the list insertion */
+
+    if (PrevSerial)
+    {
+        PrevSerial->Next = Info;
+    }
+    else
+    {
+        Gbl_SerialList = Info;
+    }
+
+    Info->Next = NextSerial;
+    return (Info);
+}
diff --git a/usr/src/cmd/acpi/iasl/aslmapoutput.c b/usr/src/cmd/acpi/iasl/aslmapoutput.c
new file mode 100644
index 0000000000..a5b19e775e
--- /dev/null
+++ b/usr/src/cmd/acpi/iasl/aslmapoutput.c
@@ -0,0 +1,642 @@
+/******************************************************************************
+ *
+ * Module Name: aslmapoutput - Output/emit the resource descriptor/device maps
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2016, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include "acpi.h"
+#include "accommon.h"
+#include "acapps.h"
+#include "aslcompiler.h"
+#include "aslcompiler.y.h"
+#include "acinterp.h"
+#include "acparser.h"
+#include "acnamesp.h"
+#include "amlcode.h"
+
+/* This module used for application-level code only */
+
+#define _COMPONENT          ACPI_COMPILER
+        ACPI_MODULE_NAME    ("aslmapoutput")
+
+/* Local prototypes */
+
+static void
+MpEmitGpioInfo (
+    void);
+
+static void
+MpEmitSerialInfo (
+    void);
+
+static void
+MpEmitDeviceTree (
+    void);
+
+static ACPI_STATUS
+MpEmitOneDevice (
+    ACPI_HANDLE             ObjHandle,
+    UINT32                  NestingLevel,
+    void                    *Context,
+    void                    **ReturnValue);
+
+static void
+MpXrefDevices (
+    ACPI_GPIO_INFO          *Info);
+
+static ACPI_STATUS
+MpNamespaceXrefBegin (
+    ACPI_PARSE_OBJECT       *Op,
+    UINT32                  Level,
+    void                    *Context);
+
+
+/* Strings used to decode flag bits */
+
+const char                  *DirectionDecode[] =
+{
+    "Both I/O   ",
+    "InputOnly  ",
+    "OutputOnly ",
+    "Preserve   "
+};
+
+const char                  *PolarityDecode[] =
+{
+    "ActiveHigh",
+    "ActiveLow ",
+    "ActiveBoth",
+    "Reserved  "
+};
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    MpEmitMappingInfo
+ *
+ * PARAMETERS:  None
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: External interface.
+ *              Map file has already been opened. Emit all of the collected
+ *              hardware mapping information. Includes: GPIO information,
+ *              Serial information, and a dump of the entire ACPI device tree.
+ *
+ ******************************************************************************/
+
+void
+MpEmitMappingInfo (
+    void)
+{
+
+    /* Mapfile option enabled? */
+
+    if (!Gbl_MapfileFlag)
+    {
+        return;
+    }
+
+    if (!Gbl_GpioList)
+    {
+        FlPrintFile (ASL_FILE_MAP_OUTPUT,
+            "\nNo GPIO devices found\n");
+    }
+
+    if (!Gbl_SerialList)
+    {
+        FlPrintFile (ASL_FILE_MAP_OUTPUT,
+            "\nNo Serial devices found (I2C/SPI/UART)\n");
+    }
+
+    if (!Gbl_GpioList && !Gbl_SerialList)
+    {
+        return;
+    }
+
+    /* Headers */
+
+    FlPrintFile (ASL_FILE_MAP_OUTPUT, "\nResource Descriptor Connectivity Map\n");
+    FlPrintFile (ASL_FILE_MAP_OUTPUT,   "------------------------------------\n");
+
+    /* Emit GPIO and Serial descriptors, then entire ACPI device tree */
+
+    MpEmitGpioInfo ();
+    MpEmitSerialInfo ();
+    MpEmitDeviceTree ();
+
+    /* Clear the lists - no need to free memory here */
+
+    Gbl_SerialList = NULL;
+    Gbl_GpioList = NULL;
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    MpEmitGpioInfo
+ *
+ * PARAMETERS:  None
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Emit the info about all GPIO devices found during the
+ *              compile or disassembly.
+ *
+ ******************************************************************************/
+
+static void
+MpEmitGpioInfo (
+    void)
+{
+    ACPI_GPIO_INFO          *Info;
+    char                    *Type;
+    char                    *PrevDeviceName = NULL;
+    const char              *Direction;
+    const char              *Polarity;
+    char                    *ParentPathname;
+    const char              *Description;
+    char                    *HidString;
+    const AH_DEVICE_ID      *HidInfo;
+
+
+    /* Walk the GPIO descriptor list */
+
+    Info = Gbl_GpioList;
+    while (Info)
+    {
+        HidString = MpGetHidViaNamestring (Info->DeviceName);
+
+        /* Print header info for the controller itself */
+
+        if (!PrevDeviceName ||
+            strcmp (PrevDeviceName, Info->DeviceName))
+        {
+            FlPrintFile (ASL_FILE_MAP_OUTPUT,
+                "\n\nGPIO Controller:  %-8s  %-28s",
+                HidString, Info->DeviceName);
+
+            HidInfo = AcpiAhMatchHardwareId (HidString);
+            if (HidInfo)
+            {
+                FlPrintFile (ASL_FILE_MAP_OUTPUT, "  // %s",
+                    HidInfo->Description);
+            }
+
+            FlPrintFile (ASL_FILE_MAP_OUTPUT,
+                "\n\nPin   Type     Direction    Polarity"
+                "    Dest _HID  Destination\n");
+        }
+
+        PrevDeviceName = Info->DeviceName;
+
+        /* Setup various strings based upon the type (GpioInt or GpioIo) */
+
+        switch (Info->Type)
+        {
+        case AML_RESOURCE_GPIO_TYPE_INT:
+
+            Type = "GpioInt";
+            Direction = "-Interrupt-";
+            Polarity = PolarityDecode[Info->Polarity];
+            break;
+
+        case AML_RESOURCE_GPIO_TYPE_IO:
+
+            Type = "GpioIo ";
+            Direction = DirectionDecode[Info->Direction];
+            Polarity = "          ";
+            break;
+
+        default:
+            continue;
+        }
+
+        /* Emit the GPIO info */
+
+        FlPrintFile (ASL_FILE_MAP_OUTPUT, "%4.4X  %s  %s  %s  ",
+            Info->PinNumber, Type, Direction, Polarity);
+
+        ParentPathname = NULL;
+        HidString = MpGetConnectionInfo (Info->Op, Info->PinIndex,
+            &Info->TargetNode, &ParentPathname);
+        if (HidString)
+        {
+            /*
+             * This is a Connection() field
+             * Attempt to find all references to the field.
+             */
+            FlPrintFile (ASL_FILE_MAP_OUTPUT, "%8s   %-28s",
+                HidString, ParentPathname);
+
+            MpXrefDevices (Info);
+        }
+        else
+        {
+            /*
+             * For Devices, attempt to get the _HID description string.
+             * Failing that (many _HIDs are not recognized), attempt to
+             * get the _DDN description string.
+             */
+            HidString = MpGetParentDeviceHid (Info->Op, &Info->TargetNode,
+                &ParentPathname);
+
+            FlPrintFile (ASL_FILE_MAP_OUTPUT, "%8s   %-28s",
+                HidString, ParentPathname);
+
+            /* Get the _HID description or _DDN string */
+
+            HidInfo = AcpiAhMatchHardwareId (HidString);
+            if (HidInfo)
+            {
+                FlPrintFile (ASL_FILE_MAP_OUTPUT, "  // %s",
+                    HidInfo->Description);
+            }
+            else if ((Description = MpGetDdnValue (ParentPathname)))
+            {
+                FlPrintFile (ASL_FILE_MAP_OUTPUT, "  // %s (_DDN)",
+                    Description);
+            }
+        }
+
+        FlPrintFile (ASL_FILE_MAP_OUTPUT, "\n");
+        ACPI_FREE (ParentPathname);
+        Info = Info->Next;
+    }
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    MpEmitSerialInfo
+ *
+ * PARAMETERS:  None
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Emit the info about all Serial devices found during the
+ *              compile or disassembly.
+ *
+ ******************************************************************************/
+
+static void
+MpEmitSerialInfo (
+    void)
+{
+    ACPI_SERIAL_INFO        *Info;
+    char                    *Type;
+    char                    *ParentPathname;
+    char                    *PrevDeviceName = NULL;
+    char                    *HidString;
+    const AH_DEVICE_ID      *HidInfo;
+    const char              *Description;
+    AML_RESOURCE            *Resource;
+
+
+    /* Walk the constructed serial descriptor list */
+
+    Info = Gbl_SerialList;
+    while (Info)
+    {
+        Resource = Info->Resource;
+        switch (Resource->CommonSerialBus.Type)
+        {
+        case AML_RESOURCE_I2C_SERIALBUSTYPE:
+            Type = "I2C ";
+            break;
+
+        case AML_RESOURCE_SPI_SERIALBUSTYPE:
+            Type = "SPI ";
+            break;
+
+        case AML_RESOURCE_UART_SERIALBUSTYPE:
+            Type = "UART";
+            break;
+
+        default:
+            Type = "UNKN";
+            break;
+        }
+
+        HidString = MpGetHidViaNamestring (Info->DeviceName);
+
+        /* Print header info for the controller itself */
+
+        if (!PrevDeviceName ||
+            strcmp (PrevDeviceName, Info->DeviceName))
+        {
+            FlPrintFile (ASL_FILE_MAP_OUTPUT, "\n\n%s Controller:  ",
+                Type);
+            FlPrintFile (ASL_FILE_MAP_OUTPUT, "%-8s  %-28s",
+                HidString, Info->DeviceName);
+
+            HidInfo = AcpiAhMatchHardwareId (HidString);
+            if (HidInfo)
+            {
+                FlPrintFile (ASL_FILE_MAP_OUTPUT, "  // %s",
+                    HidInfo->Description);
+            }
+
+            FlPrintFile (ASL_FILE_MAP_OUTPUT, "\n\n");
+            FlPrintFile (ASL_FILE_MAP_OUTPUT,
+                "Type  Address   Speed      Dest _HID  Destination\n");
+        }
+
+        PrevDeviceName = Info->DeviceName;
+
+        FlPrintFile (ASL_FILE_MAP_OUTPUT, "%s   %4.4X    %8.8X    ",
+            Type, Info->Address, Info->Speed);
+
+        ParentPathname = NULL;
+        HidString = MpGetConnectionInfo (Info->Op, 0, &Info->TargetNode,
+            &ParentPathname);
+        if (HidString)
+        {
+            /*
+             * This is a Connection() field
+             * Attempt to find all references to the field.
+             */
+            FlPrintFile (ASL_FILE_MAP_OUTPUT, "%8s   %-28s",
+                HidString, ParentPathname);
+        }
+        else
+        {
+            /* Normal resource template */
+
+            HidString = MpGetParentDeviceHid (Info->Op, &Info->TargetNode,
+                &ParentPathname);
+            FlPrintFile (ASL_FILE_MAP_OUTPUT, "%8s   %-28s",
+                HidString, ParentPathname);
+
+            /* Get the _HID description or _DDN string */
+
+            HidInfo = AcpiAhMatchHardwareId (HidString);
+            if (HidInfo)
+            {
+                FlPrintFile (ASL_FILE_MAP_OUTPUT, "  // %s",
+                    HidInfo->Description);
+            }
+            else if ((Description = MpGetDdnValue (ParentPathname)))
+            {
+                FlPrintFile (ASL_FILE_MAP_OUTPUT, "  // %s (_DDN)",
+                    Description);
+            }
+        }
+
+        FlPrintFile (ASL_FILE_MAP_OUTPUT, "\n");
+        ACPI_FREE (ParentPathname);
+        Info = Info->Next;
+    }
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    MpEmitDeviceTree
+ *
+ * PARAMETERS:  None
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Emit information about all devices within the ACPI namespace.
+ *
+ ******************************************************************************/
+
+static void
+MpEmitDeviceTree (
+    void)
+{
+
+    FlPrintFile (ASL_FILE_MAP_OUTPUT, "\n\nACPI Device Tree\n");
+    FlPrintFile (ASL_FILE_MAP_OUTPUT,     "----------------\n\n");
+
+    FlPrintFile (ASL_FILE_MAP_OUTPUT, "Device Pathname                   "
+        "_HID      Description\n\n");
+
+    /* Walk the namespace from the root */
+
+    (void) AcpiNsWalkNamespace (ACPI_TYPE_DEVICE, ACPI_ROOT_OBJECT,
+        ACPI_UINT32_MAX, FALSE, MpEmitOneDevice, NULL, NULL, NULL);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    MpEmitOneDevice
+ *
+ * PARAMETERS:  ACPI_NAMESPACE_WALK callback
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Emit information about one ACPI device in the namespace. Used
+ *              during dump of all device objects within the namespace.
+ *
+ ******************************************************************************/
+
+static ACPI_STATUS
+MpEmitOneDevice (
+    ACPI_HANDLE             ObjHandle,
+    UINT32                  NestingLevel,
+    void                    *Context,
+    void                    **ReturnValue)
+{
+    char                    *DevicePathname;
+    char                    *DdnString;
+    char                    *HidString;
+    const AH_DEVICE_ID      *HidInfo;
+
+
+    /* Device pathname */
+
+    DevicePathname = AcpiNsGetExternalPathname (
+        ACPI_CAST_PTR (ACPI_NAMESPACE_NODE, ObjHandle));
+
+    FlPrintFile (ASL_FILE_MAP_OUTPUT, "%-32s", DevicePathname);
+
+    /* _HID or _DDN */
+
+    HidString = MpGetHidValue (
+        ACPI_CAST_PTR (ACPI_NAMESPACE_NODE, ObjHandle));
+    FlPrintFile (ASL_FILE_MAP_OUTPUT, "%8s", HidString);
+
+    HidInfo = AcpiAhMatchHardwareId (HidString);
+    if (HidInfo)
+    {
+        FlPrintFile (ASL_FILE_MAP_OUTPUT, "    // %s",
+            HidInfo->Description);
+    }
+    else if ((DdnString = MpGetDdnValue (DevicePathname)))
+    {
+        FlPrintFile (ASL_FILE_MAP_OUTPUT, "    // %s (_DDN)", DdnString);
+    }
+
+    FlPrintFile (ASL_FILE_MAP_OUTPUT, "\n");
+    ACPI_FREE (DevicePathname);
+    return (AE_OK);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    MpXrefDevices
+ *
+ * PARAMETERS:  Info                    - A GPIO Info block
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Cross-reference the parse tree and find all references to the
+ *              specified GPIO device.
+ *
+ ******************************************************************************/
+
+static void
+MpXrefDevices (
+    ACPI_GPIO_INFO          *Info)
+{
+
+    /* Walk the entire parse tree */
+
+    TrWalkParseTree (Gbl_ParseTreeRoot, ASL_WALK_VISIT_DOWNWARD,
+        MpNamespaceXrefBegin, NULL, Info);
+
+    if (!Info->References)
+    {
+        FlPrintFile (ASL_FILE_MAP_OUTPUT, "  // **** No references in table");
+    }
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    MpNamespaceXrefBegin
+ *
+ * PARAMETERS:  WALK_PARSE_TREE callback
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Walk parse tree callback used to cross-reference GPIO pins.
+ *
+ ******************************************************************************/
+
+static ACPI_STATUS
+MpNamespaceXrefBegin (
+    ACPI_PARSE_OBJECT       *Op,
+    UINT32                  Level,
+    void                    *Context)
+{
+    ACPI_GPIO_INFO          *Info = ACPI_CAST_PTR (ACPI_GPIO_INFO, Context);
+    const ACPI_OPCODE_INFO  *OpInfo;
+    char                    *DevicePathname;
+    ACPI_PARSE_OBJECT       *ParentOp;
+    char                    *HidString;
+
+
+    ACPI_FUNCTION_TRACE_PTR (MpNamespaceXrefBegin, Op);
+
+    /*
+     * If this node is the actual declaration of a name
+     * [such as the XXXX name in "Method (XXXX)"],
+     * we are not interested in it here. We only care about names that
+     * are references to other objects within the namespace and the
+     * parent objects of name declarations
+     */
+    if (Op->Asl.CompileFlags & NODE_IS_NAME_DECLARATION)
+    {
+        return (AE_OK);
+    }
+
+    /* We are only interested in opcodes that have an associated name */
+
+    OpInfo = AcpiPsGetOpcodeInfo (Op->Asl.AmlOpcode);
+
+    if ((OpInfo->Flags & AML_NAMED) ||
+        (OpInfo->Flags & AML_CREATE))
+    {
+        return (AE_OK);
+    }
+
+    if ((Op->Asl.ParseOpcode != PARSEOP_NAMESTRING) &&
+        (Op->Asl.ParseOpcode != PARSEOP_NAMESEG)    &&
+        (Op->Asl.ParseOpcode != PARSEOP_METHODCALL))
+    {
+        return (AE_OK);
+    }
+
+    if (!Op->Asl.Node)
+    {
+        return (AE_OK);
+    }
+
+    ParentOp = Op->Asl.Parent;
+    if (ParentOp->Asl.ParseOpcode == PARSEOP_FIELD)
+    {
+        return (AE_OK);
+    }
+
+    if (Op->Asl.Node == Info->TargetNode)
+    {
+        while (ParentOp && (!ParentOp->Asl.Node))
+        {
+            ParentOp = ParentOp->Asl.Parent;
+        }
+
+        if (ParentOp)
+        {
+            DevicePathname = AcpiNsGetExternalPathname (
+                ParentOp->Asl.Node);
+
+            if (!Info->References)
+            {
+                FlPrintFile (ASL_FILE_MAP_OUTPUT, "  // References:");
+            }
+
+            HidString = MpGetHidViaNamestring (DevicePathname);
+
+            FlPrintFile (ASL_FILE_MAP_OUTPUT, " %s [%s]",
+                DevicePathname, HidString);
+
+            Info->References++;
+
+            ACPI_FREE (DevicePathname);
+        }
+    }
+
+    return (AE_OK);
+}
diff --git a/usr/src/cmd/acpi/iasl/aslmaputils.c b/usr/src/cmd/acpi/iasl/aslmaputils.c
new file mode 100644
index 0000000000..ebdab7daa7
--- /dev/null
+++ b/usr/src/cmd/acpi/iasl/aslmaputils.c
@@ -0,0 +1,402 @@
+/******************************************************************************
+ *
+ * Module Name: aslmaputils - Utilities for the resource descriptor/device maps
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2016, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include "acpi.h"
+#include "accommon.h"
+#include "acapps.h"
+#include "aslcompiler.h"
+#include "aslcompiler.y.h"
+#include "acinterp.h"
+#include "acnamesp.h"
+#include "amlcode.h"
+
+/* This module used for application-level code only */
+
+#define _COMPONENT          ACPI_COMPILER
+        ACPI_MODULE_NAME    ("aslmaputils")
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    MpGetHidFromParseTree
+ *
+ * PARAMETERS:  HidNode             - Node for a _HID object
+ *
+ * RETURN:      An _HID string value. Automatically converts _HID integers
+ *              to strings. Never NULL.
+ *
+ * DESCRIPTION: Extract a _HID value from the parse tree, not the namespace.
+ *              Used when a fully initialized namespace is not available.
+ *
+ ******************************************************************************/
+
+char *
+MpGetHidFromParseTree (
+    ACPI_NAMESPACE_NODE     *HidNode)
+{
+    ACPI_PARSE_OBJECT       *Op;
+    ACPI_PARSE_OBJECT       *Arg;
+    char                    *HidString;
+
+
+    Op = HidNode->Op;
+
+    switch (Op->Asl.ParseOpcode)
+    {
+    case PARSEOP_NAME:
+
+        Arg = Op->Asl.Child;  /* Get the NameSeg/NameString node */
+        Arg = Arg->Asl.Next;  /* First peer is the object to be associated with the name */
+
+        switch (Arg->Asl.ParseOpcode)
+        {
+        case PARSEOP_STRING_LITERAL:
+
+            return (Arg->Asl.Value.String);
+
+        case PARSEOP_INTEGER:
+
+            /* Convert EISAID to a string */
+
+            HidString = UtStringCacheCalloc (ACPI_EISAID_STRING_SIZE);
+            AcpiExEisaIdToString (HidString, Arg->Asl.Value.Integer);
+            return (HidString);
+
+        default:
+
+            return ("UNKNOWN");
+        }
+
+    default:
+        return ("-No HID-");
+    }
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    MpGetHidValue
+ *
+ * PARAMETERS:  DeviceNode          - Node for parent device
+ *
+ * RETURN:      An _HID string value. Automatically converts _HID integers
+ *              to strings. Never NULL.
+ *
+ * DESCRIPTION: Extract _HID value from within a device scope. Does not
+ *              actually execute a method, just gets the string or integer
+ *              value for the _HID.
+ *
+ ******************************************************************************/
+
+char *
+MpGetHidValue (
+    ACPI_NAMESPACE_NODE     *DeviceNode)
+{
+    ACPI_NAMESPACE_NODE     *HidNode;
+    char                    *HidString;
+    ACPI_STATUS             Status;
+
+
+    Status = AcpiNsGetNode (DeviceNode, METHOD_NAME__HID,
+        ACPI_NS_NO_UPSEARCH, &HidNode);
+    if (ACPI_FAILURE (Status))
+    {
+        goto ErrorExit;
+    }
+
+    /* If only partial namespace, get the _HID from the parse tree */
+
+    if (!HidNode->Object)
+    {
+        return (MpGetHidFromParseTree (HidNode));
+    }
+
+    /* Handle the different _HID flavors */
+
+    switch (HidNode->Type)
+    {
+    case ACPI_TYPE_STRING:
+
+        return (HidNode->Object->String.Pointer);
+
+    case ACPI_TYPE_INTEGER:
+
+        /* Convert EISAID to a string */
+
+        HidString = UtStringCacheCalloc (ACPI_EISAID_STRING_SIZE);
+        AcpiExEisaIdToString (HidString, HidNode->Object->Integer.Value);
+        return (HidString);
+
+    case ACPI_TYPE_METHOD:
+
+        return ("-Method-");
+
+    default:
+
+        FlPrintFile (ASL_FILE_MAP_OUTPUT, "BAD HID TYPE: %u", HidNode->Type);
+        break;
+    }
+
+
+ErrorExit:
+    return ("-No HID-");
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    MpGetHidViaNamestring
+ *
+ * PARAMETERS:  DeviceName          - Namepath for parent device
+ *
+ * RETURN:      _HID string. Never NULL.
+ *
+ * DESCRIPTION: Get a _HID value via a device pathname (instead of just simply
+ *              a device node.)
+ *
+ ******************************************************************************/
+
+char *
+MpGetHidViaNamestring (
+    char                    *DeviceName)
+{
+    ACPI_NAMESPACE_NODE     *DeviceNode;
+    ACPI_STATUS             Status;
+
+
+    Status = AcpiNsGetNode (NULL, DeviceName, ACPI_NS_NO_UPSEARCH,
+        &DeviceNode);
+    if (ACPI_FAILURE (Status))
+    {
+        goto ErrorExit;
+    }
+
+    return (MpGetHidValue (DeviceNode));
+
+
+ErrorExit:
+    return ("-No HID-");
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    MpGetParentDeviceHid
+ *
+ * PARAMETERS:  Op                      - Parse Op to be examined
+ *              TargetNode              - Where the field node is returned
+ *              ParentDeviceName        - Where the node path is returned
+ *
+ * RETURN:      _HID string. Never NULL.
+ *
+ * DESCRIPTION: Find the parent Device or Scope Op, get the full pathname to
+ *              the parent, and get the _HID associated with the parent.
+ *
+ ******************************************************************************/
+
+char *
+MpGetParentDeviceHid (
+    ACPI_PARSE_OBJECT       *Op,
+    ACPI_NAMESPACE_NODE     **TargetNode,
+    char                    **ParentDeviceName)
+{
+    ACPI_NAMESPACE_NODE     *DeviceNode;
+
+
+    /* Find parent Device() or Scope() Op */
+
+    while (Op &&
+        (Op->Asl.AmlOpcode != AML_DEVICE_OP) &&
+        (Op->Asl.AmlOpcode != AML_SCOPE_OP))
+    {
+        Op = Op->Asl.Parent;
+    }
+
+    if (!Op)
+    {
+        FlPrintFile (ASL_FILE_MAP_OUTPUT, " No_Parent_Device ");
+        goto ErrorExit;
+    }
+
+    /* Get the full pathname to the device and the _HID */
+
+    DeviceNode = Op->Asl.Node;
+    if (!DeviceNode)
+    {
+        FlPrintFile (ASL_FILE_MAP_OUTPUT, " No_Device_Node ");
+        goto ErrorExit;
+    }
+
+    *ParentDeviceName = AcpiNsGetExternalPathname (DeviceNode);
+    return (MpGetHidValue (DeviceNode));
+
+
+ErrorExit:
+    return ("-No HID-");
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    MpGetDdnValue
+ *
+ * PARAMETERS:  DeviceName          - Namepath for parent device
+ *
+ * RETURN:      _DDN description string. NULL on failure.
+ *
+ * DESCRIPTION: Execute the _DDN method for the device.
+ *
+ ******************************************************************************/
+
+char *
+MpGetDdnValue (
+    char                    *DeviceName)
+{
+    ACPI_NAMESPACE_NODE     *DeviceNode;
+    ACPI_NAMESPACE_NODE     *DdnNode;
+    ACPI_STATUS             Status;
+
+
+    Status = AcpiNsGetNode (NULL, DeviceName, ACPI_NS_NO_UPSEARCH,
+        &DeviceNode);
+    if (ACPI_FAILURE (Status))
+    {
+        goto ErrorExit;
+    }
+
+    Status = AcpiNsGetNode (DeviceNode, METHOD_NAME__DDN, ACPI_NS_NO_UPSEARCH,
+        &DdnNode);
+    if (ACPI_FAILURE (Status))
+    {
+        goto ErrorExit;
+    }
+
+    if ((DdnNode->Type != ACPI_TYPE_STRING) ||
+        !DdnNode->Object)
+    {
+        goto ErrorExit;
+    }
+
+    return (DdnNode->Object->String.Pointer);
+
+
+ErrorExit:
+    return (NULL);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    MpGetConnectionInfo
+ *
+ * PARAMETERS:  Op                      - Parse Op to be examined
+ *              PinIndex                - Index into GPIO PinList
+ *              TargetNode              - Where the field node is returned
+ *              TargetName              - Where the node path is returned
+ *
+ * RETURN:      A substitute _HID string, indicating that the name is actually
+ *              a field. NULL if the Op does not refer to a Connection.
+ *
+ * DESCRIPTION: Get the Field Unit that corresponds to the PinIndex after
+ *              a Connection() invocation.
+ *
+ ******************************************************************************/
+
+char *
+MpGetConnectionInfo (
+    ACPI_PARSE_OBJECT       *Op,
+    UINT32                  PinIndex,
+    ACPI_NAMESPACE_NODE     **TargetNode,
+    char                    **TargetName)
+{
+    ACPI_PARSE_OBJECT       *NextOp;
+    UINT32                  i;
+
+
+    /*
+     * Handle Connection() here. Find the next named FieldUnit.
+     * Note: we look at the ParseOpcode for the compiler, look
+     * at the AmlOpcode for the disassembler.
+     */
+    if ((Op->Asl.AmlOpcode == AML_INT_CONNECTION_OP) ||
+        (Op->Asl.ParseOpcode == PARSEOP_CONNECTION))
+    {
+        /* Find the correct field unit definition */
+
+        NextOp = Op;
+        for (i = 0; i <= PinIndex;)
+        {
+            NextOp = NextOp->Asl.Next;
+            while (NextOp &&
+                (NextOp->Asl.ParseOpcode != PARSEOP_NAMESEG) &&
+                (NextOp->Asl.AmlOpcode != AML_INT_NAMEDFIELD_OP))
+            {
+                NextOp = NextOp->Asl.Next;
+            }
+
+            if (!NextOp)
+            {
+                return ("UNKNOWN");
+            }
+
+            /* Add length of this field to the current pin index */
+
+            if (NextOp->Asl.ParseOpcode == PARSEOP_NAMESEG)
+            {
+                i += (UINT32) NextOp->Asl.Child->Asl.Value.Integer;
+            }
+            else /* AML_INT_NAMEDFIELD_OP */
+            {
+                i += (UINT32) NextOp->Asl.Value.Integer;
+            }
+        }
+
+        /* Return the node and pathname for the field unit */
+
+        *TargetNode = NextOp->Asl.Node;
+        *TargetName = AcpiNsGetExternalPathname (*TargetNode);
+        return ("-Field-");
+    }
+
+    return (NULL);
+}
diff --git a/usr/src/cmd/acpi/iasl/aslmessages.c b/usr/src/cmd/acpi/iasl/aslmessages.c
new file mode 100644
index 0000000000..7a6506b8a9
--- /dev/null
+++ b/usr/src/cmd/acpi/iasl/aslmessages.c
@@ -0,0 +1,415 @@
+/******************************************************************************
+ *
+ * Module Name: aslmessages.c - Compiler error/warning message strings
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2016, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include "aslcompiler.h"
+
+#define _COMPONENT          ACPI_COMPILER
+        ACPI_MODULE_NAME    ("aslmessages")
+
+
+/*
+ * Strings for message reporting levels, must match error
+ * type string tables in aslmessages.c
+ */
+const char              *AslErrorLevel [ASL_NUM_REPORT_LEVELS] = {
+    "Optimize",
+    "Remark  ",
+    "Warning ",
+    "Warning ",
+    "Warning ",
+    "Error   "
+};
+
+/* All lowercase versions for IDEs */
+
+const char              *AslErrorLevelIde [ASL_NUM_REPORT_LEVELS] = {
+    "optimize",
+    "remark  ",
+    "warning ",
+    "warning ",
+    "warning ",
+    "error   "
+};
+
+
+/*
+ * Actual message strings for each compiler message ID. There are currently
+ * three distinct blocks of error messages (so that they can be expanded
+ * individually):
+ *      Main ASL compiler
+ *      Data Table compiler
+ *      Preprocessor
+ *
+ * NOTE1: These tables must match the enum list of message IDs in the file
+ * aslmessages.h exactly.
+ *
+ * NOTE2: With the introduction of the -vw option to disable specific messages,
+ * new messages should only be added to the end of this list, so that values
+ * for existing messages are not disturbed.
+ */
+
+/* ASL compiler */
+
+const char                      *AslCompilerMsgs [] =
+{
+/*    The zeroth message is reserved */    "",
+/*    ASL_MSG_ALIGNMENT */                  "Must be a multiple of alignment/granularity value",
+/*    ASL_MSG_ALPHANUMERIC_STRING */        "String must be entirely alphanumeric",
+/*    ASL_MSG_AML_NOT_IMPLEMENTED */        "Opcode is not implemented in compiler AML code generator",
+/*    ASL_MSG_ARG_COUNT_HI */               "Too many arguments",
+/*    ASL_MSG_ARG_COUNT_LO */               "Too few arguments",
+/*    ASL_MSG_ARG_INIT */                   "Method argument is not initialized",
+/*    ASL_MSG_BACKWARDS_OFFSET */           "Invalid backwards offset",
+/*    ASL_MSG_BUFFER_LENGTH */              "Effective AML buffer length is zero",
+/*    ASL_MSG_CLOSE */                      "Could not close file",
+/*    ASL_MSG_COMPILER_INTERNAL */          "Internal compiler error",
+/*    ASL_MSG_COMPILER_RESERVED */          "Use of compiler reserved name",
+/*    ASL_MSG_CONNECTION_MISSING */         "A Connection operator is required for this field SpaceId",
+/*    ASL_MSG_CONNECTION_INVALID */         "Invalid OpRegion SpaceId for use of Connection operator",
+/*    ASL_MSG_CONSTANT_EVALUATION */        "Could not evaluate constant expression",
+/*    ASL_MSG_CONSTANT_FOLDED */            "Constant expression evaluated and reduced",
+/*    ASL_MSG_CORE_EXCEPTION */             "From ACPICA Subsystem",
+/*    ASL_MSG_DEBUG_FILE_OPEN */            "Could not open debug file",
+/*    ASL_MSG_DEBUG_FILENAME */             "Could not create debug filename",
+/*    ASL_MSG_DEPENDENT_NESTING */          "Dependent function macros cannot be nested",
+/*    ASL_MSG_DMA_CHANNEL */                "Invalid DMA channel (must be 0-7)",
+/*    ASL_MSG_DMA_LIST */                   "Too many DMA channels (8 max)",
+/*    ASL_MSG_DUPLICATE_CASE */             "Case value already specified",
+/*    ASL_MSG_DUPLICATE_ITEM */             "Duplicate value in list",
+/*    ASL_MSG_EARLY_EOF */                  "Premature end-of-file reached",
+/*    ASL_MSG_ENCODING_LENGTH */            "Package length too long to encode",
+/*    ASL_MSG_EX_INTERRUPT_LIST */          "Too many interrupts (255 max)",
+/*    ASL_MSG_EX_INTERRUPT_LIST_MIN */      "Too few interrupts (1 minimum required)",
+/*    ASL_MSG_EX_INTERRUPT_NUMBER */        "Invalid interrupt number (must be 32 bits)",
+/*    ASL_MSG_FIELD_ACCESS_WIDTH */         "Access width is greater than region size",
+/*    ASL_MSG_FIELD_UNIT_ACCESS_WIDTH */    "Access width of Field Unit extends beyond region limit",
+/*    ASL_MSG_FIELD_UNIT_OFFSET */          "Field Unit extends beyond region limit",
+/*    ASL_MSG_GPE_NAME_CONFLICT */          "Name conflicts with a previous GPE method",
+/*    ASL_MSG_HID_LENGTH */                 "_HID string must be exactly 7 or 8 characters",
+/*    ASL_MSG_HID_PREFIX */                 "_HID prefix must be all uppercase or decimal digits",
+/*    ASL_MSG_HID_SUFFIX */                 "_HID suffix must be all hex digits",
+/*    ASL_MSG_INCLUDE_FILE_OPEN */          "Could not open include file",
+/*    ASL_MSG_INPUT_FILE_OPEN */            "Could not open input file",
+/*    ASL_MSG_INTEGER_LENGTH */             "64-bit integer in 32-bit table, truncating (DSDT or SSDT version < 2)",
+/*    ASL_MSG_INTEGER_OPTIMIZATION */       "Integer optimized to single-byte AML opcode",
+/*    ASL_MSG_INTERRUPT_LIST */             "Too many interrupts (16 max)",
+/*    ASL_MSG_INTERRUPT_NUMBER */           "Invalid interrupt number (must be 0-15)",
+/*    ASL_MSG_INVALID_ACCESS_SIZE */        "Invalid AccessSize (Maximum is 4 - QWord access)",
+/*    ASL_MSG_INVALID_ADDR_FLAGS */         "Invalid combination of Length and Min/Max fixed flags",
+/*    ASL_MSG_INVALID_CONSTANT_OP */        "Invalid operator in constant expression (not type 3/4/5)",
+/*    ASL_MSG_INVALID_EISAID */             "EISAID string must be of the form \"UUUXXXX\" (3 uppercase, 4 hex digits)",
+/*    ASL_MSG_INVALID_ESCAPE */             "Invalid or unknown escape sequence",
+/*    ASL_MSG_INVALID_GRAN_FIXED */         "Granularity must be zero for fixed Min/Max",
+/*    ASL_MSG_INVALID_GRANULARITY */        "Granularity must be zero or a power of two minus one",
+/*    ASL_MSG_INVALID_LENGTH */             "Length is larger than Min/Max window",
+/*    ASL_MSG_INVALID_LENGTH_FIXED */       "Length is not equal to fixed Min/Max window",
+/*    ASL_MSG_INVALID_MIN_MAX */            "Address Min is greater than Address Max",
+/*    ASL_MSG_INVALID_OPERAND */            "Invalid operand",
+/*    ASL_MSG_INVALID_PERFORMANCE */        "Invalid performance/robustness value",
+/*    ASL_MSG_INVALID_PRIORITY */           "Invalid priority value",
+/*    ASL_MSG_INVALID_STRING */             "Invalid Hex/Octal Escape - Non-ASCII or NULL",
+/*    ASL_MSG_INVALID_TARGET */             "Target operand not allowed in constant expression",
+/*    ASL_MSG_INVALID_TIME */               "Time parameter too long (255 max)",
+/*    ASL_MSG_INVALID_TYPE */               "Invalid type",
+/*    ASL_MSG_INVALID_UUID */               "UUID string must be of the form \"aabbccdd-eeff-gghh-iijj-kkllmmnnoopp\"",
+/*    ASL_MSG_ISA_ADDRESS */                "Maximum 10-bit ISA address (0x3FF)",
+/*    ASL_MSG_LEADING_ASTERISK */           "Invalid leading asterisk",
+/*    ASL_MSG_LIST_LENGTH_LONG */           "Initializer list longer than declared package length",
+/*    ASL_MSG_LIST_LENGTH_SHORT */          "Initializer list shorter than declared package length",
+/*    ASL_MSG_LISTING_FILE_OPEN */          "Could not open listing file",
+/*    ASL_MSG_LISTING_FILENAME */           "Could not create listing filename",
+/*    ASL_MSG_LOCAL_INIT */                 "Method local variable is not initialized",
+/*    ASL_MSG_LOCAL_OUTSIDE_METHOD */       "Local or Arg used outside a control method",
+/*    ASL_MSG_LONG_LINE */                  "Splitting long input line",
+/*    ASL_MSG_MEMORY_ALLOCATION */          "Memory allocation failure",
+/*    ASL_MSG_MISSING_ENDDEPENDENT */       "Missing EndDependentFn() macro in dependent resource list",
+/*    ASL_MSG_MISSING_STARTDEPENDENT */     "Missing StartDependentFn() macro in dependent resource list",
+/*    ASL_MSG_MULTIPLE_DEFAULT */           "More than one Default statement within Switch construct",
+/*    ASL_MSG_MULTIPLE_TYPES */             "Multiple types",
+/*    ASL_MSG_NAME_EXISTS */                "Name already exists in scope",
+/*    ASL_MSG_NAME_OPTIMIZATION */          "NamePath optimized",
+/*    ASL_MSG_NAMED_OBJECT_IN_WHILE */      "Creating a named object in a While loop",
+/*    ASL_MSG_NESTED_COMMENT */             "Nested comment found",
+/*    ASL_MSG_NO_CASES */                   "No Case statements under Switch",
+/*    ASL_MSG_NO_REGION */                  "_REG has no corresponding Operation Region",
+/*    ASL_MSG_NO_RETVAL */                  "Called method returns no value",
+/*    ASL_MSG_NO_WHILE */                   "No enclosing While statement",
+/*    ASL_MSG_NON_ASCII */                  "Invalid characters found in file",
+/*    ASL_MSG_NON_ZERO */                   "Operand evaluates to zero",
+/*    ASL_MSG_NOT_EXIST */                  "Object does not exist",
+/*    ASL_MSG_NOT_FOUND */                  "Object not found or not accessible from scope",
+/*    ASL_MSG_NOT_METHOD */                 "Not a control method, cannot invoke",
+/*    ASL_MSG_NOT_PARAMETER */              "Not a parameter, used as local only",
+/*    ASL_MSG_NOT_REACHABLE */              "Object is not accessible from this scope",
+/*    ASL_MSG_NOT_REFERENCED */             "Object is not referenced",
+/*    ASL_MSG_NULL_DESCRIPTOR */            "Min/Max/Length/Gran are all zero, but no resource tag",
+/*    ASL_MSG_NULL_STRING */                "Invalid zero-length (null) string",
+/*    ASL_MSG_OPEN */                       "Could not open file",
+/*    ASL_MSG_OUTPUT_FILE_OPEN */           "Could not open output AML file",
+/*    ASL_MSG_OUTPUT_FILENAME */            "Could not create output filename",
+/*    ASL_MSG_PACKAGE_LENGTH */             "Effective AML package length is zero",
+/*    ASL_MSG_PREPROCESSOR_FILENAME */      "Could not create preprocessor filename",
+/*    ASL_MSG_READ */                       "Could not read file",
+/*    ASL_MSG_RECURSION */                  "Recursive method call",
+/*    ASL_MSG_REGION_BUFFER_ACCESS */       "Host Operation Region requires BufferAcc access",
+/*    ASL_MSG_REGION_BYTE_ACCESS */         "Host Operation Region requires ByteAcc access",
+/*    ASL_MSG_RESERVED_ARG_COUNT_HI */      "Reserved method has too many arguments",
+/*    ASL_MSG_RESERVED_ARG_COUNT_LO */      "Reserved method has too few arguments",
+/*    ASL_MSG_RESERVED_METHOD */            "Reserved name must be a control method",
+/*    ASL_MSG_RESERVED_NO_RETURN_VAL */     "Reserved method should not return a value",
+/*    ASL_MSG_RESERVED_OPERAND_TYPE */      "Invalid object type for reserved name",
+/*    ASL_MSG_RESERVED_PACKAGE_LENGTH */    "Invalid package length for reserved name",
+/*    ASL_MSG_RESERVED_RETURN_VALUE */      "Reserved method must return a value",
+/*    ASL_MSG_RESERVED_USE */               "Invalid use of reserved name",
+/*    ASL_MSG_RESERVED_WORD */              "Use of reserved name",
+/*    ASL_MSG_RESOURCE_FIELD */             "Resource field name cannot be used as a target",
+/*    ASL_MSG_RESOURCE_INDEX */             "Missing ResourceSourceIndex (required)",
+/*    ASL_MSG_RESOURCE_LIST */              "Too many resource items (internal error)",
+/*    ASL_MSG_RESOURCE_SOURCE */            "Missing ResourceSource string (required)",
+/*    ASL_MSG_RESULT_NOT_USED */            "Result is not used, operator has no effect",
+/*    ASL_MSG_RETURN_TYPES */               "Not all control paths return a value",
+/*    ASL_MSG_SCOPE_FWD_REF */              "Forward references from Scope operator not allowed",
+/*    ASL_MSG_SCOPE_TYPE */                 "Existing object has invalid type for Scope operator",
+/*    ASL_MSG_SEEK */                       "Could not seek file",
+/*    ASL_MSG_SERIALIZED */                 "Control Method marked Serialized",
+/*    ASL_MSG_SERIALIZED_REQUIRED */        "Control Method should be made Serialized",
+/*    ASL_MSG_SINGLE_NAME_OPTIMIZATION */   "NamePath optimized to NameSeg (uses run-time search path)",
+/*    ASL_MSG_SOME_NO_RETVAL */             "Called method may not always return a value",
+/*    ASL_MSG_STRING_LENGTH */              "String literal too long",
+/*    ASL_MSG_SWITCH_TYPE */                "Switch expression is not a static Integer/Buffer/String data type, defaulting to Integer",
+/*    ASL_MSG_SYNC_LEVEL */                 "SyncLevel must be in the range 0-15",
+/*    ASL_MSG_SYNTAX */                     "",
+/*    ASL_MSG_TABLE_SIGNATURE */            "Invalid Table Signature",
+/*    ASL_MSG_TAG_LARGER */                 "ResourceTag larger than Field",
+/*    ASL_MSG_TAG_SMALLER */                "ResourceTag smaller than Field",
+/*    ASL_MSG_TIMEOUT */                    "Result is not used, possible operator timeout will be missed",
+/*    ASL_MSG_TOO_MANY_TEMPS */             "Method requires too many temporary variables (_T_x)",
+/*    ASL_MSG_TRUNCATION */                 "64-bit return value will be truncated to 32 bits (DSDT or SSDT version < 2)",
+/*    ASL_MSG_UNKNOWN_RESERVED_NAME */      "Unknown reserved name",
+/*    ASL_MSG_UNREACHABLE_CODE */           "Statement is unreachable",
+/*    ASL_MSG_UNSUPPORTED */                "Unsupported feature",
+/*    ASL_MSG_UPPER_CASE */                 "Non-hex letters must be upper case",
+/*    ASL_MSG_VENDOR_LIST */                "Too many vendor data bytes (7 max)",
+/*    ASL_MSG_WRITE */                      "Could not write file",
+/*    ASL_MSG_RANGE */                      "Constant out of range",
+/*    ASL_MSG_BUFFER_ALLOCATION */          "Could not allocate line buffer",
+/*    ASL_MSG_MISSING_DEPENDENCY */         "Missing dependency",
+/*    ASL_MSG_ILLEGAL_FORWARD_REF */        "Illegal forward reference within a method",
+/*    ASL_MSG_ILLEGAL_METHOD_REF */         "Illegal reference across two methods",
+/*    ASL_MSG_LOCAL_NOT_USED */             "Method Local is set but never used",
+/*    ASL_MSG_ARG_AS_LOCAL_NOT_USED */      "Method Argument (as a local) is set but never used",
+/*    ASL_MSG_ARG_NOT_USED */               "Method Argument is never used",
+/*    ASL_MSG_CONSTANT_REQUIRED */          "Non-reducible expression",
+/*    ASL_MSG_CROSS_TABLE_SCOPE */          "Illegal open scope on external object from within DSDT"
+};
+
+/* Table compiler */
+
+const char                      *AslTableCompilerMsgs [] =
+{
+/*    ASL_MSG_BUFFER_ELEMENT */             "Invalid element in buffer initializer list",
+/*    ASL_MSG_DIVIDE_BY_ZERO */             "Expression contains divide-by-zero",
+/*    ASL_MSG_FLAG_VALUE */                 "Flag value is too large",
+/*    ASL_MSG_INTEGER_SIZE */               "Integer too large for target",
+/*    ASL_MSG_INVALID_EXPRESSION */         "Invalid expression",
+/*    ASL_MSG_INVALID_FIELD_NAME */         "Invalid Field Name",
+/*    ASL_MSG_INVALID_HEX_INTEGER */        "Invalid hex integer constant",
+/*    ASL_MSG_OEM_TABLE */                  "OEM table - unknown contents",
+/*    ASL_MSG_RESERVED_VALUE */             "Reserved field",
+/*    ASL_MSG_UNKNOWN_LABEL */              "Label is undefined",
+/*    ASL_MSG_UNKNOWN_SUBTABLE */           "Unknown subtable type",
+/*    ASL_MSG_UNKNOWN_TABLE */              "Unknown ACPI table signature",
+/*    ASL_MSG_ZERO_VALUE */                 "Value must be non-zero"
+};
+
+/* Preprocessor */
+
+const char                      *AslPreprocessorMsgs [] =
+{
+/*    ASL_MSG_DIRECTIVE_SYNTAX */           "Invalid directive syntax",
+/*    ASL_MSG_ENDIF_MISMATCH */             "Mismatched #endif",
+/*    ASL_MSG_ERROR_DIRECTIVE */            "#error",
+/*    ASL_MSG_EXISTING_NAME */              "Name is already defined",
+/*    ASL_MSG_INVALID_INVOCATION */         "Invalid macro invocation",
+/*    ASL_MSG_MACRO_SYNTAX */               "Invalid macro syntax",
+/*    ASL_MSG_TOO_MANY_ARGUMENTS */         "Too many macro arguments",
+/*    ASL_MSG_UNKNOWN_DIRECTIVE */          "Unknown directive",
+/*    ASL_MSG_UNKNOWN_PRAGMA */             "Unknown pragma",
+/*    ASL_MSG_WARNING_DIRECTIVE */          "#warning",
+/*    ASL_MSG_INCLUDE_FILE */               "Found a # preprocessor directive in ASL Include() file"
+};
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AeDecodeMessageId
+ *
+ * PARAMETERS:  MessageId               - ASL message ID (exception code) to be
+ *                                        formatted. Possibly fully encoded.
+ *
+ * RETURN:      A string containing the exception message text.
+ *
+ * DESCRIPTION: This function validates and translates an ASL message ID into
+ *              an ASCII string.
+ *
+ ******************************************************************************/
+
+const char *
+AeDecodeMessageId (
+    UINT16                  MessageId)
+{
+    UINT32                  Index;
+    const char              **MessageTable;
+
+
+    /* Main ASL Compiler messages */
+
+    if (MessageId <= ASL_MSG_MAIN_COMPILER_END)
+    {
+        MessageTable = AslCompilerMsgs;
+        Index = MessageId;
+
+        if (Index >= ACPI_ARRAY_LENGTH (AslCompilerMsgs))
+        {
+            return ("[Unknown ASL Compiler exception ID]");
+        }
+    }
+
+    /* Data Table Compiler messages */
+
+    else if (MessageId <= ASL_MSG_TABLE_COMPILER_END)
+    {
+        MessageTable = AslTableCompilerMsgs;
+        Index = MessageId - ASL_MSG_TABLE_COMPILER;
+
+        if (Index >= ACPI_ARRAY_LENGTH (AslTableCompilerMsgs))
+        {
+            return ("[Unknown Table Compiler exception ID]");
+        }
+    }
+
+    /* Preprocessor messages */
+
+    else if (MessageId <= ASL_MSG_PREPROCESSOR_END)
+    {
+        MessageTable = AslPreprocessorMsgs;
+        Index = MessageId - ASL_MSG_PREPROCESSOR;
+
+        if (Index >= ACPI_ARRAY_LENGTH (AslPreprocessorMsgs))
+        {
+            return ("[Unknown Preprocessor exception ID]");
+        }
+    }
+
+    /* Everything else is unknown */
+
+    else
+    {
+        return ("[Unknown exception/component ID]");
+    }
+
+    return (MessageTable[Index]);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AeDecodeExceptionLevel
+ *
+ * PARAMETERS:  Level               - The ASL error level to be decoded
+ *
+ * RETURN:      A string containing the error level text
+ *
+ * DESCRIPTION: This function validates and translates an ASL error level into
+ *              an ASCII string.
+ *
+ ******************************************************************************/
+
+const char *
+AeDecodeExceptionLevel (
+    UINT8                   Level)
+{
+    /* Range check on Level */
+
+    if (Level >= ACPI_ARRAY_LENGTH (AslErrorLevel))
+    {
+        return ("Unknown exception level");
+    }
+
+    /* Differentiate the string type to be used (IDE is all lower case) */
+
+    if (Gbl_VerboseErrors)
+    {
+        return (AslErrorLevel[Level]);
+    }
+
+    return (AslErrorLevelIde[Level]);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AeBuildFullExceptionCode
+ *
+ * PARAMETERS:  Level               - ASL error level
+ *              MessageId           - ASL exception code to be formatted
+ *
+ * RETURN:      Fully encoded exception code
+ *
+ * DESCRIPTION: Build the full exception code from the error level and the
+ *              actual message ID.
+ *
+ ******************************************************************************/
+
+UINT16
+AeBuildFullExceptionCode (
+    UINT8                   Level,
+    UINT16                  MessageId)
+{
+
+    /*
+     * Error level is in the thousands slot (error/warning/remark, etc.)
+     * Error codes are 0 - 999
+     */
+    return (((Level + 1) * 1000) + MessageId);
+}
diff --git a/usr/src/cmd/acpi/iasl/aslmessages.h b/usr/src/cmd/acpi/iasl/aslmessages.h
new file mode 100644
index 0000000000..0ee063fa59
--- /dev/null
+++ b/usr/src/cmd/acpi/iasl/aslmessages.h
@@ -0,0 +1,280 @@
+/******************************************************************************
+ *
+ * Module Name: aslmessages.h - Compiler error/warning messages
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2016, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#ifndef __ASLMESSAGES_H
+#define __ASLMESSAGES_H
+
+
+/* These values must match error type string tables in aslmessages.c */
+
+typedef enum
+{
+    ASL_OPTIMIZATION = 0,
+    ASL_REMARK,
+    ASL_WARNING,
+    ASL_WARNING2,
+    ASL_WARNING3,
+    ASL_ERROR,
+    ASL_NUM_REPORT_LEVELS
+
+} ASL_MESSAGE_TYPES;
+
+
+#define ASL_ERROR_LEVEL_LENGTH          8 /* Length of strings for types above */
+
+/*
+ * Exception code blocks, 0 - 999
+ * Available for new exception blocks: 600 - 999
+ */
+#define ASL_MSG_MAIN_COMPILER           0       /* 0 - 299 */
+#define ASL_MSG_MAIN_COMPILER_END       299
+
+#define ASL_MSG_TABLE_COMPILER          300     /* 300 - 499 */
+#define ASL_MSG_TABLE_COMPILER_END      499
+
+#define ASL_MSG_PREPROCESSOR            500     /* 500 - 599 */
+#define ASL_MSG_PREPROCESSOR_END        599
+
+
+/*
+ * Values (message IDs) for all compiler messages. There are currently
+ * three distinct blocks of error messages (so that they can be expanded
+ * individually):
+ *      Main ASL compiler
+ *      Data Table compiler
+ *      Preprocessor
+ *
+ * NOTE1: This list must match the tables of message strings in the file
+ * aslmessages.c exactly.
+ *
+ * NOTE2: With the introduction of the -vw option to disable specific
+ * messages, new messages should only be added to the end of these
+ * lists, so that values for existing messages are not disturbed.
+ */
+typedef enum
+{
+    ASL_MSG_RESERVED = ASL_MSG_MAIN_COMPILER,
+
+    ASL_MSG_ALIGNMENT,
+    ASL_MSG_ALPHANUMERIC_STRING,
+    ASL_MSG_AML_NOT_IMPLEMENTED,
+    ASL_MSG_ARG_COUNT_HI,
+    ASL_MSG_ARG_COUNT_LO,
+    ASL_MSG_ARG_INIT,
+    ASL_MSG_BACKWARDS_OFFSET,
+    ASL_MSG_BUFFER_LENGTH,
+    ASL_MSG_CLOSE,
+    ASL_MSG_COMPILER_INTERNAL,
+    ASL_MSG_COMPILER_RESERVED,
+    ASL_MSG_CONNECTION_MISSING,
+    ASL_MSG_CONNECTION_INVALID,
+    ASL_MSG_CONSTANT_EVALUATION,
+    ASL_MSG_CONSTANT_FOLDED,
+    ASL_MSG_CORE_EXCEPTION,
+    ASL_MSG_DEBUG_FILE_OPEN,
+    ASL_MSG_DEBUG_FILENAME,
+    ASL_MSG_DEPENDENT_NESTING,
+    ASL_MSG_DMA_CHANNEL,
+    ASL_MSG_DMA_LIST,
+    ASL_MSG_DUPLICATE_CASE,
+    ASL_MSG_DUPLICATE_ITEM,
+    ASL_MSG_EARLY_EOF,
+    ASL_MSG_ENCODING_LENGTH,
+    ASL_MSG_EX_INTERRUPT_LIST,
+    ASL_MSG_EX_INTERRUPT_LIST_MIN,
+    ASL_MSG_EX_INTERRUPT_NUMBER,
+    ASL_MSG_FIELD_ACCESS_WIDTH,
+    ASL_MSG_FIELD_UNIT_ACCESS_WIDTH,
+    ASL_MSG_FIELD_UNIT_OFFSET,
+    ASL_MSG_GPE_NAME_CONFLICT,
+    ASL_MSG_HID_LENGTH,
+    ASL_MSG_HID_PREFIX,
+    ASL_MSG_HID_SUFFIX,
+    ASL_MSG_INCLUDE_FILE_OPEN,
+    ASL_MSG_INPUT_FILE_OPEN,
+    ASL_MSG_INTEGER_LENGTH,
+    ASL_MSG_INTEGER_OPTIMIZATION,
+    ASL_MSG_INTERRUPT_LIST,
+    ASL_MSG_INTERRUPT_NUMBER,
+    ASL_MSG_INVALID_ACCESS_SIZE,
+    ASL_MSG_INVALID_ADDR_FLAGS,
+    ASL_MSG_INVALID_CONSTANT_OP,
+    ASL_MSG_INVALID_EISAID,
+    ASL_MSG_INVALID_ESCAPE,
+    ASL_MSG_INVALID_GRAN_FIXED,
+    ASL_MSG_INVALID_GRANULARITY,
+    ASL_MSG_INVALID_LENGTH,
+    ASL_MSG_INVALID_LENGTH_FIXED,
+    ASL_MSG_INVALID_MIN_MAX,
+    ASL_MSG_INVALID_OPERAND,
+    ASL_MSG_INVALID_PERFORMANCE,
+    ASL_MSG_INVALID_PRIORITY,
+    ASL_MSG_INVALID_STRING,
+    ASL_MSG_INVALID_TARGET,
+    ASL_MSG_INVALID_TIME,
+    ASL_MSG_INVALID_TYPE,
+    ASL_MSG_INVALID_UUID,
+    ASL_MSG_ISA_ADDRESS,
+    ASL_MSG_LEADING_ASTERISK,
+    ASL_MSG_LIST_LENGTH_LONG,
+    ASL_MSG_LIST_LENGTH_SHORT,
+    ASL_MSG_LISTING_FILE_OPEN,
+    ASL_MSG_LISTING_FILENAME,
+    ASL_MSG_LOCAL_INIT,
+    ASL_MSG_LOCAL_OUTSIDE_METHOD,
+    ASL_MSG_LONG_LINE,
+    ASL_MSG_MEMORY_ALLOCATION,
+    ASL_MSG_MISSING_ENDDEPENDENT,
+    ASL_MSG_MISSING_STARTDEPENDENT,
+    ASL_MSG_MULTIPLE_DEFAULT,
+    ASL_MSG_MULTIPLE_TYPES,
+    ASL_MSG_NAME_EXISTS,
+    ASL_MSG_NAME_OPTIMIZATION,
+    ASL_MSG_NAMED_OBJECT_IN_WHILE,
+    ASL_MSG_NESTED_COMMENT,
+    ASL_MSG_NO_CASES,
+    ASL_MSG_NO_REGION,
+    ASL_MSG_NO_RETVAL,
+    ASL_MSG_NO_WHILE,
+    ASL_MSG_NON_ASCII,
+    ASL_MSG_NON_ZERO,
+    ASL_MSG_NOT_EXIST,
+    ASL_MSG_NOT_FOUND,
+    ASL_MSG_NOT_METHOD,
+    ASL_MSG_NOT_PARAMETER,
+    ASL_MSG_NOT_REACHABLE,
+    ASL_MSG_NOT_REFERENCED,
+    ASL_MSG_NULL_DESCRIPTOR,
+    ASL_MSG_NULL_STRING,
+    ASL_MSG_OPEN,
+    ASL_MSG_OUTPUT_FILE_OPEN,
+    ASL_MSG_OUTPUT_FILENAME,
+    ASL_MSG_PACKAGE_LENGTH,
+    ASL_MSG_PREPROCESSOR_FILENAME,
+    ASL_MSG_READ,
+    ASL_MSG_RECURSION,
+    ASL_MSG_REGION_BUFFER_ACCESS,
+    ASL_MSG_REGION_BYTE_ACCESS,
+    ASL_MSG_RESERVED_ARG_COUNT_HI,
+    ASL_MSG_RESERVED_ARG_COUNT_LO,
+    ASL_MSG_RESERVED_METHOD,
+    ASL_MSG_RESERVED_NO_RETURN_VAL,
+    ASL_MSG_RESERVED_OPERAND_TYPE,
+    ASL_MSG_RESERVED_PACKAGE_LENGTH,
+    ASL_MSG_RESERVED_RETURN_VALUE,
+    ASL_MSG_RESERVED_USE,
+    ASL_MSG_RESERVED_WORD,
+    ASL_MSG_RESOURCE_FIELD,
+    ASL_MSG_RESOURCE_INDEX,
+    ASL_MSG_RESOURCE_LIST,
+    ASL_MSG_RESOURCE_SOURCE,
+    ASL_MSG_RESULT_NOT_USED,
+    ASL_MSG_RETURN_TYPES,
+    ASL_MSG_SCOPE_FWD_REF,
+    ASL_MSG_SCOPE_TYPE,
+    ASL_MSG_SEEK,
+    ASL_MSG_SERIALIZED,
+    ASL_MSG_SERIALIZED_REQUIRED,
+    ASL_MSG_SINGLE_NAME_OPTIMIZATION,
+    ASL_MSG_SOME_NO_RETVAL,
+    ASL_MSG_STRING_LENGTH,
+    ASL_MSG_SWITCH_TYPE,
+    ASL_MSG_SYNC_LEVEL,
+    ASL_MSG_SYNTAX,
+    ASL_MSG_TABLE_SIGNATURE,
+    ASL_MSG_TAG_LARGER,
+    ASL_MSG_TAG_SMALLER,
+    ASL_MSG_TIMEOUT,
+    ASL_MSG_TOO_MANY_TEMPS,
+    ASL_MSG_TRUNCATION,
+    ASL_MSG_UNKNOWN_RESERVED_NAME,
+    ASL_MSG_UNREACHABLE_CODE,
+    ASL_MSG_UNSUPPORTED,
+    ASL_MSG_UPPER_CASE,
+    ASL_MSG_VENDOR_LIST,
+    ASL_MSG_WRITE,
+    ASL_MSG_RANGE,
+    ASL_MSG_BUFFER_ALLOCATION,
+    ASL_MSG_MISSING_DEPENDENCY,
+    ASL_MSG_ILLEGAL_FORWARD_REF,
+    ASL_MSG_ILLEGAL_METHOD_REF,
+    ASL_MSG_LOCAL_NOT_USED,
+    ASL_MSG_ARG_AS_LOCAL_NOT_USED,
+    ASL_MSG_ARG_NOT_USED,
+    ASL_MSG_CONSTANT_REQUIRED,
+    ASL_MSG_CROSS_TABLE_SCOPE,
+
+    /* These messages are used by the Data Table compiler only */
+
+    ASL_MSG_BUFFER_ELEMENT = ASL_MSG_TABLE_COMPILER,
+    ASL_MSG_DIVIDE_BY_ZERO,
+    ASL_MSG_FLAG_VALUE,
+    ASL_MSG_INTEGER_SIZE,
+    ASL_MSG_INVALID_EXPRESSION,
+    ASL_MSG_INVALID_FIELD_NAME,
+    ASL_MSG_INVALID_HEX_INTEGER,
+    ASL_MSG_OEM_TABLE,
+    ASL_MSG_RESERVED_VALUE,
+    ASL_MSG_UNKNOWN_LABEL,
+    ASL_MSG_UNKNOWN_SUBTABLE,
+    ASL_MSG_UNKNOWN_TABLE,
+    ASL_MSG_ZERO_VALUE,
+
+    /* These messages are used by the Preprocessor only */
+
+    ASL_MSG_DIRECTIVE_SYNTAX = ASL_MSG_PREPROCESSOR,
+    ASL_MSG_ENDIF_MISMATCH,
+    ASL_MSG_ERROR_DIRECTIVE,
+    ASL_MSG_EXISTING_NAME,
+    ASL_MSG_INVALID_INVOCATION,
+    ASL_MSG_MACRO_SYNTAX,
+    ASL_MSG_TOO_MANY_ARGUMENTS,
+    ASL_MSG_UNKNOWN_DIRECTIVE,
+    ASL_MSG_UNKNOWN_PRAGMA,
+    ASL_MSG_WARNING_DIRECTIVE,
+    ASL_MSG_INCLUDE_FILE
+
+} ASL_MESSAGE_IDS;
+
+
+#endif  /* __ASLMESSAGES_H */
diff --git a/usr/src/cmd/acpi/iasl/aslmethod.c b/usr/src/cmd/acpi/iasl/aslmethod.c
new file mode 100644
index 0000000000..226aa79c46
--- /dev/null
+++ b/usr/src/cmd/acpi/iasl/aslmethod.c
@@ -0,0 +1,739 @@
+/******************************************************************************
+ *
+ * Module Name: aslmethod.c - Control method analysis walk
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2016, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include "aslcompiler.h"
+#include "aslcompiler.y.h"
+#include "acparser.h"
+#include "amlcode.h"
+
+
+#define _COMPONENT          ACPI_COMPILER
+        ACPI_MODULE_NAME    ("aslmethod")
+
+
+/* Local prototypes */
+
+static void
+MtCheckNamedObjectInMethod (
+    ACPI_PARSE_OBJECT       *Op,
+    ASL_METHOD_INFO         *MethodInfo);
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    MtMethodAnalysisWalkBegin
+ *
+ * PARAMETERS:  ASL_WALK_CALLBACK
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Descending callback for the analysis walk. Check methods for:
+ *              1) Initialized local variables
+ *              2) Valid arguments
+ *              3) Return types
+ *
+ ******************************************************************************/
+
+ACPI_STATUS
+MtMethodAnalysisWalkBegin (
+    ACPI_PARSE_OBJECT       *Op,
+    UINT32                  Level,
+    void                    *Context)
+{
+    ASL_ANALYSIS_WALK_INFO  *WalkInfo = (ASL_ANALYSIS_WALK_INFO *) Context;
+    ASL_METHOD_INFO         *MethodInfo = WalkInfo->MethodStack;
+    ACPI_PARSE_OBJECT       *Next;
+    UINT32                  RegisterNumber;
+    UINT32                  i;
+    char                    LocalName[] = "Local0";
+    char                    ArgName[] = "Arg0";
+    ACPI_PARSE_OBJECT       *ArgNode;
+    ACPI_PARSE_OBJECT       *NextType;
+    ACPI_PARSE_OBJECT       *NextParamType;
+    UINT8                   ActualArgs = 0;
+
+
+    /* Build cross-reference output file if requested */
+
+    if (Gbl_CrossReferenceOutput)
+    {
+        OtXrefWalkPart1 (Op, Level, MethodInfo);
+    }
+
+    switch (Op->Asl.ParseOpcode)
+    {
+    case PARSEOP_METHOD:
+
+        TotalMethods++;
+
+        /* Create and init method info */
+
+        MethodInfo = UtLocalCalloc (sizeof (ASL_METHOD_INFO));
+        MethodInfo->Next = WalkInfo->MethodStack;
+        MethodInfo->Op = Op;
+
+        WalkInfo->MethodStack = MethodInfo;
+
+        /*
+         * Special handling for _PSx methods. Dependency rules (same scope):
+         *
+         * 1) _PS0 - One of these must exist: _PS1, _PS2, _PS3
+         * 2) _PS1/_PS2/_PS3: A _PS0 must exist
+         */
+        if (ACPI_COMPARE_NAME (METHOD_NAME__PS0, Op->Asl.NameSeg))
+        {
+            /* For _PS0, one of _PS1/_PS2/_PS3 must exist */
+
+            if ((!ApFindNameInScope (METHOD_NAME__PS1, Op)) &&
+                (!ApFindNameInScope (METHOD_NAME__PS2, Op)) &&
+                (!ApFindNameInScope (METHOD_NAME__PS3, Op)))
+            {
+                AslError (ASL_WARNING, ASL_MSG_MISSING_DEPENDENCY, Op,
+                    "_PS0 requires one of _PS1/_PS2/_PS3 in same scope");
+            }
+        }
+        else if (
+            ACPI_COMPARE_NAME (METHOD_NAME__PS1, Op->Asl.NameSeg) ||
+            ACPI_COMPARE_NAME (METHOD_NAME__PS2, Op->Asl.NameSeg) ||
+            ACPI_COMPARE_NAME (METHOD_NAME__PS3, Op->Asl.NameSeg))
+        {
+            /* For _PS1/_PS2/_PS3, a _PS0 must exist */
+
+            if (!ApFindNameInScope (METHOD_NAME__PS0, Op))
+            {
+                sprintf (MsgBuffer,
+                    "%4.4s requires _PS0 in same scope", Op->Asl.NameSeg);
+
+                AslError (ASL_WARNING, ASL_MSG_MISSING_DEPENDENCY, Op,
+                    MsgBuffer);
+            }
+        }
+
+        /* Get the name node */
+
+        Next = Op->Asl.Child;
+
+        /* Get the NumArguments node */
+
+        Next = Next->Asl.Next;
+        MethodInfo->NumArguments = (UINT8)
+            (((UINT8) Next->Asl.Value.Integer) & 0x07);
+
+        /* Get the SerializeRule and SyncLevel nodes, ignored here */
+
+        Next = Next->Asl.Next;
+        MethodInfo->ShouldBeSerialized = (UINT8) Next->Asl.Value.Integer;
+
+        Next = Next->Asl.Next;
+        ArgNode = Next;
+
+        /* Get the ReturnType node */
+
+        Next = Next->Asl.Next;
+
+        NextType = Next->Asl.Child;
+        while (NextType)
+        {
+            /* Get and map each of the ReturnTypes */
+
+            MethodInfo->ValidReturnTypes |= AnMapObjTypeToBtype (NextType);
+            NextType->Asl.ParseOpcode = PARSEOP_DEFAULT_ARG;
+            NextType = NextType->Asl.Next;
+        }
+
+        /* Get the ParameterType node */
+
+        Next = Next->Asl.Next;
+
+        NextType = Next->Asl.Child;
+        while (NextType)
+        {
+            if (NextType->Asl.ParseOpcode == PARSEOP_DEFAULT_ARG)
+            {
+                NextParamType = NextType->Asl.Child;
+                while (NextParamType)
+                {
+                    MethodInfo->ValidArgTypes[ActualArgs] |=
+                        AnMapObjTypeToBtype (NextParamType);
+
+                    NextParamType->Asl.ParseOpcode = PARSEOP_DEFAULT_ARG;
+                    NextParamType = NextParamType->Asl.Next;
+                }
+            }
+            else
+            {
+                MethodInfo->ValidArgTypes[ActualArgs] =
+                    AnMapObjTypeToBtype (NextType);
+
+                NextType->Asl.ParseOpcode = PARSEOP_DEFAULT_ARG;
+                ActualArgs++;
+            }
+
+            NextType = NextType->Asl.Next;
+        }
+
+        if ((MethodInfo->NumArguments) &&
+            (MethodInfo->NumArguments != ActualArgs))
+        {
+            /* error: Param list did not match number of args */
+        }
+
+        /* Allow numarguments == 0 for Function() */
+
+        if ((!MethodInfo->NumArguments) && (ActualArgs))
+        {
+            MethodInfo->NumArguments = ActualArgs;
+            ArgNode->Asl.Value.Integer |= ActualArgs;
+        }
+
+        /*
+         * Actual arguments are initialized at method entry.
+         * All other ArgX "registers" can be used as locals, so we
+         * track their initialization.
+         */
+        for (i = 0; i < MethodInfo->NumArguments; i++)
+        {
+            MethodInfo->ArgInitialized[i] = TRUE;
+        }
+        break;
+
+    case PARSEOP_METHODCALL:
+
+        if (MethodInfo &&
+           (Op->Asl.Node == MethodInfo->Op->Asl.Node))
+        {
+            AslError (ASL_REMARK, ASL_MSG_RECURSION, Op, Op->Asl.ExternalName);
+        }
+        break;
+
+    case PARSEOP_LOCAL0:
+    case PARSEOP_LOCAL1:
+    case PARSEOP_LOCAL2:
+    case PARSEOP_LOCAL3:
+    case PARSEOP_LOCAL4:
+    case PARSEOP_LOCAL5:
+    case PARSEOP_LOCAL6:
+    case PARSEOP_LOCAL7:
+
+        if (!MethodInfo)
+        {
+            /*
+             * Local was used outside a control method, or there was an error
+             * in the method declaration.
+             */
+            AslError (ASL_REMARK, ASL_MSG_LOCAL_OUTSIDE_METHOD,
+                Op, Op->Asl.ExternalName);
+            return (AE_ERROR);
+        }
+
+        RegisterNumber = (Op->Asl.AmlOpcode & 0x0007);
+
+        /*
+         * If the local is being used as a target, mark the local
+         * initialized
+         */
+        if (Op->Asl.CompileFlags & NODE_IS_TARGET)
+        {
+            MethodInfo->LocalInitialized[RegisterNumber] = TRUE;
+        }
+
+        /*
+         * Otherwise, this is a reference, check if the local
+         * has been previously initialized.
+         *
+         * The only operator that accepts an uninitialized value is ObjectType()
+         */
+        else if ((!MethodInfo->LocalInitialized[RegisterNumber]) &&
+                 (Op->Asl.Parent->Asl.ParseOpcode != PARSEOP_OBJECTTYPE))
+        {
+            LocalName[strlen (LocalName) -1] = (char) (RegisterNumber + 0x30);
+            AslError (ASL_ERROR, ASL_MSG_LOCAL_INIT, Op, LocalName);
+        }
+        break;
+
+    case PARSEOP_ARG0:
+    case PARSEOP_ARG1:
+    case PARSEOP_ARG2:
+    case PARSEOP_ARG3:
+    case PARSEOP_ARG4:
+    case PARSEOP_ARG5:
+    case PARSEOP_ARG6:
+
+        if (!MethodInfo)
+        {
+            /*
+             * Arg was used outside a control method, or there was an error
+             * in the method declaration.
+             */
+            AslError (ASL_REMARK, ASL_MSG_LOCAL_OUTSIDE_METHOD,
+                Op, Op->Asl.ExternalName);
+            return (AE_ERROR);
+        }
+
+        RegisterNumber = (Op->Asl.AmlOpcode & 0x000F) - 8;
+        ArgName[strlen (ArgName) -1] = (char) (RegisterNumber + 0x30);
+
+        /*
+         * If the Arg is being used as a target, mark the local
+         * initialized
+         */
+        if (Op->Asl.CompileFlags & NODE_IS_TARGET)
+        {
+            MethodInfo->ArgInitialized[RegisterNumber] = TRUE;
+        }
+
+        /*
+         * Otherwise, this is a reference, check if the Arg
+         * has been previously initialized.
+         *
+         * The only operator that accepts an uninitialized value is ObjectType()
+         */
+        else if ((!MethodInfo->ArgInitialized[RegisterNumber]) &&
+            (Op->Asl.Parent->Asl.ParseOpcode != PARSEOP_OBJECTTYPE))
+        {
+            AslError (ASL_ERROR, ASL_MSG_ARG_INIT, Op, ArgName);
+        }
+
+        /* Flag this arg if it is not a "real" argument to the method */
+
+        if (RegisterNumber >= MethodInfo->NumArguments)
+        {
+            AslError (ASL_REMARK, ASL_MSG_NOT_PARAMETER, Op, ArgName);
+        }
+        break;
+
+    case PARSEOP_RETURN:
+
+        if (!MethodInfo)
+        {
+            /*
+             * Probably was an error in the method declaration,
+             * no additional error here
+             */
+            ACPI_WARNING ((AE_INFO, "%p, No parent method", Op));
+            return (AE_ERROR);
+        }
+
+        /*
+         * A child indicates a possible return value. A simple Return or
+         * Return() is marked with NODE_IS_NULL_RETURN by the parser so
+         * that it is not counted as a "real" return-with-value, although
+         * the AML code that is actually emitted is Return(0). The AML
+         * definition of Return has a required parameter, so we are
+         * forced to convert a null return to Return(0).
+         */
+        if ((Op->Asl.Child) &&
+            (Op->Asl.Child->Asl.ParseOpcode != PARSEOP_DEFAULT_ARG) &&
+            (!(Op->Asl.Child->Asl.CompileFlags & NODE_IS_NULL_RETURN)))
+        {
+            MethodInfo->NumReturnWithValue++;
+        }
+        else
+        {
+            MethodInfo->NumReturnNoValue++;
+        }
+        break;
+
+    case PARSEOP_BREAK:
+    case PARSEOP_CONTINUE:
+
+        Next = Op->Asl.Parent;
+        while (Next)
+        {
+            if (Next->Asl.ParseOpcode == PARSEOP_WHILE)
+            {
+                break;
+            }
+            Next = Next->Asl.Parent;
+        }
+
+        if (!Next)
+        {
+            AslError (ASL_ERROR, ASL_MSG_NO_WHILE, Op, NULL);
+        }
+        break;
+
+    case PARSEOP_STALL:
+
+        /* We can range check if the argument is an integer */
+
+        if ((Op->Asl.Child->Asl.ParseOpcode == PARSEOP_INTEGER) &&
+            (Op->Asl.Child->Asl.Value.Integer > ACPI_UINT8_MAX))
+        {
+            AslError (ASL_ERROR, ASL_MSG_INVALID_TIME, Op, NULL);
+        }
+        break;
+
+    case PARSEOP_DEVICE:
+
+        if (!ApFindNameInDeviceTree (METHOD_NAME__HID, Op) &&
+            !ApFindNameInDeviceTree (METHOD_NAME__ADR, Op))
+        {
+            AslError (ASL_WARNING, ASL_MSG_MISSING_DEPENDENCY, Op,
+                "Device object requires a _HID or _ADR in same scope");
+        }
+        break;
+
+    case PARSEOP_EVENT:
+    case PARSEOP_MUTEX:
+    case PARSEOP_OPERATIONREGION:
+    case PARSEOP_POWERRESOURCE:
+    case PARSEOP_PROCESSOR:
+    case PARSEOP_THERMALZONE:
+
+        /*
+         * The first operand is a name to be created in the namespace.
+         * Check against the reserved list.
+         */
+        i = ApCheckForPredefinedName (Op, Op->Asl.NameSeg);
+        if (i < ACPI_VALID_RESERVED_NAME_MAX)
+        {
+            AslError (ASL_ERROR, ASL_MSG_RESERVED_USE,
+                Op, Op->Asl.ExternalName);
+        }
+        break;
+
+    case PARSEOP_NAME:
+
+        /* Typecheck any predefined names statically defined with Name() */
+
+        ApCheckForPredefinedObject (Op, Op->Asl.NameSeg);
+
+        /* Special typechecking for _HID */
+
+        if (!strcmp (METHOD_NAME__HID, Op->Asl.NameSeg))
+        {
+            Next = Op->Asl.Child->Asl.Next;
+            AnCheckId (Next, ASL_TYPE_HID);
+        }
+
+        /* Special typechecking for _CID */
+
+        else if (!strcmp (METHOD_NAME__CID, Op->Asl.NameSeg))
+        {
+            Next = Op->Asl.Child->Asl.Next;
+
+            if ((Next->Asl.ParseOpcode == PARSEOP_PACKAGE) ||
+                (Next->Asl.ParseOpcode == PARSEOP_VAR_PACKAGE))
+            {
+                Next = Next->Asl.Child;
+                while (Next)
+                {
+                    AnCheckId (Next, ASL_TYPE_CID);
+                    Next = Next->Asl.Next;
+                }
+            }
+            else
+            {
+                AnCheckId (Next, ASL_TYPE_CID);
+            }
+        }
+
+        break;
+
+    default:
+
+        break;
+    }
+
+    /* Check for named object creation within a non-serialized method */
+
+    MtCheckNamedObjectInMethod (Op, MethodInfo);
+    return (AE_OK);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    MtCheckNamedObjectInMethod
+ *
+ * PARAMETERS:  Op                  - Current parser op
+ *              MethodInfo          - Info for method being parsed
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Detect if a non-serialized method is creating a named object,
+ *              which could possibly cause problems if two threads execute
+ *              the method concurrently. Emit a remark in this case.
+ *
+ ******************************************************************************/
+
+static void
+MtCheckNamedObjectInMethod (
+    ACPI_PARSE_OBJECT       *Op,
+    ASL_METHOD_INFO         *MethodInfo)
+{
+    const ACPI_OPCODE_INFO  *OpInfo;
+
+
+    /* We don't care about actual method declarations or scopes */
+
+    if ((Op->Asl.AmlOpcode == AML_METHOD_OP) ||
+        (Op->Asl.AmlOpcode == AML_SCOPE_OP))
+    {
+        return;
+    }
+
+    /* Determine if we are creating a named object */
+
+    OpInfo = AcpiPsGetOpcodeInfo (Op->Asl.AmlOpcode);
+    if (OpInfo->Class == AML_CLASS_NAMED_OBJECT)
+    {
+        /*
+         * If we have a named object created within a non-serialized method,
+         * emit a remark that the method should be serialized.
+         *
+         * Reason: If a thread blocks within the method for any reason, and
+         * another thread enters the method, the method will fail because an
+         * attempt will be made to create the same object twice.
+         */
+        if (MethodInfo && !MethodInfo->ShouldBeSerialized)
+        {
+            AslError (ASL_REMARK, ASL_MSG_SERIALIZED_REQUIRED, MethodInfo->Op,
+                "due to creation of named objects within");
+
+            /* Emit message only ONCE per method */
+
+            MethodInfo->ShouldBeSerialized = TRUE;
+        }
+    }
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    MtMethodAnalysisWalkEnd
+ *
+ * PARAMETERS:  ASL_WALK_CALLBACK
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Ascending callback for analysis walk. Complete method
+ *              return analysis.
+ *
+ ******************************************************************************/
+
+ACPI_STATUS
+MtMethodAnalysisWalkEnd (
+    ACPI_PARSE_OBJECT       *Op,
+    UINT32                  Level,
+    void                    *Context)
+{
+    ASL_ANALYSIS_WALK_INFO  *WalkInfo = (ASL_ANALYSIS_WALK_INFO *) Context;
+    ASL_METHOD_INFO         *MethodInfo = WalkInfo->MethodStack;
+
+
+    switch (Op->Asl.ParseOpcode)
+    {
+    case PARSEOP_METHOD:
+    case PARSEOP_RETURN:
+
+        if (!MethodInfo)
+        {
+            printf ("No method info for method! [%s]\n", Op->Asl.Namepath);
+            AslError (ASL_ERROR, ASL_MSG_COMPILER_INTERNAL, Op,
+                "No method info for this method");
+
+            CmCleanupAndExit ();
+            return (AE_AML_INTERNAL);
+        }
+        break;
+
+    default:
+
+        break;
+    }
+
+    switch (Op->Asl.ParseOpcode)
+    {
+    case PARSEOP_METHOD:
+
+        WalkInfo->MethodStack = MethodInfo->Next;
+
+        /*
+         * Check if there is no return statement at the end of the
+         * method AND we can actually get there -- i.e., the execution
+         * of the method can possibly terminate without a return statement.
+         */
+        if ((!AnLastStatementIsReturn (Op)) &&
+            (!(Op->Asl.CompileFlags & NODE_HAS_NO_EXIT)))
+        {
+            /*
+             * No return statement, and execution can possibly exit
+             * via this path. This is equivalent to Return ()
+             */
+            MethodInfo->NumReturnNoValue++;
+        }
+
+        /*
+         * Check for case where some return statements have a return value
+         * and some do not. Exit without a return statement is a return with
+         * no value
+         */
+        if (MethodInfo->NumReturnNoValue &&
+            MethodInfo->NumReturnWithValue)
+        {
+            AslError (ASL_WARNING, ASL_MSG_RETURN_TYPES, Op,
+                Op->Asl.ExternalName);
+        }
+
+        /*
+         * If there are any RETURN() statements with no value, or there is a
+         * control path that allows the method to exit without a return value,
+         * we mark the method as a method that does not return a value. This
+         * knowledge can be used to check method invocations that expect a
+         * returned value.
+         */
+        if (MethodInfo->NumReturnNoValue)
+        {
+            if (MethodInfo->NumReturnWithValue)
+            {
+                Op->Asl.CompileFlags |= NODE_METHOD_SOME_NO_RETVAL;
+            }
+            else
+            {
+                Op->Asl.CompileFlags |= NODE_METHOD_NO_RETVAL;
+            }
+        }
+
+        /*
+         * Check predefined method names for correct return behavior
+         * and correct number of arguments. Also, some special checks
+         * For GPE and _REG methods.
+         */
+        if (ApCheckForPredefinedMethod (Op, MethodInfo))
+        {
+            /* Special check for two names like _L01 and _E01 in same scope */
+
+            ApCheckForGpeNameConflict (Op);
+
+            /*
+             * Special check for _REG: Must have an operation region definition
+             * within the same scope!
+             */
+            ApCheckRegMethod (Op);
+        }
+
+        ACPI_FREE (MethodInfo);
+        break;
+
+    case PARSEOP_NAME:
+
+         /* Special check for two names like _L01 and _E01 in same scope */
+
+        ApCheckForGpeNameConflict (Op);
+        break;
+
+    case PARSEOP_RETURN:
+
+        /*
+         * If the parent is a predefined method name, attempt to typecheck
+         * the return value. Only static types can be validated.
+         */
+        ApCheckPredefinedReturnValue (Op, MethodInfo);
+
+        /*
+         * The parent block does not "exit" and continue execution -- the
+         * method is terminated here with the Return() statement.
+         */
+        Op->Asl.Parent->Asl.CompileFlags |= NODE_HAS_NO_EXIT;
+
+        /* Used in the "typing" pass later */
+
+        Op->Asl.ParentMethod = MethodInfo->Op;
+
+        /*
+         * If there is a peer node after the return statement, then this
+         * node is unreachable code -- i.e., it won't be executed because of
+         * the preceding Return() statement.
+         */
+        if (Op->Asl.Next)
+        {
+            AslError (ASL_WARNING, ASL_MSG_UNREACHABLE_CODE,
+                Op->Asl.Next, NULL);
+        }
+        break;
+
+    case PARSEOP_IF:
+
+        if ((Op->Asl.CompileFlags & NODE_HAS_NO_EXIT) &&
+            (Op->Asl.Next) &&
+            (Op->Asl.Next->Asl.ParseOpcode == PARSEOP_ELSE))
+        {
+            /*
+             * This IF has a corresponding ELSE. The IF block has no exit,
+             * (it contains an unconditional Return)
+             * mark the ELSE block to remember this fact.
+             */
+            Op->Asl.Next->Asl.CompileFlags |= NODE_IF_HAS_NO_EXIT;
+        }
+        break;
+
+    case PARSEOP_ELSE:
+
+        if ((Op->Asl.CompileFlags & NODE_HAS_NO_EXIT) &&
+            (Op->Asl.CompileFlags & NODE_IF_HAS_NO_EXIT))
+        {
+            /*
+             * This ELSE block has no exit and the corresponding IF block
+             * has no exit either. Therefore, the parent node has no exit.
+             */
+            Op->Asl.Parent->Asl.CompileFlags |= NODE_HAS_NO_EXIT;
+        }
+        break;
+
+
+    default:
+
+        if ((Op->Asl.CompileFlags & NODE_HAS_NO_EXIT) &&
+            (Op->Asl.Parent))
+        {
+            /* If this node has no exit, then the parent has no exit either */
+
+            Op->Asl.Parent->Asl.CompileFlags |= NODE_HAS_NO_EXIT;
+        }
+        break;
+    }
+
+    return (AE_OK);
+}
diff --git a/usr/src/cmd/acpi/iasl/aslnamesp.c b/usr/src/cmd/acpi/iasl/aslnamesp.c
new file mode 100644
index 0000000000..9a2bc14974
--- /dev/null
+++ b/usr/src/cmd/acpi/iasl/aslnamesp.c
@@ -0,0 +1,429 @@
+/******************************************************************************
+ *
+ * Module Name: aslnamesp - Namespace output file generation
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2016, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include "aslcompiler.h"
+#include "aslcompiler.y.h"
+#include "acnamesp.h"
+
+
+#define _COMPONENT          ACPI_COMPILER
+        ACPI_MODULE_NAME    ("aslnamesp")
+
+/* Local prototypes */
+
+static ACPI_STATUS
+NsDoOneNamespaceObject (
+    ACPI_HANDLE             ObjHandle,
+    UINT32                  Level,
+    void                    *Context,
+    void                    **ReturnValue);
+
+static ACPI_STATUS
+NsDoOnePathname (
+    ACPI_HANDLE             ObjHandle,
+    UINT32                  Level,
+    void                    *Context,
+    void                    **ReturnValue);
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    NsSetupNamespaceListing
+ *
+ * PARAMETERS:  Handle          - local file handle
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Set the namespace output file to the input handle
+ *
+ ******************************************************************************/
+
+void
+NsSetupNamespaceListing (
+    void                    *Handle)
+{
+
+    Gbl_NsOutputFlag = TRUE;
+    Gbl_Files[ASL_FILE_NAMESPACE_OUTPUT].Handle = Handle;
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    NsDisplayNamespace
+ *
+ * PARAMETERS:  None
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Walk the namespace an display information about each node
+ *              in the tree. Information is written to the optional
+ *              namespace output file.
+ *
+ ******************************************************************************/
+
+ACPI_STATUS
+NsDisplayNamespace (
+    void)
+{
+    ACPI_STATUS             Status;
+
+
+    if (!Gbl_NsOutputFlag)
+    {
+        return (AE_OK);
+    }
+
+    Gbl_NumNamespaceObjects = 0;
+
+    /* File header */
+
+    FlPrintFile (ASL_FILE_NAMESPACE_OUTPUT, "Contents of ACPI Namespace\n\n");
+    FlPrintFile (ASL_FILE_NAMESPACE_OUTPUT, "Count  Depth    Name - Type\n\n");
+
+    /* Walk entire namespace from the root */
+
+    Status = AcpiNsWalkNamespace (ACPI_TYPE_ANY, ACPI_ROOT_OBJECT,
+        ACPI_UINT32_MAX, FALSE, NsDoOneNamespaceObject, NULL,
+        NULL, NULL);
+
+    /* Print the full pathname for each namespace node */
+
+    FlPrintFile (ASL_FILE_NAMESPACE_OUTPUT, "\nNamespace pathnames\n\n");
+
+    Status = AcpiNsWalkNamespace (ACPI_TYPE_ANY, ACPI_ROOT_OBJECT,
+        ACPI_UINT32_MAX, FALSE, NsDoOnePathname, NULL,
+        NULL, NULL);
+
+    return (Status);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    NsDoOneNamespaceObject
+ *
+ * PARAMETERS:  ACPI_WALK_CALLBACK
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Dump a namespace object to the namespace output file.
+ *              Called during the walk of the namespace to dump all objects.
+ *
+ ******************************************************************************/
+
+static ACPI_STATUS
+NsDoOneNamespaceObject (
+    ACPI_HANDLE             ObjHandle,
+    UINT32                  Level,
+    void                    *Context,
+    void                    **ReturnValue)
+{
+    ACPI_NAMESPACE_NODE     *Node = (ACPI_NAMESPACE_NODE *) ObjHandle;
+    ACPI_OPERAND_OBJECT     *ObjDesc;
+    ACPI_PARSE_OBJECT       *Op;
+
+
+    Gbl_NumNamespaceObjects++;
+
+    FlPrintFile (ASL_FILE_NAMESPACE_OUTPUT, "%5u  [%u]  %*s %4.4s - %s",
+        Gbl_NumNamespaceObjects, Level, (Level * 3), " ",
+        &Node->Name, AcpiUtGetTypeName (Node->Type));
+
+    Op = Node->Op;
+    ObjDesc = ACPI_CAST_PTR (ACPI_OPERAND_OBJECT, Node->Object);
+
+    if (!Op)
+    {
+        FlPrintFile (ASL_FILE_NAMESPACE_OUTPUT, "\n");
+        return (AE_OK);
+    }
+
+
+    if ((ObjDesc) &&
+        (ACPI_GET_DESCRIPTOR_TYPE (ObjDesc) == ACPI_DESC_TYPE_OPERAND))
+    {
+        switch (Node->Type)
+        {
+        case ACPI_TYPE_INTEGER:
+
+            FlPrintFile (ASL_FILE_NAMESPACE_OUTPUT,
+                "       [Initial Value   0x%8.8X%8.8X]",
+                ACPI_FORMAT_UINT64 (ObjDesc->Integer.Value));
+            break;
+
+        case ACPI_TYPE_STRING:
+
+            FlPrintFile (ASL_FILE_NAMESPACE_OUTPUT,
+                "        [Initial Value   \"%s\"]",
+                ObjDesc->String.Pointer);
+            break;
+
+        default:
+
+            /* Nothing to do for other types */
+
+            break;
+        }
+
+    }
+    else
+    {
+        switch (Node->Type)
+        {
+        case ACPI_TYPE_INTEGER:
+
+            if (Op->Asl.ParseOpcode == PARSEOP_NAME)
+            {
+                Op = Op->Asl.Child;
+            }
+
+            if ((Op->Asl.ParseOpcode == PARSEOP_NAMESEG)  ||
+                (Op->Asl.ParseOpcode == PARSEOP_NAMESTRING))
+            {
+                Op = Op->Asl.Next;
+            }
+
+            FlPrintFile (ASL_FILE_NAMESPACE_OUTPUT,
+                "       [Initial Value   0x%8.8X%8.8X]",
+                ACPI_FORMAT_UINT64 (Op->Asl.Value.Integer));
+            break;
+
+        case ACPI_TYPE_STRING:
+
+            if (Op->Asl.ParseOpcode == PARSEOP_NAME)
+            {
+                Op = Op->Asl.Child;
+            }
+
+            if ((Op->Asl.ParseOpcode == PARSEOP_NAMESEG)  ||
+                (Op->Asl.ParseOpcode == PARSEOP_NAMESTRING))
+            {
+                Op = Op->Asl.Next;
+            }
+
+            FlPrintFile (ASL_FILE_NAMESPACE_OUTPUT,
+                "        [Initial Value   \"%s\"]",
+                Op->Asl.Value.String);
+            break;
+
+        case ACPI_TYPE_LOCAL_REGION_FIELD:
+
+            if ((Op->Asl.ParseOpcode == PARSEOP_NAMESEG)  ||
+                (Op->Asl.ParseOpcode == PARSEOP_NAMESTRING))
+            {
+                Op = Op->Asl.Child;
+            }
+
+            FlPrintFile (ASL_FILE_NAMESPACE_OUTPUT,
+                "   [Offset 0x%04X   Length 0x%04X bits]",
+                Op->Asl.Parent->Asl.ExtraValue, (UINT32) Op->Asl.Value.Integer);
+            break;
+
+        case ACPI_TYPE_BUFFER_FIELD:
+
+            switch (Op->Asl.ParseOpcode)
+            {
+            case PARSEOP_CREATEBYTEFIELD:
+
+                FlPrintFile (ASL_FILE_NAMESPACE_OUTPUT, "   [BYTE  ( 8 bit)]");
+                break;
+
+            case PARSEOP_CREATEDWORDFIELD:
+
+                FlPrintFile (ASL_FILE_NAMESPACE_OUTPUT, "   [DWORD (32 bit)]");
+                break;
+
+            case PARSEOP_CREATEQWORDFIELD:
+
+                FlPrintFile (ASL_FILE_NAMESPACE_OUTPUT, "   [QWORD (64 bit)]");
+                break;
+
+            case PARSEOP_CREATEWORDFIELD:
+
+                FlPrintFile (ASL_FILE_NAMESPACE_OUTPUT, "   [WORD  (16 bit)]");
+                break;
+
+            case PARSEOP_CREATEBITFIELD:
+
+                FlPrintFile (ASL_FILE_NAMESPACE_OUTPUT, "   [BIT   ( 1 bit)]");
+                break;
+
+            case PARSEOP_CREATEFIELD:
+
+                FlPrintFile (ASL_FILE_NAMESPACE_OUTPUT, "   [Arbitrary Bit Field]");
+                break;
+
+            default:
+
+                break;
+
+            }
+            break;
+
+        case ACPI_TYPE_PACKAGE:
+
+            if (Op->Asl.ParseOpcode == PARSEOP_NAME)
+            {
+                Op = Op->Asl.Child;
+            }
+
+            if ((Op->Asl.ParseOpcode == PARSEOP_NAMESEG)  ||
+                (Op->Asl.ParseOpcode == PARSEOP_NAMESTRING))
+            {
+                Op = Op->Asl.Next;
+            }
+
+            Op = Op->Asl.Child;
+
+            if ((Op->Asl.ParseOpcode == PARSEOP_BYTECONST) ||
+                (Op->Asl.ParseOpcode == PARSEOP_RAW_DATA))
+            {
+                FlPrintFile (ASL_FILE_NAMESPACE_OUTPUT,
+                    "       [Initial Length  0x%.2X elements]",
+                    Op->Asl.Value.Integer);
+            }
+            break;
+
+        case ACPI_TYPE_BUFFER:
+
+            if (Op->Asl.ParseOpcode == PARSEOP_NAME)
+            {
+                Op = Op->Asl.Child;
+            }
+
+            if ((Op->Asl.ParseOpcode == PARSEOP_NAMESEG)  ||
+                (Op->Asl.ParseOpcode == PARSEOP_NAMESTRING))
+            {
+                Op = Op->Asl.Next;
+            }
+
+            Op = Op->Asl.Child;
+
+            if (Op && (Op->Asl.ParseOpcode == PARSEOP_INTEGER))
+            {
+                FlPrintFile (ASL_FILE_NAMESPACE_OUTPUT,
+                    "        [Initial Length  0x%.2X bytes]",
+                    Op->Asl.Value.Integer);
+            }
+            break;
+
+        case ACPI_TYPE_METHOD:
+
+            FlPrintFile (ASL_FILE_NAMESPACE_OUTPUT,
+                "        [Code Length     0x%.4X bytes]",
+                Op->Asl.AmlSubtreeLength);
+            break;
+
+        case ACPI_TYPE_LOCAL_RESOURCE:
+
+            FlPrintFile (ASL_FILE_NAMESPACE_OUTPUT,
+                "  [Desc Offset     0x%.4X Bytes]", Node->Value);
+            break;
+
+        case ACPI_TYPE_LOCAL_RESOURCE_FIELD:
+
+            FlPrintFile (ASL_FILE_NAMESPACE_OUTPUT,
+                "   [Field Offset    0x%.4X Bits 0x%.4X Bytes] ",
+                Node->Value, Node->Value / 8);
+
+            if (Node->Flags & ANOBJ_IS_REFERENCED)
+            {
+                FlPrintFile (ASL_FILE_NAMESPACE_OUTPUT,
+                    "Referenced");
+            }
+            else
+            {
+                FlPrintFile (ASL_FILE_NAMESPACE_OUTPUT,
+                    "Name not referenced");
+            }
+            break;
+
+        default:
+
+            /* Nothing to do for other types */
+
+            break;
+        }
+    }
+
+    FlPrintFile (ASL_FILE_NAMESPACE_OUTPUT, "\n");
+    return (AE_OK);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    NsDoOnePathname
+ *
+ * PARAMETERS:  ACPI_WALK_CALLBACK
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Print the full pathname for a namespace node.
+ *
+ ******************************************************************************/
+
+static ACPI_STATUS
+NsDoOnePathname (
+    ACPI_HANDLE             ObjHandle,
+    UINT32                  Level,
+    void                    *Context,
+    void                    **ReturnValue)
+{
+    ACPI_NAMESPACE_NODE     *Node = (ACPI_NAMESPACE_NODE *) ObjHandle;
+    ACPI_STATUS             Status;
+    ACPI_BUFFER             TargetPath;
+
+
+    TargetPath.Length = ACPI_ALLOCATE_LOCAL_BUFFER;
+    Status = AcpiNsHandleToPathname (Node, &TargetPath, FALSE);
+    if (ACPI_FAILURE (Status))
+    {
+        return (Status);
+    }
+
+    FlPrintFile (ASL_FILE_NAMESPACE_OUTPUT, "%s\n", TargetPath.Pointer);
+    ACPI_FREE (TargetPath.Pointer);
+    return (AE_OK);
+}
diff --git a/usr/src/cmd/acpi/iasl/asloffset.c b/usr/src/cmd/acpi/iasl/asloffset.c
new file mode 100644
index 0000000000..0e55c6b856
--- /dev/null
+++ b/usr/src/cmd/acpi/iasl/asloffset.c
@@ -0,0 +1,472 @@
+/******************************************************************************
+ *
+ * Module Name: asloffset - Generate a C "offset table" for BIOS use.
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2016, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include "aslcompiler.h"
+#include "aslcompiler.y.h"
+#include "amlcode.h"
+#include "acnamesp.h"
+
+
+#define _COMPONENT          ACPI_COMPILER
+        ACPI_MODULE_NAME    ("asloffset")
+
+
+/* Local prototypes */
+
+static void
+LsEmitOffsetTableEntry (
+    UINT32                  FileId,
+    ACPI_NAMESPACE_NODE     *Node,
+    UINT32                  NamepathOffset,
+    UINT32                  Offset,
+    char                    *OpName,
+    UINT64                  Value,
+    UINT8                   AmlOpcode,
+    UINT16                  ParentOpcode);
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    LsAmlOffsetWalk
+ *
+ * PARAMETERS:  ASL_WALK_CALLBACK
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Process one node during a offset table file generation.
+ *
+ * Three types of objects are currently emitted to the offset table:
+ *   1) Tagged (named) resource descriptors
+ *   2) Named integer objects with constant integer values
+ *   3) Named package objects
+ *   4) Operation Regions that have constant Offset (address) parameters
+ *   5) Control methods
+ *
+ * The offset table allows the BIOS to dynamically update the values of these
+ * objects at boot time.
+ *
+ ******************************************************************************/
+
+ACPI_STATUS
+LsAmlOffsetWalk (
+    ACPI_PARSE_OBJECT       *Op,
+    UINT32                  Level,
+    void                    *Context)
+{
+    UINT32                  FileId = (UINT32) ACPI_TO_INTEGER (Context);
+    ACPI_NAMESPACE_NODE     *Node;
+    UINT32                  Length;
+    UINT32                  NamepathOffset;
+    UINT32                  DataOffset;
+    ACPI_PARSE_OBJECT       *NextOp;
+
+
+    /* Ignore actual data blocks for resource descriptors */
+
+    if (Op->Asl.CompileFlags & NODE_IS_RESOURCE_DATA)
+    {
+        return (AE_OK); /* Do NOT update the global AML offset */
+    }
+
+    /* We are only interested in named objects (have a namespace node) */
+
+    Node = Op->Asl.Node;
+    if (!Node)
+    {
+        Gbl_CurrentAmlOffset += Op->Asl.FinalAmlLength;
+        return (AE_OK);
+    }
+
+    /* Named resource descriptor (has a descriptor tag) */
+
+    if ((Node->Type == ACPI_TYPE_LOCAL_RESOURCE) &&
+        (Op->Asl.CompileFlags & NODE_IS_RESOURCE_DESC))
+    {
+        LsEmitOffsetTableEntry (FileId, Node, 0, Gbl_CurrentAmlOffset,
+            Op->Asl.ParseOpName, 0, Op->Asl.Extra, AML_BUFFER_OP);
+
+        Gbl_CurrentAmlOffset += Op->Asl.FinalAmlLength;
+        return (AE_OK);
+    }
+
+    switch (Op->Asl.AmlOpcode)
+    {
+    case AML_NAME_OP:
+
+        /* Named object -- Name (NameString, DataRefObject) */
+
+        if (!Op->Asl.Child)
+        {
+            FlPrintFile (FileId, "%s NO CHILD!\n", MsgBuffer);
+            return (AE_OK);
+        }
+
+        Length = Op->Asl.FinalAmlLength;
+        NamepathOffset = Gbl_CurrentAmlOffset + Length;
+
+        /* Get to the NameSeg/NamePath Op (and length of the name) */
+
+        Op = Op->Asl.Child;
+
+        /* Get offset of last nameseg and the actual data */
+
+        NamepathOffset = Gbl_CurrentAmlOffset + Length +
+            (Op->Asl.FinalAmlLength - ACPI_NAME_SIZE);
+
+        DataOffset = Gbl_CurrentAmlOffset + Length +
+            Op->Asl.FinalAmlLength;
+
+        /* Get actual value associated with the name */
+
+        Op = Op->Asl.Next;
+        switch (Op->Asl.AmlOpcode)
+        {
+        case AML_BYTE_OP:
+        case AML_WORD_OP:
+        case AML_DWORD_OP:
+        case AML_QWORD_OP:
+
+            /* The +1 is to handle the integer size prefix (opcode) */
+
+            LsEmitOffsetTableEntry (FileId, Node, NamepathOffset, (DataOffset + 1),
+                Op->Asl.ParseOpName, Op->Asl.Value.Integer,
+                (UINT8) Op->Asl.AmlOpcode, AML_NAME_OP);
+            break;
+
+        case AML_ONE_OP:
+        case AML_ONES_OP:
+        case AML_ZERO_OP:
+
+            /* For these, offset will point to the opcode */
+
+            LsEmitOffsetTableEntry (FileId, Node, NamepathOffset, DataOffset,
+                Op->Asl.ParseOpName, Op->Asl.Value.Integer,
+                (UINT8) Op->Asl.AmlOpcode, AML_NAME_OP);
+            break;
+
+        case AML_PACKAGE_OP:
+        case AML_VAR_PACKAGE_OP:
+
+            /* Get the package element count */
+
+            NextOp = Op->Asl.Child;
+
+            LsEmitOffsetTableEntry (FileId, Node, NamepathOffset, DataOffset,
+                Op->Asl.ParseOpName, NextOp->Asl.Value.Integer,
+                (UINT8) Op->Asl.AmlOpcode, AML_NAME_OP);
+            break;
+
+         default:
+             break;
+        }
+
+        Gbl_CurrentAmlOffset += Length;
+        return (AE_OK);
+
+    case AML_REGION_OP:
+
+        /* OperationRegion (NameString, RegionSpace, RegionOffset, RegionLength) */
+
+        Length = Op->Asl.FinalAmlLength;
+
+        /* Get the name/namepath node */
+
+        NextOp = Op->Asl.Child;
+
+        /* Get offset of last nameseg and the actual data */
+
+        NamepathOffset = Gbl_CurrentAmlOffset + Length +
+            (NextOp->Asl.FinalAmlLength - ACPI_NAME_SIZE);
+
+        DataOffset = Gbl_CurrentAmlOffset + Length +
+            (NextOp->Asl.FinalAmlLength + 1);
+
+        /* Get the SpaceId node, then the Offset (address) node */
+
+        NextOp = NextOp->Asl.Next;
+        NextOp = NextOp->Asl.Next;
+
+        switch (NextOp->Asl.AmlOpcode)
+        {
+        /*
+         * We are only interested in integer constants that can be changed
+         * at boot time. Note, the One/Ones/Zero opcodes are considered
+         * non-changeable, so we ignore them here.
+         */
+        case AML_BYTE_OP:
+        case AML_WORD_OP:
+        case AML_DWORD_OP:
+        case AML_QWORD_OP:
+
+            LsEmitOffsetTableEntry (FileId, Node, NamepathOffset, (DataOffset + 1),
+                Op->Asl.ParseOpName, NextOp->Asl.Value.Integer,
+                (UINT8) NextOp->Asl.AmlOpcode, AML_REGION_OP);
+
+            Gbl_CurrentAmlOffset += Length;
+            return (AE_OK);
+
+        default:
+            break;
+        }
+        break;
+
+    case AML_METHOD_OP:
+
+        /* Method (Namepath, ...) */
+
+        Length = Op->Asl.FinalAmlLength;
+
+        /* Get the NameSeg/NamePath Op */
+
+        NextOp = Op->Asl.Child;
+
+        /* Get offset of last nameseg and the actual data (flags byte) */
+
+        NamepathOffset = Gbl_CurrentAmlOffset + Length +
+            (NextOp->Asl.FinalAmlLength - ACPI_NAME_SIZE);
+
+        DataOffset = Gbl_CurrentAmlOffset + Length +
+            NextOp->Asl.FinalAmlLength;
+
+        /* Get the flags byte Op */
+
+        NextOp = NextOp->Asl.Next;
+
+        LsEmitOffsetTableEntry (FileId, Node, NamepathOffset, DataOffset,
+            Op->Asl.ParseOpName, NextOp->Asl.Value.Integer,
+            (UINT8) Op->Asl.AmlOpcode, AML_METHOD_OP);
+        break;
+
+    case AML_PROCESSOR_OP:
+
+        /* Processor (Namepath, ProcessorId, Address, Length) */
+
+        Length = Op->Asl.FinalAmlLength;
+        NextOp = Op->Asl.Child;     /* Get Namepath */
+
+        /* Get offset of last nameseg and the actual data (PBlock address) */
+
+        NamepathOffset = Gbl_CurrentAmlOffset + Length +
+            (NextOp->Asl.FinalAmlLength - ACPI_NAME_SIZE);
+
+        DataOffset = Gbl_CurrentAmlOffset + Length +
+            (NextOp->Asl.FinalAmlLength + 1);
+
+        NextOp = NextOp->Asl.Next;  /* Get ProcessorID (BYTE) */
+        NextOp = NextOp->Asl.Next;  /* Get Address (DWORD) */
+
+        LsEmitOffsetTableEntry (FileId, Node, NamepathOffset, DataOffset,
+            Op->Asl.ParseOpName, NextOp->Asl.Value.Integer,
+            (UINT8) AML_DWORD_OP, AML_PROCESSOR_OP);
+        break;
+
+    case AML_DEVICE_OP:
+    case AML_SCOPE_OP:
+    case AML_THERMAL_ZONE_OP:
+
+        /* Device/Scope/ThermalZone (Namepath) */
+
+        Length = Op->Asl.FinalAmlLength;
+        NextOp = Op->Asl.Child;     /* Get Namepath */
+
+        /* Get offset of last nameseg */
+
+        NamepathOffset = Gbl_CurrentAmlOffset + Length +
+            (NextOp->Asl.FinalAmlLength - ACPI_NAME_SIZE);
+
+        LsEmitOffsetTableEntry (FileId, Node, NamepathOffset, 0,
+            Op->Asl.ParseOpName, 0, (UINT8) 0, Op->Asl.AmlOpcode);
+        break;
+
+    default:
+        break;
+    }
+
+    Gbl_CurrentAmlOffset += Op->Asl.FinalAmlLength;
+    return (AE_OK);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    LsEmitOffsetTableEntry
+ *
+ * PARAMETERS:  FileId          - ID of current listing file
+ *              Node            - Namespace node associated with the name
+ *              Offset          - Offset of the value within the AML table
+ *              OpName          - Name of the AML opcode
+ *              Value           - Current value of the AML field
+ *              AmlOpcode       - Opcode associated with the field
+ *              ObjectType      - ACPI object type
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Emit a line of the offset table (-so option)
+ *
+ ******************************************************************************/
+
+static void
+LsEmitOffsetTableEntry (
+    UINT32                  FileId,
+    ACPI_NAMESPACE_NODE     *Node,
+    UINT32                  NamepathOffset,
+    UINT32                  Offset,
+    char                    *OpName,
+    UINT64                  Value,
+    UINT8                   AmlOpcode,
+    UINT16                  ParentOpcode)
+{
+    ACPI_BUFFER             TargetPath;
+    ACPI_STATUS             Status;
+
+
+    /* Get the full pathname to the namespace node */
+
+    TargetPath.Length = ACPI_ALLOCATE_LOCAL_BUFFER;
+    Status = AcpiNsHandleToPathname (Node, &TargetPath, FALSE);
+    if (ACPI_FAILURE (Status))
+    {
+        return;
+    }
+
+    /* [1] - Skip the opening backslash for the path */
+
+    strcpy (MsgBuffer, "\"");
+    strcat (MsgBuffer, &((char *) TargetPath.Pointer)[1]);
+    strcat (MsgBuffer, "\",");
+    ACPI_FREE (TargetPath.Pointer);
+
+    /*
+     * Max offset is 4G, constrained by 32-bit ACPI table length.
+     * Max Length for Integers is 8 bytes.
+     */
+    FlPrintFile (FileId,
+        "    {%-29s 0x%4.4X, 0x%8.8X, 0x%2.2X, 0x%8.8X, 0x%8.8X%8.8X}, /* %s */\n",
+        MsgBuffer, ParentOpcode, NamepathOffset, AmlOpcode,
+        Offset, ACPI_FORMAT_UINT64 (Value), OpName);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    LsDoOffsetTableHeader, LsDoOffsetTableFooter
+ *
+ * PARAMETERS:  FileId          - ID of current listing file
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Header and footer for the offset table file.
+ *
+ ******************************************************************************/
+
+void
+LsDoOffsetTableHeader (
+    UINT32                  FileId)
+{
+
+    FlPrintFile (FileId,
+        "#ifndef __AML_OFFSET_TABLE_H\n"
+        "#define __AML_OFFSET_TABLE_H\n\n");
+
+    FlPrintFile (FileId, "typedef struct {\n"
+        "    char                   *Pathname;      /* Full pathname (from root) to the object */\n"
+        "    unsigned short         ParentOpcode;   /* AML opcode for the parent object */\n"
+        "    unsigned long          NamesegOffset;  /* Offset of last nameseg in the parent namepath */\n"
+        "    unsigned char          Opcode;         /* AML opcode for the data */\n"
+        "    unsigned long          Offset;         /* Offset for the data */\n"
+        "    unsigned long long     Value;          /* Original value of the data (as applicable) */\n"
+        "} AML_OFFSET_TABLE_ENTRY;\n\n");
+
+    FlPrintFile (FileId,
+        "#endif /* __AML_OFFSET_TABLE_H */\n\n");
+
+    FlPrintFile (FileId,
+        "/*\n"
+        " * Information specific to the supported object types:\n"
+        " *\n"
+        " * Integers:\n"
+        " *    Opcode is the integer prefix, indicates length of the data\n"
+        " *        (One of: BYTE, WORD, DWORD, QWORD, ZERO, ONE, ONES)\n"
+        " *    Offset points to the actual integer data\n"
+        " *    Value is the existing value in the AML\n"
+        " *\n"
+        " * Packages:\n"
+        " *    Opcode is the package or var_package opcode\n"
+        " *    Offset points to the package opcode\n"
+        " *    Value is the package element count\n"
+        " *\n"
+        " * Operation Regions:\n"
+        " *    Opcode is the address integer prefix, indicates length of the data\n"
+        " *    Offset points to the region address\n"
+        " *    Value is the existing address value in the AML\n"
+        " *\n"
+        " * Control Methods:\n"
+        " *    Offset points to the method flags byte\n"
+        " *    Value is the existing flags value in the AML\n"
+        " *\n"
+        " * Processors:\n"
+        " *    Offset points to the first byte of the PBlock Address\n"
+        " *\n"
+        " * Resource Descriptors:\n"
+        " *    Opcode is the descriptor type\n"
+        " *    Offset points to the start of the descriptor\n"
+        " *\n"
+        " * Scopes/Devices/ThermalZones:\n"
+        " *    Nameseg offset only\n"
+        " */\n");
+
+    FlPrintFile (FileId,
+        "AML_OFFSET_TABLE_ENTRY   %s_%s_OffsetTable[] =\n{\n",
+        Gbl_TableSignature, Gbl_TableId);
+}
+
+
+void
+LsDoOffsetTableFooter (
+    UINT32                  FileId)
+{
+
+    FlPrintFile (FileId,
+        "    {NULL,0,0,0,0,0} /* Table terminator */\n};\n\n");
+    Gbl_CurrentAmlOffset = 0;
+}
diff --git a/usr/src/cmd/acpi/iasl/aslopcodes.c b/usr/src/cmd/acpi/iasl/aslopcodes.c
new file mode 100644
index 0000000000..de9ffe1baf
--- /dev/null
+++ b/usr/src/cmd/acpi/iasl/aslopcodes.c
@@ -0,0 +1,843 @@
+/******************************************************************************
+ *
+ * Module Name: aslopcode - AML opcode generation
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2016, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include "aslcompiler.h"
+#include "aslcompiler.y.h"
+#include "amlcode.h"
+
+#define _COMPONENT          ACPI_COMPILER
+        ACPI_MODULE_NAME    ("aslopcodes")
+
+
+/* Local prototypes */
+
+static void
+OpcDoAccessAs (
+    ACPI_PARSE_OBJECT       *Op);
+
+static void
+OpcDoConnection (
+    ACPI_PARSE_OBJECT       *Op);
+
+static void
+OpcDoUnicode (
+    ACPI_PARSE_OBJECT       *Op);
+
+static void
+OpcDoEisaId (
+    ACPI_PARSE_OBJECT       *Op);
+
+static void
+OpcDoUuId (
+    ACPI_PARSE_OBJECT       *Op);
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    OpcAmlOpcodeUpdateWalk
+ *
+ * PARAMETERS:  ASL_WALK_CALLBACK
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Opcode update walk, ascending callback
+ *
+ ******************************************************************************/
+
+ACPI_STATUS
+OpcAmlOpcodeUpdateWalk (
+    ACPI_PARSE_OBJECT       *Op,
+    UINT32                  Level,
+    void                    *Context)
+{
+
+    /*
+     * Handle the Package() case where the actual opcode cannot be determined
+     * until the PackageLength operand has been folded and minimized.
+     * (PackageOp versus VarPackageOp)
+     *
+     * This is (as of ACPI 3.0) the only case where the AML opcode can change
+     * based upon the value of a parameter.
+     *
+     * The parser always inserts a VarPackage opcode, which can possibly be
+     * optimized to a Package opcode.
+     */
+    if (Op->Asl.ParseOpcode == PARSEOP_VAR_PACKAGE)
+    {
+        OpnDoPackage (Op);
+    }
+
+    return (AE_OK);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    OpcAmlOpcodeWalk
+ *
+ * PARAMETERS:  ASL_WALK_CALLBACK
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Parse tree walk to generate both the AML opcodes and the AML
+ *              operands.
+ *
+ ******************************************************************************/
+
+ACPI_STATUS
+OpcAmlOpcodeWalk (
+    ACPI_PARSE_OBJECT       *Op,
+    UINT32                  Level,
+    void                    *Context)
+{
+
+    TotalParseNodes++;
+
+    OpcGenerateAmlOpcode (Op);
+    OpnGenerateAmlOperands (Op);
+    return (AE_OK);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    OpcGetIntegerWidth
+ *
+ * PARAMETERS:  Op          - DEFINITION BLOCK op
+ *
+ * RETURN:      none
+ *
+ * DESCRIPTION: Extract integer width from the table revision
+ *
+ ******************************************************************************/
+
+void
+OpcGetIntegerWidth (
+    ACPI_PARSE_OBJECT       *Op)
+{
+    ACPI_PARSE_OBJECT       *Child;
+
+
+    if (!Op)
+    {
+        return;
+    }
+
+    if (Gbl_RevisionOverride)
+    {
+        AcpiUtSetIntegerWidth (Gbl_RevisionOverride);
+    }
+    else
+    {
+        Child = Op->Asl.Child;
+        Child = Child->Asl.Next;
+        Child = Child->Asl.Next;
+
+        /* Use the revision to set the integer width */
+
+        AcpiUtSetIntegerWidth ((UINT8) Child->Asl.Value.Integer);
+    }
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    OpcSetOptimalIntegerSize
+ *
+ * PARAMETERS:  Op        - A parse tree node
+ *
+ * RETURN:      Integer width, in bytes. Also sets the node AML opcode to the
+ *              optimal integer AML prefix opcode.
+ *
+ * DESCRIPTION: Determine the optimal AML encoding of an integer. All leading
+ *              zeros can be truncated to squeeze the integer into the
+ *              minimal number of AML bytes.
+ *
+ ******************************************************************************/
+
+UINT32
+OpcSetOptimalIntegerSize (
+    ACPI_PARSE_OBJECT       *Op)
+{
+
+#if 0
+    /*
+     * TBD: - we don't want to optimize integers in the block header, but the
+     * code below does not work correctly.
+     */
+    if (Op->Asl.Parent &&
+        Op->Asl.Parent->Asl.Parent &&
+       (Op->Asl.Parent->Asl.Parent->Asl.ParseOpcode == PARSEOP_DEFINITION_BLOCK))
+    {
+        return (0);
+    }
+#endif
+
+    /*
+     * Check for the special AML integers first - Zero, One, Ones.
+     * These are single-byte opcodes that are the smallest possible
+     * representation of an integer.
+     *
+     * This optimization is optional.
+     */
+    if (Gbl_IntegerOptimizationFlag)
+    {
+        switch (Op->Asl.Value.Integer)
+        {
+        case 0:
+
+            Op->Asl.AmlOpcode = AML_ZERO_OP;
+            AslError (ASL_OPTIMIZATION, ASL_MSG_INTEGER_OPTIMIZATION,
+                Op, "Zero");
+            return (1);
+
+        case 1:
+
+            Op->Asl.AmlOpcode = AML_ONE_OP;
+            AslError (ASL_OPTIMIZATION, ASL_MSG_INTEGER_OPTIMIZATION,
+                Op, "One");
+            return (1);
+
+        case ACPI_UINT32_MAX:
+
+            /* Check for table integer width (32 or 64) */
+
+            if (AcpiGbl_IntegerByteWidth == 4)
+            {
+                Op->Asl.AmlOpcode = AML_ONES_OP;
+                AslError (ASL_OPTIMIZATION, ASL_MSG_INTEGER_OPTIMIZATION,
+                    Op, "Ones");
+                return (1);
+            }
+            break;
+
+        case ACPI_UINT64_MAX:
+
+            /* Check for table integer width (32 or 64) */
+
+            if (AcpiGbl_IntegerByteWidth == 8)
+            {
+                Op->Asl.AmlOpcode = AML_ONES_OP;
+                AslError (ASL_OPTIMIZATION, ASL_MSG_INTEGER_OPTIMIZATION,
+                    Op, "Ones");
+                return (1);
+            }
+            break;
+
+        default:
+
+            break;
+        }
+    }
+
+    /* Find the best fit using the various AML integer prefixes */
+
+    if (Op->Asl.Value.Integer <= ACPI_UINT8_MAX)
+    {
+        Op->Asl.AmlOpcode = AML_BYTE_OP;
+        return (1);
+    }
+
+    if (Op->Asl.Value.Integer <= ACPI_UINT16_MAX)
+    {
+        Op->Asl.AmlOpcode = AML_WORD_OP;
+        return (2);
+    }
+
+    if (Op->Asl.Value.Integer <= ACPI_UINT32_MAX)
+    {
+        Op->Asl.AmlOpcode = AML_DWORD_OP;
+        return (4);
+    }
+    else
+    {
+        if (AcpiGbl_IntegerByteWidth == 4)
+        {
+            AslError (ASL_WARNING, ASL_MSG_INTEGER_LENGTH,
+                Op, NULL);
+
+            if (!Gbl_IgnoreErrors)
+            {
+                /* Truncate the integer to 32-bit */
+                Op->Asl.AmlOpcode = AML_DWORD_OP;
+                return (4);
+            }
+        }
+
+        Op->Asl.AmlOpcode = AML_QWORD_OP;
+        return (8);
+    }
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    OpcDoAccessAs
+ *
+ * PARAMETERS:  Op        - Parse node
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Implement the ACCESS_AS ASL keyword.
+ *
+ ******************************************************************************/
+
+static void
+OpcDoAccessAs (
+    ACPI_PARSE_OBJECT       *Op)
+{
+    ACPI_PARSE_OBJECT       *TypeOp;
+    ACPI_PARSE_OBJECT       *AttribOp;
+    ACPI_PARSE_OBJECT       *LengthOp;
+    UINT8                   Attribute;
+
+
+    Op->Asl.AmlOpcodeLength = 1;
+    TypeOp = Op->Asl.Child;
+
+    /* First child is the access type */
+
+    TypeOp->Asl.AmlOpcode = AML_RAW_DATA_BYTE;
+    TypeOp->Asl.ParseOpcode = PARSEOP_RAW_DATA;
+
+    /* Second child is the optional access attribute */
+
+    AttribOp = TypeOp->Asl.Next;
+    if (AttribOp->Asl.ParseOpcode == PARSEOP_DEFAULT_ARG)
+    {
+        AttribOp->Asl.Value.Integer = 0;
+    }
+
+    AttribOp->Asl.AmlOpcode = AML_RAW_DATA_BYTE;
+    AttribOp->Asl.ParseOpcode = PARSEOP_RAW_DATA;
+
+    /* Only a few AccessAttributes support AccessLength */
+
+    Attribute = (UINT8) AttribOp->Asl.Value.Integer;
+    if ((Attribute != AML_FIELD_ATTRIB_MULTIBYTE) &&
+        (Attribute != AML_FIELD_ATTRIB_RAW_BYTES) &&
+        (Attribute != AML_FIELD_ATTRIB_RAW_PROCESS))
+    {
+        return;
+    }
+
+    Op->Asl.AmlOpcode = AML_FIELD_EXT_ACCESS_OP;
+
+    /*
+     * Child of Attributes is the AccessLength (required for Multibyte,
+     * RawBytes, RawProcess.)
+     */
+    LengthOp = AttribOp->Asl.Child;
+    if (!LengthOp)
+    {
+        return;
+    }
+
+    /* TBD: probably can remove */
+
+    if (LengthOp->Asl.ParseOpcode == PARSEOP_DEFAULT_ARG)
+    {
+        LengthOp->Asl.Value.Integer = 16;
+    }
+
+    LengthOp->Asl.AmlOpcode = AML_RAW_DATA_BYTE;
+    LengthOp->Asl.ParseOpcode = PARSEOP_RAW_DATA;
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    OpcDoConnection
+ *
+ * PARAMETERS:  Op        - Parse node
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Implement the Connection ASL keyword.
+ *
+ ******************************************************************************/
+
+static void
+OpcDoConnection (
+    ACPI_PARSE_OBJECT       *Op)
+{
+    ASL_RESOURCE_NODE       *Rnode;
+    ACPI_PARSE_OBJECT       *BufferOp;
+    ACPI_PARSE_OBJECT       *BufferLengthOp;
+    ACPI_PARSE_OBJECT       *BufferDataOp;
+    ASL_RESOURCE_INFO       Info;
+    UINT8                   State;
+
+
+    Op->Asl.AmlOpcodeLength = 1;
+
+    if (Op->Asl.Child->Asl.AmlOpcode == AML_INT_NAMEPATH_OP)
+    {
+        return;
+    }
+
+    BufferOp = Op->Asl.Child;
+    BufferLengthOp = BufferOp->Asl.Child;
+    BufferDataOp = BufferLengthOp->Asl.Next;
+
+    Info.DescriptorTypeOp = BufferDataOp->Asl.Next;
+    Info.CurrentByteOffset = 0;
+    State = ACPI_RSTATE_NORMAL;
+    Rnode = RsDoOneResourceDescriptor (&Info, &State);
+    if (!Rnode)
+    {
+        return; /* error */
+    }
+
+    /*
+     * Transform the nodes into the following
+     *
+     * Op           -> AML_BUFFER_OP
+     * First Child  -> BufferLength
+     * Second Child -> Descriptor Buffer (raw byte data)
+     */
+    BufferOp->Asl.ParseOpcode = PARSEOP_BUFFER;
+    BufferOp->Asl.AmlOpcode = AML_BUFFER_OP;
+    BufferOp->Asl.CompileFlags = NODE_AML_PACKAGE | NODE_IS_RESOURCE_DESC;
+    UtSetParseOpName (BufferOp);
+
+    BufferLengthOp->Asl.ParseOpcode = PARSEOP_INTEGER;
+    BufferLengthOp->Asl.Value.Integer = Rnode->BufferLength;
+    (void) OpcSetOptimalIntegerSize (BufferLengthOp);
+    UtSetParseOpName (BufferLengthOp);
+
+    BufferDataOp->Asl.ParseOpcode = PARSEOP_RAW_DATA;
+    BufferDataOp->Asl.AmlOpcode = AML_RAW_DATA_CHAIN;
+    BufferDataOp->Asl.AmlOpcodeLength = 0;
+    BufferDataOp->Asl.AmlLength = Rnode->BufferLength;
+    BufferDataOp->Asl.Value.Buffer = (UINT8 *) Rnode;
+    UtSetParseOpName (BufferDataOp);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    OpcDoUnicode
+ *
+ * PARAMETERS:  Op        - Parse node
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Implement the UNICODE ASL "macro".  Convert the input string
+ *              to a unicode buffer. There is no Unicode AML opcode.
+ *
+ * Note:  The Unicode string is 16 bits per character, no leading signature,
+ *        with a 16-bit terminating NULL.
+ *
+ ******************************************************************************/
+
+static void
+OpcDoUnicode (
+    ACPI_PARSE_OBJECT       *Op)
+{
+    ACPI_PARSE_OBJECT       *InitializerOp;
+    UINT32                  Length;
+    UINT32                  Count;
+    UINT32                  i;
+    UINT8                   *AsciiString;
+    UINT16                  *UnicodeString;
+    ACPI_PARSE_OBJECT       *BufferLengthOp;
+
+
+    /* Change op into a buffer object */
+
+    Op->Asl.CompileFlags &= ~NODE_COMPILE_TIME_CONST;
+    Op->Asl.ParseOpcode = PARSEOP_BUFFER;
+    UtSetParseOpName (Op);
+
+    /* Buffer Length is first, followed by the string */
+
+    BufferLengthOp = Op->Asl.Child;
+    InitializerOp = BufferLengthOp->Asl.Next;
+
+    AsciiString = (UINT8 *) InitializerOp->Asl.Value.String;
+
+    /* Create a new buffer for the Unicode string */
+
+    Count = strlen (InitializerOp->Asl.Value.String) + 1;
+    Length = Count * sizeof (UINT16);
+    UnicodeString = UtLocalCalloc (Length);
+
+    /* Convert to Unicode string (including null terminator) */
+
+    for (i = 0; i < Count; i++)
+    {
+        UnicodeString[i] = (UINT16) AsciiString[i];
+    }
+
+    /*
+     * Just set the buffer size node to be the buffer length, regardless
+     * of whether it was previously an integer or a default_arg placeholder
+     */
+    BufferLengthOp->Asl.ParseOpcode = PARSEOP_INTEGER;
+    BufferLengthOp->Asl.AmlOpcode = AML_DWORD_OP;
+    BufferLengthOp->Asl.Value.Integer = Length;
+    UtSetParseOpName (BufferLengthOp);
+
+    (void) OpcSetOptimalIntegerSize (BufferLengthOp);
+
+    /* The Unicode string is a raw data buffer */
+
+    InitializerOp->Asl.Value.Buffer = (UINT8 *) UnicodeString;
+    InitializerOp->Asl.AmlOpcode = AML_RAW_DATA_BUFFER;
+    InitializerOp->Asl.AmlLength = Length;
+    InitializerOp->Asl.ParseOpcode = PARSEOP_RAW_DATA;
+    InitializerOp->Asl.Child = NULL;
+    UtSetParseOpName (InitializerOp);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    OpcDoEisaId
+ *
+ * PARAMETERS:  Op        - Parse node
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Convert a string EISA ID to numeric representation. See the
+ *              Pnp BIOS Specification for details. Here is an excerpt:
+ *
+ *              A seven character ASCII representation of the product
+ *              identifier compressed into a 32-bit identifier. The seven
+ *              character ID consists of a three character manufacturer code,
+ *              a three character hexadecimal product identifier, and a one
+ *              character hexadecimal revision number. The manufacturer code
+ *              is a 3 uppercase character code that is compressed into 3 5-bit
+ *              values as follows:
+ *                  1) Find hex ASCII value for each letter
+ *                  2) Subtract 40h from each ASCII value
+ *                  3) Retain 5 least significant bits for each letter by
+ *                     discarding upper 3 bits because they are always 0.
+ *                  4) Compressed code = concatenate 0 and the 3 5-bit values
+ *
+ *              The format of the compressed product identifier is as follows:
+ *              Byte 0: Bit 7       - Reserved (0)
+ *                      Bits 6-2:   - 1st character of compressed mfg code
+ *                      Bits 1-0    - Upper 2 bits of 2nd character of mfg code
+ *              Byte 1: Bits 7-5    - Lower 3 bits of 2nd character of mfg code
+ *                      Bits 4-0    - 3rd character of mfg code
+ *              Byte 2: Bits 7-4    - 1st hex digit of product number
+ *                      Bits 3-0    - 2nd hex digit of product number
+ *              Byte 3: Bits 7-4    - 3st hex digit of product number
+ *                      Bits 3-0    - Hex digit of the revision number
+ *
+ ******************************************************************************/
+
+static void
+OpcDoEisaId (
+    ACPI_PARSE_OBJECT       *Op)
+{
+    UINT32                  EisaId = 0;
+    UINT32                  BigEndianId;
+    char                    *InString;
+    ACPI_STATUS             Status = AE_OK;
+    UINT32                  i;
+
+
+    InString = (char *) Op->Asl.Value.String;
+
+    /*
+     * The EISAID string must be exactly 7 characters and of the form
+     * "UUUXXXX" -- 3 uppercase letters and 4 hex digits (e.g., "PNP0001")
+     */
+    if (strlen (InString) != 7)
+    {
+        Status = AE_BAD_PARAMETER;
+    }
+    else
+    {
+        /* Check all 7 characters for correct format */
+
+        for (i = 0; i < 7; i++)
+        {
+            /* First 3 characters must be uppercase letters */
+
+            if (i < 3)
+            {
+                if (!isupper ((int) InString[i]))
+                {
+                    Status = AE_BAD_PARAMETER;
+                }
+            }
+
+            /* Last 4 characters must be hex digits */
+
+            else if (!isxdigit ((int) InString[i]))
+            {
+                Status = AE_BAD_PARAMETER;
+            }
+        }
+    }
+
+    if (ACPI_FAILURE (Status))
+    {
+        AslError (ASL_ERROR, ASL_MSG_INVALID_EISAID, Op, Op->Asl.Value.String);
+    }
+    else
+    {
+        /* Create ID big-endian first (bits are contiguous) */
+
+        BigEndianId =
+            (UINT32) ((UINT8) (InString[0] - 0x40)) << 26 |
+            (UINT32) ((UINT8) (InString[1] - 0x40)) << 21 |
+            (UINT32) ((UINT8) (InString[2] - 0x40)) << 16 |
+
+            (AcpiUtAsciiCharToHex (InString[3])) << 12 |
+            (AcpiUtAsciiCharToHex (InString[4])) << 8  |
+            (AcpiUtAsciiCharToHex (InString[5])) << 4  |
+             AcpiUtAsciiCharToHex (InString[6]);
+
+        /* Swap to little-endian to get final ID (see function header) */
+
+        EisaId = AcpiUtDwordByteSwap (BigEndianId);
+    }
+
+    /*
+     * Morph the Op into an integer, regardless of whether there
+     * was an error in the EISAID string
+     */
+    Op->Asl.Value.Integer = EisaId;
+
+    Op->Asl.CompileFlags &= ~NODE_COMPILE_TIME_CONST;
+    Op->Asl.ParseOpcode = PARSEOP_INTEGER;
+    (void) OpcSetOptimalIntegerSize (Op);
+
+    /* Op is now an integer */
+
+    UtSetParseOpName (Op);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    OpcDoUuId
+ *
+ * PARAMETERS:  Op                  - Parse node
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Convert UUID string to 16-byte buffer
+ *
+ ******************************************************************************/
+
+static void
+OpcDoUuId (
+    ACPI_PARSE_OBJECT       *Op)
+{
+    char                    *InString;
+    UINT8                   *Buffer;
+    ACPI_STATUS             Status = AE_OK;
+    ACPI_PARSE_OBJECT       *NewOp;
+
+
+    InString = ACPI_CAST_PTR (char, Op->Asl.Value.String);
+    Buffer = UtLocalCalloc (16);
+
+    Status = AuValidateUuid (InString);
+    if (ACPI_FAILURE (Status))
+    {
+        AslError (ASL_ERROR, ASL_MSG_INVALID_UUID, Op, Op->Asl.Value.String);
+    }
+    else
+    {
+        AcpiUtConvertStringToUuid (InString, Buffer);
+    }
+
+    /* Change Op to a Buffer */
+
+    Op->Asl.ParseOpcode = PARSEOP_BUFFER;
+    Op->Common.AmlOpcode = AML_BUFFER_OP;
+
+    /* Disable further optimization */
+
+    Op->Asl.CompileFlags &= ~NODE_COMPILE_TIME_CONST;
+    UtSetParseOpName (Op);
+
+    /* Child node is the buffer length */
+
+    NewOp = TrAllocateNode (PARSEOP_INTEGER);
+
+    NewOp->Asl.AmlOpcode = AML_BYTE_OP;
+    NewOp->Asl.Value.Integer = 16;
+    NewOp->Asl.Parent = Op;
+
+    Op->Asl.Child = NewOp;
+    Op = NewOp;
+
+    /* Peer to the child is the raw buffer data */
+
+    NewOp = TrAllocateNode (PARSEOP_RAW_DATA);
+    NewOp->Asl.AmlOpcode = AML_RAW_DATA_BUFFER;
+    NewOp->Asl.AmlLength = 16;
+    NewOp->Asl.Value.String = ACPI_CAST_PTR (char, Buffer);
+    NewOp->Asl.Parent = Op->Asl.Parent;
+
+    Op->Asl.Next = NewOp;
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    OpcGenerateAmlOpcode
+ *
+ * PARAMETERS:  Op                  - Parse node
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Generate the AML opcode associated with the node and its
+ *              parse (lex/flex) keyword opcode. Essentially implements
+ *              a mapping between the parse opcodes and the actual AML opcodes.
+ *
+ ******************************************************************************/
+
+void
+OpcGenerateAmlOpcode (
+    ACPI_PARSE_OBJECT       *Op)
+{
+    UINT16                  Index;
+
+
+    Index = (UINT16) (Op->Asl.ParseOpcode - ASL_PARSE_OPCODE_BASE);
+
+    Op->Asl.AmlOpcode     = AslKeywordMapping[Index].AmlOpcode;
+    Op->Asl.AcpiBtype     = AslKeywordMapping[Index].AcpiBtype;
+    Op->Asl.CompileFlags |= AslKeywordMapping[Index].Flags;
+
+    if (!Op->Asl.Value.Integer)
+    {
+        Op->Asl.Value.Integer = AslKeywordMapping[Index].Value;
+    }
+
+    /* Special handling for some opcodes */
+
+    switch (Op->Asl.ParseOpcode)
+    {
+    case PARSEOP_INTEGER:
+        /*
+         * Set the opcode based on the size of the integer
+         */
+        (void) OpcSetOptimalIntegerSize (Op);
+        break;
+
+    case PARSEOP_OFFSET:
+
+        Op->Asl.AmlOpcodeLength = 1;
+        break;
+
+    case PARSEOP_ACCESSAS:
+
+        OpcDoAccessAs (Op);
+        break;
+
+    case PARSEOP_CONNECTION:
+
+        OpcDoConnection (Op);
+        break;
+
+    case PARSEOP_EISAID:
+
+        OpcDoEisaId (Op);
+        break;
+
+    case PARSEOP_PRINTF:
+
+        OpcDoPrintf (Op);
+        break;
+
+    case PARSEOP_FPRINTF:
+
+        OpcDoFprintf (Op);
+        break;
+
+    case PARSEOP_TOPLD:
+
+        OpcDoPld (Op);
+        break;
+
+    case PARSEOP_TOUUID:
+
+        OpcDoUuId (Op);
+        break;
+
+    case PARSEOP_UNICODE:
+
+        OpcDoUnicode (Op);
+        break;
+
+    case PARSEOP_INCLUDE:
+
+        Gbl_HasIncludeFiles = TRUE;
+        break;
+
+    case PARSEOP_EXTERNAL:
+
+        if (Gbl_DoExternals == FALSE)
+        {
+            Op->Asl.Child->Asl.ParseOpcode = PARSEOP_DEFAULT_ARG;
+            Op->Asl.Child->Asl.Next->Asl.ParseOpcode = PARSEOP_DEFAULT_ARG;
+        }
+        break;
+
+    case PARSEOP_TIMER:
+
+        if (AcpiGbl_IntegerBitWidth == 32)
+        {
+            AslError (ASL_REMARK, ASL_MSG_TRUNCATION, Op, NULL);
+        }
+        break;
+
+    default:
+
+        /* Nothing to do for other opcodes */
+
+        break;
+    }
+
+    return;
+}
diff --git a/usr/src/cmd/acpi/iasl/asloperands.c b/usr/src/cmd/acpi/iasl/asloperands.c
new file mode 100644
index 0000000000..3f84114282
--- /dev/null
+++ b/usr/src/cmd/acpi/iasl/asloperands.c
@@ -0,0 +1,1196 @@
+/******************************************************************************
+ *
+ * Module Name: asloperands - AML operand processing
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2016, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include "aslcompiler.h"
+#include "aslcompiler.y.h"
+#include "amlcode.h"
+
+#define _COMPONENT          ACPI_COMPILER
+        ACPI_MODULE_NAME    ("asloperands")
+
+/* Local prototypes */
+
+static void
+OpnDoField (
+    ACPI_PARSE_OBJECT       *Op);
+
+static void
+OpnDoBankField (
+    ACPI_PARSE_OBJECT       *Op);
+
+static void
+OpnDoBuffer (
+    ACPI_PARSE_OBJECT       *Op);
+
+static void
+OpnDoDefinitionBlock (
+    ACPI_PARSE_OBJECT       *Op);
+
+static void
+OpnDoFieldCommon (
+    ACPI_PARSE_OBJECT       *FieldOp,
+    ACPI_PARSE_OBJECT       *Op);
+
+static void
+OpnDoIndexField (
+    ACPI_PARSE_OBJECT       *Op);
+
+static void
+OpnDoLoadTable (
+    ACPI_PARSE_OBJECT       *Op);
+
+static void
+OpnDoMethod (
+    ACPI_PARSE_OBJECT       *Op);
+
+static void
+OpnDoMutex (
+    ACPI_PARSE_OBJECT       *Op);
+
+static void
+OpnDoRegion (
+    ACPI_PARSE_OBJECT       *Op);
+
+static void
+OpnAttachNameToNode (
+    ACPI_PARSE_OBJECT       *Op);
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    OpnDoMutex
+ *
+ * PARAMETERS:  Op        - The parent parse node
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Construct the operands for the MUTEX ASL keyword.
+ *
+ ******************************************************************************/
+
+static void
+OpnDoMutex (
+    ACPI_PARSE_OBJECT       *Op)
+{
+    ACPI_PARSE_OBJECT       *Next;
+
+
+    Next = Op->Asl.Child;
+    Next = Next->Asl.Next;
+
+    if (Next->Asl.Value.Integer > 15)
+    {
+        AslError (ASL_ERROR, ASL_MSG_SYNC_LEVEL, Next, NULL);
+    }
+    return;
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    OpnDoMethod
+ *
+ * PARAMETERS:  Op        - The parent parse node
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Construct the operands for the METHOD ASL keyword.
+ *
+ ******************************************************************************/
+
+static void
+OpnDoMethod (
+    ACPI_PARSE_OBJECT       *Op)
+{
+    ACPI_PARSE_OBJECT       *Next;
+
+    /* Optional arguments for this opcode with defaults */
+
+    UINT8                   NumArgs = 0;
+    UINT8                   Serialized = 0;
+    UINT8                   Concurrency = 0;
+    UINT8                   MethodFlags;
+
+
+    /* Opcode and package length first */
+    /* Method name */
+
+    Next = Op->Asl.Child;
+
+    /* Num args */
+
+    Next = Next->Asl.Next;
+    if (Next->Asl.ParseOpcode != PARSEOP_DEFAULT_ARG)
+    {
+        NumArgs = (UINT8) Next->Asl.Value.Integer;
+        Next->Asl.ParseOpcode = PARSEOP_DEFAULT_ARG;
+    }
+
+    /* Serialized Flag */
+
+    Next = Next->Asl.Next;
+    if (Next->Asl.ParseOpcode != PARSEOP_DEFAULT_ARG)
+    {
+        Serialized = (UINT8) Next->Asl.Value.Integer;
+        Next->Asl.ParseOpcode = PARSEOP_DEFAULT_ARG;
+    }
+
+    /* Concurrency value (valid values are 0-15) */
+
+    Next = Next->Asl.Next;
+    if (Next->Asl.ParseOpcode != PARSEOP_DEFAULT_ARG)
+    {
+        /* This is a ByteConstExpr, so eval the constant now */
+
+        OpcAmlConstantWalk (Next, 0, NULL);
+
+        if (Next->Asl.Value.Integer > 15)
+        {
+            AslError (ASL_ERROR, ASL_MSG_SYNC_LEVEL, Next, NULL);
+        }
+
+        Concurrency = (UINT8) Next->Asl.Value.Integer;
+    }
+
+    /* Put the bits in their proper places */
+
+    MethodFlags = (UINT8)
+        ((NumArgs & 0x7) |
+        ((Serialized & 0x1) << 3) |
+        ((Concurrency & 0xF) << 4));
+
+    /* Use the last node for the combined flags byte */
+
+    Next->Asl.Value.Integer = MethodFlags;
+    Next->Asl.AmlOpcode = AML_RAW_DATA_BYTE;
+    Next->Asl.AmlLength = 1;
+    Next->Asl.ParseOpcode = PARSEOP_RAW_DATA;
+
+    /* Save the arg count in the first node */
+
+    Op->Asl.Extra = NumArgs;
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    OpnDoFieldCommon
+ *
+ * PARAMETERS:  FieldOp       - Node for an ASL field
+ *              Op            - The parent parse node
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Construct the AML operands for the various field keywords,
+ *              FIELD, BANKFIELD, INDEXFIELD
+ *
+ ******************************************************************************/
+
+static void
+OpnDoFieldCommon (
+    ACPI_PARSE_OBJECT       *FieldOp,
+    ACPI_PARSE_OBJECT       *Op)
+{
+    ACPI_PARSE_OBJECT       *Next;
+    ACPI_PARSE_OBJECT       *PkgLengthNode;
+    UINT32                  CurrentBitOffset;
+    UINT32                  NewBitOffset;
+    UINT8                   AccessType;
+    UINT8                   LockRule;
+    UINT8                   UpdateRule;
+    UINT8                   FieldFlags;
+    UINT32                  MinimumLength;
+
+
+    /* AccessType -- not optional, so no need to check for DEFAULT_ARG */
+
+    AccessType = (UINT8) Op->Asl.Value.Integer;
+    Op->Asl.ParseOpcode = PARSEOP_DEFAULT_ARG;
+
+    /* Set the access type in the parent (field) node for use later */
+
+    FieldOp->Asl.Value.Integer = AccessType;
+
+    /* LockRule -- not optional, so no need to check for DEFAULT_ARG */
+
+    Next = Op->Asl.Next;
+    LockRule = (UINT8) Next->Asl.Value.Integer;
+    Next->Asl.ParseOpcode = PARSEOP_DEFAULT_ARG;
+
+    /* UpdateRule -- not optional, so no need to check for DEFAULT_ARG */
+
+    Next = Next->Asl.Next;
+    UpdateRule = (UINT8) Next->Asl.Value.Integer;
+
+    /*
+     * Generate the flags byte. The various fields are already
+     * in the right bit position via translation from the
+     * keywords by the parser.
+     */
+    FieldFlags = (UINT8) (AccessType | LockRule | UpdateRule);
+
+    /* Use the previous node to be the FieldFlags node */
+
+    /* Set the node to RAW_DATA */
+
+    Next->Asl.Value.Integer = FieldFlags;
+    Next->Asl.AmlOpcode = AML_RAW_DATA_BYTE;
+    Next->Asl.AmlLength = 1;
+    Next->Asl.ParseOpcode = PARSEOP_RAW_DATA;
+
+    /* Process the FieldUnitList */
+
+    Next = Next->Asl.Next;
+    CurrentBitOffset = 0;
+
+    while (Next)
+    {
+        /* Save the offset of this field unit */
+
+        Next->Asl.ExtraValue = CurrentBitOffset;
+
+        switch (Next->Asl.ParseOpcode)
+        {
+        case PARSEOP_ACCESSAS:
+
+            PkgLengthNode = Next->Asl.Child;
+            AccessType = (UINT8) PkgLengthNode->Asl.Value.Integer;
+
+            /* Nothing additional to do */
+            break;
+
+        case PARSEOP_OFFSET:
+
+            /* New offset into the field */
+
+            PkgLengthNode = Next->Asl.Child;
+            NewBitOffset = ((UINT32) PkgLengthNode->Asl.Value.Integer) * 8;
+
+            /*
+             * Examine the specified offset in relation to the
+             * current offset counter.
+             */
+            if (NewBitOffset < CurrentBitOffset)
+            {
+                /*
+                 * Not allowed to specify a backwards offset!
+                 * Issue error and ignore this node.
+                 */
+                AslError (ASL_ERROR, ASL_MSG_BACKWARDS_OFFSET, PkgLengthNode,
+                    NULL);
+                Next->Asl.ParseOpcode = PARSEOP_DEFAULT_ARG;
+                PkgLengthNode->Asl.ParseOpcode = PARSEOP_DEFAULT_ARG;
+            }
+            else if (NewBitOffset == CurrentBitOffset)
+            {
+                /*
+                 * Offset is redundant; we don't need to output an
+                 * offset opcode. Just set these nodes to default
+                 */
+                Next->Asl.ParseOpcode = PARSEOP_DEFAULT_ARG;
+                PkgLengthNode->Asl.ParseOpcode = PARSEOP_DEFAULT_ARG;
+            }
+            else
+            {
+                /*
+                 * Valid new offset - set the value to be inserted into the AML
+                 * and update the offset counter.
+                 */
+                PkgLengthNode->Asl.Value.Integer =
+                    NewBitOffset - CurrentBitOffset;
+                CurrentBitOffset = NewBitOffset;
+            }
+            break;
+
+        case PARSEOP_NAMESEG:
+        case PARSEOP_RESERVED_BYTES:
+
+            /* Named or reserved field entry */
+
+            PkgLengthNode = Next->Asl.Child;
+            NewBitOffset = (UINT32) PkgLengthNode->Asl.Value.Integer;
+            CurrentBitOffset += NewBitOffset;
+
+            /* Save the current AccessAs value for error checking later */
+
+            switch (AccessType)
+            {
+                case AML_FIELD_ACCESS_ANY:
+                case AML_FIELD_ACCESS_BYTE:
+                case AML_FIELD_ACCESS_BUFFER:
+                default:
+
+                    MinimumLength = 8;
+                    break;
+
+                case AML_FIELD_ACCESS_WORD:
+                    MinimumLength = 16;
+                    break;
+
+                case AML_FIELD_ACCESS_DWORD:
+                    MinimumLength = 32;
+                    break;
+
+                case AML_FIELD_ACCESS_QWORD:
+                    MinimumLength = 64;
+                    break;
+            }
+
+            PkgLengthNode->Asl.ExtraValue = MinimumLength;
+            break;
+
+        default:
+
+            /* All supported field opcodes must appear above */
+
+            break;
+        }
+
+        /* Move on to next entry in the field list */
+
+        Next = Next->Asl.Next;
+    }
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    OpnDoField
+ *
+ * PARAMETERS:  Op        - The parent parse node
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Construct the AML operands for the FIELD ASL keyword
+ *
+ ******************************************************************************/
+
+static void
+OpnDoField (
+    ACPI_PARSE_OBJECT       *Op)
+{
+    ACPI_PARSE_OBJECT       *Next;
+
+
+    /* Opcode is parent node */
+    /* First child is field name */
+
+    Next = Op->Asl.Child;
+
+    /* Second child is the AccessType */
+
+    OpnDoFieldCommon (Op, Next->Asl.Next);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    OpnDoIndexField
+ *
+ * PARAMETERS:  Op        - The parent parse node
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Construct the AML operands for the INDEXFIELD ASL keyword
+ *
+ ******************************************************************************/
+
+static void
+OpnDoIndexField (
+    ACPI_PARSE_OBJECT       *Op)
+{
+    ACPI_PARSE_OBJECT       *Next;
+
+
+    /* Opcode is parent node */
+    /* First child is the index name */
+
+    Next = Op->Asl.Child;
+
+    /* Second child is the data name */
+
+    Next = Next->Asl.Next;
+
+    /* Third child is the AccessType */
+
+    OpnDoFieldCommon (Op, Next->Asl.Next);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    OpnDoBankField
+ *
+ * PARAMETERS:  Op        - The parent parse node
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Construct the AML operands for the BANKFIELD ASL keyword
+ *
+ ******************************************************************************/
+
+static void
+OpnDoBankField (
+    ACPI_PARSE_OBJECT       *Op)
+{
+    ACPI_PARSE_OBJECT       *Next;
+
+
+    /* Opcode is parent node */
+    /* First child is the region name */
+
+    Next = Op->Asl.Child;
+
+    /* Second child is the bank name */
+
+    Next = Next->Asl.Next;
+
+    /* Third child is the bank value */
+
+    Next = Next->Asl.Next;
+
+    /* Fourth child is the AccessType */
+
+    OpnDoFieldCommon (Op, Next->Asl.Next);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    OpnDoRegion
+ *
+ * PARAMETERS:  Op        - The parent parse node
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Tries to get the length of the region. Can only do this at
+ *              compile time if the length is a constant.
+ *
+ ******************************************************************************/
+
+static void
+OpnDoRegion (
+    ACPI_PARSE_OBJECT       *Op)
+{
+    ACPI_PARSE_OBJECT       *Next;
+
+
+    /* Opcode is parent node */
+    /* First child is the region name */
+
+    Next = Op->Asl.Child;
+
+    /* Second child is the space ID*/
+
+    Next = Next->Asl.Next;
+
+    /* Third child is the region offset */
+
+    Next = Next->Asl.Next;
+
+    /* Fourth child is the region length */
+
+    Next = Next->Asl.Next;
+    if (Next->Asl.ParseOpcode == PARSEOP_INTEGER)
+    {
+        Op->Asl.Value.Integer = Next->Asl.Value.Integer;
+    }
+    else
+    {
+        Op->Asl.Value.Integer = ACPI_UINT64_MAX;
+    }
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    OpnDoBuffer
+ *
+ * PARAMETERS:  Op        - The parent parse node
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Construct the AML operands for the BUFFER ASL keyword. We
+ *              build a single raw byte buffer from the initialization nodes,
+ *              each parse node contains a buffer byte.
+ *
+ ******************************************************************************/
+
+static void
+OpnDoBuffer (
+    ACPI_PARSE_OBJECT       *Op)
+{
+    ACPI_PARSE_OBJECT       *InitializerOp;
+    ACPI_PARSE_OBJECT       *BufferLengthOp;
+
+    /* Optional arguments for this opcode with defaults */
+
+    UINT32                  BufferLength = 0;
+
+
+    /* Opcode and package length first */
+    /* Buffer Length is next, followed by the initializer list */
+
+    BufferLengthOp = Op->Asl.Child;
+    InitializerOp = BufferLengthOp->Asl.Next;
+
+    /*
+     * If the BufferLength is not an INTEGER or was not specified in the ASL
+     * (DEFAULT_ARG), it is a TermArg that is
+     * evaluated at run-time, and we are therefore finished.
+     */
+    if ((BufferLengthOp->Asl.ParseOpcode != PARSEOP_INTEGER) &&
+        (BufferLengthOp->Asl.ParseOpcode != PARSEOP_DEFAULT_ARG))
+    {
+        return;
+    }
+
+    /*
+     * We want to count the number of items in the initializer list, because if
+     * it is larger than the buffer length, we will define the buffer size
+     * to be the size of the initializer list (as per the ACPI Specification)
+     */
+    switch (InitializerOp->Asl.ParseOpcode)
+    {
+    case PARSEOP_INTEGER:
+    case PARSEOP_BYTECONST:
+    case PARSEOP_WORDCONST:
+    case PARSEOP_DWORDCONST:
+
+        /* The peer list contains the byte list (if any...) */
+
+        while (InitializerOp)
+        {
+            /* For buffers, this is a list of raw bytes */
+
+            InitializerOp->Asl.AmlOpcode = AML_RAW_DATA_BYTE;
+            InitializerOp->Asl.AmlLength = 1;
+            InitializerOp->Asl.ParseOpcode = PARSEOP_RAW_DATA;
+
+            BufferLength++;
+            InitializerOp = ASL_GET_PEER_NODE (InitializerOp);
+        }
+        break;
+
+    case PARSEOP_STRING_LITERAL:
+
+        /*
+         * Only one initializer, the string. Buffer must be big enough to hold
+         * the string plus the null termination byte
+         */
+        BufferLength = strlen (InitializerOp->Asl.Value.String) + 1;
+
+        InitializerOp->Asl.AmlOpcode = AML_RAW_DATA_BUFFER;
+        InitializerOp->Asl.AmlLength = BufferLength;
+        InitializerOp->Asl.ParseOpcode = PARSEOP_RAW_DATA;
+        break;
+
+    case PARSEOP_RAW_DATA:
+
+        /* Buffer nodes are already initialized (e.g. Unicode operator) */
+        return;
+
+    case PARSEOP_DEFAULT_ARG:
+        break;
+
+    default:
+
+        AslError (ASL_ERROR, ASL_MSG_INVALID_OPERAND, InitializerOp,
+            "Unknown buffer initializer opcode");
+        printf ("Unknown buffer initializer opcode [%s]\n",
+            UtGetOpName (InitializerOp->Asl.ParseOpcode));
+        return;
+    }
+
+    /* Check if initializer list is longer than the buffer length */
+
+    if (BufferLengthOp->Asl.Value.Integer > BufferLength)
+    {
+        BufferLength = (UINT32) BufferLengthOp->Asl.Value.Integer;
+    }
+
+    if (!BufferLength)
+    {
+        /* No length AND no items -- issue notice */
+
+        AslError (ASL_REMARK, ASL_MSG_BUFFER_LENGTH, BufferLengthOp, NULL);
+
+        /* But go ahead and put the buffer length of zero into the AML */
+    }
+
+    /*
+     * Just set the buffer size node to be the buffer length, regardless
+     * of whether it was previously an integer or a default_arg placeholder
+     */
+    BufferLengthOp->Asl.ParseOpcode = PARSEOP_INTEGER;
+    BufferLengthOp->Asl.AmlOpcode = AML_DWORD_OP;
+    BufferLengthOp->Asl.Value.Integer = BufferLength;
+
+    (void) OpcSetOptimalIntegerSize (BufferLengthOp);
+
+    /* Remaining nodes are handled via the tree walk */
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    OpnDoPackage
+ *
+ * PARAMETERS:  Op        - The parent parse node
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Construct the AML operands for the PACKAGE ASL keyword. NOTE:
+ *              can only be called after constants have been folded, to ensure
+ *              that the PackageLength operand has been fully reduced.
+ *
+ ******************************************************************************/
+
+void
+OpnDoPackage (
+    ACPI_PARSE_OBJECT       *Op)
+{
+    ACPI_PARSE_OBJECT       *InitializerOp;
+    ACPI_PARSE_OBJECT       *PackageLengthOp;
+    UINT32                  PackageLength = 0;
+
+
+    /* Opcode and package length first, followed by the initializer list */
+
+    PackageLengthOp = Op->Asl.Child;
+    InitializerOp = PackageLengthOp->Asl.Next;
+
+    /* Count the number of items in the initializer list */
+
+    if (InitializerOp->Asl.ParseOpcode != PARSEOP_DEFAULT_ARG)
+    {
+        /* The peer list contains the byte list (if any...) */
+
+        while (InitializerOp)
+        {
+            PackageLength++;
+            InitializerOp = InitializerOp->Asl.Next;
+        }
+    }
+
+    /* If package length is a constant, compare to the initializer list */
+
+    if ((PackageLengthOp->Asl.ParseOpcode == PARSEOP_INTEGER)      ||
+        (PackageLengthOp->Asl.ParseOpcode == PARSEOP_QWORDCONST))
+    {
+        if (PackageLengthOp->Asl.Value.Integer > PackageLength)
+        {
+            /*
+             * Allow package length to be longer than the initializer
+             * list -- but if the length of initializer list is nonzero,
+             * issue a message since this is probably a coding error,
+             * even though technically legal.
+             */
+            if (PackageLength > 0)
+            {
+                AslError (ASL_REMARK, ASL_MSG_LIST_LENGTH_SHORT,
+                    PackageLengthOp, NULL);
+            }
+
+            PackageLength = (UINT32) PackageLengthOp->Asl.Value.Integer;
+        }
+        else if (PackageLengthOp->Asl.Value.Integer < PackageLength)
+        {
+            /*
+             * The package length is smaller than the length of the
+             * initializer list. This is an error as per the ACPI spec.
+             */
+            AslError (ASL_ERROR, ASL_MSG_LIST_LENGTH_LONG,
+                PackageLengthOp, NULL);
+        }
+    }
+
+    if (PackageLengthOp->Asl.ParseOpcode == PARSEOP_DEFAULT_ARG)
+    {
+        /*
+         * This is the case if the PackageLength was left empty - Package()
+         * The package length becomes the length of the initializer list
+         */
+        Op->Asl.Child->Asl.ParseOpcode = PARSEOP_INTEGER;
+        Op->Asl.Child->Asl.Value.Integer = PackageLength;
+
+        /* Set the AML opcode */
+
+        (void) OpcSetOptimalIntegerSize (Op->Asl.Child);
+    }
+
+    /* If not a variable-length package, check for a zero package length */
+
+    if ((PackageLengthOp->Asl.ParseOpcode == PARSEOP_INTEGER)      ||
+        (PackageLengthOp->Asl.ParseOpcode == PARSEOP_QWORDCONST)   ||
+        (PackageLengthOp->Asl.ParseOpcode == PARSEOP_ZERO)         ||
+        (PackageLengthOp->Asl.ParseOpcode == PARSEOP_DEFAULT_ARG))
+    {
+        if (!PackageLength)
+        {
+            /* No length AND no initializer list -- issue a remark */
+
+            AslError (ASL_REMARK, ASL_MSG_PACKAGE_LENGTH,
+                PackageLengthOp, NULL);
+
+            /* But go ahead and put the buffer length of zero into the AML */
+        }
+    }
+
+    /*
+     * If the PackageLength is a constant <= 255, we can change the
+     * AML opcode from VarPackage to a simple (ACPI 1.0) Package opcode.
+     */
+    if (((Op->Asl.Child->Asl.ParseOpcode == PARSEOP_INTEGER) &&
+            (Op->Asl.Child->Asl.Value.Integer <= 255))  ||
+        (Op->Asl.Child->Asl.ParseOpcode == PARSEOP_ONE) ||
+        (Op->Asl.Child->Asl.ParseOpcode == PARSEOP_ONES)||
+        (Op->Asl.Child->Asl.ParseOpcode == PARSEOP_ZERO))
+    {
+        Op->Asl.AmlOpcode = AML_PACKAGE_OP;
+        Op->Asl.ParseOpcode = PARSEOP_PACKAGE;
+
+        /*
+         * Just set the package size node to be the package length, regardless
+         * of whether it was previously an integer or a default_arg placeholder
+         */
+        PackageLengthOp->Asl.AmlOpcode = AML_RAW_DATA_BYTE;
+        PackageLengthOp->Asl.AmlLength = 1;
+        PackageLengthOp->Asl.ParseOpcode = PARSEOP_RAW_DATA;
+        PackageLengthOp->Asl.Value.Integer = PackageLength;
+    }
+
+    /* Remaining nodes are handled via the tree walk */
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    OpnDoLoadTable
+ *
+ * PARAMETERS:  Op        - The parent parse node
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Construct the AML operands for the LOADTABLE ASL keyword.
+ *
+ ******************************************************************************/
+
+static void
+OpnDoLoadTable (
+    ACPI_PARSE_OBJECT       *Op)
+{
+    ACPI_PARSE_OBJECT       *Next;
+
+
+    /* Opcode is parent node */
+    /* First child is the table signature */
+
+    Next = Op->Asl.Child;
+
+    /* Second child is the OEM ID*/
+
+    Next = Next->Asl.Next;
+
+    /* Third child is the OEM table ID */
+
+    Next = Next->Asl.Next;
+
+    /* Fourth child is the RootPath string */
+
+    Next = Next->Asl.Next;
+    if (Next->Asl.ParseOpcode == PARSEOP_ZERO)
+    {
+        Next->Asl.ParseOpcode = PARSEOP_STRING_LITERAL;
+        Next->Asl.Value.String = "\\";
+        Next->Asl.AmlLength = 2;
+        OpcGenerateAmlOpcode (Next);
+    }
+
+#ifdef ASL_FUTURE_IMPLEMENTATION
+
+    /* TBD: NOT IMPLEMENTED */
+    /* Fifth child is the [optional] ParameterPathString */
+    /* Sixth child is the [optional] ParameterData */
+
+    Next = Next->Asl.Next;
+    if (Next->Asl.ParseOpcode == DEFAULT_ARG)
+    {
+        Next->Asl.AmlLength = 1;
+        Next->Asl.ParseOpcode = ZERO;
+        OpcGenerateAmlOpcode (Next);
+    }
+
+
+    Next = Next->Asl.Next;
+    if (Next->Asl.ParseOpcode == DEFAULT_ARG)
+    {
+        Next->Asl.AmlLength = 1;
+        Next->Asl.ParseOpcode = ZERO;
+        OpcGenerateAmlOpcode (Next);
+    }
+#endif
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    OpnDoDefinitionBlock
+ *
+ * PARAMETERS:  Op        - The parent parse node
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Construct the AML operands for the DEFINITIONBLOCK ASL keyword
+ *
+ ******************************************************************************/
+
+static void
+OpnDoDefinitionBlock (
+    ACPI_PARSE_OBJECT       *Op)
+{
+    ACPI_PARSE_OBJECT       *Child;
+    ACPI_SIZE               Length;
+    UINT32                  i;
+    char                    *Filename;
+
+
+    /*
+     * These nodes get stuffed into the table header. They are special
+     * cased when the table is written to the output file.
+     *
+     * Mark all of these nodes as non-usable so they won't get output
+     * as AML opcodes!
+     */
+
+    /* Get AML filename. Use it if non-null */
+
+    Child = Op->Asl.Child;
+    if (Child->Asl.Value.Buffer  &&
+        *Child->Asl.Value.Buffer &&
+        (Gbl_UseDefaultAmlFilename))
+    {
+        /*
+         * We will use the AML filename that is embedded in the source file
+         * for the output filename.
+         */
+        Filename = UtStringCacheCalloc (strlen (Gbl_DirectoryPath) +
+            strlen ((char *) Child->Asl.Value.Buffer) + 1);
+
+        /* Prepend the current directory path */
+
+        strcpy (Filename, Gbl_DirectoryPath);
+        strcat (Filename, (char *) Child->Asl.Value.Buffer);
+
+        Gbl_OutputFilenamePrefix = Filename;
+        UtConvertBackslashes (Gbl_OutputFilenamePrefix);
+    }
+
+    Child->Asl.ParseOpcode = PARSEOP_DEFAULT_ARG;
+
+    /* Signature */
+
+    Child = Child->Asl.Next;
+    Child->Asl.ParseOpcode = PARSEOP_DEFAULT_ARG;
+    if (Child->Asl.Value.String)
+    {
+        Gbl_TableSignature = Child->Asl.Value.String;
+        if (strlen (Gbl_TableSignature) != ACPI_NAME_SIZE)
+        {
+            AslError (ASL_ERROR, ASL_MSG_TABLE_SIGNATURE, Child,
+                "Length is not exactly 4");
+        }
+
+        for (i = 0; i < ACPI_NAME_SIZE; i++)
+        {
+            if (!isalnum ((int) Gbl_TableSignature[i]))
+            {
+                AslError (ASL_ERROR, ASL_MSG_TABLE_SIGNATURE, Child,
+                    "Contains non-alphanumeric characters");
+            }
+        }
+    }
+
+    /* Revision */
+
+    Child = Child->Asl.Next;
+    Child->Asl.ParseOpcode = PARSEOP_DEFAULT_ARG;
+    /*
+     * We used the revision to set the integer width earlier
+     */
+
+    /* OEMID */
+
+    Child = Child->Asl.Next;
+    Child->Asl.ParseOpcode = PARSEOP_DEFAULT_ARG;
+
+    /* OEM TableID */
+
+    Child = Child->Asl.Next;
+    Child->Asl.ParseOpcode = PARSEOP_DEFAULT_ARG;
+    if (Child->Asl.Value.String)
+    {
+        Length = strlen (Child->Asl.Value.String);
+        Gbl_TableId = UtStringCacheCalloc (Length + 1);
+        strcpy (Gbl_TableId, Child->Asl.Value.String);
+
+        /*
+         * Convert anything non-alphanumeric to an underscore. This
+         * allows us to use the TableID to generate unique C symbols.
+         */
+        for (i = 0; i < Length; i++)
+        {
+            if (!isalnum ((int) Gbl_TableId[i]))
+            {
+                Gbl_TableId[i] = '_';
+            }
+        }
+    }
+
+    /* OEM Revision */
+
+    Child = Child->Asl.Next;
+    Child->Asl.ParseOpcode = PARSEOP_DEFAULT_ARG;
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    UtGetArg
+ *
+ * PARAMETERS:  Op              - Get an argument for this op
+ *              Argn            - Nth argument to get
+ *
+ * RETURN:      The argument (as an Op object). NULL if argument does not exist
+ *
+ * DESCRIPTION: Get the specified op's argument (peer)
+ *
+ ******************************************************************************/
+
+ACPI_PARSE_OBJECT *
+UtGetArg (
+    ACPI_PARSE_OBJECT       *Op,
+    UINT32                  Argn)
+{
+    ACPI_PARSE_OBJECT       *Arg = NULL;
+
+
+    /* Get the requested argument object */
+
+    Arg = Op->Asl.Child;
+    while (Arg && Argn)
+    {
+        Argn--;
+        Arg = Arg->Asl.Next;
+    }
+
+    return (Arg);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    OpnAttachNameToNode
+ *
+ * PARAMETERS:  Op        - The parent parse node
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: For the named ASL/AML operators, get the actual name from the
+ *              argument list and attach it to the parent node so that we
+ *              can get to it quickly later.
+ *
+ ******************************************************************************/
+
+static void
+OpnAttachNameToNode (
+    ACPI_PARSE_OBJECT       *Op)
+{
+    ACPI_PARSE_OBJECT       *Child = NULL;
+
+
+    switch (Op->Asl.AmlOpcode)
+    {
+    case AML_DATA_REGION_OP:
+    case AML_DEVICE_OP:
+    case AML_EVENT_OP:
+    case AML_EXTERNAL_OP:
+    case AML_METHOD_OP:
+    case AML_MUTEX_OP:
+    case AML_REGION_OP:
+    case AML_POWER_RES_OP:
+    case AML_PROCESSOR_OP:
+    case AML_THERMAL_ZONE_OP:
+    case AML_NAME_OP:
+    case AML_SCOPE_OP:
+
+        Child = UtGetArg (Op, 0);
+        break;
+
+    case AML_ALIAS_OP:
+
+        Child = UtGetArg (Op, 1);
+        break;
+
+    case AML_CREATE_BIT_FIELD_OP:
+    case AML_CREATE_BYTE_FIELD_OP:
+    case AML_CREATE_WORD_FIELD_OP:
+    case AML_CREATE_DWORD_FIELD_OP:
+    case AML_CREATE_QWORD_FIELD_OP:
+
+        Child = UtGetArg (Op, 2);
+        break;
+
+    case AML_CREATE_FIELD_OP:
+
+        Child = UtGetArg (Op, 3);
+        break;
+
+    case AML_BANK_FIELD_OP:
+    case AML_INDEX_FIELD_OP:
+    case AML_FIELD_OP:
+
+        return;
+
+    default:
+
+        return;
+    }
+
+    if (Child)
+    {
+        UtAttachNamepathToOwner (Op, Child);
+    }
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    OpnGenerateAmlOperands
+ *
+ * PARAMETERS:  Op        - The parent parse node
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Prepare nodes to be output as AML data and operands. The more
+ *              complex AML opcodes require processing of the child nodes
+ *              (arguments/operands).
+ *
+ ******************************************************************************/
+
+void
+OpnGenerateAmlOperands (
+    ACPI_PARSE_OBJECT       *Op)
+{
+
+
+    if (Op->Asl.AmlOpcode == AML_RAW_DATA_BYTE)
+    {
+        return;
+    }
+
+    switch (Op->Asl.ParseOpcode)
+    {
+    case PARSEOP_DEFINITION_BLOCK:
+
+        OpnDoDefinitionBlock (Op);
+        break;
+
+    case PARSEOP_METHOD:
+
+        OpnDoMethod (Op);
+        break;
+
+    case PARSEOP_MUTEX:
+
+        OpnDoMutex (Op);
+        break;
+
+    case PARSEOP_FIELD:
+
+        OpnDoField (Op);
+        break;
+
+    case PARSEOP_INDEXFIELD:
+
+        OpnDoIndexField (Op);
+        break;
+
+    case PARSEOP_BANKFIELD:
+
+        OpnDoBankField (Op);
+        break;
+
+    case PARSEOP_BUFFER:
+
+        OpnDoBuffer (Op);
+        break;
+
+    case PARSEOP_LOADTABLE:
+
+        OpnDoLoadTable (Op);
+        break;
+
+    case PARSEOP_OPERATIONREGION:
+
+        OpnDoRegion (Op);
+        break;
+
+    case PARSEOP_RESOURCETEMPLATE:
+
+        RsDoResourceTemplate (Op);
+        break;
+
+    case PARSEOP_NAMESEG:
+    case PARSEOP_NAMESTRING:
+    case PARSEOP_METHODCALL:
+    case PARSEOP_STRING_LITERAL:
+    default:
+
+        break;
+    }
+
+    /* TBD: move */
+
+    OpnAttachNameToNode (Op);
+}
diff --git a/usr/src/cmd/acpi/iasl/aslopt.c b/usr/src/cmd/acpi/iasl/aslopt.c
new file mode 100644
index 0000000000..a07f10c181
--- /dev/null
+++ b/usr/src/cmd/acpi/iasl/aslopt.c
@@ -0,0 +1,817 @@
+/******************************************************************************
+ *
+ * Module Name: aslopt- Compiler optimizations
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2016, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include "aslcompiler.h"
+#include "aslcompiler.y.h"
+
+#include "acparser.h"
+#include "amlcode.h"
+#include "acnamesp.h"
+
+
+#define _COMPONENT          ACPI_COMPILER
+        ACPI_MODULE_NAME    ("aslopt")
+
+
+static UINT32               OptTotal = 0;
+
+/* Local prototypes */
+
+static ACPI_STATUS
+OptSearchToRoot (
+    ACPI_PARSE_OBJECT       *Op,
+    ACPI_WALK_STATE         *WalkState,
+    ACPI_NAMESPACE_NODE     *CurrentNode,
+    ACPI_NAMESPACE_NODE     *TargetNode,
+    ACPI_BUFFER             *TargetPath,
+    char                    **NewPath);
+
+static ACPI_STATUS
+OptBuildShortestPath (
+    ACPI_PARSE_OBJECT       *Op,
+    ACPI_WALK_STATE         *WalkState,
+    ACPI_NAMESPACE_NODE     *CurrentNode,
+    ACPI_NAMESPACE_NODE     *TargetNode,
+    ACPI_BUFFER             *CurrentPath,
+    ACPI_BUFFER             *TargetPath,
+    ACPI_SIZE               AmlNameStringLength,
+    UINT8                   IsDeclaration,
+    char                    **ReturnNewPath);
+
+static ACPI_STATUS
+OptOptimizeNameDeclaration (
+    ACPI_PARSE_OBJECT       *Op,
+    ACPI_WALK_STATE         *WalkState,
+    ACPI_NAMESPACE_NODE     *CurrentNode,
+    ACPI_NAMESPACE_NODE     *TargetNode,
+    char                    *AmlNameString,
+    char                    **NewPath);
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    OptSearchToRoot
+ *
+ * PARAMETERS:  Op                  - Current parser op
+ *              WalkState           - Current state
+ *              CurrentNode         - Where we are in the namespace
+ *              TargetNode          - Node to which we are referring
+ *              TargetPath          - External full path to the target node
+ *              NewPath             - Where the optimized path is returned
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Attempt to optimize a reference to a single 4-character ACPI
+ *              name utilizing the search-to-root name resolution algorithm
+ *              that is used by AML interpreters.
+ *
+ ******************************************************************************/
+
+static ACPI_STATUS
+OptSearchToRoot (
+    ACPI_PARSE_OBJECT       *Op,
+    ACPI_WALK_STATE         *WalkState,
+    ACPI_NAMESPACE_NODE     *CurrentNode,
+    ACPI_NAMESPACE_NODE     *TargetNode,
+    ACPI_BUFFER             *TargetPath,
+    char                    **NewPath)
+{
+    ACPI_NAMESPACE_NODE     *Node;
+    ACPI_GENERIC_STATE      ScopeInfo;
+    ACPI_STATUS             Status;
+    char                    *Path;
+
+
+    ACPI_FUNCTION_NAME (OptSearchToRoot);
+
+
+    /*
+     * Check if search-to-root can be utilized. Use the last NameSeg of
+     * the NamePath and 1) See if can be found and 2) If found, make
+     * sure that it is the same node that we want. If there is another
+     * name in the search path before the one we want, the nodes will
+     * not match, and we cannot use this optimization.
+     */
+    Path = &(((char *) TargetPath->Pointer)[
+        TargetPath->Length - ACPI_NAME_SIZE]),
+    ScopeInfo.Scope.Node = CurrentNode;
+
+    /* Lookup the NameSeg using SEARCH_PARENT (search-to-root) */
+
+    Status = AcpiNsLookup (&ScopeInfo, Path, ACPI_TYPE_ANY, ACPI_IMODE_EXECUTE,
+        ACPI_NS_SEARCH_PARENT | ACPI_NS_DONT_OPEN_SCOPE,
+        WalkState, &(Node));
+    if (ACPI_FAILURE (Status))
+    {
+        return (Status);
+    }
+
+    /*
+     * We found the name, but we must check to make sure that the node
+     * matches. Otherwise, there is another identical name in the search
+     * path that precludes the use of this optimization.
+     */
+    if (Node != TargetNode)
+    {
+        /*
+         * This means that another object with the same name was found first,
+         * and we cannot use this optimization.
+         */
+        return (AE_NOT_FOUND);
+    }
+
+    /* Found the node, we can use this optimization */
+
+    ACPI_DEBUG_PRINT_RAW ((ACPI_DB_OPTIMIZATIONS,
+        "NAMESEG:   %-24s", Path));
+
+    /* We must allocate a new string for the name (TargetPath gets deleted) */
+
+    *NewPath = UtStringCacheCalloc (ACPI_NAME_SIZE + 1);
+    strcpy (*NewPath, Path);
+
+    if (strncmp (*NewPath, "_T_", 3))
+    {
+        AslError (ASL_OPTIMIZATION, ASL_MSG_SINGLE_NAME_OPTIMIZATION,
+            Op, *NewPath);
+    }
+
+    return (AE_OK);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    OptBuildShortestPath
+ *
+ * PARAMETERS:  Op                  - Current parser op
+ *              WalkState           - Current state
+ *              CurrentNode         - Where we are in the namespace
+ *              TargetNode          - Node to which we are referring
+ *              CurrentPath         - External full path to the current node
+ *              TargetPath          - External full path to the target node
+ *              AmlNameStringLength - Length of the original namepath
+ *              IsDeclaration       - TRUE for declaration, FALSE for reference
+ *              ReturnNewPath       - Where the optimized path is returned
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Build an optimal NamePath using carats
+ *
+ ******************************************************************************/
+
+static ACPI_STATUS
+OptBuildShortestPath (
+    ACPI_PARSE_OBJECT       *Op,
+    ACPI_WALK_STATE         *WalkState,
+    ACPI_NAMESPACE_NODE     *CurrentNode,
+    ACPI_NAMESPACE_NODE     *TargetNode,
+    ACPI_BUFFER             *CurrentPath,
+    ACPI_BUFFER             *TargetPath,
+    ACPI_SIZE               AmlNameStringLength,
+    UINT8                   IsDeclaration,
+    char                    **ReturnNewPath)
+{
+    UINT32                  NumCommonSegments;
+    UINT32                  MaxCommonSegments;
+    UINT32                  Index;
+    UINT32                  NumCarats;
+    UINT32                  i;
+    char                    *NewPathInternal;
+    char                    *NewPathExternal;
+    ACPI_NAMESPACE_NODE     *Node;
+    ACPI_GENERIC_STATE      ScopeInfo;
+    ACPI_STATUS             Status;
+    BOOLEAN                 SubPath = FALSE;
+
+
+    ACPI_FUNCTION_NAME (OptBuildShortestPath);
+
+
+    ScopeInfo.Scope.Node = CurrentNode;
+
+    /*
+     * Determine the maximum number of NameSegs that the Target and Current paths
+     * can possibly have in common. (To optimize, we have to have at least 1)
+     *
+     * Note: The external NamePath string lengths are always a multiple of 5
+     * (ACPI_NAME_SIZE + separator)
+     */
+    MaxCommonSegments = TargetPath->Length / ACPI_PATH_SEGMENT_LENGTH;
+    if (CurrentPath->Length < TargetPath->Length)
+    {
+        MaxCommonSegments = CurrentPath->Length / ACPI_PATH_SEGMENT_LENGTH;
+    }
+
+    /*
+     * Determine how many NameSegs the two paths have in common.
+     * (Starting from the root)
+     */
+    for (NumCommonSegments = 0;
+         NumCommonSegments < MaxCommonSegments;
+         NumCommonSegments++)
+    {
+        /* Compare two single NameSegs */
+
+        Index = (NumCommonSegments * ACPI_PATH_SEGMENT_LENGTH) + 1;
+
+        if (!ACPI_COMPARE_NAME (
+            &(ACPI_CAST_PTR (char, TargetPath->Pointer)) [Index],
+            &(ACPI_CAST_PTR (char, CurrentPath->Pointer)) [Index]))
+        {
+            /* Mismatch */
+
+            break;
+        }
+    }
+
+    ACPI_DEBUG_PRINT_RAW ((ACPI_DB_OPTIMIZATIONS, " COMMON: %u",
+        NumCommonSegments));
+
+    /* There must be at least 1 common NameSeg in order to optimize */
+
+    if (NumCommonSegments == 0)
+    {
+        return (AE_NOT_FOUND);
+    }
+
+    if (NumCommonSegments == MaxCommonSegments)
+    {
+        if (CurrentPath->Length == TargetPath->Length)
+        {
+            ACPI_DEBUG_PRINT_RAW ((ACPI_DB_OPTIMIZATIONS, " SAME PATH"));
+            return (AE_NOT_FOUND);
+        }
+        else
+        {
+            ACPI_DEBUG_PRINT_RAW ((ACPI_DB_OPTIMIZATIONS, " SUBPATH"));
+            SubPath = TRUE;
+        }
+    }
+
+    /* Determine how many prefix Carats are required */
+
+    NumCarats = (CurrentPath->Length / ACPI_PATH_SEGMENT_LENGTH) -
+        NumCommonSegments;
+
+    /*
+     * Construct a new target string
+     */
+    NewPathExternal =
+        ACPI_ALLOCATE_ZEROED (TargetPath->Length + NumCarats + 1);
+
+    /* Insert the Carats into the Target string */
+
+    for (i = 0; i < NumCarats; i++)
+    {
+        NewPathExternal[i] = AML_PARENT_PREFIX;
+    }
+
+    /*
+     * Copy only the necessary (optimal) segments from the original
+     * target string
+     */
+    Index = (NumCommonSegments * ACPI_PATH_SEGMENT_LENGTH) + 1;
+
+    /* Special handling for exact subpath in a name declaration */
+
+    if (IsDeclaration && SubPath &&
+        (CurrentPath->Length > TargetPath->Length))
+    {
+        /*
+         * The current path is longer than the target, and the target is a
+         * subpath of the current path. We must include one more NameSeg of
+         * the target path
+         */
+        Index -= ACPI_PATH_SEGMENT_LENGTH;
+
+        /* Special handling for Scope() operator */
+
+        if (Op->Asl.AmlOpcode == AML_SCOPE_OP)
+        {
+            NewPathExternal[i] = AML_PARENT_PREFIX;
+            i++;
+            ACPI_DEBUG_PRINT_RAW ((ACPI_DB_OPTIMIZATIONS, "(EXTRA ^)"));
+        }
+    }
+
+    /* Make sure we haven't gone off the end of the target path */
+
+    if (Index > TargetPath->Length)
+    {
+        Index = TargetPath->Length;
+    }
+
+    strcpy (&NewPathExternal[i],
+        &(ACPI_CAST_PTR (char, TargetPath->Pointer))[Index]);
+    ACPI_DEBUG_PRINT_RAW ((ACPI_DB_OPTIMIZATIONS, " %-24s", NewPathExternal));
+
+    /*
+     * Internalize the new target string and check it against the original
+     * string to make sure that this is in fact an optimization. If the
+     * original string is already optimal, there is no point in continuing.
+     */
+    Status = AcpiNsInternalizeName (NewPathExternal, &NewPathInternal);
+    if (ACPI_FAILURE (Status))
+    {
+        AslCoreSubsystemError (Op, Status, "Internalizing new NamePath",
+            ASL_NO_ABORT);
+        goto Cleanup;
+    }
+
+    if (strlen (NewPathInternal) >= AmlNameStringLength)
+    {
+        ACPI_DEBUG_PRINT_RAW ((ACPI_DB_OPTIMIZATIONS,
+            " NOT SHORTER (New %u old %u)",
+            (UINT32) strlen (NewPathInternal),
+            (UINT32) AmlNameStringLength));
+
+        ACPI_FREE (NewPathInternal);
+        Status = AE_NOT_FOUND;
+        goto Cleanup;
+    }
+
+    /*
+     * Check to make sure that the optimization finds the node we are
+     * looking for. This is simply a sanity check on the new
+     * path that has been created.
+     */
+    Status = AcpiNsLookup (&ScopeInfo, NewPathInternal,
+        ACPI_TYPE_ANY, ACPI_IMODE_EXECUTE,
+        ACPI_NS_DONT_OPEN_SCOPE, WalkState, &(Node));
+    if (ACPI_SUCCESS (Status))
+    {
+        /* Found the namepath, but make sure the node is correct */
+
+        if (Node == TargetNode)
+        {
+            /* The lookup matched the node, accept this optimization */
+
+            AslError (ASL_OPTIMIZATION, ASL_MSG_NAME_OPTIMIZATION,
+                Op, NewPathExternal);
+            *ReturnNewPath = NewPathInternal;
+        }
+        else
+        {
+            /* Node is not correct, do not use this optimization */
+
+            Status = AE_NOT_FOUND;
+            ACPI_DEBUG_PRINT_RAW ((ACPI_DB_OPTIMIZATIONS, " ***** WRONG NODE"));
+            AslError (ASL_WARNING, ASL_MSG_COMPILER_INTERNAL, Op,
+                "Not using optimized name - found wrong node");
+        }
+    }
+    else
+    {
+        /* The lookup failed, we obviously cannot use this optimization */
+
+        ACPI_FREE (NewPathInternal);
+
+        ACPI_DEBUG_PRINT_RAW ((ACPI_DB_OPTIMIZATIONS, " ***** NOT FOUND"));
+        AslError (ASL_WARNING, ASL_MSG_COMPILER_INTERNAL, Op,
+            "Not using optimized name - did not find node");
+    }
+
+Cleanup:
+
+    ACPI_FREE (NewPathExternal);
+    return (Status);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    OptOptimizeNameDeclaration
+ *
+ * PARAMETERS:  Op                  - Current parser op
+ *              WalkState           - Current state
+ *              CurrentNode         - Where we are in the namespace
+ *              AmlNameString       - Unoptimized namepath
+ *              NewPath             - Where the optimized path is returned
+ *
+ * RETURN:      Status. AE_OK If path is optimized
+ *
+ * DESCRIPTION: Perform a simple optimization of removing an extraneous
+ *              backslash prefix if we are already at the root scope.
+ *
+ ******************************************************************************/
+
+static ACPI_STATUS
+OptOptimizeNameDeclaration (
+    ACPI_PARSE_OBJECT       *Op,
+    ACPI_WALK_STATE         *WalkState,
+    ACPI_NAMESPACE_NODE     *CurrentNode,
+    ACPI_NAMESPACE_NODE     *TargetNode,
+    char                    *AmlNameString,
+    char                    **NewPath)
+{
+    ACPI_STATUS             Status;
+    char                    *NewPathExternal;
+    ACPI_NAMESPACE_NODE     *Node;
+
+
+    ACPI_FUNCTION_TRACE (OptOptimizeNameDeclaration);
+
+
+    if (((CurrentNode == AcpiGbl_RootNode) ||
+        (Op->Common.Parent->Asl.ParseOpcode == PARSEOP_DEFINITION_BLOCK)) &&
+            (ACPI_IS_ROOT_PREFIX (AmlNameString[0])))
+    {
+        /*
+         * The current scope is the root, and the namepath has a root prefix
+         * that is therefore extraneous. Remove it.
+         */
+        *NewPath = &AmlNameString[1];
+
+        /* Debug output */
+
+        Status = AcpiNsExternalizeName (ACPI_UINT32_MAX, *NewPath,
+            NULL, &NewPathExternal);
+        if (ACPI_FAILURE (Status))
+        {
+            AslCoreSubsystemError (Op, Status, "Externalizing NamePath",
+                ASL_NO_ABORT);
+            return (Status);
+        }
+
+        /*
+         * Check to make sure that the optimization finds the node we are
+         * looking for. This is simply a sanity check on the new
+         * path that has been created.
+         *
+         * We know that we are at the root, so NULL is used for the scope.
+         */
+        Status = AcpiNsLookup (NULL, *NewPath,
+            ACPI_TYPE_ANY, ACPI_IMODE_EXECUTE,
+            ACPI_NS_DONT_OPEN_SCOPE, WalkState, &(Node));
+        if (ACPI_SUCCESS (Status))
+        {
+            /* Found the namepath, but make sure the node is correct */
+
+            if (Node == TargetNode)
+            {
+                /* The lookup matched the node, accept this optimization */
+
+                AslError (ASL_OPTIMIZATION, ASL_MSG_NAME_OPTIMIZATION,
+                    Op, NewPathExternal);
+
+                ACPI_DEBUG_PRINT_RAW ((ACPI_DB_OPTIMIZATIONS,
+                    "AT ROOT:   %-24s", NewPathExternal));
+            }
+            else
+            {
+                /* Node is not correct, do not use this optimization */
+
+                Status = AE_NOT_FOUND;
+                ACPI_DEBUG_PRINT_RAW ((ACPI_DB_OPTIMIZATIONS,
+                    " ***** WRONG NODE"));
+                AslError (ASL_WARNING, ASL_MSG_COMPILER_INTERNAL, Op,
+                    "Not using optimized name - found wrong node");
+            }
+        }
+        else
+        {
+            /* The lookup failed, we obviously cannot use this optimization */
+
+            ACPI_DEBUG_PRINT_RAW ((ACPI_DB_OPTIMIZATIONS,
+                " ***** NOT FOUND"));
+            AslError (ASL_WARNING, ASL_MSG_COMPILER_INTERNAL, Op,
+                "Not using optimized name - did not find node");
+        }
+
+        ACPI_FREE (NewPathExternal);
+        return (Status);
+    }
+
+    /* Could not optimize */
+
+    return (AE_NOT_FOUND);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    OptOptimizeNamePath
+ *
+ * PARAMETERS:  Op                  - Current parser op
+ *              Flags               - Opcode info flags
+ *              WalkState           - Current state
+ *              AmlNameString       - Unoptimized namepath
+ *              TargetNode          - Node to which AmlNameString refers
+ *
+ * RETURN:      None. If path is optimized, the Op is updated with new path
+ *
+ * DESCRIPTION: Optimize a Named Declaration or Reference to the minimal length.
+ *              Must take into account both the current location in the
+ *              namespace and the actual reference path.
+ *
+ ******************************************************************************/
+
+void
+OptOptimizeNamePath (
+    ACPI_PARSE_OBJECT       *Op,
+    UINT32                  Flags,
+    ACPI_WALK_STATE         *WalkState,
+    char                    *AmlNameString,
+    ACPI_NAMESPACE_NODE     *TargetNode)
+{
+    ACPI_STATUS             Status;
+    ACPI_BUFFER             TargetPath;
+    ACPI_BUFFER             CurrentPath;
+    ACPI_SIZE               AmlNameStringLength;
+    ACPI_NAMESPACE_NODE     *CurrentNode;
+    char                    *ExternalNameString;
+    char                    *NewPath = NULL;
+    ACPI_SIZE               HowMuchShorter;
+    ACPI_PARSE_OBJECT       *NextOp;
+
+
+    ACPI_FUNCTION_TRACE (OptOptimizeNamePath);
+
+
+    /* This is an optional optimization */
+
+    if (!Gbl_ReferenceOptimizationFlag)
+    {
+        return_VOID;
+    }
+
+    /* Various required items */
+
+    if (!TargetNode || !WalkState || !AmlNameString || !Op->Common.Parent)
+    {
+        return_VOID;
+    }
+
+    ACPI_DEBUG_PRINT_RAW ((ACPI_DB_OPTIMIZATIONS,
+        "PATH OPTIMIZE: Line %5d ParentOp [%12.12s] ThisOp [%12.12s] ",
+        Op->Asl.LogicalLineNumber,
+        AcpiPsGetOpcodeName (Op->Common.Parent->Common.AmlOpcode),
+        AcpiPsGetOpcodeName (Op->Common.AmlOpcode)));
+
+    if (!(Flags & (AML_NAMED | AML_CREATE)))
+    {
+        if (Op->Asl.CompileFlags & NODE_IS_NAME_DECLARATION)
+        {
+            /* We don't want to fuss with actual name declaration nodes here */
+
+            ACPI_DEBUG_PRINT_RAW ((ACPI_DB_OPTIMIZATIONS,
+                "******* NAME DECLARATION\n"));
+            return_VOID;
+        }
+    }
+
+    /*
+     * The original path must be longer than one NameSeg (4 chars) for there
+     * to be any possibility that it can be optimized to a shorter string
+     */
+    AmlNameStringLength = strlen (AmlNameString);
+    if (AmlNameStringLength <= ACPI_NAME_SIZE)
+    {
+        ACPI_DEBUG_PRINT_RAW ((ACPI_DB_OPTIMIZATIONS,
+            "NAMESEG %4.4s\n", AmlNameString));
+        return_VOID;
+    }
+
+    /*
+     * We need to obtain the node that represents the current scope -- where
+     * we are right now in the namespace. We will compare this path
+     * against the Namepath, looking for commonality.
+     */
+    CurrentNode = AcpiGbl_RootNode;
+    if (WalkState->ScopeInfo)
+    {
+        CurrentNode = WalkState->ScopeInfo->Scope.Node;
+    }
+
+    if (Flags & (AML_NAMED | AML_CREATE))
+    {
+        /* This is the declaration of a new name */
+
+        ACPI_DEBUG_PRINT_RAW ((ACPI_DB_OPTIMIZATIONS, "NAME\n"));
+
+        /*
+         * The node of interest is the parent of this node (the containing
+         * scope). The actual namespace node may be up more than one level
+         * of parse op or it may not exist at all (if we traverse back
+         * up to the root.)
+         */
+        NextOp = Op->Asl.Parent;
+        while (NextOp && (!NextOp->Asl.Node))
+        {
+            NextOp = NextOp->Asl.Parent;
+        }
+
+        if (NextOp && NextOp->Asl.Node)
+        {
+            CurrentNode = NextOp->Asl.Node;
+        }
+        else
+        {
+            CurrentNode = AcpiGbl_RootNode;
+        }
+    }
+    else
+    {
+        /* This is a reference to an existing named object */
+
+        ACPI_DEBUG_PRINT_RAW ((ACPI_DB_OPTIMIZATIONS, "REFERENCE\n"));
+    }
+
+    /*
+     * Obtain the full paths to the two nodes that we are interested in
+     * (Target and current namespace location) in external
+     * format -- something we can easily manipulate
+     */
+    TargetPath.Length = ACPI_ALLOCATE_LOCAL_BUFFER;
+    Status = AcpiNsHandleToPathname (TargetNode, &TargetPath, FALSE);
+    if (ACPI_FAILURE (Status))
+    {
+        AslCoreSubsystemError (Op, Status, "Getting Target NamePath",
+            ASL_NO_ABORT);
+        return_VOID;
+    }
+
+    TargetPath.Length--;    /* Subtract one for null terminator */
+
+    /* CurrentPath is the path to this scope (where we are in the namespace) */
+
+    CurrentPath.Length = ACPI_ALLOCATE_LOCAL_BUFFER;
+    Status = AcpiNsHandleToPathname (CurrentNode, &CurrentPath, FALSE);
+    if (ACPI_FAILURE (Status))
+    {
+        AslCoreSubsystemError (Op, Status, "Getting Current NamePath",
+            ASL_NO_ABORT);
+        return_VOID;
+    }
+
+    CurrentPath.Length--;   /* Subtract one for null terminator */
+
+    /* Debug output only */
+
+    Status = AcpiNsExternalizeName (ACPI_UINT32_MAX, AmlNameString,
+        NULL, &ExternalNameString);
+    if (ACPI_FAILURE (Status))
+    {
+        AslCoreSubsystemError (Op, Status, "Externalizing NamePath",
+            ASL_NO_ABORT);
+        return_VOID;
+    }
+
+    ACPI_DEBUG_PRINT_RAW ((ACPI_DB_OPTIMIZATIONS,
+        "CURRENT SCOPE: (%2u) %-37s FULL PATH TO NAME: (%2u) %-32s ACTUAL AML:%-32s\n",
+        (UINT32) CurrentPath.Length, (char *) CurrentPath.Pointer,
+        (UINT32) TargetPath.Length, (char *) TargetPath.Pointer,
+        ExternalNameString));
+
+    ACPI_FREE (ExternalNameString);
+
+    /*
+     * Attempt an optmization depending on the type of namepath
+     */
+    if (Flags & (AML_NAMED | AML_CREATE))
+    {
+        /*
+         * This is a named opcode and the namepath is a name declaration, not
+         * a reference.
+         */
+        Status = OptOptimizeNameDeclaration (Op, WalkState, CurrentNode,
+            TargetNode, AmlNameString, &NewPath);
+        if (ACPI_FAILURE (Status))
+        {
+            /*
+             * 2) now attempt to
+             *    optimize the namestring with carats (up-arrow)
+             */
+            Status = OptBuildShortestPath (Op, WalkState, CurrentNode,
+                TargetNode, &CurrentPath, &TargetPath,
+                AmlNameStringLength, 1, &NewPath);
+        }
+    }
+    else
+    {
+        /*
+         * This is a reference to an existing named object
+         *
+         * 1) Check if search-to-root can be utilized using the last
+         *    NameSeg of the NamePath
+         */
+        Status = OptSearchToRoot (Op, WalkState, CurrentNode,
+            TargetNode, &TargetPath, &NewPath);
+        if (ACPI_FAILURE (Status))
+        {
+            /*
+             * 2) Search-to-root could not be used, now attempt to
+             *    optimize the namestring with carats (up-arrow)
+             */
+            Status = OptBuildShortestPath (Op, WalkState, CurrentNode,
+                TargetNode, &CurrentPath, &TargetPath,
+                AmlNameStringLength, 0, &NewPath);
+        }
+    }
+
+    /*
+     * Success from above indicates that the NamePath was successfully
+     * optimized. We need to update the parse op with the new name
+     */
+    if (ACPI_SUCCESS (Status))
+    {
+        HowMuchShorter = (AmlNameStringLength - strlen (NewPath));
+        OptTotal += HowMuchShorter;
+
+        ACPI_DEBUG_PRINT_RAW ((ACPI_DB_OPTIMIZATIONS,
+            " REDUCED BY %2u (TOTAL SAVED %2u)",
+            (UINT32) HowMuchShorter, OptTotal));
+
+        if (Flags & AML_NAMED)
+        {
+            if (Op->Asl.AmlOpcode == AML_ALIAS_OP)
+            {
+                /*
+                 * ALIAS is the only oddball opcode, the name declaration
+                 * (alias name) is the second operand
+                 */
+                Op->Asl.Child->Asl.Next->Asl.Value.String = NewPath;
+                Op->Asl.Child->Asl.Next->Asl.AmlLength = strlen (NewPath);
+            }
+            else
+            {
+                Op->Asl.Child->Asl.Value.String = NewPath;
+                Op->Asl.Child->Asl.AmlLength = strlen (NewPath);
+            }
+        }
+        else if (Flags & AML_CREATE)
+        {
+            /* Name must appear as the last parameter */
+
+            NextOp = Op->Asl.Child;
+            while (!(NextOp->Asl.CompileFlags & NODE_IS_NAME_DECLARATION))
+            {
+                NextOp = NextOp->Asl.Next;
+            }
+            /* Update the parse node with the new NamePath */
+
+            NextOp->Asl.Value.String = NewPath;
+            NextOp->Asl.AmlLength = strlen (NewPath);
+        }
+        else
+        {
+            /* Update the parse node with the new NamePath */
+
+            Op->Asl.Value.String = NewPath;
+            Op->Asl.AmlLength = strlen (NewPath);
+        }
+    }
+    else
+    {
+        ACPI_DEBUG_PRINT_RAW ((ACPI_DB_OPTIMIZATIONS, " ALREADY OPTIMAL"));
+    }
+
+    /* Cleanup path buffers */
+
+    ACPI_FREE (TargetPath.Pointer);
+    ACPI_FREE (CurrentPath.Pointer);
+
+    ACPI_DEBUG_PRINT_RAW ((ACPI_DB_OPTIMIZATIONS, "\n"));
+    return_VOID;
+}
diff --git a/usr/src/cmd/acpi/iasl/asloptions.c b/usr/src/cmd/acpi/iasl/asloptions.c
new file mode 100644
index 0000000000..d19c3f3f64
--- /dev/null
+++ b/usr/src/cmd/acpi/iasl/asloptions.c
@@ -0,0 +1,916 @@
+/******************************************************************************
+ *
+ * Module Name: asloptions - compiler command line processing
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2016, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include "aslcompiler.h"
+#include "acapps.h"
+#include "acdisasm.h"
+
+#define _COMPONENT          ACPI_COMPILER
+        ACPI_MODULE_NAME    ("asloption")
+
+
+/* Local prototypes */
+
+static int
+AslDoOptions (
+    int                     argc,
+    char                    **argv,
+    BOOLEAN                 IsResponseFile);
+
+static void
+AslMergeOptionTokens (
+    char                    *InBuffer,
+    char                    *OutBuffer);
+
+static int
+AslDoResponseFile (
+    char                    *Filename);
+
+
+#define ASL_TOKEN_SEPARATORS    " \t\n"
+#define ASL_SUPPORTED_OPTIONS   "@:a:b|c|d^D:e:f^gh^i|I:l^m:no|p:P^r:s|t|T+G^v^w|x:z"
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AslCommandLine
+ *
+ * PARAMETERS:  argc/argv
+ *
+ * RETURN:      Last argv index
+ *
+ * DESCRIPTION: Command line processing
+ *
+ ******************************************************************************/
+
+int
+AslCommandLine (
+    int                     argc,
+    char                    **argv)
+{
+    int                     BadCommandLine = 0;
+    ACPI_STATUS             Status;
+
+
+    /* Minimum command line contains at least the command and an input file */
+
+    if (argc < 2)
+    {
+        printf (ACPI_COMMON_SIGNON (ASL_COMPILER_NAME));
+        Usage ();
+        exit (1);
+    }
+
+    /* Process all command line options */
+
+    BadCommandLine = AslDoOptions (argc, argv, FALSE);
+
+    if (Gbl_DoTemplates)
+    {
+        Status = DtCreateTemplates (argv);
+        if (ACPI_FAILURE (Status))
+        {
+            exit (-1);
+        }
+        exit (1);
+    }
+
+    /* Next parameter must be the input filename */
+
+    if (!argv[AcpiGbl_Optind] &&
+        !Gbl_DisasmFlag)
+    {
+        printf ("Missing input filename\n");
+        BadCommandLine = TRUE;
+    }
+
+    if (Gbl_DoSignon)
+    {
+        printf (ACPI_COMMON_SIGNON (ASL_COMPILER_NAME));
+        if (Gbl_IgnoreErrors)
+        {
+            printf ("Ignoring all errors, forcing AML file generation\n\n");
+        }
+    }
+
+    if (BadCommandLine)
+    {
+        printf ("Use -h option for help information\n");
+        exit (1);
+    }
+
+    return (AcpiGbl_Optind);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AslDoOptions
+ *
+ * PARAMETERS:  argc/argv           - Standard argc/argv
+ *              IsResponseFile      - TRUE if executing a response file.
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Command line option processing
+ *
+ ******************************************************************************/
+
+static int
+AslDoOptions (
+    int                     argc,
+    char                    **argv,
+    BOOLEAN                 IsResponseFile)
+{
+    ACPI_STATUS             Status;
+    UINT32                  j;
+
+
+    /* Get the command line options */
+
+    while ((j = AcpiGetopt (argc, argv, ASL_SUPPORTED_OPTIONS)) != ACPI_OPT_END) switch (j)
+    {
+    case '@':   /* Begin a response file */
+
+        if (IsResponseFile)
+        {
+            printf ("Nested command files are not supported\n");
+            return (-1);
+        }
+
+        if (AslDoResponseFile (AcpiGbl_Optarg))
+        {
+            return (-1);
+        }
+        break;
+
+    case 'a':   /* Debug options */
+
+        switch (AcpiGbl_Optarg[0])
+        {
+        case 'r':
+
+            Gbl_EnableReferenceTypechecking = TRUE;
+            break;
+
+        default:
+
+            printf ("Unknown option: -a%s\n", AcpiGbl_Optarg);
+            return (-1);
+        }
+
+        break;
+
+
+    case 'b':   /* Debug options */
+
+        switch (AcpiGbl_Optarg[0])
+        {
+        case 'f':
+
+            AslCompilerdebug = 1; /* same as yydebug */
+            DtParserdebug = 1;
+            PrParserdebug = 1;
+            Gbl_DebugFlag = TRUE;
+            Gbl_KeepPreprocessorTempFile = TRUE;
+            break;
+
+        case 'p':   /* Prune ASL parse tree */
+
+            /* Get the required argument */
+
+            if (AcpiGetoptArgument (argc, argv))
+            {
+                return (-1);
+            }
+
+            Gbl_PruneParseTree = TRUE;
+            Gbl_PruneDepth = (UINT8) strtoul (AcpiGbl_Optarg, NULL, 0);
+            break;
+
+        case 's':
+
+            Gbl_DebugFlag = TRUE;
+            break;
+
+        case 't':
+
+            /* Get the required argument */
+
+            if (AcpiGetoptArgument (argc, argv))
+            {
+                return (-1);
+            }
+
+            Gbl_PruneType = (UINT8) strtoul (AcpiGbl_Optarg, NULL, 0);
+            break;
+
+        default:
+
+            printf ("Unknown option: -b%s\n", AcpiGbl_Optarg);
+            return (-1);
+        }
+
+        break;
+
+    case 'c':
+
+        switch (AcpiGbl_Optarg[0])
+        {
+        case 'r':
+
+            Gbl_NoResourceChecking = TRUE;
+            break;
+
+        default:
+
+            printf ("Unknown option: -c%s\n", AcpiGbl_Optarg);
+            return (-1);
+        }
+        break;
+
+    case 'd':   /* Disassembler */
+
+        switch (AcpiGbl_Optarg[0])
+        {
+        case '^':
+
+            Gbl_DoCompile = FALSE;
+            break;
+
+        case 'a':
+
+            Gbl_DoCompile = FALSE;
+            Gbl_DisassembleAll = TRUE;
+            break;
+
+        case 'b':   /* Do not convert buffers to resource descriptors */
+
+            AcpiGbl_NoResourceDisassembly = TRUE;
+            break;
+
+        case 'c':
+
+            break;
+
+        case 'f':
+
+            AcpiGbl_ForceAmlDisassembly = TRUE;
+            break;
+
+        case 'l':   /* Use legacy ASL code (not ASL+) for disassembly */
+
+            Gbl_DoCompile = FALSE;
+            AcpiGbl_CstyleDisassembly = FALSE;
+            break;
+
+        default:
+
+            printf ("Unknown option: -d%s\n", AcpiGbl_Optarg);
+            return (-1);
+        }
+
+        Gbl_DisasmFlag = TRUE;
+        break;
+
+    case 'D':   /* Define a symbol */
+
+        PrAddDefine (AcpiGbl_Optarg, NULL, TRUE);
+        break;
+
+    case 'e':   /* External files for disassembler */
+
+        /* Get entire list of external files */
+
+        AcpiGbl_Optind--;
+        argv[AcpiGbl_Optind] = AcpiGbl_Optarg;
+
+        while (argv[AcpiGbl_Optind] &&
+              (argv[AcpiGbl_Optind][0] != '-'))
+        {
+            Status = AcpiDmAddToExternalFileList (argv[AcpiGbl_Optind]);
+            if (ACPI_FAILURE (Status))
+            {
+                printf ("Could not add %s to external list\n",
+                    argv[AcpiGbl_Optind]);
+                return (-1);
+            }
+
+            AcpiGbl_Optind++;
+        }
+        break;
+
+    case 'f':
+
+        switch (AcpiGbl_Optarg[0])
+        {
+        case '^':   /* Ignore errors and force creation of aml file */
+
+            Gbl_IgnoreErrors = TRUE;
+            break;
+
+        case 'e':   /* Disassembler: Get external declaration file */
+
+            if (AcpiGetoptArgument (argc, argv))
+            {
+                return (-1);
+            }
+
+            Gbl_ExternalRefFilename = AcpiGbl_Optarg;
+            break;
+
+        default:
+
+            printf ("Unknown option: -f%s\n", AcpiGbl_Optarg);
+            return (-1);
+        }
+        break;
+
+    case 'G':
+
+        Gbl_CompileGeneric = TRUE;
+        break;
+
+    case 'g':   /* Get all ACPI tables */
+
+        printf ("-g option is deprecated, use acpidump utility instead\n");
+        exit (1);
+
+    case 'h':
+
+        switch (AcpiGbl_Optarg[0])
+        {
+        case '^':
+
+            Usage ();
+            exit (0);
+
+        case 'c':
+
+            UtDisplayConstantOpcodes ();
+            exit (0);
+
+        case 'f':
+
+            AslFilenameHelp ();
+            exit (0);
+
+        case 'r':
+
+            /* reserved names */
+
+            ApDisplayReservedNames ();
+            exit (0);
+
+        case 't':
+
+            UtDisplaySupportedTables ();
+            exit (0);
+
+        default:
+
+            printf ("Unknown option: -h%s\n", AcpiGbl_Optarg);
+            return (-1);
+        }
+
+    case 'I':   /* Add an include file search directory */
+
+        FlAddIncludeDirectory (AcpiGbl_Optarg);
+        break;
+
+    case 'i':   /* Output AML as an include file */
+
+        switch (AcpiGbl_Optarg[0])
+        {
+        case 'a':
+
+            /* Produce assembly code include file */
+
+            Gbl_AsmIncludeOutputFlag = TRUE;
+            break;
+
+        case 'c':
+
+            /* Produce C include file */
+
+            Gbl_C_IncludeOutputFlag = TRUE;
+            break;
+
+        case 'n':
+
+            /* Compiler/Disassembler: Ignore the NOOP operator */
+
+            AcpiGbl_IgnoreNoopOperator = TRUE;
+            break;
+
+        default:
+
+            printf ("Unknown option: -i%s\n", AcpiGbl_Optarg);
+            return (-1);
+        }
+        break;
+
+    case 'l':   /* Listing files */
+
+        switch (AcpiGbl_Optarg[0])
+        {
+        case '^':
+
+            /* Produce listing file (Mixed source/aml) */
+
+            Gbl_ListingFlag = TRUE;
+            AcpiGbl_DmOpt_Listing = TRUE;
+            break;
+
+        case 'i':
+
+            /* Produce preprocessor output file */
+
+            Gbl_PreprocessorOutputFlag = TRUE;
+            break;
+
+        case 'm':
+
+            /* Produce hardware map summary file */
+
+            Gbl_MapfileFlag = TRUE;
+            break;
+
+        case 'n':
+
+            /* Produce namespace file */
+
+            Gbl_NsOutputFlag = TRUE;
+            break;
+
+        case 's':
+
+            /* Produce combined source file */
+
+            Gbl_SourceOutputFlag = TRUE;
+            break;
+
+        case 'x':
+
+            /* Produce cross-reference file */
+
+            Gbl_CrossReferenceOutput = TRUE;
+            break;
+
+        default:
+
+            printf ("Unknown option: -l%s\n", AcpiGbl_Optarg);
+            return (-1);
+        }
+        break;
+
+    case 'm':   /* Set line buffer size */
+
+        Gbl_LineBufferSize = (UINT32) strtoul (AcpiGbl_Optarg, NULL, 0) * 1024;
+        if (Gbl_LineBufferSize < ASL_DEFAULT_LINE_BUFFER_SIZE)
+        {
+            Gbl_LineBufferSize = ASL_DEFAULT_LINE_BUFFER_SIZE;
+        }
+        printf ("Line Buffer Size: %u\n", Gbl_LineBufferSize);
+        break;
+
+    case 'n':   /* Parse only */
+
+        Gbl_ParseOnlyFlag = TRUE;
+        break;
+
+    case 'o':   /* Control compiler AML optimizations */
+
+        switch (AcpiGbl_Optarg[0])
+        {
+        case 'a':
+
+            /* Disable all optimizations */
+
+            Gbl_FoldConstants = FALSE;
+            Gbl_IntegerOptimizationFlag = FALSE;
+            Gbl_ReferenceOptimizationFlag = FALSE;
+            break;
+
+        case 'c':
+
+            /* Display compile time(s) */
+
+            Gbl_CompileTimesFlag = TRUE;
+            break;
+
+        case 'e':
+
+            /* iASL: Disable External opcode generation */
+
+            Gbl_DoExternals = FALSE;
+
+            /* Disassembler: Emit embedded external operators */
+
+            AcpiGbl_DmEmitExternalOpcodes = TRUE;
+            break;
+
+        case 'f':
+
+            /* Disable folding on "normal" expressions */
+
+            Gbl_FoldConstants = FALSE;
+            break;
+
+        case 'i':
+
+            /* Disable integer optimization to constants */
+
+            Gbl_IntegerOptimizationFlag = FALSE;
+            break;
+
+        case 'n':
+
+            /* Disable named reference optimization */
+
+            Gbl_ReferenceOptimizationFlag = FALSE;
+            break;
+
+        case 't':
+
+            /* Disable heavy typechecking */
+
+            Gbl_DoTypechecking = FALSE;
+            break;
+
+        default:
+
+            printf ("Unknown option: -c%s\n", AcpiGbl_Optarg);
+            return (-1);
+        }
+        break;
+
+    case 'P':   /* Preprocessor options */
+
+        switch (AcpiGbl_Optarg[0])
+        {
+        case '^':   /* Proprocess only, emit (.i) file */
+
+            Gbl_PreprocessOnly = TRUE;
+            Gbl_PreprocessorOutputFlag = TRUE;
+            break;
+
+        case 'n':   /* Disable preprocessor */
+
+            Gbl_PreprocessFlag = FALSE;
+            break;
+
+        default:
+
+            printf ("Unknown option: -P%s\n", AcpiGbl_Optarg);
+            return (-1);
+        }
+        break;
+
+    case 'p':   /* Override default AML output filename */
+
+        Gbl_OutputFilenamePrefix = AcpiGbl_Optarg;
+        UtConvertBackslashes (Gbl_OutputFilenamePrefix);
+        Gbl_UseDefaultAmlFilename = FALSE;
+        break;
+
+    case 'r':   /* Override revision found in table header */
+
+        Gbl_RevisionOverride = (UINT8) strtoul (AcpiGbl_Optarg, NULL, 0);
+        break;
+
+    case 's':   /* Create AML in a source code file */
+
+        switch (AcpiGbl_Optarg[0])
+        {
+        case 'a':
+
+            /* Produce assembly code output file */
+
+            Gbl_AsmOutputFlag = TRUE;
+            break;
+
+        case 'c':
+
+            /* Produce C hex output file */
+
+            Gbl_C_OutputFlag = TRUE;
+            break;
+
+        case 'o':
+
+            /* Produce AML offset table in C */
+
+            Gbl_C_OffsetTableFlag = TRUE;
+            break;
+
+        default:
+
+            printf ("Unknown option: -s%s\n", AcpiGbl_Optarg);
+            return (-1);
+        }
+        break;
+
+    case 't':   /* Produce hex table output file */
+
+        switch (AcpiGbl_Optarg[0])
+        {
+        case 'a':
+
+            Gbl_HexOutputFlag = HEX_OUTPUT_ASM;
+            break;
+
+        case 'c':
+
+            Gbl_HexOutputFlag = HEX_OUTPUT_C;
+            break;
+
+        case 's':
+
+            Gbl_HexOutputFlag = HEX_OUTPUT_ASL;
+            break;
+
+        default:
+
+            printf ("Unknown option: -t%s\n", AcpiGbl_Optarg);
+            return (-1);
+        }
+        break;
+
+    case 'T':   /* Create a ACPI table template file */
+
+        Gbl_DoTemplates = TRUE;
+        break;
+
+    case 'v':   /* Version and verbosity settings */
+
+        switch (AcpiGbl_Optarg[0])
+        {
+        case '^':
+
+            printf (ACPI_COMMON_SIGNON (ASL_COMPILER_NAME));
+            exit (0);
+
+        case 'a':
+
+            /* Disable all error/warning/remark messages */
+
+            Gbl_NoErrors = TRUE;
+            break;
+
+        case 'e':
+
+            /* Disable all warning/remark messages (errors only) */
+
+            Gbl_DisplayRemarks = FALSE;
+            Gbl_DisplayWarnings = FALSE;
+            break;
+
+        case 'i':
+            /*
+             * Support for integrated development environment(s).
+             *
+             * 1) No compiler signon
+             * 2) Send stderr messages to stdout
+             * 3) Less verbose error messages (single line only for each)
+             * 4) Error/warning messages are formatted appropriately to
+             *    be recognized by MS Visual Studio
+             */
+            Gbl_VerboseErrors = FALSE;
+            Gbl_DoSignon = FALSE;
+            Gbl_Files[ASL_FILE_STDERR].Handle = stdout;
+            break;
+
+        case 'o':
+
+            Gbl_DisplayOptimizations = TRUE;
+            break;
+
+        case 'r':
+
+            Gbl_DisplayRemarks = FALSE;
+            break;
+
+        case 's':
+
+            Gbl_DoSignon = FALSE;
+            break;
+
+        case 't':
+
+            Gbl_VerboseTemplates = TRUE;
+            break;
+
+        case 'w':
+
+            /* Get the required argument */
+
+            if (AcpiGetoptArgument (argc, argv))
+            {
+                return (-1);
+            }
+
+            Status = AslDisableException (AcpiGbl_Optarg);
+            if (ACPI_FAILURE (Status))
+            {
+                return (-1);
+            }
+            break;
+
+        default:
+
+            printf ("Unknown option: -v%s\n", AcpiGbl_Optarg);
+            return (-1);
+        }
+        break;
+
+    case 'w': /* Set warning levels */
+
+        switch (AcpiGbl_Optarg[0])
+        {
+        case '1':
+
+            Gbl_WarningLevel = ASL_WARNING;
+            break;
+
+        case '2':
+
+            Gbl_WarningLevel = ASL_WARNING2;
+            break;
+
+        case '3':
+
+            Gbl_WarningLevel = ASL_WARNING3;
+            break;
+
+        case 'e':
+
+            Gbl_WarningsAsErrors = TRUE;
+            break;
+
+        default:
+
+            printf ("Unknown option: -w%s\n", AcpiGbl_Optarg);
+            return (-1);
+        }
+        break;
+
+    case 'x':   /* Set debug print output level */
+
+        AcpiDbgLevel = strtoul (AcpiGbl_Optarg, NULL, 16);
+        break;
+
+    case 'z':
+
+        Gbl_UseOriginalCompilerId = TRUE;
+        break;
+
+    default:
+
+        return (-1);
+    }
+
+    return (0);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AslMergeOptionTokens
+ *
+ * PARAMETERS:  InBuffer            - Input containing an option string
+ *              OutBuffer           - Merged output buffer
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Remove all whitespace from an option string.
+ *
+ ******************************************************************************/
+
+static void
+AslMergeOptionTokens (
+    char                    *InBuffer,
+    char                    *OutBuffer)
+{
+    char                    *Token;
+
+
+    *OutBuffer = 0;
+
+    Token = strtok (InBuffer, ASL_TOKEN_SEPARATORS);
+    while (Token)
+    {
+        strcat (OutBuffer, Token);
+        Token = strtok (NULL, ASL_TOKEN_SEPARATORS);
+    }
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AslDoResponseFile
+ *
+ * PARAMETERS:  Filename        - Name of the response file
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Open a response file and process all options within.
+ *
+ ******************************************************************************/
+
+static int
+AslDoResponseFile (
+    char                    *Filename)
+{
+    char                    *argv = StringBuffer2;
+    FILE                    *ResponseFile;
+    int                     OptStatus = 0;
+    int                     Opterr;
+    int                     Optind;
+
+
+    ResponseFile = fopen (Filename, "r");
+    if (!ResponseFile)
+    {
+        printf ("Could not open command file %s, %s\n",
+            Filename, strerror (errno));
+        return (-1);
+    }
+
+    /* Must save the current GetOpt globals */
+
+    Opterr = AcpiGbl_Opterr;
+    Optind = AcpiGbl_Optind;
+
+    /*
+     * Process all lines in the response file. There must be one complete
+     * option per line
+     */
+    while (fgets (StringBuffer, ASL_MSG_BUFFER_SIZE, ResponseFile))
+    {
+        /* Compress all tokens, allowing us to use a single argv entry */
+
+        AslMergeOptionTokens (StringBuffer, StringBuffer2);
+
+        /* Process the option */
+
+        AcpiGbl_Opterr = 0;
+        AcpiGbl_Optind = 0;
+
+        OptStatus = AslDoOptions (1, &argv, TRUE);
+        if (OptStatus)
+        {
+            printf ("Invalid option in command file %s: %s\n",
+                Filename, StringBuffer);
+            break;
+        }
+    }
+
+    /* Restore the GetOpt globals */
+
+    AcpiGbl_Opterr = Opterr;
+    AcpiGbl_Optind = Optind;
+
+    fclose (ResponseFile);
+    return (OptStatus);
+}
diff --git a/usr/src/cmd/acpi/iasl/aslparser.y b/usr/src/cmd/acpi/iasl/aslparser.y
new file mode 100644
index 0000000000..b3d83b8392
--- /dev/null
+++ b/usr/src/cmd/acpi/iasl/aslparser.y
@@ -0,0 +1,133 @@
+%{
+/******************************************************************************
+ *
+ * Module Name: aslparser.y - Master Bison/Yacc input file for iASL
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2016, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include "aslcompiler.h"
+#include "acpi.h"
+#include "accommon.h"
+
+#define _COMPONENT          ACPI_COMPILER
+        ACPI_MODULE_NAME    ("aslparse")
+
+/*
+ * Global Notes:
+ *
+ * October 2005: The following list terms have been optimized (from the
+ * original ASL grammar in the ACPI specification) to force the immediate
+ * reduction of each list item so that the parse stack use doesn't increase on
+ * each list element and possibly overflow on very large lists (>4000 items).
+ * This dramatically reduces use of the parse stack overall.
+ *
+ *      ArgList, TermList, ByteList, DWordList, PackageList,
+ *      ResourceMacroList, and FieldUnitList
+ */
+
+void *
+AslLocalAllocate (
+    unsigned int            Size);
+
+/* Bison/yacc configuration */
+
+#define static
+#undef malloc
+#define malloc              AslLocalAllocate
+#undef alloca
+#define alloca              AslLocalAllocate
+#define yytname             AslCompilername
+
+#define YYINITDEPTH         600             /* State stack depth */
+#define YYDEBUG             1               /* Enable debug output */
+#define YYERROR_VERBOSE     1               /* Verbose error messages */
+#define YYFLAG              -32768
+
+/* Define YYMALLOC/YYFREE to prevent redefinition errors  */
+
+#define YYMALLOC            AslLocalAllocate
+#define YYFREE              ACPI_FREE
+%}
+
+/*
+ * Declare the type of values in the grammar
+ */
+%union {
+    UINT64              i;
+    char                *s;
+    ACPI_PARSE_OBJECT   *n;
+}
+
+/*
+ * These shift/reduce conflicts are expected. There should be zero
+ * reduce/reduce conflicts.
+ */
+%expect 101
+
+/*! [Begin] no source code translation */
+
+/*
+ * The M4 macro processor is used to bring in the parser items,
+ * in order to keep this master file smaller, and to break up
+ * the various parser items.
+ */
+m4_define(NoEcho)
+
+/* Token types */
+
+m4_include(asltokens.y)
+
+/* Production types/names */
+
+m4_include(asltypes.y)
+%%
+
+/* Production rules */
+
+m4_include(aslrules.y)
+m4_include(aslcstyle.y)
+m4_include(aslresources.y)
+%%
+
+/*! [End] no source code translation !*/
+
+/* Local support functions in C */
+
+m4_include(aslsupport.y)
diff --git a/usr/src/cmd/acpi/iasl/aslpld.c b/usr/src/cmd/acpi/iasl/aslpld.c
new file mode 100644
index 0000000000..afc4683527
--- /dev/null
+++ b/usr/src/cmd/acpi/iasl/aslpld.c
@@ -0,0 +1,729 @@
+/******************************************************************************
+ *
+ * Module Name: aslpld - Implementation of ASL ToPLD macro
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2016, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include "aslcompiler.h"
+#include "aslcompiler.y.h"
+#include "amlcode.h"
+
+#define _COMPONENT          ACPI_COMPILER
+        ACPI_MODULE_NAME    ("aslpld")
+
+
+/* Local prototypes */
+
+static UINT8 *
+OpcEncodePldBuffer (
+    ACPI_PLD_INFO           *PldInfo);
+
+static BOOLEAN
+OpcFindName (
+    const char              **List,
+    char                    *Name,
+    UINT32                  *Index);
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    OpcDoPld
+ *
+ * PARAMETERS:  Op                  - Current parse node
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Convert ToPLD macro to 20-byte buffer
+ *
+ * The ToPLD parse tree looks like this:
+ *
+ *      TOPLD
+ *          PLD_REVISION
+ *              INTEGER
+ *          PLD_IGNORECOLOR
+ *              INTEGER
+ *          ...
+ *          etc.
+ *
+ ******************************************************************************/
+
+void
+OpcDoPld (
+    ACPI_PARSE_OBJECT       *Op)
+{
+    ACPI_PLD_INFO           PldInfo;
+    UINT8                   *Buffer;
+    ACPI_PARSE_OBJECT       *ThisOp;
+    ACPI_PARSE_OBJECT       *NewOp;
+    UINT16                  ParseOpcode;
+    UINT32                  Value;
+
+
+    if (!Op)
+    {
+        AslError (ASL_ERROR, ASL_MSG_NOT_EXIST, Op, NULL);
+        return;
+    }
+
+    if (Op->Asl.ParseOpcode != PARSEOP_TOPLD)
+    {
+        AslError (ASL_ERROR, ASL_MSG_INVALID_TYPE, Op, NULL);
+        return;
+    }
+
+    memset (&PldInfo, 0, sizeof (ACPI_PLD_INFO));
+
+    /* Traverse the list of PLD Ops (one per PLD field) */
+
+    ThisOp = Op->Asl.Child;
+    while (ThisOp)
+    {
+        /* Get child values */
+
+        ParseOpcode = ThisOp->Asl.Child->Asl.ParseOpcode;
+        Value = (UINT32) ThisOp->Asl.Child->Asl.Value.Integer;
+
+        switch (ThisOp->Asl.ParseOpcode)
+        {
+        case PARSEOP_PLD_REVISION:
+
+            if (ParseOpcode != PARSEOP_INTEGER)
+            {
+                AslError (ASL_ERROR, ASL_MSG_INVALID_TYPE, ThisOp, NULL);
+                break;
+            }
+
+            if (Value > 127)
+            {
+                AslError (ASL_ERROR, ASL_MSG_RANGE, ThisOp, NULL);
+                break;
+            }
+
+            PldInfo.Revision = (UINT8) Value;
+            break;
+
+        case PARSEOP_PLD_IGNORECOLOR:
+
+            if (ParseOpcode != PARSEOP_INTEGER)
+            {
+                AslError (ASL_ERROR, ASL_MSG_INVALID_TYPE, ThisOp, NULL);
+                break;
+            }
+
+            if (Value > 1)
+            {
+                AslError (ASL_ERROR, ASL_MSG_RANGE, ThisOp, NULL);
+                break;
+            }
+
+            PldInfo.IgnoreColor = (UINT8) Value;
+            break;
+
+        case PARSEOP_PLD_RED:
+        case PARSEOP_PLD_GREEN:
+        case PARSEOP_PLD_BLUE:
+
+            if (ParseOpcode != PARSEOP_INTEGER)
+            {
+                AslError (ASL_ERROR, ASL_MSG_RANGE, ThisOp, NULL);
+                break;
+            }
+
+            if (Value > 255)
+            {
+                AslError (ASL_ERROR, ASL_MSG_RANGE, ThisOp, NULL);
+                break;
+            }
+
+            if (ThisOp->Asl.ParseOpcode == PARSEOP_PLD_RED)
+            {
+                PldInfo.Red = (UINT8) Value;
+            }
+            else if (ThisOp->Asl.ParseOpcode == PARSEOP_PLD_GREEN)
+            {
+                PldInfo.Green = (UINT8) Value;
+            }
+            else /* PARSEOP_PLD_BLUE */
+            {
+                PldInfo.Blue = (UINT8) Value;
+            }
+            break;
+
+        case PARSEOP_PLD_WIDTH:
+        case PARSEOP_PLD_HEIGHT:
+
+            if (ParseOpcode != PARSEOP_INTEGER)
+            {
+                AslError (ASL_ERROR, ASL_MSG_INVALID_TYPE, ThisOp, NULL);
+                break;
+            }
+
+            if (Value > 65535)
+            {
+                AslError (ASL_ERROR, ASL_MSG_RANGE, ThisOp, NULL);
+                break;
+            }
+
+            if (ThisOp->Asl.ParseOpcode == PARSEOP_PLD_WIDTH)
+            {
+                PldInfo.Width = (UINT16) Value;
+            }
+            else /* PARSEOP_PLD_HEIGHT */
+            {
+                PldInfo.Height = (UINT16) Value;
+            }
+
+            break;
+
+        case PARSEOP_PLD_USERVISIBLE:
+        case PARSEOP_PLD_DOCK:
+        case PARSEOP_PLD_LID:
+
+            if (ParseOpcode != PARSEOP_INTEGER)
+            {
+                AslError (ASL_ERROR, ASL_MSG_INVALID_TYPE, ThisOp, NULL);
+                break;
+            }
+
+            if (Value > 1)
+            {
+                AslError (ASL_ERROR, ASL_MSG_RANGE, ThisOp, NULL);
+                break;
+            }
+
+            if (ThisOp->Asl.ParseOpcode == PARSEOP_PLD_USERVISIBLE)
+            {
+                PldInfo.UserVisible = (UINT8) Value;
+            }
+            else if (ThisOp->Asl.ParseOpcode == PARSEOP_PLD_DOCK)
+            {
+                PldInfo.Dock = (UINT8) Value;
+            }
+            else
+            {
+                PldInfo.Lid = (UINT8) Value;
+            }
+
+            break;
+
+        case PARSEOP_PLD_PANEL:
+
+            if (ParseOpcode == PARSEOP_INTEGER)
+            {
+                if (Value > 6)
+                {
+                    AslError (ASL_ERROR, ASL_MSG_RANGE, ThisOp, NULL);
+                    break;
+                }
+            }
+            else /* PARSEOP_STRING */
+            {
+                if (!OpcFindName (AcpiGbl_PldPanelList,
+                    ThisOp->Asl.Child->Asl.Value.String,
+                    &Value))
+                {
+                    AslError (ASL_ERROR, ASL_MSG_INVALID_OPERAND, ThisOp, NULL);
+                    break;
+                }
+            }
+
+            PldInfo.Panel = (UINT8) Value;
+            break;
+
+        case PARSEOP_PLD_VERTICALPOSITION:
+
+            if (ParseOpcode == PARSEOP_INTEGER)
+            {
+                if (Value > 2)
+                {
+                    AslError (ASL_ERROR, ASL_MSG_RANGE, ThisOp, NULL);
+                    break;
+                }
+            }
+            else /* PARSEOP_STRING */
+            {
+                if (!OpcFindName (AcpiGbl_PldVerticalPositionList,
+                    ThisOp->Asl.Child->Asl.Value.String,
+                    &Value))
+                {
+                    AslError (ASL_ERROR, ASL_MSG_INVALID_OPERAND, ThisOp, NULL);
+                    break;
+                }
+            }
+
+            PldInfo.VerticalPosition = (UINT8) Value;
+            break;
+
+        case PARSEOP_PLD_HORIZONTALPOSITION:
+
+            if (ParseOpcode == PARSEOP_INTEGER)
+            {
+                if (Value > 2)
+                {
+                    AslError (ASL_ERROR, ASL_MSG_RANGE, ThisOp, NULL);
+                    break;
+                }
+            }
+            else /* PARSEOP_STRING */
+            {
+                if (!OpcFindName (AcpiGbl_PldHorizontalPositionList,
+                    ThisOp->Asl.Child->Asl.Value.String,
+                    &Value))
+                {
+                    AslError (ASL_ERROR, ASL_MSG_INVALID_OPERAND, ThisOp, NULL);
+                    break;
+                }
+            }
+
+            PldInfo.HorizontalPosition = (UINT8) Value;
+            break;
+
+        case PARSEOP_PLD_SHAPE:
+
+            if (ParseOpcode == PARSEOP_INTEGER)
+            {
+                if (Value > 8)
+                {
+                    AslError (ASL_ERROR, ASL_MSG_RANGE, ThisOp, NULL);
+                    break;
+                }
+            }
+            else /* PARSEOP_STRING */
+            {
+                if (!OpcFindName (AcpiGbl_PldShapeList,
+                    ThisOp->Asl.Child->Asl.Value.String,
+                    &Value))
+                {
+                    AslError (ASL_ERROR, ASL_MSG_INVALID_OPERAND, ThisOp, NULL);
+                    break;
+                }
+            }
+
+            PldInfo.Shape = (UINT8) Value;
+            break;
+
+        case PARSEOP_PLD_GROUPORIENTATION:
+
+            if (ParseOpcode != PARSEOP_INTEGER)
+            {
+                AslError (ASL_ERROR, ASL_MSG_INVALID_TYPE, ThisOp, NULL);
+                break;
+            }
+
+            if (Value > 1)
+            {
+                AslError (ASL_ERROR, ASL_MSG_RANGE, ThisOp, NULL);
+                break;
+            }
+
+            PldInfo.GroupOrientation = (UINT8) Value;
+            break;
+
+        case PARSEOP_PLD_GROUPTOKEN:
+        case PARSEOP_PLD_GROUPPOSITION:
+
+            if (ParseOpcode != PARSEOP_INTEGER)
+            {
+                AslError (ASL_ERROR, ASL_MSG_INVALID_TYPE, ThisOp, NULL);
+                break;
+            }
+
+            if (Value > 255)
+            {
+                AslError (ASL_ERROR, ASL_MSG_RANGE, ThisOp, NULL);
+                break;
+            }
+
+            if (ThisOp->Asl.ParseOpcode == PARSEOP_PLD_GROUPTOKEN)
+            {
+                PldInfo.GroupToken = (UINT8) Value;
+            }
+            else /* PARSEOP_PLD_GROUPPOSITION */
+            {
+                PldInfo.GroupPosition = (UINT8) Value;
+            }
+
+            break;
+
+        case PARSEOP_PLD_BAY:
+        case PARSEOP_PLD_EJECTABLE:
+        case PARSEOP_PLD_EJECTREQUIRED:
+
+            if (ParseOpcode != PARSEOP_INTEGER)
+            {
+                AslError (ASL_ERROR, ASL_MSG_INVALID_TYPE, ThisOp, NULL);
+                break;
+            }
+
+            if (Value > 1)
+            {
+                AslError (ASL_ERROR, ASL_MSG_RANGE, ThisOp, NULL);
+                break;
+            }
+
+            if (ThisOp->Asl.ParseOpcode == PARSEOP_PLD_BAY)
+            {
+                PldInfo.Bay = (UINT8) Value;
+            }
+            else if (ThisOp->Asl.ParseOpcode == PARSEOP_PLD_EJECTABLE)
+            {
+                PldInfo.Ejectable = (UINT8) Value;
+            }
+            else /* PARSEOP_PLD_EJECTREQUIRED */
+            {
+                PldInfo.OspmEjectRequired = (UINT8) Value;
+            }
+
+            break;
+
+        case PARSEOP_PLD_CABINETNUMBER:
+        case PARSEOP_PLD_CARDCAGENUMBER:
+
+            if (ParseOpcode != PARSEOP_INTEGER)
+            {
+                AslError (ASL_ERROR, ASL_MSG_INVALID_TYPE, ThisOp, NULL);
+                break;
+            }
+
+            if (Value > 255)
+            {
+                AslError (ASL_ERROR, ASL_MSG_RANGE, ThisOp, NULL);
+                break;
+            }
+
+            if (ThisOp->Asl.ParseOpcode == PARSEOP_PLD_CABINETNUMBER)
+            {
+                PldInfo.CabinetNumber = (UINT8) Value;
+            }
+            else /* PARSEOP_PLD_CARDCAGENUMBER */
+            {
+                PldInfo.CardCageNumber = (UINT8) Value;
+            }
+
+            break;
+
+        case PARSEOP_PLD_REFERENCE:
+
+            if (ParseOpcode != PARSEOP_INTEGER)
+            {
+                AslError (ASL_ERROR, ASL_MSG_INVALID_TYPE, ThisOp, NULL);
+                break;
+            }
+
+            if (Value > 1)
+            {
+                AslError (ASL_ERROR, ASL_MSG_RANGE, ThisOp, NULL);
+                break;
+            }
+
+            PldInfo.Reference = (UINT8) Value;
+            break;
+
+        case PARSEOP_PLD_ROTATION:
+
+            if (ParseOpcode != PARSEOP_INTEGER)
+            {
+                AslError (ASL_ERROR, ASL_MSG_INVALID_TYPE, ThisOp, NULL);
+                break;
+            }
+
+            if (Value > 7)
+            {
+                switch (Value)
+                {
+                case 45:
+
+                    Value = 1;
+                    break;
+
+                case 90:
+
+                    Value = 2;
+                    break;
+
+                case 135:
+
+                    Value = 3;
+                    break;
+
+                case 180:
+
+                    Value = 4;
+                    break;
+
+                case 225:
+
+                    Value = 5;
+                    break;
+
+                case 270:
+
+                    Value = 6;
+                    break;
+
+                case 315:
+
+                    Value = 7;
+                    break;
+
+                default:
+
+                    AslError (ASL_ERROR, ASL_MSG_RANGE, ThisOp, NULL);
+                    break;
+                }
+            }
+
+            PldInfo.Rotation = (UINT8) Value;
+            break;
+
+        case PARSEOP_PLD_ORDER:
+
+            if (ParseOpcode != PARSEOP_INTEGER)
+            {
+                AslError (ASL_ERROR, ASL_MSG_INVALID_TYPE, ThisOp, NULL);
+                break;
+            }
+
+            if (Value > 31)
+            {
+                AslError (ASL_ERROR, ASL_MSG_RANGE, ThisOp, NULL);
+                break;
+            }
+
+            PldInfo.Order = (UINT8) Value;
+            break;
+
+        case PARSEOP_PLD_VERTICALOFFSET:
+        case PARSEOP_PLD_HORIZONTALOFFSET:
+
+            if (ParseOpcode != PARSEOP_INTEGER)
+            {
+                AslError (ASL_ERROR, ASL_MSG_INVALID_TYPE, ThisOp, NULL);
+                break;
+            }
+
+            if (Value > 65535)
+            {
+                AslError (ASL_ERROR, ASL_MSG_RANGE, ThisOp, NULL);
+                break;
+            }
+
+            if (ThisOp->Asl.ParseOpcode == PARSEOP_PLD_VERTICALOFFSET)
+            {
+                PldInfo.VerticalOffset = (UINT16) Value;
+            }
+            else /* PARSEOP_PLD_HORIZONTALOFFSET */
+            {
+                PldInfo.HorizontalOffset = (UINT16) Value;
+            }
+
+            break;
+
+        default:
+
+            AslError (ASL_ERROR, ASL_MSG_INVALID_TYPE, ThisOp, NULL);
+            break;
+        }
+
+        ThisOp = ThisOp->Asl.Next;
+    }
+
+    Buffer = OpcEncodePldBuffer (&PldInfo);
+
+    /* Change Op to a Buffer */
+
+    Op->Asl.ParseOpcode = PARSEOP_BUFFER;
+    Op->Common.AmlOpcode = AML_BUFFER_OP;
+
+    /* Disable further optimization */
+
+    Op->Asl.CompileFlags &= ~NODE_COMPILE_TIME_CONST;
+    UtSetParseOpName (Op);
+
+    /* Child node is the buffer length */
+
+    NewOp = TrAllocateNode (PARSEOP_INTEGER);
+
+    NewOp->Asl.AmlOpcode = AML_BYTE_OP;
+    NewOp->Asl.Value.Integer = 20;
+    NewOp->Asl.Parent = Op;
+
+    Op->Asl.Child = NewOp;
+    Op = NewOp;
+
+    /* Peer to the child is the raw buffer data */
+
+    NewOp = TrAllocateNode (PARSEOP_RAW_DATA);
+    NewOp->Asl.AmlOpcode = AML_RAW_DATA_BUFFER;
+    NewOp->Asl.AmlLength = 20;
+    NewOp->Asl.Value.String = ACPI_CAST_PTR (char, Buffer);
+    NewOp->Asl.Parent = Op->Asl.Parent;
+
+    Op->Asl.Next = NewOp;
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    OpcEncodePldBuffer
+ *
+ * PARAMETERS:  PldInfo             - _PLD buffer struct (Using local struct)
+ *
+ * RETURN:      Encode _PLD buffer suitable for return value from _PLD
+ *
+ * DESCRIPTION: Bit-packs a _PLD buffer struct.
+ *
+ ******************************************************************************/
+
+static UINT8 *
+OpcEncodePldBuffer (
+    ACPI_PLD_INFO           *PldInfo)
+{
+    UINT32                  *Buffer;
+    UINT32                  Dword;
+
+
+    Buffer = ACPI_ALLOCATE_ZEROED (ACPI_PLD_BUFFER_SIZE);
+    if (!Buffer)
+    {
+        return (NULL);
+    }
+
+    /* First 32 bits */
+
+    Dword = 0;
+    ACPI_PLD_SET_REVISION       (&Dword, PldInfo->Revision);
+    ACPI_PLD_SET_IGNORE_COLOR   (&Dword, PldInfo->IgnoreColor);
+    ACPI_PLD_SET_RED            (&Dword, PldInfo->Red);
+    ACPI_PLD_SET_GREEN          (&Dword, PldInfo->Green);
+    ACPI_PLD_SET_BLUE           (&Dword, PldInfo->Blue);
+    ACPI_MOVE_32_TO_32          (&Buffer[0], &Dword);
+
+    /* Second 32 bits */
+
+    Dword = 0;
+    ACPI_PLD_SET_WIDTH          (&Dword, PldInfo->Width);
+    ACPI_PLD_SET_HEIGHT         (&Dword, PldInfo->Height);
+    ACPI_MOVE_32_TO_32          (&Buffer[1], &Dword);
+
+    /* Third 32 bits */
+
+    Dword = 0;
+    ACPI_PLD_SET_USER_VISIBLE   (&Dword, PldInfo->UserVisible);
+    ACPI_PLD_SET_DOCK           (&Dword, PldInfo->Dock);
+    ACPI_PLD_SET_LID            (&Dword, PldInfo->Lid);
+    ACPI_PLD_SET_PANEL          (&Dword, PldInfo->Panel);
+    ACPI_PLD_SET_VERTICAL       (&Dword, PldInfo->VerticalPosition);
+    ACPI_PLD_SET_HORIZONTAL     (&Dword, PldInfo->HorizontalPosition);
+    ACPI_PLD_SET_SHAPE          (&Dword, PldInfo->Shape);
+    ACPI_PLD_SET_ORIENTATION    (&Dword, PldInfo->GroupOrientation);
+    ACPI_PLD_SET_TOKEN          (&Dword, PldInfo->GroupToken);
+    ACPI_PLD_SET_POSITION       (&Dword, PldInfo->GroupPosition);
+    ACPI_PLD_SET_BAY            (&Dword, PldInfo->Bay);
+    ACPI_MOVE_32_TO_32          (&Buffer[2], &Dword);
+
+    /* Fourth 32 bits */
+
+    Dword = 0;
+    ACPI_PLD_SET_EJECTABLE      (&Dword, PldInfo->Ejectable);
+    ACPI_PLD_SET_OSPM_EJECT     (&Dword, PldInfo->OspmEjectRequired);
+    ACPI_PLD_SET_CABINET        (&Dword, PldInfo->CabinetNumber);
+    ACPI_PLD_SET_CARD_CAGE      (&Dword, PldInfo->CardCageNumber);
+    ACPI_PLD_SET_REFERENCE      (&Dword, PldInfo->Reference);
+    ACPI_PLD_SET_ROTATION       (&Dword, PldInfo->Rotation);
+    ACPI_PLD_SET_ORDER          (&Dword, PldInfo->Order);
+    ACPI_MOVE_32_TO_32          (&Buffer[3], &Dword);
+
+    /* Revision 2 adds an additional DWORD */
+
+    if (PldInfo->Revision >= 2)
+    {
+        /* Fifth 32 bits */
+
+        Dword = 0;
+        ACPI_PLD_SET_VERT_OFFSET    (&Dword, PldInfo->VerticalOffset);
+        ACPI_PLD_SET_HORIZ_OFFSET   (&Dword, PldInfo->HorizontalOffset);
+        ACPI_MOVE_32_TO_32          (&Buffer[4], &Dword);
+    }
+
+    return (ACPI_CAST_PTR (UINT8, Buffer));
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    OpcFindName
+ *
+ * PARAMETERS:  List                - Array of char strings to be searched
+ *              Name                - Char string to string for
+ *              Index               - Index value to set if found
+ *
+ * RETURN:      TRUE if any names matched, FALSE otherwise
+ *
+ * DESCRIPTION: Match PLD name to value in lookup table. Sets Value to
+ *              equivalent parameter value.
+ *
+ ******************************************************************************/
+
+static BOOLEAN
+OpcFindName (
+    const char              **List,
+    char                    *Name,
+    UINT32                  *Index)
+{
+    const char              *NameString;
+    UINT32                  i;
+
+
+    AcpiUtStrupr (Name);
+
+    for (i = 0, NameString = List[0];
+            NameString;
+            i++, NameString = List[i])
+    {
+        if (!(strncmp (NameString, Name, strlen (Name))))
+        {
+            *Index = i;
+            return (TRUE);
+        }
+    }
+
+    return (FALSE);
+}
diff --git a/usr/src/cmd/acpi/iasl/aslpredef.c b/usr/src/cmd/acpi/iasl/aslpredef.c
new file mode 100644
index 0000000000..1aa627b251
--- /dev/null
+++ b/usr/src/cmd/acpi/iasl/aslpredef.c
@@ -0,0 +1,788 @@
+/******************************************************************************
+ *
+ * Module Name: aslpredef - support for ACPI predefined names
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2016, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#define ACPI_CREATE_PREDEFINED_TABLE
+#define ACPI_CREATE_RESOURCE_TABLE
+
+#include "aslcompiler.h"
+#include "aslcompiler.y.h"
+#include "acpredef.h"
+#include "acnamesp.h"
+
+
+#define _COMPONENT          ACPI_COMPILER
+        ACPI_MODULE_NAME    ("aslpredef")
+
+
+/* Local prototypes */
+
+static void
+ApCheckForUnexpectedReturnValue (
+    ACPI_PARSE_OBJECT       *Op,
+    ASL_METHOD_INFO         *MethodInfo);
+
+static UINT32
+ApCheckForSpecialName (
+    ACPI_PARSE_OBJECT       *Op,
+    char                    *Name);
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    ApCheckForPredefinedMethod
+ *
+ * PARAMETERS:  Op              - A parse node of type "METHOD".
+ *              MethodInfo      - Saved info about this method
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: If method is a predefined name, check that the number of
+ *              arguments and the return type (returns a value or not)
+ *              is correct.
+ *
+ ******************************************************************************/
+
+BOOLEAN
+ApCheckForPredefinedMethod (
+    ACPI_PARSE_OBJECT       *Op,
+    ASL_METHOD_INFO         *MethodInfo)
+{
+    UINT32                      Index;
+    UINT32                      RequiredArgCount;
+    const ACPI_PREDEFINED_INFO  *ThisName;
+
+
+    /* Check for a match against the predefined name list */
+
+    Index = ApCheckForPredefinedName (Op, Op->Asl.NameSeg);
+
+    switch (Index)
+    {
+    case ACPI_NOT_RESERVED_NAME:        /* No underscore or _Txx or _xxx name not matched */
+    case ACPI_PREDEFINED_NAME:          /* Resource Name or reserved scope name */
+    case ACPI_COMPILER_RESERVED_NAME:   /* A _Txx that was not emitted by compiler */
+
+        /* Just return, nothing to do */
+        return (FALSE);
+
+
+    case ACPI_EVENT_RESERVED_NAME:      /* _Lxx/_Exx/_Wxx/_Qxx methods */
+
+        Gbl_ReservedMethods++;
+
+        /* NumArguments must be zero for all _Lxx/_Exx/_Wxx/_Qxx methods */
+
+        if (MethodInfo->NumArguments != 0)
+        {
+            sprintf (MsgBuffer, "%s requires %u", Op->Asl.ExternalName, 0);
+
+            AslError (ASL_WARNING, ASL_MSG_RESERVED_ARG_COUNT_HI, Op,
+                MsgBuffer);
+        }
+        break;
+
+
+    default:
+        /*
+         * Matched a predefined method name - validate the ASL-defined
+         * argument count against the ACPI specification.
+         *
+         * Some methods are allowed to have a "minimum" number of args
+         * (_SCP) because their definition in ACPI has changed over time.
+         */
+        Gbl_ReservedMethods++;
+        ThisName = &AcpiGbl_PredefinedMethods[Index];
+        RequiredArgCount = METHOD_GET_ARG_COUNT (ThisName->Info.ArgumentList);
+
+        if (MethodInfo->NumArguments != RequiredArgCount)
+        {
+            sprintf (MsgBuffer, "%4.4s requires %u",
+                ThisName->Info.Name, RequiredArgCount);
+
+            if (MethodInfo->NumArguments < RequiredArgCount)
+            {
+                AslError (ASL_WARNING, ASL_MSG_RESERVED_ARG_COUNT_LO, Op,
+                    MsgBuffer);
+            }
+            else if ((MethodInfo->NumArguments > RequiredArgCount) &&
+                !(ThisName->Info.ArgumentList & ARG_COUNT_IS_MINIMUM))
+            {
+                AslError (ASL_WARNING, ASL_MSG_RESERVED_ARG_COUNT_HI, Op,
+                    MsgBuffer);
+            }
+        }
+
+        /*
+         * Check if method returns no value, but the predefined name is
+         * required to return a value
+         */
+        if (MethodInfo->NumReturnNoValue &&
+            ThisName->Info.ExpectedBtypes)
+        {
+            AcpiUtGetExpectedReturnTypes (StringBuffer,
+                ThisName->Info.ExpectedBtypes);
+
+            sprintf (MsgBuffer, "%s required for %4.4s",
+                StringBuffer, ThisName->Info.Name);
+
+            AslError (ASL_WARNING, ASL_MSG_RESERVED_RETURN_VALUE, Op,
+                MsgBuffer);
+        }
+        break;
+    }
+
+    return (TRUE);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    ApCheckForUnexpectedReturnValue
+ *
+ * PARAMETERS:  Op              - A parse node of type "RETURN".
+ *              MethodInfo      - Saved info about this method
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Check for an unexpected return value from a predefined method.
+ *              Invoked for predefined methods that are defined to not return
+ *              any value. If there is a return value, issue a remark, since
+ *              the ASL writer may be confused as to the method definition
+ *              and/or functionality.
+ *
+ * Note: We ignore all return values of "Zero", since this is what a standalone
+ *       Return() statement will always generate -- so we ignore it here --
+ *       i.e., there is no difference between Return() and Return(Zero).
+ *       Also, a null Return() will be disassembled to return(Zero) -- so, we
+ *       don't want to generate extraneous remarks/warnings for a disassembled
+ *       ASL file.
+ *
+ ******************************************************************************/
+
+static void
+ApCheckForUnexpectedReturnValue (
+    ACPI_PARSE_OBJECT       *Op,
+    ASL_METHOD_INFO         *MethodInfo)
+{
+    ACPI_PARSE_OBJECT       *ReturnValueOp;
+
+
+    /* Ignore Return() and Return(Zero) (they are the same) */
+
+    ReturnValueOp = Op->Asl.Child;
+    if (ReturnValueOp->Asl.ParseOpcode == PARSEOP_ZERO)
+    {
+        return;
+    }
+
+    /* We have a valid return value, but the reserved name did not expect it */
+
+    AslError (ASL_WARNING, ASL_MSG_RESERVED_NO_RETURN_VAL,
+        Op, MethodInfo->Op->Asl.ExternalName);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    ApCheckPredefinedReturnValue
+ *
+ * PARAMETERS:  Op              - A parse node of type "RETURN".
+ *              MethodInfo      - Saved info about this method
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: If method is a predefined name, attempt to validate the return
+ *              value. Only "static" types can be validated - a simple return
+ *              of an integer/string/buffer/package or a named reference to
+ *              a static object. Values such as a Localx or Argx or a control
+ *              method invocation are not checked. Issue a warning if there is
+ *              a valid return value, but the reserved method defines no
+ *              return value.
+ *
+ ******************************************************************************/
+
+void
+ApCheckPredefinedReturnValue (
+    ACPI_PARSE_OBJECT       *Op,
+    ASL_METHOD_INFO         *MethodInfo)
+{
+    UINT32                      Index;
+    ACPI_PARSE_OBJECT           *ReturnValueOp;
+    const ACPI_PREDEFINED_INFO  *ThisName;
+
+
+    /*
+     * Check parent method for a match against the predefined name list.
+     *
+     * Note: Disable compiler errors/warnings because any errors will be
+     * caught when analyzing the parent method. Eliminates duplicate errors.
+     */
+    Gbl_AllExceptionsDisabled = TRUE;
+    Index = ApCheckForPredefinedName (MethodInfo->Op,
+        MethodInfo->Op->Asl.NameSeg);
+    Gbl_AllExceptionsDisabled = FALSE;
+
+    switch (Index)
+    {
+    case ACPI_EVENT_RESERVED_NAME:      /* _Lxx/_Exx/_Wxx/_Qxx methods */
+
+        /* No return value expected, warn if there is one */
+
+        ApCheckForUnexpectedReturnValue (Op, MethodInfo);
+        return;
+
+    case ACPI_NOT_RESERVED_NAME:        /* No underscore or _Txx or _xxx name not matched */
+    case ACPI_PREDEFINED_NAME:          /* Resource Name or reserved scope name */
+    case ACPI_COMPILER_RESERVED_NAME:   /* A _Txx that was not emitted by compiler */
+
+        /* Just return, nothing to do */
+        return;
+
+    default: /* A standard predefined ACPI name */
+
+        ThisName = &AcpiGbl_PredefinedMethods[Index];
+        if (!ThisName->Info.ExpectedBtypes)
+        {
+            /* No return value expected, warn if there is one */
+
+            ApCheckForUnexpectedReturnValue (Op, MethodInfo);
+            return;
+        }
+
+        /* Get the object returned, it is the next argument */
+
+        ReturnValueOp = Op->Asl.Child;
+        switch (ReturnValueOp->Asl.ParseOpcode)
+        {
+        case PARSEOP_ZERO:
+        case PARSEOP_ONE:
+        case PARSEOP_ONES:
+        case PARSEOP_INTEGER:
+        case PARSEOP_STRING_LITERAL:
+        case PARSEOP_BUFFER:
+        case PARSEOP_PACKAGE:
+
+            /* Static data return object - check against expected type */
+
+            ApCheckObjectType (ThisName->Info.Name, ReturnValueOp,
+                ThisName->Info.ExpectedBtypes, ACPI_NOT_PACKAGE_ELEMENT);
+
+            /* For packages, check the individual package elements */
+
+            if (ReturnValueOp->Asl.ParseOpcode == PARSEOP_PACKAGE)
+            {
+                ApCheckPackage (ReturnValueOp, ThisName);
+            }
+            break;
+
+        default:
+            /*
+             * All other ops are very difficult or impossible to typecheck at
+             * compile time. These include all Localx, Argx, and method
+             * invocations. Also, NAMESEG and NAMESTRING because the type of
+             * any named object can be changed at runtime (for example,
+             * CopyObject will change the type of the target object.)
+             */
+            break;
+        }
+    }
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    ApCheckForPredefinedObject
+ *
+ * PARAMETERS:  Op              - A parse node
+ *              Name            - The ACPI name to be checked
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Check for a predefined name for a static object (created via
+ *              the ASL Name operator). If it is a predefined ACPI name, ensure
+ *              that the name does not require any arguments (which would
+ *              require a control method implemenation of the name), and that
+ *              the type of the object is one of the expected types for the
+ *              predefined name.
+ *
+ ******************************************************************************/
+
+void
+ApCheckForPredefinedObject (
+    ACPI_PARSE_OBJECT       *Op,
+    char                    *Name)
+{
+    UINT32                      Index;
+    ACPI_PARSE_OBJECT           *ObjectOp;
+    const ACPI_PREDEFINED_INFO  *ThisName;
+
+
+    /*
+     * Check for a real predefined name -- not a resource descriptor name
+     * or a predefined scope name
+     */
+    Index = ApCheckForPredefinedName (Op, Name);
+
+    switch (Index)
+    {
+    case ACPI_NOT_RESERVED_NAME:        /* No underscore or _Txx or _xxx name not matched */
+    case ACPI_PREDEFINED_NAME:          /* Resource Name or reserved scope name */
+    case ACPI_COMPILER_RESERVED_NAME:   /* A _Txx that was not emitted by compiler */
+
+        /* Nothing to do */
+        return;
+
+    case ACPI_EVENT_RESERVED_NAME:      /* _Lxx/_Exx/_Wxx/_Qxx methods */
+
+        /*
+         * These names must be control methods, by definition in ACPI spec.
+         * Also because they are defined to return no value. None of them
+         * require any arguments.
+         */
+        AslError (ASL_ERROR, ASL_MSG_RESERVED_METHOD, Op,
+            "with zero arguments");
+        return;
+
+    default:
+
+        break;
+    }
+
+    /* A standard predefined ACPI name */
+
+    /*
+     * If this predefined name requires input arguments, then
+     * it must be implemented as a control method
+     */
+    ThisName = &AcpiGbl_PredefinedMethods[Index];
+    if (METHOD_GET_ARG_COUNT (ThisName->Info.ArgumentList) > 0)
+    {
+        AslError (ASL_ERROR, ASL_MSG_RESERVED_METHOD, Op,
+            "with arguments");
+        return;
+    }
+
+    /*
+     * If no return value is expected from this predefined name, then
+     * it follows that it must be implemented as a control method
+     * (with zero args, because the args > 0 case was handled above)
+     * Examples are: _DIS, _INI, _IRC, _OFF, _ON, _PSx
+     */
+    if (!ThisName->Info.ExpectedBtypes)
+    {
+        AslError (ASL_ERROR, ASL_MSG_RESERVED_METHOD, Op,
+            "with zero arguments");
+        return;
+    }
+
+    /* Typecheck the actual object, it is the next argument */
+
+    ObjectOp = Op->Asl.Child->Asl.Next;
+    ApCheckObjectType (ThisName->Info.Name, Op->Asl.Child->Asl.Next,
+        ThisName->Info.ExpectedBtypes, ACPI_NOT_PACKAGE_ELEMENT);
+
+    /* For packages, check the individual package elements */
+
+    if (ObjectOp->Asl.ParseOpcode == PARSEOP_PACKAGE)
+    {
+        ApCheckPackage (ObjectOp, ThisName);
+    }
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    ApCheckForPredefinedName
+ *
+ * PARAMETERS:  Op              - A parse node
+ *              Name            - NameSeg to check
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Check a NameSeg against the reserved list.
+ *
+ ******************************************************************************/
+
+UINT32
+ApCheckForPredefinedName (
+    ACPI_PARSE_OBJECT       *Op,
+    char                    *Name)
+{
+    UINT32                      i;
+    const ACPI_PREDEFINED_INFO  *ThisName;
+
+
+    if (Name[0] == 0)
+    {
+        AslError (ASL_ERROR, ASL_MSG_COMPILER_INTERNAL, Op,
+            "zero length name found");
+    }
+
+    /* All reserved names are prefixed with a single underscore */
+
+    if (Name[0] != '_')
+    {
+        return (ACPI_NOT_RESERVED_NAME);
+    }
+
+    /* Check for a standard predefined method name */
+
+    ThisName = AcpiGbl_PredefinedMethods;
+    for (i = 0; ThisName->Info.Name[0]; i++)
+    {
+        if (ACPI_COMPARE_NAME (Name, ThisName->Info.Name))
+        {
+            /* Return index into predefined array */
+            return (i);
+        }
+
+        ThisName++; /* Does not account for extra package data, but is OK */
+    }
+
+    /* Check for resource names and predefined scope names */
+
+    ThisName = AcpiGbl_ResourceNames;
+    while (ThisName->Info.Name[0])
+    {
+        if (ACPI_COMPARE_NAME (Name, ThisName->Info.Name))
+        {
+            return (ACPI_PREDEFINED_NAME);
+        }
+
+        ThisName++;
+    }
+
+    ThisName = AcpiGbl_ScopeNames;
+    while (ThisName->Info.Name[0])
+    {
+        if (ACPI_COMPARE_NAME (Name, ThisName->Info.Name))
+        {
+            return (ACPI_PREDEFINED_NAME);
+        }
+
+        ThisName++;
+    }
+
+    /* Check for _Lxx/_Exx/_Wxx/_Qxx/_T_x. Warning if unknown predefined name */
+
+    return (ApCheckForSpecialName (Op, Name));
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    ApCheckForSpecialName
+ *
+ * PARAMETERS:  Op              - A parse node
+ *              Name            - NameSeg to check
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Check for the "special" predefined names -
+ *              _Lxx, _Exx, _Qxx, _Wxx, and _T_x
+ *
+ ******************************************************************************/
+
+static UINT32
+ApCheckForSpecialName (
+    ACPI_PARSE_OBJECT       *Op,
+    char                    *Name)
+{
+
+    /*
+     * Check for the "special" predefined names. We already know that the
+     * first character is an underscore.
+     *   GPE:  _Lxx
+     *   GPE:  _Exx
+     *   GPE:  _Wxx
+     *   EC:   _Qxx
+     */
+    if ((Name[1] == 'L') ||
+        (Name[1] == 'E') ||
+        (Name[1] == 'W') ||
+        (Name[1] == 'Q'))
+    {
+        /* The next two characters must be hex digits */
+
+        if ((isxdigit ((int) Name[2])) &&
+            (isxdigit ((int) Name[3])))
+        {
+            return (ACPI_EVENT_RESERVED_NAME);
+        }
+    }
+
+    /* Check for the names reserved for the compiler itself: _T_x */
+
+    else if ((Op->Asl.ExternalName[1] == 'T') &&
+             (Op->Asl.ExternalName[2] == '_'))
+    {
+        /* Ignore if actually emitted by the compiler */
+
+        if (Op->Asl.CompileFlags & NODE_COMPILER_EMITTED)
+        {
+            return (ACPI_NOT_RESERVED_NAME);
+        }
+
+        /*
+         * Was not actually emitted by the compiler. This is a special case,
+         * however. If the ASL code being compiled was the result of a
+         * dissasembly, it may possibly contain valid compiler-emitted names
+         * of the form "_T_x". We don't want to issue an error or even a
+         * warning and force the user to manually change the names. So, we
+         * will issue a remark instead.
+         */
+        AslError (ASL_REMARK, ASL_MSG_COMPILER_RESERVED,
+            Op, Op->Asl.ExternalName);
+        return (ACPI_COMPILER_RESERVED_NAME);
+    }
+
+    /*
+     * The name didn't match any of the known predefined names. Flag it as a
+     * warning, since the entire namespace starting with an underscore is
+     * reserved by the ACPI spec.
+     */
+    AslError (ASL_WARNING, ASL_MSG_UNKNOWN_RESERVED_NAME,
+        Op, Op->Asl.ExternalName);
+
+    return (ACPI_NOT_RESERVED_NAME);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    ApCheckObjectType
+ *
+ * PARAMETERS:  PredefinedName  - Name of the predefined object we are checking
+ *              Op              - Current parse node
+ *              ExpectedBtypes  - Bitmap of expected return type(s)
+ *              PackageIndex    - Index of object within parent package (if
+ *                                applicable - ACPI_NOT_PACKAGE_ELEMENT
+ *                                otherwise)
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Check if the object type is one of the types that is expected
+ *              by the predefined name. Only a limited number of object types
+ *              can be returned by the predefined names.
+ *
+ ******************************************************************************/
+
+ACPI_STATUS
+ApCheckObjectType (
+    const char              *PredefinedName,
+    ACPI_PARSE_OBJECT       *Op,
+    UINT32                  ExpectedBtypes,
+    UINT32                  PackageIndex)
+{
+    UINT32                  ReturnBtype;
+    char                    *TypeName;
+
+
+    if (!Op)
+    {
+        return (AE_TYPE);
+    }
+
+    /* Map the parse opcode to a bitmapped return type (RTYPE) */
+
+    switch (Op->Asl.ParseOpcode)
+    {
+    case PARSEOP_ZERO:
+    case PARSEOP_ONE:
+    case PARSEOP_ONES:
+    case PARSEOP_INTEGER:
+
+        ReturnBtype = ACPI_RTYPE_INTEGER;
+        TypeName = "Integer";
+        break;
+
+    case PARSEOP_STRING_LITERAL:
+
+        ReturnBtype = ACPI_RTYPE_STRING;
+        TypeName = "String";
+        break;
+
+    case PARSEOP_BUFFER:
+
+        ReturnBtype = ACPI_RTYPE_BUFFER;
+        TypeName = "Buffer";
+        break;
+
+    case PARSEOP_PACKAGE:
+    case PARSEOP_VAR_PACKAGE:
+
+        ReturnBtype = ACPI_RTYPE_PACKAGE;
+        TypeName = "Package";
+        break;
+
+    case PARSEOP_NAMESEG:
+    case PARSEOP_NAMESTRING:
+        /*
+         * Ignore any named references within a package object.
+         *
+         * For Package objects, references are allowed instead of any of the
+         * standard data types (Integer/String/Buffer/Package). These
+         * references are resolved at runtime. NAMESEG and NAMESTRING are
+         * impossible to typecheck at compile time because the type of
+         * any named object can be changed at runtime (for example,
+         * CopyObject will change the type of the target object).
+         */
+        if (PackageIndex != ACPI_NOT_PACKAGE_ELEMENT)
+        {
+            return (AE_OK);
+        }
+
+        ReturnBtype = ACPI_RTYPE_REFERENCE;
+        TypeName = "Reference";
+        break;
+
+    default:
+
+        /* Not one of the supported object types */
+
+        TypeName = UtGetOpName (Op->Asl.ParseOpcode);
+        goto TypeErrorExit;
+    }
+
+    /* Exit if the object is one of the expected types */
+
+    if (ReturnBtype & ExpectedBtypes)
+    {
+        return (AE_OK);
+    }
+
+
+TypeErrorExit:
+
+    /* Format the expected types and emit an error message */
+
+    AcpiUtGetExpectedReturnTypes (StringBuffer, ExpectedBtypes);
+
+    if (PackageIndex == ACPI_NOT_PACKAGE_ELEMENT)
+    {
+        sprintf (MsgBuffer, "%4.4s: found %s, %s required",
+            PredefinedName, TypeName, StringBuffer);
+    }
+    else
+    {
+        sprintf (MsgBuffer, "%4.4s: found %s at index %u, %s required",
+            PredefinedName, TypeName, PackageIndex, StringBuffer);
+    }
+
+    AslError (ASL_ERROR, ASL_MSG_RESERVED_OPERAND_TYPE, Op, MsgBuffer);
+    return (AE_TYPE);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    ApDisplayReservedNames
+ *
+ * PARAMETERS:  None
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Dump information about the ACPI predefined names and predefined
+ *              resource descriptor names.
+ *
+ ******************************************************************************/
+
+void
+ApDisplayReservedNames (
+    void)
+{
+    const ACPI_PREDEFINED_INFO  *ThisName;
+    UINT32                      Count;
+    UINT32                      NumTypes;
+
+
+    /*
+     * Predefined names/methods
+     */
+    printf ("\nPredefined Name Information\n\n");
+
+    Count = 0;
+    ThisName = AcpiGbl_PredefinedMethods;
+    while (ThisName->Info.Name[0])
+    {
+        AcpiUtDisplayPredefinedMethod (MsgBuffer, ThisName, FALSE);
+        Count++;
+        ThisName = AcpiUtGetNextPredefinedMethod (ThisName);
+    }
+
+    printf ("%u Predefined Names are recognized\n", Count);
+
+    /*
+     * Resource Descriptor names
+     */
+    printf ("\nPredefined Names for Resource Descriptor Fields\n\n");
+
+    Count = 0;
+    ThisName = AcpiGbl_ResourceNames;
+    while (ThisName->Info.Name[0])
+    {
+        NumTypes = AcpiUtGetResourceBitWidth (MsgBuffer,
+            ThisName->Info.ArgumentList);
+
+        printf ("%4.4s    Field is %s bits wide%s\n",
+            ThisName->Info.Name, MsgBuffer,
+            (NumTypes > 1) ? " (depending on descriptor type)" : "");
+
+        Count++;
+        ThisName++;
+    }
+
+    printf ("%u Resource Descriptor Field Names are recognized\n", Count);
+
+    /*
+     * Predefined scope names
+     */
+    printf ("\nPredefined Scope/Device Names (automatically created at root)\n\n");
+
+    ThisName = AcpiGbl_ScopeNames;
+    while (ThisName->Info.Name[0])
+    {
+        printf ("%4.4s    Scope/Device\n", ThisName->Info.Name);
+        ThisName++;
+    }
+}
diff --git a/usr/src/cmd/acpi/iasl/aslprepkg.c b/usr/src/cmd/acpi/iasl/aslprepkg.c
new file mode 100644
index 0000000000..824a0c5c77
--- /dev/null
+++ b/usr/src/cmd/acpi/iasl/aslprepkg.c
@@ -0,0 +1,874 @@
+/******************************************************************************
+ *
+ * Module Name: aslprepkg - support for ACPI predefined name package objects
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2016, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include "aslcompiler.h"
+#include "aslcompiler.y.h"
+#include "acpredef.h"
+
+
+#define _COMPONENT          ACPI_COMPILER
+        ACPI_MODULE_NAME    ("aslprepkg")
+
+
+/* Local prototypes */
+
+static ACPI_PARSE_OBJECT *
+ApCheckPackageElements (
+    const char                  *PredefinedName,
+    ACPI_PARSE_OBJECT           *Op,
+    UINT8                       Type1,
+    UINT32                      Count1,
+    UINT8                       Type2,
+    UINT32                      Count2);
+
+static void
+ApCheckPackageList (
+    const char                  *PredefinedName,
+    ACPI_PARSE_OBJECT           *ParentOp,
+    const ACPI_PREDEFINED_INFO  *Package,
+    UINT32                      StartIndex,
+    UINT32                      Count);
+
+static void
+ApPackageTooSmall (
+    const char                  *PredefinedName,
+    ACPI_PARSE_OBJECT           *Op,
+    UINT32                      Count,
+    UINT32                      ExpectedCount);
+
+static void
+ApZeroLengthPackage (
+    const char                  *PredefinedName,
+    ACPI_PARSE_OBJECT           *Op);
+
+static void
+ApPackageTooLarge (
+    const char                  *PredefinedName,
+    ACPI_PARSE_OBJECT           *Op,
+    UINT32                      Count,
+    UINT32                      ExpectedCount);
+
+static void
+ApCustomPackage (
+    ACPI_PARSE_OBJECT           *ParentOp,
+    const ACPI_PREDEFINED_INFO  *Predefined);
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    ApCheckPackage
+ *
+ * PARAMETERS:  ParentOp            - Parser op for the package
+ *              Predefined          - Pointer to package-specific info for
+ *                                    the method
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Top-level validation for predefined name return package
+ *              objects.
+ *
+ ******************************************************************************/
+
+void
+ApCheckPackage (
+    ACPI_PARSE_OBJECT           *ParentOp,
+    const ACPI_PREDEFINED_INFO  *Predefined)
+{
+    ACPI_PARSE_OBJECT           *Op;
+    const ACPI_PREDEFINED_INFO  *Package;
+    ACPI_STATUS                 Status;
+    UINT32                      ExpectedCount;
+    UINT32                      Count;
+    UINT32                      i;
+
+
+    /* The package info for this name is in the next table entry */
+
+    Package = Predefined + 1;
+
+    /* First child is the package length */
+
+    Op = ParentOp->Asl.Child;
+    Count = (UINT32) Op->Asl.Value.Integer;
+
+    /*
+     * Many of the variable-length top-level packages are allowed to simply
+     * have zero elements. This allows the BIOS to tell the host that even
+     * though the predefined name/method exists, the feature is not supported.
+     * Other package types require one or more elements. In any case, there
+     * is no need to continue validation.
+     */
+    if (!Count)
+    {
+        switch (Package->RetInfo.Type)
+        {
+        case ACPI_PTYPE1_FIXED:
+        case ACPI_PTYPE1_OPTION:
+        case ACPI_PTYPE2_PKG_COUNT:
+        case ACPI_PTYPE2_REV_FIXED:
+
+            ApZeroLengthPackage (Predefined->Info.Name, ParentOp);
+            break;
+
+        case ACPI_PTYPE1_VAR:
+        case ACPI_PTYPE2:
+        case ACPI_PTYPE2_COUNT:
+        case ACPI_PTYPE2_FIXED:
+        case ACPI_PTYPE2_MIN:
+        case ACPI_PTYPE2_FIX_VAR:
+        case ACPI_PTYPE2_VAR_VAR:
+        default:
+
+            break;
+        }
+
+        return;
+    }
+
+    /* Get the first element of the package */
+
+    Op = Op->Asl.Next;
+
+    /* Decode the package type */
+
+    switch (Package->RetInfo.Type)
+    {
+    case ACPI_PTYPE_CUSTOM:
+
+        ApCustomPackage (ParentOp, Predefined);
+        break;
+
+    case ACPI_PTYPE1_FIXED:
+        /*
+         * The package count is fixed and there are no subpackages
+         *
+         * If package is too small, exit.
+         * If package is larger than expected, issue warning but continue
+         */
+        ExpectedCount = Package->RetInfo.Count1 + Package->RetInfo.Count2;
+        if (Count < ExpectedCount)
+        {
+            goto PackageTooSmall;
+        }
+        else if (Count > ExpectedCount)
+        {
+            ApPackageTooLarge (Predefined->Info.Name, ParentOp,
+                Count, ExpectedCount);
+        }
+
+        /* Validate all elements of the package */
+
+        ApCheckPackageElements (Predefined->Info.Name, Op,
+            Package->RetInfo.ObjectType1, Package->RetInfo.Count1,
+            Package->RetInfo.ObjectType2, Package->RetInfo.Count2);
+        break;
+
+    case ACPI_PTYPE1_VAR:
+        /*
+         * The package count is variable, there are no subpackages,
+         * and all elements must be of the same type
+         */
+        for (i = 0; i < Count; i++)
+        {
+            ApCheckObjectType (Predefined->Info.Name, Op,
+                Package->RetInfo.ObjectType1, i);
+            Op = Op->Asl.Next;
+        }
+        break;
+
+    case ACPI_PTYPE1_OPTION:
+        /*
+         * The package count is variable, there are no subpackages.
+         * There are a fixed number of required elements, and a variable
+         * number of optional elements.
+         *
+         * Check if package is at least as large as the minimum required
+         */
+        ExpectedCount = Package->RetInfo3.Count;
+        if (Count < ExpectedCount)
+        {
+            goto PackageTooSmall;
+        }
+
+        /* Variable number of sub-objects */
+
+        for (i = 0; i < Count; i++)
+        {
+            if (i < Package->RetInfo3.Count)
+            {
+                /* These are the required package elements (0, 1, or 2) */
+
+                ApCheckObjectType (Predefined->Info.Name, Op,
+                    Package->RetInfo3.ObjectType[i], i);
+            }
+            else
+            {
+                /* These are the optional package elements */
+
+                ApCheckObjectType (Predefined->Info.Name, Op,
+                    Package->RetInfo3.TailObjectType, i);
+            }
+
+            Op = Op->Asl.Next;
+        }
+        break;
+
+    case ACPI_PTYPE2_REV_FIXED:
+
+        /* First element is the (Integer) revision */
+
+        ApCheckObjectType (Predefined->Info.Name, Op,
+            ACPI_RTYPE_INTEGER, 0);
+
+        Op = Op->Asl.Next;
+        Count--;
+
+        /* Examine the subpackages */
+
+        ApCheckPackageList (Predefined->Info.Name, Op,
+            Package, 1, Count);
+        break;
+
+    case ACPI_PTYPE2_PKG_COUNT:
+
+        /* First element is the (Integer) count of subpackages to follow */
+
+        Status = ApCheckObjectType (Predefined->Info.Name, Op,
+            ACPI_RTYPE_INTEGER, 0);
+
+        /* We must have an integer count from above (otherwise, use Count) */
+
+        if (ACPI_SUCCESS (Status))
+        {
+            /*
+             * Count cannot be larger than the parent package length, but
+             * allow it to be smaller. The >= accounts for the Integer above.
+             */
+            ExpectedCount = (UINT32) Op->Asl.Value.Integer;
+            if (ExpectedCount >= Count)
+            {
+                goto PackageTooSmall;
+            }
+
+            Count = ExpectedCount;
+        }
+
+        Op = Op->Asl.Next;
+
+        /* Examine the subpackages */
+
+        ApCheckPackageList (Predefined->Info.Name, Op,
+            Package, 1, Count);
+        break;
+
+    case ACPI_PTYPE2_UUID_PAIR:
+
+        /* The package contains a variable list of UUID Buffer/Package pairs */
+
+        /* The length of the package must be even */
+
+        if (Count & 1)
+        {
+            sprintf (MsgBuffer, "%4.4s: Package length, %d, must be even.",
+                Predefined->Info.Name, Count);
+
+            AslError (ASL_ERROR, ASL_MSG_RESERVED_PACKAGE_LENGTH,
+                ParentOp->Asl.Child, MsgBuffer);
+        }
+
+        /* Validate the alternating types */
+
+        for (i = 0; i < Count; ++i)
+        {
+            if (i & 1)
+            {
+                ApCheckObjectType (Predefined->Info.Name, Op,
+                    Package->RetInfo.ObjectType2, i);
+            }
+            else
+            {
+                ApCheckObjectType (Predefined->Info.Name, Op,
+                    Package->RetInfo.ObjectType1, i);
+            }
+
+            Op = Op->Asl.Next;
+        }
+
+        break;
+
+    case ACPI_PTYPE2_VAR_VAR:
+
+        /* Check for minimum size (ints at beginning + 1 subpackage) */
+
+        ExpectedCount = Package->RetInfo4.Count1 + 1;
+        if (Count < ExpectedCount)
+        {
+            goto PackageTooSmall;
+        }
+
+        /* Check the non-package elements at beginning of main package */
+
+        for (i = 0; i < Package->RetInfo4.Count1; ++i)
+        {
+            Status = ApCheckObjectType (Predefined->Info.Name, Op,
+                Package->RetInfo4.ObjectType1, i);
+            Op = Op->Asl.Next;
+        }
+
+        /* Examine the variable-length list of subpackages */
+
+        ApCheckPackageList (Predefined->Info.Name, Op,
+            Package, Package->RetInfo4.Count1, Count);
+
+        break;
+
+    case ACPI_PTYPE2:
+    case ACPI_PTYPE2_FIXED:
+    case ACPI_PTYPE2_MIN:
+    case ACPI_PTYPE2_COUNT:
+    case ACPI_PTYPE2_FIX_VAR:
+        /*
+         * These types all return a single Package that consists of a
+         * variable number of subpackages.
+         */
+
+        /* Examine the subpackages */
+
+        ApCheckPackageList (Predefined->Info.Name, Op,
+            Package, 0, Count);
+        break;
+
+    default:
+        return;
+    }
+
+    return;
+
+PackageTooSmall:
+    ApPackageTooSmall (Predefined->Info.Name, ParentOp,
+        Count, ExpectedCount);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    ApCustomPackage
+ *
+ * PARAMETERS:  ParentOp            - Parse op for the package
+ *              Predefined          - Pointer to package-specific info for
+ *                                    the method
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Validate packages that don't fit into the standard model and
+ *              require custom code.
+ *
+ * NOTE: Currently used for the _BIX method only. When needed for two or more
+ * methods, probably a detect/dispatch mechanism will be required.
+ *
+ ******************************************************************************/
+
+static void
+ApCustomPackage (
+    ACPI_PARSE_OBJECT           *ParentOp,
+    const ACPI_PREDEFINED_INFO  *Predefined)
+{
+    ACPI_PARSE_OBJECT           *Op;
+    UINT32                      Count;
+    UINT32                      ExpectedCount;
+    UINT32                      Version;
+
+
+    /* First child is the package length */
+
+    Op = ParentOp->Asl.Child;
+    Count = (UINT32) Op->Asl.Value.Integer;
+
+    /* Get the version number, must be Integer */
+
+    Op = Op->Asl.Next;
+    Version = (UINT32) Op->Asl.Value.Integer;
+    if (Op->Asl.ParseOpcode != PARSEOP_INTEGER)
+    {
+        AslError (ASL_ERROR, ASL_MSG_RESERVED_OPERAND_TYPE, Op, MsgBuffer);
+        return;
+    }
+
+    /* Validate count (# of elements) */
+
+    ExpectedCount = 21;         /* Version 1 */
+    if (Version == 0)
+    {
+        ExpectedCount = 20;     /* Version 0 */
+    }
+
+    if (Count < ExpectedCount)
+    {
+        ApPackageTooSmall (Predefined->Info.Name, ParentOp,
+            Count, ExpectedCount);
+        return;
+    }
+    else if (Count > ExpectedCount)
+    {
+        ApPackageTooLarge (Predefined->Info.Name, ParentOp,
+            Count, ExpectedCount);
+    }
+
+    /* Validate all elements of the package */
+
+    Op = ApCheckPackageElements (Predefined->Info.Name, Op,
+        ACPI_RTYPE_INTEGER, 16,
+        ACPI_RTYPE_STRING, 4);
+
+    /* Version 1 has a single trailing integer */
+
+    if (Version > 0)
+    {
+        ApCheckPackageElements (Predefined->Info.Name, Op,
+            ACPI_RTYPE_INTEGER, 1, 0, 0);
+    }
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    ApCheckPackageElements
+ *
+ * PARAMETERS:  PredefinedName      - Name of the predefined object
+ *              Op                  - Parser op for the package
+ *              Type1               - Object type for first group
+ *              Count1              - Count for first group
+ *              Type2               - Object type for second group
+ *              Count2              - Count for second group
+ *
+ * RETURN:      Next Op peer in the parse tree, after all specified elements
+ *              have been validated. Used for multiple validations (calls
+ *              to this function).
+ *
+ * DESCRIPTION: Validate all elements of a package. Works with packages that
+ *              are defined to contain up to two groups of different object
+ *              types.
+ *
+ ******************************************************************************/
+
+static ACPI_PARSE_OBJECT *
+ApCheckPackageElements (
+    const char              *PredefinedName,
+    ACPI_PARSE_OBJECT       *Op,
+    UINT8                   Type1,
+    UINT32                  Count1,
+    UINT8                   Type2,
+    UINT32                  Count2)
+{
+    UINT32                  i;
+
+
+    /*
+     * Up to two groups of package elements are supported by the data
+     * structure. All elements in each group must be of the same type.
+     * The second group can have a count of zero.
+     *
+     * Aborts check upon a NULL package element, as this means (at compile
+     * time) that the remainder of the package elements are also NULL
+     * (This is the only way to create NULL package elements.)
+     */
+    for (i = 0; (i < Count1) && Op; i++)
+    {
+        ApCheckObjectType (PredefinedName, Op, Type1, i);
+        Op = Op->Asl.Next;
+    }
+
+    for (i = 0; (i < Count2) && Op; i++)
+    {
+        ApCheckObjectType (PredefinedName, Op, Type2, (i + Count1));
+        Op = Op->Asl.Next;
+    }
+
+    return (Op);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    ApCheckPackageList
+ *
+ * PARAMETERS:  PredefinedName      - Name of the predefined object
+ *              ParentOp            - Parser op of the parent package
+ *              Package             - Package info for this predefined name
+ *              StartIndex          - Index in parent package where list begins
+ *              ParentCount         - Element count of parent package
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Validate the individual package elements for a predefined name.
+ *              Handles the cases where the predefined name is defined as a
+ *              Package of Packages (subpackages). These are the types:
+ *
+ *              ACPI_PTYPE2
+ *              ACPI_PTYPE2_FIXED
+ *              ACPI_PTYPE2_MIN
+ *              ACPI_PTYPE2_COUNT
+ *              ACPI_PTYPE2_FIX_VAR
+ *              ACPI_PTYPE2_VAR_VAR
+ *
+ ******************************************************************************/
+
+static void
+ApCheckPackageList (
+    const char                  *PredefinedName,
+    ACPI_PARSE_OBJECT           *ParentOp,
+    const ACPI_PREDEFINED_INFO  *Package,
+    UINT32                      StartIndex,
+    UINT32                      ParentCount)
+{
+    ACPI_PARSE_OBJECT           *SubPackageOp = ParentOp;
+    ACPI_PARSE_OBJECT           *Op;
+    ACPI_STATUS                 Status;
+    UINT32                      Count;
+    UINT32                      ExpectedCount;
+    UINT32                      i;
+    UINT32                      j;
+
+
+    /*
+     * Validate each subpackage in the parent Package
+     *
+     * Note: We ignore NULL package elements on the assumption that
+     * they will be initialized by the BIOS or other ASL code.
+     */
+    for (i = 0; (i < ParentCount) && SubPackageOp; i++)
+    {
+        /* Each object in the list must be of type Package */
+
+        Status = ApCheckObjectType (PredefinedName, SubPackageOp,
+            ACPI_RTYPE_PACKAGE, i + StartIndex);
+        if (ACPI_FAILURE (Status))
+        {
+            goto NextSubpackage;
+        }
+
+        /* Examine the different types of expected subpackages */
+
+        Op = SubPackageOp->Asl.Child;
+
+        /* First child is the package length */
+
+        Count = (UINT32) Op->Asl.Value.Integer;
+        Op = Op->Asl.Next;
+
+        /*
+         * Most subpackage must have at least one element, with
+         * only rare exceptions. (_RDI)
+         */
+        if (!Count &&
+            (Package->RetInfo.Type != ACPI_PTYPE2_VAR_VAR))
+        {
+            ApZeroLengthPackage (PredefinedName, SubPackageOp);
+            goto NextSubpackage;
+        }
+
+        /*
+         * Decode the package type.
+         * PTYPE2 indicates that a "package of packages" is expected for
+         * this name. The various flavors of PTYPE2 indicate the number
+         * and format of the subpackages.
+         */
+        switch (Package->RetInfo.Type)
+        {
+        case ACPI_PTYPE2:
+        case ACPI_PTYPE2_PKG_COUNT:
+        case ACPI_PTYPE2_REV_FIXED:
+
+            /* Each subpackage has a fixed number of elements */
+
+            ExpectedCount = Package->RetInfo.Count1 + Package->RetInfo.Count2;
+            if (Count < ExpectedCount)
+            {
+                ApPackageTooSmall (PredefinedName, SubPackageOp,
+                    Count, ExpectedCount);
+                break;
+            }
+            if (Count > ExpectedCount)
+            {
+                ApPackageTooLarge (PredefinedName, SubPackageOp,
+                    Count, ExpectedCount);
+                break;
+            }
+
+            ApCheckPackageElements (PredefinedName, Op,
+                Package->RetInfo.ObjectType1, Package->RetInfo.Count1,
+                Package->RetInfo.ObjectType2, Package->RetInfo.Count2);
+            break;
+
+        case ACPI_PTYPE2_FIX_VAR:
+            /*
+             * Each subpackage has a fixed number of elements and an
+             * optional element
+             */
+            ExpectedCount = Package->RetInfo.Count1 + Package->RetInfo.Count2;
+            if (Count < ExpectedCount)
+            {
+                ApPackageTooSmall (PredefinedName, SubPackageOp,
+                    Count, ExpectedCount);
+                break;
+            }
+
+            ApCheckPackageElements (PredefinedName, Op,
+                Package->RetInfo.ObjectType1, Package->RetInfo.Count1,
+                Package->RetInfo.ObjectType2,
+                Count - Package->RetInfo.Count1);
+            break;
+
+        case ACPI_PTYPE2_VAR_VAR:
+            /*
+             * Must have at least the minimum number elements.
+             * A zero PkgCount means the number of elements is variable.
+             */
+            ExpectedCount = Package->RetInfo4.PkgCount;
+            if (ExpectedCount && (Count < ExpectedCount))
+            {
+                ApPackageTooSmall (PredefinedName, SubPackageOp,
+                    Count, 1);
+                break;
+            }
+
+            ApCheckPackageElements (PredefinedName, Op,
+                Package->RetInfo4.SubObjectTypes,
+                Package->RetInfo4.PkgCount,
+                0, 0);
+            break;
+
+        case ACPI_PTYPE2_FIXED:
+
+            /* Each subpackage has a fixed length */
+
+            ExpectedCount = Package->RetInfo2.Count;
+            if (Count < ExpectedCount)
+            {
+                ApPackageTooSmall (PredefinedName, SubPackageOp,
+                    Count, ExpectedCount);
+                break;
+            }
+            if (Count > ExpectedCount)
+            {
+                ApPackageTooLarge (PredefinedName, SubPackageOp,
+                    Count, ExpectedCount);
+                break;
+            }
+
+            /* Check each object/type combination */
+
+            for (j = 0; j < ExpectedCount; j++)
+            {
+                ApCheckObjectType (PredefinedName, Op,
+                    Package->RetInfo2.ObjectType[j], j);
+
+                Op = Op->Asl.Next;
+            }
+            break;
+
+        case ACPI_PTYPE2_MIN:
+
+            /* Each subpackage has a variable but minimum length */
+
+            ExpectedCount = Package->RetInfo.Count1;
+            if (Count < ExpectedCount)
+            {
+                ApPackageTooSmall (PredefinedName, SubPackageOp,
+                    Count, ExpectedCount);
+                break;
+            }
+
+            /* Check the type of each subpackage element */
+
+            ApCheckPackageElements (PredefinedName, Op,
+                Package->RetInfo.ObjectType1, Count, 0, 0);
+            break;
+
+        case ACPI_PTYPE2_COUNT:
+            /*
+             * First element is the (Integer) count of elements, including
+             * the count field (the ACPI name is NumElements)
+             */
+            Status = ApCheckObjectType (PredefinedName, Op,
+                ACPI_RTYPE_INTEGER, 0);
+
+            /* We must have an integer count from above (otherwise, use Count) */
+
+            if (ACPI_SUCCESS (Status))
+            {
+                /*
+                 * Make sure package is large enough for the Count and is
+                 * is as large as the minimum size
+                 */
+                ExpectedCount = (UINT32) Op->Asl.Value.Integer;
+
+                if (Count < ExpectedCount)
+                {
+                    ApPackageTooSmall (PredefinedName, SubPackageOp,
+                        Count, ExpectedCount);
+                    break;
+                }
+                else if (Count > ExpectedCount)
+                {
+                    ApPackageTooLarge (PredefinedName, SubPackageOp,
+                        Count, ExpectedCount);
+                }
+
+                /* Some names of this type have a minimum length */
+
+                if (Count < Package->RetInfo.Count1)
+                {
+                    ExpectedCount = Package->RetInfo.Count1;
+                    ApPackageTooSmall (PredefinedName, SubPackageOp,
+                        Count, ExpectedCount);
+                    break;
+                }
+
+                Count = ExpectedCount;
+            }
+
+            /* Check the type of each subpackage element */
+
+            Op = Op->Asl.Next;
+            ApCheckPackageElements (PredefinedName, Op,
+                Package->RetInfo.ObjectType1, (Count - 1), 0, 0);
+            break;
+
+        default:
+            break;
+        }
+
+NextSubpackage:
+        SubPackageOp = SubPackageOp->Asl.Next;
+    }
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    ApPackageTooSmall
+ *
+ * PARAMETERS:  PredefinedName      - Name of the predefined object
+ *              Op                  - Current parser op
+ *              Count               - Actual package element count
+ *              ExpectedCount       - Expected package element count
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Issue error message for a package that is smaller than
+ *              required.
+ *
+ ******************************************************************************/
+
+static void
+ApPackageTooSmall (
+    const char                  *PredefinedName,
+    ACPI_PARSE_OBJECT           *Op,
+    UINT32                      Count,
+    UINT32                      ExpectedCount)
+{
+
+    sprintf (MsgBuffer, "%s: length %u, required minimum is %u",
+        PredefinedName, Count, ExpectedCount);
+
+    AslError (ASL_ERROR, ASL_MSG_RESERVED_PACKAGE_LENGTH, Op, MsgBuffer);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    ApZeroLengthPackage
+ *
+ * PARAMETERS:  PredefinedName      - Name of the predefined object
+ *              Op                  - Current parser op
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Issue error message for a zero-length package (a package that
+ *              is required to have a non-zero length). Variable length
+ *              packages seem to be allowed to have zero length, however.
+ *              Even if not allowed, BIOS code does it.
+ *
+ ******************************************************************************/
+
+static void
+ApZeroLengthPackage (
+    const char                  *PredefinedName,
+    ACPI_PARSE_OBJECT           *Op)
+{
+
+    sprintf (MsgBuffer, "%s: length is zero", PredefinedName);
+
+    AslError (ASL_ERROR, ASL_MSG_RESERVED_PACKAGE_LENGTH, Op, MsgBuffer);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    ApPackageTooLarge
+ *
+ * PARAMETERS:  PredefinedName      - Name of the predefined object
+ *              Op                  - Current parser op
+ *              Count               - Actual package element count
+ *              ExpectedCount       - Expected package element count
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Issue a remark for a package that is larger than expected.
+ *
+ ******************************************************************************/
+
+static void
+ApPackageTooLarge (
+    const char                  *PredefinedName,
+    ACPI_PARSE_OBJECT           *Op,
+    UINT32                      Count,
+    UINT32                      ExpectedCount)
+{
+
+    sprintf (MsgBuffer, "%s: length is %u, only %u required",
+        PredefinedName, Count, ExpectedCount);
+
+    AslError (ASL_REMARK, ASL_MSG_RESERVED_PACKAGE_LENGTH, Op, MsgBuffer);
+}
diff --git a/usr/src/cmd/acpi/iasl/aslprintf.c b/usr/src/cmd/acpi/iasl/aslprintf.c
new file mode 100644
index 0000000000..c27114cf3c
--- /dev/null
+++ b/usr/src/cmd/acpi/iasl/aslprintf.c
@@ -0,0 +1,380 @@
+/******************************************************************************
+ *
+ * Module Name: aslprintf - ASL Printf/Fprintf macro support
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2016, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include "aslcompiler.h"
+#include "aslcompiler.y.h"
+#include "amlcode.h"
+
+#define _COMPONENT          ACPI_COMPILER
+        ACPI_MODULE_NAME    ("aslprintf")
+
+
+/* Local prototypes */
+
+static void
+OpcCreateConcatenateNode (
+    ACPI_PARSE_OBJECT       *Op,
+    ACPI_PARSE_OBJECT       *Node);
+
+static void
+OpcParsePrintf (
+    ACPI_PARSE_OBJECT       *Op,
+    ACPI_PARSE_OBJECT       *DestOp);
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    OpcDoPrintf
+ *
+ * PARAMETERS:  Op                  - printf parse node
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Convert printf macro to a Store(..., Debug) AML operation.
+ *
+ ******************************************************************************/
+
+void
+OpcDoPrintf (
+    ACPI_PARSE_OBJECT       *Op)
+{
+    ACPI_PARSE_OBJECT       *DestOp;
+
+
+    /* Store destination is the Debug op */
+
+    DestOp = TrAllocateNode (PARSEOP_DEBUG);
+    DestOp->Asl.AmlOpcode = AML_DEBUG_OP;
+    DestOp->Asl.Parent = Op;
+    DestOp->Asl.LogicalLineNumber = Op->Asl.LogicalLineNumber;
+
+    OpcParsePrintf (Op, DestOp);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    OpcDoFprintf
+ *
+ * PARAMETERS:  Op                  - fprintf parse node
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Convert fprintf macro to a Store AML operation.
+ *
+ ******************************************************************************/
+
+void
+OpcDoFprintf (
+    ACPI_PARSE_OBJECT       *Op)
+{
+    ACPI_PARSE_OBJECT       *DestOp;
+
+
+    /* Store destination is the first argument of fprintf */
+
+    DestOp = Op->Asl.Child;
+    Op->Asl.Child = DestOp->Asl.Next;
+    DestOp->Asl.Next = NULL;
+
+    OpcParsePrintf (Op, DestOp);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    OpcParsePrintf
+ *
+ * PARAMETERS:  Op                  - Printf parse node
+ *              DestOp              - Destination of Store operation
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Convert printf macro to a Store AML operation. The printf
+ *              macro parse tree is layed out as follows:
+ *
+ *              Op        - printf parse op
+ *              Op->Child - Format string
+ *              Op->Next  - Format string arguments
+ *
+ ******************************************************************************/
+
+static void
+OpcParsePrintf (
+    ACPI_PARSE_OBJECT       *Op,
+    ACPI_PARSE_OBJECT       *DestOp)
+{
+    char                    *Format;
+    char                    *StartPosition = NULL;
+    ACPI_PARSE_OBJECT       *ArgNode;
+    ACPI_PARSE_OBJECT       *NextNode;
+    UINT32                  StringLength = 0;
+    char                    *NewString;
+    BOOLEAN                 StringToProcess = FALSE;
+    ACPI_PARSE_OBJECT       *NewOp;
+
+
+    /* Get format string */
+
+    Format = ACPI_CAST_PTR (char, Op->Asl.Child->Asl.Value.String);
+    ArgNode = Op->Asl.Child->Asl.Next;
+
+    /*
+     * Detach argument list so that we can use a NULL check to distinguish
+     * the first concatenation operation we need to make
+     */
+    Op->Asl.Child = NULL;
+
+    for (; *Format; ++Format)
+    {
+        if (*Format != '%')
+        {
+            if (!StringToProcess)
+            {
+                /* Mark the beginning of a string */
+
+                StartPosition = Format;
+                StringToProcess = TRUE;
+            }
+
+            ++StringLength;
+            continue;
+        }
+
+        /* Save string, if any, to new string object and concat it */
+
+        if (StringToProcess)
+        {
+            NewString = UtStringCacheCalloc (StringLength + 1);
+            strncpy (NewString, StartPosition, StringLength);
+
+            NewOp = TrAllocateNode (PARSEOP_STRING_LITERAL);
+            NewOp->Asl.Value.String = NewString;
+            NewOp->Asl.AmlOpcode = AML_STRING_OP;
+            NewOp->Asl.AcpiBtype = ACPI_BTYPE_STRING;
+            NewOp->Asl.LogicalLineNumber = Op->Asl.LogicalLineNumber;
+
+            OpcCreateConcatenateNode(Op, NewOp);
+
+            StringLength = 0;
+            StringToProcess = FALSE;
+        }
+
+        ++Format;
+
+        /*
+         * We have a format parameter and will need an argument to go
+         * with it
+         */
+        if (!ArgNode ||
+            ArgNode->Asl.ParseOpcode == PARSEOP_DEFAULT_ARG)
+        {
+            AslError(ASL_ERROR, ASL_MSG_ARG_COUNT_LO, Op, NULL);
+            return;
+        }
+
+        /*
+         * We do not support sub-specifiers of printf (flags, width,
+         * precision, length). For specifiers we only support %x/%X for
+         * hex or %s for strings. Also, %o for generic "acpi object".
+         */
+        switch (*Format)
+        {
+        case 's':
+
+            if (ArgNode->Asl.ParseOpcode != PARSEOP_STRING_LITERAL)
+            {
+                AslError(ASL_ERROR, ASL_MSG_INVALID_TYPE, ArgNode,
+                    "String required");
+                return;
+            }
+
+            NextNode = ArgNode->Asl.Next;
+            ArgNode->Asl.Next = NULL;
+            OpcCreateConcatenateNode(Op, ArgNode);
+            ArgNode = NextNode;
+            continue;
+
+        case 'X':
+        case 'x':
+        case 'o':
+
+            NextNode = ArgNode->Asl.Next;
+            ArgNode->Asl.Next = NULL;
+
+            /*
+             * Append an empty string if the first argument is
+             * not a string. This will implicitly conver the 2nd
+             * concat source to a string per the ACPI specification.
+             */
+            if (!Op->Asl.Child)
+            {
+                NewOp = TrAllocateNode (PARSEOP_STRING_LITERAL);
+                NewOp->Asl.Value.String = "";
+                NewOp->Asl.AmlOpcode = AML_STRING_OP;
+                NewOp->Asl.AcpiBtype = ACPI_BTYPE_STRING;
+                NewOp->Asl.LogicalLineNumber = Op->Asl.LogicalLineNumber;
+
+                OpcCreateConcatenateNode(Op, NewOp);
+            }
+
+            OpcCreateConcatenateNode(Op, ArgNode);
+            ArgNode = NextNode;
+            break;
+
+        default:
+
+            AslError(ASL_ERROR, ASL_MSG_INVALID_OPERAND, Op,
+                "Unrecognized format specifier");
+            continue;
+        }
+    }
+
+    /* Process any remaining string */
+
+    if (StringToProcess)
+    {
+        NewString = UtStringCacheCalloc (StringLength + 1);
+        strncpy (NewString, StartPosition, StringLength);
+
+        NewOp = TrAllocateNode (PARSEOP_STRING_LITERAL);
+        NewOp->Asl.Value.String = NewString;
+        NewOp->Asl.AcpiBtype = ACPI_BTYPE_STRING;
+        NewOp->Asl.AmlOpcode = AML_STRING_OP;
+        NewOp->Asl.LogicalLineNumber = Op->Asl.LogicalLineNumber;
+
+        OpcCreateConcatenateNode(Op, NewOp);
+    }
+
+    /*
+     * If we get here and there's no child node then Format
+     * was an empty string. Just make a no op.
+     */
+    if (!Op->Asl.Child)
+    {
+        Op->Asl.ParseOpcode = PARSEOP_NOOP;
+        AslError(ASL_WARNING, ASL_MSG_NULL_STRING, Op,
+            "Converted to NOOP");
+        return;
+    }
+
+     /* Check for erroneous extra arguments */
+
+    if (ArgNode &&
+        ArgNode->Asl.ParseOpcode != PARSEOP_DEFAULT_ARG)
+    {
+        AslError(ASL_WARNING, ASL_MSG_ARG_COUNT_HI, ArgNode,
+            "Extra arguments ignored");
+    }
+
+    /* Change Op to a Store */
+
+    Op->Asl.ParseOpcode = PARSEOP_STORE;
+    Op->Common.AmlOpcode = AML_STORE_OP;
+    Op->Asl.CompileFlags  = 0;
+
+    /* Disable further optimization */
+
+    Op->Asl.CompileFlags &= ~NODE_COMPILE_TIME_CONST;
+    UtSetParseOpName (Op);
+
+    /* Set Store destination */
+
+    Op->Asl.Child->Asl.Next = DestOp;
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    OpcCreateConcatenateNode
+ *
+ * PARAMETERS:  Op                  - Parse node
+ *              Node                - Parse node to be concatenated
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Make Node the child of Op. If child node already exists, then
+ *              concat child with Node and makes concat node the child of Op.
+ *
+ ******************************************************************************/
+
+static void
+OpcCreateConcatenateNode (
+    ACPI_PARSE_OBJECT       *Op,
+    ACPI_PARSE_OBJECT       *Node)
+{
+    ACPI_PARSE_OBJECT       *NewConcatOp;
+
+
+    if (!Op->Asl.Child)
+    {
+        Op->Asl.Child = Node;
+        Node->Asl.Parent = Op;
+        return;
+    }
+
+    NewConcatOp = TrAllocateNode (PARSEOP_CONCATENATE);
+    NewConcatOp->Asl.AmlOpcode = AML_CONCAT_OP;
+    NewConcatOp->Asl.AcpiBtype = 0x7;
+    NewConcatOp->Asl.LogicalLineNumber = Op->Asl.LogicalLineNumber;
+
+    /* First arg is child of Op*/
+
+    NewConcatOp->Asl.Child = Op->Asl.Child;
+    Op->Asl.Child->Asl.Parent = NewConcatOp;
+
+    /* Second arg is Node */
+
+    NewConcatOp->Asl.Child->Asl.Next = Node;
+    Node->Asl.Parent = NewConcatOp;
+
+    /* Third arg is Zero (not used) */
+
+    NewConcatOp->Asl.Child->Asl.Next->Asl.Next =
+        TrAllocateNode (PARSEOP_ZERO);
+    NewConcatOp->Asl.Child->Asl.Next->Asl.Next->Asl.Parent =
+        NewConcatOp;
+
+    Op->Asl.Child = NewConcatOp;
+    NewConcatOp->Asl.Parent = Op;
+}
diff --git a/usr/src/cmd/acpi/iasl/aslprune.c b/usr/src/cmd/acpi/iasl/aslprune.c
new file mode 100644
index 0000000000..11b3ad97ee
--- /dev/null
+++ b/usr/src/cmd/acpi/iasl/aslprune.c
@@ -0,0 +1,241 @@
+/******************************************************************************
+ *
+ * Module Name: aslprune - Parse tree prune utility
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2016, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include "aslcompiler.h"
+#include "aslcompiler.y.h"
+#include "acapps.h"
+
+#define _COMPONENT          ACPI_COMPILER
+        ACPI_MODULE_NAME    ("aslprune")
+
+
+/* Local prototypes */
+
+static ACPI_STATUS
+PrTreePruneWalk (
+    ACPI_PARSE_OBJECT       *Op,
+    UINT32                  Level,
+    void                    *Context);
+
+static void
+PrPrintObjectAtLevel (
+    UINT32                  Level,
+    const char              *ObjectName);
+
+
+/* Structure used for the pruning parse tree walk */
+
+typedef struct acpi_prune_info
+{
+    UINT32                  PruneLevel;
+    UINT16                  ParseOpcode;
+    UINT16                  Count;
+
+} ACPI_PRUNE_INFO;
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AslPruneParseTree
+ *
+ * PARAMETERS:  PruneDepth              - Number of levels to prune
+ *              Type                    - Prune type (Device, Method, etc.)
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Prune off one or more levels of the ASL parse tree
+ *
+ ******************************************************************************/
+
+void
+AslPruneParseTree (
+    UINT32                  PruneDepth,
+    UINT32                  Type)
+{
+    ACPI_PRUNE_INFO         PruneObj;
+
+
+    PruneObj.PruneLevel = PruneDepth;
+    PruneObj.Count = 0;
+
+    switch (Type)
+    {
+    case 0:
+        PruneObj.ParseOpcode = (UINT16) PARSEOP_DEVICE;
+        break;
+
+    case 1:
+        PruneObj.ParseOpcode = (UINT16) PARSEOP_METHOD;
+        break;
+
+    case 2:
+        PruneObj.ParseOpcode = (UINT16) PARSEOP_IF;
+        break;
+
+    default:
+        AcpiOsPrintf ("Unsupported type: %u\n", Type);
+        return;
+    }
+
+    AcpiOsPrintf ("Pruning parse tree, from depth %u\n",
+        PruneDepth);
+
+    AcpiOsPrintf ("\nRemoving Objects:\n");
+
+    TrWalkParseTree (Gbl_ParseTreeRoot, ASL_WALK_VISIT_DOWNWARD,
+        PrTreePruneWalk, NULL, ACPI_CAST_PTR (void, &PruneObj));
+
+    AcpiOsPrintf ("\n%u Total Objects Removed\n", PruneObj.Count);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    PrPrintObjectAtLevel
+ *
+ * PARAMETERS:  Level                   - Current nesting level
+ *              ObjectName              - ACPI name for the object
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Print object name with indent
+ *
+ ******************************************************************************/
+
+static void
+PrPrintObjectAtLevel (
+    UINT32                  Level,
+    const char              *ObjectName)
+{
+    UINT32                  i;
+
+
+    for (i = 0; i < Level; i++)
+    {
+        AcpiOsPrintf ("  ");
+    }
+
+    AcpiOsPrintf ("[%s] at Level [%u]\n", ObjectName, Level);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    PrTreePruneWalk
+ *
+ * PARAMETERS:  Parse tree walk callback
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Prune off one or more levels of the ASL parse tree
+ *
+ * Current objects that can be pruned are: Devices, Methods, and If/Else
+ * blocks.
+ *
+ ******************************************************************************/
+
+static ACPI_STATUS
+PrTreePruneWalk (
+    ACPI_PARSE_OBJECT       *Op,
+    UINT32                  Level,
+    void                    *Context)
+{
+    ACPI_PRUNE_INFO         *PruneObj = (ACPI_PRUNE_INFO *) Context;
+
+
+    /* We only care about objects below the Prune Level threshold */
+
+    if (Level <= PruneObj->PruneLevel)
+    {
+        return (AE_OK);
+    }
+
+    if ((Op->Asl.ParseOpcode != PruneObj->ParseOpcode) &&
+       !(Op->Asl.ParseOpcode == PARSEOP_ELSE &&
+             PruneObj->ParseOpcode == PARSEOP_IF))
+    {
+        return (AE_OK);
+    }
+
+    switch (Op->Asl.ParseOpcode)
+    {
+    case PARSEOP_METHOD:
+
+        AcpiOsPrintf ("Method");
+        PrPrintObjectAtLevel (Level, Op->Asl.Child->Asl.Value.Name);
+        Op->Asl.Child->Asl.Next->Asl.Next->Asl.Next->Asl.Next->Asl.Next->Asl.Next = NULL;
+        PruneObj->Count++;
+        break;
+
+    case PARSEOP_DEVICE:
+
+        AcpiOsPrintf ("Device");
+        PrPrintObjectAtLevel (Level, Op->Asl.Child->Asl.Value.Name);
+        Op->Asl.Child->Asl.Next = NULL;
+        PruneObj->Count++;
+        break;
+
+    case PARSEOP_IF:
+    case PARSEOP_ELSE:
+
+        if (Op->Asl.ParseOpcode == PARSEOP_ELSE)
+        {
+            PrPrintObjectAtLevel(Level, "Else");
+            Op->Asl.Child = NULL;
+        }
+        else
+        {
+            PrPrintObjectAtLevel(Level, "If");
+            Op->Asl.Child->Asl.Next = NULL;
+        }
+
+        PruneObj->Count++;
+        break;
+
+    default:
+
+        break;
+    }
+
+    return (AE_OK);
+}
diff --git a/usr/src/cmd/acpi/iasl/aslresource.c b/usr/src/cmd/acpi/iasl/aslresource.c
new file mode 100644
index 0000000000..9c023ffcc6
--- /dev/null
+++ b/usr/src/cmd/acpi/iasl/aslresource.c
@@ -0,0 +1,1093 @@
+/******************************************************************************
+ *
+ * Module Name: aslresource - Resource template/descriptor utilities
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2016, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include "aslcompiler.h"
+#include "aslcompiler.y.h"
+#include "amlcode.h"
+
+
+#define _COMPONENT          ACPI_COMPILER
+        ACPI_MODULE_NAME    ("aslresource")
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    RsSmallAddressCheck
+ *
+ * PARAMETERS:  Minimum             - Address Min value
+ *              Maximum             - Address Max value
+ *              Length              - Address range value
+ *              Alignment           - Address alignment value
+ *              MinOp               - Original Op for Address Min
+ *              MaxOp               - Original Op for Address Max
+ *              LengthOp            - Original Op for address range
+ *              AlignOp             - Original Op for address alignment. If
+ *                                    NULL, means "zero value for alignment is
+ *                                    OK, and means 64K alignment" (for
+ *                                    Memory24 descriptor)
+ *              Op                  - Parent Op for entire construct
+ *
+ * RETURN:      None. Adds error messages to error log if necessary
+ *
+ * DESCRIPTION: Perform common value checks for "small" address descriptors.
+ *              Currently:
+ *                  Io, Memory24, Memory32
+ *
+ ******************************************************************************/
+
+void
+RsSmallAddressCheck (
+    UINT8                   Type,
+    UINT32                  Minimum,
+    UINT32                  Maximum,
+    UINT32                  Length,
+    UINT32                  Alignment,
+    ACPI_PARSE_OBJECT       *MinOp,
+    ACPI_PARSE_OBJECT       *MaxOp,
+    ACPI_PARSE_OBJECT       *LengthOp,
+    ACPI_PARSE_OBJECT       *AlignOp,
+    ACPI_PARSE_OBJECT       *Op)
+{
+
+    if (Gbl_NoResourceChecking)
+    {
+        return;
+    }
+
+    /*
+     * Check for a so-called "null descriptor". These are descriptors that are
+     * created with most fields set to zero. The intent is that the descriptor
+     * will be updated/completed at runtime via a BufferField.
+     *
+     * If the descriptor does NOT have a resource tag, it cannot be referenced
+     * by a BufferField and we will flag this as an error. Conversely, if
+     * the descriptor has a resource tag, we will assume that a BufferField
+     * will be used to dynamically update it, so no error.
+     *
+     * A possible enhancement to this check would be to verify that in fact
+     * a BufferField is created using the resource tag, and perhaps even
+     * verify that a Store is performed to the BufferField.
+     *
+     * Note: for these descriptors, Alignment is allowed to be zero
+     */
+    if (!Minimum && !Maximum && !Length)
+    {
+        if (!Op->Asl.ExternalName)
+        {
+            /* No resource tag. Descriptor is fixed and is also illegal */
+
+            AslError (ASL_ERROR, ASL_MSG_NULL_DESCRIPTOR, Op, NULL);
+        }
+
+        return;
+    }
+
+    /*
+     * Range checks for Memory24 and Memory32.
+     * IO descriptor has different definition of min/max, don't check.
+     */
+    if (Type != ACPI_RESOURCE_NAME_IO)
+    {
+        /* Basic checks on Min/Max/Length */
+
+        if (Minimum > Maximum)
+        {
+            AslError (ASL_ERROR, ASL_MSG_INVALID_MIN_MAX, MinOp, NULL);
+        }
+        else if (Length > (Maximum - Minimum + 1))
+        {
+            AslError (ASL_ERROR, ASL_MSG_INVALID_LENGTH, LengthOp, NULL);
+        }
+
+        /* Special case for Memory24, min/max values are compressed */
+
+        if (Type == ACPI_RESOURCE_NAME_MEMORY24)
+        {
+            if (!Alignment) /* Alignment==0 means 64K alignment */
+            {
+                Alignment = ACPI_UINT16_MAX + 1;
+            }
+
+            Minimum <<= 8;
+            Maximum <<= 8;
+        }
+    }
+
+    /* Alignment of zero is not in ACPI spec, but is used to mean byte acc */
+
+    if (!Alignment)
+    {
+        Alignment = 1;
+    }
+
+    /* Addresses must be an exact multiple of the alignment value */
+
+    if (Minimum % Alignment)
+    {
+        AslError (ASL_ERROR, ASL_MSG_ALIGNMENT, MinOp, NULL);
+    }
+    if (Maximum % Alignment)
+    {
+        AslError (ASL_ERROR, ASL_MSG_ALIGNMENT, MaxOp, NULL);
+    }
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    RsLargeAddressCheck
+ *
+ * PARAMETERS:  Minimum             - Address Min value
+ *              Maximum             - Address Max value
+ *              Length              - Address range value
+ *              Granularity         - Address granularity value
+ *              Flags               - General flags for address descriptors:
+ *                                    _MIF, _MAF, _DEC
+ *              MinOp               - Original Op for Address Min
+ *              MaxOp               - Original Op for Address Max
+ *              LengthOp            - Original Op for address range
+ *              GranOp              - Original Op for address granularity
+ *              Op                  - Parent Op for entire construct
+ *
+ * RETURN:      None. Adds error messages to error log if necessary
+ *
+ * DESCRIPTION: Perform common value checks for "large" address descriptors.
+ *              Currently:
+ *                  WordIo,     WordBusNumber,  WordSpace
+ *                  DWordIo,    DWordMemory,    DWordSpace
+ *                  QWordIo,    QWordMemory,    QWordSpace
+ *                  ExtendedIo, ExtendedMemory, ExtendedSpace
+ *
+ * _MIF flag set means that the minimum address is fixed and is not relocatable
+ * _MAF flag set means that the maximum address is fixed and is not relocatable
+ * Length of zero means that the record size is variable
+ *
+ * This function implements the LEN/MIF/MAF/MIN/MAX/GRA rules within Table 6-40
+ * of the ACPI 4.0a specification. Added 04/2010.
+ *
+ ******************************************************************************/
+
+void
+RsLargeAddressCheck (
+    UINT64                  Minimum,
+    UINT64                  Maximum,
+    UINT64                  Length,
+    UINT64                  Granularity,
+    UINT8                   Flags,
+    ACPI_PARSE_OBJECT       *MinOp,
+    ACPI_PARSE_OBJECT       *MaxOp,
+    ACPI_PARSE_OBJECT       *LengthOp,
+    ACPI_PARSE_OBJECT       *GranOp,
+    ACPI_PARSE_OBJECT       *Op)
+{
+
+    if (Gbl_NoResourceChecking)
+    {
+        return;
+    }
+
+    /*
+     * Check for a so-called "null descriptor". These are descriptors that are
+     * created with most fields set to zero. The intent is that the descriptor
+     * will be updated/completed at runtime via a BufferField.
+     *
+     * If the descriptor does NOT have a resource tag, it cannot be referenced
+     * by a BufferField and we will flag this as an error. Conversely, if
+     * the descriptor has a resource tag, we will assume that a BufferField
+     * will be used to dynamically update it, so no error.
+     *
+     * A possible enhancement to this check would be to verify that in fact
+     * a BufferField is created using the resource tag, and perhaps even
+     * verify that a Store is performed to the BufferField.
+     */
+    if (!Minimum && !Maximum && !Length && !Granularity)
+    {
+        if (!Op->Asl.ExternalName)
+        {
+            /* No resource tag. Descriptor is fixed and is also illegal */
+
+            AslError (ASL_ERROR, ASL_MSG_NULL_DESCRIPTOR, Op, NULL);
+        }
+
+        return;
+    }
+
+    /* Basic checks on Min/Max/Length */
+
+    if (Minimum > Maximum)
+    {
+        AslError (ASL_ERROR, ASL_MSG_INVALID_MIN_MAX, MinOp, NULL);
+        return;
+    }
+    else if (Length > (Maximum - Minimum + 1))
+    {
+        AslError (ASL_ERROR, ASL_MSG_INVALID_LENGTH, LengthOp, NULL);
+        return;
+    }
+
+    /* If specified (non-zero), ensure granularity is a power-of-two minus one */
+
+    if (Granularity)
+    {
+        if ((Granularity + 1) &
+             Granularity)
+        {
+            AslError (ASL_ERROR, ASL_MSG_INVALID_GRANULARITY, GranOp, NULL);
+            return;
+        }
+    }
+
+    /*
+     * Check the various combinations of Length, MinFixed, and MaxFixed
+     */
+    if (Length)
+    {
+        /* Fixed non-zero length */
+
+        switch (Flags & (ACPI_RESOURCE_FLAG_MIF | ACPI_RESOURCE_FLAG_MAF))
+        {
+        case 0:
+            /*
+             * Fixed length, variable locations (both _MIN and _MAX).
+             * Length must be a multiple of granularity
+             */
+            if (Granularity & Length)
+            {
+                AslError (ASL_ERROR, ASL_MSG_ALIGNMENT, LengthOp, NULL);
+            }
+            break;
+
+        case (ACPI_RESOURCE_FLAG_MIF | ACPI_RESOURCE_FLAG_MAF):
+
+            /* Fixed length, fixed location. Granularity must be zero */
+
+            if (Granularity != 0)
+            {
+                AslError (ASL_ERROR, ASL_MSG_INVALID_GRAN_FIXED, GranOp, NULL);
+            }
+
+            /* Length must be exactly the size of the min/max window */
+
+            if (Length != (Maximum - Minimum + 1))
+            {
+                AslError (ASL_ERROR, ASL_MSG_INVALID_LENGTH_FIXED, LengthOp, NULL);
+            }
+            break;
+
+        /* All other combinations are invalid */
+
+        case ACPI_RESOURCE_FLAG_MIF:
+        case ACPI_RESOURCE_FLAG_MAF:
+        default:
+
+            AslError (ASL_ERROR, ASL_MSG_INVALID_ADDR_FLAGS, LengthOp, NULL);
+        }
+    }
+    else
+    {
+        /* Variable length (length==0) */
+
+        switch (Flags & (ACPI_RESOURCE_FLAG_MIF | ACPI_RESOURCE_FLAG_MAF))
+        {
+        case 0:
+            /*
+             * Both _MIN and _MAX are variable.
+             * No additional requirements, just exit
+             */
+            break;
+
+        case ACPI_RESOURCE_FLAG_MIF:
+
+            /* _MIN is fixed. _MIN must be multiple of _GRA */
+
+            /*
+             * The granularity is defined by the ACPI specification to be a
+             * power-of-two minus one, therefore the granularity is a
+             * bitmask which can be used to easily validate the addresses.
+             */
+            if (Granularity & Minimum)
+            {
+                AslError (ASL_ERROR, ASL_MSG_ALIGNMENT, MinOp, NULL);
+            }
+            break;
+
+        case ACPI_RESOURCE_FLAG_MAF:
+
+            /* _MAX is fixed. (_MAX + 1) must be multiple of _GRA */
+
+            if (Granularity & (Maximum + 1))
+            {
+                AslError (ASL_ERROR, ASL_MSG_ALIGNMENT, MaxOp, "-1");
+            }
+            break;
+
+        /* Both MIF/MAF set is invalid if length is zero */
+
+        case (ACPI_RESOURCE_FLAG_MIF | ACPI_RESOURCE_FLAG_MAF):
+        default:
+
+            AslError (ASL_ERROR, ASL_MSG_INVALID_ADDR_FLAGS, LengthOp, NULL);
+        }
+    }
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    RsGetStringDataLength
+ *
+ * PARAMETERS:  InitializerOp     - Start of a subtree of init nodes
+ *
+ * RETURN:      Valid string length if a string node is found (otherwise 0)
+ *
+ * DESCRIPTION: In a list of peer nodes, find the first one that contains a
+ *              string and return the length of the string.
+ *
+ ******************************************************************************/
+
+UINT16
+RsGetStringDataLength (
+    ACPI_PARSE_OBJECT       *InitializerOp)
+{
+
+    while (InitializerOp)
+    {
+        if (InitializerOp->Asl.ParseOpcode == PARSEOP_STRING_LITERAL)
+        {
+            return ((UINT16) (strlen (InitializerOp->Asl.Value.String) + 1));
+        }
+
+        InitializerOp = ASL_GET_PEER_NODE (InitializerOp);
+    }
+
+    return (0);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    RsAllocateResourceNode
+ *
+ * PARAMETERS:  Size        - Size of node in bytes
+ *
+ * RETURN:      The allocated node - aborts on allocation failure
+ *
+ * DESCRIPTION: Allocate a resource description node and the resource
+ *              descriptor itself (the nodes are used to link descriptors).
+ *
+ ******************************************************************************/
+
+ASL_RESOURCE_NODE *
+RsAllocateResourceNode (
+    UINT32                  Size)
+{
+    ASL_RESOURCE_NODE       *Rnode;
+
+
+    /* Allocate the node */
+
+    Rnode = UtLocalCalloc (sizeof (ASL_RESOURCE_NODE));
+
+    /* Allocate the resource descriptor itself */
+
+    Rnode->Buffer = UtLocalCalloc (Size);
+    Rnode->BufferLength = Size;
+    return (Rnode);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    RsCreateResourceField
+ *
+ * PARAMETERS:  Op              - Resource field node
+ *              Name            - Name of the field (Used only to reference
+ *                                the field in the ASL, not in the AML)
+ *              ByteOffset      - Offset from the field start
+ *              BitOffset       - Additional bit offset
+ *              BitLength       - Number of bits in the field
+ *
+ * RETURN:      None, sets fields within the input node
+ *
+ * DESCRIPTION: Utility function to generate a named bit field within a
+ *              resource descriptor. Mark a node as 1) a field in a resource
+ *              descriptor, and 2) set the value to be a BIT offset
+ *
+ ******************************************************************************/
+
+void
+RsCreateResourceField (
+    ACPI_PARSE_OBJECT       *Op,
+    char                    *Name,
+    UINT32                  ByteOffset,
+    UINT32                  BitOffset,
+    UINT32                  BitLength)
+{
+
+    Op->Asl.ExternalName = Name;
+    Op->Asl.CompileFlags |= NODE_IS_RESOURCE_FIELD;
+
+    Op->Asl.Value.Tag.BitOffset = (ByteOffset * 8) + BitOffset;
+    Op->Asl.Value.Tag.BitLength = BitLength;
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    RsSetFlagBits
+ *
+ * PARAMETERS:  *Flags          - Pointer to the flag byte
+ *              Op              - Flag initialization node
+ *              Position        - Bit position within the flag byte
+ *              Default         - Used if the node is DEFAULT.
+ *
+ * RETURN:      Sets bits within the *Flags output byte.
+ *
+ * DESCRIPTION: Set a bit in a cumulative flags word from an initialization
+ *              node. Will use a default value if the node is DEFAULT, meaning
+ *              that no value was specified in the ASL. Used to merge multiple
+ *              keywords into a single flags byte.
+ *
+ ******************************************************************************/
+
+void
+RsSetFlagBits (
+    UINT8                   *Flags,
+    ACPI_PARSE_OBJECT       *Op,
+    UINT8                   Position,
+    UINT8                   DefaultBit)
+{
+
+    if (Op->Asl.ParseOpcode == PARSEOP_DEFAULT_ARG)
+    {
+        /* Use the default bit */
+
+        *Flags |= (DefaultBit << Position);
+    }
+    else
+    {
+        /* Use the bit specified in the initialization node */
+
+        *Flags |= (((UINT8) Op->Asl.Value.Integer) << Position);
+    }
+}
+
+
+void
+RsSetFlagBits16 (
+    UINT16                  *Flags,
+    ACPI_PARSE_OBJECT       *Op,
+    UINT8                   Position,
+    UINT8                   DefaultBit)
+{
+
+    if (Op->Asl.ParseOpcode == PARSEOP_DEFAULT_ARG)
+    {
+        /* Use the default bit */
+
+        *Flags |= (DefaultBit << Position);
+    }
+    else
+    {
+        /* Use the bit specified in the initialization node */
+
+        *Flags |= (((UINT16) Op->Asl.Value.Integer) << Position);
+    }
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    RsCompleteNodeAndGetNext
+ *
+ * PARAMETERS:  Op            - Resource node to be completed
+ *
+ * RETURN:      The next peer to the input node.
+ *
+ * DESCRIPTION: Mark the current node completed and return the next peer.
+ *              The node ParseOpcode is set to DEFAULT_ARG, meaning that
+ *              this node is to be ignored from now on.
+ *
+ ******************************************************************************/
+
+ACPI_PARSE_OBJECT *
+RsCompleteNodeAndGetNext (
+    ACPI_PARSE_OBJECT       *Op)
+{
+
+    /* Mark this node unused */
+
+    Op->Asl.ParseOpcode = PARSEOP_DEFAULT_ARG;
+
+    /* Move on to the next peer node in the initializer list */
+
+    return (ASL_GET_PEER_NODE (Op));
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    RsCheckListForDuplicates
+ *
+ * PARAMETERS:  Op                  - First op in the initializer list
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Check an initializer list for duplicate values. Emits an error
+ *              if any duplicates are found.
+ *
+ ******************************************************************************/
+
+void
+RsCheckListForDuplicates (
+    ACPI_PARSE_OBJECT       *Op)
+{
+    ACPI_PARSE_OBJECT       *NextValueOp = Op;
+    ACPI_PARSE_OBJECT       *NextOp;
+    UINT32                  Value;
+
+
+    if (!Op)
+    {
+        return;
+    }
+
+    /* Search list once for each value in the list */
+
+    while (NextValueOp)
+    {
+        Value = (UINT32) NextValueOp->Asl.Value.Integer;
+
+        /* Compare this value to all remaining values in the list */
+
+        NextOp = ASL_GET_PEER_NODE (NextValueOp);
+        while (NextOp)
+        {
+            if (NextOp->Asl.ParseOpcode != PARSEOP_DEFAULT_ARG)
+            {
+                /* Compare values */
+
+                if (Value == (UINT32) NextOp->Asl.Value.Integer)
+                {
+                    /* Emit error only once per duplicate node */
+
+                    if (!(NextOp->Asl.CompileFlags & NODE_IS_DUPLICATE))
+                    {
+                        NextOp->Asl.CompileFlags |= NODE_IS_DUPLICATE;
+                        AslError (ASL_ERROR, ASL_MSG_DUPLICATE_ITEM,
+                            NextOp, NULL);
+                    }
+                }
+            }
+
+            NextOp = ASL_GET_PEER_NODE (NextOp);
+        }
+
+        NextValueOp = ASL_GET_PEER_NODE (NextValueOp);
+    }
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    RsDoOneResourceDescriptor
+ *
+ * PARAMETERS:  DescriptorTypeOp    - Parent parse node of the descriptor
+ *              CurrentByteOffset   - Offset in the resource descriptor
+ *                                    buffer.
+ *
+ * RETURN:      A valid resource node for the descriptor
+ *
+ * DESCRIPTION: Dispatches the processing of one resource descriptor
+ *
+ ******************************************************************************/
+
+ASL_RESOURCE_NODE *
+RsDoOneResourceDescriptor (
+    ASL_RESOURCE_INFO       *Info,
+    UINT8                   *State)
+{
+    ASL_RESOURCE_NODE       *Rnode = NULL;
+
+
+    /* Construct the resource */
+
+    switch (Info->DescriptorTypeOp->Asl.ParseOpcode)
+    {
+    case PARSEOP_DMA:
+
+        Rnode = RsDoDmaDescriptor (Info);
+        break;
+
+    case PARSEOP_FIXEDDMA:
+
+        Rnode = RsDoFixedDmaDescriptor (Info);
+        break;
+
+    case PARSEOP_DWORDIO:
+
+        Rnode = RsDoDwordIoDescriptor (Info);
+        break;
+
+    case PARSEOP_DWORDMEMORY:
+
+        Rnode = RsDoDwordMemoryDescriptor (Info);
+        break;
+
+    case PARSEOP_DWORDSPACE:
+
+        Rnode = RsDoDwordSpaceDescriptor (Info);
+        break;
+
+    case PARSEOP_ENDDEPENDENTFN:
+
+        switch (*State)
+        {
+        case ACPI_RSTATE_NORMAL:
+
+            AslError (ASL_ERROR, ASL_MSG_MISSING_STARTDEPENDENT,
+                Info->DescriptorTypeOp, NULL);
+            break;
+
+        case ACPI_RSTATE_START_DEPENDENT:
+
+            AslError (ASL_ERROR, ASL_MSG_DEPENDENT_NESTING,
+                Info->DescriptorTypeOp, NULL);
+            break;
+
+        case ACPI_RSTATE_DEPENDENT_LIST:
+        default:
+
+            break;
+        }
+
+        *State = ACPI_RSTATE_NORMAL;
+        Rnode = RsDoEndDependentDescriptor (Info);
+        break;
+
+    case PARSEOP_ENDTAG:
+
+        Rnode = RsDoEndTagDescriptor (Info);
+        break;
+
+    case PARSEOP_EXTENDEDIO:
+
+        Rnode = RsDoExtendedIoDescriptor (Info);
+        break;
+
+    case PARSEOP_EXTENDEDMEMORY:
+
+        Rnode = RsDoExtendedMemoryDescriptor (Info);
+        break;
+
+    case PARSEOP_EXTENDEDSPACE:
+
+        Rnode = RsDoExtendedSpaceDescriptor (Info);
+        break;
+
+    case PARSEOP_FIXEDIO:
+
+        Rnode = RsDoFixedIoDescriptor (Info);
+        break;
+
+    case PARSEOP_INTERRUPT:
+
+        Rnode = RsDoInterruptDescriptor (Info);
+        break;
+
+    case PARSEOP_IO:
+
+        Rnode = RsDoIoDescriptor (Info);
+        break;
+
+    case PARSEOP_IRQ:
+
+        Rnode = RsDoIrqDescriptor (Info);
+        break;
+
+    case PARSEOP_IRQNOFLAGS:
+
+        Rnode = RsDoIrqNoFlagsDescriptor (Info);
+        break;
+
+    case PARSEOP_MEMORY24:
+
+        Rnode = RsDoMemory24Descriptor (Info);
+        break;
+
+    case PARSEOP_MEMORY32:
+
+        Rnode = RsDoMemory32Descriptor (Info);
+        break;
+
+    case PARSEOP_MEMORY32FIXED:
+
+        Rnode = RsDoMemory32FixedDescriptor (Info);
+        break;
+
+    case PARSEOP_QWORDIO:
+
+        Rnode = RsDoQwordIoDescriptor (Info);
+        break;
+
+    case PARSEOP_QWORDMEMORY:
+
+        Rnode = RsDoQwordMemoryDescriptor (Info);
+        break;
+
+    case PARSEOP_QWORDSPACE:
+
+        Rnode = RsDoQwordSpaceDescriptor (Info);
+        break;
+
+    case PARSEOP_REGISTER:
+
+        Rnode = RsDoGeneralRegisterDescriptor (Info);
+        break;
+
+    case PARSEOP_STARTDEPENDENTFN:
+
+        switch (*State)
+        {
+        case ACPI_RSTATE_START_DEPENDENT:
+
+            AslError (ASL_ERROR, ASL_MSG_DEPENDENT_NESTING,
+                Info->DescriptorTypeOp, NULL);
+            break;
+
+        case ACPI_RSTATE_NORMAL:
+        case ACPI_RSTATE_DEPENDENT_LIST:
+        default:
+
+            break;
+        }
+
+        *State = ACPI_RSTATE_START_DEPENDENT;
+        Rnode = RsDoStartDependentDescriptor (Info);
+        *State = ACPI_RSTATE_DEPENDENT_LIST;
+        break;
+
+    case PARSEOP_STARTDEPENDENTFN_NOPRI:
+
+        switch (*State)
+        {
+        case ACPI_RSTATE_START_DEPENDENT:
+
+            AslError (ASL_ERROR, ASL_MSG_DEPENDENT_NESTING,
+                Info->DescriptorTypeOp, NULL);
+            break;
+
+        case ACPI_RSTATE_NORMAL:
+        case ACPI_RSTATE_DEPENDENT_LIST:
+        default:
+
+            break;
+        }
+
+        *State = ACPI_RSTATE_START_DEPENDENT;
+        Rnode = RsDoStartDependentNoPriDescriptor (Info);
+        *State = ACPI_RSTATE_DEPENDENT_LIST;
+        break;
+
+    case PARSEOP_VENDORLONG:
+
+        Rnode = RsDoVendorLargeDescriptor (Info);
+        break;
+
+    case PARSEOP_VENDORSHORT:
+
+        Rnode = RsDoVendorSmallDescriptor (Info);
+        break;
+
+    case PARSEOP_WORDBUSNUMBER:
+
+        Rnode = RsDoWordBusNumberDescriptor (Info);
+        break;
+
+    case PARSEOP_WORDIO:
+
+        Rnode = RsDoWordIoDescriptor (Info);
+        break;
+
+    case PARSEOP_WORDSPACE:
+
+        Rnode = RsDoWordSpaceDescriptor (Info);
+        break;
+
+    case PARSEOP_GPIO_INT:
+
+        Rnode = RsDoGpioIntDescriptor (Info);
+        break;
+
+    case PARSEOP_GPIO_IO:
+
+        Rnode = RsDoGpioIoDescriptor (Info);
+        break;
+
+    case PARSEOP_I2C_SERIALBUS:
+    case PARSEOP_I2C_SERIALBUS_V2:
+
+        Rnode = RsDoI2cSerialBusDescriptor (Info);
+        break;
+
+    case PARSEOP_SPI_SERIALBUS:
+    case PARSEOP_SPI_SERIALBUS_V2:
+
+        Rnode = RsDoSpiSerialBusDescriptor (Info);
+        break;
+
+    case PARSEOP_UART_SERIALBUS:
+    case PARSEOP_UART_SERIALBUS_V2:
+
+        Rnode = RsDoUartSerialBusDescriptor (Info);
+        break;
+
+    case PARSEOP_DEFAULT_ARG:
+
+        /* Just ignore any of these, they are used as fillers/placeholders */
+        break;
+
+    default:
+
+        printf ("Unknown resource descriptor type [%s]\n",
+            Info->DescriptorTypeOp->Asl.ParseOpName);
+        break;
+    }
+
+    /*
+     * Mark original node as unused, but head of a resource descriptor.
+     * This allows the resource to be installed in the namespace so that
+     * references to the descriptor can be resolved.
+     */
+    Info->DescriptorTypeOp->Asl.ParseOpcode = PARSEOP_DEFAULT_ARG;
+    Info->DescriptorTypeOp->Asl.CompileFlags = NODE_IS_RESOURCE_DESC;
+    Info->DescriptorTypeOp->Asl.Value.Integer = Info->CurrentByteOffset;
+
+    if (Rnode)
+    {
+        Info->DescriptorTypeOp->Asl.FinalAmlLength = Rnode->BufferLength;
+        Info->DescriptorTypeOp->Asl.Extra =
+            ((AML_RESOURCE *) Rnode->Buffer)->DescriptorType;
+    }
+
+    return (Rnode);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    RsLinkDescriptorChain
+ *
+ * PARAMETERS:  PreviousRnode       - Pointer to the node that will be previous
+ *                                    to the linked node,  At exit, set to the
+ *                                    last node in the new chain.
+ *              Rnode               - Resource node to link into the list
+ *
+ * RETURN:      Cumulative buffer byte offset of the new segment of chain
+ *
+ * DESCRIPTION: Link a descriptor chain at the end of an existing chain.
+ *
+ ******************************************************************************/
+
+UINT32
+RsLinkDescriptorChain (
+    ASL_RESOURCE_NODE       **PreviousRnode,
+    ASL_RESOURCE_NODE       *Rnode)
+{
+    ASL_RESOURCE_NODE       *LastRnode;
+    UINT32                  CurrentByteOffset;
+
+
+    /* Anything to do? */
+
+    if (!Rnode)
+    {
+        return (0);
+    }
+
+    /* Point the previous node to the new node */
+
+    (*PreviousRnode)->Next = Rnode;
+    CurrentByteOffset = Rnode->BufferLength;
+
+    /* Walk to the end of the chain headed by Rnode */
+
+    LastRnode = Rnode;
+    while (LastRnode->Next)
+    {
+        LastRnode = LastRnode->Next;
+        CurrentByteOffset += LastRnode->BufferLength;
+    }
+
+    /* Previous node becomes the last node in the chain */
+
+    *PreviousRnode = LastRnode;
+    return (CurrentByteOffset);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    RsDoResourceTemplate
+ *
+ * PARAMETERS:  Op        - Parent of a resource template list
+ *
+ * RETURN:      None. Sets input node to point to a list of AML code
+ *
+ * DESCRIPTION: Merge a list of resource descriptors into a single AML buffer,
+ *              in preparation for output to the AML output file.
+ *
+ ******************************************************************************/
+
+void
+RsDoResourceTemplate (
+    ACPI_PARSE_OBJECT       *Op)
+{
+    ACPI_PARSE_OBJECT       *BufferLengthOp;
+    ACPI_PARSE_OBJECT       *BufferOp;
+    ACPI_PARSE_OBJECT       *DescriptorTypeOp;
+    ACPI_PARSE_OBJECT       *LastOp = NULL;
+    UINT32                  CurrentByteOffset = 0;
+    ASL_RESOURCE_NODE       HeadRnode;
+    ASL_RESOURCE_NODE       *PreviousRnode;
+    ASL_RESOURCE_NODE       *Rnode;
+    ASL_RESOURCE_INFO       Info;
+    UINT8                   State;
+
+
+    /* Mark parent as containing a resource template */
+
+    if (Op->Asl.Parent)
+    {
+        Op->Asl.Parent->Asl.CompileFlags |= NODE_IS_RESOURCE_DESC;
+    }
+
+    /* ResourceTemplate Opcode is first (Op) */
+    /* Buffer Length node is first child */
+
+    BufferLengthOp = ASL_GET_CHILD_NODE (Op);
+
+    /* Buffer Op is first peer */
+
+    BufferOp = ASL_GET_PEER_NODE (BufferLengthOp);
+
+    /* First Descriptor type is next */
+
+    DescriptorTypeOp = ASL_GET_PEER_NODE (BufferOp);
+
+    /*
+     * Process all resource descriptors in the list
+     * Note: It is assumed that the EndTag node has been automatically
+     * inserted at the end of the template by the parser.
+     */
+    State = ACPI_RSTATE_NORMAL;
+    PreviousRnode = &HeadRnode;
+    while (DescriptorTypeOp)
+    {
+        /* Save information for optional mapfile */
+
+        if (Op->Asl.Parent->Asl.ParseOpcode == PARSEOP_CONNECTION)
+        {
+            Info.MappingOp = Op->Asl.Parent;
+        }
+        else
+        {
+            Info.MappingOp = DescriptorTypeOp;
+        }
+
+        Info.DescriptorTypeOp = DescriptorTypeOp;
+        Info.CurrentByteOffset = CurrentByteOffset;
+
+        DescriptorTypeOp->Asl.CompileFlags |= NODE_IS_RESOURCE_DESC;
+        Rnode = RsDoOneResourceDescriptor (&Info, &State);
+
+        /*
+         * Update current byte offset to indicate the number of bytes from the
+         * start of the buffer. Buffer can include multiple descriptors, we
+         * must keep track of the offset of not only each descriptor, but each
+         * element (field) within each descriptor as well.
+         */
+        CurrentByteOffset += RsLinkDescriptorChain (&PreviousRnode, Rnode);
+
+        /* Get the next descriptor in the list */
+
+        LastOp = DescriptorTypeOp;
+        DescriptorTypeOp = ASL_GET_PEER_NODE (DescriptorTypeOp);
+    }
+
+    if (State == ACPI_RSTATE_DEPENDENT_LIST)
+    {
+        if (LastOp)
+        {
+            LastOp = LastOp->Asl.Parent;
+        }
+        AslError (ASL_ERROR, ASL_MSG_MISSING_ENDDEPENDENT, LastOp, NULL);
+    }
+
+    /*
+     * Transform the nodes into the following
+     *
+     * Op           -> AML_BUFFER_OP
+     * First Child  -> BufferLength
+     * Second Child -> Descriptor Buffer (raw byte data)
+     */
+    Op->Asl.ParseOpcode               = PARSEOP_BUFFER;
+    Op->Asl.AmlOpcode                 = AML_BUFFER_OP;
+    Op->Asl.CompileFlags              = NODE_AML_PACKAGE | NODE_IS_RESOURCE_DESC;
+    UtSetParseOpName (Op);
+
+    BufferLengthOp->Asl.ParseOpcode   = PARSEOP_INTEGER;
+    BufferLengthOp->Asl.Value.Integer = CurrentByteOffset;
+    (void) OpcSetOptimalIntegerSize (BufferLengthOp);
+    UtSetParseOpName (BufferLengthOp);
+
+    BufferOp->Asl.ParseOpcode         = PARSEOP_RAW_DATA;
+    BufferOp->Asl.AmlOpcode           = AML_RAW_DATA_CHAIN;
+    BufferOp->Asl.AmlOpcodeLength     = 0;
+    BufferOp->Asl.AmlLength           = CurrentByteOffset;
+    BufferOp->Asl.Value.Buffer        = (UINT8 *) HeadRnode.Next;
+    BufferOp->Asl.CompileFlags       |= NODE_IS_RESOURCE_DATA;
+    UtSetParseOpName (BufferOp);
+
+    return;
+}
diff --git a/usr/src/cmd/acpi/iasl/aslresources.y b/usr/src/cmd/acpi/iasl/aslresources.y
new file mode 100644
index 0000000000..074536bb0d
--- /dev/null
+++ b/usr/src/cmd/acpi/iasl/aslresources.y
@@ -0,0 +1,1248 @@
+NoEcho('
+/******************************************************************************
+ *
+ * Module Name: aslresources.y - Bison/Yacc production rules for resources
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2016, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+')
+
+/*******************************************************************************
+ *
+ * ASL Parameter Keyword Terms
+ *
+ ******************************************************************************/
+
+AccessAttribKeyword
+    : PARSEOP_ACCESSATTRIB_BLOCK            {$$ = TrCreateLeafNode (PARSEOP_ACCESSATTRIB_BLOCK);}
+    | PARSEOP_ACCESSATTRIB_BLOCK_CALL       {$$ = TrCreateLeafNode (PARSEOP_ACCESSATTRIB_BLOCK_CALL);}
+    | PARSEOP_ACCESSATTRIB_BYTE             {$$ = TrCreateLeafNode (PARSEOP_ACCESSATTRIB_BYTE);}
+    | PARSEOP_ACCESSATTRIB_QUICK            {$$ = TrCreateLeafNode (PARSEOP_ACCESSATTRIB_QUICK );}
+    | PARSEOP_ACCESSATTRIB_SND_RCV          {$$ = TrCreateLeafNode (PARSEOP_ACCESSATTRIB_SND_RCV);}
+    | PARSEOP_ACCESSATTRIB_WORD             {$$ = TrCreateLeafNode (PARSEOP_ACCESSATTRIB_WORD);}
+    | PARSEOP_ACCESSATTRIB_WORD_CALL        {$$ = TrCreateLeafNode (PARSEOP_ACCESSATTRIB_WORD_CALL);}
+    | PARSEOP_ACCESSATTRIB_MULTIBYTE '('    {$<n>$ = TrCreateLeafNode (PARSEOP_ACCESSATTRIB_MULTIBYTE);}
+        ByteConst
+        ')'                                 {$$ = TrLinkChildren ($<n>3,1,$4);}
+    | PARSEOP_ACCESSATTRIB_RAW_BYTES '('    {$<n>$ = TrCreateLeafNode (PARSEOP_ACCESSATTRIB_RAW_BYTES);}
+        ByteConst
+        ')'                                 {$$ = TrLinkChildren ($<n>3,1,$4);}
+    | PARSEOP_ACCESSATTRIB_RAW_PROCESS '('  {$<n>$ = TrCreateLeafNode (PARSEOP_ACCESSATTRIB_RAW_PROCESS);}
+        ByteConst
+        ')'                                 {$$ = TrLinkChildren ($<n>3,1,$4);}
+    ;
+
+AccessTypeKeyword
+    : PARSEOP_ACCESSTYPE_ANY                {$$ = TrCreateLeafNode (PARSEOP_ACCESSTYPE_ANY);}
+    | PARSEOP_ACCESSTYPE_BYTE               {$$ = TrCreateLeafNode (PARSEOP_ACCESSTYPE_BYTE);}
+    | PARSEOP_ACCESSTYPE_WORD               {$$ = TrCreateLeafNode (PARSEOP_ACCESSTYPE_WORD);}
+    | PARSEOP_ACCESSTYPE_DWORD              {$$ = TrCreateLeafNode (PARSEOP_ACCESSTYPE_DWORD);}
+    | PARSEOP_ACCESSTYPE_QWORD              {$$ = TrCreateLeafNode (PARSEOP_ACCESSTYPE_QWORD);}
+    | PARSEOP_ACCESSTYPE_BUF                {$$ = TrCreateLeafNode (PARSEOP_ACCESSTYPE_BUF);}
+    ;
+
+AddressingModeKeyword
+    : PARSEOP_ADDRESSINGMODE_7BIT           {$$ = TrCreateLeafNode (PARSEOP_ADDRESSINGMODE_7BIT);}
+    | PARSEOP_ADDRESSINGMODE_10BIT          {$$ = TrCreateLeafNode (PARSEOP_ADDRESSINGMODE_10BIT);}
+    ;
+
+AddressKeyword
+    : PARSEOP_ADDRESSTYPE_MEMORY            {$$ = TrCreateLeafNode (PARSEOP_ADDRESSTYPE_MEMORY);}
+    | PARSEOP_ADDRESSTYPE_RESERVED          {$$ = TrCreateLeafNode (PARSEOP_ADDRESSTYPE_RESERVED);}
+    | PARSEOP_ADDRESSTYPE_NVS               {$$ = TrCreateLeafNode (PARSEOP_ADDRESSTYPE_NVS);}
+    | PARSEOP_ADDRESSTYPE_ACPI              {$$ = TrCreateLeafNode (PARSEOP_ADDRESSTYPE_ACPI);}
+    ;
+
+AddressSpaceKeyword
+    : ByteConst                             {$$ = UtCheckIntegerRange ($1, 0x0A, 0xFF);}
+    | RegionSpaceKeyword                    {}
+    ;
+
+BitsPerByteKeyword
+    : PARSEOP_BITSPERBYTE_FIVE              {$$ = TrCreateLeafNode (PARSEOP_BITSPERBYTE_FIVE);}
+    | PARSEOP_BITSPERBYTE_SIX               {$$ = TrCreateLeafNode (PARSEOP_BITSPERBYTE_SIX);}
+    | PARSEOP_BITSPERBYTE_SEVEN             {$$ = TrCreateLeafNode (PARSEOP_BITSPERBYTE_SEVEN);}
+    | PARSEOP_BITSPERBYTE_EIGHT             {$$ = TrCreateLeafNode (PARSEOP_BITSPERBYTE_EIGHT);}
+    | PARSEOP_BITSPERBYTE_NINE              {$$ = TrCreateLeafNode (PARSEOP_BITSPERBYTE_NINE);}
+    ;
+
+ClockPhaseKeyword
+    : PARSEOP_CLOCKPHASE_FIRST              {$$ = TrCreateLeafNode (PARSEOP_CLOCKPHASE_FIRST);}
+    | PARSEOP_CLOCKPHASE_SECOND             {$$ = TrCreateLeafNode (PARSEOP_CLOCKPHASE_SECOND);}
+    ;
+
+ClockPolarityKeyword
+    : PARSEOP_CLOCKPOLARITY_LOW             {$$ = TrCreateLeafNode (PARSEOP_CLOCKPOLARITY_LOW);}
+    | PARSEOP_CLOCKPOLARITY_HIGH            {$$ = TrCreateLeafNode (PARSEOP_CLOCKPOLARITY_HIGH);}
+    ;
+
+DecodeKeyword
+    : PARSEOP_DECODETYPE_POS                {$$ = TrCreateLeafNode (PARSEOP_DECODETYPE_POS);}
+    | PARSEOP_DECODETYPE_SUB                {$$ = TrCreateLeafNode (PARSEOP_DECODETYPE_SUB);}
+    ;
+
+DevicePolarityKeyword
+    : PARSEOP_DEVICEPOLARITY_LOW            {$$ = TrCreateLeafNode (PARSEOP_DEVICEPOLARITY_LOW);}
+    | PARSEOP_DEVICEPOLARITY_HIGH           {$$ = TrCreateLeafNode (PARSEOP_DEVICEPOLARITY_HIGH);}
+    ;
+
+DMATypeKeyword
+    : PARSEOP_DMATYPE_A                     {$$ = TrCreateLeafNode (PARSEOP_DMATYPE_A);}
+    | PARSEOP_DMATYPE_COMPATIBILITY         {$$ = TrCreateLeafNode (PARSEOP_DMATYPE_COMPATIBILITY);}
+    | PARSEOP_DMATYPE_B                     {$$ = TrCreateLeafNode (PARSEOP_DMATYPE_B);}
+    | PARSEOP_DMATYPE_F                     {$$ = TrCreateLeafNode (PARSEOP_DMATYPE_F);}
+    ;
+
+EndianKeyword
+    : PARSEOP_ENDIAN_LITTLE                 {$$ = TrCreateLeafNode (PARSEOP_ENDIAN_LITTLE);}
+    | PARSEOP_ENDIAN_BIG                    {$$ = TrCreateLeafNode (PARSEOP_ENDIAN_BIG);}
+    ;
+
+FlowControlKeyword
+    : PARSEOP_FLOWCONTROL_HW                {$$ = TrCreateLeafNode (PARSEOP_FLOWCONTROL_HW);}
+    | PARSEOP_FLOWCONTROL_NONE              {$$ = TrCreateLeafNode (PARSEOP_FLOWCONTROL_NONE);}
+    | PARSEOP_FLOWCONTROL_SW                {$$ = TrCreateLeafNode (PARSEOP_FLOWCONTROL_SW);}
+    ;
+
+InterruptLevel
+    : PARSEOP_INTLEVEL_ACTIVEBOTH           {$$ = TrCreateLeafNode (PARSEOP_INTLEVEL_ACTIVEBOTH);}
+    | PARSEOP_INTLEVEL_ACTIVEHIGH           {$$ = TrCreateLeafNode (PARSEOP_INTLEVEL_ACTIVEHIGH);}
+    | PARSEOP_INTLEVEL_ACTIVELOW            {$$ = TrCreateLeafNode (PARSEOP_INTLEVEL_ACTIVELOW);}
+    ;
+
+InterruptTypeKeyword
+    : PARSEOP_INTTYPE_EDGE                  {$$ = TrCreateLeafNode (PARSEOP_INTTYPE_EDGE);}
+    | PARSEOP_INTTYPE_LEVEL                 {$$ = TrCreateLeafNode (PARSEOP_INTTYPE_LEVEL);}
+    ;
+
+IODecodeKeyword
+    : PARSEOP_IODECODETYPE_16               {$$ = TrCreateLeafNode (PARSEOP_IODECODETYPE_16);}
+    | PARSEOP_IODECODETYPE_10               {$$ = TrCreateLeafNode (PARSEOP_IODECODETYPE_10);}
+    ;
+
+IoRestrictionKeyword
+    : PARSEOP_IORESTRICT_IN                 {$$ = TrCreateLeafNode (PARSEOP_IORESTRICT_IN);}
+    | PARSEOP_IORESTRICT_OUT                {$$ = TrCreateLeafNode (PARSEOP_IORESTRICT_OUT);}
+    | PARSEOP_IORESTRICT_NONE               {$$ = TrCreateLeafNode (PARSEOP_IORESTRICT_NONE);}
+    | PARSEOP_IORESTRICT_PRESERVE           {$$ = TrCreateLeafNode (PARSEOP_IORESTRICT_PRESERVE);}
+    ;
+
+LockRuleKeyword
+    : PARSEOP_LOCKRULE_LOCK                 {$$ = TrCreateLeafNode (PARSEOP_LOCKRULE_LOCK);}
+    | PARSEOP_LOCKRULE_NOLOCK               {$$ = TrCreateLeafNode (PARSEOP_LOCKRULE_NOLOCK);}
+    ;
+
+MatchOpKeyword
+    : PARSEOP_MATCHTYPE_MTR                 {$$ = TrCreateLeafNode (PARSEOP_MATCHTYPE_MTR);}
+    | PARSEOP_MATCHTYPE_MEQ                 {$$ = TrCreateLeafNode (PARSEOP_MATCHTYPE_MEQ);}
+    | PARSEOP_MATCHTYPE_MLE                 {$$ = TrCreateLeafNode (PARSEOP_MATCHTYPE_MLE);}
+    | PARSEOP_MATCHTYPE_MLT                 {$$ = TrCreateLeafNode (PARSEOP_MATCHTYPE_MLT);}
+    | PARSEOP_MATCHTYPE_MGE                 {$$ = TrCreateLeafNode (PARSEOP_MATCHTYPE_MGE);}
+    | PARSEOP_MATCHTYPE_MGT                 {$$ = TrCreateLeafNode (PARSEOP_MATCHTYPE_MGT);}
+    ;
+
+MaxKeyword
+    : PARSEOP_MAXTYPE_FIXED                 {$$ = TrCreateLeafNode (PARSEOP_MAXTYPE_FIXED);}
+    | PARSEOP_MAXTYPE_NOTFIXED              {$$ = TrCreateLeafNode (PARSEOP_MAXTYPE_NOTFIXED);}
+    ;
+
+MemTypeKeyword
+    : PARSEOP_MEMTYPE_CACHEABLE             {$$ = TrCreateLeafNode (PARSEOP_MEMTYPE_CACHEABLE);}
+    | PARSEOP_MEMTYPE_WRITECOMBINING        {$$ = TrCreateLeafNode (PARSEOP_MEMTYPE_WRITECOMBINING);}
+    | PARSEOP_MEMTYPE_PREFETCHABLE          {$$ = TrCreateLeafNode (PARSEOP_MEMTYPE_PREFETCHABLE);}
+    | PARSEOP_MEMTYPE_NONCACHEABLE          {$$ = TrCreateLeafNode (PARSEOP_MEMTYPE_NONCACHEABLE);}
+    ;
+
+MinKeyword
+    : PARSEOP_MINTYPE_FIXED                 {$$ = TrCreateLeafNode (PARSEOP_MINTYPE_FIXED);}
+    | PARSEOP_MINTYPE_NOTFIXED              {$$ = TrCreateLeafNode (PARSEOP_MINTYPE_NOTFIXED);}
+    ;
+
+ObjectTypeKeyword
+    : PARSEOP_OBJECTTYPE_UNK                {$$ = TrCreateLeafNode (PARSEOP_OBJECTTYPE_UNK);}
+    | PARSEOP_OBJECTTYPE_INT                {$$ = TrCreateLeafNode (PARSEOP_OBJECTTYPE_INT);}
+    | PARSEOP_OBJECTTYPE_STR                {$$ = TrCreateLeafNode (PARSEOP_OBJECTTYPE_STR);}
+    | PARSEOP_OBJECTTYPE_BUF                {$$ = TrCreateLeafNode (PARSEOP_OBJECTTYPE_BUF);}
+    | PARSEOP_OBJECTTYPE_PKG                {$$ = TrCreateLeafNode (PARSEOP_OBJECTTYPE_PKG);}
+    | PARSEOP_OBJECTTYPE_FLD                {$$ = TrCreateLeafNode (PARSEOP_OBJECTTYPE_FLD);}
+    | PARSEOP_OBJECTTYPE_DEV                {$$ = TrCreateLeafNode (PARSEOP_OBJECTTYPE_DEV);}
+    | PARSEOP_OBJECTTYPE_EVT                {$$ = TrCreateLeafNode (PARSEOP_OBJECTTYPE_EVT);}
+    | PARSEOP_OBJECTTYPE_MTH                {$$ = TrCreateLeafNode (PARSEOP_OBJECTTYPE_MTH);}
+    | PARSEOP_OBJECTTYPE_MTX                {$$ = TrCreateLeafNode (PARSEOP_OBJECTTYPE_MTX);}
+    | PARSEOP_OBJECTTYPE_OPR                {$$ = TrCreateLeafNode (PARSEOP_OBJECTTYPE_OPR);}
+    | PARSEOP_OBJECTTYPE_POW                {$$ = TrCreateLeafNode (PARSEOP_OBJECTTYPE_POW);}
+    | PARSEOP_OBJECTTYPE_PRO                {$$ = TrCreateLeafNode (PARSEOP_OBJECTTYPE_PRO);}
+    | PARSEOP_OBJECTTYPE_THZ                {$$ = TrCreateLeafNode (PARSEOP_OBJECTTYPE_THZ);}
+    | PARSEOP_OBJECTTYPE_BFF                {$$ = TrCreateLeafNode (PARSEOP_OBJECTTYPE_BFF);}
+    | PARSEOP_OBJECTTYPE_DDB                {$$ = TrCreateLeafNode (PARSEOP_OBJECTTYPE_DDB);}
+    ;
+
+ParityTypeKeyword
+    : PARSEOP_PARITYTYPE_SPACE              {$$ = TrCreateLeafNode (PARSEOP_PARITYTYPE_SPACE);}
+    | PARSEOP_PARITYTYPE_MARK               {$$ = TrCreateLeafNode (PARSEOP_PARITYTYPE_MARK);}
+    | PARSEOP_PARITYTYPE_ODD                {$$ = TrCreateLeafNode (PARSEOP_PARITYTYPE_ODD);}
+    | PARSEOP_PARITYTYPE_EVEN               {$$ = TrCreateLeafNode (PARSEOP_PARITYTYPE_EVEN);}
+    | PARSEOP_PARITYTYPE_NONE               {$$ = TrCreateLeafNode (PARSEOP_PARITYTYPE_NONE);}
+    ;
+
+PinConfigByte
+    : PinConfigKeyword                      {$$ = $1;}
+    | ByteConstExpr                         {$$ = UtCheckIntegerRange ($1, 0x80, 0xFF);}
+    ;
+
+PinConfigKeyword
+    : PARSEOP_PIN_NOPULL                    {$$ = TrCreateLeafNode (PARSEOP_PIN_NOPULL);}
+    | PARSEOP_PIN_PULLDOWN                  {$$ = TrCreateLeafNode (PARSEOP_PIN_PULLDOWN);}
+    | PARSEOP_PIN_PULLUP                    {$$ = TrCreateLeafNode (PARSEOP_PIN_PULLUP);}
+    | PARSEOP_PIN_PULLDEFAULT               {$$ = TrCreateLeafNode (PARSEOP_PIN_PULLDEFAULT);}
+    ;
+
+PldKeyword
+    : PARSEOP_PLD_REVISION                  {$$ = TrCreateLeafNode (PARSEOP_PLD_REVISION);}
+    | PARSEOP_PLD_IGNORECOLOR               {$$ = TrCreateLeafNode (PARSEOP_PLD_IGNORECOLOR);}
+    | PARSEOP_PLD_RED                       {$$ = TrCreateLeafNode (PARSEOP_PLD_RED);}
+    | PARSEOP_PLD_GREEN                     {$$ = TrCreateLeafNode (PARSEOP_PLD_GREEN);}
+    | PARSEOP_PLD_BLUE                      {$$ = TrCreateLeafNode (PARSEOP_PLD_BLUE);}
+    | PARSEOP_PLD_WIDTH                     {$$ = TrCreateLeafNode (PARSEOP_PLD_WIDTH);}
+    | PARSEOP_PLD_HEIGHT                    {$$ = TrCreateLeafNode (PARSEOP_PLD_HEIGHT);}
+    | PARSEOP_PLD_USERVISIBLE               {$$ = TrCreateLeafNode (PARSEOP_PLD_USERVISIBLE);}
+    | PARSEOP_PLD_DOCK                      {$$ = TrCreateLeafNode (PARSEOP_PLD_DOCK);}
+    | PARSEOP_PLD_LID                       {$$ = TrCreateLeafNode (PARSEOP_PLD_LID);}
+    | PARSEOP_PLD_PANEL                     {$$ = TrCreateLeafNode (PARSEOP_PLD_PANEL);}
+    | PARSEOP_PLD_VERTICALPOSITION          {$$ = TrCreateLeafNode (PARSEOP_PLD_VERTICALPOSITION);}
+    | PARSEOP_PLD_HORIZONTALPOSITION        {$$ = TrCreateLeafNode (PARSEOP_PLD_HORIZONTALPOSITION);}
+    | PARSEOP_PLD_SHAPE                     {$$ = TrCreateLeafNode (PARSEOP_PLD_SHAPE);}
+    | PARSEOP_PLD_GROUPORIENTATION          {$$ = TrCreateLeafNode (PARSEOP_PLD_GROUPORIENTATION);}
+    | PARSEOP_PLD_GROUPTOKEN                {$$ = TrCreateLeafNode (PARSEOP_PLD_GROUPTOKEN);}
+    | PARSEOP_PLD_GROUPPOSITION             {$$ = TrCreateLeafNode (PARSEOP_PLD_GROUPPOSITION);}
+    | PARSEOP_PLD_BAY                       {$$ = TrCreateLeafNode (PARSEOP_PLD_BAY);}
+    | PARSEOP_PLD_EJECTABLE                 {$$ = TrCreateLeafNode (PARSEOP_PLD_EJECTABLE);}
+    | PARSEOP_PLD_EJECTREQUIRED             {$$ = TrCreateLeafNode (PARSEOP_PLD_EJECTREQUIRED);}
+    | PARSEOP_PLD_CABINETNUMBER             {$$ = TrCreateLeafNode (PARSEOP_PLD_CABINETNUMBER);}
+    | PARSEOP_PLD_CARDCAGENUMBER            {$$ = TrCreateLeafNode (PARSEOP_PLD_CARDCAGENUMBER);}
+    | PARSEOP_PLD_REFERENCE                 {$$ = TrCreateLeafNode (PARSEOP_PLD_REFERENCE);}
+    | PARSEOP_PLD_ROTATION                  {$$ = TrCreateLeafNode (PARSEOP_PLD_ROTATION);}
+    | PARSEOP_PLD_ORDER                     {$$ = TrCreateLeafNode (PARSEOP_PLD_ORDER);}
+    | PARSEOP_PLD_RESERVED                  {$$ = TrCreateLeafNode (PARSEOP_PLD_RESERVED);}
+    | PARSEOP_PLD_VERTICALOFFSET            {$$ = TrCreateLeafNode (PARSEOP_PLD_VERTICALOFFSET);}
+    | PARSEOP_PLD_HORIZONTALOFFSET          {$$ = TrCreateLeafNode (PARSEOP_PLD_HORIZONTALOFFSET);}
+    ;
+
+RangeTypeKeyword
+    : PARSEOP_RANGETYPE_ISAONLY             {$$ = TrCreateLeafNode (PARSEOP_RANGETYPE_ISAONLY);}
+    | PARSEOP_RANGETYPE_NONISAONLY          {$$ = TrCreateLeafNode (PARSEOP_RANGETYPE_NONISAONLY);}
+    | PARSEOP_RANGETYPE_ENTIRE              {$$ = TrCreateLeafNode (PARSEOP_RANGETYPE_ENTIRE);}
+    ;
+
+RegionSpaceKeyword
+    : PARSEOP_REGIONSPACE_IO                {$$ = TrCreateLeafNode (PARSEOP_REGIONSPACE_IO);}
+    | PARSEOP_REGIONSPACE_MEM               {$$ = TrCreateLeafNode (PARSEOP_REGIONSPACE_MEM);}
+    | PARSEOP_REGIONSPACE_PCI               {$$ = TrCreateLeafNode (PARSEOP_REGIONSPACE_PCI);}
+    | PARSEOP_REGIONSPACE_EC                {$$ = TrCreateLeafNode (PARSEOP_REGIONSPACE_EC);}
+    | PARSEOP_REGIONSPACE_SMBUS             {$$ = TrCreateLeafNode (PARSEOP_REGIONSPACE_SMBUS);}
+    | PARSEOP_REGIONSPACE_CMOS              {$$ = TrCreateLeafNode (PARSEOP_REGIONSPACE_CMOS);}
+    | PARSEOP_REGIONSPACE_PCIBAR            {$$ = TrCreateLeafNode (PARSEOP_REGIONSPACE_PCIBAR);}
+    | PARSEOP_REGIONSPACE_IPMI              {$$ = TrCreateLeafNode (PARSEOP_REGIONSPACE_IPMI);}
+    | PARSEOP_REGIONSPACE_GPIO              {$$ = TrCreateLeafNode (PARSEOP_REGIONSPACE_GPIO);}
+    | PARSEOP_REGIONSPACE_GSBUS             {$$ = TrCreateLeafNode (PARSEOP_REGIONSPACE_GSBUS);}
+    | PARSEOP_REGIONSPACE_PCC               {$$ = TrCreateLeafNode (PARSEOP_REGIONSPACE_PCC);}
+    | PARSEOP_REGIONSPACE_FFIXEDHW          {$$ = TrCreateLeafNode (PARSEOP_REGIONSPACE_FFIXEDHW);}
+    ;
+
+ResourceTypeKeyword
+    : PARSEOP_RESOURCETYPE_CONSUMER         {$$ = TrCreateLeafNode (PARSEOP_RESOURCETYPE_CONSUMER);}
+    | PARSEOP_RESOURCETYPE_PRODUCER         {$$ = TrCreateLeafNode (PARSEOP_RESOURCETYPE_PRODUCER);}
+    ;
+
+SerializeRuleKeyword
+    : PARSEOP_SERIALIZERULE_SERIAL          {$$ = TrCreateLeafNode (PARSEOP_SERIALIZERULE_SERIAL);}
+    | PARSEOP_SERIALIZERULE_NOTSERIAL       {$$ = TrCreateLeafNode (PARSEOP_SERIALIZERULE_NOTSERIAL);}
+    ;
+
+ShareTypeKeyword
+    : PARSEOP_SHARETYPE_SHARED              {$$ = TrCreateLeafNode (PARSEOP_SHARETYPE_SHARED);}
+    | PARSEOP_SHARETYPE_EXCLUSIVE           {$$ = TrCreateLeafNode (PARSEOP_SHARETYPE_EXCLUSIVE);}
+    | PARSEOP_SHARETYPE_SHAREDWAKE          {$$ = TrCreateLeafNode (PARSEOP_SHARETYPE_SHAREDWAKE);}
+    | PARSEOP_SHARETYPE_EXCLUSIVEWAKE       {$$ = TrCreateLeafNode (PARSEOP_SHARETYPE_EXCLUSIVEWAKE);}
+   ;
+
+SlaveModeKeyword
+    : PARSEOP_SLAVEMODE_CONTROLLERINIT      {$$ = TrCreateLeafNode (PARSEOP_SLAVEMODE_CONTROLLERINIT);}
+    | PARSEOP_SLAVEMODE_DEVICEINIT          {$$ = TrCreateLeafNode (PARSEOP_SLAVEMODE_DEVICEINIT);}
+    ;
+
+StopBitsKeyword
+    : PARSEOP_STOPBITS_TWO                  {$$ = TrCreateLeafNode (PARSEOP_STOPBITS_TWO);}
+    | PARSEOP_STOPBITS_ONEPLUSHALF          {$$ = TrCreateLeafNode (PARSEOP_STOPBITS_ONEPLUSHALF);}
+    | PARSEOP_STOPBITS_ONE                  {$$ = TrCreateLeafNode (PARSEOP_STOPBITS_ONE);}
+    | PARSEOP_STOPBITS_ZERO                 {$$ = TrCreateLeafNode (PARSEOP_STOPBITS_ZERO);}
+    ;
+
+TranslationKeyword
+    : PARSEOP_TRANSLATIONTYPE_SPARSE        {$$ = TrCreateLeafNode (PARSEOP_TRANSLATIONTYPE_SPARSE);}
+    | PARSEOP_TRANSLATIONTYPE_DENSE         {$$ = TrCreateLeafNode (PARSEOP_TRANSLATIONTYPE_DENSE);}
+    ;
+
+TypeKeyword
+    : PARSEOP_TYPE_TRANSLATION              {$$ = TrCreateLeafNode (PARSEOP_TYPE_TRANSLATION);}
+    | PARSEOP_TYPE_STATIC                   {$$ = TrCreateLeafNode (PARSEOP_TYPE_STATIC);}
+    ;
+
+UpdateRuleKeyword
+    : PARSEOP_UPDATERULE_PRESERVE           {$$ = TrCreateLeafNode (PARSEOP_UPDATERULE_PRESERVE);}
+    | PARSEOP_UPDATERULE_ONES               {$$ = TrCreateLeafNode (PARSEOP_UPDATERULE_ONES);}
+    | PARSEOP_UPDATERULE_ZEROS              {$$ = TrCreateLeafNode (PARSEOP_UPDATERULE_ZEROS);}
+    ;
+
+WireModeKeyword
+    : PARSEOP_WIREMODE_FOUR                 {$$ = TrCreateLeafNode (PARSEOP_WIREMODE_FOUR);}
+    | PARSEOP_WIREMODE_THREE                {$$ = TrCreateLeafNode (PARSEOP_WIREMODE_THREE);}
+    ;
+
+XferSizeKeyword
+    : PARSEOP_XFERSIZE_8                    {$$ = TrCreateValuedLeafNode (PARSEOP_XFERSIZE_8,   0);}
+    | PARSEOP_XFERSIZE_16                   {$$ = TrCreateValuedLeafNode (PARSEOP_XFERSIZE_16,  1);}
+    | PARSEOP_XFERSIZE_32                   {$$ = TrCreateValuedLeafNode (PARSEOP_XFERSIZE_32,  2);}
+    | PARSEOP_XFERSIZE_64                   {$$ = TrCreateValuedLeafNode (PARSEOP_XFERSIZE_64,  3);}
+    | PARSEOP_XFERSIZE_128                  {$$ = TrCreateValuedLeafNode (PARSEOP_XFERSIZE_128, 4);}
+    | PARSEOP_XFERSIZE_256                  {$$ = TrCreateValuedLeafNode (PARSEOP_XFERSIZE_256, 5);}
+    ;
+
+XferTypeKeyword
+    : PARSEOP_XFERTYPE_8                    {$$ = TrCreateLeafNode (PARSEOP_XFERTYPE_8);}
+    | PARSEOP_XFERTYPE_8_16                 {$$ = TrCreateLeafNode (PARSEOP_XFERTYPE_8_16);}
+    | PARSEOP_XFERTYPE_16                   {$$ = TrCreateLeafNode (PARSEOP_XFERTYPE_16);}
+    ;
+
+
+/*******************************************************************************
+ *
+ * ASL Resource Template Terms
+ *
+ ******************************************************************************/
+
+/*
+ * Note: Create two default nodes to allow conversion to a Buffer AML opcode
+ * Also, insert the EndTag at the end of the template.
+ */
+ResourceTemplateTerm
+    : PARSEOP_RESOURCETEMPLATE '(' ')'
+        '{'
+        ResourceMacroList '}'       {$$ = TrCreateNode (PARSEOP_RESOURCETEMPLATE,4,
+                                          TrCreateLeafNode (PARSEOP_DEFAULT_ARG),
+                                          TrCreateLeafNode (PARSEOP_DEFAULT_ARG),
+                                          $5,
+                                          TrCreateLeafNode (PARSEOP_ENDTAG));}
+    ;
+
+ResourceMacroList
+    :                               {$$ = NULL;}
+    | ResourceMacroList
+        ResourceMacroTerm           {$$ = TrLinkPeerNode ($1,$2);}
+    ;
+
+ResourceMacroTerm
+    : DMATerm                       {}
+    | DWordIOTerm                   {}
+    | DWordMemoryTerm               {}
+    | DWordSpaceTerm                {}
+    | EndDependentFnTerm            {}
+    | ExtendedIOTerm                {}
+    | ExtendedMemoryTerm            {}
+    | ExtendedSpaceTerm             {}
+    | FixedDmaTerm                  {}
+    | FixedIOTerm                   {}
+    | GpioIntTerm                   {}
+    | GpioIoTerm                    {}
+    | I2cSerialBusTerm              {}
+    | I2cSerialBusTermV2            {}
+    | InterruptTerm                 {}
+    | IOTerm                        {}
+    | IRQNoFlagsTerm                {}
+    | IRQTerm                       {}
+    | Memory24Term                  {}
+    | Memory32FixedTerm             {}
+    | Memory32Term                  {}
+    | QWordIOTerm                   {}
+    | QWordMemoryTerm               {}
+    | QWordSpaceTerm                {}
+    | RegisterTerm                  {}
+    | SpiSerialBusTerm              {}
+    | SpiSerialBusTermV2            {}
+    | StartDependentFnNoPriTerm     {}
+    | StartDependentFnTerm          {}
+    | UartSerialBusTerm             {}
+    | UartSerialBusTermV2           {}
+    | VendorLongTerm                {}
+    | VendorShortTerm               {}
+    | WordBusNumberTerm             {}
+    | WordIOTerm                    {}
+    | WordSpaceTerm                 {}
+    ;
+
+DMATerm
+    : PARSEOP_DMA '('               {$<n>$ = TrCreateLeafNode (PARSEOP_DMA);}
+        DMATypeKeyword
+        OptionalBusMasterKeyword
+        ',' XferTypeKeyword
+        OptionalNameString_Last
+        ')' '{'
+            ByteList '}'            {$$ = TrLinkChildren ($<n>3,5,$4,$5,$7,$8,$11);}
+    | PARSEOP_DMA '('
+        error ')'                   {$$ = AslDoError(); yyclearin;}
+    ;
+
+DWordIOTerm
+    : PARSEOP_DWORDIO '('           {$<n>$ = TrCreateLeafNode (PARSEOP_DWORDIO);}
+        OptionalResourceType_First
+        OptionalMinType
+        OptionalMaxType
+        OptionalDecodeType
+        OptionalRangeType
+        ',' DWordConstExpr
+        ',' DWordConstExpr
+        ',' DWordConstExpr
+        ',' DWordConstExpr
+        ',' DWordConstExpr
+        OptionalByteConstExpr
+        OptionalStringData
+        OptionalNameString
+        OptionalType
+        OptionalTranslationType_Last
+        ')'                         {$$ = TrLinkChildren ($<n>3,15,$4,$5,$6,$7,$8,$10,$12,$14,$16,$18,$19,$20,$21,$22,$23);}
+    | PARSEOP_DWORDIO '('
+        error ')'                   {$$ = AslDoError(); yyclearin;}
+    ;
+
+DWordMemoryTerm
+    : PARSEOP_DWORDMEMORY '('       {$<n>$ = TrCreateLeafNode (PARSEOP_DWORDMEMORY);}
+        OptionalResourceType_First
+        OptionalDecodeType
+        OptionalMinType
+        OptionalMaxType
+        OptionalMemType
+        ',' OptionalReadWriteKeyword
+        ',' DWordConstExpr
+        ',' DWordConstExpr
+        ',' DWordConstExpr
+        ',' DWordConstExpr
+        ',' DWordConstExpr
+        OptionalByteConstExpr
+        OptionalStringData
+        OptionalNameString
+        OptionalAddressRange
+        OptionalType_Last
+        ')'                         {$$ = TrLinkChildren ($<n>3,16,$4,$5,$6,$7,$8,$10,$12,$14,$16,$18,$20,$21,$22,$23,$24,$25);}
+    | PARSEOP_DWORDMEMORY '('
+        error ')'                   {$$ = AslDoError(); yyclearin;}
+    ;
+
+DWordSpaceTerm
+    : PARSEOP_DWORDSPACE '('        {$<n>$ = TrCreateLeafNode (PARSEOP_DWORDSPACE);}
+        ByteConstExpr               {UtCheckIntegerRange ($4, 0xC0, 0xFF);}
+        OptionalResourceType
+        OptionalDecodeType
+        OptionalMinType
+        OptionalMaxType
+        ',' ByteConstExpr
+        ',' DWordConstExpr
+        ',' DWordConstExpr
+        ',' DWordConstExpr
+        ',' DWordConstExpr
+        ',' DWordConstExpr
+        OptionalByteConstExpr
+        OptionalStringData
+        OptionalNameString_Last
+        ')'                         {$$ = TrLinkChildren ($<n>3,14,$4,$6,$7,$8,$9,$11,$13,$15,$17,$19,$21,$22,$23,$24);}
+    | PARSEOP_DWORDSPACE '('
+        error ')'                   {$$ = AslDoError(); yyclearin;}
+    ;
+
+EndDependentFnTerm
+    : PARSEOP_ENDDEPENDENTFN '('
+        ')'                         {$$ = TrCreateLeafNode (PARSEOP_ENDDEPENDENTFN);}
+    | PARSEOP_ENDDEPENDENTFN '('
+        error ')'                   {$$ = AslDoError(); yyclearin;}
+    ;
+
+ExtendedIOTerm
+    : PARSEOP_EXTENDEDIO '('        {$<n>$ = TrCreateLeafNode (PARSEOP_EXTENDEDIO);}
+        OptionalResourceType_First
+        OptionalMinType
+        OptionalMaxType
+        OptionalDecodeType
+        OptionalRangeType
+        ',' QWordConstExpr
+        ',' QWordConstExpr
+        ',' QWordConstExpr
+        ',' QWordConstExpr
+        ',' QWordConstExpr
+        OptionalQWordConstExpr
+        OptionalNameString
+        OptionalType
+        OptionalTranslationType_Last
+        ')'                         {$$ = TrLinkChildren ($<n>3,14,$4,$5,$6,$7,$8,$10,$12,$14,$16,$18,$19,$20,$21,$22);}
+    | PARSEOP_EXTENDEDIO '('
+        error ')'                   {$$ = AslDoError(); yyclearin;}
+    ;
+
+ExtendedMemoryTerm
+    : PARSEOP_EXTENDEDMEMORY '('    {$<n>$ = TrCreateLeafNode (PARSEOP_EXTENDEDMEMORY);}
+        OptionalResourceType_First
+        OptionalDecodeType
+        OptionalMinType
+        OptionalMaxType
+        OptionalMemType
+        ',' OptionalReadWriteKeyword
+        ',' QWordConstExpr
+        ',' QWordConstExpr
+        ',' QWordConstExpr
+        ',' QWordConstExpr
+        ',' QWordConstExpr
+        OptionalQWordConstExpr
+        OptionalNameString
+        OptionalAddressRange
+        OptionalType_Last
+        ')'                         {$$ = TrLinkChildren ($<n>3,15,$4,$5,$6,$7,$8,$10,$12,$14,$16,$18,$20,$21,$22,$23,$24);}
+    | PARSEOP_EXTENDEDMEMORY '('
+        error ')'                   {$$ = AslDoError(); yyclearin;}
+    ;
+
+ExtendedSpaceTerm
+    : PARSEOP_EXTENDEDSPACE '('     {$<n>$ = TrCreateLeafNode (PARSEOP_EXTENDEDSPACE);}
+        ByteConstExpr               {UtCheckIntegerRange ($4, 0xC0, 0xFF);}
+        OptionalResourceType
+        OptionalDecodeType
+        OptionalMinType
+        OptionalMaxType
+        ',' ByteConstExpr
+        ',' QWordConstExpr
+        ',' QWordConstExpr
+        ',' QWordConstExpr
+        ',' QWordConstExpr
+        ',' QWordConstExpr
+        OptionalQWordConstExpr
+        OptionalNameString_Last
+        ')'                         {$$ = TrLinkChildren ($<n>3,13,$4,$6,$7,$8,$9,$11,$13,$15,$17,$19,$21,$22,$23);}
+    | PARSEOP_EXTENDEDSPACE '('
+        error ')'                   {$$ = AslDoError(); yyclearin;}
+    ;
+
+FixedDmaTerm
+    : PARSEOP_FIXEDDMA '('          {$<n>$ = TrCreateLeafNode (PARSEOP_FIXEDDMA);}
+        WordConstExpr               /* 04: DMA RequestLines */
+        ',' WordConstExpr           /* 06: DMA Channels */
+        OptionalXferSize            /* 07: DMA TransferSize */
+        OptionalNameString          /* 08: DescriptorName */
+        ')'                         {$$ = TrLinkChildren ($<n>3,4,$4,$6,$7,$8);}
+    | PARSEOP_FIXEDDMA '('
+        error ')'                   {$$ = AslDoError(); yyclearin;}
+    ;
+
+FixedIOTerm
+    : PARSEOP_FIXEDIO '('           {$<n>$ = TrCreateLeafNode (PARSEOP_FIXEDIO);}
+        WordConstExpr
+        ',' ByteConstExpr
+        OptionalNameString_Last
+        ')'                         {$$ = TrLinkChildren ($<n>3,3,$4,$6,$7);}
+    | PARSEOP_FIXEDIO '('
+        error ')'                   {$$ = AslDoError(); yyclearin;}
+    ;
+
+GpioIntTerm
+    : PARSEOP_GPIO_INT '('          {$<n>$ = TrCreateLeafNode (PARSEOP_GPIO_INT);}
+        InterruptTypeKeyword        /* 04: InterruptType */
+        ',' InterruptLevel          /* 06: InterruptLevel */
+        OptionalShareType           /* 07: SharedType */
+        ',' PinConfigByte           /* 09: PinConfig */
+        OptionalWordConstExpr       /* 10: DebounceTimeout */
+        ',' StringData              /* 12: ResourceSource */
+        OptionalByteConstExpr       /* 13: ResourceSourceIndex */
+        OptionalResourceType        /* 14: ResourceType */
+        OptionalNameString          /* 15: DescriptorName */
+        OptionalBuffer_Last         /* 16: VendorData */
+        ')' '{'
+            DWordConstExpr '}'      {$$ = TrLinkChildren ($<n>3,11,$4,$6,$7,$9,$10,$12,$13,$14,$15,$16,$19);}
+    | PARSEOP_GPIO_INT '('
+        error ')'                   {$$ = AslDoError(); yyclearin;}
+    ;
+
+GpioIoTerm
+    : PARSEOP_GPIO_IO '('           {$<n>$ = TrCreateLeafNode (PARSEOP_GPIO_IO);}
+        OptionalShareType_First     /* 04: SharedType */
+        ',' PinConfigByte           /* 06: PinConfig */
+        OptionalWordConstExpr       /* 07: DebounceTimeout */
+        OptionalWordConstExpr       /* 08: DriveStrength */
+        OptionalIoRestriction       /* 09: IoRestriction */
+        ',' StringData              /* 11: ResourceSource */
+        OptionalByteConstExpr       /* 12: ResourceSourceIndex */
+        OptionalResourceType        /* 13: ResourceType */
+        OptionalNameString          /* 14: DescriptorName */
+        OptionalBuffer_Last         /* 15: VendorData */
+        ')' '{'
+            DWordList '}'           {$$ = TrLinkChildren ($<n>3,11,$4,$6,$7,$8,$9,$11,$12,$13,$14,$15,$18);}
+    | PARSEOP_GPIO_IO '('
+        error ')'                   {$$ = AslDoError(); yyclearin;}
+    ;
+
+I2cSerialBusTerm
+    : PARSEOP_I2C_SERIALBUS '('     {$<n>$ = TrCreateLeafNode (PARSEOP_I2C_SERIALBUS);}
+        WordConstExpr               /* 04: SlaveAddress */
+        OptionalSlaveMode           /* 05: SlaveMode */
+        ',' DWordConstExpr          /* 07: ConnectionSpeed */
+        OptionalAddressingMode      /* 08: AddressingMode */
+        ',' StringData              /* 10: ResourceSource */
+        OptionalByteConstExpr       /* 11: ResourceSourceIndex */
+        OptionalResourceType        /* 12: ResourceType */
+        OptionalNameString          /* 13: DescriptorName */
+        OptionalBuffer_Last         /* 14: VendorData */
+        ')'                         {$$ = TrLinkChildren ($<n>3,10,$4,$5,$7,$8,$10,$11,$12,$13,
+                                        TrCreateLeafNode (PARSEOP_DEFAULT_ARG),$14);}
+    | PARSEOP_I2C_SERIALBUS '('
+        error ')'                   {$$ = AslDoError(); yyclearin;}
+    ;
+
+I2cSerialBusTermV2
+    : PARSEOP_I2C_SERIALBUS_V2 '('  {$<n>$ = TrCreateLeafNode (PARSEOP_I2C_SERIALBUS_V2);}
+        WordConstExpr               /* 04: SlaveAddress */
+        OptionalSlaveMode           /* 05: SlaveMode */
+        ',' DWordConstExpr          /* 07: ConnectionSpeed */
+        OptionalAddressingMode      /* 08: AddressingMode */
+        ',' StringData              /* 10: ResourceSource */
+        OptionalByteConstExpr       /* 11: ResourceSourceIndex */
+        OptionalResourceType        /* 12: ResourceType */
+        OptionalNameString          /* 13: DescriptorName */
+        OptionalShareType           /* 14: Share */
+        OptionalBuffer_Last         /* 15: VendorData */
+        ')'                         {$$ = TrLinkChildren ($<n>3,10,$4,$5,$7,$8,$10,$11,$12,$13,
+                                        $14,$15);}
+    | PARSEOP_I2C_SERIALBUS_V2 '('
+        error ')'                   {$$ = AslDoError(); yyclearin;}
+    ;
+
+InterruptTerm
+    : PARSEOP_INTERRUPT '('         {$<n>$ = TrCreateLeafNode (PARSEOP_INTERRUPT);}
+        OptionalResourceType_First
+        ',' InterruptTypeKeyword
+        ',' InterruptLevel
+        OptionalShareType
+        OptionalByteConstExpr
+        OptionalStringData
+        OptionalNameString_Last
+        ')' '{'
+            DWordList '}'           {$$ = TrLinkChildren ($<n>3,8,$4,$6,$8,$9,$10,$11,$12,$15);}
+    | PARSEOP_INTERRUPT '('
+        error ')'                   {$$ = AslDoError(); yyclearin;}
+    ;
+
+IOTerm
+    : PARSEOP_IO '('                {$<n>$ = TrCreateLeafNode (PARSEOP_IO);}
+        IODecodeKeyword
+        ',' WordConstExpr
+        ',' WordConstExpr
+        ',' ByteConstExpr
+        ',' ByteConstExpr
+        OptionalNameString_Last
+        ')'                         {$$ = TrLinkChildren ($<n>3,6,$4,$6,$8,$10,$12,$13);}
+    | PARSEOP_IO '('
+        error ')'                   {$$ = AslDoError(); yyclearin;}
+    ;
+
+IRQNoFlagsTerm
+    : PARSEOP_IRQNOFLAGS '('        {$<n>$ = TrCreateLeafNode (PARSEOP_IRQNOFLAGS);}
+        OptionalNameString_First
+        ')' '{'
+            ByteList '}'            {$$ = TrLinkChildren ($<n>3,2,$4,$7);}
+    | PARSEOP_IRQNOFLAGS '('
+        error ')'                   {$$ = AslDoError(); yyclearin;}
+    ;
+
+IRQTerm
+    : PARSEOP_IRQ '('               {$<n>$ = TrCreateLeafNode (PARSEOP_IRQ);}
+        InterruptTypeKeyword
+        ',' InterruptLevel
+        OptionalShareType
+        OptionalNameString_Last
+        ')' '{'
+            ByteList '}'            {$$ = TrLinkChildren ($<n>3,5,$4,$6,$7,$8,$11);}
+    | PARSEOP_IRQ '('
+        error ')'                   {$$ = AslDoError(); yyclearin;}
+    ;
+
+Memory24Term
+    : PARSEOP_MEMORY24 '('          {$<n>$ = TrCreateLeafNode (PARSEOP_MEMORY24);}
+        OptionalReadWriteKeyword
+        ',' WordConstExpr
+        ',' WordConstExpr
+        ',' WordConstExpr
+        ',' WordConstExpr
+        OptionalNameString_Last
+        ')'                         {$$ = TrLinkChildren ($<n>3,6,$4,$6,$8,$10,$12,$13);}
+    | PARSEOP_MEMORY24 '('
+        error ')'                   {$$ = AslDoError(); yyclearin;}
+    ;
+
+Memory32FixedTerm
+    : PARSEOP_MEMORY32FIXED '('     {$<n>$ = TrCreateLeafNode (PARSEOP_MEMORY32FIXED);}
+        OptionalReadWriteKeyword
+        ',' DWordConstExpr
+        ',' DWordConstExpr
+        OptionalNameString_Last
+        ')'                         {$$ = TrLinkChildren ($<n>3,4,$4,$6,$8,$9);}
+    | PARSEOP_MEMORY32FIXED '('
+        error ')'                   {$$ = AslDoError(); yyclearin;}
+    ;
+
+Memory32Term
+    : PARSEOP_MEMORY32 '('          {$<n>$ = TrCreateLeafNode (PARSEOP_MEMORY32);}
+        OptionalReadWriteKeyword
+        ',' DWordConstExpr
+        ',' DWordConstExpr
+        ',' DWordConstExpr
+        ',' DWordConstExpr
+        OptionalNameString_Last
+        ')'                         {$$ = TrLinkChildren ($<n>3,6,$4,$6,$8,$10,$12,$13);}
+    | PARSEOP_MEMORY32 '('
+        error ')'                   {$$ = AslDoError(); yyclearin;}
+    ;
+
+QWordIOTerm
+    : PARSEOP_QWORDIO '('           {$<n>$ = TrCreateLeafNode (PARSEOP_QWORDIO);}
+        OptionalResourceType_First
+        OptionalMinType
+        OptionalMaxType
+        OptionalDecodeType
+        OptionalRangeType
+        ',' QWordConstExpr
+        ',' QWordConstExpr
+        ',' QWordConstExpr
+        ',' QWordConstExpr
+        ',' QWordConstExpr
+        OptionalByteConstExpr
+        OptionalStringData
+        OptionalNameString
+        OptionalType
+        OptionalTranslationType_Last
+        ')'                         {$$ = TrLinkChildren ($<n>3,15,$4,$5,$6,$7,$8,$10,$12,$14,$16,$18,$19,$20,$21,$22,$23);}
+    | PARSEOP_QWORDIO '('
+        error ')'                   {$$ = AslDoError(); yyclearin;}
+    ;
+
+QWordMemoryTerm
+    : PARSEOP_QWORDMEMORY '('       {$<n>$ = TrCreateLeafNode (PARSEOP_QWORDMEMORY);}
+        OptionalResourceType_First
+        OptionalDecodeType
+        OptionalMinType
+        OptionalMaxType
+        OptionalMemType
+        ',' OptionalReadWriteKeyword
+        ',' QWordConstExpr
+        ',' QWordConstExpr
+        ',' QWordConstExpr
+        ',' QWordConstExpr
+        ',' QWordConstExpr
+        OptionalByteConstExpr
+        OptionalStringData
+        OptionalNameString
+        OptionalAddressRange
+        OptionalType_Last
+        ')'                         {$$ = TrLinkChildren ($<n>3,16,$4,$5,$6,$7,$8,$10,$12,$14,$16,$18,$20,$21,$22,$23,$24,$25);}
+    | PARSEOP_QWORDMEMORY '('
+        error ')'                   {$$ = AslDoError(); yyclearin;}
+    ;
+
+QWordSpaceTerm
+    : PARSEOP_QWORDSPACE '('        {$<n>$ = TrCreateLeafNode (PARSEOP_QWORDSPACE);}
+        ByteConstExpr               {UtCheckIntegerRange ($4, 0xC0, 0xFF);}
+        OptionalResourceType
+        OptionalDecodeType
+        OptionalMinType
+        OptionalMaxType
+        ',' ByteConstExpr
+        ',' QWordConstExpr
+        ',' QWordConstExpr
+        ',' QWordConstExpr
+        ',' QWordConstExpr
+        ',' QWordConstExpr
+        OptionalByteConstExpr
+        OptionalStringData
+        OptionalNameString_Last
+        ')'                         {$$ = TrLinkChildren ($<n>3,14,$4,$6,$7,$8,$9,$11,$13,$15,$17,$19,$21,$22,$23,$24);}
+    | PARSEOP_QWORDSPACE '('
+        error ')'                   {$$ = AslDoError(); yyclearin;}
+    ;
+
+RegisterTerm
+    : PARSEOP_REGISTER '('          {$<n>$ = TrCreateLeafNode (PARSEOP_REGISTER);}
+        AddressSpaceKeyword
+        ',' ByteConstExpr
+        ',' ByteConstExpr
+        ',' QWordConstExpr
+        OptionalAccessSize
+        OptionalNameString_Last
+        ')'                         {$$ = TrLinkChildren ($<n>3,6,$4,$6,$8,$10,$11,$12);}
+    | PARSEOP_REGISTER '('
+        error ')'                   {$$ = AslDoError(); yyclearin;}
+    ;
+
+SpiSerialBusTerm
+    : PARSEOP_SPI_SERIALBUS '('     {$<n>$ = TrCreateLeafNode (PARSEOP_SPI_SERIALBUS);}
+        WordConstExpr               /* 04: DeviceSelection */
+        OptionalDevicePolarity      /* 05: DevicePolarity */
+        OptionalWireMode            /* 06: WireMode */
+        ',' ByteConstExpr           /* 08: DataBitLength */
+        OptionalSlaveMode           /* 09: SlaveMode */
+        ',' DWordConstExpr          /* 11: ConnectionSpeed */
+        ',' ClockPolarityKeyword    /* 13: ClockPolarity */
+        ',' ClockPhaseKeyword       /* 15: ClockPhase */
+        ',' StringData              /* 17: ResourceSource */
+        OptionalByteConstExpr       /* 18: ResourceSourceIndex */
+        OptionalResourceType        /* 19: ResourceType */
+        OptionalNameString          /* 20: DescriptorName */
+        OptionalBuffer_Last         /* 21: VendorData */
+        ')'                         {$$ = TrLinkChildren ($<n>3,14,$4,$5,$6,$8,$9,$11,$13,$15,$17,$18,$19,$20,
+                                        TrCreateLeafNode (PARSEOP_DEFAULT_ARG),$21);}
+    | PARSEOP_SPI_SERIALBUS '('
+        error ')'                   {$$ = AslDoError(); yyclearin;}
+    ;
+
+SpiSerialBusTermV2
+    : PARSEOP_SPI_SERIALBUS_V2 '('  {$<n>$ = TrCreateLeafNode (PARSEOP_SPI_SERIALBUS_V2);}
+        WordConstExpr               /* 04: DeviceSelection */
+        OptionalDevicePolarity      /* 05: DevicePolarity */
+        OptionalWireMode            /* 06: WireMode */
+        ',' ByteConstExpr           /* 08: DataBitLength */
+        OptionalSlaveMode           /* 09: SlaveMode */
+        ',' DWordConstExpr          /* 11: ConnectionSpeed */
+        ',' ClockPolarityKeyword    /* 13: ClockPolarity */
+        ',' ClockPhaseKeyword       /* 15: ClockPhase */
+        ',' StringData              /* 17: ResourceSource */
+        OptionalByteConstExpr       /* 18: ResourceSourceIndex */
+        OptionalResourceType        /* 19: ResourceType */
+        OptionalNameString          /* 20: DescriptorName */
+        OptionalShareType           /* 21: Share */
+        OptionalBuffer_Last         /* 22: VendorData */
+        ')'                         {$$ = TrLinkChildren ($<n>3,14,$4,$5,$6,$8,$9,$11,$13,$15,$17,$18,$19,$20,
+                                        $21,$22);}
+    | PARSEOP_SPI_SERIALBUS_V2 '('
+        error ')'                   {$$ = AslDoError(); yyclearin;}
+    ;
+
+StartDependentFnNoPriTerm
+    : PARSEOP_STARTDEPENDENTFN_NOPRI '('    {$<n>$ = TrCreateLeafNode (PARSEOP_STARTDEPENDENTFN_NOPRI);}
+        ')' '{'
+        ResourceMacroList '}'       {$$ = TrLinkChildren ($<n>3,1,$6);}
+    | PARSEOP_STARTDEPENDENTFN_NOPRI '('
+        error ')'                   {$$ = AslDoError(); yyclearin;}
+    ;
+
+StartDependentFnTerm
+    : PARSEOP_STARTDEPENDENTFN '('  {$<n>$ = TrCreateLeafNode (PARSEOP_STARTDEPENDENTFN);}
+        ByteConstExpr
+        ',' ByteConstExpr
+        ')' '{'
+        ResourceMacroList '}'       {$$ = TrLinkChildren ($<n>3,3,$4,$6,$9);}
+    | PARSEOP_STARTDEPENDENTFN '('
+        error ')'                   {$$ = AslDoError(); yyclearin;}
+    ;
+
+UartSerialBusTerm
+    : PARSEOP_UART_SERIALBUS '('    {$<n>$ = TrCreateLeafNode (PARSEOP_UART_SERIALBUS);}
+        DWordConstExpr              /* 04: ConnectionSpeed */
+        OptionalBitsPerByte         /* 05: BitsPerByte */
+        OptionalStopBits            /* 06: StopBits */
+        ',' ByteConstExpr           /* 08: LinesInUse */
+        OptionalEndian              /* 09: Endianess */
+        OptionalParityType          /* 10: Parity */
+        OptionalFlowControl         /* 11: FlowControl */
+        ',' WordConstExpr           /* 13: Rx BufferSize */
+        ',' WordConstExpr           /* 15: Tx BufferSize */
+        ',' StringData              /* 17: ResourceSource */
+        OptionalByteConstExpr       /* 18: ResourceSourceIndex */
+        OptionalResourceType        /* 19: ResourceType */
+        OptionalNameString          /* 20: DescriptorName */
+        OptionalBuffer_Last         /* 21: VendorData */
+        ')'                         {$$ = TrLinkChildren ($<n>3,15,$4,$5,$6,$8,$9,$10,$11,$13,$15,$17,$18,$19,$20,
+                                        TrCreateLeafNode (PARSEOP_DEFAULT_ARG),$21);}
+    | PARSEOP_UART_SERIALBUS '('
+        error ')'                   {$$ = AslDoError(); yyclearin;}
+    ;
+
+UartSerialBusTermV2
+    : PARSEOP_UART_SERIALBUS_V2 '(' {$<n>$ = TrCreateLeafNode (PARSEOP_UART_SERIALBUS_V2);}
+        DWordConstExpr              /* 04: ConnectionSpeed */
+        OptionalBitsPerByte         /* 05: BitsPerByte */
+        OptionalStopBits            /* 06: StopBits */
+        ',' ByteConstExpr           /* 08: LinesInUse */
+        OptionalEndian              /* 09: Endianess */
+        OptionalParityType          /* 10: Parity */
+        OptionalFlowControl         /* 11: FlowControl */
+        ',' WordConstExpr           /* 13: Rx BufferSize */
+        ',' WordConstExpr           /* 15: Tx BufferSize */
+        ',' StringData              /* 17: ResourceSource */
+        OptionalByteConstExpr       /* 18: ResourceSourceIndex */
+        OptionalResourceType        /* 19: ResourceType */
+        OptionalNameString          /* 20: DescriptorName */
+        OptionalShareType           /* 21: Share */
+        OptionalBuffer_Last         /* 22: VendorData */
+        ')'                         {$$ = TrLinkChildren ($<n>3,15,$4,$5,$6,$8,$9,$10,$11,$13,$15,$17,$18,$19,$20,
+                                        $21,$22);}
+    | PARSEOP_UART_SERIALBUS_V2 '('
+        error ')'                   {$$ = AslDoError(); yyclearin;}
+    ;
+
+VendorLongTerm
+    : PARSEOP_VENDORLONG '('        {$<n>$ = TrCreateLeafNode (PARSEOP_VENDORLONG);}
+        OptionalNameString_First
+        ')' '{'
+            ByteList '}'            {$$ = TrLinkChildren ($<n>3,2,$4,$7);}
+    | PARSEOP_VENDORLONG '('
+        error ')'                   {$$ = AslDoError(); yyclearin;}
+    ;
+
+VendorShortTerm
+    : PARSEOP_VENDORSHORT '('       {$<n>$ = TrCreateLeafNode (PARSEOP_VENDORSHORT);}
+        OptionalNameString_First
+        ')' '{'
+            ByteList '}'            {$$ = TrLinkChildren ($<n>3,2,$4,$7);}
+    | PARSEOP_VENDORSHORT '('
+        error ')'                   {$$ = AslDoError(); yyclearin;}
+    ;
+
+WordBusNumberTerm
+    : PARSEOP_WORDBUSNUMBER '('     {$<n>$ = TrCreateLeafNode (PARSEOP_WORDBUSNUMBER);}
+        OptionalResourceType_First
+        OptionalMinType
+        OptionalMaxType
+        OptionalDecodeType
+        ',' WordConstExpr
+        ',' WordConstExpr
+        ',' WordConstExpr
+        ',' WordConstExpr
+        ',' WordConstExpr
+        OptionalByteConstExpr
+        OptionalStringData
+        OptionalNameString_Last
+        ')'                         {$$ = TrLinkChildren ($<n>3,12,$4,$5,$6,$7,$9,$11,$13,$15,$17,$18,$19,$20);}
+    | PARSEOP_WORDBUSNUMBER '('
+        error ')'                   {$$ = AslDoError(); yyclearin;}
+    ;
+
+WordIOTerm
+    : PARSEOP_WORDIO '('            {$<n>$ = TrCreateLeafNode (PARSEOP_WORDIO);}
+        OptionalResourceType_First
+        OptionalMinType
+        OptionalMaxType
+        OptionalDecodeType
+        OptionalRangeType
+        ',' WordConstExpr
+        ',' WordConstExpr
+        ',' WordConstExpr
+        ',' WordConstExpr
+        ',' WordConstExpr
+        OptionalByteConstExpr
+        OptionalStringData
+        OptionalNameString
+        OptionalType
+        OptionalTranslationType_Last
+        ')'                         {$$ = TrLinkChildren ($<n>3,15,$4,$5,$6,$7,$8,$10,$12,$14,$16,$18,$19,$20,$21,$22,$23);}
+    | PARSEOP_WORDIO '('
+        error ')'                   {$$ = AslDoError(); yyclearin;}
+    ;
+
+WordSpaceTerm
+    : PARSEOP_WORDSPACE '('         {$<n>$ = TrCreateLeafNode (PARSEOP_WORDSPACE);}
+        ByteConstExpr               {UtCheckIntegerRange ($4, 0xC0, 0xFF);}
+        OptionalResourceType
+        OptionalDecodeType
+        OptionalMinType
+        OptionalMaxType
+        ',' ByteConstExpr
+        ',' WordConstExpr
+        ',' WordConstExpr
+        ',' WordConstExpr
+        ',' WordConstExpr
+        ',' WordConstExpr
+        OptionalByteConstExpr
+        OptionalStringData
+        OptionalNameString_Last
+        ')'                         {$$ = TrLinkChildren ($<n>3,14,$4,$6,$7,$8,$9,$11,$13,$15,$17,$19,$21,$22,$23,$24);}
+    | PARSEOP_WORDSPACE '('
+        error ')'                   {$$ = AslDoError(); yyclearin;}
+    ;
+
+
+/******* Object References ***********************************************/
+
+/* Allow IO, DMA, IRQ Resource macro names to also be used as identifiers */
+
+NameString
+    : NameSeg                       {}
+    | PARSEOP_NAMESTRING            {$$ = TrCreateValuedLeafNode (PARSEOP_NAMESTRING, (ACPI_NATIVE_INT) AslCompilerlval.s);}
+    | PARSEOP_IO                    {$$ = TrCreateValuedLeafNode (PARSEOP_NAMESTRING, (ACPI_NATIVE_INT) "IO");}
+    | PARSEOP_DMA                   {$$ = TrCreateValuedLeafNode (PARSEOP_NAMESTRING, (ACPI_NATIVE_INT) "DMA");}
+    | PARSEOP_IRQ                   {$$ = TrCreateValuedLeafNode (PARSEOP_NAMESTRING, (ACPI_NATIVE_INT) "IRQ");}
+    ;
+
+NameSeg
+    : PARSEOP_NAMESEG               {$$ = TrCreateValuedLeafNode (PARSEOP_NAMESEG, (ACPI_NATIVE_INT) AslCompilerlval.s);}
+    ;
+
+
+/*******************************************************************************
+ *
+ * ASL Helper Terms
+ *
+ ******************************************************************************/
+
+OptionalBusMasterKeyword
+    : ','                                       {$$ = TrCreateLeafNode (PARSEOP_BUSMASTERTYPE_MASTER);}
+    | ',' PARSEOP_BUSMASTERTYPE_MASTER          {$$ = TrCreateLeafNode (PARSEOP_BUSMASTERTYPE_MASTER);}
+    | ',' PARSEOP_BUSMASTERTYPE_NOTMASTER       {$$ = TrCreateLeafNode (PARSEOP_BUSMASTERTYPE_NOTMASTER);}
+    ;
+
+OptionalAccessAttribTerm
+    :                               {$$ = NULL;}
+    | ','                           {$$ = NULL;}
+    | ',' ByteConstExpr             {$$ = $2;}
+    | ',' AccessAttribKeyword       {$$ = $2;}
+    ;
+
+OptionalAccessSize
+    :                               {$$ = TrCreateValuedLeafNode (PARSEOP_BYTECONST, 0);}
+    | ','                           {$$ = TrCreateValuedLeafNode (PARSEOP_BYTECONST, 0);}
+    | ',' ByteConstExpr             {$$ = $2;}
+    ;
+
+OptionalAddressingMode
+    : ','                           {$$ = NULL;}
+    | ',' AddressingModeKeyword     {$$ = $2;}
+    ;
+
+OptionalAddressRange
+    :                               {$$ = NULL;}
+    | ','                           {$$ = NULL;}
+    | ',' AddressKeyword            {$$ = $2;}
+    ;
+
+OptionalBitsPerByte
+    : ','                           {$$ = NULL;}
+    | ',' BitsPerByteKeyword        {$$ = $2;}
+    ;
+
+OptionalBuffer_Last
+    :                               {$$ = NULL;}
+    | ','                           {$$ = NULL;}
+    | ',' RawDataBufferTerm         {$$ = $2;}
+    ;
+
+OptionalByteConstExpr
+    :                               {$$ = NULL;}
+    | ','                           {$$ = NULL;}
+    | ',' ByteConstExpr             {$$ = $2;}
+    ;
+
+OptionalDecodeType
+    : ','                           {$$ = NULL;}
+    | ',' DecodeKeyword             {$$ = $2;}
+    ;
+
+OptionalDevicePolarity
+    : ','                           {$$ = NULL;}
+    | ',' DevicePolarityKeyword     {$$ = $2;}
+    ;
+
+OptionalDWordConstExpr
+    :                               {$$ = NULL;}
+    | ','                           {$$ = NULL;}
+    | ',' DWordConstExpr            {$$ = $2;}
+    ;
+
+OptionalEndian
+    : ','                           {$$ = NULL;}
+    | ',' EndianKeyword             {$$ = $2;}
+    ;
+
+OptionalFlowControl
+    : ','                           {$$ = NULL;}
+    | ',' FlowControlKeyword        {$$ = $2;}
+    ;
+
+OptionalIoRestriction
+    : ','                           {$$ = NULL;}
+    | ',' IoRestrictionKeyword      {$$ = $2;}
+    ;
+
+OptionalListString
+    :                               {$$ = TrCreateValuedLeafNode (PARSEOP_STRING_LITERAL, ACPI_TO_INTEGER (""));}   /* Placeholder is a NULL string */
+    | ','                           {$$ = TrCreateValuedLeafNode (PARSEOP_STRING_LITERAL, ACPI_TO_INTEGER (""));}   /* Placeholder is a NULL string */
+    | ',' TermArg                   {$$ = $2;}
+    ;
+
+OptionalMaxType
+    : ','                           {$$ = NULL;}
+    | ',' MaxKeyword                {$$ = $2;}
+    ;
+
+OptionalMemType
+    : ','                           {$$ = NULL;}
+    | ',' MemTypeKeyword            {$$ = $2;}
+    ;
+
+OptionalMinType
+    : ','                           {$$ = NULL;}
+    | ',' MinKeyword                {$$ = $2;}
+    ;
+
+OptionalNameString
+    :                               {$$ = NULL;}
+    | ','                           {$$ = NULL;}
+    | ',' NameString                {$$ = $2;}
+    ;
+
+OptionalNameString_Last
+    :                               {$$ = NULL;}
+    | ','                           {$$ = NULL;}
+    | ',' NameString                {$$ = $2;}
+    ;
+
+OptionalNameString_First
+    :                               {$$ = TrCreateLeafNode (PARSEOP_ZERO);}
+    | NameString                    {$$ = $1;}
+    ;
+
+OptionalObjectTypeKeyword
+    :                               {$$ = TrCreateLeafNode (PARSEOP_OBJECTTYPE_UNK);}
+    | ',' ObjectTypeKeyword         {$$ = $2;}
+    ;
+
+OptionalParityType
+    : ','                           {$$ = NULL;}
+    | ',' ParityTypeKeyword         {$$ = $2;}
+    ;
+
+OptionalQWordConstExpr
+    :                               {$$ = NULL;}
+    | ','                           {$$ = NULL;}
+    | ',' QWordConstExpr            {$$ = $2;}
+    ;
+
+OptionalRangeType
+    : ','                           {$$ = NULL;}
+    | ',' RangeTypeKeyword          {$$ = $2;}
+    ;
+
+OptionalReadWriteKeyword
+    :                                   {$$ = TrCreateLeafNode (PARSEOP_READWRITETYPE_BOTH);}
+    | PARSEOP_READWRITETYPE_BOTH        {$$ = TrCreateLeafNode (PARSEOP_READWRITETYPE_BOTH);}
+    | PARSEOP_READWRITETYPE_READONLY    {$$ = TrCreateLeafNode (PARSEOP_READWRITETYPE_READONLY);}
+    ;
+
+OptionalResourceType_First
+    :                               {$$ = TrCreateLeafNode (PARSEOP_RESOURCETYPE_CONSUMER);}
+    | ResourceTypeKeyword           {$$ = $1;}
+    ;
+
+OptionalResourceType
+    :                               {$$ = TrCreateLeafNode (PARSEOP_RESOURCETYPE_CONSUMER);}
+    | ','                           {$$ = TrCreateLeafNode (PARSEOP_RESOURCETYPE_CONSUMER);}
+    | ',' ResourceTypeKeyword       {$$ = $2;}
+    ;
+
+OptionalSlaveMode
+    : ','                           {$$ = NULL;}
+    | ',' SlaveModeKeyword          {$$ = $2;}
+    ;
+
+OptionalShareType
+    :                               {$$ = NULL;}
+    | ','                           {$$ = NULL;}
+    | ',' ShareTypeKeyword          {$$ = $2;}
+    ;
+
+OptionalShareType_First
+    :                               {$$ = NULL;}
+    | ShareTypeKeyword              {$$ = $1;}
+    ;
+
+OptionalStopBits
+    : ','                           {$$ = NULL;}
+    | ',' StopBitsKeyword           {$$ = $2;}
+    ;
+
+OptionalStringData
+    :                               {$$ = NULL;}
+    | ','                           {$$ = NULL;}
+    | ',' StringData                {$$ = $2;}
+    ;
+
+OptionalTranslationType_Last
+    :                               {$$ = NULL;}
+    | ','                           {$$ = NULL;}
+    | ',' TranslationKeyword        {$$ = $2;}
+    ;
+
+OptionalType
+    :                               {$$ = NULL;}
+    | ','                           {$$ = NULL;}
+    | ',' TypeKeyword               {$$ = $2;}
+    ;
+
+OptionalType_Last
+    :                               {$$ = NULL;}
+    | ','                           {$$ = NULL;}
+    | ',' TypeKeyword               {$$ = $2;}
+    ;
+
+OptionalWireMode
+    : ','                           {$$ = NULL;}
+    | ',' WireModeKeyword           {$$ = $2;}
+    ;
+
+OptionalWordConstExpr
+    : ','                           {$$ = NULL;}
+    | ',' WordConstExpr             {$$ = $2;}
+    ;
+
+OptionalXferSize
+    :                               {$$ = TrCreateValuedLeafNode (PARSEOP_XFERSIZE_32, 2);}
+    | ','                           {$$ = TrCreateValuedLeafNode (PARSEOP_XFERSIZE_32, 2);}
+    | ',' XferSizeKeyword           {$$ = $2;}
+    ;
diff --git a/usr/src/cmd/acpi/iasl/aslrestype1.c b/usr/src/cmd/acpi/iasl/aslrestype1.c
new file mode 100644
index 0000000000..4bd9059781
--- /dev/null
+++ b/usr/src/cmd/acpi/iasl/aslrestype1.c
@@ -0,0 +1,641 @@
+/******************************************************************************
+ *
+ * Module Name: aslrestype1 - Miscellaneous small resource descriptors
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2016, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include "aslcompiler.h"
+#include "aslcompiler.y.h"
+
+#define _COMPONENT          ACPI_COMPILER
+        ACPI_MODULE_NAME    ("aslrestype1")
+
+/*
+ * This module contains miscellaneous small resource descriptors:
+ *
+ * EndTag
+ * EndDependentFn
+ * Memory24
+ * Memory32
+ * Memory32Fixed
+ * StartDependentFn
+ * StartDependentFnNoPri
+ * VendorShort
+ */
+
+/*******************************************************************************
+ *
+ * FUNCTION:    RsDoEndTagDescriptor
+ *
+ * PARAMETERS:  Info                - Parse Op and resource template offset
+ *
+ * RETURN:      Completed resource node
+ *
+ * DESCRIPTION: Construct a short "EndDependentFn" descriptor
+ *
+ ******************************************************************************/
+
+ASL_RESOURCE_NODE *
+RsDoEndTagDescriptor (
+    ASL_RESOURCE_INFO       *Info)
+{
+    AML_RESOURCE            *Descriptor;
+    ASL_RESOURCE_NODE       *Rnode;
+
+
+    Rnode = RsAllocateResourceNode (sizeof (AML_RESOURCE_END_TAG));
+
+    Descriptor = Rnode->Buffer;
+    Descriptor->EndTag.DescriptorType = ACPI_RESOURCE_NAME_END_TAG |
+                                        ASL_RDESC_END_TAG_SIZE;
+    Descriptor->EndTag.Checksum = 0;
+    return (Rnode);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    RsDoEndDependentDescriptor
+ *
+ * PARAMETERS:  Info                - Parse Op and resource template offset
+ *
+ * RETURN:      Completed resource node
+ *
+ * DESCRIPTION: Construct a short "EndDependentFn" descriptor
+ *
+ ******************************************************************************/
+
+ASL_RESOURCE_NODE *
+RsDoEndDependentDescriptor (
+    ASL_RESOURCE_INFO       *Info)
+{
+    AML_RESOURCE            *Descriptor;
+    ASL_RESOURCE_NODE       *Rnode;
+
+
+    Rnode = RsAllocateResourceNode (sizeof (AML_RESOURCE_END_DEPENDENT));
+
+    Descriptor = Rnode->Buffer;
+    Descriptor->EndDpf.DescriptorType =
+        ACPI_RESOURCE_NAME_END_DEPENDENT | ASL_RDESC_END_DEPEND_SIZE;
+    return (Rnode);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    RsDoMemory24Descriptor
+ *
+ * PARAMETERS:  Info                - Parse Op and resource template offset
+ *
+ * RETURN:      Completed resource node
+ *
+ * DESCRIPTION: Construct a short "Memory24" descriptor
+ *
+ ******************************************************************************/
+
+ASL_RESOURCE_NODE *
+RsDoMemory24Descriptor (
+    ASL_RESOURCE_INFO       *Info)
+{
+    AML_RESOURCE            *Descriptor;
+    ACPI_PARSE_OBJECT       *InitializerOp;
+    ACPI_PARSE_OBJECT       *MinOp = NULL;
+    ACPI_PARSE_OBJECT       *MaxOp = NULL;
+    ACPI_PARSE_OBJECT       *LengthOp = NULL;
+    ASL_RESOURCE_NODE       *Rnode;
+    UINT32                  CurrentByteOffset;
+    UINT32                  i;
+
+
+    InitializerOp = Info->DescriptorTypeOp->Asl.Child;
+    CurrentByteOffset = Info->CurrentByteOffset;
+    Rnode = RsAllocateResourceNode (sizeof (AML_RESOURCE_MEMORY24));
+
+    Descriptor = Rnode->Buffer;
+    Descriptor->Memory24.DescriptorType = ACPI_RESOURCE_NAME_MEMORY24;
+    Descriptor->Memory24.ResourceLength = 9;
+
+    /* Process all child initialization nodes */
+
+    for (i = 0; InitializerOp; i++)
+    {
+        switch (i)
+        {
+        case 0: /* Read/Write type */
+
+            RsSetFlagBits (&Descriptor->Memory24.Flags, InitializerOp, 0, 1);
+            RsCreateBitField (InitializerOp, ACPI_RESTAG_READWRITETYPE,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (Memory24.Flags), 0);
+            break;
+
+        case 1: /* Min Address */
+
+            Descriptor->Memory24.Minimum = (UINT16) InitializerOp->Asl.Value.Integer;
+            RsCreateWordField (InitializerOp, ACPI_RESTAG_MINADDR,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (Memory24.Minimum));
+            MinOp = InitializerOp;
+            break;
+
+        case 2: /* Max Address */
+
+            Descriptor->Memory24.Maximum = (UINT16) InitializerOp->Asl.Value.Integer;
+            RsCreateWordField (InitializerOp, ACPI_RESTAG_MAXADDR,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (Memory24.Maximum));
+            MaxOp = InitializerOp;
+            break;
+
+        case 3: /* Alignment */
+
+            Descriptor->Memory24.Alignment = (UINT16) InitializerOp->Asl.Value.Integer;
+            RsCreateWordField (InitializerOp, ACPI_RESTAG_ALIGNMENT,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (Memory24.Alignment));
+            break;
+
+        case 4: /* Length */
+
+            Descriptor->Memory24.AddressLength = (UINT16) InitializerOp->Asl.Value.Integer;
+            RsCreateWordField (InitializerOp, ACPI_RESTAG_LENGTH,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (Memory24.AddressLength));
+            LengthOp = InitializerOp;
+            break;
+
+        case 5: /* Name */
+
+            UtAttachNamepathToOwner (Info->DescriptorTypeOp, InitializerOp);
+            break;
+
+        default:
+
+            AslError (ASL_ERROR, ASL_MSG_RESOURCE_LIST, InitializerOp, NULL);
+            break;
+        }
+
+        InitializerOp = RsCompleteNodeAndGetNext (InitializerOp);
+    }
+
+    /* Validate the Min/Max/Len/Align values (Alignment==0 means 64K) */
+
+    RsSmallAddressCheck (ACPI_RESOURCE_NAME_MEMORY24,
+        Descriptor->Memory24.Minimum,
+        Descriptor->Memory24.Maximum,
+        Descriptor->Memory24.AddressLength,
+        Descriptor->Memory24.Alignment,
+        MinOp, MaxOp, LengthOp, NULL, Info->DescriptorTypeOp);
+
+    return (Rnode);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    RsDoMemory32Descriptor
+ *
+ * PARAMETERS:  Info                - Parse Op and resource template offset
+ *
+ * RETURN:      Completed resource node
+ *
+ * DESCRIPTION: Construct a short "Memory32" descriptor
+ *
+ ******************************************************************************/
+
+ASL_RESOURCE_NODE *
+RsDoMemory32Descriptor (
+    ASL_RESOURCE_INFO       *Info)
+{
+    AML_RESOURCE            *Descriptor;
+    ACPI_PARSE_OBJECT       *InitializerOp;
+    ACPI_PARSE_OBJECT       *MinOp = NULL;
+    ACPI_PARSE_OBJECT       *MaxOp = NULL;
+    ACPI_PARSE_OBJECT       *LengthOp = NULL;
+    ACPI_PARSE_OBJECT       *AlignOp = NULL;
+    ASL_RESOURCE_NODE       *Rnode;
+    UINT32                  CurrentByteOffset;
+    UINT32                  i;
+
+
+    InitializerOp = Info->DescriptorTypeOp->Asl.Child;
+    CurrentByteOffset = Info->CurrentByteOffset;
+    Rnode = RsAllocateResourceNode (sizeof (AML_RESOURCE_MEMORY32));
+
+    Descriptor = Rnode->Buffer;
+    Descriptor->Memory32.DescriptorType = ACPI_RESOURCE_NAME_MEMORY32;
+    Descriptor->Memory32.ResourceLength = 17;
+
+    /* Process all child initialization nodes */
+
+    for (i = 0; InitializerOp; i++)
+    {
+        switch (i)
+        {
+        case 0: /* Read/Write type */
+
+            RsSetFlagBits (&Descriptor->Memory32.Flags, InitializerOp, 0, 1);
+            RsCreateBitField (InitializerOp, ACPI_RESTAG_READWRITETYPE,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (Memory32.Flags), 0);
+            break;
+
+        case 1:  /* Min Address */
+
+            Descriptor->Memory32.Minimum = (UINT32) InitializerOp->Asl.Value.Integer;
+            RsCreateDwordField (InitializerOp, ACPI_RESTAG_MINADDR,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (Memory32.Minimum));
+            MinOp = InitializerOp;
+            break;
+
+        case 2: /* Max Address */
+
+            Descriptor->Memory32.Maximum = (UINT32) InitializerOp->Asl.Value.Integer;
+            RsCreateDwordField (InitializerOp, ACPI_RESTAG_MAXADDR,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (Memory32.Maximum));
+            MaxOp = InitializerOp;
+            break;
+
+        case 3: /* Alignment */
+
+            Descriptor->Memory32.Alignment = (UINT32) InitializerOp->Asl.Value.Integer;
+            RsCreateDwordField (InitializerOp, ACPI_RESTAG_ALIGNMENT,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (Memory32.Alignment));
+            AlignOp = InitializerOp;
+            break;
+
+        case 4: /* Length */
+
+            Descriptor->Memory32.AddressLength = (UINT32) InitializerOp->Asl.Value.Integer;
+            RsCreateDwordField (InitializerOp, ACPI_RESTAG_LENGTH,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (Memory32.AddressLength));
+            LengthOp = InitializerOp;
+            break;
+
+        case 5: /* Name */
+
+            UtAttachNamepathToOwner (Info->DescriptorTypeOp, InitializerOp);
+            break;
+
+        default:
+
+            AslError (ASL_ERROR, ASL_MSG_RESOURCE_LIST, InitializerOp, NULL);
+            break;
+        }
+
+        InitializerOp = RsCompleteNodeAndGetNext (InitializerOp);
+    }
+
+    /* Validate the Min/Max/Len/Align values */
+
+    RsSmallAddressCheck (ACPI_RESOURCE_NAME_MEMORY32,
+        Descriptor->Memory32.Minimum,
+        Descriptor->Memory32.Maximum,
+        Descriptor->Memory32.AddressLength,
+        Descriptor->Memory32.Alignment,
+        MinOp, MaxOp, LengthOp, AlignOp, Info->DescriptorTypeOp);
+
+    return (Rnode);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    RsDoMemory32FixedDescriptor
+ *
+ * PARAMETERS:  Info                - Parse Op and resource template offset
+ *
+ * RETURN:      Completed resource node
+ *
+ * DESCRIPTION: Construct a short "Memory32Fixed" descriptor
+ *
+ ******************************************************************************/
+
+ASL_RESOURCE_NODE *
+RsDoMemory32FixedDescriptor (
+    ASL_RESOURCE_INFO       *Info)
+{
+    AML_RESOURCE            *Descriptor;
+    ACPI_PARSE_OBJECT       *InitializerOp;
+    ASL_RESOURCE_NODE       *Rnode;
+    UINT32                  CurrentByteOffset;
+    UINT32                  i;
+
+
+    InitializerOp = Info->DescriptorTypeOp->Asl.Child;
+    CurrentByteOffset = Info->CurrentByteOffset;
+    Rnode = RsAllocateResourceNode (sizeof (AML_RESOURCE_FIXED_MEMORY32));
+
+    Descriptor = Rnode->Buffer;
+    Descriptor->FixedMemory32.DescriptorType = ACPI_RESOURCE_NAME_FIXED_MEMORY32;
+    Descriptor->FixedMemory32.ResourceLength = 9;
+
+    /* Process all child initialization nodes */
+
+    for (i = 0; InitializerOp; i++)
+    {
+        switch (i)
+        {
+        case 0: /* Read/Write type */
+
+            RsSetFlagBits (&Descriptor->FixedMemory32.Flags, InitializerOp, 0, 1);
+            RsCreateBitField (InitializerOp, ACPI_RESTAG_READWRITETYPE,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (FixedMemory32.Flags), 0);
+            break;
+
+        case 1: /* Address */
+
+            Descriptor->FixedMemory32.Address = (UINT32) InitializerOp->Asl.Value.Integer;
+            RsCreateDwordField (InitializerOp, ACPI_RESTAG_BASEADDRESS,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (FixedMemory32.Address));
+            break;
+
+        case 2: /* Length */
+
+            Descriptor->FixedMemory32.AddressLength = (UINT32) InitializerOp->Asl.Value.Integer;
+            RsCreateDwordField (InitializerOp, ACPI_RESTAG_LENGTH,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (FixedMemory32.AddressLength));
+            break;
+
+        case 3: /* Name */
+
+            UtAttachNamepathToOwner (Info->DescriptorTypeOp, InitializerOp);
+            break;
+
+        default:
+
+            AslError (ASL_ERROR, ASL_MSG_RESOURCE_LIST, InitializerOp, NULL);
+            break;
+        }
+
+        InitializerOp = RsCompleteNodeAndGetNext (InitializerOp);
+    }
+
+    return (Rnode);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    RsDoStartDependentDescriptor
+ *
+ * PARAMETERS:  Info                - Parse Op and resource template offset
+ *
+ * RETURN:      Completed resource node
+ *
+ * DESCRIPTION: Construct a short "StartDependentFn" descriptor
+ *
+ ******************************************************************************/
+
+ASL_RESOURCE_NODE *
+RsDoStartDependentDescriptor (
+    ASL_RESOURCE_INFO       *Info)
+{
+    AML_RESOURCE            *Descriptor;
+    ACPI_PARSE_OBJECT       *InitializerOp;
+    ASL_RESOURCE_NODE       *Rnode;
+    ASL_RESOURCE_NODE       *PreviousRnode;
+    ASL_RESOURCE_NODE       *NextRnode;
+    ASL_RESOURCE_INFO       NextInfo;
+    UINT32                  CurrentByteOffset;
+    UINT32                  i;
+    UINT8                   State;
+
+
+    InitializerOp = Info->DescriptorTypeOp->Asl.Child;
+    CurrentByteOffset = Info->CurrentByteOffset;
+    Rnode = RsAllocateResourceNode (sizeof (AML_RESOURCE_START_DEPENDENT));
+
+    PreviousRnode = Rnode;
+    Descriptor = Rnode->Buffer;
+
+    /* Increment offset past StartDependent descriptor */
+
+    CurrentByteOffset += sizeof (AML_RESOURCE_START_DEPENDENT);
+
+    /* Descriptor has priority byte */
+
+    Descriptor->StartDpf.DescriptorType =
+        ACPI_RESOURCE_NAME_START_DEPENDENT | (ASL_RDESC_ST_DEPEND_SIZE + 0x01);
+
+    /* Process all child initialization nodes */
+
+    State = ACPI_RSTATE_START_DEPENDENT;
+    for (i = 0; InitializerOp; i++)
+    {
+        switch (i)
+        {
+        case 0: /* Compatibility Priority */
+
+            if ((UINT8) InitializerOp->Asl.Value.Integer > 2)
+            {
+                AslError (ASL_ERROR, ASL_MSG_INVALID_PRIORITY,
+                    InitializerOp, NULL);
+            }
+
+            RsSetFlagBits (&Descriptor->StartDpf.Flags, InitializerOp, 0, 0);
+            break;
+
+        case 1: /* Performance/Robustness Priority */
+
+            if ((UINT8) InitializerOp->Asl.Value.Integer > 2)
+            {
+                AslError (ASL_ERROR, ASL_MSG_INVALID_PERFORMANCE,
+                    InitializerOp, NULL);
+            }
+
+            RsSetFlagBits (&Descriptor->StartDpf.Flags, InitializerOp, 2, 0);
+            break;
+
+        default:
+
+            NextInfo.CurrentByteOffset = CurrentByteOffset;
+            NextInfo.DescriptorTypeOp = InitializerOp;
+
+            NextRnode = RsDoOneResourceDescriptor (&NextInfo, &State);
+
+            /*
+             * Update current byte offset to indicate the number of bytes from the
+             * start of the buffer. Buffer can include multiple descriptors, we
+             * must keep track of the offset of not only each descriptor, but each
+             * element (field) within each descriptor as well.
+             */
+            CurrentByteOffset += RsLinkDescriptorChain (
+                &PreviousRnode, NextRnode);
+            break;
+        }
+
+        InitializerOp = RsCompleteNodeAndGetNext (InitializerOp);
+    }
+
+    return (Rnode);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    RsDoStartDependentNoPriDescriptor
+ *
+ * PARAMETERS:  Info                - Parse Op and resource template offset
+ *
+ * RETURN:      Completed resource node
+ *
+ * DESCRIPTION: Construct a short "StartDependentNoPri" descriptor
+ *
+ ******************************************************************************/
+
+ASL_RESOURCE_NODE *
+RsDoStartDependentNoPriDescriptor (
+    ASL_RESOURCE_INFO       *Info)
+{
+    AML_RESOURCE            *Descriptor;
+    ACPI_PARSE_OBJECT       *InitializerOp;
+    ASL_RESOURCE_NODE       *Rnode;
+    ASL_RESOURCE_NODE       *PreviousRnode;
+    ASL_RESOURCE_NODE       *NextRnode;
+    ASL_RESOURCE_INFO       NextInfo;
+    UINT32                  CurrentByteOffset;
+    UINT8                   State;
+
+
+    InitializerOp = Info->DescriptorTypeOp->Asl.Child;
+    CurrentByteOffset = Info->CurrentByteOffset;
+    Rnode = RsAllocateResourceNode (sizeof (AML_RESOURCE_START_DEPENDENT_NOPRIO));
+
+    Descriptor = Rnode->Buffer;
+    Descriptor->StartDpf.DescriptorType =
+        ACPI_RESOURCE_NAME_START_DEPENDENT | ASL_RDESC_ST_DEPEND_SIZE;
+    PreviousRnode = Rnode;
+
+    /* Increment offset past StartDependentNoPri descriptor */
+
+    CurrentByteOffset += sizeof (AML_RESOURCE_START_DEPENDENT_NOPRIO);
+
+    /* Process all child initialization nodes */
+
+    State = ACPI_RSTATE_START_DEPENDENT;
+    while (InitializerOp)
+    {
+        NextInfo.CurrentByteOffset = CurrentByteOffset;
+        NextInfo.DescriptorTypeOp = InitializerOp;
+
+        NextRnode = RsDoOneResourceDescriptor (&NextInfo, &State);
+
+        /*
+         * Update current byte offset to indicate the number of bytes from the
+         * start of the buffer. Buffer can include multiple descriptors, we
+         * must keep track of the offset of not only each descriptor, but each
+         * element (field) within each descriptor as well.
+         */
+        CurrentByteOffset += RsLinkDescriptorChain (&PreviousRnode, NextRnode);
+
+        InitializerOp = RsCompleteNodeAndGetNext (InitializerOp);
+    }
+
+    return (Rnode);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    RsDoVendorSmallDescriptor
+ *
+ * PARAMETERS:  Info                - Parse Op and resource template offset
+ *
+ * RETURN:      Completed resource node
+ *
+ * DESCRIPTION: Construct a short "VendorShort" descriptor
+ *
+ ******************************************************************************/
+
+ASL_RESOURCE_NODE *
+RsDoVendorSmallDescriptor (
+    ASL_RESOURCE_INFO       *Info)
+{
+    AML_RESOURCE            *Descriptor;
+    ACPI_PARSE_OBJECT       *InitializerOp;
+    ASL_RESOURCE_NODE       *Rnode;
+    UINT8                   *VendorData;
+    UINT32                  i;
+
+
+    InitializerOp = Info->DescriptorTypeOp->Asl.Child;
+
+    /* Allocate worst case - 7 vendor bytes */
+
+    Rnode = RsAllocateResourceNode (sizeof (AML_RESOURCE_VENDOR_SMALL) + 7);
+
+    Descriptor = Rnode->Buffer;
+    Descriptor->VendorSmall.DescriptorType = ACPI_RESOURCE_NAME_VENDOR_SMALL;
+    VendorData = ((UINT8 *) Descriptor) + sizeof (AML_RESOURCE_SMALL_HEADER);
+
+    /* Process all child initialization nodes */
+
+    InitializerOp = RsCompleteNodeAndGetNext (InitializerOp);
+    for (i = 0; InitializerOp; i++)
+    {
+        if (InitializerOp->Asl.ParseOpcode == PARSEOP_DEFAULT_ARG)
+        {
+            break;
+        }
+
+        /* Maximum 7 vendor data bytes allowed (0-6) */
+
+        if (i >= 7)
+        {
+            AslError (ASL_ERROR, ASL_MSG_VENDOR_LIST, InitializerOp, NULL);
+
+            /* Eat the excess initializers */
+
+            while (InitializerOp)
+            {
+                InitializerOp = RsCompleteNodeAndGetNext (InitializerOp);
+            }
+            break;
+        }
+
+        VendorData[i] = (UINT8) InitializerOp->Asl.Value.Integer;
+        InitializerOp = RsCompleteNodeAndGetNext (InitializerOp);
+    }
+
+    /* Adjust the Rnode buffer size, so correct number of bytes are emitted */
+
+    Rnode->BufferLength -= (7 - i);
+
+    /* Set the length in the Type Tag */
+
+    Descriptor->VendorSmall.DescriptorType |= (UINT8) i;
+    return (Rnode);
+}
diff --git a/usr/src/cmd/acpi/iasl/aslrestype1i.c b/usr/src/cmd/acpi/iasl/aslrestype1i.c
new file mode 100644
index 0000000000..0f38e40da6
--- /dev/null
+++ b/usr/src/cmd/acpi/iasl/aslrestype1i.c
@@ -0,0 +1,665 @@
+/******************************************************************************
+ *
+ * Module Name: aslrestype1i - Small I/O-related resource descriptors
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2016, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include "aslcompiler.h"
+#include "aslcompiler.y.h"
+
+#define _COMPONENT          ACPI_COMPILER
+        ACPI_MODULE_NAME    ("aslrestype1i")
+
+/*
+ * This module contains the I/O-related small resource descriptors:
+ *
+ * DMA
+ * FixedDMA
+ * FixedIO
+ * IO
+ * IRQ
+ * IRQNoFlags
+ */
+
+/*******************************************************************************
+ *
+ * FUNCTION:    RsDoDmaDescriptor
+ *
+ * PARAMETERS:  Info                - Parse Op and resource template offset
+ *
+ * RETURN:      Completed resource node
+ *
+ * DESCRIPTION: Construct a short "DMA" descriptor
+ *
+ ******************************************************************************/
+
+ASL_RESOURCE_NODE *
+RsDoDmaDescriptor (
+    ASL_RESOURCE_INFO       *Info)
+{
+    AML_RESOURCE            *Descriptor;
+    ACPI_PARSE_OBJECT       *InitializerOp;
+    ASL_RESOURCE_NODE       *Rnode;
+    UINT32                  CurrentByteOffset;
+    UINT32                  i;
+    UINT8                   DmaChannelMask = 0;
+    UINT8                   DmaChannels = 0;
+
+
+    InitializerOp = Info->DescriptorTypeOp->Asl.Child;
+    CurrentByteOffset = Info->CurrentByteOffset;
+    Rnode = RsAllocateResourceNode (sizeof (AML_RESOURCE_DMA));
+
+    Descriptor = Rnode->Buffer;
+    Descriptor->Dma.DescriptorType =
+        ACPI_RESOURCE_NAME_DMA | ASL_RDESC_DMA_SIZE;
+
+    /* Process all child initialization nodes */
+
+    for (i = 0; InitializerOp; i++)
+    {
+        switch (i)
+        {
+        case 0: /* DMA type */
+
+            RsSetFlagBits (&Descriptor->Dma.Flags, InitializerOp, 5, 0);
+            RsCreateMultiBitField (InitializerOp, ACPI_RESTAG_DMATYPE,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (Dma.Flags), 5, 2);
+            break;
+
+        case 1: /* Bus Master */
+
+            RsSetFlagBits (&Descriptor->Dma.Flags, InitializerOp, 2, 0);
+            RsCreateBitField (InitializerOp, ACPI_RESTAG_BUSMASTER,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (Dma.Flags), 2);
+            break;
+
+        case 2: /* Xfer Type (transfer width) */
+
+            RsSetFlagBits (&Descriptor->Dma.Flags, InitializerOp, 0, 0);
+            RsCreateMultiBitField (InitializerOp, ACPI_RESTAG_XFERTYPE,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (Dma.Flags), 0, 2);
+            break;
+
+        case 3: /* Name */
+
+            UtAttachNamepathToOwner (Info->DescriptorTypeOp, InitializerOp);
+            break;
+
+        default:
+
+            /* All DMA channel bytes are handled here, after flags and name */
+
+            if (InitializerOp->Asl.ParseOpcode != PARSEOP_DEFAULT_ARG)
+            {
+                /* Up to 8 channels can be specified in the list */
+
+                DmaChannels++;
+                if (DmaChannels > 8)
+                {
+                    AslError (ASL_ERROR, ASL_MSG_DMA_LIST,
+                        InitializerOp, NULL);
+                    return (Rnode);
+                }
+
+                /* Only DMA channels 0-7 are allowed (mask is 8 bits) */
+
+                if (InitializerOp->Asl.Value.Integer > 7)
+                {
+                    AslError (ASL_ERROR, ASL_MSG_DMA_CHANNEL,
+                        InitializerOp, NULL);
+                }
+
+                /* Build the mask */
+
+                DmaChannelMask |=
+                    (1 << ((UINT8) InitializerOp->Asl.Value.Integer));
+            }
+
+            if (i == 4) /* case 4: First DMA byte */
+            {
+                /* Check now for duplicates in list */
+
+                RsCheckListForDuplicates (InitializerOp);
+
+                /* Create a named field at the start of the list */
+
+                RsCreateByteField (InitializerOp, ACPI_RESTAG_DMA,
+                    CurrentByteOffset +
+                    ASL_RESDESC_OFFSET (Dma.DmaChannelMask));
+            }
+            break;
+        }
+
+        InitializerOp = RsCompleteNodeAndGetNext (InitializerOp);
+    }
+
+    /* Now we can set the channel mask */
+
+    Descriptor->Dma.DmaChannelMask = DmaChannelMask;
+    return (Rnode);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    RsDoFixedDmaDescriptor
+ *
+ * PARAMETERS:  Info                - Parse Op and resource template offset
+ *
+ * RETURN:      Completed resource node
+ *
+ * DESCRIPTION: Construct a short "FixedDMA" descriptor
+ *
+ ******************************************************************************/
+
+ASL_RESOURCE_NODE *
+RsDoFixedDmaDescriptor (
+    ASL_RESOURCE_INFO       *Info)
+{
+    AML_RESOURCE            *Descriptor;
+    ACPI_PARSE_OBJECT       *InitializerOp;
+    ASL_RESOURCE_NODE       *Rnode;
+    UINT32                  CurrentByteOffset;
+    UINT32                  i;
+
+
+    InitializerOp = Info->DescriptorTypeOp->Asl.Child;
+    CurrentByteOffset = Info->CurrentByteOffset;
+    Rnode = RsAllocateResourceNode (sizeof (AML_RESOURCE_FIXED_DMA));
+
+    Descriptor = Rnode->Buffer;
+    Descriptor->FixedDma.DescriptorType =
+        ACPI_RESOURCE_NAME_FIXED_DMA | ASL_RDESC_FIXED_DMA_SIZE;
+
+    /* Process all child initialization nodes */
+
+    for (i = 0; InitializerOp; i++)
+    {
+        switch (i)
+        {
+        case 0: /* DMA Request Lines [WORD] (_DMA) */
+
+            Descriptor->FixedDma.RequestLines = (UINT16) InitializerOp->Asl.Value.Integer;
+            RsCreateWordField (InitializerOp, ACPI_RESTAG_DMA,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (FixedDma.RequestLines));
+            break;
+
+        case 1: /* DMA Channel [WORD] (_TYP) */
+
+            Descriptor->FixedDma.Channels = (UINT16) InitializerOp->Asl.Value.Integer;
+            RsCreateWordField (InitializerOp, ACPI_RESTAG_DMATYPE,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (FixedDma.Channels));
+            break;
+
+        case 2: /* Transfer Width [BYTE] (_SIZ) */
+
+            Descriptor->FixedDma.Width = (UINT8) InitializerOp->Asl.Value.Integer;
+            RsCreateByteField (InitializerOp, ACPI_RESTAG_XFERTYPE,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (FixedDma.Width));
+            break;
+
+        case 3: /* Descriptor Name (optional) */
+
+            UtAttachNamepathToOwner (Info->DescriptorTypeOp, InitializerOp);
+            break;
+
+        default:    /* Ignore any extra nodes */
+
+            break;
+        }
+
+        InitializerOp = RsCompleteNodeAndGetNext (InitializerOp);
+    }
+
+    return (Rnode);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    RsDoFixedIoDescriptor
+ *
+ * PARAMETERS:  Info                - Parse Op and resource template offset
+ *
+ * RETURN:      Completed resource node
+ *
+ * DESCRIPTION: Construct a short "FixedIO" descriptor
+ *
+ ******************************************************************************/
+
+ASL_RESOURCE_NODE *
+RsDoFixedIoDescriptor (
+    ASL_RESOURCE_INFO       *Info)
+{
+    AML_RESOURCE            *Descriptor;
+    ACPI_PARSE_OBJECT       *InitializerOp;
+    ACPI_PARSE_OBJECT       *AddressOp = NULL;
+    ASL_RESOURCE_NODE       *Rnode;
+    UINT32                  CurrentByteOffset;
+    UINT32                  i;
+
+
+    InitializerOp = Info->DescriptorTypeOp->Asl.Child;
+    CurrentByteOffset = Info->CurrentByteOffset;
+    Rnode = RsAllocateResourceNode (sizeof (AML_RESOURCE_FIXED_IO));
+
+    Descriptor = Rnode->Buffer;
+    Descriptor->Io.DescriptorType =
+        ACPI_RESOURCE_NAME_FIXED_IO | ASL_RDESC_FIXED_IO_SIZE;
+
+    /* Process all child initialization nodes */
+
+    for (i = 0; InitializerOp; i++)
+    {
+        switch (i)
+        {
+        case 0: /* Base Address */
+
+            Descriptor->FixedIo.Address =
+                (UINT16) InitializerOp->Asl.Value.Integer;
+            RsCreateWordField (InitializerOp, ACPI_RESTAG_BASEADDRESS,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (FixedIo.Address));
+            AddressOp = InitializerOp;
+            break;
+
+        case 1: /* Length */
+
+            Descriptor->FixedIo.AddressLength =
+                (UINT8) InitializerOp->Asl.Value.Integer;
+            RsCreateByteField (InitializerOp, ACPI_RESTAG_LENGTH,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (FixedIo.AddressLength));
+            break;
+
+        case 2: /* Name */
+
+            UtAttachNamepathToOwner (Info->DescriptorTypeOp, InitializerOp);
+            break;
+
+        default:
+
+            AslError (ASL_ERROR, ASL_MSG_RESOURCE_LIST, InitializerOp, NULL);
+            break;
+        }
+
+        InitializerOp = RsCompleteNodeAndGetNext (InitializerOp);
+    }
+
+    /* Error checks */
+
+    if (Descriptor->FixedIo.Address > 0x03FF)
+    {
+        AslError (ASL_WARNING, ASL_MSG_ISA_ADDRESS, AddressOp, NULL);
+    }
+
+    return (Rnode);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    RsDoIoDescriptor
+ *
+ * PARAMETERS:  Info                - Parse Op and resource template offset
+ *
+ * RETURN:      Completed resource node
+ *
+ * DESCRIPTION: Construct a short "IO" descriptor
+ *
+ ******************************************************************************/
+
+ASL_RESOURCE_NODE *
+RsDoIoDescriptor (
+    ASL_RESOURCE_INFO       *Info)
+{
+    AML_RESOURCE            *Descriptor;
+    ACPI_PARSE_OBJECT       *InitializerOp;
+    ACPI_PARSE_OBJECT       *MinOp = NULL;
+    ACPI_PARSE_OBJECT       *MaxOp = NULL;
+    ACPI_PARSE_OBJECT       *LengthOp = NULL;
+    ACPI_PARSE_OBJECT       *AlignOp = NULL;
+    ASL_RESOURCE_NODE       *Rnode;
+    UINT32                  CurrentByteOffset;
+    UINT32                  i;
+
+
+    InitializerOp = Info->DescriptorTypeOp->Asl.Child;
+    CurrentByteOffset = Info->CurrentByteOffset;
+    Rnode = RsAllocateResourceNode (sizeof (AML_RESOURCE_IO));
+
+    Descriptor = Rnode->Buffer;
+    Descriptor->Io.DescriptorType =
+        ACPI_RESOURCE_NAME_IO | ASL_RDESC_IO_SIZE;
+
+    /* Process all child initialization nodes */
+
+    for (i = 0; InitializerOp; i++)
+    {
+        switch (i)
+        {
+        case 0: /* Decode size */
+
+            RsSetFlagBits (&Descriptor->Io.Flags, InitializerOp, 0, 1);
+            RsCreateBitField (InitializerOp, ACPI_RESTAG_DECODE,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (Io.Flags), 0);
+            break;
+
+        case 1:  /* Min Address */
+
+            Descriptor->Io.Minimum =
+                (UINT16) InitializerOp->Asl.Value.Integer;
+            RsCreateWordField (InitializerOp, ACPI_RESTAG_MINADDR,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (Io.Minimum));
+            MinOp = InitializerOp;
+            break;
+
+        case 2: /* Max Address */
+
+            Descriptor->Io.Maximum =
+                (UINT16) InitializerOp->Asl.Value.Integer;
+            RsCreateWordField (InitializerOp, ACPI_RESTAG_MAXADDR,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (Io.Maximum));
+            MaxOp = InitializerOp;
+            break;
+
+        case 3: /* Alignment */
+
+            Descriptor->Io.Alignment =
+                (UINT8) InitializerOp->Asl.Value.Integer;
+            RsCreateByteField (InitializerOp, ACPI_RESTAG_ALIGNMENT,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (Io.Alignment));
+            AlignOp = InitializerOp;
+            break;
+
+        case 4: /* Length */
+
+            Descriptor->Io.AddressLength =
+                (UINT8) InitializerOp->Asl.Value.Integer;
+            RsCreateByteField (InitializerOp, ACPI_RESTAG_LENGTH,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (Io.AddressLength));
+            LengthOp = InitializerOp;
+            break;
+
+        case 5: /* Name */
+
+            UtAttachNamepathToOwner (Info->DescriptorTypeOp, InitializerOp);
+            break;
+
+        default:
+
+            AslError (ASL_ERROR, ASL_MSG_RESOURCE_LIST, InitializerOp, NULL);
+            break;
+        }
+
+        InitializerOp = RsCompleteNodeAndGetNext (InitializerOp);
+    }
+
+    /* Validate the Min/Max/Len/Align values */
+
+    RsSmallAddressCheck (ACPI_RESOURCE_NAME_IO,
+        Descriptor->Io.Minimum,
+        Descriptor->Io.Maximum,
+        Descriptor->Io.AddressLength,
+        Descriptor->Io.Alignment,
+        MinOp, MaxOp, LengthOp, AlignOp, Info->DescriptorTypeOp);
+
+    return (Rnode);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    RsDoIrqDescriptor
+ *
+ * PARAMETERS:  Info                - Parse Op and resource template offset
+ *
+ * RETURN:      Completed resource node
+ *
+ * DESCRIPTION: Construct a short "IRQ" descriptor
+ *
+ ******************************************************************************/
+
+ASL_RESOURCE_NODE *
+RsDoIrqDescriptor (
+    ASL_RESOURCE_INFO       *Info)
+{
+    AML_RESOURCE            *Descriptor;
+    ACPI_PARSE_OBJECT       *InitializerOp;
+    ASL_RESOURCE_NODE       *Rnode;
+    UINT32                  Interrupts = 0;
+    UINT16                  IrqMask = 0;
+    UINT32                  CurrentByteOffset;
+    UINT32                  i;
+
+
+    InitializerOp = Info->DescriptorTypeOp->Asl.Child;
+    CurrentByteOffset = Info->CurrentByteOffset;
+    Rnode = RsAllocateResourceNode (sizeof (AML_RESOURCE_IRQ));
+
+    /* Length = 3 (with flag byte) */
+
+    Descriptor = Rnode->Buffer;
+    Descriptor->Irq.DescriptorType =
+        ACPI_RESOURCE_NAME_IRQ | (ASL_RDESC_IRQ_SIZE + 0x01);
+
+    /* Process all child initialization nodes */
+
+    for (i = 0; InitializerOp; i++)
+    {
+        switch (i)
+        {
+        case 0: /* Interrupt Type (or Mode - edge/level) */
+
+            RsSetFlagBits (&Descriptor->Irq.Flags, InitializerOp, 0, 1);
+            RsCreateBitField (InitializerOp, ACPI_RESTAG_INTERRUPTTYPE,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (Irq.Flags), 0);
+            break;
+
+        case 1: /* Interrupt Level (or Polarity - Active high/low) */
+
+            RsSetFlagBits (&Descriptor->Irq.Flags, InitializerOp, 3, 0);
+            RsCreateBitField (InitializerOp, ACPI_RESTAG_INTERRUPTLEVEL,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (Irq.Flags), 3);
+            break;
+
+        case 2: /* Share Type - Default: exclusive (0) */
+
+            RsSetFlagBits (&Descriptor->Irq.Flags, InitializerOp, 4, 0);
+            RsCreateBitField (InitializerOp, ACPI_RESTAG_INTERRUPTSHARE,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (Irq.Flags), 4);
+            break;
+
+        case 3: /* Name */
+
+            UtAttachNamepathToOwner (Info->DescriptorTypeOp, InitializerOp);
+            break;
+
+        default:
+
+            /* All IRQ bytes are handled here, after the flags and name */
+
+            if (InitializerOp->Asl.ParseOpcode != PARSEOP_DEFAULT_ARG)
+            {
+                /* Up to 16 interrupts can be specified in the list */
+
+                Interrupts++;
+                if (Interrupts > 16)
+                {
+                    AslError (ASL_ERROR, ASL_MSG_INTERRUPT_LIST,
+                        InitializerOp, NULL);
+                    return (Rnode);
+                }
+
+                /* Only interrupts 0-15 are allowed (mask is 16 bits) */
+
+                if (InitializerOp->Asl.Value.Integer > 15)
+                {
+                    AslError (ASL_ERROR, ASL_MSG_INTERRUPT_NUMBER,
+                        InitializerOp, NULL);
+                }
+                else
+                {
+                    IrqMask |= (1 << (UINT8) InitializerOp->Asl.Value.Integer);
+                }
+            }
+
+            /* Case 4: First IRQ value in list */
+
+            if (i == 4)
+            {
+                /* Check now for duplicates in list */
+
+                RsCheckListForDuplicates (InitializerOp);
+
+                /* Create a named field at the start of the list */
+
+                RsCreateWordField (InitializerOp, ACPI_RESTAG_INTERRUPT,
+                    CurrentByteOffset + ASL_RESDESC_OFFSET (Irq.IrqMask));
+            }
+            break;
+        }
+
+        InitializerOp = RsCompleteNodeAndGetNext (InitializerOp);
+    }
+
+    /* Now we can set the channel mask */
+
+    Descriptor->Irq.IrqMask = IrqMask;
+    return (Rnode);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    RsDoIrqNoFlagsDescriptor
+ *
+ * PARAMETERS:  Info                - Parse Op and resource template offset
+ *
+ * RETURN:      Completed resource node
+ *
+ * DESCRIPTION: Construct a short "IRQNoFlags" descriptor
+ *
+ ******************************************************************************/
+
+ASL_RESOURCE_NODE *
+RsDoIrqNoFlagsDescriptor (
+    ASL_RESOURCE_INFO       *Info)
+{
+    AML_RESOURCE            *Descriptor;
+    ACPI_PARSE_OBJECT       *InitializerOp;
+    ASL_RESOURCE_NODE       *Rnode;
+    UINT16                  IrqMask = 0;
+    UINT32                  Interrupts = 0;
+    UINT32                  CurrentByteOffset;
+    UINT32                  i;
+
+
+    InitializerOp = Info->DescriptorTypeOp->Asl.Child;
+    CurrentByteOffset = Info->CurrentByteOffset;
+    Rnode = RsAllocateResourceNode (sizeof (AML_RESOURCE_IRQ_NOFLAGS));
+
+    Descriptor = Rnode->Buffer;
+    Descriptor->Irq.DescriptorType =
+        ACPI_RESOURCE_NAME_IRQ | ASL_RDESC_IRQ_SIZE;
+
+    /* Process all child initialization nodes */
+
+    for (i = 0; InitializerOp; i++)
+    {
+        switch (i)
+        {
+        case 0: /* Name */
+
+            UtAttachNamepathToOwner (Info->DescriptorTypeOp, InitializerOp);
+            break;
+
+        default:
+
+            /* IRQ bytes are handled here, after the flags and name */
+
+            if (InitializerOp->Asl.ParseOpcode != PARSEOP_DEFAULT_ARG)
+            {
+                /* Up to 16 interrupts can be specified in the list */
+
+                Interrupts++;
+                if (Interrupts > 16)
+                {
+                    AslError (ASL_ERROR, ASL_MSG_INTERRUPT_LIST,
+                        InitializerOp, NULL);
+                    return (Rnode);
+                }
+
+                /* Only interrupts 0-15 are allowed (mask is 16 bits) */
+
+                if (InitializerOp->Asl.Value.Integer > 15)
+                {
+                    AslError (ASL_ERROR, ASL_MSG_INTERRUPT_NUMBER,
+                        InitializerOp, NULL);
+                }
+                else
+                {
+                    IrqMask |= (1 << ((UINT8) InitializerOp->Asl.Value.Integer));
+                }
+            }
+
+            /* Case 1: First IRQ value in list */
+
+            if (i == 1)
+            {
+                /* Check now for duplicates in list */
+
+                RsCheckListForDuplicates (InitializerOp);
+
+                /* Create a named field at the start of the list */
+
+                RsCreateWordField (InitializerOp, ACPI_RESTAG_INTERRUPT,
+                    CurrentByteOffset + ASL_RESDESC_OFFSET (Irq.IrqMask));
+            }
+            break;
+        }
+
+        InitializerOp = RsCompleteNodeAndGetNext (InitializerOp);
+    }
+
+    /* Now we can set the interrupt mask */
+
+    Descriptor->Irq.IrqMask = IrqMask;
+    return (Rnode);
+}
diff --git a/usr/src/cmd/acpi/iasl/aslrestype2.c b/usr/src/cmd/acpi/iasl/aslrestype2.c
new file mode 100644
index 0000000000..b75c1184eb
--- /dev/null
+++ b/usr/src/cmd/acpi/iasl/aslrestype2.c
@@ -0,0 +1,457 @@
+/******************************************************************************
+ *
+ * Module Name: aslrestype2 - Miscellaneous Large resource descriptors
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2016, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include "aslcompiler.h"
+#include "aslcompiler.y.h"
+#include "amlcode.h"
+
+#define _COMPONENT          ACPI_COMPILER
+        ACPI_MODULE_NAME    ("aslrestype2")
+
+/*
+ * This module contains miscellaneous large resource descriptors:
+ *
+ * Register
+ * Interrupt
+ * VendorLong
+ */
+
+/*******************************************************************************
+ *
+ * FUNCTION:    RsDoGeneralRegisterDescriptor
+ *
+ * PARAMETERS:  Info                - Parse Op and resource template offset
+ *
+ * RETURN:      Completed resource node
+ *
+ * DESCRIPTION: Construct a long "Register" descriptor
+ *
+ ******************************************************************************/
+
+ASL_RESOURCE_NODE *
+RsDoGeneralRegisterDescriptor (
+    ASL_RESOURCE_INFO       *Info)
+{
+    AML_RESOURCE            *Descriptor;
+    ACPI_PARSE_OBJECT       *InitializerOp;
+    ASL_RESOURCE_NODE       *Rnode;
+    UINT32                  CurrentByteOffset;
+    UINT32                  i;
+
+
+    InitializerOp = Info->DescriptorTypeOp->Asl.Child;
+    CurrentByteOffset = Info->CurrentByteOffset;
+    Rnode = RsAllocateResourceNode (sizeof (AML_RESOURCE_GENERIC_REGISTER));
+
+    Descriptor = Rnode->Buffer;
+    Descriptor->GenericReg.DescriptorType = ACPI_RESOURCE_NAME_GENERIC_REGISTER;
+    Descriptor->GenericReg.ResourceLength = 12;
+
+    /* Process all child initialization nodes */
+
+    for (i = 0; InitializerOp; i++)
+    {
+        switch (i)
+        {
+        case 0: /* Address space */
+
+            Descriptor->GenericReg.AddressSpaceId = (UINT8) InitializerOp->Asl.Value.Integer;
+            RsCreateByteField (InitializerOp, ACPI_RESTAG_ADDRESSSPACE,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (GenericReg.AddressSpaceId));
+           break;
+
+        case 1: /* Register Bit Width */
+
+            Descriptor->GenericReg.BitWidth = (UINT8) InitializerOp->Asl.Value.Integer;
+            RsCreateByteField (InitializerOp, ACPI_RESTAG_REGISTERBITWIDTH,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (GenericReg.BitWidth));
+            break;
+
+        case 2: /* Register Bit Offset */
+
+            Descriptor->GenericReg.BitOffset = (UINT8) InitializerOp->Asl.Value.Integer;
+            RsCreateByteField (InitializerOp, ACPI_RESTAG_REGISTERBITOFFSET,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (GenericReg.BitOffset));
+            break;
+
+        case 3: /* Register Address */
+
+            Descriptor->GenericReg.Address = InitializerOp->Asl.Value.Integer;
+            RsCreateQwordField (InitializerOp, ACPI_RESTAG_ADDRESS,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (GenericReg.Address));
+            break;
+
+        case 4: /* Access Size (ACPI 3.0) */
+
+            Descriptor->GenericReg.AccessSize = (UINT8) InitializerOp->Asl.Value.Integer;
+            RsCreateByteField (InitializerOp, ACPI_RESTAG_ACCESSSIZE,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (GenericReg.AccessSize));
+
+            if (Descriptor->GenericReg.AccessSize > AML_FIELD_ACCESS_QWORD)
+            {
+                AslError (ASL_ERROR, ASL_MSG_INVALID_ACCESS_SIZE,
+                    InitializerOp, NULL);
+            }
+            break;
+
+        case 5: /* ResourceTag (ACPI 3.0b) */
+
+            UtAttachNamepathToOwner (Info->DescriptorTypeOp, InitializerOp);
+            break;
+
+        default:
+
+            AslError (ASL_ERROR, ASL_MSG_RESOURCE_LIST, InitializerOp, NULL);
+            break;
+        }
+
+        InitializerOp = RsCompleteNodeAndGetNext (InitializerOp);
+    }
+
+    return (Rnode);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    RsDoInterruptDescriptor
+ *
+ * PARAMETERS:  Info                - Parse Op and resource template offset
+ *
+ * RETURN:      Completed resource node
+ *
+ * DESCRIPTION: Construct a long "Interrupt" descriptor
+ *
+ ******************************************************************************/
+
+ASL_RESOURCE_NODE *
+RsDoInterruptDescriptor (
+    ASL_RESOURCE_INFO       *Info)
+{
+    AML_RESOURCE            *Descriptor;
+    AML_RESOURCE            *Rover = NULL;
+    ACPI_PARSE_OBJECT       *InitializerOp;
+    ASL_RESOURCE_NODE       *Rnode;
+    UINT16                  StringLength = 0;
+    UINT32                  OptionIndex = 0;
+    UINT32                  CurrentByteOffset;
+    UINT32                  i;
+    BOOLEAN                 HasResSourceIndex = FALSE;
+    UINT8                   ResSourceIndex = 0;
+    UINT8                   *ResSourceString = NULL;
+
+
+    InitializerOp = Info->DescriptorTypeOp->Asl.Child;
+    CurrentByteOffset = Info->CurrentByteOffset;
+    StringLength = RsGetStringDataLength (InitializerOp);
+
+    /* Count the interrupt numbers */
+
+    for (i = 0; InitializerOp; i++)
+    {
+        InitializerOp = ASL_GET_PEER_NODE (InitializerOp);
+
+        if (i <= 6)
+        {
+            if (i == 3 &&
+                InitializerOp->Asl.ParseOpcode != PARSEOP_DEFAULT_ARG)
+            {
+                /*
+                 * ResourceSourceIndex was specified, always make room for
+                 * it, even if the ResourceSource was omitted.
+                 */
+                OptionIndex++;
+            }
+
+            continue;
+        }
+
+        OptionIndex += 4;
+    }
+
+    InitializerOp = Info->DescriptorTypeOp->Asl.Child;
+    Rnode = RsAllocateResourceNode (sizeof (AML_RESOURCE_EXTENDED_IRQ) +
+        1 + OptionIndex + StringLength);
+
+    Descriptor = Rnode->Buffer;
+    Descriptor->ExtendedIrq.DescriptorType = ACPI_RESOURCE_NAME_EXTENDED_IRQ;
+
+    /*
+     * Initial descriptor length -- may be enlarged if there are
+     * optional fields present
+     */
+    Descriptor->ExtendedIrq.ResourceLength  = 2;  /* Flags and table length byte */
+    Descriptor->ExtendedIrq.InterruptCount  = 0;
+
+    Rover = ACPI_CAST_PTR (AML_RESOURCE,
+        (&(Descriptor->ExtendedIrq.Interrupts[0])));
+
+    /* Process all child initialization nodes */
+
+    for (i = 0; InitializerOp; i++)
+    {
+        switch (i)
+        {
+        case 0: /* Resource Usage (Default: consumer (1) */
+
+            RsSetFlagBits (&Descriptor->ExtendedIrq.Flags, InitializerOp, 0, 1);
+            break;
+
+        case 1: /* Interrupt Type (or Mode - edge/level) */
+
+            RsSetFlagBits (&Descriptor->ExtendedIrq.Flags, InitializerOp, 1, 0);
+            RsCreateBitField (InitializerOp, ACPI_RESTAG_INTERRUPTTYPE,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (ExtendedIrq.Flags), 1);
+            break;
+
+        case 2: /* Interrupt Level (or Polarity - Active high/low) */
+
+            RsSetFlagBits (&Descriptor->ExtendedIrq.Flags, InitializerOp, 2, 0);
+            RsCreateBitField (InitializerOp, ACPI_RESTAG_INTERRUPTLEVEL,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (ExtendedIrq.Flags), 2);
+            break;
+
+        case 3: /* Share Type - Default: exclusive (0) */
+
+            RsSetFlagBits (&Descriptor->ExtendedIrq.Flags, InitializerOp, 3, 0);
+            RsCreateBitField (InitializerOp, ACPI_RESTAG_INTERRUPTSHARE,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (ExtendedIrq.Flags), 3);
+            break;
+
+        case 4: /* ResSourceIndex [Optional Field - BYTE] */
+
+            if (InitializerOp->Asl.ParseOpcode != PARSEOP_DEFAULT_ARG)
+            {
+                HasResSourceIndex = TRUE;
+                ResSourceIndex = (UINT8) InitializerOp->Asl.Value.Integer;
+            }
+            break;
+
+        case 5: /* ResSource [Optional Field - STRING] */
+
+            if ((InitializerOp->Asl.ParseOpcode != PARSEOP_DEFAULT_ARG) &&
+                (InitializerOp->Asl.Value.String))
+            {
+                if (StringLength)
+                {
+                    ResSourceString = (UINT8 *) InitializerOp->Asl.Value.String;
+                }
+
+                /* ResourceSourceIndex must also be valid */
+
+                if (!HasResSourceIndex)
+                {
+                    AslError (ASL_ERROR, ASL_MSG_RESOURCE_INDEX,
+                        InitializerOp, NULL);
+                }
+            }
+
+#if 0
+            /*
+             * Not a valid ResourceSource, ResourceSourceIndex must also
+             * be invalid
+             */
+            else if (HasResSourceIndex)
+            {
+                AslError (ASL_ERROR, ASL_MSG_RESOURCE_SOURCE,
+                    InitializerOp, NULL);
+            }
+#endif
+            break;
+
+        case 6: /* ResourceTag */
+
+            UtAttachNamepathToOwner (Info->DescriptorTypeOp, InitializerOp);
+            break;
+
+        default:
+            /*
+             * Interrupt Numbers come through here, repeatedly
+             */
+
+            /* Maximum 255 interrupts allowed for this descriptor */
+
+            if (Descriptor->ExtendedIrq.InterruptCount == 255)
+            {
+                AslError (ASL_ERROR, ASL_MSG_EX_INTERRUPT_LIST,
+                    InitializerOp, NULL);
+                return (Rnode);
+            }
+
+            /* Each interrupt number must be a 32-bit value */
+
+            if (InitializerOp->Asl.Value.Integer > ACPI_UINT32_MAX)
+            {
+                AslError (ASL_ERROR, ASL_MSG_EX_INTERRUPT_NUMBER,
+                    InitializerOp, NULL);
+            }
+
+            /* Save the integer and move pointer to the next one */
+
+            Rover->DwordItem = (UINT32) InitializerOp->Asl.Value.Integer;
+            Rover = ACPI_ADD_PTR (AML_RESOURCE, &(Rover->DwordItem), 4);
+            Descriptor->ExtendedIrq.InterruptCount++;
+            Descriptor->ExtendedIrq.ResourceLength += 4;
+
+            /* Case 7: First interrupt number in list */
+
+            if (i == 7)
+            {
+                if (InitializerOp->Asl.ParseOpcode == PARSEOP_DEFAULT_ARG)
+                {
+                    /* Must be at least one interrupt */
+
+                    AslError (ASL_ERROR, ASL_MSG_EX_INTERRUPT_LIST_MIN,
+                        InitializerOp, NULL);
+                }
+
+                /* Check now for duplicates in list */
+
+                RsCheckListForDuplicates (InitializerOp);
+
+                /* Create a named field at the start of the list */
+
+                RsCreateDwordField (InitializerOp, ACPI_RESTAG_INTERRUPT,
+                    CurrentByteOffset +
+                    ASL_RESDESC_OFFSET (ExtendedIrq.Interrupts[0]));
+            }
+        }
+
+        InitializerOp = RsCompleteNodeAndGetNext (InitializerOp);
+    }
+
+
+    /* Add optional ResSourceIndex if present */
+
+    if (HasResSourceIndex)
+    {
+        Rover->ByteItem = ResSourceIndex;
+        Rover = ACPI_ADD_PTR (AML_RESOURCE, &(Rover->ByteItem), 1);
+        Descriptor->ExtendedIrq.ResourceLength += 1;
+    }
+
+    /* Add optional ResSource string if present */
+
+    if (StringLength && ResSourceString)
+    {
+
+        strcpy ((char *) Rover, (char *) ResSourceString);
+        Rover = ACPI_ADD_PTR (
+                    AML_RESOURCE, &(Rover->ByteItem), StringLength);
+
+        Descriptor->ExtendedIrq.ResourceLength = (UINT16)
+            (Descriptor->ExtendedIrq.ResourceLength + StringLength);
+    }
+
+    Rnode->BufferLength =
+        (ASL_RESDESC_OFFSET (ExtendedIrq.Interrupts[0]) -
+        ASL_RESDESC_OFFSET (ExtendedIrq.DescriptorType))
+        + OptionIndex + StringLength;
+    return (Rnode);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    RsDoVendorLargeDescriptor
+ *
+ * PARAMETERS:  Info                - Parse Op and resource template offset
+ *
+ * RETURN:      Completed resource node
+ *
+ * DESCRIPTION: Construct a long "VendorLong" descriptor
+ *
+ ******************************************************************************/
+
+ASL_RESOURCE_NODE *
+RsDoVendorLargeDescriptor (
+    ASL_RESOURCE_INFO       *Info)
+{
+    AML_RESOURCE            *Descriptor;
+    ACPI_PARSE_OBJECT       *InitializerOp;
+    ASL_RESOURCE_NODE       *Rnode;
+    UINT8                   *VendorData;
+    UINT32                  i;
+
+
+    /* Count the number of data bytes */
+
+    InitializerOp = Info->DescriptorTypeOp->Asl.Child;
+    InitializerOp = RsCompleteNodeAndGetNext (InitializerOp);
+
+    for (i = 0; InitializerOp; i++)
+    {
+        if (InitializerOp->Asl.ParseOpcode == PARSEOP_DEFAULT_ARG)
+        {
+            break;
+        }
+        InitializerOp = InitializerOp->Asl.Next;
+    }
+
+    InitializerOp = Info->DescriptorTypeOp->Asl.Child;
+    InitializerOp = RsCompleteNodeAndGetNext (InitializerOp);
+    Rnode = RsAllocateResourceNode (sizeof (AML_RESOURCE_VENDOR_LARGE) + i);
+
+    Descriptor = Rnode->Buffer;
+    Descriptor->VendorLarge.DescriptorType = ACPI_RESOURCE_NAME_VENDOR_LARGE;
+    Descriptor->VendorLarge.ResourceLength = (UINT16) i;
+
+    /* Point to end-of-descriptor for vendor data */
+
+    VendorData = ((UINT8 *) Descriptor) + sizeof (AML_RESOURCE_LARGE_HEADER);
+
+    /* Process all child initialization nodes */
+
+    for (i = 0; InitializerOp; i++)
+    {
+        if (InitializerOp->Asl.ParseOpcode == PARSEOP_DEFAULT_ARG)
+        {
+            break;
+        }
+
+        VendorData[i] = (UINT8) InitializerOp->Asl.Value.Integer;
+        InitializerOp = RsCompleteNodeAndGetNext (InitializerOp);
+    }
+
+    return (Rnode);
+}
diff --git a/usr/src/cmd/acpi/iasl/aslrestype2d.c b/usr/src/cmd/acpi/iasl/aslrestype2d.c
new file mode 100644
index 0000000000..c7841b0fcc
--- /dev/null
+++ b/usr/src/cmd/acpi/iasl/aslrestype2d.c
@@ -0,0 +1,737 @@
+/******************************************************************************
+ *
+ * Module Name: aslrestype2d - Large DWord address resource descriptors
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2016, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include "aslcompiler.h"
+#include "aslcompiler.y.h"
+
+#define _COMPONENT          ACPI_COMPILER
+        ACPI_MODULE_NAME    ("aslrestype2d")
+
+/*
+ * This module contains the Dword (32-bit) address space descriptors:
+ *
+ * DwordIO
+ * DwordMemory
+ * DwordSpace
+ */
+
+/*******************************************************************************
+ *
+ * FUNCTION:    RsDoDwordIoDescriptor
+ *
+ * PARAMETERS:  Info                - Parse Op and resource template offset
+ *
+ * RETURN:      Completed resource node
+ *
+ * DESCRIPTION: Construct a long "DwordIO" descriptor
+ *
+ ******************************************************************************/
+
+ASL_RESOURCE_NODE *
+RsDoDwordIoDescriptor (
+    ASL_RESOURCE_INFO       *Info)
+{
+    AML_RESOURCE            *Descriptor;
+    ACPI_PARSE_OBJECT       *InitializerOp;
+    ACPI_PARSE_OBJECT       *MinOp = NULL;
+    ACPI_PARSE_OBJECT       *MaxOp = NULL;
+    ACPI_PARSE_OBJECT       *LengthOp = NULL;
+    ACPI_PARSE_OBJECT       *GranOp = NULL;
+    ASL_RESOURCE_NODE       *Rnode;
+    UINT16                  StringLength = 0;
+    UINT32                  OptionIndex = 0;
+    UINT8                   *OptionalFields;
+    UINT32                  CurrentByteOffset;
+    UINT32                  i;
+    BOOLEAN                 ResSourceIndex = FALSE;
+
+
+    InitializerOp = Info->DescriptorTypeOp->Asl.Child;
+    StringLength = RsGetStringDataLength (InitializerOp);
+    CurrentByteOffset = Info->CurrentByteOffset;
+
+    Rnode = RsAllocateResourceNode (
+        sizeof (AML_RESOURCE_ADDRESS32) + 1 + StringLength);
+
+    Descriptor = Rnode->Buffer;
+    Descriptor->Address32.DescriptorType = ACPI_RESOURCE_NAME_ADDRESS32;
+    Descriptor->Address32.ResourceType  = ACPI_ADDRESS_TYPE_IO_RANGE;
+
+    /*
+     * Initial descriptor length -- may be enlarged if there are
+     * optional fields present
+     */
+    OptionalFields = ((UINT8 *) Descriptor) + sizeof (AML_RESOURCE_ADDRESS32);
+    Descriptor->Address32.ResourceLength = (UINT16)
+        (sizeof (AML_RESOURCE_ADDRESS32) -
+         sizeof (AML_RESOURCE_LARGE_HEADER));
+
+    /* Process all child initialization nodes */
+
+    for (i = 0; InitializerOp; i++)
+    {
+        switch (i)
+        {
+        case 0: /* Resource Usage */
+
+            RsSetFlagBits (&Descriptor->Address32.Flags, InitializerOp, 0, 1);
+            break;
+
+        case 1: /* MinType */
+
+            RsSetFlagBits (&Descriptor->Address32.Flags, InitializerOp, 2, 0);
+            RsCreateBitField (InitializerOp, ACPI_RESTAG_MINTYPE,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (Address32.Flags), 2);
+            break;
+
+        case 2: /* MaxType */
+
+            RsSetFlagBits (&Descriptor->Address32.Flags, InitializerOp, 3, 0);
+            RsCreateBitField (InitializerOp, ACPI_RESTAG_MAXTYPE,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (Address32.Flags), 3);
+            break;
+
+        case 3: /* DecodeType */
+
+            RsSetFlagBits (&Descriptor->Address32.Flags, InitializerOp, 1, 0);
+            RsCreateBitField (InitializerOp, ACPI_RESTAG_DECODE,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (Address32.Flags), 1);
+            break;
+
+        case 4: /* Range Type */
+
+            RsSetFlagBits (&Descriptor->Address32.SpecificFlags, InitializerOp, 0, 3);
+            RsCreateMultiBitField (InitializerOp, ACPI_RESTAG_RANGETYPE,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (Address32.SpecificFlags), 0, 2);
+            break;
+
+        case 5: /* Address Granularity */
+
+            Descriptor->Address32.Granularity =
+                (UINT32) InitializerOp->Asl.Value.Integer;
+            RsCreateDwordField (InitializerOp, ACPI_RESTAG_GRANULARITY,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (Address32.Granularity));
+            GranOp = InitializerOp;
+            break;
+
+        case 6: /* Address Min */
+
+            Descriptor->Address32.Minimum =
+                (UINT32) InitializerOp->Asl.Value.Integer;
+            RsCreateDwordField (InitializerOp, ACPI_RESTAG_MINADDR,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (Address32.Minimum));
+            MinOp = InitializerOp;
+            break;
+
+        case 7: /* Address Max */
+
+            Descriptor->Address32.Maximum =
+                (UINT32) InitializerOp->Asl.Value.Integer;
+            RsCreateDwordField (InitializerOp, ACPI_RESTAG_MAXADDR,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (Address32.Maximum));
+            MaxOp = InitializerOp;
+            break;
+
+        case 8: /* Translation Offset */
+
+            Descriptor->Address32.TranslationOffset =
+                (UINT32) InitializerOp->Asl.Value.Integer;
+            RsCreateDwordField (InitializerOp, ACPI_RESTAG_TRANSLATION,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (Address32.TranslationOffset));
+            break;
+
+        case 9: /* Address Length */
+
+            Descriptor->Address32.AddressLength =
+                (UINT32) InitializerOp->Asl.Value.Integer;
+            RsCreateDwordField (InitializerOp, ACPI_RESTAG_LENGTH,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (Address32.AddressLength));
+            LengthOp = InitializerOp;
+            break;
+
+        case 10: /* ResSourceIndex [Optional Field - BYTE] */
+
+            if (InitializerOp->Asl.ParseOpcode != PARSEOP_DEFAULT_ARG)
+            {
+                /* Found a valid ResourceSourceIndex */
+
+                OptionalFields[0] = (UINT8) InitializerOp->Asl.Value.Integer;
+                OptionIndex++;
+                Descriptor->Address32.ResourceLength++;
+                ResSourceIndex = TRUE;
+            }
+            break;
+
+        case 11: /* ResSource [Optional Field - STRING] */
+
+            if ((InitializerOp->Asl.ParseOpcode != PARSEOP_DEFAULT_ARG) &&
+                (InitializerOp->Asl.Value.String))
+            {
+                if (StringLength)
+                {
+                    /* Found a valid ResourceSource */
+
+                    Descriptor->Address32.ResourceLength = (UINT16)
+                        (Descriptor->Address32.ResourceLength + StringLength);
+
+                    strcpy ((char *)
+                        &OptionalFields[OptionIndex],
+                        InitializerOp->Asl.Value.String);
+
+                    /* ResourceSourceIndex must also be valid */
+
+                    if (!ResSourceIndex)
+                    {
+                        AslError (ASL_ERROR, ASL_MSG_RESOURCE_INDEX,
+                            InitializerOp, NULL);
+                    }
+                }
+            }
+
+#if 0
+            /*
+             * Not a valid ResourceSource, ResourceSourceIndex must also
+             * be invalid
+             */
+            else if (ResSourceIndex)
+            {
+                AslError (ASL_ERROR, ASL_MSG_RESOURCE_SOURCE,
+                    InitializerOp, NULL);
+            }
+#endif
+            break;
+
+        case 12: /* ResourceTag */
+
+            UtAttachNamepathToOwner (Info->DescriptorTypeOp, InitializerOp);
+            break;
+
+        case 13: /* Type */
+
+            RsSetFlagBits (&Descriptor->Address32.SpecificFlags, InitializerOp, 4, 0);
+            RsCreateBitField (InitializerOp, ACPI_RESTAG_TYPE,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (Address32.SpecificFlags), 4);
+            break;
+
+        case 14: /* Translation Type */
+
+            RsSetFlagBits (&Descriptor->Address32.SpecificFlags, InitializerOp, 5, 0);
+            RsCreateBitField (InitializerOp, ACPI_RESTAG_TRANSTYPE,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (Address32.SpecificFlags), 5);
+            break;
+
+        default:
+
+            AslError (ASL_ERROR, ASL_MSG_RESOURCE_LIST, InitializerOp, NULL);
+            break;
+        }
+
+        InitializerOp = RsCompleteNodeAndGetNext (InitializerOp);
+    }
+
+    /* Validate the Min/Max/Len/Gran values */
+
+    RsLargeAddressCheck (
+        (UINT64) Descriptor->Address32.Minimum,
+        (UINT64) Descriptor->Address32.Maximum,
+        (UINT64) Descriptor->Address32.AddressLength,
+        (UINT64) Descriptor->Address32.Granularity,
+        Descriptor->Address32.Flags,
+        MinOp, MaxOp, LengthOp, GranOp, Info->DescriptorTypeOp);
+
+    Rnode->BufferLength = sizeof (AML_RESOURCE_ADDRESS32) +
+        OptionIndex + StringLength;
+    return (Rnode);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    RsDoDwordMemoryDescriptor
+ *
+ * PARAMETERS:  Info                - Parse Op and resource template offset
+ *
+ * RETURN:      Completed resource node
+ *
+ * DESCRIPTION: Construct a long "DwordMemory" descriptor
+ *
+ ******************************************************************************/
+
+ASL_RESOURCE_NODE *
+RsDoDwordMemoryDescriptor (
+    ASL_RESOURCE_INFO       *Info)
+{
+    AML_RESOURCE            *Descriptor;
+    ACPI_PARSE_OBJECT       *InitializerOp;
+    ACPI_PARSE_OBJECT       *MinOp = NULL;
+    ACPI_PARSE_OBJECT       *MaxOp = NULL;
+    ACPI_PARSE_OBJECT       *LengthOp = NULL;
+    ACPI_PARSE_OBJECT       *GranOp = NULL;
+    ASL_RESOURCE_NODE       *Rnode;
+    UINT8                   *OptionalFields;
+    UINT16                  StringLength = 0;
+    UINT32                  OptionIndex = 0;
+    UINT32                  CurrentByteOffset;
+    UINT32                  i;
+    BOOLEAN                 ResSourceIndex = FALSE;
+
+
+    InitializerOp = Info->DescriptorTypeOp->Asl.Child;
+    StringLength = RsGetStringDataLength (InitializerOp);
+    CurrentByteOffset = Info->CurrentByteOffset;
+
+    Rnode = RsAllocateResourceNode (
+                sizeof (AML_RESOURCE_ADDRESS32) + 1 + StringLength);
+
+    Descriptor = Rnode->Buffer;
+    Descriptor->Address32.DescriptorType = ACPI_RESOURCE_NAME_ADDRESS32;
+    Descriptor->Address32.ResourceType  = ACPI_ADDRESS_TYPE_MEMORY_RANGE;
+
+    /*
+     * Initial descriptor length -- may be enlarged if there are
+     * optional fields present
+     */
+    OptionalFields = ((UINT8 *) Descriptor) + sizeof (AML_RESOURCE_ADDRESS32);
+    Descriptor->Address32.ResourceLength = (UINT16)
+        (sizeof (AML_RESOURCE_ADDRESS32) -
+         sizeof (AML_RESOURCE_LARGE_HEADER));
+
+
+    /* Process all child initialization nodes */
+
+    for (i = 0; InitializerOp; i++)
+    {
+        switch (i)
+        {
+        case 0: /* Resource Usage */
+
+            RsSetFlagBits (&Descriptor->Address32.Flags, InitializerOp, 0, 1);
+            break;
+
+        case 1: /* DecodeType */
+
+            RsSetFlagBits (&Descriptor->Address32.Flags, InitializerOp, 1, 0);
+            RsCreateBitField (InitializerOp, ACPI_RESTAG_DECODE,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (Address32.Flags), 1);
+            break;
+
+        case 2: /* MinType */
+
+            RsSetFlagBits (&Descriptor->Address32.Flags, InitializerOp, 2, 0);
+            RsCreateBitField (InitializerOp, ACPI_RESTAG_MINTYPE,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (Address32.Flags), 2);
+            break;
+
+        case 3: /* MaxType */
+
+            RsSetFlagBits (&Descriptor->Address32.Flags, InitializerOp, 3, 0);
+            RsCreateBitField (InitializerOp, ACPI_RESTAG_MAXTYPE,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (Address32.Flags), 3);
+            break;
+
+        case 4: /* Memory Type */
+
+            RsSetFlagBits (&Descriptor->Address32.SpecificFlags, InitializerOp, 1, 0);
+            RsCreateMultiBitField (InitializerOp, ACPI_RESTAG_MEMTYPE,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (Address32.SpecificFlags), 1, 2);
+            break;
+
+        case 5: /* Read/Write Type */
+
+            RsSetFlagBits (&Descriptor->Address32.SpecificFlags, InitializerOp, 0, 1);
+            RsCreateBitField (InitializerOp, ACPI_RESTAG_READWRITETYPE,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (Address32.SpecificFlags), 0);
+            break;
+
+        case 6: /* Address Granularity */
+
+            Descriptor->Address32.Granularity =
+                (UINT32) InitializerOp->Asl.Value.Integer;
+            RsCreateDwordField (InitializerOp, ACPI_RESTAG_GRANULARITY,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (Address32.Granularity));
+            GranOp = InitializerOp;
+            break;
+
+        case 7: /* Min Address */
+
+            Descriptor->Address32.Minimum =
+                (UINT32) InitializerOp->Asl.Value.Integer;
+            RsCreateDwordField (InitializerOp, ACPI_RESTAG_MINADDR,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (Address32.Minimum));
+            MinOp = InitializerOp;
+            break;
+
+        case 8: /* Max Address */
+
+            Descriptor->Address32.Maximum =
+                (UINT32) InitializerOp->Asl.Value.Integer;
+            RsCreateDwordField (InitializerOp, ACPI_RESTAG_MAXADDR,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (Address32.Maximum));
+            MaxOp = InitializerOp;
+            break;
+
+        case 9: /* Translation Offset */
+
+            Descriptor->Address32.TranslationOffset =
+                (UINT32) InitializerOp->Asl.Value.Integer;
+            RsCreateDwordField (InitializerOp, ACPI_RESTAG_TRANSLATION,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (Address32.TranslationOffset));
+            break;
+
+        case 10: /* Address Length */
+
+            Descriptor->Address32.AddressLength =
+                (UINT32) InitializerOp->Asl.Value.Integer;
+            RsCreateDwordField (InitializerOp, ACPI_RESTAG_LENGTH,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (Address32.AddressLength));
+            LengthOp = InitializerOp;
+            break;
+
+        case 11: /* ResSourceIndex [Optional Field - BYTE] */
+
+            if (InitializerOp->Asl.ParseOpcode != PARSEOP_DEFAULT_ARG)
+            {
+                OptionalFields[0] = (UINT8) InitializerOp->Asl.Value.Integer;
+                OptionIndex++;
+                Descriptor->Address32.ResourceLength++;
+                ResSourceIndex = TRUE;
+            }
+            break;
+
+        case 12: /* ResSource [Optional Field - STRING] */
+
+            if ((InitializerOp->Asl.ParseOpcode != PARSEOP_DEFAULT_ARG) &&
+                (InitializerOp->Asl.Value.String))
+            {
+                if (StringLength)
+                {
+                    Descriptor->Address32.ResourceLength = (UINT16)
+                        (Descriptor->Address32.ResourceLength + StringLength);
+
+                    strcpy ((char *)
+                        &OptionalFields[OptionIndex],
+                        InitializerOp->Asl.Value.String);
+
+                    /* ResourceSourceIndex must also be valid */
+
+                    if (!ResSourceIndex)
+                    {
+                        AslError (ASL_ERROR, ASL_MSG_RESOURCE_INDEX,
+                            InitializerOp, NULL);
+                    }
+                }
+            }
+
+#if 0
+            /*
+             * Not a valid ResourceSource, ResourceSourceIndex must also
+             * be invalid
+             */
+            else if (ResSourceIndex)
+            {
+                AslError (ASL_ERROR, ASL_MSG_RESOURCE_SOURCE,
+                    InitializerOp, NULL);
+            }
+#endif
+            break;
+
+        case 13: /* ResourceTag */
+
+            UtAttachNamepathToOwner (Info->DescriptorTypeOp, InitializerOp);
+            break;
+
+
+        case 14: /* Address Range */
+
+            RsSetFlagBits (&Descriptor->Address32.SpecificFlags, InitializerOp, 3, 0);
+            RsCreateMultiBitField (InitializerOp, ACPI_RESTAG_MEMATTRIBUTES,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (Address32.SpecificFlags), 3, 2);
+            break;
+
+        case 15: /* Type */
+
+            RsSetFlagBits (&Descriptor->Address32.SpecificFlags, InitializerOp, 5, 0);
+            RsCreateBitField (InitializerOp, ACPI_RESTAG_TYPE,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (Address32.SpecificFlags), 5);
+            break;
+
+        default:
+
+            AslError (ASL_ERROR, ASL_MSG_RESOURCE_LIST, InitializerOp, NULL);
+            break;
+        }
+
+        InitializerOp = RsCompleteNodeAndGetNext (InitializerOp);
+    }
+
+    /* Validate the Min/Max/Len/Gran values */
+
+    RsLargeAddressCheck (
+        (UINT64) Descriptor->Address32.Minimum,
+        (UINT64) Descriptor->Address32.Maximum,
+        (UINT64) Descriptor->Address32.AddressLength,
+        (UINT64) Descriptor->Address32.Granularity,
+        Descriptor->Address32.Flags,
+        MinOp, MaxOp, LengthOp, GranOp, Info->DescriptorTypeOp);
+
+    Rnode->BufferLength = sizeof (AML_RESOURCE_ADDRESS32) +
+        OptionIndex + StringLength;
+    return (Rnode);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    RsDoDwordSpaceDescriptor
+ *
+ * PARAMETERS:  Info                - Parse Op and resource template offset
+ *
+ * RETURN:      Completed resource node
+ *
+ * DESCRIPTION: Construct a long "DwordSpace" descriptor
+ *
+ ******************************************************************************/
+
+ASL_RESOURCE_NODE *
+RsDoDwordSpaceDescriptor (
+    ASL_RESOURCE_INFO       *Info)
+{
+    AML_RESOURCE            *Descriptor;
+    ACPI_PARSE_OBJECT       *InitializerOp;
+    ACPI_PARSE_OBJECT       *MinOp = NULL;
+    ACPI_PARSE_OBJECT       *MaxOp = NULL;
+    ACPI_PARSE_OBJECT       *LengthOp = NULL;
+    ACPI_PARSE_OBJECT       *GranOp = NULL;
+    ASL_RESOURCE_NODE       *Rnode;
+    UINT8                   *OptionalFields;
+    UINT16                  StringLength = 0;
+    UINT32                  OptionIndex = 0;
+    UINT32                  CurrentByteOffset;
+    UINT32                  i;
+    BOOLEAN                 ResSourceIndex = FALSE;
+
+
+    InitializerOp = Info->DescriptorTypeOp->Asl.Child;
+    StringLength = RsGetStringDataLength (InitializerOp);
+    CurrentByteOffset = Info->CurrentByteOffset;
+
+    Rnode = RsAllocateResourceNode (
+        sizeof (AML_RESOURCE_ADDRESS32) + 1 + StringLength);
+
+    Descriptor = Rnode->Buffer;
+    Descriptor->Address32.DescriptorType = ACPI_RESOURCE_NAME_ADDRESS32;
+
+    /*
+     * Initial descriptor length -- may be enlarged if there are
+     * optional fields present
+     */
+    OptionalFields = ((UINT8 *) Descriptor) + sizeof (AML_RESOURCE_ADDRESS32);
+    Descriptor->Address32.ResourceLength = (UINT16)
+        (sizeof (AML_RESOURCE_ADDRESS32) -
+         sizeof (AML_RESOURCE_LARGE_HEADER));
+
+    /* Process all child initialization nodes */
+
+    for (i = 0; InitializerOp; i++)
+    {
+        switch (i)
+        {
+        case 0: /* Resource Type */
+
+            Descriptor->Address32.ResourceType =
+                (UINT8) InitializerOp->Asl.Value.Integer;
+            break;
+
+        case 1: /* Resource Usage */
+
+            RsSetFlagBits (&Descriptor->Address32.Flags, InitializerOp, 0, 1);
+            break;
+
+        case 2: /* DecodeType */
+
+            RsSetFlagBits (&Descriptor->Address32.Flags, InitializerOp, 1, 0);
+            RsCreateBitField (InitializerOp, ACPI_RESTAG_DECODE,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (Address32.Flags), 1);
+            break;
+
+        case 3: /* MinType */
+
+            RsSetFlagBits (&Descriptor->Address32.Flags, InitializerOp, 2, 0);
+            RsCreateBitField (InitializerOp, ACPI_RESTAG_MINTYPE,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (Address32.Flags), 2);
+            break;
+
+        case 4: /* MaxType */
+
+            RsSetFlagBits (&Descriptor->Address32.Flags, InitializerOp, 3, 0);
+            RsCreateBitField (InitializerOp, ACPI_RESTAG_MAXTYPE,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (Address32.Flags), 3);
+            break;
+
+        case 5: /* Type-Specific flags */
+
+            Descriptor->Address32.SpecificFlags =
+                (UINT8) InitializerOp->Asl.Value.Integer;
+            break;
+
+        case 6: /* Address Granularity */
+
+            Descriptor->Address32.Granularity =
+                (UINT32) InitializerOp->Asl.Value.Integer;
+            RsCreateDwordField (InitializerOp, ACPI_RESTAG_GRANULARITY,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (Address32.Granularity));
+            GranOp = InitializerOp;
+            break;
+
+        case 7: /* Min Address */
+
+            Descriptor->Address32.Minimum =
+                (UINT32) InitializerOp->Asl.Value.Integer;
+            RsCreateDwordField (InitializerOp, ACPI_RESTAG_MINADDR,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (Address32.Minimum));
+            MinOp = InitializerOp;
+            break;
+
+        case 8: /* Max Address */
+
+            Descriptor->Address32.Maximum =
+                (UINT32) InitializerOp->Asl.Value.Integer;
+            RsCreateDwordField (InitializerOp, ACPI_RESTAG_MAXADDR,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (Address32.Maximum));
+            MaxOp = InitializerOp;
+            break;
+
+        case 9: /* Translation Offset */
+
+            Descriptor->Address32.TranslationOffset =
+                (UINT32) InitializerOp->Asl.Value.Integer;
+            RsCreateDwordField (InitializerOp, ACPI_RESTAG_TRANSLATION,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (Address32.TranslationOffset));
+            break;
+
+        case 10: /* Address Length */
+
+            Descriptor->Address32.AddressLength =
+                (UINT32) InitializerOp->Asl.Value.Integer;
+            RsCreateDwordField (InitializerOp, ACPI_RESTAG_LENGTH,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (Address32.AddressLength));
+            LengthOp = InitializerOp;
+            break;
+
+        case 11: /* ResSourceIndex [Optional Field - BYTE] */
+
+            if (InitializerOp->Asl.ParseOpcode != PARSEOP_DEFAULT_ARG)
+            {
+                OptionalFields[0] = (UINT8) InitializerOp->Asl.Value.Integer;
+                OptionIndex++;
+                Descriptor->Address32.ResourceLength++;
+                ResSourceIndex = TRUE;
+            }
+            break;
+
+        case 12: /* ResSource [Optional Field - STRING] */
+
+            if ((InitializerOp->Asl.ParseOpcode != PARSEOP_DEFAULT_ARG) &&
+                (InitializerOp->Asl.Value.String))
+            {
+                if (StringLength)
+                {
+                    Descriptor->Address32.ResourceLength = (UINT16)
+                        (Descriptor->Address32.ResourceLength + StringLength);
+
+                    strcpy ((char *)
+                        &OptionalFields[OptionIndex],
+                        InitializerOp->Asl.Value.String);
+
+                    /* ResourceSourceIndex must also be valid */
+
+                    if (!ResSourceIndex)
+                    {
+                        AslError (ASL_ERROR, ASL_MSG_RESOURCE_INDEX,
+                            InitializerOp, NULL);
+                    }
+                }
+            }
+
+#if 0
+            /*
+             * Not a valid ResourceSource, ResourceSourceIndex must also
+             * be invalid
+             */
+            else if (ResSourceIndex)
+            {
+                AslError (ASL_ERROR, ASL_MSG_RESOURCE_SOURCE,
+                    InitializerOp, NULL);
+            }
+#endif
+            break;
+
+        case 13: /* ResourceTag */
+
+            UtAttachNamepathToOwner (Info->DescriptorTypeOp, InitializerOp);
+            break;
+
+        default:
+
+            AslError (ASL_ERROR, ASL_MSG_RESOURCE_LIST,
+                InitializerOp, NULL);
+            break;
+        }
+
+        InitializerOp = RsCompleteNodeAndGetNext (InitializerOp);
+    }
+
+    /* Validate the Min/Max/Len/Gran values */
+
+    RsLargeAddressCheck (
+        (UINT64) Descriptor->Address32.Minimum,
+        (UINT64) Descriptor->Address32.Maximum,
+        (UINT64) Descriptor->Address32.AddressLength,
+        (UINT64) Descriptor->Address32.Granularity,
+        Descriptor->Address32.Flags,
+        MinOp, MaxOp, LengthOp, GranOp, Info->DescriptorTypeOp);
+
+    Rnode->BufferLength = sizeof (AML_RESOURCE_ADDRESS32) +
+        OptionIndex + StringLength;
+    return (Rnode);
+}
diff --git a/usr/src/cmd/acpi/iasl/aslrestype2e.c b/usr/src/cmd/acpi/iasl/aslrestype2e.c
new file mode 100644
index 0000000000..aa17a755ab
--- /dev/null
+++ b/usr/src/cmd/acpi/iasl/aslrestype2e.c
@@ -0,0 +1,571 @@
+/******************************************************************************
+ *
+ * Module Name: aslrestype2e - Large Extended address resource descriptors
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2016, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include "aslcompiler.h"
+
+#define _COMPONENT          ACPI_COMPILER
+        ACPI_MODULE_NAME    ("aslrestype2e")
+
+/*
+ * This module contains the Extended (64-bit) address space descriptors:
+ *
+ * ExtendedIO
+ * ExtendedMemory
+ * ExtendedSpace
+ */
+
+/*******************************************************************************
+ *
+ * FUNCTION:    RsDoExtendedIoDescriptor
+ *
+ * PARAMETERS:  Info                - Parse Op and resource template offset
+ *
+ * RETURN:      Completed resource node
+ *
+ * DESCRIPTION: Construct a long "ExtendedIO" descriptor
+ *
+ ******************************************************************************/
+
+ASL_RESOURCE_NODE *
+RsDoExtendedIoDescriptor (
+    ASL_RESOURCE_INFO       *Info)
+{
+    AML_RESOURCE            *Descriptor;
+    ACPI_PARSE_OBJECT       *InitializerOp;
+    ACPI_PARSE_OBJECT       *MinOp = NULL;
+    ACPI_PARSE_OBJECT       *MaxOp = NULL;
+    ACPI_PARSE_OBJECT       *LengthOp = NULL;
+    ACPI_PARSE_OBJECT       *GranOp = NULL;
+    ASL_RESOURCE_NODE       *Rnode;
+    UINT16                  StringLength = 0;
+    UINT32                  CurrentByteOffset;
+    UINT32                  i;
+
+
+    InitializerOp = Info->DescriptorTypeOp->Asl.Child;
+    StringLength = RsGetStringDataLength (InitializerOp);
+    CurrentByteOffset = Info->CurrentByteOffset;
+
+    Rnode = RsAllocateResourceNode (
+        sizeof (AML_RESOURCE_EXTENDED_ADDRESS64) + 1 + StringLength);
+
+    Descriptor = Rnode->Buffer;
+    Descriptor->ExtAddress64.DescriptorType = ACPI_RESOURCE_NAME_EXTENDED_ADDRESS64;
+    Descriptor->ExtAddress64.ResourceType = ACPI_ADDRESS_TYPE_IO_RANGE;
+    Descriptor->ExtAddress64.RevisionID = AML_RESOURCE_EXTENDED_ADDRESS_REVISION;
+
+    Descriptor->ExtAddress64.ResourceLength = (UINT16)
+        (sizeof (AML_RESOURCE_EXTENDED_ADDRESS64) -
+         sizeof (AML_RESOURCE_LARGE_HEADER));
+
+    /* Process all child initialization nodes */
+
+    for (i = 0; InitializerOp; i++)
+    {
+        switch (i)
+        {
+        case 0: /* Resource Usage */
+
+            RsSetFlagBits (&Descriptor->ExtAddress64.Flags, InitializerOp, 0, 1);
+            break;
+
+        case 1: /* MinType */
+
+            RsSetFlagBits (&Descriptor->ExtAddress64.Flags, InitializerOp, 2, 0);
+            RsCreateBitField (InitializerOp, ACPI_RESTAG_MINTYPE,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (ExtAddress64.Flags), 2);
+            break;
+
+        case 2: /* MaxType */
+
+            RsSetFlagBits (&Descriptor->ExtAddress64.Flags, InitializerOp, 3, 0);
+            RsCreateBitField (InitializerOp, ACPI_RESTAG_MAXTYPE,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (ExtAddress64.Flags), 3);
+            break;
+
+        case 3: /* DecodeType */
+
+            RsSetFlagBits (&Descriptor->ExtAddress64.Flags, InitializerOp, 1, 0);
+            RsCreateBitField (InitializerOp, ACPI_RESTAG_DECODE,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (ExtAddress64.Flags), 1);
+            break;
+
+        case 4: /* Range Type */
+
+            RsSetFlagBits (&Descriptor->ExtAddress64.SpecificFlags, InitializerOp, 0, 3);
+            RsCreateMultiBitField (InitializerOp, ACPI_RESTAG_RANGETYPE,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (ExtAddress64.SpecificFlags), 0, 2);
+            break;
+
+        case 5: /* Address Granularity */
+
+            Descriptor->ExtAddress64.Granularity = InitializerOp->Asl.Value.Integer;
+            RsCreateQwordField (InitializerOp, ACPI_RESTAG_GRANULARITY,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (ExtAddress64.Granularity));
+            GranOp = InitializerOp;
+            break;
+
+        case 6: /* Address Min */
+
+            Descriptor->ExtAddress64.Minimum = InitializerOp->Asl.Value.Integer;
+            RsCreateQwordField (InitializerOp, ACPI_RESTAG_MINADDR,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (ExtAddress64.Minimum));
+            MinOp = InitializerOp;
+            break;
+
+        case 7: /* Address Max */
+
+            Descriptor->ExtAddress64.Maximum = InitializerOp->Asl.Value.Integer;
+            RsCreateQwordField (InitializerOp, ACPI_RESTAG_MAXADDR,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (ExtAddress64.Maximum));
+            MaxOp = InitializerOp;
+            break;
+
+        case 8: /* Translation Offset */
+
+            Descriptor->ExtAddress64.TranslationOffset = InitializerOp->Asl.Value.Integer;
+            RsCreateQwordField (InitializerOp, ACPI_RESTAG_TRANSLATION,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (ExtAddress64.TranslationOffset));
+            break;
+
+        case 9: /* Address Length */
+
+            Descriptor->ExtAddress64.AddressLength = InitializerOp->Asl.Value.Integer;
+            RsCreateQwordField (InitializerOp, ACPI_RESTAG_LENGTH,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (ExtAddress64.AddressLength));
+            LengthOp = InitializerOp;
+            break;
+
+        case 10: /* Type-Specific Attributes */
+
+            Descriptor->ExtAddress64.TypeSpecific = InitializerOp->Asl.Value.Integer;
+            RsCreateQwordField (InitializerOp, ACPI_RESTAG_TYPESPECIFICATTRIBUTES,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (ExtAddress64.TypeSpecific));
+            break;
+
+        case 11: /* ResourceTag */
+
+            UtAttachNamepathToOwner (Info->DescriptorTypeOp, InitializerOp);
+            break;
+
+        case 12: /* Type */
+
+            RsSetFlagBits (&Descriptor->ExtAddress64.SpecificFlags, InitializerOp, 4, 0);
+            RsCreateBitField (InitializerOp, ACPI_RESTAG_TYPE,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (ExtAddress64.SpecificFlags), 4);
+            break;
+
+        case 13: /* Translation Type */
+
+            RsSetFlagBits (&Descriptor->ExtAddress64.SpecificFlags, InitializerOp, 5, 0);
+            RsCreateBitField (InitializerOp, ACPI_RESTAG_TRANSTYPE,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (ExtAddress64.SpecificFlags), 5);
+            break;
+
+        default:
+
+            AslError (ASL_ERROR, ASL_MSG_RESOURCE_LIST, InitializerOp, NULL);
+            break;
+        }
+
+        InitializerOp = RsCompleteNodeAndGetNext (InitializerOp);
+    }
+
+    /* Validate the Min/Max/Len/Gran values */
+
+    RsLargeAddressCheck (
+        Descriptor->ExtAddress64.Minimum,
+        Descriptor->ExtAddress64.Maximum,
+        Descriptor->ExtAddress64.AddressLength,
+        Descriptor->ExtAddress64.Granularity,
+        Descriptor->ExtAddress64.Flags,
+        MinOp, MaxOp, LengthOp, GranOp, Info->DescriptorTypeOp);
+
+    Rnode->BufferLength = sizeof (AML_RESOURCE_EXTENDED_ADDRESS64) +
+        StringLength;
+    return (Rnode);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    RsDoExtendedMemoryDescriptor
+ *
+ * PARAMETERS:  Info                - Parse Op and resource template offset
+ *
+ * RETURN:      Completed resource node
+ *
+ * DESCRIPTION: Construct a long "ExtendedMemory" descriptor
+ *
+ ******************************************************************************/
+
+ASL_RESOURCE_NODE *
+RsDoExtendedMemoryDescriptor (
+    ASL_RESOURCE_INFO       *Info)
+{
+    AML_RESOURCE            *Descriptor;
+    ACPI_PARSE_OBJECT       *InitializerOp;
+    ACPI_PARSE_OBJECT       *MinOp = NULL;
+    ACPI_PARSE_OBJECT       *MaxOp = NULL;
+    ACPI_PARSE_OBJECT       *LengthOp = NULL;
+    ACPI_PARSE_OBJECT       *GranOp = NULL;
+    ASL_RESOURCE_NODE       *Rnode;
+    UINT16                  StringLength = 0;
+    UINT32                  CurrentByteOffset;
+    UINT32                  i;
+
+
+    InitializerOp = Info->DescriptorTypeOp->Asl.Child;
+    StringLength = RsGetStringDataLength (InitializerOp);
+    CurrentByteOffset = Info->CurrentByteOffset;
+
+    Rnode = RsAllocateResourceNode (
+                sizeof (AML_RESOURCE_EXTENDED_ADDRESS64) + 1 + StringLength);
+
+    Descriptor = Rnode->Buffer;
+    Descriptor->ExtAddress64.DescriptorType = ACPI_RESOURCE_NAME_EXTENDED_ADDRESS64;
+    Descriptor->ExtAddress64.ResourceType = ACPI_ADDRESS_TYPE_MEMORY_RANGE;
+    Descriptor->ExtAddress64.RevisionID = AML_RESOURCE_EXTENDED_ADDRESS_REVISION;
+
+    Descriptor->ExtAddress64.ResourceLength = (UINT16)
+        (sizeof (AML_RESOURCE_EXTENDED_ADDRESS64) -
+         sizeof (AML_RESOURCE_LARGE_HEADER));
+
+    /* Process all child initialization nodes */
+
+    for (i = 0; InitializerOp; i++)
+    {
+        switch (i)
+        {
+        case 0: /* Resource Usage */
+
+            RsSetFlagBits (&Descriptor->ExtAddress64.Flags, InitializerOp, 0, 1);
+            break;
+
+        case 1: /* DecodeType */
+
+            RsSetFlagBits (&Descriptor->ExtAddress64.Flags, InitializerOp, 1, 0);
+            RsCreateBitField (InitializerOp, ACPI_RESTAG_DECODE,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (ExtAddress64.Flags), 1);
+            break;
+
+        case 2: /* MinType */
+
+            RsSetFlagBits (&Descriptor->ExtAddress64.Flags, InitializerOp, 2, 0);
+            RsCreateBitField (InitializerOp, ACPI_RESTAG_MINTYPE,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (ExtAddress64.Flags), 2);
+            break;
+
+        case 3: /* MaxType */
+
+            RsSetFlagBits (&Descriptor->ExtAddress64.Flags, InitializerOp, 3, 0);
+            RsCreateBitField (InitializerOp, ACPI_RESTAG_MAXTYPE,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (ExtAddress64.Flags), 3);
+            break;
+
+        case 4: /* Memory Type */
+
+            RsSetFlagBits (&Descriptor->ExtAddress64.SpecificFlags, InitializerOp, 1, 0);
+            RsCreateMultiBitField (InitializerOp, ACPI_RESTAG_MEMTYPE,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (ExtAddress64.SpecificFlags), 1, 2);
+            break;
+
+        case 5: /* Read/Write Type */
+
+            RsSetFlagBits (&Descriptor->ExtAddress64.SpecificFlags, InitializerOp, 0, 1);
+            RsCreateBitField (InitializerOp, ACPI_RESTAG_READWRITETYPE,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (ExtAddress64.SpecificFlags), 0);
+            break;
+
+        case 6: /* Address Granularity */
+
+            Descriptor->ExtAddress64.Granularity = InitializerOp->Asl.Value.Integer;
+            RsCreateQwordField (InitializerOp, ACPI_RESTAG_GRANULARITY,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (ExtAddress64.Granularity));
+            GranOp = InitializerOp;
+            break;
+
+        case 7: /* Min Address */
+
+            Descriptor->ExtAddress64.Minimum = InitializerOp->Asl.Value.Integer;
+            RsCreateQwordField (InitializerOp, ACPI_RESTAG_MINADDR,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (ExtAddress64.Minimum));
+            MinOp = InitializerOp;
+            break;
+
+        case 8: /* Max Address */
+
+            Descriptor->ExtAddress64.Maximum = InitializerOp->Asl.Value.Integer;
+            RsCreateQwordField (InitializerOp, ACPI_RESTAG_MAXADDR,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (ExtAddress64.Maximum));
+            MaxOp = InitializerOp;
+            break;
+
+        case 9: /* Translation Offset */
+
+            Descriptor->ExtAddress64.TranslationOffset = InitializerOp->Asl.Value.Integer;
+            RsCreateQwordField (InitializerOp, ACPI_RESTAG_TRANSLATION,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (ExtAddress64.TranslationOffset));
+            break;
+
+        case 10: /* Address Length */
+
+            Descriptor->ExtAddress64.AddressLength = InitializerOp->Asl.Value.Integer;
+            RsCreateQwordField (InitializerOp, ACPI_RESTAG_LENGTH,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (ExtAddress64.AddressLength));
+            LengthOp = InitializerOp;
+            break;
+
+        case 11: /* Type-Specific Attributes */
+
+            Descriptor->ExtAddress64.TypeSpecific = InitializerOp->Asl.Value.Integer;
+            RsCreateQwordField (InitializerOp, ACPI_RESTAG_TYPESPECIFICATTRIBUTES,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (ExtAddress64.TypeSpecific));
+            break;
+
+        case 12: /* ResourceTag */
+
+            UtAttachNamepathToOwner (Info->DescriptorTypeOp, InitializerOp);
+            break;
+
+
+        case 13: /* Address Range */
+
+            RsSetFlagBits (&Descriptor->ExtAddress64.SpecificFlags, InitializerOp, 3, 0);
+            RsCreateMultiBitField (InitializerOp, ACPI_RESTAG_MEMATTRIBUTES,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (ExtAddress64.SpecificFlags), 3, 2);
+            break;
+
+        case 14: /* Type */
+
+            RsSetFlagBits (&Descriptor->ExtAddress64.SpecificFlags, InitializerOp, 5, 0);
+            RsCreateBitField (InitializerOp, ACPI_RESTAG_TYPE,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (ExtAddress64.SpecificFlags), 5);
+            break;
+
+        default:
+
+            AslError (ASL_ERROR, ASL_MSG_RESOURCE_LIST, InitializerOp, NULL);
+            break;
+        }
+
+        InitializerOp = RsCompleteNodeAndGetNext (InitializerOp);
+    }
+
+    /* Validate the Min/Max/Len/Gran values */
+
+    RsLargeAddressCheck (
+        Descriptor->ExtAddress64.Minimum,
+        Descriptor->ExtAddress64.Maximum,
+        Descriptor->ExtAddress64.AddressLength,
+        Descriptor->ExtAddress64.Granularity,
+        Descriptor->ExtAddress64.Flags,
+        MinOp, MaxOp, LengthOp, GranOp, Info->DescriptorTypeOp);
+
+    Rnode->BufferLength = sizeof (AML_RESOURCE_EXTENDED_ADDRESS64) +
+        StringLength;
+    return (Rnode);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    RsDoExtendedSpaceDescriptor
+ *
+ * PARAMETERS:  Info                - Parse Op and resource template offset
+ *
+ * RETURN:      Completed resource node
+ *
+ * DESCRIPTION: Construct a long "ExtendedSpace" descriptor
+ *
+ ******************************************************************************/
+
+ASL_RESOURCE_NODE *
+RsDoExtendedSpaceDescriptor (
+    ASL_RESOURCE_INFO       *Info)
+{
+    AML_RESOURCE            *Descriptor;
+    ACPI_PARSE_OBJECT       *InitializerOp;
+    ACPI_PARSE_OBJECT       *MinOp = NULL;
+    ACPI_PARSE_OBJECT       *MaxOp = NULL;
+    ACPI_PARSE_OBJECT       *LengthOp = NULL;
+    ACPI_PARSE_OBJECT       *GranOp = NULL;
+    ASL_RESOURCE_NODE       *Rnode;
+    UINT16                  StringLength = 0;
+    UINT32                  CurrentByteOffset;
+    UINT32                  i;
+
+
+    InitializerOp = Info->DescriptorTypeOp->Asl.Child;
+    StringLength = RsGetStringDataLength (InitializerOp);
+    CurrentByteOffset = Info->CurrentByteOffset;
+
+    Rnode = RsAllocateResourceNode (
+        sizeof (AML_RESOURCE_EXTENDED_ADDRESS64) + 1 + StringLength);
+
+    Descriptor = Rnode->Buffer;
+    Descriptor->ExtAddress64.DescriptorType = ACPI_RESOURCE_NAME_EXTENDED_ADDRESS64;
+    Descriptor->ExtAddress64.RevisionID = AML_RESOURCE_EXTENDED_ADDRESS_REVISION;
+
+    Descriptor->ExtAddress64.ResourceLength = (UINT16)
+        (sizeof (AML_RESOURCE_EXTENDED_ADDRESS64) -
+         sizeof (AML_RESOURCE_LARGE_HEADER));
+
+    /* Process all child initialization nodes */
+
+    for (i = 0; InitializerOp; i++)
+    {
+        switch (i)
+        {
+        case 0: /* Resource Type */
+
+            Descriptor->ExtAddress64.ResourceType =
+                (UINT8) InitializerOp->Asl.Value.Integer;
+            break;
+
+        case 1: /* Resource Usage */
+
+            RsSetFlagBits (&Descriptor->ExtAddress64.Flags, InitializerOp, 0, 1);
+            break;
+
+        case 2: /* DecodeType */
+
+            RsSetFlagBits (&Descriptor->ExtAddress64.Flags, InitializerOp, 1, 0);
+            RsCreateBitField (InitializerOp, ACPI_RESTAG_DECODE,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (ExtAddress64.Flags), 1);
+            break;
+
+        case 3: /* MinType */
+
+            RsSetFlagBits (&Descriptor->ExtAddress64.Flags, InitializerOp, 2, 0);
+            RsCreateBitField (InitializerOp, ACPI_RESTAG_MINTYPE,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (ExtAddress64.Flags), 2);
+            break;
+
+        case 4: /* MaxType */
+
+            RsSetFlagBits (&Descriptor->ExtAddress64.Flags, InitializerOp, 3, 0);
+            RsCreateBitField (InitializerOp, ACPI_RESTAG_MAXTYPE,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (ExtAddress64.Flags), 3);
+            break;
+
+        case 5: /* Type-Specific flags */
+
+            Descriptor->ExtAddress64.SpecificFlags =
+                (UINT8) InitializerOp->Asl.Value.Integer;
+            break;
+
+        case 6: /* Address Granularity */
+
+            Descriptor->ExtAddress64.Granularity = InitializerOp->Asl.Value.Integer;
+            RsCreateQwordField (InitializerOp, ACPI_RESTAG_GRANULARITY,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (ExtAddress64.Granularity));
+            GranOp = InitializerOp;
+            break;
+
+        case 7: /* Min Address */
+
+            Descriptor->ExtAddress64.Minimum = InitializerOp->Asl.Value.Integer;
+            RsCreateQwordField (InitializerOp, ACPI_RESTAG_MINADDR,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (ExtAddress64.Minimum));
+            MinOp = InitializerOp;
+            break;
+
+        case 8: /* Max Address */
+
+            Descriptor->ExtAddress64.Maximum = InitializerOp->Asl.Value.Integer;
+            RsCreateQwordField (InitializerOp, ACPI_RESTAG_MAXADDR,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (ExtAddress64.Maximum));
+            MaxOp = InitializerOp;
+            break;
+
+        case 9: /* Translation Offset */
+
+            Descriptor->ExtAddress64.TranslationOffset = InitializerOp->Asl.Value.Integer;
+            RsCreateQwordField (InitializerOp, ACPI_RESTAG_TRANSLATION,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (ExtAddress64.TranslationOffset));
+            break;
+
+        case 10: /* Address Length */
+
+            Descriptor->ExtAddress64.AddressLength = InitializerOp->Asl.Value.Integer;
+            RsCreateQwordField (InitializerOp, ACPI_RESTAG_LENGTH,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (ExtAddress64.AddressLength));
+            LengthOp = InitializerOp;
+            break;
+
+        case 11: /* Type-Specific Attributes */
+
+            Descriptor->ExtAddress64.TypeSpecific = InitializerOp->Asl.Value.Integer;
+            RsCreateQwordField (InitializerOp, ACPI_RESTAG_TYPESPECIFICATTRIBUTES,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (ExtAddress64.TypeSpecific));
+            break;
+
+        case 12: /* ResourceTag */
+
+            UtAttachNamepathToOwner (Info->DescriptorTypeOp, InitializerOp);
+            break;
+
+        default:
+
+            AslError (ASL_ERROR, ASL_MSG_RESOURCE_LIST, InitializerOp, NULL);
+            break;
+        }
+
+        InitializerOp = RsCompleteNodeAndGetNext (InitializerOp);
+    }
+
+    /* Validate the Min/Max/Len/Gran values */
+
+    RsLargeAddressCheck (
+        Descriptor->ExtAddress64.Minimum,
+        Descriptor->ExtAddress64.Maximum,
+        Descriptor->ExtAddress64.AddressLength,
+        Descriptor->ExtAddress64.Granularity,
+        Descriptor->ExtAddress64.Flags,
+        MinOp, MaxOp, LengthOp, GranOp, Info->DescriptorTypeOp);
+
+    Rnode->BufferLength = sizeof (AML_RESOURCE_EXTENDED_ADDRESS64) +
+        StringLength;
+    return (Rnode);
+}
diff --git a/usr/src/cmd/acpi/iasl/aslrestype2q.c b/usr/src/cmd/acpi/iasl/aslrestype2q.c
new file mode 100644
index 0000000000..c8d8cabea9
--- /dev/null
+++ b/usr/src/cmd/acpi/iasl/aslrestype2q.c
@@ -0,0 +1,716 @@
+/******************************************************************************
+ *
+ * Module Name: aslrestype2q - Large QWord address resource descriptors
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2016, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include "aslcompiler.h"
+#include "aslcompiler.y.h"
+
+#define _COMPONENT          ACPI_COMPILER
+        ACPI_MODULE_NAME    ("aslrestype2q")
+
+/*
+ * This module contains the QWord (64-bit) address space descriptors:
+ *
+ * QWordIO
+ * QWordMemory
+ * QWordSpace
+ */
+
+/*******************************************************************************
+ *
+ * FUNCTION:    RsDoQwordIoDescriptor
+ *
+ * PARAMETERS:  Info                - Parse Op and resource template offset
+ *
+ * RETURN:      Completed resource node
+ *
+ * DESCRIPTION: Construct a long "QwordIO" descriptor
+ *
+ ******************************************************************************/
+
+ASL_RESOURCE_NODE *
+RsDoQwordIoDescriptor (
+    ASL_RESOURCE_INFO       *Info)
+{
+    AML_RESOURCE            *Descriptor;
+    ACPI_PARSE_OBJECT       *InitializerOp;
+    ACPI_PARSE_OBJECT       *MinOp = NULL;
+    ACPI_PARSE_OBJECT       *MaxOp = NULL;
+    ACPI_PARSE_OBJECT       *LengthOp = NULL;
+    ACPI_PARSE_OBJECT       *GranOp = NULL;
+    ASL_RESOURCE_NODE       *Rnode;
+    UINT8                   *OptionalFields;
+    UINT16                  StringLength = 0;
+    UINT32                  OptionIndex = 0;
+    UINT32                  CurrentByteOffset;
+    UINT32                  i;
+    BOOLEAN                 ResSourceIndex = FALSE;
+
+
+    InitializerOp = Info->DescriptorTypeOp->Asl.Child;
+    StringLength = RsGetStringDataLength (InitializerOp);
+    CurrentByteOffset = Info->CurrentByteOffset;
+
+    Rnode = RsAllocateResourceNode (
+        sizeof (AML_RESOURCE_ADDRESS64) + 1 + StringLength);
+
+    Descriptor = Rnode->Buffer;
+    Descriptor->Address64.DescriptorType = ACPI_RESOURCE_NAME_ADDRESS64;
+    Descriptor->Address64.ResourceType = ACPI_ADDRESS_TYPE_IO_RANGE;
+
+    /*
+     * Initial descriptor length -- may be enlarged if there are
+     * optional fields present
+     */
+    OptionalFields = ((UINT8 *) Descriptor) + sizeof (AML_RESOURCE_ADDRESS64);
+    Descriptor->Address64.ResourceLength = (UINT16)
+        (sizeof (AML_RESOURCE_ADDRESS64) -
+         sizeof (AML_RESOURCE_LARGE_HEADER));
+
+    /* Process all child initialization nodes */
+
+    for (i = 0; InitializerOp; i++)
+    {
+        switch (i)
+        {
+        case 0: /* Resource Usage */
+
+            RsSetFlagBits (&Descriptor->Address64.Flags, InitializerOp, 0, 1);
+            break;
+
+        case 1: /* MinType */
+
+            RsSetFlagBits (&Descriptor->Address64.Flags, InitializerOp, 2, 0);
+            RsCreateBitField (InitializerOp, ACPI_RESTAG_MINTYPE,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (Address64.Flags), 2);
+            break;
+
+        case 2: /* MaxType */
+
+            RsSetFlagBits (&Descriptor->Address64.Flags, InitializerOp, 3, 0);
+            RsCreateBitField (InitializerOp, ACPI_RESTAG_MAXTYPE,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (Address64.Flags), 3);
+            break;
+
+        case 3: /* DecodeType */
+
+            RsSetFlagBits (&Descriptor->Address64.Flags, InitializerOp, 1, 0);
+            RsCreateBitField (InitializerOp, ACPI_RESTAG_DECODE,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (Address64.Flags), 1);
+            break;
+
+        case 4: /* Range Type */
+
+            RsSetFlagBits (&Descriptor->Address64.SpecificFlags, InitializerOp, 0, 3);
+            RsCreateMultiBitField (InitializerOp, ACPI_RESTAG_RANGETYPE,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (Address64.SpecificFlags), 0, 2);
+            break;
+
+        case 5: /* Address Granularity */
+
+            Descriptor->Address64.Granularity = InitializerOp->Asl.Value.Integer;
+            RsCreateQwordField (InitializerOp, ACPI_RESTAG_GRANULARITY,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (Address64.Granularity));
+            GranOp = InitializerOp;
+            break;
+
+        case 6: /* Address Min */
+
+            Descriptor->Address64.Minimum = InitializerOp->Asl.Value.Integer;
+            RsCreateQwordField (InitializerOp, ACPI_RESTAG_MINADDR,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (Address64.Minimum));
+            MinOp = InitializerOp;
+            break;
+
+        case 7: /* Address Max */
+
+            Descriptor->Address64.Maximum = InitializerOp->Asl.Value.Integer;
+            RsCreateQwordField (InitializerOp, ACPI_RESTAG_MAXADDR,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (Address64.Maximum));
+            MaxOp = InitializerOp;
+            break;
+
+        case 8: /* Translation Offset */
+
+            Descriptor->Address64.TranslationOffset = InitializerOp->Asl.Value.Integer;
+            RsCreateByteField (InitializerOp, ACPI_RESTAG_TRANSLATION,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (Address64.TranslationOffset));
+            break;
+
+        case 9: /* Address Length */
+
+            Descriptor->Address64.AddressLength = InitializerOp->Asl.Value.Integer;
+            RsCreateQwordField (InitializerOp, ACPI_RESTAG_LENGTH,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (Address64.AddressLength));
+            LengthOp = InitializerOp;
+            break;
+
+        case 10: /* ResSourceIndex [Optional Field - BYTE] */
+
+            if (InitializerOp->Asl.ParseOpcode != PARSEOP_DEFAULT_ARG)
+            {
+                OptionalFields[0] = (UINT8) InitializerOp->Asl.Value.Integer;
+                OptionIndex++;
+                Descriptor->Address64.ResourceLength++;
+                ResSourceIndex = TRUE;
+            }
+            break;
+
+        case 11: /* ResSource [Optional Field - STRING] */
+
+            if ((InitializerOp->Asl.ParseOpcode != PARSEOP_DEFAULT_ARG) &&
+                (InitializerOp->Asl.Value.String))
+            {
+                if (StringLength)
+                {
+                    Descriptor->Address64.ResourceLength = (UINT16)
+                        (Descriptor->Address64.ResourceLength + StringLength);
+
+                    strcpy ((char *)
+                        &OptionalFields[OptionIndex],
+                        InitializerOp->Asl.Value.String);
+
+                    /* ResourceSourceIndex must also be valid */
+
+                    if (!ResSourceIndex)
+                    {
+                        AslError (ASL_ERROR, ASL_MSG_RESOURCE_INDEX,
+                            InitializerOp, NULL);
+                    }
+                }
+            }
+
+#if 0
+            /*
+             * Not a valid ResourceSource, ResourceSourceIndex must also
+             * be invalid
+             */
+            else if (ResSourceIndex)
+            {
+                AslError (ASL_ERROR, ASL_MSG_RESOURCE_SOURCE,
+                    InitializerOp, NULL);
+            }
+#endif
+            break;
+
+        case 12: /* ResourceTag */
+
+            UtAttachNamepathToOwner (Info->DescriptorTypeOp, InitializerOp);
+            break;
+
+        case 13: /* Type */
+
+            RsSetFlagBits (&Descriptor->Address64.SpecificFlags, InitializerOp, 4, 0);
+            RsCreateBitField (InitializerOp, ACPI_RESTAG_TYPE,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (Address64.SpecificFlags), 4);
+            break;
+
+        case 14: /* Translation Type */
+
+            RsSetFlagBits (&Descriptor->Address64.SpecificFlags, InitializerOp, 5, 0);
+            RsCreateBitField (InitializerOp, ACPI_RESTAG_TRANSTYPE,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (Address64.SpecificFlags), 5);
+            break;
+
+        default:
+
+            AslError (ASL_ERROR, ASL_MSG_RESOURCE_LIST, InitializerOp, NULL);
+            break;
+        }
+
+        InitializerOp = RsCompleteNodeAndGetNext (InitializerOp);
+    }
+
+    /* Validate the Min/Max/Len/Gran values */
+
+    RsLargeAddressCheck (
+        Descriptor->Address64.Minimum,
+        Descriptor->Address64.Maximum,
+        Descriptor->Address64.AddressLength,
+        Descriptor->Address64.Granularity,
+        Descriptor->Address64.Flags,
+        MinOp, MaxOp, LengthOp, GranOp, Info->DescriptorTypeOp);
+
+    Rnode->BufferLength = sizeof (AML_RESOURCE_ADDRESS64) +
+        OptionIndex + StringLength;
+    return (Rnode);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    RsDoQwordMemoryDescriptor
+ *
+ * PARAMETERS:  Info                - Parse Op and resource template offset
+ *
+ * RETURN:      Completed resource node
+ *
+ * DESCRIPTION: Construct a long "QwordMemory" descriptor
+ *
+ ******************************************************************************/
+
+ASL_RESOURCE_NODE *
+RsDoQwordMemoryDescriptor (
+    ASL_RESOURCE_INFO       *Info)
+{
+    AML_RESOURCE            *Descriptor;
+    ACPI_PARSE_OBJECT       *InitializerOp;
+    ACPI_PARSE_OBJECT       *MinOp = NULL;
+    ACPI_PARSE_OBJECT       *MaxOp = NULL;
+    ACPI_PARSE_OBJECT       *LengthOp = NULL;
+    ACPI_PARSE_OBJECT       *GranOp = NULL;
+    ASL_RESOURCE_NODE       *Rnode;
+    UINT8                   *OptionalFields;
+    UINT16                  StringLength = 0;
+    UINT32                  OptionIndex = 0;
+    UINT32                  CurrentByteOffset;
+    UINT32                  i;
+    BOOLEAN                 ResSourceIndex = FALSE;
+
+
+    InitializerOp = Info->DescriptorTypeOp->Asl.Child;
+    StringLength = RsGetStringDataLength (InitializerOp);
+    CurrentByteOffset = Info->CurrentByteOffset;
+
+    Rnode = RsAllocateResourceNode (
+        sizeof (AML_RESOURCE_ADDRESS64) + 1 + StringLength);
+
+    Descriptor = Rnode->Buffer;
+    Descriptor->Address64.DescriptorType = ACPI_RESOURCE_NAME_ADDRESS64;
+    Descriptor->Address64.ResourceType = ACPI_ADDRESS_TYPE_MEMORY_RANGE;
+
+    /*
+     * Initial descriptor length -- may be enlarged if there are
+     * optional fields present
+     */
+    OptionalFields = ((UINT8 *) Descriptor) + sizeof (AML_RESOURCE_ADDRESS64);
+    Descriptor->Address64.ResourceLength = (UINT16)
+        (sizeof (AML_RESOURCE_ADDRESS64) -
+         sizeof (AML_RESOURCE_LARGE_HEADER));
+
+    /* Process all child initialization nodes */
+
+    for (i = 0; InitializerOp; i++)
+    {
+        switch (i)
+        {
+        case 0: /* Resource Usage */
+
+            RsSetFlagBits (&Descriptor->Address64.Flags, InitializerOp, 0, 1);
+            break;
+
+        case 1: /* DecodeType */
+
+            RsSetFlagBits (&Descriptor->Address64.Flags, InitializerOp, 1, 0);
+            RsCreateBitField (InitializerOp, ACPI_RESTAG_DECODE,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (Address64.Flags), 1);
+            break;
+
+        case 2: /* MinType */
+
+            RsSetFlagBits (&Descriptor->Address64.Flags, InitializerOp, 2, 0);
+            RsCreateBitField (InitializerOp, ACPI_RESTAG_MINTYPE,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (Address64.Flags), 2);
+            break;
+
+        case 3: /* MaxType */
+
+            RsSetFlagBits (&Descriptor->Address64.Flags, InitializerOp, 3, 0);
+            RsCreateBitField (InitializerOp, ACPI_RESTAG_MAXTYPE,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (Address64.Flags), 3);
+            break;
+
+        case 4: /* Memory Type */
+
+            RsSetFlagBits (&Descriptor->Address64.SpecificFlags, InitializerOp, 1, 0);
+            RsCreateMultiBitField (InitializerOp, ACPI_RESTAG_MEMTYPE,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (Address64.SpecificFlags), 1, 2);
+            break;
+
+        case 5: /* Read/Write Type */
+
+            RsSetFlagBits (&Descriptor->Address64.SpecificFlags, InitializerOp, 0, 1);
+            RsCreateBitField (InitializerOp, ACPI_RESTAG_READWRITETYPE,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (Address64.SpecificFlags), 0);
+            break;
+
+        case 6: /* Address Granularity */
+
+            Descriptor->Address64.Granularity = InitializerOp->Asl.Value.Integer;
+            RsCreateQwordField (InitializerOp, ACPI_RESTAG_GRANULARITY,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (Address64.Granularity));
+            GranOp = InitializerOp;
+            break;
+
+        case 7: /* Min Address */
+
+            Descriptor->Address64.Minimum = InitializerOp->Asl.Value.Integer;
+            RsCreateQwordField (InitializerOp, ACPI_RESTAG_MINADDR,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (Address64.Minimum));
+            MinOp = InitializerOp;
+            break;
+
+        case 8: /* Max Address */
+
+            Descriptor->Address64.Maximum = InitializerOp->Asl.Value.Integer;
+            RsCreateQwordField (InitializerOp, ACPI_RESTAG_MAXADDR,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (Address64.Maximum));
+            MaxOp = InitializerOp;
+            break;
+
+        case 9: /* Translation Offset */
+
+            Descriptor->Address64.TranslationOffset = InitializerOp->Asl.Value.Integer;
+            RsCreateQwordField (InitializerOp, ACPI_RESTAG_TRANSLATION,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (Address64.TranslationOffset));
+            break;
+
+        case 10: /* Address Length */
+
+            Descriptor->Address64.AddressLength = InitializerOp->Asl.Value.Integer;
+            RsCreateQwordField (InitializerOp, ACPI_RESTAG_LENGTH,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (Address64.AddressLength));
+            LengthOp = InitializerOp;
+            break;
+
+        case 11: /* ResSourceIndex [Optional Field - BYTE] */
+
+            if (InitializerOp->Asl.ParseOpcode != PARSEOP_DEFAULT_ARG)
+            {
+                OptionalFields[0] = (UINT8) InitializerOp->Asl.Value.Integer;
+                OptionIndex++;
+                Descriptor->Address64.ResourceLength++;
+                ResSourceIndex = TRUE;
+            }
+            break;
+
+        case 12: /* ResSource [Optional Field - STRING] */
+
+            if ((InitializerOp->Asl.ParseOpcode != PARSEOP_DEFAULT_ARG) &&
+                (InitializerOp->Asl.Value.String))
+            {
+                if (StringLength)
+                {
+                    Descriptor->Address64.ResourceLength = (UINT16)
+                        (Descriptor->Address64.ResourceLength + StringLength);
+
+                    strcpy ((char *)
+                        &OptionalFields[OptionIndex],
+                        InitializerOp->Asl.Value.String);
+
+                    /* ResourceSourceIndex must also be valid */
+
+                    if (!ResSourceIndex)
+                    {
+                        AslError (ASL_ERROR, ASL_MSG_RESOURCE_INDEX,
+                            InitializerOp, NULL);
+                    }
+                }
+            }
+
+#if 0
+            /*
+             * Not a valid ResourceSource, ResourceSourceIndex must also
+             * be invalid
+             */
+            else if (ResSourceIndex)
+            {
+                AslError (ASL_ERROR, ASL_MSG_RESOURCE_SOURCE,
+                    InitializerOp, NULL);
+            }
+#endif
+            break;
+
+        case 13: /* ResourceTag */
+
+            UtAttachNamepathToOwner (Info->DescriptorTypeOp, InitializerOp);
+            break;
+
+
+        case 14: /* Address Range */
+
+            RsSetFlagBits (&Descriptor->Address64.SpecificFlags, InitializerOp, 3, 0);
+            RsCreateMultiBitField (InitializerOp, ACPI_RESTAG_MEMATTRIBUTES,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (Address64.SpecificFlags), 3, 2);
+            break;
+
+        case 15: /* Type */
+
+            RsSetFlagBits (&Descriptor->Address64.SpecificFlags, InitializerOp, 5, 0);
+            RsCreateBitField (InitializerOp, ACPI_RESTAG_TYPE,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (Address64.SpecificFlags), 5);
+            break;
+
+        default:
+
+            AslError (ASL_ERROR, ASL_MSG_RESOURCE_LIST, InitializerOp, NULL);
+            break;
+        }
+
+        InitializerOp = RsCompleteNodeAndGetNext (InitializerOp);
+    }
+
+    /* Validate the Min/Max/Len/Gran values */
+
+    RsLargeAddressCheck (
+        Descriptor->Address64.Minimum,
+        Descriptor->Address64.Maximum,
+        Descriptor->Address64.AddressLength,
+        Descriptor->Address64.Granularity,
+        Descriptor->Address64.Flags,
+        MinOp, MaxOp, LengthOp, GranOp, Info->DescriptorTypeOp);
+
+    Rnode->BufferLength = sizeof (AML_RESOURCE_ADDRESS64) +
+        OptionIndex + StringLength;
+    return (Rnode);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    RsDoQwordSpaceDescriptor
+ *
+ * PARAMETERS:  Info                - Parse Op and resource template offset
+ *
+ * RETURN:      Completed resource node
+ *
+ * DESCRIPTION: Construct a long "QwordSpace" descriptor
+ *
+ ******************************************************************************/
+
+ASL_RESOURCE_NODE *
+RsDoQwordSpaceDescriptor (
+    ASL_RESOURCE_INFO       *Info)
+{
+    AML_RESOURCE            *Descriptor;
+    ACPI_PARSE_OBJECT       *InitializerOp;
+    ACPI_PARSE_OBJECT       *MinOp = NULL;
+    ACPI_PARSE_OBJECT       *MaxOp = NULL;
+    ACPI_PARSE_OBJECT       *LengthOp = NULL;
+    ACPI_PARSE_OBJECT       *GranOp = NULL;
+    ASL_RESOURCE_NODE       *Rnode;
+    UINT8                   *OptionalFields;
+    UINT16                  StringLength = 0;
+    UINT32                  OptionIndex = 0;
+    UINT32                  CurrentByteOffset;
+    UINT32                  i;
+    BOOLEAN                 ResSourceIndex = FALSE;
+
+
+    InitializerOp = Info->DescriptorTypeOp->Asl.Child;
+    StringLength = RsGetStringDataLength (InitializerOp);
+    CurrentByteOffset = Info->CurrentByteOffset;
+
+    Rnode = RsAllocateResourceNode (
+        sizeof (AML_RESOURCE_ADDRESS64) + 1 + StringLength);
+
+    Descriptor = Rnode->Buffer;
+    Descriptor->Address64.DescriptorType = ACPI_RESOURCE_NAME_ADDRESS64;
+
+    /*
+     * Initial descriptor length -- may be enlarged if there are
+     * optional fields present
+     */
+    OptionalFields = ((UINT8 *) Descriptor) + sizeof (AML_RESOURCE_ADDRESS64);
+    Descriptor->Address64.ResourceLength = (UINT16)
+        (sizeof (AML_RESOURCE_ADDRESS64) -
+         sizeof (AML_RESOURCE_LARGE_HEADER));
+
+    /* Process all child initialization nodes */
+
+    for (i = 0; InitializerOp; i++)
+    {
+        switch (i)
+        {
+        case 0: /* Resource Type */
+
+            Descriptor->Address64.ResourceType =
+                (UINT8) InitializerOp->Asl.Value.Integer;
+            break;
+
+        case 1: /* Resource Usage */
+
+            RsSetFlagBits (&Descriptor->Address64.Flags, InitializerOp, 0, 1);
+            break;
+
+        case 2: /* DecodeType */
+
+            RsSetFlagBits (&Descriptor->Address64.Flags, InitializerOp, 1, 0);
+            RsCreateBitField (InitializerOp, ACPI_RESTAG_DECODE,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (Address64.Flags), 1);
+            break;
+
+        case 3: /* MinType */
+
+            RsSetFlagBits (&Descriptor->Address64.Flags, InitializerOp, 2, 0);
+            RsCreateBitField (InitializerOp, ACPI_RESTAG_MINTYPE,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (Address64.Flags), 2);
+            break;
+
+        case 4: /* MaxType */
+
+            RsSetFlagBits (&Descriptor->Address64.Flags, InitializerOp, 3, 0);
+            RsCreateBitField (InitializerOp, ACPI_RESTAG_MAXTYPE,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (Address64.Flags), 3);
+            break;
+
+        case 5: /* Type-Specific flags */
+
+            Descriptor->Address64.SpecificFlags =
+                (UINT8) InitializerOp->Asl.Value.Integer;
+            break;
+
+        case 6: /* Address Granularity */
+
+            Descriptor->Address64.Granularity = InitializerOp->Asl.Value.Integer;
+            RsCreateQwordField (InitializerOp, ACPI_RESTAG_GRANULARITY,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (Address64.Granularity));
+            GranOp = InitializerOp;
+            break;
+
+        case 7: /* Min Address */
+
+            Descriptor->Address64.Minimum = InitializerOp->Asl.Value.Integer;
+            RsCreateQwordField (InitializerOp, ACPI_RESTAG_MINADDR,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (Address64.Minimum));
+            MinOp = InitializerOp;
+            break;
+
+        case 8: /* Max Address */
+
+            Descriptor->Address64.Maximum = InitializerOp->Asl.Value.Integer;
+            RsCreateQwordField (InitializerOp, ACPI_RESTAG_MAXADDR,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (Address64.Maximum));
+            MaxOp = InitializerOp;
+            break;
+
+        case 9: /* Translation Offset */
+
+            Descriptor->Address64.TranslationOffset = InitializerOp->Asl.Value.Integer;
+            RsCreateQwordField (InitializerOp, ACPI_RESTAG_TRANSLATION,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (Address64.TranslationOffset));
+            break;
+
+        case 10: /* Address Length */
+
+            Descriptor->Address64.AddressLength = InitializerOp->Asl.Value.Integer;
+            RsCreateQwordField (InitializerOp, ACPI_RESTAG_LENGTH,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (Address64.AddressLength));
+            LengthOp = InitializerOp;
+            break;
+
+        case 11: /* ResSourceIndex [Optional Field - BYTE] */
+
+            if (InitializerOp->Asl.ParseOpcode != PARSEOP_DEFAULT_ARG)
+            {
+                OptionalFields[0] = (UINT8) InitializerOp->Asl.Value.Integer;
+                OptionIndex++;
+                Descriptor->Address64.ResourceLength++;
+                ResSourceIndex = TRUE;
+            }
+            break;
+
+        case 12: /* ResSource [Optional Field - STRING] */
+
+            if ((InitializerOp->Asl.ParseOpcode != PARSEOP_DEFAULT_ARG) &&
+                (InitializerOp->Asl.Value.String))
+            {
+                if (StringLength)
+                {
+                    Descriptor->Address64.ResourceLength = (UINT16)
+                        (Descriptor->Address64.ResourceLength + StringLength);
+
+                    strcpy ((char *)
+                        &OptionalFields[OptionIndex],
+                        InitializerOp->Asl.Value.String);
+
+                    /* ResourceSourceIndex must also be valid */
+
+                    if (!ResSourceIndex)
+                    {
+                        AslError (ASL_ERROR, ASL_MSG_RESOURCE_INDEX,
+                            InitializerOp, NULL);
+                    }
+                }
+            }
+
+#if 0
+            /*
+             * Not a valid ResourceSource, ResourceSourceIndex must also
+             * be invalid
+             */
+            else if (ResSourceIndex)
+            {
+                AslError (ASL_ERROR, ASL_MSG_RESOURCE_SOURCE,
+                    InitializerOp, NULL);
+            }
+#endif
+            break;
+
+        case 13: /* ResourceTag */
+
+            UtAttachNamepathToOwner (Info->DescriptorTypeOp, InitializerOp);
+            break;
+
+        default:
+
+            AslError (ASL_ERROR, ASL_MSG_RESOURCE_LIST, InitializerOp, NULL);
+            break;
+        }
+
+        InitializerOp = RsCompleteNodeAndGetNext (InitializerOp);
+    }
+
+    /* Validate the Min/Max/Len/Gran values */
+
+    RsLargeAddressCheck (
+        Descriptor->Address64.Minimum,
+        Descriptor->Address64.Maximum,
+        Descriptor->Address64.AddressLength,
+        Descriptor->Address64.Granularity,
+        Descriptor->Address64.Flags,
+        MinOp, MaxOp, LengthOp, GranOp, Info->DescriptorTypeOp);
+
+    Rnode->BufferLength = sizeof (AML_RESOURCE_ADDRESS64) +
+        OptionIndex + StringLength;
+    return (Rnode);
+}
diff --git a/usr/src/cmd/acpi/iasl/aslrestype2s.c b/usr/src/cmd/acpi/iasl/aslrestype2s.c
new file mode 100644
index 0000000000..fcd8e23781
--- /dev/null
+++ b/usr/src/cmd/acpi/iasl/aslrestype2s.c
@@ -0,0 +1,1230 @@
+/******************************************************************************
+ *
+ * Module Name: aslrestype2s - Serial Large resource descriptors
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2016, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include "aslcompiler.h"
+#include "aslcompiler.y.h"
+#include "amlcode.h"
+
+#define _COMPONENT          ACPI_COMPILER
+        ACPI_MODULE_NAME    ("aslrestype2s")
+
+
+static UINT16
+RsGetBufferDataLength (
+    ACPI_PARSE_OBJECT       *InitializerOp);
+
+static UINT16
+RsGetInterruptDataLength (
+    ACPI_PARSE_OBJECT       *InitializerOp);
+
+static BOOLEAN
+RsGetVendorData (
+    ACPI_PARSE_OBJECT       *InitializerOp,
+    UINT8                   *VendorData,
+    ACPI_SIZE               DescriptorOffset);
+
+/*
+ * This module contains descriptors for serial buses and GPIO:
+ *
+ * GpioInt
+ * GpioIo
+ * I2cSerialBus
+ * SpiSerialBus
+ * UartSerialBus
+ */
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    RsGetBufferDataLength
+ *
+ * PARAMETERS:  InitializerOp       - Current parse op, start of the resource
+ *                                    descriptor
+ *
+ * RETURN:      Length of the data buffer
+ *
+ * DESCRIPTION: Get the length of a RawDataBuffer, used for vendor data.
+ *
+ ******************************************************************************/
+
+static UINT16
+RsGetBufferDataLength (
+    ACPI_PARSE_OBJECT       *InitializerOp)
+{
+    UINT16                  ExtraDataSize = 0;
+    ACPI_PARSE_OBJECT       *DataList;
+
+
+    /* Find the byte-initializer list */
+
+    while (InitializerOp)
+    {
+        if (InitializerOp->Asl.ParseOpcode == PARSEOP_DATABUFFER)
+        {
+            /* First child is the optional length (ignore it here) */
+
+            DataList = InitializerOp->Asl.Child;
+            DataList = ASL_GET_PEER_NODE (DataList);
+
+            /* Count the data items (each one is a byte of data) */
+
+            while (DataList)
+            {
+                ExtraDataSize++;
+                DataList = ASL_GET_PEER_NODE (DataList);
+            }
+
+            return (ExtraDataSize);
+        }
+
+        InitializerOp = ASL_GET_PEER_NODE (InitializerOp);
+    }
+
+    return (ExtraDataSize);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    RsGetInterruptDataLength
+ *
+ * PARAMETERS:  InitializerOp       - Current parse op, start of the resource
+ *                                    descriptor
+ *
+ * RETURN:      Length of the interrupt data list
+ *
+ * DESCRIPTION: Get the length of a list of interrupt DWORDs for the GPIO
+ *              descriptors.
+ *
+ ******************************************************************************/
+
+static UINT16
+RsGetInterruptDataLength (
+    ACPI_PARSE_OBJECT       *InitializerOp)
+{
+    UINT16                  InterruptLength;
+    UINT32                  i;
+
+
+    /* Count the interrupt numbers */
+
+    InterruptLength = 0;
+    for (i = 0; InitializerOp; i++)
+    {
+        InitializerOp = ASL_GET_PEER_NODE (InitializerOp);
+
+        /* Interrupt list starts at offset 10 (Gpio descriptors) */
+
+        if (i >= 10)
+        {
+            InterruptLength += 2;
+        }
+    }
+
+    return (InterruptLength);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    RsGetVendorData
+ *
+ * PARAMETERS:  InitializerOp       - Current parse op, start of the resource
+ *                                    descriptor.
+ *              VendorData          - Where the vendor data is returned
+ *              DescriptorOffset    - Where vendor data begins in descriptor
+ *
+ * RETURN:      TRUE if valid vendor data was returned, FALSE otherwise.
+ *
+ * DESCRIPTION: Extract the vendor data and construct a vendor data buffer.
+ *
+ ******************************************************************************/
+
+static BOOLEAN
+RsGetVendorData (
+    ACPI_PARSE_OBJECT       *InitializerOp,
+    UINT8                   *VendorData,
+    ACPI_SIZE               DescriptorOffset)
+{
+    ACPI_PARSE_OBJECT       *BufferOp;
+    UINT32                  SpecifiedLength = ACPI_UINT32_MAX;
+    UINT16                  ActualLength = 0;
+
+
+    /* Vendor Data field is always optional */
+
+    if (InitializerOp->Asl.ParseOpcode == PARSEOP_DEFAULT_ARG)
+    {
+        return (FALSE);
+    }
+
+    BufferOp = InitializerOp->Asl.Child;
+    if (!BufferOp)
+    {
+        AslError (ASL_ERROR, ASL_MSG_SYNTAX, InitializerOp, "");
+        return (FALSE);
+    }
+
+    /* First child is the optional buffer length (WORD) */
+
+    if (BufferOp->Asl.ParseOpcode != PARSEOP_DEFAULT_ARG)
+    {
+        SpecifiedLength = (UINT16) BufferOp->Asl.Value.Integer;
+    }
+
+    /* Insert field tag _VEN */
+
+    RsCreateByteField (InitializerOp, ACPI_RESTAG_VENDORDATA,
+        (UINT16) DescriptorOffset);
+
+    /* Walk the list of buffer initializers (each is one byte) */
+
+    BufferOp = RsCompleteNodeAndGetNext (BufferOp);
+    if (BufferOp->Asl.ParseOpcode != PARSEOP_DEFAULT_ARG)
+    {
+        while (BufferOp)
+        {
+            *VendorData = (UINT8) BufferOp->Asl.Value.Integer;
+            VendorData++;
+            ActualLength++;
+            BufferOp = RsCompleteNodeAndGetNext (BufferOp);
+        }
+    }
+
+    /* Length validation. Buffer cannot be of zero length */
+
+    if ((SpecifiedLength == 0) ||
+        ((SpecifiedLength == ACPI_UINT32_MAX) && (ActualLength == 0)))
+    {
+        AslError (ASL_ERROR, ASL_MSG_BUFFER_LENGTH, InitializerOp, NULL);
+        return (FALSE);
+    }
+
+    if (SpecifiedLength != ACPI_UINT32_MAX)
+    {
+        /* ActualLength > SpecifiedLength -> error */
+
+        if (ActualLength > SpecifiedLength)
+        {
+            AslError (ASL_ERROR, ASL_MSG_LIST_LENGTH_LONG, InitializerOp, NULL);
+            return (FALSE);
+        }
+
+        /* ActualLength < SpecifiedLength -> remark */
+
+        else if (ActualLength < SpecifiedLength)
+        {
+            AslError (ASL_REMARK, ASL_MSG_LIST_LENGTH_SHORT, InitializerOp, NULL);
+            return (FALSE);
+        }
+    }
+
+    return (TRUE);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    RsDoGpioIntDescriptor
+ *
+ * PARAMETERS:  Info                - Parse Op and resource template offset
+ *
+ * RETURN:      Completed resource node
+ *
+ * DESCRIPTION: Construct a long "GpioInt" descriptor
+ *
+ ******************************************************************************/
+
+ASL_RESOURCE_NODE *
+RsDoGpioIntDescriptor (
+    ASL_RESOURCE_INFO       *Info)
+{
+    AML_RESOURCE            *Descriptor;
+    ACPI_PARSE_OBJECT       *InitializerOp;
+    ASL_RESOURCE_NODE       *Rnode;
+    char                    *ResourceSource = NULL;
+    UINT8                   *VendorData = NULL;
+    UINT16                  *InterruptList = NULL;
+    UINT16                  *PinList = NULL;
+    UINT16                  ResSourceLength;
+    UINT16                  VendorLength;
+    UINT16                  InterruptLength;
+    UINT16                  DescriptorSize;
+    UINT32                  CurrentByteOffset;
+    UINT32                  PinCount = 0;
+    UINT32                  i;
+
+
+    InitializerOp = Info->DescriptorTypeOp->Asl.Child;
+    CurrentByteOffset = Info->CurrentByteOffset;
+
+    /*
+     * Calculate lengths for fields that have variable length:
+     * 1) Resource Source string
+     * 2) Vendor Data buffer
+     * 3) PIN (interrupt) list
+     */
+    ResSourceLength = RsGetStringDataLength (InitializerOp);
+    VendorLength = RsGetBufferDataLength (InitializerOp);
+    InterruptLength = RsGetInterruptDataLength (InitializerOp);
+
+    DescriptorSize = ACPI_AML_SIZE_LARGE (AML_RESOURCE_GPIO) +
+        ResSourceLength + VendorLength + InterruptLength;
+
+    /* Allocate the local resource node and initialize */
+
+    Rnode = RsAllocateResourceNode (DescriptorSize +
+        sizeof (AML_RESOURCE_LARGE_HEADER));
+
+    Descriptor = Rnode->Buffer;
+    Descriptor->Gpio.ResourceLength = DescriptorSize;
+    Descriptor->Gpio.DescriptorType = ACPI_RESOURCE_NAME_GPIO;
+    Descriptor->Gpio.RevisionId = AML_RESOURCE_GPIO_REVISION;
+    Descriptor->Gpio.ConnectionType = AML_RESOURCE_GPIO_TYPE_INT;
+
+    /* Build pointers to optional areas */
+
+    InterruptList = ACPI_ADD_PTR (UINT16, Descriptor,
+        sizeof (AML_RESOURCE_GPIO));
+    PinList = InterruptList;
+    ResourceSource = ACPI_ADD_PTR (char, InterruptList, InterruptLength);
+    VendorData = ACPI_ADD_PTR (UINT8, ResourceSource, ResSourceLength);
+
+    /* Setup offsets within the descriptor */
+
+    Descriptor->Gpio.PinTableOffset = (UINT16)
+        ACPI_PTR_DIFF (InterruptList, Descriptor);
+
+    Descriptor->Gpio.ResSourceOffset = (UINT16)
+        ACPI_PTR_DIFF (ResourceSource, Descriptor);
+
+    /* Process all child initialization nodes */
+
+    for (i = 0; InitializerOp; i++)
+    {
+        switch (i)
+        {
+        case 0: /* Interrupt Mode - edge/level [Flag] (_MOD) */
+
+            RsSetFlagBits16 (&Descriptor->Gpio.IntFlags, InitializerOp, 0, 0);
+            RsCreateBitField (InitializerOp, ACPI_RESTAG_MODE,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (Gpio.IntFlags), 0);
+            break;
+
+        case 1: /* Interrupt Polarity - Active high/low [Flags] (_POL) */
+
+            RsSetFlagBits16 (&Descriptor->Gpio.IntFlags, InitializerOp, 1, 0);
+            RsCreateMultiBitField (InitializerOp, ACPI_RESTAG_POLARITY,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (Gpio.IntFlags), 1, 2);
+            break;
+
+        case 2: /* Share Type - Default: exclusive (0) [Flags] (_SHR) */
+
+            RsSetFlagBits16 (&Descriptor->Gpio.IntFlags, InitializerOp, 3, 0);
+            RsCreateMultiBitField (InitializerOp, ACPI_RESTAG_INTERRUPTSHARE,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (Gpio.IntFlags), 3, 2);
+            break;
+
+        case 3: /* Pin Config [BYTE] (_PPI) */
+
+            Descriptor->Gpio.PinConfig = (UINT8) InitializerOp->Asl.Value.Integer;
+            RsCreateByteField (InitializerOp, ACPI_RESTAG_PINCONFIG,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (Gpio.PinConfig));
+            break;
+
+        case 4: /* Debounce Timeout [WORD] (_DBT) */
+
+            Descriptor->Gpio.DebounceTimeout = (UINT16) InitializerOp->Asl.Value.Integer;
+            RsCreateWordField (InitializerOp, ACPI_RESTAG_DEBOUNCETIME,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (Gpio.DebounceTimeout));
+            break;
+
+        case 5: /* ResSource [Optional Field - STRING] */
+
+            if (ResSourceLength)
+            {
+                /* Copy string to the descriptor */
+
+                strcpy (ResourceSource,
+                    InitializerOp->Asl.Value.String);
+            }
+            break;
+
+        case 6: /* Resource Index */
+
+            if (InitializerOp->Asl.ParseOpcode != PARSEOP_DEFAULT_ARG)
+            {
+                Descriptor->Gpio.ResSourceIndex =
+                    (UINT8) InitializerOp->Asl.Value.Integer;
+            }
+            break;
+
+        case 7: /* Resource Usage (consumer/producer) */
+
+            RsSetFlagBits16 (&Descriptor->Gpio.Flags, InitializerOp, 0, 1);
+            break;
+
+        case 8: /* Resource Tag (Descriptor Name) */
+
+            UtAttachNamepathToOwner (Info->DescriptorTypeOp, InitializerOp);
+            break;
+
+        case 9: /* Vendor Data (Optional - Buffer of BYTEs) (_VEN) */
+
+            /*
+             * Always set the VendorOffset even if there is no Vendor Data.
+             * This field is required in order to calculate the length
+             * of the ResourceSource at runtime.
+             */
+            Descriptor->Gpio.VendorOffset = (UINT16)
+                ACPI_PTR_DIFF (VendorData, Descriptor);
+
+            if (RsGetVendorData (InitializerOp, VendorData,
+                (CurrentByteOffset +  Descriptor->Gpio.VendorOffset)))
+            {
+                Descriptor->Gpio.VendorLength = VendorLength;
+            }
+            break;
+
+        default:
+            /*
+             * PINs come through here, repeatedly. Each PIN must be a WORD.
+             * NOTE: there is no "length" field for this, so from ACPI spec:
+             *  The number of pins in the table can be calculated from:
+             *  PinCount = (Resource Source Name Offset - Pin Table Offset) / 2
+             *  (implies resource source must immediately follow the pin list.)
+             *  Name: _PIN
+             */
+            *InterruptList = (UINT16) InitializerOp->Asl.Value.Integer;
+            InterruptList++;
+            PinCount++;
+
+            /* Case 10: First interrupt number in list */
+
+            if (i == 10)
+            {
+                if (InitializerOp->Asl.ParseOpcode == PARSEOP_DEFAULT_ARG)
+                {
+                    /* Must be at least one interrupt */
+
+                    AslError (ASL_ERROR, ASL_MSG_EX_INTERRUPT_LIST_MIN,
+                        InitializerOp, NULL);
+                }
+
+                /* Check now for duplicates in list */
+
+                RsCheckListForDuplicates (InitializerOp);
+
+                /* Create a named field at the start of the list */
+
+                RsCreateWordField (InitializerOp, ACPI_RESTAG_PIN,
+                    CurrentByteOffset + Descriptor->Gpio.PinTableOffset);
+            }
+            break;
+        }
+
+        InitializerOp = RsCompleteNodeAndGetNext (InitializerOp);
+    }
+
+    MpSaveGpioInfo (Info->MappingOp, Descriptor,
+        PinCount, PinList, ResourceSource);
+    return (Rnode);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    RsDoGpioIoDescriptor
+ *
+ * PARAMETERS:  Info                - Parse Op and resource template offset
+ *
+ * RETURN:      Completed resource node
+ *
+ * DESCRIPTION: Construct a long "GpioIo" descriptor
+ *
+ ******************************************************************************/
+
+ASL_RESOURCE_NODE *
+RsDoGpioIoDescriptor (
+    ASL_RESOURCE_INFO       *Info)
+{
+    AML_RESOURCE            *Descriptor;
+    ACPI_PARSE_OBJECT       *InitializerOp;
+    ASL_RESOURCE_NODE       *Rnode;
+    char                    *ResourceSource = NULL;
+    UINT8                   *VendorData = NULL;
+    UINT16                  *InterruptList = NULL;
+    UINT16                  *PinList = NULL;
+    UINT16                  ResSourceLength;
+    UINT16                  VendorLength;
+    UINT16                  InterruptLength;
+    UINT16                  DescriptorSize;
+    UINT32                  CurrentByteOffset;
+    UINT32                  PinCount = 0;
+    UINT32                  i;
+
+
+    InitializerOp = Info->DescriptorTypeOp->Asl.Child;
+    CurrentByteOffset = Info->CurrentByteOffset;
+
+    /*
+     * Calculate lengths for fields that have variable length:
+     * 1) Resource Source string
+     * 2) Vendor Data buffer
+     * 3) PIN (interrupt) list
+     */
+    ResSourceLength = RsGetStringDataLength (InitializerOp);
+    VendorLength = RsGetBufferDataLength (InitializerOp);
+    InterruptLength = RsGetInterruptDataLength (InitializerOp);
+    PinList = InterruptList;
+
+    DescriptorSize = ACPI_AML_SIZE_LARGE (AML_RESOURCE_GPIO) +
+        ResSourceLength + VendorLength + InterruptLength;
+
+    /* Allocate the local resource node and initialize */
+
+    Rnode = RsAllocateResourceNode (DescriptorSize +
+        sizeof (AML_RESOURCE_LARGE_HEADER));
+
+    Descriptor = Rnode->Buffer;
+    Descriptor->Gpio.ResourceLength = DescriptorSize;
+    Descriptor->Gpio.DescriptorType = ACPI_RESOURCE_NAME_GPIO;
+    Descriptor->Gpio.RevisionId = AML_RESOURCE_GPIO_REVISION;
+    Descriptor->Gpio.ConnectionType = AML_RESOURCE_GPIO_TYPE_IO;
+
+    /* Build pointers to optional areas */
+
+    InterruptList = ACPI_ADD_PTR (UINT16, Descriptor, sizeof (AML_RESOURCE_GPIO));
+    PinList = InterruptList;
+    ResourceSource = ACPI_ADD_PTR (char, InterruptList, InterruptLength);
+    VendorData = ACPI_ADD_PTR (UINT8, ResourceSource, ResSourceLength);
+
+    /* Setup offsets within the descriptor */
+
+    Descriptor->Gpio.PinTableOffset = (UINT16)
+        ACPI_PTR_DIFF (InterruptList, Descriptor);
+
+    Descriptor->Gpio.ResSourceOffset = (UINT16)
+        ACPI_PTR_DIFF (ResourceSource, Descriptor);
+
+    /* Process all child initialization nodes */
+
+    for (i = 0; InitializerOp; i++)
+    {
+        switch (i)
+        {
+        case 0: /* Share Type [Flags] (_SHR) */
+
+            RsSetFlagBits16 (&Descriptor->Gpio.IntFlags, InitializerOp, 3, 0);
+            RsCreateBitField (InitializerOp, ACPI_RESTAG_INTERRUPTSHARE,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (Gpio.IntFlags), 3);
+            break;
+
+        case 1: /* Pin Config [BYTE] (_PPI) */
+
+            Descriptor->Gpio.PinConfig = (UINT8) InitializerOp->Asl.Value.Integer;
+            RsCreateByteField (InitializerOp, ACPI_RESTAG_PINCONFIG,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (Gpio.PinConfig));
+            break;
+
+        case 2: /* Debounce Timeout [WORD] (_DBT) */
+
+            Descriptor->Gpio.DebounceTimeout = (UINT16) InitializerOp->Asl.Value.Integer;
+            RsCreateWordField (InitializerOp, ACPI_RESTAG_DEBOUNCETIME,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (Gpio.DebounceTimeout));
+            break;
+
+        case 3: /* Drive Strength [WORD] (_DRS) */
+
+            Descriptor->Gpio.DriveStrength = (UINT16) InitializerOp->Asl.Value.Integer;
+            RsCreateWordField (InitializerOp, ACPI_RESTAG_DRIVESTRENGTH,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (Gpio.DriveStrength));
+            break;
+
+        case 4: /* I/O Restriction [Flag] (_IOR) */
+
+            RsSetFlagBits16 (&Descriptor->Gpio.IntFlags, InitializerOp, 0, 0);
+            RsCreateMultiBitField (InitializerOp, ACPI_RESTAG_IORESTRICTION,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (Gpio.IntFlags), 0, 2);
+            break;
+
+        case 5: /* ResSource [Optional Field - STRING] */
+
+            if (ResSourceLength)
+            {
+                /* Copy string to the descriptor */
+
+                strcpy (ResourceSource,
+                    InitializerOp->Asl.Value.String);
+            }
+            break;
+
+        case 6: /* Resource Index */
+
+            if (InitializerOp->Asl.ParseOpcode != PARSEOP_DEFAULT_ARG)
+            {
+                Descriptor->Gpio.ResSourceIndex = (UINT8) InitializerOp->Asl.Value.Integer;
+            }
+            break;
+
+        case 7: /* Resource Usage (consumer/producer) */
+
+            RsSetFlagBits16 (&Descriptor->Gpio.Flags, InitializerOp, 0, 1);
+            break;
+
+        case 8: /* Resource Tag (Descriptor Name) */
+
+            UtAttachNamepathToOwner (Info->DescriptorTypeOp, InitializerOp);
+            break;
+
+        case 9: /* Vendor Data (Optional - Buffer of BYTEs) (_VEN) */
+            /*
+             * Always set the VendorOffset even if there is no Vendor Data.
+             * This field is required in order to calculate the length
+             * of the ResourceSource at runtime.
+             */
+            Descriptor->Gpio.VendorOffset = (UINT16)
+                ACPI_PTR_DIFF (VendorData, Descriptor);
+
+            if (RsGetVendorData (InitializerOp, VendorData,
+                (CurrentByteOffset + Descriptor->Gpio.VendorOffset)))
+            {
+                Descriptor->Gpio.VendorLength = VendorLength;
+            }
+            break;
+
+        default:
+            /*
+             * PINs come through here, repeatedly. Each PIN must be a WORD.
+             * NOTE: there is no "length" field for this, so from ACPI spec:
+             *  The number of pins in the table can be calculated from:
+             *  PinCount = (Resource Source Name Offset - Pin Table Offset) / 2
+             *  (implies resource source must immediately follow the pin list.)
+             *  Name: _PIN
+             */
+            *InterruptList = (UINT16) InitializerOp->Asl.Value.Integer;
+            InterruptList++;
+            PinCount++;
+
+            /* Case 10: First interrupt number in list */
+
+            if (i == 10)
+            {
+                if (InitializerOp->Asl.ParseOpcode == PARSEOP_DEFAULT_ARG)
+                {
+                    /* Must be at least one interrupt */
+
+                    AslError (ASL_ERROR, ASL_MSG_EX_INTERRUPT_LIST_MIN,
+                        InitializerOp, NULL);
+                }
+
+                /* Check now for duplicates in list */
+
+                RsCheckListForDuplicates (InitializerOp);
+
+                /* Create a named field at the start of the list */
+
+                RsCreateWordField (InitializerOp, ACPI_RESTAG_PIN,
+                    CurrentByteOffset + Descriptor->Gpio.PinTableOffset);
+            }
+            break;
+        }
+
+        InitializerOp = RsCompleteNodeAndGetNext (InitializerOp);
+    }
+
+    MpSaveGpioInfo (Info->MappingOp, Descriptor,
+        PinCount, PinList, ResourceSource);
+    return (Rnode);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    RsDoI2cSerialBusDescriptor
+ *
+ * PARAMETERS:  Info                - Parse Op and resource template offset
+ *
+ * RETURN:      Completed resource node
+ *
+ * DESCRIPTION: Construct a long "I2cSerialBus" descriptor
+ *
+ ******************************************************************************/
+
+ASL_RESOURCE_NODE *
+RsDoI2cSerialBusDescriptor (
+    ASL_RESOURCE_INFO       *Info)
+{
+    AML_RESOURCE            *Descriptor;
+    ACPI_PARSE_OBJECT       *InitializerOp;
+    ASL_RESOURCE_NODE       *Rnode;
+    char                    *ResourceSource = NULL;
+    UINT8                   *VendorData = NULL;
+    UINT16                  ResSourceLength;
+    UINT16                  VendorLength;
+    UINT16                  DescriptorSize;
+    UINT32                  CurrentByteOffset;
+    UINT32                  i;
+
+
+    InitializerOp = Info->DescriptorTypeOp->Asl.Child;
+    CurrentByteOffset = Info->CurrentByteOffset;
+
+    /*
+     * Calculate lengths for fields that have variable length:
+     * 1) Resource Source string
+     * 2) Vendor Data buffer
+     */
+    ResSourceLength = RsGetStringDataLength (InitializerOp);
+    VendorLength = RsGetBufferDataLength (InitializerOp);
+
+    DescriptorSize = ACPI_AML_SIZE_LARGE (AML_RESOURCE_I2C_SERIALBUS) +
+        ResSourceLength + VendorLength;
+
+    /* Allocate the local resource node and initialize */
+
+    Rnode = RsAllocateResourceNode (DescriptorSize +
+        sizeof (AML_RESOURCE_LARGE_HEADER));
+
+    Descriptor = Rnode->Buffer;
+    Descriptor->I2cSerialBus.ResourceLength = DescriptorSize;
+    Descriptor->I2cSerialBus.DescriptorType = ACPI_RESOURCE_NAME_SERIAL_BUS;
+    Descriptor->I2cSerialBus.RevisionId = AML_RESOURCE_I2C_REVISION;
+    Descriptor->I2cSerialBus.TypeRevisionId = AML_RESOURCE_I2C_TYPE_REVISION;
+    Descriptor->I2cSerialBus.Type = AML_RESOURCE_I2C_SERIALBUSTYPE;
+    Descriptor->I2cSerialBus.TypeDataLength = AML_RESOURCE_I2C_MIN_DATA_LEN + VendorLength;
+
+    if (Info->DescriptorTypeOp->Asl.ParseOpcode == PARSEOP_I2C_SERIALBUS_V2)
+    {
+        Descriptor->I2cSerialBus.RevisionId = 2;
+    }
+
+    /* Build pointers to optional areas */
+
+    VendorData = ACPI_ADD_PTR (UINT8, Descriptor, sizeof (AML_RESOURCE_I2C_SERIALBUS));
+    ResourceSource = ACPI_ADD_PTR (char, VendorData, VendorLength);
+
+    /* Process all child initialization nodes */
+
+    for (i = 0; InitializerOp; i++)
+    {
+        switch (i)
+        {
+        case 0: /* Slave Address [WORD] (_ADR) */
+
+            Descriptor->I2cSerialBus.SlaveAddress = (UINT16) InitializerOp->Asl.Value.Integer;
+            RsCreateWordField (InitializerOp, ACPI_RESTAG_ADDRESS,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (I2cSerialBus.SlaveAddress));
+            break;
+
+        case 1: /* Slave Mode [Flag] (_SLV) */
+
+            RsSetFlagBits (&Descriptor->I2cSerialBus.Flags, InitializerOp, 0, 0);
+            RsCreateBitField (InitializerOp, ACPI_RESTAG_SLAVEMODE,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (I2cSerialBus.Flags), 0);
+            break;
+
+        case 2: /* Connection Speed [DWORD] (_SPE) */
+
+            Descriptor->I2cSerialBus.ConnectionSpeed = (UINT32) InitializerOp->Asl.Value.Integer;
+            RsCreateDwordField (InitializerOp, ACPI_RESTAG_SPEED,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (I2cSerialBus.ConnectionSpeed));
+            break;
+
+        case 3: /* Addressing Mode [Flag] (_MOD) */
+
+            RsSetFlagBits16 (&Descriptor->I2cSerialBus.TypeSpecificFlags, InitializerOp, 0, 0);
+            RsCreateBitField (InitializerOp, ACPI_RESTAG_MODE,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (I2cSerialBus.TypeSpecificFlags), 0);
+            break;
+
+        case 4: /* ResSource [Optional Field - STRING] */
+
+            if (ResSourceLength)
+            {
+                /* Copy string to the descriptor */
+
+                strcpy (ResourceSource,
+                    InitializerOp->Asl.Value.String);
+            }
+            break;
+
+        case 5: /* Resource Index */
+
+            if (InitializerOp->Asl.ParseOpcode != PARSEOP_DEFAULT_ARG)
+            {
+                Descriptor->I2cSerialBus.ResSourceIndex =
+                    (UINT8) InitializerOp->Asl.Value.Integer;
+            }
+            break;
+
+        case 6: /* Resource Usage (consumer/producer) */
+
+            RsSetFlagBits (&Descriptor->I2cSerialBus.Flags, InitializerOp, 1, 1);
+            break;
+
+        case 7: /* Resource Tag (Descriptor Name) */
+
+            UtAttachNamepathToOwner (Info->DescriptorTypeOp, InitializerOp);
+            break;
+
+        case 8:
+            /*
+             * Connection Share - Added for V2 (ACPI 6.0) version of the descriptor
+             * Note: For V1, the share bit will be zero (Op is DEFAULT_ARG from
+             * the ASL parser)
+             */
+            RsSetFlagBits (&Descriptor->I2cSerialBus.Flags, InitializerOp, 2, 0);
+            RsCreateBitField (InitializerOp, ACPI_RESTAG_INTERRUPTSHARE,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (I2cSerialBus.Flags), 2);
+            break;
+
+        case 9: /* Vendor Data (Optional - Buffer of BYTEs) (_VEN) */
+
+            RsGetVendorData (InitializerOp, VendorData,
+                CurrentByteOffset + sizeof (AML_RESOURCE_I2C_SERIALBUS));
+            break;
+
+        default:    /* Ignore any extra nodes */
+
+            break;
+        }
+
+        InitializerOp = RsCompleteNodeAndGetNext (InitializerOp);
+    }
+
+    MpSaveSerialInfo (Info->MappingOp, Descriptor, ResourceSource);
+    return (Rnode);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    RsDoSpiSerialBusDescriptor
+ *
+ * PARAMETERS:  Info                - Parse Op and resource template offset
+ *
+ * RETURN:      Completed resource node
+ *
+ * DESCRIPTION: Construct a long "SPI Serial Bus" descriptor
+ *
+ ******************************************************************************/
+
+ASL_RESOURCE_NODE *
+RsDoSpiSerialBusDescriptor (
+    ASL_RESOURCE_INFO       *Info)
+{
+    AML_RESOURCE            *Descriptor;
+    ACPI_PARSE_OBJECT       *InitializerOp;
+    ASL_RESOURCE_NODE       *Rnode;
+    char                    *ResourceSource = NULL;
+    UINT8                   *VendorData = NULL;
+    UINT16                  ResSourceLength;
+    UINT16                  VendorLength;
+    UINT16                  DescriptorSize;
+    UINT32                  CurrentByteOffset;
+    UINT32                  i;
+
+
+    InitializerOp = Info->DescriptorTypeOp->Asl.Child;
+    CurrentByteOffset = Info->CurrentByteOffset;
+
+    /*
+     * Calculate lengths for fields that have variable length:
+     * 1) Resource Source string
+     * 2) Vendor Data buffer
+     */
+    ResSourceLength = RsGetStringDataLength (InitializerOp);
+    VendorLength = RsGetBufferDataLength (InitializerOp);
+
+    DescriptorSize = ACPI_AML_SIZE_LARGE (AML_RESOURCE_SPI_SERIALBUS) +
+        ResSourceLength + VendorLength;
+
+    /* Allocate the local resource node and initialize */
+
+    Rnode = RsAllocateResourceNode (DescriptorSize +
+        sizeof (AML_RESOURCE_LARGE_HEADER));
+
+    Descriptor = Rnode->Buffer;
+    Descriptor->SpiSerialBus.ResourceLength = DescriptorSize;
+    Descriptor->SpiSerialBus.DescriptorType = ACPI_RESOURCE_NAME_SERIAL_BUS;
+    Descriptor->SpiSerialBus.RevisionId = AML_RESOURCE_SPI_REVISION;
+    Descriptor->SpiSerialBus.TypeRevisionId = AML_RESOURCE_SPI_TYPE_REVISION;
+    Descriptor->SpiSerialBus.Type = AML_RESOURCE_SPI_SERIALBUSTYPE;
+    Descriptor->SpiSerialBus.TypeDataLength = AML_RESOURCE_SPI_MIN_DATA_LEN + VendorLength;
+
+    if (Info->DescriptorTypeOp->Asl.ParseOpcode == PARSEOP_SPI_SERIALBUS_V2)
+    {
+        Descriptor->I2cSerialBus.RevisionId = 2;
+    }
+
+    /* Build pointers to optional areas */
+
+    VendorData = ACPI_ADD_PTR (UINT8, Descriptor,
+        sizeof (AML_RESOURCE_SPI_SERIALBUS));
+    ResourceSource = ACPI_ADD_PTR (char, VendorData, VendorLength);
+
+    /* Process all child initialization nodes */
+
+    for (i = 0; InitializerOp; i++)
+    {
+        switch (i)
+        {
+        case 0: /* Device Selection [WORD] (_ADR) */
+
+            Descriptor->SpiSerialBus.DeviceSelection = (UINT16) InitializerOp->Asl.Value.Integer;
+            RsCreateWordField (InitializerOp, ACPI_RESTAG_ADDRESS,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (SpiSerialBus.DeviceSelection));
+            break;
+
+        case 1: /* Device Polarity [Flag] (_DPL) */
+
+            RsSetFlagBits16 (&Descriptor->SpiSerialBus.TypeSpecificFlags, InitializerOp, 1, 0);
+            RsCreateBitField (InitializerOp, ACPI_RESTAG_DEVICEPOLARITY,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (SpiSerialBus.TypeSpecificFlags), 1);
+            break;
+
+        case 2: /* Wire Mode [Flag] (_MOD) */
+
+            RsSetFlagBits16 (&Descriptor->SpiSerialBus.TypeSpecificFlags, InitializerOp, 0, 0);
+            RsCreateBitField (InitializerOp, ACPI_RESTAG_MODE,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (SpiSerialBus.TypeSpecificFlags), 0);
+            break;
+
+        case 3: /* Device Bit Length [BYTE] (_LEN) */
+
+            Descriptor->SpiSerialBus.DataBitLength = (UINT8) InitializerOp->Asl.Value.Integer;
+            RsCreateByteField (InitializerOp, ACPI_RESTAG_LENGTH,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (SpiSerialBus.DataBitLength));
+            break;
+
+        case 4: /* Slave Mode [Flag] (_SLV) */
+
+            RsSetFlagBits (&Descriptor->SpiSerialBus.Flags, InitializerOp, 0, 0);
+            RsCreateBitField (InitializerOp, ACPI_RESTAG_SLAVEMODE,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (SpiSerialBus.Flags), 0);
+            break;
+
+        case 5: /* Connection Speed [DWORD] (_SPE) */
+
+            Descriptor->SpiSerialBus.ConnectionSpeed = (UINT32) InitializerOp->Asl.Value.Integer;
+            RsCreateDwordField (InitializerOp, ACPI_RESTAG_SPEED,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (SpiSerialBus.ConnectionSpeed));
+            break;
+
+        case 6: /* Clock Polarity [BYTE] (_POL) */
+
+            Descriptor->SpiSerialBus.ClockPolarity = (UINT8) InitializerOp->Asl.Value.Integer;
+            RsCreateByteField (InitializerOp, ACPI_RESTAG_POLARITY,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (SpiSerialBus.ClockPolarity));
+            break;
+
+        case 7: /* Clock Phase [BYTE] (_PHA) */
+
+            Descriptor->SpiSerialBus.ClockPhase = (UINT8) InitializerOp->Asl.Value.Integer;
+            RsCreateByteField (InitializerOp, ACPI_RESTAG_PHASE,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (SpiSerialBus.ClockPhase));
+            break;
+
+        case 8: /* ResSource [Optional Field - STRING] */
+
+            if (ResSourceLength)
+            {
+                /* Copy string to the descriptor */
+
+                strcpy (ResourceSource,
+                    InitializerOp->Asl.Value.String);
+            }
+            break;
+
+        case 9: /* Resource Index */
+
+            if (InitializerOp->Asl.ParseOpcode != PARSEOP_DEFAULT_ARG)
+            {
+                Descriptor->SpiSerialBus.ResSourceIndex =
+                    (UINT8) InitializerOp->Asl.Value.Integer;
+            }
+            break;
+
+        case 10: /* Resource Usage (consumer/producer) */
+
+            RsSetFlagBits (&Descriptor->SpiSerialBus.Flags, InitializerOp, 1, 1);
+            break;
+
+        case 11: /* Resource Tag (Descriptor Name) */
+
+            UtAttachNamepathToOwner (Info->DescriptorTypeOp, InitializerOp);
+            break;
+
+        case 12:
+            /*
+             * Connection Share - Added for V2 (ACPI 6.0) version of the descriptor
+             * Note: For V1, the share bit will be zero (Op is DEFAULT_ARG from
+             * the ASL parser)
+             */
+            RsSetFlagBits (&Descriptor->SpiSerialBus.Flags, InitializerOp, 2, 0);
+            RsCreateBitField (InitializerOp, ACPI_RESTAG_INTERRUPTSHARE,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (SpiSerialBus.Flags), 2);
+            break;
+
+        case 13: /* Vendor Data (Optional - Buffer of BYTEs) (_VEN) */
+
+            RsGetVendorData (InitializerOp, VendorData,
+                CurrentByteOffset + sizeof (AML_RESOURCE_SPI_SERIALBUS));
+            break;
+
+        default:    /* Ignore any extra nodes */
+
+            break;
+        }
+
+        InitializerOp = RsCompleteNodeAndGetNext (InitializerOp);
+    }
+
+    MpSaveSerialInfo (Info->MappingOp, Descriptor, ResourceSource);
+    return (Rnode);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    RsDoUartSerialBusDescriptor
+ *
+ * PARAMETERS:  Info                - Parse Op and resource template offset
+ *
+ * RETURN:      Completed resource node
+ *
+ * DESCRIPTION: Construct a long "UART Serial Bus" descriptor
+ *
+ ******************************************************************************/
+
+ASL_RESOURCE_NODE *
+RsDoUartSerialBusDescriptor (
+    ASL_RESOURCE_INFO       *Info)
+{
+    AML_RESOURCE            *Descriptor;
+    ACPI_PARSE_OBJECT       *InitializerOp;
+    ASL_RESOURCE_NODE       *Rnode;
+    char                    *ResourceSource = NULL;
+    UINT8                   *VendorData = NULL;
+    UINT16                  ResSourceLength;
+    UINT16                  VendorLength;
+    UINT16                  DescriptorSize;
+    UINT32                  CurrentByteOffset;
+    UINT32                  i;
+
+
+    InitializerOp = Info->DescriptorTypeOp->Asl.Child;
+    CurrentByteOffset = Info->CurrentByteOffset;
+
+    /*
+     * Calculate lengths for fields that have variable length:
+     * 1) Resource Source string
+     * 2) Vendor Data buffer
+     */
+    ResSourceLength = RsGetStringDataLength (InitializerOp);
+    VendorLength = RsGetBufferDataLength (InitializerOp);
+
+    DescriptorSize = ACPI_AML_SIZE_LARGE (AML_RESOURCE_UART_SERIALBUS) +
+        ResSourceLength + VendorLength;
+
+    /* Allocate the local resource node and initialize */
+
+    Rnode = RsAllocateResourceNode (DescriptorSize +
+        sizeof (AML_RESOURCE_LARGE_HEADER));
+
+    Descriptor = Rnode->Buffer;
+    Descriptor->UartSerialBus.ResourceLength = DescriptorSize;
+    Descriptor->UartSerialBus.DescriptorType = ACPI_RESOURCE_NAME_SERIAL_BUS;
+    Descriptor->UartSerialBus.RevisionId = AML_RESOURCE_UART_REVISION;
+    Descriptor->UartSerialBus.TypeRevisionId = AML_RESOURCE_UART_TYPE_REVISION;
+    Descriptor->UartSerialBus.Type = AML_RESOURCE_UART_SERIALBUSTYPE;
+    Descriptor->UartSerialBus.TypeDataLength = AML_RESOURCE_UART_MIN_DATA_LEN + VendorLength;
+
+    if (Info->DescriptorTypeOp->Asl.ParseOpcode == PARSEOP_UART_SERIALBUS_V2)
+    {
+        Descriptor->I2cSerialBus.RevisionId = 2;
+    }
+
+    /* Build pointers to optional areas */
+
+    VendorData = ACPI_ADD_PTR (UINT8, Descriptor, sizeof (AML_RESOURCE_UART_SERIALBUS));
+    ResourceSource = ACPI_ADD_PTR (char, VendorData, VendorLength);
+
+    /* Process all child initialization nodes */
+
+    for (i = 0; InitializerOp; i++)
+    {
+        switch (i)
+        {
+        case 0: /* Connection Speed (Baud Rate) [DWORD] (_SPE) */
+
+            Descriptor->UartSerialBus.DefaultBaudRate = (UINT32) InitializerOp->Asl.Value.Integer;
+            RsCreateDwordField (InitializerOp, ACPI_RESTAG_SPEED,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (UartSerialBus.DefaultBaudRate));
+            break;
+
+        case 1: /* Bits Per Byte [Flags] (_LEN) */
+
+            RsSetFlagBits16 (&Descriptor->UartSerialBus.TypeSpecificFlags, InitializerOp, 4, 3);
+            RsCreateMultiBitField (InitializerOp, ACPI_RESTAG_LENGTH,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (UartSerialBus.TypeSpecificFlags), 4, 3);
+            break;
+
+        case 2: /* Stop Bits [Flags] (_STB) */
+
+            RsSetFlagBits16 (&Descriptor->UartSerialBus.TypeSpecificFlags, InitializerOp, 2, 1);
+            RsCreateMultiBitField (InitializerOp, ACPI_RESTAG_STOPBITS,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (UartSerialBus.TypeSpecificFlags), 2, 2);
+            break;
+
+        case 3: /* Lines In Use [BYTE] (_LIN) */
+
+            Descriptor->UartSerialBus.LinesEnabled = (UINT8) InitializerOp->Asl.Value.Integer;
+            RsCreateByteField (InitializerOp, ACPI_RESTAG_LINE,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (UartSerialBus.LinesEnabled));
+            break;
+
+        case 4: /* Endianness [Flag] (_END) */
+
+            RsSetFlagBits16 (&Descriptor->UartSerialBus.TypeSpecificFlags, InitializerOp, 7, 0);
+            RsCreateBitField (InitializerOp, ACPI_RESTAG_ENDIANNESS,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (UartSerialBus.TypeSpecificFlags), 7);
+            break;
+
+        case 5: /* Parity [BYTE] (_PAR) */
+
+            Descriptor->UartSerialBus.Parity = (UINT8) InitializerOp->Asl.Value.Integer;
+            RsCreateByteField (InitializerOp, ACPI_RESTAG_PARITY,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (UartSerialBus.Parity));
+            break;
+
+        case 6: /* Flow Control [Flags] (_FLC) */
+
+            RsSetFlagBits16 (&Descriptor->UartSerialBus.TypeSpecificFlags, InitializerOp, 0, 0);
+            RsCreateMultiBitField (InitializerOp, ACPI_RESTAG_FLOWCONTROL,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (UartSerialBus.TypeSpecificFlags), 0, 2);
+            break;
+
+        case 7: /* Rx Buffer Size [WORD] (_RXL) */
+
+            Descriptor->UartSerialBus.RxFifoSize = (UINT16) InitializerOp->Asl.Value.Integer;
+            RsCreateWordField (InitializerOp, ACPI_RESTAG_LENGTH_RX,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (UartSerialBus.RxFifoSize));
+            break;
+
+        case 8: /* Tx Buffer Size [WORD] (_TXL) */
+
+            Descriptor->UartSerialBus.TxFifoSize = (UINT16) InitializerOp->Asl.Value.Integer;
+            RsCreateWordField (InitializerOp, ACPI_RESTAG_LENGTH_TX,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (UartSerialBus.TxFifoSize));
+            break;
+
+        case 9: /* ResSource [Optional Field - STRING] */
+
+            if (ResSourceLength)
+            {
+                /* Copy string to the descriptor */
+
+                strcpy (ResourceSource,
+                    InitializerOp->Asl.Value.String);
+            }
+            break;
+
+        case 10: /* Resource Index */
+
+            if (InitializerOp->Asl.ParseOpcode != PARSEOP_DEFAULT_ARG)
+            {
+                Descriptor->UartSerialBus.ResSourceIndex =
+                    (UINT8) InitializerOp->Asl.Value.Integer;
+            }
+            break;
+
+        case 11: /* Resource Usage (consumer/producer) */
+
+            RsSetFlagBits (&Descriptor->UartSerialBus.Flags, InitializerOp, 1, 1);
+
+            /*
+             * Slave Mode [Flag] (_SLV)
+             *
+             * Note: There is no SlaveMode argument to the UartSerialBus macro, but
+             * we add this name anyway to allow the flag to be set by ASL in the
+             * rare case where there is a slave mode associated with the UART.
+             */
+            RsCreateBitField (InitializerOp, ACPI_RESTAG_SLAVEMODE,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (UartSerialBus.Flags), 0);
+            break;
+
+        case 12: /* Resource Tag (Descriptor Name) */
+
+            UtAttachNamepathToOwner (Info->DescriptorTypeOp, InitializerOp);
+            break;
+
+        case 13:
+            /*
+             * Connection Share - Added for V2 (ACPI 6.0) version of the descriptor
+             * Note: For V1, the share bit will be zero (Op is DEFAULT_ARG from
+             * the ASL parser)
+             */
+            RsSetFlagBits (&Descriptor->UartSerialBus.Flags, InitializerOp, 2, 0);
+            RsCreateBitField (InitializerOp, ACPI_RESTAG_INTERRUPTSHARE,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (UartSerialBus.Flags), 2);
+            break;
+
+        case 14: /* Vendor Data (Optional - Buffer of BYTEs) (_VEN) */
+
+            RsGetVendorData (InitializerOp, VendorData,
+                CurrentByteOffset + sizeof (AML_RESOURCE_UART_SERIALBUS));
+            break;
+
+        default:    /* Ignore any extra nodes */
+
+            break;
+        }
+
+        InitializerOp = RsCompleteNodeAndGetNext (InitializerOp);
+    }
+
+    MpSaveSerialInfo (Info->MappingOp, Descriptor, ResourceSource);
+    return (Rnode);
+}
diff --git a/usr/src/cmd/acpi/iasl/aslrestype2w.c b/usr/src/cmd/acpi/iasl/aslrestype2w.c
new file mode 100644
index 0000000000..0b88c70acd
--- /dev/null
+++ b/usr/src/cmd/acpi/iasl/aslrestype2w.c
@@ -0,0 +1,697 @@
+/******************************************************************************
+ *
+ * Module Name: aslrestype2w - Large Word address resource descriptors
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2016, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include "aslcompiler.h"
+#include "aslcompiler.y.h"
+
+#define _COMPONENT          ACPI_COMPILER
+        ACPI_MODULE_NAME    ("aslrestype2w")
+
+/*
+ * This module contains the Word (16-bit) address space descriptors:
+ *
+ * WordIO
+ * WordMemory
+ * WordSpace
+ */
+
+/*******************************************************************************
+ *
+ * FUNCTION:    RsDoWordIoDescriptor
+ *
+ * PARAMETERS:  Info                - Parse Op and resource template offset
+ *
+ * RETURN:      Completed resource node
+ *
+ * DESCRIPTION: Construct a long "WordIO" descriptor
+ *
+ ******************************************************************************/
+
+ASL_RESOURCE_NODE *
+RsDoWordIoDescriptor (
+    ASL_RESOURCE_INFO       *Info)
+{
+    AML_RESOURCE            *Descriptor;
+    ACPI_PARSE_OBJECT       *InitializerOp;
+    ACPI_PARSE_OBJECT       *MinOp = NULL;
+    ACPI_PARSE_OBJECT       *MaxOp = NULL;
+    ACPI_PARSE_OBJECT       *LengthOp = NULL;
+    ACPI_PARSE_OBJECT       *GranOp = NULL;
+    ASL_RESOURCE_NODE       *Rnode;
+    UINT8                   *OptionalFields;
+    UINT16                  StringLength = 0;
+    UINT32                  OptionIndex = 0;
+    UINT32                  CurrentByteOffset;
+    UINT32                  i;
+    BOOLEAN                 ResSourceIndex = FALSE;
+
+
+    InitializerOp = Info->DescriptorTypeOp->Asl.Child;
+    StringLength = RsGetStringDataLength (InitializerOp);
+    CurrentByteOffset = Info->CurrentByteOffset;
+
+    Rnode = RsAllocateResourceNode (
+        sizeof (AML_RESOURCE_ADDRESS16) + 1 + StringLength);
+
+    Descriptor = Rnode->Buffer;
+    Descriptor->Address16.DescriptorType = ACPI_RESOURCE_NAME_ADDRESS16;
+    Descriptor->Address16.ResourceType = ACPI_ADDRESS_TYPE_IO_RANGE;
+
+    /*
+     * Initial descriptor length -- may be enlarged if there are
+     * optional fields present
+     */
+    OptionalFields = ((UINT8 *) Descriptor) + sizeof (AML_RESOURCE_ADDRESS16);
+    Descriptor->Address16.ResourceLength = (UINT16)
+        (sizeof (AML_RESOURCE_ADDRESS16) -
+         sizeof (AML_RESOURCE_LARGE_HEADER));
+
+    /* Process all child initialization nodes */
+
+    for (i = 0; InitializerOp; i++)
+    {
+        switch (i)
+        {
+        case 0: /* Resource Usage */
+
+            RsSetFlagBits (&Descriptor->Address16.Flags, InitializerOp, 0, 1);
+            break;
+
+        case 1: /* MinType */
+
+            RsSetFlagBits (&Descriptor->Address16.Flags, InitializerOp, 2, 0);
+            RsCreateBitField (InitializerOp, ACPI_RESTAG_MINTYPE,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (Address16.Flags), 2);
+            break;
+
+        case 2: /* MaxType */
+
+            RsSetFlagBits (&Descriptor->Address16.Flags, InitializerOp, 3, 0);
+            RsCreateBitField (InitializerOp, ACPI_RESTAG_MAXTYPE,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (Address16.Flags), 3);
+            break;
+
+        case 3: /* DecodeType */
+
+            RsSetFlagBits (&Descriptor->Address16.Flags, InitializerOp, 1, 0);
+            RsCreateBitField (InitializerOp, ACPI_RESTAG_DECODE,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (Address16.Flags), 1);
+            break;
+
+        case 4: /* Range Type */
+
+            RsSetFlagBits (&Descriptor->Address16.SpecificFlags, InitializerOp, 0, 3);
+            RsCreateMultiBitField (InitializerOp, ACPI_RESTAG_RANGETYPE,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (Address16.SpecificFlags), 0, 2);
+            break;
+
+        case 5: /* Address Granularity */
+
+            Descriptor->Address16.Granularity = (UINT16) InitializerOp->Asl.Value.Integer;
+            RsCreateWordField (InitializerOp, ACPI_RESTAG_GRANULARITY,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (Address16.Granularity));
+            GranOp = InitializerOp;
+            break;
+
+        case 6: /* Address Min */
+
+            Descriptor->Address16.Minimum = (UINT16) InitializerOp->Asl.Value.Integer;
+            RsCreateWordField (InitializerOp, ACPI_RESTAG_MINADDR,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (Address16.Minimum));
+            MinOp = InitializerOp;
+            break;
+
+        case 7: /* Address Max */
+
+            Descriptor->Address16.Maximum = (UINT16) InitializerOp->Asl.Value.Integer;
+            RsCreateWordField (InitializerOp, ACPI_RESTAG_MAXADDR,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (Address16.Maximum));
+            MaxOp = InitializerOp;
+            break;
+
+        case 8: /* Translation Offset */
+
+            Descriptor->Address16.TranslationOffset = (UINT16) InitializerOp->Asl.Value.Integer;
+            RsCreateWordField (InitializerOp, ACPI_RESTAG_TRANSLATION,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (Address16.TranslationOffset));
+            break;
+
+        case 9: /* Address Length */
+
+            Descriptor->Address16.AddressLength = (UINT16) InitializerOp->Asl.Value.Integer;
+            RsCreateWordField (InitializerOp, ACPI_RESTAG_LENGTH,
+                 CurrentByteOffset + ASL_RESDESC_OFFSET (Address16.AddressLength));
+            LengthOp = InitializerOp;
+            break;
+
+        case 10: /* ResSourceIndex [Optional Field - BYTE] */
+
+            if (InitializerOp->Asl.ParseOpcode != PARSEOP_DEFAULT_ARG)
+            {
+                OptionalFields[0] = (UINT8) InitializerOp->Asl.Value.Integer;
+                OptionIndex++;
+                Descriptor->Address16.ResourceLength++;
+                ResSourceIndex = TRUE;
+            }
+            break;
+
+        case 11: /* ResSource [Optional Field - STRING] */
+
+            if ((InitializerOp->Asl.ParseOpcode != PARSEOP_DEFAULT_ARG) &&
+                (InitializerOp->Asl.Value.String))
+            {
+                if (StringLength)
+                {
+                    Descriptor->Address16.ResourceLength = (UINT16)
+                        (Descriptor->Address16.ResourceLength + StringLength);
+
+                    strcpy ((char *)
+                        &OptionalFields[OptionIndex],
+                        InitializerOp->Asl.Value.String);
+
+                    /* ResourceSourceIndex must also be valid */
+
+                    if (!ResSourceIndex)
+                    {
+                        AslError (ASL_ERROR, ASL_MSG_RESOURCE_INDEX,
+                            InitializerOp, NULL);
+                    }
+                }
+            }
+
+#if 0
+            /*
+             * Not a valid ResourceSource, ResourceSourceIndex must also
+             * be invalid
+             */
+            else if (ResSourceIndex)
+            {
+                AslError (ASL_ERROR, ASL_MSG_RESOURCE_SOURCE,
+                    InitializerOp, NULL);
+            }
+#endif
+            break;
+
+        case 12: /* ResourceTag */
+
+            UtAttachNamepathToOwner (Info->DescriptorTypeOp, InitializerOp);
+            break;
+
+        case 13: /* Type */
+
+            RsSetFlagBits (&Descriptor->Address16.SpecificFlags, InitializerOp, 4, 0);
+            RsCreateBitField (InitializerOp, ACPI_RESTAG_TYPE,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (Address16.SpecificFlags), 4);
+            break;
+
+        case 14: /* Translation Type */
+
+            RsSetFlagBits (&Descriptor->Address16.SpecificFlags, InitializerOp, 5, 0);
+            RsCreateBitField (InitializerOp, ACPI_RESTAG_TRANSTYPE,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (Address16.SpecificFlags), 5);
+            break;
+
+        default:
+
+            AslError (ASL_ERROR, ASL_MSG_RESOURCE_LIST, InitializerOp, NULL);
+            break;
+        }
+
+        InitializerOp = RsCompleteNodeAndGetNext (InitializerOp);
+    }
+
+    /* Validate the Min/Max/Len/Gran values */
+
+    RsLargeAddressCheck (
+        (UINT64) Descriptor->Address16.Minimum,
+        (UINT64) Descriptor->Address16.Maximum,
+        (UINT64) Descriptor->Address16.AddressLength,
+        (UINT64) Descriptor->Address16.Granularity,
+        Descriptor->Address16.Flags,
+        MinOp, MaxOp, LengthOp, GranOp, Info->DescriptorTypeOp);
+
+    Rnode->BufferLength = sizeof (AML_RESOURCE_ADDRESS16) +
+        OptionIndex + StringLength;
+    return (Rnode);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    RsDoWordBusNumberDescriptor
+ *
+ * PARAMETERS:  Info                - Parse Op and resource template offset
+ *
+ * RETURN:      Completed resource node
+ *
+ * DESCRIPTION: Construct a long "WordBusNumber" descriptor
+ *
+ ******************************************************************************/
+
+ASL_RESOURCE_NODE *
+RsDoWordBusNumberDescriptor (
+    ASL_RESOURCE_INFO       *Info)
+{
+    AML_RESOURCE            *Descriptor;
+    ACPI_PARSE_OBJECT       *InitializerOp;
+    ACPI_PARSE_OBJECT       *MinOp = NULL;
+    ACPI_PARSE_OBJECT       *MaxOp = NULL;
+    ACPI_PARSE_OBJECT       *LengthOp = NULL;
+    ACPI_PARSE_OBJECT       *GranOp = NULL;
+    ASL_RESOURCE_NODE       *Rnode;
+    UINT8                   *OptionalFields;
+    UINT16                  StringLength = 0;
+    UINT32                  OptionIndex = 0;
+    UINT32                  CurrentByteOffset;
+    UINT32                  i;
+    BOOLEAN                 ResSourceIndex = FALSE;
+
+
+    InitializerOp = Info->DescriptorTypeOp->Asl.Child;
+    StringLength = RsGetStringDataLength (InitializerOp);
+    CurrentByteOffset = Info->CurrentByteOffset;
+
+    Rnode = RsAllocateResourceNode (
+        sizeof (AML_RESOURCE_ADDRESS16) + 1 + StringLength);
+
+    Descriptor = Rnode->Buffer;
+    Descriptor->Address16.DescriptorType = ACPI_RESOURCE_NAME_ADDRESS16;
+    Descriptor->Address16.ResourceType = ACPI_ADDRESS_TYPE_BUS_NUMBER_RANGE;
+
+    /*
+     * Initial descriptor length -- may be enlarged if there are
+     * optional fields present
+     */
+    OptionalFields = ((UINT8 *) Descriptor) + sizeof (AML_RESOURCE_ADDRESS16);
+    Descriptor->Address16.ResourceLength = (UINT16)
+        (sizeof (AML_RESOURCE_ADDRESS16) -
+         sizeof (AML_RESOURCE_LARGE_HEADER));
+
+    /* Process all child initialization nodes */
+
+    for (i = 0; InitializerOp; i++)
+    {
+        switch (i)
+        {
+        case 0: /* Resource Usage */
+
+            RsSetFlagBits (&Descriptor->Address16.Flags, InitializerOp, 0, 1);
+            break;
+
+        case 1: /* MinType */
+
+            RsSetFlagBits (&Descriptor->Address16.Flags, InitializerOp, 2, 0);
+            RsCreateBitField (InitializerOp, ACPI_RESTAG_MINTYPE,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (Address16.Flags), 2);
+            break;
+
+        case 2: /* MaxType */
+
+            RsSetFlagBits (&Descriptor->Address16.Flags, InitializerOp, 3, 0);
+            RsCreateBitField (InitializerOp, ACPI_RESTAG_MAXTYPE,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (Address16.Flags), 3);
+            break;
+
+        case 3: /* DecodeType */
+
+            RsSetFlagBits (&Descriptor->Address16.Flags, InitializerOp, 1, 0);
+            RsCreateBitField (InitializerOp, ACPI_RESTAG_DECODE,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (Address16.Flags), 1);
+            break;
+
+        case 4: /* Address Granularity */
+
+            Descriptor->Address16.Granularity =
+                (UINT16) InitializerOp->Asl.Value.Integer;
+            RsCreateWordField (InitializerOp, ACPI_RESTAG_GRANULARITY,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (Address16.Granularity));
+            GranOp = InitializerOp;
+            break;
+
+        case 5: /* Min Address */
+
+            Descriptor->Address16.Minimum =
+                (UINT16) InitializerOp->Asl.Value.Integer;
+            RsCreateWordField (InitializerOp, ACPI_RESTAG_MINADDR,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (Address16.Minimum));
+            MinOp = InitializerOp;
+            break;
+
+        case 6: /* Max Address */
+
+            Descriptor->Address16.Maximum =
+                (UINT16) InitializerOp->Asl.Value.Integer;
+            RsCreateWordField (InitializerOp, ACPI_RESTAG_MAXADDR,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (Address16.Maximum));
+            MaxOp = InitializerOp;
+            break;
+
+        case 7: /* Translation Offset */
+
+            Descriptor->Address16.TranslationOffset =
+                (UINT16) InitializerOp->Asl.Value.Integer;
+            RsCreateWordField (InitializerOp, ACPI_RESTAG_TRANSLATION,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (Address16.TranslationOffset));
+            break;
+
+        case 8: /* Address Length */
+
+            Descriptor->Address16.AddressLength =
+                (UINT16) InitializerOp->Asl.Value.Integer;
+            RsCreateWordField (InitializerOp, ACPI_RESTAG_LENGTH,
+                 CurrentByteOffset + ASL_RESDESC_OFFSET (Address16.AddressLength));
+            LengthOp = InitializerOp;
+            break;
+
+        case 9: /* ResSourceIndex [Optional Field - BYTE] */
+
+            if (InitializerOp->Asl.ParseOpcode != PARSEOP_DEFAULT_ARG)
+            {
+                OptionalFields[0] = (UINT8) InitializerOp->Asl.Value.Integer;
+                OptionIndex++;
+                Descriptor->Address16.ResourceLength++;
+                ResSourceIndex = TRUE;
+            }
+            break;
+
+        case 10: /* ResSource [Optional Field - STRING] */
+
+            if ((InitializerOp->Asl.ParseOpcode != PARSEOP_DEFAULT_ARG) &&
+                (InitializerOp->Asl.Value.String))
+            {
+                if (StringLength)
+                {
+                    Descriptor->Address16.ResourceLength = (UINT16)
+                        (Descriptor->Address16.ResourceLength + StringLength);
+
+                    strcpy ((char *)
+                        &OptionalFields[OptionIndex],
+                        InitializerOp->Asl.Value.String);
+
+                    /* ResourceSourceIndex must also be valid */
+
+                    if (!ResSourceIndex)
+                    {
+                        AslError (ASL_ERROR, ASL_MSG_RESOURCE_INDEX,
+                            InitializerOp, NULL);
+                    }
+                }
+            }
+
+#if 0
+            /*
+             * Not a valid ResourceSource, ResourceSourceIndex must also
+             * be invalid
+             */
+            else if (ResSourceIndex)
+            {
+                AslError (ASL_ERROR, ASL_MSG_RESOURCE_SOURCE,
+                    InitializerOp, NULL);
+            }
+#endif
+            break;
+
+        case 11: /* ResourceTag */
+
+            UtAttachNamepathToOwner (Info->DescriptorTypeOp, InitializerOp);
+            break;
+
+        default:
+
+            AslError (ASL_ERROR, ASL_MSG_RESOURCE_LIST, InitializerOp, NULL);
+            break;
+        }
+
+        InitializerOp = RsCompleteNodeAndGetNext (InitializerOp);
+    }
+
+    /* Validate the Min/Max/Len/Gran values */
+
+    RsLargeAddressCheck (
+        (UINT64) Descriptor->Address16.Minimum,
+        (UINT64) Descriptor->Address16.Maximum,
+        (UINT64) Descriptor->Address16.AddressLength,
+        (UINT64) Descriptor->Address16.Granularity,
+        Descriptor->Address16.Flags,
+        MinOp, MaxOp, LengthOp, GranOp, Info->DescriptorTypeOp);
+
+    Rnode->BufferLength = sizeof (AML_RESOURCE_ADDRESS16) +
+        OptionIndex + StringLength;
+    return (Rnode);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    RsDoWordSpaceDescriptor
+ *
+ * PARAMETERS:  Info                - Parse Op and resource template offset
+ *
+ * RETURN:      Completed resource node
+ *
+ * DESCRIPTION: Construct a long "WordSpace" descriptor
+ *
+ ******************************************************************************/
+
+ASL_RESOURCE_NODE *
+RsDoWordSpaceDescriptor (
+    ASL_RESOURCE_INFO       *Info)
+{
+    AML_RESOURCE            *Descriptor;
+    ACPI_PARSE_OBJECT       *InitializerOp;
+    ACPI_PARSE_OBJECT       *MinOp = NULL;
+    ACPI_PARSE_OBJECT       *MaxOp = NULL;
+    ACPI_PARSE_OBJECT       *LengthOp = NULL;
+    ACPI_PARSE_OBJECT       *GranOp = NULL;
+    ASL_RESOURCE_NODE       *Rnode;
+    UINT8                   *OptionalFields;
+    UINT16                  StringLength = 0;
+    UINT32                  OptionIndex = 0;
+    UINT32                  CurrentByteOffset;
+    UINT32                  i;
+    BOOLEAN                 ResSourceIndex = FALSE;
+
+
+    InitializerOp = Info->DescriptorTypeOp->Asl.Child;
+    StringLength = RsGetStringDataLength (InitializerOp);
+    CurrentByteOffset = Info->CurrentByteOffset;
+
+    Rnode = RsAllocateResourceNode (
+        sizeof (AML_RESOURCE_ADDRESS16) + 1 + StringLength);
+
+    Descriptor = Rnode->Buffer;
+    Descriptor->Address16.DescriptorType = ACPI_RESOURCE_NAME_ADDRESS16;
+
+    /*
+     * Initial descriptor length -- may be enlarged if there are
+     * optional fields present
+     */
+    OptionalFields = ((UINT8 *) Descriptor) + sizeof (AML_RESOURCE_ADDRESS16);
+    Descriptor->Address16.ResourceLength = (UINT16)
+        (sizeof (AML_RESOURCE_ADDRESS16) -
+         sizeof (AML_RESOURCE_LARGE_HEADER));
+
+    /* Process all child initialization nodes */
+
+    for (i = 0; InitializerOp; i++)
+    {
+        switch (i)
+        {
+        case 0: /* Resource Type */
+
+            Descriptor->Address16.ResourceType =
+                (UINT8) InitializerOp->Asl.Value.Integer;
+            break;
+
+        case 1: /* Resource Usage */
+
+            RsSetFlagBits (&Descriptor->Address16.Flags, InitializerOp, 0, 1);
+            break;
+
+        case 2: /* DecodeType */
+
+            RsSetFlagBits (&Descriptor->Address16.Flags, InitializerOp, 1, 0);
+            RsCreateBitField (InitializerOp, ACPI_RESTAG_DECODE,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (Address16.Flags), 1);
+            break;
+
+        case 3: /* MinType */
+
+            RsSetFlagBits (&Descriptor->Address16.Flags, InitializerOp, 2, 0);
+            RsCreateBitField (InitializerOp, ACPI_RESTAG_MINTYPE,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (Address16.Flags), 2);
+            break;
+
+        case 4: /* MaxType */
+
+            RsSetFlagBits (&Descriptor->Address16.Flags, InitializerOp, 3, 0);
+            RsCreateBitField (InitializerOp, ACPI_RESTAG_MAXTYPE,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (Address16.Flags), 3);
+            break;
+
+        case 5: /* Type-Specific flags */
+
+            Descriptor->Address16.SpecificFlags =
+                (UINT8) InitializerOp->Asl.Value.Integer;
+            break;
+
+        case 6: /* Address Granularity */
+
+            Descriptor->Address16.Granularity =
+                (UINT16) InitializerOp->Asl.Value.Integer;
+            RsCreateWordField (InitializerOp, ACPI_RESTAG_GRANULARITY,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (Address16.Granularity));
+            GranOp = InitializerOp;
+            break;
+
+        case 7: /* Min Address */
+
+            Descriptor->Address16.Minimum =
+                (UINT16) InitializerOp->Asl.Value.Integer;
+            RsCreateWordField (InitializerOp, ACPI_RESTAG_MINADDR,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (Address16.Minimum));
+            MinOp = InitializerOp;
+            break;
+
+        case 8: /* Max Address */
+
+            Descriptor->Address16.Maximum =
+                (UINT16) InitializerOp->Asl.Value.Integer;
+            RsCreateWordField (InitializerOp, ACPI_RESTAG_MAXADDR,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (Address16.Maximum));
+            MaxOp = InitializerOp;
+            break;
+
+        case 9: /* Translation Offset */
+
+            Descriptor->Address16.TranslationOffset =
+                (UINT16) InitializerOp->Asl.Value.Integer;
+            RsCreateWordField (InitializerOp, ACPI_RESTAG_TRANSLATION,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (Address16.TranslationOffset));
+            break;
+
+        case 10: /* Address Length */
+
+            Descriptor->Address16.AddressLength =
+                (UINT16) InitializerOp->Asl.Value.Integer;
+            RsCreateWordField (InitializerOp, ACPI_RESTAG_LENGTH,
+                CurrentByteOffset + ASL_RESDESC_OFFSET (Address16.AddressLength));
+            LengthOp = InitializerOp;
+            break;
+
+        case 11: /* ResSourceIndex [Optional Field - BYTE] */
+
+            if (InitializerOp->Asl.ParseOpcode != PARSEOP_DEFAULT_ARG)
+            {
+                OptionalFields[0] = (UINT8) InitializerOp->Asl.Value.Integer;
+                OptionIndex++;
+                Descriptor->Address16.ResourceLength++;
+                ResSourceIndex = TRUE;
+            }
+            break;
+
+        case 12: /* ResSource [Optional Field - STRING] */
+
+            if ((InitializerOp->Asl.ParseOpcode != PARSEOP_DEFAULT_ARG) &&
+                (InitializerOp->Asl.Value.String))
+            {
+                if (StringLength)
+                {
+                    Descriptor->Address16.ResourceLength = (UINT16)
+                        (Descriptor->Address16.ResourceLength + StringLength);
+
+                    strcpy ((char *)
+                        &OptionalFields[OptionIndex],
+                        InitializerOp->Asl.Value.String);
+
+                    /* ResourceSourceIndex must also be valid */
+
+                    if (!ResSourceIndex)
+                    {
+                        AslError (ASL_ERROR, ASL_MSG_RESOURCE_INDEX,
+                            InitializerOp, NULL);
+                    }
+                }
+            }
+
+#if 0
+            /*
+             * Not a valid ResourceSource, ResourceSourceIndex must also
+             * be invalid
+             */
+            else if (ResSourceIndex)
+            {
+                AslError (ASL_ERROR, ASL_MSG_RESOURCE_SOURCE,
+                    InitializerOp, NULL);
+            }
+#endif
+            break;
+
+        case 13: /* ResourceTag */
+
+            UtAttachNamepathToOwner (Info->DescriptorTypeOp, InitializerOp);
+            break;
+
+        default:
+
+            AslError (ASL_ERROR, ASL_MSG_RESOURCE_LIST, InitializerOp, NULL);
+            break;
+        }
+
+        InitializerOp = RsCompleteNodeAndGetNext (InitializerOp);
+    }
+
+    /* Validate the Min/Max/Len/Gran values */
+
+    RsLargeAddressCheck (
+        (UINT64) Descriptor->Address16.Minimum,
+        (UINT64) Descriptor->Address16.Maximum,
+        (UINT64) Descriptor->Address16.AddressLength,
+        (UINT64) Descriptor->Address16.Granularity,
+        Descriptor->Address16.Flags,
+        MinOp, MaxOp, LengthOp, GranOp, Info->DescriptorTypeOp);
+
+    Rnode->BufferLength = sizeof (AML_RESOURCE_ADDRESS16) +
+        OptionIndex + StringLength;
+    return (Rnode);
+}
diff --git a/usr/src/cmd/acpi/iasl/aslrules.y b/usr/src/cmd/acpi/iasl/aslrules.y
new file mode 100644
index 0000000000..a5d8387d7e
--- /dev/null
+++ b/usr/src/cmd/acpi/iasl/aslrules.y
@@ -0,0 +1,1746 @@
+NoEcho('
+/******************************************************************************
+ *
+ * Module Name: aslrules.y - Main Bison/Yacc production rules
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2016, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+')
+
+/*******************************************************************************
+ *
+ * ASL Root and Secondary Terms
+ *
+ ******************************************************************************/
+
+/*
+ * Root term. Allow multiple #line directives before the definition block
+ * to handle output from preprocessors
+ */
+AslCode
+    : DefinitionBlockList           {$<n>$ = TrLinkChildren (TrCreateLeafNode (PARSEOP_ASL_CODE),1, $1);}
+    | error                         {YYABORT; $$ = NULL;}
+    ;
+
+
+/*
+ * Note concerning support for "module-level code".
+ *
+ * ACPI 1.0 allowed Type1 and Type2 executable opcodes outside of control
+ * methods (the so-called module-level code.) This support was explicitly
+ * removed in ACPI 2.0, but this type of code continues to be created by
+ * BIOS vendors. In order to support the disassembly and recompilation of
+ * such code (and the porting of ASL code to iASL), iASL supports this
+ * code in violation of the current ACPI specification.
+ *
+ * The grammar change to support module-level code is to revert the
+ * {ObjectList} portion of the DefinitionBlockTerm in ACPI 2.0 to the
+ * original use of {TermList} instead (see below.) This allows the use
+ * of Type1 and Type2 opcodes at module level.
+ *
+ * 04/2016: The module-level code is now allowed in the following terms:
+ * DeviceTerm, PowerResTerm, ProcessorTerm, ScopeTerm, ThermalZoneTerm.
+ * The ObjectList term is obsolete and has been removed.
+ */
+DefinitionBlockTerm
+    : PARSEOP_DEFINITION_BLOCK '('  {$<n>$ = TrCreateLeafNode (PARSEOP_DEFINITION_BLOCK);}
+        String ','
+        String ','
+        ByteConst ','
+        String ','
+        String ','
+        DWordConst
+        ')'                         {TrSetEndLineNumber ($<n>3);}
+            '{' TermList '}'        {$$ = TrLinkChildren ($<n>3,7,$4,$6,$8,$10,$12,$14,$18);}
+    ;
+
+DefinitionBlockList
+    : DefinitionBlockTerm
+    | DefinitionBlockTerm
+        DefinitionBlockList         {$$ = TrLinkPeerNodes (2, $1,$2);}
+    ;
+
+SuperName
+    : NameString                    {}
+    | ArgTerm                       {}
+    | LocalTerm                     {}
+    | DebugTerm                     {}
+    | Type6Opcode                   {}
+
+Target
+    :                               {$$ = TrCreateNullTarget ();} /* Placeholder is a ZeroOp object */
+    | ','                           {$$ = TrCreateNullTarget ();} /* Placeholder is a ZeroOp object */
+    | ',' SuperName                 {$$ = TrSetNodeFlags ($2, NODE_IS_TARGET);}
+    ;
+
+TermArg
+    : Type2Opcode                   {$$ = TrSetNodeFlags ($1, NODE_IS_TERM_ARG);}
+    | DataObject                    {$$ = TrSetNodeFlags ($1, NODE_IS_TERM_ARG);}
+    | NameString                    {$$ = TrSetNodeFlags ($1, NODE_IS_TERM_ARG);}
+    | ArgTerm                       {$$ = TrSetNodeFlags ($1, NODE_IS_TERM_ARG);}
+    | LocalTerm                     {$$ = TrSetNodeFlags ($1, NODE_IS_TERM_ARG);}
+    ;
+
+/*
+ NOTE: Removed from TermArg due to reduce/reduce conflicts:
+    | Type2IntegerOpcode            {$$ = TrSetNodeFlags ($1, NODE_IS_TERM_ARG);}
+    | Type2StringOpcode             {$$ = TrSetNodeFlags ($1, NODE_IS_TERM_ARG);}
+    | Type2BufferOpcode             {$$ = TrSetNodeFlags ($1, NODE_IS_TERM_ARG);}
+    | Type2BufferOrStringOpcode     {$$ = TrSetNodeFlags ($1, NODE_IS_TERM_ARG);}
+
+*/
+
+MethodInvocationTerm
+    : NameString '('                {TrUpdateNode (PARSEOP_METHODCALL, $1);}
+        ArgList ')'                 {$$ = TrLinkChildNode ($1,$4);}
+    ;
+
+/* OptionalCount must appear before ByteList or an incorrect reduction will result */
+
+OptionalCount
+    :                               {$$ = TrCreateLeafNode (PARSEOP_ONES);}       /* Placeholder is a OnesOp object */
+    | ','                           {$$ = TrCreateLeafNode (PARSEOP_ONES);}       /* Placeholder is a OnesOp object */
+    | ',' TermArg                   {$$ = $2;}
+    ;
+
+VarPackageLengthTerm
+    :                               {$$ = TrCreateLeafNode (PARSEOP_DEFAULT_ARG);}
+    | TermArg                       {$$ = $1;}
+    ;
+
+
+/******* List Terms **************************************************/
+
+ArgList
+    :                               {$$ = NULL;}
+    | TermArg
+    | ArgList ','                   /* Allows a trailing comma at list end */
+    | ArgList ','
+        TermArg                     {$$ = TrLinkPeerNode ($1,$3);}
+    ;
+
+ByteList
+    :                               {$$ = NULL;}
+    | ByteConstExpr
+    | ByteList ','                  /* Allows a trailing comma at list end */
+    | ByteList ','
+        ByteConstExpr               {$$ = TrLinkPeerNode ($1,$3);}
+    ;
+
+DWordList
+    :                               {$$ = NULL;}
+    | DWordConstExpr
+    | DWordList ','                 /* Allows a trailing comma at list end */
+    | DWordList ','
+        DWordConstExpr              {$$ = TrLinkPeerNode ($1,$3);}
+    ;
+
+FieldUnitList
+    :                               {$$ = NULL;}
+    | FieldUnit
+    | FieldUnitList ','             /* Allows a trailing comma at list end */
+    | FieldUnitList ','
+        FieldUnit                   {$$ = TrLinkPeerNode ($1,$3);}
+    ;
+
+FieldUnit
+    : FieldUnitEntry                {}
+    | OffsetTerm                    {}
+    | AccessAsTerm                  {}
+    | ConnectionTerm                {}
+    ;
+
+FieldUnitEntry
+    : ',' AmlPackageLengthTerm      {$$ = TrCreateNode (PARSEOP_RESERVED_BYTES,1,$2);}
+    | NameSeg ','
+        AmlPackageLengthTerm        {$$ = TrLinkChildNode ($1,$3);}
+    ;
+
+Object
+    : CompilerDirective             {}
+    | NamedObject                   {}
+    | NameSpaceModifier             {}
+    ;
+
+PackageList
+    :                               {$$ = NULL;}
+    | PackageElement
+    | PackageList ','               /* Allows a trailing comma at list end */
+    | PackageList ','
+        PackageElement              {$$ = TrLinkPeerNode ($1,$3);}
+    ;
+
+PackageElement
+    : DataObject                    {}
+    | NameString                    {}
+    ;
+
+    /* Rules for specifying the type of one method argument or return value */
+
+ParameterTypePackage
+    :                               {$$ = NULL;}
+    | ObjectTypeKeyword             {$$ = $1;}
+    | ParameterTypePackage ','
+        ObjectTypeKeyword           {$$ = TrLinkPeerNodes (2,$1,$3);}
+    ;
+
+ParameterTypePackageList
+    :                               {$$ = NULL;}
+    | ObjectTypeKeyword             {$$ = $1;}
+    | '{' ParameterTypePackage '}'  {$$ = $2;}
+    ;
+
+OptionalParameterTypePackage
+    :                               {$$ = TrCreateLeafNode (PARSEOP_DEFAULT_ARG);}
+    | ',' ParameterTypePackageList  {$$ = TrLinkChildren (TrCreateLeafNode (PARSEOP_DEFAULT_ARG),1,$2);}
+    ;
+
+    /* Rules for specifying the types for method arguments */
+
+ParameterTypesPackage
+    : ParameterTypePackageList      {$$ = $1;}
+    | ParameterTypesPackage ','
+        ParameterTypePackageList    {$$ = TrLinkPeerNodes (2,$1,$3);}
+    ;
+
+ParameterTypesPackageList
+    :                               {$$ = NULL;}
+    | ObjectTypeKeyword             {$$ = $1;}
+    | '{' ParameterTypesPackage '}' {$$ = $2;}
+    ;
+
+OptionalParameterTypesPackage
+    :                               {$$ = TrCreateLeafNode (PARSEOP_DEFAULT_ARG);}
+    | ',' ParameterTypesPackageList {$$ = TrLinkChildren (TrCreateLeafNode (PARSEOP_DEFAULT_ARG),1,$2);}
+    ;
+
+    /* ACPI 3.0 -- allow semicolons between terms */
+
+TermList
+    :                               {$$ = NULL;}
+    | TermList Term                 {$$ = TrLinkPeerNode (TrSetNodeFlags ($1, NODE_RESULT_NOT_USED),$2);}
+    | TermList Term ';'             {$$ = TrLinkPeerNode (TrSetNodeFlags ($1, NODE_RESULT_NOT_USED),$2);}
+    | TermList ';' Term             {$$ = TrLinkPeerNode (TrSetNodeFlags ($1, NODE_RESULT_NOT_USED),$3);}
+    | TermList ';' Term ';'         {$$ = TrLinkPeerNode (TrSetNodeFlags ($1, NODE_RESULT_NOT_USED),$3);}
+    ;
+
+Term
+    : Object                        {}
+    | Type1Opcode                   {}
+    | Type2Opcode                   {}
+    | Type2IntegerOpcode            {$$ = TrSetNodeFlags ($1, NODE_COMPILE_TIME_CONST);}
+    | Type2StringOpcode             {$$ = TrSetNodeFlags ($1, NODE_COMPILE_TIME_CONST);}
+    | Type2BufferOpcode             {}
+    | Type2BufferOrStringOpcode     {}
+    | error                         {$$ = AslDoError(); yyclearin;}
+    ;
+
+/*
+ * Case-Default list; allow only one Default term and unlimited Case terms
+ */
+CaseDefaultTermList
+    :                               {$$ = NULL;}
+    | CaseTerm  {}
+    | DefaultTerm   {}
+    | CaseDefaultTermList
+        CaseTerm                    {$$ = TrLinkPeerNode ($1,$2);}
+    | CaseDefaultTermList
+        DefaultTerm                 {$$ = TrLinkPeerNode ($1,$2);}
+
+/* Original - attempts to force zero or one default term within the switch */
+
+/*
+CaseDefaultTermList
+    :                               {$$ = NULL;}
+    | CaseTermList
+        DefaultTerm
+        CaseTermList                {$$ = TrLinkPeerNode ($1,TrLinkPeerNode ($2, $3));}
+    | CaseTermList
+        CaseTerm                    {$$ = TrLinkPeerNode ($1,$2);}
+    ;
+
+CaseTermList
+    :                               {$$ = NULL;}
+    | CaseTerm                      {}
+    | CaseTermList
+        CaseTerm                    {$$ = TrLinkPeerNode ($1,$2);}
+    ;
+*/
+
+
+/*******************************************************************************
+ *
+ * ASL Data and Constant Terms
+ *
+ ******************************************************************************/
+
+DataObject
+    : BufferData                    {}
+    | PackageData                   {}
+    | IntegerData                   {}
+    | StringData                    {}
+    ;
+
+BufferData
+    : Type5Opcode                   {$$ = TrSetNodeFlags ($1, NODE_COMPILE_TIME_CONST);}
+    | Type2BufferOrStringOpcode     {$$ = TrSetNodeFlags ($1, NODE_COMPILE_TIME_CONST);}
+    | Type2BufferOpcode             {$$ = TrSetNodeFlags ($1, NODE_COMPILE_TIME_CONST);}
+    | BufferTerm                    {}
+    ;
+
+PackageData
+    : PackageTerm                   {}
+    ;
+
+IntegerData
+    : Type2IntegerOpcode            {$$ = TrSetNodeFlags ($1, NODE_COMPILE_TIME_CONST);}
+    | Type3Opcode                   {$$ = TrSetNodeFlags ($1, NODE_COMPILE_TIME_CONST);}
+    | Integer                       {}
+    | ConstTerm                     {}
+    ;
+
+StringData
+    : Type2StringOpcode             {$$ = TrSetNodeFlags ($1, NODE_COMPILE_TIME_CONST);}
+    | String                        {}
+    ;
+
+ByteConst
+    : Integer                       {$$ = TrUpdateNode (PARSEOP_BYTECONST, $1);}
+    ;
+
+WordConst
+    : Integer                       {$$ = TrUpdateNode (PARSEOP_WORDCONST, $1);}
+    ;
+
+DWordConst
+    : Integer                       {$$ = TrUpdateNode (PARSEOP_DWORDCONST, $1);}
+    ;
+
+QWordConst
+    : Integer                       {$$ = TrUpdateNode (PARSEOP_QWORDCONST, $1);}
+    ;
+
+/*
+ * The NODE_COMPILE_TIME_CONST flag in the following constant expressions
+ * enables compile-time constant folding to reduce the Type3Opcodes/Type2IntegerOpcodes
+ * to simple integers. It is an error if these types of expressions cannot be
+ * reduced, since the AML grammar for ****ConstExpr requires a simple constant.
+ * Note: The required byte length of the constant is passed through to the
+ * constant folding code in the node AmlLength field.
+ */
+ByteConstExpr
+    : Type3Opcode                   {$$ = TrSetNodeFlags ($1, NODE_COMPILE_TIME_CONST); TrSetNodeAmlLength ($1, 1);}
+    | Type2IntegerOpcode            {$$ = TrSetNodeFlags ($1, NODE_COMPILE_TIME_CONST); TrSetNodeAmlLength ($1, 1);}
+    | ConstExprTerm                 {$$ = TrUpdateNode (PARSEOP_BYTECONST, $1);}
+    | ByteConst                     {}
+    ;
+
+WordConstExpr
+    : Type3Opcode                   {$$ = TrSetNodeFlags ($1, NODE_COMPILE_TIME_CONST); TrSetNodeAmlLength ($1, 2);}
+    | Type2IntegerOpcode            {$$ = TrSetNodeFlags ($1, NODE_COMPILE_TIME_CONST); TrSetNodeAmlLength ($1, 2);}
+    | ConstExprTerm                 {$$ = TrUpdateNode (PARSEOP_WORDCONST, $1);}
+    | WordConst                     {}
+    ;
+
+DWordConstExpr
+    : Type3Opcode                   {$$ = TrSetNodeFlags ($1, NODE_COMPILE_TIME_CONST); TrSetNodeAmlLength ($1, 4);}
+    | Type2IntegerOpcode            {$$ = TrSetNodeFlags ($1, NODE_COMPILE_TIME_CONST); TrSetNodeAmlLength ($1, 4);}
+    | ConstExprTerm                 {$$ = TrUpdateNode (PARSEOP_DWORDCONST, $1);}
+    | DWordConst                    {}
+    ;
+
+QWordConstExpr
+    : Type3Opcode                   {$$ = TrSetNodeFlags ($1, NODE_COMPILE_TIME_CONST); TrSetNodeAmlLength ($1, 8);}
+    | Type2IntegerOpcode            {$$ = TrSetNodeFlags ($1, NODE_COMPILE_TIME_CONST); TrSetNodeAmlLength ($1, 8);}
+    | ConstExprTerm                 {$$ = TrUpdateNode (PARSEOP_QWORDCONST, $1);}
+    | QWordConst                    {}
+    ;
+
+ConstTerm
+    : ConstExprTerm                 {}
+    | PARSEOP_REVISION              {$$ = TrCreateLeafNode (PARSEOP_REVISION);}
+    ;
+
+ConstExprTerm
+    : PARSEOP_ZERO                  {$$ = TrCreateValuedLeafNode (PARSEOP_ZERO, 0);}
+    | PARSEOP_ONE                   {$$ = TrCreateValuedLeafNode (PARSEOP_ONE, 1);}
+    | PARSEOP_ONES                  {$$ = TrCreateValuedLeafNode (PARSEOP_ONES, ACPI_UINT64_MAX);}
+    | PARSEOP___DATE__              {$$ = TrCreateConstantLeafNode (PARSEOP___DATE__);}
+    | PARSEOP___FILE__              {$$ = TrCreateConstantLeafNode (PARSEOP___FILE__);}
+    | PARSEOP___LINE__              {$$ = TrCreateConstantLeafNode (PARSEOP___LINE__);}
+    | PARSEOP___PATH__              {$$ = TrCreateConstantLeafNode (PARSEOP___PATH__);}
+    ;
+
+Integer
+    : PARSEOP_INTEGER               {$$ = TrCreateValuedLeafNode (PARSEOP_INTEGER, AslCompilerlval.i);}
+    ;
+
+String
+    : PARSEOP_STRING_LITERAL        {$$ = TrCreateValuedLeafNode (PARSEOP_STRING_LITERAL, (ACPI_NATIVE_INT) AslCompilerlval.s);}
+    ;
+
+
+/*******************************************************************************
+ *
+ * ASL Opcode Terms
+ *
+ ******************************************************************************/
+
+CompilerDirective
+    : IncludeTerm                   {}
+    | IncludeEndTerm                {}
+    | ExternalTerm                  {}
+    ;
+
+NamedObject
+    : BankFieldTerm                 {}
+    | CreateBitFieldTerm            {}
+    | CreateByteFieldTerm           {}
+    | CreateDWordFieldTerm          {}
+    | CreateFieldTerm               {}
+    | CreateQWordFieldTerm          {}
+    | CreateWordFieldTerm           {}
+    | DataRegionTerm                {}
+    | DeviceTerm                    {}
+    | EventTerm                     {}
+    | FieldTerm                     {}
+    | FunctionTerm                  {}
+    | IndexFieldTerm                {}
+    | MethodTerm                    {}
+    | MutexTerm                     {}
+    | OpRegionTerm                  {}
+    | PowerResTerm                  {}
+    | ProcessorTerm                 {}
+    | ThermalZoneTerm               {}
+    ;
+
+NameSpaceModifier
+    : AliasTerm                     {}
+    | NameTerm                      {}
+    | ScopeTerm                     {}
+    ;
+
+/* For ObjectType: SuperName except for MethodInvocationTerm */
+
+ObjectTypeName
+    : NameString                    {}
+    | ArgTerm                       {}
+    | LocalTerm                     {}
+    | DebugTerm                     {}
+    | RefOfTerm                     {}
+    | DerefOfTerm                   {}
+    | IndexTerm                     {}
+/*    | MethodInvocationTerm          {} */  /* Caused reduce/reduce with Type6Opcode->MethodInvocationTerm */
+    ;
+
+RequiredTarget
+    : ',' SuperName                 {$$ = TrSetNodeFlags ($2, NODE_IS_TARGET);}
+    ;
+
+SimpleTarget
+    : NameString                    {}
+    | LocalTerm                     {}
+    | ArgTerm                       {}
+    ;
+
+/* Opcode types */
+
+Type1Opcode
+    : BreakTerm                     {}
+    | BreakPointTerm                {}
+    | ContinueTerm                  {}
+    | FatalTerm                     {}
+    | ForTerm                       {}
+    | ElseIfTerm                    {}
+    | LoadTerm                      {}
+    | NoOpTerm                      {}
+    | NotifyTerm                    {}
+    | ReleaseTerm                   {}
+    | ResetTerm                     {}
+    | ReturnTerm                    {}
+    | SignalTerm                    {}
+    | SleepTerm                     {}
+    | StallTerm                     {}
+    | SwitchTerm                    {}
+    | UnloadTerm                    {}
+    | WhileTerm                     {}
+    ;
+
+Type2Opcode
+    : AcquireTerm                   {}
+    | CondRefOfTerm                 {}
+    | CopyObjectTerm                {}
+    | DerefOfTerm                   {}
+    | ObjectTypeTerm                {}
+    | RefOfTerm                     {}
+    | SizeOfTerm                    {}
+    | StoreTerm                     {}
+    | EqualsTerm                    {}
+    | TimerTerm                     {}
+    | WaitTerm                      {}
+    | MethodInvocationTerm          {}
+    ;
+
+/*
+ * Type 3/4/5 opcodes
+ */
+Type2IntegerOpcode                  /* "Type3" opcodes */
+    : Expression                    {$$ = TrSetNodeFlags ($1, NODE_COMPILE_TIME_CONST);}
+    | AddTerm                       {}
+    | AndTerm                       {}
+    | DecTerm                       {}
+    | DivideTerm                    {}
+    | FindSetLeftBitTerm            {}
+    | FindSetRightBitTerm           {}
+    | FromBCDTerm                   {}
+    | IncTerm                       {}
+    | IndexTerm                     {}
+    | LAndTerm                      {}
+    | LEqualTerm                    {}
+    | LGreaterTerm                  {}
+    | LGreaterEqualTerm             {}
+    | LLessTerm                     {}
+    | LLessEqualTerm                {}
+    | LNotTerm                      {}
+    | LNotEqualTerm                 {}
+    | LoadTableTerm                 {}
+    | LOrTerm                       {}
+    | MatchTerm                     {}
+    | ModTerm                       {}
+    | MultiplyTerm                  {}
+    | NAndTerm                      {}
+    | NOrTerm                       {}
+    | NotTerm                       {}
+    | OrTerm                        {}
+    | ShiftLeftTerm                 {}
+    | ShiftRightTerm                {}
+    | SubtractTerm                  {}
+    | ToBCDTerm                     {}
+    | ToIntegerTerm                 {}
+    | XOrTerm                       {}
+    ;
+
+Type2StringOpcode                   /* "Type4" Opcodes */
+    : ToDecimalStringTerm           {}
+    | ToHexStringTerm               {}
+    | ToStringTerm                  {}
+    ;
+
+Type2BufferOpcode                   /* "Type5" Opcodes */
+    : ToBufferTerm                  {}
+    | ConcatResTerm                 {}
+    ;
+
+Type2BufferOrStringOpcode
+    : ConcatTerm                    {$$ = TrSetNodeFlags ($1, NODE_COMPILE_TIME_CONST);}
+    | PrintfTerm                    {}
+    | FprintfTerm                   {}
+    | MidTerm                       {}
+    ;
+
+/*
+ * A type 3 opcode evaluates to an Integer and cannot have a destination operand
+ */
+Type3Opcode
+    : EISAIDTerm                    {}
+    ;
+
+/* Obsolete
+Type4Opcode
+    : ConcatTerm                    {}
+    | ToDecimalStringTerm           {}
+    | ToHexStringTerm               {}
+    | MidTerm                       {}
+    | ToStringTerm                  {}
+    ;
+*/
+
+Type5Opcode
+    : ResourceTemplateTerm          {}
+    | UnicodeTerm                   {}
+    | ToPLDTerm                     {}
+    | ToUUIDTerm                    {}
+    ;
+
+Type6Opcode
+    : RefOfTerm                     {}
+    | DerefOfTerm                   {}
+    | IndexTerm                     {}
+    | IndexExpTerm                  {}
+    | MethodInvocationTerm          {}
+    ;
+
+
+/*******************************************************************************
+ *
+ * ASL Primary Terms
+ *
+ ******************************************************************************/
+
+AccessAsTerm
+    : PARSEOP_ACCESSAS '('
+        AccessTypeKeyword
+        OptionalAccessAttribTerm
+        ')'                         {$$ = TrCreateNode (PARSEOP_ACCESSAS,2,$3,$4);}
+    | PARSEOP_ACCESSAS '('
+        error ')'                   {$$ = AslDoError(); yyclearin;}
+    ;
+
+AcquireTerm
+    : PARSEOP_ACQUIRE '('           {$<n>$ = TrCreateLeafNode (PARSEOP_ACQUIRE);}
+        SuperName
+        ',' WordConstExpr
+        ')'                         {$$ = TrLinkChildren ($<n>3,2,$4,$6);}
+    | PARSEOP_ACQUIRE '('
+        error ')'                   {$$ = AslDoError(); yyclearin;}
+    ;
+
+AddTerm
+    : PARSEOP_ADD '('               {$<n>$ = TrCreateLeafNode (PARSEOP_ADD);}
+        TermArg
+        TermArgItem
+        Target
+        ')'                         {$$ = TrLinkChildren ($<n>3,3,$4,$5,$6);}
+    | PARSEOP_ADD '('
+        error ')'                   {$$ = AslDoError(); yyclearin;}
+    ;
+
+AliasTerm
+    : PARSEOP_ALIAS '('             {$<n>$ = TrCreateLeafNode (PARSEOP_ALIAS);}
+        NameString
+        NameStringItem
+        ')'                         {$$ = TrLinkChildren ($<n>3,2,$4,
+                                        TrSetNodeFlags ($5, NODE_IS_NAME_DECLARATION));}
+    | PARSEOP_ALIAS '('
+        error ')'                   {$$ = AslDoError(); yyclearin;}
+    ;
+
+AndTerm
+    : PARSEOP_AND '('               {$<n>$ = TrCreateLeafNode (PARSEOP_AND);}
+        TermArg
+        TermArgItem
+        Target
+        ')'                         {$$ = TrLinkChildren ($<n>3,3,$4,$5,$6);}
+    | PARSEOP_AND '('
+        error ')'                   {$$ = AslDoError(); yyclearin;}
+    ;
+
+ArgTerm
+    : PARSEOP_ARG0                  {$$ = TrCreateLeafNode (PARSEOP_ARG0);}
+    | PARSEOP_ARG1                  {$$ = TrCreateLeafNode (PARSEOP_ARG1);}
+    | PARSEOP_ARG2                  {$$ = TrCreateLeafNode (PARSEOP_ARG2);}
+    | PARSEOP_ARG3                  {$$ = TrCreateLeafNode (PARSEOP_ARG3);}
+    | PARSEOP_ARG4                  {$$ = TrCreateLeafNode (PARSEOP_ARG4);}
+    | PARSEOP_ARG5                  {$$ = TrCreateLeafNode (PARSEOP_ARG5);}
+    | PARSEOP_ARG6                  {$$ = TrCreateLeafNode (PARSEOP_ARG6);}
+    ;
+
+BankFieldTerm
+    : PARSEOP_BANKFIELD '('         {$<n>$ = TrCreateLeafNode (PARSEOP_BANKFIELD);}
+        NameString
+        NameStringItem
+        TermArgItem
+        ',' AccessTypeKeyword
+        ',' LockRuleKeyword
+        ',' UpdateRuleKeyword
+        ')' '{'
+            FieldUnitList '}'       {$$ = TrLinkChildren ($<n>3,7,$4,$5,$6,$8,$10,$12,$15);}
+    | PARSEOP_BANKFIELD '('
+        error ')' '{' error '}'     {$$ = AslDoError(); yyclearin;}
+    ;
+
+BreakTerm
+    : PARSEOP_BREAK                 {$$ = TrCreateNode (PARSEOP_BREAK, 0);}
+    ;
+
+BreakPointTerm
+    : PARSEOP_BREAKPOINT            {$$ = TrCreateNode (PARSEOP_BREAKPOINT, 0);}
+    ;
+
+BufferTerm
+    : PARSEOP_BUFFER '('            {$<n>$ = TrCreateLeafNode (PARSEOP_BUFFER);}
+        OptionalBufferLength
+        ')' '{'
+            BufferTermData '}'      {$$ = TrLinkChildren ($<n>3,2,$4,$7);}
+    | PARSEOP_BUFFER '('
+        error ')'                   {$$ = AslDoError(); yyclearin;}
+    ;
+
+BufferTermData
+    : ByteList                      {}
+    | StringData                    {}
+    ;
+
+CaseTerm
+    : PARSEOP_CASE '('              {$<n>$ = TrCreateLeafNode (PARSEOP_CASE);}
+        DataObject
+        ')' '{'
+            TermList '}'            {$$ = TrLinkChildren ($<n>3,2,$4,$7);}
+    | PARSEOP_CASE '('
+        error ')'                   {$$ = AslDoError(); yyclearin;}
+    ;
+
+ConcatTerm
+    : PARSEOP_CONCATENATE '('       {$<n>$ = TrCreateLeafNode (PARSEOP_CONCATENATE);}
+        TermArg
+        TermArgItem
+        Target
+        ')'                         {$$ = TrLinkChildren ($<n>3,3,$4,$5,$6);}
+    | PARSEOP_CONCATENATE '('
+        error ')'                   {$$ = AslDoError(); yyclearin;}
+    ;
+
+ConcatResTerm
+    : PARSEOP_CONCATENATERESTEMPLATE '('    {$<n>$ = TrCreateLeafNode (PARSEOP_CONCATENATERESTEMPLATE);}
+        TermArg
+        TermArgItem
+        Target
+        ')'                         {$$ = TrLinkChildren ($<n>3,3,$4,$5,$6);}
+    | PARSEOP_CONCATENATERESTEMPLATE '('
+        error ')'                   {$$ = AslDoError(); yyclearin;}
+    ;
+
+ConnectionTerm
+    : PARSEOP_CONNECTION '('
+        NameString
+        ')'                         {$$ = TrCreateNode (PARSEOP_CONNECTION,1,$3);}
+    | PARSEOP_CONNECTION '('        {$<n>$ = TrCreateLeafNode (PARSEOP_CONNECTION);}
+        ResourceMacroTerm
+        ')'                         {$$ = TrLinkChildren ($<n>3, 1,
+                                            TrLinkChildren (TrCreateLeafNode (PARSEOP_RESOURCETEMPLATE), 3,
+                                                TrCreateLeafNode (PARSEOP_DEFAULT_ARG),
+                                                TrCreateLeafNode (PARSEOP_DEFAULT_ARG),
+                                                $4));}
+    | PARSEOP_CONNECTION '('
+        error ')'                   {$$ = AslDoError(); yyclearin;}
+    ;
+
+CondRefOfTerm
+    : PARSEOP_CONDREFOF '('         {$<n>$ = TrCreateLeafNode (PARSEOP_CONDREFOF);}
+        SuperName
+        Target
+        ')'                         {$$ = TrLinkChildren ($<n>3,2,$4,$5);}
+    | PARSEOP_CONDREFOF '('
+        error ')'                   {$$ = AslDoError(); yyclearin;}
+    ;
+
+ContinueTerm
+    : PARSEOP_CONTINUE              {$$ = TrCreateNode (PARSEOP_CONTINUE, 0);}
+    ;
+
+CopyObjectTerm
+    : PARSEOP_COPYOBJECT '('        {$<n>$ = TrCreateLeafNode (PARSEOP_COPYOBJECT);}
+        TermArg
+        ',' SimpleTarget
+        ')'                         {$$ = TrLinkChildren ($<n>3,2,$4,TrSetNodeFlags ($6, NODE_IS_TARGET));}
+    | PARSEOP_COPYOBJECT '('
+        error ')'                   {$$ = AslDoError(); yyclearin;}
+    ;
+
+CreateBitFieldTerm
+    : PARSEOP_CREATEBITFIELD '('    {$<n>$ = TrCreateLeafNode (PARSEOP_CREATEBITFIELD);}
+        TermArg
+        TermArgItem
+        NameStringItem
+        ')'                         {$$ = TrLinkChildren ($<n>3,3,$4,$5,TrSetNodeFlags ($6, NODE_IS_NAME_DECLARATION));}
+    | PARSEOP_CREATEBITFIELD '('
+        error ')'                   {$$ = AslDoError(); yyclearin;}
+    ;
+
+CreateByteFieldTerm
+    : PARSEOP_CREATEBYTEFIELD '('   {$<n>$ = TrCreateLeafNode (PARSEOP_CREATEBYTEFIELD);}
+        TermArg
+        TermArgItem
+        NameStringItem
+        ')'                         {$$ = TrLinkChildren ($<n>3,3,$4,$5,TrSetNodeFlags ($6, NODE_IS_NAME_DECLARATION));}
+    | PARSEOP_CREATEBYTEFIELD '('
+        error ')'                   {$$ = AslDoError(); yyclearin;}
+    ;
+
+CreateDWordFieldTerm
+    : PARSEOP_CREATEDWORDFIELD '('  {$<n>$ = TrCreateLeafNode (PARSEOP_CREATEDWORDFIELD);}
+        TermArg
+        TermArgItem
+        NameStringItem
+        ')'                         {$$ = TrLinkChildren ($<n>3,3,$4,$5,TrSetNodeFlags ($6, NODE_IS_NAME_DECLARATION));}
+    | PARSEOP_CREATEDWORDFIELD '('
+        error ')'                   {$$ = AslDoError(); yyclearin;}
+    ;
+
+CreateFieldTerm
+    : PARSEOP_CREATEFIELD '('       {$<n>$ = TrCreateLeafNode (PARSEOP_CREATEFIELD);}
+        TermArg
+        TermArgItem
+        TermArgItem
+        NameStringItem
+        ')'                         {$$ = TrLinkChildren ($<n>3,4,$4,$5,$6,TrSetNodeFlags ($7, NODE_IS_NAME_DECLARATION));}
+    | PARSEOP_CREATEFIELD '('
+        error ')'                   {$$ = AslDoError(); yyclearin;}
+    ;
+
+CreateQWordFieldTerm
+    : PARSEOP_CREATEQWORDFIELD '('  {$<n>$ = TrCreateLeafNode (PARSEOP_CREATEQWORDFIELD);}
+        TermArg
+        TermArgItem
+        NameStringItem
+        ')'                         {$$ = TrLinkChildren ($<n>3,3,$4,$5,TrSetNodeFlags ($6, NODE_IS_NAME_DECLARATION));}
+    | PARSEOP_CREATEQWORDFIELD '('
+        error ')'                   {$$ = AslDoError(); yyclearin;}
+    ;
+
+CreateWordFieldTerm
+    : PARSEOP_CREATEWORDFIELD '('   {$<n>$ = TrCreateLeafNode (PARSEOP_CREATEWORDFIELD);}
+        TermArg
+        TermArgItem
+        NameStringItem
+        ')'                         {$$ = TrLinkChildren ($<n>3,3,$4,$5,TrSetNodeFlags ($6, NODE_IS_NAME_DECLARATION));}
+    | PARSEOP_CREATEWORDFIELD '('
+        error ')'                   {$$ = AslDoError(); yyclearin;}
+    ;
+
+DataRegionTerm
+    : PARSEOP_DATATABLEREGION '('   {$<n>$ = TrCreateLeafNode (PARSEOP_DATATABLEREGION);}
+        NameString
+        TermArgItem
+        TermArgItem
+        TermArgItem
+        ')'                         {$$ = TrLinkChildren ($<n>3,4,TrSetNodeFlags ($4, NODE_IS_NAME_DECLARATION),$5,$6,$7);}
+    | PARSEOP_DATATABLEREGION '('
+        error ')'                   {$$ = AslDoError(); yyclearin;}
+    ;
+
+DebugTerm
+    : PARSEOP_DEBUG                 {$$ = TrCreateLeafNode (PARSEOP_DEBUG);}
+    ;
+
+DecTerm
+    : PARSEOP_DECREMENT '('         {$<n>$ = TrCreateLeafNode (PARSEOP_DECREMENT);}
+        SuperName
+        ')'                         {$$ = TrLinkChildren ($<n>3,1,$4);}
+    | PARSEOP_DECREMENT '('
+        error ')'                   {$$ = AslDoError(); yyclearin;}
+    ;
+
+DefaultTerm
+    : PARSEOP_DEFAULT '{'           {$<n>$ = TrCreateLeafNode (PARSEOP_DEFAULT);}
+        TermList '}'                {$$ = TrLinkChildren ($<n>3,1,$4);}
+    | PARSEOP_DEFAULT '{'
+        error '}'                   {$$ = AslDoError(); yyclearin;}
+    ;
+
+DerefOfTerm
+    : PARSEOP_DEREFOF '('           {$<n>$ = TrCreateLeafNode (PARSEOP_DEREFOF);}
+        TermArg
+        ')'                         {$$ = TrLinkChildren ($<n>3,1,$4);}
+    | PARSEOP_DEREFOF '('
+        error ')'                   {$$ = AslDoError(); yyclearin;}
+    ;
+
+DeviceTerm
+    : PARSEOP_DEVICE '('            {$<n>$ = TrCreateLeafNode (PARSEOP_DEVICE);}
+        NameString
+        ')' '{'
+            TermList '}'            {$$ = TrLinkChildren ($<n>3,2,TrSetNodeFlags ($4, NODE_IS_NAME_DECLARATION),$7);}
+    | PARSEOP_DEVICE '('
+        error ')'                   {$$ = AslDoError(); yyclearin;}
+    ;
+
+DivideTerm
+    : PARSEOP_DIVIDE '('            {$<n>$ = TrCreateLeafNode (PARSEOP_DIVIDE);}
+        TermArg
+        TermArgItem
+        Target
+        Target
+        ')'                         {$$ = TrLinkChildren ($<n>3,4,$4,$5,$6,$7);}
+    | PARSEOP_DIVIDE '('
+        error ')'                   {$$ = AslDoError(); yyclearin;}
+    ;
+
+EISAIDTerm
+    : PARSEOP_EISAID '('
+        StringData ')'              {$$ = TrUpdateNode (PARSEOP_EISAID, $3);}
+    | PARSEOP_EISAID '('
+        error ')'                   {$$ = AslDoError(); yyclearin;}
+    ;
+
+ElseIfTerm
+    : IfTerm ElseTerm               {$$ = TrLinkPeerNode ($1,$2);}
+    ;
+
+ElseTerm
+    :                               {$$ = NULL;}
+    | PARSEOP_ELSE '{'              {$<n>$ = TrCreateLeafNode (PARSEOP_ELSE);}
+        TermList '}'                {$$ = TrLinkChildren ($<n>3,1,$4);}
+
+    | PARSEOP_ELSE '{'
+        error '}'                   {$$ = AslDoError(); yyclearin;}
+
+    | PARSEOP_ELSE
+        error                       {$$ = AslDoError(); yyclearin;}
+
+    | PARSEOP_ELSEIF '('            {$<n>$ = TrCreateLeafNode (PARSEOP_ELSE);}
+        TermArg                     {$<n>$ = TrCreateLeafNode (PARSEOP_IF);}
+        ')' '{'
+            TermList '}'            {TrLinkChildren ($<n>5,2,$4,$8);}
+        ElseTerm                    {TrLinkPeerNode ($<n>5,$11);}
+                                    {$$ = TrLinkChildren ($<n>3,1,$<n>5);}
+
+    | PARSEOP_ELSEIF '('
+        error ')'                   {$$ = AslDoError(); yyclearin;}
+
+    | PARSEOP_ELSEIF
+        error                       {$$ = AslDoError(); yyclearin;}
+    ;
+
+EventTerm
+    : PARSEOP_EVENT '('             {$<n>$ = TrCreateLeafNode (PARSEOP_EVENT);}
+        NameString
+        ')'                         {$$ = TrLinkChildren ($<n>3,1,TrSetNodeFlags ($4, NODE_IS_NAME_DECLARATION));}
+    | PARSEOP_EVENT '('
+        error ')'                   {$$ = AslDoError(); yyclearin;}
+    ;
+
+ExternalTerm
+    : PARSEOP_EXTERNAL '('
+        NameString
+        OptionalObjectTypeKeyword
+        OptionalParameterTypePackage
+        OptionalParameterTypesPackage
+        ')'                         {$$ = TrCreateNode (PARSEOP_EXTERNAL,4,$3,$4,$5,$6);}
+    | PARSEOP_EXTERNAL '('
+        error ')'                   {$$ = AslDoError(); yyclearin;}
+    ;
+
+FatalTerm
+    : PARSEOP_FATAL '('             {$<n>$ = TrCreateLeafNode (PARSEOP_FATAL);}
+        ByteConstExpr
+        ',' DWordConstExpr
+        TermArgItem
+        ')'                         {$$ = TrLinkChildren ($<n>3,3,$4,$6,$7);}
+    | PARSEOP_FATAL '('
+        error ')'                   {$$ = AslDoError(); yyclearin;}
+    ;
+
+FieldTerm
+    : PARSEOP_FIELD '('             {$<n>$ = TrCreateLeafNode (PARSEOP_FIELD);}
+        NameString
+        ',' AccessTypeKeyword
+        ',' LockRuleKeyword
+        ',' UpdateRuleKeyword
+        ')' '{'
+            FieldUnitList '}'       {$$ = TrLinkChildren ($<n>3,5,$4,$6,$8,$10,$13);}
+    | PARSEOP_FIELD '('
+        error ')' '{' error '}'     {$$ = AslDoError(); yyclearin;}
+    ;
+
+FindSetLeftBitTerm
+    : PARSEOP_FINDSETLEFTBIT '('    {$<n>$ = TrCreateLeafNode (PARSEOP_FINDSETLEFTBIT);}
+        TermArg
+        Target
+        ')'                         {$$ = TrLinkChildren ($<n>3,2,$4,$5);}
+    | PARSEOP_FINDSETLEFTBIT '('
+        error ')'                   {$$ = AslDoError(); yyclearin;}
+    ;
+
+FindSetRightBitTerm
+    : PARSEOP_FINDSETRIGHTBIT '('   {$<n>$ = TrCreateLeafNode (PARSEOP_FINDSETRIGHTBIT);}
+        TermArg
+        Target
+        ')'                         {$$ = TrLinkChildren ($<n>3,2,$4,$5);}
+    | PARSEOP_FINDSETRIGHTBIT '('
+        error ')'                   {$$ = AslDoError(); yyclearin;}
+    ;
+
+    /* Convert a For() loop to a While() loop */
+ForTerm
+    : PARSEOP_FOR '('               {$<n>$ = TrCreateLeafNode (PARSEOP_WHILE);}
+        OptionalTermArg ','         {}
+        OptionalPredicate ','
+        OptionalTermArg             {$<n>$ = TrLinkPeerNode ($4,$<n>3);
+                                        TrSetParent ($9,$<n>3);}                /* New parent is WHILE */
+        ')' '{' TermList '}'        {$<n>$ = TrLinkChildren ($<n>3,2,$7,$13);}
+                                    {$<n>$ = TrLinkPeerNode ($13,$9);
+                                        $$ = $<n>10;}
+    ;
+
+OptionalPredicate
+    :                               {$$ = TrCreateValuedLeafNode (PARSEOP_INTEGER, 1);}
+    | TermArg                       {$$ = $1;}
+    ;
+
+FprintfTerm
+    : PARSEOP_FPRINTF '('            {$<n>$ = TrCreateLeafNode (PARSEOP_FPRINTF);}
+        TermArg ','
+        StringData
+        PrintfArgList
+        ')'                         {$$ = TrLinkChildren ($<n>3,3,$4,$6,$7);}
+    | PARSEOP_FPRINTF '('
+        error ')'                   {$$ = AslDoError(); yyclearin;}
+    ;
+
+FromBCDTerm
+    : PARSEOP_FROMBCD '('           {$<n>$ = TrCreateLeafNode (PARSEOP_FROMBCD);}
+        TermArg
+        Target
+        ')'                         {$$ = TrLinkChildren ($<n>3,2,$4,$5);}
+    | PARSEOP_FROMBCD '('
+        error ')'                   {$$ = AslDoError(); yyclearin;}
+    ;
+
+FunctionTerm
+    : PARSEOP_FUNCTION '('          {$<n>$ = TrCreateLeafNode (PARSEOP_METHOD);}
+        NameString
+        OptionalParameterTypePackage
+        OptionalParameterTypesPackage
+        ')' '{'
+            TermList '}'            {$$ = TrLinkChildren ($<n>3,7,TrSetNodeFlags ($4, NODE_IS_NAME_DECLARATION),
+                                        TrCreateValuedLeafNode (PARSEOP_BYTECONST, 0),
+                                        TrCreateLeafNode (PARSEOP_SERIALIZERULE_NOTSERIAL),
+                                        TrCreateValuedLeafNode (PARSEOP_BYTECONST, 0),$5,$6,$9);}
+    | PARSEOP_FUNCTION '('
+        error ')'                   {$$ = AslDoError(); yyclearin;}
+    ;
+
+IfTerm
+    : PARSEOP_IF '('                {$<n>$ = TrCreateLeafNode (PARSEOP_IF);}
+        TermArg
+        ')' '{'
+            TermList '}'            {$$ = TrLinkChildren ($<n>3,2,$4,$7);}
+
+    | PARSEOP_IF '('
+        error ')'                   {$$ = AslDoError(); yyclearin;}
+    ;
+
+IncludeTerm
+    : PARSEOP_INCLUDE '('
+        String  ')'                 {$$ = TrUpdateNode (PARSEOP_INCLUDE, $3);
+                                        FlOpenIncludeFile ($3);}
+    ;
+
+IncludeEndTerm
+    : PARSEOP_INCLUDE_END           {$<n>$ = TrCreateLeafNode (PARSEOP_INCLUDE_END); TrSetCurrentFilename ($$);}
+    ;
+
+IncTerm
+    : PARSEOP_INCREMENT '('         {$<n>$ = TrCreateLeafNode (PARSEOP_INCREMENT);}
+        SuperName
+        ')'                         {$$ = TrLinkChildren ($<n>3,1,$4);}
+    | PARSEOP_INCREMENT '('
+        error ')'                   {$$ = AslDoError(); yyclearin;}
+    ;
+
+IndexFieldTerm
+    : PARSEOP_INDEXFIELD '('        {$<n>$ = TrCreateLeafNode (PARSEOP_INDEXFIELD);}
+        NameString
+        NameStringItem
+        ',' AccessTypeKeyword
+        ',' LockRuleKeyword
+        ',' UpdateRuleKeyword
+        ')' '{'
+            FieldUnitList '}'       {$$ = TrLinkChildren ($<n>3,6,$4,$5,$7,$9,$11,$14);}
+    | PARSEOP_INDEXFIELD '('
+        error ')' '{' error '}'     {$$ = AslDoError(); yyclearin;}
+    ;
+
+IndexTerm
+    : PARSEOP_INDEX '('             {$<n>$ = TrCreateLeafNode (PARSEOP_INDEX);}
+        TermArg
+        TermArgItem
+        Target
+        ')'                         {$$ = TrLinkChildren ($<n>3,3,$4,$5,$6);}
+    | PARSEOP_INDEX '('
+        error ')'                   {$$ = AslDoError(); yyclearin;}
+    ;
+
+LAndTerm
+    : PARSEOP_LAND '('              {$<n>$ = TrCreateLeafNode (PARSEOP_LAND);}
+        TermArg
+        TermArgItem
+        ')'                         {$$ = TrLinkChildren ($<n>3,2,$4,$5);}
+    | PARSEOP_LAND '('
+        error ')'                   {$$ = AslDoError(); yyclearin;}
+    ;
+
+LEqualTerm
+    : PARSEOP_LEQUAL '('            {$<n>$ = TrCreateLeafNode (PARSEOP_LEQUAL);}
+        TermArg
+        TermArgItem
+        ')'                         {$$ = TrLinkChildren ($<n>3,2,$4,$5);}
+    | PARSEOP_LEQUAL '('
+        error ')'                   {$$ = AslDoError(); yyclearin;}
+    ;
+
+LGreaterEqualTerm
+    : PARSEOP_LGREATEREQUAL '('     {$<n>$ = TrCreateLeafNode (PARSEOP_LLESS);}
+        TermArg
+        TermArgItem
+        ')'                         {$$ = TrCreateNode (PARSEOP_LNOT, 1, TrLinkChildren ($<n>3,2,$4,$5));}
+    | PARSEOP_LGREATEREQUAL '('
+        error ')'                   {$$ = AslDoError(); yyclearin;}
+    ;
+
+LGreaterTerm
+    : PARSEOP_LGREATER '('          {$<n>$ = TrCreateLeafNode (PARSEOP_LGREATER);}
+        TermArg
+        TermArgItem
+        ')'                         {$$ = TrLinkChildren ($<n>3,2,$4,$5);}
+    | PARSEOP_LGREATER '('
+        error ')'                   {$$ = AslDoError(); yyclearin;}
+    ;
+
+LLessEqualTerm
+    : PARSEOP_LLESSEQUAL '('        {$<n>$ = TrCreateLeafNode (PARSEOP_LGREATER);}
+        TermArg
+        TermArgItem
+        ')'                         {$$ = TrCreateNode (PARSEOP_LNOT, 1, TrLinkChildren ($<n>3,2,$4,$5));}
+    | PARSEOP_LLESSEQUAL '('
+        error ')'                   {$$ = AslDoError(); yyclearin;}
+    ;
+
+LLessTerm
+    : PARSEOP_LLESS '('             {$<n>$ = TrCreateLeafNode (PARSEOP_LLESS);}
+        TermArg
+        TermArgItem
+        ')'                         {$$ = TrLinkChildren ($<n>3,2,$4,$5);}
+    | PARSEOP_LLESS '('
+        error ')'                   {$$ = AslDoError(); yyclearin;}
+    ;
+
+LNotEqualTerm
+    : PARSEOP_LNOTEQUAL '('         {$<n>$ = TrCreateLeafNode (PARSEOP_LEQUAL);}
+        TermArg
+        TermArgItem
+        ')'                         {$$ = TrCreateNode (PARSEOP_LNOT, 1, TrLinkChildren ($<n>3,2,$4,$5));}
+    | PARSEOP_LNOTEQUAL '('
+        error ')'                   {$$ = AslDoError(); yyclearin;}
+    ;
+
+LNotTerm
+    : PARSEOP_LNOT '('              {$<n>$ = TrCreateLeafNode (PARSEOP_LNOT);}
+        TermArg
+        ')'                         {$$ = TrLinkChildren ($<n>3,1,$4);}
+    | PARSEOP_LNOT '('
+        error ')'                   {$$ = AslDoError(); yyclearin;}
+    ;
+
+LoadTableTerm
+    : PARSEOP_LOADTABLE '('         {$<n>$ = TrCreateLeafNode (PARSEOP_LOADTABLE);}
+        TermArg
+        TermArgItem
+        TermArgItem
+        OptionalListString
+        OptionalListString
+        OptionalReference
+        ')'                         {$$ = TrLinkChildren ($<n>3,6,$4,$5,$6,$7,$8,$9);}
+    | PARSEOP_LOADTABLE '('
+        error ')'                   {$$ = AslDoError(); yyclearin;}
+    ;
+
+LoadTerm
+    : PARSEOP_LOAD '('              {$<n>$ = TrCreateLeafNode (PARSEOP_LOAD);}
+        NameString
+        RequiredTarget
+        ')'                         {$$ = TrLinkChildren ($<n>3,2,$4,$5);}
+    | PARSEOP_LOAD '('
+        error ')'                   {$$ = AslDoError(); yyclearin;}
+    ;
+
+LocalTerm
+    : PARSEOP_LOCAL0                {$$ = TrCreateLeafNode (PARSEOP_LOCAL0);}
+    | PARSEOP_LOCAL1                {$$ = TrCreateLeafNode (PARSEOP_LOCAL1);}
+    | PARSEOP_LOCAL2                {$$ = TrCreateLeafNode (PARSEOP_LOCAL2);}
+    | PARSEOP_LOCAL3                {$$ = TrCreateLeafNode (PARSEOP_LOCAL3);}
+    | PARSEOP_LOCAL4                {$$ = TrCreateLeafNode (PARSEOP_LOCAL4);}
+    | PARSEOP_LOCAL5                {$$ = TrCreateLeafNode (PARSEOP_LOCAL5);}
+    | PARSEOP_LOCAL6                {$$ = TrCreateLeafNode (PARSEOP_LOCAL6);}
+    | PARSEOP_LOCAL7                {$$ = TrCreateLeafNode (PARSEOP_LOCAL7);}
+    ;
+
+LOrTerm
+    : PARSEOP_LOR '('               {$<n>$ = TrCreateLeafNode (PARSEOP_LOR);}
+        TermArg
+        TermArgItem
+        ')'                         {$$ = TrLinkChildren ($<n>3,2,$4,$5);}
+    | PARSEOP_LOR '('
+        error ')'                   {$$ = AslDoError(); yyclearin;}
+    ;
+
+MatchTerm
+    : PARSEOP_MATCH '('             {$<n>$ = TrCreateLeafNode (PARSEOP_MATCH);}
+        TermArg
+        ',' MatchOpKeyword
+        TermArgItem
+        ',' MatchOpKeyword
+        TermArgItem
+        TermArgItem
+        ')'                         {$$ = TrLinkChildren ($<n>3,6,$4,$6,$7,$9,$10,$11);}
+    | PARSEOP_MATCH '('
+        error ')'                   {$$ = AslDoError(); yyclearin;}
+    ;
+
+MethodTerm
+    : PARSEOP_METHOD  '('           {$<n>$ = TrCreateLeafNode (PARSEOP_METHOD);}
+        NameString
+        OptionalByteConstExpr       {UtCheckIntegerRange ($5, 0, 7);}
+        OptionalSerializeRuleKeyword
+        OptionalByteConstExpr
+        OptionalParameterTypePackage
+        OptionalParameterTypesPackage
+        ')' '{'
+            TermList '}'            {$$ = TrLinkChildren ($<n>3,7,TrSetNodeFlags ($4, NODE_IS_NAME_DECLARATION),$5,$7,$8,$9,$10,$13);}
+    | PARSEOP_METHOD '('
+        error ')'                   {$$ = AslDoError(); yyclearin;}
+    ;
+
+MidTerm
+    : PARSEOP_MID '('               {$<n>$ = TrCreateLeafNode (PARSEOP_MID);}
+        TermArg
+        TermArgItem
+        TermArgItem
+        Target
+        ')'                         {$$ = TrLinkChildren ($<n>3,4,$4,$5,$6,$7);}
+    | PARSEOP_MID '('
+        error ')'                   {$$ = AslDoError(); yyclearin;}
+    ;
+
+ModTerm
+    : PARSEOP_MOD '('               {$<n>$ = TrCreateLeafNode (PARSEOP_MOD);}
+        TermArg
+        TermArgItem
+        Target
+        ')'                         {$$ = TrLinkChildren ($<n>3,3,$4,$5,$6);}
+    | PARSEOP_MOD '('
+        error ')'                   {$$ = AslDoError(); yyclearin;}
+    ;
+
+MultiplyTerm
+    : PARSEOP_MULTIPLY '('          {$<n>$ = TrCreateLeafNode (PARSEOP_MULTIPLY);}
+        TermArg
+        TermArgItem
+        Target
+        ')'                         {$$ = TrLinkChildren ($<n>3,3,$4,$5,$6);}
+    | PARSEOP_MULTIPLY '('
+        error ')'                   {$$ = AslDoError(); yyclearin;}
+    ;
+
+MutexTerm
+    : PARSEOP_MUTEX '('             {$<n>$ = TrCreateLeafNode (PARSEOP_MUTEX);}
+        NameString
+        ',' ByteConstExpr
+        ')'                         {$$ = TrLinkChildren ($<n>3,2,TrSetNodeFlags ($4, NODE_IS_NAME_DECLARATION),$6);}
+    | PARSEOP_MUTEX '('
+        error ')'                   {$$ = AslDoError(); yyclearin;}
+    ;
+
+NameTerm
+    : PARSEOP_NAME '('              {$<n>$ = TrCreateLeafNode (PARSEOP_NAME);}
+        NameString
+        ',' DataObject
+        ')'                         {$$ = TrLinkChildren ($<n>3,2,TrSetNodeFlags ($4, NODE_IS_NAME_DECLARATION),$6);}
+    | PARSEOP_NAME '('
+        error ')'                   {$$ = AslDoError(); yyclearin;}
+    ;
+
+NAndTerm
+    : PARSEOP_NAND '('              {$<n>$ = TrCreateLeafNode (PARSEOP_NAND);}
+        TermArg
+        TermArgItem
+        Target
+        ')'                         {$$ = TrLinkChildren ($<n>3,3,$4,$5,$6);}
+    | PARSEOP_NAND '('
+        error ')'                   {$$ = AslDoError(); yyclearin;}
+    ;
+
+NoOpTerm
+    : PARSEOP_NOOP                  {$$ = TrCreateNode (PARSEOP_NOOP, 0);}
+    ;
+
+NOrTerm
+    : PARSEOP_NOR '('               {$<n>$ = TrCreateLeafNode (PARSEOP_NOR);}
+        TermArg
+        TermArgItem
+        Target
+        ')'                         {$$ = TrLinkChildren ($<n>3,3,$4,$5,$6);}
+    | PARSEOP_NOR '('
+        error ')'                   {$$ = AslDoError(); yyclearin;}
+    ;
+
+NotifyTerm
+    : PARSEOP_NOTIFY '('            {$<n>$ = TrCreateLeafNode (PARSEOP_NOTIFY);}
+        SuperName
+        TermArgItem
+        ')'                         {$$ = TrLinkChildren ($<n>3,2,$4,$5);}
+    | PARSEOP_NOTIFY '('
+        error ')'                   {$$ = AslDoError(); yyclearin;}
+    ;
+
+NotTerm
+    : PARSEOP_NOT '('               {$<n>$ = TrCreateLeafNode (PARSEOP_NOT);}
+        TermArg
+        Target
+        ')'                         {$$ = TrLinkChildren ($<n>3,2,$4,$5);}
+    | PARSEOP_NOT '('
+        error ')'                   {$$ = AslDoError(); yyclearin;}
+    ;
+
+ObjectTypeTerm
+    : PARSEOP_OBJECTTYPE '('        {$<n>$ = TrCreateLeafNode (PARSEOP_OBJECTTYPE);}
+        ObjectTypeName
+        ')'                         {$$ = TrLinkChildren ($<n>3,1,$4);}
+    | PARSEOP_OBJECTTYPE '('
+        error ')'                   {$$ = AslDoError(); yyclearin;}
+    ;
+
+OffsetTerm
+    : PARSEOP_OFFSET '('
+        AmlPackageLengthTerm
+        ')'                         {$$ = TrCreateNode (PARSEOP_OFFSET,1,$3);}
+    | PARSEOP_OFFSET '('
+        error ')'                   {$$ = AslDoError(); yyclearin;}
+    ;
+
+OpRegionTerm
+    : PARSEOP_OPERATIONREGION '('   {$<n>$ = TrCreateLeafNode (PARSEOP_OPERATIONREGION);}
+        NameString
+        ',' OpRegionSpaceIdTerm
+        TermArgItem
+        TermArgItem
+        ')'                         {$$ = TrLinkChildren ($<n>3,4,TrSetNodeFlags ($4, NODE_IS_NAME_DECLARATION),$6,$7,$8);}
+    | PARSEOP_OPERATIONREGION '('
+        error ')'                   {$$ = AslDoError(); yyclearin;}
+    ;
+
+OpRegionSpaceIdTerm
+    : RegionSpaceKeyword            {}
+    | ByteConst                     {$$ = UtCheckIntegerRange ($1, 0x80, 0xFF);}
+    ;
+
+OrTerm
+    : PARSEOP_OR '('                {$<n>$ = TrCreateLeafNode (PARSEOP_OR);}
+        TermArg
+        TermArgItem
+        Target
+        ')'                         {$$ = TrLinkChildren ($<n>3,3,$4,$5,$6);}
+    | PARSEOP_OR '('
+        error ')'                   {$$ = AslDoError(); yyclearin;}
+    ;
+
+PackageTerm
+    : PARSEOP_PACKAGE '('           {$<n>$ = TrCreateLeafNode (PARSEOP_VAR_PACKAGE);}
+        VarPackageLengthTerm
+        ')' '{'
+            PackageList '}'         {$$ = TrLinkChildren ($<n>3,2,$4,$7);}
+    | PARSEOP_PACKAGE '('
+        error ')'                   {$$ = AslDoError(); yyclearin;}
+    ;
+
+PowerResTerm
+    : PARSEOP_POWERRESOURCE '('     {$<n>$ = TrCreateLeafNode (PARSEOP_POWERRESOURCE);}
+        NameString
+        ',' ByteConstExpr
+        ',' WordConstExpr
+        ')' '{'
+            TermList '}'            {$$ = TrLinkChildren ($<n>3,4,TrSetNodeFlags ($4, NODE_IS_NAME_DECLARATION),$6,$8,$11);}
+    | PARSEOP_POWERRESOURCE '('
+        error ')'                   {$$ = AslDoError(); yyclearin;}
+    ;
+
+PrintfTerm
+    : PARSEOP_PRINTF '('            {$<n>$ = TrCreateLeafNode (PARSEOP_PRINTF);}
+        StringData
+        PrintfArgList
+        ')'                         {$$ = TrLinkChildren ($<n>3,2,$4,$5);}
+    | PARSEOP_PRINTF '('
+        error ')'                   {$$ = AslDoError(); yyclearin;}
+    ;
+
+PrintfArgList
+    :                               {$$ = NULL;}
+    | TermArg                       {$$ = $1;}
+    | PrintfArgList ','
+       TermArg                      {$$ = TrLinkPeerNode ($1, $3);}
+    ;
+
+ProcessorTerm
+    : PARSEOP_PROCESSOR '('         {$<n>$ = TrCreateLeafNode (PARSEOP_PROCESSOR);}
+        NameString
+        ',' ByteConstExpr
+        OptionalDWordConstExpr
+        OptionalByteConstExpr
+        ')' '{'
+            TermList '}'            {$$ = TrLinkChildren ($<n>3,5,TrSetNodeFlags ($4, NODE_IS_NAME_DECLARATION),$6,$7,$8,$11);}
+    | PARSEOP_PROCESSOR '('
+        error ')'                   {$$ = AslDoError(); yyclearin;}
+    ;
+
+RawDataBufferTerm
+    : PARSEOP_DATABUFFER  '('       {$<n>$ = TrCreateLeafNode (PARSEOP_DATABUFFER);}
+        OptionalWordConst
+        ')' '{'
+            ByteList '}'            {$$ = TrLinkChildren ($<n>3,2,$4,$7);}
+    | PARSEOP_DATABUFFER '('
+        error ')'                   {$$ = AslDoError(); yyclearin;}
+    ;
+
+/*
+ * In RefOf, the node isn't really a target, but we can't keep track of it after
+ * we've taken a pointer to it. (hard to tell if a local becomes initialized this way.)
+ */
+RefOfTerm
+    : PARSEOP_REFOF '('             {$<n>$ = TrCreateLeafNode (PARSEOP_REFOF);}
+        SuperName
+        ')'                         {$$ = TrLinkChildren ($<n>3,1,TrSetNodeFlags ($4, NODE_IS_TARGET));}
+    | PARSEOP_REFOF '('
+        error ')'                   {$$ = AslDoError(); yyclearin;}
+    ;
+
+ReleaseTerm
+    : PARSEOP_RELEASE '('           {$<n>$ = TrCreateLeafNode (PARSEOP_RELEASE);}
+        SuperName
+        ')'                         {$$ = TrLinkChildren ($<n>3,1,$4);}
+    | PARSEOP_RELEASE '('
+        error ')'                   {$$ = AslDoError(); yyclearin;}
+    ;
+
+ResetTerm
+    : PARSEOP_RESET '('             {$<n>$ = TrCreateLeafNode (PARSEOP_RESET);}
+        SuperName
+        ')'                         {$$ = TrLinkChildren ($<n>3,1,$4);}
+    | PARSEOP_RESET '('
+        error ')'                   {$$ = AslDoError(); yyclearin;}
+    ;
+
+ReturnTerm
+    : PARSEOP_RETURN '('            {$<n>$ = TrCreateLeafNode (PARSEOP_RETURN);}
+        OptionalReturnArg
+        ')'                         {$$ = TrLinkChildren ($<n>3,1,$4);}
+    | PARSEOP_RETURN                {$$ = TrLinkChildren (TrCreateLeafNode (PARSEOP_RETURN),1,TrSetNodeFlags (TrCreateLeafNode (PARSEOP_ZERO), NODE_IS_NULL_RETURN));}
+    | PARSEOP_RETURN '('
+        error ')'                   {$$ = AslDoError(); yyclearin;}
+    ;
+
+ScopeTerm
+    : PARSEOP_SCOPE '('             {$<n>$ = TrCreateLeafNode (PARSEOP_SCOPE);}
+        NameString
+        ')' '{'
+            TermList '}'            {$$ = TrLinkChildren ($<n>3,2,TrSetNodeFlags ($4, NODE_IS_NAME_DECLARATION),$7);}
+    | PARSEOP_SCOPE '('
+        error ')'                   {$$ = AslDoError(); yyclearin;}
+    ;
+
+ShiftLeftTerm
+    : PARSEOP_SHIFTLEFT '('         {$<n>$ = TrCreateLeafNode (PARSEOP_SHIFTLEFT);}
+        TermArg
+        TermArgItem
+        Target
+        ')'                         {$$ = TrLinkChildren ($<n>3,3,$4,$5,$6);}
+    | PARSEOP_SHIFTLEFT '('
+        error ')'                   {$$ = AslDoError(); yyclearin;}
+    ;
+
+ShiftRightTerm
+    : PARSEOP_SHIFTRIGHT '('        {$<n>$ = TrCreateLeafNode (PARSEOP_SHIFTRIGHT);}
+        TermArg
+        TermArgItem
+        Target
+        ')'                         {$$ = TrLinkChildren ($<n>3,3,$4,$5,$6);}
+    | PARSEOP_SHIFTRIGHT '('
+        error ')'                   {$$ = AslDoError(); yyclearin;}
+    ;
+
+SignalTerm
+    : PARSEOP_SIGNAL '('            {$<n>$ = TrCreateLeafNode (PARSEOP_SIGNAL);}
+        SuperName
+        ')'                         {$$ = TrLinkChildren ($<n>3,1,$4);}
+    | PARSEOP_SIGNAL '('
+        error ')'                   {$$ = AslDoError(); yyclearin;}
+    ;
+
+SizeOfTerm
+    : PARSEOP_SIZEOF '('            {$<n>$ = TrCreateLeafNode (PARSEOP_SIZEOF);}
+        SuperName
+        ')'                         {$$ = TrLinkChildren ($<n>3,1,$4);}
+    | PARSEOP_SIZEOF '('
+        error ')'                   {$$ = AslDoError(); yyclearin;}
+    ;
+
+SleepTerm
+    : PARSEOP_SLEEP '('             {$<n>$ = TrCreateLeafNode (PARSEOP_SLEEP);}
+        TermArg
+        ')'                         {$$ = TrLinkChildren ($<n>3,1,$4);}
+    | PARSEOP_SLEEP '('
+        error ')'                   {$$ = AslDoError(); yyclearin;}
+    ;
+
+StallTerm
+    : PARSEOP_STALL '('             {$<n>$ = TrCreateLeafNode (PARSEOP_STALL);}
+        TermArg
+        ')'                         {$$ = TrLinkChildren ($<n>3,1,$4);}
+    | PARSEOP_STALL '('
+        error ')'                   {$$ = AslDoError(); yyclearin;}
+    ;
+
+StoreTerm
+    : PARSEOP_STORE '('             {$<n>$ = TrCreateLeafNode (PARSEOP_STORE);}
+        TermArg
+        ',' SuperName
+        ')'                         {$$ = TrLinkChildren ($<n>3,2,$4,TrSetNodeFlags ($6, NODE_IS_TARGET));}
+    | PARSEOP_STORE '('
+        error ')'                   {$$ = AslDoError(); yyclearin;}
+    ;
+
+SubtractTerm
+    : PARSEOP_SUBTRACT '('          {$<n>$ = TrCreateLeafNode (PARSEOP_SUBTRACT);}
+        TermArg
+        TermArgItem
+        Target
+        ')'                         {$$ = TrLinkChildren ($<n>3,3,$4,$5,$6);}
+    | PARSEOP_SUBTRACT '('
+        error ')'                   {$$ = AslDoError(); yyclearin;}
+    ;
+SwitchTerm
+    : PARSEOP_SWITCH '('            {$<n>$ = TrCreateLeafNode (PARSEOP_SWITCH);}
+        TermArg
+        ')' '{'
+            CaseDefaultTermList '}'
+                                    {$$ = TrLinkChildren ($<n>3,2,$4,$7);}
+    | PARSEOP_SWITCH '('
+        error ')'                   {$$ = AslDoError(); yyclearin;}
+    ;
+
+ThermalZoneTerm
+    : PARSEOP_THERMALZONE '('       {$<n>$ = TrCreateLeafNode (PARSEOP_THERMALZONE);}
+        NameString
+        ')' '{'
+            TermList '}'            {$$ = TrLinkChildren ($<n>3,2,TrSetNodeFlags ($4, NODE_IS_NAME_DECLARATION),$7);}
+    | PARSEOP_THERMALZONE '('
+        error ')'                   {$$ = AslDoError(); yyclearin;}
+    ;
+
+TimerTerm
+    : PARSEOP_TIMER '('             {$<n>$ = TrCreateLeafNode (PARSEOP_TIMER);}
+        ')'                         {$$ = TrLinkChildren ($<n>3,0);}
+    | PARSEOP_TIMER                 {$$ = TrLinkChildren (TrCreateLeafNode (PARSEOP_TIMER),0);}
+    | PARSEOP_TIMER '('
+        error ')'                   {$$ = AslDoError(); yyclearin;}
+    ;
+
+ToBCDTerm
+    : PARSEOP_TOBCD '('             {$<n>$ = TrCreateLeafNode (PARSEOP_TOBCD);}
+        TermArg
+        Target
+        ')'                         {$$ = TrLinkChildren ($<n>3,2,$4,$5);}
+    | PARSEOP_TOBCD '('
+        error ')'                   {$$ = AslDoError(); yyclearin;}
+    ;
+
+ToBufferTerm
+    : PARSEOP_TOBUFFER '('          {$<n>$ = TrCreateLeafNode (PARSEOP_TOBUFFER);}
+        TermArg
+        Target
+        ')'                         {$$ = TrLinkChildren ($<n>3,2,$4,$5);}
+    | PARSEOP_TOBUFFER '('
+        error ')'                   {$$ = AslDoError(); yyclearin;}
+    ;
+
+ToDecimalStringTerm
+    : PARSEOP_TODECIMALSTRING '('   {$<n>$ = TrCreateLeafNode (PARSEOP_TODECIMALSTRING);}
+        TermArg
+        Target
+        ')'                         {$$ = TrLinkChildren ($<n>3,2,$4,$5);}
+    | PARSEOP_TODECIMALSTRING '('
+        error ')'                   {$$ = AslDoError(); yyclearin;}
+    ;
+
+ToHexStringTerm
+    : PARSEOP_TOHEXSTRING '('       {$<n>$ = TrCreateLeafNode (PARSEOP_TOHEXSTRING);}
+        TermArg
+        Target
+        ')'                         {$$ = TrLinkChildren ($<n>3,2,$4,$5);}
+    | PARSEOP_TOHEXSTRING '('
+        error ')'                   {$$ = AslDoError(); yyclearin;}
+    ;
+
+ToIntegerTerm
+    : PARSEOP_TOINTEGER '('         {$<n>$ = TrCreateLeafNode (PARSEOP_TOINTEGER);}
+        TermArg
+        Target
+        ')'                         {$$ = TrLinkChildren ($<n>3,2,$4,$5);}
+    | PARSEOP_TOINTEGER '('
+        error ')'                   {$$ = AslDoError(); yyclearin;}
+    ;
+
+ToPLDTerm
+    : PARSEOP_TOPLD '('             {$<n>$ = TrCreateLeafNode (PARSEOP_TOPLD);}
+        PldKeywordList
+        ')'                         {$$ = TrLinkChildren ($<n>3,1,$4);}
+    | PARSEOP_TOPLD '('
+        error ')'                   {$$ = AslDoError(); yyclearin;}
+    ;
+
+PldKeywordList
+    :                               {$$ = NULL;}
+    | PldKeyword
+        PARSEOP_EXP_EQUALS Integer  {$$ = TrLinkChildren ($1,1,$3);}
+    | PldKeyword
+        PARSEOP_EXP_EQUALS String   {$$ = TrLinkChildren ($1,1,$3);}
+    | PldKeywordList ','            /* Allows a trailing comma at list end */
+    | PldKeywordList ','
+        PldKeyword
+        PARSEOP_EXP_EQUALS Integer  {$$ = TrLinkPeerNode ($1,TrLinkChildren ($3,1,$5));}
+    | PldKeywordList ','
+        PldKeyword
+        PARSEOP_EXP_EQUALS String   {$$ = TrLinkPeerNode ($1,TrLinkChildren ($3,1,$5));}
+    ;
+
+
+ToStringTerm
+    : PARSEOP_TOSTRING '('          {$<n>$ = TrCreateLeafNode (PARSEOP_TOSTRING);}
+        TermArg
+        OptionalCount
+        Target
+        ')'                         {$$ = TrLinkChildren ($<n>3,3,$4,$5,$6);}
+    | PARSEOP_TOSTRING '('
+        error ')'                   {$$ = AslDoError(); yyclearin;}
+    ;
+
+ToUUIDTerm
+    : PARSEOP_TOUUID '('
+        StringData ')'              {$$ = TrUpdateNode (PARSEOP_TOUUID, $3);}
+    | PARSEOP_TOUUID '('
+        error ')'                   {$$ = AslDoError(); yyclearin;}
+    ;
+
+UnicodeTerm
+    : PARSEOP_UNICODE '('           {$<n>$ = TrCreateLeafNode (PARSEOP_UNICODE);}
+        StringData
+        ')'                         {$$ = TrLinkChildren ($<n>3,2,0,$4);}
+    | PARSEOP_UNICODE '('
+        error ')'                   {$$ = AslDoError(); yyclearin;}
+    ;
+
+UnloadTerm
+    : PARSEOP_UNLOAD '('            {$<n>$ = TrCreateLeafNode (PARSEOP_UNLOAD);}
+        SuperName
+        ')'                         {$$ = TrLinkChildren ($<n>3,1,$4);}
+    | PARSEOP_UNLOAD '('
+        error ')'                   {$$ = AslDoError(); yyclearin;}
+    ;
+
+WaitTerm
+    : PARSEOP_WAIT '('              {$<n>$ = TrCreateLeafNode (PARSEOP_WAIT);}
+        SuperName
+        TermArgItem
+        ')'                         {$$ = TrLinkChildren ($<n>3,2,$4,$5);}
+    | PARSEOP_WAIT '('
+        error ')'                   {$$ = AslDoError(); yyclearin;}
+    ;
+
+XOrTerm
+    : PARSEOP_XOR '('               {$<n>$ = TrCreateLeafNode (PARSEOP_XOR);}
+        TermArg
+        TermArgItem
+        Target
+        ')'                         {$$ = TrLinkChildren ($<n>3,3,$4,$5,$6);}
+    | PARSEOP_XOR '('
+        error ')'                   {$$ = AslDoError(); yyclearin;}
+    ;
+
+WhileTerm
+    : PARSEOP_WHILE '('             {$<n>$ = TrCreateLeafNode (PARSEOP_WHILE);}
+        TermArg
+        ')' '{' TermList '}'
+                                    {$$ = TrLinkChildren ($<n>3,2,$4,$7);}
+    | PARSEOP_WHILE '('
+        error ')'                   {$$ = AslDoError(); yyclearin;}
+    ;
+
+
+/*******************************************************************************
+ *
+ * ASL Helper Terms
+ *
+ ******************************************************************************/
+
+AmlPackageLengthTerm
+    : Integer                       {$$ = TrUpdateNode (PARSEOP_PACKAGE_LENGTH,(ACPI_PARSE_OBJECT *) $1);}
+    ;
+
+NameStringItem
+    : ',' NameString                {$$ = $2;}
+    | ',' error                     {$$ = AslDoError (); yyclearin;}
+    ;
+
+TermArgItem
+    : ',' TermArg                   {$$ = $2;}
+    | ',' error                     {$$ = AslDoError (); yyclearin;}
+    ;
+
+OptionalReference
+    :                               {$$ = TrCreateLeafNode (PARSEOP_ZERO);}       /* Placeholder is a ZeroOp object */
+    | ','                           {$$ = TrCreateLeafNode (PARSEOP_ZERO);}       /* Placeholder is a ZeroOp object */
+    | ',' TermArg                   {$$ = $2;}
+    ;
+
+OptionalReturnArg
+    :                               {$$ = TrSetNodeFlags (TrCreateLeafNode (PARSEOP_ZERO), NODE_IS_NULL_RETURN);}       /* Placeholder is a ZeroOp object */
+    | TermArg                       {$$ = $1;}
+    ;
+
+OptionalSerializeRuleKeyword
+    :                               {$$ = NULL;}
+    | ','                           {$$ = NULL;}
+    | ',' SerializeRuleKeyword      {$$ = $2;}
+    ;
+
+OptionalTermArg
+    :                               {$$ = TrCreateLeafNode (PARSEOP_DEFAULT_ARG);}
+    | TermArg                       {$$ = $1;}
+    ;
+
+OptionalBufferLength
+    :                               {$$ = NULL;}
+    | TermArg                       {$$ = $1;}
+    ;
+
+OptionalWordConst
+    :                               {$$ = NULL;}
+    | WordConst                     {$$ = $1;}
+    ;
diff --git a/usr/src/cmd/acpi/iasl/aslstartup.c b/usr/src/cmd/acpi/iasl/aslstartup.c
new file mode 100644
index 0000000000..df90ae5fe7
--- /dev/null
+++ b/usr/src/cmd/acpi/iasl/aslstartup.c
@@ -0,0 +1,525 @@
+/******************************************************************************
+ *
+ * Module Name: aslstartup - Compiler startup routines, called from main
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2016, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include "aslcompiler.h"
+#include "actables.h"
+#include "acdisasm.h"
+#include "acapps.h"
+
+#define _COMPONENT          ACPI_COMPILER
+        ACPI_MODULE_NAME    ("aslstartup")
+
+
+/* Local prototypes */
+
+static UINT8
+AslDetectSourceFileType (
+    ASL_FILE_INFO           *Info);
+
+static ACPI_STATUS
+AslDoDisassembly (
+    void);
+
+
+/* Globals */
+
+static BOOLEAN          AslToFile = TRUE;
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AslInitializeGlobals
+ *
+ * PARAMETERS:  None
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Re-initialize globals needed to restart the compiler. This
+ *              allows multiple files to be disassembled and/or compiled.
+ *
+ ******************************************************************************/
+
+void
+AslInitializeGlobals (
+    void)
+{
+    UINT32                  i;
+
+
+    /* Init compiler globals */
+
+    Gbl_SyntaxError = 0;
+    Gbl_CurrentColumn = 0;
+    Gbl_CurrentLineNumber = 1;
+    Gbl_LogicalLineNumber = 1;
+    Gbl_CurrentLineOffset = 0;
+    Gbl_InputFieldCount = 0;
+    Gbl_InputByteCount = 0;
+    Gbl_NsLookupCount = 0;
+    Gbl_LineBufPtr = Gbl_CurrentLineBuffer;
+
+    Gbl_ErrorLog = NULL;
+    Gbl_NextError = NULL;
+    Gbl_Signature = NULL;
+    Gbl_FileType = 0;
+
+    TotalExecutableOpcodes = 0;
+    TotalNamedObjects = 0;
+    TotalKeywords = 0;
+    TotalParseNodes = 0;
+    TotalMethods = 0;
+    TotalAllocations = 0;
+    TotalAllocated = 0;
+    TotalFolds = 0;
+
+    AslGbl_NextEvent = 0;
+    for (i = 0; i < ASL_NUM_REPORT_LEVELS; i++)
+    {
+        Gbl_ExceptionCount[i] = 0;
+    }
+
+    for (i = ASL_FILE_INPUT; i <= ASL_MAX_FILE_TYPE; i++)
+    {
+        Gbl_Files[i].Handle = NULL;
+        Gbl_Files[i].Filename = NULL;
+    }
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AslDetectSourceFileType
+ *
+ * PARAMETERS:  Info            - Name/Handle for the file (must be open)
+ *
+ * RETURN:      File Type
+ *
+ * DESCRIPTION: Determine the type of the input file. Either binary (contains
+ *              non-ASCII characters), ASL file, or an ACPI Data Table file.
+ *
+ ******************************************************************************/
+
+static UINT8
+AslDetectSourceFileType (
+    ASL_FILE_INFO           *Info)
+{
+    char                    *FileChar;
+    UINT8                   Type = ASL_INPUT_TYPE_ASCII_DATA; /* default */
+    ACPI_STATUS             Status;
+
+
+    /* Check for 100% ASCII source file (comments are ignored) */
+
+    Status = FlIsFileAsciiSource (Info->Filename, FALSE);
+    if (ACPI_SUCCESS (Status))
+    {
+        /*
+         * File contains ASCII source code. Determine if this is an ASL
+         * file or an ACPI data table file.
+         */
+        while (fgets (Gbl_CurrentLineBuffer, Gbl_LineBufferSize, Info->Handle))
+        {
+            /* Uppercase the buffer for caseless compare */
+
+            FileChar = Gbl_CurrentLineBuffer;
+            while (*FileChar)
+            {
+                *FileChar = (char) toupper ((int) *FileChar);
+                FileChar++;
+            }
+
+            /* Presence of "DefinitionBlock" indicates actual ASL code */
+
+            if (strstr (Gbl_CurrentLineBuffer, "DEFINITIONBLOCK"))
+            {
+                /* Appears to be an ASL file */
+
+                Type = ASL_INPUT_TYPE_ASCII_ASL;
+                goto Cleanup;
+            }
+        }
+
+        /* Appears to be an ASCII data table source file */
+
+        Type = ASL_INPUT_TYPE_ASCII_DATA;
+        goto Cleanup;
+    }
+
+    /* We have some sort of binary table, check for valid ACPI table */
+
+    fseek (Info->Handle, 0, SEEK_SET);
+
+    Status = AcValidateTableHeader (Info->Handle, 0);
+    if (ACPI_SUCCESS (Status))
+    {
+        fprintf (stderr,
+            "Binary file appears to be a valid ACPI table, disassembling\n");
+
+        Type = ASL_INPUT_TYPE_BINARY_ACPI_TABLE;
+        goto Cleanup;
+    }
+
+    Type = ASL_INPUT_TYPE_BINARY;
+
+
+Cleanup:
+
+    /* Must seek back to the start of the file */
+
+    fseek (Info->Handle, 0, SEEK_SET);
+    return (Type);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AslDoDisassembly
+ *
+ * PARAMETERS:  None
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Initiate AML file disassembly. Uses ACPICA subsystem to build
+ *              namespace.
+ *
+ ******************************************************************************/
+
+static ACPI_STATUS
+AslDoDisassembly (
+    void)
+{
+    ACPI_STATUS             Status;
+
+
+    /* ACPICA subsystem initialization */
+
+    Status = AdInitialize ();
+    if (ACPI_FAILURE (Status))
+    {
+        return (Status);
+    }
+
+    Status = AcpiAllocateRootTable (4);
+    if (ACPI_FAILURE (Status))
+    {
+        AcpiOsPrintf ("Could not initialize ACPI Table Manager, %s\n",
+            AcpiFormatException (Status));
+        return (Status);
+    }
+
+    /* Handle additional output files for disassembler */
+
+    Gbl_FileType = ASL_INPUT_TYPE_BINARY_ACPI_TABLE;
+    Status = FlOpenMiscOutputFiles (Gbl_OutputFilenamePrefix);
+
+    /* This is where the disassembly happens */
+
+    AcpiGbl_DmOpt_Disasm = TRUE;
+    Status = AdAmlDisassemble (AslToFile,
+        Gbl_Files[ASL_FILE_INPUT].Filename, Gbl_OutputFilenamePrefix,
+        &Gbl_Files[ASL_FILE_INPUT].Filename);
+    if (ACPI_FAILURE (Status))
+    {
+        return (Status);
+    }
+
+    /* Check if any control methods were unresolved */
+
+    AcpiDmUnresolvedWarning (0);
+
+    /* Shutdown compiler and ACPICA subsystem */
+
+    AeClearErrorLog ();
+    (void) AcpiTerminate ();
+
+    /*
+     * Gbl_Files[ASL_FILE_INPUT].Filename was replaced with the
+     * .DSL disassembly file, which can now be compiled if requested
+     */
+    if (Gbl_DoCompile)
+    {
+        AcpiOsPrintf ("\nCompiling \"%s\"\n",
+            Gbl_Files[ASL_FILE_INPUT].Filename);
+        return (AE_CTRL_CONTINUE);
+    }
+
+    /* No need to free the filename string */
+
+    Gbl_Files[ASL_FILE_INPUT].Filename = NULL;
+
+    CmDeleteCaches ();
+    return (AE_OK);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AslDoOneFile
+ *
+ * PARAMETERS:  Filename        - Name of the file
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Process a single file - either disassemble, compile, or both
+ *
+ ******************************************************************************/
+
+ACPI_STATUS
+AslDoOneFile (
+    char                    *Filename)
+{
+    ACPI_STATUS             Status;
+
+
+    /* Re-initialize "some" compiler/preprocessor globals */
+
+    AslInitializeGlobals ();
+    PrInitializeGlobals ();
+
+    /*
+     * Extract the directory path. This path is used for possible include
+     * files and the optional AML filename embedded in the input file
+     * DefinitionBlock declaration.
+     */
+    Status = FlSplitInputPathname (Filename, &Gbl_DirectoryPath, NULL);
+    if (ACPI_FAILURE (Status))
+    {
+        return (Status);
+    }
+
+    /* Take a copy of the input filename, convert any backslashes */
+
+    Gbl_Files[ASL_FILE_INPUT].Filename =
+        UtStringCacheCalloc (strlen (Filename) + 1);
+
+    strcpy (Gbl_Files[ASL_FILE_INPUT].Filename, Filename);
+    UtConvertBackslashes (Gbl_Files[ASL_FILE_INPUT].Filename);
+
+    /*
+     * AML Disassembly (Optional)
+     */
+    if (Gbl_DisasmFlag)
+    {
+        Status = AslDoDisassembly ();
+        if (Status != AE_CTRL_CONTINUE)
+        {
+            return (Status);
+        }
+    }
+
+    /*
+     * Open the input file. Here, this should be an ASCII source file,
+     * either an ASL file or a Data Table file
+     */
+    Status = FlOpenInputFile (Gbl_Files[ASL_FILE_INPUT].Filename);
+    if (ACPI_FAILURE (Status))
+    {
+        AePrintErrorLog (ASL_FILE_STDERR);
+        return (AE_ERROR);
+    }
+
+    Gbl_OriginalInputFileSize = FlGetFileSize (ASL_FILE_INPUT);
+
+    /* Determine input file type */
+
+    Gbl_FileType = AslDetectSourceFileType (&Gbl_Files[ASL_FILE_INPUT]);
+    if (Gbl_FileType == ASL_INPUT_TYPE_BINARY)
+    {
+        return (AE_ERROR);
+    }
+
+    /*
+     * If -p not specified, we will use the input filename as the
+     * output filename prefix
+     */
+    if (Gbl_UseDefaultAmlFilename)
+    {
+        Gbl_OutputFilenamePrefix = Gbl_Files[ASL_FILE_INPUT].Filename;
+    }
+
+    /* Open the optional output files (listings, etc.) */
+
+    Status = FlOpenMiscOutputFiles (Gbl_OutputFilenamePrefix);
+    if (ACPI_FAILURE (Status))
+    {
+        AePrintErrorLog (ASL_FILE_STDERR);
+        return (AE_ERROR);
+    }
+
+    /*
+     * Compilation of ASL source versus DataTable source uses different
+     * compiler subsystems
+     */
+    switch (Gbl_FileType)
+    {
+    /*
+     * Data Table Compilation
+     */
+    case ASL_INPUT_TYPE_ASCII_DATA:
+
+        Status = DtDoCompile ();
+        if (ACPI_FAILURE (Status))
+        {
+            return (Status);
+        }
+
+        if (Gbl_Signature)
+        {
+            Gbl_Signature = NULL;
+        }
+
+        /* Check if any errors occurred during compile */
+
+        Status = AslCheckForErrorExit ();
+        if (ACPI_FAILURE (Status))
+        {
+            return (Status);
+        }
+
+        /* Cleanup (for next source file) and exit */
+
+        AeClearErrorLog ();
+        PrTerminatePreprocessor ();
+        return (Status);
+
+    /*
+     * ASL Compilation
+     */
+    case ASL_INPUT_TYPE_ASCII_ASL:
+
+        /* ACPICA subsystem initialization */
+
+        Status = AdInitialize ();
+        if (ACPI_FAILURE (Status))
+        {
+            return (Status);
+        }
+
+        (void) CmDoCompile ();
+        (void) AcpiTerminate ();
+
+        /* Check if any errors occurred during compile */
+
+        Status = AslCheckForErrorExit ();
+        if (ACPI_FAILURE (Status))
+        {
+            return (Status);
+        }
+
+        /* Cleanup (for next source file) and exit */
+
+        AeClearErrorLog ();
+        PrTerminatePreprocessor ();
+        return (AE_OK);
+
+    /*
+     * Binary ACPI table was auto-detected, disassemble it
+     */
+    case ASL_INPUT_TYPE_BINARY_ACPI_TABLE:
+
+        /* We have what appears to be an ACPI table, disassemble it */
+
+        FlCloseFile (ASL_FILE_INPUT);
+        Gbl_DoCompile = FALSE;
+        Gbl_DisasmFlag = TRUE;
+        Status = AslDoDisassembly ();
+        return (Status);
+
+    /* Unknown binary table */
+
+    case ASL_INPUT_TYPE_BINARY:
+
+        AePrintErrorLog (ASL_FILE_STDERR);
+        return (AE_ERROR);
+
+    default:
+
+        printf ("Unknown file type %X\n", Gbl_FileType);
+        return (AE_ERROR);
+    }
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AslCheckForErrorExit
+ *
+ * PARAMETERS:  None. Examines global exception count array
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Determine if compiler should abort with error status
+ *
+ ******************************************************************************/
+
+ACPI_STATUS
+AslCheckForErrorExit (
+    void)
+{
+
+    /*
+     * Return non-zero exit code if there have been errors, unless the
+     * global ignore error flag has been set
+     */
+    if (!Gbl_IgnoreErrors)
+    {
+        if (Gbl_ExceptionCount[ASL_ERROR] > 0)
+        {
+            return (AE_ERROR);
+        }
+
+        /* Optionally treat warnings as errors */
+
+        if (Gbl_WarningsAsErrors)
+        {
+            if ((Gbl_ExceptionCount[ASL_WARNING] > 0)  ||
+                (Gbl_ExceptionCount[ASL_WARNING2] > 0) ||
+                (Gbl_ExceptionCount[ASL_WARNING3] > 0))
+            {
+                return (AE_ERROR);
+            }
+        }
+    }
+
+    return (AE_OK);
+}
diff --git a/usr/src/cmd/acpi/iasl/aslstubs.c b/usr/src/cmd/acpi/iasl/aslstubs.c
new file mode 100644
index 0000000000..f0fbe035b5
--- /dev/null
+++ b/usr/src/cmd/acpi/iasl/aslstubs.c
@@ -0,0 +1,328 @@
+/******************************************************************************
+ *
+ * Module Name: aslstubs - Stubs used to link to Aml interpreter
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2016, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include "aslcompiler.h"
+#include "acdispat.h"
+#include "actables.h"
+#include "acevents.h"
+#include "acinterp.h"
+#include "acnamesp.h"
+
+#define _COMPONENT          ACPI_COMPILER
+        ACPI_MODULE_NAME    ("aslstubs")
+
+
+/*
+ * Stubs to simplify linkage to the ACPICA core subsystem.
+ * Things like Events, Global Lock, etc. are not used
+ * by the compiler, so they are stubbed out here.
+ */
+void
+AcpiNsExecModuleCodeList (
+    void)
+{
+}
+
+ACPI_STATUS
+AcpiNsInitializeObjects (
+    void)
+{
+    return (AE_OK);
+}
+
+ACPI_STATUS
+AcpiHwReadPort (
+    ACPI_IO_ADDRESS         Address,
+    UINT32                  *Value,
+    UINT32                  Width)
+{
+    return (AE_OK);
+}
+
+ACPI_STATUS
+AcpiHwWritePort (
+    ACPI_IO_ADDRESS         Address,
+    UINT32                  Value,
+    UINT32                  Width)
+{
+    return (AE_OK);
+}
+
+ACPI_STATUS
+AcpiDsMethodError (
+    ACPI_STATUS             Status,
+    ACPI_WALK_STATE         *WalkState)
+{
+    return (Status);
+}
+
+ACPI_STATUS
+AcpiDsMethodDataGetValue (
+    UINT8                   Type,
+    UINT32                  Index,
+    ACPI_WALK_STATE         *WalkState,
+    ACPI_OPERAND_OBJECT     **DestDesc)
+{
+    return (AE_OK);
+}
+
+ACPI_STATUS
+AcpiDsMethodDataGetNode (
+    UINT8                   Type,
+    UINT32                  Index,
+    ACPI_WALK_STATE         *WalkState,
+    ACPI_NAMESPACE_NODE     **Node)
+{
+    return (AE_OK);
+}
+
+ACPI_STATUS
+AcpiDsStoreObjectToLocal (
+    UINT8                   Type,
+    UINT32                  Index,
+    ACPI_OPERAND_OBJECT     *SrcDesc,
+    ACPI_WALK_STATE         *WalkState)
+{
+    return (AE_OK);
+}
+
+ACPI_STATUS
+AcpiEvInstallRegionHandlers (
+    void)
+{
+    return (AE_OK);
+}
+
+ACPI_STATUS
+AcpiEvQueueNotifyRequest (
+    ACPI_NAMESPACE_NODE     *Node,
+    UINT32                  NotifyValue)
+{
+    return (AE_OK);
+}
+
+BOOLEAN
+AcpiEvIsNotifyObject (
+    ACPI_NAMESPACE_NODE     *Node)
+{
+    return (FALSE);
+}
+
+#if (!ACPI_REDUCED_HARDWARE)
+ACPI_STATUS
+AcpiEvDeleteGpeBlock (
+    ACPI_GPE_BLOCK_INFO     *GpeBlock)
+{
+    return (AE_OK);
+}
+
+ACPI_STATUS
+AcpiEvAcquireGlobalLock (
+    UINT16                  Timeout)
+{
+    return (AE_OK);
+}
+
+ACPI_STATUS
+AcpiEvReleaseGlobalLock (
+    void)
+{
+    return (AE_OK);
+}
+#endif /* !ACPI_REDUCED_HARDWARE */
+
+ACPI_STATUS
+AcpiEvInitializeRegion (
+    ACPI_OPERAND_OBJECT     *RegionObj,
+    BOOLEAN                 AcpiNsLocked)
+{
+    return (AE_OK);
+}
+
+ACPI_STATUS
+AcpiExReadDataFromField (
+    ACPI_WALK_STATE         *WalkState,
+    ACPI_OPERAND_OBJECT     *ObjDesc,
+    ACPI_OPERAND_OBJECT     **RetBufferDesc)
+{
+    return (AE_SUPPORT);
+}
+
+ACPI_STATUS
+AcpiExWriteDataToField (
+    ACPI_OPERAND_OBJECT     *SourceDesc,
+    ACPI_OPERAND_OBJECT     *ObjDesc,
+    ACPI_OPERAND_OBJECT     **ResultDesc)
+{
+    return (AE_SUPPORT);
+}
+
+ACPI_STATUS
+AcpiExLoadTableOp (
+    ACPI_WALK_STATE         *WalkState,
+    ACPI_OPERAND_OBJECT     **ReturnDesc)
+{
+    return (AE_SUPPORT);
+}
+
+ACPI_STATUS
+AcpiExUnloadTable (
+    ACPI_OPERAND_OBJECT     *DdbHandle)
+{
+    return (AE_SUPPORT);
+}
+
+ACPI_STATUS
+AcpiExLoadOp (
+    ACPI_OPERAND_OBJECT     *ObjDesc,
+    ACPI_OPERAND_OBJECT     *Target,
+    ACPI_WALK_STATE         *WalkState)
+{
+    return (AE_SUPPORT);
+}
+
+void
+AcpiExDoDebugObject (
+    ACPI_OPERAND_OBJECT     *SourceDesc,
+    UINT32                  Level,
+    UINT32                  Index)
+{
+    return;
+}
+
+void
+AcpiExStartTraceMethod (
+    ACPI_NAMESPACE_NODE     *MethodNode,
+    ACPI_OPERAND_OBJECT     *ObjDesc,
+    ACPI_WALK_STATE         *WalkState)
+{
+    return;
+}
+
+void
+AcpiExStopTraceMethod (
+    ACPI_NAMESPACE_NODE     *MethodNode,
+    ACPI_OPERAND_OBJECT     *ObjDesc,
+    ACPI_WALK_STATE         *WalkState)
+{
+    return;
+}
+
+void
+AcpiExStartTraceOpcode (
+    ACPI_PARSE_OBJECT       *Op,
+    ACPI_WALK_STATE         *WalkState)
+{
+    return;
+}
+
+void
+AcpiExStopTraceOpcode (
+    ACPI_PARSE_OBJECT       *Op,
+    ACPI_WALK_STATE         *WalkState)
+
+{
+    return;
+}
+
+void
+AcpiExTracePoint (
+    ACPI_TRACE_EVENT_TYPE   Type,
+    BOOLEAN                 Begin,
+    UINT8                   *Aml,
+    char                    *Pathname)
+{
+    return;
+}
+
+ACPI_STATUS
+AcpiTbFindTable (
+    char                    *Signature,
+    char                    *OemId,
+    char                    *OemTableId,
+    UINT32                  *TableIndex)
+{
+    return (AE_SUPPORT);
+}
+
+ACPI_STATUS
+AcpiNsLoadTable (
+    UINT32                  TableIndex,
+    ACPI_NAMESPACE_NODE     *Node)
+{
+    return (AE_NOT_IMPLEMENTED);
+}
+
+ACPI_STATUS
+AcpiDsRestartControlMethod (
+    ACPI_WALK_STATE         *WalkState,
+    ACPI_OPERAND_OBJECT     *ReturnDesc)
+{
+    return (AE_OK);
+}
+
+void
+AcpiDsTerminateControlMethod (
+    ACPI_OPERAND_OBJECT     *MethodDesc,
+    ACPI_WALK_STATE         *WalkState)
+{
+    return;
+}
+
+ACPI_STATUS
+AcpiDsCallControlMethod (
+    ACPI_THREAD_STATE       *Thread,
+    ACPI_WALK_STATE         *WalkState,
+    ACPI_PARSE_OBJECT       *Op)
+{
+    return (AE_OK);
+}
+
+ACPI_STATUS
+AcpiDsMethodDataInitArgs (
+    ACPI_OPERAND_OBJECT     **Params,
+    UINT32                  MaxParamCount,
+    ACPI_WALK_STATE         *WalkState)
+{
+    return (AE_OK);
+}
diff --git a/usr/src/cmd/acpi/iasl/aslsupport.l b/usr/src/cmd/acpi/iasl/aslsupport.l
new file mode 100644
index 0000000000..deb9e9a310
--- /dev/null
+++ b/usr/src/cmd/acpi/iasl/aslsupport.l
@@ -0,0 +1,852 @@
+/******************************************************************************
+ *
+ * Module Name: aslsupport.l - Flex/lex scanner C support routines.
+ *              NOTE: Included into aslcompile.l, not compiled by itself.
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2016, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+/* Configuration */
+
+#define ASL_SPACES_PER_TAB      4
+
+#define ASL_NORMAL_CHAR         0
+#define ASL_ESCAPE_SEQUENCE     1
+#define ASL_OCTAL_CONSTANT      2
+#define ASL_HEX_CONSTANT        3
+
+
+/* File node - used for "Include" operator file stack */
+
+typedef struct asl_file_node
+{
+    FILE                    *File;
+    UINT32                  CurrentLineNumber;
+    YY_BUFFER_STATE         State;
+    char                    *Filename;
+    struct asl_file_node    *Next;
+
+} ASL_FILE_NODE;
+
+/* File stack for the "Include" operator (NOT #include operator) */
+
+ASL_FILE_NODE               *Gbl_IncludeFileStack = NULL;
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AslParserCleanup
+ *
+ * Used to delete the current buffer
+ *
+ ******************************************************************************/
+
+void
+AslParserCleanup (
+    void)
+{
+
+    yy_delete_buffer (YY_CURRENT_BUFFER);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AslDoLineDirective
+ *
+ * PARAMETERS:  None. Uses input() to access current source code line
+ *
+ * RETURN:      Updates global line number and filename
+ *
+ * DESCRIPTION: Handle #line directives emitted by the preprocessor.
+ *
+ * The #line directive is emitted by the preprocesser, and is used to
+ * pass through line numbers from the original source code file to the
+ * preprocessor output file (.i). This allows any compiler-generated
+ * error messages to be displayed with the correct line number.
+ *
+ ******************************************************************************/
+
+static void
+AslDoLineDirective (
+    void)
+{
+    int                     c;
+    char                    *Token;
+    UINT32                  LineNumber;
+    char                    *Filename;
+    UINT32                  i;
+
+   Gbl_HasIncludeFiles = TRUE;
+
+    /* Eat the entire line that contains the #line directive */
+
+    Gbl_LineBufPtr = Gbl_CurrentLineBuffer;
+
+    while ((c = input()) != '\n' && c != EOF)
+    {
+        *Gbl_LineBufPtr = c;
+        Gbl_LineBufPtr++;
+    }
+    *Gbl_LineBufPtr = 0;
+
+    /* First argument is the actual line number */
+
+    Token = strtok (Gbl_CurrentLineBuffer, " ");
+    if (!Token)
+    {
+        goto ResetAndExit;
+    }
+
+    /* First argument is the line number */
+
+    LineNumber = (UINT32) UtDoConstant (Token);
+
+    /* Emit the appropriate number of newlines */
+
+    Gbl_CurrentColumn = 0;
+    if (LineNumber > Gbl_CurrentLineNumber)
+    {
+        for (i = 0; i < (LineNumber - Gbl_CurrentLineNumber); i++)
+        {
+            FlWriteFile (ASL_FILE_SOURCE_OUTPUT, "\n", 1);
+            Gbl_CurrentColumn++;
+        }
+    }
+
+    FlSetLineNumber (LineNumber);
+
+    /* Second argument is the optional filename (in double quotes) */
+
+    Token = strtok (NULL, " \"");
+    if (Token)
+    {
+        Filename = ACPI_ALLOCATE_ZEROED (strlen (Token) + 1);
+        strcpy (Filename, Token);
+        FlSetFilename (Filename);
+    }
+
+    /* Third argument is not supported at this time */
+
+ResetAndExit:
+
+    /* Reset globals for a new line */
+
+    Gbl_CurrentLineOffset += Gbl_CurrentColumn;
+    Gbl_CurrentColumn = 0;
+    Gbl_LineBufPtr = Gbl_CurrentLineBuffer;
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AslPopInputFileStack
+ *
+ * PARAMETERS:  None
+ *
+ * RETURN:      0 if a node was popped, -1 otherwise
+ *
+ * DESCRIPTION: Pop the top of the input file stack and point the parser to
+ *              the saved parse buffer contained in the fnode. Also, set the
+ *              global line counters to the saved values. This function is
+ *              called when an include file reaches EOF.
+ *
+ ******************************************************************************/
+
+int
+AslPopInputFileStack (
+    void)
+{
+    ASL_FILE_NODE           *Fnode;
+
+
+    Gbl_PreviousIncludeFilename = Gbl_Files[ASL_FILE_INPUT].Filename;
+    Fnode = Gbl_IncludeFileStack;
+    DbgPrint (ASL_PARSE_OUTPUT,
+        "\nPop InputFile Stack, Fnode %p\n", Fnode);
+
+    DbgPrint (ASL_PARSE_OUTPUT,
+        "Include: Closing \"%s\"\n\n", Gbl_Files[ASL_FILE_INPUT].Filename);
+
+    if (!Fnode)
+    {
+        return (-1);
+    }
+
+    /* Close the current include file */
+
+    fclose (yyin);
+
+    /* Update the top-of-stack */
+
+    Gbl_IncludeFileStack = Fnode->Next;
+
+    /* Reset global line counter and filename */
+
+    Gbl_Files[ASL_FILE_INPUT].Filename = Fnode->Filename;
+    Gbl_CurrentLineNumber = Fnode->CurrentLineNumber;
+
+    /* Point the parser to the popped file */
+
+    yy_delete_buffer (YY_CURRENT_BUFFER);
+    yy_switch_to_buffer (Fnode->State);
+
+    /* All done with this node */
+
+    ACPI_FREE (Fnode);
+    return (0);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AslPushInputFileStack
+ *
+ * PARAMETERS:  InputFile           - Open file pointer
+ *              Filename            - Name of the file
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Push the InputFile onto the file stack, and point the parser
+ *              to this file. Called when an include file is successfully
+ *              opened.
+ *
+ ******************************************************************************/
+
+void
+AslPushInputFileStack (
+    FILE                    *InputFile,
+    char                    *Filename)
+{
+    ASL_FILE_NODE           *Fnode;
+    YY_BUFFER_STATE         State;
+
+
+    /* Save the current state in an Fnode */
+
+    Fnode = UtLocalCalloc (sizeof (ASL_FILE_NODE));
+
+    Fnode->File = yyin;
+    Fnode->Next = Gbl_IncludeFileStack;
+    Fnode->State = YY_CURRENT_BUFFER;
+    Fnode->Filename = Gbl_Files[ASL_FILE_INPUT].Filename;
+    Fnode->CurrentLineNumber = Gbl_CurrentLineNumber;
+
+    /* Push it on the stack */
+
+    Gbl_IncludeFileStack = Fnode;
+
+    /* Point the parser to this file */
+
+    State = yy_create_buffer (InputFile, YY_BUF_SIZE);
+    yy_switch_to_buffer (State);
+
+    DbgPrint (ASL_PARSE_OUTPUT,
+        "\nPush InputFile Stack, returning %p\n\n", InputFile);
+
+    /* Reset the global line count and filename */
+
+    Gbl_Files[ASL_FILE_INPUT].Filename =
+        UtStringCacheCalloc (strlen (Filename) + 1);
+
+    strcpy (Gbl_Files[ASL_FILE_INPUT].Filename, Filename);
+
+    Gbl_CurrentLineNumber = 1;
+    yyin = InputFile;
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AslResetCurrentLineBuffer
+ *
+ * PARAMETERS:  None
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Reset the Line Buffer to zero, increment global line numbers.
+ *
+ ******************************************************************************/
+
+void
+AslResetCurrentLineBuffer (
+    void)
+{
+
+    if (Gbl_Files[ASL_FILE_SOURCE_OUTPUT].Handle)
+    {
+        FlWriteFile (ASL_FILE_SOURCE_OUTPUT, Gbl_CurrentLineBuffer,
+            Gbl_LineBufPtr - Gbl_CurrentLineBuffer);
+    }
+
+    Gbl_CurrentLineOffset += Gbl_CurrentColumn;
+    Gbl_CurrentColumn = 0;
+
+    Gbl_CurrentLineNumber++;
+    Gbl_LogicalLineNumber++;
+    Gbl_LineBufPtr = Gbl_CurrentLineBuffer;
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AslInsertLineBuffer
+ *
+ * PARAMETERS:  SourceChar          - One char from the input ASL source file
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Put one character of the source file into the temp line buffer
+ *
+ ******************************************************************************/
+
+void
+AslInsertLineBuffer (
+    int                     SourceChar)
+{
+    UINT32                  i;
+    UINT32                  Count = 1;
+
+
+    if (SourceChar == EOF)
+    {
+        return;
+    }
+
+    Gbl_InputByteCount++;
+
+    /* Handle tabs. Convert to spaces */
+
+    if (SourceChar == '\t')
+    {
+        SourceChar = ' ';
+        Count = ASL_SPACES_PER_TAB -
+                    (Gbl_CurrentColumn & (ASL_SPACES_PER_TAB-1));
+    }
+
+    for (i = 0; i < Count; i++)
+    {
+        Gbl_CurrentColumn++;
+
+        /* Insert the character into the line buffer */
+
+        *Gbl_LineBufPtr = (UINT8) SourceChar;
+        Gbl_LineBufPtr++;
+
+        if (Gbl_LineBufPtr >
+            (Gbl_CurrentLineBuffer + (Gbl_LineBufferSize - 1)))
+        {
+#if 0
+            /*
+             * Warning if we have split a long source line.
+             * <Probably overkill>
+             */
+            sprintf (MsgBuffer, "Max %u", Gbl_LineBufferSize);
+            AslCommonError (ASL_WARNING, ASL_MSG_LONG_LINE,
+                Gbl_CurrentLineNumber, Gbl_LogicalLineNumber,
+                Gbl_CurrentLineOffset, Gbl_CurrentColumn,
+                Gbl_Files[ASL_FILE_INPUT].Filename, MsgBuffer);
+#endif
+
+            AslResetCurrentLineBuffer ();
+        }
+        else if (SourceChar == '\n')
+        {
+            /* End of line */
+
+            AslResetCurrentLineBuffer ();
+        }
+    }
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    count
+ *
+ * PARAMETERS:  yytext              - Contains the matched keyword.
+ *              Type                - Keyword/Character type:
+ *                                      0 = anything except a keyword
+ *                                      1 = pseudo-keywords
+ *                                      2 = non-executable ASL keywords
+ *                                      3 = executable ASL keywords
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Count keywords and put them into the line buffer
+ *
+ ******************************************************************************/
+
+static void
+count (
+    int                 Type)
+{
+    int                 i;
+
+
+    switch (Type)
+    {
+    case 2:
+
+        TotalKeywords++;
+        TotalNamedObjects++;
+        break;
+
+    case 3:
+
+        TotalKeywords++;
+        TotalExecutableOpcodes++;
+        break;
+
+    default:
+
+        break;
+    }
+
+    for (i = 0; (yytext[i] != 0) && (yytext[i] != EOF); i++)
+    {
+        AslInsertLineBuffer (yytext[i]);
+        *Gbl_LineBufPtr = 0;
+    }
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AslDoComment
+ *
+ * PARAMETERS:  none
+ *
+ * RETURN:      none
+ *
+ * DESCRIPTION: Process a standard comment.
+ *
+ ******************************************************************************/
+
+static char
+AslDoComment (
+    void)
+{
+    int                 c;
+    int                 c1 = 0;
+
+
+    AslInsertLineBuffer ('/');
+    AslInsertLineBuffer ('*');
+
+loop:
+
+    /* Eat chars until end-of-comment */
+
+    while (((c = input ()) != '*') && (c != EOF))
+    {
+        AslInsertLineBuffer (c);
+        c1 = c;
+    }
+
+    if (c == EOF)
+    {
+        goto EarlyEOF;
+    }
+
+    /*
+     * Check for nested comment -- can help catch cases where a previous
+     * comment was accidently left unterminated
+     */
+    if ((c1 == '/') && (c == '*'))
+    {
+        AslCommonError (ASL_WARNING, ASL_MSG_NESTED_COMMENT,
+            Gbl_CurrentLineNumber, Gbl_LogicalLineNumber,
+            Gbl_InputByteCount, Gbl_CurrentColumn,
+            Gbl_Files[ASL_FILE_INPUT].Filename, NULL);
+    }
+
+    /* Comment is closed only if the NEXT character is a slash */
+
+    AslInsertLineBuffer (c);
+
+    if (((c1 = input ()) != '/') && (c1 != EOF))
+    {
+        unput(c1);
+        goto loop;
+    }
+
+    if (c1 == EOF)
+    {
+        goto EarlyEOF;
+    }
+
+    AslInsertLineBuffer (c1);
+    return (TRUE);
+
+
+EarlyEOF:
+    /*
+     * Premature End-Of-File
+     */
+    AslCommonError (ASL_ERROR, ASL_MSG_EARLY_EOF,
+        Gbl_CurrentLineNumber, Gbl_LogicalLineNumber,
+        Gbl_CurrentLineOffset, Gbl_CurrentColumn,
+        Gbl_Files[ASL_FILE_INPUT].Filename, NULL);
+    return (FALSE);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AslDoCommentType2
+ *
+ * PARAMETERS:  none
+ *
+ * RETURN:      none
+ *
+ * DESCRIPTION: Process a new "//" comment.
+ *
+ ******************************************************************************/
+
+static char
+AslDoCommentType2 (
+    void)
+{
+    int                 c;
+
+
+    AslInsertLineBuffer ('/');
+    AslInsertLineBuffer ('/');
+
+    while (((c = input ()) != '\n') && (c != EOF))
+    {
+        AslInsertLineBuffer (c);
+    }
+
+    if (c == EOF)
+    {
+        /* End of file is OK, change to newline. Let parser detect EOF later */
+
+        c = '\n';
+    }
+
+    AslInsertLineBuffer (c);
+    return (TRUE);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AslDoStringLiteral
+ *
+ * PARAMETERS:  none
+ *
+ * RETURN:      none
+ *
+ * DESCRIPTION: Process a string literal (surrounded by quotes)
+ *
+ ******************************************************************************/
+
+static char
+AslDoStringLiteral (
+    void)
+{
+    char                *StringBuffer = MsgBuffer;
+    char                *EndBuffer = MsgBuffer + ASL_MSG_BUFFER_SIZE;
+    char                *CleanString;
+    int                 StringChar;
+    UINT32              State = ASL_NORMAL_CHAR;
+    UINT32              i = 0;
+    UINT8               Digit;
+    char                ConvertBuffer[4];
+
+
+    /*
+     * Eat chars until end-of-literal.
+     * NOTE:  Put back the original surrounding quotes into the
+     * source line buffer.
+     */
+    AslInsertLineBuffer ('\"');
+    while ((StringChar = input()) != EOF)
+    {
+        AslInsertLineBuffer (StringChar);
+
+DoCharacter:
+        switch (State)
+        {
+        case ASL_NORMAL_CHAR:
+
+            switch (StringChar)
+            {
+            case '\\':
+                /*
+                 * Special handling for backslash-escape sequence. We will
+                 * toss the backslash and translate the escape char(s).
+                 */
+                State = ASL_ESCAPE_SEQUENCE;
+                continue;
+
+            case '\"':
+
+                /* String terminator */
+
+                goto CompletedString;
+
+            default:
+
+                break;
+            }
+            break;
+
+
+        case ASL_ESCAPE_SEQUENCE:
+
+            State = ASL_NORMAL_CHAR;
+            switch (StringChar)
+            {
+            case 'a':
+
+                StringChar = 0x07;      /* BELL */
+                break;
+
+            case 'b':
+
+                StringChar = 0x08;      /* BACKSPACE */
+                break;
+
+            case 'f':
+
+                StringChar = 0x0C;      /* FORMFEED */
+                break;
+
+            case 'n':
+
+                StringChar = 0x0A;      /* LINEFEED */
+                break;
+
+            case 'r':
+
+                StringChar = 0x0D;      /* CARRIAGE RETURN*/
+                break;
+
+            case 't':
+
+                StringChar = 0x09;      /* HORIZONTAL TAB */
+                break;
+
+            case 'v':
+
+                StringChar = 0x0B;      /* VERTICAL TAB */
+                break;
+
+            case 'x':
+
+                State = ASL_HEX_CONSTANT;
+                i = 0;
+                continue;
+
+            case '\'':                  /* Single Quote */
+            case '\"':                  /* Double Quote */
+            case '\\':                  /* Backslash */
+
+                break;
+
+            default:
+
+                /* Check for an octal digit (0-7) */
+
+                if (ACPI_IS_OCTAL_DIGIT (StringChar))
+                {
+                    State = ASL_OCTAL_CONSTANT;
+                    ConvertBuffer[0] = StringChar;
+                    i = 1;
+                    continue;
+                }
+
+                /* Unknown escape sequence issue warning, but use the character */
+
+                AslCommonError (ASL_WARNING, ASL_MSG_INVALID_ESCAPE,
+                    Gbl_CurrentLineNumber, Gbl_LogicalLineNumber,
+                    Gbl_CurrentLineOffset, Gbl_CurrentColumn,
+                    Gbl_Files[ASL_FILE_INPUT].Filename, NULL);
+                break;
+            }
+            break;
+
+
+        case ASL_OCTAL_CONSTANT:
+
+            /* Up to three octal digits allowed */
+
+            if (!ACPI_IS_OCTAL_DIGIT (StringChar) ||
+                (i > 2))
+            {
+                /*
+                 * Reached end of the constant. Convert the assembled ASCII
+                 * string and resume processing of the next character
+                 */
+                ConvertBuffer[i] = 0;
+                Digit = (UINT8) strtoul (ConvertBuffer, NULL, 8);
+
+                /* Check for NULL or non-ascii character (ignore if so) */
+
+                if ((Digit == 0) || (Digit > ACPI_ASCII_MAX))
+                {
+                    AslCommonError (ASL_WARNING, ASL_MSG_INVALID_STRING,
+                        Gbl_CurrentLineNumber, Gbl_LogicalLineNumber,
+                        Gbl_CurrentLineOffset, Gbl_CurrentColumn,
+                        Gbl_Files[ASL_FILE_INPUT].Filename, NULL);
+                }
+                else
+                {
+                    *StringBuffer = (char) Digit;
+                    StringBuffer++;
+                    if (StringBuffer >= EndBuffer)
+                    {
+                        goto BufferOverflow;
+                    }
+                }
+
+                State = ASL_NORMAL_CHAR;
+                goto DoCharacter;
+                break;
+            }
+
+            /* Append another digit of the constant */
+
+            ConvertBuffer[i] = StringChar;
+            i++;
+            continue;
+
+        case ASL_HEX_CONSTANT:
+
+            /* Up to two hex digits allowed */
+
+            if (!isxdigit (StringChar) ||
+                (i > 1))
+            {
+                /*
+                 * Reached end of the constant. Convert the assembled ASCII
+                 * string and resume processing of the next character
+                 */
+                ConvertBuffer[i] = 0;
+                Digit = (UINT8) strtoul (ConvertBuffer, NULL, 16);
+
+                /* Check for NULL or non-ascii character (ignore if so) */
+
+                if ((Digit == 0) || (Digit > ACPI_ASCII_MAX))
+                {
+                    AslCommonError (ASL_WARNING, ASL_MSG_INVALID_STRING,
+                        Gbl_CurrentLineNumber, Gbl_LogicalLineNumber,
+                        Gbl_CurrentLineOffset, Gbl_CurrentColumn,
+                        Gbl_Files[ASL_FILE_INPUT].Filename, NULL);
+                }
+                else
+                {
+                    *StringBuffer = (char) Digit;
+                    StringBuffer++;
+                    if (StringBuffer >= EndBuffer)
+                    {
+                        goto BufferOverflow;
+                    }
+                }
+
+                State = ASL_NORMAL_CHAR;
+                goto DoCharacter;
+                break;
+            }
+
+            /* Append another digit of the constant */
+
+            ConvertBuffer[i] = StringChar;
+            i++;
+            continue;
+
+        default:
+
+            break;
+        }
+
+        /* Save the finished character */
+
+        *StringBuffer = StringChar;
+        StringBuffer++;
+        if (StringBuffer >= EndBuffer)
+        {
+            goto BufferOverflow;
+        }
+    }
+
+    /*
+     * Premature End-Of-File
+     */
+    AslCommonError (ASL_ERROR, ASL_MSG_EARLY_EOF,
+        Gbl_CurrentLineNumber, Gbl_LogicalLineNumber,
+        Gbl_CurrentLineOffset, Gbl_CurrentColumn,
+        Gbl_Files[ASL_FILE_INPUT].Filename, NULL);
+    return (FALSE);
+
+
+CompletedString:
+    /*
+     * Null terminate the input string and copy string to a new buffer
+     */
+    *StringBuffer = 0;
+
+    CleanString = UtStringCacheCalloc (strlen (MsgBuffer) + 1);
+    if (!CleanString)
+    {
+        AslCommonError (ASL_ERROR, ASL_MSG_MEMORY_ALLOCATION,
+            Gbl_CurrentLineNumber, Gbl_LogicalLineNumber,
+            Gbl_CurrentLineOffset, Gbl_CurrentColumn,
+            Gbl_Files[ASL_FILE_INPUT].Filename, NULL);
+        return (FALSE);
+    }
+
+    strcpy (CleanString, MsgBuffer);
+    AslCompilerlval.s = CleanString;
+    return (TRUE);
+
+
+BufferOverflow:
+
+    /* Literal was too long */
+
+    AslCommonError (ASL_ERROR, ASL_MSG_STRING_LENGTH,
+        Gbl_CurrentLineNumber, Gbl_LogicalLineNumber,
+        Gbl_CurrentLineOffset, Gbl_CurrentColumn,
+        Gbl_Files[ASL_FILE_INPUT].Filename, "Max length 4096");
+    return (FALSE);
+}
diff --git a/usr/src/cmd/acpi/iasl/aslsupport.y b/usr/src/cmd/acpi/iasl/aslsupport.y
new file mode 100644
index 0000000000..cd2605b836
--- /dev/null
+++ b/usr/src/cmd/acpi/iasl/aslsupport.y
@@ -0,0 +1,120 @@
+NoEcho('
+/******************************************************************************
+ *
+ * Module Name: aslsupport.y - Bison/Yacc C support functions
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2016, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+')
+
+/******************************************************************************
+ *
+ * Local support functions
+ *
+ *****************************************************************************/
+
+/*! [Begin] no source code translation */
+int
+AslCompilerwrap(void)
+{
+  return (1);
+}
+/*! [End] no source code translation !*/
+
+
+void *
+AslLocalAllocate (
+    unsigned int        Size)
+{
+    void                *Mem;
+
+
+    DbgPrint (ASL_PARSE_OUTPUT,
+        "\nAslLocalAllocate: Expanding Stack to %u\n\n", Size);
+
+    Mem = ACPI_ALLOCATE_ZEROED (Size);
+    if (!Mem)
+    {
+        AslCommonError (ASL_ERROR, ASL_MSG_MEMORY_ALLOCATION,
+            Gbl_CurrentLineNumber, Gbl_LogicalLineNumber,
+            Gbl_InputByteCount, Gbl_CurrentColumn,
+            Gbl_Files[ASL_FILE_INPUT].Filename, NULL);
+        exit (1);
+    }
+
+    return (Mem);
+}
+
+ACPI_PARSE_OBJECT *
+AslDoError (
+    void)
+{
+
+    return (TrCreateLeafNode (PARSEOP_ERRORNODE));
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    UtGetOpName
+ *
+ * PARAMETERS:  ParseOpcode         - Parser keyword ID
+ *
+ * RETURN:      Pointer to the opcode name
+ *
+ * DESCRIPTION: Get the ascii name of the parse opcode
+ *
+ ******************************************************************************/
+
+char *
+UtGetOpName (
+    UINT32                  ParseOpcode)
+{
+#ifdef ASL_YYTNAME_START
+    /*
+     * First entries (ASL_YYTNAME_START) in yytname are special reserved names.
+     * Ignore first 8 characters of the name
+     */
+    return ((char *) yytname
+        [(ParseOpcode - ASL_FIRST_PARSE_OPCODE) + ASL_YYTNAME_START] + 8);
+#else
+    return ("[Unknown parser generator]");
+#endif
+}
diff --git a/usr/src/cmd/acpi/iasl/asltokens.y b/usr/src/cmd/acpi/iasl/asltokens.y
new file mode 100644
index 0000000000..429fa424cb
--- /dev/null
+++ b/usr/src/cmd/acpi/iasl/asltokens.y
@@ -0,0 +1,483 @@
+NoEcho('
+/******************************************************************************
+ *
+ * Module Name: asltokens.y - Bison/Yacc token types
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2016, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+')
+
+/******************************************************************************
+ *
+ * Token types: These are returned by the lexer
+ *
+ * NOTE: This list MUST match the AslKeywordMapping table found
+ *       in aslmap.c EXACTLY!  Double check any changes!
+ *
+ *****************************************************************************/
+
+%token <i> PARSEOP_ACCESSAS
+%token <i> PARSEOP_ACCESSATTRIB_BLOCK
+%token <i> PARSEOP_ACCESSATTRIB_BLOCK_CALL
+%token <i> PARSEOP_ACCESSATTRIB_BYTE
+%token <i> PARSEOP_ACCESSATTRIB_MULTIBYTE
+%token <i> PARSEOP_ACCESSATTRIB_QUICK
+%token <i> PARSEOP_ACCESSATTRIB_RAW_BYTES
+%token <i> PARSEOP_ACCESSATTRIB_RAW_PROCESS
+%token <i> PARSEOP_ACCESSATTRIB_SND_RCV
+%token <i> PARSEOP_ACCESSATTRIB_WORD
+%token <i> PARSEOP_ACCESSATTRIB_WORD_CALL
+%token <i> PARSEOP_ACCESSTYPE_ANY
+%token <i> PARSEOP_ACCESSTYPE_BUF
+%token <i> PARSEOP_ACCESSTYPE_BYTE
+%token <i> PARSEOP_ACCESSTYPE_DWORD
+%token <i> PARSEOP_ACCESSTYPE_QWORD
+%token <i> PARSEOP_ACCESSTYPE_WORD
+%token <i> PARSEOP_ACQUIRE
+%token <i> PARSEOP_ADD
+%token <i> PARSEOP_ADDRESSINGMODE_7BIT
+%token <i> PARSEOP_ADDRESSINGMODE_10BIT
+%token <i> PARSEOP_ADDRESSTYPE_ACPI
+%token <i> PARSEOP_ADDRESSTYPE_MEMORY
+%token <i> PARSEOP_ADDRESSTYPE_NVS
+%token <i> PARSEOP_ADDRESSTYPE_RESERVED
+%token <i> PARSEOP_ALIAS
+%token <i> PARSEOP_AND
+%token <i> PARSEOP_ARG0
+%token <i> PARSEOP_ARG1
+%token <i> PARSEOP_ARG2
+%token <i> PARSEOP_ARG3
+%token <i> PARSEOP_ARG4
+%token <i> PARSEOP_ARG5
+%token <i> PARSEOP_ARG6
+%token <i> PARSEOP_BANKFIELD
+%token <i> PARSEOP_BITSPERBYTE_EIGHT
+%token <i> PARSEOP_BITSPERBYTE_FIVE
+%token <i> PARSEOP_BITSPERBYTE_NINE
+%token <i> PARSEOP_BITSPERBYTE_SEVEN
+%token <i> PARSEOP_BITSPERBYTE_SIX
+%token <i> PARSEOP_BREAK
+%token <i> PARSEOP_BREAKPOINT
+%token <i> PARSEOP_BUFFER
+%token <i> PARSEOP_BUSMASTERTYPE_MASTER
+%token <i> PARSEOP_BUSMASTERTYPE_NOTMASTER
+%token <i> PARSEOP_BYTECONST
+%token <i> PARSEOP_CASE
+%token <i> PARSEOP_CLOCKPHASE_FIRST
+%token <i> PARSEOP_CLOCKPHASE_SECOND
+%token <i> PARSEOP_CLOCKPOLARITY_HIGH
+%token <i> PARSEOP_CLOCKPOLARITY_LOW
+%token <i> PARSEOP_CONCATENATE
+%token <i> PARSEOP_CONCATENATERESTEMPLATE
+%token <i> PARSEOP_CONDREFOF
+%token <i> PARSEOP_CONNECTION
+%token <i> PARSEOP_CONTINUE
+%token <i> PARSEOP_COPYOBJECT
+%token <i> PARSEOP_CREATEBITFIELD
+%token <i> PARSEOP_CREATEBYTEFIELD
+%token <i> PARSEOP_CREATEDWORDFIELD
+%token <i> PARSEOP_CREATEFIELD
+%token <i> PARSEOP_CREATEQWORDFIELD
+%token <i> PARSEOP_CREATEWORDFIELD
+%token <i> PARSEOP_DATABUFFER
+%token <i> PARSEOP_DATATABLEREGION
+%token <i> PARSEOP_DEBUG
+%token <i> PARSEOP_DECODETYPE_POS
+%token <i> PARSEOP_DECODETYPE_SUB
+%token <i> PARSEOP_DECREMENT
+%token <i> PARSEOP_DEFAULT
+%token <i> PARSEOP_DEFAULT_ARG
+%token <i> PARSEOP_DEFINITION_BLOCK
+%token <i> PARSEOP_DEREFOF
+%token <i> PARSEOP_DEVICE
+%token <i> PARSEOP_DEVICEPOLARITY_HIGH
+%token <i> PARSEOP_DEVICEPOLARITY_LOW
+%token <i> PARSEOP_DIVIDE
+%token <i> PARSEOP_DMA
+%token <i> PARSEOP_DMATYPE_A
+%token <i> PARSEOP_DMATYPE_COMPATIBILITY
+%token <i> PARSEOP_DMATYPE_B
+%token <i> PARSEOP_DMATYPE_F
+%token <i> PARSEOP_DWORDCONST
+%token <i> PARSEOP_DWORDIO
+%token <i> PARSEOP_DWORDMEMORY
+%token <i> PARSEOP_DWORDSPACE
+%token <i> PARSEOP_EISAID
+%token <i> PARSEOP_ELSE
+%token <i> PARSEOP_ELSEIF
+%token <i> PARSEOP_ENDDEPENDENTFN
+%token <i> PARSEOP_ENDIAN_BIG
+%token <i> PARSEOP_ENDIAN_LITTLE
+%token <i> PARSEOP_ENDTAG
+%token <i> PARSEOP_ERRORNODE
+%token <i> PARSEOP_EVENT
+%token <i> PARSEOP_EXTENDEDIO
+%token <i> PARSEOP_EXTENDEDMEMORY
+%token <i> PARSEOP_EXTENDEDSPACE
+%token <i> PARSEOP_EXTERNAL
+%token <i> PARSEOP_FATAL
+%token <i> PARSEOP_FIELD
+%token <i> PARSEOP_FINDSETLEFTBIT
+%token <i> PARSEOP_FINDSETRIGHTBIT
+%token <i> PARSEOP_FIXEDDMA
+%token <i> PARSEOP_FIXEDIO
+%token <i> PARSEOP_FLOWCONTROL_HW
+%token <i> PARSEOP_FLOWCONTROL_NONE
+%token <i> PARSEOP_FLOWCONTROL_SW
+%token <i> PARSEOP_FROMBCD
+%token <i> PARSEOP_FUNCTION
+%token <i> PARSEOP_GPIO_INT
+%token <i> PARSEOP_GPIO_IO
+%token <i> PARSEOP_I2C_SERIALBUS
+%token <i> PARSEOP_I2C_SERIALBUS_V2
+%token <i> PARSEOP_IF
+%token <i> PARSEOP_INCLUDE
+%token <i> PARSEOP_INCLUDE_END
+%token <i> PARSEOP_INCREMENT
+%token <i> PARSEOP_INDEX
+%token <i> PARSEOP_INDEXFIELD
+%token <i> PARSEOP_INTEGER
+%token <i> PARSEOP_INTERRUPT
+%token <i> PARSEOP_INTLEVEL_ACTIVEBOTH
+%token <i> PARSEOP_INTLEVEL_ACTIVEHIGH
+%token <i> PARSEOP_INTLEVEL_ACTIVELOW
+%token <i> PARSEOP_INTTYPE_EDGE
+%token <i> PARSEOP_INTTYPE_LEVEL
+%token <i> PARSEOP_IO
+%token <i> PARSEOP_IODECODETYPE_10
+%token <i> PARSEOP_IODECODETYPE_16
+%token <i> PARSEOP_IORESTRICT_IN
+%token <i> PARSEOP_IORESTRICT_NONE
+%token <i> PARSEOP_IORESTRICT_OUT
+%token <i> PARSEOP_IORESTRICT_PRESERVE
+%token <i> PARSEOP_IRQ
+%token <i> PARSEOP_IRQNOFLAGS
+%token <i> PARSEOP_LAND
+%token <i> PARSEOP_LEQUAL
+%token <i> PARSEOP_LGREATER
+%token <i> PARSEOP_LGREATEREQUAL
+%token <i> PARSEOP_LLESS
+%token <i> PARSEOP_LLESSEQUAL
+%token <i> PARSEOP_LNOT
+%token <i> PARSEOP_LNOTEQUAL
+%token <i> PARSEOP_LOAD
+%token <i> PARSEOP_LOADTABLE
+%token <i> PARSEOP_LOCAL0
+%token <i> PARSEOP_LOCAL1
+%token <i> PARSEOP_LOCAL2
+%token <i> PARSEOP_LOCAL3
+%token <i> PARSEOP_LOCAL4
+%token <i> PARSEOP_LOCAL5
+%token <i> PARSEOP_LOCAL6
+%token <i> PARSEOP_LOCAL7
+%token <i> PARSEOP_LOCKRULE_LOCK
+%token <i> PARSEOP_LOCKRULE_NOLOCK
+%token <i> PARSEOP_LOR
+%token <i> PARSEOP_MATCH
+%token <i> PARSEOP_MATCHTYPE_MEQ
+%token <i> PARSEOP_MATCHTYPE_MGE
+%token <i> PARSEOP_MATCHTYPE_MGT
+%token <i> PARSEOP_MATCHTYPE_MLE
+%token <i> PARSEOP_MATCHTYPE_MLT
+%token <i> PARSEOP_MATCHTYPE_MTR
+%token <i> PARSEOP_MAXTYPE_FIXED
+%token <i> PARSEOP_MAXTYPE_NOTFIXED
+%token <i> PARSEOP_MEMORY24
+%token <i> PARSEOP_MEMORY32
+%token <i> PARSEOP_MEMORY32FIXED
+%token <i> PARSEOP_MEMTYPE_CACHEABLE
+%token <i> PARSEOP_MEMTYPE_NONCACHEABLE
+%token <i> PARSEOP_MEMTYPE_PREFETCHABLE
+%token <i> PARSEOP_MEMTYPE_WRITECOMBINING
+%token <i> PARSEOP_METHOD
+%token <i> PARSEOP_METHODCALL
+%token <i> PARSEOP_MID
+%token <i> PARSEOP_MINTYPE_FIXED
+%token <i> PARSEOP_MINTYPE_NOTFIXED
+%token <i> PARSEOP_MOD
+%token <i> PARSEOP_MULTIPLY
+%token <i> PARSEOP_MUTEX
+%token <i> PARSEOP_NAME
+%token <s> PARSEOP_NAMESEG
+%token <s> PARSEOP_NAMESTRING
+%token <i> PARSEOP_NAND
+%token <i> PARSEOP_NOOP
+%token <i> PARSEOP_NOR
+%token <i> PARSEOP_NOT
+%token <i> PARSEOP_NOTIFY
+%token <i> PARSEOP_OBJECTTYPE
+%token <i> PARSEOP_OBJECTTYPE_BFF
+%token <i> PARSEOP_OBJECTTYPE_BUF
+%token <i> PARSEOP_OBJECTTYPE_DDB
+%token <i> PARSEOP_OBJECTTYPE_DEV
+%token <i> PARSEOP_OBJECTTYPE_EVT
+%token <i> PARSEOP_OBJECTTYPE_FLD
+%token <i> PARSEOP_OBJECTTYPE_INT
+%token <i> PARSEOP_OBJECTTYPE_MTH
+%token <i> PARSEOP_OBJECTTYPE_MTX
+%token <i> PARSEOP_OBJECTTYPE_OPR
+%token <i> PARSEOP_OBJECTTYPE_PKG
+%token <i> PARSEOP_OBJECTTYPE_POW
+%token <i> PARSEOP_OBJECTTYPE_PRO
+%token <i> PARSEOP_OBJECTTYPE_STR
+%token <i> PARSEOP_OBJECTTYPE_THZ
+%token <i> PARSEOP_OBJECTTYPE_UNK
+%token <i> PARSEOP_OFFSET
+%token <i> PARSEOP_ONE
+%token <i> PARSEOP_ONES
+%token <i> PARSEOP_OPERATIONREGION
+%token <i> PARSEOP_OR
+%token <i> PARSEOP_PACKAGE
+%token <i> PARSEOP_PACKAGE_LENGTH
+%token <i> PARSEOP_PARITYTYPE_EVEN
+%token <i> PARSEOP_PARITYTYPE_MARK
+%token <i> PARSEOP_PARITYTYPE_NONE
+%token <i> PARSEOP_PARITYTYPE_ODD
+%token <i> PARSEOP_PARITYTYPE_SPACE
+%token <i> PARSEOP_PIN_NOPULL
+%token <i> PARSEOP_PIN_PULLDEFAULT
+%token <i> PARSEOP_PIN_PULLDOWN
+%token <i> PARSEOP_PIN_PULLUP
+%token <i> PARSEOP_POWERRESOURCE
+%token <i> PARSEOP_PROCESSOR
+%token <i> PARSEOP_QWORDCONST
+%token <i> PARSEOP_QWORDIO
+%token <i> PARSEOP_QWORDMEMORY
+%token <i> PARSEOP_QWORDSPACE
+%token <i> PARSEOP_RANGETYPE_ENTIRE
+%token <i> PARSEOP_RANGETYPE_ISAONLY
+%token <i> PARSEOP_RANGETYPE_NONISAONLY
+%token <i> PARSEOP_RAW_DATA
+%token <i> PARSEOP_READWRITETYPE_BOTH
+%token <i> PARSEOP_READWRITETYPE_READONLY
+%token <i> PARSEOP_REFOF
+%token <i> PARSEOP_REGIONSPACE_CMOS
+%token <i> PARSEOP_REGIONSPACE_EC
+%token <i> PARSEOP_REGIONSPACE_FFIXEDHW
+%token <i> PARSEOP_REGIONSPACE_GPIO
+%token <i> PARSEOP_REGIONSPACE_GSBUS
+%token <i> PARSEOP_REGIONSPACE_IO
+%token <i> PARSEOP_REGIONSPACE_IPMI
+%token <i> PARSEOP_REGIONSPACE_MEM
+%token <i> PARSEOP_REGIONSPACE_PCC
+%token <i> PARSEOP_REGIONSPACE_PCI
+%token <i> PARSEOP_REGIONSPACE_PCIBAR
+%token <i> PARSEOP_REGIONSPACE_SMBUS
+%token <i> PARSEOP_REGISTER
+%token <i> PARSEOP_RELEASE
+%token <i> PARSEOP_RESERVED_BYTES
+%token <i> PARSEOP_RESET
+%token <i> PARSEOP_RESOURCETEMPLATE
+%token <i> PARSEOP_RESOURCETYPE_CONSUMER
+%token <i> PARSEOP_RESOURCETYPE_PRODUCER
+%token <i> PARSEOP_RETURN
+%token <i> PARSEOP_REVISION
+%token <i> PARSEOP_SCOPE
+%token <i> PARSEOP_SERIALIZERULE_NOTSERIAL
+%token <i> PARSEOP_SERIALIZERULE_SERIAL
+%token <i> PARSEOP_SHARETYPE_EXCLUSIVE
+%token <i> PARSEOP_SHARETYPE_EXCLUSIVEWAKE
+%token <i> PARSEOP_SHARETYPE_SHARED
+%token <i> PARSEOP_SHARETYPE_SHAREDWAKE
+%token <i> PARSEOP_SHIFTLEFT
+%token <i> PARSEOP_SHIFTRIGHT
+%token <i> PARSEOP_SIGNAL
+%token <i> PARSEOP_SIZEOF
+%token <i> PARSEOP_SLAVEMODE_CONTROLLERINIT
+%token <i> PARSEOP_SLAVEMODE_DEVICEINIT
+%token <i> PARSEOP_SLEEP
+%token <i> PARSEOP_SPI_SERIALBUS
+%token <i> PARSEOP_SPI_SERIALBUS_V2
+%token <i> PARSEOP_STALL
+%token <i> PARSEOP_STARTDEPENDENTFN
+%token <i> PARSEOP_STARTDEPENDENTFN_NOPRI
+%token <i> PARSEOP_STOPBITS_ONE
+%token <i> PARSEOP_STOPBITS_ONEPLUSHALF
+%token <i> PARSEOP_STOPBITS_TWO
+%token <i> PARSEOP_STOPBITS_ZERO
+%token <i> PARSEOP_STORE
+%token <s> PARSEOP_STRING_LITERAL
+%token <i> PARSEOP_SUBTRACT
+%token <i> PARSEOP_SWITCH
+%token <i> PARSEOP_THERMALZONE
+%token <i> PARSEOP_TIMER
+%token <i> PARSEOP_TOBCD
+%token <i> PARSEOP_TOBUFFER
+%token <i> PARSEOP_TODECIMALSTRING
+%token <i> PARSEOP_TOHEXSTRING
+%token <i> PARSEOP_TOINTEGER
+%token <i> PARSEOP_TOSTRING
+%token <i> PARSEOP_TOUUID
+%token <i> PARSEOP_TRANSLATIONTYPE_DENSE
+%token <i> PARSEOP_TRANSLATIONTYPE_SPARSE
+%token <i> PARSEOP_TYPE_STATIC
+%token <i> PARSEOP_TYPE_TRANSLATION
+%token <i> PARSEOP_UART_SERIALBUS
+%token <i> PARSEOP_UART_SERIALBUS_V2
+%token <i> PARSEOP_UNICODE
+%token <i> PARSEOP_UNLOAD
+%token <i> PARSEOP_UPDATERULE_ONES
+%token <i> PARSEOP_UPDATERULE_PRESERVE
+%token <i> PARSEOP_UPDATERULE_ZEROS
+%token <i> PARSEOP_VAR_PACKAGE
+%token <i> PARSEOP_VENDORLONG
+%token <i> PARSEOP_VENDORSHORT
+%token <i> PARSEOP_WAIT
+%token <i> PARSEOP_WHILE
+%token <i> PARSEOP_WIREMODE_FOUR
+%token <i> PARSEOP_WIREMODE_THREE
+%token <i> PARSEOP_WORDBUSNUMBER
+%token <i> PARSEOP_WORDCONST
+%token <i> PARSEOP_WORDIO
+%token <i> PARSEOP_WORDSPACE
+%token <i> PARSEOP_XFERSIZE_8
+%token <i> PARSEOP_XFERSIZE_16
+%token <i> PARSEOP_XFERSIZE_32
+%token <i> PARSEOP_XFERSIZE_64
+%token <i> PARSEOP_XFERSIZE_128
+%token <i> PARSEOP_XFERSIZE_256
+%token <i> PARSEOP_XFERTYPE_8
+%token <i> PARSEOP_XFERTYPE_8_16
+%token <i> PARSEOP_XFERTYPE_16
+%token <i> PARSEOP_XOR
+%token <i> PARSEOP_ZERO
+
+/* ToPld macro */
+
+%token <i> PARSEOP_TOPLD
+%token <i> PARSEOP_PLD_REVISION
+%token <i> PARSEOP_PLD_IGNORECOLOR
+%token <i> PARSEOP_PLD_RED
+%token <i> PARSEOP_PLD_GREEN
+%token <i> PARSEOP_PLD_BLUE
+%token <i> PARSEOP_PLD_WIDTH
+%token <i> PARSEOP_PLD_HEIGHT
+%token <i> PARSEOP_PLD_USERVISIBLE
+%token <i> PARSEOP_PLD_DOCK
+%token <i> PARSEOP_PLD_LID
+%token <i> PARSEOP_PLD_PANEL
+%token <i> PARSEOP_PLD_VERTICALPOSITION
+%token <i> PARSEOP_PLD_HORIZONTALPOSITION
+%token <i> PARSEOP_PLD_SHAPE
+%token <i> PARSEOP_PLD_GROUPORIENTATION
+%token <i> PARSEOP_PLD_GROUPTOKEN
+%token <i> PARSEOP_PLD_GROUPPOSITION
+%token <i> PARSEOP_PLD_BAY
+%token <i> PARSEOP_PLD_EJECTABLE
+%token <i> PARSEOP_PLD_EJECTREQUIRED
+%token <i> PARSEOP_PLD_CABINETNUMBER
+%token <i> PARSEOP_PLD_CARDCAGENUMBER
+%token <i> PARSEOP_PLD_REFERENCE
+%token <i> PARSEOP_PLD_ROTATION
+%token <i> PARSEOP_PLD_ORDER
+%token <i> PARSEOP_PLD_RESERVED
+%token <i> PARSEOP_PLD_VERTICALOFFSET
+%token <i> PARSEOP_PLD_HORIZONTALOFFSET
+
+/*
+ * C-style expression parser. These must appear after all of the
+ * standard ASL operators and keywords.
+ *
+ * Note: The order of these tokens implements the precedence rules
+ * (low precedence to high). See aslrules.y for an exhaustive list.
+ */
+%right <i> PARSEOP_EXP_EQUALS
+           PARSEOP_EXP_ADD_EQ
+           PARSEOP_EXP_SUB_EQ
+           PARSEOP_EXP_MUL_EQ
+           PARSEOP_EXP_DIV_EQ
+           PARSEOP_EXP_MOD_EQ
+           PARSEOP_EXP_SHL_EQ
+           PARSEOP_EXP_SHR_EQ
+           PARSEOP_EXP_AND_EQ
+           PARSEOP_EXP_XOR_EQ
+           PARSEOP_EXP_OR_EQ
+
+%left <i>  PARSEOP_EXP_LOGICAL_OR
+%left <i>  PARSEOP_EXP_LOGICAL_AND
+%left <i>  PARSEOP_EXP_OR
+%left <i>  PARSEOP_EXP_XOR
+%left <i>  PARSEOP_EXP_AND
+%left <i>  PARSEOP_EXP_EQUAL
+           PARSEOP_EXP_NOT_EQUAL
+%left <i>  PARSEOP_EXP_GREATER
+           PARSEOP_EXP_LESS
+           PARSEOP_EXP_GREATER_EQUAL
+           PARSEOP_EXP_LESS_EQUAL
+%left <i>  PARSEOP_EXP_SHIFT_RIGHT
+           PARSEOP_EXP_SHIFT_LEFT
+%left <i>  PARSEOP_EXP_ADD
+           PARSEOP_EXP_SUBTRACT
+%left <i>  PARSEOP_EXP_MULTIPLY
+           PARSEOP_EXP_DIVIDE
+           PARSEOP_EXP_MODULO
+
+%right <i> PARSEOP_EXP_NOT
+           PARSEOP_EXP_LOGICAL_NOT
+
+%left <i>  PARSEOP_EXP_INCREMENT
+           PARSEOP_EXP_DECREMENT
+
+/* Brackets for Index() support */
+
+%left <i>  PARSEOP_EXP_INDEX_LEFT
+%right <i> PARSEOP_EXP_INDEX_RIGHT
+
+/* Macros */
+
+%token <i> PARSEOP_PRINTF
+%token <i> PARSEOP_FPRINTF
+%token <i> PARSEOP_FOR
+
+/* Specific parentheses tokens are not used at this time */
+           /* PARSEOP_EXP_PAREN_OPEN */
+           /* PARSEOP_EXP_PAREN_CLOSE */
+
+
+%token <i> PARSEOP_ASL_CODE
+
+/*
+ * Special functions. These should probably stay at the end of this
+ * table.
+ */
+%token <i> PARSEOP___DATE__
+%token <i> PARSEOP___FILE__
+%token <i> PARSEOP___LINE__
+%token <i> PARSEOP___PATH__
diff --git a/usr/src/cmd/acpi/iasl/asltransform.c b/usr/src/cmd/acpi/iasl/asltransform.c
new file mode 100644
index 0000000000..e504220839
--- /dev/null
+++ b/usr/src/cmd/acpi/iasl/asltransform.c
@@ -0,0 +1,822 @@
+/******************************************************************************
+ *
+ * Module Name: asltransform - Parse tree transforms
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2016, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include "aslcompiler.h"
+#include "aslcompiler.y.h"
+
+#define _COMPONENT          ACPI_COMPILER
+        ACPI_MODULE_NAME    ("asltransform")
+
+/* Local prototypes */
+
+static void
+TrTransformSubtree (
+    ACPI_PARSE_OBJECT       *Op);
+
+static char *
+TrAmlGetNextTempName (
+    ACPI_PARSE_OBJECT       *Op,
+    UINT8                   *TempCount);
+
+static void
+TrAmlInitLineNumbers (
+    ACPI_PARSE_OBJECT       *Op,
+    ACPI_PARSE_OBJECT       *Neighbor);
+
+static void
+TrAmlInitNode (
+    ACPI_PARSE_OBJECT       *Op,
+    UINT16                  ParseOpcode);
+
+static void
+TrAmlSetSubtreeParent (
+    ACPI_PARSE_OBJECT       *Op,
+    ACPI_PARSE_OBJECT       *Parent);
+
+static void
+TrAmlInsertPeer (
+    ACPI_PARSE_OBJECT       *Op,
+    ACPI_PARSE_OBJECT       *NewPeer);
+
+static void
+TrDoDefinitionBlock (
+    ACPI_PARSE_OBJECT       *Op);
+
+static void
+TrDoSwitch (
+    ACPI_PARSE_OBJECT       *StartNode);
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    TrAmlGetNextTempName
+ *
+ * PARAMETERS:  Op              - Current parse op
+ *              TempCount       - Current temporary counter. Was originally
+ *                                per-module; Currently per method, could be
+ *                                expanded to per-scope.
+ *
+ * RETURN:      A pointer to name (allocated here).
+ *
+ * DESCRIPTION: Generate an ACPI name of the form _T_x. These names are
+ *              reserved for use by the ASL compiler. (_T_0 through _T_Z)
+ *
+ ******************************************************************************/
+
+static char *
+TrAmlGetNextTempName (
+    ACPI_PARSE_OBJECT       *Op,
+    UINT8                   *TempCount)
+{
+    char                    *TempName;
+
+
+    if (*TempCount >= (10 + 26))  /* 0-35 valid: 0-9 and A-Z for TempName[3] */
+    {
+        /* Too many temps */
+
+        AslError (ASL_ERROR, ASL_MSG_TOO_MANY_TEMPS, Op, NULL);
+        return (NULL);
+    }
+
+    TempName = UtLocalCalloc (5);
+
+    if (*TempCount < 10)    /* 0-9 */
+    {
+        TempName[3] = (char) (*TempCount + '0');
+    }
+    else                    /* 10-35: A-Z */
+    {
+        TempName[3] = (char) (*TempCount + ('A' - 10));
+    }
+
+    (*TempCount)++;
+
+    /* First three characters are always "_T_" */
+
+    TempName[0] = '_';
+    TempName[1] = 'T';
+    TempName[2] = '_';
+
+    return (TempName);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    TrAmlInitLineNumbers
+ *
+ * PARAMETERS:  Op              - Op to be initialized
+ *              Neighbor        - Op used for initialization values
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Initialized the various line numbers for a parse node.
+ *
+ ******************************************************************************/
+
+static void
+TrAmlInitLineNumbers (
+    ACPI_PARSE_OBJECT       *Op,
+    ACPI_PARSE_OBJECT       *Neighbor)
+{
+
+    Op->Asl.EndLine           = Neighbor->Asl.EndLine;
+    Op->Asl.EndLogicalLine    = Neighbor->Asl.EndLogicalLine;
+    Op->Asl.LineNumber        = Neighbor->Asl.LineNumber;
+    Op->Asl.LogicalByteOffset = Neighbor->Asl.LogicalByteOffset;
+    Op->Asl.LogicalLineNumber = Neighbor->Asl.LogicalLineNumber;
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    TrAmlInitNode
+ *
+ * PARAMETERS:  Op              - Op to be initialized
+ *              ParseOpcode     - Opcode for this node
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Initialize a node with the parse opcode and opcode name.
+ *
+ ******************************************************************************/
+
+static void
+TrAmlInitNode (
+    ACPI_PARSE_OBJECT       *Op,
+    UINT16                  ParseOpcode)
+{
+
+    Op->Asl.ParseOpcode = ParseOpcode;
+    UtSetParseOpName (Op);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    TrAmlSetSubtreeParent
+ *
+ * PARAMETERS:  Op              - First node in a list of peer nodes
+ *              Parent          - Parent of the subtree
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Set the parent for all peer nodes in a subtree
+ *
+ ******************************************************************************/
+
+static void
+TrAmlSetSubtreeParent (
+    ACPI_PARSE_OBJECT       *Op,
+    ACPI_PARSE_OBJECT       *Parent)
+{
+    ACPI_PARSE_OBJECT       *Next;
+
+
+    Next = Op;
+    while (Next)
+    {
+        Next->Asl.Parent = Parent;
+        Next = Next->Asl.Next;
+    }
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    TrAmlInsertPeer
+ *
+ * PARAMETERS:  Op              - First node in a list of peer nodes
+ *              NewPeer         - Peer node to insert
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Insert a new peer node into a list of peers.
+ *
+ ******************************************************************************/
+
+static void
+TrAmlInsertPeer (
+    ACPI_PARSE_OBJECT       *Op,
+    ACPI_PARSE_OBJECT       *NewPeer)
+{
+
+    NewPeer->Asl.Next = Op->Asl.Next;
+    Op->Asl.Next = NewPeer;
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    TrAmlTransformWalkBegin
+ *
+ * PARAMETERS:  ASL_WALK_CALLBACK
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Parse tree walk to generate both the AML opcodes and the AML
+ *              operands.
+ *
+ ******************************************************************************/
+
+ACPI_STATUS
+TrAmlTransformWalkBegin (
+    ACPI_PARSE_OBJECT       *Op,
+    UINT32                  Level,
+    void                    *Context)
+{
+
+    TrTransformSubtree (Op);
+    return (AE_OK);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    TrAmlTransformWalkEnd
+ *
+ * PARAMETERS:  ASL_WALK_CALLBACK
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Parse tree walk to generate both the AML opcodes and the AML
+ *              operands.
+ *
+ ******************************************************************************/
+
+ACPI_STATUS
+TrAmlTransformWalkEnd (
+    ACPI_PARSE_OBJECT       *Op,
+    UINT32                  Level,
+    void                    *Context)
+{
+
+    /* Save possible Externals list in the DefintionBlock Op */
+
+    if (Op->Asl.ParseOpcode == PARSEOP_DEFINITION_BLOCK)
+    {
+        Op->Asl.Value.Arg = Gbl_ExternalsListHead;
+        Gbl_ExternalsListHead = NULL;
+    }
+
+    return (AE_OK);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    TrTransformSubtree
+ *
+ * PARAMETERS:  Op        - The parent parse node
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Prepare nodes to be output as AML data and operands. The more
+ *              complex AML opcodes require processing of the child nodes
+ *              (arguments/operands).
+ *
+ ******************************************************************************/
+
+static void
+TrTransformSubtree (
+    ACPI_PARSE_OBJECT           *Op)
+{
+
+    if (Op->Asl.AmlOpcode == AML_RAW_DATA_BYTE)
+    {
+        return;
+    }
+
+    switch (Op->Asl.ParseOpcode)
+    {
+    case PARSEOP_DEFINITION_BLOCK:
+
+        TrDoDefinitionBlock (Op);
+        break;
+
+    case PARSEOP_SWITCH:
+
+        TrDoSwitch (Op);
+        break;
+
+    case PARSEOP_METHOD:
+        /*
+         * TBD: Zero the tempname (_T_x) count. Probably shouldn't be a global,
+         * however
+         */
+        Gbl_TempCount = 0;
+        break;
+
+    case PARSEOP_EXTERNAL:
+
+        if (Gbl_DoExternals == TRUE)
+        {
+            ExDoExternal (Op);
+        }
+
+        break;
+
+    default:
+
+        /* Nothing to do here for other opcodes */
+
+        break;
+    }
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    TrDoDefinitionBlock
+ *
+ * PARAMETERS:  Op        - Parse node
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Find the end of the definition block and set a global to this
+ *              node. It is used by the compiler to insert compiler-generated
+ *              names at the root level of the namespace.
+ *
+ ******************************************************************************/
+
+static void
+TrDoDefinitionBlock (
+    ACPI_PARSE_OBJECT       *Op)
+{
+    ACPI_PARSE_OBJECT       *Next;
+    UINT32                  i;
+
+
+    /* Reset external list when starting a definition block */
+
+    Gbl_ExternalsListHead = NULL;
+
+    Next = Op->Asl.Child;
+    for (i = 0; i < 5; i++)
+    {
+        Next = Next->Asl.Next;
+        if (i == 0)
+        {
+            /*
+             * This is the table signature. Only the DSDT can be assumed
+             * to be at the root of the namespace;  Therefore, namepath
+             * optimization can only be performed on the DSDT.
+             */
+            if (!ACPI_COMPARE_NAME (Next->Asl.Value.String, ACPI_SIG_DSDT))
+            {
+                Gbl_ReferenceOptimizationFlag = FALSE;
+            }
+        }
+    }
+
+    Gbl_FirstLevelInsertionNode = Next;
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    TrDoSwitch
+ *
+ * PARAMETERS:  StartNode        - Parse node for SWITCH
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Translate ASL SWITCH statement to if/else pairs. There is
+ *              no actual AML opcode for SWITCH -- it must be simulated.
+ *
+ ******************************************************************************/
+
+static void
+TrDoSwitch (
+    ACPI_PARSE_OBJECT       *StartNode)
+{
+    ACPI_PARSE_OBJECT       *Next;
+    ACPI_PARSE_OBJECT       *CaseOp = NULL;
+    ACPI_PARSE_OBJECT       *CaseBlock = NULL;
+    ACPI_PARSE_OBJECT       *DefaultOp = NULL;
+    ACPI_PARSE_OBJECT       *CurrentParentNode;
+    ACPI_PARSE_OBJECT       *Conditional = NULL;
+    ACPI_PARSE_OBJECT       *Predicate;
+    ACPI_PARSE_OBJECT       *Peer;
+    ACPI_PARSE_OBJECT       *NewOp;
+    ACPI_PARSE_OBJECT       *NewOp2;
+    ACPI_PARSE_OBJECT       *MethodOp;
+    ACPI_PARSE_OBJECT       *StoreOp;
+    ACPI_PARSE_OBJECT       *BreakOp;
+    ACPI_PARSE_OBJECT       *BufferOp;
+    char                    *PredicateValueName;
+    UINT16                  Index;
+    UINT32                  Btype;
+
+
+    /* Start node is the Switch() node */
+
+    CurrentParentNode  = StartNode;
+
+    /* Create a new temp name of the form _T_x */
+
+    PredicateValueName = TrAmlGetNextTempName (StartNode, &Gbl_TempCount);
+    if (!PredicateValueName)
+    {
+        return;
+    }
+
+    /* First child is the Switch() predicate */
+
+    Next = StartNode->Asl.Child;
+
+    /*
+     * Examine the return type of the Switch Value -
+     * must be Integer/Buffer/String
+     */
+    Index = (UINT16) (Next->Asl.ParseOpcode - ASL_PARSE_OPCODE_BASE);
+    Btype = AslKeywordMapping[Index].AcpiBtype;
+    if ((Btype != ACPI_BTYPE_INTEGER) &&
+        (Btype != ACPI_BTYPE_STRING)  &&
+        (Btype != ACPI_BTYPE_BUFFER))
+    {
+        AslError (ASL_WARNING, ASL_MSG_SWITCH_TYPE, Next, NULL);
+        Btype = ACPI_BTYPE_INTEGER;
+    }
+
+    /* CASE statements start at next child */
+
+    Peer = Next->Asl.Next;
+    while (Peer)
+    {
+        Next = Peer;
+        Peer = Next->Asl.Next;
+
+        if (Next->Asl.ParseOpcode == PARSEOP_CASE)
+        {
+            if (CaseOp)
+            {
+                /* Add an ELSE to complete the previous CASE */
+
+                NewOp = TrCreateLeafNode (PARSEOP_ELSE);
+                NewOp->Asl.Parent = Conditional->Asl.Parent;
+                TrAmlInitLineNumbers (NewOp, NewOp->Asl.Parent);
+
+                /* Link ELSE node as a peer to the previous IF */
+
+                TrAmlInsertPeer (Conditional, NewOp);
+                CurrentParentNode = NewOp;
+            }
+
+            CaseOp = Next;
+            Conditional = CaseOp;
+            CaseBlock = CaseOp->Asl.Child->Asl.Next;
+            Conditional->Asl.Child->Asl.Next = NULL;
+            Predicate = CaseOp->Asl.Child;
+
+            if ((Predicate->Asl.ParseOpcode == PARSEOP_PACKAGE) ||
+                (Predicate->Asl.ParseOpcode == PARSEOP_VAR_PACKAGE))
+            {
+                /*
+                 * Convert the package declaration to this form:
+                 *
+                 * If (LNotEqual (Match (Package(<size>){<data>},
+                 *                       MEQ, _T_x, MTR, Zero, Zero), Ones))
+                 */
+                NewOp2              = TrCreateLeafNode (PARSEOP_MATCHTYPE_MEQ);
+                Predicate->Asl.Next = NewOp2;
+                TrAmlInitLineNumbers (NewOp2, Conditional);
+
+                NewOp               = NewOp2;
+                NewOp2              = TrCreateValuedLeafNode (PARSEOP_NAMESTRING,
+                                        (UINT64) ACPI_TO_INTEGER (PredicateValueName));
+                NewOp->Asl.Next     = NewOp2;
+                TrAmlInitLineNumbers (NewOp2, Predicate);
+
+                NewOp               = NewOp2;
+                NewOp2              = TrCreateLeafNode (PARSEOP_MATCHTYPE_MTR);
+                NewOp->Asl.Next     = NewOp2;
+                TrAmlInitLineNumbers (NewOp2, Predicate);
+
+                NewOp               = NewOp2;
+                NewOp2              = TrCreateLeafNode (PARSEOP_ZERO);
+                NewOp->Asl.Next     = NewOp2;
+                TrAmlInitLineNumbers (NewOp2, Predicate);
+
+                NewOp               = NewOp2;
+                NewOp2              = TrCreateLeafNode (PARSEOP_ZERO);
+                NewOp->Asl.Next     = NewOp2;
+                TrAmlInitLineNumbers (NewOp2, Predicate);
+
+                NewOp2              = TrCreateLeafNode (PARSEOP_MATCH);
+                NewOp2->Asl.Child   = Predicate;  /* PARSEOP_PACKAGE */
+                TrAmlInitLineNumbers (NewOp2, Conditional);
+                TrAmlSetSubtreeParent (Predicate, NewOp2);
+
+                NewOp               = NewOp2;
+                NewOp2              = TrCreateLeafNode (PARSEOP_ONES);
+                NewOp->Asl.Next     = NewOp2;
+                TrAmlInitLineNumbers (NewOp2, Conditional);
+
+                NewOp2              = TrCreateLeafNode (PARSEOP_LEQUAL);
+                NewOp2->Asl.Child   = NewOp;
+                NewOp->Asl.Parent   = NewOp2;
+                TrAmlInitLineNumbers (NewOp2, Conditional);
+                TrAmlSetSubtreeParent (NewOp, NewOp2);
+
+                NewOp               = NewOp2;
+                NewOp2              = TrCreateLeafNode (PARSEOP_LNOT);
+                NewOp2->Asl.Child   = NewOp;
+                NewOp2->Asl.Parent  = Conditional;
+                NewOp->Asl.Parent   = NewOp2;
+                TrAmlInitLineNumbers (NewOp2, Conditional);
+
+                Conditional->Asl.Child = NewOp2;
+                NewOp2->Asl.Next = CaseBlock;
+            }
+            else
+            {
+                /*
+                 * Integer and Buffer case.
+                 *
+                 * Change CaseOp() to:  If (LEqual (SwitchValue, CaseValue)) {...}
+                 * Note: SwitchValue is first to allow the CaseValue to be implicitly
+                 * converted to the type of SwitchValue if necessary.
+                 *
+                 * CaseOp->Child is the case value
+                 * CaseOp->Child->Peer is the beginning of the case block
+                 */
+                NewOp = TrCreateValuedLeafNode (PARSEOP_NAMESTRING,
+                    (UINT64) ACPI_TO_INTEGER (PredicateValueName));
+                NewOp->Asl.Next = Predicate;
+                TrAmlInitLineNumbers (NewOp, Predicate);
+
+                NewOp2              = TrCreateLeafNode (PARSEOP_LEQUAL);
+                NewOp2->Asl.Parent  = Conditional;
+                NewOp2->Asl.Child   = NewOp;
+                TrAmlInitLineNumbers (NewOp2, Conditional);
+
+                TrAmlSetSubtreeParent (NewOp, NewOp2);
+
+                Predicate           = NewOp2;
+                Predicate->Asl.Next = CaseBlock;
+
+                TrAmlSetSubtreeParent (Predicate, Conditional);
+                Conditional->Asl.Child = Predicate;
+            }
+
+            /* Reinitialize the CASE node to an IF node */
+
+            TrAmlInitNode (Conditional, PARSEOP_IF);
+
+            /*
+             * The first CASE(IF) is not nested under an ELSE.
+             * All other CASEs are children of a parent ELSE.
+             */
+            if (CurrentParentNode == StartNode)
+            {
+                Conditional->Asl.Next = NULL;
+            }
+            else
+            {
+                /*
+                 * The IF is a child of previous IF/ELSE. It
+                 * is therefore without peer.
+                 */
+                CurrentParentNode->Asl.Child = Conditional;
+                Conditional->Asl.Parent      = CurrentParentNode;
+                Conditional->Asl.Next        = NULL;
+            }
+        }
+        else if (Next->Asl.ParseOpcode == PARSEOP_DEFAULT)
+        {
+            if (DefaultOp)
+            {
+                /*
+                 * More than one Default
+                 * (Parser does not catch this, must check here)
+                 */
+                AslError (ASL_ERROR, ASL_MSG_MULTIPLE_DEFAULT, Next, NULL);
+            }
+            else
+            {
+                /* Save the DEFAULT node for later, after CASEs */
+
+                DefaultOp = Next;
+            }
+        }
+        else
+        {
+            /* Unknown peer opcode */
+
+            AcpiOsPrintf ("Unknown parse opcode for switch statement: %s (%u)\n",
+                Next->Asl.ParseOpName, Next->Asl.ParseOpcode);
+        }
+    }
+
+    /* Add the default case at the end of the if/else construct */
+
+    if (DefaultOp)
+    {
+        /* If no CASE statements, this is an error - see below */
+
+        if (CaseOp)
+        {
+            /* Convert the DEFAULT node to an ELSE */
+
+            TrAmlInitNode (DefaultOp, PARSEOP_ELSE);
+            DefaultOp->Asl.Parent = Conditional->Asl.Parent;
+
+            /* Link ELSE node as a peer to the previous IF */
+
+            TrAmlInsertPeer (Conditional, DefaultOp);
+        }
+    }
+
+    if (!CaseOp)
+    {
+        AslError (ASL_ERROR, ASL_MSG_NO_CASES, StartNode, NULL);
+    }
+
+
+    /*
+     * Create a Name(_T_x, ...) statement. This statement must appear at the
+     * method level, in case a loop surrounds the switch statement and could
+     * cause the name to be created twice (error).
+     */
+
+    /* Create the Name node */
+
+    Predicate = StartNode->Asl.Child;
+    NewOp = TrCreateLeafNode (PARSEOP_NAME);
+    TrAmlInitLineNumbers (NewOp, StartNode);
+
+    /* Find the parent method */
+
+    Next = StartNode;
+    while ((Next->Asl.ParseOpcode != PARSEOP_METHOD) &&
+           (Next->Asl.ParseOpcode != PARSEOP_DEFINITION_BLOCK))
+    {
+        Next = Next->Asl.Parent;
+    }
+    MethodOp = Next;
+
+    NewOp->Asl.CompileFlags |= NODE_COMPILER_EMITTED;
+    NewOp->Asl.Parent = Next;
+
+    /* Insert name after the method name and arguments */
+
+    Next = Next->Asl.Child; /* Name */
+    Next = Next->Asl.Next;  /* NumArgs */
+    Next = Next->Asl.Next;  /* SerializeRule */
+
+    /*
+     * If method is not Serialized, we must make is so, because of the way
+     * that Switch() must be implemented -- we cannot allow multiple threads
+     * to execute this method concurrently since we need to create local
+     * temporary name(s).
+     */
+    if (Next->Asl.ParseOpcode != PARSEOP_SERIALIZERULE_SERIAL)
+    {
+        AslError (ASL_REMARK, ASL_MSG_SERIALIZED, MethodOp,
+            "Due to use of Switch operator");
+        Next->Asl.ParseOpcode = PARSEOP_SERIALIZERULE_SERIAL;
+    }
+
+    Next = Next->Asl.Next;  /* SyncLevel */
+    Next = Next->Asl.Next;  /* ReturnType */
+    Next = Next->Asl.Next;  /* ParameterTypes */
+
+    TrAmlInsertPeer (Next, NewOp);
+    TrAmlInitLineNumbers (NewOp, Next);
+
+    /* Create the NameSeg child for the Name node */
+
+    NewOp2 = TrCreateValuedLeafNode (PARSEOP_NAMESEG,
+        (UINT64) ACPI_TO_INTEGER (PredicateValueName));
+    TrAmlInitLineNumbers (NewOp2, NewOp);
+    NewOp2->Asl.CompileFlags |= NODE_IS_NAME_DECLARATION;
+    NewOp->Asl.Child  = NewOp2;
+
+    /* Create the initial value for the Name. Btype was already validated above */
+
+    switch (Btype)
+    {
+    case ACPI_BTYPE_INTEGER:
+
+        NewOp2->Asl.Next = TrCreateValuedLeafNode (PARSEOP_ZERO,
+            (UINT64) 0);
+        TrAmlInitLineNumbers (NewOp2->Asl.Next, NewOp);
+        break;
+
+    case ACPI_BTYPE_STRING:
+
+        NewOp2->Asl.Next = TrCreateValuedLeafNode (PARSEOP_STRING_LITERAL,
+            (UINT64) ACPI_TO_INTEGER (""));
+        TrAmlInitLineNumbers (NewOp2->Asl.Next, NewOp);
+        break;
+
+    case ACPI_BTYPE_BUFFER:
+
+        (void) TrLinkPeerNode (NewOp2, TrCreateValuedLeafNode (PARSEOP_BUFFER,
+            (UINT64) 0));
+        Next = NewOp2->Asl.Next;
+        TrAmlInitLineNumbers (Next, NewOp2);
+        (void) TrLinkChildren (Next, 1, TrCreateValuedLeafNode (PARSEOP_ZERO,
+            (UINT64) 1));
+        TrAmlInitLineNumbers (Next->Asl.Child, Next);
+
+        BufferOp = TrCreateValuedLeafNode (PARSEOP_DEFAULT_ARG, (UINT64) 0);
+        TrAmlInitLineNumbers (BufferOp, Next->Asl.Child);
+        (void) TrLinkPeerNode (Next->Asl.Child, BufferOp);
+
+        TrAmlSetSubtreeParent (Next->Asl.Child, Next);
+        break;
+
+    default:
+
+        break;
+    }
+
+    TrAmlSetSubtreeParent (NewOp2, NewOp);
+
+    /*
+     * Transform the Switch() into a While(One)-Break node.
+     * And create a Store() node which will be used to save the
+     * Switch() value. The store is of the form: Store (Value, _T_x)
+     * where _T_x is the temp variable.
+     */
+    TrAmlInitNode (StartNode, PARSEOP_WHILE);
+    NewOp = TrCreateLeafNode (PARSEOP_ONE);
+    TrAmlInitLineNumbers (NewOp, StartNode);
+    NewOp->Asl.Next = Predicate->Asl.Next;
+    NewOp->Asl.Parent = StartNode;
+    StartNode->Asl.Child = NewOp;
+
+    /* Create a Store() node */
+
+    StoreOp = TrCreateLeafNode (PARSEOP_STORE);
+    TrAmlInitLineNumbers (StoreOp, NewOp);
+    StoreOp->Asl.Parent = StartNode;
+    TrAmlInsertPeer (NewOp, StoreOp);
+
+    /* Complete the Store subtree */
+
+    StoreOp->Asl.Child = Predicate;
+    Predicate->Asl.Parent = StoreOp;
+
+    NewOp = TrCreateValuedLeafNode (PARSEOP_NAMESEG,
+        (UINT64) ACPI_TO_INTEGER (PredicateValueName));
+    TrAmlInitLineNumbers (NewOp, StoreOp);
+    NewOp->Asl.Parent    = StoreOp;
+    Predicate->Asl.Next  = NewOp;
+
+    /* Create a Break() node and insert it into the end of While() */
+
+    Conditional = StartNode->Asl.Child;
+    while (Conditional->Asl.Next)
+    {
+        Conditional = Conditional->Asl.Next;
+    }
+
+    BreakOp = TrCreateLeafNode (PARSEOP_BREAK);
+    TrAmlInitLineNumbers (BreakOp, NewOp);
+    BreakOp->Asl.Parent = StartNode;
+    TrAmlInsertPeer (Conditional, BreakOp);
+}
diff --git a/usr/src/cmd/acpi/iasl/asltree.c b/usr/src/cmd/acpi/iasl/asltree.c
new file mode 100644
index 0000000000..af67467ef0
--- /dev/null
+++ b/usr/src/cmd/acpi/iasl/asltree.c
@@ -0,0 +1,1635 @@
+/******************************************************************************
+ *
+ * Module Name: asltree - parse tree management
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2016, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include "aslcompiler.h"
+#include "aslcompiler.y.h"
+#include "acapps.h"
+#include <time.h>
+
+#define _COMPONENT          ACPI_COMPILER
+        ACPI_MODULE_NAME    ("asltree")
+
+/* Local prototypes */
+
+static ACPI_PARSE_OBJECT *
+TrGetNextNode (
+    void);
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    TrSetParent
+ *
+ * PARAMETERS:  Op                  - To be set to new parent
+ *              ParentOp            - The parent
+ *
+ * RETURN:      None, sets Op parent directly
+ *
+ * DESCRIPTION: Change the parent of a parse op.
+ *
+ ******************************************************************************/
+
+void
+TrSetParent (
+    ACPI_PARSE_OBJECT       *Op,
+    ACPI_PARSE_OBJECT       *ParentOp)
+{
+
+    Op->Asl.Parent = ParentOp;
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    TrGetNextNode
+ *
+ * PARAMETERS:  None
+ *
+ * RETURN:      New parse node. Aborts on allocation failure
+ *
+ * DESCRIPTION: Allocate a new parse node for the parse tree. Bypass the local
+ *              dynamic memory manager for performance reasons (This has a
+ *              major impact on the speed of the compiler.)
+ *
+ ******************************************************************************/
+
+static ACPI_PARSE_OBJECT *
+TrGetNextNode (
+    void)
+{
+    ASL_CACHE_INFO          *Cache;
+
+
+    if (Gbl_ParseOpCacheNext >= Gbl_ParseOpCacheLast)
+    {
+        /* Allocate a new buffer */
+
+        Cache = UtLocalCalloc (sizeof (Cache->Next) +
+            (sizeof (ACPI_PARSE_OBJECT) * ASL_PARSEOP_CACHE_SIZE));
+
+        /* Link new cache buffer to head of list */
+
+        Cache->Next = Gbl_ParseOpCacheList;
+        Gbl_ParseOpCacheList = Cache;
+
+        /* Setup cache management pointers */
+
+        Gbl_ParseOpCacheNext = ACPI_CAST_PTR (ACPI_PARSE_OBJECT, Cache->Buffer);
+        Gbl_ParseOpCacheLast = Gbl_ParseOpCacheNext + ASL_PARSEOP_CACHE_SIZE;
+    }
+
+    Gbl_ParseOpCount++;
+    return (Gbl_ParseOpCacheNext++);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    TrAllocateNode
+ *
+ * PARAMETERS:  ParseOpcode         - Opcode to be assigned to the node
+ *
+ * RETURN:      New parse node. Aborts on allocation failure
+ *
+ * DESCRIPTION: Allocate and initialize a new parse node for the parse tree
+ *
+ ******************************************************************************/
+
+ACPI_PARSE_OBJECT *
+TrAllocateNode (
+    UINT32                  ParseOpcode)
+{
+    ACPI_PARSE_OBJECT       *Op;
+
+
+    Op = TrGetNextNode ();
+
+    Op->Asl.ParseOpcode       = (UINT16) ParseOpcode;
+    Op->Asl.Filename          = Gbl_Files[ASL_FILE_INPUT].Filename;
+    Op->Asl.LineNumber        = Gbl_CurrentLineNumber;
+    Op->Asl.LogicalLineNumber = Gbl_LogicalLineNumber;
+    Op->Asl.LogicalByteOffset = Gbl_CurrentLineOffset;
+    Op->Asl.Column            = Gbl_CurrentColumn;
+
+    UtSetParseOpName (Op);
+    return (Op);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    TrReleaseNode
+ *
+ * PARAMETERS:  Op            - Op to be released
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: "release" a node. In truth, nothing is done since the node
+ *              is part of a larger buffer
+ *
+ ******************************************************************************/
+
+void
+TrReleaseNode (
+    ACPI_PARSE_OBJECT       *Op)
+{
+
+    return;
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    TrSetCurrentFilename
+ *
+ * PARAMETERS:  Op                  - An existing parse node
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Save the include file filename. Used for debug output only.
+ *
+ ******************************************************************************/
+
+void
+TrSetCurrentFilename (
+    ACPI_PARSE_OBJECT       *Op)
+{
+    Op->Asl.Filename = Gbl_PreviousIncludeFilename;
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    TrUpdateNode
+ *
+ * PARAMETERS:  ParseOpcode         - New opcode to be assigned to the node
+ *              Op                  - An existing parse node
+ *
+ * RETURN:      The updated node
+ *
+ * DESCRIPTION: Change the parse opcode assigned to a node. Usually used to
+ *              change an opcode to DEFAULT_ARG so that the node is ignored
+ *              during the code generation. Also used to set generic integers
+ *              to a specific size (8, 16, 32, or 64 bits)
+ *
+ ******************************************************************************/
+
+ACPI_PARSE_OBJECT *
+TrUpdateNode (
+    UINT32                  ParseOpcode,
+    ACPI_PARSE_OBJECT       *Op)
+{
+
+    if (!Op)
+    {
+        return (NULL);
+    }
+
+    DbgPrint (ASL_PARSE_OUTPUT,
+        "\nUpdateNode: Old - %s, New - %s\n",
+        UtGetOpName (Op->Asl.ParseOpcode),
+        UtGetOpName (ParseOpcode));
+
+    /* Assign new opcode and name */
+
+    if (Op->Asl.ParseOpcode == PARSEOP_ONES)
+    {
+        switch (ParseOpcode)
+        {
+        case PARSEOP_BYTECONST:
+
+            Op->Asl.Value.Integer = ACPI_UINT8_MAX;
+            break;
+
+        case PARSEOP_WORDCONST:
+
+            Op->Asl.Value.Integer = ACPI_UINT16_MAX;
+            break;
+
+        case PARSEOP_DWORDCONST:
+
+            Op->Asl.Value.Integer = ACPI_UINT32_MAX;
+            break;
+
+        /* Don't need to do the QWORD case */
+
+        default:
+
+            /* Don't care about others */
+            break;
+        }
+    }
+
+    Op->Asl.ParseOpcode = (UINT16) ParseOpcode;
+    UtSetParseOpName (Op);
+
+    /*
+     * For the BYTE, WORD, and DWORD constants, make sure that the integer
+     * that was passed in will actually fit into the data type
+     */
+    switch (ParseOpcode)
+    {
+    case PARSEOP_BYTECONST:
+
+        UtCheckIntegerRange (Op, 0x00, ACPI_UINT8_MAX);
+        Op->Asl.Value.Integer &= ACPI_UINT8_MAX;
+        break;
+
+    case PARSEOP_WORDCONST:
+
+        UtCheckIntegerRange (Op, 0x00, ACPI_UINT16_MAX);
+        Op->Asl.Value.Integer &= ACPI_UINT16_MAX;
+        break;
+
+    case PARSEOP_DWORDCONST:
+
+        UtCheckIntegerRange (Op, 0x00, ACPI_UINT32_MAX);
+        Op->Asl.Value.Integer &= ACPI_UINT32_MAX;
+        break;
+
+    default:
+
+        /* Don't care about others, don't need to check QWORD */
+
+        break;
+    }
+
+    return (Op);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    TrPrintNodeCompileFlags
+ *
+ * PARAMETERS:  Flags               - Flags word to be decoded
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Decode a flags word to text. Displays all flags that are set.
+ *
+ ******************************************************************************/
+
+void
+TrPrintNodeCompileFlags (
+    UINT32                  Flags)
+{
+    UINT32                  i;
+    UINT32                  FlagBit = 1;
+    char                    *FlagName = NULL;
+
+
+    for (i = 0; i < 32; i++)
+    {
+        switch (Flags & FlagBit)
+        {
+        case NODE_VISITED:
+
+            FlagName = "NODE_VISITED";
+            break;
+
+        case NODE_AML_PACKAGE:
+
+            FlagName = "NODE_AML_PACKAGE";
+            break;
+
+        case NODE_IS_TARGET:
+
+            FlagName = "NODE_IS_TARGET";
+            break;
+
+        case NODE_IS_RESOURCE_DESC:
+
+            FlagName = "NODE_IS_RESOURCE_DESC";
+            break;
+
+        case NODE_IS_RESOURCE_FIELD:
+
+            FlagName = "NODE_IS_RESOURCE_FIELD";
+            break;
+
+        case NODE_HAS_NO_EXIT:
+
+            FlagName = "NODE_HAS_NO_EXIT";
+            break;
+
+        case NODE_IF_HAS_NO_EXIT:
+
+            FlagName = "NODE_IF_HAS_NO_EXIT";
+            break;
+
+        case NODE_NAME_INTERNALIZED:
+
+            FlagName = "NODE_NAME_INTERNALIZED";
+            break;
+
+        case NODE_METHOD_NO_RETVAL:
+
+            FlagName = "NODE_METHOD_NO_RETVAL";
+            break;
+
+        case NODE_METHOD_SOME_NO_RETVAL:
+
+            FlagName = "NODE_METHOD_SOME_NO_RETVAL";
+            break;
+
+        case NODE_RESULT_NOT_USED:
+
+            FlagName = "NODE_RESULT_NOT_USED";
+            break;
+
+        case NODE_METHOD_TYPED:
+
+            FlagName = "NODE_METHOD_TYPED";
+            break;
+
+        case NODE_COULD_NOT_REDUCE:
+
+            FlagName = "NODE_COULD_NOT_REDUCE";
+            break;
+
+        case NODE_COMPILE_TIME_CONST:
+
+            FlagName = "NODE_COMPILE_TIME_CONST";
+            break;
+
+        case NODE_IS_TERM_ARG:
+
+            FlagName = "NODE_IS_TERM_ARG";
+            break;
+
+        case NODE_WAS_ONES_OP:
+
+            FlagName = "NODE_WAS_ONES_OP";
+            break;
+
+        case NODE_IS_NAME_DECLARATION:
+
+            FlagName = "NODE_IS_NAME_DECLARATION";
+            break;
+
+        case NODE_COMPILER_EMITTED:
+
+            FlagName = "NODE_COMPILER_EMITTED";
+            break;
+
+        case NODE_IS_DUPLICATE:
+
+            FlagName = "NODE_IS_DUPLICATE";
+            break;
+
+        case NODE_IS_RESOURCE_DATA:
+
+            FlagName = "NODE_IS_RESOURCE_DATA";
+            break;
+
+        case NODE_IS_NULL_RETURN:
+
+            FlagName = "NODE_IS_NULL_RETURN";
+            break;
+
+        default:
+            break;
+        }
+
+        if (FlagName)
+        {
+            DbgPrint (ASL_PARSE_OUTPUT, " %s", FlagName);
+            FlagName = NULL;
+        }
+
+        FlagBit <<= 1;
+    }
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    TrSetNodeFlags
+ *
+ * PARAMETERS:  Op                  - An existing parse node
+ *              Flags               - New flags word
+ *
+ * RETURN:      The updated parser op
+ *
+ * DESCRIPTION: Set bits in the node flags word. Will not clear bits, only set
+ *
+ ******************************************************************************/
+
+ACPI_PARSE_OBJECT *
+TrSetNodeFlags (
+    ACPI_PARSE_OBJECT       *Op,
+    UINT32                  Flags)
+{
+
+    if (!Op)
+    {
+        return (NULL);
+    }
+
+    DbgPrint (ASL_PARSE_OUTPUT,
+        "\nSetNodeFlags: %s Op %p, %8.8X", Op->Asl.ParseOpName, Op, Flags);
+
+    TrPrintNodeCompileFlags (Flags);
+    DbgPrint (ASL_PARSE_OUTPUT, "\n\n");
+
+    Op->Asl.CompileFlags |= Flags;
+    return (Op);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    TrSetNodeAmlLength
+ *
+ * PARAMETERS:  Op                  - An existing parse node
+ *              Length              - AML Length
+ *
+ * RETURN:      The updated parser op
+ *
+ * DESCRIPTION: Set the AML Length in a node. Used by the parser to indicate
+ *              the presence of a node that must be reduced to a fixed length
+ *              constant.
+ *
+ ******************************************************************************/
+
+ACPI_PARSE_OBJECT *
+TrSetNodeAmlLength (
+    ACPI_PARSE_OBJECT       *Op,
+    UINT32                  Length)
+{
+
+    DbgPrint (ASL_PARSE_OUTPUT,
+        "\nSetNodeAmlLength: Op %p, %8.8X\n", Op, Length);
+
+    if (!Op)
+    {
+        return (NULL);
+    }
+
+    Op->Asl.AmlLength = Length;
+    return (Op);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    TrSetEndLineNumber
+ *
+ * PARAMETERS:  Op                - An existing parse node
+ *
+ * RETURN:      None.
+ *
+ * DESCRIPTION: Set the ending line numbers (file line and logical line) of a
+ *              parse node to the current line numbers.
+ *
+ ******************************************************************************/
+
+void
+TrSetEndLineNumber (
+    ACPI_PARSE_OBJECT       *Op)
+{
+
+    /* If the end line # is already set, just return */
+
+    if (Op->Asl.EndLine)
+    {
+        return;
+    }
+
+    Op->Asl.EndLine = Gbl_CurrentLineNumber;
+    Op->Asl.EndLogicalLine = Gbl_LogicalLineNumber;
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    TrCreateAssignmentNode
+ *
+ * PARAMETERS:  Target              - Assignment target
+ *              Source              - Assignment source
+ *
+ * RETURN:      Pointer to the new node. Aborts on allocation failure
+ *
+ * DESCRIPTION: Implements the C-style '=' operator. It changes the parse
+ *              tree if possible to utilize the last argument of the math
+ *              operators which is a target operand -- thus saving invocation
+ *              of and additional Store() operator. An optimization.
+ *
+ ******************************************************************************/
+
+ACPI_PARSE_OBJECT *
+TrCreateAssignmentNode (
+    ACPI_PARSE_OBJECT       *Target,
+    ACPI_PARSE_OBJECT       *Source)
+{
+    ACPI_PARSE_OBJECT       *TargetOp;
+    ACPI_PARSE_OBJECT       *SourceOp1;
+    ACPI_PARSE_OBJECT       *SourceOp2;
+    ACPI_PARSE_OBJECT       *Operator;
+
+
+    DbgPrint (ASL_PARSE_OUTPUT,
+        "\nTrCreateAssignmentNode  Line [%u to %u] Source %s Target %s\n",
+        Source->Asl.LineNumber, Source->Asl.EndLine,
+        UtGetOpName (Source->Asl.ParseOpcode),
+        UtGetOpName (Target->Asl.ParseOpcode));
+
+    TrSetNodeFlags (Target, NODE_IS_TARGET);
+
+    switch (Source->Asl.ParseOpcode)
+    {
+    /*
+     * Only these operators can be optimized because they have
+     * a target operand
+     */
+    case PARSEOP_ADD:
+    case PARSEOP_AND:
+    case PARSEOP_DIVIDE:
+    case PARSEOP_INDEX:
+    case PARSEOP_MOD:
+    case PARSEOP_MULTIPLY:
+    case PARSEOP_NOT:
+    case PARSEOP_OR:
+    case PARSEOP_SHIFTLEFT:
+    case PARSEOP_SHIFTRIGHT:
+    case PARSEOP_SUBTRACT:
+    case PARSEOP_XOR:
+
+        break;
+
+    /* Otherwise, just create a normal Store operator */
+
+    default:
+
+        goto CannotOptimize;
+    }
+
+    /*
+     * Transform the parse tree such that the target is moved to the
+     * last operand of the operator
+     */
+    SourceOp1 = Source->Asl.Child;
+    SourceOp2 = SourceOp1->Asl.Next;
+
+    /* NOT only has one operand, but has a target */
+
+    if (Source->Asl.ParseOpcode == PARSEOP_NOT)
+    {
+        SourceOp2 = SourceOp1;
+    }
+
+    /* DIVIDE has an extra target operand (remainder) */
+
+    if (Source->Asl.ParseOpcode == PARSEOP_DIVIDE)
+    {
+        SourceOp2 = SourceOp2->Asl.Next;
+    }
+
+    TargetOp = SourceOp2->Asl.Next;
+
+    /*
+     * Can't perform this optimization if there already is a target
+     * for the operator (ZERO is a "no target" placeholder).
+     */
+    if (TargetOp->Asl.ParseOpcode != PARSEOP_ZERO)
+    {
+        goto CannotOptimize;
+    }
+
+    /* Link in the target as the final operand */
+
+    SourceOp2->Asl.Next = Target;
+    Target->Asl.Parent = Source;
+
+    return (Source);
+
+
+CannotOptimize:
+
+    Operator = TrAllocateNode (PARSEOP_STORE);
+    TrLinkChildren (Operator, 2, Source, Target);
+
+    /* Set the appropriate line numbers for the new node */
+
+    Operator->Asl.LineNumber        = Target->Asl.LineNumber;
+    Operator->Asl.LogicalLineNumber = Target->Asl.LogicalLineNumber;
+    Operator->Asl.LogicalByteOffset = Target->Asl.LogicalByteOffset;
+    Operator->Asl.Column            = Target->Asl.Column;
+
+    return (Operator);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    TrCreateLeafNode
+ *
+ * PARAMETERS:  ParseOpcode         - New opcode to be assigned to the node
+ *
+ * RETURN:      Pointer to the new node. Aborts on allocation failure
+ *
+ * DESCRIPTION: Create a simple leaf node (no children or peers, and no value
+ *              assigned to the node)
+ *
+ ******************************************************************************/
+
+ACPI_PARSE_OBJECT *
+TrCreateLeafNode (
+    UINT32                  ParseOpcode)
+{
+    ACPI_PARSE_OBJECT       *Op;
+
+
+    Op = TrAllocateNode (ParseOpcode);
+
+    DbgPrint (ASL_PARSE_OUTPUT,
+        "\nCreateLeafNode  Ln/Col %u/%u NewNode %p  Op %s\n\n",
+        Op->Asl.LineNumber, Op->Asl.Column, Op, UtGetOpName (ParseOpcode));
+
+    return (Op);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    TrCreateNullTarget
+ *
+ * PARAMETERS:  None
+ *
+ * RETURN:      Pointer to the new node. Aborts on allocation failure
+ *
+ * DESCRIPTION: Create a "null" target node. This is defined by the ACPI
+ *              specification to be a zero AML opcode, and indicates that
+ *              no target has been specified for the parent operation
+ *
+ ******************************************************************************/
+
+ACPI_PARSE_OBJECT *
+TrCreateNullTarget (
+    void)
+{
+    ACPI_PARSE_OBJECT       *Op;
+
+
+    Op = TrAllocateNode (PARSEOP_ZERO);
+    Op->Asl.CompileFlags |= (NODE_IS_TARGET | NODE_COMPILE_TIME_CONST);
+
+    DbgPrint (ASL_PARSE_OUTPUT,
+        "\nCreateNullTarget  Ln/Col %u/%u NewNode %p  Op %s\n",
+        Op->Asl.LineNumber, Op->Asl.Column, Op,
+        UtGetOpName (Op->Asl.ParseOpcode));
+
+    return (Op);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    TrCreateConstantLeafNode
+ *
+ * PARAMETERS:  ParseOpcode         - The constant opcode
+ *
+ * RETURN:      Pointer to the new node. Aborts on allocation failure
+ *
+ * DESCRIPTION: Create a leaf node (no children or peers) for one of the
+ *              special constants - __LINE__, __FILE__, and __DATE__.
+ *
+ * Note: An implemenation of __FUNC__ cannot happen here because we don't
+ * have a full parse tree at this time and cannot find the parent control
+ * method. If it is ever needed, __FUNC__ must be implemented later, after
+ * the parse tree has been fully constructed.
+ *
+ ******************************************************************************/
+
+ACPI_PARSE_OBJECT *
+TrCreateConstantLeafNode (
+    UINT32                  ParseOpcode)
+{
+    ACPI_PARSE_OBJECT       *Op = NULL;
+    time_t                  CurrentTime;
+    char                    *StaticTimeString;
+    char                    *TimeString;
+    char                    *Filename;
+
+
+    switch (ParseOpcode)
+    {
+    case PARSEOP___LINE__:
+
+        Op = TrAllocateNode (PARSEOP_INTEGER);
+        Op->Asl.Value.Integer = Op->Asl.LineNumber;
+        break;
+
+    case PARSEOP___PATH__:
+
+        Op = TrAllocateNode (PARSEOP_STRING_LITERAL);
+
+        /* Op.Asl.Filename contains the full pathname to the file */
+
+        Op->Asl.Value.String = Op->Asl.Filename;
+        break;
+
+    case PARSEOP___FILE__:
+
+        Op = TrAllocateNode (PARSEOP_STRING_LITERAL);
+
+        /* Get the simple filename from the full path */
+
+        FlSplitInputPathname (Op->Asl.Filename, NULL, &Filename);
+        Op->Asl.Value.String = Filename;
+        break;
+
+    case PARSEOP___DATE__:
+
+        Op = TrAllocateNode (PARSEOP_STRING_LITERAL);
+
+        /* Get a copy of the current time */
+
+        CurrentTime = time (NULL);
+        StaticTimeString = ctime (&CurrentTime);
+        TimeString = UtLocalCalloc (strlen (StaticTimeString) + 1);
+        strcpy (TimeString, StaticTimeString);
+
+        TimeString[strlen(TimeString) -1] = 0;  /* Remove trailing newline */
+        Op->Asl.Value.String = TimeString;
+        break;
+
+    default: /* This would be an internal error */
+
+        return (NULL);
+    }
+
+    DbgPrint (ASL_PARSE_OUTPUT,
+        "\nCreateConstantLeafNode  Ln/Col %u/%u NewNode %p  "
+        "Op %s  Value %8.8X%8.8X  \n",
+        Op->Asl.LineNumber, Op->Asl.Column, Op, UtGetOpName (ParseOpcode),
+        ACPI_FORMAT_UINT64 (Op->Asl.Value.Integer));
+    return (Op);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    TrCreateTargetOperand
+ *
+ * PARAMETERS:  OriginalOp          - Op to be copied
+ *
+ * RETURN:      Pointer to the new node. Aborts on allocation failure
+ *
+ * DESCRIPTION: Copy an existing node (and subtree). Used in ASL+ (C-style)
+ *              expressions where the target is the same as one of the
+ *              operands. A new node and subtree must be created from the
+ *              original so that the parse tree can be linked properly.
+ *
+ * NOTE:        This code is specific to target operands that are the last
+ *              operand in an ASL/AML operator. Meaning that the top-level
+ *              parse Op in a possible subtree has a NULL Next pointer.
+ *              This simplifies the recursion.
+ *
+ *              Subtree example:
+ *                  DeRefOf (Local1) += 32
+ *
+ *              This gets converted to:
+ *                  Add (DeRefOf (Local1), 32, DeRefOf (Local1))
+ *
+ *              Each DeRefOf has a single child, Local1. Even more complex
+ *              subtrees can be created via the Index and DeRefOf operators.
+ *
+ ******************************************************************************/
+
+ACPI_PARSE_OBJECT *
+TrCreateTargetOperand (
+    ACPI_PARSE_OBJECT       *OriginalOp,
+    ACPI_PARSE_OBJECT       *ParentOp)
+{
+    ACPI_PARSE_OBJECT       *Op;
+
+
+    if (!OriginalOp)
+    {
+        return (NULL);
+    }
+
+    Op = TrGetNextNode ();
+
+    /* Copy the pertinent values (omit link pointer fields) */
+
+    Op->Asl.Value               = OriginalOp->Asl.Value;
+    Op->Asl.Filename            = OriginalOp->Asl.Filename;
+    Op->Asl.LineNumber          = OriginalOp->Asl.LineNumber;
+    Op->Asl.LogicalLineNumber   = OriginalOp->Asl.LogicalLineNumber;
+    Op->Asl.LogicalByteOffset   = OriginalOp->Asl.LogicalByteOffset;
+    Op->Asl.Column              = OriginalOp->Asl.Column;
+    Op->Asl.Flags               = OriginalOp->Asl.Flags;
+    Op->Asl.CompileFlags        = OriginalOp->Asl.CompileFlags;
+    Op->Asl.AmlOpcode           = OriginalOp->Asl.AmlOpcode;
+    Op->Asl.ParseOpcode         = OriginalOp->Asl.ParseOpcode;
+    Op->Asl.Parent              = ParentOp;
+    UtSetParseOpName (Op);
+
+    /* Copy a possible subtree below this node */
+
+    if (OriginalOp->Asl.Child)
+    {
+        Op->Asl.Child = TrCreateTargetOperand (OriginalOp->Asl.Child, Op);
+    }
+
+    if (OriginalOp->Asl.Next) /* Null for top-level node */
+    {
+        Op->Asl.Next = TrCreateTargetOperand (OriginalOp->Asl.Next, ParentOp);
+    }
+
+    return (Op);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    TrCreateValuedLeafNode
+ *
+ * PARAMETERS:  ParseOpcode         - New opcode to be assigned to the node
+ *              Value               - Value to be assigned to the node
+ *
+ * RETURN:      Pointer to the new node. Aborts on allocation failure
+ *
+ * DESCRIPTION: Create a leaf node (no children or peers) with a value
+ *              assigned to it
+ *
+ ******************************************************************************/
+
+ACPI_PARSE_OBJECT *
+TrCreateValuedLeafNode (
+    UINT32                  ParseOpcode,
+    UINT64                  Value)
+{
+    ACPI_PARSE_OBJECT       *Op;
+
+
+    Op = TrAllocateNode (ParseOpcode);
+
+    DbgPrint (ASL_PARSE_OUTPUT,
+        "\nCreateValuedLeafNode  Ln/Col %u/%u NewNode %p  "
+        "Op %s  Value %8.8X%8.8X  ",
+        Op->Asl.LineNumber, Op->Asl.Column, Op, UtGetOpName(ParseOpcode),
+        ACPI_FORMAT_UINT64 (Value));
+    Op->Asl.Value.Integer = Value;
+
+    switch (ParseOpcode)
+    {
+    case PARSEOP_STRING_LITERAL:
+
+        DbgPrint (ASL_PARSE_OUTPUT, "STRING->%s", Value);
+        break;
+
+    case PARSEOP_NAMESEG:
+
+        DbgPrint (ASL_PARSE_OUTPUT, "NAMESEG->%s", Value);
+        break;
+
+    case PARSEOP_NAMESTRING:
+
+        DbgPrint (ASL_PARSE_OUTPUT, "NAMESTRING->%s", Value);
+        break;
+
+    case PARSEOP_EISAID:
+
+        DbgPrint (ASL_PARSE_OUTPUT, "EISAID->%s", Value);
+        break;
+
+    case PARSEOP_METHOD:
+
+        DbgPrint (ASL_PARSE_OUTPUT, "METHOD");
+        break;
+
+    case PARSEOP_INTEGER:
+
+        DbgPrint (ASL_PARSE_OUTPUT, "INTEGER->%8.8X%8.8X",
+            ACPI_FORMAT_UINT64 (Value));
+        break;
+
+    default:
+
+        break;
+    }
+
+    DbgPrint (ASL_PARSE_OUTPUT, "\n\n");
+    return (Op);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    TrCreateNode
+ *
+ * PARAMETERS:  ParseOpcode         - Opcode to be assigned to the node
+ *              NumChildren         - Number of children to follow
+ *              ...                 - A list of child nodes to link to the new
+ *                                    node. NumChildren long.
+ *
+ * RETURN:      Pointer to the new node. Aborts on allocation failure
+ *
+ * DESCRIPTION: Create a new parse node and link together a list of child
+ *              nodes underneath the new node.
+ *
+ ******************************************************************************/
+
+ACPI_PARSE_OBJECT *
+TrCreateNode (
+    UINT32                  ParseOpcode,
+    UINT32                  NumChildren,
+    ...)
+{
+    ACPI_PARSE_OBJECT       *Op;
+    ACPI_PARSE_OBJECT       *Child;
+    ACPI_PARSE_OBJECT       *PrevChild;
+    va_list                 ap;
+    UINT32                  i;
+    BOOLEAN                 FirstChild;
+
+
+    va_start (ap, NumChildren);
+
+    /* Allocate one new node */
+
+    Op = TrAllocateNode (ParseOpcode);
+
+    DbgPrint (ASL_PARSE_OUTPUT,
+        "\nCreateNode  Ln/Col %u/%u NewParent %p Child %u Op %s  ",
+        Op->Asl.LineNumber, Op->Asl.Column, Op,
+        NumChildren, UtGetOpName(ParseOpcode));
+
+    /* Some extra debug output based on the parse opcode */
+
+    switch (ParseOpcode)
+    {
+    case PARSEOP_ASL_CODE:
+
+        Gbl_ParseTreeRoot = Op;
+        Op->Asl.ParseOpcode = PARSEOP_DEFAULT_ARG;
+        DbgPrint (ASL_PARSE_OUTPUT, "ASLCODE (Tree Completed)->");
+        break;
+
+    case PARSEOP_DEFINITION_BLOCK:
+
+        DbgPrint (ASL_PARSE_OUTPUT, "DEFINITION_BLOCK (Tree Completed)->");
+        break;
+
+    case PARSEOP_OPERATIONREGION:
+
+        DbgPrint (ASL_PARSE_OUTPUT, "OPREGION->");
+        break;
+
+    case PARSEOP_OR:
+
+        DbgPrint (ASL_PARSE_OUTPUT, "OR->");
+        break;
+
+    default:
+
+        /* Nothing to do for other opcodes */
+
+        break;
+    }
+
+    /* Link the new node to its children */
+
+    PrevChild = NULL;
+    FirstChild = TRUE;
+    for (i = 0; i < NumChildren; i++)
+    {
+        /* Get the next child */
+
+        Child = va_arg (ap, ACPI_PARSE_OBJECT *);
+        DbgPrint (ASL_PARSE_OUTPUT, "%p, ", Child);
+
+        /*
+         * If child is NULL, this means that an optional argument
+         * was omitted. We must create a placeholder with a special
+         * opcode (DEFAULT_ARG) so that the code generator will know
+         * that it must emit the correct default for this argument
+         */
+        if (!Child)
+        {
+            Child = TrAllocateNode (PARSEOP_DEFAULT_ARG);
+        }
+
+        /* Link first child to parent */
+
+        if (FirstChild)
+        {
+            FirstChild = FALSE;
+            Op->Asl.Child = Child;
+        }
+
+        /* Point all children to parent */
+
+        Child->Asl.Parent = Op;
+
+        /* Link children in a peer list */
+
+        if (PrevChild)
+        {
+            PrevChild->Asl.Next = Child;
+        };
+
+        /*
+         * This child might be a list, point all nodes in the list
+         * to the same parent
+         */
+        while (Child->Asl.Next)
+        {
+            Child = Child->Asl.Next;
+            Child->Asl.Parent = Op;
+        }
+
+        PrevChild = Child;
+    }
+    va_end(ap);
+
+    DbgPrint (ASL_PARSE_OUTPUT, "\n");
+    return (Op);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    TrLinkChildren
+ *
+ * PARAMETERS:  Op                - An existing parse node
+ *              NumChildren         - Number of children to follow
+ *              ...                 - A list of child nodes to link to the new
+ *                                    node. NumChildren long.
+ *
+ * RETURN:      The updated (linked) node
+ *
+ * DESCRIPTION: Link a group of nodes to an existing parse node
+ *
+ ******************************************************************************/
+
+ACPI_PARSE_OBJECT *
+TrLinkChildren (
+    ACPI_PARSE_OBJECT       *Op,
+    UINT32                  NumChildren,
+    ...)
+{
+    ACPI_PARSE_OBJECT       *Child;
+    ACPI_PARSE_OBJECT       *PrevChild;
+    va_list                 ap;
+    UINT32                  i;
+    BOOLEAN                 FirstChild;
+
+
+    va_start (ap, NumChildren);
+
+
+    TrSetEndLineNumber (Op);
+
+    DbgPrint (ASL_PARSE_OUTPUT,
+        "\nLinkChildren  Line [%u to %u] NewParent %p Child %u Op %s  ",
+        Op->Asl.LineNumber, Op->Asl.EndLine,
+        Op, NumChildren, UtGetOpName(Op->Asl.ParseOpcode));
+
+    switch (Op->Asl.ParseOpcode)
+    {
+    case PARSEOP_ASL_CODE:
+
+        Gbl_ParseTreeRoot = Op;
+        Op->Asl.ParseOpcode = PARSEOP_DEFAULT_ARG;
+        DbgPrint (ASL_PARSE_OUTPUT, "ASLCODE (Tree Completed)->");
+        break;
+
+    case PARSEOP_DEFINITION_BLOCK:
+
+        DbgPrint (ASL_PARSE_OUTPUT, "DEFINITION_BLOCK (Tree Completed)->");
+        break;
+
+    case PARSEOP_OPERATIONREGION:
+
+        DbgPrint (ASL_PARSE_OUTPUT, "OPREGION->");
+        break;
+
+    case PARSEOP_OR:
+
+        DbgPrint (ASL_PARSE_OUTPUT, "OR->");
+        break;
+
+    default:
+
+        /* Nothing to do for other opcodes */
+
+        break;
+    }
+
+    /* Link the new node to it's children */
+
+    PrevChild = NULL;
+    FirstChild = TRUE;
+    for (i = 0; i < NumChildren; i++)
+    {
+        Child = va_arg (ap, ACPI_PARSE_OBJECT *);
+
+        if ((Child == PrevChild) && (Child != NULL))
+        {
+            AslError (ASL_WARNING, ASL_MSG_COMPILER_INTERNAL, Child,
+                "Child node list invalid");
+            va_end(ap);
+            return (Op);
+        }
+
+        DbgPrint (ASL_PARSE_OUTPUT, "%p, ", Child);
+
+        /*
+         * If child is NULL, this means that an optional argument
+         * was omitted. We must create a placeholder with a special
+         * opcode (DEFAULT_ARG) so that the code generator will know
+         * that it must emit the correct default for this argument
+         */
+        if (!Child)
+        {
+            Child = TrAllocateNode (PARSEOP_DEFAULT_ARG);
+        }
+
+        /* Link first child to parent */
+
+        if (FirstChild)
+        {
+            FirstChild = FALSE;
+            Op->Asl.Child = Child;
+        }
+
+        /* Point all children to parent */
+
+        Child->Asl.Parent = Op;
+
+        /* Link children in a peer list */
+
+        if (PrevChild)
+        {
+            PrevChild->Asl.Next = Child;
+        };
+
+        /*
+         * This child might be a list, point all nodes in the list
+         * to the same parent
+         */
+        while (Child->Asl.Next)
+        {
+            Child = Child->Asl.Next;
+            Child->Asl.Parent = Op;
+        }
+
+        PrevChild = Child;
+    }
+
+    va_end(ap);
+    DbgPrint (ASL_PARSE_OUTPUT, "\n\n");
+    return (Op);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    TrLinkPeerNode
+ *
+ * PARAMETERS:  Op1           - First peer
+ *              Op2           - Second peer
+ *
+ * RETURN:      Op1 or the non-null node.
+ *
+ * DESCRIPTION: Link two nodes as peers. Handles cases where one peer is null.
+ *
+ ******************************************************************************/
+
+ACPI_PARSE_OBJECT *
+TrLinkPeerNode (
+    ACPI_PARSE_OBJECT       *Op1,
+    ACPI_PARSE_OBJECT       *Op2)
+{
+    ACPI_PARSE_OBJECT       *Next;
+
+
+    DbgPrint (ASL_PARSE_OUTPUT,
+        "\nLinkPeerNode: 1=%p (%s), 2=%p (%s)\n",
+        Op1, Op1 ? UtGetOpName(Op1->Asl.ParseOpcode) : NULL,
+        Op2, Op2 ? UtGetOpName(Op2->Asl.ParseOpcode) : NULL);
+
+
+    if ((!Op1) && (!Op2))
+    {
+        DbgPrint (ASL_PARSE_OUTPUT, "\nTwo Null nodes!\n");
+        return (Op1);
+    }
+
+    /* If one of the nodes is null, just return the non-null node */
+
+    if (!Op2)
+    {
+        return (Op1);
+    }
+
+    if (!Op1)
+    {
+        return (Op2);
+    }
+
+    if (Op1 == Op2)
+    {
+        DbgPrint (ASL_DEBUG_OUTPUT,
+            "\n************* Internal error, linking node to itself %p\n",
+            Op1);
+        AslError (ASL_WARNING, ASL_MSG_COMPILER_INTERNAL, Op1,
+            "Linking node to itself");
+        return (Op1);
+    }
+
+    Op1->Asl.Parent = Op2->Asl.Parent;
+
+    /*
+     * Op 1 may already have a peer list (such as an IF/ELSE pair),
+     * so we must walk to the end of the list and attach the new
+     * peer at the end
+     */
+    Next = Op1;
+    while (Next->Asl.Next)
+    {
+        Next = Next->Asl.Next;
+    }
+
+    Next->Asl.Next = Op2;
+    return (Op1);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    TrLinkPeerNodes
+ *
+ * PARAMETERS:  NumPeers            - The number of nodes in the list to follow
+ *              ...                 - A list of nodes to link together as peers
+ *
+ * RETURN:      The first node in the list (head of the peer list)
+ *
+ * DESCRIPTION: Link together an arbitrary number of peer nodes.
+ *
+ ******************************************************************************/
+
+ACPI_PARSE_OBJECT *
+TrLinkPeerNodes (
+    UINT32                  NumPeers,
+    ...)
+{
+    ACPI_PARSE_OBJECT       *This;
+    ACPI_PARSE_OBJECT       *Next;
+    va_list                 ap;
+    UINT32                  i;
+    ACPI_PARSE_OBJECT       *Start;
+
+
+    DbgPrint (ASL_PARSE_OUTPUT,
+        "\nLinkPeerNodes: (%u) ", NumPeers);
+
+    va_start (ap, NumPeers);
+    This = va_arg (ap, ACPI_PARSE_OBJECT *);
+    Start = This;
+
+    /*
+     * Link all peers
+     */
+    for (i = 0; i < (NumPeers -1); i++)
+    {
+        DbgPrint (ASL_PARSE_OUTPUT, "%u=%p ", (i+1), This);
+
+        while (This->Asl.Next)
+        {
+            This = This->Asl.Next;
+        }
+
+        /* Get another peer node */
+
+        Next = va_arg (ap, ACPI_PARSE_OBJECT *);
+        if (!Next)
+        {
+            Next = TrAllocateNode (PARSEOP_DEFAULT_ARG);
+        }
+
+        /* link new node to the current node */
+
+        This->Asl.Next = Next;
+        This = Next;
+    }
+    va_end (ap);
+
+    DbgPrint (ASL_PARSE_OUTPUT,"\n");
+    return (Start);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    TrLinkChildNode
+ *
+ * PARAMETERS:  Op1           - Parent node
+ *              Op2           - Op to become a child
+ *
+ * RETURN:      The parent node
+ *
+ * DESCRIPTION: Link two nodes together as a parent and child
+ *
+ ******************************************************************************/
+
+ACPI_PARSE_OBJECT *
+TrLinkChildNode (
+    ACPI_PARSE_OBJECT       *Op1,
+    ACPI_PARSE_OBJECT       *Op2)
+{
+    ACPI_PARSE_OBJECT       *Next;
+
+
+    DbgPrint (ASL_PARSE_OUTPUT,
+        "\nLinkChildNode: Parent=%p (%s), Child=%p (%s)\n",
+        Op1, Op1 ? UtGetOpName(Op1->Asl.ParseOpcode): NULL,
+        Op2, Op2 ? UtGetOpName(Op2->Asl.ParseOpcode): NULL);
+
+    if (!Op1 || !Op2)
+    {
+        return (Op1);
+    }
+
+    Op1->Asl.Child = Op2;
+
+    /* Set the child and all peers of the child to point to the parent */
+
+    Next = Op2;
+    while (Next)
+    {
+        Next->Asl.Parent = Op1;
+        Next = Next->Asl.Next;
+    }
+
+    return (Op1);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    TrWalkParseTree
+ *
+ * PARAMETERS:  Visitation              - Type of walk
+ *              DescendingCallback      - Called during tree descent
+ *              AscendingCallback       - Called during tree ascent
+ *              Context                 - To be passed to the callbacks
+ *
+ * RETURN:      Status from callback(s)
+ *
+ * DESCRIPTION: Walk the entire parse tree.
+ *
+ ******************************************************************************/
+
+ACPI_STATUS
+TrWalkParseTree (
+    ACPI_PARSE_OBJECT       *Op,
+    UINT32                  Visitation,
+    ASL_WALK_CALLBACK       DescendingCallback,
+    ASL_WALK_CALLBACK       AscendingCallback,
+    void                    *Context)
+{
+    UINT32                  Level;
+    BOOLEAN                 NodePreviouslyVisited;
+    ACPI_PARSE_OBJECT       *StartOp = Op;
+    ACPI_STATUS             Status;
+
+
+    if (!Gbl_ParseTreeRoot)
+    {
+        return (AE_OK);
+    }
+
+    Level = 0;
+    NodePreviouslyVisited = FALSE;
+
+    switch (Visitation)
+    {
+    case ASL_WALK_VISIT_DOWNWARD:
+
+        while (Op)
+        {
+            if (!NodePreviouslyVisited)
+            {
+                /* Let the callback process the node. */
+
+                Status = DescendingCallback (Op, Level, Context);
+                if (ACPI_SUCCESS (Status))
+                {
+                    /* Visit children first, once */
+
+                    if (Op->Asl.Child)
+                    {
+                        Level++;
+                        Op = Op->Asl.Child;
+                        continue;
+                    }
+                }
+                else if (Status != AE_CTRL_DEPTH)
+                {
+                    /* Exit immediately on any error */
+
+                    return (Status);
+                }
+            }
+
+            /* Terminate walk at start op */
+
+            if (Op == StartOp)
+            {
+                break;
+            }
+
+            /* No more children, visit peers */
+
+            if (Op->Asl.Next)
+            {
+                Op = Op->Asl.Next;
+                NodePreviouslyVisited = FALSE;
+            }
+            else
+            {
+                /* No children or peers, re-visit parent */
+
+                if (Level != 0 )
+                {
+                    Level--;
+                }
+                Op = Op->Asl.Parent;
+                NodePreviouslyVisited = TRUE;
+            }
+        }
+        break;
+
+    case ASL_WALK_VISIT_UPWARD:
+
+        while (Op)
+        {
+            /* Visit leaf node (no children) or parent node on return trip */
+
+            if ((!Op->Asl.Child) ||
+                (NodePreviouslyVisited))
+            {
+                /* Let the callback process the node. */
+
+                Status = AscendingCallback (Op, Level, Context);
+                if (ACPI_FAILURE (Status))
+                {
+                    return (Status);
+                }
+            }
+            else
+            {
+                /* Visit children first, once */
+
+                Level++;
+                Op = Op->Asl.Child;
+                continue;
+            }
+
+            /* Terminate walk at start op */
+
+            if (Op == StartOp)
+            {
+                break;
+            }
+
+            /* No more children, visit peers */
+
+            if (Op->Asl.Next)
+            {
+                Op = Op->Asl.Next;
+                NodePreviouslyVisited = FALSE;
+            }
+            else
+            {
+                /* No children or peers, re-visit parent */
+
+                if (Level != 0 )
+                {
+                    Level--;
+                }
+                Op = Op->Asl.Parent;
+                NodePreviouslyVisited = TRUE;
+            }
+        }
+        break;
+
+     case ASL_WALK_VISIT_TWICE:
+
+        while (Op)
+        {
+            if (NodePreviouslyVisited)
+            {
+                Status = AscendingCallback (Op, Level, Context);
+                if (ACPI_FAILURE (Status))
+                {
+                    return (Status);
+                }
+            }
+            else
+            {
+                /* Let the callback process the node. */
+
+                Status = DescendingCallback (Op, Level, Context);
+                if (ACPI_SUCCESS (Status))
+                {
+                    /* Visit children first, once */
+
+                    if (Op->Asl.Child)
+                    {
+                        Level++;
+                        Op = Op->Asl.Child;
+                        continue;
+                    }
+                }
+                else if (Status != AE_CTRL_DEPTH)
+                {
+                    /* Exit immediately on any error */
+
+                    return (Status);
+                }
+            }
+
+            /* Terminate walk at start op */
+
+            if (Op == StartOp)
+            {
+                break;
+            }
+
+            /* No more children, visit peers */
+
+            if (Op->Asl.Next)
+            {
+                Op = Op->Asl.Next;
+                NodePreviouslyVisited = FALSE;
+            }
+            else
+            {
+                /* No children or peers, re-visit parent */
+
+                if (Level != 0 )
+                {
+                    Level--;
+                }
+                Op = Op->Asl.Parent;
+                NodePreviouslyVisited = TRUE;
+            }
+        }
+        break;
+
+    default:
+        /* No other types supported */
+        break;
+    }
+
+    /* If we get here, the walk completed with no errors */
+
+    return (AE_OK);
+}
diff --git a/usr/src/cmd/acpi/iasl/asltypes.h b/usr/src/cmd/acpi/iasl/asltypes.h
new file mode 100644
index 0000000000..411faede48
--- /dev/null
+++ b/usr/src/cmd/acpi/iasl/asltypes.h
@@ -0,0 +1,339 @@
+/******************************************************************************
+ *
+ * Module Name: asltypes.h - compiler data types and struct definitions
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2016, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#ifndef __ASLTYPES_H
+#define __ASLTYPES_H
+
+
+/*******************************************************************************
+ *
+ * Structure definitions
+ *
+ ******************************************************************************/
+
+
+/* Op flags for the ACPI_PARSE_OBJECT */
+
+#define NODE_VISITED                0x00000001
+#define NODE_AML_PACKAGE            0x00000002
+#define NODE_IS_TARGET              0x00000004
+#define NODE_IS_RESOURCE_DESC       0x00000008
+#define NODE_IS_RESOURCE_FIELD      0x00000010
+#define NODE_HAS_NO_EXIT            0x00000020
+#define NODE_IF_HAS_NO_EXIT         0x00000040
+#define NODE_NAME_INTERNALIZED      0x00000080
+#define NODE_METHOD_NO_RETVAL       0x00000100
+#define NODE_METHOD_SOME_NO_RETVAL  0x00000200
+#define NODE_RESULT_NOT_USED        0x00000400
+#define NODE_METHOD_TYPED           0x00000800
+#define NODE_COULD_NOT_REDUCE       0x00001000
+#define NODE_COMPILE_TIME_CONST     0x00002000
+#define NODE_IS_TERM_ARG            0x00004000
+#define NODE_WAS_ONES_OP            0x00008000
+#define NODE_IS_NAME_DECLARATION    0x00010000
+#define NODE_COMPILER_EMITTED       0x00020000
+#define NODE_IS_DUPLICATE           0x00040000
+#define NODE_IS_RESOURCE_DATA       0x00080000
+#define NODE_IS_NULL_RETURN         0x00100000
+
+/* Keeps information about individual control methods */
+
+typedef struct asl_method_info
+{
+    ACPI_PARSE_OBJECT       *Op;
+    ACPI_PARSE_OBJECT       *CurrentOp;
+    struct asl_method_info  *Next;
+    UINT32                  ValidArgTypes[ACPI_METHOD_NUM_ARGS];
+    UINT32                  ValidReturnTypes;
+    UINT32                  NumReturnNoValue;
+    UINT32                  NumReturnWithValue;
+    UINT8                   NumArguments;
+    UINT8                   LocalInitialized[ACPI_METHOD_NUM_LOCALS];
+    UINT8                   ArgInitialized[ACPI_METHOD_NUM_ARGS];
+    UINT8                   HasBeenTyped;
+    UINT8                   ShouldBeSerialized;
+
+} ASL_METHOD_INFO;
+
+
+/* Parse tree walk info for control method analysis */
+
+typedef struct asl_analysis_walk_info
+{
+    ASL_METHOD_INFO         *MethodStack;
+
+} ASL_ANALYSIS_WALK_INFO;
+
+
+/* An entry in the ParseOpcode to AmlOpcode mapping table */
+
+typedef struct asl_mapping_entry
+{
+    UINT32                      Value;
+    UINT32                      AcpiBtype;   /* Object type or return type */
+    UINT16                      AmlOpcode;
+    UINT8                       Flags;
+
+} ASL_MAPPING_ENTRY;
+
+
+/* Parse tree walk info structure */
+
+typedef struct asl_walk_info
+{
+    ACPI_PARSE_OBJECT           **NodePtr;
+    UINT32                      *LevelPtr;
+
+} ASL_WALK_INFO;
+
+
+/* File info */
+
+typedef struct asl_file_info
+{
+    FILE                        *Handle;
+    char                        *Filename;
+    const char                  *ShortDescription;
+    const char                  *Description;
+
+} ASL_FILE_INFO;
+
+typedef struct asl_file_status
+{
+    UINT32                  Line;
+    UINT32                  Offset;
+
+} ASL_FILE_STATUS;
+
+
+/*
+ * File types. Note: Any changes to this table must also be reflected
+ * in the Gbl_Files array.
+ *
+ * Corresponding filename suffixes are in comments
+ *
+ * NOTE: Don't move the first 4 file types
+ */
+typedef enum
+{
+    ASL_FILE_STDOUT             = 0,
+    ASL_FILE_STDERR,
+    ASL_FILE_INPUT,             /* .asl */
+    ASL_FILE_AML_OUTPUT,        /* .aml */
+    ASL_FILE_SOURCE_OUTPUT,     /* .src */
+    ASL_FILE_PREPROCESSOR,      /* .pre */
+    ASL_FILE_PREPROCESSOR_USER, /* .i   */
+    ASL_FILE_LISTING_OUTPUT,    /* .lst */
+    ASL_FILE_HEX_OUTPUT,        /* .hex */
+    ASL_FILE_NAMESPACE_OUTPUT,  /* .nsp */
+    ASL_FILE_DEBUG_OUTPUT,      /* .txt */
+    ASL_FILE_ASM_SOURCE_OUTPUT, /* .asm */
+    ASL_FILE_C_SOURCE_OUTPUT,   /* .c   */
+    ASL_FILE_ASM_INCLUDE_OUTPUT,/* .inc */
+    ASL_FILE_C_INCLUDE_OUTPUT,  /* .h   */
+    ASL_FILE_C_OFFSET_OUTPUT,   /* .offset.h */
+    ASL_FILE_MAP_OUTPUT,        /* .map */
+    ASL_FILE_XREF_OUTPUT        /* .xrf */
+
+} ASL_FILE_TYPES;
+
+
+#define ASL_MAX_FILE_TYPE       17
+#define ASL_NUM_FILES           (ASL_MAX_FILE_TYPE + 1)
+
+/* Name suffixes used to create filenames for output files */
+
+#define FILE_SUFFIX_ASL_CODE        "asl"
+#define FILE_SUFFIX_AML_CODE        "aml"
+#define FILE_SUFFIX_SOURCE          "src"
+#define FILE_SUFFIX_PREPROCESSOR    "pre"
+#define FILE_SUFFIX_PREPROC_USER    "i"
+#define FILE_SUFFIX_LISTING         "lst"
+#define FILE_SUFFIX_HEX_DUMP        "hex"
+#define FILE_SUFFIX_NAMESPACE       "nsp"
+#define FILE_SUFFIX_DEBUG           "txt"
+#define FILE_SUFFIX_ASM_SOURCE      "asm"
+#define FILE_SUFFIX_C_SOURCE        "c"
+#define FILE_SUFFIX_ASM_INCLUDE     "inc"
+#define FILE_SUFFIX_C_INCLUDE       "h"
+#define FILE_SUFFIX_C_OFFSET        "offset.h"
+#define FILE_SUFFIX_MAP             "map"
+#define FILE_SUFFIX_XREF            "xrf"
+
+
+/* Cache block structure for ParseOps and Strings */
+
+typedef struct asl_cache_info
+{
+    void                            *Next;
+    char                            Buffer[1];
+
+} ASL_CACHE_INFO;
+
+
+typedef struct asl_include_dir
+{
+    char                        *Dir;
+    struct asl_include_dir      *Next;
+
+} ASL_INCLUDE_DIR;
+
+
+/* An entry in the exception list, one for each error/warning */
+
+typedef struct asl_error_msg
+{
+    UINT32                      LineNumber;
+    UINT32                      LogicalLineNumber;
+    UINT32                      LogicalByteOffset;
+    UINT32                      Column;
+    char                        *Message;
+    struct asl_error_msg        *Next;
+    char                        *Filename;
+    char                        *SourceLine;
+    UINT32                      FilenameLength;
+    UINT16                      MessageId;
+    UINT8                       Level;
+
+} ASL_ERROR_MSG;
+
+
+/* An entry in the listing file stack (for include files) */
+
+typedef struct asl_listing_node
+{
+    char                        *Filename;
+    UINT32                      LineNumber;
+    struct asl_listing_node     *Next;
+
+} ASL_LISTING_NODE;
+
+
+/* Callback interface for a parse tree walk */
+
+/*
+ * TBD - another copy of this is in adisasm.h, fix
+ */
+#ifndef ASL_WALK_CALLBACK_DEFINED
+typedef
+ACPI_STATUS (*ASL_WALK_CALLBACK) (
+    ACPI_PARSE_OBJECT           *Op,
+    UINT32                      Level,
+    void                        *Context);
+#define ASL_WALK_CALLBACK_DEFINED
+#endif
+
+
+typedef struct asl_event_info
+{
+    UINT64                      StartTime;
+    UINT64                      EndTime;
+    char                        *EventName;
+    BOOLEAN                     Valid;
+
+} ASL_EVENT_INFO;
+
+
+/* Hardware mapping file structures */
+
+typedef struct acpi_gpio_info
+{
+    struct acpi_gpio_info   *Next;
+    ACPI_PARSE_OBJECT       *Op;
+    char                    *DeviceName;
+    ACPI_NAMESPACE_NODE     *TargetNode;
+    UINT32                  References;
+    UINT32                  PinCount;
+    UINT32                  PinIndex;
+    UINT16                  PinNumber;
+    UINT8                   Type;
+    UINT8                   Direction;
+    UINT8                   Polarity;
+
+} ACPI_GPIO_INFO;
+
+typedef struct acpi_serial_info
+{
+    struct acpi_serial_info *Next;
+    ACPI_PARSE_OBJECT       *Op;
+    char                    *DeviceName;
+    ACPI_NAMESPACE_NODE     *TargetNode;
+    AML_RESOURCE            *Resource;
+    UINT32                  Speed;
+    UINT16                  Address;
+
+} ACPI_SERIAL_INFO;
+
+typedef struct asl_method_local
+{
+    ACPI_PARSE_OBJECT       *Op;
+    UINT8                   Flags;
+
+} ASL_METHOD_LOCAL;
+
+/* Values for Flags field above */
+
+#define ASL_LOCAL_INITIALIZED   (1)
+#define ASL_LOCAL_REFERENCED    (1<<1)
+#define ASL_ARG_IS_LOCAL        (1<<2)
+#define ASL_ARG_INITIALIZED     (1<<3)
+#define ASL_ARG_REFERENCED      (1<<4)
+
+/* Info used to track method counts for cross reference output file */
+
+typedef struct asl_xref_info
+{
+    UINT32                  ThisMethodInvocations;
+    UINT32                  TotalPredefinedMethods;
+    UINT32                  TotalUserMethods;
+    UINT32                  TotalUnreferenceUserMethods;
+    UINT32                  ThisObjectReferences;
+    UINT32                  TotalObjects;
+    UINT32                  TotalUnreferencedObjects;
+    ACPI_PARSE_OBJECT       *MethodOp;
+    ACPI_PARSE_OBJECT       *CurrentMethodOp;
+
+} ASL_XREF_INFO;
+
+
+#endif  /* __ASLTYPES_H */
diff --git a/usr/src/cmd/acpi/iasl/asltypes.y b/usr/src/cmd/acpi/iasl/asltypes.y
new file mode 100644
index 0000000000..1faecb4587
--- /dev/null
+++ b/usr/src/cmd/acpi/iasl/asltypes.y
@@ -0,0 +1,400 @@
+NoEcho('
+/******************************************************************************
+ *
+ * Module Name: asltypes.y - Bison/Yacc production types/names
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2016, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+')
+
+/******************************************************************************
+ *
+ * Production names
+ *
+ *****************************************************************************/
+
+%type <n> ArgList
+%type <n> AslCode
+%type <n> BufferData
+%type <n> BufferTermData
+%type <n> CompilerDirective
+%type <n> DataObject
+%type <n> DefinitionBlockTerm
+%type <n> DefinitionBlockList
+%type <n> IntegerData
+%type <n> NamedObject
+%type <n> NameSpaceModifier
+%type <n> Object
+%type <n> PackageData
+%type <n> ParameterTypePackage
+%type <n> ParameterTypePackageList
+%type <n> ParameterTypesPackage
+%type <n> ParameterTypesPackageList
+%type <n> RequiredTarget
+%type <n> SimpleTarget
+%type <n> StringData
+%type <n> Target
+%type <n> Term
+%type <n> TermArg
+%type <n> TermList
+%type <n> MethodInvocationTerm
+
+/* Type4Opcode is obsolete */
+
+%type <n> Type1Opcode
+%type <n> Type2BufferOpcode
+%type <n> Type2BufferOrStringOpcode
+%type <n> Type2IntegerOpcode
+%type <n> Type2Opcode
+%type <n> Type2StringOpcode
+%type <n> Type3Opcode
+%type <n> Type5Opcode
+%type <n> Type6Opcode
+
+%type <n> AccessAsTerm
+%type <n> ExternalTerm
+%type <n> FieldUnit
+%type <n> FieldUnitEntry
+%type <n> FieldUnitList
+%type <n> IncludeTerm
+%type <n> OffsetTerm
+%type <n> OptionalAccessAttribTerm
+
+/* Named Objects */
+
+%type <n> BankFieldTerm
+%type <n> CreateBitFieldTerm
+%type <n> CreateByteFieldTerm
+%type <n> CreateDWordFieldTerm
+%type <n> CreateFieldTerm
+%type <n> CreateQWordFieldTerm
+%type <n> CreateWordFieldTerm
+%type <n> DataRegionTerm
+%type <n> DeviceTerm
+%type <n> EventTerm
+%type <n> FieldTerm
+%type <n> FunctionTerm
+%type <n> IndexFieldTerm
+%type <n> MethodTerm
+%type <n> MutexTerm
+%type <n> OpRegionTerm
+%type <n> OpRegionSpaceIdTerm
+%type <n> PowerResTerm
+%type <n> ProcessorTerm
+%type <n> ThermalZoneTerm
+
+/* Namespace modifiers */
+
+%type <n> AliasTerm
+%type <n> NameTerm
+%type <n> ScopeTerm
+
+/* Type 1 opcodes */
+
+%type <n> BreakPointTerm
+%type <n> BreakTerm
+%type <n> CaseDefaultTermList
+%type <n> CaseTerm
+%type <n> ContinueTerm
+%type <n> DefaultTerm
+%type <n> ElseTerm
+%type <n> FatalTerm
+%type <n> ElseIfTerm
+%type <n> IfTerm
+%type <n> LoadTerm
+%type <n> NoOpTerm
+%type <n> NotifyTerm
+%type <n> ReleaseTerm
+%type <n> ResetTerm
+%type <n> ReturnTerm
+%type <n> SignalTerm
+%type <n> SleepTerm
+%type <n> StallTerm
+%type <n> SwitchTerm
+%type <n> UnloadTerm
+%type <n> WhileTerm
+/* %type <n> CaseTermList */
+
+/* Type 2 opcodes */
+
+%type <n> AcquireTerm
+%type <n> AddTerm
+%type <n> AndTerm
+%type <n> ConcatResTerm
+%type <n> ConcatTerm
+%type <n> CondRefOfTerm
+%type <n> CopyObjectTerm
+%type <n> DecTerm
+%type <n> DerefOfTerm
+%type <n> DivideTerm
+%type <n> FindSetLeftBitTerm
+%type <n> FindSetRightBitTerm
+%type <n> FromBCDTerm
+%type <n> IncTerm
+%type <n> IndexTerm
+%type <n> LAndTerm
+%type <n> LEqualTerm
+%type <n> LGreaterEqualTerm
+%type <n> LGreaterTerm
+%type <n> LLessEqualTerm
+%type <n> LLessTerm
+%type <n> LNotEqualTerm
+%type <n> LNotTerm
+%type <n> LoadTableTerm
+%type <n> LOrTerm
+%type <n> MatchTerm
+%type <n> MidTerm
+%type <n> ModTerm
+%type <n> MultiplyTerm
+%type <n> NAndTerm
+%type <n> NOrTerm
+%type <n> NotTerm
+%type <n> ObjectTypeTerm
+%type <n> OrTerm
+%type <n> RawDataBufferTerm
+%type <n> RefOfTerm
+%type <n> ShiftLeftTerm
+%type <n> ShiftRightTerm
+%type <n> SizeOfTerm
+%type <n> StoreTerm
+%type <n> SubtractTerm
+%type <n> TimerTerm
+%type <n> ToBCDTerm
+%type <n> ToBufferTerm
+%type <n> ToDecimalStringTerm
+%type <n> ToHexStringTerm
+%type <n> ToIntegerTerm
+%type <n> ToStringTerm
+%type <n> WaitTerm
+%type <n> XOrTerm
+
+/* Keywords */
+
+%type <n> AccessAttribKeyword
+%type <n> AccessTypeKeyword
+%type <n> AddressingModeKeyword
+%type <n> AddressKeyword
+%type <n> AddressSpaceKeyword
+%type <n> BitsPerByteKeyword
+%type <n> ClockPhaseKeyword
+%type <n> ClockPolarityKeyword
+%type <n> DecodeKeyword
+%type <n> DevicePolarityKeyword
+%type <n> DMATypeKeyword
+%type <n> EndianKeyword
+%type <n> FlowControlKeyword
+%type <n> InterruptLevel
+%type <n> InterruptTypeKeyword
+%type <n> IODecodeKeyword
+%type <n> IoRestrictionKeyword
+%type <n> LockRuleKeyword
+%type <n> MatchOpKeyword
+%type <n> MaxKeyword
+%type <n> MemTypeKeyword
+%type <n> MinKeyword
+%type <n> ObjectTypeKeyword
+%type <n> OptionalBusMasterKeyword
+%type <n> OptionalReadWriteKeyword
+%type <n> ParityTypeKeyword
+%type <n> PinConfigByte
+%type <n> PinConfigKeyword
+%type <n> RangeTypeKeyword
+%type <n> RegionSpaceKeyword
+%type <n> ResourceTypeKeyword
+%type <n> SerializeRuleKeyword
+%type <n> ShareTypeKeyword
+%type <n> SlaveModeKeyword
+%type <n> StopBitsKeyword
+%type <n> TranslationKeyword
+%type <n> TypeKeyword
+%type <n> UpdateRuleKeyword
+%type <n> WireModeKeyword
+%type <n> XferSizeKeyword
+%type <n> XferTypeKeyword
+
+/* Types */
+
+%type <n> SuperName
+%type <n> ObjectTypeName
+%type <n> ArgTerm
+%type <n> LocalTerm
+%type <n> DebugTerm
+
+%type <n> Integer
+%type <n> ByteConst
+%type <n> WordConst
+%type <n> DWordConst
+%type <n> QWordConst
+%type <n> String
+
+%type <n> ConstTerm
+%type <n> ConstExprTerm
+%type <n> ByteConstExpr
+%type <n> WordConstExpr
+%type <n> DWordConstExpr
+%type <n> QWordConstExpr
+
+%type <n> DWordList
+%type <n> BufferTerm
+%type <n> ByteList
+
+%type <n> PackageElement
+%type <n> PackageList
+%type <n> PackageTerm
+%type <n> VarPackageLengthTerm
+
+/* Macros */
+
+%type <n> EISAIDTerm
+%type <n> ResourceMacroList
+%type <n> ResourceMacroTerm
+%type <n> ResourceTemplateTerm
+%type <n> PldKeyword
+%type <n> PldKeywordList
+%type <n> ToPLDTerm
+%type <n> ToUUIDTerm
+%type <n> UnicodeTerm
+%type <n> PrintfArgList
+%type <n> PrintfTerm
+%type <n> FprintfTerm
+%type <n> ForTerm
+
+/* Resource Descriptors */
+
+%type <n> ConnectionTerm
+%type <n> DMATerm
+%type <n> DWordIOTerm
+%type <n> DWordMemoryTerm
+%type <n> DWordSpaceTerm
+%type <n> EndDependentFnTerm
+%type <n> ExtendedIOTerm
+%type <n> ExtendedMemoryTerm
+%type <n> ExtendedSpaceTerm
+%type <n> FixedDmaTerm
+%type <n> FixedIOTerm
+%type <n> GpioIntTerm
+%type <n> GpioIoTerm
+%type <n> I2cSerialBusTerm
+%type <n> I2cSerialBusTermV2
+%type <n> InterruptTerm
+%type <n> IOTerm
+%type <n> IRQNoFlagsTerm
+%type <n> IRQTerm
+%type <n> Memory24Term
+%type <n> Memory32FixedTerm
+%type <n> Memory32Term
+%type <n> NameSeg
+%type <n> NameString
+%type <n> QWordIOTerm
+%type <n> QWordMemoryTerm
+%type <n> QWordSpaceTerm
+%type <n> RegisterTerm
+%type <n> SpiSerialBusTerm
+%type <n> SpiSerialBusTermV2
+%type <n> StartDependentFnNoPriTerm
+%type <n> StartDependentFnTerm
+%type <n> UartSerialBusTerm
+%type <n> UartSerialBusTermV2
+%type <n> VendorLongTerm
+%type <n> VendorShortTerm
+%type <n> WordBusNumberTerm
+%type <n> WordIOTerm
+%type <n> WordSpaceTerm
+
+/* Local types that help construct the AML, not in ACPI spec */
+
+%type <n> AmlPackageLengthTerm
+%type <n> IncludeEndTerm
+%type <n> NameStringItem
+%type <n> TermArgItem
+
+%type <n> OptionalAccessSize
+%type <n> OptionalAddressingMode
+%type <n> OptionalAddressRange
+%type <n> OptionalBitsPerByte
+%type <n> OptionalBuffer_Last
+%type <n> OptionalBufferLength
+%type <n> OptionalByteConstExpr
+%type <n> OptionalCount
+%type <n> OptionalDecodeType
+%type <n> OptionalDevicePolarity
+%type <n> OptionalDWordConstExpr
+%type <n> OptionalEndian
+%type <n> OptionalFlowControl
+%type <n> OptionalIoRestriction
+%type <n> OptionalListString
+%type <n> OptionalMaxType
+%type <n> OptionalMemType
+%type <n> OptionalMinType
+%type <n> OptionalNameString
+%type <n> OptionalNameString_First
+%type <n> OptionalNameString_Last
+%type <n> OptionalObjectTypeKeyword
+%type <n> OptionalParameterTypePackage
+%type <n> OptionalParameterTypesPackage
+%type <n> OptionalParityType
+%type <n> OptionalPredicate
+%type <n> OptionalQWordConstExpr
+%type <n> OptionalRangeType
+%type <n> OptionalReference
+%type <n> OptionalResourceType
+%type <n> OptionalResourceType_First
+%type <n> OptionalReturnArg
+%type <n> OptionalSerializeRuleKeyword
+%type <n> OptionalShareType
+%type <n> OptionalShareType_First
+%type <n> OptionalSlaveMode
+%type <n> OptionalStopBits
+%type <n> OptionalStringData
+%type <n> OptionalTermArg
+%type <n> OptionalTranslationType_Last
+%type <n> OptionalType
+%type <n> OptionalType_Last
+%type <n> OptionalWireMode
+%type <n> OptionalWordConst
+%type <n> OptionalWordConstExpr
+%type <n> OptionalXferSize
+
+/*
+ * C-style expression parser
+ */
+%type <n> Expression
+%type <n> EqualsTerm
+%type <n> IndexExpTerm
diff --git a/usr/src/cmd/acpi/iasl/aslutils.c b/usr/src/cmd/acpi/iasl/aslutils.c
new file mode 100644
index 0000000000..f5ca7b7e86
--- /dev/null
+++ b/usr/src/cmd/acpi/iasl/aslutils.c
@@ -0,0 +1,981 @@
+/******************************************************************************
+ *
+ * Module Name: aslutils -- compiler utilities
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2016, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include "aslcompiler.h"
+#include "aslcompiler.y.h"
+#include "acdisasm.h"
+#include "acnamesp.h"
+#include "amlcode.h"
+#include "acapps.h"
+#include <sys/stat.h>
+
+
+#define _COMPONENT          ACPI_COMPILER
+        ACPI_MODULE_NAME    ("aslutils")
+
+
+/* Local prototypes */
+
+static void
+UtPadNameWithUnderscores (
+    char                    *NameSeg,
+    char                    *PaddedNameSeg);
+
+static void
+UtAttachNameseg (
+    ACPI_PARSE_OBJECT       *Op,
+    char                    *Name);
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    UtIsBigEndianMachine
+ *
+ * PARAMETERS:  None
+ *
+ * RETURN:      TRUE if machine is big endian
+ *              FALSE if machine is little endian
+ *
+ * DESCRIPTION: Detect whether machine is little endian or big endian.
+ *
+ ******************************************************************************/
+
+UINT8
+UtIsBigEndianMachine (
+    void)
+{
+    union {
+        UINT32              Integer;
+        UINT8               Bytes[4];
+    } Overlay =                 {0xFF000000};
+
+
+    return (Overlay.Bytes[0]); /* Returns 0xFF (TRUE) for big endian */
+}
+
+
+/******************************************************************************
+ *
+ * FUNCTION:    UtQueryForOverwrite
+ *
+ * PARAMETERS:  Pathname            - Output filename
+ *
+ * RETURN:      TRUE if file does not exist or overwrite is authorized
+ *
+ * DESCRIPTION: Query for file overwrite if it already exists.
+ *
+ ******************************************************************************/
+
+BOOLEAN
+UtQueryForOverwrite (
+    char                    *Pathname)
+{
+    struct stat             StatInfo;
+
+
+    if (!stat (Pathname, &StatInfo))
+    {
+        fprintf (stderr, "Target file \"%s\" already exists, overwrite? [y|n] ",
+            Pathname);
+
+        if (getchar () != 'y')
+        {
+            return (FALSE);
+        }
+    }
+
+    return (TRUE);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    UtDisplaySupportedTables
+ *
+ * PARAMETERS:  None
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Print all supported ACPI table names.
+ *
+ ******************************************************************************/
+
+void
+UtDisplaySupportedTables (
+    void)
+{
+    const AH_TABLE          *TableData;
+    UINT32                  i;
+
+
+    printf ("\nACPI tables supported by iASL version %8.8X:\n"
+        "  (Compiler, Disassembler, Template Generator)\n\n",
+        ACPI_CA_VERSION);
+
+    /* All ACPI tables with the common table header */
+
+    printf ("\n  Supported ACPI tables:\n");
+    for (TableData = AcpiSupportedTables, i = 1;
+         TableData->Signature; TableData++, i++)
+    {
+        printf ("%8u) %s    %s\n", i,
+            TableData->Signature, TableData->Description);
+    }
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    UtDisplayConstantOpcodes
+ *
+ * PARAMETERS:  None
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Print AML opcodes that can be used in constant expressions.
+ *
+ ******************************************************************************/
+
+void
+UtDisplayConstantOpcodes (
+    void)
+{
+    UINT32                  i;
+
+
+    printf ("Constant expression opcode information\n\n");
+
+    for (i = 0; i < sizeof (AcpiGbl_AmlOpInfo) / sizeof (ACPI_OPCODE_INFO); i++)
+    {
+        if (AcpiGbl_AmlOpInfo[i].Flags & AML_CONSTANT)
+        {
+            printf ("%s\n", AcpiGbl_AmlOpInfo[i].Name);
+        }
+    }
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    UtLocalCalloc
+ *
+ * PARAMETERS:  Size                - Bytes to be allocated
+ *
+ * RETURN:      Pointer to the allocated memory. Guaranteed to be valid.
+ *
+ * DESCRIPTION: Allocate zero-initialized memory. Aborts the compile on an
+ *              allocation failure, on the assumption that nothing more can be
+ *              accomplished.
+ *
+ ******************************************************************************/
+
+void *
+UtLocalCalloc (
+    UINT32                  Size)
+{
+    void                    *Allocated;
+
+
+    Allocated = ACPI_ALLOCATE_ZEROED (Size);
+    if (!Allocated)
+    {
+        AslCommonError (ASL_ERROR, ASL_MSG_MEMORY_ALLOCATION,
+            Gbl_CurrentLineNumber, Gbl_LogicalLineNumber,
+            Gbl_InputByteCount, Gbl_CurrentColumn,
+            Gbl_Files[ASL_FILE_INPUT].Filename, NULL);
+
+        CmCleanupAndExit ();
+        exit (1);
+    }
+
+    TotalAllocations++;
+    TotalAllocated += Size;
+    return (Allocated);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    UtBeginEvent
+ *
+ * PARAMETERS:  Name                - Ascii name of this event
+ *
+ * RETURN:      Event number (integer index)
+ *
+ * DESCRIPTION: Saves the current time with this event
+ *
+ ******************************************************************************/
+
+UINT8
+UtBeginEvent (
+    char                    *Name)
+{
+
+    if (AslGbl_NextEvent >= ASL_NUM_EVENTS)
+    {
+        AcpiOsPrintf ("Ran out of compiler event structs!\n");
+        return (AslGbl_NextEvent);
+    }
+
+    /* Init event with current (start) time */
+
+    AslGbl_Events[AslGbl_NextEvent].StartTime = AcpiOsGetTimer ();
+    AslGbl_Events[AslGbl_NextEvent].EventName = Name;
+    AslGbl_Events[AslGbl_NextEvent].Valid = TRUE;
+    return (AslGbl_NextEvent++);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    UtEndEvent
+ *
+ * PARAMETERS:  Event               - Event number (integer index)
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Saves the current time (end time) with this event
+ *
+ ******************************************************************************/
+
+void
+UtEndEvent (
+    UINT8                   Event)
+{
+
+    if (Event >= ASL_NUM_EVENTS)
+    {
+        return;
+    }
+
+    /* Insert end time for event */
+
+    AslGbl_Events[Event].EndTime = AcpiOsGetTimer ();
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    DbgPrint
+ *
+ * PARAMETERS:  Type                - Type of output
+ *              Fmt                 - Printf format string
+ *              ...                 - variable printf list
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Conditional print statement. Prints to stderr only if the
+ *              debug flag is set.
+ *
+ ******************************************************************************/
+
+void
+DbgPrint (
+    UINT32                  Type,
+    char                    *Fmt,
+    ...)
+{
+    va_list                 Args;
+
+
+    if (!Gbl_DebugFlag)
+    {
+        return;
+    }
+
+    if ((Type == ASL_PARSE_OUTPUT) &&
+        (!(AslCompilerdebug)))
+    {
+        return;
+    }
+
+    va_start (Args, Fmt);
+    (void) vfprintf (stderr, Fmt, Args);
+    va_end (Args);
+    return;
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    UtSetParseOpName
+ *
+ * PARAMETERS:  Op                  - Parse op to be named.
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Insert the ascii name of the parse opcode
+ *
+ ******************************************************************************/
+
+void
+UtSetParseOpName (
+    ACPI_PARSE_OBJECT       *Op)
+{
+
+    strncpy (Op->Asl.ParseOpName, UtGetOpName (Op->Asl.ParseOpcode),
+        ACPI_MAX_PARSEOP_NAME);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    UtDisplaySummary
+ *
+ * PARAMETERS:  FileID              - ID of outpout file
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Display compilation statistics
+ *
+ ******************************************************************************/
+
+void
+UtDisplaySummary (
+    UINT32                  FileId)
+{
+    UINT32                  i;
+
+
+    if (FileId != ASL_FILE_STDOUT)
+    {
+        /* Compiler name and version number */
+
+        FlPrintFile (FileId, "%s version %X%s [%s]\n\n",
+            ASL_COMPILER_NAME, (UINT32) ACPI_CA_VERSION, ACPI_WIDTH, __DATE__);
+    }
+
+    /* Summary of main input and output files */
+
+    if (Gbl_FileType == ASL_INPUT_TYPE_ASCII_DATA)
+    {
+        FlPrintFile (FileId,
+            "%-14s %s - %u lines, %u bytes, %u fields\n",
+            "Table Input:",
+            Gbl_Files[ASL_FILE_INPUT].Filename, Gbl_CurrentLineNumber,
+            Gbl_InputByteCount, Gbl_InputFieldCount);
+
+        if ((Gbl_ExceptionCount[ASL_ERROR] == 0) || (Gbl_IgnoreErrors))
+        {
+            FlPrintFile (FileId,
+                "%-14s %s - %u bytes\n",
+                "Binary Output:",
+                Gbl_Files[ASL_FILE_AML_OUTPUT].Filename, Gbl_TableLength);
+        }
+    }
+    else
+    {
+        FlPrintFile (FileId,
+            "%-14s %s - %u lines, %u bytes, %u keywords\n",
+            "ASL Input:",
+            Gbl_Files[ASL_FILE_INPUT].Filename, Gbl_CurrentLineNumber,
+            Gbl_OriginalInputFileSize, TotalKeywords);
+
+        /* AML summary */
+
+        if ((Gbl_ExceptionCount[ASL_ERROR] == 0) || (Gbl_IgnoreErrors))
+        {
+            if (Gbl_Files[ASL_FILE_AML_OUTPUT].Handle)
+            {
+                FlPrintFile (FileId,
+                    "%-14s %s - %u bytes, %u named objects, "
+                    "%u executable opcodes\n",
+                    "AML Output:",
+                    Gbl_Files[ASL_FILE_AML_OUTPUT].Filename,
+                    FlGetFileSize (ASL_FILE_AML_OUTPUT),
+                    TotalNamedObjects, TotalExecutableOpcodes);
+            }
+        }
+    }
+
+    /* Display summary of any optional files */
+
+    for (i = ASL_FILE_SOURCE_OUTPUT; i <= ASL_MAX_FILE_TYPE; i++)
+    {
+        if (!Gbl_Files[i].Filename || !Gbl_Files[i].Handle)
+        {
+            continue;
+        }
+
+        /* .SRC is a temp file unless specifically requested */
+
+        if ((i == ASL_FILE_SOURCE_OUTPUT) && (!Gbl_SourceOutputFlag))
+        {
+            continue;
+        }
+
+        /* .PRE is the preprocessor intermediate file */
+
+        if ((i == ASL_FILE_PREPROCESSOR)  && (!Gbl_KeepPreprocessorTempFile))
+        {
+            continue;
+        }
+
+        FlPrintFile (FileId, "%14s %s - %u bytes\n",
+            Gbl_Files[i].ShortDescription,
+            Gbl_Files[i].Filename, FlGetFileSize (i));
+    }
+
+    /* Error summary */
+
+    FlPrintFile (FileId,
+        "\nCompilation complete. %u Errors, %u Warnings, %u Remarks",
+        Gbl_ExceptionCount[ASL_ERROR],
+        Gbl_ExceptionCount[ASL_WARNING] +
+            Gbl_ExceptionCount[ASL_WARNING2] +
+            Gbl_ExceptionCount[ASL_WARNING3],
+        Gbl_ExceptionCount[ASL_REMARK]);
+
+    if (Gbl_FileType != ASL_INPUT_TYPE_ASCII_DATA)
+    {
+        FlPrintFile (FileId, ", %u Optimizations",
+            Gbl_ExceptionCount[ASL_OPTIMIZATION]);
+
+        if (TotalFolds)
+        {
+            FlPrintFile (FileId, ", %u Constants Folded", TotalFolds);
+        }
+    }
+
+    FlPrintFile (FileId, "\n");
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    UtCheckIntegerRange
+ *
+ * PARAMETERS:  Op                  - Integer parse node
+ *              LowValue            - Smallest allowed value
+ *              HighValue           - Largest allowed value
+ *
+ * RETURN:      Op if OK, otherwise NULL
+ *
+ * DESCRIPTION: Check integer for an allowable range
+ *
+ ******************************************************************************/
+
+ACPI_PARSE_OBJECT *
+UtCheckIntegerRange (
+    ACPI_PARSE_OBJECT       *Op,
+    UINT32                  LowValue,
+    UINT32                  HighValue)
+{
+
+    if (!Op)
+    {
+        return (NULL);
+    }
+
+    if ((Op->Asl.Value.Integer < LowValue) ||
+        (Op->Asl.Value.Integer > HighValue))
+    {
+        sprintf (MsgBuffer, "0x%X, allowable: 0x%X-0x%X",
+            (UINT32) Op->Asl.Value.Integer, LowValue, HighValue);
+
+        AslError (ASL_ERROR, ASL_MSG_RANGE, Op, MsgBuffer);
+        return (NULL);
+    }
+
+    return (Op);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    UtStringCacheCalloc
+ *
+ * PARAMETERS:  Length              - Size of buffer requested
+ *
+ * RETURN:      Pointer to the buffer. Aborts on allocation failure
+ *
+ * DESCRIPTION: Allocate a string buffer. Bypass the local
+ *              dynamic memory manager for performance reasons (This has a
+ *              major impact on the speed of the compiler.)
+ *
+ ******************************************************************************/
+
+char *
+UtStringCacheCalloc (
+    UINT32                  Length)
+{
+    char                    *Buffer;
+    ASL_CACHE_INFO          *Cache;
+    UINT32                  CacheSize = ASL_STRING_CACHE_SIZE;
+
+
+    if (Length > CacheSize)
+    {
+        CacheSize = Length;
+
+        if (Gbl_StringCacheList)
+        {
+            Cache = UtLocalCalloc (sizeof (Cache->Next) + CacheSize);
+
+            /* Link new cache buffer just following head of list */
+
+            Cache->Next = Gbl_StringCacheList->Next;
+            Gbl_StringCacheList->Next = Cache;
+
+            /* Leave cache management pointers alone as they pertain to head */
+
+            Gbl_StringCount++;
+            Gbl_StringSize += Length;
+
+            return (Cache->Buffer);
+        }
+    }
+
+    if ((Gbl_StringCacheNext + Length) >= Gbl_StringCacheLast)
+    {
+        /* Allocate a new buffer */
+
+        Cache = UtLocalCalloc (sizeof (Cache->Next) + CacheSize);
+
+        /* Link new cache buffer to head of list */
+
+        Cache->Next = Gbl_StringCacheList;
+        Gbl_StringCacheList = Cache;
+
+        /* Setup cache management pointers */
+
+        Gbl_StringCacheNext = Cache->Buffer;
+        Gbl_StringCacheLast = Gbl_StringCacheNext + CacheSize;
+    }
+
+    Gbl_StringCount++;
+    Gbl_StringSize += Length;
+
+    Buffer = Gbl_StringCacheNext;
+    Gbl_StringCacheNext += Length;
+    return (Buffer);
+}
+
+
+/******************************************************************************
+ *
+ * FUNCTION:    UtExpandLineBuffers
+ *
+ * PARAMETERS:  None. Updates global line buffer pointers.
+ *
+ * RETURN:      None. Reallocates the global line buffers
+ *
+ * DESCRIPTION: Called if the current line buffer becomes filled. Reallocates
+ *              all global line buffers and updates Gbl_LineBufferSize. NOTE:
+ *              Also used for the initial allocation of the buffers, when
+ *              all of the buffer pointers are NULL. Initial allocations are
+ *              of size ASL_DEFAULT_LINE_BUFFER_SIZE
+ *
+ *****************************************************************************/
+
+void
+UtExpandLineBuffers (
+    void)
+{
+    UINT32                  NewSize;
+
+
+    /* Attempt to double the size of all line buffers */
+
+    NewSize = Gbl_LineBufferSize * 2;
+    if (Gbl_CurrentLineBuffer)
+    {
+        DbgPrint (ASL_DEBUG_OUTPUT,
+            "Increasing line buffer size from %u to %u\n",
+            Gbl_LineBufferSize, NewSize);
+    }
+
+    Gbl_CurrentLineBuffer = realloc (Gbl_CurrentLineBuffer, NewSize);
+    Gbl_LineBufPtr = Gbl_CurrentLineBuffer;
+    if (!Gbl_CurrentLineBuffer)
+    {
+        goto ErrorExit;
+    }
+
+    Gbl_MainTokenBuffer = realloc (Gbl_MainTokenBuffer, NewSize);
+    if (!Gbl_MainTokenBuffer)
+    {
+        goto ErrorExit;
+    }
+
+    Gbl_MacroTokenBuffer = realloc (Gbl_MacroTokenBuffer, NewSize);
+    if (!Gbl_MacroTokenBuffer)
+    {
+        goto ErrorExit;
+    }
+
+    Gbl_ExpressionTokenBuffer = realloc (Gbl_ExpressionTokenBuffer, NewSize);
+    if (!Gbl_ExpressionTokenBuffer)
+    {
+        goto ErrorExit;
+    }
+
+    Gbl_LineBufferSize = NewSize;
+    return;
+
+
+    /* On error above, simply issue error messages and abort, cannot continue */
+
+ErrorExit:
+    printf ("Could not increase line buffer size from %u to %u\n",
+        Gbl_LineBufferSize, Gbl_LineBufferSize * 2);
+
+    AslError (ASL_ERROR, ASL_MSG_BUFFER_ALLOCATION,
+        NULL, NULL);
+    AslAbort ();
+}
+
+
+/******************************************************************************
+ *
+ * FUNCTION:    UtFreeLineBuffers
+ *
+ * PARAMETERS:  None
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Free all line buffers
+ *
+ *****************************************************************************/
+
+void
+UtFreeLineBuffers (
+    void)
+{
+
+    free (Gbl_CurrentLineBuffer);
+    free (Gbl_MainTokenBuffer);
+    free (Gbl_MacroTokenBuffer);
+    free (Gbl_ExpressionTokenBuffer);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    UtInternalizeName
+ *
+ * PARAMETERS:  ExternalName        - Name to convert
+ *              ConvertedName       - Where the converted name is returned
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Convert an external (ASL) name to an internal (AML) name
+ *
+ ******************************************************************************/
+
+ACPI_STATUS
+UtInternalizeName (
+    char                    *ExternalName,
+    char                    **ConvertedName)
+{
+    ACPI_NAMESTRING_INFO    Info;
+    ACPI_STATUS             Status;
+
+
+    if (!ExternalName)
+    {
+        return (AE_OK);
+    }
+
+    /* Get the length of the new internal name */
+
+    Info.ExternalName = ExternalName;
+    AcpiNsGetInternalNameLength (&Info);
+
+    /* We need a segment to store the internal name */
+
+    Info.InternalName = UtStringCacheCalloc (Info.Length);
+    if (!Info.InternalName)
+    {
+        return (AE_NO_MEMORY);
+    }
+
+    /* Build the name */
+
+    Status = AcpiNsBuildInternalName (&Info);
+    if (ACPI_FAILURE (Status))
+    {
+        return (Status);
+    }
+
+    *ConvertedName = Info.InternalName;
+    return (AE_OK);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    UtPadNameWithUnderscores
+ *
+ * PARAMETERS:  NameSeg             - Input nameseg
+ *              PaddedNameSeg       - Output padded nameseg
+ *
+ * RETURN:      Padded nameseg.
+ *
+ * DESCRIPTION: Pads a NameSeg with underscores if necessary to form a full
+ *              ACPI_NAME.
+ *
+ ******************************************************************************/
+
+static void
+UtPadNameWithUnderscores (
+    char                    *NameSeg,
+    char                    *PaddedNameSeg)
+{
+    UINT32                  i;
+
+
+    for (i = 0; (i < ACPI_NAME_SIZE); i++)
+    {
+        if (*NameSeg)
+        {
+            *PaddedNameSeg = *NameSeg;
+            NameSeg++;
+        }
+        else
+        {
+            *PaddedNameSeg = '_';
+        }
+
+        PaddedNameSeg++;
+    }
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    UtAttachNameseg
+ *
+ * PARAMETERS:  Op                  - Parent parse node
+ *              Name                - Full ExternalName
+ *
+ * RETURN:      None; Sets the NameSeg field in parent node
+ *
+ * DESCRIPTION: Extract the last nameseg of the ExternalName and store it
+ *              in the NameSeg field of the Op.
+ *
+ ******************************************************************************/
+
+static void
+UtAttachNameseg (
+    ACPI_PARSE_OBJECT       *Op,
+    char                    *Name)
+{
+    char                    *NameSeg;
+    char                    PaddedNameSeg[4];
+
+
+    if (!Name)
+    {
+        return;
+    }
+
+    /* Look for the last dot in the namepath */
+
+    NameSeg = strrchr (Name, '.');
+    if (NameSeg)
+    {
+        /* Found last dot, we have also found the final nameseg */
+
+        NameSeg++;
+        UtPadNameWithUnderscores (NameSeg, PaddedNameSeg);
+    }
+    else
+    {
+        /* No dots in the namepath, there is only a single nameseg. */
+        /* Handle prefixes */
+
+        while (ACPI_IS_ROOT_PREFIX (*Name) ||
+               ACPI_IS_PARENT_PREFIX (*Name))
+        {
+            Name++;
+        }
+
+        /* Remaining string should be one single nameseg */
+
+        UtPadNameWithUnderscores (Name, PaddedNameSeg);
+    }
+
+    ACPI_MOVE_NAME (Op->Asl.NameSeg, PaddedNameSeg);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    UtAttachNamepathToOwner
+ *
+ * PARAMETERS:  Op                  - Parent parse node
+ *              NameOp              - Node that contains the name
+ *
+ * RETURN:      Sets the ExternalName and Namepath in the parent node
+ *
+ * DESCRIPTION: Store the name in two forms in the parent node: The original
+ *              (external) name, and the internalized name that is used within
+ *              the ACPI namespace manager.
+ *
+ ******************************************************************************/
+
+void
+UtAttachNamepathToOwner (
+    ACPI_PARSE_OBJECT       *Op,
+    ACPI_PARSE_OBJECT       *NameOp)
+{
+    ACPI_STATUS             Status;
+
+
+    /* Full external path */
+
+    Op->Asl.ExternalName = NameOp->Asl.Value.String;
+
+    /* Save the NameOp for possible error reporting later */
+
+    Op->Asl.ParentMethod = (void *) NameOp;
+
+    /* Last nameseg of the path */
+
+    UtAttachNameseg (Op, Op->Asl.ExternalName);
+
+    /* Create internalized path */
+
+    Status = UtInternalizeName (NameOp->Asl.Value.String, &Op->Asl.Namepath);
+    if (ACPI_FAILURE (Status))
+    {
+        /* TBD: abort on no memory */
+    }
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    UtDoConstant
+ *
+ * PARAMETERS:  String              - Hex, Octal, or Decimal string
+ *
+ * RETURN:      Converted Integer
+ *
+ * DESCRIPTION: Convert a string to an integer, with error checking.
+ *
+ ******************************************************************************/
+
+UINT64
+UtDoConstant (
+    char                    *String)
+{
+    ACPI_STATUS             Status;
+    UINT64                  Converted;
+    char                    ErrBuf[64];
+
+
+    Status = AcpiUtStrtoul64 (String, ACPI_ANY_BASE,
+        ACPI_MAX64_BYTE_WIDTH, &Converted);
+
+    if (ACPI_FAILURE (Status))
+    {
+        sprintf (ErrBuf, "%s %s\n", "Conversion error:",
+            AcpiFormatException (Status));
+        AslCompilererror (ErrBuf);
+    }
+
+    return (Converted);
+}
+
+
+#ifdef _OBSOLETE_FUNCTIONS
+/* Removed 01/2016 */
+
+/*******************************************************************************
+ *
+ * FUNCTION:    UtConvertByteToHex
+ *
+ * PARAMETERS:  RawByte             - Binary data
+ *              Buffer              - Pointer to where the hex bytes will be
+ *                                    stored
+ *
+ * RETURN:      Ascii hex byte is stored in Buffer.
+ *
+ * DESCRIPTION: Perform hex-to-ascii translation. The return data is prefixed
+ *              with "0x"
+ *
+ ******************************************************************************/
+
+void
+UtConvertByteToHex (
+    UINT8                   RawByte,
+    UINT8                   *Buffer)
+{
+
+    Buffer[0] = '0';
+    Buffer[1] = 'x';
+
+    Buffer[2] = (UINT8) AcpiUtHexToAsciiChar (RawByte, 4);
+    Buffer[3] = (UINT8) AcpiUtHexToAsciiChar (RawByte, 0);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    UtConvertByteToAsmHex
+ *
+ * PARAMETERS:  RawByte             - Binary data
+ *              Buffer              - Pointer to where the hex bytes will be
+ *                                    stored
+ *
+ * RETURN:      Ascii hex byte is stored in Buffer.
+ *
+ * DESCRIPTION: Perform hex-to-ascii translation. The return data is prefixed
+ *              with '0', and a trailing 'h' is added.
+ *
+ ******************************************************************************/
+
+void
+UtConvertByteToAsmHex (
+    UINT8                   RawByte,
+    UINT8                   *Buffer)
+{
+
+    Buffer[0] = '0';
+    Buffer[1] = (UINT8) AcpiUtHexToAsciiChar (RawByte, 4);
+    Buffer[2] = (UINT8) AcpiUtHexToAsciiChar (RawByte, 0);
+    Buffer[3] = 'h';
+}
+#endif /* OBSOLETE_FUNCTIONS */
diff --git a/usr/src/uts/intel/io/acpica/utilities/utascii.c b/usr/src/cmd/acpi/iasl/asluuid.c
similarity index 51%
rename from usr/src/uts/intel/io/acpica/utilities/utascii.c
rename to usr/src/cmd/acpi/iasl/asluuid.c
index 25c02e674e..9a0fc5c0eb 100644
--- a/usr/src/uts/intel/io/acpica/utilities/utascii.c
+++ b/usr/src/cmd/acpi/iasl/asluuid.c
@@ -1,6 +1,6 @@
 /******************************************************************************
  *
- * Module Name: utascii - Utility ascii functions
+ * Module Name: asluuid-- compiler UUID support
  *
  *****************************************************************************/
 
@@ -41,121 +41,113 @@
  * POSSIBILITY OF SUCH DAMAGES.
  */
 
-#include "acpi.h"
-#include "accommon.h"
+#include "aslcompiler.h"
+
+#define _COMPONENT          ACPI_COMPILER
+        ACPI_MODULE_NAME    ("asluuid")
+
+
+extern UINT8                AcpiGbl_MapToUuidOffset[UUID_BUFFER_LENGTH];
 
 
 /*******************************************************************************
  *
- * FUNCTION:    AcpiUtValidNameseg
+ * FUNCTION:    AuValiduateUuid
  *
- * PARAMETERS:  Name            - The name or table signature to be examined.
- *                                Four characters, does not have to be a
- *                                NULL terminated string.
+ * PARAMETERS:  InString            - 36-byte formatted UUID string
  *
- * RETURN:      TRUE if signature is has 4 valid ACPI characters
+ * RETURN:      Status
  *
- * DESCRIPTION: Validate an ACPI table signature.
+ * DESCRIPTION: Check all 36 characters for correct format
  *
  ******************************************************************************/
 
-BOOLEAN
-AcpiUtValidNameseg (
-    char                    *Name)
+ACPI_STATUS
+AuValidateUuid (
+    char                    *InString)
 {
     UINT32                  i;
 
 
-    /* Validate each character in the signature */
-
-    for (i = 0; i < ACPI_NAME_SIZE; i++)
+    if (!InString || (strlen (InString) != UUID_STRING_LENGTH))
     {
-        if (!AcpiUtValidNameChar (Name[i], i))
-        {
-            return (FALSE);
-        }
+        return (AE_BAD_PARAMETER);
     }
 
-    return (TRUE);
-}
-
+    /* Check all 36 characters for correct format */
 
-/*******************************************************************************
- *
- * FUNCTION:    AcpiUtValidNameChar
- *
- * PARAMETERS:  Char            - The character to be examined
- *              Position        - Byte position (0-3)
- *
- * RETURN:      TRUE if the character is valid, FALSE otherwise
- *
- * DESCRIPTION: Check for a valid ACPI character. Must be one of:
- *              1) Upper case alpha
- *              2) numeric
- *              3) underscore
- *
- *              We allow a '!' as the last character because of the ASF! table
- *
- ******************************************************************************/
-
-BOOLEAN
-AcpiUtValidNameChar (
-    char                    Character,
-    UINT32                  Position)
-{
-
-    if (!((Character >= 'A' && Character <= 'Z') ||
-          (Character >= '0' && Character <= '9') ||
-          (Character == '_')))
+    for (i = 0; i < UUID_STRING_LENGTH; i++)
     {
-        /* Allow a '!' in the last position */
+        /* Must have 4 hyphens (dashes) in these positions: */
 
-        if (Character == '!' && Position == 3)
+        if ((i == UUID_HYPHEN1_OFFSET) ||
+            (i == UUID_HYPHEN2_OFFSET) ||
+            (i == UUID_HYPHEN3_OFFSET) ||
+            (i == UUID_HYPHEN4_OFFSET))
         {
-            return (TRUE);
+            if (InString[i] != '-')
+            {
+                return (AE_BAD_PARAMETER);
+            }
         }
+        else
+        {
+            /* All other positions must contain hex digits */
 
-        return (FALSE);
+            if (!isxdigit ((int) InString[i]))
+            {
+                return (AE_BAD_PARAMETER);
+            }
+        }
     }
 
-    return (TRUE);
+    return (AE_OK);
 }
 
 
 /*******************************************************************************
  *
- * FUNCTION:    AcpiUtCheckAndRepairAscii
+ * FUNCTION:    AuConvertUuidToString
  *
- * PARAMETERS:  Name                - Ascii string
- *              Count               - Number of characters to check
+ * PARAMETERS:  UuidBuffer          - 16-byte UUID buffer
+ *              OutString           - 36-byte formatted UUID string
  *
- * RETURN:      None
+ * RETURN:      Status
  *
- * DESCRIPTION: Ensure that the requested number of characters are printable
- *              Ascii characters. Sets non-printable and null chars to <space>.
+ * DESCRIPTION: Convert 16-byte UUID buffer to 36-byte formatted UUID string
+ *              OutString must be 37 bytes to include null terminator.
  *
  ******************************************************************************/
 
-void
-AcpiUtCheckAndRepairAscii (
-    UINT8                   *Name,
-    char                    *RepairedName,
-    UINT32                  Count)
+ACPI_STATUS
+AuConvertUuidToString (
+    char                    *UuidBuffer,
+    char                    *OutString)
 {
     UINT32                  i;
 
 
-    for (i = 0; i < Count; i++)
+    if (!UuidBuffer || !OutString)
     {
-        RepairedName[i] = (char) Name[i];
+        return (AE_BAD_PARAMETER);
+    }
 
-        if (!Name[i])
-        {
-            return;
-        }
-        if (!isprint (Name[i]))
-        {
-            RepairedName[i] = ' ';
-        }
+    for (i = 0; i < UUID_BUFFER_LENGTH; i++)
+    {
+        OutString[AcpiGbl_MapToUuidOffset[i]] =
+            AcpiUtHexToAsciiChar (UuidBuffer[i], 4);
+
+        OutString[AcpiGbl_MapToUuidOffset[i] + 1] =
+            AcpiUtHexToAsciiChar (UuidBuffer[i], 0);
     }
+
+    /* Insert required hyphens (dashes) */
+
+    OutString[UUID_HYPHEN1_OFFSET] =
+    OutString[UUID_HYPHEN2_OFFSET] =
+    OutString[UUID_HYPHEN3_OFFSET] =
+    OutString[UUID_HYPHEN4_OFFSET] = '-';
+
+    OutString[UUID_STRING_LENGTH] = 0; /* Null terminate */
+    return (AE_OK);
 }
diff --git a/usr/src/cmd/acpi/iasl/aslwalks.c b/usr/src/cmd/acpi/iasl/aslwalks.c
new file mode 100644
index 0000000000..357b92d0b3
--- /dev/null
+++ b/usr/src/cmd/acpi/iasl/aslwalks.c
@@ -0,0 +1,977 @@
+/******************************************************************************
+ *
+ * Module Name: aslwalks.c - Miscellaneous analytical parse tree walks
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2016, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include "aslcompiler.h"
+#include "aslcompiler.y.h"
+#include "acparser.h"
+#include "amlcode.h"
+
+
+#define _COMPONENT          ACPI_COMPILER
+        ACPI_MODULE_NAME    ("aslwalks")
+
+
+/* Local prototypes */
+
+static void
+AnAnalyzeStoreOperator (
+    ACPI_PARSE_OBJECT       *Op);
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AnMethodTypingWalkEnd
+ *
+ * PARAMETERS:  ASL_WALK_CALLBACK
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Ascending callback for typing walk. Complete the method
+ *              return analysis. Check methods for:
+ *              1) Initialized local variables
+ *              2) Valid arguments
+ *              3) Return types
+ *
+ ******************************************************************************/
+
+ACPI_STATUS
+AnMethodTypingWalkEnd (
+    ACPI_PARSE_OBJECT       *Op,
+    UINT32                  Level,
+    void                    *Context)
+{
+    UINT32                  ThisOpBtype;
+
+
+    switch (Op->Asl.ParseOpcode)
+    {
+    case PARSEOP_METHOD:
+
+        Op->Asl.CompileFlags |= NODE_METHOD_TYPED;
+        break;
+
+    case PARSEOP_RETURN:
+
+        if ((Op->Asl.Child) &&
+            (Op->Asl.Child->Asl.ParseOpcode != PARSEOP_DEFAULT_ARG))
+        {
+            ThisOpBtype = AnGetBtype (Op->Asl.Child);
+
+            if ((Op->Asl.Child->Asl.ParseOpcode == PARSEOP_METHODCALL) &&
+                (ThisOpBtype == (ACPI_UINT32_MAX -1)))
+            {
+                /*
+                 * The called method is untyped at this time (typically a
+                 * forward reference).
+                 *
+                 * Check for a recursive method call first. Note: the
+                 * Child->Node will be null if the method has not been
+                 * resolved.
+                 */
+                if (Op->Asl.Child->Asl.Node &&
+                    (Op->Asl.ParentMethod != Op->Asl.Child->Asl.Node->Op))
+                {
+                    /* We must type the method here */
+
+                    TrWalkParseTree (Op->Asl.Child->Asl.Node->Op,
+                        ASL_WALK_VISIT_UPWARD, NULL,
+                        AnMethodTypingWalkEnd, NULL);
+
+                    ThisOpBtype = AnGetBtype (Op->Asl.Child);
+                }
+            }
+
+            /* Returns a value, save the value type */
+
+            if (Op->Asl.ParentMethod)
+            {
+                Op->Asl.ParentMethod->Asl.AcpiBtype |= ThisOpBtype;
+            }
+        }
+        break;
+
+    default:
+
+        break;
+    }
+
+    return (AE_OK);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AnOperandTypecheckWalkEnd
+ *
+ * PARAMETERS:  ASL_WALK_CALLBACK
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Ascending callback for analysis walk. Complete method
+ *              return analysis.
+ *
+ ******************************************************************************/
+
+ACPI_STATUS
+AnOperandTypecheckWalkEnd (
+    ACPI_PARSE_OBJECT       *Op,
+    UINT32                  Level,
+    void                    *Context)
+{
+    const ACPI_OPCODE_INFO  *OpInfo;
+    UINT32                  RuntimeArgTypes;
+    UINT32                  RuntimeArgTypes2;
+    UINT32                  RequiredBtypes;
+    UINT32                  ThisNodeBtype;
+    UINT32                  CommonBtypes;
+    UINT32                  OpcodeClass;
+    ACPI_PARSE_OBJECT       *ArgOp;
+    UINT32                  ArgType;
+
+
+    switch (Op->Asl.AmlOpcode)
+    {
+    case AML_RAW_DATA_BYTE:
+    case AML_RAW_DATA_WORD:
+    case AML_RAW_DATA_DWORD:
+    case AML_RAW_DATA_QWORD:
+    case AML_RAW_DATA_BUFFER:
+    case AML_RAW_DATA_CHAIN:
+    case AML_PACKAGE_LENGTH:
+    case AML_UNASSIGNED_OPCODE:
+    case AML_DEFAULT_ARG_OP:
+
+        /* Ignore the internal (compiler-only) AML opcodes */
+
+        return (AE_OK);
+
+    default:
+
+        break;
+    }
+
+    OpInfo = AcpiPsGetOpcodeInfo (Op->Asl.AmlOpcode);
+    if (!OpInfo)
+    {
+        return (AE_OK);
+    }
+
+    ArgOp = Op->Asl.Child;
+    OpcodeClass = OpInfo->Class;
+    RuntimeArgTypes = OpInfo->RuntimeArgs;
+
+#ifdef ASL_ERROR_NAMED_OBJECT_IN_WHILE
+    /*
+     * Update 11/2008: In practice, we can't perform this check. A simple
+     * analysis is not sufficient. Also, it can cause errors when compiling
+     * disassembled code because of the way Switch operators are implemented
+     * (a While(One) loop with a named temp variable created within.)
+     */
+
+    /*
+     * If we are creating a named object, check if we are within a while loop
+     * by checking if the parent is a WHILE op. This is a simple analysis, but
+     * probably sufficient for many cases.
+     *
+     * Allow Scope(), Buffer(), and Package().
+     */
+    if (((OpcodeClass == AML_CLASS_NAMED_OBJECT) && (Op->Asl.AmlOpcode != AML_SCOPE_OP)) ||
+        ((OpcodeClass == AML_CLASS_CREATE) && (OpInfo->Flags & AML_NSNODE)))
+    {
+        if (Op->Asl.Parent->Asl.AmlOpcode == AML_WHILE_OP)
+        {
+            AslError (ASL_ERROR, ASL_MSG_NAMED_OBJECT_IN_WHILE, Op, NULL);
+        }
+    }
+#endif
+
+    /*
+     * Special case for control opcodes IF/RETURN/WHILE since they
+     * have no runtime arg list (at this time)
+     */
+    switch (Op->Asl.AmlOpcode)
+    {
+    case AML_IF_OP:
+    case AML_WHILE_OP:
+    case AML_RETURN_OP:
+
+        if (ArgOp->Asl.ParseOpcode == PARSEOP_METHODCALL)
+        {
+            /* Check for an internal method */
+
+            if (AnIsInternalMethod (ArgOp))
+            {
+                return (AE_OK);
+            }
+
+            /* The lone arg is a method call, check it */
+
+            RequiredBtypes = AnMapArgTypeToBtype (ARGI_INTEGER);
+            if (Op->Asl.AmlOpcode == AML_RETURN_OP)
+            {
+                RequiredBtypes = 0xFFFFFFFF;
+            }
+
+            ThisNodeBtype = AnGetBtype (ArgOp);
+            if (ThisNodeBtype == ACPI_UINT32_MAX)
+            {
+                return (AE_OK);
+            }
+
+            AnCheckMethodReturnValue (Op, OpInfo, ArgOp,
+                RequiredBtypes, ThisNodeBtype);
+        }
+        return (AE_OK);
+
+    case AML_EXTERNAL_OP:
+        /*
+         * Not really a "runtime" opcode since it used by disassembler only.
+         * The parser will find any issues with the operands.
+         */
+        return (AE_OK);
+
+    default:
+
+        break;
+    }
+
+    /* Ignore the non-executable opcodes */
+
+    if (RuntimeArgTypes == ARGI_INVALID_OPCODE)
+    {
+        return (AE_OK);
+    }
+
+    /*
+     * Special handling for certain opcodes.
+     */
+    switch (Op->Asl.AmlOpcode)
+    {
+        /* BankField has one TermArg */
+
+    case AML_BANK_FIELD_OP:
+
+        OpcodeClass = AML_CLASS_EXECUTE;
+        ArgOp = ArgOp->Asl.Next;
+        ArgOp = ArgOp->Asl.Next;
+        break;
+
+        /* Operation Region has 2 TermArgs */
+
+    case AML_REGION_OP:
+
+        OpcodeClass = AML_CLASS_EXECUTE;
+        ArgOp = ArgOp->Asl.Next;
+        ArgOp = ArgOp->Asl.Next;
+        break;
+
+        /* DataTableRegion has 3 TermArgs */
+
+    case AML_DATA_REGION_OP:
+
+        OpcodeClass = AML_CLASS_EXECUTE;
+        ArgOp = ArgOp->Asl.Next;
+        break;
+
+        /* Buffers/Packages have a length that is a TermArg */
+
+    case AML_BUFFER_OP:
+    case AML_PACKAGE_OP:
+    case AML_VAR_PACKAGE_OP:
+
+            /* If length is a constant, we are done */
+
+        if ((ArgOp->Asl.ParseOpcode == PARSEOP_INTEGER) ||
+            (ArgOp->Asl.ParseOpcode == PARSEOP_RAW_DATA))
+        {
+            return (AE_OK);
+        }
+        break;
+
+        /* Store can write any object to the Debug object */
+
+    case AML_STORE_OP:
+        /*
+         * If this is a Store() to the Debug object, we don't need
+         * to perform any further validation -- because a Store of
+         * any object to Debug is permitted and supported.
+         */
+        if (ArgOp->Asl.Next->Asl.AmlOpcode == AML_DEBUG_OP)
+        {
+            return (AE_OK);
+        }
+        break;
+
+    default:
+        break;
+    }
+
+    switch (OpcodeClass)
+    {
+    case AML_CLASS_EXECUTE:
+    case AML_CLASS_CREATE:
+    case AML_CLASS_CONTROL:
+    case AML_CLASS_RETURN_VALUE:
+
+        /* Reverse the runtime argument list */
+
+        RuntimeArgTypes2 = 0;
+        while ((ArgType = GET_CURRENT_ARG_TYPE (RuntimeArgTypes)))
+        {
+            RuntimeArgTypes2 <<= ARG_TYPE_WIDTH;
+            RuntimeArgTypes2 |= ArgType;
+            INCREMENT_ARG_LIST (RuntimeArgTypes);
+        }
+
+        /* Typecheck each argument */
+
+        while ((ArgType = GET_CURRENT_ARG_TYPE (RuntimeArgTypes2)))
+        {
+            /* Get the required type(s) for the argument */
+
+            RequiredBtypes = AnMapArgTypeToBtype (ArgType);
+
+            if (!ArgOp)
+            {
+                AslError (ASL_ERROR, ASL_MSG_COMPILER_INTERNAL, Op,
+                    "Null ArgOp in argument loop");
+                AslAbort ();
+            }
+
+            /* Get the actual type of the argument */
+
+            ThisNodeBtype = AnGetBtype (ArgOp);
+            if (ThisNodeBtype == ACPI_UINT32_MAX)
+            {
+                goto NextArgument;
+            }
+
+            /* Examine the arg based on the required type of the arg */
+
+            switch (ArgType)
+            {
+            case ARGI_TARGETREF:
+
+                if (ArgOp->Asl.ParseOpcode == PARSEOP_ZERO)
+                {
+                    /* ZERO is the placeholder for "don't store result" */
+
+                    ThisNodeBtype = RequiredBtypes;
+                    break;
+                }
+
+            /* Fallthrough */
+
+            case ARGI_STORE_TARGET:
+
+                if (ArgOp->Asl.ParseOpcode == PARSEOP_INTEGER)
+                {
+                    /*
+                     * This is the case where an original reference to a resource
+                     * descriptor field has been replaced by an (Integer) offset.
+                     * These named fields are supported at compile-time only;
+                     * the names are not passed to the interpreter (via the AML).
+                     */
+                    if ((ArgOp->Asl.Node->Type == ACPI_TYPE_LOCAL_RESOURCE_FIELD) ||
+                        (ArgOp->Asl.Node->Type == ACPI_TYPE_LOCAL_RESOURCE))
+                    {
+                        AslError (ASL_ERROR, ASL_MSG_RESOURCE_FIELD,
+                            ArgOp, NULL);
+                    }
+                    else
+                    {
+                        AslError (ASL_ERROR, ASL_MSG_INVALID_TYPE,
+                            ArgOp, NULL);
+                    }
+                }
+                break;
+
+
+#ifdef __FUTURE_IMPLEMENTATION
+/*
+ * Possible future typechecking support
+ */
+            case ARGI_REFERENCE:            /* References */
+            case ARGI_INTEGER_REF:
+            case ARGI_OBJECT_REF:
+            case ARGI_DEVICE_REF:
+
+                switch (ArgOp->Asl.ParseOpcode)
+                {
+                case PARSEOP_LOCAL0:
+                case PARSEOP_LOCAL1:
+                case PARSEOP_LOCAL2:
+                case PARSEOP_LOCAL3:
+                case PARSEOP_LOCAL4:
+                case PARSEOP_LOCAL5:
+                case PARSEOP_LOCAL6:
+                case PARSEOP_LOCAL7:
+
+                    /* TBD: implement analysis of current value (type) of the local */
+                    /* For now, just treat any local as a typematch */
+
+                    /*ThisNodeBtype = RequiredBtypes;*/
+                    break;
+
+                case PARSEOP_ARG0:
+                case PARSEOP_ARG1:
+                case PARSEOP_ARG2:
+                case PARSEOP_ARG3:
+                case PARSEOP_ARG4:
+                case PARSEOP_ARG5:
+                case PARSEOP_ARG6:
+
+                    /* Hard to analyze argument types, so we won't */
+                    /* for now. Just treat any arg as a typematch */
+
+                    /* ThisNodeBtype = RequiredBtypes; */
+                    break;
+
+                case PARSEOP_DEBUG:
+                case PARSEOP_REFOF:
+                case PARSEOP_INDEX:
+                default:
+
+                    break;
+                }
+                break;
+#endif
+            case ARGI_INTEGER:
+            default:
+
+                break;
+            }
+
+
+            /* Check for a type mismatch (required versus actual) */
+
+            CommonBtypes = ThisNodeBtype & RequiredBtypes;
+
+            if (ArgOp->Asl.ParseOpcode == PARSEOP_METHODCALL)
+            {
+                if (AnIsInternalMethod (ArgOp))
+                {
+                    return (AE_OK);
+                }
+
+                /* Check a method call for a valid return value */
+
+                AnCheckMethodReturnValue (Op, OpInfo, ArgOp,
+                    RequiredBtypes, ThisNodeBtype);
+            }
+
+            /*
+             * Now check if the actual type(s) match at least one
+             * bit to the required type
+             */
+            else if (!CommonBtypes)
+            {
+                /* No match -- this is a type mismatch error */
+
+                AnFormatBtype (StringBuffer, ThisNodeBtype);
+                AnFormatBtype (StringBuffer2, RequiredBtypes);
+
+                sprintf (MsgBuffer, "[%s] found, %s operator requires [%s]",
+                    StringBuffer, OpInfo->Name, StringBuffer2);
+
+                AslError (ASL_ERROR, ASL_MSG_INVALID_TYPE,
+                    ArgOp, MsgBuffer);
+            }
+
+        NextArgument:
+            ArgOp = ArgOp->Asl.Next;
+            INCREMENT_ARG_LIST (RuntimeArgTypes2);
+        }
+        break;
+
+    default:
+
+        break;
+    }
+
+    return (AE_OK);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AnOtherSemanticAnalysisWalkBegin
+ *
+ * PARAMETERS:  ASL_WALK_CALLBACK
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Descending callback for the analysis walk. Checks for
+ *              miscellaneous issues in the code.
+ *
+ ******************************************************************************/
+
+ACPI_STATUS
+AnOtherSemanticAnalysisWalkBegin (
+    ACPI_PARSE_OBJECT       *Op,
+    UINT32                  Level,
+    void                    *Context)
+{
+    ACPI_PARSE_OBJECT       *ArgOp;
+    ACPI_PARSE_OBJECT       *PrevArgOp = NULL;
+    const ACPI_OPCODE_INFO  *OpInfo;
+    ACPI_NAMESPACE_NODE     *Node;
+
+
+    OpInfo = AcpiPsGetOpcodeInfo (Op->Asl.AmlOpcode);
+
+
+    /*
+     * Determine if an execution class operator actually does something by
+     * checking if it has a target and/or the function return value is used.
+     * (Target is optional, so a standalone statement can actually do nothing.)
+     */
+    if ((OpInfo->Class == AML_CLASS_EXECUTE) &&
+        (OpInfo->Flags & AML_HAS_RETVAL) &&
+        (!AnIsResultUsed (Op)))
+    {
+        if (OpInfo->Flags & AML_HAS_TARGET)
+        {
+            /*
+             * Find the target node, it is always the last child. If the target
+             * is not specified in the ASL, a default node of type Zero was
+             * created by the parser.
+             */
+            ArgOp = Op->Asl.Child;
+            while (ArgOp->Asl.Next)
+            {
+                PrevArgOp = ArgOp;
+                ArgOp = ArgOp->Asl.Next;
+            }
+
+            /* Divide() is the only weird case, it has two targets */
+
+            if (Op->Asl.AmlOpcode == AML_DIVIDE_OP)
+            {
+                if ((ArgOp->Asl.ParseOpcode == PARSEOP_ZERO) &&
+                    (PrevArgOp) &&
+                    (PrevArgOp->Asl.ParseOpcode == PARSEOP_ZERO))
+                {
+                    AslError (ASL_ERROR, ASL_MSG_RESULT_NOT_USED,
+                        Op, Op->Asl.ExternalName);
+                }
+            }
+
+            else if (ArgOp->Asl.ParseOpcode == PARSEOP_ZERO)
+            {
+                AslError (ASL_ERROR, ASL_MSG_RESULT_NOT_USED,
+                    Op, Op->Asl.ExternalName);
+            }
+        }
+        else
+        {
+            /*
+             * Has no target and the result is not used. Only a couple opcodes
+             * can have this combination.
+             */
+            switch (Op->Asl.ParseOpcode)
+            {
+            case PARSEOP_ACQUIRE:
+            case PARSEOP_WAIT:
+            case PARSEOP_LOADTABLE:
+
+                break;
+
+            default:
+
+                AslError (ASL_ERROR, ASL_MSG_RESULT_NOT_USED,
+                    Op, Op->Asl.ExternalName);
+                break;
+            }
+        }
+    }
+
+
+    /*
+     * Semantic checks for individual ASL operators
+     */
+    switch (Op->Asl.ParseOpcode)
+    {
+    case PARSEOP_STORE:
+
+        if (Gbl_DoTypechecking)
+        {
+            AnAnalyzeStoreOperator (Op);
+        }
+        break;
+
+
+    case PARSEOP_ACQUIRE:
+    case PARSEOP_WAIT:
+        /*
+         * Emit a warning if the timeout parameter for these operators is not
+         * ACPI_WAIT_FOREVER, and the result value from the operator is not
+         * checked, meaning that a timeout could happen, but the code
+         * would not know about it.
+         */
+
+        /* First child is the namepath, 2nd child is timeout */
+
+        ArgOp = Op->Asl.Child;
+        ArgOp = ArgOp->Asl.Next;
+
+        /*
+         * Check for the WAIT_FOREVER case - defined by the ACPI spec to be
+         * 0xFFFF or greater
+         */
+        if (((ArgOp->Asl.ParseOpcode == PARSEOP_WORDCONST) ||
+             (ArgOp->Asl.ParseOpcode == PARSEOP_INTEGER))  &&
+             (ArgOp->Asl.Value.Integer >= (UINT64) ACPI_WAIT_FOREVER))
+        {
+            break;
+        }
+
+        /*
+         * The operation could timeout. If the return value is not used
+         * (indicates timeout occurred), issue a warning
+         */
+        if (!AnIsResultUsed (Op))
+        {
+            AslError (ASL_WARNING, ASL_MSG_TIMEOUT, ArgOp,
+                Op->Asl.ExternalName);
+        }
+        break;
+
+    case PARSEOP_CREATEFIELD:
+        /*
+         * Check for a zero Length (NumBits) operand. NumBits is the 3rd operand
+         */
+        ArgOp = Op->Asl.Child;
+        ArgOp = ArgOp->Asl.Next;
+        ArgOp = ArgOp->Asl.Next;
+
+        if ((ArgOp->Asl.ParseOpcode == PARSEOP_ZERO) ||
+           ((ArgOp->Asl.ParseOpcode == PARSEOP_INTEGER) &&
+            (ArgOp->Asl.Value.Integer == 0)))
+        {
+            AslError (ASL_ERROR, ASL_MSG_NON_ZERO, ArgOp, NULL);
+        }
+        break;
+
+    case PARSEOP_CONNECTION:
+        /*
+         * Ensure that the referenced operation region has the correct SPACE_ID.
+         * From the grammar/parser, we know the parent is a FIELD definition.
+         */
+        ArgOp = Op->Asl.Parent;     /* Field definition */
+        ArgOp = ArgOp->Asl.Child;   /* First child is the OpRegion Name */
+        Node = ArgOp->Asl.Node;     /* OpRegion namespace node */
+        if (!Node)
+        {
+            break;
+        }
+
+        ArgOp = Node->Op;           /* OpRegion definition */
+        ArgOp = ArgOp->Asl.Child;   /* First child is the OpRegion Name */
+        ArgOp = ArgOp->Asl.Next;    /* Next peer is the SPACE_ID (what we want) */
+
+        /*
+         * The Connection() operator is only valid for the following operation
+         * region SpaceIds: GeneralPurposeIo and GenericSerialBus.
+         */
+        if ((ArgOp->Asl.Value.Integer != ACPI_ADR_SPACE_GPIO) &&
+            (ArgOp->Asl.Value.Integer != ACPI_ADR_SPACE_GSBUS))
+        {
+            AslError (ASL_ERROR, ASL_MSG_CONNECTION_INVALID, Op, NULL);
+        }
+        break;
+
+    case PARSEOP_FIELD:
+        /*
+         * Ensure that fields for GeneralPurposeIo and GenericSerialBus
+         * contain at least one Connection() operator
+         */
+        ArgOp = Op->Asl.Child;      /* 1st child is the OpRegion Name */
+        Node = ArgOp->Asl.Node;     /* OpRegion namespace node */
+        if (!Node)
+        {
+            break;
+        }
+
+        ArgOp = Node->Op;           /* OpRegion definition */
+        ArgOp = ArgOp->Asl.Child;   /* First child is the OpRegion Name */
+        ArgOp = ArgOp->Asl.Next;    /* Next peer is the SPACE_ID (what we want) */
+
+        /* We are only interested in GeneralPurposeIo and GenericSerialBus */
+
+        if ((ArgOp->Asl.Value.Integer != ACPI_ADR_SPACE_GPIO) &&
+            (ArgOp->Asl.Value.Integer != ACPI_ADR_SPACE_GSBUS))
+        {
+            break;
+        }
+
+        ArgOp = Op->Asl.Child;      /* 1st child is the OpRegion Name */
+        ArgOp = ArgOp->Asl.Next;    /* AccessType */
+        ArgOp = ArgOp->Asl.Next;    /* LockRule */
+        ArgOp = ArgOp->Asl.Next;    /* UpdateRule */
+        ArgOp = ArgOp->Asl.Next;    /* Start of FieldUnitList */
+
+        /* Walk the FieldUnitList */
+
+        while (ArgOp)
+        {
+            if (ArgOp->Asl.ParseOpcode == PARSEOP_CONNECTION)
+            {
+                break;
+            }
+            else if (ArgOp->Asl.ParseOpcode == PARSEOP_NAMESEG)
+            {
+                AslError (ASL_ERROR, ASL_MSG_CONNECTION_MISSING, ArgOp, NULL);
+                break;
+            }
+
+            ArgOp = ArgOp->Asl.Next;
+        }
+        break;
+
+    default:
+
+        break;
+    }
+
+    return (AE_OK);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AnAnalyzeStoreOperator
+ *
+ * PARAMETERS:  Op                  - Store() operator
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Analyze a store operator. Mostly for stores to/from package
+ *              objects where there are more restrictions than other data
+ *              types.
+ *
+ ******************************************************************************/
+
+static void
+AnAnalyzeStoreOperator (
+    ACPI_PARSE_OBJECT       *Op)
+{
+    ACPI_NAMESPACE_NODE     *SourceNode;
+    ACPI_NAMESPACE_NODE     *TargetNode;
+    ACPI_PARSE_OBJECT       *SourceOperandOp;
+    ACPI_PARSE_OBJECT       *TargetOperandOp;
+    UINT32                  SourceOperandBtype;
+    UINT32                  TargetOperandBtype;
+
+
+    /* Extract the two operands for STORE */
+
+    SourceOperandOp = Op->Asl.Child;
+    TargetOperandOp = SourceOperandOp->Asl.Next;
+
+    /*
+     * Ignore these Source operand opcodes, they cannot be typechecked,
+     * the actual result is unknown here.
+     */
+    switch (SourceOperandOp->Asl.ParseOpcode)
+    {
+    /* For these, type of the returned value is unknown at compile time */
+
+    case PARSEOP_DEREFOF:
+    case PARSEOP_METHODCALL:
+    case PARSEOP_STORE:
+    case PARSEOP_COPYOBJECT:
+
+        return;
+
+    case PARSEOP_INDEX:
+    case PARSEOP_REFOF:
+
+        if (!Gbl_EnableReferenceTypechecking)
+        {
+            return;
+        }
+
+        /*
+         * These opcodes always return an object reference, and thus
+         * the result can only be stored to a Local, Arg, or Debug.
+         */
+        if (TargetOperandOp->Asl.AmlOpcode == AML_DEBUG_OP)
+        {
+            return;
+        }
+
+        if ((TargetOperandOp->Asl.AmlOpcode < AML_LOCAL0) ||
+            (TargetOperandOp->Asl.AmlOpcode > AML_ARG6))
+        {
+            AslError (ASL_ERROR, ASL_MSG_INVALID_TYPE, TargetOperandOp,
+                "Source [Reference], Target must be [Local/Arg/Debug]");
+        }
+        return;
+
+    default:
+        break;
+    }
+
+    /*
+     * Ignore these Target operand opcodes, they cannot be typechecked
+     */
+    switch (TargetOperandOp->Asl.ParseOpcode)
+    {
+    case PARSEOP_DEBUG:
+    case PARSEOP_DEREFOF:
+    case PARSEOP_REFOF:
+    case PARSEOP_INDEX:
+
+        return;
+
+    case PARSEOP_METHODCALL:
+        /*
+         * A target is not allowed to be a method call.
+         * It is not supported by the ACPICA interpreter, nor is it
+         * supported by the MS ASL compiler or the MS interpreter.
+         * Although legal syntax up until ACPI 6.1, support for this
+         * will be removed for ACPI 6.2 (02/2016)
+         */
+        AslError (ASL_ERROR, ASL_MSG_SYNTAX,
+            TargetOperandOp, "Illegal method invocation as a target operand");
+        return;
+
+    default:
+        break;
+    }
+
+    /*
+     * Ignore typecheck for External() operands of type "UnknownObj",
+     * we don't know the actual type (source or target).
+     */
+    SourceNode = SourceOperandOp->Asl.Node;
+    if (SourceNode &&
+        (SourceNode->Flags & ANOBJ_IS_EXTERNAL) &&
+        (SourceNode->Type == ACPI_TYPE_ANY))
+    {
+        return;
+    }
+
+    TargetNode = TargetOperandOp->Asl.Node;
+    if (TargetNode &&
+        (TargetNode->Flags & ANOBJ_IS_EXTERNAL) &&
+        (TargetNode->Type == ACPI_TYPE_ANY))
+    {
+        return;
+    }
+
+    /*
+     * A NULL node with a namepath AML opcode indicates non-existent
+     * name. Just return, the error message is generated elsewhere.
+     */
+    if ((!SourceNode && (SourceOperandOp->Asl.AmlOpcode == AML_INT_NAMEPATH_OP)) ||
+        (!TargetNode && (TargetOperandOp->Asl.AmlOpcode == AML_INT_NAMEPATH_OP)))
+    {
+        return;
+    }
+
+    /*
+     * Simple check for source same as target via NS node.
+     * -- Could be expanded to locals and args.
+     */
+    if (SourceNode && TargetNode)
+    {
+        if (SourceNode == TargetNode)
+        {
+            AslError (ASL_WARNING, ASL_MSG_DUPLICATE_ITEM,
+                TargetOperandOp, "Source is the same as Target");
+            return;
+        }
+    }
+
+    /* Ignore typecheck if either source or target is a local or arg */
+
+    if ((SourceOperandOp->Asl.AmlOpcode >= AML_LOCAL0) &&
+        (SourceOperandOp->Asl.AmlOpcode <= AML_ARG6))
+    {
+        return; /* Cannot type a local/arg at compile time */
+    }
+
+    if ((TargetOperandOp->Asl.AmlOpcode >= AML_LOCAL0) &&
+        (TargetOperandOp->Asl.AmlOpcode <= AML_ARG6))
+    {
+        return; /* Cannot type a local/arg at compile time */
+    }
+
+    /*
+     * Package objects are a special case because they cannot by implicitly
+     * converted to/from anything. Check for these two illegal cases:
+     *
+     *      Store (non-package, package)
+     *      Store (package, non-package)
+     */
+    SourceOperandBtype = AnGetBtype (SourceOperandOp);
+    TargetOperandBtype = AnGetBtype (TargetOperandOp);
+
+    /* Check source first for (package, non-package) case */
+
+    if (SourceOperandBtype & ACPI_BTYPE_PACKAGE)
+    {
+        /* If Source is PACKAGE-->Target must be PACKAGE */
+
+        if (!(TargetOperandBtype & ACPI_BTYPE_PACKAGE))
+        {
+            AslError (ASL_ERROR, ASL_MSG_INVALID_TYPE, TargetOperandOp,
+                "Source is [Package], Target must be a package also");
+        }
+    }
+
+    /* Else check target for (non-package, package) case */
+
+    else if (TargetOperandBtype & ACPI_BTYPE_PACKAGE)
+    {
+        /* If Target is PACKAGE, Source must be PACKAGE */
+
+        if (!(SourceOperandBtype & ACPI_BTYPE_PACKAGE))
+        {
+            AslError (ASL_ERROR, ASL_MSG_INVALID_TYPE, SourceOperandOp,
+                "Target is [Package], Source must be a package also");
+        }
+    }
+}
diff --git a/usr/src/cmd/acpi/iasl/aslxref.c b/usr/src/cmd/acpi/iasl/aslxref.c
new file mode 100644
index 0000000000..a2cb6b3324
--- /dev/null
+++ b/usr/src/cmd/acpi/iasl/aslxref.c
@@ -0,0 +1,1272 @@
+/******************************************************************************
+ *
+ * Module Name: aslxref - Namespace cross-reference
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2016, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include "aslcompiler.h"
+#include "aslcompiler.y.h"
+#include "acparser.h"
+#include "amlcode.h"
+#include "acnamesp.h"
+#include "acdispat.h"
+
+
+#define _COMPONENT          ACPI_COMPILER
+        ACPI_MODULE_NAME    ("aslxref")
+
+/* Local prototypes */
+
+static ACPI_STATUS
+XfNamespaceLocateBegin (
+    ACPI_PARSE_OBJECT       *Op,
+    UINT32                  Level,
+    void                    *Context);
+
+static ACPI_STATUS
+XfNamespaceLocateEnd (
+    ACPI_PARSE_OBJECT       *Op,
+    UINT32                  Level,
+    void                    *Context);
+
+static ACPI_PARSE_OBJECT *
+XfGetParentMethod (
+    ACPI_PARSE_OBJECT       *Op);
+
+static BOOLEAN
+XfObjectExists (
+    char                    *Name);
+
+static ACPI_STATUS
+XfCompareOneNamespaceObject (
+    ACPI_HANDLE             ObjHandle,
+    UINT32                  Level,
+    void                    *Context,
+    void                    **ReturnValue);
+
+static void
+XfCheckFieldRange (
+    ACPI_PARSE_OBJECT       *Op,
+    UINT32                  RegionBitLength,
+    UINT32                  FieldBitOffset,
+    UINT32                  FieldBitLength,
+    UINT32                  AccessBitWidth);
+
+#ifdef __UNDER_DEVELOPMENT
+static ACPI_PARSE_OBJECT *
+XfGetParentMethod (
+    ACPI_PARSE_OBJECT       *Op);
+
+static void
+XfCheckIllegalReference (
+    ACPI_PARSE_OBJECT       *Op,
+    ACPI_NAMESPACE_NODE     *Node);
+
+static BOOLEAN
+XfIsObjectParental (
+    ACPI_PARSE_OBJECT       *MethodOp1,
+    ACPI_PARSE_OBJECT       *MethodOp2);
+#endif
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    XfCrossReferenceNamespace
+ *
+ * PARAMETERS:  None
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Perform a cross reference check of the parse tree against the
+ *              namespace. Every named referenced within the parse tree
+ *              should be get resolved with a namespace lookup. If not, the
+ *              original reference in the ASL code is invalid -- i.e., refers
+ *              to a non-existent object.
+ *
+ * NOTE:  The ASL "External" operator causes the name to be inserted into the
+ *        namespace so that references to the external name will be resolved
+ *        correctly here.
+ *
+ ******************************************************************************/
+
+ACPI_STATUS
+XfCrossReferenceNamespace (
+    void)
+{
+    ACPI_WALK_STATE         *WalkState;
+
+
+    /*
+     * Create a new walk state for use when looking up names
+     * within the namespace (Passed as context to the callbacks)
+     */
+    WalkState = AcpiDsCreateWalkState (0, NULL, NULL, NULL);
+    if (!WalkState)
+    {
+        return (AE_NO_MEMORY);
+    }
+
+    /* Walk the entire parse tree */
+
+    TrWalkParseTree (Gbl_ParseTreeRoot, ASL_WALK_VISIT_TWICE,
+        XfNamespaceLocateBegin, XfNamespaceLocateEnd, WalkState);
+
+    ACPI_FREE (WalkState);
+    return (AE_OK);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    XfObjectExists
+ *
+ * PARAMETERS:  Name            - 4 char ACPI name
+ *
+ * RETURN:      TRUE if name exists in namespace
+ *
+ * DESCRIPTION: Walk the namespace to find an object
+ *
+ ******************************************************************************/
+
+static BOOLEAN
+XfObjectExists (
+    char                    *Name)
+{
+    ACPI_STATUS             Status;
+
+
+    /* Walk entire namespace from the supplied root */
+
+    Status = AcpiNsWalkNamespace (ACPI_TYPE_ANY, ACPI_ROOT_OBJECT,
+        ACPI_UINT32_MAX, FALSE, XfCompareOneNamespaceObject, NULL,
+        Name, NULL);
+    if (Status == AE_CTRL_TRUE)
+    {
+        /* At least one instance of the name was found */
+
+        return (TRUE);
+    }
+
+    return (FALSE);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    XfCompareOneNamespaceObject
+ *
+ * PARAMETERS:  ACPI_WALK_CALLBACK
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Compare name of one object.
+ *
+ ******************************************************************************/
+
+static ACPI_STATUS
+XfCompareOneNamespaceObject (
+    ACPI_HANDLE             ObjHandle,
+    UINT32                  Level,
+    void                    *Context,
+    void                    **ReturnValue)
+{
+    ACPI_NAMESPACE_NODE     *Node = (ACPI_NAMESPACE_NODE *) ObjHandle;
+
+
+    /* Simply check the name */
+
+    if (*((UINT32 *) (Context)) == Node->Name.Integer)
+    {
+        /* Abort walk if we found one instance */
+
+        return (AE_CTRL_TRUE);
+    }
+
+    return (AE_OK);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    XfCheckFieldRange
+ *
+ * PARAMETERS:  RegionBitLength     - Length of entire parent region
+ *              FieldBitOffset      - Start of the field unit (within region)
+ *              FieldBitLength      - Entire length of field unit
+ *              AccessBitWidth      - Access width of the field unit
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Check one field unit to make sure it fits in the parent
+ *              op region.
+ *
+ * Note: AccessBitWidth must be either 8,16,32, or 64
+ *
+ ******************************************************************************/
+
+static void
+XfCheckFieldRange (
+    ACPI_PARSE_OBJECT       *Op,
+    UINT32                  RegionBitLength,
+    UINT32                  FieldBitOffset,
+    UINT32                  FieldBitLength,
+    UINT32                  AccessBitWidth)
+{
+    UINT32                  FieldEndBitOffset;
+
+
+    /*
+     * Check each field unit against the region size. The entire
+     * field unit (start offset plus length) must fit within the
+     * region.
+     */
+    FieldEndBitOffset = FieldBitOffset + FieldBitLength;
+
+    if (FieldEndBitOffset > RegionBitLength)
+    {
+        /* Field definition itself is beyond the end-of-region */
+
+        AslError (ASL_ERROR, ASL_MSG_FIELD_UNIT_OFFSET, Op, NULL);
+        return;
+    }
+
+    /*
+     * Now check that the field plus AccessWidth doesn't go beyond
+     * the end-of-region. Assumes AccessBitWidth is a power of 2
+     */
+    FieldEndBitOffset = ACPI_ROUND_UP (FieldEndBitOffset, AccessBitWidth);
+
+    if (FieldEndBitOffset > RegionBitLength)
+    {
+        /* Field definition combined with the access is beyond EOR */
+
+        AslError (ASL_ERROR, ASL_MSG_FIELD_UNIT_ACCESS_WIDTH, Op, NULL);
+    }
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    XfGetParentMethod
+ *
+ * PARAMETERS:  Op                      - Parse Op to be checked
+ *
+ * RETURN:      Control method Op if found. NULL otherwise
+ *
+ * DESCRIPTION: Find the control method parent of a parse op. Returns NULL if
+ *              the input Op is not within a control method.
+ *
+ ******************************************************************************/
+
+static ACPI_PARSE_OBJECT *
+XfGetParentMethod (
+    ACPI_PARSE_OBJECT       *Op)
+{
+    ACPI_PARSE_OBJECT       *NextOp;
+
+
+    NextOp = Op->Asl.Parent;
+    while (NextOp)
+    {
+        if (NextOp->Asl.AmlOpcode == AML_METHOD_OP)
+        {
+            return (NextOp);
+        }
+
+        NextOp = NextOp->Asl.Parent;
+    }
+
+    return (NULL); /* No parent method found */
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    XfNamespaceLocateBegin
+ *
+ * PARAMETERS:  ASL_WALK_CALLBACK
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Descending callback used during cross-reference. For named
+ *              object references, attempt to locate the name in the
+ *              namespace.
+ *
+ * NOTE: ASL references to named fields within resource descriptors are
+ *       resolved to integer values here. Therefore, this step is an
+ *       important part of the code generation. We don't know that the
+ *       name refers to a resource descriptor until now.
+ *
+ ******************************************************************************/
+
+static ACPI_STATUS
+XfNamespaceLocateBegin (
+    ACPI_PARSE_OBJECT       *Op,
+    UINT32                  Level,
+    void                    *Context)
+{
+    ACPI_WALK_STATE         *WalkState = (ACPI_WALK_STATE *) Context;
+    ACPI_NAMESPACE_NODE     *Node;
+    ACPI_STATUS             Status;
+    ACPI_OBJECT_TYPE        ObjectType;
+    char                    *Path;
+    UINT8                   PassedArgs;
+    ACPI_PARSE_OBJECT       *NextOp;
+    ACPI_PARSE_OBJECT       *OwningOp;
+    ACPI_PARSE_OBJECT       *SpaceIdOp;
+    UINT32                  MinimumLength;
+    UINT32                  Offset;
+    UINT32                  FieldBitLength;
+    UINT32                  TagBitLength;
+    UINT8                   Message = 0;
+    const ACPI_OPCODE_INFO  *OpInfo;
+    UINT32                  Flags;
+    ASL_METHOD_LOCAL        *MethodLocals = NULL;
+    ASL_METHOD_LOCAL        *MethodArgs = NULL;
+    int                     RegisterNumber;
+    UINT32                  i;
+
+
+    ACPI_FUNCTION_TRACE_PTR (XfNamespaceLocateBegin, Op);
+
+
+    if ((Op->Asl.AmlOpcode == AML_METHOD_OP) && Op->Asl.Node)
+    {
+        Node = Op->Asl.Node;
+
+        /* Support for method LocalX/ArgX analysis */
+
+        if (!Node->MethodLocals)
+        {
+            /* Create local/arg info blocks */
+
+            MethodLocals = UtLocalCalloc (
+                sizeof (ASL_METHOD_LOCAL) * ACPI_METHOD_NUM_LOCALS);
+            Node->MethodLocals = MethodLocals;
+
+            MethodArgs = UtLocalCalloc (
+                sizeof (ASL_METHOD_LOCAL) * ACPI_METHOD_NUM_ARGS);
+            Node->MethodArgs = MethodArgs;
+
+            /*
+             * Get the method argument count
+             * First, get the name node
+             */
+            NextOp = Op->Asl.Child;
+
+            /* Get the NumArguments node */
+
+            NextOp = NextOp->Asl.Next;
+            Node->ArgCount = (UINT8)
+                (((UINT8) NextOp->Asl.Value.Integer) & 0x07);
+
+            /* We will track all posible ArgXs */
+
+            for (i = 0; i < ACPI_METHOD_NUM_ARGS; i++)
+            {
+                if (i < Node->ArgCount)
+                {
+                    /* Real Args are always "initialized" */
+
+                    MethodArgs[i].Flags = ASL_ARG_INITIALIZED;
+                }
+                else
+                {
+                    /* Other ArgXs can be used as locals */
+
+                    MethodArgs[i].Flags = ASL_ARG_IS_LOCAL;
+                }
+
+                MethodArgs[i].Op = Op;
+            }
+        }
+    }
+
+    /*
+     * If this node is the actual declaration of a name
+     * [such as the XXXX name in "Method (XXXX)"],
+     * we are not interested in it here. We only care about names that are
+     * references to other objects within the namespace and the parent objects
+     * of name declarations
+     */
+    if (Op->Asl.CompileFlags & NODE_IS_NAME_DECLARATION)
+    {
+        return_ACPI_STATUS (AE_OK);
+    }
+
+    OpInfo = AcpiPsGetOpcodeInfo (Op->Asl.AmlOpcode);
+
+    /* Check method LocalX variables */
+
+    if (OpInfo->Type == AML_TYPE_LOCAL_VARIABLE)
+    {
+        /* Find parent method Op */
+
+        NextOp = XfGetParentMethod (Op);
+        if (!NextOp)
+        {
+            return_ACPI_STATUS (AE_OK);
+        }
+
+        /* Get method node */
+
+        Node = NextOp->Asl.Node;
+
+        RegisterNumber = Op->Asl.AmlOpcode & 0x0007; /* 0x60 through 0x67 */
+        MethodLocals = Node->MethodLocals;
+
+        if (Op->Asl.CompileFlags & NODE_IS_TARGET)
+        {
+            /* Local is being initialized */
+
+            MethodLocals[RegisterNumber].Flags |= ASL_LOCAL_INITIALIZED;
+            MethodLocals[RegisterNumber].Op = Op;
+
+            return_ACPI_STATUS (AE_OK);
+        }
+
+        /* Mark this Local as referenced */
+
+        MethodLocals[RegisterNumber].Flags |= ASL_LOCAL_REFERENCED;
+        MethodLocals[RegisterNumber].Op = Op;
+
+        return_ACPI_STATUS (AE_OK);
+    }
+
+    /* Check method ArgX variables */
+
+    if (OpInfo->Type == AML_TYPE_METHOD_ARGUMENT)
+    {
+        /* Find parent method Op */
+
+        NextOp = XfGetParentMethod (Op);
+        if (!NextOp)
+        {
+            return_ACPI_STATUS (AE_OK);
+        }
+
+        /* Get method node */
+
+        Node = NextOp->Asl.Node;
+
+        /* Get Arg # */
+
+        RegisterNumber = Op->Asl.AmlOpcode - AML_ARG0; /* 0x68 through 0x6F */
+        MethodArgs = Node->MethodArgs;
+
+        if (Op->Asl.CompileFlags & NODE_IS_TARGET)
+        {
+            /* Arg is being initialized */
+
+            MethodArgs[RegisterNumber].Flags |= ASL_ARG_INITIALIZED;
+            MethodArgs[RegisterNumber].Op = Op;
+
+            return_ACPI_STATUS (AE_OK);
+        }
+
+        /* Mark this Arg as referenced */
+
+        MethodArgs[RegisterNumber].Flags |= ASL_ARG_REFERENCED;
+        MethodArgs[RegisterNumber].Op = Op;
+
+        return_ACPI_STATUS (AE_OK);
+    }
+
+    /*
+     * After method ArgX and LocalX, we are only interested in opcodes
+     * that have an associated name
+     */
+    if ((!(OpInfo->Flags & AML_NAMED)) &&
+        (!(OpInfo->Flags & AML_CREATE)) &&
+        (Op->Asl.ParseOpcode != PARSEOP_NAMESTRING) &&
+        (Op->Asl.ParseOpcode != PARSEOP_NAMESEG)    &&
+        (Op->Asl.ParseOpcode != PARSEOP_METHODCALL))
+    {
+        return_ACPI_STATUS (AE_OK);
+    }
+
+    /*
+     * One special case: CondRefOf operator - we don't care if the name exists
+     * or not at this point, just ignore it, the point of the operator is to
+     * determine if the name exists at runtime.
+     */
+    if ((Op->Asl.Parent) &&
+        (Op->Asl.Parent->Asl.ParseOpcode == PARSEOP_CONDREFOF))
+    {
+        return_ACPI_STATUS (AE_OK);
+    }
+
+    /*
+     * We must enable the "search-to-root" for single NameSegs, but
+     * we have to be very careful about opening up scopes
+     */
+    Flags = ACPI_NS_SEARCH_PARENT;
+    if ((Op->Asl.ParseOpcode == PARSEOP_NAMESTRING) ||
+        (Op->Asl.ParseOpcode == PARSEOP_NAMESEG)    ||
+        (Op->Asl.ParseOpcode == PARSEOP_METHODCALL))
+    {
+        /*
+         * These are name references, do not push the scope stack
+         * for them.
+         */
+        Flags |= ACPI_NS_DONT_OPEN_SCOPE;
+    }
+
+    /* Get the NamePath from the appropriate place */
+
+    if (OpInfo->Flags & AML_NAMED)
+    {
+        /* For nearly all NAMED operators, the name reference is the first child */
+
+        Path = Op->Asl.Child->Asl.Value.String;
+        if (Op->Asl.AmlOpcode == AML_ALIAS_OP)
+        {
+            /*
+             * ALIAS is the only oddball opcode, the name declaration
+             * (alias name) is the second operand
+             */
+            Path = Op->Asl.Child->Asl.Next->Asl.Value.String;
+        }
+    }
+    else if (OpInfo->Flags & AML_CREATE)
+    {
+        /* Name must appear as the last parameter */
+
+        NextOp = Op->Asl.Child;
+        while (!(NextOp->Asl.CompileFlags & NODE_IS_NAME_DECLARATION))
+        {
+            NextOp = NextOp->Asl.Next;
+        }
+
+        Path = NextOp->Asl.Value.String;
+    }
+    else
+    {
+        Path = Op->Asl.Value.String;
+    }
+
+    ObjectType = AslMapNamedOpcodeToDataType (Op->Asl.AmlOpcode);
+    ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH,
+        "Type=%s\n", AcpiUtGetTypeName (ObjectType)));
+
+    /*
+     * Lookup the name in the namespace. Name must exist at this point, or it
+     * is an invalid reference.
+     *
+     * The namespace is also used as a lookup table for references to resource
+     * descriptors and the fields within them.
+     */
+    Gbl_NsLookupCount++;
+
+    Status = AcpiNsLookup (WalkState->ScopeInfo, Path, ObjectType,
+        ACPI_IMODE_EXECUTE, Flags, WalkState, &(Node));
+    if (ACPI_FAILURE (Status))
+    {
+        if (Status == AE_NOT_FOUND)
+        {
+            /*
+             * We didn't find the name reference by path -- we can qualify this
+             * a little better before we print an error message
+             */
+            if (strlen (Path) == ACPI_NAME_SIZE)
+            {
+                /* A simple, one-segment ACPI name */
+
+                if (XfObjectExists (Path))
+                {
+                    /*
+                     * There exists such a name, but we couldn't get to it
+                     * from this scope
+                     */
+                    AslError (ASL_ERROR, ASL_MSG_NOT_REACHABLE, Op,
+                        Op->Asl.ExternalName);
+                }
+                else
+                {
+                    /* The name doesn't exist, period */
+
+                    AslError (ASL_ERROR, ASL_MSG_NOT_EXIST,
+                        Op, Op->Asl.ExternalName);
+                }
+            }
+            else
+            {
+                /* Check for a fully qualified path */
+
+                if (Path[0] == AML_ROOT_PREFIX)
+                {
+                    /* Gave full path, the object does not exist */
+
+                    AslError (ASL_ERROR, ASL_MSG_NOT_EXIST, Op,
+                        Op->Asl.ExternalName);
+                }
+                else
+                {
+                    /*
+                     * We can't tell whether it doesn't exist or just
+                     * can't be reached.
+                     */
+                    AslError (ASL_ERROR, ASL_MSG_NOT_FOUND, Op,
+                        Op->Asl.ExternalName);
+                }
+            }
+
+            Status = AE_OK;
+        }
+
+        return_ACPI_STATUS (Status);
+    }
+
+    /* Check for a reference vs. name declaration */
+
+    if (!(OpInfo->Flags & AML_NAMED) &&
+        !(OpInfo->Flags & AML_CREATE))
+    {
+        /* This node has been referenced, mark it for reference check */
+
+        Node->Flags |= ANOBJ_IS_REFERENCED;
+
+#ifdef __UNDER_DEVELOPMENT
+
+        /* Check for an illegal reference */
+
+        XfCheckIllegalReference (Op, Node);
+#endif
+    }
+
+    /* Attempt to optimize the NamePath */
+
+    OptOptimizeNamePath (Op, OpInfo->Flags, WalkState, Path, Node);
+
+    /*
+     * 1) Dereference an alias (A name reference that is an alias)
+     *    Aliases are not nested, the alias always points to the final object
+     */
+    if ((Op->Asl.ParseOpcode != PARSEOP_ALIAS) &&
+        (Node->Type == ACPI_TYPE_LOCAL_ALIAS))
+    {
+        /* This node points back to the original PARSEOP_ALIAS */
+
+        NextOp = Node->Op;
+
+        /* The first child is the alias target op */
+
+        NextOp = NextOp->Asl.Child;
+
+        /* That in turn points back to original target alias node */
+
+        if (NextOp->Asl.Node)
+        {
+            Node = NextOp->Asl.Node;
+        }
+
+        /* Else - forward reference to alias, will be resolved later */
+    }
+
+    /* 2) Check for a reference to a resource descriptor */
+
+    if ((Node->Type == ACPI_TYPE_LOCAL_RESOURCE_FIELD) ||
+        (Node->Type == ACPI_TYPE_LOCAL_RESOURCE))
+    {
+        /*
+         * This was a reference to a field within a resource descriptor.
+         * Extract the associated field offset (either a bit or byte
+         * offset depending on the field type) and change the named
+         * reference into an integer for AML code generation
+         */
+        Offset = Node->Value;
+        TagBitLength = Node->Length;
+
+        /*
+         * If a field is being created, generate the length (in bits) of
+         * the field. Note: Opcodes other than CreateXxxField and Index
+         * can come through here. For other opcodes, we just need to
+         * convert the resource tag reference to an integer offset.
+         */
+        switch (Op->Asl.Parent->Asl.AmlOpcode)
+        {
+        case AML_CREATE_FIELD_OP: /* Variable "Length" field, in bits */
+            /*
+             * We know the length operand is an integer constant because
+             * we know that it contains a reference to a resource
+             * descriptor tag.
+             */
+            FieldBitLength = (UINT32) Op->Asl.Next->Asl.Value.Integer;
+            break;
+
+        case AML_CREATE_BIT_FIELD_OP:
+
+            FieldBitLength = 1;
+            break;
+
+        case AML_CREATE_BYTE_FIELD_OP:
+        case AML_INDEX_OP:
+
+            FieldBitLength = 8;
+            break;
+
+        case AML_CREATE_WORD_FIELD_OP:
+
+            FieldBitLength = 16;
+            break;
+
+        case AML_CREATE_DWORD_FIELD_OP:
+
+            FieldBitLength = 32;
+            break;
+
+        case AML_CREATE_QWORD_FIELD_OP:
+
+            FieldBitLength = 64;
+            break;
+
+        default:
+
+            FieldBitLength = 0;
+            break;
+        }
+
+        /* Check the field length against the length of the resource tag */
+
+        if (FieldBitLength)
+        {
+            if (TagBitLength < FieldBitLength)
+            {
+                Message = ASL_MSG_TAG_SMALLER;
+            }
+            else if (TagBitLength > FieldBitLength)
+            {
+                Message = ASL_MSG_TAG_LARGER;
+            }
+
+            if (Message)
+            {
+                sprintf (MsgBuffer,
+                    "Size mismatch, Tag: %u bit%s, Field: %u bit%s",
+                    TagBitLength, (TagBitLength > 1) ? "s" : "",
+                    FieldBitLength, (FieldBitLength > 1) ? "s" : "");
+
+                AslError (ASL_WARNING, Message, Op, MsgBuffer);
+            }
+        }
+
+        /* Convert the BitOffset to a ByteOffset for certain opcodes */
+
+        switch (Op->Asl.Parent->Asl.AmlOpcode)
+        {
+        case AML_CREATE_BYTE_FIELD_OP:
+        case AML_CREATE_WORD_FIELD_OP:
+        case AML_CREATE_DWORD_FIELD_OP:
+        case AML_CREATE_QWORD_FIELD_OP:
+        case AML_INDEX_OP:
+
+            Offset = ACPI_DIV_8 (Offset);
+            break;
+
+        default:
+
+            break;
+        }
+
+        /* Now convert this node to an integer whose value is the field offset */
+
+        Op->Asl.AmlLength = 0;
+        Op->Asl.ParseOpcode = PARSEOP_INTEGER;
+        Op->Asl.Value.Integer = (UINT64) Offset;
+        Op->Asl.CompileFlags |= NODE_IS_RESOURCE_FIELD;
+
+        OpcGenerateAmlOpcode (Op);
+    }
+
+    /* 3) Check for a method invocation */
+
+    else if ((((Op->Asl.ParseOpcode == PARSEOP_NAMESTRING) || (Op->Asl.ParseOpcode == PARSEOP_NAMESEG)) &&
+                (Node->Type == ACPI_TYPE_METHOD) &&
+                (Op->Asl.Parent) &&
+                (Op->Asl.Parent->Asl.ParseOpcode != PARSEOP_METHOD))   ||
+
+                (Op->Asl.ParseOpcode == PARSEOP_METHODCALL))
+    {
+        /*
+         * A reference to a method within one of these opcodes is not an
+         * invocation of the method, it is simply a reference to the method.
+         */
+        if ((Op->Asl.Parent) &&
+           ((Op->Asl.Parent->Asl.ParseOpcode == PARSEOP_REFOF)      ||
+            (Op->Asl.Parent->Asl.ParseOpcode == PARSEOP_DEREFOF)    ||
+            (Op->Asl.Parent->Asl.ParseOpcode == PARSEOP_PACKAGE)    ||
+            (Op->Asl.Parent->Asl.ParseOpcode == PARSEOP_VAR_PACKAGE)||
+            (Op->Asl.Parent->Asl.ParseOpcode == PARSEOP_OBJECTTYPE)))
+        {
+            return_ACPI_STATUS (AE_OK);
+        }
+        /*
+         * There are two types of method invocation:
+         * 1) Invocation with arguments -- the parser recognizes this
+         *    as a METHODCALL.
+         * 2) Invocation with no arguments --the parser cannot determine that
+         *    this is a method invocation, therefore we have to figure it out
+         *    here.
+         */
+        if (Node->Type != ACPI_TYPE_METHOD)
+        {
+            sprintf (MsgBuffer, "%s is a %s",
+                Op->Asl.ExternalName, AcpiUtGetTypeName (Node->Type));
+
+            AslError (ASL_ERROR, ASL_MSG_NOT_METHOD, Op, MsgBuffer);
+            return_ACPI_STATUS (AE_OK);
+        }
+
+        /* Save the method node in the caller's op */
+
+        Op->Asl.Node = Node;
+        if (Op->Asl.Parent->Asl.ParseOpcode == PARSEOP_CONDREFOF)
+        {
+            return_ACPI_STATUS (AE_OK);
+        }
+
+        /*
+         * This is a method invocation, with or without arguments.
+         * Count the number of arguments, each appears as a child
+         * under the parent node
+         */
+        Op->Asl.ParseOpcode = PARSEOP_METHODCALL;
+        UtSetParseOpName (Op);
+
+        PassedArgs = 0;
+        NextOp = Op->Asl.Child;
+
+        while (NextOp)
+        {
+            PassedArgs++;
+            NextOp = NextOp->Asl.Next;
+        }
+
+        if (Node->Value != ASL_EXTERNAL_METHOD &&
+            Op->Asl.Parent->Asl.ParseOpcode != PARSEOP_EXTERNAL)
+        {
+            /*
+             * Check the parsed arguments with the number expected by the
+             * method declaration itself
+             */
+            if (PassedArgs != Node->Value)
+            {
+                sprintf (MsgBuffer, "%s requires %u", Op->Asl.ExternalName,
+                            Node->Value);
+
+                if (PassedArgs < Node->Value)
+                {
+                    AslError (ASL_ERROR, ASL_MSG_ARG_COUNT_LO, Op, MsgBuffer);
+                }
+                else
+                {
+                    AslError (ASL_ERROR, ASL_MSG_ARG_COUNT_HI, Op, MsgBuffer);
+                }
+            }
+        }
+    }
+
+    /* 4) Check for an ASL Field definition */
+
+    else if ((Op->Asl.Parent) &&
+            ((Op->Asl.Parent->Asl.ParseOpcode == PARSEOP_FIELD)     ||
+             (Op->Asl.Parent->Asl.ParseOpcode == PARSEOP_BANKFIELD)))
+    {
+        /*
+         * Offset checking for fields. If the parent operation region has a
+         * constant length (known at compile time), we can check fields
+         * defined in that region against the region length. This will catch
+         * fields and field units that cannot possibly fit within the region.
+         *
+         * Note: Index fields do not directly reference an operation region,
+         * thus they are not included in this check.
+         */
+        if (Op == Op->Asl.Parent->Asl.Child)
+        {
+            /*
+             * This is the first child of the field node, which is
+             * the name of the region. Get the parse node for the
+             * region -- which contains the length of the region.
+             */
+            OwningOp = Node->Op;
+            Op->Asl.Parent->Asl.ExtraValue =
+                ACPI_MUL_8 ((UINT32) OwningOp->Asl.Value.Integer);
+
+            /* Examine the field access width */
+
+            switch ((UINT8) Op->Asl.Parent->Asl.Value.Integer)
+            {
+            case AML_FIELD_ACCESS_ANY:
+            case AML_FIELD_ACCESS_BYTE:
+            case AML_FIELD_ACCESS_BUFFER:
+            default:
+
+                MinimumLength = 1;
+                break;
+
+            case AML_FIELD_ACCESS_WORD:
+
+                MinimumLength = 2;
+                break;
+
+            case AML_FIELD_ACCESS_DWORD:
+
+                MinimumLength = 4;
+                break;
+
+            case AML_FIELD_ACCESS_QWORD:
+
+                MinimumLength = 8;
+                break;
+            }
+
+            /*
+             * Is the region at least as big as the access width?
+             * Note: DataTableRegions have 0 length
+             */
+            if (((UINT32) OwningOp->Asl.Value.Integer) &&
+                ((UINT32) OwningOp->Asl.Value.Integer < MinimumLength))
+            {
+                AslError (ASL_ERROR, ASL_MSG_FIELD_ACCESS_WIDTH, Op, NULL);
+            }
+
+            /*
+             * Check EC/CMOS/SMBUS fields to make sure that the correct
+             * access type is used (BYTE for EC/CMOS, BUFFER for SMBUS)
+             */
+            SpaceIdOp = OwningOp->Asl.Child->Asl.Next;
+            switch ((UINT32) SpaceIdOp->Asl.Value.Integer)
+            {
+            case ACPI_ADR_SPACE_EC:
+            case ACPI_ADR_SPACE_CMOS:
+            case ACPI_ADR_SPACE_GPIO:
+
+                if ((UINT8) Op->Asl.Parent->Asl.Value.Integer !=
+                    AML_FIELD_ACCESS_BYTE)
+                {
+                    AslError (ASL_ERROR, ASL_MSG_REGION_BYTE_ACCESS, Op, NULL);
+                }
+                break;
+
+            case ACPI_ADR_SPACE_SMBUS:
+            case ACPI_ADR_SPACE_IPMI:
+            case ACPI_ADR_SPACE_GSBUS:
+
+                if ((UINT8) Op->Asl.Parent->Asl.Value.Integer !=
+                    AML_FIELD_ACCESS_BUFFER)
+                {
+                    AslError (ASL_ERROR, ASL_MSG_REGION_BUFFER_ACCESS, Op, NULL);
+                }
+                break;
+
+            default:
+
+                /* Nothing to do for other address spaces */
+
+                break;
+            }
+        }
+        else
+        {
+            /*
+             * This is one element of the field list. Check to make sure
+             * that it does not go beyond the end of the parent operation region.
+             *
+             * In the code below:
+             *    Op->Asl.Parent->Asl.ExtraValue      - Region Length (bits)
+             *    Op->Asl.ExtraValue                  - Field start offset (bits)
+             *    Op->Asl.Child->Asl.Value.Integer32  - Field length (bits)
+             *    Op->Asl.Child->Asl.ExtraValue       - Field access width (bits)
+             */
+            if (Op->Asl.Parent->Asl.ExtraValue && Op->Asl.Child)
+            {
+                XfCheckFieldRange (Op,
+                    Op->Asl.Parent->Asl.ExtraValue,
+                    Op->Asl.ExtraValue,
+                    (UINT32) Op->Asl.Child->Asl.Value.Integer,
+                    Op->Asl.Child->Asl.ExtraValue);
+            }
+        }
+    }
+
+    /* 5) Check for a connection object */
+#if 0
+    else if (Op->Asl.Parent->Asl.ParseOpcode == PARSEOP_CONNECTION)
+    {
+        return_ACPI_STATUS (Status);
+    }
+#endif
+
+    Op->Asl.Node = Node;
+    return_ACPI_STATUS (Status);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    XfNamespaceLocateEnd
+ *
+ * PARAMETERS:  ASL_WALK_CALLBACK
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Ascending callback used during cross reference. We only
+ *              need to worry about scope management here.
+ *
+ ******************************************************************************/
+
+static ACPI_STATUS
+XfNamespaceLocateEnd (
+    ACPI_PARSE_OBJECT       *Op,
+    UINT32                  Level,
+    void                    *Context)
+{
+    ACPI_WALK_STATE         *WalkState = (ACPI_WALK_STATE *) Context;
+    const ACPI_OPCODE_INFO  *OpInfo;
+
+
+    ACPI_FUNCTION_TRACE (XfNamespaceLocateEnd);
+
+
+    /* We are only interested in opcodes that have an associated name */
+
+    OpInfo = AcpiPsGetOpcodeInfo (Op->Asl.AmlOpcode);
+    if (!(OpInfo->Flags & AML_NAMED))
+    {
+        return_ACPI_STATUS (AE_OK);
+    }
+
+    /* Not interested in name references, we did not open a scope for them */
+
+    if ((Op->Asl.ParseOpcode == PARSEOP_NAMESTRING) ||
+        (Op->Asl.ParseOpcode == PARSEOP_NAMESEG)    ||
+        (Op->Asl.ParseOpcode == PARSEOP_METHODCALL))
+    {
+        return_ACPI_STATUS (AE_OK);
+    }
+
+    /* Pop the scope stack if necessary */
+
+    if (AcpiNsOpensScope (AslMapNamedOpcodeToDataType (Op->Asl.AmlOpcode)))
+    {
+
+        ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH,
+            "%s: Popping scope for Op %p\n",
+            AcpiUtGetTypeName (OpInfo->ObjectType), Op));
+
+        (void) AcpiDsScopeStackPop (WalkState);
+    }
+
+    return_ACPI_STATUS (AE_OK);
+}
+
+
+#ifdef __UNDER_DEVELOPMENT
+/*******************************************************************************
+ *
+ * FUNCTION:    XfIsObjectParental
+ *
+ * PARAMETERS:  ChildOp                 - Op to be checked
+ *              PossibleParentOp        - Determine if this op is in the family
+ *
+ * RETURN:      TRUE if ChildOp is a descendent of PossibleParentOp
+ *
+ * DESCRIPTION: Determine if an Op is a descendent of another Op. Used to
+ *              detect if a method is declared within another method.
+ *
+ ******************************************************************************/
+
+static BOOLEAN
+XfIsObjectParental (
+    ACPI_PARSE_OBJECT       *ChildOp,
+    ACPI_PARSE_OBJECT       *PossibleParentOp)
+{
+    ACPI_PARSE_OBJECT       *ParentOp;
+
+
+    /* Search upwards through the tree for possible parent */
+
+    ParentOp = ChildOp;
+    while (ParentOp)
+    {
+        if (ParentOp == PossibleParentOp)
+        {
+            return (TRUE);
+        }
+
+        ParentOp = ParentOp->Asl.Parent;
+    }
+
+    return (FALSE);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    XfGetParentMethod
+ *
+ * PARAMETERS:  Op                      - Op to be checked
+ *
+ * RETURN:      Op for parent method. NULL if object is not within a method.
+ *
+ * DESCRIPTION: Determine if an object is within a control method. Used to
+ *              implement special rules for named references from within a
+ *              control method.
+ *
+ * NOTE: It would be better to have the parser set a flag in the Op if possible.
+ *
+ ******************************************************************************/
+
+static ACPI_PARSE_OBJECT *
+XfGetParentMethod (
+    ACPI_PARSE_OBJECT       *Op)
+{
+    ACPI_PARSE_OBJECT       *ParentOp;
+
+
+    if (!Op)
+    {
+        return (NULL);
+    }
+
+    if (Op->Asl.ParseOpcode == PARSEOP_METHOD)
+    {
+        return (NULL);
+    }
+
+    /* Walk upwards through the parse tree, up to the root if necessary */
+
+    ParentOp = Op;
+    while (ParentOp)
+    {
+        if (ParentOp->Asl.ParseOpcode == PARSEOP_METHOD)
+        {
+            return (ParentOp);
+        }
+
+        ParentOp = ParentOp->Asl.Parent;
+    }
+
+    /* Object is not within a method */
+
+    return (NULL);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    XfCheckIllegalReference
+ *
+ * PARAMETERS:  Op                      - Op referring to the target
+ *              TargetNode              - Target of the reference
+ *
+ * RETURN:      None. Emits error message for an illegal reference
+ *
+ * DESCRIPTION: Determine if a named reference is legal. A "named" reference
+ *              is something like: Store(ABCD, ...), where ABCD is an AML
+ *              Nameseg or Namepath.
+ *
+ * NOTE: Caller must ensure that the name Op is in fact a reference, and not
+ *       an actual name declaration (creation of a named object).
+ *
+ ******************************************************************************/
+
+static void
+XfCheckIllegalReference (
+    ACPI_PARSE_OBJECT       *Op,
+    ACPI_NAMESPACE_NODE     *TargetNode)
+{
+    ACPI_PARSE_OBJECT       *MethodOp1;
+    ACPI_PARSE_OBJECT       *MethodOp2;
+    ACPI_PARSE_OBJECT       *TargetOp;
+
+
+    /*
+     * Check for an illegal reference to a named object:
+     *
+     * 1) References from one control method to another, non-parent
+     *    method are not allowed, they will fail at runtime.
+     *
+     * 2) Forward references within a control method are not allowed.
+     *    AML interpreters use a one-pass parse of control methods
+     *    so these forward references will fail at runtime.
+     */
+    TargetOp = TargetNode->Op;
+
+    MethodOp1 = XfGetParentMethod (Op);
+    MethodOp2 = XfGetParentMethod (TargetOp);
+
+    /* Are both objects within control method(s)? */
+
+    if (!MethodOp1 || !MethodOp2)
+    {
+        return;
+    }
+
+    /* Objects not in the same method? */
+
+    if (MethodOp1 != MethodOp2)
+    {
+        /*
+         * 1) Cross-method named reference
+         *
+         * This is OK if and only if the target reference is within in a
+         * method that is a parent of current method
+         */
+        if (!XfIsObjectParental (MethodOp1, MethodOp2))
+        {
+            AslError (ASL_ERROR, ASL_MSG_ILLEGAL_METHOD_REF, Op,
+                Op->Asl.ExternalName);
+        }
+    }
+
+    /*
+     * 2) Both reference and target are in the same method. Check if this is
+     * an (illegal) forward reference by examining the exact source code
+     * location of each (the referenced object and the object declaration).
+     * This is a bit nasty, yet effective.
+     */
+    else if (Op->Asl.LogicalByteOffset < TargetOp->Asl.LogicalByteOffset)
+    {
+        AslError (ASL_ERROR, ASL_MSG_ILLEGAL_FORWARD_REF, Op,
+            Op->Asl.ExternalName);
+    }
+
+}
+#endif
diff --git a/usr/src/cmd/acpi/iasl/aslxrefout.c b/usr/src/cmd/acpi/iasl/aslxrefout.c
new file mode 100644
index 0000000000..701399cbae
--- /dev/null
+++ b/usr/src/cmd/acpi/iasl/aslxrefout.c
@@ -0,0 +1,814 @@
+/******************************************************************************
+ *
+ * Module Name: aslxrefout.c - support for optional cross-reference file
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2016, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include "aslcompiler.h"
+#include "aslcompiler.y.h"
+#include "acnamesp.h"
+#include "acparser.h"
+#include "amlcode.h"
+
+#define _COMPONENT          ACPI_COMPILER
+        ACPI_MODULE_NAME    ("aslxrefout")
+
+
+/* Local prototypes */
+
+static ACPI_STATUS
+OtXrefWalkPart2 (
+    ACPI_PARSE_OBJECT       *Op,
+    UINT32                  Level,
+    void                    *Context);
+
+static ACPI_STATUS
+OtXrefWalkPart3 (
+    ACPI_PARSE_OBJECT       *Op,
+    UINT32                  Level,
+    void                    *Context);
+
+static ACPI_STATUS
+OtXrefAnalysisWalkPart1 (
+    ACPI_PARSE_OBJECT       *Op,
+    UINT32                  Level,
+    void                    *Context);
+
+
+static ACPI_STATUS
+OtXrefAnalysisWalkPart2 (
+    ACPI_PARSE_OBJECT       *Op,
+    UINT32                  Level,
+    void                    *Context);
+
+static ACPI_STATUS
+OtXrefAnalysisWalkPart3 (
+    ACPI_PARSE_OBJECT       *Op,
+    UINT32                  Level,
+    void                    *Context);
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    OtPrintHeaders
+ *
+ * PARAMETERS:  Message             - Main header message
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Emits the main header message along with field descriptions
+ *
+ ******************************************************************************/
+
+void
+OtPrintHeaders (
+    char                    *Message)
+{
+    UINT32                  Length;
+
+
+    Length = strlen (Message);
+
+    FlPrintFile (ASL_FILE_XREF_OUTPUT, "\n\n%s\n", Message);
+    while (Length)
+    {
+        FlPrintFile (ASL_FILE_XREF_OUTPUT, "-");
+        Length--;
+    }
+
+    FlPrintFile (ASL_FILE_XREF_OUTPUT, "\n\nLineno   %-40s Description\n",
+        "Full Pathname");
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    OtCreateXrefFile
+ *
+ * PARAMETERS:  None
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION  Main entry point for parts 2 and 3 of the cross-reference
+ *              file.
+ *
+ ******************************************************************************/
+
+void
+OtCreateXrefFile (
+    void)
+{
+    ASL_XREF_INFO           XrefInfo;
+
+
+    /* Build cross-reference output file if requested */
+
+    if (!Gbl_CrossReferenceOutput)
+    {
+        return;
+    }
+
+    memset (&XrefInfo, 0, sizeof (ASL_XREF_INFO));
+
+    /* Cross-reference output file, part 2 (Method invocations) */
+
+    OtPrintHeaders ("Part 2: Method Reference Map "
+        "(Invocations of each user-defined control method)");
+
+    TrWalkParseTree (Gbl_ParseTreeRoot, ASL_WALK_VISIT_DOWNWARD,
+        OtXrefWalkPart2, NULL, &XrefInfo);
+
+    /* Cross-reference output file, part 3 (All other object refs) */
+
+    OtPrintHeaders ("Part 3: Full Object Reference Map "
+        "(Methods that reference each object in namespace");
+
+    TrWalkParseTree (Gbl_ParseTreeRoot, ASL_WALK_VISIT_DOWNWARD,
+        OtXrefWalkPart3, NULL, &XrefInfo);
+
+    /* Cross-reference summary */
+
+    FlPrintFile (ASL_FILE_XREF_OUTPUT, "\n\nObject Summary\n");
+
+    FlPrintFile (ASL_FILE_XREF_OUTPUT,
+        "\nTotal methods:                   %u\n",
+        XrefInfo.TotalPredefinedMethods + XrefInfo.TotalUserMethods);
+    FlPrintFile (ASL_FILE_XREF_OUTPUT,
+        "Total predefined methods:        %u\n",
+        XrefInfo.TotalPredefinedMethods);
+
+    FlPrintFile (ASL_FILE_XREF_OUTPUT,
+        "\nTotal user methods:              %u\n",
+        XrefInfo.TotalUserMethods);
+    FlPrintFile (ASL_FILE_XREF_OUTPUT,
+        "Total unreferenced user methods  %u\n",
+        XrefInfo.TotalUnreferenceUserMethods);
+
+    FlPrintFile (ASL_FILE_XREF_OUTPUT,
+        "\nTotal defined objects:           %u\n",
+        XrefInfo.TotalObjects);
+    FlPrintFile (ASL_FILE_XREF_OUTPUT,
+        "Total unreferenced objects:      %u\n",
+        XrefInfo.TotalUnreferencedObjects);
+}
+
+
+/*
+ * Part 1 of the cross reference file. This part emits the namespace objects
+ * that are referenced by each control method in the namespace.
+ *
+ * Part 2 and 3 are below part 1.
+ */
+
+/*******************************************************************************
+ *
+ * FUNCTION:    OtXrefWalkPart1
+ *
+ * PARAMETERS:  Op                      - Current parse Op
+ *              Level                   - Current tree nesting level
+ *              MethodInfo              - Info block for the current method
+ *
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Entry point for the creation of the method call reference map.
+ *              For each control method in the namespace, all other methods
+ *              that invoke the method are listed. Predefined names/methods
+ *              that start with an underscore are ignored, because these are
+ *              essentially external/public interfaces.
+
+ * DESCRIPTION: Entry point for the creation of the object reference map.
+ *              For each control method in the namespace, all objects that
+ *              are referenced by the method are listed.
+ *
+ *              Called during a normal namespace walk, once per namespace
+ *              object. (MtMethodAnalysisWalkBegin)
+ *
+ ******************************************************************************/
+
+void
+OtXrefWalkPart1 (
+    ACPI_PARSE_OBJECT       *Op,
+    UINT32                  Level,
+    ASL_METHOD_INFO         *MethodInfo)
+{
+    ACPI_NAMESPACE_NODE     *Node;
+    ACPI_PARSE_OBJECT       *NextOp;
+    ACPI_PARSE_OBJECT       *FieldOp;
+    char                    *ParentPath;
+    UINT32                  Length;
+    ACPI_STATUS             Status;
+
+
+    switch (Op->Asl.ParseOpcode)
+    {
+    case PARSEOP_NAMESEG:
+    case PARSEOP_NAMESTRING:
+    case PARSEOP_METHODCALL:
+
+        if (!MethodInfo ||
+            (MethodInfo->Op->Asl.Child == Op) ||
+            !Op->Asl.Node)
+        {
+            break;
+        }
+
+        MethodInfo->CurrentOp = Op;
+        Node = Op->Asl.Node;
+
+        /* Find all objects referenced by this method */
+
+        Status = TrWalkParseTree (MethodInfo->Op, ASL_WALK_VISIT_DOWNWARD,
+            OtXrefAnalysisWalkPart1, NULL, MethodInfo);
+
+        if (Status == AE_CTRL_TERMINATE)
+        {
+            ParentPath = AcpiNsGetNormalizedPathname (Node, TRUE);
+
+            FlPrintFile (ASL_FILE_XREF_OUTPUT, "            %-40s %s",
+                ParentPath, AcpiUtGetTypeName (Node->Type));
+            ACPI_FREE (ParentPath);
+
+            switch (Node->Type)
+            {
+                /* Handle externals */
+
+            case ACPI_TYPE_ANY:
+            case ACPI_TYPE_FIELD_UNIT:
+
+                FlPrintFile (ASL_FILE_XREF_OUTPUT, " <External Object>");
+                break;
+
+            case ACPI_TYPE_INTEGER:
+
+                FlPrintFile (ASL_FILE_XREF_OUTPUT, " %8.8X%8.8X",
+                    ACPI_FORMAT_UINT64 (Op->Asl.Value.Integer));
+                break;
+
+            case ACPI_TYPE_METHOD:
+
+                FlPrintFile (ASL_FILE_XREF_OUTPUT, " Invocation (%u args)",
+                    Node->ArgCount);
+                break;
+
+            case ACPI_TYPE_BUFFER_FIELD:
+
+                NextOp = Node->Op;              /* Create Buffer Field Op */
+                switch (NextOp->Asl.ParseOpcode)
+                {
+                case PARSEOP_CREATEBITFIELD:
+                    Length = 1;
+                    break;
+
+                case PARSEOP_CREATEBYTEFIELD:
+                    Length = 8;
+                    break;
+
+                case PARSEOP_CREATEWORDFIELD:
+                    Length = 16;
+                    break;
+
+                case PARSEOP_CREATEDWORDFIELD:
+                    Length = 32;
+                    break;
+
+                case PARSEOP_CREATEQWORDFIELD:
+                    Length = 64;
+                    break;
+
+                default:
+                    Length = 0;
+                    break;
+                }
+
+                NextOp = NextOp->Asl.Child;     /* Buffer name */
+
+                if (!NextOp->Asl.ExternalName)
+                {
+                    FlPrintFile (ASL_FILE_XREF_OUTPUT, " in Arg/Local");
+                }
+                else
+                {
+                    ParentPath = AcpiNsGetNormalizedPathname (
+                        NextOp->Asl.Node, TRUE);
+
+                    FlPrintFile (ASL_FILE_XREF_OUTPUT, " (%.2u bit) in Buffer %s",
+                        Length, ParentPath);
+                    ACPI_FREE (ParentPath);
+                }
+                break;
+
+            case ACPI_TYPE_LOCAL_REGION_FIELD:
+
+                NextOp = Node->Op;
+                FieldOp = NextOp->Asl.Parent;
+                NextOp = FieldOp->Asl.Child;
+
+                ParentPath = AcpiNsGetNormalizedPathname (
+                    NextOp->Asl.Node, TRUE);
+
+                FlPrintFile (ASL_FILE_XREF_OUTPUT, " (%.2u bit) in Region %s",
+                    (UINT32) Node->Op->Asl.Child->Asl.Value.Integer,
+                    ParentPath);
+                ACPI_FREE (ParentPath);
+
+                if (FieldOp->Asl.ParseOpcode == PARSEOP_FIELD)
+                {
+                    Node = NextOp->Asl.Node;        /* Region node */
+                    NextOp = Node->Op;              /* PARSEOP_REGION */
+                    NextOp = NextOp->Asl.Child;     /* Region name */
+                    NextOp = NextOp->Asl.Next;
+
+                    /* Get region space/addr/len? */
+
+                    FlPrintFile (ASL_FILE_XREF_OUTPUT, " (%s)",
+                        AcpiUtGetRegionName ((UINT8)
+                        NextOp->Asl.Value.Integer));
+                }
+                break;
+
+            default:
+                break;
+            }
+
+            FlPrintFile (ASL_FILE_XREF_OUTPUT, "\n");
+        }
+        break;
+
+    case PARSEOP_METHOD:
+
+        ParentPath = AcpiNsGetNormalizedPathname (Op->Asl.Node, TRUE);
+
+        FlPrintFile (ASL_FILE_XREF_OUTPUT,
+            "\n[%5u]  %-40s %s Declaration (%u args)\n",
+            Op->Asl.LogicalLineNumber, ParentPath,
+            AcpiUtGetTypeName (Op->Asl.Node->Type), Op->Asl.Node->ArgCount);
+
+        ACPI_FREE (ParentPath);
+        break;
+
+    default:
+        break;
+    }
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    OtXrefAnalysisWalkPart1
+ *
+ * PARAMETERS:  ASL_WALK_CALLBACK
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Secondary walk for cross-reference part 1.
+ *
+ ******************************************************************************/
+
+static ACPI_STATUS
+OtXrefAnalysisWalkPart1 (
+    ACPI_PARSE_OBJECT       *Op,
+    UINT32                  Level,
+    void                    *Context)
+{
+    ASL_METHOD_INFO         *MethodInfo = (ASL_METHOD_INFO *) Context;
+    ACPI_PARSE_OBJECT       *Next;
+
+
+    /* Only interested in name string Ops -- ignore all others */
+
+    if ((Op->Asl.ParseOpcode != PARSEOP_NAMESEG) &&
+        (Op->Asl.ParseOpcode != PARSEOP_NAMESTRING) &&
+        (Op->Asl.ParseOpcode != PARSEOP_METHODCALL))
+    {
+        return (AE_OK);
+    }
+
+    /* No node means a locally declared object -- ignore */
+
+    if (!Op->Asl.Node)
+    {
+        return (AE_OK);
+    }
+
+    /* When we encounter the source Op, we are done */
+
+    Next = MethodInfo->CurrentOp;
+    if (Next == Op)
+    {
+        return (AE_CTRL_TERMINATE);
+    }
+
+    /* If we have a name match, this Op is a duplicate */
+
+    if ((Next->Asl.ParseOpcode == PARSEOP_NAMESEG)      ||
+        (Next->Asl.ParseOpcode == PARSEOP_NAMESTRING)   ||
+        (Next->Asl.ParseOpcode == PARSEOP_METHODCALL))
+    {
+        if (!strcmp (Op->Asl.ExternalName, Next->Asl.ExternalName))
+        {
+            return (AE_ALREADY_EXISTS);
+        }
+    }
+
+    return (AE_OK);
+}
+
+
+/*
+ * Part 2 of the cross reference file. This part emits the names of each
+ * non-predefined method in the namespace (user methods), along with the
+ * names of each control method that references that method.
+ */
+
+/*******************************************************************************
+ *
+ * FUNCTION:    OtXrefWalkPart2
+ *
+ * PARAMETERS:  ASL_WALK_CALLBACK
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: For each control method in the namespace, we will re-walk the
+ *              namespace to find each and every invocation of that control
+ *              method. Brute force, but does not matter, even for large
+ *              namespaces. Ignore predefined names (start with underscore).
+ *
+ ******************************************************************************/
+
+static ACPI_STATUS
+OtXrefWalkPart2 (
+    ACPI_PARSE_OBJECT       *Op,
+    UINT32                  Level,
+    void                    *Context)
+{
+    ASL_XREF_INFO           *XrefInfo = (ASL_XREF_INFO *) Context;
+    ACPI_NAMESPACE_NODE     *Node;
+    char                    *ParentPath;
+
+
+    /* Looking for Method Declaration Ops only */
+
+    if (!Op->Asl.Node ||
+        (Op->Asl.ParseOpcode != PARSEOP_METHOD))
+    {
+        return (AE_OK);
+    }
+
+    /* Ignore predefined names */
+
+    if (Op->Asl.Node->Name.Ascii[0] == '_')
+    {
+        XrefInfo->TotalPredefinedMethods++;
+        return (AE_OK);
+    }
+
+    Node = Op->Asl.Node;
+    ParentPath = AcpiNsGetNormalizedPathname (Node, TRUE);
+
+    FlPrintFile (ASL_FILE_XREF_OUTPUT,
+        "\n[%5u]  %-40s %s Declaration (%u args)\n",
+        Op->Asl.LogicalLineNumber, ParentPath,
+        AcpiUtGetTypeName (Node->Type), Node->ArgCount);
+
+    XrefInfo->TotalUserMethods++;
+    XrefInfo->ThisMethodInvocations = 0;
+    XrefInfo->MethodOp = Op;
+
+    (void) TrWalkParseTree (Gbl_ParseTreeRoot, ASL_WALK_VISIT_DOWNWARD,
+        OtXrefAnalysisWalkPart2, NULL, XrefInfo);
+
+    if (!XrefInfo->ThisMethodInvocations)
+    {
+        FlPrintFile (ASL_FILE_XREF_OUTPUT,
+            "            Zero invocations of this method in this module\n");
+        XrefInfo->TotalUnreferenceUserMethods++;
+    }
+    else
+    {
+        FlPrintFile (ASL_FILE_XREF_OUTPUT,
+            "            %u invocations of method %s in this module\n",
+            XrefInfo->ThisMethodInvocations, ParentPath);
+    }
+
+    ACPI_FREE (ParentPath);
+    return (AE_OK);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    OtXrefAnalysisWalkPart2
+ *
+ * PARAMETERS:  ASL_WALK_CALLBACK
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: For every Op that is a method invocation, emit a reference
+ *              line if the Op is invoking the target method.
+ *
+ ******************************************************************************/
+
+static ACPI_STATUS
+OtXrefAnalysisWalkPart2 (
+    ACPI_PARSE_OBJECT       *Op,
+    UINT32                  Level,
+    void                    *Context)
+{
+    ASL_XREF_INFO           *XrefInfo = (ASL_XREF_INFO *) Context;
+    ACPI_PARSE_OBJECT       *CallerOp;
+    char                    *CallerFullPathname;
+
+
+    /* Looking for MethodCall Ops only */
+
+    if (!Op->Asl.Node ||
+        (Op->Asl.ParseOpcode != PARSEOP_METHODCALL))
+    {
+        return (AE_OK);
+    }
+
+    /* If not a match to the target method, we are done */
+
+    if (Op->Asl.Node != XrefInfo->MethodOp->Asl.Node)
+    {
+        return (AE_CTRL_DEPTH);
+    }
+
+    /* Find parent method to get method caller namepath */
+
+    CallerOp = Op->Asl.Parent;
+    while (CallerOp &&
+        (CallerOp->Asl.ParseOpcode != PARSEOP_METHOD))
+    {
+        CallerOp = CallerOp->Asl.Parent;
+    }
+
+    /* There is no parent method for External() statements */
+
+    if (!CallerOp)
+    {
+        return (AE_OK);
+    }
+
+    CallerFullPathname = AcpiNsGetNormalizedPathname (
+        CallerOp->Asl.Node, TRUE);
+
+    FlPrintFile (ASL_FILE_XREF_OUTPUT,
+        "[%5u]     %-40s Invocation path: %s\n",
+        Op->Asl.LogicalLineNumber, CallerFullPathname,
+        Op->Asl.ExternalName);
+
+    ACPI_FREE (CallerFullPathname);
+    XrefInfo->ThisMethodInvocations++;
+    return (AE_OK);
+}
+
+
+/*
+ * Part 3 of the cross reference file. This part emits the names of each
+ * non-predefined method in the namespace (user methods), along with the
+ * names of each control method that references that method.
+ */
+
+/*******************************************************************************
+ *
+ * FUNCTION:    OtXrefWalkPart3
+ *
+ * PARAMETERS:  ASL_WALK_CALLBACK
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Cross-reference part 3. references to objects other than
+ *              control methods.
+ *
+ ******************************************************************************/
+
+static ACPI_STATUS
+OtXrefWalkPart3 (
+    ACPI_PARSE_OBJECT       *Op,
+    UINT32                  Level,
+    void                    *Context)
+{
+    ASL_XREF_INFO           *XrefInfo = (ASL_XREF_INFO *) Context;
+    ACPI_NAMESPACE_NODE     *Node;
+    char                    *ParentPath;
+    const ACPI_OPCODE_INFO  *OpInfo;
+
+
+    /* Ignore method declarations */
+
+    if (!Op->Asl.Node ||
+        (Op->Asl.ParseOpcode == PARSEOP_METHOD))
+    {
+        return (AE_OK);
+    }
+
+    OpInfo = AcpiPsGetOpcodeInfo (Op->Asl.AmlOpcode);
+    if (!(OpInfo->Class & AML_CLASS_NAMED_OBJECT))
+    {
+        return (AE_OK);
+    }
+
+    /* Only care about named object creation opcodes */
+
+    if ((Op->Asl.ParseOpcode != PARSEOP_NAME) &&
+        (Op->Asl.ParseOpcode != PARSEOP_DEVICE) &&
+        (Op->Asl.ParseOpcode != PARSEOP_MUTEX) &&
+        (Op->Asl.ParseOpcode != PARSEOP_OPERATIONREGION) &&
+        (Op->Asl.ParseOpcode != PARSEOP_FIELD) &&
+        (Op->Asl.ParseOpcode != PARSEOP_EVENT))
+    {
+        return (AE_OK);
+    }
+
+    /* Ignore predefined names */
+
+    if (Op->Asl.Node->Name.Ascii[0] == '_')
+    {
+        return (AE_OK);
+    }
+
+    Node = Op->Asl.Node;
+    ParentPath = AcpiNsGetNormalizedPathname (Node, TRUE);
+
+    FlPrintFile (ASL_FILE_XREF_OUTPUT,
+        "\n[%5u]  %-40s %s Declaration\n",
+        Op->Asl.LogicalLineNumber, ParentPath,
+        AcpiUtGetTypeName (Node->Type));
+    ACPI_FREE (ParentPath);
+
+    XrefInfo->MethodOp = Op;
+    XrefInfo->ThisObjectReferences = 0;
+    XrefInfo->TotalObjects = 0;
+
+    (void) TrWalkParseTree (Gbl_ParseTreeRoot, ASL_WALK_VISIT_DOWNWARD,
+        OtXrefAnalysisWalkPart3, NULL, XrefInfo);
+
+    if (!XrefInfo->ThisObjectReferences)
+    {
+        FlPrintFile (ASL_FILE_XREF_OUTPUT,
+            "            Zero references to this object in this module\n");
+        XrefInfo->TotalUnreferencedObjects++;
+    }
+    else
+    {
+        FlPrintFile (ASL_FILE_XREF_OUTPUT,
+            "            %u references to this object in this module\n",
+            XrefInfo->ThisObjectReferences, ParentPath);
+    }
+
+    return (AE_OK);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    OtXrefAnalysisWalkPart3
+ *
+ * PARAMETERS:  ASL_WALK_CALLBACK
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Secondary walk for cross-reference part 3.
+ *
+ ******************************************************************************/
+
+static ACPI_STATUS
+OtXrefAnalysisWalkPart3 (
+    ACPI_PARSE_OBJECT       *Op,
+    UINT32                  Level,
+    void                    *Context)
+{
+    ASL_XREF_INFO           *XrefInfo = (ASL_XREF_INFO *) Context;
+    char                    *CallerFullPathname = NULL;
+    ACPI_PARSE_OBJECT       *CallerOp;
+    const char              *Operator;
+
+
+    if (!Op->Asl.Node)
+    {
+        return (AE_OK);
+    }
+
+    XrefInfo->TotalObjects++;
+
+    /* Ignore Op that actually defined the object */
+
+    if (Op == XrefInfo->MethodOp)
+    {
+        return (AE_OK);
+    }
+
+    /* Only interested in Ops that reference the target node */
+
+    if (Op->Asl.Node != XrefInfo->MethodOp->Asl.Node)
+    {
+        return (AE_OK);
+    }
+
+    /* Find parent "open scope" object to get method caller namepath */
+
+    CallerOp = Op->Asl.Parent;
+    while (CallerOp &&
+        (CallerOp->Asl.ParseOpcode != PARSEOP_NAME) &&
+        (CallerOp->Asl.ParseOpcode != PARSEOP_METHOD) &&
+        (CallerOp->Asl.ParseOpcode != PARSEOP_DEVICE) &&
+        (CallerOp->Asl.ParseOpcode != PARSEOP_POWERRESOURCE) &&
+        (CallerOp->Asl.ParseOpcode != PARSEOP_PROCESSOR) &&
+        (CallerOp->Asl.ParseOpcode != PARSEOP_THERMALZONE))
+    {
+        CallerOp = CallerOp->Asl.Parent;
+    }
+
+    if (CallerOp == XrefInfo->CurrentMethodOp)
+    {
+        return (AE_OK);
+    }
+
+    /* Null CallerOp means the caller is at the namespace root */
+
+    if (CallerOp)
+    {
+        CallerFullPathname = AcpiNsGetNormalizedPathname (
+            CallerOp->Asl.Node, TRUE);
+    }
+
+    /* There are some special cases for the oddball operators */
+
+    if (Op->Asl.ParseOpcode == PARSEOP_SCOPE)
+    {
+        Operator = "Scope";
+    }
+    else if (Op->Asl.Parent->Asl.ParseOpcode == PARSEOP_ALIAS)
+    {
+        Operator = "Alias";
+    }
+    else if (!CallerOp)
+    {
+        Operator = "ModLevel";
+    }
+    else
+    {
+        Operator = AcpiUtGetTypeName (CallerOp->Asl.Node->Type);
+    }
+
+    FlPrintFile (ASL_FILE_XREF_OUTPUT,
+        "[%5u]     %-40s %-8s via path: %s, Operator: %s\n",
+        Op->Asl.LogicalLineNumber,
+        CallerFullPathname ? CallerFullPathname : "<root>",
+        Operator,
+        Op->Asl.ExternalName,
+        Op->Asl.Parent->Asl.ParseOpName);
+
+    if (!CallerOp)
+    {
+        CallerOp = ACPI_TO_POINTER (0xFFFFFFFF);
+    }
+
+    if (CallerFullPathname)
+    {
+        ACPI_FREE (CallerFullPathname);
+    }
+
+    XrefInfo->CurrentMethodOp = CallerOp;
+    XrefInfo->ThisObjectReferences++;
+    return (AE_OK);
+}
diff --git a/usr/src/cmd/acpi/iasl/dtcompile.c b/usr/src/cmd/acpi/iasl/dtcompile.c
new file mode 100644
index 0000000000..704b55f871
--- /dev/null
+++ b/usr/src/cmd/acpi/iasl/dtcompile.c
@@ -0,0 +1,728 @@
+/******************************************************************************
+ *
+ * Module Name: dtcompile.c - Front-end for data table compiler
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2016, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#define _DECLARE_DT_GLOBALS
+
+#include "aslcompiler.h"
+#include "dtcompiler.h"
+
+#define _COMPONENT          DT_COMPILER
+        ACPI_MODULE_NAME    ("dtcompile")
+
+static char                 VersionString[9];
+
+
+/* Local prototypes */
+
+static ACPI_STATUS
+DtInitialize (
+    void);
+
+static ACPI_STATUS
+DtCompileDataTable (
+    DT_FIELD                **Field);
+
+static void
+DtInsertCompilerIds (
+    DT_FIELD                *FieldList);
+
+
+/******************************************************************************
+ *
+ * FUNCTION:    DtDoCompile
+ *
+ * PARAMETERS:  None
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Main entry point for the data table compiler.
+ *
+ * Note: Assumes Gbl_Files[ASL_FILE_INPUT] is initialized and the file is
+ *          open at seek offset zero.
+ *
+ *****************************************************************************/
+
+ACPI_STATUS
+DtDoCompile (
+    void)
+{
+    ACPI_STATUS             Status;
+    UINT8                   Event;
+    DT_FIELD                *FieldList;
+
+
+    /* Initialize globals */
+
+    Status = DtInitialize ();
+    if (ACPI_FAILURE (Status))
+    {
+        printf ("Error during compiler initialization, 0x%X\n", Status);
+        return (Status);
+    }
+
+    /* Preprocessor */
+
+    if (Gbl_PreprocessFlag)
+    {
+        /* Preprocessor */
+
+        Event = UtBeginEvent ("Preprocess input file");
+        PrDoPreprocess ();
+        UtEndEvent (Event);
+
+        if (Gbl_PreprocessOnly)
+        {
+            return (AE_OK);
+        }
+    }
+
+    /*
+     * Scan the input file (file is already open) and
+     * build the parse tree
+     */
+    Event = UtBeginEvent ("Scan and parse input file");
+    FieldList = DtScanFile (Gbl_Files[ASL_FILE_INPUT].Handle);
+    UtEndEvent (Event);
+
+    /* Did the parse tree get successfully constructed? */
+
+    if (!FieldList)
+    {
+        /* TBD: temporary error message. Msgs should come from function above */
+
+        DtError (ASL_ERROR, ASL_MSG_SYNTAX, NULL,
+            "Input file does not appear to be an ASL or data table source file");
+
+        Status = AE_ERROR;
+        goto CleanupAndExit;
+    }
+
+    Event = UtBeginEvent ("Compile parse tree");
+
+    /*
+     * Compile the parse tree
+     */
+    Status = DtCompileDataTable (&FieldList);
+    UtEndEvent (Event);
+
+    if (ACPI_FAILURE (Status))
+    {
+        /* TBD: temporary error message. Msgs should come from function above */
+
+        DtError (ASL_ERROR, ASL_MSG_SYNTAX, NULL,
+            "Could not compile input file");
+
+        goto CleanupAndExit;
+    }
+
+    /* Create/open the binary output file */
+
+    Gbl_Files[ASL_FILE_AML_OUTPUT].Filename = NULL;
+    Status = FlOpenAmlOutputFile (Gbl_OutputFilenamePrefix);
+    if (ACPI_FAILURE (Status))
+    {
+        goto CleanupAndExit;
+    }
+
+    /* Write the binary, then the optional hex file */
+
+    DtOutputBinary (Gbl_RootTable);
+    HxDoHexOutput ();
+    DtWriteTableToListing ();
+
+CleanupAndExit:
+
+    AcpiUtDeleteCaches ();
+    DtDeleteCaches ();
+    CmCleanupAndExit ();
+    return (Status);
+}
+
+
+/******************************************************************************
+ *
+ * FUNCTION:    DtInitialize
+ *
+ * PARAMETERS:  None
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Initialize data table compiler globals. Enables multiple
+ *              compiles per invocation.
+ *
+ *****************************************************************************/
+
+static ACPI_STATUS
+DtInitialize (
+    void)
+{
+    ACPI_STATUS             Status;
+
+
+    Status = AcpiOsInitialize ();
+    if (ACPI_FAILURE (Status))
+    {
+        return (Status);
+    }
+
+    Status = AcpiUtInitGlobals ();
+    if (ACPI_FAILURE (Status))
+    {
+        return (Status);
+    }
+
+    Gbl_FieldList = NULL;
+    Gbl_RootTable = NULL;
+    Gbl_SubtableStack = NULL;
+
+    sprintf (VersionString, "%X", (UINT32) ACPI_CA_VERSION);
+    return (AE_OK);
+}
+
+
+/******************************************************************************
+ *
+ * FUNCTION:    DtInsertCompilerIds
+ *
+ * PARAMETERS:  FieldList           - Current field list pointer
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Insert the IDs (Name, Version) of the current compiler into
+ *              the original ACPI table header.
+ *
+ *****************************************************************************/
+
+static void
+DtInsertCompilerIds (
+    DT_FIELD                *FieldList)
+{
+    DT_FIELD                *Next;
+    UINT32                  i;
+
+
+    /*
+     * Don't insert current compiler ID if requested. Used for compiler
+     * debug/validation only.
+     */
+    if (Gbl_UseOriginalCompilerId)
+    {
+        return;
+    }
+
+    /* Walk to the Compiler fields at the end of the header */
+
+    Next = FieldList;
+    for (i = 0; i < 7; i++)
+    {
+        Next = Next->Next;
+    }
+
+    Next->Value = ASL_CREATOR_ID;
+    Next->Flags = DT_FIELD_NOT_ALLOCATED;
+
+    Next = Next->Next;
+    Next->Value = VersionString;
+    Next->Flags = DT_FIELD_NOT_ALLOCATED;
+}
+
+
+/******************************************************************************
+ *
+ * FUNCTION:    DtCompileDataTable
+ *
+ * PARAMETERS:  FieldList           - Current field list pointer
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Entry point to compile one data table
+ *
+ *****************************************************************************/
+
+static ACPI_STATUS
+DtCompileDataTable (
+    DT_FIELD                **FieldList)
+{
+    const ACPI_DMTABLE_DATA *TableData;
+    DT_SUBTABLE             *Subtable;
+    char                    *Signature;
+    ACPI_TABLE_HEADER       *AcpiTableHeader;
+    ACPI_STATUS             Status;
+    DT_FIELD                *RootField = *FieldList;
+
+
+    /* Verify that we at least have a table signature and save it */
+
+    Signature = DtGetFieldValue (*FieldList);
+    if (!Signature)
+    {
+        sprintf (MsgBuffer, "Expected \"%s\"", "Signature");
+        DtNameError (ASL_ERROR, ASL_MSG_INVALID_FIELD_NAME,
+            *FieldList, MsgBuffer);
+        return (AE_ERROR);
+    }
+
+    Gbl_Signature = UtStringCacheCalloc (strlen (Signature) + 1);
+    strcpy (Gbl_Signature, Signature);
+
+    /*
+     * Handle tables that don't use the common ACPI table header structure.
+     * Currently, these are the FACS and RSDP. Also check for an OEMx table,
+     * these tables have user-defined contents.
+     */
+    if (ACPI_COMPARE_NAME (Signature, ACPI_SIG_FACS))
+    {
+        Status = DtCompileFacs (FieldList);
+        if (ACPI_FAILURE (Status))
+        {
+            return (Status);
+        }
+
+        DtSetTableLength ();
+        return (Status);
+    }
+    else if (ACPI_VALIDATE_RSDP_SIG (Signature))
+    {
+        Status = DtCompileRsdp (FieldList);
+        return (Status);
+    }
+    else if (ACPI_COMPARE_NAME (Signature, ACPI_SIG_S3PT))
+    {
+        Status = DtCompileS3pt (FieldList);
+        if (ACPI_FAILURE (Status))
+        {
+            return (Status);
+        }
+
+        DtSetTableLength ();
+        return (Status);
+    }
+
+    /*
+     * All other tables must use the common ACPI table header. Insert the
+     * current iASL IDs (name, version), and compile the header now.
+     */
+    DtInsertCompilerIds (*FieldList);
+
+    Status = DtCompileTable (FieldList, AcpiDmTableInfoHeader,
+        &Gbl_RootTable, TRUE);
+    if (ACPI_FAILURE (Status))
+    {
+        return (Status);
+    }
+
+    DtPushSubtable (Gbl_RootTable);
+
+    /* Validate the signature via the ACPI table list */
+
+    TableData = AcpiDmGetTableData (Signature);
+    if (!TableData || Gbl_CompileGeneric)
+    {
+        /* Unknown table signature and/or force generic compile */
+
+        DtCompileGeneric ((void **) FieldList, NULL, NULL);
+        goto FinishHeader;
+    }
+
+    /* Dispatch to per-table compile */
+
+    if (TableData->CmTableHandler)
+    {
+        /* Complex table, has a handler */
+
+        Status = TableData->CmTableHandler ((void **) FieldList);
+        if (ACPI_FAILURE (Status))
+        {
+            return (Status);
+        }
+    }
+    else if (TableData->TableInfo)
+    {
+        /* Simple table, just walk the info table */
+
+        Subtable = NULL;
+        Status = DtCompileTable (FieldList, TableData->TableInfo,
+            &Subtable, TRUE);
+        if (ACPI_FAILURE (Status))
+        {
+            return (Status);
+        }
+
+        DtInsertSubtable (Gbl_RootTable, Subtable);
+        DtPopSubtable ();
+    }
+    else
+    {
+        DtFatal (ASL_MSG_COMPILER_INTERNAL, *FieldList,
+            "Missing table dispatch info");
+        return (AE_ERROR);
+    }
+
+FinishHeader:
+
+    /* Set the final table length and then the checksum */
+
+    DtSetTableLength ();
+    AcpiTableHeader = ACPI_CAST_PTR (
+        ACPI_TABLE_HEADER, Gbl_RootTable->Buffer);
+    DtSetTableChecksum (&AcpiTableHeader->Checksum);
+
+    DtDumpFieldList (RootField);
+    DtDumpSubtableList ();
+    return (AE_OK);
+}
+
+
+/******************************************************************************
+ *
+ * FUNCTION:    DtCompileTable
+ *
+ * PARAMETERS:  Field               - Current field list pointer
+ *              Info                - Info table for this ACPI table
+ *              RetSubtable         - Compile result of table
+ *              Required            - If this subtable must exist
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Compile a subtable
+ *
+ *****************************************************************************/
+
+ACPI_STATUS
+DtCompileTable (
+    DT_FIELD                **Field,
+    ACPI_DMTABLE_INFO       *Info,
+    DT_SUBTABLE             **RetSubtable,
+    BOOLEAN                 Required)
+{
+    DT_FIELD                *LocalField;
+    UINT32                  Length;
+    DT_SUBTABLE             *Subtable;
+    DT_SUBTABLE             *InlineSubtable = NULL;
+    UINT32                  FieldLength = 0;
+    UINT8                   FieldType;
+    UINT8                   *Buffer;
+    UINT8                   *FlagBuffer = NULL;
+    char                    *String;
+    UINT32                  CurrentFlagByteOffset = 0;
+    ACPI_STATUS             Status = AE_OK;
+
+
+    if (!Field || !*Field)
+    {
+        return (AE_BAD_PARAMETER);
+    }
+
+    /* Ignore optional subtable if name does not match */
+
+    if ((Info->Flags & DT_OPTIONAL) &&
+        strcmp ((*Field)->Name, Info->Name))
+    {
+        *RetSubtable = NULL;
+        return (AE_OK);
+    }
+
+    Length = DtGetSubtableLength (*Field, Info);
+    if (Length == ASL_EOF)
+    {
+        return (AE_ERROR);
+    }
+
+    Subtable = UtSubtableCacheCalloc ();
+
+    if (Length > 0)
+    {
+        String = UtStringCacheCalloc (Length);
+        Subtable->Buffer = ACPI_CAST_PTR (UINT8, String);
+    }
+
+    Subtable->Length = Length;
+    Subtable->TotalLength = Length;
+    Buffer = Subtable->Buffer;
+
+    LocalField = *Field;
+    Subtable->Name = LocalField->Name;
+
+    /*
+     * Main loop walks the info table for this ACPI table or subtable
+     */
+    for (; Info->Name; Info++)
+    {
+        if (Info->Opcode == ACPI_DMT_EXTRA_TEXT)
+        {
+            continue;
+        }
+
+        if (!LocalField)
+        {
+            sprintf (MsgBuffer, "Found NULL field - Field name \"%s\" needed",
+                Info->Name);
+            DtFatal (ASL_MSG_COMPILER_INTERNAL, NULL, MsgBuffer);
+            Status = AE_BAD_DATA;
+            goto Error;
+        }
+
+        /* Maintain table offsets */
+
+        LocalField->TableOffset = Gbl_CurrentTableOffset;
+        FieldLength = DtGetFieldLength (LocalField, Info);
+        Gbl_CurrentTableOffset += FieldLength;
+
+        FieldType = DtGetFieldType (Info);
+        Gbl_InputFieldCount++;
+
+        switch (FieldType)
+        {
+        case DT_FIELD_TYPE_FLAGS_INTEGER:
+            /*
+             * Start of the definition of a flags field.
+             * This master flags integer starts at value zero, in preparation
+             * to compile and insert the flag fields from the individual bits
+             */
+            LocalField = LocalField->Next;
+            *Field = LocalField;
+
+            FlagBuffer = Buffer;
+            CurrentFlagByteOffset = Info->Offset;
+            break;
+
+        case DT_FIELD_TYPE_FLAG:
+
+            /* Individual Flag field, can be multiple bits */
+
+            if (FlagBuffer)
+            {
+                /*
+                 * We must increment the FlagBuffer when we have crossed
+                 * into the next flags byte within the flags field
+                 * of type DT_FIELD_TYPE_FLAGS_INTEGER.
+                 */
+                FlagBuffer += (Info->Offset - CurrentFlagByteOffset);
+                CurrentFlagByteOffset = Info->Offset;
+
+                DtCompileFlag (FlagBuffer, LocalField, Info);
+            }
+            else
+            {
+                /* TBD - this is an internal error */
+            }
+
+            LocalField = LocalField->Next;
+            *Field = LocalField;
+            break;
+
+        case DT_FIELD_TYPE_INLINE_SUBTABLE:
+            /*
+             * Recursion (one level max): compile GAS (Generic Address)
+             * or Notify in-line subtable
+             */
+            *Field = LocalField;
+
+            switch (Info->Opcode)
+            {
+            case ACPI_DMT_GAS:
+
+                Status = DtCompileTable (Field, AcpiDmTableInfoGas,
+                    &InlineSubtable, TRUE);
+                break;
+
+            case ACPI_DMT_HESTNTFY:
+
+                Status = DtCompileTable (Field, AcpiDmTableInfoHestNotify,
+                    &InlineSubtable, TRUE);
+                break;
+
+            case ACPI_DMT_IORTMEM:
+
+                Status = DtCompileTable (Field, AcpiDmTableInfoIortAcc,
+                    &InlineSubtable, TRUE);
+                break;
+
+            default:
+                sprintf (MsgBuffer, "Invalid DMT opcode: 0x%.2X",
+                    Info->Opcode);
+                DtFatal (ASL_MSG_COMPILER_INTERNAL, NULL, MsgBuffer);
+                Status = AE_BAD_DATA;
+                break;
+            }
+
+            if (ACPI_FAILURE (Status))
+            {
+                goto Error;
+            }
+
+            DtSetSubtableLength (InlineSubtable);
+
+            memcpy (Buffer, InlineSubtable->Buffer, FieldLength);
+            LocalField = *Field;
+            break;
+
+        case DT_FIELD_TYPE_LABEL:
+
+            DtWriteFieldToListing (Buffer, LocalField, 0);
+            LocalField = LocalField->Next;
+            break;
+
+        default:
+
+            /* Normal case for most field types (Integer, String, etc.) */
+
+            DtCompileOneField (Buffer, LocalField,
+                FieldLength, FieldType, Info->Flags);
+
+            DtWriteFieldToListing (Buffer, LocalField, FieldLength);
+            LocalField = LocalField->Next;
+
+            if (Info->Flags & DT_LENGTH)
+            {
+                /* Field is an Integer that will contain a subtable length */
+
+                Subtable->LengthField = Buffer;
+                Subtable->SizeOfLengthField = FieldLength;
+            }
+            break;
+        }
+
+        Buffer += FieldLength;
+    }
+
+    *Field = LocalField;
+    *RetSubtable = Subtable;
+    return (AE_OK);
+
+Error:
+    ACPI_FREE (Subtable->Buffer);
+    ACPI_FREE (Subtable);
+    return (Status);
+}
+
+
+/******************************************************************************
+ *
+ * FUNCTION:    DtCompileTwoSubtables
+ *
+ * PARAMETERS:  List                - Current field list pointer
+ *              TableInfo1          - Info table 1
+ *              TableInfo1          - Info table 2
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Compile tables with a header and one or more same subtables.
+ *              Include CPEP, EINJ, ERST, MCFG, MSCT, WDAT
+ *
+ *****************************************************************************/
+
+ACPI_STATUS
+DtCompileTwoSubtables (
+    void                    **List,
+    ACPI_DMTABLE_INFO       *TableInfo1,
+    ACPI_DMTABLE_INFO       *TableInfo2)
+{
+    ACPI_STATUS             Status;
+    DT_SUBTABLE             *Subtable;
+    DT_SUBTABLE             *ParentTable;
+    DT_FIELD                **PFieldList = (DT_FIELD **) List;
+
+
+    Status = DtCompileTable (PFieldList, TableInfo1, &Subtable, TRUE);
+    if (ACPI_FAILURE (Status))
+    {
+        return (Status);
+    }
+
+    ParentTable = DtPeekSubtable ();
+    DtInsertSubtable (ParentTable, Subtable);
+
+    while (*PFieldList)
+    {
+        Status = DtCompileTable (PFieldList, TableInfo2, &Subtable, FALSE);
+        if (ACPI_FAILURE (Status))
+        {
+            return (Status);
+        }
+
+        DtInsertSubtable (ParentTable, Subtable);
+    }
+
+    return (AE_OK);
+}
+
+
+/******************************************************************************
+ *
+ * FUNCTION:    DtCompilePadding
+ *
+ * PARAMETERS:  Length              - Padding field size
+ *              RetSubtable         - Compile result of table
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Compile a subtable for padding purpose
+ *
+ *****************************************************************************/
+
+ACPI_STATUS
+DtCompilePadding (
+    UINT32                  Length,
+    DT_SUBTABLE             **RetSubtable)
+{
+    DT_SUBTABLE             *Subtable;
+    /* UINT8                   *Buffer; */
+    char                    *String;
+
+
+    Subtable = UtSubtableCacheCalloc ();
+
+    if (Length > 0)
+    {
+        String = UtStringCacheCalloc (Length);
+        Subtable->Buffer = ACPI_CAST_PTR (UINT8, String);
+    }
+
+    Subtable->Length = Length;
+    Subtable->TotalLength = Length;
+    /* Buffer = Subtable->Buffer; */
+
+    *RetSubtable = Subtable;
+    return (AE_OK);
+}
diff --git a/usr/src/cmd/acpi/iasl/dtcompiler.h b/usr/src/cmd/acpi/iasl/dtcompiler.h
new file mode 100644
index 0000000000..8102e8203a
--- /dev/null
+++ b/usr/src/cmd/acpi/iasl/dtcompiler.h
@@ -0,0 +1,633 @@
+/******************************************************************************
+ *
+ * Module Name: dtcompiler.h - header for data table compiler
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2016, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#define __DTCOMPILER_H__
+
+#ifndef _DTCOMPILER
+#define _DTCOMPILER
+
+#include <stdio.h>
+#include "acdisasm.h"
+
+
+#define ASL_FIELD_CACHE_SIZE            512
+#define ASL_SUBTABLE_CACHE_SIZE         128
+
+
+#undef DT_EXTERN
+
+#ifdef _DECLARE_DT_GLOBALS
+#define DT_EXTERN
+#define DT_INIT_GLOBAL(a,b)         (a)=(b)
+#else
+#define DT_EXTERN                   extern
+#define DT_INIT_GLOBAL(a,b)         (a)
+#endif
+
+
+/* Types for individual fields (one per input line) */
+
+#define DT_FIELD_TYPE_STRING            0
+#define DT_FIELD_TYPE_INTEGER           1
+#define DT_FIELD_TYPE_BUFFER            2
+#define DT_FIELD_TYPE_PCI_PATH          3
+#define DT_FIELD_TYPE_FLAG              4
+#define DT_FIELD_TYPE_FLAGS_INTEGER     5
+#define DT_FIELD_TYPE_INLINE_SUBTABLE   6
+#define DT_FIELD_TYPE_UUID              7
+#define DT_FIELD_TYPE_UNICODE           8
+#define DT_FIELD_TYPE_DEVICE_PATH       9
+#define DT_FIELD_TYPE_LABEL             10
+
+
+/*
+ * Structure used for each individual field within an ACPI table
+ */
+typedef struct dt_field
+{
+    char                    *Name;       /* Field name (from name : value) */
+    char                    *Value;      /* Field value (from name : value) */
+    UINT32                  StringLength;/* Length of Value */
+    struct dt_field         *Next;       /* Next field */
+    struct dt_field         *NextLabel;  /* If field is a label, next label */
+    UINT32                  Line;        /* Line number for this field */
+    UINT32                  ByteOffset;  /* Offset in source file for field */
+    UINT32                  NameColumn;  /* Start column for field name */
+    UINT32                  Column;      /* Start column for field value */
+    UINT32                  TableOffset; /* Binary offset within ACPI table */
+    UINT8                   Flags;
+
+} DT_FIELD;
+
+/* Flags for above */
+
+#define DT_FIELD_NOT_ALLOCATED      1
+
+
+/*
+ * Structure used for individual subtables within an ACPI table
+ */
+typedef struct dt_subtable
+{
+    struct dt_subtable      *Parent;
+    struct dt_subtable      *Child;
+    struct dt_subtable      *Peer;
+    struct dt_subtable      *StackTop;
+    UINT8                   *Buffer;
+    UINT8                   *LengthField;
+    char                    *Name;
+    UINT32                  Length;
+    UINT32                  TotalLength;
+    UINT32                  SizeOfLengthField;
+    UINT16                  Depth;
+    UINT8                   Flags;
+
+} DT_SUBTABLE;
+
+
+/*
+ * Globals
+ */
+
+/* List of all field names and values from the input source */
+
+DT_EXTERN DT_FIELD          DT_INIT_GLOBAL (*Gbl_FieldList, NULL);
+
+/* List of all compiled tables and subtables */
+
+DT_EXTERN DT_SUBTABLE       DT_INIT_GLOBAL (*Gbl_RootTable, NULL);
+
+/* Stack for subtables */
+
+DT_EXTERN DT_SUBTABLE       DT_INIT_GLOBAL (*Gbl_SubtableStack, NULL);
+
+/* List for defined labels */
+
+DT_EXTERN DT_FIELD          DT_INIT_GLOBAL (*Gbl_LabelList, NULL);
+
+/* Current offset within the binary output table */
+
+DT_EXTERN UINT32            DT_INIT_GLOBAL (Gbl_CurrentTableOffset, 0);
+
+/* Local caches */
+
+DT_EXTERN UINT32            DT_INIT_GLOBAL (Gbl_SubtableCount, 0);
+DT_EXTERN ASL_CACHE_INFO    DT_INIT_GLOBAL (*Gbl_SubtableCacheList, NULL);
+DT_EXTERN DT_SUBTABLE       DT_INIT_GLOBAL (*Gbl_SubtableCacheNext, NULL);
+DT_EXTERN DT_SUBTABLE       DT_INIT_GLOBAL (*Gbl_SubtableCacheLast, NULL);
+
+DT_EXTERN UINT32            DT_INIT_GLOBAL (Gbl_FieldCount, 0);
+DT_EXTERN ASL_CACHE_INFO    DT_INIT_GLOBAL (*Gbl_FieldCacheList, NULL);
+DT_EXTERN DT_FIELD          DT_INIT_GLOBAL (*Gbl_FieldCacheNext, NULL);
+DT_EXTERN DT_FIELD          DT_INIT_GLOBAL (*Gbl_FieldCacheLast, NULL);
+
+
+/* dtcompiler - main module */
+
+ACPI_STATUS
+DtCompileTable (
+    DT_FIELD                **Field,
+    ACPI_DMTABLE_INFO       *Info,
+    DT_SUBTABLE             **RetSubtable,
+    BOOLEAN                 Required);
+
+ACPI_STATUS
+DtCompileTwoSubtables (
+    void                    **List,
+    ACPI_DMTABLE_INFO       *TableInfo1,
+    ACPI_DMTABLE_INFO       *TableInfo2);
+
+ACPI_STATUS
+DtCompilePadding (
+    UINT32                  Length,
+    DT_SUBTABLE             **RetSubtable);
+
+
+/* dtio - binary and text input/output */
+
+UINT32
+DtGetNextLine (
+    FILE                    *Handle,
+    UINT32                  Flags);
+
+/* Flags for DtGetNextLine */
+
+#define DT_ALLOW_MULTILINE_QUOTES   0x01
+
+
+DT_FIELD *
+DtScanFile (
+    FILE                    *Handle);
+
+void
+DtOutputBinary (
+    DT_SUBTABLE             *RootTable);
+
+void
+DtDumpSubtableList (
+    void);
+
+void
+DtDumpFieldList (
+    DT_FIELD                *Field);
+
+void
+DtWriteFieldToListing (
+    UINT8                   *Buffer,
+    DT_FIELD                *Field,
+    UINT32                  Length);
+
+void
+DtWriteTableToListing (
+    void);
+
+
+/* dtsubtable - compile subtables */
+
+void
+DtCreateSubtable (
+    UINT8                   *Buffer,
+    UINT32                  Length,
+    DT_SUBTABLE             **RetSubtable);
+
+UINT32
+DtGetSubtableLength (
+    DT_FIELD                *Field,
+    ACPI_DMTABLE_INFO       *Info);
+
+void
+DtSetSubtableLength (
+    DT_SUBTABLE             *Subtable);
+
+void
+DtPushSubtable (
+    DT_SUBTABLE             *Subtable);
+
+void
+DtPopSubtable (
+    void);
+
+DT_SUBTABLE *
+DtPeekSubtable (
+    void);
+
+void
+DtInsertSubtable (
+    DT_SUBTABLE             *ParentTable,
+    DT_SUBTABLE             *Subtable);
+
+DT_SUBTABLE *
+DtGetNextSubtable (
+    DT_SUBTABLE             *ParentTable,
+    DT_SUBTABLE             *ChildTable);
+
+DT_SUBTABLE *
+DtGetParentSubtable (
+    DT_SUBTABLE             *Subtable);
+
+
+/* dtexpress - Integer expressions and labels */
+
+ACPI_STATUS
+DtResolveIntegerExpression (
+    DT_FIELD                *Field,
+    UINT64                  *ReturnValue);
+
+UINT64
+DtDoOperator (
+    UINT64                  LeftValue,
+    UINT32                  Operator,
+    UINT64                  RightValue);
+
+UINT64
+DtResolveLabel (
+    char                    *LabelString);
+
+void
+DtDetectAllLabels (
+    DT_FIELD                *FieldList);
+
+
+/* dtfield - Compile individual fields within a table */
+
+void
+DtCompileOneField (
+    UINT8                   *Buffer,
+    DT_FIELD                *Field,
+    UINT32                  ByteLength,
+    UINT8                   Type,
+    UINT8                   Flags);
+
+void
+DtCompileInteger (
+    UINT8                   *Buffer,
+    DT_FIELD                *Field,
+    UINT32                  ByteLength,
+    UINT8                   Flags);
+
+UINT32
+DtCompileBuffer (
+    UINT8                   *Buffer,
+    char                    *Value,
+    DT_FIELD                *Field,
+    UINT32                  ByteLength);
+
+void
+DtCompileFlag (
+    UINT8                   *Buffer,
+    DT_FIELD                *Field,
+    ACPI_DMTABLE_INFO       *Info);
+
+
+/* dtparser - lex/yacc files */
+
+UINT64
+DtEvaluateExpression (
+    char                    *ExprString);
+
+int
+DtInitLexer (
+    char                    *String);
+
+void
+DtTerminateLexer (
+    void);
+
+char *
+DtGetOpName (
+    UINT32                  ParseOpcode);
+
+
+/* dtutils - Miscellaneous utilities */
+
+typedef
+void (*DT_WALK_CALLBACK) (
+    DT_SUBTABLE             *Subtable,
+    void                    *Context,
+    void                    *ReturnValue);
+
+void
+DtWalkTableTree (
+    DT_SUBTABLE             *StartTable,
+    DT_WALK_CALLBACK        UserFunction,
+    void                    *Context,
+    void                    *ReturnValue);
+
+void
+DtError (
+    UINT8                   Level,
+    UINT16                  MessageId,
+    DT_FIELD                *FieldObject,
+    char                    *ExtraMessage);
+
+void
+DtNameError (
+    UINT8                   Level,
+    UINT16                  MessageId,
+    DT_FIELD                *FieldObject,
+    char                    *ExtraMessage);
+
+void
+DtFatal (
+    UINT16                  MessageId,
+    DT_FIELD                *FieldObject,
+    char                    *ExtraMessage);
+
+ACPI_STATUS
+DtStrtoul64 (
+    char                    *String,
+    UINT64                  *ReturnInteger);
+
+char*
+DtGetFieldValue (
+    DT_FIELD                *Field);
+
+UINT8
+DtGetFieldType (
+    ACPI_DMTABLE_INFO       *Info);
+
+UINT32
+DtGetBufferLength (
+    char                    *Buffer);
+
+UINT32
+DtGetFieldLength (
+    DT_FIELD                *Field,
+    ACPI_DMTABLE_INFO       *Info);
+
+void
+DtSetTableChecksum (
+    UINT8                   *ChecksumPointer);
+
+void
+DtSetTableLength(
+    void);
+
+DT_SUBTABLE *
+UtSubtableCacheCalloc (
+    void);
+
+DT_FIELD *
+UtFieldCacheCalloc (
+    void);
+
+void
+DtDeleteCaches (
+    void);
+
+
+/* dttable - individual table compilation */
+
+ACPI_STATUS
+DtCompileFacs (
+    DT_FIELD                **PFieldList);
+
+ACPI_STATUS
+DtCompileRsdp (
+    DT_FIELD                **PFieldList);
+
+ACPI_STATUS
+DtCompileAsf (
+    void                    **PFieldList);
+
+ACPI_STATUS
+DtCompileCpep (
+    void                    **PFieldList);
+
+ACPI_STATUS
+DtCompileCsrt (
+    void                    **PFieldList);
+
+ACPI_STATUS
+DtCompileDbg2 (
+    void                    **PFieldList);
+
+ACPI_STATUS
+DtCompileDmar (
+    void                    **PFieldList);
+
+ACPI_STATUS
+DtCompileDrtm (
+    void                    **PFieldList);
+
+ACPI_STATUS
+DtCompileEinj (
+    void                    **PFieldList);
+
+ACPI_STATUS
+DtCompileErst (
+    void                    **PFieldList);
+
+ACPI_STATUS
+DtCompileFadt (
+    void                    **PFieldList);
+
+ACPI_STATUS
+DtCompileFpdt (
+    void                    **PFieldList);
+
+ACPI_STATUS
+DtCompileGtdt (
+    void                    **PFieldList);
+
+ACPI_STATUS
+DtCompileHest (
+    void                    **PFieldList);
+
+ACPI_STATUS
+DtCompileIort (
+    void                    **PFieldList);
+
+ACPI_STATUS
+DtCompileIvrs (
+    void                    **PFieldList);
+
+ACPI_STATUS
+DtCompileLpit (
+    void                    **PFieldList);
+
+ACPI_STATUS
+DtCompileMadt (
+    void                    **PFieldList);
+
+ACPI_STATUS
+DtCompileMcfg (
+    void                    **PFieldList);
+
+ACPI_STATUS
+DtCompileMpst (
+    void                    **PFieldList);
+
+ACPI_STATUS
+DtCompileMsct (
+    void                    **PFieldList);
+
+ACPI_STATUS
+DtCompileMtmr (
+    void                    **PFieldList);
+
+ACPI_STATUS
+DtCompileNfit (
+    void                    **PFieldList);
+
+ACPI_STATUS
+DtCompilePmtt (
+    void                    **PFieldList);
+
+ACPI_STATUS
+DtCompilePcct (
+    void                    **PFieldList);
+
+ACPI_STATUS
+DtCompileRsdt (
+    void                    **PFieldList);
+
+ACPI_STATUS
+DtCompileS3pt (
+    DT_FIELD                **PFieldList);
+
+ACPI_STATUS
+DtCompileSlic (
+    void                    **PFieldList);
+
+ACPI_STATUS
+DtCompileSlit (
+    void                    **PFieldList);
+
+ACPI_STATUS
+DtCompileSrat (
+    void                    **PFieldList);
+
+ACPI_STATUS
+DtCompileStao (
+    void                    **PFieldList);
+
+ACPI_STATUS
+DtCompileTcpa (
+    void                    **PFieldList);
+
+ACPI_STATUS
+DtCompileUefi (
+    void                    **PFieldList);
+
+ACPI_STATUS
+DtCompileVrtc (
+    void                    **PFieldList);
+
+ACPI_STATUS
+DtCompileWdat (
+    void                    **PFieldList);
+
+ACPI_STATUS
+DtCompileWpbt (
+    void                    **PFieldList);
+
+ACPI_STATUS
+DtCompileXsdt (
+    void                    **PFieldList);
+
+ACPI_STATUS
+DtCompileGeneric (
+    void                    **PFieldList,
+    char                    *TermFieldName,
+    UINT32                  *PFieldLength);
+
+ACPI_DMTABLE_INFO *
+DtGetGenericTableInfo (
+    char                    *Name);
+
+/* ACPI Table templates */
+
+extern const unsigned char  TemplateAsf[];
+extern const unsigned char  TemplateBoot[];
+extern const unsigned char  TemplateBert[];
+extern const unsigned char  TemplateBgrt[];
+extern const unsigned char  TemplateCpep[];
+extern const unsigned char  TemplateCsrt[];
+extern const unsigned char  TemplateDbg2[];
+extern const unsigned char  TemplateDbgp[];
+extern const unsigned char  TemplateDmar[];
+extern const unsigned char  TemplateDrtm[];
+extern const unsigned char  TemplateEcdt[];
+extern const unsigned char  TemplateEinj[];
+extern const unsigned char  TemplateErst[];
+extern const unsigned char  TemplateFadt[];
+extern const unsigned char  TemplateFpdt[];
+extern const unsigned char  TemplateGtdt[];
+extern const unsigned char  TemplateHest[];
+extern const unsigned char  TemplateHpet[];
+extern const unsigned char  TemplateIort[];
+extern const unsigned char  TemplateIvrs[];
+extern const unsigned char  TemplateLpit[];
+extern const unsigned char  TemplateMadt[];
+extern const unsigned char  TemplateMcfg[];
+extern const unsigned char  TemplateMchi[];
+extern const unsigned char  TemplateMpst[];
+extern const unsigned char  TemplateMsct[];
+extern const unsigned char  TemplateMsdm[];
+extern const unsigned char  TemplateMtmr[];
+extern const unsigned char  TemplateNfit[];
+extern const unsigned char  TemplatePcct[];
+extern const unsigned char  TemplatePmtt[];
+extern const unsigned char  TemplateRsdt[];
+extern const unsigned char  TemplateS3pt[];
+extern const unsigned char  TemplateSbst[];
+extern const unsigned char  TemplateSlic[];
+extern const unsigned char  TemplateSlit[];
+extern const unsigned char  TemplateSpcr[];
+extern const unsigned char  TemplateSpmi[];
+extern const unsigned char  TemplateSrat[];
+extern const unsigned char  TemplateStao[];
+extern const unsigned char  TemplateTcpa[];
+extern const unsigned char  TemplateTpm2[];
+extern const unsigned char  TemplateUefi[];
+extern const unsigned char  TemplateVrtc[];
+extern const unsigned char  TemplateWaet[];
+extern const unsigned char  TemplateWdat[];
+extern const unsigned char  TemplateWddt[];
+extern const unsigned char  TemplateWdrt[];
+extern const unsigned char  TemplateWpbt[];
+extern const unsigned char  TemplateXenv[];
+extern const unsigned char  TemplateXsdt[];
+
+#endif
diff --git a/usr/src/cmd/acpi/iasl/dtexpress.c b/usr/src/cmd/acpi/iasl/dtexpress.c
new file mode 100644
index 0000000000..278b14f33e
--- /dev/null
+++ b/usr/src/cmd/acpi/iasl/dtexpress.c
@@ -0,0 +1,427 @@
+/******************************************************************************
+ *
+ * Module Name: dtexpress.c - Support for integer expressions and labels
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2016, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include "aslcompiler.h"
+#include "dtcompiler.h"
+#include "dtparser.y.h"
+
+#define _COMPONENT          DT_COMPILER
+        ACPI_MODULE_NAME    ("dtexpress")
+
+
+/* Local prototypes */
+
+static void
+DtInsertLabelField (
+    DT_FIELD                *Field);
+
+static DT_FIELD *
+DtLookupLabel (
+    char                    *Name);
+
+/* Global used for errors during parse and related functions */
+
+DT_FIELD                *Gbl_CurrentField;
+
+
+/******************************************************************************
+ *
+ * FUNCTION:    DtResolveIntegerExpression
+ *
+ * PARAMETERS:  Field               - Field object with Integer expression
+ *              ReturnValue         - Where the integer is returned
+ *
+ * RETURN:      Status, and the resolved 64-bit integer value
+ *
+ * DESCRIPTION: Resolve an integer expression to a single value. Supports
+ *              both integer constants and labels.
+ *
+ *****************************************************************************/
+
+ACPI_STATUS
+DtResolveIntegerExpression (
+    DT_FIELD                *Field,
+    UINT64                  *ReturnValue)
+{
+    UINT64                  Result;
+
+
+    DbgPrint (ASL_DEBUG_OUTPUT, "Full Integer expression: %s\n",
+        Field->Value);
+
+    Gbl_CurrentField = Field;
+
+    Result = DtEvaluateExpression (Field->Value);
+    *ReturnValue = Result;
+    return (AE_OK);
+}
+
+
+/******************************************************************************
+ *
+ * FUNCTION:    DtDoOperator
+ *
+ * PARAMETERS:  LeftValue           - First 64-bit operand
+ *              Operator            - Parse token for the operator (EXPOP_*)
+ *              RightValue          - Second 64-bit operand
+ *
+ * RETURN:      64-bit result of the requested operation
+ *
+ * DESCRIPTION: Perform the various 64-bit integer math functions
+ *
+ *****************************************************************************/
+
+UINT64
+DtDoOperator (
+    UINT64                  LeftValue,
+    UINT32                  Operator,
+    UINT64                  RightValue)
+{
+    UINT64                  Result;
+
+
+    /* Perform the requested operation */
+
+    switch (Operator)
+    {
+    case EXPOP_ONES_COMPLIMENT:
+
+        Result = ~RightValue;
+        break;
+
+    case EXPOP_LOGICAL_NOT:
+
+        Result = !RightValue;
+        break;
+
+    case EXPOP_MULTIPLY:
+
+        Result = LeftValue * RightValue;
+        break;
+
+    case EXPOP_DIVIDE:
+
+        if (!RightValue)
+        {
+            DtError (ASL_ERROR, ASL_MSG_DIVIDE_BY_ZERO,
+                Gbl_CurrentField, NULL);
+            return (0);
+        }
+
+        Result = LeftValue / RightValue;
+        break;
+
+    case EXPOP_MODULO:
+
+        if (!RightValue)
+        {
+            DtError (ASL_ERROR, ASL_MSG_DIVIDE_BY_ZERO,
+                Gbl_CurrentField, NULL);
+            return (0);
+        }
+
+        Result = LeftValue % RightValue;
+        break;
+
+    case EXPOP_ADD:
+        Result = LeftValue + RightValue;
+        break;
+
+    case EXPOP_SUBTRACT:
+
+        Result = LeftValue - RightValue;
+        break;
+
+    case EXPOP_SHIFT_RIGHT:
+
+        Result = LeftValue >> RightValue;
+        break;
+
+    case EXPOP_SHIFT_LEFT:
+
+        Result = LeftValue << RightValue;
+        break;
+
+    case EXPOP_LESS:
+
+        Result = LeftValue < RightValue;
+        break;
+
+    case EXPOP_GREATER:
+
+        Result = LeftValue > RightValue;
+        break;
+
+    case EXPOP_LESS_EQUAL:
+
+        Result = LeftValue <= RightValue;
+        break;
+
+    case EXPOP_GREATER_EQUAL:
+
+        Result = LeftValue >= RightValue;
+        break;
+
+    case EXPOP_EQUAL:
+
+        Result = LeftValue == RightValue;
+        break;
+
+    case EXPOP_NOT_EQUAL:
+
+        Result = LeftValue != RightValue;
+        break;
+
+    case EXPOP_AND:
+
+        Result = LeftValue & RightValue;
+        break;
+
+    case EXPOP_XOR:
+
+        Result = LeftValue ^ RightValue;
+        break;
+
+    case EXPOP_OR:
+
+        Result = LeftValue | RightValue;
+        break;
+
+    case EXPOP_LOGICAL_AND:
+
+        Result = LeftValue && RightValue;
+        break;
+
+    case EXPOP_LOGICAL_OR:
+
+        Result = LeftValue || RightValue;
+        break;
+
+   default:
+
+        /* Unknown operator */
+
+        DtFatal (ASL_MSG_INVALID_EXPRESSION,
+            Gbl_CurrentField, NULL);
+        return (0);
+    }
+
+    DbgPrint (ASL_DEBUG_OUTPUT,
+        "IntegerEval: (%8.8X%8.8X %s %8.8X%8.8X) = %8.8X%8.8X\n",
+        ACPI_FORMAT_UINT64 (LeftValue),
+        DtGetOpName (Operator),
+        ACPI_FORMAT_UINT64 (RightValue),
+        ACPI_FORMAT_UINT64 (Result));
+
+    return (Result);
+}
+
+
+/******************************************************************************
+ *
+ * FUNCTION:    DtResolveLabel
+ *
+ * PARAMETERS:  LabelString         - Contains the label
+ *
+ * RETURN:      Table offset associated with the label
+ *
+ * DESCRIPTION: Lookup a lable and return its value.
+ *
+ *****************************************************************************/
+
+UINT64
+DtResolveLabel (
+    char                    *LabelString)
+{
+    DT_FIELD                *LabelField;
+
+
+    DbgPrint (ASL_DEBUG_OUTPUT, "Resolve Label: %s\n", LabelString);
+
+    /* Resolve a label reference to an integer (table offset) */
+
+    if (*LabelString != '$')
+    {
+        return (0);
+    }
+
+    LabelField = DtLookupLabel (LabelString);
+    if (!LabelField)
+    {
+        DtError (ASL_ERROR, ASL_MSG_UNKNOWN_LABEL,
+            Gbl_CurrentField, LabelString);
+        return (0);
+    }
+
+    /* All we need from the label is the offset in the table */
+
+    DbgPrint (ASL_DEBUG_OUTPUT, "Resolved Label: 0x%8.8X\n",
+        LabelField->TableOffset);
+
+    return (LabelField->TableOffset);
+}
+
+
+/******************************************************************************
+ *
+ * FUNCTION:    DtDetectAllLabels
+ *
+ * PARAMETERS:  FieldList           - Field object at start of generic list
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Detect all labels in a list of "generic" opcodes (such as
+ *              a UEFI table.) and insert them into the global label list.
+ *
+ *****************************************************************************/
+
+void
+DtDetectAllLabels (
+    DT_FIELD                *FieldList)
+{
+    ACPI_DMTABLE_INFO       *Info;
+    DT_FIELD                *GenericField;
+    UINT32                  TableOffset;
+
+
+    TableOffset = Gbl_CurrentTableOffset;
+    GenericField = FieldList;
+
+    /*
+     * Process all "Label:" fields within the parse tree. We need
+     * to know the offsets for all labels before we can compile
+     * the parse tree in order to handle forward references. Traverse
+     * tree and get/set all field lengths of all operators in order to
+     * determine the label offsets.
+     */
+    while (GenericField)
+    {
+        Info = DtGetGenericTableInfo (GenericField->Name);
+        if (Info)
+        {
+            /* Maintain table offsets */
+
+            GenericField->TableOffset = TableOffset;
+            TableOffset += DtGetFieldLength (GenericField, Info);
+
+            /* Insert all labels in the global label list */
+
+            if (Info->Opcode == ACPI_DMT_LABEL)
+            {
+                DtInsertLabelField (GenericField);
+            }
+        }
+
+        GenericField = GenericField->Next;
+    }
+}
+
+
+/******************************************************************************
+ *
+ * FUNCTION:    DtInsertLabelField
+ *
+ * PARAMETERS:  Field               - Field object with Label to be inserted
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Insert a label field into the global label list
+ *
+ *****************************************************************************/
+
+static void
+DtInsertLabelField (
+    DT_FIELD                *Field)
+{
+
+    DbgPrint (ASL_DEBUG_OUTPUT,
+        "DtInsertLabelField: Found Label : %s at output table offset %X\n",
+        Field->Value, Field->TableOffset);
+
+    Field->NextLabel = Gbl_LabelList;
+    Gbl_LabelList = Field;
+}
+
+
+/******************************************************************************
+ *
+ * FUNCTION:    DtLookupLabel
+ *
+ * PARAMETERS:  Name                - Label to be resolved
+ *
+ * RETURN:      Field object associated with the label
+ *
+ * DESCRIPTION: Lookup a label in the global label list. Used during the
+ *              resolution of integer expressions.
+ *
+ *****************************************************************************/
+
+static DT_FIELD *
+DtLookupLabel (
+    char                    *Name)
+{
+    DT_FIELD                *LabelField;
+
+
+    /* Skip a leading $ */
+
+    if (*Name == '$')
+    {
+        Name++;
+    }
+
+    /* Search global list */
+
+    LabelField = Gbl_LabelList;
+    while (LabelField)
+    {
+        if (!strcmp (Name, LabelField->Value))
+        {
+            return (LabelField);
+        }
+
+        LabelField = LabelField->NextLabel;
+    }
+
+    return (NULL);
+}
diff --git a/usr/src/cmd/acpi/iasl/dtfield.c b/usr/src/cmd/acpi/iasl/dtfield.c
new file mode 100644
index 0000000000..a34b8e16a0
--- /dev/null
+++ b/usr/src/cmd/acpi/iasl/dtfield.c
@@ -0,0 +1,587 @@
+/******************************************************************************
+ *
+ * Module Name: dtfield.c - Code generation for individual source fields
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2016, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include "aslcompiler.h"
+#include "dtcompiler.h"
+
+#define _COMPONENT          DT_COMPILER
+        ACPI_MODULE_NAME    ("dtfield")
+
+
+/* Local prototypes */
+
+static void
+DtCompileString (
+    UINT8                   *Buffer,
+    DT_FIELD                *Field,
+    UINT32                  ByteLength);
+
+static void
+DtCompileUnicode (
+    UINT8                   *Buffer,
+    DT_FIELD                *Field,
+    UINT32                  ByteLength);
+
+static ACPI_STATUS
+DtCompileUuid (
+    UINT8                   *Buffer,
+    DT_FIELD                *Field,
+    UINT32                  ByteLength);
+
+static char *
+DtNormalizeBuffer (
+    char                    *Buffer,
+    UINT32                  *Count);
+
+
+/******************************************************************************
+ *
+ * FUNCTION:    DtCompileOneField
+ *
+ * PARAMETERS:  Buffer              - Output buffer
+ *              Field               - Field to be compiled
+ *              ByteLength          - Byte length of the field
+ *              Type                - Field type
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Compile a field value to binary
+ *
+ *****************************************************************************/
+
+void
+DtCompileOneField (
+    UINT8                   *Buffer,
+    DT_FIELD                *Field,
+    UINT32                  ByteLength,
+    UINT8                   Type,
+    UINT8                   Flags)
+{
+    ACPI_STATUS             Status;
+
+
+    switch (Type)
+    {
+    case DT_FIELD_TYPE_INTEGER:
+
+        DtCompileInteger (Buffer, Field, ByteLength, Flags);
+        break;
+
+    case DT_FIELD_TYPE_STRING:
+
+        DtCompileString (Buffer, Field, ByteLength);
+        break;
+
+    case DT_FIELD_TYPE_UUID:
+
+        Status = DtCompileUuid (Buffer, Field, ByteLength);
+        if (ACPI_SUCCESS (Status))
+        {
+            break;
+        }
+
+        /* Fall through. */
+
+    case DT_FIELD_TYPE_BUFFER:
+
+        DtCompileBuffer (Buffer, Field->Value, Field, ByteLength);
+        break;
+
+    case DT_FIELD_TYPE_UNICODE:
+
+        DtCompileUnicode (Buffer, Field, ByteLength);
+        break;
+
+    case DT_FIELD_TYPE_DEVICE_PATH:
+
+        break;
+
+    default:
+
+        DtFatal (ASL_MSG_COMPILER_INTERNAL, Field, "Invalid field type");
+        break;
+    }
+}
+
+
+/******************************************************************************
+ *
+ * FUNCTION:    DtCompileString
+ *
+ * PARAMETERS:  Buffer              - Output buffer
+ *              Field               - String to be copied to buffer
+ *              ByteLength          - Maximum length of string
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Copy string to the buffer
+ *
+ *****************************************************************************/
+
+static void
+DtCompileString (
+    UINT8                   *Buffer,
+    DT_FIELD                *Field,
+    UINT32                  ByteLength)
+{
+    UINT32                  Length;
+
+
+    Length = strlen (Field->Value);
+
+    /* Check if the string is too long for the field */
+
+    if (Length > ByteLength)
+    {
+        sprintf (MsgBuffer, "Maximum %u characters", ByteLength);
+        DtError (ASL_ERROR, ASL_MSG_STRING_LENGTH, Field, MsgBuffer);
+        Length = ByteLength;
+    }
+
+    memcpy (Buffer, Field->Value, Length);
+}
+
+
+/******************************************************************************
+ *
+ * FUNCTION:    DtCompileUnicode
+ *
+ * PARAMETERS:  Buffer              - Output buffer
+ *              Field               - String to be copied to buffer
+ *              ByteLength          - Maximum length of string
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Convert ASCII string to Unicode string
+ *
+ * Note:  The Unicode string is 16 bits per character, no leading signature,
+ *        with a 16-bit terminating NULL.
+ *
+ *****************************************************************************/
+
+static void
+DtCompileUnicode (
+    UINT8                   *Buffer,
+    DT_FIELD                *Field,
+    UINT32                  ByteLength)
+{
+    UINT32                  Count;
+    UINT32                  i;
+    char                    *AsciiString;
+    UINT16                  *UnicodeString;
+
+
+    AsciiString = Field->Value;
+    UnicodeString = (UINT16 *) Buffer;
+    Count = strlen (AsciiString) + 1;
+
+    /* Convert to Unicode string (including null terminator) */
+
+    for (i = 0; i < Count; i++)
+    {
+        UnicodeString[i] = (UINT16) AsciiString[i];
+    }
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    DtCompileUuid
+ *
+ * PARAMETERS:  Buffer              - Output buffer
+ *              Field               - String to be copied to buffer
+ *              ByteLength          - Maximum length of string
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Convert UUID string to 16-byte buffer
+ *
+ ******************************************************************************/
+
+static ACPI_STATUS
+DtCompileUuid (
+    UINT8                   *Buffer,
+    DT_FIELD                *Field,
+    UINT32                  ByteLength)
+{
+    char                    *InString;
+    ACPI_STATUS             Status;
+
+
+    InString = Field->Value;
+
+    Status = AuValidateUuid (InString);
+    if (ACPI_FAILURE (Status))
+    {
+        sprintf (MsgBuffer, "%s", Field->Value);
+        DtNameError (ASL_ERROR, ASL_MSG_INVALID_UUID, Field, MsgBuffer);
+    }
+    else
+    {
+        AcpiUtConvertStringToUuid (InString, Buffer);
+    }
+
+    return (Status);
+}
+
+
+/******************************************************************************
+ *
+ * FUNCTION:    DtCompileInteger
+ *
+ * PARAMETERS:  Buffer              - Output buffer
+ *              Field               - Field obj with Integer to be compiled
+ *              ByteLength          - Byte length of the integer
+ *              Flags               - Additional compile info
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Compile an integer. Supports integer expressions with C-style
+ *              operators.
+ *
+ *****************************************************************************/
+
+void
+DtCompileInteger (
+    UINT8                   *Buffer,
+    DT_FIELD                *Field,
+    UINT32                  ByteLength,
+    UINT8                   Flags)
+{
+    UINT64                  Value;
+    UINT64                  MaxValue;
+    ACPI_STATUS             Status;
+
+
+    /* Output buffer byte length must be in range 1-8 */
+
+    if ((ByteLength > 8) || (ByteLength == 0))
+    {
+        DtFatal (ASL_MSG_COMPILER_INTERNAL, Field,
+            "Invalid internal Byte length");
+        return;
+    }
+
+    /* Resolve integer expression to a single integer value */
+
+    Status = DtResolveIntegerExpression (Field, &Value);
+    if (ACPI_FAILURE (Status))
+    {
+        return;
+    }
+
+    /*
+     * Ensure that reserved fields are set properly. Note: uses
+     * the DT_NON_ZERO flag to indicate that the reserved value
+     * must be exactly one. Otherwise, the value must be zero.
+     * This is sufficient for now.
+     */
+
+    /* TBD: Should use a flag rather than compare "Reserved" */
+
+    if (!strcmp (Field->Name, "Reserved"))
+    {
+        if (Flags & DT_NON_ZERO)
+        {
+            if (Value != 1)
+            {
+                DtError (ASL_WARNING, ASL_MSG_RESERVED_VALUE, Field,
+                    "Must be one, setting to one");
+                Value = 1;
+            }
+        }
+        else if (Value != 0)
+        {
+            DtError (ASL_WARNING, ASL_MSG_RESERVED_VALUE, Field,
+                "Must be zero, setting to zero");
+            Value = 0;
+        }
+    }
+
+    /* Check if the value must be non-zero */
+
+    else if ((Flags & DT_NON_ZERO) && (Value == 0))
+    {
+        DtError (ASL_ERROR, ASL_MSG_ZERO_VALUE, Field, NULL);
+    }
+
+    /*
+     * Generate the maximum value for the data type (ByteLength)
+     * Note: construct chosen for maximum portability
+     */
+    MaxValue = ((UINT64) (-1)) >> (64 - (ByteLength * 8));
+
+    /* Validate that the input value is within range of the target */
+
+    if (Value > MaxValue)
+    {
+        sprintf (MsgBuffer, "%8.8X%8.8X - max %u bytes",
+            ACPI_FORMAT_UINT64 (Value), ByteLength);
+        DtError (ASL_ERROR, ASL_MSG_INTEGER_SIZE, Field, MsgBuffer);
+    }
+
+    memcpy (Buffer, &Value, ByteLength);
+    return;
+}
+
+
+/******************************************************************************
+ *
+ * FUNCTION:    DtNormalizeBuffer
+ *
+ * PARAMETERS:  Buffer              - Input buffer
+ *              Count               - Output the count of hex number in
+ *                                    the Buffer
+ *
+ * RETURN:      The normalized buffer, freed by caller
+ *
+ * DESCRIPTION: [1A,2B,3C,4D] or 1A, 2B, 3C, 4D will be normalized
+ *              to 1A 2B 3C 4D
+ *
+ *****************************************************************************/
+
+static char *
+DtNormalizeBuffer (
+    char                    *Buffer,
+    UINT32                  *Count)
+{
+    char                    *NewBuffer;
+    char                    *TmpBuffer;
+    UINT32                  BufferCount = 0;
+    BOOLEAN                 Separator = TRUE;
+    char                    c;
+
+
+    NewBuffer = UtLocalCalloc (strlen (Buffer) + 1);
+    TmpBuffer = NewBuffer;
+
+    while ((c = *Buffer++))
+    {
+        switch (c)
+        {
+        /* Valid separators */
+
+        case '[':
+        case ']':
+        case ' ':
+        case ',':
+
+            Separator = TRUE;
+            break;
+
+        default:
+
+            if (Separator)
+            {
+                /* Insert blank as the standard separator */
+
+                if (NewBuffer[0])
+                {
+                    *TmpBuffer++ = ' ';
+                    BufferCount++;
+                }
+
+                Separator = FALSE;
+            }
+
+            *TmpBuffer++ = c;
+            break;
+        }
+    }
+
+    *Count = BufferCount + 1;
+    return (NewBuffer);
+}
+
+
+/******************************************************************************
+ *
+ * FUNCTION:    DtCompileBuffer
+ *
+ * PARAMETERS:  Buffer              - Output buffer
+ *              StringValue         - Integer list to be compiled
+ *              Field               - Current field object
+ *              ByteLength          - Byte length of the integer list
+ *
+ * RETURN:      Count of remaining data in the input list
+ *
+ * DESCRIPTION: Compile and pack an integer list, for example
+ *              "AA 1F 20 3B" ==> Buffer[] = {0xAA,0x1F,0x20,0x3B}
+ *
+ *****************************************************************************/
+
+UINT32
+DtCompileBuffer (
+    UINT8                   *Buffer,
+    char                    *StringValue,
+    DT_FIELD                *Field,
+    UINT32                  ByteLength)
+{
+    ACPI_STATUS             Status;
+    char                    Hex[3];
+    UINT64                  Value;
+    UINT32                  i;
+    UINT32                  Count;
+
+
+    /* Allow several different types of value separators */
+
+    StringValue = DtNormalizeBuffer (StringValue, &Count);
+
+    Hex[2] = 0;
+    for (i = 0; i < Count; i++)
+    {
+        /* Each element of StringValue is three chars */
+
+        Hex[0] = StringValue[(3 * i)];
+        Hex[1] = StringValue[(3 * i) + 1];
+
+        /* Convert one hex byte */
+
+        Value = 0;
+        Status = DtStrtoul64 (Hex, &Value);
+        if (ACPI_FAILURE (Status))
+        {
+            DtError (ASL_ERROR, ASL_MSG_BUFFER_ELEMENT, Field, MsgBuffer);
+            goto Exit;
+        }
+
+        Buffer[i] = (UINT8) Value;
+    }
+
+Exit:
+    ACPI_FREE (StringValue);
+    return (ByteLength - Count);
+}
+
+
+/******************************************************************************
+ *
+ * FUNCTION:    DtCompileFlag
+ *
+ * PARAMETERS:  Buffer              - Output buffer
+ *              Field               - Field to be compiled
+ *              Info                - Flag info
+ *
+ * RETURN:
+ *
+ * DESCRIPTION: Compile a flag
+ *
+ *****************************************************************************/
+
+void
+DtCompileFlag (
+    UINT8                   *Buffer,
+    DT_FIELD                *Field,
+    ACPI_DMTABLE_INFO       *Info)
+{
+    UINT64                  Value = 0;
+    UINT32                  BitLength = 1;
+    UINT8                   BitPosition = 0;
+    ACPI_STATUS             Status;
+
+
+    Status = DtStrtoul64 (Field->Value, &Value);
+    if (ACPI_FAILURE (Status))
+    {
+        DtError (ASL_ERROR, ASL_MSG_INVALID_HEX_INTEGER, Field, NULL);
+    }
+
+    switch (Info->Opcode)
+    {
+    case ACPI_DMT_FLAG0:
+    case ACPI_DMT_FLAG1:
+    case ACPI_DMT_FLAG2:
+    case ACPI_DMT_FLAG3:
+    case ACPI_DMT_FLAG4:
+    case ACPI_DMT_FLAG5:
+    case ACPI_DMT_FLAG6:
+    case ACPI_DMT_FLAG7:
+
+        BitPosition = Info->Opcode;
+        BitLength = 1;
+        break;
+
+    case ACPI_DMT_FLAGS0:
+
+        BitPosition = 0;
+        BitLength = 2;
+        break;
+
+
+    case ACPI_DMT_FLAGS1:
+
+        BitPosition = 1;
+        BitLength = 2;
+        break;
+
+
+    case ACPI_DMT_FLAGS2:
+
+        BitPosition = 2;
+        BitLength = 2;
+        break;
+
+    case ACPI_DMT_FLAGS4:
+
+        BitPosition = 4;
+        BitLength = 2;
+        break;
+
+    default:
+
+        DtFatal (ASL_MSG_COMPILER_INTERNAL, Field, "Invalid flag opcode");
+        break;
+    }
+
+    /* Check range of the input flag value */
+
+    if (Value >= ((UINT64) 1 << BitLength))
+    {
+        sprintf (MsgBuffer, "Maximum %u bit", BitLength);
+        DtError (ASL_ERROR, ASL_MSG_FLAG_VALUE, Field, MsgBuffer);
+        Value = 0;
+    }
+
+    *Buffer |= (UINT8) (Value << BitPosition);
+}
diff --git a/usr/src/cmd/acpi/iasl/dtio.c b/usr/src/cmd/acpi/iasl/dtio.c
new file mode 100644
index 0000000000..a24ad3442c
--- /dev/null
+++ b/usr/src/cmd/acpi/iasl/dtio.c
@@ -0,0 +1,1149 @@
+/******************************************************************************
+ *
+ * Module Name: dtio.c - File I/O support for data table compiler
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2016, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include "aslcompiler.h"
+#include "dtcompiler.h"
+#include "acapps.h"
+
+#define _COMPONENT          DT_COMPILER
+        ACPI_MODULE_NAME    ("dtio")
+
+
+/* Local prototypes */
+
+static char *
+DtTrim (
+    char                    *String);
+
+static void
+DtLinkField (
+    DT_FIELD                *Field);
+
+static ACPI_STATUS
+DtParseLine (
+    char                    *LineBuffer,
+    UINT32                  Line,
+    UINT32                  Offset);
+
+static void
+DtWriteBinary (
+    DT_SUBTABLE             *Subtable,
+    void                    *Context,
+    void                    *ReturnValue);
+
+static void
+DtDumpBuffer (
+    UINT32                  FileId,
+    UINT8                   *Buffer,
+    UINT32                  Offset,
+    UINT32                  Length);
+
+static void
+DtDumpSubtableInfo (
+    DT_SUBTABLE             *Subtable,
+    void                    *Context,
+    void                    *ReturnValue);
+
+static void
+DtDumpSubtableTree (
+    DT_SUBTABLE             *Subtable,
+    void                    *Context,
+    void                    *ReturnValue);
+
+
+/* States for DtGetNextLine */
+
+#define DT_NORMAL_TEXT              0
+#define DT_START_QUOTED_STRING      1
+#define DT_START_COMMENT            2
+#define DT_SLASH_ASTERISK_COMMENT   3
+#define DT_SLASH_SLASH_COMMENT      4
+#define DT_END_COMMENT              5
+#define DT_MERGE_LINES              6
+#define DT_ESCAPE_SEQUENCE          7
+
+static UINT32               Gbl_NextLineOffset;
+
+
+/******************************************************************************
+ *
+ * FUNCTION:    DtTrim
+ *
+ * PARAMETERS:  String              - Current source code line to trim
+ *
+ * RETURN:      Trimmed line. Must be freed by caller.
+ *
+ * DESCRIPTION: Trim left and right spaces
+ *
+ *****************************************************************************/
+
+static char *
+DtTrim (
+    char                    *String)
+{
+    char                    *Start;
+    char                    *End;
+    char                    *ReturnString;
+    ACPI_SIZE               Length;
+
+
+    /* Skip lines that start with a space */
+
+    if (!strcmp (String, " "))
+    {
+        ReturnString = UtStringCacheCalloc (1);
+        return (ReturnString);
+    }
+
+    /* Setup pointers to start and end of input string */
+
+    Start = String;
+    End = String + strlen (String) - 1;
+
+    /* Find first non-whitespace character */
+
+    while ((Start <= End) && ((*Start == ' ') || (*Start == '\t')))
+    {
+        Start++;
+    }
+
+    /* Find last non-space character */
+
+    while (End >= Start)
+    {
+        if (*End == '\r' || *End == '\n')
+        {
+            End--;
+            continue;
+        }
+
+        if (*End != ' ')
+        {
+            break;
+        }
+
+        End--;
+    }
+
+    /* Remove any quotes around the string */
+
+    if (*Start == '\"')
+    {
+        Start++;
+    }
+    if (*End == '\"')
+    {
+        End--;
+    }
+
+    /* Create the trimmed return string */
+
+    Length = ACPI_PTR_DIFF (End, Start) + 1;
+    ReturnString = UtStringCacheCalloc (Length + 1);
+    if (strlen (Start))
+    {
+        strncpy (ReturnString, Start, Length);
+    }
+
+    ReturnString[Length] = 0;
+    return (ReturnString);
+}
+
+
+/******************************************************************************
+ *
+ * FUNCTION:    DtLinkField
+ *
+ * PARAMETERS:  Field               - New field object to link
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Link one field name and value to the list
+ *
+ *****************************************************************************/
+
+static void
+DtLinkField (
+    DT_FIELD                *Field)
+{
+    DT_FIELD                *Prev;
+    DT_FIELD                *Next;
+
+
+    Prev = Next = Gbl_FieldList;
+
+    while (Next)
+    {
+        Prev = Next;
+        Next = Next->Next;
+    }
+
+    if (Prev)
+    {
+        Prev->Next = Field;
+    }
+    else
+    {
+        Gbl_FieldList = Field;
+    }
+}
+
+
+/******************************************************************************
+ *
+ * FUNCTION:    DtParseLine
+ *
+ * PARAMETERS:  LineBuffer          - Current source code line
+ *              Line                - Current line number in the source
+ *              Offset              - Current byte offset of the line
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Parse one source line
+ *
+ *****************************************************************************/
+
+static ACPI_STATUS
+DtParseLine (
+    char                    *LineBuffer,
+    UINT32                  Line,
+    UINT32                  Offset)
+{
+    char                    *Start;
+    char                    *End;
+    char                    *TmpName;
+    char                    *TmpValue;
+    char                    *Name;
+    char                    *Value;
+    char                    *Colon;
+    UINT32                  Length;
+    DT_FIELD                *Field;
+    UINT32                  Column;
+    UINT32                  NameColumn;
+    BOOLEAN                 IsNullString = FALSE;
+
+
+    if (!LineBuffer)
+    {
+        return (AE_OK);
+    }
+
+    /* All lines after "Raw Table Data" are ingored */
+
+    if (strstr (LineBuffer, ACPI_RAW_TABLE_DATA_HEADER))
+    {
+        return (AE_NOT_FOUND);
+    }
+
+    Colon = strchr (LineBuffer, ':');
+    if (!Colon)
+    {
+        return (AE_OK);
+    }
+
+    Start = LineBuffer;
+    End = Colon;
+
+    while (Start < Colon)
+    {
+        if (*Start == '[')
+        {
+            /* Found left bracket, go to the right bracket */
+
+            while (Start < Colon && *Start != ']')
+            {
+                Start++;
+            }
+        }
+        else if (*Start != ' ')
+        {
+            break;
+        }
+
+        Start++;
+    }
+
+    /*
+     * There are two column values. One for the field name,
+     * and one for the field value.
+     */
+    Column = ACPI_PTR_DIFF (Colon, LineBuffer) + 3;
+    NameColumn = ACPI_PTR_DIFF (Start, LineBuffer) + 1;
+
+    Length = ACPI_PTR_DIFF (End, Start);
+
+    TmpName = UtLocalCalloc (Length + 1);
+    strncpy (TmpName, Start, Length);
+    Name = DtTrim (TmpName);
+    ACPI_FREE (TmpName);
+
+    Start = End = (Colon + 1);
+    while (*End)
+    {
+        /* Found left quotation, go to the right quotation and break */
+
+        if (*End == '"')
+        {
+            End++;
+
+            /* Check for an explicit null string */
+
+            if (*End == '"')
+            {
+                IsNullString = TRUE;
+            }
+            while (*End && (*End != '"'))
+            {
+                End++;
+            }
+
+            End++;
+            break;
+        }
+
+        /*
+         * Special "comment" fields at line end, ignore them.
+         * Note: normal slash-slash and slash-asterisk comments are
+         * stripped already by the DtGetNextLine parser.
+         *
+         * TBD: Perhaps DtGetNextLine should parse the following type
+         * of comments also.
+         */
+        if (*End == '[')
+        {
+            End--;
+            break;
+        }
+
+        End++;
+    }
+
+    Length = ACPI_PTR_DIFF (End, Start);
+    TmpValue = UtLocalCalloc (Length + 1);
+
+    strncpy (TmpValue, Start, Length);
+    Value = DtTrim (TmpValue);
+    ACPI_FREE (TmpValue);
+
+    /* Create a new field object only if we have a valid value field */
+
+    if ((Value && *Value) || IsNullString)
+    {
+        Field = UtFieldCacheCalloc ();
+        Field->Name = Name;
+        Field->Value = Value;
+        Field->Line = Line;
+        Field->ByteOffset = Offset;
+        Field->NameColumn = NameColumn;
+        Field->Column = Column;
+        Field->StringLength = Length;
+
+        DtLinkField (Field);
+    }
+    /* Else -- Ignore this field, it has no valid data */
+
+    return (AE_OK);
+}
+
+
+/******************************************************************************
+ *
+ * FUNCTION:    DtGetNextLine
+ *
+ * PARAMETERS:  Handle              - Open file handle for the source file
+ *
+ * RETURN:      Filled line buffer and offset of start-of-line (ASL_EOF on EOF)
+ *
+ * DESCRIPTION: Get the next valid source line. Removes all comments.
+ *              Ignores empty lines.
+ *
+ * Handles both slash-asterisk and slash-slash comments.
+ * Also, quoted strings, but no escapes within.
+ *
+ * Line is returned in Gbl_CurrentLineBuffer.
+ * Line number in original file is returned in Gbl_CurrentLineNumber.
+ *
+ *****************************************************************************/
+
+UINT32
+DtGetNextLine (
+    FILE                    *Handle,
+    UINT32                  Flags)
+{
+    BOOLEAN                 LineNotAllBlanks = FALSE;
+    UINT32                  State = DT_NORMAL_TEXT;
+    UINT32                  CurrentLineOffset;
+    UINT32                  i;
+    int                     c;
+
+
+    memset (Gbl_CurrentLineBuffer, 0, Gbl_LineBufferSize);
+    for (i = 0; ;)
+    {
+        /*
+         * If line is too long, expand the line buffers. Also increases
+         * Gbl_LineBufferSize.
+         */
+        if (i >= Gbl_LineBufferSize)
+        {
+            UtExpandLineBuffers ();
+        }
+
+        c = getc (Handle);
+        if (c == EOF)
+        {
+            switch (State)
+            {
+            case DT_START_QUOTED_STRING:
+            case DT_SLASH_ASTERISK_COMMENT:
+
+                AcpiOsPrintf ("**** EOF within comment/string %u\n", State);
+                break;
+
+            default:
+
+                break;
+            }
+
+            /* Standalone EOF is OK */
+
+            if (i == 0)
+            {
+                return (ASL_EOF);
+            }
+
+            /*
+             * Received an EOF in the middle of a line. Terminate the
+             * line with a newline. The next call to this function will
+             * return a standalone EOF. Thus, the upper parsing software
+             * never has to deal with an EOF within a valid line (or
+             * the last line does not get tossed on the floor.)
+             */
+            c = '\n';
+            State = DT_NORMAL_TEXT;
+        }
+
+        switch (State)
+        {
+        case DT_NORMAL_TEXT:
+
+            /* Normal text, insert char into line buffer */
+
+            Gbl_CurrentLineBuffer[i] = (char) c;
+            switch (c)
+            {
+            case '/':
+
+                State = DT_START_COMMENT;
+                break;
+
+            case '"':
+
+                State = DT_START_QUOTED_STRING;
+                LineNotAllBlanks = TRUE;
+                i++;
+                break;
+
+            case '\\':
+                /*
+                 * The continuation char MUST be last char on this line.
+                 * Otherwise, it will be assumed to be a valid ASL char.
+                 */
+                State = DT_MERGE_LINES;
+                break;
+
+            case '\n':
+
+                CurrentLineOffset = Gbl_NextLineOffset;
+                Gbl_NextLineOffset = (UINT32) ftell (Handle);
+                Gbl_CurrentLineNumber++;
+
+                /*
+                 * Exit if line is complete. Ignore empty lines (only \n)
+                 * or lines that contain nothing but blanks.
+                 */
+                if ((i != 0) && LineNotAllBlanks)
+                {
+                    if ((i + 1) >= Gbl_LineBufferSize)
+                    {
+                        UtExpandLineBuffers ();
+                    }
+
+                    Gbl_CurrentLineBuffer[i+1] = 0; /* Terminate string */
+                    return (CurrentLineOffset);
+                }
+
+                /* Toss this line and start a new one */
+
+                i = 0;
+                LineNotAllBlanks = FALSE;
+                break;
+
+            default:
+
+                if (c != ' ')
+                {
+                    LineNotAllBlanks = TRUE;
+                }
+
+                i++;
+                break;
+            }
+            break;
+
+        case DT_START_QUOTED_STRING:
+
+            /* Insert raw chars until end of quoted string */
+
+            Gbl_CurrentLineBuffer[i] = (char) c;
+            i++;
+
+            switch (c)
+            {
+            case '"':
+
+                State = DT_NORMAL_TEXT;
+                break;
+
+            case '\\':
+
+                State = DT_ESCAPE_SEQUENCE;
+                break;
+
+            case '\n':
+
+                if (!(Flags & DT_ALLOW_MULTILINE_QUOTES))
+                {
+                    AcpiOsPrintf (
+                        "ERROR at line %u: Unterminated quoted string\n",
+                        Gbl_CurrentLineNumber++);
+                    State = DT_NORMAL_TEXT;
+                }
+                break;
+
+            default:    /* Get next character */
+
+                break;
+            }
+            break;
+
+        case DT_ESCAPE_SEQUENCE:
+
+            /* Just copy the escaped character. TBD: sufficient for table compiler? */
+
+            Gbl_CurrentLineBuffer[i] = (char) c;
+            i++;
+            State = DT_START_QUOTED_STRING;
+            break;
+
+        case DT_START_COMMENT:
+
+            /* Open comment if this character is an asterisk or slash */
+
+            switch (c)
+            {
+            case '*':
+
+                State = DT_SLASH_ASTERISK_COMMENT;
+                break;
+
+            case '/':
+
+                State = DT_SLASH_SLASH_COMMENT;
+                break;
+
+            default:    /* Not a comment */
+
+                i++;    /* Save the preceding slash */
+                if (i >= Gbl_LineBufferSize)
+                {
+                    UtExpandLineBuffers ();
+                }
+
+                Gbl_CurrentLineBuffer[i] = (char) c;
+                i++;
+                State = DT_NORMAL_TEXT;
+                break;
+            }
+            break;
+
+        case DT_SLASH_ASTERISK_COMMENT:
+
+            /* Ignore chars until an asterisk-slash is found */
+
+            switch (c)
+            {
+            case '\n':
+
+                Gbl_NextLineOffset = (UINT32) ftell (Handle);
+                Gbl_CurrentLineNumber++;
+                break;
+
+            case '*':
+
+                State = DT_END_COMMENT;
+                break;
+
+            default:
+
+                break;
+            }
+            break;
+
+        case DT_SLASH_SLASH_COMMENT:
+
+            /* Ignore chars until end-of-line */
+
+            if (c == '\n')
+            {
+                /* We will exit via the NORMAL_TEXT path */
+
+                ungetc (c, Handle);
+                State = DT_NORMAL_TEXT;
+            }
+            break;
+
+        case DT_END_COMMENT:
+
+            /* End comment if this char is a slash */
+
+            switch (c)
+            {
+            case '/':
+
+                State = DT_NORMAL_TEXT;
+                break;
+
+            case '\n':
+
+                CurrentLineOffset = Gbl_NextLineOffset;
+                Gbl_NextLineOffset = (UINT32) ftell (Handle);
+                Gbl_CurrentLineNumber++;
+                break;
+
+            case '*':
+
+                /* Consume all adjacent asterisks */
+                break;
+
+            default:
+
+                State = DT_SLASH_ASTERISK_COMMENT;
+                break;
+            }
+            break;
+
+        case DT_MERGE_LINES:
+
+            if (c != '\n')
+            {
+                /*
+                 * This is not a continuation backslash, it is a normal
+                 * normal ASL backslash - for example: Scope(\_SB_)
+                 */
+                i++; /* Keep the backslash that is already in the buffer */
+
+                ungetc (c, Handle);
+                State = DT_NORMAL_TEXT;
+            }
+            else
+            {
+                /*
+                 * This is a continuation line -- a backlash followed
+                 * immediately by a newline. Insert a space between the
+                 * lines (overwrite the backslash)
+                 */
+                Gbl_CurrentLineBuffer[i] = ' ';
+                i++;
+
+                /* Ignore newline, this will merge the lines */
+
+                CurrentLineOffset = Gbl_NextLineOffset;
+                Gbl_NextLineOffset = (UINT32) ftell (Handle);
+                Gbl_CurrentLineNumber++;
+                State = DT_NORMAL_TEXT;
+            }
+            break;
+
+        default:
+
+            DtFatal (ASL_MSG_COMPILER_INTERNAL, NULL, "Unknown input state");
+            return (ASL_EOF);
+        }
+    }
+}
+
+
+/******************************************************************************
+ *
+ * FUNCTION:    DtScanFile
+ *
+ * PARAMETERS:  Handle              - Open file handle for the source file
+ *
+ * RETURN:      Pointer to start of the constructed parse tree.
+ *
+ * DESCRIPTION: Scan source file, link all field names and values
+ *              to the global parse tree: Gbl_FieldList
+ *
+ *****************************************************************************/
+
+DT_FIELD *
+DtScanFile (
+    FILE                    *Handle)
+{
+    ACPI_STATUS             Status;
+    UINT32                  Offset;
+
+
+    ACPI_FUNCTION_NAME (DtScanFile);
+
+
+    /* Get the file size */
+
+    Gbl_InputByteCount = CmGetFileSize (Handle);
+    if (Gbl_InputByteCount == ACPI_UINT32_MAX)
+    {
+        AslAbort ();
+    }
+
+    Gbl_CurrentLineNumber = 0;
+    Gbl_CurrentLineOffset = 0;
+    Gbl_NextLineOffset = 0;
+
+    /* Scan line-by-line */
+
+    while ((Offset = DtGetNextLine (Handle, 0)) != ASL_EOF)
+    {
+        ACPI_DEBUG_PRINT ((ACPI_DB_PARSE, "Line %2.2u/%4.4X - %s",
+            Gbl_CurrentLineNumber, Offset, Gbl_CurrentLineBuffer));
+
+        Status = DtParseLine (Gbl_CurrentLineBuffer,
+            Gbl_CurrentLineNumber, Offset);
+        if (Status == AE_NOT_FOUND)
+        {
+            break;
+        }
+    }
+
+    /* Dump the parse tree if debug enabled */
+
+    DtDumpFieldList (Gbl_FieldList);
+    return (Gbl_FieldList);
+}
+
+
+/*
+ * Output functions
+ */
+
+/******************************************************************************
+ *
+ * FUNCTION:    DtWriteBinary
+ *
+ * PARAMETERS:  DT_WALK_CALLBACK
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Write one subtable of a binary ACPI table
+ *
+ *****************************************************************************/
+
+static void
+DtWriteBinary (
+    DT_SUBTABLE             *Subtable,
+    void                    *Context,
+    void                    *ReturnValue)
+{
+
+    FlWriteFile (ASL_FILE_AML_OUTPUT, Subtable->Buffer, Subtable->Length);
+}
+
+
+/******************************************************************************
+ *
+ * FUNCTION:    DtOutputBinary
+ *
+ * PARAMETERS:
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Write entire binary ACPI table (result of compilation)
+ *
+ *****************************************************************************/
+
+void
+DtOutputBinary (
+    DT_SUBTABLE             *RootTable)
+{
+
+    if (!RootTable)
+    {
+        return;
+    }
+
+    /* Walk the entire parse tree, emitting the binary data */
+
+    DtWalkTableTree (RootTable, DtWriteBinary, NULL, NULL);
+
+    Gbl_TableLength = CmGetFileSize (Gbl_Files[ASL_FILE_AML_OUTPUT].Handle);
+    if (Gbl_TableLength == ACPI_UINT32_MAX)
+    {
+        AslAbort ();
+    }
+}
+
+
+/*
+ * Listing support
+ */
+
+/******************************************************************************
+ *
+ * FUNCTION:    DtDumpBuffer
+ *
+ * PARAMETERS:  FileID              - Where to write buffer data
+ *              Buffer              - Buffer to dump
+ *              Offset              - Offset in current table
+ *              Length              - Buffer Length
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Another copy of DumpBuffer routine (unfortunately).
+ *
+ * TBD: merge dump buffer routines
+ *
+ *****************************************************************************/
+
+static void
+DtDumpBuffer (
+    UINT32                  FileId,
+    UINT8                   *Buffer,
+    UINT32                  Offset,
+    UINT32                  Length)
+{
+    UINT32                  i;
+    UINT32                  j;
+    UINT8                   BufChar;
+
+
+    FlPrintFile (FileId, "Output: [%3.3Xh %4.4d %3d] ",
+        Offset, Offset, Length);
+
+    i = 0;
+    while (i < Length)
+    {
+        if (i >= 16)
+        {
+            FlPrintFile (FileId, "%24s", "");
+        }
+
+        /* Print 16 hex chars */
+
+        for (j = 0; j < 16;)
+        {
+            if (i + j >= Length)
+            {
+                /* Dump fill spaces */
+
+                FlPrintFile (FileId, "   ");
+                j++;
+                continue;
+            }
+
+            FlPrintFile (FileId, "%02X ", Buffer[i+j]);
+            j++;
+        }
+
+        FlPrintFile (FileId, " ");
+        for (j = 0; j < 16; j++)
+        {
+            if (i + j >= Length)
+            {
+                FlPrintFile (FileId, "\n\n");
+                return;
+            }
+
+            BufChar = Buffer[(ACPI_SIZE) i + j];
+            if (isprint (BufChar))
+            {
+                FlPrintFile (FileId, "%c", BufChar);
+            }
+            else
+            {
+                FlPrintFile (FileId, ".");
+            }
+        }
+
+        /* Done with that line. */
+
+        FlPrintFile (FileId, "\n");
+        i += 16;
+    }
+
+    FlPrintFile (FileId, "\n\n");
+}
+
+
+/******************************************************************************
+ *
+ * FUNCTION:    DtDumpFieldList
+ *
+ * PARAMETERS:  Field               - Root field
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Dump the entire field list
+ *
+ *****************************************************************************/
+
+void
+DtDumpFieldList (
+    DT_FIELD                *Field)
+{
+
+    if (!Gbl_DebugFlag || !Field)
+    {
+        return;
+    }
+
+    DbgPrint (ASL_DEBUG_OUTPUT,  "\nField List:\n"
+        "LineNo   ByteOff  NameCol  Column   TableOff "
+        "Flags %32s : %s\n\n", "Name", "Value");
+
+    while (Field)
+    {
+        DbgPrint (ASL_DEBUG_OUTPUT,
+            "%.08X %.08X %.08X %.08X %.08X %2.2X    %32s : %s\n",
+            Field->Line, Field->ByteOffset, Field->NameColumn,
+            Field->Column, Field->TableOffset, Field->Flags,
+            Field->Name, Field->Value);
+
+        Field = Field->Next;
+    }
+
+    DbgPrint (ASL_DEBUG_OUTPUT,  "\n\n");
+}
+
+
+/******************************************************************************
+ *
+ * FUNCTION:    DtDumpSubtableInfo, DtDumpSubtableTree
+ *
+ * PARAMETERS:  DT_WALK_CALLBACK
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Info - dump a subtable tree entry with extra information.
+ *              Tree - dump a subtable tree formatted by depth indentation.
+ *
+ *****************************************************************************/
+
+static void
+DtDumpSubtableInfo (
+    DT_SUBTABLE             *Subtable,
+    void                    *Context,
+    void                    *ReturnValue)
+{
+
+    DbgPrint (ASL_DEBUG_OUTPUT,
+        "[%.04X] %24s %.08X %.08X %.08X %.08X %.08X %p %p %p\n",
+        Subtable->Depth, Subtable->Name, Subtable->Length, Subtable->TotalLength,
+        Subtable->SizeOfLengthField, Subtable->Flags, Subtable,
+        Subtable->Parent, Subtable->Child, Subtable->Peer);
+}
+
+static void
+DtDumpSubtableTree (
+    DT_SUBTABLE             *Subtable,
+    void                    *Context,
+    void                    *ReturnValue)
+{
+
+    DbgPrint (ASL_DEBUG_OUTPUT,
+        "[%.04X] %24s %*s%08X (%.02X) - (%.02X)\n",
+        Subtable->Depth, Subtable->Name, (4 * Subtable->Depth), " ",
+        Subtable, Subtable->Length, Subtable->TotalLength);
+}
+
+
+/******************************************************************************
+ *
+ * FUNCTION:    DtDumpSubtableList
+ *
+ * PARAMETERS:  None
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Dump the raw list of subtables with information, and also
+ *              dump the subtable list in formatted tree format. Assists with
+ *              the development of new table code.
+ *
+ *****************************************************************************/
+
+void
+DtDumpSubtableList (
+    void)
+{
+
+    if (!Gbl_DebugFlag || !Gbl_RootTable)
+    {
+        return;
+    }
+
+    DbgPrint (ASL_DEBUG_OUTPUT,
+        "Subtable Info:\n"
+        "Depth                      Name Length   TotalLen LenSize  Flags    "
+        "This     Parent   Child    Peer\n\n");
+    DtWalkTableTree (Gbl_RootTable, DtDumpSubtableInfo, NULL, NULL);
+
+    DbgPrint (ASL_DEBUG_OUTPUT,
+        "\nSubtable Tree: (Depth, Name, Subtable, Length, TotalLength)\n\n");
+    DtWalkTableTree (Gbl_RootTable, DtDumpSubtableTree, NULL, NULL);
+
+    DbgPrint (ASL_DEBUG_OUTPUT, "\n");
+}
+
+
+/******************************************************************************
+ *
+ * FUNCTION:    DtWriteFieldToListing
+ *
+ * PARAMETERS:  Buffer              - Contains the compiled data
+ *              Field               - Field node for the input line
+ *              Length              - Length of the output data
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Write one field to the listing file (if listing is enabled).
+ *
+ *****************************************************************************/
+
+void
+DtWriteFieldToListing (
+    UINT8                   *Buffer,
+    DT_FIELD                *Field,
+    UINT32                  Length)
+{
+    UINT8                   FileByte;
+
+
+    if (!Gbl_ListingFlag || !Field)
+    {
+        return;
+    }
+
+    /* Dump the original source line */
+
+    FlPrintFile (ASL_FILE_LISTING_OUTPUT, "Input:  ");
+    FlSeekFile (ASL_FILE_INPUT, Field->ByteOffset);
+
+    while (FlReadFile (ASL_FILE_INPUT, &FileByte, 1) == AE_OK)
+    {
+        FlWriteFile (ASL_FILE_LISTING_OUTPUT, &FileByte, 1);
+        if (FileByte == '\n')
+        {
+            break;
+        }
+    }
+
+    /* Dump the line as parsed and represented internally */
+
+    FlPrintFile (ASL_FILE_LISTING_OUTPUT, "Parsed: %*s : %.64s",
+        Field->Column-4, Field->Name, Field->Value);
+
+    if (strlen (Field->Value) > 64)
+    {
+        FlPrintFile (ASL_FILE_LISTING_OUTPUT, "...Additional data, length 0x%X\n",
+            strlen (Field->Value));
+    }
+
+    FlPrintFile (ASL_FILE_LISTING_OUTPUT, "\n");
+
+    /* Dump the hex data that will be output for this field */
+
+    DtDumpBuffer (ASL_FILE_LISTING_OUTPUT, Buffer, Field->TableOffset, Length);
+}
+
+
+/******************************************************************************
+ *
+ * FUNCTION:    DtWriteTableToListing
+ *
+ * PARAMETERS:  None
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Write the entire compiled table to the listing file
+ *              in hex format
+ *
+ *****************************************************************************/
+
+void
+DtWriteTableToListing (
+    void)
+{
+    UINT8                   *Buffer;
+
+
+    if (!Gbl_ListingFlag)
+    {
+        return;
+    }
+
+    /* Read the entire table from the output file */
+
+    Buffer = UtLocalCalloc (Gbl_TableLength);
+    FlSeekFile (ASL_FILE_AML_OUTPUT, 0);
+    FlReadFile (ASL_FILE_AML_OUTPUT, Buffer, Gbl_TableLength);
+
+    /* Dump the raw table data */
+
+    AcpiOsRedirectOutput (Gbl_Files[ASL_FILE_LISTING_OUTPUT].Handle);
+
+    AcpiOsPrintf ("\n%s: Length %d (0x%X)\n\n",
+        ACPI_RAW_TABLE_DATA_HEADER, Gbl_TableLength, Gbl_TableLength);
+    AcpiUtDumpBuffer (Buffer, Gbl_TableLength, DB_BYTE_DISPLAY, 0);
+
+    AcpiOsRedirectOutput (stdout);
+    ACPI_FREE (Buffer);
+}
diff --git a/usr/src/cmd/acpi/iasl/dtparser.l b/usr/src/cmd/acpi/iasl/dtparser.l
new file mode 100644
index 0000000000..f3a307a2dd
--- /dev/null
+++ b/usr/src/cmd/acpi/iasl/dtparser.l
@@ -0,0 +1,133 @@
+%{
+/******************************************************************************
+ *
+ * Module Name: dtparser.l - Flex input file for table compiler lexer
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2016, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include "aslcompiler.h"
+#include "dtparser.y.h"
+
+#define YY_NO_INPUT     /* No file input, we use strings only */
+
+#define _COMPONENT          ACPI_COMPILER
+        ACPI_MODULE_NAME    ("dtscanner")
+%}
+
+%option noyywrap
+%option nounput
+
+Number          [0-9a-fA-F]+
+HexNumber       0[xX][0-9a-fA-F]+
+DecimalNumber   0[dD][0-9]+
+LabelRef        $[a-zA-Z][0-9a-zA-Z]*
+WhiteSpace      [ \t\v\r]+
+NewLine         [\n]
+
+%%
+
+\(              return (EXPOP_PAREN_OPEN);
+\)              return (EXPOP_PAREN_CLOSE);
+\~              return (EXPOP_ONES_COMPLIMENT);
+\!              return (EXPOP_LOGICAL_NOT);
+\*              return (EXPOP_MULTIPLY);
+\/              return (EXPOP_DIVIDE);
+\%              return (EXPOP_MODULO);
+\+              return (EXPOP_ADD);
+\-              return (EXPOP_SUBTRACT);
+">>"            return (EXPOP_SHIFT_RIGHT);
+"<<"            return (EXPOP_SHIFT_LEFT);
+\<              return (EXPOP_LESS);
+\>              return (EXPOP_GREATER);
+"<="            return (EXPOP_LESS_EQUAL);
+">="            return (EXPOP_GREATER_EQUAL);
+"=="            return (EXPOP_EQUAL);
+"!="            return (EXPOP_NOT_EQUAL);
+\&              return (EXPOP_AND);
+\^              return (EXPOP_XOR);
+\|              return (EXPOP_OR);
+"&&"            return (EXPOP_LOGICAL_AND);
+"||"            return (EXPOP_LOGICAL_OR);
+<<EOF>>         return (EXPOP_EOF); /* null end-of-string */
+
+{LabelRef}      return (EXPOP_LABEL);
+{Number}        return (EXPOP_NUMBER);
+{HexNumber}     return (EXPOP_HEX_NUMBER);
+{NewLine}       return (EXPOP_NEW_LINE);
+{WhiteSpace}    /* Ignore */
+
+.               return (EXPOP_EOF);
+
+%%
+
+/*
+ * Local support functions
+ */
+YY_BUFFER_STATE         LexBuffer;
+
+/******************************************************************************
+ *
+ * FUNCTION:    DtInitLexer, DtTerminateLexer
+ *
+ * PARAMETERS:  String              - Input string to be parsed
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Initialization and termination routines for lexer. Lexer needs
+ *              a buffer to handle strings instead of a file.
+ *
+ *****************************************************************************/
+
+int
+DtInitLexer (
+    char                    *String)
+{
+
+    LexBuffer = yy_scan_string (String);
+    return (LexBuffer == NULL);
+}
+
+void
+DtTerminateLexer (
+    void)
+{
+
+    yy_delete_buffer (LexBuffer);
+}
diff --git a/usr/src/cmd/acpi/iasl/dtparser.y b/usr/src/cmd/acpi/iasl/dtparser.y
new file mode 100644
index 0000000000..233aa9614b
--- /dev/null
+++ b/usr/src/cmd/acpi/iasl/dtparser.y
@@ -0,0 +1,284 @@
+%{
+/******************************************************************************
+ *
+ * Module Name: dtparser.y - Bison input file for table compiler parser
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2016, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include "aslcompiler.h"
+#include "dtcompiler.h"
+
+#define _COMPONENT          DT_COMPILER
+        ACPI_MODULE_NAME    ("dtparser")
+
+void *                      AslLocalAllocate (unsigned int Size);
+
+/* Bison/yacc configuration */
+
+#undef alloca
+#define alloca              AslLocalAllocate
+
+int                         DtParserlex (void);
+int                         DtParserparse (void);
+void                        DtParsererror (char const *msg);
+extern char                 *DtParsertext;
+extern DT_FIELD             *Gbl_CurrentField;
+
+UINT64                      DtParserResult; /* Expression return value */
+
+/* Bison/yacc configuration */
+
+#define yytname             DtParsername
+#define YYDEBUG             1               /* Enable debug output */
+#define YYERROR_VERBOSE     1               /* Verbose error messages */
+#define YYFLAG              -32768
+
+/* Define YYMALLOC/YYFREE to prevent redefinition errors  */
+
+#define YYMALLOC            malloc
+#define YYFREE              free
+%}
+
+%union
+{
+     UINT64                 value;
+     UINT32                 op;
+}
+
+/*! [Begin] no source code translation */
+
+%type  <value>  Expression
+
+%token <op>     EXPOP_EOF
+%token <op>     EXPOP_NEW_LINE
+%token <op>     EXPOP_NUMBER
+%token <op>     EXPOP_HEX_NUMBER
+%token <op>     EXPOP_DECIMAL_NUMBER
+%token <op>     EXPOP_LABEL
+%token <op>     EXPOP_PAREN_OPEN
+%token <op>     EXPOP_PAREN_CLOSE
+
+%left <op>      EXPOP_LOGICAL_OR
+%left <op>      EXPOP_LOGICAL_AND
+%left <op>      EXPOP_OR
+%left <op>      EXPOP_XOR
+%left <op>      EXPOP_AND
+%left <op>      EXPOP_EQUAL EXPOP_NOT_EQUAL
+%left <op>      EXPOP_GREATER EXPOP_LESS EXPOP_GREATER_EQUAL EXPOP_LESS_EQUAL
+%left <op>      EXPOP_SHIFT_RIGHT EXPOP_SHIFT_LEFT
+%left <op>      EXPOP_ADD EXPOP_SUBTRACT
+%left <op>      EXPOP_MULTIPLY EXPOP_DIVIDE EXPOP_MODULO
+%right <op>     EXPOP_ONES_COMPLIMENT EXPOP_LOGICAL_NOT
+
+%%
+
+/*
+ *  Operator precedence rules (from K&R)
+ *
+ *  1)      ( )
+ *  2)      ! ~ (unary operators that are supported here)
+ *  3)      *   /   %
+ *  4)      +   -
+ *  5)      >>  <<
+ *  6)      <   >   <=  >=
+ *  7)      ==  !=
+ *  8)      &
+ *  9)      ^
+ *  10)     |
+ *  11)     &&
+ *  12)     ||
+ */
+Value
+    : Expression EXPOP_NEW_LINE                     { DtParserResult=$1; return 0; } /* End of line (newline) */
+    | Expression EXPOP_EOF                          { DtParserResult=$1; return 0; } /* End of string (0) */
+    ;
+
+Expression
+
+      /* Unary operators */
+
+    : EXPOP_LOGICAL_NOT         Expression          { $$ = DtDoOperator ($2, EXPOP_LOGICAL_NOT,     $2);}
+    | EXPOP_ONES_COMPLIMENT     Expression          { $$ = DtDoOperator ($2, EXPOP_ONES_COMPLIMENT, $2);}
+
+      /* Binary operators */
+
+    | Expression EXPOP_MULTIPLY         Expression  { $$ = DtDoOperator ($1, EXPOP_MULTIPLY,        $3);}
+    | Expression EXPOP_DIVIDE           Expression  { $$ = DtDoOperator ($1, EXPOP_DIVIDE,          $3);}
+    | Expression EXPOP_MODULO           Expression  { $$ = DtDoOperator ($1, EXPOP_MODULO,          $3);}
+    | Expression EXPOP_ADD              Expression  { $$ = DtDoOperator ($1, EXPOP_ADD,             $3);}
+    | Expression EXPOP_SUBTRACT         Expression  { $$ = DtDoOperator ($1, EXPOP_SUBTRACT,        $3);}
+    | Expression EXPOP_SHIFT_RIGHT      Expression  { $$ = DtDoOperator ($1, EXPOP_SHIFT_RIGHT,     $3);}
+    | Expression EXPOP_SHIFT_LEFT       Expression  { $$ = DtDoOperator ($1, EXPOP_SHIFT_LEFT,      $3);}
+    | Expression EXPOP_GREATER          Expression  { $$ = DtDoOperator ($1, EXPOP_GREATER,         $3);}
+    | Expression EXPOP_LESS             Expression  { $$ = DtDoOperator ($1, EXPOP_LESS,            $3);}
+    | Expression EXPOP_GREATER_EQUAL    Expression  { $$ = DtDoOperator ($1, EXPOP_GREATER_EQUAL,   $3);}
+    | Expression EXPOP_LESS_EQUAL       Expression  { $$ = DtDoOperator ($1, EXPOP_LESS_EQUAL,      $3);}
+    | Expression EXPOP_EQUAL            Expression  { $$ = DtDoOperator ($1, EXPOP_EQUAL,           $3);}
+    | Expression EXPOP_NOT_EQUAL        Expression  { $$ = DtDoOperator ($1, EXPOP_NOT_EQUAL,       $3);}
+    | Expression EXPOP_AND              Expression  { $$ = DtDoOperator ($1, EXPOP_AND,             $3);}
+    | Expression EXPOP_XOR              Expression  { $$ = DtDoOperator ($1, EXPOP_XOR,             $3);}
+    | Expression EXPOP_OR               Expression  { $$ = DtDoOperator ($1, EXPOP_OR,              $3);}
+    | Expression EXPOP_LOGICAL_AND      Expression  { $$ = DtDoOperator ($1, EXPOP_LOGICAL_AND,     $3);}
+    | Expression EXPOP_LOGICAL_OR       Expression  { $$ = DtDoOperator ($1, EXPOP_LOGICAL_OR,      $3);}
+
+      /* Parentheses: '(' Expression ')' */
+
+    | EXPOP_PAREN_OPEN          Expression
+        EXPOP_PAREN_CLOSE                           { $$ = $2;}
+
+      /* Label references (prefixed with $) */
+
+    | EXPOP_LABEL                                   { $$ = DtResolveLabel (DtParsertext);}
+
+      /* Default base for a non-prefixed integer is 16 */
+
+    | EXPOP_NUMBER                                  { AcpiUtStrtoul64 (DtParsertext, 16, ACPI_MAX64_BYTE_WIDTH, &$$);}
+
+      /* Standard hex number (0x1234) */
+
+    | EXPOP_HEX_NUMBER                              { AcpiUtStrtoul64 (DtParsertext, 16, ACPI_MAX64_BYTE_WIDTH, &$$);}
+
+      /* TBD: Decimal number with prefix (0d1234) - Not supported by strtoul64 at this time */
+
+    | EXPOP_DECIMAL_NUMBER                          { AcpiUtStrtoul64 (DtParsertext, 10, ACPI_MAX64_BYTE_WIDTH, &$$);}
+    ;
+%%
+
+/*! [End] no source code translation !*/
+
+/*
+ * Local support functions, including parser entry point
+ */
+#define PR_FIRST_PARSE_OPCODE   EXPOP_EOF
+#define PR_YYTNAME_START        3
+
+
+/******************************************************************************
+ *
+ * FUNCTION:    DtParsererror
+ *
+ * PARAMETERS:  Message             - Parser-generated error message
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Handler for parser errors
+ *
+ *****************************************************************************/
+
+void
+DtParsererror (
+    char const              *Message)
+{
+    DtError (ASL_ERROR, ASL_MSG_SYNTAX,
+        Gbl_CurrentField, (char *) Message);
+}
+
+
+/******************************************************************************
+ *
+ * FUNCTION:    DtGetOpName
+ *
+ * PARAMETERS:  ParseOpcode         - Parser token (EXPOP_*)
+ *
+ * RETURN:      Pointer to the opcode name
+ *
+ * DESCRIPTION: Get the ascii name of the parse opcode for debug output
+ *
+ *****************************************************************************/
+
+char *
+DtGetOpName (
+    UINT32                  ParseOpcode)
+{
+#ifdef ASL_YYTNAME_START
+    /*
+     * First entries (PR_YYTNAME_START) in yytname are special reserved names.
+     * Ignore first 6 characters of name (EXPOP_)
+     */
+    return ((char *) yytname
+        [(ParseOpcode - PR_FIRST_PARSE_OPCODE) + PR_YYTNAME_START] + 6);
+#else
+    return ("[Unknown parser generator]");
+#endif
+}
+
+
+/******************************************************************************
+ *
+ * FUNCTION:    DtEvaluateExpression
+ *
+ * PARAMETERS:  ExprString          - Expression to be evaluated. Must be
+ *                                    terminated by either a newline or a NUL
+ *                                    string terminator
+ *
+ * RETURN:      64-bit value for the expression
+ *
+ * DESCRIPTION: Main entry point for the DT expression parser
+ *
+ *****************************************************************************/
+
+UINT64
+DtEvaluateExpression (
+    char                    *ExprString)
+{
+
+    DbgPrint (ASL_DEBUG_OUTPUT,
+        "**** Input expression: %s  (Base 16)\n", ExprString);
+
+    /* Point lexer to the input string */
+
+    if (DtInitLexer (ExprString))
+    {
+        DtError (ASL_ERROR, ASL_MSG_COMPILER_INTERNAL,
+            Gbl_CurrentField, "Could not initialize lexer");
+        return (0);
+    }
+
+    /* Parse/Evaluate the input string (value returned in DtParserResult) */
+
+    DtParserparse ();
+    DtTerminateLexer ();
+
+    DbgPrint (ASL_DEBUG_OUTPUT,
+        "**** Parser returned value: %u (%8.8X%8.8X)\n",
+        (UINT32) DtParserResult, ACPI_FORMAT_UINT64 (DtParserResult));
+
+    return (DtParserResult);
+}
diff --git a/usr/src/cmd/acpi/iasl/dtsubtable.c b/usr/src/cmd/acpi/iasl/dtsubtable.c
new file mode 100644
index 0000000000..f63082a368
--- /dev/null
+++ b/usr/src/cmd/acpi/iasl/dtsubtable.c
@@ -0,0 +1,384 @@
+/******************************************************************************
+ *
+ * Module Name: dtsubtable.c - handling of subtables within ACPI tables
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2016, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include "aslcompiler.h"
+#include "dtcompiler.h"
+
+#define _COMPONENT          DT_COMPILER
+        ACPI_MODULE_NAME    ("dtsubtable")
+
+
+/******************************************************************************
+ *
+ * FUNCTION:    DtCreateSubtable
+ *
+ * PARAMETERS:  Buffer              - Input buffer
+ *              Length              - Buffer length
+ *              RetSubtable         - Returned newly created subtable
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Create a subtable that is not listed with ACPI_DMTABLE_INFO
+ *              For example, FACS has 24 bytes reserved at the end
+ *              and it's not listed at AcpiDmTableInfoFacs
+ *
+ *****************************************************************************/
+
+void
+DtCreateSubtable (
+    UINT8                   *Buffer,
+    UINT32                  Length,
+    DT_SUBTABLE             **RetSubtable)
+{
+    DT_SUBTABLE             *Subtable;
+    char                    *String;
+
+
+    Subtable = UtSubtableCacheCalloc ();
+
+    /* Create a new buffer for the subtable data */
+
+    String = UtStringCacheCalloc (Length);
+    Subtable->Buffer = ACPI_CAST_PTR (UINT8, String);
+    memcpy (Subtable->Buffer, Buffer, Length);
+
+    Subtable->Length = Length;
+    Subtable->TotalLength = Length;
+
+    *RetSubtable = Subtable;
+}
+
+
+/******************************************************************************
+ *
+ * FUNCTION:    DtInsertSubtable
+ *
+ * PARAMETERS:  ParentTable         - The Parent of the new subtable
+ *              Subtable            - The new subtable to insert
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Insert the new subtable to the parent table
+ *
+ *****************************************************************************/
+
+void
+DtInsertSubtable (
+    DT_SUBTABLE             *ParentTable,
+    DT_SUBTABLE             *Subtable)
+{
+    DT_SUBTABLE             *ChildTable;
+
+
+    Subtable->Peer = NULL;
+    Subtable->Parent = ParentTable;
+    Subtable->Depth = ParentTable->Depth + 1;
+
+    /* Link the new entry into the child list */
+
+    if (!ParentTable->Child)
+    {
+        ParentTable->Child = Subtable;
+    }
+    else
+    {
+        /* Walk to the end of the child list */
+
+        ChildTable = ParentTable->Child;
+        while (ChildTable->Peer)
+        {
+            ChildTable = ChildTable->Peer;
+        }
+
+        /* Add new subtable at the end of the child list */
+
+        ChildTable->Peer = Subtable;
+    }
+}
+
+
+/******************************************************************************
+ *
+ * FUNCTION:    DtPushSubtable
+ *
+ * PARAMETERS:  Subtable            - Subtable to push
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Push a subtable onto a subtable stack
+ *
+ *****************************************************************************/
+
+void
+DtPushSubtable (
+    DT_SUBTABLE             *Subtable)
+{
+
+    Subtable->StackTop = Gbl_SubtableStack;
+    Gbl_SubtableStack = Subtable;
+}
+
+
+/******************************************************************************
+ *
+ * FUNCTION:    DtPopSubtable
+ *
+ * PARAMETERS:  None
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Pop a subtable from a subtable stack. Uses global SubtableStack
+ *
+ *****************************************************************************/
+
+void
+DtPopSubtable (
+    void)
+{
+    DT_SUBTABLE             *Subtable;
+
+
+    Subtable = Gbl_SubtableStack;
+
+    if (Subtable)
+    {
+        Gbl_SubtableStack = Subtable->StackTop;
+    }
+}
+
+
+/******************************************************************************
+ *
+ * FUNCTION:    DtPeekSubtable
+ *
+ * PARAMETERS:  None
+ *
+ * RETURN:      The subtable on top of stack
+ *
+ * DESCRIPTION: Get the subtable on top of stack
+ *
+ *****************************************************************************/
+
+DT_SUBTABLE *
+DtPeekSubtable (
+    void)
+{
+
+    return (Gbl_SubtableStack);
+}
+
+
+/******************************************************************************
+ *
+ * FUNCTION:    DtGetNextSubtable
+ *
+ * PARAMETERS:  ParentTable         - Parent table whose children we are
+ *                                    getting
+ *              ChildTable          - Previous child that was found.
+ *                                    The NEXT child will be returned
+ *
+ * RETURN:      Pointer to the NEXT child or NULL if none is found.
+ *
+ * DESCRIPTION: Return the next peer subtable within the tree.
+ *
+ *****************************************************************************/
+
+DT_SUBTABLE *
+DtGetNextSubtable (
+    DT_SUBTABLE             *ParentTable,
+    DT_SUBTABLE             *ChildTable)
+{
+    ACPI_FUNCTION_ENTRY ();
+
+
+    if (!ChildTable)
+    {
+        /* It's really the parent's _scope_ that we want */
+
+        return (ParentTable->Child);
+    }
+
+    /* Otherwise just return the next peer (NULL if at end-of-list) */
+
+    return (ChildTable->Peer);
+}
+
+
+/******************************************************************************
+ *
+ * FUNCTION:    DtGetParentSubtable
+ *
+ * PARAMETERS:  Subtable            - Current subtable
+ *
+ * RETURN:      Parent of the given subtable
+ *
+ * DESCRIPTION: Get the parent of the given subtable in the tree
+ *
+ *****************************************************************************/
+
+DT_SUBTABLE *
+DtGetParentSubtable (
+    DT_SUBTABLE             *Subtable)
+{
+
+    if (!Subtable)
+    {
+        return (NULL);
+    }
+
+    return (Subtable->Parent);
+}
+
+
+/******************************************************************************
+ *
+ * FUNCTION:    DtGetSubtableLength
+ *
+ * PARAMETERS:  Field               - Current field list pointer
+ *              Info                - Data table info
+ *
+ * RETURN:      Subtable length
+ *
+ * DESCRIPTION: Get length of bytes needed to compile the subtable
+ *
+ *****************************************************************************/
+
+UINT32
+DtGetSubtableLength (
+    DT_FIELD                *Field,
+    ACPI_DMTABLE_INFO       *Info)
+{
+    UINT32                  ByteLength = 0;
+    UINT8                   Step;
+    UINT8                   i;
+
+
+    /* Walk entire Info table; Null name terminates */
+
+    for (; Info->Name; Info++)
+    {
+        if (Info->Opcode == ACPI_DMT_EXTRA_TEXT)
+        {
+            continue;
+        }
+
+        if (!Field)
+        {
+            goto Error;
+        }
+
+        ByteLength += DtGetFieldLength (Field, Info);
+
+        switch (Info->Opcode)
+        {
+        case ACPI_DMT_GAS:
+
+            Step = 5;
+            break;
+
+        case ACPI_DMT_HESTNTFY:
+
+            Step = 9;
+            break;
+
+        case ACPI_DMT_IORTMEM:
+
+            Step = 10;
+            break;
+
+        default:
+
+            Step = 1;
+            break;
+        }
+
+        for (i = 0; i < Step; i++)
+        {
+            if (!Field)
+            {
+                goto Error;
+            }
+
+            Field = Field->Next;
+        }
+    }
+
+    return (ByteLength);
+
+Error:
+    if (!Field)
+    {
+        sprintf (MsgBuffer, "Found NULL field - Field name \"%s\" needed",
+            Info->Name);
+        DtFatal (ASL_MSG_COMPILER_INTERNAL, NULL, MsgBuffer);
+    }
+
+    return (ASL_EOF);
+}
+
+
+/******************************************************************************
+ *
+ * FUNCTION:    DtSetSubtableLength
+ *
+ * PARAMETERS:  Subtable            - Subtable
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Set length of the subtable into its length field
+ *
+ *****************************************************************************/
+
+void
+DtSetSubtableLength (
+    DT_SUBTABLE             *Subtable)
+{
+
+    if (!Subtable->LengthField)
+    {
+        return;
+    }
+
+    memcpy (Subtable->LengthField, &Subtable->TotalLength,
+        Subtable->SizeOfLengthField);
+}
diff --git a/usr/src/cmd/acpi/iasl/dttable.c b/usr/src/cmd/acpi/iasl/dttable.c
new file mode 100644
index 0000000000..7b33e4d230
--- /dev/null
+++ b/usr/src/cmd/acpi/iasl/dttable.c
@@ -0,0 +1,238 @@
+/******************************************************************************
+ *
+ * Module Name: dttable.c - handling for specific ACPI tables
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2016, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+/* Compile routines for the basic ACPI tables */
+
+#include "aslcompiler.h"
+#include "dtcompiler.h"
+
+#define _COMPONENT          DT_COMPILER
+        ACPI_MODULE_NAME    ("dttable")
+
+
+/******************************************************************************
+ *
+ * FUNCTION:    DtCompileRsdp
+ *
+ * PARAMETERS:  PFieldList          - Current field list pointer
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Compile RSDP.
+ *
+ *****************************************************************************/
+
+ACPI_STATUS
+DtCompileRsdp (
+    DT_FIELD                **PFieldList)
+{
+    DT_SUBTABLE             *Subtable;
+    ACPI_TABLE_RSDP         *Rsdp;
+    ACPI_RSDP_EXTENSION     *RsdpExtension;
+    ACPI_STATUS             Status;
+
+
+    /* Compile the "common" RSDP (ACPI 1.0) */
+
+    Status = DtCompileTable (PFieldList, AcpiDmTableInfoRsdp1,
+        &Gbl_RootTable, TRUE);
+    if (ACPI_FAILURE (Status))
+    {
+        return (Status);
+    }
+
+    Rsdp = ACPI_CAST_PTR (ACPI_TABLE_RSDP, Gbl_RootTable->Buffer);
+    DtSetTableChecksum (&Rsdp->Checksum);
+
+    if (Rsdp->Revision > 0)
+    {
+        /* Compile the "extended" part of the RSDP as a subtable */
+
+        Status = DtCompileTable (PFieldList, AcpiDmTableInfoRsdp2,
+            &Subtable, TRUE);
+        if (ACPI_FAILURE (Status))
+        {
+            return (Status);
+        }
+
+        DtInsertSubtable (Gbl_RootTable, Subtable);
+
+        /* Set length and extended checksum for entire RSDP */
+
+        RsdpExtension = ACPI_CAST_PTR (ACPI_RSDP_EXTENSION, Subtable->Buffer);
+        RsdpExtension->Length = Gbl_RootTable->Length + Subtable->Length;
+        DtSetTableChecksum (&RsdpExtension->ExtendedChecksum);
+    }
+
+    return (AE_OK);
+}
+
+
+/******************************************************************************
+ *
+ * FUNCTION:    DtCompileFadt
+ *
+ * PARAMETERS:  List                - Current field list pointer
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Compile FADT.
+ *
+ *****************************************************************************/
+
+ACPI_STATUS
+DtCompileFadt (
+    void                    **List)
+{
+    ACPI_STATUS             Status;
+    DT_SUBTABLE             *Subtable;
+    DT_SUBTABLE             *ParentTable;
+    DT_FIELD                **PFieldList = (DT_FIELD **) List;
+    ACPI_TABLE_HEADER       *Table;
+    UINT8                   Revision;
+
+
+    Status = DtCompileTable (PFieldList, AcpiDmTableInfoFadt1,
+        &Subtable, TRUE);
+    if (ACPI_FAILURE (Status))
+    {
+        return (Status);
+    }
+
+    ParentTable = DtPeekSubtable ();
+    DtInsertSubtable (ParentTable, Subtable);
+
+    Table = ACPI_CAST_PTR (ACPI_TABLE_HEADER, ParentTable->Buffer);
+    Revision = Table->Revision;
+
+    if (Revision == 2)
+    {
+        Status = DtCompileTable (PFieldList, AcpiDmTableInfoFadt2,
+            &Subtable, TRUE);
+        if (ACPI_FAILURE (Status))
+        {
+            return (Status);
+        }
+
+        DtInsertSubtable (ParentTable, Subtable);
+    }
+    else if (Revision >= 2)
+    {
+        Status = DtCompileTable (PFieldList, AcpiDmTableInfoFadt3,
+            &Subtable, TRUE);
+        if (ACPI_FAILURE (Status))
+        {
+            return (Status);
+        }
+
+        DtInsertSubtable (ParentTable, Subtable);
+
+        if (Revision >= 5)
+        {
+            Status = DtCompileTable (PFieldList, AcpiDmTableInfoFadt5,
+                &Subtable, TRUE);
+            if (ACPI_FAILURE (Status))
+            {
+                return (Status);
+            }
+
+            DtInsertSubtable (ParentTable, Subtable);
+        }
+
+        if (Revision >= 6)
+        {
+            Status = DtCompileTable (PFieldList, AcpiDmTableInfoFadt6,
+                &Subtable, TRUE);
+            if (ACPI_FAILURE (Status))
+            {
+                return (Status);
+            }
+
+            DtInsertSubtable (ParentTable, Subtable);
+        }
+    }
+
+    return (AE_OK);
+}
+
+
+/******************************************************************************
+ *
+ * FUNCTION:    DtCompileFacs
+ *
+ * PARAMETERS:  PFieldList          - Current field list pointer
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Compile FACS.
+ *
+ *****************************************************************************/
+
+ACPI_STATUS
+DtCompileFacs (
+    DT_FIELD                **PFieldList)
+{
+    DT_SUBTABLE             *Subtable;
+    UINT8                   *ReservedBuffer;
+    ACPI_STATUS             Status;
+    UINT32                  ReservedSize;
+
+
+    Status = DtCompileTable (PFieldList, AcpiDmTableInfoFacs,
+        &Gbl_RootTable, TRUE);
+    if (ACPI_FAILURE (Status))
+    {
+        return (Status);
+    }
+
+    /* Large FACS reserved area at the end of the table */
+
+    ReservedSize = (UINT32) sizeof (((ACPI_TABLE_FACS *) NULL)->Reserved1);
+    ReservedBuffer = UtLocalCalloc (ReservedSize);
+
+    DtCreateSubtable (ReservedBuffer, ReservedSize, &Subtable);
+
+    ACPI_FREE (ReservedBuffer);
+    DtInsertSubtable (Gbl_RootTable, Subtable);
+    return (AE_OK);
+}
diff --git a/usr/src/cmd/acpi/iasl/dttable1.c b/usr/src/cmd/acpi/iasl/dttable1.c
new file mode 100644
index 0000000000..a79d33be63
--- /dev/null
+++ b/usr/src/cmd/acpi/iasl/dttable1.c
@@ -0,0 +1,1684 @@
+/******************************************************************************
+ *
+ * Module Name: dttable1.c - handling for specific ACPI tables
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2016, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+/* Compile all complex data tables, signatures starting with A-I */
+
+#include "aslcompiler.h"
+#include "dtcompiler.h"
+
+#define _COMPONENT          DT_COMPILER
+        ACPI_MODULE_NAME    ("dttable1")
+
+
+static ACPI_DMTABLE_INFO           TableInfoAsfAddress[] =
+{
+    {ACPI_DMT_BUFFER,   0,               "Addresses", 0},
+    {ACPI_DMT_EXIT,     0,               NULL, 0}
+};
+
+static ACPI_DMTABLE_INFO           TableInfoDmarPciPath[] =
+{
+    {ACPI_DMT_PCI_PATH, 0,               "PCI Path", 0},
+    {ACPI_DMT_EXIT,     0,               NULL, 0}
+};
+
+
+/******************************************************************************
+ *
+ * FUNCTION:    DtCompileAsf
+ *
+ * PARAMETERS:  List                - Current field list pointer
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Compile ASF!.
+ *
+ *****************************************************************************/
+
+ACPI_STATUS
+DtCompileAsf (
+    void                    **List)
+{
+    ACPI_ASF_INFO           *AsfTable;
+    DT_SUBTABLE             *Subtable;
+    DT_SUBTABLE             *ParentTable;
+    ACPI_DMTABLE_INFO       *InfoTable;
+    ACPI_DMTABLE_INFO       *DataInfoTable = NULL;
+    UINT32                  DataCount = 0;
+    ACPI_STATUS             Status;
+    UINT32                  i;
+    DT_FIELD                **PFieldList = (DT_FIELD **) List;
+    DT_FIELD                *SubtableStart;
+
+
+    while (*PFieldList)
+    {
+        SubtableStart = *PFieldList;
+        Status = DtCompileTable (PFieldList, AcpiDmTableInfoAsfHdr,
+            &Subtable, TRUE);
+        if (ACPI_FAILURE (Status))
+        {
+            return (Status);
+        }
+
+        ParentTable = DtPeekSubtable ();
+        DtInsertSubtable (ParentTable, Subtable);
+        DtPushSubtable (Subtable);
+
+        AsfTable = ACPI_CAST_PTR (ACPI_ASF_INFO, Subtable->Buffer);
+
+        switch (AsfTable->Header.Type & 0x7F) /* Mask off top bit */
+        {
+        case ACPI_ASF_TYPE_INFO:
+
+            InfoTable = AcpiDmTableInfoAsf0;
+            break;
+
+        case ACPI_ASF_TYPE_ALERT:
+
+            InfoTable = AcpiDmTableInfoAsf1;
+            break;
+
+        case ACPI_ASF_TYPE_CONTROL:
+
+            InfoTable = AcpiDmTableInfoAsf2;
+            break;
+
+        case ACPI_ASF_TYPE_BOOT:
+
+            InfoTable = AcpiDmTableInfoAsf3;
+            break;
+
+        case ACPI_ASF_TYPE_ADDRESS:
+
+            InfoTable = AcpiDmTableInfoAsf4;
+            break;
+
+        default:
+
+            DtFatal (ASL_MSG_UNKNOWN_SUBTABLE, SubtableStart, "ASF!");
+            return (AE_ERROR);
+        }
+
+        Status = DtCompileTable (PFieldList, InfoTable, &Subtable, TRUE);
+        if (ACPI_FAILURE (Status))
+        {
+            return (Status);
+        }
+
+        ParentTable = DtPeekSubtable ();
+        DtInsertSubtable (ParentTable, Subtable);
+
+        switch (AsfTable->Header.Type & 0x7F) /* Mask off top bit */
+        {
+        case ACPI_ASF_TYPE_INFO:
+
+            DataInfoTable = NULL;
+            break;
+
+        case ACPI_ASF_TYPE_ALERT:
+
+            DataInfoTable = AcpiDmTableInfoAsf1a;
+            DataCount = ACPI_CAST_PTR (ACPI_ASF_ALERT,
+                ACPI_SUB_PTR (UINT8, Subtable->Buffer,
+                    sizeof (ACPI_ASF_HEADER)))->Alerts;
+            break;
+
+        case ACPI_ASF_TYPE_CONTROL:
+
+            DataInfoTable = AcpiDmTableInfoAsf2a;
+            DataCount = ACPI_CAST_PTR (ACPI_ASF_REMOTE,
+                ACPI_SUB_PTR (UINT8, Subtable->Buffer,
+                    sizeof (ACPI_ASF_HEADER)))->Controls;
+            break;
+
+        case ACPI_ASF_TYPE_BOOT:
+
+            DataInfoTable = NULL;
+            break;
+
+        case ACPI_ASF_TYPE_ADDRESS:
+
+            DataInfoTable = TableInfoAsfAddress;
+            DataCount = ACPI_CAST_PTR (ACPI_ASF_ADDRESS,
+                ACPI_SUB_PTR (UINT8, Subtable->Buffer,
+                    sizeof (ACPI_ASF_HEADER)))->Devices;
+            break;
+
+        default:
+
+            DtFatal (ASL_MSG_UNKNOWN_SUBTABLE, SubtableStart, "ASF!");
+            return (AE_ERROR);
+        }
+
+        if (DataInfoTable)
+        {
+            switch (AsfTable->Header.Type & 0x7F)
+            {
+            case ACPI_ASF_TYPE_ADDRESS:
+
+                while (DataCount > 0)
+                {
+                    Status = DtCompileTable (PFieldList, DataInfoTable,
+                        &Subtable, TRUE);
+                    if (ACPI_FAILURE (Status))
+                    {
+                        return (Status);
+                    }
+
+                    DtInsertSubtable (ParentTable, Subtable);
+                    DataCount = DataCount - Subtable->Length;
+                }
+                break;
+
+            default:
+
+                for (i = 0; i < DataCount; i++)
+                {
+                    Status = DtCompileTable (PFieldList, DataInfoTable,
+                        &Subtable, TRUE);
+                    if (ACPI_FAILURE (Status))
+                    {
+                        return (Status);
+                    }
+
+                    DtInsertSubtable (ParentTable, Subtable);
+                }
+                break;
+            }
+        }
+
+        DtPopSubtable ();
+    }
+
+    return (AE_OK);
+}
+
+
+/******************************************************************************
+ *
+ * FUNCTION:    DtCompileCpep
+ *
+ * PARAMETERS:  List                - Current field list pointer
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Compile CPEP.
+ *
+ *****************************************************************************/
+
+ACPI_STATUS
+DtCompileCpep (
+    void                    **List)
+{
+    ACPI_STATUS             Status;
+
+
+    Status = DtCompileTwoSubtables (List,
+        AcpiDmTableInfoCpep, AcpiDmTableInfoCpep0);
+    return (Status);
+}
+
+
+/******************************************************************************
+ *
+ * FUNCTION:    DtCompileCsrt
+ *
+ * PARAMETERS:  List                - Current field list pointer
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Compile CSRT.
+ *
+ *****************************************************************************/
+
+ACPI_STATUS
+DtCompileCsrt (
+    void                    **List)
+{
+    ACPI_STATUS             Status = AE_OK;
+    DT_SUBTABLE             *Subtable;
+    DT_SUBTABLE             *ParentTable;
+    DT_FIELD                **PFieldList = (DT_FIELD **) List;
+    UINT32                  DescriptorCount;
+    UINT32                  GroupLength;
+
+
+    /* Subtables (Resource Groups) */
+
+    ParentTable = DtPeekSubtable ();
+    while (*PFieldList)
+    {
+        /* Resource group subtable */
+
+        Status = DtCompileTable (PFieldList, AcpiDmTableInfoCsrt0,
+            &Subtable, TRUE);
+        if (ACPI_FAILURE (Status))
+        {
+            return (Status);
+        }
+
+        /* Compute the number of resource descriptors */
+
+        GroupLength =
+            (ACPI_CAST_PTR (ACPI_CSRT_GROUP,
+                Subtable->Buffer))->Length -
+            (ACPI_CAST_PTR (ACPI_CSRT_GROUP,
+                Subtable->Buffer))->SharedInfoLength -
+            sizeof (ACPI_CSRT_GROUP);
+
+        DescriptorCount = (GroupLength  /
+            sizeof (ACPI_CSRT_DESCRIPTOR));
+
+        DtInsertSubtable (ParentTable, Subtable);
+        DtPushSubtable (Subtable);
+        ParentTable = DtPeekSubtable ();
+
+        /* Shared info subtable (One per resource group) */
+
+        Status = DtCompileTable (PFieldList, AcpiDmTableInfoCsrt1,
+            &Subtable, TRUE);
+        if (ACPI_FAILURE (Status))
+        {
+            return (Status);
+        }
+
+        DtInsertSubtable (ParentTable, Subtable);
+
+        /* Sub-Subtables (Resource Descriptors) */
+
+        while (*PFieldList && DescriptorCount)
+        {
+
+            Status = DtCompileTable (PFieldList, AcpiDmTableInfoCsrt2,
+                &Subtable, TRUE);
+            if (ACPI_FAILURE (Status))
+            {
+                return (Status);
+            }
+
+            DtInsertSubtable (ParentTable, Subtable);
+
+            DtPushSubtable (Subtable);
+            ParentTable = DtPeekSubtable ();
+            if (*PFieldList)
+            {
+                Status = DtCompileTable (PFieldList, AcpiDmTableInfoCsrt2a,
+                    &Subtable, TRUE);
+                if (ACPI_FAILURE (Status))
+                {
+                    return (Status);
+                }
+                if (Subtable)
+                {
+                    DtInsertSubtable (ParentTable, Subtable);
+                }
+            }
+
+            DtPopSubtable ();
+            ParentTable = DtPeekSubtable ();
+            DescriptorCount--;
+        }
+
+        DtPopSubtable ();
+        ParentTable = DtPeekSubtable ();
+    }
+
+    return (Status);
+}
+
+
+/******************************************************************************
+ *
+ * FUNCTION:    DtCompileDbg2
+ *
+ * PARAMETERS:  List                - Current field list pointer
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Compile DBG2.
+ *
+ *****************************************************************************/
+
+ACPI_STATUS
+DtCompileDbg2 (
+    void                    **List)
+{
+    ACPI_STATUS             Status;
+    DT_SUBTABLE             *Subtable;
+    DT_SUBTABLE             *ParentTable;
+    DT_FIELD                **PFieldList = (DT_FIELD **) List;
+    UINT32                  SubtableCount;
+    ACPI_DBG2_HEADER        *Dbg2Header;
+    ACPI_DBG2_DEVICE        *DeviceInfo;
+    UINT16                  CurrentOffset;
+    UINT32                  i;
+
+
+    /* Main table */
+
+    Status = DtCompileTable (PFieldList, AcpiDmTableInfoDbg2, &Subtable, TRUE);
+    if (ACPI_FAILURE (Status))
+    {
+        return (Status);
+    }
+
+    ParentTable = DtPeekSubtable ();
+    DtInsertSubtable (ParentTable, Subtable);
+
+    /* Main table fields */
+
+    Dbg2Header = ACPI_CAST_PTR (ACPI_DBG2_HEADER, Subtable->Buffer);
+    Dbg2Header->InfoOffset = sizeof (ACPI_TABLE_HEADER) + ACPI_PTR_DIFF (
+        ACPI_ADD_PTR (UINT8, Dbg2Header, sizeof (ACPI_DBG2_HEADER)), Dbg2Header);
+
+    SubtableCount = Dbg2Header->InfoCount;
+    DtPushSubtable (Subtable);
+
+    /* Process all Device Information subtables (Count = InfoCount) */
+
+    while (*PFieldList && SubtableCount)
+    {
+        /* Subtable: Debug Device Information */
+
+        Status = DtCompileTable (PFieldList, AcpiDmTableInfoDbg2Device,
+            &Subtable, TRUE);
+        if (ACPI_FAILURE (Status))
+        {
+            return (Status);
+        }
+
+        DeviceInfo = ACPI_CAST_PTR (ACPI_DBG2_DEVICE, Subtable->Buffer);
+        CurrentOffset = (UINT16) sizeof (ACPI_DBG2_DEVICE);
+
+        ParentTable = DtPeekSubtable ();
+        DtInsertSubtable (ParentTable, Subtable);
+        DtPushSubtable (Subtable);
+
+        ParentTable = DtPeekSubtable ();
+
+        /* BaseAddressRegister GAS array (Required, size is RegisterCount) */
+
+        DeviceInfo->BaseAddressOffset = CurrentOffset;
+        for (i = 0; *PFieldList && (i < DeviceInfo->RegisterCount); i++)
+        {
+            Status = DtCompileTable (PFieldList, AcpiDmTableInfoDbg2Addr,
+                &Subtable, TRUE);
+            if (ACPI_FAILURE (Status))
+            {
+                return (Status);
+            }
+
+            CurrentOffset += (UINT16) sizeof (ACPI_GENERIC_ADDRESS);
+            DtInsertSubtable (ParentTable, Subtable);
+        }
+
+        /* AddressSize array (Required, size = RegisterCount) */
+
+        DeviceInfo->AddressSizeOffset = CurrentOffset;
+        for (i = 0; *PFieldList && (i < DeviceInfo->RegisterCount); i++)
+        {
+            Status = DtCompileTable (PFieldList, AcpiDmTableInfoDbg2Size,
+                &Subtable, TRUE);
+            if (ACPI_FAILURE (Status))
+            {
+                return (Status);
+            }
+
+            CurrentOffset += (UINT16) sizeof (UINT32);
+            DtInsertSubtable (ParentTable, Subtable);
+        }
+
+        /* NamespaceString device identifier (Required, size = NamePathLength) */
+
+        DeviceInfo->NamepathOffset = CurrentOffset;
+        Status = DtCompileTable (PFieldList, AcpiDmTableInfoDbg2Name,
+            &Subtable, TRUE);
+        if (ACPI_FAILURE (Status))
+        {
+            return (Status);
+        }
+
+        /* Update the device info header */
+
+        DeviceInfo->NamepathLength = (UINT16) Subtable->Length;
+        CurrentOffset += (UINT16) DeviceInfo->NamepathLength;
+        DtInsertSubtable (ParentTable, Subtable);
+
+        /* OemData - Variable-length data (Optional, size = OemDataLength) */
+
+        Status = DtCompileTable (PFieldList, AcpiDmTableInfoDbg2OemData,
+            &Subtable, TRUE);
+        if (ACPI_FAILURE (Status))
+        {
+            return (Status);
+        }
+
+        /* Update the device info header (zeros if no OEM data present) */
+
+        DeviceInfo->OemDataOffset = 0;
+        DeviceInfo->OemDataLength = 0;
+
+        /* Optional subtable (OemData) */
+
+        if (Subtable && Subtable->Length)
+        {
+            DeviceInfo->OemDataOffset = CurrentOffset;
+            DeviceInfo->OemDataLength = (UINT16) Subtable->Length;
+
+            DtInsertSubtable (ParentTable, Subtable);
+        }
+
+        SubtableCount--;
+        DtPopSubtable (); /* Get next Device Information subtable */
+    }
+
+    DtPopSubtable ();
+    return (AE_OK);
+}
+
+
+/******************************************************************************
+ *
+ * FUNCTION:    DtCompileDmar
+ *
+ * PARAMETERS:  List                - Current field list pointer
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Compile DMAR.
+ *
+ *****************************************************************************/
+
+ACPI_STATUS
+DtCompileDmar (
+    void                    **List)
+{
+    ACPI_STATUS             Status;
+    DT_SUBTABLE             *Subtable;
+    DT_SUBTABLE             *ParentTable;
+    DT_FIELD                **PFieldList = (DT_FIELD **) List;
+    DT_FIELD                *SubtableStart;
+    ACPI_DMTABLE_INFO       *InfoTable;
+    ACPI_DMAR_HEADER        *DmarHeader;
+    ACPI_DMAR_DEVICE_SCOPE  *DmarDeviceScope;
+    UINT32                  DeviceScopeLength;
+    UINT32                  PciPathLength;
+
+
+    Status = DtCompileTable (PFieldList, AcpiDmTableInfoDmar, &Subtable, TRUE);
+    if (ACPI_FAILURE (Status))
+    {
+        return (Status);
+    }
+
+    ParentTable = DtPeekSubtable ();
+    DtInsertSubtable (ParentTable, Subtable);
+    DtPushSubtable (Subtable);
+
+    while (*PFieldList)
+    {
+        /* DMAR Header */
+
+        SubtableStart = *PFieldList;
+        Status = DtCompileTable (PFieldList, AcpiDmTableInfoDmarHdr,
+            &Subtable, TRUE);
+        if (ACPI_FAILURE (Status))
+        {
+            return (Status);
+        }
+
+        ParentTable = DtPeekSubtable ();
+        DtInsertSubtable (ParentTable, Subtable);
+        DtPushSubtable (Subtable);
+
+        DmarHeader = ACPI_CAST_PTR (ACPI_DMAR_HEADER, Subtable->Buffer);
+
+        switch (DmarHeader->Type)
+        {
+        case ACPI_DMAR_TYPE_HARDWARE_UNIT:
+
+            InfoTable = AcpiDmTableInfoDmar0;
+            break;
+
+        case ACPI_DMAR_TYPE_RESERVED_MEMORY:
+
+            InfoTable = AcpiDmTableInfoDmar1;
+            break;
+
+        case ACPI_DMAR_TYPE_ROOT_ATS:
+
+            InfoTable = AcpiDmTableInfoDmar2;
+            break;
+
+        case ACPI_DMAR_TYPE_HARDWARE_AFFINITY:
+
+            InfoTable = AcpiDmTableInfoDmar3;
+            break;
+
+        case ACPI_DMAR_TYPE_NAMESPACE:
+
+            InfoTable = AcpiDmTableInfoDmar4;
+            break;
+
+        default:
+
+            DtFatal (ASL_MSG_UNKNOWN_SUBTABLE, SubtableStart, "DMAR");
+            return (AE_ERROR);
+        }
+
+        /* DMAR Subtable */
+
+        Status = DtCompileTable (PFieldList, InfoTable, &Subtable, TRUE);
+        if (ACPI_FAILURE (Status))
+        {
+            return (Status);
+        }
+
+        ParentTable = DtPeekSubtable ();
+        DtInsertSubtable (ParentTable, Subtable);
+
+        /*
+         * Optional Device Scope subtables
+         */
+        if ((DmarHeader->Type == ACPI_DMAR_TYPE_HARDWARE_AFFINITY) ||
+            (DmarHeader->Type == ACPI_DMAR_TYPE_NAMESPACE))
+        {
+            /* These types do not support device scopes */
+
+            DtPopSubtable ();
+            continue;
+        }
+
+        DtPushSubtable (Subtable);
+        DeviceScopeLength = DmarHeader->Length - Subtable->Length -
+            ParentTable->Length;
+        while (DeviceScopeLength)
+        {
+            Status = DtCompileTable (PFieldList, AcpiDmTableInfoDmarScope,
+                &Subtable, FALSE);
+            if (Status == AE_NOT_FOUND)
+            {
+                break;
+            }
+
+            ParentTable = DtPeekSubtable ();
+            DtInsertSubtable (ParentTable, Subtable);
+            DtPushSubtable (Subtable);
+
+            DmarDeviceScope = ACPI_CAST_PTR (ACPI_DMAR_DEVICE_SCOPE, Subtable->Buffer);
+
+            /* Optional PCI Paths */
+
+            PciPathLength = DmarDeviceScope->Length - Subtable->Length;
+            while (PciPathLength)
+            {
+                Status = DtCompileTable (PFieldList, TableInfoDmarPciPath,
+                    &Subtable, FALSE);
+                if (Status == AE_NOT_FOUND)
+                {
+                    DtPopSubtable ();
+                    break;
+                }
+
+                ParentTable = DtPeekSubtable ();
+                DtInsertSubtable (ParentTable, Subtable);
+                PciPathLength -= Subtable->Length;
+            }
+
+            DtPopSubtable ();
+            DeviceScopeLength -= DmarDeviceScope->Length;
+        }
+
+        DtPopSubtable ();
+        DtPopSubtable ();
+    }
+
+    return (AE_OK);
+}
+
+
+/******************************************************************************
+ *
+ * FUNCTION:    DtCompileDrtm
+ *
+ * PARAMETERS:  List                - Current field list pointer
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Compile DRTM.
+ *
+ *****************************************************************************/
+
+ACPI_STATUS
+DtCompileDrtm (
+    void                    **List)
+{
+    ACPI_STATUS             Status;
+    DT_SUBTABLE             *Subtable;
+    DT_SUBTABLE             *ParentTable;
+    DT_FIELD                **PFieldList = (DT_FIELD **) List;
+    UINT32                  Count;
+    /* ACPI_TABLE_DRTM         *Drtm; */
+    ACPI_DRTM_VTABLE_LIST   *DrtmVtl;
+    ACPI_DRTM_RESOURCE_LIST *DrtmRl;
+    /* ACPI_DRTM_DPS_ID        *DrtmDps; */
+
+
+    ParentTable = DtPeekSubtable ();
+
+    /* Compile DRTM header */
+
+    Status = DtCompileTable (PFieldList, AcpiDmTableInfoDrtm,
+        &Subtable, TRUE);
+    if (ACPI_FAILURE (Status))
+    {
+        return (Status);
+    }
+    DtInsertSubtable (ParentTable, Subtable);
+
+    /*
+     * Using ACPI_SUB_PTR, We needn't define a seperate structure. Care
+     * should be taken to avoid accessing ACPI_TABLE_HADER fields.
+     */
+#if 0
+    Drtm = ACPI_SUB_PTR (ACPI_TABLE_DRTM,
+        Subtable->Buffer, sizeof (ACPI_TABLE_HEADER));
+#endif
+    /* Compile VTL */
+
+    Status = DtCompileTable (PFieldList, AcpiDmTableInfoDrtm0,
+        &Subtable, TRUE);
+    if (ACPI_FAILURE (Status))
+    {
+        return (Status);
+    }
+
+    DtInsertSubtable (ParentTable, Subtable);
+    DrtmVtl = ACPI_CAST_PTR (ACPI_DRTM_VTABLE_LIST, Subtable->Buffer);
+
+    DtPushSubtable (Subtable);
+    ParentTable = DtPeekSubtable ();
+    Count = 0;
+
+    while (*PFieldList)
+    {
+        Status = DtCompileTable (PFieldList, AcpiDmTableInfoDrtm0a,
+            &Subtable, TRUE);
+        if (ACPI_FAILURE (Status))
+        {
+            return (Status);
+        }
+        if (!Subtable)
+        {
+            break;
+        }
+        DtInsertSubtable (ParentTable, Subtable);
+        Count++;
+    }
+
+    DrtmVtl->ValidatedTableCount = Count;
+    DtPopSubtable ();
+    ParentTable = DtPeekSubtable ();
+
+    /* Compile RL */
+
+    Status = DtCompileTable (PFieldList, AcpiDmTableInfoDrtm1,
+        &Subtable, TRUE);
+    if (ACPI_FAILURE (Status))
+    {
+        return (Status);
+    }
+
+    DtInsertSubtable (ParentTable, Subtable);
+    DrtmRl = ACPI_CAST_PTR (ACPI_DRTM_RESOURCE_LIST, Subtable->Buffer);
+
+    DtPushSubtable (Subtable);
+    ParentTable = DtPeekSubtable ();
+    Count = 0;
+
+    while (*PFieldList)
+    {
+        Status = DtCompileTable (PFieldList, AcpiDmTableInfoDrtm1a,
+            &Subtable, TRUE);
+        if (ACPI_FAILURE (Status))
+        {
+            return (Status);
+        }
+
+        if (!Subtable)
+        {
+            break;
+        }
+
+        DtInsertSubtable (ParentTable, Subtable);
+        Count++;
+    }
+
+    DrtmRl->ResourceCount = Count;
+    DtPopSubtable ();
+    ParentTable = DtPeekSubtable ();
+
+    /* Compile DPS */
+
+    Status = DtCompileTable (PFieldList, AcpiDmTableInfoDrtm2,
+        &Subtable, TRUE);
+    if (ACPI_FAILURE (Status))
+    {
+        return (Status);
+    }
+    DtInsertSubtable (ParentTable, Subtable);
+    /* DrtmDps = ACPI_CAST_PTR (ACPI_DRTM_DPS_ID, Subtable->Buffer);*/
+
+
+    return (AE_OK);
+}
+
+
+/******************************************************************************
+ *
+ * FUNCTION:    DtCompileEinj
+ *
+ * PARAMETERS:  List                - Current field list pointer
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Compile EINJ.
+ *
+ *****************************************************************************/
+
+ACPI_STATUS
+DtCompileEinj (
+    void                    **List)
+{
+    ACPI_STATUS             Status;
+
+
+    Status = DtCompileTwoSubtables (List,
+        AcpiDmTableInfoEinj, AcpiDmTableInfoEinj0);
+    return (Status);
+}
+
+
+/******************************************************************************
+ *
+ * FUNCTION:    DtCompileErst
+ *
+ * PARAMETERS:  List                - Current field list pointer
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Compile ERST.
+ *
+ *****************************************************************************/
+
+ACPI_STATUS
+DtCompileErst (
+    void                    **List)
+{
+    ACPI_STATUS             Status;
+
+
+    Status = DtCompileTwoSubtables (List,
+        AcpiDmTableInfoErst, AcpiDmTableInfoEinj0);
+    return (Status);
+}
+
+
+/******************************************************************************
+ *
+ * FUNCTION:    DtCompileGtdt
+ *
+ * PARAMETERS:  List                - Current field list pointer
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Compile GTDT.
+ *
+ *****************************************************************************/
+
+ACPI_STATUS
+DtCompileGtdt (
+    void                    **List)
+{
+    ACPI_STATUS             Status;
+    DT_SUBTABLE             *Subtable;
+    DT_SUBTABLE             *ParentTable;
+    DT_FIELD                **PFieldList = (DT_FIELD **) List;
+    DT_FIELD                *SubtableStart;
+    ACPI_SUBTABLE_HEADER    *GtdtHeader;
+    ACPI_DMTABLE_INFO       *InfoTable;
+    UINT32                  GtCount;
+
+
+    Status = DtCompileTable (PFieldList, AcpiDmTableInfoGtdt,
+        &Subtable, TRUE);
+    if (ACPI_FAILURE (Status))
+    {
+        return (Status);
+    }
+
+    ParentTable = DtPeekSubtable ();
+    DtInsertSubtable (ParentTable, Subtable);
+
+    while (*PFieldList)
+    {
+        SubtableStart = *PFieldList;
+        Status = DtCompileTable (PFieldList, AcpiDmTableInfoGtdtHdr,
+            &Subtable, TRUE);
+        if (ACPI_FAILURE (Status))
+        {
+            return (Status);
+        }
+
+        ParentTable = DtPeekSubtable ();
+        DtInsertSubtable (ParentTable, Subtable);
+        DtPushSubtable (Subtable);
+
+        GtdtHeader = ACPI_CAST_PTR (ACPI_SUBTABLE_HEADER, Subtable->Buffer);
+
+        switch (GtdtHeader->Type)
+        {
+        case ACPI_GTDT_TYPE_TIMER_BLOCK:
+
+            InfoTable = AcpiDmTableInfoGtdt0;
+            break;
+
+        case ACPI_GTDT_TYPE_WATCHDOG:
+
+            InfoTable = AcpiDmTableInfoGtdt1;
+            break;
+
+        default:
+
+            DtFatal (ASL_MSG_UNKNOWN_SUBTABLE, SubtableStart, "GTDT");
+            return (AE_ERROR);
+        }
+
+        Status = DtCompileTable (PFieldList, InfoTable, &Subtable, TRUE);
+        if (ACPI_FAILURE (Status))
+        {
+            return (Status);
+        }
+
+        ParentTable = DtPeekSubtable ();
+        DtInsertSubtable (ParentTable, Subtable);
+
+        /*
+         * Additional GT block subtable data
+         */
+
+        switch (GtdtHeader->Type)
+        {
+        case ACPI_GTDT_TYPE_TIMER_BLOCK:
+
+            DtPushSubtable (Subtable);
+            ParentTable = DtPeekSubtable ();
+
+            GtCount = (ACPI_CAST_PTR (ACPI_GTDT_TIMER_BLOCK,
+                Subtable->Buffer - sizeof(ACPI_GTDT_HEADER)))->TimerCount;
+
+            while (GtCount)
+            {
+                Status = DtCompileTable (PFieldList, AcpiDmTableInfoGtdt0a,
+                    &Subtable, TRUE);
+                if (ACPI_FAILURE (Status))
+                {
+                    return (Status);
+                }
+
+                DtInsertSubtable (ParentTable, Subtable);
+                GtCount--;
+            }
+
+            DtPopSubtable ();
+            break;
+
+        default:
+
+            break;
+        }
+
+        DtPopSubtable ();
+    }
+
+    return (AE_OK);
+}
+
+
+/******************************************************************************
+ *
+ * FUNCTION:    DtCompileFpdt
+ *
+ * PARAMETERS:  List                - Current field list pointer
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Compile FPDT.
+ *
+ *****************************************************************************/
+
+ACPI_STATUS
+DtCompileFpdt (
+    void                    **List)
+{
+    ACPI_STATUS             Status;
+    ACPI_FPDT_HEADER        *FpdtHeader;
+    DT_SUBTABLE             *Subtable;
+    DT_SUBTABLE             *ParentTable;
+    ACPI_DMTABLE_INFO       *InfoTable;
+    DT_FIELD                **PFieldList = (DT_FIELD **) List;
+    DT_FIELD                *SubtableStart;
+
+
+    while (*PFieldList)
+    {
+        SubtableStart = *PFieldList;
+        Status = DtCompileTable (PFieldList, AcpiDmTableInfoFpdtHdr,
+            &Subtable, TRUE);
+        if (ACPI_FAILURE (Status))
+        {
+            return (Status);
+        }
+
+        ParentTable = DtPeekSubtable ();
+        DtInsertSubtable (ParentTable, Subtable);
+        DtPushSubtable (Subtable);
+
+        FpdtHeader = ACPI_CAST_PTR (ACPI_FPDT_HEADER, Subtable->Buffer);
+
+        switch (FpdtHeader->Type)
+        {
+        case ACPI_FPDT_TYPE_BOOT:
+
+            InfoTable = AcpiDmTableInfoFpdt0;
+            break;
+
+        case ACPI_FPDT_TYPE_S3PERF:
+
+            InfoTable = AcpiDmTableInfoFpdt1;
+            break;
+
+        default:
+
+            DtFatal (ASL_MSG_UNKNOWN_SUBTABLE, SubtableStart, "FPDT");
+            return (AE_ERROR);
+            break;
+        }
+
+        Status = DtCompileTable (PFieldList, InfoTable, &Subtable, TRUE);
+        if (ACPI_FAILURE (Status))
+        {
+            return (Status);
+        }
+
+        ParentTable = DtPeekSubtable ();
+        DtInsertSubtable (ParentTable, Subtable);
+        DtPopSubtable ();
+    }
+
+    return (AE_OK);
+}
+
+
+/******************************************************************************
+ *
+ * FUNCTION:    DtCompileHest
+ *
+ * PARAMETERS:  List                - Current field list pointer
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Compile HEST.
+ *
+ *****************************************************************************/
+
+ACPI_STATUS
+DtCompileHest (
+    void                    **List)
+{
+    ACPI_STATUS             Status;
+    DT_SUBTABLE             *Subtable;
+    DT_SUBTABLE             *ParentTable;
+    DT_FIELD                **PFieldList = (DT_FIELD **) List;
+    DT_FIELD                *SubtableStart;
+    ACPI_DMTABLE_INFO       *InfoTable;
+    UINT16                  Type;
+    UINT32                  BankCount;
+
+
+    Status = DtCompileTable (PFieldList, AcpiDmTableInfoHest,
+        &Subtable, TRUE);
+    if (ACPI_FAILURE (Status))
+    {
+        return (Status);
+    }
+
+    ParentTable = DtPeekSubtable ();
+    DtInsertSubtable (ParentTable, Subtable);
+
+    while (*PFieldList)
+    {
+        /* Get subtable type */
+
+        SubtableStart = *PFieldList;
+        DtCompileInteger ((UINT8 *) &Type, *PFieldList, 2, 0);
+
+        switch (Type)
+        {
+        case ACPI_HEST_TYPE_IA32_CHECK:
+
+            InfoTable = AcpiDmTableInfoHest0;
+            break;
+
+        case ACPI_HEST_TYPE_IA32_CORRECTED_CHECK:
+
+            InfoTable = AcpiDmTableInfoHest1;
+            break;
+
+        case ACPI_HEST_TYPE_IA32_NMI:
+
+            InfoTable = AcpiDmTableInfoHest2;
+            break;
+
+        case ACPI_HEST_TYPE_AER_ROOT_PORT:
+
+            InfoTable = AcpiDmTableInfoHest6;
+            break;
+
+        case ACPI_HEST_TYPE_AER_ENDPOINT:
+
+            InfoTable = AcpiDmTableInfoHest7;
+            break;
+
+        case ACPI_HEST_TYPE_AER_BRIDGE:
+
+            InfoTable = AcpiDmTableInfoHest8;
+            break;
+
+        case ACPI_HEST_TYPE_GENERIC_ERROR:
+
+            InfoTable = AcpiDmTableInfoHest9;
+            break;
+
+        default:
+
+            /* Cannot continue on unknown type */
+
+            DtFatal (ASL_MSG_UNKNOWN_SUBTABLE, SubtableStart, "HEST");
+            return (AE_ERROR);
+        }
+
+        Status = DtCompileTable (PFieldList, InfoTable, &Subtable, TRUE);
+        if (ACPI_FAILURE (Status))
+        {
+            return (Status);
+        }
+
+        DtInsertSubtable (ParentTable, Subtable);
+
+        /*
+         * Additional subtable data - IA32 Error Bank(s)
+         */
+        BankCount = 0;
+        switch (Type)
+        {
+        case ACPI_HEST_TYPE_IA32_CHECK:
+
+            BankCount = (ACPI_CAST_PTR (ACPI_HEST_IA_MACHINE_CHECK,
+                Subtable->Buffer))->NumHardwareBanks;
+            break;
+
+        case ACPI_HEST_TYPE_IA32_CORRECTED_CHECK:
+
+            BankCount = (ACPI_CAST_PTR (ACPI_HEST_IA_CORRECTED,
+                Subtable->Buffer))->NumHardwareBanks;
+            break;
+
+        default:
+
+            break;
+        }
+
+        while (BankCount)
+        {
+            Status = DtCompileTable (PFieldList, AcpiDmTableInfoHestBank,
+                &Subtable, TRUE);
+            if (ACPI_FAILURE (Status))
+            {
+                return (Status);
+            }
+
+            DtInsertSubtable (ParentTable, Subtable);
+            BankCount--;
+        }
+    }
+
+    return (AE_OK);
+}
+
+
+/******************************************************************************
+ *
+ * FUNCTION:    DtCompileIort
+ *
+ * PARAMETERS:  List                - Current field list pointer
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Compile IORT.
+ *
+ *****************************************************************************/
+
+ACPI_STATUS
+DtCompileIort (
+    void                    **List)
+{
+    ACPI_STATUS             Status;
+    DT_SUBTABLE             *Subtable;
+    DT_SUBTABLE             *ParentTable;
+    DT_FIELD                **PFieldList = (DT_FIELD **) List;
+    DT_FIELD                *SubtableStart;
+    ACPI_TABLE_IORT         *Iort;
+    ACPI_IORT_NODE          *IortNode;
+    ACPI_IORT_ITS_GROUP     *IortItsGroup;
+    ACPI_IORT_SMMU          *IortSmmu;
+    UINT32                  NodeNumber;
+    UINT32                  NodeLength;
+    UINT32                  IdMappingNumber;
+    UINT32                  ItsNumber;
+    UINT32                  ContextIrptNumber;
+    UINT32                  PmuIrptNumber;
+    UINT32                  PaddingLength;
+
+
+    ParentTable = DtPeekSubtable ();
+
+    Status = DtCompileTable (PFieldList, AcpiDmTableInfoIort,
+        &Subtable, TRUE);
+    if (ACPI_FAILURE (Status))
+    {
+        return (Status);
+    }
+    DtInsertSubtable (ParentTable, Subtable);
+
+    /*
+     * Using ACPI_SUB_PTR, We needn't define a separate structure. Care
+     * should be taken to avoid accessing ACPI_TABLE_HEADER fields.
+     */
+    Iort = ACPI_SUB_PTR (ACPI_TABLE_IORT,
+        Subtable->Buffer, sizeof (ACPI_TABLE_HEADER));
+
+    /*
+     * OptionalPadding - Variable-length data
+     * (Optional, size = OffsetToNodes - sizeof (ACPI_TABLE_IORT))
+     * Optionally allows the generic data types to be used for filling
+     * this field.
+     */
+    Iort->NodeOffset = sizeof (ACPI_TABLE_IORT);
+    Status = DtCompileTable (PFieldList, AcpiDmTableInfoIortPad,
+        &Subtable, TRUE);
+    if (ACPI_FAILURE (Status))
+    {
+        return (Status);
+    }
+    if (Subtable)
+    {
+        DtInsertSubtable (ParentTable, Subtable);
+        Iort->NodeOffset += Subtable->Length;
+    }
+    else
+    {
+        Status = DtCompileGeneric (ACPI_CAST_PTR (void *, PFieldList),
+            AcpiDmTableInfoIortHdr[0].Name, &PaddingLength);
+        if (ACPI_FAILURE (Status))
+        {
+            return (Status);
+        }
+        Iort->NodeOffset += PaddingLength;
+    }
+
+    NodeNumber = 0;
+    while (*PFieldList)
+    {
+        SubtableStart = *PFieldList;
+        Status = DtCompileTable (PFieldList, AcpiDmTableInfoIortHdr,
+            &Subtable, TRUE);
+        if (ACPI_FAILURE (Status))
+        {
+            return (Status);
+        }
+
+        DtInsertSubtable (ParentTable, Subtable);
+        IortNode = ACPI_CAST_PTR (ACPI_IORT_NODE, Subtable->Buffer);
+        NodeLength = ACPI_OFFSET (ACPI_IORT_NODE, NodeData);
+
+        DtPushSubtable (Subtable);
+        ParentTable = DtPeekSubtable ();
+
+        switch (IortNode->Type)
+        {
+        case ACPI_IORT_NODE_ITS_GROUP:
+
+            Status = DtCompileTable (PFieldList, AcpiDmTableInfoIort0,
+                &Subtable, TRUE);
+            if (ACPI_FAILURE (Status))
+            {
+                return (Status);
+            }
+
+            DtInsertSubtable (ParentTable, Subtable);
+            IortItsGroup = ACPI_CAST_PTR (ACPI_IORT_ITS_GROUP, Subtable->Buffer);
+            NodeLength += Subtable->Length;
+
+            ItsNumber = 0;
+            while (*PFieldList)
+            {
+                Status = DtCompileTable (PFieldList, AcpiDmTableInfoIort0a,
+                    &Subtable, TRUE);
+                if (ACPI_FAILURE (Status))
+                {
+                    return (Status);
+                }
+                if (!Subtable)
+                {
+                    break;
+                }
+
+                DtInsertSubtable (ParentTable, Subtable);
+                NodeLength += Subtable->Length;
+                ItsNumber++;
+            }
+
+            IortItsGroup->ItsCount = ItsNumber;
+            break;
+
+        case ACPI_IORT_NODE_NAMED_COMPONENT:
+
+            Status = DtCompileTable (PFieldList, AcpiDmTableInfoIort1,
+                &Subtable, TRUE);
+            if (ACPI_FAILURE (Status))
+            {
+                return (Status);
+            }
+
+            DtInsertSubtable (ParentTable, Subtable);
+            NodeLength += Subtable->Length;
+
+            /*
+             * Padding - Variable-length data
+             * Optionally allows the offset of the ID mappings to be used
+             * for filling this field.
+             */
+            Status = DtCompileTable (PFieldList, AcpiDmTableInfoIort1a,
+                &Subtable, TRUE);
+            if (ACPI_FAILURE (Status))
+            {
+                return (Status);
+            }
+
+            if (Subtable)
+            {
+                DtInsertSubtable (ParentTable, Subtable);
+                NodeLength += Subtable->Length;
+            }
+            else
+            {
+                if (NodeLength > IortNode->MappingOffset)
+                {
+                    return (AE_BAD_DATA);
+                }
+
+                if (NodeLength < IortNode->MappingOffset)
+                {
+                    Status = DtCompilePadding (
+                        IortNode->MappingOffset - NodeLength,
+                        &Subtable);
+                    if (ACPI_FAILURE (Status))
+                    {
+                        return (Status);
+                    }
+
+                    DtInsertSubtable (ParentTable, Subtable);
+                    NodeLength = IortNode->MappingOffset;
+                }
+            }
+            break;
+
+        case ACPI_IORT_NODE_PCI_ROOT_COMPLEX:
+
+            Status = DtCompileTable (PFieldList, AcpiDmTableInfoIort2,
+                &Subtable, TRUE);
+            if (ACPI_FAILURE (Status))
+            {
+                return (Status);
+            }
+
+            DtInsertSubtable (ParentTable, Subtable);
+            NodeLength += Subtable->Length;
+            break;
+
+        case ACPI_IORT_NODE_SMMU:
+
+            Status = DtCompileTable (PFieldList, AcpiDmTableInfoIort3,
+                &Subtable, TRUE);
+            if (ACPI_FAILURE (Status))
+            {
+                return (Status);
+            }
+
+            DtInsertSubtable (ParentTable, Subtable);
+            IortSmmu = ACPI_CAST_PTR (ACPI_IORT_SMMU, Subtable->Buffer);
+            NodeLength += Subtable->Length;
+
+            /* Compile global interrupt array */
+
+            IortSmmu->GlobalInterruptOffset = NodeLength;
+            Status = DtCompileTable (PFieldList, AcpiDmTableInfoIort3a,
+                &Subtable, TRUE);
+            if (ACPI_FAILURE (Status))
+            {
+                return (Status);
+            }
+
+            DtInsertSubtable (ParentTable, Subtable);
+            NodeLength += Subtable->Length;
+
+            /* Compile context interrupt array */
+
+            ContextIrptNumber = 0;
+            IortSmmu->ContextInterruptOffset = NodeLength;
+            while (*PFieldList)
+            {
+                Status = DtCompileTable (PFieldList, AcpiDmTableInfoIort3b,
+                    &Subtable, TRUE);
+                if (ACPI_FAILURE (Status))
+                {
+                    return (Status);
+                }
+
+                if (!Subtable)
+                {
+                    break;
+                }
+
+                DtInsertSubtable (ParentTable, Subtable);
+                NodeLength += Subtable->Length;
+                ContextIrptNumber++;
+            }
+
+            IortSmmu->ContextInterruptCount = ContextIrptNumber;
+
+            /* Compile PMU interrupt array */
+
+            PmuIrptNumber = 0;
+            IortSmmu->PmuInterruptOffset = NodeLength;
+            while (*PFieldList)
+            {
+                Status = DtCompileTable (PFieldList, AcpiDmTableInfoIort3c,
+                    &Subtable, TRUE);
+                if (ACPI_FAILURE (Status))
+                {
+                    return (Status);
+                }
+
+                if (!Subtable)
+                {
+                    break;
+                }
+
+                DtInsertSubtable (ParentTable, Subtable);
+                NodeLength += Subtable->Length;
+                PmuIrptNumber++;
+            }
+
+            IortSmmu->PmuInterruptCount = PmuIrptNumber;
+            break;
+
+        case ACPI_IORT_NODE_SMMU_V3:
+
+            Status = DtCompileTable (PFieldList, AcpiDmTableInfoIort4,
+                &Subtable, TRUE);
+            if (ACPI_FAILURE (Status))
+            {
+                return (Status);
+            }
+
+            DtInsertSubtable (ParentTable, Subtable);
+            NodeLength += Subtable->Length;
+            break;
+
+        default:
+
+            DtFatal (ASL_MSG_UNKNOWN_SUBTABLE, SubtableStart, "IORT");
+            return (AE_ERROR);
+        }
+
+        /* Compile Array of ID mappings */
+
+        IortNode->MappingOffset = NodeLength;
+        IdMappingNumber = 0;
+        while (*PFieldList)
+        {
+            Status = DtCompileTable (PFieldList, AcpiDmTableInfoIortMap,
+                &Subtable, TRUE);
+            if (ACPI_FAILURE (Status))
+            {
+                return (Status);
+            }
+
+            if (!Subtable)
+            {
+                break;
+            }
+
+            DtInsertSubtable (ParentTable, Subtable);
+            NodeLength += sizeof (ACPI_IORT_ID_MAPPING);
+            IdMappingNumber++;
+        }
+
+        IortNode->MappingCount = IdMappingNumber;
+
+        /*
+         * Node length can be determined by DT_LENGTH option
+         * IortNode->Length = NodeLength;
+         */
+        DtPopSubtable ();
+        ParentTable = DtPeekSubtable ();
+        NodeNumber++;
+    }
+
+    Iort->NodeCount = NodeNumber;
+    return (AE_OK);
+}
+
+
+/******************************************************************************
+ *
+ * FUNCTION:    DtCompileIvrs
+ *
+ * PARAMETERS:  List                - Current field list pointer
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Compile IVRS.
+ *
+ *****************************************************************************/
+
+ACPI_STATUS
+DtCompileIvrs (
+    void                    **List)
+{
+    ACPI_STATUS             Status;
+    DT_SUBTABLE             *Subtable;
+    DT_SUBTABLE             *ParentTable;
+    DT_FIELD                **PFieldList = (DT_FIELD **) List;
+    DT_FIELD                *SubtableStart;
+    ACPI_DMTABLE_INFO       *InfoTable;
+    ACPI_IVRS_HEADER        *IvrsHeader;
+    UINT8                   EntryType;
+
+
+    Status = DtCompileTable (PFieldList, AcpiDmTableInfoIvrs,
+        &Subtable, TRUE);
+    if (ACPI_FAILURE (Status))
+    {
+        return (Status);
+    }
+
+    ParentTable = DtPeekSubtable ();
+    DtInsertSubtable (ParentTable, Subtable);
+
+    while (*PFieldList)
+    {
+        SubtableStart = *PFieldList;
+        Status = DtCompileTable (PFieldList, AcpiDmTableInfoIvrsHdr,
+            &Subtable, TRUE);
+        if (ACPI_FAILURE (Status))
+        {
+            return (Status);
+        }
+
+        ParentTable = DtPeekSubtable ();
+        DtInsertSubtable (ParentTable, Subtable);
+        DtPushSubtable (Subtable);
+
+        IvrsHeader = ACPI_CAST_PTR (ACPI_IVRS_HEADER, Subtable->Buffer);
+
+        switch (IvrsHeader->Type)
+        {
+        case ACPI_IVRS_TYPE_HARDWARE:
+
+            InfoTable = AcpiDmTableInfoIvrs0;
+            break;
+
+        case ACPI_IVRS_TYPE_MEMORY1:
+        case ACPI_IVRS_TYPE_MEMORY2:
+        case ACPI_IVRS_TYPE_MEMORY3:
+
+            InfoTable = AcpiDmTableInfoIvrs1;
+            break;
+
+        default:
+
+            DtFatal (ASL_MSG_UNKNOWN_SUBTABLE, SubtableStart, "IVRS");
+            return (AE_ERROR);
+        }
+
+        Status = DtCompileTable (PFieldList, InfoTable, &Subtable, TRUE);
+        if (ACPI_FAILURE (Status))
+        {
+            return (Status);
+        }
+
+        ParentTable = DtPeekSubtable ();
+        DtInsertSubtable (ParentTable, Subtable);
+
+        if (IvrsHeader->Type == ACPI_IVRS_TYPE_HARDWARE)
+        {
+            while (*PFieldList &&
+                !strcmp ((*PFieldList)->Name, "Entry Type"))
+            {
+                SubtableStart = *PFieldList;
+                DtCompileInteger (&EntryType, *PFieldList, 1, 0);
+
+                switch (EntryType)
+                {
+                /* 4-byte device entries */
+
+                case ACPI_IVRS_TYPE_PAD4:
+                case ACPI_IVRS_TYPE_ALL:
+                case ACPI_IVRS_TYPE_SELECT:
+                case ACPI_IVRS_TYPE_START:
+                case ACPI_IVRS_TYPE_END:
+
+                    InfoTable = AcpiDmTableInfoIvrs4;
+                    break;
+
+                /* 8-byte entries, type A */
+
+                case ACPI_IVRS_TYPE_ALIAS_SELECT:
+                case ACPI_IVRS_TYPE_ALIAS_START:
+
+                    InfoTable = AcpiDmTableInfoIvrs8a;
+                    break;
+
+                /* 8-byte entries, type B */
+
+                case ACPI_IVRS_TYPE_PAD8:
+                case ACPI_IVRS_TYPE_EXT_SELECT:
+                case ACPI_IVRS_TYPE_EXT_START:
+
+                    InfoTable = AcpiDmTableInfoIvrs8b;
+                    break;
+
+                /* 8-byte entries, type C */
+
+                case ACPI_IVRS_TYPE_SPECIAL:
+
+                    InfoTable = AcpiDmTableInfoIvrs8c;
+                    break;
+
+                default:
+
+                    DtFatal (ASL_MSG_UNKNOWN_SUBTABLE, SubtableStart,
+                        "IVRS Device Entry");
+                    return (AE_ERROR);
+                }
+
+                Status = DtCompileTable (PFieldList, InfoTable,
+                    &Subtable, TRUE);
+                if (ACPI_FAILURE (Status))
+                {
+                    return (Status);
+                }
+
+                DtInsertSubtable (ParentTable, Subtable);
+            }
+        }
+
+        DtPopSubtable ();
+    }
+
+    return (AE_OK);
+}
diff --git a/usr/src/cmd/acpi/iasl/dttable2.c b/usr/src/cmd/acpi/iasl/dttable2.c
new file mode 100644
index 0000000000..9eb04117e2
--- /dev/null
+++ b/usr/src/cmd/acpi/iasl/dttable2.c
@@ -0,0 +1,1691 @@
+/******************************************************************************
+ *
+ * Module Name: dttable2.c - handling for specific ACPI tables
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2016, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+/* Compile all complex data tables, signatures starting with L-Z */
+
+#include "aslcompiler.h"
+#include "dtcompiler.h"
+
+#define _COMPONENT          DT_COMPILER
+        ACPI_MODULE_NAME    ("dttable2")
+
+
+/******************************************************************************
+ *
+ * FUNCTION:    DtCompileLpit
+ *
+ * PARAMETERS:  List                - Current field list pointer
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Compile LPIT.
+ *
+ *****************************************************************************/
+
+ACPI_STATUS
+DtCompileLpit (
+    void                    **List)
+{
+    ACPI_STATUS             Status;
+    DT_SUBTABLE             *Subtable;
+    DT_SUBTABLE             *ParentTable;
+    DT_FIELD                **PFieldList = (DT_FIELD **) List;
+    DT_FIELD                *SubtableStart;
+    ACPI_DMTABLE_INFO       *InfoTable;
+    ACPI_LPIT_HEADER        *LpitHeader;
+
+
+    /* Note: Main table consists only of the standard ACPI table header */
+
+    while (*PFieldList)
+    {
+        SubtableStart = *PFieldList;
+
+        /* LPIT Subtable header */
+
+        Status = DtCompileTable (PFieldList, AcpiDmTableInfoLpitHdr,
+            &Subtable, TRUE);
+        if (ACPI_FAILURE (Status))
+        {
+            return (Status);
+        }
+
+        ParentTable = DtPeekSubtable ();
+        DtInsertSubtable (ParentTable, Subtable);
+        DtPushSubtable (Subtable);
+
+        LpitHeader = ACPI_CAST_PTR (ACPI_LPIT_HEADER, Subtable->Buffer);
+
+        switch (LpitHeader->Type)
+        {
+        case ACPI_LPIT_TYPE_NATIVE_CSTATE:
+
+            InfoTable = AcpiDmTableInfoLpit0;
+            break;
+
+        default:
+
+            DtFatal (ASL_MSG_UNKNOWN_SUBTABLE, SubtableStart, "LPIT");
+            return (AE_ERROR);
+        }
+
+        /* LPIT Subtable */
+
+        Status = DtCompileTable (PFieldList, InfoTable, &Subtable, TRUE);
+        if (ACPI_FAILURE (Status))
+        {
+            return (Status);
+        }
+
+        ParentTable = DtPeekSubtable ();
+        DtInsertSubtable (ParentTable, Subtable);
+        DtPopSubtable ();
+    }
+
+    return (AE_OK);
+}
+
+
+/******************************************************************************
+ *
+ * FUNCTION:    DtCompileMadt
+ *
+ * PARAMETERS:  List                - Current field list pointer
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Compile MADT.
+ *
+ *****************************************************************************/
+
+ACPI_STATUS
+DtCompileMadt (
+    void                    **List)
+{
+    ACPI_STATUS             Status;
+    DT_SUBTABLE             *Subtable;
+    DT_SUBTABLE             *ParentTable;
+    DT_FIELD                **PFieldList = (DT_FIELD **) List;
+    DT_FIELD                *SubtableStart;
+    ACPI_SUBTABLE_HEADER    *MadtHeader;
+    ACPI_DMTABLE_INFO       *InfoTable;
+
+
+    Status = DtCompileTable (PFieldList, AcpiDmTableInfoMadt,
+        &Subtable, TRUE);
+    if (ACPI_FAILURE (Status))
+    {
+        return (Status);
+    }
+
+    ParentTable = DtPeekSubtable ();
+    DtInsertSubtable (ParentTable, Subtable);
+
+    while (*PFieldList)
+    {
+        SubtableStart = *PFieldList;
+        Status = DtCompileTable (PFieldList, AcpiDmTableInfoMadtHdr,
+            &Subtable, TRUE);
+        if (ACPI_FAILURE (Status))
+        {
+            return (Status);
+        }
+
+        ParentTable = DtPeekSubtable ();
+        DtInsertSubtable (ParentTable, Subtable);
+        DtPushSubtable (Subtable);
+
+        MadtHeader = ACPI_CAST_PTR (ACPI_SUBTABLE_HEADER, Subtable->Buffer);
+
+        switch (MadtHeader->Type)
+        {
+        case ACPI_MADT_TYPE_LOCAL_APIC:
+
+            InfoTable = AcpiDmTableInfoMadt0;
+            break;
+
+        case ACPI_MADT_TYPE_IO_APIC:
+
+            InfoTable = AcpiDmTableInfoMadt1;
+            break;
+
+        case ACPI_MADT_TYPE_INTERRUPT_OVERRIDE:
+
+            InfoTable = AcpiDmTableInfoMadt2;
+            break;
+
+        case ACPI_MADT_TYPE_NMI_SOURCE:
+
+            InfoTable = AcpiDmTableInfoMadt3;
+            break;
+
+        case ACPI_MADT_TYPE_LOCAL_APIC_NMI:
+
+            InfoTable = AcpiDmTableInfoMadt4;
+            break;
+
+        case ACPI_MADT_TYPE_LOCAL_APIC_OVERRIDE:
+
+            InfoTable = AcpiDmTableInfoMadt5;
+            break;
+
+        case ACPI_MADT_TYPE_IO_SAPIC:
+
+            InfoTable = AcpiDmTableInfoMadt6;
+            break;
+
+        case ACPI_MADT_TYPE_LOCAL_SAPIC:
+
+            InfoTable = AcpiDmTableInfoMadt7;
+            break;
+
+        case ACPI_MADT_TYPE_INTERRUPT_SOURCE:
+
+            InfoTable = AcpiDmTableInfoMadt8;
+            break;
+
+        case ACPI_MADT_TYPE_LOCAL_X2APIC:
+
+            InfoTable = AcpiDmTableInfoMadt9;
+            break;
+
+        case ACPI_MADT_TYPE_LOCAL_X2APIC_NMI:
+
+            InfoTable = AcpiDmTableInfoMadt10;
+            break;
+
+        case ACPI_MADT_TYPE_GENERIC_INTERRUPT:
+
+            InfoTable = AcpiDmTableInfoMadt11;
+            break;
+
+        case ACPI_MADT_TYPE_GENERIC_DISTRIBUTOR:
+
+            InfoTable = AcpiDmTableInfoMadt12;
+            break;
+
+        case ACPI_MADT_TYPE_GENERIC_MSI_FRAME:
+
+            InfoTable = AcpiDmTableInfoMadt13;
+            break;
+
+        case ACPI_MADT_TYPE_GENERIC_REDISTRIBUTOR:
+
+            InfoTable = AcpiDmTableInfoMadt14;
+            break;
+
+        case ACPI_MADT_TYPE_GENERIC_TRANSLATOR:
+
+            InfoTable = AcpiDmTableInfoMadt15;
+            break;
+
+        default:
+
+            DtFatal (ASL_MSG_UNKNOWN_SUBTABLE, SubtableStart, "MADT");
+            return (AE_ERROR);
+        }
+
+        Status = DtCompileTable (PFieldList, InfoTable, &Subtable, TRUE);
+        if (ACPI_FAILURE (Status))
+        {
+            return (Status);
+        }
+
+        ParentTable = DtPeekSubtable ();
+        DtInsertSubtable (ParentTable, Subtable);
+        DtPopSubtable ();
+    }
+
+    return (AE_OK);
+}
+
+
+/******************************************************************************
+ *
+ * FUNCTION:    DtCompileMcfg
+ *
+ * PARAMETERS:  List                - Current field list pointer
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Compile MCFG.
+ *
+ *****************************************************************************/
+
+ACPI_STATUS
+DtCompileMcfg (
+    void                    **List)
+{
+    ACPI_STATUS             Status;
+
+
+    Status = DtCompileTwoSubtables (List,
+        AcpiDmTableInfoMcfg, AcpiDmTableInfoMcfg0);
+    return (Status);
+}
+
+
+/******************************************************************************
+ *
+ * FUNCTION:    DtCompileMpst
+ *
+ * PARAMETERS:  List                - Current field list pointer
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Compile MPST.
+ *
+ *****************************************************************************/
+
+ACPI_STATUS
+DtCompileMpst (
+    void                    **List)
+{
+    ACPI_STATUS             Status;
+    DT_SUBTABLE             *Subtable;
+    DT_SUBTABLE             *ParentTable;
+    DT_FIELD                **PFieldList = (DT_FIELD **) List;
+    ACPI_MPST_CHANNEL       *MpstChannelInfo;
+    ACPI_MPST_POWER_NODE    *MpstPowerNode;
+    ACPI_MPST_DATA_HDR      *MpstDataHeader;
+    UINT16                  SubtableCount;
+    UINT32                  PowerStateCount;
+    UINT32                  ComponentCount;
+
+
+    /* Main table */
+
+    Status = DtCompileTable (PFieldList, AcpiDmTableInfoMpst, &Subtable, TRUE);
+    if (ACPI_FAILURE (Status))
+    {
+        return (Status);
+    }
+
+    ParentTable = DtPeekSubtable ();
+    DtInsertSubtable (ParentTable, Subtable);
+    DtPushSubtable (Subtable);
+
+    MpstChannelInfo = ACPI_CAST_PTR (ACPI_MPST_CHANNEL, Subtable->Buffer);
+    SubtableCount = MpstChannelInfo->PowerNodeCount;
+
+    while (*PFieldList && SubtableCount)
+    {
+        /* Subtable: Memory Power Node(s) */
+
+        Status = DtCompileTable (PFieldList, AcpiDmTableInfoMpst0,
+            &Subtable, TRUE);
+        if (ACPI_FAILURE (Status))
+        {
+            return (Status);
+        }
+
+        ParentTable = DtPeekSubtable ();
+        DtInsertSubtable (ParentTable, Subtable);
+        DtPushSubtable (Subtable);
+
+        MpstPowerNode = ACPI_CAST_PTR (ACPI_MPST_POWER_NODE, Subtable->Buffer);
+        PowerStateCount = MpstPowerNode->NumPowerStates;
+        ComponentCount = MpstPowerNode->NumPhysicalComponents;
+
+        ParentTable = DtPeekSubtable ();
+
+        /* Sub-subtables - Memory Power State Structure(s) */
+
+        while (*PFieldList && PowerStateCount)
+        {
+            Status = DtCompileTable (PFieldList, AcpiDmTableInfoMpst0A,
+                &Subtable, TRUE);
+            if (ACPI_FAILURE (Status))
+            {
+                return (Status);
+            }
+
+            DtInsertSubtable (ParentTable, Subtable);
+            PowerStateCount--;
+        }
+
+        /* Sub-subtables - Physical Component ID Structure(s) */
+
+        while (*PFieldList && ComponentCount)
+        {
+            Status = DtCompileTable (PFieldList, AcpiDmTableInfoMpst0B,
+                &Subtable, TRUE);
+            if (ACPI_FAILURE (Status))
+            {
+                return (Status);
+            }
+
+            DtInsertSubtable (ParentTable, Subtable);
+            ComponentCount--;
+        }
+
+        SubtableCount--;
+        DtPopSubtable ();
+    }
+
+    /* Subtable: Count of Memory Power State Characteristic structures */
+
+    DtPopSubtable ();
+
+    Status = DtCompileTable (PFieldList, AcpiDmTableInfoMpst1, &Subtable, TRUE);
+    if (ACPI_FAILURE (Status))
+    {
+        return (Status);
+    }
+
+    ParentTable = DtPeekSubtable ();
+    DtInsertSubtable (ParentTable, Subtable);
+    DtPushSubtable (Subtable);
+
+    MpstDataHeader = ACPI_CAST_PTR (ACPI_MPST_DATA_HDR, Subtable->Buffer);
+    SubtableCount = MpstDataHeader->CharacteristicsCount;
+
+    ParentTable = DtPeekSubtable ();
+
+    /* Subtable: Memory Power State Characteristics structure(s) */
+
+    while (*PFieldList && SubtableCount)
+    {
+        Status = DtCompileTable (PFieldList, AcpiDmTableInfoMpst2,
+            &Subtable, TRUE);
+        if (ACPI_FAILURE (Status))
+        {
+            return (Status);
+        }
+
+        DtInsertSubtable (ParentTable, Subtable);
+        SubtableCount--;
+    }
+
+    DtPopSubtable ();
+    return (AE_OK);
+}
+
+
+/******************************************************************************
+ *
+ * FUNCTION:    DtCompileMsct
+ *
+ * PARAMETERS:  List                - Current field list pointer
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Compile MSCT.
+ *
+ *****************************************************************************/
+
+ACPI_STATUS
+DtCompileMsct (
+    void                    **List)
+{
+    ACPI_STATUS             Status;
+
+
+    Status = DtCompileTwoSubtables (List,
+        AcpiDmTableInfoMsct, AcpiDmTableInfoMsct0);
+    return (Status);
+}
+
+
+/******************************************************************************
+ *
+ * FUNCTION:    DtCompileMtmr
+ *
+ * PARAMETERS:  List                - Current field list pointer
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Compile MTMR.
+ *
+ *****************************************************************************/
+
+ACPI_STATUS
+DtCompileMtmr (
+    void                    **List)
+{
+    ACPI_STATUS             Status;
+
+
+    Status = DtCompileTwoSubtables (List,
+        AcpiDmTableInfoMtmr, AcpiDmTableInfoMtmr0);
+    return (Status);
+}
+
+
+/******************************************************************************
+ *
+ * FUNCTION:    DtCompileNfit
+ *
+ * PARAMETERS:  List                - Current field list pointer
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Compile NFIT.
+ *
+ *****************************************************************************/
+
+ACPI_STATUS
+DtCompileNfit (
+    void                    **List)
+{
+    ACPI_STATUS             Status;
+    DT_SUBTABLE             *Subtable;
+    DT_SUBTABLE             *ParentTable;
+    DT_FIELD                **PFieldList = (DT_FIELD **) List;
+    DT_FIELD                *SubtableStart;
+    ACPI_NFIT_HEADER        *NfitHeader;
+    ACPI_DMTABLE_INFO       *InfoTable;
+    UINT32                  Count;
+    ACPI_NFIT_INTERLEAVE    *Interleave = NULL;
+    ACPI_NFIT_FLUSH_ADDRESS *Hint = NULL;
+
+
+    /* Main table */
+
+    Status = DtCompileTable (PFieldList, AcpiDmTableInfoNfit,
+        &Subtable, TRUE);
+    if (ACPI_FAILURE (Status))
+    {
+        return (Status);
+    }
+
+    ParentTable = DtPeekSubtable ();
+    DtInsertSubtable (ParentTable, Subtable);
+    DtPushSubtable (Subtable);
+
+    /* Subtables */
+
+    while (*PFieldList)
+    {
+        SubtableStart = *PFieldList;
+        Status = DtCompileTable (PFieldList, AcpiDmTableInfoNfitHdr,
+            &Subtable, TRUE);
+        if (ACPI_FAILURE (Status))
+        {
+            return (Status);
+        }
+
+        ParentTable = DtPeekSubtable ();
+        DtInsertSubtable (ParentTable, Subtable);
+        DtPushSubtable (Subtable);
+
+        NfitHeader = ACPI_CAST_PTR (ACPI_NFIT_HEADER, Subtable->Buffer);
+
+        switch (NfitHeader->Type)
+        {
+        case ACPI_NFIT_TYPE_SYSTEM_ADDRESS:
+
+            InfoTable = AcpiDmTableInfoNfit0;
+            break;
+
+        case ACPI_NFIT_TYPE_MEMORY_MAP:
+
+            InfoTable = AcpiDmTableInfoNfit1;
+            break;
+
+        case ACPI_NFIT_TYPE_INTERLEAVE:
+
+            Interleave = ACPI_CAST_PTR (ACPI_NFIT_INTERLEAVE, Subtable->Buffer);
+            InfoTable = AcpiDmTableInfoNfit2;
+            break;
+
+        case ACPI_NFIT_TYPE_SMBIOS:
+
+            InfoTable = AcpiDmTableInfoNfit3;
+            break;
+
+        case ACPI_NFIT_TYPE_CONTROL_REGION:
+
+            InfoTable = AcpiDmTableInfoNfit4;
+            break;
+
+        case ACPI_NFIT_TYPE_DATA_REGION:
+
+            InfoTable = AcpiDmTableInfoNfit5;
+            break;
+
+        case ACPI_NFIT_TYPE_FLUSH_ADDRESS:
+
+            Hint = ACPI_CAST_PTR (ACPI_NFIT_FLUSH_ADDRESS, Subtable->Buffer);
+            InfoTable = AcpiDmTableInfoNfit6;
+            break;
+
+        default:
+
+            DtFatal (ASL_MSG_UNKNOWN_SUBTABLE, SubtableStart, "NFIT");
+            return (AE_ERROR);
+        }
+
+        Status = DtCompileTable (PFieldList, InfoTable, &Subtable, TRUE);
+        if (ACPI_FAILURE (Status))
+        {
+            return (Status);
+        }
+
+        ParentTable = DtPeekSubtable ();
+        DtInsertSubtable (ParentTable, Subtable);
+        DtPopSubtable ();
+
+        switch (NfitHeader->Type)
+        {
+        case ACPI_NFIT_TYPE_INTERLEAVE:
+
+            Count = 0;
+            DtPushSubtable (Subtable);
+            while (*PFieldList)
+            {
+                Status = DtCompileTable (PFieldList, AcpiDmTableInfoNfit2a,
+                    &Subtable, FALSE);
+                if (ACPI_FAILURE (Status))
+                {
+                    return (Status);
+                }
+
+                if (!Subtable)
+                {
+                    DtPopSubtable ();
+                    break;
+                }
+
+                ParentTable = DtPeekSubtable ();
+                DtInsertSubtable (ParentTable, Subtable);
+                Count++;
+            }
+
+            Interleave->LineCount = Count;
+            DtPopSubtable ();
+            break;
+
+        case ACPI_NFIT_TYPE_SMBIOS:
+
+            if (*PFieldList)
+            {
+                Status = DtCompileTable (PFieldList, AcpiDmTableInfoNfit3a,
+                    &Subtable, TRUE);
+                if (ACPI_FAILURE (Status))
+                {
+                    return (Status);
+                }
+
+                if (Subtable)
+                {
+                    DtInsertSubtable (ParentTable, Subtable);
+                }
+            }
+            break;
+
+        case ACPI_NFIT_TYPE_FLUSH_ADDRESS:
+
+            Count = 0;
+            DtPushSubtable (Subtable);
+            while (*PFieldList)
+            {
+                Status = DtCompileTable (PFieldList, AcpiDmTableInfoNfit6a,
+                    &Subtable, FALSE);
+                if (ACPI_FAILURE (Status))
+                {
+                    return (Status);
+                }
+
+                if (!Subtable)
+                {
+                    DtPopSubtable ();
+                    break;
+                }
+
+                ParentTable = DtPeekSubtable ();
+                DtInsertSubtable (ParentTable, Subtable);
+                Count++;
+            }
+
+            Hint->HintCount = (UINT16) Count;
+            DtPopSubtable ();
+            break;
+
+        default:
+            break;
+        }
+    }
+
+    return (AE_OK);
+}
+
+
+/******************************************************************************
+ *
+ * FUNCTION:    DtCompilePcct
+ *
+ * PARAMETERS:  List                - Current field list pointer
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Compile PCCT.
+ *
+ *****************************************************************************/
+
+ACPI_STATUS
+DtCompilePcct (
+    void                    **List)
+{
+    ACPI_STATUS             Status;
+    DT_SUBTABLE             *Subtable;
+    DT_SUBTABLE             *ParentTable;
+    DT_FIELD                **PFieldList = (DT_FIELD **) List;
+    DT_FIELD                *SubtableStart;
+    ACPI_SUBTABLE_HEADER    *PcctHeader;
+    ACPI_DMTABLE_INFO       *InfoTable;
+
+
+    /* Main table */
+
+    Status = DtCompileTable (PFieldList, AcpiDmTableInfoPcct,
+        &Subtable, TRUE);
+    if (ACPI_FAILURE (Status))
+    {
+        return (Status);
+    }
+
+    ParentTable = DtPeekSubtable ();
+    DtInsertSubtable (ParentTable, Subtable);
+
+    /* Subtables */
+
+    while (*PFieldList)
+    {
+        SubtableStart = *PFieldList;
+        Status = DtCompileTable (PFieldList, AcpiDmTableInfoPcctHdr,
+            &Subtable, TRUE);
+        if (ACPI_FAILURE (Status))
+        {
+            return (Status);
+        }
+
+        ParentTable = DtPeekSubtable ();
+        DtInsertSubtable (ParentTable, Subtable);
+        DtPushSubtable (Subtable);
+
+        PcctHeader = ACPI_CAST_PTR (ACPI_SUBTABLE_HEADER, Subtable->Buffer);
+
+        switch (PcctHeader->Type)
+        {
+        case ACPI_PCCT_TYPE_GENERIC_SUBSPACE:
+
+            InfoTable = AcpiDmTableInfoPcct0;
+            break;
+
+        case ACPI_PCCT_TYPE_HW_REDUCED_SUBSPACE:
+
+            InfoTable = AcpiDmTableInfoPcct1;
+            break;
+
+        case ACPI_PCCT_TYPE_HW_REDUCED_SUBSPACE_TYPE2:
+
+            InfoTable = AcpiDmTableInfoPcct2;
+            break;
+
+        default:
+
+            DtFatal (ASL_MSG_UNKNOWN_SUBTABLE, SubtableStart, "PCCT");
+            return (AE_ERROR);
+        }
+
+        Status = DtCompileTable (PFieldList, InfoTable, &Subtable, TRUE);
+        if (ACPI_FAILURE (Status))
+        {
+            return (Status);
+        }
+
+        ParentTable = DtPeekSubtable ();
+        DtInsertSubtable (ParentTable, Subtable);
+        DtPopSubtable ();
+    }
+
+    return (AE_OK);
+}
+
+
+/******************************************************************************
+ *
+ * FUNCTION:    DtCompilePmtt
+ *
+ * PARAMETERS:  List                - Current field list pointer
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Compile PMTT.
+ *
+ *****************************************************************************/
+
+ACPI_STATUS
+DtCompilePmtt (
+    void                    **List)
+{
+    ACPI_STATUS             Status;
+    DT_SUBTABLE             *Subtable;
+    DT_SUBTABLE             *ParentTable;
+    DT_FIELD                **PFieldList = (DT_FIELD **) List;
+    DT_FIELD                *SubtableStart;
+    ACPI_PMTT_HEADER        *PmttHeader;
+    ACPI_PMTT_CONTROLLER    *PmttController;
+    UINT16                  DomainCount;
+    UINT8                   PrevType = ACPI_PMTT_TYPE_SOCKET;
+
+
+    /* Main table */
+
+    Status = DtCompileTable (PFieldList, AcpiDmTableInfoPmtt, &Subtable, TRUE);
+    if (ACPI_FAILURE (Status))
+    {
+        return (Status);
+    }
+
+    ParentTable = DtPeekSubtable ();
+    DtInsertSubtable (ParentTable, Subtable);
+    DtPushSubtable (Subtable);
+
+    while (*PFieldList)
+    {
+        SubtableStart = *PFieldList;
+        Status = DtCompileTable (PFieldList, AcpiDmTableInfoPmttHdr,
+            &Subtable, TRUE);
+        if (ACPI_FAILURE (Status))
+        {
+            return (Status);
+        }
+
+        PmttHeader = ACPI_CAST_PTR (ACPI_PMTT_HEADER, Subtable->Buffer);
+        while (PrevType >= PmttHeader->Type)
+        {
+            DtPopSubtable ();
+
+            if (PrevType == ACPI_PMTT_TYPE_SOCKET)
+            {
+                break;
+            }
+
+            PrevType--;
+        }
+
+        PrevType = PmttHeader->Type;
+
+        ParentTable = DtPeekSubtable ();
+        DtInsertSubtable (ParentTable, Subtable);
+        DtPushSubtable (Subtable);
+
+        switch (PmttHeader->Type)
+        {
+        case ACPI_PMTT_TYPE_SOCKET:
+
+            /* Subtable: Socket Structure */
+
+            Status = DtCompileTable (PFieldList, AcpiDmTableInfoPmtt0,
+                &Subtable, TRUE);
+            if (ACPI_FAILURE (Status))
+            {
+                return (Status);
+            }
+
+            ParentTable = DtPeekSubtable ();
+            DtInsertSubtable (ParentTable, Subtable);
+            break;
+
+        case ACPI_PMTT_TYPE_CONTROLLER:
+
+            /* Subtable: Memory Controller Structure */
+
+            Status = DtCompileTable (PFieldList, AcpiDmTableInfoPmtt1,
+                &Subtable, TRUE);
+            if (ACPI_FAILURE (Status))
+            {
+                return (Status);
+            }
+
+            ParentTable = DtPeekSubtable ();
+            DtInsertSubtable (ParentTable, Subtable);
+
+            PmttController = ACPI_CAST_PTR (ACPI_PMTT_CONTROLLER,
+                (Subtable->Buffer - sizeof (ACPI_PMTT_HEADER)));
+            DomainCount = PmttController->DomainCount;
+
+            while (DomainCount)
+            {
+                Status = DtCompileTable (PFieldList, AcpiDmTableInfoPmtt1a,
+                    &Subtable, TRUE);
+                if (ACPI_FAILURE (Status))
+                {
+                    return (Status);
+                }
+
+                DtInsertSubtable (ParentTable, Subtable);
+                DomainCount--;
+            }
+            break;
+
+        case ACPI_PMTT_TYPE_DIMM:
+
+            /* Subtable: Physical Component Structure */
+
+            Status = DtCompileTable (PFieldList, AcpiDmTableInfoPmtt2,
+                &Subtable, TRUE);
+            if (ACPI_FAILURE (Status))
+            {
+                return (Status);
+            }
+
+            ParentTable = DtPeekSubtable ();
+            DtInsertSubtable (ParentTable, Subtable);
+            break;
+
+        default:
+
+            DtFatal (ASL_MSG_UNKNOWN_SUBTABLE, SubtableStart, "PMTT");
+            return (AE_ERROR);
+        }
+    }
+
+    return (Status);
+}
+
+
+/******************************************************************************
+ *
+ * FUNCTION:    DtCompileRsdt
+ *
+ * PARAMETERS:  List                - Current field list pointer
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Compile RSDT.
+ *
+ *****************************************************************************/
+
+ACPI_STATUS
+DtCompileRsdt (
+    void                    **List)
+{
+    DT_SUBTABLE             *Subtable;
+    DT_SUBTABLE             *ParentTable;
+    DT_FIELD                *FieldList = *(DT_FIELD **) List;
+    UINT32                  Address;
+
+
+    ParentTable = DtPeekSubtable ();
+
+    while (FieldList)
+    {
+        DtCompileInteger ((UINT8 *) &Address, FieldList, 4, DT_NON_ZERO);
+
+        DtCreateSubtable ((UINT8 *) &Address, 4, &Subtable);
+        DtInsertSubtable (ParentTable, Subtable);
+        FieldList = FieldList->Next;
+    }
+
+    return (AE_OK);
+}
+
+
+/******************************************************************************
+ *
+ * FUNCTION:    DtCompileS3pt
+ *
+ * PARAMETERS:  PFieldList          - Current field list pointer
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Compile S3PT (Pointed to by FPDT)
+ *
+ *****************************************************************************/
+
+ACPI_STATUS
+DtCompileS3pt (
+    DT_FIELD                **PFieldList)
+{
+    ACPI_STATUS             Status;
+    ACPI_FPDT_HEADER        *S3ptHeader;
+    DT_SUBTABLE             *Subtable;
+    DT_SUBTABLE             *ParentTable;
+    ACPI_DMTABLE_INFO       *InfoTable;
+    DT_FIELD                *SubtableStart;
+
+
+    Status = DtCompileTable (PFieldList, AcpiDmTableInfoS3pt,
+        &Gbl_RootTable, TRUE);
+    if (ACPI_FAILURE (Status))
+    {
+        return (Status);
+    }
+
+    DtPushSubtable (Gbl_RootTable);
+
+    while (*PFieldList)
+    {
+        SubtableStart = *PFieldList;
+        Status = DtCompileTable (PFieldList, AcpiDmTableInfoS3ptHdr,
+            &Subtable, TRUE);
+        if (ACPI_FAILURE (Status))
+        {
+            return (Status);
+        }
+
+        ParentTable = DtPeekSubtable ();
+        DtInsertSubtable (ParentTable, Subtable);
+        DtPushSubtable (Subtable);
+
+        S3ptHeader = ACPI_CAST_PTR (ACPI_FPDT_HEADER, Subtable->Buffer);
+
+        switch (S3ptHeader->Type)
+        {
+        case ACPI_S3PT_TYPE_RESUME:
+
+            InfoTable = AcpiDmTableInfoS3pt0;
+            break;
+
+        case ACPI_S3PT_TYPE_SUSPEND:
+
+            InfoTable = AcpiDmTableInfoS3pt1;
+            break;
+
+        default:
+
+            DtFatal (ASL_MSG_UNKNOWN_SUBTABLE, SubtableStart, "S3PT");
+            return (AE_ERROR);
+        }
+
+        Status = DtCompileTable (PFieldList, InfoTable, &Subtable, TRUE);
+        if (ACPI_FAILURE (Status))
+        {
+            return (Status);
+        }
+
+        ParentTable = DtPeekSubtable ();
+        DtInsertSubtable (ParentTable, Subtable);
+        DtPopSubtable ();
+    }
+
+    return (AE_OK);
+}
+
+
+/******************************************************************************
+ *
+ * FUNCTION:    DtCompileSlic
+ *
+ * PARAMETERS:  List                - Current field list pointer
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Compile SLIC.
+ *
+ *****************************************************************************/
+
+ACPI_STATUS
+DtCompileSlic (
+    void                    **List)
+{
+    ACPI_STATUS             Status;
+    DT_SUBTABLE             *Subtable;
+    DT_SUBTABLE             *ParentTable;
+    DT_FIELD                **PFieldList = (DT_FIELD **) List;
+
+
+    while (*PFieldList)
+    {
+        Status = DtCompileTable (PFieldList, AcpiDmTableInfoSlic,
+            &Subtable, TRUE);
+        if (ACPI_FAILURE (Status))
+        {
+            return (Status);
+        }
+
+        ParentTable = DtPeekSubtable ();
+        DtInsertSubtable (ParentTable, Subtable);
+        DtPushSubtable (Subtable);
+        DtPopSubtable ();
+    }
+
+    return (AE_OK);
+}
+
+
+/******************************************************************************
+ *
+ * FUNCTION:    DtCompileSlit
+ *
+ * PARAMETERS:  List                - Current field list pointer
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Compile SLIT.
+ *
+ *****************************************************************************/
+
+ACPI_STATUS
+DtCompileSlit (
+    void                    **List)
+{
+    ACPI_STATUS             Status;
+    DT_SUBTABLE             *Subtable;
+    DT_SUBTABLE             *ParentTable;
+    DT_FIELD                **PFieldList = (DT_FIELD **) List;
+    DT_FIELD                *FieldList;
+    UINT32                  Localities;
+    UINT8                   *LocalityBuffer;
+
+
+    Status = DtCompileTable (PFieldList, AcpiDmTableInfoSlit,
+        &Subtable, TRUE);
+    if (ACPI_FAILURE (Status))
+    {
+        return (Status);
+    }
+
+    ParentTable = DtPeekSubtable ();
+    DtInsertSubtable (ParentTable, Subtable);
+
+    Localities = *ACPI_CAST_PTR (UINT32, Subtable->Buffer);
+    LocalityBuffer = UtLocalCalloc (Localities);
+
+    /* Compile each locality buffer */
+
+    FieldList = *PFieldList;
+    while (FieldList)
+    {
+        DtCompileBuffer (LocalityBuffer,
+            FieldList->Value, FieldList, Localities);
+
+        DtCreateSubtable (LocalityBuffer, Localities, &Subtable);
+        DtInsertSubtable (ParentTable, Subtable);
+        FieldList = FieldList->Next;
+    }
+
+    ACPI_FREE (LocalityBuffer);
+    return (AE_OK);
+}
+
+
+/******************************************************************************
+ *
+ * FUNCTION:    DtCompileSrat
+ *
+ * PARAMETERS:  List                - Current field list pointer
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Compile SRAT.
+ *
+ *****************************************************************************/
+
+ACPI_STATUS
+DtCompileSrat (
+    void                    **List)
+{
+    ACPI_STATUS             Status;
+    DT_SUBTABLE             *Subtable;
+    DT_SUBTABLE             *ParentTable;
+    DT_FIELD                **PFieldList = (DT_FIELD **) List;
+    DT_FIELD                *SubtableStart;
+    ACPI_SUBTABLE_HEADER    *SratHeader;
+    ACPI_DMTABLE_INFO       *InfoTable;
+
+
+    Status = DtCompileTable (PFieldList, AcpiDmTableInfoSrat,
+        &Subtable, TRUE);
+    if (ACPI_FAILURE (Status))
+    {
+        return (Status);
+    }
+
+    ParentTable = DtPeekSubtable ();
+    DtInsertSubtable (ParentTable, Subtable);
+
+    while (*PFieldList)
+    {
+        SubtableStart = *PFieldList;
+        Status = DtCompileTable (PFieldList, AcpiDmTableInfoSratHdr,
+            &Subtable, TRUE);
+        if (ACPI_FAILURE (Status))
+        {
+            return (Status);
+        }
+
+        ParentTable = DtPeekSubtable ();
+        DtInsertSubtable (ParentTable, Subtable);
+        DtPushSubtable (Subtable);
+
+        SratHeader = ACPI_CAST_PTR (ACPI_SUBTABLE_HEADER, Subtable->Buffer);
+
+        switch (SratHeader->Type)
+        {
+        case ACPI_SRAT_TYPE_CPU_AFFINITY:
+
+            InfoTable = AcpiDmTableInfoSrat0;
+            break;
+
+        case ACPI_SRAT_TYPE_MEMORY_AFFINITY:
+
+            InfoTable = AcpiDmTableInfoSrat1;
+            break;
+
+        case ACPI_SRAT_TYPE_X2APIC_CPU_AFFINITY:
+
+            InfoTable = AcpiDmTableInfoSrat2;
+            break;
+
+        case ACPI_SRAT_TYPE_GICC_AFFINITY:
+
+            InfoTable = AcpiDmTableInfoSrat3;
+            break;
+
+        default:
+
+            DtFatal (ASL_MSG_UNKNOWN_SUBTABLE, SubtableStart, "SRAT");
+            return (AE_ERROR);
+        }
+
+        Status = DtCompileTable (PFieldList, InfoTable, &Subtable, TRUE);
+        if (ACPI_FAILURE (Status))
+        {
+            return (Status);
+        }
+
+        ParentTable = DtPeekSubtable ();
+        DtInsertSubtable (ParentTable, Subtable);
+        DtPopSubtable ();
+    }
+
+    return (AE_OK);
+}
+
+
+/******************************************************************************
+ *
+ * FUNCTION:    DtCompileStao
+ *
+ * PARAMETERS:  PFieldList          - Current field list pointer
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Compile STAO.
+ *
+ *****************************************************************************/
+
+ACPI_STATUS
+DtCompileStao (
+    void                    **List)
+{
+    DT_FIELD                **PFieldList = (DT_FIELD **) List;
+    DT_SUBTABLE             *Subtable;
+    DT_SUBTABLE             *ParentTable;
+    ACPI_STATUS             Status;
+
+
+    /* Compile the main table */
+
+    Status = DtCompileTable (PFieldList, AcpiDmTableInfoStao,
+        &Subtable, TRUE);
+    if (ACPI_FAILURE (Status))
+    {
+        return (Status);
+    }
+
+    ParentTable = DtPeekSubtable ();
+    DtInsertSubtable (ParentTable, Subtable);
+
+    /* Compile each ASCII namestring as a subtable */
+
+    while (*PFieldList)
+    {
+        Status = DtCompileTable (PFieldList, AcpiDmTableInfoStaoStr,
+            &Subtable, TRUE);
+        if (ACPI_FAILURE (Status))
+        {
+            return (Status);
+        }
+
+        ParentTable = DtPeekSubtable ();
+        DtInsertSubtable (ParentTable, Subtable);
+    }
+
+    return (AE_OK);
+}
+
+
+/******************************************************************************
+ *
+ * FUNCTION:    DtCompileTcpa
+ *
+ * PARAMETERS:  PFieldList          - Current field list pointer
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Compile TCPA.
+ *
+ *****************************************************************************/
+
+ACPI_STATUS
+DtCompileTcpa (
+    void                    **List)
+{
+    DT_FIELD                **PFieldList = (DT_FIELD **) List;
+    DT_SUBTABLE             *Subtable;
+    ACPI_TABLE_TCPA_HDR     *TcpaHeader;
+    DT_SUBTABLE             *ParentTable;
+    ACPI_STATUS             Status;
+
+
+    /* Compile the main table */
+
+    Status = DtCompileTable (PFieldList, AcpiDmTableInfoTcpaHdr,
+        &Subtable, TRUE);
+    if (ACPI_FAILURE (Status))
+    {
+        return (Status);
+    }
+
+    ParentTable = DtPeekSubtable ();
+    DtInsertSubtable (ParentTable, Subtable);
+
+    /*
+     * Examine the PlatformClass field to determine the table type.
+     * Either a client or server table. Only one.
+     */
+    TcpaHeader = ACPI_CAST_PTR (ACPI_TABLE_TCPA_HDR, ParentTable->Buffer);
+
+    switch (TcpaHeader->PlatformClass)
+    {
+    case ACPI_TCPA_CLIENT_TABLE:
+
+        Status = DtCompileTable (PFieldList, AcpiDmTableInfoTcpaClient,
+            &Subtable, TRUE);
+        break;
+
+    case ACPI_TCPA_SERVER_TABLE:
+
+        Status = DtCompileTable (PFieldList, AcpiDmTableInfoTcpaServer,
+            &Subtable, TRUE);
+        break;
+
+    default:
+
+        AcpiOsPrintf ("\n**** Unknown TCPA Platform Class 0x%X\n",
+            TcpaHeader->PlatformClass);
+        Status = AE_ERROR;
+        break;
+    }
+
+    ParentTable = DtPeekSubtable ();
+    DtInsertSubtable (ParentTable, Subtable);
+    return (Status);
+}
+
+
+/******************************************************************************
+ *
+ * FUNCTION:    DtGetGenericTableInfo
+ *
+ * PARAMETERS:  Name                - Generic type name
+ *
+ * RETURN:      Info entry
+ *
+ * DESCRIPTION: Obtain table info for a generic name entry
+ *
+ *****************************************************************************/
+
+ACPI_DMTABLE_INFO *
+DtGetGenericTableInfo (
+    char                    *Name)
+{
+    ACPI_DMTABLE_INFO       *Info;
+    UINT32                  i;
+
+
+    if (!Name)
+    {
+        return (NULL);
+    }
+
+    /* Search info table for name match */
+
+    for (i = 0; ; i++)
+    {
+        Info = AcpiDmTableInfoGeneric[i];
+        if (Info->Opcode == ACPI_DMT_EXIT)
+        {
+            Info = NULL;
+            break;
+        }
+
+        /* Use caseless compare for generic keywords */
+
+        if (!AcpiUtStricmp (Name, Info->Name))
+        {
+            break;
+        }
+    }
+
+    return (Info);
+}
+
+
+/******************************************************************************
+ *
+ * FUNCTION:    DtCompileUefi
+ *
+ * PARAMETERS:  List                - Current field list pointer
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Compile UEFI.
+ *
+ *****************************************************************************/
+
+ACPI_STATUS
+DtCompileUefi (
+    void                    **List)
+{
+    ACPI_STATUS             Status;
+    DT_SUBTABLE             *Subtable;
+    DT_SUBTABLE             *ParentTable;
+    DT_FIELD                **PFieldList = (DT_FIELD **) List;
+    UINT16                  *DataOffset;
+
+
+    /* Compile the predefined portion of the UEFI table */
+
+    Status = DtCompileTable (PFieldList, AcpiDmTableInfoUefi,
+        &Subtable, TRUE);
+    if (ACPI_FAILURE (Status))
+    {
+        return (Status);
+    }
+
+    DataOffset = (UINT16 *) (Subtable->Buffer + 16);
+    *DataOffset = sizeof (ACPI_TABLE_UEFI);
+
+    ParentTable = DtPeekSubtable ();
+    DtInsertSubtable (ParentTable, Subtable);
+
+    /*
+     * Compile the "generic" portion of the UEFI table. This
+     * part of the table is not predefined and any of the generic
+     * operators may be used.
+     */
+    DtCompileGeneric ((void **) PFieldList, NULL, NULL);
+    return (AE_OK);
+}
+
+
+/******************************************************************************
+ *
+ * FUNCTION:    DtCompileVrtc
+ *
+ * PARAMETERS:  List                - Current field list pointer
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Compile VRTC.
+ *
+ *****************************************************************************/
+
+ACPI_STATUS
+DtCompileVrtc (
+    void                    **List)
+{
+    ACPI_STATUS             Status;
+
+
+    Status = DtCompileTwoSubtables (List,
+        AcpiDmTableInfoVrtc, AcpiDmTableInfoVrtc0);
+    return (Status);
+}
+
+
+/******************************************************************************
+ *
+ * FUNCTION:    DtCompileWdat
+ *
+ * PARAMETERS:  List                - Current field list pointer
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Compile WDAT.
+ *
+ *****************************************************************************/
+
+ACPI_STATUS
+DtCompileWdat (
+    void                    **List)
+{
+    ACPI_STATUS             Status;
+
+
+    Status = DtCompileTwoSubtables (List,
+        AcpiDmTableInfoWdat, AcpiDmTableInfoWdat0);
+    return (Status);
+}
+
+
+/******************************************************************************
+ *
+ * FUNCTION:    DtCompileWpbt
+ *
+ * PARAMETERS:  List                - Current field list pointer
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Compile WPBT.
+ *
+ *****************************************************************************/
+
+ACPI_STATUS
+DtCompileWpbt (
+    void                    **List)
+{
+    DT_FIELD                **PFieldList = (DT_FIELD **) List;
+    DT_SUBTABLE             *Subtable;
+    DT_SUBTABLE             *ParentTable;
+    ACPI_TABLE_WPBT         *Table;
+    ACPI_STATUS             Status;
+    UINT16                  Length;
+
+
+    /* Compile the main table */
+
+    Status = DtCompileTable (PFieldList, AcpiDmTableInfoWpbt,
+        &Subtable, TRUE);
+    if (ACPI_FAILURE (Status))
+    {
+        return (Status);
+    }
+
+    ParentTable = DtPeekSubtable ();
+    DtInsertSubtable (ParentTable, Subtable);
+
+    /* Compile the argument list subtable */
+
+    Status = DtCompileTable (PFieldList, AcpiDmTableInfoWpbt0,
+        &Subtable, TRUE);
+    if (ACPI_FAILURE (Status))
+    {
+        return (Status);
+    }
+
+    /* Extract the length of the Arguments buffer, insert into main table */
+
+    Length = (UINT16) Subtable->TotalLength;
+    Table = ACPI_CAST_PTR (ACPI_TABLE_WPBT, ParentTable->Buffer);
+    Table->ArgumentsLength = Length;
+
+    ParentTable = DtPeekSubtable ();
+    DtInsertSubtable (ParentTable, Subtable);
+    return (AE_OK);
+}
+
+
+/******************************************************************************
+ *
+ * FUNCTION:    DtCompileXsdt
+ *
+ * PARAMETERS:  List                - Current field list pointer
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Compile XSDT.
+ *
+ *****************************************************************************/
+
+ACPI_STATUS
+DtCompileXsdt (
+    void                    **List)
+{
+    DT_SUBTABLE             *Subtable;
+    DT_SUBTABLE             *ParentTable;
+    DT_FIELD                *FieldList = *(DT_FIELD **) List;
+    UINT64                  Address;
+
+
+    ParentTable = DtPeekSubtable ();
+
+    while (FieldList)
+    {
+        DtCompileInteger ((UINT8 *) &Address, FieldList, 8, DT_NON_ZERO);
+
+        DtCreateSubtable ((UINT8 *) &Address, 8, &Subtable);
+        DtInsertSubtable (ParentTable, Subtable);
+        FieldList = FieldList->Next;
+    }
+
+    return (AE_OK);
+}
+
+
+/******************************************************************************
+ *
+ * FUNCTION:    DtCompileGeneric
+ *
+ * PARAMETERS:  List                - Current field list pointer
+ *              Name                - Field name to end generic compiling
+ *              Length              - Compiled table length to return
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Compile generic unknown table.
+ *
+ *****************************************************************************/
+
+ACPI_STATUS
+DtCompileGeneric (
+    void                    **List,
+    char                    *Name,
+    UINT32                  *Length)
+{
+    ACPI_STATUS             Status;
+    DT_SUBTABLE             *Subtable;
+    DT_SUBTABLE             *ParentTable;
+    DT_FIELD                **PFieldList = (DT_FIELD **) List;
+    ACPI_DMTABLE_INFO       *Info;
+
+
+    ParentTable = DtPeekSubtable ();
+
+    /*
+     * Compile the "generic" portion of the table. This
+     * part of the table is not predefined and any of the generic
+     * operators may be used.
+     */
+
+    /* Find any and all labels in the entire generic portion */
+
+    DtDetectAllLabels (*PFieldList);
+
+    /* Now we can actually compile the parse tree */
+
+    if (Length && *Length)
+    {
+        *Length = 0;
+    }
+    while (*PFieldList)
+    {
+        if (Name && !strcmp ((*PFieldList)->Name, Name))
+        {
+            break;
+        }
+
+        Info = DtGetGenericTableInfo ((*PFieldList)->Name);
+        if (!Info)
+        {
+            sprintf (MsgBuffer, "Generic data type \"%s\" not found",
+                (*PFieldList)->Name);
+            DtNameError (ASL_ERROR, ASL_MSG_INVALID_FIELD_NAME,
+                (*PFieldList), MsgBuffer);
+
+            *PFieldList = (*PFieldList)->Next;
+            continue;
+        }
+
+        Status = DtCompileTable (PFieldList, Info,
+            &Subtable, TRUE);
+        if (ACPI_SUCCESS (Status))
+        {
+            DtInsertSubtable (ParentTable, Subtable);
+            if (Length)
+            {
+                *Length += Subtable->Length;
+            }
+        }
+        else
+        {
+            *PFieldList = (*PFieldList)->Next;
+
+            if (Status == AE_NOT_FOUND)
+            {
+                sprintf (MsgBuffer, "Generic data type \"%s\" not found",
+                    (*PFieldList)->Name);
+                DtNameError (ASL_ERROR, ASL_MSG_INVALID_FIELD_NAME,
+                    (*PFieldList), MsgBuffer);
+            }
+        }
+    }
+
+    return (AE_OK);
+}
diff --git a/usr/src/cmd/acpi/iasl/dttemplate.c b/usr/src/cmd/acpi/iasl/dttemplate.c
new file mode 100644
index 0000000000..0d286c0e15
--- /dev/null
+++ b/usr/src/cmd/acpi/iasl/dttemplate.c
@@ -0,0 +1,593 @@
+/******************************************************************************
+ *
+ * Module Name: dttemplate - ACPI table template generation
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2016, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include "aslcompiler.h"
+#include "acapps.h"
+#include "dtcompiler.h"
+#include "dttemplate.h" /* Contains the hex ACPI table templates */
+
+#define _COMPONENT          DT_COMPILER
+        ACPI_MODULE_NAME    ("dttemplate")
+
+
+/* Local prototypes */
+
+static BOOLEAN
+AcpiUtIsSpecialTable (
+    char                    *Signature);
+
+static ACPI_STATUS
+DtCreateOneTemplateFile (
+    char                    *Signature,
+    UINT32                  TableCount);
+
+static ACPI_STATUS
+DtCreateOneTemplate (
+    char                    *Signature,
+    UINT32                  TableCount,
+    const ACPI_DMTABLE_DATA *TableData);
+
+static ACPI_STATUS
+DtCreateAllTemplates (
+    void);
+
+static int
+DtEmitDefinitionBlock (
+    FILE                    *File,
+    char                    *Filename,
+    char                    *Signature,
+    UINT32                  Instance);
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiUtIsSpecialTable
+ *
+ * PARAMETERS:  Signature           - ACPI table signature
+ *
+ * RETURN:      TRUE if signature is a special ACPI table
+ *
+ * DESCRIPTION: Check for valid ACPI tables that are not in the main ACPI
+ *              table data structure (AcpiDmTableData).
+ *
+ ******************************************************************************/
+
+static BOOLEAN
+AcpiUtIsSpecialTable (
+    char                    *Signature)
+{
+
+    if (ACPI_COMPARE_NAME (Signature, ACPI_SIG_DSDT) ||
+        ACPI_COMPARE_NAME (Signature, ACPI_SIG_OSDT) ||
+        ACPI_COMPARE_NAME (Signature, ACPI_SIG_SSDT) ||
+        ACPI_COMPARE_NAME (Signature, ACPI_SIG_FACS) ||
+        ACPI_COMPARE_NAME (Signature, ACPI_RSDP_NAME))
+    {
+        return (TRUE);
+    }
+
+    return (FALSE);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    DtCreateTemplates
+ *
+ * PARAMETERS:  argv                - Standard command line arguments
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Create one or more template files.
+ *
+ ******************************************************************************/
+
+ACPI_STATUS
+DtCreateTemplates (
+    char                    **argv)
+{
+    char                    *Signature;
+    char                    *End;
+    unsigned long           TableCount;
+    ACPI_STATUS             Status = AE_OK;
+
+
+    AslInitializeGlobals ();
+
+    Status = AdInitialize ();
+    if (ACPI_FAILURE (Status))
+    {
+        return (Status);
+    }
+
+    /*
+     * Special cases for DSDT, ALL, and '*'
+     */
+
+    /* Default (no signature option) is DSDT */
+
+    if (AcpiGbl_Optind < 3)
+    {
+        Status = DtCreateOneTemplateFile (ACPI_SIG_DSDT, 0);
+        goto Exit;
+    }
+
+    AcpiGbl_Optind--;
+    Signature = argv[AcpiGbl_Optind];
+    AcpiUtStrupr (Signature);
+
+    /*
+     * Multiple SSDT support (-T <ssdt count>)
+     */
+    TableCount = strtoul (Signature, &End, 0);
+    if (Signature != End)
+    {
+        /* The count is used for table ID and method name - max is 254(+1) */
+
+        if (TableCount > 254)
+        {
+            fprintf (stderr, "%u SSDTs requested, maximum is 254\n",
+                (unsigned int) TableCount);
+
+            Status = AE_LIMIT;
+            goto Exit;
+        }
+
+        Status = DtCreateOneTemplateFile (ACPI_SIG_DSDT, TableCount);
+        goto Exit;
+    }
+
+    if (!strcmp (Signature, "ALL"))
+    {
+        /* Create all available/known templates */
+
+        Status = DtCreateAllTemplates ();
+        goto Exit;
+    }
+
+    /*
+     * Normal case: Create template for each signature
+     */
+    while (argv[AcpiGbl_Optind])
+    {
+        Signature = argv[AcpiGbl_Optind];
+        AcpiUtStrupr (Signature);
+
+        Status = DtCreateOneTemplateFile (Signature, 0);
+        if (ACPI_FAILURE (Status))
+        {
+            goto Exit;
+        }
+
+        AcpiGbl_Optind++;
+    }
+
+
+Exit:
+    /* Shutdown ACPICA subsystem */
+
+    (void) AcpiTerminate ();
+    CmDeleteCaches ();
+    return (Status);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    DtCreateOneTemplateFile
+ *
+ * PARAMETERS:  Signature           - ACPI table signature
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Create one template file of the requested signature.
+ *
+ ******************************************************************************/
+
+static ACPI_STATUS
+DtCreateOneTemplateFile (
+    char                    *Signature,
+    UINT32                  TableCount)
+{
+    const ACPI_DMTABLE_DATA *TableData;
+    ACPI_STATUS             Status;
+
+
+    /*
+     * Validate signature and get the template data:
+     *  1) Signature must be 4 characters
+     *  2) Signature must be a recognized ACPI table
+     *  3) There must be a template associated with the signature
+     */
+    if (strlen (Signature) != ACPI_NAME_SIZE)
+    {
+        fprintf (stderr,
+            "%s: Invalid ACPI table signature "
+            "(length must be 4 characters)\n", Signature);
+        return (AE_ERROR);
+    }
+
+    /*
+     * Some slack for the two strange tables whose name is different than
+     * their signatures: MADT->APIC and FADT->FACP.
+     */
+    if (!strcmp (Signature, "MADT"))
+    {
+        Signature = "APIC";
+    }
+    else if (!strcmp (Signature, "FADT"))
+    {
+        Signature = "FACP";
+    }
+
+    /* TableData will point to the template */
+
+    TableData = AcpiDmGetTableData (Signature);
+    if (TableData)
+    {
+        if (!TableData->Template)
+        {
+            fprintf (stderr, "%4.4s: No template available\n", Signature);
+            return (AE_ERROR);
+        }
+    }
+    else if (!AcpiUtIsSpecialTable (Signature))
+    {
+        fprintf (stderr,
+            "%4.4s: Unrecognized ACPI table signature\n", Signature);
+        return (AE_ERROR);
+    }
+
+    Status = DtCreateOneTemplate (Signature, TableCount, TableData);
+    return (Status);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    DtCreateAllTemplates
+ *
+ * PARAMETERS:  None
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Create all currently defined template files
+ *
+ ******************************************************************************/
+
+static ACPI_STATUS
+DtCreateAllTemplates (
+    void)
+{
+    const ACPI_DMTABLE_DATA *TableData;
+    ACPI_STATUS             Status;
+
+
+    fprintf (stderr, "Creating all supported Template files\n");
+
+    /* Walk entire ACPI table data structure */
+
+    for (TableData = AcpiDmTableData; TableData->Signature; TableData++)
+    {
+        /* If table has a template, create the template file */
+
+        if (TableData->Template)
+        {
+            Status = DtCreateOneTemplate (TableData->Signature,
+                0, TableData);
+            if (ACPI_FAILURE (Status))
+            {
+                return (Status);
+            }
+        }
+    }
+
+    /*
+     * Create the special ACPI tables:
+     * 1) DSDT/SSDT are AML tables, not data tables
+     * 2) FACS and RSDP have non-standard headers
+     */
+    Status = DtCreateOneTemplate (ACPI_SIG_DSDT, 0, NULL);
+    if (ACPI_FAILURE (Status))
+    {
+        return (Status);
+    }
+
+    Status = DtCreateOneTemplate (ACPI_SIG_SSDT, 0, NULL);
+    if (ACPI_FAILURE (Status))
+    {
+        return (Status);
+    }
+
+    Status = DtCreateOneTemplate (ACPI_SIG_OSDT, 0, NULL);
+    if (ACPI_FAILURE (Status))
+    {
+        return (Status);
+    }
+
+    Status = DtCreateOneTemplate (ACPI_SIG_FACS, 0, NULL);
+    if (ACPI_FAILURE (Status))
+    {
+        return (Status);
+    }
+
+    Status = DtCreateOneTemplate (ACPI_RSDP_NAME, 0, NULL);
+    if (ACPI_FAILURE (Status))
+    {
+        return (Status);
+    }
+
+    return (AE_OK);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    DtCreateOneTemplate
+ *
+ * PARAMETERS:  Signature           - ACPI signature, NULL terminated.
+ *              TableCount          - Used for SSDTs in same file as DSDT
+ *              TableData           - Entry in ACPI table data structure.
+ *                                    NULL if a special ACPI table.
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Create one template source file for the requested ACPI table.
+ *
+ ******************************************************************************/
+
+static ACPI_STATUS
+DtCreateOneTemplate (
+    char                    *Signature,
+    UINT32                  TableCount,
+    const ACPI_DMTABLE_DATA  *TableData)
+{
+    char                    *DisasmFilename;
+    FILE                    *File;
+    ACPI_STATUS             Status = AE_OK;
+    int                     Actual;
+    UINT32                  i;
+
+
+    /* New file will have a .asl suffix */
+
+    DisasmFilename = FlGenerateFilename (
+        Signature, FILE_SUFFIX_ASL_CODE);
+    if (!DisasmFilename)
+    {
+        fprintf (stderr, "Could not generate output filename\n");
+        return (AE_ERROR);
+    }
+
+    AcpiUtStrlwr (DisasmFilename);
+    if (!UtQueryForOverwrite (DisasmFilename))
+    {
+        return (AE_ERROR);
+    }
+
+    File = fopen (DisasmFilename, "w+");
+    if (!File)
+    {
+        fprintf (stderr, "Could not open output file %s\n",
+            DisasmFilename);
+        return (AE_ERROR);
+    }
+
+    /* Emit the common file header */
+
+    AcpiOsRedirectOutput (File);
+
+    AcpiOsPrintf ("/*\n");
+    AcpiOsPrintf (ACPI_COMMON_HEADER ("iASL Compiler/Disassembler", " * "));
+
+    if (TableCount == 0)
+    {
+        AcpiOsPrintf (" * Template for [%4.4s] ACPI Table",
+            Signature);
+    }
+    else
+    {
+        AcpiOsPrintf (" * Template for [%4.4s] and %u [SSDT] ACPI Tables",
+            Signature, TableCount);
+    }
+
+    /* Dump the actual ACPI table */
+
+    if (TableData)
+    {
+        /* Normal case, tables that appear in AcpiDmTableData */
+
+        AcpiOsPrintf (" (static data table)\n");
+
+        if (Gbl_VerboseTemplates)
+        {
+            AcpiOsPrintf (" * Format: [HexOffset DecimalOffset ByteLength]"
+                "  FieldName : HexFieldValue\n */\n\n");
+        }
+        else
+        {
+            AcpiOsPrintf (" * Format: [ByteLength]"
+                "  FieldName : HexFieldValue\n */\n");
+        }
+
+        AcpiDmDumpDataTable (ACPI_CAST_PTR (ACPI_TABLE_HEADER,
+            TableData->Template));
+    }
+    else
+    {
+        /* Special ACPI tables - DSDT, SSDT, OSDT, FACS, RSDP */
+
+        AcpiOsPrintf (" (AML byte code table)\n");
+        AcpiOsPrintf (" */\n");
+
+        if (ACPI_COMPARE_NAME (Signature, ACPI_SIG_DSDT))
+        {
+            Actual = DtEmitDefinitionBlock (
+                File, DisasmFilename, ACPI_SIG_DSDT, 1);
+            if (Actual < 0)
+            {
+                Status = AE_ERROR;
+                goto Cleanup;
+            }
+
+            /* Emit any requested SSDTs into the same file */
+
+            for (i = 1; i <= TableCount; i++)
+            {
+                Actual = DtEmitDefinitionBlock (
+                    File, DisasmFilename, ACPI_SIG_SSDT, i + 1);
+                if (Actual < 0)
+                {
+                    Status = AE_ERROR;
+                    goto Cleanup;
+                }
+            }
+        }
+        else if (ACPI_COMPARE_NAME (Signature, ACPI_SIG_SSDT))
+        {
+            Actual = DtEmitDefinitionBlock (
+                File, DisasmFilename, ACPI_SIG_SSDT, 1);
+            if (Actual < 0)
+            {
+                Status = AE_ERROR;
+                goto Cleanup;
+            }
+        }
+        else if (ACPI_COMPARE_NAME (Signature, ACPI_SIG_OSDT))
+        {
+            Actual = DtEmitDefinitionBlock (
+                File, DisasmFilename, ACPI_SIG_OSDT, 1);
+            if (Actual < 0)
+            {
+                Status = AE_ERROR;
+                goto Cleanup;
+            }
+        }
+        else if (ACPI_COMPARE_NAME (Signature, ACPI_SIG_FACS))
+        {
+            AcpiDmDumpDataTable (ACPI_CAST_PTR (ACPI_TABLE_HEADER,
+                TemplateFacs));
+        }
+        else if (ACPI_COMPARE_NAME (Signature, ACPI_RSDP_NAME))
+        {
+            AcpiDmDumpDataTable (ACPI_CAST_PTR (ACPI_TABLE_HEADER,
+                TemplateRsdp));
+        }
+        else
+        {
+            fprintf (stderr,
+                "%4.4s, Unrecognized ACPI table signature\n", Signature);
+            Status = AE_ERROR;
+            goto Cleanup;
+        }
+    }
+
+    if (TableCount == 0)
+    {
+        fprintf (stderr,
+            "Created ACPI table template for [%4.4s], "
+            "written to \"%s\"\n",
+            Signature, DisasmFilename);
+    }
+    else
+    {
+        fprintf (stderr,
+            "Created ACPI table templates for [%4.4s] "
+            "and %u [SSDT], written to \"%s\"\n",
+            Signature, TableCount, DisasmFilename);
+    }
+
+Cleanup:
+    fclose (File);
+    AcpiOsRedirectOutput (stdout);
+    return (Status);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    DtEmitDefinitionBlock
+ *
+ * PARAMETERS:  File                - An open file for the block
+ *              Filename            - Filename for same, for error msg(s)
+ *              Signature           - ACPI signature for the block
+ *              Instance            - Used for multiple SSDTs in the same file
+ *
+ * RETURN:      Status from fprintf
+ *
+ * DESCRIPTION: Emit the raw ASL for a complete Definition Block (DSDT or SSDT)
+ *
+ * Note: The AMLFileName parameter for DefinitionBlock is left as a NULL
+ * string. This allows the compiler to create the output AML filename from
+ * the input filename.
+ *
+ ******************************************************************************/
+
+static int
+DtEmitDefinitionBlock (
+    FILE                    *File,
+    char                    *Filename,
+    char                    *Signature,
+    UINT32                  Instance)
+{
+    int                     Status;
+
+
+    Status = fprintf (File,
+        "DefinitionBlock (\"\", \"%4.4s\", 2, \"Intel\", \"_%4.4s_%.2X\", 0x00000001)\n"
+        "{\n"
+        "    Method (%2.2s%.2X)\n"
+        "    {\n"
+        "    }\n"
+        "}\n\n",
+        Signature, Signature, Instance, Signature, Instance);
+
+    if (Status < 0)
+    {
+        fprintf (stderr,
+            "Could not write %4.4s to output file %s\n",
+            Signature, Filename);
+    }
+
+    return (Status);
+}
diff --git a/usr/src/cmd/acpi/iasl/dttemplate.h b/usr/src/cmd/acpi/iasl/dttemplate.h
new file mode 100644
index 0000000000..23ef051767
--- /dev/null
+++ b/usr/src/cmd/acpi/iasl/dttemplate.h
@@ -0,0 +1,1287 @@
+/******************************************************************************
+ *
+ * Module Name: dttemplate.h - ACPI table template definitions
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2016, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#ifndef __DTTEMPLATE_H
+#define __DTTEMPLATE_H
+
+
+/* Templates for ACPI data tables */
+
+const unsigned char TemplateAsf[] =
+{
+    0x41,0x53,0x46,0x21,0x72,0x00,0x00,0x00,  /* 00000000    "ASF!r..." */
+    0x10,0x0B,0x49,0x4E,0x54,0x45,0x4C,0x20,  /* 00000008    "..INTEL " */
+    0x54,0x45,0x4D,0x50,0x4C,0x41,0x54,0x45,  /* 00000010    "TEMPLATE" */
+    0x01,0x00,0x00,0x00,0x49,0x4E,0x54,0x4C,  /* 00000018    "....INTL" */
+    0x28,0x05,0x10,0x20,0x00,0x00,0x10,0x00,  /* 00000020    "(.. ...." */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000028    "........" */
+    0x00,0x00,0x00,0x00,0x01,0x00,0x14,0x00,  /* 00000030    "........" */
+    0x00,0x00,0x01,0x0C,0x00,0x00,0x00,0x00,  /* 00000038    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000040    "........" */
+    0x02,0x00,0x0C,0x00,0x01,0x04,0x00,0x00,  /* 00000048    "........" */
+    0x00,0x00,0x00,0x00,0x03,0x00,0x17,0x00,  /* 00000050    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000058    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000060    "........" */
+    0x00,0x00,0x00,0x84,0x00,0x07,0x00,0x00,  /* 00000068    "........" */
+    0x01,0x00                                 /* 00000070    ".."       */
+};
+
+const unsigned char TemplateBgrt[] =
+{
+    0x42,0x47,0x52,0x54,0x38,0x00,0x00,0x00,  /* 00000000    "BGRT8..." */
+    0x01,0x0D,0x49,0x4E,0x54,0x45,0x4C,0x20,  /* 00000008    "..INTEL " */
+    0x54,0x45,0x4D,0x50,0x4C,0x41,0x54,0x45,  /* 00000010    "TEMPLATE" */
+    0x01,0x00,0x00,0x00,0x49,0x4E,0x54,0x4C,  /* 00000018    "....INTL" */
+    0x23,0x06,0x11,0x20,0x01,0x00,0x00,0x00,  /* 00000020    "#.. ...." */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000028    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00   /* 00000030    "........" */
+};
+
+const unsigned char TemplateBert[] =
+{
+    0x42,0x45,0x52,0x54,0x30,0x00,0x00,0x00,  /* 00000000    "BERT0..." */
+    0x01,0x15,0x49,0x4E,0x54,0x45,0x4C,0x20,  /* 00000008    "..INTEL " */
+    0x54,0x45,0x4D,0x50,0x4C,0x41,0x54,0x45,  /* 00000010    "TEMPLATE" */
+    0x01,0x00,0x00,0x00,0x49,0x4E,0x54,0x4C,  /* 00000018    "....INTL" */
+    0x28,0x05,0x10,0x20,0x00,0x00,0x00,0x00,  /* 00000020    "(.. ...." */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00   /* 00000028    "........" */
+};
+
+const unsigned char TemplateBoot[] =
+{
+    0x42,0x4F,0x4F,0x54,0x28,0x00,0x00,0x00,  /* 00000000    "BOOT(..." */
+    0x01,0x0D,0x49,0x4E,0x54,0x45,0x4C,0x20,  /* 00000008    "..INTEL " */
+    0x54,0x45,0x4D,0x50,0x4C,0x41,0x54,0x45,  /* 00000010    "TEMPLATE" */
+    0x00,0x00,0x04,0x06,0x49,0x4E,0x54,0x4C,  /* 00000018    "....INTL" */
+    0x28,0x05,0x10,0x20,0x00,0x00,0x00,0x00   /* 00000020    "(.. ...." */
+};
+
+const unsigned char TemplateCpep[] =
+{
+    0x43,0x50,0x45,0x50,0x34,0x00,0x00,0x00,  /* 00000000    "CPEP4..." */
+    0x01,0x0F,0x49,0x4E,0x54,0x45,0x4C,0x20,  /* 00000008    "..INTEL " */
+    0x54,0x45,0x4D,0x50,0x4C,0x41,0x54,0x45,  /* 00000010    "TEMPLATE" */
+    0x00,0x00,0x00,0x00,0x49,0x4E,0x54,0x4C,  /* 00000018    "....INTL" */
+    0x28,0x05,0x10,0x20,0x00,0x00,0x00,0x00,  /* 00000020    "(.. ...." */
+    0x00,0x00,0x00,0x00,0x00,0x08,0x00,0x00,  /* 00000028    "........" */
+    0x00,0x00,0x00,0x00                       /* 00000030    "...."     */
+};
+
+const unsigned char TemplateCsrt[] =
+{
+    0x43,0x53,0x52,0x54,0x4C,0x01,0x00,0x00,  /* 00000000    "CSRTL..." */
+    0x01,0x0D,0x49,0x4E,0x54,0x45,0x4C,0x20,  /* 00000008    "..INTEL " */
+    0x54,0x45,0x4D,0x50,0x4C,0x41,0x54,0x45,  /* 00000010    "TEMPLATE" */
+    0x01,0x00,0x00,0x00,0x49,0x4E,0x54,0x4C,  /* 00000018    "....INTL" */
+    0x14,0x11,0x12,0x20,0x88,0x00,0x00,0x00,  /* 00000020    "... ...." */
+    0x49,0x4E,0x54,0x4C,0x00,0x00,0x00,0x00,  /* 00000028    "INTL...." */
+    0x60,0x9C,0x00,0x00,0x02,0x00,0x00,0x00,  /* 00000030    "`......." */
+    0x1C,0x00,0x00,0x00,0x01,0x00,0x00,0x00,  /* 00000038    "........" */
+    0x00,0x00,0xA0,0xB3,0x00,0x00,0x00,0x00,  /* 00000040    "........" */
+    0x2A,0x00,0x00,0x00,0x02,0x00,0x06,0x20,  /* 00000048    "*...... " */
+    0x00,0x00,0x10,0x00,0xFF,0x0F,0x00,0x00,  /* 00000050    "........" */
+    0x0C,0x00,0x00,0x00,0x03,0x00,0x01,0x00,  /* 00000058    "........" */
+    0x53,0x50,0x49,0x20,0x0C,0x00,0x00,0x00,  /* 00000060    "SPI ...." */
+    0x03,0x00,0x00,0x00,0x43,0x48,0x41,0x30,  /* 00000068    "....CHA0" */
+    0x0C,0x00,0x00,0x00,0x03,0x00,0x00,0x00,  /* 00000070    "........" */
+    0x43,0x48,0x41,0x31,0x0C,0x00,0x00,0x00,  /* 00000078    "CHA1...." */
+    0x03,0x00,0x00,0x00,0x43,0x48,0x41,0x32,  /* 00000080    "....CHA2" */
+    0x0C,0x00,0x00,0x00,0x03,0x00,0x00,0x00,  /* 00000088    "........" */
+    0x43,0x48,0x41,0x33,0x0C,0x00,0x00,0x00,  /* 00000090    "CHA3...." */
+    0x03,0x00,0x00,0x00,0x43,0x48,0x41,0x34,  /* 00000098    "....CHA4" */
+    0x0C,0x00,0x00,0x00,0x03,0x00,0x00,0x00,  /* 000000A0    "........" */
+    0x43,0x48,0x41,0x35,0xA0,0x00,0x00,0x00,  /* 000000A8    "CHA5...." */
+    0x49,0x4E,0x54,0x4C,0x00,0x00,0x00,0x00,  /* 000000B0    "INTL...." */
+    0x60,0x9C,0x00,0x00,0x03,0x00,0x00,0x00,  /* 000000B8    "`......." */
+    0x1C,0x00,0x00,0x00,0x01,0x00,0x00,0x00,  /* 000000C0    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 000000C8    "........" */
+    0x2B,0x00,0x00,0x00,0x02,0x00,0x08,0x20,  /* 000000D0    "+...... " */
+    0x10,0x00,0x10,0x00,0xFF,0x0F,0x00,0x00,  /* 000000D8    "........" */
+    0x0C,0x00,0x00,0x00,0x03,0x00,0x01,0x00,  /* 000000E0    "........" */
+    0x49,0x32,0x43,0x20,0x0C,0x00,0x00,0x00,  /* 000000E8    "I2C ...." */
+    0x03,0x00,0x00,0x00,0x43,0x48,0x41,0x30,  /* 000000F0    "....CHA0" */
+    0x0C,0x00,0x00,0x00,0x03,0x00,0x00,0x00,  /* 000000F8    "........" */
+    0x43,0x48,0x41,0x31,0x0C,0x00,0x00,0x00,  /* 00000100    "CHA1...." */
+    0x03,0x00,0x00,0x00,0x43,0x48,0x41,0x32,  /* 00000108    "....CHA2" */
+    0x0C,0x00,0x00,0x00,0x03,0x00,0x00,0x00,  /* 00000110    "........" */
+    0x43,0x48,0x41,0x33,0x0C,0x00,0x00,0x00,  /* 00000118    "CHA3...." */
+    0x03,0x00,0x00,0x00,0x43,0x48,0x41,0x34,  /* 00000120    "....CHA4" */
+    0x0C,0x00,0x00,0x00,0x03,0x00,0x00,0x00,  /* 00000128    "........" */
+    0x43,0x48,0x41,0x35,0x0C,0x00,0x00,0x00,  /* 00000130    "CHA5...." */
+    0x03,0x00,0x00,0x00,0x43,0x48,0x41,0x36,  /* 00000138    "....CHA6" */
+    0x0C,0x00,0x00,0x00,0x03,0x00,0x00,0x00,  /* 00000140    "........" */
+    0x43,0x48,0x41,0x37                       /* 00000148    "CHA7"     */
+};
+
+const unsigned char TemplateDbg2[] =
+{
+    0x44,0x42,0x47,0x32,0xB2,0x00,0x00,0x00,  /* 00000000    "DBG2...." */
+    0x01,0xBA,0x49,0x4E,0x54,0x45,0x4C,0x20,  /* 00000008    "..INTEL " */
+    0x54,0x45,0x4D,0x50,0x4C,0x41,0x54,0x45,  /* 00000010    "TEMPLATE" */
+    0x00,0x00,0x00,0x00,0x49,0x4E,0x54,0x4C,  /* 00000018    "....INTL" */
+    0x15,0x11,0x13,0x20,0x2C,0x00,0x00,0x00,  /* 00000020    "... ,..." */
+    0x02,0x00,0x00,0x00,0xEE,0x3F,0x00,0x02,  /* 00000028    ".....?.." */
+    0x09,0x00,0x36,0x00,0x00,0x00,0x00,0x00,  /* 00000030    "..6....." */
+    0x00,0x80,0x00,0x00,0x00,0x00,0x16,0x00,  /* 00000038    "........" */
+    0x2E,0x00,0x01,0x32,0x00,0x03,0x88,0x77,  /* 00000040    "...2...w" */
+    0x66,0x55,0x44,0x33,0x22,0x11,0x01,0x64,  /* 00000048    "fUD3"..d" */
+    0x00,0x04,0x11,0x00,0xFF,0xEE,0xDD,0xCC,  /* 00000050    "........" */
+    0xBB,0xAA,0x10,0x32,0x54,0x76,0x98,0xBA,  /* 00000058    "...2Tv.." */
+    0xDC,0xFE,0x4D,0x79,0x44,0x65,0x76,0x69,  /* 00000060    "..MyDevi" */
+    0x63,0x65,0x00,0xEE,0x47,0x00,0x01,0x11,  /* 00000068    "ce..G..." */
+    0x00,0x26,0x00,0x10,0x00,0x37,0x00,0x00,  /* 00000070    ".&...7.." */
+    0x80,0x00,0x00,0x00,0x00,0x16,0x00,0x22,  /* 00000078    "......."" */
+    0x00,0x01,0x64,0x00,0x04,0x11,0x00,0xFF,  /* 00000080    "..d....." */
+    0xEE,0xDD,0xCC,0xBB,0xAA,0x98,0xBA,0xDC,  /* 00000088    "........" */
+    0xFE,0x5C,0x5C,0x5F,0x53,0x42,0x5F,0x2E,  /* 00000090    ".\\_SB_." */
+    0x50,0x43,0x49,0x30,0x2E,0x44,0x42,0x47,  /* 00000098    "PCI0.DBG" */
+    0x50,0x00,0x41,0x42,0x43,0x44,0x45,0x46,  /* 000000A0    "P.ABCDEF" */
+    0x47,0x48,0x49,0x50,0x51,0x52,0x53,0x54,  /* 000000A8    "GHIPQRST" */
+    0x55,0x56                                 /* 000000B0    "UV"       */
+};
+
+const unsigned char TemplateDbgp[] =
+{
+    0x44,0x42,0x47,0x50,0x34,0x00,0x00,0x00,  /* 00000000    "DBGP4..." */
+    0x01,0x1A,0x49,0x4E,0x54,0x45,0x4C,0x20,  /* 00000008    "..INTEL " */
+    0x54,0x45,0x4D,0x50,0x4C,0x41,0x54,0x45,  /* 00000010    "TEMPLATE" */
+    0x00,0x00,0x00,0x00,0x49,0x4E,0x54,0x4C,  /* 00000018    "....INTL" */
+    0x28,0x05,0x10,0x20,0x00,0x00,0x00,0x00,  /* 00000020    "(.. ...." */
+    0x00,0x08,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000028    "........" */
+    0x00,0x00,0x00,0x00                       /* 00000030    "...."     */
+};
+
+const unsigned char TemplateDmar[] =
+{
+    0x44,0x4D,0x41,0x52,0x8C,0x00,0x00,0x00,  /* 00000000    "DMAR...." */
+    0x01,0x03,0x49,0x4E,0x54,0x45,0x4C,0x20,  /* 00000008    "..INTEL " */
+    0x54,0x45,0x4D,0x50,0x4C,0x41,0x54,0x45,  /* 00000010    "TEMPLATE" */
+    0x01,0x00,0x00,0x00,0x49,0x4E,0x54,0x4C,  /* 00000018    "....INTL" */
+    0x17,0x05,0x13,0x20,0x2F,0x01,0x00,0x00,  /* 00000020    "... /..." */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000028    "........" */
+    0x00,0x00,0x18,0x00,0x01,0x00,0x00,0x00,  /* 00000030    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000038    "........" */
+    0x03,0x08,0x00,0x00,0x08,0x00,0x00,0x01,  /* 00000040    "........" */
+    0x01,0x00,0x20,0x00,0x00,0x00,0x00,0x00,  /* 00000048    ".. ....." */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000050    "........" */
+    0xFF,0x0F,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000058    "........" */
+    0x01,0x08,0x00,0x00,0x00,0x00,0x00,0x02,  /* 00000060    "........" */
+    0x02,0x00,0x10,0x00,0x00,0x00,0x00,0x00,  /* 00000068    "........" */
+    0x02,0x08,0x00,0x00,0x00,0x00,0x00,0x03,  /* 00000070    "........" */
+    0x03,0x00,0x14,0x00,0x00,0x00,0x00,0x00,  /* 00000078    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000080    "........" */
+    0x00,0x00,0x00,0x00                       /* 00000088    "...."     */
+};
+
+const unsigned char TemplateDrtm[] =
+{
+    0x44,0x52,0x54,0x4D,0x94,0x00,0x00,0x00,  /* 00000000    "DRTM...." */
+    0x01,0xB9,0x49,0x4E,0x54,0x45,0x4C,0x20,  /* 00000008    "..INTEL " */
+    0x54,0x45,0x4D,0x50,0x4C,0x41,0x54,0x45,  /* 00000010    "TEMPLATE" */
+    0x01,0x00,0x00,0x00,0x49,0x4E,0x54,0x4C,  /* 00000018    "....INTL" */
+    0x10,0x04,0x15,0x20,0x00,0x00,0x00,0x00,  /* 00000020    "... ...." */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000028    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000030    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000038    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000040    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000048    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000050    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000058    "........" */
+    0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000060    "........" */
+    0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,  /* 00000068    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000070    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000078    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000080    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000088    "........" */
+    0x00,0x00,0x00,0x00                       /* 00000090    "...."     */
+};
+
+const unsigned char TemplateEcdt[] =
+{
+    0x45,0x43,0x44,0x54,0x42,0x00,0x00,0x00,  /* 00000000    "ECDTB..." */
+    0x01,0x2D,0x49,0x4E,0x54,0x45,0x4C,0x20,  /* 00000008    ".-INTEL " */
+    0x54,0x45,0x4D,0x50,0x4C,0x41,0x54,0x45,  /* 00000010    "TEMPLATE" */
+    0x01,0x00,0x00,0x00,0x49,0x4E,0x54,0x4C,  /* 00000018    "....INTL" */
+    0x28,0x05,0x10,0x20,0x01,0x08,0x00,0x00,  /* 00000020    "(.. ...." */
+    0x66,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000028    "f......." */
+    0x01,0x08,0x00,0x00,0x62,0x00,0x00,0x00,  /* 00000030    "....b..." */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000038    "........" */
+    0x09,0x00                                 /* 00000040    ".."       */
+};
+
+const unsigned char TemplateEinj[] =
+{
+    0x45,0x49,0x4E,0x4A,0x30,0x01,0x00,0x00,  /* 00000000    "EINJ0..." */
+    0x01,0x09,0x49,0x4E,0x54,0x45,0x4C,0x20,  /* 00000008    "..INTEL " */
+    0x54,0x45,0x4D,0x50,0x4C,0x41,0x54,0x45,  /* 00000010    "TEMPLATE" */
+    0x01,0x00,0x00,0x00,0x49,0x4E,0x54,0x4C,  /* 00000018    "....INTL" */
+    0x28,0x05,0x10,0x20,0x30,0x00,0x00,0x00,  /* 00000020    "(.. 0..." */
+    0x00,0x00,0x00,0x00,0x0A,0x00,0x00,0x00,  /* 00000028    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x40,0x00,0x04,  /* 00000030    ".....@.." */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000038    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000040    "........" */
+    0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,  /* 00000048    "........" */
+    0x01,0x00,0x00,0x00,0x00,0x40,0x00,0x04,  /* 00000050    ".....@.." */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000058    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000060    "........" */
+    0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,  /* 00000068    "........" */
+    0x02,0x02,0x01,0x00,0x00,0x40,0x00,0x04,  /* 00000070    ".....@.." */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000078    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000080    "........" */
+    0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,  /* 00000088    "........" */
+    0x03,0x00,0x00,0x00,0x00,0x40,0x00,0x04,  /* 00000090    ".....@.." */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000098    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 000000A0    "........" */
+    0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,  /* 000000A8    "........" */
+    0x04,0x03,0x01,0x00,0x00,0x40,0x00,0x04,  /* 000000B0    ".....@.." */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 000000B8    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 000000C0    "........" */
+    0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,  /* 000000C8    "........" */
+    0x05,0x03,0x01,0x00,0x01,0x10,0x00,0x02,  /* 000000D0    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 000000D8    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 000000E0    "........" */
+    0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,  /* 000000E8    "........" */
+    0x06,0x01,0x00,0x00,0x00,0x40,0x00,0x04,  /* 000000F0    ".....@.." */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 000000F8    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000100    "........" */
+    0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,  /* 00000108    "........" */
+    0x07,0x00,0x01,0x00,0x00,0x40,0x00,0x04,  /* 00000110    ".....@.." */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000118    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000120    "........" */
+    0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF   /* 00000128    "........" */
+};
+
+const unsigned char TemplateErst[] =
+{
+    0x45,0x52,0x53,0x54,0x30,0x02,0x00,0x00,  /* 00000000    "ERST0..." */
+    0x01,0xAB,0x49,0x4E,0x54,0x45,0x4C,0x20,  /* 00000008    "..INTEL " */
+    0x54,0x45,0x4D,0x50,0x4C,0x41,0x54,0x45,  /* 00000010    "TEMPLATE" */
+    0x01,0x00,0x00,0x00,0x49,0x4E,0x54,0x4C,  /* 00000018    "....INTL" */
+    0x28,0x05,0x10,0x20,0x30,0x00,0x00,0x00,  /* 00000020    "(.. 0..." */
+    0x00,0x00,0x00,0x00,0x10,0x00,0x00,0x00,  /* 00000028    "........" */
+    0x00,0x03,0x00,0x00,0x00,0x40,0x00,0x04,  /* 00000030    ".....@.." */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000038    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000040    "........" */
+    0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,  /* 00000048    "........" */
+    0x01,0x03,0x00,0x00,0x00,0x40,0x00,0x04,  /* 00000050    ".....@.." */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000058    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000060    "........" */
+    0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,  /* 00000068    "........" */
+    0x02,0x03,0x00,0x00,0x00,0x40,0x00,0x04,  /* 00000070    ".....@.." */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000078    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000080    "........" */
+    0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,  /* 00000088    "........" */
+    0x03,0x04,0x01,0x00,0x00,0x40,0x00,0x04,  /* 00000090    ".....@.." */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000098    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 000000A0    "........" */
+    0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,  /* 000000A8    "........" */
+    0x04,0x02,0x00,0x00,0x00,0x40,0x00,0x04,  /* 000000B0    ".....@.." */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 000000B8    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 000000C0    "........" */
+    0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,  /* 000000C8    "........" */
+    0x05,0x03,0x00,0x00,0x01,0x08,0x00,0x01,  /* 000000D0    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 000000D8    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 000000E0    "........" */
+    0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,  /* 000000E8    "........" */
+    0x06,0x01,0x00,0x00,0x00,0x40,0x00,0x04,  /* 000000F0    ".....@.." */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 000000F8    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000100    "........" */
+    0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,  /* 00000108    "........" */
+    0x07,0x00,0x00,0x00,0x00,0x40,0x00,0x04,  /* 00000110    ".....@.." */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000118    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000120    "........" */
+    0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,  /* 00000128    "........" */
+    0x08,0x00,0x00,0x00,0x00,0x40,0x00,0x04,  /* 00000130    ".....@.." */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000138    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000140    "........" */
+    0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,  /* 00000148    "........" */
+    0x09,0x02,0x00,0x00,0x00,0x40,0x00,0x04,  /* 00000150    ".....@.." */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000158    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000160    "........" */
+    0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,  /* 00000168    "........" */
+    0x0A,0x00,0x00,0x00,0x00,0x40,0x00,0x04,  /* 00000170    ".....@.." */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000178    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000180    "........" */
+    0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,  /* 00000188    "........" */
+    0x0B,0x03,0x00,0x00,0x00,0x40,0x00,0x04,  /* 00000190    ".....@.." */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000198    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 000001A0    "........" */
+    0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,  /* 000001A8    "........" */
+    0x0C,0x00,0x00,0x00,0x00,0x40,0x00,0x04,  /* 000001B0    ".....@.." */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 000001B8    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 000001C0    "........" */
+    0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,  /* 000001C8    "........" */
+    0x0D,0x00,0x00,0x00,0x00,0x40,0x00,0x04,  /* 000001D0    ".....@.." */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 000001D8    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 000001E0    "........" */
+    0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,  /* 000001E8    "........" */
+    0x0E,0x00,0x00,0x00,0x00,0x40,0x00,0x04,  /* 000001F0    ".....@.." */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 000001F8    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000200    "........" */
+    0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,  /* 00000208    "........" */
+    0x0F,0x00,0x00,0x00,0x00,0x40,0x00,0x04,  /* 00000210    ".....@.." */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000218    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000220    "........" */
+    0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF   /* 00000228    "........" */
+};
+
+const unsigned char TemplateFacs[] =
+{
+    0x46,0x41,0x43,0x53,0x40,0x00,0x00,0x00,  /* 00000000    "FACS@..." */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000008    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000010    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000018    "........" */
+    0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000020    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000028    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000030    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00   /* 00000038    "........" */
+};
+
+/* Version 5 FADT */
+
+const unsigned char TemplateFadt[] =
+{
+    0x46,0x41,0x43,0x50,0x14,0x01,0x00,0x00,  /* 00000000    "FACP...." */
+    0x06,0x8A,0x49,0x4E,0x54,0x45,0x4C,0x20,  /* 00000008    "..INTEL " */
+    0x54,0x65,0x6D,0x70,0x6C,0x61,0x74,0x65,  /* 00000010    "Template" */
+    0x00,0x00,0x00,0x00,0x49,0x4E,0x54,0x4C,  /* 00000018    "....INTL" */
+    0x10,0x04,0x15,0x20,0x01,0x00,0x00,0x00,  /* 00000020    "... ...." */
+    0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000028    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000030    "........" */
+    0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000038    "........" */
+    0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000040    "........" */
+    0x01,0x00,0x00,0x00,0x01,0x00,0x00,0x00,  /* 00000048    "........" */
+    0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000050    "........" */
+    0x04,0x02,0x01,0x04,0x08,0x00,0x00,0x00,  /* 00000058    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000060    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000068    "........" */
+    0x00,0x00,0x00,0x00,0x01,0x08,0x00,0x01,  /* 00000070    "........" */
+    0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000078    "........" */
+    0x00,0x00,0x00,0x01,0x01,0x00,0x00,0x00,  /* 00000080    "........" */
+    0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,  /* 00000088    "........" */
+    0x00,0x00,0x00,0x00,0x01,0x20,0x00,0x02,  /* 00000090    "..... .." */
+    0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000098    "........" */
+    0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 000000A0    "........" */
+    0x00,0x00,0x00,0x00,0x01,0x10,0x00,0x02,  /* 000000A8    "........" */
+    0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 000000B0    "........" */
+    0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 000000B8    "........" */
+    0x00,0x00,0x00,0x00,0x01,0x08,0x00,0x00,  /* 000000C0    "........" */
+    0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 000000C8    "........" */
+    0x01,0x20,0x00,0x03,0x01,0x00,0x00,0x00,  /* 000000D0    ". ......" */
+    0x00,0x00,0x00,0x00,0x01,0x40,0x00,0x01,  /* 000000D8    ".....@.." */
+    0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 000000E0    "........" */
+    0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 000000E8    "........" */
+    0x00,0x00,0x00,0x00,0x01,0x08,0x00,0x01,  /* 000000F0    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 000000F8    "........" */
+    0x01,0x08,0x00,0x01,0x00,0x00,0x00,0x00,  /* 00000100    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000108    "........" */
+    0x00,0x00,0x00,0x00                       /* 00000110    "...."     */
+};
+
+const unsigned char TemplateFpdt[] =
+{
+    0x46,0x50,0x44,0x54,0x64,0x00,0x00,0x00,  /* 00000000    "FPDTd..." */
+    0x01,0xBD,0x49,0x4E,0x54,0x45,0x4C,0x20,  /* 00000008    "..INTEL " */
+    0x54,0x45,0x4D,0x50,0x4C,0x41,0x54,0x45,  /* 00000010    "TEMPLATE" */
+    0x01,0x00,0x00,0x00,0x49,0x4E,0x54,0x4C,  /* 00000018    "....INTL" */
+    0x04,0x08,0x11,0x20,0x00,0x00,0x30,0x01,  /* 00000020    "... ..0." */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000028    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000030    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000038    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000040    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000048    "........" */
+    0x00,0x00,0x00,0x00,0x01,0x00,0x10,0x01,  /* 00000050    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000058    "........" */
+    0x00,0x00,0x00,0x00                       /* 00000060    "...."     */
+};
+
+const unsigned char TemplateGtdt[] =
+{
+    0x47,0x54,0x44,0x54,0xe0,0x00,0x00,0x00,  /* 00000000    "GTDT...." */
+    0x02,0xb0,0x4c,0x49,0x4e,0x41,0x52,0x4f,  /* 00000008    "..LINARO" */
+    0x52,0x54,0x53,0x4d,0x56,0x45,0x56,0x38,  /* 00000010    "RTSMVEV8" */
+    0x01,0x00,0x00,0x00,0x49,0x4e,0x54,0x4c,  /* 00000018    "....INTL" */
+    0x24,0x04,0x14,0x20,0x00,0x00,0x00,0x00,  /* 00000020    "$.. ...." */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000028    "........" */
+    0x1d,0x00,0x00,0x00,0x01,0x00,0x00,0x00,  /* 00000030    "........" */
+    0x1e,0x00,0x00,0x00,0x01,0x00,0x00,0x00,  /* 00000038    "........" */
+    0x1b,0x00,0x00,0x00,0x01,0x00,0x00,0x00,  /* 00000040    "........" */
+    0x1a,0x00,0x00,0x00,0x01,0x00,0x00,0x00,  /* 00000048    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000050    "........" */
+    0x02,0x00,0x00,0x00,0x60,0x00,0x00,0x00,  /* 00000058    "....`..." */
+    0x00,0x64,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000060    ".d......" */
+    0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00,  /* 00000068    "........" */
+    0x14,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000070    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000078    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000080    "........" */
+    0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,  /* 00000088    "........" */
+    0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,  /* 00000090    "........" */
+    0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,  /* 00000098    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 000000a0    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 000000a8    "........" */
+    0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,  /* 000000b0    "........" */
+    0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,  /* 000000b8    "........" */
+    0x00,0x00,0x00,0x00,0x01,0x1c,0x00,0x00,  /* 000000c0    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 000000c8    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 000000d0    "........" */
+    0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,  /* 000000d8    "........" */
+};
+
+const unsigned char TemplateHest[] =
+{
+    0x48,0x45,0x53,0x54,0xD4,0x01,0x00,0x00,  /* 00000000    "HEST...." */
+    0x01,0x20,0x49,0x4E,0x54,0x45,0x4C,0x20,  /* 00000008    ". INTEL " */
+    0x54,0x45,0x4D,0x50,0x4C,0x41,0x54,0x45,  /* 00000010    "TEMPLATE" */
+    0x01,0x00,0x00,0x00,0x49,0x4E,0x54,0x4C,  /* 00000018    "....INTL" */
+    0x28,0x05,0x10,0x20,0x04,0x00,0x00,0x00,  /* 00000020    "(.. ...." */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,  /* 00000028    "........" */
+    0x01,0x00,0x00,0x00,0x01,0x00,0x00,0x00,  /* 00000030    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000038    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000040    "........" */
+    0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000048    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000050    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000058    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000060    "........" */
+    0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,  /* 00000068    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000070    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000078    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000080    "........" */
+    0x01,0x00,0x01,0x00,0x00,0x00,0x00,0x01,  /* 00000088    "........" */
+    0x01,0x00,0x00,0x00,0x01,0x00,0x00,0x00,  /* 00000090    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000098    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 000000A0    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 000000A8    "........" */
+    0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00,  /* 000000B0    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 000000B8    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 000000C0    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 000000C8    "........" */
+    0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,  /* 000000D0    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 000000D8    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 000000E0    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 000000E8    "........" */
+    0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x01,  /* 000000F0    "........" */
+    0x01,0x00,0x00,0x00,0x01,0x00,0x00,0x00,  /* 000000F8    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000100    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000108    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000110    "........" */
+    0x00,0x00,0x00,0x00,0x08,0x00,0x00,0x00,  /* 00000118    "........" */
+    0x00,0x00,0x00,0x01,0x01,0x00,0x00,0x00,  /* 00000120    "........" */
+    0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000128    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000130    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000138    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000140    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000148    "........" */
+    0x00,0x00,0x00,0x00,0x09,0x00,0x02,0x00,  /* 00000150    "........" */
+    0xFF,0xFF,0x00,0x01,0x01,0x00,0x00,0x00,  /* 00000158    "........" */
+    0x01,0x00,0x00,0x00,0x00,0x10,0x00,0x00,  /* 00000160    "........" */
+    0x00,0x40,0x00,0x04,0x00,0x00,0x00,0x00,  /* 00000168    ".@......" */
+    0x00,0x00,0x00,0x00,0x03,0x1C,0x00,0x00,  /* 00000170    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000178    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000180    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000188    "........" */
+    0x00,0x10,0x00,0x00,0x09,0x00,0x03,0x00,  /* 00000190    "........" */
+    0x00,0x00,0x00,0x01,0x01,0x00,0x00,0x00,  /* 00000198    "........" */
+    0x01,0x00,0x00,0x00,0x00,0x10,0x00,0x00,  /* 000001A0    "........" */
+    0x00,0x40,0x00,0x04,0x00,0x00,0x00,0x00,  /* 000001A8    ".@......" */
+    0x00,0x00,0x00,0x00,0x04,0x1C,0x00,0x00,  /* 000001B0    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 000001B8    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 000001C0    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 000001C8    "........" */
+    0x00,0x10,0x00,0x00                       /* 000001D0    "...."     */
+};
+
+const unsigned char TemplateHpet[] =
+{
+    0x48,0x50,0x45,0x54,0x38,0x00,0x00,0x00,  /* 00000000    "HPET8..." */
+    0x01,0x09,0x49,0x4E,0x54,0x45,0x4C,0x20,  /* 00000008    "..INTEL " */
+    0x54,0x45,0x4D,0x50,0x4C,0x41,0x54,0x45,  /* 00000010    "TEMPLATE" */
+    0x01,0x00,0x00,0x00,0x49,0x4E,0x54,0x4C,  /* 00000018    "....INTL" */
+    0x28,0x05,0x10,0x20,0x00,0x00,0x00,0x00,  /* 00000020    "(.. ...." */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000028    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00   /* 00000030    "........" */
+};
+
+const unsigned char TemplateIort[] =
+{
+    0x49,0x4F,0x52,0x54,0x48,0x01,0x00,0x00,  /* 00000000    "IORTH..." */
+    0x00,0x02,0x49,0x4E,0x54,0x45,0x4C,0x20,  /* 00000008    "..INTEL " */
+    0x54,0x45,0x4D,0x50,0x4C,0x41,0x54,0x45,  /* 00000010    "TEMPLATE" */
+    0x00,0x00,0x00,0x00,0x49,0x4E,0x54,0x4C,  /* 00000018    "....INTL" */
+    0x12,0x02,0x16,0x20,0x05,0x00,0x00,0x00,  /* 00000020    "... ...." */
+    0x34,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000028    "4......." */
+    0x00,0x00,0x00,0x00,0x00,0x2C,0x00,0x00,  /* 00000030    ".....,.." */
+    0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,  /* 00000038    "........" */
+    0x18,0x00,0x00,0x00,0x01,0x00,0x00,0x00,  /* 00000040    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000048    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000050    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000058    "........" */
+    0x01,0x30,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000060    ".0......" */
+    0x00,0x00,0x00,0x00,0x30,0x00,0x00,0x00,  /* 00000068    "....0..." */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000070    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x5C,0x5F,0x53,  /* 00000078    ".....\_S" */
+    0x42,0x2E,0x50,0x43,0x49,0x30,0x2E,0x44,  /* 00000080    "B.PCI0.D" */
+    0x45,0x56,0x30,0x00,0x00,0x00,0x00,0x00,  /* 00000088    "EV0....." */
+    0x02,0x20,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000090    ". ......" */
+    0x00,0x00,0x00,0x00,0x20,0x00,0x00,0x00,  /* 00000098    ".... ..." */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 000000A0    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 000000A8    "........" */
+    0x03,0x5C,0x00,0x00,0x00,0x00,0x00,0x00,  /* 000000B0    ".\......" */
+    0x00,0x00,0x00,0x00,0x5C,0x00,0x00,0x00,  /* 000000B8    "....\..." */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 000000C0    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 000000C8    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 000000D0    "........" */
+    0x3C,0x00,0x00,0x00,0x01,0x00,0x00,0x00,  /* 000000D8    "<......." */
+    0x4C,0x00,0x00,0x00,0x01,0x00,0x00,0x00,  /* 000000E0    "L......." */
+    0x54,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 000000E8    "T......." */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 000000F0    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 000000F8    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000100    "........" */
+    0x00,0x00,0x00,0x00,0x04,0x3C,0x00,0x00,  /* 00000108    ".....<.." */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000110    "........" */
+    0x3C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000118    "<......." */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000120    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000128    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000130    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000138    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00   /* 00000140    "........" */
+};
+
+const unsigned char TemplateIvrs[] =
+{
+    0x49,0x56,0x52,0x53,0xBC,0x00,0x00,0x00,  /* 00000000    "IVRS...." */
+    0x01,0x87,0x49,0x4E,0x54,0x45,0x4C,0x20,  /* 00000008    "..INTEL " */
+    0x54,0x45,0x4D,0x50,0x4C,0x41,0x54,0x45,  /* 00000010    "TEMPLATE" */
+    0x01,0x00,0x00,0x00,0x49,0x4E,0x54,0x4C,  /* 00000018    "....INTL" */
+    0x28,0x05,0x10,0x20,0x00,0x00,0x00,0x00,  /* 00000020    "(.. ...." */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000028    "........" */
+    0x10,0x14,0x34,0x00,0x00,0x00,0x00,0x00,  /* 00000030    "..4....." */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000038    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000040    "........" */
+    0x00,0x00,0x00,0x00,0x40,0x00,0x00,0x00,  /* 00000048    "....@..." */
+    0x00,0x00,0x00,0x00,0x42,0x00,0x00,0x00,  /* 00000050    "....B..." */
+    0x00,0x00,0x00,0x00,0x48,0x00,0x00,0x00,  /* 00000058    "....H..." */
+    0x00,0x00,0x00,0x00,0x20,0x08,0x20,0x00,  /* 00000060    ".... . ." */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000068    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000070    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000078    "........" */
+    0x00,0x00,0x00,0x00,0x21,0x04,0x20,0x00,  /* 00000080    "....!. ." */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000088    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000090    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000098    "........" */
+    0x00,0x00,0x00,0x00,0x10,0x14,0x18,0x00,  /* 000000A0    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 000000A8    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 000000B0    "........" */
+    0x00,0x00,0x00,0x00                       /* 000000B8    "...."     */
+};
+
+const unsigned char TemplateLpit[] =
+{
+    0x4C,0x50,0x49,0x54,0x94,0x00,0x00,0x00,  /* 00000000    "LPIT...." */
+    0x00,0xD8,0x49,0x4E,0x54,0x45,0x4C,0x20,  /* 00000008    "..INTEL " */
+    0x54,0x65,0x6D,0x70,0x6C,0x61,0x74,0x65,  /* 00000010    "Template" */
+    0x01,0x00,0x00,0x00,0x49,0x4E,0x54,0x4C,  /* 00000018    "....INTL" */
+    0x10,0x04,0x15,0x20,0x00,0x00,0x00,0x00,  /* 00000020    "... ...." */
+    0x38,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000028    "8......." */
+    0x00,0x00,0x00,0x00,0x01,0x08,0x00,0x01,  /* 00000030    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000038    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000040    "........" */
+    0x7F,0x40,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000048    ".@......" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000050    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000058    "........" */
+    0x38,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000060    "8......." */
+    0x00,0x00,0x00,0x00,0x01,0x08,0x00,0x01,  /* 00000068    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000070    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000078    "........" */
+    0x7F,0x40,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000080    ".@......" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000088    "........" */
+    0x00,0x00,0x00,0x00                       /* 00000090    "...."     */
+};
+
+/* MADT with ACPI 6.0 subtables */
+
+const unsigned char TemplateMadt[] =
+{
+    0x41,0x50,0x49,0x43,0x5A,0x01,0x00,0x00,  /* 00000000    "APICZ..." */
+    0x03,0xEA,0x49,0x4E,0x54,0x45,0x4C,0x20,  /* 00000008    "..INTEL " */
+    0x54,0x65,0x6D,0x70,0x6C,0x61,0x74,0x65,  /* 00000010    "Template" */
+    0x01,0x00,0x00,0x00,0x49,0x4E,0x54,0x4C,  /* 00000018    "....INTL" */
+    0x10,0x04,0x15,0x20,0x00,0x00,0x00,0x00,  /* 00000020    "... ...." */
+    0x01,0x00,0x00,0x00,0x00,0x08,0x00,0x00,  /* 00000028    "........" */
+    0x01,0x00,0x00,0x00,0x01,0x0C,0x01,0x00,  /* 00000030    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000038    "........" */
+    0x02,0x0A,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000040    "........" */
+    0x00,0x00,0x03,0x08,0x0D,0x00,0x01,0x00,  /* 00000048    "........" */
+    0x00,0x00,0x04,0x06,0x00,0x05,0x00,0x01,  /* 00000050    "........" */
+    0x05,0x0C,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000058    "........" */
+    0x00,0x00,0x00,0x00,0x06,0x10,0x00,0x00,  /* 00000060    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000068    "........" */
+    0x00,0x00,0x00,0x00,0x07,0x16,0x00,0x00,  /* 00000070    "........" */
+    0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,  /* 00000078    "........" */
+    0x00,0x00,0x00,0x00,0x5C,0x43,0x50,0x55,  /* 00000080    "....\CPU" */
+    0x30,0x00,0x08,0x10,0x05,0x00,0x00,0x00,  /* 00000088    "0......." */
+    0x00,0x00,0x01,0x00,0x00,0x00,0x01,0x00,  /* 00000090    "........" */
+    0x00,0x00,0x09,0x10,0x00,0x00,0x00,0x00,  /* 00000098    "........" */
+    0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,  /* 000000A0    "........" */
+    0x00,0x00,0x0A,0x0C,0x05,0x00,0x00,0x00,  /* 000000A8    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x0B,0x50,  /* 000000B0    ".......P" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 000000B8    "........" */
+    0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,  /* 000000C0    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 000000C8    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 000000D0    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 000000D8    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 000000E0    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 000000E8    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 000000F0    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 000000F8    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x0C,0x18,  /* 00000100    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000108    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000110    "........" */
+    0x00,0x00,0x01,0x00,0x00,0x00,0x0D,0x18,  /* 00000118    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000120    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,  /* 00000128    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x0E,0x10,  /* 00000130    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000138    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x0F,0x14,  /* 00000140    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000148    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000150    "........" */
+    0x00,0x00                                 /* 00000158    ".."       */
+};
+
+const unsigned char TemplateMcfg[] =
+{
+    0x4D,0x43,0x46,0x47,0x3C,0x00,0x00,0x00,  /* 00000000    "MCFG<..." */
+    0x01,0x19,0x49,0x4E,0x54,0x45,0x4C,0x20,  /* 00000008    "..INTEL " */
+    0x54,0x45,0x4D,0x50,0x4C,0x41,0x54,0x45,  /* 00000010    "TEMPLATE" */
+    0x01,0x00,0x00,0x00,0x49,0x4E,0x54,0x4C,  /* 00000018    "....INTL" */
+    0x28,0x05,0x10,0x20,0x00,0x00,0x00,0x00,  /* 00000020    "(.. ...." */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000028    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000030    "........" */
+    0x00,0x00,0x00,0x00                       /* 00000038    "...."     */
+};
+
+const unsigned char TemplateMchi[] =
+{
+    0x4D,0x43,0x48,0x49,0x45,0x00,0x00,0x00,  /* 00000000    "MCHIE..." */
+    0x01,0xE4,0x49,0x4E,0x54,0x45,0x4C,0x20,  /* 00000008    "..INTEL " */
+    0x54,0x45,0x4D,0x50,0x4C,0x41,0x54,0x45,  /* 00000010    "TEMPLATE" */
+    0x15,0x07,0x00,0x02,0x49,0x4E,0x54,0x4C,  /* 00000018    "....INTL" */
+    0x28,0x05,0x10,0x20,0x01,0x00,0x00,0x00,  /* 00000020    "(.. ...." */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000028    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x02,0x08,0x00,  /* 00000030    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000038    "........" */
+    0x00,0x00,0x00,0x00,0x00                  /* 00000040    "....."    */
+};
+
+const unsigned char TemplateMsdm[] =
+{
+    0x4D,0x53,0x44,0x4D,0x64,0x00,0x00,0x00,  /* 00000000    "MSDMd..." */
+    0x01,0x34,0x49,0x6E,0x74,0x65,0x6C,0x00,  /* 00000008    ".4Intel." */
+    0x54,0x65,0x6D,0x70,0x6C,0x61,0x74,0x65,  /* 00000010    "Template" */
+    0x03,0x00,0x00,0x00,0x49,0x4E,0x54,0x4C,  /* 00000018    "....INTL" */
+    0x04,0x02,0x15,0x20,0x00,0x00,0x00,0x00,  /* 00000020    "... ...." */
+    0x0A,0x10,0x16,0x17,0x18,0x19,0x1A,0x1B,  /* 00000028    "........" */
+    0x1C,0x1D,0x1E,0x1F,0x20,0x21,0x22,0x23,  /* 00000030    ".... !"#" */
+    0x24,0x25,0x26,0x27,0x10,0x0A,0x15,0x16,  /* 00000038    "$%&'...." */
+    0x17,0x18,0x19,0x1A,0x1B,0x1C,0x1D,0x1E,  /* 00000040    "........" */
+    0x1F,0x20,0x21,0x22,0x23,0x24,0x25,0x26,  /* 00000048    ". !"#$%&" */
+    0x16,0x15,0x0A,0x10,0x16,0x17,0x18,0x19,  /* 00000050    "........" */
+    0x1A,0x1B,0x1C,0x1D,0x1E,0x1F,0x20,0x21,  /* 00000058    "...... !" */
+    0x22,0x23,0x24,0x25                       /* 00000060    ""#$%"     */
+};
+
+const unsigned char TemplateMpst[] =
+{
+    0x4D,0x50,0x53,0x54,0xB6,0x00,0x00,0x00,  /* 00000000    "MPST...." */
+    0x01,0x77,0x49,0x4E,0x54,0x45,0x4C,0x20,  /* 00000008    ".wINTEL " */
+    0x54,0x45,0x4D,0x50,0x4C,0x41,0x54,0x45,  /* 00000010    "TEMPLATE" */
+    0x01,0x00,0x00,0x00,0x49,0x4E,0x54,0x4C,  /* 00000018    "....INTL" */
+    0x13,0x09,0x12,0x20,0x00,0x00,0x00,0x00,  /* 00000020    "... ...." */
+    0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000028    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000030    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000038    "........" */
+    0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00,  /* 00000040    "........" */
+    0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000048    "........" */
+    0x00,0x00,0x01,0x00,0x02,0x00,0x00,0x00,  /* 00000050    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000058    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000060    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,  /* 00000068    "........" */
+    0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,  /* 00000070    "........" */
+    0x00,0x00,0x02,0x00,0x00,0x00,0x01,0x00,  /* 00000078    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000080    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000088    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000090    "........" */
+    0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,  /* 00000098    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 000000A0    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 000000A8    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00             /* 000000B0    "......"   */
+};
+
+const unsigned char TemplateMsct[] =
+{
+    0x4D,0x53,0x43,0x54,0x90,0x00,0x00,0x00,  /* 00000000    "MSCT...." */
+    0x01,0xB7,0x49,0x4E,0x54,0x45,0x4C,0x20,  /* 00000008    "..INTEL " */
+    0x54,0x45,0x4D,0x50,0x4C,0x41,0x54,0x45,  /* 00000010    "TEMPLATE" */
+    0x01,0x00,0x00,0x00,0x49,0x4E,0x54,0x4C,  /* 00000018    "....INTL" */
+    0x28,0x05,0x10,0x20,0x38,0x00,0x00,0x00,  /* 00000020    "(.. 8..." */
+    0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000028    "........" */
+    0xFF,0xFF,0xFF,0xFF,0xFF,0x0F,0x00,0x00,  /* 00000030    "........" */
+    0x01,0x16,0x00,0x00,0x00,0x00,0x03,0x00,  /* 00000038    "........" */
+    0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x00,  /* 00000040    "........" */
+    0x00,0x00,0x40,0x00,0x00,0x00,0x01,0x16,  /* 00000048    "..@....." */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000050    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000058    "........" */
+    0x00,0x00,0x00,0x00,0x01,0x16,0x00,0x00,  /* 00000060    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000068    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000070    "........" */
+    0x00,0x00,0x01,0x16,0x00,0x00,0x00,0x00,  /* 00000078    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000080    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00   /* 00000088    "........" */
+};
+
+const unsigned char TemplateNfit[] =
+{
+    0x4E,0x46,0x49,0x54,0x70,0x01,0x00,0x00,  /* 00000000    "NFITp..." */
+    0x01,0x53,0x49,0x4E,0x54,0x45,0x4C,0x20,  /* 00000008    ".SINTEL " */
+    0x54,0x65,0x6D,0x70,0x6C,0x61,0x74,0x65,  /* 00000010    "Template" */
+    0x01,0x00,0x00,0x00,0x49,0x4E,0x54,0x4C,  /* 00000018    "....INTL" */
+    0x10,0x04,0x15,0x20,0x00,0x00,0x00,0x00,  /* 00000020    "... ...." */
+    0x00,0x00,0x38,0x00,0x01,0x00,0x00,0x00,  /* 00000028    "..8....." */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000030    "........" */
+    0x30,0x05,0xAF,0x91,0x86,0x5D,0x0E,0x47,  /* 00000038    "0....].G" */
+    0xA6,0xB0,0x0A,0x2D,0xB9,0x40,0x82,0x49,  /* 00000040    "...-.@.I" */
+    0x00,0x00,0x00,0x7C,0x03,0x00,0x00,0x00,  /* 00000048    "...|...." */
+    0x00,0x00,0x00,0x0C,0x00,0x00,0x00,0x00,  /* 00000050    "........" */
+    0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000058    "........" */
+    0x01,0x00,0x30,0x00,0x01,0x00,0x00,0x00,  /* 00000060    "..0....." */
+    0x04,0x00,0x00,0x00,0x01,0x00,0x01,0x00,  /* 00000068    "........" */
+    0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00,  /* 00000070    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000078    "........" */
+    0x00,0x00,0x00,0x08,0x00,0x00,0x00,0x00,  /* 00000080    "........" */
+    0x01,0x00,0x03,0x00,0x2A,0x00,0x00,0x00,  /* 00000088    "....*..." */
+    0x02,0x00,0x20,0x00,0x01,0x00,0x00,0x00,  /* 00000090    ".. ....." */
+    0x04,0x00,0x00,0x00,0x00,0x01,0x00,0x00,  /* 00000098    "........" */
+    0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x00,  /* 000000A0    "........" */
+    0x06,0x00,0x00,0x00,0x09,0x00,0x00,0x00,  /* 000000A8    "........" */
+    0x03,0x00,0x28,0x00,0x00,0x00,0x00,0x00,  /* 000000B0    "..(....." */
+    0xB4,0x13,0x5D,0x40,0x91,0x0B,0x29,0x93,  /* 000000B8    "..]@..)." */
+    0x67,0xE8,0x23,0x4C,0x00,0x00,0x00,0x88,  /* 000000C0    "g.#L...." */
+    0x00,0x11,0x22,0x33,0x44,0x55,0x66,0x77,  /* 000000C8    ".."3DUfw" */
+    0x88,0x99,0xAA,0xBB,0xCC,0xDD,0xEE,0xFF,  /* 000000D0    "........" */
+    0x04,0x00,0x50,0x00,0x01,0x00,0x86,0x80,  /* 000000D8    "..P....." */
+    0x17,0x20,0x01,0x00,0x86,0x80,0x17,0x20,  /* 000000E0    ". ..... " */
+    0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 000000E8    "........" */
+    0x89,0x00,0x54,0x76,0x01,0x03,0x00,0x01,  /* 000000F0    "..Tv...." */
+    0x00,0x20,0x00,0x00,0x00,0x00,0x00,0x00,  /* 000000F8    ". ......" */
+    0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,  /* 00000100    "........" */
+    0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000108    "........" */
+    0x00,0x10,0x80,0x00,0x00,0x00,0x00,0x00,  /* 00000110    "........" */
+    0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000118    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000120    "........" */
+    0x05,0x00,0x28,0x00,0x01,0x00,0x00,0x01,  /* 00000128    "..(....." */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000130    "........" */
+    0x00,0x20,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000138    ". ......" */
+    0x00,0x00,0x00,0xE0,0x0F,0x00,0x00,0x00,  /* 00000140    "........" */
+    0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x00,  /* 00000148    "........" */
+    0x06,0x00,0x20,0x00,0x01,0x00,0x00,0x00,  /* 00000150    ".. ....." */
+    0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000158    "........" */
+    0x00,0x00,0x00,0x18,0x04,0x00,0x00,0x00,  /* 00000160    "........" */
+    0x00,0x00,0x00,0x18,0x06,0x00,0x00,0x00   /* 00000168    "........" */
+};
+
+const unsigned char TemplateMtmr[] =
+{
+    0x4D,0x54,0x4D,0x52,0x4C,0x00,0x00,0x00,  /* 00000000    "MTMRL..." */
+    0x01,0xB0,0x49,0x4E,0x54,0x45,0x4C,0x20,  /* 00000008    "..INTEL " */
+    0x54,0x45,0x4D,0x50,0x4C,0x41,0x54,0x45,  /* 00000010    "TEMPLATE" */
+    0x03,0x00,0x00,0x00,0x49,0x4E,0x54,0x4C,  /* 00000018    "....INTL" */
+    0x17,0x01,0x13,0x20,0x00,0x20,0x00,0x03,  /* 00000020    "... . .." */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000028    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000030    "........" */
+    0x00,0x20,0x00,0x03,0x00,0x00,0x00,0x00,  /* 00000038    ". ......" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000040    "........" */
+    0x00,0x00,0x00,0x00                       /* 00000048    "...."     */
+};
+
+const unsigned char TemplatePcct[] =
+{
+    0x50,0x43,0x43,0x54,0x06,0x01,0x00,0x00,  /* 00000000    "PCCT...." */
+    0x01,0xE3,0x49,0x4E,0x54,0x45,0x4C,0x20,  /* 00000008    "..INTEL " */
+    0x54,0x45,0x4D,0x50,0x4C,0x41,0x54,0x45,  /* 00000010    "TEMPLATE" */
+    0x01,0x00,0x00,0x00,0x49,0x4E,0x54,0x4C,  /* 00000018    "....INTL" */
+    0x18,0x03,0x16,0x20,0x01,0x00,0x00,0x00,  /* 00000020    "... ...." */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000028    "........" */
+    0x00,0x3E,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000030    ".>......" */
+    0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,  /* 00000038    "........" */
+    0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,  /* 00000040    """""""""" */
+    0x01,0x32,0x00,0x03,0x33,0x33,0x33,0x33,  /* 00000048    ".2..3333" */
+    0x33,0x33,0x33,0x33,0x44,0x44,0x44,0x44,  /* 00000050    "3333DDDD" */
+    0x44,0x44,0x44,0x44,0x55,0x55,0x55,0x55,  /* 00000058    "DDDDUUUU" */
+    0x55,0x55,0x55,0x55,0x66,0x66,0x66,0x66,  /* 00000060    "UUUUffff" */
+    0x77,0x77,0x77,0x77,0x88,0x88,0x01,0x3E,  /* 00000068    "wwww...>" */
+    0x01,0x00,0x00,0x00,0x01,0x00,0x00,0x00,  /* 00000070    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000078    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x32,  /* 00000080    ".......2" */
+    0x00,0x03,0x44,0x44,0x44,0x44,0x44,0x44,  /* 00000088    "..DDDDDD" */
+    0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,  /* 00000090    "DDDDDDDD" */
+    0x44,0x44,0x55,0x55,0x55,0x55,0x55,0x55,  /* 00000098    "DDUUUUUU" */
+    0x55,0x55,0x66,0x66,0x66,0x66,0x77,0x77,  /* 000000A0    "UUffffww" */
+    0x77,0x77,0x88,0x88,0x02,0x5A,0x01,0x00,  /* 000000A8    "ww...Z.." */
+    0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,  /* 000000B0    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 000000B8    "........" */
+    0x00,0x00,0x00,0x00,0x01,0x32,0x00,0x03,  /* 000000C0    ".....2.." */
+    0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,  /* 000000C8    "DDDDDDDD" */
+    0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,  /* 000000D0    "DDDDDDDD" */
+    0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,  /* 000000D8    "UUUUUUUU" */
+    0x66,0x66,0x66,0x66,0x77,0x77,0x77,0x77,  /* 000000E0    "ffffwwww" */
+    0x88,0x88,0x01,0x32,0x00,0x03,0x33,0x33,  /* 000000E8    "...2..33" */
+    0x33,0x33,0x33,0x33,0x33,0x33,0x44,0x44,  /* 000000F0    "333333DD" */
+    0x44,0x44,0x44,0x44,0x44,0x44,0x55,0x55,  /* 000000F8    "DDDDDDUU" */
+    0x55,0x55,0x55,0x55,0x55,0x55             /* 00000100    "UUUUUU"   */
+};
+
+const unsigned char TemplatePmtt[] =
+{
+    0x50,0x4D,0x54,0x54,0xB4,0x00,0x00,0x00,  /* 00000000    "PMTT...." */
+    0x01,0x3A,0x49,0x4E,0x54,0x45,0x4C,0x20,  /* 00000008    ".:INTEL " */
+    0x54,0x45,0x4D,0x50,0x4C,0x41,0x54,0x45,  /* 00000010    "TEMPLATE" */
+    0x01,0x00,0x00,0x00,0x49,0x4E,0x54,0x4C,  /* 00000018    "....INTL" */
+    0x26,0x08,0x11,0x20,0x00,0x00,0x00,0x00,  /* 00000020    "&.. ...." */
+    0x00,0x00,0x80,0x00,0x01,0x00,0x00,0x00,  /* 00000028    "........" */
+    0x00,0x00,0x00,0x00,0x01,0x00,0x54,0x00,  /* 00000030    "......T." */
+    0x05,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000038    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000040    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000048    "........" */
+    0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,  /* 00000050    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000058    "........" */
+    0x02,0x00,0x14,0x00,0x02,0x00,0x00,0x00,  /* 00000060    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000068    "........" */
+    0x00,0x00,0x00,0x00,0x02,0x00,0x14,0x00,  /* 00000070    "........" */
+    0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000078    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000080    "........" */
+    0x01,0x00,0x20,0x00,0x01,0x00,0x00,0x00,  /* 00000088    ".. ....." */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000090    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000098    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 000000A0    "........" */
+    0x00,0x00,0x0C,0x00,0x01,0x00,0x00,0x00,  /* 000000A8    "........" */
+    0x00,0x00,0x00,0x00                       /* 000000B0    "...."     */
+};
+
+const unsigned char TemplateRsdp[] =
+{
+    0x52,0x53,0x44,0x20,0x50,0x54,0x52,0x20,  /* 00000000    "RSD PTR " */
+    0x43,0x49,0x4E,0x54,0x45,0x4C,0x20,0x02,  /* 00000008    "CINTEL ." */
+    0x00,0x00,0x00,0x00,0x24,0x00,0x00,0x00,  /* 00000010    "....$..." */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000018    "........" */
+    0xDC,0x00,0x00,0x00                       /* 00000020    "...."     */
+};
+
+const unsigned char TemplateRsdt[] =
+{
+    0x52,0x53,0x44,0x54,0x44,0x00,0x00,0x00,  /* 00000000    "RSDTD..." */
+    0x01,0xB1,0x49,0x4E,0x54,0x45,0x4C,0x20,  /* 00000008    "..INTEL " */
+    0x54,0x45,0x4D,0x50,0x4C,0x41,0x54,0x45,  /* 00000010    "TEMPLATE" */
+    0x01,0x00,0x00,0x00,0x49,0x4E,0x54,0x4C,  /* 00000018    "....INTL" */
+    0x28,0x05,0x10,0x20,0x10,0x00,0x00,0x00,  /* 00000020    "(.. ...." */
+    0x20,0x00,0x00,0x00,0x30,0x00,0x00,0x00,  /* 00000028    " ...0..." */
+    0x40,0x00,0x00,0x00,0x50,0x00,0x00,0x00,  /* 00000030    "@...P..." */
+    0x60,0x00,0x00,0x00,0x70,0x00,0x00,0x00,  /* 00000038    "`...p..." */
+    0x80,0x00,0x00,0x00                       /* 00000040    "...."     */
+};
+
+const unsigned char TemplateS3pt[] =
+{
+    0x53,0x33,0x50,0x54,0x34,0x00,0x00,0x00,  /* 00000000    "S3PT4..." */
+    0x00,0x00,0x18,0x01,0x00,0x00,0x00,0x00,  /* 00000008    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000010    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000018    "........" */
+    0x01,0x00,0x14,0x01,0x00,0x00,0x00,0x00,  /* 00000020    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000028    "........" */
+    0x00,0x00,0x00,0x00                       /* 00000030    "...."     */
+};
+
+const unsigned char TemplateSbst[] =
+{
+    0x53,0x42,0x53,0x54,0x30,0x00,0x00,0x00,  /* 00000000    "SBST0..." */
+    0x01,0x06,0x49,0x4E,0x54,0x45,0x4C,0x20,  /* 00000008    "..INTEL " */
+    0x54,0x45,0x4D,0x50,0x4C,0x41,0x54,0x45,  /* 00000010    "TEMPLATE" */
+    0x01,0x00,0x00,0x00,0x49,0x4E,0x54,0x4C,  /* 00000018    "....INTL" */
+    0x28,0x05,0x10,0x20,0x00,0x00,0x00,0x00,  /* 00000020    "(.. ...." */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00   /* 00000028    "........" */
+};
+
+const unsigned char TemplateSlic[] =
+{
+    0x53,0x4C,0x49,0x43,0x76,0x01,0x00,0x00,  /* 00000000    "SLICv..." */
+    0x01,0x07,0x49,0x4E,0x54,0x45,0x4C,0x20,  /* 00000008    "..INTEL " */
+    0x54,0x45,0x4D,0x50,0x4C,0x41,0x54,0x45,  /* 00000010    "TEMPLATE" */
+    0x01,0x00,0x00,0x00,0x49,0x4E,0x54,0x4C,  /* 00000018    "....INTL" */
+    0x11,0x02,0x11,0x20,0x00,0x00,0x00,0x00,  /* 00000020    "... ...." */
+    0x9C,0x00,0x00,0x00,0x06,0x02,0x00,0x00,  /* 00000028    "........" */
+    0x00,0x24,0x00,0x00,0x52,0x53,0x41,0x31,  /* 00000030    ".$..RSA1" */
+    0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000038    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000040    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000048    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000050    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000058    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000060    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000068    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000070    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000078    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000080    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000088    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000090    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000098    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 000000A0    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 000000A8    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 000000B0    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 000000B8    "........" */
+    0x01,0x00,0x00,0x00,0xB6,0x00,0x00,0x00,  /* 000000C0    "........" */
+    0x00,0x00,0x02,0x00,0x49,0x4E,0x54,0x45,  /* 000000C8    "....INTE" */
+    0x4C,0x20,0x54,0x45,0x4D,0x50,0x4C,0x41,  /* 000000D0    "L TEMPLA" */
+    0x54,0x45,0x57,0x49,0x4E,0x44,0x4F,0x57,  /* 000000D8    "TEWINDOW" */
+    0x53,0x20,0x01,0x00,0x02,0x00,0x00,0x00,  /* 000000E0    "S ......" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 000000E8    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 000000F0    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 000000F8    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000100    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000108    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000110    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000118    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000120    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000128    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000130    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000138    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000140    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000148    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000150    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000158    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000160    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000168    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00             /* 00000170    "......"   */
+};
+
+const unsigned char TemplateSlit[] =
+{
+    0x53,0x4C,0x49,0x54,0xBC,0x01,0x00,0x00,  /* 00000000    "SLIT...." */
+    0x01,0x00,0x49,0x4E,0x54,0x45,0x4C,0x20,  /* 00000008    "..INTEL " */
+    0x54,0x45,0x4D,0x50,0x4C,0x41,0x54,0x45,  /* 00000010    "TEMPLATE" */
+    0x01,0x00,0x00,0x00,0x49,0x4E,0x54,0x4C,  /* 00000018    "....INTL" */
+    0x16,0x03,0x11,0x20,0x14,0x00,0x00,0x00,  /* 00000020    "... ...." */
+    0x00,0x00,0x00,0x00,0x0A,0x10,0x16,0x17,  /* 00000028    "........" */
+    0x18,0x19,0x1A,0x1B,0x1C,0x1D,0x1E,0x1F,  /* 00000030    "........" */
+    0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27,  /* 00000038    " !"#$%&'" */
+    0x10,0x0A,0x15,0x16,0x17,0x18,0x19,0x1A,  /* 00000040    "........" */
+    0x1B,0x1C,0x1D,0x1E,0x1F,0x20,0x21,0x22,  /* 00000048    "..... !"" */
+    0x23,0x24,0x25,0x26,0x16,0x15,0x0A,0x10,  /* 00000050    "#$%&...." */
+    0x16,0x17,0x18,0x19,0x1A,0x1B,0x1C,0x1D,  /* 00000058    "........" */
+    0x1E,0x1F,0x20,0x21,0x22,0x23,0x24,0x25,  /* 00000060    ".. !"#$%" */
+    0x17,0x16,0x10,0x0A,0x15,0x16,0x17,0x18,  /* 00000068    "........" */
+    0x19,0x1A,0x1B,0x1C,0x1D,0x1E,0x1F,0x20,  /* 00000070    "....... " */
+    0x21,0x22,0x23,0x24,0x18,0x17,0x16,0x15,  /* 00000078    "!"#$...." */
+    0x0A,0x10,0x16,0x17,0x18,0x19,0x1A,0x1B,  /* 00000080    "........" */
+    0x1C,0x1D,0x1E,0x1F,0x20,0x21,0x22,0x23,  /* 00000088    ".... !"#" */
+    0x19,0x18,0x17,0x16,0x10,0x0A,0x15,0x16,  /* 00000090    "........" */
+    0x17,0x18,0x19,0x1A,0x1B,0x1C,0x1D,0x1E,  /* 00000098    "........" */
+    0x1F,0x20,0x21,0x22,0x1A,0x19,0x18,0x17,  /* 000000A0    ". !"...." */
+    0x16,0x15,0x0A,0x10,0x16,0x17,0x18,0x19,  /* 000000A8    "........" */
+    0x1A,0x1B,0x1C,0x1D,0x1E,0x1F,0x20,0x21,  /* 000000B0    "...... !" */
+    0x1B,0x1A,0x19,0x18,0x17,0x16,0x10,0x0A,  /* 000000B8    "........" */
+    0x15,0x16,0x17,0x18,0x19,0x1A,0x1B,0x1C,  /* 000000C0    "........" */
+    0x1D,0x1E,0x1F,0x20,0x1C,0x1B,0x1A,0x19,  /* 000000C8    "... ...." */
+    0x18,0x17,0x16,0x15,0x0A,0x10,0x16,0x17,  /* 000000D0    "........" */
+    0x18,0x19,0x1A,0x1B,0x1C,0x1D,0x1E,0x1F,  /* 000000D8    "........" */
+    0x1D,0x1C,0x1B,0x1A,0x19,0x18,0x17,0x16,  /* 000000E0    "........" */
+    0x10,0x0A,0x15,0x16,0x17,0x18,0x19,0x1A,  /* 000000E8    "........" */
+    0x1B,0x1C,0x1D,0x1E,0x1E,0x1D,0x1C,0x1B,  /* 000000F0    "........" */
+    0x1A,0x19,0x18,0x17,0x16,0x15,0x0A,0x10,  /* 000000F8    "........" */
+    0x16,0x17,0x18,0x19,0x1A,0x1B,0x1C,0x1D,  /* 00000100    "........" */
+    0x1F,0x1E,0x1D,0x1C,0x1B,0x1A,0x19,0x18,  /* 00000108    "........" */
+    0x17,0x16,0x10,0x0A,0x15,0x16,0x17,0x18,  /* 00000110    "........" */
+    0x19,0x1A,0x1B,0x1C,0x20,0x1F,0x1E,0x1D,  /* 00000118    ".... ..." */
+    0x1C,0x1B,0x1A,0x19,0x18,0x17,0x16,0x15,  /* 00000120    "........" */
+    0x0A,0x10,0x16,0x17,0x18,0x19,0x1A,0x1B,  /* 00000128    "........" */
+    0x21,0x20,0x1F,0x1E,0x1D,0x1C,0x1B,0x1A,  /* 00000130    "! ......" */
+    0x19,0x18,0x17,0x16,0x10,0x0A,0x15,0x16,  /* 00000138    "........" */
+    0x17,0x18,0x19,0x1A,0x22,0x21,0x20,0x1F,  /* 00000140    "...."! ." */
+    0x1E,0x1D,0x1C,0x1B,0x1A,0x19,0x18,0x17,  /* 00000148    "........" */
+    0x16,0x15,0x0A,0x10,0x16,0x17,0x18,0x19,  /* 00000150    "........" */
+    0x23,0x22,0x21,0x20,0x1F,0x1E,0x1D,0x1C,  /* 00000158    "#"! ...." */
+    0x1B,0x1A,0x19,0x18,0x17,0x16,0x10,0x0A,  /* 00000160    "........" */
+    0x15,0x16,0x17,0x18,0x24,0x23,0x22,0x21,  /* 00000168    "....$#"!" */
+    0x20,0x1F,0x1E,0x1D,0x1C,0x1B,0x1A,0x19,  /* 00000170    " ......." */
+    0x18,0x17,0x16,0x15,0x0A,0x10,0x16,0x17,  /* 00000178    "........" */
+    0x25,0x24,0x23,0x22,0x21,0x20,0x1F,0x1E,  /* 00000180    "%$#"! .." */
+    0x1D,0x1C,0x1B,0x1A,0x19,0x18,0x17,0x16,  /* 00000188    "........" */
+    0x10,0x0A,0x15,0x16,0x26,0x25,0x24,0x23,  /* 00000190    "....&%$#" */
+    0x22,0x21,0x20,0x1F,0x1E,0x1D,0x1C,0x1B,  /* 00000198    ""! ....." */
+    0x1A,0x19,0x18,0x17,0x16,0x15,0x0A,0x10,  /* 000001A0    "........" */
+    0x27,0x26,0x25,0x24,0x23,0x22,0x21,0x20,  /* 000001A8    "'&%$#"! " */
+    0x1F,0x1E,0x1D,0x1C,0x1B,0x1A,0x19,0x18,  /* 000001B0    "........" */
+    0x17,0x16,0x10,0x0A                       /* 000001B8    "...."     */
+};
+
+const unsigned char TemplateSpcr[] =
+{
+    0x53,0x50,0x43,0x52,0x50,0x00,0x00,0x00,  /* 00000000    "SPCRP..." */
+    0x01,0xE3,0x49,0x4E,0x54,0x45,0x4C,0x20,  /* 00000008    "..INTEL " */
+    0x54,0x45,0x4D,0x50,0x4C,0x41,0x54,0x45,  /* 00000010    "TEMPLATE" */
+    0x00,0x00,0x00,0x00,0x49,0x4E,0x54,0x4C,  /* 00000018    "....INTL" */
+    0x28,0x05,0x10,0x20,0x00,0x00,0x00,0x00,  /* 00000020    "(.. ...." */
+    0x00,0x08,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000028    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000030    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000038    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000040    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00   /* 00000048    "........" */
+};
+
+const unsigned char TemplateSpmi[] =
+{
+    0x53,0x50,0x4D,0x49,0x41,0x00,0x00,0x00,  /* 00000000    "SPMIA..." */
+    0x04,0x00,0x49,0x4E,0x54,0x45,0x4C,0x20,  /* 00000008    "..INTEL " */
+    0x54,0x45,0x4D,0x50,0x4C,0x41,0x54,0x45,  /* 00000010    "TEMPLATE" */
+    0x00,0x00,0x00,0x00,0x49,0x4E,0x54,0x4C,  /* 00000018    "....INTL" */
+    0x14,0x01,0x14,0x20,0x00,0x01,0x00,0x00,  /* 00000020    "... ...." */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000028    "........" */
+    0x00,0x08,0x00,0x01,0x00,0x00,0x00,0x00,  /* 00000030    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000038    "........" */
+    0x00                                      /* 00000040    "."        */
+};
+
+const unsigned char TemplateSrat[] =
+{
+    0x53,0x52,0x41,0x54,0x92,0x00,0x00,0x00,  /* 00000000    "SRAT...." */
+    0x03,0x50,0x49,0x4E,0x54,0x45,0x4C,0x20,  /* 00000008    ".PINTEL " */
+    0x54,0x65,0x6D,0x70,0x6C,0x61,0x74,0x65,  /* 00000010    "Template" */
+    0x01,0x00,0x00,0x00,0x49,0x4E,0x54,0x4C,  /* 00000018    "....INTL" */
+    0x24,0x07,0x14,0x20,0x01,0x00,0x00,0x00,  /* 00000020    "$.. ...." */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000028    "........" */
+    0x00,0x10,0x00,0x00,0x01,0x00,0x00,0x00,  /* 00000030    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000038    "........" */
+    0x01,0x28,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000040    ".(......" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000048    "........" */
+    0x00,0xFC,0x09,0x00,0x00,0x00,0x00,0x00,  /* 00000050    "........" */
+    0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,  /* 00000058    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000060    "........" */
+    0x02,0x18,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000068    "........" */
+    0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,  /* 00000070    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000078    "........" */
+    0x03,0x12,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000080    "........" */
+    0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,  /* 00000088    "........" */
+    0x00,0x00                                 /* 00000090    ".."       */
+};
+
+const unsigned char TemplateStao[] =
+{
+    0x53,0x54,0x41,0x4F,0x7E,0x00,0x00,0x00,  /* 00000000    "STAO~..." */
+    0x01,0x7F,0x49,0x4E,0x54,0x45,0x4C,0x20,  /* 00000008    "..INTEL " */
+    0x54,0x45,0x4D,0x50,0x4C,0x41,0x54,0x45,  /* 00000010    "TEMPLATE" */
+    0x00,0x00,0x00,0x00,0x49,0x4E,0x54,0x4C,  /* 00000018    "....INTL" */
+    0x10,0x04,0x15,0x20,0x01,0x5C,0x5F,0x53,  /* 00000020    "... .\_S" */
+    0x42,0x30,0x2E,0x42,0x55,0x53,0x30,0x2E,  /* 00000028    "B0.BUS0." */
+    0x44,0x45,0x56,0x31,0x00,0x5C,0x5F,0x53,  /* 00000030    "DEV1.\_S" */
+    0x42,0x30,0x2E,0x42,0x55,0x53,0x30,0x2E,  /* 00000038    "B0.BUS0." */
+    0x44,0x45,0x56,0x32,0x00,0x5C,0x5F,0x53,  /* 00000040    "DEV2.\_S" */
+    0x42,0x30,0x2E,0x42,0x55,0x53,0x31,0x2E,  /* 00000048    "B0.BUS1." */
+    0x44,0x45,0x56,0x31,0x2E,0x44,0x45,0x56,  /* 00000050    "DEV1.DEV" */
+    0x32,0x00,0x5C,0x5F,0x53,0x42,0x30,0x2E,  /* 00000058    "2.\_SB0." */
+    0x42,0x55,0x53,0x31,0x2E,0x44,0x45,0x56,  /* 00000060    "BUS1.DEV" */
+    0x32,0x2E,0x44,0x45,0x56,0x32,0x00,0x5C,  /* 00000068    "2.DEV2.\" */
+    0x55,0x53,0x42,0x31,0x2E,0x48,0x55,0x42,  /* 00000070    "USB1.HUB" */
+    0x31,0x2E,0x50,0x54,0x31,0x00             /* 00000078    "1.PT1."   */
+};
+
+const unsigned char TemplateTcpa[] =
+{
+    0x54,0x43,0x50,0x41,0x64,0x00,0x00,0x00,  /* 00000000    "TCPAd..." */
+    0x02,0xFF,0x49,0x4E,0x54,0x45,0x4C,0x20,  /* 00000008    "..INTEL " */
+    0x54,0x65,0x6D,0x70,0x6C,0x61,0x74,0x65,  /* 00000010    "Template" */
+    0x80,0x31,0x00,0x00,0x49,0x4E,0x54,0x4C,  /* 00000018    ".1..INTL" */
+    0x19,0x06,0x15,0x20,0x01,0x00,0x00,0x00,  /* 00000020    "... ...." */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000028    "........" */
+    0x11,0x00,0xFF,0xEE,0xDD,0xCC,0xBB,0xAA,  /* 00000030    "........" */
+    0x02,0x01,0x00,0x00,0x01,0x00,0x00,0x00,  /* 00000038    "........" */
+    0x00,0x00,0x00,0x00,0x01,0x20,0x00,0x03,  /* 00000040    "..... .." */
+    0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000048    "........" */
+    0x00,0x00,0x00,0x00,0x01,0x20,0x00,0x03,  /* 00000050    "..... .." */
+    0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000058    "........" */
+    0x01,0x01,0x01,0x01                       /* 00000060    "...."     */
+};
+
+const unsigned char TemplateTpm2[] =
+{
+    0x54,0x50,0x4D,0x32,0x34,0x00,0x00,0x00,  /* 00000000    "TPM24..." */
+    0x03,0x42,0x49,0x4E,0x54,0x45,0x4C,0x20,  /* 00000008    ".BINTEL " */
+    0x54,0x45,0x4D,0x50,0x4C,0x41,0x54,0x45,  /* 00000010    "TEMPLATE" */
+    0x01,0x00,0x00,0x00,0x49,0x4E,0x54,0x4C,  /* 00000018    "....INTL" */
+    0x14,0x11,0x12,0x20,0x00,0x00,0x00,0x00,  /* 00000020    "... ...." */
+    0x77,0x66,0x55,0x44,0x33,0x22,0x11,0x00,  /* 00000028    "wfUD3".." */
+    0x01,0x00,0x00,0x00                       /* 00000030    "...."     */
+};
+
+const unsigned char TemplateUefi[] =
+{
+    0x55,0x45,0x46,0x49,0x36,0x00,0x00,0x00,  /* 00000000    "UEFI6..." */
+    0x01,0x9B,0x49,0x4E,0x54,0x45,0x4C,0x20,  /* 00000008    "..INTEL " */
+    0x54,0x45,0x4D,0x50,0x4C,0x41,0x54,0x45,  /* 00000010    "TEMPLATE" */
+    0x01,0x00,0x00,0x00,0x49,0x4E,0x54,0x4C,  /* 00000018    "....INTL" */
+    0x28,0x05,0x10,0x20,0x00,0x01,0x02,0x03,  /* 00000020    "(.. ...." */
+    0x04,0x05,0x06,0x07,0x08,0x09,0x0A,0x0B,  /* 00000028    "........" */
+    0x0C,0x0D,0x0E,0x0F,0x00,0x00             /* 00000030    "......"   */
+};
+
+const unsigned char TemplateVrtc[] =
+{
+    0x56,0x52,0x54,0x43,0x44,0x00,0x00,0x00,  /* 00000000    "VRTCD..." */
+    0x01,0xEF,0x49,0x4E,0x54,0x45,0x4C,0x20,  /* 00000008    "..INTEL " */
+    0x54,0x45,0x4D,0x50,0x4C,0x41,0x54,0x45,  /* 00000010    "TEMPLATE" */
+    0x03,0x00,0x00,0x00,0x49,0x4E,0x54,0x4C,  /* 00000018    "....INTL" */
+    0x17,0x01,0x13,0x20,0x00,0x08,0x00,0x00,  /* 00000020    "... ...." */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000028    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x08,0x00,0x00,  /* 00000030    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000038    "........" */
+    0x00,0x00,0x00,0x00                       /* 00000040    "...."     */
+};
+
+const unsigned char TemplateWaet[] =
+{
+    0x57,0x41,0x45,0x54,0x28,0x00,0x00,0x00,  /* 00000000    "WAET(..." */
+    0x01,0x19,0x49,0x4E,0x54,0x45,0x4C,0x20,  /* 00000008    "..INTEL " */
+    0x54,0x45,0x4D,0x50,0x4C,0x41,0x54,0x45,  /* 00000010    "TEMPLATE" */
+    0x01,0x00,0x00,0x00,0x49,0x4E,0x54,0x4C,  /* 00000018    "....INTL" */
+    0x28,0x05,0x10,0x20,0x00,0x00,0x00,0x00   /* 00000020    "(.. ...." */
+};
+
+const unsigned char TemplateWdat[] =
+{
+    0x57,0x44,0x41,0x54,0x5C,0x00,0x00,0x00,  /* 00000000    "WDAT\..." */
+    0x01,0xE3,0x49,0x4E,0x54,0x45,0x4C,0x20,  /* 00000008    "..INTEL " */
+    0x54,0x45,0x4D,0x50,0x4C,0x41,0x54,0x45,  /* 00000010    "TEMPLATE" */
+    0x00,0x00,0x00,0x00,0x49,0x4E,0x54,0x4C,  /* 00000018    "....INTL" */
+    0x28,0x05,0x10,0x20,0x20,0x00,0x00,0x00,  /* 00000020    "(..  ..." */
+    0xFF,0x00,0xFF,0xFF,0xFF,0x00,0x00,0x00,  /* 00000028    "........" */
+    0x58,0x02,0x00,0x00,0xFF,0x03,0x00,0x00,  /* 00000030    "X......." */
+    0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000038    "........" */
+    0x0E,0x00,0x00,0x00,0x01,0x02,0x00,0x00,  /* 00000040    "........" */
+    0x01,0x10,0x00,0x02,0x60,0x04,0x00,0x00,  /* 00000048    "....`..." */
+    0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,  /* 00000050    "........" */
+    0x01,0x00,0x00,0x00                       /* 00000058    "...."     */
+};
+
+const unsigned char TemplateWddt[] =
+{
+    0x57,0x44,0x44,0x54,0x40,0x00,0x00,0x00,  /* 00000000    "WDDT@..." */
+    0x01,0x00,0x49,0x4E,0x54,0x45,0x4C,0x20,  /* 00000008    "..INTEL " */
+    0x54,0x45,0x4D,0x50,0x4C,0x41,0x54,0x45,  /* 00000010    "TEMPLATE" */
+    0x00,0x00,0x00,0x00,0x49,0x4E,0x54,0x4C,  /* 00000018    "....INTL" */
+    0x28,0x05,0x10,0x20,0x00,0x00,0x00,0x00,  /* 00000020    "(.. ...." */
+    0x00,0x00,0x01,0xFF,0x00,0x00,0x00,0x00,  /* 00000028    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000030    "........" */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00   /* 00000038    "........" */
+};
+
+const unsigned char TemplateWdrt[] =
+{
+    0x57,0x44,0x52,0x54,0x47,0x00,0x00,0x00,  /* 00000000    "WDRTG..." */
+    0x01,0xB0,0x49,0x4E,0x54,0x45,0x4C,0x20,  /* 00000008    "..INTEL " */
+    0x54,0x45,0x4D,0x50,0x4C,0x41,0x54,0x45,  /* 00000010    "TEMPLATE" */
+    0x01,0x00,0x00,0x00,0x49,0x4E,0x54,0x4C,  /* 00000018    "....INTL" */
+    0x28,0x05,0x10,0x20,0x00,0x20,0x00,0x00,  /* 00000020    "(.. . .." */
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000028    "........" */
+    0x00,0x20,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000030    ". ......" */
+    0x00,0x00,0x00,0x00,0xFF,0xFF,0xFF,0xFF,  /* 00000038    "........" */
+    0x00,0x00,0x00,0x00,0xFF,0xFF,0x00        /* 00000040    "......."  */
+};
+
+const unsigned char TemplateWpbt[] =
+{
+    0x57,0x50,0x42,0x54,0x98,0x00,0x00,0x00,  /* 00000000    "WPBT...." */
+    0x01,0x83,0x49,0x4E,0x54,0x45,0x4C,0x20,  /* 00000008    "..INTEL " */
+    0x54,0x45,0x4D,0x50,0x4C,0x41,0x54,0x45,  /* 00000010    "TEMPLATE" */
+    0x01,0x00,0x00,0x00,0x49,0x4E,0x54,0x4C,  /* 00000018    "....INTL" */
+    0x10,0x04,0x15,0x20,0x78,0x56,0x34,0x12,  /* 00000020    "... xV4." */
+    0x00,0x00,0x00,0xBB,0x00,0x00,0x00,0xAA,  /* 00000028    "........" */
+    0x33,0x88,0x64,0x00,0x34,0x00,0x20,0x00,  /* 00000030    "3.d.4. ." */
+    0x73,0x00,0x63,0x00,0x6F,0x00,0x72,0x00,  /* 00000038    "s.c.o.r." */
+    0x65,0x00,0x20,0x00,0x61,0x00,0x6E,0x00,  /* 00000040    "e. .a.n." */
+    0x64,0x00,0x20,0x00,0x37,0x00,0x20,0x00,  /* 00000048    "d. .7. ." */
+    0x79,0x00,0x65,0x00,0x61,0x00,0x72,0x00,  /* 00000050    "y.e.a.r." */
+    0x73,0x00,0x20,0x00,0x61,0x00,0x67,0x00,  /* 00000058    "s. .a.g." */
+    0x6F,0x00,0x20,0x00,0x6F,0x00,0x75,0x00,  /* 00000060    "o. .o.u." */
+    0x72,0x00,0x20,0x00,0x66,0x00,0x61,0x00,  /* 00000068    "r. .f.a." */
+    0x74,0x00,0x68,0x00,0x65,0x00,0x72,0x00,  /* 00000070    "t.h.e.r." */
+    0x73,0x00,0x20,0x00,0x62,0x00,0x72,0x00,  /* 00000078    "s. .b.r." */
+    0x6F,0x00,0x75,0x00,0x67,0x00,0x68,0x00,  /* 00000080    "o.u.g.h." */
+    0x74,0x00,0x20,0x00,0x66,0x00,0x6F,0x00,  /* 00000088    "t. .f.o." */
+    0x72,0x00,0x74,0x00,0x68,0x00,0x00,0x00   /* 00000090    "r.t.h..." */
+};
+
+const unsigned char TemplateXenv[] =
+{
+    0x58,0x45,0x4E,0x56,0x39,0x00,0x00,0x00,  /* 00000000    "XENV9..." */
+    0x01,0x3A,0x49,0x4E,0x54,0x45,0x4C,0x20,  /* 00000008    ".:INTEL " */
+    0x54,0x45,0x4D,0x50,0x4C,0x41,0x54,0x45,  /* 00000010    "TEMPLATE" */
+    0x01,0x00,0x00,0x00,0x49,0x4E,0x54,0x4C,  /* 00000018    "....INTL" */
+    0x10,0x04,0x15,0x20,0x00,0x00,0x00,0x10,  /* 00000020    "... ...." */
+    0x00,0x00,0x00,0x0A,0x00,0x20,0x00,0x00,  /* 00000028    "..... .." */
+    0x00,0x00,0x00,0x0B,0x25,0x00,0xBB,0xAA,  /* 00000030    "....%..." */
+    0x03                                      /* 00000038    "."        */
+};
+
+const unsigned char TemplateXsdt[] =
+{
+    0x58,0x53,0x44,0x54,0x64,0x00,0x00,0x00,  /* 00000000    "XSDTd..." */
+    0x01,0x8B,0x49,0x4E,0x54,0x45,0x4C,0x20,  /* 00000008    "..INTEL " */
+    0x54,0x45,0x4D,0x50,0x4C,0x41,0x54,0x45,  /* 00000010    "TEMPLATE" */
+    0x01,0x00,0x00,0x00,0x49,0x4E,0x54,0x4C,  /* 00000018    "....INTL" */
+    0x28,0x05,0x10,0x20,0x10,0x00,0x00,0x00,  /* 00000020    "(.. ...." */
+    0x00,0x00,0x00,0x00,0x20,0x00,0x00,0x00,  /* 00000028    ".... ..." */
+    0x00,0x00,0x00,0x00,0x30,0x00,0x00,0x00,  /* 00000030    "....0..." */
+    0x00,0x00,0x00,0x00,0x40,0x00,0x00,0x00,  /* 00000038    "....@..." */
+    0x00,0x00,0x00,0x00,0x50,0x00,0x00,0x00,  /* 00000040    "....P..." */
+    0x00,0x00,0x00,0x00,0x60,0x00,0x00,0x00,  /* 00000048    "....`..." */
+    0x00,0x00,0x00,0x00,0x70,0x00,0x00,0x00,  /* 00000050    "....p..." */
+    0x00,0x00,0x00,0x00,0x80,0x00,0x00,0x00,  /* 00000058    "........" */
+    0x00,0x00,0x00,0x00                       /* 00000060    "...."     */
+};
+
+#endif
diff --git a/usr/src/cmd/acpi/iasl/dtutils.c b/usr/src/cmd/acpi/iasl/dtutils.c
new file mode 100644
index 0000000000..c9756da9c4
--- /dev/null
+++ b/usr/src/cmd/acpi/iasl/dtutils.c
@@ -0,0 +1,1001 @@
+/******************************************************************************
+ *
+ * Module Name: dtutils.c - Utility routines for the data table compiler
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2016, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include "aslcompiler.h"
+#include "dtcompiler.h"
+#include "actables.h"
+
+#define _COMPONENT          DT_COMPILER
+        ACPI_MODULE_NAME    ("dtutils")
+
+/* Local prototypes */
+
+static void
+DtSum (
+    DT_SUBTABLE             *Subtable,
+    void                    *Context,
+    void                    *ReturnValue);
+
+
+/******************************************************************************
+ *
+ * FUNCTION:    DtError
+ *
+ * PARAMETERS:  Level               - Seriousness (Warning/error, etc.)
+ *              MessageId           - Index into global message buffer
+ *              Op                  - Parse node where error happened
+ *              ExtraMessage        - additional error message
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Common error interface for data table compiler
+ *
+ *****************************************************************************/
+
+void
+DtError (
+    UINT8                   Level,
+    UINT16                  MessageId,
+    DT_FIELD                *FieldObject,
+    char                    *ExtraMessage)
+{
+
+    /* Check if user wants to ignore this exception */
+
+    if (AslIsExceptionDisabled (Level, MessageId))
+    {
+        return;
+    }
+
+    if (FieldObject)
+    {
+        AslCommonError (Level, MessageId,
+            FieldObject->Line,
+            FieldObject->Line,
+            FieldObject->ByteOffset,
+            FieldObject->Column,
+            Gbl_Files[ASL_FILE_INPUT].Filename, ExtraMessage);
+    }
+    else
+    {
+        AslCommonError (Level, MessageId, 0,
+            0, 0, 0, 0, ExtraMessage);
+    }
+}
+
+
+/******************************************************************************
+ *
+ * FUNCTION:    DtNameError
+ *
+ * PARAMETERS:  Level               - Seriousness (Warning/error, etc.)
+ *              MessageId           - Index into global message buffer
+ *              Op                  - Parse node where error happened
+ *              ExtraMessage        - additional error message
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Error interface for named objects
+ *
+ *****************************************************************************/
+
+void
+DtNameError (
+    UINT8                   Level,
+    UINT16                  MessageId,
+    DT_FIELD                *FieldObject,
+    char                    *ExtraMessage)
+{
+
+    switch (Level)
+    {
+    case ASL_WARNING2:
+    case ASL_WARNING3:
+
+        if (Gbl_WarningLevel < Level)
+        {
+            return;
+        }
+        break;
+
+    default:
+
+        break;
+    }
+
+    if (FieldObject)
+    {
+        AslCommonError (Level, MessageId,
+            FieldObject->Line,
+            FieldObject->Line,
+            FieldObject->ByteOffset,
+            FieldObject->NameColumn,
+            Gbl_Files[ASL_FILE_INPUT].Filename, ExtraMessage);
+    }
+    else
+    {
+        AslCommonError (Level, MessageId, 0,
+            0, 0, 0, 0, ExtraMessage);
+    }
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    DtFatal
+ *
+ * PARAMETERS:  None
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Dump the error log and abort the compiler. Used for serious
+ *              compile or I/O errors
+ *
+ ******************************************************************************/
+
+void
+DtFatal (
+    UINT16                  MessageId,
+    DT_FIELD                *FieldObject,
+    char                    *ExtraMessage)
+{
+
+    DtError (ASL_ERROR, MessageId, FieldObject, ExtraMessage);
+
+/*
+ * TBD: remove this entire function, DtFatal
+ *
+ * We cannot abort the compiler on error, because we may be compiling a
+ * list of files. We must move on to the next file.
+ */
+#ifdef __OBSOLETE
+    CmCleanupAndExit ();
+    exit (1);
+#endif
+}
+
+
+/******************************************************************************
+ *
+ * FUNCTION:    DtStrtoul64
+ *
+ * PARAMETERS:  String              - Null terminated string
+ *              ReturnInteger       - Where the converted integer is returned
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Simple conversion of a string hex integer constant to unsigned
+ *              value. Assumes no leading "0x" for the constant.
+ *
+ * Portability note: The reason this function exists is because a 64-bit
+ * sscanf is not available in all environments.
+ *
+ *****************************************************************************/
+
+ACPI_STATUS
+DtStrtoul64 (
+    char                    *String,
+    UINT64                  *ReturnInteger)
+{
+    char                    *ThisChar = String;
+    UINT32                  ThisDigit;
+    UINT64                  ReturnValue = 0;
+    int                     DigitCount = 0;
+
+
+    /* Skip over any white space in the buffer */
+
+    while ((*ThisChar == ' ') || (*ThisChar == '\t'))
+    {
+        ThisChar++;
+    }
+
+    /* Skip leading zeros */
+
+    while ((*ThisChar) == '0')
+    {
+        ThisChar++;
+    }
+
+    /* Convert character-by-character */
+
+    while (*ThisChar)
+    {
+        if (isdigit ((int) *ThisChar))
+        {
+            /* Convert ASCII 0-9 to Decimal value */
+
+            ThisDigit = ((UINT8) *ThisChar) - '0';
+        }
+        else /* Letter */
+        {
+            ThisDigit = (UINT32) toupper ((int) *ThisChar);
+            if (!isxdigit ((int) ThisDigit))
+            {
+                /* Not A-F */
+
+                return (AE_BAD_CHARACTER);
+            }
+
+            /* Convert ASCII Hex char (A-F) to value */
+
+            ThisDigit = (ThisDigit - 'A') + 10;
+        }
+
+        /* Insert the 4-bit hex digit */
+
+        ReturnValue <<= 4;
+        ReturnValue += ThisDigit;
+
+        ThisChar++;
+        DigitCount++;
+        if (DigitCount > 16)
+        {
+            /* Value is too large (> 64 bits/8 bytes/16 hex digits) */
+
+            return (AE_LIMIT);
+        }
+    }
+
+    *ReturnInteger = ReturnValue;
+    return (AE_OK);
+}
+
+
+/******************************************************************************
+ *
+ * FUNCTION:    DtGetFieldValue
+ *
+ * PARAMETERS:  Field               - Current field list pointer
+ *
+ * RETURN:      Field value
+ *
+ * DESCRIPTION: Get field value
+ *
+ *****************************************************************************/
+
+char *
+DtGetFieldValue (
+    DT_FIELD                *Field)
+{
+    if (!Field)
+    {
+        return (NULL);
+    }
+
+    return (Field->Value);
+}
+
+
+/******************************************************************************
+ *
+ * FUNCTION:    DtGetFieldType
+ *
+ * PARAMETERS:  Info                - Data table info
+ *
+ * RETURN:      Field type
+ *
+ * DESCRIPTION: Get field type
+ *
+ *****************************************************************************/
+
+UINT8
+DtGetFieldType (
+    ACPI_DMTABLE_INFO       *Info)
+{
+    UINT8                   Type;
+
+
+    /* DT_FLAG means that this is the start of a block of flag bits */
+    /* TBD - we can make these a separate opcode later */
+
+    if (Info->Flags & DT_FLAG)
+    {
+        return (DT_FIELD_TYPE_FLAGS_INTEGER);
+    }
+
+    /* Type is based upon the opcode for this field in the info table */
+
+    switch (Info->Opcode)
+    {
+    case ACPI_DMT_FLAG0:
+    case ACPI_DMT_FLAG1:
+    case ACPI_DMT_FLAG2:
+    case ACPI_DMT_FLAG3:
+    case ACPI_DMT_FLAG4:
+    case ACPI_DMT_FLAG5:
+    case ACPI_DMT_FLAG6:
+    case ACPI_DMT_FLAG7:
+    case ACPI_DMT_FLAGS0:
+    case ACPI_DMT_FLAGS1:
+    case ACPI_DMT_FLAGS2:
+    case ACPI_DMT_FLAGS4:
+
+        Type = DT_FIELD_TYPE_FLAG;
+        break;
+
+    case ACPI_DMT_NAME4:
+    case ACPI_DMT_SIG:
+    case ACPI_DMT_NAME6:
+    case ACPI_DMT_NAME8:
+    case ACPI_DMT_STRING:
+
+        Type = DT_FIELD_TYPE_STRING;
+        break;
+
+    case ACPI_DMT_BUFFER:
+    case ACPI_DMT_RAW_BUFFER:
+    case ACPI_DMT_BUF7:
+    case ACPI_DMT_BUF10:
+    case ACPI_DMT_BUF16:
+    case ACPI_DMT_BUF128:
+    case ACPI_DMT_PCI_PATH:
+
+        Type = DT_FIELD_TYPE_BUFFER;
+        break;
+
+    case ACPI_DMT_GAS:
+    case ACPI_DMT_HESTNTFY:
+    case ACPI_DMT_IORTMEM:
+
+        Type = DT_FIELD_TYPE_INLINE_SUBTABLE;
+        break;
+
+    case ACPI_DMT_UNICODE:
+
+        Type = DT_FIELD_TYPE_UNICODE;
+        break;
+
+    case ACPI_DMT_UUID:
+
+        Type = DT_FIELD_TYPE_UUID;
+        break;
+
+    case ACPI_DMT_DEVICE_PATH:
+
+        Type = DT_FIELD_TYPE_DEVICE_PATH;
+        break;
+
+    case ACPI_DMT_LABEL:
+
+        Type = DT_FIELD_TYPE_LABEL;
+        break;
+
+    default:
+
+        Type = DT_FIELD_TYPE_INTEGER;
+        break;
+    }
+
+    return (Type);
+}
+
+
+/******************************************************************************
+ *
+ * FUNCTION:    DtGetBufferLength
+ *
+ * PARAMETERS:  Buffer              - List of integers,
+ *                                    for example "10 3A 4F 2E"
+ *
+ * RETURN:      Count of integer
+ *
+ * DESCRIPTION: Get length of bytes needed to store the integers
+ *
+ *****************************************************************************/
+
+UINT32
+DtGetBufferLength (
+    char                    *Buffer)
+{
+    UINT32                  ByteLength = 0;
+
+
+    while (*Buffer)
+    {
+        if (*Buffer == ' ')
+        {
+            ByteLength++;
+
+            while (*Buffer == ' ')
+            {
+                Buffer++;
+            }
+        }
+
+        Buffer++;
+    }
+
+    return (++ByteLength);
+}
+
+
+/******************************************************************************
+ *
+ * FUNCTION:    DtGetFieldLength
+ *
+ * PARAMETERS:  Field               - Current field
+ *              Info                - Data table info
+ *
+ * RETURN:      Field length
+ *
+ * DESCRIPTION: Get length of bytes needed to compile the field
+ *
+ * Note: This function must remain in sync with AcpiDmDumpTable.
+ *
+ *****************************************************************************/
+
+UINT32
+DtGetFieldLength (
+    DT_FIELD                *Field,
+    ACPI_DMTABLE_INFO       *Info)
+{
+    UINT32                  ByteLength = 0;
+    char                    *Value;
+
+
+    /* Length is based upon the opcode for this field in the info table */
+
+    switch (Info->Opcode)
+    {
+    case ACPI_DMT_FLAG0:
+    case ACPI_DMT_FLAG1:
+    case ACPI_DMT_FLAG2:
+    case ACPI_DMT_FLAG3:
+    case ACPI_DMT_FLAG4:
+    case ACPI_DMT_FLAG5:
+    case ACPI_DMT_FLAG6:
+    case ACPI_DMT_FLAG7:
+    case ACPI_DMT_FLAGS0:
+    case ACPI_DMT_FLAGS1:
+    case ACPI_DMT_FLAGS2:
+    case ACPI_DMT_FLAGS4:
+    case ACPI_DMT_LABEL:
+    case ACPI_DMT_EXTRA_TEXT:
+
+        ByteLength = 0;
+        break;
+
+    case ACPI_DMT_UINT8:
+    case ACPI_DMT_CHKSUM:
+    case ACPI_DMT_SPACEID:
+    case ACPI_DMT_ACCWIDTH:
+    case ACPI_DMT_IVRS:
+    case ACPI_DMT_GTDT:
+    case ACPI_DMT_MADT:
+    case ACPI_DMT_PCCT:
+    case ACPI_DMT_PMTT:
+    case ACPI_DMT_SRAT:
+    case ACPI_DMT_ASF:
+    case ACPI_DMT_HESTNTYP:
+    case ACPI_DMT_FADTPM:
+    case ACPI_DMT_EINJACT:
+    case ACPI_DMT_EINJINST:
+    case ACPI_DMT_ERSTACT:
+    case ACPI_DMT_ERSTINST:
+    case ACPI_DMT_DMAR_SCOPE:
+
+        ByteLength = 1;
+        break;
+
+    case ACPI_DMT_UINT16:
+    case ACPI_DMT_DMAR:
+    case ACPI_DMT_HEST:
+    case ACPI_DMT_NFIT:
+    case ACPI_DMT_PCI_PATH:
+
+        ByteLength = 2;
+        break;
+
+    case ACPI_DMT_UINT24:
+
+        ByteLength = 3;
+        break;
+
+    case ACPI_DMT_UINT32:
+    case ACPI_DMT_NAME4:
+    case ACPI_DMT_SIG:
+    case ACPI_DMT_LPIT:
+
+        ByteLength = 4;
+        break;
+
+    case ACPI_DMT_UINT40:
+
+        ByteLength = 5;
+        break;
+
+    case ACPI_DMT_UINT48:
+    case ACPI_DMT_NAME6:
+
+        ByteLength = 6;
+        break;
+
+    case ACPI_DMT_UINT56:
+    case ACPI_DMT_BUF7:
+
+        ByteLength = 7;
+        break;
+
+    case ACPI_DMT_UINT64:
+    case ACPI_DMT_NAME8:
+
+        ByteLength = 8;
+        break;
+
+    case ACPI_DMT_STRING:
+
+        Value = DtGetFieldValue (Field);
+        if (Value)
+        {
+            ByteLength = strlen (Value) + 1;
+        }
+        else
+        {   /* At this point, this is a fatal error */
+
+            sprintf (MsgBuffer, "Expected \"%s\"", Info->Name);
+            DtFatal (ASL_MSG_COMPILER_INTERNAL, NULL, MsgBuffer);
+            return (0);
+        }
+        break;
+
+    case ACPI_DMT_GAS:
+
+        ByteLength = sizeof (ACPI_GENERIC_ADDRESS);
+        break;
+
+    case ACPI_DMT_HESTNTFY:
+
+        ByteLength = sizeof (ACPI_HEST_NOTIFY);
+        break;
+
+    case ACPI_DMT_IORTMEM:
+
+        ByteLength = sizeof (ACPI_IORT_MEMORY_ACCESS);
+        break;
+
+    case ACPI_DMT_BUFFER:
+    case ACPI_DMT_RAW_BUFFER:
+
+        Value = DtGetFieldValue (Field);
+        if (Value)
+        {
+            ByteLength = DtGetBufferLength (Value);
+        }
+        else
+        {   /* At this point, this is a fatal error */
+
+            sprintf (MsgBuffer, "Expected \"%s\"", Info->Name);
+            DtFatal (ASL_MSG_COMPILER_INTERNAL, NULL, MsgBuffer);
+            return (0);
+        }
+        break;
+
+    case ACPI_DMT_BUF10:
+
+        ByteLength = 10;
+        break;
+
+    case ACPI_DMT_BUF16:
+    case ACPI_DMT_UUID:
+
+        ByteLength = 16;
+        break;
+
+    case ACPI_DMT_BUF128:
+
+        ByteLength = 128;
+        break;
+
+    case ACPI_DMT_UNICODE:
+
+        Value = DtGetFieldValue (Field);
+
+        /* TBD: error if Value is NULL? (as below?) */
+
+        ByteLength = (strlen (Value) + 1) * sizeof(UINT16);
+        break;
+
+    default:
+
+        DtFatal (ASL_MSG_COMPILER_INTERNAL, Field, "Invalid table opcode");
+        return (0);
+    }
+
+    return (ByteLength);
+}
+
+
+/******************************************************************************
+ *
+ * FUNCTION:    DtSum
+ *
+ * PARAMETERS:  DT_WALK_CALLBACK:
+ *              Subtable            - Subtable
+ *              Context             - Unused
+ *              ReturnValue         - Store the checksum of subtable
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Get the checksum of subtable
+ *
+ *****************************************************************************/
+
+static void
+DtSum (
+    DT_SUBTABLE             *Subtable,
+    void                    *Context,
+    void                    *ReturnValue)
+{
+    UINT8                   Checksum;
+    UINT8                   *Sum = ReturnValue;
+
+
+    Checksum = AcpiTbChecksum (Subtable->Buffer, Subtable->Length);
+    *Sum = (UINT8) (*Sum + Checksum);
+}
+
+
+/******************************************************************************
+ *
+ * FUNCTION:    DtSetTableChecksum
+ *
+ * PARAMETERS:  ChecksumPointer     - Where to return the checksum
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Set checksum of the whole data table into the checksum field
+ *
+ *****************************************************************************/
+
+void
+DtSetTableChecksum (
+    UINT8                   *ChecksumPointer)
+{
+    UINT8                   Checksum = 0;
+    UINT8                   OldSum;
+
+
+    DtWalkTableTree (Gbl_RootTable, DtSum, NULL, &Checksum);
+
+    OldSum = *ChecksumPointer;
+    Checksum = (UINT8) (Checksum - OldSum);
+
+    /* Compute the final checksum */
+
+    Checksum = (UINT8) (0 - Checksum);
+    *ChecksumPointer = Checksum;
+}
+
+
+/******************************************************************************
+ *
+ * FUNCTION:    DtSetTableLength
+ *
+ * PARAMETERS:  None
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Walk the subtables and set all the length fields
+ *
+ *****************************************************************************/
+
+void
+DtSetTableLength (
+    void)
+{
+    DT_SUBTABLE             *ParentTable;
+    DT_SUBTABLE             *ChildTable;
+
+
+    ParentTable = Gbl_RootTable;
+    ChildTable = NULL;
+
+    if (!ParentTable)
+    {
+        return;
+    }
+
+    DtSetSubtableLength (ParentTable);
+
+    while (1)
+    {
+        ChildTable = DtGetNextSubtable (ParentTable, ChildTable);
+        if (ChildTable)
+        {
+            if (ChildTable->LengthField)
+            {
+                DtSetSubtableLength (ChildTable);
+            }
+
+            if (ChildTable->Child)
+            {
+                ParentTable = ChildTable;
+                ChildTable = NULL;
+            }
+            else
+            {
+                ParentTable->TotalLength += ChildTable->TotalLength;
+                if (ParentTable->LengthField)
+                {
+                    DtSetSubtableLength (ParentTable);
+                }
+            }
+        }
+        else
+        {
+            ChildTable = ParentTable;
+
+            if (ChildTable == Gbl_RootTable)
+            {
+                break;
+            }
+
+            ParentTable = DtGetParentSubtable (ParentTable);
+
+            ParentTable->TotalLength += ChildTable->TotalLength;
+            if (ParentTable->LengthField)
+            {
+                DtSetSubtableLength (ParentTable);
+            }
+        }
+    }
+}
+
+
+/******************************************************************************
+ *
+ * FUNCTION:    DtWalkTableTree
+ *
+ * PARAMETERS:  StartTable          - Subtable in the tree where walking begins
+ *              UserFunction        - Called during the walk
+ *              Context             - Passed to user function
+ *              ReturnValue         - The return value of UserFunction
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Performs a depth-first walk of the subtable tree
+ *
+ *****************************************************************************/
+
+void
+DtWalkTableTree (
+    DT_SUBTABLE             *StartTable,
+    DT_WALK_CALLBACK        UserFunction,
+    void                    *Context,
+    void                    *ReturnValue)
+{
+    DT_SUBTABLE             *ParentTable;
+    DT_SUBTABLE             *ChildTable;
+
+
+    ParentTable = StartTable;
+    ChildTable = NULL;
+
+    if (!ParentTable)
+    {
+        return;
+    }
+
+    UserFunction (ParentTable, Context, ReturnValue);
+
+    while (1)
+    {
+        ChildTable = DtGetNextSubtable (ParentTable, ChildTable);
+        if (ChildTable)
+        {
+            UserFunction (ChildTable, Context, ReturnValue);
+
+            if (ChildTable->Child)
+            {
+                ParentTable = ChildTable;
+                ChildTable = NULL;
+            }
+        }
+        else
+        {
+            ChildTable = ParentTable;
+            if (ChildTable == Gbl_RootTable)
+            {
+                break;
+            }
+
+            ParentTable = DtGetParentSubtable (ParentTable);
+
+            if (ChildTable->Peer == StartTable)
+            {
+                break;
+            }
+        }
+    }
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    UtSubtableCacheCalloc
+ *
+ * PARAMETERS:  None
+ *
+ * RETURN:      Pointer to the buffer. Aborts on allocation failure
+ *
+ * DESCRIPTION: Allocate a subtable object buffer. Bypass the local
+ *              dynamic memory manager for performance reasons (This has a
+ *              major impact on the speed of the compiler.)
+ *
+ ******************************************************************************/
+
+DT_SUBTABLE *
+UtSubtableCacheCalloc (
+    void)
+{
+    ASL_CACHE_INFO          *Cache;
+
+
+    if (Gbl_SubtableCacheNext >= Gbl_SubtableCacheLast)
+    {
+        /* Allocate a new buffer */
+
+        Cache = UtLocalCalloc (sizeof (Cache->Next) +
+            (sizeof (DT_SUBTABLE) * ASL_SUBTABLE_CACHE_SIZE));
+
+        /* Link new cache buffer to head of list */
+
+        Cache->Next = Gbl_SubtableCacheList;
+        Gbl_SubtableCacheList = Cache;
+
+        /* Setup cache management pointers */
+
+        Gbl_SubtableCacheNext = ACPI_CAST_PTR (DT_SUBTABLE, Cache->Buffer);
+        Gbl_SubtableCacheLast = Gbl_SubtableCacheNext + ASL_SUBTABLE_CACHE_SIZE;
+    }
+
+    Gbl_SubtableCount++;
+    return (Gbl_SubtableCacheNext++);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    UtFieldCacheCalloc
+ *
+ * PARAMETERS:  None
+ *
+ * RETURN:      Pointer to the buffer. Aborts on allocation failure
+ *
+ * DESCRIPTION: Allocate a field object buffer. Bypass the local
+ *              dynamic memory manager for performance reasons (This has a
+ *              major impact on the speed of the compiler.)
+ *
+ ******************************************************************************/
+
+DT_FIELD *
+UtFieldCacheCalloc (
+    void)
+{
+    ASL_CACHE_INFO          *Cache;
+
+
+    if (Gbl_FieldCacheNext >= Gbl_FieldCacheLast)
+    {
+        /* Allocate a new buffer */
+
+        Cache = UtLocalCalloc (sizeof (Cache->Next) +
+            (sizeof (DT_FIELD) * ASL_FIELD_CACHE_SIZE));
+
+        /* Link new cache buffer to head of list */
+
+        Cache->Next = Gbl_FieldCacheList;
+        Gbl_FieldCacheList = Cache;
+
+        /* Setup cache management pointers */
+
+        Gbl_FieldCacheNext = ACPI_CAST_PTR (DT_FIELD, Cache->Buffer);
+        Gbl_FieldCacheLast = Gbl_FieldCacheNext + ASL_FIELD_CACHE_SIZE;
+    }
+
+    Gbl_FieldCount++;
+    return (Gbl_FieldCacheNext++);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    DtDeleteCaches
+ *
+ * PARAMETERS:  None
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Delete all local cache buffer blocks
+ *
+ ******************************************************************************/
+
+void
+DtDeleteCaches (
+    void)
+{
+    UINT32                  BufferCount;
+    ASL_CACHE_INFO          *Next;
+
+
+    /* Field cache */
+
+    BufferCount = 0;
+    while (Gbl_FieldCacheList)
+    {
+        Next = Gbl_FieldCacheList->Next;
+        ACPI_FREE (Gbl_FieldCacheList);
+        Gbl_FieldCacheList = Next;
+        BufferCount++;
+    }
+
+    DbgPrint (ASL_DEBUG_OUTPUT,
+        "%u Fields, Buffer size: %u fields (%u bytes), %u Buffers\n",
+        Gbl_FieldCount, ASL_FIELD_CACHE_SIZE,
+        (sizeof (DT_FIELD) * ASL_FIELD_CACHE_SIZE), BufferCount);
+
+    Gbl_FieldCount = 0;
+    Gbl_FieldCacheNext = NULL;
+    Gbl_FieldCacheLast = NULL;
+
+    /* Subtable cache */
+
+    BufferCount = 0;
+    while (Gbl_SubtableCacheList)
+    {
+        Next = Gbl_SubtableCacheList->Next;
+        ACPI_FREE (Gbl_SubtableCacheList);
+        Gbl_SubtableCacheList = Next;
+        BufferCount++;
+    }
+
+    DbgPrint (ASL_DEBUG_OUTPUT,
+        "%u Subtables, Buffer size: %u subtables (%u bytes), %u Buffers\n",
+        Gbl_SubtableCount, ASL_SUBTABLE_CACHE_SIZE,
+        (sizeof (DT_SUBTABLE) * ASL_SUBTABLE_CACHE_SIZE), BufferCount);
+
+    Gbl_SubtableCount = 0;
+    Gbl_SubtableCacheNext = NULL;
+    Gbl_SubtableCacheLast = NULL;
+}
diff --git a/usr/src/cmd/acpi/iasl/new_table.txt b/usr/src/cmd/acpi/iasl/new_table.txt
new file mode 100644
index 0000000000..1e48d385b6
--- /dev/null
+++ b/usr/src/cmd/acpi/iasl/new_table.txt
@@ -0,0 +1,88 @@
+How to add a new ACPI table to ACPICA and the iASL compiler.
+------------------------------------------------------------
+
+There are four main tasks that are needed to provide support for a
+new ACPI table:
+    1) Create a full definition of the table and any subtables
+       in the ACPICA headers.
+    2) Add disassembler support for the new table
+    3) Add iASL table compiler support for the new table
+    4) Create a default template for the new table for iASL -T
+       option.
+
+Notes for each of these tasks provided below.
+
+
+1) Header Support
+-----------------
+
+New tables should be added to the appropriate header:
+    actbl2.h: Used for new tables that are not defined in the ACPI spec.
+    actbl3.h: Used for new tables that are defined in the ACPI spec.
+
+Use ACPI_TABLE_HEADER for the common ACPI table header.
+Subtables should be defined separately from the main table.
+Don't add placeholder fields for subtables and other multiple data items.
+    (Don't use xxxxx[1] for a field that can have multiple items.)
+    The disassembler and data table compiler depends on this.
+For tables not defined in the ACPI spec, add a comment to indicate where
+    the table came from.
+Use other table definitions for additional guidance.
+
+
+2) iASL Disassembler Support
+----------------------------
+
+Add definition of the table (and subtables) in common/dmtbinfo.c
+Add table access macro(s) of the form ACPI_xxxx_OFFSET
+Add ACPI_DMT_TERMINATOR at the end of every table/subtable definition
+
+Add externals for the table/subtable definitions in acdisasm.h
+Add an entry for the new table in the AcpiDmTableData in common/dmtable.c
+
+If there are no subtables, add the AcpiDmTableInfoXXXX name to the
+    AcpiDmTableData and it will automatically be disassembled.
+
+If there are subtables, a dump routine must be written:
+Add an AcpiDmDumpXXXX function to dmtbdump.c -- note, code for another
+    similar table can often be ported for the new table.
+Add an external for this function to acdisasm.h
+Add this function to the AcpiDmTableData entry for the new ACPI table
+
+Debug/Test: Either find an existing example of the new ACPI table, or
+    create one using the "generic ACPI table support" included in the
+    iASL data table compiler. Use the -G option to force a
+    generic compile. It is often best to create the table from scratch,
+    since this clearly exposes the dependencies (lengths, offsets, etc.)
+    that the Table Compiler support will need to generate.
+
+
+3) iASL Table Compiler Support
+------------------------------
+
+Simple tables do not require a compile routine. The definition of the
+    table in common/dmtbinfo.c (created in step 2 above) will suffice.
+
+Complex tables with subtables will require a compile routine with a name
+    of the form DtCompileXXXX.
+Add a DtCompileXXXX function to the dttable.c module.
+Add an external for this function in dtcompiler.h
+Add this function to the AcpiDmTableData entry for the new ACPI table
+    in common/dmtable.c
+
+
+4) Template Support (-T iASL option)
+------------------------------------
+
+Create an example of the new ACPI table. This example should create
+    multiple subtables (if supported), and multiple instances of any
+    variable length data.
+
+Compile the example file with the -sc option. This will create a C
+    array that contains the table contents.
+
+Add this array to the dttemplate.h file. Name the array TemplateXXXX.
+Add this array name to the AcpiDmTableData entry for the new ACPI table
+
+Debug/Test: Create the template file. Compile the file. Disassemble the file.
+    Compile the disassembly file.
diff --git a/usr/src/cmd/acpi/iasl/preprocess.h b/usr/src/cmd/acpi/iasl/preprocess.h
new file mode 100644
index 0000000000..50759b5462
--- /dev/null
+++ b/usr/src/cmd/acpi/iasl/preprocess.h
@@ -0,0 +1,292 @@
+/******************************************************************************
+ *
+ * Module Name: preprocess.h - header for iASL Preprocessor
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2016, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#define __PREPROCESS_H__
+
+#ifndef _PREPROCESS
+#define _PREPROCESS
+
+#undef PR_EXTERN
+
+#ifdef _DECLARE_PR_GLOBALS
+#define PR_EXTERN
+#define PR_INIT_GLOBAL(a,b)         (a)=(b)
+#else
+#define PR_EXTERN                   extern
+#define PR_INIT_GLOBAL(a,b)         (a)
+#endif
+
+
+/*
+ * Configuration
+ */
+#define PR_MAX_MACRO_ARGS       32              /* Max number of macro args */
+#define PR_MAX_ARG_INSTANCES    24              /* Max instances of any one arg */
+#define PR_LINES_PER_BLOCK      4096            /* Max input source lines per block */
+
+
+/*
+ * Local defines and macros
+ */
+#define PR_TOKEN_SEPARATORS     " ,(){}\t\n"
+#define PR_MACRO_SEPARATORS     " ,(){}~!*/%+-<>=&^|\"\t\n"
+#define PR_MACRO_ARGUMENTS      " ,\t\n"
+#define PR_EXPR_SEPARATORS      " ,(){}~!*/%+-<>=&^|\"\t\n"
+
+#define PR_PREFIX_ID            "Pr(%.4u) - "             /* Used for debug output */
+
+#define THIS_TOKEN_OFFSET(t)    ((t-Gbl_MainTokenBuffer) + 1)
+
+
+/*
+ * Preprocessor structures
+ */
+typedef struct pr_macro_arg
+{
+    char                        *Name;
+    UINT32                      Offset[PR_MAX_ARG_INSTANCES];
+    UINT16                      UseCount;
+
+} PR_MACRO_ARG;
+
+typedef struct pr_define_info
+{
+    struct pr_define_info       *Previous;
+    struct pr_define_info       *Next;
+    char                        *Identifier;
+    char                        *Replacement;
+    char                        *Body;          /* Macro body */
+    PR_MACRO_ARG                *Args;          /* Macro arg list */
+    UINT16                      ArgCount;       /* Macro arg count */
+    BOOLEAN                     Persist;        /* Keep for entire compiler run */
+
+} PR_DEFINE_INFO;
+
+typedef struct pr_directive_info
+{
+    char                        *Name;          /* Directive name */
+    UINT8                       ArgCount;       /* Required # of args */
+
+} PR_DIRECTIVE_INFO;
+
+typedef struct pr_operator_info
+{
+    char                        *Op;
+
+} PR_OPERATOR_INFO;
+
+typedef struct pr_file_node
+{
+    struct pr_file_node         *Next;
+    FILE                        *File;
+    char                        *Filename;
+    UINT32                      CurrentLineNumber;
+
+} PR_FILE_NODE;
+
+#define MAX_ARGUMENT_LENGTH     24
+
+typedef struct directive_info
+{
+    struct directive_info       *Next;
+    char                        Argument[MAX_ARGUMENT_LENGTH];
+    int                         Directive;
+    BOOLEAN                     IgnoringThisCodeBlock;
+
+} DIRECTIVE_INFO;
+
+
+/*
+ * Globals
+ */
+#if 0 /* TBD for macros */
+PR_EXTERN char                  PR_INIT_GLOBAL (*XXXEvalBuffer, NULL); /* [ASL_LINE_BUFFER_SIZE]; */
+#endif
+
+PR_EXTERN char                  PR_INIT_GLOBAL (*Gbl_MainTokenBuffer, NULL); /* [ASL_LINE_BUFFER_SIZE]; */
+PR_EXTERN char                  PR_INIT_GLOBAL (*Gbl_MacroTokenBuffer, NULL); /* [ASL_LINE_BUFFER_SIZE]; */
+PR_EXTERN char                  PR_INIT_GLOBAL (*Gbl_ExpressionTokenBuffer, NULL); /* [ASL_LINE_BUFFER_SIZE]; */
+
+PR_EXTERN UINT32                Gbl_PreprocessorLineNumber;
+PR_EXTERN int                   Gbl_IfDepth;
+PR_EXTERN PR_FILE_NODE          *Gbl_InputFileList;
+PR_EXTERN PR_DEFINE_INFO        PR_INIT_GLOBAL (*Gbl_DefineList, NULL);
+PR_EXTERN BOOLEAN               PR_INIT_GLOBAL (Gbl_PreprocessorError, FALSE);
+PR_EXTERN BOOLEAN               PR_INIT_GLOBAL (Gbl_IgnoringThisCodeBlock, FALSE);
+PR_EXTERN DIRECTIVE_INFO        PR_INIT_GLOBAL (*Gbl_DirectiveStack, NULL);
+
+/*
+ * prscan - Preprocessor entry
+ */
+void
+PrInitializePreprocessor (
+    void);
+
+void
+PrInitializeGlobals (
+    void);
+
+void
+PrTerminatePreprocessor (
+    void);
+
+void
+PrDoPreprocess (
+    void);
+
+UINT64
+PrIsDefined (
+    char                    *Identifier);
+
+UINT64
+PrResolveDefine (
+    char                    *Identifier);
+
+int
+PrInitLexer (
+    char                    *String);
+
+void
+PrTerminateLexer (
+    void);
+
+
+/*
+ * prmacros - Support for #defines and macros
+ */
+void
+PrDumpPredefinedNames (
+    void);
+
+PR_DEFINE_INFO *
+PrAddDefine (
+    char                    *Token,
+    char                    *Token2,
+    BOOLEAN                 Persist);
+
+void
+PrRemoveDefine (
+    char                    *DefineName);
+
+PR_DEFINE_INFO *
+PrMatchDefine (
+    char                    *MatchString);
+
+void
+PrAddMacro (
+    char                    *Name,
+    char                    **Next);
+
+void
+PrDoMacroInvocation (
+    char                    *TokenBuffer,
+    char                    *MacroStart,
+    PR_DEFINE_INFO          *DefineInfo,
+    char                    **Next);
+
+
+/*
+ * prexpress - #if expression support
+ */
+ACPI_STATUS
+PrResolveIntegerExpression (
+    char                    *Line,
+    UINT64                  *ReturnValue);
+
+char *
+PrPrioritizeExpression (
+    char                    *OriginalLine);
+
+/*
+ * prparser - lex/yacc expression parser
+ */
+UINT64
+PrEvaluateExpression (
+    char                    *ExprString);
+
+
+/*
+ * prutils - Preprocesor utilities
+ */
+char *
+PrGetNextToken (
+    char                    *Buffer,
+    char                    *MatchString,
+    char                    **Next);
+
+void
+PrError (
+    UINT8                   Level,
+    UINT16                  MessageId,
+    UINT32                  Column);
+
+void
+PrReplaceData (
+    char                    *Buffer,
+    UINT32                  LengthToRemove,
+    char                    *BufferToAdd,
+    UINT32                  LengthToAdd);
+
+FILE *
+PrOpenIncludeFile (
+    char                    *Filename,
+    char                    *OpenMode,
+    char                    **FullPathname);
+
+FILE *
+PrOpenIncludeWithPrefix (
+    char                    *PrefixDir,
+    char                    *Filename,
+    char                    *OpenMode,
+    char                    **FullPathname);
+
+void
+PrPushInputFileStack (
+    FILE                    *InputFile,
+    char                    *Filename);
+
+BOOLEAN
+PrPopInputFileStack (
+    void);
+
+#endif
diff --git a/usr/src/cmd/acpi/iasl/prexpress.c b/usr/src/cmd/acpi/iasl/prexpress.c
new file mode 100644
index 0000000000..b6bc801f25
--- /dev/null
+++ b/usr/src/cmd/acpi/iasl/prexpress.c
@@ -0,0 +1,306 @@
+/******************************************************************************
+ *
+ * Module Name: prexpress - Preprocessor #if expression support
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2016, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include "aslcompiler.h"
+#include "dtcompiler.h"
+
+
+#define _COMPONENT          ASL_PREPROCESSOR
+        ACPI_MODULE_NAME    ("prexpress")
+
+/* Local prototypes */
+
+static char *
+PrExpandMacros (
+    char                    *Line);
+
+
+#ifdef _UNDER_DEVELOPMENT
+/******************************************************************************
+ *
+ * FUNCTION:    PrUnTokenize
+ *
+ * PARAMETERS:  Buffer              - Token Buffer
+ *              Next                - "Next" buffer from GetNextToken
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Un-tokenized the current token buffer. The implementation is
+ *              to simply set the null inserted by GetNextToken to a blank.
+ *              If Next is NULL, there were no tokens found in the Buffer,
+ *              so there is nothing to do.
+ *
+ *****************************************************************************/
+
+static void
+PrUnTokenize (
+    char                    *Buffer,
+    char                    *Next)
+{
+    UINT32                  Length = strlen (Buffer);
+
+
+    if (!Next)
+    {
+        return;
+    }
+
+    if (Buffer[Length] != '\n')
+    {
+        Buffer[strlen(Buffer)] = ' ';
+    }
+}
+#endif
+
+
+/******************************************************************************
+ *
+ * FUNCTION:    PrExpandMacros
+ *
+ * PARAMETERS:  Line                - Pointer into the current line
+ *
+ * RETURN:      Updated pointer into the current line
+ *
+ * DESCRIPTION: Expand any macros found in the current line buffer.
+ *
+ *****************************************************************************/
+
+static char *
+PrExpandMacros (
+    char                    *Line)
+{
+    char                    *Token;
+    char                    *ReplaceString;
+    PR_DEFINE_INFO          *DefineInfo;
+    ACPI_SIZE               TokenOffset;
+    char                    *Next;
+    int                     OffsetAdjust;
+
+
+    strcpy (Gbl_ExpressionTokenBuffer, Gbl_CurrentLineBuffer);
+    Token = PrGetNextToken (Gbl_ExpressionTokenBuffer, PR_EXPR_SEPARATORS, &Next);
+    OffsetAdjust = 0;
+
+    while (Token)
+    {
+        DefineInfo = PrMatchDefine (Token);
+        if (DefineInfo)
+        {
+            if (DefineInfo->Body)
+            {
+                /* This is a macro. TBD: Is this allowed? */
+
+                DbgPrint (ASL_DEBUG_OUTPUT, PR_PREFIX_ID
+                    "Matched Macro: %s->%s\n",
+                    Gbl_CurrentLineNumber, DefineInfo->Identifier,
+                    DefineInfo->Replacement);
+
+                PrDoMacroInvocation (Gbl_ExpressionTokenBuffer, Token,
+                    DefineInfo, &Next);
+            }
+            else
+            {
+                ReplaceString = DefineInfo->Replacement;
+
+                /* Replace the name in the original line buffer */
+
+                TokenOffset = Token - Gbl_ExpressionTokenBuffer + OffsetAdjust;
+                PrReplaceData (
+                    &Gbl_CurrentLineBuffer[TokenOffset], strlen (Token),
+                    ReplaceString, strlen (ReplaceString));
+
+                /* Adjust for length difference between old and new name length */
+
+                OffsetAdjust += strlen (ReplaceString) - strlen (Token);
+
+                DbgPrint (ASL_DEBUG_OUTPUT, PR_PREFIX_ID
+                    "Matched #define within expression: %s->%s\n",
+                    Gbl_CurrentLineNumber, Token,
+                    *ReplaceString ? ReplaceString : "(NULL STRING)");
+            }
+        }
+
+        Token = PrGetNextToken (NULL, PR_EXPR_SEPARATORS, &Next);
+    }
+
+    return (Line);
+}
+
+
+/******************************************************************************
+ *
+ * FUNCTION:    PrIsDefined
+ *
+ * PARAMETERS:  Identifier          - Name to be resolved
+ *
+ * RETURN:      64-bit boolean integer value
+ *
+ * DESCRIPTION: Returns TRUE if the name is defined, FALSE otherwise (0).
+ *
+ *****************************************************************************/
+
+UINT64
+PrIsDefined (
+    char                    *Identifier)
+{
+    UINT64                  Value;
+    PR_DEFINE_INFO          *DefineInfo;
+
+
+    DbgPrint (ASL_DEBUG_OUTPUT, PR_PREFIX_ID
+        "**** Is defined?:  %s\n", Gbl_CurrentLineNumber, Identifier);
+
+    Value = 0; /* Default is "Not defined" -- FALSE */
+
+    DefineInfo = PrMatchDefine (Identifier);
+    if (DefineInfo)
+    {
+        Value = ACPI_UINT64_MAX; /* TRUE */
+    }
+
+    DbgPrint (ASL_DEBUG_OUTPUT, PR_PREFIX_ID
+        "[#if defined %s] resolved to: %8.8X%8.8X\n",
+        Gbl_CurrentLineNumber, Identifier, ACPI_FORMAT_UINT64 (Value));
+
+    return (Value);
+}
+
+
+/******************************************************************************
+ *
+ * FUNCTION:    PrResolveDefine
+ *
+ * PARAMETERS:  Identifier          - Name to be resolved
+ *
+ * RETURN:      A 64-bit boolean integer value
+ *
+ * DESCRIPTION: Returns TRUE if the name is defined, FALSE otherwise (0).
+ *
+ *****************************************************************************/
+
+UINT64
+PrResolveDefine (
+    char                    *Identifier)
+{
+    UINT64                  Value;
+    PR_DEFINE_INFO          *DefineInfo;
+
+
+    DbgPrint (ASL_DEBUG_OUTPUT, PR_PREFIX_ID
+        "**** Resolve #define:  %s\n", Gbl_CurrentLineNumber, Identifier);
+
+    Value = 0; /* Default is "Not defined" -- FALSE */
+
+    DefineInfo = PrMatchDefine (Identifier);
+    if (DefineInfo)
+    {
+        Value = ACPI_UINT64_MAX; /* TRUE */
+    }
+
+    DbgPrint (ASL_DEBUG_OUTPUT, PR_PREFIX_ID
+        "[#if defined %s] resolved to: %8.8X%8.8X\n",
+        Gbl_CurrentLineNumber, Identifier, ACPI_FORMAT_UINT64 (Value));
+
+    return (Value);
+}
+
+
+/******************************************************************************
+ *
+ * FUNCTION:    PrResolveIntegerExpression
+ *
+ * PARAMETERS:  Line                - Pointer to integer expression
+ *              ReturnValue         - Where the resolved 64-bit integer is
+ *                                    returned.
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Resolve an integer expression to a single value. Supports
+ *              both integer constants and labels.
+ *
+ *****************************************************************************/
+
+ACPI_STATUS
+PrResolveIntegerExpression (
+    char                    *Line,
+    UINT64                  *ReturnValue)
+{
+    UINT64                  Result;
+    char                    *ExpandedLine;
+
+
+    DbgPrint (ASL_DEBUG_OUTPUT, PR_PREFIX_ID
+        "**** Resolve #if:  %s\n", Gbl_CurrentLineNumber, Line);
+
+    /* Expand all macros within the expression first */
+
+    ExpandedLine = PrExpandMacros (Line);
+
+    /* Now we can evaluate the expression */
+
+    Result = PrEvaluateExpression (ExpandedLine);
+    DbgPrint (ASL_DEBUG_OUTPUT, PR_PREFIX_ID
+        "**** Expression Resolved to: %8.8X%8.8X\n",
+        Gbl_CurrentLineNumber, ACPI_FORMAT_UINT64 (Result));
+
+    *ReturnValue = Result;
+    return (AE_OK);
+
+#if 0
+InvalidExpression:
+
+    ACPI_FREE (EvalBuffer);
+    PrError (ASL_ERROR, ASL_MSG_INVALID_EXPRESSION, 0);
+    return (AE_ERROR);
+
+
+NormalExit:
+
+    DbgPrint (ASL_DEBUG_OUTPUT, PR_PREFIX_ID
+        "**** Expression Resolved to: %8.8X%8.8X\n",
+        Gbl_CurrentLineNumber, ACPI_FORMAT_UINT64 (Value1));
+
+    *ReturnValue = Value1;
+    return (AE_OK);
+#endif
+}
diff --git a/usr/src/cmd/acpi/iasl/prmacros.c b/usr/src/cmd/acpi/iasl/prmacros.c
new file mode 100644
index 0000000000..8ad9236138
--- /dev/null
+++ b/usr/src/cmd/acpi/iasl/prmacros.c
@@ -0,0 +1,582 @@
+/******************************************************************************
+ *
+ * Module Name: prmacros - Preprocessor #define macro support
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2016, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include "aslcompiler.h"
+#include "dtcompiler.h"
+
+
+#define _COMPONENT          ASL_PREPROCESSOR
+        ACPI_MODULE_NAME    ("prmacros")
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    PrDumpPredefinedNames
+ *
+ * PARAMETERS:  None
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Dump the list of #defines. Used as the preprocessor starts, to
+ *              display the names that were defined on the command line.
+ *              Debug information only.
+ *
+ ******************************************************************************/
+
+void
+PrDumpPredefinedNames (
+    void)
+{
+    PR_DEFINE_INFO          *DefineInfo;
+
+
+    DefineInfo = Gbl_DefineList;
+    while (DefineInfo)
+    {
+        DbgPrint (ASL_DEBUG_OUTPUT, PR_PREFIX_ID
+            "Predefined #define: %s->%s\n",
+            0, DefineInfo->Identifier, DefineInfo->Replacement);
+
+        DefineInfo = DefineInfo->Next;
+    }
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    PrAddDefine
+ *
+ * PARAMETERS:  Identifier          - Name to be replaced
+ *              Replacement         - Replacement for Identifier
+ *              Persist             - Keep define across multiple compiles?
+ *
+ * RETURN:      A new define_info struct. NULL on error.
+ *
+ * DESCRIPTION: Add a new #define to the global list
+ *
+ ******************************************************************************/
+
+PR_DEFINE_INFO *
+PrAddDefine (
+    char                    *Identifier,
+    char                    *Replacement,
+    BOOLEAN                 Persist)
+{
+    char                    *IdentifierString;
+    char                    *ReplacementString;
+    PR_DEFINE_INFO          *DefineInfo;
+
+
+    if (!Replacement)
+    {
+        Replacement = "";
+    }
+
+    /* Check for already-defined first */
+
+    DefineInfo = PrMatchDefine (Identifier);
+    if (DefineInfo)
+    {
+        DbgPrint (ASL_DEBUG_OUTPUT, PR_PREFIX_ID,
+            "#define: name already exists: %s\n",
+            Gbl_CurrentLineNumber, Identifier);
+
+        /*
+         * Name already exists. This is only an error if the target name
+         * is different.
+         */
+        if (strcmp (Replacement, DefineInfo->Replacement))
+        {
+            PrError (ASL_ERROR, ASL_MSG_EXISTING_NAME,
+                THIS_TOKEN_OFFSET (Identifier));
+
+            return (NULL);
+        }
+
+        return (DefineInfo);
+    }
+
+    /* Copy input strings */
+
+    IdentifierString = UtLocalCalloc (strlen (Identifier) + 1);
+    strcpy (IdentifierString, Identifier);
+
+    ReplacementString = UtLocalCalloc (strlen (Replacement) + 1);
+    strcpy (ReplacementString, Replacement);
+
+    /* Init and link new define info struct */
+
+    DefineInfo = UtLocalCalloc (sizeof (PR_DEFINE_INFO));
+    DefineInfo->Replacement = ReplacementString;
+    DefineInfo->Identifier = IdentifierString;
+    DefineInfo->Persist = Persist;
+
+    if (Gbl_DefineList)
+    {
+        Gbl_DefineList->Previous = DefineInfo;
+    }
+
+    DefineInfo->Next = Gbl_DefineList;
+    Gbl_DefineList = DefineInfo;
+    return (DefineInfo);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    PrRemoveDefine
+ *
+ * PARAMETERS:  DefineName          - Name of define to be removed
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Implements #undef. Remove a #define if found in the global
+ *              list. No error if the target of the #undef does not exist,
+ *              as per the C #undef definition.
+ *
+ ******************************************************************************/
+
+void
+PrRemoveDefine (
+    char                    *DefineName)
+{
+    PR_DEFINE_INFO          *DefineInfo;
+
+
+    /* Match name and delete the node */
+
+    DefineInfo = Gbl_DefineList;
+    while (DefineInfo)
+    {
+        if (!strcmp (DefineName, DefineInfo->Identifier))
+        {
+            /* Remove from linked list */
+
+            if (DefineInfo->Previous)
+            {
+                (DefineInfo->Previous)->Next = DefineInfo->Next;
+            }
+            else
+            {
+                Gbl_DefineList = DefineInfo->Next;
+            }
+
+            if (DefineInfo->Next)
+            {
+                (DefineInfo->Next)->Previous = DefineInfo->Previous;
+            }
+
+            free (DefineInfo);
+            return;
+        }
+
+        DefineInfo = DefineInfo->Next;
+    }
+
+    /*
+     * Name was not found. By definition of #undef, this is not
+     * an error, however.
+     */
+    DbgPrint (ASL_DEBUG_OUTPUT, PR_PREFIX_ID
+        "#undef: could not find %s\n",
+        Gbl_CurrentLineNumber, DefineName);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    PrMatchDefine
+ *
+ * PARAMETERS:  MatchString         - Name associated with the #define
+ *
+ * RETURN:      Matched string if found. NULL otherwise.
+ *
+ * DESCRIPTION: Find a name in global #define list
+ *
+ ******************************************************************************/
+
+PR_DEFINE_INFO *
+PrMatchDefine (
+    char                    *MatchString)
+{
+    PR_DEFINE_INFO          *DefineInfo;
+
+
+    DefineInfo = Gbl_DefineList;
+    while (DefineInfo)
+    {
+        if (!strcmp (MatchString, DefineInfo->Identifier))
+        {
+            return (DefineInfo);
+        }
+
+        DefineInfo = DefineInfo->Next;
+    }
+
+    return (NULL);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    PrAddMacro
+ *
+ * PARAMETERS:  Name                - Start of the macro definition
+ *              Next                - "Next" buffer from GetNextToken
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Add a new macro to the list of #defines. Handles argument
+ *              processing.
+ *
+ ******************************************************************************/
+
+void
+PrAddMacro (
+    char                    *Name,
+    char                    **Next)
+{
+    char                    *Token = NULL;
+    ACPI_SIZE               TokenOffset;
+    ACPI_SIZE               MacroBodyOffset;
+    PR_DEFINE_INFO          *DefineInfo;
+    PR_MACRO_ARG            *Args;
+    char                    *Body;
+    char                    *BodyInSource;
+    UINT32                  i;
+    UINT16                  UseCount = 0;
+    UINT16                  ArgCount = 0;
+    UINT32                  Depth = 1;
+    UINT32                  EndOfArgList;
+    char                    BufferChar;
+
+
+    /* Find the end of the arguments list */
+
+    TokenOffset = Name - Gbl_MainTokenBuffer + strlen (Name) + 1;
+    while (1)
+    {
+        BufferChar = Gbl_CurrentLineBuffer[TokenOffset];
+        if (BufferChar == '(')
+        {
+            Depth++;
+        }
+        else if (BufferChar == ')')
+        {
+            Depth--;
+        }
+        else if (BufferChar == 0)
+        {
+            PrError (ASL_ERROR, ASL_MSG_MACRO_SYNTAX, TokenOffset);
+            return;
+        }
+
+        if (Depth == 0)
+        {
+            /* Found arg list end */
+
+            EndOfArgList = TokenOffset;
+            break;
+        }
+
+        TokenOffset++;
+    }
+
+    /* At this point, we know that we have a reasonable argument list */
+
+    Args = UtLocalCalloc (sizeof (PR_MACRO_ARG) * PR_MAX_MACRO_ARGS);
+
+    /* Get the macro argument names */
+
+    for (i = 0; i < PR_MAX_MACRO_ARGS; i++)
+    {
+        Token = PrGetNextToken (NULL, PR_MACRO_SEPARATORS, Next);
+        if (!Token)
+        {
+            /* This is the case for a NULL macro body */
+
+            BodyInSource = "";
+            goto AddMacroToList;
+        }
+
+        /* Don't go beyond the argument list */
+
+        TokenOffset = Token - Gbl_MainTokenBuffer + strlen (Token);
+        if (TokenOffset > EndOfArgList)
+        {
+            break;
+        }
+
+        DbgPrint (ASL_DEBUG_OUTPUT, PR_PREFIX_ID
+            "Macro arg: %s \n",
+            Gbl_CurrentLineNumber, Token);
+
+        Args[i].Name = UtLocalCalloc (strlen (Token) + 1);
+        strcpy (Args[i].Name, Token);
+
+        Args[i].UseCount = 0;
+
+        ArgCount++;
+        if (ArgCount >= PR_MAX_MACRO_ARGS)
+        {
+            PrError (ASL_ERROR, ASL_MSG_TOO_MANY_ARGUMENTS, TokenOffset);
+            goto ErrorExit;
+        }
+    }
+
+    /* Get the macro body. Token now points to start of body */
+
+    MacroBodyOffset = Token - Gbl_MainTokenBuffer;
+
+    /* Match each method arg in the macro body for later use */
+
+    Token = PrGetNextToken (NULL, PR_MACRO_SEPARATORS, Next);
+    while (Token)
+    {
+        /* Search the macro arg list for matching arg */
+
+        for (i = 0; Args[i].Name && (i < PR_MAX_MACRO_ARGS); i++)
+        {
+            /*
+             * Save argument offset within macro body. This is the mechanism
+             * used to expand the macro upon invocation.
+             *
+             * Handles multiple instances of the same argument
+             */
+            if (!strcmp (Token, Args[i].Name))
+            {
+                UseCount = Args[i].UseCount;
+
+                Args[i].Offset[UseCount] =
+                    (Token - Gbl_MainTokenBuffer) - MacroBodyOffset;
+
+                DbgPrint (ASL_DEBUG_OUTPUT, PR_PREFIX_ID
+                    "Macro Arg #%u: %s UseCount %u Offset %u \n",
+                    Gbl_CurrentLineNumber, i, Token,
+                    UseCount+1, Args[i].Offset[UseCount]);
+
+                Args[i].UseCount++;
+                if (Args[i].UseCount >= PR_MAX_ARG_INSTANCES)
+                {
+                    PrError (ASL_ERROR, ASL_MSG_TOO_MANY_ARGUMENTS,
+                        THIS_TOKEN_OFFSET (Token));
+
+                    goto ErrorExit;
+                }
+                break;
+            }
+        }
+
+        Token = PrGetNextToken (NULL, PR_MACRO_SEPARATORS, Next);
+    }
+
+    BodyInSource = &Gbl_CurrentLineBuffer[MacroBodyOffset];
+
+
+AddMacroToList:
+
+    /* Check if name is already defined first */
+
+    DefineInfo = PrMatchDefine (Name);
+    if (DefineInfo)
+    {
+        DbgPrint (ASL_DEBUG_OUTPUT, PR_PREFIX_ID
+            "#define: macro name already exists: %s\n",
+            Gbl_CurrentLineNumber, Name);
+
+        /* Error only if not exactly the same macro */
+
+        if (strcmp (DefineInfo->Body, BodyInSource) ||
+            (DefineInfo->ArgCount != ArgCount))
+        {
+            PrError (ASL_ERROR, ASL_MSG_EXISTING_NAME,
+                THIS_TOKEN_OFFSET (Name));
+        }
+
+        goto ErrorExit;
+    }
+
+    DbgPrint (ASL_DEBUG_OUTPUT, PR_PREFIX_ID
+        "Macro body: %s \n",
+        Gbl_CurrentLineNumber, BodyInSource);
+
+    /* Add macro to the #define list */
+
+    DefineInfo = PrAddDefine (Name, BodyInSource, FALSE);
+    if (DefineInfo)
+    {
+        Body = UtLocalCalloc (strlen (BodyInSource) + 1);
+        strcpy (Body, BodyInSource);
+
+        DefineInfo->Body = Body;
+        DefineInfo->Args = Args;
+        DefineInfo->ArgCount = ArgCount;
+    }
+
+    return;
+
+
+ErrorExit:
+    ACPI_FREE (Args);
+    return;
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    PrDoMacroInvocation
+ *
+ * PARAMETERS:  TokenBuffer         - Current line buffer
+ *              MacroStart          - Start of the macro invocation within
+ *                                    the token buffer
+ *              DefineInfo          - Info for this macro
+ *              Next                - "Next" buffer from GetNextToken
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Expand a macro invocation
+ *
+ ******************************************************************************/
+
+void
+PrDoMacroInvocation (
+    char                    *TokenBuffer,
+    char                    *MacroStart,
+    PR_DEFINE_INFO          *DefineInfo,
+    char                    **Next)
+{
+    PR_MACRO_ARG            *Args;
+    char                    *Token = NULL;
+    UINT32                  TokenOffset;
+    UINT32                  Length;
+    UINT32                  i;
+
+
+    /* Take a copy of the macro body for expansion */
+
+    strcpy (Gbl_MacroTokenBuffer, DefineInfo->Body);
+
+    /* Replace each argument within the prototype body */
+
+    Args = DefineInfo->Args;
+    if (!Args->Name)
+    {
+        /* This macro has no arguments */
+
+        Token = PrGetNextToken (NULL, PR_MACRO_ARGUMENTS, Next);
+        if (!Token)
+        {
+            goto BadInvocation;
+        }
+
+        TokenOffset = (MacroStart - TokenBuffer);
+        Length = Token - MacroStart + strlen (Token) + 1;
+
+        PrReplaceData (
+            &Gbl_CurrentLineBuffer[TokenOffset], Length,
+            Gbl_MacroTokenBuffer, strlen (Gbl_MacroTokenBuffer));
+        return;
+    }
+
+    while (Args->Name)
+    {
+        /* Get the next argument from macro invocation */
+
+        Token = PrGetNextToken (NULL, PR_MACRO_SEPARATORS, Next);
+        if (!Token)
+        {
+            goto BadInvocation;
+        }
+
+        /* Replace all instances of this argument */
+
+        for (i = 0; i < Args->UseCount; i++)
+        {
+            /* Offset zero indicates "arg not used" */
+            /* TBD: Not really needed now, with UseCount available */
+
+            if (Args->Offset[i] == 0)
+            {
+                break;
+            }
+
+            PrReplaceData (
+                &Gbl_MacroTokenBuffer[Args->Offset[i]], strlen (Args->Name),
+                Token, strlen (Token));
+
+            DbgPrint (ASL_DEBUG_OUTPUT, PR_PREFIX_ID
+                "ExpandArg: %s \n",
+                Gbl_CurrentLineNumber, Gbl_MacroTokenBuffer);
+        }
+
+        Args++;
+    }
+
+    /* TBD: need to make sure macro was not invoked with too many arguments */
+
+    if (!Token)
+    {
+        return;
+    }
+
+    /* Replace the entire macro invocation with the expanded macro */
+
+    TokenOffset = (MacroStart - TokenBuffer);
+    Length = Token - MacroStart + strlen (Token) + 1;
+
+    PrReplaceData (
+        &Gbl_CurrentLineBuffer[TokenOffset], Length,
+        Gbl_MacroTokenBuffer, strlen (Gbl_MacroTokenBuffer));
+
+    return;
+
+
+BadInvocation:
+    PrError (ASL_ERROR, ASL_MSG_INVALID_INVOCATION,
+        THIS_TOKEN_OFFSET (MacroStart));
+
+    DbgPrint (ASL_DEBUG_OUTPUT, PR_PREFIX_ID
+        "Bad macro invocation: %s \n",
+        Gbl_CurrentLineNumber, Gbl_MacroTokenBuffer);
+    return;
+}
diff --git a/usr/src/cmd/acpi/iasl/prparser.l b/usr/src/cmd/acpi/iasl/prparser.l
new file mode 100644
index 0000000000..3056699119
--- /dev/null
+++ b/usr/src/cmd/acpi/iasl/prparser.l
@@ -0,0 +1,236 @@
+%{
+/******************************************************************************
+ *
+ * Module Name: prparser.l - Flex input file for preprocessor lexer
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2016, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include "aslcompiler.h"
+#include "prparser.y.h"
+
+/* Buffer to pass strings to the parser */
+
+#define STRING_SETUP    strcpy (StringBuffer, PrParsertext);\
+    PrParserlval.str = StringBuffer
+
+#define _COMPONENT          ACPI_COMPILER
+        ACPI_MODULE_NAME    ("prscanner")
+
+
+/* Local prototypes */
+
+static char
+PrDoCommentType1 (
+    void);
+
+static char
+PrDoCommentType2 (
+    void);
+%}
+
+%option noyywrap
+
+Number          [0-9a-fA-F]+
+HexNumber       0[xX][0-9a-fA-F]+
+WhiteSpace      [ \t\v\r]+
+NewLine         [\n]
+Identifier      [a-zA-Z][0-9a-zA-Z]*
+
+%%
+"/*"            { if (!PrDoCommentType1 ()) {yyterminate ();} }
+"//"            { if (!PrDoCommentType2 ()) {yyterminate ();} }
+
+\(              return (EXPOP_PAREN_OPEN);
+\)              return (EXPOP_PAREN_CLOSE);
+\~              return (EXPOP_ONES_COMPLIMENT);
+\!              return (EXPOP_LOGICAL_NOT);
+\*              return (EXPOP_MULTIPLY);
+\/              return (EXPOP_DIVIDE);
+\%              return (EXPOP_MODULO);
+\+              return (EXPOP_ADD);
+\-              return (EXPOP_SUBTRACT);
+">>"            return (EXPOP_SHIFT_RIGHT);
+"<<"            return (EXPOP_SHIFT_LEFT);
+\<              return (EXPOP_LESS);
+\>              return (EXPOP_GREATER);
+"<="            return (EXPOP_LESS_EQUAL);
+">="            return (EXPOP_GREATER_EQUAL);
+"=="            return (EXPOP_EQUAL);
+"!="            return (EXPOP_NOT_EQUAL);
+\&              return (EXPOP_AND);
+\^              return (EXPOP_XOR);
+\|              return (EXPOP_OR);
+"&&"            return (EXPOP_LOGICAL_AND);
+"||"            return (EXPOP_LOGICAL_OR);
+
+"defined"       return (EXPOP_DEFINE);
+{Identifier}    {STRING_SETUP; return (EXPOP_IDENTIFIER);}
+
+<<EOF>>         return (EXPOP_EOF); /* null end-of-string */
+
+{Number}        return (EXPOP_NUMBER);
+{HexNumber}     return (EXPOP_HEX_NUMBER);
+{NewLine}       return (EXPOP_NEW_LINE);
+{WhiteSpace}    /* Ignore */
+
+.               return (EXPOP_EOF);
+%%
+
+/*
+ * Local support functions
+ */
+YY_BUFFER_STATE         LexBuffer;
+
+
+/******************************************************************************
+ *
+ * FUNCTION:    PrInitLexer
+ *
+ * PARAMETERS:  String              - Input string to be parsed
+ *
+ * RETURN:      TRUE if parser returns NULL. FALSE otherwise.
+ *
+ * DESCRIPTION: Initialization routine for lexer. The lexer needs
+ *              a buffer to handle strings instead of a file.
+ *
+ *****************************************************************************/
+
+int
+PrInitLexer (
+    char                    *String)
+{
+
+    LexBuffer = yy_scan_string (String);
+    return (LexBuffer == NULL);
+}
+
+
+/******************************************************************************
+ *
+ * FUNCTION:    PrTerminateLexer
+ *
+ * PARAMETERS:  None
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Termination routine for thelexer.
+ *
+ *****************************************************************************/
+
+void
+PrTerminateLexer (
+    void)
+{
+
+    yy_delete_buffer (LexBuffer);
+}
+
+
+/********************************************************************************
+ *
+ * FUNCTION:    PrDoCommentType1
+ *
+ * PARAMETERS:  none
+ *
+ * RETURN:      none
+ *
+ * DESCRIPTION: Process a new legacy comment. Just toss it.
+ *
+ ******************************************************************************/
+
+static char
+PrDoCommentType1 (
+    void)
+{
+    int                 c;
+
+
+Loop:
+    while (((c = input ()) != '*') && (c != EOF))
+    {
+    }
+    if (c == EOF)
+    {
+        return (FALSE);
+    }
+
+    if (((c = input ()) != '/') && (c != EOF))
+    {
+        unput (c);
+        goto Loop;
+    }
+    if (c == EOF)
+    {
+        return (FALSE);
+    }
+
+    return (TRUE);
+}
+
+
+/********************************************************************************
+ *
+ * FUNCTION:    PrDoCommentType2
+ *
+ * PARAMETERS:  none
+ *
+ * RETURN:      none
+ *
+ * DESCRIPTION: Process a new "//" comment. Just toss it.
+ *
+ ******************************************************************************/
+
+static char
+PrDoCommentType2 (
+    void)
+{
+    int                 c;
+
+
+    while (((c = input ()) != '\n') && (c != EOF))
+    {
+    }
+    if (c == EOF)
+    {
+        return (FALSE);
+    }
+
+    return (TRUE);
+}
diff --git a/usr/src/cmd/acpi/iasl/prparser.y b/usr/src/cmd/acpi/iasl/prparser.y
new file mode 100644
index 0000000000..d2f84059be
--- /dev/null
+++ b/usr/src/cmd/acpi/iasl/prparser.y
@@ -0,0 +1,294 @@
+%{
+/******************************************************************************
+ *
+ * Module Name: prparser.y - Bison input file for preprocessor parser
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2016, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include "aslcompiler.h"
+#include "dtcompiler.h"
+
+#define _COMPONENT          ASL_PREPROCESSOR
+        ACPI_MODULE_NAME    ("prparser")
+
+void *                      AslLocalAllocate (unsigned int Size);
+
+/* Bison/yacc configuration */
+
+#undef alloca
+#define alloca              AslLocalAllocate
+
+int                         PrParserlex (void);
+int                         PrParserparse (void);
+void                        PrParsererror (char const *msg);
+extern char                 *PrParsertext;
+
+UINT64                      PrParserResult; /* Expression return value */
+
+/* Bison/yacc configuration */
+
+#define yytname             PrParsername
+#define YYDEBUG             1               /* Enable debug output */
+#define YYERROR_VERBOSE     1               /* Verbose error messages */
+#define YYFLAG              -32768
+
+/* Define YYMALLOC/YYFREE to prevent redefinition errors  */
+
+#define YYMALLOC            malloc
+#define YYFREE              free
+%}
+
+%union
+{
+     UINT64                 value;
+     UINT32                 op;
+     char                   *str;
+}
+
+/*! [Begin] no source code translation */
+
+%type  <value>  Expression
+
+%token <op>     EXPOP_EOF
+%token <op>     EXPOP_NEW_LINE
+%token <op>     EXPOP_NUMBER
+%token <op>     EXPOP_HEX_NUMBER
+%token <op>     EXPOP_RESERVED1
+%token <op>     EXPOP_RESERVED2
+%token <op>     EXPOP_PAREN_OPEN
+%token <op>     EXPOP_PAREN_CLOSE
+
+%left <op>      EXPOP_LOGICAL_OR
+%left <op>      EXPOP_LOGICAL_AND
+%left <op>      EXPOP_OR
+%left <op>      EXPOP_XOR
+%left <op>      EXPOP_AND
+%left <op>      EXPOP_EQUAL EXPOP_NOT_EQUAL
+%left <op>      EXPOP_GREATER EXPOP_LESS EXPOP_GREATER_EQUAL EXPOP_LESS_EQUAL
+%left <op>      EXPOP_SHIFT_RIGHT EXPOP_SHIFT_LEFT
+%left <op>      EXPOP_ADD EXPOP_SUBTRACT
+%left <op>      EXPOP_MULTIPLY EXPOP_DIVIDE EXPOP_MODULO
+%right <op>     EXPOP_ONES_COMPLIMENT EXPOP_LOGICAL_NOT
+
+/* Tokens above must be kept in synch with dtparser.y */
+
+%token <op>     EXPOP_DEFINE
+%token <op>     EXPOP_IDENTIFIER
+
+%%
+
+/*
+ *  Operator precedence rules (from K&R)
+ *
+ *  1)      ( )
+ *  2)      ! ~ (unary operators that are supported here)
+ *  3)      *   /   %
+ *  4)      +   -
+ *  5)      >>  <<
+ *  6)      <   >   <=  >=
+ *  7)      ==  !=
+ *  8)      &
+ *  9)      ^
+ *  10)     |
+ *  11)     &&
+ *  12)     ||
+ */
+
+/*! [End] no source code translation !*/
+
+Value
+    : Expression EXPOP_NEW_LINE                     { PrParserResult=$1; return 0; } /* End of line (newline) */
+    | Expression EXPOP_EOF                          { PrParserResult=$1; return 0; } /* End of string (0) */
+    ;
+
+Expression
+
+      /* Unary operators */
+
+    : EXPOP_LOGICAL_NOT         Expression          { $$ = DtDoOperator ($2, EXPOP_LOGICAL_NOT,     $2);}
+    | EXPOP_ONES_COMPLIMENT     Expression          { $$ = DtDoOperator ($2, EXPOP_ONES_COMPLIMENT, $2);}
+
+      /* Binary operators */
+
+    | Expression EXPOP_MULTIPLY         Expression  { $$ = DtDoOperator ($1, EXPOP_MULTIPLY,        $3);}
+    | Expression EXPOP_DIVIDE           Expression  { $$ = DtDoOperator ($1, EXPOP_DIVIDE,          $3);}
+    | Expression EXPOP_MODULO           Expression  { $$ = DtDoOperator ($1, EXPOP_MODULO,          $3);}
+    | Expression EXPOP_ADD              Expression  { $$ = DtDoOperator ($1, EXPOP_ADD,             $3);}
+    | Expression EXPOP_SUBTRACT         Expression  { $$ = DtDoOperator ($1, EXPOP_SUBTRACT,        $3);}
+    | Expression EXPOP_SHIFT_RIGHT      Expression  { $$ = DtDoOperator ($1, EXPOP_SHIFT_RIGHT,     $3);}
+    | Expression EXPOP_SHIFT_LEFT       Expression  { $$ = DtDoOperator ($1, EXPOP_SHIFT_LEFT,      $3);}
+    | Expression EXPOP_GREATER          Expression  { $$ = DtDoOperator ($1, EXPOP_GREATER,         $3);}
+    | Expression EXPOP_LESS             Expression  { $$ = DtDoOperator ($1, EXPOP_LESS,            $3);}
+    | Expression EXPOP_GREATER_EQUAL    Expression  { $$ = DtDoOperator ($1, EXPOP_GREATER_EQUAL,   $3);}
+    | Expression EXPOP_LESS_EQUAL       Expression  { $$ = DtDoOperator ($1, EXPOP_LESS_EQUAL,      $3);}
+    | Expression EXPOP_EQUAL            Expression  { $$ = DtDoOperator ($1, EXPOP_EQUAL,           $3);}
+    | Expression EXPOP_NOT_EQUAL        Expression  { $$ = DtDoOperator ($1, EXPOP_NOT_EQUAL,       $3);}
+    | Expression EXPOP_AND              Expression  { $$ = DtDoOperator ($1, EXPOP_AND,             $3);}
+    | Expression EXPOP_XOR              Expression  { $$ = DtDoOperator ($1, EXPOP_XOR,             $3);}
+    | Expression EXPOP_OR               Expression  { $$ = DtDoOperator ($1, EXPOP_OR,              $3);}
+    | Expression EXPOP_LOGICAL_AND      Expression  { $$ = DtDoOperator ($1, EXPOP_LOGICAL_AND,     $3);}
+    | Expression EXPOP_LOGICAL_OR       Expression  { $$ = DtDoOperator ($1, EXPOP_LOGICAL_OR,      $3);}
+
+      /* Parentheses: '(' Expression ')' */
+
+    | EXPOP_PAREN_OPEN          Expression
+        EXPOP_PAREN_CLOSE                           { $$ = $2;}
+
+      /* #if defined (ID) or #if defined ID */
+
+    | EXPOP_DEFINE EXPOP_PAREN_OPEN EXPOP_IDENTIFIER
+        EXPOP_PAREN_CLOSE                           { $$ = PrIsDefined (PrParserlval.str);}
+
+    | EXPOP_DEFINE EXPOP_IDENTIFIER                 { $$ = PrIsDefined (PrParserlval.str);}
+
+    | EXPOP_IDENTIFIER                              { $$ = PrResolveDefine (PrParserlval.str);}
+
+      /* Default base for a non-prefixed integer is 10 */
+
+    | EXPOP_NUMBER                                  { AcpiUtStrtoul64 (PrParsertext, 10, ACPI_MAX64_BYTE_WIDTH, &$$);}
+
+      /* Standard hex number (0x1234) */
+
+    | EXPOP_HEX_NUMBER                              { AcpiUtStrtoul64 (PrParsertext, 16, ACPI_MAX64_BYTE_WIDTH, &$$);}
+    ;
+%%
+
+/*
+ * Local support functions, including parser entry point
+ */
+#define PR_FIRST_PARSE_OPCODE   EXPOP_EOF
+#define PR_YYTNAME_START        3
+
+
+/******************************************************************************
+ *
+ * FUNCTION:    PrParsererror
+ *
+ * PARAMETERS:  Message             - Parser-generated error message
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Handler for parser errors
+ *
+ *****************************************************************************/
+
+void
+PrParsererror (
+    char const              *Message)
+{
+
+    sprintf (StringBuffer, "Preprocessor Parser : %s (near line %u)",
+        Message, Gbl_CurrentLineNumber);
+    DtError (ASL_ERROR, ASL_MSG_SYNTAX,
+        NULL, (char *) StringBuffer);
+}
+
+
+/******************************************************************************
+ *
+ * FUNCTION:    PrGetOpName
+ *
+ * PARAMETERS:  ParseOpcode         - Parser token (EXPOP_*)
+ *
+ * RETURN:      Pointer to the opcode name
+ *
+ * DESCRIPTION: Get the ascii name of the parse opcode for debug output
+ *
+ *****************************************************************************/
+
+char *
+PrGetOpName (
+    UINT32                  ParseOpcode)
+{
+#ifdef ASL_YYTNAME_START
+    /*
+     * First entries (PR_YYTNAME_START) in yytname are special reserved names.
+     * Ignore first 6 characters of name (EXPOP_)
+     */
+    return ((char *) yytname
+        [(ParseOpcode - PR_FIRST_PARSE_OPCODE) + PR_YYTNAME_START] + 6);
+#else
+    return ("[Unknown parser generator]");
+#endif
+}
+
+
+/******************************************************************************
+ *
+ * FUNCTION:    PrEvaluateExpression
+ *
+ * PARAMETERS:  ExprString          - Expression to be evaluated. Must be
+ *                                    terminated by either a newline or a NUL
+ *                                    string terminator
+ *
+ * RETURN:      64-bit value for the expression
+ *
+ * DESCRIPTION: Main entry point for the DT expression parser
+ *
+ *****************************************************************************/
+
+UINT64
+PrEvaluateExpression (
+    char                    *ExprString)
+{
+
+    DbgPrint (ASL_DEBUG_OUTPUT,
+        "**** Input expression: %s\n", ExprString);
+
+    /* Point lexer to the input string */
+
+    if (PrInitLexer (ExprString))
+    {
+        DtError (ASL_ERROR, ASL_MSG_COMPILER_INTERNAL,
+            NULL, "Could not initialize lexer");
+        return (0);
+    }
+
+    /* Parse/Evaluate the input string (value returned in PrParserResult) */
+
+    PrParserparse ();
+    PrTerminateLexer ();
+
+    DbgPrint (ASL_DEBUG_OUTPUT,
+        "**** Parser returned value: %u (%8.8X%8.8X)\n",
+        (UINT32) PrParserResult, ACPI_FORMAT_UINT64 (PrParserResult));
+
+    return (PrParserResult);
+}
diff --git a/usr/src/cmd/acpi/iasl/prscan.c b/usr/src/cmd/acpi/iasl/prscan.c
new file mode 100644
index 0000000000..b24b319979
--- /dev/null
+++ b/usr/src/cmd/acpi/iasl/prscan.c
@@ -0,0 +1,1267 @@
+/******************************************************************************
+ *
+ * Module Name: prscan - Preprocessor start-up and file scan module
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2016, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#define _DECLARE_PR_GLOBALS
+
+#include "aslcompiler.h"
+#include "dtcompiler.h"
+
+/*
+ * TBDs:
+ *
+ * No nested macros, maybe never
+ * Implement ASL "Include" as well as "#include" here?
+ */
+#define _COMPONENT          ASL_PREPROCESSOR
+        ACPI_MODULE_NAME    ("prscan")
+
+
+/* Local prototypes */
+
+static void
+PrPreprocessInputFile (
+    void);
+
+static void
+PrDoDirective (
+    char                    *DirectiveToken,
+    char                    **Next);
+
+static void
+PrGetNextLineInit (
+    void);
+
+static UINT32
+PrGetNextLine (
+    FILE                    *Handle);
+
+static int
+PrMatchDirective (
+    char                    *Directive);
+
+static void
+PrPushDirective (
+    int                     Directive,
+    char                    *Argument);
+
+static ACPI_STATUS
+PrPopDirective (
+    void);
+
+static void
+PrDbgPrint (
+    char                    *Action,
+    char                    *DirectiveName);
+
+static void
+PrDoIncludeBuffer (
+    char                    *Pathname,
+    char                    *BufferName);
+
+static void
+PrDoIncludeFile (
+    char                    *Pathname);
+
+
+/*
+ * Supported preprocessor directives
+ * Each entry is of the form "Name, ArgumentCount"
+ */
+static const PR_DIRECTIVE_INFO      Gbl_DirectiveInfo[] =
+{
+    {"define",          1},
+    {"elif",            0}, /* Converted to #else..#if internally */
+    {"else",            0},
+    {"endif",           0},
+    {"error",           1},
+    {"if",              1},
+    {"ifdef",           1},
+    {"ifndef",          1},
+    {"include",         0}, /* Argument is not standard format, so just use 0 here */
+    {"includebuffer",   0}, /* Argument is not standard format, so just use 0 here */
+    {"line",            1},
+    {"pragma",          1},
+    {"undef",           1},
+    {"warning",         1},
+    {NULL,              0}
+};
+
+/* This table must match ordering of above table exactly */
+
+enum Gbl_DirectiveIndexes
+{
+    PR_DIRECTIVE_DEFINE = 0,
+    PR_DIRECTIVE_ELIF,
+    PR_DIRECTIVE_ELSE,
+    PR_DIRECTIVE_ENDIF,
+    PR_DIRECTIVE_ERROR,
+    PR_DIRECTIVE_IF,
+    PR_DIRECTIVE_IFDEF,
+    PR_DIRECTIVE_IFNDEF,
+    PR_DIRECTIVE_INCLUDE,
+    PR_DIRECTIVE_INCLUDEBUFFER,
+    PR_DIRECTIVE_LINE,
+    PR_DIRECTIVE_PRAGMA,
+    PR_DIRECTIVE_UNDEF,
+    PR_DIRECTIVE_WARNING
+};
+
+#define ASL_DIRECTIVE_NOT_FOUND     -1
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    PrInitializePreprocessor
+ *
+ * PARAMETERS:  None
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Startup initialization for the Preprocessor.
+ *
+ ******************************************************************************/
+
+void
+PrInitializePreprocessor (
+    void)
+{
+    /* Init globals and the list of #defines */
+
+    PrInitializeGlobals ();
+    Gbl_DefineList = NULL;
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    PrInitializeGlobals
+ *
+ * PARAMETERS:  None
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Initialize globals for the Preprocessor. Used for startuup
+ *              initialization and re-initialization between compiles during
+ *              a multiple source file compile.
+ *
+ ******************************************************************************/
+
+void
+PrInitializeGlobals (
+    void)
+{
+    /* Init globals */
+
+    Gbl_InputFileList = NULL;
+    Gbl_CurrentLineNumber = 1;
+    Gbl_PreprocessorLineNumber = 1;
+    Gbl_PreprocessorError = FALSE;
+
+    /* These are used to track #if/#else blocks (possibly nested) */
+
+    Gbl_IfDepth = 0;
+    Gbl_IgnoringThisCodeBlock = FALSE;
+    Gbl_DirectiveStack = NULL;
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    PrTerminatePreprocessor
+ *
+ * PARAMETERS:  None
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Termination of the preprocessor. Delete lists. Keep any
+ *              defines that were specified on the command line, in order to
+ *              support multiple compiles with a single compiler invocation.
+ *
+ ******************************************************************************/
+
+void
+PrTerminatePreprocessor (
+    void)
+{
+    PR_DEFINE_INFO          *DefineInfo;
+
+
+    /*
+     * The persistent defines (created on the command line) are always at the
+     * end of the list. We save them.
+     */
+    while ((Gbl_DefineList) && (!Gbl_DefineList->Persist))
+    {
+        DefineInfo = Gbl_DefineList;
+        Gbl_DefineList = DefineInfo->Next;
+
+        ACPI_FREE (DefineInfo->Replacement);
+        ACPI_FREE (DefineInfo->Identifier);
+        ACPI_FREE (DefineInfo);
+    }
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    PrDoPreprocess
+ *
+ * PARAMETERS:  None
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Main entry point for the iASL Preprocessor. Input file must
+ *              be already open. Handles multiple input files via the
+ *              #include directive.
+ *
+ ******************************************************************************/
+
+void
+PrDoPreprocess (
+    void)
+{
+    BOOLEAN                 MoreInputFiles;
+
+
+    DbgPrint (ASL_DEBUG_OUTPUT, "Starting preprocessing phase\n\n");
+
+
+    FlSeekFile (ASL_FILE_INPUT, 0);
+    PrDumpPredefinedNames ();
+
+    /* Main preprocessor loop, handles include files */
+
+    do
+    {
+        PrPreprocessInputFile ();
+        MoreInputFiles = PrPopInputFileStack ();
+
+    } while (MoreInputFiles);
+
+    /* Point compiler input to the new preprocessor output file (.pre) */
+
+    FlCloseFile (ASL_FILE_INPUT);
+    Gbl_Files[ASL_FILE_INPUT].Handle = Gbl_Files[ASL_FILE_PREPROCESSOR].Handle;
+    AslCompilerin = Gbl_Files[ASL_FILE_INPUT].Handle;
+
+    /* Reset globals to allow compiler to run */
+
+    FlSeekFile (ASL_FILE_INPUT, 0);
+    if (!Gbl_PreprocessOnly)
+    {
+        Gbl_CurrentLineNumber = 0;
+    }
+
+    DbgPrint (ASL_DEBUG_OUTPUT, "Preprocessing phase complete \n\n");
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    PrPreprocessInputFile
+ *
+ * PARAMETERS:  None
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Preprocess one entire file, line-by-line.
+ *
+ * Input:  Raw user ASL from ASL_FILE_INPUT
+ * Output: Preprocessed file written to ASL_FILE_PREPROCESSOR and
+ *         (optionally) ASL_FILE_PREPROCESSOR_USER
+ *
+ ******************************************************************************/
+
+static void
+PrPreprocessInputFile (
+    void)
+{
+    UINT32                  Status;
+    char                    *Token;
+    char                    *ReplaceString;
+    PR_DEFINE_INFO          *DefineInfo;
+    ACPI_SIZE               TokenOffset;
+    char                    *Next;
+    int                     OffsetAdjust;
+
+
+    PrGetNextLineInit ();
+
+    /* Scan source line-by-line and process directives. Then write the .i file */
+
+    while ((Status = PrGetNextLine (Gbl_Files[ASL_FILE_INPUT].Handle)) != ASL_EOF)
+    {
+        Gbl_CurrentLineNumber++;
+        Gbl_LogicalLineNumber++;
+
+        if (Status == ASL_IGNORE_LINE)
+        {
+            goto WriteEntireLine;
+        }
+
+        /* Need a copy of the input line for strok() */
+
+        strcpy (Gbl_MainTokenBuffer, Gbl_CurrentLineBuffer);
+        Token = PrGetNextToken (Gbl_MainTokenBuffer, PR_TOKEN_SEPARATORS, &Next);
+        OffsetAdjust = 0;
+
+        /* All preprocessor directives must begin with '#' */
+
+        if (Token && (*Token == '#'))
+        {
+            if (strlen (Token) == 1)
+            {
+                Token = PrGetNextToken (NULL, PR_TOKEN_SEPARATORS, &Next);
+            }
+            else
+            {
+                Token++;    /* Skip leading # */
+            }
+
+            /* Execute the directive, do not write line to output file */
+
+            PrDoDirective (Token, &Next);
+            continue;
+        }
+
+        /*
+         * If we are currently within the part of an IF/ELSE block that is
+         * FALSE, ignore the line and do not write it to the output file.
+         * This continues until an #else or #endif is encountered.
+         */
+        if (Gbl_IgnoringThisCodeBlock)
+        {
+            continue;
+        }
+
+        /* Match and replace all #defined names within this source line */
+
+        while (Token)
+        {
+            DefineInfo = PrMatchDefine (Token);
+            if (DefineInfo)
+            {
+                if (DefineInfo->Body)
+                {
+                    /* This is a macro */
+
+                    DbgPrint (ASL_DEBUG_OUTPUT, PR_PREFIX_ID
+                        "Matched Macro: %s->%s\n",
+                        Gbl_CurrentLineNumber, DefineInfo->Identifier,
+                        DefineInfo->Replacement);
+
+                    PrDoMacroInvocation (Gbl_MainTokenBuffer, Token,
+                        DefineInfo, &Next);
+                }
+                else
+                {
+                    ReplaceString = DefineInfo->Replacement;
+
+                    /* Replace the name in the original line buffer */
+
+                    TokenOffset = Token - Gbl_MainTokenBuffer + OffsetAdjust;
+                    PrReplaceData (
+                        &Gbl_CurrentLineBuffer[TokenOffset], strlen (Token),
+                        ReplaceString, strlen (ReplaceString));
+
+                    /* Adjust for length difference between old and new name length */
+
+                    OffsetAdjust += strlen (ReplaceString) - strlen (Token);
+
+                    DbgPrint (ASL_DEBUG_OUTPUT, PR_PREFIX_ID
+                        "Matched #define: %s->%s\n",
+                        Gbl_CurrentLineNumber, Token,
+                        *ReplaceString ? ReplaceString : "(NULL STRING)");
+                }
+            }
+
+            Token = PrGetNextToken (NULL, PR_TOKEN_SEPARATORS, &Next);
+        }
+
+        Gbl_PreprocessorLineNumber++;
+
+
+WriteEntireLine:
+        /*
+         * Now we can write the possibly modified source line to the
+         * preprocessor file(s).
+         */
+        FlWriteFile (ASL_FILE_PREPROCESSOR, Gbl_CurrentLineBuffer,
+            strlen (Gbl_CurrentLineBuffer));
+    }
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    PrDoDirective
+ *
+ * PARAMETERS:  Directive               - Pointer to directive name token
+ *              Next                    - "Next" buffer from GetNextToken
+ *
+ * RETURN:      None.
+ *
+ * DESCRIPTION: Main processing for all preprocessor directives
+ *
+ ******************************************************************************/
+
+static void
+PrDoDirective (
+    char                    *DirectiveToken,
+    char                    **Next)
+{
+    char                    *Token = Gbl_MainTokenBuffer;
+    char                    *Token2 = NULL;
+    char                    *End;
+    UINT64                  Value;
+    ACPI_SIZE               TokenOffset;
+    int                     Directive;
+    ACPI_STATUS             Status;
+
+
+    if (!DirectiveToken)
+    {
+        goto SyntaxError;
+    }
+
+    Directive = PrMatchDirective (DirectiveToken);
+    if (Directive == ASL_DIRECTIVE_NOT_FOUND)
+    {
+        PrError (ASL_ERROR, ASL_MSG_UNKNOWN_DIRECTIVE,
+            THIS_TOKEN_OFFSET (DirectiveToken));
+
+        DbgPrint (ASL_PARSE_OUTPUT, PR_PREFIX_ID
+            "#%s: Unknown directive\n",
+            Gbl_CurrentLineNumber, DirectiveToken);
+        return;
+    }
+
+    /*
+     * Emit a line directive into the preprocessor file (.pre) after
+     * every matched directive. This is passed through to the compiler
+     * so that error/warning messages are kept in sync with the
+     * original source file.
+     */
+    FlPrintFile (ASL_FILE_PREPROCESSOR, "#line %u \"%s\" // #%s\n",
+        Gbl_CurrentLineNumber, Gbl_Files[ASL_FILE_INPUT].Filename,
+        Gbl_DirectiveInfo[Directive].Name);
+
+    /*
+     * If we are currently ignoring this block and we encounter a #else or
+     * #elif, we must ignore their blocks also if the parent block is also
+     * being ignored.
+     */
+    if (Gbl_IgnoringThisCodeBlock)
+    {
+        switch (Directive)
+        {
+        case PR_DIRECTIVE_ELSE:
+        case PR_DIRECTIVE_ELIF:
+
+            if (Gbl_DirectiveStack &&
+                Gbl_DirectiveStack->IgnoringThisCodeBlock)
+            {
+                PrDbgPrint ("Ignoring", Gbl_DirectiveInfo[Directive].Name);
+                return;
+            }
+            break;
+
+        default:
+            break;
+        }
+    }
+
+    /*
+     * Need to always check for #else, #elif, #endif regardless of
+     * whether we are ignoring the current code block, since these
+     * are conditional code block terminators.
+     */
+    switch (Directive)
+    {
+    case PR_DIRECTIVE_ELSE:
+
+        Gbl_IgnoringThisCodeBlock = !(Gbl_IgnoringThisCodeBlock);
+        PrDbgPrint ("Executing", "else block");
+        return;
+
+    case PR_DIRECTIVE_ELIF:
+
+        Gbl_IgnoringThisCodeBlock = !(Gbl_IgnoringThisCodeBlock);
+        Directive = PR_DIRECTIVE_IF;
+
+        if (Gbl_IgnoringThisCodeBlock == TRUE)
+        {
+            /* Not executing the ELSE part -- all done here */
+            PrDbgPrint ("Ignoring", "elif block");
+            return;
+        }
+
+        /*
+         * After this, we will execute the IF part further below.
+         * First, however, pop off the original #if directive.
+         */
+        if (ACPI_FAILURE (PrPopDirective ()))
+        {
+            PrError (ASL_ERROR, ASL_MSG_COMPILER_INTERNAL,
+                THIS_TOKEN_OFFSET (DirectiveToken));
+        }
+
+        PrDbgPrint ("Executing", "elif block");
+        break;
+
+    case PR_DIRECTIVE_ENDIF:
+
+        PrDbgPrint ("Executing", "endif");
+
+        /* Pop the owning #if/#ifdef/#ifndef */
+
+        if (ACPI_FAILURE (PrPopDirective ()))
+        {
+            PrError (ASL_ERROR, ASL_MSG_ENDIF_MISMATCH,
+                THIS_TOKEN_OFFSET (DirectiveToken));
+        }
+        return;
+
+    default:
+        break;
+    }
+
+    /* Most directives have at least one argument */
+
+    if (Gbl_DirectiveInfo[Directive].ArgCount >= 1)
+    {
+        Token = PrGetNextToken (NULL, PR_TOKEN_SEPARATORS, Next);
+        if (!Token)
+        {
+            goto SyntaxError;
+        }
+    }
+
+    if (Gbl_DirectiveInfo[Directive].ArgCount >= 2)
+    {
+        Token2 = PrGetNextToken (NULL, PR_TOKEN_SEPARATORS, Next);
+        if (!Token2)
+        {
+            goto SyntaxError;
+        }
+    }
+
+    /*
+     * At this point, if we are ignoring the current code block,
+     * do not process any more directives (i.e., ignore them also.)
+     * For "if" style directives, open/push a new block anyway. We
+     * must do this to keep track of #endif directives
+     */
+    if (Gbl_IgnoringThisCodeBlock)
+    {
+        switch (Directive)
+        {
+        case PR_DIRECTIVE_IF:
+        case PR_DIRECTIVE_IFDEF:
+        case PR_DIRECTIVE_IFNDEF:
+
+            PrPushDirective (Directive, Token);
+            PrDbgPrint ("Ignoring", Gbl_DirectiveInfo[Directive].Name);
+            break;
+
+        default:
+            break;
+        }
+
+        return;
+    }
+
+    /*
+     * Execute the directive
+     */
+    PrDbgPrint ("Begin execution", Gbl_DirectiveInfo[Directive].Name);
+
+    switch (Directive)
+    {
+    case PR_DIRECTIVE_IF:
+
+        TokenOffset = Token - Gbl_MainTokenBuffer;
+
+        /* Need to expand #define macros in the expression string first */
+
+        Status = PrResolveIntegerExpression (
+            &Gbl_CurrentLineBuffer[TokenOffset-1], &Value);
+        if (ACPI_FAILURE (Status))
+        {
+            return;
+        }
+
+        PrPushDirective (Directive, Token);
+        if (!Value)
+        {
+            Gbl_IgnoringThisCodeBlock = TRUE;
+        }
+
+        DbgPrint (ASL_PARSE_OUTPUT, PR_PREFIX_ID
+            "Resolved #if: %8.8X%8.8X %s\n",
+            Gbl_CurrentLineNumber, ACPI_FORMAT_UINT64 (Value),
+            Gbl_IgnoringThisCodeBlock ? "<Skipping Block>" : "<Executing Block>");
+        break;
+
+    case PR_DIRECTIVE_IFDEF:
+
+        PrPushDirective (Directive, Token);
+        if (!PrMatchDefine (Token))
+        {
+            Gbl_IgnoringThisCodeBlock = TRUE;
+        }
+
+        PrDbgPrint ("Evaluated", "ifdef");
+        break;
+
+    case PR_DIRECTIVE_IFNDEF:
+
+        PrPushDirective (Directive, Token);
+        if (PrMatchDefine (Token))
+        {
+            Gbl_IgnoringThisCodeBlock = TRUE;
+        }
+
+        PrDbgPrint ("Evaluated", "ifndef");
+        break;
+
+    case PR_DIRECTIVE_DEFINE:
+        /*
+         * By definition, if first char after the name is a paren,
+         * this is a function macro.
+         */
+        TokenOffset = Token - Gbl_MainTokenBuffer + strlen (Token);
+        if (*(&Gbl_CurrentLineBuffer[TokenOffset]) == '(')
+        {
+#ifndef MACROS_SUPPORTED
+            AcpiOsPrintf (
+                "%s ERROR - line %u: #define macros are not supported yet\n",
+                Gbl_CurrentLineBuffer, Gbl_LogicalLineNumber);
+            exit(1);
+#else
+            PrAddMacro (Token, Next);
+#endif
+        }
+        else
+        {
+            /* Use the remainder of the line for the #define */
+
+            Token2 = *Next;
+            if (Token2)
+            {
+                while ((*Token2 == ' ') || (*Token2 == '\t'))
+                {
+                    Token2++;
+                }
+
+                End = Token2;
+                while (*End != '\n')
+                {
+                    End++;
+                }
+
+                *End = 0;
+            }
+            else
+            {
+                Token2 = "";
+            }
+#if 0
+            Token2 = PrGetNextToken (NULL, "\n", /*PR_TOKEN_SEPARATORS,*/ Next);
+            if (!Token2)
+            {
+                Token2 = "";
+            }
+#endif
+            DbgPrint (ASL_PARSE_OUTPUT, PR_PREFIX_ID
+                "New #define: %s->%s\n",
+                Gbl_LogicalLineNumber, Token, Token2);
+
+            PrAddDefine (Token, Token2, FALSE);
+        }
+        break;
+
+    case PR_DIRECTIVE_ERROR:
+
+        /* Note: No macro expansion */
+
+        PrError (ASL_ERROR, ASL_MSG_ERROR_DIRECTIVE,
+            THIS_TOKEN_OFFSET (Token));
+
+        Gbl_SourceLine = 0;
+        Gbl_NextError = Gbl_ErrorLog;
+        CmCleanupAndExit ();
+        exit(1);
+
+    case PR_DIRECTIVE_INCLUDE:
+
+        Token = PrGetNextToken (NULL, " \"<>", Next);
+        if (!Token)
+        {
+            goto SyntaxError;
+        }
+
+        DbgPrint (ASL_PARSE_OUTPUT, PR_PREFIX_ID
+            "Start #include file \"%s\"\n", Gbl_CurrentLineNumber,
+            Token, Gbl_CurrentLineNumber);
+
+        PrDoIncludeFile (Token);
+        break;
+
+    case PR_DIRECTIVE_INCLUDEBUFFER:
+
+        Token = PrGetNextToken (NULL, " \"<>", Next);
+        if (!Token)
+        {
+            goto SyntaxError;
+        }
+
+        Token2 = PrGetNextToken (NULL, PR_TOKEN_SEPARATORS, Next);
+        if (!Token2)
+        {
+            goto SyntaxError;
+        }
+
+        DbgPrint (ASL_PARSE_OUTPUT, PR_PREFIX_ID
+            "Start #includebuffer input from file \"%s\", buffer name %s\n",
+            Gbl_CurrentLineNumber, Token, Token2);
+
+        PrDoIncludeBuffer (Token, Token2);
+        break;
+
+    case PR_DIRECTIVE_LINE:
+
+        TokenOffset = Token - Gbl_MainTokenBuffer;
+
+        Status = PrResolveIntegerExpression (
+            &Gbl_CurrentLineBuffer[TokenOffset-1], &Value);
+        if (ACPI_FAILURE (Status))
+        {
+            return;
+        }
+
+        DbgPrint (ASL_PARSE_OUTPUT, PR_PREFIX_ID
+            "User #line invocation %s\n", Gbl_CurrentLineNumber,
+            Token);
+
+        Gbl_CurrentLineNumber = (UINT32) Value;
+
+        /* Emit #line into the preprocessor file */
+
+        FlPrintFile (ASL_FILE_PREPROCESSOR, "#line %u \"%s\"\n",
+            Gbl_CurrentLineNumber, Gbl_Files[ASL_FILE_INPUT].Filename);
+        break;
+
+    case PR_DIRECTIVE_PRAGMA:
+
+        if (!strcmp (Token, "disable"))
+        {
+            Token = PrGetNextToken (NULL, PR_TOKEN_SEPARATORS, Next);
+            if (!Token)
+            {
+                goto SyntaxError;
+            }
+
+            TokenOffset = Token - Gbl_MainTokenBuffer;
+            AslDisableException (&Gbl_CurrentLineBuffer[TokenOffset]);
+        }
+        else if (!strcmp (Token, "message"))
+        {
+            Token = PrGetNextToken (NULL, PR_TOKEN_SEPARATORS, Next);
+            if (!Token)
+            {
+                goto SyntaxError;
+            }
+
+            TokenOffset = Token - Gbl_MainTokenBuffer;
+            AcpiOsPrintf ("%s\n", &Gbl_CurrentLineBuffer[TokenOffset]);
+        }
+        else
+        {
+            PrError (ASL_ERROR, ASL_MSG_UNKNOWN_PRAGMA,
+                THIS_TOKEN_OFFSET (Token));
+            return;
+        }
+
+        break;
+
+    case PR_DIRECTIVE_UNDEF:
+
+        DbgPrint (ASL_PARSE_OUTPUT, PR_PREFIX_ID
+            "#undef: %s\n", Gbl_CurrentLineNumber, Token);
+
+        PrRemoveDefine (Token);
+        break;
+
+    case PR_DIRECTIVE_WARNING:
+
+        PrError (ASL_WARNING, ASL_MSG_WARNING_DIRECTIVE,
+            THIS_TOKEN_OFFSET (Token));
+
+        Gbl_SourceLine = 0;
+        Gbl_NextError = Gbl_ErrorLog;
+        break;
+
+    default:
+
+        /* Should never get here */
+        DbgPrint (ASL_PARSE_OUTPUT, PR_PREFIX_ID
+            "Unrecognized directive: %u\n",
+            Gbl_CurrentLineNumber, Directive);
+        break;
+    }
+
+    return;
+
+SyntaxError:
+
+    PrError (ASL_ERROR, ASL_MSG_DIRECTIVE_SYNTAX,
+        THIS_TOKEN_OFFSET (DirectiveToken));
+    return;
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    PrGetNextLine, PrGetNextLineInit
+ *
+ * PARAMETERS:  Handle              - Open file handle for the source file
+ *
+ * RETURN:      Status of the GetLine operation:
+ *              AE_OK               - Normal line, OK status
+ *              ASL_IGNORE_LINE     - Line is blank or part of a multi-line
+ *                                      comment
+ *              ASL_EOF             - End-of-file reached
+ *
+ * DESCRIPTION: Get the next text line from the input file. Does not strip
+ *              comments.
+ *
+ ******************************************************************************/
+
+#define PR_NORMAL_TEXT          0
+#define PR_MULTI_LINE_COMMENT   1
+#define PR_SINGLE_LINE_COMMENT  2
+#define PR_QUOTED_STRING        3
+
+static UINT8                    AcpiGbl_LineScanState = PR_NORMAL_TEXT;
+
+static void
+PrGetNextLineInit (
+    void)
+{
+    AcpiGbl_LineScanState = 0;
+}
+
+static UINT32
+PrGetNextLine (
+    FILE                    *Handle)
+{
+    UINT32                  i;
+    int                     c = 0;
+    int                     PreviousChar;
+
+
+    /* Always clear the global line buffer */
+
+    memset (Gbl_CurrentLineBuffer, 0, Gbl_LineBufferSize);
+    for (i = 0; ;)
+    {
+        /*
+         * If line is too long, expand the line buffers. Also increases
+         * Gbl_LineBufferSize.
+         */
+        if (i >= Gbl_LineBufferSize)
+        {
+            UtExpandLineBuffers ();
+        }
+
+        PreviousChar = c;
+        c = getc (Handle);
+        if (c == EOF)
+        {
+            /*
+             * On EOF: If there is anything in the line buffer, terminate
+             * it with a newline, and catch the EOF on the next call
+             * to this function.
+             */
+            if (i > 0)
+            {
+                Gbl_CurrentLineBuffer[i] = '\n';
+                return (AE_OK);
+            }
+
+            return (ASL_EOF);
+        }
+
+        /* Update state machine as necessary */
+
+        switch (AcpiGbl_LineScanState)
+        {
+        case PR_NORMAL_TEXT:
+
+            /* Check for multi-line comment start */
+
+            if ((PreviousChar == '/') && (c == '*'))
+            {
+                AcpiGbl_LineScanState = PR_MULTI_LINE_COMMENT;
+            }
+
+            /* Check for single-line comment start */
+
+            else if ((PreviousChar == '/') && (c == '/'))
+            {
+                AcpiGbl_LineScanState = PR_SINGLE_LINE_COMMENT;
+            }
+
+            /* Check for quoted string start */
+
+            else if (PreviousChar == '"')
+            {
+                AcpiGbl_LineScanState = PR_QUOTED_STRING;
+            }
+            break;
+
+        case PR_QUOTED_STRING:
+
+            if (PreviousChar == '"')
+            {
+                AcpiGbl_LineScanState = PR_NORMAL_TEXT;
+            }
+            break;
+
+        case PR_MULTI_LINE_COMMENT:
+
+            /* Check for multi-line comment end */
+
+            if ((PreviousChar == '*') && (c == '/'))
+            {
+                AcpiGbl_LineScanState = PR_NORMAL_TEXT;
+            }
+            break;
+
+        case PR_SINGLE_LINE_COMMENT: /* Just ignore text until EOL */
+        default:
+            break;
+        }
+
+        /* Always copy the character into line buffer */
+
+        Gbl_CurrentLineBuffer[i] = (char) c;
+        i++;
+
+        /* Always exit on end-of-line */
+
+        if (c == '\n')
+        {
+            /* Handle multi-line comments */
+
+            if (AcpiGbl_LineScanState == PR_MULTI_LINE_COMMENT)
+            {
+                return (ASL_IGNORE_LINE);
+            }
+
+            /* End of single-line comment */
+
+            if (AcpiGbl_LineScanState == PR_SINGLE_LINE_COMMENT)
+            {
+                AcpiGbl_LineScanState = PR_NORMAL_TEXT;
+                return (AE_OK);
+            }
+
+            /* Blank line */
+
+            if (i == 1)
+            {
+                return (ASL_IGNORE_LINE);
+            }
+
+            return (AE_OK);
+        }
+    }
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    PrMatchDirective
+ *
+ * PARAMETERS:  Directive           - Pointer to directive name token
+ *
+ * RETURN:      Index into command array, -1 if not found
+ *
+ * DESCRIPTION: Lookup the incoming directive in the known directives table.
+ *
+ ******************************************************************************/
+
+static int
+PrMatchDirective (
+    char                    *Directive)
+{
+    int                     i;
+
+
+    if (!Directive || Directive[0] == 0)
+    {
+        return (ASL_DIRECTIVE_NOT_FOUND);
+    }
+
+    for (i = 0; Gbl_DirectiveInfo[i].Name; i++)
+    {
+        if (!strcmp (Gbl_DirectiveInfo[i].Name, Directive))
+        {
+            return (i);
+        }
+    }
+
+    return (ASL_DIRECTIVE_NOT_FOUND);    /* Command not recognized */
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    PrPushDirective
+ *
+ * PARAMETERS:  Directive           - Encoded directive ID
+ *              Argument            - String containing argument to the
+ *                                    directive
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Push an item onto the directive stack. Used for processing
+ *              nested #if/#else type conditional compilation directives.
+ *              Specifically: Used on detection of #if/#ifdef/#ifndef to open
+ *              a block.
+ *
+ ******************************************************************************/
+
+static void
+PrPushDirective (
+    int                     Directive,
+    char                    *Argument)
+{
+    DIRECTIVE_INFO          *Info;
+
+
+    /* Allocate and populate a stack info item */
+
+    Info = ACPI_ALLOCATE (sizeof (DIRECTIVE_INFO));
+
+    Info->Next = Gbl_DirectiveStack;
+    Info->Directive = Directive;
+    Info->IgnoringThisCodeBlock = Gbl_IgnoringThisCodeBlock;
+    strncpy (Info->Argument, Argument, MAX_ARGUMENT_LENGTH);
+
+    DbgPrint (ASL_DEBUG_OUTPUT,
+        "Pr(%.4u) - [%u %s] %*s Pushed [#%s %s]: IgnoreFlag = %s\n",
+        Gbl_CurrentLineNumber, Gbl_IfDepth,
+        Gbl_IgnoringThisCodeBlock ? "I" : "E",
+        Gbl_IfDepth * 4, " ",
+        Gbl_DirectiveInfo[Directive].Name,
+        Argument, Gbl_IgnoringThisCodeBlock ? "TRUE" : "FALSE");
+
+    /* Push new item */
+
+    Gbl_DirectiveStack = Info;
+    Gbl_IfDepth++;
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    PrPopDirective
+ *
+ * PARAMETERS:  None
+ *
+ * RETURN:      Status. Error if the stack is empty.
+ *
+ * DESCRIPTION: Pop an item off the directive stack. Used for processing
+ *              nested #if/#else type conditional compilation directives.
+ *              Specifically: Used on detection of #elif and #endif to remove
+ *              the original #if/#ifdef/#ifndef from the stack and close
+ *              the block.
+ *
+ ******************************************************************************/
+
+static ACPI_STATUS
+PrPopDirective (
+    void)
+{
+    DIRECTIVE_INFO          *Info;
+
+
+    /* Check for empty stack */
+
+    Info = Gbl_DirectiveStack;
+    if (!Info)
+    {
+        return (AE_ERROR);
+    }
+
+    /* Pop one item, keep globals up-to-date */
+
+    Gbl_IfDepth--;
+    Gbl_IgnoringThisCodeBlock = Info->IgnoringThisCodeBlock;
+    Gbl_DirectiveStack = Info->Next;
+
+    DbgPrint (ASL_DEBUG_OUTPUT,
+        "Pr(%.4u) - [%u %s] %*s Popped [#%s %s]: IgnoreFlag now = %s\n",
+        Gbl_CurrentLineNumber, Gbl_IfDepth,
+        Gbl_IgnoringThisCodeBlock ? "I" : "E",
+        Gbl_IfDepth * 4, " ",
+        Gbl_DirectiveInfo[Info->Directive].Name,
+        Info->Argument, Gbl_IgnoringThisCodeBlock ? "TRUE" : "FALSE");
+
+    ACPI_FREE (Info);
+    return (AE_OK);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    PrDbgPrint
+ *
+ * PARAMETERS:  Action              - Action being performed
+ *              DirectiveName       - Directive being processed
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Special debug print for directive processing.
+ *
+ ******************************************************************************/
+
+static void
+PrDbgPrint (
+    char                    *Action,
+    char                    *DirectiveName)
+{
+
+    DbgPrint (ASL_DEBUG_OUTPUT, "Pr(%.4u) - [%u %s] "
+        "%*s %s #%s, IfDepth %u\n",
+        Gbl_CurrentLineNumber, Gbl_IfDepth,
+        Gbl_IgnoringThisCodeBlock ? "I" : "E",
+        Gbl_IfDepth * 4, " ",
+        Action, DirectiveName, Gbl_IfDepth);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    PrDoIncludeFile
+ *
+ * PARAMETERS:  Pathname                - Name of the input file
+ *
+ * RETURN:      None.
+ *
+ * DESCRIPTION: Open an include file, from #include.
+ *
+ ******************************************************************************/
+
+static void
+PrDoIncludeFile (
+    char                    *Pathname)
+{
+    char                    *FullPathname;
+
+
+    (void) PrOpenIncludeFile (Pathname, "r", &FullPathname);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    PrDoIncludeBuffer
+ *
+ * PARAMETERS:  Pathname                - Name of the input binary file
+ *              BufferName              - ACPI namepath of the buffer
+ *
+ * RETURN:      None.
+ *
+ * DESCRIPTION: Create an ACPI buffer object from a binary file. The contents
+ *              of the file are emitted into the buffer object as ascii
+ *              hex data. From #includebuffer.
+ *
+ ******************************************************************************/
+
+static void
+PrDoIncludeBuffer (
+    char                    *Pathname,
+    char                    *BufferName)
+{
+    char                    *FullPathname;
+    FILE                    *BinaryBufferFile;
+    UINT32                  i = 0;
+    UINT8                   c;
+
+
+    BinaryBufferFile = PrOpenIncludeFile (Pathname, "rb", &FullPathname);
+    if (!BinaryBufferFile)
+    {
+        return;
+    }
+
+    /* Emit "Name (XXXX, Buffer() {" header */
+
+    FlPrintFile (ASL_FILE_PREPROCESSOR, "Name (%s, Buffer()\n{", BufferName);
+
+    /* Dump the entire file in ascii hex format */
+
+    while (fread (&c, 1, 1, BinaryBufferFile))
+    {
+        if (!(i % 8))
+        {
+            FlPrintFile (ASL_FILE_PREPROCESSOR, "\n   ", c);
+        }
+
+        FlPrintFile (ASL_FILE_PREPROCESSOR, " 0x%2.2X,", c);
+        i++;
+    }
+
+    DbgPrint (ASL_PARSE_OUTPUT, PR_PREFIX_ID
+        "#includebuffer: read %u bytes from %s\n",
+        Gbl_CurrentLineNumber, i, FullPathname);
+
+    /* Close the Name() operator */
+
+    FlPrintFile (ASL_FILE_PREPROCESSOR, "\n})\n", BufferName);
+    fclose (BinaryBufferFile);
+}
diff --git a/usr/src/cmd/acpi/iasl/prutils.c b/usr/src/cmd/acpi/iasl/prutils.c
new file mode 100644
index 0000000000..ec9bf6664f
--- /dev/null
+++ b/usr/src/cmd/acpi/iasl/prutils.c
@@ -0,0 +1,476 @@
+/******************************************************************************
+ *
+ * Module Name: prutils - Preprocessor utilities
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2016, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include "aslcompiler.h"
+#include "dtcompiler.h"
+
+
+#define _COMPONENT          ASL_PREPROCESSOR
+        ACPI_MODULE_NAME    ("prutils")
+
+
+/******************************************************************************
+ *
+ * FUNCTION:    PrGetNextToken
+ *
+ * PARAMETERS:  Buffer              - Current line buffer
+ *              MatchString         - String with valid token delimiters
+ *              Next                - Set to next possible token in buffer
+ *
+ * RETURN:      Next token (null-terminated). Modifies the input line.
+ *              Remainder of line is stored in *Next.
+ *
+ * DESCRIPTION: Local implementation of strtok() with local storage for the
+ *              next pointer. Not only thread-safe, but allows multiple
+ *              parsing of substrings such as expressions.
+ *
+ *****************************************************************************/
+
+char *
+PrGetNextToken (
+    char                    *Buffer,
+    char                    *MatchString,
+    char                    **Next)
+{
+    char                    *TokenStart;
+
+
+    if (!Buffer)
+    {
+        /* Use Next if it is valid */
+
+        Buffer = *Next;
+        if (!(*Next))
+        {
+            return (NULL);
+        }
+    }
+
+    /* Skip any leading delimiters */
+
+    while (*Buffer)
+    {
+        if (strchr (MatchString, *Buffer))
+        {
+            Buffer++;
+        }
+        else
+        {
+            break;
+        }
+    }
+
+    /* Anything left on the line? */
+
+    if (!(*Buffer))
+    {
+        *Next = NULL;
+        return (NULL);
+    }
+
+    TokenStart = Buffer;
+
+    /* Find the end of this token */
+
+    while (*Buffer)
+    {
+        if (strchr (MatchString, *Buffer))
+        {
+            *Buffer = 0;
+            *Next = Buffer+1;
+            if (!**Next)
+            {
+                *Next = NULL;
+            }
+
+            return (TokenStart);
+        }
+
+        Buffer++;
+    }
+
+    *Next = NULL;
+    return (TokenStart);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    PrError
+ *
+ * PARAMETERS:  Level               - Seriousness (Warning/error, etc.)
+ *              MessageId           - Index into global message buffer
+ *              Column              - Column in current line
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Preprocessor error reporting. Front end to AslCommonError2
+ *
+ ******************************************************************************/
+
+void
+PrError (
+    UINT8                   Level,
+    UINT16                  MessageId,
+    UINT32                  Column)
+{
+#if 0
+    AcpiOsPrintf ("%s (%u) : %s", Gbl_Files[ASL_FILE_INPUT].Filename,
+        Gbl_CurrentLineNumber, Gbl_CurrentLineBuffer);
+#endif
+
+
+    if (Column > 120)
+    {
+        Column = 0;
+    }
+
+    /* TBD: Need Logical line number? */
+
+    AslCommonError2 (Level, MessageId,
+        Gbl_CurrentLineNumber, Column,
+        Gbl_CurrentLineBuffer,
+        Gbl_Files[ASL_FILE_INPUT].Filename, "Preprocessor");
+
+    Gbl_PreprocessorError = TRUE;
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    PrReplaceData
+ *
+ * PARAMETERS:  Buffer              - Original(target) buffer pointer
+ *              LengthToRemove      - Length to be removed from target buffer
+ *              BufferToAdd         - Data to be inserted into target buffer
+ *              LengthToAdd         - Length of BufferToAdd
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Generic buffer data replacement.
+ *
+ ******************************************************************************/
+
+void
+PrReplaceData (
+    char                    *Buffer,
+    UINT32                  LengthToRemove,
+    char                    *BufferToAdd,
+    UINT32                  LengthToAdd)
+{
+    UINT32                  BufferLength;
+
+
+    /* Buffer is a string, so the length must include the terminating zero */
+
+    BufferLength = strlen (Buffer) + 1;
+
+    if (LengthToRemove != LengthToAdd)
+    {
+        /*
+         * Move some of the existing data
+         * 1) If adding more bytes than removing, make room for the new data
+         * 2) if removing more bytes than adding, delete the extra space
+         */
+        if (LengthToRemove > 0)
+        {
+            memmove ((Buffer + LengthToAdd), (Buffer + LengthToRemove),
+                (BufferLength - LengthToRemove));
+        }
+    }
+
+    /* Now we can move in the new data */
+
+    if (LengthToAdd > 0)
+    {
+        memmove (Buffer, BufferToAdd, LengthToAdd);
+    }
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    PrOpenIncludeFile
+ *
+ * PARAMETERS:  Filename            - Filename or pathname for include file
+ *
+ * RETURN:      None.
+ *
+ * DESCRIPTION: Open an include file and push it on the input file stack.
+ *
+ ******************************************************************************/
+
+FILE *
+PrOpenIncludeFile (
+    char                    *Filename,
+    char                    *OpenMode,
+    char                    **FullPathname)
+{
+    FILE                    *IncludeFile;
+    ASL_INCLUDE_DIR         *NextDir;
+
+
+    /* Start the actual include file on the next line */
+
+    Gbl_CurrentLineOffset++;
+
+    /* Attempt to open the include file */
+    /* If the file specifies an absolute path, just open it */
+
+    if ((Filename[0] == '/')  ||
+        (Filename[0] == '\\') ||
+        (Filename[1] == ':'))
+    {
+        IncludeFile = PrOpenIncludeWithPrefix (
+            "", Filename, OpenMode, FullPathname);
+        if (!IncludeFile)
+        {
+            goto ErrorExit;
+        }
+        return (IncludeFile);
+    }
+
+    /*
+     * The include filename is not an absolute path.
+     *
+     * First, search for the file within the "local" directory -- meaning
+     * the same directory that contains the source file.
+     *
+     * Construct the file pathname from the global directory name.
+     */
+    IncludeFile = PrOpenIncludeWithPrefix (
+        Gbl_DirectoryPath, Filename, OpenMode, FullPathname);
+    if (IncludeFile)
+    {
+        return (IncludeFile);
+    }
+
+    /*
+     * Second, search for the file within the (possibly multiple)
+     * directories specified by the -I option on the command line.
+     */
+    NextDir = Gbl_IncludeDirList;
+    while (NextDir)
+    {
+        IncludeFile = PrOpenIncludeWithPrefix (
+            NextDir->Dir, Filename, OpenMode, FullPathname);
+        if (IncludeFile)
+        {
+            return (IncludeFile);
+        }
+
+        NextDir = NextDir->Next;
+    }
+
+    /* We could not open the include file after trying very hard */
+
+ErrorExit:
+    sprintf (Gbl_MainTokenBuffer, "%s, %s", Filename, strerror (errno));
+    PrError (ASL_ERROR, ASL_MSG_INCLUDE_FILE_OPEN, 0);
+    return (NULL);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    FlOpenIncludeWithPrefix
+ *
+ * PARAMETERS:  PrefixDir       - Prefix directory pathname. Can be a zero
+ *                                length string.
+ *              Filename        - The include filename from the source ASL.
+ *
+ * RETURN:      Valid file descriptor if successful. Null otherwise.
+ *
+ * DESCRIPTION: Open an include file and push it on the input file stack.
+ *
+ ******************************************************************************/
+
+FILE *
+PrOpenIncludeWithPrefix (
+    char                    *PrefixDir,
+    char                    *Filename,
+    char                    *OpenMode,
+    char                    **FullPathname)
+{
+    FILE                    *IncludeFile;
+    char                    *Pathname;
+
+
+    /* Build the full pathname to the file */
+
+    Pathname = FlMergePathnames (PrefixDir, Filename);
+
+    DbgPrint (ASL_PARSE_OUTPUT, PR_PREFIX_ID
+        "Include: Opening file - \"%s\"\n",
+        Gbl_CurrentLineNumber, Pathname);
+
+    /* Attempt to open the file, push if successful */
+
+    IncludeFile = fopen (Pathname, OpenMode);
+    if (!IncludeFile)
+    {
+        fprintf (stderr, "Could not open include file %s\n", Pathname);
+        return (NULL);
+    }
+
+    /* Push the include file on the open input file stack */
+
+    PrPushInputFileStack (IncludeFile, Pathname);
+    *FullPathname = Pathname;
+    return (IncludeFile);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AslPushInputFileStack
+ *
+ * PARAMETERS:  InputFile           - Open file pointer
+ *              Filename            - Name of the file
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Push the InputFile onto the file stack, and point the parser
+ *              to this file. Called when an include file is successfully
+ *              opened.
+ *
+ ******************************************************************************/
+
+void
+PrPushInputFileStack (
+    FILE                    *InputFile,
+    char                    *Filename)
+{
+    PR_FILE_NODE            *Fnode;
+
+
+    Gbl_HasIncludeFiles = TRUE;
+
+    /* Save the current state in an Fnode */
+
+    Fnode = UtLocalCalloc (sizeof (PR_FILE_NODE));
+
+    Fnode->File = Gbl_Files[ASL_FILE_INPUT].Handle;
+    Fnode->Next = Gbl_InputFileList;
+    Fnode->Filename = Gbl_Files[ASL_FILE_INPUT].Filename;
+    Fnode->CurrentLineNumber = Gbl_CurrentLineNumber;
+
+    /* Push it on the stack */
+
+    Gbl_InputFileList = Fnode;
+
+    DbgPrint (ASL_PARSE_OUTPUT, PR_PREFIX_ID
+        "Push InputFile Stack: handle %p\n\n",
+        Gbl_CurrentLineNumber, InputFile);
+
+    /* Reset the global line count and filename */
+
+    Gbl_Files[ASL_FILE_INPUT].Filename =
+        UtStringCacheCalloc (strlen (Filename) + 1);
+    strcpy (Gbl_Files[ASL_FILE_INPUT].Filename, Filename);
+
+    Gbl_Files[ASL_FILE_INPUT].Handle = InputFile;
+    Gbl_CurrentLineNumber = 1;
+
+    /* Emit a new #line directive for the include file */
+
+    FlPrintFile (ASL_FILE_PREPROCESSOR, "#line %u \"%s\"\n", 1, Filename);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AslPopInputFileStack
+ *
+ * PARAMETERS:  None
+ *
+ * RETURN:      0 if a node was popped, -1 otherwise
+ *
+ * DESCRIPTION: Pop the top of the input file stack and point the parser to
+ *              the saved parse buffer contained in the fnode. Also, set the
+ *              global line counters to the saved values. This function is
+ *              called when an include file reaches EOF.
+ *
+ ******************************************************************************/
+
+BOOLEAN
+PrPopInputFileStack (
+    void)
+{
+    PR_FILE_NODE            *Fnode;
+
+
+    Fnode = Gbl_InputFileList;
+    DbgPrint (ASL_PARSE_OUTPUT, "\n" PR_PREFIX_ID
+        "Pop InputFile Stack, Fnode %p\n\n",
+        Gbl_CurrentLineNumber, Fnode);
+
+    if (!Fnode)
+    {
+        return (FALSE);
+    }
+
+    /* Close the current include file */
+
+    fclose (Gbl_Files[ASL_FILE_INPUT].Handle);
+
+    /* Update the top-of-stack */
+
+    Gbl_InputFileList = Fnode->Next;
+
+    /* Reset global line counter and filename */
+
+    Gbl_Files[ASL_FILE_INPUT].Filename = Fnode->Filename;
+    Gbl_Files[ASL_FILE_INPUT].Handle = Fnode->File;
+    Gbl_CurrentLineNumber = Fnode->CurrentLineNumber;
+
+    /* Emit a new #line directive after the include file */
+
+    FlPrintFile (ASL_FILE_PREPROCESSOR, "#line %u \"%s\"\n",
+        Gbl_CurrentLineNumber, Fnode->Filename);
+
+    /* All done with this node */
+
+    ACPI_FREE (Fnode);
+    return (TRUE);
+}
diff --git a/usr/src/common/acpica/disassembler/Readme.resync b/usr/src/common/acpica/disassembler/Readme.resync
new file mode 100644
index 0000000000..439905cee4
--- /dev/null
+++ b/usr/src/common/acpica/disassembler/Readme.resync
@@ -0,0 +1,82 @@
+This file and its contents are supplied under the terms of the
+Common Development and Distribution License ("CDDL"), version 1.0.
+You may only use this file in accordance with the terms of version
+1.0 of the CDDL.
+
+A full copy of the text of the CDDL should have accompanied this
+source.  A copy of the CDDL is also available via the Internet at
+http://www.illumos.org/license/CDDL.
+
+Copyright (c) 2018, Joyent, Inc.
+
+---
+
+Files in this directory are used by kernel and user space code.  Things that are
+unsupported in the kernel need to be excluded for kernel builds.
+
+
+diff --git a/usr/src/common/acpica/disassembler/dmbuffer.c b/usr/src/common/acpica/disassembler/dmbuffer.c
+index 79c37e2..923a485 100644
+--- a/usr/src/common/acpica/disassembler/dmbuffer.c
++++ b/usr/src/common/acpica/disassembler/dmbuffer.c
+@@ -375,6 +375,7 @@ AcpiDmUuid (
+         Data[8], Data[9],
+         Data[10], Data[11], Data[12], Data[13], Data[14], Data[15]);
+ 
++#ifdef ACPI_APPLICATION
+     /* Dump the UUID description string if available */
+ 
+     Description = AcpiAhMatchUuid (Data);
+@@ -382,6 +383,7 @@ AcpiDmUuid (
+     {
+         AcpiOsPrintf (" /* %s */", Description);
+     }
++#endif
+ }
+ 
+ 
+diff --git a/usr/src/common/acpica/disassembler/dmresrcl2.c b/usr/src/common/acpica/disassembler/dmresrcl2.c
+index c725bec..2e32731 100644
+--- a/usr/src/common/acpica/disassembler/dmresrcl2.c
++++ b/usr/src/common/acpica/disassembler/dmresrcl2.c
+@@ -250,8 +250,10 @@ AcpiDmGpioCommon (
+     AcpiDmIndent (Level + 1);
+     AcpiOsPrintf ("}\n");
+ 
++#ifdef ACPI_APPLICATION
+     MpSaveGpioInfo (Info->MappingOp, Resource,
+         PinCount, PinList, DeviceName);
++#endif
+ }
+ 
+ 
+@@ -541,7 +543,9 @@ AcpiDmI2cSerialBusDescriptor (
+     AcpiDmDumpSerialBusVendorData (Resource, Level);
+     AcpiOsPrintf (")\n");
+ 
++#ifdef ACPI_APPLICATION
+     MpSaveSerialInfo (Info->MappingOp, Resource, DeviceName);
++#endif
+ }
+ 
+ 
+@@ -624,7 +628,9 @@ AcpiDmSpiSerialBusDescriptor (
+     AcpiDmDumpSerialBusVendorData (Resource, Level);
+     AcpiOsPrintf (")\n");
+ 
++#ifdef ACPI_APPLICATION
+     MpSaveSerialInfo (Info->MappingOp, Resource, DeviceName);
++#endif
+ }
+ 
+ 
+@@ -710,7 +716,9 @@ AcpiDmUartSerialBusDescriptor (
+     AcpiDmDumpSerialBusVendorData (Resource, Level);
+     AcpiOsPrintf (")\n");
+ 
++#ifdef ACPI_APPLICATION
+     MpSaveSerialInfo (Info->MappingOp, Resource, DeviceName);
++#endif
+ }
+ 
+ 
diff --git a/usr/src/uts/intel/io/acpica/disassembler/dmbuffer.c b/usr/src/common/acpica/disassembler/dmbuffer.c
similarity index 100%
rename from usr/src/uts/intel/io/acpica/disassembler/dmbuffer.c
rename to usr/src/common/acpica/disassembler/dmbuffer.c
diff --git a/usr/src/uts/intel/io/acpica/disassembler/dmcstyle.c b/usr/src/common/acpica/disassembler/dmcstyle.c
similarity index 100%
rename from usr/src/uts/intel/io/acpica/disassembler/dmcstyle.c
rename to usr/src/common/acpica/disassembler/dmcstyle.c
diff --git a/usr/src/uts/intel/io/acpica/disassembler/dmdeferred.c b/usr/src/common/acpica/disassembler/dmdeferred.c
similarity index 100%
rename from usr/src/uts/intel/io/acpica/disassembler/dmdeferred.c
rename to usr/src/common/acpica/disassembler/dmdeferred.c
diff --git a/usr/src/uts/intel/io/acpica/disassembler/dmnames.c b/usr/src/common/acpica/disassembler/dmnames.c
similarity index 100%
rename from usr/src/uts/intel/io/acpica/disassembler/dmnames.c
rename to usr/src/common/acpica/disassembler/dmnames.c
diff --git a/usr/src/uts/intel/io/acpica/disassembler/dmopcode.c b/usr/src/common/acpica/disassembler/dmopcode.c
similarity index 100%
rename from usr/src/uts/intel/io/acpica/disassembler/dmopcode.c
rename to usr/src/common/acpica/disassembler/dmopcode.c
diff --git a/usr/src/uts/intel/io/acpica/disassembler/dmresrc.c b/usr/src/common/acpica/disassembler/dmresrc.c
similarity index 100%
rename from usr/src/uts/intel/io/acpica/disassembler/dmresrc.c
rename to usr/src/common/acpica/disassembler/dmresrc.c
diff --git a/usr/src/uts/intel/io/acpica/disassembler/dmresrcl.c b/usr/src/common/acpica/disassembler/dmresrcl.c
similarity index 100%
rename from usr/src/uts/intel/io/acpica/disassembler/dmresrcl.c
rename to usr/src/common/acpica/disassembler/dmresrcl.c
diff --git a/usr/src/uts/intel/io/acpica/disassembler/dmresrcl2.c b/usr/src/common/acpica/disassembler/dmresrcl2.c
similarity index 100%
rename from usr/src/uts/intel/io/acpica/disassembler/dmresrcl2.c
rename to usr/src/common/acpica/disassembler/dmresrcl2.c
diff --git a/usr/src/uts/intel/io/acpica/disassembler/dmresrcs.c b/usr/src/common/acpica/disassembler/dmresrcs.c
similarity index 100%
rename from usr/src/uts/intel/io/acpica/disassembler/dmresrcs.c
rename to usr/src/common/acpica/disassembler/dmresrcs.c
diff --git a/usr/src/uts/intel/io/acpica/disassembler/dmutils.c b/usr/src/common/acpica/disassembler/dmutils.c
similarity index 100%
rename from usr/src/uts/intel/io/acpica/disassembler/dmutils.c
rename to usr/src/common/acpica/disassembler/dmutils.c
diff --git a/usr/src/uts/intel/io/acpica/disassembler/dmwalk.c b/usr/src/common/acpica/disassembler/dmwalk.c
similarity index 100%
rename from usr/src/uts/intel/io/acpica/disassembler/dmwalk.c
rename to usr/src/common/acpica/disassembler/dmwalk.c
diff --git a/usr/src/common/acpica/dispatcher/Readme.resync b/usr/src/common/acpica/dispatcher/Readme.resync
new file mode 100644
index 0000000000..876e68961c
--- /dev/null
+++ b/usr/src/common/acpica/dispatcher/Readme.resync
@@ -0,0 +1,114 @@
+This file and its contents are supplied under the terms of the
+Common Development and Distribution License ("CDDL"), version 1.0.
+You may only use this file in accordance with the terms of version
+1.0 of the CDDL.
+
+A full copy of the text of the CDDL should have accompanied this
+source.  A copy of the CDDL is also available via the Internet at
+http://www.illumos.org/license/CDDL.
+
+Copyright (c) 2018, Joyent, Inc.
+
+---
+
+Files in this directory are used by kernel and user space code.  Things that are
+unsupported in the kernel need to be excluded for kernel builds.
+
+diff --git a/usr/src/common/acpica/dispatcher/dscontrol.c b/usr/src/common/acpica/dispatcher/dscontrol.c
+index 3509f16..d603619 100644
+--- a/usr/src/common/acpica/dispatcher/dscontrol.c
++++ b/usr/src/common/acpica/dispatcher/dscontrol.c
+@@ -360,12 +360,14 @@ AcpiDsExecEndControlOp (
+ 
+     case AML_BREAK_POINT_OP:
+ 
++#ifdef ACPI_DEBUGGER
+         AcpiDbSignalBreakPoint (WalkState);
+ 
+         /* Call to the OSL in case OS wants a piece of the action */
+ 
+         Status = AcpiOsSignal (ACPI_SIGNAL_BREAKPOINT,
+             "Executed AML Breakpoint opcode");
++#endif
+         break;
+ 
+     case AML_BREAK_OP:
+diff --git a/usr/src/common/acpica/dispatcher/dsutils.c b/usr/src/common/acpica/dispatcher/dsutils.c
+index 66eac34..e294c83 100644
+--- a/usr/src/common/acpica/dispatcher/dsutils.c
++++ b/usr/src/common/acpica/dispatcher/dsutils.c
+@@ -647,7 +647,9 @@ AcpiDsCreateOperand (
+             return_ACPI_STATUS (Status);
+         }
+ 
++#ifdef ACPI_DEBUGGER
+         AcpiDbDisplayArgumentObject (ObjDesc, WalkState);
++#endif
+     }
+     else
+     {
+@@ -686,8 +688,10 @@ AcpiDsCreateOperand (
+             ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH,
+                 "Argument previously created, already stacked\n"));
+ 
++#ifdef ACPI_DEBUGGER
+             AcpiDbDisplayArgumentObject (
+                 WalkState->Operands [WalkState->NumOperands - 1], WalkState);
++#endif
+ 
+             /*
+              * Use value that was already previously returned
+@@ -734,7 +738,9 @@ AcpiDsCreateOperand (
+             return_ACPI_STATUS (Status);
+         }
+ 
++#ifdef ACPI_DEBUGGER
+         AcpiDbDisplayArgumentObject (ObjDesc, WalkState);
++#endif
+     }
+ 
+     return_ACPI_STATUS (AE_OK);
+diff --git a/usr/src/common/acpica/dispatcher/dswexec.c b/usr/src/common/acpica/dispatcher/dswexec.c
+index 307af60..8408ebf 100644
+--- a/usr/src/common/acpica/dispatcher/dswexec.c
++++ b/usr/src/common/acpica/dispatcher/dswexec.c
+@@ -193,9 +193,11 @@ Cleanup:
+         "Completed a predicate eval=%X Op=%p\n",
+         WalkState->ControlState->Common.Value, WalkState->Op));
+ 
++#ifdef ACPI_DEBUGGER
+     /* Break to debugger to display result */
+ 
+     AcpiDbDisplayResultObject (LocalObjDesc, WalkState);
++#endif
+ 
+     /*
+      * Delete the predicate result object (we know that
+@@ -419,6 +421,7 @@ AcpiDsExecEndOp (
+     WalkState->ReturnDesc = NULL;
+     WalkState->ResultObj = NULL;
+ 
++#ifdef ACPI_DEBUGGER
+     /* Call debugger for single step support (DEBUG build only) */
+ 
+     Status = AcpiDbSingleStep (WalkState, Op, OpClass);
+@@ -426,6 +429,7 @@ AcpiDsExecEndOp (
+     {
+         return_ACPI_STATUS (Status);
+     }
++#endif
+ 
+     /* Decode the Opcode Class */
+ 
+@@ -755,9 +759,11 @@ Cleanup:
+ 
+     if (WalkState->ResultObj)
+     {
++#ifdef ACPI_DEBUGGER
+         /* Break to debugger to display result */
+ 
+         AcpiDbDisplayResultObject (WalkState->ResultObj,WalkState);
++#endif
+ 
+         /*
+          * Delete the result op if and only if:
diff --git a/usr/src/uts/intel/io/acpica/dispatcher/dsargs.c b/usr/src/common/acpica/dispatcher/dsargs.c
similarity index 100%
rename from usr/src/uts/intel/io/acpica/dispatcher/dsargs.c
rename to usr/src/common/acpica/dispatcher/dsargs.c
diff --git a/usr/src/uts/intel/io/acpica/dispatcher/dscontrol.c b/usr/src/common/acpica/dispatcher/dscontrol.c
similarity index 100%
rename from usr/src/uts/intel/io/acpica/dispatcher/dscontrol.c
rename to usr/src/common/acpica/dispatcher/dscontrol.c
diff --git a/usr/src/uts/intel/io/acpica/dispatcher/dsdebug.c b/usr/src/common/acpica/dispatcher/dsdebug.c
similarity index 100%
rename from usr/src/uts/intel/io/acpica/dispatcher/dsdebug.c
rename to usr/src/common/acpica/dispatcher/dsdebug.c
diff --git a/usr/src/uts/intel/io/acpica/dispatcher/dsfield.c b/usr/src/common/acpica/dispatcher/dsfield.c
similarity index 100%
rename from usr/src/uts/intel/io/acpica/dispatcher/dsfield.c
rename to usr/src/common/acpica/dispatcher/dsfield.c
diff --git a/usr/src/uts/intel/io/acpica/dispatcher/dsinit.c b/usr/src/common/acpica/dispatcher/dsinit.c
similarity index 100%
rename from usr/src/uts/intel/io/acpica/dispatcher/dsinit.c
rename to usr/src/common/acpica/dispatcher/dsinit.c
diff --git a/usr/src/uts/intel/io/acpica/dispatcher/dsmethod.c b/usr/src/common/acpica/dispatcher/dsmethod.c
similarity index 100%
rename from usr/src/uts/intel/io/acpica/dispatcher/dsmethod.c
rename to usr/src/common/acpica/dispatcher/dsmethod.c
diff --git a/usr/src/uts/intel/io/acpica/dispatcher/dsmthdat.c b/usr/src/common/acpica/dispatcher/dsmthdat.c
similarity index 100%
rename from usr/src/uts/intel/io/acpica/dispatcher/dsmthdat.c
rename to usr/src/common/acpica/dispatcher/dsmthdat.c
diff --git a/usr/src/uts/intel/io/acpica/dispatcher/dsobject.c b/usr/src/common/acpica/dispatcher/dsobject.c
similarity index 100%
rename from usr/src/uts/intel/io/acpica/dispatcher/dsobject.c
rename to usr/src/common/acpica/dispatcher/dsobject.c
diff --git a/usr/src/uts/intel/io/acpica/dispatcher/dsopcode.c b/usr/src/common/acpica/dispatcher/dsopcode.c
similarity index 100%
rename from usr/src/uts/intel/io/acpica/dispatcher/dsopcode.c
rename to usr/src/common/acpica/dispatcher/dsopcode.c
diff --git a/usr/src/uts/intel/io/acpica/dispatcher/dsutils.c b/usr/src/common/acpica/dispatcher/dsutils.c
similarity index 100%
rename from usr/src/uts/intel/io/acpica/dispatcher/dsutils.c
rename to usr/src/common/acpica/dispatcher/dsutils.c
diff --git a/usr/src/uts/intel/io/acpica/dispatcher/dswexec.c b/usr/src/common/acpica/dispatcher/dswexec.c
similarity index 100%
rename from usr/src/uts/intel/io/acpica/dispatcher/dswexec.c
rename to usr/src/common/acpica/dispatcher/dswexec.c
diff --git a/usr/src/uts/intel/io/acpica/dispatcher/dswload.c b/usr/src/common/acpica/dispatcher/dswload.c
similarity index 100%
rename from usr/src/uts/intel/io/acpica/dispatcher/dswload.c
rename to usr/src/common/acpica/dispatcher/dswload.c
diff --git a/usr/src/uts/intel/io/acpica/dispatcher/dswload2.c b/usr/src/common/acpica/dispatcher/dswload2.c
similarity index 100%
rename from usr/src/uts/intel/io/acpica/dispatcher/dswload2.c
rename to usr/src/common/acpica/dispatcher/dswload2.c
diff --git a/usr/src/uts/intel/io/acpica/dispatcher/dswscope.c b/usr/src/common/acpica/dispatcher/dswscope.c
similarity index 100%
rename from usr/src/uts/intel/io/acpica/dispatcher/dswscope.c
rename to usr/src/common/acpica/dispatcher/dswscope.c
diff --git a/usr/src/uts/intel/io/acpica/dispatcher/dswstate.c b/usr/src/common/acpica/dispatcher/dswstate.c
similarity index 100%
rename from usr/src/uts/intel/io/acpica/dispatcher/dswstate.c
rename to usr/src/common/acpica/dispatcher/dswstate.c
diff --git a/usr/src/uts/intel/io/acpica/events/evevent.c b/usr/src/common/acpica/events/evevent.c
similarity index 100%
rename from usr/src/uts/intel/io/acpica/events/evevent.c
rename to usr/src/common/acpica/events/evevent.c
diff --git a/usr/src/uts/intel/io/acpica/events/evglock.c b/usr/src/common/acpica/events/evglock.c
similarity index 100%
rename from usr/src/uts/intel/io/acpica/events/evglock.c
rename to usr/src/common/acpica/events/evglock.c
diff --git a/usr/src/uts/intel/io/acpica/events/evgpe.c b/usr/src/common/acpica/events/evgpe.c
similarity index 100%
rename from usr/src/uts/intel/io/acpica/events/evgpe.c
rename to usr/src/common/acpica/events/evgpe.c
diff --git a/usr/src/uts/intel/io/acpica/events/evgpeblk.c b/usr/src/common/acpica/events/evgpeblk.c
similarity index 100%
rename from usr/src/uts/intel/io/acpica/events/evgpeblk.c
rename to usr/src/common/acpica/events/evgpeblk.c
diff --git a/usr/src/uts/intel/io/acpica/events/evgpeinit.c b/usr/src/common/acpica/events/evgpeinit.c
similarity index 100%
rename from usr/src/uts/intel/io/acpica/events/evgpeinit.c
rename to usr/src/common/acpica/events/evgpeinit.c
diff --git a/usr/src/uts/intel/io/acpica/events/evgpeutil.c b/usr/src/common/acpica/events/evgpeutil.c
similarity index 100%
rename from usr/src/uts/intel/io/acpica/events/evgpeutil.c
rename to usr/src/common/acpica/events/evgpeutil.c
diff --git a/usr/src/uts/intel/io/acpica/events/evhandler.c b/usr/src/common/acpica/events/evhandler.c
similarity index 100%
rename from usr/src/uts/intel/io/acpica/events/evhandler.c
rename to usr/src/common/acpica/events/evhandler.c
diff --git a/usr/src/uts/intel/io/acpica/events/evmisc.c b/usr/src/common/acpica/events/evmisc.c
similarity index 100%
rename from usr/src/uts/intel/io/acpica/events/evmisc.c
rename to usr/src/common/acpica/events/evmisc.c
diff --git a/usr/src/uts/intel/io/acpica/events/evregion.c b/usr/src/common/acpica/events/evregion.c
similarity index 100%
rename from usr/src/uts/intel/io/acpica/events/evregion.c
rename to usr/src/common/acpica/events/evregion.c
diff --git a/usr/src/uts/intel/io/acpica/events/evrgnini.c b/usr/src/common/acpica/events/evrgnini.c
similarity index 100%
rename from usr/src/uts/intel/io/acpica/events/evrgnini.c
rename to usr/src/common/acpica/events/evrgnini.c
diff --git a/usr/src/uts/intel/io/acpica/events/evsci.c b/usr/src/common/acpica/events/evsci.c
similarity index 100%
rename from usr/src/uts/intel/io/acpica/events/evsci.c
rename to usr/src/common/acpica/events/evsci.c
diff --git a/usr/src/uts/intel/io/acpica/events/evxface.c b/usr/src/common/acpica/events/evxface.c
similarity index 100%
rename from usr/src/uts/intel/io/acpica/events/evxface.c
rename to usr/src/common/acpica/events/evxface.c
diff --git a/usr/src/uts/intel/io/acpica/events/evxfevnt.c b/usr/src/common/acpica/events/evxfevnt.c
similarity index 100%
rename from usr/src/uts/intel/io/acpica/events/evxfevnt.c
rename to usr/src/common/acpica/events/evxfevnt.c
diff --git a/usr/src/uts/intel/io/acpica/events/evxfgpe.c b/usr/src/common/acpica/events/evxfgpe.c
similarity index 100%
rename from usr/src/uts/intel/io/acpica/events/evxfgpe.c
rename to usr/src/common/acpica/events/evxfgpe.c
diff --git a/usr/src/uts/intel/io/acpica/events/evxfregn.c b/usr/src/common/acpica/events/evxfregn.c
similarity index 100%
rename from usr/src/uts/intel/io/acpica/events/evxfregn.c
rename to usr/src/common/acpica/events/evxfregn.c
diff --git a/usr/src/uts/intel/io/acpica/executer/exconcat.c b/usr/src/common/acpica/executer/exconcat.c
similarity index 100%
rename from usr/src/uts/intel/io/acpica/executer/exconcat.c
rename to usr/src/common/acpica/executer/exconcat.c
diff --git a/usr/src/uts/intel/io/acpica/executer/exconfig.c b/usr/src/common/acpica/executer/exconfig.c
similarity index 100%
rename from usr/src/uts/intel/io/acpica/executer/exconfig.c
rename to usr/src/common/acpica/executer/exconfig.c
diff --git a/usr/src/uts/intel/io/acpica/executer/exconvrt.c b/usr/src/common/acpica/executer/exconvrt.c
similarity index 100%
rename from usr/src/uts/intel/io/acpica/executer/exconvrt.c
rename to usr/src/common/acpica/executer/exconvrt.c
diff --git a/usr/src/uts/intel/io/acpica/executer/excreate.c b/usr/src/common/acpica/executer/excreate.c
similarity index 100%
rename from usr/src/uts/intel/io/acpica/executer/excreate.c
rename to usr/src/common/acpica/executer/excreate.c
diff --git a/usr/src/uts/intel/io/acpica/executer/exdebug.c b/usr/src/common/acpica/executer/exdebug.c
similarity index 100%
rename from usr/src/uts/intel/io/acpica/executer/exdebug.c
rename to usr/src/common/acpica/executer/exdebug.c
diff --git a/usr/src/uts/intel/io/acpica/executer/exdump.c b/usr/src/common/acpica/executer/exdump.c
similarity index 100%
rename from usr/src/uts/intel/io/acpica/executer/exdump.c
rename to usr/src/common/acpica/executer/exdump.c
diff --git a/usr/src/uts/intel/io/acpica/executer/exfield.c b/usr/src/common/acpica/executer/exfield.c
similarity index 100%
rename from usr/src/uts/intel/io/acpica/executer/exfield.c
rename to usr/src/common/acpica/executer/exfield.c
diff --git a/usr/src/uts/intel/io/acpica/executer/exfldio.c b/usr/src/common/acpica/executer/exfldio.c
similarity index 100%
rename from usr/src/uts/intel/io/acpica/executer/exfldio.c
rename to usr/src/common/acpica/executer/exfldio.c
diff --git a/usr/src/uts/intel/io/acpica/executer/exmisc.c b/usr/src/common/acpica/executer/exmisc.c
similarity index 100%
rename from usr/src/uts/intel/io/acpica/executer/exmisc.c
rename to usr/src/common/acpica/executer/exmisc.c
diff --git a/usr/src/uts/intel/io/acpica/executer/exmutex.c b/usr/src/common/acpica/executer/exmutex.c
similarity index 100%
rename from usr/src/uts/intel/io/acpica/executer/exmutex.c
rename to usr/src/common/acpica/executer/exmutex.c
diff --git a/usr/src/uts/intel/io/acpica/executer/exnames.c b/usr/src/common/acpica/executer/exnames.c
similarity index 100%
rename from usr/src/uts/intel/io/acpica/executer/exnames.c
rename to usr/src/common/acpica/executer/exnames.c
diff --git a/usr/src/uts/intel/io/acpica/executer/exoparg1.c b/usr/src/common/acpica/executer/exoparg1.c
similarity index 100%
rename from usr/src/uts/intel/io/acpica/executer/exoparg1.c
rename to usr/src/common/acpica/executer/exoparg1.c
diff --git a/usr/src/uts/intel/io/acpica/executer/exoparg2.c b/usr/src/common/acpica/executer/exoparg2.c
similarity index 100%
rename from usr/src/uts/intel/io/acpica/executer/exoparg2.c
rename to usr/src/common/acpica/executer/exoparg2.c
diff --git a/usr/src/uts/intel/io/acpica/executer/exoparg3.c b/usr/src/common/acpica/executer/exoparg3.c
similarity index 100%
rename from usr/src/uts/intel/io/acpica/executer/exoparg3.c
rename to usr/src/common/acpica/executer/exoparg3.c
diff --git a/usr/src/uts/intel/io/acpica/executer/exoparg6.c b/usr/src/common/acpica/executer/exoparg6.c
similarity index 100%
rename from usr/src/uts/intel/io/acpica/executer/exoparg6.c
rename to usr/src/common/acpica/executer/exoparg6.c
diff --git a/usr/src/uts/intel/io/acpica/executer/exprep.c b/usr/src/common/acpica/executer/exprep.c
similarity index 100%
rename from usr/src/uts/intel/io/acpica/executer/exprep.c
rename to usr/src/common/acpica/executer/exprep.c
diff --git a/usr/src/uts/intel/io/acpica/executer/exregion.c b/usr/src/common/acpica/executer/exregion.c
similarity index 100%
rename from usr/src/uts/intel/io/acpica/executer/exregion.c
rename to usr/src/common/acpica/executer/exregion.c
diff --git a/usr/src/uts/intel/io/acpica/executer/exresnte.c b/usr/src/common/acpica/executer/exresnte.c
similarity index 100%
rename from usr/src/uts/intel/io/acpica/executer/exresnte.c
rename to usr/src/common/acpica/executer/exresnte.c
diff --git a/usr/src/uts/intel/io/acpica/executer/exresolv.c b/usr/src/common/acpica/executer/exresolv.c
similarity index 100%
rename from usr/src/uts/intel/io/acpica/executer/exresolv.c
rename to usr/src/common/acpica/executer/exresolv.c
diff --git a/usr/src/uts/intel/io/acpica/executer/exresop.c b/usr/src/common/acpica/executer/exresop.c
similarity index 100%
rename from usr/src/uts/intel/io/acpica/executer/exresop.c
rename to usr/src/common/acpica/executer/exresop.c
diff --git a/usr/src/uts/intel/io/acpica/executer/exstore.c b/usr/src/common/acpica/executer/exstore.c
similarity index 100%
rename from usr/src/uts/intel/io/acpica/executer/exstore.c
rename to usr/src/common/acpica/executer/exstore.c
diff --git a/usr/src/uts/intel/io/acpica/executer/exstoren.c b/usr/src/common/acpica/executer/exstoren.c
similarity index 100%
rename from usr/src/uts/intel/io/acpica/executer/exstoren.c
rename to usr/src/common/acpica/executer/exstoren.c
diff --git a/usr/src/uts/intel/io/acpica/executer/exstorob.c b/usr/src/common/acpica/executer/exstorob.c
similarity index 100%
rename from usr/src/uts/intel/io/acpica/executer/exstorob.c
rename to usr/src/common/acpica/executer/exstorob.c
diff --git a/usr/src/uts/intel/io/acpica/executer/exsystem.c b/usr/src/common/acpica/executer/exsystem.c
similarity index 100%
rename from usr/src/uts/intel/io/acpica/executer/exsystem.c
rename to usr/src/common/acpica/executer/exsystem.c
diff --git a/usr/src/uts/intel/io/acpica/executer/extrace.c b/usr/src/common/acpica/executer/extrace.c
similarity index 100%
rename from usr/src/uts/intel/io/acpica/executer/extrace.c
rename to usr/src/common/acpica/executer/extrace.c
diff --git a/usr/src/uts/intel/io/acpica/executer/exutils.c b/usr/src/common/acpica/executer/exutils.c
similarity index 100%
rename from usr/src/uts/intel/io/acpica/executer/exutils.c
rename to usr/src/common/acpica/executer/exutils.c
diff --git a/usr/src/uts/intel/io/acpica/hardware/hwacpi.c b/usr/src/common/acpica/hardware/hwacpi.c
similarity index 100%
rename from usr/src/uts/intel/io/acpica/hardware/hwacpi.c
rename to usr/src/common/acpica/hardware/hwacpi.c
diff --git a/usr/src/uts/intel/io/acpica/hardware/hwesleep.c b/usr/src/common/acpica/hardware/hwesleep.c
similarity index 100%
rename from usr/src/uts/intel/io/acpica/hardware/hwesleep.c
rename to usr/src/common/acpica/hardware/hwesleep.c
diff --git a/usr/src/uts/intel/io/acpica/hardware/hwgpe.c b/usr/src/common/acpica/hardware/hwgpe.c
similarity index 100%
rename from usr/src/uts/intel/io/acpica/hardware/hwgpe.c
rename to usr/src/common/acpica/hardware/hwgpe.c
diff --git a/usr/src/uts/intel/io/acpica/hardware/hwpci.c b/usr/src/common/acpica/hardware/hwpci.c
similarity index 100%
rename from usr/src/uts/intel/io/acpica/hardware/hwpci.c
rename to usr/src/common/acpica/hardware/hwpci.c
diff --git a/usr/src/uts/intel/io/acpica/hardware/hwregs.c b/usr/src/common/acpica/hardware/hwregs.c
similarity index 100%
rename from usr/src/uts/intel/io/acpica/hardware/hwregs.c
rename to usr/src/common/acpica/hardware/hwregs.c
diff --git a/usr/src/uts/intel/io/acpica/hardware/hwsleep.c b/usr/src/common/acpica/hardware/hwsleep.c
similarity index 100%
rename from usr/src/uts/intel/io/acpica/hardware/hwsleep.c
rename to usr/src/common/acpica/hardware/hwsleep.c
diff --git a/usr/src/uts/intel/io/acpica/hardware/hwtimer.c b/usr/src/common/acpica/hardware/hwtimer.c
similarity index 100%
rename from usr/src/uts/intel/io/acpica/hardware/hwtimer.c
rename to usr/src/common/acpica/hardware/hwtimer.c
diff --git a/usr/src/uts/intel/io/acpica/hardware/hwvalid.c b/usr/src/common/acpica/hardware/hwvalid.c
similarity index 100%
rename from usr/src/uts/intel/io/acpica/hardware/hwvalid.c
rename to usr/src/common/acpica/hardware/hwvalid.c
diff --git a/usr/src/uts/intel/io/acpica/hardware/hwxface.c b/usr/src/common/acpica/hardware/hwxface.c
similarity index 100%
rename from usr/src/uts/intel/io/acpica/hardware/hwxface.c
rename to usr/src/common/acpica/hardware/hwxface.c
diff --git a/usr/src/uts/intel/io/acpica/hardware/hwxfsleep.c b/usr/src/common/acpica/hardware/hwxfsleep.c
similarity index 100%
rename from usr/src/uts/intel/io/acpica/hardware/hwxfsleep.c
rename to usr/src/common/acpica/hardware/hwxfsleep.c
diff --git a/usr/src/uts/intel/io/acpica/namespace/nsaccess.c b/usr/src/common/acpica/namespace/nsaccess.c
similarity index 100%
rename from usr/src/uts/intel/io/acpica/namespace/nsaccess.c
rename to usr/src/common/acpica/namespace/nsaccess.c
diff --git a/usr/src/uts/intel/io/acpica/namespace/nsalloc.c b/usr/src/common/acpica/namespace/nsalloc.c
similarity index 100%
rename from usr/src/uts/intel/io/acpica/namespace/nsalloc.c
rename to usr/src/common/acpica/namespace/nsalloc.c
diff --git a/usr/src/uts/intel/io/acpica/namespace/nsarguments.c b/usr/src/common/acpica/namespace/nsarguments.c
similarity index 100%
rename from usr/src/uts/intel/io/acpica/namespace/nsarguments.c
rename to usr/src/common/acpica/namespace/nsarguments.c
diff --git a/usr/src/uts/intel/io/acpica/namespace/nsconvert.c b/usr/src/common/acpica/namespace/nsconvert.c
similarity index 100%
rename from usr/src/uts/intel/io/acpica/namespace/nsconvert.c
rename to usr/src/common/acpica/namespace/nsconvert.c
diff --git a/usr/src/uts/intel/io/acpica/namespace/nsdump.c b/usr/src/common/acpica/namespace/nsdump.c
similarity index 100%
rename from usr/src/uts/intel/io/acpica/namespace/nsdump.c
rename to usr/src/common/acpica/namespace/nsdump.c
diff --git a/usr/src/uts/intel/io/acpica/namespace/nsdumpdv.c b/usr/src/common/acpica/namespace/nsdumpdv.c
similarity index 100%
rename from usr/src/uts/intel/io/acpica/namespace/nsdumpdv.c
rename to usr/src/common/acpica/namespace/nsdumpdv.c
diff --git a/usr/src/uts/intel/io/acpica/namespace/nseval.c b/usr/src/common/acpica/namespace/nseval.c
similarity index 100%
rename from usr/src/uts/intel/io/acpica/namespace/nseval.c
rename to usr/src/common/acpica/namespace/nseval.c
diff --git a/usr/src/uts/intel/io/acpica/namespace/nsinit.c b/usr/src/common/acpica/namespace/nsinit.c
similarity index 100%
rename from usr/src/uts/intel/io/acpica/namespace/nsinit.c
rename to usr/src/common/acpica/namespace/nsinit.c
diff --git a/usr/src/uts/intel/io/acpica/namespace/nsload.c b/usr/src/common/acpica/namespace/nsload.c
similarity index 100%
rename from usr/src/uts/intel/io/acpica/namespace/nsload.c
rename to usr/src/common/acpica/namespace/nsload.c
diff --git a/usr/src/uts/intel/io/acpica/namespace/nsnames.c b/usr/src/common/acpica/namespace/nsnames.c
similarity index 100%
rename from usr/src/uts/intel/io/acpica/namespace/nsnames.c
rename to usr/src/common/acpica/namespace/nsnames.c
diff --git a/usr/src/uts/intel/io/acpica/namespace/nsobject.c b/usr/src/common/acpica/namespace/nsobject.c
similarity index 100%
rename from usr/src/uts/intel/io/acpica/namespace/nsobject.c
rename to usr/src/common/acpica/namespace/nsobject.c
diff --git a/usr/src/uts/intel/io/acpica/namespace/nsparse.c b/usr/src/common/acpica/namespace/nsparse.c
similarity index 100%
rename from usr/src/uts/intel/io/acpica/namespace/nsparse.c
rename to usr/src/common/acpica/namespace/nsparse.c
diff --git a/usr/src/uts/intel/io/acpica/namespace/nspredef.c b/usr/src/common/acpica/namespace/nspredef.c
similarity index 100%
rename from usr/src/uts/intel/io/acpica/namespace/nspredef.c
rename to usr/src/common/acpica/namespace/nspredef.c
diff --git a/usr/src/uts/intel/io/acpica/namespace/nsprepkg.c b/usr/src/common/acpica/namespace/nsprepkg.c
similarity index 100%
rename from usr/src/uts/intel/io/acpica/namespace/nsprepkg.c
rename to usr/src/common/acpica/namespace/nsprepkg.c
diff --git a/usr/src/uts/intel/io/acpica/namespace/nsrepair.c b/usr/src/common/acpica/namespace/nsrepair.c
similarity index 100%
rename from usr/src/uts/intel/io/acpica/namespace/nsrepair.c
rename to usr/src/common/acpica/namespace/nsrepair.c
diff --git a/usr/src/uts/intel/io/acpica/namespace/nsrepair2.c b/usr/src/common/acpica/namespace/nsrepair2.c
similarity index 100%
rename from usr/src/uts/intel/io/acpica/namespace/nsrepair2.c
rename to usr/src/common/acpica/namespace/nsrepair2.c
diff --git a/usr/src/uts/intel/io/acpica/namespace/nssearch.c b/usr/src/common/acpica/namespace/nssearch.c
similarity index 100%
rename from usr/src/uts/intel/io/acpica/namespace/nssearch.c
rename to usr/src/common/acpica/namespace/nssearch.c
diff --git a/usr/src/uts/intel/io/acpica/namespace/nsutils.c b/usr/src/common/acpica/namespace/nsutils.c
similarity index 100%
rename from usr/src/uts/intel/io/acpica/namespace/nsutils.c
rename to usr/src/common/acpica/namespace/nsutils.c
diff --git a/usr/src/uts/intel/io/acpica/namespace/nswalk.c b/usr/src/common/acpica/namespace/nswalk.c
similarity index 100%
rename from usr/src/uts/intel/io/acpica/namespace/nswalk.c
rename to usr/src/common/acpica/namespace/nswalk.c
diff --git a/usr/src/uts/intel/io/acpica/namespace/nsxfeval.c b/usr/src/common/acpica/namespace/nsxfeval.c
similarity index 100%
rename from usr/src/uts/intel/io/acpica/namespace/nsxfeval.c
rename to usr/src/common/acpica/namespace/nsxfeval.c
diff --git a/usr/src/uts/intel/io/acpica/namespace/nsxfname.c b/usr/src/common/acpica/namespace/nsxfname.c
similarity index 100%
rename from usr/src/uts/intel/io/acpica/namespace/nsxfname.c
rename to usr/src/common/acpica/namespace/nsxfname.c
diff --git a/usr/src/uts/intel/io/acpica/namespace/nsxfobj.c b/usr/src/common/acpica/namespace/nsxfobj.c
similarity index 100%
rename from usr/src/uts/intel/io/acpica/namespace/nsxfobj.c
rename to usr/src/common/acpica/namespace/nsxfobj.c
diff --git a/usr/src/uts/intel/io/acpica/parser/psargs.c b/usr/src/common/acpica/parser/psargs.c
similarity index 100%
rename from usr/src/uts/intel/io/acpica/parser/psargs.c
rename to usr/src/common/acpica/parser/psargs.c
diff --git a/usr/src/uts/intel/io/acpica/parser/psloop.c b/usr/src/common/acpica/parser/psloop.c
similarity index 100%
rename from usr/src/uts/intel/io/acpica/parser/psloop.c
rename to usr/src/common/acpica/parser/psloop.c
diff --git a/usr/src/uts/intel/io/acpica/parser/psobject.c b/usr/src/common/acpica/parser/psobject.c
similarity index 100%
rename from usr/src/uts/intel/io/acpica/parser/psobject.c
rename to usr/src/common/acpica/parser/psobject.c
diff --git a/usr/src/uts/intel/io/acpica/parser/psopcode.c b/usr/src/common/acpica/parser/psopcode.c
similarity index 100%
rename from usr/src/uts/intel/io/acpica/parser/psopcode.c
rename to usr/src/common/acpica/parser/psopcode.c
diff --git a/usr/src/uts/intel/io/acpica/parser/psopinfo.c b/usr/src/common/acpica/parser/psopinfo.c
similarity index 100%
rename from usr/src/uts/intel/io/acpica/parser/psopinfo.c
rename to usr/src/common/acpica/parser/psopinfo.c
diff --git a/usr/src/uts/intel/io/acpica/parser/psparse.c b/usr/src/common/acpica/parser/psparse.c
similarity index 100%
rename from usr/src/uts/intel/io/acpica/parser/psparse.c
rename to usr/src/common/acpica/parser/psparse.c
diff --git a/usr/src/uts/intel/io/acpica/parser/psscope.c b/usr/src/common/acpica/parser/psscope.c
similarity index 100%
rename from usr/src/uts/intel/io/acpica/parser/psscope.c
rename to usr/src/common/acpica/parser/psscope.c
diff --git a/usr/src/uts/intel/io/acpica/parser/pstree.c b/usr/src/common/acpica/parser/pstree.c
similarity index 100%
rename from usr/src/uts/intel/io/acpica/parser/pstree.c
rename to usr/src/common/acpica/parser/pstree.c
diff --git a/usr/src/uts/intel/io/acpica/parser/psutils.c b/usr/src/common/acpica/parser/psutils.c
similarity index 100%
rename from usr/src/uts/intel/io/acpica/parser/psutils.c
rename to usr/src/common/acpica/parser/psutils.c
diff --git a/usr/src/uts/intel/io/acpica/parser/pswalk.c b/usr/src/common/acpica/parser/pswalk.c
similarity index 100%
rename from usr/src/uts/intel/io/acpica/parser/pswalk.c
rename to usr/src/common/acpica/parser/pswalk.c
diff --git a/usr/src/uts/intel/io/acpica/parser/psxface.c b/usr/src/common/acpica/parser/psxface.c
similarity index 100%
rename from usr/src/uts/intel/io/acpica/parser/psxface.c
rename to usr/src/common/acpica/parser/psxface.c
diff --git a/usr/src/uts/intel/io/acpica/resources/rsaddr.c b/usr/src/common/acpica/resources/rsaddr.c
similarity index 100%
rename from usr/src/uts/intel/io/acpica/resources/rsaddr.c
rename to usr/src/common/acpica/resources/rsaddr.c
diff --git a/usr/src/uts/intel/io/acpica/resources/rscalc.c b/usr/src/common/acpica/resources/rscalc.c
similarity index 100%
rename from usr/src/uts/intel/io/acpica/resources/rscalc.c
rename to usr/src/common/acpica/resources/rscalc.c
diff --git a/usr/src/uts/intel/io/acpica/resources/rscreate.c b/usr/src/common/acpica/resources/rscreate.c
similarity index 100%
rename from usr/src/uts/intel/io/acpica/resources/rscreate.c
rename to usr/src/common/acpica/resources/rscreate.c
diff --git a/usr/src/uts/intel/io/acpica/resources/rsdump.c b/usr/src/common/acpica/resources/rsdump.c
similarity index 100%
rename from usr/src/uts/intel/io/acpica/resources/rsdump.c
rename to usr/src/common/acpica/resources/rsdump.c
diff --git a/usr/src/uts/intel/io/acpica/resources/rsdumpinfo.c b/usr/src/common/acpica/resources/rsdumpinfo.c
similarity index 100%
rename from usr/src/uts/intel/io/acpica/resources/rsdumpinfo.c
rename to usr/src/common/acpica/resources/rsdumpinfo.c
diff --git a/usr/src/uts/intel/io/acpica/resources/rsinfo.c b/usr/src/common/acpica/resources/rsinfo.c
similarity index 100%
rename from usr/src/uts/intel/io/acpica/resources/rsinfo.c
rename to usr/src/common/acpica/resources/rsinfo.c
diff --git a/usr/src/uts/intel/io/acpica/resources/rsio.c b/usr/src/common/acpica/resources/rsio.c
similarity index 100%
rename from usr/src/uts/intel/io/acpica/resources/rsio.c
rename to usr/src/common/acpica/resources/rsio.c
diff --git a/usr/src/uts/intel/io/acpica/resources/rsirq.c b/usr/src/common/acpica/resources/rsirq.c
similarity index 100%
rename from usr/src/uts/intel/io/acpica/resources/rsirq.c
rename to usr/src/common/acpica/resources/rsirq.c
diff --git a/usr/src/uts/intel/io/acpica/resources/rslist.c b/usr/src/common/acpica/resources/rslist.c
similarity index 100%
rename from usr/src/uts/intel/io/acpica/resources/rslist.c
rename to usr/src/common/acpica/resources/rslist.c
diff --git a/usr/src/uts/intel/io/acpica/resources/rsmemory.c b/usr/src/common/acpica/resources/rsmemory.c
similarity index 100%
rename from usr/src/uts/intel/io/acpica/resources/rsmemory.c
rename to usr/src/common/acpica/resources/rsmemory.c
diff --git a/usr/src/uts/intel/io/acpica/resources/rsmisc.c b/usr/src/common/acpica/resources/rsmisc.c
similarity index 100%
rename from usr/src/uts/intel/io/acpica/resources/rsmisc.c
rename to usr/src/common/acpica/resources/rsmisc.c
diff --git a/usr/src/uts/intel/io/acpica/resources/rsserial.c b/usr/src/common/acpica/resources/rsserial.c
similarity index 100%
rename from usr/src/uts/intel/io/acpica/resources/rsserial.c
rename to usr/src/common/acpica/resources/rsserial.c
diff --git a/usr/src/uts/intel/io/acpica/resources/rsutils.c b/usr/src/common/acpica/resources/rsutils.c
similarity index 100%
rename from usr/src/uts/intel/io/acpica/resources/rsutils.c
rename to usr/src/common/acpica/resources/rsutils.c
diff --git a/usr/src/uts/intel/io/acpica/resources/rsxface.c b/usr/src/common/acpica/resources/rsxface.c
similarity index 100%
rename from usr/src/uts/intel/io/acpica/resources/rsxface.c
rename to usr/src/common/acpica/resources/rsxface.c
diff --git a/usr/src/uts/intel/io/acpica/tables/tbdata.c b/usr/src/common/acpica/tables/tbdata.c
similarity index 100%
rename from usr/src/uts/intel/io/acpica/tables/tbdata.c
rename to usr/src/common/acpica/tables/tbdata.c
diff --git a/usr/src/uts/intel/io/acpica/tables/tbfadt.c b/usr/src/common/acpica/tables/tbfadt.c
similarity index 100%
rename from usr/src/uts/intel/io/acpica/tables/tbfadt.c
rename to usr/src/common/acpica/tables/tbfadt.c
diff --git a/usr/src/uts/intel/io/acpica/tables/tbfind.c b/usr/src/common/acpica/tables/tbfind.c
similarity index 100%
rename from usr/src/uts/intel/io/acpica/tables/tbfind.c
rename to usr/src/common/acpica/tables/tbfind.c
diff --git a/usr/src/uts/intel/io/acpica/tables/tbinstal.c b/usr/src/common/acpica/tables/tbinstal.c
similarity index 100%
rename from usr/src/uts/intel/io/acpica/tables/tbinstal.c
rename to usr/src/common/acpica/tables/tbinstal.c
diff --git a/usr/src/cmd/acpi/acpidump/tbprint.c b/usr/src/common/acpica/tables/tbprint.c
similarity index 100%
rename from usr/src/cmd/acpi/acpidump/tbprint.c
rename to usr/src/common/acpica/tables/tbprint.c
diff --git a/usr/src/uts/intel/io/acpica/tables/tbutils.c b/usr/src/common/acpica/tables/tbutils.c
similarity index 100%
rename from usr/src/uts/intel/io/acpica/tables/tbutils.c
rename to usr/src/common/acpica/tables/tbutils.c
diff --git a/usr/src/uts/intel/io/acpica/tables/tbxface.c b/usr/src/common/acpica/tables/tbxface.c
similarity index 100%
rename from usr/src/uts/intel/io/acpica/tables/tbxface.c
rename to usr/src/common/acpica/tables/tbxface.c
diff --git a/usr/src/uts/intel/io/acpica/tables/tbxfload.c b/usr/src/common/acpica/tables/tbxfload.c
similarity index 100%
rename from usr/src/uts/intel/io/acpica/tables/tbxfload.c
rename to usr/src/common/acpica/tables/tbxfload.c
diff --git a/usr/src/cmd/acpi/acpidump/tbxfroot.c b/usr/src/common/acpica/tables/tbxfroot.c
similarity index 100%
rename from usr/src/cmd/acpi/acpidump/tbxfroot.c
rename to usr/src/common/acpica/tables/tbxfroot.c
diff --git a/usr/src/cmd/acpi/acpidump/Readme b/usr/src/common/acpica/utilities/Readme.resync
similarity index 82%
rename from usr/src/cmd/acpi/acpidump/Readme
rename to usr/src/common/acpica/utilities/Readme.resync
index 58271787f1..dc7256a220 100644
--- a/usr/src/cmd/acpi/acpidump/Readme
+++ b/usr/src/common/acpica/utilities/Readme.resync
@@ -9,7 +9,7 @@ A full copy of the text of the CDDL should have accompanied this
 source.  A copy of the CDDL is also available via the Internet at
 http://www.illumos.org/license/CDDL.
 
-Copyright 2016 Joyent, Inc.
+Copyright (c) 2018, Joyent, Inc.
 
 ---
 
@@ -21,8 +21,10 @@ upstream, the following patch can be used against new versions of the acpi
 source.
 
 
---- a/usr/src/cmd/acpi/acpidump/utbuffer.c
-+++ b/usr/src/cmd/acpi/acpidump/utbuffer.c
+diff --git a/usr/src/common/acpica/utilities/utbuffer.c b/usr/src/common/acpica/utilities/utbuffer.c
+index 2f97c64..863055f 100644
+--- a/usr/src/common/acpica/utilities/utbuffer.c
++++ b/usr/src/common/acpica/utilities/utbuffer.c
 @@ -97,7 +97,7 @@ AcpiUtDumpBuffer (
      {
          /* Print current offset */
@@ -41,4 +43,3 @@ source.
  
          /* Print 16 hex chars */
  
-
diff --git a/usr/src/uts/intel/io/acpica/utilities/utaddress.c b/usr/src/common/acpica/utilities/utaddress.c
similarity index 100%
rename from usr/src/uts/intel/io/acpica/utilities/utaddress.c
rename to usr/src/common/acpica/utilities/utaddress.c
diff --git a/usr/src/uts/intel/io/acpica/utilities/utalloc.c b/usr/src/common/acpica/utilities/utalloc.c
similarity index 100%
rename from usr/src/uts/intel/io/acpica/utilities/utalloc.c
rename to usr/src/common/acpica/utilities/utalloc.c
diff --git a/usr/src/cmd/acpi/common/utascii.c b/usr/src/common/acpica/utilities/utascii.c
similarity index 100%
rename from usr/src/cmd/acpi/common/utascii.c
rename to usr/src/common/acpica/utilities/utascii.c
diff --git a/usr/src/cmd/acpi/acpidump/utbuffer.c b/usr/src/common/acpica/utilities/utbuffer.c
similarity index 100%
rename from usr/src/cmd/acpi/acpidump/utbuffer.c
rename to usr/src/common/acpica/utilities/utbuffer.c
diff --git a/usr/src/uts/intel/io/acpica/utilities/utcache.c b/usr/src/common/acpica/utilities/utcache.c
similarity index 100%
rename from usr/src/uts/intel/io/acpica/utilities/utcache.c
rename to usr/src/common/acpica/utilities/utcache.c
diff --git a/usr/src/uts/intel/io/acpica/utilities/utclib.c b/usr/src/common/acpica/utilities/utclib.c
similarity index 100%
rename from usr/src/uts/intel/io/acpica/utilities/utclib.c
rename to usr/src/common/acpica/utilities/utclib.c
diff --git a/usr/src/uts/intel/io/acpica/utilities/utcopy.c b/usr/src/common/acpica/utilities/utcopy.c
similarity index 100%
rename from usr/src/uts/intel/io/acpica/utilities/utcopy.c
rename to usr/src/common/acpica/utilities/utcopy.c
diff --git a/usr/src/cmd/acpi/common/utdebug.c b/usr/src/common/acpica/utilities/utdebug.c
similarity index 100%
rename from usr/src/cmd/acpi/common/utdebug.c
rename to usr/src/common/acpica/utilities/utdebug.c
diff --git a/usr/src/uts/intel/io/acpica/utilities/utdecode.c b/usr/src/common/acpica/utilities/utdecode.c
similarity index 100%
rename from usr/src/uts/intel/io/acpica/utilities/utdecode.c
rename to usr/src/common/acpica/utilities/utdecode.c
diff --git a/usr/src/uts/intel/io/acpica/utilities/utdelete.c b/usr/src/common/acpica/utilities/utdelete.c
similarity index 100%
rename from usr/src/uts/intel/io/acpica/utilities/utdelete.c
rename to usr/src/common/acpica/utilities/utdelete.c
diff --git a/usr/src/uts/intel/io/acpica/utilities/uterror.c b/usr/src/common/acpica/utilities/uterror.c
similarity index 100%
rename from usr/src/uts/intel/io/acpica/utilities/uterror.c
rename to usr/src/common/acpica/utilities/uterror.c
diff --git a/usr/src/uts/intel/io/acpica/utilities/uteval.c b/usr/src/common/acpica/utilities/uteval.c
similarity index 100%
rename from usr/src/uts/intel/io/acpica/utilities/uteval.c
rename to usr/src/common/acpica/utilities/uteval.c
diff --git a/usr/src/cmd/acpi/common/utexcep.c b/usr/src/common/acpica/utilities/utexcep.c
similarity index 100%
rename from usr/src/cmd/acpi/common/utexcep.c
rename to usr/src/common/acpica/utilities/utexcep.c
diff --git a/usr/src/cmd/acpi/common/utglobal.c b/usr/src/common/acpica/utilities/utglobal.c
similarity index 100%
rename from usr/src/cmd/acpi/common/utglobal.c
rename to usr/src/common/acpica/utilities/utglobal.c
diff --git a/usr/src/uts/intel/io/acpica/utilities/uthex.c b/usr/src/common/acpica/utilities/uthex.c
similarity index 100%
rename from usr/src/uts/intel/io/acpica/utilities/uthex.c
rename to usr/src/common/acpica/utilities/uthex.c
diff --git a/usr/src/uts/intel/io/acpica/utilities/utids.c b/usr/src/common/acpica/utilities/utids.c
similarity index 100%
rename from usr/src/uts/intel/io/acpica/utilities/utids.c
rename to usr/src/common/acpica/utilities/utids.c
diff --git a/usr/src/uts/intel/io/acpica/utilities/utinit.c b/usr/src/common/acpica/utilities/utinit.c
similarity index 100%
rename from usr/src/uts/intel/io/acpica/utilities/utinit.c
rename to usr/src/common/acpica/utilities/utinit.c
diff --git a/usr/src/uts/intel/io/acpica/utilities/utlock.c b/usr/src/common/acpica/utilities/utlock.c
similarity index 100%
rename from usr/src/uts/intel/io/acpica/utilities/utlock.c
rename to usr/src/common/acpica/utilities/utlock.c
diff --git a/usr/src/cmd/acpi/common/utmath.c b/usr/src/common/acpica/utilities/utmath.c
similarity index 100%
rename from usr/src/cmd/acpi/common/utmath.c
rename to usr/src/common/acpica/utilities/utmath.c
diff --git a/usr/src/uts/intel/io/acpica/utilities/utmisc.c b/usr/src/common/acpica/utilities/utmisc.c
similarity index 100%
rename from usr/src/uts/intel/io/acpica/utilities/utmisc.c
rename to usr/src/common/acpica/utilities/utmisc.c
diff --git a/usr/src/uts/intel/io/acpica/utilities/utmutex.c b/usr/src/common/acpica/utilities/utmutex.c
similarity index 100%
rename from usr/src/uts/intel/io/acpica/utilities/utmutex.c
rename to usr/src/common/acpica/utilities/utmutex.c
diff --git a/usr/src/cmd/acpi/common/utnonansi.c b/usr/src/common/acpica/utilities/utnonansi.c
similarity index 100%
rename from usr/src/cmd/acpi/common/utnonansi.c
rename to usr/src/common/acpica/utilities/utnonansi.c
diff --git a/usr/src/uts/intel/io/acpica/utilities/utobject.c b/usr/src/common/acpica/utilities/utobject.c
similarity index 100%
rename from usr/src/uts/intel/io/acpica/utilities/utobject.c
rename to usr/src/common/acpica/utilities/utobject.c
diff --git a/usr/src/uts/intel/io/acpica/utilities/utosi.c b/usr/src/common/acpica/utilities/utosi.c
similarity index 95%
rename from usr/src/uts/intel/io/acpica/utilities/utosi.c
rename to usr/src/common/acpica/utilities/utosi.c
index 18656fa017..674fe364d3 100644
--- a/usr/src/uts/intel/io/acpica/utilities/utosi.c
+++ b/usr/src/common/acpica/utilities/utosi.c
@@ -103,19 +103,9 @@ static ACPI_INTERFACE_INFO    AcpiDefaultSupportedInterfaces[] =
     {"Windows 2006 SP1",    NULL, 0, ACPI_OSI_WIN_VISTA_SP1},    /* Windows Vista SP1 - Added 09/2009 */
     {"Windows 2006 SP2",    NULL, 0, ACPI_OSI_WIN_VISTA_SP2},    /* Windows Vista SP2 - Added 09/2010 */
     {"Windows 2009",        NULL, 0, ACPI_OSI_WIN_7},            /* Windows 7 and Server 2008 R2 - Added 09/2009 */
-	/*
-	 * XXX
-	 * The following OSes are temporarily disabled. Windows introduced
-	 * support for xhci (USB 3.0) in Windows 8. When we advertise Windows 8
-	 * and newer support, some vendors use that as a key to automatically
-	 * transition all USB ports to the xhci controller. Until we have
-	 * support for the xhci controller, we should not advertise these
-	 * operating systems. From a brief survey, there isn't too much other
-	 * AML that this impacts at this time.
-	 */
-/*    {"Windows 2012",        NULL, 0, ACPI_OSI_WIN_8},*/            /* Windows 8 and Server 2012 - Added 08/2012 */
-/*    {"Windows 2013",        NULL, 0, ACPI_OSI_WIN_8},*/            /* Windows 8.1 and Server 2012 R2 - Added 01/2014 */
-/*    {"Windows 2015",        NULL, 0, ACPI_OSI_WIN_10},*/           /* Windows 10 - Added 03/2015 */
+    {"Windows 2012",        NULL, 0, ACPI_OSI_WIN_8},            /* Windows 8 and Server 2012 - Added 08/2012 */
+    {"Windows 2013",        NULL, 0, ACPI_OSI_WIN_8},            /* Windows 8.1 and Server 2012 R2 - Added 01/2014 */
+    {"Windows 2015",        NULL, 0, ACPI_OSI_WIN_10},           /* Windows 10 - Added 03/2015 */
 
     /* Feature Group Strings */
 
diff --git a/usr/src/uts/intel/io/acpica/utilities/utownerid.c b/usr/src/common/acpica/utilities/utownerid.c
similarity index 100%
rename from usr/src/uts/intel/io/acpica/utilities/utownerid.c
rename to usr/src/common/acpica/utilities/utownerid.c
diff --git a/usr/src/uts/intel/io/acpica/utilities/utpredef.c b/usr/src/common/acpica/utilities/utpredef.c
similarity index 100%
rename from usr/src/uts/intel/io/acpica/utilities/utpredef.c
rename to usr/src/common/acpica/utilities/utpredef.c
diff --git a/usr/src/cmd/acpi/common/utprint.c b/usr/src/common/acpica/utilities/utprint.c
similarity index 100%
rename from usr/src/cmd/acpi/common/utprint.c
rename to usr/src/common/acpica/utilities/utprint.c
diff --git a/usr/src/uts/intel/io/acpica/utilities/utresrc.c b/usr/src/common/acpica/utilities/utresrc.c
similarity index 100%
rename from usr/src/uts/intel/io/acpica/utilities/utresrc.c
rename to usr/src/common/acpica/utilities/utresrc.c
diff --git a/usr/src/uts/intel/io/acpica/utilities/utstate.c b/usr/src/common/acpica/utilities/utstate.c
similarity index 100%
rename from usr/src/uts/intel/io/acpica/utilities/utstate.c
rename to usr/src/common/acpica/utilities/utstate.c
diff --git a/usr/src/uts/intel/io/acpica/utilities/utstring.c b/usr/src/common/acpica/utilities/utstring.c
similarity index 100%
rename from usr/src/uts/intel/io/acpica/utilities/utstring.c
rename to usr/src/common/acpica/utilities/utstring.c
diff --git a/usr/src/uts/intel/io/acpica/utilities/uttrack.c b/usr/src/common/acpica/utilities/uttrack.c
similarity index 100%
rename from usr/src/uts/intel/io/acpica/utilities/uttrack.c
rename to usr/src/common/acpica/utilities/uttrack.c
diff --git a/usr/src/uts/intel/io/acpica/utilities/utuuid.c b/usr/src/common/acpica/utilities/utuuid.c
similarity index 100%
rename from usr/src/uts/intel/io/acpica/utilities/utuuid.c
rename to usr/src/common/acpica/utilities/utuuid.c
diff --git a/usr/src/uts/intel/io/acpica/utilities/utxface.c b/usr/src/common/acpica/utilities/utxface.c
similarity index 100%
rename from usr/src/uts/intel/io/acpica/utilities/utxface.c
rename to usr/src/common/acpica/utilities/utxface.c
diff --git a/usr/src/cmd/acpi/common/utxferror.c b/usr/src/common/acpica/utilities/utxferror.c
similarity index 100%
rename from usr/src/cmd/acpi/common/utxferror.c
rename to usr/src/common/acpica/utilities/utxferror.c
diff --git a/usr/src/uts/intel/io/acpica/utilities/utxfinit.c b/usr/src/common/acpica/utilities/utxfinit.c
similarity index 100%
rename from usr/src/uts/intel/io/acpica/utilities/utxfinit.c
rename to usr/src/common/acpica/utilities/utxfinit.c
diff --git a/usr/src/uts/intel/io/acpica/utilities/utxfmutex.c b/usr/src/common/acpica/utilities/utxfmutex.c
similarity index 100%
rename from usr/src/uts/intel/io/acpica/utilities/utxfmutex.c
rename to usr/src/common/acpica/utilities/utxfmutex.c
diff --git a/usr/src/pkg/manifests/developer-acpi.mf b/usr/src/pkg/manifests/developer-acpi.mf
index 487b085e6d..4b2b7fc23b 100644
--- a/usr/src/pkg/manifests/developer-acpi.mf
+++ b/usr/src/pkg/manifests/developer-acpi.mf
@@ -10,7 +10,7 @@
 #
 
 #
-# Copyright 2016 Joyent, Inc.
+# Copyright 2017 Joyent, Inc.
 #
 set name=pkg.fmri value=pkg:/developer/acpi@$(PKGVERS)
 set name=pkg.description value="ACPI utilities"
@@ -21,6 +21,7 @@ set name=variant.arch value=i386
 dir path=usr/share/man/man1m
 file path=usr/sbin/acpidump mode=0555
 file path=usr/sbin/acpixtract mode=0555
+file path=usr/sbin/iasl mode=0555
 file path=usr/share/man/man1m/acpidump.1m
 file path=usr/share/man/man1m/acpixtract.1m
 depend fmri=driver/x11/xsvc type=require
diff --git a/usr/src/pkg/manifests/developer-opensolaris-osnet.mf b/usr/src/pkg/manifests/developer-opensolaris-osnet.mf
index ef3473902a..ca27aff134 100644
--- a/usr/src/pkg/manifests/developer-opensolaris-osnet.mf
+++ b/usr/src/pkg/manifests/developer-opensolaris-osnet.mf
@@ -20,6 +20,7 @@
 #
 
 # Copyright (c) 2010, Oracle and/or its affiliates. All rights reserved.
+# Copyright (c) 2018, Joyent, Inc.
 
 set name=pkg.fmri value=pkg:/developer/opensolaris/osnet@$(PKGVERS)
 set name=pkg.description \
@@ -37,6 +38,7 @@ depend fmri=developer/build/onbld@0.5.11-0.133 type=require
 $(i386_ONLY)depend fmri=developer/gnu-binutils@2.19-0.133 type=require
 depend fmri=developer/java/jdk@0.5.11-0.133 type=require
 depend fmri=developer/lexer/flex@2.5.35-0.133 type=require
+depend fmri=developer/macro/gnu-m4@1.4 type=require
 depend fmri=developer/object-file@0.5.11-0.133 type=require
 depend fmri=developer/parser/bison@2.3-0.133 type=require
 depend fmri=developer/versioning/mercurial@1.3.1-0.133 type=require
diff --git a/usr/src/uts/intel/Makefile.files b/usr/src/uts/intel/Makefile.files
index f118f1f157..f9406097c6 100644
--- a/usr/src/uts/intel/Makefile.files
+++ b/usr/src/uts/intel/Makefile.files
@@ -242,8 +242,8 @@ ACPICA_OBJS	+= \
 		   utclib.o utcopy.o utdebug.o utdecode.o utdelete.o \
 		   uterror.o uteval.o utexcep.o utglobal.o uthex.o utids.o \
 		   utinit.o utlock.o utmath.o utmisc.o utmutex.o utnonansi.o \
-		   utobject.o utosi.o utownerid.o utpredef.o utprint.o \
-		   utresrc.o utstate.o utstring.o uttrack.o utuuid.o utxface.o \
+		   utobject.o utosi.o utownerid.o utpredef.o utresrc.o \
+		   utstate.o utstring.o uttrack.o utuuid.o utxface.o \
 		   utxferror.o utxfinit.o utxfmutex.o \
 		   \
 		   acpi_enum.o acpica_ec.o acpica.o ahids.o master_ops.o \
diff --git a/usr/src/uts/intel/Makefile.rules b/usr/src/uts/intel/Makefile.rules
index 55ed580da8..0054b66bef 100644
--- a/usr/src/uts/intel/Makefile.rules
+++ b/usr/src/uts/intel/Makefile.rules
@@ -21,7 +21,7 @@
 #
 # Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
 # Use is subject to license terms.
-# Copyright 2012 Joyent, Inc.  All rights reserved.
+# Copyright (c) 2018, Joyent, Inc.
 # Copyright 2017 Nexenta Systems, Inc.
 #
 
@@ -102,47 +102,43 @@ $(OBJS_DIR)/%.o:		$(UTSBASE)/intel/io/acpica/%.c
 $(OBJS_DIR)/%.o:		$(UTSBASE)/intel/io/acpica/%.s
 	$(COMPILE.s) -o $@ $<
 
-$(OBJS_DIR)/%.o:		$(UTSBASE)/intel/io/acpica/debugger/%.c
+$(OBJS_DIR)/%.o:		$(SRC)/common/acpica/events/%.c
 	$(COMPILE.c) -o $@ $<
 	$(CTFCONVERT_O)
 
-$(OBJS_DIR)/%.o:		$(UTSBASE)/intel/io/acpica/events/%.c
+$(OBJS_DIR)/%.o:		$(SRC)/common/acpica/hardware/%.c
 	$(COMPILE.c) -o $@ $<
 	$(CTFCONVERT_O)
 
-$(OBJS_DIR)/%.o:		$(UTSBASE)/intel/io/acpica/hardware/%.c
+$(OBJS_DIR)/%.o:		$(SRC)/common/acpica/dispatcher/%.c
 	$(COMPILE.c) -o $@ $<
 	$(CTFCONVERT_O)
 
-$(OBJS_DIR)/%.o:		$(UTSBASE)/intel/io/acpica/dispatcher/%.c
+$(OBJS_DIR)/%.o:		$(SRC)/common/acpica/executer/%.c
 	$(COMPILE.c) -o $@ $<
 	$(CTFCONVERT_O)
 
-$(OBJS_DIR)/%.o:		$(UTSBASE)/intel/io/acpica/executer/%.c
+$(OBJS_DIR)/%.o:		$(SRC)/common/acpica/parser/%.c
 	$(COMPILE.c) -o $@ $<
 	$(CTFCONVERT_O)
 
-$(OBJS_DIR)/%.o:		$(UTSBASE)/intel/io/acpica/parser/%.c
+$(OBJS_DIR)/%.o:		$(SRC)/common/acpica/namespace/%.c
 	$(COMPILE.c) -o $@ $<
 	$(CTFCONVERT_O)
 
-$(OBJS_DIR)/%.o:		$(UTSBASE)/intel/io/acpica/namespace/%.c
+$(OBJS_DIR)/%.o:		$(SRC)/common/acpica/resources/%.c
 	$(COMPILE.c) -o $@ $<
 	$(CTFCONVERT_O)
 
-$(OBJS_DIR)/%.o:		$(UTSBASE)/intel/io/acpica/resources/%.c
+$(OBJS_DIR)/%.o:		$(SRC)/common/acpica/tables/%.c
 	$(COMPILE.c) -o $@ $<
 	$(CTFCONVERT_O)
 
-$(OBJS_DIR)/%.o:		$(UTSBASE)/intel/io/acpica/tables/%.c
+$(OBJS_DIR)/%.o:		$(SRC)/common/acpica/utilities/%.c
 	$(COMPILE.c) -o $@ $<
 	$(CTFCONVERT_O)
 
-$(OBJS_DIR)/%.o:		$(UTSBASE)/intel/io/acpica/utilities/%.c
-	$(COMPILE.c) -o $@ $<
-	$(CTFCONVERT_O)
-
-$(OBJS_DIR)/%.o:		$(UTSBASE)/intel/io/acpica/disassembler/%.c
+$(OBJS_DIR)/%.o:		$(SRC)/common/acpica/disassembler/%.c
 	$(COMPILE.c) -o $@ $<
 	$(CTFCONVERT_O)
 
@@ -364,37 +360,34 @@ $(LINTS_DIR)/%.ln:		$(UTSBASE)/intel/io/acpica/%.s
 $(LINTS_DIR)/%.ln:		$(UTSBASE)/intel/io/acpica/%.c
 	@($(LHEAD) $(LINT.c) $< $(LTAIL))
 
-$(LINTS_DIR)/%.ln:		$(UTSBASE)/intel/io/acpica/debugger/%.c
-	@($(LHEAD) $(LINT.c) $< $(LTAIL))
-
-$(LINTS_DIR)/%.ln:		$(UTSBASE)/intel/io/acpica/events/%.c
+$(LINTS_DIR)/%.ln:		$(SRC)/common/acpica/events/%.c
 	@($(LHEAD) $(LINT.c) $< $(LTAIL))
 
-$(LINTS_DIR)/%.ln:		$(UTSBASE)/intel/io/acpica/hardware/%.c
+$(LINTS_DIR)/%.ln:		$(SRC)/common/acpica/hardware/%.c
 	@($(LHEAD) $(LINT.c) $< $(LTAIL))
 
-$(LINTS_DIR)/%.ln:		$(UTSBASE)/intel/io/acpica/dispatcher/%.c
+$(LINTS_DIR)/%.ln:		$(SRC)/common/acpica/dispatcher/%.c
 	@($(LHEAD) $(LINT.c) $< $(LTAIL))
 
-$(LINTS_DIR)/%.ln:		$(UTSBASE)/intel/io/acpica/executer/%.c
+$(LINTS_DIR)/%.ln:		$(SRC)/common/acpica/executer/%.c
 	@($(LHEAD) $(LINT.c) $< $(LTAIL))
 
-$(LINTS_DIR)/%.ln:		$(UTSBASE)/intel/io/acpica/parser/%.c
+$(LINTS_DIR)/%.ln:		$(SRC)/common/acpica/parser/%.c
 	@($(LHEAD) $(LINT.c) $< $(LTAIL))
 
-$(LINTS_DIR)/%.ln:		$(UTSBASE)/intel/io/acpica/namespace/%.c
+$(LINTS_DIR)/%.ln:		$(SRC)/common/acpica/namespace/%.c
 	@($(LHEAD) $(LINT.c) $< $(LTAIL))
 
-$(LINTS_DIR)/%.ln:		$(UTSBASE)/intel/io/acpica/resources/%.c
+$(LINTS_DIR)/%.ln:		$(SRC)/common/acpica/resources/%.c
 	@($(LHEAD) $(LINT.c) $< $(LTAIL))
 
-$(LINTS_DIR)/%.ln:		$(UTSBASE)/intel/io/acpica/tables/%.c
+$(LINTS_DIR)/%.ln:		$(SRC)/common/acpica/tables/%.c
 	@($(LHEAD) $(LINT.c) $< $(LTAIL))
 
-$(LINTS_DIR)/%.ln:		$(UTSBASE)/intel/io/acpica/utilities/%.c
+$(LINTS_DIR)/%.ln:		$(SRC)/common/acpica/utilities/%.c
 	@($(LHEAD) $(LINT.c) $< $(LTAIL))
 
-$(LINTS_DIR)/%.ln:		$(UTSBASE)/intel/io/acpica/disassembler/%.c
+$(LINTS_DIR)/%.ln:		$(SRC)/common/acpica/disassembler/%.c
 	@($(LHEAD) $(LINT.c) $< $(LTAIL))
 
 $(LINTS_DIR)/%.ln:		$(UTSBASE)/intel/io/agpgart/%.c
diff --git a/usr/src/uts/intel/io/acpica/tables/tbprint.c b/usr/src/uts/intel/io/acpica/tables/tbprint.c
deleted file mode 100644
index 9dab6d9d4a..0000000000
--- a/usr/src/uts/intel/io/acpica/tables/tbprint.c
+++ /dev/null
@@ -1,272 +0,0 @@
-/******************************************************************************
- *
- * Module Name: tbprint - Table output utilities
- *
- *****************************************************************************/
-
-/*
- * Copyright (C) 2000 - 2016, Intel Corp.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions, and the following disclaimer,
- *    without modification.
- * 2. Redistributions in binary form must reproduce at minimum a disclaimer
- *    substantially similar to the "NO WARRANTY" disclaimer below
- *    ("Disclaimer") and any redistribution must be conditioned upon
- *    including a substantially similar Disclaimer requirement for further
- *    binary redistribution.
- * 3. Neither the names of the above-listed copyright holders nor the names
- *    of any contributors may be used to endorse or promote products derived
- *    from this software without specific prior written permission.
- *
- * Alternatively, this software may be distributed under the terms of the
- * GNU General Public License ("GPL") version 2 as published by the Free
- * Software Foundation.
- *
- * NO WARRANTY
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
- * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGES.
- */
-
-#include "acpi.h"
-#include "accommon.h"
-#include "actables.h"
-
-#define _COMPONENT          ACPI_TABLES
-        ACPI_MODULE_NAME    ("tbprint")
-
-
-/* Local prototypes */
-
-static void
-AcpiTbFixString (
-    char                    *String,
-    ACPI_SIZE               Length);
-
-static void
-AcpiTbCleanupTableHeader (
-    ACPI_TABLE_HEADER       *OutHeader,
-    ACPI_TABLE_HEADER       *Header);
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiTbFixString
- *
- * PARAMETERS:  String              - String to be repaired
- *              Length              - Maximum length
- *
- * RETURN:      None
- *
- * DESCRIPTION: Replace every non-printable or non-ascii byte in the string
- *              with a question mark '?'.
- *
- ******************************************************************************/
-
-static void
-AcpiTbFixString (
-    char                    *String,
-    ACPI_SIZE               Length)
-{
-
-    while (Length && *String)
-    {
-        if (!isprint ((int) *String))
-        {
-            *String = '?';
-        }
-
-        String++;
-        Length--;
-    }
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiTbCleanupTableHeader
- *
- * PARAMETERS:  OutHeader           - Where the cleaned header is returned
- *              Header              - Input ACPI table header
- *
- * RETURN:      Returns the cleaned header in OutHeader
- *
- * DESCRIPTION: Copy the table header and ensure that all "string" fields in
- *              the header consist of printable characters.
- *
- ******************************************************************************/
-
-static void
-AcpiTbCleanupTableHeader (
-    ACPI_TABLE_HEADER       *OutHeader,
-    ACPI_TABLE_HEADER       *Header)
-{
-
-    memcpy (OutHeader, Header, sizeof (ACPI_TABLE_HEADER));
-
-    AcpiTbFixString (OutHeader->Signature, ACPI_NAME_SIZE);
-    AcpiTbFixString (OutHeader->OemId, ACPI_OEM_ID_SIZE);
-    AcpiTbFixString (OutHeader->OemTableId, ACPI_OEM_TABLE_ID_SIZE);
-    AcpiTbFixString (OutHeader->AslCompilerId, ACPI_NAME_SIZE);
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiTbPrintTableHeader
- *
- * PARAMETERS:  Address             - Table physical address
- *              Header              - Table header
- *
- * RETURN:      None
- *
- * DESCRIPTION: Print an ACPI table header. Special cases for FACS and RSDP.
- *
- ******************************************************************************/
-
-void
-AcpiTbPrintTableHeader (
-    ACPI_PHYSICAL_ADDRESS   Address,
-    ACPI_TABLE_HEADER       *Header)
-{
-    ACPI_TABLE_HEADER       LocalHeader;
-
-
-    if (ACPI_COMPARE_NAME (Header->Signature, ACPI_SIG_FACS))
-    {
-        /* FACS only has signature and length fields */
-
-        ACPI_INFO (("%-4.4s 0x%8.8X%8.8X %06X",
-            Header->Signature, ACPI_FORMAT_UINT64 (Address),
-            Header->Length));
-    }
-    else if (ACPI_VALIDATE_RSDP_SIG (Header->Signature))
-    {
-        /* RSDP has no common fields */
-
-        memcpy (LocalHeader.OemId, ACPI_CAST_PTR (ACPI_TABLE_RSDP,
-            Header)->OemId, ACPI_OEM_ID_SIZE);
-        AcpiTbFixString (LocalHeader.OemId, ACPI_OEM_ID_SIZE);
-
-        ACPI_INFO (("RSDP 0x%8.8X%8.8X %06X (v%.2d %-6.6s)",
-            ACPI_FORMAT_UINT64 (Address),
-            (ACPI_CAST_PTR (ACPI_TABLE_RSDP, Header)->Revision > 0) ?
-                ACPI_CAST_PTR (ACPI_TABLE_RSDP, Header)->Length : 20,
-            ACPI_CAST_PTR (ACPI_TABLE_RSDP, Header)->Revision,
-            LocalHeader.OemId));
-    }
-    else
-    {
-        /* Standard ACPI table with full common header */
-
-        AcpiTbCleanupTableHeader (&LocalHeader, Header);
-
-        ACPI_INFO ((
-            "%-4.4s 0x%8.8X%8.8X"
-            " %06X (v%.2d %-6.6s %-8.8s %08X %-4.4s %08X)",
-            LocalHeader.Signature, ACPI_FORMAT_UINT64 (Address),
-            LocalHeader.Length, LocalHeader.Revision, LocalHeader.OemId,
-            LocalHeader.OemTableId, LocalHeader.OemRevision,
-            LocalHeader.AslCompilerId, LocalHeader.AslCompilerRevision));
-    }
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiTbValidateChecksum
- *
- * PARAMETERS:  Table               - ACPI table to verify
- *              Length              - Length of entire table
- *
- * RETURN:      Status
- *
- * DESCRIPTION: Verifies that the table checksums to zero. Optionally returns
- *              exception on bad checksum.
- *
- ******************************************************************************/
-
-ACPI_STATUS
-AcpiTbVerifyChecksum (
-    ACPI_TABLE_HEADER       *Table,
-    UINT32                  Length)
-{
-    UINT8                   Checksum;
-
-
-    /*
-     * FACS/S3PT:
-     * They are the odd tables, have no standard ACPI header and no checksum
-     */
-
-    if (ACPI_COMPARE_NAME (Table->Signature, ACPI_SIG_S3PT) ||
-        ACPI_COMPARE_NAME (Table->Signature, ACPI_SIG_FACS))
-    {
-        return (AE_OK);
-    }
-
-    /* Compute the checksum on the table */
-
-    Checksum = AcpiTbChecksum (ACPI_CAST_PTR (UINT8, Table), Length);
-
-    /* Checksum ok? (should be zero) */
-
-    if (Checksum)
-    {
-        ACPI_BIOS_WARNING ((AE_INFO,
-            "Incorrect checksum in table [%4.4s] - 0x%2.2X, "
-            "should be 0x%2.2X",
-            Table->Signature, Table->Checksum,
-            (UINT8) (Table->Checksum - Checksum)));
-
-#if (ACPI_CHECKSUM_ABORT)
-        return (AE_BAD_CHECKSUM);
-#endif
-    }
-
-    return (AE_OK);
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiTbChecksum
- *
- * PARAMETERS:  Buffer          - Pointer to memory region to be checked
- *              Length          - Length of this memory region
- *
- * RETURN:      Checksum (UINT8)
- *
- * DESCRIPTION: Calculates circular checksum of memory region.
- *
- ******************************************************************************/
-
-UINT8
-AcpiTbChecksum (
-    UINT8                   *Buffer,
-    UINT32                  Length)
-{
-    UINT8                   Sum = 0;
-    UINT8                   *End = Buffer + Length;
-
-
-    while (Buffer < End)
-    {
-        Sum = (UINT8) (Sum + *(Buffer++));
-    }
-
-    return (Sum);
-}
diff --git a/usr/src/uts/intel/io/acpica/tables/tbxfroot.c b/usr/src/uts/intel/io/acpica/tables/tbxfroot.c
deleted file mode 100644
index aaa24c470f..0000000000
--- a/usr/src/uts/intel/io/acpica/tables/tbxfroot.c
+++ /dev/null
@@ -1,323 +0,0 @@
-/******************************************************************************
- *
- * Module Name: tbxfroot - Find the root ACPI table (RSDT)
- *
- *****************************************************************************/
-
-/*
- * Copyright (C) 2000 - 2016, Intel Corp.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions, and the following disclaimer,
- *    without modification.
- * 2. Redistributions in binary form must reproduce at minimum a disclaimer
- *    substantially similar to the "NO WARRANTY" disclaimer below
- *    ("Disclaimer") and any redistribution must be conditioned upon
- *    including a substantially similar Disclaimer requirement for further
- *    binary redistribution.
- * 3. Neither the names of the above-listed copyright holders nor the names
- *    of any contributors may be used to endorse or promote products derived
- *    from this software without specific prior written permission.
- *
- * Alternatively, this software may be distributed under the terms of the
- * GNU General Public License ("GPL") version 2 as published by the Free
- * Software Foundation.
- *
- * NO WARRANTY
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
- * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGES.
- */
-
-#include "acpi.h"
-#include "accommon.h"
-#include "actables.h"
-
-
-#define _COMPONENT          ACPI_TABLES
-        ACPI_MODULE_NAME    ("tbxfroot")
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiTbGetRsdpLength
- *
- * PARAMETERS:  Rsdp                - Pointer to RSDP
- *
- * RETURN:      Table length
- *
- * DESCRIPTION: Get the length of the RSDP
- *
- ******************************************************************************/
-
-UINT32
-AcpiTbGetRsdpLength (
-    ACPI_TABLE_RSDP         *Rsdp)
-{
-
-    if (!ACPI_VALIDATE_RSDP_SIG (Rsdp->Signature))
-    {
-        /* BAD Signature */
-
-        return (0);
-    }
-
-    /* "Length" field is available if table version >= 2 */
-
-    if (Rsdp->Revision >= 2)
-    {
-        return (Rsdp->Length);
-    }
-    else
-    {
-        return (ACPI_RSDP_CHECKSUM_LENGTH);
-    }
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiTbValidateRsdp
- *
- * PARAMETERS:  Rsdp                - Pointer to unvalidated RSDP
- *
- * RETURN:      Status
- *
- * DESCRIPTION: Validate the RSDP (ptr)
- *
- ******************************************************************************/
-
-ACPI_STATUS
-AcpiTbValidateRsdp (
-    ACPI_TABLE_RSDP         *Rsdp)
-{
-
-    /*
-     * The signature and checksum must both be correct
-     *
-     * Note: Sometimes there exists more than one RSDP in memory; the valid
-     * RSDP has a valid checksum, all others have an invalid checksum.
-     */
-    if (!ACPI_VALIDATE_RSDP_SIG (Rsdp->Signature))
-    {
-        /* Nope, BAD Signature */
-
-        return (AE_BAD_SIGNATURE);
-    }
-
-    /* Check the standard checksum */
-
-    if (AcpiTbChecksum ((UINT8 *) Rsdp, ACPI_RSDP_CHECKSUM_LENGTH) != 0)
-    {
-        return (AE_BAD_CHECKSUM);
-    }
-
-    /* Check extended checksum if table version >= 2 */
-
-    if ((Rsdp->Revision >= 2) &&
-        (AcpiTbChecksum ((UINT8 *) Rsdp, ACPI_RSDP_XCHECKSUM_LENGTH) != 0))
-    {
-        return (AE_BAD_CHECKSUM);
-    }
-
-    return (AE_OK);
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiFindRootPointer
- *
- * PARAMETERS:  TableAddress            - Where the table pointer is returned
- *
- * RETURN:      Status, RSDP physical address
- *
- * DESCRIPTION: Search lower 1Mbyte of memory for the root system descriptor
- *              pointer structure. If it is found, set *RSDP to point to it.
- *
- * NOTE1:       The RSDP must be either in the first 1K of the Extended
- *              BIOS Data Area or between E0000 and FFFFF (From ACPI Spec.)
- *              Only a 32-bit physical address is necessary.
- *
- * NOTE2:       This function is always available, regardless of the
- *              initialization state of the rest of ACPI.
- *
- ******************************************************************************/
-
-ACPI_STATUS
-AcpiFindRootPointer (
-    ACPI_PHYSICAL_ADDRESS   *TableAddress)
-{
-    UINT8                   *TablePtr;
-    UINT8                   *MemRover;
-    UINT32                  PhysicalAddress;
-
-
-    ACPI_FUNCTION_TRACE (AcpiFindRootPointer);
-
-
-    /* 1a) Get the location of the Extended BIOS Data Area (EBDA) */
-
-    TablePtr = AcpiOsMapMemory (
-        (ACPI_PHYSICAL_ADDRESS) ACPI_EBDA_PTR_LOCATION,
-        ACPI_EBDA_PTR_LENGTH);
-    if (!TablePtr)
-    {
-        ACPI_ERROR ((AE_INFO,
-            "Could not map memory at 0x%8.8X for length %u",
-            ACPI_EBDA_PTR_LOCATION, ACPI_EBDA_PTR_LENGTH));
-
-        return_ACPI_STATUS (AE_NO_MEMORY);
-    }
-
-    ACPI_MOVE_16_TO_32 (&PhysicalAddress, TablePtr);
-
-    /* Convert segment part to physical address */
-
-    PhysicalAddress <<= 4;
-    AcpiOsUnmapMemory (TablePtr, ACPI_EBDA_PTR_LENGTH);
-
-    /* EBDA present? */
-
-    if (PhysicalAddress > 0x400)
-    {
-        /*
-         * 1b) Search EBDA paragraphs (EBDA is required to be a
-         *     minimum of 1K length)
-         */
-        TablePtr = AcpiOsMapMemory (
-            (ACPI_PHYSICAL_ADDRESS) PhysicalAddress,
-            ACPI_EBDA_WINDOW_SIZE);
-        if (!TablePtr)
-        {
-            ACPI_ERROR ((AE_INFO,
-                "Could not map memory at 0x%8.8X for length %u",
-                PhysicalAddress, ACPI_EBDA_WINDOW_SIZE));
-
-            return_ACPI_STATUS (AE_NO_MEMORY);
-        }
-
-        MemRover = AcpiTbScanMemoryForRsdp (
-            TablePtr, ACPI_EBDA_WINDOW_SIZE);
-        AcpiOsUnmapMemory (TablePtr, ACPI_EBDA_WINDOW_SIZE);
-
-        if (MemRover)
-        {
-            /* Return the physical address */
-
-            PhysicalAddress +=
-                (UINT32) ACPI_PTR_DIFF (MemRover, TablePtr);
-
-            *TableAddress = (ACPI_PHYSICAL_ADDRESS) PhysicalAddress;
-            return_ACPI_STATUS (AE_OK);
-        }
-    }
-
-    /*
-     * 2) Search upper memory: 16-byte boundaries in E0000h-FFFFFh
-     */
-    TablePtr = AcpiOsMapMemory (
-        (ACPI_PHYSICAL_ADDRESS) ACPI_HI_RSDP_WINDOW_BASE,
-        ACPI_HI_RSDP_WINDOW_SIZE);
-
-    if (!TablePtr)
-    {
-        ACPI_ERROR ((AE_INFO,
-            "Could not map memory at 0x%8.8X for length %u",
-            ACPI_HI_RSDP_WINDOW_BASE, ACPI_HI_RSDP_WINDOW_SIZE));
-
-        return_ACPI_STATUS (AE_NO_MEMORY);
-    }
-
-    MemRover = AcpiTbScanMemoryForRsdp (
-        TablePtr, ACPI_HI_RSDP_WINDOW_SIZE);
-    AcpiOsUnmapMemory (TablePtr, ACPI_HI_RSDP_WINDOW_SIZE);
-
-    if (MemRover)
-    {
-        /* Return the physical address */
-
-        PhysicalAddress = (UINT32)
-            (ACPI_HI_RSDP_WINDOW_BASE + ACPI_PTR_DIFF (MemRover, TablePtr));
-
-        *TableAddress = (ACPI_PHYSICAL_ADDRESS) PhysicalAddress;
-        return_ACPI_STATUS (AE_OK);
-    }
-
-    /* A valid RSDP was not found */
-
-    ACPI_BIOS_ERROR ((AE_INFO, "A valid RSDP was not found"));
-    return_ACPI_STATUS (AE_NOT_FOUND);
-}
-
-ACPI_EXPORT_SYMBOL (AcpiFindRootPointer)
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiTbScanMemoryForRsdp
- *
- * PARAMETERS:  StartAddress        - Starting pointer for search
- *              Length              - Maximum length to search
- *
- * RETURN:      Pointer to the RSDP if found, otherwise NULL.
- *
- * DESCRIPTION: Search a block of memory for the RSDP signature
- *
- ******************************************************************************/
-
-UINT8 *
-AcpiTbScanMemoryForRsdp (
-    UINT8                   *StartAddress,
-    UINT32                  Length)
-{
-    ACPI_STATUS             Status;
-    UINT8                   *MemRover;
-    UINT8                   *EndAddress;
-
-
-    ACPI_FUNCTION_TRACE (TbScanMemoryForRsdp);
-
-
-    EndAddress = StartAddress + Length;
-
-    /* Search from given start address for the requested length */
-
-    for (MemRover = StartAddress; MemRover < EndAddress;
-         MemRover += ACPI_RSDP_SCAN_STEP)
-    {
-        /* The RSDP signature and checksum must both be correct */
-
-        Status = AcpiTbValidateRsdp (
-            ACPI_CAST_PTR (ACPI_TABLE_RSDP, MemRover));
-        if (ACPI_SUCCESS (Status))
-        {
-            /* Sig and checksum valid, we have found a real RSDP */
-
-            ACPI_DEBUG_PRINT ((ACPI_DB_INFO,
-                "RSDP located at physical address %p\n", MemRover));
-            return_PTR (MemRover);
-        }
-
-        /* No sig match or bad checksum, keep searching */
-    }
-
-    /* Searched entire block, no RSDP was found */
-
-    ACPI_DEBUG_PRINT ((ACPI_DB_INFO,
-        "Searched entire block from %p, valid RSDP was not found\n",
-        StartAddress));
-    return_PTR (NULL);
-}
diff --git a/usr/src/uts/intel/io/acpica/utilities/utbuffer.c b/usr/src/uts/intel/io/acpica/utilities/utbuffer.c
deleted file mode 100644
index 863055f737..0000000000
--- a/usr/src/uts/intel/io/acpica/utilities/utbuffer.c
+++ /dev/null
@@ -1,362 +0,0 @@
-/******************************************************************************
- *
- * Module Name: utbuffer - Buffer dump routines
- *
- *****************************************************************************/
-
-/*
- * Copyright (C) 2000 - 2016, Intel Corp.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions, and the following disclaimer,
- *    without modification.
- * 2. Redistributions in binary form must reproduce at minimum a disclaimer
- *    substantially similar to the "NO WARRANTY" disclaimer below
- *    ("Disclaimer") and any redistribution must be conditioned upon
- *    including a substantially similar Disclaimer requirement for further
- *    binary redistribution.
- * 3. Neither the names of the above-listed copyright holders nor the names
- *    of any contributors may be used to endorse or promote products derived
- *    from this software without specific prior written permission.
- *
- * Alternatively, this software may be distributed under the terms of the
- * GNU General Public License ("GPL") version 2 as published by the Free
- * Software Foundation.
- *
- * NO WARRANTY
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
- * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGES.
- */
-
-#include "acpi.h"
-#include "accommon.h"
-
-#define _COMPONENT          ACPI_UTILITIES
-        ACPI_MODULE_NAME    ("utbuffer")
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiUtDumpBuffer
- *
- * PARAMETERS:  Buffer              - Buffer to dump
- *              Count               - Amount to dump, in bytes
- *              Display             - BYTE, WORD, DWORD, or QWORD display:
- *                                      DB_BYTE_DISPLAY
- *                                      DB_WORD_DISPLAY
- *                                      DB_DWORD_DISPLAY
- *                                      DB_QWORD_DISPLAY
- *              BaseOffset          - Beginning buffer offset (display only)
- *
- * RETURN:      None
- *
- * DESCRIPTION: Generic dump buffer in both hex and ascii.
- *
- ******************************************************************************/
-
-void
-AcpiUtDumpBuffer (
-    UINT8                   *Buffer,
-    UINT32                  Count,
-    UINT32                  Display,
-    UINT32                  BaseOffset)
-{
-    UINT32                  i = 0;
-    UINT32                  j;
-    UINT32                  Temp32;
-    UINT8                   BufChar;
-
-
-    if (!Buffer)
-    {
-        AcpiOsPrintf ("Null Buffer Pointer in DumpBuffer!\n");
-        return;
-    }
-
-    if ((Count < 4) || (Count & 0x01))
-    {
-        Display = DB_BYTE_DISPLAY;
-    }
-
-    /* Nasty little dump buffer routine! */
-
-    while (i < Count)
-    {
-        /* Print current offset */
-
-        AcpiOsPrintf ("%6.4X: ", (BaseOffset + i));
-
-        /* Print 16 hex chars */
-
-        for (j = 0; j < 16;)
-        {
-            if (i + j >= Count)
-            {
-                /* Dump fill spaces */
-
-                AcpiOsPrintf ("%*s", ((Display * 2) + 1), " ");
-                j += Display;
-                continue;
-            }
-
-            switch (Display)
-            {
-            case DB_BYTE_DISPLAY:
-            default:    /* Default is BYTE display */
-
-                AcpiOsPrintf ("%02X ", Buffer[(ACPI_SIZE) i + j]);
-                break;
-
-            case DB_WORD_DISPLAY:
-
-                ACPI_MOVE_16_TO_32 (&Temp32, &Buffer[(ACPI_SIZE) i + j]);
-                AcpiOsPrintf ("%04X ", Temp32);
-                break;
-
-            case DB_DWORD_DISPLAY:
-
-                ACPI_MOVE_32_TO_32 (&Temp32, &Buffer[(ACPI_SIZE) i + j]);
-                AcpiOsPrintf ("%08X ", Temp32);
-                break;
-
-            case DB_QWORD_DISPLAY:
-
-                ACPI_MOVE_32_TO_32 (&Temp32, &Buffer[(ACPI_SIZE) i + j]);
-                AcpiOsPrintf ("%08X", Temp32);
-
-                ACPI_MOVE_32_TO_32 (&Temp32, &Buffer[(ACPI_SIZE) i + j + 4]);
-                AcpiOsPrintf ("%08X ", Temp32);
-                break;
-            }
-
-            j += Display;
-        }
-
-        /*
-         * Print the ASCII equivalent characters but watch out for the bad
-         * unprintable ones (printable chars are 0x20 through 0x7E)
-         */
-        AcpiOsPrintf (" ");
-        for (j = 0; j < 16; j++)
-        {
-            if (i + j >= Count)
-            {
-                AcpiOsPrintf ("\n");
-                return;
-            }
-
-            /*
-             * Add comment characters so rest of line is ignored when
-             * compiled
-             */
-            if (j == 0)
-            {
-                AcpiOsPrintf ("// ");
-            }
-
-            BufChar = Buffer[(ACPI_SIZE) i + j];
-            if (isprint (BufChar))
-            {
-                AcpiOsPrintf ("%c", BufChar);
-            }
-            else
-            {
-                AcpiOsPrintf (".");
-            }
-        }
-
-        /* Done with that line. */
-
-        AcpiOsPrintf ("\n");
-        i += 16;
-    }
-
-    return;
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiUtDebugDumpBuffer
- *
- * PARAMETERS:  Buffer              - Buffer to dump
- *              Count               - Amount to dump, in bytes
- *              Display             - BYTE, WORD, DWORD, or QWORD display:
- *                                      DB_BYTE_DISPLAY
- *                                      DB_WORD_DISPLAY
- *                                      DB_DWORD_DISPLAY
- *                                      DB_QWORD_DISPLAY
- *              ComponentID         - Caller's component ID
- *
- * RETURN:      None
- *
- * DESCRIPTION: Generic dump buffer in both hex and ascii.
- *
- ******************************************************************************/
-
-void
-AcpiUtDebugDumpBuffer (
-    UINT8                   *Buffer,
-    UINT32                  Count,
-    UINT32                  Display,
-    UINT32                  ComponentId)
-{
-
-    /* Only dump the buffer if tracing is enabled */
-
-    if (!((ACPI_LV_TABLES & AcpiDbgLevel) &&
-        (ComponentId & AcpiDbgLayer)))
-    {
-        return;
-    }
-
-    AcpiUtDumpBuffer (Buffer, Count, Display, 0);
-}
-
-
-#ifdef ACPI_APPLICATION
-/*******************************************************************************
- *
- * FUNCTION:    AcpiUtDumpBufferToFile
- *
- * PARAMETERS:  File                - File descriptor
- *              Buffer              - Buffer to dump
- *              Count               - Amount to dump, in bytes
- *              Display             - BYTE, WORD, DWORD, or QWORD display:
- *                                      DB_BYTE_DISPLAY
- *                                      DB_WORD_DISPLAY
- *                                      DB_DWORD_DISPLAY
- *                                      DB_QWORD_DISPLAY
- *              BaseOffset          - Beginning buffer offset (display only)
- *
- * RETURN:      None
- *
- * DESCRIPTION: Generic dump buffer in both hex and ascii to a file.
- *
- ******************************************************************************/
-
-void
-AcpiUtDumpBufferToFile (
-    ACPI_FILE               File,
-    UINT8                   *Buffer,
-    UINT32                  Count,
-    UINT32                  Display,
-    UINT32                  BaseOffset)
-{
-    UINT32                  i = 0;
-    UINT32                  j;
-    UINT32                  Temp32;
-    UINT8                   BufChar;
-
-
-    if (!Buffer)
-    {
-        AcpiUtFilePrintf (File, "Null Buffer Pointer in DumpBuffer!\n");
-        return;
-    }
-
-    if ((Count < 4) || (Count & 0x01))
-    {
-        Display = DB_BYTE_DISPLAY;
-    }
-
-    /* Nasty little dump buffer routine! */
-
-    while (i < Count)
-    {
-        /* Print current offset */
-
-        AcpiUtFilePrintf (File, "%6.4X: ", (BaseOffset + i));
-
-        /* Print 16 hex chars */
-
-        for (j = 0; j < 16;)
-        {
-            if (i + j >= Count)
-            {
-                /* Dump fill spaces */
-
-                AcpiUtFilePrintf (File, "%*s", ((Display * 2) + 1), " ");
-                j += Display;
-                continue;
-            }
-
-            switch (Display)
-            {
-            case DB_BYTE_DISPLAY:
-            default:    /* Default is BYTE display */
-
-                AcpiUtFilePrintf (File, "%02X ", Buffer[(ACPI_SIZE) i + j]);
-                break;
-
-            case DB_WORD_DISPLAY:
-
-                ACPI_MOVE_16_TO_32 (&Temp32, &Buffer[(ACPI_SIZE) i + j]);
-                AcpiUtFilePrintf (File, "%04X ", Temp32);
-                break;
-
-            case DB_DWORD_DISPLAY:
-
-                ACPI_MOVE_32_TO_32 (&Temp32, &Buffer[(ACPI_SIZE) i + j]);
-                AcpiUtFilePrintf (File, "%08X ", Temp32);
-                break;
-
-            case DB_QWORD_DISPLAY:
-
-                ACPI_MOVE_32_TO_32 (&Temp32, &Buffer[(ACPI_SIZE) i + j]);
-                AcpiUtFilePrintf (File, "%08X", Temp32);
-
-                ACPI_MOVE_32_TO_32 (&Temp32, &Buffer[(ACPI_SIZE) i + j + 4]);
-                AcpiUtFilePrintf (File, "%08X ", Temp32);
-                break;
-            }
-
-            j += Display;
-        }
-
-        /*
-         * Print the ASCII equivalent characters but watch out for the bad
-         * unprintable ones (printable chars are 0x20 through 0x7E)
-         */
-        AcpiUtFilePrintf (File, " ");
-        for (j = 0; j < 16; j++)
-        {
-            if (i + j >= Count)
-            {
-                AcpiUtFilePrintf (File, "\n");
-                return;
-            }
-
-            BufChar = Buffer[(ACPI_SIZE) i + j];
-            if (isprint (BufChar))
-            {
-                AcpiUtFilePrintf (File, "%c", BufChar);
-            }
-            else
-            {
-                AcpiUtFilePrintf (File, ".");
-            }
-        }
-
-        /* Done with that line. */
-
-        AcpiUtFilePrintf (File, "\n");
-        i += 16;
-    }
-
-    return;
-}
-#endif
diff --git a/usr/src/uts/intel/io/acpica/utilities/utdebug.c b/usr/src/uts/intel/io/acpica/utilities/utdebug.c
deleted file mode 100644
index 6a298d175b..0000000000
--- a/usr/src/uts/intel/io/acpica/utilities/utdebug.c
+++ /dev/null
@@ -1,740 +0,0 @@
-/******************************************************************************
- *
- * Module Name: utdebug - Debug print/trace routines
- *
- *****************************************************************************/
-
-/*
- * Copyright (C) 2000 - 2016, Intel Corp.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions, and the following disclaimer,
- *    without modification.
- * 2. Redistributions in binary form must reproduce at minimum a disclaimer
- *    substantially similar to the "NO WARRANTY" disclaimer below
- *    ("Disclaimer") and any redistribution must be conditioned upon
- *    including a substantially similar Disclaimer requirement for further
- *    binary redistribution.
- * 3. Neither the names of the above-listed copyright holders nor the names
- *    of any contributors may be used to endorse or promote products derived
- *    from this software without specific prior written permission.
- *
- * Alternatively, this software may be distributed under the terms of the
- * GNU General Public License ("GPL") version 2 as published by the Free
- * Software Foundation.
- *
- * NO WARRANTY
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
- * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGES.
- */
-
-#define EXPORT_ACPI_INTERFACES
-
-#include "acpi.h"
-#include "accommon.h"
-#include "acinterp.h"
-
-#define _COMPONENT          ACPI_UTILITIES
-        ACPI_MODULE_NAME    ("utdebug")
-
-
-#ifdef ACPI_DEBUG_OUTPUT
-
-static ACPI_THREAD_ID       AcpiGbl_PreviousThreadId = (ACPI_THREAD_ID) 0xFFFFFFFF;
-static const char           *AcpiGbl_FunctionEntryPrefix = "----Entry";
-static const char           *AcpiGbl_FunctionExitPrefix  = "----Exit-";
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiUtInitStackPtrTrace
- *
- * PARAMETERS:  None
- *
- * RETURN:      None
- *
- * DESCRIPTION: Save the current CPU stack pointer at subsystem startup
- *
- ******************************************************************************/
-
-void
-AcpiUtInitStackPtrTrace (
-    void)
-{
-    ACPI_SIZE               CurrentSp;
-
-
-    AcpiGbl_EntryStackPointer = &CurrentSp;
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiUtTrackStackPtr
- *
- * PARAMETERS:  None
- *
- * RETURN:      None
- *
- * DESCRIPTION: Save the current CPU stack pointer
- *
- ******************************************************************************/
-
-void
-AcpiUtTrackStackPtr (
-    void)
-{
-    ACPI_SIZE               CurrentSp;
-
-
-    if (&CurrentSp < AcpiGbl_LowestStackPointer)
-    {
-        AcpiGbl_LowestStackPointer = &CurrentSp;
-    }
-
-    if (AcpiGbl_NestingLevel > AcpiGbl_DeepestNesting)
-    {
-        AcpiGbl_DeepestNesting = AcpiGbl_NestingLevel;
-    }
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiUtTrimFunctionName
- *
- * PARAMETERS:  FunctionName        - Ascii string containing a procedure name
- *
- * RETURN:      Updated pointer to the function name
- *
- * DESCRIPTION: Remove the "Acpi" prefix from the function name, if present.
- *              This allows compiler macros such as __FUNCTION__ to be used
- *              with no change to the debug output.
- *
- ******************************************************************************/
-
-static const char *
-AcpiUtTrimFunctionName (
-    const char              *FunctionName)
-{
-
-    /* All Function names are longer than 4 chars, check is safe */
-
-    if (*(ACPI_CAST_PTR (UINT32, FunctionName)) == ACPI_PREFIX_MIXED)
-    {
-        /* This is the case where the original source has not been modified */
-
-        return (FunctionName + 4);
-    }
-
-    if (*(ACPI_CAST_PTR (UINT32, FunctionName)) == ACPI_PREFIX_LOWER)
-    {
-        /* This is the case where the source has been 'linuxized' */
-
-        return (FunctionName + 5);
-    }
-
-    return (FunctionName);
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiDebugPrint
- *
- * PARAMETERS:  RequestedDebugLevel - Requested debug print level
- *              LineNumber          - Caller's line number (for error output)
- *              FunctionName        - Caller's procedure name
- *              ModuleName          - Caller's module name
- *              ComponentId         - Caller's component ID
- *              Format              - Printf format field
- *              ...                 - Optional printf arguments
- *
- * RETURN:      None
- *
- * DESCRIPTION: Print error message with prefix consisting of the module name,
- *              line number, and component ID.
- *
- ******************************************************************************/
-
-void  ACPI_INTERNAL_VAR_XFACE
-AcpiDebugPrint (
-    UINT32                  RequestedDebugLevel,
-    UINT32                  LineNumber,
-    const char              *FunctionName,
-    const char              *ModuleName,
-    UINT32                  ComponentId,
-    const char              *Format,
-    ...)
-{
-    ACPI_THREAD_ID          ThreadId;
-    va_list                 args;
-
-
-    /* Check if debug output enabled */
-
-    if (!ACPI_IS_DEBUG_ENABLED (RequestedDebugLevel, ComponentId))
-    {
-        return;
-    }
-
-    /*
-     * Thread tracking and context switch notification
-     */
-    ThreadId = AcpiOsGetThreadId ();
-    if (ThreadId != AcpiGbl_PreviousThreadId)
-    {
-        if (ACPI_LV_THREADS & AcpiDbgLevel)
-        {
-            AcpiOsPrintf (
-                "\n**** Context Switch from TID %u to TID %u ****\n\n",
-                (UINT32) AcpiGbl_PreviousThreadId, (UINT32) ThreadId);
-        }
-
-        AcpiGbl_PreviousThreadId = ThreadId;
-        AcpiGbl_NestingLevel = 0;
-    }
-
-    /*
-     * Display the module name, current line number, thread ID (if requested),
-     * current procedure nesting level, and the current procedure name
-     */
-    AcpiOsPrintf ("%9s-%04ld ", ModuleName, LineNumber);
-
-#ifdef ACPI_APPLICATION
-    /*
-     * For AcpiExec/iASL only, emit the thread ID and nesting level.
-     * Note: nesting level is really only useful during a single-thread
-     * execution. Otherwise, multiple threads will keep resetting the
-     * level.
-     */
-    if (ACPI_LV_THREADS & AcpiDbgLevel)
-    {
-        AcpiOsPrintf ("[%u] ", (UINT32) ThreadId);
-    }
-
-    AcpiOsPrintf ("[%02ld] ", AcpiGbl_NestingLevel);
-#endif
-
-    AcpiOsPrintf ("%-22.22s: ", AcpiUtTrimFunctionName (FunctionName));
-
-    va_start (args, Format);
-    AcpiOsVprintf (Format, args);
-    va_end (args);
-}
-
-ACPI_EXPORT_SYMBOL (AcpiDebugPrint)
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiDebugPrintRaw
- *
- * PARAMETERS:  RequestedDebugLevel - Requested debug print level
- *              LineNumber          - Caller's line number
- *              FunctionName        - Caller's procedure name
- *              ModuleName          - Caller's module name
- *              ComponentId         - Caller's component ID
- *              Format              - Printf format field
- *              ...                 - Optional printf arguments
- *
- * RETURN:      None
- *
- * DESCRIPTION: Print message with no headers. Has same interface as
- *              DebugPrint so that the same macros can be used.
- *
- ******************************************************************************/
-
-void  ACPI_INTERNAL_VAR_XFACE
-AcpiDebugPrintRaw (
-    UINT32                  RequestedDebugLevel,
-    UINT32                  LineNumber,
-    const char              *FunctionName,
-    const char              *ModuleName,
-    UINT32                  ComponentId,
-    const char              *Format,
-    ...)
-{
-    va_list                 args;
-
-
-    /* Check if debug output enabled */
-
-    if (!ACPI_IS_DEBUG_ENABLED (RequestedDebugLevel, ComponentId))
-    {
-        return;
-    }
-
-    va_start (args, Format);
-    AcpiOsVprintf (Format, args);
-    va_end (args);
-}
-
-ACPI_EXPORT_SYMBOL (AcpiDebugPrintRaw)
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiUtTrace
- *
- * PARAMETERS:  LineNumber          - Caller's line number
- *              FunctionName        - Caller's procedure name
- *              ModuleName          - Caller's module name
- *              ComponentId         - Caller's component ID
- *
- * RETURN:      None
- *
- * DESCRIPTION: Function entry trace. Prints only if TRACE_FUNCTIONS bit is
- *              set in DebugLevel
- *
- ******************************************************************************/
-
-void
-AcpiUtTrace (
-    UINT32                  LineNumber,
-    const char              *FunctionName,
-    const char              *ModuleName,
-    UINT32                  ComponentId)
-{
-
-    AcpiGbl_NestingLevel++;
-    AcpiUtTrackStackPtr ();
-
-    /* Check if enabled up-front for performance */
-
-    if (ACPI_IS_DEBUG_ENABLED (ACPI_LV_FUNCTIONS, ComponentId))
-    {
-        AcpiDebugPrint (ACPI_LV_FUNCTIONS,
-            LineNumber, FunctionName, ModuleName, ComponentId,
-            "%s\n", AcpiGbl_FunctionEntryPrefix);
-    }
-}
-
-ACPI_EXPORT_SYMBOL (AcpiUtTrace)
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiUtTracePtr
- *
- * PARAMETERS:  LineNumber          - Caller's line number
- *              FunctionName        - Caller's procedure name
- *              ModuleName          - Caller's module name
- *              ComponentId         - Caller's component ID
- *              Pointer             - Pointer to display
- *
- * RETURN:      None
- *
- * DESCRIPTION: Function entry trace. Prints only if TRACE_FUNCTIONS bit is
- *              set in DebugLevel
- *
- ******************************************************************************/
-
-void
-AcpiUtTracePtr (
-    UINT32                  LineNumber,
-    const char              *FunctionName,
-    const char              *ModuleName,
-    UINT32                  ComponentId,
-    const void              *Pointer)
-{
-
-    AcpiGbl_NestingLevel++;
-    AcpiUtTrackStackPtr ();
-
-    /* Check if enabled up-front for performance */
-
-    if (ACPI_IS_DEBUG_ENABLED (ACPI_LV_FUNCTIONS, ComponentId))
-    {
-        AcpiDebugPrint (ACPI_LV_FUNCTIONS,
-            LineNumber, FunctionName, ModuleName, ComponentId,
-            "%s %p\n", AcpiGbl_FunctionEntryPrefix, Pointer);
-    }
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiUtTraceStr
- *
- * PARAMETERS:  LineNumber          - Caller's line number
- *              FunctionName        - Caller's procedure name
- *              ModuleName          - Caller's module name
- *              ComponentId         - Caller's component ID
- *              String              - Additional string to display
- *
- * RETURN:      None
- *
- * DESCRIPTION: Function entry trace. Prints only if TRACE_FUNCTIONS bit is
- *              set in DebugLevel
- *
- ******************************************************************************/
-
-void
-AcpiUtTraceStr (
-    UINT32                  LineNumber,
-    const char              *FunctionName,
-    const char              *ModuleName,
-    UINT32                  ComponentId,
-    const char              *String)
-{
-
-    AcpiGbl_NestingLevel++;
-    AcpiUtTrackStackPtr ();
-
-    /* Check if enabled up-front for performance */
-
-    if (ACPI_IS_DEBUG_ENABLED (ACPI_LV_FUNCTIONS, ComponentId))
-    {
-        AcpiDebugPrint (ACPI_LV_FUNCTIONS,
-            LineNumber, FunctionName, ModuleName, ComponentId,
-            "%s %s\n", AcpiGbl_FunctionEntryPrefix, String);
-    }
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiUtTraceU32
- *
- * PARAMETERS:  LineNumber          - Caller's line number
- *              FunctionName        - Caller's procedure name
- *              ModuleName          - Caller's module name
- *              ComponentId         - Caller's component ID
- *              Integer             - Integer to display
- *
- * RETURN:      None
- *
- * DESCRIPTION: Function entry trace. Prints only if TRACE_FUNCTIONS bit is
- *              set in DebugLevel
- *
- ******************************************************************************/
-
-void
-AcpiUtTraceU32 (
-    UINT32                  LineNumber,
-    const char              *FunctionName,
-    const char              *ModuleName,
-    UINT32                  ComponentId,
-    UINT32                  Integer)
-{
-
-    AcpiGbl_NestingLevel++;
-    AcpiUtTrackStackPtr ();
-
-    /* Check if enabled up-front for performance */
-
-    if (ACPI_IS_DEBUG_ENABLED (ACPI_LV_FUNCTIONS, ComponentId))
-    {
-        AcpiDebugPrint (ACPI_LV_FUNCTIONS,
-            LineNumber, FunctionName, ModuleName, ComponentId,
-            "%s %08X\n", AcpiGbl_FunctionEntryPrefix, Integer);
-    }
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiUtExit
- *
- * PARAMETERS:  LineNumber          - Caller's line number
- *              FunctionName        - Caller's procedure name
- *              ModuleName          - Caller's module name
- *              ComponentId         - Caller's component ID
- *
- * RETURN:      None
- *
- * DESCRIPTION: Function exit trace. Prints only if TRACE_FUNCTIONS bit is
- *              set in DebugLevel
- *
- ******************************************************************************/
-
-void
-AcpiUtExit (
-    UINT32                  LineNumber,
-    const char              *FunctionName,
-    const char              *ModuleName,
-    UINT32                  ComponentId)
-{
-
-    /* Check if enabled up-front for performance */
-
-    if (ACPI_IS_DEBUG_ENABLED (ACPI_LV_FUNCTIONS, ComponentId))
-    {
-        AcpiDebugPrint (ACPI_LV_FUNCTIONS,
-            LineNumber, FunctionName, ModuleName, ComponentId,
-            "%s\n", AcpiGbl_FunctionExitPrefix);
-    }
-
-    if (AcpiGbl_NestingLevel)
-    {
-        AcpiGbl_NestingLevel--;
-    }
-}
-
-ACPI_EXPORT_SYMBOL (AcpiUtExit)
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiUtStatusExit
- *
- * PARAMETERS:  LineNumber          - Caller's line number
- *              FunctionName        - Caller's procedure name
- *              ModuleName          - Caller's module name
- *              ComponentId         - Caller's component ID
- *              Status              - Exit status code
- *
- * RETURN:      None
- *
- * DESCRIPTION: Function exit trace. Prints only if TRACE_FUNCTIONS bit is
- *              set in DebugLevel. Prints exit status also.
- *
- ******************************************************************************/
-
-void
-AcpiUtStatusExit (
-    UINT32                  LineNumber,
-    const char              *FunctionName,
-    const char              *ModuleName,
-    UINT32                  ComponentId,
-    ACPI_STATUS             Status)
-{
-
-    /* Check if enabled up-front for performance */
-
-    if (ACPI_IS_DEBUG_ENABLED (ACPI_LV_FUNCTIONS, ComponentId))
-    {
-        if (ACPI_SUCCESS (Status))
-        {
-            AcpiDebugPrint (ACPI_LV_FUNCTIONS,
-                LineNumber, FunctionName, ModuleName, ComponentId,
-                "%s %s\n", AcpiGbl_FunctionExitPrefix,
-                AcpiFormatException (Status));
-        }
-        else
-        {
-            AcpiDebugPrint (ACPI_LV_FUNCTIONS,
-                LineNumber, FunctionName, ModuleName, ComponentId,
-                "%s ****Exception****: %s\n", AcpiGbl_FunctionExitPrefix,
-                AcpiFormatException (Status));
-        }
-    }
-
-    if (AcpiGbl_NestingLevel)
-    {
-        AcpiGbl_NestingLevel--;
-    }
-}
-
-ACPI_EXPORT_SYMBOL (AcpiUtStatusExit)
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiUtValueExit
- *
- * PARAMETERS:  LineNumber          - Caller's line number
- *              FunctionName        - Caller's procedure name
- *              ModuleName          - Caller's module name
- *              ComponentId         - Caller's component ID
- *              Value               - Value to be printed with exit msg
- *
- * RETURN:      None
- *
- * DESCRIPTION: Function exit trace. Prints only if TRACE_FUNCTIONS bit is
- *              set in DebugLevel. Prints exit value also.
- *
- ******************************************************************************/
-
-void
-AcpiUtValueExit (
-    UINT32                  LineNumber,
-    const char              *FunctionName,
-    const char              *ModuleName,
-    UINT32                  ComponentId,
-    UINT64                  Value)
-{
-
-    /* Check if enabled up-front for performance */
-
-    if (ACPI_IS_DEBUG_ENABLED (ACPI_LV_FUNCTIONS, ComponentId))
-    {
-        AcpiDebugPrint (ACPI_LV_FUNCTIONS,
-            LineNumber, FunctionName, ModuleName, ComponentId,
-            "%s %8.8X%8.8X\n", AcpiGbl_FunctionExitPrefix,
-            ACPI_FORMAT_UINT64 (Value));
-    }
-
-    if (AcpiGbl_NestingLevel)
-    {
-        AcpiGbl_NestingLevel--;
-    }
-}
-
-ACPI_EXPORT_SYMBOL (AcpiUtValueExit)
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiUtPtrExit
- *
- * PARAMETERS:  LineNumber          - Caller's line number
- *              FunctionName        - Caller's procedure name
- *              ModuleName          - Caller's module name
- *              ComponentId         - Caller's component ID
- *              Ptr                 - Pointer to display
- *
- * RETURN:      None
- *
- * DESCRIPTION: Function exit trace. Prints only if TRACE_FUNCTIONS bit is
- *              set in DebugLevel. Prints exit value also.
- *
- ******************************************************************************/
-
-void
-AcpiUtPtrExit (
-    UINT32                  LineNumber,
-    const char              *FunctionName,
-    const char              *ModuleName,
-    UINT32                  ComponentId,
-    UINT8                   *Ptr)
-{
-
-    /* Check if enabled up-front for performance */
-
-    if (ACPI_IS_DEBUG_ENABLED (ACPI_LV_FUNCTIONS, ComponentId))
-    {
-        AcpiDebugPrint (ACPI_LV_FUNCTIONS,
-            LineNumber, FunctionName, ModuleName, ComponentId,
-            "%s %p\n", AcpiGbl_FunctionExitPrefix, Ptr);
-    }
-
-    if (AcpiGbl_NestingLevel)
-    {
-        AcpiGbl_NestingLevel--;
-    }
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiUtStrExit
- *
- * PARAMETERS:  LineNumber          - Caller's line number
- *              FunctionName        - Caller's procedure name
- *              ModuleName          - Caller's module name
- *              ComponentId         - Caller's component ID
- *              String              - String to display
- *
- * RETURN:      None
- *
- * DESCRIPTION: Function exit trace. Prints only if TRACE_FUNCTIONS bit is
- *              set in DebugLevel. Prints exit value also.
- *
- ******************************************************************************/
-
-void
-AcpiUtStrExit (
-    UINT32                  LineNumber,
-    const char              *FunctionName,
-    const char              *ModuleName,
-    UINT32                  ComponentId,
-    const char              *String)
-{
-
-    /* Check if enabled up-front for performance */
-
-    if (ACPI_IS_DEBUG_ENABLED (ACPI_LV_FUNCTIONS, ComponentId))
-    {
-        AcpiDebugPrint (ACPI_LV_FUNCTIONS,
-            LineNumber, FunctionName, ModuleName, ComponentId,
-            "%s %s\n", AcpiGbl_FunctionExitPrefix, String);
-    }
-
-    if (AcpiGbl_NestingLevel)
-    {
-        AcpiGbl_NestingLevel--;
-    }
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiTracePoint
- *
- * PARAMETERS:  Type                - Trace event type
- *              Begin               - TRUE if before execution
- *              Aml                 - Executed AML address
- *              Pathname            - Object path
- *              Pointer             - Pointer to the related object
- *
- * RETURN:      None
- *
- * DESCRIPTION: Interpreter execution trace.
- *
- ******************************************************************************/
-
-void
-AcpiTracePoint (
-    ACPI_TRACE_EVENT_TYPE   Type,
-    BOOLEAN                 Begin,
-    UINT8                   *Aml,
-    char                    *Pathname)
-{
-
-    ACPI_FUNCTION_ENTRY ();
-
-    AcpiExTracePoint (Type, Begin, Aml, Pathname);
-
-#ifdef ACPI_USE_SYSTEM_TRACER
-    AcpiOsTracePoint (Type, Begin, Aml, Pathname);
-#endif
-}
-
-ACPI_EXPORT_SYMBOL (AcpiTracePoint)
-
-#endif
-
-
-#ifdef ACPI_APPLICATION
-/*******************************************************************************
- *
- * FUNCTION:    AcpiLogError
- *
- * PARAMETERS:  Format              - Printf format field
- *              ...                 - Optional printf arguments
- *
- * RETURN:      None
- *
- * DESCRIPTION: Print error message to the console, used by applications.
- *
- ******************************************************************************/
-
-void  ACPI_INTERNAL_VAR_XFACE
-AcpiLogError (
-    const char              *Format,
-    ...)
-{
-    va_list                 Args;
-
-    va_start (Args, Format);
-    (void) AcpiUtFileVprintf (ACPI_FILE_ERR, Format, Args);
-    va_end (Args);
-}
-
-ACPI_EXPORT_SYMBOL (AcpiLogError)
-#endif
diff --git a/usr/src/uts/intel/io/acpica/utilities/utexcep.c b/usr/src/uts/intel/io/acpica/utilities/utexcep.c
deleted file mode 100644
index 5be8efd5f2..0000000000
--- a/usr/src/uts/intel/io/acpica/utilities/utexcep.c
+++ /dev/null
@@ -1,179 +0,0 @@
-/*******************************************************************************
- *
- * Module Name: utexcep - Exception code support
- *
- ******************************************************************************/
-
-/*
- * Copyright (C) 2000 - 2016, Intel Corp.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions, and the following disclaimer,
- *    without modification.
- * 2. Redistributions in binary form must reproduce at minimum a disclaimer
- *    substantially similar to the "NO WARRANTY" disclaimer below
- *    ("Disclaimer") and any redistribution must be conditioned upon
- *    including a substantially similar Disclaimer requirement for further
- *    binary redistribution.
- * 3. Neither the names of the above-listed copyright holders nor the names
- *    of any contributors may be used to endorse or promote products derived
- *    from this software without specific prior written permission.
- *
- * Alternatively, this software may be distributed under the terms of the
- * GNU General Public License ("GPL") version 2 as published by the Free
- * Software Foundation.
- *
- * NO WARRANTY
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
- * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGES.
- */
-
-#define EXPORT_ACPI_INTERFACES
-
-#define ACPI_DEFINE_EXCEPTION_TABLE
-#include "acpi.h"
-#include "accommon.h"
-
-
-#define _COMPONENT          ACPI_UTILITIES
-        ACPI_MODULE_NAME    ("utexcep")
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiFormatException
- *
- * PARAMETERS:  Status              - The ACPI_STATUS code to be formatted
- *
- * RETURN:      A string containing the exception text. A valid pointer is
- *              always returned.
- *
- * DESCRIPTION: This function translates an ACPI exception into an ASCII
- *              string. Returns "unknown status" string for invalid codes.
- *
- ******************************************************************************/
-
-const char *
-AcpiFormatException (
-    ACPI_STATUS             Status)
-{
-    const ACPI_EXCEPTION_INFO   *Exception;
-
-
-    ACPI_FUNCTION_ENTRY ();
-
-
-    Exception = AcpiUtValidateException (Status);
-    if (!Exception)
-    {
-        /* Exception code was not recognized */
-
-        ACPI_ERROR ((AE_INFO,
-            "Unknown exception code: 0x%8.8X", Status));
-
-        return ("UNKNOWN_STATUS_CODE");
-    }
-
-    return (Exception->Name);
-}
-
-ACPI_EXPORT_SYMBOL (AcpiFormatException)
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiUtValidateException
- *
- * PARAMETERS:  Status              - The ACPI_STATUS code to be formatted
- *
- * RETURN:      A string containing the exception text. NULL if exception is
- *              not valid.
- *
- * DESCRIPTION: This function validates and translates an ACPI exception into
- *              an ASCII string.
- *
- ******************************************************************************/
-
-const ACPI_EXCEPTION_INFO *
-AcpiUtValidateException (
-    ACPI_STATUS             Status)
-{
-    UINT32                      SubStatus;
-    const ACPI_EXCEPTION_INFO   *Exception = NULL;
-
-
-    ACPI_FUNCTION_ENTRY ();
-
-
-    /*
-     * Status is composed of two parts, a "type" and an actual code
-     */
-    SubStatus = (Status & ~AE_CODE_MASK);
-
-    switch (Status & AE_CODE_MASK)
-    {
-    case AE_CODE_ENVIRONMENTAL:
-
-        if (SubStatus <= AE_CODE_ENV_MAX)
-        {
-            Exception = &AcpiGbl_ExceptionNames_Env [SubStatus];
-        }
-        break;
-
-    case AE_CODE_PROGRAMMER:
-
-        if (SubStatus <= AE_CODE_PGM_MAX)
-        {
-            Exception = &AcpiGbl_ExceptionNames_Pgm [SubStatus];
-        }
-        break;
-
-    case AE_CODE_ACPI_TABLES:
-
-        if (SubStatus <= AE_CODE_TBL_MAX)
-        {
-            Exception = &AcpiGbl_ExceptionNames_Tbl [SubStatus];
-        }
-        break;
-
-    case AE_CODE_AML:
-
-        if (SubStatus <= AE_CODE_AML_MAX)
-        {
-            Exception = &AcpiGbl_ExceptionNames_Aml [SubStatus];
-        }
-        break;
-
-    case AE_CODE_CONTROL:
-
-        if (SubStatus <= AE_CODE_CTRL_MAX)
-        {
-            Exception = &AcpiGbl_ExceptionNames_Ctrl [SubStatus];
-        }
-        break;
-
-    default:
-
-        break;
-    }
-
-    if (!Exception || !Exception->Name)
-    {
-        return (NULL);
-    }
-
-    return (Exception);
-}
diff --git a/usr/src/uts/intel/io/acpica/utilities/utglobal.c b/usr/src/uts/intel/io/acpica/utilities/utglobal.c
deleted file mode 100644
index 0d8dff88c9..0000000000
--- a/usr/src/uts/intel/io/acpica/utilities/utglobal.c
+++ /dev/null
@@ -1,243 +0,0 @@
-/******************************************************************************
- *
- * Module Name: utglobal - Global variables for the ACPI subsystem
- *
- *****************************************************************************/
-
-/*
- * Copyright (C) 2000 - 2016, Intel Corp.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions, and the following disclaimer,
- *    without modification.
- * 2. Redistributions in binary form must reproduce at minimum a disclaimer
- *    substantially similar to the "NO WARRANTY" disclaimer below
- *    ("Disclaimer") and any redistribution must be conditioned upon
- *    including a substantially similar Disclaimer requirement for further
- *    binary redistribution.
- * 3. Neither the names of the above-listed copyright holders nor the names
- *    of any contributors may be used to endorse or promote products derived
- *    from this software without specific prior written permission.
- *
- * Alternatively, this software may be distributed under the terms of the
- * GNU General Public License ("GPL") version 2 as published by the Free
- * Software Foundation.
- *
- * NO WARRANTY
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
- * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGES.
- */
-
-#define EXPORT_ACPI_INTERFACES
-#define DEFINE_ACPI_GLOBALS
-
-#include "acpi.h"
-#include "accommon.h"
-
-#define _COMPONENT          ACPI_UTILITIES
-        ACPI_MODULE_NAME    ("utglobal")
-
-
-/*******************************************************************************
- *
- * Static global variable initialization.
- *
- ******************************************************************************/
-
-/* Various state name strings */
-
-const char                  *AcpiGbl_SleepStateNames[ACPI_S_STATE_COUNT] =
-{
-    "\\_S0_",
-    "\\_S1_",
-    "\\_S2_",
-    "\\_S3_",
-    "\\_S4_",
-    "\\_S5_"
-};
-
-const char                  *AcpiGbl_LowestDstateNames[ACPI_NUM_SxW_METHODS] =
-{
-    "_S0W",
-    "_S1W",
-    "_S2W",
-    "_S3W",
-    "_S4W"
-};
-
-const char                  *AcpiGbl_HighestDstateNames[ACPI_NUM_SxD_METHODS] =
-{
-    "_S1D",
-    "_S2D",
-    "_S3D",
-    "_S4D"
-};
-
-
-/* Hex-to-ascii */
-
-const char                  AcpiGbl_LowerHexDigits[] = "0123456789abcdef";
-const char                  AcpiGbl_UpperHexDigits[] = "0123456789ABCDEF";
-
-
-/*******************************************************************************
- *
- * Namespace globals
- *
- ******************************************************************************/
-
-/*
- * Predefined ACPI Names (Built-in to the Interpreter)
- *
- * NOTES:
- * 1) _SB_ is defined to be a device to allow \_SB_._INI to be run
- *    during the initialization sequence.
- * 2) _TZ_ is defined to be a thermal zone in order to allow ASL code to
- *    perform a Notify() operation on it. 09/2010: Changed to type Device.
- *    This still allows notifies, but does not confuse host code that
- *    searches for valid ThermalZone objects.
- */
-const ACPI_PREDEFINED_NAMES     AcpiGbl_PreDefinedNames[] =
-{
-    {"_GPE",    ACPI_TYPE_LOCAL_SCOPE,      NULL},
-    {"_PR_",    ACPI_TYPE_LOCAL_SCOPE,      NULL},
-    {"_SB_",    ACPI_TYPE_DEVICE,           NULL},
-    {"_SI_",    ACPI_TYPE_LOCAL_SCOPE,      NULL},
-    {"_TZ_",    ACPI_TYPE_DEVICE,           NULL},
-    /*
-     * March, 2015:
-     * The _REV object is in the process of being deprecated, because
-     * other ACPI implementations permanently return 2. Thus, it
-     * has little or no value. Return 2 for compatibility with
-     * other ACPI implementations.
-     */
-    {"_REV",    ACPI_TYPE_INTEGER,          ACPI_CAST_PTR (char, 2)},
-    {"_OS_",    ACPI_TYPE_STRING,           ACPI_OS_NAME},
-    {"_GL_",    ACPI_TYPE_MUTEX,            ACPI_CAST_PTR (char, 1)},
-
-#if !defined (ACPI_NO_METHOD_EXECUTION) || defined (ACPI_CONSTANT_EVAL_ONLY)
-    {"_OSI",    ACPI_TYPE_METHOD,           ACPI_CAST_PTR (char, 1)},
-#endif
-
-    /* Table terminator */
-
-    {NULL,      ACPI_TYPE_ANY,              NULL}
-};
-
-
-#if (!ACPI_REDUCED_HARDWARE)
-/******************************************************************************
- *
- * Event and Hardware globals
- *
- ******************************************************************************/
-
-ACPI_BIT_REGISTER_INFO      AcpiGbl_BitRegisterInfo[ACPI_NUM_BITREG] =
-{
-    /* Name                                     Parent Register             Register Bit Position                   Register Bit Mask       */
-
-    /* ACPI_BITREG_TIMER_STATUS         */   {ACPI_REGISTER_PM1_STATUS,   ACPI_BITPOSITION_TIMER_STATUS,          ACPI_BITMASK_TIMER_STATUS},
-    /* ACPI_BITREG_BUS_MASTER_STATUS    */   {ACPI_REGISTER_PM1_STATUS,   ACPI_BITPOSITION_BUS_MASTER_STATUS,     ACPI_BITMASK_BUS_MASTER_STATUS},
-    /* ACPI_BITREG_GLOBAL_LOCK_STATUS   */   {ACPI_REGISTER_PM1_STATUS,   ACPI_BITPOSITION_GLOBAL_LOCK_STATUS,    ACPI_BITMASK_GLOBAL_LOCK_STATUS},
-    /* ACPI_BITREG_POWER_BUTTON_STATUS  */   {ACPI_REGISTER_PM1_STATUS,   ACPI_BITPOSITION_POWER_BUTTON_STATUS,   ACPI_BITMASK_POWER_BUTTON_STATUS},
-    /* ACPI_BITREG_SLEEP_BUTTON_STATUS  */   {ACPI_REGISTER_PM1_STATUS,   ACPI_BITPOSITION_SLEEP_BUTTON_STATUS,   ACPI_BITMASK_SLEEP_BUTTON_STATUS},
-    /* ACPI_BITREG_RT_CLOCK_STATUS      */   {ACPI_REGISTER_PM1_STATUS,   ACPI_BITPOSITION_RT_CLOCK_STATUS,       ACPI_BITMASK_RT_CLOCK_STATUS},
-    /* ACPI_BITREG_WAKE_STATUS          */   {ACPI_REGISTER_PM1_STATUS,   ACPI_BITPOSITION_WAKE_STATUS,           ACPI_BITMASK_WAKE_STATUS},
-    /* ACPI_BITREG_PCIEXP_WAKE_STATUS   */   {ACPI_REGISTER_PM1_STATUS,   ACPI_BITPOSITION_PCIEXP_WAKE_STATUS,    ACPI_BITMASK_PCIEXP_WAKE_STATUS},
-
-    /* ACPI_BITREG_TIMER_ENABLE         */   {ACPI_REGISTER_PM1_ENABLE,   ACPI_BITPOSITION_TIMER_ENABLE,          ACPI_BITMASK_TIMER_ENABLE},
-    /* ACPI_BITREG_GLOBAL_LOCK_ENABLE   */   {ACPI_REGISTER_PM1_ENABLE,   ACPI_BITPOSITION_GLOBAL_LOCK_ENABLE,    ACPI_BITMASK_GLOBAL_LOCK_ENABLE},
-    /* ACPI_BITREG_POWER_BUTTON_ENABLE  */   {ACPI_REGISTER_PM1_ENABLE,   ACPI_BITPOSITION_POWER_BUTTON_ENABLE,   ACPI_BITMASK_POWER_BUTTON_ENABLE},
-    /* ACPI_BITREG_SLEEP_BUTTON_ENABLE  */   {ACPI_REGISTER_PM1_ENABLE,   ACPI_BITPOSITION_SLEEP_BUTTON_ENABLE,   ACPI_BITMASK_SLEEP_BUTTON_ENABLE},
-    /* ACPI_BITREG_RT_CLOCK_ENABLE      */   {ACPI_REGISTER_PM1_ENABLE,   ACPI_BITPOSITION_RT_CLOCK_ENABLE,       ACPI_BITMASK_RT_CLOCK_ENABLE},
-    /* ACPI_BITREG_PCIEXP_WAKE_DISABLE  */   {ACPI_REGISTER_PM1_ENABLE,   ACPI_BITPOSITION_PCIEXP_WAKE_DISABLE,   ACPI_BITMASK_PCIEXP_WAKE_DISABLE},
-
-    /* ACPI_BITREG_SCI_ENABLE           */   {ACPI_REGISTER_PM1_CONTROL,  ACPI_BITPOSITION_SCI_ENABLE,            ACPI_BITMASK_SCI_ENABLE},
-    /* ACPI_BITREG_BUS_MASTER_RLD       */   {ACPI_REGISTER_PM1_CONTROL,  ACPI_BITPOSITION_BUS_MASTER_RLD,        ACPI_BITMASK_BUS_MASTER_RLD},
-    /* ACPI_BITREG_GLOBAL_LOCK_RELEASE  */   {ACPI_REGISTER_PM1_CONTROL,  ACPI_BITPOSITION_GLOBAL_LOCK_RELEASE,   ACPI_BITMASK_GLOBAL_LOCK_RELEASE},
-    /* ACPI_BITREG_SLEEP_TYPE           */   {ACPI_REGISTER_PM1_CONTROL,  ACPI_BITPOSITION_SLEEP_TYPE,            ACPI_BITMASK_SLEEP_TYPE},
-    /* ACPI_BITREG_SLEEP_ENABLE         */   {ACPI_REGISTER_PM1_CONTROL,  ACPI_BITPOSITION_SLEEP_ENABLE,          ACPI_BITMASK_SLEEP_ENABLE},
-
-    /* ACPI_BITREG_ARB_DIS              */   {ACPI_REGISTER_PM2_CONTROL,  ACPI_BITPOSITION_ARB_DISABLE,           ACPI_BITMASK_ARB_DISABLE}
-};
-
-
-ACPI_FIXED_EVENT_INFO       AcpiGbl_FixedEventInfo[ACPI_NUM_FIXED_EVENTS] =
-{
-    /* ACPI_EVENT_PMTIMER       */  {ACPI_BITREG_TIMER_STATUS,          ACPI_BITREG_TIMER_ENABLE,        ACPI_BITMASK_TIMER_STATUS,          ACPI_BITMASK_TIMER_ENABLE},
-    /* ACPI_EVENT_GLOBAL        */  {ACPI_BITREG_GLOBAL_LOCK_STATUS,    ACPI_BITREG_GLOBAL_LOCK_ENABLE,  ACPI_BITMASK_GLOBAL_LOCK_STATUS,    ACPI_BITMASK_GLOBAL_LOCK_ENABLE},
-    /* ACPI_EVENT_POWER_BUTTON  */  {ACPI_BITREG_POWER_BUTTON_STATUS,   ACPI_BITREG_POWER_BUTTON_ENABLE, ACPI_BITMASK_POWER_BUTTON_STATUS,   ACPI_BITMASK_POWER_BUTTON_ENABLE},
-    /* ACPI_EVENT_SLEEP_BUTTON  */  {ACPI_BITREG_SLEEP_BUTTON_STATUS,   ACPI_BITREG_SLEEP_BUTTON_ENABLE, ACPI_BITMASK_SLEEP_BUTTON_STATUS,   ACPI_BITMASK_SLEEP_BUTTON_ENABLE},
-    /* ACPI_EVENT_RTC           */  {ACPI_BITREG_RT_CLOCK_STATUS,       ACPI_BITREG_RT_CLOCK_ENABLE,     ACPI_BITMASK_RT_CLOCK_STATUS,       ACPI_BITMASK_RT_CLOCK_ENABLE},
-};
-#endif /* !ACPI_REDUCED_HARDWARE */
-
-
-#if defined (ACPI_DISASSEMBLER) || defined (ACPI_ASL_COMPILER)
-
-/* ToPld macro: compile/disassemble strings */
-
-const char              *AcpiGbl_PldPanelList[] =
-{
-    "TOP",
-    "BOTTOM",
-    "LEFT",
-    "RIGHT",
-    "FRONT",
-    "BACK",
-    "UNKNOWN",
-    NULL
-};
-
-const char              *AcpiGbl_PldVerticalPositionList[] =
-{
-    "UPPER",
-    "CENTER",
-    "LOWER",
-    NULL
-};
-
-const char              *AcpiGbl_PldHorizontalPositionList[] =
-{
-    "LEFT",
-    "CENTER",
-    "RIGHT",
-    NULL
-};
-
-const char              *AcpiGbl_PldShapeList[] =
-{
-    "ROUND",
-    "OVAL",
-    "SQUARE",
-    "VERTICALRECTANGLE",
-    "HORIZONTALRECTANGLE",
-    "VERTICALTRAPEZOID",
-    "HORIZONTALTRAPEZOID",
-    "UNKNOWN",
-    "CHAMFERED",
-    NULL
-};
-#endif
-
-
-/* Public globals */
-
-ACPI_EXPORT_SYMBOL (AcpiGbl_FADT)
-ACPI_EXPORT_SYMBOL (AcpiDbgLevel)
-ACPI_EXPORT_SYMBOL (AcpiDbgLayer)
-ACPI_EXPORT_SYMBOL (AcpiGpeCount)
-ACPI_EXPORT_SYMBOL (AcpiCurrentGpeCount)
diff --git a/usr/src/uts/intel/io/acpica/utilities/utmath.c b/usr/src/uts/intel/io/acpica/utilities/utmath.c
deleted file mode 100644
index aa3d762c0d..0000000000
--- a/usr/src/uts/intel/io/acpica/utilities/utmath.c
+++ /dev/null
@@ -1,375 +0,0 @@
-/*******************************************************************************
- *
- * Module Name: utmath - Integer math support routines
- *
- ******************************************************************************/
-
-/*
- * Copyright (C) 2000 - 2016, Intel Corp.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions, and the following disclaimer,
- *    without modification.
- * 2. Redistributions in binary form must reproduce at minimum a disclaimer
- *    substantially similar to the "NO WARRANTY" disclaimer below
- *    ("Disclaimer") and any redistribution must be conditioned upon
- *    including a substantially similar Disclaimer requirement for further
- *    binary redistribution.
- * 3. Neither the names of the above-listed copyright holders nor the names
- *    of any contributors may be used to endorse or promote products derived
- *    from this software without specific prior written permission.
- *
- * Alternatively, this software may be distributed under the terms of the
- * GNU General Public License ("GPL") version 2 as published by the Free
- * Software Foundation.
- *
- * NO WARRANTY
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
- * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGES.
- */
-
-#include "acpi.h"
-#include "accommon.h"
-
-
-#define _COMPONENT          ACPI_UTILITIES
-        ACPI_MODULE_NAME    ("utmath")
-
-/*
- * Optional support for 64-bit double-precision integer divide. This code
- * is configurable and is implemented in order to support 32-bit kernel
- * environments where a 64-bit double-precision math library is not available.
- *
- * Support for a more normal 64-bit divide/modulo (with check for a divide-
- * by-zero) appears after this optional section of code.
- */
-#ifndef ACPI_USE_NATIVE_DIVIDE
-
-/* Structures used only for 64-bit divide */
-
-typedef struct uint64_struct
-{
-    UINT32                          Lo;
-    UINT32                          Hi;
-
-} UINT64_STRUCT;
-
-typedef union uint64_overlay
-{
-    UINT64                          Full;
-    UINT64_STRUCT                   Part;
-
-} UINT64_OVERLAY;
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiUtShortDivide
- *
- * PARAMETERS:  Dividend            - 64-bit dividend
- *              Divisor             - 32-bit divisor
- *              OutQuotient         - Pointer to where the quotient is returned
- *              OutRemainder        - Pointer to where the remainder is returned
- *
- * RETURN:      Status (Checks for divide-by-zero)
- *
- * DESCRIPTION: Perform a short (maximum 64 bits divided by 32 bits)
- *              divide and modulo. The result is a 64-bit quotient and a
- *              32-bit remainder.
- *
- ******************************************************************************/
-
-ACPI_STATUS
-AcpiUtShortDivide (
-    UINT64                  Dividend,
-    UINT32                  Divisor,
-    UINT64                  *OutQuotient,
-    UINT32                  *OutRemainder)
-{
-    UINT64_OVERLAY          DividendOvl;
-    UINT64_OVERLAY          Quotient;
-    UINT32                  Remainder32;
-
-
-    ACPI_FUNCTION_TRACE (UtShortDivide);
-
-
-    /* Always check for a zero divisor */
-
-    if (Divisor == 0)
-    {
-        ACPI_ERROR ((AE_INFO, "Divide by zero"));
-        return_ACPI_STATUS (AE_AML_DIVIDE_BY_ZERO);
-    }
-
-    DividendOvl.Full = Dividend;
-
-    /*
-     * The quotient is 64 bits, the remainder is always 32 bits,
-     * and is generated by the second divide.
-     */
-    ACPI_DIV_64_BY_32 (0, DividendOvl.Part.Hi, Divisor,
-        Quotient.Part.Hi, Remainder32);
-
-    ACPI_DIV_64_BY_32 (Remainder32, DividendOvl.Part.Lo, Divisor,
-        Quotient.Part.Lo, Remainder32);
-
-    /* Return only what was requested */
-
-    if (OutQuotient)
-    {
-        *OutQuotient = Quotient.Full;
-    }
-    if (OutRemainder)
-    {
-        *OutRemainder = Remainder32;
-    }
-
-    return_ACPI_STATUS (AE_OK);
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiUtDivide
- *
- * PARAMETERS:  InDividend          - Dividend
- *              InDivisor           - Divisor
- *              OutQuotient         - Pointer to where the quotient is returned
- *              OutRemainder        - Pointer to where the remainder is returned
- *
- * RETURN:      Status (Checks for divide-by-zero)
- *
- * DESCRIPTION: Perform a divide and modulo.
- *
- ******************************************************************************/
-
-ACPI_STATUS
-AcpiUtDivide (
-    UINT64                  InDividend,
-    UINT64                  InDivisor,
-    UINT64                  *OutQuotient,
-    UINT64                  *OutRemainder)
-{
-    UINT64_OVERLAY          Dividend;
-    UINT64_OVERLAY          Divisor;
-    UINT64_OVERLAY          Quotient;
-    UINT64_OVERLAY          Remainder;
-    UINT64_OVERLAY          NormalizedDividend;
-    UINT64_OVERLAY          NormalizedDivisor;
-    UINT32                  Partial1;
-    UINT64_OVERLAY          Partial2;
-    UINT64_OVERLAY          Partial3;
-
-
-    ACPI_FUNCTION_TRACE (UtDivide);
-
-
-    /* Always check for a zero divisor */
-
-    if (InDivisor == 0)
-    {
-        ACPI_ERROR ((AE_INFO, "Divide by zero"));
-        return_ACPI_STATUS (AE_AML_DIVIDE_BY_ZERO);
-    }
-
-    Divisor.Full  = InDivisor;
-    Dividend.Full = InDividend;
-    if (Divisor.Part.Hi == 0)
-    {
-        /*
-         * 1) Simplest case is where the divisor is 32 bits, we can
-         * just do two divides
-         */
-        Remainder.Part.Hi = 0;
-
-        /*
-         * The quotient is 64 bits, the remainder is always 32 bits,
-         * and is generated by the second divide.
-         */
-        ACPI_DIV_64_BY_32 (0, Dividend.Part.Hi, Divisor.Part.Lo,
-            Quotient.Part.Hi, Partial1);
-
-        ACPI_DIV_64_BY_32 (Partial1, Dividend.Part.Lo, Divisor.Part.Lo,
-            Quotient.Part.Lo, Remainder.Part.Lo);
-    }
-
-    else
-    {
-        /*
-         * 2) The general case where the divisor is a full 64 bits
-         * is more difficult
-         */
-        Quotient.Part.Hi   = 0;
-        NormalizedDividend = Dividend;
-        NormalizedDivisor  = Divisor;
-
-        /* Normalize the operands (shift until the divisor is < 32 bits) */
-
-        do
-        {
-            ACPI_SHIFT_RIGHT_64 (
-                NormalizedDivisor.Part.Hi, NormalizedDivisor.Part.Lo);
-            ACPI_SHIFT_RIGHT_64 (
-                NormalizedDividend.Part.Hi, NormalizedDividend.Part.Lo);
-
-        } while (NormalizedDivisor.Part.Hi != 0);
-
-        /* Partial divide */
-
-        ACPI_DIV_64_BY_32 (
-            NormalizedDividend.Part.Hi, NormalizedDividend.Part.Lo,
-            NormalizedDivisor.Part.Lo, Quotient.Part.Lo, Partial1);
-
-        /*
-         * The quotient is always 32 bits, and simply requires
-         * adjustment. The 64-bit remainder must be generated.
-         */
-        Partial1 = Quotient.Part.Lo * Divisor.Part.Hi;
-        Partial2.Full = (UINT64) Quotient.Part.Lo * Divisor.Part.Lo;
-        Partial3.Full = (UINT64) Partial2.Part.Hi + Partial1;
-
-        Remainder.Part.Hi = Partial3.Part.Lo;
-        Remainder.Part.Lo = Partial2.Part.Lo;
-
-        if (Partial3.Part.Hi == 0)
-        {
-            if (Partial3.Part.Lo >= Dividend.Part.Hi)
-            {
-                if (Partial3.Part.Lo == Dividend.Part.Hi)
-                {
-                    if (Partial2.Part.Lo > Dividend.Part.Lo)
-                    {
-                        Quotient.Part.Lo--;
-                        Remainder.Full -= Divisor.Full;
-                    }
-                }
-                else
-                {
-                    Quotient.Part.Lo--;
-                    Remainder.Full -= Divisor.Full;
-                }
-            }
-
-            Remainder.Full = Remainder.Full - Dividend.Full;
-            Remainder.Part.Hi = (UINT32) -((INT32) Remainder.Part.Hi);
-            Remainder.Part.Lo = (UINT32) -((INT32) Remainder.Part.Lo);
-
-            if (Remainder.Part.Lo)
-            {
-                Remainder.Part.Hi--;
-            }
-        }
-    }
-
-    /* Return only what was requested */
-
-    if (OutQuotient)
-    {
-        *OutQuotient = Quotient.Full;
-    }
-    if (OutRemainder)
-    {
-        *OutRemainder = Remainder.Full;
-    }
-
-    return_ACPI_STATUS (AE_OK);
-}
-
-#else
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiUtShortDivide, AcpiUtDivide
- *
- * PARAMETERS:  See function headers above
- *
- * DESCRIPTION: Native versions of the UtDivide functions. Use these if either
- *              1) The target is a 64-bit platform and therefore 64-bit
- *                 integer math is supported directly by the machine.
- *              2) The target is a 32-bit or 16-bit platform, and the
- *                 double-precision integer math library is available to
- *                 perform the divide.
- *
- ******************************************************************************/
-
-ACPI_STATUS
-AcpiUtShortDivide (
-    UINT64                  InDividend,
-    UINT32                  Divisor,
-    UINT64                  *OutQuotient,
-    UINT32                  *OutRemainder)
-{
-
-    ACPI_FUNCTION_TRACE (UtShortDivide);
-
-
-    /* Always check for a zero divisor */
-
-    if (Divisor == 0)
-    {
-        ACPI_ERROR ((AE_INFO, "Divide by zero"));
-        return_ACPI_STATUS (AE_AML_DIVIDE_BY_ZERO);
-    }
-
-    /* Return only what was requested */
-
-    if (OutQuotient)
-    {
-        *OutQuotient = InDividend / Divisor;
-    }
-    if (OutRemainder)
-    {
-        *OutRemainder = (UINT32) (InDividend % Divisor);
-    }
-
-    return_ACPI_STATUS (AE_OK);
-}
-
-ACPI_STATUS
-AcpiUtDivide (
-    UINT64                  InDividend,
-    UINT64                  InDivisor,
-    UINT64                  *OutQuotient,
-    UINT64                  *OutRemainder)
-{
-    ACPI_FUNCTION_TRACE (UtDivide);
-
-
-    /* Always check for a zero divisor */
-
-    if (InDivisor == 0)
-    {
-        ACPI_ERROR ((AE_INFO, "Divide by zero"));
-        return_ACPI_STATUS (AE_AML_DIVIDE_BY_ZERO);
-    }
-
-
-    /* Return only what was requested */
-
-    if (OutQuotient)
-    {
-        *OutQuotient = InDividend / InDivisor;
-    }
-    if (OutRemainder)
-    {
-        *OutRemainder = InDividend % InDivisor;
-    }
-
-    return_ACPI_STATUS (AE_OK);
-}
-
-#endif
diff --git a/usr/src/uts/intel/io/acpica/utilities/utnonansi.c b/usr/src/uts/intel/io/acpica/utilities/utnonansi.c
deleted file mode 100644
index 70fb33e64c..0000000000
--- a/usr/src/uts/intel/io/acpica/utilities/utnonansi.c
+++ /dev/null
@@ -1,667 +0,0 @@
-/*******************************************************************************
- *
- * Module Name: utnonansi - Non-ansi C library functions
- *
- ******************************************************************************/
-
-/*
- * Copyright (C) 2000 - 2016, Intel Corp.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions, and the following disclaimer,
- *    without modification.
- * 2. Redistributions in binary form must reproduce at minimum a disclaimer
- *    substantially similar to the "NO WARRANTY" disclaimer below
- *    ("Disclaimer") and any redistribution must be conditioned upon
- *    including a substantially similar Disclaimer requirement for further
- *    binary redistribution.
- * 3. Neither the names of the above-listed copyright holders nor the names
- *    of any contributors may be used to endorse or promote products derived
- *    from this software without specific prior written permission.
- *
- * Alternatively, this software may be distributed under the terms of the
- * GNU General Public License ("GPL") version 2 as published by the Free
- * Software Foundation.
- *
- * NO WARRANTY
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
- * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGES.
- */
-
-#include "acpi.h"
-#include "accommon.h"
-
-
-#define _COMPONENT          ACPI_UTILITIES
-        ACPI_MODULE_NAME    ("utnonansi")
-
-
-/*
- * Non-ANSI C library functions - strlwr, strupr, stricmp, and a 64-bit
- * version of strtoul.
- */
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiUtStrlwr (strlwr)
- *
- * PARAMETERS:  SrcString       - The source string to convert
- *
- * RETURN:      None
- *
- * DESCRIPTION: Convert a string to lowercase
- *
- ******************************************************************************/
-
-void
-AcpiUtStrlwr (
-    char                    *SrcString)
-{
-    char                    *String;
-
-
-    ACPI_FUNCTION_ENTRY ();
-
-
-    if (!SrcString)
-    {
-        return;
-    }
-
-    /* Walk entire string, lowercasing the letters */
-
-    for (String = SrcString; *String; String++)
-    {
-        *String = (char) tolower ((int) *String);
-    }
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiUtStrupr (strupr)
- *
- * PARAMETERS:  SrcString       - The source string to convert
- *
- * RETURN:      None
- *
- * DESCRIPTION: Convert a string to uppercase
- *
- ******************************************************************************/
-
-void
-AcpiUtStrupr (
-    char                    *SrcString)
-{
-    char                    *String;
-
-
-    ACPI_FUNCTION_ENTRY ();
-
-
-    if (!SrcString)
-    {
-        return;
-    }
-
-    /* Walk entire string, uppercasing the letters */
-
-    for (String = SrcString; *String; String++)
-    {
-        *String = (char) toupper ((int) *String);
-    }
-}
-
-
-/******************************************************************************
- *
- * FUNCTION:    AcpiUtStricmp (stricmp)
- *
- * PARAMETERS:  String1             - first string to compare
- *              String2             - second string to compare
- *
- * RETURN:      int that signifies string relationship. Zero means strings
- *              are equal.
- *
- * DESCRIPTION: Case-insensitive string compare. Implementation of the
- *              non-ANSI stricmp function.
- *
- ******************************************************************************/
-
-int
-AcpiUtStricmp (
-    char                    *String1,
-    char                    *String2)
-{
-    int                     c1;
-    int                     c2;
-
-
-    do
-    {
-        c1 = tolower ((int) *String1);
-        c2 = tolower ((int) *String2);
-
-        String1++;
-        String2++;
-    }
-    while ((c1 == c2) && (c1));
-
-    return (c1 - c2);
-}
-
-
-#if defined (ACPI_DEBUGGER) || defined (ACPI_APPLICATION)
-/*******************************************************************************
- *
- * FUNCTION:    AcpiUtSafeStrcpy, AcpiUtSafeStrcat, AcpiUtSafeStrncat
- *
- * PARAMETERS:  Adds a "DestSize" parameter to each of the standard string
- *              functions. This is the size of the Destination buffer.
- *
- * RETURN:      TRUE if the operation would overflow the destination buffer.
- *
- * DESCRIPTION: Safe versions of standard Clib string functions. Ensure that
- *              the result of the operation will not overflow the output string
- *              buffer.
- *
- * NOTE:        These functions are typically only helpful for processing
- *              user input and command lines. For most ACPICA code, the
- *              required buffer length is precisely calculated before buffer
- *              allocation, so the use of these functions is unnecessary.
- *
- ******************************************************************************/
-
-BOOLEAN
-AcpiUtSafeStrcpy (
-    char                    *Dest,
-    ACPI_SIZE               DestSize,
-    char                    *Source)
-{
-
-    if (strlen (Source) >= DestSize)
-    {
-        return (TRUE);
-    }
-
-    strcpy (Dest, Source);
-    return (FALSE);
-}
-
-BOOLEAN
-AcpiUtSafeStrcat (
-    char                    *Dest,
-    ACPI_SIZE               DestSize,
-    char                    *Source)
-{
-
-    if ((strlen (Dest) + strlen (Source)) >= DestSize)
-    {
-        return (TRUE);
-    }
-
-    strcat (Dest, Source);
-    return (FALSE);
-}
-
-BOOLEAN
-AcpiUtSafeStrncat (
-    char                    *Dest,
-    ACPI_SIZE               DestSize,
-    char                    *Source,
-    ACPI_SIZE               MaxTransferLength)
-{
-    ACPI_SIZE               ActualTransferLength;
-
-
-    ActualTransferLength = ACPI_MIN (MaxTransferLength, strlen (Source));
-
-    if ((strlen (Dest) + ActualTransferLength) >= DestSize)
-    {
-        return (TRUE);
-    }
-
-    strncat (Dest, Source, MaxTransferLength);
-    return (FALSE);
-}
-#endif
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiUtStrtoul64
- *
- * PARAMETERS:  String                  - Null terminated string
- *              Base                    - Radix of the string: 16 or 10 or
- *                                        ACPI_ANY_BASE
- *              MaxIntegerByteWidth     - Maximum allowable integer,in bytes:
- *                                        4 or 8 (32 or 64 bits)
- *              RetInteger              - Where the converted integer is
- *                                        returned
- *
- * RETURN:      Status and Converted value
- *
- * DESCRIPTION: Convert a string into an unsigned value. Performs either a
- *              32-bit or 64-bit conversion, depending on the input integer
- *              size (often the current mode of the interpreter).
- *
- * NOTES:       Negative numbers are not supported, as they are not supported
- *              by ACPI.
- *
- *              AcpiGbl_IntegerByteWidth should be set to the proper width.
- *              For the core ACPICA code, this width depends on the DSDT
- *              version. For iASL, the default byte width is always 8 for the
- *              parser, but error checking is performed later to flag cases
- *              where a 64-bit constant is defined in a 32-bit DSDT/SSDT.
- *
- *              Does not support Octal strings, not needed at this time.
- *
- ******************************************************************************/
-
-ACPI_STATUS
-AcpiUtStrtoul64 (
-    char                    *String,
-    UINT32                  Base,
-    UINT32                  MaxIntegerByteWidth,
-    UINT64                  *RetInteger)
-{
-    UINT32                  ThisDigit = 0;
-    UINT64                  ReturnValue = 0;
-    UINT64                  Quotient;
-    UINT64                  Dividend;
-    UINT8                   ValidDigits = 0;
-    UINT8                   SignOf0x = 0;
-    UINT8                   Term = 0;
-
-
-    ACPI_FUNCTION_TRACE_STR (UtStrtoul64, String);
-
-
-    switch (Base)
-    {
-    case ACPI_ANY_BASE:
-    case 10:
-    case 16:
-
-        break;
-
-    default:
-
-        /* Invalid Base */
-
-        return_ACPI_STATUS (AE_BAD_PARAMETER);
-    }
-
-    if (!String)
-    {
-        goto ErrorExit;
-    }
-
-    /* Skip over any white space in the buffer */
-
-    while ((*String) && (isspace ((int) *String) || *String == '\t'))
-    {
-        String++;
-    }
-
-    if (Base == ACPI_ANY_BASE)
-    {
-        /*
-         * Base equal to ACPI_ANY_BASE means 'Either decimal or hex'.
-         * We need to determine if it is decimal or hexadecimal.
-         */
-        if ((*String == '0') && (tolower ((int) *(String + 1)) == 'x'))
-        {
-            SignOf0x = 1;
-            Base = 16;
-
-            /* Skip over the leading '0x' */
-            String += 2;
-        }
-        else
-        {
-            Base = 10;
-        }
-    }
-
-    /* Any string left? Check that '0x' is not followed by white space. */
-
-    if (!(*String) || isspace ((int) *String) || *String == '\t')
-    {
-        if (Base == ACPI_ANY_BASE)
-        {
-            goto ErrorExit;
-        }
-        else
-        {
-            goto AllDone;
-        }
-    }
-
-    /*
-     * Perform a 32-bit or 64-bit conversion, depending upon the input
-     * byte width
-     */
-    Dividend = (MaxIntegerByteWidth <= ACPI_MAX32_BYTE_WIDTH) ?
-        ACPI_UINT32_MAX : ACPI_UINT64_MAX;
-
-    /* Main loop: convert the string to a 32- or 64-bit integer */
-
-    while (*String)
-    {
-        if (isdigit ((int) *String))
-        {
-            /* Convert ASCII 0-9 to Decimal value */
-
-            ThisDigit = ((UINT8) *String) - '0';
-        }
-        else if (Base == 10)
-        {
-            /* Digit is out of range; possible in ToInteger case only */
-
-            Term = 1;
-        }
-        else
-        {
-            ThisDigit = (UINT8) toupper ((int) *String);
-            if (isxdigit ((int) ThisDigit))
-            {
-                /* Convert ASCII Hex char to value */
-
-                ThisDigit = ThisDigit - 'A' + 10;
-            }
-            else
-            {
-                Term = 1;
-            }
-        }
-
-        if (Term)
-        {
-            if (Base == ACPI_ANY_BASE)
-            {
-                goto ErrorExit;
-            }
-            else
-            {
-                break;
-            }
-        }
-        else if ((ValidDigits == 0) && (ThisDigit == 0) && !SignOf0x)
-        {
-            /* Skip zeros */
-            String++;
-            continue;
-        }
-
-        ValidDigits++;
-
-        if (SignOf0x && ((ValidDigits > 16) ||
-            ((ValidDigits > 8) && (MaxIntegerByteWidth <= ACPI_MAX32_BYTE_WIDTH))))
-        {
-            /*
-             * This is ToInteger operation case.
-             * No restrictions for string-to-integer conversion,
-             * see ACPI spec.
-             */
-            goto ErrorExit;
-        }
-
-        /* Divide the digit into the correct position */
-
-        (void) AcpiUtShortDivide (
-            (Dividend - (UINT64) ThisDigit), Base, &Quotient, NULL);
-
-        if (ReturnValue > Quotient)
-        {
-            if (Base == ACPI_ANY_BASE)
-            {
-                goto ErrorExit;
-            }
-            else
-            {
-                break;
-            }
-        }
-
-        ReturnValue *= Base;
-        ReturnValue += ThisDigit;
-        String++;
-    }
-
-    /* All done, normal exit */
-
-AllDone:
-
-    ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "Converted value: %8.8X%8.8X\n",
-        ACPI_FORMAT_UINT64 (ReturnValue)));
-
-    *RetInteger = ReturnValue;
-    return_ACPI_STATUS (AE_OK);
-
-
-ErrorExit:
-
-    /* Base was set/validated above (10 or 16) */
-
-    if (Base == 10)
-    {
-        return_ACPI_STATUS (AE_BAD_DECIMAL_CONSTANT);
-    }
-    else
-    {
-        return_ACPI_STATUS (AE_BAD_HEX_CONSTANT);
-    }
-}
-
-
-#ifdef _OBSOLETE_FUNCTIONS
-/* Removed: 01/2016 */
-
-/*******************************************************************************
- *
- * FUNCTION:    strtoul64
- *
- * PARAMETERS:  String              - Null terminated string
- *              Terminater          - Where a pointer to the terminating byte
- *                                    is returned
- *              Base                - Radix of the string
- *
- * RETURN:      Converted value
- *
- * DESCRIPTION: Convert a string into an unsigned value.
- *
- ******************************************************************************/
-
-ACPI_STATUS
-strtoul64 (
-    char                    *String,
-    UINT32                  Base,
-    UINT64                  *RetInteger)
-{
-    UINT32                  Index;
-    UINT32                  Sign;
-    UINT64                  ReturnValue = 0;
-    ACPI_STATUS             Status = AE_OK;
-
-
-    *RetInteger = 0;
-
-    switch (Base)
-    {
-    case 0:
-    case 8:
-    case 10:
-    case 16:
-
-        break;
-
-    default:
-        /*
-         * The specified Base parameter is not in the domain of
-         * this function:
-         */
-        return (AE_BAD_PARAMETER);
-    }
-
-    /* Skip over any white space in the buffer: */
-
-    while (isspace ((int) *String) || *String == '\t')
-    {
-        ++String;
-    }
-
-    /*
-     * The buffer may contain an optional plus or minus sign.
-     * If it does, then skip over it but remember what is was:
-     */
-    if (*String == '-')
-    {
-        Sign = ACPI_SIGN_NEGATIVE;
-        ++String;
-    }
-    else if (*String == '+')
-    {
-        ++String;
-        Sign = ACPI_SIGN_POSITIVE;
-    }
-    else
-    {
-        Sign = ACPI_SIGN_POSITIVE;
-    }
-
-    /*
-     * If the input parameter Base is zero, then we need to
-     * determine if it is octal, decimal, or hexadecimal:
-     */
-    if (Base == 0)
-    {
-        if (*String == '0')
-        {
-            if (tolower ((int) *(++String)) == 'x')
-            {
-                Base = 16;
-                ++String;
-            }
-            else
-            {
-                Base = 8;
-            }
-        }
-        else
-        {
-            Base = 10;
-        }
-    }
-
-    /*
-     * For octal and hexadecimal bases, skip over the leading
-     * 0 or 0x, if they are present.
-     */
-    if (Base == 8 && *String == '0')
-    {
-        String++;
-    }
-
-    if (Base == 16 &&
-        *String == '0' &&
-        tolower ((int) *(++String)) == 'x')
-    {
-        String++;
-    }
-
-    /* Main loop: convert the string to an unsigned long */
-
-    while (*String)
-    {
-        if (isdigit ((int) *String))
-        {
-            Index = ((UINT8) *String) - '0';
-        }
-        else
-        {
-            Index = (UINT8) toupper ((int) *String);
-            if (isupper ((int) Index))
-            {
-                Index = Index - 'A' + 10;
-            }
-            else
-            {
-                goto ErrorExit;
-            }
-        }
-
-        if (Index >= Base)
-        {
-            goto ErrorExit;
-        }
-
-        /* Check to see if value is out of range: */
-
-        if (ReturnValue > ((ACPI_UINT64_MAX - (UINT64) Index) /
-            (UINT64) Base))
-        {
-            goto ErrorExit;
-        }
-        else
-        {
-            ReturnValue *= Base;
-            ReturnValue += Index;
-        }
-
-        ++String;
-    }
-
-
-    /* If a minus sign was present, then "the conversion is negated": */
-
-    if (Sign == ACPI_SIGN_NEGATIVE)
-    {
-        ReturnValue = (ACPI_UINT32_MAX - ReturnValue) + 1;
-    }
-
-    *RetInteger = ReturnValue;
-    return (Status);
-
-
-ErrorExit:
-    switch (Base)
-    {
-    case 8:
-
-        Status = AE_BAD_OCTAL_CONSTANT;
-        break;
-
-    case 10:
-
-        Status = AE_BAD_DECIMAL_CONSTANT;
-        break;
-
-    case 16:
-
-        Status = AE_BAD_HEX_CONSTANT;
-        break;
-
-    default:
-
-        /* Base validated above */
-
-        break;
-    }
-
-    return (Status);
-}
-#endif
diff --git a/usr/src/uts/intel/io/acpica/utilities/utprint.c b/usr/src/uts/intel/io/acpica/utilities/utprint.c
deleted file mode 100644
index e01f1734a9..0000000000
--- a/usr/src/uts/intel/io/acpica/utilities/utprint.c
+++ /dev/null
@@ -1,812 +0,0 @@
-/******************************************************************************
- *
- * Module Name: utprint - Formatted printing routines
- *
- *****************************************************************************/
-
-/*
- * Copyright (C) 2000 - 2016, Intel Corp.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions, and the following disclaimer,
- *    without modification.
- * 2. Redistributions in binary form must reproduce at minimum a disclaimer
- *    substantially similar to the "NO WARRANTY" disclaimer below
- *    ("Disclaimer") and any redistribution must be conditioned upon
- *    including a substantially similar Disclaimer requirement for further
- *    binary redistribution.
- * 3. Neither the names of the above-listed copyright holders nor the names
- *    of any contributors may be used to endorse or promote products derived
- *    from this software without specific prior written permission.
- *
- * Alternatively, this software may be distributed under the terms of the
- * GNU General Public License ("GPL") version 2 as published by the Free
- * Software Foundation.
- *
- * NO WARRANTY
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
- * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGES.
- */
-
-#include "acpi.h"
-#include "accommon.h"
-
-#define _COMPONENT          ACPI_UTILITIES
-        ACPI_MODULE_NAME    ("utprint")
-
-
-#define ACPI_FORMAT_SIGN            0x01
-#define ACPI_FORMAT_SIGN_PLUS       0x02
-#define ACPI_FORMAT_SIGN_PLUS_SPACE 0x04
-#define ACPI_FORMAT_ZERO            0x08
-#define ACPI_FORMAT_LEFT            0x10
-#define ACPI_FORMAT_UPPER           0x20
-#define ACPI_FORMAT_PREFIX          0x40
-
-
-/* Local prototypes */
-
-static ACPI_SIZE
-AcpiUtBoundStringLength (
-    const char              *String,
-    ACPI_SIZE               Count);
-
-static char *
-AcpiUtBoundStringOutput (
-    char                    *String,
-    const char              *End,
-    char                    c);
-
-static char *
-AcpiUtFormatNumber (
-    char                    *String,
-    char                    *End,
-    UINT64                  Number,
-    UINT8                   Base,
-    INT32                   Width,
-    INT32                   Precision,
-    UINT8                   Type);
-
-static char *
-AcpiUtPutNumber (
-    char                    *String,
-    UINT64                  Number,
-    UINT8                   Base,
-    BOOLEAN                 Upper);
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiUtBoundStringLength
- *
- * PARAMETERS:  String              - String with boundary
- *              Count               - Boundary of the string
- *
- * RETURN:      Length of the string. Less than or equal to Count.
- *
- * DESCRIPTION: Calculate the length of a string with boundary.
- *
- ******************************************************************************/
-
-static ACPI_SIZE
-AcpiUtBoundStringLength (
-    const char              *String,
-    ACPI_SIZE               Count)
-{
-    UINT32                  Length = 0;
-
-
-    while (*String && Count)
-    {
-        Length++;
-        String++;
-        Count--;
-    }
-
-    return (Length);
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiUtBoundStringOutput
- *
- * PARAMETERS:  String              - String with boundary
- *              End                 - Boundary of the string
- *              c                   - Character to be output to the string
- *
- * RETURN:      Updated position for next valid character
- *
- * DESCRIPTION: Output a character into a string with boundary check.
- *
- ******************************************************************************/
-
-static char *
-AcpiUtBoundStringOutput (
-    char                    *String,
-    const char              *End,
-    char                    c)
-{
-
-    if (String < End)
-    {
-        *String = c;
-    }
-
-    ++String;
-    return (String);
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiUtPutNumber
- *
- * PARAMETERS:  String              - Buffer to hold reverse-ordered string
- *              Number              - Integer to be converted
- *              Base                - Base of the integer
- *              Upper               - Whether or not using upper cased digits
- *
- * RETURN:      Updated position for next valid character
- *
- * DESCRIPTION: Convert an integer into a string, note that, the string holds a
- *              reversed ordered number without the trailing zero.
- *
- ******************************************************************************/
-
-static char *
-AcpiUtPutNumber (
-    char                    *String,
-    UINT64                  Number,
-    UINT8                   Base,
-    BOOLEAN                 Upper)
-{
-    const char              *Digits;
-    UINT64                  DigitIndex;
-    char                    *Pos;
-
-
-    Pos = String;
-    Digits = Upper ? AcpiGbl_UpperHexDigits : AcpiGbl_LowerHexDigits;
-
-    if (Number == 0)
-    {
-        *(Pos++) = '0';
-    }
-    else
-    {
-        while (Number)
-        {
-            (void) AcpiUtDivide (Number, Base, &Number, &DigitIndex);
-            *(Pos++) = Digits[DigitIndex];
-        }
-    }
-
-    /* *(Pos++) = '0'; */
-    return (Pos);
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiUtScanNumber
- *
- * PARAMETERS:  String              - String buffer
- *              NumberPtr           - Where the number is returned
- *
- * RETURN:      Updated position for next valid character
- *
- * DESCRIPTION: Scan a string for a decimal integer.
- *
- ******************************************************************************/
-
-const char *
-AcpiUtScanNumber (
-    const char              *String,
-    UINT64                  *NumberPtr)
-{
-    UINT64                  Number = 0;
-
-
-    while (isdigit ((int) *String))
-    {
-        Number *= 10;
-        Number += *(String++) - '0';
-    }
-
-    *NumberPtr = Number;
-    return (String);
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiUtPrintNumber
- *
- * PARAMETERS:  String              - String buffer
- *              Number              - The number to be converted
- *
- * RETURN:      Updated position for next valid character
- *
- * DESCRIPTION: Print a decimal integer into a string.
- *
- ******************************************************************************/
-
-const char *
-AcpiUtPrintNumber (
-    char                    *String,
-    UINT64                  Number)
-{
-    char                    AsciiString[20];
-    const char              *Pos1;
-    char                    *Pos2;
-
-
-    Pos1 = AcpiUtPutNumber (AsciiString, Number, 10, FALSE);
-    Pos2 = String;
-
-    while (Pos1 != AsciiString)
-    {
-        *(Pos2++) = *(--Pos1);
-    }
-
-    *Pos2 = 0;
-    return (String);
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiUtFormatNumber
- *
- * PARAMETERS:  String              - String buffer with boundary
- *              End                 - Boundary of the string
- *              Number              - The number to be converted
- *              Base                - Base of the integer
- *              Width               - Field width
- *              Precision           - Precision of the integer
- *              Type                - Special printing flags
- *
- * RETURN:      Updated position for next valid character
- *
- * DESCRIPTION: Print an integer into a string with any base and any precision.
- *
- ******************************************************************************/
-
-static char *
-AcpiUtFormatNumber (
-    char                    *String,
-    char                    *End,
-    UINT64                  Number,
-    UINT8                   Base,
-    INT32                   Width,
-    INT32                   Precision,
-    UINT8                   Type)
-{
-    char                    *Pos;
-    char                    Sign;
-    char                    Zero;
-    BOOLEAN                 NeedPrefix;
-    BOOLEAN                 Upper;
-    INT32                   i;
-    char                    ReversedString[66];
-
-
-    /* Parameter validation */
-
-    if (Base < 2 || Base > 16)
-    {
-        return (NULL);
-    }
-
-    if (Type & ACPI_FORMAT_LEFT)
-    {
-        Type &= ~ACPI_FORMAT_ZERO;
-    }
-
-    NeedPrefix = ((Type & ACPI_FORMAT_PREFIX) && Base != 10) ? TRUE : FALSE;
-    Upper = (Type & ACPI_FORMAT_UPPER) ? TRUE : FALSE;
-    Zero = (Type & ACPI_FORMAT_ZERO) ? '0' : ' ';
-
-    /* Calculate size according to sign and prefix */
-
-    Sign = '\0';
-    if (Type & ACPI_FORMAT_SIGN)
-    {
-        if ((INT64) Number < 0)
-        {
-            Sign = '-';
-            Number = - (INT64) Number;
-            Width--;
-        }
-        else if (Type & ACPI_FORMAT_SIGN_PLUS)
-        {
-            Sign = '+';
-            Width--;
-        }
-        else if (Type & ACPI_FORMAT_SIGN_PLUS_SPACE)
-        {
-            Sign = ' ';
-            Width--;
-        }
-    }
-    if (NeedPrefix)
-    {
-        Width--;
-        if (Base == 16)
-        {
-            Width--;
-        }
-    }
-
-    /* Generate full string in reverse order */
-
-    Pos = AcpiUtPutNumber (ReversedString, Number, Base, Upper);
-    i = ACPI_PTR_DIFF (Pos, ReversedString);
-
-    /* Printing 100 using %2d gives "100", not "00" */
-
-    if (i > Precision)
-    {
-        Precision = i;
-    }
-
-    Width -= Precision;
-
-    /* Output the string */
-
-    if (!(Type & (ACPI_FORMAT_ZERO | ACPI_FORMAT_LEFT)))
-    {
-        while (--Width >= 0)
-        {
-            String = AcpiUtBoundStringOutput (String, End, ' ');
-        }
-    }
-    if (Sign)
-    {
-        String = AcpiUtBoundStringOutput (String, End, Sign);
-    }
-    if (NeedPrefix)
-    {
-        String = AcpiUtBoundStringOutput (String, End, '0');
-        if (Base == 16)
-        {
-            String = AcpiUtBoundStringOutput (
-                String, End, Upper ? 'X' : 'x');
-        }
-    }
-    if (!(Type & ACPI_FORMAT_LEFT))
-    {
-        while (--Width >= 0)
-        {
-            String = AcpiUtBoundStringOutput (String, End, Zero);
-        }
-    }
-
-    while (i <= --Precision)
-    {
-        String = AcpiUtBoundStringOutput (String, End, '0');
-    }
-    while (--i >= 0)
-    {
-        String = AcpiUtBoundStringOutput (String, End,
-                    ReversedString[i]);
-    }
-    while (--Width >= 0)
-    {
-        String = AcpiUtBoundStringOutput (String, End, ' ');
-    }
-
-    return (String);
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiUtVsnprintf
- *
- * PARAMETERS:  String              - String with boundary
- *              Size                - Boundary of the string
- *              Format              - Standard printf format
- *              Args                - Argument list
- *
- * RETURN:      Number of bytes actually written.
- *
- * DESCRIPTION: Formatted output to a string using argument list pointer.
- *
- ******************************************************************************/
-
-int
-AcpiUtVsnprintf (
-    char                    *String,
-    ACPI_SIZE               Size,
-    const char              *Format,
-    va_list                 Args)
-{
-    UINT8                   Base;
-    UINT8                   Type;
-    INT32                   Width;
-    INT32                   Precision;
-    char                    Qualifier;
-    UINT64                  Number;
-    char                    *Pos;
-    char                    *End;
-    char                    c;
-    const char              *s;
-    const void              *p;
-    INT32                   Length;
-    int                     i;
-
-
-    Pos = String;
-    End = String + Size;
-
-    for (; *Format; ++Format)
-    {
-        if (*Format != '%')
-        {
-            Pos = AcpiUtBoundStringOutput (Pos, End, *Format);
-            continue;
-        }
-
-        Type = 0;
-        Base = 10;
-
-        /* Process sign */
-
-        do
-        {
-            ++Format;
-            if (*Format == '#')
-            {
-                Type |= ACPI_FORMAT_PREFIX;
-            }
-            else if (*Format == '0')
-            {
-                Type |= ACPI_FORMAT_ZERO;
-            }
-            else if (*Format == '+')
-            {
-                Type |= ACPI_FORMAT_SIGN_PLUS;
-            }
-            else if (*Format == ' ')
-            {
-                Type |= ACPI_FORMAT_SIGN_PLUS_SPACE;
-            }
-            else if (*Format == '-')
-            {
-                Type |= ACPI_FORMAT_LEFT;
-            }
-            else
-            {
-                break;
-            }
-
-        } while (1);
-
-        /* Process width */
-
-        Width = -1;
-        if (isdigit ((int) *Format))
-        {
-            Format = AcpiUtScanNumber (Format, &Number);
-            Width = (INT32) Number;
-        }
-        else if (*Format == '*')
-        {
-            ++Format;
-            Width = va_arg (Args, int);
-            if (Width < 0)
-            {
-                Width = -Width;
-                Type |= ACPI_FORMAT_LEFT;
-            }
-        }
-
-        /* Process precision */
-
-        Precision = -1;
-        if (*Format == '.')
-        {
-            ++Format;
-            if (isdigit ((int) *Format))
-            {
-                Format = AcpiUtScanNumber (Format, &Number);
-                Precision = (INT32) Number;
-            }
-            else if (*Format == '*')
-            {
-                ++Format;
-                Precision = va_arg (Args, int);
-            }
-
-            if (Precision < 0)
-            {
-                Precision = 0;
-            }
-        }
-
-        /* Process qualifier */
-
-        Qualifier = -1;
-        if (*Format == 'h' || *Format == 'l' || *Format == 'L')
-        {
-            Qualifier = *Format;
-            ++Format;
-
-            if (Qualifier == 'l' && *Format == 'l')
-            {
-                Qualifier = 'L';
-                ++Format;
-            }
-        }
-
-        switch (*Format)
-        {
-        case '%':
-
-            Pos = AcpiUtBoundStringOutput (Pos, End, '%');
-            continue;
-
-        case 'c':
-
-            if (!(Type & ACPI_FORMAT_LEFT))
-            {
-                while (--Width > 0)
-                {
-                    Pos = AcpiUtBoundStringOutput (Pos, End, ' ');
-                }
-            }
-
-            c = (char) va_arg (Args, int);
-            Pos = AcpiUtBoundStringOutput (Pos, End, c);
-
-            while (--Width > 0)
-            {
-                Pos = AcpiUtBoundStringOutput (Pos, End, ' ');
-            }
-            continue;
-
-        case 's':
-
-            s = va_arg (Args, char *);
-            if (!s)
-            {
-                s = "<NULL>";
-            }
-            Length = AcpiUtBoundStringLength (s, Precision);
-            if (!(Type & ACPI_FORMAT_LEFT))
-            {
-                while (Length < Width--)
-                {
-                    Pos = AcpiUtBoundStringOutput (Pos, End, ' ');
-                }
-            }
-
-            for (i = 0; i < Length; ++i)
-            {
-                Pos = AcpiUtBoundStringOutput (Pos, End, *s);
-                ++s;
-            }
-
-            while (Length < Width--)
-            {
-                Pos = AcpiUtBoundStringOutput (Pos, End, ' ');
-            }
-            continue;
-
-        case 'o':
-
-            Base = 8;
-            break;
-
-        case 'X':
-
-            Type |= ACPI_FORMAT_UPPER;
-
-        case 'x':
-
-            Base = 16;
-            break;
-
-        case 'd':
-        case 'i':
-
-            Type |= ACPI_FORMAT_SIGN;
-
-        case 'u':
-
-            break;
-
-        case 'p':
-
-            if (Width == -1)
-            {
-                Width = 2 * sizeof (void *);
-                Type |= ACPI_FORMAT_ZERO;
-            }
-
-            p = va_arg (Args, void *);
-            Pos = AcpiUtFormatNumber (
-                Pos, End, ACPI_TO_INTEGER (p), 16, Width, Precision, Type);
-            continue;
-
-        default:
-
-            Pos = AcpiUtBoundStringOutput (Pos, End, '%');
-            if (*Format)
-            {
-                Pos = AcpiUtBoundStringOutput (Pos, End, *Format);
-            }
-            else
-            {
-                --Format;
-            }
-            continue;
-        }
-
-        if (Qualifier == 'L')
-        {
-            Number = va_arg (Args, UINT64);
-            if (Type & ACPI_FORMAT_SIGN)
-            {
-                Number = (INT64) Number;
-            }
-        }
-        else if (Qualifier == 'l')
-        {
-            Number = va_arg (Args, unsigned long);
-            if (Type & ACPI_FORMAT_SIGN)
-            {
-                Number = (INT32) Number;
-            }
-        }
-        else if (Qualifier == 'h')
-        {
-            Number = (UINT16) va_arg (Args, int);
-            if (Type & ACPI_FORMAT_SIGN)
-            {
-                Number = (INT16) Number;
-            }
-        }
-        else
-        {
-            Number = va_arg (Args, unsigned int);
-            if (Type & ACPI_FORMAT_SIGN)
-            {
-                Number = (signed int) Number;
-            }
-        }
-
-        Pos = AcpiUtFormatNumber (Pos, End, Number, Base,
-            Width, Precision, Type);
-    }
-
-    if (Size > 0)
-    {
-        if (Pos < End)
-        {
-            *Pos = '\0';
-        }
-        else
-        {
-            End[-1] = '\0';
-        }
-    }
-
-    return (ACPI_PTR_DIFF (Pos, String));
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiUtSnprintf
- *
- * PARAMETERS:  String              - String with boundary
- *              Size                - Boundary of the string
- *              Format, ...         - Standard printf format
- *
- * RETURN:      Number of bytes actually written.
- *
- * DESCRIPTION: Formatted output to a string.
- *
- ******************************************************************************/
-
-int
-AcpiUtSnprintf (
-    char                    *String,
-    ACPI_SIZE               Size,
-    const char              *Format,
-    ...)
-{
-    va_list                 Args;
-    int                     Length;
-
-
-    va_start (Args, Format);
-    Length = AcpiUtVsnprintf (String, Size, Format, Args);
-    va_end (Args);
-
-    return (Length);
-}
-
-
-#ifdef ACPI_APPLICATION
-/*******************************************************************************
- *
- * FUNCTION:    AcpiUtFileVprintf
- *
- * PARAMETERS:  File                - File descriptor
- *              Format              - Standard printf format
- *              Args                - Argument list
- *
- * RETURN:      Number of bytes actually written.
- *
- * DESCRIPTION: Formatted output to a file using argument list pointer.
- *
- ******************************************************************************/
-
-int
-AcpiUtFileVprintf (
-    ACPI_FILE               File,
-    const char              *Format,
-    va_list                 Args)
-{
-    ACPI_CPU_FLAGS          Flags;
-    int                     Length;
-
-
-    Flags = AcpiOsAcquireLock (AcpiGbl_PrintLock);
-    Length = AcpiUtVsnprintf (AcpiGbl_PrintBuffer,
-        sizeof (AcpiGbl_PrintBuffer), Format, Args);
-
-    (void) AcpiOsWriteFile (File, AcpiGbl_PrintBuffer, Length, 1);
-    AcpiOsReleaseLock (AcpiGbl_PrintLock, Flags);
-
-    return (Length);
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiUtFilePrintf
- *
- * PARAMETERS:  File                - File descriptor
- *              Format, ...         - Standard printf format
- *
- * RETURN:      Number of bytes actually written.
- *
- * DESCRIPTION: Formatted output to a file.
- *
- ******************************************************************************/
-
-int
-AcpiUtFilePrintf (
-    ACPI_FILE               File,
-    const char              *Format,
-    ...)
-{
-    va_list                 Args;
-    int                     Length;
-
-
-    va_start (Args, Format);
-    Length = AcpiUtFileVprintf (File, Format, Args);
-    va_end (Args);
-
-    return (Length);
-}
-#endif
diff --git a/usr/src/uts/intel/io/acpica/utilities/utxferror.c b/usr/src/uts/intel/io/acpica/utilities/utxferror.c
deleted file mode 100644
index e79ffc94f3..0000000000
--- a/usr/src/uts/intel/io/acpica/utilities/utxferror.c
+++ /dev/null
@@ -1,305 +0,0 @@
-/*******************************************************************************
- *
- * Module Name: utxferror - Various error/warning output functions
- *
- ******************************************************************************/
-
-/*
- * Copyright (C) 2000 - 2016, Intel Corp.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions, and the following disclaimer,
- *    without modification.
- * 2. Redistributions in binary form must reproduce at minimum a disclaimer
- *    substantially similar to the "NO WARRANTY" disclaimer below
- *    ("Disclaimer") and any redistribution must be conditioned upon
- *    including a substantially similar Disclaimer requirement for further
- *    binary redistribution.
- * 3. Neither the names of the above-listed copyright holders nor the names
- *    of any contributors may be used to endorse or promote products derived
- *    from this software without specific prior written permission.
- *
- * Alternatively, this software may be distributed under the terms of the
- * GNU General Public License ("GPL") version 2 as published by the Free
- * Software Foundation.
- *
- * NO WARRANTY
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
- * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGES.
- */
-
-#define EXPORT_ACPI_INTERFACES
-
-#include "acpi.h"
-#include "accommon.h"
-
-
-#define _COMPONENT          ACPI_UTILITIES
-        ACPI_MODULE_NAME    ("utxferror")
-
-/*
- * This module is used for the in-kernel ACPICA as well as the ACPICA
- * tools/applications.
- */
-
-#ifndef ACPI_NO_ERROR_MESSAGES /* Entire module */
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiError
- *
- * PARAMETERS:  ModuleName          - Caller's module name (for error output)
- *              LineNumber          - Caller's line number (for error output)
- *              Format              - Printf format string + additional args
- *
- * RETURN:      None
- *
- * DESCRIPTION: Print "ACPI Error" message with module/line/version info
- *
- ******************************************************************************/
-
-void ACPI_INTERNAL_VAR_XFACE
-AcpiError (
-    const char              *ModuleName,
-    UINT32                  LineNumber,
-    const char              *Format,
-    ...)
-{
-    va_list                 ArgList;
-
-
-    ACPI_MSG_REDIRECT_BEGIN;
-    AcpiOsPrintf (ACPI_MSG_ERROR);
-
-    va_start (ArgList, Format);
-    AcpiOsVprintf (Format, ArgList);
-    ACPI_MSG_SUFFIX;
-    va_end (ArgList);
-
-    ACPI_MSG_REDIRECT_END;
-}
-
-ACPI_EXPORT_SYMBOL (AcpiError)
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiException
- *
- * PARAMETERS:  ModuleName          - Caller's module name (for error output)
- *              LineNumber          - Caller's line number (for error output)
- *              Status              - Status to be formatted
- *              Format              - Printf format string + additional args
- *
- * RETURN:      None
- *
- * DESCRIPTION: Print "ACPI Exception" message with module/line/version info
- *              and decoded ACPI_STATUS.
- *
- ******************************************************************************/
-
-void ACPI_INTERNAL_VAR_XFACE
-AcpiException (
-    const char              *ModuleName,
-    UINT32                  LineNumber,
-    ACPI_STATUS             Status,
-    const char              *Format,
-    ...)
-{
-    va_list                 ArgList;
-
-
-    ACPI_MSG_REDIRECT_BEGIN;
-
-    /* For AE_OK, just print the message */
-
-    if (ACPI_SUCCESS (Status))
-    {
-        AcpiOsPrintf (ACPI_MSG_EXCEPTION);
-
-    }
-    else
-    {
-        AcpiOsPrintf (ACPI_MSG_EXCEPTION "%s, ",
-            AcpiFormatException (Status));
-    }
-
-    va_start (ArgList, Format);
-    AcpiOsVprintf (Format, ArgList);
-    ACPI_MSG_SUFFIX;
-    va_end (ArgList);
-
-    ACPI_MSG_REDIRECT_END;
-}
-
-ACPI_EXPORT_SYMBOL (AcpiException)
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiWarning
- *
- * PARAMETERS:  ModuleName          - Caller's module name (for error output)
- *              LineNumber          - Caller's line number (for error output)
- *              Format              - Printf format string + additional args
- *
- * RETURN:      None
- *
- * DESCRIPTION: Print "ACPI Warning" message with module/line/version info
- *
- ******************************************************************************/
-
-void ACPI_INTERNAL_VAR_XFACE
-AcpiWarning (
-    const char              *ModuleName,
-    UINT32                  LineNumber,
-    const char              *Format,
-    ...)
-{
-    va_list                 ArgList;
-
-
-    ACPI_MSG_REDIRECT_BEGIN;
-    AcpiOsPrintf (ACPI_MSG_WARNING);
-
-    va_start (ArgList, Format);
-    AcpiOsVprintf (Format, ArgList);
-    ACPI_MSG_SUFFIX;
-    va_end (ArgList);
-
-    ACPI_MSG_REDIRECT_END;
-}
-
-ACPI_EXPORT_SYMBOL (AcpiWarning)
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiInfo
- *
- * PARAMETERS:  ModuleName          - Caller's module name (for error output)
- *              LineNumber          - Caller's line number (for error output)
- *              Format              - Printf format string + additional args
- *
- * RETURN:      None
- *
- * DESCRIPTION: Print generic "ACPI:" information message. There is no
- *              module/line/version info in order to keep the message simple.
- *
- * TBD: ModuleName and LineNumber args are not needed, should be removed.
- *
- ******************************************************************************/
-
-void ACPI_INTERNAL_VAR_XFACE
-AcpiInfo (
-    const char              *Format,
-    ...)
-{
-    va_list                 ArgList;
-
-
-    ACPI_MSG_REDIRECT_BEGIN;
-    AcpiOsPrintf (ACPI_MSG_INFO);
-
-    va_start (ArgList, Format);
-    AcpiOsVprintf (Format, ArgList);
-    AcpiOsPrintf ("\n");
-    va_end (ArgList);
-
-    ACPI_MSG_REDIRECT_END;
-}
-
-ACPI_EXPORT_SYMBOL (AcpiInfo)
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiBiosError
- *
- * PARAMETERS:  ModuleName          - Caller's module name (for error output)
- *              LineNumber          - Caller's line number (for error output)
- *              Format              - Printf format string + additional args
- *
- * RETURN:      None
- *
- * DESCRIPTION: Print "ACPI Firmware Error" message with module/line/version
- *              info
- *
- ******************************************************************************/
-
-void ACPI_INTERNAL_VAR_XFACE
-AcpiBiosError (
-    const char              *ModuleName,
-    UINT32                  LineNumber,
-    const char              *Format,
-    ...)
-{
-    va_list                 ArgList;
-
-
-    ACPI_MSG_REDIRECT_BEGIN;
-    AcpiOsPrintf (ACPI_MSG_BIOS_ERROR);
-
-    va_start (ArgList, Format);
-    AcpiOsVprintf (Format, ArgList);
-    ACPI_MSG_SUFFIX;
-    va_end (ArgList);
-
-    ACPI_MSG_REDIRECT_END;
-}
-
-ACPI_EXPORT_SYMBOL (AcpiBiosError)
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiBiosWarning
- *
- * PARAMETERS:  ModuleName          - Caller's module name (for error output)
- *              LineNumber          - Caller's line number (for error output)
- *              Format              - Printf format string + additional args
- *
- * RETURN:      None
- *
- * DESCRIPTION: Print "ACPI Firmware Warning" message with module/line/version
- *              info
- *
- ******************************************************************************/
-
-void ACPI_INTERNAL_VAR_XFACE
-AcpiBiosWarning (
-    const char              *ModuleName,
-    UINT32                  LineNumber,
-    const char              *Format,
-    ...)
-{
-    va_list                 ArgList;
-
-
-    ACPI_MSG_REDIRECT_BEGIN;
-    AcpiOsPrintf (ACPI_MSG_BIOS_WARNING);
-
-    va_start (ArgList, Format);
-    AcpiOsVprintf (Format, ArgList);
-    ACPI_MSG_SUFFIX;
-    va_end (ArgList);
-
-    ACPI_MSG_REDIRECT_END;
-}
-
-ACPI_EXPORT_SYMBOL (AcpiBiosWarning)
-
-#endif /* ACPI_NO_ERROR_MESSAGES */
diff --git a/usr/src/uts/intel/sys/acpi/Readme.resync b/usr/src/uts/intel/sys/acpi/Readme.resync
new file mode 100644
index 0000000000..a36a7b51f8
--- /dev/null
+++ b/usr/src/uts/intel/sys/acpi/Readme.resync
@@ -0,0 +1,52 @@
+This file and its contents are supplied under the terms of the
+Common Development and Distribution License ("CDDL"), version 1.0.
+You may only use this file in accordance with the terms of version
+1.0 of the CDDL.
+
+A full copy of the text of the CDDL should have accompanied this
+source.  A copy of the CDDL is also available via the Internet at
+http://www.illumos.org/license/CDDL.
+
+Copyright (c) 2018, Joyent, Inc.
+
+---
+
+Without this patch, debug builds are unhappy about unused functions.
+
+  cc1: warnings being treated as errors
+  ../../intel/sys/acpi/acpixf.h:1203: error: 'AcpiDebugPrint' defined but not used [-Wunused-function]
+  ../../intel/sys/acpi/acpixf.h:1215: error: 'AcpiDebugPrintRaw' defined but not used [-Wunused-function]
+  ../../intel/sys/acpi/acpixf.h:1227: error: 'AcpiTracePoint' defined but not used [-Wunused-function]
+  ../../intel/sys/acpi/acpixf.h:1235: error: 'AcpiLogError' defined but not used [-Wunused-function]
+  *** Error code 1
+  make: Warning: Command failed for target `debug64/psm_common.o'
+  Current working directory
+  .../usr/src/uts/i86pc/apix
+
+
+diff --git b/usr/src/uts/intel/sys/acpi/acpixf.h a/usr/src/uts/intel/sys/acpi/acpixf.h
+index aafac14..81e550a 100644
+--- b/usr/src/uts/intel/sys/acpi/acpixf.h
++++ a/usr/src/uts/intel/sys/acpi/acpixf.h
+@@ -363,9 +361,7 @@ ACPI_GLOBAL (BOOLEAN,               AcpiGbl_SystemAwakeAndRunning);
+     Prototype;
+ 
+ #else
+-#define ACPI_DBG_DEPENDENT_RETURN_VOID(Prototype) \
+-    static ACPI_INLINE Prototype {return;}
+-
++#define ACPI_DBG_DEPENDENT_RETURN_VOID(Prototype)
+ #endif /* ACPI_DEBUG_OUTPUT */
+ 
+ 
+@@ -381,9 +377,7 @@ ACPI_GLOBAL (BOOLEAN,               AcpiGbl_SystemAwakeAndRunning);
+     Prototype;
+ 
+ #else
+-#define ACPI_APP_DEPENDENT_RETURN_VOID(Prototype) \
+-    static ACPI_INLINE Prototype {return;}
+-
++#define ACPI_APP_DEPENDENT_RETURN_VOID(Prototype)
+ #endif /* ACPI_APPLICATION */
+ 
+ 
diff --git a/usr/src/uts/intel/sys/acpi/acpixf.h b/usr/src/uts/intel/sys/acpi/acpixf.h
index 81e550aedb..e3382c655f 100644
--- a/usr/src/uts/intel/sys/acpi/acpixf.h
+++ b/usr/src/uts/intel/sys/acpi/acpixf.h
@@ -349,6 +349,7 @@ ACPI_GLOBAL (BOOLEAN,               AcpiGbl_SystemAwakeAndRunning);
 
 #endif /* ACPI_NO_ERROR_MESSAGES */
 
+
 /*
  * Debugging output prototypes (default: no debug output).
  *
@@ -404,11 +405,6 @@ ACPI_GLOBAL (BOOLEAN,               AcpiGbl_SystemAwakeAndRunning);
 
 #endif /* ACPI_DEBUGGER */
 
-/*****************************************************************************
- *
- * ACPICA public interface prototypes
- *
- ****************************************************************************/
 
 /*****************************************************************************
  *
diff --git a/usr/src/uts/intel/sys/acpi/platform/acsolaris.h b/usr/src/uts/intel/sys/acpi/platform/acsolaris.h
index 207ef4723d..3931916d77 100644
--- a/usr/src/uts/intel/sys/acpi/platform/acsolaris.h
+++ b/usr/src/uts/intel/sys/acpi/platform/acsolaris.h
@@ -74,7 +74,9 @@ uint32_t acpi_strtoul(const char *, char **, int);
 #define	ACPI_USE_NATIVE_DIVIDE
 #define	ACPI_FLUSH_CPU_CACHE()	(__acpi_wbinvd())
 
+#ifndef ACPI_DISASSEMBLER
 #define	ACPI_DISASSEMBLER
+#endif
 #define	ACPI_PACKED_POINTERS_NOT_SUPPORTED
 
 /*
