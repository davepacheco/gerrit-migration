commit fd8530bf1b54ff982a17cd0e8f38ee0f91d43bb1
Author: Rob Johnston <rob.johnston@joyent.com>
Date:   2019-01-29T15:59:40+00:00 (8 months ago)
    
    OS-7422 iPXE should be provided directly from joyent/ipxe
    TRITON-1016 Need to build and deliver the ipxe EFI binary
    OS-XXXX newboot

diff --git a/.gitignore b/.gitignore
index 77068525..69ae1ac6 100644
--- a/.gitignore
+++ b/.gitignore
@@ -15,7 +15,7 @@
 /log
 *.swp
 /tmp
-/.DS_Store
+.DS_Store
 /hvm/platform*
 /hvm/agents*
 /recipe.*
diff --git a/Makefile b/Makefile
index 0636ec5e..43fcb932 100644
--- a/Makefile
+++ b/Makefile
@@ -17,8 +17,10 @@ PERCENT := %
 
 ifeq ($(shell uname -s),SunOS)
 GREP = /usr/xpg4/bin/grep
+TAR = gtar
 else
 GREP = grep
+TAR = tar
 endif
 
 BASH_FILES := \
@@ -121,13 +123,9 @@ TOOLS_LIB_FILES = \
 	usbkey.js \
 	wrap.sh
 
-TOOLS_BOOT_FILES = \
-	boot/default.ipxe \
-	boot/ipxe.lkrn
-
 TOOLS_SHARE_FILES = \
 	servicebundle/pubkey.key \
-	$(TOOLS_BOOT_FILES:%=usbkey/%)
+	usbkey
 
 TOOLS_RONN_FILES = \
 	man1/sdc-amonrelay.1.ronn \
@@ -188,7 +186,7 @@ CN_TOOLS_FILES = \
 	lib/oscmds.js \
 	lib/usbkey.js \
 	man/man1/sdc-sbcreate.1 \
-	$(TOOLS_BOOT_FILES:%=share/usbkey/%) \
+	share/usbkey \
 	node_modules \
 	etc
 
@@ -363,20 +361,29 @@ $(PROTO)/opt/smartdc/etc/gz-tools.image:
 	echo $(TOOLS_UUID) > $@
 	chmod 644 $@
 
+USBKEY_SCRIPTS = \
+	scripts/update-usbkey.0.esp.sh \
+	scripts/update-usbkey.5.copy-contents.js
+
+USBKEY_TARBALLS = \
+	cache/file.ipxe.tgz \
+	cache/file.platboot.tgz
+
+$(USBKEY_TARBALLS): download
+
 #
-# We deliver some specific boot files in the compute node tools tarball so that
-# partial updates to USB keys may be delivered by incremental updates to SDC.
-# These files come from the same copy of the sdcboot artefact used to build the
-# rest of sdc-headnode.
+# The usbkey sub-directory, included in the tarballs, represents new contents
+# that should be updated on USB keys, in particular any updates of loader or
+# iPXE.
 #
-$(PROTO)/opt/smartdc/share/usbkey/%: cache/file.sdcboot.tgz
-	mkdir -p $(@D)
-	rm -f $@
-	(FILE="$(PWD)/$<"; cd $(PROTO)/opt/smartdc/share/usbkey && \
-	    tar xvfz $${FILE} ./$*)
-	test -f $@ && touch $@
-
-cache/file.sdcboot.tgz: download
+$(PROTO)/opt/smartdc/share/usbkey: $(USBKEY_SCRIPTS) $(USBKEY_TARBALLS)
+	mkdir -p $@/contents
+	cp -f $(USBKEY_SCRIPTS) $@/
+	for tar in $(USBKEY_TARBALLS); do \
+		$(TAR) -C $@/contents -xvf $$tar || exit 1; \
+	done
+	cp -fr boot $@/contents
+	touch $@
 
 $(SDC_ZONE_BIN_LINKS):
 	mkdir -p $(@D)
diff --git a/README.md b/README.md
index c34b9291..8e26c4b0 100644
--- a/README.md
+++ b/README.md
@@ -22,8 +22,8 @@ To create a VM for local development work – commonly called 'coal' (Cloud On
             ./tools/coal-mac-vmware-setup
 
   - Optionally, to automate setup:
-    - create a `build.spec.local` file with the following contents: `{"answer-file": "answers.json"}`
-    - copy one of the answers.json templates: `cp answers.json.tmpl.external answers.json`
+
+    - `echo '{"answer-file": "answers.json.tmpl.external"}' >build.spec.local`
 
     - see the [Build Specification][buildspec] and
       [Automating Headnode Setup][autosetup] sections below for more information.
@@ -32,10 +32,15 @@ To create a VM for local development work – commonly called 'coal' (Cloud On
     images of all services. This can take quite some time. If this fails,
     please see the 'Build Prerequisites' and/or 'Debugging' sections below.
 
-  - open `coal-master-TIMESTAMP-gSHA.vmwarevm`, select 'Live 64-bit' at the
-    grub menu, and work through the interactive installer referring to [this
-    documentation][coal-setup.md]. **Important**: while many answers are arbitrary, the
-    networking questions require specific values for local development.
+  - `open coal-master-TIMESTAMP-gSHA.vmwarevm`, let the boot time out, then work
+    through the interactive installer if you didn't provide an answer file,
+    referring to [this documentation][coal-setup.md]. **Important**: while many
+    answers are arbitrary, the networking questions require specific values
+    for local development.
+
+  - note that the console defaults to `ttyb` a.k.a. `socket.serial1`. You can
+    use something like [sercons][https://github.com/jclulow/vmware-sercons] to
+    connect to this.
 
   - when setup completes, you can access the headnode via ssh: `ssh
     root@10.99.99.7` using the root password specified during setup.
@@ -81,35 +86,36 @@ of all build configuration, and is versioned in the repository.
 During development, or as part of release engineering, particular elements of
 the build specification may be overridden in another file: `build.spec.local`.
 By re-specifying a subset of build configuration in this file, the behaviour of
-a particular build run may be altered.  A useful example of `build.spec.local`
-for local development is:
+a particular build run may be altered.  For example:
 
 ```
 {
-    "answer-file": "answers.json",
+    "answer-file": "answers.json.tmpl.external",
     "build-tgz": "false",
     "coal-memsize": 8192,
     "vmware_version": 7,
-    "default-boot-option": 1,
-    "clean-cache": true
+    "clean-cache": true,
+    "ipxe": false,
+    "console": "ttya"
 }
 ```
 
 In the example above,
 
   - `"answer-file"` is used to specify a setup answers file for inclusion in
-    resultant installation media
+    resultant installation media; `answers.json.tmpl.external` is suitable for
+    a standard COAL setup
   - `"build-tgz"` is used to disable the creation of a compressed tarball with
     the build results; instead, the resultant build artefacts will be left in
-    output directories.
+    output directories. This can be very useful when rsync'ing a COAL build
   - `"coal-memsize"` is used to set the VMware guest memory size to 8192MB
     (recommended if you plan to install a [Manta][manta] test environment.)
   - `"vmware_version"` specifies the version of VMware Fusion to target.
     See <https://kb.vmware.com/s/article/1003746> for mapping of Virtual
     Hardware Version to VMware releases. Note that `vmware_version=7`,
     corresponding to hardware version 11, is required for Bhyve VMs to work.
-  - `"default-boot-option"` selects the default grub boot option; a value of
-    `1` selects the second entry in the menu: regular headnode boot
+  - COAL defaults to USB boot; `"ipxe"` modifies this default
+  - COAL defaults to serial console, using `ttyb`. Use `text` for VGA console
 
 #### Build Artefacts
 
@@ -459,7 +465,7 @@ The failure may have occurred in one of the zones being installed, rather than i
 Development in this repo is typically to alter setup and bootstrap of the system. Setup scripts reside on a USB key typically mounted at `/mnt/usbkey`, and are copied onto the headnode at `/usbkey`.
 
 To test changes to setup procedures without a complete rebuild, you can:
-  - mount the usbkey (if required) using `/usbkey/scripts/mount-usb.sh`
+  - mount the usbkey (if required) using `sdc-usbkey mount`
   - copy your modifications over the existing scripts
   - run `sdc-factoryreset` to re-run the setup process
 
diff --git a/bin/build-coal-image b/bin/build-coal-image
index 94e54eb3..303a423a 100755
--- a/bin/build-coal-image
+++ b/bin/build-coal-image
@@ -6,7 +6,7 @@
 #
 
 #
-# Copyright 2017 Joyent, Inc.
+# Copyright (c) 2019, Joyent, Inc.
 #
 
 ROOT=$(cd $(dirname $0)/../; pwd)
@@ -44,14 +44,6 @@ while getopts 'cr' name; do
 done
 shift $((OPTIND - 1))
 
-function rel2abs () {
-    local abs_path end
-    abs_path=$(unset CDPATH; cd `dirname $1` 2>/dev/null && pwd -P)
-    [[ -z "$abs_path" ]] && return 1
-    end=$(basename $1)
-    echo "${abs_path%*/}/$end"
-}
-
 if [[ -z "$1" ]]; then
     usage 'must provide <usb_tarball> filename'
 fi
@@ -92,69 +84,42 @@ function build_spec () {
 };
 
 BUILD_TGZ=$(build_spec build-tgz)
-
-# Tools.
-
-MNT_DIR=/mnt/tmp
 USB_SIZE="4gb"
 USB_SKIP=7812500
 USB_PADDING=508
+PARTMAP="${USB_SIZE}.partition.map"
 OUTPUT_IMG="${USB_SIZE}.img"
-if [[ -z $IMG_TMP_DIR ]]; then
-  IMG_TMP_DIR=/tmp
-fi
-PLATFORM=$(uname -s)
-
-if [[ "$PLATFORM" == "SunOS" ]]; then
-    SUCMD='pfexec'
-elif [[ "$PLATFORM" == "Linux" ]]; then
-    SUCMD='sudo'
-    # Parted is required to find the partition offset in the image.
-    [[ $(which parted) ]] || fatal "Please install 'parted'"
-fi
+IMG_TMP_DIR=/tmp/tmp.$$
+MNT_DIR=$IMG_TMP_DIR/mnt
 
 STAGE=${ROOT}/cache/stage_coal
+
 mkdir -p $STAGE
 rm -rf $STAGE/*
 
 echo ">> Starting build at $(date)"
 
-function fatal
-{
-    echo "$(basename $0): fatal error: $*"
-    exit 1
-}
-
-function errexit
-{
-    [[ $1 -ne 0 ]] || exit 0
-    fatal "error exit status $1 at line $2"
-}
-
-trap 'errexit $? $LINENO' EXIT
-
-
 function unpack_image
 {
     echo -n "==> Unpacking USB image... "
-    mkdir -p $IMG_TMP_DIR/coal.$$
+    mkdir -p $IMG_TMP_DIR
     if [[ $TAR_BUILD_IS_DIRECTORY == 1 ]]; then
         if [[ $REUSE_USB_BUILD == 1 ]]; then
-            rm -rf $IMG_TMP_DIR/coal.$$
-            mv $TAR_BUILD_FILENAME $IMG_TMP_DIR/coal.$$
+            rm -rf $IMG_TMP_DIR
+            mv $TAR_BUILD_FILENAME $IMG_TMP_DIR/
         else
             (cd $TAR_BUILD_FILENAME \
-                && tar -c . | tar -C $IMG_TMP_DIR/coal.$$ -xovf - )
+                && tar -c . | tar -C $IMG_TMP_DIR/ -xovf - )
         fi
-
-        (cd $IMG_TMP_DIR/coal.$$ \
-            && mv usb-*${OUTPUT_IMG} $$.${OUTPUT_IMG}) \
-            || fatal "Unable to unpack USB image"
     else
-        (cd $IMG_TMP_DIR/coal.$$ && ${TAR} -xzf $TAR_BUILD_FILENAME \
-            && mv usb-*${OUTPUT_IMG} $$.${OUTPUT_IMG}) \
-            || fatal "Unable to unpack USB image"
+        (cd $IMG_TMP_DIR/ && ${TAR} -xzf $TAR_BUILD_FILENAME) || \
+            fatal "Unable to unpack USB image"
     fi
+
+    (cd $IMG_TMP_DIR && mv usb-*${OUTPUT_IMG} ${OUTPUT_IMG} && \
+        mv usb-*${PARTMAP} ${PARTMAP}) || \
+        fatal "Unable to unpack USB image"
+
     echo "done."
 }
 
@@ -164,45 +129,17 @@ function expand_image
 {
     echo -n "==> Expanding USB image for VMWare... "
 
-    if [[ -f $IMG_TMP_DIR/coal.$$/$$.${OUTPUT_IMG} && \
+    if [[ -f $IMG_TMP_DIR/${OUTPUT_IMG} && \
           -n ${USB_SKIP} && -n ${USB_PADDING} ]]; then
         echo ""
-        local file=$IMG_TMP_DIR/coal.$$/$$.${OUTPUT_IMG}
-        dd if=/dev/zero of=${file} conv=notrunc seek=${USB_SKIP} \
+        local file=$IMG_TMP_DIR/${OUTPUT_IMG}
+        ${SUCMD} dd if=/dev/zero of=${file} conv=notrunc seek=${USB_SKIP} \
            bs=512 count=${USB_PADDING}
     else
         echo "skipped."
     fi
 }
 
-function mount_image
-{
-    echo -n "==> Mounting new USB image... "
-    if [[ "$PLATFORM" == "Darwin" ]]; then
-        [ ! -d ${ROOT}/cache/tmp_volumes ] && mkdir -p ${ROOT}/cache/tmp_volumes
-        hdiutil attach $IMG_TMP_DIR/coal.$$/$$.${OUTPUT_IMG} \
-            >/tmp/output.hdiattach.$$ \
-            -mountrandom ${ROOT}/cache/tmp_volumes 2>&1
-        LOOPBACK=`grep "FDisk_partition_scheme" /tmp/output.hdiattach.$$ \
-            | awk '{ print $1 }'`
-        MNT_DIR=`grep "Windows_FAT_32" /tmp/output.hdiattach.$$ \
-            | awk '{ print $3 }'`
-    elif [[ "$PLATFORM" == "Linux" ]]; then
-        MNT_DIR="/tmp/sdc_image.$$"
-        mkdir -p "$MNT_DIR"
-        LOOPBACK="$IMG_TMP_DIR/coal.$$/$$.${OUTPUT_IMG}"
-        OFFSET=$(parted -m "${LOOPBACK}" unit B print | grep fat32 \
-            | cut -f2 -d: | sed 's/.$//')
-        ${SUCMD} mount -o "loop,offset=${OFFSET},uid=${EUID},gid=${GROUPS[0]}" \
-            "${LOOPBACK}" "${MNT_DIR}"
-    else
-        ${SUCMD} mkdir -p ${MNT_DIR}
-        LOOPBACK=$(${SUCMD} lofiadm -a $IMG_TMP_DIR/coal.$$/$$.${OUTPUT_IMG})
-        ${SUCMD} mount -F pcfs -o foldcase ${LOOPBACK}:c ${MNT_DIR}
-    fi
-    echo "($IMG_TMP_DIR/coal.$$/$$.${OUTPUT_IMG} mounted on ${MNT_DIR}) done."
-}
-
 function copy_config {
 
     # Clear current configs from stage area
@@ -212,6 +149,22 @@ function copy_config {
     cp -r config/config.inc ${MNT_DIR}/config.inc
 }
 
+#
+# COAL should default to booting from the USB key, not iPXE.
+#
+function modify_loader {
+    local ipxe=
+
+    ipxe=$(build_spec ipxe)
+
+    if [ -z "$ipxe" ]; then
+        ipxe="false"
+    fi
+
+    sed -i'.tmp' "s+^ipxe=.*+ipxe=\"$ipxe\"+" $MNT_DIR/boot/loader.conf
+    rm $MNT_DIR/boot/loader.conf.tmp
+}
+
 # Copy to mount is basically just extracting everything to the image mount
 function copy_to_mount
 {
@@ -233,31 +186,6 @@ function copy_to_mount
     cp -r $ROOT/devtools $MNT_DIR/devtools
 }
 
-CLEANED=0
-function cleanup
-{
-    if [ ${CLEANED} -eq 0 ]; then
-        echo '==> Cleaning up'
-        CLEANED=1
-        if [[ -n ${LOOPBACK} ]]; then
-            if [[ "$PLATFORM" == "Darwin" ]]; then
-                hdiutil detach ${MNT_DIR} || true
-            elif [[ "$PLATFORM" == "Linux" ]]; then
-                ${SUCMD} umount "${MNT_DIR}" || /usr/bin/true
-                rm -rf "${MNT_DIR}"
-            else
-                ${SUCMD} umount ${MNT_DIR} || /usr/bin/true
-                ${SUCMD} lofiadm -d ${LOOPBACK}
-            fi
-            sync; sync
-            LOOPBACK=
-        fi
-
-    fi
-    rm -rf $IMG_TMP_DIR/fs.*.$$
-    rm -rf $IMG_TMP_DIR/output.*.$$
-}
-
 function create_output
 {
     local vmxfile="${STAGE}/USB-headnode.vmwarevm/USB-headnode.vmx"
@@ -338,7 +266,7 @@ function create_output
     fi
 
     echo -n "==> Copying in ${OUTPUT_IMG}... "
-    mv $IMG_TMP_DIR/coal.$$/$$.${OUTPUT_IMG} "$vmdk_img"
+    mv $IMG_TMP_DIR/${OUTPUT_IMG} "$vmdk_img"
     echo "done."
 
     echo -n "==> Generating VMDK file for ${OUTPUT_IMG}... "
@@ -370,7 +298,7 @@ function create_output
             coal-${THIS_BUILDSTAMP}-${USB_SIZE}.vmwarevm)
         mv $STAGE $ROOT/coal-${THIS_BUILDSTAMP}-${USB_SIZE}
     else
-        echo "==> Creating coal-${THIS_BUILDSTAMP}.tgz"
+        echo "==> Creating coal-${THIS_BUILDSTAMP}-${USB_SIZE}.tgz"
         (cd $STAGE \
             && mv USB-headnode.vmwarevm \
             coal-${THIS_BUILDSTAMP}-${USB_SIZE}.vmwarevm \
@@ -380,16 +308,33 @@ function create_output
         [[ $? -eq 0 ]] || fatal "Unable to create .tgz image."
     fi
 
-    rm -rf $IMG_TMP_DIR/coal.$$
     #XXX
     #rm -rf $STAGE || true
 }
 
+function cleanup
+{
+    echo '==> Cleaning up'
+
+    unmount_loopback
+
+    ${SUCMD} rm -f $IMG_TMP_DIR/${OUTPUT_IMG}
+    ${SUCMD} rm -f $IMG_TMP_DIR/$PARTMAP
+    ${SUCMD} rm -f ${IMG_TMP_DIR}/rootfs.img
+    ${SUCMD} rm -f ${IMG_TMP_DIR}/root.password.${LIVEIMG_VERSION}
+    ${SUCMD} rm -rf $IMG_TMP_DIR/*.manifest
+    ${SUCMD} rm -rf $IMG_TMP_DIR/fs.*
+    ${SUCMD} rm -rf $IMG_TMP_DIR/output.*
+    ${SUCMD} rmdir $MNT_DIR
+    ${SUCMD} rmdir $IMG_TMP_DIR
+}
+
 unpack_image
 expand_image
-mount_image
 trap 'cleanup' EXIT
+mount_root_image
 copy_to_mount
 copy_config
-cleanup
+modify_loader
+unmount_root_image
 create_output
diff --git a/bin/build-tar-image b/bin/build-tar-image
index 245fba70..490f92e7 100755
--- a/bin/build-tar-image
+++ b/bin/build-tar-image
@@ -6,7 +6,7 @@
 #
 
 #
-# Copyright (c) 2017, Joyent, Inc.
+# Copyright (c) 2018, Joyent, Inc.
 #
 
 if [[ -n "$TRACE" ]]; then
@@ -170,104 +170,69 @@ function create_directories
     mkdir -p ${STAGE}
 }
 
-function generate_grub_menu
+#
+# The console configuration is a little bit complicated below.  We want loader
+# to appear on everything available, but prefer any explicitly specified
+# console, defaulting to ttyb.
+#
+# But we also need to pass through "os_console" for the kernel, so we can see
+# kernel output on the console requested.
+#
+function generate_loader_config
 {
-    local unit=
     local serial_dev
-    serial_dev=$(build_spec serial-dev)
+    local enable_dr
     local console
-    console=$(build_spec console)
-    local default_boot_option
-    default_boot_option=$(build_spec default-boot-option)
+    # XXX - add code to handle ENABLE_DR
+    local DR_VAL='#DR'
+    local ipxe
 
+    echo "==> Generating boot loader configuration "
+
+    serial_dev=$(build_spec serial-dev)
+    os_console=$(build_spec console)
+    ipxe=$(build_spec ipxe)
     # Feature flag for HEAD-2093
-    local enable_dr
     enable_dr=$(build_spec enable-disaster-recovery)
-    local DR_VAL='#DR '
-    [[ ${enable_dr} == "true" ]] && DR_VAL=''
-
-    echo "==> Generating grub menu"
 
-    [[ -z "${serial_dev}" ]] && serial_dev=ttyb
-    [[ -z "${console}" ]] && console="serial"
-    [[ -z "${default_boot_option}" ]] && default_boot_option=0
+    [[ ${enable_dr} == "true" ]] && DR_VAL=''
+    [[ -z "$ipxe" ]] && ipxe="true"
+    [[ -z "${serial_dev}" ]] && serial_dev="ttyb"
+    [[ -z "${os_console}" ]] && os_console="${serial_dev}"
 
-    #
-    # This section describes the serial-dev and console parameters.  These
-    # values may be overridden in build.spec{,.local}.
-    #
-    # serial-dev is the serial console device on the target system.  It
-    # defaults to ttyb (illumos) aka COM2 (FreeDOS), which is legacy I/O
-    # port 2f8 interrupt 3.
-    #
-    # console is used to set the default value of the GRUB variable
-    # "os_console", which selects the post-boot console device.  It may
-    # be one of "serial", in which case the serial device specified by
-    # serial-dev is used, or "text" in which case an attached keyboard
-    # and VGA device is used.  For backward compatibility, "graphics"
-    # and "vga" are aliases for "text".  In addition, an explicit serial
-    # device may be specified, in which case its value will override
-    # serial-dev.  This is almost certainly not what you want, since it
-    # will mean that post-boot I/O will be to/from a different device
-    # than was used during boot.  Note that the operator can change the
-    # post-boot console by modifying the os_console GRUB variable before
-    # booting.
-    #
-    # When the system boots, GRUB will display its output to the VGA
-    # device, if one is present, and the device specified by serial-dev,
-    # if it exists.  It will also accept input from either an attached
-    # keyboard or serial-dev.  Once a boot selection is made, the value
-    # of the os_console GRUB variable is passed to the operating system
-    # and used as the system console, unless a network boot is
-    # performed.  In that case, the parameters received from the HN will
-    # override all console selection made here or in the GRUB
-    # environment; this may be modified for each CN using CNAPI.
-    #
-    # By default, serial-dev is "ttyb" and console is "serial".  We try
-    # other devices in turn if the preferred one does not exist.  Only
-    # one device will actually be used; see the GRUB help for details.
-    #
     case "${serial_dev}" in
-    ttya)
-        unit=0,1,2,3
-        ;;
-    ttyb)
-        unit=1,0,2,3
-        ;;
-    ttyc)
-        unit=2,1,0,3
-        ;;
-    ttyd)
-        unit=3,1,0,2
-        ;;
-    *)
-        fatal "Unknown serial device: ${serial_dev}"
-        ;;
+    ttya) lconsole="ttya,ttyb,ttyc,ttyd" ;;
+    ttyb) lconsole="ttyb,ttya,ttyc,ttyd" ;;
+    ttyc) lconsole="ttyc,ttya,ttyb,ttyd" ;;
+    ttyd) lconsole="ttyd,ttya,ttyb,ttyc" ;;
+    *) fatal "Unknown serial-dev \"${serial_dev}\"" ;;
     esac
 
-    case "${console}" in
+    case "${os_console}" in
+    text|graphics|vga)
+        os_console="text"
+        lconsole="text,${lconsole}"
+        ;;
+
     serial)
-        console=${serial_dev}
+        os_console="${serial_dev}"
+        lconsole="${lconsole},text"
         ;;
+
     ttya|ttyb|ttyc|ttyd)
+        lconsole="${lconsole},text"
         ;;
-    text|graphics|vga)
-        console=text
-        ;;
+
     *)
-        fatal "Unknown default console device: ${console}"
+        fatal "Unknown console device \"${os_console}\""
         ;;
     esac
 
-    serial_string="--speed=115200 --unit=${unit} --word=8 --parity=no --stop=1"
+    cp -f ${STAGE}/boot/loader.conf.tmpl ${STAGE}/boot/loader.conf
 
-    sed \
-        -e "s/^#SERIAL/serial ${serial_string}/" \
-        -e "s/DEFAULT_CONSOLE/${console}/g" \
-        -e "s/^default.*$/default ${default_boot_option}/" \
-        -e "s/^#DR /${DR_VAL}/" \
-        boot/grub/menu.lst.tmpl \
-        > ${STAGE}/boot/grub/menu.lst.tmpl
+    echo "ipxe=\"${ipxe}\"" >>${STAGE}/boot/loader.conf
+    echo "console=\"${lconsole}\"" >>${STAGE}/boot/loader.conf
+    echo "os_console=\"${os_console}\"" >>${STAGE}/boot/loader.conf
 }
 
 function copy_base
@@ -288,11 +253,6 @@ function copy_base
         [[ -z ${ftbranch} ]] && ftbranch="master"
     fi
 
-    local sdcboot_path
-    sdcboot_path=$(get_bit "file.sdcboot.tgz")
-    local platboot_path
-    platboot_path=$(get_bit "file.platboot${plat_suf}.tgz")
-
     if [[ "${is_joyent}" == "true" ]]; then
         local firmware_path
         firmware_path=$(get_bit "file.firmware-tools.tgz")
@@ -313,19 +273,12 @@ function copy_base
     echo "==> Copying in default/"
     cp -r default ${STAGE}/default
 
+    echo "==> Copying in usbkey/contents/"
+    cp -r proto/opt/smartdc/share/usbkey/contents/* ${STAGE}
+
     echo "==> Copying in LICENSE"
     cp -r LICENSE ${STAGE}/LICENSE
 
-    echo "==> Extracting platform boot bundle"
-    if ! (cd ${STAGE} && ${TAR} -xzf ${platboot_path}); then
-        fatal "Failed to extract boot bundle"
-    fi
-
-    echo "==> Extracting sdcboot bundle"
-    if ! (cd ${STAGE} && ${TAR} -xzf ${sdcboot_path}); then
-        fatal "Failed to extract sdcboot bundle"
-    fi
-
     if [[ "${is_joyent}" == "true" ]]; then
         echo "==> Extracting firmware bundle"
         if ! (cd ${STAGE} && ${TAR} -xzf ${firmware_path}); then
@@ -462,10 +415,23 @@ function copy_platform
     root_pw=$(cat ${STAGE}/private/root.password.${LIVEIMG_VERSION})
     echo "Root password is: '${root_pw}'"
 
-    # Create the menu.lst file
-    cat ${STAGE}/boot/grub/menu.lst.tmpl | sed \
-        -e "s|/PLATFORM/|/os/${LIVEIMG_VERSION}/platform/|" \
-        > ${STAGE}/boot/grub/menu.lst
+    #
+    # By default, loader on illumos expects the "platform" directory to be at
+    # to be a top-level directory in the root filesystem and sets the location
+    # of the kernel to be relative to that.  On Triton, the platform directory
+    # exists under /os/${LIVEIMG_VERSION}, so we override it by setting the
+    # full paths to the kernel, boot archive and archive hash in loader.conf.
+    #
+    local defplatdir="/os/${LIVEIMG_VERSION}"
+    echo "bootfile=\"$defplatdir/platform/i86pc/kernel/amd64/unix\"" \
+        >> ${STAGE}/boot/loader.conf
+    echo "boot_archive_name=\"$defplatdir/platform/i86pc/amd64/boot_archive\"" \
+        >> ${STAGE}/boot/loader.conf
+    # BASHSTYLED
+    echo "boot_archive.hash_name=\"$defplatdir/platform/i86pc/amd64/boot_archive.hash\"" \
+        >> ${STAGE}/boot/loader.conf
+
+    echo "platform-version=\"${LIVEIMG_VERSION}\"" >> ${STAGE}/boot/loader.conf
 
     rm -f ${LOGDIR}/latest
     ln -s ${LOGFILE} ${LOGDIR}/latest
@@ -714,7 +680,7 @@ test_rootperms
 create_directories
 load_buildspec
 copy_base
-generate_grub_menu
+generate_loader_config
 copy_platform
 copy_sdcadm
 copy_agentsshar
diff --git a/bin/build-usb-image b/bin/build-usb-image
index 2ab2ea74..f585cdce 100755
--- a/bin/build-usb-image
+++ b/bin/build-usb-image
@@ -6,7 +6,7 @@
 #
 
 #
-# Copyright 2017 Joyent, Inc.
+# Copyright 2018 Joyent, Inc.
 #
 
 ROOT=$(cd $(dirname $0)/../; pwd)
@@ -37,14 +37,6 @@ while getopts cr name; do
 done
 shift $((OPTIND - 1))
 
-function rel2abs () {
-    local abs_path end
-    abs_path=$(unset CDPATH; cd `dirname $1` 2>/dev/null && pwd -P)
-    [[ -z "$abs_path" ]] && return 1
-    end=$(basename $1)
-    echo "${abs_path%*/}/$end"
-}
-
 if [[ -z "$1" ]]; then
     usage 'must provide <boot_tarball> filename'
 fi
@@ -87,15 +79,11 @@ function build_spec () {
 };
 
 BUILD_TGZ=$(build_spec build-tgz)
-
-
-MNT_DIR=/mnt/tmp
 USB_SIZE="4gb"
+PARTMAP="${USB_SIZE}.partition.map"
 OUTPUT_IMG="${USB_SIZE}.img"
-if [[ -z $IMG_TMP_DIR ]]; then
-  IMG_TMP_DIR=/tmp
-fi
-PLATFORM=$(uname -s)
+IMG_TMP_DIR=/tmp/tmp.$$
+MNT_DIR=$IMG_TMP_DIR/mnt
 
 #
 # Determine the name of the template images archive.  This depends on
@@ -108,13 +96,7 @@ if [[ $($BUILDSPEC -f debug-platform) == 'true' ]]; then
 fi
 TEMPLATE_IMG="$ROOT/cache/file.platimages$PLATFORM_SUFFIX.tgz"
 
-if [[ "$PLATFORM" == "SunOS" ]]; then
-    SUCMD='pfexec'
-elif [[ "$PLATFORM" == "Linux" ]]; then
-    SUCMD='sudo'
-    # Parted is required to find the partition offset in the image.
-    [[ $(which parted) ]] || fatal "Please install 'parted'"
-fi
+mkdir -p $IMG_TMP_DIR
 
 STAGE=${ROOT}/cache/stage_usb
 mkdir -p $STAGE
@@ -122,60 +104,16 @@ rm -rf $STAGE/*
 
 echo ">> Starting build at $(date)"
 
-function fatal
-{
-    echo "$(basename $0): fatal error: $*"
-    exit 1
-}
-
-function errexit
-{
-    [[ $1 -ne 0 ]] || exit 0
-    fatal "error exit status $1 at line $2"
-}
-
-trap 'errexit $? $LINENO' EXIT
-
-
 function unpack_image
 {
     echo -n "==> Unpacking USB image... "
-    rm -f "$IMG_TMP_DIR/$OUTPUT_IMG.$$"
-    (cd "$IMG_TMP_DIR" && $TAR -xzf "$TEMPLATE_IMG" "$OUTPUT_IMG" &&
-        mv "$OUTPUT_IMG" "$$.$OUTPUT_IMG") ||
+    rm -f "$IMG_TMP_DIR/$OUTPUT_IMG"
+    (cd "$IMG_TMP_DIR" &&
+        $TAR -xzf "$TEMPLATE_IMG" "$PARTMAP" "$OUTPUT_IMG") ||
         fatal "Unable to unpack USB image"
     echo "done."
 }
 
-function mount_image
-{
-    echo -n "==> Mounting new USB image... "
-    if [[ "$PLATFORM" == "Darwin" ]]; then
-        # REVIEW - [ blah ] ?
-        [ ! -d ${ROOT}/cache/tmp_volumes ] && mkdir -p ${ROOT}/cache/tmp_volumes
-        hdiutil attach $IMG_TMP_DIR/$$.${OUTPUT_IMG} \
-            >/tmp/output.hdiattach.$$ \
-            -mountrandom ${ROOT}/cache/tmp_volumes 2>&1
-        LOOPBACK=`grep "FDisk_partition_scheme" /tmp/output.hdiattach.$$ \
-            | awk '{ print $1 }'`
-        MNT_DIR=`grep "Windows_FAT_32" /tmp/output.hdiattach.$$ \
-            | awk '{ print $3 }'`
-    elif [[ "$PLATFORM" == "Linux" ]]; then
-        MNT_DIR="/tmp/sdc_image.$$"
-        mkdir -p "$MNT_DIR"
-        LOOPBACK=$IMG_TMP_DIR/$$.${OUTPUT_IMG}
-        OFFSET=$(parted -m "${LOOPBACK}" unit B print | grep fat32 \
-            | cut -f2 -d: | sed 's/.$//')
-        ${SUCMD} mount -o "loop,offset=${OFFSET},uid=${EUID},gid=${GROUPS[0]}" \
-            "${LOOPBACK}" "${MNT_DIR}"
-    else
-        ${SUCMD} mkdir -p ${MNT_DIR}
-        LOOPBACK=$(${SUCMD} lofiadm -a $IMG_TMP_DIR/$$.${OUTPUT_IMG})
-        ${SUCMD} mount -F pcfs -o foldcase ${LOOPBACK}:c ${MNT_DIR}
-    fi
-    echo "($IMG_TMP_DIR/coal.$$/$$.${OUTPUT_IMG} mounted on ${MNT_DIR}) done."
-}
-
 function copy_config {
 
     # Clear current configs from stage area
@@ -201,6 +139,7 @@ function copy_config {
 # Copy to mount is basically just extracting everything to the image mount
 function copy_to_mount
 {
+    echo "Extracting content to image root"
     if [[ $TAR_BUILD_IS_DIRECTORY == 1 ]]; then
         (cd $TAR_BUILD_FILENAME \
             && rsync -av .[a-zA-Z]* * $MNT_DIR/) \
@@ -227,31 +166,6 @@ function copy_to_mount
     chmod 444 $STAGE/*.manifest
 }
 
-CLEANED=0
-function cleanup
-{
-    if [ ${CLEANED} -eq 0 ]; then
-        echo '==> Cleaning up'
-        CLEANED=1
-        if [[ -n ${LOOPBACK} ]]; then
-            if [[ "$PLATFORM" == "Darwin" ]]; then
-                hdiutil detach ${MNT_DIR} || true
-            elif [[ "$PLATFORM" == "Linux" ]]; then
-                ${SUCMD} umount "${MNT_DIR}" || /usr/bin/true
-                rm -rf "${MNT_DIR}"
-            else
-                ${SUCMD} umount ${MNT_DIR} || /usr/bin/true
-                ${SUCMD} lofiadm -d ${LOOPBACK}
-            fi
-            sync; sync
-            LOOPBACK=
-        fi
-
-    fi
-    rm -rf $IMG_TMP_DIR/fs.*.$$
-    rm -rf $IMG_TMP_DIR/output.*.$$
-}
-
 function create_output
 {
     if [[ "$BUILD_TGZ" == "false" ]]; then
@@ -259,28 +173,48 @@ function create_output
         [[ -d $ROOT/usb-${THIS_BUILDSTAMP} ]] \
             && rm -rf $ROOT/usb-${THIS_BUILDSTAMP}
         (cd $STAGE \
-            && mv $IMG_TMP_DIR/$$.${OUTPUT_IMG} \
-            usb-${THIS_BUILDSTAMP}-${OUTPUT_IMG})
+            && mv $IMG_TMP_DIR/${OUTPUT_IMG} \
+            usb-${THIS_BUILDSTAMP}-${OUTPUT_IMG} \
+            && mv $IMG_TMP_DIR/$PARTMAP \
+            usb-${THIS_BUILDSTAMP}-$PARTMAP)
         mv $STAGE $ROOT/usb-${THIS_BUILDSTAMP}
     else
         echo "==> Creating usb-${THIS_BUILDSTAMP}.tgz"
         (cd $STAGE \
-            && mv $IMG_TMP_DIR/$$.${OUTPUT_IMG} \
+            && mv $IMG_TMP_DIR/${OUTPUT_IMG} \
             usb-${THIS_BUILDSTAMP}-${OUTPUT_IMG} \
+            && mv $IMG_TMP_DIR/$PARTMAP \
+            usb-${THIS_BUILDSTAMP}-$PARTMAP \
             && ${TAR} -zcf ${ROOT}/usb-${THIS_BUILDSTAMP}.tgz \
             root.password.${LIVEIMG_VERSION} \
+	    usb-${THIS_BUILDSTAMP}-$PARTMAP \
             usb-${THIS_BUILDSTAMP}-${OUTPUT_IMG} *.manifest)
         [[ $? -eq 0 ]] || fatal "Unable to create .tgz image."
 
     fi
-    rm -rf $IMG_TMP_DIR/*.${OUTPUT_IMG} || true
+
     rm -rf $STAGE || true
 }
 
+function cleanup
+{
+    echo '==> Cleaning up'
+
+    unmount_loopback
+
+    ${SUCMD} rm -f $IMG_TMP_DIR/*gb.img
+    ${SUCMD} rm -f $IMG_TMP_DIR/*gb.partition.map
+    ${SUCMD} rm -f ${IMG_TMP_DIR}/rootfs.img
+    ${SUCMD} rm -rf $IMG_TMP_DIR/fs.*
+    ${SUCMD} rm -rf $IMG_TMP_DIR/output.*
+    ${SUCMD} rmdir $MNT_DIR
+    ${SUCMD} rmdir $IMG_TMP_DIR
+}
+
 unpack_image
-mount_image
+mount_root_image
 trap 'cleanup' EXIT
 copy_to_mount
 copy_config
-cleanup
+unmount_root_image
 create_output
diff --git a/bin/reflash b/bin/reflash
index 386c6de5..30789c1a 100755
--- a/bin/reflash
+++ b/bin/reflash
@@ -129,18 +129,10 @@ backup_usb_key()
             set -o xtrace
         fi
 
-        if [[ -z \$(mount | grep "^\/mnt\/usbkey ") ]]; then
-            MOUNT_SCRIPT="/usbkey/scripts/mount-usb.sh"
-            if [[ ! -f \${MOUNT_SCRIPT} ]]; then
-                MOUNT_SCRIPT="/mnt/usbkey/scripts/mount-usb.sh"
-            fi
-
-            # mount the usb key
-            echo "# mounting USB key..."
-            \${MOUNT_SCRIPT}
-        else
-            echo "# USB key already mounted"
-        fi
+        /opt/smartdc/bin/sdc-usbkey mount >/dev/null || {
+            echo "unable to mount USB key" >&2
+            exit 1
+        }
 
         # Keep the answers.json if it exists
         if [[ -f /mnt/usbkey/private/answers.json ]]; then
@@ -661,19 +653,10 @@ restore_usb_key()
             set -o xtrace
         fi
 
-        # mount it again
-        if [[ -z \$(mount | grep "^\/mnt\/usbkey ") ]]; then
-            MOUNT_SCRIPT="/usbkey/scripts/mount-usb.sh"
-            if [[ ! -f \${MOUNT_SCRIPT} ]]; then
-                MOUNT_SCRIPT="/mnt/usbkey/scripts/mount-usb.sh"
-            fi
-
-            # mount the usb key
-            echo "# mounting USB key..."
-            \${MOUNT_SCRIPT}
-        else
-            echo "# USB key already mounted"
-        fi
+        /opt/smartdc/bin/sdc-usbkey mount >/dev/null || {
+            echo "unable to mount USB key" >&2
+            exit 1
+        }
 
         # move new devtools out of way so we can drop in old first
         if [[ -d /mnt/usbkey/devtools ]]; then
@@ -728,23 +711,32 @@ sanity_check_usb()
             set -o xtrace
         fi
 
-        # Ensure we've got a platform + grub
-        if [[ ! -f /mnt/usbkey/boot/grub/menu.lst ]]; then
-            echo "Missing grub menu.lst, bailing" >&2
-            exit 1
-        fi
         if [[ -z \$(find /mnt/usbkey/os/ -name "boot_archive") ]]; then
             echo "Missing boot_archive, bailing" >&2
             exit 1
         fi
 
-        # Set default menu item to boot to 1 so we can boot unattended (we know
-        # this is a HN since we're reflashing, so don't boot the Compute Node
-        # image)
-        sed -e "s/^default.*$/default 1/" /mnt/usbkey/boot/grub/menu.lst \
-            > /mnt/usbkey/boot/grub/menu.lst.new \
-            && mv /mnt/usbkey/boot/grub/menu.lst.new \
-                /mnt/usbkey/boot/grub/menu.lst
+        #
+        # Make sure to boot from USB, so we can boot unattended (we know this is
+        # an HN since we're reflashing, so don't boot the CN image).
+        #
+        # sdc-usbkey might not be new enough for this; in that case, we know
+        # we're using grub.
+        #
+        if ! /opt/smartdc/bin/sdc-usbkey set-variable \
+	    ipxe false 2>/dev/null; then
+
+            # Ensure we've got a platform + grub
+            if [[ ! -f /mnt/usbkey/boot/grub/menu.lst ]]; then
+                echo "Missing grub menu.lst, bailing" >&2
+                exit 1
+            fi
+
+            sed -e "s/^default.*$/default 1/" /mnt/usbkey/boot/grub/menu.lst \
+                > /mnt/usbkey/boot/grub/menu.lst.new \
+                && mv /mnt/usbkey/boot/grub/menu.lst.new \
+                    /mnt/usbkey/boot/grub/menu.lst
+        fi
 
         exit 0
 EOF
diff --git a/boot/forth/menu.rc b/boot/forth/menu.rc
new file mode 100644
index 00000000..35558bc0
--- /dev/null
+++ b/boot/forth/menu.rc
@@ -0,0 +1,168 @@
+\ Menu.rc
+\
+\ Load required Forth modules
+include /boot/forth/version.4th
+include /boot/forth/brand.4th
+include /boot/forth/menu.4th
+include /boot/forth/menu-commands.4th
+include /boot/forth/shortcuts.4th
+
+\ Init: store set up ipxe_command
+variable ipxe_command 20 chars allot
+
+s" efi-version" getenv? [if]
+	s" ipxe_chainload" ipxe_command place
+[else]
+	s" ipxe_boot" ipxe_command place
+[then]
+
+\ Screen prep
+clear         \ clear the screen (see `screen.4th')
+print_version \ print version string (bottom-right; see `version.4th')
+draw-beastie  \ draw freebsd mascot (on right; see `beastie.4th')
+draw-brand    \ draw the FreeBSD title (top-left; see `brand.4th')
+menu-init     \ initialize the menu area (see `menu.4th')
+
+\ Initialize main menu constructs (see `menu.4th')
+\ NOTE: To use `non-ansi' variants, add `loader_color=0' to loader.conf(5)
+\ NOTE: ANSI variants can use `^' in place of literal `Esc' (ASCII 27)
+
+\
+\ MAIN MENU
+\
+
+set menuset_name1="main"
+
+set mainmenu_init[1]="init_boot"
+
+set mainmenu_caption[1]="Compute Node (PXE)"
+set mainansi_caption[1]="Compute Node (PXE)"
+ipxe_command count s" mainmenu_command[1]" setenv
+
+s" platform-version" getenv? [if]
+	create tmpstr 32 chars allot
+	s" Boot " tmpstr place
+	s" platform-version" getenv tmpstr append
+	tmpstr count s" mainmenu_caption[2]" setenv
+	tmpstr count s" mainansi_caption[2]" setenv
+[else]
+	set mainmenu_caption[2]="Boot SmartOS [Enter]"
+	set mainansi_caption[2]="Boot SmartOS [Enter]"
+[then]
+set mainmenu_command[2]="boot"
+
+s" prev-version" getenv? [if]
+	create tmpstr2 48 chars allot
+	s" Rollback to " tmpstr2 place
+	s" prev-version" getenv tmpstr2 append
+	tmpstr2 count s" mainmenu_caption[3]" setenv
+	tmpstr2 count s" mainansi_caption[3]" setenv
+	set mainmenu_command[3]="rollback_boot"
+
+	set mainmenu_caption[4]="[Esc]ape to loader prompt"
+	set mainmenu_command[4]="goto_prompt"
+	set mainmenu_keycode[4]=27
+	set mainansi_caption[4]="^[1mEsc^[mape to loader prompt"
+
+	\ Enable built-in "Reboot" trailing menuitem
+	\ NOTE: appears before menu_options if configured
+	\
+	set mainmenu_reboot
+
+	\ Enable "Options:" separator. When set to a numerical value (1-8), a visual
+	\ separator is inserted before that menuitem number.
+	\
+	set mainmenu_options=6
+
+	set mainmenu_caption[6]="Configure Boot [O]ptions..."
+	set mainmenu_command[6]="2 goto_menu"
+	set mainmenu_keycode[6]=111
+	set mainansi_caption[6]="Configure Boot ^[1mO^[mptions..."
+[else]
+	set mainmenu_caption[3]="[Esc]ape to loader prompt"
+	set mainmenu_command[3]="goto_prompt"
+	set mainmenu_keycode[3]=27
+	set mainansi_caption[3]="^[1mEsc^[mape to loader prompt"
+
+	\ Enable built-in "Reboot" trailing menuitem
+	\ NOTE: appears before menu_options if configured
+	\
+	set mainmenu_reboot
+
+	\ Enable "Options:" separator. When set to a numerical value (1-8), a visual
+	\ separator is inserted before that menuitem number.
+	\
+	set mainmenu_options=5
+
+	set mainmenu_caption[5]="Configure Boot [O]ptions..."
+	set mainmenu_command[5]="2 goto_menu"
+	set mainmenu_keycode[5]=111
+	set mainansi_caption[5]="Configure Boot ^[1mO^[mptions..."
+[then]
+
+\
+\ BOOT OPTIONS MENU
+\
+
+set menuset_name2="options"
+
+set optionsmenu_caption[1]="Back to Main Menu [Backspace]"
+set optionsmenu_command[1]="1 goto_menu"
+set optionsmenu_keycode[1]=8
+set optionsansi_caption[1]="Back to Main Menu ^[1m[Backspace]^[m"
+
+set optionsmenu_options=2
+set optionsmenu_optionstext="Boot Options:"
+
+set optionsmenu_osconsole=2
+set optionsmenu_command[2]="cycle_osconsole"
+set optionsmenu_keycode[2]=99
+
+set optionsmenu_init[3]="init_verbose"
+set optionsmenu_caption[3]="[V]erbose............. Off"
+set optionstoggled_text[3]="[V]erbose............. On"
+set optionsmenu_command[3]="toggle_verbose"
+set optionsmenu_keycode[3]=118
+set optionsansi_caption[3]="^[1mV^[merbose......... ^[34;1mOff^[m"
+set optionstoggled_ansi[3]="^[1mV^[merbose......... ^[32;7mOn^[m"
+
+set optionsmenu_init[4]="init_kmdb"
+set optionsmenu_caption[4]="k[m]db................ Off"
+set optionstoggled_text[4]="k[m]db................ On"
+set optionsmenu_command[4]="toggle_kmdb"
+set optionsmenu_keycode[4]=109
+set optionsansi_caption[4]="k^[1mm^[mdb............ ^[34;1mOff^[m"
+set optionstoggled_ansi[4]="k^[1mm^[mdb............ ^[32;7mOn^[m"
+
+set optionsmenu_init[5]="init_debug"
+set optionsmenu_caption[5]="[D]ebug............... Off"
+set optionstoggled_text[5]="[D]ebug............... On"
+set optionsmenu_command[5]="toggle_debug"
+set optionsmenu_keycode[5]=100
+set optionsansi_caption[5]="^[1mD^[mebug........... ^[34;1mOff^[m"
+set optionstoggled_ansi[5]="^[1mD^[mebug........... ^[32;7mOn^[m"
+
+set optionsmenu_init[6]="init_dr"
+set optionsmenu_caption[6]="Disaster [R]ecovery... Off"
+set optionstoggled_text[6]="Disaster [R]ecovery... On"
+set optionsmenu_command[6]="toggle_dr"
+set optionsmenu_keycode[6]=114
+set optionsansi_caption[6]="Disaster ^[1mR^mecovery......... ^[34;1mOff^[m"
+set optionstoggled_ansi[6]="Disaster ^[1mR^mecovery........ ^[32;7mOn^[m"
+
+\ Set menu_timeout_command depending on whether the user
+\ has set ipxe
+s" ipxe" getenv s" true" compare 0= [if]
+	ipxe_command count s" menu_timeout_command" setenv
+[else]
+	s" boot" strdup s" menu_timeout_command" setenv
+[then]
+
+\ Include optional elements defined in a local file
+\
+try-include /boot/menu.rc.local
+
+\ Display the main menu (see `menu.4th')
+set menuset_initial=1
+menuset-loadinitial
+menu-display
diff --git a/boot/grub/menu.lst.tmpl b/boot/grub/menu.lst.tmpl
deleted file mode 100755
index 19cf10cc..00000000
--- a/boot/grub/menu.lst.tmpl
+++ /dev/null
@@ -1,49 +0,0 @@
-#
-# This Source Code Form is subject to the terms of the Mozilla Public
-# License, v. 2.0. If a copy of the MPL was not distributed with this
-# file, You can obtain one at http://mozilla.org/MPL/2.0/.
-#
-
-#
-# Copyright (c) 2014, Joyent, Inc.
-#
-
-default 0
-timeout 10
-min_mem64 1024
-#SERIAL
-terminal composite
-variable os_console DEFAULT_CONSOLE
-
-title Compute Node (PXE)
-   kernel /boot/ipxe.lkrn
-   module /boot/default.ipxe
-
-title Live 64-bit
-   kernel$ /PLATFORM/i86pc/kernel/amd64/unix -B console=${os_console},${os_console}-mode="115200,8,n,1,-",headnode=true
-   module /PLATFORM/i86pc/amd64/boot_archive
-   module /PLATFORM/i86pc/amd64/boot_archive.hash
-
-#PREV title Live 64-bit (rollback to PREV_PLATFORM_VERSION)
-#PREV    kernel$ /PREV_PLATFORM/i86pc/kernel/amd64/unix -B console=${os_console},${os_console}-mode="115200,8,n,1,-",headnode=true
-#PREV    module /PREV_PLATFORM/i86pc/amd64/boot_archive
-#PREV    module /PREV_PLATFORM/i86pc/amd64/boot_archive.hash
-
-title Live 64-bit Rescue (no importing zpool)
-   kernel$ /PLATFORM/i86pc/kernel/amd64/unix -B console=${os_console},${os_console}-mode="115200,8,n,1,-",headnode=true,noimport=true
-   module /PLATFORM/i86pc/amd64/boot_archive
-   module /PLATFORM/i86pc/amd64/boot_archive.hash
-
-title Live 64-bit +kmdb
-   kernel$ /PLATFORM/i86pc/kernel/amd64/unix -kd -B console=${os_console},${os_console}-mode="115200,8,n,1,-",headnode=true
-   module /PLATFORM/i86pc/amd64/boot_archive
-   module /PLATFORM/i86pc/amd64/boot_archive.hash
-
-#DR title Live 64-bit (Disaster recovery mode)
-#DR    kernel$ /PLATFORM/i86pc/kernel/amd64/unix -B console=${os_console},${os_console}-mode="115200,8,n,1,-",headnode=true,DISASTER_RECOVERY=true
-#DR    module /PLATFORM/i86pc/amd64/boot_archive
-#DR    module /PLATFORM/i86pc/amd64/boot_archive.hash
-
-title Legacy Firmware Upgrade Mode
-   kernel$ /boot/memdisk console=${os_console}
-   module /boot/freedos.img raw
diff --git a/boot/loader.conf.tmpl b/boot/loader.conf.tmpl
new file mode 100644
index 00000000..b7811399
--- /dev/null
+++ b/boot/loader.conf.tmpl
@@ -0,0 +1,10 @@
+loader_logo="smartos"
+loader_brand="smartos"
+headnode="true"
+ipxe-bootfile="/boot/ipxe.lkrn"
+ipxe-archive="/boot/default.ipxe"
+ipxe-efi="/boot/ipxe.efi"
+ttya-mode="115200,8,n,1,-"
+ttyb-mode="115200,8,n,1,-"
+ttyc-mode="115200,8,n,1,-"
+ttyd-mode="115200,8,n,1,-"
diff --git a/boot/splash.xpm.gz b/boot/splash.xpm.gz
deleted file mode 100644
index 1c2973ac..00000000
Binary files a/boot/splash.xpm.gz and /dev/null differ
diff --git a/build.spec b/build.spec
index 5a672d94..4752a385 100644
--- a/build.spec
+++ b/build.spec
@@ -57,8 +57,8 @@
   },
 
   "files": {
-    "sdcboot": {
-      "file": { "base": "sdcboot", "ext": "tgz" }
+    "ipxe": {
+      "file": { "base": "ipxe", "ext": "tgz" }
     },
 
     "platboot": {
diff --git a/buildtools/lib/common.sh b/buildtools/lib/common.sh
index a0cff1f0..f1bf7d53 100755
--- a/buildtools/lib/common.sh
+++ b/buildtools/lib/common.sh
@@ -6,7 +6,7 @@
 #
 
 #
-# Copyright 2016 Joyent, Inc.
+# Copyright 2018 Joyent, Inc.
 #
 
 #
@@ -26,3 +26,114 @@ elif [[ $(uname) = "SunOS" ]]; then
 else
 	TAR="tar"
 fi
+
+PLATFORM=$(uname -s)
+
+if [[ "$PLATFORM" == "SunOS" ]]; then
+    SUCMD='pfexec'
+elif [[ "$PLATFORM" == "Darwin" ]]; then
+    SUCMD='sudo'
+elif [[ "$PLATFORM" == "Linux" ]]; then
+    SUCMD='sudo'
+fi
+
+function fatal
+{
+    echo "$(basename $0): fatal error: $*"
+    exit 1
+}
+
+function errexit
+{
+    [[ $1 -ne 0 ]] || exit 0
+    fatal "error exit status $1 at line $2"
+}
+
+trap 'errexit $? $LINENO' EXIT
+
+function rel2abs () {
+    local abs_path end
+    abs_path=$(unset CDPATH; cd `dirname $1` 2>/dev/null && pwd -P)
+    [[ -z "$abs_path" ]] && return 1
+    end=$(basename $1)
+    echo "${abs_path%*/}/$end"
+}
+
+#
+# The USB Image uses the GPT partitioning scheme and has the following slices:
+#
+# slice 1 - EFI System Partition (PCFS)
+# slice 2 - Boot partition (no filesystem)
+# slice 3 - Root partition (PCFS)
+# slice 9 - reserved
+#
+# For our purposes, we want to mount slice 3, as that's where we'll be
+# installing the platform image and other required software.
+#
+# Under SmartOS, we can't use labeled lofi or any other method to directly
+# access the root filesystem, so we need to work from a temporary image.
+#
+function mount_root_image
+{
+    echo -n "==> Mounting new USB image... "
+    if [[ "$PLATFORM" == "Darwin" ]]; then
+        [ ! -d ${ROOT}/cache/tmp_volumes ] && mkdir -p ${ROOT}/cache/tmp_volumes
+        ${SUCMD} hdiutil attach -nomount \
+            -imagekey diskimage-class=CRawDiskImage \
+            $IMG_TMP_DIR/${OUTPUT_IMG} >/tmp/output.hdiattach.$$ 2>&1
+        LOOPBACK=`grep "GUID_partition_scheme" /tmp/output.hdiattach.$$ \
+            | awk '{ print $1 }'`
+        MNT_DIR=$(mktemp -d ${ROOT}/cache/tmp_volumes/root.XXXX)
+        ${SUCMD} mount -t msdos ${LOOPBACK}s3 $MNT_DIR
+    elif [[ "$PLATFORM" == "Linux" ]]; then
+        # XXX - might need to fix this up
+        MNT_DIR="/tmp/sdc_image.$$"
+        mkdir -p "$MNT_DIR"
+        LOOPBACK=$IMG_TMP_DIR/${OUTPUT_IMG}
+        OFFSET=$(parted -s -m "${LOOPBACK}" unit B print | grep fat32:root \
+            | cut -f2 -d: | sed 's/.$//')
+        ${SUCMD} mount -o "loop,offset=${OFFSET},uid=${EUID},gid=${GROUPS[0]}" \
+            "${LOOPBACK}" "${MNT_DIR}"
+    else
+        ${SUCMD} mkdir -p ${MNT_DIR}
+        ROOTOFF=$(nawk '$1 == "root" { print $3 }' <$IMG_TMP_DIR/$PARTMAP)
+        ROOTSIZE=$(nawk '$1 == "root" { print $4 }' <$IMG_TMP_DIR/$PARTMAP)
+        ${SUCMD} /usr/bin/dd bs=1048576 conv=notrunc \
+            iseek=$(( $ROOTOFF / 1048576 )) count=$(( $ROOTSIZE / 1048576 )) \
+            if=$IMG_TMP_DIR/${OUTPUT_IMG} of=$IMG_TMP_DIR/rootfs.img
+        ${SUCMD} mount -F pcfs -o foldcase ${IMG_TMP_DIR}/rootfs.img ${MNT_DIR}
+    fi
+    echo "rootfs mounted on ${MNT_DIR}"
+}
+
+function unmount_loopback
+{
+    if ${SUCMD} mount | grep $MNT_DIR >/dev/null; then
+        ${SUCMD} umount $MNT_DIR
+    fi
+
+    if [[ -n "$LOOPBACK" && "$PLATFORM" == "Darwin" ]]; then
+        ${SUCMD} hdiutil detach ${LOOPBACK} || /usr/bin/true
+    fi
+
+    sync; sync
+    LOOPBACK=
+}
+
+#
+# On SmartOS, we need to copy our root fs back over into the original image
+# file.
+#
+function unmount_root_image
+{
+    unmount_loopback
+
+    if [[ "$PLATFORM" = "SunOS" ]]; then
+        ROOTOFF=$(nawk '$1 == "root" { print $3 }' <$IMG_TMP_DIR/$PARTMAP)
+        ROOTSIZE=$(nawk '$1 == "root" { print $4 }' <$IMG_TMP_DIR/$PARTMAP)
+
+        ${SUCMD} /usr/bin/dd bs=1048576 conv=notrunc \
+            oseek=$(( $ROOTOFF / 1048576 )) count=$(( $ROOTSIZE / 1048576 )) \
+            if=$IMG_TMP_DIR/rootfs.img of=$IMG_TMP_DIR/${OUTPUT_IMG}
+    fi
+}
diff --git a/buildtools/novus/cmd/checker.js b/buildtools/novus/cmd/checker.js
index 23ddc32c..2cee71fb 100644
--- a/buildtools/novus/cmd/checker.js
+++ b/buildtools/novus/cmd/checker.js
@@ -6,7 +6,7 @@
  */
 
 /*
- * Copyright 2017 Joyent, Inc.
+ * Copyright (c) 2018, Joyent, Inc.
  */
 
 var mod_fs = require('fs');
@@ -105,7 +105,7 @@ check_old_branch_keys()
 	var OLD_TO_NEW = {
 		'platform-image': '"files.platform.*"',
 		'platform-release': '"files.platform.*"',
-		'sdcboot-release': '"files.sdcboot.*"',
+		'ipxe-release': '"files.ipxe.*"',
 		'firmware-tools-release': '"files.firmware-tools.*"',
 		'sdcadm-release': '"files.sdcadm.*"',
 		'agents-shar': '"files.agents.*" and "files.agents_md5.*"'
diff --git a/buildtools/novus/lib/bits_from/dir.js b/buildtools/novus/lib/bits_from/dir.js
index 538748fa..60e29b45 100755
--- a/buildtools/novus/lib/bits_from/dir.js
+++ b/buildtools/novus/lib/bits_from/dir.js
@@ -94,7 +94,7 @@ bfd_find_build_files(bfd, next)
 	 *
 	 * For example:
 	 *
-	 *   sdcboot-master-20150421T175549Z-g41a555a.tgz
+	 *   boot-master-20181203T230136Z.tgz
 	 *
 	 * Build a regular expression that will, given our selection
 	 * constraints, match only the build artefact file we are looking for:
diff --git a/buildtools/novus/lib/bits_from/manta.js b/buildtools/novus/lib/bits_from/manta.js
index 3b6d11ca..81639351 100755
--- a/buildtools/novus/lib/bits_from/manta.js
+++ b/buildtools/novus/lib/bits_from/manta.js
@@ -96,7 +96,7 @@ bfm_find_build_files(bfm, next)
 	 * Build artefacts from MG are uploaded into Manta in a directory
 	 * structure that reflects the branch and build stamp, e.g.
 	 *
-	 *   /Joyent_Dev/public/builds/sdcboot/master-20150421T175549Z
+	 *   /Joyent_Dev/public/builds/platform/master-20150421T175549Z
 	 *
 	 * The build artefact we are interested in downloading generally
 	 * has a filename of the form:
@@ -105,7 +105,7 @@ bfm_find_build_files(bfm, next)
 	 *
 	 * For example:
 	 *
-	 *   sdcboot-master-20150421T175549Z-g41a555a.tgz
+	 *   platform-master-20150421T175549Z.tgz
 	 *
 	 * Build a regular expression that will, given our selection
 	 * constraints, match only the build artefact file we are looking for:
@@ -245,11 +245,10 @@ bfm_find_build_files(bfm, next)
  * that includes the MD5 checksum and the filename of each produced bit.  The
  * lines look roughly like:
  *
- *   a28033c7b101328f3f9921a178088c45 bits//sdcboot/sdcboot-g41a555a.tgz
+ *   e3b3ee... bits//platform/platform-master-20150721T202313Z.tgz
  *
  * It is probably not safe to infer anything about the path, other than
- * that the _basename_ (e.g. "sdcboot-g41a555a.tgz" in the above) will
- * match the uploaded object name in Manta.
+ * that the _basename_ will match the uploaded object name in Manta.
  */
 function
 bfm_get_md5sum(bfm, next)
@@ -302,12 +301,12 @@ bfm_get_md5sum(bfm, next)
 /*
  * Each build artefact from MG is uploaded into a Manta directory, e.g.
  *
- *   /Joyent_Dev/public/builds/sdcboot/master-20150421T175549Z
+ *   /Joyent_Dev/public/builds/platform/master-20150421T175549Z
  *
  * MG also maintains an object (not a directory) that contains the full
  * path of the most recent build for a particular branch, e.g.
  *
- *   /Joyent_Dev/public/builds/sdcboot/master-latest
+ *   /Joyent_Dev/public/builds/platform/master-latest
  */
 function
 bfm_lookup_latest_dir(bfm, next)
diff --git a/scripts/cleanup-key.sh b/scripts/cleanup-key.sh
index e74842db..64db033e 100755
--- a/scripts/cleanup-key.sh
+++ b/scripts/cleanup-key.sh
@@ -6,10 +6,14 @@
 #
 
 #
-# Copyright (c) 2014, Joyent, Inc.
+# Copyright (c) 2018, Joyent, Inc.
 #
+function fatal()
+{
+        printf "%s\n" "$1" 1>&2
+        exit 1
+}
 
-usbmnt=/mnt/usbkey
 cache=/usbkey
 
 cleanup_cache=0
@@ -21,7 +25,8 @@ do
 done
 shift $(($OPTIND - 1))
 
-/usbkey/scripts/mount-usb.sh
+usbmnt=$(/opt/smartdc/bin/sdc-usbkey mount)
+[ $? != 0 ] && fatal "failed to mount USB key"
 
 # cleanup old images from the USB key
 cnt=$(ls -d ${usbmnt}/os/* | wc -l)
diff --git a/scripts/install-platform.sh b/scripts/install-platform.sh
index 9c1ec4db..758fe71a 100755
--- a/scripts/install-platform.sh
+++ b/scripts/install-platform.sh
@@ -6,7 +6,7 @@
 #
 
 #
-# Copyright (c) 2014, Joyent, Inc.
+# Copyright (c) 2018, Joyent, Inc.
 #
 
 function usage()
@@ -75,9 +75,12 @@ fatal_cleanup=0
 . /lib/sdc/config.sh
 load_sdc_config
 
-if [[ -z $(mount | grep ^${usbmnt}) ]]; then
+mnt_status=$(/opt/smartdc/bin/sdc-usbkey status)
+[ $? != 0 ] && fatal "failed to get USB key status"
+if [[ $mnt_status = "unmounted" ]]; then
     echo "==> Mounting USB key"
-    /usbkey/scripts/mount-usb.sh
+    /opt/smartdc/bin/sdc-usbkey mount
+    [ $? != 0 ] && fatal "failed to mount USB key"
     mounted="true"
 fi
 
@@ -142,7 +145,7 @@ fatal_cleanup=0
 
 if [[ ${mounted} == "true" ]]; then
     echo "==> Unmounting USB Key"
-    umount /mnt/usbkey
+    /opt/smartdc/bin/sdc-usbkey unmount
 fi
 
 echo "==> Adding to list of available platforms"
diff --git a/scripts/joysetup.sh b/scripts/joysetup.sh
index 2b4e6cfb..c88f73d9 100755
--- a/scripts/joysetup.sh
+++ b/scripts/joysetup.sh
@@ -6,7 +6,7 @@
 #
 
 #
-# Copyright 2017 Joyent, Inc.
+# Copyright (c) 2019, Joyent, Inc.
 #
 
 #
@@ -63,6 +63,58 @@ if [[ $(zonename) != "global" && -n ${MOCKCN_SERVER_UUID} ]]; then
     MOCKCN="true"
 fi
 
+#
+# If we're on an older PI, this include file won't exist. For a CN, it doesn't
+# matter, as these routines are only used by headnode_boot_setup.
+#
+# An HN that has done `update-gz-tools` could be running this script on an older
+# PI. But such an older PI can presume grub: if we had a loader key, it should
+# have a PI new enough to have this file.
+#
+. /lib/sdc/usb-key.sh 2>/dev/null || {
+
+   function usb_key_set_console
+   {
+       local readonly console=$1
+
+       if [[ ! -f /mnt/usbkey/boot/grub/menu.lst.tmpl ]]; then
+           fatal "No GRUB menu found."
+       else
+           sed -e "s/^variable os_console.*/variable os_console ${console}/" \
+               < /mnt/usbkey/boot/grub/menu.lst.tmpl \
+               > /tmp/menu.lst.tmpl
+           mv -f /tmp/menu.lst.tmpl /mnt/usbkey/boot/grub/menu.lst.tmpl
+       fi
+
+       if [[ -f /mnt/usbkey/boot/grub/menu.lst ]]; then
+           sed -e "s/^variable os_console.*/variable os_console ${console}/" \
+               < /mnt/usbkey/boot/grub/menu.lst \
+               > /tmp/menu.lst
+           mv -f /tmp/menu.lst /mnt/usbkey/boot/grub/menu.lst
+       fi
+   }
+
+   function usb_key_disable_ipxe
+   {
+       if [[ ! -f /mnt/usbkey/boot/grub/menu.lst.tmpl ]]; then
+           fatal "No GRUB menu found."
+       else
+           sed -e "s/^default.*/default 1/" \
+               < /mnt/usbkey/boot/grub/menu.lst.tmpl \
+               > /tmp/menu.lst.tmpl
+           mv -f /tmp/menu.lst.tmpl /mnt/usbkey/boot/grub/menu.lst.tmpl
+       fi
+
+       if [[ -f /mnt/usbkey/boot/grub/menu.lst ]]; then
+           sed -e "s/^default.*/default 1/" \
+               < /mnt/usbkey/boot/grub/menu.lst \
+               > /tmp/menu.lst
+           mv -f /tmp/menu.lst /mnt/usbkey/boot/grub/menu.lst
+       fi
+   }
+
+}
+
 # Load SYSINFO_* and CONFIG_* values
 . /lib/sdc/config.sh
 load_sdc_sysinfo
@@ -174,7 +226,11 @@ function check_ntp
     set -o pipefail
 }
 
-function boot_setup
+#
+# If we're a headnode we should default to booting from the USB key from this
+# point on.  In addition we should update any console setting.
+#
+function headnode_boot_setup
 {
     local console=
 
@@ -182,24 +238,14 @@ function boot_setup
     console=$(bootparams | grep ^console= | cut -d= -f2)
     set -o pipefail
 
-    [[ -z "${console}" ]] && console=text
+    [[ -z "$console" ]] && console=text
 
-    if [[ ! -f /mnt/usbkey/boot/grub/menu.lst.tmpl ]]; then
-        fatal "No GRUB menu found."
-    else
-        sed -e "s/^default.*/default 1/" \
-            -e "s/^variable os_console.*/variable os_console ${console}/" \
-            < /mnt/usbkey/boot/grub/menu.lst.tmpl \
-            > /tmp/menu.lst.tmpl
-        mv -f /tmp/menu.lst.tmpl /mnt/usbkey/boot/grub/menu.lst.tmpl
+    if ! usb_key_set_console "$console"; then
+        fatal "Couldn't set bootloader console to \"$console\""
     fi
 
-    if [[ -f /mnt/usbkey/boot/grub/menu.lst ]]; then
-        sed -e "s/^default.*/default 1/" \
-            -e "s/^variable os_console.*/variable os_console ${console}/" \
-            < /mnt/usbkey/boot/grub/menu.lst \
-            > /tmp/menu.lst
-        mv -f /tmp/menu.lst /mnt/usbkey/boot/grub/menu.lst
+    if ! usb_key_disable_ipxe; then
+        fatal "Couldn't modify bootloader to disable ipxe"
     fi
 }
 
@@ -634,7 +680,7 @@ if [[ "$(zpool list)" == "no pools available" ]] \
     create_zpool zones ${POOL_FILE}
 
     if is_headnode; then
-        boot_setup
+        headnode_boot_setup
     fi
 
     if is_headnode; then
diff --git a/scripts/mount-image.sh b/scripts/mount-image.sh
index 074f1823..e55332fa 100755
--- a/scripts/mount-image.sh
+++ b/scripts/mount-image.sh
@@ -6,7 +6,7 @@
 #
 
 #
-# Copyright (c) 2015, Joyent, Inc.
+# Copyright (c) 2018, Joyent, Inc.
 #
 
 #
@@ -42,9 +42,12 @@ fi
 # BASHSTYLED
 usbcp="$(svcprop -p 'joyentfs/usb_copy_path' svc:/system/filesystem/smartdc:default)"
 
-mount | grep "^${usbmnt}" >/dev/null 2>&1 || bash $usbcp/scripts/mount-usb.sh
-
-mount | grep "^${usbmnt}" >/dev/null 2>&1 || fatal "${usbmnt} is not mounted"
+mnt_status=$(/opt/smartdc/bin/sdc-usbkey status)
+[ $? != 0 ] && fatal "failed to get USB key status"
+if [[ $mnt_status = "unmounted" ]]; then
+    /opt/smartdc/bin/sdc-usbkey mount
+    [ $? != 0 ] && fatal "failed to mount USB key"
+fi
 
 if [[ ! -f $image ]]; then
     fatal "could not find image file $image"
diff --git a/scripts/mount-usb.sh b/scripts/mount-usb.sh
deleted file mode 100755
index c91a2420..00000000
--- a/scripts/mount-usb.sh
+++ /dev/null
@@ -1,36 +0,0 @@
-#!/usr/bin/bash
-#
-# This Source Code Form is subject to the terms of the Mozilla Public
-# License, v. 2.0. If a copy of the MPL was not distributed with this
-# file, You can obtain one at http://mozilla.org/MPL/2.0/.
-#
-
-#
-# Copyright (c) 2015, Joyent, Inc.
-#
-
-function fatal
-{
-    echo "`basename $0`: $*" >&2
-    exit 1
-}
-
-# BASHSTYLED
-usbmnt="/mnt/$(svcprop -p 'joyentfs/usb_mountpoint' svc:/system/filesystem/smartdc:default)"
-
-USBKEYS=`/usr/bin/disklist -a`
-for key in ${USBKEYS}; do
-    if [[ `/usr/sbin/fstyp /dev/dsk/${key}p1` == 'pcfs' ]]; then
-        /usr/sbin/mount -F pcfs -o foldcase,noatime /dev/dsk/${key}p1 \
-            ${usbmnt};
-        if [[ $? == "0" ]]; then
-            if [[ ! -f ${usbmnt}/.joyliveusb ]]; then
-                /usr/sbin/umount ${usbmnt};
-            else
-                break;
-            fi
-        fi
-    fi
-done
-
-mount | grep "^${usbmnt}" >/dev/null 2>&1 || fatal "${usbmnt} is not mounted"
diff --git a/scripts/restore.sh b/scripts/restore.sh
index 4c79d202..e7d08c84 100755
--- a/scripts/restore.sh
+++ b/scripts/restore.sh
@@ -6,7 +6,7 @@
 #
 
 #
-# Copyright (c) 2014, Joyent, Inc.
+# Copyright (c) 2018, Joyent, Inc.
 #
 
 #
@@ -51,7 +51,6 @@ function on_error
 }
 
 # BEGIN BASHSTYLED
-usbmnt="/mnt/$(svcprop -p 'joyentfs/usb_mountpoint' svc:/system/filesystem/smartdc:default)"
 usbcpy="$(svcprop -p 'joyentfs/usb_copy_path' svc:/system/filesystem/smartdc:default)"
 # END BASHSTYLED
 mounted_usb="false"
@@ -78,7 +77,7 @@ function cleanup
     rm -rf ${TEMPDIR}
 
     if [[ ${mounted_usb} == "true" ]]; then
-        umount ${usbmnt}
+        /opt/smartdc/bin/sdc-usbkey unmount
         mounted_usb="false"
     fi
 
@@ -87,9 +86,10 @@ function cleanup
 
 function mount_usbkey
 {
-    if [[ -z $(mount | grep ^${usbmnt}) ]]; then
+    mnt_status=$(/opt/smartdc/bin/sdc-usbkey status)
+    if [[ $mnt_status = "unmounted" ]]; then
         echo "==> Mounting USB key"
-        ${usbcpy}/scripts/mount-usb.sh
+        /opt/smartdc/bin/sdc-usbkey mount
         mounted_usb="true"
     fi
 }
diff --git a/scripts/switch-platform.sh b/scripts/switch-platform.sh
index a7d46618..b6752c72 100755
--- a/scripts/switch-platform.sh
+++ b/scripts/switch-platform.sh
@@ -6,7 +6,7 @@
 #
 
 #
-# Copyright (c) 2014, Joyent, Inc.
+# Copyright (c) 2019, Joyent, Inc.
 #
 
 set -o errexit
@@ -15,95 +15,203 @@ set -o pipefail
 #export PS4='[\D{%FT%TZ}] ${BASH_SOURCE}:${LINENO}: ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
 #set -o xtrace
 
+function fatal()
+{
+        printf "%s\n" "$1" 1>&2
+        exit 1
+}
+
+function usage()
+{
+    print -u2 "Usage: $0 <platform buildstamp>"
+    print -u2 "(eg. '$0 20110318T170209Z')"
+    exit 1
+}
+
 if [[ "$1" = "-n" ]]; then
     dryrun=true
     shift
 fi
 
-version="${1^^}"
-if [[ -z "${version}" ]]; then
-    echo "Usage: $0 <platform buildstamp>"
-    echo "(eg. '$0 20110318T170209Z')"
-    exit 1
-fi
-
-current_version=$(uname -v | cut -d '_' -f 2)
-
-# BEGIN BASHSTYLED
-usbmnt="/mnt/$(svcprop -p 'joyentfs/usb_mountpoint' svc:/system/filesystem/smartdc:default)"
-usbcpy="$(svcprop -p 'joyentfs/usb_copy_path' svc:/system/filesystem/smartdc:default)"
-# END BASHSTYLED
-mounted="false"
-hashfile="/platform/i86pc/amd64/boot_archive.hash"
-menulst="${usbmnt}/boot/grub/menu.lst"
-
 function onexit
 {
     if [[ ${mounted} == "true" ]]; then
         echo "==> Unmounting USB Key"
-        umount /mnt/usbkey
+        /opt/smartdc/bin/sdc-usbkey unmount ||
+            echo "failed to unmount USB key" >&2
     fi
 
     echo "==> Done!"
 }
 
+# replace a loader conf value
+function edit_param
+{
+    local readonly file="$1"
+    local readonly key="$2"
+    local readonly value="$3"
+    if ! /usr/bin/grep "^\s*$key\s*=\s*" $file >/dev/null; then
+        echo "$key=\"$value\"" >>$file
+        return
+    fi
+
+    /usr/bin/sed -i '' "s+^\s*$key\s*=.*+$key=\"$value\"+" $file
+}
+
+function config_loader
+{
+    local readonly kernel="i86pc/kernel/amd64/unix"
+    local readonly archive="i86pc/amd64/boot_archive"
+    local readonly tmpconf=$(mktemp /tmp/loader.conf.XXXX)
+
+    echo "==> Updating Loader configuration"
+
+    cp ${usbmnt}/boot/loader.conf $tmpconf
+
+    edit_param $tmpconf bootfile "/os/$version/platform/$kernel"
+    edit_param $tmpconf boot_archive_name "/os/$version/platform/$archive"
+    edit_param $tmpconf boot_archive.hash_name \
+        "/os/$version/platform/${archive}.hash"
+    edit_param $tmpconf platform-version "$version"
+
+    #
+    # Check whether the currently running (soon-to-be previous) version
+    # exists on the USB key.  This should always be the case on production
+    # bits as we set the rollback target to the currently running platform and
+    # sdcadm will prevent the user from removing the currently running platform
+    # (though it can be overridden with the --force option).  The more likely
+    # place we'd see this is with developer platform images where there can
+    # be skew between the platform buildstamp and the version stamp that gets
+    # encoded into unix.  When that happens, the buildstamp of the currently
+    # running platform may not match the output of "uname -v".  So this code
+    # attempts to handle these (admittedly rare) corner cases to ensure that:
+    #
+    # 1) The boot entry for the rollback target always points to a valid path
+    #    on the USB key
+    # 2) Or if we've found ourselves in a situation where there is only one
+    #    platform on the USB key, then we don't create a rollback boot entry
+    #    at all.
+    #
+    # XXX - the more likely place this could occur is after a
+    # "sdcadm platform remove" - for example, consider the case where a CN
+    # has a USB key with two platform images (A and B)
+    #
+    # CN is currently running image A.
+    # CN is then assigned image B.
+    # Image A gets set as the rollback target in the boot loder config
+    # CN reboots and is now running image B.
+    #
+    # At his point there is nothing to prevent the admin from removing image A.
+    # which would invalidate the rollback boot menu entry.  So we have some
+    # more work to do in sdcadm to fully handle these cases.
+    #
+    local rollback_vers=$current_version
+    if [[ ! -d $usbmnt/os/$rollback_vers ]]; then
+        rollback_vers=$(ls -1 $usbmnt/os | tr "[:lower:]" "[:upper:]" | \
+            grep -v $version | sort | tail -1)
+    fi
+
+    if [[ -n $rollback_vers ]]; then
+        edit_param $tmpconf prev-platform "/os/$rollback_vers/platform/$kernel"
+        edit_param $tmpconf prev-archive "/os/$rollback_vers/platform/$archive"
+        edit_param $tmpconf prev-hash \
+            "/os/$rollback_vers/platform/${archive}.hash"
+        edit_param $tmpconf prev-version "$rollback_vers"
+    fi
+
+    #
+    # If it's a dryrun, just print the new Loader configuration.  Otherwise,
+    # copy the new configuration into place.
+    #
+    if [[ -n "${dryrun}" ]]; then
+        cat $tmpconf
+    else
+        cp -f $tmpconf ${usbmnt}/boot/loader.conf
+    fi
+
+    rm -f $tmpconf
+}
+
+function config_grub
+{
+    echo "==> Creating new GRUB configuration"
+    if [[ -z "${dryrun}" ]]; then
+        rm -f ${usbmnt}/boot/grub/menu.lst
+        tomenulst=">> ${menulst}"
+    fi
+    while read input; do
+        set -- $input
+        if [[ "$1" = "#PREV" ]]; then
+            _thisversion="${current_version}"
+        else
+            _thisversion="${version}"
+        fi
+        output=$(echo "$input" | sed \
+            -e "s|/PLATFORM/|/os/${version}/platform/|" \
+            -e "s|/PREV_PLATFORM/|/os/${current_version}/platform/|" \
+            -e "s|PREV_PLATFORM_VERSION|${current_version}|" \
+            -e "s|^#PREV ||")
+        set -- $output
+        if [[ "$1" = "module" ]] && [[ "${2##*.}" = "hash" ]] && \
+            [[ ! -f "${usbcpy}/os/${_thisversion}${hashfile}" ]]; then
+            continue
+        fi
+        eval echo '${output}' "${tomenulst}"
+    done < "${menulst}.tmpl"
+}
+
+version=$1
+[[ -z ${version} ]] && usage
+
 # -U is a private option to bypass cnapi update during upgrade.
 UPGRADE=0
 while getopts "U" opt
 do
     case "$opt" in
-        U) UPGRADE=1;;
-        *) echo "invalid option"
-           exit 1
-           ;;
+        U) UPGRADE=1 ;;
+        *)
+            print -u2 "invalid option"
+            usage
+            ;;
     esac
 done
 shift $(($OPTIND - 1))
 
-version=$1
-if [[ -z ${version} ]]; then
-    echo "Usage: $0 <platform buildstamp>"
-    echo "(eg. '$0 20110318T170209Z')"
-    exit 1
-fi
+current_version=$(uname -v | cut -d '_' -f 2)
 
-if [[ -z $(mount | grep ^${usbmnt}) ]]; then
+# BEGIN BASHSTYLED
+usbmnt="/mnt/$(svcprop -p 'joyentfs/usb_mountpoint' svc:/system/filesystem/smartdc:default)"
+usbcpy="$(svcprop -p 'joyentfs/usb_copy_path' svc:/system/filesystem/smartdc:default)"
+# END BASHSTYLED
+mounted="false"
+hashfile="/platform/i86pc/amd64/boot_archive.hash"
+menulst="${usbmnt}/boot/grub/menu.lst"
+loader_conf="${usbmnt}/boot/loader.conf"
+
+mnt_status=$(/opt/smartdc/bin/sdc-usbkey status)
+[ $? != 0 ] && fatal "failed to get USB key status"
+if [[ $mnt_status = "unmounted" ]]; then
     echo "==> Mounting USB key"
-    /usbkey/scripts/mount-usb.sh
+    /opt/smartdc/bin/sdc-usbkey mount
+    [ $? != 0 ] && fatal "failed to mount USB key"
     mounted="true"
 fi
 
 trap onexit EXIT
 
-if [[ ! -d ${usbmnt}/os/${version} ]]; then
-    echo "==> FATAL ${usbmnt}/os/${version} does not exist."
-    exit 1
-fi
+[[ ! -d ${usbmnt}/os/${version} ]] && \
+    fatal "==> FATAL ${usbmnt}/os/${version} does not exist."
 
-echo "==> Creating new menu.lst"
-if [[ -z "${dryrun}" ]]; then
-    rm -f ${usbmnt}/boot/grub/menu.lst
-    tomenulst=">> ${menulst}"
-fi
-while read input; do
-    set -- $input
-    if [[ "$1" = "#PREV" ]]; then
-        _thisversion="${current_version}"
-    else
-        _thisversion="${version}"
-    fi
-    output=$(echo "$input" | sed \
-        -e "s|/PLATFORM/|/os/${version}/platform/|" \
-        -e "s|/PREV_PLATFORM/|/os/${current_version}/platform/|" \
-        -e "s|PREV_PLATFORM_VERSION|${current_version}|" \
-        -e "s|^#PREV ||")
-    set -- $output
-    if [[ "$1" = "module" ]] && [[ "${2##*.}" = "hash" ]] && \
-        [[ ! -f "${usbcpy}/os/${_thisversion}${hashfile}" ]]; then
-        continue
-    fi
-    eval echo '${output}' "${tomenulst}"
-done < "${menulst}.tmpl"
+
+readonly usb_version=$(/opt/smartdc/bin/sdc-usbkey status -j | json version)
+
+case "$usb_version" in
+    1) config_grub ;;
+    2) config_loader ;;
+    *) echo "unknown USB key version $usb_version" >&2
+       /opt/smartdc/bin/sdc-usbkey unmount
+       exit 1 ;;
+esac
 
 # If upgrading, skip cnapi update, we're done now.
 [ $UPGRADE -eq 1 ] && exit 0
@@ -115,13 +223,11 @@ load_sdc_config
 uuid=`curl -s http://${CONFIG_cnapi_admin_ips}/servers | \
     json -a headnode uuid | nawk '{if ($1 == "true") print $2}' 2>/dev/null`
 
-if [[ -z "${uuid}" ]]; then
-    echo "==> FATAL unable to determine headnode UUID from cnapi."
-    exit 1
-fi
+[[ -z "${uuid}" ]] && \
+    fatal "==> FATAL unable to determine headnode UUID from cnapi."
 
 if [[ -n "${dryrun}" ]]; then
-	doit="echo"
+    doit="echo"
 fi
 
 ${doit} curl -s http://${CONFIG_cnapi_admin_ips}/servers/${uuid} \
diff --git a/scripts/umount-image.sh b/scripts/umount-image.sh
index 35be9209..16a0fbfd 100755
--- a/scripts/umount-image.sh
+++ b/scripts/umount-image.sh
@@ -6,7 +6,7 @@
 #
 
 #
-# Copyright (c) 2015, Joyent, Inc.
+# Copyright (c) 2019, Joyent, Inc.
 #
 
 function fatal
@@ -18,7 +18,6 @@ function fatal
 current_image=$(uname -v | cut -d '_' -f2)
 mnt=/image
 # BEGIN BASHSTYLED
-usb="/mnt/$(svcprop -p 'joyentfs/usb_mountpoint' svc:/system/filesystem/smartdc:default)"
 usbcopy="$(svcprop -p 'joyentfs/usb_copy_path' svc:/system/filesystem/smartdc:default)"
 # END BASHSTYLED
 image_subdir="/os/${current_image}/platform/i86pc/amd64"
@@ -60,7 +59,7 @@ cp ${image} "${usbcopy}${image_subdir}"
 digest -a sha1 ${image} > "${image}.hash"
 cp "${image}.hash" "${usbcopy}${image_subdir}"
 
-if ! umount $usb ; then
-    fatal "could not unmount $usb"
-fi
+/opt/smartdc/bin/sdc-usbkey unmount
+[[ $? != 0 ]] && fatal "could not unmount USB key"
+
 echo "done."
diff --git a/scripts/update-usbkey.0.esp.sh b/scripts/update-usbkey.0.esp.sh
new file mode 100755
index 00000000..a137a623
--- /dev/null
+++ b/scripts/update-usbkey.0.esp.sh
@@ -0,0 +1,249 @@
+#!/usr/bin/bash
+#
+# This Source Code Form is subject to the terms of the Mozilla Public
+# License, v. 2.0. If a copy of the MPL was not distributed with this
+# file, You can obtain one at http://mozilla.org/MPL/2.0/.
+#
+# Copyright (c) 2019, Joyent, Inc.
+#
+# This script is run by sdc-usbkey update to update the copy of loader in the
+# EFI System Partition if needed.
+#
+
+#
+# We don't rely on the PI's usb-key.sh, as it may be too old.
+
+set -e
+
+readonly loader_path="/boot/loader64.efi"
+dryrun="no"
+verbose="no"
+update_esp="no"
+
+function usage()
+{
+	echo "$0 [-nv] contentsdir mountpoint" >&2
+	exit 2
+}
+
+#
+# Identify the version of this USB key (if it is indeed a USB key).
+#
+# We do this by sniffing fixed offset within the MBR. If we have a (legacy)
+# grub MBR, then we can look at offset 0x3e for COMPAT_VERSION_MAJOR and
+# COMPAT_VERSION_MINOR (and we'll presume 3.2 as a minimum).
+#
+# If we're talking about a loader-based key, we'll peek at 0xfa AKA
+# STAGE1_MBR_VERSION for format_image's IMAGE_MAJOR, which we expect to be 2.
+#
+# Unfortunately there's no standard way to find a version for other MBRs such as
+# grub2's. In these cases we'll end up with a potentially random version here,
+# so this key should not be trusted as ours until mounted and the path
+# .joyusbkey is found.
+#
+function usb_key_version()
+{
+	local readonly devpath=$1
+	local readonly mbr_sig_offset=0x1fe
+	local readonly mbr_grub_offset=0x3e
+	local readonly mbr_stage1_offset=0xfa
+	local readonly mbr_grub_version=0203
+	local readonly mbr_sig=aa55
+
+	sig=$(echo $(/usr/bin/od -t x2 \
+	    -j $mbr_sig_offset -A n -N 2 $devpath) )
+
+	if [[ "$sig" != $mbr_sig ]]; then
+		echo "unknown"
+		return
+	fi
+
+	grub_val=$(echo $(/usr/bin/od -t x2 \
+	    -j $mbr_grub_offset -A n -N 2 $devpath) )
+	loader_major=$(echo $(/usr/bin/od -t x1 \
+	    -j $mbr_stage1_offset -A n -N 1 $devpath) )
+
+	if [[ "$grub_val" = $mbr_grub_version ]]; then
+		echo "1"
+		return
+	fi
+
+	echo $(( 0x$loader_major ))
+}
+
+#
+# Mount the usbkey at the standard mount location (or whatever is specified).
+#
+function mount_usb_key()
+{
+	local mnt=$1
+
+	if [[ -z "$mnt" ]]; then
+		mnt=/mnt/$(svcprop -p "joyentfs/usb_mountpoint" \
+		    "svc:/system/filesystem/smartdc:default")
+	fi
+
+	if [[ -f "$mnt/.joyliveusb" ]]; then
+		echo $mnt
+		return 0
+	fi
+
+	if ! mkdir -p $mnt; then
+		echo "failed to mkdir $mnt" >&2
+		return 1
+	fi
+
+	readonly alldisks=$(/usr/bin/disklist -a)
+
+	for disk in $alldisks; do
+		version=$(usb_key_version "/dev/dsk/${disk}p0")
+
+		case $version in
+		1) devpath="/dev/dsk/${disk}p1" ;;
+		2) devpath="/dev/dsk/${disk}s2" ;;
+		*) continue ;;
+		esac
+
+		fstyp="$(/usr/sbin/fstyp $devpath 2>/dev/null)"
+
+		if [[ "$fstyp" != "pcfs" ]]; then
+			continue
+		fi
+
+		/usr/sbin/mount -F pcfs -o foldcase,noatime $devpath $mnt \
+		    2>/dev/null
+
+		if [[ $? -ne 0 ]]; then
+			continue
+		fi
+
+		if [[ -f $mnt/.joyliveusb ]]; then
+			echo $mnt
+			return 0
+		fi
+
+		if ! /usr/sbin/umount $mnt; then
+			echo "Failed to unmount $mnt" >&2
+			return 1
+		fi
+	done
+
+	echo "Couldn't find USB key" >&2
+	return 1
+}
+
+#
+# Mount the EFI system partition, if there is one.  Note that since we need to
+# peek at .joyliveusb to be sure, the only way to find a USB key is to mount its
+# root first...
+#
+function mount_usb_key_esp()
+{
+	local readonly rootmnt=$(mount_usb_key)
+
+	if [[ $? -ne 0 ]]; then
+		return 1
+	fi
+
+	dev=$(mount | nawk "\$0~\"^$rootmnt\" { print \$3 ; }")
+	dsk=${dev%[ps]?}
+
+	mnt=/tmp/mnt.$$
+
+	if ! mkdir -p $mnt; then
+		echo "failed to mkdir $mnt" >&2
+		return 1
+	fi
+
+	version=$(usb_key_version ${dsk}p0)
+
+	#
+	# If this key is still grub, then we don't have an ESP, but we shouldn't
+	# report an error.
+	#
+	if [[ "$version" = "1" ]]; then
+		rmdir $mnt
+		return 0
+	fi
+
+	/usr/sbin/mount -F pcfs -o foldcase,noatime ${dsk}s0 $mnt
+
+	if [[ $? -ne 0 ]]; then
+		rmdir $mnt
+		return 1
+	fi
+
+	echo $mnt
+	return 0
+}
+
+while getopts "nv" opt; do
+	case $opt in
+	n) dryrun="yes" ;;
+	v) verbose="yes" ;;
+	*) usage ;;
+	esac
+done
+
+shift $((OPTIND-1))
+contents=$1
+shift
+mountpoint=$1
+
+[[ -n "$contents" ]] || usage
+[[ -n "$mountpoint" ]] || usage
+
+old_boot_ver=$(cat $mountpoint/etc/version/boot 2>&1 || true)
+
+if [[ -z "$old_boot_ver" ]]; then
+	exit 0
+fi
+
+if cmp $mountpoint/$loader_path $contents/$loader_path 2>/dev/null; then
+	if [[ "$verbose" = "yes" ]]; then
+		echo "$loader_path is unchanged; skipping ESP update"
+	fi
+
+	exit 0
+fi
+
+if [[ "$verbose" = "yes" ]]; then
+	echo "Updating loader ESP because $loader_path changed"
+fi
+
+if [[ "$dryrun" = "yes" ]]; then
+	exit 0
+fi
+
+esp=$(mount_usb_key_esp)
+ret=$?
+
+if [[ $ret -ne 0 ]]; then
+	exit $ret
+fi
+
+#
+# An empty result means that key isn't loader-based, so there's no ESP to
+# update...
+#
+if [[ -z "$esp" ]]; then
+	if [[ "$verbose" = "yes" ]]; then
+		echo "Key is legacy type; skipping ESP update"
+	fi
+	exit 0
+fi
+
+if ! cp -f $contents/$loader_path $esp/efi/boot/bootx64.efi; then
+	echo "Failed to copy $contents/$loader_path to ESP" >&2
+	umount $esp
+	rmdir $esp
+	exit 1
+fi
+
+if ! umount $esp; then
+	echo "Failed to unmount $esp" >&2
+	exit 1
+fi
+
+rmdir $esp
+exit 0
diff --git a/scripts/update-usbkey.5.copy-contents.js b/scripts/update-usbkey.5.copy-contents.js
new file mode 100755
index 00000000..cdfb549a
--- /dev/null
+++ b/scripts/update-usbkey.5.copy-contents.js
@@ -0,0 +1,416 @@
+#!/usr/node/bin/node
+
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2019, Joyent, Inc.
+ */
+
+
+var mod_path = require('path');
+var mod_fs = require('fs');
+var mod_util = require('util');
+var mod_crypto = require('crypto');
+
+var mod_assert = require('assert-plus');
+var mod_getopt = require('posix-getopt');
+var mod_vasync = require('vasync');
+var mod_verror = require('verror');
+
+/*
+ * In order to cope with running this software on an unknown version of Node
+ * (at least the 0.8 and 0.10 branches have been included in various platform
+ * images), we import the external streams module:
+ */
+var mod_stream = require('readable-stream');
+
+var lib_oscmds = require('/opt/smartdc/lib/oscmds.js');
+
+var VError = mod_verror.VError;
+
+function
+wrap_stream(oldstream)
+{
+    var newstream = new mod_stream.Readable();
+
+    return (newstream.wrap(oldstream));
+}
+
+function
+shasum_file(path, callback)
+{
+    mod_assert.string(path, 'path');
+    mod_assert.func(callback, 'callback');
+
+    var sum = mod_crypto.createHash('sha1');
+
+    /*
+     * So that we may use the 'readable' event, and the read() method, we wrap
+     * the file stream in the external streams module:
+     */
+    var fstr = wrap_stream(mod_fs.createReadStream(path));
+    fstr.on('error', function (err) {
+        callback(new VError(err, 'could not shasum file "%s"', path));
+        return;
+    });
+    fstr.on('readable', function () {
+        for (;;) {
+            var d = fstr.read();
+            if (!d)
+                return;
+            sum.update(d);
+        }
+    });
+    fstr.on('end', function () {
+        callback(null, sum.digest('hex'));
+    });
+}
+
+function
+lstat(path)
+{
+    var st;
+
+    try {
+        st = mod_fs.lstatSync(path);
+    } catch (ex) {
+        if (ex.code === 'ENOENT') {
+            return (null);
+        }
+
+        throw (ex);
+    }
+
+    mod_assert.object(st, 'st');
+
+    if (st.isFile()) {
+        st.type = 'file';
+    } else if (st.isDirectory()) {
+        st.type = 'dir';
+    } else if (st.isBlockDevice()) {
+        st.type = 'block';
+    } else if (st.isCharacterDevice()) {
+        st.type = 'char';
+    } else if (st.isSymbolicLink()) {
+        st.type = 'link';
+    } else if (st.isFIFO()) {
+        st.type = 'fifo';
+    } else if (st.isSocket()) {
+        st.type = 'socket';
+    } else {
+        st.type = 'unknown';
+    }
+
+    return (st);
+}
+
+function
+safe_copy(src, dst, callback)
+{
+    mod_assert.string(src, 'src');
+    mod_assert.string(dst, 'dst');
+    mod_assert.func(callback, 'callback');
+
+    var tmpn = '.tmp.' + process.pid + '.' + mod_path.basename(dst);
+    var tmpf = mod_path.join(mod_path.dirname(dst), tmpn);
+
+    /*
+     * So that we may get modern pipe() behaviour, we wrap the source stream in
+     * the external streams module:
+     */
+    var fin = wrap_stream(mod_fs.createReadStream(src, {
+        flags: 'r',
+        encoding: null
+    }));
+    var fout = mod_fs.createWriteStream(tmpf, {
+        flags: 'wx',
+        encoding: null
+    });
+
+    var cb_fired = false;
+    var cb = function (err) {
+        fout.removeAllListeners();
+        fin.removeAllListeners();
+
+        mod_assert.ok(!cb_fired, 'cb fired twice');
+        cb_fired = true;
+        callback(err);
+    };
+
+    fin.on('error', function (err) {
+        cb(new VError(err, 'safe_copy src file "%s" error', src));
+    });
+    fout.on('error', function (err) {
+        cb(new VError(err, 'safe_copy dst file "%s" error', tmpf));
+    });
+
+    /*
+     * We should be using the 'finish' event here, but apparently that did
+     * not exist in node version prior to 0.10 -- instead, we will use
+     * the 'close' event.
+     */
+    fout.on('close', function () {
+        mod_fs.rename(tmpf, dst, function (err) {
+            if (err) {
+                cb(new VError(err, 'could not rename tmp file "%s" to ' +
+                  'dst "%s"', tmpf, dst));
+                return;
+            }
+
+            cb();
+        });
+    });
+
+    fin.pipe(fout);
+}
+
+function
+do_copy(opts, callback)
+{
+    mod_assert.object(opts, 'opts');
+    mod_assert.string(opts.src, 'src');
+    mod_assert.string(opts.dst, 'dst');
+    mod_assert.bool(opts.dryrun, 'dryrun');
+    mod_assert.bool(opts.verbose, 'verbose');
+    mod_assert.func(callback, 'callback');
+
+    if (opts.dryrun)
+        opts.verbose = true;
+
+    var top = mod_path.resolve(opts.src);
+    var topd = mod_path.resolve(opts.dst);
+
+    var dir_check = function (path) {
+        var st = lstat(path);
+        if (!st) {
+            callback(new VError('directory "%s" does not exist', path));
+            return (false);
+        } else if (st.type !== 'dir') {
+            callback(new VError('path "%s" should be a directory, but is "%s"',
+              path, st.type));
+            return (false);
+        }
+        return (true);
+    };
+
+    if (!dir_check(top) || !dir_check(topd)) {
+        return;
+    }
+
+    var dirs = [ '' ];
+
+    var process_file = function (relp, next) {
+        var srcf = mod_path.join(top, relp);
+        var dstf = mod_path.join(topd, relp);
+
+        shasum_file(srcf, function (err, sum) {
+            if (err) {
+                next(err);
+                return;
+            }
+
+            var std = lstat(dstf);
+            if (!std) {
+                /*
+                 * The file does not exist.  Copy the source file.
+                 */
+
+                if (opts.verbose) {
+                    console.log('create file "%s"', relp);
+                    console.log('\tnew shasum: %s', sum);
+                }
+
+                if (opts.dryrun) {
+                    next();
+                    return;
+                }
+
+                safe_copy(srcf, dstf, next);
+                return;
+            }
+
+            if (std.type !== 'file') {
+                next(new VError('path "%s" exists, but is of type "%s", not' +
+                  ' file', dstf, std.type));
+                return;
+            }
+
+            shasum_file(dstf, function (_err, dstsum) {
+                if (_err) {
+                    next(_err);
+                    return;
+                }
+
+                if (sum === dstsum) {
+                    /*
+                     * The destination and source file match.  No action is
+                     * required.
+                     */
+                    next();
+                    return;
+                }
+
+                if (opts.verbose) {
+                    console.log('update file "%s"', relp);
+                    console.log('\told shasum: %s', dstsum);
+                    console.log('\tnew shasum: %s', sum);
+                }
+
+                if (opts.dryrun) {
+                    next();
+                    return;
+                }
+
+                safe_copy(srcf, dstf, next);
+            });
+
+        });
+    };
+
+    var walk_dirs = function () {
+        if (dirs.length === 0) {
+            callback(null);
+            return;
+        }
+
+        var dir = dirs.shift();
+
+        /*
+         * If dir is the empty string, we are enumerating the top-level
+         * directory; i.e. the USB key mountpoint itself.  Otherwise, this is a
+         * subdirectory that may need to be created.
+         */
+        if (dir) {
+            var dstdir = mod_path.resolve(mod_path.join(topd, dir));
+            var ddst = lstat(dstdir);
+
+            if (!ddst) {
+                /*
+                 * The target directory does not exist.  We must create it.
+                 */
+
+                if (opts.verbose) {
+                    console.log('mkdir "%s"', dir);
+                }
+
+                if (!opts.dryrun) {
+                    try {
+                        mod_fs.mkdirSync(dstdir, parseInt('0755', 8));
+                    } catch (ex) {
+                        callback(new VError(ex, 'failed to mkdir "%s"',
+                          dstdir));
+                        return;
+                    }
+                }
+            }
+        }
+
+        /*
+         * Walk each entry in the current source directory:
+         */
+        var ents = mod_fs.readdirSync(mod_path.join(top, dir));
+        var files = [];
+        for (var i = 0; i < ents.length; i++) {
+            var ent = ents[i];
+            var relp = mod_path.join(dir, ent);
+            var srcp = mod_path.join(top, relp);
+            var st = lstat(srcp);
+
+            switch (st.type) {
+            case 'dir':
+                dirs.push(relp);
+                break;
+
+            case 'file':
+                files.push(relp);
+                break;
+
+            default:
+                callback(new VError('source file "%s" is of unsupported type' +
+                  ' "%s"', srcp, st.type));
+                return;
+            }
+        }
+
+        mod_vasync.forEachPipeline({
+            inputs: files,
+            func: process_file
+        }, function (err) {
+            if (err) {
+                callback(err);
+                return;
+            }
+
+            setImmediate(walk_dirs);
+        });
+    };
+
+    walk_dirs();
+}
+
+if (require.main === module) {
+    var parser = new mod_getopt.BasicParser('nv', process.argv);
+
+    var dryrun = false;
+    var verbose = false;
+    var option;
+
+    while ((option = parser.getopt()) !== undefined) {
+        switch (option.option) {
+            case 'n':
+               dryrun = true;
+               break;
+
+           case 'v':
+               verbose = true;
+               break;
+
+           default:
+               mod_assert.equal('?', option.option);
+               process.exit(2);
+               break;
+        }
+    }
+
+    if (parser.optind() + 2 != process.argv.length) {
+        console.log('missing arguments');
+        process.exit(2);
+    }
+
+    var contents = process.argv[parser.optind()];
+    var mountpoint = process.argv[parser.optind() + 1];
+
+    do_copy({
+        src: contents,
+        dst: mountpoint,
+        verbose: verbose,
+        dryrun: dryrun
+    }, function (err) {
+        if (err) {
+            console.log(err.message);
+            process.exit(1);
+            return;
+        }
+
+        /*
+         * Give pcfs(7FS) and the USB key a few seconds to
+         * settle while we knock on wood after the sync.
+         */
+        if (!dryrun) {
+            lib_oscmds.sync(function () {
+                setTimeout(function () {
+                   process.exit(0);
+                }, 5000);
+            });
+            return;
+        }
+
+        process.exit(0);
+    });
+}
+
+/* vim: set ts=4 sts=4 sw=4 et: */
diff --git a/tools/bin/sdc-image-sync b/tools/bin/sdc-image-sync
index c55b3a62..b3ca2ea2 100755
--- a/tools/bin/sdc-image-sync
+++ b/tools/bin/sdc-image-sync
@@ -26,7 +26,10 @@ declare -A SDC_PKGS=()
 # The cnt is the next number to use when adding a new pkg_ entry
 PKG_CNT=0
 
-load_config_pkgs()
+readonly smartdc_fmri="svc:/system/filesystem/smartdc:default"
+usbcpy=$(svcprop -p 'joyentfs/usb_copy_path' $smartdc_fmri)
+
+function load_config_pkgs()
 {
 	pkgs=`set | nawk -F= '/^CONFIG_pkg/ {print $2}'`
 	for p in $pkgs
@@ -40,17 +43,17 @@ load_config_pkgs()
 	done
 }
 
-add_pkg()
+function add_pkg()
 {
 	echo "add '$1' package for '$2' to the generic config file"
 
 	# Make sure we haven't already added it once before
-	egrep -s "^pkg_[0-9]*=${1}:" /mnt/usbkey/config.inc/generic
+	egrep -s "^pkg_[0-9]*=${1}:" $usbmnt/config.inc/generic
 	if [ $? -ne 0 ]; then
 		out=$(sdc-papi --no-headers /packages?name=$pnm | \
   json -a -d: name max_physical_memory max_swap quota cpu_cap max_lwps \
   zfs_io_priority uuid)
-  printf "pkg_%d=%s" $PKG_CNT $out >> /mnt/usbkey/config.inc/generic
+  printf "pkg_%d=%s" $PKG_CNT $out >> $usbmnt/config.inc/generic
 
 	    # Just added an entry, so increment the cnt
 	    PKG_CNT=$((PKG_CNT + 1))
@@ -62,11 +65,11 @@ add_pkg()
 		printf("%s=%s\n", $1, val)
 	    else
 		print $0
-        }' /mnt/usbkey/config.inc/generic >/mnt/usbkey/config.inc/generic.new
-	mv /mnt/usbkey/config.inc/generic.new /mnt/usbkey/config.inc/generic
+        }' $usbmnt/config.inc/generic > $usbmnt/config.inc/generic.new
+	mv $usbmnt/config.inc/generic.new $usbmnt /config.inc/generic
 }
 
-update_sdc_zone_pkgs()
+function update_sdc_zone_pkgs()
 {
 	[[ -z ${CONFIG_vmapi_domain} ]] && return
 
@@ -86,7 +89,7 @@ update_sdc_zone_pkgs()
 	    done
 }
 
-save_root_password() {
+function save_root_password() {
     enc_password=`nawk -F: '{if ($1 == "root") print $2}' /etc/shadow`
 
     # First check if it has changed
@@ -95,8 +98,8 @@ save_root_password() {
     echo "Updating root password in the config file"
 
     sed -e "s|^root_shadow=.*$|root_shadow='${enc_password}'|" \
-      /mnt/usbkey/config > /mnt/usbkey/config.new \
-      && mv /mnt/usbkey/config.new /mnt/usbkey/config
+      $usbmt/config > $usbmnt/config.new \
+      && mv $usbmnt/config.new $usbmnt/config
 }
 
 #
@@ -104,7 +107,7 @@ save_root_password() {
 #
 [[ `sysinfo | json '["Boot Parameters"].headnode'` != "true" ]] && exit 0
 
-/usbkey/scripts/mount-usb.sh >/dev/null 2>&1
+usbmnt=$(sdc-usbkey mount)
 if [ $? != 0 ]; then
 	echo "Error: unable to mount the USB stick"
 	exit 1
@@ -126,26 +129,9 @@ load_config_pkgs
 update_sdc_zone_pkgs
 
 # update the cached copy so compute nodes get the same data
-cp -p /mnt/usbkey/config /usbkey/config
-cp -p /mnt/usbkey/config.inc/generic /usbkey/config.inc/generic
-
-umount /mnt/usbkey
+cp -p $usbmnt/config $usbcpy/config
+cp -p $usbmnt/config.inc/generic $usbcpy/config.inc/generic
 
-#
-# If we want to save updates to other files on the image, uncomment the
-# following block and add the copy code in the middle.  Right now we don't
-# have anything to copy.
-#
-
-#/usbkey/scripts/mount-image.sh >/dev/null 2>&1
-#if [ $? != 0 ]; then
-#	echo "Error: unable to mount the image"
-#	exit 1
-#fi
-#
-# example:
-# cp -pr /etc/user_attr /image/etc/user_attr
-#
-#/usbkey/scripts/umount-image.sh
+sdc-usbkey unmount
 
 exit 0
diff --git a/tools/bin/sdc-restore b/tools/bin/sdc-restore
index 4fe245a6..ad6bf3fc 100755
--- a/tools/bin/sdc-restore
+++ b/tools/bin/sdc-restore
@@ -435,7 +435,7 @@ mount_usbkey()
     # check if usb key already mounted, Note: ${mounted} is a global we check
     # at unmount as well.
     mounted=`mount -p | nawk '{if ($3 == "/mnt/usbkey") print $3}'`
-    [[ -z "$mounted" ]] && (/usbkey/scripts/mount-usb.sh || \
+    [[ -z "$mounted" ]] && (/opt/smartdc/bin/sdc-usbkey mount >/dev/null || \
         fatal "unable to mount USB key, all zones will remain shutdown")
 }
 
@@ -766,7 +766,7 @@ restore_usb()
     printf "%-80s\n" "waited 10 seconds, now proceeding."
 
     mounted=`mount -p | nawk '{if ($3 == "/mnt/usbkey") print $3}'`
-    [[ -z "$mounted" ]] && (/usbkey/scripts/mount-usb.sh || \
+    [[ -z "$mounted" ]] && (/opt/smartdc/bin/sdc-usbkey mount || \
         fatal "unable to mount USB key")
 
     BDISK=`mount -p | nawk '{
diff --git a/tools/bin/sdc-sbcreate b/tools/bin/sdc-sbcreate
index c4ee5733..e956179c 100755
--- a/tools/bin/sdc-sbcreate
+++ b/tools/bin/sdc-sbcreate
@@ -6,7 +6,7 @@
 #
 
 #
-# Copyright (c) 2014, Joyent, Inc.
+# Copyright (c) 2018, Joyent, Inc.
 #
 
 #
@@ -379,9 +379,10 @@ function grab_platform_md5
 
     echo "  > kernel & platform integrity hash"
     sum -R -x md5 /usbkey/os > ${TEMPDIR}/platforms_cache.md5
-    /usbkey/scripts/mount-usb.sh
-    sum -R -x md5 /mnt/usbkey/os > ${TEMPDIR}/platforms_bootable.md5
-    umount /mnt/usbkey
+    usbmnt=$(sdc-usbkey mount)
+    [ $? != 0 ] && return
+    sum -R -x md5 $usbmnt/os > ${TEMPDIR}/platforms_bootable.md5
+    sdc-usbkey unmount
 }
 
 function grab_rabbitmq_info
diff --git a/tools/bin/sdc-setconsole b/tools/bin/sdc-setconsole
index f8eebf2a..f7976894 100755
--- a/tools/bin/sdc-setconsole
+++ b/tools/bin/sdc-setconsole
@@ -6,76 +6,7 @@
 #
 
 #
-# Copyright (c) 2015, Joyent, Inc.
+# Copyright (c) 2018, Joyent, Inc.
 #
 
-#
-# Usage:
-#
-#  sdc-setconsole <console>
-#
-
-mntsvc="svc:/system/filesystem/smartdc:default"
-usbmnt="/mnt/$(svcprop -p 'joyentfs/usb_mountpoint' ${mntsvc})"
-usbcp="$(svcprop -p 'joyentfs/usb_copy_path' ${mntsvc})"
-menu="${usbmnt}/boot/grub/menu.lst"
-menutmpl="${menu}.tmpl"
-
-function usage
-{
-    cat <<USAGE
-Usage: $0 [ttya|ttyb|ttyc|ttyd|text]
-
-Example:
-
-    $0 ttyb
-
-USAGE
-
-    exit 1
-}
-
-function fatal
-{
-    echo "`basename $0`: $*" >&2 
-    exit 1
-}
-
-if [[ -z "$1" ]]; then
-    usage
-fi
-
-console=$1
-
-case "${console}" in
-ttya|ttyb|ttyc|ttyd|text)
-    ;;
-graphics|vga)
-    console=text
-    ;;
-*)
-    usage
-    ;;
-esac
-
-if [[ ! -d $usbmnt ]]; then
-    mkdir $usbmnt || fatal "could not make $usbmnt"
-fi
-
-mount | grep "^${usbmnt}" >/dev/null 2>&1 || bash $usbcp/scripts/mount-usb.sh
-mount | grep "^${usbmnt}" >/dev/null 2>&1 || fatal "${usbmnt} is not mounted"
-
-echo -n "Setting default OS console to ${console} ... "
-sed -e "s/^variable os_console.*/variable os_console ${console}/" \
-    < ${menu} > /tmp/menu.lst.$$
-mv -f /tmp/menu.lst.$$ ${menu}
-sed -e "s/^variable os_console.*/variable os_console ${console}/" \
-    < ${menutmpl} > /tmp/menu.lst.tmpl.$$
-mv -f /tmp/menu.lst.tmpl.$$ ${menutmpl}
-echo "done."
-
-echo -n "Unmounting USB key ... "
-umount "${usbmnt}"
-echo "done."
-
-exit 0
+exec /opt/smartdc/bin/sdc-usbkey set-variable os_console "$@"
diff --git a/tools/bin/sdc-ufds-m2s b/tools/bin/sdc-ufds-m2s
index 52d8105c..5959f575 100755
--- a/tools/bin/sdc-ufds-m2s
+++ b/tools/bin/sdc-ufds-m2s
@@ -332,7 +332,7 @@ zlogin $ufds_uuid "/opt/smartdc/ufds/bin/ufds-reconcile-data"
 echo "Updating config files"
 
 # fix usbkey config
-/usbkey/scripts/mount-usb.sh >/dev/null 2>&1
+/opt/smartdc/bin/sdc-usbkey mount >/dev/null
 if [ $? != 0 ]; then
     echo "Error: unable to mount the USB stick"
     exit 1
diff --git a/tools/bin/sdc-usbkey b/tools/bin/sdc-usbkey
index 753a4132..39eb97f1 100755
--- a/tools/bin/sdc-usbkey
+++ b/tools/bin/sdc-usbkey
@@ -3,4 +3,4 @@
 dir=$(dirname $(whence $0))
 cmd=$(basename $0)
 
-/usr/node/bin/node "${dir}/../cmd/${cmd}.js" "$@"
+/usr/node/bin/node --abort-on-uncaught-exception "${dir}/../cmd/${cmd}.js" "$@"
diff --git a/tools/cmd/sdc-usbkey.js b/tools/cmd/sdc-usbkey.js
index bb174121..a80d80e0 100644
--- a/tools/cmd/sdc-usbkey.js
+++ b/tools/cmd/sdc-usbkey.js
@@ -5,27 +5,20 @@
  */
 
 /*
- * Copyright (c) 2017, Joyent, Inc.
+ * Copyright (c) 2018, Joyent, Inc.
  */
 
 
-var mod_path = require('path');
 var mod_fs = require('fs');
 var mod_util = require('util');
-var mod_crypto = require('crypto');
 
 var mod_assert = require('assert-plus');
 var mod_cmdln = require('cmdln');
+var mod_forkexec = require('forkexec');
+var mod_glob = require('glob');
 var mod_vasync = require('vasync');
 var mod_verror = require('verror');
 
-/*
- * In order to cope with running this software on an unknown version of Node
- * (at least the 0.8 and 0.10 branches have been included in various platform
- * images), we import the external streams module:
- */
-var mod_stream = require('readable-stream');
-
 var lib_oscmds = require('../lib/oscmds');
 var lib_usbkey = require('../lib/usbkey');
 
@@ -36,15 +29,8 @@ var SECONDS = 1000;
 var TIMEOUT_MOUNT = 90 * SECONDS;
 var TIMEOUT_UNMOUNT = 45 * SECONDS;
 
-var UPDATE_FILE_SOURCE = '/opt/smartdc/share/usbkey';
-
-function
-wrap_stream(oldstream)
-{
-    var newstream = new mod_stream.Readable();
-
-    return (newstream.wrap(oldstream));
-}
+var USBKEY_DIR = '/opt/smartdc/share/usbkey/';
+var CONTENTS_DIR = USBKEY_DIR + 'contents/';
 
 function
 Usbkey()
@@ -77,6 +63,8 @@ init(opts, args, callback)
 {
     var self = this;
 
+    self.verbose = opts.verbose;
+
     if (opts.verbose) {
         /*
          * We set DEBUG in our "environment" so that dprintf() can find it.
@@ -85,7 +73,7 @@ init(opts, args, callback)
         process.env.DEBUG = 'yes';
     }
 
-    lib_oscmds.zonename(function (err, zonename) {
+    lib_oscmds.zonename(function set_uk_ngz(err, zonename) {
         if (!err && zonename !== 'global') {
             self.uk_ngz = true;
         }
@@ -231,7 +219,7 @@ do_status(subcmd, opts, args, callback)
         return;
     }
 
-    lib_usbkey.get_usbkey_mount_status(null, function (err, status) {
+    lib_usbkey.get_usbkey_mount_status(null, function log_status(err, status) {
         if (err) {
             callback(err);
             return;
@@ -283,36 +271,6 @@ Usbkey.prototype.do_status.help = [
     '{{options}}'
 ].join('\n');
 
-function
-shasum_file(path, callback)
-{
-    mod_assert.string(path, 'path');
-    mod_assert.func(callback, 'callback');
-
-    var sum = mod_crypto.createHash('sha1');
-
-    /*
-     * So that we may use the 'readable' event, and the read() method, we wrap
-     * the file stream in the external streams module:
-     */
-    var fstr = wrap_stream(mod_fs.createReadStream(path));
-    fstr.on('error', function (err) {
-        callback(new VError(err, 'could not shasum file "%s"', path));
-        return;
-    });
-    fstr.on('readable', function () {
-        for (;;) {
-            var d = fstr.read();
-            if (!d)
-                return;
-            sum.update(d);
-        }
-    });
-    fstr.on('end', function () {
-        callback(null, sum.digest('hex'));
-    });
-}
-
 function
 lstat(path)
 {
@@ -351,79 +309,15 @@ lstat(path)
     return (st);
 }
 
-function
-safe_copy(src, dst, callback)
-{
-    mod_assert.string(src, 'src');
-    mod_assert.string(dst, 'dst');
-    mod_assert.func(callback, 'callback');
-
-    var tmpn = '.tmp.' + process.pid + '.' + mod_path.basename(dst);
-    var tmpf = mod_path.join(mod_path.dirname(dst), tmpn);
-
-    /*
-     * So that we may get modern pipe() behaviour, we wrap the source stream in
-     * the external streams module:
-     */
-    var fin = wrap_stream(mod_fs.createReadStream(src, {
-        flags: 'r',
-        encoding: null
-    }));
-    var fout = mod_fs.createWriteStream(tmpf, {
-        flags: 'wx',
-        encoding: null
-    });
-
-    var cb_fired = false;
-    var cb = function (err) {
-        fout.removeAllListeners();
-        fin.removeAllListeners();
-
-        mod_assert.ok(!cb_fired, 'cb fired twice');
-        cb_fired = true;
-        callback(err);
-    };
-
-    fin.on('error', function (err) {
-        cb(new VError(err, 'safe_copy src file "%s" error', src));
-    });
-    fout.on('error', function (err) {
-        cb(new VError(err, 'safe_copy dst file "%s" error', tmpf));
-    });
-
-    /*
-     * We should be using the 'finish' event here, but apparently that did
-     * not exist in node version prior to 0.10 -- instead, we will use
-     * the 'close' event.
-     */
-    fout.on('close', function () {
-        mod_fs.rename(tmpf, dst, function (err) {
-            if (err) {
-                cb(new VError(err, 'could not rename tmp file "%s" to ' +
-                  'dst "%s"', tmpf, dst));
-                return;
-            }
-
-            cb();
-        });
-    });
-
-    fin.pipe(fout);
-}
-
 function
 run_update(opts, callback)
 {
     mod_assert.object(opts, 'opts');
-    mod_assert.string(opts.src, 'src');
-    mod_assert.string(opts.dst, 'dst');
+    mod_assert.string(opts.mountpoint, 'mountpoint');
     mod_assert.bool(opts.dryrun, 'dryrun');
-    mod_assert.bool(opts.progress, 'progress');
+    mod_assert.bool(opts.verbose, 'verbose');
     mod_assert.func(callback, 'callback');
 
-    var top = mod_path.resolve(opts.src);
-    var topd = mod_path.resolve(opts.dst);
-
     var dir_check = function (path) {
         var st = lstat(path);
         if (!st) {
@@ -437,191 +331,52 @@ run_update(opts, callback)
         return (true);
     };
 
-    if (!dir_check(top) || !dir_check(topd)) {
+    if (!dir_check(opts.mountpoint)) {
         return;
     }
 
-    var actions = [];
-    var dirs = [ '' ];
-
-    var process_file = function (relp, next) {
-        var srcf = mod_path.join(top, relp);
-        var dstf = mod_path.join(topd, relp);
-
-        shasum_file(srcf, function (err, sum) {
-            if (err) {
-                next(err);
-                return;
-            }
-
-            var std = lstat(dstf);
-            if (!std) {
-                /*
-                 * The file does not exist.  Copy the source file.
-                 */
-                actions.push({
-                    a_type: 'CREATE_FILE',
-                    a_relpath: relp,
-                    a_src: {
-                        path: srcf,
-                        shasum: sum
-                    },
-                    a_dst: {
-                        path: dstf
-                    }
-                });
+    var args = [];
+    if (opts.dryrun) {
+        args.push('-n');
+    }
 
-                if (opts.progress) {
-                    console.log('create file "%s"', relp);
-                    console.log('\tnew shasum: %s', sum);
-                }
+    if (opts.verbose) {
+        args.push('-v');
+    }
 
-                if (opts.dryrun) {
-                    next();
-                    return;
-                }
+    args.push(CONTENTS_DIR);
+    args.push(opts.mountpoint);
 
-                safe_copy(srcf, dstf, next);
-                return;
-            }
+    mod_vasync.forEachPipeline({
+        func: function run_update_script(script, callback) {
+            var argv = [ script ].concat(args);
 
-            if (std.type !== 'file') {
-                next(new VError('path "%s" exists, but is of type "%s", not' +
-                  ' file', dstf, std.type));
-                return;
+            if (opts.verbose) {
+                console.log('Executing ' + argv.join(' '));
             }
 
-            shasum_file(dstf, function (_err, dstsum) {
-                if (_err) {
-                    next(_err);
-                    return;
-                }
-
-                if (sum === dstsum) {
-                    /*
-                     * The destination and source file match.  No action is
-                     * required.
-                     */
-                    next();
-                    return;
-                }
-
-                actions.push({
-                    a_type: 'UPDATE_FILE',
-                    a_relpath: relp,
-                    a_src: {
-                        path: srcf,
-                        shasum: sum
-                    },
-                    a_dst: {
-                        path: dstf,
-                        shasum: dstsum
-                    }
-                });
-
-                if (opts.progress) {
-                    console.log('update file "%s"', relp);
-                    console.log('\told shasum: %s', dstsum);
-                    console.log('\tnew shasum: %s', sum);
+            mod_forkexec.forkExecWait({
+                'argv': argv,
+                'includeStderr': true
+            }, function (err, info) {
+                if (err) {
+                   callback(err);
+                   return;
                 }
 
-                if (opts.dryrun) {
-                    next();
-                    return;
-                }
-
-                safe_copy(srcf, dstf, next);
+                console.log(info.stdout);
+                callback();
             });
-
-        });
-    };
-
-    var walk_dirs = function () {
-        if (dirs.length === 0) {
-            callback(null, actions);
+        },
+        inputs: mod_glob.sync(USBKEY_DIR + '/update-usbkey.*')
+    }, function (err) {
+        if (err) {
+            callback(err);
             return;
         }
 
-        var dir = dirs.shift();
-
-        /*
-         * If dir is the empty string, we are enumerating the top-level
-         * directory; i.e. the USB key mountpoint itself.  Otherwise, this is a
-         * subdirectory that may need to be created.
-         */
-        if (dir) {
-            var dstdir = mod_path.resolve(mod_path.join(topd, dir));
-            var ddst = lstat(dstdir);
-
-            if (!ddst) {
-                /*
-                 * The target directory does not exist.  We must create it.
-                 */
-                actions.push({
-                    a_type: 'CREATE_DIRECTORY',
-                    a_relpath: dir,
-                    a_dst: {
-                        path: dstdir
-                    }
-                });
-
-                if (opts.progress) {
-                    console.log('mkdir "%s"', dir);
-                }
-
-                if (!opts.dryrun) {
-                    try {
-                        mod_fs.mkdirSync(dstdir, parseInt('0755', 8));
-                    } catch (ex) {
-                        callback(new VError(ex, 'failed to mkdir "%s"',
-                          dstdir));
-                        return;
-                    }
-                }
-            }
-        }
-
-        /*
-         * Walk each entry in the current source directory:
-         */
-        var ents = mod_fs.readdirSync(mod_path.join(top, dir));
-        var files = [];
-        for (var i = 0; i < ents.length; i++) {
-            var ent = ents[i];
-            var relp = mod_path.join(dir, ent);
-            var srcp = mod_path.join(top, relp);
-            var st = lstat(srcp);
-
-            switch (st.type) {
-            case 'dir':
-                dirs.push(relp);
-                break;
-
-            case 'file':
-                files.push(relp);
-                break;
-
-            default:
-                callback(new VError('source file "%s" is of unsupported type' +
-                  ' "%s"', srcp, st.type));
-                return;
-            }
-        }
-
-        mod_vasync.forEachPipeline({
-            inputs: files,
-            func: process_file
-        }, function (err) {
-            if (err) {
-                callback(err);
-                return;
-            }
-
-            setImmediate(walk_dirs);
-        });
-    };
-
-    walk_dirs();
+        callback();
+    });
 }
 
 /*
@@ -641,28 +396,26 @@ do_update(subcmd, opts, args, callback)
         return;
     }
 
+    opts.verbose = Boolean(self.verbose);
+
     if (!opts.hasOwnProperty('dryrun')) {
         opts.dryrun = false;
     }
-    if (!opts.hasOwnProperty('json')) {
-        opts.json = false;
-    }
     if (!opts.hasOwnProperty('ignore_missing')) {
         opts.ignore_missing = false;
     }
 
     mod_assert.bool(opts.dryrun, 'opts.dryrun');
-    mod_assert.bool(opts.json, 'opts.json');
+    mod_assert.bool(opts.verbose, 'opts.verbose');
     mod_assert.bool(opts.ignore_missing, 'opts.ignore_missing');
 
     var cancel = false;
     var already_mounted = false;
-    var actions;
     var mountpoint;
 
     mod_vasync.pipeline({
         funcs: [
-            function (_, next) {
+            function get_usbkey_status(_, next) {
                 if (cancel) {
                     next();
                     return;
@@ -686,7 +439,7 @@ do_update(subcmd, opts, args, callback)
                     next();
                 });
             },
-            function (_, next) {
+            function mount_usbkey(_, next) {
                 if (cancel) {
                     next();
                     return;
@@ -721,7 +474,7 @@ do_update(subcmd, opts, args, callback)
                     next();
                 });
             },
-            function (_, next) {
+            function do_run_update(_, next) {
                 if (cancel) {
                     next();
                     return;
@@ -729,42 +482,20 @@ do_update(subcmd, opts, args, callback)
 
                 mod_assert.string(mountpoint, 'mountpoint');
 
-                /*
-                 * The Compute Node Tools tarball (cn_tools.tar.gz) deploys a
-                 * set of incremental updates to the USB key image.  Update
-                 * the USB key from this directory.
-                 */
                 run_update({
-                    src: UPDATE_FILE_SOURCE,
-                    dst: mountpoint,
-                    progress: !opts.json,
+                    mountpoint: mountpoint,
+                    verbose: opts.verbose,
                     dryrun: opts.dryrun
-                }, function (err, _acts) {
+                }, function (err) {
                     if (err) {
                         next(err);
                         return;
                     }
 
-                    actions = _acts;
-
-                    if (opts.dryrun || actions.length < 1) {
-                        next();
-                        return;
-                    }
-
-                    /*
-                     * Invoke sync(1M) for good measure.
-                     */
-                    lib_oscmds.sync(function () {
-                        /*
-                         * Give pcfs(7FS) and the USB key a few seconds to
-                         * settle while we knock on wood.
-                         */
-                        setTimeout(next, 5000);
-                    });
+                    next();
                 });
             },
-            function (_, next) {
+            function unmount_usbkey(_, next) {
                 if (cancel) {
                     next();
                     return;
@@ -797,10 +528,6 @@ do_update(subcmd, opts, args, callback)
             return;
         }
 
-        if (opts.json) {
-            console.log(JSON.stringify(actions));
-        }
-
         callback();
     });
 };
@@ -810,16 +537,10 @@ Usbkey.prototype.do_update.options = [
         type: 'bool',
         help: 'Print this help message.'
     },
-    {
-        names: [ 'json', 'j' ],
-        type: 'bool',
-        help: 'Emit status to stdout as a JSON object.'
-    },
     {
         names: [ 'dryrun', 'n' ],
         type: 'bool',
-        help: 'Do not copy files, just determine what action is required' +
-          ' to update the USB key.'
+        help: 'Do not modify the key, just report changes.'
     },
     {
         names: [ 'ignore-missing', 'i' ],
@@ -829,7 +550,7 @@ Usbkey.prototype.do_update.options = [
     }
 ];
 Usbkey.prototype.do_update.help = [
-    'Update the files stored on the USB key.',
+    'Update the USB key contents.',
     '',
     'Usage:',
     '     sdc-usbkey update [OPTIONS]',
@@ -837,6 +558,53 @@ Usbkey.prototype.do_update.help = [
     '{{options}}'
 ].join('\n');
 
+/*
+ * sdc-usbkey set-variable
+ */
+Usbkey.prototype.do_set_variable = function
+do_set_variable(subcmd, opts, args, callback)
+{
+    var self = this;
+
+    if (opts.help) {
+        self.do_help('help', {}, [ subcmd ], callback);
+        return;
+    }
+
+    if (args.length != 2) {
+        self.do_help('help', {}, [ subcmd ], callback);
+        return;
+    }
+
+    if (!self._global_zone_only(callback)) {
+        return;
+    }
+
+    lib_usbkey.set_variable(args[0], args[1], function (err) {
+        if (err) {
+            callback(err);
+            return;
+        }
+
+        callback();
+    });
+};
+Usbkey.prototype.do_set_variable.options = [
+    {
+        names: [ 'help', 'h', '?' ],
+        type: 'bool',
+        help: 'Print this help message.'
+    }
+];
+Usbkey.prototype.do_set_variable.help = [
+    'Set a grub/loader variable',
+    '',
+    'Usage:',
+    '     sdc-usbkey set-variable <name> <value>',
+    '',
+    '{{options}}'
+].join('\n');
+
 if (require.main === module) {
     mod_cmdln.main(Usbkey);
 }
diff --git a/tools/lib/usbkey.js b/tools/lib/usbkey.js
index fd358b54..25b186cb 100644
--- a/tools/lib/usbkey.js
+++ b/tools/lib/usbkey.js
@@ -5,10 +5,11 @@
  */
 
 /*
- * Copyright (c) 2017, Joyent, Inc.
+ * Copyright (c) 2019, Joyent, Inc.
  */
 
 var mod_fs = require('fs');
+var mod_os = require('os');
 var mod_path = require('path');
 var mod_child = require('child_process');
 
@@ -204,7 +205,7 @@ parse_mount_optstr(optstr)
 
 /*
  * The kernel makes the list of mounted filesystems available in /etc/mnttab,
- * as documnted in the manual page mnttab(4).  Attempt to locate an entry in
+ * as documented in the manual page mnttab(4).  Attempt to locate an entry in
  * this file for a given mount point.  If an entry is found, it will be
  * returned as an object; if not, Boolean(false) will be returned instead.
  */
@@ -269,12 +270,126 @@ get_mount_info(mount, callback)
     });
 }
 
+/*
+ * A recognized key will have an MBR in one of two forms: either a legacy BIOS
+ * image, with a grub-legacy version of 3.2 at 0x3e; or a loader(5)-produced MBR
+ * with a major version of 2 at offset 0xfa.
+ *
+ * The former has the root pcfs at partition 1, the latter at (GPT) partition 2.
+ * Both should have the standard MBR magic of 0xaa55.
+ */
+function
+get_usb_key_version(device, callback)
+{
+    mod_assert.string(device, 'device');
+    mod_assert.func(callback, 'callback');
+
+    var COMPAT_VERSION_MAJOR = 3;
+    var COMPAT_VERSION_MINOR = 2;
+    var IMAGE_MAJOR = 2;
+
+    var p0dev = device.replace(/[sp][0-9]+$/, 'p0');
+
+    mod_fs.open(p0dev, 'r', function read_mbr(err, fd) {
+        if (err) {
+            callback(null, err);
+            return;
+        }
+
+        var buffer = new Buffer(512);
+
+        mod_fs.read(fd, buffer, 0, buffer.length, 0,
+          function inspect_mbr(err, nr_read, buffer) {
+            if (err) {
+                mod_fs.close(fd, function () {
+                    callback();
+                });
+                return;
+            }
+
+            if ((buffer[0x1fe] | buffer[0x1ff] << 8) !== 0xaa55) {
+                mod_fs.close(fd, function () {
+                    callback();
+                });
+                return;
+            }
+
+            var version = null;
+
+            if (buffer[0x3e] === COMPAT_VERSION_MAJOR &&
+                buffer[0x3f] === COMPAT_VERSION_MINOR) {
+                version = 1;
+            } else if (buffer[0xfa] === IMAGE_MAJOR) {
+                version = 2;
+            }
+
+            mod_fs.close(fd, function () {
+                if (version === null) {
+                    callback(null,
+                        new VError('unrecognised key version for ' + device));
+                    return;
+                }
+
+                callback(version);
+            });
+        });
+    });
+}
+
+/*
+ * Figure out if the given disk is potentially the USB key we're looking for.
+ * It should have a recognised version.
+ *
+ * As this is all we have to go on, we'll later make sure it really is a USB key
+ * via check_for_marker_file().
+ */
+function
+inspect_device(pcfs_devices, disk, callback)
+{
+    mod_assert.string(disk, 'disk');
+    mod_assert.func(callback, 'callback');
+
+    get_usb_key_version('/dev/dsk/' + disk + 'p0',
+        function check_fstyp(version, err) {
+        if (err) {
+            callback();
+            return;
+        }
+
+        var part = '/dev/dsk/' + disk;
+
+        switch (version) {
+        case 1:
+            part += 'p1';
+            break;
+        case 2:
+            part += 's2';
+            break;
+        default:
+            callback();
+            return;
+        }
+
+        lib_oscmds.fstyp(part, function (err, type) {
+            if (err) {
+                callback();
+                return;
+            }
+
+            if (type === 'pcfs')
+                pcfs_devices.push(part);
+
+            callback();
+        });
+    });
+}
+
 function
 locate_pcfs_devices(callback)
 {
     mod_assert.func(callback, 'callback');
 
-    lib_oscmds.diskinfo(function (err, disks) {
+    lib_oscmds.diskinfo(function inspect_devices(err, disks) {
         if (err) {
             callback(err);
             return;
@@ -282,27 +397,10 @@ locate_pcfs_devices(callback)
 
         var pcfs_devices = [];
 
-        /*
-         * Run 'fstyp' against the first partition (p1) of each device, looking
-         * for the USB key FAT filesystem:
-         */
         mod_vasync.forEachParallel({
             inputs: disks,
-            func: function (dsk, next) {
-                var path = '/dev/dsk/' + dsk.dsk_device + 'p1';
-
-                lib_oscmds.fstyp(path, function (_err, type) {
-                    if (_err) {
-                        next(_err);
-                        return;
-                    }
-
-                    if (type === 'pcfs' && pcfs_devices.indexOf(path) === -1) {
-                        pcfs_devices.push(path);
-                    }
-
-                    next();
-                });
+            func: function (disk, next) {
+                inspect_device(pcfs_devices, disk.dsk_device, next);
             }
         }, function (_err) {
             if (_err) {
@@ -470,48 +568,57 @@ _get_mountpoint_status(status, mountpoint, exp_mount_options, callback) {
         status.device = mi.mi_special;
         status.options = mi.mi_options;
 
-        /*
-         * If `exp_mount_options` is not given, then we skip checking
-         * mount options and the marker file.
-         */
-        if (!exp_mount_options) {
-            callback();
-            return;
-        }
+        get_usb_key_version(status.device, function (version, err) {
+            if (err) {
+                callback(err);
+                return;
+            }
+
+            status.version = version;
 
-        mod_assert.strictEqual(mi.mi_mountpoint, mountpoint);
-        if (mi.mi_fstype !== 'pcfs' ||
-                !equiv_usbkey_mount_options(
-                    mi.mi_options, exp_mount_options)) {
             /*
-             * The mount does not match both the expected filesystem
-             * type and the expected mount options.
+             * If `exp_mount_options` is not given, then we skip checking
+             * mount options and the marker file.
              */
-            dprintf('"%s" is mounted, but with different options: %j\n',
-                mi.mi_mountpoint, mi.mi_options);
-            callback();
-            return;
-        }
-
-        /*
-         * The filesystem mount options are as expected.
-         */
-        status.steps.options_ok = true;
-
-        dprintf('checking marker file...\n');
-        check_for_marker_file(mi.mi_mountpoint,
-          function (markerErr, exists) {
-            if (markerErr) {
-                callback(new VError(markerErr,
-                    'failed to locate marker file'));
+            if (!exp_mount_options) {
+                callback();
                 return;
             }
 
-            if (exists) {
-                status.steps.marker_file = true;
+            mod_assert.strictEqual(mi.mi_mountpoint, mountpoint);
+            if (mi.mi_fstype !== 'pcfs' ||
+                    !equiv_usbkey_mount_options(
+                        mi.mi_options, exp_mount_options)) {
+                /*
+                 * The mount does not match both the expected filesystem
+                 * type and the expected mount options.
+                 */
+                dprintf('"%s" is mounted, but with different options: %j\n',
+                    mi.mi_mountpoint, mi.mi_options);
+                callback();
+                return;
             }
 
-            callback();
+            /*
+             * The filesystem mount options are as expected.
+             */
+            status.steps.options_ok = true;
+
+            dprintf('checking marker file...\n');
+            check_for_marker_file(mi.mi_mountpoint,
+              function (markerErr, exists) {
+                if (markerErr) {
+                    callback(new VError(markerErr,
+                        'failed to locate marker file'));
+                    return;
+                }
+
+                if (exists) {
+                    status.steps.marker_file = true;
+                }
+
+                callback();
+            });
         });
     });
 
@@ -525,6 +632,7 @@ _get_mountpoint_status(status, mountpoint, exp_mount_options, callback) {
  *  {
  *      "mountpoint": <The current mountpoint, if mounted, else `null`.>
  *      "device": <the USB device /dev/... path, if mounted>
+ *      "version": <the integer version of the key format>
  *      "options": <the mount options object, if mounted>
  *      "steps": {
  *          "mounted": <A boolean indicating if the USB key is mounted at all.>
@@ -563,6 +671,7 @@ get_usbkey_mount_status(alt_mount_options, callback)
         status: {
             mountpoint: null,
             device: null,
+            version: null,
             options: null,
             steps: {
                 mounted: false,
@@ -888,11 +997,165 @@ ensure_usbkey_mounted(options, callback)
     });
 }
 
+function
+sedfile(file, search, replace, callback)
+{
+    mod_assert.string(file, 'file');
+    mod_assert.string(search, 'search');
+    mod_assert.string(replace, 'replace');
+    mod_assert.func(callback, 'callback');
+
+    mod_fs.readFile(file, 'utf8', function (err, data) {
+        var outfile = file + '.tmp';
+        var replaced = false;
+    	var out = '';
+        var i;
+
+        if (err) {
+            callback(new VError(err, 'failed to read ' + file));
+            return;
+        }
+
+        var lines = data.replace(/\n$/, '').split(mod_os.EOL);
+
+        for (i = 0; i < lines.length; i++) {
+            var line = lines[i];
+    		out += line.replace(new RegExp(search, 'g'), function () {
+                replaced = true;
+                return replace;
+            });
+    		out += mod_os.EOL;
+        }
+
+        if (!replaced) {
+            out += replace + '\n';
+        }
+
+        mod_fs.writeFile(outfile, out, 'utf8', function (err) {
+            if (err) {
+                callback(new VError(err, 'failed to write ' + outfile));
+                return;
+            }
+
+            mod_fs.rename(outfile, file, function (err) {
+                if (err) {
+                    callback(new VError(err, 'failed to rename ' + outfile));
+                    return;
+                }
+
+                callback();
+            });
+        });
+    });
+}
+
+function
+set_variable_grub(mountpoint, name, value, callback)
+{
+    mod_assert.string(mountpoint, 'mountpoint');
+    mod_assert.string(name, 'name');
+    mod_assert.string(value, 'value');
+    mod_assert.func(callback, 'callback');
+
+    /* Special handling: ipxe for grub means changing default */
+    if (name === 'ipxe') {
+        var search = '^\\s*default\\s+.*$';
+        var replace;
+
+        if (value === 'true') {
+            replace = 'default 0';
+        } else {
+            replace = 'default 1';
+        }
+    } else if (name === 'os_console') {
+        search = '^\\s*variable\\s+os_console\\s+.*$';
+        replace = 'variable ' + name + ' ' + value;
+    } else {
+        search = '^\\s*' + name + '\\s+.*$';
+        replace = name + ' ' + value;
+    }
+
+    sedfile(mountpoint + '/boot/grub/menu.lst',
+      search, replace, function (err) {
+        if (err) {
+            callback(err);
+            return;
+        }
+
+        sedfile(mountpoint + '/boot/grub/menu.lst.tmpl',
+          search, replace, function (err) {
+            if (err) {
+                callback(err);
+                return;
+            }
+
+           callback();
+        });
+    });
+}
+
+function
+set_variable_loader(mountpoint, name, value, callback)
+{
+    mod_assert.string(mountpoint, 'mountpoint');
+    mod_assert.string(name, 'name');
+    mod_assert.string(value, 'value');
+    mod_assert.func(callback, 'callback');
+
+    var search = '^\\s*' + name + '\\s*=\\s*.*$';
+    var replace = name + '=' + value;
+
+    sedfile(mountpoint + '/boot/loader.conf', search, replace, function (err) {
+        if (err) {
+            callback(err);
+            return;
+        }
+
+        callback();
+    });
+}
+
+function
+set_variable(name, value, callback)
+{
+    mod_assert.string(name, 'name');
+    mod_assert.string(value, 'value');
+    mod_assert.func(callback, 'callback');
+
+    ensure_usbkey_mounted({}, function (err) {
+        if (err) {
+            callback(err);
+            return;
+        }
+
+        get_usbkey_mount_status({}, function (err, status) {
+            if (err) {
+                callback(err);
+                return;
+            }
+
+            switch (status.version) {
+            case 1:
+                set_variable_grub(status.mountpoint, name, value, callback);
+                return;
+            case 2:
+                set_variable_loader(status.mountpoint, name, value, callback);
+                return;
+            default:
+                callback(new VError('unknown USB key version ' +
+                    status.version));
+                return;
+            }
+        });
+    });
+}
+
 module.exports = {
     DEFAULT_MOUNTPOINT: DEFAULT_MOUNTPOINT,
     ensure_usbkey_unmounted: ensure_usbkey_unmounted,
     ensure_usbkey_mounted: ensure_usbkey_mounted,
-    get_usbkey_mount_status: get_usbkey_mount_status
+    get_usbkey_mount_status: get_usbkey_mount_status,
+    set_variable: set_variable
 };
 
 /* vim: set ts=4 sts=4 sw=4 et: */
diff --git a/tools/node_modules/cmdln/CHANGES.md b/tools/node_modules/cmdln/CHANGES.md
index a29e3949..3eb5d9ab 100644
--- a/tools/node_modules/cmdln/CHANGES.md
+++ b/tools/node_modules/cmdln/CHANGES.md
@@ -1,5 +1,107 @@
 # node-cmdln Changelog
 
+## 1.3.1
+
+- Add `helpBody` optional param to `Cmdln` constructor. This is string content
+  that will be included at the help of automatic help output.
+
+
+## 1.3.0
+
+- Add a `Cmdln.emptyLine` hook that is called when no argv is given, i.e.
+  when your command is called with no args:
+
+        $ mycmd
+
+  The default behaviour (as before) is to print help output.
+  A **change in default behaviour** is that this will now exit non-zero. If
+  you want different behaviour, then override `emptyLine()` in your Cmdln
+  subclass.
+
+- Improve the `cmdln.main` convenience function's printing of error messages.
+  An `options.showCode` has been added to allow printing error instances'
+  `code` attribute, if defined. E.g., with this usage:
+
+        cmdln.main(MyCmd, process.argv, {showCode: true});
+
+  You get this output for errors (in this example the error is an unknown
+  subcommand):
+
+        $ node mycmd.js bogus
+        mycmd bogus: error (UnknownCommand): unknown command: "bogus"
+
+
+## 1.2.2
+
+- Fix `{{name}}`-replacement in subcmd help templates: all {{name}} usages
+  are replaced. Change from using the *subcommand* name as the value of
+  `{{name}}` to the *tool name* (i.e. the top-level command name).
+
+
+## 1.2.1
+
+- Pass the `subcmd` back as the second arg in the `<cli>.main` callback. This
+  enabled the subcmd to be quoted in an error message if there was an `err`
+  returned. E.g.:
+
+        var cli = new Mo();
+        cli.main(process.argv, function (err, subcmd) {
+            if (err) {
+                var subcmdStr = subcmd ? ' ' + subcmd : '';    // <---- HERE
+                if (err.body && err.body.code) {
+                    console.error('%s%s: error (%s): %s', cli.name, subcmdStr,
+                        err.body.code, err.message);
+                } else {
+                    console.error('%s%s: error: %s', cli.name, subcmdStr,
+                        err.message);
+                }
+                if (cli.opts.verbose && err.stack) {
+                    console.error('\n' + err.stack);
+                }
+                process.exit(1);
+            } else {
+                process.exit(0);
+            }
+        });
+
+
+## 1.2.0
+
+- [Backward incompatible change] Underscores in sub-command `do_*` methods
+  are translated to hyphens for the sub-command name. This means you can
+  have sub-commands with hyphens, at the cost of not allowing underscores.
+
+  A sub-command method like this:
+
+        MyCmdln.prototype.do_foo_bar
+
+  results in a 'foo-bar' sub-command.
+
+  Shout if this breaks you. I could see about making this configurable.
+
+
+## 1.1.4
+
+- Update to [dashdash
+  1.3.2](https://github.com/trentm/node-dashdash/blob/master/CHANGES.md#132):
+  fix a subtlety with an option using all of `type: 'bool'`, `default` and
+  `env` (IOW, rare).
+
+
+## 1.1.3
+
+- Update to [dashdash
+  1.3.1](https://github.com/trentm/node-dashdash/blob/master/CHANGES.md#131):
+  fix 'env' not working for options with a 'default'.
+
+
+## 1.1.2
+
+- Update to [dashdash
+  1.3.0](https://github.com/trentm/node-dashdash/blob/master/CHANGES.md#130):
+  interp boolean envvar '0' as false
+
+
 ## 1.1.1
 
 - Update to [dashdash
diff --git a/tools/node_modules/cmdln/Makefile b/tools/node_modules/cmdln/Makefile
index 25014a47..867c284b 100644
--- a/tools/node_modules/cmdln/Makefile
+++ b/tools/node_modules/cmdln/Makefile
@@ -17,12 +17,12 @@ test: | $(NODEUNIT)
 	$(NODEUNIT) test/*.test.js
 
 .PHONY: testall
-testall: test09 test08
-.PHONY: test09
-test09:
-	@echo "# Test node 0.9.x (with node `$(NODEOPT)/node-0.9/bin/node --version`)"
-	@$(NODEOPT)/node-0.9/bin/node --version
-	PATH="$(NODEOPT)/node-0.9/bin:$(PATH)" make test
+testall: test10 test08
+.PHONY: test10
+test10:
+	@echo "# Test node 0.10.x (with node `$(NODEOPT)/node-0.10/bin/node --version`)"
+	@$(NODEOPT)/node-0.10/bin/node --version
+	PATH="$(NODEOPT)/node-0.10/bin:$(PATH)" make test
 .PHONY: test08
 test08:
 	@echo "# Test node 0.8.x (with node `$(NODEOPT)/node-0.8/bin/node --version`)"
@@ -39,8 +39,12 @@ check: check-jsstyle
 	@echo "Check ok."
 
 
+.PHONY: versioncheck
+versioncheck:
+	[[ `cat package.json | json version` == `grep '^## ' CHANGES.md | head -1 | awk '{print $$2}'` ]]
+
 .PHONY: cutarelease
-cutarelease:
+cutarelease: versioncheck
 	[[ `git status | tail -n1` == "nothing to commit (working directory clean)" ]]
 	./tools/cutarelease.py -p cmdln -f package.json
 
diff --git a/tools/node_modules/cmdln/README.md b/tools/node_modules/cmdln/README.md
index 7636267a..6d38aafe 100644
--- a/tools/node_modules/cmdln/README.md
+++ b/tools/node_modules/cmdln/README.md
@@ -59,10 +59,6 @@ With this, you get the following behaviour:
 Option processing (using [dashdash](https://github.com/trentm/node-dashdash))
 is integrated. `do_crush` above could be replaced with:
 
-    Conan.prototype.do_crush = function (subcmd, opts, args, callback) {
-        console.log('Yargh!');
-        callback();
-    };
     Conan.prototype.do_crush = function (subcmd, opts, args, callback) {
         if (opts.help) {
             this.do_help('help', {}, [subcmd], callback);
@@ -95,7 +91,7 @@ is integrated. `do_crush` above could be replaced with:
         'Crush your enemies.\n'
         + '\n'
         + 'Usage:\n'
-        + '     conan crush [OPTIONS] [ENEMIES...]\n'
+        + '     {{name}} crush [OPTIONS] [ENEMIES...]\n'
         + '\n'
         + '{{options}}'
     );
diff --git a/tools/node_modules/cmdln/TODO.txt b/tools/node_modules/cmdln/TODO.txt
index 7020c9fb..971d62fb 100644
--- a/tools/node_modules/cmdln/TODO.txt
+++ b/tools/node_modules/cmdln/TODO.txt
@@ -1,5 +1,8 @@
+- doc helpOpts, helpBody, etc.
+- tests and docs for _ -> - translation in sub-command names
 - doc `init` usage (--version example). Doc `this.opts` for global parsed
   opts.
+- doc `return callback(false)` ?
 - update README for current usage
 - make do_help optional (see helpCmd in ctor)
 - `debug: true` option to  ctor for the debug logging
diff --git a/tools/node_modules/cmdln/examples/conan.js b/tools/node_modules/cmdln/examples/conan.js
index 0e09a0cf..20d0aa4f 100644
--- a/tools/node_modules/cmdln/examples/conan.js
+++ b/tools/node_modules/cmdln/examples/conan.js
@@ -69,14 +69,14 @@ Conan.prototype.do_crush.help = (
     'Crush your enemies.\n'
     + '\n'
     + 'Usage:\n'
-    + '     conan crush [OPTIONS] [ENEMIES...]\n'
+    + '     {{name}} crush [OPTIONS] [ENEMIES...]\n'
     + '\n'
     + '{{options}}'
 );
 
 
 Conan.prototype.do_see = function (subcmd, opts, args, callback) {
-    var x = (this.opts.x ? ' Yarg!' : '');
+    var x = (this.opts.x || opts.x ? ' Yarg!' : '');
     if (args.length) {
         args.forEach(function (arg) {
             console.log('I see %s.%s', arg, x);
@@ -86,15 +86,25 @@ Conan.prototype.do_see = function (subcmd, opts, args, callback) {
     }
     callback();
 };
-Conan.prototype.do_see.help = 'See them driven before you.'
-// Explicitly empty opts to do option processing.
-Conan.prototype.do_see.options = [];
+Conan.prototype.do_see.help = (
+    'See them driven before you.\n'
+    + '\n'
+    + 'Usage:\n'
+    + '     {{name}} see [OPTIONS] [ENEMIES...]\n'
+    + '\n'
+    + '{{options}}'
+);
+Conan.prototype.do_see.options = [
+    {name: 'x', type: 'bool', help: 'Be more excited about it.'}
+];
 
 Conan.prototype.do_hear = function (subcmd, opts, args, callback) {
     console.log('I hear %s.', args.join(' '));
     callback();
 };
 Conan.prototype.do_hear.help = 'Hear the lamentation of their women.'
+// Explicitly empty opts to do option processing.
+Conan.prototype.do_hear.options = [];
 
 
 if (require.main === module) {
diff --git a/tools/node_modules/cmdln/kittehz/kittehln.jpg b/tools/node_modules/cmdln/kittehz/kittehln.jpg
new file mode 100644
index 00000000..765490d2
Binary files /dev/null and b/tools/node_modules/cmdln/kittehz/kittehln.jpg differ
diff --git a/tools/node_modules/cmdln/lib/cmdln.js b/tools/node_modules/cmdln/lib/cmdln.js
index 5a6e281a..0c267d1f 100644
--- a/tools/node_modules/cmdln/lib/cmdln.js
+++ b/tools/node_modules/cmdln/lib/cmdln.js
@@ -116,6 +116,15 @@ function UnknownCommandError(cause, command) {
 }
 util.inherits(UnknownCommandError, CmdlnError);
 
+function NoCommandError() {
+    CmdlnError.call(this, {
+        message: 'no command given',
+        code: 'NoCommand',
+        exitStatus: 1
+    });
+}
+util.inherits(NoCommandError, CmdlnError);
+
 
 
 // ---- Cmdln object
@@ -131,6 +140,8 @@ util.inherits(UnknownCommandError, CmdlnError);
  *      - @param helpOpts {Object} Help output formatting options. These
  *        are the same formatting options as for `dashdash.Parser.help`:
  *        indent, maxCol, helpCol, minHelpCol, maxHelpCol (TODO:doc).
+ *      - @param helpBody {String} Extra string content to put at the end of
+ *        help output.
  *      - @param options {Array} Custom options (in the format used by
  *        [dashdash](https://github.com/trentm/node-dashdash)). If not
  *        specified, then it defaults to a single -h/--help option.
@@ -151,11 +162,13 @@ function Cmdln(config) {
     assert.optionalString(config.desc, 'config.desc')
     assert.optionalArrayOfObject(config.options, 'config.options');
     assert.optionalObject(config.helpOpts, 'config.helpOpts')
+    assert.optionalString(config.helpBody, 'config.helpBody')
 
     this.name = config.name || this.constructor.name.toLowerCase();
     this.desc = config.desc;
     this.options = config.options || DEFAULT_OPTIONS;
     this.helpOpts = config.helpOpts || {};
+    this.helpBody = config.helpBody;
     if (!this.helpOpts.indent)
         this.helpOpts.indent = space(4);
     else if (typeof (this.helpOpts.indent) === 'number')
@@ -183,7 +196,7 @@ function Cmdln(config) {
         Object.keys(proto)
             .filter(function (funcname) { return /^do_/.test(funcname); })
             .forEach(function (funcname) {
-                var name = funcname.slice(3);
+                var name = funcname.slice(3).replace(/_/g, '-');
                 var func = proto[funcname];
                 self.subcmds[name] = func;
                 self.subcmdOrder.push(name);
@@ -203,7 +216,9 @@ function Cmdln(config) {
  * Cmdln mainline.
  *
  * @param argv {Array}
- * @param callback {Function} `function (err)`
+ * @param callback {Function} `function (err, subcmd)` where err is an
+ *      error object if there was a problem, and subcmd is the sub-command
+ *      string (if there is one, i.e. it might be undefined).
  */
 Cmdln.prototype.main = function main(argv, callback) {
     var self = this;
@@ -230,7 +245,7 @@ Cmdln.prototype.main = function main(argv, callback) {
         }
 
         if (args.length === 0) {
-            self.printHelp(function (helpErr) { callback(helpErr); });
+            self.emptyLine(callback);
             return;
         }
 
@@ -239,14 +254,29 @@ Cmdln.prototype.main = function main(argv, callback) {
         try {
             debug('-> dispatch(%j, %j)', subcmd, subcmdArgv);
             self.dispatch(subcmd, subcmdArgv,
-                function (dispErr) { callback(dispErr); });
+                function (dispErr) { callback(dispErr, subcmd); });
         } catch (ex) {
-            callback(ex);
+            callback(ex, subcmd);
         }
     });
 };
 
 
+/**
+ * Handler called for an empty line of input. By default this prints help
+ * output and returns a `NoCommandError` (exitStatus == 1).
+ *
+ * Dev Note: Equiv to python-cmdln's Cmdln.emptyline.
+ *
+ * @param callback {Function} `function (err)`
+ */
+Cmdln.prototype.emptyLine = function emptyLine(callback) {
+    this.printHelp(function (helpErr) {
+        callback(helpErr || new NoCommandError());
+    });
+};
+
+
 /**
  * Post-option processing initialization of this Cmdln instance.
  *
@@ -272,7 +302,6 @@ Cmdln.prototype.init = function init(opts, args, callback) {
 };
 
 
-
 /**
  * Print top-level tool help.
  *
@@ -325,6 +354,13 @@ Cmdln.prototype.printHelp = function printHelp(callback) {
         lines.push(line);
     });
 
+    if (this.helpBody) {
+        if (lines.slice(-1) !== '\n') {
+            lines.push('');
+        }
+        lines.push(this.helpBody);
+    }
+
     console.log(lines.join('\n'));
     callback();
 };
@@ -372,7 +408,7 @@ Cmdln.prototype.do_help = function do_help(subcmd, opts, args, callback) {
     var func = this.subcmds[name];
     if (func.help) {
         var help = func.help;
-        help = help.replace('{{name}}', name);
+        help = help.replace(/{{name}}/g, self.name);
         if (~help.indexOf('{{options}}')) {
             var parser = new dashdash.Parser({options: func.options});
             help = help.replace('{{options}}',
@@ -408,22 +444,48 @@ Cmdln.prototype.help_help = function help_help(subcmd, callback) {
  *          cmdln.main(MyTool);
  *      }
  *
+ * This does not have a callback because it calls `process.exit` (with an
+ * appropriate exit status).
+ *
  * @param cmdClass {Function} The Cmdln subclass ctor.
- * @param argv {Array} The argv to process. Optional. Default is `process.argv`.0
+ * @param argv {Array} The argv to process. Optional. Default is `process.argv`.
+ * @param options {Object}
+ *      - `showCode` {Boolean} Default false. Whether to show the error `code`
+ *        in the stderr output, if available on the error objects returned
+ *        by subcommands. E.g.:
+ *              fash: error: no command given               # showCode=false
+ *              fash: error (NoCommand): no command given   # showCode=true
+ *        See the doc on the `CmdlnError` class above for details on the `code`.
  */
-function main(cmdClass, argv) {
+function main(cmdClass, argv, options) {
     assert.func(cmdClass, 'cmdClass');
     assert.optionalArrayOfString(argv, 'argv');
-    if (!argv) argv = process.argv;
+    assert.optionalObject(options, 'options');
+    if (!options) {
+        options = {};
+    }
+    assert.optionalBool(options.showCode, 'options.showCode');
+    if (!argv) {
+        argv = process.argv;
+    }
 
+    // TODO: Should prefer passing in the cmdClass *instance* here, then can
+    // set it up.
     var cli = new cmdClass();
-    cli.main(argv, function (err) {
+    cli.main(argv, function (err, subcmd) {
         if (err) {
-            console.error('%s%s: error%s: %s',
-                cli.name,
-                (err.subcmd ? ' ' + err.subcmd : ''),
-                (false && err.code ? format(' (%s)', err.code) : ''),
-                (process.env.DEBUG ? err.stack : err.message));
+            // If the `err` has no "message" field, then this probably isn't
+            // and Error instance. Let's just not print an error message. This
+            // can happen if the subcmd passes back `true` or similar to
+            // indicate "yes there was an error".
+            if (err.message !== undefined) {
+                var code = (err.body ? err.body.code : err.code);
+                console.error('%s%s: error%s: %s',
+                    cli.name,
+                    (subcmd ? ' ' + subcmd : ''),
+                    ((options.showCode && code) ? format(' (%s)', code) : ''),
+                    (process.env.DEBUG ? err.stack : err.message));
+            }
             process.exit(err.exitStatus || 1);
         }
         process.exit(0);
@@ -431,6 +493,7 @@ function main(cmdClass, argv) {
 }
 
 
+
 // ---- exports
 
 module.exports = {
diff --git a/tools/node_modules/cmdln/node_modules/assert-plus/README.md b/tools/node_modules/cmdln/node_modules/assert-plus/README.md
new file mode 100644
index 00000000..c0c3a530
--- /dev/null
+++ b/tools/node_modules/cmdln/node_modules/assert-plus/README.md
@@ -0,0 +1,126 @@
+# node-assert-plus
+
+This library is a super small wrapper over node's assert module that has two
+things: (1) the ability to disable assertions with the environment variable
+NODE_NDEBUG, and (2) some API wrappers for argument testing.  Like
+`assert.string(myArg, 'myArg')`.  As a simple example, most of my code looks
+like this:
+
+    var assert = require('assert-plus');
+
+    function fooAccount(options, callback) {
+	    assert.object(options, 'options');
+		assert.number(options.id, 'options.id);
+		assert.bool(options.isManager, 'options.isManager');
+		assert.string(options.name, 'options.name');
+		assert.arrayOfString(options.email, 'options.email');
+		assert.func(callback, 'callback');
+
+        // Do stuff
+		callback(null, {});
+    }
+
+# API
+
+All methods that *aren't* part of node's core assert API are simply assumed to
+take an argument, and then a string 'name' that's not a message; `AssertionError`
+will be thrown if the assertion fails with a message like:
+
+    AssertionError: foo (string) is required
+	at test (/home/mark/work/foo/foo.js:3:9)
+	at Object.<anonymous> (/home/mark/work/foo/foo.js:15:1)
+	at Module._compile (module.js:446:26)
+	at Object..js (module.js:464:10)
+	at Module.load (module.js:353:31)
+	at Function._load (module.js:311:12)
+	at Array.0 (module.js:484:10)
+	at EventEmitter._tickCallback (node.js:190:38)
+
+from:
+
+    function test(foo) {
+	    assert.string(foo, 'foo');
+    }
+
+There you go.  You can check that arrays are of a homogenous type with `Arrayof$Type`:
+
+    function test(foo) {
+	    assert.arrayOfString(foo, 'foo');
+    }
+
+You can assert IFF an argument is not `undefined` (i.e., an optional arg):
+
+    assert.optionalString(foo, 'foo');
+
+Lastly, you can opt-out of assertion checking altogether by setting the
+environment variable `NODE_NDEBUG=1`.  This is pseudo-useful if you have
+lots of assertions, and don't want to pay `typeof ()` taxes to v8 in
+production.
+
+The complete list of APIs is:
+
+* assert.bool
+* assert.buffer
+* assert.func
+* assert.number
+* assert.object
+* assert.string
+* assert.arrayOfBool
+* assert.arrayOfFunc
+* assert.arrayOfNumber
+* assert.arrayOfObject
+* assert.arrayOfString
+* assert.optionalBool
+* assert.optionalBuffer
+* assert.optionalFunc
+* assert.optionalNumber
+* assert.optionalObject
+* assert.optionalString
+* assert.optionalArrayOfBool
+* assert.optionalArrayOfFunc
+* assert.optionalArrayOfNumber
+* assert.optionalArrayOfObject
+* assert.optionalArrayOfString
+* assert.AssertionError
+* assert.fail
+* assert.ok
+* assert.equal
+* assert.notEqual
+* assert.deepEqual
+* assert.notDeepEqual
+* assert.strictEqual
+* assert.notStrictEqual
+* assert.throws
+* assert.doesNotThrow
+* assert.ifError
+
+# Installation
+
+    npm install assert-plus
+
+## License
+
+The MIT License (MIT)
+Copyright (c) 2012 Mark Cavage
+
+Permission is hereby granted, free of charge, to any person obtaining a copy of
+this software and associated documentation files (the "Software"), to deal in
+the Software without restriction, including without limitation the rights to
+use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
+the Software, and to permit persons to whom the Software is furnished to do so,
+subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all
+copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+SOFTWARE.
+
+## Bugs
+
+See <https://github.com/mcavage/node-assert-plus/issues>.
diff --git a/tools/node_modules/cmdln/node_modules/assert-plus/assert.js b/tools/node_modules/cmdln/node_modules/assert-plus/assert.js
new file mode 100644
index 00000000..caaaae93
--- /dev/null
+++ b/tools/node_modules/cmdln/node_modules/assert-plus/assert.js
@@ -0,0 +1,196 @@
+// Copyright (c) 2012, Mark Cavage. All rights reserved.
+
+var assert = require('assert');
+var Stream = require('stream').Stream;
+var util = require('util');
+
+
+
+///--- Globals
+
+var NDEBUG = process.env.NODE_NDEBUG || false;
+
+
+
+///--- Messages
+
+var ARRAY_TYPE_REQUIRED = '%s ([%s]) required';
+var TYPE_REQUIRED = '%s (%s) is required';
+
+
+
+///--- Internal
+
+function capitalize(str) {
+        return (str.charAt(0).toUpperCase() + str.slice(1));
+}
+
+function uncapitalize(str) {
+        return (str.charAt(0).toLowerCase() + str.slice(1));
+}
+
+function _() {
+        return (util.format.apply(util, arguments));
+}
+
+
+function _assert(arg, type, name, stackFunc) {
+        if (!NDEBUG) {
+                name = name || type;
+                stackFunc = stackFunc || _assert.caller;
+                var t = typeof (arg);
+
+                if (t !== type) {
+                        throw new assert.AssertionError({
+                                message: _(TYPE_REQUIRED, name, type),
+                                actual: t,
+                                expected: type,
+                                operator: '===',
+                                stackStartFunction: stackFunc
+                        });
+                }
+        }
+}
+
+
+
+///--- API
+
+function array(arr, type, name) {
+        if (!NDEBUG) {
+                name = name || type;
+
+                if (!Array.isArray(arr)) {
+                        throw new assert.AssertionError({
+                                message: _(ARRAY_TYPE_REQUIRED, name, type),
+                                actual: typeof (arr),
+                                expected: 'array',
+                                operator: 'Array.isArray',
+                                stackStartFunction: array.caller
+                        });
+                }
+
+                for (var i = 0; i < arr.length; i++) {
+                        _assert(arr[i], type, name, array);
+                }
+        }
+}
+
+
+function bool(arg, name) {
+        _assert(arg, 'boolean', name, bool);
+}
+
+
+function buffer(arg, name) {
+        if (!Buffer.isBuffer(arg)) {
+                throw new assert.AssertionError({
+                        message: _(TYPE_REQUIRED, name, type),
+                        actual: typeof (arg),
+                        expected: 'buffer',
+                        operator: 'Buffer.isBuffer',
+                        stackStartFunction: buffer
+                });
+        }
+}
+
+
+function func(arg, name) {
+        _assert(arg, 'function', name);
+}
+
+
+function number(arg, name) {
+        _assert(arg, 'number', name);
+}
+
+
+function object(arg, name) {
+        _assert(arg, 'object', name);
+}
+
+
+function stream(arg, name) {
+        if (!(arg instanceof Stream)) {
+                throw new assert.AssertionError({
+                        message: _(TYPE_REQUIRED, name, 'stream'),
+                        actual: typeof (arg),
+                        expected: 'Stream',
+                        operator: 'instanceof',
+                        stackStartFunction: buffer
+                });
+        }
+}
+
+
+function string(arg, name) {
+        _assert(arg, 'string', name);
+}
+
+
+
+///--- Exports
+
+module.exports = {
+        bool: bool,
+        buffer: buffer,
+        func: func,
+        number: number,
+        object: object,
+        stream: stream,
+        string: string
+};
+
+
+Object.keys(module.exports).forEach(function (k) {
+        if (k === 'buffer')
+                return;
+
+        var name = 'arrayOf' + capitalize(k);
+
+        if (k === 'bool')
+                k = 'boolean';
+        if (k === 'func')
+                k = 'function';
+        module.exports[name] = function (arg, name) {
+                array(arg, k, name);
+        };
+});
+
+Object.keys(module.exports).forEach(function (k) {
+        var _name = 'optional' + capitalize(k);
+        var s = uncapitalize(k.replace('arrayOf', ''));
+        if (s === 'bool')
+                s = 'boolean';
+        if (s === 'func')
+                s = 'function';
+
+        if (k.indexOf('arrayOf') !== -1) {
+          module.exports[_name] = function (arg, name) {
+                  if (!NDEBUG && arg !== undefined) {
+                          array(arg, s, name);
+                  }
+          };
+        } else {
+          module.exports[_name] = function (arg, name) {
+                  if (!NDEBUG && arg !== undefined) {
+                          _assert(arg, s, name);
+                  }
+          };
+        }
+});
+
+
+// Reexport built-in assertions
+Object.keys(assert).forEach(function (k) {
+        if (k === 'AssertionError') {
+                module.exports[k] = assert[k];
+                return;
+        }
+
+        module.exports[k] = function () {
+                if (!NDEBUG) {
+                        assert[k].apply(assert[k], arguments);
+                }
+        };
+});
diff --git a/tools/node_modules/cmdln/node_modules/assert-plus/package.json b/tools/node_modules/cmdln/node_modules/assert-plus/package.json
new file mode 100644
index 00000000..c6eca844
--- /dev/null
+++ b/tools/node_modules/cmdln/node_modules/assert-plus/package.json
@@ -0,0 +1,28 @@
+{
+  "author": {
+    "name": "Mark Cavage",
+    "email": "mcavage@gmail.com"
+  },
+  "dependencies": {},
+  "description": "Extra assertions on top of node's assert module",
+  "devDependencies": {},
+  "directories": {},
+  "dist": {
+    "shasum": "32eba8ac83e50ae4f4b5babab1ae9aa0edec9fef",
+    "tarball": "https://registry.npmjs.org/assert-plus/-/assert-plus-0.1.3.tgz"
+  },
+  "engines": {
+    "node": ">=0.8"
+  },
+  "main": "./assert.js",
+  "maintainers": [
+    {
+      "name": "mcavage",
+      "email": "mcavage@gmail.com"
+    }
+  ],
+  "name": "assert-plus",
+  "optionalDependencies": {},
+  "readme": "ERROR: No README data found!",
+  "version": "0.1.3"
+}
\ No newline at end of file
diff --git a/tools/node_modules/cmdln/node_modules/dashdash/.npmignore b/tools/node_modules/cmdln/node_modules/dashdash/.npmignore
new file mode 100644
index 00000000..590c7315
--- /dev/null
+++ b/tools/node_modules/cmdln/node_modules/dashdash/.npmignore
@@ -0,0 +1,3 @@
+/tmp
+/node_modules
+/npm-debug.log
diff --git a/tools/node_modules/cmdln/node_modules/dashdash/CHANGES.md b/tools/node_modules/cmdln/node_modules/dashdash/CHANGES.md
new file mode 100644
index 00000000..d2566d47
--- /dev/null
+++ b/tools/node_modules/cmdln/node_modules/dashdash/CHANGES.md
@@ -0,0 +1,102 @@
+# node-dashdash changelog
+
+## 1.3.2
+
+- Fix a subtlety where a *bool* option using both `env` and `default` didn't
+  work exactly correctly. If `default: false` then all was fine (by luck).
+  However, if you had an option like this:
+
+        options: [ {
+            names: ['verbose', 'v'],
+            env: 'FOO_VERBOSE',
+            'default': true,    // <--- this
+            type: 'bool'
+        } ],
+
+  wanted `FOO_VERBOSE=0` to make the option false, then you need the fix
+  in this version of dashdash.
+
+
+## 1.3.1
+
+- [issue #1] Fix an envvar not winning over an option 'default'. Previously
+  an option with both `default` and `env` would never take a value from the
+  environment variable. E.g. `FOO_FILE` would never work here:
+
+        options: [ {
+            names: ['file', 'f'],
+            env: 'FOO_FILE',
+            'default': 'default.file',
+            type: 'string'
+        } ],
+
+
+## 1.3.0
+
+- [Backward incompatible change for boolean envvars] Change the
+  interpretation of environment variables for boolean options to consider '0'
+  to be false. Previous to this *any* value to the envvar was considered
+  true -- which was quite misleading. Example:
+
+        $ FOO_VERBOSE=0 node examples/foo.js
+        # opts: { verbose: [ false ],
+          _order: [ { key: 'verbose', value: false, from: 'env' } ],
+          _args: [] }
+        # args: []
+
+
+## 1.2.1
+
+- Fix for `parse.help({includeEnv: true, ...})` handling to ensure that an
+  option with an `env` **but no `help`** still has the "Environment: ..."
+  output. E.g.:
+
+        { names: ['foo'], type: 'string', env: 'FOO' }
+
+        ...
+
+        --foo=ARG      Environment: FOO=ARG
+
+
+## 1.2.0
+
+- Transform the option key on the `opts` object returned from
+  `<parser>.parse()` for convenience. Currently this is just
+  `s/-/_/g`, e.g. '--dry-run' -> `opts.dry_run`. This allow one to use hyphen
+  in option names (common) but not have to do silly things like
+  `opt["dry-run"]` to access the parsed results.
+
+
+## 1.1.0
+
+- Environment variable integration. Envvars can be associated with an option,
+  then option processing will fallback to using that envvar if defined and
+  if the option isn't specified in argv. See the "Environment variable
+  integration" section in the README.
+
+- Change the `<parser>.parse()` signature to take a single object with keys
+  for arguments. The old signature is still supported.
+
+- `dashdash.createParser(CONFIG)` alternative to `new dashdash.Parser(CONFIG)`
+  a la many node-land APIs.
+
+
+## 1.0.2
+
+- Add "positiveInteger" and "arrayOfPositiveInteger" option types that only
+  accept positive integers.
+
+- Add "integer" and "arrayOfInteger" option types that accepts only integers.
+  Note that, for better or worse, these do NOT accept: "0x42" (hex), "1e2"
+  (with exponent) or "1.", "3.0" (floats).
+
+
+## 1.0.1
+
+- Fix not modifying the given option spec objects (which breaks creating
+  a Parser with them more than once).
+
+
+## 1.0.0
+
+First release.
diff --git a/tools/node_modules/cmdln/node_modules/dashdash/LICENSE.txt b/tools/node_modules/cmdln/node_modules/dashdash/LICENSE.txt
new file mode 100644
index 00000000..54706c66
--- /dev/null
+++ b/tools/node_modules/cmdln/node_modules/dashdash/LICENSE.txt
@@ -0,0 +1,24 @@
+# This is the MIT license
+
+Copyright (c) 2013 Trent Mick. All rights reserved.
+Copyright (c) 2013 Joyent Inc. All rights reserved.
+
+Permission is hereby granted, free of charge, to any person obtaining a
+copy of this software and associated documentation files (the
+"Software"), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+The above copyright notice and this permission notice shall be included
+in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
diff --git a/tools/node_modules/cmdln/node_modules/dashdash/Makefile b/tools/node_modules/cmdln/node_modules/dashdash/Makefile
new file mode 100644
index 00000000..62357086
--- /dev/null
+++ b/tools/node_modules/cmdln/node_modules/dashdash/Makefile
@@ -0,0 +1,50 @@
+
+NODEUNIT = ./node_modules/.bin/nodeunit
+JSSTYLE_FILES := $(shell find lib test -name "*.js")
+NODEOPT ?= $(HOME)/opt
+
+
+all $(NODEUNIT):
+	npm install
+
+.PHONY: distclean
+distclean:
+	rm -rf node_modules
+
+
+.PHONY: test
+test: | $(NODEUNIT)
+	$(NODEUNIT) test/*.test.js
+
+.PHONY: testall
+testall: test10 test08
+.PHONY: test10
+test10:
+	@echo "# Test node 0.10.x (with node `$(NODEOPT)/node-0.10/bin/node --version`)"
+	@$(NODEOPT)/node-0.10/bin/node --version
+	PATH="$(NODEOPT)/node-0.10/bin:$(PATH)" make test
+.PHONY: test08
+test08:
+	@echo "# Test node 0.8.x (with node `$(NODEOPT)/node-0.8/bin/node --version`)"
+	@$(NODEOPT)/node-0.8/bin/node --version
+	PATH="$(NODEOPT)/node-0.8/bin:$(PATH)" make test
+
+
+.PHONY: check-jsstyle
+check-jsstyle: $(JSSTYLE_FILES)
+	./tools/jsstyle -o indent=4,doxygen,unparenthesized-return=0,blank-after-start-comment=0,leading-right-paren-ok $(JSSTYLE_FILES)
+
+.PHONY: check
+check: check-jsstyle
+	@echo "Check ok."
+
+# Ensure CHANGES.md and package.json have the same version.
+.PHONY: versioncheck
+versioncheck:
+	[[ `cat package.json | json version` == `grep '^## ' CHANGES.md | head -1 | awk '{print $$2}'` ]]
+
+.PHONY: cutarelease
+cutarelease: versioncheck
+	[[ `git status | tail -n1` == "nothing to commit (working directory clean)" ]]
+	./tools/cutarelease.py -p dashdash -f package.json
+
diff --git a/tools/node_modules/cmdln/node_modules/dashdash/README.md b/tools/node_modules/cmdln/node_modules/dashdash/README.md
new file mode 100644
index 00000000..a3a961e9
--- /dev/null
+++ b/tools/node_modules/cmdln/node_modules/dashdash/README.md
@@ -0,0 +1,364 @@
+A light, featureful and explicit option parsing library for node.js.
+
+[Why another one? See below](#why). tl;dr: The others I've tried are one of
+too loosey goosey (not explicit), too big/too many deps, or ill specified.
+YMMV.
+
+Follow <a href="https://twitter.com/intent/user?screen_name=trentmick" target="_blank">@trentmick</a>
+for updates to node-dashdash.
+
+# Install
+
+    npm install dashdash
+
+
+# Usage
+
+```javascript
+var dashdash = require('dashdash');
+
+// Specify the options. Minimally `name` (or `names`) and `type`
+// must be given for each.
+var options = [
+    {
+        // `names` or a single `name`. First element is the `opts.KEY`.
+        names: ['help', 'h'],
+        // See "Option config" below for types.
+        type: 'bool',
+        help: 'Print this help and exit.'
+    }
+];
+
+// Shortcut form. As called it infers `process.argv`. See below for
+// the longer form to use methods like `.help()` on the Parser object.
+var opts = dashdash.parse({options: options});
+
+console.log("opts:", opts);
+console.log("args:", opts._args);
+```
+
+
+# Longer Example
+
+A more realistic [starter script "foo.js"](./examples/foo.js) is as follows.
+This also shows using `parser.help()` for formatted option help.
+
+```javascript
+var dashdash = require('./lib/dashdash');
+
+var options = [
+    {
+        name: 'version',
+        type: 'bool',
+        help: 'Print tool version and exit.'
+    },
+    {
+        names: ['help', 'h'],
+        type: 'bool',
+        help: 'Print this help and exit.'
+    },
+    {
+        names: ['verbose', 'v'],
+        type: 'arrayOfBool',
+        help: 'Verbose output. Use multiple times for more verbose.'
+    },
+    {
+        names: ['file', 'f'],
+        type: 'string',
+        help: 'File to process',
+        helpArg: 'FILE'
+    }
+];
+
+var parser = dashdash.createParser({options: options});
+try {
+    var opts = parser.parse(process.argv);
+} catch (e) {
+    console.error('foo: error: %s', e.message);
+    process.exit(1);
+}
+
+console.log("# opts:", opts);
+console.log("# args:", opts._args);
+
+// Use `parser.help()` for formatted options help.
+if (opts.help) {
+    var help = parser.help({includeEnv: true}).trimRight();
+    console.log('usage: node foo.js [OPTIONS]\n'
+                + 'options:\n'
+                + help);
+    process.exit(0);
+}
+
+// ...
+```
+
+
+Some example output from this script (foo.js):
+
+```
+$ node foo.js -h
+# opts: { help: true,
+  _order: [ { name: 'help', value: true, from: 'argv' } ],
+  _args: [] }
+# args: []
+usage: node foo.js [OPTIONS]
+options:
+    --version             Print tool version and exit.
+    -h, --help            Print this help and exit.
+    -v, --verbose         Verbose output. Use multiple times for more verbose.
+    -f FILE, --file=FILE  File to process
+
+$ node foo.js -v
+# opts: { verbose: [ true ],
+  _order: [ { name: 'verbose', value: true, from: 'argv' } ],
+  _args: [] }
+# args: []
+
+$ node foo.js --version arg1
+# opts: { version: true,
+  _order: [ { name: 'version', value: true, from: 'argv' } ],
+  _args: [ 'arg1' ] }
+# args: [ 'arg1' ]
+
+$ node foo.js -f bar.txt
+# opts: { file: 'bar.txt',
+  _order: [ { name: 'file', value: 'bar.txt', from: 'argv' } ],
+  _args: [] }
+# args: []
+
+$ node foo.js -vvv --file=blah
+# opts: { verbose: [ true, true, true ],
+  file: 'blah',
+  _order:
+   [ { name: 'verbose', value: true, from: 'argv' },
+     { name: 'verbose', value: true, from: 'argv' },
+     { name: 'verbose', value: true, from: 'argv' },
+     { name: 'file', value: 'blah', from: 'argv' } ],
+  _args: [] }
+# args: []
+```
+
+
+# Environment variable integration
+
+If you want to allow environment variables to specify options to your tool,
+dashdash makes this easy. We can change the 'verbose' option in the example
+above to include an 'env' field:
+
+```javascript
+    {
+        names: ['verbose', 'v'],
+        type: 'arrayOfBool',
+        env: 'FOO_VERBOSE',         // <--- add this line
+        help: 'Verbose output. Use multiple times for more verbose.'
+    },
+```
+
+then the **"FOO_VERBOSE" environment variable** can be used to set this
+option:
+
+```shell
+$ FOO_VERBOSE=1 node foo.js
+# opts: { verbose: [ true ],
+  _order: [ { name: 'verbose', value: true, from: 'env' } ],
+  _args: [] }
+# args: []
+```
+
+Boolean options will interpret the empty string as unset, '0' as false
+and anything else as true.
+
+```shell
+$ FOO_VERBOSE= node examples/foo.js                 # not set
+# opts: { _order: [], _args: [] }
+# args: []
+
+$ FOO_VERBOSE=0 node examples/foo.js                # '0' is false
+# opts: { verbose: [ false ],
+  _order: [ { key: 'verbose', value: false, from: 'env' } ],
+  _args: [] }
+# args: []
+
+$ FOO_VERBOSE=1 node examples/foo.js                # true
+# opts: { verbose: [ true ],
+  _order: [ { key: 'verbose', value: true, from: 'env' } ],
+  _args: [] }
+# args: []
+
+$ FOO_VERBOSE=boogabooga node examples/foo.js       # true
+# opts: { verbose: [ true ],
+  _order: [ { key: 'verbose', value: true, from: 'env' } ],
+  _args: [] }
+# args: []
+```
+
+Non-booleans can be used as well. Strings:
+
+```shell
+$ FOO_FILE=data.txt node examples/foo.js
+# opts: { file: 'data.txt',
+  _order: [ { key: 'file', value: 'data.txt', from: 'env' } ],
+  _args: [] }
+# args: []
+```
+
+Numbers:
+
+```shell
+$ FOO_TIMEOUT=5000 node examples/foo.js
+# opts: { timeout: 5000,
+  _order: [ { key: 'timeout', value: 5000, from: 'env' } ],
+  _args: [] }
+# args: []
+
+$ FOO_TIMEOUT=blarg node examples/foo.js
+foo: error: arg for "FOO_TIMEOUT" is not a positive integer: "blarg"
+```
+
+With the `includeEnv: true` config to `parser.help()` the environment
+variable can also be included in **help output**:
+
+    usage: node foo.js [OPTIONS]
+    options:
+        --version             Print tool version and exit.
+        -h, --help            Print this help and exit.
+        -v, --verbose         Verbose output. Use multiple times for more verbose.
+                              Environment: FOO_VERBOSE=1
+        -f FILE, --file=FILE  File to process
+
+
+# Parser config
+
+Parser construction (i.e. `dashdash.createParser(CONFIG)`) takes the
+following fields:
+
+- `options` (Array of option specs). Required. See the
+  [Option specs](#option-specs) section below.
+
+- `interspersed` (Boolean). Option. Default is true. If true this allows
+  interspersed arguments and options. I.e.:
+
+        node ./tool.js -v arg1 arg2 -h   # '-h' is after interspersed args
+
+  Set it to false to have '-h' **not** get parsed as an option in the above
+  example.
+
+
+# Option specs
+
+Example using all fields:
+
+```javascript
+{
+    names: ['file', 'f'],       // Required (or `name`).
+    type: 'string',             // Required.
+    env: 'MYTOOL_FILE',
+    help: 'Config file to load before running "mytool"',
+    helpArg: 'PATH',
+    default: path.resolve(process.env.HOME, '.mytoolrc')
+}
+```
+
+Each option spec in the `options` array must/can have the following fields:
+
+- `name` (String) or `names` (Array). Required. These give the option name
+  and aliases. The first name (if more than one given) is the key for the
+  parsed `opts` object.
+
+- `type` (String). Required. One of:
+
+    - bool
+    - string
+    - number
+    - integer
+    - positiveInteger
+    - arrayOfBool
+    - arrayOfString
+    - arrayOfNumber
+    - arrayOfInteger
+    - arrayOfPositiveInteger
+
+  FWIW, these names attempt to match with asserts on
+  [assert-plus](https://github.com/mcavage/node-assert-plus).
+
+- `env` (String or Array of String). Optional. An environment variable name
+  (or names) that can be used as a fallback for this option. For example,
+  given a "foo.js" like this:
+
+        var options = [{names: ['dry-run', 'n'], env: 'FOO_DRY_RUN'}];
+        var opts = dashdash.parse({options: options});
+
+  Both `node foo.js --dry-run` and `FOO_DRY_RUN=1 node foo.js` would result
+  in `opts.dry_run = true`.
+
+  An environment variable is only used as a fallback, i.e. it is ignored if
+  the associated option is given in `argv`.
+
+- `help` (String). Optional. Used for `parser.help()` output.
+
+- `helpArg` (String). Optional. Used in help output as the placeholder for
+  the option argument, e.g. the "PATH" in:
+
+        ...
+        -f PATH, --file=PATH    File to process
+        ...
+
+- `default`. Optional. A default value used for this option, if the
+  option isn't specified in argv.
+
+
+# Help config
+
+The `parser.help(...)` function is configurable as follows:
+
+    Options:
+        -w WEAPON, --weapon=WEAPON  Weapon with which to crush. One of: |
+                                    sword, spear, maul                  |
+        -h, --help                  Print this help and exit.           |
+    ^^^^                            ^                                   |
+        `-- indent                   `-- helpCol              maxCol ---'
+
+- `indent` (Number or String). Default 4. Set to a number (for that many
+  spaces) or a string for the literal indent.
+- `nameSort` (String). Default is 'length'. By default the names are
+  sorted to put the short opts first (i.e. '-h, --help' preferred
+  to '--help, -h'). Set to 'none' to not do this sorting.
+- `maxCol` (Number). Default 80. Note that reflow is just done on whitespace
+  so a long token in the option help can overflow maxCol.
+- `helpCol` (Number). If not set a reasonable value will be determined
+  between `minHelpCol` and `maxHelpCol`.
+- `minHelpCol` (Number). Default 20.
+- `maxHelpCol` (Number). Default 40.
+- `includeEnv` (Boolean). Default false. If the option has associated
+  environment variables (via the `env` option spec attribute), then
+  append mentioned of those envvars to the help string.
+
+
+# Why
+
+Why another node.js option parsing lib?
+
+- `nopt` really is just for "tools like npm". Implicit opts (e.g. '--no-foo'
+works for every '--foo'). Can't disable abbreviated opts. Can't do multiple
+usages of same opt, e.g. '-vvv' (I think). Can't do grouped short opts.
+
+- `optimist` has surprise interpretation of options (at least to me).
+  Implicit opts mean ambiguities and poor error handling for fat-fingering.
+  `process.exit` calls makes it hard to use as a libary.
+
+- `optparse` Incomplete docs. Is this an attempted clone of Python's `optparse`.
+  Not clear. Some divergence. `parser.on("name", ...)` API is weird.
+
+- `argparse` Dep on underscore. No thanks just for option processing.
+  `find lib | wc -l` -> `26`. Overkill.
+  Argparse is a bit different anyway. Not sure I want that.
+
+- `posix-getopt` No type validation. Though that isn't a killer. AFAIK can't
+  have a long opt without a short alias. I.e. no `getopt_long` semantics.
+  Also, no whizbang features like generated help output.
+
+
+# License
+
+MIT. See LICENSE.txt.
diff --git a/tools/node_modules/cmdln/node_modules/dashdash/TODO.txt b/tools/node_modules/cmdln/node_modules/dashdash/TODO.txt
new file mode 100644
index 00000000..4c44a80d
--- /dev/null
+++ b/tools/node_modules/cmdln/node_modules/dashdash/TODO.txt
@@ -0,0 +1,44 @@
+- --dry-run -> opts.dry_run
+
+# someday/maybe
+
+- being able to add types: i.e. a validator (easy to do, just haven't exposed)
+- Maybe this later: var opts = parser.parse({argv: process.argv});
+
+
+# notes: supporting opts from env or from a file
+
+Say I have a 'foo' tool with a '-v' option for verbose. I also want
+FOO_VERBOSE envvar to set verbose:
+
+    $ foo -v
+    debug: blah blah
+    ...
+
+    $ FOO_VERBOSE=1 foo
+    debug: blah blah
+    ...
+
+foo.js:
+
+    var dashdash = require('dashdash')
+    var options = [{name: 'v', env: 'FOO_VERBOSE', type: 'bool'}];
+    var parser = new dashdash.Parser({options: options});
+    var opts = parser.parse(process.argv);
+
+Say, also a ~/.foorc file is supported (somewhat a la ~/.ackrc) where
+the file holds extra CLI opts:
+
+    $ cat ~/.foorc
+    -v -i
+    --file=foo.txt
+
+Parsing that would look like:
+
+    var options = [
+        {name: 'v', env: 'FOO_VERBOSE', type: 'bool'},
+        {name: 'i', type: 'bool'},
+        {name: 'file', env: 'FOO_FILE', type: 'string'}
+    ];
+    var parser = new dashdash.Parser({options: options});
+    var opts = parser.parse(process.argv);
diff --git a/tools/node_modules/cmdln/node_modules/dashdash/examples/foo.js b/tools/node_modules/cmdln/node_modules/dashdash/examples/foo.js
new file mode 100644
index 00000000..c11a19e4
--- /dev/null
+++ b/tools/node_modules/cmdln/node_modules/dashdash/examples/foo.js
@@ -0,0 +1,60 @@
+var dashdash = require('../lib/dashdash');
+
+// Specify the options. Minimally `name` (or `names`) and `type`
+// must be given for each.
+var options = [
+    {
+        name: 'version',              // `name` or `names`
+        type: 'bool',
+        help: 'Print tool version and exit.'
+    },
+    {
+        names: ['help', 'h'],        // first name is opts key
+        type: 'bool',
+        help: 'Print this help and exit.'
+    },
+    {
+        names: ['verbose', 'v'],
+        type: 'arrayOfBool',
+        env: 'FOO_VERBOSE',
+        help: 'Verbose output. Use multiple times for more verbose.'
+    },
+    {
+        names: ['file', 'f'],
+        type: 'string',
+        env: 'FOO_FILE',
+        help: 'File to process',
+        helpArg: 'FILE'
+    },
+    {
+        names: ['timeout', 't'],
+        type: 'positiveInteger',
+        env: 'FOO_TIMEOUT',
+        help: 'Processing timeout in milliseconds',
+        helpArg: 'MS'
+    }
+];
+
+var parser = dashdash.createParser({options: options});
+try {
+    var opts = parser.parse(process.argv);
+} catch (e) {
+    console.error('foo: error: %s', e.message);
+    process.exit(1);
+}
+// Or a shortcut:
+//      var opts = dashdash.parse({options: options});
+
+console.log("# opts:", opts);
+console.log("# args:", opts._args);
+
+// Use `parser.help()` for formatted options help.
+if (opts.help) {
+    var help = parser.help({includeEnv: true}).trimRight();
+    console.log('usage: node foo.js [OPTIONS]\n'
+                + 'options:\n'
+                + help);
+    process.exit(0);
+}
+
+// ...
diff --git a/tools/node_modules/cmdln/node_modules/dashdash/lib/dashdash.js b/tools/node_modules/cmdln/node_modules/dashdash/lib/dashdash.js
new file mode 100644
index 00000000..f1a753b3
--- /dev/null
+++ b/tools/node_modules/cmdln/node_modules/dashdash/lib/dashdash.js
@@ -0,0 +1,597 @@
+/**
+ * dashdash - A light, featureful and explicit option parsing library for
+ * node.js.
+ */
+
+var p = console.log;
+var format = require('util').format;
+
+var assert = require('assert-plus');
+
+var DEBUG = true;
+if (DEBUG) {
+    var debug = console.warn;
+} else {
+    var debug = function () {};
+}
+
+
+
+// ---- internal support stuff
+
+/**
+ * Return a shallow copy of the given object;
+ */
+function shallowCopy(obj) {
+    if (!obj) {
+        return (obj);
+    }
+    var copy = {};
+    Object.keys(obj).forEach(function (k) {
+        copy[k] = obj[k];
+    });
+    return (copy);
+}
+
+
+function space(n) {
+    var s = '';
+    for (var i = 0; i < n; i++) {
+        s += ' ';
+    }
+    return s;
+}
+
+
+/**
+ * Return an array of lines wrapping the given text to the given width.
+ * This splits on whitespace. Single tokens longer than `width` are not
+ * broken up.
+ */
+function textwrap(s, width) {
+    var words = s.trim().split(/\s+/);
+    var lines = [];
+    var line = '';
+    words.forEach(function (w) {
+        var newLength = line.length + w.length;
+        if (line.length > 0)
+            newLength += 1;
+        if (newLength > width) {
+            lines.push(line);
+            line = '';
+        }
+        if (line.length > 0)
+            line += ' ';
+        line += w;
+    });
+    lines.push(line);
+    return lines;
+}
+
+
+/**
+ * Transform an option name to a "key" that is used as the field
+ * on the `opts` object returned from `<parser>.parse()`.
+ *
+ * Transformations:
+ * - '-' -> '_': This allow one to use hyphen in option names (common)
+ *   but not have to do silly things like `opt["dry-run"]` to access the
+ *   parsed results.
+ */
+function optionKeyFromName(name) {
+    return name.replace(/-/g, '_');
+}
+
+
+
+// ---- Option types
+
+function parseBool(option, optstr, arg) {
+    return Boolean(arg);
+}
+
+function parseString(option, optstr, arg) {
+    assert.string(arg, 'arg');
+    return arg;
+}
+
+function parseNumber(option, optstr, arg) {
+    assert.string(arg, 'arg');
+    var num = Number(arg);
+    if (isNaN(num)) {
+        throw new Error(format('arg for "%s" is not a number: "%s"',
+            optstr, arg));
+    }
+    return num;
+}
+
+function parseInteger(option, optstr, arg) {
+    assert.string(arg, 'arg');
+    var num = Number(arg);
+    if (!/^[0-9-]+$/.test(arg) || isNaN(num)) {
+        throw new Error(format('arg for "%s" is not an integer: "%s"',
+            optstr, arg));
+    }
+    return num;
+}
+
+function parsePositiveInteger(option, optstr, arg) {
+    assert.string(arg, 'arg');
+    var num = Number(arg);
+    if (!/^[0-9]+$/.test(arg) || isNaN(num)) {
+        throw new Error(format('arg for "%s" is not a positive integer: "%s"',
+            optstr, arg));
+    }
+    return num;
+}
+
+var types = {
+    bool: {
+        takesArg: false,
+        parseArg: parseBool
+    },
+    string: {
+        takesArg: true,
+        helpArg: 'ARG',
+        parseArg: parseString
+    },
+    number: {
+        takesArg: true,
+        helpArg: 'NUM',
+        parseArg: parseNumber
+    },
+    integer: {
+        takesArg: true,
+        helpArg: 'INT',
+        parseArg: parseInteger
+    },
+    positiveInteger: {
+        takesArg: true,
+        helpArg: 'INT',
+        parseArg: parsePositiveInteger
+    },
+    arrayOfBool: {
+        takesArg: false,
+        array: true,
+        parseArg: parseBool
+    },
+    arrayOfString: {
+        takesArg: true,
+        helpArg: 'ARG',
+        array: true,
+        parseArg: parseString
+    },
+    arrayOfNumber: {
+        takesArg: true,
+        helpArg: 'NUM',
+        array: true,
+        parseArg: parseNumber
+    },
+    arrayOfInteger: {
+        takesArg: true,
+        helpArg: 'INT',
+        array: true,
+        parseArg: parseInteger
+    },
+    arrayOfPositiveInteger: {
+        takesArg: true,
+        helpArg: 'INT',
+        array: true,
+        parseArg: parsePositiveInteger
+    },
+};
+
+
+
+// ---- Parser
+
+/**
+ * Parser constructor.
+ *
+ * @param config {Object} The parser configuration
+ *      - options {Array} Array of option specs. See the README for how to
+ *        specify each option spec.
+ *      - interspersed {Boolean} Default true. Whether to allow interspersed
+ *        arguments (non-options) and options. E.g.:
+ *              node tool.js arg1 arg2 -v
+ *        '-v' is after some args here. If `interspersed: false` then '-v'
+ *        would not be parsed out. Note that regardless of `interspersed`
+ *        the presence of '--' will stop option parsing, as all good
+ *        option parsers should.
+ */
+function Parser(config) {
+    assert.object(config, 'config');
+    assert.arrayOfObject(config.options, 'config.options');
+    assert.optionalBool(config.interspersed, 'config.interspersed');
+    var self = this;
+
+    // Allow interspersed arguments (true by default).
+    this.interspersed = (config.interspersed !== undefined
+        ? config.interspersed : true);
+
+    this.options = config.options.map(function (o) { return shallowCopy(o); });
+    this.optionFromName = {};
+    this.optionFromEnv = {};
+    for (var i = 0; i < this.options.length; i++) {
+        var o = this.options[i];
+        assert.ok(types[o.type],
+            format('invalid config.options.%d.type: "%s" in %j',
+                   i, o.type, o));
+        assert.optionalString(o.name, format('config.options.%d.name', i));
+        assert.optionalArrayOfString(o.names,
+            format('config.options.%d.names', i));
+        assert.ok((o.name || o.names) && !(o.name && o.names),
+            format('exactly one of "name" or "names" required: %j', o));
+        assert.optionalString(o.help, format('config.options.%d.help', i));
+        var env = o.env || [];
+        if (typeof (env) === 'string') {
+            env = [env];
+        }
+        assert.optionalArrayOfString(env, format('config.options.%d.env', i));
+
+        if (o.name) {
+            o.names = [o.name];
+        } else {
+            assert.string(o.names[0],
+                format('config.options.%d.names is empty', i));
+        }
+        o.key = optionKeyFromName(o.names[0]);
+        o.names.forEach(function (n) {
+            if (self.optionFromName[n]) {
+                throw new Error(format(
+                    'option name collision: "%s" used in %j and %j',
+                    n, self.optionFromName[n], o));
+            }
+            self.optionFromName[n] = o;
+        });
+        env.forEach(function (n) {
+            if (self.optionFromEnv[n]) {
+                throw new Error(format(
+                    'option env collision: "%s" used in %j and %j',
+                    n, self.optionFromEnv[n], o));
+            }
+            self.optionFromEnv[n] = o;
+        });
+    }
+}
+
+Parser.prototype.optionTakesArg = function optionTakesArg(option) {
+    return types[option.type].takesArg;
+};
+
+/**
+ * Parse options from the given argv.
+ *
+ * @param inputs {Object}
+ *      - argv {Array} Optional. The argv to parse. Defaults to
+ *        `process.argv`.
+ *      - slice {Number} The index into argv at which options/args begin.
+ *        Default is 2, as appropriate for `process.argv`.
+ *      - env {Object} Optional. The env to use for 'env' entries in the
+ *        option specs. Defaults to `process.env`.
+ * @returns {Object} Parsed `opts`. It has special keys `_args` (the
+ *      remaining args from `argv`) and `_order` (gives the order that
+ *      options were specified).
+ */
+Parser.prototype.parse = function parse(inputs) {
+    var self = this;
+
+    // Old API was `parse([argv, [slice]])`
+    if (Array.isArray(arguments[0])) {
+        inputs = {argv: arguments[0], slice: arguments[1]};
+    }
+
+    assert.object(inputs, 'inputs');
+    assert.optionalArrayOfString(inputs.argv, 'inputs.argv');
+    //assert.optionalNumber(slice, 'slice');
+    var argv = inputs.argv || process.argv;
+    var slice = inputs.slice !== undefined ? inputs.slice : 2;
+    var args = argv.slice(slice);
+    var env = inputs.env || process.env;
+    var opts = {};
+    var _order = [];
+
+    function addOpt(option, optstr, key, val, from) {
+        var type = types[option.type];
+        var parsedVal = type.parseArg(option, optstr, val);
+        if (type.array) {
+            if (!opts[key]) {
+                opts[key] = [];
+            }
+            opts[key].push(parsedVal);
+        } else {
+            opts[key] = parsedVal;
+        }
+        var item = { key: key, value: parsedVal, from: from };
+        _order.push(item);
+    }
+
+    // Parse args.
+    var _args = [];
+    var i = 0;
+    while (i < args.length) {
+        var arg = args[i];
+
+        // End of options marker.
+        if (arg === '--') {
+            i++;
+            break;
+
+        // Long option
+        } else if (arg.slice(0, 2) === '--') {
+            var name = arg.slice(2);
+            var val = null;
+            var idx = name.indexOf('=');
+            if (idx !== -1) {
+                val = name.slice(idx + 1);
+                name = name.slice(0, idx);
+            }
+            var option = this.optionFromName[name];
+            if (!option) {
+                throw new Error(format('unknown option: "--%s"', name));
+            }
+            var takesArg = this.optionTakesArg(option);
+            if (val !== null && !takesArg) {
+                throw new Error(format('argument given to "--%s" option '
+                    + 'that does not take one: "%s"', name, arg));
+            }
+            if (!takesArg) {
+                addOpt(option, '--'+name, option.key, true, 'argv');
+            } else if (val !== null) {
+                addOpt(option, '--'+name, option.key, val, 'argv');
+            } else if (i + 1 >= args.length) {
+                throw new Error(format('do not have enough args for "--%s" '
+                    + 'option', name));
+            } else {
+                addOpt(option, '--'+name, option.key, args[i + 1], 'argv');
+                i++;
+            }
+
+        // Short option
+        } else if (arg[0] === '-' && arg.length > 1) {
+            var j = 1;
+            while (j < arg.length) {
+                var name = arg[j];
+                var val = arg.slice(j + 1);  // option val if it takes an arg
+                // debug('name: %s (val: %s)', name, val)
+                var option = this.optionFromName[name];
+                if (!option) {
+                    if (arg.length > 2) {
+                        throw new Error(format(
+                            'unknown option: "-%s" in "%s" group',
+                            name, arg));
+                    } else {
+                        throw new Error(format('unknown option: "-%s"', name));
+                    }
+                }
+                var takesArg = this.optionTakesArg(option);
+                if (!takesArg) {
+                    addOpt(option, '-'+name, option.key, true, 'argv');
+                } else if (val) {
+                    addOpt(option, '-'+name, option.key, val, 'argv');
+                    break;
+                } else {
+                    if (i + 1 >= args.length) {
+                        throw new Error(format('do not have enough args '
+                            + 'for "-%s" option', name));
+                    }
+                    addOpt(option, '-'+name, option.key, args[i + 1], 'argv');
+                    i++;
+                    break;
+                }
+                j++;
+            }
+
+        // An interspersed arg
+        } else if (this.interspersed) {
+            _args.push(arg);
+
+        // An arg and interspersed args are not allowed, so done options.
+        } else {
+            break;
+        }
+        i++;
+    }
+    _args = _args.concat(args.slice(i));
+
+    // Parse environment.
+    Object.keys(this.optionFromEnv).forEach(function (envname) {
+        var val = env[envname];
+        if (val === undefined)
+            return;
+        var option = self.optionFromEnv[envname];
+        if (opts[option.key] !== undefined)
+            return;
+        var takesArg = self.optionTakesArg(option);
+        if (takesArg) {
+            addOpt(option, envname, option.key, val, 'env');
+        } else if (val !== '') {
+            // Boolean envvar handling:
+            // - VAR=<empty-string>     not set (as if the VAR was not set)
+            // - VAR=0                  false
+            // - anything else          true
+            addOpt(option, envname, option.key, (val !== '0'), 'env');
+        }
+    });
+
+    // Apply default values.
+    this.options.forEach(function (o) {
+        if (o.default !== undefined && opts[o.key] === undefined) {
+            opts[o.key] = o.default;
+        }
+    });
+
+    opts._order = _order;
+    opts._args = _args;
+    return opts;
+};
+
+
+/**
+ * Return help output for the current options.
+ *
+ * E.g.: if the current options are:
+ *      [{names: ['help', 'h'], type: 'bool', help: 'Show help and exit.'}]
+ * then this would return:
+ *      '  -h, --help     Show help and exit.\n'
+ *
+ * @param config {Object} Config for controlling the option help output.
+ *      - indent {Number|String} Default 4. An indent/prefix to use for
+ *        each option line.
+ *      - nameSort {String} Default is 'length'. By default the names are
+ *        sorted to put the short opts first (i.e. '-h, --help' preferred
+ *        to '--help, -h'). Set to 'none' to not do this sorting.
+ *      - maxCol {Number} Default 80. Note that long tokens in a help string
+ *        can go past this.
+ *      - helpCol {Number} Set to specify a specific column at which
+ *        option help will be aligned. By default this is determined
+ *        automatically.
+ *      - minHelpCol {Number} Default 20.
+ *      - maxHelpCol {Number} Default 40.
+ *      - includeEnv {Boolean} Default false.
+ * @returns {String}
+ */
+Parser.prototype.help = function help(config) {
+    config = config || {};
+    assert.object(config, 'config');
+    var indent;
+    if (config.indent === undefined) {
+        indent = space(4);
+    } else if (typeof (config.indent) === 'number') {
+        indent = space(config.indent);
+    } else if (typeof (config.indent) === 'string') {
+        indent = config.indent;
+    } else {
+        assert.fail('invalid "config.indent": not a string or number: '
+            + config.indent);
+    }
+    assert.optionalString(config.nameSort, 'config.nameSort');
+    var nameSort = config.nameSort || 'length';
+    assert.ok(~['length', 'none'].indexOf(nameSort),
+        'invalid "config.nameSort"');
+    assert.optionalNumber(config.maxCol, 'config.maxCol');
+    assert.optionalNumber(config.maxHelpCol, 'config.maxHelpCol');
+    assert.optionalNumber(config.minHelpCol, 'config.minHelpCol');
+    assert.optionalNumber(config.helpCol, 'config.helpCol');
+    assert.optionalBool(config.includeEnv, 'config.includeEnv');
+    var maxCol = config.maxCol || 80;
+    var minHelpCol = config.minHelpCol || 20;
+    var maxHelpCol = config.maxHelpCol || 40;
+
+    var lines = [];
+    var maxWidth = 0;
+    this.options.forEach(function (o) {
+        var type = types[o.type];
+        var arg = o.helpArg || type.helpArg || 'ARG';
+        var line = '';
+        var names = o.names.slice();
+        if (nameSort === 'length') {
+            names.sort(function (a, b) {
+                if (a.length < b.length)
+                    return -1;
+                else if (b.length < a.length)
+                    return 1;
+                else
+                    return 0;
+            })
+        }
+        names.forEach(function (name, i) {
+            if (i > 0)
+                line += ', ';
+            if (name.length === 1) {
+                line += '-' + name
+                if (type.takesArg)
+                    line += ' ' + arg;
+            } else {
+                line += '--' + name
+                if (type.takesArg)
+                    line += '=' + arg;
+            }
+        });
+        maxWidth = Math.max(maxWidth, line.length);
+        lines.push(line);
+    });
+
+    // Add help strings.
+    var helpCol = config.helpCol;
+    if (!helpCol) {
+        helpCol = maxWidth + indent.length + 2;
+        helpCol = Math.min(Math.max(helpCol, minHelpCol), maxHelpCol);
+    }
+    this.options.forEach(function (o, i) {
+        if (!o.help && !(config.includeEnv && o.env)) {
+            return;
+        }
+        var line = lines[i];
+        var n = helpCol - (indent.length + line.length);
+        if (n >= 0) {
+            line += space(n);
+        } else {
+            line += '\n' + space(helpCol);
+        }
+        var help = (o.help || '').trim();
+        if (o.env && o.env.length && config.includeEnv) {
+            if (help.length && !~'.!?'.indexOf(help.slice(-1))) {
+                help += '.';
+            }
+            if (help.length) {
+                help += ' ';
+            }
+            help += 'Environment: ';
+            var type = types[o.type];
+            var arg = o.helpArg || type.helpArg || 'ARG';
+            var envs = (Array.isArray(o.env) ? o.env : [o.env]).map(function (e) {
+                if (type.takesArg) {
+                    return e + '=' + arg;
+                } else {
+                    return e + '=1';
+                }
+            });
+            help += envs.join(', ');
+        }
+        line += textwrap(help, maxCol - helpCol).join(
+            '\n' + space(helpCol));
+        lines[i] = line;
+    });
+
+    var rv = '';
+    if (lines.length > 0) {
+        rv = indent + lines.join('\n' + indent) + '\n';
+    }
+    return rv;
+};
+
+
+
+// ---- exports
+
+function createParser(config) {
+    return new Parser(config);
+}
+
+/**
+ * Parse argv with the given options.
+ *
+ * @param config {Object} A merge of all the available fields from
+ *      `dashdash.Parser` and `dashdash.Parser.parse`: options, interspersed,
+ *      argv, env, slice.
+ */
+function parse(config) {
+    assert.object(config, 'config');
+    assert.optionalArrayOfString(config.argv, 'config.argv');
+    assert.optionalObject(config.env, 'config.env');
+    var config = shallowCopy(config);
+    var argv = config.argv;
+    delete config.argv;
+    var env = config.env;
+    delete config.env;
+
+    var parser = new Parser(config);
+    return parser.parse({argv: argv, env: env});
+}
+
+module.exports = {
+    createParser: createParser,
+    Parser: Parser,
+    parse: parse
+};
diff --git a/tools/node_modules/cmdln/node_modules/dashdash/node_modules/assert-plus/README.md b/tools/node_modules/cmdln/node_modules/dashdash/node_modules/assert-plus/README.md
new file mode 100644
index 00000000..c0c3a530
--- /dev/null
+++ b/tools/node_modules/cmdln/node_modules/dashdash/node_modules/assert-plus/README.md
@@ -0,0 +1,126 @@
+# node-assert-plus
+
+This library is a super small wrapper over node's assert module that has two
+things: (1) the ability to disable assertions with the environment variable
+NODE_NDEBUG, and (2) some API wrappers for argument testing.  Like
+`assert.string(myArg, 'myArg')`.  As a simple example, most of my code looks
+like this:
+
+    var assert = require('assert-plus');
+
+    function fooAccount(options, callback) {
+	    assert.object(options, 'options');
+		assert.number(options.id, 'options.id);
+		assert.bool(options.isManager, 'options.isManager');
+		assert.string(options.name, 'options.name');
+		assert.arrayOfString(options.email, 'options.email');
+		assert.func(callback, 'callback');
+
+        // Do stuff
+		callback(null, {});
+    }
+
+# API
+
+All methods that *aren't* part of node's core assert API are simply assumed to
+take an argument, and then a string 'name' that's not a message; `AssertionError`
+will be thrown if the assertion fails with a message like:
+
+    AssertionError: foo (string) is required
+	at test (/home/mark/work/foo/foo.js:3:9)
+	at Object.<anonymous> (/home/mark/work/foo/foo.js:15:1)
+	at Module._compile (module.js:446:26)
+	at Object..js (module.js:464:10)
+	at Module.load (module.js:353:31)
+	at Function._load (module.js:311:12)
+	at Array.0 (module.js:484:10)
+	at EventEmitter._tickCallback (node.js:190:38)
+
+from:
+
+    function test(foo) {
+	    assert.string(foo, 'foo');
+    }
+
+There you go.  You can check that arrays are of a homogenous type with `Arrayof$Type`:
+
+    function test(foo) {
+	    assert.arrayOfString(foo, 'foo');
+    }
+
+You can assert IFF an argument is not `undefined` (i.e., an optional arg):
+
+    assert.optionalString(foo, 'foo');
+
+Lastly, you can opt-out of assertion checking altogether by setting the
+environment variable `NODE_NDEBUG=1`.  This is pseudo-useful if you have
+lots of assertions, and don't want to pay `typeof ()` taxes to v8 in
+production.
+
+The complete list of APIs is:
+
+* assert.bool
+* assert.buffer
+* assert.func
+* assert.number
+* assert.object
+* assert.string
+* assert.arrayOfBool
+* assert.arrayOfFunc
+* assert.arrayOfNumber
+* assert.arrayOfObject
+* assert.arrayOfString
+* assert.optionalBool
+* assert.optionalBuffer
+* assert.optionalFunc
+* assert.optionalNumber
+* assert.optionalObject
+* assert.optionalString
+* assert.optionalArrayOfBool
+* assert.optionalArrayOfFunc
+* assert.optionalArrayOfNumber
+* assert.optionalArrayOfObject
+* assert.optionalArrayOfString
+* assert.AssertionError
+* assert.fail
+* assert.ok
+* assert.equal
+* assert.notEqual
+* assert.deepEqual
+* assert.notDeepEqual
+* assert.strictEqual
+* assert.notStrictEqual
+* assert.throws
+* assert.doesNotThrow
+* assert.ifError
+
+# Installation
+
+    npm install assert-plus
+
+## License
+
+The MIT License (MIT)
+Copyright (c) 2012 Mark Cavage
+
+Permission is hereby granted, free of charge, to any person obtaining a copy of
+this software and associated documentation files (the "Software"), to deal in
+the Software without restriction, including without limitation the rights to
+use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
+the Software, and to permit persons to whom the Software is furnished to do so,
+subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all
+copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+SOFTWARE.
+
+## Bugs
+
+See <https://github.com/mcavage/node-assert-plus/issues>.
diff --git a/tools/node_modules/cmdln/node_modules/dashdash/node_modules/assert-plus/assert.js b/tools/node_modules/cmdln/node_modules/dashdash/node_modules/assert-plus/assert.js
new file mode 100644
index 00000000..70583f12
--- /dev/null
+++ b/tools/node_modules/cmdln/node_modules/dashdash/node_modules/assert-plus/assert.js
@@ -0,0 +1,196 @@
+// Copyright (c) 2012, Mark Cavage. All rights reserved.
+
+var assert = require('assert');
+var Stream = require('stream').Stream;
+var util = require('util');
+
+
+
+///--- Globals
+
+var NDEBUG = process.env.NODE_NDEBUG || false;
+
+
+
+///--- Messages
+
+var ARRAY_TYPE_REQUIRED = '%s ([%s]) required';
+var TYPE_REQUIRED = '%s (%s) is required';
+
+
+
+///--- Internal
+
+function capitalize(str) {
+        return (str.charAt(0).toUpperCase() + str.slice(1));
+}
+
+function uncapitalize(str) {
+        return (str.charAt(0).toLowerCase() + str.slice(1));
+}
+
+function _() {
+        return (util.format.apply(util, arguments));
+}
+
+
+function _assert(arg, type, name, stackFunc) {
+        if (!NDEBUG) {
+                name = name || type;
+                stackFunc = stackFunc || _assert.caller;
+                var t = typeof (arg);
+
+                if (t !== type) {
+                        throw new assert.AssertionError({
+                                message: _(TYPE_REQUIRED, name, type),
+                                actual: t,
+                                expected: type,
+                                operator: '===',
+                                stackStartFunction: stackFunc
+                        });
+                }
+        }
+}
+
+
+
+///--- API
+
+function array(arr, type, name) {
+        if (!NDEBUG) {
+                name = name || type;
+
+                if (!Array.isArray(arr)) {
+                        throw new assert.AssertionError({
+                                message: _(ARRAY_TYPE_REQUIRED, name, type),
+                                actual: typeof (arr),
+                                expected: 'array',
+                                operator: 'Array.isArray',
+                                stackStartFunction: array.caller
+                        });
+                }
+
+                for (var i = 0; i < arr.length; i++) {
+                        _assert(arr[i], type, name, array);
+                }
+        }
+}
+
+
+function bool(arg, name) {
+        _assert(arg, 'boolean', name, bool);
+}
+
+
+function buffer(arg, name) {
+        if (!Buffer.isBuffer(arg)) {
+                throw new assert.AssertionError({
+                        message: _(TYPE_REQUIRED, name, type),
+                        actual: typeof (arg),
+                        expected: 'buffer',
+                        operator: 'Buffer.isBuffer',
+                        stackStartFunction: buffer
+                });
+        }
+}
+
+
+function func(arg, name) {
+        _assert(arg, 'function', name);
+}
+
+
+function number(arg, name) {
+        _assert(arg, 'number', name);
+}
+
+
+function object(arg, name) {
+        _assert(arg, 'object', name);
+}
+
+
+function stream(arg, name) {
+        if (!(arg instanceof Stream)) {
+                throw new assert.AssertionError({
+                        message: _(TYPE_REQUIRED, name, type),
+                        actual: typeof (arg),
+                        expected: 'Stream',
+                        operator: 'instanceof',
+                        stackStartFunction: buffer
+                });
+        }
+}
+
+
+function string(arg, name) {
+        _assert(arg, 'string', name);
+}
+
+
+
+///--- Exports
+
+module.exports = {
+        bool: bool,
+        buffer: buffer,
+        func: func,
+        number: number,
+        object: object,
+        stream: stream,
+        string: string
+};
+
+
+Object.keys(module.exports).forEach(function (k) {
+        if (k === 'buffer')
+                return;
+
+        var name = 'arrayOf' + capitalize(k);
+
+        if (k === 'bool')
+                k = 'boolean';
+        if (k === 'func')
+                k = 'function';
+        module.exports[name] = function (arg, name) {
+                array(arg, k, name);
+        };
+});
+
+Object.keys(module.exports).forEach(function (k) {
+        var _name = 'optional' + capitalize(k);
+        var s = uncapitalize(k.replace('arrayOf', ''));
+        if (s === 'bool')
+                s = 'boolean';
+        if (s === 'func')
+                s = 'function';
+
+        if (k.indexOf('arrayOf') !== -1) {
+          module.exports[_name] = function (arg, name) {
+                  if (!NDEBUG && arg !== undefined) {
+                          array(arg, s, name);
+                  }
+          };
+        } else {
+          module.exports[_name] = function (arg, name) {
+                  if (!NDEBUG && arg !== undefined) {
+                          _assert(arg, s, name);
+                  }
+          };
+        }
+});
+
+
+// Reexport built-in assertions
+Object.keys(assert).forEach(function (k) {
+        if (k === 'AssertionError') {
+                module.exports[k] = assert[k];
+                return;
+        }
+
+        module.exports[k] = function () {
+                if (!NDEBUG) {
+                        assert[k].apply(assert[k], arguments);
+                }
+        };
+});
diff --git a/tools/node_modules/cmdln/node_modules/dashdash/node_modules/assert-plus/package.json b/tools/node_modules/cmdln/node_modules/dashdash/node_modules/assert-plus/package.json
new file mode 100644
index 00000000..8c7333da
--- /dev/null
+++ b/tools/node_modules/cmdln/node_modules/dashdash/node_modules/assert-plus/package.json
@@ -0,0 +1,28 @@
+{
+  "author": {
+    "name": "Mark Cavage",
+    "email": "mcavage@gmail.com"
+  },
+  "dependencies": {},
+  "description": "Extra assertions on top of node's assert module",
+  "devDependencies": {},
+  "directories": {},
+  "dist": {
+    "shasum": "d93ffdbb67ac5507779be316a7d65146417beef8",
+    "tarball": "https://registry.npmjs.org/assert-plus/-/assert-plus-0.1.2.tgz"
+  },
+  "engines": {
+    "node": ">=0.6"
+  },
+  "main": "./assert.js",
+  "maintainers": [
+    {
+      "name": "mcavage",
+      "email": "mcavage@gmail.com"
+    }
+  ],
+  "name": "assert-plus",
+  "optionalDependencies": {},
+  "readme": "ERROR: No README data found!",
+  "version": "0.1.2"
+}
\ No newline at end of file
diff --git a/tools/node_modules/cmdln/node_modules/dashdash/package.json b/tools/node_modules/cmdln/node_modules/dashdash/package.json
new file mode 100644
index 00000000..9b356d24
--- /dev/null
+++ b/tools/node_modules/cmdln/node_modules/dashdash/package.json
@@ -0,0 +1,40 @@
+{
+  "author": {
+    "name": "Trent Mick",
+    "url": "trentm.com"
+  },
+  "bugs": {
+    "url": "https://github.com/trentm/node-dashdash/issues"
+  },
+  "dependencies": {
+    "assert-plus": "0.1.2"
+  },
+  "description": "A light, featureful and explicit option parsing library.",
+  "devDependencies": {
+    "nodeunit": "0.7.4"
+  },
+  "directories": {},
+  "dist": {
+    "shasum": "1e76d13fadf25f8f50e70212c98a25beb1b3b8eb",
+    "tarball": "https://registry.npmjs.org/dashdash/-/dashdash-1.3.2.tgz"
+  },
+  "engines": {
+    "node": ">=0.8"
+  },
+  "homepage": "https://github.com/trentm/node-dashdash#readme",
+  "main": "./lib/dashdash.js",
+  "maintainers": [
+    {
+      "name": "trentm",
+      "email": "trentm@gmail.com"
+    }
+  ],
+  "name": "dashdash",
+  "optionalDependencies": {},
+  "readme": "ERROR: No README data found!",
+  "repository": {
+    "type": "git",
+    "url": "git://github.com/trentm/node-dashdash.git"
+  },
+  "version": "1.3.2"
+}
\ No newline at end of file
diff --git a/tools/node_modules/cmdln/node_modules/dashdash/test/basics.test.js b/tools/node_modules/cmdln/node_modules/dashdash/test/basics.test.js
new file mode 100644
index 00000000..58c977d4
--- /dev/null
+++ b/tools/node_modules/cmdln/node_modules/dashdash/test/basics.test.js
@@ -0,0 +1,774 @@
+/*
+ * dashdash tests
+ */
+
+var DEBUG = false;
+if (DEBUG) {
+    var debug = console.warn;
+} else {
+    var debug = function () {};
+}
+
+var format = require('util').format;
+
+
+// node-tap API
+if (require.cache[__dirname + '/tap4nodeunit.js'])
+    delete require.cache[__dirname + '/tap4nodeunit.js'];
+var tap4nodeunit = require('./tap4nodeunit.js');
+var after = tap4nodeunit.after;
+var before = tap4nodeunit.before;
+var test = tap4nodeunit.test;
+
+var dashdash = require('../lib/dashdash');
+
+
+// ---- globals
+
+var TEST_FILTER = process.env.TEST_FILTER;
+
+
+// ---- tests
+
+before(function (next) {
+    next();
+});
+
+test('exports', function (t) {
+    t.ok(dashdash.createParser, 'dashdash.createParser');
+    t.ok(dashdash.parse, 'dashdash.parse');
+    t.ok(dashdash.Parser, 'dashdash.Parser');
+    t.end();
+});
+
+test('createParser', function (t) {
+    var options = [{name: 'help', type: 'bool'}];
+    var parser = dashdash.createParser({options: options});
+    t.ok(parser);
+    t.end();
+});
+
+test('Parser', function (t) {
+    var options = [{name: 'help', type: 'bool'}];
+    var parser = new dashdash.Parser({options: options});
+    t.ok(parser);
+    t.end();
+});
+
+test('parse', function (t) {
+    var options = [{name: 'help', type: 'bool'}];
+    var argv = 'node tool.js --help'.split(/\s+/g);
+    var opts = dashdash.parse({options: options, argv: argv});
+    t.ok(opts);
+    t.end();
+});
+
+
+test('old Parser.parse() API', function (t) {
+    var options = [{name: 'v', type: 'bool'}];
+    var parser = new dashdash.Parser({options: options});
+    var opts = parser.parse('node tool.js -v'.split(/\s+/g));
+    t.ok(opts.v);
+    opts = parser.parse('-v'.split(/\s+/g), 0);
+    t.ok(opts.v);
+    t.end();
+});
+
+
+test('slice', function (t) {
+    var options = [{name: 'v', type: 'bool'}];
+    var parser = new dashdash.Parser({options: options});
+    var opts = parser.parse({argv: 'node tool.js -v'.split(/\s+/g)});
+    t.ok(opts.v);
+    t.equal(opts._args.length, 0);
+    var opts = parser.parse({argv: '-v'.split(/\s+/g), slice: 0});
+    t.ok(opts.v);
+    t.equal(opts._args.length, 0);
+    t.end();
+});
+
+
+var cases = [
+    // no opts
+    {
+        options: [],
+        argv: 'node tool.js',
+        expect: {
+            _args: []
+        }
+    },
+    {
+        options: [],
+        argv: 'node tool.js a b c',
+        expect: {
+            _args: ['a', 'b', 'c']
+        }
+    },
+    {
+        options: [ {name: 'help', type: 'bool'} ],
+        argv: 'node tool.js a b',
+        expect: {
+            _args: ['a', 'b']
+        }
+    },
+
+    // '--'
+    {
+        options: [ {name: 'help', type: 'bool'} ],
+        argv: 'node tool.js -- a',
+        expect: {
+            _args: ['a']
+        }
+    },
+    {
+        options: [ {name: 'help', type: 'bool'} ],
+        argv: 'node tool.js a -- b',
+        expect: {
+            _args: ['a', 'b']
+        }
+    },
+    {
+        options: [ {name: 'help', type: 'bool'} ],
+        argv: 'node tool.js a -- --help',
+        expect: {
+            _args: ['a', '--help']
+        }
+    },
+
+    // '--long-opt'
+    {
+        options: [ {name: 'help', type: 'bool'} ],
+        argv: 'node tool.js --help',
+        expect: {
+            help: true,
+            _args: []
+        }
+    },
+    {
+        options: [ {name: 'help', type: 'bool'} ],
+        argv: 'node tool.js --help a b',
+        expect: {
+            help: true,
+            _args: ['a', 'b']
+        }
+    },
+    {
+        options: [ {name: 'help', type: 'bool'} ],
+        argv: 'node tool.js a --help b',
+        expect: {
+            help: true,
+            _args: ['a', 'b']
+        }
+    },
+    {
+        options: [ {name: 'help', type: 'bool'} ],
+        argv: 'node tool.js a --help b',
+        interspersed: true,
+        expect: {
+            help: true,
+            _args: ['a', 'b']
+        }
+    },
+    {
+        options: [ {name: 'help', type: 'bool'} ],
+        argv: 'node tool.js a --help b',
+        interspersed: false,
+        expect: {
+            _args: ['a', '--help', 'b']
+        }
+    },
+    {
+        options: [ {name: 'help', type: 'bool'} ],
+        argv: 'node tool.js --help=foo',
+        expect: /argument given to .* option that does not take one/,
+    },
+    {
+        options: [ {name: 'file', type: 'string'} ],
+        argv: 'node tool.js --file',
+        expect: /do not have enough args/
+    },
+    {
+        options: [ {name: 'file', type: 'string', default: '/dev/null'} ],
+        argv: 'node tool.js',
+        expect: {
+            file: '/dev/null',
+            _args: []
+        }
+    },
+    {
+        options: [ {name: 'file', type: 'string'} ],
+        argv: 'node tool.js --file foo.txt',
+        expect: {
+            file: 'foo.txt',
+            _args: []
+        }
+    },
+    {
+        options: [ {name: 'file', type: 'string'} ],
+        argv: 'node tool.js --file=foo.txt',
+        expect: {
+            file: 'foo.txt',
+            _args: []
+        }
+    },
+
+    // short opts
+    {
+        options: [ {name: 'h', type: 'bool'} ],
+        argv: 'node tool.js -',
+        expect: {
+            _args: ['-']
+        }
+    },
+    {
+        options: [ {name: 'h', type: 'bool'} ],
+        argv: 'node tool.js -h',
+        expect: {
+            h: true,
+            _args: []
+        }
+    },
+    {
+        options: [ {name: 'f', type: 'string'} ],
+        argv: 'node tool.js -f',
+        expect: /do not have enough args/
+    },
+    {
+        options: [ {name: 'f', type: 'string'} ],
+        argv: 'node tool.js -f foo.txt',
+        expect: {
+            f: 'foo.txt',
+            _args: []
+        }
+    },
+    {
+        options: [ {name: 'f', type: 'string'} ],
+        argv: 'node tool.js -ffoo.txt',
+        expect: {
+            f: 'foo.txt',
+            _args: []
+        }
+    },
+    {
+        options: [ {name: 'l', type: 'bool'},
+                   {names: ['all', 'a'], type: 'bool'} ],
+        argv: 'node ls.js -l -a dir',
+        expect: {
+            l: true,
+            all: true,
+            _order: [ {key: 'l', value: true, from: 'argv'},
+                {key: 'all', value: true, from: 'argv'} ],
+            _args: ['dir']
+        }
+    },
+    {
+        options: [ {name: 'l', type: 'bool'},
+                   {names: ['all', 'a'], type: 'bool'} ],
+        argv: 'node ls.js -l dir -a',
+        expect: {
+            l: true,
+            all: true,
+            _order: [ {key: 'l', value: true, from: 'argv'},
+                {key: 'all', value: true, from: 'argv'} ],
+            _args: ['dir']
+        }
+    },
+    {
+        options: [ {name: 'l', type: 'bool'},
+                   {names: ['all', 'a'], type: 'bool'} ],
+        argv: 'node ls.js -l dir -a',
+        interspersed: false,
+        expect: {
+            l: true,
+            _order: [ {key: 'l', value: true, from: 'argv'} ],
+            _args: ['dir', '-a']
+        }
+    },
+    {
+        options: [ {name: 'l', type: 'bool'},
+                   {names: ['all', 'a'], type: 'bool'} ],
+        argv: 'node ls.js -la dir',
+        expect: {
+            l: true,
+            all: true,
+            _args: ['dir']
+        }
+    },
+
+    // type=number
+    {
+        options: [
+            {name: 'a', type: 'number'},
+            {name: 'b', type: 'number'},
+            {name: 'c', type: 'number'},
+            {name: 'd', type: 'number'},
+            {name: 'e', type: 'number'},
+            ],
+        argv: 'node tool.js -a 5 -b4 -c -1 -d -3.14159 -e 1.0e42 foo',
+        expect: {
+            a: 5,
+            b: 4,
+            c: -1,
+            d: -3.14159,
+            e: 1.0e42,
+            _args: ['foo']
+        }
+    },
+    {
+        options: [ {names: ['timeout', 't'], type: 'number'} ],
+        argv: 'node tool.js -t 5a',
+        /* JSSTYLED */
+        expect: /arg for "-t" is not a number/
+    },
+
+    // type: arrayOf*
+    {
+        options: [ {names: ['verbose', 'v'], type: 'arrayOfBool'} ],
+        argv: 'node tool.js -vvv foo bar',
+        expect: {
+            verbose: [true, true, true],
+            _args: ['foo', 'bar']
+        }
+    },
+    {
+        options: [ {names: ['verbose', 'v'], type: 'arrayOfBool'} ],
+        argv: 'node tool.js foo bar',
+        expect: {
+            // verbose: undefined,
+            _args: ['foo', 'bar']
+        }
+    },
+    {
+        options: [ {names: ['weapon', 'w'], type: 'arrayOfString'} ],
+        argv: 'node tool.js -w club --weapon mallet -w sword bang',
+        expect: {
+            weapon: ['club', 'mallet', 'sword'],
+            _args: ['bang']
+        }
+    },
+    {
+        options: [ {names: ['split', 's'], type: 'arrayOfNumber'} ],
+        argv: 'node tool.js --split 10 -s 5 -s 0.01 bang',
+        expect: {
+            split: [10, 5, 0.01],
+            _args: ['bang']
+        }
+    },
+
+    // help
+    {
+        options: [
+            {names: ['help', 'h'], type: 'bool', help: 'Show help and exit.'}
+        ],
+        argv: 'node tool.js --help',
+        expectHelp: /-h, --help\s+Show help and exit./
+    },
+
+    // integer
+    {
+        options: [ {name: 't', type: 'integer'} ],
+        argv: 'node tool.js -t 0',
+        expect: { t: 0, _args: [] }
+    },
+    {
+        options: [ {name: 't', type: 'integer'} ],
+        argv: 'node tool.js -t 42',
+        expect: { t: 42, _args: [] }
+    },
+    {
+        options: [ {name: 't', type: 'integer'} ],
+        argv: 'node tool.js -t42',
+        expect: { t: 42, _args: [] }
+    },
+    {
+        options: [ {name: 't', type: 'integer'} ],
+        argv: 'node tool.js -t -5',
+        expect: { t: -5, _args: [] }
+    },
+    {
+        options: [ {name: 't', type: 'integer'} ],
+        argv: 'node tool.js -t-5',
+        expect: { t: -5, _args: [] }
+    },
+    {
+        options: [ {name: 't', type: 'integer'} ],
+        argv: 'node tool.js -t 1e2',
+        /* JSSTYLED */
+        expect: /arg for "-t" is not an integer/
+    },
+    {
+        options: [ {name: 't', type: 'integer'} ],
+        argv: 'node tool.js -t 0x32',
+        /* JSSTYLED */
+        expect: /arg for "-t" is not an integer/
+    },
+    {
+        options: [ {name: 't', type: 'integer'} ],
+        argv: 'node tool.js -t 3.1',
+        /* JSSTYLED */
+        expect: /arg for "-t" is not an integer/
+    },
+    {
+        options: [ {name: 't', type: 'integer'} ],
+        argv: 'node tool.js -t 42.',
+        /* JSSTYLED */
+        expect: /arg for "-t" is not an integer/
+    },
+    {
+        options: [ {name: 't', type: 'integer'} ],
+        argv: 'node tool.js -t 1e-2',
+        /* JSSTYLED */
+        expect: /arg for "-t" is not an integer/
+    },
+    {
+        options: [ {name: 't', type: 'arrayOfInteger'} ],
+        argv: 'node tool.js',
+        expect: { _args: [] }
+    },
+    {
+        options: [ {name: 't', type: 'arrayOfInteger'} ],
+        argv: 'node tool.js -t 42',
+        expect: { t: [42], _args: [] }
+    },
+    {
+        options: [ {name: 't', type: 'arrayOfInteger'} ],
+        argv: 'node tool.js -t 1 -t 2 -t -3',
+        expect: { t: [1, 2, -3], _args: [] }
+    },
+    {
+        options: [ {name: 't', type: 'arrayOfInteger'} ],
+        argv: 'node tool.js -t 1 -t 1e2',
+        /* JSSTYLED */
+        expect: /arg for "-t" is not an integer/
+    },
+
+    // positiveInteger
+    {
+        options: [ {name: 't', type: 'positiveInteger'} ],
+        argv: 'node tool.js -t 0',
+        expect: { t: 0, _args: [] }
+    },
+    {
+        options: [ {name: 't', type: 'positiveInteger'} ],
+        argv: 'node tool.js -t 42',
+        expect: { t: 42, _args: [] }
+    },
+    {
+        options: [ {name: 't', type: 'positiveInteger'} ],
+        argv: 'node tool.js -t42',
+        expect: { t: 42, _args: [] }
+    },
+    {
+        options: [ {name: 't', type: 'positiveInteger'} ],
+        argv: 'node tool.js -t -5',
+        /* JSSTYLED */
+        expect: /arg for "-t" is not a positive integer/
+    },
+    {
+        options: [ {name: 't', type: 'arrayOfPositiveInteger'} ],
+        argv: 'node tool.js -t42',
+        expect: { t: [42], _args: [] }
+    },
+    {
+        options: [ {name: 't', type: 'arrayOfPositiveInteger'} ],
+        argv: 'node tool.js -t 42 -t -5',
+        /* JSSTYLED */
+        expect: /arg for "-t" is not a positive integer/
+    },
+
+    // env
+    {
+        options: [ {name: 'v', env: 'FOO_VERBOSE', type: 'bool'} ],
+        argv: 'node foo.js -v',
+        /* JSSTYLED */
+        expect: {
+            v: true,
+            _args: [],
+            _order: [ {key: 'v', value: true, from: 'argv'} ]
+        }
+    },
+    {
+        options: [ {name: 'v', env: 'FOO_VERBOSE', type: 'bool'} ],
+        argv: 'node foo.js -v',
+        env: {FOO_VERBOSE: '1'},
+        /* JSSTYLED */
+        expect: {
+            v: true,
+            _args: [],
+            _order: [ {key: 'v', value: true, from: 'argv'} ]
+        }
+    },
+    {
+        options: [ {name: 'v', env: 'FOO_VERBOSE', type: 'bool'} ],
+        argv: 'node foo.js',
+        env: {FOO_VERBOSE: '1'},
+        expect: {
+            v: true,
+            _args: [],
+            _order: [ {key: 'v', value: true, from: 'env'} ]
+        }
+    },
+    {
+        options: [ {name: 'v', env: 'FOO_VERBOSE', type: 'bool'} ],
+        argv: 'node foo.js',
+        env: {FOO_VERBOSE: '0'},
+        expect: {
+            v: false,
+            _args: [],
+            _order: [ {key: 'v', value: false, from: 'env'} ]
+        }
+    },
+    {
+        options: [ {name: 'v', env: 'FOO_VERBOSE', type: 'bool'} ],
+        argv: 'node foo.js',
+        env: {FOO_VERBOSE: ''},
+        /* JSSTYLED */
+        expect: { _args: [] }
+    },
+
+    // env help
+    {
+        options: [
+            {names: ['a'], type: 'string', env: 'A', help: 'Phrase'},
+            {names: ['b'], type: 'string', env: 'B', help: 'Sentence.'},
+            {names: ['c'], type: 'string', env: 'C', help: 'Question?'},
+            {names: ['d'], type: 'string', env: 'D', help: 'Exclamation!'},
+            {names: ['e'], type: 'string', env: 'E', help: ' '},
+            {names: ['f'], type: 'string', env: 'F', help: ''},
+            {names: ['g'], type: 'string', env: 'G'},
+            {names: ['h'], type: 'bool', env: 'H'},
+        ],
+        argv: 'node tool.js --help',
+        helpOptions: { includeEnv: true },
+        expectHelp: [
+            /-a ARG\s+Phrase. Environment: A=ARG/,
+            /-b ARG\s+Sentence. Environment: B=ARG/,
+            /-c ARG\s+Question\? Environment: C=ARG/,
+            /-d ARG\s+Exclamation! Environment: D=ARG/,
+            /-e ARG\s+Environment: E=ARG/,
+            /-f ARG\s+Environment: F=ARG/,
+            /-g ARG\s+Environment: G=ARG/,
+            /-h\s+Environment: H=1/,
+        ]
+    },
+
+    // env (number)
+    {
+        options: [ {names: ['timeout', 't'], env: 'FOO_TIMEOUT', type: 'number'} ],
+        argv: 'node foo.js -t 42',
+        env: {},
+        /* JSSTYLED */
+        expect: { timeout: 42, _args: [] }
+    },
+    {
+        options: [ {names: ['timeout', 't'], env: 'FOO_TIMEOUT', type: 'number'} ],
+        argv: 'node foo.js',
+        env: {FOO_TIMEOUT: '32'},
+        /* JSSTYLED */
+        expect: { timeout: 32, _args: [] }
+    },
+    {
+        options: [ {names: ['timeout', 't'], env: 'FOO_TIMEOUT', type: 'number'} ],
+        argv: 'node foo.js -t 52',
+        env: {FOO_TIMEOUT: '32'},
+        /* JSSTYLED */
+        expect: { timeout: 52, _args: [] }
+    },
+
+    // Test that a validation fail in env throws, but NOT if a valid
+    // value is given in CLI opts (i.e. when env is ignored).
+    {
+        options: [ {names: ['timeout', 't'], env: 'FOO_TIMEOUT', type: 'number'} ],
+        argv: 'node foo.js -t 52',
+        env: {FOO_TIMEOUT: 'wallawalla'},
+        /* JSSTYLED */
+        expect: { timeout: 52, _args: [] }
+    },
+    {
+        options: [ {names: ['timeout', 't'], env: 'FOO_TIMEOUT', type: 'number'} ],
+        argv: 'node foo.js',
+        env: {FOO_TIMEOUT: 'wallawalla'},
+        expect: /arg for "FOO_TIMEOUT" is not a number: "wallawalla"/
+    },
+
+    // env (arrayOfBool)
+    {
+        options: [ {name: 'v', env: 'FOO_VERBOSE', type: 'arrayOfBool'} ],
+        argv: 'node foo.js',
+        env: {FOO_VERBOSE: 'blah'},
+        /* JSSTYLED */
+        expect: { v: [true], _args: [] }
+    },
+    {
+        options: [ {name: 'v', env: 'FOO_VERBOSE', type: 'arrayOfBool'} ],
+        argv: 'node foo.js -v',
+        env: {FOO_VERBOSE: 'blah'},
+        /* JSSTYLED */
+        expect: { v: [true], _args: [] }
+    },
+    {
+        options: [ {name: 'v', env: 'FOO_VERBOSE', type: 'arrayOfBool'} ],
+        argv: 'node foo.js -vv',
+        env: {FOO_VERBOSE: 'blah'},
+        /* JSSTYLED */
+        expect: { v: [true, true], _args: [] }
+    },
+
+    // key name transformation
+    {
+        options: [ {names: ['dry-run', 'n'], type: 'bool'} ],
+        argv: 'node foo.js --dry-run',
+        /* JSSTYLED */
+        expect: { dry_run: true, _args: [] }
+    },
+    {
+        options: [ {name: 'foo-bar-', type: 'bool'} ],
+        argv: 'node foo.js --foo-bar-',
+        /* JSSTYLED */
+        expect: { foo_bar_: true, _args: [] }
+    },
+
+    // issue #1: 'env' not taking precendence over 'default'
+    {
+        options: [ {
+            names: ['file', 'f'],
+            env: 'FOO_FILE',
+            'default': 'default.file',
+            type: 'string'
+        } ],
+        argv: 'node foo.js',
+        expect: { file: 'default.file', _args: [] }
+    },
+    {
+        options: [ {
+            names: ['file', 'f'],
+            env: 'FOO_FILE',
+            'default': 'default.file',
+            type: 'string'
+        } ],
+        env: {FOO_FILE: 'env.file'},
+        argv: 'node foo.js',
+        expect: { file: 'env.file', _args: [] }
+    },
+    {
+        options: [ {
+            names: ['file', 'f'],
+            env: 'FOO_FILE',
+            'default': 'default.file',
+            type: 'string'
+        } ],
+        argv: 'node foo.js -f argv.file',
+        env: {FOO_FILE: 'env.file'},
+        expect: { file: 'argv.file', _args: [] }
+    },
+
+    {
+        options: [ {
+            names: ['verbose', 'v'],
+            env: 'FOO_VERBOSE',
+            'default': false,
+            type: 'bool'
+        } ],
+        argv: 'node foo.js',
+        expect: { verbose: false, _args: [] }
+    },
+    {
+        options: [ {
+            names: ['verbose', 'v'],
+            env: 'FOO_VERBOSE',
+            'default': false,
+            type: 'bool'
+        } ],
+        argv: 'node foo.js',
+        env: {FOO_VERBOSE: '1'},
+        expect: { verbose: true, _args: [] }
+    },
+    {
+        options: [ {
+            names: ['verbose', 'v'],
+            env: 'FOO_VERBOSE',
+            'default': false,
+            type: 'bool'
+        } ],
+        argv: 'node foo.js',
+        env: {FOO_VERBOSE: '0'},
+        expect: { verbose: false, _args: [] }
+    },
+    {
+        options: [ {
+            names: ['verbose', 'v'],
+            env: 'FOO_VERBOSE',
+            'default': false,
+            type: 'bool'
+        } ],
+        argv: 'node foo.js -v',
+        env: {FOO_VERBOSE: '0'},
+        expect: { verbose: true, _args: [] }
+    },
+];
+cases.forEach(function (c, num) {
+    var expect = c.expect;
+    delete c.expect;
+    var expectHelps = c.expectHelp;
+    if (!Array.isArray(expectHelps)) {
+        expectHelps = expectHelps ? [expectHelps] : [];
+        for (var i = 0; i < expectHelps.length; i++) {
+            if (typeof (expectHelps[i]) === 'string') {
+                expectHelps[i] = new RegExp(expectHelps[i]);
+            }
+        }
+    }
+    delete c.expectHelp;
+    var helpOptions = c.helpOptions;
+    delete c.helpOptions;
+    var argv = c.argv;
+    delete c.argv;
+    if (typeof (argv) === 'string') {
+        argv = argv.split(/\s+/);
+    }
+    var env = c.env;
+    delete c.env;
+    var envStr = '';
+    if (env) {
+        Object.keys(env).forEach(function (e) {
+            envStr += format('%s=%s ', e, env[e]);
+        });
+    }
+    var testName = format('case %d: %s%s', num, envStr, argv.join(' '));
+    if (TEST_FILTER && !~testName.indexOf(TEST_FILTER)) {
+        return;
+    }
+    test(testName, function (t) {
+        debug('--', num)
+        debug('c: %j', c)
+        var parser = new dashdash.Parser(c);
+        var opts;
+        if (expect instanceof RegExp) {
+            var error = null;
+            try {
+                opts = parser.parse({argv: argv, env: env});
+            } catch (e) {
+                error = e;
+                t.ok(expect.test(e.message), format(
+                    'error message did not match %s: "%s"',
+                    expect, e.message));
+            }
+            t.ok(error, 'expected an error');
+        } else if (expect) {
+            opts = parser.parse({argv: argv, env: env});
+            if (!expect._order) {
+                delete opts._order; // don't test it, if not in case data
+            }
+            debug('opts: %j', opts)
+            t.deepEqual(opts, expect);
+        }
+        if (expectHelps.length) {
+            var help = parser.help(helpOptions);
+            expectHelps.forEach(function (eH) {
+                t.ok(eH.test(help), format(
+                    'help did not match %s: "%s"', eH, help));
+            });
+        }
+        t.end();
+    });
+});
diff --git a/tools/node_modules/cmdln/node_modules/dashdash/test/tap4nodeunit.js b/tools/node_modules/cmdln/node_modules/dashdash/test/tap4nodeunit.js
new file mode 100644
index 00000000..76105e9a
--- /dev/null
+++ b/tools/node_modules/cmdln/node_modules/dashdash/test/tap4nodeunit.js
@@ -0,0 +1,59 @@
+/*
+ * Copyright 2012 Mark Cavage.  All rights reserved.
+ *
+ * Help nodeunit API feel like node-tap's.
+ *
+ * Usage:
+ *      if (require.cache[__dirname + '/tap4nodeunit.js'])
+ *          delete require.cache[__dirname + '/tap4nodeunit.js'];
+ *      var tap4nodeunit = require('./tap4nodeunit.js');
+ *      var after = tap4nodeunit.after;
+ *      var before = tap4nodeunit.before;
+ *      var test = tap4nodeunit.test;
+ */
+
+
+
+//---- Exports
+
+module.exports = {
+
+        after: function after(teardown) {
+                module.parent.exports.tearDown = function _teardown(callback) {
+                        try {
+                                teardown.call(this, callback);
+                        } catch (e) {
+                                console.error('after:\n' + e.stack);
+                                process.exit(1);
+                        }
+                };
+        },
+
+        before: function before(setup) {
+                module.parent.exports.setUp = function _setup(callback) {
+                        try {
+                                setup.call(this, callback);
+                        } catch (e) {
+                                console.error('before:\n' + e.stack);
+                                process.exit(1);
+                        }
+                };
+        },
+
+        test: function test(name, tester) {
+                module.parent.exports[name] = function _(t) {
+                        var _done = false;
+                        t.end = function end() {
+                                if (!_done) {
+                                        _done = true;
+                                        t.done();
+                                }
+                        };
+                        t.notOk = function notOk(ok, message) {
+                                return (t.ok(!ok, message));
+                        };
+
+                        tester.call(this, t);
+                };
+        }
+};
diff --git a/tools/node_modules/cmdln/node_modules/dashdash/tools/cutarelease.py b/tools/node_modules/cmdln/node_modules/dashdash/tools/cutarelease.py
new file mode 100755
index 00000000..2cfeb983
--- /dev/null
+++ b/tools/node_modules/cmdln/node_modules/dashdash/tools/cutarelease.py
@@ -0,0 +1,609 @@
+#!/usr/bin/env python
+# -*- coding: utf-8 -*-
+# Copyright (c) 2009-2012 Trent Mick
+
+"""cutarelease -- Cut a release of your project.
+
+A script that will help cut a release for a git-based project that follows
+a few conventions. It'll update your changelog (CHANGES.md), add a git
+tag, push those changes, update your version to the next patch level release
+and create a new changelog section for that new version.
+
+Conventions:
+- XXX
+"""
+
+__version_info__ = (1, 0, 7)
+__version__ = '.'.join(map(str, __version_info__))
+
+import sys
+import os
+from os.path import join, dirname, normpath, abspath, exists, basename, splitext
+from glob import glob
+from pprint import pprint
+import re
+import codecs
+import logging
+import optparse
+import json
+
+
+
+#---- globals and config
+
+log = logging.getLogger("cutarelease")
+
+class Error(Exception):
+    pass
+
+
+
+#---- main functionality
+
+def cutarelease(project_name, version_files, dry_run=False):
+    """Cut a release.
+
+    @param project_name {str}
+    @param version_files {list} List of paths to files holding the version
+        info for this project.
+
+        If none are given it attempts to guess the version file:
+        package.json or VERSION.txt or VERSION or $project_name.py
+        or lib/$project_name.py or $project_name.js or lib/$project_name.js.
+
+        The version file can be in one of the following forms:
+
+        - A .py file, in which case the file is expect to have a top-level
+          global called "__version_info__" as follows. [1]
+
+            __version_info__ = (0, 7, 6)
+
+          Note that I typically follow that with the following to get a
+          string version attribute on my modules:
+
+            __version__ = '.'.join(map(str, __version_info__))
+
+        - A .js file, in which case the file is expected to have a top-level
+          global called "VERSION" as follows:
+
+            ver VERSION = "1.2.3";
+
+        - A "package.json" file, typical of a node.js npm-using project.
+          The package.json file must have a "version" field.
+
+        - TODO: A simple version file whose only content is a "1.2.3"-style version
+          string.
+
+    [1]: This is a convention I tend to follow in my projects.
+        Granted it might not be your cup of tea. I should add support for
+        just `__version__ = "1.2.3"`. I'm open to other suggestions too.
+    """
+    dry_run_str = dry_run and " (dry-run)" or ""
+
+    if not version_files:
+        log.info("guessing version file")
+        candidates = [
+            "package.json",
+            "VERSION.txt",
+            "VERSION",
+            "%s.py" % project_name,
+            "lib/%s.py" % project_name,
+            "%s.js" % project_name,
+            "lib/%s.js" % project_name,
+        ]
+        for candidate in candidates:
+            if exists(candidate):
+                version_files = [candidate]
+                break
+        else:
+            raise Error("could not find a version file: specify its path or "
+                "add one of the following to your project: '%s'"
+                % "', '".join(candidates))
+        log.info("using '%s' as version file", version_files[0])
+
+    parsed_version_files = [_parse_version_file(f) for f in version_files]
+    version_file_type, version_info = parsed_version_files[0]
+    version = _version_from_version_info(version_info)
+
+    # Confirm
+    if not dry_run:
+        answer = query_yes_no("* * *\n"
+            "Are you sure you want cut a %s release?\n"
+            "This will involved commits and a push." % version,
+            default="no")
+        print "* * *"
+        if answer != "yes":
+            log.info("user abort")
+            return
+    log.info("cutting a %s release%s", version, dry_run_str)
+
+    # Checks: Ensure there is a section in changes for this version.
+
+
+
+    changes_path = "CHANGES.md"
+    changes_txt, changes, nyr = parse_changelog(changes_path)
+    #pprint(changes)
+    top_ver = changes[0]["version"]
+    if top_ver != version:
+        raise Error("changelog '%s' top section says "
+            "version %r, expected version %r: aborting"
+            % (changes_path, top_ver, version))
+    top_verline = changes[0]["verline"]
+    if not top_verline.endswith(nyr):
+        answer = query_yes_no("\n* * *\n"
+            "The changelog '%s' top section doesn't have the expected\n"
+            "'%s' marker. Has this been released already?"
+            % (changes_path, nyr), default="yes")
+        print "* * *"
+        if answer != "no":
+            log.info("abort")
+            return
+    top_body = changes[0]["body"]
+    if top_body.strip() == "(nothing yet)":
+        raise Error("top section body is `(nothing yet)': it looks like "
+            "nothing has been added to this release")
+
+    # Commits to prepare release.
+    changes_txt_before = changes_txt
+    changes_txt = changes_txt.replace(" (not yet released)", "", 1)
+    if not dry_run and changes_txt != changes_txt_before:
+        log.info("prepare `%s' for release", changes_path)
+        f = codecs.open(changes_path, 'w', 'utf-8')
+        f.write(changes_txt)
+        f.close()
+        run('git commit %s -m "prepare for %s release"'
+            % (changes_path, version))
+
+    # Tag version and push.
+    curr_tags = set(t for t in _capture_stdout(["git", "tag", "-l"]).split('\n') if t)
+    if not dry_run and version not in curr_tags:
+        log.info("tag the release")
+        run('git tag -a "%s" -m "version %s"' % (version, version))
+        run('git push --tags')
+
+    # Optionally release.
+    if exists("package.json"):
+        answer = query_yes_no("\n* * *\nPublish to npm?", default="yes")
+        print "* * *"
+        if answer == "yes":
+            if dry_run:
+                log.info("skipping npm publish (dry-run)")
+            else:
+                run('npm publish')
+    elif exists("setup.py"):
+        answer = query_yes_no("\n* * *\nPublish to pypi?", default="yes")
+        print "* * *"
+        if answer == "yes":
+            if dry_run:
+                log.info("skipping pypi publish (dry-run)")
+            else:
+                run("%spython setup.py sdist --formats zip upload"
+                    % _setup_command_prefix())
+
+    # Commits to prepare for future dev and push.
+    # - update changelog file
+    next_version_info = _get_next_version_info(version_info)
+    next_version = _version_from_version_info(next_version_info)
+    log.info("prepare for future dev (version %s)", next_version)
+    marker = "## " + changes[0]["verline"]
+    if marker.endswith(nyr):
+        marker = marker[0:-len(nyr)]
+    if marker not in changes_txt:
+        raise Error("couldn't find `%s' marker in `%s' "
+            "content: can't prep for subsequent dev" % (marker, changes_path))
+    next_verline = "%s %s%s" % (marker.rsplit(None, 1)[0], next_version, nyr)
+    changes_txt = changes_txt.replace(marker + '\n',
+        "%s\n\n(nothing yet)\n\n\n%s\n" % (next_verline, marker))
+    if not dry_run:
+        f = codecs.open(changes_path, 'w', 'utf-8')
+        f.write(changes_txt)
+        f.close()
+
+    # - update version file
+    next_version_tuple = _tuple_from_version(next_version)
+    for i, ver_file in enumerate(version_files):
+        ver_content = codecs.open(ver_file, 'r', 'utf-8').read()
+        ver_file_type, ver_info = parsed_version_files[i]
+        if ver_file_type == "json":
+            marker = '"version": "%s"' % version
+            if marker not in ver_content:
+                raise Error("couldn't find `%s' version marker in `%s' "
+                    "content: can't prep for subsequent dev" % (marker, ver_file))
+            ver_content = ver_content.replace(marker,
+                '"version": "%s"' % next_version)
+        elif ver_file_type == "javascript":
+            candidates = [
+                ("single", "var VERSION = '%s';" % version),
+                ("double", 'var VERSION = "%s";' % version),
+            ]
+            for quote_type, marker in candidates:
+                if marker in ver_content:
+                    break
+            else:
+                raise Error("couldn't find any candidate version marker in "
+                    "`%s' content: can't prep for subsequent dev: %r"
+                    % (ver_file, candidates))
+            if quote_type == "single":
+                ver_content = ver_content.replace(marker,
+                    "var VERSION = '%s';" % next_version)
+            else:
+                ver_content = ver_content.replace(marker,
+                    'var VERSION = "%s";' % next_version)
+        elif ver_file_type == "python":
+            marker = "__version_info__ = %r" % (version_info,)
+            if marker not in ver_content:
+                raise Error("couldn't find `%s' version marker in `%s' "
+                    "content: can't prep for subsequent dev" % (marker, ver_file))
+            ver_content = ver_content.replace(marker,
+                "__version_info__ = %r" % (next_version_tuple,))
+        elif ver_file_type == "version":
+            ver_content = next_version
+        else:
+            raise Error("unknown ver_file_type: %r" % ver_file_type)
+        if not dry_run:
+            log.info("update version to '%s' in '%s'", next_version, ver_file)
+            f = codecs.open(ver_file, 'w', 'utf-8')
+            f.write(ver_content)
+            f.close()
+
+    if not dry_run:
+        run('git commit %s %s -m "prep for future dev"' % (
+            changes_path, ' '.join(version_files)))
+        run('git push')
+
+
+
+#---- internal support routines
+
+def _indent(s, indent='    '):
+    return indent + indent.join(s.splitlines(True))
+
+def _tuple_from_version(version):
+    def _intify(s):
+        try:
+            return int(s)
+        except ValueError:
+            return s
+    return tuple(_intify(b) for b in version.split('.'))
+
+def _get_next_version_info(version_info):
+    next = list(version_info[:])
+    next[-1] += 1
+    return tuple(next)
+
+def _version_from_version_info(version_info):
+    v = str(version_info[0])
+    state_dot_join = True
+    for i in version_info[1:]:
+        if state_dot_join:
+            try:
+                int(i)
+            except ValueError:
+                state_dot_join = False
+            else:
+                pass
+        if state_dot_join:
+            v += "." + str(i)
+        else:
+            v += str(i)
+    return v
+
+_version_re = re.compile(r"^(\d+)\.(\d+)(?:\.(\d+)([abc](\d+)?)?)?$")
+def _version_info_from_version(version):
+    m = _version_re.match(version)
+    if not m:
+        raise Error("could not convert '%s' version to version info" % version)
+    version_info = []
+    for g in m.groups():
+        if g is None:
+            break
+        try:
+            version_info.append(int(g))
+        except ValueError:
+            version_info.append(g)
+    return tuple(version_info)
+
+def _parse_version_file(version_file):
+    """Get version info from the given file. It can be any of:
+
+    Supported version file types (i.e. types of files from which we know
+    how to parse the version string/number -- often by some convention):
+    - json: use the "version" key
+    - javascript: look for a `var VERSION = "1.2.3";` or
+      `var VERSION = '1.2.3';`
+    - python: Python script/module with `__version_info__ = (1, 2, 3)`
+    - version: a VERSION.txt or VERSION file where the whole contents are
+      the version string
+
+    @param version_file {str} Can be a path or "type:path", where "type"
+        is one of the supported types.
+    """
+    # Get version file *type*.
+    version_file_type = None
+    match = re.compile("^([a-z]+):(.*)$").search(version_file)
+    if match:
+        version_file = match.group(2)
+        version_file_type = match.group(1)
+        aliases = {
+            "js": "javascript"
+        }
+        if version_file_type in aliases:
+            version_file_type = aliases[version_file_type]
+
+    f = codecs.open(version_file, 'r', 'utf-8')
+    content = f.read()
+    f.close()
+
+    if not version_file_type:
+        # Guess the type.
+        base = basename(version_file)
+        ext = splitext(base)[1]
+        if ext == ".json":
+            version_file_type = "json"
+        elif ext == ".py":
+            version_file_type = "python"
+        elif ext == ".js":
+            version_file_type = "javascript"
+        elif content.startswith("#!"):
+            shebang = content.splitlines(False)[0]
+            shebang_bits = re.split(r'[/ \t]', shebang)
+            for name, typ in {"python": "python", "node": "javascript"}.items():
+                if name in shebang_bits:
+                    version_file_type = typ
+                    break
+        elif base in ("VERSION", "VERSION.txt"):
+            version_file_type = "version"
+    if not version_file_type:
+        raise RuntimeError("can't extract version from '%s': no idea "
+            "what type of file it it" % version_file)
+
+    if version_file_type == "json":
+        obj = json.loads(content)
+        version_info = _version_info_from_version(obj["version"])
+    elif version_file_type == "python":
+        m = re.search(r'^__version_info__ = (.*?)$', content, re.M)
+        version_info = eval(m.group(1))
+    elif version_file_type == "javascript":
+        m = re.search(r'^var VERSION = (\'|")(.*?)\1;$', content, re.M)
+        version_info = _version_info_from_version(m.group(2))
+    elif version_file_type == "version":
+        version_info = _version_info_from_version(content.strip())
+    else:
+        raise RuntimeError("unexpected version_file_type: %r"
+            % version_file_type)
+    return version_file_type, version_info
+
+
+def parse_changelog(changes_path):
+    """Parse the given changelog path and return `(content, parsed, nyr)`
+    where `nyr` is the ' (not yet released)' marker and `parsed` looks like:
+
+        [{'body': u'\n(nothing yet)\n\n',
+          'verline': u'restify 1.0.1 (not yet released)',
+          'version': u'1.0.1'},    # version is parsed out for top section only
+         {'body': u'...',
+          'verline': u'1.0.0'},
+         {'body': u'...',
+          'verline': u'1.0.0-rc2'},
+         {'body': u'...',
+          'verline': u'1.0.0-rc1'}]
+
+    A changelog (CHANGES.md) is expected to look like this:
+
+        # $project Changelog
+
+        ## $next_version (not yet released)
+
+        ...
+
+        ## $version1
+
+        ...
+
+        ## $version2
+
+        ... and so on
+
+    The version lines are enforced as follows:
+
+    - The top entry should have a " (not yet released)" suffix. "Should"
+      because recovery from half-cutarelease failures is supported.
+    - A version string must be extractable from there, but it tries to
+      be loose (though strict "X.Y.Z" versioning is preferred). Allowed
+
+            ## 1.0.0
+            ## my project 1.0.1
+            ## foo 1.2.3-rc2
+
+      Basically, (a) the " (not yet released)" is stripped, (b) the
+      last token is the version, and (c) that version must start with
+      a digit (sanity check).
+    """
+    if not exists(changes_path):
+        raise Error("changelog file '%s' not found" % changes_path)
+    content = codecs.open(changes_path, 'r', 'utf-8').read()
+
+    parser = re.compile(
+        r'^##\s*(?P<verline>[^\n]*?)\s*$(?P<body>.*?)(?=^##|\Z)',
+        re.M | re.S)
+    sections = parser.findall(content)
+
+    # Sanity checks on changelog format.
+    if not sections:
+        template = "## 1.0.0 (not yet released)\n\n(nothing yet)\n"
+        raise Error("changelog '%s' must have at least one section, "
+            "suggestion:\n\n%s" % (changes_path, _indent(template)))
+    first_section_verline = sections[0][0]
+    nyr = ' (not yet released)'
+    #if not first_section_verline.endswith(nyr):
+    #    eg = "## %s%s" % (first_section_verline, nyr)
+    #    raise Error("changelog '%s' top section must end with %r, "
+    #        "naive e.g.: '%s'" % (changes_path, nyr, eg))
+
+    items = []
+    for i, section in enumerate(sections):
+        item = {
+            "verline": section[0],
+            "body": section[1]
+        }
+        if i == 0:
+            # We only bother to pull out 'version' for the top section.
+            verline = section[0]
+            if verline.endswith(nyr):
+                verline = verline[0:-len(nyr)]
+            version = verline.split()[-1]
+            try:
+                int(version[0])
+            except ValueError:
+                msg = ''
+                if version.endswith(')'):
+                    msg = " (cutarelease is picky about the trailing %r " \
+                        "on the top version line. Perhaps you misspelled " \
+                        "that?)" % nyr
+                raise Error("changelog '%s' top section version '%s' is "
+                    "invalid: first char isn't a number%s"
+                    % (changes_path, version, msg))
+            item["version"] = version
+        items.append(item)
+
+    return content, items, nyr
+
+## {{{ http://code.activestate.com/recipes/577058/ (r2)
+def query_yes_no(question, default="yes"):
+    """Ask a yes/no question via raw_input() and return their answer.
+
+    "question" is a string that is presented to the user.
+    "default" is the presumed answer if the user just hits <Enter>.
+        It must be "yes" (the default), "no" or None (meaning
+        an answer is required of the user).
+
+    The "answer" return value is one of "yes" or "no".
+    """
+    valid = {"yes":"yes",   "y":"yes",  "ye":"yes",
+             "no":"no",     "n":"no"}
+    if default == None:
+        prompt = " [y/n] "
+    elif default == "yes":
+        prompt = " [Y/n] "
+    elif default == "no":
+        prompt = " [y/N] "
+    else:
+        raise ValueError("invalid default answer: '%s'" % default)
+
+    while 1:
+        sys.stdout.write(question + prompt)
+        choice = raw_input().lower()
+        if default is not None and choice == '':
+            return default
+        elif choice in valid.keys():
+            return valid[choice]
+        else:
+            sys.stdout.write("Please respond with 'yes' or 'no' "\
+                             "(or 'y' or 'n').\n")
+## end of http://code.activestate.com/recipes/577058/ }}}
+
+def _capture_stdout(argv):
+    import subprocess
+    p = subprocess.Popen(argv, stdout=subprocess.PIPE)
+    return p.communicate()[0]
+
+class _NoReflowFormatter(optparse.IndentedHelpFormatter):
+    """An optparse formatter that does NOT reflow the description."""
+    def format_description(self, description):
+        return description or ""
+
+def run(cmd):
+    """Run the given command.
+
+    Raises OSError is the command returns a non-zero exit status.
+    """
+    log.debug("running '%s'", cmd)
+    fixed_cmd = cmd
+    if sys.platform == "win32" and cmd.count('"') > 2:
+        fixed_cmd = '"' + cmd + '"'
+    retval = os.system(fixed_cmd)
+    if hasattr(os, "WEXITSTATUS"):
+        status = os.WEXITSTATUS(retval)
+    else:
+        status = retval
+    if status:
+        raise OSError(status, "error running '%s'" % cmd)
+
+def _setup_command_prefix():
+    prefix = ""
+    if sys.platform == "darwin":
+        # http://forums.macosxhints.com/archive/index.php/t-43243.html
+        # This is an Apple customization to `tar` to avoid creating
+        # '._foo' files for extended-attributes for archived files.
+        prefix = "COPY_EXTENDED_ATTRIBUTES_DISABLE=1 "
+    return prefix
+
+
+#---- mainline
+
+def main(argv):
+    logging.basicConfig(format="%(name)s: %(levelname)s: %(message)s")
+    log.setLevel(logging.INFO)
+
+    # Parse options.
+    parser = optparse.OptionParser(prog="cutarelease", usage='',
+        version="%prog " + __version__, description=__doc__,
+        formatter=_NoReflowFormatter())
+    parser.add_option("-v", "--verbose", dest="log_level",
+        action="store_const", const=logging.DEBUG,
+        help="more verbose output")
+    parser.add_option("-q", "--quiet", dest="log_level",
+        action="store_const", const=logging.WARNING,
+        help="quieter output (just warnings and errors)")
+    parser.set_default("log_level", logging.INFO)
+    parser.add_option("--test", action="store_true",
+        help="run self-test and exit (use 'eol.py -v --test' for verbose test output)")
+    parser.add_option("-p", "--project-name", metavar="NAME",
+        help='the name of this project (default is the base dir name)',
+        default=basename(os.getcwd()))
+    parser.add_option("-f", "--version-file", metavar="[TYPE:]PATH",
+        action='append', dest="version_files",
+        help='The path to the project file holding the version info. Can be '
+             'specified multiple times if more than one file should be updated '
+             'with new version info. If excluded, it will be guessed.')
+    parser.add_option("-n", "--dry-run", action="store_true",
+        help='Do a dry-run', default=False)
+    opts, args = parser.parse_args()
+    log.setLevel(opts.log_level)
+
+    cutarelease(opts.project_name, opts.version_files, dry_run=opts.dry_run)
+
+
+## {{{ http://code.activestate.com/recipes/577258/ (r5+)
+if __name__ == "__main__":
+    try:
+        retval = main(sys.argv)
+    except KeyboardInterrupt:
+        sys.exit(1)
+    except SystemExit:
+        raise
+    except:
+        import traceback, logging
+        if not log.handlers and not logging.root.handlers:
+            logging.basicConfig()
+        skip_it = False
+        exc_info = sys.exc_info()
+        if hasattr(exc_info[0], "__name__"):
+            exc_class, exc, tb = exc_info
+            if isinstance(exc, IOError) and exc.args[0] == 32:
+                # Skip 'IOError: [Errno 32] Broken pipe': often a cancelling of `less`.
+                skip_it = True
+            if not skip_it:
+                tb_path, tb_lineno, tb_func = traceback.extract_tb(tb)[-1][:3]
+                log.error("%s (%s:%s in %s)", exc_info[1], tb_path,
+                    tb_lineno, tb_func)
+        else:  # string exception
+            log.error(exc_info[0])
+        if not skip_it:
+            if log.isEnabledFor(logging.DEBUG):
+                traceback.print_exception(*exc_info)
+            sys.exit(1)
+    else:
+        sys.exit(retval)
+## end of http://code.activestate.com/recipes/577258/ }}}
diff --git a/tools/node_modules/cmdln/node_modules/dashdash/tools/jsstyle b/tools/node_modules/cmdln/node_modules/dashdash/tools/jsstyle
new file mode 100755
index 00000000..9df33c98
--- /dev/null
+++ b/tools/node_modules/cmdln/node_modules/dashdash/tools/jsstyle
@@ -0,0 +1,953 @@
+#!/usr/bin/env perl
+#
+# CDDL HEADER START
+#
+# The contents of this file are subject to the terms of the
+# Common Development and Distribution License (the "License").
+# You may not use this file except in compliance with the License.
+#
+# You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
+# or http://www.opensolaris.org/os/licensing.
+# See the License for the specific language governing permissions
+# and limitations under the License.
+#
+# When distributing Covered Code, include this CDDL HEADER in each
+# file and include the License file at usr/src/OPENSOLARIS.LICENSE.
+# If applicable, add the following below this CDDL HEADER, with the
+# fields enclosed by brackets "[]" replaced with your own identifying
+# information: Portions Copyright [yyyy] [name of copyright owner]
+#
+# CDDL HEADER END
+#
+#
+# Copyright 2008 Sun Microsystems, Inc.  All rights reserved.
+# Use is subject to license terms.
+#
+# Copyright 2011 Joyent, Inc. All rights reserved.
+#
+# jsstyle - check for some common stylistic errors.
+#
+#	jsstyle is a sort of "lint" for Javascript coding style.  This tool is
+#	derived from the cstyle tool, used to check for the style used in the
+#	Solaris kernel, sometimes known as "Bill Joy Normal Form".
+#
+#	There's a lot this can't check for, like proper indentation of code
+#	blocks.  There's also a lot more this could check for.
+#
+#	A note to the non perl literate:
+#
+#		perl regular expressions are pretty much like egrep
+#		regular expressions, with the following special symbols
+#
+#		\s	any space character
+#		\S	any non-space character
+#		\w	any "word" character [a-zA-Z0-9_]
+#		\W	any non-word character
+#		\d	a digit [0-9]
+#		\D	a non-digit
+#		\b	word boundary (between \w and \W)
+#		\B	non-word boundary
+#
+
+require 5.0;
+use IO::File;
+use Getopt::Std;
+use strict;
+
+my $usage =
+"Usage: jsstyle [-h?vcC] [-t <num>] [-f <path>] [-o <config>] file ...
+
+Check your JavaScript file for style.
+See <https://github.com/davepacheco/jsstyle> for details on config options.
+Report bugs to <https://github.com/davepacheco/jsstyle/issues>.
+
+Options:
+	-h 	print this help and exit
+	-v	verbose
+
+	-c	check continuation indentation inside functions
+	-t	specify tab width for line length calculation
+	-C	don't check anything in header block comments
+
+	-f PATH
+		path to a jsstyle config file
+	-o OPTION1,OPTION2
+		set config options, e.g. '-o doxygen,indent=2'
+
+";
+
+my %opts;
+
+if (!getopts("ch?o:t:f:vC", \%opts)) {
+	print $usage;
+	exit 2;
+}
+
+if (defined($opts{'h'}) || defined($opts{'?'})) {
+	print $usage;
+	exit;
+}
+
+my $check_continuation = $opts{'c'};
+my $verbose = $opts{'v'};
+my $ignore_hdr_comment = $opts{'C'};
+my $tab_width = $opts{'t'};
+
+# By default, tabs are 8 characters wide
+if (! defined($opts{'t'})) {
+	$tab_width = 8;
+}
+
+
+# Load config
+my %config = (
+	indent => "tab",
+	doxygen => 0,  	# doxygen comments: /** ... */
+	splint => 0,    # splint comments. Needed?
+	"unparenthesized-return" => 1,
+	"literal-string-quote" => "single",  # 'single' or 'double'
+	"blank-after-start-comment" => 1,
+	"continuation-at-front" => 0,
+	"leading-right-paren-ok" => 0,
+	"strict-indent" => 0
+);
+sub add_config_var ($$) {
+	my ($scope, $str) = @_;
+
+	if ($str !~ /^([\w-]+)(?:\s*=\s*(.*?))?$/) {
+		die "$scope: invalid option: '$str'";
+	}
+	my $name = $1;
+	my $value = ($2 eq '' ? 1 : $2);
+	#print "scope: '$scope', str: '$str', name: '$name', value: '$value'\n";
+
+	# Validate config var.
+	if ($name eq "indent") {
+		# A number of spaces or "tab".
+		if ($value !~ /^\d+$/ && $value ne "tab") {
+			die "$scope: invalid '$name': must be a number (of ".
+				"spaces) or 'tab'";
+		}
+	} elsif ($name eq "doxygen" ||   # boolean vars
+		 $name eq "splint" ||
+		 $name eq "unparenthesized-return" ||
+		 $name eq "continuation-at-front" ||
+		 $name eq "leading-right-paren-ok" ||
+		 $name eq "leading-comma-ok" ||
+		 $name eq "uncuddled-else-ok" ||
+		 $name eq "whitespace-after-left-paren-ok" ||
+		 $name eq "strict-indent" ||
+		 $name eq "blank-after-start-comment") {
+
+		if ($value != 1 && $value != 0) {
+			die "$scope: invalid '$name': don't give a value";
+		}
+	} elsif ($name eq "literal-string-quote") {
+		if ($value !~ /single|double/) {
+			die "$scope: invalid '$name': must be 'single' ".
+				"or 'double'";
+		}
+	} else {
+		die "$scope: unknown config var: $name";
+	}
+	$config{$name} = $value;
+}
+
+if (defined($opts{'f'})) {
+	my $path = $opts{'f'};
+	my $fh = new IO::File $path, "r";
+	if (!defined($fh)) {
+		die "cannot open config path '$path'";
+	}
+	my $line = 0;
+	while (<$fh>) {
+		$line++;
+		s/^\s*//;  # drop leading space
+		s/\s*$//;  # drop trailing space
+		next if ! $_;  # skip empty line
+		next if /^#/;  # skip comments
+		add_config_var "$path:$line", $_;
+	}
+}
+
+if (defined($opts{'o'})) {
+	for my $x (split /,/, $opts{'o'}) {
+		add_config_var "'-o' option", $x;
+	}
+}
+
+
+my ($filename, $line, $prev);		# shared globals
+
+my $fmt;
+my $hdr_comment_start;
+
+if ($verbose) {
+	$fmt = "%s: %d: %s\n%s\n";
+} else {
+	$fmt = "%s: %d: %s\n";
+}
+
+if ($config{"doxygen"}) {
+	# doxygen comments look like "/*!" or "/**"; allow them.
+	$hdr_comment_start = qr/^\s*\/\*[\!\*]?$/;
+} else {
+	$hdr_comment_start = qr/^\s*\/\*$/;
+}
+
+# Note, following must be in single quotes so that \s and \w work right.
+my $lint_re = qr/\/\*(?:
+	jsl:\w+?|ARGSUSED[0-9]*|NOTREACHED|LINTLIBRARY|VARARGS[0-9]*|
+	CONSTCOND|CONSTANTCOND|CONSTANTCONDITION|EMPTY|
+	FALLTHRU|FALLTHROUGH|LINTED.*?|PRINTFLIKE[0-9]*|
+	PROTOLIB[0-9]*|SCANFLIKE[0-9]*|JSSTYLED.*?
+    )\*\//x;
+
+my $splint_re = qr/\/\*@.*?@\*\//x;
+
+my $err_stat = 0;		# exit status
+
+if ($#ARGV >= 0) {
+	foreach my $arg (@ARGV) {
+		my $fh = new IO::File $arg, "r";
+		if (!defined($fh)) {
+			printf "%s: cannot open\n", $arg;
+		} else {
+			&jsstyle($arg, $fh);
+			close $fh;
+		}
+	}
+} else {
+	&jsstyle("<stdin>", *STDIN);
+}
+exit $err_stat;
+
+my $no_errs = 0;		# set for JSSTYLED-protected lines
+
+sub err($) {
+	my ($error) = @_;
+	unless ($no_errs) {
+		printf $fmt, $filename, $., $error, $line;
+		$err_stat = 1;
+	}
+}
+
+sub err_prefix($$) {
+	my ($prevline, $error) = @_;
+	my $out = $prevline."\n".$line;
+	unless ($no_errs) {
+		printf $fmt, $filename, $., $error, $out;
+		$err_stat = 1;
+	}
+}
+
+sub err_prev($) {
+	my ($error) = @_;
+	unless ($no_errs) {
+		printf $fmt, $filename, $. - 1, $error, $prev;
+		$err_stat = 1;
+	}
+}
+
+sub jsstyle($$) {
+
+my ($fn, $filehandle) = @_;
+$filename = $fn;			# share it globally
+
+my $in_cpp = 0;
+my $next_in_cpp = 0;
+
+my $in_comment = 0;
+my $in_header_comment = 0;
+my $comment_done = 0;
+my $in_function = 0;
+my $in_function_header = 0;
+my $in_declaration = 0;
+my $note_level = 0;
+my $nextok = 0;
+my $nocheck = 0;
+
+my $in_string = 0;
+
+my ($okmsg, $comment_prefix);
+
+$line = '';
+$prev = '';
+reset_indent();
+
+line: while (<$filehandle>) {
+	s/\r?\n$//;	# strip return and newline
+
+	# save the original line, then remove all text from within
+	# double or single quotes, we do not want to check such text.
+
+	$line = $_;
+
+	#
+	# C allows strings to be continued with a backslash at the end of
+	# the line.  We translate that into a quoted string on the previous
+	# line followed by an initial quote on the next line.
+	#
+	# (we assume that no-one will use backslash-continuation with character
+	# constants)
+	#
+	$_ = '"' . $_		if ($in_string && !$nocheck && !$in_comment);
+
+	#
+	# normal strings and characters
+	#
+	s/'([^\\']|\\.)*'/\'\'/g;
+	s/"([^\\"]|\\.)*"/\"\"/g;
+
+	#
+	# detect string continuation
+	#
+	if ($nocheck || $in_comment) {
+		$in_string = 0;
+	} else {
+		#
+		# Now that all full strings are replaced with "", we check
+		# for unfinished strings continuing onto the next line.
+		#
+		$in_string =
+		    (s/([^"](?:"")*)"([^\\"]|\\.)*\\$/$1""/ ||
+		    s/^("")*"([^\\"]|\\.)*\\$/""/);
+	}
+
+	#
+	# figure out if we are in a cpp directive
+	#
+	$in_cpp = $next_in_cpp || /^\s*#/;	# continued or started
+	$next_in_cpp = $in_cpp && /\\$/;	# only if continued
+
+	# strip off trailing backslashes, which appear in long macros
+	s/\s*\\$//;
+
+	# an /* END JSSTYLED */ comment ends a no-check block.
+	if ($nocheck) {
+		if (/\/\* *END *JSSTYLED *\*\//) {
+			$nocheck = 0;
+		} else {
+			reset_indent();
+			next line;
+		}
+	}
+
+	# a /*JSSTYLED*/ comment indicates that the next line is ok.
+	if ($nextok) {
+		if ($okmsg) {
+			err($okmsg);
+		}
+		$nextok = 0;
+		$okmsg = 0;
+		if (/\/\* *JSSTYLED.*\*\//) {
+			/^.*\/\* *JSSTYLED *(.*) *\*\/.*$/;
+			$okmsg = $1;
+			$nextok = 1;
+		}
+		$no_errs = 1;
+	} elsif ($no_errs) {
+		$no_errs = 0;
+	}
+
+	# check length of line.
+	# first, a quick check to see if there is any chance of being too long.
+	if ((($line =~ tr/\t/\t/) * ($tab_width - 1)) + length($line) > 80) {
+		# yes, there is a chance.
+		# replace tabs with spaces and check again.
+		my $eline = $line;
+		1 while $eline =~
+		    s/\t+/' ' x
+			(length($&) * $tab_width - length($`) % $tab_width)/e;
+		if (length($eline) > 80) {
+			err("line > 80 characters");
+		}
+	}
+
+	# ignore NOTE(...) annotations (assumes NOTE is on lines by itself).
+	if ($note_level || /\b_?NOTE\s*\(/) { # if in NOTE or this is NOTE
+		s/[^()]//g;			  # eliminate all non-parens
+		$note_level += s/\(//g - length;  # update paren nest level
+		next;
+	}
+
+	# a /* BEGIN JSSTYLED */ comment starts a no-check block.
+	if (/\/\* *BEGIN *JSSTYLED *\*\//) {
+		$nocheck = 1;
+	}
+
+	# a /*JSSTYLED*/ comment indicates that the next line is ok.
+	if (/\/\* *JSSTYLED.*\*\//) {
+		/^.*\/\* *JSSTYLED *(.*) *\*\/.*$/;
+		$okmsg = $1;
+		$nextok = 1;
+	}
+	if (/\/\/ *JSSTYLED/) {
+		/^.*\/\/ *JSSTYLED *(.*)$/;
+		$okmsg = $1;
+		$nextok = 1;
+	}
+
+	# universal checks; apply to everything
+	if (/\t +\t/) {
+		err("spaces between tabs");
+	}
+	if (/ \t+ /) {
+		err("tabs between spaces");
+	}
+	if (/\s$/) {
+		err("space or tab at end of line");
+	}
+	if (/[^ \t(]\/\*/ && !/\w\(\/\*.*\*\/\);/) {
+		err("comment preceded by non-blank");
+	}
+
+	# is this the beginning or ending of a function?
+	# (not if "struct foo\n{\n")
+	if (/^{$/ && $prev =~ /\)\s*(const\s*)?(\/\*.*\*\/\s*)?\\?$/) {
+		$in_function = 1;
+		$in_declaration = 1;
+		$in_function_header = 0;
+		$prev = $line;
+		next line;
+	}
+	if (/^}\s*(\/\*.*\*\/\s*)*$/) {
+		if ($prev =~ /^\s*return\s*;/) {
+			err_prev("unneeded return at end of function");
+		}
+		$in_function = 0;
+		reset_indent();		# we don't check between functions
+		$prev = $line;
+		next line;
+	}
+	if (/^\w*\($/) {
+		$in_function_header = 1;
+	}
+
+	# a blank line terminates the declarations within a function.
+	# XXX - but still a problem in sub-blocks.
+	if ($in_declaration && /^$/) {
+		$in_declaration = 0;
+	}
+
+	if ($comment_done) {
+		$in_comment = 0;
+		$in_header_comment = 0;
+		$comment_done = 0;
+	}
+	# does this looks like the start of a block comment?
+	if (/$hdr_comment_start/) {
+		if ($config{"indent"} eq "tab") {
+			if (!/^\t*\/\*/) {
+				err("block comment not indented by tabs");
+			}
+		} elsif (!/^ *\/\*/) {
+			err("block comment not indented by spaces");
+		}
+		$in_comment = 1;
+		/^(\s*)\//;
+		$comment_prefix = $1;
+		if ($comment_prefix eq "") {
+			$in_header_comment = 1;
+		}
+		$prev = $line;
+		next line;
+	}
+	# are we still in the block comment?
+	if ($in_comment) {
+		if (/^$comment_prefix \*\/$/) {
+			$comment_done = 1;
+		} elsif (/\*\//) {
+			$comment_done = 1;
+			err("improper block comment close")
+			    unless ($ignore_hdr_comment && $in_header_comment);
+		} elsif (!/^$comment_prefix \*[ \t]/ &&
+		    !/^$comment_prefix \*$/) {
+			err("improper block comment")
+			    unless ($ignore_hdr_comment && $in_header_comment);
+		}
+	}
+
+	if ($in_header_comment && $ignore_hdr_comment) {
+		$prev = $line;
+		next line;
+	}
+
+	# check for errors that might occur in comments and in code.
+
+	# allow spaces to be used to draw pictures in header comments.
+	#if (/[^ ]     / && !/".*     .*"/ && !$in_header_comment) {
+	#	err("spaces instead of tabs");
+	#}
+	#if (/^ / && !/^ \*[ \t\/]/ && !/^ \*$/ &&
+	#    (!/^    \w/ || $in_function != 0)) {
+	#	err("indent by spaces instead of tabs");
+	#}
+	if ($config{"indent"} eq "tab") {
+		if (/^ {2,}/ && !/^    [^ ]/) {
+			err("indent by spaces instead of tabs");
+		}
+	} elsif (/^\t/) {
+		err("indent by tabs instead of spaces")
+	} elsif (/^( +)/ && !$in_comment) {
+		my $indent = $1;
+		if (length($indent) < $config{"indent"}) {
+			err("indent of " . length($indent) .
+				" space(s) instead of " . $config{"indent"});
+		} elsif ($config{"strict-indent"} &&
+			length($indent) % $config{"indent"} != 0) {
+			err("indent is " . length($indent) .
+				" not a multiple of " . $config{'indent'} . " spaces");
+		}
+	}
+	if (/^\t+ [^ \t\*]/ || /^\t+  \S/ || /^\t+   \S/) {
+		err("continuation line not indented by 4 spaces");
+	}
+
+	# A multi-line block comment must not have content on the first line.
+	if (/^\s*\/\*./ && !/^\s*\/\*.*\*\// && !/$hdr_comment_start/) {
+		err("improper first line of block comment");
+	}
+
+	if ($in_comment) {	# still in comment, don't do further checks
+		$prev = $line;
+		next line;
+	}
+
+	if ((/[^(]\/\*\S/ || /^\/\*\S/) &&
+	    !(/$lint_re/ || ($config{"splint"} && /$splint_re/))) {
+		err("missing blank after open comment");
+	}
+	if (/\S\*\/[^)]|\S\*\/$/ &&
+	    !(/$lint_re/ || ($config{"splint"} && /$splint_re/))) {
+		err("missing blank before close comment");
+	}
+	if ($config{"blank-after-start-comment"} && /(?<!\w:)\/\/\S/) {	# C++ comments
+		err("missing blank after start comment");
+	}
+	# check for unterminated single line comments, but allow them when
+	# they are used to comment out the argument list of a function
+	# declaration.
+	if (/\S.*\/\*/ && !/\S.*\/\*.*\*\// && !/\(\/\*/) {
+		err("unterminated single line comment");
+	}
+
+	if (/^(#else|#endif|#include)(.*)$/) {
+		$prev = $line;
+		next line;
+	}
+
+	#
+	# delete any comments and check everything else.  Note that
+	# ".*?" is a non-greedy match, so that we don't get confused by
+	# multiple comments on the same line.
+	#
+	s/\/\*.*?\*\///g;
+	s/\/\/.*$//;		# C++ comments
+
+	# delete any trailing whitespace; we have already checked for that.
+	s/\s*$//;
+
+	# following checks do not apply to text in comments.
+	my $quote = $config{"literal-string-quote"};
+	if ($quote eq "single") {
+		if (/"/) {
+			err("literal string using double-quote instead of single");
+		}
+	} elsif ($quote eq "double") {
+		if (/'/) {
+			err("literal string using single-quote instead of double");
+		}
+	}
+
+	if (/[^=!<>\s][!<>=]=/ || /[^<>!=][!<>=]==?[^\s,=]/ ||
+	    (/[^->]>[^,=>\s]/ && !/[^->]>$/) ||
+	    (/[^<]<[^,=<\s]/ && !/[^<]<$/) ||
+	    /[^<\s]<[^<]/ || /[^->\s]>[^>]/) {
+		err("missing space around relational operator");
+	}
+	if (/\S>>=/ || /\S<<=/ || />>=\S/ || /<<=\S/ || /\S[-+*\/&|^%]=/ ||
+	    (/[^-+*\/&|^%!<>=\s]=[^=]/ && !/[^-+*\/&|^%!<>=\s]=$/) ||
+	    (/[^!<>=]=[^=\s]/ && !/[^!<>=]=$/)) {
+		# XXX - should only check this for C++ code
+		# XXX - there are probably other forms that should be allowed
+		if (!/\soperator=/) {
+			err("missing space around assignment operator");
+		}
+	}
+	if (/[,;]\S/ && !/\bfor \(;;\)/ &&
+	    # Allow a comma in a regex quantifier.
+	    !/\/.*?\{\d+,?\d*\}.*?\//) {
+		err("comma or semicolon followed by non-blank");
+	}
+	# check for commas preceded by blanks
+	if ((!$config{"leading-comma-ok"} && /^\s*,/) || (!/^\s*,/ && /\s,/)) {
+		err("comma preceded by blank");
+	}
+	# check for semicolons preceded by blanks
+	# allow "for" statements to have empty "while" clauses
+	if (/\s;/ && !/^[\t]+;$/ && !/^\s*for \([^;]*; ;[^;]*\)/) {
+		err("semicolon preceded by blank");
+	}
+	if (!$config{"continuation-at-front"} && /^\s*(&&|\|\|)/) {
+		err("improper boolean continuation");
+	} elsif ($config{"continuation-at-front"} && /(&&|\|\||\+)$/) {
+		err("improper continuation");
+	}
+	if (/\S   *(&&|\|\|)/ || /(&&|\|\|)   *\S/) {
+		err("more than one space around boolean operator");
+	}
+	# We allow methods which look like obj.delete() but not keywords without
+	# spaces ala: delete(obj)
+	if (/(?<!\.)\b(delete|typeof|instanceof|throw|with|catch|new|function|in|for|if|while|switch|return|case)\(/) {
+		err("missing space between keyword and paren");
+	}
+	if (/(\b(catch|for|if|with|while|switch|return)\b.*){2,}/) {
+		# multiple "case" and "sizeof" allowed
+		err("more than one keyword on line");
+	}
+	if (/\b(delete|typeof|instanceOf|with|throw|catch|new|function|in|for|if|while|switch|return|case)\s\s+\(/ &&
+	    !/^#if\s+\(/) {
+		err("extra space between keyword and paren");
+	}
+	# try to detect "func (x)" but not "if (x)" or
+	# "#define foo (x)" or "int (*func)();"
+	if (/\w\s\(/) {
+		my $s = $_;
+		# strip off all keywords on the line
+		s/\b(delete|typeof|instanceOf|throw|with|catch|new|function|in|for|if|while|switch|return|case)\s\(/XXX(/g;
+		s/#elif\s\(/XXX(/g;
+		s/^#define\s+\w+\s+\(/XXX(/;
+		# do not match things like "void (*f)();"
+		# or "typedef void (func_t)();"
+		s/\w\s\(+\*/XXX(*/g;
+		s/\b(void)\s+\(+/XXX(/og;
+		if (/\w\s\(/) {
+			err("extra space between function name and left paren");
+		}
+		$_ = $s;
+	}
+
+	if ($config{"unparenthesized-return"} &&
+	    /^\s*return\W[^;]*;/ && !/^\s*return\s*\(.*\);/) {
+		err("unparenthesized return expression");
+	}
+	if (/\btypeof\b/ && !/\btypeof\s*\(.*\)/) {
+		err("unparenthesized typeof expression");
+	}
+	if (!$config{"whitespace-after-left-paren-ok"} && /\(\s/) {
+		err("whitespace after left paren");
+	}
+	# allow "for" statements to have empty "continue" clauses
+	if (/\s\)/ && !/^\s*for \([^;]*;[^;]*; \)/) {
+		if ($config{"leading-right-paren-ok"} && /^\s+\)/) {
+			# this is allowed
+		} else {
+			err("whitespace before right paren");
+		}
+	}
+	if (/^\s*\(void\)[^ ]/) {
+		err("missing space after (void) cast");
+	}
+	if (/\S{/ && !/({|\(){/ &&
+	    # Allow a brace in a regex quantifier.
+	    !/\/.*?\{\d+,?\d*\}.*?\//) {
+		err("missing space before left brace");
+	}
+	if ($in_function && /^\s+{/ &&
+	    ($prev =~ /\)\s*$/ || $prev =~ /\bstruct\s+\w+$/)) {
+		err("left brace starting a line");
+	}
+	if (/}(else|while)/) {
+		err("missing space after right brace");
+	}
+	if (/}\s\s+(else|while)/) {
+		err("extra space after right brace");
+	}
+	if (/^\s+#/) {
+		err("preprocessor statement not in column 1");
+	}
+	if (/^#\s/) {
+		err("blank after preprocessor #");
+	}
+
+	#
+	# We completely ignore, for purposes of indentation:
+	#  * lines outside of functions
+	#  * preprocessor lines
+	#
+	if ($check_continuation && $in_function && !$in_cpp) {
+		process_indent($_);
+	}
+
+	if (/^\s*else\W/) {
+		if (!$config{"uncuddled-else-ok"} && $prev =~ /^\s*}$/) {
+			err_prefix($prev,
+			    "else and right brace should be on same line");
+		}
+	}
+	$prev = $line;
+}
+
+if ($prev eq "") {
+	err("last line in file is blank");
+}
+
+}
+
+#
+# Continuation-line checking
+#
+# The rest of this file contains the code for the continuation checking
+# engine.  It's a pretty simple state machine which tracks the expression
+# depth (unmatched '('s and '['s).
+#
+# Keep in mind that the argument to process_indent() has already been heavily
+# processed; all comments have been replaced by control-A, and the contents of
+# strings and character constants have been elided.
+#
+
+my $cont_in;		# currently inside of a continuation
+my $cont_off;		# skipping an initializer or definition
+my $cont_noerr;		# suppress cascading errors
+my $cont_start;		# the line being continued
+my $cont_base;		# the base indentation
+my $cont_first;		# this is the first line of a statement
+my $cont_multiseg;	# this continuation has multiple segments
+
+my $cont_special;	# this is a C statement (if, for, etc.)
+my $cont_macro;		# this is a macro
+my $cont_case;		# this is a multi-line case
+
+my @cont_paren;		# the stack of unmatched ( and [s we've seen
+
+sub
+reset_indent()
+{
+	$cont_in = 0;
+	$cont_off = 0;
+}
+
+sub
+delabel($)
+{
+	#
+	# replace labels with tabs.  Note that there may be multiple
+	# labels on a line.
+	#
+	local $_ = $_[0];
+
+	while (/^(\t*)( *(?:(?:\w+\s*)|(?:case\b[^:]*)): *)(.*)$/) {
+		my ($pre_tabs, $label, $rest) = ($1, $2, $3);
+		$_ = $pre_tabs;
+		while ($label =~ s/^([^\t]*)(\t+)//) {
+			$_ .= "\t" x (length($2) + length($1) / 8);
+		}
+		$_ .= ("\t" x (length($label) / 8)).$rest;
+	}
+
+	return ($_);
+}
+
+sub
+process_indent($)
+{
+	require strict;
+	local $_ = $_[0];			# preserve the global $_
+
+	s///g;	# No comments
+	s/\s+$//;	# Strip trailing whitespace
+
+	return			if (/^$/);	# skip empty lines
+
+	# regexps used below; keywords taking (), macros, and continued cases
+	my $special = '(?:(?:\}\s*)?else\s+)?(?:if|for|while|switch)\b';
+	my $macro = '[A-Z_][A-Z_0-9]*\(';
+	my $case = 'case\b[^:]*$';
+
+	# skip over enumerations, array definitions, initializers, etc.
+	if ($cont_off <= 0 && !/^\s*$special/ &&
+	    (/(?:(?:\b(?:enum|struct|union)\s*[^\{]*)|(?:\s+=\s*)){/ ||
+	    (/^\s*{/ && $prev =~ /=\s*(?:\/\*.*\*\/\s*)*$/))) {
+		$cont_in = 0;
+		$cont_off = tr/{/{/ - tr/}/}/;
+		return;
+	}
+	if ($cont_off) {
+		$cont_off += tr/{/{/ - tr/}/}/;
+		return;
+	}
+
+	if (!$cont_in) {
+		$cont_start = $line;
+
+		if (/^\t* /) {
+			err("non-continuation indented 4 spaces");
+			$cont_noerr = 1;		# stop reporting
+		}
+		$_ = delabel($_);	# replace labels with tabs
+
+		# check if the statement is complete
+		return		if (/^\s*\}?$/);
+		return		if (/^\s*\}?\s*else\s*\{?$/);
+		return		if (/^\s*do\s*\{?$/);
+		return		if (/{$/);
+		return		if (/}[,;]?$/);
+
+		# Allow macros on their own lines
+		return		if (/^\s*[A-Z_][A-Z_0-9]*$/);
+
+		# cases we don't deal with, generally non-kosher
+		if (/{/) {
+			err("stuff after {");
+			return;
+		}
+
+		# Get the base line, and set up the state machine
+		/^(\t*)/;
+		$cont_base = $1;
+		$cont_in = 1;
+		@cont_paren = ();
+		$cont_first = 1;
+		$cont_multiseg = 0;
+
+		# certain things need special processing
+		$cont_special = /^\s*$special/? 1 : 0;
+		$cont_macro = /^\s*$macro/? 1 : 0;
+		$cont_case = /^\s*$case/? 1 : 0;
+	} else {
+		$cont_first = 0;
+
+		# Strings may be pulled back to an earlier (half-)tabstop
+		unless ($cont_noerr || /^$cont_base    / ||
+		    (/^\t*(?:    )?(?:gettext\()?\"/ && !/^$cont_base\t/)) {
+			err_prefix($cont_start,
+			    "continuation should be indented 4 spaces");
+		}
+	}
+
+	my $rest = $_;			# keeps the remainder of the line
+
+	#
+	# The split matches 0 characters, so that each 'special' character
+	# is processed separately.  Parens and brackets are pushed and
+	# popped off the @cont_paren stack.  For normal processing, we wait
+	# until a ; or { terminates the statement.  "special" processing
+	# (if/for/while/switch) is allowed to stop when the stack empties,
+	# as is macro processing.  Case statements are terminated with a :
+	# and an empty paren stack.
+	#
+	foreach $_ (split /[^\(\)\[\]\{\}\;\:]*/) {
+		next		if (length($_) == 0);
+
+		# rest contains the remainder of the line
+		my $rxp = "[^\Q$_\E]*\Q$_\E";
+		$rest =~ s/^$rxp//;
+
+		if (/\(/ || /\[/) {
+			push @cont_paren, $_;
+		} elsif (/\)/ || /\]/) {
+			my $cur = $_;
+			tr/\)\]/\(\[/;
+
+			my $old = (pop @cont_paren);
+			if (!defined($old)) {
+				err("unexpected '$cur'");
+				$cont_in = 0;
+				last;
+			} elsif ($old ne $_) {
+				err("'$cur' mismatched with '$old'");
+				$cont_in = 0;
+				last;
+			}
+
+			#
+			# If the stack is now empty, do special processing
+			# for if/for/while/switch and macro statements.
+			#
+			next		if (@cont_paren != 0);
+			if ($cont_special) {
+				if ($rest =~ /^\s*{?$/) {
+					$cont_in = 0;
+					last;
+				}
+				if ($rest =~ /^\s*;$/) {
+					err("empty if/for/while body ".
+					    "not on its own line");
+					$cont_in = 0;
+					last;
+				}
+				if (!$cont_first && $cont_multiseg == 1) {
+					err_prefix($cont_start,
+					    "multiple statements continued ".
+					    "over multiple lines");
+					$cont_multiseg = 2;
+				} elsif ($cont_multiseg == 0) {
+					$cont_multiseg = 1;
+				}
+				# We've finished this section, start
+				# processing the next.
+				goto section_ended;
+			}
+			if ($cont_macro) {
+				if ($rest =~ /^$/) {
+					$cont_in = 0;
+					last;
+				}
+			}
+		} elsif (/\;/) {
+			if ($cont_case) {
+				err("unexpected ;");
+			} elsif (!$cont_special) {
+				err("unexpected ;")	if (@cont_paren != 0);
+				if (!$cont_first && $cont_multiseg == 1) {
+					err_prefix($cont_start,
+					    "multiple statements continued ".
+					    "over multiple lines");
+					$cont_multiseg = 2;
+				} elsif ($cont_multiseg == 0) {
+					$cont_multiseg = 1;
+				}
+				if ($rest =~ /^$/) {
+					$cont_in = 0;
+					last;
+				}
+				if ($rest =~ /^\s*special/) {
+					err("if/for/while/switch not started ".
+					    "on its own line");
+				}
+				goto section_ended;
+			}
+		} elsif (/\{/) {
+			err("{ while in parens/brackets") if (@cont_paren != 0);
+			err("stuff after {")		if ($rest =~ /[^\s}]/);
+			$cont_in = 0;
+			last;
+		} elsif (/\}/) {
+			err("} while in parens/brackets") if (@cont_paren != 0);
+			if (!$cont_special && $rest !~ /^\s*(while|else)\b/) {
+				if ($rest =~ /^$/) {
+					err("unexpected }");
+				} else {
+					err("stuff after }");
+				}
+				$cont_in = 0;
+				last;
+			}
+		} elsif (/\:/ && $cont_case && @cont_paren == 0) {
+			err("stuff after multi-line case") if ($rest !~ /$^/);
+			$cont_in = 0;
+			last;
+		}
+		next;
+section_ended:
+		# End of a statement or if/while/for loop.  Reset
+		# cont_special and cont_macro based on the rest of the
+		# line.
+		$cont_special = ($rest =~ /^\s*$special/)? 1 : 0;
+		$cont_macro = ($rest =~ /^\s*$macro/)? 1 : 0;
+		$cont_case = 0;
+		next;
+	}
+	$cont_noerr = 0			if (!$cont_in);
+}
diff --git a/tools/node_modules/cmdln/node_modules/extsprintf/.gitmodules b/tools/node_modules/cmdln/node_modules/extsprintf/.gitmodules
new file mode 100644
index 00000000..4e0f5e29
--- /dev/null
+++ b/tools/node_modules/cmdln/node_modules/extsprintf/.gitmodules
@@ -0,0 +1,6 @@
+[submodule "deps/jsstyle"]
+	path = deps/jsstyle
+	url = git://github.com/davepacheco/jsstyle
+[submodule "deps/javascriptlint"]
+	path = deps/javascriptlint
+	url = git://github.com/davepacheco/javascriptlint
diff --git a/tools/node_modules/cmdln/node_modules/extsprintf/LICENSE b/tools/node_modules/cmdln/node_modules/extsprintf/LICENSE
new file mode 100644
index 00000000..cbc0bb3b
--- /dev/null
+++ b/tools/node_modules/cmdln/node_modules/extsprintf/LICENSE
@@ -0,0 +1,19 @@
+Copyright (c) 2012, Joyent, Inc. All rights reserved.
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+THE SOFTWARE
diff --git a/tools/node_modules/cmdln/node_modules/extsprintf/Makefile b/tools/node_modules/cmdln/node_modules/extsprintf/Makefile
new file mode 100644
index 00000000..1deeb5fd
--- /dev/null
+++ b/tools/node_modules/cmdln/node_modules/extsprintf/Makefile
@@ -0,0 +1,23 @@
+#
+# Copyright (c) 2012, Joyent, Inc. All rights reserved.
+#
+# Makefile: top-level Makefile
+#
+# This Makefile contains only repo-specific logic and uses included makefiles
+# to supply common targets (javascriptlint, jsstyle, restdown, etc.), which are
+# used by other repos as well.
+#
+
+#
+# Files
+#
+JS_FILES	:= $(shell find lib -name '*.js')
+JSL_FILES_NODE   = $(JS_FILES)
+JSSTYLE_FILES	 = $(JS_FILES)
+JSL_CONF_NODE	 = jsl.node.conf
+
+# Default target is "check"
+check:
+
+include ./Makefile.deps
+include ./Makefile.targ
diff --git a/tools/node_modules/cmdln/node_modules/extsprintf/Makefile.deps b/tools/node_modules/cmdln/node_modules/extsprintf/Makefile.deps
new file mode 100644
index 00000000..2811bde1
--- /dev/null
+++ b/tools/node_modules/cmdln/node_modules/extsprintf/Makefile.deps
@@ -0,0 +1,39 @@
+# -*- mode: makefile -*-
+#
+# Copyright (c) 2012, Joyent, Inc. All rights reserved.
+#
+# Makefile.deps: Makefile for including common tools as dependencies
+#
+# NOTE: This makefile comes from the "eng" repo. It's designed to be dropped
+# into other repos as-is without requiring any modifications. If you find
+# yourself changing this file, you should instead update the original copy in
+# eng.git and then update your repo to use the new version.
+#
+# This file is separate from Makefile.targ so that teams can choose
+# independently whether to use the common targets in Makefile.targ and the
+# common tools here.
+#
+
+#
+# javascriptlint
+#
+JSL_EXEC	?= deps/javascriptlint/build/install/jsl
+JSL		?= python2.6 $(JSL_EXEC)
+
+$(JSL_EXEC): | deps/javascriptlint/.git
+	cd deps/javascriptlint && make install
+
+#
+# jsstyle
+#
+JSSTYLE_EXEC	?= deps/jsstyle/jsstyle
+JSSTYLE		?= $(JSSTYLE_EXEC)
+
+$(JSSTYLE_EXEC): | deps/jsstyle/.git
+
+#
+# restdown
+#
+RESTDOWN_EXEC	?= deps/restdown/bin/restdown
+RESTDOWN	?= python2.6 $(RESTDOWN_EXEC)
+$(RESTDOWN_EXEC): | deps/restdown/.git
diff --git a/tools/node_modules/cmdln/node_modules/extsprintf/Makefile.targ b/tools/node_modules/cmdln/node_modules/extsprintf/Makefile.targ
new file mode 100644
index 00000000..2a64fe7e
--- /dev/null
+++ b/tools/node_modules/cmdln/node_modules/extsprintf/Makefile.targ
@@ -0,0 +1,285 @@
+# -*- mode: makefile -*-
+#
+# Copyright (c) 2012, Joyent, Inc. All rights reserved.
+#
+# Makefile.targ: common targets.
+#
+# NOTE: This makefile comes from the "eng" repo. It's designed to be dropped
+# into other repos as-is without requiring any modifications. If you find
+# yourself changing this file, you should instead update the original copy in
+# eng.git and then update your repo to use the new version.
+#
+# This Makefile defines several useful targets and rules. You can use it by
+# including it from a Makefile that specifies some of the variables below.
+#
+# Targets defined in this Makefile:
+#
+#	check	Checks JavaScript files for lint and style
+#		Checks bash scripts for syntax
+#		Checks SMF manifests for validity against the SMF DTD
+#
+#	clean	Removes built files
+#
+#	docs	Builds restdown documentation in docs/
+#
+#	prepush	Depends on "check" and "test"
+#
+#	test	Does nothing (you should override this)
+#
+#	xref	Generates cscope (source cross-reference index)
+#
+# For details on what these targets are supposed to do, see the Joyent
+# Engineering Guide.
+#
+# To make use of these targets, you'll need to set some of these variables. Any
+# variables left unset will simply not be used.
+#
+#	BASH_FILES	Bash scripts to check for syntax
+#			(paths relative to top-level Makefile)
+#
+#	CLEAN_FILES	Files to remove as part of the "clean" target.  Note
+#			that files generated by targets in this Makefile are
+#			automatically included in CLEAN_FILES.  These include
+#			restdown-generated HTML and JSON files.
+#
+#	DOC_FILES	Restdown (documentation source) files. These are
+#			assumed to be contained in "docs/", and must NOT
+#			contain the "docs/" prefix.
+#
+#	JSL_CONF_NODE	Specify JavaScriptLint configuration files
+#	JSL_CONF_WEB	(paths relative to top-level Makefile)
+#
+#			Node.js and Web configuration files are separate
+#			because you'll usually want different global variable
+#			configurations.  If no file is specified, none is given
+#			to jsl, which causes it to use a default configuration,
+#			which probably isn't what you want.
+#
+#	JSL_FILES_NODE	JavaScript files to check with Node config file.
+#	JSL_FILES_WEB	JavaScript files to check with Web config file.
+#
+# You can also override these variables:
+#
+#	BASH		Path to bash (default: bash)
+#
+#	CSCOPE_DIRS	Directories to search for source files for the cscope
+#			index. (default: ".")
+#
+#	JSL		Path to JavaScriptLint (default: "jsl")
+#
+#	JSL_FLAGS_NODE	Additional flags to pass through to JSL
+#	JSL_FLAGS_WEB
+#	JSL_FLAGS
+#
+#	JSSTYLE		Path to jsstyle (default: jsstyle)
+#
+#	JSSTYLE_FLAGS	Additional flags to pass through to jsstyle
+#
+
+#
+# Defaults for the various tools we use.
+#
+BASH		?= bash
+BASHSTYLE	?= tools/bashstyle
+CP		?= cp
+CSCOPE		?= cscope
+CSCOPE_DIRS	?= .
+JSL		?= jsl
+JSSTYLE		?= jsstyle
+MKDIR		?= mkdir -p
+MV		?= mv
+RESTDOWN_FLAGS	?=
+RMTREE		?= rm -rf
+JSL_FLAGS  	?= --nologo --nosummary
+
+ifeq ($(shell uname -s),SunOS)
+	TAR	?= gtar
+else
+	TAR	?= tar
+endif
+
+
+#
+# Defaults for other fixed values.
+#
+BUILD		= build
+DISTCLEAN_FILES += $(BUILD)
+DOC_BUILD	= $(BUILD)/docs/public
+
+#
+# Configure JSL_FLAGS_{NODE,WEB} based on JSL_CONF_{NODE,WEB}.
+#
+ifneq ($(origin JSL_CONF_NODE), undefined)
+	JSL_FLAGS_NODE += --conf=$(JSL_CONF_NODE)
+endif
+
+ifneq ($(origin JSL_CONF_WEB), undefined)
+	JSL_FLAGS_WEB += --conf=$(JSL_CONF_WEB)
+endif
+
+#
+# Targets. For descriptions on what these are supposed to do, see the
+# Joyent Engineering Guide.
+#
+
+#
+# Instruct make to keep around temporary files. We have rules below that
+# automatically update git submodules as needed, but they employ a deps/*/.git
+# temporary file. Without this directive, make tries to remove these .git
+# directories after the build has completed.
+#
+.SECONDARY: $($(wildcard deps/*):%=%/.git)
+
+#
+# This rule enables other rules that use files from a git submodule to have
+# those files depend on deps/module/.git and have "make" automatically check
+# out the submodule as needed.
+#
+deps/%/.git:
+	git submodule update --init deps/$*
+
+#
+# These recipes make heavy use of dynamically-created phony targets. The parent
+# Makefile defines a list of input files like BASH_FILES. We then say that each
+# of these files depends on a fake target called filename.bashchk, and then we
+# define a pattern rule for those targets that runs bash in check-syntax-only
+# mode. This mechanism has the nice properties that if you specify zero files,
+# the rule becomes a noop (unlike a single rule to check all bash files, which
+# would invoke bash with zero files), and you can check individual files from
+# the command line with "make filename.bashchk".
+#
+.PHONY: check-bash
+check-bash: $(BASH_FILES:%=%.bashchk) $(BASH_FILES:%=%.bashstyle)
+
+%.bashchk: %
+	$(BASH) -n $^
+
+%.bashstyle: %
+	$(BASHSTYLE) $^
+
+.PHONY: check-jsl check-jsl-node check-jsl-web
+check-jsl: check-jsl-node check-jsl-web
+
+check-jsl-node: $(JSL_FILES_NODE:%=%.jslnodechk)
+
+check-jsl-web: $(JSL_FILES_WEB:%=%.jslwebchk)
+
+%.jslnodechk: % $(JSL_EXEC)
+	$(JSL) $(JSL_FLAGS) $(JSL_FLAGS_NODE) $<
+
+%.jslwebchk: % $(JSL_EXEC)
+	$(JSL) $(JSL_FLAGS) $(JSL_FLAGS_WEB) $<
+
+.PHONY: check-jsstyle
+check-jsstyle: $(JSSTYLE_FILES:%=%.jsstylechk)
+
+%.jsstylechk: % $(JSSTYLE_EXEC)
+	$(JSSTYLE) $(JSSTYLE_FLAGS) $<
+
+.PHONY: check
+check: check-jsl check-jsstyle check-bash
+	@echo check ok
+
+.PHONY: clean
+clean::
+	-$(RMTREE) $(CLEAN_FILES)
+
+.PHONY: distclean
+distclean:: clean
+	-$(RMTREE) $(DISTCLEAN_FILES)
+
+CSCOPE_FILES = cscope.in.out cscope.out cscope.po.out
+CLEAN_FILES += $(CSCOPE_FILES)
+
+.PHONY: xref
+xref: cscope.files
+	$(CSCOPE) -bqR
+
+.PHONY: cscope.files
+cscope.files:
+	find $(CSCOPE_DIRS) -name '*.c' -o -name '*.h' -o -name '*.cc' \
+	    -o -name '*.js' -o -name '*.s' -o -name '*.cpp' > $@
+
+#
+# The "docs" target is complicated because we do several things here:
+#
+#    (1) Use restdown to build HTML and JSON files from each of DOC_FILES.
+#
+#    (2) Copy these files into $(DOC_BUILD) (build/docs/public), which
+#        functions as a complete copy of the documentation that could be
+#        mirrored or served over HTTP.
+#
+#    (3) Then copy any directories and media from docs/media into
+#        $(DOC_BUILD)/media. This allows projects to include their own media,
+#        including files that will override same-named files provided by
+#        restdown.
+#
+# Step (3) is the surprisingly complex part: in order to do this, we need to
+# identify the subdirectories in docs/media, recreate them in
+# $(DOC_BUILD)/media, then do the same with the files.
+#
+DOC_MEDIA_DIRS := $(shell find docs/media -type d 2>/dev/null | grep -v "^docs/media$$")
+DOC_MEDIA_DIRS := $(DOC_MEDIA_DIRS:docs/media/%=%)
+DOC_MEDIA_DIRS_BUILD := $(DOC_MEDIA_DIRS:%=$(DOC_BUILD)/media/%)
+
+DOC_MEDIA_FILES := $(shell find docs/media -type f 2>/dev/null)
+DOC_MEDIA_FILES := $(DOC_MEDIA_FILES:docs/media/%=%)
+DOC_MEDIA_FILES_BUILD := $(DOC_MEDIA_FILES:%=$(DOC_BUILD)/media/%)
+
+#
+# Like the other targets, "docs" just depends on the final files we want to
+# create in $(DOC_BUILD), leveraging other targets and recipes to define how
+# to get there.
+#
+.PHONY: docs
+docs:							\
+    $(DOC_FILES:%.restdown=$(DOC_BUILD)/%.html)		\
+    $(DOC_FILES:%.restdown=$(DOC_BUILD)/%.json)		\
+    $(DOC_MEDIA_FILES_BUILD)
+
+#
+# We keep the intermediate files so that the next build can see whether the
+# files in DOC_BUILD are up to date.
+#
+.PRECIOUS:					\
+    $(DOC_FILES:%.restdown=docs/%.html)		\
+    $(DOC_FILES:%.restdown=docs/%json)
+
+#
+# We do clean those intermediate files, as well as all of DOC_BUILD.
+#
+CLEAN_FILES +=					\
+    $(DOC_BUILD)				\
+    $(DOC_FILES:%.restdown=docs/%.html)		\
+    $(DOC_FILES:%.restdown=docs/%.json)
+
+#
+# Before installing the files, we must make sure the directories exist. The |
+# syntax tells make that the dependency need only exist, not be up to date.
+# Otherwise, it might try to rebuild spuriously because the directory itself
+# appears out of date.
+#
+$(DOC_MEDIA_FILES_BUILD): | $(DOC_MEDIA_DIRS_BUILD)
+
+$(DOC_BUILD)/%: docs/% | $(DOC_BUILD)
+	$(CP) $< $@
+
+docs/%.json docs/%.html: docs/%.restdown | $(DOC_BUILD) $(RESTDOWN_EXEC)
+	$(RESTDOWN) $(RESTDOWN_FLAGS) -m $(DOC_BUILD) $<
+
+$(DOC_BUILD):
+	$(MKDIR) $@
+
+$(DOC_MEDIA_DIRS_BUILD):
+	$(MKDIR) $@
+
+#
+# The default "test" target does nothing. This should usually be overridden by
+# the parent Makefile. It's included here so we can define "prepush" without
+# requiring the repo to define "test".
+#
+.PHONY: test
+test:
+
+.PHONY: prepush
+prepush: check test
diff --git a/tools/node_modules/cmdln/node_modules/extsprintf/README.md b/tools/node_modules/cmdln/node_modules/extsprintf/README.md
new file mode 100644
index 00000000..702e4e22
--- /dev/null
+++ b/tools/node_modules/cmdln/node_modules/extsprintf/README.md
@@ -0,0 +1,39 @@
+# extsprintf: extended POSIX-style sprintf
+
+Stripped down version of s[n]printf(3c).  We make a best effort to throw an
+exception when given a format string we don't understand, rather than ignoring
+it, so that we won't break existing programs if/when we go implement the rest
+of this.
+
+This implementation currently supports specifying
+
+* field alignment ('-' flag),
+* zero-pad ('0' flag)
+* always show numeric sign ('+' flag),
+* field width
+* conversions for strings, decimal integers, and floats (numbers).
+* argument size specifiers.  These are all accepted but ignored, since
+  Javascript has no notion of the physical size of an argument.
+
+Everything else is currently unsupported, most notably: precision, unsigned
+numbers, non-decimal numbers, and characters.
+
+Besides the usual POSIX conversions, this implementation supports:
+
+* `%j`: pretty-print a JSON object (using node's "inspect")
+* `%r`: pretty-print an Error object
+
+# Example
+
+First, install it:
+
+    # npm install extsprintf
+
+Now, use it:
+
+    var mod_extsprintf = require('extsprintf');
+    console.log(mod_extsprintf.sprintf('hello %25s', 'world'));
+
+outputs:
+
+    hello                     world
diff --git a/tools/node_modules/cmdln/node_modules/extsprintf/examples/simple.js b/tools/node_modules/cmdln/node_modules/extsprintf/examples/simple.js
new file mode 100644
index 00000000..9f342f5b
--- /dev/null
+++ b/tools/node_modules/cmdln/node_modules/extsprintf/examples/simple.js
@@ -0,0 +1,2 @@
+var mod_extsprintf = require('extsprintf');
+console.log(mod_extsprintf.sprintf('hello %25s', 'world'));
diff --git a/tools/node_modules/cmdln/node_modules/extsprintf/jsl.node.conf b/tools/node_modules/cmdln/node_modules/extsprintf/jsl.node.conf
new file mode 100644
index 00000000..03f787ff
--- /dev/null
+++ b/tools/node_modules/cmdln/node_modules/extsprintf/jsl.node.conf
@@ -0,0 +1,137 @@
+#
+# Configuration File for JavaScript Lint 
+#
+# This configuration file can be used to lint a collection of scripts, or to enable
+# or disable warnings for scripts that are linted via the command line.
+#
+
+### Warnings
+# Enable or disable warnings based on requirements.
+# Use "+WarningName" to display or "-WarningName" to suppress.
+#
++ambiguous_else_stmt          # the else statement could be matched with one of multiple if statements (use curly braces to indicate intent
++ambiguous_nested_stmt        # block statements containing block statements should use curly braces to resolve ambiguity
++ambiguous_newline            # unexpected end of line; it is ambiguous whether these lines are part of the same statement
++anon_no_return_value         # anonymous function does not always return value
++assign_to_function_call      # assignment to a function call
+-block_without_braces         # block statement without curly braces
++comma_separated_stmts        # multiple statements separated by commas (use semicolons?)
++comparison_type_conv         # comparisons against null, 0, true, false, or an empty string allowing implicit type conversion (use === or !==)
++default_not_at_end           # the default case is not at the end of the switch statement
++dup_option_explicit          # duplicate "option explicit" control comment
++duplicate_case_in_switch     # duplicate case in switch statement
++duplicate_formal             # duplicate formal argument {name}
++empty_statement              # empty statement or extra semicolon
++identifier_hides_another     # identifer {name} hides an identifier in a parent scope
+-inc_dec_within_stmt          # increment (++) and decrement (--) operators used as part of greater statement
++incorrect_version            # Expected /*jsl:content-type*/ control comment. The script was parsed with the wrong version.
++invalid_fallthru             # unexpected "fallthru" control comment
++invalid_pass                 # unexpected "pass" control comment
++jsl_cc_not_understood        # couldn't understand control comment using /*jsl:keyword*/ syntax
++leading_decimal_point        # leading decimal point may indicate a number or an object member
++legacy_cc_not_understood     # couldn't understand control comment using /*@keyword@*/ syntax
++meaningless_block            # meaningless block; curly braces have no impact
++mismatch_ctrl_comments       # mismatched control comment; "ignore" and "end" control comments must have a one-to-one correspondence
++misplaced_regex              # regular expressions should be preceded by a left parenthesis, assignment, colon, or comma
++missing_break                # missing break statement
++missing_break_for_last_case  # missing break statement for last case in switch
++missing_default_case         # missing default case in switch statement
++missing_option_explicit      # the "option explicit" control comment is missing
++missing_semicolon            # missing semicolon
++missing_semicolon_for_lambda # missing semicolon for lambda assignment
++multiple_plus_minus          # unknown order of operations for successive plus (e.g. x+++y) or minus (e.g. x---y) signs
++nested_comment               # nested comment
++no_return_value              # function {name} does not always return a value
++octal_number                 # leading zeros make an octal number
++parseint_missing_radix       # parseInt missing radix parameter
++partial_option_explicit      # the "option explicit" control comment, if used, must be in the first script tag
++redeclared_var               # redeclaration of {name}
++trailing_comma_in_array      # extra comma is not recommended in array initializers
++trailing_decimal_point       # trailing decimal point may indicate a number or an object member
++undeclared_identifier        # undeclared identifier: {name}
++unreachable_code             # unreachable code
+-unreferenced_argument        # argument declared but never referenced: {name}
+-unreferenced_function        # function is declared but never referenced: {name}
++unreferenced_variable        # variable is declared but never referenced: {name}
++unsupported_version          # JavaScript {version} is not supported
++use_of_label                 # use of label
++useless_assign               # useless assignment
++useless_comparison           # useless comparison; comparing identical expressions
+-useless_quotes               # the quotation marks are unnecessary
++useless_void                 # use of the void type may be unnecessary (void is always undefined)
++var_hides_arg                # variable {name} hides argument
++want_assign_or_call          # expected an assignment or function call
++with_statement               # with statement hides undeclared variables; use temporary variable instead
+
+
+### Output format
+# Customize the format of the error message.
+#    __FILE__ indicates current file path
+#    __FILENAME__ indicates current file name
+#    __LINE__ indicates current line
+#    __COL__ indicates current column
+#    __ERROR__ indicates error message (__ERROR_PREFIX__: __ERROR_MSG__)
+#    __ERROR_NAME__ indicates error name (used in configuration file)
+#    __ERROR_PREFIX__ indicates error prefix
+#    __ERROR_MSG__ indicates error message
+#
+# For machine-friendly output, the output format can be prefixed with
+# "encode:". If specified, all items will be encoded with C-slashes.
+#
+# Visual Studio syntax (default):
++output-format __FILE__(__LINE__): __ERROR__
+# Alternative syntax:
+#+output-format __FILE__:__LINE__: __ERROR__
+
+
+### Context
+# Show the in-line position of the error.
+# Use "+context" to display or "-context" to suppress.
+#
++context
+
+
+### Control Comments
+# Both JavaScript Lint and the JScript interpreter confuse each other with the syntax for
+# the /*@keyword@*/ control comments and JScript conditional comments. (The latter is
+# enabled in JScript with @cc_on@). The /*jsl:keyword*/ syntax is preferred for this reason,
+# although legacy control comments are enabled by default for backward compatibility.
+#
+-legacy_control_comments
+
+
+### Defining identifiers
+# By default, "option explicit" is enabled on a per-file basis.
+# To enable this for all files, use "+always_use_option_explicit"
+-always_use_option_explicit
+
+# Define certain identifiers of which the lint is not aware.
+# (Use this in conjunction with the "undeclared identifier" warning.)
+#
+# Common uses for webpages might be:
++define __dirname
++define clearInterval
++define clearTimeout
++define console
++define exports
++define global
++define process
++define require
++define setInterval
++define setTimeout
++define Buffer
++define JSON
++define Math
+
+### JavaScript Version
+# To change the default JavaScript version:
+#+default-type text/javascript;version=1.5
+#+default-type text/javascript;e4x=1
+
+### Files
+# Specify which files to lint
+# Use "+recurse" to enable recursion (disabled by default).
+# To add a set of files, use "+process FileName", "+process Folder\Path\*.js",
+# or "+process Folder\Path\*.htm".
+#
+
diff --git a/tools/node_modules/cmdln/node_modules/extsprintf/lib/extsprintf.js b/tools/node_modules/cmdln/node_modules/extsprintf/lib/extsprintf.js
new file mode 100644
index 00000000..61ff891d
--- /dev/null
+++ b/tools/node_modules/cmdln/node_modules/extsprintf/lib/extsprintf.js
@@ -0,0 +1,166 @@
+/*
+ * extsprintf.js: extended POSIX-style sprintf
+ */
+
+var mod_assert = require('assert');
+var mod_util = require('util');
+
+/*
+ * Public interface
+ */
+exports.sprintf = jsSprintf;
+
+/*
+ * Stripped down version of s[n]printf(3c).  We make a best effort to throw an
+ * exception when given a format string we don't understand, rather than
+ * ignoring it, so that we won't break existing programs if/when we go implement
+ * the rest of this.
+ *
+ * This implementation currently supports specifying
+ *	- field alignment ('-' flag),
+ * 	- zero-pad ('0' flag)
+ *	- always show numeric sign ('+' flag),
+ *	- field width
+ *	- conversions for strings, decimal integers, and floats (numbers).
+ *	- argument size specifiers.  These are all accepted but ignored, since
+ *	  Javascript has no notion of the physical size of an argument.
+ *
+ * Everything else is currently unsupported, most notably precision, unsigned
+ * numbers, non-decimal numbers, and characters.
+ */
+function jsSprintf(fmt)
+{
+	var regex = [
+	    '([^%]*)',				/* normal text */
+	    '%',				/* start of format */
+	    '([\'\\-+ #0]*?)',			/* flags (optional) */
+	    '([1-9]\\d*)?',			/* width (optional) */
+	    '(\\.([1-9]\\d*))?',		/* precision (optional) */
+	    '[lhjztL]*?',			/* length mods (ignored) */
+	    '([diouxXfFeEgGaAcCsSp%jr])'	/* conversion */
+	].join('');
+
+	var re = new RegExp(regex);
+	var args = Array.prototype.slice.call(arguments, 1);
+	var flags, width, precision, conversion;
+	var left, pad, sign, arg, match;
+	var ret = '';
+	var argn = 1;
+
+	mod_assert.equal('string', typeof (fmt));
+
+	while ((match = re.exec(fmt)) !== null) {
+		ret += match[1];
+		fmt = fmt.substring(match[0].length);
+
+		flags = match[2] || '';
+		width = match[3] || 0;
+		precision = match[4] || '';
+		conversion = match[6];
+		left = false;
+		sign = false;
+		pad = ' ';
+
+		if (conversion == '%') {
+			ret += '%';
+			continue;
+		}
+
+		if (args.length === 0)
+			throw (new Error('too few args to sprintf'));
+
+		arg = args.shift();
+		argn++;
+
+		if (flags.match(/[\' #]/))
+			throw (new Error(
+			    'unsupported flags: ' + flags));
+
+		if (precision.length > 0)
+			throw (new Error(
+			    'non-zero precision not supported'));
+
+		if (flags.match(/-/))
+			left = true;
+
+		if (flags.match(/0/))
+			pad = '0';
+
+		if (flags.match(/\+/))
+			sign = true;
+
+		switch (conversion) {
+		case 's':
+			if (arg === undefined || arg === null)
+				throw (new Error('argument ' + argn +
+				    ': attempted to print undefined or null ' +
+				    'as a string'));
+			ret += doPad(pad, width, left, arg.toString());
+			break;
+
+		case 'd':
+			arg = Math.floor(arg);
+			/*jsl:fallthru*/
+		case 'f':
+			sign = sign && arg > 0 ? '+' : '';
+			ret += sign + doPad(pad, width, left,
+			    arg.toString());
+			break;
+
+		case 'j': /* non-standard */
+			if (width === 0)
+				width = 10;
+			ret += mod_util.inspect(arg, false, width);
+			break;
+
+		case 'r': /* non-standard */
+			ret += dumpException(arg);
+			break;
+
+		default:
+			throw (new Error('unsupported conversion: ' +
+			    conversion));
+		}
+	}
+
+	ret += fmt;
+	return (ret);
+}
+
+function doPad(chr, width, left, str)
+{
+	var ret = str;
+
+	while (ret.length < width) {
+		if (left)
+			ret += chr;
+		else
+			ret = chr + ret;
+	}
+
+	return (ret);
+}
+
+/*
+ * This function dumps long stack traces for exceptions having a cause() method.
+ * See node-verror for an example.
+ */
+function dumpException(ex)
+{
+	var ret;
+
+	if (!(ex instanceof Error))
+		throw (new Error(jsSprintf('invalid type for %%r: %j', ex)));
+
+	/* Note that V8 prepends "ex.stack" with ex.toString(). */
+	ret = 'EXCEPTION: ' + ex.constructor.name + ': ' + ex.stack;
+
+	if (ex.cause && typeof (ex.cause) === 'function') {
+		var cex = ex.cause();
+		if (cex) {
+			ret += '\nCaused by: ' + dumpException(cex);
+		}
+	}
+
+	return (ret);
+}
diff --git a/tools/node_modules/cmdln/node_modules/extsprintf/package.json b/tools/node_modules/cmdln/node_modules/extsprintf/package.json
new file mode 100644
index 00000000..6bba4291
--- /dev/null
+++ b/tools/node_modules/cmdln/node_modules/extsprintf/package.json
@@ -0,0 +1,32 @@
+{
+  "bugs": {
+    "url": "https://github.com/davepacheco/node-extsprintf/issues"
+  },
+  "dependencies": {},
+  "description": "extended POSIX-style sprintf",
+  "devDependencies": {},
+  "directories": {},
+  "dist": {
+    "shasum": "e1080e0658e300b06294990cc70e1502235fd550",
+    "tarball": "https://registry.npmjs.org/extsprintf/-/extsprintf-1.0.2.tgz"
+  },
+  "engines": [
+    "node >=0.6.0"
+  ],
+  "homepage": "https://github.com/davepacheco/node-extsprintf#readme",
+  "main": "./lib/extsprintf.js",
+  "maintainers": [
+    {
+      "name": "dap",
+      "email": "dap@cs.brown.edu"
+    }
+  ],
+  "name": "extsprintf",
+  "optionalDependencies": {},
+  "readme": "ERROR: No README data found!",
+  "repository": {
+    "type": "git",
+    "url": "git://github.com/davepacheco/node-extsprintf.git"
+  },
+  "version": "1.0.2"
+}
\ No newline at end of file
diff --git a/tools/node_modules/cmdln/node_modules/verror/.gitmodules b/tools/node_modules/cmdln/node_modules/verror/.gitmodules
new file mode 100644
index 00000000..e69de29b
diff --git a/tools/node_modules/cmdln/node_modules/verror/.npmignore b/tools/node_modules/cmdln/node_modules/verror/.npmignore
new file mode 100644
index 00000000..3c3629e6
--- /dev/null
+++ b/tools/node_modules/cmdln/node_modules/verror/.npmignore
@@ -0,0 +1 @@
+node_modules
diff --git a/tools/node_modules/cmdln/node_modules/verror/LICENSE b/tools/node_modules/cmdln/node_modules/verror/LICENSE
new file mode 100644
index 00000000..cbc0bb3b
--- /dev/null
+++ b/tools/node_modules/cmdln/node_modules/verror/LICENSE
@@ -0,0 +1,19 @@
+Copyright (c) 2012, Joyent, Inc. All rights reserved.
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+THE SOFTWARE
diff --git a/tools/node_modules/cmdln/node_modules/verror/Makefile b/tools/node_modules/cmdln/node_modules/verror/Makefile
new file mode 100644
index 00000000..00faa97d
--- /dev/null
+++ b/tools/node_modules/cmdln/node_modules/verror/Makefile
@@ -0,0 +1,35 @@
+#
+# Copyright (c) 2012, Joyent, Inc. All rights reserved.
+#
+# Makefile: top-level Makefile
+#
+# This Makefile contains only repo-specific logic and uses included makefiles
+# to supply common targets (javascriptlint, jsstyle, restdown, etc.), which are
+# used by other repos as well.
+#
+
+#
+# Tools
+#
+NPM		 = npm
+
+#
+# Files
+#
+JS_FILES	:= $(shell find lib examples tests -name '*.js')
+JSL_FILES_NODE   = $(JS_FILES)
+JSSTYLE_FILES	 = $(JS_FILES)
+JSL_CONF_NODE	 = jsl.node.conf
+
+.PHONY: all
+all:
+	$(NPM) install
+
+.PHONY: test
+test:
+	node tests/tst.inherit.js
+	node tests/tst.verror.js
+	node tests/tst.werror.js
+	@echo all tests passed
+
+include ./Makefile.targ
diff --git a/tools/node_modules/cmdln/node_modules/verror/Makefile.targ b/tools/node_modules/cmdln/node_modules/verror/Makefile.targ
new file mode 100644
index 00000000..2a64fe7e
--- /dev/null
+++ b/tools/node_modules/cmdln/node_modules/verror/Makefile.targ
@@ -0,0 +1,285 @@
+# -*- mode: makefile -*-
+#
+# Copyright (c) 2012, Joyent, Inc. All rights reserved.
+#
+# Makefile.targ: common targets.
+#
+# NOTE: This makefile comes from the "eng" repo. It's designed to be dropped
+# into other repos as-is without requiring any modifications. If you find
+# yourself changing this file, you should instead update the original copy in
+# eng.git and then update your repo to use the new version.
+#
+# This Makefile defines several useful targets and rules. You can use it by
+# including it from a Makefile that specifies some of the variables below.
+#
+# Targets defined in this Makefile:
+#
+#	check	Checks JavaScript files for lint and style
+#		Checks bash scripts for syntax
+#		Checks SMF manifests for validity against the SMF DTD
+#
+#	clean	Removes built files
+#
+#	docs	Builds restdown documentation in docs/
+#
+#	prepush	Depends on "check" and "test"
+#
+#	test	Does nothing (you should override this)
+#
+#	xref	Generates cscope (source cross-reference index)
+#
+# For details on what these targets are supposed to do, see the Joyent
+# Engineering Guide.
+#
+# To make use of these targets, you'll need to set some of these variables. Any
+# variables left unset will simply not be used.
+#
+#	BASH_FILES	Bash scripts to check for syntax
+#			(paths relative to top-level Makefile)
+#
+#	CLEAN_FILES	Files to remove as part of the "clean" target.  Note
+#			that files generated by targets in this Makefile are
+#			automatically included in CLEAN_FILES.  These include
+#			restdown-generated HTML and JSON files.
+#
+#	DOC_FILES	Restdown (documentation source) files. These are
+#			assumed to be contained in "docs/", and must NOT
+#			contain the "docs/" prefix.
+#
+#	JSL_CONF_NODE	Specify JavaScriptLint configuration files
+#	JSL_CONF_WEB	(paths relative to top-level Makefile)
+#
+#			Node.js and Web configuration files are separate
+#			because you'll usually want different global variable
+#			configurations.  If no file is specified, none is given
+#			to jsl, which causes it to use a default configuration,
+#			which probably isn't what you want.
+#
+#	JSL_FILES_NODE	JavaScript files to check with Node config file.
+#	JSL_FILES_WEB	JavaScript files to check with Web config file.
+#
+# You can also override these variables:
+#
+#	BASH		Path to bash (default: bash)
+#
+#	CSCOPE_DIRS	Directories to search for source files for the cscope
+#			index. (default: ".")
+#
+#	JSL		Path to JavaScriptLint (default: "jsl")
+#
+#	JSL_FLAGS_NODE	Additional flags to pass through to JSL
+#	JSL_FLAGS_WEB
+#	JSL_FLAGS
+#
+#	JSSTYLE		Path to jsstyle (default: jsstyle)
+#
+#	JSSTYLE_FLAGS	Additional flags to pass through to jsstyle
+#
+
+#
+# Defaults for the various tools we use.
+#
+BASH		?= bash
+BASHSTYLE	?= tools/bashstyle
+CP		?= cp
+CSCOPE		?= cscope
+CSCOPE_DIRS	?= .
+JSL		?= jsl
+JSSTYLE		?= jsstyle
+MKDIR		?= mkdir -p
+MV		?= mv
+RESTDOWN_FLAGS	?=
+RMTREE		?= rm -rf
+JSL_FLAGS  	?= --nologo --nosummary
+
+ifeq ($(shell uname -s),SunOS)
+	TAR	?= gtar
+else
+	TAR	?= tar
+endif
+
+
+#
+# Defaults for other fixed values.
+#
+BUILD		= build
+DISTCLEAN_FILES += $(BUILD)
+DOC_BUILD	= $(BUILD)/docs/public
+
+#
+# Configure JSL_FLAGS_{NODE,WEB} based on JSL_CONF_{NODE,WEB}.
+#
+ifneq ($(origin JSL_CONF_NODE), undefined)
+	JSL_FLAGS_NODE += --conf=$(JSL_CONF_NODE)
+endif
+
+ifneq ($(origin JSL_CONF_WEB), undefined)
+	JSL_FLAGS_WEB += --conf=$(JSL_CONF_WEB)
+endif
+
+#
+# Targets. For descriptions on what these are supposed to do, see the
+# Joyent Engineering Guide.
+#
+
+#
+# Instruct make to keep around temporary files. We have rules below that
+# automatically update git submodules as needed, but they employ a deps/*/.git
+# temporary file. Without this directive, make tries to remove these .git
+# directories after the build has completed.
+#
+.SECONDARY: $($(wildcard deps/*):%=%/.git)
+
+#
+# This rule enables other rules that use files from a git submodule to have
+# those files depend on deps/module/.git and have "make" automatically check
+# out the submodule as needed.
+#
+deps/%/.git:
+	git submodule update --init deps/$*
+
+#
+# These recipes make heavy use of dynamically-created phony targets. The parent
+# Makefile defines a list of input files like BASH_FILES. We then say that each
+# of these files depends on a fake target called filename.bashchk, and then we
+# define a pattern rule for those targets that runs bash in check-syntax-only
+# mode. This mechanism has the nice properties that if you specify zero files,
+# the rule becomes a noop (unlike a single rule to check all bash files, which
+# would invoke bash with zero files), and you can check individual files from
+# the command line with "make filename.bashchk".
+#
+.PHONY: check-bash
+check-bash: $(BASH_FILES:%=%.bashchk) $(BASH_FILES:%=%.bashstyle)
+
+%.bashchk: %
+	$(BASH) -n $^
+
+%.bashstyle: %
+	$(BASHSTYLE) $^
+
+.PHONY: check-jsl check-jsl-node check-jsl-web
+check-jsl: check-jsl-node check-jsl-web
+
+check-jsl-node: $(JSL_FILES_NODE:%=%.jslnodechk)
+
+check-jsl-web: $(JSL_FILES_WEB:%=%.jslwebchk)
+
+%.jslnodechk: % $(JSL_EXEC)
+	$(JSL) $(JSL_FLAGS) $(JSL_FLAGS_NODE) $<
+
+%.jslwebchk: % $(JSL_EXEC)
+	$(JSL) $(JSL_FLAGS) $(JSL_FLAGS_WEB) $<
+
+.PHONY: check-jsstyle
+check-jsstyle: $(JSSTYLE_FILES:%=%.jsstylechk)
+
+%.jsstylechk: % $(JSSTYLE_EXEC)
+	$(JSSTYLE) $(JSSTYLE_FLAGS) $<
+
+.PHONY: check
+check: check-jsl check-jsstyle check-bash
+	@echo check ok
+
+.PHONY: clean
+clean::
+	-$(RMTREE) $(CLEAN_FILES)
+
+.PHONY: distclean
+distclean:: clean
+	-$(RMTREE) $(DISTCLEAN_FILES)
+
+CSCOPE_FILES = cscope.in.out cscope.out cscope.po.out
+CLEAN_FILES += $(CSCOPE_FILES)
+
+.PHONY: xref
+xref: cscope.files
+	$(CSCOPE) -bqR
+
+.PHONY: cscope.files
+cscope.files:
+	find $(CSCOPE_DIRS) -name '*.c' -o -name '*.h' -o -name '*.cc' \
+	    -o -name '*.js' -o -name '*.s' -o -name '*.cpp' > $@
+
+#
+# The "docs" target is complicated because we do several things here:
+#
+#    (1) Use restdown to build HTML and JSON files from each of DOC_FILES.
+#
+#    (2) Copy these files into $(DOC_BUILD) (build/docs/public), which
+#        functions as a complete copy of the documentation that could be
+#        mirrored or served over HTTP.
+#
+#    (3) Then copy any directories and media from docs/media into
+#        $(DOC_BUILD)/media. This allows projects to include their own media,
+#        including files that will override same-named files provided by
+#        restdown.
+#
+# Step (3) is the surprisingly complex part: in order to do this, we need to
+# identify the subdirectories in docs/media, recreate them in
+# $(DOC_BUILD)/media, then do the same with the files.
+#
+DOC_MEDIA_DIRS := $(shell find docs/media -type d 2>/dev/null | grep -v "^docs/media$$")
+DOC_MEDIA_DIRS := $(DOC_MEDIA_DIRS:docs/media/%=%)
+DOC_MEDIA_DIRS_BUILD := $(DOC_MEDIA_DIRS:%=$(DOC_BUILD)/media/%)
+
+DOC_MEDIA_FILES := $(shell find docs/media -type f 2>/dev/null)
+DOC_MEDIA_FILES := $(DOC_MEDIA_FILES:docs/media/%=%)
+DOC_MEDIA_FILES_BUILD := $(DOC_MEDIA_FILES:%=$(DOC_BUILD)/media/%)
+
+#
+# Like the other targets, "docs" just depends on the final files we want to
+# create in $(DOC_BUILD), leveraging other targets and recipes to define how
+# to get there.
+#
+.PHONY: docs
+docs:							\
+    $(DOC_FILES:%.restdown=$(DOC_BUILD)/%.html)		\
+    $(DOC_FILES:%.restdown=$(DOC_BUILD)/%.json)		\
+    $(DOC_MEDIA_FILES_BUILD)
+
+#
+# We keep the intermediate files so that the next build can see whether the
+# files in DOC_BUILD are up to date.
+#
+.PRECIOUS:					\
+    $(DOC_FILES:%.restdown=docs/%.html)		\
+    $(DOC_FILES:%.restdown=docs/%json)
+
+#
+# We do clean those intermediate files, as well as all of DOC_BUILD.
+#
+CLEAN_FILES +=					\
+    $(DOC_BUILD)				\
+    $(DOC_FILES:%.restdown=docs/%.html)		\
+    $(DOC_FILES:%.restdown=docs/%.json)
+
+#
+# Before installing the files, we must make sure the directories exist. The |
+# syntax tells make that the dependency need only exist, not be up to date.
+# Otherwise, it might try to rebuild spuriously because the directory itself
+# appears out of date.
+#
+$(DOC_MEDIA_FILES_BUILD): | $(DOC_MEDIA_DIRS_BUILD)
+
+$(DOC_BUILD)/%: docs/% | $(DOC_BUILD)
+	$(CP) $< $@
+
+docs/%.json docs/%.html: docs/%.restdown | $(DOC_BUILD) $(RESTDOWN_EXEC)
+	$(RESTDOWN) $(RESTDOWN_FLAGS) -m $(DOC_BUILD) $<
+
+$(DOC_BUILD):
+	$(MKDIR) $@
+
+$(DOC_MEDIA_DIRS_BUILD):
+	$(MKDIR) $@
+
+#
+# The default "test" target does nothing. This should usually be overridden by
+# the parent Makefile. It's included here so we can define "prepush" without
+# requiring the repo to define "test".
+#
+.PHONY: test
+test:
+
+.PHONY: prepush
+prepush: check test
diff --git a/tools/node_modules/cmdln/node_modules/verror/README.md b/tools/node_modules/cmdln/node_modules/verror/README.md
new file mode 100644
index 00000000..e9b54978
--- /dev/null
+++ b/tools/node_modules/cmdln/node_modules/verror/README.md
@@ -0,0 +1,120 @@
+# verror: richer JavaScript errors
+
+This module provides two classes: VError, for accretive errors, and WError, for
+wrapping errors.  Both support printf-style error messages using extsprintf.
+
+## Printf-style errors
+
+At the most basic level, VError is just like JavaScript's Error class, but with
+printf-style arguments:
+
+    var verror = require('verror');
+
+    var opname = 'read';
+    var err = new verror.VError('"%s" operation failed', opname);
+    console.log(err.message);
+    console.log(err.stack);
+
+This prints:
+
+    "read" operation failed
+    "read" operation failed
+        at Object.<anonymous> (/Users/dap/node-verror/examples/varargs.js:4:11)
+        at Module._compile (module.js:449:26)
+        at Object.Module._extensions..js (module.js:467:10)
+        at Module.load (module.js:356:32)
+        at Function.Module._load (module.js:312:12)
+        at Module.runMain (module.js:492:10)
+        at process.startup.processNextTick.process._tickCallback (node.js:244:9)
+
+
+## VError for accretive error messages
+
+More interestingly, you can use VError to build up an error describing what
+happened at various levels in the stack.  For example, suppose you have a
+request handler that stats a file and fails if it doesn't exist:
+
+    var fs = require('fs');
+    var verror = require('verror');
+
+    function checkFile(filename, callback) {
+        fs.stat(filename, function (err) {
+            if (err)
+		/* Annotate the "stat" error with what we were doing. */
+	    	return (callback(new verror.VError(err,
+		    'failed to check "%s"', filename)));
+
+	    /* ... */
+        });
+    }
+
+    function handleRequest(filename, callback) {
+    	checkFile('/nonexistent', function (err) {
+    	    if (err) {
+    	    	/* Annotate the "checkFile" error with what we were doing. */
+    	    	return (callback(new verror.VError(err, 'request failed')));
+    	    }
+
+    	    /* ... */
+    	});
+    }
+
+    handleRequest('/nonexistent', function (err) {
+	if (err)
+		console.log(err.message);
+	/* ... */
+    });
+
+Since the file "/nonexistent" doesn't exist, this prints out:
+
+    request failed: failed to check "/nonexistent": ENOENT, stat '/nonexistent'
+
+The idea here is that the lowest level (Node's "fs.stat" function) generates an
+arbitrary error, and each higher level (request handler and stat callback)
+creates a new VError that annotates the previous error with what it was doing,
+so that the result is a clear message explaining what failed at each level.
+
+This plays nicely with extsprintf's "%r" specifier, which prints out a
+Java-style stacktrace with the whole chain of exceptions:
+
+    EXCEPTION: VError: request failed: failed to check "/nonexistent": ENOENT, stat '/nonexistent'
+        at /Users/dap/work/node-verror/examples/levels.js:21:21
+        at /Users/dap/work/node-verror/examples/levels.js:9:12
+        at Object.oncomplete (fs.js:297:15)
+    Caused by: EXCEPTION: VError: failed to check "/nonexistent": ENOENT, stat '/nonexistent'
+        at /Users/dap/work/node-verror/examples/levels.js:9:21
+        at Object.oncomplete (fs.js:297:15)
+    Caused by: EXCEPTION: Error: Error: ENOENT, stat '/nonexistent'
+
+
+## WError for wrapped errors
+
+Sometimes you don't want an Error's "message" field to include the details of
+all of the low-level errors, but you still want to be able to get at them
+programmatically.  For example, in an HTTP server, you probably don't want to
+spew all of the low-level errors back to the client, but you do want to include
+them in the audit log entry for the request.  In that case, you can use a
+WError, which is created exactly like VError (and also supports both
+printf-style arguments and an optional cause), but the resulting "message" only
+contains the top-level error.  It's also more verbose, including the class
+associated with each error in the cause chain.  Using the same example above,
+but replacing the VError in handleRequest with WError, we get this output:
+
+    request failed
+
+That's what we wanted -- just a high-level summary for the client.  But we can
+get the object's toString() for the full details:
+
+    WError: request failed; caused by WError: failed to check "/nonexistent";
+    caused by Error: ENOENT, stat '/nonexistent'
+
+# Contributing
+
+Contributions welcome.  Code should be "make check" clean.  To run "make check",
+you'll need these tools:
+
+* https://github.com/davepacheco/jsstyle
+* https://github.com/davepacheco/javascriptlint
+
+If you're changing something non-trivial or user-facing, you may want to submit
+an issue first.
diff --git a/tools/node_modules/cmdln/node_modules/verror/examples/levels-verror.js b/tools/node_modules/cmdln/node_modules/verror/examples/levels-verror.js
new file mode 100644
index 00000000..53a7022c
--- /dev/null
+++ b/tools/node_modules/cmdln/node_modules/verror/examples/levels-verror.js
@@ -0,0 +1,36 @@
+var extsprintf = require('extsprintf');
+var fs = require('fs');
+var verror = require('../lib/verror');
+
+function checkFile(filename, callback) {
+	fs.stat(filename, function (err) {
+		if (err)
+			/* Annotate the "stat" error with what we were doing. */
+			return (callback(new verror.VError(err,
+			    'failed to check "%s"', filename)));
+
+		/* ... */
+		return (callback());
+	});
+}
+
+function handleRequest(filename, callback) {
+	checkFile('/nonexistent', function (err) {
+		if (err)
+			/* Annotate the "checkFile" error. */
+			return (callback(new verror.VError(
+			    err, 'request failed')));
+
+		/* ... */
+		return (callback());
+	});
+}
+
+handleRequest('/nonexistent', function (err) {
+	if (err) {
+		console.log(err.message);
+		console.log(extsprintf.sprintf('%r', err));
+	}
+
+    /* ... */
+});
diff --git a/tools/node_modules/cmdln/node_modules/verror/examples/levels-werror.js b/tools/node_modules/cmdln/node_modules/verror/examples/levels-werror.js
new file mode 100644
index 00000000..7e570756
--- /dev/null
+++ b/tools/node_modules/cmdln/node_modules/verror/examples/levels-werror.js
@@ -0,0 +1,34 @@
+var extsprintf = require('extsprintf');
+var fs = require('fs');
+var verror = require('../lib/verror');
+
+function checkFile(filename, callback) {
+	fs.stat(filename, function (err) {
+		if (err)
+			/* Annotate the "stat" error with what we were doing. */
+			return (callback(new verror.VError(err,
+			    'failed to check "%s"', filename)));
+
+		/* ... */
+		return (callback());
+	});
+}
+
+function handleRequest(filename, callback) {
+	checkFile('/nonexistent', function (err) {
+		if (err)
+			/* Wrap the "checkFile" error. */
+			return (callback(new verror.WError(
+			    err, 'request failed')));
+
+		/* ... */
+		return (callback());
+	});
+}
+
+handleRequest('/nonexistent', function (err) {
+	if (err) {
+		console.log(err.message);
+		console.log(err.toString());
+	}
+});
diff --git a/tools/node_modules/cmdln/node_modules/verror/examples/varargs.js b/tools/node_modules/cmdln/node_modules/verror/examples/varargs.js
new file mode 100644
index 00000000..2e14ee48
--- /dev/null
+++ b/tools/node_modules/cmdln/node_modules/verror/examples/varargs.js
@@ -0,0 +1,6 @@
+var verror = require('../lib/verror');
+
+var opname = 'read';
+var err = new verror.VError('"%s" operation failed', opname);
+console.log(err.message);
+console.log(err.stack);
diff --git a/tools/node_modules/cmdln/node_modules/verror/examples/verror.js b/tools/node_modules/cmdln/node_modules/verror/examples/verror.js
new file mode 100644
index 00000000..887b181b
--- /dev/null
+++ b/tools/node_modules/cmdln/node_modules/verror/examples/verror.js
@@ -0,0 +1,13 @@
+var mod_fs = require('fs');
+var mod_verror = require('../lib/verror');
+
+var filename = '/nonexistent';
+
+mod_fs.stat(filename, function (err1) {
+	var err2 = new mod_verror.VError(err1, 'failed to stat "%s"', filename);
+
+	/* The following would normally be higher up the stack. */
+	var err3 = new mod_verror.VError(err2, 'failed to handle request');
+	console.log(err3.message);
+	console.log(err3.stack);
+});
diff --git a/tools/node_modules/cmdln/node_modules/verror/examples/werror.js b/tools/node_modules/cmdln/node_modules/verror/examples/werror.js
new file mode 100644
index 00000000..f55e5322
--- /dev/null
+++ b/tools/node_modules/cmdln/node_modules/verror/examples/werror.js
@@ -0,0 +1,14 @@
+var mod_fs = require('fs');
+var mod_verror = require('../lib/verror');
+
+var filename = '/nonexistent';
+
+mod_fs.stat(filename, function (err1) {
+	var err2 = new mod_verror.WError(err1, 'failed to stat "%s"', filename);
+
+	/* The following would normally be higher up the stack. */
+	var err3 = new mod_verror.WError(err2, 'failed to handle request');
+	console.log(err3.message);
+	console.log(err3.toString());
+	console.log(err3.stack);
+});
diff --git a/tools/node_modules/cmdln/node_modules/verror/jsl.node.conf b/tools/node_modules/cmdln/node_modules/verror/jsl.node.conf
new file mode 100644
index 00000000..bd724a2c
--- /dev/null
+++ b/tools/node_modules/cmdln/node_modules/verror/jsl.node.conf
@@ -0,0 +1,139 @@
+#
+# Configuration File for JavaScript Lint 
+#
+# This configuration file can be used to lint a collection of scripts, or to enable
+# or disable warnings for scripts that are linted via the command line.
+#
+
+### Warnings
+# Enable or disable warnings based on requirements.
+# Use "+WarningName" to display or "-WarningName" to suppress.
+#
++ambiguous_else_stmt          # the else statement could be matched with one of multiple if statements (use curly braces to indicate intent
++ambiguous_nested_stmt        # block statements containing block statements should use curly braces to resolve ambiguity
++ambiguous_newline            # unexpected end of line; it is ambiguous whether these lines are part of the same statement
++anon_no_return_value         # anonymous function does not always return value
++assign_to_function_call      # assignment to a function call
+-block_without_braces         # block statement without curly braces
++comma_separated_stmts        # multiple statements separated by commas (use semicolons?)
++comparison_type_conv         # comparisons against null, 0, true, false, or an empty string allowing implicit type conversion (use === or !==)
++default_not_at_end           # the default case is not at the end of the switch statement
++dup_option_explicit          # duplicate "option explicit" control comment
++duplicate_case_in_switch     # duplicate case in switch statement
++duplicate_formal             # duplicate formal argument {name}
++empty_statement              # empty statement or extra semicolon
++identifier_hides_another     # identifer {name} hides an identifier in a parent scope
+-inc_dec_within_stmt          # increment (++) and decrement (--) operators used as part of greater statement
++incorrect_version            # Expected /*jsl:content-type*/ control comment. The script was parsed with the wrong version.
++invalid_fallthru             # unexpected "fallthru" control comment
++invalid_pass                 # unexpected "pass" control comment
++jsl_cc_not_understood        # couldn't understand control comment using /*jsl:keyword*/ syntax
++leading_decimal_point        # leading decimal point may indicate a number or an object member
++legacy_cc_not_understood     # couldn't understand control comment using /*@keyword@*/ syntax
++meaningless_block            # meaningless block; curly braces have no impact
++mismatch_ctrl_comments       # mismatched control comment; "ignore" and "end" control comments must have a one-to-one correspondence
++misplaced_regex              # regular expressions should be preceded by a left parenthesis, assignment, colon, or comma
++missing_break                # missing break statement
++missing_break_for_last_case  # missing break statement for last case in switch
++missing_default_case         # missing default case in switch statement
++missing_option_explicit      # the "option explicit" control comment is missing
++missing_semicolon            # missing semicolon
++missing_semicolon_for_lambda # missing semicolon for lambda assignment
++multiple_plus_minus          # unknown order of operations for successive plus (e.g. x+++y) or minus (e.g. x---y) signs
++nested_comment               # nested comment
++no_return_value              # function {name} does not always return a value
++octal_number                 # leading zeros make an octal number
++parseint_missing_radix       # parseInt missing radix parameter
++partial_option_explicit      # the "option explicit" control comment, if used, must be in the first script tag
++redeclared_var               # redeclaration of {name}
++trailing_comma_in_array      # extra comma is not recommended in array initializers
++trailing_decimal_point       # trailing decimal point may indicate a number or an object member
++undeclared_identifier        # undeclared identifier: {name}
++unreachable_code             # unreachable code
+-unreferenced_argument        # argument declared but never referenced: {name}
+-unreferenced_function        # function is declared but never referenced: {name}
++unreferenced_variable        # variable is declared but never referenced: {name}
++unsupported_version          # JavaScript {version} is not supported
++use_of_label                 # use of label
++useless_assign               # useless assignment
++useless_comparison           # useless comparison; comparing identical expressions
+-useless_quotes               # the quotation marks are unnecessary
++useless_void                 # use of the void type may be unnecessary (void is always undefined)
++var_hides_arg                # variable {name} hides argument
++want_assign_or_call          # expected an assignment or function call
++with_statement               # with statement hides undeclared variables; use temporary variable instead
+
+
+### Output format
+# Customize the format of the error message.
+#    __FILE__ indicates current file path
+#    __FILENAME__ indicates current file name
+#    __LINE__ indicates current line
+#    __COL__ indicates current column
+#    __ERROR__ indicates error message (__ERROR_PREFIX__: __ERROR_MSG__)
+#    __ERROR_NAME__ indicates error name (used in configuration file)
+#    __ERROR_PREFIX__ indicates error prefix
+#    __ERROR_MSG__ indicates error message
+#
+# For machine-friendly output, the output format can be prefixed with
+# "encode:". If specified, all items will be encoded with C-slashes.
+#
+# Visual Studio syntax (default):
++output-format __FILE__(__LINE__): __ERROR__
+# Alternative syntax:
+#+output-format __FILE__:__LINE__: __ERROR__
+
+
+### Context
+# Show the in-line position of the error.
+# Use "+context" to display or "-context" to suppress.
+#
++context
+
+
+### Control Comments
+# Both JavaScript Lint and the JScript interpreter confuse each other with the syntax for
+# the /*@keyword@*/ control comments and JScript conditional comments. (The latter is
+# enabled in JScript with @cc_on@). The /*jsl:keyword*/ syntax is preferred for this reason,
+# although legacy control comments are enabled by default for backward compatibility.
+#
+-legacy_control_comments
+
+
+### Defining identifiers
+# By default, "option explicit" is enabled on a per-file basis.
+# To enable this for all files, use "+always_use_option_explicit"
+-always_use_option_explicit
+
+# Define certain identifiers of which the lint is not aware.
+# (Use this in conjunction with the "undeclared identifier" warning.)
+#
+# Common uses for webpages might be:
++define __dirname
++define clearInterval
++define clearTimeout
++define console
++define exports
++define global
++define process
++define require
++define setInterval
++define setTimeout
++define Buffer
++define JSON
++define Math
++define __dirname
++define __filename
+
+### JavaScript Version
+# To change the default JavaScript version:
+#+default-type text/javascript;version=1.5
+#+default-type text/javascript;e4x=1
+
+### Files
+# Specify which files to lint
+# Use "+recurse" to enable recursion (disabled by default).
+# To add a set of files, use "+process FileName", "+process Folder\Path\*.js",
+# or "+process Folder\Path\*.htm".
+#
+
diff --git a/tools/node_modules/cmdln/node_modules/verror/lib/verror.js b/tools/node_modules/cmdln/node_modules/verror/lib/verror.js
new file mode 100644
index 00000000..9ca087b1
--- /dev/null
+++ b/tools/node_modules/cmdln/node_modules/verror/lib/verror.js
@@ -0,0 +1,157 @@
+/*
+ * verror.js: richer JavaScript errors
+ */
+
+var mod_assert = require('assert');
+var mod_util = require('util');
+
+var mod_extsprintf = require('extsprintf');
+
+/*
+ * Public interface
+ */
+exports.VError = VError;
+exports.WError = WError;
+exports.MultiError = MultiError;
+
+/*
+ * Like JavaScript's built-in Error class, but supports a "cause" argument and a
+ * printf-style message.  The cause argument can be null.
+ */
+function VError(options)
+{
+	var args, causedBy, ctor, tailmsg;
+
+	if (options instanceof Error || typeof (options) === 'object') {
+		args = Array.prototype.slice.call(arguments, 1);
+	} else {
+		args = Array.prototype.slice.call(arguments, 0);
+		options = undefined;
+	}
+
+	tailmsg = args.length > 0 ?
+	    mod_extsprintf.sprintf.apply(null, args) : '';
+	this.jse_shortmsg = tailmsg;
+	this.jse_summary = tailmsg;
+
+	if (options) {
+		causedBy = options.cause;
+
+		if (!causedBy || !(options.cause instanceof Error))
+			causedBy = options;
+
+		if (causedBy && (causedBy instanceof Error)) {
+			this.jse_cause = causedBy;
+			this.jse_summary += ': ' + causedBy.message;
+		}
+	}
+
+	this.message = this.jse_summary;
+	Error.call(this, this.jse_summary);
+
+	if (Error.captureStackTrace) {
+		ctor = options ? options.constructorOpt : undefined;
+		ctor = ctor || arguments.callee;
+		Error.captureStackTrace(this, ctor);
+	}
+}
+
+mod_util.inherits(VError, Error);
+VError.prototype.name = 'VError';
+
+VError.prototype.toString = function ve_toString()
+{
+	var str = (this.hasOwnProperty('name') && this.name ||
+		this.constructor.name || this.constructor.prototype.name);
+	if (this.message)
+		str += ': ' + this.message;
+
+	return (str);
+};
+
+VError.prototype.cause = function ve_cause()
+{
+	return (this.jse_cause);
+};
+
+
+/*
+ * Represents a collection of errors for the purpose of consumers that generally
+ * only deal with one error.  Callers can extract the individual errors
+ * contained in this object, but may also just treat it as a normal single
+ * error, in which case a summary message will be printed.
+ */
+function MultiError(errors)
+{
+	mod_assert.ok(errors.length > 0);
+	this.ase_errors = errors;
+
+	VError.call(this, errors[0], 'first of %d error%s',
+	    errors.length, errors.length == 1 ? '' : 's');
+}
+
+mod_util.inherits(MultiError, VError);
+
+
+
+/*
+ * Like JavaScript's built-in Error class, but supports a "cause" argument which
+ * is wrapped, not "folded in" as with VError.	Accepts a printf-style message.
+ * The cause argument can be null.
+ */
+function WError(options)
+{
+	Error.call(this);
+
+	var args, cause, ctor;
+	if (typeof (options) === 'object') {
+		args = Array.prototype.slice.call(arguments, 1);
+	} else {
+		args = Array.prototype.slice.call(arguments, 0);
+		options = undefined;
+	}
+
+	if (args.length > 0) {
+		this.message = mod_extsprintf.sprintf.apply(null, args);
+	} else {
+		this.message = '';
+	}
+
+	if (options) {
+		if (options instanceof Error) {
+			cause = options;
+		} else {
+			cause = options.cause;
+			ctor = options.constructorOpt;
+		}
+	}
+
+	Error.captureStackTrace(this, ctor || this.constructor);
+	if (cause)
+		this.cause(cause);
+
+}
+
+mod_util.inherits(WError, Error);
+WError.prototype.name = 'WError';
+
+
+WError.prototype.toString = function we_toString()
+{
+	var str = (this.hasOwnProperty('name') && this.name ||
+		this.constructor.name || this.constructor.prototype.name);
+	if (this.message)
+		str += ': ' + this.message;
+	if (this.we_cause && this.we_cause.message)
+		str += '; caused by ' + this.we_cause.toString();
+
+	return (str);
+};
+
+WError.prototype.cause = function we_cause(c)
+{
+	if (c instanceof Error)
+		this.we_cause = c;
+
+	return (this.we_cause);
+};
diff --git a/tools/node_modules/cmdln/node_modules/verror/package.json b/tools/node_modules/cmdln/node_modules/verror/package.json
new file mode 100644
index 00000000..35a7ee95
--- /dev/null
+++ b/tools/node_modules/cmdln/node_modules/verror/package.json
@@ -0,0 +1,37 @@
+{
+  "bugs": {
+    "url": "https://github.com/davepacheco/node-verror/issues"
+  },
+  "dependencies": {
+    "extsprintf": "1.0.2"
+  },
+  "description": "richer JavaScript errors",
+  "devDependencies": {},
+  "directories": {},
+  "dist": {
+    "shasum": "cff5df12946d297d2baaefaa2689e25be01c005c",
+    "tarball": "https://registry.npmjs.org/verror/-/verror-1.3.6.tgz"
+  },
+  "engines": [
+    "node >=0.6.0"
+  ],
+  "homepage": "https://github.com/davepacheco/node-verror#readme",
+  "main": "./lib/verror.js",
+  "maintainers": [
+    {
+      "name": "dap",
+      "email": "dap@cs.brown.edu"
+    }
+  ],
+  "name": "verror",
+  "optionalDependencies": {},
+  "readme": "ERROR: No README data found!",
+  "repository": {
+    "type": "git",
+    "url": "git://github.com/davepacheco/node-verror.git"
+  },
+  "scripts": {
+    "test": "make test"
+  },
+  "version": "1.3.6"
+}
\ No newline at end of file
diff --git a/tools/node_modules/cmdln/node_modules/verror/tests/tst.inherit.js b/tools/node_modules/cmdln/node_modules/verror/tests/tst.inherit.js
new file mode 100644
index 00000000..0f0d70b5
--- /dev/null
+++ b/tools/node_modules/cmdln/node_modules/verror/tests/tst.inherit.js
@@ -0,0 +1,100 @@
+/*
+ * tst.inherit.js: test that inheriting from VError and WError work as expected.
+ */
+
+var mod_assert = require('assert');
+var mod_util = require('util');
+
+var mod_verror = require('../lib/verror');
+
+var VError = mod_verror.VError;
+var WError = mod_verror.WError;
+var err, suberr;
+
+function VErrorChild()
+{
+	VError.apply(this, Array.prototype.slice.call(arguments));
+}
+
+mod_util.inherits(VErrorChild, VError);
+VErrorChild.prototype.name = 'VErrorChild';
+
+
+function WErrorChild()
+{
+	WError.apply(this, Array.prototype.slice.call(arguments));
+}
+
+mod_util.inherits(WErrorChild, WError);
+WErrorChild.prototype.name = 'WErrorChild';
+
+
+suberr = new Error('root cause');
+err = new VErrorChild(suberr, 'top');
+mod_assert.ok(err instanceof Error);
+mod_assert.ok(err instanceof VError);
+mod_assert.ok(err instanceof VErrorChild);
+mod_assert.equal(err.cause(), suberr);
+mod_assert.equal(err.message, 'top: root cause');
+mod_assert.equal(err.toString(), 'VErrorChild: top: root cause');
+mod_assert.equal(err.stack.split('\n')[0], 'VErrorChild: top: root cause');
+
+suberr = new Error('root cause');
+err = new WErrorChild(suberr, 'top');
+mod_assert.ok(err instanceof Error);
+mod_assert.ok(err instanceof WError);
+mod_assert.ok(err instanceof WErrorChild);
+mod_assert.equal(err.cause(), suberr);
+mod_assert.equal(err.message, 'top');
+mod_assert.equal(err.toString(),
+	'WErrorChild: top; caused by Error: root cause');
+mod_assert.equal(err.stack.split('\n')[0],
+	'WErrorChild: top; caused by Error: root cause');
+
+
+// Test that `<Ctor>.toString()` uses the ctor name. I.e. setting
+// `<Ctor>.prototype.name` isn't necessary.
+function VErrorChildNoName() {
+	VError.apply(this, Array.prototype.slice.call(arguments));
+}
+mod_util.inherits(VErrorChildNoName, VError);
+err = new VErrorChildNoName('top');
+mod_assert.equal(err.toString(), 'VErrorChildNoName: top');
+
+function WErrorChildNoName() {
+	WError.apply(this, Array.prototype.slice.call(arguments));
+}
+mod_util.inherits(WErrorChildNoName, WError);
+err = new WErrorChildNoName('top');
+mod_assert.equal(err.toString(), 'WErrorChildNoName: top');
+
+
+// Test that `<Ctor>.prototype.name` can be used for the `.toString()`
+// when the ctor is anonymous.
+var VErrorChildAnon = function () {
+	VError.apply(this, Array.prototype.slice.call(arguments));
+};
+mod_util.inherits(VErrorChildAnon, VError);
+VErrorChildAnon.prototype.name = 'VErrorChildAnon';
+err = new VErrorChildAnon('top');
+mod_assert.equal(err.toString(), 'VErrorChildAnon: top');
+
+var WErrorChildAnon = function () {
+	WError.apply(this, Array.prototype.slice.call(arguments));
+};
+mod_util.inherits(WErrorChildAnon, WError);
+WErrorChildAnon.prototype.name = 'WErrorChildAnon';
+err = new WErrorChildAnon('top');
+mod_assert.equal(err.toString(), 'WErrorChildAnon: top');
+
+
+// Test get appropriate exception name in `.toString()` when reconstituting
+// an error instance a la:
+//    https://github.com/mcavage/node-fast/blob/master/lib/client.js#L215
+err = new VError('top');
+err.name = 'CustomNameError';
+mod_assert.equal(err.toString(), 'CustomNameError: top');
+
+err = new WError('top');
+err.name = 'CustomNameError';
+mod_assert.equal(err.toString(), 'CustomNameError: top');
diff --git a/tools/node_modules/cmdln/node_modules/verror/tests/tst.verror.js b/tools/node_modules/cmdln/node_modules/verror/tests/tst.verror.js
new file mode 100644
index 00000000..ee937cd0
--- /dev/null
+++ b/tools/node_modules/cmdln/node_modules/verror/tests/tst.verror.js
@@ -0,0 +1,156 @@
+/*
+ * tst.verror.js: tests basic functionality of the VError class.
+ */
+
+var mod_assert = require('assert');
+var mod_verror = require('../lib/verror');
+
+var VError = mod_verror.VError;
+var WError = mod_verror.WError;
+
+var err, suberr, stack, substack;
+
+/*
+ * Remove full paths and relative line numbers from stack traces so that we can
+ * compare against "known-good" output.
+ */
+function cleanStack(stacktxt)
+{
+	var re = new RegExp(__filename + ':\\d+:\\d+', 'gm');
+	stacktxt = stacktxt.replace(re, 'tst.verror.js');
+	return (stacktxt);
+}
+
+/*
+ * Save the generic parts of all stack traces so we can avoid hardcoding
+ * Node-specific implementation details in our testing of stack traces.
+ */
+var nodestack = new Error().stack.split('\n').slice(2).join('\n');
+
+/* no arguments */
+err = new VError();
+mod_assert.equal(err.name, 'VError');
+mod_assert.ok(err instanceof Error);
+mod_assert.ok(err instanceof VError);
+mod_assert.equal(err.message, '');
+mod_assert.ok(err.cause() === undefined);
+stack = cleanStack(err.stack);
+mod_assert.equal(stack, [
+    'VError',
+    '    at Object.<anonymous> (tst.verror.js)'
+].join('\n') + '\n' + nodestack);
+
+/* options-argument form */
+err = new VError({});
+mod_assert.equal(err.message, '');
+mod_assert.ok(err.cause() === undefined);
+
+/* simple message */
+err = new VError('my error');
+mod_assert.equal(err.message, 'my error');
+mod_assert.ok(err.cause() === undefined);
+stack = cleanStack(err.stack);
+mod_assert.equal(stack, [
+    'VError: my error',
+    '    at Object.<anonymous> (tst.verror.js)'
+].join('\n') + '\n' + nodestack);
+
+err = new VError({}, 'my error');
+mod_assert.equal(err.message, 'my error');
+mod_assert.ok(err.cause() === undefined);
+
+/* printf-style message */
+err = new VError('%s error: %3d problems', 'very bad', 15);
+mod_assert.equal(err.message, 'very bad error:  15 problems');
+mod_assert.ok(err.cause() === undefined);
+
+err = new VError({}, '%s error: %3d problems', 'very bad', 15);
+mod_assert.equal(err.message, 'very bad error:  15 problems');
+mod_assert.ok(err.cause() === undefined);
+
+/* caused by another error, with no additional message */
+suberr = new Error('root cause');
+err = new VError(suberr);
+mod_assert.equal(err.message, ': root cause');
+mod_assert.ok(err.cause() === suberr);
+
+err = new VError({ 'cause': suberr });
+mod_assert.equal(err.message, ': root cause');
+mod_assert.ok(err.cause() === suberr);
+
+/* caused by another error, with annotation */
+err = new VError(suberr, 'proximate cause: %d issues', 3);
+mod_assert.equal(err.message, 'proximate cause: 3 issues: root cause');
+mod_assert.ok(err.cause() === suberr);
+stack = cleanStack(err.stack);
+mod_assert.equal(stack, [
+    'VError: proximate cause: 3 issues: root cause',
+    '    at Object.<anonymous> (tst.verror.js)'
+].join('\n') + '\n' + nodestack);
+
+err = new VError({ 'cause': suberr }, 'proximate cause: %d issues', 3);
+mod_assert.equal(err.message, 'proximate cause: 3 issues: root cause');
+mod_assert.ok(err.cause() === suberr);
+stack = cleanStack(err.stack);
+mod_assert.equal(stack, [
+    'VError: proximate cause: 3 issues: root cause',
+    '    at Object.<anonymous> (tst.verror.js)'
+].join('\n') + '\n' + nodestack);
+
+/* caused by another VError, with annotation. */
+suberr = err;
+err = new VError(suberr, 'top');
+mod_assert.equal(err.message, 'top: proximate cause: 3 issues: root cause');
+mod_assert.ok(err.cause() === suberr);
+
+err = new VError({ 'cause': suberr }, 'top');
+mod_assert.equal(err.message, 'top: proximate cause: 3 issues: root cause');
+mod_assert.ok(err.cause() === suberr);
+
+/* caused by a WError */
+suberr = new WError(new Error('root cause'), 'mid');
+err = new VError(suberr, 'top');
+mod_assert.equal(err.message, 'top: mid');
+mod_assert.ok(err.cause() === suberr);
+
+/* null cause (for backwards compatibility with older versions) */
+err = new VError(null, 'my error');
+mod_assert.equal(err.message, 'my error');
+mod_assert.ok(err.cause() === undefined);
+stack = cleanStack(err.stack);
+mod_assert.equal(stack, [
+    'VError: my error',
+    '    at Object.<anonymous> (tst.verror.js)'
+].join('\n') + '\n' + nodestack);
+
+err = new VError({ 'cause': null }, 'my error');
+mod_assert.equal(err.message, 'my error');
+mod_assert.ok(err.cause() === undefined);
+
+err = new VError(null);
+mod_assert.equal(err.message, '');
+mod_assert.ok(err.cause() === undefined);
+stack = cleanStack(err.stack);
+mod_assert.equal(stack, [
+    'VError',
+    '    at Object.<anonymous> (tst.verror.js)'
+].join('\n') + '\n' + nodestack);
+
+/* constructorOpt */
+function makeErr(options) {
+	return (new VError(options, 'test error'));
+}
+err = makeErr({});
+stack = cleanStack(err.stack);
+mod_assert.equal(stack, [
+    'VError: test error',
+    '    at makeErr (tst.verror.js)',
+    '    at Object.<anonymous> (tst.verror.js)'
+].join('\n') + '\n' + nodestack);
+
+err = makeErr({ 'constructorOpt': makeErr });
+stack = cleanStack(err.stack);
+mod_assert.equal(stack, [
+    'VError: test error',
+    '    at Object.<anonymous> (tst.verror.js)'
+].join('\n') + '\n' + nodestack);
diff --git a/tools/node_modules/cmdln/node_modules/verror/tests/tst.werror.js b/tools/node_modules/cmdln/node_modules/verror/tests/tst.werror.js
new file mode 100644
index 00000000..c8cdc615
--- /dev/null
+++ b/tools/node_modules/cmdln/node_modules/verror/tests/tst.werror.js
@@ -0,0 +1,179 @@
+/*
+ * tst.werror.js: tests basic functionality of the WError class.
+ */
+
+var mod_assert = require('assert');
+var mod_verror = require('../lib/verror');
+
+var VError = mod_verror.VError;
+var WError = mod_verror.WError;
+
+var err, suberr, stack, substack;
+
+/*
+ * Remove full paths and relative line numbers from stack traces so that we can
+ * compare against "known-good" output.
+ */
+function cleanStack(stacktxt)
+{
+	var re = new RegExp(__filename + ':\\d+:\\d+', 'gm');
+	stacktxt = stacktxt.replace(re, 'tst.werror.js');
+	return (stacktxt);
+}
+
+/*
+ * Save the generic parts of all stack traces so we can avoid hardcoding
+ * Node-specific implementation details in our testing of stack traces.
+ */
+var nodestack = new Error().stack.split('\n').slice(2).join('\n');
+
+/* no arguments */
+err = new WError();
+mod_assert.equal(err.name, 'WError');
+mod_assert.ok(err instanceof Error);
+mod_assert.ok(err instanceof WError);
+mod_assert.equal(err.message, '');
+mod_assert.equal(err.toString(), 'WError');
+mod_assert.ok(err.cause() === undefined);
+stack = cleanStack(err.stack);
+mod_assert.equal(stack, [
+    'WError',
+    '    at Object.<anonymous> (tst.werror.js)'
+].join('\n') + '\n' + nodestack);
+
+/* options-argument form */
+err = new WError({});
+mod_assert.equal(err.message, '');
+mod_assert.equal(err.toString(), 'WError');
+mod_assert.ok(err.cause() === undefined);
+
+/* simple message */
+err = new WError('my error');
+mod_assert.equal(err.message, 'my error');
+mod_assert.equal(err.toString(), 'WError: my error');
+mod_assert.ok(err.cause() === undefined);
+stack = cleanStack(err.stack);
+mod_assert.equal(stack, [
+    'WError: my error',
+    '    at Object.<anonymous> (tst.werror.js)'
+].join('\n') + '\n' + nodestack);
+
+err = new WError({}, 'my error');
+mod_assert.equal(err.message, 'my error');
+mod_assert.equal(err.toString(), 'WError: my error');
+mod_assert.ok(err.cause() === undefined);
+
+/* printf-style message */
+err = new WError('%s error: %3d problems', 'very bad', 15);
+mod_assert.equal(err.message, 'very bad error:  15 problems');
+mod_assert.equal(err.toString(), 'WError: very bad error:  15 problems');
+mod_assert.ok(err.cause() === undefined);
+
+err = new WError({}, '%s error: %3d problems', 'very bad', 15);
+mod_assert.equal(err.message, 'very bad error:  15 problems');
+mod_assert.equal(err.toString(), 'WError: very bad error:  15 problems');
+mod_assert.ok(err.cause() === undefined);
+
+/* caused by another error, with no additional message */
+suberr = new Error('root cause');
+err = new WError(suberr);
+mod_assert.equal(err.message, '');
+mod_assert.equal(err.toString(), 'WError; caused by Error: root cause');
+mod_assert.ok(err.cause() === suberr);
+
+err = new WError({ 'cause': suberr });
+mod_assert.equal(err.message, '');
+mod_assert.equal(err.toString(), 'WError; caused by Error: root cause');
+mod_assert.ok(err.cause() === suberr);
+
+/* caused by another error, with annotation */
+err = new WError(suberr, 'proximate cause: %d issues', 3);
+mod_assert.equal(err.message, 'proximate cause: 3 issues');
+mod_assert.equal(err.toString(), 'WError: proximate cause: 3 issues; ' +
+    'caused by Error: root cause');
+mod_assert.ok(err.cause() === suberr);
+stack = cleanStack(err.stack);
+mod_assert.equal(stack, [
+    'WError: proximate cause: 3 issues; caused by Error: root cause',
+    '    at Object.<anonymous> (tst.werror.js)'
+].join('\n') + '\n' + nodestack);
+
+err = new WError({ 'cause': suberr }, 'proximate cause: %d issues', 3);
+mod_assert.equal(err.message, 'proximate cause: 3 issues');
+mod_assert.equal(err.toString(), 'WError: proximate cause: 3 issues; ' +
+    'caused by Error: root cause');
+mod_assert.ok(err.cause() === suberr);
+stack = cleanStack(err.stack);
+mod_assert.equal(stack, [
+    'WError: proximate cause: 3 issues; caused by Error: root cause',
+    '    at Object.<anonymous> (tst.werror.js)'
+].join('\n') + '\n' + nodestack);
+
+/* caused by another WError, with annotation. */
+suberr = err;
+err = new WError(suberr, 'top');
+mod_assert.equal(err.message, 'top');
+mod_assert.equal(err.toString(), 'WError: top; caused by WError: ' +
+    'proximate cause: 3 issues; caused by Error: root cause');
+mod_assert.ok(err.cause() === suberr);
+
+err = new WError({ 'cause': suberr }, 'top');
+mod_assert.equal(err.message, 'top');
+mod_assert.equal(err.toString(), 'WError: top; caused by WError: ' +
+    'proximate cause: 3 issues; caused by Error: root cause');
+mod_assert.ok(err.cause() === suberr);
+
+/* caused by a VError */
+suberr = new VError(new Error('root cause'), 'mid');
+err = new WError(suberr, 'top');
+mod_assert.equal(err.message, 'top');
+mod_assert.equal(err.toString(),
+    'WError: top; caused by VError: mid: root cause');
+mod_assert.ok(err.cause() === suberr);
+
+/* null cause (for backwards compatibility with older versions) */
+err = new WError(null, 'my error');
+mod_assert.equal(err.message, 'my error');
+mod_assert.equal(err.toString(), 'WError: my error');
+mod_assert.ok(err.cause() === undefined);
+stack = cleanStack(err.stack);
+mod_assert.equal(stack, [
+    'WError: my error',
+    '    at Object.<anonymous> (tst.werror.js)'
+].join('\n') + '\n' + nodestack);
+
+err = new WError({ 'cause': null }, 'my error');
+mod_assert.equal(err.message, 'my error');
+mod_assert.equal(err.toString(), 'WError: my error');
+mod_assert.ok(err.cause() === undefined);
+
+err = new WError(null);
+mod_assert.equal(err.message, '');
+mod_assert.equal(err.toString(), 'WError');
+mod_assert.ok(err.cause() === undefined);
+stack = cleanStack(err.stack);
+mod_assert.equal(stack, [
+    'WError',
+    '    at Object.<anonymous> (tst.werror.js)'
+].join('\n') + '\n' + nodestack);
+
+/* constructorOpt */
+function makeErr(options) {
+	return (new WError(options, 'test error'));
+}
+err = makeErr({});
+mod_assert.equal(err.toString(), 'WError: test error');
+stack = cleanStack(err.stack);
+mod_assert.equal(stack, [
+    'WError: test error',
+    '    at makeErr (tst.werror.js)',
+    '    at Object.<anonymous> (tst.werror.js)'
+].join('\n') + '\n' + nodestack);
+
+err = makeErr({ 'constructorOpt': makeErr });
+mod_assert.equal(err.toString(), 'WError: test error');
+stack = cleanStack(err.stack);
+mod_assert.equal(stack, [
+    'WError: test error',
+    '    at Object.<anonymous> (tst.werror.js)'
+].join('\n') + '\n' + nodestack);
diff --git a/tools/node_modules/cmdln/package.json b/tools/node_modules/cmdln/package.json
index 4265939e..92c32bdf 100644
--- a/tools/node_modules/cmdln/package.json
+++ b/tools/node_modules/cmdln/package.json
@@ -1,39 +1,48 @@
 {
-  "name": "cmdln",
-  "version": "1.1.1",
-  "description": "helper lib for creating CLI tools with subcommands; think `git`, `svn`, `zfs`",
   "author": {
     "name": "Trent Mick",
     "url": "http://trentm.com"
   },
-  "main": "./lib/cmdln.js",
-  "repository": {
-    "type": "git",
-    "url": "git://github.com/trentm/node-cmdln.git"
+  "bugs": {
+    "url": "https://github.com/trentm/node-cmdln/issues"
+  },
+  "dependencies": {
+    "assert-plus": "0.1.3",
+    "dashdash": "1.3.2",
+    "extsprintf": "1.0.2",
+    "verror": "1.3.6"
+  },
+  "description": "helper lib for creating CLI tools with subcommands; think `git`, `svn`, `zfs`",
+  "devDependencies": {
+    "nodeunit": "0.7.4"
+  },
+  "directories": {},
+  "dist": {
+    "shasum": "dfedc0c29612219f2fafbf3cb71fbf5356b207f2",
+    "tarball": "https://registry.npmjs.org/cmdln/-/cmdln-1.3.1.tgz"
   },
   "engines": [
     "node >=0.8.0"
   ],
+  "homepage": "https://github.com/trentm/node-cmdln#readme",
   "keywords": [
     "cmdln",
     "cli",
     "tool"
   ],
-  "dependencies": {
-    "assert-plus": "0.1.2",
-    "extsprintf": "1.0.2",
-    "verror": "1.3.6",
-    "dashdash": "1.2.0"
-  },
-  "devDependencies": {
-    "nodeunit": "0.7.4"
-  },
-  "readme": "`node-cmdln` is a node.js helper lib for creating CLI tools with subcommands\n(think `git`, `svn`, `zfs`, `brew`, etc.). It is a sister of my earlier\n[Python lib for this](https://github.com/trentm/cmdln).\n\nFollow <a href=\"https://twitter.com/intent/user?screen_name=trentmick\" target=\"_blank\">@trentmick</a>\nfor updates to node-cmdln.\n\n\n# Usage\n\nYou define a subclass of `Cmdln` and subcommands as `do_NAME` methods.\nMinimally you could have a \"conan.js\" as follows:\n\n    #!/usr/bin/env node\n    var util = require('util');\n    var cmdln = require('cmdln');\n\n    function Conan() {\n        cmdln.Cmdln.call(this, {\n            name: 'conan',\n            desc: 'What is best in life?'\n        });\n    }\n    util.inherits(Conan, cmdln.Cmdln);\n\n    Conan.prototype.do_crush = function do_crush(subcmd, opts, args, callback) {\n        console.log('Yargh!');\n        callback();\n    };\n    Conan.prototype.do_crush.help = 'Crush your enemies.';\n\n    cmdln.main(Conan);  // mainline\n\nWith this, you get the following behaviour:\n\n    $ node conan.js\n    What is best in life?\n\n    Usage:\n        conan [OPTIONS] COMMAND [ARGS...]\n        conan help COMMAND\n\n    Options:\n        -h, --help      Show this help message and exit.\n\n    Commands:\n        help (?)        Help on a specific sub-command.\n        crush           Crush your enemies.\n\n    $ node conan.js help crush\n    Crush your enemies.\n\n    $ node conan.js crush\n    Yargh!\n\n\n# Option processing\n\nOption processing (using [dashdash](https://github.com/trentm/node-dashdash))\nis integrated. `do_crush` above could be replaced with:\n\n    Conan.prototype.do_crush = function (subcmd, opts, args, callback) {\n        console.log('Yargh!');\n        callback();\n    };\n    Conan.prototype.do_crush = function (subcmd, opts, args, callback) {\n        if (opts.help) {\n            this.do_help('help', {}, [subcmd], callback);\n            return;\n        }\n        if (!args.length) {\n            console.log('No enemies? Yarg!');\n        } else {\n            args.forEach(function (enemy) {\n                console.log('Smite %s with a %s!', enemy, opts.weapon);\n            });\n        }\n        callback();\n    };\n    Conan.prototype.do_crush.options = [\n        {\n            names: ['help', 'h'],\n            type: 'bool',\n            help: 'Show this help.'\n        },\n        {\n            names: ['weapon', 'w'],\n            helpArg: 'WEAPON',\n            type: 'string',\n            default: 'sword',\n            help: 'Weapon with which to smite.'\n        }\n    ];\n    Conan.prototype.do_crush.help = (\n        'Crush your enemies.\\n'\n        + '\\n'\n        + 'Usage:\\n'\n        + '     conan crush [OPTIONS] [ENEMIES...]\\n'\n        + '\\n'\n        + '{{options}}'\n    );\n\nThen we get this behaviour:\n\n    $ node conan.js crush Bob\n    Smite Bob with a sword!\n\n    $ node conan.js crush Bob Linda --weapon mattock\n    Smite Bob with a mattock!\n    Smite Linda with a mattock!\n\n    $ node conan.js crush -h\n    Crush your enemies.\n\n    Usage:\n         conan crush [OPTIONS] [ENEMIES...]\n\n    Options:\n        -h, --help                  Show this help.\n        -w WEAPON, --weapon=WEAPON  Weapon with which to smite.\n\n\nSee \"examples/conan.js\" for the complete example. Run\n`node example/conan.js ...` to try it out.\n\n\n# License\n\nMIT. See LICENSE.txt\n",
-  "readmeFilename": "README.md",
-  "_id": "cmdln@1.1.1",
-  "dist": {
-    "shasum": "9e95155b8bd839079da4f036f2f637d701f3fdd3"
+  "main": "./lib/cmdln.js",
+  "maintainers": [
+    {
+      "name": "trentm",
+      "email": "trentm@gmail.com"
+    }
+  ],
+  "name": "cmdln",
+  "optionalDependencies": {},
+  "readme": "ERROR: No README data found!",
+  "repository": {
+    "type": "git",
+    "url": "git://github.com/trentm/node-cmdln.git"
   },
-  "_from": "cmdln@",
-  "_resolved": "https://registry.npmjs.org/cmdln/-/cmdln-1.1.1.tgz"
-}
+  "version": "1.3.1"
+}
\ No newline at end of file
diff --git a/tools/node_modules/forkexec/.npmignore b/tools/node_modules/forkexec/.npmignore
new file mode 100644
index 00000000..db5dad8e
--- /dev/null
+++ b/tools/node_modules/forkexec/.npmignore
@@ -0,0 +1,4 @@
+examples/
+tools/
+test/
+Makefile*
diff --git a/tools/node_modules/forkexec/CHANGES.md b/tools/node_modules/forkexec/CHANGES.md
new file mode 100644
index 00000000..fdb22668
--- /dev/null
+++ b/tools/node_modules/forkexec/CHANGES.md
@@ -0,0 +1,20 @@
+# Changelog
+
+# Not yet released
+
+No changes.
+
+
+# v1.1.0 (2016-07-14)
+
+* joyent/node-forkexec#3 optionally include stderr in error message
+* joyent/node-forkexec#4 NPM package should not ship development files
+
+# v1.0.0 (2016-05-20)
+
+* joyent/node-forkexec#2 add interface for normalizing Node errors
+* Commit to API
+
+# v0.1.0 (2015-03-17)
+
+* Initial version with forkExecWait().
diff --git a/tools/node_modules/forkexec/LICENSE b/tools/node_modules/forkexec/LICENSE
new file mode 100644
index 00000000..37702144
--- /dev/null
+++ b/tools/node_modules/forkexec/LICENSE
@@ -0,0 +1,19 @@
+Copyright (c) 2015, Joyent, Inc. All rights reserved.
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+THE SOFTWARE
diff --git a/tools/node_modules/forkexec/README.md b/tools/node_modules/forkexec/README.md
new file mode 100644
index 00000000..64d8ba2c
--- /dev/null
+++ b/tools/node_modules/forkexec/README.md
@@ -0,0 +1,294 @@
+# forkexec: sane child process library
+
+This library provides somewhat saner interfaces to Node's
+[child_process](https://nodejs.org/api/child_process.html) module.  It's still
+growing, and most of the interfaces there don't have analogs here yet.
+
+The interfaces in this library conform to Joyent's [Best Practices for Error
+Handling in Node.js](http://www.joyent.com/developers/node/design/errors).  Most
+notably:
+
+* most arguments are passed via named properties of an "args" object, and
+* passing invalid arguments into the library results in thrown exceptions that
+  _should not be caught_.  Don't pass bad values in.
+
+The only interfaces currently provided are:
+
+* [forkExecWait](#forkexecwait)`(args, callback)`: like
+  `child_process.execFile`, but all operational errors are emitted
+  asynchronously, errors are more descriptive, and there's a crisper summary of
+  exactly what happened.
+* [interpretChildProcessResult](#interpretchildprocessresult)`(args)`:
+  lower-level function for taking the result of one of Node's `child_process`
+  functions and producing a normalized summary of what happened.
+
+**One of the biggest challenges in using Node's child\_process interfaces is
+properly interpreting the result.**  When you kick off a child process (as with
+fork/exec), there are basically four possible outcomes:
+
+1. Node failed to fork or exec the child process at all.
+   (`error` is non-null, `status` is null, and `signal` is null)
+2. The child process was successfully forked and exec'd, but terminated
+   abnormally due to a signal.
+   (`error` is non-null, `status` is null, and `signal` is non-null)
+3. The child process was successfully forked and exec'd and exited
+   with a status code other than 0.
+   (`error` is non-null, `status` is a non-zero integer, and `signal` is null).
+4. The child process was successfully forked and exec'd and exited with
+   a status code of 0.
+   (`error` is null, `status` is 0, and `signal` is null.)
+
+Most code doesn't handle (1) at all, since it usually results in the
+child\_process function throwing an exception rather than calling your callback.
+Most use-cases want to treat (1), (2), and (3) as failure cases and generate a
+descriptive error for them, but the built-in Errors are not very descriptive.
+
+The interfaces here attempt to make the common case very easy (providing a
+descriptive, non-null Error in cases (1) through (3), but not (4)), while still
+allowing more complex callers to easily determine exactly what happened.  These
+interfaces do this by taking the result of the underlying Node API function and
+producing an `info` object with properties:
+
+* **error**: null if the child process was created and terminated normally with
+  exit\_status 0.  This is a non-null, descriptive error if the child process was
+  not created at all, if the process was terminated abnormally by a signal, or
+  if the process was terminated normally with a non-zero exit status.
+* **status**: the wait(2) numeric status code if the child process exited
+  normally, and null otherwise.
+* **signal**: the name of the signal that terminated the child process if the
+* child process exited abnormally as a result of a signal, or null otherwise
+
+
+## forkExecWait
+
+Like the built-in `child_process.execFile`, this function forks a child process,
+exec's the requested command, waits for it to exit, and captures the full stdout
+and stderr.  The file should be an executable on the caller's PATH.  It is
+_not_ passed through `bash -c` as would happen with `child_process.exec`.
+
+### Arguments
+
+```javascript
+forkExecWait(args, callback)
+```
+
+The main argument is:
+
+* **argv** (array of string): command-line arguments, _including the command
+  name itself_.  If you want to run "ls -l", this should be `[ 'ls', '-l' ]`.
+
+The following arguments have the same semantics as for Node's built-in
+`child_process.execFile` except where otherwise noted:
+
+* **timeout** (int: milliseconds): maximum time the child process may run before
+  SIGKILL will be sent to it.  If 0, then there is no timeout.  (Note that Node
+  lets you override the signal used and defaults to SIGTERM.  This interface
+  always uses SIGKILL.)
+* **cwd** (string): working directory
+* **encoding** (string): encoding for stdout and stderr
+* **env** (object): environment variables
+* **maxBuffer** (int): bytes of stdout and stderr that will be buffered
+* **uid** (int): uid for child process
+* **gid** (int): gid for child process
+* **includeStderr** (boolean): if the process exits with a non-zero status,
+  the output of `stderr` will be trimmed and included in the error message.
+  Defaults to `false`.
+
+### Return value
+
+The return value is the same as `child_process.execFile` except when that
+function would throw an exception, in which case this function will return
+`null` and the error that would have been thrown is instead emitted to the
+callback (as you'd probably have expected Node to do).
+
+### Callback
+
+The callback is invoked as `callback(err, info)`, where `info` always has
+properties:
+
+* **error**, **status**, **signal**: see description of "info" object above.
+  `info.error` is the same as the `err` argument.
+* **stdout**: the string contents of the command's stdout.  This is unspecified
+  if the process was not successfully exec'd.
+* **stderr**: the string contents of the command's stderr.  This is unspecified
+  if the process was not successfully exec'd.
+
+### Error handling
+
+As described above, the interface throws on programmer errors, and these should
+not be handled.  Operational errors are emitted asynchronously.  See the four
+possible outcomes described above for what those are.
+
+### Examples
+
+Normal command:
+
+```javascript
+forkExecWait({
+    'argv': [ 'echo', 'hello', 'world' ]
+}, function (err, info) {
+    console.log(info);
+});
+```
+
+```javascript
+{ error: null,
+  status: 0,
+  signal: null,
+  stdout: 'hello world\n',
+  stderr: '' }
+```
+
+Successful fork/exec, command fails:
+
+```javascript
+forkExecWait({
+    'argv': [ 'grep', 'foobar' '/nonexistent_file' ]
+}, function (err, info) {
+    console.log(info);
+});
+```
+
+```javascript
+{ error: 
+   { [VError: exec "grep foobar /nonexistent_file": exited with status 2]
+     jse_shortmsg: 'exec "grep foobar /nonexistent_file"',
+     jse_summary: 'exec "grep foobar /nonexistent_file": exited with status 2',
+     jse_cause: 
+      { [VError: exited with status 2]
+        jse_shortmsg: 'exited with status 2',
+        jse_summary: 'exited with status 2',
+        message: 'exited with status 2' },
+     message: 'exec "grep foobar /nonexistent_file": exited with status 2' },
+  status: 2,
+  signal: null,
+  stdout: '',
+  stderr: 'grep: /nonexistent_file: No such file or directory\n' }
+```
+
+Failed fork/exec: command not found:
+
+```javascript
+forkExecWait({
+    'argv': [ 'nonexistent', 'command' ]
+}, function (err, info) {
+    console.log(info);
+});
+```
+
+```javascript
+{ error: 
+   { [VError: exec "nonexistent command": spawn nonexistent ENOENT]
+     jse_shortmsg: 'exec "nonexistent command"',
+     jse_summary: 'exec "nonexistent command": spawn nonexistent ENOENT',
+     jse_cause: 
+      { [Error: spawn nonexistent ENOENT]
+        code: 'ENOENT',
+        errno: 'ENOENT',
+        syscall: 'spawn nonexistent',
+        path: 'nonexistent',
+        cmd: 'nonexistent command' },
+     message: 'exec "nonexistent command": spawn nonexistent ENOENT' },
+  status: null,
+  signal: null,
+  stdout: '',
+  stderr: '' }
+```
+
+Failed fork/exec: command is not executable (note: Node throws on this, while
+this library emits an error asynchronously, since this is an operational error):
+
+```javascript
+forkExecWait({
+    'argv': [ '/dev/null' ]
+}, function (err, info) {
+    console.log(info);
+});
+```
+
+```javascript
+{ error: 
+   { [VError: exec "/dev/null": spawn EACCES]
+     jse_shortmsg: 'exec "/dev/null"',
+     jse_summary: 'exec "/dev/null": spawn EACCES',
+     jse_cause: { [Error: spawn EACCES] code: 'EACCES', errno: 'EACCES', syscall: 'spawn' },
+     message: 'exec "/dev/null": spawn EACCES' },
+  status: null,
+  signal: null,
+  stdout: '',
+  stderr: '' }
+```
+
+Command times out (killed by our SIGKILL after 3 seconds):
+
+```javascript
+forkExecWait({
+    'argv': [ 'sleep', '4' ],
+    'timeout': 3000,
+}, function (err, info) {
+    console.log(info);
+});
+```
+
+```javascript
+{ error: 
+   { [VError: exec "sleep 2": unexpectedly terminated by signal SIGKILL]
+     jse_shortmsg: 'exec "sleep 2"',
+     jse_summary: 'exec "sleep 2": unexpectedly terminated by signal SIGKILL',
+     jse_cause: 
+      { [VError: unexpectedly terminated by signal SIGKILL]
+        jse_shortmsg: 'unexpectedly terminated by signal SIGKILL',
+        jse_summary: 'unexpectedly terminated by signal SIGKILL',
+        message: 'unexpectedly terminated by signal SIGKILL' },
+     message: 'exec "sleep 2": unexpectedly terminated by signal SIGKILL' },
+  status: null,
+  signal: 'SIGKILL',
+  stdout: '',
+  stderr: '' }
+```
+
+
+## interpretChildProcessResult
+
+This lower-level function takes the results of one of the `child_process`
+functions and produces the `info` object described above, including a more
+descriptive Error (if there was one).
+
+### Arguments
+
+```javascript
+interpretChildProcessResult(args)
+```
+
+Named arguments are:
+
+* **label** (string): label for the child process.  This can be just the command
+  (e.g., "grep"), the full argument string (e.g., "grep foo /my/files"), a
+  human-readable label (e.g., "grep subprocess"), or whatever else you want to
+  report with an optional error.
+* **error** (optional Error): error object reported by one of Node's
+  child_process functions.  Per the Node docs, this should be either `null` or
+  an instance of Error.
+
+### Return value
+
+The return value is an `info` object with the `error`, `status`, and `signal`
+properties described above.
+
+
+### Error handling
+
+As described above, the interface throws on programmer errors, and these should
+not be handled.  There are no operational errors for this interface.
+
+
+# Contributions
+
+Contributions welcome.  Code should be "make prepush" clean.  To run "make
+prepush", you'll need these tools:
+
+* https://github.com/davepacheco/jsstyle
+* https://github.com/davepacheco/javascriptlint
+
+If you're changing something non-trivial or user-facing, you may want to submit
+an issue first.
diff --git a/tools/node_modules/forkexec/lib/forkexec.js b/tools/node_modules/forkexec/lib/forkexec.js
new file mode 100644
index 00000000..cde4d21f
--- /dev/null
+++ b/tools/node_modules/forkexec/lib/forkexec.js
@@ -0,0 +1,165 @@
+/*
+ * lib/forkexec.js: sane child process library
+ */
+
+var mod_assertplus = require('assert-plus');
+var mod_child = require('child_process');
+var VError = require('verror');
+
+exports.forkExecWait = forkExecWait;
+exports.interpretChildProcessResult = interpretChildProcessResult;
+
+/*
+ * forkExecWait(args, callback): similar to Node's child_process.execFile().
+ * See README.md for interface details.
+ */
+function forkExecWait(args, callback)
+{
+	var cmd, cmdstr, cmdargs, options;
+	var passthru, rv;
+
+	mod_assertplus.object(args, 'args');
+	mod_assertplus.arrayOfString(args.argv, 'args.argv');
+	mod_assertplus.optionalString(args.cwd, 'args.cwd');
+	mod_assertplus.optionalObject(args.env, 'args.env');
+	mod_assertplus.optionalNumber(args.timeout, 'args.timeout');
+	mod_assertplus.optionalNumber(args.maxBuffer, 'args.maxBuffer');
+	mod_assertplus.optionalNumber(args.uid, 'args.uid');
+	mod_assertplus.optionalNumber(args.gid, 'args.gid');
+	mod_assertplus.optionalBool(args.includeStderr, 'args.stderr');
+
+	cmd = args.argv[0];
+	cmdstr = JSON.stringify(args.argv.join(' '));
+	cmdargs = args.argv.slice(1);
+	options = {};
+	passthru = [ 'cwd', 'encoding', 'env', 'maxBuffer', 'uid', 'gid',
+	    'timeout' ];
+	passthru.forEach(function (field) {
+		if (args.hasOwnProperty(field))
+			options[field] = args[field];
+	});
+
+	if (options.hasOwnProperty('timeout'))
+		options['killSignal'] = 'SIGKILL';
+
+	/*
+	 * Node returns most operational errors asynchronously here, but some
+	 * are synchronous (like EACCES from exec(2)).  We want to make these
+	 * asynchronous here.
+	 */
+	try {
+		rv = mod_child.execFile(cmd, cmdargs, options,
+		    function (error, stdout, stderr) {
+			onChildExited(cmdstr, callback, error, stdout, stderr,
+			    args.includeStderr);
+		    });
+	} catch (ex) {
+		rv = null;
+		setImmediate(onChildExited, cmdstr, callback, ex, '', '',
+		    args.includeStderr);
+	}
+
+	return (rv);
+}
+
+function onChildExited(cmdstr, callback, error, stdout, stderr, includeStderr)
+{
+	var info;
+	var extra;
+
+	if (!includeStderr || typeof (stderr) !== 'string' ||
+	    (extra = stderr.trim()) === '') {
+		extra = null;
+	}
+
+	info = interpretChildProcessResult({
+	    'label': cmdstr,
+	    'error': error,
+	    '_extra': extra
+	});
+
+	info.stdout = stdout;
+	info.stderr = stderr;
+	callback(info.error, info);
+}
+
+/*
+ * Common function for constructing an "info" object from a call to one of
+ * Node's child_process functions.  This function effectively normalizes the
+ * various possible failure cases from child process exits.  Arguments:
+ *
+ *     label	label for the child process.  This can be just the command
+ *              (e.g., "grep"), the full argument string (e.g., "grep foo
+ *              /my/files"), a human-readable label (e.g., "grep subprocess"),
+ *              or whatever else you want to report with an optional error.
+ *
+ *     error	error object reported by one of Node's child_process functions
+ *
+ * The return value is the object described in the README.
+ */
+function interpretChildProcessResult(args)
+{
+	var info, err;
+	var error;
+
+	mod_assertplus.object(args, 'args');
+	mod_assertplus.string(args.label, 'args.label');
+	mod_assertplus.optionalString(args._extra, 'args._extra');
+
+	error = args.error;
+	info = {
+	    'error': null,
+	    'status': null,
+	    'signal': null
+	};
+
+	if (error === null) {
+		info.status = 0;
+		return (info);
+	}
+
+	/*
+	 * child_process.execFile() is documented to produce either null
+	 * or an instance of Error.
+	 */
+	mod_assertplus.ok(error instanceof Error,
+	    'child_process function returned non-null, non-Error');
+	if (error.signal) {
+		/*
+		 * We deliberately don't pass "error" to the VError
+		 * constructor because the "message" on Node's error is
+		 * non-idiomatic for Unix programs.
+		 */
+		err = new VError('unexpectedly terminated by signal %s',
+		    error.signal);
+		info.signal = error.signal;
+	} else if (typeof (error.code) == 'number') {
+		/* See above. */
+		if (args._extra) {
+			err = new VError('exited with status %d: %s',
+			    error.code, args._extra);
+		} else {
+			err = new VError('exited with status %d', error.code);
+		}
+		info.status = error.code;
+	} else {
+		/*
+		 * In this case, fork() or exec() probably failed.
+		 * Neither "signal" nor "status" will be provided to the
+		 * caller since no child process was created.  In this
+		 * case, we use the underlying error as a cause because
+		 * it may well be meaningful.
+		 *
+		 * Note that this kind of error can have a "code" on it,
+		 * but it's not the status code of the program.  Node
+		 * uses "code" on other kinds of errors.  That's why the
+		 * previous condition checks whether "code" is a number,
+		 * not just whether it's present.
+		 */
+		err = error;
+	}
+
+	mod_assertplus.ok(err instanceof Error);
+	info.error = new VError(err, 'exec %s', args.label);
+	return (info);
+}
diff --git a/tools/node_modules/forkexec/node_modules/assert-plus/AUTHORS b/tools/node_modules/forkexec/node_modules/assert-plus/AUTHORS
new file mode 100644
index 00000000..1923524f
--- /dev/null
+++ b/tools/node_modules/forkexec/node_modules/assert-plus/AUTHORS
@@ -0,0 +1,6 @@
+Dave Eddy <dave@daveeddy.com>
+Fred Kuo <fred.kuo@joyent.com>
+Lars-Magnus Skog <ralphtheninja@riseup.net>
+Mark Cavage <mcavage@gmail.com>
+Patrick Mooney <pmooney@pfmooney.com>
+Rob Gulewich <robert.gulewich@joyent.com>
diff --git a/tools/node_modules/forkexec/node_modules/assert-plus/CHANGES.md b/tools/node_modules/forkexec/node_modules/assert-plus/CHANGES.md
new file mode 100644
index 00000000..57d92bfd
--- /dev/null
+++ b/tools/node_modules/forkexec/node_modules/assert-plus/CHANGES.md
@@ -0,0 +1,14 @@
+# assert-plus Changelog
+
+## 1.0.0
+
+- *BREAKING* assert.number (and derivatives) now accept Infinity as valid input
+- Add assert.finite check.  Previous assert.number callers should use this if
+  they expect Infinity inputs to throw.
+
+## 0.2.0
+
+- Fix `assert.object(null)` so it throws
+- Fix optional/arrayOf exports for non-type-of asserts
+- Add optiona/arrayOf exports for Stream/Date/Regex/uuid
+- Add basic unit test coverage
diff --git a/tools/node_modules/forkexec/node_modules/assert-plus/README.md b/tools/node_modules/forkexec/node_modules/assert-plus/README.md
new file mode 100644
index 00000000..ec200d16
--- /dev/null
+++ b/tools/node_modules/forkexec/node_modules/assert-plus/README.md
@@ -0,0 +1,162 @@
+# assert-plus
+
+This library is a super small wrapper over node's assert module that has two
+things: (1) the ability to disable assertions with the environment variable
+NODE\_NDEBUG, and (2) some API wrappers for argument testing.  Like
+`assert.string(myArg, 'myArg')`.  As a simple example, most of my code looks
+like this:
+
+```javascript
+    var assert = require('assert-plus');
+
+    function fooAccount(options, callback) {
+        assert.object(options, 'options');
+        assert.number(options.id, 'options.id');
+        assert.bool(options.isManager, 'options.isManager');
+        assert.string(options.name, 'options.name');
+        assert.arrayOfString(options.email, 'options.email');
+        assert.func(callback, 'callback');
+
+        // Do stuff
+        callback(null, {});
+    }
+```
+
+# API
+
+All methods that *aren't* part of node's core assert API are simply assumed to
+take an argument, and then a string 'name' that's not a message; `AssertionError`
+will be thrown if the assertion fails with a message like:
+
+    AssertionError: foo (string) is required
+    at test (/home/mark/work/foo/foo.js:3:9)
+    at Object.<anonymous> (/home/mark/work/foo/foo.js:15:1)
+    at Module._compile (module.js:446:26)
+    at Object..js (module.js:464:10)
+    at Module.load (module.js:353:31)
+    at Function._load (module.js:311:12)
+    at Array.0 (module.js:484:10)
+    at EventEmitter._tickCallback (node.js:190:38)
+
+from:
+
+```javascript
+    function test(foo) {
+        assert.string(foo, 'foo');
+    }
+```
+
+There you go.  You can check that arrays are of a homogeneous type with `Arrayof$Type`:
+
+```javascript
+    function test(foo) {
+        assert.arrayOfString(foo, 'foo');
+    }
+```
+
+You can assert IFF an argument is not `undefined` (i.e., an optional arg):
+
+```javascript
+    assert.optionalString(foo, 'foo');
+```
+
+Lastly, you can opt-out of assertion checking altogether by setting the
+environment variable `NODE_NDEBUG=1`.  This is pseudo-useful if you have
+lots of assertions, and don't want to pay `typeof ()` taxes to v8 in
+production.  Be advised:  The standard functions re-exported from `assert` are
+also disabled in assert-plus if NDEBUG is specified.  Using them directly from
+the `assert` module avoids this behavior.
+
+The complete list of APIs is:
+
+* assert.array
+* assert.bool
+* assert.buffer
+* assert.func
+* assert.number
+* assert.finite
+* assert.object
+* assert.string
+* assert.stream
+* assert.date
+* assert.regexp
+* assert.uuid
+* assert.arrayOfArray
+* assert.arrayOfBool
+* assert.arrayOfBuffer
+* assert.arrayOfFunc
+* assert.arrayOfNumber
+* assert.arrayOfFinite
+* assert.arrayOfObject
+* assert.arrayOfString
+* assert.arrayOfStream
+* assert.arrayOfDate
+* assert.arrayOfRegexp
+* assert.arrayOfUuid
+* assert.optionalArray
+* assert.optionalBool
+* assert.optionalBuffer
+* assert.optionalFunc
+* assert.optionalNumber
+* assert.optionalFinite
+* assert.optionalObject
+* assert.optionalString
+* assert.optionalStream
+* assert.optionalDate
+* assert.optionalRegexp
+* assert.optionalUuid
+* assert.optionalArrayOfArray
+* assert.optionalArrayOfBool
+* assert.optionalArrayOfBuffer
+* assert.optionalArrayOfFunc
+* assert.optionalArrayOfNumber
+* assert.optionalArrayOfFinite
+* assert.optionalArrayOfObject
+* assert.optionalArrayOfString
+* assert.optionalArrayOfStream
+* assert.optionalArrayOfDate
+* assert.optionalArrayOfRegexp
+* assert.optionalArrayOfUuid
+* assert.AssertionError
+* assert.fail
+* assert.ok
+* assert.equal
+* assert.notEqual
+* assert.deepEqual
+* assert.notDeepEqual
+* assert.strictEqual
+* assert.notStrictEqual
+* assert.throws
+* assert.doesNotThrow
+* assert.ifError
+
+# Installation
+
+    npm install assert-plus
+
+## License
+
+The MIT License (MIT)
+Copyright (c) 2012 Mark Cavage
+
+Permission is hereby granted, free of charge, to any person obtaining a copy of
+this software and associated documentation files (the "Software"), to deal in
+the Software without restriction, including without limitation the rights to
+use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
+the Software, and to permit persons to whom the Software is furnished to do so,
+subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all
+copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+SOFTWARE.
+
+## Bugs
+
+See <https://github.com/mcavage/node-assert-plus/issues>.
diff --git a/tools/node_modules/forkexec/node_modules/assert-plus/assert.js b/tools/node_modules/forkexec/node_modules/assert-plus/assert.js
new file mode 100644
index 00000000..26f944ee
--- /dev/null
+++ b/tools/node_modules/forkexec/node_modules/assert-plus/assert.js
@@ -0,0 +1,211 @@
+// Copyright (c) 2012, Mark Cavage. All rights reserved.
+// Copyright 2015 Joyent, Inc.
+
+var assert = require('assert');
+var Stream = require('stream').Stream;
+var util = require('util');
+
+
+///--- Globals
+
+/* JSSTYLED */
+var UUID_REGEXP = /^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/;
+
+
+///--- Internal
+
+function _capitalize(str) {
+    return (str.charAt(0).toUpperCase() + str.slice(1));
+}
+
+function _toss(name, expected, oper, arg, actual) {
+    throw new assert.AssertionError({
+        message: util.format('%s (%s) is required', name, expected),
+        actual: (actual === undefined) ? typeof (arg) : actual(arg),
+        expected: expected,
+        operator: oper || '===',
+        stackStartFunction: _toss.caller
+    });
+}
+
+function _getClass(arg) {
+    return (Object.prototype.toString.call(arg).slice(8, -1));
+}
+
+function noop() {
+    // Why even bother with asserts?
+}
+
+
+///--- Exports
+
+var types = {
+    bool: {
+        check: function (arg) { return typeof (arg) === 'boolean'; }
+    },
+    func: {
+        check: function (arg) { return typeof (arg) === 'function'; }
+    },
+    string: {
+        check: function (arg) { return typeof (arg) === 'string'; }
+    },
+    object: {
+        check: function (arg) {
+            return typeof (arg) === 'object' && arg !== null;
+        }
+    },
+    number: {
+        check: function (arg) {
+            return typeof (arg) === 'number' && !isNaN(arg);
+        }
+    },
+    finite: {
+        check: function (arg) {
+            return typeof (arg) === 'number' && !isNaN(arg) && isFinite(arg);
+        }
+    },
+    buffer: {
+        check: function (arg) { return Buffer.isBuffer(arg); },
+        operator: 'Buffer.isBuffer'
+    },
+    array: {
+        check: function (arg) { return Array.isArray(arg); },
+        operator: 'Array.isArray'
+    },
+    stream: {
+        check: function (arg) { return arg instanceof Stream; },
+        operator: 'instanceof',
+        actual: _getClass
+    },
+    date: {
+        check: function (arg) { return arg instanceof Date; },
+        operator: 'instanceof',
+        actual: _getClass
+    },
+    regexp: {
+        check: function (arg) { return arg instanceof RegExp; },
+        operator: 'instanceof',
+        actual: _getClass
+    },
+    uuid: {
+        check: function (arg) {
+            return typeof (arg) === 'string' && UUID_REGEXP.test(arg);
+        },
+        operator: 'isUUID'
+    }
+};
+
+function _setExports(ndebug) {
+    var keys = Object.keys(types);
+    var out;
+
+    /* re-export standard assert */
+    if (process.env.NODE_NDEBUG) {
+        out = noop;
+    } else {
+        out = function (arg, msg) {
+            if (!arg) {
+                _toss(msg, 'true', arg);
+            }
+        };
+    }
+
+    /* standard checks */
+    keys.forEach(function (k) {
+        if (ndebug) {
+            out[k] = noop;
+            return;
+        }
+        var type = types[k];
+        out[k] = function (arg, msg) {
+            if (!type.check(arg)) {
+                _toss(msg, k, type.operator, arg, type.actual);
+            }
+        };
+    });
+
+    /* optional checks */
+    keys.forEach(function (k) {
+        var name = 'optional' + _capitalize(k);
+        if (ndebug) {
+            out[name] = noop;
+            return;
+        }
+        var type = types[k];
+        out[name] = function (arg, msg) {
+            if (arg === undefined || arg === null) {
+                return;
+            }
+            if (!type.check(arg)) {
+                _toss(msg, k, type.operator, arg, type.actual);
+            }
+        };
+    });
+
+    /* arrayOf checks */
+    keys.forEach(function (k) {
+        var name = 'arrayOf' + _capitalize(k);
+        if (ndebug) {
+            out[name] = noop;
+            return;
+        }
+        var type = types[k];
+        var expected = '[' + k + ']';
+        out[name] = function (arg, msg) {
+            if (!Array.isArray(arg)) {
+                _toss(msg, expected, type.operator, arg, type.actual);
+            }
+            var i;
+            for (i = 0; i < arg.length; i++) {
+                if (!type.check(arg[i])) {
+                    _toss(msg, expected, type.operator, arg, type.actual);
+                }
+            }
+        };
+    });
+
+    /* optionalArrayOf checks */
+    keys.forEach(function (k) {
+        var name = 'optionalArrayOf' + _capitalize(k);
+        if (ndebug) {
+            out[name] = noop;
+            return;
+        }
+        var type = types[k];
+        var expected = '[' + k + ']';
+        out[name] = function (arg, msg) {
+            if (arg === undefined || arg === null) {
+                return;
+            }
+            if (!Array.isArray(arg)) {
+                _toss(msg, expected, type.operator, arg, type.actual);
+            }
+            var i;
+            for (i = 0; i < arg.length; i++) {
+                if (!type.check(arg[i])) {
+                    _toss(msg, expected, type.operator, arg, type.actual);
+                }
+            }
+        };
+    });
+
+    /* re-export built-in assertions */
+    Object.keys(assert).forEach(function (k) {
+        if (k === 'AssertionError') {
+            out[k] = assert[k];
+            return;
+        }
+        if (ndebug) {
+            out[k] = noop;
+            return;
+        }
+        out[k] = assert[k];
+    });
+
+    /* export ourselves (for unit tests _only_) */
+    out._setExports = _setExports;
+
+    return out;
+}
+
+module.exports = _setExports(process.env.NODE_NDEBUG);
diff --git a/tools/node_modules/forkexec/node_modules/assert-plus/package.json b/tools/node_modules/forkexec/node_modules/assert-plus/package.json
new file mode 100644
index 00000000..4e1f49e1
--- /dev/null
+++ b/tools/node_modules/forkexec/node_modules/assert-plus/package.json
@@ -0,0 +1,73 @@
+{
+  "author": {
+    "name": "Mark Cavage",
+    "email": "mcavage@gmail.com"
+  },
+  "bugs": {
+    "url": "https://github.com/mcavage/node-assert-plus/issues"
+  },
+  "contributors": [
+    {
+      "name": "Dave Eddy",
+      "email": "dave@daveeddy.com"
+    },
+    {
+      "name": "Fred Kuo",
+      "email": "fred.kuo@joyent.com"
+    },
+    {
+      "name": "Lars-Magnus Skog",
+      "email": "ralphtheninja@riseup.net"
+    },
+    {
+      "name": "Mark Cavage",
+      "email": "mcavage@gmail.com"
+    },
+    {
+      "name": "Patrick Mooney",
+      "email": "pmooney@pfmooney.com"
+    },
+    {
+      "name": "Rob Gulewich",
+      "email": "robert.gulewich@joyent.com"
+    }
+  ],
+  "dependencies": {},
+  "description": "Extra assertions on top of node's assert module",
+  "devDependencies": {
+    "faucet": "0.0.1",
+    "tape": "4.2.2"
+  },
+  "directories": {},
+  "dist": {
+    "shasum": "f12e0f3c5d77b0b1cdd9146942e4e96c1e4dd525",
+    "tarball": "https://registry.npmjs.org/assert-plus/-/assert-plus-1.0.0.tgz"
+  },
+  "engines": {
+    "node": ">=0.8"
+  },
+  "homepage": "https://github.com/mcavage/node-assert-plus#readme",
+  "license": "MIT",
+  "main": "./assert.js",
+  "maintainers": [
+    {
+      "name": "mcavage",
+      "email": "mcavage@gmail.com"
+    },
+    {
+      "name": "pfmooney",
+      "email": "patrick.f.mooney@gmail.com"
+    }
+  ],
+  "name": "assert-plus",
+  "optionalDependencies": {},
+  "readme": "ERROR: No README data found!",
+  "repository": {
+    "type": "git",
+    "url": "git+https://github.com/mcavage/node-assert-plus.git"
+  },
+  "scripts": {
+    "test": "tape tests/*.js | ./node_modules/.bin/faucet"
+  },
+  "version": "1.0.0"
+}
\ No newline at end of file
diff --git a/tools/node_modules/forkexec/package.json b/tools/node_modules/forkexec/package.json
new file mode 100644
index 00000000..ade73715
--- /dev/null
+++ b/tools/node_modules/forkexec/package.json
@@ -0,0 +1,45 @@
+{
+  "author": {
+    "name": "Joyent",
+    "url": "joyent.com"
+  },
+  "bugs": {
+    "url": "https://github.com/joyent/node-forkexec/issues"
+  },
+  "dependencies": {
+    "assert-plus": "^1.0.0",
+    "verror": "^1.6.0"
+  },
+  "description": "sane child process library",
+  "devDependencies": {},
+  "directories": {},
+  "dist": {
+    "shasum": "abd8cee71277bfaa5d23380a84199a324bb2b0e6",
+    "tarball": "https://registry.npmjs.org/forkexec/-/forkexec-1.1.0.tgz"
+  },
+  "gitHead": "5427cedebd103275b0ba3e0733dc586b80446d0e",
+  "homepage": "https://github.com/joyent/node-forkexec#readme",
+  "license": "MIT",
+  "main": "./lib/forkexec.js",
+  "maintainers": [
+    {
+      "name": "dap",
+      "email": "dap@cs.brown.edu"
+    },
+    {
+      "name": "jclulow",
+      "email": "josh@sysmgr.org"
+    }
+  ],
+  "name": "forkexec",
+  "optionalDependencies": {},
+  "readme": "ERROR: No README data found!",
+  "repository": {
+    "type": "git",
+    "url": "git://github.com/joyent/node-forkexec.git"
+  },
+  "scripts": {
+    "test": "make test"
+  },
+  "version": "1.1.0"
+}
\ No newline at end of file
diff --git a/tools/node_modules/glob/LICENSE b/tools/node_modules/glob/LICENSE
new file mode 100644
index 00000000..19129e31
--- /dev/null
+++ b/tools/node_modules/glob/LICENSE
@@ -0,0 +1,15 @@
+The ISC License
+
+Copyright (c) Isaac Z. Schlueter and Contributors
+
+Permission to use, copy, modify, and/or distribute this software for any
+purpose with or without fee is hereby granted, provided that the above
+copyright notice and this permission notice appear in all copies.
+
+THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR
+IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
diff --git a/tools/node_modules/glob/README.md b/tools/node_modules/glob/README.md
new file mode 100644
index 00000000..258257ec
--- /dev/null
+++ b/tools/node_modules/glob/README.md
@@ -0,0 +1,369 @@
+[![Build Status](https://travis-ci.org/isaacs/node-glob.svg?branch=master)](https://travis-ci.org/isaacs/node-glob/) [![Dependency Status](https://david-dm.org/isaacs/node-glob.svg)](https://david-dm.org/isaacs/node-glob) [![devDependency Status](https://david-dm.org/isaacs/node-glob/dev-status.svg)](https://david-dm.org/isaacs/node-glob#info=devDependencies) [![optionalDependency Status](https://david-dm.org/isaacs/node-glob/optional-status.svg)](https://david-dm.org/isaacs/node-glob#info=optionalDependencies)
+
+# Glob
+
+Match files using the patterns the shell uses, like stars and stuff.
+
+This is a glob implementation in JavaScript.  It uses the `minimatch`
+library to do its matching.
+
+![](oh-my-glob.gif)
+
+## Usage
+
+```javascript
+var glob = require("glob")
+
+// options is optional
+glob("**/*.js", options, function (er, files) {
+  // files is an array of filenames.
+  // If the `nonull` option is set, and nothing
+  // was found, then files is ["**/*.js"]
+  // er is an error object or null.
+})
+```
+
+## Glob Primer
+
+"Globs" are the patterns you type when you do stuff like `ls *.js` on
+the command line, or put `build/*` in a `.gitignore` file.
+
+Before parsing the path part patterns, braced sections are expanded
+into a set.  Braced sections start with `{` and end with `}`, with any
+number of comma-delimited sections within.  Braced sections may contain
+slash characters, so `a{/b/c,bcd}` would expand into `a/b/c` and `abcd`.
+
+The following characters have special magic meaning when used in a
+path portion:
+
+* `*` Matches 0 or more characters in a single path portion
+* `?` Matches 1 character
+* `[...]` Matches a range of characters, similar to a RegExp range.
+  If the first character of the range is `!` or `^` then it matches
+  any character not in the range.
+* `!(pattern|pattern|pattern)` Matches anything that does not match
+  any of the patterns provided.
+* `?(pattern|pattern|pattern)` Matches zero or one occurrence of the
+  patterns provided.
+* `+(pattern|pattern|pattern)` Matches one or more occurrences of the
+  patterns provided.
+* `*(a|b|c)` Matches zero or more occurrences of the patterns provided
+* `@(pattern|pat*|pat?erN)` Matches exactly one of the patterns
+  provided
+* `**` If a "globstar" is alone in a path portion, then it matches
+  zero or more directories and subdirectories searching for matches.
+  It does not crawl symlinked directories.
+
+### Dots
+
+If a file or directory path portion has a `.` as the first character,
+then it will not match any glob pattern unless that pattern's
+corresponding path part also has a `.` as its first character.
+
+For example, the pattern `a/.*/c` would match the file at `a/.b/c`.
+However the pattern `a/*/c` would not, because `*` does not start with
+a dot character.
+
+You can make glob treat dots as normal characters by setting
+`dot:true` in the options.
+
+### Basename Matching
+
+If you set `matchBase:true` in the options, and the pattern has no
+slashes in it, then it will seek for any file anywhere in the tree
+with a matching basename.  For example, `*.js` would match
+`test/simple/basic.js`.
+
+### Negation
+
+The intent for negation would be for a pattern starting with `!` to
+match everything that *doesn't* match the supplied pattern.  However,
+the implementation is weird, and for the time being, this should be
+avoided.  The behavior will change or be deprecated in version 5.
+
+### Empty Sets
+
+If no matching files are found, then an empty array is returned.  This
+differs from the shell, where the pattern itself is returned.  For
+example:
+
+    $ echo a*s*d*f
+    a*s*d*f
+
+To get the bash-style behavior, set the `nonull:true` in the options.
+
+### See Also:
+
+* `man sh`
+* `man bash` (Search for "Pattern Matching")
+* `man 3 fnmatch`
+* `man 5 gitignore`
+* [minimatch documentation](https://github.com/isaacs/minimatch)
+
+## glob.hasMagic(pattern, [options])
+
+Returns `true` if there are any special characters in the pattern, and
+`false` otherwise.
+
+Note that the options affect the results.  If `noext:true` is set in
+the options object, then `+(a|b)` will not be considered a magic
+pattern.  If the pattern has a brace expansion, like `a/{b/c,x/y}`
+then that is considered magical, unless `nobrace:true` is set in the
+options.
+
+## glob(pattern, [options], cb)
+
+* `pattern` {String} Pattern to be matched
+* `options` {Object}
+* `cb` {Function}
+  * `err` {Error | null}
+  * `matches` {Array<String>} filenames found matching the pattern
+
+Perform an asynchronous glob search.
+
+## glob.sync(pattern, [options])
+
+* `pattern` {String} Pattern to be matched
+* `options` {Object}
+* return: {Array<String>} filenames found matching the pattern
+
+Perform a synchronous glob search.
+
+## Class: glob.Glob
+
+Create a Glob object by instantiating the `glob.Glob` class.
+
+```javascript
+var Glob = require("glob").Glob
+var mg = new Glob(pattern, options, cb)
+```
+
+It's an EventEmitter, and starts walking the filesystem to find matches
+immediately.
+
+### new glob.Glob(pattern, [options], [cb])
+
+* `pattern` {String} pattern to search for
+* `options` {Object}
+* `cb` {Function} Called when an error occurs, or matches are found
+  * `err` {Error | null}
+  * `matches` {Array<String>} filenames found matching the pattern
+
+Note that if the `sync` flag is set in the options, then matches will
+be immediately available on the `g.found` member.
+
+### Properties
+
+* `minimatch` The minimatch object that the glob uses.
+* `options` The options object passed in.
+* `aborted` Boolean which is set to true when calling `abort()`.  There
+  is no way at this time to continue a glob search after aborting, but
+  you can re-use the statCache to avoid having to duplicate syscalls.
+* `statCache` Collection of all the stat results the glob search
+  performed.
+* `cache` Convenience object.  Each field has the following possible
+  values:
+  * `false` - Path does not exist
+  * `true` - Path exists
+  * `'DIR'` - Path exists, and is not a directory
+  * `'FILE'` - Path exists, and is a directory
+  * `[file, entries, ...]` - Path exists, is a directory, and the
+    array value is the results of `fs.readdir`
+* `statCache` Cache of `fs.stat` results, to prevent statting the same
+  path multiple times.
+* `symlinks` A record of which paths are symbolic links, which is
+  relevant in resolving `**` patterns.
+* `realpathCache` An optional object which is passed to `fs.realpath`
+  to minimize unnecessary syscalls.  It is stored on the instantiated
+  Glob object, and may be re-used.
+
+### Events
+
+* `end` When the matching is finished, this is emitted with all the
+  matches found.  If the `nonull` option is set, and no match was found,
+  then the `matches` list contains the original pattern.  The matches
+  are sorted, unless the `nosort` flag is set.
+* `match` Every time a match is found, this is emitted with the matched.
+* `error` Emitted when an unexpected error is encountered, or whenever
+  any fs error occurs if `options.strict` is set.
+* `abort` When `abort()` is called, this event is raised.
+
+### Methods
+
+* `pause` Temporarily stop the search
+* `resume` Resume the search
+* `abort` Stop the search forever
+
+### Options
+
+All the options that can be passed to Minimatch can also be passed to
+Glob to change pattern matching behavior.  Also, some have been added,
+or have glob-specific ramifications.
+
+All options are false by default, unless otherwise noted.
+
+All options are added to the Glob object, as well.
+
+If you are running many `glob` operations, you can pass a Glob object
+as the `options` argument to a subsequent operation to shortcut some
+`stat` and `readdir` calls.  At the very least, you may pass in shared
+`symlinks`, `statCache`, `realpathCache`, and `cache` options, so that
+parallel glob operations will be sped up by sharing information about
+the filesystem.
+
+* `cwd` The current working directory in which to search.  Defaults
+  to `process.cwd()`.
+* `root` The place where patterns starting with `/` will be mounted
+  onto.  Defaults to `path.resolve(options.cwd, "/")` (`/` on Unix
+  systems, and `C:\` or some such on Windows.)
+* `dot` Include `.dot` files in normal matches and `globstar` matches.
+  Note that an explicit dot in a portion of the pattern will always
+  match dot files.
+* `nomount` By default, a pattern starting with a forward-slash will be
+  "mounted" onto the root setting, so that a valid filesystem path is
+  returned.  Set this flag to disable that behavior.
+* `mark` Add a `/` character to directory matches.  Note that this
+  requires additional stat calls.
+* `nosort` Don't sort the results.
+* `stat` Set to true to stat *all* results.  This reduces performance
+  somewhat, and is completely unnecessary, unless `readdir` is presumed
+  to be an untrustworthy indicator of file existence.
+* `silent` When an unusual error is encountered when attempting to
+  read a directory, a warning will be printed to stderr.  Set the
+  `silent` option to true to suppress these warnings.
+* `strict` When an unusual error is encountered when attempting to
+  read a directory, the process will just continue on in search of
+  other matches.  Set the `strict` option to raise an error in these
+  cases.
+* `cache` See `cache` property above.  Pass in a previously generated
+  cache object to save some fs calls.
+* `statCache` A cache of results of filesystem information, to prevent
+  unnecessary stat calls.  While it should not normally be necessary
+  to set this, you may pass the statCache from one glob() call to the
+  options object of another, if you know that the filesystem will not
+  change between calls.  (See "Race Conditions" below.)
+* `symlinks` A cache of known symbolic links.  You may pass in a
+  previously generated `symlinks` object to save `lstat` calls when
+  resolving `**` matches.
+* `sync` DEPRECATED: use `glob.sync(pattern, opts)` instead.
+* `nounique` In some cases, brace-expanded patterns can result in the
+  same file showing up multiple times in the result set.  By default,
+  this implementation prevents duplicates in the result set.  Set this
+  flag to disable that behavior.
+* `nonull` Set to never return an empty set, instead returning a set
+  containing the pattern itself.  This is the default in glob(3).
+* `debug` Set to enable debug logging in minimatch and glob.
+* `nobrace` Do not expand `{a,b}` and `{1..3}` brace sets.
+* `noglobstar` Do not match `**` against multiple filenames.  (Ie,
+  treat it as a normal `*` instead.)
+* `noext` Do not match `+(a|b)` "extglob" patterns.
+* `nocase` Perform a case-insensitive match.  Note: on
+  case-insensitive filesystems, non-magic patterns will match by
+  default, since `stat` and `readdir` will not raise errors.
+* `matchBase` Perform a basename-only match if the pattern does not
+  contain any slash characters.  That is, `*.js` would be treated as
+  equivalent to `**/*.js`, matching all js files in all directories.
+* `nonegate` Suppress `negate` behavior.  (See below.)
+* `nocomment` Suppress `comment` behavior.  (See below.)
+* `nonull` Return the pattern when no matches are found.
+* `nodir` Do not match directories, only files.  (Note: to match
+  *only* directories, simply put a `/` at the end of the pattern.)
+* `ignore` Add a pattern or an array of patterns to exclude matches.
+* `follow` Follow symlinked directories when expanding `**` patterns.
+  Note that this can result in a lot of duplicate references in the
+  presence of cyclic links.
+* `realpath` Set to true to call `fs.realpath` on all of the results.
+  In the case of a symlink that cannot be resolved, the full absolute
+  path to the matched entry is returned (though it will usually be a
+  broken symlink)
+
+## Comparisons to other fnmatch/glob implementations
+
+While strict compliance with the existing standards is a worthwhile
+goal, some discrepancies exist between node-glob and other
+implementations, and are intentional.
+
+If the pattern starts with a `!` character, then it is negated.  Set the
+`nonegate` flag to suppress this behavior, and treat leading `!`
+characters normally.  This is perhaps relevant if you wish to start the
+pattern with a negative extglob pattern like `!(a|B)`.  Multiple `!`
+characters at the start of a pattern will negate the pattern multiple
+times.
+
+If a pattern starts with `#`, then it is treated as a comment, and
+will not match anything.  Use `\#` to match a literal `#` at the
+start of a line, or set the `nocomment` flag to suppress this behavior.
+
+The double-star character `**` is supported by default, unless the
+`noglobstar` flag is set.  This is supported in the manner of bsdglob
+and bash 4.3, where `**` only has special significance if it is the only
+thing in a path part.  That is, `a/**/b` will match `a/x/y/b`, but
+`a/**b` will not.
+
+Note that symlinked directories are not crawled as part of a `**`,
+though their contents may match against subsequent portions of the
+pattern.  This prevents infinite loops and duplicates and the like.
+
+If an escaped pattern has no matches, and the `nonull` flag is set,
+then glob returns the pattern as-provided, rather than
+interpreting the character escapes.  For example,
+`glob.match([], "\\*a\\?")` will return `"\\*a\\?"` rather than
+`"*a?"`.  This is akin to setting the `nullglob` option in bash, except
+that it does not resolve escaped pattern characters.
+
+If brace expansion is not disabled, then it is performed before any
+other interpretation of the glob pattern.  Thus, a pattern like
+`+(a|{b),c)}`, which would not be valid in bash or zsh, is expanded
+**first** into the set of `+(a|b)` and `+(a|c)`, and those patterns are
+checked for validity.  Since those two are valid, matching proceeds.
+
+## Windows
+
+**Please only use forward-slashes in glob expressions.**
+
+Though windows uses either `/` or `\` as its path separator, only `/`
+characters are used by this glob implementation.  You must use
+forward-slashes **only** in glob expressions.  Back-slashes will always
+be interpreted as escape characters, not path separators.
+
+Results from absolute patterns such as `/foo/*` are mounted onto the
+root setting using `path.join`.  On windows, this will by default result
+in `/foo/*` matching `C:\foo\bar.txt`.
+
+## Race Conditions
+
+Glob searching, by its very nature, is susceptible to race conditions,
+since it relies on directory walking and such.
+
+As a result, it is possible that a file that exists when glob looks for
+it may have been deleted or modified by the time it returns the result.
+
+As part of its internal implementation, this program caches all stat
+and readdir calls that it makes, in order to cut down on system
+overhead.  However, this also makes it even more susceptible to races,
+especially if the cache or statCache objects are reused between glob
+calls.
+
+Users are thus advised not to use a glob result as a guarantee of
+filesystem state in the face of rapid changes.  For the vast majority
+of operations, this is never a problem.
+
+## Contributing
+
+Any change to behavior (including bugfixes) must come with a test.
+
+Patches that fail tests or reduce performance will be rejected.
+
+```
+# to run tests
+npm test
+
+# to re-generate test fixtures
+npm run test-regen
+
+# to benchmark against bash/zsh
+npm run bench
+
+# to profile javascript
+npm run prof
+```
diff --git a/tools/node_modules/glob/common.js b/tools/node_modules/glob/common.js
new file mode 100644
index 00000000..cd7c8244
--- /dev/null
+++ b/tools/node_modules/glob/common.js
@@ -0,0 +1,237 @@
+exports.alphasort = alphasort
+exports.alphasorti = alphasorti
+exports.isAbsolute = process.platform === "win32" ? absWin : absUnix
+exports.setopts = setopts
+exports.ownProp = ownProp
+exports.makeAbs = makeAbs
+exports.finish = finish
+exports.mark = mark
+exports.isIgnored = isIgnored
+exports.childrenIgnored = childrenIgnored
+
+function ownProp (obj, field) {
+  return Object.prototype.hasOwnProperty.call(obj, field)
+}
+
+var path = require("path")
+var minimatch = require("minimatch")
+var Minimatch = minimatch.Minimatch
+
+function absWin (p) {
+  if (absUnix(p)) return true
+  // pull off the device/UNC bit from a windows path.
+  // from node's lib/path.js
+  var splitDeviceRe =
+      /^([a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?([\\\/])?([\s\S]*?)$/
+  var result = splitDeviceRe.exec(p)
+  var device = result[1] || ''
+  var isUnc = device && device.charAt(1) !== ':'
+  var isAbsolute = !!result[2] || isUnc // UNC paths are always absolute
+
+  return isAbsolute
+}
+
+function absUnix (p) {
+  return p.charAt(0) === "/" || p === ""
+}
+
+function alphasorti (a, b) {
+  return a.toLowerCase().localeCompare(b.toLowerCase())
+}
+
+function alphasort (a, b) {
+  return a.localeCompare(b)
+}
+
+function setupIgnores (self, options) {
+  self.ignore = options.ignore || []
+
+  if (!Array.isArray(self.ignore))
+    self.ignore = [self.ignore]
+
+  if (self.ignore.length) {
+    self.ignore = self.ignore.map(ignoreMap)
+  }
+}
+
+function ignoreMap (pattern) {
+  var gmatcher = null
+  if (pattern.slice(-3) === '/**') {
+    var gpattern = pattern.replace(/(\/\*\*)+$/, '')
+    gmatcher = new Minimatch(gpattern, { nonegate: true })
+  }
+
+  return {
+    matcher: new Minimatch(pattern, { nonegate: true }),
+    gmatcher: gmatcher
+  }
+}
+
+function setopts (self, pattern, options) {
+  if (!options)
+    options = {}
+
+  // base-matching: just use globstar for that.
+  if (options.matchBase && -1 === pattern.indexOf("/")) {
+    if (options.noglobstar) {
+      throw new Error("base matching requires globstar")
+    }
+    pattern = "**/" + pattern
+  }
+
+  self.pattern = pattern
+  self.strict = options.strict !== false
+  self.realpath = !!options.realpath
+  self.realpathCache = options.realpathCache || Object.create(null)
+  self.follow = !!options.follow
+  self.dot = !!options.dot
+  self.mark = !!options.mark
+  self.nodir = !!options.nodir
+  if (self.nodir)
+    self.mark = true
+  self.sync = !!options.sync
+  self.nounique = !!options.nounique
+  self.nonull = !!options.nonull
+  self.nosort = !!options.nosort
+  self.nocase = !!options.nocase
+  self.stat = !!options.stat
+  self.noprocess = !!options.noprocess
+
+  self.maxLength = options.maxLength || Infinity
+  self.cache = options.cache || Object.create(null)
+  self.statCache = options.statCache || Object.create(null)
+  self.symlinks = options.symlinks || Object.create(null)
+
+  setupIgnores(self, options)
+
+  self.changedCwd = false
+  var cwd = process.cwd()
+  if (!ownProp(options, "cwd"))
+    self.cwd = cwd
+  else {
+    self.cwd = options.cwd
+    self.changedCwd = path.resolve(options.cwd) !== cwd
+  }
+
+  self.root = options.root || path.resolve(self.cwd, "/")
+  self.root = path.resolve(self.root)
+  if (process.platform === "win32")
+    self.root = self.root.replace(/\\/g, "/")
+
+  self.nomount = !!options.nomount
+
+  self.minimatch = new Minimatch(pattern, options)
+  self.options = self.minimatch.options
+}
+
+function finish (self) {
+  var nou = self.nounique
+  var all = nou ? [] : Object.create(null)
+
+  for (var i = 0, l = self.matches.length; i < l; i ++) {
+    var matches = self.matches[i]
+    if (!matches || Object.keys(matches).length === 0) {
+      if (self.nonull) {
+        // do like the shell, and spit out the literal glob
+        var literal = self.minimatch.globSet[i]
+        if (nou)
+          all.push(literal)
+        else
+          all[literal] = true
+      }
+    } else {
+      // had matches
+      var m = Object.keys(matches)
+      if (nou)
+        all.push.apply(all, m)
+      else
+        m.forEach(function (m) {
+          all[m] = true
+        })
+    }
+  }
+
+  if (!nou)
+    all = Object.keys(all)
+
+  if (!self.nosort)
+    all = all.sort(self.nocase ? alphasorti : alphasort)
+
+  // at *some* point we statted all of these
+  if (self.mark) {
+    for (var i = 0; i < all.length; i++) {
+      all[i] = self._mark(all[i])
+    }
+    if (self.nodir) {
+      all = all.filter(function (e) {
+        return !(/\/$/.test(e))
+      })
+    }
+  }
+
+  if (self.ignore.length)
+    all = all.filter(function(m) {
+      return !isIgnored(self, m)
+    })
+
+  self.found = all
+}
+
+function mark (self, p) {
+  var abs = makeAbs(self, p)
+  var c = self.cache[abs]
+  var m = p
+  if (c) {
+    var isDir = c === 'DIR' || Array.isArray(c)
+    var slash = p.slice(-1) === '/'
+
+    if (isDir && !slash)
+      m += '/'
+    else if (!isDir && slash)
+      m = m.slice(0, -1)
+
+    if (m !== p) {
+      var mabs = makeAbs(self, m)
+      self.statCache[mabs] = self.statCache[abs]
+      self.cache[mabs] = self.cache[abs]
+    }
+  }
+
+  return m
+}
+
+// lotta situps...
+function makeAbs (self, f) {
+  var abs = f
+  if (f.charAt(0) === '/') {
+    abs = path.join(self.root, f)
+  } else if (exports.isAbsolute(f)) {
+    abs = f
+  } else if (self.changedCwd) {
+    abs = path.resolve(self.cwd, f)
+  } else if (self.realpath) {
+    abs = path.resolve(f)
+  }
+  return abs
+}
+
+
+// Return true, if pattern ends with globstar '**', for the accompanying parent directory.
+// Ex:- If node_modules/** is the pattern, add 'node_modules' to ignore list along with it's contents
+function isIgnored (self, path) {
+  if (!self.ignore.length)
+    return false
+
+  return self.ignore.some(function(item) {
+    return item.matcher.match(path) || !!(item.gmatcher && item.gmatcher.match(path))
+  })
+}
+
+function childrenIgnored (self, path) {
+  if (!self.ignore.length)
+    return false
+
+  return self.ignore.some(function(item) {
+    return !!(item.gmatcher && item.gmatcher.match(path))
+  })
+}
diff --git a/tools/node_modules/glob/glob.js b/tools/node_modules/glob/glob.js
new file mode 100644
index 00000000..eac0693c
--- /dev/null
+++ b/tools/node_modules/glob/glob.js
@@ -0,0 +1,740 @@
+// Approach:
+//
+// 1. Get the minimatch set
+// 2. For each pattern in the set, PROCESS(pattern, false)
+// 3. Store matches per-set, then uniq them
+//
+// PROCESS(pattern, inGlobStar)
+// Get the first [n] items from pattern that are all strings
+// Join these together.  This is PREFIX.
+//   If there is no more remaining, then stat(PREFIX) and
+//   add to matches if it succeeds.  END.
+//
+// If inGlobStar and PREFIX is symlink and points to dir
+//   set ENTRIES = []
+// else readdir(PREFIX) as ENTRIES
+//   If fail, END
+//
+// with ENTRIES
+//   If pattern[n] is GLOBSTAR
+//     // handle the case where the globstar match is empty
+//     // by pruning it out, and testing the resulting pattern
+//     PROCESS(pattern[0..n] + pattern[n+1 .. $], false)
+//     // handle other cases.
+//     for ENTRY in ENTRIES (not dotfiles)
+//       // attach globstar + tail onto the entry
+//       // Mark that this entry is a globstar match
+//       PROCESS(pattern[0..n] + ENTRY + pattern[n .. $], true)
+//
+//   else // not globstar
+//     for ENTRY in ENTRIES (not dotfiles, unless pattern[n] is dot)
+//       Test ENTRY against pattern[n]
+//       If fails, continue
+//       If passes, PROCESS(pattern[0..n] + item + pattern[n+1 .. $])
+//
+// Caveat:
+//   Cache all stats and readdirs results to minimize syscall.  Since all
+//   we ever care about is existence and directory-ness, we can just keep
+//   `true` for files, and [children,...] for directories, or `false` for
+//   things that don't exist.
+
+module.exports = glob
+
+var fs = require('fs')
+var minimatch = require('minimatch')
+var Minimatch = minimatch.Minimatch
+var inherits = require('inherits')
+var EE = require('events').EventEmitter
+var path = require('path')
+var assert = require('assert')
+var globSync = require('./sync.js')
+var common = require('./common.js')
+var alphasort = common.alphasort
+var alphasorti = common.alphasorti
+var isAbsolute = common.isAbsolute
+var setopts = common.setopts
+var ownProp = common.ownProp
+var inflight = require('inflight')
+var util = require('util')
+var childrenIgnored = common.childrenIgnored
+
+var once = require('once')
+
+function glob (pattern, options, cb) {
+  if (typeof options === 'function') cb = options, options = {}
+  if (!options) options = {}
+
+  if (options.sync) {
+    if (cb)
+      throw new TypeError('callback provided to sync glob')
+    return globSync(pattern, options)
+  }
+
+  return new Glob(pattern, options, cb)
+}
+
+glob.sync = globSync
+var GlobSync = glob.GlobSync = globSync.GlobSync
+
+// old api surface
+glob.glob = glob
+
+glob.hasMagic = function (pattern, options_) {
+  var options = util._extend({}, options_)
+  options.noprocess = true
+
+  var g = new Glob(pattern, options)
+  var set = g.minimatch.set
+  if (set.length > 1)
+    return true
+
+  for (var j = 0; j < set[0].length; j++) {
+    if (typeof set[0][j] !== 'string')
+      return true
+  }
+
+  return false
+}
+
+glob.Glob = Glob
+inherits(Glob, EE)
+function Glob (pattern, options, cb) {
+  if (typeof options === 'function') {
+    cb = options
+    options = null
+  }
+
+  if (options && options.sync) {
+    if (cb)
+      throw new TypeError('callback provided to sync glob')
+    return new GlobSync(pattern, options)
+  }
+
+  if (!(this instanceof Glob))
+    return new Glob(pattern, options, cb)
+
+  setopts(this, pattern, options)
+  this._didRealPath = false
+
+  // process each pattern in the minimatch set
+  var n = this.minimatch.set.length
+
+  // The matches are stored as {<filename>: true,...} so that
+  // duplicates are automagically pruned.
+  // Later, we do an Object.keys() on these.
+  // Keep them as a list so we can fill in when nonull is set.
+  this.matches = new Array(n)
+
+  if (typeof cb === 'function') {
+    cb = once(cb)
+    this.on('error', cb)
+    this.on('end', function (matches) {
+      cb(null, matches)
+    })
+  }
+
+  var self = this
+  var n = this.minimatch.set.length
+  this._processing = 0
+  this.matches = new Array(n)
+
+  this._emitQueue = []
+  this._processQueue = []
+  this.paused = false
+
+  if (this.noprocess)
+    return this
+
+  if (n === 0)
+    return done()
+
+  for (var i = 0; i < n; i ++) {
+    this._process(this.minimatch.set[i], i, false, done)
+  }
+
+  function done () {
+    --self._processing
+    if (self._processing <= 0)
+      self._finish()
+  }
+}
+
+Glob.prototype._finish = function () {
+  assert(this instanceof Glob)
+  if (this.aborted)
+    return
+
+  if (this.realpath && !this._didRealpath)
+    return this._realpath()
+
+  common.finish(this)
+  this.emit('end', this.found)
+}
+
+Glob.prototype._realpath = function () {
+  if (this._didRealpath)
+    return
+
+  this._didRealpath = true
+
+  var n = this.matches.length
+  if (n === 0)
+    return this._finish()
+
+  var self = this
+  for (var i = 0; i < this.matches.length; i++)
+    this._realpathSet(i, next)
+
+  function next () {
+    if (--n === 0)
+      self._finish()
+  }
+}
+
+Glob.prototype._realpathSet = function (index, cb) {
+  var matchset = this.matches[index]
+  if (!matchset)
+    return cb()
+
+  var found = Object.keys(matchset)
+  var self = this
+  var n = found.length
+
+  if (n === 0)
+    return cb()
+
+  var set = this.matches[index] = Object.create(null)
+  found.forEach(function (p, i) {
+    // If there's a problem with the stat, then it means that
+    // one or more of the links in the realpath couldn't be
+    // resolved.  just return the abs value in that case.
+    p = self._makeAbs(p)
+    fs.realpath(p, self.realpathCache, function (er, real) {
+      if (!er)
+        set[real] = true
+      else if (er.syscall === 'stat')
+        set[p] = true
+      else
+        self.emit('error', er) // srsly wtf right here
+
+      if (--n === 0) {
+        self.matches[index] = set
+        cb()
+      }
+    })
+  })
+}
+
+Glob.prototype._mark = function (p) {
+  return common.mark(this, p)
+}
+
+Glob.prototype._makeAbs = function (f) {
+  return common.makeAbs(this, f)
+}
+
+Glob.prototype.abort = function () {
+  this.aborted = true
+  this.emit('abort')
+}
+
+Glob.prototype.pause = function () {
+  if (!this.paused) {
+    this.paused = true
+    this.emit('pause')
+  }
+}
+
+Glob.prototype.resume = function () {
+  if (this.paused) {
+    this.emit('resume')
+    this.paused = false
+    if (this._emitQueue.length) {
+      var eq = this._emitQueue.slice(0)
+      this._emitQueue.length = 0
+      for (var i = 0; i < eq.length; i ++) {
+        var e = eq[i]
+        this._emitMatch(e[0], e[1])
+      }
+    }
+    if (this._processQueue.length) {
+      var pq = this._processQueue.slice(0)
+      this._processQueue.length = 0
+      for (var i = 0; i < pq.length; i ++) {
+        var p = pq[i]
+        this._processing--
+        this._process(p[0], p[1], p[2], p[3])
+      }
+    }
+  }
+}
+
+Glob.prototype._process = function (pattern, index, inGlobStar, cb) {
+  assert(this instanceof Glob)
+  assert(typeof cb === 'function')
+
+  if (this.aborted)
+    return
+
+  this._processing++
+  if (this.paused) {
+    this._processQueue.push([pattern, index, inGlobStar, cb])
+    return
+  }
+
+  //console.error('PROCESS %d', this._processing, pattern)
+
+  // Get the first [n] parts of pattern that are all strings.
+  var n = 0
+  while (typeof pattern[n] === 'string') {
+    n ++
+  }
+  // now n is the index of the first one that is *not* a string.
+
+  // see if there's anything else
+  var prefix
+  switch (n) {
+    // if not, then this is rather simple
+    case pattern.length:
+      this._processSimple(pattern.join('/'), index, cb)
+      return
+
+    case 0:
+      // pattern *starts* with some non-trivial item.
+      // going to readdir(cwd), but not include the prefix in matches.
+      prefix = null
+      break
+
+    default:
+      // pattern has some string bits in the front.
+      // whatever it starts with, whether that's 'absolute' like /foo/bar,
+      // or 'relative' like '../baz'
+      prefix = pattern.slice(0, n).join('/')
+      break
+  }
+
+  var remain = pattern.slice(n)
+
+  // get the list of entries.
+  var read
+  if (prefix === null)
+    read = '.'
+  else if (isAbsolute(prefix) || isAbsolute(pattern.join('/'))) {
+    if (!prefix || !isAbsolute(prefix))
+      prefix = '/' + prefix
+    read = prefix
+  } else
+    read = prefix
+
+  var abs = this._makeAbs(read)
+
+  //if ignored, skip _processing
+  if (childrenIgnored(this, read))
+    return cb()
+
+  var isGlobStar = remain[0] === minimatch.GLOBSTAR
+  if (isGlobStar)
+    this._processGlobStar(prefix, read, abs, remain, index, inGlobStar, cb)
+  else
+    this._processReaddir(prefix, read, abs, remain, index, inGlobStar, cb)
+}
+
+Glob.prototype._processReaddir = function (prefix, read, abs, remain, index, inGlobStar, cb) {
+  var self = this
+  this._readdir(abs, inGlobStar, function (er, entries) {
+    return self._processReaddir2(prefix, read, abs, remain, index, inGlobStar, entries, cb)
+  })
+}
+
+Glob.prototype._processReaddir2 = function (prefix, read, abs, remain, index, inGlobStar, entries, cb) {
+
+  // if the abs isn't a dir, then nothing can match!
+  if (!entries)
+    return cb()
+
+  // It will only match dot entries if it starts with a dot, or if
+  // dot is set.  Stuff like @(.foo|.bar) isn't allowed.
+  var pn = remain[0]
+  var negate = !!this.minimatch.negate
+  var rawGlob = pn._glob
+  var dotOk = this.dot || rawGlob.charAt(0) === '.'
+
+  var matchedEntries = []
+  for (var i = 0; i < entries.length; i++) {
+    var e = entries[i]
+    if (e.charAt(0) !== '.' || dotOk) {
+      var m
+      if (negate && !prefix) {
+        m = !e.match(pn)
+      } else {
+        m = e.match(pn)
+      }
+      if (m)
+        matchedEntries.push(e)
+    }
+  }
+
+  //console.error('prd2', prefix, entries, remain[0]._glob, matchedEntries)
+
+  var len = matchedEntries.length
+  // If there are no matched entries, then nothing matches.
+  if (len === 0)
+    return cb()
+
+  // if this is the last remaining pattern bit, then no need for
+  // an additional stat *unless* the user has specified mark or
+  // stat explicitly.  We know they exist, since readdir returned
+  // them.
+
+  if (remain.length === 1 && !this.mark && !this.stat) {
+    if (!this.matches[index])
+      this.matches[index] = Object.create(null)
+
+    for (var i = 0; i < len; i ++) {
+      var e = matchedEntries[i]
+      if (prefix) {
+        if (prefix !== '/')
+          e = prefix + '/' + e
+        else
+          e = prefix + e
+      }
+
+      if (e.charAt(0) === '/' && !this.nomount) {
+        e = path.join(this.root, e)
+      }
+      this._emitMatch(index, e)
+    }
+    // This was the last one, and no stats were needed
+    return cb()
+  }
+
+  // now test all matched entries as stand-ins for that part
+  // of the pattern.
+  remain.shift()
+  for (var i = 0; i < len; i ++) {
+    var e = matchedEntries[i]
+    var newPattern
+    if (prefix) {
+      if (prefix !== '/')
+        e = prefix + '/' + e
+      else
+        e = prefix + e
+    }
+    this._process([e].concat(remain), index, inGlobStar, cb)
+  }
+  cb()
+}
+
+Glob.prototype._emitMatch = function (index, e) {
+  if (this.aborted)
+    return
+
+  if (this.matches[index][e])
+    return
+
+  if (this.paused) {
+    this._emitQueue.push([index, e])
+    return
+  }
+
+  var abs = this._makeAbs(e)
+
+  if (this.nodir) {
+    var c = this.cache[abs]
+    if (c === 'DIR' || Array.isArray(c))
+      return
+  }
+
+  if (this.mark)
+    e = this._mark(e)
+
+  this.matches[index][e] = true
+
+  var st = this.statCache[abs]
+  if (st)
+    this.emit('stat', e, st)
+
+  this.emit('match', e)
+}
+
+Glob.prototype._readdirInGlobStar = function (abs, cb) {
+  if (this.aborted)
+    return
+
+  // follow all symlinked directories forever
+  // just proceed as if this is a non-globstar situation
+  if (this.follow)
+    return this._readdir(abs, false, cb)
+
+  var lstatkey = 'lstat\0' + abs
+  var self = this
+  var lstatcb = inflight(lstatkey, lstatcb_)
+
+  if (lstatcb)
+    fs.lstat(abs, lstatcb)
+
+  function lstatcb_ (er, lstat) {
+    if (er)
+      return cb()
+
+    var isSym = lstat.isSymbolicLink()
+    self.symlinks[abs] = isSym
+
+    // If it's not a symlink or a dir, then it's definitely a regular file.
+    // don't bother doing a readdir in that case.
+    if (!isSym && !lstat.isDirectory()) {
+      self.cache[abs] = 'FILE'
+      cb()
+    } else
+      self._readdir(abs, false, cb)
+  }
+}
+
+Glob.prototype._readdir = function (abs, inGlobStar, cb) {
+  if (this.aborted)
+    return
+
+  cb = inflight('readdir\0'+abs+'\0'+inGlobStar, cb)
+  if (!cb)
+    return
+
+  //console.error('RD %j %j', +inGlobStar, abs)
+  if (inGlobStar && !ownProp(this.symlinks, abs))
+    return this._readdirInGlobStar(abs, cb)
+
+  if (ownProp(this.cache, abs)) {
+    var c = this.cache[abs]
+    if (!c || c === 'FILE')
+      return cb()
+
+    if (Array.isArray(c))
+      return cb(null, c)
+  }
+
+  var self = this
+  fs.readdir(abs, readdirCb(this, abs, cb))
+}
+
+function readdirCb (self, abs, cb) {
+  return function (er, entries) {
+    if (er)
+      self._readdirError(abs, er, cb)
+    else
+      self._readdirEntries(abs, entries, cb)
+  }
+}
+
+Glob.prototype._readdirEntries = function (abs, entries, cb) {
+  if (this.aborted)
+    return
+
+  // if we haven't asked to stat everything, then just
+  // assume that everything in there exists, so we can avoid
+  // having to stat it a second time.
+  if (!this.mark && !this.stat) {
+    for (var i = 0; i < entries.length; i ++) {
+      var e = entries[i]
+      if (abs === '/')
+        e = abs + e
+      else
+        e = abs + '/' + e
+      this.cache[e] = true
+    }
+  }
+
+  this.cache[abs] = entries
+  return cb(null, entries)
+}
+
+Glob.prototype._readdirError = function (f, er, cb) {
+  if (this.aborted)
+    return
+
+  // handle errors, and cache the information
+  switch (er.code) {
+    case 'ENOTDIR': // totally normal. means it *does* exist.
+      this.cache[this._makeAbs(f)] = 'FILE'
+      break
+
+    case 'ENOENT': // not terribly unusual
+    case 'ELOOP':
+    case 'ENAMETOOLONG':
+    case 'UNKNOWN':
+      this.cache[this._makeAbs(f)] = false
+      break
+
+    default: // some unusual error.  Treat as failure.
+      this.cache[this._makeAbs(f)] = false
+      if (this.strict) return this.emit('error', er)
+      if (!this.silent) console.error('glob error', er)
+      break
+  }
+  return cb()
+}
+
+Glob.prototype._processGlobStar = function (prefix, read, abs, remain, index, inGlobStar, cb) {
+  var self = this
+  this._readdir(abs, inGlobStar, function (er, entries) {
+    self._processGlobStar2(prefix, read, abs, remain, index, inGlobStar, entries, cb)
+  })
+}
+
+
+Glob.prototype._processGlobStar2 = function (prefix, read, abs, remain, index, inGlobStar, entries, cb) {
+  //console.error('pgs2', prefix, remain[0], entries)
+
+  // no entries means not a dir, so it can never have matches
+  // foo.txt/** doesn't match foo.txt
+  if (!entries)
+    return cb()
+
+  // test without the globstar, and with every child both below
+  // and replacing the globstar.
+  var remainWithoutGlobStar = remain.slice(1)
+  var gspref = prefix ? [ prefix ] : []
+  var noGlobStar = gspref.concat(remainWithoutGlobStar)
+
+  // the noGlobStar pattern exits the inGlobStar state
+  this._process(noGlobStar, index, false, cb)
+
+  var isSym = this.symlinks[abs]
+  var len = entries.length
+
+  // If it's a symlink, and we're in a globstar, then stop
+  if (isSym && inGlobStar)
+    return cb()
+
+  for (var i = 0; i < len; i++) {
+    var e = entries[i]
+    if (e.charAt(0) === '.' && !this.dot)
+      continue
+
+    // these two cases enter the inGlobStar state
+    var instead = gspref.concat(entries[i], remainWithoutGlobStar)
+    this._process(instead, index, true, cb)
+
+    var below = gspref.concat(entries[i], remain)
+    this._process(below, index, true, cb)
+  }
+
+  cb()
+}
+
+Glob.prototype._processSimple = function (prefix, index, cb) {
+  // XXX review this.  Shouldn't it be doing the mounting etc
+  // before doing stat?  kinda weird?
+  var self = this
+  this._stat(prefix, function (er, exists) {
+    self._processSimple2(prefix, index, er, exists, cb)
+  })
+}
+Glob.prototype._processSimple2 = function (prefix, index, er, exists, cb) {
+
+  //console.error('ps2', prefix, exists)
+
+  if (!this.matches[index])
+    this.matches[index] = Object.create(null)
+
+  // If it doesn't exist, then just mark the lack of results
+  if (!exists)
+    return cb()
+
+  if (prefix && isAbsolute(prefix) && !this.nomount) {
+    var trail = /[\/\\]$/.test(prefix)
+    if (prefix.charAt(0) === '/') {
+      prefix = path.join(this.root, prefix)
+    } else {
+      prefix = path.resolve(this.root, prefix)
+      if (trail)
+        prefix += '/'
+    }
+  }
+
+  if (process.platform === 'win32')
+    prefix = prefix.replace(/\\/g, '/')
+
+  // Mark this as a match
+  this._emitMatch(index, prefix)
+  cb()
+}
+
+// Returns either 'DIR', 'FILE', or false
+Glob.prototype._stat = function (f, cb) {
+  var abs = this._makeAbs(f)
+  var needDir = f.slice(-1) === '/'
+
+  if (f.length > this.maxLength)
+    return cb()
+
+  if (!this.stat && ownProp(this.cache, abs)) {
+    var c = this.cache[abs]
+
+    if (Array.isArray(c))
+      c = 'DIR'
+
+    // It exists, but maybe not how we need it
+    if (!needDir || c === 'DIR')
+      return cb(null, c)
+
+    if (needDir && c === 'FILE')
+      return cb()
+
+    // otherwise we have to stat, because maybe c=true
+    // if we know it exists, but not what it is.
+  }
+
+  var exists
+  var stat = this.statCache[abs]
+  if (stat !== undefined) {
+    if (stat === false)
+      return cb(null, stat)
+    else {
+      var type = stat.isDirectory() ? 'DIR' : 'FILE'
+      if (needDir && type === 'FILE')
+        return cb()
+      else
+        return cb(null, type, stat)
+    }
+  }
+
+  var self = this
+  var statcb = inflight('stat\0' + abs, lstatcb_)
+  if (statcb)
+    fs.lstat(abs, statcb)
+
+  function lstatcb_ (er, lstat) {
+    if (lstat && lstat.isSymbolicLink()) {
+      // If it's a symlink, then treat it as the target, unless
+      // the target does not exist, then treat it as a file.
+      return fs.stat(abs, function (er, stat) {
+        if (er)
+          self._stat2(f, abs, null, lstat, cb)
+        else
+          self._stat2(f, abs, er, stat, cb)
+      })
+    } else {
+      self._stat2(f, abs, er, lstat, cb)
+    }
+  }
+}
+
+Glob.prototype._stat2 = function (f, abs, er, stat, cb) {
+  if (er) {
+    this.statCache[abs] = false
+    return cb()
+  }
+
+  var needDir = f.slice(-1) === '/'
+  this.statCache[abs] = stat
+
+  if (abs.slice(-1) === '/' && !stat.isDirectory())
+    return cb(null, false, stat)
+
+  var c = stat.isDirectory() ? 'DIR' : 'FILE'
+  this.cache[abs] = this.cache[abs] || c
+
+  if (needDir && c !== 'DIR')
+    return cb()
+
+  return cb(null, c, stat)
+}
diff --git a/tools/node_modules/glob/node_modules/balanced-match/.npmignore b/tools/node_modules/glob/node_modules/balanced-match/.npmignore
new file mode 100644
index 00000000..ae5d8c36
--- /dev/null
+++ b/tools/node_modules/glob/node_modules/balanced-match/.npmignore
@@ -0,0 +1,5 @@
+test
+.gitignore
+.travis.yml
+Makefile
+example.js
diff --git a/tools/node_modules/glob/node_modules/balanced-match/LICENSE.md b/tools/node_modules/glob/node_modules/balanced-match/LICENSE.md
new file mode 100644
index 00000000..2cdc8e41
--- /dev/null
+++ b/tools/node_modules/glob/node_modules/balanced-match/LICENSE.md
@@ -0,0 +1,21 @@
+(MIT)
+
+Copyright (c) 2013 Julian Gruber &lt;julian@juliangruber.com&gt;
+
+Permission is hereby granted, free of charge, to any person obtaining a copy of
+this software and associated documentation files (the "Software"), to deal in
+the Software without restriction, including without limitation the rights to
+use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
+of the Software, and to permit persons to whom the Software is furnished to do
+so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all
+copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+SOFTWARE.
diff --git a/tools/node_modules/glob/node_modules/balanced-match/README.md b/tools/node_modules/glob/node_modules/balanced-match/README.md
new file mode 100644
index 00000000..08e918c0
--- /dev/null
+++ b/tools/node_modules/glob/node_modules/balanced-match/README.md
@@ -0,0 +1,91 @@
+# balanced-match
+
+Match balanced string pairs, like `{` and `}` or `<b>` and `</b>`. Supports regular expressions as well!
+
+[![build status](https://secure.travis-ci.org/juliangruber/balanced-match.svg)](http://travis-ci.org/juliangruber/balanced-match)
+[![downloads](https://img.shields.io/npm/dm/balanced-match.svg)](https://www.npmjs.org/package/balanced-match)
+
+[![testling badge](https://ci.testling.com/juliangruber/balanced-match.png)](https://ci.testling.com/juliangruber/balanced-match)
+
+## Example
+
+Get the first matching pair of braces:
+
+```js
+var balanced = require('balanced-match');
+
+console.log(balanced('{', '}', 'pre{in{nested}}post'));
+console.log(balanced('{', '}', 'pre{first}between{second}post'));
+console.log(balanced(/\s+\{\s+/, /\s+\}\s+/, 'pre  {   in{nest}   }  post'));
+```
+
+The matches are:
+
+```bash
+$ node example.js
+{ start: 3, end: 14, pre: 'pre', body: 'in{nested}', post: 'post' }
+{ start: 3,
+  end: 9,
+  pre: 'pre',
+  body: 'first',
+  post: 'between{second}post' }
+{ start: 3, end: 17, pre: 'pre', body: 'in{nest}', post: 'post' }
+```
+
+## API
+
+### var m = balanced(a, b, str)
+
+For the first non-nested matching pair of `a` and `b` in `str`, return an
+object with those keys:
+
+* **start** the index of the first match of `a`
+* **end** the index of the matching `b`
+* **pre** the preamble, `a` and `b` not included
+* **body** the match, `a` and `b` not included
+* **post** the postscript, `a` and `b` not included
+
+If there's no match, `undefined` will be returned.
+
+If the `str` contains more `a` than `b` / there are unmatched pairs, the first match that was closed will be used. For example, `{{a}` will match `['{', 'a', '']` and `{a}}` will match `['', 'a', '}']`.
+
+### var r = balanced.range(a, b, str)
+
+For the first non-nested matching pair of `a` and `b` in `str`, return an
+array with indexes: `[ <a index>, <b index> ]`.
+
+If there's no match, `undefined` will be returned.
+
+If the `str` contains more `a` than `b` / there are unmatched pairs, the first match that was closed will be used. For example, `{{a}` will match `[ 1, 3 ]` and `{a}}` will match `[0, 2]`.
+
+## Installation
+
+With [npm](https://npmjs.org) do:
+
+```bash
+npm install balanced-match
+```
+
+## License
+
+(MIT)
+
+Copyright (c) 2013 Julian Gruber &lt;julian@juliangruber.com&gt;
+
+Permission is hereby granted, free of charge, to any person obtaining a copy of
+this software and associated documentation files (the "Software"), to deal in
+the Software without restriction, including without limitation the rights to
+use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
+of the Software, and to permit persons to whom the Software is furnished to do
+so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all
+copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+SOFTWARE.
diff --git a/tools/node_modules/glob/node_modules/balanced-match/index.js b/tools/node_modules/glob/node_modules/balanced-match/index.js
new file mode 100644
index 00000000..1685a762
--- /dev/null
+++ b/tools/node_modules/glob/node_modules/balanced-match/index.js
@@ -0,0 +1,59 @@
+'use strict';
+module.exports = balanced;
+function balanced(a, b, str) {
+  if (a instanceof RegExp) a = maybeMatch(a, str);
+  if (b instanceof RegExp) b = maybeMatch(b, str);
+
+  var r = range(a, b, str);
+
+  return r && {
+    start: r[0],
+    end: r[1],
+    pre: str.slice(0, r[0]),
+    body: str.slice(r[0] + a.length, r[1]),
+    post: str.slice(r[1] + b.length)
+  };
+}
+
+function maybeMatch(reg, str) {
+  var m = str.match(reg);
+  return m ? m[0] : null;
+}
+
+balanced.range = range;
+function range(a, b, str) {
+  var begs, beg, left, right, result;
+  var ai = str.indexOf(a);
+  var bi = str.indexOf(b, ai + 1);
+  var i = ai;
+
+  if (ai >= 0 && bi > 0) {
+    begs = [];
+    left = str.length;
+
+    while (i >= 0 && !result) {
+      if (i == ai) {
+        begs.push(i);
+        ai = str.indexOf(a, i + 1);
+      } else if (begs.length == 1) {
+        result = [ begs.pop(), bi ];
+      } else {
+        beg = begs.pop();
+        if (beg < left) {
+          left = beg;
+          right = bi;
+        }
+
+        bi = str.indexOf(b, i + 1);
+      }
+
+      i = ai < bi && ai >= 0 ? ai : bi;
+    }
+
+    if (begs.length) {
+      result = [ left, right ];
+    }
+  }
+
+  return result;
+}
diff --git a/tools/node_modules/glob/node_modules/balanced-match/package.json b/tools/node_modules/glob/node_modules/balanced-match/package.json
new file mode 100644
index 00000000..96f41b73
--- /dev/null
+++ b/tools/node_modules/glob/node_modules/balanced-match/package.json
@@ -0,0 +1,66 @@
+{
+  "author": {
+    "name": "Julian Gruber",
+    "email": "mail@juliangruber.com",
+    "url": "http://juliangruber.com"
+  },
+  "bugs": {
+    "url": "https://github.com/juliangruber/balanced-match/issues"
+  },
+  "dependencies": {},
+  "description": "Match balanced character pairs, like \"{\" and \"}\"",
+  "devDependencies": {
+    "matcha": "^0.7.0",
+    "tape": "^4.6.0"
+  },
+  "directories": {},
+  "dist": {
+    "shasum": "89b4d199ab2bee49de164ea02b89ce462d71b767",
+    "tarball": "https://registry.npmjs.org/balanced-match/-/balanced-match-1.0.0.tgz"
+  },
+  "gitHead": "d701a549a7653a874eebce7eca25d3577dc868ac",
+  "homepage": "https://github.com/juliangruber/balanced-match",
+  "keywords": [
+    "match",
+    "regexp",
+    "test",
+    "balanced",
+    "parse"
+  ],
+  "license": "MIT",
+  "main": "index.js",
+  "maintainers": [
+    {
+      "name": "juliangruber",
+      "email": "julian@juliangruber.com"
+    }
+  ],
+  "name": "balanced-match",
+  "optionalDependencies": {},
+  "readme": "ERROR: No README data found!",
+  "repository": {
+    "type": "git",
+    "url": "git://github.com/juliangruber/balanced-match.git"
+  },
+  "scripts": {
+    "bench": "make bench",
+    "test": "make test"
+  },
+  "testling": {
+    "files": "test/*.js",
+    "browsers": [
+      "ie/8..latest",
+      "firefox/20..latest",
+      "firefox/nightly",
+      "chrome/25..latest",
+      "chrome/canary",
+      "opera/12..latest",
+      "opera/next",
+      "safari/5.1..latest",
+      "ipad/6.0..latest",
+      "iphone/6.0..latest",
+      "android-browser/4.2..latest"
+    ]
+  },
+  "version": "1.0.0"
+}
\ No newline at end of file
diff --git a/tools/node_modules/glob/node_modules/brace-expansion/LICENSE b/tools/node_modules/glob/node_modules/brace-expansion/LICENSE
new file mode 100644
index 00000000..de322667
--- /dev/null
+++ b/tools/node_modules/glob/node_modules/brace-expansion/LICENSE
@@ -0,0 +1,21 @@
+MIT License
+
+Copyright (c) 2013 Julian Gruber <julian@juliangruber.com>
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all
+copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+SOFTWARE.
diff --git a/tools/node_modules/glob/node_modules/brace-expansion/README.md b/tools/node_modules/glob/node_modules/brace-expansion/README.md
new file mode 100644
index 00000000..6b4e0e16
--- /dev/null
+++ b/tools/node_modules/glob/node_modules/brace-expansion/README.md
@@ -0,0 +1,129 @@
+# brace-expansion
+
+[Brace expansion](https://www.gnu.org/software/bash/manual/html_node/Brace-Expansion.html), 
+as known from sh/bash, in JavaScript.
+
+[![build status](https://secure.travis-ci.org/juliangruber/brace-expansion.svg)](http://travis-ci.org/juliangruber/brace-expansion)
+[![downloads](https://img.shields.io/npm/dm/brace-expansion.svg)](https://www.npmjs.org/package/brace-expansion)
+[![Greenkeeper badge](https://badges.greenkeeper.io/juliangruber/brace-expansion.svg)](https://greenkeeper.io/)
+
+[![testling badge](https://ci.testling.com/juliangruber/brace-expansion.png)](https://ci.testling.com/juliangruber/brace-expansion)
+
+## Example
+
+```js
+var expand = require('brace-expansion');
+
+expand('file-{a,b,c}.jpg')
+// => ['file-a.jpg', 'file-b.jpg', 'file-c.jpg']
+
+expand('-v{,,}')
+// => ['-v', '-v', '-v']
+
+expand('file{0..2}.jpg')
+// => ['file0.jpg', 'file1.jpg', 'file2.jpg']
+
+expand('file-{a..c}.jpg')
+// => ['file-a.jpg', 'file-b.jpg', 'file-c.jpg']
+
+expand('file{2..0}.jpg')
+// => ['file2.jpg', 'file1.jpg', 'file0.jpg']
+
+expand('file{0..4..2}.jpg')
+// => ['file0.jpg', 'file2.jpg', 'file4.jpg']
+
+expand('file-{a..e..2}.jpg')
+// => ['file-a.jpg', 'file-c.jpg', 'file-e.jpg']
+
+expand('file{00..10..5}.jpg')
+// => ['file00.jpg', 'file05.jpg', 'file10.jpg']
+
+expand('{{A..C},{a..c}}')
+// => ['A', 'B', 'C', 'a', 'b', 'c']
+
+expand('ppp{,config,oe{,conf}}')
+// => ['ppp', 'pppconfig', 'pppoe', 'pppoeconf']
+```
+
+## API
+
+```js
+var expand = require('brace-expansion');
+```
+
+### var expanded = expand(str)
+
+Return an array of all possible and valid expansions of `str`. If none are
+found, `[str]` is returned.
+
+Valid expansions are:
+
+```js
+/^(.*,)+(.+)?$/
+// {a,b,...}
+```
+
+A comma separated list of options, like `{a,b}` or `{a,{b,c}}` or `{,a,}`.
+
+```js
+/^-?\d+\.\.-?\d+(\.\.-?\d+)?$/
+// {x..y[..incr]}
+```
+
+A numeric sequence from `x` to `y` inclusive, with optional increment.
+If `x` or `y` start with a leading `0`, all the numbers will be padded
+to have equal length. Negative numbers and backwards iteration work too.
+
+```js
+/^-?\d+\.\.-?\d+(\.\.-?\d+)?$/
+// {x..y[..incr]}
+```
+
+An alphabetic sequence from `x` to `y` inclusive, with optional increment.
+`x` and `y` must be exactly one character, and if given, `incr` must be a
+number.
+
+For compatibility reasons, the string `${` is not eligible for brace expansion.
+
+## Installation
+
+With [npm](https://npmjs.org) do:
+
+```bash
+npm install brace-expansion
+```
+
+## Contributors
+
+- [Julian Gruber](https://github.com/juliangruber)
+- [Isaac Z. Schlueter](https://github.com/isaacs)
+
+## Sponsors
+
+This module is proudly supported by my [Sponsors](https://github.com/juliangruber/sponsors)!
+
+Do you want to support modules like this to improve their quality, stability and weigh in on new features? Then please consider donating to my [Patreon](https://www.patreon.com/juliangruber). Not sure how much of my modules you're using? Try [feross/thanks](https://github.com/feross/thanks)!
+
+## License
+
+(MIT)
+
+Copyright (c) 2013 Julian Gruber &lt;julian@juliangruber.com&gt;
+
+Permission is hereby granted, free of charge, to any person obtaining a copy of
+this software and associated documentation files (the "Software"), to deal in
+the Software without restriction, including without limitation the rights to
+use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
+of the Software, and to permit persons to whom the Software is furnished to do
+so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all
+copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+SOFTWARE.
diff --git a/tools/node_modules/glob/node_modules/brace-expansion/index.js b/tools/node_modules/glob/node_modules/brace-expansion/index.js
new file mode 100644
index 00000000..0478be81
--- /dev/null
+++ b/tools/node_modules/glob/node_modules/brace-expansion/index.js
@@ -0,0 +1,201 @@
+var concatMap = require('concat-map');
+var balanced = require('balanced-match');
+
+module.exports = expandTop;
+
+var escSlash = '\0SLASH'+Math.random()+'\0';
+var escOpen = '\0OPEN'+Math.random()+'\0';
+var escClose = '\0CLOSE'+Math.random()+'\0';
+var escComma = '\0COMMA'+Math.random()+'\0';
+var escPeriod = '\0PERIOD'+Math.random()+'\0';
+
+function numeric(str) {
+  return parseInt(str, 10) == str
+    ? parseInt(str, 10)
+    : str.charCodeAt(0);
+}
+
+function escapeBraces(str) {
+  return str.split('\\\\').join(escSlash)
+            .split('\\{').join(escOpen)
+            .split('\\}').join(escClose)
+            .split('\\,').join(escComma)
+            .split('\\.').join(escPeriod);
+}
+
+function unescapeBraces(str) {
+  return str.split(escSlash).join('\\')
+            .split(escOpen).join('{')
+            .split(escClose).join('}')
+            .split(escComma).join(',')
+            .split(escPeriod).join('.');
+}
+
+
+// Basically just str.split(","), but handling cases
+// where we have nested braced sections, which should be
+// treated as individual members, like {a,{b,c},d}
+function parseCommaParts(str) {
+  if (!str)
+    return [''];
+
+  var parts = [];
+  var m = balanced('{', '}', str);
+
+  if (!m)
+    return str.split(',');
+
+  var pre = m.pre;
+  var body = m.body;
+  var post = m.post;
+  var p = pre.split(',');
+
+  p[p.length-1] += '{' + body + '}';
+  var postParts = parseCommaParts(post);
+  if (post.length) {
+    p[p.length-1] += postParts.shift();
+    p.push.apply(p, postParts);
+  }
+
+  parts.push.apply(parts, p);
+
+  return parts;
+}
+
+function expandTop(str) {
+  if (!str)
+    return [];
+
+  // I don't know why Bash 4.3 does this, but it does.
+  // Anything starting with {} will have the first two bytes preserved
+  // but *only* at the top level, so {},a}b will not expand to anything,
+  // but a{},b}c will be expanded to [a}c,abc].
+  // One could argue that this is a bug in Bash, but since the goal of
+  // this module is to match Bash's rules, we escape a leading {}
+  if (str.substr(0, 2) === '{}') {
+    str = '\\{\\}' + str.substr(2);
+  }
+
+  return expand(escapeBraces(str), true).map(unescapeBraces);
+}
+
+function identity(e) {
+  return e;
+}
+
+function embrace(str) {
+  return '{' + str + '}';
+}
+function isPadded(el) {
+  return /^-?0\d/.test(el);
+}
+
+function lte(i, y) {
+  return i <= y;
+}
+function gte(i, y) {
+  return i >= y;
+}
+
+function expand(str, isTop) {
+  var expansions = [];
+
+  var m = balanced('{', '}', str);
+  if (!m || /\$$/.test(m.pre)) return [str];
+
+  var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
+  var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
+  var isSequence = isNumericSequence || isAlphaSequence;
+  var isOptions = m.body.indexOf(',') >= 0;
+  if (!isSequence && !isOptions) {
+    // {a},b}
+    if (m.post.match(/,.*\}/)) {
+      str = m.pre + '{' + m.body + escClose + m.post;
+      return expand(str);
+    }
+    return [str];
+  }
+
+  var n;
+  if (isSequence) {
+    n = m.body.split(/\.\./);
+  } else {
+    n = parseCommaParts(m.body);
+    if (n.length === 1) {
+      // x{{a,b}}y ==> x{a}y x{b}y
+      n = expand(n[0], false).map(embrace);
+      if (n.length === 1) {
+        var post = m.post.length
+          ? expand(m.post, false)
+          : [''];
+        return post.map(function(p) {
+          return m.pre + n[0] + p;
+        });
+      }
+    }
+  }
+
+  // at this point, n is the parts, and we know it's not a comma set
+  // with a single entry.
+
+  // no need to expand pre, since it is guaranteed to be free of brace-sets
+  var pre = m.pre;
+  var post = m.post.length
+    ? expand(m.post, false)
+    : [''];
+
+  var N;
+
+  if (isSequence) {
+    var x = numeric(n[0]);
+    var y = numeric(n[1]);
+    var width = Math.max(n[0].length, n[1].length)
+    var incr = n.length == 3
+      ? Math.abs(numeric(n[2]))
+      : 1;
+    var test = lte;
+    var reverse = y < x;
+    if (reverse) {
+      incr *= -1;
+      test = gte;
+    }
+    var pad = n.some(isPadded);
+
+    N = [];
+
+    for (var i = x; test(i, y); i += incr) {
+      var c;
+      if (isAlphaSequence) {
+        c = String.fromCharCode(i);
+        if (c === '\\')
+          c = '';
+      } else {
+        c = String(i);
+        if (pad) {
+          var need = width - c.length;
+          if (need > 0) {
+            var z = new Array(need + 1).join('0');
+            if (i < 0)
+              c = '-' + z + c.slice(1);
+            else
+              c = z + c;
+          }
+        }
+      }
+      N.push(c);
+    }
+  } else {
+    N = concatMap(n, function(el) { return expand(el, false) });
+  }
+
+  for (var j = 0; j < N.length; j++) {
+    for (var k = 0; k < post.length; k++) {
+      var expansion = pre + N[j] + post[k];
+      if (!isTop || isSequence || expansion)
+        expansions.push(expansion);
+    }
+  }
+
+  return expansions;
+}
+
diff --git a/tools/node_modules/glob/node_modules/brace-expansion/package.json b/tools/node_modules/glob/node_modules/brace-expansion/package.json
new file mode 100644
index 00000000..bc29dd86
--- /dev/null
+++ b/tools/node_modules/glob/node_modules/brace-expansion/package.json
@@ -0,0 +1,71 @@
+{
+  "author": {
+    "name": "Julian Gruber",
+    "email": "mail@juliangruber.com",
+    "url": "http://juliangruber.com"
+  },
+  "bugs": {
+    "url": "https://github.com/juliangruber/brace-expansion/issues"
+  },
+  "dependencies": {
+    "balanced-match": "^1.0.0",
+    "concat-map": "0.0.1"
+  },
+  "description": "Brace expansion as known from sh/bash",
+  "devDependencies": {
+    "matcha": "^0.7.0",
+    "tape": "^4.6.0"
+  },
+  "directories": {},
+  "dist": {
+    "integrity": "sha512-iCuPHDFgrHX7H2vEI/5xpz07zSHB00TpugqhmYtVmMO6518mCuRMoOYFldEBl0g187ufozdaHgWKcYFb61qGiA==",
+    "shasum": "3c7fcbf529d87226f3d2f52b966ff5271eb441dd",
+    "tarball": "https://registry.npmjs.org/brace-expansion/-/brace-expansion-1.1.11.tgz",
+    "fileCount": 4,
+    "unpackedSize": 11059
+  },
+  "gitHead": "01a21de7441549d26ac0c0a9ff91385d16e5c21c",
+  "homepage": "https://github.com/juliangruber/brace-expansion",
+  "keywords": [],
+  "license": "MIT",
+  "main": "index.js",
+  "maintainers": [
+    {
+      "name": "isaacs",
+      "email": "isaacs@npmjs.com"
+    },
+    {
+      "name": "juliangruber",
+      "email": "julian@juliangruber.com"
+    }
+  ],
+  "name": "brace-expansion",
+  "optionalDependencies": {},
+  "readme": "ERROR: No README data found!",
+  "repository": {
+    "type": "git",
+    "url": "git://github.com/juliangruber/brace-expansion.git"
+  },
+  "scripts": {
+    "bench": "matcha test/perf/bench.js",
+    "gentest": "bash test/generate.sh",
+    "test": "tape test/*.js"
+  },
+  "testling": {
+    "files": "test/*.js",
+    "browsers": [
+      "ie/8..latest",
+      "firefox/20..latest",
+      "firefox/nightly",
+      "chrome/25..latest",
+      "chrome/canary",
+      "opera/12..latest",
+      "opera/next",
+      "safari/5.1..latest",
+      "ipad/6.0..latest",
+      "iphone/6.0..latest",
+      "android-browser/4.2..latest"
+    ]
+  },
+  "version": "1.1.11"
+}
\ No newline at end of file
diff --git a/tools/node_modules/glob/node_modules/concat-map/.travis.yml b/tools/node_modules/glob/node_modules/concat-map/.travis.yml
new file mode 100644
index 00000000..f1d0f13c
--- /dev/null
+++ b/tools/node_modules/glob/node_modules/concat-map/.travis.yml
@@ -0,0 +1,4 @@
+language: node_js
+node_js:
+  - 0.4
+  - 0.6
diff --git a/tools/node_modules/glob/node_modules/concat-map/LICENSE b/tools/node_modules/glob/node_modules/concat-map/LICENSE
new file mode 100644
index 00000000..ee27ba4b
--- /dev/null
+++ b/tools/node_modules/glob/node_modules/concat-map/LICENSE
@@ -0,0 +1,18 @@
+This software is released under the MIT license:
+
+Permission is hereby granted, free of charge, to any person obtaining a copy of
+this software and associated documentation files (the "Software"), to deal in
+the Software without restriction, including without limitation the rights to
+use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
+the Software, and to permit persons to whom the Software is furnished to do so,
+subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all
+copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
diff --git a/tools/node_modules/glob/node_modules/concat-map/README.markdown b/tools/node_modules/glob/node_modules/concat-map/README.markdown
new file mode 100644
index 00000000..408f70a1
--- /dev/null
+++ b/tools/node_modules/glob/node_modules/concat-map/README.markdown
@@ -0,0 +1,62 @@
+concat-map
+==========
+
+Concatenative mapdashery.
+
+[![browser support](http://ci.testling.com/substack/node-concat-map.png)](http://ci.testling.com/substack/node-concat-map)
+
+[![build status](https://secure.travis-ci.org/substack/node-concat-map.png)](http://travis-ci.org/substack/node-concat-map)
+
+example
+=======
+
+``` js
+var concatMap = require('concat-map');
+var xs = [ 1, 2, 3, 4, 5, 6 ];
+var ys = concatMap(xs, function (x) {
+    return x % 2 ? [ x - 0.1, x, x + 0.1 ] : [];
+});
+console.dir(ys);
+```
+
+***
+
+```
+[ 0.9, 1, 1.1, 2.9, 3, 3.1, 4.9, 5, 5.1 ]
+```
+
+methods
+=======
+
+``` js
+var concatMap = require('concat-map')
+```
+
+concatMap(xs, fn)
+-----------------
+
+Return an array of concatenated elements by calling `fn(x, i)` for each element
+`x` and each index `i` in the array `xs`.
+
+When `fn(x, i)` returns an array, its result will be concatenated with the
+result array. If `fn(x, i)` returns anything else, that value will be pushed
+onto the end of the result array.
+
+install
+=======
+
+With [npm](http://npmjs.org) do:
+
+```
+npm install concat-map
+```
+
+license
+=======
+
+MIT
+
+notes
+=====
+
+This module was written while sitting high above the ground in a tree.
diff --git a/tools/node_modules/glob/node_modules/concat-map/example/map.js b/tools/node_modules/glob/node_modules/concat-map/example/map.js
new file mode 100644
index 00000000..33656217
--- /dev/null
+++ b/tools/node_modules/glob/node_modules/concat-map/example/map.js
@@ -0,0 +1,6 @@
+var concatMap = require('../');
+var xs = [ 1, 2, 3, 4, 5, 6 ];
+var ys = concatMap(xs, function (x) {
+    return x % 2 ? [ x - 0.1, x, x + 0.1 ] : [];
+});
+console.dir(ys);
diff --git a/tools/node_modules/glob/node_modules/concat-map/index.js b/tools/node_modules/glob/node_modules/concat-map/index.js
new file mode 100644
index 00000000..b29a7812
--- /dev/null
+++ b/tools/node_modules/glob/node_modules/concat-map/index.js
@@ -0,0 +1,13 @@
+module.exports = function (xs, fn) {
+    var res = [];
+    for (var i = 0; i < xs.length; i++) {
+        var x = fn(xs[i], i);
+        if (isArray(x)) res.push.apply(res, x);
+        else res.push(x);
+    }
+    return res;
+};
+
+var isArray = Array.isArray || function (xs) {
+    return Object.prototype.toString.call(xs) === '[object Array]';
+};
diff --git a/tools/node_modules/glob/node_modules/concat-map/package.json b/tools/node_modules/glob/node_modules/concat-map/package.json
new file mode 100644
index 00000000..c06af3ff
--- /dev/null
+++ b/tools/node_modules/glob/node_modules/concat-map/package.json
@@ -0,0 +1,76 @@
+{
+  "author": {
+    "name": "James Halliday",
+    "email": "mail@substack.net",
+    "url": "http://substack.net"
+  },
+  "bugs": {
+    "url": "https://github.com/substack/node-concat-map/issues"
+  },
+  "dependencies": {},
+  "description": "concatenative mapdashery",
+  "devDependencies": {
+    "tape": "~2.4.0"
+  },
+  "directories": {
+    "example": "example",
+    "test": "test"
+  },
+  "dist": {
+    "shasum": "d8a96bd77fd68df7793a73036a3ba0d5405d477b",
+    "tarball": "https://registry.npmjs.org/concat-map/-/concat-map-0.0.1.tgz"
+  },
+  "homepage": "https://github.com/substack/node-concat-map",
+  "keywords": [
+    "concat",
+    "concatMap",
+    "map",
+    "functional",
+    "higher-order"
+  ],
+  "license": "MIT",
+  "main": "index.js",
+  "maintainers": [
+    {
+      "name": "substack",
+      "email": "mail@substack.net"
+    }
+  ],
+  "name": "concat-map",
+  "optionalDependencies": {},
+  "readme": "ERROR: No README data found!",
+  "repository": {
+    "type": "git",
+    "url": "git://github.com/substack/node-concat-map.git"
+  },
+  "scripts": {
+    "test": "tape test/*.js"
+  },
+  "testling": {
+    "files": "test/*.js",
+    "browsers": {
+      "ie": [
+        6,
+        7,
+        8,
+        9
+      ],
+      "ff": [
+        3.5,
+        10,
+        15
+      ],
+      "chrome": [
+        10,
+        22
+      ],
+      "safari": [
+        5.1
+      ],
+      "opera": [
+        12
+      ]
+    }
+  },
+  "version": "0.0.1"
+}
\ No newline at end of file
diff --git a/tools/node_modules/glob/node_modules/concat-map/test/map.js b/tools/node_modules/glob/node_modules/concat-map/test/map.js
new file mode 100644
index 00000000..fdbd7022
--- /dev/null
+++ b/tools/node_modules/glob/node_modules/concat-map/test/map.js
@@ -0,0 +1,39 @@
+var concatMap = require('../');
+var test = require('tape');
+
+test('empty or not', function (t) {
+    var xs = [ 1, 2, 3, 4, 5, 6 ];
+    var ixes = [];
+    var ys = concatMap(xs, function (x, ix) {
+        ixes.push(ix);
+        return x % 2 ? [ x - 0.1, x, x + 0.1 ] : [];
+    });
+    t.same(ys, [ 0.9, 1, 1.1, 2.9, 3, 3.1, 4.9, 5, 5.1 ]);
+    t.same(ixes, [ 0, 1, 2, 3, 4, 5 ]);
+    t.end();
+});
+
+test('always something', function (t) {
+    var xs = [ 'a', 'b', 'c', 'd' ];
+    var ys = concatMap(xs, function (x) {
+        return x === 'b' ? [ 'B', 'B', 'B' ] : [ x ];
+    });
+    t.same(ys, [ 'a', 'B', 'B', 'B', 'c', 'd' ]);
+    t.end();
+});
+
+test('scalars', function (t) {
+    var xs = [ 'a', 'b', 'c', 'd' ];
+    var ys = concatMap(xs, function (x) {
+        return x === 'b' ? [ 'B', 'B', 'B' ] : x;
+    });
+    t.same(ys, [ 'a', 'B', 'B', 'B', 'c', 'd' ]);
+    t.end();
+});
+
+test('undefs', function (t) {
+    var xs = [ 'a', 'b', 'c', 'd' ];
+    var ys = concatMap(xs, function () {});
+    t.same(ys, [ undefined, undefined, undefined, undefined ]);
+    t.end();
+});
diff --git a/tools/node_modules/glob/node_modules/inflight/LICENSE b/tools/node_modules/glob/node_modules/inflight/LICENSE
new file mode 100644
index 00000000..05eeeb88
--- /dev/null
+++ b/tools/node_modules/glob/node_modules/inflight/LICENSE
@@ -0,0 +1,15 @@
+The ISC License
+
+Copyright (c) Isaac Z. Schlueter
+
+Permission to use, copy, modify, and/or distribute this software for any
+purpose with or without fee is hereby granted, provided that the above
+copyright notice and this permission notice appear in all copies.
+
+THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR
+IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
diff --git a/tools/node_modules/glob/node_modules/inflight/README.md b/tools/node_modules/glob/node_modules/inflight/README.md
new file mode 100644
index 00000000..6dc89291
--- /dev/null
+++ b/tools/node_modules/glob/node_modules/inflight/README.md
@@ -0,0 +1,37 @@
+# inflight
+
+Add callbacks to requests in flight to avoid async duplication
+
+## USAGE
+
+```javascript
+var inflight = require('inflight')
+
+// some request that does some stuff
+function req(key, callback) {
+  // key is any random string.  like a url or filename or whatever.
+  //
+  // will return either a falsey value, indicating that the
+  // request for this key is already in flight, or a new callback
+  // which when called will call all callbacks passed to inflightk
+  // with the same key
+  callback = inflight(key, callback)
+
+  // If we got a falsey value back, then there's already a req going
+  if (!callback) return
+
+  // this is where you'd fetch the url or whatever
+  // callback is also once()-ified, so it can safely be assigned
+  // to multiple events etc.  First call wins.
+  setTimeout(function() {
+    callback(null, key)
+  }, 100)
+}
+
+// only assigns a single setTimeout
+// when it dings, all cbs get called
+req('foo', cb1)
+req('foo', cb2)
+req('foo', cb3)
+req('foo', cb4)
+```
diff --git a/tools/node_modules/glob/node_modules/inflight/inflight.js b/tools/node_modules/glob/node_modules/inflight/inflight.js
new file mode 100644
index 00000000..48202b3c
--- /dev/null
+++ b/tools/node_modules/glob/node_modules/inflight/inflight.js
@@ -0,0 +1,54 @@
+var wrappy = require('wrappy')
+var reqs = Object.create(null)
+var once = require('once')
+
+module.exports = wrappy(inflight)
+
+function inflight (key, cb) {
+  if (reqs[key]) {
+    reqs[key].push(cb)
+    return null
+  } else {
+    reqs[key] = [cb]
+    return makeres(key)
+  }
+}
+
+function makeres (key) {
+  return once(function RES () {
+    var cbs = reqs[key]
+    var len = cbs.length
+    var args = slice(arguments)
+
+    // XXX It's somewhat ambiguous whether a new callback added in this
+    // pass should be queued for later execution if something in the
+    // list of callbacks throws, or if it should just be discarded.
+    // However, it's such an edge case that it hardly matters, and either
+    // choice is likely as surprising as the other.
+    // As it happens, we do go ahead and schedule it for later execution.
+    try {
+      for (var i = 0; i < len; i++) {
+        cbs[i].apply(null, args)
+      }
+    } finally {
+      if (cbs.length > len) {
+        // added more in the interim.
+        // de-zalgo, just in case, but don't call again.
+        cbs.splice(0, len)
+        process.nextTick(function () {
+          RES.apply(null, args)
+        })
+      } else {
+        delete reqs[key]
+      }
+    }
+  })
+}
+
+function slice (args) {
+  var length = args.length
+  var array = []
+
+  for (var i = 0; i < length; i++) array[i] = args[i]
+  return array
+}
diff --git a/tools/node_modules/glob/node_modules/inflight/package.json b/tools/node_modules/glob/node_modules/inflight/package.json
new file mode 100644
index 00000000..cc1247c7
--- /dev/null
+++ b/tools/node_modules/glob/node_modules/inflight/package.json
@@ -0,0 +1,59 @@
+{
+  "author": {
+    "name": "Isaac Z. Schlueter",
+    "email": "i@izs.me",
+    "url": "http://blog.izs.me/"
+  },
+  "bugs": {
+    "url": "https://github.com/isaacs/inflight/issues"
+  },
+  "dependencies": {
+    "once": "^1.3.0",
+    "wrappy": "1"
+  },
+  "description": "Add callbacks to requests in flight to avoid async duplication",
+  "devDependencies": {
+    "tap": "^7.1.2"
+  },
+  "directories": {},
+  "dist": {
+    "shasum": "49bd6331d7d02d0c09bc910a1075ba8165b56df9",
+    "tarball": "https://registry.npmjs.org/inflight/-/inflight-1.0.6.tgz"
+  },
+  "files": [
+    "inflight.js"
+  ],
+  "gitHead": "a547881738c8f57b27795e584071d67cf6ac1a57",
+  "homepage": "https://github.com/isaacs/inflight",
+  "license": "ISC",
+  "main": "inflight.js",
+  "maintainers": [
+    {
+      "name": "iarna",
+      "email": "me@re-becca.org"
+    },
+    {
+      "name": "isaacs",
+      "email": "i@izs.me"
+    },
+    {
+      "name": "othiym23",
+      "email": "ogd@aoaioxxysz.net"
+    },
+    {
+      "name": "zkat",
+      "email": "kat@sykosomatic.org"
+    }
+  ],
+  "name": "inflight",
+  "optionalDependencies": {},
+  "readme": "ERROR: No README data found!",
+  "repository": {
+    "type": "git",
+    "url": "git+https://github.com/npm/inflight.git"
+  },
+  "scripts": {
+    "test": "tap test.js --100"
+  },
+  "version": "1.0.6"
+}
\ No newline at end of file
diff --git a/tools/node_modules/glob/node_modules/inherits/LICENSE b/tools/node_modules/glob/node_modules/inherits/LICENSE
new file mode 100644
index 00000000..dea3013d
--- /dev/null
+++ b/tools/node_modules/glob/node_modules/inherits/LICENSE
@@ -0,0 +1,16 @@
+The ISC License
+
+Copyright (c) Isaac Z. Schlueter
+
+Permission to use, copy, modify, and/or distribute this software for any
+purpose with or without fee is hereby granted, provided that the above
+copyright notice and this permission notice appear in all copies.
+
+THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
+REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
+INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
+LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
+OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
+PERFORMANCE OF THIS SOFTWARE.
+
diff --git a/tools/node_modules/glob/node_modules/inherits/README.md b/tools/node_modules/glob/node_modules/inherits/README.md
new file mode 100644
index 00000000..b1c56658
--- /dev/null
+++ b/tools/node_modules/glob/node_modules/inherits/README.md
@@ -0,0 +1,42 @@
+Browser-friendly inheritance fully compatible with standard node.js
+[inherits](http://nodejs.org/api/util.html#util_util_inherits_constructor_superconstructor).
+
+This package exports standard `inherits` from node.js `util` module in
+node environment, but also provides alternative browser-friendly
+implementation through [browser
+field](https://gist.github.com/shtylman/4339901). Alternative
+implementation is a literal copy of standard one located in standalone
+module to avoid requiring of `util`. It also has a shim for old
+browsers with no `Object.create` support.
+
+While keeping you sure you are using standard `inherits`
+implementation in node.js environment, it allows bundlers such as
+[browserify](https://github.com/substack/node-browserify) to not
+include full `util` package to your client code if all you need is
+just `inherits` function. It worth, because browser shim for `util`
+package is large and `inherits` is often the single function you need
+from it.
+
+It's recommended to use this package instead of
+`require('util').inherits` for any code that has chances to be used
+not only in node.js but in browser too.
+
+## usage
+
+```js
+var inherits = require('inherits');
+// then use exactly as the standard one
+```
+
+## note on version ~1.0
+
+Version ~1.0 had completely different motivation and is not compatible
+neither with 2.0 nor with standard node.js `inherits`.
+
+If you are using version ~1.0 and planning to switch to ~2.0, be
+careful:
+
+* new version uses `super_` instead of `super` for referencing
+  superclass
+* new version overwrites current prototype while old one preserves any
+  existing fields on it
diff --git a/tools/node_modules/glob/node_modules/inherits/inherits.js b/tools/node_modules/glob/node_modules/inherits/inherits.js
new file mode 100644
index 00000000..3b94763a
--- /dev/null
+++ b/tools/node_modules/glob/node_modules/inherits/inherits.js
@@ -0,0 +1,7 @@
+try {
+  var util = require('util');
+  if (typeof util.inherits !== 'function') throw '';
+  module.exports = util.inherits;
+} catch (e) {
+  module.exports = require('./inherits_browser.js');
+}
diff --git a/tools/node_modules/glob/node_modules/inherits/inherits_browser.js b/tools/node_modules/glob/node_modules/inherits/inherits_browser.js
new file mode 100644
index 00000000..c1e78a75
--- /dev/null
+++ b/tools/node_modules/glob/node_modules/inherits/inherits_browser.js
@@ -0,0 +1,23 @@
+if (typeof Object.create === 'function') {
+  // implementation from standard node.js 'util' module
+  module.exports = function inherits(ctor, superCtor) {
+    ctor.super_ = superCtor
+    ctor.prototype = Object.create(superCtor.prototype, {
+      constructor: {
+        value: ctor,
+        enumerable: false,
+        writable: true,
+        configurable: true
+      }
+    });
+  };
+} else {
+  // old school shim for old browsers
+  module.exports = function inherits(ctor, superCtor) {
+    ctor.super_ = superCtor
+    var TempCtor = function () {}
+    TempCtor.prototype = superCtor.prototype
+    ctor.prototype = new TempCtor()
+    ctor.prototype.constructor = ctor
+  }
+}
diff --git a/tools/node_modules/glob/node_modules/inherits/package.json b/tools/node_modules/glob/node_modules/inherits/package.json
new file mode 100644
index 00000000..b9ac71ed
--- /dev/null
+++ b/tools/node_modules/glob/node_modules/inherits/package.json
@@ -0,0 +1,51 @@
+{
+  "browser": "./inherits_browser.js",
+  "bugs": {
+    "url": "https://github.com/isaacs/inherits/issues"
+  },
+  "dependencies": {},
+  "description": "Browser-friendly inheritance fully compatible with standard node.js inherits()",
+  "devDependencies": {
+    "tap": "^7.1.0"
+  },
+  "directories": {},
+  "dist": {
+    "shasum": "633c2c83e3da42a502f52466022480f4208261de",
+    "tarball": "https://registry.npmjs.org/inherits/-/inherits-2.0.3.tgz"
+  },
+  "files": [
+    "inherits.js",
+    "inherits_browser.js"
+  ],
+  "gitHead": "e05d0fb27c61a3ec687214f0476386b765364d5f",
+  "homepage": "https://github.com/isaacs/inherits#readme",
+  "keywords": [
+    "inheritance",
+    "class",
+    "klass",
+    "oop",
+    "object-oriented",
+    "inherits",
+    "browser",
+    "browserify"
+  ],
+  "license": "ISC",
+  "main": "./inherits.js",
+  "maintainers": [
+    {
+      "name": "isaacs",
+      "email": "i@izs.me"
+    }
+  ],
+  "name": "inherits",
+  "optionalDependencies": {},
+  "readme": "ERROR: No README data found!",
+  "repository": {
+    "type": "git",
+    "url": "git://github.com/isaacs/inherits.git"
+  },
+  "scripts": {
+    "test": "node test"
+  },
+  "version": "2.0.3"
+}
\ No newline at end of file
diff --git a/tools/node_modules/glob/node_modules/minimatch/LICENSE b/tools/node_modules/glob/node_modules/minimatch/LICENSE
new file mode 100644
index 00000000..19129e31
--- /dev/null
+++ b/tools/node_modules/glob/node_modules/minimatch/LICENSE
@@ -0,0 +1,15 @@
+The ISC License
+
+Copyright (c) Isaac Z. Schlueter and Contributors
+
+Permission to use, copy, modify, and/or distribute this software for any
+purpose with or without fee is hereby granted, provided that the above
+copyright notice and this permission notice appear in all copies.
+
+THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR
+IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
diff --git a/tools/node_modules/glob/node_modules/minimatch/README.md b/tools/node_modules/glob/node_modules/minimatch/README.md
new file mode 100644
index 00000000..d458bc2e
--- /dev/null
+++ b/tools/node_modules/glob/node_modules/minimatch/README.md
@@ -0,0 +1,216 @@
+# minimatch
+
+A minimal matching utility.
+
+[![Build Status](https://secure.travis-ci.org/isaacs/minimatch.png)](http://travis-ci.org/isaacs/minimatch)
+
+
+This is the matching library used internally by npm.
+
+It works by converting glob expressions into JavaScript `RegExp`
+objects.
+
+## Usage
+
+```javascript
+var minimatch = require("minimatch")
+
+minimatch("bar.foo", "*.foo") // true!
+minimatch("bar.foo", "*.bar") // false!
+minimatch("bar.foo", "*.+(bar|foo)", { debug: true }) // true, and noisy!
+```
+
+## Features
+
+Supports these glob features:
+
+* Brace Expansion
+* Extended glob matching
+* "Globstar" `**` matching
+
+See:
+
+* `man sh`
+* `man bash`
+* `man 3 fnmatch`
+* `man 5 gitignore`
+
+## Minimatch Class
+
+Create a minimatch object by instanting the `minimatch.Minimatch` class.
+
+```javascript
+var Minimatch = require("minimatch").Minimatch
+var mm = new Minimatch(pattern, options)
+```
+
+### Properties
+
+* `pattern` The original pattern the minimatch object represents.
+* `options` The options supplied to the constructor.
+* `set` A 2-dimensional array of regexp or string expressions.
+  Each row in the
+  array corresponds to a brace-expanded pattern.  Each item in the row
+  corresponds to a single path-part.  For example, the pattern
+  `{a,b/c}/d` would expand to a set of patterns like:
+
+        [ [ a, d ]
+        , [ b, c, d ] ]
+
+    If a portion of the pattern doesn't have any "magic" in it
+    (that is, it's something like `"foo"` rather than `fo*o?`), then it
+    will be left as a string rather than converted to a regular
+    expression.
+
+* `regexp` Created by the `makeRe` method.  A single regular expression
+  expressing the entire pattern.  This is useful in cases where you wish
+  to use the pattern somewhat like `fnmatch(3)` with `FNM_PATH` enabled.
+* `negate` True if the pattern is negated.
+* `comment` True if the pattern is a comment.
+* `empty` True if the pattern is `""`.
+
+### Methods
+
+* `makeRe` Generate the `regexp` member if necessary, and return it.
+  Will return `false` if the pattern is invalid.
+* `match(fname)` Return true if the filename matches the pattern, or
+  false otherwise.
+* `matchOne(fileArray, patternArray, partial)` Take a `/`-split
+  filename, and match it against a single row in the `regExpSet`.  This
+  method is mainly for internal use, but is exposed so that it can be
+  used by a glob-walker that needs to avoid excessive filesystem calls.
+
+All other methods are internal, and will be called as necessary.
+
+## Functions
+
+The top-level exported function has a `cache` property, which is an LRU
+cache set to store 100 items.  So, calling these methods repeatedly
+with the same pattern and options will use the same Minimatch object,
+saving the cost of parsing it multiple times.
+
+### minimatch(path, pattern, options)
+
+Main export.  Tests a path against the pattern using the options.
+
+```javascript
+var isJS = minimatch(file, "*.js", { matchBase: true })
+```
+
+### minimatch.filter(pattern, options)
+
+Returns a function that tests its
+supplied argument, suitable for use with `Array.filter`.  Example:
+
+```javascript
+var javascripts = fileList.filter(minimatch.filter("*.js", {matchBase: true}))
+```
+
+### minimatch.match(list, pattern, options)
+
+Match against the list of
+files, in the style of fnmatch or glob.  If nothing is matched, and
+options.nonull is set, then return a list containing the pattern itself.
+
+```javascript
+var javascripts = minimatch.match(fileList, "*.js", {matchBase: true}))
+```
+
+### minimatch.makeRe(pattern, options)
+
+Make a regular expression object from the pattern.
+
+## Options
+
+All options are `false` by default.
+
+### debug
+
+Dump a ton of stuff to stderr.
+
+### nobrace
+
+Do not expand `{a,b}` and `{1..3}` brace sets.
+
+### noglobstar
+
+Disable `**` matching against multiple folder names.
+
+### dot
+
+Allow patterns to match filenames starting with a period, even if
+the pattern does not explicitly have a period in that spot.
+
+Note that by default, `a/**/b` will **not** match `a/.d/b`, unless `dot`
+is set.
+
+### noext
+
+Disable "extglob" style patterns like `+(a|b)`.
+
+### nocase
+
+Perform a case-insensitive match.
+
+### nonull
+
+When a match is not found by `minimatch.match`, return a list containing
+the pattern itself if this option is set.  When not set, an empty list
+is returned if there are no matches.
+
+### matchBase
+
+If set, then patterns without slashes will be matched
+against the basename of the path if it contains slashes.  For example,
+`a?b` would match the path `/xyz/123/acb`, but not `/xyz/acb/123`.
+
+### nocomment
+
+Suppress the behavior of treating `#` at the start of a pattern as a
+comment.
+
+### nonegate
+
+Suppress the behavior of treating a leading `!` character as negation.
+
+### flipNegate
+
+Returns from negate expressions the same as if they were not negated.
+(Ie, true on a hit, false on a miss.)
+
+
+## Comparisons to other fnmatch/glob implementations
+
+While strict compliance with the existing standards is a worthwhile
+goal, some discrepancies exist between minimatch and other
+implementations, and are intentional.
+
+If the pattern starts with a `!` character, then it is negated.  Set the
+`nonegate` flag to suppress this behavior, and treat leading `!`
+characters normally.  This is perhaps relevant if you wish to start the
+pattern with a negative extglob pattern like `!(a|B)`.  Multiple `!`
+characters at the start of a pattern will negate the pattern multiple
+times.
+
+If a pattern starts with `#`, then it is treated as a comment, and
+will not match anything.  Use `\#` to match a literal `#` at the
+start of a line, or set the `nocomment` flag to suppress this behavior.
+
+The double-star character `**` is supported by default, unless the
+`noglobstar` flag is set.  This is supported in the manner of bsdglob
+and bash 4.1, where `**` only has special significance if it is the only
+thing in a path part.  That is, `a/**/b` will match `a/x/y/b`, but
+`a/**b` will not.
+
+If an escaped pattern has no matches, and the `nonull` flag is set,
+then minimatch.match returns the pattern as-provided, rather than
+interpreting the character escapes.  For example,
+`minimatch.match([], "\\*a\\?")` will return `"\\*a\\?"` rather than
+`"*a?"`.  This is akin to setting the `nullglob` option in bash, except
+that it does not resolve escaped pattern characters.
+
+If brace expansion is not disabled, then it is performed before any
+other interpretation of the glob pattern.  Thus, a pattern like
+`+(a|{b),c)}`, which would not be valid in bash or zsh, is expanded
+**first** into the set of `+(a|b)` and `+(a|c)`, and those patterns are
+checked for validity.  Since those two are valid, matching proceeds.
diff --git a/tools/node_modules/glob/node_modules/minimatch/browser.js b/tools/node_modules/glob/node_modules/minimatch/browser.js
new file mode 100644
index 00000000..7d051592
--- /dev/null
+++ b/tools/node_modules/glob/node_modules/minimatch/browser.js
@@ -0,0 +1,1159 @@
+(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.minimatch = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
+module.exports = minimatch
+minimatch.Minimatch = Minimatch
+
+var path = { sep: '/' }
+try {
+  path = require('path')
+} catch (er) {}
+
+var GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {}
+var expand = require('brace-expansion')
+
+// any single thing other than /
+// don't need to escape / when using new RegExp()
+var qmark = '[^/]'
+
+// * => any number of characters
+var star = qmark + '*?'
+
+// ** when dots are allowed.  Anything goes, except .. and .
+// not (^ or / followed by one or two dots followed by $ or /),
+// followed by anything, any number of times.
+var twoStarDot = '(?:(?!(?:\\\/|^)(?:\\.{1,2})($|\\\/)).)*?'
+
+// not a ^ or / followed by a dot,
+// followed by anything, any number of times.
+var twoStarNoDot = '(?:(?!(?:\\\/|^)\\.).)*?'
+
+// characters that need to be escaped in RegExp.
+var reSpecials = charSet('().*{}+?[]^$\\!')
+
+// "abc" -> { a:true, b:true, c:true }
+function charSet (s) {
+  return s.split('').reduce(function (set, c) {
+    set[c] = true
+    return set
+  }, {})
+}
+
+// normalizes slashes.
+var slashSplit = /\/+/
+
+minimatch.filter = filter
+function filter (pattern, options) {
+  options = options || {}
+  return function (p, i, list) {
+    return minimatch(p, pattern, options)
+  }
+}
+
+function ext (a, b) {
+  a = a || {}
+  b = b || {}
+  var t = {}
+  Object.keys(b).forEach(function (k) {
+    t[k] = b[k]
+  })
+  Object.keys(a).forEach(function (k) {
+    t[k] = a[k]
+  })
+  return t
+}
+
+minimatch.defaults = function (def) {
+  if (!def || !Object.keys(def).length) return minimatch
+
+  var orig = minimatch
+
+  var m = function minimatch (p, pattern, options) {
+    return orig.minimatch(p, pattern, ext(def, options))
+  }
+
+  m.Minimatch = function Minimatch (pattern, options) {
+    return new orig.Minimatch(pattern, ext(def, options))
+  }
+
+  return m
+}
+
+Minimatch.defaults = function (def) {
+  if (!def || !Object.keys(def).length) return Minimatch
+  return minimatch.defaults(def).Minimatch
+}
+
+function minimatch (p, pattern, options) {
+  if (typeof pattern !== 'string') {
+    throw new TypeError('glob pattern string required')
+  }
+
+  if (!options) options = {}
+
+  // shortcut: comments match nothing.
+  if (!options.nocomment && pattern.charAt(0) === '#') {
+    return false
+  }
+
+  // "" only matches ""
+  if (pattern.trim() === '') return p === ''
+
+  return new Minimatch(pattern, options).match(p)
+}
+
+function Minimatch (pattern, options) {
+  if (!(this instanceof Minimatch)) {
+    return new Minimatch(pattern, options)
+  }
+
+  if (typeof pattern !== 'string') {
+    throw new TypeError('glob pattern string required')
+  }
+
+  if (!options) options = {}
+  pattern = pattern.trim()
+
+  // windows support: need to use /, not \
+  if (path.sep !== '/') {
+    pattern = pattern.split(path.sep).join('/')
+  }
+
+  this.options = options
+  this.set = []
+  this.pattern = pattern
+  this.regexp = null
+  this.negate = false
+  this.comment = false
+  this.empty = false
+
+  // make the set of regexps etc.
+  this.make()
+}
+
+Minimatch.prototype.debug = function () {}
+
+Minimatch.prototype.make = make
+function make () {
+  // don't do it more than once.
+  if (this._made) return
+
+  var pattern = this.pattern
+  var options = this.options
+
+  // empty patterns and comments match nothing.
+  if (!options.nocomment && pattern.charAt(0) === '#') {
+    this.comment = true
+    return
+  }
+  if (!pattern) {
+    this.empty = true
+    return
+  }
+
+  // step 1: figure out negation, etc.
+  this.parseNegate()
+
+  // step 2: expand braces
+  var set = this.globSet = this.braceExpand()
+
+  if (options.debug) this.debug = console.error
+
+  this.debug(this.pattern, set)
+
+  // step 3: now we have a set, so turn each one into a series of path-portion
+  // matching patterns.
+  // These will be regexps, except in the case of "**", which is
+  // set to the GLOBSTAR object for globstar behavior,
+  // and will not contain any / characters
+  set = this.globParts = set.map(function (s) {
+    return s.split(slashSplit)
+  })
+
+  this.debug(this.pattern, set)
+
+  // glob --> regexps
+  set = set.map(function (s, si, set) {
+    return s.map(this.parse, this)
+  }, this)
+
+  this.debug(this.pattern, set)
+
+  // filter out everything that didn't compile properly.
+  set = set.filter(function (s) {
+    return s.indexOf(false) === -1
+  })
+
+  this.debug(this.pattern, set)
+
+  this.set = set
+}
+
+Minimatch.prototype.parseNegate = parseNegate
+function parseNegate () {
+  var pattern = this.pattern
+  var negate = false
+  var options = this.options
+  var negateOffset = 0
+
+  if (options.nonegate) return
+
+  for (var i = 0, l = pattern.length
+    ; i < l && pattern.charAt(i) === '!'
+    ; i++) {
+    negate = !negate
+    negateOffset++
+  }
+
+  if (negateOffset) this.pattern = pattern.substr(negateOffset)
+  this.negate = negate
+}
+
+// Brace expansion:
+// a{b,c}d -> abd acd
+// a{b,}c -> abc ac
+// a{0..3}d -> a0d a1d a2d a3d
+// a{b,c{d,e}f}g -> abg acdfg acefg
+// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg
+//
+// Invalid sets are not expanded.
+// a{2..}b -> a{2..}b
+// a{b}c -> a{b}c
+minimatch.braceExpand = function (pattern, options) {
+  return braceExpand(pattern, options)
+}
+
+Minimatch.prototype.braceExpand = braceExpand
+
+function braceExpand (pattern, options) {
+  if (!options) {
+    if (this instanceof Minimatch) {
+      options = this.options
+    } else {
+      options = {}
+    }
+  }
+
+  pattern = typeof pattern === 'undefined'
+    ? this.pattern : pattern
+
+  if (typeof pattern === 'undefined') {
+    throw new Error('undefined pattern')
+  }
+
+  if (options.nobrace ||
+    !pattern.match(/\{.*\}/)) {
+    // shortcut. no need to expand.
+    return [pattern]
+  }
+
+  return expand(pattern)
+}
+
+// parse a component of the expanded set.
+// At this point, no pattern may contain "/" in it
+// so we're going to return a 2d array, where each entry is the full
+// pattern, split on '/', and then turned into a regular expression.
+// A regexp is made at the end which joins each array with an
+// escaped /, and another full one which joins each regexp with |.
+//
+// Following the lead of Bash 4.1, note that "**" only has special meaning
+// when it is the *only* thing in a path portion.  Otherwise, any series
+// of * is equivalent to a single *.  Globstar behavior is enabled by
+// default, and can be disabled by setting options.noglobstar.
+Minimatch.prototype.parse = parse
+var SUBPARSE = {}
+function parse (pattern, isSub) {
+  var options = this.options
+
+  // shortcuts
+  if (!options.noglobstar && pattern === '**') return GLOBSTAR
+  if (pattern === '') return ''
+
+  var re = ''
+  var hasMagic = !!options.nocase
+  var escaping = false
+  // ? => one single character
+  var patternListStack = []
+  var negativeLists = []
+  var plType
+  var stateChar
+  var inClass = false
+  var reClassStart = -1
+  var classStart = -1
+  // . and .. never match anything that doesn't start with .,
+  // even when options.dot is set.
+  var patternStart = pattern.charAt(0) === '.' ? '' // anything
+  // not (start or / followed by . or .. followed by / or end)
+  : options.dot ? '(?!(?:^|\\\/)\\.{1,2}(?:$|\\\/))'
+  : '(?!\\.)'
+  var self = this
+
+  function clearStateChar () {
+    if (stateChar) {
+      // we had some state-tracking character
+      // that wasn't consumed by this pass.
+      switch (stateChar) {
+        case '*':
+          re += star
+          hasMagic = true
+        break
+        case '?':
+          re += qmark
+          hasMagic = true
+        break
+        default:
+          re += '\\' + stateChar
+        break
+      }
+      self.debug('clearStateChar %j %j', stateChar, re)
+      stateChar = false
+    }
+  }
+
+  for (var i = 0, len = pattern.length, c
+    ; (i < len) && (c = pattern.charAt(i))
+    ; i++) {
+    this.debug('%s\t%s %s %j', pattern, i, re, c)
+
+    // skip over any that are escaped.
+    if (escaping && reSpecials[c]) {
+      re += '\\' + c
+      escaping = false
+      continue
+    }
+
+    switch (c) {
+      case '/':
+        // completely not allowed, even escaped.
+        // Should already be path-split by now.
+        return false
+
+      case '\\':
+        clearStateChar()
+        escaping = true
+      continue
+
+      // the various stateChar values
+      // for the "extglob" stuff.
+      case '?':
+      case '*':
+      case '+':
+      case '@':
+      case '!':
+        this.debug('%s\t%s %s %j <-- stateChar', pattern, i, re, c)
+
+        // all of those are literals inside a class, except that
+        // the glob [!a] means [^a] in regexp
+        if (inClass) {
+          this.debug('  in class')
+          if (c === '!' && i === classStart + 1) c = '^'
+          re += c
+          continue
+        }
+
+        // if we already have a stateChar, then it means
+        // that there was something like ** or +? in there.
+        // Handle the stateChar, then proceed with this one.
+        self.debug('call clearStateChar %j', stateChar)
+        clearStateChar()
+        stateChar = c
+        // if extglob is disabled, then +(asdf|foo) isn't a thing.
+        // just clear the statechar *now*, rather than even diving into
+        // the patternList stuff.
+        if (options.noext) clearStateChar()
+      continue
+
+      case '(':
+        if (inClass) {
+          re += '('
+          continue
+        }
+
+        if (!stateChar) {
+          re += '\\('
+          continue
+        }
+
+        plType = stateChar
+        patternListStack.push({
+          type: plType,
+          start: i - 1,
+          reStart: re.length
+        })
+        // negation is (?:(?!js)[^/]*)
+        re += stateChar === '!' ? '(?:(?!(?:' : '(?:'
+        this.debug('plType %j %j', stateChar, re)
+        stateChar = false
+      continue
+
+      case ')':
+        if (inClass || !patternListStack.length) {
+          re += '\\)'
+          continue
+        }
+
+        clearStateChar()
+        hasMagic = true
+        re += ')'
+        var pl = patternListStack.pop()
+        plType = pl.type
+        // negation is (?:(?!js)[^/]*)
+        // The others are (?:<pattern>)<type>
+        switch (plType) {
+          case '!':
+            negativeLists.push(pl)
+            re += ')[^/]*?)'
+            pl.reEnd = re.length
+            break
+          case '?':
+          case '+':
+          case '*':
+            re += plType
+            break
+          case '@': break // the default anyway
+        }
+      continue
+
+      case '|':
+        if (inClass || !patternListStack.length || escaping) {
+          re += '\\|'
+          escaping = false
+          continue
+        }
+
+        clearStateChar()
+        re += '|'
+      continue
+
+      // these are mostly the same in regexp and glob
+      case '[':
+        // swallow any state-tracking char before the [
+        clearStateChar()
+
+        if (inClass) {
+          re += '\\' + c
+          continue
+        }
+
+        inClass = true
+        classStart = i
+        reClassStart = re.length
+        re += c
+      continue
+
+      case ']':
+        //  a right bracket shall lose its special
+        //  meaning and represent itself in
+        //  a bracket expression if it occurs
+        //  first in the list.  -- POSIX.2 2.8.3.2
+        if (i === classStart + 1 || !inClass) {
+          re += '\\' + c
+          escaping = false
+          continue
+        }
+
+        // handle the case where we left a class open.
+        // "[z-a]" is valid, equivalent to "\[z-a\]"
+        if (inClass) {
+          // split where the last [ was, make sure we don't have
+          // an invalid re. if so, re-walk the contents of the
+          // would-be class to re-translate any characters that
+          // were passed through as-is
+          // TODO: It would probably be faster to determine this
+          // without a try/catch and a new RegExp, but it's tricky
+          // to do safely.  For now, this is safe and works.
+          var cs = pattern.substring(classStart + 1, i)
+          try {
+            RegExp('[' + cs + ']')
+          } catch (er) {
+            // not a valid class!
+            var sp = this.parse(cs, SUBPARSE)
+            re = re.substr(0, reClassStart) + '\\[' + sp[0] + '\\]'
+            hasMagic = hasMagic || sp[1]
+            inClass = false
+            continue
+          }
+        }
+
+        // finish up the class.
+        hasMagic = true
+        inClass = false
+        re += c
+      continue
+
+      default:
+        // swallow any state char that wasn't consumed
+        clearStateChar()
+
+        if (escaping) {
+          // no need
+          escaping = false
+        } else if (reSpecials[c]
+          && !(c === '^' && inClass)) {
+          re += '\\'
+        }
+
+        re += c
+
+    } // switch
+  } // for
+
+  // handle the case where we left a class open.
+  // "[abc" is valid, equivalent to "\[abc"
+  if (inClass) {
+    // split where the last [ was, and escape it
+    // this is a huge pita.  We now have to re-walk
+    // the contents of the would-be class to re-translate
+    // any characters that were passed through as-is
+    cs = pattern.substr(classStart + 1)
+    sp = this.parse(cs, SUBPARSE)
+    re = re.substr(0, reClassStart) + '\\[' + sp[0]
+    hasMagic = hasMagic || sp[1]
+  }
+
+  // handle the case where we had a +( thing at the *end*
+  // of the pattern.
+  // each pattern list stack adds 3 chars, and we need to go through
+  // and escape any | chars that were passed through as-is for the regexp.
+  // Go through and escape them, taking care not to double-escape any
+  // | chars that were already escaped.
+  for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
+    var tail = re.slice(pl.reStart + 3)
+    // maybe some even number of \, then maybe 1 \, followed by a |
+    tail = tail.replace(/((?:\\{2})*)(\\?)\|/g, function (_, $1, $2) {
+      if (!$2) {
+        // the | isn't already escaped, so escape it.
+        $2 = '\\'
+      }
+
+      // need to escape all those slashes *again*, without escaping the
+      // one that we need for escaping the | character.  As it works out,
+      // escaping an even number of slashes can be done by simply repeating
+      // it exactly after itself.  That's why this trick works.
+      //
+      // I am sorry that you have to see this.
+      return $1 + $1 + $2 + '|'
+    })
+
+    this.debug('tail=%j\n   %s', tail, tail)
+    var t = pl.type === '*' ? star
+      : pl.type === '?' ? qmark
+      : '\\' + pl.type
+
+    hasMagic = true
+    re = re.slice(0, pl.reStart) + t + '\\(' + tail
+  }
+
+  // handle trailing things that only matter at the very end.
+  clearStateChar()
+  if (escaping) {
+    // trailing \\
+    re += '\\\\'
+  }
+
+  // only need to apply the nodot start if the re starts with
+  // something that could conceivably capture a dot
+  var addPatternStart = false
+  switch (re.charAt(0)) {
+    case '.':
+    case '[':
+    case '(': addPatternStart = true
+  }
+
+  // Hack to work around lack of negative lookbehind in JS
+  // A pattern like: *.!(x).!(y|z) needs to ensure that a name
+  // like 'a.xyz.yz' doesn't match.  So, the first negative
+  // lookahead, has to look ALL the way ahead, to the end of
+  // the pattern.
+  for (var n = negativeLists.length - 1; n > -1; n--) {
+    var nl = negativeLists[n]
+
+    var nlBefore = re.slice(0, nl.reStart)
+    var nlFirst = re.slice(nl.reStart, nl.reEnd - 8)
+    var nlLast = re.slice(nl.reEnd - 8, nl.reEnd)
+    var nlAfter = re.slice(nl.reEnd)
+
+    nlLast += nlAfter
+
+    // Handle nested stuff like *(*.js|!(*.json)), where open parens
+    // mean that we should *not* include the ) in the bit that is considered
+    // "after" the negated section.
+    var openParensBefore = nlBefore.split('(').length - 1
+    var cleanAfter = nlAfter
+    for (i = 0; i < openParensBefore; i++) {
+      cleanAfter = cleanAfter.replace(/\)[+*?]?/, '')
+    }
+    nlAfter = cleanAfter
+
+    var dollar = ''
+    if (nlAfter === '' && isSub !== SUBPARSE) {
+      dollar = '$'
+    }
+    var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast
+    re = newRe
+  }
+
+  // if the re is not "" at this point, then we need to make sure
+  // it doesn't match against an empty path part.
+  // Otherwise a/* will match a/, which it should not.
+  if (re !== '' && hasMagic) {
+    re = '(?=.)' + re
+  }
+
+  if (addPatternStart) {
+    re = patternStart + re
+  }
+
+  // parsing just a piece of a larger pattern.
+  if (isSub === SUBPARSE) {
+    return [re, hasMagic]
+  }
+
+  // skip the regexp for non-magical patterns
+  // unescape anything in it, though, so that it'll be
+  // an exact match against a file etc.
+  if (!hasMagic) {
+    return globUnescape(pattern)
+  }
+
+  var flags = options.nocase ? 'i' : ''
+  var regExp = new RegExp('^' + re + '$', flags)
+
+  regExp._glob = pattern
+  regExp._src = re
+
+  return regExp
+}
+
+minimatch.makeRe = function (pattern, options) {
+  return new Minimatch(pattern, options || {}).makeRe()
+}
+
+Minimatch.prototype.makeRe = makeRe
+function makeRe () {
+  if (this.regexp || this.regexp === false) return this.regexp
+
+  // at this point, this.set is a 2d array of partial
+  // pattern strings, or "**".
+  //
+  // It's better to use .match().  This function shouldn't
+  // be used, really, but it's pretty convenient sometimes,
+  // when you just want to work with a regex.
+  var set = this.set
+
+  if (!set.length) {
+    this.regexp = false
+    return this.regexp
+  }
+  var options = this.options
+
+  var twoStar = options.noglobstar ? star
+    : options.dot ? twoStarDot
+    : twoStarNoDot
+  var flags = options.nocase ? 'i' : ''
+
+  var re = set.map(function (pattern) {
+    return pattern.map(function (p) {
+      return (p === GLOBSTAR) ? twoStar
+      : (typeof p === 'string') ? regExpEscape(p)
+      : p._src
+    }).join('\\\/')
+  }).join('|')
+
+  // must match entire pattern
+  // ending in a * or ** will make it less strict.
+  re = '^(?:' + re + ')$'
+
+  // can match anything, as long as it's not this.
+  if (this.negate) re = '^(?!' + re + ').*$'
+
+  try {
+    this.regexp = new RegExp(re, flags)
+  } catch (ex) {
+    this.regexp = false
+  }
+  return this.regexp
+}
+
+minimatch.match = function (list, pattern, options) {
+  options = options || {}
+  var mm = new Minimatch(pattern, options)
+  list = list.filter(function (f) {
+    return mm.match(f)
+  })
+  if (mm.options.nonull && !list.length) {
+    list.push(pattern)
+  }
+  return list
+}
+
+Minimatch.prototype.match = match
+function match (f, partial) {
+  this.debug('match', f, this.pattern)
+  // short-circuit in the case of busted things.
+  // comments, etc.
+  if (this.comment) return false
+  if (this.empty) return f === ''
+
+  if (f === '/' && partial) return true
+
+  var options = this.options
+
+  // windows: need to use /, not \
+  if (path.sep !== '/') {
+    f = f.split(path.sep).join('/')
+  }
+
+  // treat the test path as a set of pathparts.
+  f = f.split(slashSplit)
+  this.debug(this.pattern, 'split', f)
+
+  // just ONE of the pattern sets in this.set needs to match
+  // in order for it to be valid.  If negating, then just one
+  // match means that we have failed.
+  // Either way, return on the first hit.
+
+  var set = this.set
+  this.debug(this.pattern, 'set', set)
+
+  // Find the basename of the path by looking for the last non-empty segment
+  var filename
+  var i
+  for (i = f.length - 1; i >= 0; i--) {
+    filename = f[i]
+    if (filename) break
+  }
+
+  for (i = 0; i < set.length; i++) {
+    var pattern = set[i]
+    var file = f
+    if (options.matchBase && pattern.length === 1) {
+      file = [filename]
+    }
+    var hit = this.matchOne(file, pattern, partial)
+    if (hit) {
+      if (options.flipNegate) return true
+      return !this.negate
+    }
+  }
+
+  // didn't get any hits.  this is success if it's a negative
+  // pattern, failure otherwise.
+  if (options.flipNegate) return false
+  return this.negate
+}
+
+// set partial to true to test if, for example,
+// "/a/b" matches the start of "/*/b/*/d"
+// Partial means, if you run out of file before you run
+// out of pattern, then that's fine, as long as all
+// the parts match.
+Minimatch.prototype.matchOne = function (file, pattern, partial) {
+  var options = this.options
+
+  this.debug('matchOne',
+    { 'this': this, file: file, pattern: pattern })
+
+  this.debug('matchOne', file.length, pattern.length)
+
+  for (var fi = 0,
+      pi = 0,
+      fl = file.length,
+      pl = pattern.length
+      ; (fi < fl) && (pi < pl)
+      ; fi++, pi++) {
+    this.debug('matchOne loop')
+    var p = pattern[pi]
+    var f = file[fi]
+
+    this.debug(pattern, p, f)
+
+    // should be impossible.
+    // some invalid regexp stuff in the set.
+    if (p === false) return false
+
+    if (p === GLOBSTAR) {
+      this.debug('GLOBSTAR', [pattern, p, f])
+
+      // "**"
+      // a/**/b/**/c would match the following:
+      // a/b/x/y/z/c
+      // a/x/y/z/b/c
+      // a/b/x/b/x/c
+      // a/b/c
+      // To do this, take the rest of the pattern after
+      // the **, and see if it would match the file remainder.
+      // If so, return success.
+      // If not, the ** "swallows" a segment, and try again.
+      // This is recursively awful.
+      //
+      // a/**/b/**/c matching a/b/x/y/z/c
+      // - a matches a
+      // - doublestar
+      //   - matchOne(b/x/y/z/c, b/**/c)
+      //     - b matches b
+      //     - doublestar
+      //       - matchOne(x/y/z/c, c) -> no
+      //       - matchOne(y/z/c, c) -> no
+      //       - matchOne(z/c, c) -> no
+      //       - matchOne(c, c) yes, hit
+      var fr = fi
+      var pr = pi + 1
+      if (pr === pl) {
+        this.debug('** at the end')
+        // a ** at the end will just swallow the rest.
+        // We have found a match.
+        // however, it will not swallow /.x, unless
+        // options.dot is set.
+        // . and .. are *never* matched by **, for explosively
+        // exponential reasons.
+        for (; fi < fl; fi++) {
+          if (file[fi] === '.' || file[fi] === '..' ||
+            (!options.dot && file[fi].charAt(0) === '.')) return false
+        }
+        return true
+      }
+
+      // ok, let's see if we can swallow whatever we can.
+      while (fr < fl) {
+        var swallowee = file[fr]
+
+        this.debug('\nglobstar while', file, fr, pattern, pr, swallowee)
+
+        // XXX remove this slice.  Just pass the start index.
+        if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
+          this.debug('globstar found match!', fr, fl, swallowee)
+          // found a match.
+          return true
+        } else {
+          // can't swallow "." or ".." ever.
+          // can only swallow ".foo" when explicitly asked.
+          if (swallowee === '.' || swallowee === '..' ||
+            (!options.dot && swallowee.charAt(0) === '.')) {
+            this.debug('dot detected!', file, fr, pattern, pr)
+            break
+          }
+
+          // ** swallows a segment, and continue.
+          this.debug('globstar swallow a segment, and continue')
+          fr++
+        }
+      }
+
+      // no match was found.
+      // However, in partial mode, we can't say this is necessarily over.
+      // If there's more *pattern* left, then
+      if (partial) {
+        // ran out of file
+        this.debug('\n>>> no match, partial?', file, fr, pattern, pr)
+        if (fr === fl) return true
+      }
+      return false
+    }
+
+    // something other than **
+    // non-magic patterns just have to match exactly
+    // patterns with magic have been turned into regexps.
+    var hit
+    if (typeof p === 'string') {
+      if (options.nocase) {
+        hit = f.toLowerCase() === p.toLowerCase()
+      } else {
+        hit = f === p
+      }
+      this.debug('string match', p, f, hit)
+    } else {
+      hit = f.match(p)
+      this.debug('pattern match', p, f, hit)
+    }
+
+    if (!hit) return false
+  }
+
+  // Note: ending in / means that we'll get a final ""
+  // at the end of the pattern.  This can only match a
+  // corresponding "" at the end of the file.
+  // If the file ends in /, then it can only match a
+  // a pattern that ends in /, unless the pattern just
+  // doesn't have any more for it. But, a/b/ should *not*
+  // match "a/b/*", even though "" matches against the
+  // [^/]*? pattern, except in partial mode, where it might
+  // simply not be reached yet.
+  // However, a/b/ should still satisfy a/*
+
+  // now either we fell off the end of the pattern, or we're done.
+  if (fi === fl && pi === pl) {
+    // ran out of pattern and filename at the same time.
+    // an exact hit!
+    return true
+  } else if (fi === fl) {
+    // ran out of file, but still had pattern left.
+    // this is ok if we're doing the match as part of
+    // a glob fs traversal.
+    return partial
+  } else if (pi === pl) {
+    // ran out of pattern, still have file left.
+    // this is only acceptable if we're on the very last
+    // empty segment of a file with a trailing slash.
+    // a/* should match a/b/
+    var emptyFileEnd = (fi === fl - 1) && (file[fi] === '')
+    return emptyFileEnd
+  }
+
+  // should be unreachable.
+  throw new Error('wtf?')
+}
+
+// replace stuff like \* with *
+function globUnescape (s) {
+  return s.replace(/\\(.)/g, '$1')
+}
+
+function regExpEscape (s) {
+  return s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&')
+}
+
+},{"brace-expansion":2,"path":undefined}],2:[function(require,module,exports){
+var concatMap = require('concat-map');
+var balanced = require('balanced-match');
+
+module.exports = expandTop;
+
+var escSlash = '\0SLASH'+Math.random()+'\0';
+var escOpen = '\0OPEN'+Math.random()+'\0';
+var escClose = '\0CLOSE'+Math.random()+'\0';
+var escComma = '\0COMMA'+Math.random()+'\0';
+var escPeriod = '\0PERIOD'+Math.random()+'\0';
+
+function numeric(str) {
+  return parseInt(str, 10) == str
+    ? parseInt(str, 10)
+    : str.charCodeAt(0);
+}
+
+function escapeBraces(str) {
+  return str.split('\\\\').join(escSlash)
+            .split('\\{').join(escOpen)
+            .split('\\}').join(escClose)
+            .split('\\,').join(escComma)
+            .split('\\.').join(escPeriod);
+}
+
+function unescapeBraces(str) {
+  return str.split(escSlash).join('\\')
+            .split(escOpen).join('{')
+            .split(escClose).join('}')
+            .split(escComma).join(',')
+            .split(escPeriod).join('.');
+}
+
+
+// Basically just str.split(","), but handling cases
+// where we have nested braced sections, which should be
+// treated as individual members, like {a,{b,c},d}
+function parseCommaParts(str) {
+  if (!str)
+    return [''];
+
+  var parts = [];
+  var m = balanced('{', '}', str);
+
+  if (!m)
+    return str.split(',');
+
+  var pre = m.pre;
+  var body = m.body;
+  var post = m.post;
+  var p = pre.split(',');
+
+  p[p.length-1] += '{' + body + '}';
+  var postParts = parseCommaParts(post);
+  if (post.length) {
+    p[p.length-1] += postParts.shift();
+    p.push.apply(p, postParts);
+  }
+
+  parts.push.apply(parts, p);
+
+  return parts;
+}
+
+function expandTop(str) {
+  if (!str)
+    return [];
+
+  var expansions = expand(escapeBraces(str));
+  return expansions.filter(identity).map(unescapeBraces);
+}
+
+function identity(e) {
+  return e;
+}
+
+function embrace(str) {
+  return '{' + str + '}';
+}
+function isPadded(el) {
+  return /^-?0\d/.test(el);
+}
+
+function lte(i, y) {
+  return i <= y;
+}
+function gte(i, y) {
+  return i >= y;
+}
+
+function expand(str) {
+  var expansions = [];
+
+  var m = balanced('{', '}', str);
+  if (!m || /\$$/.test(m.pre)) return [str];
+
+  var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
+  var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
+  var isSequence = isNumericSequence || isAlphaSequence;
+  var isOptions = /^(.*,)+(.+)?$/.test(m.body);
+  if (!isSequence && !isOptions) {
+    // {a},b}
+    if (m.post.match(/,.*}/)) {
+      str = m.pre + '{' + m.body + escClose + m.post;
+      return expand(str);
+    }
+    return [str];
+  }
+
+  var n;
+  if (isSequence) {
+    n = m.body.split(/\.\./);
+  } else {
+    n = parseCommaParts(m.body);
+    if (n.length === 1) {
+      // x{{a,b}}y ==> x{a}y x{b}y
+      n = expand(n[0]).map(embrace);
+      if (n.length === 1) {
+        var post = m.post.length
+          ? expand(m.post)
+          : [''];
+        return post.map(function(p) {
+          return m.pre + n[0] + p;
+        });
+      }
+    }
+  }
+
+  // at this point, n is the parts, and we know it's not a comma set
+  // with a single entry.
+
+  // no need to expand pre, since it is guaranteed to be free of brace-sets
+  var pre = m.pre;
+  var post = m.post.length
+    ? expand(m.post)
+    : [''];
+
+  var N;
+
+  if (isSequence) {
+    var x = numeric(n[0]);
+    var y = numeric(n[1]);
+    var width = Math.max(n[0].length, n[1].length)
+    var incr = n.length == 3
+      ? Math.abs(numeric(n[2]))
+      : 1;
+    var test = lte;
+    var reverse = y < x;
+    if (reverse) {
+      incr *= -1;
+      test = gte;
+    }
+    var pad = n.some(isPadded);
+
+    N = [];
+
+    for (var i = x; test(i, y); i += incr) {
+      var c;
+      if (isAlphaSequence) {
+        c = String.fromCharCode(i);
+        if (c === '\\')
+          c = '';
+      } else {
+        c = String(i);
+        if (pad) {
+          var need = width - c.length;
+          if (need > 0) {
+            var z = new Array(need + 1).join('0');
+            if (i < 0)
+              c = '-' + z + c.slice(1);
+            else
+              c = z + c;
+          }
+        }
+      }
+      N.push(c);
+    }
+  } else {
+    N = concatMap(n, function(el) { return expand(el) });
+  }
+
+  for (var j = 0; j < N.length; j++) {
+    for (var k = 0; k < post.length; k++) {
+      expansions.push([pre, N[j], post[k]].join(''))
+    }
+  }
+
+  return expansions;
+}
+
+
+},{"balanced-match":3,"concat-map":4}],3:[function(require,module,exports){
+module.exports = balanced;
+function balanced(a, b, str) {
+  var bal = 0;
+  var m = {};
+  var ended = false;
+
+  for (var i = 0; i < str.length; i++) {
+    if (a == str.substr(i, a.length)) {
+      if (!('start' in m)) m.start = i;
+      bal++;
+    }
+    else if (b == str.substr(i, b.length) && 'start' in m) {
+      ended = true;
+      bal--;
+      if (!bal) {
+        m.end = i;
+        m.pre = str.substr(0, m.start);
+        m.body = (m.end - m.start > 1)
+          ? str.substring(m.start + a.length, m.end)
+          : '';
+        m.post = str.slice(m.end + b.length);
+        return m;
+      }
+    }
+  }
+
+  // if we opened more than we closed, find the one we closed
+  if (bal && ended) {
+    var start = m.start + a.length;
+    m = balanced(a, b, str.substr(start));
+    if (m) {
+      m.start += start;
+      m.end += start;
+      m.pre = str.slice(0, start) + m.pre;
+    }
+    return m;
+  }
+}
+
+},{}],4:[function(require,module,exports){
+module.exports = function (xs, fn) {
+    var res = [];
+    for (var i = 0; i < xs.length; i++) {
+        var x = fn(xs[i], i);
+        if (Array.isArray(x)) res.push.apply(res, x);
+        else res.push(x);
+    }
+    return res;
+};
+
+},{}]},{},[1])(1)
+});
\ No newline at end of file
diff --git a/tools/node_modules/glob/node_modules/minimatch/minimatch.js b/tools/node_modules/glob/node_modules/minimatch/minimatch.js
new file mode 100644
index 00000000..ec4c05c5
--- /dev/null
+++ b/tools/node_modules/glob/node_modules/minimatch/minimatch.js
@@ -0,0 +1,912 @@
+module.exports = minimatch
+minimatch.Minimatch = Minimatch
+
+var path = { sep: '/' }
+try {
+  path = require('path')
+} catch (er) {}
+
+var GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {}
+var expand = require('brace-expansion')
+
+// any single thing other than /
+// don't need to escape / when using new RegExp()
+var qmark = '[^/]'
+
+// * => any number of characters
+var star = qmark + '*?'
+
+// ** when dots are allowed.  Anything goes, except .. and .
+// not (^ or / followed by one or two dots followed by $ or /),
+// followed by anything, any number of times.
+var twoStarDot = '(?:(?!(?:\\\/|^)(?:\\.{1,2})($|\\\/)).)*?'
+
+// not a ^ or / followed by a dot,
+// followed by anything, any number of times.
+var twoStarNoDot = '(?:(?!(?:\\\/|^)\\.).)*?'
+
+// characters that need to be escaped in RegExp.
+var reSpecials = charSet('().*{}+?[]^$\\!')
+
+// "abc" -> { a:true, b:true, c:true }
+function charSet (s) {
+  return s.split('').reduce(function (set, c) {
+    set[c] = true
+    return set
+  }, {})
+}
+
+// normalizes slashes.
+var slashSplit = /\/+/
+
+minimatch.filter = filter
+function filter (pattern, options) {
+  options = options || {}
+  return function (p, i, list) {
+    return minimatch(p, pattern, options)
+  }
+}
+
+function ext (a, b) {
+  a = a || {}
+  b = b || {}
+  var t = {}
+  Object.keys(b).forEach(function (k) {
+    t[k] = b[k]
+  })
+  Object.keys(a).forEach(function (k) {
+    t[k] = a[k]
+  })
+  return t
+}
+
+minimatch.defaults = function (def) {
+  if (!def || !Object.keys(def).length) return minimatch
+
+  var orig = minimatch
+
+  var m = function minimatch (p, pattern, options) {
+    return orig.minimatch(p, pattern, ext(def, options))
+  }
+
+  m.Minimatch = function Minimatch (pattern, options) {
+    return new orig.Minimatch(pattern, ext(def, options))
+  }
+
+  return m
+}
+
+Minimatch.defaults = function (def) {
+  if (!def || !Object.keys(def).length) return Minimatch
+  return minimatch.defaults(def).Minimatch
+}
+
+function minimatch (p, pattern, options) {
+  if (typeof pattern !== 'string') {
+    throw new TypeError('glob pattern string required')
+  }
+
+  if (!options) options = {}
+
+  // shortcut: comments match nothing.
+  if (!options.nocomment && pattern.charAt(0) === '#') {
+    return false
+  }
+
+  // "" only matches ""
+  if (pattern.trim() === '') return p === ''
+
+  return new Minimatch(pattern, options).match(p)
+}
+
+function Minimatch (pattern, options) {
+  if (!(this instanceof Minimatch)) {
+    return new Minimatch(pattern, options)
+  }
+
+  if (typeof pattern !== 'string') {
+    throw new TypeError('glob pattern string required')
+  }
+
+  if (!options) options = {}
+  pattern = pattern.trim()
+
+  // windows support: need to use /, not \
+  if (path.sep !== '/') {
+    pattern = pattern.split(path.sep).join('/')
+  }
+
+  this.options = options
+  this.set = []
+  this.pattern = pattern
+  this.regexp = null
+  this.negate = false
+  this.comment = false
+  this.empty = false
+
+  // make the set of regexps etc.
+  this.make()
+}
+
+Minimatch.prototype.debug = function () {}
+
+Minimatch.prototype.make = make
+function make () {
+  // don't do it more than once.
+  if (this._made) return
+
+  var pattern = this.pattern
+  var options = this.options
+
+  // empty patterns and comments match nothing.
+  if (!options.nocomment && pattern.charAt(0) === '#') {
+    this.comment = true
+    return
+  }
+  if (!pattern) {
+    this.empty = true
+    return
+  }
+
+  // step 1: figure out negation, etc.
+  this.parseNegate()
+
+  // step 2: expand braces
+  var set = this.globSet = this.braceExpand()
+
+  if (options.debug) this.debug = console.error
+
+  this.debug(this.pattern, set)
+
+  // step 3: now we have a set, so turn each one into a series of path-portion
+  // matching patterns.
+  // These will be regexps, except in the case of "**", which is
+  // set to the GLOBSTAR object for globstar behavior,
+  // and will not contain any / characters
+  set = this.globParts = set.map(function (s) {
+    return s.split(slashSplit)
+  })
+
+  this.debug(this.pattern, set)
+
+  // glob --> regexps
+  set = set.map(function (s, si, set) {
+    return s.map(this.parse, this)
+  }, this)
+
+  this.debug(this.pattern, set)
+
+  // filter out everything that didn't compile properly.
+  set = set.filter(function (s) {
+    return s.indexOf(false) === -1
+  })
+
+  this.debug(this.pattern, set)
+
+  this.set = set
+}
+
+Minimatch.prototype.parseNegate = parseNegate
+function parseNegate () {
+  var pattern = this.pattern
+  var negate = false
+  var options = this.options
+  var negateOffset = 0
+
+  if (options.nonegate) return
+
+  for (var i = 0, l = pattern.length
+    ; i < l && pattern.charAt(i) === '!'
+    ; i++) {
+    negate = !negate
+    negateOffset++
+  }
+
+  if (negateOffset) this.pattern = pattern.substr(negateOffset)
+  this.negate = negate
+}
+
+// Brace expansion:
+// a{b,c}d -> abd acd
+// a{b,}c -> abc ac
+// a{0..3}d -> a0d a1d a2d a3d
+// a{b,c{d,e}f}g -> abg acdfg acefg
+// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg
+//
+// Invalid sets are not expanded.
+// a{2..}b -> a{2..}b
+// a{b}c -> a{b}c
+minimatch.braceExpand = function (pattern, options) {
+  return braceExpand(pattern, options)
+}
+
+Minimatch.prototype.braceExpand = braceExpand
+
+function braceExpand (pattern, options) {
+  if (!options) {
+    if (this instanceof Minimatch) {
+      options = this.options
+    } else {
+      options = {}
+    }
+  }
+
+  pattern = typeof pattern === 'undefined'
+    ? this.pattern : pattern
+
+  if (typeof pattern === 'undefined') {
+    throw new Error('undefined pattern')
+  }
+
+  if (options.nobrace ||
+    !pattern.match(/\{.*\}/)) {
+    // shortcut. no need to expand.
+    return [pattern]
+  }
+
+  return expand(pattern)
+}
+
+// parse a component of the expanded set.
+// At this point, no pattern may contain "/" in it
+// so we're going to return a 2d array, where each entry is the full
+// pattern, split on '/', and then turned into a regular expression.
+// A regexp is made at the end which joins each array with an
+// escaped /, and another full one which joins each regexp with |.
+//
+// Following the lead of Bash 4.1, note that "**" only has special meaning
+// when it is the *only* thing in a path portion.  Otherwise, any series
+// of * is equivalent to a single *.  Globstar behavior is enabled by
+// default, and can be disabled by setting options.noglobstar.
+Minimatch.prototype.parse = parse
+var SUBPARSE = {}
+function parse (pattern, isSub) {
+  var options = this.options
+
+  // shortcuts
+  if (!options.noglobstar && pattern === '**') return GLOBSTAR
+  if (pattern === '') return ''
+
+  var re = ''
+  var hasMagic = !!options.nocase
+  var escaping = false
+  // ? => one single character
+  var patternListStack = []
+  var negativeLists = []
+  var plType
+  var stateChar
+  var inClass = false
+  var reClassStart = -1
+  var classStart = -1
+  // . and .. never match anything that doesn't start with .,
+  // even when options.dot is set.
+  var patternStart = pattern.charAt(0) === '.' ? '' // anything
+  // not (start or / followed by . or .. followed by / or end)
+  : options.dot ? '(?!(?:^|\\\/)\\.{1,2}(?:$|\\\/))'
+  : '(?!\\.)'
+  var self = this
+
+  function clearStateChar () {
+    if (stateChar) {
+      // we had some state-tracking character
+      // that wasn't consumed by this pass.
+      switch (stateChar) {
+        case '*':
+          re += star
+          hasMagic = true
+        break
+        case '?':
+          re += qmark
+          hasMagic = true
+        break
+        default:
+          re += '\\' + stateChar
+        break
+      }
+      self.debug('clearStateChar %j %j', stateChar, re)
+      stateChar = false
+    }
+  }
+
+  for (var i = 0, len = pattern.length, c
+    ; (i < len) && (c = pattern.charAt(i))
+    ; i++) {
+    this.debug('%s\t%s %s %j', pattern, i, re, c)
+
+    // skip over any that are escaped.
+    if (escaping && reSpecials[c]) {
+      re += '\\' + c
+      escaping = false
+      continue
+    }
+
+    switch (c) {
+      case '/':
+        // completely not allowed, even escaped.
+        // Should already be path-split by now.
+        return false
+
+      case '\\':
+        clearStateChar()
+        escaping = true
+      continue
+
+      // the various stateChar values
+      // for the "extglob" stuff.
+      case '?':
+      case '*':
+      case '+':
+      case '@':
+      case '!':
+        this.debug('%s\t%s %s %j <-- stateChar', pattern, i, re, c)
+
+        // all of those are literals inside a class, except that
+        // the glob [!a] means [^a] in regexp
+        if (inClass) {
+          this.debug('  in class')
+          if (c === '!' && i === classStart + 1) c = '^'
+          re += c
+          continue
+        }
+
+        // if we already have a stateChar, then it means
+        // that there was something like ** or +? in there.
+        // Handle the stateChar, then proceed with this one.
+        self.debug('call clearStateChar %j', stateChar)
+        clearStateChar()
+        stateChar = c
+        // if extglob is disabled, then +(asdf|foo) isn't a thing.
+        // just clear the statechar *now*, rather than even diving into
+        // the patternList stuff.
+        if (options.noext) clearStateChar()
+      continue
+
+      case '(':
+        if (inClass) {
+          re += '('
+          continue
+        }
+
+        if (!stateChar) {
+          re += '\\('
+          continue
+        }
+
+        plType = stateChar
+        patternListStack.push({
+          type: plType,
+          start: i - 1,
+          reStart: re.length
+        })
+        // negation is (?:(?!js)[^/]*)
+        re += stateChar === '!' ? '(?:(?!(?:' : '(?:'
+        this.debug('plType %j %j', stateChar, re)
+        stateChar = false
+      continue
+
+      case ')':
+        if (inClass || !patternListStack.length) {
+          re += '\\)'
+          continue
+        }
+
+        clearStateChar()
+        hasMagic = true
+        re += ')'
+        var pl = patternListStack.pop()
+        plType = pl.type
+        // negation is (?:(?!js)[^/]*)
+        // The others are (?:<pattern>)<type>
+        switch (plType) {
+          case '!':
+            negativeLists.push(pl)
+            re += ')[^/]*?)'
+            pl.reEnd = re.length
+            break
+          case '?':
+          case '+':
+          case '*':
+            re += plType
+            break
+          case '@': break // the default anyway
+        }
+      continue
+
+      case '|':
+        if (inClass || !patternListStack.length || escaping) {
+          re += '\\|'
+          escaping = false
+          continue
+        }
+
+        clearStateChar()
+        re += '|'
+      continue
+
+      // these are mostly the same in regexp and glob
+      case '[':
+        // swallow any state-tracking char before the [
+        clearStateChar()
+
+        if (inClass) {
+          re += '\\' + c
+          continue
+        }
+
+        inClass = true
+        classStart = i
+        reClassStart = re.length
+        re += c
+      continue
+
+      case ']':
+        //  a right bracket shall lose its special
+        //  meaning and represent itself in
+        //  a bracket expression if it occurs
+        //  first in the list.  -- POSIX.2 2.8.3.2
+        if (i === classStart + 1 || !inClass) {
+          re += '\\' + c
+          escaping = false
+          continue
+        }
+
+        // handle the case where we left a class open.
+        // "[z-a]" is valid, equivalent to "\[z-a\]"
+        if (inClass) {
+          // split where the last [ was, make sure we don't have
+          // an invalid re. if so, re-walk the contents of the
+          // would-be class to re-translate any characters that
+          // were passed through as-is
+          // TODO: It would probably be faster to determine this
+          // without a try/catch and a new RegExp, but it's tricky
+          // to do safely.  For now, this is safe and works.
+          var cs = pattern.substring(classStart + 1, i)
+          try {
+            RegExp('[' + cs + ']')
+          } catch (er) {
+            // not a valid class!
+            var sp = this.parse(cs, SUBPARSE)
+            re = re.substr(0, reClassStart) + '\\[' + sp[0] + '\\]'
+            hasMagic = hasMagic || sp[1]
+            inClass = false
+            continue
+          }
+        }
+
+        // finish up the class.
+        hasMagic = true
+        inClass = false
+        re += c
+      continue
+
+      default:
+        // swallow any state char that wasn't consumed
+        clearStateChar()
+
+        if (escaping) {
+          // no need
+          escaping = false
+        } else if (reSpecials[c]
+          && !(c === '^' && inClass)) {
+          re += '\\'
+        }
+
+        re += c
+
+    } // switch
+  } // for
+
+  // handle the case where we left a class open.
+  // "[abc" is valid, equivalent to "\[abc"
+  if (inClass) {
+    // split where the last [ was, and escape it
+    // this is a huge pita.  We now have to re-walk
+    // the contents of the would-be class to re-translate
+    // any characters that were passed through as-is
+    cs = pattern.substr(classStart + 1)
+    sp = this.parse(cs, SUBPARSE)
+    re = re.substr(0, reClassStart) + '\\[' + sp[0]
+    hasMagic = hasMagic || sp[1]
+  }
+
+  // handle the case where we had a +( thing at the *end*
+  // of the pattern.
+  // each pattern list stack adds 3 chars, and we need to go through
+  // and escape any | chars that were passed through as-is for the regexp.
+  // Go through and escape them, taking care not to double-escape any
+  // | chars that were already escaped.
+  for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
+    var tail = re.slice(pl.reStart + 3)
+    // maybe some even number of \, then maybe 1 \, followed by a |
+    tail = tail.replace(/((?:\\{2})*)(\\?)\|/g, function (_, $1, $2) {
+      if (!$2) {
+        // the | isn't already escaped, so escape it.
+        $2 = '\\'
+      }
+
+      // need to escape all those slashes *again*, without escaping the
+      // one that we need for escaping the | character.  As it works out,
+      // escaping an even number of slashes can be done by simply repeating
+      // it exactly after itself.  That's why this trick works.
+      //
+      // I am sorry that you have to see this.
+      return $1 + $1 + $2 + '|'
+    })
+
+    this.debug('tail=%j\n   %s', tail, tail)
+    var t = pl.type === '*' ? star
+      : pl.type === '?' ? qmark
+      : '\\' + pl.type
+
+    hasMagic = true
+    re = re.slice(0, pl.reStart) + t + '\\(' + tail
+  }
+
+  // handle trailing things that only matter at the very end.
+  clearStateChar()
+  if (escaping) {
+    // trailing \\
+    re += '\\\\'
+  }
+
+  // only need to apply the nodot start if the re starts with
+  // something that could conceivably capture a dot
+  var addPatternStart = false
+  switch (re.charAt(0)) {
+    case '.':
+    case '[':
+    case '(': addPatternStart = true
+  }
+
+  // Hack to work around lack of negative lookbehind in JS
+  // A pattern like: *.!(x).!(y|z) needs to ensure that a name
+  // like 'a.xyz.yz' doesn't match.  So, the first negative
+  // lookahead, has to look ALL the way ahead, to the end of
+  // the pattern.
+  for (var n = negativeLists.length - 1; n > -1; n--) {
+    var nl = negativeLists[n]
+
+    var nlBefore = re.slice(0, nl.reStart)
+    var nlFirst = re.slice(nl.reStart, nl.reEnd - 8)
+    var nlLast = re.slice(nl.reEnd - 8, nl.reEnd)
+    var nlAfter = re.slice(nl.reEnd)
+
+    nlLast += nlAfter
+
+    // Handle nested stuff like *(*.js|!(*.json)), where open parens
+    // mean that we should *not* include the ) in the bit that is considered
+    // "after" the negated section.
+    var openParensBefore = nlBefore.split('(').length - 1
+    var cleanAfter = nlAfter
+    for (i = 0; i < openParensBefore; i++) {
+      cleanAfter = cleanAfter.replace(/\)[+*?]?/, '')
+    }
+    nlAfter = cleanAfter
+
+    var dollar = ''
+    if (nlAfter === '' && isSub !== SUBPARSE) {
+      dollar = '$'
+    }
+    var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast
+    re = newRe
+  }
+
+  // if the re is not "" at this point, then we need to make sure
+  // it doesn't match against an empty path part.
+  // Otherwise a/* will match a/, which it should not.
+  if (re !== '' && hasMagic) {
+    re = '(?=.)' + re
+  }
+
+  if (addPatternStart) {
+    re = patternStart + re
+  }
+
+  // parsing just a piece of a larger pattern.
+  if (isSub === SUBPARSE) {
+    return [re, hasMagic]
+  }
+
+  // skip the regexp for non-magical patterns
+  // unescape anything in it, though, so that it'll be
+  // an exact match against a file etc.
+  if (!hasMagic) {
+    return globUnescape(pattern)
+  }
+
+  var flags = options.nocase ? 'i' : ''
+  var regExp = new RegExp('^' + re + '$', flags)
+
+  regExp._glob = pattern
+  regExp._src = re
+
+  return regExp
+}
+
+minimatch.makeRe = function (pattern, options) {
+  return new Minimatch(pattern, options || {}).makeRe()
+}
+
+Minimatch.prototype.makeRe = makeRe
+function makeRe () {
+  if (this.regexp || this.regexp === false) return this.regexp
+
+  // at this point, this.set is a 2d array of partial
+  // pattern strings, or "**".
+  //
+  // It's better to use .match().  This function shouldn't
+  // be used, really, but it's pretty convenient sometimes,
+  // when you just want to work with a regex.
+  var set = this.set
+
+  if (!set.length) {
+    this.regexp = false
+    return this.regexp
+  }
+  var options = this.options
+
+  var twoStar = options.noglobstar ? star
+    : options.dot ? twoStarDot
+    : twoStarNoDot
+  var flags = options.nocase ? 'i' : ''
+
+  var re = set.map(function (pattern) {
+    return pattern.map(function (p) {
+      return (p === GLOBSTAR) ? twoStar
+      : (typeof p === 'string') ? regExpEscape(p)
+      : p._src
+    }).join('\\\/')
+  }).join('|')
+
+  // must match entire pattern
+  // ending in a * or ** will make it less strict.
+  re = '^(?:' + re + ')$'
+
+  // can match anything, as long as it's not this.
+  if (this.negate) re = '^(?!' + re + ').*$'
+
+  try {
+    this.regexp = new RegExp(re, flags)
+  } catch (ex) {
+    this.regexp = false
+  }
+  return this.regexp
+}
+
+minimatch.match = function (list, pattern, options) {
+  options = options || {}
+  var mm = new Minimatch(pattern, options)
+  list = list.filter(function (f) {
+    return mm.match(f)
+  })
+  if (mm.options.nonull && !list.length) {
+    list.push(pattern)
+  }
+  return list
+}
+
+Minimatch.prototype.match = match
+function match (f, partial) {
+  this.debug('match', f, this.pattern)
+  // short-circuit in the case of busted things.
+  // comments, etc.
+  if (this.comment) return false
+  if (this.empty) return f === ''
+
+  if (f === '/' && partial) return true
+
+  var options = this.options
+
+  // windows: need to use /, not \
+  if (path.sep !== '/') {
+    f = f.split(path.sep).join('/')
+  }
+
+  // treat the test path as a set of pathparts.
+  f = f.split(slashSplit)
+  this.debug(this.pattern, 'split', f)
+
+  // just ONE of the pattern sets in this.set needs to match
+  // in order for it to be valid.  If negating, then just one
+  // match means that we have failed.
+  // Either way, return on the first hit.
+
+  var set = this.set
+  this.debug(this.pattern, 'set', set)
+
+  // Find the basename of the path by looking for the last non-empty segment
+  var filename
+  var i
+  for (i = f.length - 1; i >= 0; i--) {
+    filename = f[i]
+    if (filename) break
+  }
+
+  for (i = 0; i < set.length; i++) {
+    var pattern = set[i]
+    var file = f
+    if (options.matchBase && pattern.length === 1) {
+      file = [filename]
+    }
+    var hit = this.matchOne(file, pattern, partial)
+    if (hit) {
+      if (options.flipNegate) return true
+      return !this.negate
+    }
+  }
+
+  // didn't get any hits.  this is success if it's a negative
+  // pattern, failure otherwise.
+  if (options.flipNegate) return false
+  return this.negate
+}
+
+// set partial to true to test if, for example,
+// "/a/b" matches the start of "/*/b/*/d"
+// Partial means, if you run out of file before you run
+// out of pattern, then that's fine, as long as all
+// the parts match.
+Minimatch.prototype.matchOne = function (file, pattern, partial) {
+  var options = this.options
+
+  this.debug('matchOne',
+    { 'this': this, file: file, pattern: pattern })
+
+  this.debug('matchOne', file.length, pattern.length)
+
+  for (var fi = 0,
+      pi = 0,
+      fl = file.length,
+      pl = pattern.length
+      ; (fi < fl) && (pi < pl)
+      ; fi++, pi++) {
+    this.debug('matchOne loop')
+    var p = pattern[pi]
+    var f = file[fi]
+
+    this.debug(pattern, p, f)
+
+    // should be impossible.
+    // some invalid regexp stuff in the set.
+    if (p === false) return false
+
+    if (p === GLOBSTAR) {
+      this.debug('GLOBSTAR', [pattern, p, f])
+
+      // "**"
+      // a/**/b/**/c would match the following:
+      // a/b/x/y/z/c
+      // a/x/y/z/b/c
+      // a/b/x/b/x/c
+      // a/b/c
+      // To do this, take the rest of the pattern after
+      // the **, and see if it would match the file remainder.
+      // If so, return success.
+      // If not, the ** "swallows" a segment, and try again.
+      // This is recursively awful.
+      //
+      // a/**/b/**/c matching a/b/x/y/z/c
+      // - a matches a
+      // - doublestar
+      //   - matchOne(b/x/y/z/c, b/**/c)
+      //     - b matches b
+      //     - doublestar
+      //       - matchOne(x/y/z/c, c) -> no
+      //       - matchOne(y/z/c, c) -> no
+      //       - matchOne(z/c, c) -> no
+      //       - matchOne(c, c) yes, hit
+      var fr = fi
+      var pr = pi + 1
+      if (pr === pl) {
+        this.debug('** at the end')
+        // a ** at the end will just swallow the rest.
+        // We have found a match.
+        // however, it will not swallow /.x, unless
+        // options.dot is set.
+        // . and .. are *never* matched by **, for explosively
+        // exponential reasons.
+        for (; fi < fl; fi++) {
+          if (file[fi] === '.' || file[fi] === '..' ||
+            (!options.dot && file[fi].charAt(0) === '.')) return false
+        }
+        return true
+      }
+
+      // ok, let's see if we can swallow whatever we can.
+      while (fr < fl) {
+        var swallowee = file[fr]
+
+        this.debug('\nglobstar while', file, fr, pattern, pr, swallowee)
+
+        // XXX remove this slice.  Just pass the start index.
+        if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
+          this.debug('globstar found match!', fr, fl, swallowee)
+          // found a match.
+          return true
+        } else {
+          // can't swallow "." or ".." ever.
+          // can only swallow ".foo" when explicitly asked.
+          if (swallowee === '.' || swallowee === '..' ||
+            (!options.dot && swallowee.charAt(0) === '.')) {
+            this.debug('dot detected!', file, fr, pattern, pr)
+            break
+          }
+
+          // ** swallows a segment, and continue.
+          this.debug('globstar swallow a segment, and continue')
+          fr++
+        }
+      }
+
+      // no match was found.
+      // However, in partial mode, we can't say this is necessarily over.
+      // If there's more *pattern* left, then
+      if (partial) {
+        // ran out of file
+        this.debug('\n>>> no match, partial?', file, fr, pattern, pr)
+        if (fr === fl) return true
+      }
+      return false
+    }
+
+    // something other than **
+    // non-magic patterns just have to match exactly
+    // patterns with magic have been turned into regexps.
+    var hit
+    if (typeof p === 'string') {
+      if (options.nocase) {
+        hit = f.toLowerCase() === p.toLowerCase()
+      } else {
+        hit = f === p
+      }
+      this.debug('string match', p, f, hit)
+    } else {
+      hit = f.match(p)
+      this.debug('pattern match', p, f, hit)
+    }
+
+    if (!hit) return false
+  }
+
+  // Note: ending in / means that we'll get a final ""
+  // at the end of the pattern.  This can only match a
+  // corresponding "" at the end of the file.
+  // If the file ends in /, then it can only match a
+  // a pattern that ends in /, unless the pattern just
+  // doesn't have any more for it. But, a/b/ should *not*
+  // match "a/b/*", even though "" matches against the
+  // [^/]*? pattern, except in partial mode, where it might
+  // simply not be reached yet.
+  // However, a/b/ should still satisfy a/*
+
+  // now either we fell off the end of the pattern, or we're done.
+  if (fi === fl && pi === pl) {
+    // ran out of pattern and filename at the same time.
+    // an exact hit!
+    return true
+  } else if (fi === fl) {
+    // ran out of file, but still had pattern left.
+    // this is ok if we're doing the match as part of
+    // a glob fs traversal.
+    return partial
+  } else if (pi === pl) {
+    // ran out of pattern, still have file left.
+    // this is only acceptable if we're on the very last
+    // empty segment of a file with a trailing slash.
+    // a/* should match a/b/
+    var emptyFileEnd = (fi === fl - 1) && (file[fi] === '')
+    return emptyFileEnd
+  }
+
+  // should be unreachable.
+  throw new Error('wtf?')
+}
+
+// replace stuff like \* with *
+function globUnescape (s) {
+  return s.replace(/\\(.)/g, '$1')
+}
+
+function regExpEscape (s) {
+  return s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&')
+}
diff --git a/tools/node_modules/glob/node_modules/minimatch/package.json b/tools/node_modules/glob/node_modules/minimatch/package.json
new file mode 100644
index 00000000..ace458c7
--- /dev/null
+++ b/tools/node_modules/glob/node_modules/minimatch/package.json
@@ -0,0 +1,55 @@
+{
+  "author": {
+    "name": "Isaac Z. Schlueter",
+    "email": "i@izs.me",
+    "url": "http://blog.izs.me"
+  },
+  "bugs": {
+    "url": "https://github.com/isaacs/minimatch/issues"
+  },
+  "dependencies": {
+    "brace-expansion": "^1.0.0"
+  },
+  "deprecated": "Please update to minimatch 3.0.2 or higher to avoid a RegExp DoS issue",
+  "description": "a glob matcher in javascript",
+  "devDependencies": {
+    "browserify": "^9.0.3",
+    "standard": "^3.7.2",
+    "tap": "^1.2.0"
+  },
+  "directories": {},
+  "dist": {
+    "shasum": "8d087c39c6b38c001b97fca7ce6d0e1e80afbac7",
+    "tarball": "https://registry.npmjs.org/minimatch/-/minimatch-2.0.10.tgz"
+  },
+  "engines": {
+    "node": "*"
+  },
+  "files": [
+    "minimatch.js",
+    "browser.js"
+  ],
+  "gitHead": "6afb85f0c324b321f76a38df81891e562693e257",
+  "homepage": "https://github.com/isaacs/minimatch#readme",
+  "license": "ISC",
+  "main": "minimatch.js",
+  "maintainers": [
+    {
+      "name": "isaacs",
+      "email": "i@izs.me"
+    }
+  ],
+  "name": "minimatch",
+  "optionalDependencies": {},
+  "readme": "ERROR: No README data found!",
+  "repository": {
+    "type": "git",
+    "url": "git://github.com/isaacs/minimatch.git"
+  },
+  "scripts": {
+    "posttest": "standard minimatch.js test/*.js",
+    "prepublish": "browserify -o browser.js -e minimatch.js -s minimatch --bare",
+    "test": "tap test/*.js"
+  },
+  "version": "2.0.10"
+}
\ No newline at end of file
diff --git a/tools/node_modules/glob/node_modules/once/LICENSE b/tools/node_modules/glob/node_modules/once/LICENSE
new file mode 100644
index 00000000..19129e31
--- /dev/null
+++ b/tools/node_modules/glob/node_modules/once/LICENSE
@@ -0,0 +1,15 @@
+The ISC License
+
+Copyright (c) Isaac Z. Schlueter and Contributors
+
+Permission to use, copy, modify, and/or distribute this software for any
+purpose with or without fee is hereby granted, provided that the above
+copyright notice and this permission notice appear in all copies.
+
+THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR
+IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
diff --git a/tools/node_modules/glob/node_modules/once/README.md b/tools/node_modules/glob/node_modules/once/README.md
new file mode 100644
index 00000000..1f1ffca9
--- /dev/null
+++ b/tools/node_modules/glob/node_modules/once/README.md
@@ -0,0 +1,79 @@
+# once
+
+Only call a function once.
+
+## usage
+
+```javascript
+var once = require('once')
+
+function load (file, cb) {
+  cb = once(cb)
+  loader.load('file')
+  loader.once('load', cb)
+  loader.once('error', cb)
+}
+```
+
+Or add to the Function.prototype in a responsible way:
+
+```javascript
+// only has to be done once
+require('once').proto()
+
+function load (file, cb) {
+  cb = cb.once()
+  loader.load('file')
+  loader.once('load', cb)
+  loader.once('error', cb)
+}
+```
+
+Ironically, the prototype feature makes this module twice as
+complicated as necessary.
+
+To check whether you function has been called, use `fn.called`. Once the
+function is called for the first time the return value of the original
+function is saved in `fn.value` and subsequent calls will continue to
+return this value.
+
+```javascript
+var once = require('once')
+
+function load (cb) {
+  cb = once(cb)
+  var stream = createStream()
+  stream.once('data', cb)
+  stream.once('end', function () {
+    if (!cb.called) cb(new Error('not found'))
+  })
+}
+```
+
+## `once.strict(func)`
+
+Throw an error if the function is called twice.
+
+Some functions are expected to be called only once. Using `once` for them would
+potentially hide logical errors.
+
+In the example below, the `greet` function has to call the callback only once:
+
+```javascript
+function greet (name, cb) {
+  // return is missing from the if statement
+  // when no name is passed, the callback is called twice
+  if (!name) cb('Hello anonymous')
+  cb('Hello ' + name)
+}
+
+function log (msg) {
+  console.log(msg)
+}
+
+// this will print 'Hello anonymous' but the logical error will be missed
+greet(null, once(msg))
+
+// once.strict will print 'Hello anonymous' and throw an error when the callback will be called the second time
+greet(null, once.strict(msg))
+```
diff --git a/tools/node_modules/glob/node_modules/once/once.js b/tools/node_modules/glob/node_modules/once/once.js
new file mode 100644
index 00000000..23540673
--- /dev/null
+++ b/tools/node_modules/glob/node_modules/once/once.js
@@ -0,0 +1,42 @@
+var wrappy = require('wrappy')
+module.exports = wrappy(once)
+module.exports.strict = wrappy(onceStrict)
+
+once.proto = once(function () {
+  Object.defineProperty(Function.prototype, 'once', {
+    value: function () {
+      return once(this)
+    },
+    configurable: true
+  })
+
+  Object.defineProperty(Function.prototype, 'onceStrict', {
+    value: function () {
+      return onceStrict(this)
+    },
+    configurable: true
+  })
+})
+
+function once (fn) {
+  var f = function () {
+    if (f.called) return f.value
+    f.called = true
+    return f.value = fn.apply(this, arguments)
+  }
+  f.called = false
+  return f
+}
+
+function onceStrict (fn) {
+  var f = function () {
+    if (f.called)
+      throw new Error(f.onceError)
+    f.called = true
+    return f.value = fn.apply(this, arguments)
+  }
+  var name = fn.name || 'Function wrapped with `once`'
+  f.onceError = name + " shouldn't be called more than once"
+  f.called = false
+  return f
+}
diff --git a/tools/node_modules/glob/node_modules/once/package.json b/tools/node_modules/glob/node_modules/once/package.json
new file mode 100644
index 00000000..d9dd5e55
--- /dev/null
+++ b/tools/node_modules/glob/node_modules/once/package.json
@@ -0,0 +1,54 @@
+{
+  "author": {
+    "name": "Isaac Z. Schlueter",
+    "email": "i@izs.me",
+    "url": "http://blog.izs.me/"
+  },
+  "bugs": {
+    "url": "https://github.com/isaacs/once/issues"
+  },
+  "dependencies": {
+    "wrappy": "1"
+  },
+  "description": "Run a function exactly one time",
+  "devDependencies": {
+    "tap": "^7.0.1"
+  },
+  "directories": {
+    "test": "test"
+  },
+  "dist": {
+    "shasum": "583b1aa775961d4b113ac17d9c50baef9dd76bd1",
+    "tarball": "https://registry.npmjs.org/once/-/once-1.4.0.tgz"
+  },
+  "files": [
+    "once.js"
+  ],
+  "gitHead": "0e614d9f5a7e6f0305c625f6b581f6d80b33b8a6",
+  "homepage": "https://github.com/isaacs/once#readme",
+  "keywords": [
+    "once",
+    "function",
+    "one",
+    "single"
+  ],
+  "license": "ISC",
+  "main": "once.js",
+  "maintainers": [
+    {
+      "name": "isaacs",
+      "email": "i@izs.me"
+    }
+  ],
+  "name": "once",
+  "optionalDependencies": {},
+  "readme": "ERROR: No README data found!",
+  "repository": {
+    "type": "git",
+    "url": "git://github.com/isaacs/once.git"
+  },
+  "scripts": {
+    "test": "tap test/*.js"
+  },
+  "version": "1.4.0"
+}
\ No newline at end of file
diff --git a/tools/node_modules/glob/node_modules/wrappy/LICENSE b/tools/node_modules/glob/node_modules/wrappy/LICENSE
new file mode 100644
index 00000000..19129e31
--- /dev/null
+++ b/tools/node_modules/glob/node_modules/wrappy/LICENSE
@@ -0,0 +1,15 @@
+The ISC License
+
+Copyright (c) Isaac Z. Schlueter and Contributors
+
+Permission to use, copy, modify, and/or distribute this software for any
+purpose with or without fee is hereby granted, provided that the above
+copyright notice and this permission notice appear in all copies.
+
+THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR
+IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
diff --git a/tools/node_modules/glob/node_modules/wrappy/README.md b/tools/node_modules/glob/node_modules/wrappy/README.md
new file mode 100644
index 00000000..98eab252
--- /dev/null
+++ b/tools/node_modules/glob/node_modules/wrappy/README.md
@@ -0,0 +1,36 @@
+# wrappy
+
+Callback wrapping utility
+
+## USAGE
+
+```javascript
+var wrappy = require("wrappy")
+
+// var wrapper = wrappy(wrapperFunction)
+
+// make sure a cb is called only once
+// See also: http://npm.im/once for this specific use case
+var once = wrappy(function (cb) {
+  var called = false
+  return function () {
+    if (called) return
+    called = true
+    return cb.apply(this, arguments)
+  }
+})
+
+function printBoo () {
+  console.log('boo')
+}
+// has some rando property
+printBoo.iAmBooPrinter = true
+
+var onlyPrintOnce = once(printBoo)
+
+onlyPrintOnce() // prints 'boo'
+onlyPrintOnce() // does nothing
+
+// random property is retained!
+assert.equal(onlyPrintOnce.iAmBooPrinter, true)
+```
diff --git a/tools/node_modules/glob/node_modules/wrappy/package.json b/tools/node_modules/glob/node_modules/wrappy/package.json
new file mode 100644
index 00000000..47938398
--- /dev/null
+++ b/tools/node_modules/glob/node_modules/wrappy/package.json
@@ -0,0 +1,50 @@
+{
+  "author": {
+    "name": "Isaac Z. Schlueter",
+    "email": "i@izs.me",
+    "url": "http://blog.izs.me/"
+  },
+  "bugs": {
+    "url": "https://github.com/npm/wrappy/issues"
+  },
+  "dependencies": {},
+  "description": "Callback wrapping utility",
+  "devDependencies": {
+    "tap": "^2.3.1"
+  },
+  "directories": {
+    "test": "test"
+  },
+  "dist": {
+    "shasum": "b5243d8f3ec1aa35f1364605bc0d1036e30ab69f",
+    "tarball": "https://registry.npmjs.org/wrappy/-/wrappy-1.0.2.tgz"
+  },
+  "files": [
+    "wrappy.js"
+  ],
+  "gitHead": "71d91b6dc5bdeac37e218c2cf03f9ab55b60d214",
+  "homepage": "https://github.com/npm/wrappy",
+  "license": "ISC",
+  "main": "wrappy.js",
+  "maintainers": [
+    {
+      "name": "isaacs",
+      "email": "i@izs.me"
+    },
+    {
+      "name": "zkat",
+      "email": "kat@sykosomatic.org"
+    }
+  ],
+  "name": "wrappy",
+  "optionalDependencies": {},
+  "readme": "ERROR: No README data found!",
+  "repository": {
+    "type": "git",
+    "url": "git+https://github.com/npm/wrappy.git"
+  },
+  "scripts": {
+    "test": "tap --coverage test/*.js"
+  },
+  "version": "1.0.2"
+}
\ No newline at end of file
diff --git a/tools/node_modules/glob/node_modules/wrappy/wrappy.js b/tools/node_modules/glob/node_modules/wrappy/wrappy.js
new file mode 100644
index 00000000..bb7e7d6f
--- /dev/null
+++ b/tools/node_modules/glob/node_modules/wrappy/wrappy.js
@@ -0,0 +1,33 @@
+// Returns a wrapper function that returns a wrapped callback
+// The wrapper function should do some stuff, and return a
+// presumably different callback function.
+// This makes sure that own properties are retained, so that
+// decorations and such are not lost along the way.
+module.exports = wrappy
+function wrappy (fn, cb) {
+  if (fn && cb) return wrappy(fn)(cb)
+
+  if (typeof fn !== 'function')
+    throw new TypeError('need wrapper function')
+
+  Object.keys(fn).forEach(function (k) {
+    wrapper[k] = fn[k]
+  })
+
+  return wrapper
+
+  function wrapper() {
+    var args = new Array(arguments.length)
+    for (var i = 0; i < args.length; i++) {
+      args[i] = arguments[i]
+    }
+    var ret = fn.apply(this, args)
+    var cb = args[args.length-1]
+    if (typeof ret === 'function' && ret !== cb) {
+      Object.keys(cb).forEach(function (k) {
+        ret[k] = cb[k]
+      })
+    }
+    return ret
+  }
+}
diff --git a/tools/node_modules/glob/package.json b/tools/node_modules/glob/package.json
new file mode 100644
index 00000000..3549e060
--- /dev/null
+++ b/tools/node_modules/glob/package.json
@@ -0,0 +1,63 @@
+{
+  "author": {
+    "name": "Isaac Z. Schlueter",
+    "email": "i@izs.me",
+    "url": "http://blog.izs.me/"
+  },
+  "bugs": {
+    "url": "https://github.com/isaacs/node-glob/issues"
+  },
+  "dependencies": {
+    "inflight": "^1.0.4",
+    "inherits": "2",
+    "minimatch": "^2.0.1",
+    "once": "^1.3.0"
+  },
+  "description": "a little globber",
+  "devDependencies": {
+    "mkdirp": "0",
+    "rimraf": "^2.2.8",
+    "tap": "^0.5.0",
+    "tick": "0.0.6"
+  },
+  "directories": {},
+  "dist": {
+    "shasum": "c6cb73d3226c1efef04de3c56d012f03377ee15f",
+    "tarball": "https://registry.npmjs.org/glob/-/glob-4.5.3.tgz"
+  },
+  "engines": {
+    "node": "*"
+  },
+  "files": [
+    "glob.js",
+    "sync.js",
+    "common.js"
+  ],
+  "gitHead": "a4e461ab59a837eee80a4d8dbdbf5ae1054a646f",
+  "homepage": "https://github.com/isaacs/node-glob",
+  "license": "ISC",
+  "main": "glob.js",
+  "maintainers": [
+    {
+      "name": "isaacs",
+      "email": "i@izs.me"
+    }
+  ],
+  "name": "glob",
+  "optionalDependencies": {},
+  "readme": "ERROR: No README data found!",
+  "repository": {
+    "type": "git",
+    "url": "git://github.com/isaacs/node-glob.git"
+  },
+  "scripts": {
+    "bench": "bash benchmark.sh",
+    "benchclean": "bash benchclean.sh",
+    "prepublish": "npm run benchclean",
+    "prof": "bash prof.sh && cat profile.txt",
+    "profclean": "rm -f v8.log profile.txt",
+    "test": "npm run profclean && tap test/*.js",
+    "test-regen": "npm run profclean && TEST_REGEN=1 node test/00-setup.js"
+  },
+  "version": "4.5.3"
+}
\ No newline at end of file
diff --git a/tools/node_modules/glob/sync.js b/tools/node_modules/glob/sync.js
new file mode 100644
index 00000000..f4f5e36d
--- /dev/null
+++ b/tools/node_modules/glob/sync.js
@@ -0,0 +1,457 @@
+module.exports = globSync
+globSync.GlobSync = GlobSync
+
+var fs = require('fs')
+var minimatch = require('minimatch')
+var Minimatch = minimatch.Minimatch
+var Glob = require('./glob.js').Glob
+var util = require('util')
+var path = require('path')
+var assert = require('assert')
+var common = require('./common.js')
+var alphasort = common.alphasort
+var alphasorti = common.alphasorti
+var isAbsolute = common.isAbsolute
+var setopts = common.setopts
+var ownProp = common.ownProp
+var childrenIgnored = common.childrenIgnored
+
+function globSync (pattern, options) {
+  if (typeof options === 'function' || arguments.length === 3)
+    throw new TypeError('callback provided to sync glob\n'+
+                        'See: https://github.com/isaacs/node-glob/issues/167')
+
+  return new GlobSync(pattern, options).found
+}
+
+function GlobSync (pattern, options) {
+  if (!pattern)
+    throw new Error('must provide pattern')
+
+  if (typeof options === 'function' || arguments.length === 3)
+    throw new TypeError('callback provided to sync glob\n'+
+                        'See: https://github.com/isaacs/node-glob/issues/167')
+
+  if (!(this instanceof GlobSync))
+    return new GlobSync(pattern, options)
+
+  setopts(this, pattern, options)
+
+  if (this.noprocess)
+    return this
+
+  var n = this.minimatch.set.length
+  this.matches = new Array(n)
+  for (var i = 0; i < n; i ++) {
+    this._process(this.minimatch.set[i], i, false)
+  }
+  this._finish()
+}
+
+GlobSync.prototype._finish = function () {
+  assert(this instanceof GlobSync)
+  if (this.realpath) {
+    var self = this
+    this.matches.forEach(function (matchset, index) {
+      var set = self.matches[index] = Object.create(null)
+      for (var p in matchset) {
+        try {
+          p = self._makeAbs(p)
+          var real = fs.realpathSync(p, this.realpathCache)
+          set[real] = true
+        } catch (er) {
+          if (er.syscall === 'stat')
+            set[self._makeAbs(p)] = true
+          else
+            throw er
+        }
+      }
+    })
+  }
+  common.finish(this)
+}
+
+
+GlobSync.prototype._process = function (pattern, index, inGlobStar) {
+  assert(this instanceof GlobSync)
+
+  // Get the first [n] parts of pattern that are all strings.
+  var n = 0
+  while (typeof pattern[n] === 'string') {
+    n ++
+  }
+  // now n is the index of the first one that is *not* a string.
+
+  // See if there's anything else
+  var prefix
+  switch (n) {
+    // if not, then this is rather simple
+    case pattern.length:
+      this._processSimple(pattern.join('/'), index)
+      return
+
+    case 0:
+      // pattern *starts* with some non-trivial item.
+      // going to readdir(cwd), but not include the prefix in matches.
+      prefix = null
+      break
+
+    default:
+      // pattern has some string bits in the front.
+      // whatever it starts with, whether that's 'absolute' like /foo/bar,
+      // or 'relative' like '../baz'
+      prefix = pattern.slice(0, n).join('/')
+      break
+  }
+
+  var remain = pattern.slice(n)
+
+  // get the list of entries.
+  var read
+  if (prefix === null)
+    read = '.'
+  else if (isAbsolute(prefix) || isAbsolute(pattern.join('/'))) {
+    if (!prefix || !isAbsolute(prefix))
+      prefix = '/' + prefix
+    read = prefix
+  } else
+    read = prefix
+
+  var abs = this._makeAbs(read)
+
+  //if ignored, skip processing
+  if (childrenIgnored(this, read))
+    return
+
+  var isGlobStar = remain[0] === minimatch.GLOBSTAR
+  if (isGlobStar)
+    this._processGlobStar(prefix, read, abs, remain, index, inGlobStar)
+  else
+    this._processReaddir(prefix, read, abs, remain, index, inGlobStar)
+}
+
+
+GlobSync.prototype._processReaddir = function (prefix, read, abs, remain, index, inGlobStar) {
+  var entries = this._readdir(abs, inGlobStar)
+
+  // if the abs isn't a dir, then nothing can match!
+  if (!entries)
+    return
+
+  // It will only match dot entries if it starts with a dot, or if
+  // dot is set.  Stuff like @(.foo|.bar) isn't allowed.
+  var pn = remain[0]
+  var negate = !!this.minimatch.negate
+  var rawGlob = pn._glob
+  var dotOk = this.dot || rawGlob.charAt(0) === '.'
+
+  var matchedEntries = []
+  for (var i = 0; i < entries.length; i++) {
+    var e = entries[i]
+    if (e.charAt(0) !== '.' || dotOk) {
+      var m
+      if (negate && !prefix) {
+        m = !e.match(pn)
+      } else {
+        m = e.match(pn)
+      }
+      if (m)
+        matchedEntries.push(e)
+    }
+  }
+
+  var len = matchedEntries.length
+  // If there are no matched entries, then nothing matches.
+  if (len === 0)
+    return
+
+  // if this is the last remaining pattern bit, then no need for
+  // an additional stat *unless* the user has specified mark or
+  // stat explicitly.  We know they exist, since readdir returned
+  // them.
+
+  if (remain.length === 1 && !this.mark && !this.stat) {
+    if (!this.matches[index])
+      this.matches[index] = Object.create(null)
+
+    for (var i = 0; i < len; i ++) {
+      var e = matchedEntries[i]
+      if (prefix) {
+        if (prefix.slice(-1) !== '/')
+          e = prefix + '/' + e
+        else
+          e = prefix + e
+      }
+
+      if (e.charAt(0) === '/' && !this.nomount) {
+        e = path.join(this.root, e)
+      }
+      this.matches[index][e] = true
+    }
+    // This was the last one, and no stats were needed
+    return
+  }
+
+  // now test all matched entries as stand-ins for that part
+  // of the pattern.
+  remain.shift()
+  for (var i = 0; i < len; i ++) {
+    var e = matchedEntries[i]
+    var newPattern
+    if (prefix)
+      newPattern = [prefix, e]
+    else
+      newPattern = [e]
+    this._process(newPattern.concat(remain), index, inGlobStar)
+  }
+}
+
+
+GlobSync.prototype._emitMatch = function (index, e) {
+  var abs = this._makeAbs(e)
+  if (this.mark)
+    e = this._mark(e)
+
+  if (this.matches[index][e])
+    return
+
+  if (this.nodir) {
+    var c = this.cache[this._makeAbs(e)]
+    if (c === 'DIR' || Array.isArray(c))
+      return
+  }
+
+  this.matches[index][e] = true
+  if (this.stat)
+    this._stat(e)
+}
+
+
+GlobSync.prototype._readdirInGlobStar = function (abs) {
+  // follow all symlinked directories forever
+  // just proceed as if this is a non-globstar situation
+  if (this.follow)
+    return this._readdir(abs, false)
+
+  var entries
+  var lstat
+  var stat
+  try {
+    lstat = fs.lstatSync(abs)
+  } catch (er) {
+    // lstat failed, doesn't exist
+    return null
+  }
+
+  var isSym = lstat.isSymbolicLink()
+  this.symlinks[abs] = isSym
+
+  // If it's not a symlink or a dir, then it's definitely a regular file.
+  // don't bother doing a readdir in that case.
+  if (!isSym && !lstat.isDirectory())
+    this.cache[abs] = 'FILE'
+  else
+    entries = this._readdir(abs, false)
+
+  return entries
+}
+
+GlobSync.prototype._readdir = function (abs, inGlobStar) {
+  var entries
+
+  if (inGlobStar && !ownProp(this.symlinks, abs))
+    return this._readdirInGlobStar(abs)
+
+  if (ownProp(this.cache, abs)) {
+    var c = this.cache[abs]
+    if (!c || c === 'FILE')
+      return null
+
+    if (Array.isArray(c))
+      return c
+  }
+
+  try {
+    return this._readdirEntries(abs, fs.readdirSync(abs))
+  } catch (er) {
+    this._readdirError(abs, er)
+    return null
+  }
+}
+
+GlobSync.prototype._readdirEntries = function (abs, entries) {
+  // if we haven't asked to stat everything, then just
+  // assume that everything in there exists, so we can avoid
+  // having to stat it a second time.
+  if (!this.mark && !this.stat) {
+    for (var i = 0; i < entries.length; i ++) {
+      var e = entries[i]
+      if (abs === '/')
+        e = abs + e
+      else
+        e = abs + '/' + e
+      this.cache[e] = true
+    }
+  }
+
+  this.cache[abs] = entries
+
+  // mark and cache dir-ness
+  return entries
+}
+
+GlobSync.prototype._readdirError = function (f, er) {
+  // handle errors, and cache the information
+  switch (er.code) {
+    case 'ENOTDIR': // totally normal. means it *does* exist.
+      this.cache[this._makeAbs(f)] = 'FILE'
+      break
+
+    case 'ENOENT': // not terribly unusual
+    case 'ELOOP':
+    case 'ENAMETOOLONG':
+    case 'UNKNOWN':
+      this.cache[this._makeAbs(f)] = false
+      break
+
+    default: // some unusual error.  Treat as failure.
+      this.cache[this._makeAbs(f)] = false
+      if (this.strict) throw er
+      if (!this.silent) console.error('glob error', er)
+      break
+  }
+}
+
+GlobSync.prototype._processGlobStar = function (prefix, read, abs, remain, index, inGlobStar) {
+
+  var entries = this._readdir(abs, inGlobStar)
+
+  // no entries means not a dir, so it can never have matches
+  // foo.txt/** doesn't match foo.txt
+  if (!entries)
+    return
+
+  // test without the globstar, and with every child both below
+  // and replacing the globstar.
+  var remainWithoutGlobStar = remain.slice(1)
+  var gspref = prefix ? [ prefix ] : []
+  var noGlobStar = gspref.concat(remainWithoutGlobStar)
+
+  // the noGlobStar pattern exits the inGlobStar state
+  this._process(noGlobStar, index, false)
+
+  var len = entries.length
+  var isSym = this.symlinks[abs]
+
+  // If it's a symlink, and we're in a globstar, then stop
+  if (isSym && inGlobStar)
+    return
+
+  for (var i = 0; i < len; i++) {
+    var e = entries[i]
+    if (e.charAt(0) === '.' && !this.dot)
+      continue
+
+    // these two cases enter the inGlobStar state
+    var instead = gspref.concat(entries[i], remainWithoutGlobStar)
+    this._process(instead, index, true)
+
+    var below = gspref.concat(entries[i], remain)
+    this._process(below, index, true)
+  }
+}
+
+GlobSync.prototype._processSimple = function (prefix, index) {
+  // XXX review this.  Shouldn't it be doing the mounting etc
+  // before doing stat?  kinda weird?
+  var exists = this._stat(prefix)
+
+  if (!this.matches[index])
+    this.matches[index] = Object.create(null)
+
+  // If it doesn't exist, then just mark the lack of results
+  if (!exists)
+    return
+
+  if (prefix && isAbsolute(prefix) && !this.nomount) {
+    var trail = /[\/\\]$/.test(prefix)
+    if (prefix.charAt(0) === '/') {
+      prefix = path.join(this.root, prefix)
+    } else {
+      prefix = path.resolve(this.root, prefix)
+      if (trail)
+        prefix += '/'
+    }
+  }
+
+  if (process.platform === 'win32')
+    prefix = prefix.replace(/\\/g, '/')
+
+  // Mark this as a match
+  this.matches[index][prefix] = true
+}
+
+// Returns either 'DIR', 'FILE', or false
+GlobSync.prototype._stat = function (f) {
+  var abs = this._makeAbs(f)
+  var needDir = f.slice(-1) === '/'
+
+  if (f.length > this.maxLength)
+    return false
+
+  if (!this.stat && ownProp(this.cache, abs)) {
+    var c = this.cache[abs]
+
+    if (Array.isArray(c))
+      c = 'DIR'
+
+    // It exists, but maybe not how we need it
+    if (!needDir || c === 'DIR')
+      return c
+
+    if (needDir && c === 'FILE')
+      return false
+
+    // otherwise we have to stat, because maybe c=true
+    // if we know it exists, but not what it is.
+  }
+
+  var exists
+  var stat = this.statCache[abs]
+  if (!stat) {
+    var lstat
+    try {
+      lstat = fs.lstatSync(abs)
+    } catch (er) {
+      return false
+    }
+
+    if (lstat.isSymbolicLink()) {
+      try {
+        stat = fs.statSync(abs)
+      } catch (er) {
+        stat = lstat
+      }
+    } else {
+      stat = lstat
+    }
+  }
+
+  this.statCache[abs] = stat
+
+  var c = stat.isDirectory() ? 'DIR' : 'FILE'
+  this.cache[abs] = this.cache[abs] || c
+
+  if (needDir && c !== 'DIR')
+    return false
+
+  return c
+}
+
+GlobSync.prototype._mark = function (p) {
+  return common.mark(this, p)
+}
+
+GlobSync.prototype._makeAbs = function (f) {
+  return common.makeAbs(this, f)
+}
diff --git a/tools/node_modules/posix-getopt/LICENSE b/tools/node_modules/posix-getopt/LICENSE
new file mode 100644
index 00000000..280e3364
--- /dev/null
+++ b/tools/node_modules/posix-getopt/LICENSE
@@ -0,0 +1,18 @@
+Copyright (c) 2013, Joyent, Inc. All rights reserved.
+
+Permission is hereby granted, free of charge, to any person obtaining a copy of
+this software and associated documentation files (the "Software"), to deal in
+the Software without restriction, including without limitation the rights to
+use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
+the Software, and to permit persons to whom the Software is furnished to do so,
+subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all
+copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
diff --git a/tools/node_modules/posix-getopt/README.md b/tools/node_modules/posix-getopt/README.md
new file mode 100644
index 00000000..1e1ac426
--- /dev/null
+++ b/tools/node_modules/posix-getopt/README.md
@@ -0,0 +1,359 @@
+
+node-getopt
+==============
+
+Overview
+--------
+
+node-getopt implements the POSIX getopt() function for Node.  getopt() provides
+a functional interface for option parsing.
+
+Install the npm package in the usual way:
+
+	$ npm install posix-getopt
+
+Here's how you'd typically use it for a command that takes options "-a" and
+"-b" with no arguments, option "-o" (also called "--output") with one argument,
+and another mandatory argument:
+
+	var mod_getopt = require('posix-getopt');
+	var parser, option;
+
+	parser = new mod_getopt.BasicParser('abo:(output)', process.argv);
+
+	while ((option = parser.getopt()) !== undefined) {
+		switch (option.option) {
+		case 'a':
+			console.log('option "a" is set');
+			break;
+
+		case 'b':
+			console.log('option "b" is set');
+			break;
+
+		case 'o':
+			console.error('option "o" has value "%s"',
+			    option.optarg);
+			break;
+
+		default:
+			/* error message already emitted by getopt */
+			mod_assert.equal('?', option.option);
+			break;
+		}
+	}
+
+	if (parser.optind() >= process.argv.length)
+		usage('missing required argument: "input"');
+
+	console.log('input = %s', process.argv[parser.optind()]);
+
+Examples:
+
+	$ cmd
+	error: missing required argument: "input"
+	usage: cmd [-ab] [-o file] input
+
+	$ cmd foo
+	input = foo
+
+	$ cmd -a foo
+	option "a" is set
+	input = foo
+
+	$ cmd -ba foo
+	option "b" is set
+	option "a" is set
+	input = foo
+
+	$ cmd -ba -obar foo
+	option "b" is set
+	option "a" is set
+	option "o" has value "bar"
+	input = foo
+
+	$ cmd -ba --output=bar foo
+	option "b" is set
+	option "a" is set
+	option "o" has value "bar"
+	input = foo
+
+	$ cmd --output= foo
+	option "o" has value ""
+	input = foo
+
+	$ cmd -o 
+	option requires an argument -- o
+	error: missing required argument: "input"
+	usage: cmd [-ab] [-o file] input
+
+	$ cmd -- -a
+	input = -a
+
+	$ cmd -q
+	illegal option -- q
+	error: missing required argument: "input"
+	usage: cmd [-ab] [-o file] input
+
+
+Background
+--------
+
+getopt() is a general-purpose command line parser that follows the POSIX
+guidelines for command-line utilities.  Using these guidelines encourages
+common conventions among applications, including use of:
+
+- short option names (e.g., "-r")
+- options with arguments (e.g., "-f filename or -ffilename")
+- chaining short option names when options have no arguments (e.g., "-ra")
+
+This implementation mirrors the Solaris getopt() implementation and supports
+long option names (e.g., "--recurse"), potentially with values specified using
+"=" (e.g., "--file=/path/to/file").
+
+Unlike other option parsers available for Node.js, the POSIX getopt() interface
+supports using the same option multiple times (e.g., "-vvv", commonly used to
+indicate level of verbosity).
+
+For further reference on the relevant POSIX standards, see the following:
+
+    http://pubs.opengroup.org/onlinepubs/009695399/functions/getopt.html
+    http://pubs.opengroup.org/onlinepubs/009695399/utilities/getopts.html
+
+The Utility Syntax Guidelines are described here:
+
+    http://pubs.opengroup.org/onlinepubs/009695399/basedefs/xbd_chap12.html
+
+
+Status
+------
+
+This module is considered complete except that there's minimal automated test
+coverage.  There are no known bugs.
+
+
+API
+---
+
+### `new getopt.BasicParser(optstring, argv[, optind])`
+
+Instantiates a new object for parsing the specified arguments using the
+specified option string.  This interface is closest to the traditional getopt()
+C function.  Callers first instantiate a BasicParser and then invoke the
+getopt() method to iterate the options as they would in C.  (This interface
+allows the same option to be specified multiple times.)  The optional 3rd
+argument to the constructor `optind` is the number of arguments from `argv` to
+skip.  By default `optind` is set to `2`, so the first two arguments in `argv`
+are ignored, since they generally denote the path to the node executable and
+the script being run.
+
+The option string consists of an optional leading ":" (see below) followed by a
+sequence of option-specifiers.  Each option-specifier consists of a single
+character denoting the short option name, optionally followed by a colon if the
+option takes an argument and/or a sequence of strings in parentheses
+representing long-option aliases for the option name.
+
+Example option strings:
+
+	':r'            Command takes one option with no args: -r
+	':ra'           Command takes two option with no args: -r and -a
+	':raf:'         Command takes two option with no args: -r and -a
+	                and a single option that takes an arg: -f
+	':f:(file)'     Command takes a single option with an argument: -f
+	                -f can also be specified as --file
+
+The presence of a leading colon in the option string determines the behavior
+when an argument is not specified for an option which takes an argument.  See
+getopt() below.  Additionally, if no colon is specified, then error messages are
+printed to stderr when invalid options, options with missing arguments, or
+options with unexpected arguments are encountered.
+
+
+### `parser.optind()`
+
+Returns the next argv-argument to be parsed.  When options are specified as
+separate "argv" arguments, this value is incremented with each option parsed.
+When multiple options are specified in the same argv-argument, the returned
+value is unspecified.  This matches the variable "OPTIND" from the POSIX
+standard, but is read-only.  (If you want to reset OPTIND, you must create a new
+BasicParser instance.)  This is most useful after parsing has finished to
+examine the non-option arguments.
+
+This value starts at "2" as described under "Departures from POSIX" below.
+
+
+### `parser.getopt()`
+
+Returns the next argument specified in "argv" (the object's constructor
+argument).  The returned value is either undefined or an object with at least
+the following members:
+
+	option		single-character option name
+
+The following members may also be present:
+
+	optarg		argument value, if any
+
+	optopt		option character that caused the error, if any
+
+	error		if true, this object represents an error
+
+This function scans "argv" starting at the current value of "optind" and returns
+an object describing the next argument based on the following cases:
+
+- If the end of command line arguments is reached, an undefined value is
+  returned.  The end of arguments is signified by a single '-' argument, a
+  single '--' argument, an argument that's neither an option nor a previous
+  option's argument, the end of argv, or an error.
+
+- If an unrecognized command line option is found (i.e. an option character
+  not defined in "optstring"), the returned object's "option" member
+  is just "?".  "optopt" is set to the unrecognized option letter.  "error"
+  is set to a true value.
+
+- If a known command line option is found and the option takes no arguments
+  then the returned object's "option" member is the option's short name
+  (i.e.  the single character specifier in "optstring").
+      
+- If a known command line option is found and that option takes an argument
+  and the argument is also found, then the returned object's "option"
+  member is the option's short name and the "optarg" member contains the
+  argument's value.
+
+- If a known command line option is found and that option takes an argument
+  but the argument is not found, then the returned object's "option" member
+  is "?" unless the first character of "optstring" was a colon, in which
+  case the "option" member is set to ":".  Either way, the "optopt" member
+  is set to the option character that caused the error and "error" is set to
+  a true value.
+
+
+Departures from POSIX
+--------
+
+- Global state in the C implementation (e.g., optind, optarg, and optopt) is
+  encapsulated in the BasicParser object.  optind is available as a method
+  call on the parser object.  optarg and optopt are returned directly by
+  getopt().
+
+- Rather than returning an integer or character, getopt() returns an object
+  with the "option" field corresponding to the processed option character
+  and possibly the additional "optarg" and "optopt" fields.  If an error
+  occurs on a particular option, "error" is also set.  If an error occurs on
+  no particular option or if the end of input is encountered, undefined is
+  returned.
+
+- Long option forms are supported as described above.  This introduces an
+  additional error case which is where an argument of the form
+  --option=value is encountered, where "option" does not take a value.
+
+- POSIX starts "optind" at 1, since argv[0] is generally the name of the
+  command and options start at argv[1].  This implementation starts "optind"
+  at 2, since argv[0] is generally the path to the node binary and argv[1]
+  is the path to the script, so options start with argv[2].
+
+
+Examples
+--------
+
+### Example 1: simple short options
+
+	var mod_getopt = require('getopt')
+	var parser, option;
+	
+	parser = new mod_getopt.BasicParser('la',
+	    ['node', 'script', '-l', '-a', 'stuff']);
+	while ((option = parser.getopt()) !== undefined && !option.error)
+		console.error(option);
+
+outputs:
+
+	{ option: 'l' }
+	{ option: 'a' }
+
+
+### Example 2: invalid option specified
+
+	var mod_getopt = require('getopt')
+	var parser, option;
+	
+	parser = new mod_getopt.BasicParser('la',
+	    ['node', 'script', '-l', '-b', 'stuff']);
+	while ((option = parser.getopt()) !== undefined && !option.error)
+		console.error(option);
+	console.error(option);
+
+outputs:
+
+	{ option: 'l' }
+	illegal option -- b
+	{ option: '?', optopt: 'b', error: true }
+
+
+### Example 3: long options
+
+	var mod_getopt = require('getopt')
+	var parser, option;
+	
+	parser = new mod_getopt.BasicParser('lar(recurse)',
+	    ['node', 'script', '-l', '--recurse', 'stuff']);
+	while ((option = parser.getopt()) !== undefined && !option.error)
+		console.error(option);
+
+outputs:
+
+	{ option: 'l' }
+	{ option: 'r' }
+
+
+### Example 4: options with arguments
+
+	var mod_getopt = require('getopt')
+	var parser, option;
+	
+	parser = new mod_getopt.BasicParser('f:lad:',
+	    ['node', 'script', '-l', '-f', 'filename', '-dtype', 'stuff']);
+	while ((option = parser.getopt()) !== undefined && !option.error)
+		console.error(option);
+
+outputs:
+
+	{ option: 'l' }
+	{ option: 'f', optarg: 'filename' }
+	{ option: 'd', optarg: 'type' }
+
+
+### Example 5: options with missing arguments
+
+	var mod_getopt = require('getopt')
+	var parser, option;
+	
+	parser = new mod_getopt.BasicParser('f:la',
+	    ['node', 'script', '-l', '-a', '-f']);
+	while ((option = parser.getopt()) !== undefined && !option.error)
+		console.error(option);
+	console.error(option);
+
+outputs:
+
+	{ option: 'l' }
+	{ option: 'a' }
+	option requires an argument -- f
+	{ option: '?', optopt: 'f', error: true }
+
+
+### Example 6: options specified multiple times
+
+	var mod_getopt = require('getopt')
+	var parser, option;
+	
+	parser = new mod_getopt.BasicParser('la',
+	    ['node', 'script', '-l', '-a', '-l']);
+	while ((option = parser.getopt()) !== undefined && !option.error)
+		console.error(option);
+
+outputs:
+
+	{ option: 'l' }
+	{ option: 'a' }
+	{ option: 'l' }
diff --git a/tools/node_modules/posix-getopt/examples/basic.js b/tools/node_modules/posix-getopt/examples/basic.js
new file mode 100644
index 00000000..90d4a62d
--- /dev/null
+++ b/tools/node_modules/posix-getopt/examples/basic.js
@@ -0,0 +1,72 @@
+/*
+ * examples/basic.js: basic example of using node-getopt
+ *
+ * This example parses options for an example command that takes options "a" and
+ * "b" having no arguments, option "o" (with long alias "output") which takes a
+ * mandatory value, and then one mandatory argument.  Example valid invocations:
+ *
+ *	cmd foo
+ *      cmd -a foo
+ *      cmd -ab foo
+ *      cmd -a -o bar foo
+ *      cmd -o bar foo
+ *      cmd --output bar foo
+ *      cmd --output=bar foo
+ *      cmd --output= foo
+ *      cmd -- -a		(note: "-a" option is NOT set in this case)
+ *
+ * Invalid invocations:
+ *
+ *      cmd		missing mandatory argument
+ *      cmd -o		option "-o" requires an argument
+ *      cmd -q		unknown option "-q"
+ */
+
+var mod_assert = require('assert');
+var mod_getopt = require('..');
+
+function main()
+{
+	var parser, option;
+
+	parser = new mod_getopt.BasicParser('abo:(output)', process.argv);
+
+	while ((option = parser.getopt()) !== undefined) {
+		switch (option.option) {
+		case 'a':
+			console.log('option "a" is set');
+			break;
+
+		case 'b':
+			console.log('option "b" is set');
+			break;
+
+		case 'o':
+			console.error('option "o" has value "%s"',
+			    option.optarg);
+			break;
+
+		default:
+			/* error message already emitted by getopt */
+			mod_assert.equal('?', option.option);
+			break;
+		}
+	}
+
+	if (parser.optind() >= process.argv.length)
+		usage('missing required argument: "input"');
+
+	console.log('input = %s', process.argv[parser.optind()]);
+}
+
+function usage(message)
+{
+	if (message)
+		console.error('error: %s', message);
+
+	console.error('usage: %s %s [-ab] [-o file] input',
+	    process.argv[0], process.argv[1]);
+	process.exit(2);
+}
+
+main();
diff --git a/tools/node_modules/posix-getopt/examples/examples.js b/tools/node_modules/posix-getopt/examples/examples.js
new file mode 100644
index 00000000..59be1467
--- /dev/null
+++ b/tools/node_modules/posix-getopt/examples/examples.js
@@ -0,0 +1,40 @@
+var mod_getopt = require('..');
+var parser, option;
+
+console.error('Example 1: simple short options');
+parser = new mod_getopt.BasicParser('la',
+    ['node', 'script', '-l', '-a', 'stuff']);
+while ((option = parser.getopt()) !== undefined && !option.error)
+	console.error(option);
+
+console.error('Example 2: invalid option specified');
+parser = new mod_getopt.BasicParser('la',
+    ['node', 'script', '-l', '-b', 'stuff']);
+while ((option = parser.getopt()) !== undefined && !option.error)
+	console.error(option);
+console.error(option);
+
+console.error('Example 3: long options');
+parser = new mod_getopt.BasicParser('lar(recurse)',
+    ['node', 'script', '-l', '--recurse', 'stuff']);
+while ((option = parser.getopt()) !== undefined && !option.error)
+	console.error(option);
+
+console.error('Example 4: options with arguments');
+parser = new mod_getopt.BasicParser('f:lad:',
+    ['node', 'script', '-l', '-f', 'filename', '-dtype', 'stuff']);
+while ((option = parser.getopt()) !== undefined && !option.error)
+	console.error(option);
+
+console.error('Example 5: options with missing arguments');
+parser = new mod_getopt.BasicParser('f:la',
+    ['node', 'script', '-l', '-a', '-f']);
+while ((option = parser.getopt()) !== undefined && !option.error)
+	console.error(option);
+console.error(option);
+
+console.error('Example 6: options specified multiple times');
+parser = new mod_getopt.BasicParser('la',
+    ['node', 'script', '-l', '-a', '-l']);
+while ((option = parser.getopt()) !== undefined && !option.error)
+	console.error(option);
diff --git a/tools/node_modules/posix-getopt/lib/getopt.js b/tools/node_modules/posix-getopt/lib/getopt.js
new file mode 100644
index 00000000..15525ba6
--- /dev/null
+++ b/tools/node_modules/posix-getopt/lib/getopt.js
@@ -0,0 +1,305 @@
+/*
+ * getopt.js: node.js implementation of POSIX getopt() (and then some)
+ *
+ * Copyright 2011 David Pacheco. All rights reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+
+var ASSERT = require('assert').ok;
+
+function goError(msg)
+{
+	return (new Error('getopt: ' + msg));
+}
+
+/*
+ * The BasicParser is our primary interface to the outside world.  The
+ * documentation for this object and its public methods is contained in
+ * the included README.md.
+ */
+function goBasicParser(optstring, argv, optind)
+{
+	var ii;
+
+	ASSERT(optstring || optstring === '', 'optstring is required');
+	ASSERT(optstring.constructor === String, 'optstring must be a string');
+	ASSERT(argv, 'argv is required');
+	ASSERT(argv.constructor === Array, 'argv must be an array');
+
+	this.gop_argv = new Array(argv.length);
+	this.gop_options = {};
+	this.gop_aliases = {};
+	this.gop_optind = optind !== undefined ? optind : 2;
+	this.gop_subind = 0;
+
+	for (ii = 0; ii < argv.length; ii++) {
+		ASSERT(argv[ii].constructor === String,
+		    'argv must be string array');
+		this.gop_argv[ii] = argv[ii];
+	}
+
+	this.parseOptstr(optstring);
+}
+
+exports.BasicParser = goBasicParser;
+
+/*
+ * Parse the option string and update the following fields:
+ *
+ *	gop_silent	Whether to log errors to stderr.  Silent mode is
+ *			indicated by a leading ':' in the option string.
+ *
+ *	gop_options	Maps valid single-letter-options to booleans indicating
+ *			whether each option is required.
+ *
+ *	gop_aliases	Maps valid long options to the corresponding
+ *			single-letter short option.
+ */
+goBasicParser.prototype.parseOptstr = function (optstr)
+{
+	var chr, cp, alias, arg, ii;
+
+	ii = 0;
+	if (optstr.length > 0 && optstr[0] == ':') {
+		this.gop_silent = true;
+		ii++;
+	} else {
+		this.gop_silent = false;
+	}
+
+	while (ii < optstr.length) {
+		chr = optstr[ii];
+		arg = false;
+
+		if (!/^[\w\d\u1000-\u1100]$/.test(chr))
+			throw (goError('invalid optstring: only alphanumeric ' +
+			    'characters and unicode characters between ' +
+			    '\\u1000-\\u1100 may be used as options: ' + chr));
+
+		if (ii + 1 < optstr.length && optstr[ii + 1] == ':') {
+			arg = true;
+			ii++;
+		}
+
+		this.gop_options[chr] = arg;
+
+		while (ii + 1 < optstr.length && optstr[ii + 1] == '(') {
+			ii++;
+			cp = optstr.indexOf(')', ii + 1);
+			if (cp == -1)
+				throw (goError('invalid optstring: missing ' +
+				    '")" to match "(" at char ' + ii));
+
+			alias = optstr.substring(ii + 1, cp);
+			this.gop_aliases[alias] = chr;
+			ii = cp;
+		}
+
+		ii++;
+	}
+};
+
+goBasicParser.prototype.optind = function ()
+{
+	return (this.gop_optind);
+};
+
+/*
+ * For documentation on what getopt() does, see README.md.  The following
+ * implementation invariants are maintained by getopt() and its helper methods:
+ *
+ *	this.gop_optind		Refers to the element of gop_argv that contains
+ *				the next argument to be processed.  This may
+ *				exceed gop_argv, in which case the end of input
+ *				has been reached.
+ *
+ *	this.gop_subind		Refers to the character inside
+ *				this.gop_options[this.gop_optind] which begins
+ *				the next option to be processed.  This may never
+ *				exceed the length of gop_argv[gop_optind], so
+ *				when incrementing this value we must always
+ *				check if we should instead increment optind and
+ *				reset subind to 0.
+ *
+ * That is, when any of these functions is entered, the above indices' values
+ * are as described above.  getopt() itself and getoptArgument() may both be
+ * called at the end of the input, so they check whether optind exceeds
+ * argv.length.  getoptShort() and getoptLong() are called only when the indices
+ * already point to a valid short or long option, respectively.
+ *
+ * getopt() processes the next option as follows:
+ *
+ *	o If gop_optind > gop_argv.length, then we already parsed all arguments.
+ *
+ *	o If gop_subind == 0, then we're looking at the start of an argument:
+ *
+ *	    o Check for special cases like '-', '--', and non-option arguments.
+ *	      If present, update the indices and return the appropriate value.
+ *
+ *	    o Check for a long-form option (beginning with '--').  If present,
+ *	      delegate to getoptLong() and return the result.
+ *
+ *	    o Otherwise, advance subind past the argument's leading '-' and
+ *	      continue as though gop_subind != 0 (since that's now the case).
+ *
+ *	o Delegate to getoptShort() and return the result.
+ */
+goBasicParser.prototype.getopt = function ()
+{
+	if (this.gop_optind >= this.gop_argv.length)
+		/* end of input */
+		return (undefined);
+
+	var arg = this.gop_argv[this.gop_optind];
+
+	if (this.gop_subind === 0) {
+		if (arg == '-' || arg === '' || arg[0] != '-')
+			return (undefined);
+
+		if (arg == '--') {
+			this.gop_optind++;
+			this.gop_subind = 0;
+			return (undefined);
+		}
+
+		if (arg[1] == '-')
+			return (this.getoptLong());
+
+		this.gop_subind++;
+		ASSERT(this.gop_subind < arg.length);
+	}
+
+	return (this.getoptShort());
+};
+
+/*
+ * Implements getopt() for the case where optind/subind point to a short option.
+ */
+goBasicParser.prototype.getoptShort = function ()
+{
+	var arg, chr;
+
+	ASSERT(this.gop_optind < this.gop_argv.length);
+	arg = this.gop_argv[this.gop_optind];
+	ASSERT(this.gop_subind < arg.length);
+	chr = arg[this.gop_subind];
+
+	if (++this.gop_subind >= arg.length) {
+		this.gop_optind++;
+		this.gop_subind = 0;
+	}
+
+	if (!(chr in this.gop_options))
+		return (this.errInvalidOption(chr));
+
+	if (!this.gop_options[chr])
+		return ({ option: chr });
+
+	return (this.getoptArgument(chr));
+};
+
+/*
+ * Implements getopt() for the case where optind/subind point to a long option.
+ */
+goBasicParser.prototype.getoptLong = function ()
+{
+	var arg, alias, chr, eq;
+
+	ASSERT(this.gop_subind === 0);
+	ASSERT(this.gop_optind < this.gop_argv.length);
+	arg = this.gop_argv[this.gop_optind];
+	ASSERT(arg.length > 2 && arg[0] == '-' && arg[1] == '-');
+
+	eq = arg.indexOf('=');
+	alias = arg.substring(2, eq == -1 ? arg.length : eq);
+	if (!(alias in this.gop_aliases))
+		return (this.errInvalidOption(alias));
+
+	chr = this.gop_aliases[alias];
+	ASSERT(chr in this.gop_options);
+
+	if (!this.gop_options[chr]) {
+		if (eq != -1)
+			return (this.errExtraArg(alias));
+
+		this.gop_optind++; /* eat this argument */
+		return ({ option: chr });
+	}
+
+	/*
+	 * Advance optind/subind for the argument value and retrieve it.
+	 */
+	if (eq == -1)
+		this.gop_optind++;
+	else
+		this.gop_subind = eq + 1;
+
+	return (this.getoptArgument(chr));
+};
+
+/*
+ * For the given option letter 'chr' that takes an argument, assumes that
+ * optind/subind point to the argument (or denote the end of input) and return
+ * the appropriate getopt() return value for this option and argument (or return
+ * the appropriate error).
+ */
+goBasicParser.prototype.getoptArgument = function (chr)
+{
+	var arg;
+
+	if (this.gop_optind >= this.gop_argv.length)
+		return (this.errMissingArg(chr));
+
+	arg = this.gop_argv[this.gop_optind].substring(this.gop_subind);
+	this.gop_optind++;
+	this.gop_subind = 0;
+	return ({ option: chr, optarg: arg });
+};
+
+goBasicParser.prototype.errMissingArg = function (chr)
+{
+	if (this.gop_silent)
+		return ({ option: ':', optopt: chr });
+
+	process.stderr.write('option requires an argument -- ' + chr + '\n');
+	return ({ option: '?', optopt: chr, error: true });
+};
+
+goBasicParser.prototype.errInvalidOption = function (chr)
+{
+	if (!this.gop_silent)
+		process.stderr.write('illegal option -- ' + chr + '\n');
+
+	return ({ option: '?', optopt: chr, error: true });
+};
+
+/*
+ * This error is not specified by POSIX, but neither is the notion of specifying
+ * long option arguments using "=" in the same argv-argument, but it's common
+ * practice and pretty convenient.
+ */
+goBasicParser.prototype.errExtraArg = function (chr)
+{
+	if (!this.gop_silent)
+		process.stderr.write('option expects no argument -- ' +
+		    chr + '\n');
+
+	return ({ option: '?', optopt: chr, error: true });
+};
diff --git a/tools/node_modules/posix-getopt/package.json b/tools/node_modules/posix-getopt/package.json
new file mode 100644
index 00000000..bc7c595c
--- /dev/null
+++ b/tools/node_modules/posix-getopt/package.json
@@ -0,0 +1,41 @@
+{
+  "author": {
+    "name": "Dave Pacheco",
+    "url": "dap@cs.brown.edu"
+  },
+  "bugs": {
+    "url": "https://github.com/davepacheco/node-getopt/issues"
+  },
+  "dependencies": {},
+  "description": "POSIX-style getopt()",
+  "devDependencies": {},
+  "directories": {},
+  "dist": {
+    "shasum": "4aeeeb7dade66fca8a9365dda9f6b005741cb621",
+    "tarball": "https://registry.npmjs.org/posix-getopt/-/posix-getopt-1.2.0.tgz"
+  },
+  "engines": {
+    "node": "*"
+  },
+  "gitHead": "e90fa0e92b35ea9150428de29ae3ff56a716ca85",
+  "homepage": "https://github.com/davepacheco/node-getopt",
+  "license": "MIT",
+  "main": "./lib/getopt",
+  "maintainers": [
+    {
+      "name": "dap",
+      "email": "dap@cs.brown.edu"
+    }
+  ],
+  "name": "posix-getopt",
+  "optionalDependencies": {},
+  "readme": "ERROR: No README data found!",
+  "repository": {
+    "type": "git",
+    "url": "git://github.com/davepacheco/node-getopt.git"
+  },
+  "scripts": {
+    "test": "for f in tests/*.js; do echo \"$f\"; node \"$f\" || exit 1; done"
+  },
+  "version": "1.2.0"
+}
\ No newline at end of file
diff --git a/tools/node_modules/posix-getopt/tests/test-getopt.js b/tools/node_modules/posix-getopt/tests/test-getopt.js
new file mode 100644
index 00000000..ad32c7fa
--- /dev/null
+++ b/tools/node_modules/posix-getopt/tests/test-getopt.js
@@ -0,0 +1,100 @@
+/*
+ * Tests getopt() itself.
+ */
+var mod_getopt = require('..');
+var mod_assert = require('assert');
+
+var test_cases = [ {
+	optstr: '',
+	argv: [],
+	result: []
+}, {
+	optstr: ':',
+	argv: [],
+	result: []
+}, {
+	optstr: ':l',
+	argv: [],
+	result: []
+}, {
+	optstr: ':l:',
+	argv: [],
+	result: []
+}, {
+	optstr: ':las',
+	argv: [],
+	result: []
+}, {
+	optstr: ':l:a:s:',
+	argv: [],
+	result: []
+}, {
+	optstr: ':l(long)',
+	argv: [],
+	result: []
+}, {
+	optstr: ':l:(long)',
+	argv: ['cmd', 'script', '-l', 'arg1', '--long=q', 'b', '--long', 'foo'],
+	result: [
+	    { option: 'l', optarg: 'arg1' },
+	    { option: 'l', optarg: 'q' }
+	]
+}, {
+	optstr: 'l:(long)(longer)',
+	argv: [],
+	result: []
+}, {
+	optstr: ':la:r(recurse)(recur)f:(file)(filename)q',
+	argv: [],
+	result: []
+}, {
+	optstr: '\u1000(help)\u1001(version)',
+	argv: ['cmd', 'script', '--help' ],
+	result: [
+	   { option: '\u1000' },
+	]
+}, {
+	optstr: '\u1000(help)\u1001(version)',
+	argv: ['cmd', 'script', '--version' ],
+	result: [
+	   { option: '\u1001' },
+	]
+}, {
+	optstr: '\u1000:(parallel)',
+	argv: ['cmd', 'script', '--parallel=100' ],
+	result: [
+	   { option: '\u1000', optarg: 100 },
+	]
+}, {
+	optstr: 'h',
+	argv: ['-h'],
+	result: [
+	   { option: 'h' },
+	],
+        optind: 0
+}, {
+	optstr: 'hv',
+	argv: ['foo', '-h', '-v' ],
+	result: [
+	   { option: 'h' },
+	   { option: 'v' },
+	],
+        optind: 1
+}];
+
+var parser, ii, arg, result;
+for (ii = 0; ii < test_cases.length; ii++) {
+	console.log('test case %s: "%s" with argv = "%s"', ii + 1,
+	    test_cases[ii].optstr, test_cases[ii].argv);
+	parser = new mod_getopt.BasicParser(test_cases[ii].optstr,
+	    test_cases[ii].argv, test_cases[ii].optind);
+	console.log(parser.gop_tokens);
+
+	result = [];
+	while ((arg = parser.getopt()) !== undefined)
+		result.push(arg);
+
+	mod_assert.deepEqual(test_cases[ii].result, result);
+}
+
+console.log('%s test cases passed', test_cases.length);
diff --git a/tools/node_modules/posix-getopt/tests/test-tokenize-optstr.js b/tools/node_modules/posix-getopt/tests/test-tokenize-optstr.js
new file mode 100644
index 00000000..60c10c66
--- /dev/null
+++ b/tools/node_modules/posix-getopt/tests/test-tokenize-optstr.js
@@ -0,0 +1,73 @@
+/*
+ * Tests internal state of the parser.
+ */
+var mod_path = require('path');
+
+var mod_sys = require('sys');
+var mod_getopt = require('..');
+var mod_assert = require('assert');
+
+var test_cases = [ {
+	optstr: '',
+	silent: false,
+	options: {},
+	aliases: {},
+}, {
+	optstr: ':',
+	silent: true,
+	options: {},
+	aliases: {},
+}, {
+	optstr: ':l',
+	silent: true,
+	options: { l: false },
+	aliases: {},
+}, {
+	optstr: ':l:',
+	silent: true,
+	options: { l: true },
+	aliases: {},
+}, {
+	optstr: ':las',
+	silent: true,
+	options: { l: false, a: false, s: false },
+	aliases: {},
+}, {
+	optstr: ':l:a:s:',
+	silent: true,
+	options: { l: true, a: true, s: true },
+	aliases: {},
+}, {
+	optstr: ':l(long)',
+	silent: true,
+	options: { l: false },
+	aliases: { long: 'l' },
+}, {
+	optstr: ':l:(long)',
+	silent: true,
+	options: { l: true },
+	aliases: { long: 'l' },
+}, {
+	optstr: 'l:(long)(longer)',
+	silent: false,
+	options: { l: true },
+	aliases: { long: 'l', longer: 'l' },
+}, {
+	optstr: ':la:r(recurse)(recur)f:(file)(filename)q',
+	silent: true,
+	options: { l: false, a: true, r: false, f: true, q: false },
+	aliases: { recurse: 'r', recur: 'r', file: 'f', filename: 'f' }
+} ];
+
+var parser, ii;
+for (ii = 0; ii < test_cases.length; ii++) {
+	console.log('test case %s: "%s"', ii + 1, test_cases[ii].optstr);
+	parser = new mod_getopt.BasicParser(test_cases[ii].optstr, []);
+	mod_assert.ok(test_cases[ii].silent === parser.gop_silent);
+	mod_assert.deepEqual(test_cases[ii].options,
+	    parser.gop_options);
+	mod_assert.deepEqual(test_cases[ii].aliases,
+	    parser.gop_aliases);
+}
+
+console.log('%s test cases passed', test_cases.length);
