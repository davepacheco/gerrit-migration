From d2d7940e33196adc3e4116d61c4d012be9eee1fd Mon Sep 17 00:00:00 2001
From: Kody A Kantor <kody.kantor@gmail.com>
Date: Fri, 21 Jul 2017 18:46:42 +0000
Subject: [PATCH] joyent/node-artedi#3 Support Prometheus-style counters and
 histograms

---
 .gitignore                  |   1 +
 .gitmodules                 |   3 +
 Makefile                    |  39 +--
 README.adoc                 |  31 ---
 README.md                   |  94 ++++++-
 deps/restdown               |   1 +
 docs/API.md                 | 183 +++++++++++++
 docs/DESIGN.md              | 458 +++++++++++++++++++++++++++++++
 docs/api.adoc               |   9 -
 docs/index.adoc             |  11 -
 docs/private_api.md         | 197 ++++++++++++++
 lib/collector.js            | 247 +++++++++++++++++
 lib/{index.js => common.js} |   8 +
 lib/counter.js              | 102 +++++++
 lib/gauge.js                |  88 ++++++
 lib/histogram.js            | 328 ++++++++++++++++++++++
 lib/metric.js               |  42 +++
 lib/metric_vector.js        | 162 +++++++++++
 lib/utils.js                | 138 ++++++++++
 package.json                |  33 +--
 test/basic.test.js          | 525 +++++++++++++++++++++++++++++++++++-
 tools/bashstyle             | 164 -----------
 tools/eslint.node.conf      |  17 ++
 tools/jsstyle.conf          |   5 +-
 tools/mk/Makefile.targ      |  11 +-
 tools/update-ghdocs         |  50 ----
 26 files changed, 2631 insertions(+), 316 deletions(-)
 delete mode 100644 README.adoc
 create mode 160000 deps/restdown
 create mode 100644 docs/API.md
 create mode 100644 docs/DESIGN.md
 delete mode 100644 docs/api.adoc
 delete mode 100644 docs/index.adoc
 create mode 100644 docs/private_api.md
 create mode 100644 lib/collector.js
 rename lib/{index.js => common.js} (58%)
 create mode 100644 lib/counter.js
 create mode 100644 lib/gauge.js
 create mode 100644 lib/histogram.js
 create mode 100644 lib/metric.js
 create mode 100644 lib/metric_vector.js
 create mode 100644 lib/utils.js
 delete mode 100644 tools/bashstyle
 create mode 100644 tools/eslint.node.conf
 delete mode 100755 tools/update-ghdocs

diff --git a/.gitignore b/.gitignore
index c817bc7..4cdb8ee 100644
--- a/.gitignore
+++ b/.gitignore
@@ -1,2 +1,3 @@
 node_modules/
 docs/*.html
+build/
diff --git a/.gitmodules b/.gitmodules
index 62eb074..9254389 100644
--- a/.gitmodules
+++ b/.gitmodules
@@ -4,3 +4,6 @@
 [submodule "deps/jsstyle"]
 	path = deps/jsstyle
 	url = https://github.com/davepacheco/jsstyle.git
+[submodule "deps/restdown"]
+	path = deps/restdown
+	url = https://github.com/trentm/restdown.git
diff --git a/Makefile b/Makefile
index 6392c48..f54e2a9 100644
--- a/Makefile
+++ b/Makefile
@@ -23,9 +23,7 @@ include ./tools/mk/Makefile.defs
 # Configuration used by Makefile.defs and Makefile.targ to generate
 # "check" and "docs" targets.
 #
-DOC_SRCFILES	 = index.adoc
-DOC_ASSETS	 =
-
+DOC_FILES	 = README.md
 JSON_FILES	 = package.json
 JS_FILES	:= $(shell find lib test -name '*.js')
 JSL_FILES_NODE	 = $(JS_FILES)
@@ -33,44 +31,47 @@ JSSTYLE_FILES	 = $(JS_FILES)
 
 JSL_CONF_NODE	 = tools/jsl.node.conf
 JSSTYLE_FLAGS	 = -f tools/jsstyle.conf
+ESLINT		:= ./node_modules/.bin/eslint
+ESLINT_CONF	:= tools/eslint.node.conf
+ESLINT_FILES	:= $(JS_FILES)
 
-include ./tools/mk/Makefile.defs
 include ./tools/mk/Makefile.node_deps.defs
 
 #
 # Repo-specific targets
 #
 .PHONY: all
-all: $(SMF_MANIFESTS) | $(TAP) $(REPO_DEPS)
+all: $(TAP) $(REPO_DEPS)
 	$(NPM) rebuild
 
 $(TAP): | $(NPM_EXEC)
 	$(NPM) install
+
 $(JSON): | $(NPM_EXEC)
 	$(NPM) install
 
-CLEAN_FILES += $(TAP) ./node_modules/tap
+CLEAN_FILES += ./node_modules
 
 .PHONY: test
 test: $(TAP)
 	TAP=1 $(TAP) test/*.test.js
 
-.PHONY: coverage
-coverage: all
-	$(NPM_EXEC) install istanbul && \
-	    ./node_modules/.bin/istanbul cover \
-	    $(TAP) test/*.js
+# Before running the 'check' target, we first make sure the 'json' tool is
+# installed locally.
+check:: $(JSON)
 
-DOC_OUTPUTS	 = $(patsubst %.adoc,docs/%.html,$(DOC_SRCFILES))
-docs/%.html: docs/%.adoc
-	asciidoctor -o $@ -b html5 $<
+#
+# Target definitions.  This is where we include the target Makefiles for
+# the "defs" Makefiles we included above.
+#
 
-docs:: $(DOC_OUTPUTS)
+include ./tools/mk/Makefile.deps
 
-.PHONY: ghdocs
-ghdocs: $(DOC_OUTPUTS) $(DOC_ASSETS)
-	./tools/update-ghdocs $(DOC_OUTPUTS) $(DOC_ASSETS)
+ifeq ($(shell uname -s),SunOS)
+	include ./tools/mk/Makefile.node_prebuilt.targ
+else
+	include ./tools/mk/Makefile.node.targ
+endif
 
-include ./tools/mk/Makefile.deps
 include ./tools/mk/Makefile.node_deps.targ
 include ./tools/mk/Makefile.targ
diff --git a/README.adoc b/README.adoc
deleted file mode 100644
index fd0abd1..0000000
--- a/README.adoc
+++ /dev/null
@@ -1,31 +0,0 @@
-:toc: left
-:source-highlighter: pygments
-:doctype: book
-:idprefix:
-:docinfo:
-
-# artedi
-
-## About
-
-`artedi` is a node.js library for measuring fish -- specifically, the fish
-being the services involved in Manta, the Triton Object Store.
-
-## Installation
-
-```
-npm install artedi
-```
-
-## License
-
-MPL-v2
-
-## Contributing
-
-Contributions should be made via the https://cr.joyent.us[Joyent Gerrit].
-
-## Reading documentation online
-
-You can view the https://joyent.github.io/node-artedi[full API documentation]
-rendered online.
diff --git a/README.md b/README.md
index e94f971..fee42ba 100644
--- a/README.md
+++ b/README.md
@@ -1,12 +1,88 @@
-# artedi
+# node-artedi: client library for metric collection
 
-<!--
-This file is here because npm doesn't support any format except markdown for
-README files. This way people browsing the package on npmjs.com will get a
-link to the documentation instead of nothing.
+## About
+`artedi` is a Node.js library for measuring applications -- specifically, the
+services composing Triton and Manta.
 
-GitHub prefers .adoc files to .md, so it will render the correct README for
-the repository root.
--->
+## Sample Usage
+Here is a simple example usage of counters and histograms to expose
+metrics in the Prometheus v0.0.4 text format.
 
-See the [documentation](https://joyent.github.io/node-artedi).
+```javascript
+var artedi = require('artedi');
+
+// collectors are the 'parent' collector.
+var collector = artedi.createCollector();
+
+// counters are a 'child' collector.
+// This call is idempotent.
+var counter = collector.counter({
+    name: 'http_requests_completed',
+    help: 'count of muskie http requests completed',
+    labels: {
+        zone: ZONENAME
+    }
+});
+
+// Add 1 to the counter with the labels 'method=getobject,code=200'.
+counter.increment({
+    method: 'getobject',
+    code: '200'
+});
+
+collector.collect(artedi.FMT_PROM, function (err, metrics) {
+    console.log(metrics);
+    // Prints:
+    // # HELP http_requests_completed count of muskie http requests completed
+    // # TYPE http_requests_completed counter
+    // http_requests_completed{zone="e5d3",method="getobject",code="200"} 1
+});
+
+var histogram = collector.histogram({
+    name: 'http_request_latency_ms',
+    help: 'latency of muskie http requests'
+});
+
+// Observe a latency of 998ms for a 'putobjectdir' request.
+histogram.observe(998, {
+    method: 'putobjectdir'
+});
+
+// For each bucket, we get a count of the number of requests that fall
+// below or at the latency upper-bound of the bucket.
+// This output is defined by Prometheus.
+collector.collect(artedi.FMT_PROM, function (err, metrics) {
+    if (err) {
+        throw new VError(err, 'could not collect metrics');
+    }
+    console.log(metrics);
+    // Prints:
+    // # HELP http_requests_completed count of muskie http requests completed
+    // # TYPE http_requests_completed counter
+    // http_requests_completed{zone="e5d3",method="getobject",code="200"} 1
+    // # HELP http_request_latency_ms latency of muskie http requests
+    // # TYPE http_request_latency_ms histogram
+    // http_request_latency_ms{le="729"} 0 1499645380000
+    // http_request_latency_ms{le="2187"} 1 1499645380000
+    // http_request_latency_ms{le="3645"} 0 1499645380000
+    // http_request_latency_ms{le="5103"} 0 1499645380000
+    // http_request_latency_ms{le="6561"} 0 1499645380000
+    // http_request_latency_ms{le="+Inf"} 1 1499645380000
+    // http_request_latency_ms_count{} 1 1499645380000
+    // http_request_latency_ms_sum{} 998 1499645380000
+});
+```
+
+For more advanced usage and full API documentation, see
+[docs/API.md](./docs/API.md).
+
+## Installation
+```
+npm install artedi
+```
+
+## License
+MPL-v2
+
+## Contributing
+Contributions should be made via the https://cr.joyent.us[Joyent Gerrit].
diff --git a/deps/restdown b/deps/restdown
new file mode 160000
index 0000000..1b833da
--- /dev/null
+++ b/deps/restdown
@@ -0,0 +1 @@
+Subproject commit 1b833da2199b08c3bc92ef16cf52b0b0d6e4c189
diff --git a/docs/API.md b/docs/API.md
new file mode 100644
index 0000000..3dce5a5
--- /dev/null
+++ b/docs/API.md
@@ -0,0 +1,183 @@
+* [Intro](#intro)
+* [Collector](#collector)
+* [Counter](#counter)
+* [Gauge](#gauge)
+* [Absolute Gauge](#absolutegauge)
+* [Histogram](#histogram)
+
+## Intro
+This document contains a description of this library's public-facing API.
+We outline each of the different objects that can be created, and describe
+the functions that can be called on each object.
+
+For information on the private API (for developers), see
+[private API docs](./private_api.md).
+
+## Collector
+A Collector is the 'parent' of all other collector types (Counter, Gauge,
+Histogram). A Collector is what is first created by the user, and then the
+user will create 'child' collectors from their Collector instance.
+
+All of the labels passed to a Collector will be inherited by child collectors.
+
+### artedi.createCollector(opts) : Collector
+Create a new Collector object with the given options (labels are included in
+`opts`). `opts` is optional, and may include a nested 'labels' object.
+
+Example:
+```javascript
+var collector = artedi.createCollector({
+    labels: {
+        hostname: 'myhostname'
+    }
+});
+```
+
+### collector.counter(opts) : Counter
+Create a new Counter object with the given options (incl. labels). This call is
+idempotent. `opts` must include 'help' and 'name' fields, and may optionally
+include a 'labels' object.
+
+Example:
+```javascript
+var counter = collector.counter({
+    name: 'http_requests_completed',
+    help: 'count of http requests completed',
+    labels: {
+        component: 'muskie'
+    }
+});
+```
+### collector.gauge(opts) : Gauge
+Create a new Gauge object with the given options (incl. labels). This call is
+idempotent. `opts` must include 'help' and 'name' fields, and may optionally
+include a 'labels' object.
+
+Example:
+```javascript
+var gauge = collector.gauge({
+    name: 'tcp_connections_available',
+    help: 'count of tcp connections available',
+    labels: {
+        backend: 'myserver'
+    }
+});
+```
+
+### collector.histogram(opts) : Histogram
+Creates a new Histogram object with the given options (incl. labels). This call
+is idempotent. `opts` must include 'help' and 'name' fields, and may optionally
+include a 'labels' object.
+
+Example:
+```javascript
+var histogram = collector.histogram({
+    name: 'http_request_latency_ms',
+    help: 'latency of http requests',
+    labels: {
+        component: 'muskie'
+    }
+});
+```
+
+### collector.collect(format, callback(err, string))
+Iterate through the list of previously-instantiated collectors, calling the
+serialization function corresponding to `format` on each collector.
+
+Valid values for `format` are in the global `artedi` namespace. Currently, the
+valid values are `FMT_PROM` and `FMT_PROM_0_0_4`. `FMT_PROM` will always point
+to the latest supported version of the Prometheus text format. `FMT_PROM_0_0_4`
+represents version 0.0.4 of the Prometheus text format, which is the latest
+supported text format version.
+
+Example:
+```javascript
+collector.collect(artedi.FMT_PROM, function (err, str) {
+    if (err) {
+        throw err;
+    }
+    console.log(str);
+});
+```
+## Counter
+Counters are the most simple of the collector types. They simply count
+up starting from zero. You can either increment a counter, or add
+arbitrary positive numbers to counters. The numbers do not have to be
+whole numbers.
+
+### counter.increment(labels)
+Adds 1 to the metric represented by `labels` (calls `add(1, labels)`).
+
+Example:
+```javascript
+counter.increment({
+    method: 'ping',
+    code: 200
+});
+```
+
+### counter.add(value, labels)
+Add `value` to the metric represented by `labels`, `value` must be > 0.
+
+Example:
+```javascript
+counter.add(100, {
+    operation: 'click'
+});
+```
+
+## Gauge
+Gauges are similar to counters. Gauges can count up, or count down relative
+to their current value. Gauges start with an initial value of `0`. If you want
+a gauge that can be set to arbitrary values, look at [AbsoluteGauge](#absolutegauge).
+
+### gauge.add(value, labels)
+Add `value` to the metric represented by `labels`.
+
+Example:
+```javascript
+gauge.add(10, {
+    le: '+Inf'
+});
+```
+
+## AbsoluteGauge
+AbsoluteGauges are metrics that can only be set to an arbitrary value. These are
+useful for tracking things like the current amount of memory available on a
+system, or the async lag of a postgres peer. If you need to 'move' a gauge
+relative to its current position, you probably want to use [Gauge](#gauge)
+instead.
+
+### absoluteGauge.set(value, labels)
+Set the metric represented by `labels` to `value`.
+
+The `AbsoluteGauge` object has not yet been implemented. `AbsoluteGauge` is
+going to be implemented in one of the first post-1.0 releases.
+
+Example:
+```javascript
+absoluteGauge.set(123, {
+    tableName: 'manta'
+});
+```
+
+## Histogram
+Histograms are internally made up of Counters and Gauges. Once you
+understand that, Histograms are much easier to understand. Histograms
+count values that fall between a number of buckets.
+
+### histogram.observe(value, labels)
+Increment buckets with a value >= `value`.
+
+Note that it isn't necessary to specify which
+buckets to use. Log/linear buckets are automatically generated. More details
+about log/linear buckets can be found at the
+[DTrace blog](http://dtrace.org/blogs/bmc/2011/02/08/llquantize/).
+
+Example:
+```javascript
+histogram.observe(1111, {
+    method: 'putobject',
+    code: 204
+});
+```
diff --git a/docs/DESIGN.md b/docs/DESIGN.md
new file mode 100644
index 0000000..1a1c146
--- /dev/null
+++ b/docs/DESIGN.md
@@ -0,0 +1,458 @@
+# Design
+
+* [Unique Design Elements](#unique-design-elements)
+    * [Parent/Child Relationship](#parentchild-relationship)
+    * [Log/Linear Buckets](#loglinear-buckets)
+    * [Dynamic Labelling](#dynamic-labelling)
+    * [Triggered Metrics](#triggered-metrics)
+    * [Children are leaf collectors](#children-are-leaf-collectors)
+* [Problems](#problems)
+    * [Metric Cardinality](#metric-cardinality)
+    * [Javascript Numbers](#javascript-numbers)
+* [Other Thoughts and Ideas](#other-thoughts-and-ideas)
+    * [Aggregated Metrics](#aggregated-metrics)
+    * [Dropwizard and Prometheus Histograms](#dropwizard-and-prometheus-histograms)
+    * [Instrumenting Libraries](#instrumenting-libraries)
+    * [Scrape Endpoint and Push Gateway Support](#scrape-endpoint-and-push-gateway-support)
+    * [Retention Period](#retention-period)
+    * [Naming](#naming)
+    * [CLI Usage](#cli-usage)
+
+This document describes some of the unique design elements that factored into
+the creation of this library. It also mentions some speculative ideas, and a
+couple problems that may come about.
+
+## Unique Design Elements
+### Parent/Child Relationship
+
+The parent/child relationship is very important for our use case. This
+concept is taken from [bunyan](https://github.com/trentm/bunyan).
+This is a description of how it is implemented in this library.
+A parent collector is created with a set of properties including a name,
+and a set of labels. Labels are key/value pairs that can be used to
+'drill down' metrics. For example, to create a new parent collector:
+
+```javascript
+var collector = artedi.createCollector({
+    labels: {
+        zone: ZONENAME
+    }
+});
+```
+And to create a child collector:
+```javascript
+var gauge = collector.gauge({
+    name: 'marlin_agent_jobs_running',
+    labels: {
+        key: 'value'
+    }
+});
+```
+
+All of the child collectors created from the parent collector will have
+the label `zone=ZONENAME`. The child that we created is a gauge in this
+case. A user could also call `.counter()`, `.histogram()`, or
+`.gauge()`. Note that when we refer to histograms, we're referring to the
+Prometheus-style histograms. There are currently no plans to implement
+the Prometheus 'Summary' collector.
+
+In the Prometheus nomenclature, gauges, counters, histograms, and
+summaries are all called 'collectors.' For this library, we're also
+calling the parent instance a 'collector.' The child collector (gauge)
+that we just created has the following labels: zone=ZONENAME,key=value.
+It inherited the 'zone' label from its parent. Any metric measurement
+that we take will include these two labels in addition to any labels
+provided at the time of measurement. For example:
+
+```javascript
+gauge.set(1, {
+    owner: 'kkantor'
+});
+```
+The reported metric from that operation will look something like this:
+```
+marlin_agent_jobs_running{zone="e5d03bc",key="value",owner="kkantor"} 1
+```
+
+### Log/Linear Buckets
+One of the major problems with creating histograms in existing metric clients
+is that they require the user to provide a static list of bucket values for
+values to fall into. There are some problems with this, and to understand them
+we first need to understand what role buckets serve.
+
+Buckets are upper bounds on the value being tracked. For example, if a histogram
+is tracking request latency, you may have the following buckets: [100, 200, 300,
+400, 500, Inf] where each number represents time to completion in milliseconds.
+Inf is a special bucket that counts ALL values, including those that are greater
+than the largest bucket. So the value of Inf is >= sum(all bucket counts). Each
+bucket counts values that are less than or equal to the bucket. So for a request
+that took 222ms, the 300, 400, 500, and Inf buckets will be incremented.
+
+This sounds good if we know that we'll have a normal distribution of inputs and
+we know the approximate values that we should be receiving. This makes a lot of
+sense for simple use cases, like a webserver that serves text files. The latency
+of something simple like that should be relatively consistent. The usefulness of
+static buckets degrades quickly when workloads become much more varied.
+
+In Muskie, for example, we have some operations that finish quickly
+(`putdirectory`), and some that can take a long time (`putobject`). The latency
+of `putdirectory` will be relatively stable and low when compared to
+`putobject`. The latency of `putobject` can vary widely based on how large the
+object being uploaded is. We would like fine granularity when monitoring the
+latency of `putdirectory`, and a coarse granularity when monitoring `putobject`.
+
+With current metric clients, we have to either know the
+expected behavior of our application, or sacrifice either fine or coarse
+granularity in order to get accurate measurements from histograms.
+
+Luckily, this problem has been solved in-house already! DTrace has support
+for log/linear quantization. In short, it gives us the ability to represent
+both fine and coarse granularity in the same histogram. For more information on
+log/linear quantization, see
+[this DTrace blog post](http://dtrace.org/blogs/bmc/2011/02/08/llquantize/).
+
+Rather than requiring the user to provide a static list of buckets, log/linear
+buckets can be automatically generated. They are still static buckets in that
+the value of the bucket itself doesn't change. They are, however, dynamic in that
+the number of buckets can expand out as needed by the client's observations.
+
+Let's take an example. If my application observes a latency of 6ms, this is what
+a set of log/linear buckets would produce:
+```
+# HELP muskie_request_latency_ms latency of requests completed
+# TYPE muskie_request_latency_ms histogram
+http_request_latency_ms{le="1"} 0
+http_request_latency_ms{le="3"} 0
+http_request_latency_ms{le="5"} 0
+http_request_latency_ms{le="7"} 1
+http_request_latency_ms{le="9"} 1
+http_request_latency_ms{le="+Inf"} 1
+http_request_latency_ms_count{} 1
+http_request_latency_ms_sum{} 6
+```
+
+Now if my application observes a latency of 600ms, this is what we receive:
+```
+# HELP http_request_latency_ms latency of requests completed
+# TYPE http_request_latency_ms histogram
+http_request_latency_ms{le="1"} 0
+http_request_latency_ms{le="3"} 0
+http_request_latency_ms{le="5"} 0
+http_request_latency_ms{le="7"} 1
+http_request_latency_ms{le="9"} 1
+http_request_latency_ms{le="81"} 1
+http_request_latency_ms{le="243"} 1
+http_request_latency_ms{le="405"} 1
+http_request_latency_ms{le="567"} 1
+http_request_latency_ms{le="729"} 2
+http_request_latency_ms{le="+Inf"} 2
+http_request_latency_ms_count{} 2
+http_request_latency_ms_sum{} 606
+```
+
+And then maybe we observe a latency of 60000ms!
+```
+# HELP http_request_latency_ms latency of requests completed
+# TYPE http_request_latency_ms histogram
+http_request_latency_ms{le="1"} 0
+http_request_latency_ms{le="3"} 0
+http_request_latency_ms{le="5"} 0
+http_request_latency_ms{le="7"} 1
+http_request_latency_ms{le="9"} 1
+http_request_latency_ms{le="81"} 1
+http_request_latency_ms{le="243"} 1
+http_request_latency_ms{le="405"} 1
+http_request_latency_ms{le="567"} 1
+http_request_latency_ms{le="729"} 2
+http_request_latency_ms{le="59049"} 2
+http_request_latency_ms{le="177147"} 3
+http_request_latency_ms{le="295245"} 3
+http_request_latency_ms{le="413343"} 3
+http_request_latency_ms{le="531441"} 3
+http_request_latency_ms{le="+Inf"} 3
+http_request_latency_ms_count{} 3
+http_request_latency_ms_sum{} 60606
+```
+
+We can see that log/linear buckets give us a lot of flexibility while only
+removing a slight bit of precision.
+
+Prometheus is fine with this way of adding additional buckets between
+scrape periods as long as we don't modify the bucket values themselves.
+
+### Dynamic Labelling
+We can see in the last example that the metric inherited two labels, and
+we additionally crated a third label (`owner="kkantor"`) on the fly.
+Existing metric clients (prom-client, the Golang Prometheus client)
+don't allow for dynamic creation of labels. We allow that in this
+library. It is also unique for this library to allow for 'static'
+key/value pairings of labels. Existing clients only allow users to
+specify label keys at the time a collector is created, but we are
+allowing a user to specify both a label key and value (`labels{'zone'}`
+vs `labels{zone: ZONENAME}`).
+
+By allowing on the fly creation of labels, we gain a lot of flexibility,
+but lose the ability to strictly control labels. This makes it easier for
+a user to mess up labeling. For example, a user could do something like
+this:
+```javascript
+var counter = collector.counter({
+    name: 'http_requests_completed',
+    help: 'count of requests completed'
+});
+
+if (res.statusCode >= 500 && res.err) {
+    counter.increment({
+        method: req.method,
+        err: res.err.name
+    });
+} else {
+    counter.increment({
+        method: req.method
+    });
+}
+
+// Elsewhere in the code...
+collector.collect(artedi.FMT_PROM, function (err, str) {
+    console.log(str);
+});
+
+/*
+ * If both of the counter.increment() statements are hit once each,
+ * the output might look something like this:
+ * HELP: http_requests_completed count of requests completed
+ * TYPE: http_requests_completed counter
+ * http_requests_completed{method="putobject"} 1
+ * http_requests_completed{method="putobject",err="Service Unavailable"} 1
+ */
+```
+The above example shows that two different metrics were created. This is
+possibly the intended behavior, but depending on how queries are being
+run, this may result in information being lost. Other implementations
+would require a user to define labels up-front, and throw an error if
+the user tried to create a label ad-hoc, like above.
+
+Merits of up-front label declaration:
+* Programming mistakes become runtime errors, rather than producing
+    valid, but confusing data
+    * This defines a type of 'metric schema'
+
+Merits of dynamic label declaration:
+* Flexibility, ease of use
+
+In the end, we decided to implement dynamic declaration due to the
+increase in flexibility.
+
+### Triggered Metrics
+Traditionally, metrics are collected continuously and synchronously. For
+example, whenever a user makes a GET request, a counter to track HTTP requests
+is incremented. This makes sense for lightweight things, like counting HTTP
+requests, but doesn't work well for remote instrumentation. Remote
+instrumentation might mean that we are trying to collect metrics from a Postgres
+instance running on another machine, for instance. Instrumenting something like
+Postgres would require us to make a network request, and may involve some heavy
+lifting on the Postgres side as well depending on what type of information we're
+trying to retrieve.
+
+To provide for this use case, we'll introduce the notion of 'triggered metrics.'
+A triggered metric can take two forms:
+1. A metric that is observed only once metrics are scraped
+2. A metric that is observed once in a while
+
+An example of 1) could be a Gauge tracking the amount of free RAM on a system.
+The amount of RAM that was free 10 seconds ago doesn't matter. The amount of RAM
+that is free when we make our collection is what we want.
+
+An example of 2) could be a Gauge for the total number of records stored in a
+Postgres table. Something like that may involve a SQL query being run, and we
+may only want coarse time granularity for such an operation (i.e. every couple
+minutes). Note that this could also be implemented as an example of 1).
+
+To accomplish this, the `collect()` function will be asynchronous. An API will
+be provided that allows a user to register a metric with a scheduled collection
+period. At collection time, the each of the metrics in the 'trigger registry'
+could be invoked. This is similar to existing solutions, like
+[boolean health checks](http://metrics.dropwizard.io/3.2.2/getting-started.html#health-checks).
+
+Further implementation details have to be worked out when we implement Triggered
+Metrics. Triggered Metrics will be implemented soon after the initial release,
+as they're a necessary feature to efficiently gather some types of metrics.
+
+### Children are leaf collectors
+Children cannot be created from children. That is, a user can't call
+.gauge() on a Counter to create a child Gauge.
+
+The name of the metric (`marlin_agent_jobs_running` from our example) is
+created by appending the `namespace` field from the parent collector to
+the `subsystem` and `name` fields of the child, separated by
+underscores.
+
+When a child collector is created, the parent registers the collector.
+This is done for two reasons. The first is that the user only needs to
+call .collect() on the parent collector in order to generate metric
+output. The second is so that child collectors are not garbage collected
+into non-existence after they are dereferenced by whatever function
+created them to measure a certain task. When a user calls .gauge() on a
+parent collector, it may or may not create a new gauge depending on if
+one with the same metric name (`marlin_agent_jobs_running` from our
+example) already has been registered.
+
+## Problems
+### Metric Cardinality
+To illustrate this problem, let's say that we have the label keys
+`method`, `code`, and `username`. `method` can take the values `get`,
+and `post`. `code` can take the values `200`, `500`, and `404`.
+`username` can take any value from a list of 100 users. The number of
+possible counters created in this situation is `(2*3)*100=600`. For this
+very small data set, you can see that we have the possibility of having
+a shitload of data. Keeping unbounded fields like `username` to a
+minimum (or not including them at all) is very important to maintaining a
+manageable amount of data (as well as conserving memory in the metric
+client and server). This is called the problem of **metric
+cardinality**.
+
+### Javascript Numbers
+Numbers in Javascript are 64-bit floats. The maximum value for a number in
+Javascript is `(2^53)-1`. There is a possible danger here because of the way
+Counters function. A Counter counts up, and is unbounded. We could theoretically
+overflow the number value. If we instrument a process that performs one thousand
+requests per second, and we were incrementing a counter for each request, it
+would take us many years to reach the overflow point.
+
+## Other Thoughts and Ideas
+
+### Aggregated Metrics
+Rather than making a programmer choose which fields to collect at the time of
+observation, the programmer could observe all of the possible fields, and then
+choose which fields to keep.
+
+Take Muskie as an example. Currently we collect only a subset of fields
+(latency, request method, response code, etc.). We could change that to collect
+all of the information about a request (user, local/remote IP, metadata shard,
+sharks, etc.). When we initially create the collector, we specify which of the
+metrics we want to keep. The metrics that we don't want to keep are aggregated
+away at observation time.
+
+This is especially useful when we go to instrument things like Cueball, where
+different fields will be relevant (and efficient to collect) for each
+application component. For example, it may be efficient (in terms of
+cardinality) for Muskie to collect a 'remoteIP' field, but not efficient for
+CloudAPI to do so.
+
+This makes it easier for application developers to know which fields will be
+collected, and stops them from accidentally adding fields that may make querying
+difficult.
+
+### Dropwizard and Prometheus Histograms
+Dropwizard is a Java framework that (among other things) provides a popular Java
+library used to instrument applications. The instrumentation library is similar
+in scope to `artedi`. There are a couple fundamental differences in the way that
+Dropwizard's library and `artedi` function, especially with respect to
+histograms.
+
+Dropwizard histograms have a pretty complex implementation on the client-side.
+As metrics are observed, they are added to a `reservoir`. Quantiles are
+calculated each time a metric is observed. If a user wants to know, for example,
+what the 90th percentile of a given metric is, it would be a simple lookup due
+to the functionality of `reservoirs` and histograms. A `reservoir` is a type of
+in-memory database that can have a number of different rules for eviction of
+records. For example, a `reservoir` could be configured to use a `sliding
+window`, which retains a user-defined `N` metrics in memory. When `N+1` metrics
+have been observed, the first observed metric is evicted from memory. Dropwizard
+places the burden of calculating quantiles on the client library.
+
+Prometheus histograms have a relatively simple implementation. Prometheus places
+the burden of calculating histogram quantiles on the server. When a metric is
+observed, the Prometheus client simply increments a set of `buckets`. Metrics
+are retained indefinitely on the client-side because they carry next to no cost
+to retain.
+
+Server-side histogram quantile calculation has benefits and drawbacks. One major
+benefit is that a quantile based on any percentile can be calculated at any
+time. With Dropwizard histograms, only a set number of quantiles can be
+calculated, and they have to be defined when the client begins collecting
+metrics. The major drawback to server-side quantile calculation is that the
+server may have to iterate through an enormous amount of historical data to
+produce a result. This can cause lead to slow server performance.
+
+Prometheus clients may implement a metric type called a 'summary'. Summaries
+more closely resemble Dropwizard-style histograms. Quantile calculation is done
+on the client side, and there are sets of rules for how metrics are retained and
+evicted. At this point Prometheus-style summaries are not implemented in
+`artedi`, though we could add them at a later point if we find it necessary.
+
+For more information on Prometheus histograms and summaries, see this page:
+https://prometheus.io/docs/practices/histograms/ .
+
+### Instrumenting Libraries
+One cool thing that we might think about doing is instrumenting common
+libraries. We are already planning on doing something like this for Cueball. We
+could conceivably instrument something like Restify so we wouldn't need to
+specifically track counts and latency of http requests in our applications. The
+downside of doing something like this (specifically with Restify) is that the
+library may not know all of the information that we may like to convey in our
+metrics. Examples of those things would be usernames, request IDs, etc.
+
+### Scrape Endpoint and Push Gateway Support
+Some other metric client libraries provide a built-in server that can make it
+more convenient to expose metrics. In our applications, we may be required to
+stand up another server to expose metrics as a way to ensure metrics don't fall
+into the wrong hands. We could design this in such a way that it is pluggable
+so a user could choose to expose metrics via Restify, node-fast, a flat file,
+or something else. Disadvantages to this approach is that it is potentially
+quite a bit of extra code to maintain, and we may not be able to efficiently
+write this in a way that gives us the flexibility we require. We will have to
+revisit if this is needed or helpful.
+
+Separately, it may make sense for us to add support of push gateways to this
+library. For applications that are only behind private networks the pull model
+will sometimes not work. Prometheus suggests placing a Prometheus server within
+the boundaries of the private network, but that won't work well for our case
+when application owners may create an arbitrary number of private networks. Push
+gateways are one way to solve this, and would require client library support.
+
+We'll have to revisit this topic when we have thought more about how we will
+discover applications (and processes within applications) providing metrics.
+
+### Retention Period
+For now, the amount of time we retain metrics will be up to the operators of the
+metric server. Retention periods are in the scope of a not-yet-created RFD, so
+when we start working on an end-to-end solution for instrumentation we will have
+to revisit the question of how long to retain scraped metrics.
+
+### Naming
+We should try to maintain standard naming conventions for our metrics. For
+Prometheus, they are outlined
+[here](https://prometheus.io/docs/practices/naming/). As a summary, metrics
+should have generic names when it makes sense (`http_requests_completed`), and
+specific names when needed (`marlin_agent_jobs_running`). Labels should be used to
+break generic metrics into specific measurements. These two things allow for
+more powerful queries to be made at the monitoring dashboard.
+
+Names chosen for metrics are deceptively important. Changing names of metrics
+after they have been running in the wild should be considered a breaking change.
+Changing names of metrics results in a couple possibly unforeseen consequences.
+The first is that dashboards and queries have to be recreated to use the new
+metric name. The second, and more deceptive reason, is that changing names make
+historical metric queries much more difficult, if not impossible.
+
+This will be covered more in-depth in a future RFD, as this applies specifically
+to the instrumentation of applications.
+
+### CLI Usage
+It may be useful to provide a CLI wrapper around this library to dynamically
+instrument arbitrary applications. Dave Pacheco's
+[statblast](https://github.com/davepacheco/node-statblast) is an example of
+what we're would be going for. Imagine being able to instrument your favorite
+system monitoring tools directly from the CLI! Further, we could use DTrace to
+inspect a running system and instrument pieces of the application that are not
+normally instrumented. An example of this could be counting Restify entry/exits
+by pairing the already existing DTrace probes with this library to tie DTrace
+output into the power of monitoring systems.
+
+It may also separately be useful for applications to provide CLI tooling for
+scraping their metrics. For instance, if my application exposes metrics via
+node-fast, my application could provide a simple tool to allow CLI users
+to call the proper fast RPC endpoint to access the metrics and print them to the
+terminal. This portion is out of the scope of this document, but it is good to
+keep in mind, and is related to the previous idea.
diff --git a/docs/api.adoc b/docs/api.adoc
deleted file mode 100644
index 75eeec3..0000000
--- a/docs/api.adoc
+++ /dev/null
@@ -1,9 +0,0 @@
-:toc: left
-:source-highlighter: pygments
-:doctype: book
-:idprefix:
-:docinfo:
-
-:sectnums:
-# API
-
diff --git a/docs/index.adoc b/docs/index.adoc
deleted file mode 100644
index 65f9e8c..0000000
--- a/docs/index.adoc
+++ /dev/null
@@ -1,11 +0,0 @@
-:toc: left
-:source-highlighter: pygments
-:doctype: book
-:idprefix:
-:docinfo:
-
-include::../README.adoc[]
-
-include::api.adoc[]
-
-# Other documentation
diff --git a/docs/private_api.md b/docs/private_api.md
new file mode 100644
index 0000000..a6730f7
--- /dev/null
+++ b/docs/private_api.md
@@ -0,0 +1,197 @@
+* [Intro](#intro)
+* [Internal Structures](#internal-structures)
+    * [Metric](#metric)
+    * [MetricVector](#metricvector)
+* [External Structures](#external-structures)
+    * [Collector](#collector)
+    * [Counter](#counter)
+    * [Gauge](#gauge)
+    * [Histogram](#histogram)
+
+## Intro
+This document contains a description of this library's internal API. Consumers
+of the `artedi` library shouldn't need to look at this.
+
+Unless stated otherwise, all of the variables and functions outlined in this
+document should be considered private, and not used by the library consumers.
+The internal API is not static, and may change at any time without notice.
+
+To learn about the public, user-facing API provided, see [API.md](./API.md).
+
+## Internal Structures
+These structures are internal to `artedi`, and should not be directly
+instantiated by the user.
+
+### Metric
+A Metric is the most basic structure that we have implemented. Every
+collector type uses Metrics, but not directly.
+
+The Metric class represents the value behind an individual metric. For example,
+a Metric could represent the count of HTTP POST requests made that resulted in a
+204 status code. This class has no knowledge of higher-level concepts like
+counters, gauges, or histograms. It is simply a class that maintains a numeric
+value, a timestamp, and associated labels.
+
+| Variable | Type | Value |
+|----------|------|-----------------|
+|labels    |object|A map of label key/value pairs|
+|value     |number|A number that describes the current value of the metric|
+|timestamp |number|Unix time since the epoch, representing the time this metric was last modified|
+
+| Function | Arguments | Result | Return Value|
+|----------|-----------|--------|-------------|
+|add       |num     |Adds `num` to the `value` field of the metric. No positive/negative check is done on `num`|None|
+
+The `labels` that belong to each Metric are key/value pairs. There can
+be two Metrics that have the exact same key/value pairs, but they cannot
+belong to the same collector. For example, a Counter and a Gauge may
+both have the labels `{method="getObject",code="200"}`. The Gauge and
+Counter will be tracking different things though. In this case, the
+Counter may be tracking requests completed, while the Gauge is tracking
+request latency.
+
+All collector functions (`add()`, `observe()`, etc.) are
+all built on top of the Metric's `add()` function. To
+accomplish subtraction, `add()` is called with a negative number.
+
+The user should never directly perform operations on Metrics, but
+instead use collectors (which build on top of Metrics by way of
+MetricVectors).
+
+### MetricVector
+MetricVectors are built on top of Metrics and give them much more
+utility. Counters and Gauges directly use MetricVectors. Histograms use
+MetricVectors, but indirectly.
+
+The MetricVector provides a way to organize, create, and retrieve Metric
+objects. While a Metric represents a single data point, a MetricVector can
+represent one or more data points. For example, a MetricVector could represent
+the counts of all HTTP requests separated by method, and response code. Each
+unique method and response code pair would result in a new Metric object being
+created and tracked. The MetricVector class has no knowledge of higher-level
+concepts like counters, gauges, or histograms. Counters, gauges, and histograms
+are built on top of MetricVectors.
+
+| Variable | Type | Value |
+|----------|------|-----------------|
+|fullName  |string|full name of what is being tracked, resulting from concatenation of namespace, subsystem, and collector name|
+|metrics   |object|key/value mapping. Each key corresponds to a unique Metric object|
+
+| Function | Arguments | Result | Return Value|
+|----------|-----------|--------|-------------|
+|getWithLabels|object  |searches metrics map for Metrics with the provided labels|a Metric object, or null if not found|
+|createWithLabels|object|creates a new Metric with the given labels, adds it to the metric map|the newly created Metric object|
+|createOrGetWithLabels|object|calls `getWithLabels()` to determine if a Metric with the given labels is already created. If so, returns it. Otherwise, calls `createWithLabels()` and returns the created Metric|Metric object|
+|prometheus|callback|iterates through the metric map, serializing each Metric into a prometheus-parseable string|None (string and error via callback)|
+|json      |callback|same as `prometheus()`, but in JSON format|None (string and error via callback)|
+
+Simply put, MetricVectors keep track of multiple Metrics. Counters and
+Gauges directly wrap MetricVectors (which we'll explain later).
+Histograms use Counters and Gauges in their implementation, so they also
+use MetricVectors. MetricVectors do the vast majority of the heavy
+lifting for collectors.
+
+`json()` will be implemented when the need arises. No implementation is
+currently required.
+
+Users should not directly interact with MetricVectors. They should use
+things like collectors, which use MetricVectors internally.
+
+## External Structures
+These structures are what the user will interact with. See [API.md](./API.md)
+for more information on publicly available functions. This section extends
+API.md by describing the private functions, as well as 'class variables'.
+
+### Collector
+| Variable | Type | Value |
+|----------|------|-----------------|
+|registry  | object | key/value mapping of unique collector names -> child collectors|
+
+`registry` keeps references to all of the previously-instantiated child
+collectors. When it is time to serialize metrics, the Collector iterates through
+this map and calls the serialization method of choice on each child collector.
+The results are concatenated and returned to the user.
+
+| Function | Arguments | Result | Return Value|
+|----------|-----------|--------|-------------|
+|Collector | opts      | see `createCollector()`| see `createCollector()`|
+|register  |collector object|if the given collector has already been registered, returns an error. Otherwise, adds the collector to `registry`|error, or null|
+|getCollector|name|returns the collector with the full name of `name`, or null if not present in `registry`|collector object, or null|
+
+`Collector()` is called by the public `createCollector` function.
+
+### Counter
+| Variable | Type | Value |
+|----------|------|-----------------|
+|name|string|full name of what is being tracked, resulting from concatenation of namespace, subsystem, and collector name|
+|help|string|user-provided string explaining this collector|
+|metricVec|MetricVector|empty to start, is populated as the user performs metric operations|
+|type|string|'counter,' used during serialization|
+|staticLabels|object|key/value mapping of labels that will be present in all metrics collected by this collector|
+
+| Function | Arguments | Result | Return Value|
+|----------|-----------|--------|-------------|
+|Counter |parent, opts|creates a Counter object from traits available in the parent, and options passed in|a new Counter object|
+|labels|object|returns a metric that have *exactly* the label key/value pairs provided. If none exists, one is created|A Metric object|
+|prometheus|callback   |returns all of the Counter's metrics in prometheus format as a string|None (string and error via callback)|
+
+`Counter()` is called by the Collector object's `counter()` function.
+
+### Gauge
+| Variable | Type | Value |
+|----------|------|-----------------|
+|name|string|full name of what is being tracked, resulting from concatenation of namespace, subsystem, and collector name|
+|help|string|user-provided string explaining this collector|
+|metricVec|MetricVector|empty to start, is populated as the user performs metric operations|
+|type|string|'gauge,' used during serialization|
+|staticLabels|object|key/value mapping of labels that will be present in all metrics collected by this collector|
+
+| Function | Arguments | Result | Return Value|
+|----------|-----------|--------|-------------|
+|Gauge |parent, opts|creates a Gauge object from traits available in the parent, and options passed in|a new Gauge object|
+|labels|object|returns a metric that have *exactly* the label key/value pairs provided. If none exists, one is created|A Metric object|
+|prometheus|callback   |returns all of the Gauge's metrics in prometheus format as a string|None (string and error via callback)|
+
+`Gauge()` is called by the Collector object's `gauge()` function.
+
+### AbsoluteGauge
+AbsoluteGauge is not yet implemented.
+
+| Variable | Type | Value |
+|----------|------|-----------------|
+|name|string|full name of what is being tracked, resulting from concatenation of namespace, subsystem, and collector name|
+|help|string|user-provided string explaining this collector|
+|metricVec|MetricVector|empty to start, is populated as the user performs metric operations|
+|type|string|'gauge,' used during serialization|
+|staticLabels|object|key/value mapping of labels that will be present in all metrics collected by this collector|
+
+| Function | Arguments | Result | Return Value|
+|----------|-----------|--------|-------------|
+|AbsoluteGauge |parent, opts|creates an AbsoluteGauge object from traits available in the parent, and options passed in|a new AbsoluteGauge object|
+|labels|object|returns a metric that have *exactly* the label key/value pairs provided. If none exists, one is created|A Metric object|
+|prometheus|callback   |returns all of the Gauge's metrics in prometheus format as a string|None (string and error via callback)|
+
+`AbsoluteGauge()` is called by the Collector object's `absoluteGauge()` function.
+
+### Histogram
+| Variable | Type | Value |
+|----------|------|-----------------|
+|fullName|string|full name of what is being tracked, resulting from concatenation of namespace, subsystem, and collector name|
+|name|string|name of the collector, used when creating Counters and Gauges|
+|buckets|number array|an array that holds the upper values of each bucket|
+|counters|object|key/value mapping containing Counters for tracking metrics in each bucket|
+|gauge|Gauge|a Gauge used to track the \_sum field of each metric|
+|help|string|user-provided string explaining this collector|
+|metricVec|MetricVector|empty to start, is populated as the user performs metric operations|
+|type|string|'histogram,' used during serialization|
+|staticLabels|object|key/value mapping of labels that will be present in all metrics collected by this collector|
+
+| Function | Arguments | Result | Return Value|
+|----------|-----------|--------|-------------|
+|Histogram|parent, opts|creates a Histogram object from traits available in the parent, and options passed in|a new Histogram object|
+|labels|object|checks if a Counter with the given labels already exists. If yes, returns it, otherwise creates a new Counter, and initializes another Gauge|None|
+|prometheus|callback|iterates through the Counters, calling `prometheus()` on their `MetricVector` object. The results are stitched together and added to the result of calling `prometheus()` on the Gauge's MetricVector|None (string and error via callback)|
+
+`Histogram()` is called by the parent object's `histogram()` function.
+Buckets will be created using the log/linear method, similar to how it's done in
+[DTrace](http://dtrace.org/blogs/bmc/2011/02/08/llquantize/).
diff --git a/lib/collector.js b/lib/collector.js
new file mode 100644
index 0000000..3238003
--- /dev/null
+++ b/lib/collector.js
@@ -0,0 +1,247 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ *
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+
+var mod_assert = require('assert-plus');
+var mod_vasync = require('vasync');
+var mod_jsprim = require('jsprim');
+var VError = require('verror').VError;
+var MultiError = require('verror').MultiError;
+
+var lib_utils = require('./utils');
+var lib_counter = require('./counter');
+var lib_gauge = require('./gauge');
+var lib_histogram = require('./histogram');
+var lib_common = require('./common');
+
+/*
+ * Serialization formats that this library supports:
+ */
+var FMT_PROM_0_0_4 = 'prometheus-0.0.4';
+
+// FMT_PROM points to the latest Prometheus format spec.
+var FMT_PROM = FMT_PROM_0_0_4;
+
+/*
+ * The Collector object acts as a mostly dumb parent. It doesn't hold metrics,
+ * but it does hold a list of all child metric collectors.
+ *
+ * When the user creates child collectors from this parent collector (by
+ * calling collector.counter(), collector.gauge(), etc.), this object
+ * will create a child collector and then register it.
+ *
+ * Registration serves two purposes:
+ * 1) It gives the user the ability to call collector.collect() to retrieve
+ *      parseable metrics from ALL child collectors without explicitly
+ *      calling the collect() function on each child collector.
+ * 2) It persists child collector objects in memory. Collectors keep all of
+ *      their metrics in memory, so to avoid having collectors garbage collected
+ *      we will place them in a map. When the user creates a child collector
+ *      for the first time (a counter, for example), this object will invoke
+ *      the constructor for that collector type to create a new collector.
+ *      Now let's say that the user's program dereferences that collector. This
+ *      object will hold on to the counter so when the user tries to create
+ *      the same counter again (they re-entered the same function as when they
+ *      first created the counter), we can simply return the counter that has
+ *      already been created without having lost any important metrics.
+ *
+ */
+function Collector(options) {
+    mod_assert.optionalObject(options, 'options');
+    if (options) {
+        mod_assert.object(options.labels, 'options.labels');
+    }
+    var err;
+
+    if (options) {
+        this.staticLabels = options.labels;
+        this.staticLabels = lib_utils.trim(this.staticLabels);
+        err = lib_utils.checkValid(this.staticLabels);
+        if (err !== null) {
+            throw new VError(err, 'invalid labels');
+        }
+    } else {
+        this.staticLabels = null;
+    }
+
+    this.registry = {};
+}
+
+/* Public Functions */
+
+/*
+ * The user calls collector.counter(options) to create a 'child' Counter
+ * object from the 'parent' Collector object.
+ */
+Collector.prototype.counter = function counter(options) {
+    return (this.createChild(options, lib_common.COUNTER));
+};
+
+/*
+ * The user calls collector.gauge(options) to create a 'child' Gauge
+ * object from the 'parent' Collector object.
+ */
+Collector.prototype.gauge = function gauge(options) {
+    return (this.createChild(options, lib_common.GAUGE));
+};
+
+/*
+ * The user calls collector.histogram(options) to create a 'child' Histogram
+ * object from the 'parent' Collector object.
+ */
+Collector.prototype.histogram = function histogram(options) {
+    return (this.createChild(options, lib_common.HISTOGRAM));
+};
+
+/*
+ * We will tell each collector that is a child of this Collector to produce
+ * machine-readable output that we can report back to whatever is scraping
+ * this process.
+ *
+ * For example, if this collector has two child collectors (a Counter and
+ * a Histogram), this instructs both to produce Prometheus-style output and
+ * returns it to the caller.
+ */
+Collector.prototype.collect = function collect(format, cb) {
+    mod_assert.string(format, 'format');
+    mod_assert.func(cb, 'cb');
+
+    var str = '';
+    var errors = [];
+    var queue;
+    var multiError = null;
+
+    if (format === FMT_PROM) {
+
+        var promCallback = function promCallback(err, metricString) {
+            mod_assert.string(metricString, 'metricString');
+            if (err) {
+                errors.push(err);
+            }
+            str += metricString;
+        };
+
+        var dispatchCollect = function dispatchCollect(collector, callback) {
+            collector.prometheus(callback);
+        };
+
+        queue = mod_vasync.queue(dispatchCollect, 10);
+        mod_jsprim.forEachKey(this.registry, function (_, collector) {
+            queue.push(collector, promCallback);
+        });
+        queue.close();
+
+    } else {
+        errors.push(new VError('Unknown serialization format: ' + format));
+        cb(multiError, str);
+        return;
+    }
+
+    queue.once('end', function () {
+        if (errors.length > 0) {
+            multiError = new MultiError(errors);
+        }
+        cb(multiError, str);
+    });
+};
+
+
+
+/* Private Functions */
+/*
+ * Creates a child collector object with the given type (counter, for example).
+ *
+ * The 'options' structure passed in may include labels that should be used
+ * by the child. In addition, this function appends any additional labels that
+ * have been defined on the parent Collector.
+ *
+ * - If a collector with the given name and type already exists, it is returned.
+ * - If a collector with the given name, but a different type already exists,
+ *   an error is thrown.
+ * - If a collector with the given name and type does not exist, a new child is
+ *   created and returned.
+ */
+Collector.prototype.createChild = function createChild(options, type) {
+    mod_assert.object(options, 'options');
+    mod_assert.string(options.name, 'options.name');
+    mod_assert.string(options.help, 'options.help');
+    mod_assert.optionalObject(options.labels, 'options.labels');
+    var opts;
+    var err;
+    var child;
+
+    child = this.getCollector(options.name);
+    if (child === null || child === undefined) {
+        opts = lib_utils.shallowClone(options);
+        opts.labels = options.labels;
+        err = lib_utils.checkValidCollector(opts.name, opts.help);
+        if (err) {
+            throw new VError(err, 'invalid collector name/help');
+        }
+
+        // Include staticLabels, which are inherited from the parent Collector.
+        opts.parentLabels = this.staticLabels;
+
+        // Create a child of the corresponding type.
+        if (type === lib_common.COUNTER) {
+            child = new lib_counter.Counter(opts);
+        } else if (type === lib_common.GAUGE) {
+            child = new lib_gauge.Gauge(opts);
+        } else if (type === lib_common.HISTOGRAM) {
+            child = new lib_histogram.Histogram(opts);
+        } else {
+            throw new VError('Unknown type: ' + type);
+        }
+
+        err = this.register(child);
+        if (err) {
+            throw new VError(err, 'unable to create ' + type);
+        }
+    } else if (child.type !== type) {
+        // Prevent the user from overwriting collectors.
+        throw new VError('collector with name "%s" already registered',
+                options.name);
+    }
+
+    return (child);
+};
+
+
+/*
+ * Registers the given collector in this Collector's registry. If a collector
+ * already exists with the given name, and error is returned.
+ */
+Collector.prototype.register = function register(collector) {
+    mod_assert.object(collector, 'collector');
+    mod_assert.string(collector.name, 'collector.name');
+
+    if (this.getCollector(collector.name) !== null) {
+        return new VError('collector with name already registered: %s',
+                collector.name);
+    }
+    this.registry[collector.name] = collector;
+    return (null);
+};
+
+/*
+ * Finds finds the named collector in the registry and returns it. If none
+ * exists, returns 'null.'
+ */
+Collector.prototype.getCollector = function getCollector(name) {
+    if (!mod_jsprim.hasKey(this.registry, name)) {
+        return (null);
+    }
+    return (this.registry[name]);
+};
+
+module.exports = {
+    createCollector: function createCollector(options) {
+        return (new Collector(options));
+    },
+    FMT_PROM: FMT_PROM,
+    FMT_PROM_0_0_4: FMT_PROM_0_0_4
+};
diff --git a/lib/index.js b/lib/common.js
similarity index 58%
rename from lib/index.js
rename to lib/common.js
index b22916b..5023885 100644
--- a/lib/index.js
+++ b/lib/common.js
@@ -6,3 +6,11 @@
  * Copyright (c) 2017, Joyent, Inc.
  */
 
+/*
+ * These are a few global constants used in various places in this library.
+ */
+module.exports = {
+    COUNTER: 'counter',
+    GAUGE: 'gauge',
+    HISTOGRAM: 'histogram'
+};
diff --git a/lib/counter.js b/lib/counter.js
new file mode 100644
index 0000000..d85b431
--- /dev/null
+++ b/lib/counter.js
@@ -0,0 +1,102 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ *
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+var mod_util = require('util');
+
+var mod_assert = require('assert-plus');
+var mod_jsprim = require('jsprim');
+var VError = require('verror').VError;
+
+var lib_metric_vector = require('./metric_vector');
+var lib_common = require('./common');
+
+/*
+ * A Counter is a type of collector that can only increase in value by calling
+ * functions 'add()' and 'increment()'.
+ */
+function Counter(options) {
+    mod_assert.object(options, 'options');
+    mod_assert.string(options.name, 'options.name');
+    mod_assert.string(options.help, 'options.help');
+    mod_assert.optionalObject(options.labels, 'options.labels');
+    mod_assert.optionalObject(options.parentLabels, 'options.parentLabels');
+
+    this.staticLabels =
+        mod_jsprim.mergeObjects(options.labels, options.parentLabels, null);
+
+    // Create a full metric name that looks
+    // like 'muskie_audit_requests_completed'.
+    this.name = options.name;
+    this.help = options.help;
+    this.metricVec = new lib_metric_vector.MetricVector({
+        name: this.name,
+        labels: this.staticLabels
+    });
+    this.type = lib_common.COUNTER;
+}
+
+/* Public Functions */
+/*
+ * Add '1' to the Metric represented by the labels 'pairs.' This uses the
+ * 'labels()' function to find the metric represented by 'pairs.'
+ */
+Counter.prototype.increment = function increment(pairs) {
+    this.add(1, pairs);
+};
+
+/*
+ * Add 'value' to the Metric represented by the labels 'pairs.' This uses the
+ * 'labels()' function to find the metric represented by 'pairs.'
+ */
+Counter.prototype.add = function add(value, pairs) {
+    mod_assert.optionalObject(pairs, 'pairs');
+    mod_assert.number(value, 'value');
+    if (value < 0) {
+        throw new VError('adding negative values to counters ' +
+                'is not allowed:', value);
+    }
+
+    // Get the metric associated with the labels passed in.
+    // This will create the metric if one does not exist.
+    var metric = this.labels(pairs);
+    metric.add(value);
+};
+
+/* Private Functions */
+/*
+ * Returns a Metric object that represents the labels passed in. If a Metric
+ * exists with the given labels in the MetricVector, it will be returned without
+ * creating a new Metric. If no labels are specified, the 'default' metric
+ * (that is, the Metric with no labels) is returned.
+ */
+Counter.prototype.labels = function labels(pairs) {
+    mod_assert.optionalObject(pairs);
+    if (!pairs || mod_jsprim.isEmpty(pairs)) { // User passed in '{}'.
+        return (this.metricVec.getDefault());
+    }
+
+    return (this.metricVec.createOrGetWithLabels(pairs));
+};
+
+/*
+ * Call the 'prometheus()' function on the MetricVector object, which represents
+ * all of the metrics. Additionally, append the HELP and TYPE lines that are
+ * specific to this metric.
+ */
+Counter.prototype.prometheus = function prometheus(cb) {
+    var str = mod_util.format('%s %s %s\n', '# HELP', this.name, this.help);
+    str += mod_util.format('%s %s %s\n', '# TYPE', this.name, this.type);
+
+    this.metricVec.prometheus(function (err, metrics) {
+        str += metrics;
+        cb(err, str);
+    });
+};
+
+module.exports = {
+    Counter: Counter
+};
diff --git a/lib/gauge.js b/lib/gauge.js
new file mode 100644
index 0000000..1efef03
--- /dev/null
+++ b/lib/gauge.js
@@ -0,0 +1,88 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ *
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+var mod_util = require('util');
+
+var mod_assert = require('assert-plus');
+var mod_jsprim = require('jsprim');
+
+var lib_metric_vector = require('./metric_vector');
+var lib_common = require('./common');
+
+/*
+ * A Gauge is a type of collector that can increase and decrease in value.
+ * This Gauge only supports 'relative' movement of values through the 'add()'
+ * function.
+ */
+function Gauge(options) {
+    mod_assert.object(options, 'options');
+    mod_assert.string(options.name, 'options.name');
+    mod_assert.string(options.help, 'options.help');
+    mod_assert.optionalObject(options.labels, 'options.labels');
+    mod_assert.optionalObject(options.parentLabels, 'options.parentLabels');
+
+    this.staticLabels =
+        mod_jsprim.mergeObjects(options.parentLabels, options.labels, null);
+
+    this.help = options.help;
+    this.type = lib_common.GAUGE;
+    this.name = options.name;
+    this.metricVec = new lib_metric_vector.MetricVector({
+        name: this.name,
+        labels: this.staticLabels
+    });
+}
+
+ /*
+  * Add 'value' to the Metric represented by the labels, 'pairs.' This uses the
+  * 'labels()' function to find the metric represented by 'pairs.'
+  */
+Gauge.prototype.add = function add(value, pairs) {
+    mod_assert.optionalObject(pairs, 'pairs');
+    mod_assert.number(value, 'value');
+
+    var metric = this.labels(pairs);
+    metric.add(value);
+};
+
+/* Private Functions */
+/*
+ * Returns a Metric object that represents the labels passed in. If a Metric
+ * exists with the given labels in the MetricVector, it will be returned without
+ * creating a new Metric. If no labels are specified, the 'default' metric
+ * (that is, the Metric with no labels) is returned.
+ */
+Gauge.prototype.labels = function labels(pairs) {
+    mod_assert.optionalObject(pairs, 'pairs');
+
+    if (!pairs || mod_jsprim.isEmpty(pairs)) {
+        return (this.metricVec.getDefault());
+    }
+
+    return (this.metricVec.createOrGetWithLabels(pairs));
+};
+
+/*
+ * Call the 'prometheus()' function on the MetricVector object, which represents
+ * all of the metrics. Additionally, append the HELP and TYPE lines that are
+ * specific to this metric.
+ */
+Gauge.prototype.prometheus = function prometheus(cb) {
+    mod_assert.func(cb, 'cb');
+    var str = mod_util.format('%s %s %s\n', '# HELP', this.name, this.help);
+    str += mod_util.format('%s %s %s\n', '# TYPE', this.name, this.type);
+
+    this.metricVec.prometheus(function (err, metrics) {
+        str += metrics;
+        cb(err, str);
+    });
+
+};
+
+module.exports = {
+    Gauge: Gauge
+};
diff --git a/lib/histogram.js b/lib/histogram.js
new file mode 100644
index 0000000..c12db74
--- /dev/null
+++ b/lib/histogram.js
@@ -0,0 +1,328 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ *
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+var mod_util = require('util');
+
+var mod_assert = require('assert-plus');
+var mod_jsprim = require('jsprim');
+var VError = require('verror').VError;
+
+var lib_utils = require('./utils');
+var lib_counter = require('./counter');
+var lib_gauge = require('./gauge');
+var lib_common = require('./common');
+
+/*
+ * A Histogram is a type of collector that represents a series of Counters. Each
+ * Counter corresponds to a certain range of values, called 'buckets.'
+ */
+function Histogram(options) {
+    mod_assert.object(options, 'options');
+    mod_assert.string(options.name, 'options.name');
+    mod_assert.string(options.help, 'options.help');
+    mod_assert.optionalObject(options.labels, 'options.labels');
+    mod_assert.optionalObject(options.parentLabels, 'options.parentLabels');
+
+    this.staticLabels =
+        mod_jsprim.mergeObjects(options.parentLabels, options.labels, null);
+
+    this.name = options.name;
+    this.help = options.help;
+    this.type = lib_common.HISTOGRAM;
+
+    this.counters = {};
+    this.gauge = new lib_gauge.Gauge(options);
+}
+
+/* Public Functions */
+/*
+ * Determine which bucket the observed 'value' falls into, and increment all the
+ * Counters >= that observed value. The '+Inf' Counter is always incremented,
+ * and a Gauge is created to track the running sum of values observed.
+ */
+Histogram.prototype.observe = function observe(value, pairs) {
+    mod_assert.number(value, 'value');
+    mod_assert.optionalObject(pairs, 'pairs');
+    if (value < 0) {
+        throw new VError('observe must be called with a value >= 0: %d', value);
+    }
+
+    var counter;
+    var pairCopy;
+    var buckets;
+    var index, count, i, bucket;
+    var smaller;
+
+    // For log-linear bucketing, we will produce five linear steps per log jump.
+    // At a point in the future, we may allow the user to provide this value,
+    // but five seems like a reasonable default.
+    var linearSteps = 5;
+
+    pairs = mod_jsprim.mergeObjects(pairs, this.staticLabels, null);
+    counter = this.labels(pairs);
+
+    // Make a copy of the labels sent in.
+    pairCopy = mod_jsprim.deepCopy(pairs);
+
+    /* Begin setting initial value for new buckets (if applicable). */
+
+    // Determine which bucket from the new order our value falls into.
+    buckets = getOrder(value, linearSteps);
+    if (!buckets) {
+        // The value passed in is too big (> 10 billion), so we just increment
+        // the +Inf counter, and add to the Gauge.
+        counter.increment({
+            le: '+Inf'
+        });
+        this.gauge.add(value, counter.staticLabels);
+        return;
+    }
+
+    // Find the largest bucket that the observed value falls into.
+    for (bucket in buckets) {
+        if (value <= buckets[bucket]) {
+            index = buckets[bucket];
+            break;
+        }
+    }
+
+    // Find the next-smallest bucket from the list of already-used buckets.
+    // The buckets are sorted when they are added to a metric vector.
+    for (bucket in counter.metricVec.buckets) {
+        if (counter.metricVec.buckets[bucket] < index) {
+            smaller = bucket;
+        }
+    }
+
+    // Check to see if the proper bucket for this value already exists in
+    // the bucket list.
+    if (counter.metricVec.buckets.indexOf(index) === -1) {
+        counter.metricVec.addBuckets(buckets);
+        if (smaller) {
+            // Copy value from the next-smallest bucket into the newly created
+            // buckets.
+            pairCopy['le'] = counter.metricVec.buckets[smaller];
+            count = counter.labels(pairCopy).value;
+            if (count > 0) {
+                for (bucket in buckets) {
+                    // In the case of overlapping buckets, we don't want to
+                    // double the value of the bucket.
+                    if (buckets[bucket] !==
+                            counter.metricVec.buckets[smaller]) {
+                        pairCopy['le'] = buckets[bucket];
+                        counter.add(count, pairCopy); // Set the initial value.
+                    }
+                }
+            }
+        }
+    }
+    /* Done setting initial value for new buckets. */
+
+    // Now we need to increment the Counters for the buckets >= the value
+    // passed in.
+    buckets = counter.metricVec.buckets;
+    index = buckets.indexOf(index);
+    for (i = 0; i < buckets.length; i++) {
+        pairCopy['le'] = buckets[i];
+        if (i < index) {
+            // We don't need to increment buckets that are smaller than what we
+            // received, but we do want to zero them out if they don't exist.
+            counter.labels(pairCopy);
+            continue;
+        }
+        counter.increment(pairCopy);
+    }
+
+    // Always increment the Inf Counter.
+    counter.increment({
+        le: '+Inf'
+    });
+
+    // There is a gauge for each counter so we can keep track
+    // of the _sum field (which can move up or down).
+    this.gauge.add(value, counter.staticLabels);
+};
+
+/* Private Functions */
+/*
+ * Returns a Counter associated with the givel labels, 'pairs,' and initializes
+ * a Gauge which will be used to track the sum of the values added to the
+ * Counter.
+ */
+Histogram.prototype.labels = function labels(pairs) {
+    mod_assert.optionalObject(pairs);
+    if (!pairs || mod_jsprim.isEmpty(pairs)) {
+        return (this.defaultCounter());
+    }
+    var lhash;
+    var opts;
+    var my_counter;
+
+    pairs = lib_utils.trim(pairs);
+    lhash = lib_utils.hashObj(pairs);
+    if (this.counters[lhash]) {
+        // We have already recorded this Counter.
+        return (this.counters[lhash]);
+    }
+
+    // Before we create the Counter, append the static labels.
+    pairs = mod_jsprim.mergeObjects(pairs, this.staticLabels, null);
+
+    // Create a new Counter.
+    opts = {
+        name: this.name,
+        help: this.help,
+        labels: pairs
+    };
+    my_counter = new lib_counter.Counter(opts);
+    this.gauge.labels(my_counter.staticLabels); // Initialize the gauge.
+
+    this.counters[lhash] = my_counter;
+    return (my_counter);
+};
+
+/*
+ * The 'prometheus()' function for Histograms is more complicated than that of
+ * Counters and Gauges.
+ *
+ * Each Counter represents a number of Metrics (via MetricVectors), so we
+ * call 'prometheus()' on each Counter's underlying MetricVector object. After
+ * we serialize each Counter, we synthesize the '_count' field and append the
+ * '_sum' field. The '_count' field carries the same value as the corresponding
+ * Counter's '+Inf' label.
+ */
+Histogram.prototype.prometheus = function prometheus(cb) {
+    mod_assert.func(cb, 'callback');
+    var str = '';
+    var labelStr = '';
+    var counter;
+    var keys;
+    var countLabels, key, labelObj, label;
+
+    var infHash = lib_utils.hashObj({le: '+Inf'});
+
+    str = mod_util.format('%s %s %s\n', '# HELP', this.name, this.help);
+    str += mod_util.format('%s %s %s\n', '# TYPE', this.name, this.type);
+
+    /*
+     * We're digging deep in this loop.
+     * The objective of this code is to get each Counter's MetricVec
+     * to report its metrics in the prometheus style. But we don't want the
+     * Counter itself to do that reporting, since then it would add on the
+     * '# TYPE' and '# HELP' headers.
+     *
+     * In addition, we need to serialize extra fields, like the _sum and _count
+     * fields. Both of these fields are reported based on label key/value
+     * combinations. That information is stored in each of the Metric objects.
+     */
+    var promCallback = function (err, metrics) {
+        if (err) {
+            cb(null, err);
+        }
+        str += metrics;
+    };
+    for (counter in this.counters) {
+        // Bypass the Counter object's .prometheus function, and instead
+        // call it on the metricVector itself.
+        this.counters[counter].metricVec.prometheus(promCallback);
+
+        // Get the last object in the metric vector. All of the metrics
+        // within a metric vector have the same labels.
+        keys = Object.keys(this.counters[counter].metricVec.metrics);
+        key = keys[0];
+        labelStr = '';
+        labelObj = {};
+        countLabels = this.counters[counter].metricVec.metrics[key].labels;
+        for (label in countLabels) {
+            if (label !== 'le') {
+                // Ignore the internal 'le' label.
+                labelStr += mod_util.format('%s="%s",',
+                        label, countLabels[label]);
+                labelObj[label] = countLabels[label];
+            }
+        }
+        // Chop off the trailing ','
+        labelStr = labelStr.substring(0, labelStr.length - 1);
+
+        // Create the _count metric.
+        str += mod_util.format('%s_count{%s}', this.name, labelStr);
+
+        // Append the +Inf value to the _count field, since they are the same.
+        str += mod_util.format(' %s %d\n',
+                this.counters[counter].metricVec.metrics[infHash].value,
+                this.counters[counter].metricVec.metrics[infHash].timestamp);
+
+        // Read the _sum Gauge.
+        str += mod_util.format('%s_sum{%s}', this.name, labelStr);
+        str += mod_util.format(' %d %d\n', this.gauge.labels(labelObj).value,
+            this.gauge.labels(labelObj).timestamp);
+    }
+
+    cb(null, str);
+};
+
+/*
+ * Returns a Counter with no labels. This is used when an observation is made
+ * with no labels.
+ */
+Histogram.prototype.defaultCounter = function defaultCounter() {
+    var opts;
+    if (!this.counters['default']) {
+        opts = {
+            name: this.name,
+            help: this.help,
+            labels: this.staticLabels
+        };
+        this.counters['default'] = new lib_counter.Counter(opts);
+    }
+    return (this.counters['default']);
+};
+
+/*
+ * Find (and return) a list of linear numbers that 'value' falls into.
+ * The 'steps' argument is provided, as we may allow the user to specify
+ * the number of linear 'steps' between logarithmic jumps. This idea is taken
+ * from DTrace's log/linear quantization ('llquantize()').
+ */
+function getOrder(value, steps) {
+    var i, j, val, width, next;
+    var buckets = [];
+
+    // These values are relatively arbitrary. It's possible that we may want to
+    // allow the user to change these at some point.
+    var factor = 10;
+    var low = 0;
+
+    // This is an arbitrary high watermark. Setting this allows us to ensure
+    // that our loop will always exit.
+    // The maximum value that we can observe (without it falling into only the
+    // +Inf bucket is 10^10, or 10,000,000,000.
+    var high = 10;
+
+    val = 1;
+    for (i = low; i <= high; i++) {
+        next = val * factor;
+        width = next > steps ? next / steps : 1;
+
+        for (j = 0; val <= next; val += width, j++) {
+            buckets[j] = val;
+        }
+
+        // Overlap buckets so we get something like:
+        // [0-10], [10-100], [100-1000].
+        val -= width;
+        if (value <= buckets[buckets.length - 1]) {
+            // The number is within this order.
+            return (buckets);
+        }
+    }
+    return (null);
+}
+
+module.exports = {
+    Histogram: Histogram
+};
diff --git a/lib/metric.js b/lib/metric.js
new file mode 100644
index 0000000..051b928
--- /dev/null
+++ b/lib/metric.js
@@ -0,0 +1,42 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ *
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+
+var mod_assert = require('assert-plus');
+
+/*
+ * Basic building block for counters and gauges. This object is not intended to
+ * be used directly by users.
+ * This object exposes the basic functionality of metrics, like
+ * add(), subtract(), and observe(). The higher layers (counters, gauges,
+ * summaries, histograms) will wrap these functions and restrict access
+ * to only the functions that are supported by the collector type (for example,
+ * counters can only call add() while gauges can call either add() or subtract()
+ * but not observe()).
+ */
+function Metric(options) {
+    mod_assert.optionalObject(options, 'options');
+    this.labels = options ? options.labels : {};
+    this.value = 0;
+    this.timestamp = 0;
+}
+
+/*
+ * Building block for upper-level functions like add(), subtract(),
+ * observe() (because it uses Counters). This does not check
+ * for positive/negative values. That should be handled at an upper layer.
+ */
+Metric.prototype.add = function add(num) {
+    mod_assert.number(num, 'num');
+
+    this.value += num;
+    this.timestamp = Date.now(); // Current unix time in milliseconds.
+};
+
+module.exports = {
+    Metric: Metric
+};
diff --git a/lib/metric_vector.js b/lib/metric_vector.js
new file mode 100644
index 0000000..0620645
--- /dev/null
+++ b/lib/metric_vector.js
@@ -0,0 +1,162 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ *
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+
+var mod_util = require('util');
+
+var mod_assert = require('assert-plus');
+var mod_jsprim = require('jsprim');
+var VError = require('verror').VError;
+
+var lib_metric = require('./metric');
+var lib_utils = require('./utils');
+
+/*
+ * MetricVectors are used to keep track of multiple metrics in one object.
+ * This is useful when the collector type can handle multiple label key/value
+ * pairs. A good example of this is counting web requests, and metering them
+ * based on method, and return code. There will be many different values for
+ * both 'method' and 'return code', but they are logically the same metric, so
+ * we can use metric vectors to accomplish that abstraction.
+ *
+ * This object is not intended to be used directly by users.
+ *
+ */
+function MetricVector(opts) {
+    mod_assert.string(opts.name, 'opts.name');
+    mod_assert.optionalObject(opts.labels, 'opts.labels');
+
+    this.name = opts.name;
+    this.metrics = {};
+
+    this.staticLabels = opts.labels;
+    if (this.staticLabels) {
+        this.staticLabels = lib_utils.trim(this.staticLabels);
+        var err = lib_utils.checkValid(this.staticLabels);
+        if (err !== null) {
+            throw new VError(err, 'invalid labels');
+        }
+    }
+    this.buckets = []; // Used for Histograms.
+}
+
+/*
+ * Appends 'newBuckets' to the list of buckets currently managed by this
+ * MetricVector.
+ */
+MetricVector.prototype.addBuckets = function addBuckets(newBuckets) {
+    newBuckets.forEach(function (bucket) {
+        if (this.buckets.indexOf(bucket) === -1) {
+            this.buckets.push(bucket);
+        }
+    }, this);
+    this.buckets.sort(function (a, b) { return a - b; });
+};
+
+/*
+ * Returns a Metric with no labels, or with only the static labels defined
+ * for this MetricVector.
+ */
+MetricVector.prototype.getDefault = function getDefault() {
+    // defaultMetric is a metric with only static labels (if provided).
+    if (!this.metrics['default']) {
+        this.metrics['default'] = new lib_metric.Metric({
+            labels: this.staticLabels
+        });
+    }
+    return (this.metrics['default']);
+};
+
+/*
+ * Returns a previously-created Metric representing 'labels,' or 'null' if
+ * the Metric has not been created.
+ */
+MetricVector.prototype.getWithLabels = function getWithLabels(labels) {
+    mod_assert.object(labels, 'labels');
+    var lhash = lib_utils.hashObj(labels);
+    return (this.metrics[lhash] || null);
+};
+
+/*
+ * Returns a newly-created Metric representing 'labels.'
+ */
+MetricVector.prototype.createWithLabels = function createWithLabels(labels) {
+    mod_assert.object(labels, 'labels');
+    var copy = lib_utils.shallowClone(labels);
+    var lhash = lib_utils.hashObj(copy);
+
+    // Before we create the metric, append the static labels.
+    if (this.staticLabels) {
+        for (var label in this.staticLabels) {
+            copy[label] = this.staticLabels[label];
+        }
+    }
+
+    this.metrics[lhash] = new lib_metric.Metric({labels: copy});
+    return (this.metrics[lhash]);
+};
+
+/*
+ * Create, or retrieve a Metric representing 'labels.' This calls
+ * 'getWithLabels(),' followed by 'createWithLabels()' if the Metric doesn't
+ * exist.
+ */
+MetricVector.prototype.createOrGetWithLabels =
+    function createOrGetWithLabels(labels) {
+    mod_assert.object(labels, 'labels');
+    var met = this.getWithLabels(labels);
+    if (typeof (met) !== 'undefined' && met !== null) {
+        return (met);
+    }
+    return (this.createWithLabels(labels));
+};
+
+/*
+ * Serialize this object into the format of prometheus metrics.
+ * For example:
+ *
+ * # HELP http_requests_completed count of muskie requests completed
+ * # TYPE http_requests_completed counter
+ * http_requests_completed{method="getmetrics",code="200"} 505
+ * http_requests_completed{method="getstorage",code="404"} 1
+ * http_requests_completed{method="headstorage",code="200"} 3
+ * http_requests_completed{method="getstorage",code="200"} 1
+ * http_requests_completed{method="putobject",code="204"} 33
+ * http_requests_completed{method="putdirectory",code="204"} 173
+ * http_requests_completed{method="putdirectory",code="403"} 1
+ *
+ */
+MetricVector.prototype.prometheus = function prometheus(cb) {
+    mod_assert.func(cb, 'cb');
+    var str = '';
+    var labelStr = '';
+    var name = this.name;
+
+    var appendLabel = function (key, value) {
+            labelStr += mod_util.format('%s="%s",', key, value);
+    };
+
+    // TODO O(M*N) - make faster?
+    mod_jsprim.forEachKey(this.metrics, function (_, metric) {
+        // Generate the labels and their values.
+        mod_jsprim.forEachKey(metric.labels, appendLabel);
+
+        // Chop off trailing ','.
+        labelStr = labelStr.substring(0, labelStr.length - 1);
+
+        // Put together the whole string.
+        str += mod_util.format('%s{%s} %d %d\n', name, labelStr, metric.value,
+            metric.timestamp);
+
+        labelStr = '';
+    });
+    cb(null, str);
+};
+
+module.exports = {
+    MetricVector: MetricVector
+};
diff --git a/lib/utils.js b/lib/utils.js
new file mode 100644
index 0000000..a95b075
--- /dev/null
+++ b/lib/utils.js
@@ -0,0 +1,138 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ *
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+
+var mod_assert = require('assert-plus');
+var mod_jsprim = require('jsprim');
+var VError = require('verror').VError;
+
+var mod_md5 = require('md5');
+
+/*
+ * This is a similar regex to the one used in the golang prometheus client lib.
+ * The Go client doesn't validate against a regex (citing bad performance), and
+ * actually have a hard-coded `if` statement that checks each string.
+ * That's something we could consider if we see performance issues with this.
+ *
+ * Also, if we want to support multiple formats we can do away with this and
+ * only check for validity at the time when we serialize the metrics.
+ */
+var regex = new RegExp('^[a-zA-Z_][a-zA-Z0-9_]*$');
+
+function shallowClone(obj) {
+    mod_assert.object(obj, 'obj');
+
+    var clone = {};
+    mod_jsprim.forEachKey(obj, function (key, value) {
+        clone[key] = value;
+    });
+
+    return (clone);
+}
+
+/*
+ * To ensure that we don't store duplicate metrics, we must hash all of
+ * the metrics before they're stored. This function takes an object of labels.
+ * The labels are sorted alphabetically, sent through stringify, and then their
+ * md5 hash is calculated. This should be adequately unique for our case.
+ */
+function hashObj(obj) {
+    mod_assert.object(obj, 'obj');
+
+    var newObj = {};
+    var keys = Object.keys(obj).sort();
+    keys.forEach(function (key) {
+        newObj[key] = obj[key];
+    });
+    return (mod_md5(JSON.stringify(newObj)));
+}
+
+/*
+ * Loop through the label object, trim off left- and right- whitespace.
+ */
+function trim(labels) {
+    mod_assert.object(labels, 'labels');
+
+    var keys = Object.keys(labels);
+    var trimmed = keys.reduce(function (newObj, key) {
+        newObj[key.trim()] = typeof (labels[key]) === 'string' ?
+            labels[key].trim() : labels[key];
+        return (newObj);
+    }, {});
+
+    return (trimmed);
+
+}
+
+/*
+ * Check the name and help strings given to collectors.
+ */
+function checkValidCollector(name, help) {
+    var err = null;
+
+    // Collector names must be strings, and pass the regex test.
+    if (typeof (name) !== 'string' || regex.test(name) === false) {
+        err = new VError('name "%s" must match regex "%s', name, regex);
+    }
+
+    // Collector 'help' messages must be strings.
+    if (typeof (help) !== 'string') {
+        err = new VError('help "%s" must be a string', help);
+    }
+
+    return (err);
+}
+
+/*
+ * Check the validity of labels.
+ */
+function checkValid(labels) {
+    mod_assert.optionalObject(labels, 'labels');
+
+    var err = null;
+    if (!labels) {
+        return (null);
+    }
+
+    mod_jsprim.forEachKey(labels, function (name, value) {
+        if (err !== null) {
+            // Short-circuit the rest of the for-each functions if we've already
+            // found an invalid string.
+            return;
+        }
+
+        // Test the label name for validity.
+        if (typeof (name) === 'string') {
+            if (regex.test(name) === false) {
+                err = new VError('label key "%s" must match regex "%s"',
+                    name, regex);
+                return;
+            }
+        } else {
+            err = new VError('label key must be a string', name);
+            return;
+        }
+
+        // Test the label value for validity.
+        if (typeof (value) !== 'string' && typeof (value) !== 'number' &&
+                typeof (value) !== 'boolean') {
+            err = new VError('label value "%s" must be one of ' +
+                    '[string, number, bool]',
+                    value, typeof (value));
+            return;
+        }
+    });
+    return (err);
+}
+
+module.exports = {
+    shallowClone: shallowClone,
+    hashObj: hashObj,
+    checkValidCollector: checkValidCollector,
+    checkValid: checkValid,
+    trim: trim
+};
diff --git a/package.json b/package.json
index 5d1189a..8500a5a 100644
--- a/package.json
+++ b/package.json
@@ -1,23 +1,24 @@
 {
   "name": "artedi",
-  "version": "0.1.0",
-  "description": "measuring fish",
-  "main": "lib/index.js",
+  "version": "1.0.0",
+  "description": "a metric client library",
+  "main": "lib/collector.js",
   "dependencies": {
-    "assert-plus": ">=1.0.0 <2.0.0",
-    "bunyan": ">=1.5.1 <2.0.0",
-    "mooremachine": ">=2.1.0 <3.0.0",
-    "vasync": ">=1.6.3 <2.0.0",
-    "verror": ">=1.6.1 <2.0.0"
-  },
-  "optionalDependencies": {
-    "dtrace-provider": "~0.8"
+    "assert-plus": "1.0.0",
+    "jsprim": "1.4.0",
+    "md5": "2.2.1",
+    "vasync": "1.6.4",
+    "verror": "1.10.0"
   },
   "devDependencies": {
-    "tape": ">=4.4.0 <5.0.0",
-    "sinon": ">=1.17.3 <2.0.0",
-    "json": ">=9.0.3 <10.0.0",
-    "restify": "^4.3.0"
+    "eslint": "2.13.1",
+    "eslint-plugin-joyent": "1.1.0",
+    "json": "9.0.6",
+    "tape": "4.6.3"
+  },
+  "repository": {
+    "url": "https://github.com/joyent/node-artedi.git",
+    "type": "git"
   },
   "engines": {
     "node": ">=0.10.0"
@@ -25,6 +26,6 @@
   "scripts": {
     "test": "tape test/*.test.js"
   },
-  "author": "",
+  "author": "Joyent, Inc",
   "license": "MPL-2.0"
 }
diff --git a/test/basic.test.js b/test/basic.test.js
index 4ef2aca..5cf0bb6 100644
--- a/test/basic.test.js
+++ b/test/basic.test.js
@@ -7,9 +7,530 @@
  */
 
 var mod_tape = require('tape');
+var mod_vasync = require('vasync');
 
 var mod_artedi = require('..');
 
-mod_tape.test('empty test', function (t) {
-	t.end();
+var common = require('../lib/common.js');
+
+/*
+ * Test that the parent/child relationship is working.
+ * - Empty strings
+ */
+mod_tape('parent/child tests', function (t) {
+    var collector = mod_artedi.createCollector();
+
+    var obj = {
+        name: 'test_awesome',
+        help: 'help me!'
+    };
+    var counter = collector.counter(obj);
+
+    // Make sure the fullName is being created properly.
+    t.equals(counter.name, 'test_awesome', 'basic full name');
+    // Make sure the child collector was registered.
+    t.ok(collector.registry[counter.name], 'metric registered');
+
+    // Test preventing the user from accidentally
+    // overwriting collectors in the collector registry.
+    // This gauge has the same full name as the counter previously created.
+    t.throws(function () {
+        var gauge = collector.gauge(obj);
+        gauge.add(100); // This line should not execute.
+    }, 'duplicate collector with same name');
+
+    // getCollector should return a child collector from the parent.
+    t.ok(collector.getCollector(counter.name), 'get collector by name');
+
+    t.end();
+});
+
+mod_tape('trim functionality tests', function (t) {
+    var utils = require('../lib/utils');
+    var myObj = {
+        '         kevin': 'spacey        '
+    };
+    var targetObj = {
+        'kevin': 'spacey'
+    };
+
+    var trimObj = utils.trim(myObj);
+    t.deepEquals(trimObj, targetObj, 'left- and right-trim');
+
+    myObj = {
+        '   neil   ': ' armstrong  ',
+        'buzz ': 'aldrin',
+        'chris ': ' hadfield',
+        'lightyear': ' buzz '
+    };
+    targetObj = {
+        'neil': 'armstrong',
+        'buzz': 'aldrin',
+        'chris': 'hadfield',
+        'lightyear': 'buzz'
+    };
+
+    trimObj = utils.trim(myObj);
+    t.deepEquals(trimObj, targetObj, 'left- and right-trim of multiple labels');
+
+
+    t.end();
+});
+
+mod_tape('hash tests', function (t) {
+    var utils = require('../lib/utils');
+
+    var obj1 = {
+        a: 'b',
+        b: 'a'
+    };
+    var obj2 = {
+        b: 'a',
+        a: 'b'
+    };
+
+    var hash1 = utils.hashObj(obj1);
+    var hash2 = utils.hashObj(obj2);
+
+    t.equals(hash1, hash2, 'consistent hashing with unordered objects');
+    t.end();
+});
+
+
+/*
+ * Test that labels are working properly.
+ * A few things to test:
+ * - Invalid label names                x
+ * - No labels                          x
+ * - numeric label values               x
+ * - Labels with objects as keys        x
+ */
+mod_tape('label tests', function (t) {
+    var collector = mod_artedi.createCollector({
+        labels: {
+            global: 'label'
+        }
+    });
+
+    // Create a counter with static labels.
+    var counter = collector.counter({
+        name: 'test_counter_labels',
+        help: 'counters with static labels should work',
+        labels: {
+            mytag: 'isAwesome'
+        }
+    });
+
+    // Increment counter with static labels.
+    counter.increment();
+    t.equals(counter.metricVec.getDefault().value, 1,
+        'increment w/ static labels from Collector and Counter');
+
+    counter.increment({
+        dynamicLabel: 'pepsi'
+    });
+    t.equals(counter.labels({
+        dynamicLabel: 'pepsi'
+    }).value, 1, 'increment w/ dynamic label and static labels');
+
+
+    counter = collector.counter({
+        name: 'counter',
+        help: 'counters are fantastic'
+    });
+
+    counter.increment();
+    t.equals(counter.metricVec.getDefault().value, 1,
+            'increment w/ label from Collector');
+
+    // The user gave us a label structure, but no labels.
+    counter.add(100, {});
+    t.equals(counter.metricVec.getDefault().value, 101,
+            'increment with empty label structure');
+
+    // Test for numeric metric values.
+    counter.increment({
+        method: 'putobject',
+        code: 200
+    });
+    t.equals(counter.labels({
+        method: 'putobject',
+        code: 200
+    }).value, 1, 'numeric label values, multiple labels');
+
+    t.end();
+});
+
+/*
+ * Test that prometheus serialization happens properly.
+ * A few things to test:
+ * - No metrics                                 x
+ * - Ordering of labels (it shouldn't matter)   x
+ */
+mod_tape('counter serialization tests', function (t) {
+    var collector = mod_artedi.createCollector();
+
+    var counter = collector.counter({
+        name: 'bot_demerits',
+        help: 'wtf'
+    });
+
+    var expected = '# HELP bot_demerits ' + counter.help + '\n';
+    expected += '# TYPE bot_demerits ' + common.COUNTER + '\n';
+
+    // collector.collect is async, so we'll force these tests to happen
+    // serially so we can accurately predict what collector.collect will output.
+    mod_vasync.pipeline({ funcs: [
+        function (_, cb) {
+            // No metrics present, so we should just see the comments.
+            collector.collect(mod_artedi.FMT_PROM, function (err, str) {
+                t.notOk(err, 'no error for no metrics');
+                t.equals(str, expected, 'no metrics, only comments');
+            });
+            cb();
+        },
+
+        function (_, cb) {
+            counter.increment({
+                trollcon: '4',
+                user: 'kkantor'
+            });
+
+            resetTimestamps(counter.metricVec);
+            var oneDemerit = expected +
+                'bot_demerits{trollcon="4",user="kkantor"} 1 0\n';
+            collector.collect(mod_artedi.FMT_PROM, function (err, str) {
+                t.notOk(err, 'no error for two labels');
+                t.equals(str, oneDemerit, 'two label increment');
+            });
+            cb();
+        },
+
+        function (_, cb) {
+            // Note the reversal of labels here (shouldn't make a difference).
+            counter.add(1000, {
+                user: 'kkantor',
+                trollcon: '4'
+            });
+
+            resetTimestamps(counter.metricVec);
+            /* BEGIN JSSTYLED */
+            // eslint-disable-next-line max-len
+            var lots = expected + 'bot_demerits{trollcon="4",user="kkantor"} 1001 0\n';
+            /* END JSSTYLED */
+            collector.collect(mod_artedi.FMT_PROM, function (err, str) {
+                t.notOk(err, 'no error for reversed labels');
+                t.equals(str, lots, 'reversed label add');
+            });
+            cb();
+        },
+
+        function (_, cb) {
+            collector = mod_artedi.createCollector();
+            counter = collector.counter({
+                name: 'test',
+                help: 'help'
+            });
+            counter.increment();
+            counter.increment();
+            counter.increment();
+
+            resetTimestamps(counter.metricVec);
+            expected = '' +
+                '# HELP test help\n' +
+                '# TYPE test ' + common.COUNTER + '\n' +
+                'test{} 3 0\n';
+
+            collector.collect(mod_artedi.FMT_PROM, function (err, str) {
+                t.notOk(err, 'no error for default counter');
+                t.equals(str, expected, 'default counter');
+            });
+            cb();
+        }]
+    }, function (_, result) {
+        t.end();
+    });
+
 });
+
+mod_tape('histogram serialization tests', function (t) {
+    var collector = mod_artedi.createCollector();
+
+    var histogram = collector.histogram({
+        name: 'bot_trolololol',
+        help: 'there is no help'
+    });
+    var expected = '# HELP bot_trolololol there is no help\n';
+    expected += '# TYPE bot_trolololol ' + common.HISTOGRAM + '\n';
+
+    mod_vasync.pipeline({ funcs: [
+        function (_, cb) {
+            collector.collect(mod_artedi.FMT_PROM, function (err, str) {
+                t.notOk(err, 'no error for no metrics');
+                t.equals(str, expected, 'no labels or data points');
+            });
+            cb();
+        },
+
+        function (_, cb) {
+            histogram.observe(1, {
+                'key': 'value'
+            });
+
+            expected = expected +
+                'bot_trolololol{key="value",le="1"} 1 0\n' +
+                'bot_trolololol{key="value",le="3"} 1 0\n' +
+                'bot_trolololol{key="value",le="5"} 1 0\n' +
+                'bot_trolololol{key="value",le="7"} 1 0\n' +
+                'bot_trolololol{key="value",le="9"} 1 0\n' +
+                'bot_trolololol{le="+Inf",key="value"} 1 0\n' +
+                'bot_trolololol_count{key="value"} 1 0\n' +
+                'bot_trolololol_sum{key="value"} 1 0\n';
+
+            resetTimestamps(histogram.gauge.metricVec);
+            Object.keys(histogram.counters).forEach(function (counter) {
+                resetTimestamps(histogram.counters[counter].metricVec);
+            });
+
+            collector.collect(mod_artedi.FMT_PROM, function (err, str) {
+                t.notOk(err, 'no error for single label');
+                t.equals(str, expected, 'single label');
+            });
+            cb();
+        },
+
+        function (_, cb) {
+            // Histogram metric with labels inherited from Collector
+            collector = mod_artedi.createCollector({
+                labels: {
+                    service: 'muskie'
+                }
+            });
+
+            histogram = collector.histogram({
+                name: 'http_request_latency',
+                help: 'latency of requests'
+            });
+
+            histogram.observe(99);
+            expected = '' +
+                '# HELP http_request_latency latency of requests\n' +
+                '# TYPE http_request_latency ' + common.HISTOGRAM + '\n' +
+                'http_request_latency{service="muskie",le="81"} 0 0\n' +
+                'http_request_latency{service="muskie",le="243"} 1 0\n' +
+                'http_request_latency{service="muskie",le="405"} 1 0\n' +
+                'http_request_latency{service="muskie",le="567"} 1 0\n' +
+                'http_request_latency{service="muskie",le="729"} 1 0\n' +
+                'http_request_latency{le="+Inf",service="muskie"} 1 0\n' +
+                'http_request_latency_count{service="muskie"} 1 0\n' +
+                'http_request_latency_sum{service="muskie"} 99 0\n';
+
+            resetTimestamps(histogram.gauge.metricVec);
+            Object.keys(histogram.counters).forEach(function (counter) {
+                resetTimestamps(histogram.counters[counter].metricVec);
+            });
+
+            collector.collect(mod_artedi.FMT_PROM, function (err, str) {
+                t.notOk(err, 'no error for collector labels');
+                t.equals(str, expected, 'Collector labels and no Histogram' +
+                    ' labels');
+            });
+            cb();
+        },
+
+        function (_, cb) {
+            // Histogram metric with labels inherited from both Collector and
+            // Histogram.
+            collector = mod_artedi.createCollector({
+                labels: {
+                    service: 'muskie'
+                }
+            });
+
+            histogram = collector.histogram({
+                name: 'web_conn_alive_time',
+                help: 'connection alive time',
+                labels: {
+                    component: 'qball'
+                }
+            });
+
+            histogram.observe(101);
+            /* BEGIN JSSTYLED */
+            /* eslint-disable */
+            expected = '' +
+            '# HELP web_conn_alive_time connection alive time\n' +
+            '# TYPE web_conn_alive_time ' + common.HISTOGRAM + '\n' +
+            'web_conn_alive_time{service="muskie",component="qball",le="81"} 0 0\n' +
+            'web_conn_alive_time{service="muskie",component="qball",le="243"} 1 0\n' +
+            'web_conn_alive_time{service="muskie",component="qball",le="405"} 1 0\n' +
+            'web_conn_alive_time{service="muskie",component="qball",le="567"} 1 0\n' +
+            'web_conn_alive_time{service="muskie",component="qball",le="729"} 1 0\n' +
+            'web_conn_alive_time{le="+Inf",service="muskie",component="qball"} 1 0\n' +
+            'web_conn_alive_time_count{service="muskie",component="qball"} 1 0\n' +
+            'web_conn_alive_time_sum{service="muskie",component="qball"} 101 0\n';
+            /* eslint-enable */
+            /* END JSSTYLED */
+
+            resetTimestamps(histogram.gauge.metricVec);
+            Object.keys(histogram.counters).forEach(function (counter) {
+                resetTimestamps(histogram.counters[counter].metricVec);
+            });
+            collector.collect(mod_artedi.FMT_PROM, function (err, str) {
+                t.notOk(err, 'no error for inherited labels');
+                t.equals(str, expected, 'inherited Histogram and Collector' +
+                    ' labels');
+            });
+
+
+            cb();
+        },
+
+        function (_, cb) {
+            // Histogram metric with labels inherited from both Collector and
+            // Histogram, and provided at time of observation.
+            collector = mod_artedi.createCollector({
+                labels: {
+                    service: 'muskie'
+                }
+            });
+
+            histogram = collector.histogram({
+                name: 'webapi_conn_alive_time',
+                help: 'connection alive time',
+                labels: {
+                    component: 'cueball'
+                }
+            });
+
+            histogram.observe(101, {
+                err: 'ECONNRESET'
+            });
+
+            // Silence line length linting error.
+            /* BEGIN JSSTYLED */
+            /* eslint-disable */
+            var expected4 = '' +
+            '# HELP webapi_conn_alive_time connection alive time\n' +
+            '# TYPE webapi_conn_alive_time ' + common.HISTOGRAM + '\n' +
+            'webapi_conn_alive_time{err="ECONNRESET",service="muskie",component="cueball",le="81"} 0 0\n' +
+            'webapi_conn_alive_time{err="ECONNRESET",service="muskie",component="cueball",le="243"} 1 0\n' +
+            'webapi_conn_alive_time{err="ECONNRESET",service="muskie",component="cueball",le="405"} 1 0\n' +
+            'webapi_conn_alive_time{err="ECONNRESET",service="muskie",component="cueball",le="567"} 1 0\n' +
+            'webapi_conn_alive_time{err="ECONNRESET",service="muskie",component="cueball",le="729"} 1 0\n' +
+            'webapi_conn_alive_time{le="+Inf",err="ECONNRESET",service="muskie",component="cueball"} 1 0\n' +
+            'webapi_conn_alive_time_count{err="ECONNRESET",service="muskie",component="cueball"} 1 0\n' +
+            'webapi_conn_alive_time_sum{err="ECONNRESET",service="muskie",component="cueball"} 101 0\n';
+            /* eslint-enable */
+            /* END JSSTYLED */
+
+            resetTimestamps(histogram.gauge.metricVec);
+            Object.keys(histogram.counters).forEach(function (counter) {
+                resetTimestamps(histogram.counters[counter].metricVec);
+            });
+            collector.collect(mod_artedi.FMT_PROM, function (err, str) {
+                t.notOk(err, 'no error for dynamic and static labels');
+                t.equals(str, expected4, 'dynamic labels, and static labels' +
+                    ' from Histogram and Collector');
+            });
+            cb();
+        },
+
+        function (_, cb) {
+            collector = mod_artedi.createCollector();
+            histogram = collector.histogram({
+                name: 'test_test1',
+                help: 'testhelp'
+            });
+
+            histogram.observe(1);
+            histogram.observe(100);
+            resetTimestamps(histogram.gauge.metricVec);
+            Object.keys(histogram.counters).forEach(function (counter) {
+                resetTimestamps(histogram.counters[counter].metricVec);
+            });
+            // TODO We should have the +Inf label at the end. This works, but
+            // it would look nicer.
+            expected = '' +
+                '# HELP test_test1 testhelp\n' +
+                '# TYPE test_test1 ' + common.HISTOGRAM + '\n' +
+                'test_test1{le="1"} 1 0\n' +
+                'test_test1{le="3"} 1 0\n' +
+                'test_test1{le="5"} 1 0\n' +
+                'test_test1{le="7"} 1 0\n' +
+                'test_test1{le="9"} 1 0\n' +
+                'test_test1{le="+Inf"} 2 0\n' +
+                'test_test1{le="81"} 1 0\n' +
+                'test_test1{le="243"} 2 0\n' +
+                'test_test1{le="405"} 2 0\n' +
+                'test_test1{le="567"} 2 0\n' +
+                'test_test1{le="729"} 2 0\n' +
+                'test_test1_count{} 2 0\n' +
+                'test_test1_sum{} 101 0\n';
+            collector.collect(mod_artedi.FMT_PROM, function (err, str) {
+                t.notOk(err, 'no error for copying bucket values');
+                t.equals(str, expected, 'initial values copied from ' +
+                    'low-order buckets to high-order buckets');
+            });
+
+            cb();
+        }]
+    }, function (_, result) {
+        t.end();
+    });
+});
+
+mod_tape('odd value tests', function (t) {
+    var collector = mod_artedi.createCollector();
+    var counter = collector.counter({
+        name: 'counter',
+        help: 'help'
+    });
+    var hist = collector.histogram({
+        name: 'histo',
+        help: 'histo help'
+    });
+
+    counter.add(0);
+    t.equals(counter.metricVec.getDefault().value, 0, 'add zero to counter');
+
+    hist.observe(0);
+    t.equals(hist.defaultCounter().metricVec.getDefault().value, 0,
+        'histogram observes zero value');
+
+    t.throws(function () {
+        counter = collector.counter({
+            name: '@#$5235',
+            help: 'valid help @ #34'
+        });
+    }, 'invalid collector name (invalid chars)');
+
+    t.throws(function () {
+        counter = collector.counter({
+            name: 'space name',
+            help: 'valid help @ #34'
+        });
+    }, 'invalid collector name (space)');
+
+    t.throws(function () {
+        counter = collector.counter({
+            name: 'valid_name',
+            help: 4
+        });
+    }, 'invalid collector help (numeric)');
+
+    t.throws(function () {
+        counter = collector.counter({
+            name: 'valid_name',
+            help: { help: 'nested help!' }
+        });
+    }, 'invalid collector help (object)');
+
+    t.end();
+});
+
+function resetTimestamps(metricVec) {
+    Object.keys(metricVec.metrics).forEach(function (metric) {
+        metricVec.metrics[metric].timestamp = 0;
+    });
+}
diff --git a/tools/bashstyle b/tools/bashstyle
deleted file mode 100644
index 3e8052e..0000000
--- a/tools/bashstyle
+++ /dev/null
@@ -1,164 +0,0 @@
-#!/usr/bin/env node
-/*
- * This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/.
- */
-
-/*
- * Copyright (c) 2014, Joyent, Inc.
- */
-
-/*
- * bashstyle: check bash scripts for adherence to style guidelines, including:
- *
- *    o no lines longer than 80 characters
- *    o file does not end with a blank line
- *    o Do not use 'local' and var initialization *using a subshell* in the
- *      same statement. See
- *      <http://www.tldp.org/LDP/abs/html/localvar.html#EXITVALANOMALY01>
- *      for why not. Arguably this belongs in a separate 'bashlint'.
- *
- * Future enhancements could include:
- *    o indents consistent with respect to tabs, spaces
- *    o indents consistently sized (all are some multiple of the smallest
- *      indent, which must be a tab or 4 or 8 spaces)
- */
-
-var VERSION = '2.0.0';
-
-var mod_assert = require('assert');
-var mod_fs = require('fs');
-
-var nerrors = 0;
-
-main();
-process.exit(0);
-
-function main()
-{
-	var files = process.argv.slice(2);
-
-	if (files.length === 0) {
-		console.error('usage: %s file1 [...]',
-		    process.argv.slice(0, 2).join(' '));
-		process.exit(2);
-	}
-
-	files.forEach(checkFile);
-
-	if (nerrors != 0)
-		process.exit(1);
-}
-
-function checkFile(filename)
-{
-	var text = mod_fs.readFileSync(filename, 'utf-8');
-	var lines = text.split('\n');
-	var i;
-	var styled = false;
-	var styleStart;
-
-	mod_assert.ok(lines.length > 0);
-
-	/*
-	 * Expand tabs in each line and check for long lines.
-	 */
-	for (i = 1; i <= lines.length; i++) {
-		var line = expandTabs(lines[i - 1]);
-
-		if (i > 1 && lines[i-2].match(/# BASHSTYLED/)) {
-			continue;
-		}
-
-		if (line.match(/# BEGIN BASHSTYLED/)) {
-			styleStart = i;
-			styled = true;
-		}
-
-		if (line.match(/# END BASHSTYLED/)) {
-			if (styled != true) {
-				nerrors++;
-				console.log('%s: %d: END BASHSTYLED w/o corresponding BEGIN',
-				            filename, i);
-			}
-			styled = false;
-		}
-
-		if (!styled && line.match(/^\s*local\s+(\w+)\s*=.*\$\(/)) {
-			nerrors++;
-			var m = line.match(/^\s*local\s+(\w+)\s*=/);
-			console.log('%s: %d: declaring and setting a "local" ' +
-				'var in the same statement ' +
-				'ignores a subshell return code ' +
-				'<http://www.tldp.org/LDP/abs/html/localvar.html#EXITVALANOMALY01>: ' +
-				'local %s=...',
-				filename, i, m[1]);
-		}
-
-		// Regexplanation: non-[, [, space (contents) space, ], non-]
-		// groups before and after brackets to ease search/replace.
-		if (!styled && line.match(/(^|[^\[])\[(\s.+\s)\]([^\]])/)) {
-			nerrors++;
-			console.log('%s: %d: prefer [[ to [ for tests.', filename, i);
-		}
-
-		if (!styled && line.length > 80) {
-			nerrors++;
-			console.log('%s: %d: line exceeds 80 columns',
-			    filename, i);
-		}
-	}
-
-	if (styled) {
-		nerrors++;
-		console.log('%s: %d: BEGIN BASHSTYLED that does not END',
-		            filename, styleStart);
-	}
-
-
-	/*
-	 * No sane editor lets you save a file without a newline at the very end.
-	 */
-	if (lines[lines.length - 1].length !== 0) {
-		nerrors++;
-		console.log('%s: %d: file does not end with newline',
-			filename, lines.length);
-	}
-
-	/*
-	 * Since the file will always end with a newline, the last entry of
-	 * "lines" will actually be blank.
-	 */
-	if (lines.length > 1 && lines[lines.length - 2].length === 0) {
-		nerrors++;
-		console.log('%s: %d: file ends with a blank line',
-		    filename, lines.length - 1);
-	}
-}
-
-function expandTabs(text)
-{
-	var out = '';
-	var col = 0;
-	var j, k;
-
-	for (j = 0; j < text.length; j++) {
-		if (text[j] != '\t') {
-			out += text[j];
-			col++;
-			continue;
-		}
-
-		k = 8 - (col % 8);
-		col += k;
-
-		do {
-			out += ' ';
-		}  while (--k > 0);
-
-		col += k;
-	}
-
-	return (out);
-}
diff --git a/tools/eslint.node.conf b/tools/eslint.node.conf
new file mode 100644
index 0000000..207e5ba
--- /dev/null
+++ b/tools/eslint.node.conf
@@ -0,0 +1,17 @@
+{
+    "plugins": [ "joyent" ],
+    "extends": [
+        "eslint:recommended",
+        "plugin:joyent/style",
+        "plugin:joyent/lint"
+    ],
+    "parserOptions": {
+        "ecmaVersion": 5,
+        "sourceType": "script",
+        "ecmaFeatures": {
+        }
+    },
+    "env": {
+        "node": true
+    }
+}
diff --git a/tools/jsstyle.conf b/tools/jsstyle.conf
index 5e7999e..f8704ab 100644
--- a/tools/jsstyle.conf
+++ b/tools/jsstyle.conf
@@ -5,8 +5,9 @@
 #
 
 #
-# Copyright (c) 2014, Joyent, Inc.
+# Copyright (c) 2017, Joyent, Inc.
 #
 
-indent=tab
+indent=4
 blank-after-start-comment=0
+strict-indent=true
diff --git a/tools/mk/Makefile.targ b/tools/mk/Makefile.targ
index 39c5498..fff3c94 100644
--- a/tools/mk/Makefile.targ
+++ b/tools/mk/Makefile.targ
@@ -6,7 +6,7 @@
 #
 
 #
-# Copyright (c) 2014, Joyent, Inc.
+# Copyright (c) 2017, Joyent, Inc.
 #
 
 #
@@ -180,7 +180,7 @@ check-bash: $(BASH_FILES:%=%.bashchk) $(BASH_FILES:%=%.bashstyle)
 .PHONY: check-json
 check-json: $(JSON_FILES:%=%.jsonchk)
 
-%.jsonchk: % $(JSON)
+%.jsonchk: %
 	$(JSON) --validate -f $^
 
 #
@@ -208,8 +208,13 @@ JSSTYLE_TARGET = $(if $(JSSTYLE_FILES), check-jsstyle)
 check-jsstyle:  $(JSSTYLE_EXEC)
 	$(JSSTYLE) $(JSSTYLE_FLAGS) $(JSSTYLE_FILES)
 
+.PHONY: check-esl
+$(ESLINT): | $(NPM_EXEC)
+	$(NPM) install
+
 .PHONY: check
-check:: check-jsl check-json $(JSSTYLE_TARGET) check-bash
+check:: $(ESLINT) check-json $(JSSTYLE_TARGET) check-bash
+	$(ESLINT) -c $(ESLINT_CONF) $(ESLINT_FILES)
 	@echo check ok
 
 .PHONY: clean
diff --git a/tools/update-ghdocs b/tools/update-ghdocs
deleted file mode 100755
index 160eb65..0000000
--- a/tools/update-ghdocs
+++ /dev/null
@@ -1,50 +0,0 @@
-#!/usr/bin/env bash
-
-SOURCE="${0}"
-while [ -h "$SOURCE" ]; do
-	DIR="$(cd -P "$( dirname "$SOURCE" )" && pwd)"
-	SOURCE="$(readlink "$SOURCE")"
-	[[ $SOURCE != /* ]] && SOURCE="$DIR/$SOURCE"
-done
-
-set -ex
-
-SCRIPTDIR="$(cd -P "$( dirname "$SOURCE" )" && pwd)"
-
-ROOTDIR="$(cd -P "$( dirname "$SCRIPTDIR" )" && pwd)"
-
-GHURI=$(cd "$ROOTDIR" && git remote -v | awk '
-	$2 ~ /(^|@)github[.]com[:\/]/ && $3 == "(push)" {
-		printf("%s\n", $2);
-		exit(0);
-	}
-')
-
-TMPDIR="$(mktemp -d)"
-function clean {
-	rm -fr "${TMPDIR}"
-}
-trap clean EXIT
-
-pushd "${TMPDIR}"
-git clone "file://${ROOTDIR}" ./repo
-cd repo
-git remote add ghdocs "${GHURI}"
-git branch -D gh-pages || true
-git checkout --orphan gh-pages
-rm -fr * .gitignore .gitmodules .npmignore .travis.yml
-git add -u
-popd
-
-while (( "$#" )); do
-	SRC="$1"
-	TARGET="${TMPDIR}/repo/$(basename "$SRC")"
-	cp "${SRC}" "${TARGET}"
-	shift
-done
-
-pushd "${TMPDIR}/repo"
-git add *
-git commit -m "auto-generated ghdocs commit"
-git push -f ghdocs gh-pages
-popd
-- 
2.21.0

