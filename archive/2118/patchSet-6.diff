commit 248f4cf5bb99854ba171eb6204a586d3c5df57a4 (refs/changes/18/2118/6)
Author: Kody A Kantor <kody.kantor@gmail.com>
Date:   2017-07-18T16:29:30+00:00 (2 years, 3 months ago)
    
    joyent/node-artedi#3 Support Prometheus-style counters and histograms

diff --git a/.gitignore b/.gitignore
index c817bc7..4cdb8ee 100644
--- a/.gitignore
+++ b/.gitignore
@@ -1,2 +1,3 @@
 node_modules/
 docs/*.html
+build/
diff --git a/.gitmodules b/.gitmodules
index 62eb074..9254389 100644
--- a/.gitmodules
+++ b/.gitmodules
@@ -4,3 +4,6 @@
 [submodule "deps/jsstyle"]
 	path = deps/jsstyle
 	url = https://github.com/davepacheco/jsstyle.git
+[submodule "deps/restdown"]
+	path = deps/restdown
+	url = https://github.com/trentm/restdown.git
diff --git a/DESIGN.md b/DESIGN.md
new file mode 100644
index 0000000..b647eee
--- /dev/null
+++ b/DESIGN.md
@@ -0,0 +1,2 @@
+# Design
+DESIGN.md to be populated after review of [RFD 99](https://github.com/joyent/rfd/tree/master/rfd/0099).
diff --git a/Makefile b/Makefile
index 6392c48..f54e2a9 100644
--- a/Makefile
+++ b/Makefile
@@ -23,9 +23,7 @@ include ./tools/mk/Makefile.defs
 # Configuration used by Makefile.defs and Makefile.targ to generate
 # "check" and "docs" targets.
 #
-DOC_SRCFILES	 = index.adoc
-DOC_ASSETS	 =
-
+DOC_FILES	 = README.md
 JSON_FILES	 = package.json
 JS_FILES	:= $(shell find lib test -name '*.js')
 JSL_FILES_NODE	 = $(JS_FILES)
@@ -33,44 +31,47 @@ JSSTYLE_FILES	 = $(JS_FILES)
 
 JSL_CONF_NODE	 = tools/jsl.node.conf
 JSSTYLE_FLAGS	 = -f tools/jsstyle.conf
+ESLINT		:= ./node_modules/.bin/eslint
+ESLINT_CONF	:= tools/eslint.node.conf
+ESLINT_FILES	:= $(JS_FILES)
 
-include ./tools/mk/Makefile.defs
 include ./tools/mk/Makefile.node_deps.defs
 
 #
 # Repo-specific targets
 #
 .PHONY: all
-all: $(SMF_MANIFESTS) | $(TAP) $(REPO_DEPS)
+all: $(TAP) $(REPO_DEPS)
 	$(NPM) rebuild
 
 $(TAP): | $(NPM_EXEC)
 	$(NPM) install
+
 $(JSON): | $(NPM_EXEC)
 	$(NPM) install
 
-CLEAN_FILES += $(TAP) ./node_modules/tap
+CLEAN_FILES += ./node_modules
 
 .PHONY: test
 test: $(TAP)
 	TAP=1 $(TAP) test/*.test.js
 
-.PHONY: coverage
-coverage: all
-	$(NPM_EXEC) install istanbul && \
-	    ./node_modules/.bin/istanbul cover \
-	    $(TAP) test/*.js
+# Before running the 'check' target, we first make sure the 'json' tool is
+# installed locally.
+check:: $(JSON)
 
-DOC_OUTPUTS	 = $(patsubst %.adoc,docs/%.html,$(DOC_SRCFILES))
-docs/%.html: docs/%.adoc
-	asciidoctor -o $@ -b html5 $<
+#
+# Target definitions.  This is where we include the target Makefiles for
+# the "defs" Makefiles we included above.
+#
 
-docs:: $(DOC_OUTPUTS)
+include ./tools/mk/Makefile.deps
 
-.PHONY: ghdocs
-ghdocs: $(DOC_OUTPUTS) $(DOC_ASSETS)
-	./tools/update-ghdocs $(DOC_OUTPUTS) $(DOC_ASSETS)
+ifeq ($(shell uname -s),SunOS)
+	include ./tools/mk/Makefile.node_prebuilt.targ
+else
+	include ./tools/mk/Makefile.node.targ
+endif
 
-include ./tools/mk/Makefile.deps
 include ./tools/mk/Makefile.node_deps.targ
 include ./tools/mk/Makefile.targ
diff --git a/README.adoc b/README.adoc
deleted file mode 100644
index fd0abd1..0000000
--- a/README.adoc
+++ /dev/null
@@ -1,31 +0,0 @@
-:toc: left
-:source-highlighter: pygments
-:doctype: book
-:idprefix:
-:docinfo:
-
-# artedi
-
-## About
-
-`artedi` is a node.js library for measuring fish -- specifically, the fish
-being the services involved in Manta, the Triton Object Store.
-
-## Installation
-
-```
-npm install artedi
-```
-
-## License
-
-MPL-v2
-
-## Contributing
-
-Contributions should be made via the https://cr.joyent.us[Joyent Gerrit].
-
-## Reading documentation online
-
-You can view the https://joyent.github.io/node-artedi[full API documentation]
-rendered online.
diff --git a/README.md b/README.md
index e94f971..2affcd5 100644
--- a/README.md
+++ b/README.md
@@ -1,12 +1,15 @@
 # artedi
+README.md to be populated after review of [RFD 99](https://github.com/joyent/rfd/tree/master/rfd/0099).
 
-<!--
-This file is here because npm doesn't support any format except markdown for
-README files. This way people browsing the package on npmjs.com will get a
-link to the documentation instead of nothing.
+## License
 
-GitHub prefers .adoc files to .md, so it will render the correct README for
-the repository root.
--->
+MPL-v2
 
-See the [documentation](https://joyent.github.io/node-artedi).
+## Contributing
+
+Contributions should be made via the [Joyent Gerrit](https://cr.joyent.us).
+
+## Reading documentation online
+
+You can view the [full API documentation](https://joyent.github.io/node-artedi)
+rendered online.
diff --git a/deps/restdown b/deps/restdown
new file mode 160000
index 0000000..1b833da
--- /dev/null
+++ b/deps/restdown
@@ -0,0 +1 @@
+Subproject commit 1b833da2199b08c3bc92ef16cf52b0b0d6e4c189
diff --git a/docs/api.adoc b/docs/api.adoc
deleted file mode 100644
index 75eeec3..0000000
--- a/docs/api.adoc
+++ /dev/null
@@ -1,9 +0,0 @@
-:toc: left
-:source-highlighter: pygments
-:doctype: book
-:idprefix:
-:docinfo:
-
-:sectnums:
-# API
-
diff --git a/docs/index.adoc b/docs/index.adoc
deleted file mode 100644
index 65f9e8c..0000000
--- a/docs/index.adoc
+++ /dev/null
@@ -1,11 +0,0 @@
-:toc: left
-:source-highlighter: pygments
-:doctype: book
-:idprefix:
-:docinfo:
-
-include::../README.adoc[]
-
-include::api.adoc[]
-
-# Other documentation
diff --git a/lib/collector.js b/lib/collector.js
new file mode 100644
index 0000000..3238003
--- /dev/null
+++ b/lib/collector.js
@@ -0,0 +1,247 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ *
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+
+var mod_assert = require('assert-plus');
+var mod_vasync = require('vasync');
+var mod_jsprim = require('jsprim');
+var VError = require('verror').VError;
+var MultiError = require('verror').MultiError;
+
+var lib_utils = require('./utils');
+var lib_counter = require('./counter');
+var lib_gauge = require('./gauge');
+var lib_histogram = require('./histogram');
+var lib_common = require('./common');
+
+/*
+ * Serialization formats that this library supports:
+ */
+var FMT_PROM_0_0_4 = 'prometheus-0.0.4';
+
+// FMT_PROM points to the latest Prometheus format spec.
+var FMT_PROM = FMT_PROM_0_0_4;
+
+/*
+ * The Collector object acts as a mostly dumb parent. It doesn't hold metrics,
+ * but it does hold a list of all child metric collectors.
+ *
+ * When the user creates child collectors from this parent collector (by
+ * calling collector.counter(), collector.gauge(), etc.), this object
+ * will create a child collector and then register it.
+ *
+ * Registration serves two purposes:
+ * 1) It gives the user the ability to call collector.collect() to retrieve
+ *      parseable metrics from ALL child collectors without explicitly
+ *      calling the collect() function on each child collector.
+ * 2) It persists child collector objects in memory. Collectors keep all of
+ *      their metrics in memory, so to avoid having collectors garbage collected
+ *      we will place them in a map. When the user creates a child collector
+ *      for the first time (a counter, for example), this object will invoke
+ *      the constructor for that collector type to create a new collector.
+ *      Now let's say that the user's program dereferences that collector. This
+ *      object will hold on to the counter so when the user tries to create
+ *      the same counter again (they re-entered the same function as when they
+ *      first created the counter), we can simply return the counter that has
+ *      already been created without having lost any important metrics.
+ *
+ */
+function Collector(options) {
+    mod_assert.optionalObject(options, 'options');
+    if (options) {
+        mod_assert.object(options.labels, 'options.labels');
+    }
+    var err;
+
+    if (options) {
+        this.staticLabels = options.labels;
+        this.staticLabels = lib_utils.trim(this.staticLabels);
+        err = lib_utils.checkValid(this.staticLabels);
+        if (err !== null) {
+            throw new VError(err, 'invalid labels');
+        }
+    } else {
+        this.staticLabels = null;
+    }
+
+    this.registry = {};
+}
+
+/* Public Functions */
+
+/*
+ * The user calls collector.counter(options) to create a 'child' Counter
+ * object from the 'parent' Collector object.
+ */
+Collector.prototype.counter = function counter(options) {
+    return (this.createChild(options, lib_common.COUNTER));
+};
+
+/*
+ * The user calls collector.gauge(options) to create a 'child' Gauge
+ * object from the 'parent' Collector object.
+ */
+Collector.prototype.gauge = function gauge(options) {
+    return (this.createChild(options, lib_common.GAUGE));
+};
+
+/*
+ * The user calls collector.histogram(options) to create a 'child' Histogram
+ * object from the 'parent' Collector object.
+ */
+Collector.prototype.histogram = function histogram(options) {
+    return (this.createChild(options, lib_common.HISTOGRAM));
+};
+
+/*
+ * We will tell each collector that is a child of this Collector to produce
+ * machine-readable output that we can report back to whatever is scraping
+ * this process.
+ *
+ * For example, if this collector has two child collectors (a Counter and
+ * a Histogram), this instructs both to produce Prometheus-style output and
+ * returns it to the caller.
+ */
+Collector.prototype.collect = function collect(format, cb) {
+    mod_assert.string(format, 'format');
+    mod_assert.func(cb, 'cb');
+
+    var str = '';
+    var errors = [];
+    var queue;
+    var multiError = null;
+
+    if (format === FMT_PROM) {
+
+        var promCallback = function promCallback(err, metricString) {
+            mod_assert.string(metricString, 'metricString');
+            if (err) {
+                errors.push(err);
+            }
+            str += metricString;
+        };
+
+        var dispatchCollect = function dispatchCollect(collector, callback) {
+            collector.prometheus(callback);
+        };
+
+        queue = mod_vasync.queue(dispatchCollect, 10);
+        mod_jsprim.forEachKey(this.registry, function (_, collector) {
+            queue.push(collector, promCallback);
+        });
+        queue.close();
+
+    } else {
+        errors.push(new VError('Unknown serialization format: ' + format));
+        cb(multiError, str);
+        return;
+    }
+
+    queue.once('end', function () {
+        if (errors.length > 0) {
+            multiError = new MultiError(errors);
+        }
+        cb(multiError, str);
+    });
+};
+
+
+
+/* Private Functions */
+/*
+ * Creates a child collector object with the given type (counter, for example).
+ *
+ * The 'options' structure passed in may include labels that should be used
+ * by the child. In addition, this function appends any additional labels that
+ * have been defined on the parent Collector.
+ *
+ * - If a collector with the given name and type already exists, it is returned.
+ * - If a collector with the given name, but a different type already exists,
+ *   an error is thrown.
+ * - If a collector with the given name and type does not exist, a new child is
+ *   created and returned.
+ */
+Collector.prototype.createChild = function createChild(options, type) {
+    mod_assert.object(options, 'options');
+    mod_assert.string(options.name, 'options.name');
+    mod_assert.string(options.help, 'options.help');
+    mod_assert.optionalObject(options.labels, 'options.labels');
+    var opts;
+    var err;
+    var child;
+
+    child = this.getCollector(options.name);
+    if (child === null || child === undefined) {
+        opts = lib_utils.shallowClone(options);
+        opts.labels = options.labels;
+        err = lib_utils.checkValidCollector(opts.name, opts.help);
+        if (err) {
+            throw new VError(err, 'invalid collector name/help');
+        }
+
+        // Include staticLabels, which are inherited from the parent Collector.
+        opts.parentLabels = this.staticLabels;
+
+        // Create a child of the corresponding type.
+        if (type === lib_common.COUNTER) {
+            child = new lib_counter.Counter(opts);
+        } else if (type === lib_common.GAUGE) {
+            child = new lib_gauge.Gauge(opts);
+        } else if (type === lib_common.HISTOGRAM) {
+            child = new lib_histogram.Histogram(opts);
+        } else {
+            throw new VError('Unknown type: ' + type);
+        }
+
+        err = this.register(child);
+        if (err) {
+            throw new VError(err, 'unable to create ' + type);
+        }
+    } else if (child.type !== type) {
+        // Prevent the user from overwriting collectors.
+        throw new VError('collector with name "%s" already registered',
+                options.name);
+    }
+
+    return (child);
+};
+
+
+/*
+ * Registers the given collector in this Collector's registry. If a collector
+ * already exists with the given name, and error is returned.
+ */
+Collector.prototype.register = function register(collector) {
+    mod_assert.object(collector, 'collector');
+    mod_assert.string(collector.name, 'collector.name');
+
+    if (this.getCollector(collector.name) !== null) {
+        return new VError('collector with name already registered: %s',
+                collector.name);
+    }
+    this.registry[collector.name] = collector;
+    return (null);
+};
+
+/*
+ * Finds finds the named collector in the registry and returns it. If none
+ * exists, returns 'null.'
+ */
+Collector.prototype.getCollector = function getCollector(name) {
+    if (!mod_jsprim.hasKey(this.registry, name)) {
+        return (null);
+    }
+    return (this.registry[name]);
+};
+
+module.exports = {
+    createCollector: function createCollector(options) {
+        return (new Collector(options));
+    },
+    FMT_PROM: FMT_PROM,
+    FMT_PROM_0_0_4: FMT_PROM_0_0_4
+};
diff --git a/lib/index.js b/lib/common.js
similarity index 58%
rename from lib/index.js
rename to lib/common.js
index b22916b..5023885 100644
--- a/lib/index.js
+++ b/lib/common.js
@@ -6,3 +6,11 @@
  * Copyright (c) 2017, Joyent, Inc.
  */
 
+/*
+ * These are a few global constants used in various places in this library.
+ */
+module.exports = {
+    COUNTER: 'counter',
+    GAUGE: 'gauge',
+    HISTOGRAM: 'histogram'
+};
diff --git a/lib/counter.js b/lib/counter.js
new file mode 100644
index 0000000..d85b431
--- /dev/null
+++ b/lib/counter.js
@@ -0,0 +1,102 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ *
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+var mod_util = require('util');
+
+var mod_assert = require('assert-plus');
+var mod_jsprim = require('jsprim');
+var VError = require('verror').VError;
+
+var lib_metric_vector = require('./metric_vector');
+var lib_common = require('./common');
+
+/*
+ * A Counter is a type of collector that can only increase in value by calling
+ * functions 'add()' and 'increment()'.
+ */
+function Counter(options) {
+    mod_assert.object(options, 'options');
+    mod_assert.string(options.name, 'options.name');
+    mod_assert.string(options.help, 'options.help');
+    mod_assert.optionalObject(options.labels, 'options.labels');
+    mod_assert.optionalObject(options.parentLabels, 'options.parentLabels');
+
+    this.staticLabels =
+        mod_jsprim.mergeObjects(options.labels, options.parentLabels, null);
+
+    // Create a full metric name that looks
+    // like 'muskie_audit_requests_completed'.
+    this.name = options.name;
+    this.help = options.help;
+    this.metricVec = new lib_metric_vector.MetricVector({
+        name: this.name,
+        labels: this.staticLabels
+    });
+    this.type = lib_common.COUNTER;
+}
+
+/* Public Functions */
+/*
+ * Add '1' to the Metric represented by the labels 'pairs.' This uses the
+ * 'labels()' function to find the metric represented by 'pairs.'
+ */
+Counter.prototype.increment = function increment(pairs) {
+    this.add(1, pairs);
+};
+
+/*
+ * Add 'value' to the Metric represented by the labels 'pairs.' This uses the
+ * 'labels()' function to find the metric represented by 'pairs.'
+ */
+Counter.prototype.add = function add(value, pairs) {
+    mod_assert.optionalObject(pairs, 'pairs');
+    mod_assert.number(value, 'value');
+    if (value < 0) {
+        throw new VError('adding negative values to counters ' +
+                'is not allowed:', value);
+    }
+
+    // Get the metric associated with the labels passed in.
+    // This will create the metric if one does not exist.
+    var metric = this.labels(pairs);
+    metric.add(value);
+};
+
+/* Private Functions */
+/*
+ * Returns a Metric object that represents the labels passed in. If a Metric
+ * exists with the given labels in the MetricVector, it will be returned without
+ * creating a new Metric. If no labels are specified, the 'default' metric
+ * (that is, the Metric with no labels) is returned.
+ */
+Counter.prototype.labels = function labels(pairs) {
+    mod_assert.optionalObject(pairs);
+    if (!pairs || mod_jsprim.isEmpty(pairs)) { // User passed in '{}'.
+        return (this.metricVec.getDefault());
+    }
+
+    return (this.metricVec.createOrGetWithLabels(pairs));
+};
+
+/*
+ * Call the 'prometheus()' function on the MetricVector object, which represents
+ * all of the metrics. Additionally, append the HELP and TYPE lines that are
+ * specific to this metric.
+ */
+Counter.prototype.prometheus = function prometheus(cb) {
+    var str = mod_util.format('%s %s %s\n', '# HELP', this.name, this.help);
+    str += mod_util.format('%s %s %s\n', '# TYPE', this.name, this.type);
+
+    this.metricVec.prometheus(function (err, metrics) {
+        str += metrics;
+        cb(err, str);
+    });
+};
+
+module.exports = {
+    Counter: Counter
+};
diff --git a/lib/gauge.js b/lib/gauge.js
new file mode 100644
index 0000000..1efef03
--- /dev/null
+++ b/lib/gauge.js
@@ -0,0 +1,88 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ *
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+var mod_util = require('util');
+
+var mod_assert = require('assert-plus');
+var mod_jsprim = require('jsprim');
+
+var lib_metric_vector = require('./metric_vector');
+var lib_common = require('./common');
+
+/*
+ * A Gauge is a type of collector that can increase and decrease in value.
+ * This Gauge only supports 'relative' movement of values through the 'add()'
+ * function.
+ */
+function Gauge(options) {
+    mod_assert.object(options, 'options');
+    mod_assert.string(options.name, 'options.name');
+    mod_assert.string(options.help, 'options.help');
+    mod_assert.optionalObject(options.labels, 'options.labels');
+    mod_assert.optionalObject(options.parentLabels, 'options.parentLabels');
+
+    this.staticLabels =
+        mod_jsprim.mergeObjects(options.parentLabels, options.labels, null);
+
+    this.help = options.help;
+    this.type = lib_common.GAUGE;
+    this.name = options.name;
+    this.metricVec = new lib_metric_vector.MetricVector({
+        name: this.name,
+        labels: this.staticLabels
+    });
+}
+
+ /*
+  * Add 'value' to the Metric represented by the labels, 'pairs.' This uses the
+  * 'labels()' function to find the metric represented by 'pairs.'
+  */
+Gauge.prototype.add = function add(value, pairs) {
+    mod_assert.optionalObject(pairs, 'pairs');
+    mod_assert.number(value, 'value');
+
+    var metric = this.labels(pairs);
+    metric.add(value);
+};
+
+/* Private Functions */
+/*
+ * Returns a Metric object that represents the labels passed in. If a Metric
+ * exists with the given labels in the MetricVector, it will be returned without
+ * creating a new Metric. If no labels are specified, the 'default' metric
+ * (that is, the Metric with no labels) is returned.
+ */
+Gauge.prototype.labels = function labels(pairs) {
+    mod_assert.optionalObject(pairs, 'pairs');
+
+    if (!pairs || mod_jsprim.isEmpty(pairs)) {
+        return (this.metricVec.getDefault());
+    }
+
+    return (this.metricVec.createOrGetWithLabels(pairs));
+};
+
+/*
+ * Call the 'prometheus()' function on the MetricVector object, which represents
+ * all of the metrics. Additionally, append the HELP and TYPE lines that are
+ * specific to this metric.
+ */
+Gauge.prototype.prometheus = function prometheus(cb) {
+    mod_assert.func(cb, 'cb');
+    var str = mod_util.format('%s %s %s\n', '# HELP', this.name, this.help);
+    str += mod_util.format('%s %s %s\n', '# TYPE', this.name, this.type);
+
+    this.metricVec.prometheus(function (err, metrics) {
+        str += metrics;
+        cb(err, str);
+    });
+
+};
+
+module.exports = {
+    Gauge: Gauge
+};
diff --git a/lib/histogram.js b/lib/histogram.js
new file mode 100644
index 0000000..c12db74
--- /dev/null
+++ b/lib/histogram.js
@@ -0,0 +1,328 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ *
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+var mod_util = require('util');
+
+var mod_assert = require('assert-plus');
+var mod_jsprim = require('jsprim');
+var VError = require('verror').VError;
+
+var lib_utils = require('./utils');
+var lib_counter = require('./counter');
+var lib_gauge = require('./gauge');
+var lib_common = require('./common');
+
+/*
+ * A Histogram is a type of collector that represents a series of Counters. Each
+ * Counter corresponds to a certain range of values, called 'buckets.'
+ */
+function Histogram(options) {
+    mod_assert.object(options, 'options');
+    mod_assert.string(options.name, 'options.name');
+    mod_assert.string(options.help, 'options.help');
+    mod_assert.optionalObject(options.labels, 'options.labels');
+    mod_assert.optionalObject(options.parentLabels, 'options.parentLabels');
+
+    this.staticLabels =
+        mod_jsprim.mergeObjects(options.parentLabels, options.labels, null);
+
+    this.name = options.name;
+    this.help = options.help;
+    this.type = lib_common.HISTOGRAM;
+
+    this.counters = {};
+    this.gauge = new lib_gauge.Gauge(options);
+}
+
+/* Public Functions */
+/*
+ * Determine which bucket the observed 'value' falls into, and increment all the
+ * Counters >= that observed value. The '+Inf' Counter is always incremented,
+ * and a Gauge is created to track the running sum of values observed.
+ */
+Histogram.prototype.observe = function observe(value, pairs) {
+    mod_assert.number(value, 'value');
+    mod_assert.optionalObject(pairs, 'pairs');
+    if (value < 0) {
+        throw new VError('observe must be called with a value >= 0: %d', value);
+    }
+
+    var counter;
+    var pairCopy;
+    var buckets;
+    var index, count, i, bucket;
+    var smaller;
+
+    // For log-linear bucketing, we will produce five linear steps per log jump.
+    // At a point in the future, we may allow the user to provide this value,
+    // but five seems like a reasonable default.
+    var linearSteps = 5;
+
+    pairs = mod_jsprim.mergeObjects(pairs, this.staticLabels, null);
+    counter = this.labels(pairs);
+
+    // Make a copy of the labels sent in.
+    pairCopy = mod_jsprim.deepCopy(pairs);
+
+    /* Begin setting initial value for new buckets (if applicable). */
+
+    // Determine which bucket from the new order our value falls into.
+    buckets = getOrder(value, linearSteps);
+    if (!buckets) {
+        // The value passed in is too big (> 10 billion), so we just increment
+        // the +Inf counter, and add to the Gauge.
+        counter.increment({
+            le: '+Inf'
+        });
+        this.gauge.add(value, counter.staticLabels);
+        return;
+    }
+
+    // Find the largest bucket that the observed value falls into.
+    for (bucket in buckets) {
+        if (value <= buckets[bucket]) {
+            index = buckets[bucket];
+            break;
+        }
+    }
+
+    // Find the next-smallest bucket from the list of already-used buckets.
+    // The buckets are sorted when they are added to a metric vector.
+    for (bucket in counter.metricVec.buckets) {
+        if (counter.metricVec.buckets[bucket] < index) {
+            smaller = bucket;
+        }
+    }
+
+    // Check to see if the proper bucket for this value already exists in
+    // the bucket list.
+    if (counter.metricVec.buckets.indexOf(index) === -1) {
+        counter.metricVec.addBuckets(buckets);
+        if (smaller) {
+            // Copy value from the next-smallest bucket into the newly created
+            // buckets.
+            pairCopy['le'] = counter.metricVec.buckets[smaller];
+            count = counter.labels(pairCopy).value;
+            if (count > 0) {
+                for (bucket in buckets) {
+                    // In the case of overlapping buckets, we don't want to
+                    // double the value of the bucket.
+                    if (buckets[bucket] !==
+                            counter.metricVec.buckets[smaller]) {
+                        pairCopy['le'] = buckets[bucket];
+                        counter.add(count, pairCopy); // Set the initial value.
+                    }
+                }
+            }
+        }
+    }
+    /* Done setting initial value for new buckets. */
+
+    // Now we need to increment the Counters for the buckets >= the value
+    // passed in.
+    buckets = counter.metricVec.buckets;
+    index = buckets.indexOf(index);
+    for (i = 0; i < buckets.length; i++) {
+        pairCopy['le'] = buckets[i];
+        if (i < index) {
+            // We don't need to increment buckets that are smaller than what we
+            // received, but we do want to zero them out if they don't exist.
+            counter.labels(pairCopy);
+            continue;
+        }
+        counter.increment(pairCopy);
+    }
+
+    // Always increment the Inf Counter.
+    counter.increment({
+        le: '+Inf'
+    });
+
+    // There is a gauge for each counter so we can keep track
+    // of the _sum field (which can move up or down).
+    this.gauge.add(value, counter.staticLabels);
+};
+
+/* Private Functions */
+/*
+ * Returns a Counter associated with the givel labels, 'pairs,' and initializes
+ * a Gauge which will be used to track the sum of the values added to the
+ * Counter.
+ */
+Histogram.prototype.labels = function labels(pairs) {
+    mod_assert.optionalObject(pairs);
+    if (!pairs || mod_jsprim.isEmpty(pairs)) {
+        return (this.defaultCounter());
+    }
+    var lhash;
+    var opts;
+    var my_counter;
+
+    pairs = lib_utils.trim(pairs);
+    lhash = lib_utils.hashObj(pairs);
+    if (this.counters[lhash]) {
+        // We have already recorded this Counter.
+        return (this.counters[lhash]);
+    }
+
+    // Before we create the Counter, append the static labels.
+    pairs = mod_jsprim.mergeObjects(pairs, this.staticLabels, null);
+
+    // Create a new Counter.
+    opts = {
+        name: this.name,
+        help: this.help,
+        labels: pairs
+    };
+    my_counter = new lib_counter.Counter(opts);
+    this.gauge.labels(my_counter.staticLabels); // Initialize the gauge.
+
+    this.counters[lhash] = my_counter;
+    return (my_counter);
+};
+
+/*
+ * The 'prometheus()' function for Histograms is more complicated than that of
+ * Counters and Gauges.
+ *
+ * Each Counter represents a number of Metrics (via MetricVectors), so we
+ * call 'prometheus()' on each Counter's underlying MetricVector object. After
+ * we serialize each Counter, we synthesize the '_count' field and append the
+ * '_sum' field. The '_count' field carries the same value as the corresponding
+ * Counter's '+Inf' label.
+ */
+Histogram.prototype.prometheus = function prometheus(cb) {
+    mod_assert.func(cb, 'callback');
+    var str = '';
+    var labelStr = '';
+    var counter;
+    var keys;
+    var countLabels, key, labelObj, label;
+
+    var infHash = lib_utils.hashObj({le: '+Inf'});
+
+    str = mod_util.format('%s %s %s\n', '# HELP', this.name, this.help);
+    str += mod_util.format('%s %s %s\n', '# TYPE', this.name, this.type);
+
+    /*
+     * We're digging deep in this loop.
+     * The objective of this code is to get each Counter's MetricVec
+     * to report its metrics in the prometheus style. But we don't want the
+     * Counter itself to do that reporting, since then it would add on the
+     * '# TYPE' and '# HELP' headers.
+     *
+     * In addition, we need to serialize extra fields, like the _sum and _count
+     * fields. Both of these fields are reported based on label key/value
+     * combinations. That information is stored in each of the Metric objects.
+     */
+    var promCallback = function (err, metrics) {
+        if (err) {
+            cb(null, err);
+        }
+        str += metrics;
+    };
+    for (counter in this.counters) {
+        // Bypass the Counter object's .prometheus function, and instead
+        // call it on the metricVector itself.
+        this.counters[counter].metricVec.prometheus(promCallback);
+
+        // Get the last object in the metric vector. All of the metrics
+        // within a metric vector have the same labels.
+        keys = Object.keys(this.counters[counter].metricVec.metrics);
+        key = keys[0];
+        labelStr = '';
+        labelObj = {};
+        countLabels = this.counters[counter].metricVec.metrics[key].labels;
+        for (label in countLabels) {
+            if (label !== 'le') {
+                // Ignore the internal 'le' label.
+                labelStr += mod_util.format('%s="%s",',
+                        label, countLabels[label]);
+                labelObj[label] = countLabels[label];
+            }
+        }
+        // Chop off the trailing ','
+        labelStr = labelStr.substring(0, labelStr.length - 1);
+
+        // Create the _count metric.
+        str += mod_util.format('%s_count{%s}', this.name, labelStr);
+
+        // Append the +Inf value to the _count field, since they are the same.
+        str += mod_util.format(' %s %d\n',
+                this.counters[counter].metricVec.metrics[infHash].value,
+                this.counters[counter].metricVec.metrics[infHash].timestamp);
+
+        // Read the _sum Gauge.
+        str += mod_util.format('%s_sum{%s}', this.name, labelStr);
+        str += mod_util.format(' %d %d\n', this.gauge.labels(labelObj).value,
+            this.gauge.labels(labelObj).timestamp);
+    }
+
+    cb(null, str);
+};
+
+/*
+ * Returns a Counter with no labels. This is used when an observation is made
+ * with no labels.
+ */
+Histogram.prototype.defaultCounter = function defaultCounter() {
+    var opts;
+    if (!this.counters['default']) {
+        opts = {
+            name: this.name,
+            help: this.help,
+            labels: this.staticLabels
+        };
+        this.counters['default'] = new lib_counter.Counter(opts);
+    }
+    return (this.counters['default']);
+};
+
+/*
+ * Find (and return) a list of linear numbers that 'value' falls into.
+ * The 'steps' argument is provided, as we may allow the user to specify
+ * the number of linear 'steps' between logarithmic jumps. This idea is taken
+ * from DTrace's log/linear quantization ('llquantize()').
+ */
+function getOrder(value, steps) {
+    var i, j, val, width, next;
+    var buckets = [];
+
+    // These values are relatively arbitrary. It's possible that we may want to
+    // allow the user to change these at some point.
+    var factor = 10;
+    var low = 0;
+
+    // This is an arbitrary high watermark. Setting this allows us to ensure
+    // that our loop will always exit.
+    // The maximum value that we can observe (without it falling into only the
+    // +Inf bucket is 10^10, or 10,000,000,000.
+    var high = 10;
+
+    val = 1;
+    for (i = low; i <= high; i++) {
+        next = val * factor;
+        width = next > steps ? next / steps : 1;
+
+        for (j = 0; val <= next; val += width, j++) {
+            buckets[j] = val;
+        }
+
+        // Overlap buckets so we get something like:
+        // [0-10], [10-100], [100-1000].
+        val -= width;
+        if (value <= buckets[buckets.length - 1]) {
+            // The number is within this order.
+            return (buckets);
+        }
+    }
+    return (null);
+}
+
+module.exports = {
+    Histogram: Histogram
+};
diff --git a/lib/metric.js b/lib/metric.js
new file mode 100644
index 0000000..051b928
--- /dev/null
+++ b/lib/metric.js
@@ -0,0 +1,42 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ *
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+
+var mod_assert = require('assert-plus');
+
+/*
+ * Basic building block for counters and gauges. This object is not intended to
+ * be used directly by users.
+ * This object exposes the basic functionality of metrics, like
+ * add(), subtract(), and observe(). The higher layers (counters, gauges,
+ * summaries, histograms) will wrap these functions and restrict access
+ * to only the functions that are supported by the collector type (for example,
+ * counters can only call add() while gauges can call either add() or subtract()
+ * but not observe()).
+ */
+function Metric(options) {
+    mod_assert.optionalObject(options, 'options');
+    this.labels = options ? options.labels : {};
+    this.value = 0;
+    this.timestamp = 0;
+}
+
+/*
+ * Building block for upper-level functions like add(), subtract(),
+ * observe() (because it uses Counters). This does not check
+ * for positive/negative values. That should be handled at an upper layer.
+ */
+Metric.prototype.add = function add(num) {
+    mod_assert.number(num, 'num');
+
+    this.value += num;
+    this.timestamp = Date.now(); // Current unix time in milliseconds.
+};
+
+module.exports = {
+    Metric: Metric
+};
diff --git a/lib/metric_vector.js b/lib/metric_vector.js
new file mode 100644
index 0000000..0620645
--- /dev/null
+++ b/lib/metric_vector.js
@@ -0,0 +1,162 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ *
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+
+var mod_util = require('util');
+
+var mod_assert = require('assert-plus');
+var mod_jsprim = require('jsprim');
+var VError = require('verror').VError;
+
+var lib_metric = require('./metric');
+var lib_utils = require('./utils');
+
+/*
+ * MetricVectors are used to keep track of multiple metrics in one object.
+ * This is useful when the collector type can handle multiple label key/value
+ * pairs. A good example of this is counting web requests, and metering them
+ * based on method, and return code. There will be many different values for
+ * both 'method' and 'return code', but they are logically the same metric, so
+ * we can use metric vectors to accomplish that abstraction.
+ *
+ * This object is not intended to be used directly by users.
+ *
+ */
+function MetricVector(opts) {
+    mod_assert.string(opts.name, 'opts.name');
+    mod_assert.optionalObject(opts.labels, 'opts.labels');
+
+    this.name = opts.name;
+    this.metrics = {};
+
+    this.staticLabels = opts.labels;
+    if (this.staticLabels) {
+        this.staticLabels = lib_utils.trim(this.staticLabels);
+        var err = lib_utils.checkValid(this.staticLabels);
+        if (err !== null) {
+            throw new VError(err, 'invalid labels');
+        }
+    }
+    this.buckets = []; // Used for Histograms.
+}
+
+/*
+ * Appends 'newBuckets' to the list of buckets currently managed by this
+ * MetricVector.
+ */
+MetricVector.prototype.addBuckets = function addBuckets(newBuckets) {
+    newBuckets.forEach(function (bucket) {
+        if (this.buckets.indexOf(bucket) === -1) {
+            this.buckets.push(bucket);
+        }
+    }, this);
+    this.buckets.sort(function (a, b) { return a - b; });
+};
+
+/*
+ * Returns a Metric with no labels, or with only the static labels defined
+ * for this MetricVector.
+ */
+MetricVector.prototype.getDefault = function getDefault() {
+    // defaultMetric is a metric with only static labels (if provided).
+    if (!this.metrics['default']) {
+        this.metrics['default'] = new lib_metric.Metric({
+            labels: this.staticLabels
+        });
+    }
+    return (this.metrics['default']);
+};
+
+/*
+ * Returns a previously-created Metric representing 'labels,' or 'null' if
+ * the Metric has not been created.
+ */
+MetricVector.prototype.getWithLabels = function getWithLabels(labels) {
+    mod_assert.object(labels, 'labels');
+    var lhash = lib_utils.hashObj(labels);
+    return (this.metrics[lhash] || null);
+};
+
+/*
+ * Returns a newly-created Metric representing 'labels.'
+ */
+MetricVector.prototype.createWithLabels = function createWithLabels(labels) {
+    mod_assert.object(labels, 'labels');
+    var copy = lib_utils.shallowClone(labels);
+    var lhash = lib_utils.hashObj(copy);
+
+    // Before we create the metric, append the static labels.
+    if (this.staticLabels) {
+        for (var label in this.staticLabels) {
+            copy[label] = this.staticLabels[label];
+        }
+    }
+
+    this.metrics[lhash] = new lib_metric.Metric({labels: copy});
+    return (this.metrics[lhash]);
+};
+
+/*
+ * Create, or retrieve a Metric representing 'labels.' This calls
+ * 'getWithLabels(),' followed by 'createWithLabels()' if the Metric doesn't
+ * exist.
+ */
+MetricVector.prototype.createOrGetWithLabels =
+    function createOrGetWithLabels(labels) {
+    mod_assert.object(labels, 'labels');
+    var met = this.getWithLabels(labels);
+    if (typeof (met) !== 'undefined' && met !== null) {
+        return (met);
+    }
+    return (this.createWithLabels(labels));
+};
+
+/*
+ * Serialize this object into the format of prometheus metrics.
+ * For example:
+ *
+ * # HELP http_requests_completed count of muskie requests completed
+ * # TYPE http_requests_completed counter
+ * http_requests_completed{method="getmetrics",code="200"} 505
+ * http_requests_completed{method="getstorage",code="404"} 1
+ * http_requests_completed{method="headstorage",code="200"} 3
+ * http_requests_completed{method="getstorage",code="200"} 1
+ * http_requests_completed{method="putobject",code="204"} 33
+ * http_requests_completed{method="putdirectory",code="204"} 173
+ * http_requests_completed{method="putdirectory",code="403"} 1
+ *
+ */
+MetricVector.prototype.prometheus = function prometheus(cb) {
+    mod_assert.func(cb, 'cb');
+    var str = '';
+    var labelStr = '';
+    var name = this.name;
+
+    var appendLabel = function (key, value) {
+            labelStr += mod_util.format('%s="%s",', key, value);
+    };
+
+    // TODO O(M*N) - make faster?
+    mod_jsprim.forEachKey(this.metrics, function (_, metric) {
+        // Generate the labels and their values.
+        mod_jsprim.forEachKey(metric.labels, appendLabel);
+
+        // Chop off trailing ','.
+        labelStr = labelStr.substring(0, labelStr.length - 1);
+
+        // Put together the whole string.
+        str += mod_util.format('%s{%s} %d %d\n', name, labelStr, metric.value,
+            metric.timestamp);
+
+        labelStr = '';
+    });
+    cb(null, str);
+};
+
+module.exports = {
+    MetricVector: MetricVector
+};
diff --git a/lib/utils.js b/lib/utils.js
new file mode 100644
index 0000000..a95b075
--- /dev/null
+++ b/lib/utils.js
@@ -0,0 +1,138 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ *
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+
+var mod_assert = require('assert-plus');
+var mod_jsprim = require('jsprim');
+var VError = require('verror').VError;
+
+var mod_md5 = require('md5');
+
+/*
+ * This is a similar regex to the one used in the golang prometheus client lib.
+ * The Go client doesn't validate against a regex (citing bad performance), and
+ * actually have a hard-coded `if` statement that checks each string.
+ * That's something we could consider if we see performance issues with this.
+ *
+ * Also, if we want to support multiple formats we can do away with this and
+ * only check for validity at the time when we serialize the metrics.
+ */
+var regex = new RegExp('^[a-zA-Z_][a-zA-Z0-9_]*$');
+
+function shallowClone(obj) {
+    mod_assert.object(obj, 'obj');
+
+    var clone = {};
+    mod_jsprim.forEachKey(obj, function (key, value) {
+        clone[key] = value;
+    });
+
+    return (clone);
+}
+
+/*
+ * To ensure that we don't store duplicate metrics, we must hash all of
+ * the metrics before they're stored. This function takes an object of labels.
+ * The labels are sorted alphabetically, sent through stringify, and then their
+ * md5 hash is calculated. This should be adequately unique for our case.
+ */
+function hashObj(obj) {
+    mod_assert.object(obj, 'obj');
+
+    var newObj = {};
+    var keys = Object.keys(obj).sort();
+    keys.forEach(function (key) {
+        newObj[key] = obj[key];
+    });
+    return (mod_md5(JSON.stringify(newObj)));
+}
+
+/*
+ * Loop through the label object, trim off left- and right- whitespace.
+ */
+function trim(labels) {
+    mod_assert.object(labels, 'labels');
+
+    var keys = Object.keys(labels);
+    var trimmed = keys.reduce(function (newObj, key) {
+        newObj[key.trim()] = typeof (labels[key]) === 'string' ?
+            labels[key].trim() : labels[key];
+        return (newObj);
+    }, {});
+
+    return (trimmed);
+
+}
+
+/*
+ * Check the name and help strings given to collectors.
+ */
+function checkValidCollector(name, help) {
+    var err = null;
+
+    // Collector names must be strings, and pass the regex test.
+    if (typeof (name) !== 'string' || regex.test(name) === false) {
+        err = new VError('name "%s" must match regex "%s', name, regex);
+    }
+
+    // Collector 'help' messages must be strings.
+    if (typeof (help) !== 'string') {
+        err = new VError('help "%s" must be a string', help);
+    }
+
+    return (err);
+}
+
+/*
+ * Check the validity of labels.
+ */
+function checkValid(labels) {
+    mod_assert.optionalObject(labels, 'labels');
+
+    var err = null;
+    if (!labels) {
+        return (null);
+    }
+
+    mod_jsprim.forEachKey(labels, function (name, value) {
+        if (err !== null) {
+            // Short-circuit the rest of the for-each functions if we've already
+            // found an invalid string.
+            return;
+        }
+
+        // Test the label name for validity.
+        if (typeof (name) === 'string') {
+            if (regex.test(name) === false) {
+                err = new VError('label key "%s" must match regex "%s"',
+                    name, regex);
+                return;
+            }
+        } else {
+            err = new VError('label key must be a string', name);
+            return;
+        }
+
+        // Test the label value for validity.
+        if (typeof (value) !== 'string' && typeof (value) !== 'number' &&
+                typeof (value) !== 'boolean') {
+            err = new VError('label value "%s" must be one of ' +
+                    '[string, number, bool]',
+                    value, typeof (value));
+            return;
+        }
+    });
+    return (err);
+}
+
+module.exports = {
+    shallowClone: shallowClone,
+    hashObj: hashObj,
+    checkValidCollector: checkValidCollector,
+    checkValid: checkValid,
+    trim: trim
+};
diff --git a/package.json b/package.json
index 5d1189a..8500a5a 100644
--- a/package.json
+++ b/package.json
@@ -1,23 +1,24 @@
 {
   "name": "artedi",
-  "version": "0.1.0",
-  "description": "measuring fish",
-  "main": "lib/index.js",
+  "version": "1.0.0",
+  "description": "a metric client library",
+  "main": "lib/collector.js",
   "dependencies": {
-    "assert-plus": ">=1.0.0 <2.0.0",
-    "bunyan": ">=1.5.1 <2.0.0",
-    "mooremachine": ">=2.1.0 <3.0.0",
-    "vasync": ">=1.6.3 <2.0.0",
-    "verror": ">=1.6.1 <2.0.0"
-  },
-  "optionalDependencies": {
-    "dtrace-provider": "~0.8"
+    "assert-plus": "1.0.0",
+    "jsprim": "1.4.0",
+    "md5": "2.2.1",
+    "vasync": "1.6.4",
+    "verror": "1.10.0"
   },
   "devDependencies": {
-    "tape": ">=4.4.0 <5.0.0",
-    "sinon": ">=1.17.3 <2.0.0",
-    "json": ">=9.0.3 <10.0.0",
-    "restify": "^4.3.0"
+    "eslint": "2.13.1",
+    "eslint-plugin-joyent": "1.1.0",
+    "json": "9.0.6",
+    "tape": "4.6.3"
+  },
+  "repository": {
+    "url": "https://github.com/joyent/node-artedi.git",
+    "type": "git"
   },
   "engines": {
     "node": ">=0.10.0"
@@ -25,6 +26,6 @@
   "scripts": {
     "test": "tape test/*.test.js"
   },
-  "author": "",
+  "author": "Joyent, Inc",
   "license": "MPL-2.0"
 }
diff --git a/test/basic.test.js b/test/basic.test.js
index 4ef2aca..5cf0bb6 100644
--- a/test/basic.test.js
+++ b/test/basic.test.js
@@ -7,9 +7,530 @@
  */
 
 var mod_tape = require('tape');
+var mod_vasync = require('vasync');
 
 var mod_artedi = require('..');
 
-mod_tape.test('empty test', function (t) {
-	t.end();
+var common = require('../lib/common.js');
+
+/*
+ * Test that the parent/child relationship is working.
+ * - Empty strings
+ */
+mod_tape('parent/child tests', function (t) {
+    var collector = mod_artedi.createCollector();
+
+    var obj = {
+        name: 'test_awesome',
+        help: 'help me!'
+    };
+    var counter = collector.counter(obj);
+
+    // Make sure the fullName is being created properly.
+    t.equals(counter.name, 'test_awesome', 'basic full name');
+    // Make sure the child collector was registered.
+    t.ok(collector.registry[counter.name], 'metric registered');
+
+    // Test preventing the user from accidentally
+    // overwriting collectors in the collector registry.
+    // This gauge has the same full name as the counter previously created.
+    t.throws(function () {
+        var gauge = collector.gauge(obj);
+        gauge.add(100); // This line should not execute.
+    }, 'duplicate collector with same name');
+
+    // getCollector should return a child collector from the parent.
+    t.ok(collector.getCollector(counter.name), 'get collector by name');
+
+    t.end();
+});
+
+mod_tape('trim functionality tests', function (t) {
+    var utils = require('../lib/utils');
+    var myObj = {
+        '         kevin': 'spacey        '
+    };
+    var targetObj = {
+        'kevin': 'spacey'
+    };
+
+    var trimObj = utils.trim(myObj);
+    t.deepEquals(trimObj, targetObj, 'left- and right-trim');
+
+    myObj = {
+        '   neil   ': ' armstrong  ',
+        'buzz ': 'aldrin',
+        'chris ': ' hadfield',
+        'lightyear': ' buzz '
+    };
+    targetObj = {
+        'neil': 'armstrong',
+        'buzz': 'aldrin',
+        'chris': 'hadfield',
+        'lightyear': 'buzz'
+    };
+
+    trimObj = utils.trim(myObj);
+    t.deepEquals(trimObj, targetObj, 'left- and right-trim of multiple labels');
+
+
+    t.end();
+});
+
+mod_tape('hash tests', function (t) {
+    var utils = require('../lib/utils');
+
+    var obj1 = {
+        a: 'b',
+        b: 'a'
+    };
+    var obj2 = {
+        b: 'a',
+        a: 'b'
+    };
+
+    var hash1 = utils.hashObj(obj1);
+    var hash2 = utils.hashObj(obj2);
+
+    t.equals(hash1, hash2, 'consistent hashing with unordered objects');
+    t.end();
+});
+
+
+/*
+ * Test that labels are working properly.
+ * A few things to test:
+ * - Invalid label names                x
+ * - No labels                          x
+ * - numeric label values               x
+ * - Labels with objects as keys        x
+ */
+mod_tape('label tests', function (t) {
+    var collector = mod_artedi.createCollector({
+        labels: {
+            global: 'label'
+        }
+    });
+
+    // Create a counter with static labels.
+    var counter = collector.counter({
+        name: 'test_counter_labels',
+        help: 'counters with static labels should work',
+        labels: {
+            mytag: 'isAwesome'
+        }
+    });
+
+    // Increment counter with static labels.
+    counter.increment();
+    t.equals(counter.metricVec.getDefault().value, 1,
+        'increment w/ static labels from Collector and Counter');
+
+    counter.increment({
+        dynamicLabel: 'pepsi'
+    });
+    t.equals(counter.labels({
+        dynamicLabel: 'pepsi'
+    }).value, 1, 'increment w/ dynamic label and static labels');
+
+
+    counter = collector.counter({
+        name: 'counter',
+        help: 'counters are fantastic'
+    });
+
+    counter.increment();
+    t.equals(counter.metricVec.getDefault().value, 1,
+            'increment w/ label from Collector');
+
+    // The user gave us a label structure, but no labels.
+    counter.add(100, {});
+    t.equals(counter.metricVec.getDefault().value, 101,
+            'increment with empty label structure');
+
+    // Test for numeric metric values.
+    counter.increment({
+        method: 'putobject',
+        code: 200
+    });
+    t.equals(counter.labels({
+        method: 'putobject',
+        code: 200
+    }).value, 1, 'numeric label values, multiple labels');
+
+    t.end();
+});
+
+/*
+ * Test that prometheus serialization happens properly.
+ * A few things to test:
+ * - No metrics                                 x
+ * - Ordering of labels (it shouldn't matter)   x
+ */
+mod_tape('counter serialization tests', function (t) {
+    var collector = mod_artedi.createCollector();
+
+    var counter = collector.counter({
+        name: 'bot_demerits',
+        help: 'wtf'
+    });
+
+    var expected = '# HELP bot_demerits ' + counter.help + '\n';
+    expected += '# TYPE bot_demerits ' + common.COUNTER + '\n';
+
+    // collector.collect is async, so we'll force these tests to happen
+    // serially so we can accurately predict what collector.collect will output.
+    mod_vasync.pipeline({ funcs: [
+        function (_, cb) {
+            // No metrics present, so we should just see the comments.
+            collector.collect(mod_artedi.FMT_PROM, function (err, str) {
+                t.notOk(err, 'no error for no metrics');
+                t.equals(str, expected, 'no metrics, only comments');
+            });
+            cb();
+        },
+
+        function (_, cb) {
+            counter.increment({
+                trollcon: '4',
+                user: 'kkantor'
+            });
+
+            resetTimestamps(counter.metricVec);
+            var oneDemerit = expected +
+                'bot_demerits{trollcon="4",user="kkantor"} 1 0\n';
+            collector.collect(mod_artedi.FMT_PROM, function (err, str) {
+                t.notOk(err, 'no error for two labels');
+                t.equals(str, oneDemerit, 'two label increment');
+            });
+            cb();
+        },
+
+        function (_, cb) {
+            // Note the reversal of labels here (shouldn't make a difference).
+            counter.add(1000, {
+                user: 'kkantor',
+                trollcon: '4'
+            });
+
+            resetTimestamps(counter.metricVec);
+            /* BEGIN JSSTYLED */
+            // eslint-disable-next-line max-len
+            var lots = expected + 'bot_demerits{trollcon="4",user="kkantor"} 1001 0\n';
+            /* END JSSTYLED */
+            collector.collect(mod_artedi.FMT_PROM, function (err, str) {
+                t.notOk(err, 'no error for reversed labels');
+                t.equals(str, lots, 'reversed label add');
+            });
+            cb();
+        },
+
+        function (_, cb) {
+            collector = mod_artedi.createCollector();
+            counter = collector.counter({
+                name: 'test',
+                help: 'help'
+            });
+            counter.increment();
+            counter.increment();
+            counter.increment();
+
+            resetTimestamps(counter.metricVec);
+            expected = '' +
+                '# HELP test help\n' +
+                '# TYPE test ' + common.COUNTER + '\n' +
+                'test{} 3 0\n';
+
+            collector.collect(mod_artedi.FMT_PROM, function (err, str) {
+                t.notOk(err, 'no error for default counter');
+                t.equals(str, expected, 'default counter');
+            });
+            cb();
+        }]
+    }, function (_, result) {
+        t.end();
+    });
+
 });
+
+mod_tape('histogram serialization tests', function (t) {
+    var collector = mod_artedi.createCollector();
+
+    var histogram = collector.histogram({
+        name: 'bot_trolololol',
+        help: 'there is no help'
+    });
+    var expected = '# HELP bot_trolololol there is no help\n';
+    expected += '# TYPE bot_trolololol ' + common.HISTOGRAM + '\n';
+
+    mod_vasync.pipeline({ funcs: [
+        function (_, cb) {
+            collector.collect(mod_artedi.FMT_PROM, function (err, str) {
+                t.notOk(err, 'no error for no metrics');
+                t.equals(str, expected, 'no labels or data points');
+            });
+            cb();
+        },
+
+        function (_, cb) {
+            histogram.observe(1, {
+                'key': 'value'
+            });
+
+            expected = expected +
+                'bot_trolololol{key="value",le="1"} 1 0\n' +
+                'bot_trolololol{key="value",le="3"} 1 0\n' +
+                'bot_trolololol{key="value",le="5"} 1 0\n' +
+                'bot_trolololol{key="value",le="7"} 1 0\n' +
+                'bot_trolololol{key="value",le="9"} 1 0\n' +
+                'bot_trolololol{le="+Inf",key="value"} 1 0\n' +
+                'bot_trolololol_count{key="value"} 1 0\n' +
+                'bot_trolololol_sum{key="value"} 1 0\n';
+
+            resetTimestamps(histogram.gauge.metricVec);
+            Object.keys(histogram.counters).forEach(function (counter) {
+                resetTimestamps(histogram.counters[counter].metricVec);
+            });
+
+            collector.collect(mod_artedi.FMT_PROM, function (err, str) {
+                t.notOk(err, 'no error for single label');
+                t.equals(str, expected, 'single label');
+            });
+            cb();
+        },
+
+        function (_, cb) {
+            // Histogram metric with labels inherited from Collector
+            collector = mod_artedi.createCollector({
+                labels: {
+                    service: 'muskie'
+                }
+            });
+
+            histogram = collector.histogram({
+                name: 'http_request_latency',
+                help: 'latency of requests'
+            });
+
+            histogram.observe(99);
+            expected = '' +
+                '# HELP http_request_latency latency of requests\n' +
+                '# TYPE http_request_latency ' + common.HISTOGRAM + '\n' +
+                'http_request_latency{service="muskie",le="81"} 0 0\n' +
+                'http_request_latency{service="muskie",le="243"} 1 0\n' +
+                'http_request_latency{service="muskie",le="405"} 1 0\n' +
+                'http_request_latency{service="muskie",le="567"} 1 0\n' +
+                'http_request_latency{service="muskie",le="729"} 1 0\n' +
+                'http_request_latency{le="+Inf",service="muskie"} 1 0\n' +
+                'http_request_latency_count{service="muskie"} 1 0\n' +
+                'http_request_latency_sum{service="muskie"} 99 0\n';
+
+            resetTimestamps(histogram.gauge.metricVec);
+            Object.keys(histogram.counters).forEach(function (counter) {
+                resetTimestamps(histogram.counters[counter].metricVec);
+            });
+
+            collector.collect(mod_artedi.FMT_PROM, function (err, str) {
+                t.notOk(err, 'no error for collector labels');
+                t.equals(str, expected, 'Collector labels and no Histogram' +
+                    ' labels');
+            });
+            cb();
+        },
+
+        function (_, cb) {
+            // Histogram metric with labels inherited from both Collector and
+            // Histogram.
+            collector = mod_artedi.createCollector({
+                labels: {
+                    service: 'muskie'
+                }
+            });
+
+            histogram = collector.histogram({
+                name: 'web_conn_alive_time',
+                help: 'connection alive time',
+                labels: {
+                    component: 'qball'
+                }
+            });
+
+            histogram.observe(101);
+            /* BEGIN JSSTYLED */
+            /* eslint-disable */
+            expected = '' +
+            '# HELP web_conn_alive_time connection alive time\n' +
+            '# TYPE web_conn_alive_time ' + common.HISTOGRAM + '\n' +
+            'web_conn_alive_time{service="muskie",component="qball",le="81"} 0 0\n' +
+            'web_conn_alive_time{service="muskie",component="qball",le="243"} 1 0\n' +
+            'web_conn_alive_time{service="muskie",component="qball",le="405"} 1 0\n' +
+            'web_conn_alive_time{service="muskie",component="qball",le="567"} 1 0\n' +
+            'web_conn_alive_time{service="muskie",component="qball",le="729"} 1 0\n' +
+            'web_conn_alive_time{le="+Inf",service="muskie",component="qball"} 1 0\n' +
+            'web_conn_alive_time_count{service="muskie",component="qball"} 1 0\n' +
+            'web_conn_alive_time_sum{service="muskie",component="qball"} 101 0\n';
+            /* eslint-enable */
+            /* END JSSTYLED */
+
+            resetTimestamps(histogram.gauge.metricVec);
+            Object.keys(histogram.counters).forEach(function (counter) {
+                resetTimestamps(histogram.counters[counter].metricVec);
+            });
+            collector.collect(mod_artedi.FMT_PROM, function (err, str) {
+                t.notOk(err, 'no error for inherited labels');
+                t.equals(str, expected, 'inherited Histogram and Collector' +
+                    ' labels');
+            });
+
+
+            cb();
+        },
+
+        function (_, cb) {
+            // Histogram metric with labels inherited from both Collector and
+            // Histogram, and provided at time of observation.
+            collector = mod_artedi.createCollector({
+                labels: {
+                    service: 'muskie'
+                }
+            });
+
+            histogram = collector.histogram({
+                name: 'webapi_conn_alive_time',
+                help: 'connection alive time',
+                labels: {
+                    component: 'cueball'
+                }
+            });
+
+            histogram.observe(101, {
+                err: 'ECONNRESET'
+            });
+
+            // Silence line length linting error.
+            /* BEGIN JSSTYLED */
+            /* eslint-disable */
+            var expected4 = '' +
+            '# HELP webapi_conn_alive_time connection alive time\n' +
+            '# TYPE webapi_conn_alive_time ' + common.HISTOGRAM + '\n' +
+            'webapi_conn_alive_time{err="ECONNRESET",service="muskie",component="cueball",le="81"} 0 0\n' +
+            'webapi_conn_alive_time{err="ECONNRESET",service="muskie",component="cueball",le="243"} 1 0\n' +
+            'webapi_conn_alive_time{err="ECONNRESET",service="muskie",component="cueball",le="405"} 1 0\n' +
+            'webapi_conn_alive_time{err="ECONNRESET",service="muskie",component="cueball",le="567"} 1 0\n' +
+            'webapi_conn_alive_time{err="ECONNRESET",service="muskie",component="cueball",le="729"} 1 0\n' +
+            'webapi_conn_alive_time{le="+Inf",err="ECONNRESET",service="muskie",component="cueball"} 1 0\n' +
+            'webapi_conn_alive_time_count{err="ECONNRESET",service="muskie",component="cueball"} 1 0\n' +
+            'webapi_conn_alive_time_sum{err="ECONNRESET",service="muskie",component="cueball"} 101 0\n';
+            /* eslint-enable */
+            /* END JSSTYLED */
+
+            resetTimestamps(histogram.gauge.metricVec);
+            Object.keys(histogram.counters).forEach(function (counter) {
+                resetTimestamps(histogram.counters[counter].metricVec);
+            });
+            collector.collect(mod_artedi.FMT_PROM, function (err, str) {
+                t.notOk(err, 'no error for dynamic and static labels');
+                t.equals(str, expected4, 'dynamic labels, and static labels' +
+                    ' from Histogram and Collector');
+            });
+            cb();
+        },
+
+        function (_, cb) {
+            collector = mod_artedi.createCollector();
+            histogram = collector.histogram({
+                name: 'test_test1',
+                help: 'testhelp'
+            });
+
+            histogram.observe(1);
+            histogram.observe(100);
+            resetTimestamps(histogram.gauge.metricVec);
+            Object.keys(histogram.counters).forEach(function (counter) {
+                resetTimestamps(histogram.counters[counter].metricVec);
+            });
+            // TODO We should have the +Inf label at the end. This works, but
+            // it would look nicer.
+            expected = '' +
+                '# HELP test_test1 testhelp\n' +
+                '# TYPE test_test1 ' + common.HISTOGRAM + '\n' +
+                'test_test1{le="1"} 1 0\n' +
+                'test_test1{le="3"} 1 0\n' +
+                'test_test1{le="5"} 1 0\n' +
+                'test_test1{le="7"} 1 0\n' +
+                'test_test1{le="9"} 1 0\n' +
+                'test_test1{le="+Inf"} 2 0\n' +
+                'test_test1{le="81"} 1 0\n' +
+                'test_test1{le="243"} 2 0\n' +
+                'test_test1{le="405"} 2 0\n' +
+                'test_test1{le="567"} 2 0\n' +
+                'test_test1{le="729"} 2 0\n' +
+                'test_test1_count{} 2 0\n' +
+                'test_test1_sum{} 101 0\n';
+            collector.collect(mod_artedi.FMT_PROM, function (err, str) {
+                t.notOk(err, 'no error for copying bucket values');
+                t.equals(str, expected, 'initial values copied from ' +
+                    'low-order buckets to high-order buckets');
+            });
+
+            cb();
+        }]
+    }, function (_, result) {
+        t.end();
+    });
+});
+
+mod_tape('odd value tests', function (t) {
+    var collector = mod_artedi.createCollector();
+    var counter = collector.counter({
+        name: 'counter',
+        help: 'help'
+    });
+    var hist = collector.histogram({
+        name: 'histo',
+        help: 'histo help'
+    });
+
+    counter.add(0);
+    t.equals(counter.metricVec.getDefault().value, 0, 'add zero to counter');
+
+    hist.observe(0);
+    t.equals(hist.defaultCounter().metricVec.getDefault().value, 0,
+        'histogram observes zero value');
+
+    t.throws(function () {
+        counter = collector.counter({
+            name: '@#$5235',
+            help: 'valid help @ #34'
+        });
+    }, 'invalid collector name (invalid chars)');
+
+    t.throws(function () {
+        counter = collector.counter({
+            name: 'space name',
+            help: 'valid help @ #34'
+        });
+    }, 'invalid collector name (space)');
+
+    t.throws(function () {
+        counter = collector.counter({
+            name: 'valid_name',
+            help: 4
+        });
+    }, 'invalid collector help (numeric)');
+
+    t.throws(function () {
+        counter = collector.counter({
+            name: 'valid_name',
+            help: { help: 'nested help!' }
+        });
+    }, 'invalid collector help (object)');
+
+    t.end();
+});
+
+function resetTimestamps(metricVec) {
+    Object.keys(metricVec.metrics).forEach(function (metric) {
+        metricVec.metrics[metric].timestamp = 0;
+    });
+}
diff --git a/tools/bashstyle b/tools/bashstyle
deleted file mode 100644
index 3e8052e..0000000
--- a/tools/bashstyle
+++ /dev/null
@@ -1,164 +0,0 @@
-#!/usr/bin/env node
-/*
- * This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/.
- */
-
-/*
- * Copyright (c) 2014, Joyent, Inc.
- */
-
-/*
- * bashstyle: check bash scripts for adherence to style guidelines, including:
- *
- *    o no lines longer than 80 characters
- *    o file does not end with a blank line
- *    o Do not use 'local' and var initialization *using a subshell* in the
- *      same statement. See
- *      <http://www.tldp.org/LDP/abs/html/localvar.html#EXITVALANOMALY01>
- *      for why not. Arguably this belongs in a separate 'bashlint'.
- *
- * Future enhancements could include:
- *    o indents consistent with respect to tabs, spaces
- *    o indents consistently sized (all are some multiple of the smallest
- *      indent, which must be a tab or 4 or 8 spaces)
- */
-
-var VERSION = '2.0.0';
-
-var mod_assert = require('assert');
-var mod_fs = require('fs');
-
-var nerrors = 0;
-
-main();
-process.exit(0);
-
-function main()
-{
-	var files = process.argv.slice(2);
-
-	if (files.length === 0) {
-		console.error('usage: %s file1 [...]',
-		    process.argv.slice(0, 2).join(' '));
-		process.exit(2);
-	}
-
-	files.forEach(checkFile);
-
-	if (nerrors != 0)
-		process.exit(1);
-}
-
-function checkFile(filename)
-{
-	var text = mod_fs.readFileSync(filename, 'utf-8');
-	var lines = text.split('\n');
-	var i;
-	var styled = false;
-	var styleStart;
-
-	mod_assert.ok(lines.length > 0);
-
-	/*
-	 * Expand tabs in each line and check for long lines.
-	 */
-	for (i = 1; i <= lines.length; i++) {
-		var line = expandTabs(lines[i - 1]);
-
-		if (i > 1 && lines[i-2].match(/# BASHSTYLED/)) {
-			continue;
-		}
-
-		if (line.match(/# BEGIN BASHSTYLED/)) {
-			styleStart = i;
-			styled = true;
-		}
-
-		if (line.match(/# END BASHSTYLED/)) {
-			if (styled != true) {
-				nerrors++;
-				console.log('%s: %d: END BASHSTYLED w/o corresponding BEGIN',
-				            filename, i);
-			}
-			styled = false;
-		}
-
-		if (!styled && line.match(/^\s*local\s+(\w+)\s*=.*\$\(/)) {
-			nerrors++;
-			var m = line.match(/^\s*local\s+(\w+)\s*=/);
-			console.log('%s: %d: declaring and setting a "local" ' +
-				'var in the same statement ' +
-				'ignores a subshell return code ' +
-				'<http://www.tldp.org/LDP/abs/html/localvar.html#EXITVALANOMALY01>: ' +
-				'local %s=...',
-				filename, i, m[1]);
-		}
-
-		// Regexplanation: non-[, [, space (contents) space, ], non-]
-		// groups before and after brackets to ease search/replace.
-		if (!styled && line.match(/(^|[^\[])\[(\s.+\s)\]([^\]])/)) {
-			nerrors++;
-			console.log('%s: %d: prefer [[ to [ for tests.', filename, i);
-		}
-
-		if (!styled && line.length > 80) {
-			nerrors++;
-			console.log('%s: %d: line exceeds 80 columns',
-			    filename, i);
-		}
-	}
-
-	if (styled) {
-		nerrors++;
-		console.log('%s: %d: BEGIN BASHSTYLED that does not END',
-		            filename, styleStart);
-	}
-
-
-	/*
-	 * No sane editor lets you save a file without a newline at the very end.
-	 */
-	if (lines[lines.length - 1].length !== 0) {
-		nerrors++;
-		console.log('%s: %d: file does not end with newline',
-			filename, lines.length);
-	}
-
-	/*
-	 * Since the file will always end with a newline, the last entry of
-	 * "lines" will actually be blank.
-	 */
-	if (lines.length > 1 && lines[lines.length - 2].length === 0) {
-		nerrors++;
-		console.log('%s: %d: file ends with a blank line',
-		    filename, lines.length - 1);
-	}
-}
-
-function expandTabs(text)
-{
-	var out = '';
-	var col = 0;
-	var j, k;
-
-	for (j = 0; j < text.length; j++) {
-		if (text[j] != '\t') {
-			out += text[j];
-			col++;
-			continue;
-		}
-
-		k = 8 - (col % 8);
-		col += k;
-
-		do {
-			out += ' ';
-		}  while (--k > 0);
-
-		col += k;
-	}
-
-	return (out);
-}
diff --git a/tools/eslint.node.conf b/tools/eslint.node.conf
new file mode 100644
index 0000000..207e5ba
--- /dev/null
+++ b/tools/eslint.node.conf
@@ -0,0 +1,17 @@
+{
+    "plugins": [ "joyent" ],
+    "extends": [
+        "eslint:recommended",
+        "plugin:joyent/style",
+        "plugin:joyent/lint"
+    ],
+    "parserOptions": {
+        "ecmaVersion": 5,
+        "sourceType": "script",
+        "ecmaFeatures": {
+        }
+    },
+    "env": {
+        "node": true
+    }
+}
diff --git a/tools/jsstyle.conf b/tools/jsstyle.conf
index 5e7999e..f8704ab 100644
--- a/tools/jsstyle.conf
+++ b/tools/jsstyle.conf
@@ -5,8 +5,9 @@
 #
 
 #
-# Copyright (c) 2014, Joyent, Inc.
+# Copyright (c) 2017, Joyent, Inc.
 #
 
-indent=tab
+indent=4
 blank-after-start-comment=0
+strict-indent=true
diff --git a/tools/mk/Makefile.targ b/tools/mk/Makefile.targ
index 39c5498..fff3c94 100644
--- a/tools/mk/Makefile.targ
+++ b/tools/mk/Makefile.targ
@@ -6,7 +6,7 @@
 #
 
 #
-# Copyright (c) 2014, Joyent, Inc.
+# Copyright (c) 2017, Joyent, Inc.
 #
 
 #
@@ -180,7 +180,7 @@ check-bash: $(BASH_FILES:%=%.bashchk) $(BASH_FILES:%=%.bashstyle)
 .PHONY: check-json
 check-json: $(JSON_FILES:%=%.jsonchk)
 
-%.jsonchk: % $(JSON)
+%.jsonchk: %
 	$(JSON) --validate -f $^
 
 #
@@ -208,8 +208,13 @@ JSSTYLE_TARGET = $(if $(JSSTYLE_FILES), check-jsstyle)
 check-jsstyle:  $(JSSTYLE_EXEC)
 	$(JSSTYLE) $(JSSTYLE_FLAGS) $(JSSTYLE_FILES)
 
+.PHONY: check-esl
+$(ESLINT): | $(NPM_EXEC)
+	$(NPM) install
+
 .PHONY: check
-check:: check-jsl check-json $(JSSTYLE_TARGET) check-bash
+check:: $(ESLINT) check-json $(JSSTYLE_TARGET) check-bash
+	$(ESLINT) -c $(ESLINT_CONF) $(ESLINT_FILES)
 	@echo check ok
 
 .PHONY: clean
diff --git a/tools/update-ghdocs b/tools/update-ghdocs
deleted file mode 100755
index 160eb65..0000000
--- a/tools/update-ghdocs
+++ /dev/null
@@ -1,50 +0,0 @@
-#!/usr/bin/env bash
-
-SOURCE="${0}"
-while [ -h "$SOURCE" ]; do
-	DIR="$(cd -P "$( dirname "$SOURCE" )" && pwd)"
-	SOURCE="$(readlink "$SOURCE")"
-	[[ $SOURCE != /* ]] && SOURCE="$DIR/$SOURCE"
-done
-
-set -ex
-
-SCRIPTDIR="$(cd -P "$( dirname "$SOURCE" )" && pwd)"
-
-ROOTDIR="$(cd -P "$( dirname "$SCRIPTDIR" )" && pwd)"
-
-GHURI=$(cd "$ROOTDIR" && git remote -v | awk '
-	$2 ~ /(^|@)github[.]com[:\/]/ && $3 == "(push)" {
-		printf("%s\n", $2);
-		exit(0);
-	}
-')
-
-TMPDIR="$(mktemp -d)"
-function clean {
-	rm -fr "${TMPDIR}"
-}
-trap clean EXIT
-
-pushd "${TMPDIR}"
-git clone "file://${ROOTDIR}" ./repo
-cd repo
-git remote add ghdocs "${GHURI}"
-git branch -D gh-pages || true
-git checkout --orphan gh-pages
-rm -fr * .gitignore .gitmodules .npmignore .travis.yml
-git add -u
-popd
-
-while (( "$#" )); do
-	SRC="$1"
-	TARGET="${TMPDIR}/repo/$(basename "$SRC")"
-	cp "${SRC}" "${TARGET}"
-	shift
-done
-
-pushd "${TMPDIR}/repo"
-git add *
-git commit -m "auto-generated ghdocs commit"
-git push -f ghdocs gh-pages
-popd
