From 8bd9d3f2392c1e5098e9178afd7585d0c53a655a Mon Sep 17 00:00:00 2001
From: Dillon Amburgey <dillona@dillona.com>
Date: Thu, 29 Dec 2016 12:04:55 -0500
Subject: [PATCH] joyent/illumos-joyent#134 Want ASLR in LX zones

---
 usr/src/uts/common/brand/lx/procfs/lx_proc.h  |   1 +
 .../uts/common/brand/lx/procfs/lx_prvnops.c   | 138 ++++++++++++++++++
 2 files changed, 139 insertions(+)

diff --git a/usr/src/uts/common/brand/lx/procfs/lx_proc.h b/usr/src/uts/common/brand/lx/procfs/lx_proc.h
index 67988e4aab..ebf5fd4021 100644
--- a/usr/src/uts/common/brand/lx/procfs/lx_proc.h
+++ b/usr/src/uts/common/brand/lx/procfs/lx_proc.h
@@ -214,6 +214,7 @@ typedef enum lxpr_nodetype {
 	LXPR_SYS_KERNEL_PID_MAX,	/* /proc/sys/kernel/pid_max */
 	LXPR_SYS_KERNEL_RANDDIR,	/* /proc/sys/kernel/random */
 	LXPR_SYS_KERNEL_RAND_BOOTID, /* /proc/sys/kernel/random/boot_id */
+	LXPR_SYS_KERNEL_RAND_VASPACE, /* /proc/sys/kernel/randomize_va_space */
 	LXPR_SYS_KERNEL_SEM,		/* /proc/sys/kernel/sem		*/
 	LXPR_SYS_KERNEL_SHMALL,		/* /proc/sys/kernel/shmall	*/
 	LXPR_SYS_KERNEL_SHMMAX,		/* /proc/sys/kernel/shmmax	*/
diff --git a/usr/src/uts/common/brand/lx/procfs/lx_prvnops.c b/usr/src/uts/common/brand/lx/procfs/lx_prvnops.c
index 5586ed05ad..55c2811b28 100644
--- a/usr/src/uts/common/brand/lx/procfs/lx_prvnops.c
+++ b/usr/src/uts/common/brand/lx/procfs/lx_prvnops.c
@@ -230,6 +230,7 @@ static void lxpr_read_sys_kernel_ngroups_max(lxpr_node_t *, lxpr_uiobuf_t *);
 static void lxpr_read_sys_kernel_osrel(lxpr_node_t *, lxpr_uiobuf_t *);
 static void lxpr_read_sys_kernel_pid_max(lxpr_node_t *, lxpr_uiobuf_t *);
 static void lxpr_read_sys_kernel_rand_bootid(lxpr_node_t *, lxpr_uiobuf_t *);
+static void lspr_read_sys_kernel_rand_va(lxpr_node_t *, lxpr_uiobuf_t *);
 static void lxpr_read_sys_kernel_sem(lxpr_node_t *, lxpr_uiobuf_t *);
 static void lxpr_read_sys_kernel_shmall(lxpr_node_t *, lxpr_uiobuf_t *);
 static void lxpr_read_sys_kernel_shmmax(lxpr_node_t *, lxpr_uiobuf_t *);
@@ -274,6 +275,8 @@ static int lxpr_write_sys_net_ipv4_tcp_winscale(lxpr_node_t *, uio_t *,
     cred_t *, caller_context_t *);
 static int lxpr_write_sys_kernel_corepatt(lxpr_node_t *, uio_t *, cred_t *,
     caller_context_t *);
+static int lxpr_write_sys_kernel_rand_vaspace(lxpr_node_t *, uio_t *, cred_t *,
+    caller_context_t *);
 
 /*
  * Simple conversion
@@ -523,6 +526,7 @@ static lxpr_dirent_t sys_kerneldir[] = {
 	{ LXPR_SYS_KERNEL_OSREL,	"osrelease" },
 	{ LXPR_SYS_KERNEL_PID_MAX,	"pid_max" },
 	{ LXPR_SYS_KERNEL_RANDDIR,	"random" },
+	{ LXPR_SYS_KERNEL_RAND_VASPACE,	"randomize_va_space" },
 	{ LXPR_SYS_KERNEL_SEM,		"sem" },
 	{ LXPR_SYS_KERNEL_SHMALL,	"shmall" },
 	{ LXPR_SYS_KERNEL_SHMMAX,	"shmmax" },
@@ -615,6 +619,7 @@ static wftab_t wr_tab[] = {
 	{LXPR_PID_TID_OOM_SCR_ADJ, NULL},
 	{LXPR_SYS_FS_FILEMAX, NULL},
 	{LXPR_SYS_KERNEL_COREPATT, lxpr_write_sys_kernel_corepatt},
+	{LXPR_SYS_KERNEL_RAND_VASPACE, lxpr_write_sys_kernel_rand_vaspace},
 	{LXPR_SYS_KERNEL_SHMALL, NULL},
 	{LXPR_SYS_KERNEL_SHMMAX, NULL},
 	{LXPR_SYS_NET_CORE_SOMAXCON, lxpr_write_sys_net_core_somaxc},
@@ -839,6 +844,7 @@ static void (*lxpr_read_function[LXPR_NFILES])() = {
 	lxpr_read_sys_kernel_pid_max,	/* /proc/sys/kernel/pid_max */
 	lxpr_read_invalid,		/* /proc/sys/kernel/random */
 	lxpr_read_sys_kernel_rand_bootid, /* /proc/sys/kernel/random/boot_id */
+	lspr_read_sys_kernel_rand_va, /* /proc/sys/kernel/randomize_va_space */
 	lxpr_read_sys_kernel_sem,	/* /proc/sys/kernel/sem */
 	lxpr_read_sys_kernel_shmall,	/* /proc/sys/kernel/shmall */
 	lxpr_read_sys_kernel_shmmax,	/* /proc/sys/kernel/shmmax */
@@ -979,6 +985,7 @@ static vnode_t *(*lxpr_lookup_function[LXPR_NFILES])() = {
 	lxpr_lookup_not_a_dir,		/* /proc/sys/kernel/pid_max */
 	lxpr_lookup_sys_kdir_randdir,	/* /proc/sys/kernel/random */
 	lxpr_lookup_not_a_dir,		/* /proc/sys/kernel/random/boot_id */
+	lxpr_lookup_not_a_dir,		/* .../kernel/randomize_va_space */
 	lxpr_lookup_not_a_dir,		/* /proc/sys/kernel/sem */
 	lxpr_lookup_not_a_dir,		/* /proc/sys/kernel/shmall */
 	lxpr_lookup_not_a_dir,		/* /proc/sys/kernel/shmmax */
@@ -1119,6 +1126,7 @@ static int (*lxpr_readdir_function[LXPR_NFILES])() = {
 	lxpr_readdir_not_a_dir,		/* /proc/sys/kernel/pid_max */
 	lxpr_readdir_sys_kdir_randdir,	/* /proc/sys/kernel/random */
 	lxpr_readdir_not_a_dir,		/* /proc/sys/kernel/random/boot_id */
+	lxpr_readdir_not_a_dir,		/* .../kernel/randomize_va_space */
 	lxpr_readdir_not_a_dir,		/* /proc/sys/kernel/sem */
 	lxpr_readdir_not_a_dir,		/* /proc/sys/kernel/shmall */
 	lxpr_readdir_not_a_dir,		/* /proc/sys/kernel/shmmax */
@@ -4468,6 +4476,23 @@ lxpr_read_sys_kernel_rand_bootid(lxpr_node_t *lxpnp, lxpr_uiobuf_t *uiobuf)
 	lxpr_uiobuf_printf(uiobuf, "%s\n", bootid);
 }
 
+/* ARGSUSED */
+static void
+lspr_read_sys_kernel_rand_va(lxpr_node_t *lxpnp, lxpr_uiobuf_t *uiobuf)
+{
+	zone_t *zone = LXPTOZ(lxpnp);
+
+	ASSERT(lxpnp->lxpr_type == LXPR_SYS_KERNEL_RAND_VASPACE);
+	ASSERT(zone->zone_brand == &lx_brand);
+	ASSERT(lxzd != NULL);
+
+	if (secflag_isset(zone->zone_secflags.psf_effective, PROC_SEC_ASLR)) {
+		lxpr_uiobuf_printf(uiobuf, "%d\n", 2);
+	} else {
+		lxpr_uiobuf_printf(uiobuf, "%d\n", 0);
+	}
+}
+
 /* ARGSUSED */
 static void
 lxpr_read_sys_kernel_sem(lxpr_node_t *lxpnp, lxpr_uiobuf_t *uiobuf)
@@ -7085,6 +7110,119 @@ lxpr_write_sys_kernel_corepatt(lxpr_node_t *lxpnp, struct uio *uio,
 	return (0);
 }
 
+/* ARGSUSED */
+static int
+lxpr_write_sys_kernel_rand_vaspace(lxpr_node_t *lxpnp, struct uio *uio,
+    struct cred *cr, caller_context_t *ct)
+{
+	zone_t *zone = LXPTOZ(lxpnp);
+	char val[3];
+	size_t olen;
+	int error;
+	proc_t *p;
+
+	ASSERT(lxpnp->lxpr_type == LXPR_SYS_KERNEL_RAND_VASPACE);
+
+	if (uio->uio_loffset != 0)
+		return (EINVAL);
+
+	if (uio->uio_resid == 0)
+		return (0);
+
+	olen = uio->uio_resid;
+	if (olen > sizeof (val) - 1)
+		return (EINVAL);
+
+	bzero(val, sizeof (val));
+	error = uiomove(val, olen, UIO_WRITE, uio);
+	if (error != 0)
+		return (error);
+
+	if (val[olen - 1] == '\n')
+		val[olen - 1] = '\0';
+
+	switch (val[0]) {
+	case '0':
+		/* Walk all active processes in the zone */
+		mutex_enter(&pidlock);
+		for (p = practive; p != NULL; p = p->p_next) {
+			/* skip kernel processes */
+			if (p->p_exec == NULLVP || p->p_as == &kas ||
+			    (p->p_flag & SSYS))
+				continue;
+			/*
+			 * Only processes in the given zone
+			 * are taken into account
+			 */
+			if (p->p_zone->zone_id == zone->zone_id) {
+				mutex_enter(&p->p_lock);
+				secflag_clear(&p->p_secflags.psf_effective,
+				    PROC_SEC_ASLR);
+				secflag_clear(&p->p_secflags.psf_inherit,
+				    PROC_SEC_ASLR);
+				mutex_exit(&p->p_lock);
+			}
+		}
+		mutex_exit(&pidlock);
+
+		/*
+		 * There isn't a functional reason to replace these
+		 * because secflags work through strict inheritance.
+		 * When the zone is already running, this has no effect.
+		 * Do it anyway to serve as a clear marker of whether ASLR is
+		 * enabled or disabled.
+		 */
+		secflag_clear(&zone->zone_secflags.psf_effective,
+		    PROC_SEC_ASLR);
+		secflag_clear(&zone->zone_secflags.psf_inherit,
+		    PROC_SEC_ASLR);
+		break;
+	case '1':
+		/*
+		 * Linux distinguishes between (1) "conservative" and
+		 * (2) "full" ASLR. Illumos does not have the same distinction
+		 */
+		/* FALLTHROUGH */
+	case '2':
+		/* Walk all active processes in the zone */
+		mutex_enter(&pidlock);
+		for (p = practive; p != NULL; p = p->p_next) {
+			/* skip kernel processes */
+			if (p->p_exec == NULLVP || p->p_as == &kas ||
+			    (p->p_flag & SSYS))
+				continue;
+			/*
+			 * Only processes in the given zone
+			 * are taken into account
+			 */
+			if (p->p_zone->zone_id == zone->zone_id) {
+				mutex_enter(&p->p_lock);
+				secflag_set(&p->p_secflags.psf_effective,
+				    PROC_SEC_ASLR);
+				secflag_set(&p->p_secflags.psf_inherit,
+				    PROC_SEC_ASLR);
+				mutex_exit(&p->p_lock);
+			}
+		}
+		mutex_exit(&pidlock);
+
+		/*
+		 * There isn't a functional reason to replace these
+		 * because secflags work through strict inheritance.
+		 * When the zone is already running, this has no effect.
+		 * Do it anyway to serve as a clear marker of whether ASLR is
+		 * enabled or disabled.
+		 */
+		secflag_set(&zone->zone_secflags.psf_effective, PROC_SEC_ASLR);
+		secflag_set(&zone->zone_secflags.psf_inherit, PROC_SEC_ASLR);
+		break;
+	default:
+		return (EINVAL);
+	}
+
+	return (0);
+}
+
 /* ARGSUSED */
 static int
 lxpr_write_pid_loginuid(lxpr_node_t *lxpnp, struct uio *uio, struct cred *cr,
-- 
2.21.0

