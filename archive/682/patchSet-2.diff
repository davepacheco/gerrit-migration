commit b050d2d8d222e0245206def0067d9d0fcf14f47a (refs/changes/82/682/2)
Author: David Pacheco <dap@joyent.com>
Date:   2016-10-14T13:32:34-07:00 (3 years ago)
    
    MORAY-346 moray client needs work
    MORAY-361 moray client tools hang forever while moray is down
    MORAY-325 node-moray client emits 'close' event even if some connections are still open

diff --git a/Makefile b/Makefile
index 7886aeb..711c949 100644
--- a/Makefile
+++ b/Makefile
@@ -60,13 +60,16 @@ CLEAN_FILES += node_modules
 test: | $(FAUCET) $(MORAY_TEST_ENV_FILE)
 	(set -o pipefail; \
 	source $(MORAY_TEST_ENV_FILE) && \
+	$(CTRUN) node test/cli-sanity.test.js | $(FAUCET) && \
 	$(CTRUN) node test/client.test.js | $(FAUCET) && \
+	$(CTRUN) node test/close-handles.test.js | $(FAUCET) && \
 	$(CTRUN) node test/buckets.test.js | $(FAUCET) && \
 	$(CTRUN) node test/objects.test.js | $(FAUCET) && \
 	$(CTRUN) node test/sql.test.js | $(FAUCET) && \
 	$(CTRUN) node test/integ.test.js | $(FAUCET) && \
 	$(CTRUN) node test/arrays.test.js | $(FAUCET) && \
 	$(CTRUN) node test/version.test.js | $(FAUCET) && \
+	$(CTRUN) node test/translate-legacy.test.js | $(FAUCET) && \
 	$(CTRUN) node test/loop.test.js | bunyan -lfatal )
 	@echo tests passed
 
diff --git a/test/cli-sanity.test.js b/test/cli-sanity.test.js
new file mode 100644
index 0000000..3a4096c
--- /dev/null
+++ b/test/cli-sanity.test.js
@@ -0,0 +1,421 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2016, Joyent, Inc.
+ */
+
+/*
+ * cli-sanity.test.js: very basic test suite for the moray CLI tools.  This
+ * is not an exhaustive regression suite.
+ */
+
+var assertplus = require('assert-plus');
+var forkexec = require('forkexec');
+var helper = require('./helper');
+var path = require('path');
+var tape = require('tape');
+var vasync = require('vasync');
+
+var binpath, testcases;
+var bucket = 'cli_sanity_test_bucket';
+
+function main()
+{
+    binpath = path.join(__dirname, '..', 'run', 'client',
+        'node_modules', '.bin');
+
+    tape.test('successful sequence', runNormalSequence);
+
+    testcases = [];
+    generateFailureTests();
+    testcases.forEach(defineTestCase);
+}
+
+/*
+ * "tc" is a CLI tool test case, which should have:
+ *
+ *     name        name of the test case
+ *
+ *     exec        "argv" argument to node-forkexec, which describes the command
+ *                 to execute (as an array)
+ *
+ *     statusCode  integer status code expected from the command.  (This test
+ *                 runner does not support invocations that would die as a
+ *                 result of a signal.  Those would produce no status code.)
+ *
+ *     stdout      regular expression to match against stdout contents
+ *
+ *     stderr      regular expression to match against stderr contents
+ *
+ * This function configures tape to run the command "exec" and validate the
+ * status code, stdout, and stderr.
+ */
+function defineTestCase(tc)
+{
+    assertplus.string(tc.name);
+    assertplus.number(tc.statusCode);
+    assertplus.object(tc.stdout);
+    assertplus.object(tc.stderr);
+    assertplus.arrayOfString(tc.exec);
+
+    tape.test(tc.name, function runTestCase(t) {
+        runCmd(tc.exec, function (err, info) {
+            t.strictEqual(tc.statusCode, info.status, 'status code');
+            t.ok(tc.stdout.test(info.stdout), 'stdout matches');
+            t.ok(tc.stderr.test(info.stderr), 'stderr matches');
+            t.end();
+        });
+    });
+}
+
+function runCmd(argv, callback)
+{
+    var qualified_argv, forkexec_args;
+
+    assertplus.arrayOfString(argv);
+    assertplus.func(callback);
+
+    qualified_argv = argv.slice(0);
+    qualified_argv[0] = path.join(binpath, argv[0]);
+    forkexec_args = {
+        'env': {
+            'PATH': process.env['PATH']
+        },
+        'timeout': 60000,
+        'argv': qualified_argv,
+        'includeStderr': true
+    };
+
+    if (process.env['MORAY_TEST_SERVER_REMOTE']) {
+        forkexec_args.env['MORAY_URL'] = process.env[
+            'MORAY_TEST_SERVER_REMOTE'];
+    } else {
+        forkexec_args.env['MORAY_URL'] = 'tcp://127.0.0.1:2020';
+    }
+
+    forkexec.forkExecWait(forkexec_args, callback);
+}
+
+/*
+ * Runs a sequence of commands that exercises all of the command-line tools.
+ * This sequence is based on the one in test/stress-client.js.  Updates here
+ * should be propagated there.
+ */
+function runNormalSequence(t)
+{
+    var server, funcs;
+
+    funcs = [
+        function setupServer(_, callback) {
+            helper.createServer({}, function (s) {
+                server = s;
+                callback();
+            });
+        },
+
+        function delBucketCleanup(_, callback) {
+            runCmd([ 'delbucket', bucket ], function (err) {
+                /* We don't care about a "not found" error here. */
+                callback();
+            });
+        },
+
+        function createBucket(_, callback) {
+            runCmd([ 'putbucket', bucket ], callback);
+        },
+
+        function getBucket(_, callback) {
+            runCmd([ 'getbucket', bucket ], function (err, info) {
+                var p, d;
+
+                t.error(err);
+                p = JSON.parse(info.stdout);
+                t.equal(typeof (p), 'object');
+                t.ok(p !== null);
+                t.equal(p.name, bucket);
+                t.deepEqual(p.index, {});
+                t.deepEqual(p.pre, []);
+                t.deepEqual(p.post, []);
+                t.deepEqual(p.options, { 'version': 0 });
+                d = Date.parse(p.mtime);
+                t.ok(d > Date.parse('2016-01-01') &&
+                    d < Date.parse('2038-01-19'));
+                callback();
+            });
+        },
+
+        function listBuckets(_, callback) {
+            runCmd([ 'listbuckets' ], function (err, info) {
+                var p;
+
+                t.error(err);
+                p = JSON.parse(info.stdout);
+                t.ok(Array.isArray(p));
+                p = p.filter(function (b) { return (b.name == bucket); });
+                t.equal(p.length, 1);
+                p = p[0];
+                t.deepEqual(p.options, { 'version': 0 });
+                callback();
+            });
+        },
+
+        function putObject5(_, callback) {
+            runCmd([ 'putobject', '-d',
+                JSON.stringify({ 'field1': 5 }), bucket, 'key5' ], callback);
+        },
+
+        function updateBucket(_, callback) {
+            runCmd([ 'putbucket', '-x', '2', '-i', 'field1:number', bucket ],
+                callback);
+        },
+
+        function reindexObjects(_, callback) {
+            runCmd([ 'reindexobjects', bucket ], callback);
+        },
+
+        function putObject2(_, callback) {
+            runCmd([ 'putobject', '-d',
+                JSON.stringify({ 'field1': 2 }), bucket, 'key2' ], callback);
+        },
+
+        function putObject3(_, callback) {
+            runCmd([ 'putobject', '-d',
+                JSON.stringify({ 'field1': 3 }), bucket, 'key3' ], callback);
+        },
+
+        function putObject9(_, callback) {
+            runCmd([ 'putobject', '-d',
+                JSON.stringify({ 'field1': 9 }), bucket, 'key9' ], callback);
+        },
+
+        function getObject(_, callback) {
+            runCmd([ 'getobject', bucket, 'key5' ], function (err, info) {
+                t.error(err);
+
+                var p = JSON.parse(info.stdout);
+                t.equal(p.key, 'key5');
+                t.deepEqual(p.value, { 'field1': 5 });
+                t.equal(p._id, 1);
+                t.equal('string', typeof (p._etag));
+                t.equal('number', typeof (p._mtime));
+                callback();
+            });
+        },
+
+        function delObject(_, callback) {
+            runCmd([ 'delobject', bucket, 'key3' ], callback);
+        },
+
+        function findObjects(_, callback) {
+            var filter = 'field1>=3';
+            runCmd([ 'findobjects', '-H', bucket, filter ],
+                function (err, info) {
+
+                var objs, found;
+                t.error(err);
+                objs = parseFindobjectsResults(t, info.stdout);
+                found = [];
+                objs.forEach(function (o) {
+                    t.equal('key' + o.value.field1, o.key);
+                    found.push(o.key);
+                });
+
+                found.sort();
+                t.deepEqual(found, [ 'key5', 'key9' ]);
+                callback();
+            });
+        },
+
+        function updateMany(_, callback) {
+            var filter = 'field1>=9';
+            runCmd([ 'updatemany', '-d', JSON.stringify({ 'field1': 10 }),
+                bucket, filter ], callback);
+        },
+
+        function findobjectsAll(_, callback) {
+            runCmd([ 'findobjects', '-H', bucket, 'field1=*' ],
+                function (err, info) {
+
+                var objs;
+                t.error(err);
+                objs = parseFindobjectsResults(t, info.stdout);
+                objs.sort(function (o1, o2) {
+                    return (o1.key.localeCompare(o2.key));
+                });
+                objs = objs.map(function (o) {
+                    return ({ 'key': o.key, 'value': o.value });
+                });
+                t.deepEqual(objs, [
+                    { 'key': 'key2', 'value': { 'field1': 2 } },
+                    { 'key': 'key5', 'value': { 'field1': 5 } },
+                    { 'key': 'key9', 'value': { 'field1': 10 } }
+                ]);
+                callback();
+            });
+        },
+
+        function delMany(_, callback) {
+            var filter = 'field1>=5';
+            runCmd([ 'delmany', bucket, filter], callback);
+        },
+
+        function findobjectsDeleted(_, callback) {
+            runCmd([ 'findobjects', '-H', bucket, 'field1=*' ],
+                function (err, info) {
+
+                var objs;
+                t.error(err);
+                objs = parseFindobjectsResults(t, info.stdout);
+                t.equal(objs.length, 1);
+                t.equal(objs[0].key, 'key2');
+                callback();
+            });
+        },
+
+        function delbucket(_, callback) {
+            runCmd([ 'delbucket', bucket ], callback);
+        },
+
+        function ping(_, callback) {
+            runCmd([ 'morayping' ], callback);
+        },
+
+        function version(_, callback) {
+            runCmd([ 'morayversion' ], callback);
+        },
+
+        function sql(_, callback) {
+            runCmd([ 'sql', 'select 8+8 as TwiceEight' ], function (err, info) {
+                var joined, parsed;
+
+                t.error(err);
+                joined = info.stdout.split('\n').join(' ');
+                parsed = JSON.parse(joined);
+                t.deepEqual(parsed, { 'twiceeight': 16 });
+                callback();
+            });
+        }
+    ];
+
+    vasync.pipeline({
+        'funcs': funcs
+    }, function (err) {
+        t.error(err, 'no error');
+        helper.cleanupServer(server, function () {
+            t.end();
+        });
+    });
+}
+
+function parseFindobjectsResults(t, stdout)
+{
+    var lines, objs;
+
+    assertplus.object(t, 't');
+    assertplus.string(stdout, 'stdout');
+    lines = stdout.split('\n');
+    t.ok(lines.length > 1);
+    /* Chop off trailing newline. */
+    t.equal(lines[lines.length - 1], '');
+    lines = lines.slice(0, lines.length - 1);
+
+    objs = lines.map(function (l) { return (JSON.parse(l)); });
+    return (objs);
+}
+
+/*
+ * Generates test cases (that can be provided to defineTestCase) for each of the
+ * command-line tools that exercise bad arguments for the "-h" (host) and "-p"
+ * (port) arguments.
+ */
+function generateFailureTests()
+{
+    var cmds = [
+        'backfill',
+        'delbucket',
+        'delmany',
+        'delobject',
+        'findobjects',
+        'getbucket',
+        'getobject',
+        'listbuckets',
+        'morayping',
+        'morayversion',
+        'putbucket',
+        'putobject',
+        'reindexobjects',
+        'sql',
+        'updatemany'
+    ];
+
+    cmds.forEach(function (cmdname) {
+        var args = validArgsFor(cmdname);
+        testcases.push({
+            'name': cmdname + ': bad hostname',
+            'exec': [ cmdname ].concat(
+                [ '-h', 'bogus-test', '-p', '1111' ].concat(args)),
+            'statusCode': 1,
+            'stdout': /^$/,
+            'stderr': new RegExp('^' + cmdname +
+                ':.*bogus-test.*: failed to establish connection')
+        });
+
+        testcases.push({
+            'name': cmdname + ': bad port',
+            'exec': [ cmdname ].concat(
+                [ '-h', '127.0.0.1', '-p', '1111' ].concat(args)),
+            'statusCode': 1,
+            'stdout': /^$/,
+            'stderr': new RegExp('^' + cmdname +
+                ':.*127\\.0\\.0\\.1.*: failed to establish connection')
+        });
+    });
+}
+
+/*
+ * Given one of the Moray CLI tools, return a list of arguments that are
+ * necessary for a syntactically valid command invocation.  The goal is that we
+ * can combine these arguments with invalid values for "-h" and "-p" and have
+ * the command fail as a result of the -h/-p arguments rather than because the
+ * command had missing or incorrect arguments.
+ */
+function validArgsFor(cmdname)
+{
+    var args = [];
+
+    if (cmdname == 'sql') {
+        return ([ 'select NOW()' ]);
+    }
+
+    if (cmdname == 'backfill' || cmdname == 'delbucket' ||
+        cmdname == 'delmany' || cmdname == 'delobject' ||
+        cmdname == 'findobjects' || cmdname == 'getbucket' ||
+        cmdname == 'getobject' || cmdname == 'putbucket' ||
+        cmdname == 'putobject' || cmdname == 'reindexobjects' ||
+        cmdname == 'updatemany') {
+        /* add a bucket name */
+        args.push(bucket);
+    }
+
+    if (cmdname == 'delobject' ||
+        cmdname == 'getobject' ||
+        cmdname == 'putobject') {
+        /* add an object key */
+        args.push('x');
+    }
+
+    if (cmdname == 'delmany' ||
+        cmdname == 'findobjects' ||
+        cmdname == 'updatemany') {
+        /* add a filter */
+        args.push('x=y');
+    }
+
+    return (args);
+}
+
+main();
diff --git a/test/close-handles.test.js b/test/close-handles.test.js
new file mode 100644
index 0000000..7cf2984
--- /dev/null
+++ b/test/close-handles.test.js
@@ -0,0 +1,72 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2016, Joyent, Inc.
+ */
+
+/*
+ * close-handles.test.js: test that close() does close all sockets.
+ * Regrettably, this test encodes a bunch of implementation details, and may
+ * turn out to be brittle.
+ */
+
+var moray = require('moray');
+var net = require('net');
+var tape = require('tape');
+var vasync = require('vasync');
+var helper = require('./helper');
+
+tape.test('client close actually closes sockets', function (t) {
+    var server, nhandles, client;
+
+    server = net.createServer(12345);
+
+    vasync.waterfall([
+        function startServer(callback) {
+            server.listen(callback);
+        },
+
+        function createClient(callback) {
+            nhandles = process._getActiveHandles().length;
+            client = moray.createClient({
+                'log': helper.createLogger(),
+                'host': server.address().address,
+                'port': server.address().port,
+                'maxConnections': 1
+            });
+            client.on('connect', callback);
+        },
+
+        function closeClient(callback) {
+            t.ok(nhandles < process._getActiveHandles().length,
+                'handle count increased');
+            client.on('close', function () {
+                /*
+                 * Sockets are destroyed in the context where this event is
+                 * fired, but it may take another tick for them to disappear
+                 * from the list of active handles.
+                 */
+                setImmediate(callback);
+            });
+            client.close();
+        },
+
+        function closeServer(callback) {
+            t.equal(nhandles, process._getActiveHandles().length,
+                'handle count decreased');
+            server.on('close', function () {
+                /* See above. */
+                setImmediate(callback);
+            });
+            server.close();
+        }
+    ], function (err) {
+        t.error(err);
+        t.equal(0, process._getActiveHandles().length);
+        t.end();
+    });
+});
diff --git a/test/stress-client.js b/test/stress-client.js
index 27e4e43..12e5876 100644
--- a/test/stress-client.js
+++ b/test/stress-client.js
@@ -549,6 +549,9 @@ scCommands.push({
                  * different than the failure cases above because it's simpler
                  * to create a working sequence in this order.  deleteBucket
                  * appears twice to deal with unclean exits.
+                 *
+                 * This sequence is replicated in cli-sanity.test.js for
+                 * command-line tools.  Updates here should be propagated there.
                  */
 
                 function cmdRpcOkayDeleteBucketCleanup(_, subcallback) {
diff --git a/test/translate-legacy.test.js b/test/translate-legacy.test.js
new file mode 100644
index 0000000..82b6f24
--- /dev/null
+++ b/test/translate-legacy.test.js
@@ -0,0 +1,323 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2016, Joyent, Inc.
+ */
+
+/*
+ * translate-legacy.test.js: test Moray v2 function for translating v1-style
+ * parameters.
+ */
+
+var assertplus = require('assert-plus');
+var moray = require('moray');
+var tape = require('tape');
+var translateLegacyOptions = moray.Client.privateTranslateLegacyOptions;
+
+var testcases;
+
+function main()
+{
+    testcases.forEach(defineTestCase);
+}
+
+function defineTestCase(tc)
+{
+    assertplus.string(tc.name);
+    assertplus.object(tc.input);
+    assertplus.optionalObject(tc.output);
+    assertplus.ok(tc.output || tc.errmsg);
+    assertplus.ok(!(tc.output && tc.errmsg));
+
+    tape.test(tc.name, function runTestCase(t) {
+        var rv;
+
+        if (tc.errmsg) {
+            t.throws(function () {
+                translateLegacyOptions(tc.input);
+            }, tc.errmsg);
+            t.end();
+            return;
+        }
+
+        /*
+         * There's no sense in testing all of the defaults.  We only compare
+         * properties that were specified in tc.output.
+         */
+        rv = translateLegacyOptions(tc.input);
+        assertplus.object(rv);
+        checkDeepSubset(t, tc.output, rv, 'result');
+        t.end();
+    });
+}
+
+/*
+ * This function behaves like t.deepEqual(), except that it ignores properties
+ * in "actual" that are not present in "expected".  This applies recursively, so
+ * that if expected.x.y exists but actual.x.y doesn't (but actual.x and
+ * expected.x are otherwise equivalent), then no error is thrown.
+ */
+function checkDeepSubset(t, expected, actual, prefix)
+{
+    var k;
+
+    for (k in expected) {
+        if (typeof (expected[k]) == 'object' &&
+            typeof (actual[k]) == 'object' &&
+            expected[k] !== null && actual[k] !== null &&
+            !Array.isArray(expected[k]) && !Array.isArray(actual[k])) {
+
+            checkDeepSubset(t, expected[k], actual[k], prefix + '.' + k);
+        } else {
+            t.deepEqual(expected[k], actual[k], prefix + '.' + k + '  matches');
+        }
+    }
+}
+
+/*
+ * For details on allowed inputs and expected behavior, see the detailed comment
+ * above translateLegacyOptions().
+ */
+testcases = [ {
+    'name': 'no arguments',
+    'input': {},
+    'errmsg': /is required/
+},
+
+/*
+ * The behavior with respect to "host", "port", and "url" is the most
+ * complicated.
+ */
+
+{
+    'name': 'host specified, missing port',
+    'input': { 'host': 'foobar' },
+    'errmsg': /port.*is required/
+}, {
+    'name': 'host and port specified',
+    'input': { 'host': 'foobar', 'port': 1234 },
+    'output': {
+        'defaultPort': 1234,
+        'domain': 'foobar'
+    }
+}, {
+    'name': 'host and port specified, wrong host type',
+    'input': { 'host': [], 'port': 1234 },
+    'errmsg': /host.*is required/
+}, {
+    'name': 'host and port specified, wrong port type',
+    'input': { 'host': 'foobar', 'port': '1234' },
+    'errmsg': /port.*is required/
+}, {
+    'name': 'url specified, bad type',
+    'input': { 'url': 1234 },
+    'errmsg': /is required/
+}, {
+    'name': 'url specified with port',
+    'input': { 'url': 'tcp://foobar.a.b.c:1234/' },
+    'output': {
+        'defaultPort': 1234,
+        'domain': 'foobar.a.b.c'
+    }
+}, {
+    'name': 'url specified with no port',
+    'input': { 'url': 'tcp://foobar.a.b.c/' },
+    'output': {
+        'defaultPort': 2020,
+        'domain': 'foobar.a.b.c'
+    }
+}, {
+    'name': 'url and port specified',
+    'input': { 'url': 'tcp://foobar.a.b.c:1234/', 'port': 3456 },
+    'output': {
+        'defaultPort': 3456,
+        'domain': 'foobar.a.b.c'
+    }
+}, {
+    'name': 'host, url, and port specified',
+    'input': { 'url': 'tcp://foobar.a:1234/', 'host': 'fooey', 'port': 3456 },
+    'output': {
+        'defaultPort': 3456,
+        'domain': 'fooey'
+    }
+},
+
+/*
+ * Miscellaneous other parameters
+ */
+{
+    'name': 'connectTimeout: bad',
+    'input': {
+        'url': 'tcp://foobar.a.b:5678',
+        'connectTimeout': {}
+    },
+    'errmsg': /connectTimeout/
+}, {
+    'name': 'connectTimeout: specified',
+    'input': {
+        'url': 'tcp://foobar.a.b:5678',
+        'connectTimeout': 4567
+    },
+    'output': {
+        'domain': 'foobar.a.b',
+        'defaultPort': 5678,
+        'recovery': {
+            'default': {
+                'timeout': 4567,
+                'maxTimeout': 4567,
+                'retries': 0,
+                'delay': 0,
+                'maxDelay': 0
+            }
+        }
+    }
+},
+
+{
+    'name': 'maxConnections: bad',
+    'input': {
+        'url': 'tcp://foobar.a.b:5678',
+        'maxConnections': {}
+    },
+    'errmsg': /maxConnections/
+}, {
+    'name': 'maxConnections specified',
+    'input': {
+        'url': 'tcp://foobar.a.b:5678',
+        'maxConnections': 427
+    },
+    'output': {
+        'domain': 'foobar.a.b',
+        'defaultPort': 5678,
+        'maximum': 427
+    }
+},
+
+{
+    'name': 'dns: bad',
+    'input': {
+        'url': 'tcp://foobar.a.b:5678',
+        'dns': 17
+    },
+    'errmsg': /dns/
+}, {
+    'name': 'dns: specified',
+    'input': {
+        'url': 'tcp://foobar.a.b:5678',
+        'dns': {
+            /* checkInterval should not appear in the output. */
+            'checkInterval': 37,
+            'resolvers': [ '1.2.3.4', '5.6.7.8' ],
+            'timeout': 9876
+        }
+    },
+    'output': {
+        'domain': 'foobar.a.b',
+        'defaultPort': 5678,
+        'resolvers': [ '1.2.3.4', '5.6.7.8' ],
+        'recovery': {
+            'dns': {
+                'timeout': 9876,
+                'maxTimeout': 9876
+            },
+            'dns_srv': {
+                'timeout': 9876,
+                'maxTimeout': 9876
+            }
+        }
+    }
+},
+
+{
+    'name': 'retry: bad',
+    'input': {
+        'url': 'tcp://foobar.a.b:5678',
+        'retry': 37
+    },
+    'errmsg': /retry/
+}, {
+    'name': 'retry: minTimeout > maxTimeout',
+    'input': {
+        'url': 'tcp://foobar.a.b:5678',
+        'retry': {
+            'retries': 42,
+            'minTimeout': 7890,
+            'maxTimeout': 4567
+        }
+    },
+    'errmsg': /maxTimeout.*minTimeout/
+}, {
+    'name': 'retry: specified',
+    'input': {
+        'url': 'tcp://foobar.a.b:5678',
+        'retry': {
+            'retries': 42,
+            'minTimeout': 4567,
+            'maxTimeout': 7890
+        }
+    },
+    'output': {
+        'resolvers': undefined,
+        'recovery': {
+            'dns': {},
+            'dns_srv': {},
+            'default': {
+                'retries': 42,
+                'delay': 4567,
+                'maxDelay': 7890
+            }
+        }
+    }
+},
+
+{
+    'name': 'the works',
+    'input': {
+        'url': 'tcp://foobar.a.b:5678',
+        'host': 'example.com',
+        'port': 314,
+        'connectTimeout': 111,
+        'dns': {
+            /* checkInterval should not appear in the output. */
+            'checkInterval': 555,
+            'resolvers': [ '1.1.1.1', '2.2.2.2' ],
+            'timeout': 222
+        },
+        'maxConnections': 333,
+        'retry': {
+            'retries': 444,
+            'minTimeout': 777,
+            'maxTimeout': 888
+        }
+    },
+    'output': {
+        'domain': 'example.com',
+        'defaultPort': 314,
+        'maximum': 333,
+        'resolvers': [ '1.1.1.1', '2.2.2.2' ],
+        'recovery': {
+            'dns': {
+                'timeout': 222,
+                'maxTimeout': 222
+            },
+            'dns_srv': {
+                'retries': 0,
+                'timeout': 222,
+                'maxTimeout': 222
+            },
+            'default': {
+                'timeout': 111,
+                'maxTimeout': 111,
+                'retries': 444,
+                'delay': 777,
+                'maxDelay': 888
+            }
+        }
+    }
+} ];
+
+main();
