From 86c89242ac3029e423aac6edc595b695a8e54242 Mon Sep 17 00:00:00 2001
From: Jordan Hendricks <jordan.hendricks@joyent.com>
Date: Fri, 16 Feb 2018 22:22:14 +0000
Subject: [PATCH] MANTA-3520 Create a tool to model the behavior of picker

---
 bin/mpicker   | 615 ++++++++++++++++++++++++++++++++++++++++++++++++++
 lib/errors.js |   7 +-
 lib/picker.js | 197 +++++++++++-----
 package.json  |   2 +
 4 files changed, 762 insertions(+), 59 deletions(-)
 create mode 100755 bin/mpicker

diff --git a/bin/mpicker b/bin/mpicker
new file mode 100755
index 0000000..402a0b0
--- /dev/null
+++ b/bin/mpicker
@@ -0,0 +1,615 @@
+#!/usr/bin/env node
+/* vim: set ft=javascript: */
+
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2018, Joyent, Inc.
+ */
+
+var mod_assert = require('assert-plus');
+var mod_bunyan = require('bunyan');
+var mod_cmdln = require('cmdln');
+var mod_fs = require('fs');
+var mod_jsprim = require('jsprim');
+var mod_lstream = require('lstream');
+var mod_path = require('path');
+var mod_tab = require('tab');
+var mod_util = require('util');
+var mod_vasync = require('vasync');
+var mod_verror = require('verror');
+
+var mod_picker = require('../lib/picker');
+
+var MultiError = require('verror').MultiError;
+var sprintf = mod_util.format;
+var VError = mod_verror.VError;
+var muskie_errors = require('../lib/errors');
+
+
+
+///-- Globals
+
+var NAME = 'mpicker';
+var LOG = mod_bunyan.createLogger({
+    name: NAME,
+    level: process.LOG_LEVEL || 'error',
+    stream: process.stderr
+});
+
+/*
+ * Common options for all submcommands.
+ */
+var commonOptions = [
+    {
+        names: ['help', 'h'],
+        type: 'bool',
+        help: 'Show this help'
+    }
+];
+
+
+/*
+ * Creates an instance of the MPicker object.
+ */
+function MPicker() {
+    mod_cmdln.Cmdln.call(this, {
+        name: 'mpicker',
+        desc: 'Models the behavior of the Muskie "picker" component.',
+        options: [
+            {
+                names: ['help', 'h'],
+                type: 'bool',
+                help: 'Show this help message and exit.'
+            },
+            {
+                names: ['version'],
+                type: 'bool',
+                help: 'Print version and exit.'
+            },
+            {
+                names: ['completion'],
+                type: 'bool',
+                help: 'Print bash completion code for this command and exit.',
+                hidden: true
+            }
+        ],
+        helpOpts: {
+            includeEnv: true
+        }
+    });
+
+    this.arg0 = NAME;
+}
+mod_util.inherits(MPicker, mod_cmdln.Cmdln);
+
+/*
+ * Print an error message, then a help message, then exit.
+ */
+MPicker.prototype.usage = function usage(message, subcmd, cb) {
+    mod_assert.string(message, 'message');
+    mod_assert.string(subcmd, 'subcmd');
+
+    var self = this;
+
+    console.error('%s: %s', self.arg0, message);
+    console.error(self.helpFromSubcmd(subcmd));
+    process.exit(2);
+}
+
+
+/*
+ * Checks whether the "help" option was specified.  If so, print the usage
+ * message and exit.  This function does not return if it prints the help
+ * message.
+ */
+MPicker.prototype.checkHelpRequested = function (subcmd, opts, cb) {
+    var self = this;
+
+    if (opts.help) {
+        self.do_help('help', {}, [subcmd], cb);
+        throw (new Error('internal error: did not expect do_help() to return'));
+    }
+};
+
+
+/*
+ * "Polls" a Moray for storage information and prints a summary to stdout.
+ * Optionally, you may provide an interval for which the Picker will poll and a
+ * count of polls to complete.
+ *
+ * Polling requires instantiating a Picker with a valid Moray client, which
+ * requires some configuration from the user.  This command expects the Muskie
+ * configuration format.  By default, we assume the configuration is located at
+ * /opt/smartdc/muskie/etc/config.json, which is where the configuration is
+ * located in a deployed webapi zone.
+ */
+MPicker.prototype.do_poll = function do_poll(subcmd, opts, args, cb) {
+    var self = this;
+    var interval, count, cfg, picker, picker_opts;
+
+    self.checkHelpRequested(subcmd, opts, cb);
+
+    if (args[0]) {
+        interval = mod_jsprim.parseInteger(args[0]);
+        if (typeof (interval) !== 'number') {
+            self.usage('invalid interval: "' + args[0] + '"', subcmd, cb);
+        }
+
+        if (args[1]) {
+            count = mod_jsprim.parseInteger(args[1]);
+            if (typeof (count) !== 'number' || count < 1) {
+                self.usage('invalid count: "' + args[1] + '"', subcmd, cb);
+            }
+        }
+    }
+
+    if (args.length > 2) {
+        self.usage('unexpected arguments: ' + args.slice(2), subcmd, cb);
+    }
+
+    var data;
+    try {
+        data = mod_fs.readFileSync(opts.config, 'utf8');
+        cfg = JSON.parse(data);
+    } catch (e) {
+        cb(new VError('Unable to load %s: %s', opts.config, e.message));
+        return;
+    }
+
+    picker_opts = {
+        log: LOG,
+        defaultMaxStreamingSizeMB: 5120,
+        maxUtilizationPct: 90,
+        mulitDC: cfg.storage.multiDC,
+        moray: cfg.storage.moray,
+        lag: cfg.storage.lag
+    };
+    if (interval) {
+        picker_opts.interval = interval * 1000;
+    }
+    var p = mod_picker.createClient(picker_opts);
+
+    function printSummary(db) {
+        mod_assert.object(db, 'db');
+
+        var columns, rows;
+
+        var dcs = Object.keys(db);
+
+        var dc_label = 'DATACENTER';
+        var msi_label = 'MANTA_STORAGE_ID';
+        var pu_label = '%USED';
+        var amb_label = 'AVAIL_MB';
+        var time_label = 'TIMESTAMP';
+
+        columns = [
+            {
+                label: dc_label,
+                width: 10
+            }, {
+                label: msi_label,
+                width: 25
+            }, {
+                label: pu_label,
+                width: 13
+            }, {
+                label: amb_label,
+                width: 13
+            }, {
+                label: time_label,
+                width: 30
+            }
+        ];
+
+        rows = [];
+        dcs.forEach(function (dc) {
+            var sharks = db[dc];
+
+            sharks.forEach(function (s) {
+                var obj = {};
+                obj[dc_label] = dc;
+                obj[msi_label] = s.manta_storage_id;
+                obj[pu_label] = s.percentUsed;
+                obj[amb_label] = s.availableMB;
+                obj[time_label] = new Date(s.timestamp).toISOString();
+                rows.push(obj);
+            });
+        });
+
+
+        mod_tab.emitTable({
+            columns: columns,
+            rows: rows,
+            omitHeader: opts.omitHeader
+        });
+    }
+
+    var iteration = 0;
+
+    /*
+     * The Picker emits a 'topology' event every time it receives a response
+     * from its polling, so we can listen for this to see the poll response.
+     */
+    p.on('topology', function onTopology(db) {
+        if (opts.all) {
+            console.log(JSON.stringify(db, null, 4));
+        } else if (opts.json) {
+            var obj = {};
+            var dcs = Object.keys(db);
+
+            dcs.forEach(function (dc) {
+                obj[dc] = [];
+                var sharks = db[dc];
+                sharks.forEach(function (s) {
+                    obj[dc].push({
+                        manta_storage_id: s.manta_storage_id,
+                        availableMB: s.availableMB,
+                        timestamp: s.timestamp,
+                        percentUsed: s.percentUsed
+                    });
+                });
+            });
+            console.log(JSON.stringify(obj, null, 4));
+        } else {
+            printSummary(db);
+        }
+
+        if (!interval || (count === ++iteration)) {
+            p.close();
+            cb();
+        }
+    });
+};
+
+MPicker.prototype.do_poll.options = commonOptions.concat([
+    {
+        group: 'mpicker poll options'
+    },
+    {
+        names: ['config', 'c'],
+        type: 'string',
+        help: 'Muskie configuration file',
+        default: '/opt/smartdc/muskie/etc/config.json',
+        helpArg: 'FILE',
+        completionType: 'file'
+    },
+    {
+        names: ['all', 'a'],
+        type: 'bool',
+        default: false,
+        help: 'Print all information available in storage records in JSON'
+    },
+    {
+        names: ['json', 'j'],
+        type: 'bool',
+        default: false,
+        help: 'Print storage records in JSON'
+    },
+    {
+        names: [ 'omitHeader', 'H' ],
+        type: 'bool',
+        help: 'Omit header row from tabular output',
+        default: false
+    }
+]);
+
+
+MPicker.prototype.do_poll.help = [
+    'Poll a Moray instance for storage records and summarizes the results.',
+    '',
+    'Usage:',
+    '    mpicker choose [OPTIONS] [INTERVAL [COUNT]]',
+    '',
+    '{{options}}',
+    ''
+].join('\n');
+
+
+/*
+ * Given an input set of storage records (real or constructed), a desired number
+ * of replicas, and an object size, see the output of an invocation of
+ * Picker.choose().
+ */
+MPicker.prototype.do_choose = function do_choose(subcmd, opts, args, cb) {
+    var size = opts.size;
+    var replicas = opts.replicas;
+    var dcs = [];
+
+    var user_db, user_dcs;
+    var p, p_opts, p_choices, p_err, p_stats, p_sharkCount;
+
+    function printChooseSummary(chooseStats) {
+        mod_assert.object(chooseStats, 'chooseStats');
+
+        var p_db = chooseStats.db;
+        var p_allDcs = Object.keys(p_db);
+        var p_dcsInUse = chooseStats.dcsInUse;
+        var p_offsets = chooseStats.offsets;
+
+        var summary = [];
+
+        summary.push('replicas requested: ' + replicas);
+        summary.push('size requested: ' + size + ' MB');
+
+        var allSharkCount = 0;
+        var inUseSharkCount = 0;
+        var sharksByDc = {};
+        p_allDcs.forEach(function (dc) {
+            var len = p_db[dc].length;
+            allSharkCount += len;
+            sharksByDc[dc] = {
+                count: len,
+                inUse: 0
+            };
+
+            var i = p_dcsInUse.indexOf(dc);
+            if (i !== -1) {
+                var c = p_db[dc].length - p_offsets[i];
+                sharksByDc[dc].inUse = c;
+                inUseSharkCount += c;
+            }
+        });
+
+        summary.push('storage server count by datacenter:');
+        p_allDcs.forEach(function (dc) {
+            summary.push('\t' + dc + ': ' + sharksByDc[dc].count +
+                ' (' + sharksByDc[dc].inUse + ' available)');
+        });
+        summary.push('total storage server count: ' + allSharkCount +
+            ' (' + inUseSharkCount + ' available)');
+
+        summary.push('');
+
+        if (p_err) {
+            summary.push('could not choose storage node set: ' +
+                p_err.cause().message);
+        } else {
+            mod_assert.object(p_choices, 'p_choices');
+            summary.push('choices:');
+
+            p_choices.forEach(function(c, i) {
+                summary.push(sprintf('\t%s:', i));
+                c.forEach(function (s, j) {
+                    summary.push(sprintf('\t\t%s (%s)', s['manta_storage_id'],
+                        s['datacenter']));
+                });
+
+                summary.push('');
+            });
+        }
+
+        console.log(summary.join('\n'));
+    }
+
+    mod_vasync.pipeline({
+        funcs: [
+        function readRecords(_, vcb) {
+            if (opts.file) {
+                mod_fs.readFile(opts.file, function (err, contents) {
+                    if (err) {
+                        err = new VError(err, 'reading %s', opts.file);
+                        vcb(err);
+                        return;
+                    }
+
+                    user_db = JSON.parse(contents);
+                    vcb();
+                });
+            } else {
+                var input = '';
+                process.stdin.on('data', function (data) {
+                    input += data;
+                });
+                process.stdin.on('end', function() {
+                    user_db = JSON.parse(input);
+                    vcb();
+                });
+            }
+        },
+        function validateRecords(_, vcb) {
+            mod_assert.object(user_db, 'user_db');
+
+            var errors = [];
+            user_dcs = Object.keys(user_db);
+            user_dcs.forEach(function (dc) {
+                records = user_db[dc];
+                records.forEach(function (r) {
+                    if (!r.manta_storage_id) {
+                        errors.push(new VError('"%s" record missing ' +
+                            '"manta_storage_id" identifier', dc));
+                        return;
+                    }
+
+                    if (!r.hasOwnProperty('availableMB')) {
+                        errors.push(new VError('%s missing "availableMB"',
+                            r.manta_storage_id));
+                    }
+
+                    if (r.datacenter) {
+                        if (r.datacenter !== dc) {
+                            errors.push(new VError('datacenter mismatch: ' +
+                                '"%s" grouped with datacenter "%s", but ' +
+                                'storage record reports datacenter "%s"',
+                                r.manta_storage_id, dc, r.datacenter));
+                        }
+                    } else {
+                        // Set the DC for the input if it's not set.
+                        r.datacenter = dc;
+                    }
+                });
+            });
+
+            if (errors.length !== 0) {
+                vcb(new MultiError(errors));
+            } else {
+                vcb();
+            }
+        },
+        function runChoose(_, vcb) {
+            p_opts = {
+                log: LOG,
+                defaultMaxStreamingSizeMB: 5120,
+                maxUtilizationPct: 90,
+                multiDC: user_dcs.length > 1,
+                standalone: true
+            };
+
+            p = mod_picker.createClient(p_opts);
+
+            p.setRecordsDb(user_db, function () {
+                var chooseOpts = {
+                    replicas: replicas,
+                    size: size
+                };
+                p.choose(chooseOpts, function (err, sharks, chooseStats) {
+                    if (err) {
+                        if (err.cause().name === 'PickerError') {
+                            p_err = err;
+                        } else {
+                            vcb(err);
+                            return;
+                        }
+                    }
+
+                    p_stats = chooseStats;
+                    p_choices = sharks;
+                    vcb();
+                });
+            });
+        },
+        function printChoices(_, vcb) {
+            if (opts.json) {
+                JSON.stringify(p_choices);
+            } else {
+                printChooseSummary(p_stats);
+            }
+
+            vcb();
+        }]}, function (err) {
+            cb(err);
+        });
+};
+
+MPicker.prototype.do_choose.options = [
+    {
+        group: 'mpicker choose options'
+    },
+    {
+        names: ['replicas', 'r'],
+        type: 'positiveInteger',
+        default: 2,
+        help: 'Number of replicas desired',
+        helpArg: 'REPLICAS'
+    },
+    {
+        names: ['size', 's'],
+        type: 'positiveInteger',
+        help: 'Object size in MB',
+        default: 1,
+        helpArg: 'SIZE'
+    },
+    {
+        names: ['file', 'f'],
+        type: 'string',
+        help: 'File containing records',
+        helpArg: 'FILE',
+        completionType: 'file'
+    },
+    {
+        names: ['json', 'j'],
+        type: 'bool',
+        default: false,
+        help: 'Print output in JSON.'
+    }
+];
+
+
+MPicker.prototype.do_choose.help = [
+    'Simulate Manta storage node selection for an object.',
+    '',
+    'Usage:',
+    '    mpicker choose [OPTIONS]           # storage records read from stdin',
+    '    mpicker choose [OPTIONS] -f FILE   # storage records in JSON file',
+    '',
+    '{{options}}',
+    '',
+    'Given a representation of storage nodes in a Manta, an object size, and a',
+    'desired number of replicas, this subcommand invokes the picker\'s',
+    'interface for selecting where to store an object in Manta.  This allows',
+    'you to see where an object might be stored in a system without actually',
+    'making any requests to Manta.',
+    '',
+    'This subcommand also summarizes how many storage nodes in each',
+    'datacenter, as represented in the input storage records, have capacity',
+    'for the input size object and replica count.  This can provide some',
+    'context as to why the picker chooses the storage node sets it did.',
+    '',
+    'Sometimes the picker cannot choose a storage node set for an object.  In',
+    'these cases, more informative error messages are provided than are',
+    'typically shown to end users of Manta.',
+    '',
+    'Information about storage nodes must be specified in a JSON object.  The',
+    'keys on this object must be the datacenter names.  The associated value',
+    'with each datacenter must be an array of objects, in which each element',
+    'is an object representing a storage node.  At a minimum, each storage',
+    'node object must have the properties `availableMB`, its available space ',
+    'in MB, and `manta_storage_id`, its storage ID in Manta.',
+    '',
+    'For example, the following JSON object represents a three-datacenter',
+    'deployment, in which each datacenter has two storage nodes:',
+    '{',
+    '   "emy-13": [',
+    '       {',
+    '           "manta_storage_id": "2.stor.emy-13.joyent.us"',
+    '           "availableMB": "2087636"',
+    '       },',
+    '       {',
+    '           "manta_storage_id": "1.stor.emy-13.joyent.us"',
+    '           "availableMB": "100"',
+    '       }',
+    '   ],',
+    '   "emy-14": [',
+    '       {',
+    '           "manta_storage_id": "3.stor.emy-13.joyent.us"',
+    '           "availableMB": "123890"',
+    '       },',
+    '       {',
+    '           "manta_storage_id": "4.stor.emy-13.joyent.us"',
+    '           "availableMB": "0"',
+    '       }',
+    '   ],',
+    '   "emy-15": [',
+    '       {',
+    '           "manta_storage_id": "6.stor.emy-13.joyent.us"',
+    '           "availableMB": "1235809"',
+    '       },',
+    '       {',
+    '           "manta_storage_id": "5.stor.emy-13.joyent.us"',
+    '           "availableMB": "25"',
+    '       }',
+    '   ]',
+    '}',
+    '',
+    'You may also simulate storage node selection from real storage records',
+    'easily using `choose` in combination with the `poll` subcommand.',
+    'For example:',
+    '   mpicker poll -j | mpicker choose -s 100 -r 3',
+    '',
+    'The above command would poll the configured Moray for storage node',
+    'records and simulate storage node selection for a 100 MB object with',
+    '3 replicas, without making any requests to store the object.',
+    '',
+].join('\n');
+
+
+
+//--- Mainline
+
+var cli = new MPicker();
+cli.showErrStack = false;
+mod_cmdln.main(cli);
diff --git a/lib/errors.js b/lib/errors.js
index d730095..bacc920 100644
--- a/lib/errors.js
+++ b/lib/errors.js
@@ -496,11 +496,14 @@ function NoMatchingRoleTagError() {
 util.inherits(NoMatchingRoleTagError, MuskieError);
 
 
-function NotEnoughSpaceError(size) {
+function NotEnoughSpaceError(size, cause) {
+    var message = sprintf('not enough free space for %d MB', size);
+
     MuskieError.call(this, {
         restCode: 'NotEnoughSpace',
         statusCode: 507,
-        message: sprintf('not enough free space for %d MB', size)
+        message: message,
+        cause: cause
     });
 }
 util.inherits(NotEnoughSpaceError, MuskieError);
diff --git a/lib/picker.js b/lib/picker.js
index 101a7b2..fade379 100644
--- a/lib/picker.js
+++ b/lib/picker.js
@@ -5,16 +5,16 @@
  */
 
 /*
- * Copyright (c) 2017, Joyent, Inc.
+ * Copyright (c) 2018, Joyent, Inc.
  */
 
 //
 // Picker is the component that selects where to send data on PUT requests.
 //
 // The only method public available from picker is `choose`.  Choose takes
-// a desired number of replicas and a size (in bytes), and then selects two
+// a desired number of replicas and a size (in bytes), and then selects three
 // random "tuples" (the number of items in a tuple is #replicas).  The first
-// random tuple is "primary," and then we have a backup tuple.  The contract
+// random tuple is "primary," and then we have 2 backup tuples.  The contract
 // here is that upstack code tries all hosts in "primary," and if all are up
 // we're good to go; if any fail it falls through to trying all hosts in
 // "secondary." While not the most sophisticated and/or error-proof approach,
@@ -50,12 +50,15 @@
 var EventEmitter = require('events').EventEmitter;
 var util = require('util');
 
+var assert = require('assert-plus');
 var jsprim = require('jsprim');
 var moray = require('moray');
-
-var assert = require('assert-plus');
 var once = require('once');
 
+var objCommon = require('./obj');
+
+var VError = require('verror');
+
 
 require('./errors');
 
@@ -174,11 +177,26 @@ function fetch_stub(opts, cb) {
     }
 }
 
+/*
+ * Used to encode more detailed information about storage selection errors.
+ * Providing an error cause allows us to expose more detailed information in
+ * logging about why the picker was unable to choose a storage set.
+ */
+function PickerError(msg) {
+    VError.call(this, {
+        name: 'PickerError'
+    }, msg);
+}
+util.inherits(PickerError, VError);
 
 
 // "this" must be bound to an instance of Picker. This simply
 // manages timers and calls `fetch`, above.
 function poll() {
+    assert.object(this.client, 'no client connected');
+    assert.bool(this.firstTopology, 'no topology flag set');
+    assert.ok(!this.standalone, 'polling not available in standalone mode');
+
     var opts = {
         lag: this.lag,
         moray: this.client,
@@ -225,43 +243,24 @@ function poll() {
             obj[v.datacenter].push(v);
         });
 
-        // We just defer to the next tick so we're not tying
-        // up the event loop to sort a lot if the list is large
-        process.nextTick(function () {
-            var count = 0;
-            var dcs = Object.keys(obj);
-
-            dcs.forEach(function (k) {
-                obj[k].sort(function (a, b) {
-                    if (a.availableMB < b.availableMB)
-                        return (-1);
-                    if (a.availableMB > b.availableMB)
-                        return (1);
-                    return (0);
-                });
-                count++;
-            });
-
-            /*
-             * In general, we don't want to replace a non-empty set of sharks
-             * with an empty one.  We make an exception at startup: provided
-             * the query to Moray did not result in any errors, we accept one
-             * empty result set.  This enables us to service requests that will
-             * not ask the Picker for a storage node, while remaining confident
-             * that once storage nodes become available, we'll know about them.
-             */
-            if (count > 0 || self.firstTopology) {
+       /*
+        * In general, we don't want to replace a non-empty set of sharks
+        * with an empty one.  We make an exception at startup: provided
+        * the query to Moray did not result in any errors, we accept one
+        * empty result set.  This enables us to service requests that will
+        * not ask the Picker for a storage node, while remaining confident
+        * that once storage nodes become available, we'll know about them.
+        */
+        if (Object.keys(obj) > 0 || self.firstTopology) {
                 self.firstTopology = false;
-                self.datacenters = dcs;
-                self.db = obj;
-                self.emit('topology', self.db);
-            } else {
-                self.log.warn('Picker.poll: could not find any minnow ' +
+                self.setRecordsDb(obj, function () {
+                    self.emit('topology', self.db);
+                    self.log.trace('Picker.poll: done');
+                });
+        } else {
+            self.log.warn('Picker.poll: could not find any minnow ' +
                     'instances');
-            }
-
-            self.log.trace('Picker.poll: done');
-        });
+        }
     });
 }
 
@@ -299,7 +298,8 @@ function shuffle(array) {
 // what the picker logic can then look at
 function lower_bound(set, size, low, high) {
     assert.arrayOfObject(set, 'set');
-    assert.number(size);
+    assert.number(size, 'size');
+    assert.optionalNumber(low, 'low');
 
     low = low || 0;
     high = high || set.length;
@@ -334,22 +334,20 @@ function lower_bound(set, size, low, high) {
  */
 function Picker(opts) {
     assert.object(opts, 'options');
-    assert.object(opts, 'options.moray');
-    assert.optionalBool(opts.multiDC, 'options.multiDC');
-    assert.optionalNumber(opts.interval, 'options.interval');
-    assert.optionalNumber(opts.lag, 'options.lag');
     assert.number(opts.defaultMaxStreamingSizeMB,
         'options.defaultMaxStreamingSizeMB');
     assert.object(opts.log, 'options.log');
     assert.number(opts.maxUtilizationPct, 'options.maxUtilizationPct');
+    assert.optionalObject(opts.moray, 'options.moray');
+    assert.optionalBool(opts.multiDC, 'options.multiDC');
+    assert.optionalNumber(opts.interval, 'options.interval');
+    assert.optionalNumber(opts.lag, 'options.lag');
+    assert.optionalBool(opts.standalone, 'options.standalone');
 
     EventEmitter.call(this);
 
-    var morayOptions = jsprim.deepCopy(opts.moray);
-    morayOptions.log = opts.log;
-
-    this.client = moray.createClient(morayOptions);
     this.db = null;
+    this.datacenters = null;
     this.dcIndex = -1;
     this.interval = parseInt(opts.interval || 30000, 10);
     this.lag = parseInt(opts.lag || (60 * 60 * 1000), 10);
@@ -359,10 +357,23 @@ function Picker(opts) {
     this.defMaxSizeMB = opts.defaultMaxStreamingSizeMB;
     this.utilization = opts.maxUtilizationPct;
 
-    this.client.once('connect', poll.bind(this));
+    this.client = null;
 
-    this.firstTopology = true;
-    this.once('topology', this.emit.bind(this, 'connect'));
+    /*
+     * `Standalone` mode is used only when an instance of the Picker is needed
+     * without having to connect to a Moray first (e.g., for testing).
+     */
+    if (!opts.standalone) {
+        assert.object(opts.moray, 'options.moray');
+
+        var morayOptions = jsprim.deepCopy(opts.moray);
+        morayOptions.log = opts.log;
+
+        this.client = moray.createClient(morayOptions);
+        this.client.once('connect', poll.bind(this));
+        this.firstTopology = true;
+        this.once('topology', this.emit.bind(this, 'connect'));
+    }
 }
 util.inherits(Picker, EventEmitter);
 
@@ -395,10 +406,11 @@ Picker.prototype.choose = function choose(opts, cb) {
     var dcs = [];
     var log = opts.log || this.log;
     var offsets = [];
-    var replicas = opts.replicas || 2;
+    var replicas = opts.replicas || objCommon.DEF_NUM_COPIES;
     var seen = [];
     var self = this;
     var size = Math.ceil((opts.size || 0) / 1048576) || this.defMaxSizeMB;
+    var err, err_msg;
 
     log.debug({
         replicas: replicas,
@@ -406,6 +418,12 @@ Picker.prototype.choose = function choose(opts, cb) {
         defMaxSizeMB: this.defMaxSizeMB
     }, 'Picker.choose: entered');
 
+    /*
+     * Determine the index of the first storage node for each DC that has space
+     * for an object of the requested size.  If no sharks in a given DC have
+     * enough space, we exclude them from the possible set of DCs to choose
+     * from.
+     */
     this.datacenters.forEach(function filterDatacenters(dc) {
         var l = lower_bound(self.db[dc], size);
         if (l !== -1) {
@@ -415,16 +433,35 @@ Picker.prototype.choose = function choose(opts, cb) {
     });
     dcs = shuffle(dcs);
 
+    var chooseStats = {
+        db: self.db,
+        dcsInUse: dcs,
+        offsets: offsets
+    };
+
+    // TODO: simplify this conditional?
     if ((replicas > 1 && this.multiDC && dcs.length < 2) ||
         !dcs.length ||
         (replicas > 1 && dcs.some(function (dc) {
             return (!dc.length);
         }))) {
         log.warn('Picker.choose: not enough DCs available');
-        cb(new NotEnoughSpaceError(size));
+
+        err_msg = 'not enough DCs available';
+        err = new NotEnoughSpaceError(size, new PickerError(err_msg));
+        cb(err, null, chooseStats);
         return;
     }
 
+    /*
+     * Pick a random shark from the next DC in the round robin ordering.  If it
+     * hasn't yet been used for a set, return the shark.
+     *
+     * If the shark has been chosen for another set, iterate through all sharks
+     * in the DC until we find one that hasn't yet been seen.
+     *
+     * If there are no sharks that haven't yet been used in the DC, return null.
+     */
     function host() {
         if (++self.dcIndex >= dcs.length)
             self.dcIndex = 0;
@@ -459,6 +496,9 @@ Picker.prototype.choose = function choose(opts, cb) {
         });
     }
 
+    /*
+     * Return a set with `replicas` sharks.
+     */
     function set() {
         var s = [];
 
@@ -479,7 +519,10 @@ Picker.prototype.choose = function choose(opts, cb) {
         var tuple = set();
 
         if (!sharks.length && (!tuple || tuple.length < replicas)) {
-            cb(new NotEnoughSpaceError(size));
+            err_msg = 'copies requested exceeds number of available ' +
+                'storage nodes';
+            err = new NotEnoughSpaceError(size, new PickerError(err_msg));
+            cb(err, null, chooseStats);
             return;
         } else if (tuple && this.multiDC && replicas > 1) {
             var _dcs = tuple.map(function (s) {
@@ -490,8 +533,11 @@ Picker.prototype.choose = function choose(opts, cb) {
                 return (last);
             }, []);
 
+            // TODO: not sure how we could ever hit this.
             if (_dcs.length < 2) {
-                cb(new NotEnoughSpaceError(size));
+                err_msg = 'copies requested exceeds number of available DCs';
+                err = new NotEnoughSpaceError(size, new PickerError(err_msg));
+                cb(err, null, chooseStats);
                 return;
             }
         }
@@ -505,7 +551,44 @@ Picker.prototype.choose = function choose(opts, cb) {
         sharks: sharks,
         size: size
     }, 'Picker.choose: done');
-    cb(null, sharks);
+    cb(null, sharks, chooseStats);
+};
+
+
+/*
+ * Given an input set of Moray records, sort them and set necessary properties
+ * on the Picker object.
+ */
+Picker.prototype.setRecordsDb = function setRecordsDb(db, cb) {
+    assert.object(db, 'db');
+    assert.func(cb, 'cb');
+
+    var self = this;
+
+    var dcs = Object.keys(db);
+
+   /*
+    * We defer to the end of the event loop, so that it's not tied up
+    * sorting if the list is large.
+    */
+    setImmediate(function () {
+        dcs.forEach(function (k) {
+            db[k].sort(function (a, b) {
+                if (a.availableMB < b.availableMB) {
+                    return (-1);
+                }
+                if (a.availableMB > b.availableMB) {
+                    return (1);
+                }
+
+                return (0);
+            });
+        });
+
+        self.db = db;
+        self.datacenters = dcs;
+        cb();
+    });
 };
 
 
diff --git a/package.json b/package.json
index 5470605..7115b69 100644
--- a/package.json
+++ b/package.json
@@ -17,6 +17,7 @@
         "backoff": "2.3.0",
         "bunyan": "0.22.1",
         "bunyan-syslog": "0.2.2",
+        "cmdln": "4.3.0",
         "cueball": "2.2.9",
         "dashdash": "1.3.2",
         "deep-equal": "0.0.0",
@@ -38,6 +39,7 @@
         "once": "1.3.0",
         "restify": "2.6.3",
         "sshpk": "1.13.1",
+        "tab": "1.0.0",
         "vasync": "^1.5.0",
         "verror": "^1.9.0",
         "watershed": "0.3.0",
-- 
2.21.0

