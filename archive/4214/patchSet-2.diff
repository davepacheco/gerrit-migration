From 525dab78722e70fc62704976ff5bae09d36f6650 Mon Sep 17 00:00:00 2001
From: Hans Rosenfeld <hans.rosenfeld@joyent.com>
Date: Tue, 12 Jun 2018 17:34:56 +0200
Subject: [PATCH] OS-6832 reclaim memory when NOSLEEP bhyve allocation fails

---
 usr/src/uts/i86pc/io/vmm/vmm_sol_vm.c | 41 ++++++++++++++++++++++++---
 1 file changed, 37 insertions(+), 4 deletions(-)

diff --git a/usr/src/uts/i86pc/io/vmm/vmm_sol_vm.c b/usr/src/uts/i86pc/io/vmm/vmm_sol_vm.c
index d8a44ddf37..c915e927ad 100644
--- a/usr/src/uts/i86pc/io/vmm/vmm_sol_vm.c
+++ b/usr/src/uts/i86pc/io/vmm/vmm_sol_vm.c
@@ -19,6 +19,7 @@
 #include <sys/list.h>
 #include <sys/mman.h>
 #include <sys/types.h>
+#include <sys/ddi.h>
 #include <sys/sysmacros.h>
 #include <sys/machsystm.h>
 #include <sys/vmsystm.h>
@@ -932,6 +933,39 @@ vm_object_pager_sg(vm_object_t vmo, uintptr_t off, pfn_t *lpfn, uint_t *lvl)
 	return (pfn);
 }
 
+static void *
+vm_default_alloc(size_t size)
+{
+	int npages = btop(size);
+	int retries = 60;
+
+	mutex_enter(&freemem_lock);
+	if (availrmem < npages) {
+		mutex_exit(&freemem_lock);
+
+		/*
+		 * Set needfree and wait for the ZFS ARC reap thread to free up
+		 * some memory.
+		 */
+		page_needfree(btop(size));
+
+		mutex_enter(&freemem_lock);
+		while ((availrmem < npages) && retries-- > 0) {
+			mutex_exit(&freemem_lock);
+			delay(drv_usectohz(1 * MICROSEC));
+			mutex_enter(&freemem_lock);
+		}
+		mutex_exit(&freemem_lock);
+
+		page_needfree(-btop(size));
+	} else {
+		mutex_exit(&freemem_lock);
+	}
+
+	/* XXXJOY: opt-in to larger pages? */
+	return (vmem_alloc(vmm_alloc_arena, size, KM_NOSLEEP));
+}
+
 vm_object_t
 vm_object_allocate(objtype_t type, vm_pindex_t psize)
 {
@@ -947,9 +981,9 @@ vm_object_allocate(objtype_t type, vm_pindex_t psize)
 	vmo->vmo_attr = VM_MEMATTR_DEFAULT;
 
 	switch (type) {
-	case OBJT_DEFAULT: {
-		/* XXXJOY: opt-in to larger pages? */
-		vmo->vmo_data = vmem_alloc(vmm_alloc_arena, size, KM_NOSLEEP);
+	case OBJT_DEFAULT:
+		vmo->vmo_data = vm_default_alloc(size);
+
 		if (vmo->vmo_data == NULL) {
 			mutex_destroy(&vmo->vmo_lock);
 			kmem_free(vmo, sizeof (*vmo));
@@ -958,7 +992,6 @@ vm_object_allocate(objtype_t type, vm_pindex_t psize)
 		/* XXXJOY: Better zeroing approach? */
 		bzero(vmo->vmo_data, size);
 		vmo->vmo_pager = vm_object_pager_heap;
-	}
 		break;
 	case OBJT_SG:
 		vmo->vmo_data = NULL;
-- 
2.21.0

