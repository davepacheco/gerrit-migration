From b5d1f788868666f0d0264f3121cd0031e55e0092 Mon Sep 17 00:00:00 2001
From: Rui Loura <rui@joyent.com>
Date: Fri, 13 Sep 2019 16:14:22 -0400
Subject: [PATCH] MANTA-4550 create manta moray client module for managing per
 shard connections MANTA-4534 rebalancer should take option to specify
 location of config.json

---
 Cargo.toml           |   3 +-
 src/agent.rs         |   1 +
 src/config.json      |   3 -
 src/config.rs        |  33 +++++---
 src/error.rs         |  23 ++++++
 src/jobs/evacuate.rs | 188 ++++++++++++++++++++++++++++++-------------
 src/lib.rs           |   1 +
 src/main.rs          |   2 +-
 src/moray_client.rs  | 116 ++++++++++++++++++++++++++
 src/picker.rs        |   2 +-
 src/util.rs          |  15 ----
 11 files changed, 299 insertions(+), 88 deletions(-)
 create mode 100644 src/moray_client.rs

diff --git a/Cargo.toml b/Cargo.toml
index 4fde386..a8c8a6f 100644
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -20,7 +20,8 @@ base64 = "0.10.1"
 uuid = { version = "0.7.4", features = ["v4"] }
 libmanta = { git = "https://github.com/joyent/rust-libmanta", tag = "v0.1.0" }
 clap = "2.33.0"
-sharkspotter = { git = "https://github.com/joyent/rust-sharkspotter", tag = "v0.2.0" }
+#sharkspotter = { git = "https://github.com/joyent/rust-sharkspotter", tag =
+sharkspotter = { git = "https://github.com/joyent/rust-sharkspotter", branch = "return_etag" }
 crossbeam-channel = "0.3.8"
 crossbeam-deque = "0.7.1"
 serde = { version = "1.0.91", features = ["derive"] }
diff --git a/src/agent.rs b/src/agent.rs
index c879f77..46e14a5 100644
--- a/src/agent.rs
+++ b/src/agent.rs
@@ -637,6 +637,7 @@ fn process_task(task: &mut Task) {
     // complete and move on.
     if path.exists() && verify_file_md5(&file_path, &task.md5sum) {
         task.set_status(TaskStatus::Complete);
+        // TODO: Remove?  causes panic?
         println!("Checksum passed -- no need to download.");
         return;
     }
diff --git a/src/config.json b/src/config.json
index 4d8aaa7..f1e78f1 100644
--- a/src/config.json
+++ b/src/config.json
@@ -4,9 +4,6 @@
   "database_url": "rebalancer.sqlite",
   "database_buffer_size": 100,
   "shards": [
-      {
-        "host": "3.moray.staging.joyent.us"
-      },
       {
         "host": "2.moray.staging.joyent.us",
         "last": true
diff --git a/src/config.rs b/src/config.rs
index 283b8d0..56381f1 100644
--- a/src/config.rs
+++ b/src/config.rs
@@ -33,6 +33,7 @@ pub struct Config {
 }
 
 impl Config {
+    // TODO: there's a bug here that 1 will always be the min shard number
     pub fn min_shard_num(&self) -> u32 {
         self.shards.iter().fold(1, |res, elem| {
             let shard_num = util::shard_host2num(elem.host.as_str());
@@ -70,8 +71,8 @@ pub struct Command {
 }
 
 impl Command {
-    pub fn parse_config() -> Result<Config, Error> {
-        let file = File::open("./target/debug/config.json")?;
+    pub fn parse_config(config_path: &str) -> Result<Config, Error> {
+        let file = File::open(config_path)?;
         let reader = BufReader::new(file);
         let config: Config = serde_json::from_reader(reader)?;
 
@@ -79,9 +80,6 @@ impl Command {
     }
     pub fn new() -> Result<Command, Error> {
         let mut subcommand = SubCommand::Server;
-        let config = Command::parse_config()?;
-
-        let domain_name = String::from(config.domain_name.as_str());
 
         let matches: ArgMatches = App::new("remora")
             .version("0.1.0")
@@ -100,6 +98,15 @@ impl Command {
                     .long("agent")
                     .help("Run in agent mode"),
             )
+            .arg(
+                Arg::with_name("config_file")
+                    .short("c")
+                    .long("config_file")
+                    .takes_value(true)
+                    .value_name("CONFIG_FILE")
+                    .required(true)
+                    .help("Specify the location of the config file")
+            )
             .subcommand(
                 // TODO: server subcommand
                 ClapSubCommand::with_name("job")
@@ -154,8 +161,6 @@ impl Command {
                                             .value_name("DOMAIN_NAME")
                                             .help("Domain of Manta Deployment")
                                             .required(false)
-                                            .default_value(domain_name
-                                                .as_str())
                                     ),
 
                             ),
@@ -163,6 +168,11 @@ impl Command {
             )
             .get_matches();
 
+        let config_file = matches
+            .value_of("config_file")
+            .expect("Missing config file name");
+        let config = Command::parse_config(config_file)?;
+
         if matches.is_present("server") {
             subcommand = SubCommand::Server;
         }
@@ -191,7 +201,7 @@ impl Command {
 // TODO:
 // This should really be removed in favor of the following:
 // 1. Command::new() handling override of domain_name from config file
-// 2. Job::new() taking all args necssary to create new Job Action (e.g.
+// 2. Job::new() taking all args necessary to create new Job Action (e.g.
 // EvacuateJob)
 fn job_subcommand_handler(matches: &ArgMatches, config: Config) -> SubCommand {
     let shark_id = matches.value_of("from_shark").unwrap_or("").to_string();
@@ -202,8 +212,11 @@ fn job_subcommand_handler(matches: &ArgMatches, config: Config) -> SubCommand {
     // we plan to have a server mode that will generate multiple jobs in a
     // single process.
     let db_url = format!("{}.{}", &config.database_url, process::id());
-    let job_action =
-        JobAction::Evacuate(Box::new(EvacuateJob::new(from_shark, &db_url)));
+    let job_action = JobAction::Evacuate(Box::new(EvacuateJob::new(
+        from_shark,
+        domain_name,
+        &db_url,
+    )));
     let job = Job::new(job_action, config);
 
     SubCommand::DoJob(Box::new(job))
diff --git a/src/error.rs b/src/error.rs
index a15adb7..540a940 100644
--- a/src/error.rs
+++ b/src/error.rs
@@ -9,6 +9,7 @@
  */
 
 use std::fmt;
+use trust_dns_resolver::error::ResolveErrorKind;
 
 #[derive(Debug)]
 pub enum Error {
@@ -18,6 +19,7 @@ pub enum Error {
     Diesel(diesel::result::Error),
     SerdeJson(serde_json::error::Error),
     Reqwest(reqwest::Error),
+    Resolve(trust_dns_resolver::error::ResolveError),
 }
 
 impl std::error::Error for Error {
@@ -29,6 +31,19 @@ impl std::error::Error for Error {
             Error::Diesel(e) => e.description(),
             Error::SerdeJson(e) => e.description(),
             Error::Reqwest(e) => e.description(),
+            Error::Resolve(e) => {
+                let kind = e.kind();
+                match kind {
+                    ResolveErrorKind::Message(m) => m,
+                    ResolveErrorKind::Io => "IO Error",
+                    ResolveErrorKind::Msg(m) => m.as_str(),
+                    ResolveErrorKind::NoRecordsFound { .. } => {
+                        "No Records Found"
+                    }
+                    ResolveErrorKind::Proto => "Proto Error",
+                    ResolveErrorKind::Timeout => "Request Timed Out",
+                }
+            }
         }
     }
 }
@@ -69,6 +84,12 @@ impl From<reqwest::Error> for Error {
     }
 }
 
+impl From<trust_dns_resolver::error::ResolveError> for Error {
+    fn from(error: trust_dns_resolver::error::ResolveError) -> Self {
+        Error::Resolve(error)
+    }
+}
+
 impl fmt::Display for Error {
     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
         match self {
@@ -78,6 +99,7 @@ impl fmt::Display for Error {
             Error::Diesel(e) => write!(f, "{}", e),
             Error::SerdeJson(e) => write!(f, "{}", e),
             Error::Reqwest(e) => write!(f, "{}", e),
+            Error::Resolve(e) => write!(f, "{}", e),
         }
     }
 }
@@ -97,6 +119,7 @@ pub enum InternalErrorCode {
     AssignmentLookupError,
     AssignmentGetError,
     LockError,
+    HashNotFound,
 }
 
 impl fmt::Display for InternalError {
diff --git a/src/jobs/evacuate.rs b/src/jobs/evacuate.rs
index c168e48..6007f69 100644
--- a/src/jobs/evacuate.rs
+++ b/src/jobs/evacuate.rs
@@ -15,8 +15,8 @@ use crate::jobs::{
     Assignment, AssignmentId, AssignmentPayload, AssignmentState, ObjectId,
     StorageId, Task, TaskStatus,
 };
+use crate::moray_client;
 use crate::picker::{self as mod_picker, SharkSource, StorageNode};
-use crate::util;
 
 use std::collections::HashMap;
 use std::error::Error as _Error;
@@ -29,7 +29,6 @@ use crossbeam_channel as crossbeam;
 use crossbeam_channel::TryRecvError;
 use crossbeam_deque::{Injector, Steal};
 use libmanta::moray::{MantaObject, MantaObjectShark};
-use moray::objects::{Etag, MethodOptions};
 use reqwest;
 use slog::{o, Drain, Logger};
 use std::borrow::Borrow;
@@ -37,6 +36,7 @@ use threadpool::ThreadPool;
 
 // --- Diesel Stuff, TODO This should be refactored --- //
 
+use crate::moray_client::MantaMorayClient;
 use diesel::prelude::*;
 
 // TODO: move database stuff somewhere.
@@ -48,6 +48,7 @@ table! {
         assignment_id -> Text,
         object -> Text,
         shard -> Integer,
+        etag -> Text,
         status -> EvacuateObjectStatusMapping,
     }
 }
@@ -65,6 +66,7 @@ pub struct EvacuateObjectDB {
     pub assignment_id: AssignmentId,
     pub object: String,
     pub shard: i32,
+    pub etag: String,
     pub status: EvacuateObjectStatus,
 }
 
@@ -76,6 +78,7 @@ struct FiniMsg;
 pub struct SharkSpotterObject {
     pub shard: i32,
     pub object: MantaObject,
+    pub etag: String,
 }
 
 #[derive(Debug, Clone, PartialEq, DbEnum)]
@@ -105,6 +108,7 @@ pub struct EvacuateObject {
     pub id: ObjectId,        // MantaObject ObjectId
     pub object: MantaObject, // The MantaObject being rebalanced
     pub shard: i32,          // shard number of metadata object record
+    pub etag: String,
     pub status: EvacuateObjectStatus,
     // Status of the object in the evacuation job
 }
@@ -116,6 +120,7 @@ impl EvacuateObject {
             id: ssobj.object.object_id.to_owned(),
             object: ssobj.object,
             shard: ssobj.shard,
+            etag: ssobj.etag,
             ..Default::default()
         }
     }
@@ -129,6 +134,7 @@ impl EvacuateObject {
             id: self.id.clone(),
             object: serde_json::to_string(&self.object)?,
             shard: self.shard,
+            etag: self.etag.clone(),
             status: self.status.clone(),
         })
     }
@@ -167,6 +173,8 @@ pub struct EvacuateJob {
     /// SqliteConnection to local database.
     pub conn: Mutex<SqliteConnection>,
 
+    pub moray_client: Mutex<moray_client::MantaMorayClient>,
+
     /// Accumulator for total time spent on DB inserts. (test/dev)
     pub total_db_time: Mutex<u128>,
 }
@@ -174,13 +182,24 @@ pub struct EvacuateJob {
 impl EvacuateJob {
     /// Create a new EvacauteJob instance.
     /// As part of this initialization also create a new SqliteConnection.
-    pub fn new<S: Into<String>>(from_shark: S, db_url: &str) -> Self {
+    pub fn new<S: Into<String>>(
+        from_shark: S,
+        domain_name: &str,
+        db_url: &str,
+    ) -> Self {
         let manta_storage_id = from_shark.into();
+        let plain = slog_term::PlainSyncDecorator::new(std::io::stdout());
+        let log = Logger::root(
+            Mutex::new(slog_term::FullFormat::new(plain).build()).fuse(),
+            o!("build-id" => "0.1.0"),
+        );
         let conn = SqliteConnection::establish(db_url)
             .unwrap_or_else(|_| panic!("Error connecting to {}", db_url));
+        let moray_client =
+            Mutex::new(MantaMorayClient::new(domain_name, log.clone()));
         Self {
             min_avail_mb: Some(1000),
-            max_tasks_per_assignment: Some(100),
+            max_tasks_per_assignment: Some(1000),
             dest_shark_list: RwLock::new(HashMap::new()),
             assignments: RwLock::new(HashMap::new()),
             from_shark: MantaObjectShark {
@@ -189,6 +208,7 @@ impl EvacuateJob {
             },
             conn: Mutex::new(conn),
             total_db_time: Mutex::new(0),
+            moray_client,
         }
     }
 
@@ -211,6 +231,7 @@ impl EvacuateJob {
                     assignment_id TEXT,
                     object TEXT,
                     shard Integer,
+                    etag TEXT,
                     status TEXT CHECK(status IN ('unprocessed', 'assigned',
                     'skipped', 'post_processing', 'complete')) NOT NULL
                 );
@@ -429,11 +450,54 @@ impl EvacuateJob {
         Ok(ret)
     }
 
+    // One other alternative is to try
+    /*
+    diesel::insert_into(users)
+    .values(&user2)
+    .on_conflict(id)
+    .do_update()
+    .set(name.eq("I DONT KNOW ANYMORE"))
+    .execute(&conn);
+    */
+    // Quick tests show that the below implementation scales very well:
+    // 100 objects: 12ms or (1/10 time/obj)
+    // 500 objects: 25ms (1/20 time/obj)
+    // 1000 objects: 52.5ms (1/19 time/obj)
+    fn mark_many_objects(
+        &self,
+        vec_obj_ids: Vec<String>,
+        to_status: EvacuateObjectStatus,
+    ) -> usize {
+        use self::evacuateobjects::dsl::*;
+
+        let locked_conn = self.conn.lock().expect("db conn lock");
+        let len = vec_obj_ids.len();
+
+        debug!("Marking {} objects as {:?}", len, to_status);
+        let now = std::time::Instant::now();
+        let ret = diesel::update(evacuateobjects)
+            .filter(id.eq_any(vec_obj_ids))
+            .set(status.eq(to_status))
+            .execute(&*locked_conn)
+            .unwrap_or_else(|e| {
+                let msg = format!("LocalDB: Error updating {}", e);
+                error!("{}", msg);
+                panic!(msg);
+            });
+        debug!(
+            "eq_any update of {} took {}ms",
+            len,
+            now.elapsed().as_millis()
+        );
+
+        ret
+    }
+
     /// Mark all objects with a given assignment ID with the specified
     /// EvacuateObjectStatus
     fn mark_assignment_objects(
         &self,
-        id: &AssignmentId,
+        id: &str,
         to_status: EvacuateObjectStatus,
     ) -> usize {
         use self::evacuateobjects::dsl::{
@@ -476,7 +540,7 @@ impl EvacuateJob {
 
     fn get_assignment_objects(
         &self,
-        id: &AssignmentId,
+        id: &str,
         status_filter: EvacuateObjectStatus,
     ) -> Vec<EvacuateObjectDB> {
         use self::evacuateobjects::dsl::{
@@ -608,20 +672,11 @@ impl UpdateMetadata for EvacuateJob {
     fn update_object_shark(
         &self,
         mut object: MantaObject,
+        etag: String,
+        shard: u32,
         new_shark: &StorageNode,
     ) -> Result<MantaObject, Error> {
         let old_shark = &self.from_shark;
-        let obj = serde_json::to_string(&object)?;
-        let etag = match util::crc_hex_str(&obj) {
-            Some(o) => o,
-            None => {
-                return Err(InternalError::new(
-                    None,
-                    "Error getting etag from Manta Object",
-                )
-                .into())
-            }
-        };
 
         // Replace shark value
         let mut shark_found = false;
@@ -637,31 +692,11 @@ impl UpdateMetadata for EvacuateJob {
             }
         }
 
-        // Prepare metadata message.
-        let key = object.key.as_str();
-        let value =
-            serde_json::to_value(&object).expect("Serialize Manta Object");
-        let mut opts = MethodOptions::default();
+        let mut manta_moray_client =
+            self.moray_client.lock().expect("moray client lock");
 
-        opts.etag = Etag::Specified(etag);
+        manta_moray_client.put_object(shard, &object, &etag)?;
 
-        trace!(
-            "Updating metadata. Key: {}\nValue: {}\nopts: {:?}",
-            key,
-            value,
-            opts
-        );
-
-        // TODO: The EvacuateJob struct should implement a moray client hash
-        // and we can call a "get_moray_client()" method here that will
-        // get an existing client, or create a new client if need be.
-        /*
-        mclient.put_object("manta", key, value, &opts, |o| {
-                debug!("Updated object metadata: {}", &o);
-                Ok(())
-            },
-        ).expect("put_object");
-        */
         Ok(object)
     }
 }
@@ -793,19 +828,29 @@ fn start_sharkspotter(
         .name(String::from("sharkspotter"))
         .spawn(move || {
             let mut count = 0;
-            sharkspotter::run(config, log, move |object, shard| {
+            sharkspotter::run(config, log, move |object, shard, etag| {
+                trace!("Sharkspotter discovered object: {:#?}", &object);
                 // while testing, limit the number of objects processed for now
                 count += 1;
-                if count > 2000 {
+                if count > 2 {
                     return Err(std::io::Error::new(
                         ErrorKind::Other,
                         "Just stop already",
                     ));
                 }
 
+                if shard > std::i32::MAX as u32 {
+                    error!("Found shard number over int32 max");
+                    return Err(std::io::Error::new(
+                        ErrorKind::Other,
+                        "Exceeded max number of shards",
+                    ));
+                }
+
                 let ssobj = SharkSpotterObject {
                     shard: shard as i32,
                     object,
+                    etag,
                 };
                 obj_tx
                     .send(ssobj)
@@ -986,9 +1031,11 @@ fn start_assignment_generator(
                 let mut eobj_vec: Vec<EvacuateObject> = vec![];
 
                 debug!(
-                    "Filling up new assignment with max_tasks: {:#?}, \
+                    "Filling up new assignment for {} with max_tasks: {:#?}, \
                      and available_space: {}",
-                    &max_tasks, &available_space
+                    &assignment.dest_shark.manta_storage_id,
+                    &max_tasks,
+                    &available_space
                 );
 
                 // Start Task Loop
@@ -1022,14 +1069,10 @@ fn start_assignment_generator(
                     }
 
                     let obj = &eobj.object;
-                    let obj_on_dest = obj
-                        .sharks
-                        .iter()
-                        .find(|s| {
-                            s.manta_storage_id
-                                == assignment.dest_shark.manta_storage_id
-                        })
-                        .is_some();
+                    let obj_on_dest = obj.sharks.iter().any(|s| {
+                        s.manta_storage_id
+                            == assignment.dest_shark.manta_storage_id
+                    });
 
                     // We've found the object on the destination shark.  We will
                     // need to skip this object for now and find a destination
@@ -1187,6 +1230,8 @@ trait UpdateMetadata: Sync + Send {
     fn update_object_shark(
         &self,
         object: MantaObject,
+        etag: String,
+        shard: u32,
         new_shark: &StorageNode,
     ) -> Result<MantaObject, Error>;
 }
@@ -1282,6 +1327,7 @@ fn start_assignment_checker(
                     .clone();
 
                 debug!("Checking Assignments");
+
                 if !run
                     && assignments
                         .values()
@@ -1391,6 +1437,7 @@ fn metadata_update_worker(
 
             let mut updated_objects = vec![];
             for obj in objects {
+                let etag = obj.etag;
                 let mut mobj: MantaObject =
                     match serde_json::from_str(&obj.object) {
                         Ok(o) => o,
@@ -1404,16 +1451,29 @@ fn metadata_update_worker(
                         }
                     };
 
+                // Unfortunately sqlite only accepts signed integers.  So we
+                // have to do the conversion here and cross our fingers that
+                // we don't have more than 2.1 billion shards.
+                // We do check this value coming in from sharkspotter as well.
+                if obj.shard < 0 {
+                    // TODO: persistent error (panic for now)
+                    panic!("Cannot have a negative shard");
+                }
+                let shard = obj.shard as u32;
+
                 // This function updates the manta object with the new
                 // sharks in the Manta Metadata tier, and then returns the
                 // updated Manta metadata object.  It does not update the
                 // state of the associated EvacuateObject in the local database.
-                mobj = match job_action.update_object_shark(mobj, dest_shark) {
+                mobj = match job_action
+                    .update_object_shark(mobj, etag, shard, dest_shark)
+                {
                     Ok(o) => o,
                     Err(e) => {
                         // TODO: log a persistent error for final job report.
                         error!(
-                            "Error updating {}, with dest_shark {:?}: {}",
+                            "MD Update worker: Error updating \n\n{:#?}, with \
+                             dest_shark {:?}\n\n{}",
                             &obj.object, dest_shark, e
                         );
                         continue;
@@ -1446,10 +1506,17 @@ fn metadata_update_worker(
                 }
             }
 
+            // https://stackoverflow
+            // .com/questions/47626047/execute-an-insert-or-update-using-diesel
             // TODO: batch update all objects in `updated_objects` with
             // EvacuateObjectStatus::Complete in the local DB meaning we are
             // completely done and this object has been rebalanced.
             // This is the finish line.
+
+            job_action.mark_many_objects(
+                updated_objects,
+                EvacuateObjectStatus::Complete,
+            );
         }
     }
 }
@@ -1596,6 +1663,7 @@ mod tests {
 
         let job_action = EvacuateJob::new(
             String::from("1.stor.joyent.us"),
+            "joyent.us",
             "empty_picker_test.db",
         );
         let job_action = Arc::new(job_action);
@@ -1656,8 +1724,11 @@ mod tests {
         let (md_update_tx, md_update_rx) = crossbeam::bounded(5);
         let (checker_fini_tx, checker_fini_rx) = crossbeam::bounded(1);
 
-        let job_action =
-            EvacuateJob::new(String::from("1.stor.joyent.us"), "full_test.db");
+        let job_action = EvacuateJob::new(
+            String::from("1.stor.joyent.us"),
+            "east.joyent.us",
+            "full_test.db",
+        );
         let conn = job_action.conn.lock().expect("db connection lock");
         conn.execute(r#"DROP TABLE evacuateobjects"#)
             .unwrap_or_else(|e| {
@@ -1671,6 +1742,7 @@ mod tests {
                 assignment_id TEXT,
                 object TEXT,
                 shard Integer,
+                etag TEXT,
                 status TEXT CHECK(status IN ('unprocessed', 'assigned',
                 'skipped', 'post_processing', 'complete')) NOT NULL
             );"#,
@@ -1684,7 +1756,7 @@ mod tests {
         let mut test_objects = vec![];
 
         let mut g = StdThreadGen::new(10);
-        for _ in 0..1000 {
+        for _ in 0..2 {
             let mobj = MantaObject::arbitrary(&mut g);
             test_objects.push(mobj);
         }
@@ -1699,6 +1771,8 @@ mod tests {
                     let ssobj = SharkSpotterObject {
                         shard: 1,
                         object: o.clone(),
+                        // TODO
+                        etag: String::from("Fake_etag"),
                     };
                     match obj_tx.send(ssobj) {
                         Ok(()) => (),
diff --git a/src/lib.rs b/src/lib.rs
index aba43e0..8e52314 100644
--- a/src/lib.rs
+++ b/src/lib.rs
@@ -24,5 +24,6 @@ pub mod jobs;
 pub mod agent;
 pub mod config;
 pub mod error;
+pub(crate) mod moray_client;
 pub mod picker;
 pub mod util;
diff --git a/src/main.rs b/src/main.rs
index 486507e..44a0e03 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -23,7 +23,7 @@ fn main() -> Result<(), Error> {
         SubCommand::Server => Ok(()),
         SubCommand::DoJob(job) => job.run(),
         SubCommand::Agent => {
-            Agent::run("127.0.0.1:7878");
+            Agent::run("0.0.0.0:7878");
             Ok(())
         }
     }
diff --git a/src/moray_client.rs b/src/moray_client.rs
new file mode 100644
index 0000000..33cecad
--- /dev/null
+++ b/src/moray_client.rs
@@ -0,0 +1,116 @@
+use crate::error::{Error, InternalError, InternalErrorCode};
+use libmanta::moray::MantaObject;
+use moray::{
+    client::MorayClient,
+    objects::{Etag, MethodOptions as ObjectMethodOptions},
+};
+use slog::{trace, warn, Logger};
+use std::collections::HashMap;
+use std::net::IpAddr;
+use trust_dns_resolver::Resolver;
+
+static MANTA_BUCKET: &str = "manta";
+
+// TODO: We should really create clients like these in libmanta
+pub struct MantaMorayClient {
+    clients: HashMap<u32, MorayClient>,
+    domain: String,
+    log: Logger,
+}
+
+impl MantaMorayClient {
+    pub fn new<S: Into<String>>(domain: S, log: Logger) -> Self {
+        Self {
+            clients: HashMap::new(),
+            domain: domain.into(),
+            log,
+        }
+    }
+
+    pub fn close(&mut self, shard: u32) {
+        let log = self.log.clone();
+        match self.clients.remove(&shard) {
+            Some(_) => (),
+            None => warn!(
+                log,
+                "Attempt to close MantaMorayClient that \
+                 doesn't exist: {}",
+                shard
+            ),
+        };
+    }
+
+    fn create_client(&mut self, shard: u32) -> Result<(), Error> {
+        let domain_name = format!("{}.moray.{}", shard, self.domain);
+
+        info!("Creating moray client for: {}", domain_name);
+
+        // TODO: Lookup SRV record for port number
+        let ip = lookup_ip(&domain_name)?;
+        let client = MorayClient::from_parts(ip, 2021, self.log.clone(), None)?;
+        self.clients.insert(shard, client);
+        Ok(())
+    }
+
+    // A bit of an odd dance.  We can't use or_insert_with() because that
+    // doesn't return a result and we need to make sure were were successful in
+    // creating the client before inserting it.
+    // We also can't have a single function both insert and return the same
+    // local value, because once we insert the hash owns the value.  So we have
+    // to call get_mut() to pull it back out of the hash.
+    pub fn get_or_create_client(
+        &mut self,
+        shard: u32,
+    ) -> Result<&mut MorayClient, Error> {
+        if !self.clients.contains_key(&shard) {
+            self.create_client(shard)?;
+        }
+
+        match self.clients.get_mut(&shard) {
+            Some(c) => Ok(c),
+            None => Err(InternalError::new(
+                Some(InternalErrorCode::HashNotFound),
+                "Could not retrieve client from client hash.",
+            )
+            .into()),
+        }
+    }
+
+    pub fn put_object(
+        &mut self,
+        shard: u32,
+        object: &MantaObject,
+        etag: &str,
+    ) -> Result<(), Error> {
+        let mut opts = ObjectMethodOptions::default();
+        let key = object.key.as_str();
+        let value = serde_json::to_value(object)?;
+        let log = self.log.clone();
+        let mclient = self.get_or_create_client(shard)?;
+
+        opts.etag = Etag::Specified(etag.to_string());
+
+        trace!(
+            log,
+            "Updating metadata. Key: {}\nValue: {:#?}\nopts: {:?}",
+            key,
+            value,
+            opts
+        );
+
+        mclient
+            .put_object(MANTA_BUCKET, key, value, &opts, |o| {
+                println!("{}", o);
+                Ok(())
+            })
+            .map_err(Error::from)
+    }
+}
+
+fn lookup_ip(host: &str) -> Result<IpAddr, Error> {
+    let resolver = Resolver::from_system_conf()?;
+    let response = resolver.lookup_ip(host)?;
+    let ip: Vec<IpAddr> = response.iter().collect();
+
+    Ok(ip[0])
+}
diff --git a/src/picker.rs b/src/picker.rs
index 4f66719..d678023 100644
--- a/src/picker.rs
+++ b/src/picker.rs
@@ -162,7 +162,7 @@ pub trait SharkSource: Sync + Send {
 // client in the future.
 fn fetch_sharks() -> Vec<StorageNode> {
     // TODO: should find picker in DNS
-    let mut ret = reqwest::get("http://10.77.77.24/poll").unwrap();
+    let mut ret = reqwest::get("http://10.77.77.43/poll").unwrap();
     let result = ret.json::<HashMap<String, Vec<StorageNode>>>().unwrap();
     let mut new_sharks = vec![];
 
diff --git a/src/util.rs b/src/util.rs
index 4316da2..349e7ec 100644
--- a/src/util.rs
+++ b/src/util.rs
@@ -8,9 +8,6 @@
  * Copyright 2019, Joyent, Inc.
  */
 
-use crc::crc32;
-use unescape::unescape;
-
 #[cfg(test)]
 use rand::{distributions::Alphanumeric, Rng};
 
@@ -19,18 +16,6 @@ pub fn shard_host2num(shard_host: &str) -> u32 {
     shard_split[0].parse().unwrap()
 }
 
-pub fn crc_hex_str(data: &str) -> Option<String> {
-    let str_obj = match unescape(data) {
-        Some(o) => o,
-        None => {
-            return None;
-        }
-    };
-    let crc_input = str_obj.trim_matches('"').as_bytes();
-    let etag = crc32::checksum_ieee(crc_input);
-    Some(format!("{:X}", etag))
-}
-
 // Used in test
 #[cfg(test)]
 pub fn random_string(len: usize) -> String {
-- 
2.21.0

