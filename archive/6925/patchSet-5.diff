commit 0ad48443eb3224f296b7c890dae3c3f2dcde4d01
Author: Rui Loura <rui@joyent.com>
Date:   2019-09-30T14:12:32-04:00 (7 days ago)
    
    MANTA-4550 create manta moray client module for managing per shard connections
    MANTA-4534 rebalancer should take option to specify location of config.json
    MANTA-4570 add MPL to rebalancer

diff --git a/Cargo.toml b/Cargo.toml
index 4fde386..1fe6c7a 100644
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -20,7 +20,7 @@ base64 = "0.10.1"
 uuid = { version = "0.7.4", features = ["v4"] }
 libmanta = { git = "https://github.com/joyent/rust-libmanta", tag = "v0.1.0" }
 clap = "2.33.0"
-sharkspotter = { git = "https://github.com/joyent/rust-sharkspotter", tag = "v0.2.0" }
+sharkspotter = { git = "https://github.com/joyent/rust-sharkspotter", tag = "v0.3.0" }
 crossbeam-channel = "0.3.8"
 crossbeam-deque = "0.7.1"
 serde = { version = "1.0.91", features = ["derive"] }
diff --git a/LICENSE b/LICENSE
new file mode 100644
index 0000000..a612ad9
--- /dev/null
+++ b/LICENSE
@@ -0,0 +1,373 @@
+Mozilla Public License Version 2.0
+==================================
+
+1. Definitions
+--------------
+
+1.1. "Contributor"
+    means each individual or legal entity that creates, contributes to
+    the creation of, or owns Covered Software.
+
+1.2. "Contributor Version"
+    means the combination of the Contributions of others (if any) used
+    by a Contributor and that particular Contributor's Contribution.
+
+1.3. "Contribution"
+    means Covered Software of a particular Contributor.
+
+1.4. "Covered Software"
+    means Source Code Form to which the initial Contributor has attached
+    the notice in Exhibit A, the Executable Form of such Source Code
+    Form, and Modifications of such Source Code Form, in each case
+    including portions thereof.
+
+1.5. "Incompatible With Secondary Licenses"
+    means
+
+    (a) that the initial Contributor has attached the notice described
+        in Exhibit B to the Covered Software; or
+
+    (b) that the Covered Software was made available under the terms of
+        version 1.1 or earlier of the License, but not also under the
+        terms of a Secondary License.
+
+1.6. "Executable Form"
+    means any form of the work other than Source Code Form.
+
+1.7. "Larger Work"
+    means a work that combines Covered Software with other material, in
+    a separate file or files, that is not Covered Software.
+
+1.8. "License"
+    means this document.
+
+1.9. "Licensable"
+    means having the right to grant, to the maximum extent possible,
+    whether at the time of the initial grant or subsequently, any and
+    all of the rights conveyed by this License.
+
+1.10. "Modifications"
+    means any of the following:
+
+    (a) any file in Source Code Form that results from an addition to,
+        deletion from, or modification of the contents of Covered
+        Software; or
+
+    (b) any new file in Source Code Form that contains any Covered
+        Software.
+
+1.11. "Patent Claims" of a Contributor
+    means any patent claim(s), including without limitation, method,
+    process, and apparatus claims, in any patent Licensable by such
+    Contributor that would be infringed, but for the grant of the
+    License, by the making, using, selling, offering for sale, having
+    made, import, or transfer of either its Contributions or its
+    Contributor Version.
+
+1.12. "Secondary License"
+    means either the GNU General Public License, Version 2.0, the GNU
+    Lesser General Public License, Version 2.1, the GNU Affero General
+    Public License, Version 3.0, or any later versions of those
+    licenses.
+
+1.13. "Source Code Form"
+    means the form of the work preferred for making modifications.
+
+1.14. "You" (or "Your")
+    means an individual or a legal entity exercising rights under this
+    License. For legal entities, "You" includes any entity that
+    controls, is controlled by, or is under common control with You. For
+    purposes of this definition, "control" means (a) the power, direct
+    or indirect, to cause the direction or management of such entity,
+    whether by contract or otherwise, or (b) ownership of more than
+    fifty percent (50%) of the outstanding shares or beneficial
+    ownership of such entity.
+
+2. License Grants and Conditions
+--------------------------------
+
+2.1. Grants
+
+Each Contributor hereby grants You a world-wide, royalty-free,
+non-exclusive license:
+
+(a) under intellectual property rights (other than patent or trademark)
+    Licensable by such Contributor to use, reproduce, make available,
+    modify, display, perform, distribute, and otherwise exploit its
+    Contributions, either on an unmodified basis, with Modifications, or
+    as part of a Larger Work; and
+
+(b) under Patent Claims of such Contributor to make, use, sell, offer
+    for sale, have made, import, and otherwise transfer either its
+    Contributions or its Contributor Version.
+
+2.2. Effective Date
+
+The licenses granted in Section 2.1 with respect to any Contribution
+become effective for each Contribution on the date the Contributor first
+distributes such Contribution.
+
+2.3. Limitations on Grant Scope
+
+The licenses granted in this Section 2 are the only rights granted under
+this License. No additional rights or licenses will be implied from the
+distribution or licensing of Covered Software under this License.
+Notwithstanding Section 2.1(b) above, no patent license is granted by a
+Contributor:
+
+(a) for any code that a Contributor has removed from Covered Software;
+    or
+
+(b) for infringements caused by: (i) Your and any other third party's
+    modifications of Covered Software, or (ii) the combination of its
+    Contributions with other software (except as part of its Contributor
+    Version); or
+
+(c) under Patent Claims infringed by Covered Software in the absence of
+    its Contributions.
+
+This License does not grant any rights in the trademarks, service marks,
+or logos of any Contributor (except as may be necessary to comply with
+the notice requirements in Section 3.4).
+
+2.4. Subsequent Licenses
+
+No Contributor makes additional grants as a result of Your choice to
+distribute the Covered Software under a subsequent version of this
+License (see Section 10.2) or under the terms of a Secondary License (if
+permitted under the terms of Section 3.3).
+
+2.5. Representation
+
+Each Contributor represents that the Contributor believes its
+Contributions are its original creation(s) or it has sufficient rights
+to grant the rights to its Contributions conveyed by this License.
+
+2.6. Fair Use
+
+This License is not intended to limit any rights You have under
+applicable copyright doctrines of fair use, fair dealing, or other
+equivalents.
+
+2.7. Conditions
+
+Sections 3.1, 3.2, 3.3, and 3.4 are conditions of the licenses granted
+in Section 2.1.
+
+3. Responsibilities
+-------------------
+
+3.1. Distribution of Source Form
+
+All distribution of Covered Software in Source Code Form, including any
+Modifications that You create or to which You contribute, must be under
+the terms of this License. You must inform recipients that the Source
+Code Form of the Covered Software is governed by the terms of this
+License, and how they can obtain a copy of this License. You may not
+attempt to alter or restrict the recipients' rights in the Source Code
+Form.
+
+3.2. Distribution of Executable Form
+
+If You distribute Covered Software in Executable Form then:
+
+(a) such Covered Software must also be made available in Source Code
+    Form, as described in Section 3.1, and You must inform recipients of
+    the Executable Form how they can obtain a copy of such Source Code
+    Form by reasonable means in a timely manner, at a charge no more
+    than the cost of distribution to the recipient; and
+
+(b) You may distribute such Executable Form under the terms of this
+    License, or sublicense it under different terms, provided that the
+    license for the Executable Form does not attempt to limit or alter
+    the recipients' rights in the Source Code Form under this License.
+
+3.3. Distribution of a Larger Work
+
+You may create and distribute a Larger Work under terms of Your choice,
+provided that You also comply with the requirements of this License for
+the Covered Software. If the Larger Work is a combination of Covered
+Software with a work governed by one or more Secondary Licenses, and the
+Covered Software is not Incompatible With Secondary Licenses, this
+License permits You to additionally distribute such Covered Software
+under the terms of such Secondary License(s), so that the recipient of
+the Larger Work may, at their option, further distribute the Covered
+Software under the terms of either this License or such Secondary
+License(s).
+
+3.4. Notices
+
+You may not remove or alter the substance of any license notices
+(including copyright notices, patent notices, disclaimers of warranty,
+or limitations of liability) contained within the Source Code Form of
+the Covered Software, except that You may alter any license notices to
+the extent required to remedy known factual inaccuracies.
+
+3.5. Application of Additional Terms
+
+You may choose to offer, and to charge a fee for, warranty, support,
+indemnity or liability obligations to one or more recipients of Covered
+Software. However, You may do so only on Your own behalf, and not on
+behalf of any Contributor. You must make it absolutely clear that any
+such warranty, support, indemnity, or liability obligation is offered by
+You alone, and You hereby agree to indemnify every Contributor for any
+liability incurred by such Contributor as a result of warranty, support,
+indemnity or liability terms You offer. You may include additional
+disclaimers of warranty and limitations of liability specific to any
+jurisdiction.
+
+4. Inability to Comply Due to Statute or Regulation
+---------------------------------------------------
+
+If it is impossible for You to comply with any of the terms of this
+License with respect to some or all of the Covered Software due to
+statute, judicial order, or regulation then You must: (a) comply with
+the terms of this License to the maximum extent possible; and (b)
+describe the limitations and the code they affect. Such description must
+be placed in a text file included with all distributions of the Covered
+Software under this License. Except to the extent prohibited by statute
+or regulation, such description must be sufficiently detailed for a
+recipient of ordinary skill to be able to understand it.
+
+5. Termination
+--------------
+
+5.1. The rights granted under this License will terminate automatically
+if You fail to comply with any of its terms. However, if You become
+compliant, then the rights granted under this License from a particular
+Contributor are reinstated (a) provisionally, unless and until such
+Contributor explicitly and finally terminates Your grants, and (b) on an
+ongoing basis, if such Contributor fails to notify You of the
+non-compliance by some reasonable means prior to 60 days after You have
+come back into compliance. Moreover, Your grants from a particular
+Contributor are reinstated on an ongoing basis if such Contributor
+notifies You of the non-compliance by some reasonable means, this is the
+first time You have received notice of non-compliance with this License
+from such Contributor, and You become compliant prior to 30 days after
+Your receipt of the notice.
+
+5.2. If You initiate litigation against any entity by asserting a patent
+infringement claim (excluding declaratory judgment actions,
+counter-claims, and cross-claims) alleging that a Contributor Version
+directly or indirectly infringes any patent, then the rights granted to
+You by any and all Contributors for the Covered Software under Section
+2.1 of this License shall terminate.
+
+5.3. In the event of termination under Sections 5.1 or 5.2 above, all
+end user license agreements (excluding distributors and resellers) which
+have been validly granted by You or Your distributors under this License
+prior to termination shall survive termination.
+
+************************************************************************
+*                                                                      *
+*  6. Disclaimer of Warranty                                           *
+*  -------------------------                                           *
+*                                                                      *
+*  Covered Software is provided under this License on an "as is"       *
+*  basis, without warranty of any kind, either expressed, implied, or  *
+*  statutory, including, without limitation, warranties that the       *
+*  Covered Software is free of defects, merchantable, fit for a        *
+*  particular purpose or non-infringing. The entire risk as to the     *
+*  quality and performance of the Covered Software is with You.        *
+*  Should any Covered Software prove defective in any respect, You     *
+*  (not any Contributor) assume the cost of any necessary servicing,   *
+*  repair, or correction. This disclaimer of warranty constitutes an   *
+*  essential part of this License. No use of any Covered Software is   *
+*  authorized under this License except under this disclaimer.         *
+*                                                                      *
+************************************************************************
+
+************************************************************************
+*                                                                      *
+*  7. Limitation of Liability                                          *
+*  --------------------------                                          *
+*                                                                      *
+*  Under no circumstances and under no legal theory, whether tort      *
+*  (including negligence), contract, or otherwise, shall any           *
+*  Contributor, or anyone who distributes Covered Software as          *
+*  permitted above, be liable to You for any direct, indirect,         *
+*  special, incidental, or consequential damages of any character      *
+*  including, without limitation, damages for lost profits, loss of    *
+*  goodwill, work stoppage, computer failure or malfunction, or any    *
+*  and all other commercial damages or losses, even if such party      *
+*  shall have been informed of the possibility of such damages. This   *
+*  limitation of liability shall not apply to liability for death or   *
+*  personal injury resulting from such party's negligence to the       *
+*  extent applicable law prohibits such limitation. Some               *
+*  jurisdictions do not allow the exclusion or limitation of           *
+*  incidental or consequential damages, so this exclusion and          *
+*  limitation may not apply to You.                                    *
+*                                                                      *
+************************************************************************
+
+8. Litigation
+-------------
+
+Any litigation relating to this License may be brought only in the
+courts of a jurisdiction where the defendant maintains its principal
+place of business and such litigation shall be governed by laws of that
+jurisdiction, without reference to its conflict-of-law provisions.
+Nothing in this Section shall prevent a party's ability to bring
+cross-claims or counter-claims.
+
+9. Miscellaneous
+----------------
+
+This License represents the complete agreement concerning the subject
+matter hereof. If any provision of this License is held to be
+unenforceable, such provision shall be reformed only to the extent
+necessary to make it enforceable. Any law or regulation which provides
+that the language of a contract shall be construed against the drafter
+shall not be used to construe this License against a Contributor.
+
+10. Versions of the License
+---------------------------
+
+10.1. New Versions
+
+Mozilla Foundation is the license steward. Except as provided in Section
+10.3, no one other than the license steward has the right to modify or
+publish new versions of this License. Each version will be given a
+distinguishing version number.
+
+10.2. Effect of New Versions
+
+You may distribute the Covered Software under the terms of the version
+of the License under which You originally received the Covered Software,
+or under the terms of any subsequent version published by the license
+steward.
+
+10.3. Modified Versions
+
+If you create software not governed by this License, and you want to
+create a new license for such software, you may create and use a
+modified version of this License if you rename the license and remove
+any references to the name of the license steward (except to note that
+such modified license differs from this License).
+
+10.4. Distributing Source Code Form that is Incompatible With Secondary
+Licenses
+
+If You choose to distribute Source Code Form that is Incompatible With
+Secondary Licenses under the terms of this version of the License, the
+notice described in Exhibit B of this License must be attached.
+
+Exhibit A - Source Code Form License Notice
+-------------------------------------------
+
+  This Source Code Form is subject to the terms of the Mozilla Public
+  License, v. 2.0. If a copy of the MPL was not distributed with this
+  file, You can obtain one at http://mozilla.org/MPL/2.0/.
+
+If it is not possible or desirable to put the notice in a particular
+file, then You may include the notice in a location (such as a LICENSE
+file in a relevant directory) where a recipient would be likely to look
+for such a notice.
+
+You may add additional accurate notices of copyright ownership.
+
+Exhibit B - "Incompatible With Secondary Licenses" Notice
+---------------------------------------------------------
+
+  This Source Code Form is "Incompatible With Secondary Licenses", as
+  defined by the Mozilla Public License, v. 2.0.
diff --git a/src/config.json b/src/config.json
index 4d8aaa7..f1e78f1 100644
--- a/src/config.json
+++ b/src/config.json
@@ -4,9 +4,6 @@
   "database_url": "rebalancer.sqlite",
   "database_buffer_size": 100,
   "shards": [
-      {
-        "host": "3.moray.staging.joyent.us"
-      },
       {
         "host": "2.moray.staging.joyent.us",
         "last": true
diff --git a/src/config.rs b/src/config.rs
index 283b8d0..56381f1 100644
--- a/src/config.rs
+++ b/src/config.rs
@@ -33,6 +33,7 @@ pub struct Config {
 }
 
 impl Config {
+    // TODO: there's a bug here that 1 will always be the min shard number
     pub fn min_shard_num(&self) -> u32 {
         self.shards.iter().fold(1, |res, elem| {
             let shard_num = util::shard_host2num(elem.host.as_str());
@@ -70,8 +71,8 @@ pub struct Command {
 }
 
 impl Command {
-    pub fn parse_config() -> Result<Config, Error> {
-        let file = File::open("./target/debug/config.json")?;
+    pub fn parse_config(config_path: &str) -> Result<Config, Error> {
+        let file = File::open(config_path)?;
         let reader = BufReader::new(file);
         let config: Config = serde_json::from_reader(reader)?;
 
@@ -79,9 +80,6 @@ impl Command {
     }
     pub fn new() -> Result<Command, Error> {
         let mut subcommand = SubCommand::Server;
-        let config = Command::parse_config()?;
-
-        let domain_name = String::from(config.domain_name.as_str());
 
         let matches: ArgMatches = App::new("remora")
             .version("0.1.0")
@@ -100,6 +98,15 @@ impl Command {
                     .long("agent")
                     .help("Run in agent mode"),
             )
+            .arg(
+                Arg::with_name("config_file")
+                    .short("c")
+                    .long("config_file")
+                    .takes_value(true)
+                    .value_name("CONFIG_FILE")
+                    .required(true)
+                    .help("Specify the location of the config file")
+            )
             .subcommand(
                 // TODO: server subcommand
                 ClapSubCommand::with_name("job")
@@ -154,8 +161,6 @@ impl Command {
                                             .value_name("DOMAIN_NAME")
                                             .help("Domain of Manta Deployment")
                                             .required(false)
-                                            .default_value(domain_name
-                                                .as_str())
                                     ),
 
                             ),
@@ -163,6 +168,11 @@ impl Command {
             )
             .get_matches();
 
+        let config_file = matches
+            .value_of("config_file")
+            .expect("Missing config file name");
+        let config = Command::parse_config(config_file)?;
+
         if matches.is_present("server") {
             subcommand = SubCommand::Server;
         }
@@ -191,7 +201,7 @@ impl Command {
 // TODO:
 // This should really be removed in favor of the following:
 // 1. Command::new() handling override of domain_name from config file
-// 2. Job::new() taking all args necssary to create new Job Action (e.g.
+// 2. Job::new() taking all args necessary to create new Job Action (e.g.
 // EvacuateJob)
 fn job_subcommand_handler(matches: &ArgMatches, config: Config) -> SubCommand {
     let shark_id = matches.value_of("from_shark").unwrap_or("").to_string();
@@ -202,8 +212,11 @@ fn job_subcommand_handler(matches: &ArgMatches, config: Config) -> SubCommand {
     // we plan to have a server mode that will generate multiple jobs in a
     // single process.
     let db_url = format!("{}.{}", &config.database_url, process::id());
-    let job_action =
-        JobAction::Evacuate(Box::new(EvacuateJob::new(from_shark, &db_url)));
+    let job_action = JobAction::Evacuate(Box::new(EvacuateJob::new(
+        from_shark,
+        domain_name,
+        &db_url,
+    )));
     let job = Job::new(job_action, config);
 
     SubCommand::DoJob(Box::new(job))
diff --git a/src/error.rs b/src/error.rs
index a15adb7..540a940 100644
--- a/src/error.rs
+++ b/src/error.rs
@@ -9,6 +9,7 @@
  */
 
 use std::fmt;
+use trust_dns_resolver::error::ResolveErrorKind;
 
 #[derive(Debug)]
 pub enum Error {
@@ -18,6 +19,7 @@ pub enum Error {
     Diesel(diesel::result::Error),
     SerdeJson(serde_json::error::Error),
     Reqwest(reqwest::Error),
+    Resolve(trust_dns_resolver::error::ResolveError),
 }
 
 impl std::error::Error for Error {
@@ -29,6 +31,19 @@ impl std::error::Error for Error {
             Error::Diesel(e) => e.description(),
             Error::SerdeJson(e) => e.description(),
             Error::Reqwest(e) => e.description(),
+            Error::Resolve(e) => {
+                let kind = e.kind();
+                match kind {
+                    ResolveErrorKind::Message(m) => m,
+                    ResolveErrorKind::Io => "IO Error",
+                    ResolveErrorKind::Msg(m) => m.as_str(),
+                    ResolveErrorKind::NoRecordsFound { .. } => {
+                        "No Records Found"
+                    }
+                    ResolveErrorKind::Proto => "Proto Error",
+                    ResolveErrorKind::Timeout => "Request Timed Out",
+                }
+            }
         }
     }
 }
@@ -69,6 +84,12 @@ impl From<reqwest::Error> for Error {
     }
 }
 
+impl From<trust_dns_resolver::error::ResolveError> for Error {
+    fn from(error: trust_dns_resolver::error::ResolveError) -> Self {
+        Error::Resolve(error)
+    }
+}
+
 impl fmt::Display for Error {
     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
         match self {
@@ -78,6 +99,7 @@ impl fmt::Display for Error {
             Error::Diesel(e) => write!(f, "{}", e),
             Error::SerdeJson(e) => write!(f, "{}", e),
             Error::Reqwest(e) => write!(f, "{}", e),
+            Error::Resolve(e) => write!(f, "{}", e),
         }
     }
 }
@@ -97,6 +119,7 @@ pub enum InternalErrorCode {
     AssignmentLookupError,
     AssignmentGetError,
     LockError,
+    HashNotFound,
 }
 
 impl fmt::Display for InternalError {
diff --git a/src/jobs/evacuate.rs b/src/jobs/evacuate.rs
index c168e48..a39fe87 100644
--- a/src/jobs/evacuate.rs
+++ b/src/jobs/evacuate.rs
@@ -15,9 +15,10 @@ use crate::jobs::{
     Assignment, AssignmentId, AssignmentPayload, AssignmentState, ObjectId,
     StorageId, Task, TaskStatus,
 };
+use crate::moray_client;
 use crate::picker::{self as mod_picker, SharkSource, StorageNode};
-use crate::util;
 
+use std::collections::hash_map::Entry::{Occupied, Vacant};
 use std::collections::HashMap;
 use std::error::Error as _Error;
 use std::io::ErrorKind;
@@ -29,7 +30,7 @@ use crossbeam_channel as crossbeam;
 use crossbeam_channel::TryRecvError;
 use crossbeam_deque::{Injector, Steal};
 use libmanta::moray::{MantaObject, MantaObjectShark};
-use moray::objects::{Etag, MethodOptions};
+use moray::client::MorayClient;
 use reqwest;
 use slog::{o, Drain, Logger};
 use std::borrow::Borrow;
@@ -48,6 +49,7 @@ table! {
         assignment_id -> Text,
         object -> Text,
         shard -> Integer,
+        etag -> Text,
         status -> EvacuateObjectStatusMapping,
     }
 }
@@ -65,6 +67,7 @@ pub struct EvacuateObjectDB {
     pub assignment_id: AssignmentId,
     pub object: String,
     pub shard: i32,
+    pub etag: String,
     pub status: EvacuateObjectStatus,
 }
 
@@ -76,6 +79,7 @@ struct FiniMsg;
 pub struct SharkSpotterObject {
     pub shard: i32,
     pub object: MantaObject,
+    pub etag: String,
 }
 
 #[derive(Debug, Clone, PartialEq, DbEnum)]
@@ -105,6 +109,7 @@ pub struct EvacuateObject {
     pub id: ObjectId,        // MantaObject ObjectId
     pub object: MantaObject, // The MantaObject being rebalanced
     pub shard: i32,          // shard number of metadata object record
+    pub etag: String,
     pub status: EvacuateObjectStatus,
     // Status of the object in the evacuation job
 }
@@ -116,6 +121,7 @@ impl EvacuateObject {
             id: ssobj.object.object_id.to_owned(),
             object: ssobj.object,
             shard: ssobj.shard,
+            etag: ssobj.etag,
             ..Default::default()
         }
     }
@@ -129,6 +135,7 @@ impl EvacuateObject {
             id: self.id.clone(),
             object: serde_json::to_string(&self.object)?,
             shard: self.shard,
+            etag: self.etag.clone(),
             status: self.status.clone(),
         })
     }
@@ -167,6 +174,12 @@ pub struct EvacuateJob {
     /// SqliteConnection to local database.
     pub conn: Mutex<SqliteConnection>,
 
+    /// domain_name of manta deployment
+    pub domain_name: String,
+
+    /// Logger
+    pub log: Logger,
+
     /// Accumulator for total time spent on DB inserts. (test/dev)
     pub total_db_time: Mutex<u128>,
 }
@@ -174,13 +187,22 @@ pub struct EvacuateJob {
 impl EvacuateJob {
     /// Create a new EvacauteJob instance.
     /// As part of this initialization also create a new SqliteConnection.
-    pub fn new<S: Into<String>>(from_shark: S, db_url: &str) -> Self {
+    pub fn new<S: Into<String>>(
+        from_shark: S,
+        domain_name: &str,
+        db_url: &str,
+    ) -> Self {
         let manta_storage_id = from_shark.into();
+        let plain = slog_term::PlainSyncDecorator::new(std::io::stdout());
+        let log = Logger::root(
+            Mutex::new(slog_term::FullFormat::new(plain).build()).fuse(),
+            o!("build-id" => "0.1.0"),
+        );
         let conn = SqliteConnection::establish(db_url)
             .unwrap_or_else(|_| panic!("Error connecting to {}", db_url));
         Self {
             min_avail_mb: Some(1000),
-            max_tasks_per_assignment: Some(100),
+            max_tasks_per_assignment: Some(1000),
             dest_shark_list: RwLock::new(HashMap::new()),
             assignments: RwLock::new(HashMap::new()),
             from_shark: MantaObjectShark {
@@ -189,6 +211,8 @@ impl EvacuateJob {
             },
             conn: Mutex::new(conn),
             total_db_time: Mutex::new(0),
+            domain_name: domain_name.to_string(),
+            log,
         }
     }
 
@@ -211,6 +235,7 @@ impl EvacuateJob {
                     assignment_id TEXT,
                     object TEXT,
                     shard Integer,
+                    etag TEXT,
                     status TEXT CHECK(status IN ('unprocessed', 'assigned',
                     'skipped', 'post_processing', 'complete')) NOT NULL
                 );
@@ -429,11 +454,54 @@ impl EvacuateJob {
         Ok(ret)
     }
 
+    // One other alternative is to try
+    /*
+    diesel::insert_into(users)
+    .values(&user2)
+    .on_conflict(id)
+    .do_update()
+    .set(name.eq("I DONT KNOW ANYMORE"))
+    .execute(&conn);
+    */
+    // Quick tests show that the below implementation scales very well:
+    // 100 objects: 12ms or (1/10 time/obj)
+    // 500 objects: 25ms (1/20 time/obj)
+    // 1000 objects: 52.5ms (1/19 time/obj)
+    fn mark_many_objects(
+        &self,
+        vec_obj_ids: Vec<String>,
+        to_status: EvacuateObjectStatus,
+    ) -> usize {
+        use self::evacuateobjects::dsl::*;
+
+        let locked_conn = self.conn.lock().expect("db conn lock");
+        let len = vec_obj_ids.len();
+
+        debug!("Marking {} objects as {:?}", len, to_status);
+        let now = std::time::Instant::now();
+        let ret = diesel::update(evacuateobjects)
+            .filter(id.eq_any(vec_obj_ids))
+            .set(status.eq(to_status))
+            .execute(&*locked_conn)
+            .unwrap_or_else(|e| {
+                let msg = format!("LocalDB: Error updating {}", e);
+                error!("{}", msg);
+                panic!(msg);
+            });
+        debug!(
+            "eq_any update of {} took {}ms",
+            len,
+            now.elapsed().as_millis()
+        );
+
+        ret
+    }
+
     /// Mark all objects with a given assignment ID with the specified
     /// EvacuateObjectStatus
     fn mark_assignment_objects(
         &self,
-        id: &AssignmentId,
+        id: &str,
         to_status: EvacuateObjectStatus,
     ) -> usize {
         use self::evacuateobjects::dsl::{
@@ -476,7 +544,7 @@ impl EvacuateJob {
 
     fn get_assignment_objects(
         &self,
-        id: &AssignmentId,
+        id: &str,
         status_filter: EvacuateObjectStatus,
     ) -> Vec<EvacuateObjectDB> {
         use self::evacuateobjects::dsl::{
@@ -609,19 +677,11 @@ impl UpdateMetadata for EvacuateJob {
         &self,
         mut object: MantaObject,
         new_shark: &StorageNode,
+        etag: String,
+        mclient: &mut MorayClient,
     ) -> Result<MantaObject, Error> {
         let old_shark = &self.from_shark;
-        let obj = serde_json::to_string(&object)?;
-        let etag = match util::crc_hex_str(&obj) {
-            Some(o) => o,
-            None => {
-                return Err(InternalError::new(
-                    None,
-                    "Error getting etag from Manta Object",
-                )
-                .into())
-            }
-        };
+        let log = self.log.clone();
 
         // Replace shark value
         let mut shark_found = false;
@@ -637,31 +697,8 @@ impl UpdateMetadata for EvacuateJob {
             }
         }
 
-        // Prepare metadata message.
-        let key = object.key.as_str();
-        let value =
-            serde_json::to_value(&object).expect("Serialize Manta Object");
-        let mut opts = MethodOptions::default();
-
-        opts.etag = Etag::Specified(etag);
+        moray_client::put_object(mclient, &object, &etag, log)?;
 
-        trace!(
-            "Updating metadata. Key: {}\nValue: {}\nopts: {:?}",
-            key,
-            value,
-            opts
-        );
-
-        // TODO: The EvacuateJob struct should implement a moray client hash
-        // and we can call a "get_moray_client()" method here that will
-        // get an existing client, or create a new client if need be.
-        /*
-        mclient.put_object("manta", key, value, &opts, |o| {
-                debug!("Updated object metadata: {}", &o);
-                Ok(())
-            },
-        ).expect("put_object");
-        */
         Ok(object)
     }
 }
@@ -793,19 +830,29 @@ fn start_sharkspotter(
         .name(String::from("sharkspotter"))
         .spawn(move || {
             let mut count = 0;
-            sharkspotter::run(config, log, move |object, shard| {
+            sharkspotter::run(config, log, move |object, shard, etag| {
+                trace!("Sharkspotter discovered object: {:#?}", &object);
                 // while testing, limit the number of objects processed for now
                 count += 1;
-                if count > 2000 {
+                if count > 2 {
                     return Err(std::io::Error::new(
                         ErrorKind::Other,
                         "Just stop already",
                     ));
                 }
 
+                if shard > std::i32::MAX as u32 {
+                    error!("Found shard number over int32 max");
+                    return Err(std::io::Error::new(
+                        ErrorKind::Other,
+                        "Exceeded max number of shards",
+                    ));
+                }
+
                 let ssobj = SharkSpotterObject {
                     shard: shard as i32,
                     object,
+                    etag,
                 };
                 obj_tx
                     .send(ssobj)
@@ -986,9 +1033,11 @@ fn start_assignment_generator(
                 let mut eobj_vec: Vec<EvacuateObject> = vec![];
 
                 debug!(
-                    "Filling up new assignment with max_tasks: {:#?}, \
+                    "Filling up new assignment for {} with max_tasks: {:#?}, \
                      and available_space: {}",
-                    &max_tasks, &available_space
+                    &assignment.dest_shark.manta_storage_id,
+                    &max_tasks,
+                    &available_space
                 );
 
                 // Start Task Loop
@@ -1022,14 +1071,10 @@ fn start_assignment_generator(
                     }
 
                     let obj = &eobj.object;
-                    let obj_on_dest = obj
-                        .sharks
-                        .iter()
-                        .find(|s| {
-                            s.manta_storage_id
-                                == assignment.dest_shark.manta_storage_id
-                        })
-                        .is_some();
+                    let obj_on_dest = obj.sharks.iter().any(|s| {
+                        s.manta_storage_id
+                            == assignment.dest_shark.manta_storage_id
+                    });
 
                     // We've found the object on the destination shark.  We will
                     // need to skip this object for now and find a destination
@@ -1188,6 +1233,8 @@ trait UpdateMetadata: Sync + Send {
         &self,
         object: MantaObject,
         new_shark: &StorageNode,
+        etag: String,
+        mclient: &mut MorayClient,
     ) -> Result<MantaObject, Error>;
 }
 
@@ -1282,6 +1329,7 @@ fn start_assignment_checker(
                     .clone();
 
                 debug!("Checking Assignments");
+
                 if !run
                     && assignments
                         .values()
@@ -1370,11 +1418,22 @@ fn start_assignment_checker(
         .map_err(Error::from)
 }
 
+// This worker continues to run as long as the queue has entries for it to
+// work on.  If, when the worker attempts to "steal" from the queue, the
+// queue is emtpy the worker exits.
 fn metadata_update_worker(
     job_action: Arc<EvacuateJob>,
     queue_front: Arc<Injector<Assignment>>,
 ) -> impl Fn() {
     move || {
+        // For each worker we create a hash of moray clients indexed by shard.
+        // If the worker exits then the clients and the associated
+        // connections are dropped.  This avoids having to place locks around
+        // the shard connections.  It also allows us to manage our max
+        // number of per-shard connections by simply tuning the number of
+        // metadata update worker threads.
+        let mut client_hash: HashMap<u32, MorayClient> = HashMap::new();
+
         loop {
             let assignment = match queue_front.steal() {
                 Steal::Success(a) => a,
@@ -1382,15 +1441,15 @@ fn metadata_update_worker(
                 Steal::Empty => break,
             };
 
+            let mut updated_objects = vec![];
             let dest_shark = &assignment.dest_shark;
-
             let objects = job_action.get_assignment_objects(
                 &assignment.id,
                 EvacuateObjectStatus::PostProcessing,
             );
 
-            let mut updated_objects = vec![];
             for obj in objects {
+                let etag = obj.etag;
                 let mut mobj: MantaObject =
                     match serde_json::from_str(&obj.object) {
                         Ok(o) => o,
@@ -1404,16 +1463,57 @@ fn metadata_update_worker(
                         }
                     };
 
+                // Unfortunately sqlite only accepts signed integers.  So we
+                // have to do the conversion here and cross our fingers that
+                // we don't have more than 2.1 billion shards.
+                // We do check this value coming in from sharkspotter as well.
+                if obj.shard < 0 {
+                    // TODO: persistent error (panic for now)
+                    panic!("Cannot have a negative shard");
+                }
+                let shard = obj.shard as u32;
+
+                // We can't use or_insert_with() here because in the event
+                // that client creation fails we want to handle that error.
+                let mclient = match client_hash.entry(shard) {
+                    Occupied(entry) => entry.into_mut(),
+                    Vacant(entry) => {
+                        let client = match moray_client::create_client(
+                            shard,
+                            &job_action.domain_name,
+                            &job_action.log,
+                        ) {
+                            Ok(client) => client,
+                            Err(e) => {
+                                // TODO: persistent error for EvacuateObject
+                                // in local DB
+                                error!(
+                                    "MD Update Worker: failed to get moray \
+                                     client for shard number {}. Cannot update \
+                                     metadata for {:#?}\n{}",
+                                    shard, mobj, e
+                                );
+
+                                continue;
+                            }
+                        };
+                        entry.insert(client)
+                    }
+                };
+
                 // This function updates the manta object with the new
                 // sharks in the Manta Metadata tier, and then returns the
                 // updated Manta metadata object.  It does not update the
                 // state of the associated EvacuateObject in the local database.
-                mobj = match job_action.update_object_shark(mobj, dest_shark) {
+                mobj = match job_action
+                    .update_object_shark(mobj, dest_shark, etag, mclient)
+                {
                     Ok(o) => o,
                     Err(e) => {
                         // TODO: log a persistent error for final job report.
                         error!(
-                            "Error updating {}, with dest_shark {:?}: {}",
+                            "MD Update worker: Error updating \n\n{:#?}, with \
+                             dest_shark {:?}\n\n{}",
                             &obj.object, dest_shark, e
                         );
                         continue;
@@ -1446,10 +1546,17 @@ fn metadata_update_worker(
                 }
             }
 
+            // https://stackoverflow
+            // .com/questions/47626047/execute-an-insert-or-update-using-diesel
             // TODO: batch update all objects in `updated_objects` with
             // EvacuateObjectStatus::Complete in the local DB meaning we are
             // completely done and this object has been rebalanced.
             // This is the finish line.
+
+            job_action.mark_many_objects(
+                updated_objects,
+                EvacuateObjectStatus::Complete,
+            );
         }
     }
 }
@@ -1596,6 +1703,7 @@ mod tests {
 
         let job_action = EvacuateJob::new(
             String::from("1.stor.joyent.us"),
+            "joyent.us",
             "empty_picker_test.db",
         );
         let job_action = Arc::new(job_action);
@@ -1656,8 +1764,11 @@ mod tests {
         let (md_update_tx, md_update_rx) = crossbeam::bounded(5);
         let (checker_fini_tx, checker_fini_rx) = crossbeam::bounded(1);
 
-        let job_action =
-            EvacuateJob::new(String::from("1.stor.joyent.us"), "full_test.db");
+        let job_action = EvacuateJob::new(
+            String::from("1.stor.joyent.us"),
+            "east.joyent.us",
+            "full_test.db",
+        );
         let conn = job_action.conn.lock().expect("db connection lock");
         conn.execute(r#"DROP TABLE evacuateobjects"#)
             .unwrap_or_else(|e| {
@@ -1671,6 +1782,7 @@ mod tests {
                 assignment_id TEXT,
                 object TEXT,
                 shard Integer,
+                etag TEXT,
                 status TEXT CHECK(status IN ('unprocessed', 'assigned',
                 'skipped', 'post_processing', 'complete')) NOT NULL
             );"#,
@@ -1684,7 +1796,7 @@ mod tests {
         let mut test_objects = vec![];
 
         let mut g = StdThreadGen::new(10);
-        for _ in 0..1000 {
+        for _ in 0..2 {
             let mobj = MantaObject::arbitrary(&mut g);
             test_objects.push(mobj);
         }
@@ -1699,6 +1811,8 @@ mod tests {
                     let ssobj = SharkSpotterObject {
                         shard: 1,
                         object: o.clone(),
+                        // TODO
+                        etag: String::from("Fake_etag"),
                     };
                     match obj_tx.send(ssobj) {
                         Ok(()) => (),
diff --git a/src/lib.rs b/src/lib.rs
index aba43e0..8e52314 100644
--- a/src/lib.rs
+++ b/src/lib.rs
@@ -24,5 +24,6 @@ pub mod jobs;
 pub mod agent;
 pub mod config;
 pub mod error;
+pub(crate) mod moray_client;
 pub mod picker;
 pub mod util;
diff --git a/src/main.rs b/src/main.rs
index 486507e..44a0e03 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -23,7 +23,7 @@ fn main() -> Result<(), Error> {
         SubCommand::Server => Ok(()),
         SubCommand::DoJob(job) => job.run(),
         SubCommand::Agent => {
-            Agent::run("127.0.0.1:7878");
+            Agent::run("0.0.0.0:7878");
             Ok(())
         }
     }
diff --git a/src/moray_client.rs b/src/moray_client.rs
new file mode 100644
index 0000000..8c95afc
--- /dev/null
+++ b/src/moray_client.rs
@@ -0,0 +1,63 @@
+use crate::error::Error;
+use libmanta::moray::MantaObject;
+use moray::{
+    client::MorayClient,
+    objects::{Etag, MethodOptions as ObjectMethodOptions},
+};
+use slog::{trace, Logger};
+use std::net::IpAddr;
+use trust_dns_resolver::Resolver;
+
+static MANTA_BUCKET: &str = "manta";
+
+fn lookup_ip(host: &str) -> Result<IpAddr, Error> {
+    let resolver = Resolver::from_system_conf()?;
+    let response = resolver.lookup_ip(host)?;
+    let ip: Vec<IpAddr> = response.iter().collect();
+
+    Ok(ip[0])
+}
+
+pub fn create_client(
+    shard: u32,
+    domain: &str,
+    log: &Logger,
+) -> Result<MorayClient, Error> {
+    let domain_name = format!("{}.moray.{}", shard, domain);
+
+    info!("Creating moray client for: {}", domain_name);
+
+    // TODO: Lookup SRV record for port number
+    // Waiting on trust-dns-resolver issue:
+    // https://github.com/bluejekyll/trust-dns/issues/872
+    let ip = lookup_ip(&domain_name)?;
+    MorayClient::from_parts(ip, 2021, log.clone(), None).map_err(Error::from)
+}
+
+pub fn put_object(
+    mclient: &mut MorayClient,
+    object: &MantaObject,
+    etag: &str,
+    log: Logger,
+) -> Result<(), Error> {
+    let mut opts = ObjectMethodOptions::default();
+    let key = object.key.as_str();
+    let value = serde_json::to_value(object)?;
+
+    opts.etag = Etag::Specified(etag.to_string());
+
+    trace!(
+        log,
+        "Updating metadata. Key: {}\nValue: {:#?}\nopts: {:?}",
+        key,
+        value,
+        opts
+    );
+
+    mclient
+        .put_object(MANTA_BUCKET, key, value, &opts, |o| {
+            trace!(log, "Object Updated: {}", o);
+            Ok(())
+        })
+        .map_err(Error::from)
+}
diff --git a/src/picker.rs b/src/picker.rs
index 4f66719..d678023 100644
--- a/src/picker.rs
+++ b/src/picker.rs
@@ -162,7 +162,7 @@ pub trait SharkSource: Sync + Send {
 // client in the future.
 fn fetch_sharks() -> Vec<StorageNode> {
     // TODO: should find picker in DNS
-    let mut ret = reqwest::get("http://10.77.77.24/poll").unwrap();
+    let mut ret = reqwest::get("http://10.77.77.43/poll").unwrap();
     let result = ret.json::<HashMap<String, Vec<StorageNode>>>().unwrap();
     let mut new_sharks = vec![];
 
diff --git a/src/util.rs b/src/util.rs
index 4316da2..349e7ec 100644
--- a/src/util.rs
+++ b/src/util.rs
@@ -8,9 +8,6 @@
  * Copyright 2019, Joyent, Inc.
  */
 
-use crc::crc32;
-use unescape::unescape;
-
 #[cfg(test)]
 use rand::{distributions::Alphanumeric, Rng};
 
@@ -19,18 +16,6 @@ pub fn shard_host2num(shard_host: &str) -> u32 {
     shard_split[0].parse().unwrap()
 }
 
-pub fn crc_hex_str(data: &str) -> Option<String> {
-    let str_obj = match unescape(data) {
-        Some(o) => o,
-        None => {
-            return None;
-        }
-    };
-    let crc_input = str_obj.trim_matches('"').as_bytes();
-    let etag = crc32::checksum_ieee(crc_input);
-    Some(format!("{:X}", etag))
-}
-
 // Used in test
 #[cfg(test)]
 pub fn random_string(len: usize) -> String {
