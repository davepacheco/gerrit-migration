From b2f6520ee8398451e10b22cc527e1183a0c55761 Mon Sep 17 00:00:00 2001
From: Rui Loura <rui@joyent.com>
Date: Fri, 13 Sep 2019 16:14:22 -0400
Subject: [PATCH] MANTA-4550 create manta moray client module for managing per
 shard connections MANTA-4534 rebalancer should take option to specify
 location of config.json

---
 Cargo.toml           |   2 +-
 src/config.json      |   3 -
 src/config.rs        |  33 ++++--
 src/error.rs         |  23 +++++
 src/jobs/evacuate.rs | 234 ++++++++++++++++++++++++++++++++-----------
 src/lib.rs           |   1 +
 src/main.rs          |   2 +-
 src/moray_client.rs  |  61 +++++++++++
 src/picker.rs        |   2 +-
 src/util.rs          |  15 ---
 10 files changed, 285 insertions(+), 91 deletions(-)
 create mode 100644 src/moray_client.rs

diff --git a/Cargo.toml b/Cargo.toml
index 4fde386..1fe6c7a 100644
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -20,7 +20,7 @@ base64 = "0.10.1"
 uuid = { version = "0.7.4", features = ["v4"] }
 libmanta = { git = "https://github.com/joyent/rust-libmanta", tag = "v0.1.0" }
 clap = "2.33.0"
-sharkspotter = { git = "https://github.com/joyent/rust-sharkspotter", tag = "v0.2.0" }
+sharkspotter = { git = "https://github.com/joyent/rust-sharkspotter", tag = "v0.3.0" }
 crossbeam-channel = "0.3.8"
 crossbeam-deque = "0.7.1"
 serde = { version = "1.0.91", features = ["derive"] }
diff --git a/src/config.json b/src/config.json
index 4d8aaa7..f1e78f1 100644
--- a/src/config.json
+++ b/src/config.json
@@ -4,9 +4,6 @@
   "database_url": "rebalancer.sqlite",
   "database_buffer_size": 100,
   "shards": [
-      {
-        "host": "3.moray.staging.joyent.us"
-      },
       {
         "host": "2.moray.staging.joyent.us",
         "last": true
diff --git a/src/config.rs b/src/config.rs
index 283b8d0..56381f1 100644
--- a/src/config.rs
+++ b/src/config.rs
@@ -33,6 +33,7 @@ pub struct Config {
 }
 
 impl Config {
+    // TODO: there's a bug here that 1 will always be the min shard number
     pub fn min_shard_num(&self) -> u32 {
         self.shards.iter().fold(1, |res, elem| {
             let shard_num = util::shard_host2num(elem.host.as_str());
@@ -70,8 +71,8 @@ pub struct Command {
 }
 
 impl Command {
-    pub fn parse_config() -> Result<Config, Error> {
-        let file = File::open("./target/debug/config.json")?;
+    pub fn parse_config(config_path: &str) -> Result<Config, Error> {
+        let file = File::open(config_path)?;
         let reader = BufReader::new(file);
         let config: Config = serde_json::from_reader(reader)?;
 
@@ -79,9 +80,6 @@ impl Command {
     }
     pub fn new() -> Result<Command, Error> {
         let mut subcommand = SubCommand::Server;
-        let config = Command::parse_config()?;
-
-        let domain_name = String::from(config.domain_name.as_str());
 
         let matches: ArgMatches = App::new("remora")
             .version("0.1.0")
@@ -100,6 +98,15 @@ impl Command {
                     .long("agent")
                     .help("Run in agent mode"),
             )
+            .arg(
+                Arg::with_name("config_file")
+                    .short("c")
+                    .long("config_file")
+                    .takes_value(true)
+                    .value_name("CONFIG_FILE")
+                    .required(true)
+                    .help("Specify the location of the config file")
+            )
             .subcommand(
                 // TODO: server subcommand
                 ClapSubCommand::with_name("job")
@@ -154,8 +161,6 @@ impl Command {
                                             .value_name("DOMAIN_NAME")
                                             .help("Domain of Manta Deployment")
                                             .required(false)
-                                            .default_value(domain_name
-                                                .as_str())
                                     ),
 
                             ),
@@ -163,6 +168,11 @@ impl Command {
             )
             .get_matches();
 
+        let config_file = matches
+            .value_of("config_file")
+            .expect("Missing config file name");
+        let config = Command::parse_config(config_file)?;
+
         if matches.is_present("server") {
             subcommand = SubCommand::Server;
         }
@@ -191,7 +201,7 @@ impl Command {
 // TODO:
 // This should really be removed in favor of the following:
 // 1. Command::new() handling override of domain_name from config file
-// 2. Job::new() taking all args necssary to create new Job Action (e.g.
+// 2. Job::new() taking all args necessary to create new Job Action (e.g.
 // EvacuateJob)
 fn job_subcommand_handler(matches: &ArgMatches, config: Config) -> SubCommand {
     let shark_id = matches.value_of("from_shark").unwrap_or("").to_string();
@@ -202,8 +212,11 @@ fn job_subcommand_handler(matches: &ArgMatches, config: Config) -> SubCommand {
     // we plan to have a server mode that will generate multiple jobs in a
     // single process.
     let db_url = format!("{}.{}", &config.database_url, process::id());
-    let job_action =
-        JobAction::Evacuate(Box::new(EvacuateJob::new(from_shark, &db_url)));
+    let job_action = JobAction::Evacuate(Box::new(EvacuateJob::new(
+        from_shark,
+        domain_name,
+        &db_url,
+    )));
     let job = Job::new(job_action, config);
 
     SubCommand::DoJob(Box::new(job))
diff --git a/src/error.rs b/src/error.rs
index a15adb7..540a940 100644
--- a/src/error.rs
+++ b/src/error.rs
@@ -9,6 +9,7 @@
  */
 
 use std::fmt;
+use trust_dns_resolver::error::ResolveErrorKind;
 
 #[derive(Debug)]
 pub enum Error {
@@ -18,6 +19,7 @@ pub enum Error {
     Diesel(diesel::result::Error),
     SerdeJson(serde_json::error::Error),
     Reqwest(reqwest::Error),
+    Resolve(trust_dns_resolver::error::ResolveError),
 }
 
 impl std::error::Error for Error {
@@ -29,6 +31,19 @@ impl std::error::Error for Error {
             Error::Diesel(e) => e.description(),
             Error::SerdeJson(e) => e.description(),
             Error::Reqwest(e) => e.description(),
+            Error::Resolve(e) => {
+                let kind = e.kind();
+                match kind {
+                    ResolveErrorKind::Message(m) => m,
+                    ResolveErrorKind::Io => "IO Error",
+                    ResolveErrorKind::Msg(m) => m.as_str(),
+                    ResolveErrorKind::NoRecordsFound { .. } => {
+                        "No Records Found"
+                    }
+                    ResolveErrorKind::Proto => "Proto Error",
+                    ResolveErrorKind::Timeout => "Request Timed Out",
+                }
+            }
         }
     }
 }
@@ -69,6 +84,12 @@ impl From<reqwest::Error> for Error {
     }
 }
 
+impl From<trust_dns_resolver::error::ResolveError> for Error {
+    fn from(error: trust_dns_resolver::error::ResolveError) -> Self {
+        Error::Resolve(error)
+    }
+}
+
 impl fmt::Display for Error {
     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
         match self {
@@ -78,6 +99,7 @@ impl fmt::Display for Error {
             Error::Diesel(e) => write!(f, "{}", e),
             Error::SerdeJson(e) => write!(f, "{}", e),
             Error::Reqwest(e) => write!(f, "{}", e),
+            Error::Resolve(e) => write!(f, "{}", e),
         }
     }
 }
@@ -97,6 +119,7 @@ pub enum InternalErrorCode {
     AssignmentLookupError,
     AssignmentGetError,
     LockError,
+    HashNotFound,
 }
 
 impl fmt::Display for InternalError {
diff --git a/src/jobs/evacuate.rs b/src/jobs/evacuate.rs
index c168e48..a39fe87 100644
--- a/src/jobs/evacuate.rs
+++ b/src/jobs/evacuate.rs
@@ -15,9 +15,10 @@ use crate::jobs::{
     Assignment, AssignmentId, AssignmentPayload, AssignmentState, ObjectId,
     StorageId, Task, TaskStatus,
 };
+use crate::moray_client;
 use crate::picker::{self as mod_picker, SharkSource, StorageNode};
-use crate::util;
 
+use std::collections::hash_map::Entry::{Occupied, Vacant};
 use std::collections::HashMap;
 use std::error::Error as _Error;
 use std::io::ErrorKind;
@@ -29,7 +30,7 @@ use crossbeam_channel as crossbeam;
 use crossbeam_channel::TryRecvError;
 use crossbeam_deque::{Injector, Steal};
 use libmanta::moray::{MantaObject, MantaObjectShark};
-use moray::objects::{Etag, MethodOptions};
+use moray::client::MorayClient;
 use reqwest;
 use slog::{o, Drain, Logger};
 use std::borrow::Borrow;
@@ -48,6 +49,7 @@ table! {
         assignment_id -> Text,
         object -> Text,
         shard -> Integer,
+        etag -> Text,
         status -> EvacuateObjectStatusMapping,
     }
 }
@@ -65,6 +67,7 @@ pub struct EvacuateObjectDB {
     pub assignment_id: AssignmentId,
     pub object: String,
     pub shard: i32,
+    pub etag: String,
     pub status: EvacuateObjectStatus,
 }
 
@@ -76,6 +79,7 @@ struct FiniMsg;
 pub struct SharkSpotterObject {
     pub shard: i32,
     pub object: MantaObject,
+    pub etag: String,
 }
 
 #[derive(Debug, Clone, PartialEq, DbEnum)]
@@ -105,6 +109,7 @@ pub struct EvacuateObject {
     pub id: ObjectId,        // MantaObject ObjectId
     pub object: MantaObject, // The MantaObject being rebalanced
     pub shard: i32,          // shard number of metadata object record
+    pub etag: String,
     pub status: EvacuateObjectStatus,
     // Status of the object in the evacuation job
 }
@@ -116,6 +121,7 @@ impl EvacuateObject {
             id: ssobj.object.object_id.to_owned(),
             object: ssobj.object,
             shard: ssobj.shard,
+            etag: ssobj.etag,
             ..Default::default()
         }
     }
@@ -129,6 +135,7 @@ impl EvacuateObject {
             id: self.id.clone(),
             object: serde_json::to_string(&self.object)?,
             shard: self.shard,
+            etag: self.etag.clone(),
             status: self.status.clone(),
         })
     }
@@ -167,6 +174,12 @@ pub struct EvacuateJob {
     /// SqliteConnection to local database.
     pub conn: Mutex<SqliteConnection>,
 
+    /// domain_name of manta deployment
+    pub domain_name: String,
+
+    /// Logger
+    pub log: Logger,
+
     /// Accumulator for total time spent on DB inserts. (test/dev)
     pub total_db_time: Mutex<u128>,
 }
@@ -174,13 +187,22 @@ pub struct EvacuateJob {
 impl EvacuateJob {
     /// Create a new EvacauteJob instance.
     /// As part of this initialization also create a new SqliteConnection.
-    pub fn new<S: Into<String>>(from_shark: S, db_url: &str) -> Self {
+    pub fn new<S: Into<String>>(
+        from_shark: S,
+        domain_name: &str,
+        db_url: &str,
+    ) -> Self {
         let manta_storage_id = from_shark.into();
+        let plain = slog_term::PlainSyncDecorator::new(std::io::stdout());
+        let log = Logger::root(
+            Mutex::new(slog_term::FullFormat::new(plain).build()).fuse(),
+            o!("build-id" => "0.1.0"),
+        );
         let conn = SqliteConnection::establish(db_url)
             .unwrap_or_else(|_| panic!("Error connecting to {}", db_url));
         Self {
             min_avail_mb: Some(1000),
-            max_tasks_per_assignment: Some(100),
+            max_tasks_per_assignment: Some(1000),
             dest_shark_list: RwLock::new(HashMap::new()),
             assignments: RwLock::new(HashMap::new()),
             from_shark: MantaObjectShark {
@@ -189,6 +211,8 @@ impl EvacuateJob {
             },
             conn: Mutex::new(conn),
             total_db_time: Mutex::new(0),
+            domain_name: domain_name.to_string(),
+            log,
         }
     }
 
@@ -211,6 +235,7 @@ impl EvacuateJob {
                     assignment_id TEXT,
                     object TEXT,
                     shard Integer,
+                    etag TEXT,
                     status TEXT CHECK(status IN ('unprocessed', 'assigned',
                     'skipped', 'post_processing', 'complete')) NOT NULL
                 );
@@ -429,11 +454,54 @@ impl EvacuateJob {
         Ok(ret)
     }
 
+    // One other alternative is to try
+    /*
+    diesel::insert_into(users)
+    .values(&user2)
+    .on_conflict(id)
+    .do_update()
+    .set(name.eq("I DONT KNOW ANYMORE"))
+    .execute(&conn);
+    */
+    // Quick tests show that the below implementation scales very well:
+    // 100 objects: 12ms or (1/10 time/obj)
+    // 500 objects: 25ms (1/20 time/obj)
+    // 1000 objects: 52.5ms (1/19 time/obj)
+    fn mark_many_objects(
+        &self,
+        vec_obj_ids: Vec<String>,
+        to_status: EvacuateObjectStatus,
+    ) -> usize {
+        use self::evacuateobjects::dsl::*;
+
+        let locked_conn = self.conn.lock().expect("db conn lock");
+        let len = vec_obj_ids.len();
+
+        debug!("Marking {} objects as {:?}", len, to_status);
+        let now = std::time::Instant::now();
+        let ret = diesel::update(evacuateobjects)
+            .filter(id.eq_any(vec_obj_ids))
+            .set(status.eq(to_status))
+            .execute(&*locked_conn)
+            .unwrap_or_else(|e| {
+                let msg = format!("LocalDB: Error updating {}", e);
+                error!("{}", msg);
+                panic!(msg);
+            });
+        debug!(
+            "eq_any update of {} took {}ms",
+            len,
+            now.elapsed().as_millis()
+        );
+
+        ret
+    }
+
     /// Mark all objects with a given assignment ID with the specified
     /// EvacuateObjectStatus
     fn mark_assignment_objects(
         &self,
-        id: &AssignmentId,
+        id: &str,
         to_status: EvacuateObjectStatus,
     ) -> usize {
         use self::evacuateobjects::dsl::{
@@ -476,7 +544,7 @@ impl EvacuateJob {
 
     fn get_assignment_objects(
         &self,
-        id: &AssignmentId,
+        id: &str,
         status_filter: EvacuateObjectStatus,
     ) -> Vec<EvacuateObjectDB> {
         use self::evacuateobjects::dsl::{
@@ -609,19 +677,11 @@ impl UpdateMetadata for EvacuateJob {
         &self,
         mut object: MantaObject,
         new_shark: &StorageNode,
+        etag: String,
+        mclient: &mut MorayClient,
     ) -> Result<MantaObject, Error> {
         let old_shark = &self.from_shark;
-        let obj = serde_json::to_string(&object)?;
-        let etag = match util::crc_hex_str(&obj) {
-            Some(o) => o,
-            None => {
-                return Err(InternalError::new(
-                    None,
-                    "Error getting etag from Manta Object",
-                )
-                .into())
-            }
-        };
+        let log = self.log.clone();
 
         // Replace shark value
         let mut shark_found = false;
@@ -637,31 +697,8 @@ impl UpdateMetadata for EvacuateJob {
             }
         }
 
-        // Prepare metadata message.
-        let key = object.key.as_str();
-        let value =
-            serde_json::to_value(&object).expect("Serialize Manta Object");
-        let mut opts = MethodOptions::default();
-
-        opts.etag = Etag::Specified(etag);
+        moray_client::put_object(mclient, &object, &etag, log)?;
 
-        trace!(
-            "Updating metadata. Key: {}\nValue: {}\nopts: {:?}",
-            key,
-            value,
-            opts
-        );
-
-        // TODO: The EvacuateJob struct should implement a moray client hash
-        // and we can call a "get_moray_client()" method here that will
-        // get an existing client, or create a new client if need be.
-        /*
-        mclient.put_object("manta", key, value, &opts, |o| {
-                debug!("Updated object metadata: {}", &o);
-                Ok(())
-            },
-        ).expect("put_object");
-        */
         Ok(object)
     }
 }
@@ -793,19 +830,29 @@ fn start_sharkspotter(
         .name(String::from("sharkspotter"))
         .spawn(move || {
             let mut count = 0;
-            sharkspotter::run(config, log, move |object, shard| {
+            sharkspotter::run(config, log, move |object, shard, etag| {
+                trace!("Sharkspotter discovered object: {:#?}", &object);
                 // while testing, limit the number of objects processed for now
                 count += 1;
-                if count > 2000 {
+                if count > 2 {
                     return Err(std::io::Error::new(
                         ErrorKind::Other,
                         "Just stop already",
                     ));
                 }
 
+                if shard > std::i32::MAX as u32 {
+                    error!("Found shard number over int32 max");
+                    return Err(std::io::Error::new(
+                        ErrorKind::Other,
+                        "Exceeded max number of shards",
+                    ));
+                }
+
                 let ssobj = SharkSpotterObject {
                     shard: shard as i32,
                     object,
+                    etag,
                 };
                 obj_tx
                     .send(ssobj)
@@ -986,9 +1033,11 @@ fn start_assignment_generator(
                 let mut eobj_vec: Vec<EvacuateObject> = vec![];
 
                 debug!(
-                    "Filling up new assignment with max_tasks: {:#?}, \
+                    "Filling up new assignment for {} with max_tasks: {:#?}, \
                      and available_space: {}",
-                    &max_tasks, &available_space
+                    &assignment.dest_shark.manta_storage_id,
+                    &max_tasks,
+                    &available_space
                 );
 
                 // Start Task Loop
@@ -1022,14 +1071,10 @@ fn start_assignment_generator(
                     }
 
                     let obj = &eobj.object;
-                    let obj_on_dest = obj
-                        .sharks
-                        .iter()
-                        .find(|s| {
-                            s.manta_storage_id
-                                == assignment.dest_shark.manta_storage_id
-                        })
-                        .is_some();
+                    let obj_on_dest = obj.sharks.iter().any(|s| {
+                        s.manta_storage_id
+                            == assignment.dest_shark.manta_storage_id
+                    });
 
                     // We've found the object on the destination shark.  We will
                     // need to skip this object for now and find a destination
@@ -1188,6 +1233,8 @@ trait UpdateMetadata: Sync + Send {
         &self,
         object: MantaObject,
         new_shark: &StorageNode,
+        etag: String,
+        mclient: &mut MorayClient,
     ) -> Result<MantaObject, Error>;
 }
 
@@ -1282,6 +1329,7 @@ fn start_assignment_checker(
                     .clone();
 
                 debug!("Checking Assignments");
+
                 if !run
                     && assignments
                         .values()
@@ -1370,11 +1418,22 @@ fn start_assignment_checker(
         .map_err(Error::from)
 }
 
+// This worker continues to run as long as the queue has entries for it to
+// work on.  If, when the worker attempts to "steal" from the queue, the
+// queue is emtpy the worker exits.
 fn metadata_update_worker(
     job_action: Arc<EvacuateJob>,
     queue_front: Arc<Injector<Assignment>>,
 ) -> impl Fn() {
     move || {
+        // For each worker we create a hash of moray clients indexed by shard.
+        // If the worker exits then the clients and the associated
+        // connections are dropped.  This avoids having to place locks around
+        // the shard connections.  It also allows us to manage our max
+        // number of per-shard connections by simply tuning the number of
+        // metadata update worker threads.
+        let mut client_hash: HashMap<u32, MorayClient> = HashMap::new();
+
         loop {
             let assignment = match queue_front.steal() {
                 Steal::Success(a) => a,
@@ -1382,15 +1441,15 @@ fn metadata_update_worker(
                 Steal::Empty => break,
             };
 
+            let mut updated_objects = vec![];
             let dest_shark = &assignment.dest_shark;
-
             let objects = job_action.get_assignment_objects(
                 &assignment.id,
                 EvacuateObjectStatus::PostProcessing,
             );
 
-            let mut updated_objects = vec![];
             for obj in objects {
+                let etag = obj.etag;
                 let mut mobj: MantaObject =
                     match serde_json::from_str(&obj.object) {
                         Ok(o) => o,
@@ -1404,16 +1463,57 @@ fn metadata_update_worker(
                         }
                     };
 
+                // Unfortunately sqlite only accepts signed integers.  So we
+                // have to do the conversion here and cross our fingers that
+                // we don't have more than 2.1 billion shards.
+                // We do check this value coming in from sharkspotter as well.
+                if obj.shard < 0 {
+                    // TODO: persistent error (panic for now)
+                    panic!("Cannot have a negative shard");
+                }
+                let shard = obj.shard as u32;
+
+                // We can't use or_insert_with() here because in the event
+                // that client creation fails we want to handle that error.
+                let mclient = match client_hash.entry(shard) {
+                    Occupied(entry) => entry.into_mut(),
+                    Vacant(entry) => {
+                        let client = match moray_client::create_client(
+                            shard,
+                            &job_action.domain_name,
+                            &job_action.log,
+                        ) {
+                            Ok(client) => client,
+                            Err(e) => {
+                                // TODO: persistent error for EvacuateObject
+                                // in local DB
+                                error!(
+                                    "MD Update Worker: failed to get moray \
+                                     client for shard number {}. Cannot update \
+                                     metadata for {:#?}\n{}",
+                                    shard, mobj, e
+                                );
+
+                                continue;
+                            }
+                        };
+                        entry.insert(client)
+                    }
+                };
+
                 // This function updates the manta object with the new
                 // sharks in the Manta Metadata tier, and then returns the
                 // updated Manta metadata object.  It does not update the
                 // state of the associated EvacuateObject in the local database.
-                mobj = match job_action.update_object_shark(mobj, dest_shark) {
+                mobj = match job_action
+                    .update_object_shark(mobj, dest_shark, etag, mclient)
+                {
                     Ok(o) => o,
                     Err(e) => {
                         // TODO: log a persistent error for final job report.
                         error!(
-                            "Error updating {}, with dest_shark {:?}: {}",
+                            "MD Update worker: Error updating \n\n{:#?}, with \
+                             dest_shark {:?}\n\n{}",
                             &obj.object, dest_shark, e
                         );
                         continue;
@@ -1446,10 +1546,17 @@ fn metadata_update_worker(
                 }
             }
 
+            // https://stackoverflow
+            // .com/questions/47626047/execute-an-insert-or-update-using-diesel
             // TODO: batch update all objects in `updated_objects` with
             // EvacuateObjectStatus::Complete in the local DB meaning we are
             // completely done and this object has been rebalanced.
             // This is the finish line.
+
+            job_action.mark_many_objects(
+                updated_objects,
+                EvacuateObjectStatus::Complete,
+            );
         }
     }
 }
@@ -1596,6 +1703,7 @@ mod tests {
 
         let job_action = EvacuateJob::new(
             String::from("1.stor.joyent.us"),
+            "joyent.us",
             "empty_picker_test.db",
         );
         let job_action = Arc::new(job_action);
@@ -1656,8 +1764,11 @@ mod tests {
         let (md_update_tx, md_update_rx) = crossbeam::bounded(5);
         let (checker_fini_tx, checker_fini_rx) = crossbeam::bounded(1);
 
-        let job_action =
-            EvacuateJob::new(String::from("1.stor.joyent.us"), "full_test.db");
+        let job_action = EvacuateJob::new(
+            String::from("1.stor.joyent.us"),
+            "east.joyent.us",
+            "full_test.db",
+        );
         let conn = job_action.conn.lock().expect("db connection lock");
         conn.execute(r#"DROP TABLE evacuateobjects"#)
             .unwrap_or_else(|e| {
@@ -1671,6 +1782,7 @@ mod tests {
                 assignment_id TEXT,
                 object TEXT,
                 shard Integer,
+                etag TEXT,
                 status TEXT CHECK(status IN ('unprocessed', 'assigned',
                 'skipped', 'post_processing', 'complete')) NOT NULL
             );"#,
@@ -1684,7 +1796,7 @@ mod tests {
         let mut test_objects = vec![];
 
         let mut g = StdThreadGen::new(10);
-        for _ in 0..1000 {
+        for _ in 0..2 {
             let mobj = MantaObject::arbitrary(&mut g);
             test_objects.push(mobj);
         }
@@ -1699,6 +1811,8 @@ mod tests {
                     let ssobj = SharkSpotterObject {
                         shard: 1,
                         object: o.clone(),
+                        // TODO
+                        etag: String::from("Fake_etag"),
                     };
                     match obj_tx.send(ssobj) {
                         Ok(()) => (),
diff --git a/src/lib.rs b/src/lib.rs
index aba43e0..8e52314 100644
--- a/src/lib.rs
+++ b/src/lib.rs
@@ -24,5 +24,6 @@ pub mod jobs;
 pub mod agent;
 pub mod config;
 pub mod error;
+pub(crate) mod moray_client;
 pub mod picker;
 pub mod util;
diff --git a/src/main.rs b/src/main.rs
index 486507e..44a0e03 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -23,7 +23,7 @@ fn main() -> Result<(), Error> {
         SubCommand::Server => Ok(()),
         SubCommand::DoJob(job) => job.run(),
         SubCommand::Agent => {
-            Agent::run("127.0.0.1:7878");
+            Agent::run("0.0.0.0:7878");
             Ok(())
         }
     }
diff --git a/src/moray_client.rs b/src/moray_client.rs
new file mode 100644
index 0000000..1b31aac
--- /dev/null
+++ b/src/moray_client.rs
@@ -0,0 +1,61 @@
+use crate::error::Error;
+use libmanta::moray::MantaObject;
+use moray::{
+    client::MorayClient,
+    objects::{Etag, MethodOptions as ObjectMethodOptions},
+};
+use slog::{trace, Logger};
+use std::net::IpAddr;
+use trust_dns_resolver::Resolver;
+
+static MANTA_BUCKET: &str = "manta";
+
+fn lookup_ip(host: &str) -> Result<IpAddr, Error> {
+    let resolver = Resolver::from_system_conf()?;
+    let response = resolver.lookup_ip(host)?;
+    let ip: Vec<IpAddr> = response.iter().collect();
+
+    Ok(ip[0])
+}
+
+pub fn create_client(
+    shard: u32,
+    domain: &str,
+    log: &Logger,
+) -> Result<MorayClient, Error> {
+    let domain_name = format!("{}.moray.{}", shard, domain);
+
+    info!("Creating moray client for: {}", domain_name);
+
+    // TODO: Lookup SRV record for port number
+    let ip = lookup_ip(&domain_name)?;
+    MorayClient::from_parts(ip, 2021, log.clone(), None).map_err(Error::from)
+}
+
+pub fn put_object(
+    mclient: &mut MorayClient,
+    object: &MantaObject,
+    etag: &str,
+    log: Logger,
+) -> Result<(), Error> {
+    let mut opts = ObjectMethodOptions::default();
+    let key = object.key.as_str();
+    let value = serde_json::to_value(object)?;
+
+    opts.etag = Etag::Specified(etag.to_string());
+
+    trace!(
+        log,
+        "Updating metadata. Key: {}\nValue: {:#?}\nopts: {:?}",
+        key,
+        value,
+        opts
+    );
+
+    mclient
+        .put_object(MANTA_BUCKET, key, value, &opts, |o| {
+            trace!(log, "Object Updated: {}", o);
+            Ok(())
+        })
+        .map_err(Error::from)
+}
diff --git a/src/picker.rs b/src/picker.rs
index 4f66719..d678023 100644
--- a/src/picker.rs
+++ b/src/picker.rs
@@ -162,7 +162,7 @@ pub trait SharkSource: Sync + Send {
 // client in the future.
 fn fetch_sharks() -> Vec<StorageNode> {
     // TODO: should find picker in DNS
-    let mut ret = reqwest::get("http://10.77.77.24/poll").unwrap();
+    let mut ret = reqwest::get("http://10.77.77.43/poll").unwrap();
     let result = ret.json::<HashMap<String, Vec<StorageNode>>>().unwrap();
     let mut new_sharks = vec![];
 
diff --git a/src/util.rs b/src/util.rs
index 4316da2..349e7ec 100644
--- a/src/util.rs
+++ b/src/util.rs
@@ -8,9 +8,6 @@
  * Copyright 2019, Joyent, Inc.
  */
 
-use crc::crc32;
-use unescape::unescape;
-
 #[cfg(test)]
 use rand::{distributions::Alphanumeric, Rng};
 
@@ -19,18 +16,6 @@ pub fn shard_host2num(shard_host: &str) -> u32 {
     shard_split[0].parse().unwrap()
 }
 
-pub fn crc_hex_str(data: &str) -> Option<String> {
-    let str_obj = match unescape(data) {
-        Some(o) => o,
-        None => {
-            return None;
-        }
-    };
-    let crc_input = str_obj.trim_matches('"').as_bytes();
-    let etag = crc32::checksum_ieee(crc_input);
-    Some(format!("{:X}", etag))
-}
-
 // Used in test
 #[cfg(test)]
 pub fn random_string(len: usize) -> String {
-- 
2.21.0

