From 15a69d3e4ce6ecdea8be25694a4796a4b2e018e4 Mon Sep 17 00:00:00 2001
From: Cody Peter Mello <cody.mello@joyent.com>
Date: Thu, 18 Jan 2018 23:54:10 +0000
Subject: [PATCH] FWAPI-244 ipfilter dislikes fragmented IP packets FWAPI-295
 Returned packets are blocked when inbound is allowed and outbound is blocked

---
 src/fw/lib/fw.js                   | 69 +++++++++++++++++++++++-------
 src/fw/test/lib/helpers.js         | 25 +++++++----
 src/fw/test/unit/fw.test.js        |  6 +--
 src/fw/test/unit/owner.test.js     | 55 ++++++++++++++----------
 src/fw/test/unit/wildcards.test.js | 60 ++++++++++++++++++--------
 5 files changed, 147 insertions(+), 68 deletions(-)

diff --git a/src/fw/lib/fw.js b/src/fw/lib/fw.js
index 6c5d3fce..c7ba4591 100644
--- a/src/fw/lib/fw.js
+++ b/src/fw/lib/fw.js
@@ -65,6 +65,8 @@ var IPF_CONF = '%s/config/ipf.conf';
 var IPF_CONF_OLD = '%s/config/ipf.conf.old';
 var IPF6_CONF = '%s/config/ipf6.conf';
 var IPF6_CONF_OLD = '%s/config/ipf6.conf.old';
+var KEEP_FRAGS = ' keep frags';
+var KEEP_STATE = ' keep state';
 var NOT_RUNNING_MSG = 'Could not find running zone';
 // VM fields that affect filtering
 var VM_FIELDS = [
@@ -986,12 +988,10 @@ function ipfRuleObj(opts) {
         action: rule.action,
         direction: dir,
         protocol: rule.protocol,
-        v4text: [ '', util.format('# rule=%s, version=%s, %s=%s',
-            rule.uuid, rule.version, opts.type, opts.value)
-        ],
-        v6text: [ '', util.format('# rule=%s, version=%s, %s=%s',
-            rule.uuid, rule.version, opts.type, opts.value)
-        ],
+        header: util.format('\n# rule=%s, version=%s, %s=%s',
+            rule.uuid, rule.version, opts.type, opts.value),
+        v4text: [],
+        v6text: [],
         targets: targets,
         protoTargets: rule.protoTargets,
         type: opts.type,
@@ -1078,15 +1078,45 @@ function prepareIPFdata(opts, log, callback) {
         }, {});
     }
 
-    rules.forEach(function (rule) {
+    /* Gather the VMs targeted on each side of every enabled rule. */
+    var targetVMs = rules.map(function (rule) {
         if (!rule.enabled) {
-            return;
+            return null;
         }
 
-        var ruleVMs = {
+        return {
             from: vmsOnSide(allVMs, rule, 'from', log),
             to: vmsOnSide(allVMs, rule, 'to', log)
         };
+    });
+
+    /*
+     * If we block outbound traffic for a protocol, make sure to also track
+     * inbound state for anything allowed, so that we'll allow response
+     * packets.
+     *
+     * We could just always enable state tracking for all of our inbound
+     * allow rules, but state tracking can get pretty expensive. There's no
+     * need to penalize all firewall users.
+     */
+    var keepInboundState = { };
+    rules.forEach(function (rule, i) {
+        if (!rule.enabled || rule.action === 'allow') {
+            return;
+        }
+
+        targetVMs[i].from.forEach(function (uuid) {
+            if (!hasKey(keepInboundState, uuid)) {
+                keepInboundState[uuid] = {};
+            }
+            keepInboundState[uuid][rule.protocol] = true;
+        });
+    });
+
+    rules.forEach(function (rule, i) {
+        if (!rule.enabled) {
+            return;
+        }
 
         DIRECTIONS.forEach(function (dir) {
             // XXX: add to errors here if missing
@@ -1100,7 +1130,7 @@ function prepareIPFdata(opts, log, callback) {
             var otherSideRules =
                 rulesFromOtherSide(rule, dir, allVMs, remoteVMs);
 
-            ruleVMs[dir].forEach(function (uuid) {
+            targetVMs[i][dir].forEach(function (uuid) {
                 /*
                  * If the VM's firewall is disabled, we don't need to write out
                  * rules for it.
@@ -1119,35 +1149,44 @@ function prepareIPFdata(opts, log, callback) {
         var rulesIncluded = {};
         var v4filename = util.format(IPF_CONF, allVMs.all[vm].zonepath);
         var v6filename = util.format(IPF6_CONF, allVMs.all[vm].zonepath);
-        var ipfConf = [
+        var ipf4Conf = [
             '# DO NOT EDIT THIS FILE. THIS FILE IS AUTO-GENERATED BY fwadm(1M)',
             '# AND MAY BE OVERWRITTEN AT ANY TIME.',
             '#',
             '# File generated at ' + date.toString(),
             '#',
             ''];
-        var ipf6Conf = ipfConf.slice();
+        var ipf6Conf = ipf4Conf.slice();
+        var iks = hasKey(keepInboundState, vm) ? keepInboundState[vm] : {};
 
         toReturn.vms.push(vm);
 
         // XXX: sort here
         conf[vm].sort(compareRules).forEach(function (sortObj) {
+            var ktxt = KEEP_FRAGS;
+            if (sortObj.direction === 'to' && iks[sortObj.protocol]) {
+                ktxt += KEEP_STATE;
+            }
+
             if (!hasKey(rulesIncluded, sortObj.uuid)) {
                 rulesIncluded[sortObj.uuid] = [];
             }
             rulesIncluded[sortObj.uuid].push(sortObj.direction);
 
+            ipf4Conf.push(sortObj.header);
+            ipf6Conf.push(sortObj.header);
+
             sortObj.v4text.forEach(function (line) {
-                ipfConf.push(line);
+                ipf4Conf.push(line + ktxt);
             });
             sortObj.v6text.forEach(function (line) {
-                ipf6Conf.push(line);
+                ipf6Conf.push(line + ktxt);
             });
         });
 
         log.debug(rulesIncluded, 'VM %s: generated ipf(6).conf', vm);
 
-        var v4rules = ipfConf.concat(v4fallbacks);
+        var v4rules = ipf4Conf.concat(v4fallbacks);
         var v6rules = ipf6Conf.concat(v6fallbacks);
 
         toReturn.files[v4filename] = v4rules.join('\n') + '\n';
diff --git a/src/fw/test/lib/helpers.js b/src/fw/test/lib/helpers.js
index fae9876b..82085c42 100644
--- a/src/fw/test/lib/helpers.js
+++ b/src/fw/test/lib/helpers.js
@@ -622,39 +622,46 @@ function convertAction(action) {
     }
 }
 
-function createPortRule(action, dir, proto, who, port) {
+function createPortRule(action, dir, proto, who, port, rest) {
     var suffix = '';
     if (port) {
         suffix += 'port = ' + port;
     }
+    suffix += ' keep frags';
+    if (rest) {
+        suffix += ' ' + rest;
+    }
     return util.format(
         '%s %s quick proto %s from %s %s', action, dir, proto, who, suffix);
 }
 
-function createRangeRule(action, dir, proto, who, p1, p2) {
+function createRangeRule(action, dir, proto, who, p1, p2, rest) {
     var suffix = 'port ' + p1 + ' : ' + p2 + ' keep frags';
+    if (rest) {
+        suffix += ' ' + rest;
+    }
     return util.format(
         '%s %s quick proto %s from %s %s', action, dir, proto, who, suffix);
 }
 
-function allowPortInTCP(src, port) {
-    return createPortRule('pass', 'in', 'tcp', src + ' to any', port);
+function allowPortInTCP(src, port, rest) {
+    return createPortRule('pass', 'in', 'tcp', src + ' to any', port, rest);
 }
 
 function allowRangeInTCP(src, p1, p2) {
     return createRangeRule('pass', 'in', 'tcp', src + ' to any', p1, p2);
 }
 
-function blockPortInTCP(src, port) {
-    return createPortRule('block', 'in', 'tcp', src + ' to any', port);
+function blockPortInTCP(src, port, rest) {
+    return createPortRule('block', 'in', 'tcp', src + ' to any', port, rest);
 }
 
 function blockRangeInTCP(src, p1, p2) {
     return createRangeRule('block', 'in', 'tcp', src + ' to any', p1, p2);
 }
 
-function allowPortInUDP(src, port) {
-    return createPortRule('pass', 'in', 'udp', src + ' to any', port);
+function allowPortInUDP(src, port, rest) {
+    return createPortRule('pass', 'in', 'udp', src + ' to any', port, rest);
 }
 
 function allowInICMP(src, type, code) {
@@ -665,6 +672,7 @@ function allowInICMP(src, type, code) {
     if (code !== undefined) {
         suffix += ' code ' + code;
     }
+    suffix += ' keep frags';
     return util.format(
         'pass in quick proto icmp from %s to any %s', src, suffix);
 }
@@ -677,6 +685,7 @@ function allowInICMP6(src, type, code) {
     if (code !== undefined) {
         suffix += ' code ' + code;
     }
+    suffix += ' keep frags';
     return util.format(
         'pass in quick proto ipv6-icmp from %s to any %s', src, suffix);
 }
diff --git a/src/fw/test/unit/fw.test.js b/src/fw/test/unit/fw.test.js
index 06e0d376..a6e04688 100644
--- a/src/fw/test/unit/fw.test.js
+++ b/src/fw/test/unit/fw.test.js
@@ -20,7 +20,7 @@
  *
  * CDDL HEADER END
  *
- * Copyright (c) 2016, Joyent, Inc. All rights reserved.
+ * Copyright (c) 2018, Joyent, Inc. All rights reserved.
  *
  * fwadm tests
  */
@@ -530,7 +530,7 @@ exports['add: tag to subnet'] = function (t) {
                 helpers.blockPortOutTCP('10.99.99.0/24', 25)
             ];
             v4rules[vm1.uuid].in.tcp = [
-                helpers.allowPortInTCP('10.99.99.0/24', 80)
+                helpers.allowPortInTCP('10.99.99.0/24', 80, 'keep state')
             ];
 
             v4rules[vm2.uuid] = v4rules[vm1.uuid];
@@ -663,7 +663,7 @@ exports['add: vm to subnet'] = function (t) {
             v4rules[vm1.uuid].out.tcp =
                 [ helpers.blockPortOutTCP('10.99.99.0/24', 25) ];
             v4rules[vm1.uuid].in.tcp =
-                [ helpers.allowPortInTCP('10.99.99.0/24', 80) ];
+                [ helpers.allowPortInTCP('10.99.99.0/24', 80, 'keep state') ];
 
             t.deepEqual(helpers.zoneIPFconfigs(4), v4rules,
                 'zone ipf.conf files correct');
diff --git a/src/fw/test/unit/owner.test.js b/src/fw/test/unit/owner.test.js
index 981d0111..7a6d4eb4 100644
--- a/src/fw/test/unit/owner.test.js
+++ b/src/fw/test/unit/owner.test.js
@@ -20,7 +20,7 @@
  *
  * CDDL HEADER END
  *
- * Copyright (c) 2016, Joyent, Inc. All rights reserved.
+ * Copyright (c) 2018, Joyent, Inc. All rights reserved.
  *
  * test rules with owner_uuid set
  */
@@ -401,10 +401,10 @@ exports['all vms (local and remote)'] = function (t) {
                     helpers.blockPortOutTCP('10.1.1.4', 8082)
                 ];
                 v4rules[vm.uuid].in.tcp = [
-                    helpers.allowPortInTCP('10.1.1.1', 8081),
-                    helpers.allowPortInTCP('10.1.1.2', 8081),
-                    helpers.allowPortInTCP('10.1.1.3', 8081),
-                    helpers.allowPortInTCP('10.1.1.4', 8081)
+                    helpers.allowPortInTCP('10.1.1.1', 8081, 'keep state'),
+                    helpers.allowPortInTCP('10.1.1.2', 8081, 'keep state'),
+                    helpers.allowPortInTCP('10.1.1.3', 8081, 'keep state'),
+                    helpers.allowPortInTCP('10.1.1.4', 8081, 'keep state')
                 ];
             });
 
@@ -455,17 +455,17 @@ exports['all vms (local and remote)'] = function (t) {
 
             [vm1, vm2].forEach(function (vm) {
                 v4rules[vm.uuid].in.tcp = [
-                    helpers.allowPortInTCP('10.1.1.1', 8081),
-                    helpers.allowPortInTCP('10.1.1.2', 8081),
-                    helpers.allowPortInTCP('10.1.1.3', 8081),
-                    helpers.allowPortInTCP('10.1.1.4', 8081),
-
-                    helpers.allowPortInTCP('10.1.1.1', 8083),
-                    helpers.allowPortInTCP('10.1.1.2', 8083),
-                    helpers.allowPortInTCP('10.1.1.3', 8083),
-                    helpers.allowPortInTCP('10.1.1.4', 8083),
-                    helpers.allowPortInTCP('10.8.8.1', 8083),
-                    helpers.allowPortInTCP('10.8.8.2', 8083)
+                    helpers.allowPortInTCP('10.1.1.1', 8081, 'keep state'),
+                    helpers.allowPortInTCP('10.1.1.2', 8081, 'keep state'),
+                    helpers.allowPortInTCP('10.1.1.3', 8081, 'keep state'),
+                    helpers.allowPortInTCP('10.1.1.4', 8081, 'keep state'),
+
+                    helpers.allowPortInTCP('10.1.1.1', 8083, 'keep state'),
+                    helpers.allowPortInTCP('10.1.1.2', 8083, 'keep state'),
+                    helpers.allowPortInTCP('10.1.1.3', 8083, 'keep state'),
+                    helpers.allowPortInTCP('10.1.1.4', 8083, 'keep state'),
+                    helpers.allowPortInTCP('10.8.8.1', 8083, 'keep state'),
+                    helpers.allowPortInTCP('10.8.8.2', 8083, 'keep state')
                 ];
             });
 
@@ -534,13 +534,13 @@ exports['all vms (local and remote)'] = function (t) {
 
             [vm1, vm2].forEach(function (vm) {
                 v4rules[vm.uuid].in.tcp = [
-                    helpers.allowPortInTCP('10.1.1.4', 8081),
-                    helpers.allowPortInTCP('10.1.1.1', 8083),
-                    helpers.allowPortInTCP('10.1.1.2', 8083),
-                    helpers.allowPortInTCP('10.1.1.3', 8083),
-                    helpers.allowPortInTCP('10.1.1.4', 8083),
-                    helpers.allowPortInTCP('10.8.8.1', 8083),
-                    helpers.allowPortInTCP('10.8.8.2', 8083)
+                    helpers.allowPortInTCP('10.1.1.4', 8081, 'keep state'),
+                    helpers.allowPortInTCP('10.1.1.1', 8083, 'keep state'),
+                    helpers.allowPortInTCP('10.1.1.2', 8083, 'keep state'),
+                    helpers.allowPortInTCP('10.1.1.3', 8083, 'keep state'),
+                    helpers.allowPortInTCP('10.1.1.4', 8083, 'keep state'),
+                    helpers.allowPortInTCP('10.8.8.1', 8083, 'keep state'),
+                    helpers.allowPortInTCP('10.8.8.2', 8083, 'keep state')
                 ];
             });
 
@@ -582,6 +582,15 @@ exports['all vms (local and remote)'] = function (t) {
 
             [vm1, vm2].forEach(function (vm) {
                 v4rules[vm.uuid].out = {};
+                v4rules[vm.uuid].in.tcp = [
+                    helpers.allowPortInTCP('10.1.1.4', 8081),
+                    helpers.allowPortInTCP('10.1.1.1', 8083),
+                    helpers.allowPortInTCP('10.1.1.2', 8083),
+                    helpers.allowPortInTCP('10.1.1.3', 8083),
+                    helpers.allowPortInTCP('10.1.1.4', 8083),
+                    helpers.allowPortInTCP('10.8.8.1', 8083),
+                    helpers.allowPortInTCP('10.8.8.2', 8083)
+                ];
             });
 
             expRules = expRules.filter(function (r) {
diff --git a/src/fw/test/unit/wildcards.test.js b/src/fw/test/unit/wildcards.test.js
index ce0bf6f1..529483d2 100644
--- a/src/fw/test/unit/wildcards.test.js
+++ b/src/fw/test/unit/wildcards.test.js
@@ -20,7 +20,7 @@
  *
  * CDDL HEADER END
  *
- * Copyright (c) 2016, Joyent, Inc. All rights reserved.
+ * Copyright (c) 2018, Joyent, Inc. All rights reserved.
  *
  * fwadm tests: all and any targets
  */
@@ -175,8 +175,12 @@ exports['any <-> vm: add / update'] = function (t) {
                 rules: [ expRules[1] ]
             }, 'rules returned');
 
-            v4rules[vm.uuid].in.tcp = [ helpers.allowPortInTCP('any', 8081) ];
-            v6rules[vm.uuid].in.tcp = [ helpers.allowPortInTCP('any', 8081) ];
+            v4rules[vm.uuid].in.tcp = [
+                helpers.allowPortInTCP('any', 8081, 'keep state')
+            ];
+            v6rules[vm.uuid].in.tcp = [
+                helpers.allowPortInTCP('any', 8081, 'keep state')
+            ];
             t.deepEqual(helpers.zoneIPFconfigs(4), v4rules,
                 'IPv4 firewall rules correct');
             t.deepEqual(helpers.zoneIPFconfigs(6), v6rules,
@@ -301,6 +305,10 @@ exports['any <-> vm: add / update'] = function (t) {
 
             delete v4rules[vm.uuid].out.tcp;
             delete v6rules[vm.uuid].out.tcp;
+
+            v4rules[vm.uuid].in.tcp = [ helpers.allowPortInTCP('any', 8081) ];
+            v6rules[vm.uuid].in.tcp = [ helpers.allowPortInTCP('any', 8081) ];
+
             t.deepEqual(helpers.zoneIPFconfigs(4), v4rules,
                 'IPv4 firewall rules correct');
             t.deepEqual(helpers.zoneIPFconfigs(6), v6rules,
@@ -398,12 +406,14 @@ exports['any <-> all vms: add / update'] = function (t) {
                     helpers.blockPortOutTCP('192.168.4.2', 8082)
                 ];
                 v4rules[uuid].in.tcp = [
-                    helpers.allowPortInTCP('any', 8081),
-                    helpers.allowPortInTCP('192.168.0.1', 8083),
-                    helpers.allowPortInTCP('192.168.4.1', 8083),
-                    helpers.allowPortInTCP('192.168.4.2', 8083)
+                    helpers.allowPortInTCP('any', 8081, 'keep state'),
+                    helpers.allowPortInTCP('192.168.0.1', 8083, 'keep state'),
+                    helpers.allowPortInTCP('192.168.4.1', 8083, 'keep state'),
+                    helpers.allowPortInTCP('192.168.4.2', 8083, 'keep state')
+                ];
+                v6rules[uuid].in.tcp = [
+                    helpers.allowPortInTCP('any', 8081, 'keep state')
                 ];
-                v6rules[uuid].in.tcp = [ helpers.allowPortInTCP('any', 8081) ];
             });
 
             t.deepEqual(helpers.zoneIPFconfigs(4), v4rules,
@@ -458,11 +468,11 @@ exports['any <-> all vms: add / update'] = function (t) {
                     helpers.blockPortOutTCP('192.168.4.2', 8082)
                 ];
                 v4rules[uuid].in.tcp = [
-                    helpers.allowPortInTCP('any', 8081),
-                    helpers.allowPortInTCP('192.168.0.1', 8083),
-                    helpers.allowPortInTCP('192.168.0.2', 8083),
-                    helpers.allowPortInTCP('192.168.4.1', 8083),
-                    helpers.allowPortInTCP('192.168.4.2', 8083)
+                    helpers.allowPortInTCP('any', 8081, 'keep state'),
+                    helpers.allowPortInTCP('192.168.0.1', 8083, 'keep state'),
+                    helpers.allowPortInTCP('192.168.0.2', 8083, 'keep state'),
+                    helpers.allowPortInTCP('192.168.4.1', 8083, 'keep state'),
+                    helpers.allowPortInTCP('192.168.4.2', 8083, 'keep state')
                 ];
             });
 
@@ -512,9 +522,9 @@ exports['any <-> all vms: add / update'] = function (t) {
             delete v6rules[vm2.uuid].in.tcp;
 
             v4rules[vm1.uuid].in.tcp[0] =
-                helpers.allowPortInTCP('192.168.0.2', 8081);
+                helpers.allowPortInTCP('192.168.0.2', 8081, 'keep state');
             v4rules[vm2.uuid].in.tcp[0] =
-                helpers.allowPortInTCP('192.168.0.2', 8081);
+                helpers.allowPortInTCP('192.168.0.2', 8081, 'keep state');
 
             t.deepEqual(helpers.zoneIPFconfigs(4), v4rules,
                 'IPv4 firewall rules correct');
@@ -688,10 +698,10 @@ exports['add / update: all ports'] = function (t) {
             }, 'rules returned');
 
             v4rules[vm.uuid].in.tcp = [
-                helpers.allowPortInTCP('any')
+                helpers.allowPortInTCP('any', null, 'keep state')
             ];
             v6rules[vm.uuid].in.tcp = [
-                helpers.allowPortInTCP('any')
+                helpers.allowPortInTCP('any', null, 'keep state')
             ];
 
             t.deepEqual(helpers.zoneIPFconfigs(4), v4rules,
@@ -745,8 +755,12 @@ exports['add / update: all ports'] = function (t) {
                 rules: [ expRules[1] ]
             }, 'rules returned');
 
-            v4rules[vm.uuid].in.tcp = [ helpers.allowPortInTCP('any', 8081) ];
-            v6rules[vm.uuid].in.tcp = [ helpers.allowPortInTCP('any', 8081) ];
+            v4rules[vm.uuid].in.tcp = [
+                helpers.allowPortInTCP('any', 8081, 'keep state')
+            ];
+            v6rules[vm.uuid].in.tcp = [
+                helpers.allowPortInTCP('any', 8081, 'keep state')
+            ];
 
             v4rules[vm2.uuid] = helpers.defaultZoneRules();
             v6rules[vm2.uuid] = helpers.defaultZoneRules();
@@ -817,6 +831,14 @@ exports['add / update: all ports'] = function (t) {
 
             delete v4rules[vm.uuid].out.tcp;
             delete v6rules[vm.uuid].out.tcp;
+
+            v4rules[vm.uuid].in.tcp = [
+                helpers.allowPortInTCP('any', 8081)
+            ];
+            v6rules[vm.uuid].in.tcp = [
+                helpers.allowPortInTCP('any', 8081)
+            ];
+
             t.deepEqual(helpers.zoneIPFconfigs(4), v4rules,
                 'IPv4 firewall rules correct');
             t.deepEqual(helpers.zoneIPFconfigs(6), v6rules,
-- 
2.21.0

