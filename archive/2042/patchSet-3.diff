From b44e1371bf80907ac3ce9b6e56af42a5d677fc38 Mon Sep 17 00:00:00 2001
From: Alex Wilson <alex.wilson@joyent.com>
Date: Mon, 5 Jun 2017 16:43:55 -0700
Subject: [PATCH] joyent/node-cueball#111 smgr fixes in 2.2.6 forgot 'error'
 states Reviewed by: Robert Mustacchi <rm@joyent.com>

---
 CHANGES.adoc          |  9 ++++++
 lib/connection-fsm.js | 24 +++++++++++-----
 lib/pool.js           |  2 +-
 package.json          |  2 +-
 test/pool.test.js     | 64 ++++++++++++++++++++++++++++++++++++++++---
 5 files changed, 88 insertions(+), 13 deletions(-)

diff --git a/CHANGES.adoc b/CHANGES.adoc
index 5240d65..9222e4a 100644
--- a/CHANGES.adoc
+++ b/CHANGES.adoc
@@ -6,6 +6,15 @@ toc::[]
 
 ## v2.x
 
+### v2.2.7
+
+Maintenance release.
+
+Bugs fixed:
+
+ - #111 smgr fixes in 2.2.6 forgot 'error' states -- possible crash resulting
+   from mistake in fix for #108
+
 ### v2.2.6
 
 Maintenance release.
diff --git a/lib/connection-fsm.js b/lib/connection-fsm.js
index 8c117e3..ea9db76 100644
--- a/lib/connection-fsm.js
+++ b/lib/connection-fsm.js
@@ -818,8 +818,8 @@ function countListeners(eve, event) {
  *  | smgr.close() | <------------+        +-------------+            |
  *  +------+-------+  hdl rel. && |        | hdl released &&          |
  *         |         smgr conn && |        | smgr connected &&        |
- *   smgr  |              !wanted |        | wanted                   |
- * closed  |                      |        |                          |
+ *   !smgr |              !wanted |        | wanted                   |
+ * connctd |                      |        |                          |
  *         |                      |  busy  +----------------->(A)     |
  *         v                      |        | hdl released &&          |
  *    +---------+                 |        | smgr closed              |
@@ -834,9 +834,19 @@ function countListeners(eve, event) {
  *                                      v                             |
  *                                    +--------------+                |
  *                                    |   killing    +----------------+
- *                                    |              | smgr closed
+ *                                    |              | !(smgr connected)
  *                                    | smgr.close() |
  *                                    +--------------+
+ *
+ * Note that "!(smgr connected)" is often expanded out as (smgr closed) ||
+ * (smgr error), since 'closed' and 'error' are the two states the smgr pauses
+ * in when disconnected.
+ *
+ * Transitions out of the 'busy' state have to deal with the fact that they are
+ * entered on a handle transition and exited on an smgr transition, so they have
+ * to take a possible 'error' or 'closed' transition into consideration that
+ * they might not yet have observed the event for (it's still on the toEmit
+ * list, since it happened in the same event loop spin as the handle event).
  */
 function ConnectionSlotFSM(options) {
 	mod_assert.object(options, 'options');
@@ -1143,7 +1153,7 @@ ConnectionSlotFSM.prototype.state_killing = function (S) {
 	var smgr = this.csf_smgr;
 
 	S.on(smgr, 'stateChanged', function (st) {
-		if (st === 'closed') {
+		if (st === 'closed' || st === 'error') {
 			S.gotoState('retrying');
 		}
 	});
@@ -1154,7 +1164,7 @@ ConnectionSlotFSM.prototype.state_killing = function (S) {
 	 * 'stateChanged' event yet. If so, don't call .close(), just wait for
 	 * the event.
 	 */
-	if (!smgr.isInState('closed'))
+	if (!smgr.isInState('closed') && !smgr.isInState('error'))
 		smgr.close();
 };
 
@@ -1163,7 +1173,7 @@ ConnectionSlotFSM.prototype.state_stopping = function (S) {
 	var smgr = this.csf_smgr;
 
 	S.on(smgr, 'stateChanged', function (st) {
-		if (st === 'closed') {
+		if (st === 'closed' || st === 'error') {
 			S.gotoState('stopped');
 		}
 	});
@@ -1171,7 +1181,7 @@ ConnectionSlotFSM.prototype.state_stopping = function (S) {
 	/*
 	 * See above (deal with possible pending stateChanged event).
 	 */
-	if (!smgr.isInState('closed'))
+	if (!smgr.isInState('closed') && !smgr.isInState('error'))
 		smgr.close();
 };
 
diff --git a/lib/pool.js b/lib/pool.js
index 0cf9e57..12c9be3 100644
--- a/lib/pool.js
+++ b/lib/pool.js
@@ -415,7 +415,7 @@ CueBallConnectionPool.prototype.state_stopping.backends = function (S) {
 			fsms.push(fsm);
 		});
 	});
-	mod_vasync.forEachParallel({
+	this.p_closingForEach = mod_vasync.forEachParallel({
 		func: closeBackend,
 		inputs: fsms
 	}, function () {
diff --git a/package.json b/package.json
index 30d2e3e..375f01a 100644
--- a/package.json
+++ b/package.json
@@ -1,6 +1,6 @@
 {
   "name": "cueball",
-  "version": "2.2.6",
+  "version": "2.2.7",
   "description": "manage a pool of connections to a multi-node service where nodes are listed in DNS",
   "main": "lib/index.js",
   "dependencies": {
diff --git a/test/pool.test.js b/test/pool.test.js
index e960b1b..67d8c24 100644
--- a/test/pool.test.js
+++ b/test/pool.test.js
@@ -823,10 +823,66 @@ mod_tape.test('cueball#108', function (t) {
 
 				function doFail() {
 					hdl.close();
-					setImmediate(function () {
-						conn.emit('close');
-						setTimeout(end, 100);
-					});
+					conn.emit('close');
+					setTimeout(end, 100);
+				}
+
+				function end() {
+					pool.stop();
+				}
+			});
+		}, 100);
+	});
+});
+
+mod_tape.test('cueball#111', function (t) {
+	connections = [];
+	resolver = undefined;
+
+	recovery.default.retries = 2;
+	var pool = new mod_pool.ConnectionPool({
+		log: log,
+		domain: 'foobar',
+		spares: 2,
+		maximum: 2,
+		constructor: function (backend) {
+			return (new DummyConnection(backend));
+		},
+		recovery: recovery
+	});
+	t.ok(resolver);
+
+	pool.on('stateChanged', function (st) {
+		if (st === 'stopped') {
+			t.end();
+		}
+	});
+
+	resolver.emit('added', 'b1', {});
+	setImmediate(function () {
+		t.equal(connections.length, 2);
+		summarize();
+		t.deepEqual(counts, { 'b1': 2 });
+
+		index.b1[0].connect();
+		index.b1[1].connect();
+
+		setTimeout(function () {
+			t.ok(pool.isInState('running'));
+
+			t.equal(connections.length, 2);
+			summarize();
+			t.deepEqual(counts, { 'b1': 2 });
+
+			pool.claim(function (err, hdl, conn) {
+				t.ifError(err);
+
+				setTimeout(doFail, 100);
+
+				function doFail() {
+					hdl.close();
+					conn.emit('error', new Error('Foo'));
+					setTimeout(end, 100);
 				}
 
 				function end() {
-- 
2.21.0

