From 75cfe3ff8e8712860dd9b864ccb13d0cff141aae Mon Sep 17 00:00:00 2001
From: Alex Wilson <alex.wilson@joyent.com>
Date: Mon, 5 Jun 2017 16:43:55 -0700
Subject: [PATCH] joyent/node-cueball#111 smgr fixes in 2.2.6 forgot 'error'
 states

---
 CHANGES.adoc          |  9 ++++++
 lib/connection-fsm.js |  8 +++---
 lib/pool.js           |  2 +-
 package.json          |  2 +-
 test/pool.test.js     | 64 ++++++++++++++++++++++++++++++++++++++++---
 5 files changed, 75 insertions(+), 10 deletions(-)

diff --git a/CHANGES.adoc b/CHANGES.adoc
index 5240d65..9222e4a 100644
--- a/CHANGES.adoc
+++ b/CHANGES.adoc
@@ -6,6 +6,15 @@ toc::[]
 
 ## v2.x
 
+### v2.2.7
+
+Maintenance release.
+
+Bugs fixed:
+
+ - #111 smgr fixes in 2.2.6 forgot 'error' states -- possible crash resulting
+   from mistake in fix for #108
+
 ### v2.2.6
 
 Maintenance release.
diff --git a/lib/connection-fsm.js b/lib/connection-fsm.js
index 8c117e3..c255bab 100644
--- a/lib/connection-fsm.js
+++ b/lib/connection-fsm.js
@@ -1143,7 +1143,7 @@ ConnectionSlotFSM.prototype.state_killing = function (S) {
 	var smgr = this.csf_smgr;
 
 	S.on(smgr, 'stateChanged', function (st) {
-		if (st === 'closed') {
+		if (st === 'closed' || st === 'error') {
 			S.gotoState('retrying');
 		}
 	});
@@ -1154,7 +1154,7 @@ ConnectionSlotFSM.prototype.state_killing = function (S) {
 	 * 'stateChanged' event yet. If so, don't call .close(), just wait for
 	 * the event.
 	 */
-	if (!smgr.isInState('closed'))
+	if (!smgr.isInState('closed') && !smgr.isInState('error'))
 		smgr.close();
 };
 
@@ -1163,7 +1163,7 @@ ConnectionSlotFSM.prototype.state_stopping = function (S) {
 	var smgr = this.csf_smgr;
 
 	S.on(smgr, 'stateChanged', function (st) {
-		if (st === 'closed') {
+		if (st === 'closed' || st === 'error') {
 			S.gotoState('stopped');
 		}
 	});
@@ -1171,7 +1171,7 @@ ConnectionSlotFSM.prototype.state_stopping = function (S) {
 	/*
 	 * See above (deal with possible pending stateChanged event).
 	 */
-	if (!smgr.isInState('closed'))
+	if (!smgr.isInState('closed') && !smgr.isInState('error'))
 		smgr.close();
 };
 
diff --git a/lib/pool.js b/lib/pool.js
index 0cf9e57..12c9be3 100644
--- a/lib/pool.js
+++ b/lib/pool.js
@@ -415,7 +415,7 @@ CueBallConnectionPool.prototype.state_stopping.backends = function (S) {
 			fsms.push(fsm);
 		});
 	});
-	mod_vasync.forEachParallel({
+	this.p_closingForEach = mod_vasync.forEachParallel({
 		func: closeBackend,
 		inputs: fsms
 	}, function () {
diff --git a/package.json b/package.json
index 30d2e3e..375f01a 100644
--- a/package.json
+++ b/package.json
@@ -1,6 +1,6 @@
 {
   "name": "cueball",
-  "version": "2.2.6",
+  "version": "2.2.7",
   "description": "manage a pool of connections to a multi-node service where nodes are listed in DNS",
   "main": "lib/index.js",
   "dependencies": {
diff --git a/test/pool.test.js b/test/pool.test.js
index e960b1b..67d8c24 100644
--- a/test/pool.test.js
+++ b/test/pool.test.js
@@ -823,10 +823,66 @@ mod_tape.test('cueball#108', function (t) {
 
 				function doFail() {
 					hdl.close();
-					setImmediate(function () {
-						conn.emit('close');
-						setTimeout(end, 100);
-					});
+					conn.emit('close');
+					setTimeout(end, 100);
+				}
+
+				function end() {
+					pool.stop();
+				}
+			});
+		}, 100);
+	});
+});
+
+mod_tape.test('cueball#111', function (t) {
+	connections = [];
+	resolver = undefined;
+
+	recovery.default.retries = 2;
+	var pool = new mod_pool.ConnectionPool({
+		log: log,
+		domain: 'foobar',
+		spares: 2,
+		maximum: 2,
+		constructor: function (backend) {
+			return (new DummyConnection(backend));
+		},
+		recovery: recovery
+	});
+	t.ok(resolver);
+
+	pool.on('stateChanged', function (st) {
+		if (st === 'stopped') {
+			t.end();
+		}
+	});
+
+	resolver.emit('added', 'b1', {});
+	setImmediate(function () {
+		t.equal(connections.length, 2);
+		summarize();
+		t.deepEqual(counts, { 'b1': 2 });
+
+		index.b1[0].connect();
+		index.b1[1].connect();
+
+		setTimeout(function () {
+			t.ok(pool.isInState('running'));
+
+			t.equal(connections.length, 2);
+			summarize();
+			t.deepEqual(counts, { 'b1': 2 });
+
+			pool.claim(function (err, hdl, conn) {
+				t.ifError(err);
+
+				setTimeout(doFail, 100);
+
+				function doFail() {
+					hdl.close();
+					conn.emit('error', new Error('Foo'));
+					setTimeout(end, 100);
 				}
 
 				function end() {
-- 
2.21.0

