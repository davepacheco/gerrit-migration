From ca62001a76ec2569aa2d122206ec7861e952f184 Mon Sep 17 00:00:00 2001
From: Dan McDonald <danmcd@joyent.com>
Date: Fri, 22 Feb 2019 14:42:52 -0500
Subject: [PATCH] OS-7606 Multicast NCEs know no bounds!

---
 usr/src/uts/common/inet/ip.h                |   7 +-
 usr/src/uts/common/inet/ip/ip_ndp.c         | 270 ++++++++++++++++++--
 usr/src/uts/intel/ip/ip.global-objs.debug64 |   4 +-
 usr/src/uts/intel/ip/ip.global-objs.obj64   |   4 +-
 usr/src/uts/sparc/ip/ip.global-objs.debug64 |   4 +-
 usr/src/uts/sparc/ip/ip.global-objs.obj64   |   4 +-
 6 files changed, 269 insertions(+), 24 deletions(-)

diff --git a/usr/src/uts/common/inet/ip.h b/usr/src/uts/common/inet/ip.h
index a0ae38d4dd..1af5f16587 100644
--- a/usr/src/uts/common/inet/ip.h
+++ b/usr/src/uts/common/inet/ip.h
@@ -22,7 +22,7 @@
 /*
  * Copyright (c) 1990 Mentat Inc.
  * Copyright (c) 1991, 2010, Oracle and/or its affiliates. All rights reserved.
- * Copyright 2017, Joyent, Inc. All rights reserved.
+ * Copyright 2019, Joyent, Inc. All rights reserved.
  * Copyright 2017 Nexenta Systems, Inc.
  * Copyright 2017 OmniTI Computer Consulting, Inc. All rights reserved.
  */
@@ -1709,7 +1709,8 @@ typedef struct ill_s {
 
 		ill_manual_dst_linklocal : 1, /* same for pt-pt dst linklocal */
 
-		ill_pad_bit_31 : 27;
+		ill_mcast_ncec_cleanup : 1,	/* Reaping mcast ncecs. */
+		ill_pad_bit_31 : 26;
 
 	/*
 	 * Used in SIOCSIFMUXID and SIOCGIFMUXID for 'ifconfig unplumb'.
@@ -1777,6 +1778,7 @@ typedef struct ill_s {
 	 */
 	uint_t		ill_dl_bind_err;
 	avl_node_t	ill_avl_byppa; /* avl node based on ppa */
+	uint_t		ill_mcast_nces;	/* Number of NCEs that are multicast. */
 	list_t		ill_nce; /* pointer to nce_s list */
 	uint_t		ill_refcnt;	/* active refcnt by threads */
 	uint_t		ill_ire_cnt;	/* ires associated with this ill */
@@ -1948,6 +1950,7 @@ typedef struct ill_s {
  * ill_refcnt			ill_lock		ill_lock
  * ill_ire_cnt			ill_lock		ill_lock
  * ill_cv			ill_lock		ill_lock
+ * ill_mcast_nces		ill_lock		ill_lock
  * ill_ncec_cnt			ill_lock		ill_lock
  * ill_nce_cnt			ill_lock		ill_lock
  * ill_ilm_cnt			ill_lock		ill_lock
diff --git a/usr/src/uts/common/inet/ip/ip_ndp.c b/usr/src/uts/common/inet/ip/ip_ndp.c
index 211e56633f..7c759f902e 100644
--- a/usr/src/uts/common/inet/ip/ip_ndp.c
+++ b/usr/src/uts/common/inet/ip/ip_ndp.c
@@ -23,7 +23,7 @@
  */
 
 /*
- * Copyright (c) 2018, Joyent, Inc.
+ * Copyright (c) 2019, Joyent, Inc.
  */
 
 #include <sys/types.h>
@@ -127,8 +127,8 @@ static boolean_t ill_defend_rate_limit(ill_t *, ncec_t *);
 static	void	nce_queue_mp_common(ncec_t *, mblk_t *, boolean_t);
 static	int	nce_add_common(ill_t *, uchar_t *, uint_t, const in6_addr_t *,
     uint16_t, uint16_t, nce_t **);
-static nce_t *nce_add_impl(ill_t *, ncec_t *, nce_t *, mblk_t *);
-static nce_t *nce_add(ill_t *, ncec_t *);
+static nce_t *nce_add_impl(ill_t *, ncec_t *, nce_t *, mblk_t *, nce_t **);
+static nce_t *nce_add(ill_t *, ncec_t *, nce_t **);
 static void nce_inactive(nce_t *);
 extern nce_t	*nce_lookup(ill_t *, const in6_addr_t *);
 static nce_t *nce_ill_lookup_then_add(ill_t *, ncec_t *);
@@ -1004,6 +1004,212 @@ ncec_walk(ill_t *ill, ncec_walk_cb_t cbf, void *arg1, ip_stack_t *ipst)
 	ncec_walk_common(ipst->ips_ndp6, ill, cbf, arg1, B_TRUE);
 }
 
+/*
+ * Cheesy globals (i.e. all netstacks) for both a limit on per-ill multicast
+ * NCEs, and the number to reclaim if we hit the limit.  Used by
+ * nce_set_multicast_v[46]() to limit the linked-list length of ill_nce. Until
+ * we solve the multicast-mappings-shouldn't-be-NCEs problem, use this.
+ */
+
+/* Maximum number of multicast NCEs on an ill. */
+uint_t ip_max_ill_mcast_nces = 16384;
+/*
+ * Number of NCEs to delete if we hit the maximum above.  0 means *don't* and
+ * return an error.  Non-zero means delete so many, and if the number is >=
+ * the max above, that means delete them all.
+ */
+uint_t ip_ill_mcast_reclaim = 256;
+
+/*
+ * Encapsulate multicast ill capping in a function, for easier DTrace
+ * detections.  Return a list of refheld NCEs to destroy-via-refrele.  That
+ * list can be NULL, but can only be non-NULL if we successfully reclaimed.
+ *
+ * NOTE:  This function must be called while holding the ill_lock AND
+ * JUST PRIOR to making the insertion into the ill_nce list.
+ *
+ * We can't release the ones we delete ourselves because the ill_lock is
+ * held by the caller, they are passed back in a singly-linked nce_t list
+ * for deletion outside of the ill_lock hold by nce_graveyard_free().
+ *
+ * While this covers nce_t, ncec_t gets done even further down the road.  See
+ * nce_graveyard_free() for why.
+ */
+static boolean_t
+nce_too_many_mcast(ill_t *ill, nce_t **deadones)
+{
+	uint_t reclaim_count, max_count, reclaimed = 0;
+	boolean_t too_many = B_TRUE;
+	nce_t *nce, *deadman, *graveyard = NULL;
+
+	ASSERT(MUTEX_HELD(&ill->ill_lock));
+	/*
+	 * NOTE: Some grinning weirdo may have lowered the global max beyond
+	 * what this ill currently has.  The behavior in this case will be
+	 * trim-back just by the reclaim amount for any new ones.
+	 */
+	max_count = ip_max_ill_mcast_nces;
+	reclaim_count = min(ip_ill_mcast_reclaim, max_count);
+
+	if (ill->ill_mcast_nces < max_count) {
+		too_many = B_FALSE;
+		goto done;
+	}
+
+	if (reclaim_count == 0)
+		goto done;	/* Don't bother - we're stuck. */
+
+	/* We need to reclaim now.  Exploit our held ill_lock. */
+
+	/* Start at the tail and work backwards, new nces are head-inserted. */
+	nce = list_tail(&ill->ill_nce);
+	while (reclaimed < reclaim_count) {
+		/* Skip ahead to a multicast NCE. */
+		while (nce != NULL &&
+		    (nce->nce_common->ncec_flags & NCE_F_MCAST) == 0) {
+			nce = list_prev(&ill->ill_nce, nce);
+		}
+		if (nce == NULL)
+			break;
+
+		/*
+		 * NOTE: For now, we just delete the first one(s) we find.
+		 * This is not optimal, and may require some inspection of nce
+		 * & its ncec to be better.
+		 */
+		deadman = nce;
+		nce = list_prev(&ill->ill_nce, nce);
+
+		/* nce_delete() requires caller holds... */
+		nce_refhold(deadman);
+		nce_delete(deadman);	/* Bumps down ill_mcast_nces. */
+
+		/* Link the dead ones singly, still refheld... */
+		deadman->nce_node.list_next = (void *)graveyard;
+		graveyard = deadman;
+		reclaimed++;
+	}
+
+	if (reclaimed != reclaim_count) {
+		/* We didn't have enough to reach reclaim_count. Why?!? */
+		DTRACE_PROBE3(ill__mcast__nce__reclaim__mismatch, ill_t *, ill,
+		    uint_t, reclaimed, uint_t, reclaim_count);
+
+		/* In case for some REALLY weird reason we found none! */
+		too_many = (reclaimed == 0);
+	} else {
+		too_many = B_FALSE;
+	}
+
+done:
+	if (!too_many)
+		ill->ill_mcast_nces++;
+	*deadones = graveyard;	/* Caller can cope with NULL here, BTW. */
+	return (too_many);
+}
+
+static void
+ncec_mcast_reap_one(ncec_t *ncec, void *arg)
+{
+	boolean_t reapit;
+	ill_t *ill = (ill_t *)arg;
+
+	/* Obvious no-lock-needed checks... */
+	if (ncec == NULL || ncec->ncec_ill != ill ||
+	    (ncec->ncec_flags & NCE_F_MCAST) == 0)
+		return;
+
+	mutex_enter(&ncec->ncec_lock);
+	/*
+	 * It's refheld by the walk infrastructure. It has one reference
+	 * for interning, and if an nce_t exists, that's one more.
+	 * We want ones without an nce_t, so 2 is the magic number.  If it's
+	 * LESS than 2, we have much bigger problems anyway.
+	 */
+	ASSERT(ncec->ncec_refcnt >= 2);
+	reapit = (ncec->ncec_refcnt == 2);
+	mutex_exit(&ncec->ncec_lock);
+
+	if (reapit) {
+		/*
+		 * XXX KEBE ASKS, bump ip_nce_reclaim_deleted stat ala.
+		 * ncec_cache_reclaim() ?
+		 */
+		ncec_delete(ncec);
+	}
+}
+
+/*
+ * Attempt to reap stray multicast ncec_t structures. This is a taskq
+ * servicing routine, as it's well outside any netstack-global locks being
+ * held - ndp_g_lock in this case.  We have a reference hold on the ill, which
+ * will prevent any unplumbing races.
+ */
+static void
+ncec_mcast_reap(void *arg)
+{
+	ill_t *ill = (ill_t *)arg;
+
+	ncec_walk(ill, ncec_mcast_reap_one, ill, ill->ill_ipst);
+	mutex_enter(&ill->ill_lock);
+	ill->ill_mcast_ncec_cleanup = B_FALSE;
+	mutex_exit(&ill->ill_lock);
+	ill_refrele(ill);
+}
+
+/*
+ * Free a list (including handling an empty list) of reference-held NCEs that
+ * were reaped from a nce_too_many_mcast() call. Separate because the caller
+ * must have dropped ndp_g_lock first.
+ *
+ * This also schedules a taskq task to unlink underlying NCECs from the
+ * ndp_g_hash, which are protected by ndp_g_lock.
+ */
+static void
+nce_graveyard_free(nce_t *graveyard)
+{
+	nce_t *deadman;
+	ill_t *ill;
+	boolean_t doit;
+
+	if (graveyard == NULL)
+		return;
+
+	ill = graveyard->nce_ill;
+	ill_refhold(ill);
+
+	while (graveyard != NULL) {
+		ASSERT(ill == graveyard->nce_ill);
+		deadman = graveyard;
+		graveyard = (nce_t *)deadman->nce_node.list_next;
+		deadman->nce_node.list_next = NULL;
+		ASSERT((deadman->nce_common->ncec_flags & NCE_F_MCAST) != 0);
+		nce_refrele(deadman);
+	}
+
+	mutex_enter(&ill->ill_lock);
+	if (ill->ill_mcast_ncec_cleanup)
+		doit = B_FALSE;
+	else {
+		ill->ill_mcast_ncec_cleanup = B_TRUE;
+		doit = B_TRUE;
+	}
+	mutex_exit(&ill->ill_lock);
+	if (!doit || taskq_dispatch(system_taskq, ncec_mcast_reap,
+	    ill, TQ_NOSLEEP) == NULL) {
+		/*
+		 * XXX KEBE ASKS, keep track of this failure?  Or is refrele
+		 * here enough?
+		 */
+		if (doit) {
+			mutex_enter(&ill->ill_lock);
+			ill->ill_mcast_ncec_cleanup = B_FALSE;
+			mutex_exit(&ill->ill_lock);
+		}
+		ill_refrele(ill);
+	}
+}
+
 /*
  * For each interface an entry is added for the unspecified multicast group.
  * Here that mapping is used to form the multicast cache entry for a particular
@@ -1050,7 +1256,7 @@ nce_set_multicast_v6(ill_t *ill, const in6_addr_t *dst,
 	    ND_UNCHANGED, &nce);
 	mutex_exit(&ipst->ips_ndp6->ndp_g_lock);
 	if (err == 0)
-		err = nce_add_v6_postprocess(nce);
+		err = (nce != NULL) ? nce_add_v6_postprocess(nce) : ENOMEM;
 	if (hw_addr != NULL)
 		kmem_free(hw_addr, ill->ill_nd_lla_len);
 	if (err != 0) {
@@ -3100,7 +3306,7 @@ nce_fastpath_create(ill_t *ill, ncec_t *ncec)
  * method. All other callers (that pass in NULL ncec_nce) will have to do a
  * nce_refrele of the returned nce (when it is non-null).
  */
-nce_t *
+static nce_t *
 nce_fastpath(ncec_t *ncec, boolean_t trigger_fp_req, nce_t *ncec_nce)
 {
 	nce_t *nce;
@@ -3158,7 +3364,7 @@ nce_fastpath_trigger(nce_t *nce)
  * Add ncec to the nce fastpath list on ill.
  */
 static nce_t *
-nce_ill_lookup_then_add_locked(ill_t *ill, ncec_t *ncec)
+nce_ill_lookup_then_add_locked(ill_t *ill, ncec_t *ncec, nce_t **graveyard)
 {
 	nce_t *nce = NULL;
 
@@ -3178,21 +3384,22 @@ nce_ill_lookup_then_add_locked(ill_t *ill, ncec_t *ncec)
 		nce = nce_lookup(ill, &ncec->ncec_addr);
 		if (nce != NULL)
 			goto done;
-		nce = nce_add(ill, ncec);
+		nce = nce_add(ill, ncec, graveyard);
 	}
 done:
 	mutex_exit(&ncec->ncec_lock);
 	return (nce);
 }
 
-nce_t *
+static nce_t *
 nce_ill_lookup_then_add(ill_t *ill, ncec_t *ncec)
 {
-	nce_t *nce;
+	nce_t *nce, *graveyard = NULL;
 
 	mutex_enter(&ill->ill_lock);
-	nce = nce_ill_lookup_then_add_locked(ill, ncec);
+	nce = nce_ill_lookup_then_add_locked(ill, ncec, &graveyard);
 	mutex_exit(&ill->ill_lock);
+	nce_graveyard_free(graveyard);
 	return (nce);
 }
 
@@ -3242,7 +3449,7 @@ static nce_t *
 nce_delete_then_add(nce_t *nce)
 {
 	ill_t		*ill = nce->nce_ill;
-	nce_t		*newnce = NULL;
+	nce_t		*newnce = NULL, *graveyard = NULL;
 
 	ip0dbg(("nce_delete_then_add nce %p ill %s\n",
 	    (void *)nce, ill->ill_name));
@@ -3255,9 +3462,10 @@ nce_delete_then_add(nce_t *nce)
 	 * ipmp_ncec_delete_nce()
 	 */
 	if (!NCE_ISCONDEMNED(nce->nce_common))
-		newnce = nce_add(ill, nce->nce_common);
+		newnce = nce_add(ill, nce->nce_common, &graveyard);
 	mutex_exit(&nce->nce_common->ncec_lock);
 	mutex_exit(&ill->ill_lock);
+	nce_graveyard_free(graveyard);
 	nce_refrele(nce);
 	return (newnce); /* could be null if nomem */
 }
@@ -3972,7 +4180,7 @@ nce_set_multicast_v4(ill_t *ill, const in_addr_t *dst,
 	    ND_UNCHANGED, &nce);
 	mutex_exit(&ipst->ips_ndp4->ndp_g_lock);
 	if (err == 0)
-		err = nce_add_v4_postprocess(nce);
+		err = (nce != NULL) ? nce_add_v4_postprocess(nce) : ENOMEM;
 	if (hw_addr != NULL)
 		kmem_free(hw_addr, ill->ill_phys_addr_length);
 	if (err != 0) {
@@ -4395,7 +4603,7 @@ nce_add_common(ill_t *ill, uchar_t *hw_addr, uint_t hw_addr_len,
 	uint16_t		state;
 	boolean_t		fastprobe = B_FALSE;
 	struct ndp_g_s		*ndp;
-	nce_t			*nce = NULL;
+	nce_t			*nce = NULL, *graveyard = NULL;
 	mblk_t			*dlur_mp = NULL;
 
 	if (ill->ill_isv6)
@@ -4686,9 +4894,10 @@ nce_add_common(ill_t *ill, uchar_t *hw_addr, uint_t hw_addr_len,
 	 * Since we hold the ncec_lock at this time, the ncec cannot be
 	 * condemned, and we can safely add the nce.
 	 */
-	*retnce = nce_add_impl(ill, ncec, nce, dlur_mp);
+	*retnce = nce_add_impl(ill, ncec, nce, dlur_mp, &graveyard);
 	mutex_exit(&ncec->ncec_lock);
 	mutex_exit(&ill->ill_lock);
+	nce_graveyard_free(graveyard);
 
 	/* caller must trigger fastpath on *retnce */
 	return (0);
@@ -4774,10 +4983,27 @@ nce_inactive(nce_t *nce)
 
 /*
  * Add an nce to the ill_nce list.
+ *
+ * Adding multicast NCEs is subject to a per-ill limit. This function returns
+ * NULL if that's the case, and it may reap a number of multicast nces.
+ * Callers (and upstack) must be able to cope with NULL returns.
  */
 static nce_t *
-nce_add_impl(ill_t *ill, ncec_t *ncec, nce_t *nce, mblk_t *dlur_mp)
+nce_add_impl(ill_t *ill, ncec_t *ncec, nce_t *nce, mblk_t *dlur_mp,
+	nce_t **graveyard)
 {
+	ASSERT(MUTEX_HELD(&ill->ill_lock));
+
+	if (graveyard != NULL)
+		*graveyard = NULL;	/* Just in case... */
+
+	if ((ncec->ncec_flags & NCE_F_MCAST) != 0 &&
+	    nce_too_many_mcast(ill, graveyard)) {
+		ASSERT(graveyard == NULL);
+		kmem_cache_free(nce_cache, nce);
+		return (NULL);
+	}
+
 	bzero(nce, sizeof (*nce));
 	mutex_init(&nce->nce_lock, NULL, MUTEX_DEFAULT, NULL);
 	nce->nce_common = ncec;
@@ -4798,7 +5024,7 @@ nce_add_impl(ill_t *ill, ncec_t *ncec, nce_t *nce, mblk_t *dlur_mp)
 }
 
 static nce_t *
-nce_add(ill_t *ill, ncec_t *ncec)
+nce_add(ill_t *ill, ncec_t *ncec, nce_t **graveyard)
 {
 	nce_t	*nce;
 	mblk_t	*dlur_mp = NULL;
@@ -4819,7 +5045,11 @@ nce_add(ill_t *ill, ncec_t *ncec)
 			return (NULL);
 		}
 	}
-	return (nce_add_impl(ill, ncec, nce, dlur_mp));
+	/*
+	 * If nce_add_impl() returns NULL due to on multicast limiting, caller
+	 * will (correctly) assume ENOMEM.
+	 */
+	return (nce_add_impl(ill, ncec, nce, dlur_mp, graveyard));
 }
 
 /*
@@ -4843,6 +5073,10 @@ nce_delete(nce_t *nce)
 	nce->nce_is_condemned = B_TRUE;
 	mutex_exit(&nce->nce_lock);
 
+	/* Update the count of multicast NCEs. */
+	if ((nce->nce_common->ncec_flags & NCE_F_MCAST) == NCE_F_MCAST)
+		ill->ill_mcast_nces--;
+
 	list_remove(&ill->ill_nce, nce);
 	/*
 	 * even though we are holding the ill_lock, it is ok to
diff --git a/usr/src/uts/intel/ip/ip.global-objs.debug64 b/usr/src/uts/intel/ip/ip.global-objs.debug64
index d189c7a47c..b63f4cceee 100644
--- a/usr/src/uts/intel/ip/ip.global-objs.debug64
+++ b/usr/src/uts/intel/ip/ip.global-objs.debug64
@@ -21,7 +21,7 @@
 #
 # Copyright (c) 2007, 2010, Oracle and/or its affiliates. All rights reserved.
 # Copyright 2011 Nexenta Systems, Inc. All rights reserved
-# Copyright 2017 Joyent, Inc.
+# Copyright 2019 Joyent, Inc.
 #
 
 arp_m_tbl
@@ -119,11 +119,13 @@ ip_g_all_ones
 ip_helper_stream_info
 ip_helper_stream_rinit
 ip_helper_stream_winit
+ip_ill_mcast_reclaim
 ip_ioctl_ftbl
 ip_loopback_mtu_v6plus
 ip_loopback_mtuplus
 ip_m_tbl
 ip_max_frag_dups
+ip_max_ill_mcast_nces
 ip_min_frag_prune_time
 ip_minor_arena_la
 ip_minor_arena_sa
diff --git a/usr/src/uts/intel/ip/ip.global-objs.obj64 b/usr/src/uts/intel/ip/ip.global-objs.obj64
index e2b81e66a0..198eeea513 100644
--- a/usr/src/uts/intel/ip/ip.global-objs.obj64
+++ b/usr/src/uts/intel/ip/ip.global-objs.obj64
@@ -21,7 +21,7 @@
 #
 # Copyright (c) 2007, 2010, Oracle and/or its affiliates. All rights reserved.
 # Copyright 2011 Nexenta Systems, Inc. All rights reserved
-# Copyright 2017 Joyent, Inc.
+# Copyright 2019 Joyent, Inc.
 #
 
 arp_m_tbl
@@ -119,11 +119,13 @@ ip_g_all_ones
 ip_helper_stream_info
 ip_helper_stream_rinit
 ip_helper_stream_winit
+ip_ill_mcast_reclaim
 ip_ioctl_ftbl
 ip_loopback_mtu_v6plus
 ip_loopback_mtuplus
 ip_m_tbl
 ip_max_frag_dups
+ip_max_ill_mcast_nces
 ip_min_frag_prune_time
 ip_minor_arena_la
 ip_minor_arena_sa
diff --git a/usr/src/uts/sparc/ip/ip.global-objs.debug64 b/usr/src/uts/sparc/ip/ip.global-objs.debug64
index d189c7a47c..b63f4cceee 100644
--- a/usr/src/uts/sparc/ip/ip.global-objs.debug64
+++ b/usr/src/uts/sparc/ip/ip.global-objs.debug64
@@ -21,7 +21,7 @@
 #
 # Copyright (c) 2007, 2010, Oracle and/or its affiliates. All rights reserved.
 # Copyright 2011 Nexenta Systems, Inc. All rights reserved
-# Copyright 2017 Joyent, Inc.
+# Copyright 2019 Joyent, Inc.
 #
 
 arp_m_tbl
@@ -119,11 +119,13 @@ ip_g_all_ones
 ip_helper_stream_info
 ip_helper_stream_rinit
 ip_helper_stream_winit
+ip_ill_mcast_reclaim
 ip_ioctl_ftbl
 ip_loopback_mtu_v6plus
 ip_loopback_mtuplus
 ip_m_tbl
 ip_max_frag_dups
+ip_max_ill_mcast_nces
 ip_min_frag_prune_time
 ip_minor_arena_la
 ip_minor_arena_sa
diff --git a/usr/src/uts/sparc/ip/ip.global-objs.obj64 b/usr/src/uts/sparc/ip/ip.global-objs.obj64
index e2b81e66a0..198eeea513 100644
--- a/usr/src/uts/sparc/ip/ip.global-objs.obj64
+++ b/usr/src/uts/sparc/ip/ip.global-objs.obj64
@@ -21,7 +21,7 @@
 #
 # Copyright (c) 2007, 2010, Oracle and/or its affiliates. All rights reserved.
 # Copyright 2011 Nexenta Systems, Inc. All rights reserved
-# Copyright 2017 Joyent, Inc.
+# Copyright 2019 Joyent, Inc.
 #
 
 arp_m_tbl
@@ -119,11 +119,13 @@ ip_g_all_ones
 ip_helper_stream_info
 ip_helper_stream_rinit
 ip_helper_stream_winit
+ip_ill_mcast_reclaim
 ip_ioctl_ftbl
 ip_loopback_mtu_v6plus
 ip_loopback_mtuplus
 ip_m_tbl
 ip_max_frag_dups
+ip_max_ill_mcast_nces
 ip_min_frag_prune_time
 ip_minor_arena_la
 ip_minor_arena_sa
-- 
2.21.0

