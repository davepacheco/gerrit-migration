From 65a88b23ac7722c110fd0c70000afcd823916e2b Mon Sep 17 00:00:00 2001
From: Cody Peter Mello <cody.mello@joyent.com>
Date: Tue, 11 Apr 2017 02:08:23 +0000
Subject: [PATCH] ZAPI-781 Pass server NIC tag information to NAPI Reviewed by:
 Marsell Kukuljevic <marsell@joyent.com> Reviewed by: Josh Wilsdon
 <jwilsdon@joyent.com> Approved by: Josh Wilsdon <jwilsdon@joyent.com>

---
 lib/workflows/add-nics.js   | 123 +---------------------
 lib/workflows/job-common.js | 197 +++++++++++++++++++++++++++++++++---
 lib/workflows/provision.js  | 128 +++++++++--------------
 3 files changed, 234 insertions(+), 214 deletions(-)

diff --git a/lib/workflows/add-nics.js b/lib/workflows/add-nics.js
index b7ac403..d25f328 100644
--- a/lib/workflows/add-nics.js
+++ b/lib/workflows/add-nics.js
@@ -21,7 +21,7 @@
 
 var async;  // stub to keep jsl happy
 var common = require('./job-common');
-var VERSION = '7.1.0';
+var VERSION = '7.2.0';
 
 
 /*
@@ -45,123 +45,6 @@ function setupRequest(job, cb) {
 }
 
 
-/*
- * Get server object so we can check if it has the corresponding NIC tags
- */
-function getServerNicTags(job, cb) {
-    var cnapi = new sdcClients.CNAPI({
-        url: cnapiUrl,
-        headers: { 'x-request-id': job.params['x-request-id'] }
-    });
-
-    // Goes inside the "NIC Names" array and extracts the NIC Tags for each NIC
-    function mapNics(object) {
-        var nics = [];
-
-        for (var key in object) {
-            var subNics = object[key]['NIC Names'];
-            nics = nics.concat(subNics);
-        }
-
-        return nics;
-    }
-
-    // Goes inside the "Overlay Nic Tags" array and extracts the NIC Tags for
-    // each vnic
-    function mapVnics(object) {
-        var nics = [];
-        if (!object) {
-            object = {};
-        }
-
-        for (var key in object) {
-            var subNics = object[key]['Overlay Nic Tags'];
-            nics = nics.concat(subNics);
-        }
-
-        return nics;
-    }
-
-    cnapi.getServer(job.params.server_uuid, function (err, server) {
-        if (err) {
-            return cb(err);
-        }
-
-        job.serverNicTags =
-            mapNics(server.sysinfo['Network Interfaces']).concat(
-            mapVnics(server.sysinfo['Virtual Network Interfaces']));
-
-        return cb();
-    });
-}
-
-
-/*
- * Checks that the server has the NIC tags for every network or NIC that was
- * passed.
- */
-function checkServerNicTags(job, cb) {
-    var napi = new sdcClients.NAPI({
-        url: napiUrl,
-        headers: { 'x-request-id': job.params['x-request-id'] }
-    });
-
-    function done(err) {
-        if (err) {
-            cb(err);
-        } else {
-            cb(null, 'Server has all the required NIC tags');
-        }
-    }
-
-    var macs = job.params.macs;
-
-    // If 'macs' was passed, we're dealing with pre-created NICs, so we need
-    // to pull the NICs from NAPI first.
-    if (macs) {
-        async.mapSeries(macs, function (mac, next) {
-            napi.getNic(mac, function (err, nic) {
-                if (err) {
-                    return next(err);
-                }
-
-                var msg;
-                var nicTag = nic.nic_tag;
-
-                if (!nicTag) {
-                    msg = 'NIC does not have a tag';
-                    return next(new Error(msg));
-                }
-
-                // this hack is to split the nic tag off from the vnet_id,
-                // which fabric nics have embedded in their nic_tag attribute
-                var overlay = nicTag.match(/^(.+)\/\d+$/);
-                nicTag = overlay ? overlay[1] : nicTag;
-
-                if (job.serverNicTags.indexOf(nicTag) === -1) {
-                    msg = 'Server does not have NIC tag: ' + nicTag;
-                    return next(new Error(msg));
-                }
-
-                return next();
-            });
-        }, done);
-
-    // Otherwise we're dealing with networks. nicTags for these networks were
-    // loaded by the common.validateNetworks() task below.
-    } else {
-        for (var i = 0; i !== job.nicTags.length; i++) {
-            var tag = job.nicTags[i];
-
-            if (job.serverNicTags.indexOf(tag) === -1) {
-                return done(new Error('Server does not have NIC tag: ' + tag));
-            }
-        }
-
-        return done();
-    }
-}
-
 
 var workflow = module.exports = {
     name: 'add-nics-' + VERSION,
@@ -188,13 +71,13 @@ var workflow = module.exports = {
         name: 'cnapi.get_server_nic_tags',
         timeout: 10,
         retry: 1,
-        body: getServerNicTags,
+        body: common.getServerNicTags,
         modules: { sdcClients: 'sdc-clients' }
     }, {
         name: 'napi.check_server_nic_tags',
         timeout: 10,
         retry: 1,
-        body: checkServerNicTags,
+        body: common.checkServerNicTags,
         modules: { sdcClients: 'sdc-clients', async: 'async' }
     }, {
         name: 'napi.provision_nics',
diff --git a/lib/workflows/job-common.js b/lib/workflows/job-common.js
index 9e2321d..f118b09 100644
--- a/lib/workflows/job-common.js
+++ b/lib/workflows/job-common.js
@@ -569,7 +569,15 @@ function validateNetworks(job, cb) {
         headers: { 'x-request-id': job.params['x-request-id'] }
     });
 
-    job.nicTags = [];
+    job.nicTagReqs = [];
+
+    function pushPoolTags(pool) {
+        if (pool.nic_tags_present) {
+            job.nicTagReqs.push(pool.nic_tags_present);
+        } else {
+            job.nicTagReqs.push([ pool.nic_tag ]);
+        }
+    }
 
     // - Resolve network names to uuids when applicable
     // - Repopulate job.params.networks
@@ -594,38 +602,50 @@ function validateNetworks(job, cb) {
         netFn.call(napi, params, function (err, nets) {
             // If network is not found then it might be a network pool
             if (err && err.name !== 'ResourceNotFoundError') {
-                return callback(err);
+                callback(err);
+                return;
             }
 
             // Did we get the network from list or get?
             var net = (Array.isArray(nets) ? nets[0] : nets);
+
             // No net if NAPI returns an empty array or if we got a 404
             if (net) {
-                job.nicTags.push(net.nic_tag);
-                return callback(null, net.uuid);
+                job.nicTagReqs.push([ net.nic_tag ]);
+                callback(null, net.uuid);
+                return;
             }
 
             // We might be trying to provision on a network pool, so
             // try that instead
             poolFn.call(napi, params, function (err2, pools) {
                 if (err2) {
-                    return callback(err2);
+                    callback(err2);
+                    return;
                 }
 
-                // NAPI-121: listNetworkPools should accept a name
+                /*
+                 * Prior to NAPI-121, using a "name" filter for a network pool
+                 * would either be silently ignored (or rejected post NAPI-343).
+                 * In case we're talking to a NAPI that's ignored our parameter,
+                 * we filter the results to avoid using an incorrect pool.
+                 */
                 if (Array.isArray(pools)) {
                     pools = pools.filter(function (pool) {
                         return pool.name === netId;
                     });
-                    if (pools.length) {
-                        job.nicTags.push(pools[0].nic_tag);
+                    if (pools.length === 0) {
+                        callback(new Error(
+                            'No such Network Pool with name: ' + netId));
+                    } else if (pools.length === 1) {
+                        pushPoolTags(pools[0]);
                         callback(null, pools[0].uuid);
                     } else {
-                        callback(new Error('No such Network Pool with ' +
-                            'name: ' + netId));
+                        callback(new Error(
+                            'Multiple Network Pools with name: ' + netId));
                     }
                 } else {
-                    job.nicTags.push(pools.nic_tag);
+                    pushPoolTags(pools);
                     callback(null, pools.uuid);
                 }
             });
@@ -656,13 +676,163 @@ function validateNetworks(job, cb) {
             cb(err2);
         } else {
             job.params.networks = newNetworks;
-            job.log.info({ nicTags: job.nicTags }, 'NIC Tags retrieved');
+            job.log.info({ nicTagReqs: job.nicTagReqs },
+                'NIC Tag requirements retrieved');
             cb(null, 'Networks are valid');
         }
     });
 }
 
 
+/*
+ * Get server object so we can check if it has the corresponding NIC tags.
+ */
+function getServerNicTags(job, cb) {
+    function extractServerNicTags(err, server) {
+        if (err) {
+            cb(err);
+            return;
+        }
+
+        /*
+         * Perform the same logic that DAPI performs on the sysinfo payload,
+         * minus the parts about online/offline NICs, since we're either
+         * adding new NICs to a VM or performing a manual server selection.
+         */
+
+        var interfaces = server.sysinfo['Network Interfaces'] || {};
+        var vnics = server.sysinfo['Virtual Network Interfaces'] || {};
+
+        var serverTags = {};
+
+        Object.keys(interfaces).forEach(function extractTags(nicName) {
+            var nic = interfaces[nicName];
+            var nicTags = nic['NIC Names'];
+
+            for (var i = 0; i < nicTags.length; i++) {
+                serverTags[nicTags[i]] = true;
+            }
+        });
+
+        Object.keys(vnics).forEach(function extractOverlayTags(nicName) {
+            var nic = vnics[nicName];
+            var nicTags = nic['Overlay Nic Tags'] || [];
+
+            for (var i = 0; i < nicTags.length; i++) {
+                serverTags[nicTags[i]] = true;
+            }
+        });
+
+        job.serverNicTags = Object.keys(serverTags);
+
+        cb();
+    }
+
+    if (job.server_info) {
+        extractServerNicTags(null, job.server_info);
+    } else {
+        var cnapi = new sdcClients.CNAPI({
+            url: cnapiUrl,
+            headers: { 'x-request-id': job.params['x-request-id'] }
+        });
+
+        cnapi.getServer(job.params.server_uuid, extractServerNicTags);
+    }
+}
+
+
+/*
+ * Checks that the server has the NIC tags for every network or NIC that was
+ * passed to it. While this task is usually done in DAPI when determining where
+ * to place a VM, it also needs to be done when adding a new NIC to a VM, or
+ * when the server_uuid has been manually specified during provisioning.
+ */
+function checkServerNicTags(job, cb) {
+    function done(err) {
+        if (err) {
+            cb(err);
+        } else {
+            cb(null, 'Server has all the required NIC tags');
+        }
+    }
+
+    var macs = job.params.macs;
+
+    if (macs) {
+        /*
+         * If 'macs' was passed, we're dealing with pre-created NICs, so we need
+         * to pull the NICs from NAPI first.
+         */
+        var napi = new sdcClients.NAPI({
+            url: napiUrl,
+            headers: { 'x-request-id': job.params['x-request-id'] }
+        });
+
+        async.mapSeries(macs, function lookupMAC(mac, next) {
+            napi.getNic(mac, function checkTagOkay(err, nic) {
+                if (err) {
+                    next(err);
+                    return;
+                }
+
+                var nicTag = nic.nic_tag;
+
+                if (!nicTag) {
+                    next(new Error('NIC ' + mac + 'does not have a tag'));
+                    return;
+                }
+
+                /*
+                 * This hack is to split the NIC tag off from the vnet_id, which
+                 * fabric NICs have embedded in their nic_tag attribute.
+                 */
+                var overlay = nicTag.match(/^(.+)\/\d+$/);
+                nicTag = overlay ? overlay[1] : nicTag;
+
+                if (job.serverNicTags.indexOf(nicTag) === -1) {
+                    next(new Error('Server does not have NIC tag: ' + nicTag));
+                    return;
+                }
+
+                next();
+            });
+        }, done);
+    } else {
+        /*
+         * Otherwise we're dealing with networks. The nic_tag requirements for
+         * these networks and pools were already loaded by validateNetworks().
+         * We need to make sure that the specified server satisfies at least one
+         * of the tags required for each network and pool.
+         */
+        var serverTags = {};
+        job.serverNicTags.forEach(function extractServerTag(tag) {
+            serverTags[tag] = true;
+        });
+
+        for (var i = 0; i < job.nicTagReqs.length; i++) {
+            var reqs = job.nicTagReqs[i];
+            var satisfied = false;
+
+            for (var j = 0; j < reqs.length; j++) {
+                if (serverTags[reqs[j]]) {
+                    satisfied = true;
+                    break;
+                }
+            }
+
+            if (!satisfied) {
+                done(new Error(
+                    'Server must have one of the following NIC tags: ' +
+                    reqs.join(', ')));
+                return;
+            }
+        }
+
+        done();
+        return;
+    }
+}
+
 
 /*
  * Provisions a list of NICs for the soon to be provisioned machine.
@@ -712,6 +882,7 @@ function provisionNics(job, cb) {
             owner_uuid: owner_uuid,
             belongs_to_uuid: inst_uuid,
             belongs_to_type: 'zone',
+            nic_tags_available: job.serverNicTags,
             cn_uuid: job.params.server_uuid
         };
     }
@@ -1420,6 +1591,8 @@ module.exports = {
     putVm: putVm,
     checkUpdated: checkUpdated,
     postBack: postBack,
+    getServerNicTags: getServerNicTags,
+    checkServerNicTags: checkServerNicTags,
     provisionNics: provisionNics,
     addNics: addNics,
     cleanupNics: cleanupNics,
diff --git a/lib/workflows/provision.js b/lib/workflows/provision.js
index f4ad1a0..efc30c2 100644
--- a/lib/workflows/provision.js
+++ b/lib/workflows/provision.js
@@ -19,7 +19,7 @@ var common = require('./job-common');
 var childProcess = require('child_process');
 var wfapiUrl;
 
-var VERSION = '7.4.0';
+var VERSION = '7.5.0';
 
 
 /*
@@ -122,86 +122,22 @@ function generatePasswords(job, cb) {
 }
 
 
-
-/*
- * If a server_uuid was already provided (thus skipping DAPI's checks above),
- * we'd still like to at least ensure that the manually-selected server has the
- * sufficient matching nic-tags.
- *
- * This function only applies if params['server_uuid'] was provided by the
- * entity (e.g. person) invoking the provision.
- */
-function checkManualServerNics(job, cb) {
-    var serverUuid = job.params['server_uuid'];
-
-    if (!serverUuid) {
-        return cb();
-    }
-
-    var headers = { 'x-request-id': job.params['x-request-id'] };
-    var cnapi = new sdcClients.CNAPI({ url: cnapiUrl, headers: headers });
-
-    return cnapi.getServer(serverUuid, function (err, server) {
-        if (err) {
-            return cb(err);
-        }
-
-        var nicTags = job.nicTags;
-        var interfaces = server.sysinfo['Network Interfaces'];
-        var found = 0;
-        var vnics = server.sysinfo['Virtual Network Interfaces'] || {};
-
-        Object.keys(interfaces).forEach(function (iname) {
-            var serverTags = interfaces[iname]['NIC Names'];
-
-            for (var i = 0; i < nicTags.length; i++) {
-                if (serverTags.indexOf(nicTags[i]) !== -1) {
-                    found++;
-                }
-            }
-        });
-
-        Object.keys(vnics).forEach(function (iname) {
-            var serverTags = vnics[iname]['Overlay Nic Tags'] || [];
-
-            for (var i = 0; i < nicTags.length; i++) {
-                if (serverTags.indexOf(nicTags[i]) !== -1) {
-                    found++;
-                }
-            }
-        });
-
-        if (found == nicTags.length) {
-            return cb(null, 'Manual server meets NIC Tag requirements');
-        } else {
-            job.log.info({
-                nicTags: nicTags,
-                found: found,
-                interfaces: interfaces,
-                vnics: vnics
-            }, 'Missing manual server nic tags');
-            return cb('Manual server does not meet NIC Tag requirements');
-        }
-    });
-}
-
-
-
 /*
  * Selects a server for the VM. This function will send VM, image, package and
- * nic-tag requirements to DAPI, and let it figure out which server best fits
+ * NIC tag requirements to DAPI, and let it figure out which server best fits
  * the requirements.
  *
  * Note that if you pass params['server_uuid'], this function will terminate
  * early, because you have already specified the server you want to provision.
  */
 function getAllocation(job, cb) {
-    var nicTags = job.nicTags;
+    var nicTagReqs = job.nicTagReqs;
     var pkg = job.params.package;
     var img = job.params.image;
 
-    if (!nicTags) {
-        return cb('NIC tags are required');
+    if (!nicTagReqs) {
+        cb('NIC tag requirements must be present');
+        return;
     }
 
     if (!img) {
@@ -219,24 +155,44 @@ function getAllocation(job, cb) {
         headers: { 'x-request-id': job.params['x-request-id'] }
     });
 
+    /*
+     * In case we're talking to an older DAPI from before heterogeneous pools
+     * were supported, we select the first tag from each list of alternatives.
+     */
+    var nicTags = nicTagReqs.map(function extractFirstTag(arr) {
+        return arr[0];
+    });
+
     var payload = {
         vm: job.params,
         image: img,
         package: pkg,
-        nic_tags: nicTags
+        nic_tags: nicTags,
+        nic_tag_requirements: nicTagReqs
     };
 
     job.log.info({ dapiPayload: payload }, 'Payload sent to DAPI');
 
-    return cnapi.post('/allocate', payload, function (err, req, res, body) {
+    cnapi.post('/allocate', payload, function finish(err, req, res, body) {
         if (err) {
-            return cb(err);
+            cb(err);
+            return;
         }
 
-        job.params['server_uuid'] = body.server.uuid;
+        var server_uuid = body.server.uuid;
+        job.params.server_uuid = server_uuid;
         job.params.imgapiPeers = body.imgapiPeers;
-        job.server_uuid = body.server.uuid;
-        return cb(null, 'VM allocated to Server ' + body.server.uuid);
+        job.server_uuid = server_uuid;
+        job.server_info = {
+            sysinfo: {
+                'Network Interfaces':
+                    body.server.sysinfo['Network Interfaces'],
+                'Virtual Network Interfaces':
+                    body.server.sysinfo['Virtual Network Interfaces']
+            }
+        };
+
+        cb(null, 'VM allocated to Server ' + server_uuid);
     });
 }
 
@@ -484,12 +440,6 @@ var workflow = module.exports = {
         retry: 1,
         body: common.validateNetworks,
         modules: { sdcClients: 'sdc-clients', async: 'async' }
-    }, {
-        name: 'cnapi.check_manual_server_nics',
-        timeout: 10,
-        retry: 1,
-        body: checkManualServerNics,
-        modules: { sdcClients: 'sdc-clients' }
     },
 
     /**
@@ -543,6 +493,20 @@ var workflow = module.exports = {
     /**
      * End of DAPI serialization section.
      */
+
+    {
+        name: 'cnapi.get_server_nic_tags',
+        timeout: 10,
+        retry: 1,
+        body: common.getServerNicTags,
+        modules: { sdcClients: 'sdc-clients' }
+    }, {
+        name: 'cnapi.check_manual_server_nics',
+        timeout: 10,
+        retry: 1,
+        body: common.checkServerNicTags,
+        modules: { sdcClients: 'sdc-clients' }
+    },
     {
         name: 'napi.provision_nics',
         timeout: 20,
-- 
2.21.0

