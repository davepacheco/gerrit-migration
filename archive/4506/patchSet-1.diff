commit 3502c5808339141f918a3a1d03b664d179775c09 (refs/changes/06/4506/1)
Author: Pedro Palazon Candel <pedro@joyent.com>
Date:   2018-07-12T17:03:21+02:00 (1 year, 3 months ago)
    
    TOOLS-1571 sdcadm should rollback post-setup ha-manatee

diff --git a/test/manatee.test.js b/test/manatee.test.js
index ace1753..89cdc10 100644
--- a/test/manatee.test.js
+++ b/test/manatee.test.js
@@ -19,6 +19,9 @@ var format = util.format;
 
 var test = require('tape').test;
 var uuid = require('node-uuid');
+var bunyan = require('bunyan');
+var vasync = require('vasync');
+var zkstream = require('zkstream');
 
 var exec = require('child_process').exec;
 var common = require('./common');
@@ -27,6 +30,9 @@ var shared = require('./shared');
 
 var servers = [];
 var instances = [];
+// Used to restore pre-HA manatee setup when possible:
+var zkHost;
+var zkInitialStateRaw;
 
 function getServers(t, cb) {
     var cmd = 'sdc-cnapi /servers?setup=true|json -H -j';
@@ -61,6 +67,76 @@ test('setup', function (t) {
     });
 });
 
+test('get initial zk-state', function (t) {
+    if (instances.length > 1) {
+        t.end();
+        return;
+    }
+
+    var context = {};
+    vasync.pipeline({
+        arg: context,
+        funcs: [
+            function getBinderIPs(_, next) {
+                var command = 'sdcadm insts binder -j';
+                exec(command, function (err, stdout, stderr) {
+                    if (err) {
+                        next(err);
+                        return;
+                    }
+                    var out = JSON.parse(stdout.trim());
+                    zkHost = out[0].ip;
+                    next();
+                });
+            },
+            function createZkClient(ctx, next) {
+                var zkc = new zkstream.Client({
+                    address: zkHost,
+                    port: 2181,
+                    log: bunyan.createLogger({
+                        name: 'manatee.test',
+                        stream: process.stderr,
+                        level: 'debug'
+                    }),
+                    sessionTimeout: 30000
+                });
+                zkc.once('connect', function () {
+                    next();
+                });
+                zkc.once('failed', function () {
+                    zkc.close(function () {
+                        next(new Error('Zookeeper connection failed'));
+                    });
+                });
+                zkc.once('close', function () {
+                    t.end();
+                });
+
+                ctx.zkc = zkc;
+            },
+            function getSdcZkData(ctx, next) {
+                if (!ctx.zkc.isConnected()) {
+                    next(new Error('Not connected to Zookeeper'));
+                    return;
+                }
+
+                ctx.zkc.get('/manatee/sdc/state', function (err, data) {
+                    if (err) {
+                        next(err);
+                        return;
+                    }
+                    zkInitialStateRaw = data;
+                    next();
+                });
+            }
+        ]
+    }, function pipeCb(pipeErr) {
+        t.ok(context.zkc);
+        t.ifError(pipeErr);
+        context.zkc.close();
+    });
+});
+
 
 test('post-setup help ha-manatee', function (t) {
     checkHelp(t, 'post-setup ha-manatee',
@@ -69,7 +145,7 @@ test('post-setup help ha-manatee', function (t) {
 
 
 test('update non-HA', function (t) {
-    // Skip of not into ONWM initially
+    // Skip if not into ONWM initially
     if (instances.length > 1) {
         t.end();
         return;
@@ -174,3 +250,333 @@ test('update HA', function (t) {
         t.end();
     });
 });
+
+test('teardown', function (t) {
+    if (instances.length > 1) {
+        t.end();
+        return;
+    }
+
+    var context = {};
+
+    /*
+     * Pipeline of functions to be executed only if our setup has moved from
+     * ONWM to HA
+     */
+    var haFuncs = [
+        /*
+         * set `ctx.instsToRemove`
+         */
+        function getManateeInstances(ctx, next) {
+            getInstances(t, function (insts) {
+                // We don't wanna remove first one:
+                ctx.instsToRemove = insts.filter(function (inst) {
+                    return (inst.params.alias !==
+                        instances[0].params.alias);
+                });
+                next();
+            });
+        },
+
+        /*
+         * Set `ctx.manateVmsByUuid`
+         */
+        function getManateeVms(ctx, next) {
+            var command = '/opt/smartdc/bin/sdc-vmapi --no-headers' +
+                    ' /vms?tag.smartdc_role=manatee' +
+                    '&state=running';
+
+            exec(command, function (err, stdout, stderr) {
+                if (err) {
+                    next(err);
+                    return;
+                }
+                var vms = JSON.parse(stdout);
+                vms = vms.filter(function (vm) {
+                    return (vm.alias !== instances[0].params.alias);
+                });
+
+                ctx.manateVmsByUuid = {};
+
+                vms.forEach(function (vm) {
+                    ctx.manateVmsByUuid[vm.uuid] = vm;
+                });
+
+                next();
+            });
+        },
+
+        /*
+         * Call `manatee-adm freeze` before going for the downgrade steps
+         */
+        function freezeManatee(ctx, next) {
+            if (ctx.zkState.freeze) {
+                next();
+                return;
+            }
+            var cmd = format('/usr/sbin/zlogin %s ' +
+                '"source ~/.bashrc; ' +
+                '/opt/smartdc/manatee/node_modules/.bin/manatee-adm freeze ' +
+                '-r \'downgrading\'"',
+                instances[0].uuid);
+            exec(cmd, next);
+        },
+
+        /*
+         * Updates initial manatee instance metadata in SAPI
+         */
+        function setSapiONWM(_, next) {
+            var command = util.format(
+                '/opt/smartdc/bin/sdc-sapi /instances/%s ' +
+                '-d \'{"metadata": {"ONE_NODE_WRITE_MODE": true}}\' -X PUT',
+                instances[0].uuid
+            );
+            exec(command, next);
+        },
+
+        /*
+         * Disable manatee-sitter service for all the manatee VMs to remove
+         * so we get them out of the manatee-shard as soon as possible
+         */
+        function disableManateeSitterSvcs(ctx, next) {
+            vasync.forEachPipeline({
+                inputs: ctx.instsToRemove,
+                func: function stopSvc(inst, nextInst) {
+                    var cmd = format('/usr/sbin/zlogin %s ' +
+                        '"svcadm disable manatee-sitter"',
+                        inst.uuid);
+                    exec(cmd, nextInst);
+                }
+            }, next);
+        },
+
+        /*
+         * Disables moray services into local moray instance.
+         * (It obviously has the drawback of assuming a single local
+         * moray instance and no more instances anywyere else)
+         */
+        function disableMoray(_, next) {
+            var cmd = '/usr/sbin/svcadm -z ' +
+                '`/opt/smartdc/bin/sdc-vmname moray` disable \'*moray*\'';
+            exec(cmd, next);
+        },
+
+        function setInstONWM(_, next) {
+            var cmd = format('/usr/sbin/zlogin %s ' +
+                '"source ~/.bashrc; ' +
+                '/opt/smartdc/manatee/node_modules/.bin/manatee-adm ' +
+                'set-onwm -m on -y"',
+                instances[0].uuid);
+            exec(cmd, next);
+        },
+
+        function getSdcZkVersion(ctx, next) {
+            if (!ctx.zkc.isConnected()) {
+                next(new Error('Not connected to Zookeeper'));
+                return;
+            }
+
+            ctx.zkc.stat('/manatee/sdc/state', function (err, stat) {
+                if (err) {
+                    next(err);
+                    return;
+                }
+                ctx.zkVersion = stat.version;
+                next();
+            });
+        },
+
+        function setZkState(ctx, next) {
+            if (!ctx.zkc.isConnected()) {
+                next(new Error('Not connected to Zookeeper'));
+                return;
+            }
+
+            ctx.zkc.set(
+                '/manatee/sdc/state', zkInitialStateRaw, ctx.zkVersion, next);
+        },
+
+        function callManateeConfigAgentSync(_, next) {
+            var cmd = format('/usr/sbin/zlogin %s ' +
+                '"/opt/smartdc/config-agent/build/node/bin/node ' +
+                '/opt/smartdc/config-agent/agent.js -f ' +
+                '/opt/smartdc/config-agent/etc/config.json -s"',
+                instances[0].uuid);
+            exec(cmd, next);
+        },
+
+        // Let's just do not wait for config agent to restart manatee-sitter
+        function restartManateeSitter(_, next) {
+            var cmd = format('/usr/sbin/zlogin %s ' +
+                '"svcadm restart manatee-sitter"',
+                instances[0].uuid);
+            exec(cmd, next);
+        },
+
+        function waitForManatee(_, next) {
+            var cmd = format('/usr/sbin/zlogin %s ' +
+                '"source ~/.bashrc; ' +
+                '/opt/smartdc/manatee/node_modules/.bin/manatee-adm ' +
+                'pg-status -r primary -H -o pg-online"',
+                instances[0].uuid);
+
+            var counter = 0;
+            var limit = 36;
+
+            function _waitForManatee() {
+                counter += 1;
+                exec(cmd, function (err, stdout, stderr) {
+                    if (err) {
+                        next(err);
+                        return;
+                    }
+
+                    var res = stdout.trim();
+                    if (res !== 'ok') {
+                       if (counter < limit) {
+                          setTimeout(_waitForManatee, 5000);
+                       } else {
+                           next(new Error(
+                               'Timeout waiting for manatee-sitter'));
+                       }
+                    } else {
+                        next();
+                    }
+                });
+            }
+            _waitForManatee();
+        },
+
+        function enableMoray(_, next) {
+            var cmd = '/usr/sbin/svcadm -z ' +
+                '`/opt/smartdc/bin/sdc-vmname moray` enable \'*moray*\'';
+            exec(cmd, next);
+        },
+
+
+        function waitForSapiStorAvailable(_, next) {
+            // We're gonna attempt instances deletion, which will not work if
+            // moray backend is not available. Pinging SAPI until that's not
+            // a problem:
+            var cmd = '/opt/smartdc/bin/sdc-sapi /ping|json -H';
+
+            var counter = 0;
+            var limit = 36;
+
+            function _waitForSapi() {
+                counter += 1;
+                exec(cmd, function (err, stdout, stderr) {
+                    if (err) {
+                        next(err);
+                        return;
+                    }
+
+                    var res = JSON.parse(stdout.trim());
+                    if (!res.storAvailable) {
+                       if (counter < limit) {
+                          setTimeout(_waitForSapi, 5000);
+                       } else {
+                           next(new Error(
+                               'Timeout waiting for SAPI to reconnect moray'));
+                       }
+                    } else {
+                        next();
+                    }
+                });
+            }
+            _waitForSapi();
+        },
+
+
+        /*
+         * sdc-sapi /instances/manatee1|manatee2 -X DELETE
+         */
+        function deleteManateeVms(ctx, next) {
+            vasync.forEachPipeline({
+                inputs: ctx.instsToRemove,
+                func: function delInst(inst, nextInst) {
+                    var cmd = 'sdc-sapi /instances/' + inst.uuid +
+                        ' -X DELETE';
+                    exec(cmd, function (err, stdout, stderr) {
+                        if (err) {
+                            nextInst(err);
+                            return;
+                        }
+                        nextInst();
+                    });
+                }
+            }, next);
+        }
+    ];
+
+    vasync.pipeline({
+        arg: context,
+        funcs: [
+            /*
+             * Creates Zk Client and sets it to the variable `ctx.zkc`
+             */
+            function createZkClient(ctx, next) {
+                var zkc = new zkstream.Client({
+                    address: zkHost,
+                    port: 2181,
+                    log: bunyan.createLogger({
+                        name: 'manatee.test',
+                        stream: process.stderr,
+                        level: 'debug'
+                    }),
+                    sessionTimeout: 30000
+                });
+                zkc.once('connect', function () {
+                    next();
+                });
+                zkc.once('failed', function () {
+                    zkc.close(function () {
+                        next(new Error('Zookeeper connection failed'));
+                    });
+                });
+                zkc.once('close', function () {
+                    t.end();
+                });
+
+                ctx.zkc = zkc;
+            },
+
+            /*
+             * Gets `ctx.zkState`, `ctx.zkStateRaw`
+             */
+            function getSdcZkState(ctx, next) {
+                if (!ctx.zkc.isConnected()) {
+                    next(new Error('Not connected to Zookeeper'));
+                    return;
+                }
+
+                ctx.zkc.get('/manatee/sdc/state', function (err, data, _stat) {
+                    if (err) {
+                        next(err);
+                        return;
+                    }
+                    ctx.zkStateRaw = data.toString('ascii');
+                    ctx.zkState = JSON.parse(ctx.zkStateRaw);
+                    next();
+                });
+            },
+
+            function runOnlyWhenNotInONWM(ctx, next) {
+                if (ctx.zkState.oneNodeWriteMode) {
+                    next();
+                    return;
+                }
+
+                vasync.pipeline({
+                    arg: ctx,
+                    funcs: haFuncs
+                }, next);
+            }
+
+        ]
+    }, function pipeCb(pipeErr) {
+        t.ok(context.zkc);
+        t.ifError(pipeErr);
+        context.zkc.close();
+    });
+});
