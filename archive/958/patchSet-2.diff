From 018b5bec3860d19dd69c5435ceb506ab82ecbbe2 Mon Sep 17 00:00:00 2001
From: Jerry Jelinek <jerry.jelinek@joyent.com>
Date: Wed, 30 Nov 2016 22:55:42 +0000
Subject: [PATCH] OS-5805 chromium depends on CLONE_FS w/o full SHARED_AS

---
 usr/src/common/brand/lx/lx_syscall.h          |  30 ++
 usr/src/lib/brand/lx/lx_brand/common/clone.c  |  39 +-
 usr/src/uts/common/brand/lx/os/lx_brand.c     |   7 +-
 usr/src/uts/common/brand/lx/sys/lx_brand.h    |  18 +
 usr/src/uts/common/brand/lx/sys/lx_misc.h     |   6 +-
 .../uts/common/brand/lx/syscall/lx_clone.c    | 503 +++++++++++++++++-
 .../uts/common/brand/lx/syscall/lx_miscsys.c  |  88 +++
 .../uts/common/brand/lx/syscall/lx_umask.c    |  27 +
 usr/src/uts/common/syscall/chdir.c            |  16 +-
 9 files changed, 713 insertions(+), 21 deletions(-)

diff --git a/usr/src/common/brand/lx/lx_syscall.h b/usr/src/common/brand/lx/lx_syscall.h
index 54fb196b5a..063109934f 100644
--- a/usr/src/common/brand/lx/lx_syscall.h
+++ b/usr/src/common/brand/lx/lx_syscall.h
@@ -88,6 +88,36 @@ extern "C" {
 #define	LX_CLONE_DETACH		0x00400000
 #define	LX_CLONE_CHILD_SETTID	0x01000000
 
+#define	SHARED_AS \
+	(LX_CLONE_VM | LX_CLONE_FS | LX_CLONE_FILES | LX_CLONE_SIGHAND | \
+	LX_CLONE_THREAD)
+
+/*
+ * Valid clone flags when not a full process or full thread (SHARED_AS), This
+ * can be expanded as additional clone-group support is added.
+ */
+#define	LX_CLONE_GRP_SUBSET	(LX_CLONE_FS)
+
+#define	LX_IS_CLONE_GRP(X)	((X & SHARED_AS) != 0 && \
+				(X & SHARED_AS) != SHARED_AS && \
+				((X & SHARED_AS) & ~LX_CLONE_GRP_SUBSET) == 0)
+
+typedef struct {
+	int	lcha_flags;
+	pid_t	lcha_ppid;
+	void	*lcha_ptidp;
+	void	*lcha_ldtinfo;
+	void	*lcha_ctidp;
+} lx_clone_helper_arg_t;
+
+typedef struct {
+	int		lcha_flags;
+	pid_t		lcha_ppid;
+	uint32_t	lcha_ptidp;
+	uint32_t	lcha_ldtinfo;
+	uint32_t	lcha_ctidp;
+} lx_clone_helper_arg32_t;
+
 #ifdef	__cplusplus
 }
 #endif
diff --git a/usr/src/lib/brand/lx/lx_brand/common/clone.c b/usr/src/lib/brand/lx/lx_brand/common/clone.c
index 586c042a83..f04a03d86a 100644
--- a/usr/src/lib/brand/lx/lx_brand/common/clone.c
+++ b/usr/src/lib/brand/lx/lx_brand/common/clone.c
@@ -53,10 +53,6 @@
 #include <sys/debug.h>
 #include <lx_syscall.h>
 
-
-#define	SHARED_AS	\
-	(LX_CLONE_VM | LX_CLONE_FS | LX_CLONE_FILES | LX_CLONE_SIGHAND	\
-	    | LX_CLONE_THREAD)
 #define	CLONE_VFORK (LX_CLONE_VM | LX_CLONE_VFORK)
 #define	CLONE_TD (LX_CLONE_THREAD|LX_CLONE_DETACH)
 
@@ -174,6 +170,7 @@ clone_start(void *arg)
 	int rval;
 	struct clone_state *cs = (struct clone_state *)arg;
 	lx_tsd_t *lxtsd;
+	lx_clone_helper_arg_t helper_arg;
 
 	/*
 	 * Let the kernel finish setting up all the needed state for this
@@ -187,8 +184,12 @@ clone_start(void *arg)
 	lx_debug("\tB_HELPER_CLONE(0x%x, 0x%p, 0x%p, 0x%p)",
 	    cs->c_flags, cs->c_ptidp, cs->c_ldtinfo, cs->c_ctidp);
 
-	rval = syscall(SYS_brand, B_HELPER_CLONE, cs->c_flags, cs->c_ptidp,
-	    cs->c_ldtinfo, cs->c_ctidp);
+	helper_arg.lcha_ppid = 0;	/* unused */
+	helper_arg.lcha_flags = cs->c_flags;
+	helper_arg.lcha_ptidp = cs->c_ptidp;
+	helper_arg.lcha_ldtinfo = cs->c_ldtinfo;
+	helper_arg.lcha_ctidp = cs->c_ctidp;
+	rval = syscall(SYS_brand, B_HELPER_CLONE, &helper_arg);
 
 	/*
 	 * At this point the parent is waiting for cs->c_clone_res to go
@@ -309,6 +310,7 @@ lx_clone(uintptr_t p1, uintptr_t p2, uintptr_t p3, uintptr_t p4, uintptr_t p5)
 	int fork_flags = 0;
 	int ptrace_event;
 	lx_tsd_t *lx_tsd = lx_get_tsd();
+	lx_clone_helper_arg_t helper_arg;
 
 	if (flags & LX_CLONE_SETTLS) {
 		lx_debug("lx_clone(flags=0x%x stk=0x%p ptidp=0x%p ldt=0x%p "
@@ -367,10 +369,12 @@ lx_clone(uintptr_t p1, uintptr_t p2, uintptr_t p3, uintptr_t p4, uintptr_t p5)
 	lx_ptrace_clone_begin(ptrace_event, !!(flags & LX_CLONE_PTRACE));
 
 	/*
-	 * Handle a fork(2) operation here.  If this is not a fork, a new
-	 * thread will be created after this block.
+	 * Handle a fork(2) operation here. If this is not a fork, a new
+	 * thread will be created after this block. We can also create a new
+	 * clone-group here (when two or more processes share data represented
+	 * by a subset of the SHARED_AS flags, but not a true thread).
 	 */
-	if (IS_FORK(flags) || IS_VFORK(flags)) {
+	if (IS_FORK(flags) || IS_VFORK(flags) || LX_IS_CLONE_GRP(flags)) {
 		if (flags & LX_CLONE_PARENT) {
 			lx_unsupported("clone(2) only supports CLONE_PARENT "
 			    "for threads.\n");
@@ -380,6 +384,8 @@ lx_clone(uintptr_t p1, uintptr_t p2, uintptr_t p3, uintptr_t p4, uintptr_t p5)
 		if ((flags & LX_CSIGNAL) == 0)
 			fork_flags |= FORK_NOSIGCHLD;
 
+		helper_arg.lcha_ppid = getpid();
+
 		/*
 		 * Suspend signal delivery, run the stack management prefork
 		 * handler and perform the actual fork(2) operation.
@@ -485,8 +491,13 @@ lx_clone(uintptr_t p1, uintptr_t p2, uintptr_t p3, uintptr_t p4, uintptr_t p5)
 		 * Set up additional data in the lx_proc_data structure as
 		 * necessary.
 		 */
-		if ((rval = syscall(SYS_brand, B_HELPER_CLONE, flags, ptidp,
-		    ldtinfo, ctidp)) < 0) {
+		/* helper_arg.lcha_ppid set above */
+		helper_arg.lcha_flags = flags;
+		helper_arg.lcha_ptidp = ptidp;
+		helper_arg.lcha_ldtinfo = ldtinfo;
+		helper_arg.lcha_ctidp = ctidp;
+		rval = syscall(SYS_brand, B_HELPER_CLONE, &helper_arg);
+		if (rval < 0) {
 			return (rval);
 		}
 
@@ -571,11 +582,11 @@ lx_clone(uintptr_t p1, uintptr_t p2, uintptr_t p3, uintptr_t p4, uintptr_t p5)
 	}
 
 	/*
-	 * We have very restricted support.... only exactly these flags are
-	 * supported
+	 * A supported clone-group was handled above, so now it must be a
+	 * true native thread, which means exactly these flags are supported
 	 */
 	if (((flags & SHARED_AS) != SHARED_AS)) {
-		lx_unsupported("clone(2) requires that all or none of "
+		lx_unsupported("clone(2) a thread requires that all or none of "
 		    "CLONE_VM/FS/FILES/THREAD/SIGHAND be set. (flags:0x%08X)\n",
 		    flags);
 		return (-ENOTSUP);
diff --git a/usr/src/uts/common/brand/lx/os/lx_brand.c b/usr/src/uts/common/brand/lx/os/lx_brand.c
index fbca57a418..beb2884d6d 100644
--- a/usr/src/uts/common/brand/lx/os/lx_brand.c
+++ b/usr/src/uts/common/brand/lx/os/lx_brand.c
@@ -206,6 +206,8 @@ extern void lx_ioctl_fini();
 extern void lx_socket_init();
 extern void lx_socket_fini();
 
+extern void lx_clone_grp_exit(proc_t *);
+
 lx_systrace_f *lx_systrace_entry_ptr;
 lx_systrace_f *lx_systrace_return_ptr;
 
@@ -333,6 +335,8 @@ lx_proc_exit(proc_t *p)
 	lx_proc_data_t *lxpd;
 	proc_t *cp;
 
+	lx_clone_grp_exit(p);
+
 	mutex_enter(&p->p_lock);
 	VERIFY((lxpd = ptolxproc(p)) != NULL);
 	VERIFY(lxpd->l_ptrace == 0);
@@ -1604,8 +1608,7 @@ lx_brandsys(int cmd, int64_t *rval, uintptr_t arg1, uintptr_t arg2,
 	}
 
 	case B_HELPER_CLONE:
-		return (lx_helper_clone(rval, arg1, (void *)arg2, (void *)arg3,
-		    (void *)arg4));
+		return (lx_helper_clone(rval, (void *)arg1));
 
 	case B_HELPER_SETGROUPS:
 		return (lx_helper_setgroups(arg1, (gid_t *)arg2));
diff --git a/usr/src/uts/common/brand/lx/sys/lx_brand.h b/usr/src/uts/common/brand/lx/sys/lx_brand.h
index 959e84b0a0..677ba4a52e 100644
--- a/usr/src/uts/common/brand/lx/sys/lx_brand.h
+++ b/usr/src/uts/common/brand/lx/sys/lx_brand.h
@@ -295,6 +295,21 @@ typedef struct {
 	uint64_t	rlim_max;
 } lx_rlimit64_t;
 
+typedef struct {
+	list_node_t	lx_clgrpm_link;
+	proc_t		*lx_clgrpm_pp;
+} lx_clone_grp_member_t;
+
+typedef struct {
+	kmutex_t	lx_clgrp_lock;	/* protects cnt & member list */
+	int		lx_clgrp_cnt;
+	list_t		*lx_clgrp_members;
+} lx_clone_grp_t;
+
+/* Entries in the l_clone_grps clone-group array */
+#define	LX_CLGRP_FS	0
+#define	LX_CLGRP_MAX	1
+
 typedef struct lx_proc_data {
 	uintptr_t l_handler;	/* address of user-space handler */
 	pid_t l_ppid;		/* pid of originating parent proc */
@@ -307,6 +322,9 @@ typedef struct lx_proc_data {
 	int l_parent_deathsig;
 	lx_proc_flags_t l_flags;
 
+	kmutex_t l_clone_grp_lock; /* protects the following member */
+	lx_clone_grp_t *l_clone_grps[LX_CLGRP_MAX];
+
 	lx_rlimit64_t l_fake_limits[LX_RLFAKE_NLIMITS];
 
 	/* original start/end bounds of arg/env string data */
diff --git a/usr/src/uts/common/brand/lx/sys/lx_misc.h b/usr/src/uts/common/brand/lx/sys/lx_misc.h
index af073c3f5f..e217b8b27d 100644
--- a/usr/src/uts/common/brand/lx/sys/lx_misc.h
+++ b/usr/src/uts/common/brand/lx/sys/lx_misc.h
@@ -44,6 +44,10 @@ extern void lx_clear_gdt(int);
 
 extern longlong_t lx_nosys();
 
+extern boolean_t lx_clone_grp_member(lx_proc_data_t *, uint_t);
+extern int lx_clone_grp_walk(lx_proc_data_t *, uint_t,
+    int (*)(proc_t *, void *), void *);
+
 extern greg_t lx_fixsegreg(greg_t, model_t);
 extern uintptr_t lx_fsbase(klwp_t *, uintptr_t);
 extern void lx_exit_with_sig(proc_t *, sigqueue_t *);
@@ -102,7 +106,7 @@ extern int lx_sigcld_repost(proc_t *, sigqueue_t *);
 extern int lx_ptrace_issig_stop(proc_t *, klwp_t *);
 extern boolean_t lx_ptrace_sig_ignorable(proc_t *, klwp_t *, int);
 
-extern int lx_helper_clone(int64_t *, int, void *, void *, void *);
+extern int lx_helper_clone(int64_t *, void *);
 extern int lx_helper_setgroups(int, gid_t *);
 extern int lx_helper_rt_sigqueueinfo(pid_t, int, siginfo_t *);
 extern int lx_helper_rt_tgsigqueueinfo(pid_t, pid_t, int, siginfo_t *);
diff --git a/usr/src/uts/common/brand/lx/syscall/lx_clone.c b/usr/src/uts/common/brand/lx/syscall/lx_clone.c
index 50cdeaeab9..e3a4e59931 100644
--- a/usr/src/uts/common/brand/lx/syscall/lx_clone.c
+++ b/usr/src/uts/common/brand/lx/syscall/lx_clone.c
@@ -21,9 +21,107 @@
 /*
  * Copyright 2006 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
- * Copyright 2015 Joyent, Inc.
+ * Copyright 2016 Joyent, Inc.
  */
 
+/*
+ * The vast majority of clone calls are for either the creation of a new
+ * process or for a new thread. Both of these map easily from Linux to our
+ * native code. For these calls, the user-level brand library uses a brand
+ * call to hook into the lx_helper_clone function for the required in-kernel
+ * support.
+ *
+ * Unfortunately, clone can also be called with a subset of the LX_CLONE_*
+ * flags. This does not map directly to our native code and requires special
+ * handling in the brand code itself. The rest of this description omits the
+ * 'LX_' prefix on the clone flag names.
+ *
+ * A fork will provide these clone flags:
+ *    CLONE_CHILD_SETTID | CLONE_CHILD_CLEARTID
+ *
+ * A new thread will use our SHARED_AS macro which has the flags:
+ *     CLONE_FILES | CLONE_FS | CLONE_SIGHAND | CLONE_THREAD |  CLONE_VM
+ *
+ * However, in rare cases an application will attempt to use a subset of the
+ * SHARED_AS flags in order to implement some sharing between two processes
+ * without using a true thread. Because we do not have native support for this
+ * concept, the lx brand implements the notion of a 'clone-group'. This is a
+ * set of processes which share a subset of the allowed SHARED_AS flags. The
+ * lx brand syscalls implement the appropriate sharing for each flag. A
+ * clone-group is only instantiated in the rare case that a subset of the
+ * SHARED_AS flags are used with clone.
+ *
+ * The following set of flags could theoretically be supported, although most
+ * are not implemented at this time. The user-level brand library will validate
+ * that a supported subset of the flags is being used, or error if not. We
+ * also re-validate in the kernel.
+ *
+ * CLONE_FILES:	share the file descriptor table
+ * CLONE_FS:	share the filesystem information (root of the filesystem, the
+ *		CWD, and the umask)
+ * CLONE_SIGHAND: share the table of signal handlers
+ * CLONE_THREAD: share the thread group
+ * CLONE_VM:	share the address space
+ *
+ * At this time, only those flags in CLONE_GRP_SUBSET are implemented.
+ *
+ * When a clone-group is in use, the lx_proc_data_t`l_clone_grps array will
+ * hold groups of processes sharing some information. Each supported flag
+ * can have an associated group list in the array.
+ *
+ * On the first clone, a new lx_clone_grp_t struct will be created. This struct
+ * holds a pointer to each process in the group. A reference to that group is
+ * held in the appropriate slot in l_clone_grps.
+ *
+ * Each syscall which requires it must implement the appropriaate clone-group
+ * support. The syscalls will use lx_clone_grp_member() to determine if
+ * clone-group handling is required, and use lx_clone_grp_walk() to walk the
+ * list of processes in the group and apply the provided callback to each
+ * process.
+ *
+ * The following example illustrate how a common clone group would be used,
+ * as processes clone with the same set of CLONE_* flags.
+ *	A clones B with CLONE_FS
+ *	B clones C with CLONE_FS
+ * When A clones B, a new clone group is created and saved in the LX_CLGRP_FS
+ * slot in the l_clone_grps array on both A and B. When B clones, since a group
+ * already exists, C is added to the group and the group is saved in the
+ * LX_CLGRP_FS slot on C.
+ *
+ * The following example illustrate how two common clone groups would be used,
+ * as processes clone with the same set of CLONE_* flags.
+ *	A clones B with CLONE_FS|CLONE_THREAD
+ * A new clone group is created and saved in the LX_CLGRP_FS slot in the
+ * l_clone_grps array on both A and B. A second clone group is created and
+ * saved in the LX_CLGRP_THREAD slot on both A and B (note that LX_CLGRP_THREAD
+ * is not implemented at this time).
+ *
+ * The following example illustrate how different clone groups would be used,
+ * as processes clone with different sets of CLONE_* flags.
+ *	A clones B with CLONE_FS
+ *	B clones C with CLONE_THREAD
+ *	C clones D with CLONE_FS
+ * In this example, only A&B and C&D should share their FS information. B&C
+ * have to be in two clone groups. When A clones, a new clone group is created
+ * and saved in the LX_CLGRP_FS slot in the l_clone_grps array on both A and B.
+ * When B clones, a new clone group is created and saved in the LX_CLGRP_THREAD
+ * slot on both B and C (note that LX_CLGRP_THREAD is not implemented at this
+ * time). When C clones, a new clone group is created and saved in the
+ * LX_CLGRP_FS slot on both C and D.
+ *
+ * When a process exits, it removes itself from the group. When there is one
+ * process left in the group, the group itself is removed and the appropriate
+ * slot in l_clone_grps is cleared on the remaining process.
+ *
+ * If clone-groups were commonly used, this implementation would be inefficient
+ * and unwieldy, but since they are so rare a straightforward list-based
+ * approach is adequate.
+ *
+ * Lock ordering for manipulating the clone-group pointers and list:
+ * child l_clone_grp_lock -> parent l_clone_grp_lock -> group's lx_clgrp_lock
+ */
+
+
 #include <sys/types.h>
 #include <sys/systm.h>
 #include <sys/errno.h>
@@ -36,6 +134,352 @@
 #include <sys/x86_archext.h>
 #include <sys/controlregs.h>
 
+/*
+ * We currently only support a single clone-group (CLONE_FS) but the design
+ * allows for future expansion by expanding the lx_proc_data+t`l_clone_grps
+ * array.
+ */
+static int
+lx_clone_flag2grp(int flag)
+{
+	if (flag & LX_CLONE_FS)
+		return (LX_CLGRP_FS);
+
+	return (-1);
+}
+
+static int
+lx_clone_flags_iter(int *fp)
+{
+	if (*fp & LX_CLONE_FS) {
+		*fp &= ~LX_CLONE_FS;
+		return (LX_CLGRP_FS);
+	}
+
+	return (-1);
+}
+
+/*
+ * Setup the current process and its parent in the proper clone-group(s)
+ * together.
+ */
+static int
+lx_clone_grp_enter(int flags, pid_t ppid)
+{
+	int offset;
+	lx_proc_data_t *clproc = ttolxproc(curthread);
+	lx_proc_data_t *plproc;
+	proc_t *pp;
+	lx_clone_grp_t **cgps;
+	lx_clone_grp_t *cgp;
+	lx_clone_grp_member_t *mp;
+
+	mutex_enter(&pidlock);
+
+	pp = ttoproc(curthread)->p_parent;
+	plproc = ptolxproc(pp);
+
+	if (plproc == NULL) {
+		/*
+		 * Somehow parent is not branded. Although this shouldn't
+		 * happen, it might theoretically occur if the parent already
+		 * exited and we got reparented to a non-branded process
+		 * (although the init process in the zone should be branded).
+		 * Bail out if this ever happens.
+		 */
+		mutex_exit(&pidlock);
+		return (0);
+	}
+
+	/*
+	 * It is possible for the parent to exit before the child gets a chance
+	 * to setup the clone-group(s). A well-behaved application will
+	 * explicitly depend on both processes co-existing, but we don't want a
+	 * parent which exits prematurely to cause this child to be in a
+	 * clone-group with the init process that the child got reparented to.
+	 * Before the parent forked, we recorded its pid, so now we can
+	 * validate that the original parent is still our parent.
+	 */
+	if (ppid != pp->p_pid) {
+		mutex_exit(&pidlock);
+		return (0);
+	}
+
+	/* Check if parent is exiting or zombie and return */
+	if (((pp->p_flag & SEXITING) || pp->p_stat == SZOMB)) {
+		mutex_exit(&pidlock);
+		return (0);
+	}
+
+	mutex_enter(&clproc->l_clone_grp_lock);
+	mutex_enter(&plproc->l_clone_grp_lock);
+	mutex_exit(&pidlock);
+
+	cgps = plproc->l_clone_grps;
+
+	while ((offset = lx_clone_flags_iter(&flags)) != -1) {
+		cgp = cgps[offset];
+
+		/*
+		 * If parent already has a clone-group list for this flag, the
+		 * child joins the group, otherwise create a group and place
+		 * both processes into the group.
+		 */
+		if (cgp != NULL) {
+			mp = kmem_zalloc(sizeof (lx_clone_grp_member_t),
+			    KM_SLEEP);
+			mp->lx_clgrpm_pp = curproc;
+
+			mutex_enter(&cgp->lx_clgrp_lock);
+			list_insert_tail(cgp->lx_clgrp_members, mp);
+			cgp->lx_clgrp_cnt++;
+			mutex_exit(&cgp->lx_clgrp_lock);
+
+			continue;
+		}
+
+		/* Create a new clone-group and add both processes */
+		cgp = kmem_alloc(sizeof (lx_clone_grp_t), KM_SLEEP);
+		mutex_init(&cgp->lx_clgrp_lock, NULL, MUTEX_DEFAULT, NULL);
+		cgp->lx_clgrp_cnt = 2;
+		cgp->lx_clgrp_members = kmem_alloc(sizeof (list_t), KM_SLEEP);
+		list_create(cgp->lx_clgrp_members,
+		    sizeof (lx_clone_grp_member_t),
+		    offsetof(lx_clone_grp_member_t, lx_clgrpm_link));
+
+		/*
+		 * The list isn't attached to either process yet; mutex not
+		 * needed.
+		 */
+
+		mp = kmem_zalloc(sizeof (lx_clone_grp_member_t), KM_SLEEP);
+		mp->lx_clgrpm_pp = pp;
+		list_insert_tail(cgp->lx_clgrp_members, mp);
+
+		mp = kmem_zalloc(sizeof (lx_clone_grp_member_t), KM_SLEEP);
+		mp->lx_clgrpm_pp = curproc;
+		list_insert_tail(cgp->lx_clgrp_members, mp);
+
+		/* Attach group to both processes */
+		mutex_enter(&cgp->lx_clgrp_lock);
+		plproc->l_clone_grps[offset] = clproc->l_clone_grps[offset] =
+		    cgp;
+		mutex_exit(&cgp->lx_clgrp_lock);
+	}
+
+	mutex_exit(&plproc->l_clone_grp_lock);
+	mutex_exit(&clproc->l_clone_grp_lock);
+	return (0);
+}
+
+/*
+ * The process is exiting, in the unlikely event it is in a clone-group, remove
+ * it from the group and perform any necessary cleanup.
+ *
+ * Note that there is some locking complexity here since some other process in
+ * the group might be in any state, including in the middle of walking the
+ * group itself, while we're working on exiting. While a process is walking the
+ * group, there can be all sorts of locking activity taking place for the
+ * callbacks on each process in the group (e.g. pidlock, p_lock, etc).
+ */
+void
+lx_clone_grp_exit(proc_t *p)
+{
+	int i;
+	lx_proc_data_t *plproc = ptolxproc(p);
+	lx_clone_grp_t **cgps;
+
+	ASSERT(!MUTEX_HELD(&pidlock));
+	ASSERT(!MUTEX_HELD(&p->p_lock));
+	ASSERT(plproc != NULL);
+
+	mutex_enter(&plproc->l_clone_grp_lock);
+	cgps = plproc->l_clone_grps;
+	for (i = 0; i < LX_CLGRP_MAX; i++) {
+		lx_clone_grp_t *cgp;
+		lx_clone_grp_member_t *mp;
+		boolean_t found;
+
+		cgp = cgps[i];
+		if (cgp == NULL)
+			continue;
+
+		/*
+		 * The rare case when this process belongs to a clone-group.
+		 *
+		 * Although we're exiting, we're holding our l_clone_grp_lock
+		 * here in case one of our children is still in the middle of
+		 * the shared clone and intends to manipulate the group list.
+		 */
+
+		mutex_enter(&cgp->lx_clgrp_lock);
+
+		/* First remove ourselves from the group. */
+		found = B_FALSE;
+		mp = list_head(cgp->lx_clgrp_members);
+		while (mp != NULL) {
+			if (mp->lx_clgrpm_pp == p) {
+				found = B_TRUE;
+				list_remove(cgp->lx_clgrp_members, mp);
+				kmem_free(mp, sizeof (lx_clone_grp_member_t));
+				ASSERT(cgp->lx_clgrp_cnt > 0);
+				cgp->lx_clgrp_cnt--;
+				plproc->l_clone_grps[i] = NULL;
+				break;
+			}
+			mp = list_next(cgp->lx_clgrp_members, mp);
+		}
+		VERIFY(found);
+
+		if (cgp->lx_clgrp_cnt > 1) {
+			mutex_exit(&cgp->lx_clgrp_lock);
+			continue;
+		}
+
+		if (cgp->lx_clgrp_cnt == 1) {
+			/*
+			 * There is only one process left in the group. We want
+			 * to cleanup but we can't do this while only holding
+			 * lx_clgrp_lock since the remaining process could be
+			 * in any kind of locking state (most importantly, it's
+			 * l_clone_grp_lock might be held and waiting for
+			 * the lx_clgrp_lock). We'll reacquire the locks in the
+			 * proper order to cleanup.
+			 *
+			 * The remaining proc can't exit while we're holding
+			 * lx_clgrp_lock.
+			 */
+			proc_t *tp;
+			lx_proc_data_t *tplproc;
+
+			VERIFY((mp = list_head(cgp->lx_clgrp_members)) != NULL);
+
+			tp = mp->lx_clgrpm_pp;
+
+			/*
+			 * If someone is already holding that process's
+			 * l_clone_grp_lock and waiting for the lx_clgrp_lock,
+			 * then we need to drop the lx_clgrp_lock and leave that
+			 * process to clean itself up later when it exits.
+			 */
+			VERIFY((tplproc = ptolxproc(tp)) != NULL);
+			if (mutex_tryenter(&tplproc->l_clone_grp_lock) == 0) {
+				/*
+				 * We'll have to leave that proc in the group
+				 * by itself. It will cleanup the group when it
+				 * exits.
+				 */
+				mutex_exit(&cgp->lx_clgrp_lock);
+				continue;
+			}
+
+			/*
+			 * Continue to hold lx_clgrp_lock along with the
+			 * l_clone_grp_lock from the final process in the group.
+			 */
+			ASSERT(tplproc->l_clone_grps[i] == cgp);
+
+			/*
+			 * It's now safe to remove that group from the process
+			 * and no one can find the group after this.
+			 */
+			tplproc->l_clone_grps[i] = NULL;
+			mutex_exit(&cgp->lx_clgrp_lock);
+			mutex_exit(&tplproc->l_clone_grp_lock);
+
+			list_remove(cgp->lx_clgrp_members, mp);
+			kmem_free(mp, sizeof (lx_clone_grp_member_t));
+		} else {
+			/*
+			 * cgp->lx_clgrp_cnt == 0
+			 *
+			 * There was an earlier race in group exit by another
+			 * proc which left us as the sole member; finish
+			 * cleanup now. Note that we have to keep holding
+			 * our own l_clone_grp_lock throughout this loop.
+			 */
+			ASSERT(plproc->l_clone_grps[i] == NULL);
+			mutex_exit(&cgp->lx_clgrp_lock);
+		}
+
+		/*
+		 * Finish cleaning up the group since there are no more
+		 * references to it.
+		 */
+		VERIFY(list_is_empty(cgp->lx_clgrp_members));
+
+		list_destroy(cgp->lx_clgrp_members);
+		kmem_free(cgp->lx_clgrp_members, sizeof (list_t));
+		mutex_destroy(&cgp->lx_clgrp_lock);
+		kmem_free(cgp, sizeof (lx_clone_grp_t));
+	}
+
+	mutex_exit(&plproc->l_clone_grp_lock);
+}
+
+/*
+ * Return true in the rare case that the process is a member of a clone group
+ * with the specific flag set. In that case we return with the process's
+ * l_clone_grp_lock held.
+ */
+boolean_t
+lx_clone_grp_member(lx_proc_data_t *dp, uint_t flag)
+{
+	int offset;
+
+	if ((offset = lx_clone_flag2grp(flag)) == -1)
+		return (B_FALSE);
+
+	mutex_enter(&dp->l_clone_grp_lock);
+	if (dp->l_clone_grps[offset] != NULL) {
+		return (B_TRUE);
+	}
+
+	mutex_exit(&dp->l_clone_grp_lock);
+	return (B_FALSE);
+}
+
+/*
+ * Walk all of the processes in the clone-group list and apply the callback
+ * to each. Because we're holding the group list lock (lx_clgrp_lock) none of
+ * the processes can exit, but that is the only locking guarantee made by this
+ * function itself.
+ */
+int
+lx_clone_grp_walk(lx_proc_data_t *dp, uint_t flag, int (*cb)(proc_t *, void *),
+    void *arg)
+{
+	int offset;
+	lx_clone_grp_t *cgp;
+	lx_clone_grp_member_t *mp;
+	int res, rv = 0;
+
+
+	ASSERT(dp != NULL);
+	ASSERT(MUTEX_HELD(&dp->l_clone_grp_lock));
+	/* We should not be called unless we belong to a group */
+	VERIFY((offset = lx_clone_flag2grp(flag)) != -1);
+	VERIFY(dp->l_clone_grps[offset] != NULL);
+
+	cgp = dp->l_clone_grps[offset];
+	mutex_enter(&cgp->lx_clgrp_lock);
+
+	mp = list_head(cgp->lx_clgrp_members);
+	while (mp != NULL) {
+		res = cb(mp->lx_clgrpm_pp, arg);
+		/* return the first error we see, but try all procs */
+		if (res != 0 && rv == 0)
+			rv = res;
+		mp = list_next(cgp->lx_clgrp_members, mp);
+	}
+
+	mutex_exit(&cgp->lx_clgrp_lock);
+	mutex_exit(&dp->l_clone_grp_lock);
+
+	return (rv);
+}
+
+
 /*
  * Our lwp has already been created at this point, so this routine is
  * responsible for setting up all the state needed to track this as a
@@ -43,8 +487,15 @@
  */
 /* ARGSUSED */
 int
-lx_helper_clone(int64_t *rval, int flags, void *ptidp, void *tls, void *ctidp)
+lx_helper_clone(int64_t *rval, void *args)
 {
+	/* decoded args - initialized due to ifdef below */
+	int flags = 0;
+	void *ptidp = NULL;
+	void *tls = NULL;
+	void *ctidp = NULL;
+	pid_t ppid = 0;
+
 	struct lx_lwp_data *lwpd = ttolxlwp(curthread);
 	struct lx_proc_data *lproc = ttolxproc(curthread);
 	struct ldt_info info;
@@ -53,6 +504,41 @@ lx_helper_clone(int64_t *rval, int flags, void *ptidp, void *tls, void *ctidp)
 	int entry = -1;
 	int signo;
 
+	if (curproc->p_model == DATAMODEL_NATIVE) {
+		lx_clone_helper_arg_t helper_args;
+
+		if (copyin(args, &helper_args, sizeof (helper_args)) != 0) {
+			lx_print("Failed to copyin brand registration "
+			    "at 0x%p\n", args);
+			return (EFAULT);
+		}
+
+		flags = helper_args.lcha_flags;
+		ppid = helper_args.lcha_ppid;
+		ptidp = helper_args.lcha_ptidp;
+		tls = helper_args.lcha_ldtinfo;
+		ctidp = helper_args.lcha_ctidp;
+	}
+#ifdef _LP64
+	else {
+		/* 32-bit userland on 64-bit kernel */
+		lx_clone_helper_arg32_t helper_args32;
+
+		if (copyin(args, &helper_args32, sizeof (helper_args32)) != 0) {
+			lx_print("Failed to copyin brand registration "
+			    "at 0x%p\n", args);
+			return (EFAULT);
+		}
+
+		flags = helper_args32.lcha_flags;
+		ppid = helper_args32.lcha_ppid;
+		ptidp = (void *)(uintptr_t)helper_args32.lcha_ptidp;
+		tls = (void *)(uintptr_t)helper_args32.lcha_ldtinfo;
+		ctidp = (void *)(uintptr_t)helper_args32.lcha_ctidp;
+	}
+#endif
+
+
 	signo = flags & LX_CSIGNAL;
 	if (signo < 0 || signo > LX_NSIG)
 		return (set_errno(EINVAL));
@@ -121,6 +607,19 @@ lx_helper_clone(int64_t *rval, int flags, void *ptidp, void *tls, void *ctidp)
 		}
 	}
 
+	/*
+	 * Check if we have non-standard flags for clone (i.e. not a pure
+	 * thread or process).
+	 */
+	if (LX_IS_CLONE_GRP(flags)) {
+		if (lx_clone_grp_enter(flags & LX_CLONE_GRP_SUBSET, ppid)
+		    != 0) {
+			if (entry >= 0)
+				lx_clear_gdt(entry);
+			return (set_errno(EINVAL));
+		}
+	}
+
 	*rval = lwpd->br_pid;
 	return (0);
 }
diff --git a/usr/src/uts/common/brand/lx/syscall/lx_miscsys.c b/usr/src/uts/common/brand/lx/syscall/lx_miscsys.c
index 87bb9bde1b..0d25c95e24 100644
--- a/usr/src/uts/common/brand/lx/syscall/lx_miscsys.c
+++ b/usr/src/uts/common/brand/lx/syscall/lx_miscsys.c
@@ -18,6 +18,7 @@
 #include <sys/resource.h>
 #include <sys/uadmin.h>
 #include <sys/lx_misc.h>
+#include <lx_syscall.h>
 
 #define	LINUX_REBOOT_MAGIC1		0xfee1dead
 #define	LINUX_REBOOT_MAGIC2		672274793
@@ -68,6 +69,19 @@ extern int getitimer(uint_t, struct itimerval *);
 extern int stime(time_t);
 /* From uts/common/syscall/uadmin.c */
 extern int uadmin(int, int, uintptr_t);
+/* From uts/common/syscall/chdir.c */
+extern int chdir_proc(proc_t *, vnode_t *, int, int);
+/* From uts/common/fs/lookup.c */
+extern int lookupname(char *, enum uio_seg, int, vnode_t **, vnode_t **);
+/* From uts/common/fs/fs_subr.c */
+extern int fs_need_estale_retry(int);
+
+/* The callback arguments when handling a FS clone group. */
+typedef struct {
+	vnode_t	*lcfa_vp;
+	int	lcfa_type;
+	int	lcfa_cnt;
+} lx_clone_fs_arg_t;
 
 long
 lx_alarm(int seconds)
@@ -75,15 +89,89 @@ lx_alarm(int seconds)
 	return (alarm(seconds));
 }
 
+static int
+lx_clone_fs_cb(proc_t *pp, void *arg)
+{
+	lx_clone_fs_arg_t *ap = (lx_clone_fs_arg_t *)arg;
+	int err;
+
+	/*
+	 * The initial lookupname() from lx_clone_fs_do_group() will have added
+	 * a hold on the vnode. That accounts for the first process in the
+	 * group, but we need to add another hold for each additional process.
+	 */
+	if (ap->lcfa_cnt++ > 0)
+		VN_HOLD(ap->lcfa_vp);
+	if ((err = chdir_proc(pp, ap->lcfa_vp, ap->lcfa_type, 1)) != 0) {
+		/* if we failed, chdir_proc already did a rele on vp */
+		return (err);
+	}
+
+	return (0);
+}
+
+/*
+ * Check to see if the process is in a CLONE_FS clone group. Return false
+ * if not (the normal case), otherwise perform the setup, do the group walk
+ * and return true.
+ */
+static boolean_t
+lx_clone_fs_do_group(char *path, int is_chroot, int *errp)
+{
+	lx_proc_data_t *lproc = ttolxproc(curthread);
+	vnode_t *vp;
+	lx_clone_fs_arg_t arg;
+	int err;
+	int estale_retry = 0;
+
+	if (!lx_clone_grp_member(lproc, LX_CLONE_FS))
+		return (B_FALSE);
+
+	/* Handle the rare case of being in a CLONE_FS clone group */
+
+retry:
+	err = lookupname(path, UIO_USERSPACE, FOLLOW, NULLVPP, &vp);
+	if (err != 0) {
+		if (err == ESTALE && fs_need_estale_retry(estale_retry++))
+			goto retry;
+		*errp = err;
+		return (B_TRUE);
+	}
+
+	arg.lcfa_vp = vp;
+	arg.lcfa_type = is_chroot;
+	arg.lcfa_cnt = 0;
+
+	/* Take an extra hold to guarantee vp exists for entire walk. */
+	VN_HOLD(vp);
+	err = lx_clone_grp_walk(lproc, LX_CLONE_FS, lx_clone_fs_cb,
+	    (void *)&arg);
+	VN_RELE(vp);
+	*errp = err;
+	return (B_TRUE);
+}
+
 long
 lx_chdir(char *path)
 {
+	int err;
+
+	/* Handle the rare case of being in a CLONE_FS clone group */
+	if (lx_clone_fs_do_group(path, 0, &err))
+		return ((err != 0) ? set_errno(err) : 0);
+
 	return (chdir(path));
 }
 
 long
 lx_chroot(char *path)
 {
+	int err;
+
+	/* Handle the rare case of being in a CLONE_FS clone group */
+	if (lx_clone_fs_do_group(path, 1, &err))
+		return ((err != 0) ? set_errno(err) : 0);
+
 	return (chroot(path));
 }
 
diff --git a/usr/src/uts/common/brand/lx/syscall/lx_umask.c b/usr/src/uts/common/brand/lx/syscall/lx_umask.c
index 130af6c776..cb5e4ed232 100644
--- a/usr/src/uts/common/brand/lx/syscall/lx_umask.c
+++ b/usr/src/uts/common/brand/lx/syscall/lx_umask.c
@@ -14,12 +14,39 @@
  */
 
 #include <sys/types.h>
+#include <sys/lx_misc.h>
+#include <lx_syscall.h>
 
 /* From usr/src/uts/common/syscall/umask.c */
 extern int umask(int);
 
+/*
+ * Just do what umask() does, but for the given process.
+ */
+static int
+lx_clone_umask_cb(proc_t *pp, void *arg)
+{
+	mode_t cmask = (mode_t)(intptr_t)arg;
+	mode_t orig;
+
+	orig = PTOU(pp)->u_cmask;
+	PTOU(pp)->u_cmask = (mode_t)(cmask & PERMMASK);
+	return ((int)orig);
+}
+
 long
 lx_umask(mode_t cmask)
 {
+	lx_proc_data_t *lproc = ttolxproc(curthread);
+
+	/* Handle the rare case of being in a CLONE_FS clone group */
+	if (lx_clone_grp_member(lproc, LX_CLONE_FS)) {
+		int omask;
+
+		omask = lx_clone_grp_walk(lproc, LX_CLONE_FS, lx_clone_umask_cb,
+		    (void *)(intptr_t)cmask);
+		return (omask);
+	}
+
 	return (umask(cmask));
 }
diff --git a/usr/src/uts/common/syscall/chdir.c b/usr/src/uts/common/syscall/chdir.c
index 84c924f570..ac4fa05dd6 100644
--- a/usr/src/uts/common/syscall/chdir.c
+++ b/usr/src/uts/common/syscall/chdir.c
@@ -21,6 +21,7 @@
 /*
  * Copyright 2010 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
+ * Copyright 2016 Joyent, Inc.
  */
 
 /*	Copyright (c) 1983, 1984, 1985, 1986, 1987, 1988, 1989 AT&T	*/
@@ -159,11 +160,10 @@ fchroot(int fd)
 }
 
 static int
-chdirec(vnode_t *vp, int ischroot, int do_traverse)
+chdirec_common(proc_t *pp, vnode_t *vp, int ischroot, int do_traverse)
 {
 	int error;
 	vnode_t *oldvp;
-	proc_t *pp = curproc;
 	vnode_t **vpp;
 	refstr_t *cwd;
 	int newcwd = 1;
@@ -243,3 +243,15 @@ bad:
 	VN_RELE(vp);
 	return (error);
 }
+
+int
+chdir_proc(proc_t *pp, vnode_t *vp, int ischroot, int do_traverse)
+{
+	return (chdirec_common(pp, vp, ischroot, do_traverse));
+}
+
+static int
+chdirec(vnode_t *vp, int ischroot, int do_traverse)
+{
+	return (chdirec_common(curproc, vp, ischroot, do_traverse));
+}
-- 
2.21.0

