From 62f7ba840dccbea780539f5114d55ed70c748445 Mon Sep 17 00:00:00 2001
From: Jerry Jelinek <jerry.jelinek@joyent.com>
Date: Mon, 28 Nov 2016 23:39:14 +0000
Subject: [PATCH] OS-5805 chromium depends on CLONE_FS w/o full SHARED_AS

---
 usr/src/common/brand/lx/lx_syscall.h          |  14 +
 usr/src/lib/brand/lx/lx_brand/common/clone.c  |  18 +-
 usr/src/uts/common/brand/lx/os/lx_brand.c     |   4 +
 usr/src/uts/common/brand/lx/os/lx_misc.c      |   3 +
 usr/src/uts/common/brand/lx/sys/lx_brand.h    |  16 +
 usr/src/uts/common/brand/lx/sys/lx_misc.h     |   4 +
 .../uts/common/brand/lx/syscall/lx_clone.c    | 403 +++++++++++++++++-
 .../uts/common/brand/lx/syscall/lx_miscsys.c  |  59 +++
 .../uts/common/brand/lx/syscall/lx_umask.c    |  27 ++
 usr/src/uts/common/syscall/chdir.c            |  16 +-
 10 files changed, 551 insertions(+), 13 deletions(-)

diff --git a/usr/src/common/brand/lx/lx_syscall.h b/usr/src/common/brand/lx/lx_syscall.h
index 54fb196b5a..a0292023a0 100644
--- a/usr/src/common/brand/lx/lx_syscall.h
+++ b/usr/src/common/brand/lx/lx_syscall.h
@@ -88,6 +88,20 @@ extern "C" {
 #define	LX_CLONE_DETACH		0x00400000
 #define	LX_CLONE_CHILD_SETTID	0x01000000
 
+#define	SHARED_AS \
+	(LX_CLONE_VM | LX_CLONE_FS | LX_CLONE_FILES | LX_CLONE_SIGHAND | \
+	LX_CLONE_THREAD)
+
+/*
+ * Valid clone flags when not a full process or full thread (SHARED_AS), This
+ * can be expanded as additional clone-group support is added.
+ */
+#define	LX_CLONE_GRP_SUBSET	(LX_CLONE_FS)
+
+#define	LX_IS_CLONE_GRP(X)	((X & SHARED_AS) != 0 && \
+				(X & SHARED_AS) != SHARED_AS && \
+				((X & SHARED_AS) & ~LX_CLONE_GRP_SUBSET) == 0)
+
 #ifdef	__cplusplus
 }
 #endif
diff --git a/usr/src/lib/brand/lx/lx_brand/common/clone.c b/usr/src/lib/brand/lx/lx_brand/common/clone.c
index 586c042a83..2ae95e197c 100644
--- a/usr/src/lib/brand/lx/lx_brand/common/clone.c
+++ b/usr/src/lib/brand/lx/lx_brand/common/clone.c
@@ -53,10 +53,6 @@
 #include <sys/debug.h>
 #include <lx_syscall.h>
 
-
-#define	SHARED_AS	\
-	(LX_CLONE_VM | LX_CLONE_FS | LX_CLONE_FILES | LX_CLONE_SIGHAND	\
-	    | LX_CLONE_THREAD)
 #define	CLONE_VFORK (LX_CLONE_VM | LX_CLONE_VFORK)
 #define	CLONE_TD (LX_CLONE_THREAD|LX_CLONE_DETACH)
 
@@ -367,10 +363,12 @@ lx_clone(uintptr_t p1, uintptr_t p2, uintptr_t p3, uintptr_t p4, uintptr_t p5)
 	lx_ptrace_clone_begin(ptrace_event, !!(flags & LX_CLONE_PTRACE));
 
 	/*
-	 * Handle a fork(2) operation here.  If this is not a fork, a new
-	 * thread will be created after this block.
+	 * Handle a fork(2) operation here. If this is not a fork, a new
+	 * thread will be created after this block. We can also create a new
+	 * clone-group here (when two or more processes share data represented
+	 * by a subset of the SHARED_AS flags, but not a true thread).
 	 */
-	if (IS_FORK(flags) || IS_VFORK(flags)) {
+	if (IS_FORK(flags) || IS_VFORK(flags) || LX_IS_CLONE_GRP(flags)) {
 		if (flags & LX_CLONE_PARENT) {
 			lx_unsupported("clone(2) only supports CLONE_PARENT "
 			    "for threads.\n");
@@ -571,11 +569,11 @@ lx_clone(uintptr_t p1, uintptr_t p2, uintptr_t p3, uintptr_t p4, uintptr_t p5)
 	}
 
 	/*
-	 * We have very restricted support.... only exactly these flags are
-	 * supported
+	 * A supported clone-group was handled above, so now it must be a
+	 * true native thread, which means exactly these flags are supported
 	 */
 	if (((flags & SHARED_AS) != SHARED_AS)) {
-		lx_unsupported("clone(2) requires that all or none of "
+		lx_unsupported("clone(2) a thread requires that all or none of "
 		    "CLONE_VM/FS/FILES/THREAD/SIGHAND be set. (flags:0x%08X)\n",
 		    flags);
 		return (-ENOTSUP);
diff --git a/usr/src/uts/common/brand/lx/os/lx_brand.c b/usr/src/uts/common/brand/lx/os/lx_brand.c
index fbca57a418..f6d0afdb16 100644
--- a/usr/src/uts/common/brand/lx/os/lx_brand.c
+++ b/usr/src/uts/common/brand/lx/os/lx_brand.c
@@ -206,6 +206,8 @@ extern void lx_ioctl_fini();
 extern void lx_socket_init();
 extern void lx_socket_fini();
 
+extern void lx_clone_grp_exit(proc_t *);
+
 lx_systrace_f *lx_systrace_entry_ptr;
 lx_systrace_f *lx_systrace_return_ptr;
 
@@ -333,6 +335,8 @@ lx_proc_exit(proc_t *p)
 	lx_proc_data_t *lxpd;
 	proc_t *cp;
 
+	lx_clone_grp_exit(p);
+
 	mutex_enter(&p->p_lock);
 	VERIFY((lxpd = ptolxproc(p)) != NULL);
 	VERIFY(lxpd->l_ptrace == 0);
diff --git a/usr/src/uts/common/brand/lx/os/lx_misc.c b/usr/src/uts/common/brand/lx/os/lx_misc.c
index b8c9b52329..1d1977d3d7 100644
--- a/usr/src/uts/common/brand/lx/os/lx_misc.c
+++ b/usr/src/uts/common/brand/lx/os/lx_misc.c
@@ -538,8 +538,11 @@ lx_forklwp(klwp_t *srclwp, klwp_t *dstlwp)
 {
 	struct lx_lwp_data *src = srclwp->lwp_brand;
 	struct lx_lwp_data *dst = dstlwp->lwp_brand;
+	lx_proc_data_t *lproc = ttolxproc(lwptot(dstlwp));
 
 	dst->br_ppid = src->br_pid;
+	/* Record ppid for future clone validation */
+	lproc->l_clone_ppid = lwptoproc(srclwp)->p_pid;
 	dst->br_ptid = lwptot(srclwp)->t_tid;
 	bcopy(src->br_tls, dst->br_tls, sizeof (dst->br_tls));
 
diff --git a/usr/src/uts/common/brand/lx/sys/lx_brand.h b/usr/src/uts/common/brand/lx/sys/lx_brand.h
index 959e84b0a0..59656189e6 100644
--- a/usr/src/uts/common/brand/lx/sys/lx_brand.h
+++ b/usr/src/uts/common/brand/lx/sys/lx_brand.h
@@ -295,6 +295,18 @@ typedef struct {
 	uint64_t	rlim_max;
 } lx_rlimit64_t;
 
+typedef struct {
+	list_node_t	lx_clgrpm_link;
+	proc_t		*lx_clgrpm_pp;
+} lx_clone_grp_member_t;
+
+typedef struct {
+	kmutex_t	lx_clgrp_lock;	/* protects cnt & member list */
+	uint32_t	lx_clgrp_flags;	/* See big theory in lx_clone.c */
+	int		lx_clgrp_cnt;
+	list_t		*lx_clgrp_members;
+} lx_clone_grp_t;
+
 typedef struct lx_proc_data {
 	uintptr_t l_handler;	/* address of user-space handler */
 	pid_t l_ppid;		/* pid of originating parent proc */
@@ -307,6 +319,10 @@ typedef struct lx_proc_data {
 	int l_parent_deathsig;
 	lx_proc_flags_t l_flags;
 
+	kmutex_t l_clone_grp_lock; /* protects the following member */
+	lx_clone_grp_t *l_clone_grp;
+	pid_t l_clone_ppid;	/* used for clone-group parent pid checking */
+
 	lx_rlimit64_t l_fake_limits[LX_RLFAKE_NLIMITS];
 
 	/* original start/end bounds of arg/env string data */
diff --git a/usr/src/uts/common/brand/lx/sys/lx_misc.h b/usr/src/uts/common/brand/lx/sys/lx_misc.h
index af073c3f5f..5569511d58 100644
--- a/usr/src/uts/common/brand/lx/sys/lx_misc.h
+++ b/usr/src/uts/common/brand/lx/sys/lx_misc.h
@@ -44,6 +44,10 @@ extern void lx_clear_gdt(int);
 
 extern longlong_t lx_nosys();
 
+extern boolean_t lx_clone_grp_member(lx_proc_data_t *, uint_t);
+extern int lx_clone_grp_walk(lx_proc_data_t *, int (*)(proc_t *, void *),
+    void *);
+
 extern greg_t lx_fixsegreg(greg_t, model_t);
 extern uintptr_t lx_fsbase(klwp_t *, uintptr_t);
 extern void lx_exit_with_sig(proc_t *, sigqueue_t *);
diff --git a/usr/src/uts/common/brand/lx/syscall/lx_clone.c b/usr/src/uts/common/brand/lx/syscall/lx_clone.c
index 50cdeaeab9..59ac27e6af 100644
--- a/usr/src/uts/common/brand/lx/syscall/lx_clone.c
+++ b/usr/src/uts/common/brand/lx/syscall/lx_clone.c
@@ -21,9 +21,87 @@
 /*
  * Copyright 2006 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
- * Copyright 2015 Joyent, Inc.
+ * Copyright 2016 Joyent, Inc.
  */
 
+/*
+ * The vast majority of clone calls are for either the creation of a new
+ * process or for a new thread. Both of these map easily from Linux to our
+ * native code. For these calls, the user-level brand library uses a brand
+ * call to hook into the lx_helper_clone function for the required in-kernel
+ * support.
+ *
+ * Unfortunately, clone can also be called with a subset of the LX_CLONE_*
+ * flags. This does not map directly to our native code and requires special
+ * handling in the brand code itself. The rest of this description omits the
+ * 'LX_' prefix on the clone flag names.
+ *
+ * A fork will provide these clone flags:
+ *    CLONE_CHILD_SETTID | CLONE_CHILD_CLEARTID
+ *
+ * A new thread will use our SHARED_AS macro which has the flags:
+ *     CLONE_FILES | CLONE_FS | CLONE_SIGHAND | CLONE_THREAD |  CLONE_VM
+ *
+ * However, in rare cases an application will attempt to use a subset of the
+ * SHARED_AS flags in order to implement some sharing between two processes
+ * without using a true thread. Because we do not have native support for this
+ * concept, the lx brand implements the notion of a 'clone-group'. This is a
+ * set of processes which share a subset of the allowed SHARED_AS flags. The
+ * lx brand syscalls implement the appropriate sharing for each flag. A
+ * clone-group is only instantiated in the rare case that a subset of the
+ * SHARED_AS flags are used with clone.
+ *
+ * The following set of flags could be supported, although not all of them
+ * are implemented at this time. The user-level brand library will validate
+ * that a supported subset of the flags is being used, or error if not. We
+ * also re-validate in the kernel.
+ *
+ * CLONE_FILES:	share the file descriptor table
+ * CLONE_FS:	share the filesystem information (root of the filesystem, the
+ *		CWD, and the umask)
+ * CLONE_SIGHAND: share the table of signal handlers
+ * CLONE_THREAD: share the thread group
+ *
+ * At this time, only those flags in CLONE_GRP_SUBSET are implemented.
+ *
+ * When a clone-group is in use, the lx_proc_data_t`l_clone_grp member will
+ * hold the group of processes sharing some information. That struct also
+ * includes the flags for what is being shared. On the first clone, a new
+ * lx_clone_grp_t struct will be created. This struct holds a pointer to each
+ * process in the group. Each syscall which requires it must implement the
+ * appropriaate clone-group support. The syscalls will use lx_clone_grp_member
+ * to determine if clone-group handling is required, and use lx_clone_grp_walk
+ * to walk the list of processes in the group and apply the provided callback
+ * to each process.
+ *
+ * Note that we currently only implement a single clone-group at this time.
+ * That is, all of the processes in the group must be using the same subset
+ * of the CLONE_* flags. For example, we DO NOT currently support the following
+ * scenario:
+ *	A clones B with CLONE_FS
+ *	B clones C with CLONE_THREAD
+ *	C clones D with CLONE_FS
+ * In this example, only A&B and C&D should share their FS information, but B&C
+ * would have to be in two separate clone groups. Because the CLONE flag subset
+ * usage is already very rare, and it is expected that a scenario such as this
+ * one would be even rarer still, we have chosen to only support a single
+ * common group with a single set of CLONE_* flags for all of the processes at
+ * this time. Otherwise, we'll need to support a list of lists to handle
+ * multiple groups.
+ *
+ * When a process exits, it removes itself from the group. When there is one
+ * process left in the group, the group itself is removed and the l_clone_grp
+ * is cleared on the remaining process.
+ *
+ * If clone-groups were commonly used, this implementation would be inefficient
+ * and unwieldy, but since they are so rare and the observed sharing seems
+ * simple, a straightforward list-based approach is adequate.
+ *
+ * Lock ordering for manipulating the clone-group pointers and list:
+ * child l_clone_grp_lock -> parent l_clone_grp_lock -> group's lx_clgrp_lock
+ */
+
+
 #include <sys/types.h>
 #include <sys/systm.h>
 #include <sys/errno.h>
@@ -36,6 +114,317 @@
 #include <sys/x86_archext.h>
 #include <sys/controlregs.h>
 
+/*
+ * Setup the current process and its parent in a clone-group together.
+ */
+static int
+lx_clone_grp_enter(int flags)
+{
+	lx_proc_data_t *clproc = ttolxproc(curthread);
+	lx_proc_data_t *plproc;
+	proc_t *pp;
+	lx_clone_grp_t *cgp;
+	lx_clone_grp_member_t *mp;
+
+	mutex_enter(&pidlock);
+
+	pp = ttoproc(curthread)->p_parent;
+	plproc = ptolxproc(pp);
+
+	if (plproc == NULL) {
+		/*
+		 * Somehow parent is not branded. Although this shouldn't
+		 * happen, it might theoretically occur if the parent already
+		 * exited and we got reparented to a non-branded process
+		 * (although the init process in the zone should be branded).
+		 * Bail out if this ever happens.
+		 */
+		mutex_exit(&pidlock);
+		return (0);
+	}
+
+	/*
+	 * It is possible for the parent to exit before the child gets a chance
+	 * to setup the clone-group. A well-behaved application will explicitly
+	 * depend on both processes co-existing, but we don't want a malicious
+	 * application to setup an invalid clone-group with the init process
+	 * that the child got reparented to. When the parent forked, we
+	 * recorded its pid, so now we can validate that the original parent is
+	 * still our parent.
+	 */
+	if (clproc->l_clone_ppid != pp->p_pid) {
+		mutex_exit(&pidlock);
+		return (0);
+	}
+
+	/* Check if parent is exiting or zombie and return */
+	if (((pp->p_flag & SEXITING) || pp->p_stat == SZOMB)) {
+		mutex_exit(&pidlock);
+		return (0);
+	}
+
+	mutex_enter(&clproc->l_clone_grp_lock);
+	mutex_enter(&plproc->l_clone_grp_lock);
+	mutex_exit(&pidlock);
+
+	/*
+	 * If the parent is already in a group, the new clone flags must be
+	 * for the same subset of the existing group's CLONE flags.
+	 */
+	cgp = plproc->l_clone_grp;
+	if (cgp != NULL &&
+	    (cgp->lx_clgrp_flags & flags) != cgp->lx_clgrp_flags) {
+		mutex_exit(&plproc->l_clone_grp_lock);
+		mutex_exit(&clproc->l_clone_grp_lock);
+		return (-1);
+	}
+
+	/*
+	 * If parent already has a clone-group list, the child joins the group,
+	 * otherwise create a group and place both processes into the group.
+	 */
+	if (cgp != NULL) {
+		mp = kmem_zalloc(sizeof (lx_clone_grp_member_t), KM_SLEEP);
+		mp->lx_clgrpm_pp = curproc;
+
+		mutex_enter(&cgp->lx_clgrp_lock);
+		list_insert_tail(cgp->lx_clgrp_members, mp);
+		cgp->lx_clgrp_cnt++;
+		mutex_exit(&cgp->lx_clgrp_lock);
+
+		mutex_exit(&plproc->l_clone_grp_lock);
+		mutex_exit(&clproc->l_clone_grp_lock);
+		return (0);
+	}
+
+	/* Create a new clone-group and add both processes */
+	cgp = kmem_alloc(sizeof (lx_clone_grp_t), KM_SLEEP);
+	mutex_init(&cgp->lx_clgrp_lock, NULL, MUTEX_DEFAULT, NULL);
+	cgp->lx_clgrp_flags = flags;
+	cgp->lx_clgrp_cnt = 2;
+	cgp->lx_clgrp_members = kmem_alloc(sizeof (list_t), KM_SLEEP);
+	list_create(cgp->lx_clgrp_members, sizeof (lx_clone_grp_member_t),
+	    offsetof(lx_clone_grp_member_t, lx_clgrpm_link));
+
+	/* The list isn't attached to either process yet; mutex not needed */
+
+	mp = kmem_zalloc(sizeof (lx_clone_grp_member_t), KM_SLEEP);
+	mp->lx_clgrpm_pp = pp;
+	list_insert_tail(cgp->lx_clgrp_members, mp);
+
+	mp = kmem_zalloc(sizeof (lx_clone_grp_member_t), KM_SLEEP);
+	mp->lx_clgrpm_pp = curproc;
+	list_insert_tail(cgp->lx_clgrp_members, mp);
+
+	/* Attach group to both processes */
+	mutex_enter(&cgp->lx_clgrp_lock);
+	plproc->l_clone_grp = clproc->l_clone_grp = cgp;
+	mutex_exit(&cgp->lx_clgrp_lock);
+
+	mutex_exit(&plproc->l_clone_grp_lock);
+	mutex_exit(&clproc->l_clone_grp_lock);
+	return (0);
+}
+
+/*
+ * The process is exiting, in the unlikely event it is in a clone-group, remove
+ * it from the group and perform any necessary cleanup.
+ *
+ * Note that there is some locking complexity here since some other process in
+ * the group might be in any state, including in the middle of walking the
+ * group itself, while we're working on exiting. While a process is walking the
+ * group, there can be all sorts of locking activity taking place for the
+ * callbacks on each process in the group.
+ */
+void
+lx_clone_grp_exit(proc_t *p)
+{
+	lx_proc_data_t *plproc = ptolxproc(p);
+	lx_clone_grp_t *cgp;
+	lx_clone_grp_member_t *mp;
+	boolean_t found;
+	pid_t last_pid;
+
+	ASSERT(!MUTEX_HELD(&pidlock));
+	ASSERT(!MUTEX_HELD(&p->p_lock));
+	ASSERT(plproc != NULL);
+
+	mutex_enter(&plproc->l_clone_grp_lock);
+	if (plproc->l_clone_grp == NULL) {
+		mutex_exit(&plproc->l_clone_grp_lock);
+		return;
+	}
+
+	/*
+	 * The rare case when this process belongs to a clone-group.
+	 *
+	 * Although we're exiting, we're holding our l_clone_grp_lock here in
+	 * case one of our children is still in the middle of the shared clone
+	 * and intends to manipulate the group list.
+	 */
+
+	cgp = plproc->l_clone_grp;
+
+	/* First remove ourselves from the group. */
+	mutex_enter(&cgp->lx_clgrp_lock);
+
+	found = B_FALSE;
+	mp = list_head(cgp->lx_clgrp_members);
+	while (mp != NULL) {
+		if (mp->lx_clgrpm_pp == p) {
+			found = B_TRUE;
+			list_remove(cgp->lx_clgrp_members, mp);
+			kmem_free(mp, sizeof (lx_clone_grp_member_t));
+			ASSERT(cgp->lx_clgrp_cnt > 0);
+			cgp->lx_clgrp_cnt--;
+			plproc->l_clone_grp = NULL;
+			break;
+		}
+		mp = list_next(cgp->lx_clgrp_members, mp);
+	}
+	VERIFY(found);
+
+	last_pid = -1;
+	if (cgp->lx_clgrp_cnt < 2) {
+		/*
+		 * It looks like there is only one process left in group. We
+		 * want to cleanup but we can't do this while only holding
+		 * lx_clgrp_lock since the remaining process could be in any
+		 * kind of locking state. We'll reacquire the locks in the
+		 * proper order to cleanup.
+		 *
+		 * The remaining proc can't exit while we're holding
+		 * lx_clgrp_lock but anything can happen after we drop it,
+		 * including a race with both procs here simultaneously
+		 * exiting.
+		 */
+		if ((mp = list_head(cgp->lx_clgrp_members)) != NULL)
+			last_pid = mp->lx_clgrpm_pp->p_pid;
+	}
+	mutex_exit(&cgp->lx_clgrp_lock);
+	mutex_exit(&plproc->l_clone_grp_lock);
+
+	if (last_pid == -1)
+		return;
+
+	/*
+	 * We want to cleanup what we saw as the final process in the group,
+	 * but at this point that process might not even exist anymore.
+	 *
+	 * Do a locking dance so we can reacquire the locks in the proper order
+	 * to cleanup. Because this is a rare occurance, we're not worried
+	 * about the perf. impact of reacquiring the locks and re-checking.
+	 */
+	mutex_enter(&pidlock);
+
+	if ((p = prfind(last_pid)) == NULL) {
+		mutex_exit(&pidlock);
+		return;
+	}
+
+	mutex_enter(&p->p_lock);
+	mutex_exit(&pidlock);
+
+	/* p now refers to the process we think is the last one */
+	if ((plproc = ptolxproc(p)) == NULL) {
+		mutex_exit(&p->p_lock);
+		return;
+	}
+
+	mutex_enter(&plproc->l_clone_grp_lock);
+	if (plproc->l_clone_grp == NULL || plproc->l_clone_grp != cgp) {
+		mutex_exit(&plproc->l_clone_grp_lock);
+		mutex_exit(&p->p_lock);
+		return;
+	}
+
+	cgp = plproc->l_clone_grp;
+	mutex_enter(&cgp->lx_clgrp_lock);
+
+	/* Re-confirm p is still the only member of the group */
+	if (cgp->lx_clgrp_cnt > 1) {
+		/* Another process snuck into the group! */
+		mutex_exit(&cgp->lx_clgrp_lock);
+		mutex_exit(&plproc->l_clone_grp_lock);
+		mutex_exit(&p->p_lock);
+		return;
+	}
+
+	/*
+	 * It's now finally safe to remove that group from the process, then
+	 * cleanup the old group since there are no more references to it.
+	 */
+	plproc->l_clone_grp = NULL;
+	mutex_exit(&cgp->lx_clgrp_lock);
+	mutex_exit(&plproc->l_clone_grp_lock);
+	mutex_exit(&p->p_lock);
+
+	VERIFY((mp = list_head(cgp->lx_clgrp_members)) != NULL);
+	list_remove(cgp->lx_clgrp_members, mp);
+	kmem_free(mp, sizeof (lx_clone_grp_member_t));
+	VERIFY(list_is_empty(cgp->lx_clgrp_members));
+
+	list_destroy(cgp->lx_clgrp_members);
+	kmem_free(cgp->lx_clgrp_members, sizeof (list_t));
+	mutex_destroy(&cgp->lx_clgrp_lock);
+	kmem_free(cgp, sizeof (lx_clone_grp_t));
+}
+
+/*
+ * Return true in the rare case that the process is a member of a clone group
+ * with the specific flag set. In that case we return with the process's
+ * l_clone_grp_lock held.
+ */
+boolean_t
+lx_clone_grp_member(lx_proc_data_t *dp, uint_t flag)
+{
+	mutex_enter(&dp->l_clone_grp_lock);
+	if (dp->l_clone_grp != NULL &&
+	    (dp->l_clone_grp->lx_clgrp_flags & flag) != 0) {
+		return (B_TRUE);
+	}
+
+	mutex_exit(&dp->l_clone_grp_lock);
+	return (B_FALSE);
+}
+
+/*
+ * Walk all of the processes in the clone-group list and apply the callback
+ * to each. Because we're holding the group list lock (lx_clgrp_lock) none of
+ * the processes can exit, but that is the only locking guarantee made by this
+ * function itself.
+ */
+int
+lx_clone_grp_walk(lx_proc_data_t *dp, int (*cb)(proc_t *, void *), void *arg)
+{
+	lx_clone_grp_t *cgp;
+	lx_clone_grp_member_t *mp;
+	int res, rv = 0;
+
+	ASSERT(dp != NULL);
+	ASSERT(MUTEX_HELD(&dp->l_clone_grp_lock));
+	/* We should not be called unless we belong to a group */
+	VERIFY(dp->l_clone_grp != NULL);
+
+	cgp = dp->l_clone_grp;
+	mutex_enter(&cgp->lx_clgrp_lock);
+
+	mp = list_head(cgp->lx_clgrp_members);
+	while (mp != NULL) {
+		res = cb(mp->lx_clgrpm_pp, arg);
+		/* return the first error we see, but try all procs */
+		if (res != 0 && rv == 0)
+			rv = res;
+		mp = list_next(cgp->lx_clgrp_members, mp);
+	}
+
+	mutex_exit(&cgp->lx_clgrp_lock);
+	mutex_exit(&dp->l_clone_grp_lock);
+
+	return (rv);
+}
+
+
 /*
  * Our lwp has already been created at this point, so this routine is
  * responsible for setting up all the state needed to track this as a
@@ -121,6 +510,18 @@ lx_helper_clone(int64_t *rval, int flags, void *ptidp, void *tls, void *ctidp)
 		}
 	}
 
+	/*
+	 * Check if we have non-standard flags for clone (i.e. not a pure
+	 * thread or process).
+	 */
+	if (LX_IS_CLONE_GRP(flags)) {
+		if (lx_clone_grp_enter(flags & LX_CLONE_GRP_SUBSET) != 0) {
+			if (entry >= 0)
+				lx_clear_gdt(entry);
+			return (set_errno(EINVAL));
+		}
+	}
+
 	*rval = lwpd->br_pid;
 	return (0);
 }
diff --git a/usr/src/uts/common/brand/lx/syscall/lx_miscsys.c b/usr/src/uts/common/brand/lx/syscall/lx_miscsys.c
index 87bb9bde1b..d5705fff11 100644
--- a/usr/src/uts/common/brand/lx/syscall/lx_miscsys.c
+++ b/usr/src/uts/common/brand/lx/syscall/lx_miscsys.c
@@ -18,6 +18,7 @@
 #include <sys/resource.h>
 #include <sys/uadmin.h>
 #include <sys/lx_misc.h>
+#include <lx_syscall.h>
 
 #define	LINUX_REBOOT_MAGIC1		0xfee1dead
 #define	LINUX_REBOOT_MAGIC2		672274793
@@ -69,21 +70,79 @@ extern int stime(time_t);
 /* From uts/common/syscall/uadmin.c */
 extern int uadmin(int, int, uintptr_t);
 
+/* XXX */
+extern int chdir_proc(proc_t *, vnode_t *, int, int);
+extern int lookupname(char *, enum uio_seg, int, vnode_t **, vnode_t **);
+
+typedef struct {
+	char	*lcfa_path;
+	int	lcfa_type;
+} lx_clone_fs_arg_t;
+
 long
 lx_alarm(int seconds)
 {
 	return (alarm(seconds));
 }
 
+static int
+lx_clone_fs_cb(proc_t *pp, void *arg)
+{
+	lx_clone_fs_arg_t *ap = (lx_clone_fs_arg_t *)arg;
+	vnode_t *vp;
+	int err;
+
+	err = lookupname(ap->lcfa_path, UIO_USERSPACE, FOLLOW, NULLVPP, &vp);
+	if (err != 0)
+		return (err);
+
+	if ((err = chdir_proc(pp, vp, ap->lcfa_type, 1)) != 0)
+		return (err);
+
+	return (0);
+}
+
 long
 lx_chdir(char *path)
 {
+	lx_proc_data_t *lproc = ttolxproc(curthread);
+
+	/* Handle the rare case of being in a CLONE_FS clone group */
+	if (lx_clone_grp_member(lproc, LX_CLONE_FS)) {
+		int err;
+		lx_clone_fs_arg_t arg;
+
+		arg.lcfa_path = path;
+		arg.lcfa_type = 0;
+
+		err = lx_clone_grp_walk(lproc, lx_clone_fs_cb, (void *)&arg);
+		if (err != 0)
+			return (set_errno(err));
+		return (0);
+	}
+
 	return (chdir(path));
 }
 
 long
 lx_chroot(char *path)
 {
+	struct lx_proc_data *lproc = ttolxproc(curthread);
+
+	/* Handle the rare case of being in a CLONE_FS clone group */
+	if (lx_clone_grp_member(lproc, LX_CLONE_FS)) {
+		int err;
+		lx_clone_fs_arg_t arg;
+
+		arg.lcfa_path = path;
+		arg.lcfa_type = 1;
+
+		err = lx_clone_grp_walk(lproc, lx_clone_fs_cb, (void *)&arg);
+		if (err != 0)
+			return (set_errno(err));
+		return (0);
+	}
+
 	return (chroot(path));
 }
 
diff --git a/usr/src/uts/common/brand/lx/syscall/lx_umask.c b/usr/src/uts/common/brand/lx/syscall/lx_umask.c
index 130af6c776..fbf0f2b548 100644
--- a/usr/src/uts/common/brand/lx/syscall/lx_umask.c
+++ b/usr/src/uts/common/brand/lx/syscall/lx_umask.c
@@ -14,12 +14,39 @@
  */
 
 #include <sys/types.h>
+#include <sys/lx_misc.h>
+#include <lx_syscall.h>
 
 /* From usr/src/uts/common/syscall/umask.c */
 extern int umask(int);
 
+/*
+ * Just do what umask() does, but for the given process.
+ */
+static int
+lx_clone_umask_cb(proc_t *pp, void *arg)
+{
+	mode_t cmask = (mode_t)(intptr_t)arg;
+	mode_t orig;
+
+	orig = PTOU(pp)->u_cmask;
+	PTOU(pp)->u_cmask = (mode_t)(cmask & PERMMASK);
+	return ((int)orig);
+}
+
 long
 lx_umask(mode_t cmask)
 {
+	lx_proc_data_t *lproc = ttolxproc(curthread);
+
+	/* Handle the rare case of being in a CLONE_FS clone group */
+	if (lx_clone_grp_member(lproc, LX_CLONE_FS)) {
+		int omask;
+
+		omask = lx_clone_grp_walk(lproc, lx_clone_umask_cb,
+		    (void *)(intptr_t)cmask);
+		return (omask);
+	}
+
 	return (umask(cmask));
 }
diff --git a/usr/src/uts/common/syscall/chdir.c b/usr/src/uts/common/syscall/chdir.c
index 84c924f570..ac4fa05dd6 100644
--- a/usr/src/uts/common/syscall/chdir.c
+++ b/usr/src/uts/common/syscall/chdir.c
@@ -21,6 +21,7 @@
 /*
  * Copyright 2010 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
+ * Copyright 2016 Joyent, Inc.
  */
 
 /*	Copyright (c) 1983, 1984, 1985, 1986, 1987, 1988, 1989 AT&T	*/
@@ -159,11 +160,10 @@ fchroot(int fd)
 }
 
 static int
-chdirec(vnode_t *vp, int ischroot, int do_traverse)
+chdirec_common(proc_t *pp, vnode_t *vp, int ischroot, int do_traverse)
 {
 	int error;
 	vnode_t *oldvp;
-	proc_t *pp = curproc;
 	vnode_t **vpp;
 	refstr_t *cwd;
 	int newcwd = 1;
@@ -243,3 +243,15 @@ bad:
 	VN_RELE(vp);
 	return (error);
 }
+
+int
+chdir_proc(proc_t *pp, vnode_t *vp, int ischroot, int do_traverse)
+{
+	return (chdirec_common(pp, vp, ischroot, do_traverse));
+}
+
+static int
+chdirec(vnode_t *vp, int ischroot, int do_traverse)
+{
+	return (chdirec_common(curproc, vp, ischroot, do_traverse));
+}
-- 
2.21.0

