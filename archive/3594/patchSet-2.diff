From 4efb548c284b9e8efcbd409ad0f01f9df0311b4b Mon Sep 17 00:00:00 2001
From: Trent Mick <trentm@gmail.com>
Date: Mon, 12 Mar 2018 15:03:50 -0700
Subject: [PATCH] TRITON-231 sapi: abort-on-uncaught-exception, improved audit
 logging (include GetConfig), drop unused middleware

---
 lib/server/audit.js | 380 ++++++++++++++++++++++++++++++++++++++++++++
 lib/server/sapi.js  |  41 +++--
 2 files changed, 400 insertions(+), 21 deletions(-)
 create mode 100644 lib/server/audit.js

diff --git a/lib/server/audit.js b/lib/server/audit.js
new file mode 100644
index 0000000..6ea9312
--- /dev/null
+++ b/lib/server/audit.js
@@ -0,0 +1,380 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2018, Joyent, Inc.
+ */
+
+/*
+ * This is an adaptation of restify/lib/plugins/audit.js (originally from
+ * restify 4.x) with a number of feature additions.
+ *
+ * Usage:
+ *
+ *      server.on('after', audit.createAuditLogHandler({
+ *          ...options...
+ *      }));
+ *
+ * Features and differences:
+ *
+ * - Fine control on how and whether to log request and response bodies.
+ *   `opts.reqBody` and `opts.resBody` can be used to independently control
+ *   how the request and response bodies are logged. At its simplest,
+ *   `{resBody: {}}`, will log response bodies, excluding buffers, excluding
+ *   responses with GET requests with a 2xx status code, and will clip
+ *   at 10k characters.
+ *
+ *   These replace `opts.body` from the default restify audit logger. As well,
+ *   this audit logger will log the *formatted* response body, as opposed
+ *   to the default restify audit logger which logs the response body *object*
+ *   before formatting.
+ *
+ * - Logged records set `audit: true`.
+ *   (Note that restify's audit logger sets that *and* `_audit: true`.)
+ *
+ * - There is an optional `polish` function that can be passed in to customize
+ *   audit log records just before they are logged by Bunyan.
+ *
+ * - Most options can be overridden per route name via `opts.routeOverrides`.
+ *
+ * See the `createAuditLogHandler` block comment for specifics.
+ */
+
+var assert = require('assert-plus');
+var bunyan = require('bunyan');
+var restify = require('restify');
+
+var HttpError = require('restify').HttpError;
+
+// Default maximum length for requests/responses body that are logged.
+var DEFAULT_BODY_MAX_LEN = 10 * 1024;
+
+function auditBodyFromReq(req, bodyOpts) {
+    // `req.body` is the request content as a *string* (i.e. not parsed by
+    // restify yet. We want the audit log to be as close as possible to the
+    // what is on the wire.
+    var auditBody = req.body;
+
+    if (!bodyOpts.include) {
+        auditBody = undefined;
+        /* jsl:ignore */
+    } else if (!auditBody) {
+        /* jsl:end */
+    } else if (Buffer.isBuffer(auditBody) && !bodyOpts.includeBuffers) {
+        auditBody = '<buffer>';
+    } else if (typeof (auditBody) === 'string' &&
+            auditBody.length > bodyOpts.maxLen) {
+        auditBody = auditBody.slice(0, bodyOpts.maxLen)
+            + '\n...<elided ' + (auditBody.length - bodyOpts.maxLen)
+            + ' chars>';
+    }
+
+    return auditBody;
+}
+
+// Same as `auditBodyFromReq` plus:
+// - `req._body` is trickier
+// - handle `bodyOpts.includeGet2xx`.
+function auditBodyFromRes(res, bodyOpts) {
+    var auditBody;
+
+    // We want the audit log to be as close as possible to the what is on
+    // the wire. That means we prefer the *formatted* response body (i.e. after
+    // the restify "formatter" has been applied). `res._data` holds this --
+    // at least that appears to be so in restify 4.x and 6.x code.
+    //
+    // This differs from the core restify audit logger that uses the
+    // *unformatted* response body:
+    //    if (res._body instanceof HttpError) {
+    //        auditBody = res._body.body;
+    //    } else {
+    //        auditBody = res._body;
+    //    }
+    //
+    // One reason we want the formatted body is that we can more realistically
+    // apply `maxLen`.
+    auditBody = res._data;
+
+    if (!bodyOpts.include) {
+        auditBody = undefined;
+    } else if (!bodyOpts.includeGet2xx && res.req.method === 'GET' &&
+            (res.statusCode >= 200 && res.statusCode < 300)) {
+        auditBody = undefined;
+        /* jsl:ignore */
+    } else if (!auditBody) {
+        /* jsl:end */
+    } else if (Buffer.isBuffer(auditBody) && !bodyOpts.includeBuffers) {
+        auditBody = '<buffer>';
+    } else if (typeof (auditBody) === 'string' &&
+            auditBody.length > bodyOpts.maxLen) {
+        auditBody = auditBody.slice(0, bodyOpts.maxLen)
+            + '...<elided ' + (auditBody.length - bodyOpts.maxLen)
+            + ' chars>';
+    }
+
+    return auditBody;
+}
+
+/**
+ * Manually generates a POJO from `res.getHeaderNames` and `res.getHeader`,
+ * if available, falling back to deprecated `res._headers`, otherwise.
+ * Intentionally does not use `res.getHeaders` to avoid deserialization
+ * issues with object returned by that method.
+ *
+ * See https://github.com/restify/node-restify/issues/1370
+ *
+ * (This was lifted from restify v6.x's lib/plugins/audit.js.)
+ */
+function getResponseHeaders(res) {
+    if (res.getHeaderNames && res.getHeader) {
+        return res.getHeaderNames().reduce(function reduce(prev, curr) {
+            var header = {};
+            header[curr] = res.getHeader(curr);
+            return Object.assign({}, prev, header);
+        }, {});
+    }
+    return res._headers;
+}
+
+
+/*
+ * A "bodyOpts" is one of the `opts.reqBody` or `opts.resBody` options to
+ * `createAuditLogHandler`.
+ */
+function assertOptionalBodyOpts(bo, bodyName) {
+    if (!bo) {
+        return;
+    }
+    assert.optionalBool(bo.include, bodyName + '.include');
+    assert.optionalBool(bo.includeBuffers, bodyName + '.includeBuffers');
+    assert.optionalBool(bo.includeGet2xx, bodyName + '.includeGet2xx');
+    assert.optionalNumber(bo.maxLen, bodyName + '.maxLen');
+}
+
+/*
+ * A `routeOpts` is one of the objects specified as values to
+ * `opts.routeOverrides`. The top-level `opts` to `createAuditLogHandler`
+ * is also a superset of `routeOpts`.
+ */
+function assertRouteOpts(ro, routeName) {
+    assert.optionalBool(ro.include, routeName + '.include');
+    // logLevel is validated in `Normalize` section below.
+    assertOptionalBodyOpts(ro.reqBody, routeName + '.reqBody');
+    assertOptionalBodyOpts(ro.resBody, routeName + '.resBody');
+    assert.optionalFunc(ro.polish, routeName + '.polish');
+}
+
+function normalizeRouteOpts(ro, defaults) {
+    // - default 'ro.include' to true
+    if (ro.include === undefined) {
+        ro.include = true;
+    }
+    // - set `ro.logFnName`, default to "info"
+    if (ro.logLevel) {
+        ro.logFnName = bunyan.nameFromLevel[
+            bunyan.resolveLevel(ro.logLevel)];
+        assert.string(ro.logFnName, 'can resolve logLevel="' + ro.logLevel
+            + '" to a Bunyan log level name');
+    } else {
+        ro.logFnName = 'info';
+    }
+    [ro.reqBody, ro.resBody].forEach(function (bodyOpt) {
+        if (bodyOpt) {
+            // - default `reqBody.include` and `resBody.include` to true
+            if (!bodyOpt.hasOwnProperty('include')) {
+                bodyOpt.include = true;
+            }
+            // - default `reqBody.maxLen` and `resBody.maxLen`
+            if (!bodyOpt.hasOwnProperty('maxLen')) {
+                bodyOpt.maxLen = DEFAULT_BODY_MAX_LEN;
+            }
+        }
+    });
+    // - inherit values from `defaultRouteOpts`
+    if (defaults) {
+        Object.keys(defaults).forEach(function (fieldName) {
+            if (ro[fieldName] === undefined) {
+                ro[fieldName] = defaults[fieldName];
+            }
+        });
+    }
+}
+
+
+// ---- API
+
+/**
+ * Create an audit log handler.
+ *
+ * @param {Object} opts:
+ *      @param {Object} opts.log - A Bunyan logger on which to log. Required.
+ *      @param {Boolean} opts.include - Whether to log at all. Default true.
+ *      @param {String} opts.logLevel - The bunyan log level (either the name
+ *          or the integer value) at which to log. Default is "info".
+ *      @param {Object} opts.reqBody - Options for logging request bodies.
+ *      @param {Object} opts.resBody - Options for logging response bodies.
+ *          Each of `reqBody` and `resBody` may have the following fields.
+ *          All fields are optional.
+ *          - {Boolean} `include` - Whether to log the body. Default is true.
+ *          - {Number} `maxLen` - The maximum length of body to log.
+ *            Default is 10k.
+ *          - {Boolean} `includeBuffers` - Whether to log the body even if it
+ *            is a Buffer. By default buffers are logged as `<buffer>`.
+ *          - {Boolean} `includeGet2xx` - Whether to include response bodies
+ *            for "GET" requests with a success response code (i.e. 2xx).
+ *            Default is false. The reasoning is that successful GET response
+ *            bodies can tend to be large and uninteresting. This field is
+ *            only relevant for `opts.resBody`.
+ *      @param {Function} opts.polish - A *sync* function that is called for
+ *          each audit log record just before the call to log it. Called as:
+ *              `function (fields, req, res, route, err)`
+ *          where `fields` is the Bunyan fields object being logged. It
+ *          can be changed in-place (as could `req` et al) to "polish" the
+ *          audit log record.
+ *      @param {Object} opts.routeOverrides - A mapping of `route.name`
+ *          (recall that restify, at least v4.x, lowercases `route.name`), to
+ *          overrides for any of the above options, except `log`. E.g.:
+ *              {
+ *                  // Exclude "GetPing" requests.
+ *                  'getping': {include: false}
+ *                  // Log "GetConfig" requests at DEBUG-level.
+ *                  'getconfig': {logLevel: 'debug'}
+ *                  // See the first 300 chars of ListInstances responses.
+ *                  'listinstances': {
+ *                      resBody: {
+ *                          includeGet2xx: true,
+ *                          maxLen: 300
+ *                      }
+ *                  }
+ *              }
+ *          Dev Note: This function modifies the `routeOverrides` objects
+ *          in-place.
+ * @returns {Function} A restify handler intended for `server.on('after', ...)`.
+ */
+function createAuditLogHandler(opts) {
+    // Validate inputs.
+    assert.object(opts, 'opts');
+    assert.object(opts.log, 'opts.log');
+    assert.optionalObject(opts.routeOverrides, 'opts.routeOverrides');
+    var defaultRouteOpts = {
+        include: opts.include,
+        logLevel: opts.logLevel,
+        reqBody: opts.reqBody,
+        resBody: opts.resBody,
+        polish: opts.polish
+    };
+    assertRouteOpts(defaultRouteOpts, 'default');
+    var routeOptsFromName = opts.routeOverrides || {};
+    Object.keys(routeOptsFromName).forEach(function (name) {
+        assertRouteOpts(routeOptsFromName[name], 'routeOverrides.' + name);
+    });
+
+    // Normalize routeOpts objects.
+    normalizeRouteOpts(defaultRouteOpts);
+    Object.keys(routeOptsFromName).forEach(function (name) {
+        normalizeRouteOpts(routeOptsFromName[name], defaultRouteOpts);
+    });
+
+    function routeOptsFromRoute(route) {
+        return (route && route.name && routeOptsFromName[route.name] ||
+            defaultRouteOpts);
+    }
+
+    var errSerializer = (opts.log.serializers && opts.log.serializers.err)
+        ? opts.log.serializers.err : bunyan.stdSerializers.err;
+    var log = opts.log.child({
+        audit: true,
+        serializers: {
+            err: errSerializer,
+            req: function auditReqSerializer(req) {
+                if (!req) {
+                    return false;
+                }
+
+                var routeOpts = routeOptsFromRoute(req.route);
+
+                var timers = {};
+                (req.timers || []).forEach(function (time) {
+                    var t = time.time;
+                    var _t = Math.floor((1000000 * t[0]) + (t[1] / 1000));
+                    // TODO: restify 6.x diff here to consider
+                    timers[time.name] = _t;
+                });
+
+                return {
+                    // account for native and queryParser plugin usage
+                    query: (typeof (req.query) === 'function') ?
+                        req.query() : req.query,
+                    method: req.method,
+                    url: req.url,
+                    headers: req.headers,
+                    httpVersion: req.httpVersion,
+                    trailers: req.trailers,
+                    version: req.version(),
+                    body: auditBodyFromReq(req, routeOpts.reqBody),
+                    timers: timers
+                    // TODO: consider connectionState from restify 6.x here
+                };
+            },
+            res: function auditResSerializer(res) {
+                if (!res) {
+                    return false;
+                }
+
+                var routeOpts = routeOptsFromRoute(res.req.route);
+
+                return {
+                    statusCode: res.statusCode,
+                    headers: getResponseHeaders(res),
+                    trailer: res._trailer || false,
+                    body: auditBodyFromRes(res, routeOpts.resBody)
+                };
+            }
+        }
+    });
+
+    function audit(req, res, route, err) {
+        var routeName = route && route.name || undefined;
+        var routeOpts = routeOptsFromRoute(route);
+
+        if (!routeOpts.include) {
+            return;
+        }
+
+        // TODO: 6.x diff here to accomodate.
+        var latency = res.get('Response-Time');
+        if (typeof (latency) !== 'number') {
+            latency = Date.now() - req._time;
+        }
+
+        var fields = {
+            remoteAddress: req.connection.remoteAddress,
+            remotePort: req.connection.remotePort,
+            req_id: req.getId(),
+            req: req,
+            res: res,
+            err: err,
+            latency: latency,
+            secure: req.secure,
+            route: routeName
+        };
+
+        if (routeOpts.polish) {
+            routeOpts.polish(fields, req, res, route, err);
+        }
+
+        log[routeOpts.logFnName](fields, 'handled: %d', res.statusCode);
+    }
+
+    return audit;
+}
+
+
+// ---- exports
+
+module.exports = {
+    createAuditLogHandler: createAuditLogHandler
+};
diff --git a/lib/server/sapi.js b/lib/server/sapi.js
index dddc6fa..7f34319 100644
--- a/lib/server/sapi.js
+++ b/lib/server/sapi.js
@@ -20,6 +20,7 @@ var https = require('https');
 var os = require('os');
 var restify = require('restify');
 
+var audit = require('./audit');
 var endpoints = require('./endpoints');
 var Model = require('./model');
 
@@ -110,11 +111,12 @@ SAPI.prototype.shutdown = function shutdown(cb) {
 function createServer(options) {
     var server = restify.createServer({
         name: 'sapi/' + serverVersion(),
+        handleUncaughtExceptions: false,
         log: options.log,
         version: ['1.0.0', '2.0.0']
     });
 
-    server.pre(function (req, res, next) {
+    server.pre(function setDefaultApiVersion(req, res, next) {
         /**
          * If the client does not set Accept-Version, then we default
          * the header to "~1".
@@ -143,30 +145,27 @@ function createServer(options) {
         next();
     });
 
-    server.use(restify.acceptParser(server.acceptable));
-    server.use(restify.authorizationParser());
-    server.use(restify.dateParser());
     server.use(restify.queryParser({allowDots: false, plainObjects: false}));
     server.use(restify.bodyParser());
     server.use(restify.requestLogger());
-    server.on('after', function (req, res, route, err) {
-        // Skip logging some high frequency or unimportant endpoints to
-        // keep log noise down.
-        var method = req.method;
-        var pth = req.path();
-        if (method === 'GET' && pth.slice(0, 9) === '/configs/') {
-            return;
+
+    server.on('after', audit.createAuditLogHandler({
+        log: options.log,
+        reqBody: {
+            include: true,
+            maxLen: 1024
+        },
+        resBody: {
+            include: true,
+            includeGet2xx: false
+        },
+        routeOverrides: {
+            // Make the frequent `GetConfig` calls visible via `bunyan -p`.
+            'getconfigs': {
+                logLevel: 'debug'
+            }
         }
-        // Successful GET res bodies are uninteresting and *big*.
-        var body = !(method === 'GET' &&
-            Math.floor(res.statusCode / 100) === 2);
-
-        restify.auditLogger({
-            log: req.log.child(
-            {route: route && route.name || route}, true),
-            body: body
-        })(req, res, route, err);
-    });
+    }));
 
     endpoints.attachTo(server, options.model);
 
-- 
2.21.0

