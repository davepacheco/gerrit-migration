commit fde88e53e745e8bb7c919dcd67bda914f58f5af5 (refs/changes/19/5019/3)
Author: Marsell Kukuljevic <marsell@joyent.com>
Date:   2018-11-09T23:51:55+13:00 (11 months ago)
    
    TOOLS-2077 port modern mdata tools to Windows

diff --git a/Makefile b/Makefile
index af0c297..a0b4a79 100644
--- a/Makefile
+++ b/Makefile
@@ -98,6 +98,12 @@ PLATFORM_OK = true
 MANSECT = 1
 endif
 
+ifeq ($(UNAME_S),CYGWIN_NT-6.3)
+CFILES += plat/cygwin.c plat/unix_common.c
+HDRS += plat/unix_common.h
+PLATFORM_OK = true
+endif
+
 ifeq ($(PLATFORM_OK),false)
 $(error Unknown platform: $(UNAME_S))
 endif
diff --git a/README.md b/README.md
index 3847e40..87f26d2 100644
--- a/README.md
+++ b/README.md
@@ -31,15 +31,15 @@ base metadata keys for guests to consume, as well as the ability to support
 arbitrary additional user-provided metadata.
 
 In a SmartOS container/zone guest, a UNIX domain socket is used to communicate
-with the metadata server running in the hypervisor.  In a KVM guest, such as a
-Linux virtual machine, the client tools will make use of the second serial port
-(e.g.  `ttyb`, or `COM2`) to communicate with the hypervisor.
+with the metadata server running in the hypervisor.  In a bhyve or KVM guest,
+such as a Linux virtual machine, the client tools will make use of the second
+serial port (e.g.  `ttyb`, or `COM2`) to communicate with the hypervisor.
 
 # OS Support
 
-The tools currently build and function on SmartOS and various Linux
-distributions.  Support for other operating systems, such as \*BSD or Windows,
-is absolutely welcome.
+The tools currently build and function on SmartOS, some \*BSDs, various Linux
+distributions, and Windows (cygwin). Support for other operating systems is
+absolutely welcome.
 
 ## License
 
diff --git a/plat/cygwin.c b/plat/cygwin.c
new file mode 100644
index 0000000..66d4172
--- /dev/null
+++ b/plat/cygwin.c
@@ -0,0 +1,161 @@
+/*
+ * Copyright (c) 2018, Joyent, Inc.
+ * See LICENSE file for copyright and license details.
+ */
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <errno.h>
+#include <err.h>
+
+#include <poll.h>
+
+#include "common.h"
+#include "plat.h"
+#include "dynstr.h"
+#include "plat/unix_common.h"
+
+#define	SERIAL_DEVICE	"/dev/ttyS1"
+#define	MAX_READ_SZ	16
+
+struct mdata_plat {
+	struct pollfd mpl_poll;
+};
+
+
+int
+plat_send(mdata_plat_t *mpl, string_t *data)
+{
+	int len = dynstr_len(data);
+
+	if (write(mpl->mpl_poll.fd, dynstr_cstr(data), len) != len)
+		return (-1);
+
+	return (0);
+}
+
+int
+plat_recv(mdata_plat_t *mpl, string_t *data, int timeout_ms)
+{
+	for (;;) {
+		struct pollfd *mpl_poll = &mpl->mpl_poll;
+		short revents = 0;
+
+		if (poll(mpl_poll, 1, timeout_ms) == -1) {
+			fprintf(stderr, "poll error: %d\n", errno);
+			if (errno == EINTR)
+				return (-1);
+			err(1, "POLL_WAIT ERROR");
+		}
+
+		revents = mpl_poll->revents;
+
+		if (mpl_poll->fd < 0 || revents == 0) {
+			fprintf(stderr, "plat_recv timeout\n");
+			return (-1);
+		}
+
+		if (revents & POLLIN) {
+			char buf[MAX_READ_SZ+1];
+			ssize_t sz;
+
+			if ((sz = read(mpl_poll->fd, buf, MAX_READ_SZ)) > 0) {
+				if (buf[sz-1] == '\n') {
+					buf[sz-1] = '\0';   // also del newline
+					dynstr_append(data, buf);
+					return (0);
+				}
+
+				buf[sz] = '\0';
+				dynstr_append(data, buf);
+			}
+		}
+
+		if (revents & POLLERR) {
+			fprintf(stderr, "POLLERR\n");
+			return (-1);
+		}
+
+		if (revents & POLLHUP) {
+			fprintf(stderr, "POLLHUP\n");
+			return (-1);
+		}
+	}
+
+	return (-1);
+}
+
+void
+plat_fini(mdata_plat_t *mpl)
+{
+	if (mpl != NULL) {
+		if (mpl->mpl_poll.fd != -1)
+			(void) close(mpl->mpl_poll.fd);
+		free(mpl);
+	}
+}
+
+static int
+plat_send_reset(mdata_plat_t *mpl)
+{
+	int ret = -1;
+	string_t *str = dynstr_new();
+
+	dynstr_append(str, "\n");
+	if (plat_send(mpl, str) != 0)
+		goto bail;
+	dynstr_reset(str);
+
+	if (plat_recv(mpl, str, 2000) != 0)
+		goto bail;
+
+	if (strcmp(dynstr_cstr(str), "invalid command") != 0)
+		goto bail;
+
+	ret = 0;
+
+bail:
+	dynstr_free(str);
+	return (ret);
+}
+
+int
+plat_is_interactive(void)
+{
+	return (unix_is_interactive());
+}
+
+int
+plat_init(mdata_plat_t **mplout, char **errmsg, int *permfail)
+{
+	mdata_plat_t *mpl = NULL;
+
+	if ((mpl = calloc(1, sizeof (*mpl))) == NULL) {
+		*errmsg = "Could not allocate memory.";
+		*permfail = 1;
+		goto bail;
+	}
+
+	if (unix_open_serial(SERIAL_DEVICE, &mpl->mpl_poll.fd, errmsg,
+	    permfail) != 0) {
+		goto bail;
+	}
+
+	mpl->mpl_poll.events = POLLIN | POLLERR | POLLHUP;
+
+	if (plat_send_reset(mpl) == -1) {
+		*errmsg = "Could not do active reset.";
+		goto bail;
+	}
+
+	*mplout = mpl;
+
+	return (0);
+
+bail:
+	plat_fini(mpl);
+	return (-1);
+}
