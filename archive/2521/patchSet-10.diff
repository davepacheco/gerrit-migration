commit 1457c7c8cd08e11aefe4ef7142207c827e8fe967 (refs/changes/21/2521/10)
Author: Julien Gilli <julien.gilli@joyent.com>
Date:   2017-11-03T17:17:35+00:00 (1 year, 11 months ago)
    
    DOCKER-793: First pass for NFS shared volumes
    DOCKER-863: Create shared volume when mounting nonexistent volume
    VOLAPI-9 Implement asynchronous NFS shared volume creation
    PUBAPI-1300 Implement CRUD volumes endpoints
    VOLAPI-50 Add ListVolumeSizes endpoint
    VOLAPI-50 Add ListVolumeSizes endpoint (disambiguate endpoint)
    DOCKER-1034 support docker volume ls -f dangling=true
    TOOLS-1855 complete documentation about new volumes APIs
    TOOLS-1856 complete node-sdc-clients' new volume APIs' tests suite
    Reviewed by: Trent Mick <trentm@gmail.com>
    Approved by: Trent Mick <trentm@gmail.com>

diff --git a/CHANGES.md b/CHANGES.md
index 18e3185..d9069ac 100644
--- a/CHANGES.md
+++ b/CHANGES.md
@@ -8,7 +8,9 @@
 
 ## not yet released
 
-(nothing yet)
+- Integration of [RFD 26](https://github.com/joyent/rfd/tree/master/rfd/0026)'s
+  first "master integration" milestone. Adds support for Volume APIs provided by
+  the new VOLAPI core service.
 
 ## 10.3.0
 
diff --git a/docs/index.md b/docs/index.md
index 507ec84..dfa5392 100644
--- a/docs/index.md
+++ b/docs/index.md
@@ -338,3 +338,307 @@ peer.
 | Name     | Type     | Description     |
 | -------- | -------- | --------------- |
 | callback | Function | fn(error, objs) |
+
+# VOLAPI Client
+
+VOLAPI is the Volumes API. More documentation about this API can be found in
+[its code repository](https://github.com/joyent/sdc-volapi) and in [RFD
+26](https://github.com/joyent/rfd/blob/master/rfd/0026).
+
+## listVolumes(params, callback)
+
+List all volumes given the specified filter params. Currently the following
+parameters are allowed:
+
+| Name | Type | Description |
+| ---- | ---- | ----------- |
+| owner\_uuid | UUID | Volume owner account |
+| name | String | volume name, unique per owner |
+| type | String | volume type ('tritonnfs' is currently the only supported type) |
+| size | String | volume size  |
+| state| String | volume state |
+| predicate | String | URL encoded JSON string representing a JavaScript object that can be used to build a LDAP filter. This LDAP filter can search for volumes on arbitrary (indexed) properties |
+
+The function callback takes the following form
+
+| Name | Type | Description |
+| ---- | ---- | ----------- |
+| callback | Function | fn(error, volumes) |
+
+## createVolume(params, options, callback)
+
+Creates a new volume. The following params are allowed:
+
+| Name | Type | Description |
+| ---- | ---- | ----------- |
+| uuid | String | UUID of the volume. If not present, it is automatically generated |
+| name | String | Name of the volume |
+| owner_uuid | UUID | UUID the created volume's owner |
+| type | String | volume type (`'tritonnfs` is currently the only supported type) |
+| networks | Array | An array of network UUIDs representing networks on which this volume will be reachable |
+| size | Number | The desired storage capacity for that volume in mebibytes. Default value is 10240 mebibytes (10 gibibytes) |
+
+The following options are allowed:
+
+| Name | Type | Description |
+| ---- | ---- | ----------- |
+| headers | Object | a set of headers to add to the request (e.g a request ID |
+| log | Object | a logger that will be used to log messages about this request |
+
+The function callback takes the following form
+
+| Name | Type | Description |
+| ---- | ---- | ----------- |
+| callback | Function | fn(error, volume) |
+
+## createVolumeAndWait(params, options, callback)
+
+Similar to `createVolume`, but waits for the volume to not be in state
+`creating` (not necessarily in state `ready`) before calling `callback`.
+
+If the volume transitions to state `ready`, `callback` is called with no error as its first parameter. If the volume transitions to the state `failed`, `callback` is called with an error as its first parameter.
+
+The following params are allowed:
+
+| Name | Type | Description |
+| ---- | ---- | ----------- |
+| uuid | String | UUID of the volume. If not present, it is automatically generated |
+| name | String | Name of the volume |
+| owner_uuid | UUID | UUID the created volume's owner |
+| type | String | volume type (`'tritonnfs` is currently the only supported type) |
+| networks | Array | An array of network UUIDs representing networks on which this volume will be reachable |
+| size | Number | The desired storage capacity for that volume in mebibytes. Default value is 10240 mebibytes (10 gibibytes) |
+
+The following options are allowed:
+
+| Name | Type | Description |
+| ---- | ---- | ----------- |
+| headers | Object | a set of headers to add to the request (e.g a request ID |
+| log | Object | a logger that will be used to log messages about this request |
+| timeout | Number | the delay in miliseconds after which `callback` is called with an error as its first parameters regardless of the state of the volume |
+
+The function callback takes the following form
+
+| Name | Type | Description |
+| ---- | ---- | ----------- |
+| callback | Function | fn(error, volume) |
+
+## getVolume(params, options, callback)
+
+Gets information about an existing volume. The following params are allowed:
+
+| Name | Type | Description |
+| ---- | ---- | ----------- |
+| uuid | String | UUID of the volume |
+| owner_uuid | UUID | When present, the volume's owner UUID will be checked against this parameter. If it doesn't match, the request will result in an error  |
+
+The following options are allowed:
+
+| Name | Type | Description |
+| ---- | ---- | ----------- |
+| headers | Object | a set of headers to add to the request (e.g a request ID |
+| log | Object | a logger that will be used to log messages about this request |
+
+The function callback takes the following form
+
+| Name | Type | Description |
+| ---- | ---- | ----------- |
+| callback | Function | fn(error, volume) |
+
+## deleteVolume(params, options, callback)
+
+Deletes an existing volume. The following params are allowed:
+
+| Name | Type | Description |
+| ---- | ---- | ----------- |
+| uuid | String | UUID of the volume to delete |
+| owner_uuid | UUID | When present, the volume's owner UUID will be checked against this parameter. If it doesn't match, the request will result in an error  |
+| force | Boolean | `true` means that a volume will be deleted even if active VMs reference it. Default is `false`. |
+
+The following options are allowed:
+
+| Name | Type | Description |
+| ---- | ---- | ----------- |
+| headers | Object | a set of headers to add to the request (e.g a request ID |
+| log | Object | a logger that will be used to log messages about this request |
+
+The function callback takes the following form
+
+| Name | Type | Description |
+| ---- | ---- | ----------- |
+| callback | Function | fn(error) |
+
+## deleteVolumeAndWait(params, options, callback)
+
+Similar to `deleteVolume`, but waits for the volume to not be in state
+`deleting` (not necessarily deleted) before calling `callback`.
+
+If the volume cannot be found, `callback` is called with no error as its first parameter. If the volume transitions to the state `failed` or `ready`, `callback` is called with an error as its first parameter.
+
+The following params are allowed:
+
+| Name | Type | Description |
+| ---- | ---- | ----------- |
+| uuid | String | UUID of the volume to delete |
+| owner_uuid | UUID | When present, the volume's owner UUID will be checked against this parameter. If it doesn't match, the request will result in an error  |
+| force | Boolean | `true` means that a volume will be deleted even if active VMs reference it. Default is `false`. |
+
+The following options are allowed:
+
+| Name | Type | Description |
+| ---- | ---- | ----------- |
+| headers | Object | a set of headers to add to the request (e.g a request ID |
+| log | Object | a logger that will be used to log messages about this request |
+| timeout | Number | the delay in miliseconds after which `callback` is called with an error as its first parameters regardless of the state of the volume |
+
+The function callback takes the following form
+
+| Name | Type | Description |
+| ---- | ---- | ----------- |
+| callback | Function | fn(error) |
+
+## updateVolume(params, options, callback)
+
+Updates a volume, currently only allows to change a volume's `name` property.
+
+| Name | Type | Description |
+| ---- | ---- | ----------- |
+| uuid | String | UUID of the volume to delete |
+| owner_uuid | UUID | When present, the volume's owner UUID will be checked against this parameter. If it doesn't match, the request will result in an error  |
+| name | String | The new name of the volume with uuid `uuid` |
+
+The following options are allowed:
+
+| Name | Type | Description |
+| ---- | ---- | ----------- |
+| headers | Object | a set of headers to add to the request (e.g a request ID |
+| log | Object | a logger that will be used to log messages about this request |
+
+The function callback takes the following form
+
+| Name | Type | Description |
+| ---- | ---- | ----------- |
+| callback | Function | fn(error) |
+
+## createVolumeReservation(params, options, callback)
+
+Reserves a volume. For more information on volume reservations, please refer to
+[the relevant section of RFD
+26](https://github.com/joyent/rfd/blob/master/rfd/0026/README.md#volume-reservations).
+
+| Name | Type | Description |
+| ---- | ---- | ----------- |
+| volume_name | String | Name of the volume to reserve |
+| owner_uuid | UUID | The owner UUID for the volume to reserve |
+| job_uuid | UUUD | UUID of the job making the volume reservation |
+| vm_uuid | UUUD | UUID of the VM that will mount the reserved volume when it's available |
+
+The following options are allowed:
+
+| Name | Type | Description |
+| ---- | ---- | ----------- |
+| headers | Object | a set of headers to add to the request (e.g a request ID |
+| log | Object | a logger that will be used to log messages about this request |
+
+The function callback takes the following form
+
+| Name | Type | Description |
+| ---- | ---- | ----------- |
+| callback | Function | fn(error) |
+
+## deleteVolumeReservation(params, options, callback)
+
+Removes a volume reservation. If `callback` is called without an error object as
+its first (and only) parameter, the volume associated with the volume reservation is no longer reserved.
+
+For more information on volume reservations, please refer to [the relevant
+section of RFD
+26](https://github.com/joyent/rfd/blob/master/rfd/0026/README.md#volume-reservations).
+
+| Name | Type | Description |
+| ---- | ---- | ----------- |
+| uuid | UUID | The UUID of the volume reservation to remove |
+
+The following options are allowed:
+
+| Name | Type | Description |
+| ---- | ---- | ----------- |
+| headers | Object | a set of headers to add to the request (e.g a request ID |
+| log | Object | a logger that will be used to log messages about this request |
+
+The function callback takes the following form
+
+| Name | Type | Description |
+| ---- | ---- | ----------- |
+| callback | Function | fn(error) |
+
+## addVolumeReference(params, options, callback)
+
+Adds a reference from a VM to a volume.
+
+For more information about volume references, please refer to [the relevant
+section of RFD 26](https://github.com/joyent/rfd/blob/master/rfd/0026/README.md#deletion-and-usage-semantics).
+
+| Name | Type | Description |
+| ---- | ---- | ----------- |
+| volume_uuid | UUID | The UUID of the volume to which the reference should be added |
+| vm_uuid | UUID | The UUID of the VM from which the reference should be added |
+
+The following options are allowed:
+
+| Name | Type | Description |
+| ---- | ---- | ----------- |
+| headers | Object | a set of headers to add to the request (e.g a request ID |
+| log | Object | a logger that will be used to log messages about this request |
+
+The function callback takes the following form
+
+| Name | Type | Description |
+| ---- | ---- | ----------- |
+| callback | Function | fn(error) |
+
+## removeVolumeReference(params, options, callback)
+
+Removes a reference from a VM to a volume.
+
+For more information about volume references, please refer to [the relevant
+section of RFD 26](https://github.com/joyent/rfd/blob/master/rfd/0026/README.md#deletion-and-usage-semantics).
+
+| Name | Type | Description |
+| ---- | ---- | ----------- |
+| volume_uuid | UUID | The UUID of the volume to which the reference should be removed |
+| vm_uuid | UUID | The UUID of the VM from which the reference should be removed |
+
+The following options are allowed:
+
+| Name | Type | Description |
+| ---- | ---- | ----------- |
+| headers | Object | a set of headers to add to the request (e.g a request ID |
+| log | Object | a logger that will be used to log messages about this request |
+
+The function callback takes the following form
+
+| Name | Type | Description |
+| ---- | ---- | ----------- |
+| callback | Function | fn(error) |
+
+## listVolumeSizes(parans, options, callback)
+
+List the sizes available when creating new volumes
+
+| Name | Type | Description |
+| ---- | ---- | ----------- |
+| type | String | The volume type (e.g `tritonnfs`) for which to list available sizes. Default value is `tritonnfs`|
+
+The following options are allowed:
+
+| Name | Type | Description |
+| ---- | ---- | ----------- |
+| headers | Object | a set of headers to add to the request (e.g a request ID |
+| log | Object | a logger that will be used to log messages about this request |
+
+The function callback takes the following form
+
+| Name | Type | Description |
+| ---- | ---- | ----------- |
+| callback | Function | fn(error, volumeSizes) |
\ No newline at end of file
diff --git a/lib/index.js b/lib/index.js
index 894f45f..4d53ab8 100644
--- a/lib/index.js
+++ b/lib/index.js
@@ -41,5 +41,8 @@ module.exports = {
     },
     get CNS() {
         return require('./cns');
+    },
+    get VOLAPI() {
+        return require('./volapi');
     }
 };
diff --git a/lib/volapi.js b/lib/volapi.js
new file mode 100644
index 0000000..fa91960
--- /dev/null
+++ b/lib/volapi.js
@@ -0,0 +1,535 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+
+/*
+ * Client library for the Triton Volume API (VOLAPI).
+ */
+
+
+var assert = require('assert-plus');
+var jsprim = require('jsprim');
+var util = require('util');
+
+var RestifyClient = require('./restifyclient');
+
+var POLL_VOLUME_STATE_CHANGE_PERIOD_IN_MS = 1000;
+
+function VOLAPI(options) {
+    assert.object(options, 'options');
+    assert.string(options.userAgent, 'options.userAgent');
+
+    var volapiOpts = jsprim.deepCopy(options);
+
+    volapiOpts.version = '~1';
+
+    RestifyClient.call(this, volapiOpts);
+    this.url = volapiOpts.url;
+}
+
+util.inherits(VOLAPI, RestifyClient);
+
+
+VOLAPI.prototype.close = function close() {
+    this.client.close();
+};
+
+function doCreateVolume(client, params, options, callback) {
+    assert.object(client, 'client');
+    assert.object(params, 'params');
+    assert.optionalObject(options, 'options');
+    assert.func(callback, 'callback');
+
+    var opts = {
+        path: '/volumes',
+        headers: {}
+    };
+
+    if (options) {
+        if (options.headers) {
+            opts.headers = options.headers;
+        }
+
+        opts.log = options.log || this.log;
+    }
+
+    return client.post(opts, params, callback);
+}
+
+VOLAPI.prototype.createVolume =
+function createVolume(params, options, callback) {
+    if (typeof (options) === 'function') {
+        callback = options;
+        options = undefined;
+    }
+
+    assert.object(params, 'params');
+    assert.optionalObject(options, 'options');
+    assert.func(callback, 'callback');
+
+    doCreateVolume(this, params, options, callback);
+};
+
+function hrtimeToMs(hrtime) {
+    assert.arrayOfNumber(hrtime, 'hrtime');
+    assert.ok(hrtime.length === 2, 'hrtime must be an array of length 2');
+
+    var MSECS_PER_SEC = 1000;
+    var NSECS_PER_MSEC = 1e6;
+
+    return hrtime[0] * MSECS_PER_SEC + hrtime[1] / NSECS_PER_MSEC;
+}
+
+function pollVolumeStateChange(client, volumeUuid, options, callback) {
+    assert.object(client, 'client');
+    assert.uuid(volumeUuid, 'volumeUuid');
+    assert.object(options, 'options');
+    assert.arrayOfString(options.successStates, 'options.successStates');
+    assert.arrayOfString(options.failureStates, 'options.failureStates');
+    assert.optionalNumber(options.timeout, 'options.timeout');
+    assert.optionalBool(options.successOnVolumeNotFound,
+            'options.successOnVolumeNotFound');
+    assert.func(callback, 'callback');
+
+    var pollStart;
+
+    function _poll() {
+        client.getVolume({
+            uuid: volumeUuid
+        }, function onGetVolume(getVolumeErr, volume) {
+            var latestPollTimeFromStart = process.hrtime(pollStart);
+            var latestPollTimeFromStartInMs =
+                hrtimeToMs(latestPollTimeFromStart);
+
+            var volumeInFailState =
+                options.failureStates.indexOf(volume.state) !== -1;
+            var volumeInSuccessState =
+                options.successStates.indexOf(volume.state) !== -1;
+
+            if (getVolumeErr) {
+                if (options.successOnVolumeNotFound &&
+                    getVolumeErr.statusCode === 404) {
+                    callback();
+                } else {
+                    callback(getVolumeErr, volume);
+                }
+                return;
+            } else if (volumeInFailState) {
+                callback(new Error('Volume in state ' + volume.state +
+                    ' while polling for states ' +
+                    options.successStates.join(', ')));
+                return;
+            } else if (volumeInSuccessState) {
+                callback(null, volume);
+            } else {
+                if (options.timeout === undefined ||
+                    latestPollTimeFromStartInMs < options.timeout) {
+                    setTimeout(_poll, POLL_VOLUME_STATE_CHANGE_PERIOD_IN_MS);
+                } else {
+                    callback(new Error('Timeout when polling for state ' +
+                        'change'));
+                    return;
+                }
+            }
+        });
+    }
+
+    pollStart = process.hrtime();
+    setTimeout(_poll, POLL_VOLUME_STATE_CHANGE_PERIOD_IN_MS);
+}
+
+function pollVolumeCreation(client, volumeUuid, options, callback) {
+    assert.object(client, 'client');
+    assert.uuid(volumeUuid, 'volumeUuid');
+    assert.object(options, 'options');
+    assert.optionalNumber(options.timeout, 'options.timeout');
+    assert.func(callback, 'callback');
+
+    pollVolumeStateChange(client, volumeUuid, {
+        successStates: ['ready'],
+        failureStates: ['failed'],
+        timeout: options.timeout
+    }, callback);
+}
+
+function pollVolumeDeletion(client, volumeUuid, options, callback) {
+    assert.object(client, 'client');
+    assert.uuid(volumeUuid, 'volumeUuid');
+    assert.object(options, 'options');
+    assert.optionalNumber(options.timeout, 'options.timeout');
+    assert.func(callback, 'callback');
+
+    pollVolumeStateChange(client, volumeUuid, {
+        /*
+         * Deleted volumes are not kept in the volumes database, so there's no
+         * success state to check for. Instead, we consider 404 responses to a
+         * GetVolume request to represent a deleted volume.
+         */
+        successOnVolumeNotFound: true,
+        successStates: [],
+        failureStates: ['ready', 'failed'],
+        timeout: options.timeout
+    }, callback);
+}
+
+VOLAPI.prototype.createVolumeAndWait =
+function createVolumeAndWait(params, options, callback) {
+    var createVolOptions = {};
+
+    if (typeof (options) === 'function') {
+        callback = options;
+        options = {};
+    }
+
+    assert.object(params, 'params');
+    assert.optionalObject(options, 'options');
+    assert.func(callback, 'callback');
+
+    var self = this;
+
+    createVolOptions.headers = options.header;
+    createVolOptions.log = options.log;
+
+    doCreateVolume(self, params, createVolOptions,
+        function onVolumeCreated(volumeCreationErr, volume) {
+            if (volumeCreationErr || volume === undefined ||
+                volume.state !== 'creating') {
+                callback(volumeCreationErr, volume);
+                return;
+            } else {
+                pollVolumeCreation(self, volume.uuid, {
+                    timeout: options.timeout
+                }, callback);
+            }
+        });
+};
+
+VOLAPI.prototype.listVolumes = function listVolumes(params, options, callback) {
+    // If only one argument then this is 'find all'
+    if (typeof (params) === 'function') {
+        callback = params;
+        params = {};
+    // If 2 arguments -> (params, callback)
+    } else if (typeof (options) === 'function') {
+        callback = options;
+        options = undefined;
+    }
+
+    assert.optionalObject(params, 'params');
+    assert.optionalObject(options, 'options');
+    assert.func(callback, 'callback');
+
+    var reqOpts = { path: '/volumes', query: params };
+    if (options) {
+        reqOpts.headers = options.headers;
+        reqOpts.log = options.log || this.log;
+    }
+
+    this.get(reqOpts, callback);
+};
+
+VOLAPI.prototype.listVolumeSizes =
+function listVolumeSizes(params, options, callback) {
+    // If only one argument then this is 'find all'
+    if (typeof (params) === 'function') {
+        callback = params;
+        params = {};
+    // If 2 arguments -> (params, callback)
+    } else if (typeof (options) === 'function') {
+        callback = options;
+        options = undefined;
+    }
+
+    assert.optionalObject(params, 'params');
+    assert.optionalObject(options, 'options');
+    assert.func(callback, 'callback');
+
+    var reqOpts = { path: '/volumesizes', query: params };
+    if (options) {
+        reqOpts.headers = options.headers;
+        reqOpts.log = options.log || this.log;
+    }
+
+    this.get(reqOpts, callback);
+};
+
+VOLAPI.prototype.getVolume = function getVolume(params, options, callback) {
+    var query = {};
+
+    // If 2 arguments -> (params, callback)
+    if (typeof (options) === 'function') {
+        callback = options;
+        options = undefined;
+    }
+
+    assert.object(params, 'params');
+    assert.uuid(params.uuid, 'params.uuid');
+    assert.optionalUuid(params.owner_uuid, 'params.owner_uuid');
+    assert.optionalObject(options, 'options');
+    assert.func(callback, 'callback');
+
+    if (params.owner_uuid) {
+        query.owner_uuid = params.owner_uuid;
+    }
+
+    var reqOpts = { path: '/volumes/' + params.uuid, query: query };
+    if (options) {
+        reqOpts.headers = options.headers;
+        reqOpts.log = options.log || this.log;
+    }
+
+    this.get(reqOpts, callback);
+};
+
+function doDeleteVolume(client, params, options, callback) {
+    var query = {};
+
+    assert.object(client, 'client');
+    assert.object(params, 'params');
+    assert.uuid(params.uuid, 'params.uuid');
+    assert.optionalUuid(params.owner_uuid, 'params.owner_uuid');
+    assert.optionalObject(options, 'options');
+    assert.func(callback, 'callback');
+
+    if (params.owner_uuid) {
+        query.owner_uuid = params.owner_uuid;
+    }
+
+    var reqOpts = {
+        path: '/volumes/' + params.uuid,
+        query: query,
+        headers: {}
+    };
+
+    if (options) {
+        if (options.headers) {
+            reqOpts.headers = options.headers;
+        }
+
+        reqOpts.log = options.log || this.log;
+    }
+
+    return client.del(reqOpts, callback);
+}
+
+VOLAPI.prototype.deleteVolume =
+function deleteVolume(params, options, callback) {
+    if (typeof (options) === 'function') {
+        callback = options;
+        options = undefined;
+    }
+
+    doDeleteVolume(this, params, options, callback);
+};
+
+VOLAPI.prototype.deleteVolumeAndWait =
+function deleteVolumeAndWait(params, options, callback) {
+    var deleteVolOptions = {};
+
+    var self = this;
+
+    if (typeof (options) === 'function') {
+        callback = options;
+        options = {};
+    }
+
+    deleteVolOptions.headers = options.headers;
+    deleteVolOptions.log = options.log;
+
+    doDeleteVolume(this, params, options,
+        function onVolumeDeleted(volumeDeletionErr, volume) {
+            if (volumeDeletionErr || volume === undefined ||
+                volume.state !== 'deleting') {
+                callback(volumeDeletionErr, volume);
+            } else {
+                pollVolumeDeletion(self, volume.uuid, {
+                    timeout: options.timeout
+                }, callback);
+            }
+        });
+};
+
+VOLAPI.prototype.updateVolume =
+function updateVolume(params, options, callback) {
+    if (typeof (options) === 'function') {
+        callback = options;
+        options = {};
+    }
+
+    assert.object(params, 'params');
+    assert.uuid(params.uuid, 'params.uuid');
+    assert.optionalObject(options, 'options');
+    assert.func(callback, 'callback');
+
+    var opts = {
+        path: '/volumes/' + params.uuid,
+        headers: {}
+    };
+
+    if (options) {
+        if (options.headers) {
+            opts.headers = options.headers;
+        }
+
+        opts.log = options.log || this.log;
+    }
+
+    return this.post(opts, params, callback);
+};
+
+VOLAPI.prototype.createVolumeReservation =
+function createVolumeReservation(params, options, callback) {
+    if (typeof (options) === 'function') {
+        callback = options;
+        options = {};
+    }
+
+    assert.object(params, 'params');
+    assert.string(params.volume_name, 'params.volume_name');
+    assert.uuid(params.vm_uuid, 'params.vm_uuid');
+    assert.uuid(params.job_uuid, 'params.job_uuid');
+    assert.uuid(params.owner_uuid, 'params.owner_uuid');
+    assert.optionalObject(options, 'options');
+    assert.func(callback, 'callback');
+
+    var opts = {
+        path: '/volumereservations',
+        headers: {}
+    };
+
+    if (options) {
+        if (options.headers) {
+            opts.headers = options.headers;
+        }
+
+        opts.log = options.log || this.log;
+    }
+
+    return this.post(opts, {
+        volume_name: params.volume_name,
+        vm_uuid: params.vm_uuid,
+        job_uuid: params.job_uuid,
+        owner_uuid: params.owner_uuid
+    }, callback);
+};
+
+VOLAPI.prototype.deleteVolumeReservation =
+function deleteVolumeReservation(params, options, callback) {
+    if (typeof (options) === 'function') {
+        callback = options;
+        options = {};
+    }
+
+    var query = {};
+
+    assert.object(params, 'params');
+    assert.string(params.uuid, 'params.uuid');
+    assert.optionalObject(options, 'options');
+    assert.func(callback, 'callback');
+
+    if (params.owner_uuid) {
+        query.owner_uuid = params.owner_uuid;
+    }
+
+    var reqOpts = {
+        path: '/volumereservations/' + params.uuid,
+        query: query,
+        headers: {}
+    };
+
+    if (options) {
+        if (options.headers) {
+            reqOpts.headers = options.headers;
+        }
+
+        reqOpts.log = options.log || this.log;
+    }
+
+    return this.client.del(reqOpts, callback);
+};
+
+VOLAPI.prototype.addVolumeReference =
+function addVolumeReference(params, options, callback) {
+    if (typeof (options) === 'function') {
+        callback = options;
+        options = {};
+    }
+
+    assert.object(params, 'params');
+    assert.uuid(params.volume_uuid, 'params.volume_uuid');
+    assert.uuid(params.vm_uuid, 'params.vm_uuid');
+    assert.optionalObject(options, 'options');
+    assert.func(callback, 'callback');
+
+    var opts = {
+        path: '/volumes/' + params.volume_uuid + '/addreference',
+        headers: {}
+    };
+
+    var requestBody = {
+        vm_uuid: params.vm_uuid,
+        owner_uuid: params.owner_uuid
+    };
+
+    if (options) {
+        if (options.headers) {
+            opts.headers = options.headers;
+        }
+
+        opts.log = options.log || this.log;
+    }
+
+    return this.post(opts, requestBody, callback);
+};
+
+VOLAPI.prototype.removeVolumeReference =
+function removeVolumeReference(params, options, callback) {
+    if (typeof (options) === 'function') {
+        callback = options;
+        options = {};
+    }
+
+    assert.object(params, 'params');
+    assert.uuid(params.volume_uuid, 'params.volume_uuid');
+    assert.uuid(params.vm_uuid, 'params.vm_uuid');
+    assert.optionalObject(options, 'options');
+    assert.func(callback, 'callback');
+
+    var opts = {
+        path: '/volumes/' + params.volume_uuid + '/removereference',
+        headers: {}
+    };
+
+    var requestBody = {
+        vm_uuid: params.vm_uuid,
+        owner_uuid: params.owner_uuid
+    };
+
+    if (options) {
+        if (options.headers) {
+            opts.headers = options.headers;
+        }
+
+        opts.log = options.log || this.log;
+    }
+
+    return this.post(opts, requestBody, callback);
+};
+
+/**
+ * Does a ping check to see if API is still serving requests.
+ *
+ * @param {Function} callback : of the form f(err).
+ */
+VOLAPI.prototype.ping = function (callback) {
+    var opts = { path: '/ping' };
+    this.get(opts, callback);
+};
+
+module.exports = VOLAPI;
diff --git a/package.json b/package.json
index 350aaeb..ab385b6 100644
--- a/package.json
+++ b/package.json
@@ -9,11 +9,12 @@
   },
   "main": "./lib/index.js",
   "dependencies": {
-    "assert-plus": "0.1.5",
+    "assert-plus": "^1.0.0",
     "async": "~0.9.0",
     "backoff": "^2.4.1",
     "bunyan": "^1.8.1",
     "clone": "0.1.8",
+    "jsprim": "1.4.1",
     "lru-cache": "2.3.0",
     "libuuid": "0.2.1",
     "lomstream": "1.1.0",
diff --git a/test/runtests b/test/runtests
index c64ad87..01453f5 100755
--- a/test/runtests
+++ b/test/runtests
@@ -123,6 +123,10 @@ if [[ -n "$opt_headnode" ]]; then
     export PAPI_IP=$(ssh $opt_headnode 'bash /lib/sdc/config.sh -json | json papi_admin_ips | cut -d, -f1')
     export CNS_IP=$(ssh $opt_headnode '/opt/smartdc/bin/sdcadm insts cns -j | json 0.ip')
     export MORAY_IP=$(ssh $opt_headnode '/opt/smartdc/bin/sdcadm insts moray -j | json 0.ip')
+    # sdcadm insts instance-name doesn't exit with an exit code != 0 if a zone
+    # with name "instance-name is not present, so this is safe even if VOLAPI is
+    # not setup on the DC where the tests run.
+    export VOLAPI_IP=$(ssh $opt_headnode '/opt/smartdc/bin/sdcadm insts volapi -j | json 0.ip')
 else
     export AMON_IP=$(bash /lib/sdc/config.sh -json | json amon_admin_ips | cut -d, -f1)
     export CNAPI_IP=$(bash /lib/sdc/config.sh -json | json cnapi_admin_ips | cut -d, -f1)
@@ -135,6 +139,10 @@ else
     export IMGAPI_IP=$(sdcadm insts imgapi -j | json 0.ip)
     export CNS_IP=$(sdcadm insts cns -j | json 0.ip)
     export MORAY_IP=$(sdcadm insts moray -j | json 0.ip)
+    # sdcadm insts instance-name doesn't exit with an exit code != 0 if a zone
+    # with name "instance-name is not present, so this is safe even if VOLAPI is
+    # not setup on the DC where the tests run.
+    export VOLAPI_IP=$(sdcadm insts volapi -j | json 0.ip)
 fi
 
 echo ""
diff --git a/test/volapi.test.js b/test/volapi.test.js
new file mode 100644
index 0000000..61a6e13
--- /dev/null
+++ b/test/volapi.test.js
@@ -0,0 +1,264 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+
+var assert = require('assert-plus');
+var bunyan = require('bunyan');
+var libuuid = require('libuuid');
+var restify = require('restify-clients');
+var test = require('tape');
+
+assert.ok(typeof (process.env.NAPI_IP) === 'string' &&
+    process.env.NAPI_IP !== '', 'NAPI_IP env var must be a non-empty string');
+
+if (!process.env.VOLAPI_IP) {
+    console.log('Could not find VOLAPI core service IP address, skipping.');
+    process.exit(0);
+}
+
+var NAPI = require('../lib/index').NAPI;
+
+var ADMIN_UUID = process.env.UFDS_ADMIN_UUID;
+var ADMIN_FABRIC_NETWORK_UUID;
+var napiClient;
+var NAPI_URL = 'http://' + (process.env.NAPI_IP || '10.99.99.10');
+var TEST_VOLUME_NAME = 'node-sdc-clients-test-volapi-' + libuuid.create();
+var TEST_VOLUME_UUID;
+
+var VOLAPI = require('../lib/index').VOLAPI;
+
+var VOLAPI_IP = process.env.VOLAPI_IP;
+var VOLAPI_URL = 'http://' + VOLAPI_IP;
+
+var volApiClient;
+
+test('volapi', function (tt) {
+    var volumeResOwnerUuid;
+    var volumeResUuid;
+
+    tt.test(' setup', function (t) {
+        var log = bunyan.createLogger({
+            name: 'volapi_unit_test',
+            stream: process.stderr,
+            level: (process.env.LOG_LEVEL || 'info'),
+            serializers: restify.bunyan.serializers
+        });
+
+        volApiClient = new VOLAPI({
+            url: VOLAPI_URL,
+            version: '^1',
+            userAgent: 'node-sdc-clients-volapi-tests',
+            retry: {
+                retries: 1,
+                minTimeout: 1000
+            },
+            log: log
+        });
+
+        t.ok(volApiClient, 'created volapi client');
+
+        t.end();
+    });
+
+    tt.test(' ping', function (t) {
+        volApiClient.ping(function onPing(err) {
+            t.ifErr(err, 'ping should succeed');
+            t.end();
+        });
+    });
+
+    tt.test(' get admin\'s fabric network', function (t) {
+        var log = bunyan.createLogger({
+            name: 'volapi_unit_test',
+            stream: process.stderr,
+            level: (process.env.LOG_LEVEL || 'info'),
+            serializers: bunyan.stdSerializers
+        });
+
+        napiClient = new NAPI({
+            url: NAPI_URL,
+            retry: {
+                retries: 1,
+                minTimeout: 1000
+            },
+            log: log
+        });
+
+        napiClient.listNetworks({
+            owner_uuid: ADMIN_UUID,
+            fabric: true
+        }, function (listNetsErr, networks) {
+            t.ifError(listNetsErr,
+                    'listing fabric networks for the admin user should not ' +
+                        'error');
+            t.ok(networks,
+                'listing fabric networks for the admin user should not ' +
+                    'return an empty list of networks');
+            if (networks) {
+                t.ok(networks.length > 0,
+                    'admin user should have at least one fabric network');
+                ADMIN_FABRIC_NETWORK_UUID = networks[0].uuid;
+            }
+
+            t.end();
+        });
+    });
+
+    tt.test(' create volume', function (t) {
+        var volumeParams = {
+            name: TEST_VOLUME_NAME,
+            owner_uuid: ADMIN_UUID,
+            type: 'tritonnfs',
+            networks: [ADMIN_FABRIC_NETWORK_UUID]
+        };
+
+        volApiClient.createVolumeAndWait(volumeParams,
+            function onVolCreated(volCreateErr, createdVol) {
+                var expectedVolState = 'ready';
+
+                t.ifErr(volCreateErr, 'creating volume ' + TEST_VOLUME_NAME +
+                    'should not error, got error: ' + volCreateErr);
+                t.ok(createdVol, 'createVolumeAndWait should return a volume');
+
+                if (createdVol) {
+                    t.ok(createdVol.uuid,
+                        'newly created volume should have a non-empty "uuid" ' +
+                            'property');
+                    TEST_VOLUME_UUID = createdVol.uuid;
+
+                    t.equal(createdVol.state, expectedVolState,
+                        'newly created volume\'s state should be ' +
+                            expectedVolState);
+                }
+
+                t.end();
+            });
+    });
+
+    tt.test(' list volumes', function (t) {
+        var listVolsParams = {
+            name: TEST_VOLUME_NAME
+        };
+
+        volApiClient.listVolumes(listVolsParams, function (err, objs) {
+            t.ifErr(err, 'listVolumes should succeed');
+            t.ok(objs, 'listVolumes should return object');
+            t.ok(Array.isArray(objs), 'listVolumes object should be an array');
+            t.equal(objs.length, 1, 'listing volume with params ' +
+                listVolsParams + ' should output exactly one volume');
+
+            if (objs.length > 0) {
+                t.equal(objs[0].name, TEST_VOLUME_NAME,
+                        'listed volume should have name ' + TEST_VOLUME_NAME);
+                t.equal(objs[0].type, 'tritonnfs',
+                    'listed volume should have type tritonnfs');
+            }
+
+            t.end();
+        });
+    });
+
+    tt.test(' delete volumes', function (t) {
+        var delVolsParams = {
+            uuid: TEST_VOLUME_UUID
+        };
+
+        assert.optionalUuid(TEST_VOLUME_UUID, 'TEST_VOLUME_UUID');
+        if (!TEST_VOLUME_UUID) {
+            t.end();
+            return;
+        }
+
+        volApiClient.deleteVolumeAndWait(delVolsParams,
+            function onVolDeleted(delVolErr) {
+                t.ifErr(delVolErr, 'deleting volume with params ' +
+                    delVolsParams + 'should not error');
+                t.end();
+            });
+    });
+
+    tt.test(' list volume sizes', function (t) {
+        volApiClient.listVolumeSizes(function (err, objs) {
+            var expectedVolumeType = 'tritonnfs';
+
+            t.ifError(err, 'ListVolumeSizes should succeed');
+            t.ok(objs, 'should have received object from ListVolumeSizes');
+            t.ok(Array.isArray(objs), 'volume sizes object should be array');
+            t.ok(objs.length > 0,
+                'volume sizes array should have at least 1 size object');
+            t.ok(objs[0].size, 'expected value for size, got: ' + objs[0].size);
+            t.equal(objs[0].type, expectedVolumeType,
+                'description should be ' + expectedVolumeType + ', got: ' +
+                    objs[0].type);
+            t.end();
+        });
+    });
+
+    tt.test(' create volume reservation', function (t) {
+        volApiClient.createVolumeReservation({
+            volume_name: 'foo',
+            vm_uuid: libuuid.create(),
+            job_uuid: libuuid.create(),
+            owner_uuid: libuuid.create()
+        }, function onVolResCreated(resCreatErr, res) {
+            t.ifError(resCreatErr,
+                'creating volume reservation should not error');
+
+            if (!resCreatErr) {
+                t.ok(typeof (res) === 'object' && res !== null,
+                    'response should be an object');
+
+                if (res) {
+                    volumeResOwnerUuid = res.owner_uuid;
+                    volumeResUuid = res.uuid;
+
+                    t.ok(res.uuid,
+                        'reservation object should have a uuid property');
+                    t.ok(res.volume_name,
+                        'reservation object should have a volume_name ' +
+                            'property');
+                    t.ok(res.vm_uuid,
+                        'reservation object should have a vm_uuid property');
+                    t.ok(res.job_uuid,
+                        'reservation object should have a job_uuid property');
+                    t.ok(res.owner_uuid,
+                        'reservation object should have a owner_uuid property');
+                    t.ok(res.create_timestamp,
+                        'reservation object should have a create_timestamp ' +
+                            'property');
+                }
+            }
+
+            t.end();
+        });
+    });
+
+    tt.test(' delete volume reservation', function (t) {
+        if (volumeResOwnerUuid && volumeResUuid) {
+            volApiClient.deleteVolumeReservation({
+                uuid: volumeResUuid,
+                owner_uuid: volumeResOwnerUuid
+            }, function onVolResDeleted(resDelErr) {
+                t.ifError(resDelErr, 'deleting volume reservation with UUID ' +
+                    volumeResUuid + ' should not error');
+                t.end();
+            });
+        } else {
+            t.fail('Missing volume reservation uuid or volume reservation ' +
+                'owner uuid');
+            t.end();
+        }
+    });
+
+    tt.test(' teardown', function (t) {
+        napiClient.close();
+        volApiClient.close();
+        t.end();
+    });
+});
