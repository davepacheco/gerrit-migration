commit 766cc5692d4725ae13e1388f409f7e6a0abb8b1e (refs/changes/21/2521/1)
Author: Julien Gilli <julien.gilli@joyent.com>
Date:   2017-09-08T10:24:54-04:00 (2 years, 1 month ago)
    
    DOCKER-793: First pass for NFS shared volumes
    DOCKER-863: Create shared volume when mounting nonexistent volume
    VOLAPI-9 Implement asynchronous NFS shared volume creation
    PUBAPI-1300 Implement CRUD volumes endpoints
    VOLAPI-50 Add ListVolumeSizes endpoint
    VOLAPI-50 Add ListVolumeSizes endpoint (disambiguate endpoint)
    DOCKER-1034 support docker volume ls -f dangling=true
    TOOLS-1855 complete documentation about new volumes APIs
    TOOLS-1856 complete node-sdc-clients' new volume APIs' tests suite

diff --git a/CHANGES.md b/CHANGES.md
index 18e3185..77b8ba6 100644
--- a/CHANGES.md
+++ b/CHANGES.md
@@ -8,7 +8,7 @@
 
 ## not yet released
 
-(nothing yet)
+- Add volume APIs.
 
 ## 10.3.0
 
diff --git a/docs/index.md b/docs/index.md
index 507ec84..b740fe9 100644
--- a/docs/index.md
+++ b/docs/index.md
@@ -338,3 +338,256 @@ peer.
 | Name     | Type     | Description     |
 | -------- | -------- | --------------- |
 | callback | Function | fn(error, objs) |
+
+# VOLAPI Client
+
+VOLAPI is the Volumes API. More documentation about this API can be found in
+[its code repository](https://www.github.com/joyent/sdc-volapi) and in [RFD
+26](https://github.com/joyent/rfd/blob/master/rfd/0026).
+
+## listVolumes(params, callback)
+
+List all volumes given the specified filter params. Currently the following
+parameters are allowed:
+
+| Name | Type | Description |
+| ---- | ---- | ----------- |
+| owner_uuid | UUID | VM Owner |
+| name | String | volume name  |
+| type | String | volume type (`'tritonnfs` is currently the only supported type) |
+| size | String | volume size  |
+| state| String | volume state |
+| predicate | String | URL encoded JSON string representing a JavaScript object that can be used to build a LDAP filter. This LDAP filter can search for volumes on arbitrary (indexed) properties |
+
+The function callback takes the following form
+
+| Name | Type | Description |
+| ---- | ---- | ----------- |
+| callback | Function | fn(error, volumes) |
+
+## createVolume(params, options, callback)
+
+Creates a new volume. The following params are allowed:
+
+| Name | Type | Description |
+| ---- | ---- | ----------- |
+| uuid | String | UUID of the volume. If not present, it is automatically generated |
+| name | String | Name of the volume |
+| owner_uuid | UUID | UUID the created volume's owner |
+| type | String | volume type (`'tritonnfs` is currently the only supported type) |
+| networks | Array | An array of network UUIDs representing networks on which this volume will be reachable |
+| size | Number | The desired storage capacity for that volume in mebibytes. Default value is 10240 mebibytes (10 gibibytes) |
+
+The following options are allowed:
+
+| Name | Type | Description |
+| ---- | ---- | ----------- |
+| headers | Object | a set of headers to add to the request (e.g a request ID |
+| log | Object | a logger that will be used to log messages about this request |
+
+The function callback takes the following form
+
+| Name | Type | Description |
+| ---- | ---- | ----------- |
+| callback | Function | fn(error, volume) |
+
+## createVolumeAndWait(params, options, callback)
+
+Similar to `createVolume`, but waits for the volume to not be in state
+`creating` (not necessarily in state `running`) before calling `callback`.
+
+## getVolume(params, options, callback)
+
+Gets information about an existing volume. The following params are allowed:
+
+| Name | Type | Description |
+| ---- | ---- | ----------- |
+| uuid | String | UUID of the volume |
+| owner_uuid | UUID | When present, the volume's owner UUID will be checked against this parameter. If it doesn't match, the request will result in an error  |
+
+The following options are allowed:
+
+| Name | Type | Description |
+| ---- | ---- | ----------- |
+| headers | Object | a set of headers to add to the request (e.g a request ID |
+| log | Object | a logger that will be used to log messages about this request |
+
+The function callback takes the following form
+
+| Name | Type | Description |
+| ---- | ---- | ----------- |
+| callback | Function | fn(error, volume) |
+
+## deleteVolume(params, options, callback)
+
+Deletes an existing volume. The following params are allowed:
+
+| Name | Type | Description |
+| ---- | ---- | ----------- |
+| uuid | String | UUID of the volume to delete |
+| owner_uuid | UUID | When present, the volume's owner UUID will be checked against this parameter. If it doesn't match, the request will result in an error  |
+| force | Boolean | `true` means that a volume will be deleted even if active VMs reference it. Default is `false`. |
+
+The following options are allowed:
+
+| Name | Type | Description |
+| ---- | ---- | ----------- |
+| headers | Object | a set of headers to add to the request (e.g a request ID |
+| log | Object | a logger that will be used to log messages about this request |
+
+The function callback takes the following form
+
+| Name | Type | Description |
+| ---- | ---- | ----------- |
+| callback | Function | fn(error) |
+
+## deleteVolumeAndWait(params, options, callback)
+
+Similar to `deleteVolume`, but waits for the volume to not be in state
+`deleting` (not necessarily deleted) before calling `callback`.
+
+## updateVolume(params, options, callback)
+
+Updates a volume, currently only allows to change volumes' `name`.
+
+| Name | Type | Description |
+| ---- | ---- | ----------- |
+| uuid | String | UUID of the volume to delete |
+| owner_uuid | UUID | When present, the volume's owner UUID will be checked against this parameter. If it doesn't match, the request will result in an error  |
+| name | String | The new name of the volume with uuid `uuid` |
+
+The following options are allowed:
+
+| Name | Type | Description |
+| ---- | ---- | ----------- |
+| headers | Object | a set of headers to add to the request (e.g a request ID |
+| log | Object | a logger that will be used to log messages about this request |
+
+The function callback takes the following form
+
+| Name | Type | Description |
+| ---- | ---- | ----------- |
+| callback | Function | fn(error) |
+
+## reserveVolume(params, options, callback)
+
+Reserves a volume. For more information on volume reservations, please refer to
+[the relevant section of RFD
+26](https://github.com/joyent/rfd/blob/master/rfd/0026/README.md#volume-reservations).
+
+| Name | Type | Description |
+| ---- | ---- | ----------- |
+| volume_name | String | Name of the volume to reserve |
+| owner_uuid | UUID | The owner UUID for the volume to reserve |
+| job_uuid | UUUD | UUID of the job making the volume reservation |
+| vm_uuid | UUUD | UUID of the VM that will mount the reserved volume when it's available |
+
+The following options are allowed:
+
+| Name | Type | Description |
+| ---- | ---- | ----------- |
+| headers | Object | a set of headers to add to the request (e.g a request ID |
+| log | Object | a logger that will be used to log messages about this request |
+
+The function callback takes the following form
+
+| Name | Type | Description |
+| ---- | ---- | ----------- |
+| callback | Function | fn(error) |
+
+## removeVolumeReservation(params, options, callback)
+
+Removes a volume reservation. If `callback` is called without an error object as
+its first (and only) parameter, the volume associated with the volume reservation is no longer reserved.
+
+For more information on volume reservations, please refer to [the relevant
+section of RFD
+26](https://github.com/joyent/rfd/blob/master/rfd/0026/README.md#volume-reservations).
+
+| Name | Type | Description |
+| ---- | ---- | ----------- |
+| uuid | UUID | The UUID of the volume reservation to remove |
+
+The following options are allowed:
+
+| Name | Type | Description |
+| ---- | ---- | ----------- |
+| headers | Object | a set of headers to add to the request (e.g a request ID |
+| log | Object | a logger that will be used to log messages about this request |
+
+The function callback takes the following form
+
+| Name | Type | Description |
+| ---- | ---- | ----------- |
+| callback | Function | fn(error) |
+
+## addVolumeReference(params, options, callback)
+
+Adds a reference from a VM to a volume.
+
+For more information about volume references, please refer to [the relevant
+section of RFD 26](https://github.com/joyent/rfd/blob/master/rfd/0026/README.md#deletion-and-usage-semantics).
+
+| Name | Type | Description |
+| ---- | ---- | ----------- |
+| volume_uuid | UUID | The UUID of the volume to which the reference should be added |
+| vm_uuid | UUID | The UUID of the VM from which the reference should be added |
+
+The following options are allowed:
+
+| Name | Type | Description |
+| ---- | ---- | ----------- |
+| headers | Object | a set of headers to add to the request (e.g a request ID |
+| log | Object | a logger that will be used to log messages about this request |
+
+The function callback takes the following form
+
+| Name | Type | Description |
+| ---- | ---- | ----------- |
+| callback | Function | fn(error) |
+
+## removeVolumeReference(params, options, callback)
+
+Removes a reference from a VM to a volume.
+
+For more information about volume references, please refer to [the relevant
+section of RFD 26](https://github.com/joyent/rfd/blob/master/rfd/0026/README.md#deletion-and-usage-semantics).
+
+| Name | Type | Description |
+| ---- | ---- | ----------- |
+| volume_uuid | UUID | The UUID of the volume to which the reference should be removed |
+| vm_uuid | UUID | The UUID of the VM from which the reference should be removed |
+
+The following options are allowed:
+
+| Name | Type | Description |
+| ---- | ---- | ----------- |
+| headers | Object | a set of headers to add to the request (e.g a request ID |
+| log | Object | a logger that will be used to log messages about this request |
+
+The function callback takes the following form
+
+| Name | Type | Description |
+| ---- | ---- | ----------- |
+| callback | Function | fn(error) |
+
+## listVolumeSizes(parans, options, callback)
+
+List the sizes available when creating new volumes
+
+| Name | Type | Description |
+| ---- | ---- | ----------- |
+| type | String | The volume type (e.g `tritonnfs`) for which to list available sizes. Default value is `tritonnfs`|
+
+The following options are allowed:
+
+| Name | Type | Description |
+| ---- | ---- | ----------- |
+| headers | Object | a set of headers to add to the request (e.g a request ID |
+| log | Object | a logger that will be used to log messages about this request |
+
+The function callback takes the following form
+
+| Name | Type | Description |
+| ---- | ---- | ----------- |
+| callback | Function | fn(error, volumeSizes) |
\ No newline at end of file
diff --git a/lib/index.js b/lib/index.js
index 894f45f..4d53ab8 100644
--- a/lib/index.js
+++ b/lib/index.js
@@ -41,5 +41,8 @@ module.exports = {
     },
     get CNS() {
         return require('./cns');
+    },
+    get VOLAPI() {
+        return require('./volapi');
     }
 };
diff --git a/lib/volapi.js b/lib/volapi.js
new file mode 100644
index 0000000..067423a
--- /dev/null
+++ b/lib/volapi.js
@@ -0,0 +1,450 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+
+var assert = require('assert-plus');
+var util = require('util');
+
+var RestifyClient = require('./restifyclient');
+
+var POLL_VOLUME_STATE_CHANGE_PERIOD_IN_MS = 1000;
+
+function VOLAPI(options) {
+    assert.object(options, 'options');
+    assert.string(options.version, 'options.version');
+    assert.notEqual(options.version, '*');
+    assert.string(options.userAgent, 'options.userAgent');
+
+    RestifyClient.call(this, options);
+    this.url = options.url;
+}
+
+util.inherits(VOLAPI, RestifyClient);
+
+
+VOLAPI.prototype.close = function close() {
+    this.client.close();
+};
+
+function doCreateVolume(client, params, options, callback) {
+    assert.object(client, 'client');
+    assert.object(params, 'params');
+    assert.optionalObject(options, 'options');
+    assert.func(callback, 'callback');
+
+    var opts = {
+        path: '/volumes',
+        headers: {}
+    };
+
+    if (options) {
+        if (options.headers) {
+            opts.headers = options.headers;
+        }
+
+        opts.log = options.log || this.log;
+    }
+
+    return client.post(opts, params, callback);
+}
+
+VOLAPI.prototype.createVolume =
+function createVolume(params, options, callback) {
+    if (typeof (options) === 'function') {
+        callback = options;
+        options = undefined;
+    }
+
+    assert.object(params, 'params');
+    assert.optionalObject(options, 'options');
+    assert.func(callback, 'callback');
+
+    doCreateVolume(this, params, options, callback);
+};
+
+function pollVolumeStateChange(client, volumeUuid, state, callback) {
+    assert.object(client, 'client');
+    assert.uuid(volumeUuid, 'volumeUuid');
+    assert.string(state, 'state');
+    assert.func(callback, 'callback');
+
+    function _poll() {
+        client.getVolume({
+            uuid: volumeUuid
+        }, function onGetVolume(getVolumeErr, volume) {
+            if (getVolumeErr || volume.state === state) {
+                callback(getVolumeErr, volume);
+                return;
+            } else {
+                setTimeout(_poll, POLL_VOLUME_STATE_CHANGE_PERIOD_IN_MS);
+            }
+        });
+    }
+
+    setTimeout(_poll, POLL_VOLUME_STATE_CHANGE_PERIOD_IN_MS);
+}
+
+function pollVolumeCreation(client, volumeUuid, callback) {
+    assert.object(client, 'client');
+    assert.uuid(volumeUuid, 'volumeUuid');
+    assert.func(callback, 'callback');
+
+    pollVolumeStateChange(client, volumeUuid, 'ready', callback);
+}
+
+function pollVolumeDeletion(client, volumeUuid, callback) {
+    assert.object(client, 'client');
+    assert.uuid(volumeUuid, 'volumeUuid');
+    assert.func(callback, 'callback');
+
+    pollVolumeStateChange(client, volumeUuid, 'deleted', callback);
+}
+
+VOLAPI.prototype.createVolumeAndWait =
+function createVolumeAndWait(params, options, callback) {
+    if (typeof (options) === 'function') {
+        callback = options;
+        options = undefined;
+    }
+
+    assert.object(params, 'params');
+    assert.optionalObject(options, 'options');
+    assert.func(callback, 'callback');
+
+    var self = this;
+
+    doCreateVolume(self, params, options,
+        function onVolumeCreated(volumeCreationErr, volume) {
+            if (volumeCreationErr || volume === undefined ||
+                volume.state !== 'creating') {
+                callback(volumeCreationErr, volume);
+                return;
+            } else {
+                pollVolumeCreation(self, volume.uuid, callback);
+            }
+        });
+};
+
+VOLAPI.prototype.listVolumes = function listVolumes(params, options, callback) {
+    // If only one argument then this is 'find all'
+    if (typeof (params) === 'function') {
+        callback = params;
+        params = {};
+    // If 2 arguments -> (params, callback)
+    } else if (typeof (options) === 'function') {
+        callback = options;
+        options = undefined;
+    }
+
+    assert.optionalObject(params, 'params');
+    assert.optionalObject(options, 'options');
+    assert.func(callback, 'callback');
+
+    var reqOpts = { path: '/volumes', query: params };
+    if (options) {
+        reqOpts.headers = options.headers;
+        reqOpts.log = options.log || this.log;
+    }
+
+    this.get(reqOpts, callback);
+};
+
+VOLAPI.prototype.listVolumeSizes =
+function listVolumeSizes(params, options, callback) {
+    // If only one argument then this is 'find all'
+    if (typeof (params) === 'function') {
+        callback = params;
+        params = {};
+    // If 2 arguments -> (params, callback)
+    } else if (typeof (options) === 'function') {
+        callback = options;
+        options = undefined;
+    }
+
+    assert.optionalObject(params, 'params');
+    assert.optionalObject(options, 'options');
+    assert.func(callback, 'callback');
+
+    var reqOpts = { path: '/volumesizes', query: params };
+    if (options) {
+        reqOpts.headers = options.headers;
+        reqOpts.log = options.log || this.log;
+    }
+
+    this.get(reqOpts, callback);
+};
+
+VOLAPI.prototype.getVolume = function getVolume(params, options, callback) {
+    var query = {};
+
+    // If 2 arguments -> (params, callback)
+    if (typeof (options) === 'function') {
+        callback = options;
+        options = undefined;
+    }
+
+    assert.object(params, 'params');
+    assert.string(params.uuid, 'params.uuid');
+    assert.optionalObject(options, 'options');
+    assert.func(callback, 'callback');
+
+    if (params.owner_uuid) {
+        query.owner_uuid = params.owner_uuid;
+    }
+
+    var reqOpts = { path: '/volumes/' + params.uuid, query: query };
+    if (options) {
+        reqOpts.headers = options.headers;
+        reqOpts.log = options.log || this.log;
+    }
+
+    this.get(reqOpts, callback);
+};
+
+function doDeleteVolume(client, params, options, callback) {
+    var query = {};
+
+    assert.object(client, 'client');
+    assert.object(params, 'params');
+    assert.string(params.uuid, 'params.uuid');
+    assert.optionalObject(options, 'options');
+    assert.func(callback, 'callback');
+
+    if (params.owner_uuid) {
+        query.owner_uuid = params.owner_uuid;
+    }
+
+    var reqOpts = {
+        path: '/volumes/' + params.uuid,
+        query: query,
+        headers: {}
+    };
+
+    if (options) {
+        if (options.headers) {
+            reqOpts.headers = options.headers;
+        }
+
+        reqOpts.log = options.log || this.log;
+    }
+
+    return client.del(reqOpts, callback);
+}
+
+VOLAPI.prototype.deleteVolume =
+    function deleteVolume(params, options, callback) {
+
+        if (typeof (options) === 'function') {
+            callback = options;
+            options = undefined;
+        }
+
+        doDeleteVolume(this, params, options, callback);
+    };
+
+VOLAPI.prototype.deleteVolumeAndWait =
+    function deleteVolumeAndWait(params, options, callback) {
+
+        var self = this;
+
+        if (typeof (options) === 'function') {
+            callback = options;
+            options = undefined;
+        }
+
+        doDeleteVolume(this, params, options,
+            function onVolumeDeleted(volumeDeletionErr, volume) {
+                if (volumeDeletionErr || volume === undefined ||
+                    volume.state !== 'deleting') {
+                    callback(volumeDeletionErr, volume);
+                    return;
+                } else {
+                    pollVolumeDeletion(self, volume.uuid, callback);
+                }
+            });
+    };
+
+VOLAPI.prototype.updateVolume =
+    function updateVolume(params, options, callback) {
+        if (typeof (options) === 'function') {
+            callback = options;
+            options = {};
+        }
+
+        assert.object(params, 'params');
+        assert.uuid(params.uuid, 'params.uuid');
+        assert.optionalObject(options, 'options');
+        assert.func(callback, 'callback');
+
+        var opts = {
+            path: '/volumes/' + params.uuid,
+            headers: {}
+        };
+
+        if (options) {
+            if (options.headers) {
+                opts.headers = options.headers;
+            }
+
+            opts.log = options.log || this.log;
+        }
+
+        return this.post(opts, params, callback);
+    };
+
+VOLAPI.prototype.reserveVolume =
+    function reserveVolume(params, options, callback) {
+        if (typeof (options) === 'function') {
+            callback = options;
+            options = {};
+        }
+
+        assert.object(params, 'params');
+        assert.string(params.volume_name, 'params.volume_name');
+        assert.uuid(params.vm_uuid, 'params.vm_uuid');
+        assert.uuid(params.job_uuid, 'params.job_uuid');
+        assert.uuid(params.owner_uuid, 'params.owner_uuid');
+        assert.optionalObject(options, 'options');
+        assert.func(callback, 'callback');
+
+        var opts = {
+            path: '/volumereservations',
+            headers: {}
+        };
+
+        if (options) {
+            if (options.headers) {
+                opts.headers = options.headers;
+            }
+
+            opts.log = options.log || this.log;
+        }
+
+        return this.post(opts, {
+            volume_name: params.volume_name,
+            vm_uuid: params.vm_uuid,
+            job_uuid: params.job_uuid,
+            owner_uuid: params.owner_uuid
+        }, callback);
+    };
+
+VOLAPI.prototype.removeVolumeReservation =
+    function removeVolumeReservation(params, options, callback) {
+        if (typeof (options) === 'function') {
+            callback = options;
+            options = {};
+        }
+
+        var query = {};
+
+        assert.object(params, 'params');
+        assert.string(params.uuid, 'params.uuid');
+        assert.optionalObject(options, 'options');
+        assert.func(callback, 'callback');
+
+        if (params.owner_uuid) {
+            query.owner_uuid = params.owner_uuid;
+        }
+
+        var reqOpts = {
+            path: '/volumes/' + params.uuid,
+            query: query,
+            headers: {}
+        };
+
+        if (options) {
+            if (options.headers) {
+                reqOpts.headers = options.headers;
+            }
+
+            reqOpts.log = options.log || this.log;
+        }
+
+        return this.client.del(reqOpts, callback);
+    };
+
+VOLAPI.prototype.addVolumeReference =
+    function addVolumeReference(params, options, callback) {
+        if (typeof (options) === 'function') {
+            callback = options;
+            options = {};
+        }
+
+        assert.object(params, 'params');
+        assert.uuid(params.volume_uuid, 'params.volume_uuid');
+        assert.uuid(params.vm_uuid, 'params.vm_uuid');
+        assert.optionalObject(options, 'options');
+        assert.func(callback, 'callback');
+
+        var opts = {
+            path: '/volumes/' + params.volume_uuid + '/addreference',
+            headers: {}
+        };
+
+        var requestBody = {
+            vm_uuid: params.vm_uuid,
+            owner_uuid: params.owner_uuid
+        };
+
+        if (options) {
+            if (options.headers) {
+                opts.headers = options.headers;
+            }
+
+            opts.log = options.log || this.log;
+        }
+
+        return this.post(opts, requestBody, callback);
+    };
+
+VOLAPI.prototype.removeVolumeReference =
+    function removeVolumeReference(params, options, callback) {
+        if (typeof (options) === 'function') {
+            callback = options;
+            options = {};
+        }
+
+        assert.object(params, 'params');
+        assert.uuid(params.volume_uuid, 'params.volume_uuid');
+        assert.uuid(params.vm_uuid, 'params.vm_uuid');
+        assert.optionalObject(options, 'options');
+        assert.func(callback, 'callback');
+
+        var opts = {
+            path: '/volumes/' + params.volume_uuid + '/removereference',
+            headers: {}
+        };
+
+        var requestBody = {
+            vm_uuid: params.vm_uuid,
+            owner_uuid: params.owner_uuid
+        };
+
+        if (options) {
+            if (options.headers) {
+                opts.headers = options.headers;
+            }
+
+            opts.log = options.log || this.log;
+        }
+
+        return this.post(opts, requestBody, callback);
+    };
+
+/**
+ * Does a ping check to see if API is still serving requests.
+ *
+ * @param {Function} callback : of the form f(err).
+ */
+VOLAPI.prototype.ping = function (callback) {
+    var opts = { path: '/ping' };
+    this.get(opts, callback);
+};
+
+module.exports = VOLAPI;
diff --git a/package.json b/package.json
index 350aaeb..13b9ca8 100644
--- a/package.json
+++ b/package.json
@@ -9,7 +9,7 @@
   },
   "main": "./lib/index.js",
   "dependencies": {
-    "assert-plus": "0.1.5",
+    "assert-plus": "^1.0.0",
     "async": "~0.9.0",
     "backoff": "^2.4.1",
     "bunyan": "^1.8.1",
diff --git a/test/runtests b/test/runtests
index c64ad87..01453f5 100755
--- a/test/runtests
+++ b/test/runtests
@@ -123,6 +123,10 @@ if [[ -n "$opt_headnode" ]]; then
     export PAPI_IP=$(ssh $opt_headnode 'bash /lib/sdc/config.sh -json | json papi_admin_ips | cut -d, -f1')
     export CNS_IP=$(ssh $opt_headnode '/opt/smartdc/bin/sdcadm insts cns -j | json 0.ip')
     export MORAY_IP=$(ssh $opt_headnode '/opt/smartdc/bin/sdcadm insts moray -j | json 0.ip')
+    # sdcadm insts instance-name doesn't exit with an exit code != 0 if a zone
+    # with name "instance-name is not present, so this is safe even if VOLAPI is
+    # not setup on the DC where the tests run.
+    export VOLAPI_IP=$(ssh $opt_headnode '/opt/smartdc/bin/sdcadm insts volapi -j | json 0.ip')
 else
     export AMON_IP=$(bash /lib/sdc/config.sh -json | json amon_admin_ips | cut -d, -f1)
     export CNAPI_IP=$(bash /lib/sdc/config.sh -json | json cnapi_admin_ips | cut -d, -f1)
@@ -135,6 +139,10 @@ else
     export IMGAPI_IP=$(sdcadm insts imgapi -j | json 0.ip)
     export CNS_IP=$(sdcadm insts cns -j | json 0.ip)
     export MORAY_IP=$(sdcadm insts moray -j | json 0.ip)
+    # sdcadm insts instance-name doesn't exit with an exit code != 0 if a zone
+    # with name "instance-name is not present, so this is safe even if VOLAPI is
+    # not setup on the DC where the tests run.
+    export VOLAPI_IP=$(sdcadm insts volapi -j | json 0.ip)
 fi
 
 echo ""
diff --git a/test/volapi.test.js b/test/volapi.test.js
new file mode 100644
index 0000000..9af386d
--- /dev/null
+++ b/test/volapi.test.js
@@ -0,0 +1,228 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+
+var bunyan = require('bunyan');
+var libuuid = require('libuuid');
+var restify = require('restify-clients');
+var test = require('tape');
+
+var NAPI = require('../lib/index').NAPI;
+
+var ADMIN_UUID = process.env.UFDS_ADMIN_UUID;
+var ADMIN_FABRIC_NETWORK_UUID;
+var NAPI_CLIENT;
+var NAPI_URL = 'http://' + (process.env.NAPI_IP || '10.99.99.10');
+var TEST_VOLUME_NAME = 'node-sdc-clients-test-volapi-' + libuuid.create();
+var TEST_VOLUME_UUID;
+
+var VOLAPI = require('../lib/index').VOLAPI;
+
+var VOLAPI_IP = process.env.VOLAPI_IP || '10.99.99.70';
+var VOLAPI_URL = 'http://' + VOLAPI_IP;
+
+var volApiClient;
+
+test('volapi', function (tt) {
+    tt.test(' setup', function (t) {
+        var log = bunyan.createLogger({
+            name: 'volapi_unit_test',
+            stream: process.stderr,
+            level: (process.env.LOG_LEVEL || 'info'),
+            serializers: restify.bunyan.serializers
+        });
+
+        volApiClient = new VOLAPI({
+            url: VOLAPI_URL,
+            version: '^1',
+            userAgent: 'node-sdc-clients-volapi-tests',
+            retry: {
+                retries: 1,
+                minTimeout: 1000
+            },
+            log: log
+        });
+
+        t.ok(volApiClient, 'created volapi client');
+
+        t.end();
+    });
+
+    tt.test(' ping', function (t) {
+        volApiClient.ping(function onPing(err) {
+            t.ifErr(err, 'ping should succeed');
+            t.end();
+        });
+    });
+
+    tt.test(' get admin\'s fabric network', function (t) {
+        var log = bunyan.createLogger({
+            name: 'volapi_unit_test',
+            stream: process.stderr,
+            level: (process.env.LOG_LEVEL || 'info'),
+            serializers: bunyan.stdSerializers
+        });
+
+        NAPI_CLIENT = new NAPI({
+            url: NAPI_URL,
+            retry: {
+                retries: 1,
+                minTimeout: 1000
+            },
+            log: log
+        });
+
+        NAPI_CLIENT.listNetworks({
+            owner_uuid: ADMIN_UUID,
+            fabric: true
+        }, function (listNetsErr, networks) {
+            t.ifError(listNetsErr,
+                    'listing fabric networks for the admin user should not ' +
+                        'error');
+            t.ok(networks,
+                'listing fabric networks for the admin user should not ' +
+                    'return an empty list of networks');
+            if (networks) {
+                t.ok(networks.length > 0,
+                    'admin user should have at least one fabric network');
+                ADMIN_FABRIC_NETWORK_UUID = networks[0].uuid;
+            }
+
+            t.end();
+        });
+    });
+
+    tt.test(' create volume', function (t) {
+        var volumeParams = {
+            name: TEST_VOLUME_NAME,
+            owner_uuid: ADMIN_UUID,
+            type: 'tritonnfs',
+            networks: [ADMIN_FABRIC_NETWORK_UUID]
+        };
+
+        volApiClient.createVolumeAndWait(volumeParams,
+            function onVolCreated(volCreateErr, createdVol) {
+                var expectedVolState = 'ready';
+
+                t.ifErr(volCreateErr, 'creating volume ' + TEST_VOLUME_NAME +
+                    'should not error, got error: ' + volCreateErr);
+                t.ok(createdVol, 'createVolumeAndWait should return a volume');
+
+                if (createdVol) {
+                    t.ok(createdVol.uuid,
+                        'newly created volume should have a non-empty "uuid" ' +
+                            'property');
+                    TEST_VOLUME_UUID = createdVol.uuid;
+
+                    t.equal(createdVol.state, expectedVolState,
+                            'newly created volume\'s state should be ' +
+                                expectedVolState);
+                }
+
+                t.end();
+            });
+    });
+
+    tt.test(' list volumes', function (t) {
+        var listVolsParams = {
+            name: TEST_VOLUME_NAME
+        };
+
+        volApiClient.listVolumes(listVolsParams, function (err, objs) {
+            t.ifErr(err, 'listVolumes should succeed');
+            t.ok(objs, 'listVolumes should return object');
+            t.ok(Array.isArray(objs), 'listVolumes object should be an array');
+            t.equal(objs.length, 1, 'listing volume with params ' +
+                listVolsParams + ' should output exactly one volume');
+
+            if (objs.length > 0) {
+                t.equal(objs[0].name, TEST_VOLUME_NAME,
+                        'listed volume should have name ' + TEST_VOLUME_NAME);
+                t.equal(objs[0].type, 'tritonnfs',
+                    'listed volume should have type tritonnfs');
+            }
+
+            t.end();
+        });
+    });
+
+    tt.test(' delete volumes', function (t) {
+        var delVolsParams = {
+            uuid: TEST_VOLUME_UUID
+        };
+
+        if (typeof (TEST_VOLUME_UUID) !== 'string') {
+            t.end();
+            return;
+        }
+
+        volApiClient.deleteVolumeAndWait(delVolsParams,
+            function onVolDeleted(delVolErr) {
+                t.ifErr(delVolErr, 'deleting volume with params ' +
+                    delVolsParams + 'should not error');
+                t.end();
+            });
+    });
+
+    tt.test(' list volume sizes', function (t) {
+        volApiClient.listVolumeSizes(function (err, objs) {
+            var expectedVolumeType = 'tritonnfs';
+
+            t.ifError(err, 'ListVolumeSizes should succeed');
+            t.ok(objs, 'should have received object from ListVolumeSizes');
+            t.ok(Array.isArray(objs), 'volume sizes object should be array');
+            t.ok(objs.length > 0,
+                'volume sizes array should have at least 1 size object');
+            t.ok(objs[0].size, 'expected value for size, got: ' + objs[0].size);
+            t.equal(objs[0].type, expectedVolumeType,
+                'description should be ' + expectedVolumeType + ', got: ' +
+                    objs[0].description);
+            t.end();
+        });
+    });
+
+    tt.test(' api version needs to be specified', function (t) {
+        var apiClient;
+        t.throws(function badClient() {
+            apiClient = new VOLAPI({
+                url: VOLAPI_URL,
+                userAgent: 'node-sdc-clients-volapi-tests'
+            });
+        });
+
+        if (apiClient) {
+            apiClient.close();
+        }
+
+        t.end();
+    });
+
+    tt.test(' api version star not allowed', function (t) {
+        var apiClient;
+        t.throws(function badClient() {
+             apiClient = new VOLAPI({
+                url: VOLAPI_URL,
+                version: '*',
+                userAgent: 'node-sdc-clients-volapi-tests'
+            });
+        });
+
+        if (apiClient) {
+            apiClient.close();
+        }
+
+        t.end();
+    });
+
+    tt.test(' teardown', function (t) {
+        NAPI_CLIENT.close();
+        volApiClient.close();
+        t.end();
+    });
+});
