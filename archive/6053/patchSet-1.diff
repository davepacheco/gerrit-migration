commit e67e8acbfc9ac94557b0b7dfce40017a451d51be
Author: Mike Gerdts <mike.gerdts@joyent.com>
Date:   2019-04-05T18:29:51+00:00 (6 months ago)
    
    OS-7708 nss_ldap needs to cache netgroups

diff --git a/usr/src/cmd/initpkg/nscd.conf b/usr/src/cmd/initpkg/nscd.conf
index a2a06950ce..3ebb50bcd2 100644
--- a/usr/src/cmd/initpkg/nscd.conf
+++ b/usr/src/cmd/initpkg/nscd.conf
@@ -21,14 +21,13 @@
 #
 # Copyright 2006 Sun Microsystems, Inc.  All rights reserved.
 # Use is subject to license terms.
-#
-#ident	"%Z%%M%	%I%	%E% SMI"
+# Copyright 2019 Joyent, Inc.
 #
 
 #
 #	Currently supported cache names:
 #		audit_user, auth_attr, bootparams, ethers
-#		exec_attr, group, hosts, ipnodes, netmasks
+#		exec_attr, group, hosts, ipnodes, netgroup, netmasks
 #		networks, passwd, printers, prof_attr, project
 #		protocols, rpc, services, tnrhdb, tnrhtp, user_attr
 #
@@ -77,6 +76,10 @@
 	keep-hot-count		ipnodes		20
 	check-files		ipnodes		yes
 
+	positive-time-to-live	netgroup	3600
+	negative-time-to-live	netgroup	5
+	enable-cache		netgroup	yes
+
 	positive-time-to-live	netmasks	3600
 	negative-time-to-live	netmasks	5
 	keep-hot-count		netmasks	20
diff --git a/usr/src/lib/nsswitch/Makefile.targ b/usr/src/lib/nsswitch/Makefile.targ
index 399d9be82c..d1fc6976c4 100644
--- a/usr/src/lib/nsswitch/Makefile.targ
+++ b/usr/src/lib/nsswitch/Makefile.targ
@@ -21,15 +21,14 @@
 #
 # Copyright 2006 Sun Microsystems, Inc.  All rights reserved.
 # Use is subject to license terms.
-#
-# ident	"%Z%%M%	%I%	%E% SMI"
+# Copyright 2019 Joyent, Inc.
 #
 
 all:		$(LIBS)
 
 # include global library targets.
 include		$(SRC)/lib/Makefile.targ
-
+include		$(SRC)/lib/Makefile.usdt
 
 $(ROOT32DYNLIB) := FILEMODE= 755
 $(ROOT64DYNLIB) := FILEMODE= 755
@@ -39,7 +38,7 @@ $(DYNLIB1) :=	CTFMERGE_POST = $(CTFMERGE_LIB)
 # DYNLIB1 is used rather than DYNLIB to prevent the automagic expansion and
 # creation of a libXXXX.so$(VERS) target.
 
-$(DYNLIB1):	pics .WAIT $$(PICS)
+$(DYNLIB1):	pics .WAIT $$(PICS) .WAIT $(USDT_PICS)
 		$(BUILD.SO)
 		$(POST_PROCESS_SO)
 
diff --git a/usr/src/lib/nsswitch/ldap/Makefile.com b/usr/src/lib/nsswitch/ldap/Makefile.com
index 694bd5f023..2abe629cb3 100644
--- a/usr/src/lib/nsswitch/ldap/Makefile.com
+++ b/usr/src/lib/nsswitch/ldap/Makefile.com
@@ -21,6 +21,7 @@
 #
 # Copyright 2008 Sun Microsystems, Inc.  All rights reserved.
 # Use is subject to license terms.
+# Copyright 2019 Joyent, Inc.
 #
 
 LIBRARY =	libnss_ldap.a
@@ -50,13 +51,15 @@ OBJECTS =	getauthattr.o	\
 		tsol_getrhent.o	\
 		tsol_gettpent.o	\
 		ldap_common.o	\
-		ldap_utils.o
+		ldap_utils.o	\
+
+USDT_PROVIDERS	= provider.d
 
 # include common nsswitch library definitions.
 include		../../Makefile.com
 
 CPPFLAGS +=	-I../../../libsldap/common
-LDLIBS +=	-lsldap -lnsl -lldap
+LDLIBS +=	-lsldap -lnsl -lldap -lavl -lcmdutils -lscf
 LINTFLAGS +=	-erroff=E_GLOBAL_COULD_BE_STATIC2
 LINTFLAGS64 +=	-erroff=E_GLOBAL_COULD_BE_STATIC2
 DYNLIB1 =	nss_ldap.so$(VERS)
diff --git a/usr/src/lib/nsswitch/ldap/common/getnetgrent.c b/usr/src/lib/nsswitch/ldap/common/getnetgrent.c
index c2ff7466ec..97765336cd 100644
--- a/usr/src/lib/nsswitch/ldap/common/getnetgrent.c
+++ b/usr/src/lib/nsswitch/ldap/common/getnetgrent.c
@@ -21,18 +21,133 @@
 /*
  * Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
+ * Copyright 2019 Joyent, Inc.
  */
 
+/*
+ * nss_ldap netgroup support
+ *
+ * Like other name service switch modules, this code may run in nscd or
+ * arbitrary processes that call getnetgrent(3C), getnetgrent_r(3C),
+ * setnetgrent(3C), endnetgrent(3C), and innetgr(3C).  For a reason that is not
+ * entirely clear ("due to backend knowledge"), libc's nss_pack() instructs
+ * callers of all netgroup functions other than innetgr(3C) to TRY_LOCAL rather
+ * than allowing the query to be passed to nscd.  This is probably of negligible
+ * impact, as modern use of netgroup lookups is almost exclusively through
+ * innetgr(3C).
+ *
+ * Whether being called from libc or nscd, initlalization happens via a call to
+ * _nss_ldap_netgroup_constr().  There is no destructor - rather the library is
+ * closed with dlclose().  This can lead to memory leaks if there are any cached
+ * netgroups.
+ *
+ *
+ * Netgroup Caching
+ *
+ * Caching of netgroups is done within this module because the type of caching
+ * that is most useful for netgroups is a poor fit for nscd.  nscd is focused on
+ * caching individual results, with the assumption that one request doesn't
+ * perform a high cost operation from which a subsequent operation may benefit.
+ * The poster child for this problem is the most common case: innetgr().  The
+ * LDAP NIS schema is poorly designed for innetgr because it forces a full
+ * object transfer for every innetgr call.  Native NIS avoids this with the
+ * revnetgroup map.
+ *
+ * Netgroups are cached only when running as part of the
+ * svc:/system/name-service-cache:default service.  nscd.conf(4) can be used to
+ * configure enable-cache, positive-time-to-live, and negative-time-to-live.
+ *
+ * The cache is implemented as an AVL tree (ngc_cache), with each node of the
+ * tree representing one netgroup.  Nested netgroups are not flattened, implying
+ * that if there are two netgroups that each include a common third netgroup,
+ * there will be three tree nodes.  Expired netgroups that still have references
+ * are migrated from ngc_cache (AVL tree) to ngc_graveyard (list).
+ *
+ * The following functions are intended to be called by those functions that
+ * implement setnetgroup(), endnetgroup(), and innetgr().
+ *
+ * netgroup_get()	On success, a reference counted pointer to a cached
+ *			netgroup is returned.  A call to this function may
+ *			trigger the netgroup to be loaded from LDAP.
+ *			The context that is passed is used to ensure that
+ *			use of memberNisNetgroup does not lead to infinite
+ *			loops.
+ * netgroup_rele()	Releases the reference returned by netgroup_get.
+ *
+ *
+ * Locking
+ *
+ * There is one big lock, ngc_lock.  It must be held while accessing ngc_cache,
+ * ngc_graveyard, or ngc_warm_queue.  It must also be held while accessing the
+ * ng_refcnt field of any netgroup_t that is in any of the ngc_* lists or tree.
+ *
+ * ngc_*() functions operate on netgroup_t objects.  ngc_*_locked() functions
+ * must be called with ngc_lock held and the others expect ngc_lock not to be
+ * held.
+ *
+ *
+ * Expiry
+ *
+ * Clearly, it is not OK to cache data forever without checking to ensure that
+ * it is current.  When a netgroup is loaded from LDAP, its expiration time is
+ * set to ngc_pos_ttl (default NGC_POS_TTL) from the time that it is loaded.
+ * Any queries that start after the expiration time will trigger the netgroup to
+ * be loaded from LDAP again.  Negative (NSS_NOTFOUND) results are also cached
+ * for ngc_neg_ttl seconds.
+ *
+ * To avoid full reloads of netgroups on a regular basis, a netgroup_get() that
+ * occurs in the final 25% of a netgroup's expiry period will trigger a worker
+ * thread to make an LDAP query to check the modifyTimestamp of the relevant
+ * netgroup object.  If the modifyTimestamp has not changed from its value
+ * stored in the cache, the netgroup's timeout is reset to ngc_pos_ttl seconds
+ * in the future.  If the modifyTimestamp has changed, the netgroup will be
+ * reloaded and replaced in or removed from the cache.  In addition to reducing
+ * the load on the LDAP server(s), this approach leads to lower latency for
+ * frequent lookups.
+ *
+ * Each netgroup in the cache is also in the ngc_pos_expire_queue or
+ * ngc_neg_expire_queue list_t.  These lists are ordered by expiry time, which
+ * each new or renewed netgroup being placed at the end of the appropriate list.
+ * Whether triggered by a lookup or a periodic reap (see ngc_reap_locked()),
+ * when an expired netgroup is removed from ngc_cache, it is also removed from
+ * the expire queue.  See ngc_dispose_locked().
+ *
+ * When setnetgroup() is called, it calls netgroup_get() and holds the reference
+ * in the context that lives until endnetgroup() is called or the netgroup is
+ * fully consumed.  To avoid probles with a netgroup reference that is returned
+ * in the instant before the netgroup expires, the reference is valid for at
+ * least EXPIRE_SECONDS seconds. If the netgroup is refreshed, as described in
+ * the previous paragraph, the context's expiry may be earlier than the
+ * netgroup's expiry. In such a case, the context's expiry will be extended if
+ * needed.   When the context's reference outlives the netgroup expiration, the
+ * netgroup will be found in ngc_graveyard.
+ *
+ * When nscd sees a configuration change, it restarts itself.  Thus, there is no
+ * need for any finalization code to free state.
+ */
 
+
+#include <assert.h>
+#include <atomic.h>
+#include <errno.h>
+#include <libscf.h>
+#include <stddef.h>
 #include <syslog.h>
+#include <sys/avl.h>
+#include <sys/debug.h>
+#include <sys/list.h>
+#include <sys/sdt.h>
+#include <sys/sysmacros.h>
+#include <thread.h>
 #include "ldap_common.h"
 
 /* netgroup attributes filters */
 #define	_N_TRIPLE		"nisnetgrouptriple"
 #define	_N_MEMBER		"membernisnetgroup"
+#define	_N_MODIFYSTAMP		"modifyTimestamp"
 
-#define	PRINT_VAL(a)		(((a).argc == 0) || ((a).argv == NULL) || \
-				    ((a).argv[0] == NULL)) ? "*" : (a).argv[0]
+#define	PRINT_VAL(a)		((((a).argc == 0) || ((a).argv == NULL) || \
+				    ((a).argv[0] == NULL)) ? "*" : (a).argv[0])
 #define	ISNULL(a)		(a == NULL ? "<NULL>" : a)
 #define	MAX_DOMAIN_LEN		1024
 #define	MAX_TRIPLE_LEN		(MAXHOSTNAMELEN + LOGNAME_MAX + \
@@ -44,12 +159,78 @@
 #define	N_HASH		257
 #define	COMMA		','
 
+#define	NGC_POS_TTL		3600	/* or nscd.conf positive-time-to-live */
+#define	NGC_NEG_TTL		5	/* or nscd.conf negative-time-to-live */
+#define	NGC_DATESTR_LEN		24
+
+#define	NSCD_FMRI "svc:/system/name-service-cache:default"
+#define	NSCD_CONF "/etc/nscd.conf"
+
 static const char *netgrent_attrs[] = {
 	_N_TRIPLE,
 	_N_MEMBER,
+	_N_MODIFYSTAMP,
 	(char *)NULL
 };
 
+static const char *netgrent_stamp[] = {
+	_N_MODIFYSTAMP,
+	(char *)NULL
+};
+
+/*
+ * Each of these will reference strings in ng_result.  Per split_triple(), NULL
+ * is treated as a wildcard.
+ */
+typedef struct {
+	char *ngt_host;
+	char *ngt_user;
+	char *ngt_domain;
+} ngc_triple_t;
+
+typedef enum {
+	NGC_FLAG_NEGATIVE	= 0x01,
+	NGC_FLAG_INCACHE	= 0x02,
+	NGC_FLAG_INWARMER	= 0x04,
+} ngc_flags_t;
+
+#define	NGC_NEGATIVE(ng)	(!!((ng)->ng_flags & NGC_FLAG_NEGATIVE))
+#define	NGC_INCACHE(ng)		(!!((ng)->ng_flags & NGC_FLAG_INCACHE))
+#define	NGC_INWARMER(ng)	(!!((ng)->ng_flags & NGC_FLAG_INWARMER))
+
+#define	NGC_CLEAR(ng, flags)	((ng)->ng_flags &= ~(flags))
+#define	NGC_SET(ng, flags)	((ng)->ng_flags |= (flags))
+
+/*
+ * A cached netgroup.
+ */
+typedef struct {
+	ns_ldap_result_t *ng_result;
+	time_t ng_birth;		/* For cache debugging */
+	time_t ng_expire;		/* Do not use after */
+	time_t ng_refresh;		/* Time to update ahead of expiry */
+	int32_t ng_refcnt;
+	ngc_flags_t ng_flags;
+	ngc_triple_t *ng_triples;
+	int32_t ng_triplecnt;
+	char ng_lastchange[NGC_DATESTR_LEN];	/* RFC 4512 3.3.13 */
+	union {
+		avl_node_t ng_cache;	/* if NGC_INCACHE(), in ngc_cache */
+		list_node_t ng_tombstone; /* !NGC_INCACHE(), in ngc_graveyard */
+	} ng_linkage;
+	list_node_t ng_warmlink;
+	list_node_t ng_expire_linkage;	/* ngc_{pos,neg}_expire_queue */
+	const char *ng_name;		/* Will reference space after struct */
+} netgroup_t;
+
+/*
+ * While iterating a netgroup we must keep track of which memberNisNetgroups
+ * have been seen and avoid visiting the same nested netgroup multiple times.
+ * This is particularly important for netgroups that form cicurlar references.
+ *
+ * This is handled with a netgroup_table_t.  Each iterator establishes a
+ * netgroup_table_t containing a hash table of netgroup_name_t elements.
+ */
 typedef struct netgroup_name {
 	char *name;
 	struct netgroup_name *next;
@@ -62,23 +243,663 @@ typedef struct {
 	netgroup_name_t *done;
 } netgroup_table_t;
 
+typedef unsigned int hash_t;
+
+/*
+ * This cookie is used across setnetgrent()/getnetgrent()/endnetgrent().
+ */
 typedef struct {
-	ns_ldap_result_t *results;
-	ns_ldap_entry_t *entry;
-	char **attrs;
-	char *netgroup;
+	netgroup_t *netgroup;		/* cached netgroup */
+	ns_ldap_entry_t *entry;		/* entry in netgroup->ng_result */
+	char *name;			/* netgroup name */
+	int curtriple;			/* index in netgroup->ng_triples */
 	netgroup_table_t tab;
 } getnetgrent_cookie_t;
 
-typedef struct {
-	struct nss_innetgr_args *ia;
-	const char *ssd_filter;
-	const char *netgrname;
-	const char *membername;
-	netgroup_table_t tab;
-} innetgr_cookie_t;
+/* These hold netgroup_t nodes in the cache. */
+static avl_tree_t ngc_cache;
+static list_t ngc_graveyard;
+static list_t ngc_warm_queue;
 
-typedef unsigned int hash_t;
+/*
+ * ngc_lock must be held while modifying ngc_cache, ngc_graveyard, or adjusting
+ * ng_refcnt in any netgroup in ngc_cache or ngc_graveyard.
+ */
+static mutex_t ngc_lock = DEFAULTMUTEX;
+static cond_t ngc_warm_cv = DEFAULTCV;
+static thread_t ngc_warmer_tid;
+static boolean_t ngc_warmer_die = B_FALSE;
+static boolean_t ngc_initialized = B_FALSE;
+
+/*
+ * The positive cache size is naturally limited by the directory size.  The
+ * negative cache is limited only by imagination, unless we have an explicit
+ * limit on the size.
+ */
+static uint32_t ngc_neg_max = 200;		/* Arbitrary */
+static volatile uint32_t ngc_neg_count = 0;
+list_t ngc_pos_expire_queue;
+list_t ngc_neg_expire_queue;
+// XXX-mg
+//static int ngc_reap_interval = 313;	/* Arbitary, but try to avoid minute */
+static int ngc_reap_interval = 31;	/* Arbitary, but try to avoid minute */
+
+/* Initialized in read_nscd_conf() */
+int ngc_enable;
+int ngc_pos_ttl;
+int ngc_neg_ttl;
+
+static int split_triple(char *, char **, char **, char **);
+static void ngc_dispose_locked(netgroup_t *);
+
+static netgroup_t *
+ngc_alloc(const char *name)
+{
+	netgroup_t *ng;
+	size_t len = strlen(name) + 1;
+
+	/*
+	 * Use one allocation for the structure and the variable length name.
+	 * Not using flexible array member because we need to be able to assign
+	 * a value ng_name before avl_find() without doing a heap allocation.
+         */
+	if ((ng = calloc(1, sizeof (*ng) + len)) == NULL) {
+		return (NULL);
+	}
+
+	ng->ng_birth = time(NULL);
+	ng->ng_name = (const char *)&ng->ng_name + sizeof (ng->ng_name);
+	(void) strlcpy((char *)ng->ng_name, name, len);
+
+	return (ng);
+}
+
+static void
+ngc_free(netgroup_t *ng)
+{
+	DTRACE_PROBE2(nss_ldap, netgroup__cache__free, ng->ng_name, ng);
+
+	VERIFY0(ng->ng_refcnt);
+	free(ng->ng_triples);
+	(void) __ns_ldap_freeResult(&ng->ng_result);
+	free(ng);
+}
+
+static void
+ngc_hold_locked(netgroup_t *ng)
+{
+	assert(MUTEX_HELD(&ngc_lock));
+	DTRACE_PROBE3(nss_ldap, netgroup__cache__hold, ng->ng_name, ng,
+	    ng->ng_refcnt);
+	ng->ng_refcnt++;
+}
+
+static void
+ngc_rele_locked(netgroup_t *ng)
+{
+	time_t now = time(NULL);
+
+	assert(MUTEX_HELD(&ngc_lock));
+	ASSERT3S(ng->ng_refcnt, >, 0);
+
+	DTRACE_PROBE3(nss_ldap, netgroup__cache__rele, ng->ng_name, ng,
+	    ng->ng_refcnt);
+
+	ng->ng_refcnt--;
+	if (ng->ng_expire <= now) {
+		ngc_dispose_locked(ng);
+	}
+}
+
+static void
+netgroup_rele(netgroup_t *ng)
+{
+	VERIFY0(mutex_lock(&ngc_lock));
+
+	ngc_rele_locked(ng);
+
+	VERIFY0(mutex_unlock(&ngc_lock));
+}
+
+/*
+ * Free or otherwise properly dispose of a netgroup that is evicted from the
+ * cache or may be ready to be evicted from the graveyard.  Does not alter the
+ * reference count.
+ */
+static void
+ngc_dispose_locked(netgroup_t *ng)
+{
+	assert(MUTEX_HELD(&ngc_lock));
+
+	DTRACE_PROBE4(nss_ldap, netgroup__cache__dispose, ng->ng_name, ng,
+	    ng->ng_refcnt, ng->ng_flags);
+
+	if (NGC_INCACHE(ng)) {
+		/*
+		 * This netgroup will move from an expire queue to the bit
+		 * bucket or the graveyard.
+		 */
+		if (NGC_NEGATIVE(ng)) {
+			list_remove(&ngc_neg_expire_queue, ng);
+			atomic_dec_32(&ngc_neg_count);
+		} else {
+			list_remove(&ngc_pos_expire_queue, ng);
+		}
+
+		avl_remove(&ngc_cache, ng);
+
+		if (ng->ng_refcnt == 0) {
+			ngc_free(ng);
+		} else {
+			NGC_CLEAR(ng, NGC_FLAG_INCACHE);
+			DTRACE_PROBE2(nss_ldap, netgroup__cache__to__graveyard,
+			    ng->ng_name, ng);
+			list_insert_tail(&ngc_graveyard, ng);
+		}
+		return;
+	}
+
+	if (ng->ng_refcnt == 0) {
+		list_remove(&ngc_graveyard, ng);
+		ngc_free(ng);
+		return;
+	}
+}
+
+static void
+ngc_dispose(netgroup_t *ng)
+{
+	VERIFY(mutex_lock(&ngc_lock));
+	ngc_dispose_locked(ng);
+	VERIFY(mutex_unlock(&ngc_lock));
+}
+
+static void
+ngc_set_expire_locked(netgroup_t *ng, boolean_t in_expire_queue)
+{
+	list_t *expire_queue;
+	int expire_ttl;
+	int refresh_ttl;
+
+	VERIFY(MUTEX_HELD(&ngc_lock));
+
+	if (NGC_NEGATIVE(ng)) {
+		expire_queue = &ngc_neg_expire_queue;
+		ng->ng_expire = ngc_enable ? (time(NULL) + ngc_neg_ttl) : 0;
+		ng->ng_refresh = 0;
+	} else {
+		expire_queue = &ngc_pos_expire_queue;
+		ng->ng_expire = ngc_enable ? (time(NULL) + ngc_pos_ttl) : 0;
+		ng->ng_refresh = ngc_enable ?
+		    (ng->ng_expire - (ngc_pos_ttl >> 2)) : 0;
+	}
+
+	if (in_expire_queue && list_tail(expire_queue) != ng) {
+		list_remove(expire_queue, ng);
+	}
+	list_insert_tail(expire_queue, ng);
+}
+
+/*
+ * This parses the netgroup triples in ng->ng_result, storing them in
+ * ng->ng_triples.  The process of parsing them overwrites at least some of the
+ * white space, commas, and parentheses in ng_result so they are not usable
+ * after this.  ng->ng_result must live as long as ng->ng_triples.
+ */
+static int
+ngc_parse_triples(netgroup_t *ng)
+{
+	ns_ldap_entry_t *entry;
+	char **attr;
+	int i = 0;
+	int entries = 0;
+
+	VERIFY0(ng->ng_triplecnt);
+
+	/* First, we need a count of nisNetgroupTriple attributes */
+	for (entry = ng->ng_result->entry; entry != NULL; entry = entry->next) {
+		entries++;
+		for (attr = __ns_ldap_getAttr(entry, _N_TRIPLE);
+		    *attr != NULL; attr++) {
+			i++;
+		}
+	}
+#ifdef DEBUG
+	syslog(LOG_DEBUG, "ngc_parse_triples parsing %d triples from "
+	    "%d entries", i, entries);
+#endif
+	if (i == 0) {
+		return (0);
+	}
+
+	/* Allocate the triples */
+	ng->ng_triples = calloc(i, sizeof (*ng->ng_triples));
+	if (ng->ng_triples == NULL) {
+		ng->ng_triplecnt = 0;
+		return (-1);
+	}
+	ng->ng_triplecnt = i;
+	i = 0;
+
+	/*
+	 * Parse the triples. Parse errors lead to not all of the allocated
+	 * slots being used.
+	 */
+	for (entry = ng->ng_result->entry; entry != NULL; entry = entry->next) {
+		for (attr = __ns_ldap_getAttr(entry, _N_TRIPLE);
+		    *attr != NULL; attr++) {
+			ngc_triple_t *ngt = &ng->ng_triples[i];
+
+			if (split_triple(*attr, &ngt->ngt_host,
+			    &ngt->ngt_user, &ngt->ngt_domain) == 0) {
+				i++;
+				DTRACE_PROBE5(nss_ldap, netgroup__cache__triple,
+				    ng->ng_name, ng, ngt->ngt_host,
+				    ngt->ngt_user, ngt->ngt_domain);
+			}
+		}
+	}
+	ng->ng_triplecnt = i;
+
+	return (0);
+}
+
+/*
+ * XXX-mg turn this into a time_t.
+ */
+static int
+get_last_modified(ns_ldap_result_t *result, char *buf, size_t bufsz)
+{
+	ns_ldap_entry_t		*entry;
+	char			**attr;
+
+	for (entry = result->entry; entry != NULL; entry = entry->next) {
+		attr = __ns_ldap_getAttr(entry, _N_MODIFYSTAMP);
+		if (*attr != NULL) {
+			(void) strlcpy(buf, *attr, bufsz);
+			return (0);
+		}
+	}
+	if (bufsz > 0) {
+		buf[0] = '\0';
+	}
+	return (-1);
+}
+
+static nss_status_t
+ngc_ldap_search(const char *ngname, const char **attrs,
+    ns_ldap_result_t **result)
+{
+	char			filter[SEARCHFILTERLEN];
+	char			name[SEARCHFILTERLEN];
+	char			userdata[SEARCHFILTERLEN];
+	ns_ldap_error_t		*error = NULL;
+	int			rc;
+
+	/* Escape special characters */
+	if (_ldap_filter_name(name, ngname, sizeof (name)) != 0)
+		return NSS_NOTFOUND;
+	/* Form "(&(objectClass=nisNetGroup)(cn=<name>))" */
+	rc = snprintf(filter, sizeof (filter), _F_SETMEMBER, name);
+	if (rc >= sizeof (filter) || rc < 0)
+		return (NSS_NOTFOUND);
+
+	/* Form "(&(%s)(cn=<name>))" - including literal %s */
+	rc = snprintf(userdata, sizeof (userdata), _F_SETMEMBER_SSD, name);
+	if (rc >= sizeof (userdata) || rc < 0) {
+		return (NSS_NOTFOUND);
+	}
+
+	/* Perform the search */
+	rc = __ns_ldap_list(_NETGROUP, filter, _merge_SSD_filter, attrs, NULL,
+	    0, result, &error, NULL, userdata);
+	if (error != NULL && switch_err(rc, error) == NSS_TRYAGAIN) {
+		/*
+		 * Return NSS_TRYAGAIN (rather than looping here) so nscd can
+		 * manage retry count, which is configurable in nscd.conf.
+		 */
+		(void) __ns_ldap_freeError(&error);
+		return (NSS_TRYAGAIN);
+	}
+	(void) __ns_ldap_freeError(&error);
+	if (rc != NS_LDAP_SUCCESS) {
+		return (NSS_NOTFOUND);
+	}
+
+	return (NSS_SUCCESS);
+}
+
+/*
+ * Get the specified netgroup from LDAP.  Only to be called by netgroup_get() or
+ * ng_refresh();
+ *
+ * On successful read from ldap, the netgroup is added to the cache and a held
+ * reference is returned.  If the cache is enabled, a lookup that returns
+ * NSS_NOTFOUND will lead to a negative cache entry.
+ */
+static nss_status_t
+ngc_get_from_ldap(const char *ngname, netgroup_t **ngp)
+{
+	char			filter[SEARCHFILTERLEN];
+	char			name[SEARCHFILTERLEN];
+	char			userdata[SEARCHFILTERLEN];
+	ns_ldap_result_t	*result = NULL;
+	ns_ldap_error_t		*error = NULL;
+	int			rc;
+	nss_status_t		status;
+	netgroup_t		*ng, *ngc;
+
+	assert(!MUTEX_HELD(&ngc_lock));
+
+	status = ngc_ldap_search(ngname, netgrent_attrs, &result);
+	if (status == NSS_NOTFOUND && ngc_enable && ngc_neg_ttl > 0) {
+		/* Add a negative entry, being careful not to allow too many */
+		if (ngc_neg_count < ngc_neg_max) {
+			if ((ng = ngc_alloc(ngname)) == NULL) {
+				return (status);
+			}
+			atomic_inc_32(&ngc_neg_count);
+		}
+		NGC_SET(ng, NGC_FLAG_NEGATIVE | NGC_FLAG_INCACHE);
+	} else if (status != NSS_SUCCESS) {
+		return (status);
+	} else {
+		/* We got a result, cache it. */
+		if ((ng = ngc_alloc(ngname)) == NULL) {
+			int err = errno;
+			(void) __ns_ldap_freeResult(&result);
+			errno = err;
+			return (NSS_ERROR);
+		}
+
+		ng->ng_result = result;
+		if (ngc_parse_triples(ng)) {
+			return (NSS_ERROR);
+		}
+
+		get_last_modified(result, ng->ng_lastchange,
+		    sizeof (ng->ng_lastchange));
+
+		NGC_SET(ng, NGC_FLAG_INCACHE);
+		*ngp = ng;
+	}
+
+	VERIFY0(mutex_lock(&ngc_lock));
+
+	if ((ngc = avl_find(&ngc_cache, ng, NULL)) != NULL) {
+		/* Someone else just slipped one in. This one is newer? */
+		DTRACE_PROBE3(nss_ldap, netgroup__cache__add__collision,
+		    ng->ng_name, ng, ngc);
+		ngc_dispose_locked(ngc);
+	}
+
+	ngc_set_expire_locked(ng, B_FALSE);
+	avl_add(&ngc_cache, ng);
+
+	status = NGC_NEGATIVE(ng) ? NSS_NOTFOUND : NSS_SUCCESS;
+	if (status == NSS_SUCCESS) {
+		ngc_hold_locked(ng);
+		*ngp = ng;
+	}
+
+	VERIFY0(mutex_unlock(&ngc_lock));
+
+	DTRACE_PROBE3(nss_ldap, netgroup__cache__add, ng->ng_name, ng, status);
+	return (status);
+}
+
+static void
+ngc_queue_refresh_locked(netgroup_t *ng)
+{
+	assert(MUTEX_HELD(&ngc_lock));
+
+	DTRACE_PROBE2(nss_ldap, netgroup__warmer__enqueue, ng->ng_name, ng);
+
+	NGC_SET(ng, NGC_FLAG_INWARMER);
+	list_insert_tail(&ngc_warm_queue, ng);
+
+	VERIFY0(cond_signal(&ngc_warm_cv));
+}
+
+/*
+ * Get the specified netgroup from the cache.
+ */
+static nss_status_t
+netgroup_get(const char *name, netgroup_t **ngp)
+{
+	netgroup_t *ng;
+	netgroup_t find = { .ng_name = name };
+	time_t now;
+	nss_status_t status;
+
+	VERIFY(ngc_initialized);
+	VERIFY0(mutex_lock(&ngc_lock));
+
+	ng = avl_find(&ngc_cache, &find, NULL);
+	if (ng == NULL) {
+		/* not in cache, get it from LDAP */
+		VERIFY0(mutex_unlock(&ngc_lock));
+		return (ngc_get_from_ldap(name, ngp));
+	}
+	VERIFY(NGC_INCACHE(ng));
+
+	/*
+	 * If the netgroup has expired, get it out of the cache and get it fresh
+	 * from LDAP.
+	 */
+	now = time(NULL);
+	if (ng->ng_expire <= now) {
+		ngc_dispose_locked(ng);
+		VERIFY0(mutex_unlock(&ngc_lock));
+		return (ngc_get_from_ldap(name, ngp));
+	}
+
+	/*
+	 * If a refresh is needed, grab one ref for the return and another for
+	 * the refresh.  Set the refresh time forward so that we don't end up
+	 * with concurrent refreshes.
+	 */
+	if (ngc_enable && ng->ng_refresh < now && !NGC_INWARMER(ng) &&
+	    !NGC_NEGATIVE(ng)) {
+		ng->ng_refresh = ng->ng_expire;
+		ngc_hold_locked(ng);
+		ngc_queue_refresh_locked(ng);
+	}
+	status = NGC_NEGATIVE(ng) ? NSS_NOTFOUND : NSS_SUCCESS;
+	if (status == NSS_SUCCESS) {
+		ngc_hold_locked(ng);
+		*ngp = ng;
+	}
+	VERIFY0(mutex_unlock(&ngc_lock));
+
+	DTRACE_PROBE3(nss_ldap, netgroup__get__from__cache, ng->ng_name, ng,
+	    status);
+	return (status);
+}
+
+/*
+ * Dispose of all expired netgroups that are in the cache.
+ */
+static void
+ngc_reap_locked(void)
+{
+	list_t *queues[] = {
+	    &ngc_neg_expire_queue,
+	    &ngc_pos_expire_queue,
+	};
+	netgroup_t *ng;
+	time_t now = time(NULL);
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(queues); i++) {
+		for (ng = list_head(queues[i]);
+		    ng != NULL && now >= ng->ng_expire;
+		    ng = list_head(queues[i])) {
+			VERIFY(NGC_INCACHE(ng));
+			DTRACE_PROBE3(nss_ldap, netgroup__reap, ng->ng_name, ng,
+			    queues[i]);
+			ngc_dispose_locked(ng);
+			VERIFY3P(list_head(queues[i]), !=, ng);
+		}
+	}
+}
+
+/*
+ * This worker thread picks up netgroups that need to be refreshed from
+ * ngc_warm_queue.  It also wakes up from time to time (ngc_reap_interval) to
+ * clear cruft from the cache.
+ *
+ * Several things can happen to a netgroup that is in this queue.
+ *
+ * - There could be a delay in queue processing and the netgroup may have
+ *   already been evicted from the cache.  In this case it is not refreshed.
+ * - The LDAP server may not provide a modifyTimestamp attr.  In this case, the
+ *   netgroup will be fully reloaded on demand.
+ * - Most commonly, the current modifyTimestamp value matches the value found in
+ *   the cache.  The expire and refresh times are updated as though the entire
+ *   netgroup was just loaded.
+ * - A newer modifyTimestamp may be seen.  This causes the netgroup to be
+ *   expired from the cache.
+ *
+ * As each netgroup was placed in ngc_warm_queue, a reference was taken.  That
+ * reference is released as this thread processes the renewal.
+ */
+static void *
+ngc_warmer(void *data)
+{
+	netgroup_t		*ng;
+	netgroup_t		*newng;
+	nss_status_t		status;
+	ns_ldap_result_t	*result = NULL;
+	avl_index_t		where;
+	char			buf[NGC_DATESTR_LEN];
+	timestruc_t		reltime;
+
+	VERIFY0(mutex_lock(&ngc_lock));
+
+	reltime.tv_sec = ngc_reap_interval;
+	reltime.tv_nsec = 0;
+
+	for (;;) {
+		cond_reltimedwait(&ngc_warm_cv, &ngc_lock, &reltime);
+
+		/*
+		 * First, do a little housekeeping.
+		 */
+		ngc_reap_locked();
+
+		ng = list_remove_head(&ngc_warm_queue);
+		if (ng != NULL) {
+			NGC_CLEAR(ng, NGC_FLAG_INWARMER);
+		}
+
+		if (ng == NULL) {
+			/* Timeout or interrupted by a signal */
+			continue;
+		}
+
+		VERIFY0(mutex_unlock(&ngc_lock));
+		status = ngc_ldap_search(ng->ng_name, netgrent_stamp, &result);
+		VERIFY0(mutex_lock(&ngc_lock));
+		if (status != NSS_SUCCESS) {
+			/*
+			 * Either the server does not support modifyTimestamp or
+			 * something worse happened.  Since we aren't certain of
+			 * the reason, do not evict it from the cache.
+			 */
+			DTRACE_PROBE3(nss_ldap, netgroup__warmer__ldap__fail,
+			    ng->ng_name, ng, status);
+			ngc_rele_locked(ng);
+			continue;
+		}
+		if (get_last_modified(result, buf, sizeof (buf)) != 0) {
+			DTRACE_PROBE2(nss_ldap, netgroup__warmer__no__stamp,
+			    ng->ng_name, ng);
+			ngc_rele_locked(ng);
+			continue;
+		}
+		/*
+		 * modifyTimestamp is an ISO 8601 time stamp, which should lend
+		 * itself to string comparison.  The key place where this could
+		 * get confused is if the LDAP server decides to add or remove
+		 * the timezone from the stamp.  The consequences of that
+		 * happening are not dire - we end up pulling an entire netgroup
+		 * when things haven't really changed.
+		 */
+		int cmp = strcmp(buf, ng->ng_lastchange);
+		if (cmp == 0 && !NGC_INCACHE(ng) &&
+		    avl_find(&ngc_cache, ng, &where) == NULL) {
+			/*
+			 * The netgroup has not changed, but it has been
+			 * expired.  Rip it from the jaws of death.
+			 */
+
+			DTRACE_PROBE2(nss_ldap, netgroup__warmer__resurrection,
+			    ng->ng_name, ng);
+			list_remove(&ngc_graveyard, ng);
+			avl_insert(&ngc_cache, ng, where);
+			NGC_SET(ng, NGC_FLAG_INCACHE);
+			ngc_set_expire_locked(ng, B_TRUE);
+
+			ngc_rele_locked(ng);
+			continue;
+		}
+		if (cmp == 0) {
+			/* Netgroup has not changed, move expiry ahead */
+
+			DTRACE_PROBE2(nss_ldap, netgroup__warmer__renewal,
+			    ng->ng_name, ng);
+			ngc_set_expire_locked(ng, B_TRUE);
+			ngc_rele_locked(ng);
+			continue;
+		}
+		if (cmp < 0) {
+			/*
+			 * The time stamp went backwards?  Maybe there's a
+			 * replica out of sync.  Let's not use the old version.
+			 */
+			DTRACE_PROBE2(nss_ldap, netgroup__warmer__backwards,
+			    ng->ng_name, ng);
+			ngc_rele_locked(ng);
+			continue;
+		}
+
+		/*
+		 * The netgroup has been changed. Expire the current
+		 * netgroup then fetch a fresh copy.  That order is
+		 * important so that the netgroup is not in the cache
+		 * when ngc_get_from_ldap() tries to add the fresh copy.
+		 * Keep the hold on ng until after ngc_get_from_ldap()
+		 * completes to ensure that ng->ng_name does not get
+		 * freed while it is still needed.
+		 */
+		DTRACE_PROBE2(nss_ldap, netgroup__warmer__expire, ng->ng_name,
+		    ng);
+		ngc_dispose_locked(ng);
+
+		VERIFY0(mutex_unlock(&ngc_lock));
+		status = ngc_get_from_ldap(ng->ng_name, &newng);
+		VERIFY0(mutex_lock(&ngc_lock));
+
+		if (status == NSS_SUCCESS) {
+			DTRACE_PROBE3(nss_ldap,
+			    netgroup__warmer__reload__success, ng->ng_name, ng,
+			    newng);
+			ngc_rele_locked(newng);
+		} else {
+			DTRACE_PROBE3(nss_ldap, netgroup__warmer__reload__fail,
+			    ng->ng_name, ng, status);
+		}
+		ngc_rele_locked(ng);
+	}
+	/* NOTREACHED */
+	return (NULL);
+}
+
+/*
+ * Netgroup table management.  This is used during a query to handle nested
+ * netgroups while avoiding loops.
+ */
 
 static hash_t
 get_hash(const char *s)
@@ -190,8 +1011,8 @@ free_netgroup_table(netgroup_table_t *tab)
 
 /*
  * domain comparing routine
- * 	n1: See if n1 is n2 or an ancestor of it
- * 	n2: (in string terms, n1 is a suffix of n2)
+ *	n1: See if n1 is n2 or an ancestor of it
+ *	n2: (in string terms, n1 is a suffix of n2)
  * Returns ZERO for success, -1 for failure.
  */
 static int
@@ -240,7 +1061,7 @@ split_triple(char *triple, char **hostname, char **username, char **domain)
 	char	*p = triple;
 
 #ifdef	DEBUG
-	(void) fprintf(stdout, "\n[getnetgrent.c: split_triple]\n");
+	(void) fprintf(stderr, "\n[getnetgrent.c: split_triple]\n");
 #endif	/* DEBUG */
 
 	if (triple == NULL)
@@ -308,7 +1129,7 @@ split_triple(char *triple, char **hostname, char **username, char **domain)
  */
 
 static int
-match_triple_entry(struct nss_innetgr_args *ia, const ns_ldap_entry_t *entry)
+match_triple(struct nss_innetgr_args *ia, netgroup_t *ng)
 {
 	int	ndomains;
 	char	**pdomains;
@@ -316,12 +1137,8 @@ match_triple_entry(struct nss_innetgr_args *ia, const ns_ldap_entry_t *entry)
 	char	**phost;
 	int	nusers;
 	char	**pusers;
-	char	**attr;
-	char	triple[MAX_TRIPLE_LEN];
 	char	*tuser, *thost, *tdomain;
-	int	i;
-	char	*current, *limit;
-	int	pulen, phlen;
+	int	i, trip;
 	char	*pusers0, *phost0;
 
 	nhost = ia->arg[NSS_NETGR_MACHINE].argc;
@@ -330,7 +1147,6 @@ match_triple_entry(struct nss_innetgr_args *ia, const ns_ldap_entry_t *entry)
 		nhost = 0;
 	} else {
 		phost0 = phost[0];
-		phlen = strlen(phost0);
 #ifdef DEBUG
 		syslog(LOG_DEBUG, "nss_ldap: match_triple_entry: "
 		    "entering with host: %s", phost0 ? phost0 : "");
@@ -342,7 +1158,6 @@ match_triple_entry(struct nss_innetgr_args *ia, const ns_ldap_entry_t *entry)
 		nusers = 0;
 	} else {
 		pusers0 = pusers[0];
-		pulen = strlen(pusers0);
 #ifdef DEBUG
 		syslog(LOG_DEBUG, "nss_ldap: match_triple_entry: "
 		    "entering with user: %s", pusers0 ? pusers0 : "");
@@ -358,10 +1173,6 @@ match_triple_entry(struct nss_innetgr_args *ia, const ns_ldap_entry_t *entry)
 		    "entering with domain: %s", pdomains[0] ? pdomains[0] : "");
 #endif
 
-	attr = __ns_ldap_getAttr(entry, _N_TRIPLE);
-	if (attr == NULL || *attr == NULL)
-		return (0);
-
 #ifdef DEBUG
 	syslog(LOG_DEBUG, "nss_ldap: match_triple_entry: "
 	    "(nusers: %d, nhost:%d, ndomains: %d)",
@@ -371,102 +1182,53 @@ match_triple_entry(struct nss_innetgr_args *ia, const ns_ldap_entry_t *entry)
 	/* Special cases for speedup */
 	if (nusers == 1 && nhost == 0 && ndomains == 0) {
 		/* Special case for finding a single user in a netgroup */
-		for (; *attr; attr++) {
-			/* jump to first comma and check next character */
-			current = *attr;
+		for (trip = 0; trip < ng->ng_triplecnt; trip++) {
+			ngc_triple_t *ngt = &ng->ng_triples[trip];
+
 #ifdef DEBUG
 			syslog(LOG_DEBUG, "nss_ldap: match_triple_entry: "
-			    "current is: %s", current);
+			    "current user is: %s", ngt->ngt_user);
 #endif
-			if ((current = strchr(current, COMMA)) == NULL)
-				continue;
-			current++;
-
-			/* skip whitespaces */
-			while (isspace(*current))
-				current++;
-
 			/* if user part is null, then treat as wildcard */
-			if (*current == COMMA)
+			if (ngt->ngt_user == NULL) {
 				return (1);
-
-			/* compare first character */
-			if (*pusers0 != *current)
-				continue;
-
-			/* limit username to COMMA */
-			if ((limit = strchr(current, COMMA)) == NULL)
-				continue;
-			*limit = '\0';
-
-			/* remove blanks before COMMA */
-			if ((limit = strpbrk(current, " \t")) != NULL)
-				*limit = '\0';
-
-			/* compare size of username */
-			if (pulen != strlen(current)) {
-				continue;
 			}
 
 			/* do actual compare */
-			if (strncmp(pusers0, current, pulen) == 0) {
+			if (strcmp(pusers0, ngt->ngt_user) == 0) {
 				return (1);
-			} else {
-				continue;
 			}
 		}
 	} else if (nusers == 0 && nhost == 1 && ndomains == 0) {
 		/* Special case for finding a single host in a netgroup */
-		for (; *attr; attr++) {
+		for (trip = 0; trip < ng->ng_triplecnt; trip++) {
+			ngc_triple_t *ngt = &ng->ng_triples[trip];
+
 
-			/* jump to first character and check */
-			current = *attr;
 #ifdef DEBUG
 			syslog(LOG_DEBUG, "nss_ldap: match_triple_entry: "
-			    "current is: %s", current);
+			    "current host is: %s", ngt->ngt_host);
 #endif
-			current++;
-
-			/* skip whitespaces */
-			while (isspace(*current))
-				current++;
 
 			/* if host part is null, then treat as wildcard */
-			if (*current == COMMA)
+			if (ngt->ngt_host == NULL) {
 				return (1);
-
-			/* limit hostname to COMMA */
-			if ((limit = strchr(current, COMMA)) == NULL)
-				continue;
-			*limit = '\0';
-
-			/* remove blanks before COMMA */
-			if ((limit = strpbrk(current, " \t")) != NULL)
-				*limit = '\0';
-
-			/* compare size of hostname */
-			if (phlen != strlen(current)) {
-				continue;
 			}
 
 			/* do actual compare */
-			if (strncasecmp(phost0, current, phlen) == 0) {
+			if (strcasecmp(phost0, ngt->ngt_host) == 0) {
 				return (1);
-			} else {
-				continue;
 			}
 		}
 	} else {
-		for (; *attr; attr++) {
-			if (strlcpy(triple, *attr,
-			    sizeof (triple)) >= sizeof (triple))
-				continue;
+		for (trip = 0; trip < ng->ng_triplecnt; trip++) {
+			thost = ng->ng_triples[trip].ngt_host;
+			tuser = ng->ng_triples[trip].ngt_user;
+			tdomain = ng->ng_triples[trip].ngt_domain;
 #ifdef DEBUG
 			syslog(LOG_DEBUG, "nss_ldap: match_triple_entry: "
-			    "triple is: %s", triple);
+			    "triple is: (%s,%s,%s)", thost, tuser, tdomain);
 #endif
-			if (split_triple(triple, &thost, &tuser, &tdomain) != 0)
-				continue;
 			if (thost != NULL && *thost != '\0' && nhost != 0) {
 				for (i = 0; i < nhost; i++)
 					if (strcasecmp(thost, phost[i]) == 0)
@@ -496,18 +1258,6 @@ match_triple_entry(struct nss_innetgr_args *ia, const ns_ldap_entry_t *entry)
 	return (0);
 }
 
-static int
-match_triple(struct nss_innetgr_args *ia, ns_ldap_result_t *result)
-{
-	ns_ldap_entry_t	*entry;
-
-	for (entry = result->entry; entry != NULL; entry = entry->next)
-		if (match_triple_entry(ia, entry) == 1)
-			return (1);
-
-	return (0);
-}
-
 static int
 add_netgroup_member_entry(ns_ldap_entry_t *entry, netgroup_table_t *tab)
 {
@@ -542,89 +1292,66 @@ add_netgroup_member(ns_ldap_result_t *result, netgroup_table_t *tab)
 	return (ret);
 }
 
+
+
 /*
  * top_down_search checks only checks the netgroup specified in netgrname
  */
 static nss_status_t
 top_down_search(struct nss_innetgr_args *ia, char *netgrname)
 {
-	char			searchfilter[SEARCHFILTERLEN];
-	char			name[SEARCHFILTERLEN];
-	char			userdata[SEARCHFILTERLEN];
-	ns_ldap_result_t	*result = NULL;
-	ns_ldap_error_t		*error = NULL;
-	int			rc;
-	nss_status_t		status = NSS_NOTFOUND;
-	nss_status_t		status1;
-	netgroup_table_t	tab;
-	netgroup_name_t		*ng;
-	int			ret;
+	netgroup_table_t tab;
+	netgroup_name_t *ngn;
+	netgroup_t *ng;
+	int rc;
+	int serrno;
 
 	(void) memset(&tab, 0, sizeof (tab));
 
 	if (add_netgroup_name(netgrname, &tab) != 0)
 		return ((nss_status_t)NSS_NOTFOUND);
 
-	while ((ng = get_next_netgroup(&tab)) != NULL) {
+	while ((ngn = get_next_netgroup(&tab)) != NULL) {
 #ifdef DEBUG
 		syslog(LOG_DEBUG, "nss_ldap: top_down_search: netgroup  loop "
-		    "(ng->name: %s)", ng->name ? ng->name : "null !");
+		    "(ngn->name: %s)", ngn->name ? ngn->name : "null !");
 #endif
-		if (_ldap_filter_name(name, ng->name, sizeof (name)) != 0)
+		switch (netgroup_get(ngn->name, &ng)) {
+		case NSS_SUCCESS:
 			break;
-		ret = snprintf(searchfilter, sizeof (searchfilter),
-		    _F_SETMEMBER, name);
-		if (ret >= sizeof (searchfilter) || ret < 0)
-			break;
-
-		ret = snprintf(userdata, sizeof (userdata), _F_SETMEMBER_SSD,
-		    name);
-		if (ret >= sizeof (userdata) || ret < 0)
-			break;
-
-		/* searching for current netgroup name entry */
-		rc = __ns_ldap_list(_NETGROUP, searchfilter,
-		    _merge_SSD_filter, netgrent_attrs, NULL, 0, &result,
-		    &error, NULL, userdata);
-
-		if (error != NULL) {
-			status1 = switch_err(rc, error);
-			if (status1 == NSS_TRYAGAIN) {
-				(void) __ns_ldap_freeError(&error);
-				free_netgroup_table(&tab);
-				return (status1);
-			}
+		case NSS_TRYAGAIN:
+			free_netgroup_table(&tab);
+			return (NSS_TRYAGAIN);
+		case NSS_ERROR:
+			serrno = errno;
+			free_netgroup_table(&tab);
+			errno = serrno;
+			return (NSS_ERROR);
+		default:
+			continue;
 		}
 
-		(void) __ns_ldap_freeError(&error);
-		if (rc == NS_LDAP_SUCCESS) {
-			if (match_triple(ia, result) == 1) {
-				/* We found a match */
-				ia->status = NSS_NETGR_FOUND;
-				status = NSS_SUCCESS;
+		if (match_triple(ia, ng) == 1) {
+			/* We found a match */
+			ia->status = NSS_NETGR_FOUND;
+			free_netgroup_table(&tab);
+			netgroup_rele(ng);
 #ifdef DEBUG
-				syslog(LOG_DEBUG, "nss_ldap: top_down_search: "
-				    "found match");
+			syslog(LOG_DEBUG, "nss_ldap: top_down_search: "
+			    "found match\n");
 #endif
-				break;
-			}
+			return (NSS_SUCCESS);
+		}
 
-			/*
-			 * No match found. Check for membernisnetgroup
-			 * in result and if yes, start again with those.
-			 */
-			rc = add_netgroup_member(result, &tab);
-			if (rc != 0)
-				break;
-		} else if (rc != NS_LDAP_NOTFOUND) {
+		rc = add_netgroup_member(ng->ng_result, &tab);
+		netgroup_rele(ng);
+		if (rc != 0) {
 			break;
 		}
-		(void) __ns_ldap_freeResult(&result);
 	}
 
-	(void) __ns_ldap_freeResult(&result);
 	free_netgroup_table(&tab);
-	return (status);
+	return (NSS_NOTFOUND);
 }
 
 /*
@@ -637,8 +1364,8 @@ __netgr_in(void *a, char *netgrname)
 	nss_status_t		status = NSS_NOTFOUND;
 
 #ifdef DEBUG
-	(void) fprintf(stdout, "\n[getnetgrent.c: netgr_in]\n");
-	(void) fprintf(stdout, "\tmachine: argc[%d]='%s' user: "
+	(void) fprintf(stderr, "\n[getnetgrent.c: netgr_in]\n");
+	(void) fprintf(stderr, "\tmachine: argc[%d]='%s' user: "
 	    "argc[%d]='%s',\n\tdomain:argc[%d]='%s' "
 	    "netgroup: argc[%d]='%s'\n",
 	    NSS_NETGR_MACHINE,
@@ -649,7 +1376,7 @@ __netgr_in(void *a, char *netgrname)
 	    PRINT_VAL(ia->arg[NSS_NETGR_DOMAIN]),
 	    NSS_NETGR_N,
 	    PRINT_VAL(ia->arg[NSS_NETGR_N]));
-	(void) fprintf(stdout, "\tgroups='%s'\n", netgrname);
+	(void) fprintf(stderr, "\tgroups='%s'\n", netgrname);
 #endif	/* DEBUG */
 
 	ia->status = NSS_NETGR_NO;
@@ -657,7 +1384,12 @@ __netgr_in(void *a, char *netgrname)
 	if (netgrname == NULL)
 		return (status);
 
-	return (top_down_search(ia, netgrname));
+	status = top_down_search(ia, netgrname);
+	DTRACE_PROBE5(nss_ldap, innetgr, netgrname,
+	    PRINT_VAL(ia->arg[NSS_NETGR_MACHINE]),
+	    PRINT_VAL(ia->arg[NSS_NETGR_USER]),
+	    PRINT_VAL(ia->arg[NSS_NETGR_DOMAIN]), status);
+	return (status);
 }
 
 /*ARGSUSED0*/
@@ -680,21 +1412,21 @@ netgr_in(ldap_backend_ptr be, void *a)
 /*
  *
  */
-
+// XXX-mg what is the difference between this and ngetr_set()?
 static nss_status_t
 getnetgr_ldap_setent(ldap_backend_ptr be, void *a)
 {
-	const char	*netgroup = (const char *) a;
+	const char	*name = (const char *) a;
 	getnetgrent_cookie_t	*cookie;
 
 #ifdef	DEBUG
-	(void) fprintf(stdout, "\n[getnetgrent.c: getnetgr_ldap_setent]\n");
+	(void) fprintf(stderr, "\n[getnetgrent.c: getnetgr_ldap_setent]\n");
 #endif	/* DEBUG */
 
 	cookie = (getnetgrent_cookie_t *)be->netgroup_cookie;
-	if (cookie != NULL && cookie->netgroup != NULL) {
+	if (cookie != NULL && cookie->name != NULL) {
 		/* is this another set on the same netgroup */
-		if (strcmp(cookie->netgroup, netgroup) == 0)
+		if (strcmp(cookie->name, name) == 0)
 			return ((nss_status_t)NSS_SUCCESS);
 	}
 
@@ -707,15 +1439,15 @@ free_getnetgrent_cookie(getnetgrent_cookie_t **cookie)
 	getnetgrent_cookie_t *p = *cookie;
 
 #ifdef DEBUG
-	(void) fprintf(stdout, "\n[getnetgrent.c: free_getnetgrent_cookie]\n");
+	(void) fprintf(stderr, "\n[getnetgrent.c: free_getnetgrent_cookie]\n");
 #endif	/* DEBUG */
 
 	if (p == NULL)
 		return;
 
-	(void) __ns_ldap_freeResult(&p->results);
+	netgroup_rele(p->netgroup);
 	free_netgroup_table(&p->tab);
-	free(p->netgroup);
+	free(p->name);
 	free(p);
 	*cookie = NULL;
 }
@@ -726,7 +1458,7 @@ getnetgr_ldap_endent(ldap_backend_ptr be, void *a)
 {
 
 #ifdef	DEBUG
-	(void) fprintf(stdout, "\n[getnetgrent.c: getnetgr_ldap_endent]\n");
+	(void) fprintf(stderr, "\n[getnetgrent.c: getnetgr_ldap_endent]\n");
 #endif	/* DEBUG */
 
 	free_getnetgrent_cookie((getnetgrent_cookie_t **)&be->netgroup_cookie);
@@ -741,7 +1473,7 @@ getnetgr_ldap_destr(ldap_backend_ptr be, void *a)
 {
 
 #ifdef	DEBUG
-	(void) fprintf(stdout, "\n[getnetgrent.c: getnetgr_ldap_destr]\n");
+	(void) fprintf(stderr, "\n[getnetgrent.c: getnetgr_ldap_destr]\n");
 #endif	/* DEBUG */
 
 	free_getnetgrent_cookie((getnetgrent_cookie_t **)&be->netgroup_cookie);
@@ -750,27 +1482,40 @@ getnetgr_ldap_destr(ldap_backend_ptr be, void *a)
 	return ((nss_status_t)NSS_NOTFOUND);
 }
 
+static int
+set_retbuf(const char *val, char **bufferp, int *leftp, char **retbufp)
+{
+	char *buffer = *bufferp;
+	int left = *leftp;
+	int len;
+
+	if (val == NULL) {
+		*retbufp = NULL;
+		return (0);
+	}
+	len = strlcpy(buffer, val, left);
+	if (len >= left) {
+		return (-1);
+	}
+	*retbufp = buffer;
+	*bufferp = buffer + len;
+	*leftp = left - len;
+	return (0);
+}
 
 static nss_status_t
 getnetgr_ldap_getent(ldap_backend_ptr be, void *a)
 {
 	struct nss_getnetgrent_args	*args;
 	getnetgrent_cookie_t	*p;
-	char			searchfilter[SEARCHFILTERLEN];
-	char			userdata[SEARCHFILTERLEN];
-	char			name[SEARCHFILTERLEN];
-	int			rc;
-	ns_ldap_result_t	*result = NULL;
-	ns_ldap_error_t		*error = NULL;
-	char			**attrs;
-	char			*hostname, *username, *domain;
-	char			*buffer;
 	nss_status_t		status = NSS_SUCCESS;
-	netgroup_name_t		*ng;
+	netgroup_name_t		*ngn;
 	int			ret;
+	netgroup_t		*ng = NULL;
+	ns_ldap_result_t	*results = NULL;
 
 #ifdef	DEBUG
-	(void) fprintf(stdout, "\n[getnetgrent.c: getnetgr_ldap_getent]\n");
+	(void) fprintf(stderr, "\n[getnetgrent.c: getnetgr_ldap_getent]\n");
 #endif	/* DEBUG */
 
 	args = (struct nss_getnetgrent_args *)a;
@@ -782,136 +1527,98 @@ getnetgr_ldap_getent(ldap_backend_ptr be, void *a)
 		return ((nss_status_t)NSS_SUCCESS);
 
 	for (;;) {
+		ng = p->netgroup;
 		/*
 		 * Search through each netgroup consecutively: only search
 		 * next netgroup when results from previous netgroup are
 		 * processed.
 		 * Needed for nested netgroup (memberNisNetgroup attributes).
 		 */
-		if (p->results == NULL) {
-			if ((ng = get_next_netgroup(&p->tab)) != NULL) {
-				if (_ldap_filter_name(name, ng->name,
-				    sizeof (name)) != 0)
-					break;
-
-				ret = snprintf(searchfilter,
-				    sizeof (searchfilter),
-				    _F_SETMEMBER, name);
-				if (ret >= sizeof (searchfilter) || ret < 0)
-					break;
-
-#ifdef DEBUG
-				syslog(LOG_DEBUG, "nss_ldap: "
-				    "getnetgr_ldap_getent: "
-				    "netgroup name: %s", name);
-#endif
-				ret = snprintf(userdata, sizeof (userdata),
-				    _F_SETMEMBER_SSD, name);
-				if (ret >= sizeof (userdata) || ret < 0)
-					break;
-
-				result = NULL;
-				rc = __ns_ldap_list(_NETGROUP, searchfilter,
-				    _merge_SSD_filter, netgrent_attrs, NULL,
-				    0, &result, &error, NULL, userdata);
-				(void) __ns_ldap_freeError(&error);
-
-				if (rc == NS_LDAP_SUCCESS && result != NULL) {
-					p->results = result;
-				} else {
-#ifdef DEBUG
-					syslog(LOG_DEBUG, "nss_ldap: "
-					    "getnetgr_ldap_getent: "
-					    "__ns_ldap_list() returned %d "
-					    "(result: 0x%x)", rc, result);
-#endif
-					/*
-					 * Will exit when no more netgroup
-					 * to search and no more p->results
-					 * to process.
-					 */
-					(void) __ns_ldap_freeResult(&result);
-				}
-			} else { /* no more netgroup to process */
-				/*
-				 * If no more results to process, and since
-				 * there's no more netgroup to process either,
-				 * then it's time to break and exit the for
-				 * loop.
-				 */
+		if (ng == NULL) {
+			if ((ngn = get_next_netgroup(&p->tab)) == NULL) {
+				/* No more netgroups to process */
 #ifdef DEBUG
 				syslog(LOG_DEBUG, "nss_ldap: "
 				    "getnetgr_ldap_getent: no more netgroup "
-				    "to process, p->results: 0x%x",
-				    p->results);
+				    "to process.\n");
 #endif
-				if (p->results == NULL)
-					break;
+				break;		/* from loop */
+			}
+
+			switch (netgroup_get(ngn->name, &ng)) {
+			case NSS_SUCCESS:
+				break;		/* from switch */
+			case NSS_TRYAGAIN:
+				return (NSS_TRYAGAIN);
+			default:
+				continue;
 			}
+
+			p->netgroup = ng;
+			p->entry = NULL;
 		}
-		if (p->results == NULL)
+
+		results = ng->ng_result;
+
+		/* Empty or missing netgroup */
+		if (results == NULL)
 			continue;
 
 		if (p->entry == NULL)
-			p->entry = p->results->entry;
+			p->entry = results->entry;
 
 		if (p->entry == NULL)
 			continue;
 
-		if (p->attrs == NULL) {
-			attrs = __ns_ldap_getAttr(p->entry, _N_TRIPLE);
-			if (attrs != NULL && *attrs != NULL)
-				p->attrs = attrs;
-		}
+		if (p->curtriple < ng->ng_triplecnt) {
+			ngc_triple_t *ngt;
+			char *buffer = args->buffer;
+			int left = args->buflen;
 
-		if (p->attrs != NULL) {
-			attrs = p->attrs;
-			buffer = args->buffer;
+			ngt = &ng->ng_triples[p->curtriple];
+			p->curtriple++;
 
-			if (strlcpy(buffer, *attrs, args->buflen) >=
-			    args->buflen) {
+			/*
+			 * The triple (ngt) may be freed before args->retp[] are
+			 * consumed.  Copy the components from the cache into
+			 * args->buffer.
+			 */
+			if (set_retbuf(ngt->ngt_host, &buffer, &left,
+			    &args->retp[NSS_NETGR_MACHINE]) != 0 ||
+			   set_retbuf(ngt->ngt_user, &buffer, &left,
+			    &args->retp[NSS_NETGR_USER]) != 0 ||
+			   set_retbuf(ngt->ngt_domain, &buffer, &left,
+			    &args->retp[NSS_NETGR_DOMAIN]) != 0) {
 				status = NSS_STR_PARSE_ERANGE;
 				break;
 			}
+			args->status = NSS_NETGR_FOUND;
 
-			rc = split_triple(buffer, &hostname, &username,
-			    &domain);
-			attrs++;
-			if (attrs != NULL && *attrs != NULL)
-				p->attrs = attrs;
-			else
-				p->attrs = NULL;
-			if (rc == 0) {
-				args->retp[NSS_NETGR_MACHINE] = hostname;
-				args->retp[NSS_NETGR_USER] = username;
-				args->retp[NSS_NETGR_DOMAIN] = domain;
-				args->status = NSS_NETGR_FOUND;
 #ifdef DEBUG
-				syslog(LOG_DEBUG, "nss_ldap: "
-				    "getnetgr_ldap_getent: found triple "
-				    "(%s, %s, %s), 0x%x to process",
-				    hostname ? hostname : "",
-				    username ? username : "",
-				    domain ? domain : "",
-				    p->attrs);
+			syslog(LOG_DEBUG, "nss_ldap: getnetgr_ldap_getent: "
+			    "found triple (%s,%s,%s), %d more to process",
+			    args->retp[NSS_NETGR_MACHINE] ?
+			    args->retp[NSS_NETGR_MACHINE] : "",
+			    args->retp[NSS_NETGR_USER] ?
+			    args->retp[NSS_NETGR_USER] : "",
+			    args->retp[NSS_NETGR_DOMAIN] ?
+			    args->retp[NSS_NETGR_DOMAIN] : "",
+			    ng->ng_triplecnt - p->curtriple);
 #endif
-				if (p->attrs != NULL)
-					break;
-			}
+
+			break;
 		}
 
-		if (p->attrs == NULL) {
-			rc = add_netgroup_member_entry(p->entry, &p->tab);
-			if (rc != 0) {
-				args->status = NSS_NETGR_NO;
-				break;
-			}
+		/* Despite its name, this adds all members on this entry. */
+		if (add_netgroup_member_entry(p->entry, &p->tab) != 0) {
+			args->status = NSS_NETGR_NO;
+			break;
+		}
 
-			p->entry = p->entry->next;
-			if (p->entry == NULL)
-				(void) __ns_ldap_freeResult(&p->results);
-			if (args->status == NSS_NETGR_FOUND)
-				break;
+		p->entry = p->entry->next;
+		if (p->entry == NULL) {
+			netgroup_rele(p->netgroup);
+			p->netgroup = NULL;
 		}
 	}
 
@@ -929,6 +1636,7 @@ static ldap_backend_op_t getnetgroup_ops[] = {
  *
  */
 
+// XXX-mg what is the difference between this and getnetgr_setent()?
 static nss_status_t
 netgr_set(ldap_backend_ptr be, void *a)
 {
@@ -938,8 +1646,8 @@ netgr_set(ldap_backend_ptr be, void *a)
 	getnetgrent_cookie_t		*p;
 
 #ifdef DEBUG
-	(void) fprintf(stdout, "\n[getnetgrent.c: netgr_set]\n");
-	(void) fprintf(stdout,
+	(void) fprintf(stderr, "\n[getnetgrent.c: netgr_set]\n");
+	(void) fprintf(stderr,
 	    "\targs->netgroup: %s\n", ISNULL(args->netgroup));
 #endif /* DEBUG */
 
@@ -950,8 +1658,8 @@ netgr_set(ldap_backend_ptr be, void *a)
 	p = (getnetgrent_cookie_t *)calloc(1, sizeof (getnetgrent_cookie_t));
 	if (p == NULL)
 		return ((nss_status_t)NSS_NOTFOUND);
-	p->netgroup = strdup(args->netgroup);
-	if (p->netgroup == NULL) {
+	p->name = strdup(args->netgroup);
+	if (p->name == NULL) {
 		free(p);
 		return ((nss_status_t)NSS_NOTFOUND);
 	}
@@ -976,11 +1684,189 @@ netgr_set(ldap_backend_ptr be, void *a)
 	get_be->netgroup_cookie = p;
 	args->iterator = (nss_backend_t *)get_be;
 
-	(void) __ns_ldap_freeResult(&be->result);
-
 	return (NSS_SUCCESS);
 }
 
+/*
+ * Initilization and configuration
+ */
+
+static int
+ngc_compare(const void *l, const void *r)
+{
+	const netgroup_t *ngl = l, *ngr = r;
+	int ret;
+
+	ret = strcmp(ngl->ng_name, ngr->ng_name);
+	if (ret < 0)
+		return (-1);
+	if (ret > 0)
+		return (1);
+	return (0);
+}
+
+static int
+yntoi(const char *yorn)
+{
+	if (strcmp(yorn, "yes") == 0) {
+		return (1);
+	}
+	if (strcmp(yorn, "no") == 0) {
+		return (0);
+	}
+	return (-1);
+}
+
+/*
+ * nscd does not provide us with the config or an easy way to get it.  We'll
+ * fetch it ourselves.
+ */
+static void
+read_nscd_conf(void)
+{
+	const int week = 60 * 60 * 24 * 7;
+	struct {
+		char *key;
+		int *valp;
+		int defval;
+		int minval;
+		int maxval;
+		int (*toi)(const char *);
+	} config[] = {
+		{ "enable-cache", &ngc_enable, 1, 0, 1, yntoi },
+		{ "positive-time-to-live", &ngc_pos_ttl, NGC_POS_TTL, 0, week,
+		    atoi },
+		{ "negative-time-to-live", &ngc_neg_ttl, NGC_NEG_TTL, 0, week,
+		    atoi }
+	};
+	int i;
+	FILE *cfg;
+	char buf[1024];
+	int line = 0;
+
+	/*
+	 * Set values back to their defaults in case they were removed from
+	 * nscd.conf.
+	 */
+	for (i = 0; i < ARRAY_SIZE(config) ; i++) {
+		*config[i].valp = config[i].defval;
+	};
+
+	if ((cfg = fopen(NSCD_CONF, "r")) == NULL) {
+		syslog(LOG_ERR, "nss_ldap: unable to read nscd.conf: %m");
+		return;
+	}
+
+	while (fgets(buf, sizeof (buf), cfg) != NULL) {
+		char *key, *db, *strval, *junk, *last = NULL;
+		int ival;
+
+		line++;
+
+		if ((key = strchr(buf, '#')) != NULL) {
+			*key = '\0';
+		}
+		if ((key = strtok_r(buf, "\n\t ", &last)) == NULL) {
+			continue;
+		}
+		if ((db = strtok_r(NULL, "\n\t ", &last)) == NULL) {
+			continue;
+		}
+		if (strcmp(db, "netgroup") != 0) {
+			continue;
+		}
+
+		strval = strtok_r(NULL, "\n\t ", &last);
+		junk = strtok_r(NULL, "\n\t ", &last);
+
+		for (i = 0; i < ARRAY_SIZE(config); i++) {
+			if (strcmp(config[i].key, key) == 0) {
+				break;
+			}
+		}
+		if (i == ARRAY_SIZE(config)) {
+			syslog(LOG_ERR, "nss_ldap: %s:%d: "
+			    "netgroup attribute '%s' invalid", NSCD_CONF,
+			    line, key);
+			continue;
+		}
+		if (strval == NULL) {
+			syslog(LOG_ERR, "nss_ldap: %s:%d: "
+			    "netgroup attribute '%s' missing value", NSCD_CONF,
+			    line, key);
+			continue;
+		}
+		if (junk != NULL) {
+			syslog(LOG_ERR, "nss_ldap: %s:%d "
+			    "netgroup attribute '%s' has too many values",
+			    NSCD_CONF, line, key);
+			continue;
+		}
+		ival = config[i].toi(strval);
+		if (ival < config[i].minval || ival > config[i].maxval) {
+			syslog(LOG_ERR, "nss_ldap: %s:%d "
+			    "netgroup attribute '%s' value out of range",
+			    NSCD_CONF, line, key);
+			continue;
+		}
+		*(config[i].valp) = ival;
+	}
+	VERIFY0(fclose(cfg));
+}
+
+static void
+ngc_init(void)
+{
+	char fmri[sizeof (NSCD_FMRI) + 1];	/* space for extra char */
+	scf_handle_t *scf = NULL;
+
+	VERIFY0(mutex_lock(&ngc_lock));
+
+	VERIFY0(ngc_initialized);
+
+	read_nscd_conf();
+
+	/*
+	 * Even when not caching, the caching structures are used - netgroups
+	 * just expire immediately and are pruned when ng_refcnt drops to zero.
+	 */
+	avl_create(&ngc_cache, ngc_compare, sizeof (netgroup_t),
+	    offsetof(netgroup_t, ng_linkage));
+	list_create(&ngc_graveyard, sizeof (netgroup_t),
+	    offsetof(netgroup_t, ng_linkage));
+	list_create(&ngc_neg_expire_queue, sizeof (netgroup_t),
+	    offsetof(netgroup_t, ng_expire_linkage));
+	list_create(&ngc_pos_expire_queue, sizeof (netgroup_t),
+	    offsetof(netgroup_t, ng_expire_linkage));
+
+	/*
+	 * Name service backends may run under nscd or as part of some other
+	 * process that is making a request.  Keep things as light as possible
+	 * while not running under nscd.
+	 */
+	if (ngc_enable && (scf = scf_handle_create(SCF_VERSION)) != NULL &&
+	    scf_handle_bind(scf) == 0 &&
+	    scf_myname(scf, fmri, sizeof (fmri)) == (sizeof (NSCD_FMRI) - 1) &&
+	    strcmp(fmri, NSCD_FMRI) == 0) {
+		list_create(&ngc_warm_queue, sizeof (netgroup_t),
+		    offsetof(netgroup_t, ng_warmlink));
+		VERIFY0(cond_init(&ngc_warm_cv, USYNC_THREAD, NULL));
+		if (thr_create(NULL, 0, ngc_warmer, NULL, 0,
+		    &ngc_warmer_tid) != 0) {
+			ngc_warmer_tid = 0;
+		}
+	} else {
+		ngc_enable = B_FALSE;
+		ngc_warmer_tid = 0;
+	}
+	if (scf != NULL) {
+		scf_handle_destroy(scf);
+	}
+
+	ngc_initialized = B_TRUE;
+	VERIFY0(mutex_unlock(&ngc_lock));
+}
+
 
 /*ARGSUSED1*/
 static nss_status_t
@@ -988,7 +1874,7 @@ netgr_ldap_destr(ldap_backend_ptr be, void *a)
 {
 
 #ifdef	DEBUG
-	(void) fprintf(stdout, "\n[getnetgrent.c: netgr_ldap_destr]\n");
+	(void) fprintf(stderr, "\n[getnetgrent.c: netgr_ldap_destr]\n");
 #endif	/* DEBUG */
 
 	(void) _clean_ldap_backend(be);
@@ -997,8 +1883,6 @@ netgr_ldap_destr(ldap_backend_ptr be, void *a)
 }
 
 
-
-
 static ldap_backend_op_t netgroup_ops[] = {
 	netgr_ldap_destr,
 	0,
@@ -1022,10 +1906,13 @@ _nss_ldap_netgroup_constr(const char *dummy1, const char *dummy2,
 {
 
 #ifdef	DEBUG
-	(void) fprintf(stdout,
+	(void) fprintf(stderr,
 	    "\n[getnetgrent.c: _nss_ldap_netgroup_constr]\n");
 #endif	/* DEBUG */
 
+	/* Initialize the cache. */
+	ngc_init();
+
 	return ((nss_backend_t *)_nss_ldap_constr(netgroup_ops,
 	    sizeof (netgroup_ops)/sizeof (netgroup_ops[0]), _NETGROUP,
 	    netgrent_attrs, NULL));
diff --git a/usr/src/lib/nsswitch/ldap/common/provider.d b/usr/src/lib/nsswitch/ldap/common/provider.d
new file mode 100644
index 0000000000..52f3607249
--- /dev/null
+++ b/usr/src/lib/nsswitch/ldap/common/provider.d
@@ -0,0 +1,51 @@
+/*
+ * CDDL HEADER START
+ *
+ * This file and its contents are supplied under the terms of the
+ * Common Development and Distribution License ("CDDL"), version 1.0.
+ * You may only use this file in accordance with the terms of version
+ * 1.0 of the CDDL.
+ *
+ * A full copy of the text of the CDDL should have accompanied this
+ * source.  A copy of the CDDL is also available via the Internet at
+ * http://www.illumos.org/license/CDDL.
+ *
+ * CDDL HEADER END
+ */
+
+/*
+ * Copyright 2019 Joyent, Inc.
+ */
+
+provider nss_ldap {
+	/* netgroup-* probes all start with string, netgroup_t */
+	probe netgroup__cache__add__collision(string, uintptr_t, uintptr_t);
+	probe netgroup__cache__add(string, uintptr_t, int);
+	probe netgroup__cache__dispose(string, uintptr_t, int, int);
+	probe netgroup__cache__hold(string, uintptr_t, int);
+	probe netgroup__cache__free(string, uintptr_t);
+	probe netgroup__cache__rele(string, uintptr_t, int);
+	probe netgroup__cache__to__graveyard(string, uintptr_t);
+	probe netgroup__cache__triple(string, uintptr_t, string, string,
+	    string);
+	probe netgroup__get__from__cache(string, uintptr_t, int);
+	probe netgroup__reap(string, uintptr_t, uintptr_t);
+	probe netgroup__warmer__backwards(string, uintptr_t);
+	probe netgroup__warmer__enqueue(string, uintptr_t);
+	probe netgroup__warmer__expire(string, uintptr_t);
+	probe netgroup__warmer__ldap__fail(string, uintptr_t);
+	probe netgroup__warmer__no__stamp(string, uintptr_t);
+	probe netgroup__warmer__reload__fail(string, uintptr_t, int);
+	probe netgroup__warmer__reload__success(string, uintptr_t, uintptr_t);
+	probe netgroup__warmer__renewal(string, uintptr_t);
+	probe netgroup__warmer__resurrection(string, uintptr_t);
+
+	/* probes not starting with netgroup-* can be more diverse */
+	probe innetgr(string, string, string, string, int);
+};
+
+#pragma D attributes Evolving/Evolving/Common provider nss_ldap provider
+#pragma D attributes Private/Private/Unknown provider nss_ldap module
+#pragma D attributes Private/Private/Unknown provider nss_ldap function
+#pragma D attributes Evolving/Evolving/Common provider nss_ldap name
+#pragma D attributes Evolving/Evolving/Common provider nss_ldap args
diff --git a/usr/src/man/man4/nscd.conf.4 b/usr/src/man/man4/nscd.conf.4
index be0b415b61..7039008a9e 100644
--- a/usr/src/man/man4/nscd.conf.4
+++ b/usr/src/man/man4/nscd.conf.4
@@ -1,5 +1,6 @@
 '\" te
 .\"  Copyright (c) 2004 Sun Microsystems, Inc. All Rights Reserved
+.\"  Copyright 2019 Joyent, Inc.
 .\" The contents of this file are subject to the terms of the Common Development and Distribution License (the "License").  You may not use this file except in compliance with the License.
 .\" You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE or http://www.opensolaris.org/os/licensing.  See the License for the specific language governing permissions and limitations under the License.
 .\" When distributing Covered Code, include this CDDL HEADER in each file and include the License file at usr/src/OPENSOLARIS.LICENSE.  If applicable, add the following below this CDDL HEADER, with the fields enclosed by brackets "[]" replaced with your own identifying information: Portions Copyright [yyyy] [name of copyright owner]
@@ -25,8 +26,8 @@ not interpreted by \fBnscd\fR.
 \fIcachename\fR is represented by \fBhosts\fR, \fBipnodes\fR, \fBpasswd\fR,
 \fBgroup\fR, \fBexec_attr\fR, \fBprof_attr\fR, \fBuser_attr\fR, \fBethers\fR,
 \fBrpc\fR, \fBprotocols\fR, \fBnetworks\fR, \fBbootparams\fR,
-\fBauth_attr\fR, \fBservices\fR, \fBnetmasks\fR, \fBprinters\fR, or
-\fBproject\fR.
+\fBauth_attr\fR, \fBservices\fR, \fBnetmasks\fR, \fBprinters\fR,
+\fBproject\fR, or \fBnetgroup\fR..
 .sp
 .LP
 The \fIattribute\fR field supports the following:
