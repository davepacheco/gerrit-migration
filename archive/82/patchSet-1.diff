From 122defa33d96a6219fa3df9a84f9694762be80fe Mon Sep 17 00:00:00 2001
From: Jerry Jelinek <jerry.jelinek@joyent.com>
Date: Thu, 14 Jul 2016 21:56:55 +0000
Subject: [PATCH] OS-4900 lxbrand strace has detachment problems Reviewed by:
 Patrick Mooney <patrick.mooney@joyent.com>

---
 usr/src/uts/common/brand/lx/os/lx_ptrace.c | 75 +++++++++++++---------
 1 file changed, 44 insertions(+), 31 deletions(-)

diff --git a/usr/src/uts/common/brand/lx/os/lx_ptrace.c b/usr/src/uts/common/brand/lx/os/lx_ptrace.c
index ff85826ee9..f5834429c1 100644
--- a/usr/src/uts/common/brand/lx/os/lx_ptrace.c
+++ b/usr/src/uts/common/brand/lx/os/lx_ptrace.c
@@ -740,10 +740,15 @@ lx_stop_notify(proc_t *p, klwp_t *lwp, ushort_t why, ushort_t what)
  * For any restarting action (e.g. PTRACE_CONT, PTRACE_SYSCALL or
  * PTRACE_DETACH) to be allowed, the tracee LWP must be in "ptrace-stop".  This
  * check must ONLY be run on tracees of the current LWP.  If the check is
- * successful, we return with the tracee p_lock held.
+ * successful, we return with the tracee p_lock held. In the case of
+ * PTRACE_DETACH, we can return with the tracee locked even if it is not in
+ * "ptrace-stop". This can happen for various reasons, such as if the remote
+ * process is already job-stopped in the kernel. We must still be able to
+ * detach from this process.
  */
 static int
-lx_ptrace_lock_if_stopped(lx_ptrace_accord_t *accord, lx_lwp_data_t *remote)
+lx_ptrace_lock_if_stopped(lx_ptrace_accord_t *accord, lx_lwp_data_t *remote,
+    boolean_t detaching)
 {
 	klwp_t *rlwp = remote->br_lwp;
 	proc_t *rproc = lwptoproc(rlwp);
@@ -778,6 +783,14 @@ lx_ptrace_lock_if_stopped(lx_ptrace_accord_t *accord, lx_lwp_data_t *remote)
 	VERIFY(remote->br_ptrace_tracer == accord);
 
 	if (!(remote->br_ptrace_flags & LX_PTF_STOPPED)) {
+		if (detaching) {
+			/*
+			 * The tracee is not in "ptrace-stop", but we still
+			 * return with the locked process.
+			 */
+			return (ENOENT);
+		}
+
 		/*
 		 * The tracee is not in "ptrace-stop", so we release the
 		 * process.
@@ -907,15 +920,11 @@ lx_ptrace_cont(lx_lwp_data_t *remote, lx_ptrace_cont_flags_t flags, int signo)
  * Implements the PTRACE_DETACH subcommand of the Linux ptrace(2) interface.
  *
  * The LWP identified by the Linux pid "lx_pid" will, if it as a tracee of the
- * current LWP, be detached and set runnable.  If the specified LWP is not
- * currently in the "ptrace-stop" state, the routine will return ESRCH as if
- * the LWP did not exist at all.
- *
- * The caller must not hold p_lock on any process.
+ * current LWP, be detached and (optionally) set runnable.
  */
-static int
+static void
 lx_ptrace_detach(lx_ptrace_accord_t *accord, lx_lwp_data_t *remote, int signo,
-    boolean_t *release_hold)
+    boolean_t restart)
 {
 	klwp_t *rlwp = remote->br_lwp;
 
@@ -932,7 +941,6 @@ lx_ptrace_detach(lx_ptrace_accord_t *accord, lx_lwp_data_t *remote, int signo,
 	remote->br_ptrace_attach = LX_PTA_NONE;
 	remote->br_ptrace_tracer = NULL;
 	remote->br_ptrace_flags = 0;
-	*release_hold = B_TRUE;
 
 	/*
 	 * Decrement traced-lwp count for the process.
@@ -947,9 +955,9 @@ lx_ptrace_detach(lx_ptrace_accord_t *accord, lx_lwp_data_t *remote, int signo,
 	remote->br_ptrace_stopsig = signo;
 	remote->br_ptrace_donesig = 0;
 
-	lx_ptrace_restart_lwp(rlwp);
-
-	return (0);
+	if (restart) {
+		lx_ptrace_restart_lwp(rlwp);
+	}
 }
 
 /*
@@ -2059,7 +2067,7 @@ lx_sigcld_repost(proc_t *pp, sigqueue_t *sqp)
 		 * Check if this LWP is in "ptrace-stop".  If in the correct
 		 * stop condition, lock the process containing the tracee LWP.
 		 */
-		if (lx_ptrace_lock_if_stopped(accord, remote) != 0) {
+		if (lx_ptrace_lock_if_stopped(accord, remote, B_FALSE) != 0) {
 			continue;
 		}
 
@@ -2231,7 +2239,7 @@ lx_waitid_helper(idtype_t idtype, id_t id, k_siginfo_t *ip, int options,
 		 * Check if this LWP is in "ptrace-stop".  If in the correct
 		 * stop condition, lock the process containing the tracee LWP.
 		 */
-		if (lx_ptrace_lock_if_stopped(accord, remote) != 0) {
+		if (lx_ptrace_lock_if_stopped(accord, remote, B_FALSE) != 0) {
 			continue;
 		}
 
@@ -2403,7 +2411,7 @@ lx_ptrace_kernel(int ptrace_op, pid_t lxpid, uintptr_t addr, uintptr_t data)
 	klwp_t *rlwp;
 	proc_t *rproc;
 	int error;
-	boolean_t found = B_FALSE;
+	boolean_t found = B_FALSE, restart = B_TRUE;
 
 	/*
 	 * PTRACE_TRACEME and PTRACE_ATTACH operations induce the tracing of
@@ -2461,12 +2469,21 @@ lx_ptrace_kernel(int ptrace_op, pid_t lxpid, uintptr_t addr, uintptr_t data)
 	/*
 	 * Attempt to lock the target LWP.
 	 */
-	if ((error = lx_ptrace_lock_if_stopped(accord, remote)) != 0) {
+	if ((error = lx_ptrace_lock_if_stopped(accord, remote,
+	    (ptrace_op == LX_PTRACE_DETACH))) != 0) {
 		/*
 		 * The LWP was not in "ptrace-stop".
 		 */
-		mutex_exit(&accord->lxpa_tracees_lock);
-		return (error);
+		if (ptrace_op != LX_PTRACE_DETACH || error != ENOENT) {
+			mutex_exit(&accord->lxpa_tracees_lock);
+			return (error);
+		}
+
+		/*
+		 * We're detaching, but the process was not in ptrace_stop, so
+		 * we don't want to try to restart it.
+		 */
+		restart = B_FALSE;
 	}
 
 	/*
@@ -2478,25 +2495,21 @@ lx_ptrace_kernel(int ptrace_op, pid_t lxpid, uintptr_t addr, uintptr_t data)
 
 
 	if (ptrace_op == LX_PTRACE_DETACH) {
-		boolean_t release_hold = B_FALSE;
-		error = lx_ptrace_detach(accord, remote, (int)data,
-		    &release_hold);
+		lx_ptrace_detach(accord, remote, (int)data, restart);
 		/*
 		 * Drop the lock on both the tracee process and the tracee list.
 		 */
 		mutex_exit(&rproc->p_lock);
 		mutex_exit(&accord->lxpa_tracees_lock);
 
-		if (release_hold) {
-			/*
-			 * Release a hold from the accord.
-			 */
-			lx_ptrace_accord_enter(accord);
-			lx_ptrace_accord_rele(accord);
-			lx_ptrace_accord_exit(accord);
-		}
+		/*
+		 * Release a hold from the accord.
+		 */
+		lx_ptrace_accord_enter(accord);
+		lx_ptrace_accord_rele(accord);
+		lx_ptrace_accord_exit(accord);
 
-		return (error);
+		return (0);
 	}
 
 	/*
-- 
2.21.0

