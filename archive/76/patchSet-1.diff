From e06cb3ff9570f4935e135ecce9dc5906110d92b8 Mon Sep 17 00:00:00 2001
From: Patrick Mooney <pmooney@pfmooney.com>
Date: Tue, 12 Jul 2016 22:37:46 +0000
Subject: [PATCH] OS-5510 remove lwp_brand_syscall_fast handler

---
 usr/src/uts/common/brand/lx/os/lx_misc.c    |  2 -
 usr/src/uts/common/brand/lx/os/lx_syscall.c | 93 ---------------------
 usr/src/uts/common/brand/lx/sys/lx_brand.h  |  2 -
 usr/src/uts/common/sys/klwp.h               |  7 +-
 usr/src/uts/i86pc/ml/offsets.in             |  1 -
 usr/src/uts/i86pc/ml/syscall_asm_amd64.s    | 34 +-------
 6 files changed, 2 insertions(+), 137 deletions(-)

diff --git a/usr/src/uts/common/brand/lx/os/lx_misc.c b/usr/src/uts/common/brand/lx/os/lx_misc.c
index 5932495655..01fbfca382 100644
--- a/usr/src/uts/common/brand/lx/os/lx_misc.c
+++ b/usr/src/uts/common/brand/lx/os/lx_misc.c
@@ -321,7 +321,6 @@ lx_freelwp(klwp_t *lwp)
 	 * Remove our system call interposer.
 	 */
 	lwp->lwp_brand_syscall = NULL;
-	lwp->lwp_brand_syscall_fast = NULL;
 
 	(void) removectx(lwptot(lwp), lwp, lx_save, lx_restore, NULL, NULL,
 	    lx_save, NULL);
@@ -472,7 +471,6 @@ lx_initlwp(klwp_t *lwp, void *lwpbd)
 	 * Install branded system call hooks for this LWP:
 	 */
 	lwp->lwp_brand_syscall = lx_syscall_enter;
-	lwp->lwp_brand_syscall_fast = lx_syscall_fast_enter;
 
 	/*
 	 * The new LWP inherits the parent LWP cgroup ID.
diff --git a/usr/src/uts/common/brand/lx/os/lx_syscall.c b/usr/src/uts/common/brand/lx/os/lx_syscall.c
index 4371cd801d..35020f4fe6 100644
--- a/usr/src/uts/common/brand/lx/os/lx_syscall.c
+++ b/usr/src/uts/common/brand/lx/os/lx_syscall.c
@@ -516,99 +516,6 @@ lx_vsyscall_iscall(klwp_t *lwp, uintptr_t addr, int *scnum)
 }
 #endif
 
-/*
- * This function is used to provide a fasttrap-like interface for emulated
- * syscalls.  By skipping housekeeping such as mstate transitions, it should
- * cut down on overhead for syscalls which would normally be fasttraps in a
- * native process.
- */
-int
-lx_syscall_fast_enter(void)
-{
-	klwp_t *lwp = ttolwp(curthread);
-	lx_lwp_data_t *lwpd = lwptolxlwp(lwp);
-	struct regs *rp = lwptoregs(lwp);
-	int syscall_num, error;
-	lx_sysent_t *s;
-	uintptr_t args[6];
-	long ret = 0;
-
-	/*
-	 * If we got here, we should have an LWP-specific brand data structure.
-	 */
-	VERIFY(lwpd != NULL);
-
-	if (lwpd->br_stack_mode != LX_STACK_MODE_BRAND) {
-		/*
-		 * The lwp is not in in BRAND execution mode, so we return to
-		 * the regular native system call path.
-		 */
-		DTRACE_PROBE(brand__lx__syscall__hook__skip);
-		return (1);
-	}
-	if (lwpd->br_ptrace_tracer != NULL) {
-		/*
-		 * Given that ptrace is the antithesis of "fast", return to the
-		 * regular system call path if we are being traced.
-		 */
-		return (1);
-	}
-
-	syscall_num = (int)rp->r_r0;
-#if defined(_LP64)
-	if (get_udatamodel() != DATAMODEL_NATIVE) {
-		switch (syscall_num) {
-		case LX_SYS32_gettimeofday:
-		case LX_SYS32_time:
-		case LX_SYS32_clock_gettime:
-		case LX_SYS32_getcpu:
-			s = &lx_sysent32[syscall_num];
-			break;
-		default:
-			return (1);
-		}
-	} else
-#endif
-	{
-		switch (syscall_num) {
-		case LX_SYS_gettimeofday:
-		case LX_SYS_time:
-		case LX_SYS_clock_gettime:
-		case LX_SYS_getcpu:
-#if defined(_LP64)
-			s = &lx_sysent64[syscall_num];
-#else
-			s = &lx_sysent32[syscall_num];
-#endif
-			break;
-		default:
-			return (1);
-		}
-	}
-
-	/*
-	 * The above syscall restrictions should ensure that we do not arrive
-	 * at this point without a suitable syscall planned.  Since the
-	 * lx_emulate_args routine can only fail for 6-arg syscalls, none of
-	 * which would be performed as a fasttrap, it is assumed to succeed.
-	 */
-	VERIFY(s->sy_callc != NULL);
-	VERIFY(s->sy_narg < 6);
-	(void) lx_emulate_args(lwp, s, args);
-	lx_trace_sysenter(syscall_num, args);
-	ret = s->sy_callc(args[0], args[1], args[2], args[3], args[4],
-	    args[5]);
-
-	if ((error = lwp->lwp_errno) != 0) {
-		ret = -lx_errno(error, EINVAL);
-		lwp->lwp_errno = 0;
-	}
-	rp->r_r0 = ret;
-	lx_trace_sysreturn(syscall_num, ret);
-	lwp->lwp_eosys = JUSTRETURN;
-	return (0);
-}
-
 /*
  * Linux defines system call numbers for 32-bit x86 in the file:
  *   arch/x86/syscalls/syscall_32.tbl
diff --git a/usr/src/uts/common/brand/lx/sys/lx_brand.h b/usr/src/uts/common/brand/lx/sys/lx_brand.h
index 01b74f727e..44ea80070d 100644
--- a/usr/src/uts/common/brand/lx/sys/lx_brand.h
+++ b/usr/src/uts/common/brand/lx/sys/lx_brand.h
@@ -634,8 +634,6 @@ extern void lx_switch_to_native(klwp_t *);
 extern int lx_syscall_enter(void);
 extern void lx_syscall_return(klwp_t *, int, long);
 
-extern int lx_syscall_fast_enter(void);
-
 extern void lx_trace_sysenter(int, uintptr_t *);
 extern void lx_trace_sysreturn(int, long);
 
diff --git a/usr/src/uts/common/sys/klwp.h b/usr/src/uts/common/sys/klwp.h
index bdbff0be9b..0ea1a396b9 100644
--- a/usr/src/uts/common/sys/klwp.h
+++ b/usr/src/uts/common/sys/klwp.h
@@ -24,7 +24,7 @@
  */
 
 /*
- * Copyright 2015 Joyent, Inc.
+ * Copyright 2016 Joyent, Inc.
  */
 
 #ifndef	_SYS_KLWP_H
@@ -195,14 +195,9 @@ typedef struct _klwp {
 	 * Branding:
 	 * lwp_brand			- per-lwp brand data
 	 * lwp_brand_syscall		- brand syscall interposer
-	 * lwp_brand_syscall_fast	- brand "fast path" syscall interposer
-	 *
-	 * The lwp_brand_syscall_fast handler should only be used if an
-	 * lwp_brand_syscall handler is also in place.
 	 */
 	void	*lwp_brand;
 	int	(*lwp_brand_syscall)(void);
-	int	(*lwp_brand_syscall_fast)(void);
 
 	struct psinfo *lwp_spymaster;	/* if an agent LWP, our spymaster */
 } klwp_t;
diff --git a/usr/src/uts/i86pc/ml/offsets.in b/usr/src/uts/i86pc/ml/offsets.in
index a1f83d3cf8..406d389000 100644
--- a/usr/src/uts/i86pc/ml/offsets.in
+++ b/usr/src/uts/i86pc/ml/offsets.in
@@ -153,7 +153,6 @@ _klwp
 	lwp_procp
 	lwp_brand
 	lwp_brand_syscall
-	lwp_brand_syscall_fast
 	lwp_eosys
 	lwp_regs
 	lwp_arg
diff --git a/usr/src/uts/i86pc/ml/syscall_asm_amd64.s b/usr/src/uts/i86pc/ml/syscall_asm_amd64.s
index bc901e3e42..a4dd2722b6 100644
--- a/usr/src/uts/i86pc/ml/syscall_asm_amd64.s
+++ b/usr/src/uts/i86pc/ml/syscall_asm_amd64.s
@@ -20,7 +20,7 @@
  */
 /*
  * Copyright (c) 2004, 2010, Oracle and/or its affiliates. All rights reserved.
- * Copyright 2015 Joyent, Inc.
+ * Copyright 2016 Joyent, Inc.
  */
 
 #include <sys/asm_linkage.h>
@@ -506,22 +506,6 @@ noprod_sys_syscall:
 
 	ENABLE_INTR_FLAGS
 
-	/*
-	 * If our LWP has a branded syscall_fast handler, execute it.  A return
-	 * code of zero indicates that the handler completely processed the syscall
-	 * and we can return directly to userspace.
-	 */
-	movq	LWP_BRAND_SYSCALL_FAST(%r14), %rdi
-	testq	%rdi, %rdi
-	jz	_syscall_no_brand_fast
-	call	*%rdi
-	testl	%eax, %eax
-	jnz	_syscall_no_brand_fast
-	incq	LWP_RU_SYSC(%r14)
-	incq	%gs:CPU_STATS_SYS_SYSCALL
-	jmp	_sys_rtt
-
-_syscall_no_brand_fast:
 	MSTATE_TRANSITION(LMS_USER, LMS_SYSTEM)
 	movl	REGOFF_RAX(%rsp), %eax	/* (%rax damaged by mstate call) */
 
@@ -828,22 +812,6 @@ _syscall32_save:
 
 	ENABLE_INTR_FLAGS
 
-	/*
-	 * If our LWP has a branded syscall_fast handler, execute it.  A return
-	 * code of zero indicates that the handler completely processed the syscall
-	 * and we can return directly to userspace.
-	 */
-	movq	LWP_BRAND_SYSCALL_FAST(%r14), %rdi
-	testq	%rdi, %rdi
-	jz	_syscall32_no_brand_fast
-	call	*%rdi
-	testl	%eax, %eax
-	jnz	_syscall32_no_brand_fast
-	incq	LWP_RU_SYSC(%r14)
-	incq	%gs:CPU_STATS_SYS_SYSCALL
-	jmp	_sys_rtt
-
-_syscall32_no_brand_fast:
 	MSTATE_TRANSITION(LMS_USER, LMS_SYSTEM)
 	movl	REGOFF_RAX(%rsp), %eax	/* (%rax damaged by mstate call) */
 
-- 
2.21.0

