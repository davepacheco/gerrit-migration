From ced6eaa2b0e164011a078028faecac0943bed5ca Mon Sep 17 00:00:00 2001
From: Jan Wyszynski <jan.wyszynski@joyent.com>
Date: Thu, 17 Aug 2017 19:04:36 +0000
Subject: [PATCH] joyent/node-cueball#124 new getPool api method for
 CueBallAgent

---
 docs/api.adoc | 24 ++++++++++++++
 lib/agent.js  | 89 +++++++++++++++++++++++++++++++++++++++------------
 2 files changed, 93 insertions(+), 20 deletions(-)

diff --git a/docs/api.adoc b/docs/api.adoc
index 2fbe6ef..98887a7 100644
--- a/docs/api.adoc
+++ b/docs/api.adoc
@@ -61,6 +61,30 @@ held by the pool). The `stop()` method should be used on an Agent if your
 program does not plan to use it again and wishes to be able to exit node
 without calling `process.exit()`.
 
+### `#getPool([host])`
+
+Returns the connection pool this agent has created for the input host,
+or creates one if it doesn't already exist.
+
+Parameters
+
+- `host` -- hostname of the host for which the pool is being requested.
+
+### `#createPool(host, [options])`
+
+Creates and returns a connection pool for the host identified by the
+input host name if one doesn't already exist. You can either provide
+a resolver directly in the options parameter or have one allocated by
+cueball. If you provide a resolver, Agent#stop will not effect it's
+state when used to stop the pool to which it belongs, but cueball
+will forget about the resolver once the pool is cleaned up.
+
+Parameters
+
+- `host` -- hostname of the host for which the pool is being requested.
+- `options` -- an optional Object, with keys:
+    * `resolver` - Object satisfying the Resolver interface.
+
 [[pool]]
 ## ConnectionPool
 
diff --git a/lib/agent.js b/lib/agent.js
index 4c58c65..f368bd4 100644
--- a/lib/agent.js
+++ b/lib/agent.js
@@ -54,6 +54,7 @@ function CueBallAgent(options) {
 
 	this.pools = {};
 	this.poolResolvers = {};
+	this.poolExternalResolvers = {};
 	this.resolvers = options.resolvers;
 	this.log = options.log || mod_bunyan.createLogger({
 		name: 'cueball'
@@ -111,16 +112,24 @@ CueBallAgent.prototype.addPool = function (host, options) {
 	if (typeof (options.port) === 'string')
 		defPort = parseInt(options.port, 10);
 	mod_assert.optionalNumber(defPort, 'default port');
-	var res = mod_resolver.resolverForIpOrDomain({
-		input: host,
-		resolverConfig: {
-			resolvers: this.resolvers,
-			service: this.service,
-			defaultPort: defPort,
-			recovery: this.cba_recovery,
-			log: this.log
-		}
-	});
+
+	var res;
+	var useExternalResolver = options.hasOwnProperty('resolver');
+
+	if (useExternalResolver) {
+		res = options.resolver;
+	} else {
+		res = mod_resolver.resolverForIpOrDomain({
+			input: host,
+			resolverConfig: {
+				resolvers: this.resolvers,
+				service: this.service,
+				defaultPort: defPort,
+				recovery: this.cba_recovery,
+				log: this.log
+			}
+		});
+	}
 	var poolOpts = {
 		resolver: res,
 		domain: host,
@@ -167,36 +176,40 @@ CueBallAgent.prototype.addPool = function (host, options) {
 			nsock = mod_net.createConnection(opts);
 		}
 		if (self.tcpKAID !== undefined &&
-		    self.tcpKAID !== null) {
+			self.tcpKAID !== null) {
 			nsock.on('connect', function () {
 				if (USE_SECURECONNECT &&
-				    self.protocol === 'https:') {
+					self.protocol === 'https:') {
 					nsock.socket.setKeepAlive(true,
-					    self.tcpKAID);
+						self.tcpKAID);
 				} else {
 					nsock.setKeepAlive(true,
-					    self.tcpKAID);
+						self.tcpKAID);
 				}
 			});
 		}
 		return (nsock);
 	}
 	if (this.cba_ping !== undefined &&
-	    this.cba_ping !== null) {
+		this.cba_ping !== null) {
 		poolOpts.checkTimeout = this.cba_pingInterval || 30000;
 		poolOpts.checker = this.checkSocket.bind(this, host);
 	}
 	this.log.debug({ host: host }, 'CueBallAgent creating new pool');
 	this.pools[host] = new Pool(poolOpts);
 	res.start();
-	this.poolResolvers[host] = res;
+	if (useExternalResolver) {
+		this.poolExternalResolvers[host] = res;
+	} else {
+		this.poolResolvers[host] = res;
+	}
 };
 
 CueBallAgent.prototype.stop = function (cb) {
 	var self = this;
 	if (this.cba_stopped) {
 		throw (new Error('Cannot stop a CueBallAgent that has ' +
-		    'already stopped'));
+					'already stopped'));
 	}
 	this.cba_stopped = true;
 	this.log.debug('CueBallAgent stopping all pools');
@@ -214,16 +227,28 @@ CueBallAgent.prototype.stop = function (cb) {
 	function stopPool(host, pcb) {
 		var pool = self.pools[host];
 		var res = self.poolResolvers[host];
+		var hasExternalResolver = false;
+
 		delete (self.pools[host]);
-		delete (self.poolResolvers[host]);
+
+		if (res === undefined) {
+			res = self.poolExternalResolvers[host];
+			mod_assert.ok(res, 'found pool with no resolver');
+			hasExternalResolver = true;
+			delete (self.poolExternalResolvers[host]);
+		} else {
+			delete (self.poolResolvers[host]);
+		}
+
 		if (pool.isInState('stopped')) {
 			pcb();
-			if (!res.isInState('stopped'))
+			if (!hasExternalResolver && !res.isInState('stopped'))
 				res.stop();
 		} else {
 			pool.on('stateChanged', function (st) {
 				if (st === 'stopped') {
-					if (!res.isInState('stopped'))
+					if (!hasExternalResolver &&
+						!res.isInState('stopped'))
 						res.stop();
 					pcb();
 				}
@@ -423,6 +448,30 @@ CueBallAgent.prototype.checkSocket = function (host, handle, socket) {
 	req.end();
 };
 
+/* Used by muskie to check for recent shark connections. */
+CueBallAgent.prototype.getPool = function (host) {
+	mod_assert.string(host, 'hostname');
+	return (this.pools[host]);
+};
+
+/* Used by muskie to create a pool if one doesn't already exist. */
+CueBallAgent.prototype.createPool = function (host, options) {
+	mod_assert.string(host, 'hostname');
+	if (this.pools[host] === undefined) {
+		if (options && options.hasOwnProperty('resolver')) {
+			var opts = {
+				resolver: options['resolver']
+			};
+			this.addPool(host, opts);
+		} else {
+			this.addPool(host, {});
+		}
+	} else {
+		throw (new Error('Attempting to create a pool for a hostname ' +
+					'that already has one.'));
+	}
+};
+
 /* Only used by UNIX socket connections with "socketPath" set. */
 CueBallAgent.prototype.createConnection = function (options, connectListener) {
 	throw (new Error('UNIX domain sockets not supported'));
-- 
2.21.0

