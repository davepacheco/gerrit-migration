commit e55a5545c28699a124841f128799b205ea30e96e (refs/changes/50/2550/3)
Author: Dan McDonald <danmcd@joyent.com>
Date:   2017-09-12T21:50:57-04:00 (2 years, 1 month ago)
    
    OS-6333 sadb_x_kmc_t's KM cookie should be 64-bits

diff --git a/usr/src/lib/libipsecutil/common/ipsec_util.c b/usr/src/lib/libipsecutil/common/ipsec_util.c
index ad9410b8b4..8d50403330 100644
--- a/usr/src/lib/libipsecutil/common/ipsec_util.c
+++ b/usr/src/lib/libipsecutil/common/ipsec_util.c
@@ -1152,6 +1152,9 @@ error:
  * not found).  Note that the returned label pointer points to a static
  * string, so the label will be overwritten by a subsequent call to the
  * function; the function is also not thread-safe as a result.
+ *
+ * Because this is possibly publically exported, do not change its name,
+ * but this is for all intents and purposes an IKEv1/in.iked function.
  */
 char *
 kmc_lookup_by_cookie(int cookie)
@@ -2591,13 +2594,32 @@ print_kmc(FILE *file, char *prefix, struct sadb_x_kmc *kmc)
 {
 	char *cookie_label;
 
-	if ((cookie_label = kmc_lookup_by_cookie(kmc->sadb_x_kmc_cookie)) ==
-	    NULL)
-		cookie_label = dgettext(TEXT_DOMAIN, "<Label not found.>");
+	switch (kmc->sadb_x_kmc_proto) {
+	case SADB_X_KMP_IKE:
+		cookie_label = kmc_lookup_by_cookie(kmc->sadb_x_kmc_cookie);
+		if (cookie_label == NULL)
+			cookie_label =
+			    dgettext(TEXT_DOMAIN, "<Label not found.>");
+		(void) fprintf(file, dgettext(TEXT_DOMAIN,
+			"%sProtocol %u, cookie=\"%s\" (%u)\n"), prefix,
+		    kmc->sadb_x_kmc_proto, cookie_label,
+		    kmc->sadb_x_kmc_cookie);
+		return;
+	case SADB_X_KMP_MANUAL:
+		cookie_label = dgettext(TEXT_DOMAIN, "Manual SA with cookie");
+		break;
+	/* case SADB_X_KMP_IKEV2: */
+	default:
+		cookie_label =
+		    dgettext(TEXT_DOMAIN, "<unknown KM protocol>");
+		break;
+	}
 
+	/* XXX KEBE ASKS... htonll() on generic kmc_cookie? */
 	(void) fprintf(file, dgettext(TEXT_DOMAIN,
-	    "%sProtocol %u, cookie=\"%s\" (%u)\n"), prefix,
-	    kmc->sadb_x_kmc_proto, cookie_label, kmc->sadb_x_kmc_cookie);
+		"%sProtocol %u, cookie=\"%s\" (0x%"PRIx64"/%"PRIu64")\n"),
+	    prefix, kmc->sadb_x_kmc_proto, cookie_label,
+	    kmc->sadb_x_kmc_cookie64, kmc->sadb_x_kmc_cookie64);
 }
 
 /*
diff --git a/usr/src/lib/libipsecutil/common/ipsec_util.h b/usr/src/lib/libipsecutil/common/ipsec_util.h
index 6c555472cc..9d7d318474 100644
--- a/usr/src/lib/libipsecutil/common/ipsec_util.h
+++ b/usr/src/lib/libipsecutil/common/ipsec_util.h
@@ -225,7 +225,7 @@ void libssl_load(void);
 void libcrypto_load(void);
 
 /*
- * functions to manipulate the kmcookie-label mapping file
+ * functions to manipulate the IKEv1 kmcookie-label mapping file
  */
 
 #define	KMCFILE		"/var/run/ipsec_kmc_map"
diff --git a/usr/src/uts/common/inet/ip/sadb.c b/usr/src/uts/common/inet/ip/sadb.c
index d6dfa5705f..c7d479fb5e 100644
--- a/usr/src/uts/common/inet/ip/sadb.c
+++ b/usr/src/uts/common/inet/ip/sadb.c
@@ -1043,7 +1043,7 @@ sadb_make_addr_ext(uint8_t *start, uint8_t *end, uint16_t exttype,
  */
 
 static uint8_t *
-sadb_make_kmc_ext(uint8_t *cur, uint8_t *end, uint32_t kmp, uint32_t kmc)
+sadb_make_kmc_ext(uint8_t *cur, uint8_t *end, uint32_t kmp, uint64_t kmc)
 {
 	sadb_x_kmc_t *kmcext = (sadb_x_kmc_t *)cur;
 
@@ -1058,8 +1058,7 @@ sadb_make_kmc_ext(uint8_t *cur, uint8_t *end, uint32_t kmp, uint32_t kmc)
 	kmcext->sadb_x_kmc_len = SADB_8TO64(sizeof (*kmcext));
 	kmcext->sadb_x_kmc_exttype = SADB_X_EXT_KM_COOKIE;
 	kmcext->sadb_x_kmc_proto = kmp;
-	kmcext->sadb_x_kmc_cookie = kmc;
-	kmcext->sadb_x_kmc_reserved = 0;
+	kmcext->sadb_x_kmc_cookie64 = kmc;
 
 	return (cur);
 }
@@ -2330,8 +2329,13 @@ sadb_form_query(keysock_in_t *ksi, uint32_t req, uint32_t match,
 	sq->kmp = 0;
 
 	if ((match & IPSA_Q_KMC) && (sq->kmcext)) {
-		sq->kmc = sq->kmcext->sadb_x_kmc_cookie;
 		sq->kmp = sq->kmcext->sadb_x_kmc_proto;
+		/* Be liberal in what we receive.  Special-case IKEv1. */
+		if (sq->kmp == SADB_X_KMP_IKE) {
+			/* Just in case in.iked is misbehaving... */
+			sq->kmcext->sadb_x_kmc_reserved = 0;
+		}
+		sq->kmc = sq->kmcext->sadb_x_kmc_cookie64;
 		*mfpp++ = sadb_match_kmc;
 	}
 
@@ -3133,7 +3137,12 @@ sadb_common_add(queue_t *pfkey_q, mblk_t *mp, sadb_msg_t *samsg,
 
 	if (kmcext != NULL) {
 		newbie->ipsa_kmp = kmcext->sadb_x_kmc_proto;
-		newbie->ipsa_kmc = kmcext->sadb_x_kmc_cookie;
+		/* Be liberal in what we receive.  Special-case IKEv1. */
+		if (newbie->ipsa_kmp == SADB_X_KMP_IKE) {
+			/* Just in case in.iked is misbehaving... */
+			kmcext->sadb_x_kmc_reserved = 0;
+		}
+		newbie->ipsa_kmc = kmcext->sadb_x_kmc_cookie64;
 	}
 
 	/*
@@ -4436,7 +4445,7 @@ static int
 sadb_check_kmc(ipsa_query_t *sq, ipsa_t *sa, int *diagnostic)
 {
 	uint32_t kmp = sq->kmp;
-	uint32_t kmc = sq->kmc;
+	uint64_t kmc = sq->kmc;
 
 	if (sa == NULL)
 		return (0);
@@ -4464,7 +4473,7 @@ static void
 sadb_update_kmc(ipsa_query_t *sq, ipsa_t *sa)
 {
 	uint32_t kmp = sq->kmp;
-	uint32_t kmc = sq->kmc;
+	uint64_t kmc = sq->kmc;
 
 	if (kmp != 0)
 		sa->ipsa_kmp = kmp;
@@ -5107,7 +5116,8 @@ sadb_acquire_prop(ipsec_action_t *ap, netstack_t *ns, boolean_t do_esp)
 	    emaxbits, replay;
 	uint64_t softbytes, hardbytes, softaddtime, hardaddtime, softusetime,
 	    hardusetime;
-	uint32_t kmc = 0, kmp = 0;
+	uint64_t kmc = 0;
+	uint32_t kmp = 0;
 
 	/*
 	 * Since it's an rwlock read, AND writing to the IPsec algorithms is
@@ -5297,7 +5307,6 @@ bail:
 /*
  * Generate an extended ACQUIRE's extended-proposal extension.
  */
-/* ARGSUSED */
 static mblk_t *
 sadb_acquire_extended_prop(ipsec_action_t *ap, netstack_t *ns)
 {
@@ -5305,7 +5314,8 @@ sadb_acquire_extended_prop(ipsec_action_t *ap, netstack_t *ns)
 	uint8_t *cur, *end;
 	mblk_t *mp;
 	int allocsize, numecombs = 0, numalgdescs = 0;
-	uint32_t kmc = 0, kmp = 0, replay = 0;
+	uint32_t kmp = 0, replay = 0;
+	uint64_t kmc = 0;
 	ipsec_action_t *walker;
 
 	allocsize = sizeof (*eprop);
diff --git a/usr/src/uts/common/inet/ipsec_impl.h b/usr/src/uts/common/inet/ipsec_impl.h
index 80e35e6ad4..46e580d39e 100644
--- a/usr/src/uts/common/inet/ipsec_impl.h
+++ b/usr/src/uts/common/inet/ipsec_impl.h
@@ -236,7 +236,7 @@ typedef struct ipsec_prot
 	uint16_t	ipp_espa_minbits;	 /* ESP auth: min keylen */
 	uint16_t	ipp_espa_maxbits;	 /* ESP auth: max keylen */
 	uint32_t	ipp_km_proto;		 /* key mgmt protocol */
-	uint32_t	ipp_km_cookie;		 /* key mgmt cookie */
+	uint64_t	ipp_km_cookie;		 /* key mgmt cookie */
 	uint32_t	ipp_replay_depth;	 /* replay window */
 	/* XXX add lifetimes */
 } ipsec_prot_t;
diff --git a/usr/src/uts/common/inet/sadb.h b/usr/src/uts/common/inet/sadb.h
index 3dad99c0dd..910d7c6ea5 100644
--- a/usr/src/uts/common/inet/sadb.h
+++ b/usr/src/uts/common/inet/sadb.h
@@ -247,7 +247,7 @@ typedef struct ipsa_s {
 	uint32_t ipsa_spi;	/* Security parameters index. */
 	uint32_t ipsa_replay;	/* Highest seen replay value for this SA. */
 	uint32_t ipsa_kmp;	/* key management proto */
-	uint32_t ipsa_kmc;	/* key management cookie */
+	uint64_t ipsa_kmc;	/* key management cookie (now 64-bit) */
 
 	boolean_t ipsa_haspeer;		/* Has peer in another table. */
 
@@ -690,7 +690,8 @@ struct ipsa_query_s {
 	sa_family_t af;
 	uint32_t *srcaddr, *dstaddr;
 	uint32_t ifindex;
-	uint32_t kmc, kmp;
+	uint32_t kmp;
+	uint64_t kmc;
 	char *didstr, *sidstr;
 	uint16_t didtype, sidtype;
 	sadbp_t *spp;
diff --git a/usr/src/uts/common/net/pfkeyv2.h b/usr/src/uts/common/net/pfkeyv2.h
index e05195ce4f..67cf3eb84c 100644
--- a/usr/src/uts/common/net/pfkeyv2.h
+++ b/usr/src/uts/common/net/pfkeyv2.h
@@ -477,10 +477,11 @@ typedef struct sadb_x_kmc {
 			uint32_t sadb_x_kmc_ucookie;	/* KMP-specific */
 			uint32_t sadb_x_kmc_ureserved;	/* Must be zero */
 		} sadb_x_kmc_actual;
-		uint64_t sadb_x_kmc_alignment;
+		uint64_t sadb_x_kmc_ucookie64;
 	} sadb_x_kmc_u;
 #define	sadb_x_kmc_cookie sadb_x_kmc_u.sadb_x_kmc_actual.sadb_x_kmc_ucookie
 #define	sadb_x_kmc_reserved sadb_x_kmc_u.sadb_x_kmc_actual.sadb_x_kmc_ureserved
+#define	sadb_x_kmc_cookie64 sadb_x_kmc_u.sadb_x_kmc_ucookie64
 } sadb_x_kmc_t;
 
 typedef struct sadb_x_pair {
