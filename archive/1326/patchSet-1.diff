From 7d790db69dcbb83b0162e91b28dff6249fa52963 Mon Sep 17 00:00:00 2001
From: Keith M Wesolowski <wesolows@foobazco.org>
Date: Fri, 24 May 2013 23:14:30 +0000
Subject: [PATCH] MANTA-1274 nginx calls fsync(3C) too often MANTA-1375 nginx
 doesn't honor content-md5, need data integrity muskie to mako

---
 src/core/ngx_file.c                    |   8 ++
 src/core/ngx_file.h                    |   4 +-
 src/http/modules/ngx_http_dav_module.c | 149 +++++++++++++++++++++++++
 src/http/ngx_http_core_module.c        |  10 --
 src/http/ngx_http_core_module.h        |   1 -
 src/http/ngx_http_request.c            |   4 +
 src/http/ngx_http_request.h            |   2 +
 src/http/ngx_http_request_body.c       |   6 +-
 src/http/ngx_http_variables.c          |   3 +
 src/os/unix/ngx_files.c                |  14 +--
 src/os/unix/ngx_files.h                |   8 ++
 11 files changed, 184 insertions(+), 25 deletions(-)

diff --git a/src/core/ngx_file.c b/src/core/ngx_file.c
index fc2dfd32..6105272f 100644
--- a/src/core/ngx_file.c
+++ b/src/core/ngx_file.c
@@ -109,6 +109,7 @@ ssize_t
 ngx_write_chain_to_temp_file(ngx_temp_file_t *tf, ngx_chain_t *chain)
 {
     ngx_int_t  rc;
+    ngx_chain_t *cl;
 
     if (tf->file.fd == NGX_INVALID_FILE) {
         rc = ngx_create_temp_file(&tf->file, tf->path, tf->pool,
@@ -124,6 +125,13 @@ ngx_write_chain_to_temp_file(ngx_temp_file_t *tf, ngx_chain_t *chain)
         }
     }
 
+    if (tf->md5) {
+        for (cl = chain; cl != NULL; cl = cl->next) {
+            ngx_md5_update(&tf->md5ctx, cl->buf->pos,
+                           cl->buf->last - cl->buf->pos);
+        }
+    }
+
 #if (NGX_THREADS && NGX_HAVE_PWRITEV)
 
     if (tf->thread_write) {
diff --git a/src/core/ngx_file.h b/src/core/ngx_file.h
index eda11ef0..6f2d10da 100644
--- a/src/core/ngx_file.h
+++ b/src/core/ngx_file.h
@@ -11,6 +11,7 @@
 
 #include <ngx_config.h>
 #include <ngx_core.h>
+#include <ngx_md5.h>
 
 
 struct ngx_file_s {
@@ -36,7 +37,6 @@ struct ngx_file_s {
 
     unsigned                   valid_info:1;
     unsigned                   directio:1;
-    unsigned                   fsync:1;
 };
 
 
@@ -70,6 +70,7 @@ typedef struct {
 typedef struct {
     ngx_file_t                 file;
     off_t                      offset;
+    ngx_md5_t                  md5ctx;
     ngx_path_t                *path;
     ngx_pool_t                *pool;
     char                      *warn;
@@ -80,6 +81,7 @@ typedef struct {
     unsigned                   persistent:1;
     unsigned                   clean:1;
     unsigned                   thread_write:1;
+    unsigned                   md5:1;
 } ngx_temp_file_t;
 
 
diff --git a/src/http/modules/ngx_http_dav_module.c b/src/http/modules/ngx_http_dav_module.c
index 36002656..1b382132 100644
--- a/src/http/modules/ngx_http_dav_module.c
+++ b/src/http/modules/ngx_http_dav_module.c
@@ -23,6 +23,11 @@ typedef struct {
     ngx_uint_t  access;
     ngx_uint_t  min_delete_depth;
     ngx_flag_t  create_full_put_path;
+#if (NGX_HAVE_FSYNC)
+    ngx_flag_t  fsync;
+#endif
+    ngx_flag_t  md5_header;
+    ngx_uint_t  content_md5_fail_status;
 } ngx_http_dav_loc_conf_t;
 
 
@@ -104,6 +109,29 @@ static ngx_command_t  ngx_http_dav_commands[] = {
       offsetof(ngx_http_dav_loc_conf_t, access),
       NULL },
 
+#if (NGX_HAVE_FSYNC)
+    { ngx_string("fsync"),
+      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_FLAG,
+      ngx_conf_set_flag_slot,
+      NGX_HTTP_LOC_CONF_OFFSET,
+      offsetof(ngx_http_dav_loc_conf_t, fsync),
+      NULL },
+#endif
+
+    { ngx_string("put_always_respond_md5"),
+      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_FLAG,
+      ngx_conf_set_flag_slot,
+      NGX_HTTP_LOC_CONF_OFFSET,
+      offsetof(ngx_http_dav_loc_conf_t, md5_header),
+      NULL },
+
+    { ngx_string("content_md5_fail_status"),
+      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_num_slot,
+      NGX_HTTP_LOC_CONF_OFFSET,
+      offsetof(ngx_http_dav_loc_conf_t, content_md5_fail_status),
+      NULL },
+
       ngx_null_command
 };
 
@@ -167,6 +195,12 @@ ngx_http_dav_handler(ngx_http_request_t *r)
         r->request_body_file_group_access = 1;
         r->request_body_file_log_level = 0;
 
+        if (dlcf->md5_header ||
+            (dlcf->content_md5_fail_status != 0 &&
+             r->headers_in.content_md5 != NULL)) {
+            r->request_body_md5 = 1;
+        }
+
         rc = ngx_http_read_client_request_body(r, ngx_http_dav_put_handler);
 
         if (rc >= NGX_HTTP_SPECIAL_RESPONSE) {
@@ -206,6 +240,10 @@ ngx_http_dav_put_handler(ngx_http_request_t *r)
     ngx_file_info_t           fi;
     ngx_ext_rename_file_t     ext;
     ngx_http_dav_loc_conf_t  *dlcf;
+    ngx_str_t                 d_computed_hash;
+    ngx_str_t                 e_computed_hash;
+    ngx_table_elt_t          *h;
+    ngx_uint_t                failed_md5 = 0;
 
     if (r->request_body == NULL || r->request_body->temp_file == NULL) {
         ngx_http_finalize_request(r, NGX_HTTP_INTERNAL_SERVER_ERROR);
@@ -264,6 +302,102 @@ ngx_http_dav_put_handler(ngx_http_request_t *r)
         }
     }
 
+    /*
+     * If we accumulated MD5 hash metadata, finish computing it here.
+     */
+    if (r->request_body_md5) {
+        d_computed_hash.data = ngx_palloc(r->pool, 16);
+        if (d_computed_hash.data == NULL) {
+            ngx_http_finalize_request(r, NGX_HTTP_INTERNAL_SERVER_ERROR);
+            return;
+        }
+
+        ngx_md5_final(d_computed_hash.data,
+                      &r->request_body->temp_file->md5ctx);
+        d_computed_hash.len = 16;
+    }
+
+    /*
+     * The Content-MD5 header's value is base64 encoded.  We need to decode it,
+     * then compare it with the computed hash value.  If they do not match, we
+     * will fail the request with the configured status code.
+     *
+     * We also handle various problems with the request header here.  This is
+     * unfortunate, since we could have checked this before actually receiving
+     * the file's contents if the client sent expect: 100-continue.  As a
+     * future optimisation, some of this checking could be moved.
+     */
+    if (r->request_body_md5 && r->headers_in.content_md5 != NULL) {
+        const ngx_str_t *e_client_hash = &r->headers_in.content_md5->value;
+        ngx_str_t d_client_hash;
+
+        if (e_client_hash->len != ngx_base64_encoded_length(16)) {
+            ngx_http_finalize_request(r, NGX_HTTP_BAD_REQUEST);
+            return;
+        }
+
+        d_client_hash.data = ngx_palloc(r->pool, 16);
+        if (d_client_hash.data == NULL) {
+            ngx_http_finalize_request(r, NGX_HTTP_INTERNAL_SERVER_ERROR);
+            return;
+        }
+
+        if (ngx_decode_base64(&d_client_hash,
+                              (ngx_str_t *)e_client_hash) != NGX_OK) {
+            ngx_http_finalize_request(r, NGX_HTTP_BAD_REQUEST);
+            return;
+        }
+
+        if (ngx_memcmp(d_client_hash.data, d_computed_hash.data, 16) != 0)
+            ++failed_md5;
+    }
+
+    /*
+     * If we failed to match the client's MD5 hash, or if we've been configured
+     * to always append the computed hash, encode the computed hash and attach
+     * it into the header chain now.
+     */
+    if (failed_md5 || dlcf->md5_header) {
+        e_computed_hash.data = ngx_palloc(r->pool,
+            ngx_base64_encoded_length(16) + 1);
+        if (e_computed_hash.data == NULL) {
+            ngx_http_finalize_request(r, NGX_HTTP_INTERNAL_SERVER_ERROR);
+            return;
+        }
+
+        h = ngx_list_push(&r->headers_out.headers);
+        if (h == NULL) {
+            ngx_http_finalize_request(r, NGX_HTTP_INTERNAL_SERVER_ERROR);
+            return;
+        }
+
+        h->hash = 1;
+        ngx_str_set(&h->key, "X-Joyent-Computed-Content-MD5");
+        ngx_encode_base64(&e_computed_hash, &d_computed_hash);
+        e_computed_hash.data[e_computed_hash.len] = '\0';
+        h->value = e_computed_hash;
+    }
+
+    if (failed_md5) {
+        ngx_http_finalize_request(r, dlcf->content_md5_fail_status);
+        return;
+    }
+
+    /*
+     * We want to do this last, so that the OS will have maximum opportunity
+     * to schedule and complete this I/O while we were doing other things.
+     */
+#if (NGX_HAVE_FSYNC)
+    if (dlcf->fsync) {
+        if (ngx_file_sync(r->request_body->temp_file->file.fd) != 0) {
+            ngx_log_error(NGX_LOG_CRIT, r->connection->log, ngx_errno,
+                ngx_file_sync_n " \"%s\"", temp->data);
+            ngx_http_finalize_request(r, NGX_HTTP_INTERNAL_SERVER_ERROR);
+            return;
+        }
+    }
+#endif
+
     if (ngx_ext_rename_file(temp, &path, &ext) != NGX_OK) {
         ngx_http_finalize_request(r, NGX_HTTP_INTERNAL_SERVER_ERROR);
         return;
@@ -1111,6 +1245,11 @@ ngx_http_dav_create_loc_conf(ngx_conf_t *cf)
     conf->min_delete_depth = NGX_CONF_UNSET_UINT;
     conf->access = NGX_CONF_UNSET_UINT;
     conf->create_full_put_path = NGX_CONF_UNSET;
+#if (NGX_HAVE_FSYNC)
+    conf->fsync = NGX_CONF_UNSET;
+#endif
+    conf->content_md5_fail_status = NGX_CONF_UNSET_UINT;
+    conf->md5_header = NGX_CONF_UNSET;
 
     return conf;
 }
@@ -1133,6 +1272,16 @@ ngx_http_dav_merge_loc_conf(ngx_conf_t *cf, void *parent, void *child)
     ngx_conf_merge_value(conf->create_full_put_path,
                          prev->create_full_put_path, 0);
 
+#if (NGX_HAVE_FSYNC)
+    ngx_conf_merge_value(conf->fsync, prev->fsync, 0);
+#endif
+
+    ngx_conf_merge_uint_value(conf->content_md5_fail_status,
+                              prev->content_md5_fail_status, 400);
+
+    ngx_conf_merge_value(conf->md5_header,
+                         prev->md5_header, 0);
+
     return NGX_CONF_OK;
 }
 
diff --git a/src/http/ngx_http_core_module.c b/src/http/ngx_http_core_module.c
index 739493d4..bd36aecc 100644
--- a/src/http/ngx_http_core_module.c
+++ b/src/http/ngx_http_core_module.c
@@ -619,13 +619,6 @@ static ngx_command_t  ngx_http_core_commands[] = {
       offsetof(ngx_http_core_loc_conf_t, chunked_transfer_encoding),
       NULL },
 
-    { ngx_string("fsync"),
-      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_FLAG,
-      ngx_conf_set_flag_slot,
-      NGX_HTTP_LOC_CONF_OFFSET,
-      offsetof(ngx_http_core_loc_conf_t, fsync),
-      NULL },
-
     { ngx_string("etag"),
       NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_FLAG,
       ngx_conf_set_flag_slot,
@@ -3653,7 +3646,6 @@ ngx_http_core_create_loc_conf(ngx_conf_t *cf)
     clcf->recursive_error_pages = NGX_CONF_UNSET;
     clcf->server_tokens = NGX_CONF_UNSET;
     clcf->chunked_transfer_encoding = NGX_CONF_UNSET;
-    clcf->fsync = NGX_CONF_UNSET;
     clcf->etag = NGX_CONF_UNSET;
     clcf->types_hash_max_size = NGX_CONF_UNSET_UINT;
     clcf->types_hash_bucket_size = NGX_CONF_UNSET_UINT;
@@ -3921,8 +3913,6 @@ ngx_http_core_merge_loc_conf(ngx_conf_t *cf, void *parent, void *child)
     ngx_conf_merge_value(conf->server_tokens, prev->server_tokens, 1);
     ngx_conf_merge_value(conf->chunked_transfer_encoding,
                               prev->chunked_transfer_encoding, 1);
-    ngx_conf_merge_value(conf->fsync,
-                              prev->fsync, 0);
     ngx_conf_merge_value(conf->etag, prev->etag, 1);
 
     ngx_conf_merge_ptr_value(conf->open_file_cache,
diff --git a/src/http/ngx_http_core_module.h b/src/http/ngx_http_core_module.h
index ebcd8373..6c446a05 100644
--- a/src/http/ngx_http_core_module.h
+++ b/src/http/ngx_http_core_module.h
@@ -418,7 +418,6 @@ struct ngx_http_core_loc_conf_s {
     ngx_flag_t    server_tokens;           /* server_tokens */
     ngx_flag_t    chunked_transfer_encoding; /* chunked_transfer_encoding */
     ngx_flag_t    etag;                    /* etag */
-    ngx_flag_t    fsync;	           /* fsync(3C) when writing files */
 
 #if (NGX_HTTP_GZIP)
     ngx_flag_t    gzip_vary;               /* gzip_vary */
diff --git a/src/http/ngx_http_request.c b/src/http/ngx_http_request.c
index c2ce2224..48967775 100644
--- a/src/http/ngx_http_request.c
+++ b/src/http/ngx_http_request.c
@@ -114,6 +114,10 @@ ngx_http_header_t  ngx_http_headers_in[] = {
                  offsetof(ngx_http_headers_in_t, content_type),
                  ngx_http_process_header_line },
 
+    { ngx_string("Content-MD5"),
+                 offsetof(ngx_http_headers_in_t, content_md5),
+                 ngx_http_process_header_line },
+
     { ngx_string("Range"), offsetof(ngx_http_headers_in_t, range),
                  ngx_http_process_header_line },
 
diff --git a/src/http/ngx_http_request.h b/src/http/ngx_http_request.h
index 57f8583d..c56a7900 100644
--- a/src/http/ngx_http_request.h
+++ b/src/http/ngx_http_request.h
@@ -184,6 +184,7 @@ typedef struct {
     ngx_table_elt_t                  *referer;
     ngx_table_elt_t                  *content_length;
     ngx_table_elt_t                  *content_type;
+    ngx_table_elt_t                  *content_md5;
 
     ngx_table_elt_t                  *range;
     ngx_table_elt_t                  *if_range;
@@ -480,6 +481,7 @@ struct ngx_http_request_s {
     unsigned                          request_body_file_group_access:1;
     unsigned                          request_body_file_log_level:3;
     unsigned                          request_body_no_buffering:1;
+    unsigned                          request_body_md5:1;
 
     unsigned                          subrequest_in_memory:1;
     unsigned                          waited:1;
diff --git a/src/http/ngx_http_request_body.c b/src/http/ngx_http_request_body.c
index 80030db0..7d0d5267 100644
--- a/src/http/ngx_http_request_body.c
+++ b/src/http/ngx_http_request_body.c
@@ -449,18 +449,22 @@ ngx_http_write_request_body(ngx_http_request_t *r)
 
         tf->file.fd = NGX_INVALID_FILE;
         tf->file.log = r->connection->log;
-        tf->file.fsync = clcf->fsync;
         tf->path = clcf->client_body_temp_path;
         tf->pool = r->pool;
         tf->warn = "a client request body is buffered to a temporary file";
         tf->log_level = r->request_body_file_log_level;
         tf->persistent = r->request_body_in_persistent_file;
         tf->clean = r->request_body_in_clean_file;
+        tf->md5 = r->request_body_md5;
 
         if (r->request_body_file_group_access) {
             tf->access = 0660;
         }
 
+        if (tf->md5) {
+            ngx_md5_init(&tf->md5ctx);
+        }
+
         rb->temp_file = tf;
 
         if (rb->bufs == NULL) {
diff --git a/src/http/ngx_http_variables.c b/src/http/ngx_http_variables.c
index f8271ab6..7094ee59 100644
--- a/src/http/ngx_http_variables.c
+++ b/src/http/ngx_http_variables.c
@@ -180,6 +180,9 @@ static ngx_http_variable_t  ngx_http_core_variables[] = {
     { ngx_string("content_type"), NULL, ngx_http_variable_header,
       offsetof(ngx_http_request_t, headers_in.content_type), 0, 0 },
 
+    { ngx_string("content_md5"), NULL, ngx_http_variable_header,
+      offsetof(ngx_http_request_t, headers_in.content_md5), 0, 0 },
+
     { ngx_string("host"), NULL, ngx_http_variable_host, 0, 0, 0 },
 
     { ngx_string("binary_remote_addr"), NULL,
diff --git a/src/os/unix/ngx_files.c b/src/os/unix/ngx_files.c
index cbe04d60..113a8326 100644
--- a/src/os/unix/ngx_files.c
+++ b/src/os/unix/ngx_files.c
@@ -223,7 +223,7 @@ ngx_write_file(ngx_file_t *file, u_char *buf, size_t size, off_t offset)
         written += n;
 
         if ((size_t) n == size) {
-	    break;
+            return written;
         }
 
         offset += n;
@@ -264,23 +264,13 @@ ngx_write_file(ngx_file_t *file, u_char *buf, size_t size, off_t offset)
         written += n;
 
         if ((size_t) n == size) {
-            break;
+            return written;
         }
 
         size -= n;
     }
 #endif
 
-#ifdef NGX_HAVE_FSYNC
-    if (file->fsync) {
-         if (fsync(file->fd) != 0) {
-              ngx_log_error(NGX_LOG_CRIT, file->log, ngx_errno,
-                          "fsync() \"%s\" failed", file->name.data);
-              return NGX_ERROR;
-         }
-    }
-#endif
-
     return written;
 }
 
diff --git a/src/os/unix/ngx_files.h b/src/os/unix/ngx_files.h
index 07872b13..2863d07b 100644
--- a/src/os/unix/ngx_files.h
+++ b/src/os/unix/ngx_files.h
@@ -373,6 +373,14 @@ size_t ngx_fs_bsize(u_char *name);
 #define ngx_set_stderr(fd)       dup2(fd, STDERR_FILENO)
 #define ngx_set_stderr_n         "dup2(STDERR_FILENO)"
 
+#if (NGX_HAVE_FSYNC)
+
+#define ngx_file_sync(fd)                                                    \
+    fsync(fd)
+
+#define ngx_file_sync_n          "fsync()"
+
+#endif
 
 #if (NGX_HAVE_FILE_AIO)
 
-- 
2.21.0

