commit e397aa7d89d0f5302e22e182e547441c07d906c3 (refs/changes/52/1552/9)
Author: Pedro Palazon Candel <pedro@joyent.com>
Date:   2017-08-15T12:07:31+02:00 (2 years, 2 months ago)
    
    TOOLS-1699 sdcadm health -j should always provide JSON even on exceptions

diff --git a/lib/channel.js b/lib/channel.js
index 23031ab..004d1de 100644
--- a/lib/channel.js
+++ b/lib/channel.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2015, Joyent, Inc.
+ * Copyright 2017 Joyent, Inc.
  */
 
 /*
@@ -18,7 +18,7 @@
 
 var util = require('util');
 var tabula = require('tabula');
-
+var vasync = require('vasync');
 var cmdln = require('cmdln');
 var Cmdln = cmdln.Cmdln;
 
@@ -59,63 +59,76 @@ function do_list(subcmd, opts, args, cb) {
     }
 
     var progress = self.progress;
-    var app = self.sdcadm.sdc;
+    var app;
 
-    self.sdcadm.updates.listChannels({}, function (err, channels) {
-        if (err) {
-            progress('Error trying to retrieve update channels');
-            var e = new errors.SDCClientError(err, 'imgapi');
-            return cb(e);
-        }
+    vasync.pipeline({arg: {}, funcs: [
+        function ensureSdcApp(_, next) {
+            self.sdcadm.ensureSdcApp(next);
+        },
+        function getChannels(ctx, next) {
+            app = self.sdcadm.sdcApp;
+            self.sdcadm.updates.listChannels({}, function (err, channels) {
+                if (err) {
+                    progress('Error trying to retrieve update channels');
+                    var e = new errors.SDCClientError(err, 'imgapi');
+                    next(e);
+                    return;
+                }
 
-        if (app.metadata.update_channel) {
-            channels = channels.map(function (c) {
-                if (c.name === app.metadata.update_channel) {
-                    c['default'] = true;
+                if (app.metadata.update_channel) {
+                    ctx.channels = channels.map(function (c) {
+                        if (c.name === app.metadata.update_channel) {
+                            c['default'] = true;
+                        } else {
+                            delete c['default'];
+                        }
+                        return c;
+                    });
                 } else {
-                    delete c['default'];
+                    ctx.channels = channels.map(function (c) {
+                        if (c['default']) {
+                            c.remote = true;
+                        }
+                        return c;
+                    });
                 }
-                return c;
+
+                next();
             });
-        } else {
-            channels = channels.map(function (c) {
-                if (c['default']) {
-                    c.remote = true;
+        },
+        function printChannels(ctx, next) {
+            if (opts.json) {
+                console.log(JSON.stringify(ctx.channels, null, 4));
+                next();
+                return;
+            }
+
+            ctx.channels = ctx.channels.map(function (c) {
+                if (c['default'] && c.remote) {
+                    delete c.remote;
+                    c['default'] = 'true (remote)';
                 }
                 return c;
             });
-        }
-
-        if (opts.json) {
-            console.log(JSON.stringify(channels, null, 4));
-            return cb();
-        }
-
-        channels = channels.map(function (c) {
-            if (c['default'] && c.remote) {
-                delete c.remote;
-                c['default'] = 'true (remote)';
-            }
-            return c;
-        });
 
 
-        var validFieldsMap = {};
-        channels.forEach(function (v) {
-            var k;
-            for (k in v) {
-                validFieldsMap[k] = true;
-            }
-        });
-
-        tabula(channels, {
-            skipHeader: opts.H,
-            columns: ['name', 'default', 'description'],
-            validFields: Object.keys(validFieldsMap)
-        });
-
-        return cb();
+            var validFieldsMap = {};
+            ctx.channels.forEach(function (v) {
+                var k;
+                for (k in v) {
+                    validFieldsMap[k] = true;
+                }
+            });
 
+            tabula(ctx.channels, {
+                skipHeader: opts.H,
+                columns: ['name', 'default', 'description'],
+                validFields: Object.keys(validFieldsMap)
+            });
+            next();
+        }
+    ]}, function pipeCb(pipeErr) {
+        cb(pipeErr);
     });
 };
 
@@ -162,36 +175,52 @@ function do_set(subcmd, opts, args, cb) {
 
     var channel = args.shift();
     var progress = self.progress;
-    var app = self.sdcadm.sdc;
-
-    self.sdcadm.updates.listChannels({}, function (err, channels) {
-        if (err) {
-            progress('Error trying to retrieve update channels');
-            var e = new errors.SDCClientError(err, 'imgapi');
-            return cb(e);
-        }
 
-        var names = channels.map(function (c) {
-            return (c.name);
-        });
-
-        if (names.indexOf(channel) === -1) {
-            progress('Must specify a valid channel: %j', channels);
-            return cb(new errors.UsageError('Invalid channel name'));
-        }
+    vasync.pipeline({arg: {}, funcs: [
+        function ensureSdcApp(_, next) {
+            self.sdcadm.ensureSdcApp(next);
+        },
+        function getChannels(ctx, next) {
+            self.sdcadm.updates.listChannels({}, function (err, channels) {
+                if (err) {
+                    progress('Error trying to retrieve update channels');
+                    var e = new errors.SDCClientError(err, 'imgapi');
+                    next(e);
+                    return;
+                }
+                ctx.channels = channels;
+                next();
+            });
+        },
+        function validateChannel(ctx, next) {
+            var names = ctx.channels.map(function (c) {
+                return (c.name);
+            });
 
-        self.sdcadm.sapi.updateApplication(app.uuid, {
-            metadata: {
-                update_channel: channel
-            }
-        }, function (updateErr, svc) {
-            if (updateErr) {
-                return cb(new errors.SDCClientError(updateErr, 'sapi'));
+            if (names.indexOf(channel) === -1) {
+                progress('Must specify a valid channel: %j', ctx.channels);
+                next(new errors.UsageError('Invalid channel name'));
+                return;
             }
-            progress('Update channel has been successfully set to: \'%s\'',
-                    channel);
-            return cb();
-        });
+            next();
+        },
+        function setChannel(ctx, next) {
+            self.sdcadm.sapi.updateApplication(self.sdcadm.sdcApp.uuid, {
+                metadata: {
+                    update_channel: channel
+                }
+            }, function (updateErr, svc) {
+                if (updateErr) {
+                    next(new errors.SDCClientError(updateErr, 'sapi'));
+                    return;
+                }
+                progress('Update channel has been successfully set to: \'%s\'',
+                        channel);
+                next();
+            });
+        }
+    ]}, function pipeCb(pipeErr) {
+        cb(pipeErr);
     });
 };
 
@@ -222,19 +251,28 @@ function do_unset(subcmd, opts, args, cb) {
     }
 
     var progress = self.progress;
-    var app = self.sdcadm.sdc;
 
-    self.sdcadm.sapi.updateApplication(app.uuid, {
-        metadata: {
-            update_channel: app.metadata.update_channel
+    vasync.pipeline({arg: {}, funcs: [
+        function ensureSdcApp(_, next) {
+            self.sdcadm.ensureSdcApp(next);
         },
-        action: 'delete'
-    }, function (err, svc) {
-        if (err) {
-            return cb(new errors.SDCClientError(err, 'sapi'));
+        function unsetChannel(_, next) {
+            self.sdcadm.sapi.updateApplication(self.sdcadm.sdcApp.uuid, {
+                metadata: {
+                    update_channel: self.sdcadm.sdcApp.metadata.update_channel
+                },
+                action: 'delete'
+            }, function (err, svc) {
+                if (err) {
+                    next(new errors.SDCClientError(err, 'sapi'));
+                    return;
+                }
+                progress('Update channel has been successfully unset');
+                next();
+            });
         }
-        progress('Update channel has been successfully unset');
-        return cb();
+    ]}, function pipeCb(pipeErr) {
+        cb(pipeErr);
     });
 };
 
diff --git a/lib/cli/do_avail.js b/lib/cli/do_avail.js
index cf6a528..c3f93f2 100644
--- a/lib/cli/do_avail.js
+++ b/lib/cli/do_avail.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2015, Joyent, Inc.
+ * Copyright 2017 Joyent, Inc.
  */
 
 /*
@@ -55,16 +55,23 @@ Available.prototype.execute = function cExecute(opts, args, cb) {
     var changes;
     var plan;
 
-    // Set or override the default channel if anything is given:
-    if (opts.channel) {
-        self.sdcadm.updates.channel = opts.channel;
-    }
+
 
     // override to true list portolan/rabbit
     opts.force_data_path = true;
     opts.force_rabbitmq = true;
 
     vasync.pipeline({funcs: [
+        function ensureSdcApp(_, next) {
+            self.sdcadm.ensureSdcApp(next);
+        },
+        function setChannel(_, next) {
+            // Set or override the default channel if anything is given:
+            if (opts.channel) {
+                self.sdcadm.updates.channel = opts.channel;
+            }
+            next();
+        },
         function getChangesFromArgs(_, next) {
             self.cli._specFromArgs(opts, args, function (err, chgs) {
                 if (err) {
diff --git a/lib/cli/do_check_health.js b/lib/cli/do_check_health.js
index ccc790c..4e6aca2 100644
--- a/lib/cli/do_check_health.js
+++ b/lib/cli/do_check_health.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2016, Joyent, Inc.
+ * Copyright 2017 Joyent, Inc.
  */
 
 var tabula = require('tabula');
@@ -42,6 +42,10 @@ function do_check_health(subcmd, opts, args, callback) {
         healthOpts.servers = opts.servers;
     }
 
+    if (opts.json) {
+        healthOpts.json = opts.json;
+    }
+
     if (args.length) {
         args = args.filter(function (arg) {
             if (arg.indexOf('=') !== -1) {
@@ -116,7 +120,21 @@ function do_check_health(subcmd, opts, args, callback) {
 
     function displayResults(err, statuses) {
         if (err) {
-            return callback(new errors.InternalError(err));
+            if (opts.json) {
+                console.log(JSON.stringify({
+                    type: 'triton',
+                    hostname: 'headnode',
+                    healthy: false,
+                    health_errors: [ {
+                        message: 'Triton is experiencing severe errors ' +
+                            'that prevent detailed health checks'
+                    }, {
+                        message: err.message
+                    } ]
+                }));
+            }
+            callback(new errors.InternalError(err));
+            return;
         }
 
         var rows = statuses.map(function (status) {
diff --git a/lib/cli/do_instances.js b/lib/cli/do_instances.js
index 27ae7bc..7518197 100644
--- a/lib/cli/do_instances.js
+++ b/lib/cli/do_instances.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2015, Joyent, Inc.
+ * Copyright 2017 Joyent, Inc.
  */
 
 var tabula = require('tabula');
@@ -25,7 +25,9 @@ function do_instances(subcmd, opts, args, callback) {
     }
 
     var validTypes = ['vm', 'agent'];
-    var listOpts = {};
+    var listOpts = {
+        json: opts.json || false
+    };
     for (var i = 0; i < args.length; i++) {
         var arg = args[i];
         var k = 'svc';
diff --git a/lib/cli/do_services.js b/lib/cli/do_services.js
index 00c4ce0..c655c79 100644
--- a/lib/cli/do_services.js
+++ b/lib/cli/do_services.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2015, Joyent, Inc.
+ * Copyright 2017 Joyent, Inc.
  */
 
 var tabula = require('tabula');
@@ -36,14 +36,16 @@ function do_services(subcmd, opts, args, callback) {
         if (!needInsts) {
             return next();
         }
-        self.sdcadm.listInsts(next);
+        self.sdcadm.listInsts({ json: opts.json || false }, next);
     }
 
     getInstsIfNecessary(function (iErr, insts) {
         if (iErr) {
             return callback(iErr);
         }
-        self.sdcadm.getServices({}, function (err, svcs) {
+        self.sdcadm.getServices({
+            json: opts.json || false
+        }, function (err, svcs) {
             if (err) {
                 return callback(err);
             }
diff --git a/lib/cli/do_update_gz_tools.js b/lib/cli/do_update_gz_tools.js
index 1377d5a..a8804be 100644
--- a/lib/cli/do_update_gz_tools.js
+++ b/lib/cli/do_update_gz_tools.js
@@ -5,10 +5,11 @@
  */
 
 /*
- * Copyright 2016 Joyent, Inc.
+ * Copyright 2017 Joyent, Inc.
  */
 
 var assert = require('assert-plus');
+var vasync = require('vasync');
 
 var errors = require('../errors');
 
@@ -48,19 +49,24 @@ function do_update_gz_tools(subcmd, opts, args, cb) {
             'must specify installer image UUID or --latest'));
     }
 
-    // Set or override the default channel if anything is given:
-    if (opts.channel) {
-        self.sdcadm.updates.channel = opts.channel;
-    }
-
-    self.sdcadm.updateGzTools({
-        image: opts.latest ? 'latest' : args[0],
-        progress: progress,
-        justDownload: opts.just_download,
-        forceReinstall: opts.force_reinstall,
-        concurrency: opts.concurrency
-    }, finish);
-
+    vasync.pipeline({funcs: [
+        function ensureSdcApp(_, next) {
+            self.sdcadm.ensureSdcApp(next);
+        },
+        function updateGzTools(_, next) {
+            // Set or override the default channel if anything is given:
+            if (opts.channel) {
+                self.sdcadm.updates.channel = opts.channel;
+            }
+            self.sdcadm.updateGzTools({
+                image: opts.latest ? 'latest' : args[0],
+                progress: progress,
+                justDownload: opts.just_download,
+                forceReinstall: opts.force_reinstall,
+                concurrency: opts.concurrency
+            }, next);
+        }
+    ]}, finish);
 }
 do_update_gz_tools.options = [
     {
diff --git a/lib/cli/do_update_other.js b/lib/cli/do_update_other.js
index d8f55b7..1637708 100644
--- a/lib/cli/do_update_other.js
+++ b/lib/cli/do_update_other.js
@@ -67,7 +67,7 @@ function do_update_other(subcmd, opts, args, cb) {
     }
 
     function updateSdcApp(svcOpts, next) {
-        var uuid = self.sdcadm.sdc.uuid;
+        var uuid = self.sdcadm.sdcApp.uuid;
         self.sdcadm.sapi.updateApplication(uuid, svcOpts, function (err, svc) {
             if (err) {
                 return next(new errors.SDCClientError(err, 'sapi'));
@@ -122,6 +122,9 @@ function do_update_other(subcmd, opts, args, cb) {
         progress: self.progress
     };
     vasync.pipeline({arg: context, funcs: [
+        function ensureSdcApp(_, next) {
+            self.sdcadm.ensureSdcApp(next);
+        },
         /*
          * Time to finally make the switch to the new agents by default.
          */
@@ -171,11 +174,11 @@ function do_update_other(subcmd, opts, args, cb) {
 
         // Remove deprecated params.resolvers:
         function removeSdcAppResolvers(ctx, next) {
-            if (!self.sdcadm.sdc.params.resolvers) {
+            if (!self.sdcadm.sdcApp.params.resolvers) {
                 return next();
             }
             progress('Remove deprecated "sdc" SAPI app params resolvers');
-            self.sdcadm.sapi.updateApplication(self.sdcadm.sdc.uuid, {
+            self.sdcadm.sapi.updateApplication(self.sdcadm.sdcApp.uuid, {
                 action: 'delete',
                 params: {
                     resolvers: []
@@ -191,7 +194,7 @@ function do_update_other(subcmd, opts, args, cb) {
         },
 
         function updateSdcAppSchemas(ctx, next) {
-            var currSchema = self.sdcadm.sdc.metadata_schema;
+            var currSchema = self.sdcadm.sdcApp.metadata_schema;
             var latestSchema = schemas.sdc.sdc_app;
             if (currSchema && jsprim.deepEqual(currSchema, latestSchema)) {
                 return next();
@@ -200,7 +203,7 @@ function do_update_other(subcmd, opts, args, cb) {
             self.log.debug({before: currSchema, after: latestSchema},
                 'update sdc app metadata_schema');
             progress('Update "sdc" SAPI app metadata_schema');
-            self.sdcadm.sapi.updateApplication(self.sdcadm.sdc.uuid, {
+            self.sdcadm.sapi.updateApplication(self.sdcadm.sdcApp.uuid, {
                 action: 'update',
                 metadata_schema: latestSchema
             }, function (err, app) {
@@ -245,7 +248,7 @@ function do_update_other(subcmd, opts, args, cb) {
             vasync.forEachParallel({
                 inputs: svcsToUpdate,
                 func: function updateSvc(svc, nextSvc) {
-                    var mdata = self.sdcadm.sdc.metadata;
+                    var mdata = self.sdcadm.sdcApp.metadata;
                     var svcDomain = format('%s.%s.%s', svc.name,
                         mdata.datacenter_name, mdata.dns_domain);
                     progress('Set "%s" service "metadata.SERVICE_DOMAIN"',
@@ -263,7 +266,7 @@ function do_update_other(subcmd, opts, args, cb) {
         },
 
         function updateAppDomains(ctx, next) {
-            var mdata = self.sdcadm.sdc.metadata;
+            var mdata = self.sdcadm.sdcApp.metadata;
             var mdataUpdates = {};
 
             NEW_SERVICES.forEach(function (svcName) {
@@ -591,7 +594,7 @@ function do_update_other(subcmd, opts, args, cb) {
                 }
 
                 progress('Appending "sapi_domain" to node.config');
-                var mdata = self.sdcadm.sdc.metadata;
+                var mdata = self.sdcadm.sdcApp.metadata;
                 var sapiDomain = format('sapi_domain=\'sapi.%s.%s\'\n',
                     mdata.datacenter_name, mdata.dns_domain);
                 fs.appendFile(nodeConfig, sapiDomain, next);
diff --git a/lib/cli/index.js b/lib/cli/index.js
index e3a5b5a..598cca3 100644
--- a/lib/cli/index.js
+++ b/lib/cli/index.js
@@ -182,7 +182,6 @@ CLI.prototype.init = function init(opts, args, callback) {
             callback();
             return;
         }
-
         self.sdcadm = new SdcAdm({
             log: self.log,
             uuid: self.uuid
diff --git a/lib/dc-maint.js b/lib/dc-maint.js
index 28125c2..c04e071 100644
--- a/lib/dc-maint.js
+++ b/lib/dc-maint.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright 2016, Joyent, Inc.
+ * Copyright 2017 Joyent, Inc.
  */
 
 /*
diff --git a/lib/default-fabric.js b/lib/default-fabric.js
index 97027e0..a0cc203 100644
--- a/lib/default-fabric.js
+++ b/lib/default-fabric.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2015, Joyent, Inc.
+ * Copyright 2017 Joyent, Inc.
  */
 
 /*
@@ -63,7 +63,7 @@ function defFabricAddNetwork(opts, cb) {
        provision_start_ip: '192.168.128.5',
        provision_end_ip: '192.168.131.250',
        gateway: '192.168.128.1',
-       resolvers: opts.sdcadm.sdc.metadata.dns_resolvers.split(','),
+       resolvers: opts.sdcadm.sdcApp.metadata.dns_resolvers.split(','),
        vlan_id: 2
     };
 
diff --git a/lib/platform.js b/lib/platform.js
index dbbb9a4..2a21072 100644
--- a/lib/platform.js
+++ b/lib/platform.js
@@ -346,38 +346,55 @@ Platform.prototype.available = function available(opts, cb) {
     assert.optionalString(opts.channel, 'opts.channel');
 
     var self = this;
-
-    // Set or override the default channel if anything is given:
-    if (opts.channel) {
-        self.sdcadm.updates.channel = opts.channel;
-    }
-
-    self.getLatestPlatformInstalled(function (err2, latest) {
-        if (err2) {
-            return cb(err2);
-        }
-        var filter = {
-            name: 'platform'
-        };
-        self.sdcadm.updates.listImages(filter, function (err, images) {
-            if (err) {
-                return cb(new errors.SDCClientError(err, 'updates'));
-            }
-            if (Array.isArray(images) && !images.length) {
-                return cb(new errors.UpdateError('no images found'));
+    var imgs;
+    vasync.pipeline({arg: {}, funcs: [
+        function ensureSdcApp(_, next) {
+            self.sdcadm.ensureSdcApp(next);
+        },
+        function getLatestInstalled(ctx, next) {
+            // Set or override the default channel if anything is given:
+            if (opts.channel) {
+                self.sdcadm.updates.channel = opts.channel;
             }
-            common.sortArrayOfObjects(images, ['published_at']);
-            images = images.map(function (img) {
-                return ({
-                    version: img.version.split('-').pop(),
-                    uuid: img.uuid,
-                    published_at: img.published_at
+            self.getLatestPlatformInstalled(function (err2, latest) {
+                if (err2) {
+                    next(err2);
+                    return;
+                }
+                ctx.latest = latest;
+                next();
+            });
+        },
+        function getAvailableImages(ctx, next) {
+            var filter = {
+                name: 'platform'
+            };
+            self.sdcadm.updates.listImages(filter, function (err, images) {
+                if (err) {
+                    next(new errors.SDCClientError(err, 'updates'));
+                    return;
+                }
+                if (Array.isArray(images) && !images.length) {
+                    next(new errors.UpdateError('no images found'));
+                    return;
+                }
+                common.sortArrayOfObjects(images, ['published_at']);
+                images = images.map(function (img) {
+                    return ({
+                        version: img.version.split('-').pop(),
+                        uuid: img.uuid,
+                        published_at: img.published_at
+                    });
+                }).filter(function (i) {
+                    return (i.version > ctx.latest);
                 });
-            }).filter(function (i) {
-                return (i.version > latest);
+                imgs = images;
+                next(null);
             });
-            return cb(null, images);
-        });
+
+        }
+    ]}, function pipeCb(pipeErr) {
+        cb(pipeErr, imgs);
     });
 };
 
@@ -443,11 +460,6 @@ Platform.prototype.install = function install(opts, callback) {
     // image in order to avoid same thing than for TOOLS-876
     var imgNotFoundError = false;
 
-    // Set or override the default channel if anything is given:
-    if (opts.channel) {
-        self.sdcadm.updates.channel = opts.channel;
-    }
-
     function findPlatformImageLatest(cb) {
         var filter = {
             name: 'platform'
@@ -583,7 +595,14 @@ Platform.prototype.install = function install(opts, callback) {
     }
 
     vasync.pipeline({funcs: [
+        function ensureSdcApp(_, next) {
+            self.sdcadm.ensureSdcApp(next);
+        },
         function getChannel(_, next) {
+            // Set or override the default channel if anything is given:
+            if (opts.channel) {
+                self.sdcadm.updates.channel = opts.channel;
+            }
             self.sdcadm.getDefaultChannel(function (err, channel) {
                 // Will not fail the whole operation due to channel not found
                 if (err) {
diff --git a/lib/post-setup/cmon.js b/lib/post-setup/cmon.js
index 830770e..5e44c62 100644
--- a/lib/post-setup/cmon.js
+++ b/lib/post-setup/cmon.js
@@ -83,6 +83,10 @@ function do_cmon(subcmd, opts, args, cb) {
     vasync.pipeline({arg: context, funcs: [
         steps.sapiAssertFullMode,
 
+        function ensureSdcApp(_, next) {
+            self.sdcadm.ensureSdcApp(next);
+        },
+
         function ensureCnsSvc(ctx, next) {
             self.sdcadm.sapi.listServices({
                 name: 'cns',
@@ -122,7 +126,7 @@ function do_cmon(subcmd, opts, args, cb) {
         function getSvc(ctx, next) {
             self.sdcadm.sapi.listServices({
                 name: 'cmon',
-                application_uuid: self.sdcadm.sdc.uuid
+                application_uuid: self.sdcadm.sdcApp.uuid
             }, function (svcErr, svcs) {
                 if (svcErr) {
                     return next(svcErr);
@@ -255,8 +259,8 @@ function do_cmon(subcmd, opts, args, cb) {
                 return;
             }
 
-            var domain = self.sdcadm.sdc.metadata.datacenter_name + '.' +
-                    self.sdcadm.sdc.metadata.dns_domain;
+            var domain = self.sdcadm.sdcApp.metadata.datacenter_name + '.' +
+                    self.sdcadm.sdcApp.metadata.dns_domain;
             var svcDomain = svcData.name + '.' + domain;
 
             self.progress('Creating "cmon" service');
@@ -267,7 +271,7 @@ function do_cmon(subcmd, opts, args, cb) {
             svcData.params.billing_id = ctx.cmonPkg.uuid;
             delete svcData.params.package_name;
 
-            self.sdcadm.sapi.createService('cmon', self.sdcadm.sdc.uuid,
+            self.sdcadm.sapi.createService('cmon', self.sdcadm.sdcApp.uuid,
                     svcData, function (err, svc) {
                 if (err) {
                     return next(new errors.SDCClientError(err, 'sapi'));
@@ -330,7 +334,7 @@ function do_cmon(subcmd, opts, args, cb) {
                 }
                 self.progress('Creating "cmon-agent" service');
                 self.sdcadm.sapi.createService('cmon-agent',
-                        self.sdcadm.sdc.uuid, {
+                        self.sdcadm.sdcApp.uuid, {
                     params: {
                         image_uuid: ctx.cmonAgentImg.uuid,
                         tags: {
diff --git a/lib/post-setup/cns.js b/lib/post-setup/cns.js
index 6fb1517..19ded33 100644
--- a/lib/post-setup/cns.js
+++ b/lib/post-setup/cns.js
@@ -72,6 +72,9 @@ function do_cns(subcmd, opts, args, cb) {
     vasync.pipeline({arg: context, funcs: [
         steps.sapiAssertFullMode,
 
+        function ensureSdcApp(_, next) {
+            self.sdcadm.ensureSdcApp(next);
+        },
         /* @field ctx.cnsPkg */
         function getPkg(ctx, next) {
             var filter = {name: svcData.params.package_name,
@@ -93,7 +96,7 @@ function do_cns(subcmd, opts, args, cb) {
         function getSvc(ctx, next) {
             self.sdcadm.sapi.listServices({
                 name: 'cns',
-                application_uuid: self.sdcadm.sdc.uuid
+                application_uuid: self.sdcadm.sdcApp.uuid
             }, function (svcErr, svcs) {
                 if (svcErr) {
                     return next(svcErr);
@@ -182,8 +185,8 @@ function do_cns(subcmd, opts, args, cb) {
                 return next();
             }
 
-            var domain = self.sdcadm.sdc.metadata.datacenter_name + '.' +
-                    self.sdcadm.sdc.metadata.dns_domain;
+            var domain = self.sdcadm.sdcApp.metadata.datacenter_name + '.' +
+                    self.sdcadm.sdcApp.metadata.dns_domain;
             var svcDomain = svcData.name + '.' + domain;
 
             self.progress('Creating "cns" service');
@@ -194,7 +197,7 @@ function do_cns(subcmd, opts, args, cb) {
             svcData.params.billing_id = ctx.cnsPkg.uuid;
             delete svcData.params.package_name;
 
-            self.sdcadm.sapi.createService('cns', self.sdcadm.sdc.uuid,
+            self.sdcadm.sapi.createService('cns', self.sdcadm.sdcApp.uuid,
                     svcData, function (err, svc) {
                 if (err) {
                     return next(new errors.SDCClientError(err, 'sapi'));
diff --git a/lib/post-setup/dev-sample-data.js b/lib/post-setup/dev-sample-data.js
index aeda52b..37088ef 100644
--- a/lib/post-setup/dev-sample-data.js
+++ b/lib/post-setup/dev-sample-data.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2015, Joyent, Inc.
+ * Copyright 2017 Joyent, Inc.
  */
 
 /*
@@ -25,23 +25,6 @@ var errors = require('../errors');
 
 //---- internal support stuff
 
-function addDevSampleData(opts, cb) {
-    assert.object(opts, 'opts');
-    assert.object(opts.sdcadm, 'opts.sdcadm');
-    assert.object(opts.log, 'opts.log');
-    assert.func(opts.progress, 'opts.progress');
-    assert.func(cb, 'cb');
-
-    vasync.parallel({funcs: [
-        function pkgs(next) {
-            addDevSamplePkgs(opts, next);
-        },
-        function imgs(next) {
-            addDevSampleImgs(opts, next);
-        }
-    ]}, cb);
-}
-
 function addDevSamplePkgs(opts, cb) {
     var papi = opts.sdcadm.papi;
 
@@ -140,6 +123,30 @@ function addDevSampleImgs(opts, cb) {
 }
 
 
+function addDevSampleData(opts, cb) {
+    assert.object(opts, 'opts');
+    assert.object(opts.sdcadm, 'opts.sdcadm');
+    assert.object(opts.log, 'opts.log');
+    assert.func(opts.progress, 'opts.progress');
+    assert.func(cb, 'cb');
+
+    vasync.pipeline({funcs: [
+        function ensureSdcApp(_, nextFun) {
+            opts.sdcadm.ensureSdcApp(nextFun);
+        },
+        function addSampleData(_, nextFun) {
+            vasync.parallel({funcs: [
+                function pkgs(next) {
+                    addDevSamplePkgs(opts, next);
+                },
+                function imgs(next) {
+                    addDevSampleImgs(opts, next);
+                }
+            ]}, nextFun);
+        }
+    ]}, cb);
+}
+
 //---- CLI
 
 function do_dev_sample_data(subcmd, opts, args, cb) {
diff --git a/lib/post-setup/docker.js b/lib/post-setup/docker.js
index 4ca5c33..95c4d71 100644
--- a/lib/post-setup/docker.js
+++ b/lib/post-setup/docker.js
@@ -80,6 +80,9 @@ function do_docker(subcmd, opts, args, cb) {
     vasync.pipeline({arg: context, funcs: [
         steps.sapiAssertFullMode,
 
+        function ensureSdcApp(_, next) {
+            self.sdcadm.ensureSdcApp(next);
+        },
         /* @field ctx.dockerPkg */
         function getDockerPkg(ctx, next) {
             var filter = {name: dockerSvcData.params.package_name,
@@ -99,7 +102,7 @@ function do_docker(subcmd, opts, args, cb) {
         },
 
         function getSdcApp(ctx, next) {
-            ctx.app = self.sdcadm.sdc;
+            ctx.app = self.sdcadm.sdcApp;
             ctx.sdcadm = self.sdcadm;
             ctx.log = self.log;
             ctx.progress = self.progress;
@@ -410,7 +413,7 @@ function do_docker(subcmd, opts, args, cb) {
                 }
                 self.progress('Creating "dockerlogger" servivce');
                 self.sdcadm.sapi.createService('dockerlogger',
-                        self.sdcadm.sdc.uuid, {
+                        self.sdcadm.sdcApp.uuid, {
                     params: {
                         image_uuid: ctx.dockerloggerImg.uuid
                     },
diff --git a/lib/post-setup/fabrics.js b/lib/post-setup/fabrics.js
index 9c58721..5c0a098 100644
--- a/lib/post-setup/fabrics.js
+++ b/lib/post-setup/fabrics.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2015, Joyent, Inc.
+ * Copyright 2017 Joyent, Inc.
  */
 
 /*
@@ -198,14 +198,18 @@ Fabrics.prototype.setupPortolan = function setupPortolan(cb) {
         }
     };
 
-    var app = self.sdcadm.sdc;
+    var app;
     var headnode = self.headnode;
 
     var img, haveImg, svc, svcExists, instExists;
 
     vasync.pipeline({arg: {}, funcs: [
+        function ensureSdcApp(_, next) {
+            self.sdcadm.ensureSdcApp(next);
+        },
         /* @field ctx.package */
         function getPackage(ctx, next) {
+            app = self.sdcadm.sdcApp;
             var filter = {name: 'sdc_768', active: true};
             self.sdcadm.papi.list(filter, {}, function (err, pkgs) {
                 if (err) {
@@ -391,12 +395,13 @@ Fabrics.prototype.setupNat = function setupNat(cb) {
     };
 
 
-    vasync.pipeline({arg: {
-        app: self.sdcadm.sdc
-    }, funcs: [
-
+    vasync.pipeline({arg: {}, funcs: [
+        function ensureSdcApp(_, next) {
+            self.sdcadm.ensureSdcApp(next);
+        },
         /* @field ctx.natPkg */
         function getNatPkg(ctx, next) {
+            ctx.app = self.sdcadm.sdcApp;
             var filter = {name: natSvcData.params.package_name, active: true};
             self.sdcadm.papi.list(filter, {}, function (err, pkgs) {
                 if (err) {
@@ -506,29 +511,39 @@ Fabrics.prototype.initDiffSchema = function initDiffSchema(cb) {
     var self = this;
     var schema = schemas.sdc.sdc_app;
     var fab, mdata;
-    var app = self.sdcadm.sdc;
-
-    if ('metadata_schemas' in app &&
-        'properties' in app.metadata_schemas &&
-        'fabric_cfg' in app.metadata_schemas.properties) {
-        mdata = app.metadata_schemas;
-        fab = mdata.properties.fabric_cfg;
-        if (jsprim.deepEqual(fab, schema.properties.fabric_cfg)) {
-            self.alreadySetup = true;
-            return cb(null);
+
+    self.sdcadm.ensureSdcApp(function (appErr) {
+        if (appErr) {
+            cb(appErr);
+            return;
         }
-    }
 
-    self.sdcadm.sapi.updateApplication(app.uuid, {
-        action: 'update',
-        metadata_schema: schema
-    }, function (err, sdcApp) {
-        if (err) {
-            return cb(new errors.SDCClientError(err, 'sapi'));
+        var app = self.sdcadm.sdcApp;
+
+        if ('metadata_schemas' in app &&
+            'properties' in app.metadata_schemas &&
+            'fabric_cfg' in app.metadata_schemas.properties) {
+            mdata = app.metadata_schemas;
+            fab = mdata.properties.fabric_cfg;
+            if (jsprim.deepEqual(fab, schema.properties.fabric_cfg)) {
+                self.alreadySetup = true;
+                return cb(null);
+            }
         }
-        self.sdcadm.sdc = sdcApp;
-        return cb(null);
+
+        self.sdcadm.sapi.updateApplication(app.uuid, {
+            action: 'update',
+            metadata_schema: schema
+        }, function (err, sdcApp) {
+            if (err) {
+                return cb(new errors.SDCClientError(err, 'sapi'));
+            }
+            self.sdcadm.sdcApp = sdcApp;
+            return cb(null);
+        });
     });
+
+
 };
 
 
@@ -667,32 +682,45 @@ Fabrics.prototype.checkNatPool = function checkNatPool(cb) {
 Fabrics.prototype.updateSapi = function updateSapi(cb) {
     var self = this;
 
-    if (self.sdcadm.sdc.metadata.fabric_cfg && !self.options.reconfigure) {
-        self.progress('Fabric configuration already in SAPI');
-        self.progress('Please, use \'--reconfigure\' if you want to override');
-        return cb(null);
-    }
+    self.sdcadm.ensureSdcApp(function (err) {
+        if (err) {
+            cb(err);
+            return;
+        }
 
-    if (self.sdcadm.sdc.metadata.fabric_cfg &&
-            jsprim.deepEqual(self.sdcadm.sdc.metadata.fabric_cfg, self.data)) {
-        self.progress('Exactly the same fabric configuration already in SAPI');
-        return cb(null);
-    }
-    self.configChanged = true;
+        if (self.sdcadm.sdcApp.metadata.fabric_cfg &&
+            !self.options.reconfigure) {
+            self.progress('Fabric configuration already in SAPI');
+            self.progress('Please, use \'--reconfigure\' ' +
+                'if you want to override');
+            return cb(null);
+        }
 
-    var word = (self.sdcadm.sdc.metadata.fabric_cfg) ? 'Updating' : 'Adding';
-    self.progress('%s fabric configuration', word);
-    /*
-     * Note, we're updating the entire application here, but update today only
-     * ever goes one layer deep. eg. update will always replace our key,
-     * 'fabric_cfg', with one that's always what we give it. In this case, it
-     * shouldn't merge anything. If that behavior changes, we're in trouble and
-     * the docs don't exactly promise one behavior or another...
-     */
-    self.sdcadm.sapi.updateApplication(self.sdcadm.sdc.uuid, {
-        action: 'update',
-        metadata: { fabric_cfg: self.data }
-    }, errors.sdcClientErrWrap(cb, 'sapi'));
+        if (self.sdcadm.sdcApp.metadata.fabric_cfg &&
+                jsprim.deepEqual(self.sdcadm.sdcApp.metadata.fabric_cfg,
+                    self.data)) {
+            self.progress('Exactly the same fabric configuration ' +
+                'already in SAPI');
+            return cb(null);
+        }
+        self.configChanged = true;
+
+        var word = (self.sdcadm.sdcApp.metadata.fabric_cfg) ? 'Updating' :
+            'Adding';
+        self.progress('%s fabric configuration', word);
+        /*
+         * Note, we're updating the entire application here, but update today
+         * only ever goes one layer deep. eg. update will always replace our
+         * key, 'fabric_cfg', with one that's always what we give it. In this
+         * case, it shouldn't merge anything. If that behavior changes, we're
+         * in trouble and the docs don't exactly promise one behavior or
+         * another...
+         */
+        self.sdcadm.sapi.updateApplication(self.sdcadm.sdcApp.uuid, {
+            action: 'update',
+            metadata: { fabric_cfg: self.data }
+        }, errors.sdcClientErrWrap(cb, 'sapi'));
+    });
 };
 
 
@@ -751,32 +779,39 @@ Fabrics.prototype.updateFabricsSvcs = function updateFabricsSvcs(cb) {
  */
 Fabrics.prototype.checkDocker = function checkDocker(cb) {
     var self = this;
-    self.sdcadm.getSvc({
-        app: self.sdcadm.sdc.uuid,
-        svc: 'docker',
-        allowNone: true
-    }, function (err, docker) {
-        if (err) {
-            return cb(err);
-        }
-        if (!docker) {
-            return cb();
+    self.sdcadm.ensureSdcApp(function (appErr) {
+        if (appErr) {
+            cb(appErr);
+            return;
         }
 
-        self.dockerSetup = true;
-        if (!docker.metadata.USE_FABRICS) {
-            self.sdcadm.sapi.updateService(docker.uuid, {
-                action: 'update',
-                metadata: { USE_FABRICS: true }
-            }, function (er2, _docker) {
-                if (er2) {
-                    return cb(new errors.SDCClientError(er2, 'sapi'));
-                }
+        self.sdcadm.getSvc({
+            app: self.sdcadm.sdcApp.uuid,
+            svc: 'docker',
+            allowNone: true
+        }, function (err, docker) {
+            if (err) {
+                return cb(err);
+            }
+            if (!docker) {
                 return cb();
-            });
-        } else {
-            return cb();
-        }
+            }
+
+            self.dockerSetup = true;
+            if (!docker.metadata.USE_FABRICS) {
+                self.sdcadm.sapi.updateService(docker.uuid, {
+                    action: 'update',
+                    metadata: { USE_FABRICS: true }
+                }, function (er2, _docker) {
+                    if (er2) {
+                        return cb(new errors.SDCClientError(er2, 'sapi'));
+                    }
+                    return cb();
+                });
+            } else {
+                return cb();
+            }
+        });
     });
 };
 
diff --git a/lib/post-setup/ha-binder.js b/lib/post-setup/ha-binder.js
index 8443b17..3bc3e6a 100644
--- a/lib/post-setup/ha-binder.js
+++ b/lib/post-setup/ha-binder.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2016, Joyent, Inc.
+ * Copyright 2017 Joyent, Inc.
  */
 
 /*
@@ -86,7 +86,7 @@ function do_ha_binder(subcmd, opts, args, cb) {
 
     }
 
-    var app = self.sdcadm.sdc;
+    var app;
     var img, svc, instances, history;
     var vms;
     var oldVms;
@@ -107,7 +107,11 @@ function do_ha_binder(subcmd, opts, args, cb) {
     var hasManatee21 = false;
 
     vasync.pipeline({arg: arg, funcs: [
+        function ensureSdcApp(_, next) {
+            self.sdcadm.ensureSdcApp(next);
+        },
         function getBinderSvc(_, next) {
+            app = self.sdcadm.sdcApp;
             self.progress('Getting SDC\'s binder details from SAPI');
             self.sdcadm.sapi.listServices({
                 name: 'binder',
diff --git a/lib/post-setup/ha-manatee.js b/lib/post-setup/ha-manatee.js
index 9867519..121fe69 100644
--- a/lib/post-setup/ha-manatee.js
+++ b/lib/post-setup/ha-manatee.js
@@ -130,7 +130,7 @@ function do_ha_manatee(subcmd, opts, args, cb) {
     }
 
 
-    var app = self.sdcadm.sdc;
+    var app;
     // This is the primary instance VM:
     var pri;
     // This is the secondary instance VM, if it exists when we run the process
@@ -171,7 +171,11 @@ function do_ha_manatee(subcmd, opts, args, cb) {
     var duplicatedServers = false;
 
     vasync.pipeline({funcs: [
+        function ensureSdcApp(_, next) {
+            self.sdcadm.ensureSdcApp(next);
+        },
         function checkTargetServer(_, next) {
+            app = self.sdcadm.sdcApp;
             self.progress('Verifying target severs "%j" exist', opts.servers);
             self.sdcadm.cnapi.listServers(function (sErr, servers_) {
                 if (sErr) {
diff --git a/lib/post-setup/underlay-nics.js b/lib/post-setup/underlay-nics.js
index 4b319be..b6e7686 100644
--- a/lib/post-setup/underlay-nics.js
+++ b/lib/post-setup/underlay-nics.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2016, Joyent, Inc.
+ * Copyright 2017 Joyent, Inc.
  */
 
 /*
@@ -186,7 +186,8 @@ UnderlayNics.prototype.execute = function (opts, cb) {
         // CNs must have the configured underlay network tag assigned to an
         // actual NIC in order to be able to add underlay-nic for the CN:
         function filterServersWithoutUnderlayNicTag(_, next) {
-            var underlayTag = sdcadm.sdc.metadata.fabric_cfg.sdc_underlay_tag;
+            var underlayTag =
+                sdcadm.sdcApp.metadata.fabric_cfg.sdc_underlay_tag;
             var cnsToSkip = [];
             var theCns = cns2Update;
             cns2Update = [];
diff --git a/lib/procedures/update-agent-v1.js b/lib/procedures/update-agent-v1.js
index 587387c..2c33344 100644
--- a/lib/procedures/update-agent-v1.js
+++ b/lib/procedures/update-agent-v1.js
@@ -120,6 +120,9 @@ UpdateAgentV1.prototype.execute = function uaExecute(opts, callback) {
         };
 
         vasync.pipeline({arg: context, funcs: [
+            function ensureSdcApp(_, next) {
+                sdcadm.ensureSdcApp(next);
+            },
             /*
              * Check if cn-agent service is already on SAPI. Otherwise,
              * inform the user how to add it.
@@ -127,7 +130,7 @@ UpdateAgentV1.prototype.execute = function uaExecute(opts, callback) {
             function checkCnAgentSvcOnSapi(_, next) {
                 sdcadm.getSvc({
                     svc: 'cn-agent',
-                    app: sdcadm.sdc.uuid,
+                    app: sdcadm.sdcApp.uuid,
                     allowNone: true
                 }, function (err, svc) {
                     if (err) {
diff --git a/lib/procedures/update-dockerlogger.js b/lib/procedures/update-dockerlogger.js
index dd603d0..c4526f1 100644
--- a/lib/procedures/update-dockerlogger.js
+++ b/lib/procedures/update-dockerlogger.js
@@ -126,7 +126,7 @@ UpdateDockerlogger.prototype.execute = function udExecute(opts, callback) {
             function checkDockerSvcOnSapi(_, next) {
                 sdcadm.getSvc({
                     svc: 'docker',
-                    app: sdcadm.sdc.uuid,
+                    app: sdcadm.sdcApp.uuid,
                     allowNone: true
                 }, function (err, service) {
                     if (err) {
@@ -155,7 +155,8 @@ UpdateDockerlogger.prototype.execute = function udExecute(opts, callback) {
                         return next();
                     }
                     progress('Creating "dockerlogger" servivce');
-                    sdcadm.sapi.createService('dockerlogger', sdcadm.sdc.uuid, {
+                    sdcadm.sapi.createService('dockerlogger',
+                        sdcadm.sdcApp.uuid, {
                         params: {
                             image_uuid: change.image.uuid
                         },
diff --git a/lib/sdcadm.js b/lib/sdcadm.js
index f492199..202966d 100644
--- a/lib/sdcadm.js
+++ b/lib/sdcadm.js
@@ -247,19 +247,19 @@ function SdcAdm(options) {
     Object.defineProperty(this, 'updates', {
         get: function () {
             if (self._updates === undefined) {
-                assert.object(self.sdc, 'self.sdc (the SAPI "sdc" app) ' +
-                    'must be retrieved for client config');
+                assert.object(self.sdcApp, 'self.sdcApp (the SAPI "sdc" app) '
+                    + 'must be retrieved for client config');
                 var opts = {
                     url: self.config.updatesServerUrl,
-                    proxy: self.sdc.metadata.http_proxy || false,
+                    proxy: self.sdcApp.metadata.http_proxy || false,
                     userAgent: self.userAgent,
                     log: self.log,
                     headers: {
                         'x-request-id': self.uuid
                     }
                 };
-                if (self.sdc.metadata.update_channel) {
-                    opts.channel = self.sdc.metadata.update_channel;
+                if (self.sdcApp.metadata.update_channel) {
+                    opts.channel = self.sdcApp.metadata.update_channel;
                 }
                 self._updates = new sdcClients.IMGAPI(opts);
             }
@@ -269,11 +269,16 @@ function SdcAdm(options) {
     Object.defineProperty(this, 'imagesJo', {
         get: function () {
             if (self._imagesJo === undefined) {
+<<<<<<< HEAD
                 assert.object(self.sdc, 'self.sdc (the SAPI "sdc" app) ' +
                     'must be retrieved for client config');
+=======
+                assert.object(self.sdcApp, 'self.sdcApp (the SAPI "sdc" app) '
+                    + 'must be retrieved for client config');
+>>>>>>> TOOLS-1699 sdcadm health -j should always provide JSON even on exceptions
                 var opts = {
                     url: 'https://images.joyent.com',
-                    proxy: self.sdc.metadata.http_proxy || false,
+                    proxy: self.sdcApp.metadata.http_proxy || false,
                     userAgent: self.userAgent,
                     log: self.log,
                     headers: {
@@ -383,8 +388,47 @@ function SdcAdm(options) {
     this.sadm_urStart = null;
 }
 
+// Avoid preloading sdcApp by default since we cannot load it during
+// headnode recovery. Additionally, this allow us to handle the error
+// messages output when the command in use is given JSON option:
+SdcAdm.prototype.ensureSdcApp = function (arg, cb) {
+    if (typeof (arg) === 'function') {
+        cb = arg;
+    }
+    var self = this;
+    if (self.sdcApp) {
+        cb();
+        return;
+    }
+
+    self.getApp({app: 'sdc'}, function (appErr, app) {
+        if (appErr) {
+            // Couple known issues we can help operators with a friendly
+            // message instead of the default "ENO..." errors:
+            if (appErr.message) {
+                var msg;
+                if (appErr.message.match(/getaddrinfo ENOTFOUND/)) {
+                    msg = 'Binder service seems to be down. ' +
+                            'Please review it before proceeding';
+                } else if (appErr.message.match(/connect ECONNREFUSED/)) {
+                    msg = 'SAPI service seems to be down. ' +
+                            'Please review it before proceeding';
+                }
+                if (!arg.json) {
+                    console.log(msg);
+                }
+            }
+            return cb(appErr);
+        }
+        self.sdcApp = app;
+        cb();
+    });
+
+};
+
+
 // This function defines the sdcadm properties which require async callbacks
-// to be used: 'config', 'history' and 'sdc' application.
+// to be used: 'config' and 'history'.
 SdcAdm.prototype.init = function init(cb) {
     var self = this;
     common.loadConfig({log: self.log}, function (err, config) {
@@ -398,25 +442,7 @@ SdcAdm.prototype.init = function init(cb) {
         }
 
         self.history = new History({sdcadm: self});
-
-        self.getApp({app: 'sdc'}, function (appErr, app) {
-            if (appErr) {
-                // Couple known issues we can help operators with a friendly
-                // message instead of the default "ENO..." errors:
-                if (appErr.message) {
-                    if (appErr.message.match(/getaddrinfo ENOTFOUND/)) {
-                        console.log('Binder service seems to be down. ' +
-                                'Please review it before proceeding');
-                    } else if (appErr.message.match(/connect ECONNREFUSED/)) {
-                        console.log('SAPI service seems to be down. ' +
-                                'Please review it before proceeding');
-                    }
-                }
-                return cb(appErr);
-            }
-            self.sdc = app;
-            return self.history.init(cb);
-        });
+        self.history.init(cb);
     });
 };
 
@@ -579,6 +605,9 @@ SdcAdm.prototype.listInsts = function listInsts(opts, cb) {
         insts: []
     };
     vasync.pipeline({arg: context, funcs: [
+        function ensureSdcApp(_, next) {
+            self.ensureSdcApp({ json: opts.json || false }, next);
+        },
         function getServers(ctx, next) {
             ctx.serverFromUuid = {};
             ctx.serverAdminIpFromUuid = {};
@@ -813,6 +842,15 @@ SdcAdm.prototype.listInsts = function listInsts(opts, cb) {
                 return next();
             }
 
+            self.getSvc({
+                app: self.sdcApp.uuid,
+                svc: 'dockerlogger',
+                allowNone: true
+            }, function (svcErr, dlSvc) {
+                if (svcErr) {
+                    return next(new errors.SDCClientError(svcErr, 'sapi'));
+                }
+
             var dlCtx = {};
 
             vasync.pipeline({
@@ -943,15 +981,17 @@ SdcAdm.prototype.getServices = function getServices(opts, cb) {
     assert.object(opts, 'opts');
     assert.func(cb, 'cb');
 
-    var app = self.sdc;
     var svcs = [];
     vasync.pipeline({funcs: [
+        function ensureSdcApp(_, next) {
+            self.ensureSdcApp({ json: opts.json || false }, next);
+        },
         function getSapiSvcs(_, next) {
             // 'cloudapi' zones typically don't have `tags.smartdc_core=true`
             // so we can't filter on that. And VMAPI doesn't support filtering
             // on presence of a tag (e.g. `smartdc_role`.)
             var filters = {
-                application_uuid: app.uuid
+                application_uuid: self.sdcApp.uuid
             };
 
             if (opts.type) {
@@ -1025,136 +1065,894 @@ SdcAdm.prototype.getServices = function getServices(opts, cb) {
                 {
                     'name': 'zonetracker'
                 }
-            ].forEach(function (agent) {
-                var exists = svcs.filter(function (s) {
-                    return (s.name === agent.name);
-                }).length;
-                if (!exists) {
-                    agent.type = 'agent';
-                    svcs.push(agent);
+            ].forEach(function (agent) {
+                var exists = svcs.filter(function (s) {
+                    return (s.name === agent.name);
+                }).length;
+                if (!exists) {
+                    agent.type = 'agent';
+                    svcs.push(agent);
+                }
+            });
+            next();
+        }
+    ]}, function (err) {
+        cb(err, svcs);
+    });
+};
+
+
+/**
+ * Get the full image object for the given image UUID from either the local
+ * IMGAPI or the updates server.
+ *
+ * @param opts {Object} Required.
+ *      - uuid {UUID} Required. The image uuid.
+ * @param cb {Function} `function (err, img)`
+ */
+SdcAdm.prototype.getImage = function getImage(opts, cb) {
+    assert.object(opts, 'opts');
+    assert.string(opts.uuid, 'opts.uuid');
+    assert.func(cb, 'cb');
+    var self = this;
+    var img;
+
+    vasync.pipeline({funcs: [
+        function ensureSdcApp(_, next) {
+            self.ensureSdcApp(next);
+        },
+        function getImg(_, next) {
+            self.imgapi.getImage(opts.uuid, function (iErr, iImg) {
+                if (iErr && iErr.body &&
+                    iErr.body.code === 'ResourceNotFound') {
+                    self.updates.getImage(opts.uuid, function (err, image) {
+                        if (err) {
+                            next(err);
+                            return;
+                        }
+                        img = image;
+                    });
+                } else {
+                    img = iImg;
+                    next(iErr);
+                }
+            });
+        }
+    ]}, function (pipeErr) {
+        cb(pipeErr, img);
+    });
+};
+
+
+/**
+ * Get a SAPI application.
+ *
+ * @param opts {Object} Required.
+ *      - app {String|UUID} Required. The application name or UUID.
+ * @param cb {Function} `function (err, app)`
+ */
+SdcAdm.prototype.getApp = function getApp(opts, cb) {
+    assert.object(opts, 'opts');
+    assert.string(opts.app, 'opts.app');
+    assert.func(cb, 'cb');
+
+    if (opts.app === 'sdc' && this.sdcApp) {
+        cb(null, this.sdcApp);
+    } else if (common.UUID_RE.test(opts.app)) {
+        this.sapi.getApplication(opts.app, errors.sdcClientErrWrap(cb, 'sapi'));
+    } else {
+        this.sapi.listApplications({name: opts.app}, function (err, apps) {
+            if (err) {
+                cb(new errors.SDCClientError(err, 'sapi'));
+            } else if (apps.length !== 1) {
+                cb(new errors.InternalError({
+                    message: format('unexpected number of "%s" apps: %d',
+                        opts.app, apps.length)
+                }));
+            } else {
+                cb(null, apps[0]);
+            }
+        });
+    }
+};
+
+/**
+ * Get a SAPI service.
+ *
+ * Dev Note: Why 'getSvc' and not 'getService'? I want to move to
+ * app/svc/inst/img for naming in functions as well.
+ *
+ * @param opts {Object} Required.
+ *      - app {String|UUID} Required. The application name or UUID.
+ *      - svc {String|UUID} Required. The service name or UUID.
+ *      - allowNone {Boolean} Optional. Default false. Set `true` to return
+ *        `cb()` if there is no such service. By default an InternalError is
+ *        returned.
+ * @param cb {Function} `function (err, svc)`
+ */
+SdcAdm.prototype.getSvc = function getSvc(opts, cb) {
+    var self = this;
+    assert.string(opts.app, 'opts.app');
+    assert.string(opts.svc, 'opts.svc');
+    assert.optionalBool(opts.allowNone, 'opts.allowNone');
+
+    self.getApp({app: opts.app}, function (appErr, app) {
+        if (appErr) {
+            return cb(appErr);
+        }
+
+        if (common.UUID_RE.test(opts.svc)) {
+            self.sapi.getService(opts.svc, function (svcErr, svc) {
+                if (svcErr) {
+                    return cb(new errors.SDCClientError(svcErr, 'sapi'));
+                } else if (svc.application_uuid !== app.uuid) {
+                    cb(new errors.ValidationError(format(
+                        'given svc "%s" does not belong to the "%s" app',
+                        opts.svc, opts.app)));
+                } else {
+                    cb(null, svc);
+                }
+            });
+        } else {
+            var filters = {
+                application_uuid: app.uuid,
+                name: opts.svc
+            };
+            self.sapi.listServices(filters, function (svcsErr, svcs) {
+                if (svcsErr) {
+                    return cb(new errors.SDCClientError(svcsErr, 'sapi'));
+                } else if (svcs.length > 1) {
+                    cb(new errors.InternalError({
+                        message: format('unexpected number of "%s" svcs: %d',
+                            opts.svc, svcs.length)
+                    }));
+                } else if (svcs.length === 0) {
+                    if (opts.allowNone) {
+                        cb(null);
+                    } else {
+                        cb(new errors.InternalError({
+                            message: format('no "%s" service found', opts.svc)
+                        }));
+<<<<<<< HEAD
+=======
+                    }
+                } else {
+                    cb(null, svcs[0]);
+                }
+            });
+        }
+    });
+};
+
+
+/**
+ * Get the image version for all the active VMs of the given service.
+ *
+ * @type obj {Object} including:
+ * @prop vms {Array} of VMAPI vms
+ * @prop imgs {Array} of IMGAPI imgs (only different images, if all the
+ * VMs are using the same image, only one image will be returned here).
+ *
+ * @params svc {String|UUID} Required. The service name or UUID.
+ * @param cb {Function} `function (err, obj)`
+ */
+SdcAdm.prototype.getImgsForSvcVms = function getImgsForSvcVms(opts, cb) {
+    var self = this;
+    assert.object(opts, 'opts');
+    assert.optionalString(opts.app, 'opts.app');
+    assert.string(opts.svc, 'opts.svc');
+    assert.func(cb, 'cb');
+
+    if (!opts.app) {
+        opts.app = 'sdc';
+    }
+    var svc, vms;
+
+    vasync.pipeline({funcs: [
+            function _getSvc(_, next) {
+                self.getSvc(opts, function (err, service) {
+                    if (err) {
+                        return next(err);
+                    }
+                    svc = service;
+                    return next();
+                });
+            },
+            function _getVms(_, next) {
+                self.vmapi.listVms({
+                    'tag.smartdc_role': svc.name,
+                    state: 'active'
+                }, function (vmsErr, vms_) {
+                    if (vmsErr) {
+                        return next(vmsErr);
+                    }
+                    if (!vms_.length) {
+                        return next(new errors.SDCClientError(new Error(format(
+                             'Unable to find %s VMs', svc.name)),
+                             'vmapi'));
+                    }
+
+                    vms = vms_;
+                    return next();
+                });
+            }
+    ]}, function pipeCb(err) {
+        if (err) {
+            return cb(err);
+        }
+
+        var imgs = [];
+
+        var differentImgUUIDs = vms.map(function (vm) {
+            return (vm.image_uuid);
+        }).sort().filter(function (id, pos, ary) {
+            // Once we've sorted out the array, we can remove any duplicates
+            // just by looking up at the previous element. Obviously, first one
+            // will never be removed.
+            return (!pos || id !== ary[pos - 1]);
+        });
+
+        vasync.forEachParallel({
+            func: function _getImg(id, next) {
+                self.getImage({uuid: id}, function (er3, img) {
+                    if (er3) {
+                        return next(er3);
+                    }
+                    imgs.push(img);
+                    return next();
+                });
+            },
+            inputs: differentImgUUIDs
+        }, function paraCb(err2) {
+            if (err2) {
+                return cb(err2);
+            }
+            return cb(null, {imgs: imgs, vms: vms});
+        });
+    });
+};
+
+
+/**
+ * Get the default channel used to retrieve images for updates.
+ *
+ * This may be either the local channel when set, or the default remote, when
+ * there is no local setting.
+ *
+ * @param cb {Function} `function (err, channel)`
+ */
+SdcAdm.prototype.getDefaultChannel = function getDefaultChannel(cb) {
+    var self = this;
+
+    var channel;
+
+    vasync.pipeline({funcs: [
+        function ensureSdcApp(_, next) {
+            self.ensureSdcApp(next);
+        },
+        function getChannel(_, next) {
+            if (self.updates.channel) {
+                channel = self.updates.channel;
+                next();
+            } else if (self.sdcApp.metadata.update_channel) {
+                channel = self.sdcApp.metadata.update_channel;
+                next();
+            } else {
+                self.updates.listChannels({}, function (err, channels) {
+                    if (err) {
+                        var e = new errors.SDCClientError(err, 'imgapi');
+                        next(e);
+                        return;
+                    }
+
+                    var remote = channels.filter(function (c) {
+                        return (c['default']);
+                    }).shift();
+                    channel = remote.name;
+                    next();
+                });
+            }
+
+        }
+    ]}, function (pipeErr) {
+        cb(pipeErr, channel);
+    });
+
+};
+
+
+
+/*
+ * Fetch a given agent installer image (or if desired, latest), download it,
+ * then deploy it on the selected servers.
+ *
+ * @param options.agentsshar {String} A string indicating the agentsshar to
+ *      which to update. This is the string 'latest', an updates server UUID, or
+ *      a path to a locally downloaded agentsshar.
+ * @param options.all {Boolean} Update on all setup servers.
+ *      One of `options.all` or `options.servers` must be specified.
+ * @param options.servers {Array} Array of server hostnames or UUIDs on which
+ *      to update. One of `options.all` or `options.servers` must be specified.
+ * ...
+ *
+ * TODO: finish documenting
+ * TODO: refactor to lib/steps/, separate out the image lookup, the download
+ */
+SdcAdm.prototype.updateAgents = function updateAgents(options, callback) {
+    assert.object(options, 'options');
+    assert.string(options.agentsshar, 'options.agentsshar');
+    assert.optionalBool(options.justDownload, 'options.justDownload');
+    assert.optionalBool(options.yes, 'options.yes');
+    assert.optionalBool(options.all, 'options.all');
+    assert.optionalArrayOfString(options.servers, 'options.servers');
+    assert.func(options.progress, 'options.progress');
+    assert.func(callback, 'callback');
+
+    if ((options.all && options.servers) ||
+        (!options.all && !options.servers)) {
+        return callback(new Error(
+            'must specify exactly one of "options.all" or "options.servers"'));
+    }
+
+    var self = this;
+    var log = self.log;
+
+    var startTime = Date.now();
+    var downloadDir = '/var/tmp';
+    var filepath;
+    var channel;
+    var image;
+    // The file name, to be used by ur:
+    var fname;
+    var progress = options.progress;
+    var justDownload = options.justDownload;
+    var hist;
+
+    function setImageToLatest(cb) {
+        var filter = {
+            name: 'agentsshar'
+        };
+        progress('Finding latest "agentsshar" on updates server (channel "%s")',
+            channel);
+        self.updates.listImages(filter, function (err, images) {
+            if (err) {
+                cb(new errors.SDCClientError(err, 'updates'));
+                return;
+            }
+            if (Array.isArray(images) && !images.length) {
+                return cb(new errors.UpdateError('no images found'));
+            }
+            common.sortArrayOfObjects(images, ['published_at']);
+            image = images[images.length - 1];
+            progress('Latest is agentsshar %s (%s)', image.uuid, image.version);
+            cb();
+        });
+    }
+
+    function setImageFromUuid(imageUuid, cb) {
+        self.updates.getImage(imageUuid, function (err, foundImage) {
+            if (err) {
+                cb(new errors.SDCClientError(err, 'updates'));
+                return;
+            }
+            image = foundImage;
+            progress('Found agentsshar %s (%s)', image.uuid, image.version);
+            cb();
+        });
+    }
+
+    function sha1Path(filePath, cb) {
+        var hash = crypto.createHash('sha1');
+        var s = fs.createReadStream(filePath);
+        s.on('data', function (d) {
+            hash.update(d);
+        });
+        s.on('end', function () {
+            cb(null, hash.digest('hex'));
+        });
+    }
+
+    var context = {
+        progress: progress,
+        log: self.log,
+        sdcadm: self,
+        urconn: null
+    };
+
+    vasync.pipeline({arg: context, funcs: [
+        function ensureSdcApp(_, next) {
+            self.ensureSdcApp(next);
+        },
+        /*
+         * Check for Ur availability first, as we cannot proceed without
+         * it:
+         */
+        function urDiscoveryGetReady(ctx, next) {
+            if (justDownload) {
+                return next();
+            }
+
+            self.getUrConnection(function (err, urconn) {
+                if (err) {
+                    log.debug({
+                        err: err
+                    }, 'ur error');
+                    next(new errors.InternalError({
+                        cause: err,
+                        message: 'ur not available (check RabbitMQ)'
+                    }));
+                    return;
+                }
+
+                log.debug('ur connected');
+                ctx.urconn = urconn;
+                next();
+            });
+        },
+
+        function getChannelIfNeeded(_, next) {
+            if (options.agentsshar === 'latest' ||
+                common.UUID_RE.test(options.agentsshar))
+            {
+                self.getDefaultChannel(function (err, ch) {
+                    channel = ch;
+                    next(err);
+                });
+            } else {
+                next();
+            }
+        },
+
+        function setImageOrFilepath(_, next) {
+            if (options.agentsshar === 'latest') {
+                setImageToLatest(next);
+            } else if (common.UUID_RE.test(options.agentsshar)) {
+                setImageFromUuid(options.agentsshar, next);
+            } else if (fs.existsSync(options.agentsshar)) {
+                filepath = options.agentsshar;
+                next();
+            } else {
+                next(new Error(format('could not find agentsshar: "%s" is ' +
+                    'not a UUID or an existing file', options.agentsshar)));
+            }
+        },
+
+        /*
+         * If we are about to download an image, first check to see if that
+         * image is already available locally (verifying via checksum).
+         * If so, then switch to using that file.
+         */
+        function haveSharAlready_candidate1(ctx, next) {
+            if (filepath) {
+                return next();
+            }
+
+            // lla == "Latest Local Agentsshar"
+            var llaLink = '/usbkey/extra/agents/latest';
+            fs.exists(llaLink, function (exists) {
+                if (!exists) {
+                    log.debug({llaLink: llaLink}, 'symlink to latest ' +
+                        'agentsshar is missing, skipping shortcut');
+                    return next();
+                }
+                fs.readlink(llaLink, function (err, linkTarget) {
+                    if (err) {
+                        log.error({err: err, llaLink: llaLink},
+                            'could not read agents "latest" symlink');
+                        return next(new errors.UpdateError(err,
+                            'could not read agents "latest" symlink, ' +
+                            llaLink));
+                    }
+
+                    var llaPath = path.resolve(
+                        path.dirname(llaLink), linkTarget);
+                    log.debug({llaPath: llaPath}, 'latest local agentsshar');
+                    sha1Path(llaPath, function (checksumErr, checksum) {
+                        if (checksumErr) {
+                            return next(checksumErr);
+                        }
+                        if (checksum === image.files[0].sha1) {
+                            progress('The %s agentsshar already exists ' +
+                                'at %s, using it', options.agentsshar,
+                                llaPath);
+                            filepath = llaPath;
+                        }
+                        next();
+                    });
+                });
+            });
+        },
+        function haveSharAlready_candidate2(ctx, next) {
+            if (filepath) {
+                return next();
+            }
+
+            var predownloadedPath = path.resolve(downloadDir,
+                'agent-' + image.uuid + '.sh');
+            fs.exists(predownloadedPath, function (exists) {
+                if (!exists) {
+                    return next();
+                }
+                sha1Path(predownloadedPath, function (checksumErr, checksum) {
+                    if (checksumErr) {
+                        return next(checksumErr);
+                    }
+                    if (checksum === image.files[0].sha1) {
+                        progress('The %s agentsshar already exists ' +
+                            'at %s, using it', options.agentsshar,
+                            predownloadedPath);
+                        filepath = predownloadedPath;
+                    }
+                    next();
+                });
+            });
+        },
+
+        function listServers(ctx, next) {
+            if (justDownload) {
+                return next();
+            }
+            progress('Finding servers to update');
+            // Get all servers to validate if unsetup servers are selected.
+            self.cnapi.listServers({}, function (err, servers) {
+                if (err) {
+                    return next(err);
+                }
+                ctx.allServers = servers;
+                next();
+            });
+        },
+
+        function findServersToUpdate(ctx, next) {
+            if (justDownload) {
+                return next();
+            }
+
+            if (options.all) {
+                ctx.serversToUpdate = ctx.allServers.filter(function (svr) {
+                    return svr.setup;
+                });
+                next();
+            } else {
+                var i, s;
+                var serverFromUuid = {};
+                var serverFromHostname = {};
+                for (i = 0; i < ctx.allServers.length; i++) {
+                    s = ctx.allServers[i];
+                    serverFromUuid[s.uuid] = s;
+                    serverFromHostname[s.hostname] = s;
+                }
+
+                ctx.serversToUpdate = [];
+                var serverToUpdateFromUuid = {};
+                var unsetupServerIds = [];
+                var notFoundServerIds = [];
+                for (i = 0; i < options.servers.length; i++) {
+                    var id = options.servers[i];
+                    s = serverFromUuid[id] || serverFromHostname[id];
+                    if (s) {
+                        // Avoid drop dupes in `opts.servers`.
+                        if (! serverToUpdateFromUuid[s.uuid]) {
+                            ctx.serversToUpdate.push(s);
+                            serverToUpdateFromUuid[s.uuid] = true;
+                        }
+                        if (!s.setup) {
+                            unsetupServerIds.push(id);
+                        }
+                    } else {
+                        notFoundServerIds.push(id);
+                    }
+                }
+                if (notFoundServerIds.length) {
+                    next(new Error(format(
+                        '%d of %d selected servers were not found in CNAPI: %s',
+                        notFoundServerIds.length, options.servers.length,
+                        notFoundServerIds.join(', '))));
+                } else if (unsetupServerIds.length) {
+                    next(new Error(format(
+                        '%d of %d selected servers are not setup: %s',
+                        unsetupServerIds.length, options.servers.length,
+                        unsetupServerIds.join(', '))));
+                } else {
+                    next();
+                }
+            }
+        },
+
+        function urDiscovery(ctx, next) {
+            if (justDownload) {
+                return next();
+            }
+
+            common.urDiscovery({
+                sdcadm: self,
+                progress: progress,
+                nodes: ctx.serversToUpdate.map(
+                    function (s) { return s.uuid; }),
+                urconn: ctx.urconn
+            }, function (err, urAvailServers) {
+                if (err) {
+                    return next(err);
+                }
+                ctx.urServersToUpdate = urAvailServers;
+                return next();
+            });
+        },
+
+        function earlyAbortForJustDownload(ctx, next) {
+            if (justDownload && filepath) {
+                progress('Agentsshar is already downloaded to %s', filepath);
+                next(true); // early abort signal
+            } else {
+                next();
+            }
+        },
+
+        function confirm(ctx, next) {
+            progress('\nThis update will make the following changes:');
+            progress(common.indent('Ensure core agent SAPI services exist'));
+            if (!filepath) {
+                assert.object(image, 'image');
+                progress(common.indent(format(
+                    'Download agentsshar %s\n    (%s)',
+                    image.uuid, image.version)));
+            }
+            if (!justDownload) {
+                progress(common.indent(format(
+                    'Update GZ agents on %d (of %d) servers using\n' +
+                    '    agentsshar %s', ctx.serversToUpdate.length,
+                    ctx.allServers.length,
+                    (filepath ? filepath : image.version))));
+            }
+            progress('');
+            if (options.yes) {
+                return next();
+            }
+            var msg = 'Would you like to continue? [y/N] ';
+            common.promptYesNo({msg: msg, default: 'n'}, function (answer) {
+                if (answer !== 'y') {
+                    progress('Aborting agents update');
+                    return callback();
+                }
+                progress('');
+                startTime = Date.now(); // Reset to not count confirm time.
+                return next();
+            });
+        },
+
+        function saveChangesToHistory(_, next) {
+            if (justDownload) {
+                return next();
+            }
+            var change = {
+                service: {
+                    name: 'agentsshar'
+                },
+                type: 'update-service',
+                img: (image ? image : options.agentsshar)
+            };
+
+            self.history.saveHistory({
+                changes: [change]
+            }, function (err, hst) {
+                if (err) {
+                    return next(err);
+                }
+                hist = hst;
+                return next();
+            });
+        },
+
+        steps.agentServicesEnsureCreated,
+
+        function downloadAgentsshar(ctx, next) {
+            if (filepath) {
+                return next();
+            }
+            filepath = path.resolve(downloadDir,
+                'agent-' + image.uuid + '.sh');
+            ctx.deleteAgentssharOnFinish = true;
+            progress('Downloading agentsshar from updates server ' +
+                '(channel "%s")\n    to %s', channel, filepath);
+            self.updates.getImageFile(image.uuid, filepath, function (err) {
+                if (err) {
+                    next(new errors.SDCClientError(err, 'updates'));
+                } else {
+                    next();
                 }
             });
-            next();
-        }
-    ]}, function (err) {
-        cb(err, svcs);
-    });
-};
+        },
 
+        function copyFileToAssetsDir(_, next) {
+            if (justDownload) {
+                return next();
+            }
+            var assetsdir = '/usbkey/extra/agents';
+            if (path.dirname(filepath) === assetsdir) {
+                return next();
+            }
+            progress('Copy agentsshar to assets dir: %s', assetsdir);
+            var argv = ['cp', filepath, assetsdir];
+            mkdirp.sync(assetsdir);
+            common.execFilePlus({
+                argv: argv,
+                log: self.log
+            }, function (err, stderr, stdout) {
+                self.log.trace({
+                    cmd: argv.join(' '),
+                    err: err,
+                    stdout: stdout,
+                    stderr: stderr
+                }, 'ran cp command');
+                if (err) {
+                    return next(new errors.InternalError({
+                        message: format('error copying shar file to %s',
+                                         assetsdir),
+                        cmd: argv.join(' '),
+                        stdout: stdout,
+                        stderr: stderr,
+                        cause: err
+                    }));
+                }
+                next();
+            });
+        },
 
-/**
- * Get the full image object for the given image UUID from either the local
- * IMGAPI or the updates server.
- *
- * @param opts {Object} Required.
- *      - uuid {UUID} Required. The image uuid.
- * @param cb {Function} `function (err, img)`
- */
-SdcAdm.prototype.getImage = function getImage(opts, cb) {
-    assert.object(opts, 'opts');
-    assert.string(opts.uuid, 'opts.uuid');
-    assert.func(cb, 'cb');
-    var self = this;
+        function createLatestSymlink(_, next) {
+            if (justDownload) {
+                return next();
+            }
+            // TODO: this should just use `fs.unlink/symlink`.
+            progress('Create /usbkey/extra/agents/latest symlink');
+            common.execFilePlus({
+                argv: [ 'rm', '-f', '/usbkey/extra/agents/latest' ],
+                log: self.log
+            }, function (rmErr) {
+                if (rmErr) {
+                    return next(rmErr);
+                }
+                fname = path.basename(filepath);
+                common.execFilePlus({
+                    argv: ['ln', '-s', fname, 'latest'],
+                    cwd: '/usbkey/extra/agents',
+                    log: self.log
+                }, function (lnErr) {
+                    if (lnErr) {
+                        return next(lnErr);
+                    }
+                    return next();
+                });
+            });
+        },
 
-    self.imgapi.getImage(opts.uuid, function (iErr, iImg) {
-        if (iErr && iErr.body && iErr.body.code === 'ResourceNotFound') {
-            self.updates.getImage(opts.uuid, cb);
-        } else {
-            cb(iErr, iImg);
-        }
-    });
-};
+        function updateCNAgents(ctx, next) {
+            if (justDownload) {
+                return next();
+            }
 
+            progress('Starting agentsshar update on %d servers',
+                ctx.urServersToUpdate.length);
 
-/**
- * Get a SAPI application.
- *
- * @param opts {Object} Required.
- *      - app {String|UUID} Required. The application name or UUID.
- * @param cb {Function} `function (err, app)`
- */
-SdcAdm.prototype.getApp = function getApp(opts, cb) {
-    assert.object(opts, 'opts');
-    assert.string(opts.app, 'opts.app');
-    assert.func(cb, 'cb');
+            var ip = self.config.assets_admin_ip;
+            var f = fname;
+            var ff = '/var/tmp/' + f;
+            // Do not override log file if we run installer more than once for
+            // the same version.
+            // TODO(trent): Won't these build up? Should clean these out.
+            var lf = '/var/tmp/' + f + '_' + uuid() + '_install.log';
+            var nodeConfigCmd = [
+                'cd /var/tmp;',
+                '',
+                /*
+                 * Rename previous node.config file, if exists
+                 */
+                'if [[ -f /var/tmp/node.config/node.config ]]; then',
+                '   mv /var/tmp/node.config/node.config ' +
+                    '/var/tmp/node.config/node.\$\$.config',
+                'fi',
+                '',
+                /*
+                 * Update node.config first, just in case
+                 *
+                 * Exit 33 if cannot download the node.config file
+                 */
+                'if [[ -z "$(bootparams | grep \'^headnode=true\')" ]]; then',
+                '   if [[ ! -d  /var/tmp/node.config ]]; then',
+                '       rm /var/tmp/node.config',
+                '       mkdir -p /var/tmp/node.config',
+                '   fi',
+                '',
+                '   /usr/bin/curl -ksf http://' + ip +
+                        '/extra/joysetup/node.config' +
+                        ' -o /var/tmp/node.config/node.config',
+                '   if [[ "$?" -ne "0" ]]; then',
+                '       exit 33',
+                '   fi',
+                '',
+                /*
+                 * Exit non zero if config dir does not exist
+                 */
+                '   if [[ ! -d  /opt/smartdc/config && -z "$IS_CN" ]]; then',
+                '       exit 44',
+                '   fi',
+                '',
+                '   /usr/bin/cp /var/tmp/node.config/node.config '+
+                '/opt/smartdc/config/',
+                'fi',
+                ''
+            ].join('\n');
 
-    if (opts.app === 'sdc' && this.sdc) {
-        cb(null, this.sdc);
-    } else if (common.UUID_RE.test(opts.app)) {
-        this.sapi.getApplication(opts.app, errors.sdcClientErrWrap(cb, 'sapi'));
-    } else {
-        this.sapi.listApplications({name: opts.app}, function (err, apps) {
-            if (err) {
-                cb(new errors.SDCClientError(err, 'sapi'));
-            } else if (apps.length !== 1) {
-                cb(new errors.InternalError({
-                    message: format('unexpected number of "%s" apps: %d',
-                        opts.app, apps.length)
-                }));
-            } else {
-                cb(null, apps[0]);
-            }
-        });
-    }
-};
+            var downloadCmd = [
+                'cd /var/tmp;',
+                /*
+                 * Exit non zero if agents dir does not exist
+                 */
+                'if [[ ! -d  /opt/smartdc/agents/lib ]]; then',
+                '   exit 50',
+                'fi',
+                '',
+                /*
+                 * Exit 22 if cannot download the installer file (curl code)
+                 */
+                '/usr/bin/curl -kOsf http://' + ip + '/extra/agents/' + f,
+                'if [[ "$?" -ne "0" ]]; then',
+                '   exit $?',
+                'fi',
+                ''
+            ].join('\n');
 
-/**
- * Get a SAPI service.
- *
- * Dev Note: Why 'getSvc' and not 'getService'? I want to move to
- * app/svc/inst/img for naming in functions as well.
- *
- * @param opts {Object} Required.
- *      - app {String|UUID} Required. The application name or UUID.
- *      - svc {String|UUID} Required. The service name or UUID.
- *      - allowNone {Boolean} Optional. Default false. Set `true` to return
- *        `cb()` if there is no such service. By default an InternalError is
- *        returned.
- * @param cb {Function} `function (err, svc)`
- */
-SdcAdm.prototype.getSvc = function getSvc(opts, cb) {
-    var self = this;
-    assert.string(opts.app, 'opts.app');
-    assert.string(opts.svc, 'opts.svc');
-    assert.optionalBool(opts.allowNone, 'opts.allowNone');
+            var installCmd = [
+                'cd /var/tmp;',
+                '',
+                /*
+                 * Exit 60 if installer fails
+                 */
+                '/usr/bin/bash ' + ff + ' </dev/null >' + lf +' 2>&1',
+                'if [[ "$?" -ne "0" ]]; then',
+                '   exit 60',
+                'fi',
+                ''
+            ].join('\n');
 
-    self.getApp({app: opts.app}, function (appErr, app) {
-        if (appErr) {
-            return cb(appErr);
-        }
+            vasync.forEachPipeline({
+                inputs: [
+                    {
+                        str: nodeConfigCmd,
+                        progbarName: 'Updating node.config',
+                        timeout: 10 * 60 * 1000
+                    },
+                    {
+                        str: downloadCmd,
+                        progbarName: 'Downloading agentsshar',
+                        timeout: 10 * 60 * 1000
+                    },
+                    {
+                        str: installCmd,
+                        progbarName: 'Installing agentsshar',
+                        timeout: 20 * 60 * 1000
+                    }
+                ],
+                func: function runUrQueue(cmd, nextCmd) {
+                    assert.object(ctx.urconn, 'ctx.urconn');
+                    var queueOpts = {
+                        sdcadm: self,
+                        urConnection: ctx.urconn,
+                        log: self.log,
+                        progress: progress,
+                        command: cmd.str,
+                        concurrency: options.rate,
+                        timeout: cmd.timeout
+                    };
 
-        if (common.UUID_RE.test(opts.svc)) {
-            self.sapi.getService(opts.svc, function (svcErr, svc) {
-                if (svcErr) {
-                    return cb(new errors.SDCClientError(svcErr, 'sapi'));
-                } else if (svc.application_uuid !== app.uuid) {
-                    cb(new errors.ValidationError(format(
-                        'given svc "%s" does not belong to the "%s" app',
-                        opts.svc, opts.app)));
-                } else {
-                    cb(null, svc);
-                }
-            });
-        } else {
-            var filters = {
-                application_uuid: app.uuid,
-                name: opts.svc
-            };
-            self.sapi.listServices(filters, function (svcsErr, svcs) {
-                if (svcsErr) {
-                    return cb(new errors.SDCClientError(svcsErr, 'sapi'));
-                } else if (svcs.length > 1) {
-                    cb(new errors.InternalError({
-                        message: format('unexpected number of "%s" svcs: %d',
-                            opts.svc, svcs.length)
-                    }));
-                } else if (svcs.length === 0) {
-                    if (opts.allowNone) {
-                        cb(null);
-                    } else {
-                        cb(new errors.InternalError({
-                            message: format('no "%s" service found', opts.svc)
-                        }));
+                    var bar;
+                    if (process.stderr.isTTY) {
+                        bar = new ProgressBar({
+                            size: ctx.urServersToUpdate.length,
+                            bytes: false,
+                            filename: cmd.progbarName
+                        });
+                        queueOpts.progbar = bar;
+>>>>>>> TOOLS-1699 sdcadm health -j should always provide JSON even on exceptions
                     }
                 } else {
                     cb(null, svcs[0]);
@@ -2576,7 +3374,7 @@ SdcAdm.prototype.genUpdatePlan = function genUpdatePlan(options, cb) {
                             if (ch.service === 'dockerlogger') {
                                 ch.service = {
                                     name: 'dockerlogger',
-                                    application_uuid: self.sdc.uuid,
+                                    application_uuid: self.sdcApp.uuid,
                                     type: 'other',
                                     params: {
                                         // First dockerlogger image ever:
@@ -3082,8 +3880,8 @@ SdcAdm.prototype.genUpdatePlan = function genUpdatePlan(options, cb) {
                     if (self.config.svcMinImages[ch.service.name]) {
                         checkMinImageBuildDate({
                             service: ch.service.name,
-                            version: ch.image.version,
-                            image: ch.image.uuid
+                            image: ch.image.uuid,
+                            version: ch.image.version
                         });
                     }
                 }
@@ -3832,7 +4630,7 @@ SdcAdm.prototype.dcMaintStatus = function dcMaintStatus(cb) {
     var self = this;
     var log = self.log;
 
-    var sdcApp = self.sdc;
+    var sdcApp = self.sdcApp;
     var services = {};
     var maint = false;
     var cloudapiMaint;
@@ -3953,7 +4751,7 @@ SdcAdm.prototype.dcMaintStart = function dcMaintStart(opts, cb) {
     var self = this;
     var progress = opts.progress || function () {};
 
-    var sdcApp = self.sdc;
+    var sdcApp = self.sdcApp;
     var services = {};
     var headnode;
     var putCloudapiIntoMaint = false;
@@ -4234,7 +5032,7 @@ SdcAdm.prototype.dcMaintStop = function dcMaintStop(opts, cb) {
     var progress = opts.progress || function () {};
 
     var headnode;
-    var sdcApp = self.sdc;
+    var sdcApp = self.sdcApp;
     var services = {};
     var disableCloudapiMaint = false;
     var disableDockerMaint = false;
@@ -4458,8 +5256,6 @@ SdcAdm.prototype.dcMaintStop = function dcMaintStop(opts, cb) {
 
 SdcAdm.prototype.checkConfig = function (opts, cb) {
     var self = this;
-    // SAPI values for sdc application:
-    var sdc = self.sdc.metadata;
     // Name of SAPI services for VMs:
     var services;
     // Headnode sysinfo:
@@ -4468,6 +5264,8 @@ SdcAdm.prototype.checkConfig = function (opts, cb) {
     var admin;
     var external;
 
+    var sdc;
+
     // Errors:
     var errs = [];
 
@@ -4490,7 +5288,8 @@ SdcAdm.prototype.checkConfig = function (opts, cb) {
                     errs.push('SAPI sdc admin_nic did not match with GZ ' +
                         'Admin MAC Address');
                 }
-                if (sysinfo['Network Interfaces'][k].ip4addr !== sdc.admin_ip) {
+                if (sysinfo['Network Interfaces'][k].ip4addr !==
+                    sdc.admin_ip) {
                     errs.push('SAPI sdc admin_ip did not match with GZ ' +
                         'Admin IPv4 Address');
                 }
@@ -4669,68 +5468,69 @@ SdcAdm.prototype.checkConfig = function (opts, cb) {
 
     }
 
-    self.sapi.listServices({
-        application_uuid: sdc.uuid
-    }, function (err2, res2) {
-        if (err2) {
-            return cb(err2);
-        }
-        if (!res2.length) {
-            return cb('Cannot find SDC services in SAPI');
-        }
-
-        services = res2.filter(function (s) {
-            return (s.type === 'vm');
-        }).map(function (s) {
-            return (s.name);
+    function getVmServiceNames(_, next) {
+        self.getServices({type: 'vm'}, function (err, svcs) {
+            if (err) {
+                next(err);
+                return;
+            }
+            services = svcs.filter(function (s) {
+                return s.type === 'vm';
+            }).map(function (s) {
+                return (s.name);
+            });
+            sdc = self.sdcApp.metadata;
+            next();
         });
+    }
 
-        vasync.pipeline({
-            funcs: [
-                getSysinfo,
-                getNetworks,
-                getDcFromUfds,
-                getUfdsAdmin,
-                getVmsIps
-            ]
-        }, function (err4, _res) {
-            if (err4) {
-                return cb(err4);
-            }
 
-            // PEDRO: Note the exceptions listed below. I bet we could
-            // remove most of these variables anyway, and left a single
-            // value for *_pw.
-            services.forEach(function (s) {
-                if (!sdc[s + '_root_pw'] && s !== 'manta' && s !== 'sapi') {
-                    errs.push(sprintf('Missing %s_root_pw in SAPI', s));
-                }
+    vasync.pipeline({
+        funcs: [
+            getVmServiceNames,
+            getSysinfo,
+            getNetworks,
+            getDcFromUfds,
+            getUfdsAdmin,
+            getVmsIps
+        ]
+    }, function (err4, _res) {
+        if (err4) {
+            return cb(err4);
+        }
 
-                if (!sdc[s + '_admin_ips'] && s !== 'cloudapi' &&
-                    s !== 'manta' && s !== 'sdcsso') {
-                    errs.push(sprintf('Missing %s_admin_ips in SAPI', s));
-                }
+        // PEDRO: Note the exceptions listed below. I bet we could
+        // remove most of these variables anyway, and left a single
+        // value for *_pw.
+        services.forEach(function (s) {
+            if (!sdc[s + '_root_pw'] && s !== 'manta' && s !== 'sapi') {
+                errs.push(sprintf('Missing %s_root_pw in SAPI', s));
+            }
 
-                if (s !== 'manatee' && s !== 'binder' &&
-                    s !== 'manta' && s !== 'cloudapi') {
-                    if (!sdc[s + '_domain']) {
-                        errs.push(sprintf('Missing %s_domain in SAPI', s));
-                    }
-                    if (!sdc[s.toUpperCase() + '_SERVICE']) {
-                        errs.push(sprintf('Missing %s_SERVICE in SAPI',
-                                s.toUpperCase()));
-                    }
+            if (!sdc[s + '_admin_ips'] && s !== 'cloudapi' &&
+                s !== 'manta' && s !== 'sdcsso') {
+                errs.push(sprintf('Missing %s_admin_ips in SAPI', s));
+            }
+
+            if (s !== 'manatee' && s !== 'binder' &&
+                s !== 'manta' && s !== 'cloudapi') {
+                if (!sdc[s + '_domain']) {
+                    errs.push(sprintf('Missing %s_domain in SAPI', s));
                 }
-            });
-            // Check that ufds_remote_ip is present if this is not master:
-            if (!sdc.ufds_is_master || sdc.ufds_is_master === 'false') {
-                if (!sdc.ufds_remote_ip) {
-                    errs.push('Missing SAPI variable "ufds_remote_ip"');
+                if (!sdc[s.toUpperCase() + '_SERVICE']) {
+                    errs.push(sprintf('Missing %s_SERVICE in SAPI',
+                            s.toUpperCase()));
                 }
             }
-            return self.ufds.close(function (err3) {
-                return cb(null, errs);
-            });
+        });
+        // Check that ufds_remote_ip is present if this is not master:
+        if (!sdc.ufds_is_master || sdc.ufds_is_master === 'false') {
+            if (!sdc.ufds_remote_ip) {
+                errs.push('Missing SAPI variable "ufds_remote_ip"');
+            }
+        }
+        return self.ufds.close(function (err3) {
+            return cb(null, errs);
         });
     });
 };
@@ -4864,6 +5664,10 @@ SdcAdm.prototype.checkHealth = function checkHealth(opts, cb) {
         if (opts.type) {
             svcOpts.type = opts.type;
         }
+
+        if (opts.json) {
+            svcOpts.json = opts.json;
+        }
         self.getServices(svcOpts, function (err, svcs) {
             if (err) {
                 if (!err.message) {  // TODO(trentm): why this?!
@@ -4906,6 +5710,10 @@ SdcAdm.prototype.checkHealth = function checkHealth(opts, cb) {
             svcOpts.types = [opts.type];
         }
 
+        if (opts.json) {
+            svcOpts.json = opts.json;
+        }
+
         self.listInsts(svcOpts, function (err, insts_) {
             if (err) {
                 if (!err.message) {
diff --git a/lib/steps/no-rabbit.js b/lib/steps/no-rabbit.js
index 3df7cfb..bd80a80 100644
--- a/lib/steps/no-rabbit.js
+++ b/lib/steps/no-rabbit.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2015, Joyent, Inc.
+ * Copyright 2017 Joyent, Inc.
  */
 
 /*
@@ -42,8 +42,8 @@ function noRabbitEnable(arg, callback) {
     var imgsFromSvcName = {};
     var MIN_NO_RABBIT_VERSION = '20150917';
 
-    if (arg.sdcadm.sdc.metadata.no_rabbit) {
-        log.debug({no_rabbit: arg.sdcadm.sdc.metadata.no_rabbit},
+    if (arg.sdcadm.sdcApp && arg.sdcadm.sdcApp.metadata.no_rabbit) {
+        log.debug({no_rabbit: arg.sdcadm.sdcApp.metadata.no_rabbit},
             'no_rabbit already enabled');
         return callback();
     }
@@ -51,6 +51,9 @@ function noRabbitEnable(arg, callback) {
     progress('\n--- enable the new agents (no_rabbit=true)');
 
     vasync.pipeline({arg: {}, funcs: [
+        function ensureSdcApp(_, next) {
+            arg.sdcadm.ensureSdcApp(next);
+        },
         function getVmImgs(ctx, next) {
             vasync.forEachParallel({
                 inputs: ['cnapi', 'workflow'],
@@ -128,7 +131,7 @@ function noRabbitEnable(arg, callback) {
                     no_rabbit: true
                 }
             };
-            sdcadm.sapi.updateApplication(sdcadm.sdc.uuid, update,
+            sdcadm.sapi.updateApplication(sdcadm.sdcApp.uuid, update,
                 errors.sdcClientErrWrap(next, 'sapi'));
         },
         function stopDatacenterMaint(ctx, next) {
diff --git a/lib/steps/sapi.js b/lib/steps/sapi.js
index bf7c6f3..584b301 100644
--- a/lib/steps/sapi.js
+++ b/lib/steps/sapi.js
@@ -49,7 +49,7 @@ function sapiEnsureAgentServices(arg, cb) {
     // We need at least a MIN_VALID_SAPI_VERSION image so
     // type=agent suport is there.
     var MIN_VALID_SAPI_VERSION = '20140703';
-    var app = sdcadm.sdc;
+    var app = sdcadm.sdcApp;
     var historyItem = null;
 
     var img;
