commit ebf55024af32a55f974082d61f765ef218ed0424
Author: Alex Wilson <alex.wilson@joyent.com>
Date:   2019-05-31T14:55:09-07:00 (4 months ago)
    
    MANTA-4305 want a waferlock that uses pg_hba.conf instead of ipfilter

diff --git a/Makefile b/Makefile
index 83ec1f3..9c7800e 100644
--- a/Makefile
+++ b/Makefile
@@ -112,6 +112,7 @@ release: all
 	mkdir -p $(RELSTAGEDIR)/root
 	mkdir -p $(RELSTAGEDIR)/root/$(PREFIX)/etc
 	cp	$(ROOT)/etc/ipf.conf \
+		$(ROOT)/etc/pg_hba.conf \
 		$(RELSTAGEDIR)/root/$(PREFIX)/etc
 	cp -r   $(ROOT)/lib \
 		$(ROOT)/server.js \
diff --git a/etc/config.json.example b/etc/config.json.example
index 2812541..0a5e11d 100644
--- a/etc/config.json.example
+++ b/etc/config.json.example
@@ -5,6 +5,12 @@
 			{"address": "127.0.0.1", "port": 2181}
 		]
 	},
+	"pg_hba": {
+		"path": "/manatee/pg/data/pg_hba.conf",
+		"pidFile": "/manatee/pg/data/postmaster.pid",
+		"statInterval": 5,
+		"hupInterval": 10
+	},
 	"holdTime": 30,
 	"paths": [
 		"/foo",
diff --git a/etc/pg_hba.conf b/etc/pg_hba.conf
new file mode 100644
index 0000000..00b496e
--- /dev/null
+++ b/etc/pg_hba.conf
@@ -0,0 +1,100 @@
+# PostgreSQL Client Authentication Configuration File
+# ===================================================
+#
+# Refer to the "Client Authentication" section in the PostgreSQL
+# documentation for a complete description of this file.  A short
+# synopsis follows.
+#
+# This file controls: which hosts are allowed to connect, how clients
+# are authenticated, which PostgreSQL user names they can use, which
+# databases they can access.  Records take one of these forms:
+#
+# local      DATABASE  USER  METHOD  [OPTIONS]
+# host       DATABASE  USER  ADDRESS  METHOD  [OPTIONS]
+# hostssl    DATABASE  USER  ADDRESS  METHOD  [OPTIONS]
+# hostnossl  DATABASE  USER  ADDRESS  METHOD  [OPTIONS]
+#
+# (The uppercase items must be replaced by actual values.)
+#
+# The first field is the connection type: "local" is a Unix-domain
+# socket, "host" is either a plain or SSL-encrypted TCP/IP socket,
+# "hostssl" is an SSL-encrypted TCP/IP socket, and "hostnossl" is a
+# plain TCP/IP socket.
+#
+# DATABASE can be "all", "sameuser", "samerole", "replication", a
+# database name, or a comma-separated list thereof. The "all"
+# keyword does not match "replication". Access to replication
+# must be enabled in a separate record (see example below).
+#
+# USER can be "all", a user name, a group name prefixed with "+", or a
+# comma-separated list thereof.  In both the DATABASE and USER fields
+# you can also write a file name prefixed with "@" to include names
+# from a separate file.
+#
+# ADDRESS specifies the set of hosts the record matches.  It can be a
+# host name, or it is made up of an IP address and a CIDR mask that is
+# an integer (between 0 and 32 (IPv4) or 128 (IPv6) inclusive) that
+# specifies the number of significant bits in the mask.  A host name
+# that starts with a dot (.) matches a suffix of the actual host name.
+# Alternatively, you can write an IP address and netmask in separate
+# columns to specify the set of hosts.  Instead of a CIDR-address, you
+# can write "samehost" to match any of the server's own IP addresses,
+# or "samenet" to match any address in any subnet that the server is
+# directly connected to.
+#
+# METHOD can be "trust", "reject", "md5", "password", "gss", "sspi",
+# "krb5", "ident", "peer", "pam", "ldap", "radius" or "cert".  Note that
+# "password" sends passwords in clear text; "md5" is preferred since
+# it sends encrypted passwords.
+#
+# OPTIONS are a set of options for the authentication in the format
+# NAME=VALUE.  The available options depend on the different
+# authentication methods -- refer to the "Client Authentication"
+# section in the documentation for a list of which options are
+# available for which authentication methods.
+#
+# Database and user names containing spaces, commas, quotes and other
+# special characters must be quoted.  Quoting one of the keywords
+# "all", "sameuser", "samerole" or "replication" makes the name lose
+# its special character, and just match a database or username with
+# that name.
+#
+# This file is read on server startup and when the postmaster receives
+# a SIGHUP signal.  If you edit the file on a running system, you have
+# to SIGHUP the postmaster for the changes to take effect.  You can
+# use "pg_ctl reload" to do that.
+
+# Put your actual configuration here
+# ----------------------------------
+#
+# If you want to allow non-local connections, you need to add more
+# "host" records.  In that case you will also need to make PostgreSQL
+# listen on a non-local interface via the listen_addresses
+# configuration parameter, or via the -i or -h command line switches.
+
+# CAUTION: Configuring the system for local "trust" authentication
+# allows any local user to connect as any PostgreSQL user, including
+# the database superuser.  If you do not trust all your local users,
+# use another authentication method.
+
+
+# TYPE  DATABASE        USER            ADDRESS                 METHOD
+
+# "local" is for Unix domain socket connections only
+local   all             all                                     trust
+local   replication     admin                                   trust
+# IPv4 local connections:
+host    all             all             127.0.0.1/32            trust
+# IPv6 local connections:
+host    all             all             ::1/128                 trust
+# Allow replication connections from localhost, by a user with the
+# replication privilege.
+host    replication     admin        127.0.0.1/32               trust
+host    replication     all          127.0.0.1/32               trust
+host    replication     admin        ::1/128                    trust
+
+# These are disabled while waferlock is in operation
+##host    replication     all          0.0.0.0/0                  trust
+##host    all             all          0.0.0.0/0                  trust
+
+# Lines below this point are automatically generated by waferlock
diff --git a/lib/pg_hba.js b/lib/pg_hba.js
new file mode 100644
index 0000000..1209be9
--- /dev/null
+++ b/lib/pg_hba.js
@@ -0,0 +1,286 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2018, Joyent, Inc.
+ */
+
+'use strict';
+
+var mod_assert = require('assert-plus');
+var mod_util = require('util');
+var mod_cproc = require('child_process');
+var mod_ipaddr = require('ipaddr.js');
+var mod_fs = require('fs');
+var mod_fsm = require('mooremachine');
+
+function PgHbaPool(options) {
+	mod_assert.object(options, 'options');
+	mod_assert.object(options.log, 'options.log');
+	mod_assert.number(options.hupInterval, 'options.hupInterval');
+	mod_assert.number(options.statInterval, 'options.statInterval');
+	mod_assert.number(options.holdTime, 'options.holdTime');
+	mod_assert.ok(options.baseText, 'options.baseText');
+	mod_assert.string(options.path, 'options.path');
+	mod_assert.string(options.pidFile, 'options.pidFile');
+
+	this.php_log = options.log.child({
+		component: 'PgHbaPool',
+		path: options.path
+	});
+	this.php_path = options.path;
+	this.php_statInterval = options.statInterval * 1000;
+	this.php_hupInterval = options.hupInterval * 1000;
+	this.php_hold = options.holdTime * 1000;
+	this.php_baseText = options.baseText;
+	if (typeof (this.php_baseText) === 'string')
+		this.php_baseText = new Buffer(this.php_baseText);
+	this.php_pidFile = options.pidFile;
+
+	this.php_addrs = {};
+	this.php_held = {};
+	this.php_tags = {};
+	this.php_timers = {};
+	this.php_lastWrite = Date.now();
+	this.php_lastSize = 0;
+	this.php_pid = null;
+	this.php_dirty = false;
+	this.php_stopping = false;
+
+	mod_fsm.FSM.call(this, 'stopped');
+}
+mod_util.inherits(PgHbaPool, mod_fsm.FSM);
+PgHbaPool.prototype.setDirty = function () {
+	this.php_dirty = true;
+	this.emit('dirty');
+};
+PgHbaPool.prototype.stop = function () {
+	this.php_stopping = true;
+	this.php_dirty = true;
+	this.emit('dirty');
+};
+PgHbaPool.prototype.state_stopped = function (S) {
+	S.gotoStateOn(this, 'start', 'waiting');
+};
+PgHbaPool.prototype.state_running = function (S) {
+	var self = this;
+	S.gotoStateOn(this, 'dirty', 'writing');
+	if (this.php_dirty) {
+		S.gotoState('writing');
+		return;
+	}
+	if (this.php_stopping) {
+		S.gotoState('stopped');
+		return;
+	}
+
+	S.interval(this.php_statInterval, function () {
+		mod_fs.stat(self.php_path, S.callback(function (err, stats) {
+			if (err || !stats.isFile()) {
+				self.php_log.debug(err,
+				    'failed to stat pg_hba.conf');
+				return;
+			}
+			var mtime = stats.mtime.getTime();
+			if (Math.abs(mtime - self.php_lastWrite) > 100 ||
+			    stats.size !== self.php_lastSize) {
+				S.gotoState('writing');
+			}
+		}));
+	});
+};
+PgHbaPool.prototype.state_waiting = function (S) {
+	var self = this;
+
+	this.php_log.debug('waiting for stat on pg_hba.conf to clear...');
+	S.interval(this.php_statInterval, function () {
+		mod_fs.stat(self.php_path, S.callback(function (err, stats) {
+			if (err || !stats.isFile()) {
+				self.php_log.debug(err,
+				    'failed to stat pg_hba.conf');
+				return;
+			}
+			S.gotoState('writing');
+		}));
+	});
+
+	S.on(this, 'dirty', function () {
+		if (self.php_stopping)
+			S.gotoState('stopped');
+	});
+};
+PgHbaPool.prototype.state_writing = function (S) {
+	var self = this;
+	var data = [this.php_baseText];
+	if (this.php_stopping) {
+		data.push(new Buffer(mod_util.format(
+		    'host  all  all  0.0.0.0/0  trust\n')));
+		data.push(new Buffer(mod_util.format(
+		    'host  replication  all  0.0.0.0/0  trust\n')));
+	} else {
+		for (var key in this.php_addrs) {
+			data.push(new Buffer(mod_util.format(
+			    'host  all  all  %s/32  trust\n', key)));
+			data.push(new Buffer(mod_util.format(
+			    'host  replication  all  %s/32  trust\n', key)));
+		}
+		for (key in this.php_held) {
+			data.push(new Buffer(mod_util.format(
+			    'host  all  all  %s/32  trust   # held\n', key)));
+			data.push(new Buffer(mod_util.format(
+			    'host  replication  all  %s/32  trust\n', key)));
+		}
+	}
+	data = Buffer.concat(data);
+	this.php_dirty = false;
+
+	mod_fs.writeFile(this.php_path, data, S.callback(function (err) {
+		if (err) {
+			self.php_log.warn(err, 'failed to write pg_hba.conf, ' +
+			    'will retry', self.php_path);
+			S.gotoState('waiting');
+			return;
+		}
+		self.php_log.debug('wrote new pg_hba.conf');
+		self.php_lastSize = data.length;
+		self.php_lastWrite = Date.now();
+		S.gotoState('findingPid');
+	}));
+};
+PgHbaPool.prototype.state_findingPid = function (S) {
+	var self = this;
+	mod_fs.readFile(this.php_pidFile, S.callback(function (err, data) {
+		if (err) {
+			self.php_log.error(err,
+			    'failed reading postmaster.pid');
+			S.gotoState('waiting');
+			return;
+		}
+		var lines = data.toString('ascii').split('\n');
+		self.php_pid = lines[0];
+		S.gotoState('hupping');
+	}));
+};
+PgHbaPool.prototype.state_hupping = function (S) {
+	var self = this;
+	this.php_log.debug('sending SIGHUP to postmaster (pid %s)',
+	    this.php_pid);
+	var args = ['-s', 'SIGHUP', self.php_pid];
+	mod_cproc.execFile('/usr/bin/kill', args, S.callback(
+	    function (err, _stdout, stderr) {
+		if (err) {
+			self.php_log.error(err, 'failed sending SIGHUP to ' +
+			    'postmaster (pid %s): %s', self.php_pid, stderr);
+			S.gotoState('waiting');
+			return;
+		}
+		self.emit('hupped');
+		S.gotoState('debouncing');
+	}));
+};
+PgHbaPool.prototype.state_debouncing = function (S) {
+	S.gotoStateTimeout(this.php_hupInterval, 'running');
+	if (this.php_stopping) {
+		S.gotoState('stopped');
+		return;
+	}
+};
+
+PgHbaPool.prototype.start = function () {
+	this.emit('start');
+};
+
+PgHbaPool.prototype.expire = function (key) {
+	if (this.php_stopping)
+		return;
+	delete (this.php_timers[key]);
+	delete (this.php_held[key]);
+	this.setDirty();
+};
+PgHbaPool.prototype.refreshTag = function (tag, addrs, cb) {
+	var self = this;
+
+	if (this.php_stopping)
+		return;
+
+	var keys = addrs.map(function (addr) {
+		var ipaddr = mod_ipaddr.parse(addr);
+		return (ipaddr.toNormalizedString());
+	});
+
+	var oldKeys = this.php_tags[tag];
+	if (oldKeys === undefined)
+		oldKeys = [];
+	this.php_tags[tag] = keys;
+
+	var added = keys.filter(function (k) {
+		return (oldKeys.indexOf(k) === -1);
+	});
+	var removed = oldKeys.filter(function (k) {
+		return (keys.indexOf(k) === -1);
+	});
+
+	var held = [];
+	removed.forEach(function (k) {
+		var tags = self.php_addrs[k];
+		mod_assert.arrayOfString(tags);
+		mod_assert.ok(tags.length > 0);
+		var idx = tags.indexOf(tag);
+		mod_assert.notStrictEqual(idx, -1);
+		tags.splice(idx, 1);
+		if (tags.length === 0) {
+			delete (self.php_addrs[k]);
+			held.push(k);
+		}
+	});
+
+	if (held.length > 0) {
+		var now = (new Date()).getTime();
+		var expiry = Math.ceil((now + this.php_hold) / 5000) * 5000;
+		var timeout = expiry - now;
+
+		held.forEach(function (k) {
+			mod_assert.strictEqual(self.php_timers[k], undefined);
+			self.php_timers[k] = setTimeout(
+			    self.expire.bind(self, k), timeout);
+			self.php_held[k] = true;
+		});
+
+		self.php_log.debug({ addrs: held, tag: tag }, 'holding %d ' +
+		    'addresses for %d ms', held.length, timeout);
+	}
+
+	var news = [];
+	added.forEach(function (k) {
+		var timer = self.php_timers[k];
+		if (timer !== undefined) {
+			clearTimeout(timer);
+			delete (self.php_timers[k]);
+			delete (self.php_held[k]);
+			mod_assert.strictEqual(self.php_addrs[k], undefined);
+			self.php_addrs[k] = [tag];
+			return;
+		}
+		var tags = self.php_addrs[k];
+		if (tags === undefined) {
+			tags = (self.php_addrs[k] = []);
+			news.push(k);
+		}
+		tags.push(tag);
+	});
+
+	if (news.length > 0) {
+		self.php_log.debug({ addrs: news, tag: tag },
+		    'adding new addresses');
+		this.setDirty();
+	}
+	if (cb)
+		setImmediate(cb);
+};
+
+module.exports = {
+	PgHbaPool: PgHbaPool
+};
diff --git a/package.json b/package.json
index f7637b8..0dde50b 100644
--- a/package.json
+++ b/package.json
@@ -26,7 +26,7 @@
     "ipaddr.js": "^1.7.0",
     "lstream": "0.0.4",
     "mooremachine": "^2.2.1",
-    "restify-clients": "^2.2.0",
+    "restify-clients": "2.2.0",
     "vasync": "^2.2.0",
     "verror": "^1.10.0",
     "zkstream": "^0.11.2"
diff --git a/sapi_manifests/waferlock/template b/sapi_manifests/waferlock/template
index 73334da..6cea847 100644
--- a/sapi_manifests/waferlock/template
+++ b/sapi_manifests/waferlock/template
@@ -9,6 +9,13 @@
 		]
 	},
 
+	"pg_hba": {
+		"path": "/manatee/pg/data/pg_hba.conf",
+		"pidFile": "/manatee/pg/data/postmaster.pid",
+		"statInterval": 5,
+		"hupInterval": 10
+	},
+
 	"holdTime": 600,
 
 	{{! The SAPI polling interval can be shortened when ipmon shows
diff --git a/server.js b/server.js
index fa6336a..5951e31 100644
--- a/server.js
+++ b/server.js
@@ -11,7 +11,6 @@
 'use strict';
 
 var mod_assert = require('assert-plus');
-var mod_verror = require('verror');
 var mod_bunyan = require('bunyan');
 var mod_fs = require('fs');
 var mod_util = require('util');
@@ -20,10 +19,8 @@ var mod_fsm = require('mooremachine');
 var mod_cueball = require('cueball');
 var mod_url = require('url');
 
-var lib_ipf = require('./lib/ipf');
-var Ipf = lib_ipf.Ipf;
-var IpfPool = lib_ipf.IpfPool;
-var IpMon = lib_ipf.IpMon;
+var lib_pghba = require('./lib/pg_hba');
+var PgHbaPool = lib_pghba.PgHbaPool;
 
 var lib_zk = require('./lib/zk');
 var ZKCache = lib_zk.ZKCache;
@@ -31,11 +28,9 @@ var ZKCache = lib_zk.ZKCache;
 var lib_sapi = require('./lib/sapi');
 var SapiPoller = lib_sapi.SapiPoller;
 
-var VError = mod_verror.VError;
-
 var confDir = mod_path.join(__dirname, 'etc');
 var confFile = mod_path.join(confDir, 'config.json');
-var ipfConfigFile = mod_path.join(confDir, 'ipf.conf');
+var pgHbaBaseFile = mod_path.join(confDir, 'pg_hba.conf');
 var config = JSON.parse(mod_fs.readFileSync(confFile, 'utf-8'));
 
 mod_assert.object(config, 'config');
@@ -49,6 +44,11 @@ mod_assert.number(config.sapiPollingInterval.min,
 mod_assert.number(config.sapiPollingInterval.max,
     'config.sapiPollingInterval.max');
 mod_assert.optionalString(config.shard, 'config.shard');
+mod_assert.object(config.pg_hba, 'config.pg_hba');
+mod_assert.string(config.pg_hba.path, 'config.pg_hba.path');
+mod_assert.string(config.pg_hba.pidFile, 'config.pg_hba.pidFile');
+mod_assert.number(config.pg_hba.statInterval, 'config.pg_hba.statInterval');
+mod_assert.number(config.pg_hba.hupInterval, 'config.pg_hba.hupInterval');
 
 mod_assert.optionalArrayOfString(config.paths, 'config.paths');
 mod_assert.optionalArrayOfString(config.domains, 'config.domains');
@@ -77,6 +77,7 @@ function AppFSM() {
 	this.af_denials = {};
 	this.af_log = log;
 	this.af_sapis = {};
+	this.af_pgHbaBase = null;
 
 	var agopts = {
 		spares: 1,
@@ -107,50 +108,33 @@ function AppFSM() {
 mod_util.inherits(AppFSM, mod_fsm.FSM);
 
 AppFSM.prototype.state_init = function (S) {
-	var self = this;
-	Ipf.flushAll(S.callback(function (err) {
-		if (err && err.name === 'IpfDisabledError') {
-			S.gotoState('enableIpf');
-			return;
-		}
-		if (err) {
-			self.af_err = new VError(
-			    { cause: err, name: 'IpfFlushError' },
-			    'failed to flush ipf rules');
-			S.gotoState('fatal');
-			return;
-		}
-		S.gotoState('setupPool');
-	}));
+	S.gotoState('readPgHbaBaseFile');
 };
 
-AppFSM.prototype.state_enableIpf = function (S) {
+AppFSM.prototype.state_readPgHbaBaseFile = function (S) {
 	var self = this;
-	Ipf.enable(S.callback(function (err) {
+	mod_fs.readFile(pgHbaBaseFile, S.callback(function (err, data) {
 		if (err) {
 			self.af_err = err;
 			S.gotoState('fatal');
 			return;
 		}
+		self.af_pgHbaBase = data;
 		S.gotoState('setupPool');
 	}));
 };
 
 AppFSM.prototype.state_setupPool = function (S) {
-	var self = this;
-	this.af_pool = new IpfPool({
+	this.af_pool = new PgHbaPool({
 		log: log,
-		name: '100',
-		holdTime: config.holdTime
+		statInterval: config.pg_hba.statInterval,
+		hupInterval: config.pg_hba.hupInterval,
+		path: config.pg_hba.path,
+		pidFile: config.pg_hba.pidFile,
+		holdTime: config.holdTime,
+		baseText: this.af_pgHbaBase
 	});
-	this.af_pool.init(S.callback(function (err) {
-		if (err) {
-			self.af_err = err;
-			S.gotoState('fatal');
-			return;
-		}
-		S.gotoState('setupCache');
-	}));
+	S.gotoState('setupCache');
 };
 
 AppFSM.prototype.state_setupCache = function (S) {
@@ -213,59 +197,12 @@ AppFSM.prototype.state_setupSapi = function (S) {
 };
 
 AppFSM.prototype.state_loadRules = function (S) {
-	var self = this;
-	Ipf.loadRulesFile(ipfConfigFile, S.callback(function (err) {
-		if (err) {
-			self.af_err = err;
-			S.gotoState('fatal');
-			return;
-		}
-		S.gotoState('enforcing');
-	}));
+	S.gotoStateOn(this.af_pool, 'hupped', 'enforcing');
+	this.af_pool.start();
 };
 
-/* eslint-disable */
-/* JSSTYLED */
-var TUPLE_RE = / ([0-9]+\.[0-9]+\.[0-9]+\.[0-9]+),([0-9]+) -> ([0-9]+\.[0-9]+\.[0-9]+\.[0-9]+),([0-9]+) /;
-/* eslint-enable */
-
-AppFSM.prototype.state_enforcing = function (S) {
-	var self = this;
-	this.af_log.info('ipf rules loaded, now enforcing');
-	this.af_mon = new IpMon({
-		log: log
-	});
-	S.on(this.af_mon, 'line', function (line) {
-		var m = TUPLE_RE.exec(line);
-		if (!m) {
-			self.af_log.trace({ ipmonLine: line }, 'unparseable ' +
-			    'ipmon output line');
-			return;
-		}
-		var fromIp = m[1];
-		var fromPort = parseInt(m[2], 10);
-		var toIp = m[3];
-		var toPort = parseInt(m[4], 10);
-		if (typeof (fromPort) !== 'number' || !isFinite(fromPort) ||
-		    typeof (toPort) !== 'number' || !isFinite(toPort)) {
-			return;
-		}
-		var ds = self.af_denials[fromIp];
-		if (ds === undefined) {
-			ds = (self.af_denials[fromIp] = {});
-			Object.keys(self.af_sapis).forEach(function (k) {
-				self.af_sapis[k].trigger();
-			});
-		}
-		if (ds[toPort] === undefined) {
-			self.af_log.debug({ fromIp: fromIp, fromPort: fromPort,
-			    toIp: toIp, toPort: toPort },
-			    'denied access from %s to port %d',
-			    fromIp, toPort);
-			ds[toPort] = 0;
-		}
-		ds[toPort]++;
-	});
+AppFSM.prototype.state_enforcing = function (_S) {
+	this.af_log.info('pg_hba.conf reloaded, now enforcing');
 };
 
 AppFSM.prototype.state_fatal = function (S) {
@@ -277,11 +214,18 @@ AppFSM.prototype.state_fatal = function (S) {
 var app = new AppFSM();
 
 function disableIpfAndExit() {
-	if (app.af_mon && app.af_mon.isInState('running'))
-		app.af_mon.stop();
-	Ipf.disable(function () {
+	if (app.af_pool && !app.af_pool.isInState('stopped')) {
+		log.info('shutting down pool, writing permissive pg_hba.conf');
+		app.af_pool.on('stateChanged', function (st) {
+			if (st === 'stopped') {
+				log.info('shut down');
+				process.exit(0);
+			}
+		});
+		app.af_pool.stop();
+	} else {
 		process.exit(0);
-	});
+	}
 }
 process.on('SIGINT', disableIpfAndExit);
 process.on('SIGTERM', disableIpfAndExit);
