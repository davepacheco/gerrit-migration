commit ad4740c4d20fa19190ec9b5f5c5eaf3bdbbc1719
Author: Alex Wilson <alex.wilson@joyent.com>
Date:   2019-05-31T16:11:14-07:00 (4 months ago)
    
    MANTA-4305 want a waferlock that uses pg_hba.conf instead of ipfilter

diff --git a/Makefile b/Makefile
index 83ec1f3..3e91074 100644
--- a/Makefile
+++ b/Makefile
@@ -111,7 +111,7 @@ release: all
 	touch $(RELSTAGEDIR)/site/.do-not-delete-me
 	mkdir -p $(RELSTAGEDIR)/root
 	mkdir -p $(RELSTAGEDIR)/root/$(PREFIX)/etc
-	cp	$(ROOT)/etc/ipf.conf \
+	cp	$(ROOT)/etc/pg_hba.conf \
 		$(RELSTAGEDIR)/root/$(PREFIX)/etc
 	cp -r   $(ROOT)/lib \
 		$(ROOT)/server.js \
diff --git a/etc/config.json.example b/etc/config.json.example
index 2812541..0a5e11d 100644
--- a/etc/config.json.example
+++ b/etc/config.json.example
@@ -5,6 +5,12 @@
 			{"address": "127.0.0.1", "port": 2181}
 		]
 	},
+	"pg_hba": {
+		"path": "/manatee/pg/data/pg_hba.conf",
+		"pidFile": "/manatee/pg/data/postmaster.pid",
+		"statInterval": 5,
+		"hupInterval": 10
+	},
 	"holdTime": 30,
 	"paths": [
 		"/foo",
diff --git a/etc/ipf.conf b/etc/ipf.conf
deleted file mode 100644
index 0741bf2..0000000
--- a/etc/ipf.conf
+++ /dev/null
@@ -1,24 +0,0 @@
-#
-# This Source Code Form is subject to the terms of the Mozilla Public
-# License, v. 2.0. If a copy of the MPL was not distributed with this
-# file, You can obtain one at http://mozilla.org/MPL/2.0/.
-#
-# Copyright (c) 2018, Joyent, Inc.
-#
-
-#
-# output rules
-#
-pass out quick proto tcp from any to any flags S/SA keep state
-pass out proto tcp from any to any
-pass out proto udp from any to any keep state
-pass out quick proto icmp from any to any keep state
-pass out proto icmp from any to any
-
-#
-# input rules
-#
-pass in quick proto icmp from any to any keep frags
-pass in quick proto udp from any to any keep frags
-pass in quick proto tcp from pool/100 to any keep frags
-block in log all
diff --git a/etc/pg_hba.conf b/etc/pg_hba.conf
new file mode 100644
index 0000000..2f643b6
--- /dev/null
+++ b/etc/pg_hba.conf
@@ -0,0 +1,29 @@
+# PostgreSQL Client Authentication Configuration File
+# ===================================================
+#
+# This configuration file is being managed by the "waferlock" service on this
+# machine.
+#
+# Any edits or changes you make by hand will be undone by waferlock.
+#
+
+# TYPE  DATABASE        USER            ADDRESS                 METHOD
+
+# "local" is for Unix domain socket connections only
+local   all             all                                     trust
+local   replication     admin                                   trust
+# IPv4 local connections:
+host    all             all             127.0.0.1/32            trust
+# IPv6 local connections:
+host    all             all             ::1/128                 trust
+# Allow replication connections from localhost, by a user with the
+# replication privilege.
+host    replication     admin        127.0.0.1/32               trust
+host    replication     all          127.0.0.1/32               trust
+host    replication     admin        ::1/128                    trust
+
+# These are disabled while waferlock is in operation
+##host    replication     all          0.0.0.0/0                  trust
+##host    all             all          0.0.0.0/0                  trust
+
+# Lines below this point are automatically generated by the PgHbaPool
diff --git a/lib/ipf.js b/lib/ipf.js
deleted file mode 100644
index 5a9f6d9..0000000
--- a/lib/ipf.js
+++ /dev/null
@@ -1,347 +0,0 @@
-/*
- * This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/.
- */
-
-/*
- * Copyright (c) 2018, Joyent, Inc.
- */
-
-'use strict';
-
-var mod_assert = require('assert-plus');
-var mod_vasync = require('vasync');
-var mod_verror = require('verror');
-var mod_forkexec = require('forkexec');
-var mod_util = require('util');
-var mod_ipaddr = require('ipaddr.js');
-var mod_cproc = require('child_process');
-var mod_lstream = require('lstream');
-var mod_fsm = require('mooremachine');
-
-var VError = mod_verror.VError;
-
-var Ipf = {};
-Ipf.flushAll = function (cb) {
-	mod_forkexec.forkExecWait({
-		argv: ['pfexec', 'ipf', '-F', 'a']
-	}, function (err, info) {
-		if (info.status === 1 &&
-		    info.stderr.indexOf('I/O error') !== -1) {
-			err = new VError({ cause: err,
-			    name: 'IpfDisabledError' }, 'ipf is disabled');
-			cb(err);
-			return;
-		}
-		if (info.status !== 0) {
-			cb(err);
-			return;
-		}
-		cb();
-	});
-};
-Ipf.enable = function (cb) {
-	mod_forkexec.forkExecWait({
-		argv: ['pfexec', 'ipf', '-E']
-	}, cb);
-};
-Ipf.disable = function (cb) {
-	mod_forkexec.forkExecWait({
-		argv: ['pfexec', 'ipf', '-D']
-	}, cb);
-};
-Ipf.loadRulesFile = function (path, cb) {
-	mod_forkexec.forkExecWait({
-		argv: ['pfexec', 'ipf', '-I', '-f', path, '-s']
-	}, cb);
-};
-
-function IpMon(options) {
-	mod_assert.object(options, 'options');
-	mod_assert.object(options.log, 'options.log');
-
-	this.im_kid = undefined;
-	this.im_log = options.log.child({
-		component: 'IpMon'
-	});
-	this.im_outls = new mod_lstream();
-	this.im_errls = new mod_lstream();
-
-	mod_fsm.FSM.call(this, 'spawning');
-}
-mod_util.inherits(IpMon, mod_fsm.FSM);
-
-IpMon.prototype.state_spawning = function (S) {
-	var self = this;
-
-	var opts = {};
-	opts.env = {};
-	try {
-		this.im_kid = mod_cproc.spawn('pfexec', ['ipmon', '-p'], opts);
-	} catch (e) {
-		this.im_lastError = new VError(e,
-		    'failed to spawn ipmon command');
-		S.gotoState('error');
-		return;
-	}
-
-	S.on(this.im_kid, 'error', function (err) {
-		self.im_lastError = new VError(err, 'ipmon command failed');
-		self.gotoState('error');
-	});
-
-	this.im_kid.stderr.pipe(this.im_errls);
-	this.im_kid.stdout.pipe(this.im_outls);
-
-	S.on(this.im_errls, 'line', function (line) {
-		self.im_lastError = new VError(new Error(line), 'ipmon ' +
-		    'command error');
-		S.gotoState('error');
-	});
-
-	S.on(this.im_outls, 'line', function () {
-		S.gotoState('running');
-	});
-
-	S.on(this.im_kid, 'close', function (code) {
-		self.im_lastError = new VError('ipmon command exited ' +
-		    'unexpectedly with error code %d', code);
-		S.gotoState('error');
-	});
-};
-
-IpMon.prototype.state_running = function (S) {
-	var self = this;
-
-	S.on(this.im_kid, 'error', function (err) {
-		self.im_lastError = new VError(err, 'ipmon command failed');
-		self.gotoState('error');
-	});
-
-	S.on(this.im_errls, 'line', function (line) {
-		self.im_lastError = new VError(new Error(line), 'ipmon ' +
-		    'command error');
-		S.gotoState('error');
-	});
-
-	S.on(this.im_outls, 'readable', function () {
-		var line;
-		while ((line = self.im_outls.read()) !== null) {
-			self.emit('line', line);
-		}
-	});
-
-	S.on(this.im_kid, 'close', function (code) {
-		if (code !== 0) {
-			self.im_lastError = new VError('ipmon command exited ' +
-			    'unexpectedly with error code %d', code);
-			S.gotoState('error');
-		} else {
-			S.gotoState('stopped');
-		}
-	});
-
-	S.on(this, 'stopAsserted', function () {
-		S.gotoState('stopping');
-	});
-};
-
-IpMon.prototype.state_stopping = function (S) {
-	S.on(this.im_kid, 'error', function (_err) {
-	});
-	S.on(this.im_kid, 'close', function (_code) {
-		S.gotoState('stopped');
-	});
-	this.im_kid.kill();
-};
-
-IpMon.prototype.stop = function () {
-	mod_assert.ok(this.isInState('running'));
-	this.emit('stopAsserted');
-};
-
-IpMon.prototype.state_stopped = function (S) {
-	S.validTransitions([]);
-};
-
-IpMon.prototype.state_error = function (S) {
-	S.validTransitions([]);
-	this.emit('error', this.im_lastError);
-	this.im_kid.kill();
-};
-
-function IpfPool(options) {
-	mod_assert.object(options, 'options');
-	mod_assert.object(options.log, 'options.log');
-	mod_assert.string(options.name, 'options.name');
-	mod_assert.number(options.holdTime, 'options.holdTime');
-
-	this.ipp_log = options.log.child({
-		component: 'IpfPool',
-		pool: options.name
-	});
-	this.ipp_name = options.name;
-	this.ipp_hold = options.holdTime * 1000;
-	this.ipp_addrs = {};
-	this.ipp_tags = {};
-	this.ipp_timers = {};
-}
-IpfPool.prototype.init = function (cb) {
-	var self = this;
-	this.ipp_log.info('setting up ipf pool');
-	IpfPool.create(this.ipp_name, 'tree', function (err) {
-		if (err && err.name === 'PoolExistsError') {
-			IpfPool.destroy(self.ipp_name, 'tree', function (err2) {
-				if (err2) {
-					cb(err2);
-					return;
-				}
-				IpfPool.create(self.ipp_name, 'tree', cb);
-			});
-			return;
-		}
-		cb(err);
-	});
-};
-IpfPool.prototype.expire = function (key) {
-	var self = this;
-	delete (this.ipp_timers[key]);
-	IpfPool.removeMask(this.ipp_name, key, function (err) {
-		if (err) {
-			self.ipp_log.error(err, 'failed to remove expiring ip');
-			return;
-		}
-		self.ipp_log.debug('expired address %s', key);
-	});
-};
-IpfPool.prototype.refreshTag = function (tag, addrs, cb) {
-	var self = this;
-
-	var keys = addrs.map(function (addr) {
-		var ipaddr = mod_ipaddr.parse(addr);
-		return (ipaddr.toNormalizedString());
-	});
-
-	var oldKeys = this.ipp_tags[tag];
-	if (oldKeys === undefined)
-		oldKeys = [];
-	this.ipp_tags[tag] = keys;
-
-	var added = keys.filter(function (k) {
-		return (oldKeys.indexOf(k) === -1);
-	});
-	var removed = oldKeys.filter(function (k) {
-		return (keys.indexOf(k) === -1);
-	});
-
-	var held = [];
-	removed.forEach(function (k) {
-		var tags = self.ipp_addrs[k];
-		mod_assert.arrayOfString(tags);
-		mod_assert.ok(tags.length > 0);
-		var idx = tags.indexOf(tag);
-		mod_assert.notStrictEqual(idx, -1);
-		tags.splice(idx, 1);
-		if (tags.length === 0) {
-			delete (self.ipp_addrs[k]);
-			held.push(k);
-		}
-	});
-
-	if (held.length > 0) {
-		var now = (new Date()).getTime();
-		var expiry = Math.ceil((now + this.ipp_hold) / 5000) * 5000;
-		var timeout = expiry - now;
-
-		held.forEach(function (k) {
-			mod_assert.strictEqual(self.ipp_timers[k], undefined);
-			self.ipp_timers[k] = setTimeout(
-			    self.expire.bind(self, k), timeout);
-		});
-
-		self.ipp_log.debug({ addrs: held, tag: tag }, 'holding %d ' +
-		    'addresses for %d ms', held.length, timeout);
-	}
-
-	var news = [];
-	added.forEach(function (k) {
-		var timer = self.ipp_timers[k];
-		if (timer !== undefined) {
-			clearTimeout(timer);
-			delete (self.ipp_timers[k]);
-			mod_assert.strictEqual(self.ipp_addrs[k], undefined);
-			self.ipp_addrs[k] = [tag];
-			return;
-		}
-		var tags = self.ipp_addrs[k];
-		if (tags === undefined) {
-			tags = (self.ipp_addrs[k] = []);
-			news.push(k);
-		}
-		tags.push(tag);
-	});
-
-	if (news.length > 0) {
-		self.ipp_log.debug({ addrs: news, tag: tag },
-		    'adding new addresses');
-		mod_vasync.forEachPipeline({
-			inputs: news,
-			func: function (k, ccb) {
-				IpfPool.addMask(self.ipp_name, k, ccb);
-			}
-		}, function (err, res) {
-			if (cb)
-				cb(err);
-		});
-	} else if (cb) {
-		setImmediate(cb);
-	}
-};
-
-IpfPool.create = function (name, type, cb) {
-	mod_forkexec.forkExecWait({
-		argv: [
-			'pfexec', 'ippool', '-A', '-o', 'ipf', '-t', type,
-			'-m', name
-		]
-	}, function (err, info) {
-		if (info.status === 255 &&
-		    info.stderr.indexOf(': File exists') !== -1) {
-			err = new VError({ cause: err,
-			    name: 'PoolExistsError' },
-			    'pool "%s" already exists', name);
-			cb(err);
-			return;
-		}
-		if (info.status !== 0) {
-			cb(err);
-			return;
-		}
-		cb();
-	});
-};
-IpfPool.destroy = function (name, type, cb) {
-	mod_forkexec.forkExecWait({
-		argv: [
-			'pfexec', 'ippool', '-R', '-o', 'ipf', '-t', type,
-			'-m', name
-		]
-	}, cb);
-};
-IpfPool.addMask = function (name, addr, cb) {
-	mod_forkexec.forkExecWait({
-		argv: ['pfexec', 'ippool', '-a', '-m', name, '-i', addr]
-	}, cb);
-};
-IpfPool.removeMask = function (name, addr, cb) {
-	mod_forkexec.forkExecWait({
-		argv: ['pfexec', 'ippool', '-r', '-m', name, '-i', addr]
-	}, cb);
-};
-
-module.exports = {
-	Ipf: Ipf,
-	IpfPool: IpfPool,
-	IpMon: IpMon
-};
diff --git a/lib/pg_hba.js b/lib/pg_hba.js
new file mode 100644
index 0000000..81c015d
--- /dev/null
+++ b/lib/pg_hba.js
@@ -0,0 +1,283 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright 2019 Joyent, Inc.
+ */
+
+'use strict';
+
+var mod_assert = require('assert-plus');
+var mod_util = require('util');
+var mod_ipaddr = require('ipaddr.js');
+var mod_fs = require('fs');
+var mod_fsm = require('mooremachine');
+
+function PgHbaPool(options) {
+	mod_assert.object(options, 'options');
+	mod_assert.object(options.log, 'options.log');
+	mod_assert.number(options.hupInterval, 'options.hupInterval');
+	mod_assert.number(options.statInterval, 'options.statInterval');
+	mod_assert.number(options.holdTime, 'options.holdTime');
+	mod_assert.string(options.baseText, 'options.baseText');
+	mod_assert.string(options.path, 'options.path');
+	mod_assert.string(options.pidFile, 'options.pidFile');
+
+	this.php_log = options.log.child({
+		component: 'PgHbaPool',
+		path: options.path
+	});
+	this.php_path = options.path;
+	this.php_statInterval = options.statInterval * 1000;
+	this.php_hupInterval = options.hupInterval * 1000;
+	this.php_hold = options.holdTime * 1000;
+	this.php_baseText = options.baseText;
+	this.php_pidFile = options.pidFile;
+
+	this.php_addrs = {};
+	this.php_held = {};
+	this.php_tags = {};
+	this.php_timers = {};
+	this.php_lastWrite = Date.now();
+	this.php_lastSize = 0;
+	this.php_pid = null;
+	this.php_dirty = false;
+	this.php_stopping = false;
+
+	mod_fsm.FSM.call(this, 'stopped');
+}
+mod_util.inherits(PgHbaPool, mod_fsm.FSM);
+PgHbaPool.prototype.setDirty = function () {
+	this.php_dirty = true;
+	this.emit('dirty');
+};
+PgHbaPool.prototype.stop = function () {
+	this.php_stopping = true;
+	this.php_dirty = true;
+	this.emit('dirty');
+};
+PgHbaPool.prototype.state_stopped = function (S) {
+	S.gotoStateOn(this, 'start', 'waiting');
+};
+PgHbaPool.prototype.state_running = function (S) {
+	var self = this;
+	S.gotoStateOn(this, 'dirty', 'writing');
+	if (this.php_dirty) {
+		S.gotoState('writing');
+		return;
+	}
+	if (this.php_stopping) {
+		S.gotoState('stopped');
+		return;
+	}
+
+	S.interval(this.php_statInterval, function () {
+		mod_fs.stat(self.php_path, S.callback(function (err, stats) {
+			if (err || !stats.isFile()) {
+				self.php_log.debug(err,
+				    'failed to stat pg_hba.conf');
+				return;
+			}
+			var mtime = stats.mtime.getTime();
+			if (Math.abs(mtime - self.php_lastWrite) > 100 ||
+			    stats.size !== self.php_lastSize) {
+				S.gotoState('writing');
+			}
+		}));
+	});
+};
+PgHbaPool.prototype.state_waiting = function (S) {
+	var self = this;
+
+	this.php_log.debug('waiting for stat on pg_hba.conf to clear...');
+	S.interval(this.php_statInterval, function () {
+		mod_fs.stat(self.php_path, S.callback(function (err, stats) {
+			if (err || !stats.isFile()) {
+				self.php_log.debug(err,
+				    'failed to stat pg_hba.conf');
+				return;
+			}
+			S.gotoState('writing');
+		}));
+	});
+
+	S.on(this, 'dirty', function () {
+		if (self.php_stopping)
+			S.gotoState('stopped');
+	});
+};
+PgHbaPool.prototype.state_writing = function (S) {
+	var self = this;
+	var data = this.php_baseText;
+	if (this.php_stopping) {
+		data += 'host  all  all  0.0.0.0/0  trust\n';
+		data += 'host  replication  all  0.0.0.0/0  trust\n';
+	} else {
+		for (var key in this.php_addrs) {
+			data += mod_util.format(
+			    'host  all  all  %s/32  trust\n', key);
+			data += mod_util.format(
+			    'host  replication  all  %s/32  trust\n', key);
+		}
+		for (key in this.php_held) {
+			data += mod_util.format(
+			    'host  all  all  %s/32  trust\n', key);
+			data += mod_util.format(
+			    'host  replication  all  %s/32  trust\n', key);
+		}
+	}
+	this.php_dirty = false;
+
+	mod_fs.writeFile(this.php_path, data, S.callback(function (err) {
+		if (err) {
+			self.php_log.warn(err, 'failed to write pg_hba.conf, ' +
+			    'will retry', self.php_path);
+			S.gotoState('waiting');
+			return;
+		}
+		self.php_log.debug('wrote new pg_hba.conf');
+		self.php_lastSize = data.length;
+		self.php_lastWrite = Date.now();
+		S.gotoState('findingPid');
+	}));
+};
+PgHbaPool.prototype.state_findingPid = function (S) {
+	var self = this;
+	mod_fs.readFile(this.php_pidFile, S.callback(function (err, data) {
+		if (err) {
+			self.php_log.error(err,
+			    'failed reading postmaster.pid');
+			S.gotoState('waiting');
+			return;
+		}
+		var lines = data.toString('ascii').split('\n');
+		if (/[^0-9]/.test(lines[0])) {
+			self.php_log.error('failed parsing postmaster.pid: ' +
+			    'first line is not a number');
+			S.gotoState('waiting');
+			return;
+		}
+		self.php_pid = parseInt(lines[0], 10);
+		S.gotoState('hupping');
+	}));
+};
+PgHbaPool.prototype.state_hupping = function (S) {
+	this.php_log.debug('sending SIGHUP to postmaster (pid %d)',
+	    this.php_pid);
+	try {
+		process.kill(this.php_pid, 'SIGHUP');
+	} catch (err) {
+		this.php_log.error(err, 'failed sending SIGHUP to ' +
+		    'postmaster (pid %d)', this.php_pid);
+		S.gotoState('waiting');
+		return;
+	}
+	setImmediate(this.emit.bind(this, 'hupped'));
+	S.gotoState('debouncing');
+};
+PgHbaPool.prototype.state_debouncing = function (S) {
+	S.gotoStateTimeout(this.php_hupInterval, 'running');
+	if (this.php_stopping) {
+		S.gotoState('stopped');
+		return;
+	}
+};
+
+PgHbaPool.prototype.start = function () {
+	this.emit('start');
+};
+
+PgHbaPool.prototype.expire = function (key) {
+	if (this.php_stopping)
+		return;
+	delete (this.php_timers[key]);
+	delete (this.php_held[key]);
+	this.setDirty();
+};
+PgHbaPool.prototype.refreshTag = function (tag, addrs, cb) {
+	var self = this;
+
+	if (this.php_stopping)
+		return;
+
+	var keys = addrs.map(function (addr) {
+		var ipaddr = mod_ipaddr.parse(addr);
+		return (ipaddr.toNormalizedString());
+	});
+
+	var oldKeys = this.php_tags[tag];
+	if (oldKeys === undefined)
+		oldKeys = [];
+	this.php_tags[tag] = keys;
+
+	var added = keys.filter(function (k) {
+		return (oldKeys.indexOf(k) === -1);
+	});
+	var removed = oldKeys.filter(function (k) {
+		return (keys.indexOf(k) === -1);
+	});
+
+	var held = [];
+	removed.forEach(function (k) {
+		var tags = self.php_addrs[k];
+		mod_assert.arrayOfString(tags);
+		mod_assert.ok(tags.length > 0);
+		var idx = tags.indexOf(tag);
+		mod_assert.notStrictEqual(idx, -1);
+		tags.splice(idx, 1);
+		if (tags.length === 0) {
+			delete (self.php_addrs[k]);
+			held.push(k);
+		}
+	});
+
+	if (held.length > 0) {
+		var now = Date.now();
+		var expiry = Math.ceil((now + this.php_hold) / 5000) * 5000;
+		var timeout = expiry - now;
+
+		held.forEach(function (k) {
+			mod_assert.strictEqual(self.php_timers[k], undefined);
+			self.php_timers[k] = setTimeout(
+			    self.expire.bind(self, k), timeout);
+			self.php_held[k] = true;
+		});
+
+		self.php_log.debug({ addrs: held, tag: tag }, 'holding %d ' +
+		    'addresses for %d ms', held.length, timeout);
+	}
+
+	var news = [];
+	added.forEach(function (k) {
+		var timer = self.php_timers[k];
+		if (timer !== undefined) {
+			clearTimeout(timer);
+			delete (self.php_timers[k]);
+			delete (self.php_held[k]);
+			mod_assert.strictEqual(self.php_addrs[k], undefined);
+			self.php_addrs[k] = [tag];
+			return;
+		}
+		var tags = self.php_addrs[k];
+		if (tags === undefined) {
+			tags = (self.php_addrs[k] = []);
+			news.push(k);
+		}
+		tags.push(tag);
+	});
+
+	if (news.length > 0) {
+		self.php_log.debug({ addrs: news, tag: tag },
+		    'adding new addresses');
+		this.setDirty();
+	}
+	if (cb)
+		setImmediate(cb);
+};
+
+module.exports = {
+	PgHbaPool: PgHbaPool
+};
diff --git a/package.json b/package.json
index f7637b8..0dde50b 100644
--- a/package.json
+++ b/package.json
@@ -26,7 +26,7 @@
     "ipaddr.js": "^1.7.0",
     "lstream": "0.0.4",
     "mooremachine": "^2.2.1",
-    "restify-clients": "^2.2.0",
+    "restify-clients": "2.2.0",
     "vasync": "^2.2.0",
     "verror": "^1.10.0",
     "zkstream": "^0.11.2"
diff --git a/sapi_manifests/waferlock/template b/sapi_manifests/waferlock/template
index 73334da..6cea847 100644
--- a/sapi_manifests/waferlock/template
+++ b/sapi_manifests/waferlock/template
@@ -9,6 +9,13 @@
 		]
 	},
 
+	"pg_hba": {
+		"path": "/manatee/pg/data/pg_hba.conf",
+		"pidFile": "/manatee/pg/data/postmaster.pid",
+		"statInterval": 5,
+		"hupInterval": 10
+	},
+
 	"holdTime": 600,
 
 	{{! The SAPI polling interval can be shortened when ipmon shows
diff --git a/server.js b/server.js
index fa6336a..4e4b797 100644
--- a/server.js
+++ b/server.js
@@ -5,13 +5,12 @@
  */
 
 /*
- * Copyright (c) 2018, Joyent, Inc.
+ * Copyright 2019 Joyent, Inc.
  */
 
 'use strict';
 
 var mod_assert = require('assert-plus');
-var mod_verror = require('verror');
 var mod_bunyan = require('bunyan');
 var mod_fs = require('fs');
 var mod_util = require('util');
@@ -20,10 +19,8 @@ var mod_fsm = require('mooremachine');
 var mod_cueball = require('cueball');
 var mod_url = require('url');
 
-var lib_ipf = require('./lib/ipf');
-var Ipf = lib_ipf.Ipf;
-var IpfPool = lib_ipf.IpfPool;
-var IpMon = lib_ipf.IpMon;
+var lib_pghba = require('./lib/pg_hba');
+var PgHbaPool = lib_pghba.PgHbaPool;
 
 var lib_zk = require('./lib/zk');
 var ZKCache = lib_zk.ZKCache;
@@ -31,11 +28,9 @@ var ZKCache = lib_zk.ZKCache;
 var lib_sapi = require('./lib/sapi');
 var SapiPoller = lib_sapi.SapiPoller;
 
-var VError = mod_verror.VError;
-
 var confDir = mod_path.join(__dirname, 'etc');
 var confFile = mod_path.join(confDir, 'config.json');
-var ipfConfigFile = mod_path.join(confDir, 'ipf.conf');
+var pgHbaBaseFile = mod_path.join(confDir, 'pg_hba.conf');
 var config = JSON.parse(mod_fs.readFileSync(confFile, 'utf-8'));
 
 mod_assert.object(config, 'config');
@@ -49,6 +44,11 @@ mod_assert.number(config.sapiPollingInterval.min,
 mod_assert.number(config.sapiPollingInterval.max,
     'config.sapiPollingInterval.max');
 mod_assert.optionalString(config.shard, 'config.shard');
+mod_assert.object(config.pg_hba, 'config.pg_hba');
+mod_assert.string(config.pg_hba.path, 'config.pg_hba.path');
+mod_assert.string(config.pg_hba.pidFile, 'config.pg_hba.pidFile');
+mod_assert.number(config.pg_hba.statInterval, 'config.pg_hba.statInterval');
+mod_assert.number(config.pg_hba.hupInterval, 'config.pg_hba.hupInterval');
 
 mod_assert.optionalArrayOfString(config.paths, 'config.paths');
 mod_assert.optionalArrayOfString(config.domains, 'config.domains');
@@ -77,6 +77,7 @@ function AppFSM() {
 	this.af_denials = {};
 	this.af_log = log;
 	this.af_sapis = {};
+	this.af_pgHbaBase = null;
 
 	var agopts = {
 		spares: 1,
@@ -107,50 +108,33 @@ function AppFSM() {
 mod_util.inherits(AppFSM, mod_fsm.FSM);
 
 AppFSM.prototype.state_init = function (S) {
-	var self = this;
-	Ipf.flushAll(S.callback(function (err) {
-		if (err && err.name === 'IpfDisabledError') {
-			S.gotoState('enableIpf');
-			return;
-		}
-		if (err) {
-			self.af_err = new VError(
-			    { cause: err, name: 'IpfFlushError' },
-			    'failed to flush ipf rules');
-			S.gotoState('fatal');
-			return;
-		}
-		S.gotoState('setupPool');
-	}));
+	S.gotoState('readPgHbaBaseFile');
 };
 
-AppFSM.prototype.state_enableIpf = function (S) {
+AppFSM.prototype.state_readPgHbaBaseFile = function (S) {
 	var self = this;
-	Ipf.enable(S.callback(function (err) {
+	mod_fs.readFile(pgHbaBaseFile, S.callback(function (err, data) {
 		if (err) {
 			self.af_err = err;
 			S.gotoState('fatal');
 			return;
 		}
+		self.af_pgHbaBase = data.toString('ascii');
 		S.gotoState('setupPool');
 	}));
 };
 
 AppFSM.prototype.state_setupPool = function (S) {
-	var self = this;
-	this.af_pool = new IpfPool({
+	this.af_pool = new PgHbaPool({
 		log: log,
-		name: '100',
-		holdTime: config.holdTime
+		statInterval: config.pg_hba.statInterval,
+		hupInterval: config.pg_hba.hupInterval,
+		path: config.pg_hba.path,
+		pidFile: config.pg_hba.pidFile,
+		holdTime: config.holdTime,
+		baseText: this.af_pgHbaBase
 	});
-	this.af_pool.init(S.callback(function (err) {
-		if (err) {
-			self.af_err = err;
-			S.gotoState('fatal');
-			return;
-		}
-		S.gotoState('setupCache');
-	}));
+	S.gotoState('setupCache');
 };
 
 AppFSM.prototype.state_setupCache = function (S) {
@@ -213,59 +197,12 @@ AppFSM.prototype.state_setupSapi = function (S) {
 };
 
 AppFSM.prototype.state_loadRules = function (S) {
-	var self = this;
-	Ipf.loadRulesFile(ipfConfigFile, S.callback(function (err) {
-		if (err) {
-			self.af_err = err;
-			S.gotoState('fatal');
-			return;
-		}
-		S.gotoState('enforcing');
-	}));
+	S.gotoStateOn(this.af_pool, 'hupped', 'enforcing');
+	this.af_pool.start();
 };
 
-/* eslint-disable */
-/* JSSTYLED */
-var TUPLE_RE = / ([0-9]+\.[0-9]+\.[0-9]+\.[0-9]+),([0-9]+) -> ([0-9]+\.[0-9]+\.[0-9]+\.[0-9]+),([0-9]+) /;
-/* eslint-enable */
-
-AppFSM.prototype.state_enforcing = function (S) {
-	var self = this;
-	this.af_log.info('ipf rules loaded, now enforcing');
-	this.af_mon = new IpMon({
-		log: log
-	});
-	S.on(this.af_mon, 'line', function (line) {
-		var m = TUPLE_RE.exec(line);
-		if (!m) {
-			self.af_log.trace({ ipmonLine: line }, 'unparseable ' +
-			    'ipmon output line');
-			return;
-		}
-		var fromIp = m[1];
-		var fromPort = parseInt(m[2], 10);
-		var toIp = m[3];
-		var toPort = parseInt(m[4], 10);
-		if (typeof (fromPort) !== 'number' || !isFinite(fromPort) ||
-		    typeof (toPort) !== 'number' || !isFinite(toPort)) {
-			return;
-		}
-		var ds = self.af_denials[fromIp];
-		if (ds === undefined) {
-			ds = (self.af_denials[fromIp] = {});
-			Object.keys(self.af_sapis).forEach(function (k) {
-				self.af_sapis[k].trigger();
-			});
-		}
-		if (ds[toPort] === undefined) {
-			self.af_log.debug({ fromIp: fromIp, fromPort: fromPort,
-			    toIp: toIp, toPort: toPort },
-			    'denied access from %s to port %d',
-			    fromIp, toPort);
-			ds[toPort] = 0;
-		}
-		ds[toPort]++;
-	});
+AppFSM.prototype.state_enforcing = function (_S) {
+	this.af_log.info('pg_hba.conf reloaded, now enforcing');
 };
 
 AppFSM.prototype.state_fatal = function (S) {
@@ -276,12 +213,19 @@ AppFSM.prototype.state_fatal = function (S) {
 
 var app = new AppFSM();
 
-function disableIpfAndExit() {
-	if (app.af_mon && app.af_mon.isInState('running'))
-		app.af_mon.stop();
-	Ipf.disable(function () {
+function stopAndExit() {
+	if (app.af_pool && !app.af_pool.isInState('stopped')) {
+		log.info('shutting down pool, writing permissive pg_hba.conf');
+		app.af_pool.on('stateChanged', function (st) {
+			if (st === 'stopped') {
+				log.info('shut down');
+				process.exit(0);
+			}
+		});
+		app.af_pool.stop();
+	} else {
 		process.exit(0);
-	});
+	}
 }
-process.on('SIGINT', disableIpfAndExit);
-process.on('SIGTERM', disableIpfAndExit);
+process.on('SIGINT', stopAndExit);
+process.on('SIGTERM', stopAndExit);
