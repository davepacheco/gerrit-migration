commit fb3f9818da3f1de118243882d983ceab1bcffbe9 (refs/changes/07/5607/7)
Author: Rob Johnston <rob.johnston@joyent.com>
Date:   2019-02-22T04:57:48+00:00 (8 months ago)
    
    OS-7560 libtopo's XML serialization code is broken and incomplete

diff --git a/usr/src/lib/fm/topo/libtopo/Makefile.com b/usr/src/lib/fm/topo/libtopo/Makefile.com
index c0c164fa18..4f397a589e 100644
--- a/usr/src/lib/fm/topo/libtopo/Makefile.com
+++ b/usr/src/lib/fm/topo/libtopo/Makefile.com
@@ -76,6 +76,7 @@ SRCDIR =	../common
 CLEANFILES += $(SRCDIR)/topo_error.c $(SRCDIR)/topo_tables.c
 
 CPPFLAGS += -I../common -I$(ADJUNCT_PROTO)/usr/include/libxml2 -I.
+CSTD = $(CSTD_GNU99)
 CFLAGS += $(CCVERBOSE) $(C_BIGPICFLAGS)
 CFLAGS += -D_POSIX_PTHREAD_SEMANTICS
 CFLAGS64 += $(CCVERBOSE) $(C_BIGPICFLAGS)
diff --git a/usr/src/lib/fm/topo/libtopo/common/topo_2xml.c b/usr/src/lib/fm/topo/libtopo/common/topo_2xml.c
index d7edbc31e7..43c891a5f5 100644
--- a/usr/src/lib/fm/topo/libtopo/common/topo_2xml.c
+++ b/usr/src/lib/fm/topo/libtopo/common/topo_2xml.c
@@ -45,8 +45,15 @@
  * 10 bytes for base-10 value + 1 for sign + nul
  */
 #define	INT32BUFSZ	12
-/* 2 bytes for "0x" + 16 bytes for the hex value + 1 for sign + nul */
-#define	INT64BUFSZ	20
+/*
+ * Buffer that is large enough to hold the string representation of any signed
+ * or unsigned 64-bit integer.
+ *
+ * 2 bytes for "0x" + 16 bytes for the base-16 value + nul
+ * or
+ * 19 bytes for base-10 value + 1 for sign + nul
+ */
+#define	INT64BUFSZ	21
 #define	XML_VERSION	"1.0"
 
 static int txml_print_range(topo_hdl_t *, FILE *, tnode_t *, int);
@@ -115,129 +122,240 @@ txml_print_prop(topo_hdl_t *thp, FILE *fp, tnode_t *node, const char *pgname,
     topo_propval_t *pv)
 {
 	int err;
-	char *fmri = NULL;
-	char vbuf[INT64BUFSZ], tbuf[32], *pval = NULL, *aval = NULL;
+	uint_t nelem;
+	char vbuf[INT64BUFSZ];
 
 	switch (pv->tp_type) {
 		case TOPO_TYPE_INT32: {
 			int32_t val;
+
 			if (topo_prop_get_int32(node, pgname, pv->tp_name, &val,
-			    &err) == 0) {
-				(void) snprintf(vbuf, INT64BUFSZ, "%d", val);
-				(void) snprintf(tbuf, sizeof (tbuf), "%s",
-				    Int32);
-				pval = vbuf;
-			} else
+			    &err) != 0)
 				return;
+
+			(void) snprintf(vbuf, INT64BUFSZ, "%d", val);
+			begin_end_element(fp, Propval, Name, pv->tp_name, Type,
+			    Int32, Value, vbuf, NULL);
 			break;
 		}
 		case TOPO_TYPE_UINT32: {
 			uint32_t val;
+
 			if (topo_prop_get_uint32(node, pgname, pv->tp_name,
-			    &val, &err) == 0) {
-				(void) snprintf(vbuf, INT64BUFSZ, "0x%x", val);
-				(void) snprintf(tbuf, sizeof (tbuf), "%s",
-				    UInt32);
-				pval = vbuf;
-			} else
+			    &val, &err) != 0)
 				return;
+
+			(void) snprintf(vbuf, INT64BUFSZ, "0x%x", val);
+			begin_end_element(fp, Propval, Name, pv->tp_name, Type,
+			    UInt32, Value, vbuf, NULL);
 			break;
 		}
 		case TOPO_TYPE_INT64: {
 			int64_t val;
+
 			if (topo_prop_get_int64(node, pgname, pv->tp_name, &val,
-			    &err) == 0) {
-				(void) snprintf(vbuf, INT64BUFSZ, "0x%llx",
-				    (longlong_t)val);
-				(void) snprintf(tbuf, sizeof (tbuf), "%s",
-				    Int64);
-				pval = vbuf;
-			} else
+			    &err) != 0)
 				return;
+
+			(void) snprintf(vbuf, INT64BUFSZ, "%" PRId64, val);
+			begin_end_element(fp, Propval, Name, pv->tp_name, Type,
+			    Int64, Value, vbuf, NULL);
 			break;
 		}
 		case TOPO_TYPE_UINT64: {
 			uint64_t val;
+
 			if (topo_prop_get_uint64(node, pgname, pv->tp_name,
-			    &val, &err) == 0) {
-				(void) snprintf(vbuf, INT64BUFSZ, "0x%llx",
-				    (u_longlong_t)val);
-				(void) snprintf(tbuf, sizeof (tbuf), "%s",
-				    UInt64);
-				pval = vbuf;
-			} else
+			    &val, &err) != 0)
 				return;
+
+			(void) snprintf(vbuf, INT64BUFSZ, "0x%" PRIx64, val);
+			begin_end_element(fp, Propval, Name, pv->tp_name, Type,
+			    UInt64, Value, vbuf, NULL);
+			break;
+		}
+		case TOPO_TYPE_DOUBLE: {
+			double val;
+			char *dblstr = NULL;
+
+			if (topo_prop_get_double(node, pgname, pv->tp_name,
+			    &val, &err) != 0)
+				return;
+
+			/*
+			 * The %a format specifier allows floating point values
+			 * to be serialized without losing precision.
+			 */
+			if (asprintf(&dblstr, "%a", val) < 0)
+				return;
+			begin_end_element(fp, Propval, Name, pv->tp_name, Type,
+			    Double, Value, dblstr, NULL);
+			free(dblstr);
 			break;
 		}
 		case TOPO_TYPE_STRING: {
+			char *strbuf = NULL;
+
 			if (topo_prop_get_string(node, pgname, pv->tp_name,
-			    &pval, &err) != 0)
+			    &strbuf, &err) != 0)
 				return;
-			(void) snprintf(tbuf, sizeof (tbuf), "%s", "string");
+
+			begin_end_element(fp, Propval, Name, pv->tp_name, Type,
+			    String, Value, strbuf, NULL);
+			topo_hdl_strfree(thp, strbuf);
 			break;
 		}
 		case TOPO_TYPE_FMRI: {
-			nvlist_t *val;
+			nvlist_t *val = NULL;
+			char *fmristr = NULL;
 
 			if (topo_prop_get_fmri(node, pgname, pv->tp_name, &val,
-			    &err) == 0) {
-				if (topo_fmri_nvl2str(thp, val, &fmri, &err)
-				    == 0) {
-					nvlist_free(val);
-					pval = fmri;
-				} else {
-					nvlist_free(val);
-					return;
-				}
-			} else
+			    &err) != 0 ||
+			    topo_fmri_nvl2str(thp, val, &fmristr, &err) != 0) {
+				nvlist_free(val);
 				return;
-			(void) snprintf(tbuf, sizeof (tbuf), "%s", FMRI);
+			}
+			nvlist_free(val);
+			begin_end_element(fp, Propval, Name, pv->tp_name, Type,
+			    FMRI, Value, fmristr, NULL);
+			topo_hdl_strfree(thp, fmristr);
+			break;
+		}
+		case TOPO_TYPE_INT32_ARRAY: {
+			int32_t *val;
+
+			if (topo_prop_get_int32_array(node, pgname,
+			    pv->tp_name, &val, &nelem, &err) != 0)
+				return;
+
+			begin_element(fp, Propval, Name, pv->tp_name, Type,
+			    Int32_Arr, NULL);
+
+			for (uint_t i = 0; i < nelem; i++) {
+				(void) snprintf(vbuf, INT64BUFSZ, "%d", val[i]);
+				begin_end_element(fp, Propitem, Value, vbuf,
+				    NULL);
+			}
+
+			topo_hdl_free(thp, val, nelem * sizeof (int32_t));
+			end_element(fp, Propval);
 			break;
 		}
 		case TOPO_TYPE_UINT32_ARRAY: {
 			uint32_t *val;
-			uint_t nelem, i;
+
 			if (topo_prop_get_uint32_array(node, pgname,
 			    pv->tp_name, &val, &nelem, &err) != 0)
 				return;
 
-			if (nelem > 0) {
-				if ((aval = calloc((nelem * 9 - 1),
-				    sizeof (uchar_t))) == NULL) {
-
-					topo_hdl_free(thp, val,
-					    nelem * sizeof (uint32_t));
-					return;
-				}
-
-				(void) sprintf(aval, "0x%x", val[0]);
-				for (i = 1; i < nelem; i++) {
-					(void) sprintf(vbuf, " 0x%x", val[i]);
-					(void) strcat(aval, vbuf);
-				}
-				topo_hdl_free(thp, val,
-				    nelem * sizeof (uint32_t));
-				(void) snprintf(tbuf, sizeof (tbuf), "%s",
-				    UInt32_Arr);
-				pval = aval;
+			begin_element(fp, Propval, Name, pv->tp_name, Type,
+			    UInt32_Arr, NULL);
+
+			for (uint_t i = 0; i < nelem; i++) {
+				(void) snprintf(vbuf, INT64BUFSZ, "0x%x",
+				    val[i]);
+				begin_end_element(fp, Propitem, Value, vbuf,
+				    NULL);
 			}
+
+			topo_hdl_free(thp, val, nelem * sizeof (uint32_t));
+			end_element(fp, Propval);
 			break;
 		}
-		default:
-			return;
-	}
+		case TOPO_TYPE_INT64_ARRAY: {
+			int64_t *val;
 
-	begin_end_element(fp, Propval, Name, pv->tp_name, Type, tbuf,
-	    Value, pval, NULL);
+			if (topo_prop_get_int64_array(node, pgname,
+			    pv->tp_name, &val, &nelem, &err) != 0)
+				return;
+
+			begin_element(fp, Propval, Name, pv->tp_name, Type,
+			    Int64_Arr, NULL);
+
+			for (uint_t i = 0; i < nelem; i++) {
+				(void) snprintf(vbuf, INT64BUFSZ, "%" PRId64,
+				    val[i]);
+				begin_end_element(fp, Propitem, Value, vbuf,
+				    NULL);
+			}
+
+			topo_hdl_free(thp, val, nelem * sizeof (int64_t));
+			end_element(fp, Propval);
+			break;
+		}
+		case TOPO_TYPE_UINT64_ARRAY: {
+			uint64_t *val;
+
+			if (topo_prop_get_uint64_array(node, pgname,
+			    pv->tp_name, &val, &nelem, &err) != 0)
+				return;
+
+			begin_element(fp, Propval, Name, pv->tp_name, Type,
+			    UInt64_Arr, NULL);
 
-	if (pval != NULL && pv->tp_type == TOPO_TYPE_STRING)
-		topo_hdl_strfree(thp, pval);
+			for (uint_t i = 0; i < nelem; i++) {
+				(void) snprintf(vbuf, INT64BUFSZ, "0x%" PRIx64,
+				    val[i]);
+				begin_end_element(fp, Propitem, Value, vbuf,
+				    NULL);
+			}
+
+			topo_hdl_free(thp, val, nelem * sizeof (uint64_t));
+			end_element(fp, Propval);
+			break;
+		}
+		case TOPO_TYPE_STRING_ARRAY: {
+			char **val;
+
+			if (topo_prop_get_string_array(node, pgname,
+			    pv->tp_name, &val, &nelem, &err) != 0)
+				return;
 
-	if (fmri != NULL)
-		topo_hdl_strfree(thp, fmri);
+			begin_element(fp, Propval, Name, pv->tp_name, Type,
+			    String_Arr, NULL);
 
-	if (aval != NULL)
-		free(aval);
+			for (uint_t i = 0; i < nelem; i++) {
+				begin_end_element(fp, Propitem, Value, val[i],
+				    NULL);
+			}
+			for (uint_t i = 0; i < nelem; i++) {
+				topo_hdl_strfree(thp, val[i]);
+			}
+			topo_hdl_free(thp, val, nelem * sizeof (char *));
+
+			end_element(fp, Propval);
+			break;
+		}
+		case TOPO_TYPE_FMRI_ARRAY: {
+			nvlist_t **val;
+			char *fmristr = NULL;
+			int ret;
+
+			if (topo_prop_get_fmri_array(node, pgname,
+			    pv->tp_name, &val, &nelem, &err) != 0)
+				return;
+
+			begin_element(fp, Propval, Name, pv->tp_name, Type,
+			    FMRI_Arr, NULL);
+
+			for (uint_t i = 0; i < nelem; i++) {
+				if ((ret = topo_fmri_nvl2str(thp, val[i],
+				    &fmristr, &err)) != 0)
+					break;
+				begin_end_element(fp, Propitem, Value, fmristr,
+				    NULL);
+				topo_hdl_strfree(thp, fmristr);
+			}
+			for (uint_t i = 0; i < nelem; i++) {
+				nvlist_free(val[i]);
+			}
+			topo_hdl_free(thp, val, nelem * sizeof (nvlist_t *));
+			end_element(fp, Propval);
+			break;
+		}
+		default:
+			return;
+	}
 }
 
 static void
@@ -277,7 +395,7 @@ txml_print_node(topo_hdl_t *thp, FILE *fp, tnode_t *node)
 	topo_pgroup_t *pg;
 
 	(void) snprintf(inst, INT32BUFSZ, "%d", node->tn_instance);
-	begin_element(fp, Node, Instance, inst, Static, True, NULL);
+	begin_element(fp, Node, Instance, inst, Static, False, NULL);
 	for (pg = topo_list_next(&node->tn_pgroups); pg != NULL;
 	    pg = topo_list_next(pg)) {
 		txml_print_pgroup(thp, fp, node, pg);
diff --git a/usr/src/lib/fm/topo/libtopo/common/topo_xml.c b/usr/src/lib/fm/topo/libtopo/common/topo_xml.c
index d907c72c44..1c83c472c0 100644
--- a/usr/src/lib/fm/topo/libtopo/common/topo_xml.c
+++ b/usr/src/lib/fm/topo/libtopo/common/topo_xml.c
@@ -21,7 +21,7 @@
 
 /*
  * Copyright (c) 2006, 2010, Oracle and/or its affiliates. All rights reserved.
- * Copyright (c) 2018, Joyent, Inc.
+ * Copyright (c) 2019, Joyent, Inc.
  */
 
 #include <libxml/parser.h>
@@ -118,8 +118,10 @@ xmlattr_to_int(topo_mod_t *mp,
 	    propname);
 	if ((str = xmlGetProp(n, (xmlChar *)propname)) == NULL)
 		return (topo_mod_seterrno(mp, ETOPO_PRSR_NOATTR));
-	*value = strtoull((char *)str, (char **)&estr, 10);
-	if (estr == str) {
+
+	errno = 0;
+	*value = strtoull((char *)str, (char **)&estr, 0);
+	if (errno != 0 || *estr != '\0') {
 		/* no conversion was done */
 		xmlFree(str);
 		return (topo_mod_seterrno(mp, ETOPO_PRSR_BADNUM));
@@ -139,8 +141,10 @@ xmlattr_to_double(topo_mod_t *mp,
 	    "xmlattr_to_double(propname=%s)\n", propname);
 	if ((str = xmlGetProp(n, (xmlChar *)propname)) == NULL)
 		return (topo_mod_seterrno(mp, ETOPO_PRSR_NOATTR));
-	*value = strtod((char *)str, (char **)&estr);
-	if (estr == str || *estr != '\0') {
+
+	errno = 0;
+	*value = strtold((char *)str, (char **)&estr);
+	if (errno != 0 || *estr != '\0') {
 		/* full or partial conversion failure */
 		xmlFree(str);
 		return (topo_mod_seterrno(mp, ETOPO_PRSR_BADNUM));
@@ -224,7 +228,7 @@ xlate_common(topo_mod_t *mp, xmlNodePtr xn, topo_type_t ptype, nvlist_t *nvl,
 	double dbl;
 	uint_t i = 0, nelems = 0;
 	nvlist_t *fmri;
-	xmlChar *str;
+	xmlChar *str, *estr;
 	char **strarrbuf;
 	void *arrbuf;
 	nvlist_t **nvlarrbuf;
@@ -305,8 +309,15 @@ xlate_common(topo_mod_t *mp, xmlNodePtr xn, topo_type_t ptype, nvlist_t *nvl,
 				    == NULL)
 					return (-1);
 
+				errno = 0;
 				((int32_t *)arrbuf)[i++]
-				    = atoi((const char *)str);
+				    = strtol((const char *)str, (char **)estr,
+				    0);
+				if (errno != 0 || *estr != '\0') {
+					xmlFree(str);
+					return (topo_mod_seterrno(mp,
+					    ETOPO_PRSR_BADNUM));
+				}
 				xmlFree(str);
 			}
 		}
@@ -327,8 +338,15 @@ xlate_common(topo_mod_t *mp, xmlNodePtr xn, topo_type_t ptype, nvlist_t *nvl,
 				    == NULL)
 					return (-1);
 
+				errno = 0;
 				((uint32_t *)arrbuf)[i++]
-				    = atoi((const char *)str);
+				    = strtoul((const char *)str, (char **)estr,
+				    0);
+				if (errno != 0 || *estr != '\0') {
+					xmlFree(str);
+					return (topo_mod_seterrno(mp,
+					    ETOPO_PRSR_BADNUM));
+				}
 				xmlFree(str);
 			}
 		}
@@ -349,8 +367,15 @@ xlate_common(topo_mod_t *mp, xmlNodePtr xn, topo_type_t ptype, nvlist_t *nvl,
 				    == NULL)
 					return (-1);
 
+				errno = 0;
 				((int64_t *)arrbuf)[i++]
-				    = atol((const char *)str);
+				    = strtoll((const char *)str, (char **)&estr,
+				    0);
+				if (errno != 0 || *estr != '\0') {
+					xmlFree(str);
+					return (topo_mod_seterrno(mp,
+					    ETOPO_PRSR_BADNUM));
+				}
 				xmlFree(str);
 			}
 		}
@@ -371,8 +396,15 @@ xlate_common(topo_mod_t *mp, xmlNodePtr xn, topo_type_t ptype, nvlist_t *nvl,
 				    == NULL)
 					return (-1);
 
+				errno = 0;
 				((uint64_t *)arrbuf)[i++]
-				    = atol((const char *)str);
+				    = strtoull((const char *)str,
+				    (char **)&estr, 0);
+				if (errno != 0 || *estr != '\0') {
+					xmlFree(str);
+					return (topo_mod_seterrno(mp,
+					    ETOPO_PRSR_BADNUM));
+				}
 				xmlFree(str);
 			}
 		}
