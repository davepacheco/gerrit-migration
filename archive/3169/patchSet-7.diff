commit 3b4eeea73e5e2e3df3385e90152c99131ad460df (refs/changes/69/3169/7)
Author: Rui Loura <rui@joyent.com>
Date:   2018-03-09T01:31:59+00:00 (1 year, 7 months ago)
    
    NET-384 sdc-booter should dump core on uncaught exception
    NET-385 sdc-booter panics while handling discover on log level trace
    NET-386 booter should be able to handle option 82 as nictags

diff --git a/README.md b/README.md
index 92c0a7a..68a1108 100644
--- a/README.md
+++ b/README.md
@@ -72,7 +72,7 @@ Booter supports a few SAPI configuration values:
 
 - `http_pxe_boot`: if set to `true`, allow iPXE clients to pull down their
   files via HTTP rather than TFTP
-- `compute_node_default_gateway`: set this to give Compute Nodess a
+- `compute_node_default_gateway`: set this to give Compute Nodes a
   default gateway
 - `dhcp_lease_time`: DHCP lease time for Compute Nodes
 - `allow_missing_class_id`: booter only allows clients with class identifiers
diff --git a/bin/dhcpd b/bin/dhcpd
index 3e21437..8822d6e 100755
--- a/bin/dhcpd
+++ b/bin/dhcpd
@@ -16,4 +16,4 @@ if [[ ! -d "${NODE_INSTALL}" && -d "${TOP}/build/node" ]]; then
     NODE_INSTALL=${TOP}/build/node
 fi
 
-${NODE_INSTALL}/bin/node ${TOP}/server.js "$@"
+${NODE_INSTALL}/bin/node --abort-on-uncaught-exception ${TOP}/server.js "$@"
diff --git a/config.json.sample b/config.json.sample
index 8feea4c..00b87aa 100644
--- a/config.json.sample
+++ b/config.json.sample
@@ -16,5 +16,6 @@
   "defaultGateway": "10.99.99.7",
   "serverIp": "10.99.99.11",
   "leaseTime": 3600,
-  "netmask": "255.255.255.0"
+  "netmask": "255.255.255.0",
+  "updateCacheInterval": 60000
 }
diff --git a/lib/admin-pool-cache.js b/lib/admin-pool-cache.js
new file mode 100644
index 0000000..32ffe69
--- /dev/null
+++ b/lib/admin-pool-cache.js
@@ -0,0 +1,127 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright 2018 Joyent, Inc.
+ */
+
+var assert = require('assert-plus');
+var vasync = require('vasync');
+var mod_json = require('./json-file');
+
+
+/*
+ * Initialize AdminPoolCache and start periodic updater.
+ */
+function AdminPoolCache(config) {
+    this._cache = {};
+    this.log = config.log;
+    this.napi = config.napi;
+    this.updateInterval = config.cacheUpdateInterval;
+    this.filename = 'admin_network_pool';
+    this.cacheDir = config.cacheDir;
+    this.timeoutId = setTimeout(this.updateWorker.bind(this),
+        this.updateInterval);
+    Object.seal(this);
+}
+
+/*
+ * Update AdminPoolCache.
+ */
+AdminPoolCache.prototype.update = function _AdminPoolCacheUpdate(callback) {
+    var napi = this.napi;
+    var self = this;
+
+    assert.func(callback, 'callback');
+
+    var resetTimeout = function () {
+        clearTimeout(self.timeoutId);
+        self.timeoutId = setTimeout(self.updateWorker.bind(self),
+            self.updateInterval);
+
+    };
+
+    // Callbacks are called via readCache and writeCache
+    var writeCache = function (payload) {
+        mod_json.write({
+            dir: self.cacheDir,
+            log: self.log,
+            name: self.filename,
+            payload: payload
+        }, function (writeErr) {
+            callback(writeErr, payload);
+            return;
+        });
+    };
+
+    var readCache = function () {
+        mod_json.read({
+            dir: self.cacheDir,
+            name: self.filename,
+            log: self.log
+        }, function (err, data) {
+            callback(err, data);
+            return;
+        });
+    };
+
+    napi.listNetworkPools({name: 'admin'}, null, function (err, res) {
+        // If there was an error, don't alter the cache.
+        if (err) {
+            self.log.error({ err: err }, 'NAPI Error');
+            resetTimeout();
+            readCache();
+            return;
+        }
+
+        assert.arrayOfObject(res, 'pools');
+        if (res.length > 1) {
+            self.log.error({
+                pools: res
+            }, 'More than one network pool found for "admin"');
+            resetTimeout();
+            readCache();
+            return;
+        }
+
+        /*
+         * If NAPI is error free, but there isn't an admin network pool, clear
+         * the cache.
+         */
+        if (!res || res.length === 0) {
+            resetTimeout();
+            writeCache({});
+            return;
+        }
+
+        resetTimeout();
+        writeCache(res[0]);
+        return;
+    });
+};
+
+AdminPoolCache.prototype.updateWorker = function () {
+    var self = this;
+    this.update(function (err, data) {
+        if (err) {
+            self.log.error({error: err, cache: data},
+                'Periodic Admin Pool Cache update failed to write cache');
+        } else {
+            self.log.info({cache: data},
+                'Periodic Admin Pool Cache update complete');
+        }
+    });
+};
+
+AdminPoolCache.prototype.quiesce = function () {
+    clearTimeout(this.timeoutId);
+};
+
+module.exports = {
+    create: function (config) {
+        return new AdminPoolCache(config);
+    }
+};
diff --git a/lib/boot-files.js b/lib/boot-files.js
index ce559d6..5c94d9b 100644
--- a/lib/boot-files.js
+++ b/lib/boot-files.js
@@ -39,7 +39,9 @@ function extractBootOpts(opts) {
         log: opts.log,
         napi: opts.napi,
         mac: opts.mac,
-        tftpRoot: opts.config.tftpRoot
+        tftpRoot: opts.config.tftpRoot,
+        nic_tag: opts.nic_tag,
+        adminPoolCache: opts.adminPoolCache
     };
 
     if (opts.mac) {
@@ -95,6 +97,7 @@ function writeBootFiles(opts, callback) {
             });
         },
 
+        // Write out networking.json file.
         function _bootTimeFile(arg, cb) {
             mod_net_file.write(arg, function (err) {
                 // Don't let this hold up booting - we can always fall back to
@@ -103,6 +106,7 @@ function writeBootFiles(opts, callback) {
             });
         },
 
+        // Make sure networking.json file is in the bootFsDir.
         function _bootFsFiles(arg, cb) {
             mod_find.files(arg, function (err, files) {
                 if (err) {
diff --git a/lib/booter.js b/lib/booter.js
index 5fa83eb..5b0eab5 100644
--- a/lib/booter.js
+++ b/lib/booter.js
@@ -20,6 +20,7 @@ var menu = require('./menulst');
 var mod_cache = require('./cache');
 var mod_clients = require('./clients');
 var path = require('path');
+var AdminPoolCache = require('./admin-pool-cache');
 
 
 
@@ -49,6 +50,13 @@ function main() {
         }
     });
 
+    var adminPoolCache = AdminPoolCache.create({
+        napi: napi,
+        log: log,
+        cacheDir: config.poolCache.dir,
+        cacheUpdateInterval: config.poolCache.updateInterval
+    });
+
     switch (process.argv[2]) {
     case 'ping-napi':
         napi.ping(standardHandler);
@@ -64,7 +72,8 @@ function main() {
             napi: napi,
             cnapi: cnapi,
             log: log,
-            pipelineTimeoutSeconds: -1
+            pipelineTimeoutSeconds: -1,
+            adminPoolCache: adminPoolCache
         }, standardHandler);
         break;
     case 'bootparams-cnapi':
@@ -77,7 +86,8 @@ function main() {
             mac: getArg('MAC address'),
             napi: napi,
             cnapi: cnapi,
-            log: log
+            log: log,
+            adminPoolCache: adminPoolCache
         }, function (err, res) {
             if (err) {
                 return console.error(err.code + ': ' + err.message);
@@ -98,7 +108,8 @@ function main() {
             mac: getArg('MAC address'),
             napi: napi,
             cnapi: cnapi,
-            log: log
+            log: log,
+            adminPoolCache: adminPoolCache
         }, function (err, res) {
             if (err) {
                 return console.error(err.code + ': ' + err.message);
@@ -112,13 +123,15 @@ function main() {
     case 'full-cache-refresh':
         var cacheSentinel = new mod_cache.CacheSentinel({
             log: log, cnapi: cnapi, napi: napi,
-            adminUuid: config.adminUuid, cacheConfig: config.cache});
+            adminUuid: config.adminUuid, cacheConfig: config.cache,
+            adminPoolCache: adminPoolCache});
         cacheSentinel.refreshCache();
         break;
     default:
         usage();
         break;
     }
+    adminPoolCache.quiesce();
 }
 
 
diff --git a/lib/bootparams.js b/lib/bootparams.js
index ab875c0..c6c9f50 100644
--- a/lib/bootparams.js
+++ b/lib/bootparams.js
@@ -26,25 +26,6 @@ var verror = require('verror');
 
 
 
-/**
- * Return an object mapping foo_nic to aggregation name
- */
-function aggrsToTags(aggrs) {
-    var agTag = {};
-
-    aggrs.forEach(function (ag) {
-        if (ag.hasOwnProperty('nic_tags_provided')) {
-
-            ag.nic_tags_provided.forEach(function (t) {
-                agTag[t + '_nic'] = ag.name;
-            });
-        }
-    });
-
-    return agTag;
-}
-
-
 /**
  * Return an object mapping MAC addresses to the names of their parent
  * aggregations
@@ -72,34 +53,25 @@ function getFromCache(opts, callback) {
     assert.string(opts.mac, 'opts.mac');
     assert.optionalObject(opts.err, 'opts.err');
 
-    var dir = opts.dir;
     var log = opts.log;
+    var dir = opts.dir;
     var mac = opts.mac;
     var originalErr = opts.err;
 
-    var file = util.format('%s/%s.json', dir, mac);
-    fs.readFile(file, function (err, data) {
+    mod_json.read({
+        dir: dir,
+        name: mac,
+        log: log
+    }, function (err, data) {
         if (err) {
-            log.error(err,
-                'getFromCache: MAC "%s": error getting cached params from "%s"',
-                mac, file);
-            return callback(originalErr);
+            callback(originalErr);
+            return;
         }
 
-        var params;
-        try {
-            params = JSON.parse(data);
-        } catch (err2) {
-            log.error(err2,
-                'getFromCache: MAC "%s": error parsing JSON from "%s"',
-                mac, file);
+        log.debug(data, 'getFromCache: got cached params from "%s/%s.json"',
+            dir, mac);
 
-            return callback(originalErr);
-        }
-
-        log.debug(params, 'getFromCache: MAC "%s": got cached params from "%s"',
-            mac, file);
-        return callback(null, { bootParams: params });
+        return callback(null, { bootParams: data });
     });
 }
 
@@ -121,6 +93,7 @@ function getBootParams(opts, callback) {
     assert.object(opts.napi, 'opts.napi');
     assert.optionalNumber(opts.pipelineTimeoutSeconds,
                           'opts.pipelineTimeoutSeconds');
+    assert.object(opts.adminPoolCache, 'opts.adminPoolCache');
 
     var cacheDir = opts.cacheDir;
     var adminUuid = opts.adminUuid;
@@ -128,6 +101,7 @@ function getBootParams(opts, callback) {
     var log = opts.log;
     var mac = opts.mac;
     var napi = opts.napi;
+    var adminPoolCache = opts.adminPoolCache;
 
     /*
      * getBootParams performs several calls to external services (e.g. napi &
@@ -172,16 +146,40 @@ function getBootParams(opts, callback) {
     var uuid;
     var params = null;
     var vArg = {
-        adminUuid: opts.adminUuid,
+        adminUuid: opts.adminUuid, // admin user not network
         bootNic: null,
         log: opts.log,
-        napi: opts.napi
+        napi: opts.napi,
+        network_uuid: 'admin',
+        adminPool: null,
+        nic_tag: opts.nic_tag
     };
 
     vasync.pipeline({
         arg: vArg,
         funcs: [
+            /*
+             * Make sure we have the latest adminPoolCache data.  We use this
+             * not only on initial provision but also for returning nics that
+             * may have changed nic tags since initial provision and before the
+             * adminPoolCache has updated.
+             *
+             * If we encounter an error here we log it and move on, because we
+             * may not even need the admin network pool info to boot this CN.
+             */
+            function _updateAdminPoolCache(fArg, cb) {
+                adminPoolCache.update(function (err, pool_cache) {
+                    if (err) {
+                        log.error({err: err}, 'Error getting adminPoolCache');
+                        cb();
+                        return;
+                    }
 
+                    fArg.adminPool = pool_cache;
+                    cb();
+                    return;
+                });
+            },
             // Get nic data from NAPI for the given MAC
             function _getNic(fArg, cb) {
                 napi.getNic(mac, function (err, res) {
@@ -207,14 +205,16 @@ function getBootParams(opts, callback) {
                     return cb();
                 }
 
+                assert(fArg.bootNic.network_uuid === undefined,
+                    'network_uuid undefined');
                 var putParams = {
-                    network_uuid: 'admin'
+                    network_uuid: fArg.network_uuid
                 };
 
                 log.debug(putParams, 'Updating nic "%s" to add IP', mac);
                 napi.updateNic(mac, putParams, function (err, res) {
                     if (err) {
-                        log.error({ err: err, params: putParams},
+                        log.error({err: err, params: putParams},
                             'Error adding IP to nic "%s" on NAPI', mac);
                         return cb(err);
                     }
@@ -228,6 +228,32 @@ function getBootParams(opts, callback) {
                 });
             },
 
+            function _checkAdminPoolCache(fArg, cb) {
+                if (fArg.bootNic !== null) {
+                    cb();
+                    return;
+                }
+
+                if (!fArg.nic_tag) {
+                    fArg.nic_tag = 'admin';
+                    cb();
+                    return;
+                }
+
+                var ntag = fArg.nic_tag;
+                log.info('bootNic not found, checking for admin network pool');
+                if (fArg.adminPool &&
+                    fArg.adminPool.hasOwnProperty('nic_tags_present') &&
+                    fArg.adminPool.nic_tags_present.indexOf(ntag) != -1) {
+
+                    log.info('found nictag in admin network pool');
+                    fArg.network_uuid = fArg.adminPool.uuid;
+                }
+
+                cb();
+                return;
+            },
+
             // If the nic doesn't exist in NAPI, provision it on the admin
             // network, which will give it an IP
             function _createNic(fArg, cb) {
@@ -240,9 +266,13 @@ function getBootParams(opts, callback) {
                     belongs_to_uuid: adminUuid,
                     belongs_to_type: 'other',
                     mac: mac,
-                    nic_tags_provided: [ 'admin' ]
+                    nic_tags_provided: [ fArg.nic_tag ] // XXX additional param?
                 };
-                napi.provisionNic('admin', postParams, function (err, res) {
+
+                log.info(postParams, 'posting params to napi');
+
+                napi.provisionNic(fArg.network_uuid, postParams,
+                    function (err, res) {
                     if (err) {
                         log.error(err,
                             'Error provisioning admin nic "%s" on NAPI', mac);
@@ -325,6 +355,7 @@ function getBootParams(opts, callback) {
             mod_clients.napiGetNicTags
         ]
     }, function (err, res) {
+
         if (pipelineTimedOut) {
             log.warn('getBootParams pipeline timed out; pipeline cb no-op');
             return;
@@ -350,18 +381,24 @@ function getBootParams(opts, callback) {
         }
 
         var adminNic = vArg.bootNic;
-        var aggrTags = aggrsToTags(vArg.aggrs);
+        var adminPool = vArg.adminPool;
+        var aggrs = vArg.aggrs;
         var bootNic = vArg.bootNic;
         var macAggrs = macsToAggrs(vArg.aggrs);
         var nics = vArg.nics;
         var overridden = {};
         var seen = {};
+        var adminFound = false;
         var tag;
 
         params.ip = bootNic.ip;
         params.netmask = bootNic.netmask;
         params.resolvers = bootNic.resolvers;
 
+        if (bootNic.gateway) {
+            params.gateway = bootNic.gateway;
+        }
+
         // Allow kernel_args from CNAPI to override the nic tag values, but
         // dutifully complain about it
         if (params.kernel_args.hasOwnProperty('admin_nic')) {
@@ -386,8 +423,10 @@ function getBootParams(opts, callback) {
                 continue;
             }
 
-            for (var t in nic.nic_tags_provided) {
-                tag = nic.nic_tags_provided[t] + '_nic';
+            for (var tg in nic.nic_tags_provided) {
+                var nictag = nic.nic_tags_provided[tg];
+                tag = nictag + '_nic';
+
                 if (params.kernel_args.hasOwnProperty(tag)) {
                     overridden[tag] = 1;
                 } else {
@@ -396,8 +435,21 @@ function getBootParams(opts, callback) {
                     }
                 }
 
-                if (tag == 'admin_nic') {
-                    adminNic = nic;
+                /*
+                 * Check for the nic tagged with 'admin' or any nic tagged with
+                 * a network that is in the admin network pool.  We do the same
+                 * below for aggrs.
+                 */
+                if (tag == 'admin_nic' ||
+                    (adminPool &&
+                    adminPool.hasOwnProperty('nic_tags_present') &&
+                    adminPool.nic_tags_present.indexOf(nictag) != -1)) {
+                        if (adminFound) {
+                            log.warn({orig_admin: adminNic, new_admin: nic},
+                                'second admin nic found');
+                        }
+                        adminNic = nic;
+                        adminFound = true;
                 }
             }
 
@@ -405,11 +457,24 @@ function getBootParams(opts, callback) {
         }
 
         // Now go through and assign nic tags to aggregations
-        for (tag in aggrTags) {
-            if (!params.kernel_args.hasOwnProperty(tag)) {
-                params.kernel_args[tag] = aggrTags[tag];
+        aggrs.forEach(function (ag) {
+            if (ag.hasOwnProperty('nic_tags_provided')) {
+                ag.nic_tags_provided.forEach(function (t) {
+                    var ntag = t + '_nic';
+
+                    if (!params.kernel_args.hasOwnProperty(ntag)) {            
+                        params.kernel_args[ntag] = ag.name;
+                    }
+
+                    if (adminPool &&                                      
+                        adminPool.hasOwnProperty('nic_tags_present') &&   
+                        adminPool.nic_tags_present.indexOf(t) != -1) {  
+                                              
+                        adminFound = true; 
+                    }
+                });
             }
-        }
+        });
 
         // Add aggregation boot parameters
         for (var a in vArg.aggrs) {
@@ -424,9 +489,9 @@ function getBootParams(opts, callback) {
 
         // If we don't have admin nic from NAPI, then set it to the nic
         // we booted from: this is likely the first boot
-        if (!params.kernel_args.hasOwnProperty('admin_nic')) {
-            params.kernel_args.admin_nic = bootNic.mac;
-            seen[bootNic.mac] = 1;
+        if (!adminFound && !params.kernel_args.hasOwnProperty('admin_nic')) {
+                params.kernel_args.admin_nic = bootNic.mac;
+                seen[bootNic.mac] = 1; // XXX cuft?
         }
 
         if (Object.keys(overridden).length !== 0) {
@@ -450,6 +515,7 @@ function getBootParams(opts, callback) {
                 aggrs: vArg.aggrs,
                 bootParams: params,
                 nics: nics,
+                adminPool: adminPool,
                 nictags: vArg.nictags
             });
         });
diff --git a/lib/cache.js b/lib/cache.js
index aed0a6c..a73b599 100644
--- a/lib/cache.js
+++ b/lib/cache.js
@@ -22,6 +22,7 @@ const verror = require('verror');
 
 // local
 const mod_bootparams = require('./bootparams');
+const mod_json = require('./json-file');
 
 
 /*
@@ -64,6 +65,7 @@ function CacheSentinel(opts) {
     assert.object(opts.log, 'opts.log');
     assert.object(opts.cnapi, 'opts.cnapi');
     assert.object(opts.napi, 'opts.napi');
+    assert.object(opts.adminPoolCache, 'opts.adminPoolCache');
     assert.uuid(opts.adminUuid, 'opts.adminUuid');
 
     assert.object(opts.cacheConfig, 'opts.cacheConfig');
@@ -89,6 +91,7 @@ function CacheSentinel(opts) {
     this.cnapi = opts.cnapi;
     this.napi = opts.napi;
     this.adminUuid = opts.adminUuid;
+    this.adminPoolCache = opts.adminPoolCache;
 
     this.cacheDir = opts.cacheConfig.dir;
     this.refreshInterval = opts.cacheConfig.refreshIntervalSeconds * 1000;
@@ -153,6 +156,7 @@ CacheSentinel.prototype.refreshCache = function refreshCache() {
             },
             function stepListNics(ctx, next) {
                 self.napi.listNics(
+                    // XXX: rui, need to include all nics on admin network pool.
                     {nic_tag: 'admin', belongs_to_type: 'server'},
                     function onList(err, nics) {
                         if (err) {
@@ -164,7 +168,69 @@ CacheSentinel.prototype.refreshCache = function refreshCache() {
                         return next();
                     });
             },
+            function stepAppendAdminPoolNics(ctx, next) {
+                var dir = self.adminPoolCache.cacheDir;
+                var filename = self.adminPoolCache.filename;
+
+                mod_json.read({
+                    dir: dir,
+                    name: filename,
+                    log: self.log
+                }, function (err, data) {
+                    if (err || Object.keys(data).length === 0 ||
+                        !data.hasOwnProperty('networks') ||
+                        !data.hasOwnProperty('nic_tags_present') ||
+                        data.nic_tags_present.length === 0) {
+
+                        self.log.info({err: err, data: data},
+                            'No admin pool cache, ignoring.');
+
+                        // ignore error reading from admin pool cache
+                        next();
+                        return;
+                    }
+
+                    var pooltags = data.nic_tags_present;
+                    const filterAdminPoolNics = function (net, cb) {
+
+                        self.log.info({net: net}, 'CHECKING NETWORK');
+                        self.napi.listNics({network_uuid: net},
+                            function (e, res) {
+
+                            self.log.info({nics: res, pooltags: pooltags},
+                                'PROCESSING NICS');
+                            if (e) {
+                                cb(new verror.VError(e,
+                                    'unable to list admin pool nics'));
+                                return;
+                            }
+
+                            res.forEach(function (nic) {
+                                if (pooltags.indexOf(nic.nic_tag) != -1) {
+                                    ctx.nics.push(nic);
+                                }
+                            });
+                            cb();
+                            return;
+                        });
+                    };
+
+                    vasync.forEachParallel({
+                        func: filterAdminPoolNics,
+                        inputs: data.networks
+                    }, function (e, res) {
+                        if (e) {
+                            // Only error out if there is an issue with NAPI
+                            next(e);
+                            return;
+                        }
+                        next();
+                        return;
+                    });
+                });
+            },
             function stepFilterToMacs(ctx, next) {
+                self.log.info({nics: ctx.nics}, "CTX BEFORE FILTER");
                 const serverUUIDs = ctx.servers.map(function (s) {
                     return s.uuid;
                 });
@@ -191,6 +257,7 @@ CacheSentinel.prototype.refreshCache = function refreshCache() {
                         napi: self.napi,
                         cnapi: self.cnapi,
                         log: self.log,
+                        adminPoolCache: self.adminPoolCache,
                         pipelineTimeout: -1
                     }, cb);
                 }, self.refreshConcurrency);
diff --git a/lib/dhcp.js b/lib/dhcp.js
index 42c55aa..4135805 100644
--- a/lib/dhcp.js
+++ b/lib/dhcp.js
@@ -362,6 +362,10 @@ function createDHCPreply(packet, data) {
                         pkt.options[opt] = pack.unpack('CCCC',
                                 pack.pack('N', parseInt(value, 10)));
                         break;
+                    // pass through
+                    case 82: // DHCP Relay
+                        pkt.options[opt] = value;
+                        break;
                     default:
                         throw new Error('Ignoring unhandled option ' + opt);
                 }
@@ -424,13 +428,14 @@ function parseDHCPpacket(data) {
     while (i < res.length) {
             var option = parseInt(res[i++], 10);
             if (option === 0) {
-                    continue;
+                continue;
             }
 
             if (option == 255) {
                     // end of options option
                     break;
             } else {
+                    // XXX: I'll take sub-options for a 100 Alex
                     // an option that will have data
                     var olen = res[i++]; // length of option data
                     var value = [];
diff --git a/lib/dhcpd.js b/lib/dhcpd.js
index 25d3a78..ee66a10 100755
--- a/lib/dhcpd.js
+++ b/lib/dhcpd.js
@@ -37,14 +37,24 @@ var uuid = require('node-uuid');
  */
 function DHCPD(opts) {
     this.config = opts.config;
-
-    this.cnapi = mod_clients.createCNAPIclient(this.config);
     this.log = opts.log;
-    this.napi = mod_clients.createNAPIclient(this.config);
+    this.adminPoolCache = opts.adminPoolCache;
+
+    if (opts.napi) {
+        this.napi = opts.napi;
+    } else {
+        this.napi = mod_clients.createNAPIclient(this.config);
+    }
 
+    if (opts.cnapi) {
+        this.cnapi = opts.cnapi;
+    } else {
+        this.cnapi = mod_clients.createCNAPIclient(this.config);
+    }
     this.cacheSentinel = new mod_cache.CacheSentinel(
         {log: this.log, cnapi: this.cnapi, napi: this.napi,
-         adminUuid: this.config.adminUuid, cacheConfig: this.config.cache});
+         adminUuid: this.config.adminUuid, cacheConfig: this.config.cache,
+         adminPoolCache: this.adminPoolCache});
 }
 
 
@@ -59,7 +69,7 @@ DHCPD.prototype.start = function () {
     });
 
     this.sock.on('listening', function () {
-        self.sock.setTTL(128);  // XXX Doesn't work! :( Bug in node?
+        self.sock.setTTL(128);  // Only for unicast replies.
         self.sock.setBroadcast(true);
         self.log.info('dhcpd started on %s:%d',
             self.config.listenIp, self.config.port);
@@ -81,10 +91,15 @@ DHCPD.prototype.handleMessage = function (msg, peer) {
 
     // Print the whole packet in hex
     if (log.trace()) {
+        var str_buf;
         for (var i = 0; i < msg.length; i += 4) {
-            // XXX
-            this.log.trace(sprintf('[%03d]: 0x%02x 0x%02x 0x%02x 0x%02x',
-                i, msg[i], msg[i+1], msg[i+2], msg[i+3]));
+            str_buf = '';
+            str_buf += sprintf('[%03d]:', i);
+
+            for (var j = 0; j < Math.min(4, msg.length - i); j++) {
+                str_buf += sprintf(' 0x%02x', msg[i + j]);
+            }
+            this.log.trace(str_buf);
         }
     }
 
@@ -128,13 +143,57 @@ DHCPD.prototype.handleMessage = function (msg, peer) {
             + 'identifier');
     }
 
+    function ipv4str2buf(ip) {
+        var ip_octets = ip.split('.');
+        var buf = Buffer.from(ip_octets).readUInt32BE(0);
+        return (buf);
+    }
 
+    /*
+     * This block decodes option 82 which has multiple sub-options.  If we
+     * decide to extend booter to be a full fledged, DHCP server then we should
+     * create decoders for each option in dhcp.js.  But at this time, option 82
+     * is the only option we support that leverages suboptions (excepting the
+     * widely misused option 77).
+     */
+    if (self.config.cacheDebug) {
+        packet.options[82] = [ 1, 12, 97, 100, 109, 105, 110, 95, 114, 97, 99,
+            107, 57, 57 ];
+    }
+
+    if (packet.options[82]) {
+        log.info({option_82: packet.options[82]}, 'Found DHCP Option 82');
+        var relayopt = packet.options[82];
+        var suboptid = relayopt[0];
+
+        /* We only support sub-option 1. */
+        if (suboptid !== 1) {
+            log.info('Option 82, missing dhcp circuit-id suboption, '
+                + 'found suboption number: %d.  Not responding.', suboptid);
+            return;
+        }
+
+        /* Slice off the suboption id. */
+        var subopt = relayopt.slice(1);
+        var suboptlen = subopt[0];
+
+        /* Slice off the suboption length. */
+        subopt = subopt.slice(1);
+
+        if (suboptlen !== subopt.length) {
+            log.info('Option 82, missing dhcp circuit-id suboption, '
+                + 'found suboption number: %d.  Not responding.', suboptid);
+            return;
+        }
+
+        var nictag = new Buffer(subopt).toString();
+        log.info('Found nic tag from Option 82:', nictag);
+    }
 
     var _sendReplyWithParams = function (params) {
         var packetOpts = self.buildPacketOpts(packet, params.bootParams, log);
         self.sendReply(packet, packetOpts, log, function (sendErr) {
-            if (sendErr) {
-                log.error(sendErr, 'Error sending reply');
+                if (sendErr) { log.error(sendErr, 'Error sending reply');
                 return;
             }
 
@@ -154,6 +213,8 @@ DHCPD.prototype.handleMessage = function (msg, peer) {
             config: self.config,
             log: log,
             mac: mac,
+            nic_tag: nictag,
+            adminPoolCache: self.adminPoolCache,
             napi: self.napi
         }, function _afterParams(pErr, params) {
             if (pErr) {
@@ -166,6 +227,7 @@ DHCPD.prototype.handleMessage = function (msg, peer) {
         mod_bootparams.getFromCache({
             dir: self.config.cache.dir,
             log: log,
+            nic_tag: nictag, // XXX Not sure this is needed here.
             mac: mac
         }, function _afterCache(err, params) {
             if (err) {
@@ -184,7 +246,8 @@ DHCPD.prototype.handleMessage = function (msg, peer) {
 DHCPD.prototype.sendReply = function (packet, packetOpts, log, callback) {
     var mac = packet.chaddr;
     var port = 68;
-    var broadcastAddr = '255.255.255.255';
+    var addr = '255.255.255.255';
+    var msg = 'broadcast';
 
     var outPacket = dhcp.createReplyPacket(packet, packetOpts);
     var outBuf = outPacket.toBuffer();
@@ -192,11 +255,27 @@ DHCPD.prototype.sendReply = function (packet, packetOpts, log, callback) {
         log.debug(outPacket.toObject(), 'Packet options');
     }
 
-    log.info('Sending broadcast ("%s:%d") reply to MAC "%s"',
-        broadcastAddr, port, mac);
+    // XXX: rui, does this work for both DHCPOFFER and DHCPACK (i.e. all
+    // traffic from the relay?
+    /* XXX: Need to implement relay before we can test this.
+     *
+     * May not need to do this if the source IP is the relay's IP.
+    if (packet.options[82]) {
+        buf = new Buffer(4);
+        buf.writeUInt32BE(packet.giaddr);
+        addr = ''.concat(
+            buf.readUInt8(0).toString(), '.',
+            buf.readUInt8(1).toString(), '.',
+            buf.readUInt8(2).toString(), '.',
+            buf.readUInt8(3).toString()
+        );
+        msg = 'unicast';
+    }
+    */
+
+    log.info('Sending %s ("%s:%d") reply to MAC "%s"', msg, addr, port, mac);
 
-    this.sock.send(outBuf, 0, outBuf.length, port, broadcastAddr,
-        function (err, bytes) {
+    this.sock.send(outBuf, 0, outBuf.length, port, addr, function (err, bytes) {
         if (err) {
             log.error(err, 'Error sending reply to "%s"', mac);
         } else {
@@ -229,7 +308,15 @@ DHCPD.prototype.buildPacketOpts = function (packet, params, log) {
         }
     };
 
-    if (this.config.defaultGateway) {
+    /*
+     * If option 82 (circuit id) is set that means the CN is behind a DHCP
+     * relay and we need to provide it a different gateway IP.  We get this from
+     * the gateway property of the adminNic's network.
+     */
+    if (packet.options[82]) {
+        packetOpts['options']['3'] = params.gateway;
+        packetOpts['options']['82'] = packet.options[82];
+    } else if (this.config.defaultGateway) {
         packetOpts['options']['3'] = this.config.defaultGateway;
     }
 
@@ -278,6 +365,7 @@ function createServer(opts) {
     assert.optionalObject(opts.config, 'opts.config');
     assert.optionalString(opts.configFile, 'opts.configFile');
     assert.object(opts.log, 'opts.log');
+    assert.object(opts.adminPoolCache, 'opts.adminPoolCache');
 
     var config;
     var log = opts.log;
@@ -301,6 +389,8 @@ function createServer(opts) {
 
     assert.number(config.leaseTime, 'config.leaseTime');
     assert.number(config.port, 'config.port');
+    assert.number(config.poolCache.updateInterval,
+        'config.poolCache.updateInterval');
 
     assert.optionalArrayOfString(config.resolvers);
     assert.optionalBool(config.disableBootTimeFiles,
@@ -312,7 +402,9 @@ function createServer(opts) {
     log.info({ config: config }, 'server config loaded');
     return new DHCPD({
         log: log,
-        config: config
+        config: config,
+        adminPoolCache: opts.adminPoolCache,
+        napi: opts.napi
     });
 }
 
diff --git a/lib/json-file.js b/lib/json-file.js
index ad48f04..d6f7d5f 100644
--- a/lib/json-file.js
+++ b/lib/json-file.js
@@ -23,6 +23,35 @@ var mod_vasync = require('vasync');
 // --- Exports
 
 
+function readJSONfile(opts, callback) {
+    assert.object(opts, 'opts');
+    assert.string(opts.dir, 'opts.dir');
+    assert.object(opts.log, 'opts.log');
+    assert.string(opts.name, 'opts.name');
+
+    var file = fmt('%s/%s.json', opts.dir, opts.name);
+    var log = opts.log;
+
+    mod_fs.readFile(file, function (err, data) {
+        if (err) {
+            log.error(err,
+                'readJSONfile: error getting cached params from "%s"', file);
+            callback(new Error('Error reading JSON file'));
+            return;
+        }
+
+        var json_data;
+        try {
+            json_data = JSON.parse(data);
+        } catch (err2) {
+            log.error(err2, 'readJSONfile: error parsing JSON from "%s"', file);
+            callback(new Error('Error parsing JSON file'));
+            return;
+        }
+        callback(null, json_data);
+        return;
+    });
+}
 
 function writeJSONfile(opts, callback) {
     assert.object(opts, 'opts');
@@ -69,5 +98,6 @@ function writeJSONfile(opts, callback) {
 
 
 module.exports = {
-    write: writeJSONfile
+    write: writeJSONfile,
+    read: readJSONfile
 };
diff --git a/lib/net-file.js b/lib/net-file.js
index 8add89a..d1a6809 100644
--- a/lib/net-file.js
+++ b/lib/net-file.js
@@ -15,7 +15,7 @@
 var assert = require('assert-plus');
 var fmt = require('util').format;
 var mod_crypto = require('crypto');
-var mod_file = require('./json-file');
+var mod_json = require('./json-file');
 var mod_fs = require('fs');
 
 
@@ -75,6 +75,7 @@ function generateNetConfFile(opts) {
 
     var conf = {
         nictags: opts.nictags,
+        adminNic: opts.adminNic,
         resolvers: [],
         routes: {},
         vnics: []
@@ -165,7 +166,8 @@ function generateNetConfFile(opts) {
 
         // This is a server that has just booted: fall back to setting the
         // admin nic tag's MAC address to it
-        if (aTag.name === 'admin') {
+        // XXX: do we need both comparisons?
+        if (aTag.name === 'admin' || opts.adminNic.nic_tag === aTag.name) {
             if (conf.vnics.length === 1 && !aTag.mac) {
                 aTag.mac = opts.adminNic.mac;
             }
@@ -184,7 +186,9 @@ function writeNetConfFile(opts, callback) {
     assert.object(opts.log, 'opts.log');
 
     var adminFound;
+    var nictag;
     var conf = generateNetConfFile(opts);
+    var adminPool = opts.adminPool;
     var name = 'writeNetConfFile: ';
 
     if (!conf) {
@@ -192,7 +196,12 @@ function writeNetConfFile(opts, callback) {
     }
 
     for (var n in conf.nictags) {
-        if (conf.nictags[n].name == 'admin') {
+        nictag = conf.nictags[n].name;
+        if (nictag == 'admin' ||
+            (adminPool &&
+            adminPool.hasOwnProperty('nic_tags_present') &&
+            adminPool.nic_tags_present.indexOf(nictag) != -1)) {
+
             adminFound = true;
             break;
         }
@@ -204,7 +213,7 @@ function writeNetConfFile(opts, callback) {
         return callback();
     }
 
-    mod_file.write({
+    mod_json.write({
         dir: opts.bootFsDir,
         log: opts.log,
         name: 'networking',
@@ -219,7 +228,7 @@ function writeNetConfFile(opts, callback) {
         var hashName = fmt('%s/networking.json.hash', opts.bootFsDir);
         var sha1 = mod_crypto.createHash('sha1');
 
-        // XXX: should really get mod_file.write() to return the actual
+        // XXX: should really get mod_json.write() to return the actual
         // string it wrote:
         sha1.update(JSON.stringify(conf, null, 2));
         digest = sha1.digest('hex');
diff --git a/sapi_manifests/dhcpd/template b/sapi_manifests/dhcpd/template
index bc86c39..8a43c70 100644
--- a/sapi_manifests/dhcpd/template
+++ b/sapi_manifests/dhcpd/template
@@ -40,5 +40,9 @@
     "purgeIntervalSeconds": 3600,
     "maxCacheFileAgeSeconds": 604800,
     "refreshConcurrency": 16
+  },
+  "poolCache": {
+    "updateInterval": 60000,
+    "dir": "/tftpboot/poolcache"
   }
 }
diff --git a/server.js b/server.js
index 7459722..a95a6d4 100644
--- a/server.js
+++ b/server.js
@@ -13,8 +13,12 @@
  */
 
 var bunyan = require('bunyan');
+var fs = require('fs');
 var dhcpd = require('./lib/dhcpd');
 var stdSerializers = require('sdc-bunyan-serializers');
+var AdminPoolCache = require('./lib/admin-pool-cache');
+var mod_clients = require('./lib/clients');
+
 
 
 var log = bunyan.createLogger({
@@ -24,11 +28,39 @@ var log = bunyan.createLogger({
 });
 
 try {
+    var configFile = __dirname + '/config.json';
+    var config = JSON.parse(fs.readFileSync(configFile, 'utf-8'));
+    var napi = mod_clients.createNAPIclient(config);
+
+    log.info('Loaded config from "%s"', configFile);
+
+
+    var cache = AdminPoolCache.create({
+        napi: napi,
+        log: log,
+        cacheDir: config.poolCache.dir,
+        cacheUpdateInterval: config.poolCache.updateInterval
+    });
+
     var server = dhcpd.createServer({
         log: log,
-        configFile: __dirname + '/config.json'
+        config: config,
+        napi: napi,
+        adminPoolCache: cache
+    });
+
+    /*
+     * Update the cache before we start the dhcpd server.
+     */
+    cache.update(function (err) {
+        if (err) {
+            log.error('Failed initial admin pool cache update', err);
+            throw err;
+        } else {
+            log.info('Initial cache update completed.  Starting DHCP server.');
+            server.start();
+        }
     });
-    server.start();
 } catch (err) {
     log.error(err);
     process.exit(1);
diff --git a/test/bootparams.test.js b/test/bootparams.test.js
index 631810d..db9c1ae 100644
--- a/test/bootparams.test.js
+++ b/test/bootparams.test.js
@@ -163,7 +163,8 @@ test('new CN boots', function (t) {
         getNic: [ { err: error404() } ],
         getNicTag: [ nicTag('admin') ],
         listAggrs: [ { res: [] } ],
-        provisionNic: [ { res: newNic } ]
+        provisionNic: [ { res: newNic } ],
+        listNetworkPools: [ { res: [] } ]
     };
 
     mocks.cnapi.VALUES = {
@@ -203,10 +204,129 @@ test('new CN boots', function (t) {
         ], 'NAPI provision nic endpoint called correctly');
 
         t.deepEqual(mod_file.netConfig(newNic.mac), {
-            aggregations: [],
             nictags: [
                 { name: 'admin', mac: newNic.mac, mtu: 1500 }
             ],
+            adminNic: newNic,
+            resolvers: newNic.resolvers,
+            routes: {},
+            vnics: [
+                newNic
+            ],
+            aggregations: []
+        }, 'network boot-time file written correctly');
+
+        tearDownMocks();
+        t.end();
+    });
+});
+
+
+test('new CN boots with admin pool', function (t) {
+    setUpMocks();
+
+    var admin_network = {
+        family: 'ipv4',
+        mtu: 1500,
+        nic_tag: 'admin_rack99',
+        name: 'admin_rack99',
+        provision_end_ip: '10.222.222.250',
+        provision_start_ip: '10.222.222.5',
+        subnet: '10.222.222.0/24',
+        uuid: '9d136dbc-a161-44f5-85a9-83c0bbecef6f',
+        vlan_id: 0,
+        resolvers: [],
+        gateway: '10.222.222.1',
+        netmask: '255.255.255.0'
+    };
+
+    var newNic = {
+        belongs_to_type: 'other',
+        belongs_to_uuid: mod_server.adminUuid,
+        mac: '06:b7:ad:86:be:04',
+        owner_uuid: mod_server.adminUuid,
+        primary: false,
+        ip: '10.222.222.9',
+        gateway: '10.222.222.1',
+        netmask: '255.255.255.0',
+        vlan_id: 0,
+        nic_tag: 'admin_rack99',
+        resolvers: [ '10.99.99.11' ]
+    };
+
+    var network_pool = {
+        family: 'ipv4',
+        uuid: '2cecff7d-fc97-4a44-bd1c-522dbaa39587',
+        name: 'admin',
+        networks: [
+            '9d136dbc-a161-44f5-85a9-83c0bbecef6f'
+        ],
+        nic_tags_present: [
+            'admin_rack99'
+        ],
+        nic_tag: 'admin_rack99'
+    };
+
+    mocks.napi.VALUES = {
+        getNic: [ { err: error404() } ],
+        getNicTag: [ nicTag('admin_rack99') ],
+        listAggrs: [ { res: [] } ],
+        provisionNic: [ { res: newNic } ],
+        listNetworkPools: [
+            { res: [ network_pool ] }
+        ],
+        listNetworks: [ { res: [ admin_network ] } ]
+    };
+
+    mocks.cnapi.VALUES = {
+        getBootParams: [ { res: clone(DEFAULT_BOOT_PARAMS) } ]
+    };
+
+    getBootParams({ mac: newNic.mac, nic_tag: newNic.nic_tag },
+            function (err, res) {
+        t.ifError(err, 'expect truthy value');
+        if (err) {
+            return t.end();
+        }
+
+        var params = clone(DEFAULT_BOOT_PARAMS);
+        params.kernel_args.admin_nic = newNic.mac;
+        params.ip = newNic.ip;
+        params.netmask = newNic.netmask;
+        params.resolvers = [ '10.99.99.11' ];
+        params.gateway = newNic.gateway;
+
+        t.deepEqual(res.bootParams, params, 'boot params for new CN');
+        t.deepEqual(mocks.cnapi.CALLS.getBootParams, [
+            { uuid: 'default' }
+        ], 'cnapi /boot called correctly');
+
+        t.deepEqual(mocks.napi.CALLS.getNic, [
+            { mac: newNic.mac }
+        ], 'NAPI /nics/:mac called correctly');
+
+        // TODO: when we provision on a network pool we should get the network
+        // uuid returned, not the network pool uuid. But we are using mocks
+        // here, instead of real NAPI.  So we could build in the same
+        // intelligence of real NAPI into mocks.  But for now just set
+        // 'network' to the network pool uuid.
+        t.deepEqual(mocks.napi.CALLS.provisionNic, [
+            { network: network_pool.uuid,
+                params: {
+                    belongs_to_type: newNic.belongs_to_type,
+                    belongs_to_uuid: newNic.belongs_to_uuid,
+                    mac: newNic.mac,
+                    owner_uuid: newNic.owner_uuid,
+                    nic_tags_provided: ['admin_rack99']
+                } }
+        ], 'NAPI provision nic endpoint called correctly');
+
+        t.deepEqual(mod_file.netConfig(newNic.mac), {
+            aggregations: [],
+            nictags: [
+                { name: 'admin_rack99', mac: newNic.mac, mtu: 1500 }
+            ],
+            adminNic: newNic,
             resolvers: newNic.resolvers,
             routes: {},
             vnics: [
@@ -229,7 +349,9 @@ test('existing CN boots', function (t) {
         getNic: [ { res: serverNics[1] } ],
         getNics: [ { res: serverNics } ],
         getNicTag: [ nicTag('admin'), nicTag('external') ],
-        listAggrs: [ { res: [] } ]
+        listAggrs: [ { res: [] } ],
+        listNetworkPools: [ { res: [] } ]
+
     };
 
     mocks.cnapi.VALUES = {
@@ -266,6 +388,7 @@ test('existing CN boots', function (t) {
                 { name: 'admin', mac: serverNics[1].mac, mtu: 1500 },
                 { name: 'external', mac: serverNics[0].mac, mtu: 1500 }
             ],
+            adminNic: serverNics[1],
             resolvers: serverNics[1].resolvers.concat(serverNics[0].resolvers),
             routes: {},
             vnics: [
@@ -279,6 +402,7 @@ test('existing CN boots', function (t) {
     });
 });
 
+// TODO: test('existing CN boots: admin network pool', function (t) {
 
 test('existing CN boots: no bootparams', function (t) {
     setUpMocks();
@@ -288,7 +412,9 @@ test('existing CN boots: no bootparams', function (t) {
         getNic: [ { res: serverNics[1] } ],
         getNics: [ { res: serverNics } ],
         getNicTag: [ nicTag('admin'), nicTag('external') ],
-        listAggrs: [ { res: [] } ]
+        listAggrs: [ { res: [] } ],
+        listNetworkPools: [ { res: [] } ]
+
     };
 
     mocks.cnapi.VALUES = {
@@ -325,6 +451,7 @@ test('existing CN boots: no bootparams', function (t) {
                 { name: 'admin', mac: serverNics[1].mac, mtu: 1500 },
                 { name: 'external', mac: serverNics[0].mac, mtu: 1500 }
             ],
+            adminNic: serverNics[1],
             resolvers: serverNics[1].resolvers.concat(serverNics[0].resolvers),
             routes: {},
             vnics: [
@@ -348,6 +475,11 @@ test('admin nic different than booting nic', function (t) {
     setUpMocks();
     var desc = ': admin nic != booting nic';
     var serverNics = clone(CN1_NICS);
+    // XXX: Needs work?
+    // Seems like this test will always pass because we are manually adding the
+    // 'admin' nic tag to a nic that does not actually provide it.  Perhaps the
+    // thinking is that since they are on the same L2, we assume that this nic
+    // is on the admin network.
     serverNics[0].nic_tags_provided = [ 'admin' ];
     delete serverNics[1].nic_tags_provided;
 
@@ -355,7 +487,9 @@ test('admin nic different than booting nic', function (t) {
         getNic: [ { res: serverNics[1] } ],
         getNics: [ { res: serverNics } ],
         getNicTag: [ nicTag('admin'), nicTag('external') ],
-        listAggrs: [ { res: [] } ]
+        listAggrs: [ { res: [] } ],
+        listNetworkPools: [ { res: [] } ]
+
     };
 
     mocks.cnapi.VALUES = {
@@ -388,6 +522,7 @@ test('admin nic different than booting nic', function (t) {
                 { name: 'admin', mac: serverNics[0].mac, mtu: 1500 },
                 { name: 'external', mtu: 1500 }
             ],
+            adminNic: serverNics[0], // TODO: Test this for rack aware
             resolvers: serverNics[0].resolvers.concat(serverNics[1].resolvers),
             routes: {},
             vnics: [
@@ -431,6 +566,12 @@ test('existing CN boots: NAPI connection error', function (t) {
         listAggrs: [
             { res: [] },
             { res: [] }
+        ],
+        listNetworkPools: [
+            { res: [] },
+            { res: [] },
+            { res: [] },
+            { res: [] }
         ]
     };
 
@@ -451,6 +592,7 @@ test('existing CN boots: NAPI connection error', function (t) {
             { name: 'admin', mac: serverNics[1].mac, mtu: 1500 },
             { name: 'external', mac: serverNics[0].mac, mtu: 1500 }
         ],
+        adminNic: serverNics[1],
         resolvers: serverNics[1].resolvers.concat(serverNics[0].resolvers),
         routes: {},
         vnics: [
@@ -589,7 +731,11 @@ test('existing CN boots: CNAPI connection error', function (t) {
         getNicTag: [
             nicTag('admin'), nicTag('external')
         ],
-        listAggrs: [ { res: [] } ]
+        listAggrs: [ { res: [] } ],
+        listNetworkPools: [
+            { res: [] },
+            { res: [] }
+        ]
     };
 
     mocks.cnapi.VALUES = {
@@ -606,6 +752,7 @@ test('existing CN boots: CNAPI connection error', function (t) {
             { name: 'admin', mac: serverNics[1].mac, mtu: 1500 },
             { name: 'external', mac: serverNics[0].mac, mtu: 1500 }
         ],
+        adminNic: serverNics[1],
         resolvers: serverNics[1].resolvers.concat(serverNics[0].resolvers),
         routes: {},
         vnics: [
@@ -655,7 +802,8 @@ test('error while provisioning nic', function (t) {
     mocks.napi.VALUES = {
         getNic: [ { err: error404() } ],
         provisionNic: [ { err: new Error('XXX bad error') } ],
-        listAggrs: [ { res: [] } ]
+        listAggrs: [ { res: [] } ],
+        listNetworkPools: [ { res: [] } ]
     };
 
     mocks.cnapi.VALUES = {
@@ -691,7 +839,11 @@ test('invalid JSON in cache file',  function (t) {
         getNicTag: [
             nicTag('admin'), nicTag('external')
         ],
-        listAggrs: [ { res: [] } ]
+        listAggrs: [ { res: [] } ],
+        listNetworkPools: [
+            { res: [] },
+            { res: [] }
+        ]
     };
 
     mocks.cnapi.VALUES = {
@@ -753,6 +905,10 @@ test('aggregation', function (t) {
         listAggrs: [
             { res: [ aggr ] },
             { res: [ aggr ] }
+        ],
+        listNetworkPools: [
+            { res: [] },
+            { res: [] }
         ]
     };
 
@@ -805,6 +961,7 @@ test('aggregation', function (t) {
                 { name: 'external', mac: 'aggr0', mtu: 1500 },
                 { name: 'foo', mac: 'aggr0', mtu: 1500 }
             ],
+            adminNic: serverNics[1],
             resolvers: serverNics[1].resolvers.concat(serverNics[0].resolvers),
             routes: {},
             vnics: [
@@ -831,6 +988,7 @@ test('aggregation', function (t) {
                     { name: 'external', mac: 'aggr0', mtu: 1500 },
                     { name: 'foo', mac: 'aggr0', mtu: 1500 }
                 ],
+                adminNic: serverNics[1],
                 resolvers: serverNics[1].resolvers.concat(
                     serverNics[0].resolvers),
                 routes: {},
diff --git a/test/lib/mocks.js b/test/lib/mocks.js
index fb79211..8aac5ab 100644
--- a/test/lib/mocks.js
+++ b/test/lib/mocks.js
@@ -154,6 +154,16 @@ function createMocks() {
             { mac: mac, params: params }, cb);
     };
 
+    mocks.napi.listNetworks = function (params, options, cb) {
+        return this._handle('listNetworks',
+            { params: params, options: options }, cb);
+    };
+
+    mocks.napi.listNetworkPools = function (params, options, cb) {
+        return this._handle('listNetworkPools',
+            { params: params, options: options }, cb);
+    };
+
     // CNAPI
 
     mocks.cnapi = new Mock();
@@ -217,7 +227,6 @@ function createMocks() {
                 err.code = 'EEXIST';
                 return setImmediate(cb, err);
             }
-
             ROOT[dir] = {};
             return setImmediate(cb);
         },
@@ -318,6 +327,7 @@ function registerMocks() {
         'util',
         'vasync',
         'verror',
+        '../../lib/admin-pool-cache',
         '../../lib/boot-files',
         '../../lib/cache',
         '../../lib/dhcpd',
diff --git a/test/lib/server.js b/test/lib/server.js
index 16b79ae..71da90c 100644
--- a/test/lib/server.js
+++ b/test/lib/server.js
@@ -13,9 +13,11 @@
  */
 
 var assert = require('assert-plus');
+var vasync = require('vasync');
+var mod_log = require('./log');
 var mod_boot_files;
 var mod_dhcpd;
-var mod_log = require('./log');
+var adminPoolCache;
 
 
 
@@ -24,15 +26,17 @@ var mod_log = require('./log');
 
 
 var ADMIN_UUID = '930896af-bf8c-48d4-885c-6573a94b1853';
-var SERVER;
+var SERVER = {};
 
 
 
-function createServer() {
-    if (SERVER) {
+function createServer(config) {
+    if (SERVER === {}) {
         return;
     }
 
+    var log = mod_log.child({ component: 'test-server' });
+
     if (!mod_boot_files) {
         mod_boot_files = require('../../lib/boot-files');
     }
@@ -41,30 +45,61 @@ function createServer() {
         mod_dhcpd = require('../../lib/dhcpd');
     }
 
-    SERVER = mod_dhcpd.createServer({
-        config: serverConfig(),
-        log: mod_log.child({ component: 'test-server' })
+    if (!adminPoolCache) {
+        adminPoolCache = require('../../lib/admin-pool-cache');
+    }
+
+    var cache = adminPoolCache.create({
+        napi: config.opts.napi,
+        log: log,
+        cacheDir: config.poolCache.dir,
+        cacheUpdateInterval: config.poolCache.updateInterval
+    });
+
+    var dhcp = mod_dhcpd.createServer({
+        config: config,
+        log: log,
+        adminPoolCache: cache,
+        napi: config.opts.napi,
+        cnapi: config.opts.cnapi
     });
+
+    SERVER.dhcp = dhcp;
+    SERVER.cache = cache;
+    SERVER.log = log;
 }
 
+function destroyServer() {
+    SERVER.cache.quiesce();
+}
 
 function bootData(opts, callback) {
     assert.object(opts, 'opts');
     assert.string(opts.mac, 'opts.mac');
-    createServer();
-
-    SERVER.cnapi = opts.cnapi;
-    SERVER.napi = opts.napi;
-
-    mod_boot_files.writeAll({
-        config: serverConfig(),
-        cnapi: opts.cnapi,
-        log: mod_log.child({ mac: opts.mac }),
-        mac: opts.mac,
-        napi: opts.napi
-    }, callback);
-}
 
+    var config = serverConfig();
+    config.opts = opts;
+
+    createServer(config);
+    SERVER.cache.update(function (error) {
+        if (error) {
+            callback(error, null);
+        }
+
+        mod_boot_files.writeAll({
+            config: config,
+            cnapi: opts.cnapi,
+            log: mod_log.child({ mac: opts.mac }),
+            mac: opts.mac,
+            napi: opts.napi,
+            adminPoolCache: SERVER.cache,
+            nic_tag: opts.nic_tag
+        }, function (err, res) {
+            destroyServer();
+            callback(err, res);
+        });
+    });
+}
 
 function serverConfig() {
     return {
@@ -99,6 +134,10 @@ function serverConfig() {
             purgeIntervalSeconds: 36000,
             maxCacheFileAgeSeconds: 604800,
             refreshConcurrency: 1
+        },
+        poolCache: {
+            updateInterval: 60000,
+            dir: '/tmp/tftpboot/poolcache'
         }
     };
 }
