From 9c599c9b45fa9418f649b3f5b96b29d42689ed2e Mon Sep 17 00:00:00 2001
From: Rui Loura <rui@joyent.com>
Date: Mon, 8 Jan 2018 19:45:02 +0000
Subject: [PATCH] NET-384 sdc-booter should dump core on uncaught exception
 NET-385 sdc-booter panics while handling discover on log level trace NET-386
 booter should be able to handle option 82 as nictags

---
 .gitignore                    |   1 +
 README.md                     |   2 +-
 bin/dhcpd                     |   4 +-
 config.json.sample            |   3 +-
 lib/admin-pool-cache.js       | 168 ++++++++++++++++++++++++++++
 lib/boot-files.js             |   6 +-
 lib/booter.js                 |  20 +++-
 lib/bootparams.js             | 199 ++++++++++++++++++++++++----------
 lib/cache.js                  |  55 ++++++++++
 lib/dhcp.js                   |   8 +-
 lib/dhcpd.js                  | 164 ++++++++++++++++++++++++----
 lib/json-file.js              |  42 ++++++-
 lib/net-file.js               |  26 +++--
 package.json                  |   2 +
 sapi_manifests/dhcpd/template |   4 +
 server.js                     |  37 ++++++-
 test/bootparams.test.js       | 179 ++++++++++++++++++++++++++++--
 test/lib/file.js              |  26 ++++-
 test/lib/mocks.js             |  13 ++-
 test/lib/server.js            |  77 +++++++++----
 tools/jsl.node.conf           |   1 +
 21 files changed, 890 insertions(+), 147 deletions(-)
 create mode 100644 lib/admin-pool-cache.js

diff --git a/.gitignore b/.gitignore
index 41e4ef5..a8bff48 100644
--- a/.gitignore
+++ b/.gitignore
@@ -1,3 +1,4 @@
+*.swp
 /coverage
 /dhcpd-pkg-*.tar.bz2
 /node_modules
diff --git a/README.md b/README.md
index 92c0a7a..68a1108 100644
--- a/README.md
+++ b/README.md
@@ -72,7 +72,7 @@ Booter supports a few SAPI configuration values:
 
 - `http_pxe_boot`: if set to `true`, allow iPXE clients to pull down their
   files via HTTP rather than TFTP
-- `compute_node_default_gateway`: set this to give Compute Nodess a
+- `compute_node_default_gateway`: set this to give Compute Nodes a
   default gateway
 - `dhcp_lease_time`: DHCP lease time for Compute Nodes
 - `allow_missing_class_id`: booter only allows clients with class identifiers
diff --git a/bin/dhcpd b/bin/dhcpd
index 3e21437..47179d6 100755
--- a/bin/dhcpd
+++ b/bin/dhcpd
@@ -6,7 +6,7 @@
 #
 
 #
-# Copyright (c) 2014, Joyent, Inc.
+# Copyright (c) 2018, Joyent, Inc.
 #
 
 TOP=$(unset CDPATH; cd $(dirname $0)/../; pwd)
@@ -16,4 +16,4 @@ if [[ ! -d "${NODE_INSTALL}" && -d "${TOP}/build/node" ]]; then
     NODE_INSTALL=${TOP}/build/node
 fi
 
-${NODE_INSTALL}/bin/node ${TOP}/server.js "$@"
+${NODE_INSTALL}/bin/node --abort-on-uncaught-exception ${TOP}/server.js "$@"
diff --git a/config.json.sample b/config.json.sample
index 8feea4c..00b87aa 100644
--- a/config.json.sample
+++ b/config.json.sample
@@ -16,5 +16,6 @@
   "defaultGateway": "10.99.99.7",
   "serverIp": "10.99.99.11",
   "leaseTime": 3600,
-  "netmask": "255.255.255.0"
+  "netmask": "255.255.255.0",
+  "updateCacheInterval": 60000
 }
diff --git a/lib/admin-pool-cache.js b/lib/admin-pool-cache.js
new file mode 100644
index 0000000..3521e2c
--- /dev/null
+++ b/lib/admin-pool-cache.js
@@ -0,0 +1,168 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+/*
+ * Copyright (c) 2018, Joyent, Inc.
+ */
+
+
+/*
+ * This cache is intended to minimize the impact on NAPI when booting a new
+ * rack of CNs.  We accomplish this by caching the 'admin' network pool
+ * information so that we can avoid calling NAPI.listNetworkPools() for each
+ * booting CN.
+ *
+ * The location of the admin network pool cache and it's update interval are
+ * specified in the config file.
+ */
+var assert = require('assert-plus');
+var vasync = require('vasync');
+var mod_json = require('./json-file');
+
+
+/*
+ * Internal
+ */
+function _readCache(opts, cb) {
+    mod_json.read({
+        dir: opts.cacheDir,
+        name: opts.filename,
+        log: opts.log
+    }, function (err, data) {
+        cb(err, data);
+        return;
+    });
+}
+
+function _resetTimeout() {
+    clearTimeout(this.timeoutId);
+    this.timeoutId = setTimeout(this.updateWorker.bind(this),
+        this.updateInterval);
+    this.timeoutId.unref();
+}
+
+
+/*
+ * Initialize AdminPoolCache and start periodic updater.
+ */
+function AdminPoolCache(config) {
+    this._cache = {};
+    this.log = config.log;
+    this.napi = config.napi;
+    this.updateInterval = config.cacheUpdateIntervalSeconds * 1000;
+    this.filename = 'admin_network_pool';
+    this.cacheDir = config.cacheDir;
+    _resetTimeout.call(this);
+    /*
+     * this.timeoutId = setTimeout(this.updateWorker.bind(this),
+     *   this.updateInterval);
+     * this.timeoutId.unref();
+     */
+    Object.seal(this);
+}
+
+/*
+ * Update AdminPoolCache.
+ */
+AdminPoolCache.prototype.update = function update(callback) {
+    var napi = this.napi;
+    var self = this;
+
+    assert.func(callback, 'callback');
+
+    var resetTimeout = _resetTimeout.bind(this);
+    // Callbacks are called via readCache and writeCache
+    var writeCache = function (payload) {
+        mod_json.write({
+            dir: self.cacheDir,
+            log: self.log,
+            name: self.filename,
+            payload: payload
+        }, function (writeErr) {
+            callback(writeErr, payload);
+            return;
+        });
+    };
+
+    var opts = {
+        cacheDir: self.cacheDir,
+        filename: self.filename,
+        log: self.log
+    };
+
+    napi.listNetworkPools({name: 'admin'}, null, function (err, res) {
+        // If there was an error, don't alter the cache.
+        if (err || !Array.isArray(res)) {
+            self.log.error({ err: err }, 'NAPI Error');
+            resetTimeout();
+            _readCache(opts, callback);
+            return;
+        }
+
+        if (res.length > 1) {
+            self.log.error({
+                pools: res
+            }, 'More than one network pool found for "admin"');
+            resetTimeout();
+            _readCache(opts, callback);
+            return;
+        }
+
+        /*
+         * If NAPI is error free, but there isn't an admin network pool, clear
+         * the cache.
+         */
+        if (res.length === 0) {
+            resetTimeout();
+            writeCache({});
+            return;
+        }
+
+        resetTimeout();
+        writeCache(res[0]);
+        return;
+    });
+};
+
+AdminPoolCache.prototype.updateWorker = function updateWorker() {
+    var self = this;
+    this.update(function (err, data) {
+        if (err) {
+            self.log.error({error: err, cache: data},
+                'Periodic Admin Pool Cache update failed to write cache');
+        } else {
+            self.log.info({cache: data},
+                'Periodic Admin Pool Cache update complete');
+        }
+    });
+};
+
+AdminPoolCache.prototype.readCache = function (callback) {
+    var self = this;
+
+    var opts = {
+        cacheDir: self.cacheDir,
+        filename: self.filename,
+        log: self.log
+    };
+
+    /*
+     * Read the cache.  If we fail a read due to a missing file, update the
+     * cache (which does an implicit read).
+     */
+    _readCache(opts, function (err, data) {
+        if (err && err.code === 'ENOENT') {
+            self.update(callback);
+            return;
+        }
+        callback(err, data);
+    });
+};
+
+module.exports = {
+    create: function (config) {
+        return new AdminPoolCache(config);
+    }
+};
diff --git a/lib/boot-files.js b/lib/boot-files.js
index ce559d6..5c94d9b 100644
--- a/lib/boot-files.js
+++ b/lib/boot-files.js
@@ -39,7 +39,9 @@ function extractBootOpts(opts) {
         log: opts.log,
         napi: opts.napi,
         mac: opts.mac,
-        tftpRoot: opts.config.tftpRoot
+        tftpRoot: opts.config.tftpRoot,
+        nic_tag: opts.nic_tag,
+        adminPoolCache: opts.adminPoolCache
     };
 
     if (opts.mac) {
@@ -95,6 +97,7 @@ function writeBootFiles(opts, callback) {
             });
         },
 
+        // Write out networking.json file.
         function _bootTimeFile(arg, cb) {
             mod_net_file.write(arg, function (err) {
                 // Don't let this hold up booting - we can always fall back to
@@ -103,6 +106,7 @@ function writeBootFiles(opts, callback) {
             });
         },
 
+        // Make sure networking.json file is in the bootFsDir.
         function _bootFsFiles(arg, cb) {
             mod_find.files(arg, function (err, files) {
                 if (err) {
diff --git a/lib/booter.js b/lib/booter.js
index f278a21..14aa663 100644
--- a/lib/booter.js
+++ b/lib/booter.js
@@ -20,6 +20,7 @@ var menu = require('./menulst');
 var mod_cache = require('./cache');
 var mod_clients = require('./clients');
 var path = require('path');
+var AdminPoolCache = require('./admin-pool-cache');
 
 
 
@@ -49,6 +50,13 @@ function main() {
         }
     });
 
+    var adminPoolCache = AdminPoolCache.create({
+        napi: napi,
+        log: log,
+        cacheDir: config.poolCache.dir,
+        cacheUpdateIntervalSeconds: config.poolCache.updateIntervalSeconds
+    });
+
     switch (process.argv[2]) {
     case 'ping-napi':
         napi.ping(standardHandler);
@@ -64,7 +72,8 @@ function main() {
             napi: napi,
             cnapi: cnapi,
             log: log,
-            pipelineTimeoutSeconds: -1
+            pipelineTimeoutSeconds: -1,
+            adminPoolCache: adminPoolCache
         }, standardHandler);
         break;
     case 'bootparams-cnapi':
@@ -78,7 +87,8 @@ function main() {
             mac: getArg('MAC address'),
             napi: napi,
             cnapi: cnapi,
-            log: log
+            log: log,
+            adminPoolCache: adminPoolCache
         }, function (err, res) {
             if (err) {
                 return console.error(err.code + ': ' + err.message);
@@ -100,7 +110,8 @@ function main() {
             mac: getArg('MAC address'),
             napi: napi,
             cnapi: cnapi,
-            log: log
+            log: log,
+            adminPoolCache: adminPoolCache
         }, function (err, res) {
             if (err) {
                 return console.error(err.code + ': ' + err.message);
@@ -114,7 +125,8 @@ function main() {
     case 'full-cache-refresh':
         var cacheSentinel = new mod_cache.CacheSentinel({
             log: log, cnapi: cnapi, napi: napi,
-            adminUuid: config.adminUuid, cacheConfig: config.cache});
+            adminUuid: config.adminUuid, cacheConfig: config.cache,
+            adminPoolCache: adminPoolCache});
         cacheSentinel.refreshCache();
         break;
     default:
diff --git a/lib/bootparams.js b/lib/bootparams.js
index ab875c0..17eed28 100644
--- a/lib/bootparams.js
+++ b/lib/bootparams.js
@@ -14,6 +14,7 @@
 
 var assert = require('assert-plus');
 var fs = require('fs');
+var jsprim = require('jsprim');
 var mod_clients = require('./clients');
 var mod_json = require('./json-file');
 var util = require('util');
@@ -26,25 +27,6 @@ var verror = require('verror');
 
 
 
-/**
- * Return an object mapping foo_nic to aggregation name
- */
-function aggrsToTags(aggrs) {
-    var agTag = {};
-
-    aggrs.forEach(function (ag) {
-        if (ag.hasOwnProperty('nic_tags_provided')) {
-
-            ag.nic_tags_provided.forEach(function (t) {
-                agTag[t + '_nic'] = ag.name;
-            });
-        }
-    });
-
-    return agTag;
-}
-
-
 /**
  * Return an object mapping MAC addresses to the names of their parent
  * aggregations
@@ -72,37 +54,34 @@ function getFromCache(opts, callback) {
     assert.string(opts.mac, 'opts.mac');
     assert.optionalObject(opts.err, 'opts.err');
 
-    var dir = opts.dir;
     var log = opts.log;
+    var dir = opts.dir;
     var mac = opts.mac;
     var originalErr = opts.err;
 
-    var file = util.format('%s/%s.json', dir, mac);
-    fs.readFile(file, function (err, data) {
+    mod_json.read({
+        dir: dir,
+        name: mac,
+        log: log
+    }, function (err, data) {
         if (err) {
-            log.error(err,
-                'getFromCache: MAC "%s": error getting cached params from "%s"',
-                mac, file);
-            return callback(originalErr);
+            callback(originalErr);
+            return;
         }
 
-        var params;
-        try {
-            params = JSON.parse(data);
-        } catch (err2) {
-            log.error(err2,
-                'getFromCache: MAC "%s": error parsing JSON from "%s"',
-                mac, file);
-
-            return callback(originalErr);
-        }
+        log.debug(data, 'getFromCache: got cached params from "%s/%s.json"',
+            dir, mac);
 
-        log.debug(params, 'getFromCache: MAC "%s": got cached params from "%s"',
-            mac, file);
-        return callback(null, { bootParams: params });
+        return callback(null, { bootParams: data });
     });
 }
 
+function poolContainsTag(pool, tag) {
+    return (pool &&
+        pool.hasOwnProperty('nic_tags_present') &&
+        pool.nic_tags_present.indexOf(tag) !== -1);
+}
+
 
 // --- Exported functions
 
@@ -121,6 +100,7 @@ function getBootParams(opts, callback) {
     assert.object(opts.napi, 'opts.napi');
     assert.optionalNumber(opts.pipelineTimeoutSeconds,
                           'opts.pipelineTimeoutSeconds');
+    assert.object(opts.adminPoolCache, 'opts.adminPoolCache');
 
     var cacheDir = opts.cacheDir;
     var adminUuid = opts.adminUuid;
@@ -128,6 +108,7 @@ function getBootParams(opts, callback) {
     var log = opts.log;
     var mac = opts.mac;
     var napi = opts.napi;
+    var adminPoolCache = opts.adminPoolCache;
 
     /*
      * getBootParams performs several calls to external services (e.g. napi &
@@ -172,16 +153,45 @@ function getBootParams(opts, callback) {
     var uuid;
     var params = null;
     var vArg = {
-        adminUuid: opts.adminUuid,
+        adminUuid: opts.adminUuid, // admin user not network
         bootNic: null,
         log: opts.log,
-        napi: opts.napi
+        napi: opts.napi,
+        network_uuid: 'admin',
+        adminPool: null,
+        nic_tag: opts.nic_tag
     };
 
     vasync.pipeline({
         arg: vArg,
         funcs: [
+            /*
+             * Make sure we have the latest adminPoolCache data.  We use this
+             * not only on initial admin nic provision (for a new CN), but also
+             * for returning nics that may have changed nic tags since initial
+             * provision and before the adminPoolCache has updated.
+             *
+             * If we encounter an error here we log it and move on, because we
+             * may not even need the admin network pool info to boot this CN.
+             */
+            function _readAdminPoolCache(fArg, cb) {
+                adminPoolCache.readCache(function (err, pool) {
+                    if (err) {
+                        log.error({err: err}, 'Error getting adminPoolCache');
+                        cb();
+                        return;
+                    }
+
+                    if (jsprim.isEmpty(pool) || !pool.nic_tags_present) {
+                        cb();
+                        return;
+                    }
 
+                    fArg.adminPool = pool;
+                    cb();
+                    return;
+                });
+            },
             // Get nic data from NAPI for the given MAC
             function _getNic(fArg, cb) {
                 napi.getNic(mac, function (err, res) {
@@ -201,20 +211,53 @@ function getBootParams(opts, callback) {
                 });
             },
 
+            /*
+             * If the boot nic exists but doesn't have an ip, or if it doesn't
+             * exist at all, check if we have specified an alternate admin
+             * nictag, and if so look for it in the 'admin' network pool.  If
+             * the tag exists in the 'admin' network pool, subsequent steps in
+             * this chain will provision the nic and IP on a network from the
+             * 'admin' network pool.
+             */
+            function _checkAdminPoolCache(fArg, cb) {
+                if (fArg.bootNic !== null && fArg.bootNic.ip) {
+                    cb();
+                    return;
+                }
+
+                if (!fArg.nic_tag) {
+                    fArg.nic_tag = 'admin';
+                    cb();
+                    return;
+                }
+
+                log.info('bootNic not found, checking for admin network pool');
+
+                if (poolContainsTag(fArg.adminPool, fArg.nic_tag)) {
+                    fArg.network_uuid = fArg.adminPool.uuid;
+                }
+
+                cb();
+                return;
+            },
+
             // If the nic exists in NAPI but it doesn't have an IP, give it one
             function _provisionIP(fArg, cb) {
                 if (fArg.bootNic === null || fArg.bootNic.ip) {
                     return cb();
                 }
 
+                assert(fArg.bootNic.network_uuid === undefined,
+                    'network_uuid undefined');
                 var putParams = {
-                    network_uuid: 'admin'
+                    network_uuid: fArg.network_uuid,
+                    nic_tag: fArg.nic_tag
                 };
 
                 log.debug(putParams, 'Updating nic "%s" to add IP', mac);
                 napi.updateNic(mac, putParams, function (err, res) {
                     if (err) {
-                        log.error({ err: err, params: putParams},
+                        log.error({err: err, params: putParams},
                             'Error adding IP to nic "%s" on NAPI', mac);
                         return cb(err);
                     }
@@ -229,7 +272,7 @@ function getBootParams(opts, callback) {
             },
 
             // If the nic doesn't exist in NAPI, provision it on the admin
-            // network, which will give it an IP
+            // network (or pool), which will give it an IP
             function _createNic(fArg, cb) {
                 if (fArg.bootNic !== null) {
                     return cb();
@@ -240,9 +283,15 @@ function getBootParams(opts, callback) {
                     belongs_to_uuid: adminUuid,
                     belongs_to_type: 'other',
                     mac: mac,
-                    nic_tags_provided: [ 'admin' ]
+                    nic_tags_provided: [ fArg.nic_tag ],
+                    nic_tag: fArg.nic_tag
                 };
-                napi.provisionNic('admin', postParams, function (err, res) {
+
+                log.info(postParams, 'Provisioning admin nic on network %s',
+                    fArg.network_uuid);
+
+                napi.provisionNic(fArg.network_uuid, postParams,
+                    function (err, res) {
                     if (err) {
                         log.error(err,
                             'Error provisioning admin nic "%s" on NAPI', mac);
@@ -350,18 +399,28 @@ function getBootParams(opts, callback) {
         }
 
         var adminNic = vArg.bootNic;
-        var aggrTags = aggrsToTags(vArg.aggrs);
+        var adminPool = vArg.adminPool;
+        var aggrs = vArg.aggrs;
         var bootNic = vArg.bootNic;
         var macAggrs = macsToAggrs(vArg.aggrs);
         var nics = vArg.nics;
         var overridden = {};
         var seen = {};
+        var adminFound = false;
         var tag;
 
         params.ip = bootNic.ip;
         params.netmask = bootNic.netmask;
         params.resolvers = bootNic.resolvers;
 
+        if (bootNic.gateway) {
+            params.gateway = bootNic.gateway;
+        }
+
+        if (bootNic.routes) {
+            params.routes = bootNic.routes;
+        }
+
         // Allow kernel_args from CNAPI to override the nic tag values, but
         // dutifully complain about it
         if (params.kernel_args.hasOwnProperty('admin_nic')) {
@@ -386,8 +445,10 @@ function getBootParams(opts, callback) {
                 continue;
             }
 
-            for (var t in nic.nic_tags_provided) {
-                tag = nic.nic_tags_provided[t] + '_nic';
+            for (var tg in nic.nic_tags_provided) {
+                var nictag = nic.nic_tags_provided[tg];
+                tag = nictag + '_nic';
+
                 if (params.kernel_args.hasOwnProperty(tag)) {
                     overridden[tag] = 1;
                 } else {
@@ -396,8 +457,19 @@ function getBootParams(opts, callback) {
                     }
                 }
 
-                if (tag == 'admin_nic') {
-                    adminNic = nic;
+                /*
+                 * Check for the nic tagged with 'admin' or any nic tagged with
+                 * a network that is in the admin network pool.  We do the same
+                 * below for aggrs.
+                 */
+                if (tag == 'admin_nic' ||
+                    poolContainsTag(adminPool, nictag)) {
+                        if (adminFound) {
+                            log.warn({orig_admin: adminNic, new_admin: nic},
+                                'second admin nic found');
+                        }
+                        adminNic = nic;
+                        adminFound = true;
                 }
             }
 
@@ -405,11 +477,21 @@ function getBootParams(opts, callback) {
         }
 
         // Now go through and assign nic tags to aggregations
-        for (tag in aggrTags) {
-            if (!params.kernel_args.hasOwnProperty(tag)) {
-                params.kernel_args[tag] = aggrTags[tag];
+        aggrs.forEach(function (ag) {
+            if (ag.hasOwnProperty('nic_tags_provided')) {
+                ag.nic_tags_provided.forEach(function (t) {
+                    var ntag = t + '_nic';
+
+                    if (!params.kernel_args.hasOwnProperty(ntag)) {
+                        params.kernel_args[ntag] = ag.name;
+                    }
+
+                    if (poolContainsTag(adminPool, t)) {
+                        adminFound = true;
+                    }
+                });
             }
-        }
+        });
 
         // Add aggregation boot parameters
         for (var a in vArg.aggrs) {
@@ -424,9 +506,9 @@ function getBootParams(opts, callback) {
 
         // If we don't have admin nic from NAPI, then set it to the nic
         // we booted from: this is likely the first boot
-        if (!params.kernel_args.hasOwnProperty('admin_nic')) {
-            params.kernel_args.admin_nic = bootNic.mac;
-            seen[bootNic.mac] = 1;
+        if (!adminFound && !params.kernel_args.hasOwnProperty('admin_nic')) {
+                params.kernel_args.admin_nic = bootNic.mac;
+                seen[bootNic.mac] = 1;
         }
 
         if (Object.keys(overridden).length !== 0) {
@@ -450,6 +532,7 @@ function getBootParams(opts, callback) {
                 aggrs: vArg.aggrs,
                 bootParams: params,
                 nics: nics,
+                adminPool: adminPool,
                 nictags: vArg.nictags
             });
         });
diff --git a/lib/cache.js b/lib/cache.js
index aed0a6c..b062c26 100644
--- a/lib/cache.js
+++ b/lib/cache.js
@@ -14,6 +14,7 @@
 // stdlib
 const fs = require('fs');
 const path = require('path');
+const jsprim = require('jsprim');
 
 // npm
 var assert = require('assert-plus');
@@ -22,6 +23,7 @@ const verror = require('verror');
 
 // local
 const mod_bootparams = require('./bootparams');
+const mod_json = require('./json-file');
 
 
 /*
@@ -64,6 +66,7 @@ function CacheSentinel(opts) {
     assert.object(opts.log, 'opts.log');
     assert.object(opts.cnapi, 'opts.cnapi');
     assert.object(opts.napi, 'opts.napi');
+    assert.object(opts.adminPoolCache, 'opts.adminPoolCache');
     assert.uuid(opts.adminUuid, 'opts.adminUuid');
 
     assert.object(opts.cacheConfig, 'opts.cacheConfig');
@@ -89,6 +92,7 @@ function CacheSentinel(opts) {
     this.cnapi = opts.cnapi;
     this.napi = opts.napi;
     this.adminUuid = opts.adminUuid;
+    this.adminPoolCache = opts.adminPoolCache;
 
     this.cacheDir = opts.cacheConfig.dir;
     this.refreshInterval = opts.cacheConfig.refreshIntervalSeconds * 1000;
@@ -164,6 +168,56 @@ CacheSentinel.prototype.refreshCache = function refreshCache() {
                         return next();
                     });
             },
+            function stepAppendAdminPoolNics(ctx, next) {
+                self.adminPoolCache.update(function (err, data) {
+                    if (err || jsprim.isEmpty(data) ||
+                        !data.hasOwnProperty('networks') ||
+                        !data.hasOwnProperty('nic_tags_present') ||
+                        data.nic_tags_present.length === 0) {
+
+                        self.log.info({err: err, data: data},
+                            'No admin pool cache, ignoring.');
+
+                        // ignore error reading from admin pool cache
+                        next();
+                        return;
+                    }
+
+                    var pooltags = data.nic_tags_present;
+                    const filterAdminPoolNics = function (net, cb) {
+                        self.napi.listNics({network_uuid: net},
+                            function (e, res) {
+
+                            if (e) {
+                                cb(new verror.VError(e,
+                                    'unable to list admin pool nics'));
+                                return;
+                            }
+
+                            res.forEach(function (nic) {
+                                if (pooltags.indexOf(nic.nic_tag) !== -1) {
+                                    ctx.nics.push(nic);
+                                }
+                            });
+                            cb();
+                            return;
+                        });
+                    };
+
+                    vasync.forEachParallel({
+                        func: filterAdminPoolNics,
+                        inputs: data.networks
+                    }, function (e, res) {
+                        if (e) {
+                            // Only error out if there is an issue with NAPI
+                            next(e);
+                            return;
+                        }
+                        next();
+                        return;
+                    });
+                });
+            },
             function stepFilterToMacs(ctx, next) {
                 const serverUUIDs = ctx.servers.map(function (s) {
                     return s.uuid;
@@ -191,6 +245,7 @@ CacheSentinel.prototype.refreshCache = function refreshCache() {
                         napi: self.napi,
                         cnapi: self.cnapi,
                         log: self.log,
+                        adminPoolCache: self.adminPoolCache,
                         pipelineTimeout: -1
                     }, cb);
                 }, self.refreshConcurrency);
diff --git a/lib/dhcp.js b/lib/dhcp.js
index 42c55aa..589bfae 100644
--- a/lib/dhcp.js
+++ b/lib/dhcp.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2015, Joyent, Inc.
+ * Copyright (c) 2018, Joyent, Inc.
  */
 
 /*
@@ -362,6 +362,10 @@ function createDHCPreply(packet, data) {
                         pkt.options[opt] = pack.unpack('CCCC',
                                 pack.pack('N', parseInt(value, 10)));
                         break;
+                    // pass through
+                    case 82: // DHCP Relay
+                        pkt.options[opt] = value;
+                        break;
                     default:
                         throw new Error('Ignoring unhandled option ' + opt);
                 }
@@ -424,7 +428,7 @@ function parseDHCPpacket(data) {
     while (i < res.length) {
             var option = parseInt(res[i++], 10);
             if (option === 0) {
-                    continue;
+                continue;
             }
 
             if (option == 255) {
diff --git a/lib/dhcpd.js b/lib/dhcpd.js
index 25d3a78..003cefc 100755
--- a/lib/dhcpd.js
+++ b/lib/dhcpd.js
@@ -19,6 +19,7 @@ var fmt = require('util').format;
 var fs = require('fs');
 var dgram = require('dgram');
 var dhcp = require('./dhcp');
+var ip6addr = require('ip6addr');
 var mod_boot_files = require('./boot-files');
 var mod_bootparams = require('./bootparams');
 var mod_cache = require('./cache');
@@ -37,14 +38,24 @@ var uuid = require('node-uuid');
  */
 function DHCPD(opts) {
     this.config = opts.config;
-
-    this.cnapi = mod_clients.createCNAPIclient(this.config);
     this.log = opts.log;
-    this.napi = mod_clients.createNAPIclient(this.config);
+    this.adminPoolCache = opts.adminPoolCache;
+
+    if (opts.napi) {
+        this.napi = opts.napi;
+    } else {
+        this.napi = mod_clients.createNAPIclient(this.config);
+    }
 
+    if (opts.cnapi) {
+        this.cnapi = opts.cnapi;
+    } else {
+        this.cnapi = mod_clients.createCNAPIclient(this.config);
+    }
     this.cacheSentinel = new mod_cache.CacheSentinel(
         {log: this.log, cnapi: this.cnapi, napi: this.napi,
-         adminUuid: this.config.adminUuid, cacheConfig: this.config.cache});
+         adminUuid: this.config.adminUuid, cacheConfig: this.config.cache,
+         adminPoolCache: this.adminPoolCache});
 }
 
 
@@ -59,7 +70,7 @@ DHCPD.prototype.start = function () {
     });
 
     this.sock.on('listening', function () {
-        self.sock.setTTL(128);  // XXX Doesn't work! :( Bug in node?
+        self.sock.setTTL(128);  // Only for unicast replies.
         self.sock.setBroadcast(true);
         self.log.info('dhcpd started on %s:%d',
             self.config.listenIp, self.config.port);
@@ -77,14 +88,20 @@ DHCPD.prototype.handleMessage = function (msg, peer) {
     var packet = dhcp.parse(msg);
     var mac = packet.chaddr;
     var log = this.log.child({ mac: mac, req_id: uuid()});
+    var nictag;
     log.info('source address="%s:%d"', peer.address, peer.port);
 
     // Print the whole packet in hex
     if (log.trace()) {
+        var str_buf;
         for (var i = 0; i < msg.length; i += 4) {
-            // XXX
-            this.log.trace(sprintf('[%03d]: 0x%02x 0x%02x 0x%02x 0x%02x',
-                i, msg[i], msg[i+1], msg[i+2], msg[i+3]));
+            str_buf = '';
+            str_buf += sprintf('[%03d]:', i);
+
+            for (var j = 0; j < Math.min(4, msg.length - i); j++) {
+                str_buf += sprintf(' 0x%02x', msg[i + j]);
+            }
+            this.log.trace(str_buf);
         }
     }
 
@@ -128,19 +145,74 @@ DHCPD.prototype.handleMessage = function (msg, peer) {
             + 'identifier');
     }
 
+    /*
+     * This block decodes option 82 which has multiple sub-options.  If we
+     * decide to extend booter to be a full fledged, DHCP server then we should
+     * create decoders for each option in dhcp.js.  But at this time, option 82
+     * is the only option we support that leverages suboptions (excepting the
+     * widely misused option 77).
+     *
+     * [<option id>, <option length>, <variable length option data>]
+     */
+    if (packet.options[82]) {
+        log.info({option_82: packet.options[82]}, 'Found DHCP Option 82, '
+            + 'getting sub-options');
+
+        var relayopt = packet.options[82];
+        var suboptlen;
+        var suboptid;
+        var subopt;
+        while (relayopt.length > 0) {
+            try {
+                /* Shift off the suboption id. */
+                suboptid = relayopt.shift();
+
+                /* Shift off the suboption length. */
+                suboptlen = relayopt.shift();
+
+                /* get suboption payload */
+                subopt = relayopt.slice(0, suboptlen);
+
+                /* strip suboption off of relay option */
+                relayopt = relayopt.slice(suboptlen);
+
+                /* We only support sub-option 1. */
+                if (suboptid !== 1) {
+                    log.warn('Option 82: found unsupported sub-option (%d), '
+                        + 'skipping', suboptid);
+
+                    continue;
+                }
+
+                nictag = new Buffer(subopt).toString();
+                log.info('Found circuit-id from Option 82:', nictag);
+            } catch (e) {
+                log.error({error: e}, 'Error parsing option 82');
+                break;
+            }
+        }
+    }
+
+    if (nictag &&
+        nictag.toUpperCase().search(/^ADMIN_RACK_[A-Z0-9_-]+$/) !== 0) {
 
+        nictag = 'admin_rack_' + nictag;
+        log.info('Prepending "admin_rack_" to circuit-id, nictag is now:',
+            nictag);
+    }
 
     var _sendReplyWithParams = function (params) {
         var packetOpts = self.buildPacketOpts(packet, params.bootParams, log);
-        self.sendReply(packet, packetOpts, log, function (sendErr) {
-            if (sendErr) {
-                log.error(sendErr, 'Error sending reply');
-                return;
-            }
+        self.sendReply(peer, packet, packetOpts, log, function (sendErr) {
+                if (sendErr) {
+                    log.error(sendErr, 'Error sending reply');
+                    return;
+                }
 
             log.info('Reply sent');
         });
     };
+
     /*
      * Booter handles only two types of DHCP messages: DHCPDISCOVER and
      * DHCPREQUEST (coming in that order).  On the initial DHCPDISCOVER,
@@ -154,6 +226,8 @@ DHCPD.prototype.handleMessage = function (msg, peer) {
             config: self.config,
             log: log,
             mac: mac,
+            nic_tag: nictag,
+            adminPoolCache: self.adminPoolCache,
             napi: self.napi
         }, function _afterParams(pErr, params) {
             if (pErr) {
@@ -181,10 +255,11 @@ DHCPD.prototype.handleMessage = function (msg, peer) {
 /*
  * Sends the DHCP reply
  */
-DHCPD.prototype.sendReply = function (packet, packetOpts, log, callback) {
+DHCPD.prototype.sendReply = function (peer, packet, packetOpts, log, callback) {
     var mac = packet.chaddr;
     var port = 68;
-    var broadcastAddr = '255.255.255.255';
+    var addr = '255.255.255.255';
+    var msg = 'broadcast';
 
     var outPacket = dhcp.createReplyPacket(packet, packetOpts);
     var outBuf = outPacket.toBuffer();
@@ -192,11 +267,20 @@ DHCPD.prototype.sendReply = function (packet, packetOpts, log, callback) {
         log.debug(outPacket.toObject(), 'Packet options');
     }
 
-    log.info('Sending broadcast ("%s:%d") reply to MAC "%s"',
-        broadcastAddr, port, mac);
+    /*
+     * Per 2131 sect 4.1, we should be able to use giaddr for the destination
+     * address, but in practice that field is populated with the IP on which
+     * the relay received the client's DHCPDISCOVER.  So instead we just reply
+     * to the peer's source address.
+     */
+    if (packet.options[82]) {
+        msg = 'unicast';
+        addr = peer.address;
+        port = peer.port;
+    }
 
-    this.sock.send(outBuf, 0, outBuf.length, port, broadcastAddr,
-        function (err, bytes) {
+    log.info('Sending %s ("%s:%d") reply to MAC "%s"', msg, addr, port, mac);
+    this.sock.send(outBuf, 0, outBuf.length, port, addr, function (err, bytes) {
         if (err) {
             log.error(err, 'Error sending reply to "%s"', mac);
         } else {
@@ -216,6 +300,7 @@ DHCPD.prototype.buildPacketOpts = function (packet, params, log) {
     var responseType = msgType == 'DHCPDISCOVER' ? 'DHCPOFFER' : 'DHCPACK';
     var mac = packet.chaddr;
     var resolvers = [];
+    var serverIp = this.config.serverIp;
 
     var packetOpts = {
         'siaddr': this.config.serverIp,
@@ -225,11 +310,43 @@ DHCPD.prototype.buildPacketOpts = function (packet, params, log) {
             '1': params.netmask || this.config.netmask,
             '51': this.config.leaseTime,
             '53': responseType,
-            '54': this.config.serverIp
+            '54': serverIp
         }
     };
 
-    if (this.config.defaultGateway) {
+    function _findRouteToBooter(routes) {
+        var dests = Object.keys(routes);
+        for (var d in dests) {
+            var dest = dests[d];
+            var cidr = ip6addr.createCIDR(dest);
+            if (cidr.contains(serverIp)) {
+                return routes[dest];
+            }
+        }
+
+        log.error({routes: routes},
+            'Could not find route to booter in network\'s routes');
+
+        return '';
+    }
+    /*
+     * If option 82 (circuit id) and giaddr are both set that means the CN
+     * is behind a DHCP relay and we need to provide it a different gateway IP.
+     * If the nic's network is configured with a gateway, then we use that one.
+     * If not we assume the route is already added to the napi network and we
+     * pull it out of the routes object.  Note that the relay may have set
+     * giaddr to the same IP as the client's gateway.  However, RFC 2131 sect
+     * 4.1 states that the giaddr should be used as the destination IP for
+     * dhcpd server reply traffic, so we can't depend on that.
+     */
+    if (packet.options[82] && packet.giaddr) {
+        var giaddr = ip6addr.parse(packet.giaddr).toString();
+
+        packetOpts['giaddr'] = giaddr;
+        packetOpts['options']['3'] = params.gateway ? params.gateway :
+            _findRouteToBooter(params.routes);
+        packetOpts['options']['82'] = packet.options[82];
+    } else if (this.config.defaultGateway) {
         packetOpts['options']['3'] = this.config.defaultGateway;
     }
 
@@ -278,6 +395,7 @@ function createServer(opts) {
     assert.optionalObject(opts.config, 'opts.config');
     assert.optionalString(opts.configFile, 'opts.configFile');
     assert.object(opts.log, 'opts.log');
+    assert.object(opts.adminPoolCache, 'opts.adminPoolCache');
 
     var config;
     var log = opts.log;
@@ -312,7 +430,9 @@ function createServer(opts) {
     log.info({ config: config }, 'server config loaded');
     return new DHCPD({
         log: log,
-        config: config
+        config: config,
+        adminPoolCache: opts.adminPoolCache,
+        napi: opts.napi
     });
 }
 
diff --git a/lib/json-file.js b/lib/json-file.js
index ad48f04..413486e 100644
--- a/lib/json-file.js
+++ b/lib/json-file.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2014, Joyent, Inc.
+ * Copyright (c) 2018, Joyent, Inc.
  */
 
 /*
@@ -23,6 +23,35 @@ var mod_vasync = require('vasync');
 // --- Exports
 
 
+function readJSONfile(opts, callback) {
+    assert.object(opts, 'opts');
+    assert.string(opts.dir, 'opts.dir');
+    assert.object(opts.log, 'opts.log');
+    assert.string(opts.name, 'opts.name');
+
+    var file = fmt('%s/%s.json', opts.dir, opts.name);
+    var log = opts.log;
+
+    mod_fs.readFile(file, function (err, data) {
+        if (err) {
+            log.error(err,
+                'readJSONfile: error getting cached params from "%s"', file);
+            callback(err);
+            return;
+        }
+
+        var json_data;
+        try {
+            json_data = JSON.parse(data);
+        } catch (err2) {
+            log.error(err2, 'readJSONfile: error parsing JSON from "%s"', file);
+            callback(err2);
+            return;
+        }
+        callback(null, json_data);
+        return;
+    });
+}
 
 function writeJSONfile(opts, callback) {
     assert.object(opts, 'opts');
@@ -31,6 +60,8 @@ function writeJSONfile(opts, callback) {
     assert.string(opts.name, 'opts.name');
     assert.object(opts.payload, 'opts.payload');
 
+    var data;
+
     mod_vasync.pipeline({
         'funcs': [
             function _mkdir(_, cb) {
@@ -50,8 +81,8 @@ function writeJSONfile(opts, callback) {
 
             function _writeFile(_, cb) {
                 var file = fmt('%s/%s.json', opts.dir, opts.name);
-                mod_fs.writeFile(file, JSON.stringify(opts.payload, null, 2),
-                    function (err) {
+                data = JSON.stringify(opts.payload, null, 2);
+                mod_fs.writeFile(file, data, function (err) {
                     if (err) {
                         opts.log.error(err, 'Error writing "%s"', file);
                         return cb(err);
@@ -63,11 +94,12 @@ function writeJSONfile(opts, callback) {
             }
         ]
     }, function (err) {
-        return callback(err, opts.payload);
+        return callback(err, data);
     });
 }
 
 
 module.exports = {
-    write: writeJSONfile
+    write: writeJSONfile,
+    read: readJSONfile
 };
diff --git a/lib/net-file.js b/lib/net-file.js
index 8add89a..31f3142 100644
--- a/lib/net-file.js
+++ b/lib/net-file.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2015, Joyent, Inc.
+ * Copyright (c) 2018, Joyent, Inc.
  */
 
 /*
@@ -15,7 +15,7 @@
 var assert = require('assert-plus');
 var fmt = require('util').format;
 var mod_crypto = require('crypto');
-var mod_file = require('./json-file');
+var mod_json = require('./json-file');
 var mod_fs = require('fs');
 
 
@@ -59,7 +59,7 @@ function generateNetConfFile(opts) {
     var name = 'generateNetConfFile: ';
 
     if (!opts.adminNic) {
-        opts.log.info(name + 'No admin nic: returning');
+        opts.log.warn(name + 'No admin nic: returning');
         return;
     }
 
@@ -75,6 +75,7 @@ function generateNetConfFile(opts) {
 
     var conf = {
         nictags: opts.nictags,
+        admin_tag: opts.adminNic.nic_tag,
         resolvers: [],
         routes: {},
         vnics: []
@@ -165,7 +166,7 @@ function generateNetConfFile(opts) {
 
         // This is a server that has just booted: fall back to setting the
         // admin nic tag's MAC address to it
-        if (aTag.name === 'admin') {
+        if (aTag.name === 'admin' || opts.adminNic.nic_tag === aTag.name) {
             if (conf.vnics.length === 1 && !aTag.mac) {
                 aTag.mac = opts.adminNic.mac;
             }
@@ -184,7 +185,9 @@ function writeNetConfFile(opts, callback) {
     assert.object(opts.log, 'opts.log');
 
     var adminFound;
+    var nictag;
     var conf = generateNetConfFile(opts);
+    var adminPool = opts.adminPool;
     var name = 'writeNetConfFile: ';
 
     if (!conf) {
@@ -192,7 +195,12 @@ function writeNetConfFile(opts, callback) {
     }
 
     for (var n in conf.nictags) {
-        if (conf.nictags[n].name == 'admin') {
+        nictag = conf.nictags[n].name;
+        if (nictag == 'admin' ||
+            (adminPool &&
+            adminPool.hasOwnProperty('nic_tags_present') &&
+            adminPool.nic_tags_present.indexOf(nictag) != -1)) {
+
             adminFound = true;
             break;
         }
@@ -204,12 +212,12 @@ function writeNetConfFile(opts, callback) {
         return callback();
     }
 
-    mod_file.write({
+    mod_json.write({
         dir: opts.bootFsDir,
         log: opts.log,
         name: 'networking',
         payload: conf
-    }, function (fErr) {
+    }, function (fErr, data) {
         if (fErr) {
             return callback(fErr);
         }
@@ -219,9 +227,7 @@ function writeNetConfFile(opts, callback) {
         var hashName = fmt('%s/networking.json.hash', opts.bootFsDir);
         var sha1 = mod_crypto.createHash('sha1');
 
-        // XXX: should really get mod_file.write() to return the actual
-        // string it wrote:
-        sha1.update(JSON.stringify(conf, null, 2));
+        sha1.update(data);
         digest = sha1.digest('hex');
         opts.log.info({
             file: hashName,
diff --git a/package.json b/package.json
index 06eff60..4b1dd9e 100644
--- a/package.json
+++ b/package.json
@@ -9,6 +9,8 @@
     "bunyan": "1.8.8",
     "dashdash": "1.14.1",
     "findit": "2.0.0",
+    "ip6addr": "0.2.2",
+    "jsprim": "2.0.0",
     "mkdirp": "0.5.0",
     "node-uuid": "1.2.0",
     "restify": "4.3.0",
diff --git a/sapi_manifests/dhcpd/template b/sapi_manifests/dhcpd/template
index bc86c39..22dbb3b 100644
--- a/sapi_manifests/dhcpd/template
+++ b/sapi_manifests/dhcpd/template
@@ -40,5 +40,9 @@
     "purgeIntervalSeconds": 3600,
     "maxCacheFileAgeSeconds": 604800,
     "refreshConcurrency": 16
+  },
+  "poolCache": {
+    "updateIntervalSeconds": 60,
+    "dir": "/tftpboot/poolcache"
   }
 }
diff --git a/server.js b/server.js
index 7459722..cd99b1b 100644
--- a/server.js
+++ b/server.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2015, Joyent, Inc.
+ * Copyright (c) 2018, Joyent, Inc.
  */
 
 /*
@@ -13,8 +13,12 @@
  */
 
 var bunyan = require('bunyan');
+var fs = require('fs');
 var dhcpd = require('./lib/dhcpd');
 var stdSerializers = require('sdc-bunyan-serializers');
+var AdminPoolCache = require('./lib/admin-pool-cache');
+var mod_clients = require('./lib/clients');
+
 
 
 var log = bunyan.createLogger({
@@ -24,11 +28,38 @@ var log = bunyan.createLogger({
 });
 
 try {
+    var configFile = __dirname + '/config.json';
+    var config = JSON.parse(fs.readFileSync(configFile, 'utf-8'));
+    var napi = mod_clients.createNAPIclient(config);
+
+    log.info('Loaded config from "%s"', configFile);
+
+    var cache = AdminPoolCache.create({
+        napi: napi,
+        log: log,
+        cacheDir: config.poolCache.dir,
+        cacheUpdateIntervalSeconds: config.poolCache.updateIntervalSeconds
+    });
+
     var server = dhcpd.createServer({
         log: log,
-        configFile: __dirname + '/config.json'
+        config: config,
+        napi: napi,
+        adminPoolCache: cache
+    });
+
+    /*
+     * Update the cache before we start the dhcpd server.
+     */
+    cache.update(function (err) {
+        if (err) {
+            log.error('Failed initial admin pool cache update', err);
+            throw err;
+        } else {
+            log.info('Initial cache update completed.  Starting DHCP server.');
+            server.start();
+        }
     });
-    server.start();
 } catch (err) {
     log.error(err);
     process.exit(1);
diff --git a/test/bootparams.test.js b/test/bootparams.test.js
index 631810d..1c41b32 100644
--- a/test/bootparams.test.js
+++ b/test/bootparams.test.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2017, Joyent, Inc.
+ * Copyright (c) 2018, Joyent, Inc.
  */
 
 /*
@@ -163,7 +163,8 @@ test('new CN boots', function (t) {
         getNic: [ { err: error404() } ],
         getNicTag: [ nicTag('admin') ],
         listAggrs: [ { res: [] } ],
-        provisionNic: [ { res: newNic } ]
+        provisionNic: [ { res: newNic } ],
+        listNetworkPools: [ { res: [] } ]
     };
 
     mocks.cnapi.VALUES = {
@@ -198,15 +199,138 @@ test('new CN boots', function (t) {
                     belongs_to_uuid: newNic.belongs_to_uuid,
                     mac: newNic.mac,
                     owner_uuid: newNic.owner_uuid,
-                    nic_tags_provided: ['admin']
+                    nic_tags_provided: ['admin'],
+                    nic_tag: 'admin'
                 } }
         ], 'NAPI provision nic endpoint called correctly');
 
         t.deepEqual(mod_file.netConfig(newNic.mac), {
-            aggregations: [],
             nictags: [
                 { name: 'admin', mac: newNic.mac, mtu: 1500 }
             ],
+            admin_tag: newNic.nic_tag,
+            resolvers: newNic.resolvers,
+            routes: {},
+            vnics: [
+                newNic
+            ],
+            aggregations: []
+        }, 'network boot-time file written correctly');
+
+        tearDownMocks();
+        t.end();
+    });
+});
+
+
+test('new CN boots with admin pool', function (t) {
+    setUpMocks();
+
+    var admin_network = {
+        family: 'ipv4',
+        mtu: 1500,
+        nic_tag: 'admin_rack_99',
+        name: 'admin_rack_99',
+        provision_end_ip: '10.222.222.250',
+        provision_start_ip: '10.222.222.5',
+        subnet: '10.222.222.0/24',
+        uuid: '9d136dbc-a161-44f5-85a9-83c0bbecef6f',
+        vlan_id: 0,
+        resolvers: [],
+        gateway: '10.222.222.1',
+        netmask: '255.255.255.0'
+    };
+
+    var newNic = {
+        belongs_to_type: 'other',
+        belongs_to_uuid: mod_server.adminUuid,
+        mac: '06:b7:ad:86:be:04',
+        owner_uuid: mod_server.adminUuid,
+        primary: false,
+        ip: '10.222.222.9',
+        gateway: '10.222.222.1',
+        netmask: '255.255.255.0',
+        vlan_id: 0,
+        nic_tag: 'admin_rack_99',
+        resolvers: [ '10.99.99.11' ]
+    };
+
+    var network_pool = {
+        family: 'ipv4',
+        uuid: '2cecff7d-fc97-4a44-bd1c-522dbaa39587',
+        name: 'admin',
+        networks: [
+            '9d136dbc-a161-44f5-85a9-83c0bbecef6f'
+        ],
+        nic_tags_present: [
+            'admin_rack_99'
+        ],
+        nic_tag: 'admin_rack_99'
+    };
+
+    mocks.napi.VALUES = {
+        getNic: [ { err: error404() } ],
+        getNicTag: [ nicTag('admin_rack_99') ],
+        listAggrs: [ { res: [] } ],
+        provisionNic: [ { res: newNic } ],
+        listNetworkPools: [
+            { res: [ network_pool ] }
+        ],
+        listNetworks: [ { res: [ admin_network ] } ]
+    };
+
+    mocks.cnapi.VALUES = {
+        getBootParams: [ { res: clone(DEFAULT_BOOT_PARAMS) } ]
+    };
+
+    getBootParams({ mac: newNic.mac, nic_tag: newNic.nic_tag },
+            function (err, res) {
+        t.ifError(err, 'expect truthy value');
+        if (err) {
+            return t.end();
+        }
+
+        var params = clone(DEFAULT_BOOT_PARAMS);
+        params.kernel_args.admin_nic = newNic.mac;
+        params.ip = newNic.ip;
+        params.netmask = newNic.netmask;
+        params.resolvers = [ '10.99.99.11' ];
+        params.gateway = newNic.gateway;
+
+        t.deepEqual(res.bootParams, params, 'boot params for new CN');
+        t.deepEqual(mocks.cnapi.CALLS.getBootParams, [
+            { uuid: 'default' }
+        ], 'cnapi /boot called correctly');
+
+        t.deepEqual(mocks.napi.CALLS.getNic, [
+            { mac: newNic.mac }
+        ], 'NAPI /nics/:mac called correctly');
+
+        // TODO: when we provision on a network pool we should get the network
+        // uuid returned, not the network pool uuid. But we are using mocks
+        // here, instead of real NAPI.  So we could build in the same
+        // intelligence of real NAPI into mocks.  But for now just set
+        // 'network' to the network pool uuid.
+        t.deepEqual(mocks.napi.CALLS.provisionNic, [
+            { network: network_pool.uuid,
+                params: {
+                    belongs_to_type: newNic.belongs_to_type,
+                    belongs_to_uuid: newNic.belongs_to_uuid,
+                    mac: newNic.mac,
+                    owner_uuid: newNic.owner_uuid,
+                    nic_tags_provided: ['admin_rack_99'],
+                    nic_tag: 'admin_rack_99'
+                } }
+        ], 'NAPI provision nic endpoint called correctly');
+
+        t.deepEqual(mod_file.adminPoolCache(), network_pool);
+
+        t.deepEqual(mod_file.netConfig(newNic.mac), {
+            aggregations: [],
+            nictags: [
+                { name: 'admin_rack_99', mac: newNic.mac, mtu: 1500 }
+            ],
+            admin_tag: newNic.nic_tag,
             resolvers: newNic.resolvers,
             routes: {},
             vnics: [
@@ -229,7 +353,8 @@ test('existing CN boots', function (t) {
         getNic: [ { res: serverNics[1] } ],
         getNics: [ { res: serverNics } ],
         getNicTag: [ nicTag('admin'), nicTag('external') ],
-        listAggrs: [ { res: [] } ]
+        listAggrs: [ { res: [] } ],
+        listNetworkPools: [ { res: [] } ]
     };
 
     mocks.cnapi.VALUES = {
@@ -266,6 +391,7 @@ test('existing CN boots', function (t) {
                 { name: 'admin', mac: serverNics[1].mac, mtu: 1500 },
                 { name: 'external', mac: serverNics[0].mac, mtu: 1500 }
             ],
+            admin_tag: serverNics[1].nic_tag,
             resolvers: serverNics[1].resolvers.concat(serverNics[0].resolvers),
             routes: {},
             vnics: [
@@ -279,7 +405,6 @@ test('existing CN boots', function (t) {
     });
 });
 
-
 test('existing CN boots: no bootparams', function (t) {
     setUpMocks();
     var serverNics = clone(CN1_NICS);
@@ -288,7 +413,8 @@ test('existing CN boots: no bootparams', function (t) {
         getNic: [ { res: serverNics[1] } ],
         getNics: [ { res: serverNics } ],
         getNicTag: [ nicTag('admin'), nicTag('external') ],
-        listAggrs: [ { res: [] } ]
+        listAggrs: [ { res: [] } ],
+        listNetworkPools: [ { res: [] } ]
     };
 
     mocks.cnapi.VALUES = {
@@ -325,6 +451,7 @@ test('existing CN boots: no bootparams', function (t) {
                 { name: 'admin', mac: serverNics[1].mac, mtu: 1500 },
                 { name: 'external', mac: serverNics[0].mac, mtu: 1500 }
             ],
+            admin_tag: serverNics[1].nic_tag,
             resolvers: serverNics[1].resolvers.concat(serverNics[0].resolvers),
             routes: {},
             vnics: [
@@ -348,6 +475,11 @@ test('admin nic different than booting nic', function (t) {
     setUpMocks();
     var desc = ': admin nic != booting nic';
     var serverNics = clone(CN1_NICS);
+    // XXX: Needs work?
+    // Seems like this test will always pass because we are manually adding the
+    // 'admin' nic tag to a nic that does not actually provide it.  Perhaps the
+    // thinking is that since they are on the same L2, we assume that this nic
+    // is on the admin network.
     serverNics[0].nic_tags_provided = [ 'admin' ];
     delete serverNics[1].nic_tags_provided;
 
@@ -355,7 +487,8 @@ test('admin nic different than booting nic', function (t) {
         getNic: [ { res: serverNics[1] } ],
         getNics: [ { res: serverNics } ],
         getNicTag: [ nicTag('admin'), nicTag('external') ],
-        listAggrs: [ { res: [] } ]
+        listAggrs: [ { res: [] } ],
+        listNetworkPools: [ { res: [] } ]
     };
 
     mocks.cnapi.VALUES = {
@@ -388,6 +521,7 @@ test('admin nic different than booting nic', function (t) {
                 { name: 'admin', mac: serverNics[0].mac, mtu: 1500 },
                 { name: 'external', mtu: 1500 }
             ],
+            admin_tag: serverNics[0].nic_tag, // TODO: Test this for rack aware
             resolvers: serverNics[0].resolvers.concat(serverNics[1].resolvers),
             routes: {},
             vnics: [
@@ -431,6 +565,12 @@ test('existing CN boots: NAPI connection error', function (t) {
         listAggrs: [
             { res: [] },
             { res: [] }
+        ],
+        listNetworkPools: [
+            { res: [] },
+            { res: [] },
+            { res: [] },
+            { res: [] }
         ]
     };
 
@@ -451,6 +591,7 @@ test('existing CN boots: NAPI connection error', function (t) {
             { name: 'admin', mac: serverNics[1].mac, mtu: 1500 },
             { name: 'external', mac: serverNics[0].mac, mtu: 1500 }
         ],
+        admin_tag: serverNics[1].nic_tag,
         resolvers: serverNics[1].resolvers.concat(serverNics[0].resolvers),
         routes: {},
         vnics: [
@@ -589,7 +730,11 @@ test('existing CN boots: CNAPI connection error', function (t) {
         getNicTag: [
             nicTag('admin'), nicTag('external')
         ],
-        listAggrs: [ { res: [] } ]
+        listAggrs: [ { res: [] } ],
+        listNetworkPools: [
+            { res: [] },
+            { res: [] }
+        ]
     };
 
     mocks.cnapi.VALUES = {
@@ -606,6 +751,7 @@ test('existing CN boots: CNAPI connection error', function (t) {
             { name: 'admin', mac: serverNics[1].mac, mtu: 1500 },
             { name: 'external', mac: serverNics[0].mac, mtu: 1500 }
         ],
+        admin_tag: serverNics[1].nic_tag,
         resolvers: serverNics[1].resolvers.concat(serverNics[0].resolvers),
         routes: {},
         vnics: [
@@ -655,7 +801,8 @@ test('error while provisioning nic', function (t) {
     mocks.napi.VALUES = {
         getNic: [ { err: error404() } ],
         provisionNic: [ { err: new Error('XXX bad error') } ],
-        listAggrs: [ { res: [] } ]
+        listAggrs: [ { res: [] } ],
+        listNetworkPools: [ { res: [] } ]
     };
 
     mocks.cnapi.VALUES = {
@@ -691,7 +838,11 @@ test('invalid JSON in cache file',  function (t) {
         getNicTag: [
             nicTag('admin'), nicTag('external')
         ],
-        listAggrs: [ { res: [] } ]
+        listAggrs: [ { res: [] } ],
+        listNetworkPools: [
+            { res: [] },
+            { res: [] }
+        ]
     };
 
     mocks.cnapi.VALUES = {
@@ -753,6 +904,10 @@ test('aggregation', function (t) {
         listAggrs: [
             { res: [ aggr ] },
             { res: [ aggr ] }
+        ],
+        listNetworkPools: [
+            { res: [] },
+            { res: [] }
         ]
     };
 
@@ -805,6 +960,7 @@ test('aggregation', function (t) {
                 { name: 'external', mac: 'aggr0', mtu: 1500 },
                 { name: 'foo', mac: 'aggr0', mtu: 1500 }
             ],
+            admin_tag: serverNics[1].nic_tag,
             resolvers: serverNics[1].resolvers.concat(serverNics[0].resolvers),
             routes: {},
             vnics: [
@@ -831,6 +987,7 @@ test('aggregation', function (t) {
                     { name: 'external', mac: 'aggr0', mtu: 1500 },
                     { name: 'foo', mac: 'aggr0', mtu: 1500 }
                 ],
+                admin_tag: serverNics[1].nic_tag,
                 resolvers: serverNics[1].resolvers.concat(
                     serverNics[0].resolvers),
                 routes: {},
diff --git a/test/lib/file.js b/test/lib/file.js
index c368f39..78b63b5 100644
--- a/test/lib/file.js
+++ b/test/lib/file.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2015, Joyent, Inc.
+ * Copyright (c) 2018, Joyent, Inc.
  */
 
 /*
@@ -30,6 +30,27 @@ var LOG = mod_log.child({ component: 'file' });
 // --- Exports
 
 
+function adminPoolCache() {
+    var fs = mod_mocks.getCreated().fs.getRoot();
+    var path = mod_server.config().poolCache.dir;
+    var name = 'admin_network_pool.json';
+
+    if (!fs.hasOwnProperty(path)) {
+        return '';
+    }
+
+    if (!fs.hasOwnProperty(path)) {
+        LOG.debug({fs: fs, path: path}, 'path does not exist');
+        return {};
+    }
+
+    if (!fs[path].hasOwnProperty(name)) {
+        LOG.debug({fs: fs, path: path}, 'admin_network_pool.js does not exist');
+        return {};
+    }
+
+    return JSON.parse(fs[path][name]);
+}
 
 function cacheFile(mac, val) {
     var name = fmt('%s.json', mac);
@@ -41,7 +62,6 @@ function cacheFile(mac, val) {
     return JSON.parse(mod_mocks.getCreated().fs.getRoot()[path][name]);
 }
 
-
 function menuLstFile(mac) {
     var fs = mod_mocks.getCreated().fs.getRoot();
     var name = fmt('menu.lst.01%s',
@@ -55,7 +75,6 @@ function menuLstFile(mac) {
     return fs[path][name];
 }
 
-
 function netBootTimeFile(mac) {
     var name = 'networking.json';
     var path = fmt('%s/bootfs/%s', mod_server.config().tftpRoot,
@@ -77,6 +96,7 @@ function netBootTimeFile(mac) {
 
 
 module.exports = {
+    adminPoolCache: adminPoolCache,
     cache: cacheFile,
     menuLst: menuLstFile,
     netConfig: netBootTimeFile
diff --git a/test/lib/mocks.js b/test/lib/mocks.js
index fb79211..efe8891 100644
--- a/test/lib/mocks.js
+++ b/test/lib/mocks.js
@@ -154,6 +154,16 @@ function createMocks() {
             { mac: mac, params: params }, cb);
     };
 
+    mocks.napi.listNetworks = function (params, options, cb) {
+        return this._handle('listNetworks',
+            { params: params, options: options }, cb);
+    };
+
+    mocks.napi.listNetworkPools = function (params, options, cb) {
+        return this._handle('listNetworkPools',
+            { params: params, options: options }, cb);
+    };
+
     // CNAPI
 
     mocks.cnapi = new Mock();
@@ -217,7 +227,6 @@ function createMocks() {
                 err.code = 'EEXIST';
                 return setImmediate(cb, err);
             }
-
             ROOT[dir] = {};
             return setImmediate(cb);
         },
@@ -310,6 +319,7 @@ function registerMocks() {
         'extsprintf',
         'events',
         'findit',
+        'ip6addr',
         'node-uuid',
         'pack',
         'path',
@@ -318,6 +328,7 @@ function registerMocks() {
         'util',
         'vasync',
         'verror',
+        '../../lib/admin-pool-cache',
         '../../lib/boot-files',
         '../../lib/cache',
         '../../lib/dhcpd',
diff --git a/test/lib/server.js b/test/lib/server.js
index 16b79ae..a791766 100644
--- a/test/lib/server.js
+++ b/test/lib/server.js
@@ -13,9 +13,11 @@
  */
 
 var assert = require('assert-plus');
+var vasync = require('vasync');
+var mod_log = require('./log');
 var mod_boot_files;
 var mod_dhcpd;
-var mod_log = require('./log');
+var adminPoolCache;
 
 
 
@@ -24,14 +26,12 @@ var mod_log = require('./log');
 
 
 var ADMIN_UUID = '930896af-bf8c-48d4-885c-6573a94b1853';
-var SERVER;
+var SERVER = {};
 
 
 
-function createServer() {
-    if (SERVER) {
-        return;
-    }
+function createServer(config) {
+    var log = mod_log.child({ component: 'test-server' });
 
     if (!mod_boot_files) {
         mod_boot_files = require('../../lib/boot-files');
@@ -41,30 +41,57 @@ function createServer() {
         mod_dhcpd = require('../../lib/dhcpd');
     }
 
-    SERVER = mod_dhcpd.createServer({
-        config: serverConfig(),
-        log: mod_log.child({ component: 'test-server' })
+    if (!adminPoolCache) {
+        adminPoolCache = require('../../lib/admin-pool-cache');
+    }
+
+    var cache = adminPoolCache.create({
+        napi: config.opts.napi,
+        log: log,
+        cacheDir: config.poolCache.dir,
+        cacheUpdateIntervalSeconds: config.poolCache.updateIntervalSeconds
+    });
+
+    var dhcp = mod_dhcpd.createServer({
+        config: config,
+        log: log,
+        adminPoolCache: cache,
+        napi: config.opts.napi,
+        cnapi: config.opts.cnapi
     });
-}
 
+    SERVER.dhcp = dhcp;
+    SERVER.cache = cache;
+    SERVER.log = log;
+}
 
 function bootData(opts, callback) {
     assert.object(opts, 'opts');
     assert.string(opts.mac, 'opts.mac');
-    createServer();
-
-    SERVER.cnapi = opts.cnapi;
-    SERVER.napi = opts.napi;
-
-    mod_boot_files.writeAll({
-        config: serverConfig(),
-        cnapi: opts.cnapi,
-        log: mod_log.child({ mac: opts.mac }),
-        mac: opts.mac,
-        napi: opts.napi
-    }, callback);
-}
 
+    var config = serverConfig();
+    config.opts = opts;
+
+    createServer(config);
+    SERVER.cache.update(function (error) {
+        if (error) {
+            callback(error, null);
+            return;
+        }
+
+        mod_boot_files.writeAll({
+            config: config,
+            cnapi: opts.cnapi,
+            log: mod_log.child({ mac: opts.mac }),
+            mac: opts.mac,
+            napi: opts.napi,
+            adminPoolCache: SERVER.cache,
+            nic_tag: opts.nic_tag
+        }, function (err, res) {
+            callback(err, res);
+        });
+    });
+}
 
 function serverConfig() {
     return {
@@ -99,6 +126,10 @@ function serverConfig() {
             purgeIntervalSeconds: 36000,
             maxCacheFileAgeSeconds: 604800,
             refreshConcurrency: 1
+        },
+        poolCache: {
+            updateIntervalSeconds: 60,
+            dir: '/tmp/tftpRoot/poolcache'
         }
     };
 }
diff --git a/tools/jsl.node.conf b/tools/jsl.node.conf
index d540a33..41f9808 100644
--- a/tools/jsl.node.conf
+++ b/tools/jsl.node.conf
@@ -124,6 +124,7 @@
 +define Buffer
 +define JSON
 +define Math
++define Set
 
 ### JavaScript Version
 # To change the default JavaScript version:
-- 
2.21.0

