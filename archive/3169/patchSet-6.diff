From a72fd050078e620af8b88fed0a61f51e486f0c1d Mon Sep 17 00:00:00 2001
From: Rui Loura <rui@joyent.com>
Date: Mon, 8 Jan 2018 19:45:02 +0000
Subject: [PATCH] NET-384 sdc-booter should dump core on uncaught exception
 NET-385 sdc-booter panics while handling discover on log level trace NET-386
 booter should be able to handle option 82 as nictags

---
 README.md                     |   2 +-
 bin/dhcpd                     |   2 +-
 config.json.sample            |   3 +-
 lib/admin-pool-cache.js       | 193 ++++++++++++++++++++++++++++++++++
 lib/boot-files.js             |   4 +-
 lib/booter.js                 |  16 ++-
 lib/bootparams.js             |  40 ++++++-
 lib/dhcp.js                   |   7 +-
 lib/dhcpd.js                  |  72 +++++++++++--
 lib/net-file.js               |  15 ++-
 sapi_manifests/dhcpd/template |   3 +-
 server.js                     |  35 +++++-
 test/bootparams.test.js       | 150 ++++++++++++++++++++++++--
 test/lib/mocks.js             |  11 ++
 test/lib/server.js            |  77 ++++++++++----
 15 files changed, 576 insertions(+), 54 deletions(-)
 create mode 100644 lib/admin-pool-cache.js

diff --git a/README.md b/README.md
index 92c0a7a..68a1108 100644
--- a/README.md
+++ b/README.md
@@ -72,7 +72,7 @@ Booter supports a few SAPI configuration values:
 
 - `http_pxe_boot`: if set to `true`, allow iPXE clients to pull down their
   files via HTTP rather than TFTP
-- `compute_node_default_gateway`: set this to give Compute Nodess a
+- `compute_node_default_gateway`: set this to give Compute Nodes a
   default gateway
 - `dhcp_lease_time`: DHCP lease time for Compute Nodes
 - `allow_missing_class_id`: booter only allows clients with class identifiers
diff --git a/bin/dhcpd b/bin/dhcpd
index 3e21437..8822d6e 100755
--- a/bin/dhcpd
+++ b/bin/dhcpd
@@ -16,4 +16,4 @@ if [[ ! -d "${NODE_INSTALL}" && -d "${TOP}/build/node" ]]; then
     NODE_INSTALL=${TOP}/build/node
 fi
 
-${NODE_INSTALL}/bin/node ${TOP}/server.js "$@"
+${NODE_INSTALL}/bin/node --abort-on-uncaught-exception ${TOP}/server.js "$@"
diff --git a/config.json.sample b/config.json.sample
index 8feea4c..00b87aa 100644
--- a/config.json.sample
+++ b/config.json.sample
@@ -16,5 +16,6 @@
   "defaultGateway": "10.99.99.7",
   "serverIp": "10.99.99.11",
   "leaseTime": 3600,
-  "netmask": "255.255.255.0"
+  "netmask": "255.255.255.0",
+  "updateCacheInterval": 60000
 }
diff --git a/lib/admin-pool-cache.js b/lib/admin-pool-cache.js
new file mode 100644
index 0000000..064865e
--- /dev/null
+++ b/lib/admin-pool-cache.js
@@ -0,0 +1,193 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright 2018 Joyent, Inc.
+ */
+
+var assert = require('assert-plus');
+var vasync = require('vasync');
+
+var fArg = {arg: null, admin_nets: {}};
+
+
+
+/*
+ * Initialize AdminPoolCache and start periodic updater.
+ */
+function AdminPoolCache(config) {
+    this._cache = {};
+    this.log = config.log;
+    this.napi = config.napi;
+    this.updateInterval = config.cacheUpdateInterval;
+    this.timeoutId = setTimeout(this.updateWorker.bind(this),
+        this.updateInterval);
+    Object.seal(this);
+}
+
+/*
+ * Update AdminPoolCache.
+ *
+ * XXX: this assumes there is only one network per nictag, which should be safe
+ * since this should only be used for rackaware networking (subnet per rack).
+ */
+AdminPoolCache.prototype.update = function _AdminPoolCacheUpdate(callback) {
+    var napi = this.napi;
+    var log = this.log;
+    var newcache = {};
+    var self = this;
+
+    assert.func(callback, 'callback');
+
+    vasync.waterfall([
+        function _listNetworkPools(next) {
+            napi.listNetworkPools({name: 'admin'}, null, function (err, res) {
+                if (err) {
+                    return next(err);
+                }
+
+                /*
+                 * If there is no admin network pool, zero out the cache and
+                 * short-circuit the waterfall.
+                 */
+                if (!res || res.length === 0) {
+                    self._cache = {};
+                    return next(true);
+                }
+
+                assert.arrayOfObject(res, 'pools');
+                if (res.length > 1) {
+                    err = 'Too many admin network pools';
+                    log.error(err, res);
+                    return next(err);
+                }
+                assert.arrayOfString(res[0].networks, 'networks');
+
+                return next(null, res[0].networks);
+            });
+        },
+        function _updateAdminNetworks(pool_nets, next) {
+            /*
+             * Non-error, but no need to go further.
+             */
+            if (!pool_nets || pool_nets.length === 0) {
+                self._cache = {};
+                return next(true);
+            }
+
+            napi.listNetworks(null, null, function (err, res) {
+                if (err) {
+                   return next(err);
+                }
+
+                if (!res || res.length === 0) {
+                    self._cache = {};
+                    return next();
+                }
+
+                assert.arrayOfObject(res, 'networks');
+
+                for (var n = 0; n < res.length; n++) {
+                    var net = res[n];
+                    var nic_tag;
+
+                    if (pool_nets.indexOf(net.uuid) === -1 ||
+                        !net.hasOwnProperty('nic_tag')) {
+                        continue;
+                    }
+
+                    nic_tag = net.nic_tag.toUpperCase();
+                    newcache[nic_tag] = net.uuid;
+                }
+                next(null);
+            });
+        }
+    ],
+    function (err) {
+        /* Only update the cache if completed successfully */
+        if (err && err !== true) {
+            log.error(err);
+            return callback(err);
+        }
+        self._cache = newcache;
+
+        /*
+         * It's possible this was an unscheduled update.  So clear the existing
+         * timeout, if any, and reschedule the next run.
+         */
+        clearTimeout(self.timeoutId);
+        self.timeoutId = setTimeout(self.updateWorker.bind(self),
+            self.updateInterval);
+        return callback();
+    });
+};
+
+AdminPoolCache.prototype.updateWorker = function () {
+    var self = this;
+    this.update(function (err) {
+        if (err) {
+            self.log.error({error: err, cache: self._cache},
+                'Periodic Admin Pool Cache update failed');
+        } else {
+            self.log.info({cache: self._cache},
+                'Periodic Admin Pool Cache update complete');
+        }
+    });
+};
+
+/*
+ * Synchronous get.  Don't bother going out to napi on a cache miss.
+ */
+AdminPoolCache.prototype.syncGet = function (nictag) {
+    var tag = nictag.toUpperCase();
+
+    return (this._cache[tag]);
+};
+
+/*
+ * Return the uuid of the network from the admin pool with the specified nictag.
+ */
+AdminPoolCache.prototype.get = function (nictag, callback) {
+    var self = this;
+    var tag = nictag.toUpperCase();
+
+    if (this._cache.hasOwnProperty(tag)) {
+        return callback(null, this._cache[tag]);
+    }
+
+    /*
+     * Maybe this is a recently added network / nictag.  Update the cache and
+     * see if it is picked up.
+     *
+     * XXX: this could cause a failure cascade if one lookup delays booting
+     * other CNs with valid nictags.  But in that case it is no worse than not
+     * having a cache at all.
+     */
+    this.update(function asyncCacheUpdate(err) {
+        if (err) {
+            return callback(err);
+        }
+
+        if (!self._cache.hasOwnProperty(tag)) {
+            err = 'Could not find nictag in admin network pool';
+            self.log.error({nictag: tag, cache: self._cache}, err);
+            callback(err);
+            return;
+        }
+
+        return callback(null, self._cache[tag]);
+    });
+};
+
+AdminPoolCache.prototype.quiesce = function () {
+    clearTimeout(this.timeoutId);
+};
+
+module.exports = {
+    create: function (config) {
+        return new AdminPoolCache(config);
+    }
+};
diff --git a/lib/boot-files.js b/lib/boot-files.js
index ce559d6..12065f2 100644
--- a/lib/boot-files.js
+++ b/lib/boot-files.js
@@ -39,7 +39,9 @@ function extractBootOpts(opts) {
         log: opts.log,
         napi: opts.napi,
         mac: opts.mac,
-        tftpRoot: opts.config.tftpRoot
+        tftpRoot: opts.config.tftpRoot,
+        nic_tag: opts.nic_tag,
+        adminPoolCache: opts.adminPoolCache
     };
 
     if (opts.mac) {
diff --git a/lib/booter.js b/lib/booter.js
index 5fa83eb..6930c31 100644
--- a/lib/booter.js
+++ b/lib/booter.js
@@ -20,6 +20,7 @@ var menu = require('./menulst');
 var mod_cache = require('./cache');
 var mod_clients = require('./clients');
 var path = require('path');
+var adminPoolCache = require('./admin-pool-cache');
 
 
 
@@ -49,6 +50,12 @@ function main() {
         }
     });
 
+    var cache = adminPoolCache.create({
+        napi: napi,
+        log: log,
+        cacheUpdateInterval: this.config.cacheUpdateInterval
+    });
+
     switch (process.argv[2]) {
     case 'ping-napi':
         napi.ping(standardHandler);
@@ -64,7 +71,8 @@ function main() {
             napi: napi,
             cnapi: cnapi,
             log: log,
-            pipelineTimeoutSeconds: -1
+            pipelineTimeoutSeconds: -1,
+            adminPoolCache: cache
         }, standardHandler);
         break;
     case 'bootparams-cnapi':
@@ -77,7 +85,8 @@ function main() {
             mac: getArg('MAC address'),
             napi: napi,
             cnapi: cnapi,
-            log: log
+            log: log,
+            adminPoolCache: cache
         }, function (err, res) {
             if (err) {
                 return console.error(err.code + ': ' + err.message);
@@ -98,7 +107,8 @@ function main() {
             mac: getArg('MAC address'),
             napi: napi,
             cnapi: cnapi,
-            log: log
+            log: log,
+            adminPoolCache: cache
         }, function (err, res) {
             if (err) {
                 return console.error(err.code + ': ' + err.message);
diff --git a/lib/bootparams.js b/lib/bootparams.js
index ab875c0..fc458f1 100644
--- a/lib/bootparams.js
+++ b/lib/bootparams.js
@@ -121,6 +121,7 @@ function getBootParams(opts, callback) {
     assert.object(opts.napi, 'opts.napi');
     assert.optionalNumber(opts.pipelineTimeoutSeconds,
                           'opts.pipelineTimeoutSeconds');
+    assert.object(opts.adminPoolCache, 'opts.adminPoolCache');
 
     var cacheDir = opts.cacheDir;
     var adminUuid = opts.adminUuid;
@@ -128,6 +129,7 @@ function getBootParams(opts, callback) {
     var log = opts.log;
     var mac = opts.mac;
     var napi = opts.napi;
+    var adminPoolCache = opts.adminPoolCache;
 
     /*
      * getBootParams performs several calls to external services (e.g. napi &
@@ -175,7 +177,9 @@ function getBootParams(opts, callback) {
         adminUuid: opts.adminUuid,
         bootNic: null,
         log: opts.log,
-        napi: opts.napi
+        napi: opts.napi,
+        network_uuid: 'admin',
+        nic_tag: opts.nic_tag
     };
 
     vasync.pipeline({
@@ -207,8 +211,10 @@ function getBootParams(opts, callback) {
                     return cb();
                 }
 
+                assert(fArg.bootNic.network_uuid === undefined,
+                    'network_uuid undefined');
                 var putParams = {
-                    network_uuid: 'admin'
+                    network_uuid: fArg.network_uuid
                 };
 
                 log.debug(putParams, 'Updating nic "%s" to add IP', mac);
@@ -228,6 +234,28 @@ function getBootParams(opts, callback) {
                 });
             },
 
+            function _checkAdminPoolCache(fArg, cb) {
+                if (fArg.bootNic !== null) {
+                    return cb();
+                }
+
+                if (!fArg.nic_tag) {
+                    fArg.nic_tag = 'admin';
+                    return cb();
+                }
+
+                log.info('bootNic not found, checking cache for network uuid');
+                adminPoolCache.get(fArg.nic_tag, function (err, net_uuid) {
+                    if (err) {
+                        log.error({nictag: fArg.nic_tag}, 'Tag not found');
+                        return cb(err);
+                    }
+
+                    fArg.network_uuid = net_uuid;
+                    return cb();
+                });
+            },
+
             // If the nic doesn't exist in NAPI, provision it on the admin
             // network, which will give it an IP
             function _createNic(fArg, cb) {
@@ -240,9 +268,13 @@ function getBootParams(opts, callback) {
                     belongs_to_uuid: adminUuid,
                     belongs_to_type: 'other',
                     mac: mac,
-                    nic_tags_provided: [ 'admin' ]
+                    nic_tags_provided: [ fArg.nic_tag ] // XXX correct param?
                 };
-                napi.provisionNic('admin', postParams, function (err, res) {
+
+                log.info(postParams, 'posting params to napi');
+
+                napi.provisionNic(fArg.network_uuid, postParams,
+                    function (err, res) {
                     if (err) {
                         log.error(err,
                             'Error provisioning admin nic "%s" on NAPI', mac);
diff --git a/lib/dhcp.js b/lib/dhcp.js
index 42c55aa..4135805 100644
--- a/lib/dhcp.js
+++ b/lib/dhcp.js
@@ -362,6 +362,10 @@ function createDHCPreply(packet, data) {
                         pkt.options[opt] = pack.unpack('CCCC',
                                 pack.pack('N', parseInt(value, 10)));
                         break;
+                    // pass through
+                    case 82: // DHCP Relay
+                        pkt.options[opt] = value;
+                        break;
                     default:
                         throw new Error('Ignoring unhandled option ' + opt);
                 }
@@ -424,13 +428,14 @@ function parseDHCPpacket(data) {
     while (i < res.length) {
             var option = parseInt(res[i++], 10);
             if (option === 0) {
-                    continue;
+                continue;
             }
 
             if (option == 255) {
                     // end of options option
                     break;
             } else {
+                    // XXX: I'll take sub-options for a 100 Alex
                     // an option that will have data
                     var olen = res[i++]; // length of option data
                     var value = [];
diff --git a/lib/dhcpd.js b/lib/dhcpd.js
index 25d3a78..d7fb0bc 100755
--- a/lib/dhcpd.js
+++ b/lib/dhcpd.js
@@ -37,11 +37,20 @@ var uuid = require('node-uuid');
  */
 function DHCPD(opts) {
     this.config = opts.config;
-
-    this.cnapi = mod_clients.createCNAPIclient(this.config);
     this.log = opts.log;
-    this.napi = mod_clients.createNAPIclient(this.config);
+    this.adminPoolCache = opts.adminPoolCache;
 
+    if (opts.napi) {
+        this.napi = opts.napi;
+    } else {
+        this.napi = mod_clients.createNAPIclient(this.config);
+    }
+
+    if (opts.cnapi) {
+        this.cnapi = opts.cnapi;
+    } else {
+        this.cnapi = mod_clients.createCNAPIclient(this.config);
+    }
     this.cacheSentinel = new mod_cache.CacheSentinel(
         {log: this.log, cnapi: this.cnapi, napi: this.napi,
          adminUuid: this.config.adminUuid, cacheConfig: this.config.cache});
@@ -81,10 +90,15 @@ DHCPD.prototype.handleMessage = function (msg, peer) {
 
     // Print the whole packet in hex
     if (log.trace()) {
+        var str_buf;
         for (var i = 0; i < msg.length; i += 4) {
-            // XXX
-            this.log.trace(sprintf('[%03d]: 0x%02x 0x%02x 0x%02x 0x%02x',
-                i, msg[i], msg[i+1], msg[i+2], msg[i+3]));
+            str_buf = '';
+            str_buf += sprintf('[%03d]:', i);
+
+            for (var j = 0; j < Math.min(4, msg.length - i); j++) {
+                str_buf += sprintf(' 0x%02x', msg[i + j]);
+            }
+            this.log.trace(str_buf);
         }
     }
 
@@ -128,7 +142,41 @@ DHCPD.prototype.handleMessage = function (msg, peer) {
             + 'identifier');
     }
 
+    /*
+     * This block decodes option 82 which has multiple sub-options.  If we
+     * decide to extend booter to be a full fledged, DHCP server then we should
+     * create decoders for each option in dhcp.js.  But at this time, option 82
+     * is the only option we support that leverages suboptions (excepting the
+     * widely misused option 77).
+     */
+    if (packet.options[82]) {
+        log.info('Found DHCP Option 82');
+        var relayopt = packet.options[82];
+        var suboptid = relayopt[0];
+
+        /* We only support sub-option 1. */
+        if (suboptid !== 1) {
+            log.info('Option 82, missing dhcp circuit-id suboption, '
+                + 'found suboption number: %d.  Not responding.', suboptid);
+            return;
+        }
+
+        /* Slice off the suboption id. */
+        var subopt = relayopt.slice(1);
+        var suboptlen = subopt[0];
+
+        /* Slice off the suboption length. */
+        subopt = subopt.slice(1);
+
+        if (suboptlen !== subopt.length) {
+            log.info('Option 82, missing dhcp circuit-id suboption, '
+                + 'found suboption number: %d.  Not responding.', suboptid);
+            return;
+        }
 
+        var nictag = new Buffer(subopt).toString();
+        log.info('Found nic tag from Option 82:', nictag);
+    }
 
     var _sendReplyWithParams = function (params) {
         var packetOpts = self.buildPacketOpts(packet, params.bootParams, log);
@@ -154,6 +202,7 @@ DHCPD.prototype.handleMessage = function (msg, peer) {
             config: self.config,
             log: log,
             mac: mac,
+            nic_tag: nictag,
             napi: self.napi
         }, function _afterParams(pErr, params) {
             if (pErr) {
@@ -166,6 +215,7 @@ DHCPD.prototype.handleMessage = function (msg, peer) {
         mod_bootparams.getFromCache({
             dir: self.config.cache.dir,
             log: log,
+            nic_tag: nictag, // XXX Not sure this is needed here.
             mac: mac
         }, function _afterCache(err, params) {
             if (err) {
@@ -245,6 +295,10 @@ DHCPD.prototype.buildPacketOpts = function (packet, params, log) {
         }
     }
 
+    if (packet.options[82]) {
+        packetOpts['options']['82'] = packet.options[82];
+    }
+
     if (params.resolvers && params.resolvers.length) {
         resolvers = params.resolvers;
     }
@@ -278,6 +332,7 @@ function createServer(opts) {
     assert.optionalObject(opts.config, 'opts.config');
     assert.optionalString(opts.configFile, 'opts.configFile');
     assert.object(opts.log, 'opts.log');
+    assert.object(opts.adminPoolCache, 'opts.adminPoolCache');
 
     var config;
     var log = opts.log;
@@ -301,6 +356,7 @@ function createServer(opts) {
 
     assert.number(config.leaseTime, 'config.leaseTime');
     assert.number(config.port, 'config.port');
+    assert.number(config.cacheUpdateInterval, 'config.cacheUpdateInterval');
 
     assert.optionalArrayOfString(config.resolvers);
     assert.optionalBool(config.disableBootTimeFiles,
@@ -312,7 +368,9 @@ function createServer(opts) {
     log.info({ config: config }, 'server config loaded');
     return new DHCPD({
         log: log,
-        config: config
+        config: config,
+        adminPoolCache: opts.adminPoolCache,
+        napi: opts.napi
     });
 }
 
diff --git a/lib/net-file.js b/lib/net-file.js
index 8add89a..55645eb 100644
--- a/lib/net-file.js
+++ b/lib/net-file.js
@@ -165,7 +165,8 @@ function generateNetConfFile(opts) {
 
         // This is a server that has just booted: fall back to setting the
         // admin nic tag's MAC address to it
-        if (aTag.name === 'admin') {
+        // XXX: do we need both comparisons?
+        if (aTag.name === 'admin' || opts.adminNic.nic_tag === aTag.name) {
             if (conf.vnics.length === 1 && !aTag.mac) {
                 aTag.mac = opts.adminNic.mac;
             }
@@ -184,6 +185,7 @@ function writeNetConfFile(opts, callback) {
     assert.object(opts.log, 'opts.log');
 
     var adminFound;
+    var nictag;
     var conf = generateNetConfFile(opts);
     var name = 'writeNetConfFile: ';
 
@@ -191,10 +193,15 @@ function writeNetConfFile(opts, callback) {
         return callback();
     }
 
+    /*
+     * Do we even need this block?  If not we can remove syncGet()
+     */
     for (var n in conf.nictags) {
-        if (conf.nictags[n].name == 'admin') {
-            adminFound = true;
-            break;
+        nictag = conf.nictags[n].name;
+        if (opts.adminPoolCache.syncGet(nictag) ||
+            nictag == 'admin') {
+                adminFound = true;
+                break;
         }
     }
 
diff --git a/sapi_manifests/dhcpd/template b/sapi_manifests/dhcpd/template
index bc86c39..f5d42b8 100644
--- a/sapi_manifests/dhcpd/template
+++ b/sapi_manifests/dhcpd/template
@@ -40,5 +40,6 @@
     "purgeIntervalSeconds": 3600,
     "maxCacheFileAgeSeconds": 604800,
     "refreshConcurrency": 16
-  }
+  },
+  "cacheUpdateInterval": 60000
 }
diff --git a/server.js b/server.js
index 7459722..5953434 100644
--- a/server.js
+++ b/server.js
@@ -13,8 +13,12 @@
  */
 
 var bunyan = require('bunyan');
+var fs = require('fs');
 var dhcpd = require('./lib/dhcpd');
 var stdSerializers = require('sdc-bunyan-serializers');
+var adminPoolCache = require('./lib/admin-pool-cache');
+var mod_clients = require('./lib/clients');
+
 
 
 var log = bunyan.createLogger({
@@ -24,11 +28,38 @@ var log = bunyan.createLogger({
 });
 
 try {
+    var configFile = __dirname + '/config.json';
+    var config = JSON.parse(fs.readFileSync(configFile, 'utf-8'));
+    var napi = mod_clients.createNAPIclient(config);
+
+    log.info('Loaded config from "%s"', configFile);
+
+
+    var cache = adminPoolCache.create({
+        napi: napi,
+        log: log,
+        cacheUpdateInterval: config.cacheUpdateInterval
+    });
+
     var server = dhcpd.createServer({
         log: log,
-        configFile: __dirname + '/config.json'
+        config: config,
+        napi: napi,
+        adminPoolCache: cache
+    });
+
+    /*
+     * Update the cache before we start the dhcpd server.
+     */
+    cache.update(function (err) {
+        if (err) {
+            log.error('Failed initial admin pool cache update', err);
+            throw err;
+        } else {
+            log.info('Initial cache update completed.  Starting DHCP server.');
+            server.start();
+        }
     });
-    server.start();
 } catch (err) {
     log.error(err);
     process.exit(1);
diff --git a/test/bootparams.test.js b/test/bootparams.test.js
index 631810d..105f90c 100644
--- a/test/bootparams.test.js
+++ b/test/bootparams.test.js
@@ -163,7 +163,8 @@ test('new CN boots', function (t) {
         getNic: [ { err: error404() } ],
         getNicTag: [ nicTag('admin') ],
         listAggrs: [ { res: [] } ],
-        provisionNic: [ { res: newNic } ]
+        provisionNic: [ { res: newNic } ],
+        listNetworkPools: [ { res: [] } ]
     };
 
     mocks.cnapi.VALUES = {
@@ -220,6 +221,116 @@ test('new CN boots', function (t) {
 });
 
 
+test('new CN boots with admin pool', function (t) {
+    setUpMocks();
+
+    var admin_network = {
+        family: 'ipv4',
+        mtu: 1500,
+        nic_tag: 'admin_rack99',
+        name: 'admin_rack99',
+        provision_end_ip: '10.222.222.250',
+        provision_start_ip: '10.222.222.5',
+        subnet: '10.222.222.0/24',
+        uuid: '9d136dbc-a161-44f5-85a9-83c0bbecef6f',
+        vlan_id: 0,
+        resolvers: [],
+        gateway: '10.222.222.1',
+        netmask: '255.255.255.0'
+    };
+
+    var newNic = {
+        belongs_to_type: 'other',
+        belongs_to_uuid: mod_server.adminUuid,
+        mac: '06:b7:ad:86:be:04',
+        owner_uuid: mod_server.adminUuid,
+        primary: false,
+        ip: '10.222.222.9',
+        netmask: '255.255.255.0',
+        vlan_id: 0,
+        nic_tag: 'admin_rack99',
+        resolvers: [ '10.99.99.11' ]
+    };
+
+    var network_pool = {
+        family: 'ipv4',
+        uuid: '2cecff7d-fc97-4a44-bd1c-522dbaa39587',
+        name: 'admin',
+        networks: [
+            '9d136dbc-a161-44f5-85a9-83c0bbecef6f'
+        ],
+        nic_tags_present: [
+            'admin_rack99'
+        ],
+        nic_tag: 'admin_rack99'
+    };
+
+    mocks.napi.VALUES = {
+        getNic: [ { err: error404() } ],
+        getNicTag: [ nicTag('admin_rack99') ],
+        listAggrs: [ { res: [] } ],
+        provisionNic: [ { res: newNic } ],
+        listNetworkPools: [
+            { res: [ network_pool ] }
+        ],
+        listNetworks: [ { res: [ admin_network ] } ]
+    };
+
+    mocks.cnapi.VALUES = {
+        getBootParams: [ { res: clone(DEFAULT_BOOT_PARAMS) } ]
+    };
+
+    getBootParams({ mac: newNic.mac, nic_tag: newNic.nic_tag },
+            function (err, res) {
+        t.ifError(err, 'expect truthy value');
+        if (err) {
+            return t.end();
+        }
+
+        var params = clone(DEFAULT_BOOT_PARAMS);
+        params.kernel_args.admin_nic = newNic.mac;
+        params.ip = newNic.ip;
+        params.netmask = newNic.netmask;
+        params.resolvers = [ '10.99.99.11' ];
+
+        t.deepEqual(res.bootParams, params, 'boot params for new CN');
+        t.deepEqual(mocks.cnapi.CALLS.getBootParams, [
+            { uuid: 'default' }
+        ], 'cnapi /boot called correctly');
+
+        t.deepEqual(mocks.napi.CALLS.getNic, [
+            { mac: newNic.mac }
+        ], 'NAPI /nics/:mac called correctly');
+
+        t.deepEqual(mocks.napi.CALLS.provisionNic, [
+            { network: admin_network.uuid,
+                params: {
+                    belongs_to_type: newNic.belongs_to_type,
+                    belongs_to_uuid: newNic.belongs_to_uuid,
+                    mac: newNic.mac,
+                    owner_uuid: newNic.owner_uuid,
+                    nic_tags_provided: ['admin_rack99']
+                } }
+        ], 'NAPI provision nic endpoint called correctly');
+
+        t.deepEqual(mod_file.netConfig(newNic.mac), {
+            aggregations: [],
+            nictags: [
+                { name: 'admin_rack99', mac: newNic.mac, mtu: 1500 }
+            ],
+            resolvers: newNic.resolvers,
+            routes: {},
+            vnics: [
+                newNic
+            ]
+        }, 'network boot-time file written correctly');
+
+        tearDownMocks();
+        t.end();
+    });
+});
+
+
 test('existing CN boots', function (t) {
     setUpMocks();
     var serverNics = clone(CN1_NICS);
@@ -229,7 +340,9 @@ test('existing CN boots', function (t) {
         getNic: [ { res: serverNics[1] } ],
         getNics: [ { res: serverNics } ],
         getNicTag: [ nicTag('admin'), nicTag('external') ],
-        listAggrs: [ { res: [] } ]
+        listAggrs: [ { res: [] } ],
+        listNetworkPools: [ { res: [] } ]
+
     };
 
     mocks.cnapi.VALUES = {
@@ -288,7 +401,9 @@ test('existing CN boots: no bootparams', function (t) {
         getNic: [ { res: serverNics[1] } ],
         getNics: [ { res: serverNics } ],
         getNicTag: [ nicTag('admin'), nicTag('external') ],
-        listAggrs: [ { res: [] } ]
+        listAggrs: [ { res: [] } ],
+        listNetworkPools: [ { res: [] } ]
+
     };
 
     mocks.cnapi.VALUES = {
@@ -355,7 +470,9 @@ test('admin nic different than booting nic', function (t) {
         getNic: [ { res: serverNics[1] } ],
         getNics: [ { res: serverNics } ],
         getNicTag: [ nicTag('admin'), nicTag('external') ],
-        listAggrs: [ { res: [] } ]
+        listAggrs: [ { res: [] } ],
+        listNetworkPools: [ { res: [] } ]
+
     };
 
     mocks.cnapi.VALUES = {
@@ -431,6 +548,12 @@ test('existing CN boots: NAPI connection error', function (t) {
         listAggrs: [
             { res: [] },
             { res: [] }
+        ],
+        listNetworkPools: [
+            { res: [] },
+            { res: [] },
+            { res: [] },
+            { res: [] }
         ]
     };
 
@@ -589,7 +712,11 @@ test('existing CN boots: CNAPI connection error', function (t) {
         getNicTag: [
             nicTag('admin'), nicTag('external')
         ],
-        listAggrs: [ { res: [] } ]
+        listAggrs: [ { res: [] } ],
+        listNetworkPools: [
+            { res: [] },
+            { res: [] }
+        ]
     };
 
     mocks.cnapi.VALUES = {
@@ -655,7 +782,8 @@ test('error while provisioning nic', function (t) {
     mocks.napi.VALUES = {
         getNic: [ { err: error404() } ],
         provisionNic: [ { err: new Error('XXX bad error') } ],
-        listAggrs: [ { res: [] } ]
+        listAggrs: [ { res: [] } ],
+        listNetworkPools: [ { res: [] } ]
     };
 
     mocks.cnapi.VALUES = {
@@ -691,7 +819,11 @@ test('invalid JSON in cache file',  function (t) {
         getNicTag: [
             nicTag('admin'), nicTag('external')
         ],
-        listAggrs: [ { res: [] } ]
+        listAggrs: [ { res: [] } ],
+        listNetworkPools: [
+            { res: [] },
+            { res: [] }
+        ]
     };
 
     mocks.cnapi.VALUES = {
@@ -753,6 +885,10 @@ test('aggregation', function (t) {
         listAggrs: [
             { res: [ aggr ] },
             { res: [ aggr ] }
+        ],
+        listNetworkPools: [
+            { res: [] },
+            { res: [] }
         ]
     };
 
diff --git a/test/lib/mocks.js b/test/lib/mocks.js
index fb79211..f598249 100644
--- a/test/lib/mocks.js
+++ b/test/lib/mocks.js
@@ -154,6 +154,16 @@ function createMocks() {
             { mac: mac, params: params }, cb);
     };
 
+    mocks.napi.listNetworks = function (params, options, cb) {
+        return this._handle('listNetworks',
+            { params: params, options: options }, cb);
+    };
+
+    mocks.napi.listNetworkPools = function (params, options, cb) {
+        return this._handle('listNetworkPools',
+            { params: params, options: options }, cb);
+    };
+
     // CNAPI
 
     mocks.cnapi = new Mock();
@@ -318,6 +328,7 @@ function registerMocks() {
         'util',
         'vasync',
         'verror',
+        '../../lib/admin-pool-cache',
         '../../lib/boot-files',
         '../../lib/cache',
         '../../lib/dhcpd',
diff --git a/test/lib/server.js b/test/lib/server.js
index 16b79ae..5d1ec90 100644
--- a/test/lib/server.js
+++ b/test/lib/server.js
@@ -13,9 +13,11 @@
  */
 
 var assert = require('assert-plus');
+var vasync = require('vasync');
+var mod_log = require('./log');
 var mod_boot_files;
 var mod_dhcpd;
-var mod_log = require('./log');
+var adminPoolCache;
 
 
 
@@ -24,15 +26,17 @@ var mod_log = require('./log');
 
 
 var ADMIN_UUID = '930896af-bf8c-48d4-885c-6573a94b1853';
-var SERVER;
+var SERVER = {};
 
 
 
-function createServer() {
-    if (SERVER) {
+function createServer(config) {
+    if (SERVER === {}) {
         return;
     }
 
+    var log = mod_log.child({ component: 'test-server' });
+
     if (!mod_boot_files) {
         mod_boot_files = require('../../lib/boot-files');
     }
@@ -41,30 +45,60 @@ function createServer() {
         mod_dhcpd = require('../../lib/dhcpd');
     }
 
-    SERVER = mod_dhcpd.createServer({
-        config: serverConfig(),
-        log: mod_log.child({ component: 'test-server' })
+    if (!adminPoolCache) {
+        adminPoolCache = require('../../lib/admin-pool-cache');
+    }
+
+    var cache = adminPoolCache.create({
+        napi: config.opts.napi,
+        log: log,
+        cacheUpdateInterval: config.cacheUpdateInterval
     });
+
+    var dhcp = mod_dhcpd.createServer({
+        config: config,
+        log: log,
+        adminPoolCache: cache,
+        napi: config.opts.napi,
+        cnapi: config.opts.cnapi
+    });
+
+    SERVER.dhcp = dhcp;
+    SERVER.cache = cache;
+    SERVER.log = log;
 }
 
+function destroyServer() {
+    SERVER.cache.quiesce();
+}
 
 function bootData(opts, callback) {
     assert.object(opts, 'opts');
     assert.string(opts.mac, 'opts.mac');
-    createServer();
-
-    SERVER.cnapi = opts.cnapi;
-    SERVER.napi = opts.napi;
-
-    mod_boot_files.writeAll({
-        config: serverConfig(),
-        cnapi: opts.cnapi,
-        log: mod_log.child({ mac: opts.mac }),
-        mac: opts.mac,
-        napi: opts.napi
-    }, callback);
-}
 
+    var config = serverConfig();
+    config.opts = opts;
+
+    createServer(config);
+    SERVER.cache.update(function (error) {
+        if (error) {
+            callback(error, null);
+        }
+
+        mod_boot_files.writeAll({
+            config: config,
+            cnapi: opts.cnapi,
+            log: mod_log.child({ mac: opts.mac }),
+            mac: opts.mac,
+            napi: opts.napi,
+            adminPoolCache: SERVER.cache,
+            nic_tag: opts.nic_tag
+        }, function (err, res) {
+            destroyServer();
+            callback(err, res);
+        });
+    });
+}
 
 function serverConfig() {
     return {
@@ -99,7 +133,8 @@ function serverConfig() {
             purgeIntervalSeconds: 36000,
             maxCacheFileAgeSeconds: 604800,
             refreshConcurrency: 1
-        }
+        },
+        cacheUpdateInterval: 60000
     };
 }
 
-- 
2.21.0

