From 07b1d84610315f1bf66433d0c0785e90e16767ab Mon Sep 17 00:00:00 2001
From: Jason King <jason.king@joyent.com>
Date: Thu, 3 Jan 2019 18:11:04 +0000
Subject: [PATCH] OS-7478 Add rust demangling support

---
 usr/src/cmd/dis/dis_util.c                    |   3 +-
 usr/src/cmd/mdb/common/mdb/mdb_cmds.c         |   4 +-
 usr/src/cmd/mdb/common/mdb/mdb_demangle.c     |   4 +-
 usr/src/cmd/sgs/elfdump/common/elfdump.msg    |   2 +-
 usr/src/cmd/sgs/pvs/common/pvs.c              |   2 +-
 usr/src/cmd/sgs/pvs/common/pvs.msg            |   3 +-
 usr/src/lib/Makefile                          |   2 +-
 usr/src/lib/libdemangle/Makefile.com          |   4 +-
 usr/src/lib/libdemangle/common/cxx.c          |   3 +-
 usr/src/lib/libdemangle/common/demangle-sys.h |   4 +-
 usr/src/lib/libdemangle/common/demangle.c     |  93 +++-
 usr/src/lib/libdemangle/common/demangle_int.h |  10 +-
 usr/src/lib/libdemangle/common/rust.c         | 424 ++++++++++++++++++
 usr/src/lib/libdemangle/common/strview.c      | 114 +++++
 usr/src/lib/libdemangle/common/strview.h      |  51 +++
 usr/src/lib/libdemangle/common/util.c         |  14 +
 usr/src/man/man1/dis.1                        |   4 +-
 usr/src/man/man1/dump.1                       |   4 +-
 usr/src/man/man1/elfdump.1                    |   4 +-
 usr/src/man/man1/gprof.1                      |   4 +-
 usr/src/man/man1/nm.1                         |   4 +-
 usr/src/man/man1/pvs.1                        |   4 +-
 usr/src/pkg/manifests/system-test-utiltest.mf |   2 +
 .../test/util-tests/tests/demangle/Makefile   |   7 +-
 usr/src/test/util-tests/tests/demangle/rust.c | 196 ++++++++
 25 files changed, 924 insertions(+), 42 deletions(-)
 create mode 100644 usr/src/lib/libdemangle/common/rust.c
 create mode 100644 usr/src/lib/libdemangle/common/strview.c
 create mode 100644 usr/src/lib/libdemangle/common/strview.h
 create mode 100644 usr/src/test/util-tests/tests/demangle/rust.c

diff --git a/usr/src/cmd/dis/dis_util.c b/usr/src/cmd/dis/dis_util.c
index f74e7cef67..af38189cb4 100644
--- a/usr/src/cmd/dis/dis_util.c
+++ b/usr/src/cmd/dis/dis_util.c
@@ -24,6 +24,7 @@
  * Use is subject to license terms.
  *
  * Copyright 2018 Jason King.
+ * Copyright 2018, Joyent, Inc.
  */
 
 #include <dlfcn.h>
@@ -106,6 +107,6 @@ dis_demangle(const char *name)
 	 * from previous invocations is freed.
 	 */
 	free(demangled_name);
-	demangled_name = sysdemangle(name, SYSDEM_LANG_CPP, NULL);
+	demangled_name = sysdemangle(name, SYSDEM_LANG_AUTO, NULL);
 	return ((demangled_name != NULL) ? demangled_name : name);
 }
diff --git a/usr/src/cmd/mdb/common/mdb/mdb_cmds.c b/usr/src/cmd/mdb/common/mdb/mdb_cmds.c
index 95584e6a89..56c20e37c2 100644
--- a/usr/src/cmd/mdb/common/mdb/mdb_cmds.c
+++ b/usr/src/cmd/mdb/common/mdb/mdb_cmds.c
@@ -3208,8 +3208,8 @@ const mdb_dcmd_t mdb_dcmd_builtins[] = {
 	 */
 	{ "?", "fmt-list", "format data from object file", cmd_print_object },
 	{ "$>", "[file]", "log session to a file", cmd_old_log },
-	{ "$g", "?", "get/set C++ demangling options", cmd_demflags },
-	{ "$G", NULL, "enable/disable C++ demangling support", cmd_demangle },
+	{ "$g", "?", "get/set demangling options", cmd_demflags },
+	{ "$G", NULL, "enable/disable demangling support", cmd_demangle },
 	{ "$i", NULL, "print signals that are ignored", cmd_notsup },
 	{ "$l", NULL, "print the representative thread's lwp id", cmd_notsup },
 	{ "$p", ":", "change debugger target context", cmd_context },
diff --git a/usr/src/cmd/mdb/common/mdb/mdb_demangle.c b/usr/src/cmd/mdb/common/mdb/mdb_demangle.c
index a24d889009..c477725489 100644
--- a/usr/src/cmd/mdb/common/mdb/mdb_demangle.c
+++ b/usr/src/cmd/mdb/common/mdb/mdb_demangle.c
@@ -24,6 +24,7 @@
  * Use is subject to license terms.
  *
  * Copyright 2018 Jason King
+ * Copyright 2018, Joyent, Inc.
  */
 
 /*
@@ -66,8 +67,7 @@ mdb_dem_load(void)
 	dmp->dm_len = 0;
 	dmp->dm_buf = NULL;
 	dmp->dm_flags = MDB_DM_SCOPE;
-	/* stick with C++ for now to match old behavior */
-	dmp->dm_lang = SYSDEM_LANG_CPP;
+	dmp->dm_lang = SYSDEM_LANG_AUTO;
 
 	return (dmp);
 }
diff --git a/usr/src/cmd/sgs/elfdump/common/elfdump.msg b/usr/src/cmd/sgs/elfdump/common/elfdump.msg
index 253ea4a788..5876b59f1f 100644
--- a/usr/src/cmd/sgs/elfdump/common/elfdump.msg
+++ b/usr/src/cmd/sgs/elfdump/common/elfdump.msg
@@ -37,7 +37,7 @@
 			 [-N name] [-O osabi] [-T type] [-p | -w outfile] \
 			 file...\n"
 @ MSG_USAGE_DETAIL1	"\t[-c]\t\tdump section header information\n"
-@ MSG_USAGE_DETAIL2	"\t[-C]\t\tdemangle C++ symbol names\n"
+@ MSG_USAGE_DETAIL2	"\t[-C]\t\tdemangle symbol names\n"
 @ MSG_USAGE_DETAIL3	"\t[-d]\t\tdump the contents of the .dynamic section\n"
 @ MSG_USAGE_DETAIL4	"\t[-e]\t\tdump the elf header\n"
 @ MSG_USAGE_DETAIL5	"\t[-g]\t\tdump the contents of the .group sections\n"
diff --git a/usr/src/cmd/sgs/pvs/common/pvs.c b/usr/src/cmd/sgs/pvs/common/pvs.c
index 4d51ce300d..4c353b887c 100644
--- a/usr/src/cmd/sgs/pvs/common/pvs.c
+++ b/usr/src/cmd/sgs/pvs/common/pvs.c
@@ -27,7 +27,7 @@
 /*
  * Analyze the versioning information within a file.
  *
- *   -C		demangle C++ symbol names.
+ *   -C		demangle symbol names.
  *
  *   -d		dump version definitions.
  *
diff --git a/usr/src/cmd/sgs/pvs/common/pvs.msg b/usr/src/cmd/sgs/pvs/common/pvs.msg
index 82a61385cd..eb888a753a 100644
--- a/usr/src/cmd/sgs/pvs/common/pvs.msg
+++ b/usr/src/cmd/sgs/pvs/common/pvs.msg
@@ -22,6 +22,7 @@
 #
 # Copyright 2008 Sun Microsystems, Inc.  All rights reserved.
 # Use is subject to license terms.
+# Copyright 2018, Joyent, Inc.
 #
 
 @ _START_
@@ -34,7 +35,7 @@
 # Argument usage messages.
 
 @ MSG_USAGE_BRIEF	"usage: %s [-Cdlnorsv] [-I index] [-N Name] file(s)\n"
-@ MSG_USAGE_DETAIL	"\t[-C]\t\tdemangle C++ symbol names\n\
+@ MSG_USAGE_DETAIL	"\t[-C]\t\tdemangle symbol names\n\
 			 \t[-d]\t\tprint version definition information\n\
 			 \t[-I index]\tqualify version with an index\n\
 			 \t[-l]\t\tprint reduced symbols\n\
diff --git a/usr/src/lib/Makefile b/usr/src/lib/Makefile
index 8e48dda5ed..c9fdcd761e 100644
--- a/usr/src/lib/Makefile
+++ b/usr/src/lib/Makefile
@@ -30,7 +30,7 @@
 # Copyright 2018 Nexenta Systems, Inc.
 # Copyright (c) 2016, Chris Fraire <cfraire@me.com>.
 # Copyright 2017 RackTop Systems.
-# Copyirght 2018 Jason King
+# Copyright 2018 Jason King
 #
 
 include ../Makefile.master
diff --git a/usr/src/lib/libdemangle/Makefile.com b/usr/src/lib/libdemangle/Makefile.com
index 0b0d495df7..7eba05ce1c 100644
--- a/usr/src/lib/libdemangle/Makefile.com
+++ b/usr/src/lib/libdemangle/Makefile.com
@@ -16,12 +16,12 @@
 
 LIBRARY = libdemangle-sys.a
 VERS    = .1
-OBJECTS = str.o util.o cxx_util.o cxx.o demangle.o
+OBJECTS = str.o strview.o util.o cxx_util.o cxx.o demangle.o rust.o
 
 include ../../Makefile.lib
 
 LIBS =		$(DYNLIB) $(LINTLIB)
-LDLIBS +=	-lc
+LDLIBS +=	-lc -lcustr
 
 SRCDIR =	../common
 $(LINTLIB) :=	SRCS = $(SRCDIR)/$(LINTSRC)
diff --git a/usr/src/lib/libdemangle/common/cxx.c b/usr/src/lib/libdemangle/common/cxx.c
index e3b4c06a8a..af5f549f78 100644
--- a/usr/src/lib/libdemangle/common/cxx.c
+++ b/usr/src/lib/libdemangle/common/cxx.c
@@ -165,11 +165,10 @@ static const char *parse_vector_type(const char *, const char *, cpp_db_t *);
 size_t cpp_name_max_depth = 1024;	/* max depth of name stack */
 
 char *
-cpp_demangle(const char *src, sysdem_ops_t *ops)
+cpp_demangle(const char *src, size_t srclen, sysdem_ops_t *ops)
 {
 	char *result = NULL;
 	cpp_db_t db;
-	size_t srclen = strlen(src);
 
 	if (!db_init(&db, ops))
 		goto done;
diff --git a/usr/src/lib/libdemangle/common/demangle-sys.h b/usr/src/lib/libdemangle/common/demangle-sys.h
index 02636c9521..05776ee5ee 100644
--- a/usr/src/lib/libdemangle/common/demangle-sys.h
+++ b/usr/src/lib/libdemangle/common/demangle-sys.h
@@ -11,6 +11,7 @@
 
 /*
  * Copyright 2017 Jason King
+ * Copyright 2018, Joyent, Inc.
  */
 
 #ifndef _DEMANGLE_SYS_H
@@ -24,7 +25,8 @@ extern "C" {
 
 typedef enum sysdem_lang_e {
 	SYSDEM_LANG_AUTO,
-	SYSDEM_LANG_CPP
+	SYSDEM_LANG_CPP,
+	SYSDEM_LANG_RUST
 } sysdem_lang_t;
 
 typedef struct sysdem_alloc_s {
diff --git a/usr/src/lib/libdemangle/common/demangle.c b/usr/src/lib/libdemangle/common/demangle.c
index e827fd8cec..03e029b1af 100644
--- a/usr/src/lib/libdemangle/common/demangle.c
+++ b/usr/src/lib/libdemangle/common/demangle.c
@@ -11,13 +11,17 @@
 
 /*
  * Copyright 2018 Jason King
+ * Copyright 2018, Joyent, Inc.
  */
 
 #include <stdlib.h>
+#include <stdio.h>
 #include <string.h>
 #include <errno.h>
 #include <pthread.h>
+#include <sys/ctype.h>
 #include <sys/debug.h>
+#include <stdarg.h>
 #include "demangle-sys.h"
 #include "demangle_int.h"
 
@@ -25,31 +29,67 @@
 
 static pthread_once_t debug_once = PTHREAD_ONCE_INIT;
 volatile boolean_t demangle_debug;
+FILE *debugf = stdout;
+
+static const char *
+langstr(sysdem_lang_t lang)
+{
+	switch (lang) {
+	case SYSDEM_LANG_AUTO:
+		return ("auto");
+	case SYSDEM_LANG_CPP:
+		return ("c++");
+	case SYSDEM_LANG_RUST:
+		return ("rust");
+	default:
+		/*
+		 * XXX: It'd be nice if there was a way to set panicstr
+		 * outside of libc so we could add a nice msg here, but
+		 * oh well.
+		 */
+		abort();
+	}
+}
 
 static sysdem_lang_t
-detect_lang(const char *str)
+detect_lang(const char *str, size_t n)
 {
-	size_t n = strlen(str);
+	const char *p = str;
+	size_t len;
 
 	if (n < 3 || str[0] != '_')
 		return (SYSDEM_LANG_AUTO);
 
-	switch (str[1]) {
-	case 'Z':
+	p = str + 1;
+	n--;
+	if (*p == '_') {
+		p++;
+		n--;
+	}
+
+	if (*p != 'Z')
+		return (SYSDEM_LANG_AUTO);
+
+	/*
+	 * Sadly, rust currently uses the same prefix as C++, however
+	 * demangling rust as a C++ mangled name yields less than desirable
+	 * results.  However rust names end with a hash.  We use that to attempt to
+	 * disambiguate
+	 */
+
+	/* Find 'h'<hexdigit>+E$ */
+	if ((p = strrchr(str, 'h')) == NULL)
 		return (SYSDEM_LANG_CPP);
 
-	case '_':
-		break;
+	if ((len = strspn(p + 1, "0123456789abcdef")) == 0)
+		return (SYSDEM_LANG_CPP);
 
-	default:
-		return (SYSDEM_LANG_AUTO);
-	}
+	p += len + 1;
 
-	/* why they use ___Z sometimes is puzzling... *sigh* */
-	if (str[2] == '_' && str[3] == 'Z')
+	if (p[0] != 'E' || p[1] != '\0')
 		return (SYSDEM_LANG_CPP);
 
-	return (SYSDEM_LANG_AUTO);
+	return (SYSDEM_LANG_RUST);
 }
 
 static void
@@ -62,26 +102,51 @@ check_debug(void)
 char *
 sysdemangle(const char *str, sysdem_lang_t lang, sysdem_ops_t *ops)
 {
+	size_t slen = strlen(str);
+
 	VERIFY0(pthread_once(&debug_once, check_debug));
 
 	if (ops == NULL)
 		ops = sysdem_ops_default;
 
+	DEMDEBUG("name = '%s'", str);
+	DEMDEBUG("lang = %s", langstr(lang));
+
 	if (lang == SYSDEM_LANG_AUTO) {
-		lang = detect_lang(str);
+		lang = detect_lang(str, slen);
 		if (lang == SYSDEM_LANG_AUTO) {
+			DEMDEBUG("could not detect language");
 			errno = ENOTSUP;
 			return (NULL);
 		}
+		DEMDEBUG("detected language is %s", langstr(lang));
 	}
 
 	switch (lang) {
 	case SYSDEM_LANG_AUTO:
 		break;
 	case SYSDEM_LANG_CPP:
-		return (cpp_demangle(str, ops));
+		return (cpp_demangle(str, slen, ops));
+	case SYSDEM_LANG_RUST:
+		return (rust_demangle(str, slen, ops));
 	}
 
 	errno = ENOTSUP;
 	return (NULL);
 }
+
+int
+demdebug(const char *fmt, ...)
+{
+	va_list ap;
+
+	flockfile(debugf);
+	(void) fprintf(debugf, "LIBDEMANGLE: ");
+	va_start(ap, fmt);
+	(void) vfprintf(debugf, fmt, ap);
+	(void) fputc('\n', debugf);
+	va_end(ap);
+	funlockfile(debugf);
+
+	return (0);
+}
diff --git a/usr/src/lib/libdemangle/common/demangle_int.h b/usr/src/lib/libdemangle/common/demangle_int.h
index 9abb2cc295..1cf6d19d1d 100644
--- a/usr/src/lib/libdemangle/common/demangle_int.h
+++ b/usr/src/lib/libdemangle/common/demangle_int.h
@@ -11,6 +11,7 @@
 
 /*
  * Copyright 2017 Jason King
+ * Copyright 2018, Joyent, Inc.
  */
 #ifndef _DEMANGLE_INT_H
 #define	_DEMANGLE_INT_H
@@ -24,13 +25,20 @@ extern "C" {
 
 extern sysdem_ops_t *sysdem_ops_default;
 
-char *cpp_demangle(const char *, sysdem_ops_t *);
+char *cpp_demangle(const char *, size_t, sysdem_ops_t *);
+char *rust_demangle(const char *, size_t, sysdem_ops_t *);
 
 void *zalloc(sysdem_ops_t *, size_t);
 void *xrealloc(sysdem_ops_t *, void *, size_t, size_t);
 void xfree(sysdem_ops_t *, void *, size_t);
+char *xstrdup(sysdem_ops_t *, const char *);
 
 extern volatile boolean_t demangle_debug;
+extern FILE *debugf;
+int demdebug(const char *, ...);
+
+#define	DEMDEBUG(s, ...) \
+	((void)(demangle_debug && demdebug(s, ## __VA_ARGS__)))
 
 #ifdef __cplusplus
 }
diff --git a/usr/src/lib/libdemangle/common/rust.c b/usr/src/lib/libdemangle/common/rust.c
new file mode 100644
index 0000000000..0f2f44c291
--- /dev/null
+++ b/usr/src/lib/libdemangle/common/rust.c
@@ -0,0 +1,424 @@
+/*
+ * This file and its contents are supplied under the terms of the
+ * Common Development and Distribution License ("CDDL"), version 1.0.
+ * You may only use this file in accordance with the terms of version
+ * 1.0 of the CDDL.
+ *
+ * A full copy of the text of the CDDL should have accompanied this
+ * source.  A copy of the CDDL is also available via the Internet at
+ * http://www.illumos.org/license/CDDL.
+ */
+
+/*
+ * Copyright 2018, Joyent, Inc.
+ */
+
+#include <errno.h>
+#include <libcustr.h>
+#include <limits.h>
+#include <string.h>
+#include <sys/ctype.h>
+#include <sys/debug.h>
+#include <stdio.h>
+
+#include "strview.h"
+#include "demangle_int.h"
+
+typedef struct rustdem_state {
+	const char	*rds_str;
+	custr_t		*rds_demangled;
+	sysdem_ops_t	*rds_ops;
+	int		rds_error;
+} rustdem_state_t;
+
+typedef struct rustdem_ops {
+	custr_alloc_t	rdo_custr;
+	rustdem_state_t	*rdo_demstate;
+} rustdem_ops_t;
+
+static struct rust_charmap {
+	const char	*ruc_seq;
+	char		ruc_ch;
+} rust_charmap[] = {
+	{ "$SP$", '@' },
+	{ "$BP$", '*' },
+	{ "$RF$", '&' },
+	{ "$LT$", '<' },
+	{ "$GT$", '>' },
+	{ "$LP$", '(' },
+	{ "$RP$", ')' },
+	{ "$C$", ',' },
+	{ "$u7e$", '~' },
+	{ "$u20$", ' ' },
+	{ "$u27$", '\'' },
+	{ "$u3d$", '=' },
+	{ "$u5b$", '[' },
+	{ "$u5d$", ']' },
+	{ "$u7b$", '{' },
+	{ "$u7d$", '}' },
+	{ "$u3b$", ';' },
+	{ "$u2b$", '+' },
+	{ "$u22$", '"' }
+};
+static const size_t rust_charmap_sz =
+    sizeof (rust_charmap) / sizeof (rust_charmap[0]);
+
+static void *rustdem_alloc(custr_alloc_t *, size_t);
+static void rustdem_free(custr_alloc_t *, void *, size_t);
+
+static boolean_t rustdem_append_c(rustdem_state_t *, int);
+static boolean_t rustdem_all_ascii(const strview_t *);
+
+static boolean_t rustdem_parse_prefix(rustdem_state_t *, strview_t *);
+static boolean_t rustdem_parse_name(rustdem_state_t *, strview_t *);
+static boolean_t rustdem_parse_hash(rustdem_state_t *, strview_t *);
+static boolean_t rustdem_parse_num(rustdem_state_t *, strview_t *, uint64_t *);
+static boolean_t rustdem_parse_special(rustdem_state_t *, strview_t *);
+static boolean_t rustdem_add_sep(rustdem_state_t *);
+
+char *
+rust_demangle(const char *s, size_t slen, sysdem_ops_t *ops)
+{
+	rustdem_state_t st = {
+		.rds_str = s,
+		.rds_ops = ops,
+	};
+	rustdem_ops_t rustdem_ops = {
+		.rdo_custr = {
+			.custr_ao_alloc = rustdem_alloc,
+			.custr_ao_free = rustdem_free
+		},
+		.rdo_demstate = &st
+	};
+	strview_t sv;
+	int ret;
+
+	(void) sv_init_str(&sv, s, s + slen);
+
+	if (sv_remaining(&sv) < 1 || sv_peek(&sv, -1) != 'E') {
+		DEMDEBUG("ERROR: string is either too small or does not end "
+		    "with 'E'");
+		errno = EINVAL;
+		return (NULL);
+	}
+
+	if (!rustdem_parse_prefix(&st, &sv)) {
+		DEMDEBUG("ERROR: could not parse prefix");
+		errno = EINVAL;
+		return (NULL);
+	}
+	DEMDEBUG("parsed prefix; remaining='%.*s'", SV_PRINT(&sv));
+
+	if (!rustdem_all_ascii(&sv)) {
+		/* rustdem_all_ascii() provides debug output */
+		errno = EINVAL;
+		return (NULL);
+	}
+
+	if ((ret = custr_xalloc(&st.rds_demangled,
+	    &rustdem_ops.rdo_custr)) != 0)
+		return (NULL);
+
+	while (sv_remaining(&sv) > 1) {
+		if (rustdem_parse_name(&st, &sv))
+			continue;
+		if (st.rds_error != 0)
+			goto fail;
+	}
+
+	if (st.rds_error != 0 || !sv_consume_if_c(&sv, 'E'))
+		goto fail;
+
+	char *res = xstrdup(ops, custr_cstr(st.rds_demangled));
+	if (res == NULL) {
+		st.rds_error = errno;
+		goto fail;
+	}
+
+	custr_free(st.rds_demangled);
+	DEMDEBUG("result = '%s'", res);
+	return (res);
+
+fail:
+	custr_free(st.rds_demangled);
+	errno = st.rds_error;
+	return (NULL);
+}
+
+static boolean_t
+rustdem_parse_prefix(rustdem_state_t *st, strview_t *svp)
+{
+	strview_t pfx = SV_INIT(svp);
+
+	DEMDEBUG("checking for '_ZN' or '__ZN' in '%.*s'", SV_PRINT(&pfx));
+
+	if (st->rds_error != 0)
+		return (B_FALSE);
+
+	if (!sv_consume_if_c(&pfx, '_'))
+		return (B_FALSE);
+
+	(void) sv_consume_if_c(&pfx, '_');
+
+	if (!sv_consume_if_c(&pfx, 'Z') || !sv_consume_if_c(&pfx, 'N'))
+		return (B_FALSE);
+
+	/* Update svp with new position */
+	(void) sv_init_sv(svp, &pfx);
+	return (B_TRUE);
+}
+
+static boolean_t
+rustdem_parse_name_segment(rustdem_state_t *st, strview_t *svp, boolean_t first)
+{
+	strview_t sv = SV_INIT(svp);
+	strview_t name;
+	uint64_t len;
+	size_t rem;
+	boolean_t last = B_FALSE;
+
+	if (st->rds_error != 0 || sv_remaining(svp) == 0)
+		return (B_FALSE);
+
+	if (!rustdem_parse_num(st, &sv, &len)) {
+		DEMDEBUG("ERROR: no leading length");
+		st->rds_error = EINVAL;
+		return (B_FALSE);
+	}
+
+	rem = sv_remaining(&sv);
+
+	if (rem < len || len > SIZE_MAX) {
+		st->rds_error = EINVAL;
+		return (B_FALSE);
+	}
+
+	/* Is this the last segment before the terminating E? */
+	if (rem == len + 1) {
+		VERIFY3U(sv_peek(&sv, -1), ==, 'E');
+		last = B_TRUE;
+	}
+
+	if (!first && !rustdem_add_sep(st))
+		return (B_FALSE);
+
+	/* Reduce length of seg to the length we parsed */
+	(void) sv_init_sv_range(&name, &sv, len);
+
+	DEMDEBUG("%s: segment='%.*s'", __func__, SV_PRINT(&name));
+
+	/*
+	 * A rust hash starts with 'h', and is the last component of a name
+	 * before the terminating 'E'
+	 */
+	if (sv_peek(&name, 0) == 'h' && last) {
+		if (!rustdem_parse_hash(st, &name))
+			return (B_FALSE);
+		goto done;
+	}
+
+	while (sv_remaining(&name) > 0) {
+		switch (sv_peek(&name, 0)) {
+		case '$':
+			if (rustdem_parse_special(st, &name))
+				continue;
+			break;
+		case '_':
+			if (sv_peek(&name, 1) == '$') {
+				/*
+				 * Only consume/ignore '_'.  Leave
+				 * $ for next round.
+				 */
+				sv_consume_n(&name, 1);
+				continue;
+			}
+			break;
+		case '.':
+			if (sv_peek(&name, 1) != '.') {
+				if (!rustdem_append_c(st, '.'))
+					return (B_FALSE);
+				break;
+			}
+
+			if (!rustdem_add_sep(st))
+				return (B_FALSE);
+
+			sv_consume_n(&name, 2);
+			continue;
+		}
+
+		if (custr_appendc(st->rds_demangled,
+		    sv_consume_c(&name)) != 0) {
+			st->rds_error = ENOMEM;
+			return (B_FALSE);
+		}
+	}
+
+done:
+	DEMDEBUG("%s: consumed '%.*s'", __func__, (int)len, svp->sv_first);
+	sv_consume_n(&sv, len);
+	(void) sv_init_sv(svp, &sv);
+	return (B_TRUE);
+}
+
+static boolean_t
+rustdem_parse_name(rustdem_state_t *st, strview_t *svp)
+{
+	strview_t name = SV_INIT(svp);
+	boolean_t first = B_TRUE;
+
+	if (st->rds_error != 0)
+		return (B_FALSE);
+
+	if (sv_remaining(&name) == 0)
+		return (B_FALSE);
+
+	while (sv_remaining(&name) > 0 && sv_peek(&name, 0) != 'E') {
+		if (!rustdem_parse_name_segment(st, &name, first))
+			return (B_FALSE);
+		first = B_FALSE;
+	}
+
+	(void) sv_init_sv(svp, &name);
+	return (B_TRUE);
+}
+
+static boolean_t
+rustdem_parse_hash(rustdem_state_t *st, strview_t *svp)
+{
+	strview_t sv = SV_INIT(svp);
+
+	VERIFY(sv_consume_if_c(&sv, 'h'));
+	if (!rustdem_append_c(st, 'h'))
+		return (B_FALSE);
+
+	while (sv_remaining(&sv) > 0) {
+		char c;
+		switch (c = sv_consume_c(&sv)) {
+		case '0': case '1': case '2': case '3':
+		case '4': case '5': case '6': case '7':
+		case '8': case '9': case 'a': case 'b':
+		case 'c': case 'd': case 'e': case 'f':
+			if (!rustdem_append_c(st, c))
+				return (B_FALSE);
+			break;
+		default:
+			return (B_FALSE);
+		}
+	}
+
+	(void) sv_init_sv(svp, &sv);
+	return (B_TRUE);
+}
+
+static boolean_t
+rustdem_parse_num(rustdem_state_t *restrict st, strview_t *restrict svp,
+    uint64_t *restrict valp)
+{
+	strview_t snum = SV_INIT(svp);
+	uint64_t v = 0;
+	size_t ndigits = 0;
+
+	if (st->rds_error != 0)
+		return (B_FALSE);
+
+	DEMDEBUG("%s: str='%.*s'", __func__, SV_PRINT(&snum));
+
+	if (!ISDIGIT(sv_peek(&snum, 0))) {
+		DEMDEBUG("%s: ERROR no digits in str\n", __func__);
+		return (B_FALSE);
+	}
+
+	while (sv_remaining(&snum) > 0) {
+		char c = sv_consume_c(&snum);
+
+		if (!ISDIGIT(c))
+			break;
+
+		v *= 10;
+		v += c - '0';
+		ndigits++;
+	}
+
+	DEMDEBUG("%s: num=%llu", __func__, v);
+
+	*valp = v;
+	sv_consume_n(svp, ndigits);
+	return (B_TRUE);
+}
+
+static boolean_t
+rustdem_parse_special(rustdem_state_t *st, strview_t *svp)
+{
+	if (st->rds_error != 0)
+		return (B_FALSE);
+
+	if (sv_peek(svp, 0) != '$')
+		return (B_FALSE);
+
+	for (size_t i = 0; i < rust_charmap_sz; i++) {
+		if (sv_consume_if(svp, rust_charmap[i].ruc_seq)) {
+			if (!rustdem_append_c(st, rust_charmap[i].ruc_ch))
+				return (B_FALSE);
+			return (B_TRUE);
+		}
+	}
+	return (B_FALSE);
+}
+
+static boolean_t
+rustdem_add_sep(rustdem_state_t *st)
+{
+	if (st->rds_error != 0)
+		return (B_FALSE);
+
+	if (!rustdem_append_c(st, ':') ||
+	    !rustdem_append_c(st, ':'))
+		return (B_FALSE);
+
+	return (B_TRUE);
+}
+
+static boolean_t
+rustdem_append_c(rustdem_state_t *st, int c)
+{
+	if (st->rds_error != 0)
+		return (B_FALSE);
+
+	if (custr_appendc(st->rds_demangled, c) == 0)
+		return (B_TRUE);
+
+	st->rds_error = errno;
+	return (B_FALSE);
+}
+
+static boolean_t
+rustdem_all_ascii(const strview_t *svp)
+{
+	strview_t p = SV_INIT(svp);
+
+	while (sv_remaining(&p) > 0) {
+		char c;
+		if (((c = sv_consume_c(&p)) & 0x80) != 0) {
+			DEMDEBUG("%s: found non-ascii character 0x%02hhx at "
+			    "offset %tu", __func__, c,
+			    (ptrdiff_t)(p.sv_first - svp->sv_first));
+			return (B_FALSE);
+		}
+	}
+	return (B_TRUE);
+}
+
+static void *
+rustdem_alloc(custr_alloc_t *cao, size_t len)
+{
+	rustdem_ops_t *rdo = (rustdem_ops_t *)cao;
+	return (zalloc(rdo->rdo_demstate->rds_ops, len));
+}
+
+static void
+rustdem_free(custr_alloc_t *cao, void *p, size_t len)
+{
+	rustdem_ops_t *rdo = (rustdem_ops_t *)cao;
+	xfree(rdo->rdo_demstate->rds_ops, p, len);
+}
diff --git a/usr/src/lib/libdemangle/common/strview.c b/usr/src/lib/libdemangle/common/strview.c
new file mode 100644
index 0000000000..4836290494
--- /dev/null
+++ b/usr/src/lib/libdemangle/common/strview.c
@@ -0,0 +1,114 @@
+/*
+ * This file and its contents are supplied under the terms of the
+ * Common Development and Distribution License ("CDDL"), version 1.0.
+ * You may only use this file in accordance with the terms of version
+ * 1.0 of the CDDL.
+ *
+ * A full copy of the text of the CDDL should have accompanied this
+ * source.  A copy of the CDDL is also available via the Internet at
+ * http://www.illumos.org/license/CDDL.
+ */
+
+/*
+ * Copyright 2018, Joyent, Inc.
+ */
+
+#include <string.h>
+#include <sys/debug.h>
+#include "strview.h"
+
+strview_t *
+sv_init_sv(strview_t *sv, const strview_t *src)
+{
+	sv->sv_first = src->sv_first;
+	sv->sv_last = src->sv_last;
+	return (sv);
+}
+
+strview_t *
+sv_init_sv_range(strview_t *sv, const strview_t *src, size_t len)
+{
+	VERIFY3U(sv_remaining(src), >=, len);
+
+	sv->sv_first = src->sv_first;
+	sv->sv_last = src->sv_first + len;
+	return (sv);
+}
+
+strview_t *
+sv_init_str(strview_t *sv, const char *first, const char *last)
+{
+	if (last == NULL)
+		last = first + strlen(first);
+
+	VERIFY3P(first, <=, last);
+	sv->sv_first = first;
+	sv->sv_last = last;
+	return (sv);
+}
+
+strview_t *
+sv_init_str_len(strview_t *sv, const char *s, size_t len)
+{
+	size_t slen = strlen(s);
+
+	VERIFY3U(len, <=, slen);
+	sv->sv_first = s;
+	sv->sv_last = s + len;
+	return (sv);
+}
+
+size_t
+sv_remaining(const strview_t *sv)
+{
+	return ((size_t)(sv->sv_last - sv->sv_first));
+}
+
+boolean_t
+sv_consume_if_c(strview_t *sv, char c)
+{
+	size_t rem = sv_remaining(sv);
+
+	if (rem < 1 || *sv->sv_first != c)
+		return (B_FALSE);
+
+	sv->sv_first++;
+	return (B_TRUE);
+}
+
+boolean_t
+sv_consume_if(strview_t *sv, const char *str)
+{
+	size_t slen = strlen(str);
+	size_t rem = sv_remaining(sv);
+
+	if (rem < slen)
+		return (B_FALSE);
+	if (strncmp(sv->sv_first, str, slen) != 0)
+		return (B_FALSE);
+
+	sv->sv_first += slen;
+	return (B_TRUE);
+}
+
+char
+sv_peek(const strview_t *sv, ssize_t n)
+{
+	const char *p;
+
+	p = (n >= 0) ? sv->sv_first + n : sv->sv_last + n;
+	return ((p >= sv->sv_first && p < sv->sv_last) ? *p : '\0');
+}
+
+char
+sv_consume_c(strview_t *sv)
+{
+	return ((sv->sv_first < sv->sv_last) ? *sv->sv_first++ : '\0');
+}
+
+void
+sv_consume_n(strview_t *sv, size_t n)
+{
+	VERIFY3U(sv_remaining(sv), >=, n);
+	sv->sv_first += n;
+}
diff --git a/usr/src/lib/libdemangle/common/strview.h b/usr/src/lib/libdemangle/common/strview.h
new file mode 100644
index 0000000000..7e888ba960
--- /dev/null
+++ b/usr/src/lib/libdemangle/common/strview.h
@@ -0,0 +1,51 @@
+/*
+ * This file and its contents are supplied under the terms of the
+ * Common Development and Distribution License ("CDDL"), version 1.0.
+ * You may only use this file in accordance with the terms of version
+ * 1.0 of the CDDL.
+ *
+ * A full copy of the text of the CDDL should have accompanied this
+ * source.  A copy of the CDDL is also available via the Internet at
+ * http://www.illumos.org/license/CDDL.
+ */
+
+/*
+ * Copyright 2018, Joyent, Inc.
+ */
+
+#ifndef _STRVIEW_H
+#define	_STRVIEW_H
+
+#include <inttypes.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef struct strview {
+	const char *sv_first;
+	const char *sv_last;
+} strview_t;
+
+#define	SV_INIT(_src) {			\
+	.sv_first = (_src)->sv_first,	\
+	.sv_last = (_src)->sv_last	\
+}
+
+#define	SV_PRINT(_sv)	(int)((_sv)->sv_last - (_sv)->sv_first), (_sv)->sv_first
+strview_t *sv_init_sv(strview_t *, const strview_t *);
+strview_t *sv_init_sv_range(strview_t *, const strview_t *, size_t);
+strview_t *sv_init_str(strview_t *, const char *, const char *);
+strview_t *sv_init_str_len(strview_t *, const char *, size_t);
+size_t sv_remaining(const strview_t *);
+char sv_peek(const strview_t *, ssize_t);
+char sv_consume_c(strview_t *);
+void sv_consume_n(strview_t *, size_t);
+boolean_t sv_consume_if(strview_t *, const char *);
+boolean_t sv_consume_if_c(strview_t *, char);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _STRVIEW_H */
diff --git a/usr/src/lib/libdemangle/common/util.c b/usr/src/lib/libdemangle/common/util.c
index 9ffb72c79b..d9cfabc9be 100644
--- a/usr/src/lib/libdemangle/common/util.c
+++ b/usr/src/lib/libdemangle/common/util.c
@@ -11,6 +11,7 @@
 
 /*
  * Copyright 2017 Jason King
+ * Copyright 2018, Joyent, Inc.
  */
 
 #include <sys/debug.h>
@@ -71,6 +72,19 @@ xrealloc(sysdem_ops_t *ops, void *p, size_t oldsz, size_t newsz)
 	return (temp);
 }
 
+char *
+xstrdup(sysdem_ops_t *ops, const char *src)
+{
+	size_t len = strlen(src);
+	char *str = zalloc(ops, len + 1);
+
+	if (str == NULL)
+		return (NULL);
+
+	(void) memcpy(str, src, len);
+	return (str);
+}
+
 /*ARGSUSED*/
 static void
 def_free(void *p, size_t len)
diff --git a/usr/src/man/man1/dis.1 b/usr/src/man/man1/dis.1
index bff3a55372..dcb12b50b6 100644
--- a/usr/src/man/man1/dis.1
+++ b/usr/src/man/man1/dis.1
@@ -44,7 +44,7 @@
 .\" Portions Copyright (c) 1992, X/Open Company Limited  All Rights Reserved
 .\" Copyright (c) 2009, Sun Microsystems, Inc.  All Rights Reserved
 .\"
-.TH DIS 1 "Aug 24, 2009"
+.TH DIS 1 "Dec 19, 2018"
 .SH NAME
 dis \- object code disassembler
 .SH SYNOPSIS
@@ -74,7 +74,7 @@ The following options are supported:
 \fB\fB-C\fR\fR
 .ad
 .RS 15n
-Displays demangled C++ symbol names in the disassembly.
+Displays demangled symbol names in the disassembly.
 .RE
 
 .sp
diff --git a/usr/src/man/man1/dump.1 b/usr/src/man/man1/dump.1
index 50540b462d..ebe40fe09a 100644
--- a/usr/src/man/man1/dump.1
+++ b/usr/src/man/man1/dump.1
@@ -3,7 +3,7 @@
 .\" The contents of this file are subject to the terms of the Common Development and Distribution License (the "License").  You may not use this file except in compliance with the License.
 .\" You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE or http://www.opensolaris.org/os/licensing.  See the License for the specific language governing permissions and limitations under the License.
 .\" When distributing Covered Code, include this CDDL HEADER in each file and include the License file at usr/src/OPENSOLARIS.LICENSE.  If applicable, add the following below this CDDL HEADER, with the fields enclosed by brackets "[]" replaced with your own identifying information: Portions Copyright [yyyy] [name of copyright owner]
-.TH DUMP 1 "Sep 6, 2002"
+.TH DUMP 1 "Dec 19, 2018"
 .SH NAME
 dump \- dump selected parts of an object file
 .SH SYNOPSIS
@@ -65,7 +65,7 @@ Dumps the string table(s).
 \fB\fB-C\fR\fR
 .ad
 .RS 20n
-Dumps decoded C++ symbol table names.
+Dumps decoded symbol table names.
 .RE
 
 .sp
diff --git a/usr/src/man/man1/elfdump.1 b/usr/src/man/man1/elfdump.1
index c27e7aef0b..01a9963189 100644
--- a/usr/src/man/man1/elfdump.1
+++ b/usr/src/man/man1/elfdump.1
@@ -11,7 +11,7 @@
 .\"  If applicable, add the following below this CDDL HEADER, with the fields
 .\" enclosed by brackets "[]" replaced with your own identifying information:
 .\" Portions Copyright [yyyy] [name of copyright owner]
-.TH ELFDUMP 1 "Apr 3, 2009"
+.TH ELFDUMP 1 "Dec 19, 2018"
 .SH NAME
 elfdump \- dumps selected parts of an object file
 .SH SYNOPSIS
@@ -111,7 +111,7 @@ Dumps section header information.
 \fB\fB-C\fR\fR
 .ad
 .RS 18n
-Demangles C++ symbol names.
+Demangles symbol names.
 .RE
 
 .sp
diff --git a/usr/src/man/man1/gprof.1 b/usr/src/man/man1/gprof.1
index 4e2d0bf807..a6bfc0f2b4 100644
--- a/usr/src/man/man1/gprof.1
+++ b/usr/src/man/man1/gprof.1
@@ -3,7 +3,7 @@
 .\" The contents of this file are subject to the terms of the Common Development and Distribution License (the "License").  You may not use this file except in compliance with the License.
 .\" You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE or http://www.opensolaris.org/os/licensing.  See the License for the specific language governing permissions and limitations under the License.
 .\" When distributing Covered Code, include this CDDL HEADER in each file and include the License file at usr/src/OPENSOLARIS.LICENSE.  If applicable, add the following below this CDDL HEADER, with the fields enclosed by brackets "[]" replaced with your own identifying information: Portions Copyright [yyyy] [name of copyright owner]
-.TH GPROF 1 "Feb 8, 2007"
+.TH GPROF 1 "Dec 19, 2018"
 .SH NAME
 gprof \- display call-graph profile data
 .SH SYNOPSIS
@@ -109,7 +109,7 @@ shared objects' text segments are not examined.
 \fB\fB-C\fR\fR
 .ad
 .RS 19n
-Demangle C++ symbol names before printing them out.
+Demangle symbol names before printing them out.
 .RE
 
 .sp
diff --git a/usr/src/man/man1/nm.1 b/usr/src/man/man1/nm.1
index 23c1757ee1..f4f8cdda74 100644
--- a/usr/src/man/man1/nm.1
+++ b/usr/src/man/man1/nm.1
@@ -44,7 +44,7 @@
 .\" Portions Copyright (c) 1992, X/Open Company Limited  All Rights Reserved
 .\" Copyright (c) 2007, Sun Microsystems, Inc.  All Rights Reserved
 .\"
-.TH NM 1 "Sep 10, 2013"
+.TH NM 1 "Dec 19, 2018"
 .SH NAME
 nm \- print name list of an object file
 .SH SYNOPSIS
@@ -88,7 +88,7 @@ Writes the full path name or library name of an object on each line.
 \fB\fB-C\fR\fR
 .ad
 .RS 13n
-Demangles C++ symbol names before printing them out.
+Demangles symbol names before printing them out.
 .RE
 
 .sp
diff --git a/usr/src/man/man1/pvs.1 b/usr/src/man/man1/pvs.1
index 8304261cd3..9375613b36 100644
--- a/usr/src/man/man1/pvs.1
+++ b/usr/src/man/man1/pvs.1
@@ -4,7 +4,7 @@
 .\" The contents of this file are subject to the terms of the Common Development and Distribution License (the "License").  You may not use this file except in compliance with the License.
 .\" You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE or http://www.opensolaris.org/os/licensing.  See the License for the specific language governing permissions and limitations under the License.
 .\" When distributing Covered Code, include this CDDL HEADER in each file and include the License file at usr/src/OPENSOLARIS.LICENSE.  If applicable, add the following below this CDDL HEADER, with the fields enclosed by brackets "[]" replaced with your own identifying information: Portions Copyright [yyyy] [name of copyright owner]
-.TH PVS 1 "Sep 25, 2008"
+.TH PVS 1 "Dec 19, 2018"
 .SH NAME
 pvs \- display the internal version information of dynamic objects
 .SH SYNOPSIS
@@ -63,7 +63,7 @@ options are specified, both are enabled.
 \fB\fB-C\fR\fR
 .ad
 .RS 18n
-Demangles C++ symbol names.
+Demangles symbol names.
 .RE
 
 .sp
diff --git a/usr/src/pkg/manifests/system-test-utiltest.mf b/usr/src/pkg/manifests/system-test-utiltest.mf
index 0797eed1b0..0bc5244aec 100644
--- a/usr/src/pkg/manifests/system-test-utiltest.mf
+++ b/usr/src/pkg/manifests/system-test-utiltest.mf
@@ -15,6 +15,7 @@
 # Copyright 2014 Nexenta Systems, Inc. All rights reserved.
 # Copyright 2017 Joyent, Inc.
 # Copyright 2017 Jason King.
+# Copyright 2018, Joyent, Inc.
 #
 
 set name=pkg.fmri value=pkg:/system/test/utiltest@$(PKGVERS)
@@ -1121,6 +1122,7 @@ file path=opt/util-tests/tests/date_test mode=0555
 file path=opt/util-tests/tests/demangle/afl-fast mode=0555
 file path=opt/util-tests/tests/demangle/gcc-libstdc++ mode=0555
 file path=opt/util-tests/tests/demangle/llvm-stdcxxabi mode=0555
+file path=opt/util-tests/tests/demangle/rust mode=0555
 file path=opt/util-tests/tests/dis/distest mode=0555
 file path=opt/util-tests/tests/dis/i386/32.adx.out mode=0444
 file path=opt/util-tests/tests/dis/i386/32.adx.s mode=0444
diff --git a/usr/src/test/util-tests/tests/demangle/Makefile b/usr/src/test/util-tests/tests/demangle/Makefile
index fd64f0a2f4..99b2bd69b3 100644
--- a/usr/src/test/util-tests/tests/demangle/Makefile
+++ b/usr/src/test/util-tests/tests/demangle/Makefile
@@ -11,6 +11,7 @@
 
 #
 # Copyright 2018 Jason King.
+# Copyright 2018, Joyent, Inc.
 #
 
 include $(SRC)/Makefile.master
@@ -19,7 +20,7 @@ include $(SRC)/test/Makefile.com
 
 ROOTBINDIR = $(ROOTOPTPKG)/bin
 
-PROG = gcc-libstdc++ llvm-stdcxxabi afl-fast
+PROG = gcc-libstdc++ llvm-stdcxxabi afl-fast rust
 
 ROOTOPTPKG = $(ROOT)/opt/util-tests
 TESTDIR = $(ROOTOPTPKG)/tests/demangle
@@ -48,6 +49,10 @@ afl-fast: afl-fast.o
 	$(LINK.c) -o $@ afl-fast.o $(LDLIBS)
 	$(POST_PROCESS)
 
+rust: rust.o
+	$(LINK.c) -o $@ rust.o $(LDLIBS)
+	$(POST_PROCESS)
+
 install: all $(CMDS)
 
 lint:
diff --git a/usr/src/test/util-tests/tests/demangle/rust.c b/usr/src/test/util-tests/tests/demangle/rust.c
new file mode 100644
index 0000000000..9e56eeca73
--- /dev/null
+++ b/usr/src/test/util-tests/tests/demangle/rust.c
@@ -0,0 +1,196 @@
+/*
+ * Copyright (c) 2014 Alex Crichton
+ *
+ * Permission is hereby granted, free of charge, to any
+ * person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the
+ * Software without restriction, including without
+ * limitation the rights to use, copy, modify, merge,
+ * publish, distribute, sublicense, and/or sell copies of
+ * the Software, and to permit persons to whom the Software
+ * is furnished to do so, subject to the following
+ * conditions:
+ *
+ * The above copyright notice and this permission notice
+ * shall be included in all copies or substantial portions
+ * of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF
+ * ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED
+ * TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
+ * PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT
+ * SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
+ * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ */
+/*
+ * Copyright 2018, Joyent, Inc.
+ */
+
+/*
+ * Test cases taken from rustc-demangle 0.1.9
+ */
+#include <errno.h>
+#include <stdio.h>
+#include <string.h>
+#include <demangle-sys.h>
+
+typedef struct rust_test_case {
+	const char *mangled;
+	const char *demangled;
+} rust_test_case_t;
+#define	T(_m, _d) &(rust_test_case_t){ .mangled = _m, .demangled = _d }
+#define	T_ERR(_m) &(rust_test_case_t){ .mangled = _m }
+
+typedef struct rust_test_grp {
+	const char		*name;
+	rust_test_case_t	*tests[];
+} rust_test_grp_t;
+#define	GROUP(_n, ...) 						\
+	static rust_test_grp_t _n = {				\
+		.name = #_n,					\
+		.tests = {					\
+			__VA_ARGS__,				\
+			&(rust_test_case_t){ NULL, NULL }	\
+		}						\
+	}
+
+GROUP(demangle,
+    T_ERR("test"),
+    T("_ZN4testE", "test"),
+    T_ERR("_ZN4test"),
+    T("_ZN4test1a2bcE", "test::a::bc"));
+
+GROUP(demangle_dollars,
+    T("_ZN4$RP$E", ")"),
+    T("_ZN8$RF$testE", "&test"),
+    T("_ZN8$BP$test4foobE", "*test::foob"),
+    T("_ZN9$u20$test4foobE", " test::foob"),
+    T("_ZN35Bar$LT$$u5b$u32$u3b$$u20$4$u5d$$GT$E", "Bar<[u32; 4]>"));
+
+GROUP(demangle_many_dollars,
+    T("_ZN13test$u20$test4foobE", "test test::foob"),
+    T("_ZN12test$BP$test4foobE", "test*test::foob"));
+
+/* BEGIN CSTYLED */
+GROUP(demangle_osx,
+    T("__ZN5alloc9allocator6Layout9for_value17h02a996811f781011E",
+    "alloc::allocator::Layout::for_value::h02a996811f781011"),
+    T("__ZN38_$LT$core..option..Option$LT$T$GT$$GT$6unwrap18_MSG_FILE_LINE_COL17haf7cb8d5824ee659E",
+    "<core::option::Option<T>>::unwrap::_MSG_FILE_LINE_COL::haf7cb8d5824ee659"),
+    T("__ZN4core5slice89_$LT$impl$u20$core..iter..traits..IntoIterator$u20$for$u20$$RF$$u27$a$u20$$u5b$T$u5d$$GT$9into_iter17h450e234d27262170E",
+    "core::slice::<impl core::iter::traits::IntoIterator for &'a [T]>::into_iter::h450e234d27262170"));
+/* END CSTYLED */
+
+GROUP(demangle_elements_beginning_with_underscore,
+    T("_ZN13_$LT$test$GT$E", "<test>"),
+    T("_ZN28_$u7b$$u7b$closure$u7d$$u7d$E", "{{closure}}"),
+    T("_ZN15__STATIC_FMTSTRE", "__STATIC_FMTSTR"));
+
+/* BEGIN CSTYLED */
+GROUP(demangle_trait_impls,
+    T("_ZN71_$LT$Test$u20$$u2b$$u20$$u27$static$u20$as$u20$foo..Bar$LT$Test$GT$$GT$3barE",
+    "<Test + 'static as foo::Bar<Test>>::bar"));
+/* END CSTYLED */
+
+GROUP(invalid_no_chop, T_ERR("_ZNfooE"));
+
+/* BEGIN CSTYLED */
+GROUP(handle_assoc_types,
+    T("_ZN151_$LT$alloc..boxed..Box$LT$alloc..boxed..FnBox$LT$A$C$$u20$Output$u3d$R$GT$$u20$$u2b$$u20$$u27$a$GT$$u20$as$u20$core..ops..function..FnOnce$LT$A$GT$$GT$9call_once17h69e8f44b3723e1caE",
+    "<alloc::boxed::Box<alloc::boxed::FnBox<A, Output=R> + 'a> as core::ops::function::FnOnce<A>>::call_once::h69e8f44b3723e1ca"));
+/* END CSTYLED */
+
+static rust_test_grp_t *rust_tests[] = {
+	&demangle,
+	&demangle_dollars,
+	&demangle_many_dollars,
+	&demangle_osx,
+	&demangle_elements_beginning_with_underscore,
+	&demangle_trait_impls,
+	&invalid_no_chop,
+	&handle_assoc_types
+};
+
+static const size_t n_rust_tests = sizeof (rust_tests) / sizeof (rust_tests[0]);
+
+static boolean_t
+check_failure(size_t i, rust_test_case_t *tc, char *dem, boolean_t res)
+{
+	if (dem == NULL && errno == EINVAL)
+		return (B_TRUE);
+
+	if (res)
+		(void) printf("FAILURE\n");
+
+	if (dem != NULL) {
+		(void) printf("  [%zu] Successfully demanged an invalid "
+		    "name\n", i);
+		(void) printf("         Name: '%s'\n", tc->mangled);
+		(void) printf("    Demangled: '%s'\n", dem);
+		return (B_FALSE);
+	}
+
+	(void) printf("  [%zu] demangle() returned an unexpected error\n", i);
+	(void) printf("    Errno: %d\n", errno);
+	return (B_FALSE);
+}
+
+static boolean_t
+check_success(size_t i, rust_test_case_t *tc, char *dem, boolean_t res)
+{
+	if (dem != NULL && strcmp(tc->demangled, dem) == 0)
+		return (B_TRUE);
+
+	if (res)
+		(void) printf("FAILURE\n");
+
+	if (dem == NULL) {
+		(void) printf("  [%zu] Failed to demangle '%s'\n", i,
+		    tc->mangled);
+		return (B_FALSE);
+	}
+
+	(void) printf("  [%zu] Demangled results do not match.\n", i);
+	(void) printf("       Mangled: %s\n", tc->mangled);
+	(void) printf("      Expected: %s\n", tc->demangled);
+	(void) printf("        Actual: %s\n", dem);
+	return (B_FALSE);
+}
+
+static boolean_t
+run_test(rust_test_grp_t *test)
+{
+	boolean_t res = B_TRUE;
+
+	(void) printf("Test %s: ", test->name);
+
+	for (size_t i = 0; test->tests[i]->mangled != NULL; i++) {
+		char *dem;
+
+		dem = sysdemangle(test->tests[i]->mangled, SYSDEM_LANG_RUST,
+		    NULL);
+		if (test->tests[i]->demangled == NULL)
+			res &= check_failure(i, test->tests[i], dem, res);
+		else
+			res &= check_success(i, test->tests[i], dem, res);
+	}
+
+	if (res)
+		(void) printf("SUCCESS\n");
+
+	return (res);
+}
+
+int
+main(int argc, char **argv)
+{
+	boolean_t ok = B_TRUE;
+
+	for (size_t i = 0; i < n_rust_tests; i++)
+		ok &= run_test(rust_tests[i]);
+
+	return (ok ? 0 : 1);
+}
-- 
2.21.0

