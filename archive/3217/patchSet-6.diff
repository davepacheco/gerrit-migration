From 944be2275ef4802d4d66a6c898a98ef8fc84c32b Mon Sep 17 00:00:00 2001
From: Orlando Vazquez <ovazquez@gmail.com>
Date: Fri, 23 Feb 2018 14:11:34 -0800
Subject: [PATCH] AGENT-1089 Hermes should have option to delete files matching
 a pattern and not upload them to Manta

---
 actor/lib/listglob.js |  52 +++++++++++++++++++++
 actor/lib/worker.js   | 105 +++++++++++++++++++++++++++++++++---------
 lib/logsets.js        |   6 ++-
 3 files changed, 140 insertions(+), 23 deletions(-)
 create mode 100644 actor/lib/listglob.js

diff --git a/actor/lib/listglob.js b/actor/lib/listglob.js
new file mode 100644
index 0000000..428170d
--- /dev/null
+++ b/actor/lib/listglob.js
@@ -0,0 +1,52 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2018, Joyent, Inc.
+ */
+
+var mod_child = require('child_process');
+var mod_verror = require('verror');
+var mod_assert = require('assert-plus');
+
+var LS = '/usr/bin/ls';
+
+function listGlob(pattern, callback) {
+	mod_assert.string(pattern, 'pattern');
+	mod_assert.func(callback, 'callback');
+
+	var args = [
+		'-d'
+	];
+
+	args.push(pattern);
+
+	var opts = {
+		env: {},
+		cwd: '/'
+	};
+
+	var cmd = [LS, '-d', pattern].join(' ');
+
+	mod_child.exec(cmd, opts, onExec);
+
+	function onExec(err, stdout, stderr) {
+		if (err) {
+			callback(
+			    new mod_verror.VError(err,
+			    'could not list files matching pattern'));
+			return;
+		}
+		callback(null, stdout.toString().trim().split('\n'));
+	}
+}
+
+
+module.exports = {
+	listGlob: listGlob
+};
+
+/* vim: set ts=8 sts=8 sw=8 noet: */
diff --git a/actor/lib/worker.js b/actor/lib/worker.js
index ac3cf82..43690c5 100644
--- a/actor/lib/worker.js
+++ b/actor/lib/worker.js
@@ -19,6 +19,7 @@ var mod_verror = require('verror');
 
 var lib_logsets = require('./logsets');
 var lib_findstream = require('./findstream');
+var lib_listglob = require('./listglob');
 var lib_remember = require('./remember');
 
 var VError = mod_verror.VError;
@@ -110,19 +111,63 @@ run(callback)
 	mod_assert.func(callback, 'callback');
 	self.lsw_end_callback = callback;
 
-	/*
-	 * Add zoneroot prefix to search directories if we're looking
-	 * at the non-global zone.
-	 */
-	var adjdirs = [];
-	for (var i = 0; i < self.lsw_logset.search_dirs.length; i++) {
-		adjdirs.push(mod_path.join(self.lsw_path_prefix,
-		    self.lsw_logset.search_dirs[i]));
-	}
+	self.lsw_run_pipeline = mod_vasync.pipeline({
+		arg: self.lsw_manta_task,
+		funcs: [
+			function (_, next) {
+				/*
+				 * If we're not using a search_pattern, skip this part.
+				 */
+				if (!self.lsw_logset.hasOwnProperty('search_pattern')) {
+					next();
+					return;
+				}
+				lib_listglob.listGlob(self.lsw_logset.search_pattern,
+				function (err, matches) {
+					if (err) {
+						next();
+						return;
+					}
+
+					for (var match in matches) {
+						if (self.lsw_logset.search_dirs
+						        .indexOf(match) === -1)
+						{
+							self.lsw_logset.search_dirs =
+							    self.lsw_logset.search_dirs.push(match);
+							}
+						}
+
+					next();
+				});
+			}
+		]
+	}, function (err) {
+		if (err) {
+			callback(err);
+			return;
+		}
+
+		/*
+		 * Add zoneroot prefix to search directories if we're
+		 * looking at the non-global zone.
+		 */
+		var adjdirs = [];
+		for (var i = 0; i < self.lsw_logset.search_dirs.length; i++) {
+			adjdirs.push(mod_path.join(self.lsw_path_prefix,
+			    self.lsw_logset.search_dirs[i]));
+		}
+		self.lsw_barrier.start('find');
+		self._find(adjdirs);
+	});
+};
 
-	self.lsw_barrier.start('find');
-	var find = new lib_findstream.FindStream(adjdirs);
 
+LogsetWorker.prototype._find = function
+_find(adjdirs)
+{
+    var self = this;
+	var find = new lib_findstream.FindStream(adjdirs);
 	find.on('error', function (err) {
 		/*
 		 * XXX It's possible that there's a class of error we can
@@ -250,6 +295,17 @@ _disp()
 	var delete_after = archive_after + (self.lsw_logset.retain_time * 1000);
 	var _delete = (now >= delete_after);
 
+	/*
+	 * We want to upload files by default, unless the logset specifies
+	 * no_upload as being true.
+	 */
+	var _upload = true;
+	if (self.lsw_logset.no_upload === true) {
+		self.lsw_log.info({ file: inf },
+		    'skipping upload for file because \'no_upload\' specified');
+		_upload = false;
+	}
+
 	/*
 	 * Derive the path that we would upload this file to, in Manta:
 	 */
@@ -273,10 +329,11 @@ _disp()
 	self.lsw_log.debug({
 		file: inf,
 		manta_path: manta_path,
-		do_delete: _delete
+		do_delete: _delete,
+		do_upload: _upload
 	}, 'archiving log file');
 
-	self._manta_upload(inf, manta_path, _delete, function (err) {
+	self._manta_upload(inf, manta_path, _delete, _upload, function (err) {
 		if (err) {
 			self.lsw_log.error({
 				err: err
@@ -305,7 +362,7 @@ _disp()
 function
 pl_local_md5(t, next)
 {
-	if (t.t_cancel) {
+	if (t.t_cancel || !t.t_do_upload) {
 		next();
 		return;
 	}
@@ -333,7 +390,7 @@ pl_local_md5(t, next)
 function
 pl_manta_info(t, next)
 {
-	if (t.t_cancel) {
+	if (t.t_cancel || !t.t_do_upload) {
 		next();
 		return;
 	}
@@ -356,7 +413,7 @@ pl_manta_info(t, next)
 function
 pl_manta_mkdirp(t, next)
 {
-	if (t.t_cancel) {
+	if (t.t_cancel || !t.t_do_upload) {
 		next();
 		return;
 	}
@@ -380,7 +437,7 @@ pl_manta_mkdirp(t, next)
 function
 pl_manta_put(t, next)
 {
-	if (t.t_cancel) {
+	if (t.t_cancel || !t.t_do_upload) {
 		next();
 		return;
 	}
@@ -389,6 +446,7 @@ pl_manta_put(t, next)
 
 	mod_assert.string(t.t_md5_local, 'md5_local');
 	mod_assert.number(t.t_file.size, 'file.size');
+	mod_assert.strictEqual(t.t_do_upload, true);
 
 	var opts = {
 		md5: t.t_md5_local,
@@ -449,7 +507,7 @@ pl_manta_put(t, next)
 function
 pl_compare_hash(t, next)
 {
-	if (t.t_cancel) {
+	if (t.t_cancel || !t.t_do_upload) {
 		next();
 		return;
 	}
@@ -478,9 +536,11 @@ pl_local_rm(t, next)
 		return;
 	}
 
-	mod_assert.string(t.t_md5_remote);
-	mod_assert.string(t.t_md5_local);
-	mod_assert.strictEqual(t.t_md5_remote, t.t_md5_local);
+    if (t.t_do_upload) {
+        mod_assert.string(t.t_md5_remote);
+        mod_assert.strictEqual(t.t_md5_remote, t.t_md5_local);
+        mod_assert.string(t.t_md5_local);
+    }
 	mod_assert.strictEqual(t.t_do_delete, true);
 
 	mod_fs.unlink(t.t_file.real_path, function (err) {
@@ -504,7 +564,7 @@ pl_local_rm(t, next)
 }
 
 LogsetWorker.prototype._manta_upload = function
-_manta_upload(file, manta_path, _delete, next)
+_manta_upload(file, manta_path, _delete, _upload, next)
 {
 	var self = this;
 
@@ -519,6 +579,7 @@ _manta_upload(file, manta_path, _delete, next)
 		t_manta_path: manta_path,
 		t_file: file,
 		t_do_delete: _delete,
+		t_do_upload: _upload,
 		t_md5_remote: null,
 		t_md5_local: null,
 		t_cancel: self.lsw_cancel
diff --git a/lib/logsets.js b/lib/logsets.js
index adf20ad..2752b4e 100644
--- a/lib/logsets.js
+++ b/lib/logsets.js
@@ -28,7 +28,9 @@ load_logsets()
 
 		ls.regex = new RegExp(ls.regex);
 
+		mod_assert.optionalString(ls.search_pattern, 'search_pattern');
 		mod_assert.arrayOfString(ls.search_dirs, 'search_dirs');
+		mod_assert.optionalBool(ls.no_upload, 'no_upload');
 		mod_assert.string(ls.manta_path, 'manta_path');
 
 		mod_assert.optionalNumber(ls.debounce_time, 'debounce_time');
@@ -47,11 +49,13 @@ load_logsets()
 
 var COPY_FIELDS = [
 	'search_dirs',
+	'search_pattern',
 	'manta_path',
 	'date_string',
 	'date_adjustment',
 	'debounce_time',
-	'retain_time'
+	'retain_time',
+	'no_upload'
 ];
 
 /*
-- 
2.21.0

