commit 6d195da2afc3ae3019afafa5deb4c24f80787c85
Author: Orlando Vazquez <ovazquez@gmail.com>
Date:   2018-03-19T09:40:57-07:00 (1 year, 7 months ago)
    
    AGENT-1089 Hermes should have option to delete files matching a pattern and not upload them to Manta

diff --git a/actor/lib/listglob.js b/actor/lib/listglob.js
new file mode 100644
index 0000000..4cb2827
--- /dev/null
+++ b/actor/lib/listglob.js
@@ -0,0 +1,60 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2018, Joyent, Inc.
+ */
+
+/*
+ * Returns all files matching a found matching a glob string.
+ */
+
+var mod_child = require('child_process');
+var mod_verror = require('verror');
+var mod_assert = require('assert-plus');
+
+var LS = '/usr/bin/ls';
+
+function list_glob(pattern, callback) {
+	mod_assert.string(pattern, 'pattern');
+	mod_assert.func(callback, 'callback');
+
+	/*
+	 * We want to allow filename expansion to happen, however, we do not want
+	 * to break if given paths with spaces. Here we lean on the shell IFS
+	 * variable to prevent the shell from splitting the path on spaces.
+	 */
+	var args = [
+		'-c',
+		'IFS=""; ls -1Ud $0',
+		pattern
+	];
+
+	var opts = {
+		env: {},
+		cwd: '/',
+		maxBuffer: 1024 * 1024
+	};
+
+	mod_child.execFile('/bin/bash', args, opts, onExec);
+
+	function onExec(err, stdout, stderr) {
+		if (err) {
+			callback(
+			    new mod_verror.VError(err,
+			    'could not list files matching pattern'));
+			return;
+		}
+		callback(null, stdout.toString().trim().split('\n'));
+	}
+}
+
+
+module.exports = {
+	list_glob: list_glob
+};
+
+/* vim: set ts=8 sts=8 sw=8 noet: */
diff --git a/actor/lib/worker.js b/actor/lib/worker.js
index ac3cf82..0706a4b 100644
--- a/actor/lib/worker.js
+++ b/actor/lib/worker.js
@@ -5,20 +5,21 @@
  */
 
 /*
- * Copyright (c) 2014, Joyent, Inc.
+ * Copyright (c) 2018, Joyent, Inc.
  */
 
+var mod_assert = require('assert-plus');
+var mod_crypto = require('crypto');
 var mod_fs = require('fs');
+var mod_jsprim = require('jsprim');
+var mod_once = require('once');
 var mod_path = require('path');
-var mod_crypto = require('crypto');
-
-var mod_assert = require('assert-plus');
 var mod_vasync = require('vasync');
-var mod_once = require('once');
 var mod_verror = require('verror');
 
 var lib_logsets = require('./logsets');
 var lib_findstream = require('./findstream');
+var lib_listglob = require('./listglob');
 var lib_remember = require('./remember');
 
 var VError = mod_verror.VError;
@@ -100,6 +101,7 @@ LogsetWorker.prototype.run = function
 run(callback)
 {
 	var self = this;
+	var search_dirs = mod_jsprim.deepCopy(self.lsw_logset.search_dirs);
 
 	mod_assert.ok(!self.lsw_started, 'cannot run() a worker twice');
 	self.lsw_started = true;
@@ -111,18 +113,53 @@ run(callback)
 	self.lsw_end_callback = callback;
 
 	/*
-	 * Add zoneroot prefix to search directories if we're looking
-	 * at the non-global zone.
+	 * If we're not using a search_dirs_pattern, skip this part.
 	 */
-	var adjdirs = [];
-	for (var i = 0; i < self.lsw_logset.search_dirs.length; i++) {
-		adjdirs.push(mod_path.join(self.lsw_path_prefix,
-		    self.lsw_logset.search_dirs[i]));
+	if (!self.lsw_logset.hasOwnProperty('search_dirs_pattern')) {
+		do_find();
+		return;
 	}
 
-	self.lsw_barrier.start('find');
-	var find = new lib_findstream.FindStream(adjdirs);
+	lib_listglob.list_glob(self.lsw_logset.search_dirs_pattern,
+	function on_list(err, matches) {
+		if (err) {
+			self.lsw_log.error({
+				err: err
+			}, 'find stream error');
+			callback(err);
+			return;
+		}
+
+		for (var idx in matches) {
+			if (search_dirs.indexOf(matches[idx]) === -1)
+			{
+				search_dirs.push(matches[idx]);
+			}
+		}
 
+		do_find();
+	});
+
+	function do_find() {
+		/*
+		 * Add zoneroot prefix to search directories if we're
+		 * looking at the non-global zone.
+		 */
+		var adjdirs = [];
+		for (var i = 0; i < search_dirs.length; i++) {
+			adjdirs.push(mod_path.join(self.lsw_path_prefix,
+			    search_dirs[i]));
+		}
+		self.lsw_barrier.start('find');
+		self._find(adjdirs);
+	}
+};
+
+
+LogsetWorker.prototype._find = function _find(adjdirs) {
+	mod_assert.arrayOfString(adjdirs, 'adjdirs');
+	var self = this;
+	var find = new lib_findstream.FindStream(adjdirs);
 	find.on('error', function (err) {
 		/*
 		 * XXX It's possible that there's a class of error we can
@@ -250,6 +287,17 @@ _disp()
 	var delete_after = archive_after + (self.lsw_logset.retain_time * 1000);
 	var _delete = (now >= delete_after);
 
+	/*
+	 * We want to upload files by default, unless the logset specifies
+	 * no_upload as being true.
+	 */
+	var _upload = true;
+	if (self.lsw_logset.no_upload === true) {
+		self.lsw_log.debug({ file: inf },
+		    'skipping upload for file because \'no_upload\' specified');
+		_upload = false;
+	}
+
 	/*
 	 * Derive the path that we would upload this file to, in Manta:
 	 */
@@ -273,10 +321,11 @@ _disp()
 	self.lsw_log.debug({
 		file: inf,
 		manta_path: manta_path,
-		do_delete: _delete
+		do_delete: _delete,
+		do_upload: _upload
 	}, 'archiving log file');
 
-	self._manta_upload(inf, manta_path, _delete, function (err) {
+	self._manta_upload(inf, manta_path, _delete, _upload, function (err) {
 		if (err) {
 			self.lsw_log.error({
 				err: err
@@ -305,7 +354,7 @@ _disp()
 function
 pl_local_md5(t, next)
 {
-	if (t.t_cancel) {
+	if (t.t_cancel || !t.t_do_upload) {
 		next();
 		return;
 	}
@@ -333,7 +382,7 @@ pl_local_md5(t, next)
 function
 pl_manta_info(t, next)
 {
-	if (t.t_cancel) {
+	if (t.t_cancel || !t.t_do_upload) {
 		next();
 		return;
 	}
@@ -356,7 +405,7 @@ pl_manta_info(t, next)
 function
 pl_manta_mkdirp(t, next)
 {
-	if (t.t_cancel) {
+	if (t.t_cancel || !t.t_do_upload) {
 		next();
 		return;
 	}
@@ -380,7 +429,7 @@ pl_manta_mkdirp(t, next)
 function
 pl_manta_put(t, next)
 {
-	if (t.t_cancel) {
+	if (t.t_cancel || !t.t_do_upload) {
 		next();
 		return;
 	}
@@ -389,6 +438,7 @@ pl_manta_put(t, next)
 
 	mod_assert.string(t.t_md5_local, 'md5_local');
 	mod_assert.number(t.t_file.size, 'file.size');
+	mod_assert.strictEqual(t.t_do_upload, true);
 
 	var opts = {
 		md5: t.t_md5_local,
@@ -449,7 +499,7 @@ pl_manta_put(t, next)
 function
 pl_compare_hash(t, next)
 {
-	if (t.t_cancel) {
+	if (t.t_cancel || !t.t_do_upload) {
 		next();
 		return;
 	}
@@ -478,9 +528,11 @@ pl_local_rm(t, next)
 		return;
 	}
 
-	mod_assert.string(t.t_md5_remote);
-	mod_assert.string(t.t_md5_local);
-	mod_assert.strictEqual(t.t_md5_remote, t.t_md5_local);
+	if (t.t_do_upload) {
+		mod_assert.string(t.t_md5_remote);
+		mod_assert.strictEqual(t.t_md5_remote, t.t_md5_local);
+		mod_assert.string(t.t_md5_local);
+	}
 	mod_assert.strictEqual(t.t_do_delete, true);
 
 	mod_fs.unlink(t.t_file.real_path, function (err) {
@@ -504,8 +556,13 @@ pl_local_rm(t, next)
 }
 
 LogsetWorker.prototype._manta_upload = function
-_manta_upload(file, manta_path, _delete, next)
+_manta_upload(file, manta_path, _delete, _upload, next)
 {
+	mod_assert.object(file, 'file');
+	mod_assert.string(manta_path, 'manta_path');
+	mod_assert.bool(_delete, '_delete');
+	mod_assert.bool(_upload, '_upload');
+
 	var self = this;
 
 	mod_assert.ok(!self.lsw_manta_task, '!lsw_manta_task');
@@ -519,6 +576,7 @@ _manta_upload(file, manta_path, _delete, next)
 		t_manta_path: manta_path,
 		t_file: file,
 		t_do_delete: _delete,
+		t_do_upload: _upload,
 		t_md5_remote: null,
 		t_md5_local: null,
 		t_cancel: self.lsw_cancel
diff --git a/lib/logsets.js b/lib/logsets.js
index adf20ad..fc93d11 100644
--- a/lib/logsets.js
+++ b/lib/logsets.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2014, Joyent, Inc.
+ * Copyright (c) 2018, Joyent, Inc.
  */
 
 var mod_fs = require('fs');
@@ -27,8 +27,11 @@ load_logsets()
 		var ls = LOGSETS[i];
 
 		ls.regex = new RegExp(ls.regex);
-
+		mod_assert.optionalString(
+		    ls.search_dirs_pattern,
+		    'search_dirs_pattern');
 		mod_assert.arrayOfString(ls.search_dirs, 'search_dirs');
+		mod_assert.optionalBool(ls.no_upload, 'no_upload');
 		mod_assert.string(ls.manta_path, 'manta_path');
 
 		mod_assert.optionalNumber(ls.debounce_time, 'debounce_time');
@@ -40,18 +43,20 @@ load_logsets()
 			ls.retain_time = DEFAULT_RETAIN_TIME;
 
 		mod_assert.ok(NAMES_SEEN.indexOf(ls.name) === -1,
-		    'duplicate logset name');
+				'duplicate logset name');
 		NAMES_SEEN.push(ls.name);
 	}
 }
 
 var COPY_FIELDS = [
 	'search_dirs',
+	'search_dirs_pattern',
 	'manta_path',
 	'date_string',
 	'date_adjustment',
 	'debounce_time',
-	'retain_time'
+	'retain_time',
+	'no_upload'
 ];
 
 /*
diff --git a/package.json b/package.json
index 3e6f1fd..3c76c21 100644
--- a/package.json
+++ b/package.json
@@ -1,6 +1,6 @@
 {
   "name": "hermes",
-  "version": "0.2.0",
+  "version": "0.3.0",
   "description": "Centralised tool to upload SDC logs to Manta",
   "main": "hermes.js",
   "author": "Joshua M. Clulow <jmc@joyent.com>",
