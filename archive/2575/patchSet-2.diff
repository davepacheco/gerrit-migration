commit 53df88f1c9c747db27c3a88bf99e479f12e9a7c4 (refs/changes/75/2575/2)
Author: Alex Wilson <alex.wilson@joyent.com>
Date:   2017-09-15T11:28:50-07:00 (2 years, 1 month ago)
    
    joyent/node-mname-client#6 make it easy to set flags with lookup()
    joyent/node-mname-client#7 want basic API docs

diff --git a/README.md b/README.md
index 5c92514..d890727 100644
--- a/README.md
+++ b/README.md
@@ -63,7 +63,7 @@ req.on('reply', function (msg, done) {
     class: 'IN',
     ttl: 299,
     target: '216.58.192.14' } ];
-  
+
   /*
    * Need to call done() to indicate that this query is complete.
    * This is important so that AXFR and similar queries that can result
@@ -83,7 +83,7 @@ sock.on('ready', function () {
    * way too big)
    */
   sock.send(req);
-  
+
   /* Call end once you've added all pipelined queries you want. */
   sock.end();
 });
@@ -102,7 +102,7 @@ sock.on('ready', function () {
    * can re-use the one bound socket for multiple destinations.
    */
   sock.send(req, { address: '8.8.8.8', port: 53 });
-  
+
   /* Will cause the socket to close after the last outstanding query returns. */
   sock.end();
 });
@@ -110,3 +110,190 @@ sock.on('error', function (err) {
   /* A socket-level error resulting in this socket being unusable. */
 });
 ```
+
+## API
+
+### `new mod_mname_client.DnsClient([options])`
+
+Parameters:
+ - `options` -- an optional Object, with keys:
+   * `resolvers` -- an optional Array of String, IP addresses of nameservers
+     to use
+   * `concurrency` -- an optional Number, max number of requests to send at
+     once, default 3
+
+### `DnsClient#close()`
+
+Ends all sockets and waits for outstanding DNS requests to finish or time out
+before closing.
+
+### `DnsClient#lookup(options, cb)`
+
+Look up a name and return the first successful result as a DnsMessage.
+
+Parameters:
+ - `options` -- Object, with keys:
+   * `domain` -- String, domain to look up
+   * `type` -- String, the query type (qtype), e.g. `"AAAA"`
+   * `timeout` -- Number, milliseconds
+   * `resolvers` -- optional Array of String, resolvers to use just for this
+     request
+   * `filter` -- optional Func `(msg)`, if provided will run on each DnsMessage
+     before sending (useful to set flags or sign requests)
+ - `cb` -- Func `(err, message)` with parameters:
+   * `err` -- either `null` or an `Error` instance
+   * `message` -- a DnsMessage (if `err` is `null`)
+
+### `new mod_mname_client.DnsMessage()`
+
+Construct a new, empty DNS message. The message is also an EventEmitter.
+
+### `DnsMessage->error(err)`
+
+Event emitted when the DNS message experiences an error because of a network
+or system failure. This is not emitted if the message receives a reply that is
+an error-type reply (e.g. `isError()` on the reply would return `true`).
+
+Parameters:
+ - `err` -- an Error object
+
+### `DnsMessage->reply(msg)`
+
+Event emitted when a reply to the DNS message is received.
+
+Parameters:
+ - `msg` -- a DnsMessage instance
+
+### `DnsMessage#isError()`
+
+Returns `true` if this message indicates an error (either by the rcode being
+something other than `NOERROR`, or the truncation flag being set).
+
+### `DnsMessage#toError([resolver])`
+
+Converts the DnsMessage into an `Error` object with a descriptive message about
+the error that occurred. The optional `resolver` parameter is included in the
+Error messages.
+
+If the DnsMessage does not represent any kind of error condition, this function
+returns `null`. The returned errors will be named either `TruncationError` or
+`DnsError`.
+
+Parameters:
+ - `resolver` -- optional String, resolver IP or name to include in error
+   message
+
+### `DnsMessage#getAnswers()`
+
+Returns the answer part of the DNS message as an Array of Record Objects, of
+the form:
+
+```json
+{
+  "name": "domain.foo.com",
+  "type": "AAAA",
+  "class": "IN",
+  "ttl": 30,
+  "address": "abcd::1"
+}
+```
+
+The `name`, `type`, `class` and `ttl` properties are available on all types of
+record. Other fields such as `address` appear only on the relevant `type`.
+
+### `DnsMessage#getAuthority()`
+
+Returns the authority section of the DNS message as an Array of Record Objects
+(see `getAnswers()`).
+
+### `DnsMessage#getAdditionals()`
+
+Returns the additional section of the DNS message as an Array of Record Objects
+(see `getAnswers()`).
+
+### `DnsMessage#testFlag(flag)`
+
+Returns `true` if a given flag is set in the message header. Valid flag names:
+
+ - `qr`, `response`
+ - `aa`, `authoritative`
+ - `rd`, `recursionDesired`
+ - `ra`, `recursionAvailable`
+ - `ad`, `authenticated`
+ - `cd`, `noChecking`
+ - `cd`, `checkingDisabled`
+
+Parameters:
+ - `flag` -- a String
+
+### `DnsMessage#setFlag(flag)`
+### `DnsMessage#clearFlag(flag)`
+
+Sets or clears a given flag (see `testFlag()` for a list of values).
+
+Parameters:
+ - `flag` -- a String
+
+### `DnsMessage#addQuestion(name, type, qclass)`
+
+Adds a question section to the DNS message.
+
+Parameters:
+ - `name` -- a String, the domain name to be questioned
+ - `type` -- a String, the record type desired (e.g. `'AAAA'`)
+ - `qclass` -- a String, the query class (e.g. `'IN'`)
+
+### `DnsMessage#addEDNS(options)`
+
+Adds EDNS to the message.
+
+Parameters
+ - `options` -- an Object, with keys:
+   * `maxUDPLength` -- a Number, the maximum length of UDP frames
+
+### `new mod_mname_client.DnsTcpSocket(options)`
+
+Creates a new TCP-based DNS client socket.
+
+Parameters:
+ - `options` -- an Object, with keys:
+   * `address` -- a String, IP address of remote machine
+   * `port` -- a Number, the port to connect to
+
+### `new mod_mname_client.DnsUdpSocket(options)`
+
+Creates a new UDP-based DNS client socket.
+
+Parameters:
+ - `options` -- an Object, with keys:
+   * `family` -- a String, either `'udp4'` or `'udp6'`
+
+### `DnsSocket->ready()`
+
+Event emitted by `DnsTcpSocket` or `DnsUdpSocket` when the socket is open and
+ready for use.
+
+### `DnsSocket->error(err)`
+
+Event emitted by `DnsTcpSocket` or `DnsUdpSocket` when a socket-level error is
+experienced.
+
+Parameters:
+ - `err` -- an Error object
+
+### `DnsSocket#end()`
+
+Wait for any outstanding requests to complete, and then close the socket.
+
+### `DnsSocket#isReady()`
+
+Returns `true` if the socket has emitted the `->ready` event.
+
+### `DnsSocket#send(msg[, destination])`
+
+Sends a DnsMessage over the socket.
+
+Parameters:
+ - `msg` -- a DnsMessage object
+ - `destination` -- a String, optional for TCP sockets, required for UDP (must
+   be remote address to send message to)
diff --git a/lib/client.js b/lib/client.js
index b4eb9ab..f4e6ae9 100644
--- a/lib/client.js
+++ b/lib/client.js
@@ -78,6 +78,7 @@ DnsClient.prototype.lookup = function (options, cb) {
 	mod_assert.string(options.domain, 'options.domain');
 	mod_assert.string(options.type, 'options.type');
 	mod_assert.number(options.timeout, 'options.timeout');
+	mod_assert.optionalFunc(options.filter, 'options.filter');
 
 	var resolvers = options.resolvers || this.dc_resolvers;
 	if (resolvers === undefined) {
@@ -121,7 +122,8 @@ DnsClient.prototype.lookup = function (options, cb) {
 			resolver: res,
 			domain: options.domain,
 			type: options.type,
-			timeout: options.timeout
+			timeout: options.timeout,
+			filter: options.filter
 		};
 		reqs.push(self.lookupOnce(opts, function (err, msg) {
 			if (err) {
@@ -161,6 +163,7 @@ DnsClient.prototype.lookupOnce = function (options, cb) {
 	mod_assert.string(options.type, 'options.type');
 	mod_assert.number(options.timeout, 'options.timeout');
 	mod_assert.optionalString(options.protocol, 'options.protocol');
+	mod_assert.optionalFunc(options.filter, 'options.filter');
 
 	var protocol = 'udp';
 	var key = options.domain + '|' + options.type;
@@ -170,6 +173,8 @@ DnsClient.prototype.lookupOnce = function (options, cb) {
 	var req = new mod_message.DnsMessage();
 	req.addQuestion(options.domain, options.type);
 	req.addEDNS({ maxUDPLength: 1420 });
+	if (options.filter)
+		options.filter(req);
 
 	var timer = setTimeout(function () {
 		if (timer !== undefined) {
diff --git a/lib/message.js b/lib/message.js
index 41bb120..7e91455 100644
--- a/lib/message.js
+++ b/lib/message.js
@@ -214,3 +214,33 @@ DnsMessage.prototype.cancel = function () {
 	this.dm_cancelled = true;
 	this.emit('cancel');
 };
+
+var FLAGS = {
+	qr: true, aa: true, rd: true, ra: true, ad: true, cd: true,
+	response: 'qr', authoritative: 'aa', recursionDesired: 'rd',
+	recursionAvailable: 'ra', authenticated: 'ad', noChecking: 'cd',
+	checkingDisabled: 'cd'
+};
+
+function validateAndAliasFlag(flag) {
+	if (typeof (FLAGS[flag]) === 'string')
+		flag = FLAGS[flag];
+	if (FLAGS[flag] !== true)
+		throw (new Error('Invalid DNS header flag "' + flag + '"'));
+	return (flag);
+}
+
+DnsMessage.prototype.testFlag = function testFlag(flag) {
+	flag = validateAndAliasFlag(flag);
+	return (this.header.flags[flag] === true);
+};
+
+DnsMessage.prototype.setFlag = function setFlag(flag) {
+	flag = validateAndAliasFlag(flag);
+	this.header.flags[flag] = true;
+};
+
+DnsMessage.prototype.clearFlag = function clearFlag(flag) {
+	flag = validateAndAliasFlag(flag);
+	this.header.flags[flag] = false;
+};
diff --git a/package.json b/package.json
index 2c8c867..ac35a2f 100644
--- a/package.json
+++ b/package.json
@@ -1,7 +1,7 @@
 {
   "name": "mname-client",
   "description": "DNS client library for node.js",
-  "version": "0.5.1",
+  "version": "0.6.0",
   "author": "Joyent, Inc",
   "scripts": {
     "test": "tape test/*.test.js"
diff --git a/test/google.test.js b/test/google.test.js
index 3897304..320f117 100644
--- a/test/google.test.js
+++ b/test/google.test.js
@@ -92,6 +92,41 @@ mod_tape.test('use the parallel lookup api', function (t) {
 	});
 });
 
+mod_tape.test('filter option', function (t) {
+	var client = new mod_nsc.DnsClient({
+		resolvers: ['8.8.8.8']
+	});
+	client.lookup({
+		domain: 'google.com',
+		type: 'A',
+		timeout: 2000,
+		filter: function (msg) {
+			msg.clearFlag('recursionDesired');
+		}
+	}, function (err, msg) {
+		/*
+		 * This test is kinda crappy, since 8.8.8.8 can return either
+		 * a reasonable response or SERVFAIL to queries without the RD
+		 * bit set. No idea why. It's not RFC-compliant.
+		 */
+		if (err) {
+			var errs = err.errors();
+			err = errs[0];
+			t.strictEqual(err.code, 'SERVFAIL');
+		} else {
+			t.ok(!msg.isError());
+			t.ok(msg.getAnswers().length > 0);
+
+			t.ok(!msg.testFlag('rd'));
+			t.ok(msg.testFlag('ra'));
+		}
+
+		client.close();
+
+		t.end();
+	});
+});
+
 mod_tape.test('parallel lookup with failing resolvers', function (t) {
 	var client = new mod_nsc.DnsClient({
 		resolvers: ['192.0.2.1', '192.0.2.3', '8.8.8.8', '8.8.4.4']
