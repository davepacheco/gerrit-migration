commit d9e81530df21c5dd164c4524de9f147d62b7922e
Author: dyep <dyep49@gmail.com>
Date:   2019-04-24T03:17:02-07:00 (6 months ago)
    
    TRITON-967 Add support for flexible disk, disks information and disks modifications to triton

diff --git a/CHANGES.md b/CHANGES.md
index 7dcf302..cd32d96 100644
--- a/CHANGES.md
+++ b/CHANGES.md
@@ -9,6 +9,11 @@ Known issues:
 - [joyent/node-triton#263] Correct envvar name to `TRITON_TLS_INSECURE`
   in CLI profile validation error message.
 
+## 7.1.0
+
+- [TRITON-967] Add support for listing, adding, deleting, and resizing
+  flexible disk instance disks
+
 ## 7.0.2
 
 - [TRITON-1347] Changing to node-tap as the test runner. Also some
diff --git a/lib/cloudapi2.js b/lib/cloudapi2.js
index b5fb949..840d479 100644
--- a/lib/cloudapi2.js
+++ b/lib/cloudapi2.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2018, Joyent, Inc.
+ * Copyright (c) 2019, Joyent, Inc.
  *
  * Client library for the SmartDataCenter Cloud API (cloudapi).
  * http://apidocs.joyent.com/cloudapi/
@@ -3093,6 +3093,278 @@ function waitForVolumeStates(opts, callback) {
     }
 };
 
+// --- Disks
+
+/**
+ * List disks for a given machine.
+ *
+ * Returns an array of disk objects.
+ *
+ * @param {Object} options object containing:
+ *      - {String} id (required) the machine's id.
+ * @param {Function} callback of the form f(err, body, res).
+ */
+CloudApi.prototype.listMachineDisks =
+function listMachineDisks(opts, cb) {
+    assert.object(opts, 'opts');
+    assert.uuid(opts.id, 'opts.id');
+    assert.func(cb, 'cb');
+
+    var endpoint = format('/%s/machines/%s/disks', this.account, opts.id);
+    this._passThrough(endpoint, opts, cb);
+};
+
+/**
+ * Get a single disk for a given machine.
+ *
+ * Returns a disk object.
+ *
+ * @param {Object} options object containing:
+ *      - {String} id (required) the machine's id.
+ *      - {String} diskId (required) the disk's ID
+ * @param {Function} callback of the form f(err, body, res).
+ */
+CloudApi.prototype.getMachineDisk =
+function getMachineDisk(opts, cb) {
+    assert.object(opts, 'opts');
+    assert.uuid(opts.id, 'opts.id');
+    assert.string(opts.diskId, 'opts.diskId');
+    assert.func(cb, 'cb');
+
+    var endpoint = format('/%s/machines/%s/disks/%s', this.account, opts.id,
+        encodeURIComponent(opts.diskId));
+    this._passThrough(endpoint, opts, cb);
+};
+
+/**
+ * Create a new disk for a given machine.
+ *
+ * Returns a disk object.
+ *
+ * @param {Object} options object containing:
+ *      - {String} id (required) the machine's id.
+ *      - {String or Number} size (required) in MiB, or the string "remaining"
+ *        to use up all remaining available space
+ * @param {Function} callback of the form f(err, body, res).
+ */
+CloudApi.prototype.createMachineDisk =
+function createMachineDisk(opts, cb) {
+    assert.object(opts, 'opts');
+    assert.uuid(opts.id, 'opts.id');
+    assert.ok(opts.size, 'opts.size');
+    assert.func(cb, 'cb');
+
+    this._request({
+        method: 'POST',
+        path: format('/%s/machines/%s/disks', this.account, opts.id),
+        data: {size: opts.size}
+    }, function (err, req, res, body) {
+        cb(err, body, res);
+    });
+};
+
+/**
+ * Delete a disk for a given machine.
+ *
+ * Returns a disk object.
+ *
+ * @param {Object} options object containing:
+ *      - {String} id (required), the machine's id.
+ *      - {String} diskId (required), the disk id.
+ * @param {Function} callback of the form f(err, body, res).
+ */
+CloudApi.prototype.deleteMachineDisk =
+function deleteMachineDisk(opts, cb) {
+    assert.object(opts, 'opts');
+    assert.uuid(opts.id, 'opts.id');
+    assert.ok(opts.diskId, 'opts.diskId');
+    assert.func(cb, 'cb');
+
+    this._request({
+        method: 'DELETE',
+        path: format('/%s/machines/%s/disks/%s', this.account, opts.id,
+                     opts.diskId)
+    }, function (err, req, res, body) {
+        cb(err, body, res);
+    });
+};
+
+/**
+ * Resize a disk for a given machine.
+ *
+ * Returns a disk object.
+ *
+ * @param {Object} options object containing:
+ *      - {String} id (required), the machine's id.
+ *      - {String} diskId (required), the disk id.
+ *      - {Number} size (required) in MiB
+ *      - {Boolean} dangerousAllowShrink (optional), whether a disk can be
+ *        shrunk.
+ * @param {Function} callback of the form f(err, body, res).
+ */
+CloudApi.prototype.resizeMachineDisk =
+function resizeMachineDisk(opts, cb) {
+    assert.object(opts, 'opts');
+    assert.uuid(opts.id, 'opts.id');
+    assert.ok(opts.diskId, 'opts.diskId');
+    assert.number(opts.size, 'opts.size');
+    assert.optionalBool(opts.dangerousAllowShrink, 'opts.dangerousAllowShrink');
+    assert.func(cb, 'cb');
+
+    this._request({
+        method: 'POST',
+        path: format('/%s/machines/%s/disks/%s', this.account, opts.id,
+                     opts.diskId),
+        data: {
+            size: opts.size,
+            dangerous_allow_shrink: opts.dangerousAllowShrink
+        }
+    }, function (err, req, res, body) {
+        cb(err, body, res);
+    });
+};
+
+/**
+ * Wait for a disk to be created
+ *
+ * @param {Object} options
+ *      - {String} id - machine UUID
+ *      - {String} diskId - diskId
+ *      - {Array of Object} disks - the disks prior to disk creation
+ *      - {String or Number} diskSize - final size of disk in MiB or "remaining"
+ *      - {Number} interval (optional) - time in ms to poll
+ * @param {Function} callback - called when disk is created or on error
+ */
+CloudApi.prototype.waitForDiskCreate =
+function waitForDiskCreate(opts, callback) {
+    var self = this;
+    assert.object(opts, 'opts');
+    assert.uuid(opts.id, 'opts.id');
+    assert.arrayOfObject(opts.disks, 'opts.disks');
+    assert.ok(opts.diskSize, 'opts.diskSize');
+    assert.optionalNumber(opts.interval, 'opts.interval');
+    assert.func(callback, 'callback');
+    var interval = (opts.interval === undefined ? 1000 : opts.interval);
+    assert.ok(interval > 0, 'interval must be a positive number');
+
+    function checkAdd(oldDisks, newDisks, diskSize) {
+        var oldDiskIds = oldDisks.map(function toIds(disk) {
+            return disk.id;
+        });
+
+        if (newDisks.length > oldDisks.length) {
+            return newDisks.filter(function getAdd(disk) {
+                return oldDiskIds.indexOf(disk.id) === -1 &&
+                    disk.state !== 'creating' &&
+                    disk.size === diskSize;
+            });
+        }
+    }
+
+    poll();
+
+    function poll() {
+        self.listMachineDisks({id: opts.id}, function onDisks(err, disks) {
+            if (err) {
+                callback(err);
+                return;
+            }
+
+            var newDisks = checkAdd(opts.disks, disks, opts.diskSize);
+
+            if (newDisks === undefined) {
+                poll();
+            } else if (newDisks.length === 1) {
+                callback(null, newDisks[0]);
+            } else if (newDisks.length > 1) {
+                callback(new Error('Multiple new disks were detected while ' +
+                    'waiting for disk add to complete.'));
+            }
+        });
+    }
+};
+
+/**
+ * Wait for a disk to be deleted
+ *
+ * @param {Object} options
+ *      - {String} id - machine UUID
+ *      - {String} diskId - diskId
+ *      - {Number} interval (optional) - time in ms to poll
+ * @param {Function} callback - called when disk is deleted or on error
+ */
+CloudApi.prototype.waitForDiskDelete =
+function waitForDiskDelete(opts, callback) {
+    var self = this;
+    assert.object(opts, 'opts');
+    assert.uuid(opts.id, 'opts.id');
+    assert.uuid(opts.diskId, 'opts.diskId');
+    assert.optionalNumber(opts.interval, 'opts.interval');
+    assert.func(callback, 'callback');
+    var interval = (opts.interval === undefined ? 1000 : opts.interval);
+    assert.ok(interval > 0, 'interval must be a positive number');
+
+    poll();
+
+    function poll() {
+        self.getMachineDisk({id: opts.id, diskId: opts.diskId},
+        function onDisk(err, disk, res) {
+            if (err && err.name === 'ResourceNotFoundError') {
+                callback();
+                return;
+            }
+
+            if (err) {
+                callback(err);
+                return;
+            }
+
+            setTimeout(poll, interval);
+        });
+    }
+};
+
+/**
+ * Wait for a disk to resize.
+ *
+ * @param {Object} options
+ *      - {String} id - machine UUID
+ *      - {String} diskId - diskId
+ *      - {String or Number} diskSize - final size of disk in MiB or "remaining"
+ *      - {Number} interval (optional) - time in ms to poll
+ * @param {Function} callback - called when disk is resized or on error
+ */
+CloudApi.prototype.waitForDiskResize =
+function waitForDiskResize(opts, callback) {
+    var self = this;
+    assert.object(opts, 'opts');
+    assert.uuid(opts.id, 'opts.id');
+    assert.uuid(opts.diskId, 'opts.diskId');
+    assert.number(opts.diskSize, 'opts.diskSize');
+    assert.optionalNumber(opts.interval, 'opts.interval');
+    assert.func(callback, 'callback');
+    var interval = (opts.interval === undefined ? 1000 : opts.interval);
+    assert.ok(interval > 0, 'interval must be a positive number');
+
+    poll();
+
+    function poll() {
+        self.getMachineDisk({id: opts.id, diskId: opts.diskId},
+        function onDisk(err, disk, res) {
+            if (err) {
+                callback(err, null, res);
+                return;
+            }
+
+            if (disk.size === opts.diskSize && disk.state !== 'resizing') {
+                callback(null, disk);
+            } else {
+                setTimeout(poll, interval);
+            }
+        });
+    }
+};
+
 // --- Exports
 
 module.exports = {
diff --git a/lib/disks.js b/lib/disks.js
new file mode 100644
index 0000000..7a5277b
--- /dev/null
+++ b/lib/disks.js
@@ -0,0 +1,91 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright 2019 Joyent, Inc.
+ *
+ * Utilities for parsing disks from CLI options.
+ */
+
+var assert = require('assert-plus');
+var format = require('util').format;
+var fs = require('fs');
+
+var common = require('./common');
+var errors = require('./errors');
+
+/*
+ * Load and validate disks from these options:
+ *      --disks DATA
+ *      --disks FILE
+ */
+function disksFromOpts(opts, log, cb) {
+    assert.object(log, 'log');
+    assert.func(cb, 'cb');
+
+    var disks;
+    for (var i = 0; i < opts._order.length; i++) {
+        if (opts._order[i].key === 'disks') {
+            disks = opts._order[i].value;
+            break;
+        }
+    }
+
+    if (!disks) {
+        cb();
+        return;
+    }
+
+    log.trace({opt: disks}, 'disksFromOpts');
+
+    if (disks[0] === '[') {
+        _addDisksFromJsonStr(disks, cb);
+    } else if (disks[0] === '@') {
+        _addDisksFromFile(disks.slice(1), cb);
+    } else {
+        cb(new errors.usageError('disks does not start with "[" or "@")'));
+        return;
+    }
+}
+
+function _addDisksFromJsonStr(disksStr, cb) {
+    assert.string(disksStr, 'disksStr');
+    try {
+        var disks = JSON.parse(disksStr);
+    } catch (parseErr) {
+        cb(new errors.TritonError(parseErr,
+            format('%s is not valid JSON', disksStr)));
+        return;
+    }
+
+    cb(null, disks);
+}
+
+function _addDisksFromFile(fileStr, cb) {
+    assert.string(fileStr, 'fileStr');
+
+    var filePath = common.tildeSync(fileStr);
+    fs.stat(filePath, function onStat(statErr, stats) {
+        if (statErr || !stats.isFile()) {
+            cb(new errors.TritonError(format(
+                'disks path "%s" is not an existing file', fileStr)));
+            return;
+        }
+
+        fs.readFile(filePath, 'utf8', function onRead(readErr, data) {
+            if (readErr) {
+                cb(readErr);
+                return;
+            }
+
+            _addDisksFromJsonStr(data, cb);
+        });
+    });
+}
+
+module.exports = {
+    disksFromOpts: disksFromOpts
+};
diff --git a/lib/do_instance/do_create.js b/lib/do_instance/do_create.js
index 4cc056b..6a9041e 100644
--- a/lib/do_instance/do_create.js
+++ b/lib/do_instance/do_create.js
@@ -16,6 +16,7 @@ var tabula = require('tabula');
 var vasync = require('vasync');
 
 var common = require('../common');
+var disks = require('../disks');
 var distractions = require('../distractions');
 var errors = require('../errors');
 var mat = require('../metadataandtags');
@@ -132,6 +133,24 @@ function do_create(subcmd, opts, args, cb) {
             next();
         },
 
+        /*
+         * Parse any disks given via `--disks`
+         */
+        function parseDisks(ctx, next) {
+            disks.disksFromOpts(opts, log, function onDisks(err, disksArr) {
+                if (err) {
+                    next(err);
+                    return;
+                }
+                if (disksArr) {
+                    log.trace({disks: disksArr},
+                        'disks loaded from opts');
+                    ctx.disks = disksArr;
+                }
+                next();
+            });
+        },
+
         /*
          * Parse any nics given via `--nic`
          */
@@ -258,6 +277,7 @@ function do_create(subcmd, opts, args, cb) {
         },
 
         function createInst(ctx, next) {
+            assert.optionalArrayOfObject(ctx.disks, 'ctx.disks');
             assert.optionalArrayOfObject(ctx.volMounts, 'ctx.volMounts');
 
             var createOpts = {
@@ -277,6 +297,9 @@ function do_create(subcmd, opts, args, cb) {
             if (ctx.volMounts) {
                 createOpts.volumes = ctx.volMounts;
             }
+            if (ctx.disks) {
+                createOpts.disks = ctx.disks;
+            }
             if (opts.affinity) {
                 createOpts.affinity = opts.affinity;
             }
@@ -507,6 +530,14 @@ do_create.options = [
         type: 'bool',
         help: 'Allow instance creation to use a shared image.'
     },
+    {
+        names: ['disks'],
+        type: 'arrayOfString',
+        helpArg: 'DATA',
+        help: 'Configure disks in a flexible disk instance. DATA is a JSON ' +
+            'object (if the first character is "{"} or "@FILE" to have disks ' +
+            'loaded from FILE.'
+    },
 
     {
         group: 'Other options'
diff --git a/lib/do_instance/do_disk/do_add.js b/lib/do_instance/do_disk/do_add.js
new file mode 100644
index 0000000..878b385
--- /dev/null
+++ b/lib/do_instance/do_disk/do_add.js
@@ -0,0 +1,150 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright 2019 Joyent, Inc.
+ *
+ * `triton instance disk add ...`
+ */
+var assert = require('assert-plus');
+var jsprim = require('jsprim');
+var vasync = require('vasync');
+
+var common = require('../../common');
+var errors = require('../../errors');
+
+function do_add(subcmd, opts, args, cb) {
+    assert.func(cb, 'cb');
+
+    if (opts.help) {
+        this.do_help('help', {}, [subcmd], cb);
+        return;
+    }
+
+    if (args.length === 0) {
+        cb(new errors.UsageError('missing INST argument'));
+        return;
+    } else if (args.length === 1) {
+        cb(new errors.UsageError('missing SIZE argument'));
+        return;
+    } else if (args.length > 2) {
+        cb(new errors.UsageError('incorrect number of arguments'));
+        return;
+    }
+
+    var cli = this.top;
+    var instanceId = args[0];
+    var size = args[1];
+
+    if (size !== 'remaining') {
+        size = jsprim.parseInteger(size);
+
+        if (typeof (size) !== 'number') {
+            cb(new errors.UsageError('SIZE must be an number or "remaining"'));
+            return;
+        }
+    }
+
+    vasync.pipeline({arg: {cli: this.top}, funcs: [
+        common.cliSetupTritonApi,
+        function getDisks(ctx, next) {
+            if (!opts.wait) {
+                next();
+                return;
+            }
+
+            ctx.start = Date.now();
+
+            cli.tritonapi.listInstanceDisks({
+                id: instanceId
+            }, function onDisks(err, disks) {
+                if (err) {
+                    next(err);
+                    return;
+                }
+
+                ctx.disks = disks;
+                next();
+            });
+        },
+        function addDisk(ctx, next) {
+            cli.tritonapi.addInstanceDisk({
+                id: instanceId,
+                size: size
+            }, function onAddDisk(err, res) {
+                if (err) {
+                    cb(err);
+                    return;
+                }
+
+                ctx.instId = res.instId;
+
+                console.log('Adding disk to instance %s',
+                    instanceId);
+                next();
+            });
+        },
+        function maybeWait(ctx, next) {
+            if (!opts.wait) {
+                next();
+                return;
+            }
+
+            var cloudapi = cli.tritonapi.cloudapi;
+            var waiter = cloudapi.waitForDiskCreate.bind(cloudapi);
+
+            waiter({
+                id: ctx.instId,
+                disks: ctx.disks,
+                diskSize: size
+            }, function (err, disk) {
+                if (err) {
+                    next(err);
+                    return;
+                }
+
+                if (disk) {
+                    var duration = Date.now() - ctx.start;
+                    console.log('Added disk "%s" in %s', disk.id,
+                                common.humanDurationFromMs(duration));
+                    next();
+                } else {
+                    next(new Error('Failed to create disk'));
+                }
+            });
+        }
+    ]}, cb);
+}
+
+do_add.options = [
+    {
+        names: ['help', 'h'],
+        type: 'bool',
+        help: 'Show this help.'
+    },
+    {
+        names: ['wait', 'w'],
+        type: 'bool',
+        help: 'Block until instance state indicates the action is complete.'
+    }
+];
+
+do_add.synopses = ['{{name}} {{cmd}} [OPTIONS] INST SIZE'];
+
+do_add.help = [
+    'Add a disk to a flexible disk instance.',
+    '',
+    '{{usage}}',
+    '',
+    '{{options}}',
+    'Arguments:',
+    '    INST        Instance name, id, or short id',
+    '    SIZE        Size in mebibytes'
+].join('\n');
+
+do_add.completionArgtypes = ['tritoninstance', 'none'];
+
+module.exports = do_add;
diff --git a/lib/do_instance/do_disk/do_delete.js b/lib/do_instance/do_disk/do_delete.js
new file mode 100644
index 0000000..6100ef8
--- /dev/null
+++ b/lib/do_instance/do_disk/do_delete.js
@@ -0,0 +1,137 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright 2019 Joyent, Inc.
+ *
+ * `triton instance disk delete ...`
+ */
+var assert = require('assert-plus');
+var vasync = require('vasync');
+
+var common = require('../../common');
+var errors = require('../../errors');
+
+
+function do_delete(subcmd, opts, args, cb) {
+    assert.func(cb, 'cb');
+
+    if (opts.help) {
+        this.do_help('help', {}, [subcmd], cb);
+        return;
+    }
+
+    if (args.length === 0) {
+        cb(new errors.UsageError('missing INST argument'));
+        return;
+    } else if (args.length === 1) {
+        cb(new errors.UsageError('missing DISK argument'));
+        return;
+    } else if (args.length > 2) {
+        cb(new errors.UsageError('incorrect number of arguments'));
+        return;
+    }
+
+    var cli = this.top;
+    var instanceId = args[0];
+    var diskId = args[1];
+
+    vasync.pipeline({arg: {cli: this.top}, funcs: [
+        common.cliSetupTritonApi,
+        function getDisks(ctx, next) {
+            ctx.start = Date.now();
+
+            cli.tritonapi.listInstanceDisks({
+                id: instanceId
+            }, function onDisks(err, disks) {
+                if (err) {
+                    next(err);
+                    return;
+                }
+
+                ctx.disks = disks;
+                var matchingDisk = disks.filter(function matchDisk(disk) {
+                    return disk.id === diskId || disk.id.slice(0, 8) === diskId;
+                });
+                ctx.deleteId = matchingDisk[0].id;
+
+                next();
+            });
+        },
+        function deleteDisk(ctx, next) {
+            cli.tritonapi.deleteInstanceDisk({
+                id: instanceId,
+                diskId: diskId
+            }, function onDeleted(err, res) {
+                if (err) {
+                    cb(err);
+                    return;
+                }
+
+                ctx.instId = res.instId;
+
+                console.log('Deleting disk "%s" from instance %s',
+                    diskId, instanceId);
+                next();
+            });
+        },
+        function maybeWait(ctx, next) {
+            if (!opts.wait) {
+                next();
+                return;
+            }
+
+            var cloudapi = cli.tritonapi.cloudapi;
+            var waiter = cloudapi.waitForDiskDelete.bind(cloudapi);
+
+            waiter({
+                id: ctx.instId,
+                diskId: ctx.deleteId
+            }, function (err) {
+                if (err) {
+                    next(err);
+                    return;
+                }
+
+                var duration = Date.now() - ctx.start;
+                console.log('Deleted disk "%s" in %s', diskId,
+                            common.humanDurationFromMs(duration));
+                next();
+            });
+        }
+    ]}, cb);
+}
+
+
+do_delete.options = [
+    {
+        names: ['help', 'h'],
+        type: 'bool',
+        help: 'Show this help.'
+    },
+    {
+        names: ['wait', 'w'],
+        type: 'bool',
+        help: 'Block until instance state indicates the action is complete.'
+    }
+];
+
+do_delete.synopses = ['{{name}} {{cmd}} [OPTIONS] INST DISK'];
+
+do_delete.help = [
+    'Delete a disk from an instance.',
+    '',
+    '{{usage}}',
+    '',
+    '{{options}}',
+    'Where "INST" is an instance name, id, or short id.'
+].join('\n');
+
+do_delete.aliases = ['rm'];
+
+do_delete.completionArgtypes = ['tritoninstance', 'none'];
+
+module.exports = do_delete;
diff --git a/lib/do_instance/do_disk/do_get.js b/lib/do_instance/do_disk/do_get.js
new file mode 100644
index 0000000..dbc862e
--- /dev/null
+++ b/lib/do_instance/do_disk/do_get.js
@@ -0,0 +1,83 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright 2019 Joyent, Inc.
+ *
+ * `triton instance disk get ...`
+ */
+
+var assert = require('assert-plus');
+
+var common = require('../../common');
+var errors = require('../../errors');
+
+function do_get(subcmd, opts, args, cb) {
+    assert.func(cb, 'cb');
+
+    if (opts.help) {
+        this.do_help('help', {}, [subcmd], cb);
+        return;
+    }
+
+    if (args.length < 2) {
+        cb(new errors.UsageError('missing INST and/or DISKID arguments'));
+        return;
+    } else if (args.length > 2) {
+        cb(new errors.UsageError('incorrect number of arguments'));
+        return;
+    }
+
+    var instanceId = args[0];
+    var diskId = args[1];
+    var cli = this.top;
+
+    common.cliSetupTritonApi({cli: this.top}, function onSetup(setupErr) {
+        if (setupErr) {
+            cb(setupErr);
+            return;
+        }
+        cli.tritonapi.getInstanceDisk({
+            id: instanceId,
+            diskId: diskId
+        }, function onDisk(err, disk) {
+            if (err) {
+                cb(err);
+                return;
+            }
+
+            if (opts.json) {
+                console.log(JSON.stringify(disk));
+            } else {
+                console.log(JSON.stringify(disk, null, 4));
+            }
+
+            cb();
+        });
+    });
+}
+
+do_get.options = [
+    {
+        names: ['help', 'h'],
+        type: 'bool',
+        help: 'Show this help.'
+    }
+];
+
+do_get.synopses = ['{{name}} {{cmd}} [OPTIONS] INST DISK_UUID'];
+
+do_get.help = [
+    'Show a specific disk of an instance.',
+    '',
+    '{{usage}}',
+    '',
+    '{{options}}'
+].join('\n');
+
+do_get.completionArgtypes = ['tritoninstance', 'none'];
+
+module.exports = do_get;
diff --git a/lib/do_instance/do_disk/do_list.js b/lib/do_instance/do_disk/do_list.js
new file mode 100644
index 0000000..82cb4d1
--- /dev/null
+++ b/lib/do_instance/do_disk/do_list.js
@@ -0,0 +1,108 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright 2019 Joyent, Inc.
+ *
+ * `triton instance disk list ...`
+ */
+var assert = require('assert-plus');
+var tabula = require('tabula');
+
+var common = require('../../common');
+var errors = require('../../errors');
+
+var COLUMNS_DEFAULT = 'shortid,size';
+var SORT_DEFAULT = 'shortid';
+
+function do_list(subcmd, opts, args, cb) {
+    assert.func(cb, 'cb');
+
+    if (opts.help) {
+        this.do_help('help', {}, [subcmd], cb);
+        return;
+    }
+
+    if (args.length === 0) {
+        cb(new errors.UsageError('missing INST argument'));
+        return;
+    } else if (args.length > 1) {
+        cb(new errors.UsageError('incorrect number of arguments'));
+        return;
+    }
+
+    var cli = this.top;
+    var instanceId = args[0];
+
+    common.cliSetupTritonApi({cli: this.top}, function onSetup(setupErr) {
+        if (setupErr) {
+            cb(setupErr);
+            return;
+        }
+        cli.tritonapi.listInstanceDisks({
+            id: instanceId
+        }, function onDisks(err, disks) {
+            if (err) {
+                cb(err);
+                return;
+            }
+
+            disks.forEach(function (disk) {
+                disk.shortid = disk.id.split('-', 1)[0];
+            });
+
+            if (opts.json) {
+                common.jsonStream(disks);
+            } else {
+                var columns = COLUMNS_DEFAULT;
+
+                if (opts.o) {
+                    columns = opts.o;
+                } else if (opts.long) {
+                    columns = COLUMNS_DEFAULT;
+                }
+
+                columns = columns.split(',');
+                var sort = opts.s.split(',');
+
+                tabula(disks, {
+                    skipHeader: opts.H,
+                    columns: columns,
+                    sort: sort
+                });
+            }
+            cb();
+        });
+    });
+}
+
+do_list.options = [
+    {
+        names: ['help', 'h'],
+        type: 'bool',
+        help: 'Show this help.'
+    }
+].concat(common.getCliTableOptions({
+    includeLong: true,
+    sortDefault: SORT_DEFAULT
+}));
+
+do_list.synopses = ['{{name}} {{cmd}} [OPTIONS] INST'];
+
+do_list.help = [
+    'Show the disks that belong to an instance.',
+    '',
+    '{{usage}}',
+    '',
+    '{{options}}',
+    'Where "INST" is an instance name, id, or short id.'
+].join('\n');
+
+do_list.completionArgtypes = ['tritoninstance', 'none'];
+
+do_list.aliases = ['ls'];
+
+module.exports = do_list;
diff --git a/lib/do_instance/do_disk/do_resize.js b/lib/do_instance/do_disk/do_resize.js
new file mode 100644
index 0000000..3d2636b
--- /dev/null
+++ b/lib/do_instance/do_disk/do_resize.js
@@ -0,0 +1,166 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright 2019 Joyent, Inc.
+ *
+ * `triton instance disk resize ...`
+ */
+
+var assert = require('assert-plus');
+var jsprim = require('jsprim');
+var vasync = require('vasync');
+
+var common = require('../../common');
+var errors = require('../../errors');
+
+function do_resize(subcmd, opts, args, cb) {
+    assert.func(cb, 'cb');
+
+    if (opts.help) {
+        this.do_help('help', {}, [subcmd], cb);
+        return;
+    }
+
+    if (args.length === 0) {
+        cb(new errors.UsageError('missing INST argument'));
+        return;
+    } else if (args.length === 1) {
+        cb(new errors.UsageError('missing DISK argument'));
+        return;
+    } else if (args.length === 2) {
+        cb(new errors.UsageErorr('missing SIZE argument'));
+        return;
+    } else if (args.length > 3) {
+        cb(new errors.UsageError('incorrect number of arguments'));
+        return;
+    }
+
+    var cli = this.top;
+    var instanceId = args[0];
+    var diskId = args[1];
+    var size = args[2];
+
+    size = jsprim.parseInteger(size);
+
+    if (typeof (size) !== 'number') {
+        cb(new errors.UsageError('SIZE must be a number'));
+        return;
+    }
+
+    vasync.pipeline({arg: {cli: this.top}, funcs: [
+        common.cliSetupTritonApi,
+        function getDisk(ctx, next) {
+            if (!opts.wait) {
+                next();
+                return;
+            }
+
+            ctx.start = Date.now();
+
+            cli.tritonapi.getInstanceDisk({
+                id: instanceId,
+                diskId: diskId
+            }, function onDisk(err, disk) {
+                if (err) {
+                    next(err);
+                    return;
+                }
+
+                ctx.disk = disk;
+                next();
+            });
+        },
+        function resizeDisk(ctx, next) {
+            if (size < ctx.disk.size && !opts.dangerous_allow_shrink) {
+                next(new Error('--dangerous-allow-shrink must be specified ' +
+                                'when shrinking a disk'));
+            }
+
+            cli.tritonapi.resizeInstanceDisk({
+                id: instanceId,
+                diskId: diskId,
+                size: size,
+                dangerousAllowShrink: opts.dangerous_allow_shrink
+            }, function onResized(err, res) {
+                if (err) {
+                    cb(err);
+                    return;
+                }
+
+                ctx.instId = res.instId;
+
+                console.log('Resizing disk "%s"', ctx.disk.id);
+                next();
+            });
+        },
+        function maybeWait(ctx, next) {
+            if (!opts.wait) {
+                next();
+                return;
+            }
+
+            var cloudapi = cli.tritonapi.cloudapi;
+            var waiter = cloudapi.waitForDiskResize.bind(cloudapi);
+
+            waiter({
+                id: ctx.instId,
+                diskId: ctx.disk.id,
+                diskSize: size,
+                action: 'resize'
+            }, function onDone(err, disk) {
+                if (err) {
+                    next(err);
+                    return;
+                }
+
+                if (disk) {
+                    var duration = Date.now() - ctx.start;
+                    console.log('Resized disk "%s" in %s', disk.id,
+                                common.humanDurationFromMs(duration));
+                    next();
+                } else {
+                    next(new Error('Failed to resize disk'));
+                }
+            });
+        }
+    ]}, cb);
+}
+
+do_resize.options = [
+    {
+        names: ['help', 'h'],
+        type: 'bool',
+        help: 'Show this help.'
+    },
+    {
+        names: ['dangerous-allow-shrink'],
+        type: 'bool',
+        help: 'Allows the disk size to be reduced. This will truncate ' +
+              '(chop off the end of) the disk. Any data previously ' +
+              'written to the truncated area is permanently lost. Snapshots ' +
+              'will not be useful to recover from this operation.'
+    },
+    {
+        names: ['wait', 'w'],
+        type: 'bool',
+        help: 'Block until instance state indicates the action is complete.'
+    }
+];
+
+do_resize.synopses = ['{{name}} {{cmd}} [OPTIONS] INST DISK SIZE'];
+
+do_resize.help = [
+    'Resize a disk for a bhyve instance.',
+    '',
+    '{{usage}}',
+    '',
+    '{{options}}'
+].join('\n');
+
+do_resize.completionArgtypes = ['tritoninstance', 'none'];
+
+module.exports = do_resize;
diff --git a/lib/do_instance/do_disk/index.js b/lib/do_instance/do_disk/index.js
new file mode 100644
index 0000000..f933a60
--- /dev/null
+++ b/lib/do_instance/do_disk/index.js
@@ -0,0 +1,47 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright 2019 Joyent, Inc.
+ *
+ * `triton instance disk ...`
+ */
+
+var Cmdln = require('cmdln').Cmdln;
+var util = require('util');
+
+// ---- CLI class
+
+function DiskCLI(top) {
+    this.top = top.top;
+
+    Cmdln.call(this, {
+        name: top.name + ' disk',
+        desc: 'List, get, add, resize and delete Triton instance disks.',
+        helpSubcmds: [
+            'help',
+            'add',
+            'list',
+            'get',
+            'delete',
+            'resize'
+        ]
+    });
+}
+util.inherits(DiskCLI, Cmdln);
+
+DiskCLI.prototype.init = function init(opts, args, cb) {
+    this.log = this.top.log;
+    Cmdln.prototype.init.apply(this, arguments);
+};
+
+DiskCLI.prototype.do_add = require('./do_add');
+DiskCLI.prototype.do_get = require('./do_get');
+DiskCLI.prototype.do_list = require('./do_list');
+DiskCLI.prototype.do_resize = require('./do_resize');
+DiskCLI.prototype.do_delete = require('./do_delete');
+
+module.exports = DiskCLI;
diff --git a/lib/do_instance/do_disks.js b/lib/do_instance/do_disks.js
new file mode 100644
index 0000000..84b875a
--- /dev/null
+++ b/lib/do_instance/do_disks.js
@@ -0,0 +1,32 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright 2019 Joyent, Inc.
+ *
+ * `triton instance disks ...` shortcut for
+ * `triton instance disk list ...`.
+ */
+
+var targ = require('./do_disk/do_list');
+
+function do_disks(subcmd, opts, args, callback) {
+    this.handlerFromSubcmd('disk').dispatch({
+        subcmd: 'list',
+        opts: opts,
+        args: args
+    }, callback);
+}
+
+do_disks.help = 'A shortcut for "triton instance disk list".\n' +
+    targ.help;
+do_disks.synopses = targ.synopses;
+do_disks.options = targ.options;
+do_disks.completionArgtypes = targ.completionArgtypes;
+
+do_disks.hidden = true;
+
+module.exports = do_disks;
diff --git a/lib/do_instance/index.js b/lib/do_instance/index.js
index 483d407..87496f4 100644
--- a/lib/do_instance/index.js
+++ b/lib/do_instance/index.js
@@ -54,7 +54,8 @@ function InstanceCLI(top) {
             'audit',
             'nic',
             'snapshot',
-            'tag'
+            'tag',
+            'disk'
         ]
     });
 }
@@ -95,6 +96,8 @@ InstanceCLI.prototype.do_snapshot = require('./do_snapshot');
 InstanceCLI.prototype.do_snapshots = require('./do_snapshots');
 InstanceCLI.prototype.do_tag = require('./do_tag');
 InstanceCLI.prototype.do_tags = require('./do_tags');
+InstanceCLI.prototype.do_disk = require('./do_disk');
+InstanceCLI.prototype.do_disks = require('./do_disks');
 
 InstanceCLI.aliases = ['inst'];
 
diff --git a/lib/tritonapi.js b/lib/tritonapi.js
index 77575c1..c7c184a 100644
--- a/lib/tritonapi.js
+++ b/lib/tritonapi.js
@@ -3888,6 +3888,227 @@ TritonApi.prototype.deleteVolume = function deleteVolume(opts, cb) {
     });
 };
 
+// ---- Disks
+
+/**
+ * List an instance's disks.
+ *
+ * @param {Object} opts
+ *      - {String} id: The instance ID, name, or short ID. Required.
+ * @param {Function} callback `function (err, disks, res)`
+ */
+TritonApi.prototype.listInstanceDisks =
+function listInstanceDisks(opts, cb) {
+    assert.string(opts.id, 'opts.id');
+    assert.func(cb, 'cb');
+
+    var self = this;
+    var res;
+    var disks;
+
+    vasync.pipeline({arg: {client: self, id: opts.id}, funcs: [
+        _stepInstId,
+
+        function listDisks(arg, next) {
+            self.cloudapi.listMachineDisks({
+                id: arg.instId,
+                name: opts.name
+            }, function (err, listedDisks, _res) {
+                res = _res;
+                res.instId = arg.instId; // gross hack, in case caller needs it
+                disks = listedDisks;
+                next(err);
+            });
+        }
+    ]}, function (err) {
+        cb(err, disks, res);
+    });
+};
+
+/**
+ * Get an instance's disk.
+ *
+ * @param {Object} opts
+ *      - {String} id: The instance ID, name, or short ID. Required.
+ *      - {String} diskId: The ID or short ID of the disk. Required.
+ * @param {Function} callback `function (err, disk, res)`
+ */
+TritonApi.prototype.getInstanceDisk =
+function getInstanceDisk(opts, cb) {
+    assert.string(opts.id, 'opts.id');
+    assert.string(opts.diskId, 'opts.diskId');
+    assert.func(cb, 'cb');
+
+    var self = this;
+    var machineId = opts.id;
+    var diskId = opts.diskId;
+
+    self.getInstance({
+        id: machineId,
+        fields: ['id', 'disks']
+    }, function onInstance(err, inst) {
+        if (err) {
+            cb(err);
+            return;
+        }
+
+        var matchingDisks = inst.disks.filter(function getDisk(disk) {
+            return disk.id === diskId || disk.id.slice(0, 8) === diskId;
+        });
+
+        if (matchingDisks.length === 1) {
+            cb(null, matchingDisks[0]);
+        } else if (matchingDisks.length === 0) {
+            cb(new errors.ResourceNotFoundError(format(
+                'no disk with id "%s" was found', diskId)));
+        } else {
+            cb(new errors.ResourceNotFoundError(
+                format('no disk with shortId "%s" was found '
+                + 'and "%s" is an ambiguous short id', diskId)));
+        }
+    });
+};
+
+/**
+ * Add a disk to an instance.
+ *
+ * @param {Object} opts
+ *      - {String} id: The instance ID, name, or short ID. Required.
+ *      - {String} size: The size of the disk in mebibytes. Required.
+ * @param {Function} callback `function (err, disks, res)`
+ */
+TritonApi.prototype.addInstanceDisk =
+function addInstanceDisk(opts, cb) {
+    assert.string(opts.id, 'opts.id');
+    assert.ok(opts.size, 'opts.size');
+    assert.func(cb, 'cb');
+
+
+    var self = this;
+    var res;
+
+    vasync.pipeline({arg: {client: self, id: opts.id}, funcs: [
+        _stepInstId,
+
+        function addDisk(arg, next) {
+            self.cloudapi.createMachineDisk({
+                id: arg.instId,
+                size: opts.size
+            }, function (err, _, _res) {
+                res = _res;
+                res.instId = arg.instId; // gross hack, in case caller needs it
+                next(err);
+            });
+        }
+    ]}, function (err) {
+        cb(err, res);
+    });
+};
+
+/**
+ * Delete a disk to an instance.
+ *
+ * @param {Object} opts
+ *      - {String} id: The instance ID, name, or short ID. Required.
+ *      - {String} diskId: The disk ID or short ID. Required.
+ * @param {Function} callback `function (err, disks, res)`
+ */
+TritonApi.prototype.deleteInstanceDisk =
+function deleteInstanceDisk(opts, cb) {
+    assert.string(opts.id, 'opts.id');
+    assert.string(opts.diskId, 'opts.diskId');
+    assert.func(cb, 'cb');
+
+
+    var self = this;
+    var res;
+
+    vasync.pipeline({arg: {client: self, id: opts.id}, funcs: [
+        _stepInstId,
+        function getDisk(arg, next) {
+            self.getInstanceDisk({
+                id: arg.instId,
+                diskId: opts.diskId
+            }, function onDisk(err, disk) {
+                if (err) {
+                    next(err);
+                    return;
+                }
+
+                arg.diskId = disk.id;
+                next();
+            });
+        },
+        function deleteDisk(arg, next) {
+            self.cloudapi.deleteMachineDisk({
+                id: arg.instId,
+                diskId: arg.diskId
+            }, function (err, _, _res) {
+                res = _res;
+                res.instId = arg.instId; // gross hack, in case caller needs it
+                next(err);
+            });
+        }
+    ]}, function (err) {
+        cb(err, res);
+    });
+};
+
+/**
+ * Resize an instance disk.
+ *
+ * @param {Object} opts
+ *      - {String} id: The instance ID, name, or short ID. Required.
+ *      - {String} diskId: The disk ID or short ID. Required.
+ *      - {String} size: The size of the disk in mebibytes. Required.
+ *      - {Boolean} dangerousAllowShrink: Whether a disk can be shrunk.
+ *        Optional.
+ * @param {Function} callback `function (err, disks, res)`
+ */
+TritonApi.prototype.resizeInstanceDisk =
+function resizeInstanceDisk(opts, cb) {
+    assert.string(opts.id, 'opts.id');
+    assert.string(opts.diskId, 'opts.diskId');
+    assert.number(opts.size, 'opts.size');
+    assert.optionalBool(opts.dangerousAllowShrink, 'opts.dangerousAllowShrink');
+    assert.func(cb, 'cb');
+
+    var self = this;
+    var res;
+
+    vasync.pipeline({arg: {client: self, id: opts.id}, funcs: [
+        _stepInstId,
+        function getDisk(arg, next) {
+            self.getInstanceDisk({
+                id: arg.instId,
+                diskId: opts.diskId
+            }, function onDisk(err, disk) {
+                if (err) {
+                    next(err);
+                    return;
+                }
+
+                arg.diskId = disk.id;
+                next();
+            });
+        },
+        function resizeDisk(arg, next) {
+            self.cloudapi.resizeMachineDisk({
+                id: arg.instId,
+                diskId: arg.diskId,
+                size: opts.size,
+                dangerousAllowSrhink: opts.dangerousAllowShrink
+            }, function (err, _, _res) {
+                res = _res;
+                res.instId = arg.instId; // gross hack, in case caller needs it
+                next(err);
+            });
+        }
+    ]}, function (err) {
+        cb(err, res);
+    });
+};
+
 //---- exports
 
 module.exports = {
diff --git a/package.json b/package.json
index 448c992..3e545ab 100644
--- a/package.json
+++ b/package.json
@@ -1,7 +1,7 @@
 {
   "name": "triton",
   "description": "Joyent Triton CLI and client (https://www.joyent.com/triton)",
-  "version": "7.0.2",
+  "version": "7.1.0",
   "author": "Joyent (joyent.com)",
   "homepage": "https://github.com/joyent/node-triton",
   "dependencies": {
diff --git a/test/config.json.sample b/test/config.json.sample
index ec64816..fc86848 100644
--- a/test/config.json.sample
+++ b/test/config.json.sample
@@ -41,4 +41,8 @@
     // ubuntu-certified image.
     "kvmPackage": "<package name or uuid>",
     "kvmImage": "<image uuid, name or name@version>"
+
+    // Optional. Set to 'true' to skip flexible disk tests. These tests assume
+    // the datacenter has flexible disk packages.
+    "skipFlexDiskTests": false
 }
diff --git a/test/integration/cli-disks.test.js b/test/integration/cli-disks.test.js
new file mode 100644
index 0000000..304620c
--- /dev/null
+++ b/test/integration/cli-disks.test.js
@@ -0,0 +1,206 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at hsuitep://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright 2019, Joyent, Inc.
+ */
+
+/*
+ * Test disks commands.
+ */
+
+var h = require('./helpers');
+var f = require('util').format;
+var os = require('os');
+var test = require('tap').test;
+
+var DISK_ID;
+var INST_ALIAS = f('nodetritontest-disks-%s', os.hostname());
+var INST;
+var OPTS = {
+    skip: (!h.CONFIG.allowWriteActions || h.CONFIG.skipFlexDiskTests) &&
+        'requires config.allowWriteActions and config.skipFlexDiskTests=false'
+};
+
+// --- Tests
+
+if (OPTS.skip) {
+    console.error('** skipping %s tests', __filename);
+    console.error('** set "allowWriteActions" in test config to enable');
+}
+
+test('triton instance disks', OPTS, function (suite) {
+    h.printConfig(suite);
+
+    suite.test('  cleanup existing inst with alias ' + INST_ALIAS,
+    function (t) {
+        h.deleteTestInst(t, INST_ALIAS, function (err) {
+            t.ifErr(err);
+            t.end();
+        });
+    });
+
+    suite.test('  setup: triton instance create', function (t) {
+        var disks = JSON.stringify(JSON.stringify([
+            {size: 10240},
+            {size: 512}
+        ]));
+        var diskOpts = ['--disks', disks];
+
+        h.createTestFlexInst(t, INST_ALIAS, {extraFlags: diskOpts},
+        function onInst(err2, instId) {
+            if (h.ifErr(t, err2, 'triton instance create')) {
+                t.end();
+                return;
+            }
+
+            if (!instId) {
+                t.end();
+                return;
+            }
+
+            INST = instId.match(/^(.+?)-/)[1]; // convert to short ID
+            t.end();
+        });
+    });
+
+    suite.test('  triton instance disks', function (t) {
+        var cmd = 'instance disks -s SIZE ' + INST;
+
+        h.triton(cmd, function onDisks(err, stdout, stderr) {
+            if (h.ifErr(t, err, 'triton instance disks')) {
+                t.end();
+                return;
+            }
+
+            var disks = stdout.split('\n');
+            t.ok(disks[0].match(/SHORTID\s+SIZE/));
+            t.strictEqual(disks[1].split(' ')[2], '10240');
+            t.strictEqual(disks[2].split(' ')[2], '512');
+            t.end();
+        });
+    });
+
+    suite.test('  stop instance', function (t) {
+        var cmd = 'instance stop -w ' + INST;
+
+        h.triton(cmd, function onStop(err) {
+            if (h.ifErr(t, err, 'triton instance stop')) {
+                t.end();
+                return;
+            }
+
+            t.end();
+        });
+    });
+
+    suite.test('  triton instance disk add', function (t) {
+        var cmd = 'instance disk add -w ' + INST + ' 256';
+
+        h.triton(cmd, function onAdd(err, stdout, stderr) {
+            if (h.ifErr(t, err, 'triton instance disk add')) {
+                t.end();
+                return;
+            }
+
+            var uuidPattern = new RegExp('[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]' +
+                '{4}-[0-9a-f]{4}-[0-9a-f]{12}');
+
+            DISK_ID = stdout.match(uuidPattern)[0];
+            var lines = stdout.split('\n');
+
+            t.ok(lines[0].match('Adding disk to instance ' + INST),
+                'adding disk');
+            t.ok(lines[1].match('Added disk "' + DISK_ID + '" in \\d+'),
+                'disk added');
+            t.end();
+        });
+    });
+
+    suite.test('  triton instance get added disk', function (t) {
+        var cmd = 'instance disk get ' + INST + ' ' + DISK_ID;
+
+        h.triton(cmd, function onDisks(err, stdout, stderr) {
+            if (h.ifErr(t, err, 'triton instance disk get')) {
+                t.end();
+                return;
+            }
+
+            var disk = JSON.parse(stdout);
+
+            t.strictEqual(disk.size, 256);
+            t.strictEqual(disk.id, DISK_ID);
+            t.end();
+        });
+    });
+
+    suite.test('  triton instance disk resize', function (t) {
+        var cmd = 'instance disk resize -w ' + INST + ' ' + DISK_ID + ' 512';
+
+        h.triton(cmd, function onAdd(err, stdout, stderr) {
+            if (h.ifErr(t, err, 'triton instance disk resize')) {
+                t.end();
+                return;
+            }
+
+            var lines = stdout.split('\n');
+            t.ok(lines[0].match('Resizing disk "' + DISK_ID + '"'),
+                'resizing disk');
+            t.ok(lines[1].match('Resized disk "' + DISK_ID + '" in \\d+'),
+                'disk added');
+            t.end();
+        });
+    });
+
+    suite.test('  triton instance get resized disk', function (t) {
+        var cmd = 'instance disk get ' + INST + ' ' + DISK_ID;
+
+        h.triton(cmd, function onDisks(err, stdout, stderr) {
+            if (h.ifErr(t, err, 'triton instance disk get')) {
+                t.end();
+                return;
+            }
+
+            var disk = JSON.parse(stdout);
+
+            t.strictEqual(disk.size, 512);
+            t.strictEqual(disk.id, DISK_ID);
+            t.end();
+        });
+    });
+
+    suite.test('  triton instance disk delete', function (t) {
+        var cmd = 'instance disk delete -w ' + INST + ' ' + DISK_ID;
+
+        h.triton(cmd, function onDisks(err, stdout, stderr) {
+            if (h.ifErr(t, err, 'triton instance disk delete')) {
+                t.end();
+                return;
+            }
+
+            var lines = stdout.split('\n');
+            t.ok(lines[0].match('Deleting disk "' + DISK_ID + '" from instance '
+                + INST), 'deleting disk');
+            t.ok(lines[1].match('Deleted disk "' + DISK_ID + '" in \\d+'),
+                'disk deleted');
+            t.end();
+        });
+    });
+
+
+    /*
+     * Use a timeout, because '-w' on delete doesn't have a way to know if the
+     * a suite attempt failed or if it is just taking a really long time.
+     */
+    suite.test('  cleanup: triton instance rm INST', {timeout: 10 * 60 * 1000},
+    function (t) {
+        h.deleteTestInst(t, INST_ALIAS, function () {
+            t.end();
+        });
+    });
+
+    suite.end();
+});
diff --git a/test/integration/helpers.js b/test/integration/helpers.js
index e00a613..2737838 100644
--- a/test/integration/helpers.js
+++ b/test/integration/helpers.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright 2017 Joyent, Inc.
+ * Copyright 2019 Joyent, Inc.
  */
 
 /*
@@ -254,6 +254,46 @@ function getTestKvmImg(t, cb) {
     });
 }
 
+/*
+ * Find and return an image that can be used for test *bhyve* provisions
+ *
+ * @param {Tape} t - tape test object
+ * @param {Function} cb - `function (err, imgId)`
+ *      where `imgId` is an image identifier ( an image name, shortid, or id).
+ */
+function getTestBhyveImg(t, cb) {
+    if (CONFIG.bhyveImage) {
+        assert.string(CONFIG.bhyvePackage, 'CONFIG.bhyvePackage');
+        t.ok(CONFIG.bhyveImage, 'bhyveImage from config: ' + CONFIG.bhyveImage);
+        cb(null, CONFIG.bhyveImage);
+        return;
+    }
+
+    var candidateImageNames = {
+        'ubuntu-certified-16.04': true
+    };
+    safeTriton(t, ['img', 'ls', '-j'], function (err, stdout) {
+        var imgId;
+        var imgs = jsonStreamParse(stdout);
+        // Newest images first.
+        tabula.sortArrayOfObjects(imgs, ['-published_at']);
+        var imgRepr;
+        for (var i = 0; i < imgs.length; i++) {
+            var img = imgs[i];
+            if (candidateImageNames[img.name] && !img.requirements ||
+                !img.requirements.brand || img.requirements.brand === 'bhyve') {
+                imgId = img.id;
+                imgRepr = f('%s@%s', img.name, img.version);
+                break;
+            }
+        }
+
+        t.ok(imgId,
+            f('latest bhyve image (using subset of supported names): %s (%s)',
+            imgId, imgRepr));
+        cb(err, imgId);
+    });
+}
 
 /*
  * Find and return an package that can be used for test provisions.
@@ -314,6 +354,46 @@ function getTestKvmPkg(t, cb) {
     });
 }
 
+/*
+ * Find and return an package that can be used for flexible_disk test
+ * provisions.
+ *
+ * @param {Tape} t - tape test object
+ * @param {Function} cb - `function (err, pkgId)`
+ *      where `pkgId` is an package identifier (a name, shortid, or id).
+ */
+
+//XXX: Handle no flex packages
+function getTestFlexPkg(t, cb) {
+    if (CONFIG.flexPackage) {
+        assert.string(CONFIG.flexPackage, 'CONFIG.flexPackage');
+        t.ok(CONFIG.flexPackage, 'flexPackage from config: ' +
+            CONFIG.flexPackage);
+        cb(null, CONFIG.flexPackage);
+        return;
+    }
+
+    safeTriton(t, ['pkg', 'ls', '-j'], function (err, stdout) {
+        var pkgs = jsonStreamParse(stdout);
+        pkgs = pkgs.filter(function getFlex(pkg) {
+            return pkg.flexible_disk === true;
+        });
+
+        if (pkgs.length === 0) {
+            cb();
+            return;
+        }
+
+        // Smallest RAM first.
+        tabula.sortArrayOfObjects(pkgs, ['memory']);
+        var pkgId = pkgs[0].id;
+        t.ok(pkgId, f('smallest (RAM) available flexible_disk package: %s (%s)',
+            pkgId, pkgs[0].name));
+        cb(null, pkgId);
+    });
+}
+
+
 /*
  * Find and return second smallest package name that can be used for
  * test provisions.
@@ -414,6 +494,53 @@ function createTestInst(t, name, opts, cb) {
     });
 }
 
+function createTestFlexInst(t, name, opts, cb) {
+    assert.object(t, 't');
+    assert.string(name, 'name');
+    assert.object(opts, 'opts');
+    assert.optionalArrayOfString(opts.extraFlags, 'opts.extraFlags');
+    assert.func(cb, 'cb');
+
+    getTestFlexPkg(t, function (err, pkgId) {
+        t.ifErr(err);
+        if (err) {
+            cb(err);
+            return;
+        }
+
+        if (!pkgId) {
+            error('No flexible_disk packages are available');
+            cb();
+            return;
+        }
+
+        getTestBhyveImg(t, function (err2, imgId) {
+            t.ifErr(err2);
+            if (err2) {
+                cb(err2);
+                return;
+            }
+
+            var cmd = f('instance create -w -n %s %s %s', name, imgId, pkgId);
+            if (opts.extraFlags) {
+                cmd += ' ' + opts.extraFlags.join(' ');
+            }
+
+            triton(cmd, function (err3, stdout) {
+                t.ifErr(err3, 'create test instance');
+                if (err3) {
+                    cb(err3);
+                    return;
+                }
+
+                var match = stdout.match(/Created .+? \((.+)\)/);
+                var inst = match[1];
+
+                cb(null, inst);
+            });
+        });
+    });
+}
 
 /*
  * Delete the given test instance (by name or id). It is not an error for the
@@ -520,6 +647,7 @@ module.exports = {
 
     createClient: createClient,
     createTestInst: createTestInst,
+    createTestFlexInst: createTestFlexInst,
     deleteTestInst: deleteTestInst,
     deleteTestImg: deleteTestImg,
 
