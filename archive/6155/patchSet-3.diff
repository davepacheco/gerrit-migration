From 7326369977ae4e45caa6a8e86c9bc9c682f0e205 Mon Sep 17 00:00:00 2001
From: Pedro Palazon Candel <pedro@joyent.com>
Date: Fri, 3 May 2019 17:31:29 +0200
Subject: [PATCH] TRITON-967 Add support for flexible disk, disks information
 and disks modifications to triton

---
 CHANGES.md                               |   5 +
 lib/cloudapi2.js                         | 366 +++++++++++++++++++++--
 lib/disks.js                             |  92 ++++++
 lib/do_instance/do_create.js             |  63 +++-
 lib/do_instance/do_disk/do_add.js        | 150 ++++++++++
 lib/do_instance/do_disk/do_delete.js     | 146 +++++++++
 lib/do_instance/do_disk/do_get.js        |  83 +++++
 lib/do_instance/do_disk/do_list.js       | 108 +++++++
 lib/do_instance/do_disk/do_resize.js     | 162 ++++++++++
 lib/do_instance/do_disk/index.js         |  47 +++
 lib/do_instance/do_disks.js              |  32 ++
 lib/do_instance/index.js                 |   5 +-
 lib/tritonapi.js                         | 244 ++++++++++++++-
 package.json                             |   2 +-
 test/config.json.sample                  |   4 +
 test/integration/cli-disks.test.js       | 246 +++++++++++++++
 test/integration/cli-subcommands.test.js |   8 +-
 test/integration/helpers.js              | 134 ++++++++-
 18 files changed, 1848 insertions(+), 49 deletions(-)
 create mode 100644 lib/disks.js
 create mode 100644 lib/do_instance/do_disk/do_add.js
 create mode 100644 lib/do_instance/do_disk/do_delete.js
 create mode 100644 lib/do_instance/do_disk/do_get.js
 create mode 100644 lib/do_instance/do_disk/do_list.js
 create mode 100644 lib/do_instance/do_disk/do_resize.js
 create mode 100644 lib/do_instance/do_disk/index.js
 create mode 100644 lib/do_instance/do_disks.js
 create mode 100644 test/integration/cli-disks.test.js

diff --git a/CHANGES.md b/CHANGES.md
index 7dcf302..842e1d8 100644
--- a/CHANGES.md
+++ b/CHANGES.md
@@ -6,6 +6,11 @@ Known issues:
 
 ## not yet released
 
+## 7.1.0
+
+- [TRITON-967] Add support for listing, adding, deleting, and resizing
+  flexible disk instance disks
+
 - [joyent/node-triton#263] Correct envvar name to `TRITON_TLS_INSECURE`
   in CLI profile validation error message.
 
diff --git a/lib/cloudapi2.js b/lib/cloudapi2.js
index b5fb949..c95e42c 100644
--- a/lib/cloudapi2.js
+++ b/lib/cloudapi2.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2018, Joyent, Inc.
+ * Copyright 2019 Joyent, Inc.
  *
  * Client library for the SmartDataCenter Cloud API (cloudapi).
  * http://apidocs.joyent.com/cloudapi/
@@ -39,9 +39,7 @@ var format = require('util').format;
 var LOMStream = require('lomstream').LOMStream;
 var os = require('os');
 var querystring = require('querystring');
-var vasync = require('vasync');
 var auth = require('smartdc-auth');
-var EventEmitter = require('events').EventEmitter;
 
 var bunyannoop = require('./bunyannoop');
 var common = require('./common');
@@ -144,17 +142,17 @@ function CloudApi(options) {
     }
 
     // XXX relevant?
-    //options.retryCallback = function checkFor500(code) {
+    // options.retryCallback = function checkFor500(code) {
     //    return (code === 500);
-    //};
+    // };
 
     // TODO support token auth
-    //this.token = options.token;
+    // this.token = options.token;
 
     this.client = new SaferJsonClient(options);
 }
 
-CloudApi.prototype.close = function close(callback) {
+CloudApi.prototype.close = function close() {
     this.log.trace({host: this.client.url && this.client.url.host},
         'close cloudapi http client');
     this.client.close();
@@ -190,9 +188,9 @@ CloudApi.prototype._getAuthHeaders =
     headers.date = rs.writeDateHeader();
 
     // TODO: token auth support
-    //if (this.token !== undefined) {
+    // if (this.token !== undefined) {
     //    obj.headers['X-Auth-Token'] = this.token;
-    //}
+    // }
 
     rs.sign(function (err, authz) {
         if (err || !authz) {
@@ -330,8 +328,7 @@ CloudApi.prototype._passThrough = function _passThrough(endpoint, opts, cb) {
          * TODO: this should be on _request, no? So that PUT, POST, etc. get it.
          */
         if (err && err.message === 'DEPTH_ZERO_SELF_SIGNED_CERT' &&
-            self.client.rejectUnauthorized)
-        {
+            self.client.rejectUnauthorized) {
             err = new errors.SelfSignedCertError(err, self.url);
         }
 
@@ -792,7 +789,7 @@ CloudApi.prototype.updateAccount = function updateAccount(opts, cb) {
         var type = self.UPDATE_ACCOUNT_FIELDS[field];
         if (type) {
             assert[type === 'boolean' ? 'bool' : type](opts[field],
-                'opts.'+field);
+                'opts.' + field);
             update[field] = opts[field];
         } else {
             unexpectedFields.push(field);
@@ -1446,7 +1443,7 @@ function createListMachinesStream(options) {
         offset: true
     });
 
-    function fetch(fetcharg, limitObj, datacb, donecb) {
+    function fetch(_fetcharg, limitObj, _datacb, donecb) {
         options.limit = limitObj.limit;
         options.offset = limitObj.offset;
         var endpoint = self._path(
@@ -1454,7 +1451,8 @@ function createListMachinesStream(options) {
 
         self._request(endpoint, function (err, req, res, body) {
             if (err) {
-                return donecb(err);
+                donecb(err);
+                return;
             }
             var resourcecount = res.headers['x-resource-count'];
             var done = once || resourcecount < options.limit;
@@ -2821,7 +2819,7 @@ CloudApi.prototype.getRoleTags = function getRoleTags(opts, cb) {
     // Validate `resource`.
     // TODO: share this validation with `setRoleTags`.
     var resourceRe = new RegExp('^/[^/]{2,}/[^/]+');
-    if (! resourceRe.test(opts.resource)) {
+    if (!resourceRe.test(opts.resource)) {
         throw new TypeError(format('invalid resource "%s": must match ' +
             '"/:account/:type..."', opts.resource));
     }
@@ -2897,7 +2895,7 @@ CloudApi.prototype.setRoleTags = function setRoleTags(opts, cb) {
 
     // Validate `resource`.
     var resourceRe = new RegExp('^/[^/]{2,}/[^/]+');
-    if (! resourceRe.test(opts.resource)) {
+    if (!resourceRe.test(opts.resource)) {
         throw new TypeError(format('invalid resource "%s": must match ' +
             '"/:account/:type..."', opts.resource));
     }
@@ -3018,7 +3016,7 @@ CloudApi.prototype.deleteVolume = function deleteVolume(volumeUuid, cb) {
     this._request({
         method: 'DELETE',
         path: format('/%s/volumes/%s', this.account, volumeUuid)
-    }, function (err, req, res, body) {
+    }, function (err, req, res, _body) {
         cb(err, res);
     });
 };
@@ -3093,6 +3091,340 @@ function waitForVolumeStates(opts, callback) {
     }
 };
 
+// --- Disks
+
+/**
+ * List disks for a given machine.
+ *
+ * Returns an array of disk objects.
+ *
+ * @param {Object} options object containing:
+ *      - {String} id (required) the machine's id.
+ * @param {Function} callback of the form f(err, body, res).
+ */
+CloudApi.prototype.listMachineDisks =
+function listMachineDisks(opts, cb) {
+    assert.object(opts, 'opts');
+    assert.uuid(opts.id, 'opts.id');
+    assert.func(cb, 'cb');
+
+    var endpoint = format('/%s/machines/%s/disks', this.account, opts.id);
+    this._passThrough(endpoint, opts, cb);
+};
+
+/**
+ * Get a single disk for a given machine.
+ *
+ * Returns a disk object.
+ *
+ * @param {Object} options object containing:
+ *      - {String} id (required) the machine's id.
+ *      - {String} diskId (required) the disk's ID
+ * @param {Function} callback of the form f(err, body, res).
+ */
+CloudApi.prototype.getMachineDisk =
+function getMachineDisk(opts, cb) {
+    assert.object(opts, 'opts');
+    assert.uuid(opts.id, 'opts.id');
+    assert.uuid(opts.diskId, 'opts.diskId');
+    assert.func(cb, 'cb');
+
+    var endpoint = format('/%s/machines/%s/disks/%s', this.account, opts.id,
+        encodeURIComponent(opts.diskId));
+    this._passThrough(endpoint, opts, cb);
+};
+
+/**
+ * Create a new disk for a given machine.
+ *
+ * Returns a disk object.
+ *
+ * @param {Object} options object containing:
+ *      - {String} id (required) the machine's id.
+ *      - {String or Number} size (required) in MiB or the string "remaining"
+ *        to use up all remaining available space
+ * @param {Function} callback of the form f(err, body, res).
+ */
+CloudApi.prototype.createMachineDisk =
+function createMachineDisk(opts, cb) {
+    assert.object(opts, 'opts');
+    assert.uuid(opts.id, 'opts.id');
+    assert.ok(opts.size, 'opts.size');
+    if (!isNaN(opts.size)) {
+        assert.ok(opts.size > 0, 'opts.size > 0');
+    }
+    assert.func(cb, 'cb');
+
+    this._request({
+        method: 'POST',
+        path: format('/%s/machines/%s/disks', this.account, opts.id),
+        data: {size: opts.size}
+    }, function (err, req, res, body) {
+        cb(err, body, res);
+    });
+};
+
+/**
+ * Delete a disk for a given machine.
+ *
+ * Returns a disk object.
+ *
+ * @param {Object} options object containing:
+ *      - {String} id (required) the machine's id.
+ *      - {String} diskId (required) the disk id.
+ * @param {Function} callback of the form f(err, body, res).
+ */
+CloudApi.prototype.deleteMachineDisk =
+function deleteMachineDisk(opts, cb) {
+    assert.object(opts, 'opts');
+    assert.uuid(opts.id, 'opts.id');
+    assert.uuid(opts.diskId, 'opts.diskId');
+    assert.func(cb, 'cb');
+
+    this._request({
+        method: 'DELETE',
+        path: format('/%s/machines/%s/disks/%s', this.account, opts.id,
+                     opts.diskId)
+    }, function (err, req, res, body) {
+        cb(err, body, res);
+    });
+};
+
+/**
+ * Resize a disk for a given machine.
+ *
+ * Returns a disk object.
+ *
+ * @param {Object} options object containing:
+ *      - {String} id (required) the machine's id.
+ *      - {String} diskId (required) the disk id.
+ *      - {Number} size (required) in MiB
+ *      - {Boolean} dangerousAllowShrink (optional), whether a disk can be
+ *        shrunk.
+ * @param {Function} callback of the form f(err, body, res).
+ */
+CloudApi.prototype.resizeMachineDisk =
+function resizeMachineDisk(opts, cb) {
+    assert.object(opts, 'opts');
+    assert.uuid(opts.id, 'opts.id');
+    assert.uuid(opts.diskId, 'opts.diskId');
+    assert.number(opts.size, 'opts.size');
+    assert.ok(opts.size > 0, 'opts.size > 0');
+    assert.optionalBool(opts.dangerousAllowShrink, 'opts.dangerousAllowShrink');
+    assert.func(cb, 'cb');
+
+    this._request({
+        method: 'POST',
+        path: format('/%s/machines/%s/disks/%s', this.account, opts.id,
+                     opts.diskId),
+        data: {
+            size: opts.size,
+            dangerous_allow_shrink: opts.dangerousAllowShrink
+        }
+    }, function (err, req, res, body) {
+        cb(err, body, res);
+    });
+};
+
+/**
+ * Wait for a disk to be created
+ *
+ * @param {Object} options
+ *      - {String} id - machine UUID
+ *      - {Array of Object} disks - the disks prior to disk creation
+ *      - {String or Number} size - final size of disk in MiB or "remaining"
+ *      - {Number} interval (optional) - time in ms to poll
+ *      - {Number} waitTimeout (optional) - time in seconds to wait before
+ *        failing with an exception.
+ * @param {Function} cb - called when disk is created or on error
+ */
+CloudApi.prototype.waitForDiskCreate =
+function waitForDiskCreate(opts, cb) {
+    var self = this;
+    assert.object(opts, 'opts');
+    assert.uuid(opts.id, 'opts.id');
+    assert.arrayOfObject(opts.disks, 'opts.disks');
+    assert.ok(opts.size, 'opts.size');
+    assert.optionalNumber(opts.waitTimeout, 'opts.waitTimeout');
+    assert.optionalNumber(opts.interval, 'opts.interval');
+    assert.func(cb, 'cb');
+
+    var interval = (opts.interval === undefined ? 1000 : opts.interval);
+    assert.ok(interval > 0, 'interval must be a positive number');
+
+    var oldDiskIds = opts.disks.map(function toIds(disk) {
+        return disk.id;
+    });
+
+    var startTime = process.hrtime();
+
+    function checkAdd(oldDisks, newDisks, size) {
+        if (newDisks.length > oldDisks.length) {
+            return newDisks.filter(function getAdd(disk) {
+                return oldDiskIds.indexOf(disk.id) === -1 &&
+                    disk.state !== 'creating' &&
+                    disk.size === size;
+            });
+        } else {
+            return [];
+        }
+    }
+
+    poll();
+
+    function poll() {
+        self.listMachineDisks({id: opts.id}, function onDisks(err, disks) {
+            if (err) {
+                cb(err);
+                return;
+            }
+
+            var newDisks = checkAdd(oldDiskIds, disks, opts.size);
+
+            if (newDisks.length === 0) {
+                if (opts.waitTimeout) {
+                    var elapsedMs =
+                        common.monotonicTimeDiffMs(startTime);
+                    if (elapsedMs > opts.waitTimeout) {
+                        cb(new errors.TimeoutError(format('timeout '
+                            + 'waiting for disk %s addition '
+                            + '(elapsed %ds)',
+                            opts.id,
+                            Math.round(elapsedMs / 1000))));
+                        return;
+                    }
+                }
+
+                poll();
+            } else if (newDisks.length === 1) {
+                cb(null, newDisks[0]);
+            } else if (newDisks.length > 1) {
+                cb(new Error('Multiple new disks were detected while ' +
+                    'waiting for disk add to complete.'));
+            }
+        });
+    }
+};
+
+/**
+ * Wait for a disk to be deleted
+ *
+ * @param {Object} options
+ *      - {String} id - machine UUID
+ *      - {String} diskId - diskId
+ *      - {Number} interval (optional) - time in ms to poll
+ *      - {Number} waitTimeout (optional) - time in seconds to wait before
+ *        failing with an exception.
+ * @param {Function} cb - called when disk is deleted or on error
+ */
+CloudApi.prototype.waitForDiskDelete =
+function waitForDiskDelete(opts, cb) {
+    var self = this;
+    assert.object(opts, 'opts');
+    assert.uuid(opts.id, 'opts.id');
+    assert.uuid(opts.diskId, 'opts.diskId');
+    assert.optionalNumber(opts.interval, 'opts.interval');
+    assert.optionalNumber(opts.waitTimeout, 'opts.waitTimeout');
+    assert.func(cb, 'cb');
+
+    var interval = (opts.interval === undefined ? 1000 : opts.interval);
+    assert.ok(interval > 0, 'interval must be a positive number');
+    var startTime = process.hrtime();
+
+    poll();
+
+    function poll() {
+        self.getMachineDisk({
+            id: opts.id,
+            diskId: opts.diskId
+        }, function onDisk(err, _disk, _res) {
+            if (err && err.name === 'ResourceNotFoundError') {
+                cb();
+                return;
+            }
+
+            if (err) {
+                cb(err);
+                return;
+            }
+
+            if (opts.waitTimeout) {
+                var elapsedMs =
+                    common.monotonicTimeDiffMs(startTime);
+                if (elapsedMs > opts.waitTimeout) {
+                    cb(new errors.TimeoutError(format('timeout '
+                        + 'waiting for disk %s addition '
+                        + '(elapsed %ds)',
+                        opts.id,
+                        Math.round(elapsedMs / 1000))));
+                    return;
+                }
+            }
+            setTimeout(poll, interval);
+        });
+    }
+};
+
+/**
+ * Wait for a disk to resize.
+ *
+ * @param {Object} options
+ *      - {String} id - machine UUID
+ *      - {String} diskId - diskId
+ *      - {String or Number} size - final size of disk in MiB or "remaining"
+ *      - {Number} interval (optional) - time in ms to poll
+ *      - {Number} waitTimeout (optional) - time in seconds to wait before
+ *        failing with an exception.
+ * @param {Function} cb - called when disk is resized or on error
+ */
+CloudApi.prototype.waitForDiskResize =
+function waitForDiskResize(opts, cb) {
+    var self = this;
+    assert.object(opts, 'opts');
+    assert.uuid(opts.id, 'opts.id');
+    assert.uuid(opts.diskId, 'opts.diskId');
+    assert.number(opts.size, 'opts.size');
+    assert.optionalNumber(opts.waitTimeout, 'opts.waitTimeout');
+    assert.optionalNumber(opts.interval, 'opts.interval');
+    assert.func(cb, 'cb');
+
+    var interval = (opts.interval === undefined ? 1000 : opts.interval);
+    assert.ok(interval > 0, 'interval must be a positive number');
+    var startTime = process.hrtime();
+
+    poll();
+
+    function poll() {
+        self.getMachineDisk({
+            id: opts.id,
+            diskId: opts.diskId
+        }, function onDisk(err, disk, res) {
+            if (err) {
+                cb(err, null, res);
+                return;
+            }
+
+            if (disk.size === opts.size && disk.state !== 'resizing') {
+                cb(null, disk);
+            } else {
+                if (opts.waitTimeout) {
+                    var elapsedMs =
+                        common.monotonicTimeDiffMs(startTime);
+                    if (elapsedMs > opts.waitTimeout) {
+                        cb(new errors.TimeoutError(format('timeout '
+                            + 'waiting for disk %s addition '
+                            + '(elapsed %ds)',
+                            opts.id,
+                            Math.round(elapsedMs / 1000))));
+                        return;
+                    }
+                }
+                setTimeout(poll, interval);
+            }
+        });
+    }
+};
+
 // --- Exports
 
 module.exports = {
diff --git a/lib/disks.js b/lib/disks.js
new file mode 100644
index 0000000..db9bda9
--- /dev/null
+++ b/lib/disks.js
@@ -0,0 +1,92 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright 2019 Joyent, Inc.
+ *
+ * Utilities for parsing disks from CLI options.
+ */
+
+var assert = require('assert-plus');
+var format = require('util').format;
+var fs = require('fs');
+
+var common = require('./common');
+var errors = require('./errors');
+
+/*
+ * Load and validate disks from these options:
+ *      --disks DATA
+ *      --disks FILE
+ */
+function disksFromOpts(opts, log, cb) {
+    assert.object(log, 'log');
+    assert.func(cb, 'cb');
+
+    var disks;
+    var order = opts._order;
+    for (var i = 0; i < order.length; i++) {
+        if (order[i].key === 'disks') {
+            disks = order[i].value;
+            break;
+        }
+    }
+
+    if (!disks) {
+        cb();
+        return;
+    }
+
+    log.trace({opt: disks}, 'disksFromOpts');
+
+    if (disks[0] === '[') {
+        _addDisksFromJsonStr(disks, cb);
+    } else if (disks[0] === '@') {
+        _addDisksFromFile(disks.slice(1), cb);
+    } else {
+        cb(new errors.usageError('disks does not start with "[" or "@")'));
+        return;
+    }
+}
+
+function _addDisksFromJsonStr(disksStr, cb) {
+    assert.string(disksStr, 'disksStr');
+    try {
+        var disks = JSON.parse(disksStr);
+    } catch (parseErr) {
+        cb(new errors.TritonError(parseErr,
+            format('%s is not valid JSON', disksStr)));
+        return;
+    }
+
+    cb(null, disks);
+}
+
+function _addDisksFromFile(fileStr, cb) {
+    assert.string(fileStr, 'fileStr');
+
+    var filePath = common.tildeSync(fileStr);
+    fs.stat(filePath, function onStat(statErr, stats) {
+        if (statErr || !stats.isFile()) {
+            cb(new errors.TritonError(format(
+                'disks path "%s" is not an existing file', fileStr)));
+            return;
+        }
+
+        fs.readFile(filePath, 'utf8', function onRead(readErr, data) {
+            if (readErr) {
+                cb(readErr);
+                return;
+            }
+
+            _addDisksFromJsonStr(data, cb);
+        });
+    });
+}
+
+module.exports = {
+    disksFromOpts: disksFromOpts
+};
diff --git a/lib/do_instance/do_create.js b/lib/do_instance/do_create.js
index 4cc056b..7a7d2fc 100644
--- a/lib/do_instance/do_create.js
+++ b/lib/do_instance/do_create.js
@@ -12,10 +12,10 @@
 
 var assert = require('assert-plus');
 var format = require('util').format;
-var tabula = require('tabula');
 var vasync = require('vasync');
 
 var common = require('../common');
+var disks = require('../disks');
 var distractions = require('../distractions');
 var errors = require('../errors');
 var mat = require('../metadataandtags');
@@ -84,10 +84,12 @@ function do_create(subcmd, opts, args, cb) {
         this.do_help('help', {}, [subcmd], cb);
         return;
     } else if (args.length !== 2) {
-        return cb(new errors.UsageError('incorrect number of args'));
+        cb(new errors.UsageError('incorrect number of args'));
+        return;
     } else if (opts.nic && opts.network) {
-        return cb(new errors.UsageError(
+        cb(new errors.UsageError(
             '--network and --nic cannot be specified together'));
+        return;
     }
 
     var log = this.top.log;
@@ -132,6 +134,24 @@ function do_create(subcmd, opts, args, cb) {
             next();
         },
 
+        /*
+         * Parse any disks given via `--disks`
+         */
+        function parseDisks(ctx, next) {
+            disks.disksFromOpts(opts, log, function onDisks(err, disksArr) {
+                if (err) {
+                    next(err);
+                    return;
+                }
+                if (disksArr) {
+                    log.trace({disks: disksArr},
+                        'disks loaded from opts');
+                    ctx.disks = disksArr;
+                }
+                next();
+            });
+        },
+
         /*
          * Parse any nics given via `--nic`
          */
@@ -208,7 +228,8 @@ function do_create(subcmd, opts, args, cb) {
             };
             tritonapi.getImage(_opts, function (err, img) {
                 if (err) {
-                    return next(err);
+                    next(err);
+                    return;
                 }
                 ctx.img = img;
                 log.trace({img: img}, 'create-instance img');
@@ -217,7 +238,8 @@ function do_create(subcmd, opts, args, cb) {
         },
         function getPkg(ctx, next) {
             if (args.length < 2) {
-                return next();
+                next();
+                return;
             }
 
             var id = args[1];
@@ -229,7 +251,8 @@ function do_create(subcmd, opts, args, cb) {
 
             tritonapi.getPackage(id, function (err, pkg) {
                 if (err) {
-                    return next(err);
+                    next(err);
+                    return;
                 }
                 log.trace({pkg: pkg}, 'create-instance pkg');
                 ctx.pkg = pkg;
@@ -238,7 +261,8 @@ function do_create(subcmd, opts, args, cb) {
         },
         function getNets(ctx, next) {
             if (!opts.network) {
-                return next();
+                next();
+                return;
             }
             // TODO: want an error or warning on no networks?
             ctx.nets = [];
@@ -258,6 +282,7 @@ function do_create(subcmd, opts, args, cb) {
         },
 
         function createInst(ctx, next) {
+            assert.optionalArrayOfObject(ctx.disks, 'ctx.disks');
             assert.optionalArrayOfObject(ctx.volMounts, 'ctx.volMounts');
 
             var createOpts = {
@@ -277,17 +302,20 @@ function do_create(subcmd, opts, args, cb) {
             if (ctx.volMounts) {
                 createOpts.volumes = ctx.volMounts;
             }
+            if (ctx.disks) {
+                createOpts.disks = ctx.disks;
+            }
             if (opts.affinity) {
                 createOpts.affinity = opts.affinity;
             }
             if (ctx.metadata) {
                 Object.keys(ctx.metadata).forEach(function (key) {
-                    createOpts['metadata.'+key] = ctx.metadata[key];
+                    createOpts['metadata.' + key] = ctx.metadata[key];
                 });
             }
             if (ctx.tags) {
                 Object.keys(ctx.tags).forEach(function (key) {
-                    createOpts['tag.'+key] = ctx.tags[key];
+                    createOpts['tag.' + key] = ctx.tags[key];
                 });
             }
             if (opts.allow_shared_images) {
@@ -314,7 +342,8 @@ function do_create(subcmd, opts, args, cb) {
                 console.log('Creating instance %s (%s, %s@%s)',
                     ctx.inst.name, ctx.inst.id,
                     ctx.img.name, ctx.img.version);
-                return next();
+                next();
+                return;
             }
 
             tritonapi.cloudapi.createMachine(createOpts, function (err, inst) {
@@ -336,7 +365,8 @@ function do_create(subcmd, opts, args, cb) {
         },
         function maybeWait(ctx, next) {
             if (!opts.wait) {
-                return next();
+                next();
+                return;
             }
 
             //  1 'wait': no distraction.
@@ -364,7 +394,8 @@ function do_create(subcmd, opts, args, cb) {
                     distraction.destroy();
                 }
                 if (err) {
-                    return next(err);
+                    next(err);
+                    return;
                 }
                 if (opts.json) {
                     console.log(JSON.stringify(inst));
@@ -507,6 +538,14 @@ do_create.options = [
         type: 'bool',
         help: 'Allow instance creation to use a shared image.'
     },
+    {
+        names: ['disks'],
+        type: 'arrayOfString',
+        helpArg: 'DATA',
+        help: 'Configure disks for an instance with flexible disks. DATA is ' +
+            'a JSON object (if the first character is "{") or "@FILE" to ' +
+            'have disks loaded from FILE.'
+    },
 
     {
         group: 'Other options'
diff --git a/lib/do_instance/do_disk/do_add.js b/lib/do_instance/do_disk/do_add.js
new file mode 100644
index 0000000..32007d1
--- /dev/null
+++ b/lib/do_instance/do_disk/do_add.js
@@ -0,0 +1,150 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright 2019 Joyent, Inc.
+ *
+ * `triton instance disk add ...`
+ */
+var assert = require('assert-plus');
+var jsprim = require('jsprim');
+var vasync = require('vasync');
+
+var common = require('../../common');
+var errors = require('../../errors');
+
+function do_add(subcmd, opts, args, cb) {
+    assert.func(cb, 'cb');
+
+    if (opts.help) {
+        this.do_help('help', {}, [subcmd], cb);
+        return;
+    }
+
+    if (args.length < 2) {
+        cb(new errors.UsageError('missing INST and/or SIZE arguments'));
+        return;
+    } else if (args.length > 2) {
+        cb(new errors.UsageError('incorrect number of arguments'));
+        return;
+    }
+
+    var cli = this.top;
+    var instanceId = args[0];
+    var size = args[1];
+
+    if (size !== 'remaining') {
+        size = jsprim.parseInteger(size);
+
+        if (typeof (size) !== 'number') {
+            cb(new errors.UsageError('SIZE must be a number or "remaining"'));
+            return;
+        }
+    }
+
+    vasync.pipeline({arg: {cli: this.top}, funcs: [
+        common.cliSetupTritonApi,
+        function getDisks(ctx, next) {
+            ctx.start = Date.now();
+
+            cli.tritonapi.listInstanceDisks({
+                id: instanceId
+            }, function onDisks(err, disks) {
+                if (err) {
+                    next(err);
+                    return;
+                }
+
+                ctx.disks = disks;
+                next();
+            });
+        },
+        function addDisk(ctx, next) {
+            cli.tritonapi.addInstanceDisk({
+                id: instanceId,
+                size: size
+            }, function onAddDisk(err, res) {
+                if (err) {
+                    cb(err);
+                    return;
+                }
+
+                ctx.instId = res.instId;
+
+                console.log('Adding disk to instance %s',
+                    instanceId);
+                next();
+            });
+        },
+        function maybeWait(ctx, next) {
+            if (!opts.wait) {
+                next();
+                return;
+            }
+
+            var cloudapi = cli.tritonapi.cloudapi;
+            var waiter = cloudapi.waitForDiskCreate.bind(cloudapi);
+
+            waiter({
+                id: ctx.instId,
+                disks: ctx.disks,
+                size: size,
+                waitTimeout: opts.wait_timeout * 1000
+            }, function (err, disk) {
+                if (err) {
+                    next(err);
+                    return;
+                }
+
+                if (disk) {
+                    var duration = Date.now() - ctx.start;
+                    console.log('Added disk "%s" in %s', disk.id,
+                                common.humanDurationFromMs(duration));
+                    next();
+                } else {
+                    next(new Error('Failed to create disk'));
+                }
+            });
+        }
+    ]}, cb);
+}
+
+do_add.options = [
+    {
+        names: ['help', 'h'],
+        type: 'bool',
+        help: 'Show this help.'
+    },
+    {
+        names: ['wait', 'w'],
+        type: 'bool',
+        help: 'Block until instance state indicates the action is complete.'
+    },
+    {
+        names: ['wait-timeout'],
+        type: 'positiveInteger',
+        default: 120,
+        help: 'The number of seconds to wait before timing out with an error. '
+            + 'The default is 120 seconds.'
+    }
+];
+
+do_add.synopses = ['{{name}} {{cmd}} [OPTIONS] INST SIZE'];
+
+do_add.help = [
+    'Add a disk to a flexible disk instance.',
+    '',
+    '{{usage}}',
+    '',
+    '{{options}}',
+    'Arguments:',
+    '    INST        Instance name, id, or short id',
+    '    SIZE        Size in mebibytes'
+].join('\n');
+
+do_add.completionArgtypes = ['tritoninstance', 'none'];
+
+module.exports = do_add;
diff --git a/lib/do_instance/do_disk/do_delete.js b/lib/do_instance/do_disk/do_delete.js
new file mode 100644
index 0000000..97c76d2
--- /dev/null
+++ b/lib/do_instance/do_disk/do_delete.js
@@ -0,0 +1,146 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright 2019 Joyent, Inc.
+ *
+ * `triton instance disk delete ...`
+ */
+var assert = require('assert-plus');
+var vasync = require('vasync');
+
+var common = require('../../common');
+var errors = require('../../errors');
+
+
+function do_delete(subcmd, opts, args, cb) {
+    assert.func(cb, 'cb');
+
+    if (opts.help) {
+        this.do_help('help', {}, [subcmd], cb);
+        return;
+    }
+
+    if (args.length < 2) {
+        cb(new errors.UsageError('missing INST and/or DISKID arguments'));
+        return;
+    } else if (args.length > 2) {
+        cb(new errors.UsageError('incorrect number of arguments'));
+        return;
+    }
+
+    var cli = this.top;
+    var instanceId = args[0];
+    var diskId = args[1];
+
+    vasync.pipeline({arg: {cli: this.top}, funcs: [
+        common.cliSetupTritonApi,
+        function getDisks(ctx, next) {
+            ctx.start = Date.now();
+
+            cli.tritonapi.listInstanceDisks({
+                id: instanceId
+            }, function onDisks(err, disks) {
+                if (err) {
+                    next(err);
+                    return;
+                }
+
+                ctx.disks = disks;
+                var matchingDisk = disks.filter(function matchDisk(disk) {
+                    return disk.id === diskId || disk.id.slice(0, 8) === diskId;
+                });
+                if (!matchingDisk.length) {
+                    next(new errors.UsageError('unknown DISKID'));
+                    return;
+                }
+                ctx.deleteId = matchingDisk[0].id;
+
+                next();
+            });
+        },
+        function deleteDisk(ctx, next) {
+            cli.tritonapi.deleteInstanceDisk({
+                id: instanceId,
+                diskId: diskId
+            }, function onDeleted(err, res) {
+                if (err) {
+                    cb(err);
+                    return;
+                }
+
+                ctx.instId = res.instId;
+
+                console.log('Deleting disk "%s" from instance %s',
+                    diskId, instanceId);
+                next();
+            });
+        },
+        function maybeWait(ctx, next) {
+            if (!opts.wait) {
+                next();
+                return;
+            }
+
+            var cloudapi = cli.tritonapi.cloudapi;
+            var waiter = cloudapi.waitForDiskDelete.bind(cloudapi);
+
+            waiter({
+                id: ctx.instId,
+                diskId: ctx.deleteId,
+                waitTimeout: opts.wait_timeout * 1000
+            }, function (err) {
+                if (err) {
+                    next(err);
+                    return;
+                }
+
+                var duration = Date.now() - ctx.start;
+                console.log('Deleted disk "%s" in %s', diskId,
+                            common.humanDurationFromMs(duration));
+                next();
+            });
+        }
+    ]}, cb);
+}
+
+
+do_delete.options = [
+    {
+        names: ['help', 'h'],
+        type: 'bool',
+        help: 'Show this help.'
+    },
+    {
+        names: ['wait', 'w'],
+        type: 'bool',
+        help: 'Block until instance state indicates the action is complete.'
+    },
+    {
+        names: ['wait-timeout'],
+        type: 'positiveInteger',
+        default: 120,
+        help: 'The number of seconds to wait before timing out with an error. '
+            + 'The default is 120 seconds.'
+    }
+];
+
+do_delete.synopses = ['{{name}} {{cmd}} [OPTIONS] INST DISK'];
+
+do_delete.help = [
+    'Delete a disk from an instance.',
+    '',
+    '{{usage}}',
+    '',
+    '{{options}}',
+    'Where "INST" is an instance name, id, or short id.'
+].join('\n');
+
+do_delete.aliases = ['rm'];
+
+do_delete.completionArgtypes = ['tritoninstance', 'none'];
+
+module.exports = do_delete;
diff --git a/lib/do_instance/do_disk/do_get.js b/lib/do_instance/do_disk/do_get.js
new file mode 100644
index 0000000..dbc862e
--- /dev/null
+++ b/lib/do_instance/do_disk/do_get.js
@@ -0,0 +1,83 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright 2019 Joyent, Inc.
+ *
+ * `triton instance disk get ...`
+ */
+
+var assert = require('assert-plus');
+
+var common = require('../../common');
+var errors = require('../../errors');
+
+function do_get(subcmd, opts, args, cb) {
+    assert.func(cb, 'cb');
+
+    if (opts.help) {
+        this.do_help('help', {}, [subcmd], cb);
+        return;
+    }
+
+    if (args.length < 2) {
+        cb(new errors.UsageError('missing INST and/or DISKID arguments'));
+        return;
+    } else if (args.length > 2) {
+        cb(new errors.UsageError('incorrect number of arguments'));
+        return;
+    }
+
+    var instanceId = args[0];
+    var diskId = args[1];
+    var cli = this.top;
+
+    common.cliSetupTritonApi({cli: this.top}, function onSetup(setupErr) {
+        if (setupErr) {
+            cb(setupErr);
+            return;
+        }
+        cli.tritonapi.getInstanceDisk({
+            id: instanceId,
+            diskId: diskId
+        }, function onDisk(err, disk) {
+            if (err) {
+                cb(err);
+                return;
+            }
+
+            if (opts.json) {
+                console.log(JSON.stringify(disk));
+            } else {
+                console.log(JSON.stringify(disk, null, 4));
+            }
+
+            cb();
+        });
+    });
+}
+
+do_get.options = [
+    {
+        names: ['help', 'h'],
+        type: 'bool',
+        help: 'Show this help.'
+    }
+];
+
+do_get.synopses = ['{{name}} {{cmd}} [OPTIONS] INST DISK_UUID'];
+
+do_get.help = [
+    'Show a specific disk of an instance.',
+    '',
+    '{{usage}}',
+    '',
+    '{{options}}'
+].join('\n');
+
+do_get.completionArgtypes = ['tritoninstance', 'none'];
+
+module.exports = do_get;
diff --git a/lib/do_instance/do_disk/do_list.js b/lib/do_instance/do_disk/do_list.js
new file mode 100644
index 0000000..82cb4d1
--- /dev/null
+++ b/lib/do_instance/do_disk/do_list.js
@@ -0,0 +1,108 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright 2019 Joyent, Inc.
+ *
+ * `triton instance disk list ...`
+ */
+var assert = require('assert-plus');
+var tabula = require('tabula');
+
+var common = require('../../common');
+var errors = require('../../errors');
+
+var COLUMNS_DEFAULT = 'shortid,size';
+var SORT_DEFAULT = 'shortid';
+
+function do_list(subcmd, opts, args, cb) {
+    assert.func(cb, 'cb');
+
+    if (opts.help) {
+        this.do_help('help', {}, [subcmd], cb);
+        return;
+    }
+
+    if (args.length === 0) {
+        cb(new errors.UsageError('missing INST argument'));
+        return;
+    } else if (args.length > 1) {
+        cb(new errors.UsageError('incorrect number of arguments'));
+        return;
+    }
+
+    var cli = this.top;
+    var instanceId = args[0];
+
+    common.cliSetupTritonApi({cli: this.top}, function onSetup(setupErr) {
+        if (setupErr) {
+            cb(setupErr);
+            return;
+        }
+        cli.tritonapi.listInstanceDisks({
+            id: instanceId
+        }, function onDisks(err, disks) {
+            if (err) {
+                cb(err);
+                return;
+            }
+
+            disks.forEach(function (disk) {
+                disk.shortid = disk.id.split('-', 1)[0];
+            });
+
+            if (opts.json) {
+                common.jsonStream(disks);
+            } else {
+                var columns = COLUMNS_DEFAULT;
+
+                if (opts.o) {
+                    columns = opts.o;
+                } else if (opts.long) {
+                    columns = COLUMNS_DEFAULT;
+                }
+
+                columns = columns.split(',');
+                var sort = opts.s.split(',');
+
+                tabula(disks, {
+                    skipHeader: opts.H,
+                    columns: columns,
+                    sort: sort
+                });
+            }
+            cb();
+        });
+    });
+}
+
+do_list.options = [
+    {
+        names: ['help', 'h'],
+        type: 'bool',
+        help: 'Show this help.'
+    }
+].concat(common.getCliTableOptions({
+    includeLong: true,
+    sortDefault: SORT_DEFAULT
+}));
+
+do_list.synopses = ['{{name}} {{cmd}} [OPTIONS] INST'];
+
+do_list.help = [
+    'Show the disks that belong to an instance.',
+    '',
+    '{{usage}}',
+    '',
+    '{{options}}',
+    'Where "INST" is an instance name, id, or short id.'
+].join('\n');
+
+do_list.completionArgtypes = ['tritoninstance', 'none'];
+
+do_list.aliases = ['ls'];
+
+module.exports = do_list;
diff --git a/lib/do_instance/do_disk/do_resize.js b/lib/do_instance/do_disk/do_resize.js
new file mode 100644
index 0000000..083e368
--- /dev/null
+++ b/lib/do_instance/do_disk/do_resize.js
@@ -0,0 +1,162 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright 2019 Joyent, Inc.
+ *
+ * `triton instance disk resize ...`
+ */
+
+var assert = require('assert-plus');
+var jsprim = require('jsprim');
+var vasync = require('vasync');
+
+var common = require('../../common');
+var errors = require('../../errors');
+
+function do_resize(subcmd, opts, args, cb) {
+    assert.func(cb, 'cb');
+
+    if (opts.help) {
+        this.do_help('help', {}, [subcmd], cb);
+        return;
+    }
+
+    if (args.length < 3) {
+        cb(new errors.UsageError('missing INST, DISKID and/or SIZE arguments'));
+        return;
+    } else if (args.length > 3) {
+        cb(new errors.UsageError('incorrect number of arguments'));
+        return;
+    }
+
+    var cli = this.top;
+    var instanceId = args[0];
+    var diskId = args[1];
+    var size = args[2];
+
+    size = jsprim.parseInteger(size);
+
+    if (typeof (size) !== 'number') {
+        cb(new errors.UsageError('SIZE must be a number'));
+        return;
+    }
+
+    vasync.pipeline({arg: {cli: this.top}, funcs: [
+        common.cliSetupTritonApi,
+        function getDisk(ctx, next) {
+            ctx.start = Date.now();
+
+            cli.tritonapi.getInstanceDisk({
+                id: instanceId,
+                diskId: diskId
+            }, function onDisk(err, disk) {
+                if (err) {
+                    next(err);
+                    return;
+                }
+
+                ctx.disk = disk;
+                next();
+            });
+        },
+        function resizeDisk(ctx, next) {
+            if (size < ctx.disk.size && !opts.dangerous_allow_shrink) {
+                next(new Error('--dangerous-allow-shrink must be specified ' +
+                                'when shrinking a disk'));
+            }
+
+            cli.tritonapi.resizeInstanceDisk({
+                id: instanceId,
+                diskId: diskId,
+                size: size,
+                dangerousAllowShrink: opts.dangerous_allow_shrink
+            }, function onResized(err, res) {
+                if (err) {
+                    cb(err);
+                    return;
+                }
+
+                ctx.instId = res.instId;
+
+                console.log('Resizing disk "%s"', ctx.disk.id);
+                next();
+            });
+        },
+        function maybeWait(ctx, next) {
+            if (!opts.wait) {
+                next();
+                return;
+            }
+
+            var cloudapi = cli.tritonapi.cloudapi;
+            var waiter = cloudapi.waitForDiskResize.bind(cloudapi);
+
+            waiter({
+                id: ctx.instId,
+                diskId: ctx.disk.id,
+                size: size,
+                waitTimeout: opts.wait_timeout * 1000
+            }, function onDone(err, disk) {
+                if (err) {
+                    next(err);
+                    return;
+                }
+
+                if (disk) {
+                    var duration = Date.now() - ctx.start;
+                    console.log('Resized disk "%s" in %s', disk.id,
+                                common.humanDurationFromMs(duration));
+                    next();
+                } else {
+                    next(new Error('Failed to resize disk'));
+                }
+            });
+        }
+    ]}, cb);
+}
+
+do_resize.options = [
+    {
+        names: ['help', 'h'],
+        type: 'bool',
+        help: 'Show this help.'
+    },
+    {
+        names: ['dangerous-allow-shrink'],
+        type: 'bool',
+        help: 'Allows the disk size to be reduced. This will truncate ' +
+              '(chop off the end of) the disk. Any data previously ' +
+              'written to the truncated area is permanently lost. Snapshots ' +
+              'will not be useful to recover from this operation.'
+    },
+    {
+        names: ['wait', 'w'],
+        type: 'bool',
+        help: 'Block until instance state indicates the action is complete.'
+    },
+    {
+        names: ['wait-timeout'],
+        type: 'positiveInteger',
+        default: 120,
+        help: 'The number of seconds to wait before timing out with an error. '
+            + 'The default is 120 seconds.'
+    }
+];
+
+do_resize.synopses = ['{{name}} {{cmd}} [OPTIONS] INST DISK SIZE'];
+
+do_resize.help = [
+    'Resize a disk for a bhyve instance.',
+    '',
+    '{{usage}}',
+    '',
+    '{{options}}'
+].join('\n');
+
+do_resize.completionArgtypes = ['tritoninstance', 'none'];
+
+module.exports = do_resize;
diff --git a/lib/do_instance/do_disk/index.js b/lib/do_instance/do_disk/index.js
new file mode 100644
index 0000000..f933a60
--- /dev/null
+++ b/lib/do_instance/do_disk/index.js
@@ -0,0 +1,47 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright 2019 Joyent, Inc.
+ *
+ * `triton instance disk ...`
+ */
+
+var Cmdln = require('cmdln').Cmdln;
+var util = require('util');
+
+// ---- CLI class
+
+function DiskCLI(top) {
+    this.top = top.top;
+
+    Cmdln.call(this, {
+        name: top.name + ' disk',
+        desc: 'List, get, add, resize and delete Triton instance disks.',
+        helpSubcmds: [
+            'help',
+            'add',
+            'list',
+            'get',
+            'delete',
+            'resize'
+        ]
+    });
+}
+util.inherits(DiskCLI, Cmdln);
+
+DiskCLI.prototype.init = function init(opts, args, cb) {
+    this.log = this.top.log;
+    Cmdln.prototype.init.apply(this, arguments);
+};
+
+DiskCLI.prototype.do_add = require('./do_add');
+DiskCLI.prototype.do_get = require('./do_get');
+DiskCLI.prototype.do_list = require('./do_list');
+DiskCLI.prototype.do_resize = require('./do_resize');
+DiskCLI.prototype.do_delete = require('./do_delete');
+
+module.exports = DiskCLI;
diff --git a/lib/do_instance/do_disks.js b/lib/do_instance/do_disks.js
new file mode 100644
index 0000000..84b875a
--- /dev/null
+++ b/lib/do_instance/do_disks.js
@@ -0,0 +1,32 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright 2019 Joyent, Inc.
+ *
+ * `triton instance disks ...` shortcut for
+ * `triton instance disk list ...`.
+ */
+
+var targ = require('./do_disk/do_list');
+
+function do_disks(subcmd, opts, args, callback) {
+    this.handlerFromSubcmd('disk').dispatch({
+        subcmd: 'list',
+        opts: opts,
+        args: args
+    }, callback);
+}
+
+do_disks.help = 'A shortcut for "triton instance disk list".\n' +
+    targ.help;
+do_disks.synopses = targ.synopses;
+do_disks.options = targ.options;
+do_disks.completionArgtypes = targ.completionArgtypes;
+
+do_disks.hidden = true;
+
+module.exports = do_disks;
diff --git a/lib/do_instance/index.js b/lib/do_instance/index.js
index 483d407..87496f4 100644
--- a/lib/do_instance/index.js
+++ b/lib/do_instance/index.js
@@ -54,7 +54,8 @@ function InstanceCLI(top) {
             'audit',
             'nic',
             'snapshot',
-            'tag'
+            'tag',
+            'disk'
         ]
     });
 }
@@ -95,6 +96,8 @@ InstanceCLI.prototype.do_snapshot = require('./do_snapshot');
 InstanceCLI.prototype.do_snapshots = require('./do_snapshots');
 InstanceCLI.prototype.do_tag = require('./do_tag');
 InstanceCLI.prototype.do_tags = require('./do_tags');
+InstanceCLI.prototype.do_disk = require('./do_disk');
+InstanceCLI.prototype.do_disks = require('./do_disks');
 
 InstanceCLI.aliases = ['inst'];
 
diff --git a/lib/tritonapi.js b/lib/tritonapi.js
index 77575c1..f599604 100644
--- a/lib/tritonapi.js
+++ b/lib/tritonapi.js
@@ -396,7 +396,7 @@ function _stepFabricVlanId(arg, next) {
 
 
 
-//---- TritonApi class
+// ---- TritonApi class
 
 /**
  * Create a TritonApi client.
@@ -646,7 +646,7 @@ TritonApi.prototype.listImages = function listImages(opts, cb) {
             if (!useCache) {
                 return next();
             }
-            self._cacheGetJson(cacheKey, 5*60, function (err, cached_) {
+            self._cacheGetJson(cacheKey, 5 * 60, function (err, cached_) {
                 if (err) {
                     return next(err);
                 }
@@ -719,7 +719,7 @@ TritonApi.prototype.getImage = function getImage(opts, cb) {
                     return;
                 }
                 var cacheKey = 'images.json';
-                self._cacheGetJson(cacheKey, 60*60, function (err, images) {
+                self._cacheGetJson(cacheKey, 60 * 60, function (err, images) {
                     if (err) {
                         next(err);
                         return;
@@ -828,8 +828,7 @@ TritonApi.prototype.getImage = function getImage(opts, cb) {
  *          - {String} image_path The pathname in Manta of the exported image.
  *          and `res` is the CloudAPI `ExportImage` response.
  */
-TritonApi.prototype.exportImage = function exportImage(opts, cb)
-{
+TritonApi.prototype.exportImage = function exportImage(opts, cb) {
     var self = this;
     assert.object(opts, 'opts');
     assert.string(opts.image, 'opts.image');
@@ -878,8 +877,7 @@ TritonApi.prototype.exportImage = function exportImage(opts, cb)
  *      On failure `err` is an error instance, else it is null.
  *      On success: `img` is an image object.
  */
-TritonApi.prototype.shareImage = function shareImage(opts, cb)
-{
+TritonApi.prototype.shareImage = function shareImage(opts, cb) {
     var self = this;
     assert.object(opts, 'opts');
     assert.string(opts.image, 'opts.image');
@@ -923,8 +921,7 @@ TritonApi.prototype.shareImage = function shareImage(opts, cb)
  *      On failure `err` is an error instance, else it is null.
  *      On success: `img` is an image object.
  */
-TritonApi.prototype.unshareImage = function unshareImage(opts, cb)
-{
+TritonApi.prototype.unshareImage = function unshareImage(opts, cb) {
     var self = this;
     assert.object(opts, 'opts');
     assert.string(opts.image, 'opts.image');
@@ -972,8 +969,7 @@ TritonApi.prototype.unshareImage = function unshareImage(opts, cb)
  *      On failure `err` is an error instance, else it is null.
  *      On success: `img` is the cloned image object.
  */
-TritonApi.prototype.cloneImage = function cloneImage(opts, cb)
-{
+TritonApi.prototype.cloneImage = function cloneImage(opts, cb) {
     var self = this;
     assert.object(opts, 'opts');
     assert.string(opts.image, 'opts.image');
@@ -1548,7 +1544,7 @@ TritonApi.prototype.getInstance = function getInstance(opts, cb) {
                 // If already have all the requested fields, no need to re-get.
                 var missingAField = false;
                 for (var i = 0; i < opts.fields.length; i++) {
-                    if (! instFromList.hasOwnProperty(opts.fields[i])) {
+                    if (!instFromList.hasOwnProperty(opts.fields[i])) {
                         missingAField = true;
                         break;
                     }
@@ -3888,7 +3884,229 @@ TritonApi.prototype.deleteVolume = function deleteVolume(opts, cb) {
     });
 };
 
-//---- exports
+// ---- Disks
+
+/**
+ * List an instance's disks.
+ *
+ * @param {Object} opts
+ *      - {String} id: The instance ID, name, or short ID. Required.
+ * @param {Function} callback `function (err, disks, res)`
+ */
+TritonApi.prototype.listInstanceDisks =
+function listInstanceDisks(opts, cb) {
+    assert.string(opts.id, 'opts.id');
+    assert.func(cb, 'cb');
+
+    var self = this;
+    var res;
+    var disks;
+
+    vasync.pipeline({arg: {client: self, id: opts.id}, funcs: [
+        _stepInstId,
+
+        function listDisks(arg, next) {
+            self.cloudapi.listMachineDisks({
+                id: arg.instId
+            }, function (err, listedDisks, _res) {
+                res = _res;
+                res.instId = arg.instId; // gross hack, in case caller needs it
+                disks = listedDisks;
+                next(err);
+            });
+        }
+    ]}, function (err) {
+        cb(err, disks, res);
+    });
+};
+
+/**
+ * Get an instance's disk.
+ *
+ * @param {Object} opts
+ *      - {String} id: The instance ID, name, or short ID. Required.
+ *      - {String} diskId: The ID or short ID of the disk. Required.
+ * @param {Function} callback `function (err, disk)`
+ */
+TritonApi.prototype.getInstanceDisk =
+function getInstanceDisk(opts, cb) {
+    assert.string(opts.id, 'opts.id');
+    assert.string(opts.diskId, 'opts.diskId');
+    assert.func(cb, 'cb');
+
+    var self = this;
+    var machineId = opts.id;
+    var diskId = opts.diskId;
+
+    self.getInstance({
+        id: machineId,
+        fields: ['id', 'disks']
+    }, function onInstance(err, inst) {
+        if (err) {
+            cb(err);
+            return;
+        }
+
+        var matchingDisks = inst.disks.filter(function getDisk(disk) {
+            return disk.id === diskId || disk.id.slice(0, 8) === diskId;
+        });
+
+        if (matchingDisks.length === 1) {
+            cb(null, matchingDisks[0]);
+        } else if (matchingDisks.length === 0) {
+            cb(new errors.ResourceNotFoundError(format(
+                'no disk with id "%s" was found', diskId)));
+        } else {
+            cb(new errors.ResourceNotFoundError(
+                format('Multiple disks with shortId "%s" were found '
+                + 'and "%s" is an ambiguous short id', diskId)));
+        }
+    });
+};
+
+/**
+ * Add a disk to an instance.
+ *
+ * @param {Object} opts
+ *      - {String} id: The instance ID, name, or short ID. Required.
+ *      - {String} size: The size of the disk in mebibytes. Required.
+ * @param {Function} callback `function (err, res)`
+ */
+TritonApi.prototype.addInstanceDisk =
+function addInstanceDisk(opts, cb) {
+    assert.string(opts.id, 'opts.id');
+    assert.ok(opts.size, 'opts.size');
+    assert.optionalNumber(opts.waitTimeout, 'opts.waitTimeout');
+    assert.func(cb, 'cb');
+
+
+    var self = this;
+    var res;
+
+    vasync.pipeline({arg: {client: self, id: opts.id}, funcs: [
+        _stepInstId,
+
+        function addDisk(arg, next) {
+            self.cloudapi.createMachineDisk({
+                id: arg.instId,
+                size: opts.size
+            }, function (err, _, _res) {
+                res = _res;
+                res.instId = arg.instId; // gross hack, in case caller needs it
+                next(err);
+            });
+        }
+    ]}, function (err) {
+        cb(err, res);
+    });
+};
+
+/**
+ * Delete a disk to an instance.
+ *
+ * @param {Object} opts
+ *      - {String} id: The instance ID, name, or short ID. Required.
+ *      - {String} diskId: The disk ID or short ID. Required.
+ * @param {Function} callback `function (err, res)`
+ */
+TritonApi.prototype.deleteInstanceDisk =
+function deleteInstanceDisk(opts, cb) {
+    assert.string(opts.id, 'opts.id');
+    assert.string(opts.diskId, 'opts.diskId');
+    assert.func(cb, 'cb');
+
+
+    var self = this;
+    var res;
+
+    vasync.pipeline({arg: {client: self, id: opts.id}, funcs: [
+        _stepInstId,
+        function getDisk(arg, next) {
+            self.getInstanceDisk({
+                id: arg.instId,
+                diskId: opts.diskId
+            }, function onDisk(err, disk) {
+                if (err) {
+                    next(err);
+                    return;
+                }
+
+                arg.diskId = disk.id;
+                next();
+            });
+        },
+        function deleteDisk(arg, next) {
+            self.cloudapi.deleteMachineDisk({
+                id: arg.instId,
+                diskId: arg.diskId
+            }, function (err, _, _res) {
+                res = _res;
+                res.instId = arg.instId; // gross hack, in case caller needs it
+                next(err);
+            });
+        }
+    ]}, function (err) {
+        cb(err, res);
+    });
+};
+
+/**
+ * Resize an instance disk.
+ *
+ * @param {Object} opts
+ *      - {String} id: The instance ID, name, or short ID. Required.
+ *      - {String} diskId: The disk ID or short ID. Required.
+ *      - {String} size: The size of the disk in mebibytes. Required.
+ *      - {Boolean} dangerousAllowShrink: Whether a disk can be shrunk.
+ *        Optional.
+ * @param {Function} callback `function (err, res)`
+ */
+TritonApi.prototype.resizeInstanceDisk =
+function resizeInstanceDisk(opts, cb) {
+    assert.string(opts.id, 'opts.id');
+    assert.string(opts.diskId, 'opts.diskId');
+    assert.number(opts.size, 'opts.size');
+    assert.optionalBool(opts.dangerousAllowShrink, 'opts.dangerousAllowShrink');
+    assert.optionalNumber(opts.waitTimeout, 'opts.waitTimeout');
+    assert.func(cb, 'cb');
+
+    var self = this;
+    var res;
+
+    vasync.pipeline({arg: {client: self, id: opts.id}, funcs: [
+        _stepInstId,
+        function getDisk(arg, next) {
+            self.getInstanceDisk({
+                id: arg.instId,
+                diskId: opts.diskId
+            }, function onDisk(err, disk) {
+                if (err) {
+                    next(err);
+                    return;
+                }
+
+                arg.diskId = disk.id;
+                next();
+            });
+        },
+        function resizeDisk(arg, next) {
+            self.cloudapi.resizeMachineDisk({
+                id: arg.instId,
+                diskId: arg.diskId,
+                size: opts.size,
+                dangerousAllowSrhink: opts.dangerousAllowShrink
+            }, function (err, _, _res) {
+                res = _res;
+                res.instId = arg.instId; // gross hack, in case caller needs it
+                next(err);
+            });
+        }
+    ]}, function (err) {
+        cb(err, res);
+    });
+};
+
+// ---- exports
 
 module.exports = {
     CLOUDAPI_ACCEPT_VERSION: CLOUDAPI_ACCEPT_VERSION,
diff --git a/package.json b/package.json
index 448c992..3e545ab 100644
--- a/package.json
+++ b/package.json
@@ -1,7 +1,7 @@
 {
   "name": "triton",
   "description": "Joyent Triton CLI and client (https://www.joyent.com/triton)",
-  "version": "7.0.2",
+  "version": "7.1.0",
   "author": "Joyent (joyent.com)",
   "homepage": "https://github.com/joyent/node-triton",
   "dependencies": {
diff --git a/test/config.json.sample b/test/config.json.sample
index ec64816..fc86848 100644
--- a/test/config.json.sample
+++ b/test/config.json.sample
@@ -41,4 +41,8 @@
     // ubuntu-certified image.
     "kvmPackage": "<package name or uuid>",
     "kvmImage": "<image uuid, name or name@version>"
+
+    // Optional. Set to 'true' to skip flexible disk tests. These tests assume
+    // the datacenter has flexible disk packages.
+    "skipFlexDiskTests": false
 }
diff --git a/test/integration/cli-disks.test.js b/test/integration/cli-disks.test.js
new file mode 100644
index 0000000..01d110b
--- /dev/null
+++ b/test/integration/cli-disks.test.js
@@ -0,0 +1,246 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at hsuitep://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright 2019 Joyent, Inc.
+ */
+
+/*
+ * Test disks commands.
+ */
+
+var h = require('./helpers');
+var f = require('util').format;
+var os = require('os');
+var test = require('tap').test;
+
+var DISK_ID;
+var INST_ALIAS = f('nodetritontest-disks-%s', os.hostname());
+var INST;
+var OPTS = {
+    skip: (!h.CONFIG.allowWriteActions || h.CONFIG.skipFlexDiskTests) &&
+        'requires config.allowWriteActions and config.skipFlexDiskTests=false'
+};
+
+// --- Tests
+
+if (OPTS.skip) {
+    console.error('** skipping %s tests', __filename);
+    console.error('** set "allowWriteActions" in test config to enable');
+}
+
+test('triton instance disks', OPTS, function (suite) {
+    h.printConfig(suite);
+
+    suite.test('  cleanup existing inst with alias ' + INST_ALIAS,
+    function (t) {
+        h.deleteTestInst(t, INST_ALIAS, function (err) {
+            t.ifErr(err);
+            t.end();
+        });
+    });
+
+    suite.test('  setup: triton instance create', function (t) {
+        var disks = JSON.stringify(JSON.stringify([
+            {size: 10240},
+            {size: 512}
+        ]));
+        var diskOpts = ['--disks', disks];
+
+        h.createTestFlexInst(t, INST_ALIAS, {extraFlags: diskOpts},
+        function onInst(err2, instId) {
+            if (h.ifErr(t, err2, 'triton instance create')) {
+                t.end();
+                return;
+            }
+            t.ok(instId, 'triton instance create instId');
+            if (!instId) {
+                t.end();
+                return;
+            }
+
+            INST = instId.match(/^(.+?)-/)[1]; // convert to short ID
+            t.end();
+        });
+    });
+
+    suite.test('  triton instance disks', function (t) {
+        if (!INST) {
+            t.comment('Skipping test. Instance not created');
+            t.end();
+            return;
+        }
+        var cmd = 'instance disks -s SIZE ' + INST;
+
+        h.triton(cmd, function onDisks(err, stdout, stderr) {
+            if (h.ifErr(t, err, 'triton instance disks')) {
+                t.end();
+                return;
+            }
+
+            var disks = stdout.split('\n');
+            t.ok(disks[0].match(/SHORTID\s+SIZE/));
+            t.strictEqual(disks[1].split(' ')[2], '10240');
+            t.strictEqual(disks[2].split(' ')[2], '512');
+            t.end();
+        });
+    });
+
+    suite.test('  stop instance', function (t) {
+        if (!INST) {
+            t.comment('Skipping test. Instance not created');
+            t.end();
+            return;
+        }
+        var cmd = 'instance stop -w ' + INST;
+
+        h.triton(cmd, function onStop(err) {
+            if (h.ifErr(t, err, 'triton instance stop')) {
+                t.end();
+                return;
+            }
+
+            t.end();
+        });
+    });
+
+    suite.test('  triton instance disk add', function (t) {
+        if (!INST) {
+            t.comment('Skipping test. Instance not created');
+            t.end();
+            return;
+        }
+        var cmd = 'instance disk add -w ' + INST + ' 256';
+
+        h.triton(cmd, function onAdd(err, stdout, stderr) {
+            if (h.ifErr(t, err, 'triton instance disk add')) {
+                t.end();
+                return;
+            }
+
+            var uuidPattern = new RegExp('[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]' +
+                '{4}-[0-9a-f]{4}-[0-9a-f]{12}');
+
+            DISK_ID = stdout.match(uuidPattern)[0];
+            var lines = stdout.split('\n');
+
+            t.ok(lines[0].match('Adding disk to instance ' + INST),
+                'adding disk');
+            t.ok(lines[1].match('Added disk "' + DISK_ID + '" in \\d+'),
+                'disk added');
+            t.end();
+        });
+    });
+
+    suite.test('  triton instance get added disk', function (t) {
+        if (!INST) {
+            t.comment('Skipping test. Instance not created');
+            t.end();
+            return;
+        }
+        var cmd = 'instance disk get ' + INST + ' ' + DISK_ID;
+
+        h.triton(cmd, function onDisks(err, stdout, stderr) {
+            if (h.ifErr(t, err, 'triton instance disk get')) {
+                t.end();
+                return;
+            }
+
+            var disk = JSON.parse(stdout);
+
+            t.strictEqual(disk.size, 256);
+            t.strictEqual(disk.id, DISK_ID);
+            t.end();
+        });
+    });
+
+    suite.test('  triton instance disk resize', function (t) {
+        if (!INST) {
+            t.comment('Skipping test. Instance not created');
+            t.end();
+            return;
+        }
+        var cmd = 'instance disk resize -w ' + INST + ' ' + DISK_ID + ' 512';
+
+        h.triton(cmd, function onAdd(err, stdout, stderr) {
+            if (h.ifErr(t, err, 'triton instance disk resize')) {
+                t.end();
+                return;
+            }
+
+            var lines = stdout.split('\n');
+            t.ok(lines[0].match('Resizing disk "' + DISK_ID + '"'),
+                'resizing disk');
+            t.ok(lines[1].match('Resized disk "' + DISK_ID + '" in \\d+'),
+                'disk added');
+            t.end();
+        });
+    });
+
+    suite.test('  triton instance get resized disk', function (t) {
+        if (!INST) {
+            t.comment('Skipping test. Instance not created');
+            t.end();
+            return;
+        }
+        var cmd = 'instance disk get ' + INST + ' ' + DISK_ID;
+
+        h.triton(cmd, function onDisks(err, stdout, stderr) {
+            if (h.ifErr(t, err, 'triton instance disk get')) {
+                t.end();
+                return;
+            }
+
+            var disk = JSON.parse(stdout);
+
+            t.strictEqual(disk.size, 512);
+            t.strictEqual(disk.id, DISK_ID);
+            t.end();
+        });
+    });
+
+    suite.test('  triton instance disk delete', function (t) {
+        if (!INST) {
+            t.comment('Skipping test. Instance not created');
+            t.end();
+            return;
+        }
+        var cmd = 'instance disk delete -w ' + INST + ' ' + DISK_ID;
+
+        h.triton(cmd, function onDisks(err, stdout, stderr) {
+            if (h.ifErr(t, err, 'triton instance disk delete')) {
+                t.end();
+                return;
+            }
+
+            var lines = stdout.split('\n');
+            t.ok(lines[0].match('Deleting disk "' + DISK_ID + '" from instance '
+                + INST), 'deleting disk');
+            t.ok(lines[1].match('Deleted disk "' + DISK_ID + '" in \\d+'),
+                'disk deleted');
+            t.end();
+        });
+    });
+
+
+    /*
+     * Use a timeout, because '-w' on delete doesn't have a way to know if the
+     * a suite attempt failed or if it is just taking a really long time.
+     */
+    suite.test('  cleanup: triton instance rm INST', {timeout: 10 * 60 * 1000},
+    function (t) {
+        if (!INST) {
+            t.comment('Skipping test. Instance not created');
+            t.end();
+            return;
+        }
+        h.deleteTestInst(t, INST_ALIAS, function () {
+            t.end();
+        });
+    });
+
+    suite.end();
+});
diff --git a/test/integration/cli-subcommands.test.js b/test/integration/cli-subcommands.test.js
index 057807d..416c334 100644
--- a/test/integration/cli-subcommands.test.js
+++ b/test/integration/cli-subcommands.test.js
@@ -17,8 +17,6 @@ var f = require('util').format;
 var h = require('./helpers');
 var test = require('tap').test;
 
-var common = require('../../lib/common');
-
 var subs = [
     ['info'],
     ['profile'],
@@ -62,6 +60,12 @@ var subs = [
     ['instance nic list', 'instance nic ls'],
     ['instance nic get'],
     ['instance nic delete', 'instance nic rm'],
+    ['instance disk'],
+    ['instance disk add'],
+    ['instance disk list', 'instance disk ls'],
+    ['instance disk get'],
+    ['instance disk resize'],
+    ['instance disk delete', 'instance disk rm'],
     ['ip'],
     ['ssh'],
     ['network'],
diff --git a/test/integration/helpers.js b/test/integration/helpers.js
index e00a613..1211620 100644
--- a/test/integration/helpers.js
+++ b/test/integration/helpers.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright 2017 Joyent, Inc.
+ * Copyright 2019 Joyent, Inc.
  */
 
 /*
@@ -19,7 +19,6 @@ var os = require('os');
 var path = require('path');
 var tabula = require('tabula');
 
-var common = require('../../lib/common');
 var mod_triton = require('../../');
 var testcommon = require('../lib/testcommon');
 
@@ -78,7 +77,6 @@ if (CONFIG.allowWriteActions === undefined)
     CONFIG.allowWriteActions = false;
 
 var TRITON = [process.execPath, path.resolve(__dirname, '../../bin/triton')];
-var UA = 'node-triton-test';
 
 var LOG = require('../lib/log');
 
@@ -254,6 +252,46 @@ function getTestKvmImg(t, cb) {
     });
 }
 
+/*
+ * Find and return an image that can be used for test *bhyve* provisions.
+ *
+ * @param {Tape} t - tape test object
+ * @param {Function} cb - `function (err, imgId)`
+ *      where `imgId` is an image identifier (an image name, shortid, or id).
+ */
+function getTestBhyveImg(t, cb) {
+    if (CONFIG.bhyveImage) {
+        assert.string(CONFIG.bhyvePackage, 'CONFIG.bhyvePackage');
+        t.ok(CONFIG.bhyveImage, 'bhyveImage from config: ' + CONFIG.bhyveImage);
+        cb(null, CONFIG.bhyveImage);
+        return;
+    }
+
+    var candidateImageNames = {
+        'ubuntu-certified-16.04': true
+    };
+    safeTriton(t, ['img', 'ls', '-j'], function (err, stdout) {
+        var imgId;
+        var imgs = jsonStreamParse(stdout);
+        // Newest images first.
+        tabula.sortArrayOfObjects(imgs, ['-published_at']);
+        var imgRepr;
+        for (var i = 0; i < imgs.length; i++) {
+            var img = imgs[i];
+            if (candidateImageNames[img.name] && !img.requirements ||
+                !img.requirements.brand || img.requirements.brand === 'bhyve') {
+                imgId = img.id;
+                imgRepr = f('%s@%s', img.name, img.version);
+                break;
+            }
+        }
+
+        t.ok(imgId,
+            f('latest bhyve image (using subset of supported names): %s (%s)',
+            imgId, imgRepr));
+        cb(err, imgId);
+    });
+}
 
 /*
  * Find and return an package that can be used for test provisions.
@@ -314,6 +352,48 @@ function getTestKvmPkg(t, cb) {
     });
 }
 
+/*
+ * Find and return a package that can be used for flexible_disk test
+ * provisions.
+ *
+ * @param {Tape} t - tape test object
+ * @param {Function} cb - `function (err, pkgId)`
+ *      where `pkgId` is an package identifier (a name, shortid, or id).
+ */
+function getTestFlexPkg(t, cb) {
+    if (CONFIG.flexPackage) {
+        assert.string(CONFIG.flexPackage, 'CONFIG.flexPackage');
+        t.ok(CONFIG.flexPackage, 'flexPackage from config: ' +
+            CONFIG.flexPackage);
+        cb(null, CONFIG.flexPackage);
+        return;
+    }
+
+    safeTriton(t, ['pkg', 'ls', '-j'], function (err, stdout) {
+        if (err) {
+            cb(err);
+            return;
+        }
+        var pkgs = jsonStreamParse(stdout);
+        pkgs = pkgs.filter(function getFlex(pkg) {
+            return pkg.flexible_disk === true;
+        });
+
+        if (pkgs.length === 0) {
+            cb();
+            return;
+        }
+
+        // Smallest RAM first.
+        tabula.sortArrayOfObjects(pkgs, ['memory']);
+        var pkgId = pkgs[0].id;
+        t.ok(pkgId, f('smallest (RAM) available flexible_disk package: %s (%s)',
+            pkgId, pkgs[0].name));
+        cb(null, pkgId);
+    });
+}
+
+
 /*
  * Find and return second smallest package name that can be used for
  * test provisions.
@@ -414,6 +494,53 @@ function createTestInst(t, name, opts, cb) {
     });
 }
 
+function createTestFlexInst(t, name, opts, cb) {
+    assert.object(t, 't');
+    assert.string(name, 'name');
+    assert.object(opts, 'opts');
+    assert.optionalArrayOfString(opts.extraFlags, 'opts.extraFlags');
+    assert.func(cb, 'cb');
+
+    getTestFlexPkg(t, function (err, pkgId) {
+        t.ifErr(err);
+        if (err) {
+            cb(err);
+            return;
+        }
+
+        if (!pkgId) {
+            error('No flexible_disk packages are available');
+            cb();
+            return;
+        }
+
+        getTestBhyveImg(t, function (err2, imgId) {
+            t.ifErr(err2);
+            if (err2) {
+                cb(err2);
+                return;
+            }
+
+            var cmd = f('instance create -w -n %s %s %s', name, imgId, pkgId);
+            if (opts.extraFlags) {
+                cmd += ' ' + opts.extraFlags.join(' ');
+            }
+
+            triton(cmd, function (err3, stdout) {
+                t.ifErr(err3, 'create test instance');
+                if (err3) {
+                    cb(err3);
+                    return;
+                }
+
+                var match = stdout.match(/Created .+? \((.+)\)/);
+                var inst = match[1];
+
+                cb(null, inst);
+            });
+        });
+    });
+}
 
 /*
  * Delete the given test instance (by name or id). It is not an error for the
@@ -520,6 +647,7 @@ module.exports = {
 
     createClient: createClient,
     createTestInst: createTestInst,
+    createTestFlexInst: createTestFlexInst,
     deleteTestInst: deleteTestInst,
     deleteTestImg: deleteTestImg,
 
-- 
2.21.0

