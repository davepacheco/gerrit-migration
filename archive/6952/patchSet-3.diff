From ce2922905227f6b40c84a2bfb2d43175ca81f1f6 Mon Sep 17 00:00:00 2001
From: Mohamed Khalfella <khalfella@gmail.com>
Date: Wed, 2 Oct 2019 21:54:10 +0000
Subject: [PATCH] MANTA-3479 want haproxy metrics from loadbalancer instances

---
 lib/app.js                   |  18 +
 lib/haproxy_sock.js          |  18 +-
 lib/metrics_exporter.js      | 868 +++++++++++++++++++++++++++++++++++
 package.json                 |   3 +-
 test/metrics_exports.test.js | 121 +++++
 5 files changed, 1025 insertions(+), 3 deletions(-)
 create mode 100644 lib/metrics_exporter.js
 create mode 100644 test/metrics_exports.test.js

diff --git a/lib/app.js b/lib/app.js
index e9b8a04..8bda9df 100644
--- a/lib/app.js
+++ b/lib/app.js
@@ -42,6 +42,7 @@ const FSM = require('mooremachine').FSM;
 const lib_lbman = require('./lb_manager');
 const lib_watch = require('./watch');
 const lib_hasock = require('./haproxy_sock');
+const lib_metrics = require('./metrics_exporter');
 
 function domainToPath(domain) {
     return ('/' + domain.split('.').reverse().join('/'));
@@ -52,6 +53,14 @@ const SETUP_RETRY_TIMEOUT = 30000;
 const BESTATE_DOUBLECHECK = 30000;
 const MAX_DIRTY_TIME = 6*3600*1000;
 
+/*
+ * XXX: For now METRICS_PORT is set to an arbitrary value > 1024. We need
+ * to revisit this decision in the future and set "metricPorts" in instance
+ * metadata, similar to what binder does. This way cmon-agent can discover
+ * the metrics port automatically.
+ */
+const METRICS_PORT = 12321;
+
 function AppFSM(cfg) {
     this.a_log = cfg.log;
 
@@ -70,6 +79,15 @@ function AppFSM(cfg) {
 
     this.a_reloadCmd = cfg.reload;
 
+    cfg.metricsPort = METRICS_PORT;
+    this.a_metricsExporter = lib_metrics.createMetricsExporter(cfg);
+    this.a_metricsExporter.start(function (_err) {
+        /*
+         * The metric server is not a critical component of muppet.
+         * If it has failed to start, we would log the error and continue.
+         */
+    });
+
     FSM.call(this, 'getips');
 }
 mod_util.inherits(AppFSM, FSM);
diff --git a/lib/haproxy_sock.js b/lib/haproxy_sock.js
index 9979994..21c7a0e 100644
--- a/lib/haproxy_sock.js
+++ b/lib/haproxy_sock.js
@@ -28,6 +28,10 @@ const HAPROXY_SOCK_PATH = '/tmp/haproxy';
 const CONNECT_TIMEOUT = 3000;
 const COMMAND_TIMEOUT = 30000;
 
+/* Stats commands */
+const HAPROXY_SERVER_STATS_COMMAND = 'show stat -1 4 -1';
+const HAPROXY_ALL_STATS_COMMAND = 'show stat -1 7 -1';
+
 function HaproxyCmdFSM(opts) {
     mod_assert.string(opts.command, 'opts.command');
     this.hcf_cmd = opts.command;
@@ -187,12 +191,20 @@ function disconnectServer(opts, cb) {
 }
 
 function serverStats(opts, cb) {
+    statsCommon(opts, HAPROXY_SERVER_STATS_COMMAND, cb);
+}
+function allStats(opts, cb) {
+    statsCommon(opts, HAPROXY_ALL_STATS_COMMAND, cb);
+}
+
+function statsCommon(opts, cmd, cb) {
     mod_assert.object(opts, 'options');
+    mod_assert.string(cmd, 'cmd');
     mod_assert.func(cb, 'callback');
     mod_assert.object(opts.log, 'opts.log');
 
     var fsm = new HaproxyCmdFSM({
-        command: 'show stat -1 4 -1',
+        command: cmd,
         log: opts.log
     });
     fsm.on('result', function (output) {
@@ -343,5 +355,7 @@ module.exports = {
     disconnectServer: disconnectServer,
     /* Used by app.js */
     serverStats: serverStats,
-    syncServerState: syncServerState
+    syncServerState: syncServerState,
+    /* Used by metric_exporter.js */
+    allStats: allStats
 };
diff --git a/lib/metrics_exporter.js b/lib/metrics_exporter.js
new file mode 100644
index 0000000..68eccc4
--- /dev/null
+++ b/lib/metrics_exporter.js
@@ -0,0 +1,868 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright 2019 Joyent, Inc.
+ */
+
+
+const mod_assert = require('assert-plus');
+const mod_jsprim = require('jsprim');
+const mod_restify = require('restify');
+const mod_os = require('os');
+const lib_hasock = require('./haproxy_sock');
+
+const HAPROXY_FRONTEND = '0';
+const HAPROXY_BACKEND = '1';
+const HAPROXY_SERVER = '2';
+
+const HOSTNAME = mod_os.hostname();
+
+/*
+ * Helper functiions
+ */
+function isUp(status) {
+    return ((status === 'UP') ? '1' : '0');
+}
+
+function haproxyComponentName(comp) {
+    var componentName;
+    switch (comp) {
+        case '0':
+            componentName = 'frontend';
+        break;
+        case '1':
+            componentName =  'backend';
+        break;
+        case '2':
+            componentName = 'server';
+        break;
+        default :
+            componentName = 'unknown';
+        break;
+    }
+    return (componentName);
+}
+
+/*
+ * All haproxy metrics go in this arrary.
+ */
+const HAPROXY_METRICS = [
+    // Frontend Metrics
+    {
+        name: 'current_sessions',
+        type: 'gauge',
+        hpComponent: HAPROXY_FRONTEND,
+        labels: { name: 'pxname' },
+        desc: 'Current number of active sessions.',
+        stats: [ { statName: 'scur' } ]
+    },
+    {
+        name: 'max_sessions',
+        type: 'gauge',
+        hpComponent: HAPROXY_FRONTEND,
+        labels: { name: 'pxname' },
+        desc: 'Maximum observed number of active sessions.',
+        stats: [ { statName: 'smax' } ]
+    },
+    {
+        name: 'limit_sessions',
+        type: 'gauge',
+        hpComponent: HAPROXY_FRONTEND,
+        labels: { name: 'pxname' },
+        desc: 'Configured session limit.',
+        stats: [ { statName: 'slim' } ]
+    },
+    {
+        name: 'sessions_total',
+        type: 'counter',
+        hpComponent: HAPROXY_FRONTEND,
+        labels: { name: 'pxname' },
+        desc: 'Total number of sessions.',
+        stats: [ { statName: 'stot' } ]
+    },
+    {
+        name: 'bytes_in_total',
+        type: 'counter',
+        hpComponent: HAPROXY_FRONTEND,
+        labels: { name: 'pxname' },
+        desc: 'Current total of incoming bytes.',
+        stats: [ { statName: 'bin' } ]
+    },
+    {
+        name: 'bytes_out_total',
+        type: 'counter',
+        hpComponent: HAPROXY_FRONTEND,
+        labels: { name: 'pxname' },
+        desc: 'Current total of outgoing bytes.',
+        stats: [ { statName: 'bout' } ]
+    },
+    {
+        name: 'requests_denied_total',
+        type: 'counter',
+        hpComponent: HAPROXY_FRONTEND,
+        labels: { name: 'pxname' },
+        desc: 'Total of requests denied for security.',
+        stats: [ { statName: 'dreq' } ]
+    },
+    {
+        name: 'request_errors_total',
+        type: 'counter',
+        hpComponent: HAPROXY_FRONTEND,
+        labels: { name: 'pxname' },
+        desc: 'Total of request errors.',
+        stats: [ { statName: 'ereq' } ]
+    },
+    {
+        name: 'current_session_rate',
+        type: 'gauge',
+        hpComponent: HAPROXY_FRONTEND,
+        labels: { name: 'pxname' },
+        desc: 'Current number of sessions per second over last elapsed second.',
+        stats: [ { statName: 'rate' } ]
+    },
+    {
+        name: 'limit_session_rate',
+        type: 'gauge',
+        hpComponent: HAPROXY_FRONTEND,
+        labels: { name: 'pxname' },
+        desc: 'Configured limit on new sessions per second.',
+        stats: [ { statName: 'rate_lim' } ]
+    },
+    {
+        name: 'max_session_rate',
+        type: 'gauge',
+        hpComponent: HAPROXY_FRONTEND,
+        labels: { name: 'pxname' },
+        desc: 'Maximum observed number of sessions per second.',
+        stats: [ { statName: 'rate_max' } ]
+    },
+    {
+        name: 'http_responses_total',
+        type: 'counter',
+        hpComponent: HAPROXY_FRONTEND,
+        labels: { name: 'pxname' },
+        desc: 'Total of HTTP responses.',
+        stats: [
+            {
+                statName: 'hrsp_1xx',
+                labels: { code: '1xx' }
+            },
+            {
+                statName: 'hrsp_2xx',
+                labels: { code: '2xx' }
+            },
+            {
+                statName: 'hrsp_3xx',
+                labels: { code: '3xx' }
+            },
+            {
+                statName: 'hrsp_4xx',
+                labels: { code: '4xx' }
+            },
+            {
+                statName: 'hrsp_5xx',
+                labels: { code: '5xx' }
+            },
+            {
+                statName: 'hrsp_other',
+                labels: { code: 'other' }
+            }
+        ]
+    },
+    {
+        name: 'http_requests_total',
+        type: 'counter',
+        hpComponent: HAPROXY_FRONTEND,
+        labels: { name: 'pxname' },
+        desc: 'Total HTTP requests.',
+        stats: [ { statName: 'req_tot' } ]
+    },
+    {
+        name: 'compressor_bytes_in_total',
+        type: 'counter',
+        hpComponent: HAPROXY_FRONTEND,
+        labels: { name: 'pxname' },
+        desc: 'Number of HTTP response bytes fed to the compressor.',
+        stats: [ { statName: 'comp_in' } ]
+    },
+    {
+        name: 'compressor_bytes_out_total',
+        type: 'counter',
+        hpComponent: HAPROXY_FRONTEND,
+        labels: { name: 'pxname' },
+        desc: 'Number of HTTP response bytes emitted by the compressor.',
+        stats: [ { statName: 'comp_out' } ]
+    },
+    {
+        name: 'compressor_bytes_bypassed_total',
+        type: 'counter',
+        hpComponent: HAPROXY_FRONTEND,
+        labels: { name: 'pxname' },
+        desc: 'Number of bytes that bypassed the HTTP compressor.',
+        stats: [ { statName: 'comp_byp' } ]
+    },
+    {
+        name: 'http_responses_compressed_total',
+        type: 'counter',
+        hpComponent: HAPROXY_FRONTEND,
+        labels: { name: 'pxname' },
+        desc: 'Number of HTTP responses that were compressed.',
+        stats: [ { statName: 'comp_rsp' } ]
+    },
+    {
+        name: 'connections_total',
+        type: 'counter',
+        hpComponent: HAPROXY_FRONTEND,
+        labels: { name: 'pxname' },
+        desc: 'Total number of connections.',
+        stats: [ { statName: 'conn_tot' } ]
+    },
+
+    // Backend Metrics
+    {
+        name: 'current_queue',
+        type: 'gauge',
+        hpComponent: HAPROXY_BACKEND,
+        labels: { name: 'pxname' },
+        desc: 'Current number of queued requests not assigned to any server.',
+        stats: [ { statName: 'qcur' } ]
+    },
+    {
+        name: 'max_queue',
+        type: 'gauge',
+        hpComponent: HAPROXY_BACKEND,
+        labels: { name: 'pxname' },
+        desc: 'Maximum observed number of queued ' +
+            'requests not assigned to any server.',
+        stats: [ { statName: 'qmax' } ]
+    },
+    {
+        name: 'current_sessions',
+        type: 'gauge',
+        hpComponent: HAPROXY_BACKEND,
+        labels: { name: 'pxname' },
+        desc: 'Current number of active sessions.',
+        stats: [ { statName: 'scur' } ]
+    },
+    {
+        name: 'max_sessions',
+        type: 'gauge',
+        hpComponent: HAPROXY_BACKEND,
+        labels: { name: 'pxname' },
+        desc: 'Maximum observed number of active sessions.',
+        stats: [ { statName: 'smax' } ]
+    },
+    {
+        name: 'limit_sessions',
+        type: 'gauge',
+        hpComponent: HAPROXY_BACKEND,
+        labels: { name: 'pxname' },
+        desc: 'Configured session limit.',
+        stats: [ { statName: 'slim' } ]
+    },
+    {
+        name: 'sessions_total',
+        type: 'counter',
+        hpComponent: HAPROXY_BACKEND,
+        labels: { name: 'pxname' },
+        desc: 'Total number of sessions.',
+        stats: [ { statName: 'stot' } ]
+    },
+    {
+        name: 'bytes_in_total',
+        type: 'counter',
+        hpComponent: HAPROXY_BACKEND,
+        labels: { name: 'pxname' },
+        desc: 'Current total of incoming bytes.',
+        stats: [ { statName: 'bin' } ]
+    },
+    {
+        name: 'bytes_out_total',
+        type: 'counter',
+        hpComponent: HAPROXY_BACKEND,
+        labels: { name: 'pxname' },
+        desc: 'Current total of outgoing bytes.',
+        stats: [ { statName: 'bout' } ]
+    },
+    {
+        name: 'connection_errors_total',
+        type: 'counter',
+        hpComponent: HAPROXY_BACKEND,
+        labels: { name: 'pxname' },
+        desc: 'Total of connection errors.',
+        stats: [ { statName: 'econ' } ]
+    },
+    {
+        name: 'response_errors_total',
+        type: 'counter',
+        hpComponent: HAPROXY_BACKEND,
+        labels: { name: 'pxname' },
+        desc: 'Total of response errors.',
+        stats: [ { statName: 'eresp' } ]
+    },
+    {
+        name: 'retry_warnings_total',
+        type: 'counter',
+        hpComponent: HAPROXY_BACKEND,
+        labels: { name: 'pxname' },
+        desc: 'Total of retry warnings.',
+        stats: [ { statName: 'wretr' } ]
+    },
+    {
+        name: 'redispatch_warnings_total',
+        type: 'counter',
+        hpComponent: HAPROXY_BACKEND,
+        labels: { name: 'pxname' },
+        desc: 'Total of redispatch warnings.',
+        stats: [ { statName: 'wredis' } ]
+    },
+    {
+        name: 'up',
+        type: 'gauge',
+        hpComponent: HAPROXY_BACKEND,
+        labels: { name: 'pxname' },
+        desc: 'Current health status of the backend (1 = UP, 0 = DOWN).',
+        stats: [ { statName: 'status', modifier: isUp } ]
+    },
+    {
+        name: 'weight',
+        type: 'gauge',
+        hpComponent: HAPROXY_BACKEND,
+        labels: { name: 'pxname' },
+        desc: 'Total weight of the servers in the backend.',
+        stats: [ { statName: 'weight' } ]
+    },
+    {
+        name: 'current_server',
+        type: 'gauge',
+        hpComponent: HAPROXY_BACKEND,
+        labels: { name: 'pxname' },
+        desc: 'Current number of active servers.',
+        stats: [ { statName: 'act' } ]
+    },
+    {
+        name: 'server_selected_total',
+        type: 'counter',
+        hpComponent: HAPROXY_BACKEND,
+        labels: { name: 'pxname' },
+        desc: 'Total number of times a server was selected, either ' +
+            'for new sessions, or when re-dispatching.',
+        stats: [ { statName: 'lbtot' } ]
+    },
+    {
+        name: 'current_session_rate',
+        type: 'gauge',
+        hpComponent: HAPROXY_BACKEND,
+        labels: { name: 'pxname' },
+        desc: 'Current number of sessions per second over last elapsed second.',
+        stats: [ { statName: 'rate' } ]
+    },
+    {
+        name: 'max_session_rate',
+        type: 'gauge',
+        hpComponent: HAPROXY_BACKEND,
+        labels: { name: 'pxname' },
+        desc: 'Maximum number of sessions per second.',
+        stats: [ { statName: 'rate_max' } ]
+    },
+    {
+        name: 'http_responses_total',
+        type: 'counter',
+        hpComponent: HAPROXY_BACKEND,
+        labels: { name: 'pxname' },
+        desc: 'Total of HTTP responses.',
+        stats: [
+            {
+                statName: 'hrsp_1xx',
+                labels: { code: '1xx' }
+            },
+            {
+                statName: 'hrsp_2xx',
+                labels: { code: '2xx' }
+            },
+            {
+                statName: 'hrsp_3xx',
+                labels: { code: '3xx' }
+            },
+            {
+                statName: 'hrsp_4xx',
+                labels: { code: '4xx' }
+            },
+            {
+                statName: 'hrsp_5xx',
+                labels: { code: '5xx' }
+            },
+            {
+                statName: 'hrsp_other',
+                labels: { code: 'other' }
+            }
+        ]
+    },
+    {
+        name: 'compressor_bytes_in_total',
+        type: 'counter',
+        hpComponent: HAPROXY_BACKEND,
+        labels: { name: 'pxname' },
+        desc: 'Number of HTTP response bytes fed to the compressor.',
+        stats: [ { statName: 'comp_in' } ]
+    },
+    {
+        name: 'compressor_bytes_out_total',
+        type: 'counter',
+        hpComponent: HAPROXY_BACKEND,
+        labels: { name: 'pxname' },
+        desc: 'Number of HTTP response bytes emitted by the compressor.',
+        stats: [ { statName: 'comp_out' } ]
+    },
+    {
+        name: 'compressor_bytes_bypassed_total',
+        type: 'counter',
+        hpComponent: HAPROXY_BACKEND,
+        labels: { name: 'pxname' },
+        desc: 'Number of bytes that bypassed the HTTP compressor.',
+        stats: [ { statName: 'comp_byp' } ]
+    },
+    {
+        name: 'http_responses_compressed_total',
+        type: 'counter',
+        hpComponent: HAPROXY_BACKEND,
+        labels: { name: 'pxname' },
+        desc: 'Number of HTTP responses that were compressed.',
+        stats: [ { statName: 'comp_rsp' } ]
+    },
+    {
+        name: 'http_queue_time_average_seconds',
+        type: 'gauge',
+        hpComponent: HAPROXY_BACKEND,
+        labels: { name: 'pxname' },
+        desc: 'Avg. HTTP queue time for last 1024 successful connections.',
+        stats: [ { statName: 'qtime' } ]
+    },
+    {
+        name: 'http_connect_time_average_seconds',
+        type: 'gauge',
+        hpComponent: HAPROXY_BACKEND,
+        labels: { name: 'pxname' },
+        desc: 'Avg. HTTP connect time for last 1024 successful connections.',
+        stats: [ { statName: 'ctime' } ]
+    },
+    {
+        name: 'http_response_time_average_seconds',
+        type: 'gauge',
+        hpComponent: HAPROXY_BACKEND,
+        labels: { name: 'pxname' },
+        desc: 'Avg. HTTP response time for last 1024 successful connections.',
+        stats: [ { statName: 'rtime' } ]
+    },
+    {
+        name: 'http_total_time_average_seconds',
+        type: 'gauge',
+        hpComponent: HAPROXY_BACKEND,
+        labels: { name: 'pxname' },
+        desc: 'Avg. HTTP total time for last 1024 successful connections.',
+        stats: [ { statName: 'ttime' } ]
+    },
+    // Server Metrics
+    {
+        name: 'current_queue',
+        type: 'gauge',
+        hpComponent: HAPROXY_SERVER,
+        labels: { name: 'pxname', address: 'addr' },
+        desc: 'Current number of queued requests assigned to this server.',
+        stats: [ { statName: 'qcur' } ]
+    },
+    {
+        name: 'max_queue',
+        type: 'gauge',
+        hpComponent: HAPROXY_SERVER,
+        labels: { name: 'pxname', address: 'addr' },
+        desc: 'Maximum observed number of ' +
+            'queued requests assigned to this server.',
+        stats: [ { statName: 'qmax'} ]
+    },
+    {
+        name: 'current_sessions',
+        type: 'gauge',
+        hpComponent: HAPROXY_SERVER,
+        labels: { name: 'pxname', address: 'addr' },
+        desc: 'Current number of active sessions.',
+        stats: [ { statName: 'scur' } ]
+    },
+    {
+        name: 'max_sessions',
+        type: 'gauge',
+        hpComponent: HAPROXY_SERVER,
+        labels: { name: 'pxname', address: 'addr' },
+        desc: 'Maximum observed number of active sessions.',
+        stats: [ { statName: 'smax' } ]
+    },
+    /*
+     * The current version of haproxy (1.8.20) doesn't
+     * support 'slim' statistic for servers. It will be
+     * exported when haproxy is upgraded to a newer version.
+     */
+    {
+        name: 'limit_sessions',
+        type: 'gauge',
+        hpComponent: HAPROXY_SERVER,
+        labels: { name: 'pxname', address: 'addr' },
+        desc: 'Configured session limit.',
+        stats: [ { statName: 'slim' } ]
+    },
+    {
+        name: 'sessions_total',
+        type: 'counter',
+        hpComponent: HAPROXY_SERVER,
+        labels: { name: 'pxname', address: 'addr' },
+        desc: 'Total number of sessions.',
+        stats: [ { statName: 'stot' } ]
+    },
+    {
+        name: 'bytes_in_total',
+        type: 'counter',
+        hpComponent: HAPROXY_SERVER,
+        labels: { name: 'pxname', address: 'addr' },
+        desc: 'Current total of incoming bytes.',
+        stats: [ { statName: 'bin' } ]
+    },
+    {
+        name: 'bytes_out_total',
+        type: 'counter',
+        hpComponent: HAPROXY_SERVER,
+        labels: { name: 'pxname', address: 'addr' },
+        desc: 'Current total of outgoing bytes.',
+        stats: [ { statName: 'bout' } ]
+    },
+    {
+        name: 'connection_errors_total',
+        type: 'counter',
+        hpComponent: HAPROXY_SERVER,
+        labels: { name: 'pxname', address: 'addr' },
+        desc: 'Total of connection errors.',
+        stats: [ { statName: 'econ' } ]
+    },
+    {
+        name: 'response_errors_total',
+        type: 'counter',
+        hpComponent: HAPROXY_SERVER,
+        labels: { name: 'pxname', address: 'addr' },
+        desc: 'Total of connection errors.',
+        stats: [ { statName: 'eresp' } ]
+    },
+    {
+        name: 'retry_warnings_total',
+        type: 'counter',
+        hpComponent: HAPROXY_SERVER,
+        labels: { name: 'pxname', address: 'addr' },
+        desc: 'Total of retry warnings.',
+        stats: [ { statName: 'wretr' } ]
+    },
+    {
+        name: 'redispatch_warnings_total',
+        type: 'counter',
+        hpComponent: HAPROXY_SERVER,
+        labels: { name: 'pxname', address: 'addr' },
+        desc: 'Total of redispatch warnings.',
+        stats: [ { statName: 'wredis' } ]
+    },
+    {
+        name: 'redispatch_warnings_total',
+        type: 'counter',
+        hpComponent: HAPROXY_SERVER,
+        labels: { name: 'pxname', address: 'addr' },
+        desc: 'Total of redispatch warnings.',
+        stats: [ { statName: 'wredis' } ]
+    },
+    {
+        name: 'up',
+        type: 'gauge',
+        hpComponent: HAPROXY_SERVER,
+        labels: { name: 'pxname', address: 'addr' },
+        desc: 'Current health status of the server (1 = UP, 0 = DOWN).',
+        stats: [ { statName: 'status', modifier: isUp } ]
+    },
+    {
+        name: 'weight',
+        type: 'gauge',
+        hpComponent: HAPROXY_SERVER,
+        labels: { name: 'pxname', address: 'addr' },
+        desc: 'Current weight of the server.',
+        stats: [ { statName: 'weight' } ]
+    },
+    {
+        name: 'check_failures_total',
+        type: 'counter',
+        hpComponent: HAPROXY_SERVER,
+        labels: { name: 'pxname', address: 'addr' },
+        desc: 'Total number of failed health checks.',
+        stats: [ { statName: 'chkfail' } ]
+    },
+    {
+        name: 'downtime_seconds_total',
+        type: 'counter',
+        hpComponent: HAPROXY_SERVER,
+        labels: { name: 'pxname', address: 'addr' },
+        desc: 'Total downtime in seconds.',
+        stats: [ { statName: 'downtime' } ]
+    },
+    {
+        name: 'server_selected_total',
+        type: 'counter',
+        hpComponent: HAPROXY_SERVER,
+        labels: { name: 'pxname', address: 'addr' },
+        desc: 'Total number of times a server was selected, ' +
+            'either for new sessions, or when re-dispatching.',
+        stats: [ { statName: 'lbtot' } ]
+    },
+    {
+        name: 'current_session_rate',
+        type: 'gauge',
+        hpComponent: HAPROXY_SERVER,
+        labels: { name: 'pxname', address: 'addr' },
+        desc: 'Current number of sessions per second ' +
+            'over last elapsed second.',
+        stats: [ { statName: 'rate' } ]
+    },
+    {
+        name: 'max_session_rate',
+        type: 'gauge',
+        hpComponent: HAPROXY_SERVER,
+        labels: { name: 'pxname', address: 'addr' },
+        desc: 'Maximum observed number of sessions per second.',
+        stats: [ { statName: 'rate_max' } ]
+    },
+    {
+        name: 'check_duration_milliseconds',
+        type: 'gauge',
+        hpComponent: HAPROXY_SERVER,
+        labels: { name: 'pxname', address: 'addr' },
+        desc: 'Previously run health check duration, in milliseconds.',
+        stats: [ { statName: 'check_duration' } ]
+    },
+    {
+        name: 'http_responses_total',
+        type: 'counter',
+        hpComponent: HAPROXY_SERVER,
+        labels: { name: 'pxname', address: 'addr' },
+        desc: 'Total of HTTP responses.',
+        stats: [
+            {
+                statName: 'hrsp_1xx',
+                labels: { code: '1xx' }
+            },
+            {
+                statName: 'hrsp_2xx',
+                labels: { code: '2xx' }
+            },
+            {
+                statName: 'hrsp_3xx',
+                labels: { code: '3xx' }
+            },
+            {
+                statName: 'hrsp_4xx',
+                labels: { code: '4xx' }
+            },
+            {
+                statName: 'hrsp_5xx',
+                labels: { code: '5xx' }
+            },
+            {
+                statName: 'hrsp_other',
+                labels: { code: 'other' }
+            }
+        ]
+    }
+];
+
+
+function MetricsExporter(opts) {
+    mod_assert.object(opts, 'opts');
+    mod_assert.object(opts.log, 'opts.log');
+    mod_assert.arrayOfString(opts.mantaIPS, 'opts.mantaIPS');
+    mod_assert.number(opts.metricsPort, 'opts.metricsPort');
+    mod_assert.ok(opts.mantaIPS.length > 0, 'opts.mantaIPS.length > 0');
+
+
+    var self = this;
+    self.log =  opts.log.child({component: 'metrics-exporter'});
+
+    self.server = mod_restify.createServer({
+        name: 'muppet-metrics-exporter',
+        log: self.log,
+        handleUncaughtExceptions: false,
+        handleUpgrades: false
+    });
+
+    self.server.use(function _addStandardRespHeaders(req, res, next) {
+        res.on('header', function onHeader() {
+            var now = Date.now();
+            res.header('Date', new Date());
+            res.header('Server', self.server.name);
+            res.header('x-request-id', req.getId());
+            var t = now - req.time();
+            res.header('x-response-time', t);
+            res.header('x-server-name', HOSTNAME);
+        });
+        req.metricExporter = self;
+        next();
+    });
+
+    self.server.use(mod_restify.plugins.requestLogger());
+
+    self.server.on('after', function audit(req, res, route, err) {
+        // Successful GET res bodies are uninteresting and *big*.
+        var body = !(req.method === 'GET' &&
+            Math.floor(res.statusCode / 100) === 2);
+
+        mod_restify.plugins.auditLogger({
+            log: req.log.child({
+                route: route && route.name,
+                action: req.query.action
+            }, true),
+            event: 'after',
+            body: body
+        })(req, res, route, err);
+    });
+
+    // Register /metrics handler
+    self.server.get('/metrics', getMetricsHandler);
+    self.address = opts.mantaIPS[0];
+    self.port = opts.metricsPort;
+}
+
+MetricsExporter.prototype.start = function (cb) {
+    var self = this;
+    mod_assert.optionalFunc(cb);
+    self.server.listen(self.port, self.address, cb);
+};
+
+MetricsExporter.prototype.close = function (cb) {
+    mod_assert.optionalFunc(cb);
+    this.server.close(cb);
+};
+
+function createMetricString(opts) {
+    mod_assert.object(opts, 'opts');
+    mod_assert.string(opts.metricName, 'opts.metricName');
+    mod_assert.string(opts.metricType, 'opts.metricType');
+    mod_assert.string(opts.metricDocString, 'opts.metricDocString');
+    mod_assert.arrayOfObject(opts.metricLabels, 'opts.metricLabels');
+    mod_assert.arrayOfString(opts.metricValues, 'opts.metricValues');
+    mod_assert.ok(opts.metricLabels.length === opts.metricValues.length,
+        'opts.metricLabels.length === opts.metricValues.length');
+
+    var metricString = '# HELP ' +
+        opts.metricName + ' ' + opts.metricDocString + '\n' +
+        '# TYPE ' + opts.metricName + ' ' + opts.metricType;
+
+    for (var i = 0; i < opts.metricLabels.length; i++) {
+        metricString += '\n';
+        metricString += (opts.metricName + '{');
+
+        var firstLabel = true;
+        Object.keys(opts.metricLabels[i]).forEach(function (key) {
+            var value = opts.metricLabels[i][key];
+
+            mod_assert.string(key, 'key');
+            mod_assert.ok(key.indexOf('"') === -1, 'key');
+            mod_assert.string(value, 'value');
+            mod_assert.ok(value.indexOf('"') === -1, 'value');
+
+            if (!firstLabel) {
+                metricString += ',';
+            }
+            firstLabel = false;
+
+            metricString += (key + '="' + value + '"');
+        });
+
+        metricString += '} ' + opts.metricValues[i];
+    }
+
+
+    return (metricString + '\n');
+}
+
+function getMetricsHandler(req, res, next) {
+
+    lib_hasock.allStats({log: this.log}, function _gotSrvStats(err, allStats) {
+        if (err) {
+            req.metricExporter.log.error(err);
+            next(err);
+            return;
+        }
+
+        var metricsString = '';
+        HAPROXY_METRICS.forEach(function _buildServerMetric(metric) {
+
+            var metricLabels = [];
+            var metricValues = [];
+            var componentName = haproxyComponentName(metric.hpComponent);
+
+            /*
+             * Filter out stats not related to this metric. This
+             * is needed because haproxy uses the same stat name
+             * for different components (fronend, backend, and server)
+             */
+            allStats.filter(function (stat) {
+                return (stat.type === metric.hpComponent);
+            }).forEach(function _serverStat(stat) {
+
+                // Populate metric labels
+                var labels = mod_jsprim.deepCopy(metric.labels);
+                Object.keys(labels).forEach(function (key) {
+                    labels[key] = stat[labels[key]] || '';
+                });
+
+                // Process stats in each metric
+                metric.stats.forEach(function _processMetricStats(metricStat) {
+                    var value = stat[metricStat.statName];
+                    if (value) {
+                        if (metricStat.modifier) {
+                            value = metricStat.modifier(value);
+                        }
+
+                        var metricStatLabels = mod_jsprim.mergeObjects(
+                            {'component': componentName, 'inst_id': HOSTNAME},
+                            labels, metricStat.labels);
+
+                        metricLabels.push(metricStatLabels);
+                        metricValues.push(value);
+                    }
+                });
+            });
+
+            // Strop processing this metric in case no stat has been found
+            if (metricValues.length === 0) {
+                return;
+            }
+
+            var metricName = 'muppet_' + componentName + '_' + metric.name;
+            var metricOpts = {
+                metricName: metricName,
+                metricType: metric.type,
+                metricDocString: metric.desc,
+                metricLabels: metricLabels,
+                metricValues: metricValues
+            };
+
+            metricsString += createMetricString(metricOpts);
+        });
+
+        res.header('content-type', 'text/plain');
+        res.send(metricsString);
+        next();
+    });
+}
+
+function createMetricsExporter(opts) {
+    return (new MetricsExporter(opts));
+}
+
+module.exports = {
+    createMetricsExporter: createMetricsExporter
+};
diff --git a/package.json b/package.json
index f598de6..78ce04f 100644
--- a/package.json
+++ b/package.json
@@ -1,7 +1,7 @@
 {
   "name": "muppet",
   "description": "Joyent's Load Balancer",
-  "version": "1.2.0",
+  "version": "1.3.0",
   "author": "Joyent (joyent.com)",
   "private": true,
   "dependencies": {
@@ -15,6 +15,7 @@
     "mooremachine": "2.3.0",
     "node-uuid": "1.4.1",
     "once": "1.4.0",
+    "restify": "5.0.0",
     "vasync": "2.2.0",
     "verror": "1.10.0",
     "zkstream": "0.11.8"
diff --git a/test/metrics_exports.test.js b/test/metrics_exports.test.js
new file mode 100644
index 0000000..b615093
--- /dev/null
+++ b/test/metrics_exports.test.js
@@ -0,0 +1,121 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright 2019 Joyent, Inc.
+ */
+
+/*jsl:ignore*/
+'use strict';
+/*jsl:end*/
+
+const metrics_exporter = require('../lib/metrics_exporter.js');
+const bunyan = require('bunyan');
+
+const helper = require('./helper.js');
+const http = require('http');
+const fs = require('fs');
+const tap = require('tap');
+
+var log = helper.createLogger();
+
+tap.beforeEach(function (cb, t) {
+    helper.startHaproxy(cb);
+});
+
+tap.afterEach(function (cb, t) {
+    helper.killHaproxy(cb);
+});
+
+tap.test('start and close metrics server', function (t) {
+    var opts = {
+        log: bunyan.createLogger({ name: 'dummy' }),
+        mantaIPS: ['127.0.0.1'],
+        metricsPort: 12421
+    };
+    var me = metrics_exporter.createMetricsExporter(opts);
+    me.start(function (err) {
+        if (err) {
+            t.fail(err);
+            return;
+        }
+        me.close(t.done);
+    });
+});
+
+
+const NUMBER_REG_EXP =
+    '[-+]?' +
+    '(?:[0-9]{0,30}\\.)?' +
+    '[0-9]{1,30}' +
+    '(?:[Ee][-+]?[1-2]?[0-9])?';
+
+tap.test('metrics server is producing valid metrics', function (t) {
+    var opts = {
+        log: bunyan.createLogger({ name: 'dummy' }),
+        mantaIPS: ['127.0.0.1'],
+        metricsPort: 12421
+    };
+
+    // XXX: This is not full validation by any means.
+    function validateMetrics(metrics) {
+        var lines = metrics.trim().split('\n');
+        var re = [
+            '(^# HELP \.*$)',
+            '(^# TYPE \.* (counter|gauge|histogram)$)',
+            '(^([\\w_]*) ' + NUMBER_REG_EXP + '$)',
+            '(^([\\w_]*)(\\{(.*)\\})? ' + NUMBER_REG_EXP + '$)'
+        ];
+
+        var regExp = new RegExp(re.join('|'));
+        var invalidMetrics = lines.some(function (line) {
+            if (regExp.test(line) === false) {
+                t.fail('Invalid Metric line: ' + line);
+                return (true);
+            }
+            return (false);
+        });
+
+        if (!invalidMetrics)
+            t.done();
+    }
+
+    var me = metrics_exporter.createMetricsExporter(opts);
+    me.start(function (err1) {
+        if (err1) {
+            t.fail(err1);
+            return;
+        }
+
+        var body = '';
+        var reqOpts = {
+            host: opts.mantaIPS[0],
+            port: opts.metricsPort,
+            path: '/metrics'
+        };
+
+        var req = http.request(reqOpts, function (res) {
+            res.on('data', function (chunk) {
+                body += chunk;
+            });
+
+            res.on('end', function () {
+                me.close(function (err2) {
+                    if (err2) {
+                        t.fail(err2);
+                        return;
+                    }
+                    validateMetrics(body);
+                });
+            });
+        });
+
+        req.on('error', function (err2) {
+             me.close(function () { t.fail(err2); });
+        });
+        req.end();
+    });
+});
-- 
2.21.0

