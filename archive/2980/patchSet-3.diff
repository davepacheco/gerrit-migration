From 1e2135ce727fbbf5067e81463a388045df8d1c7a Mon Sep 17 00:00:00 2001
From: Alex Wilson <alex.wilson@joyent.com>
Date: Wed, 15 Nov 2017 15:18:01 -0800
Subject: [PATCH] PUBAPI-804 Provide access to KVM Console for end users

---
 docs/index.md        |  97 ++++++++++++--
 lib/app.js           |   6 +
 lib/auth.js          | 125 +++++++++++++++++-
 lib/endpoints/vnc.js | 304 +++++++++++++++++++++++++++++++++++++++++++
 package.json         |  41 +++---
 test/auth.test.js    |  99 ++++++++++++++
 6 files changed, 644 insertions(+), 28 deletions(-)
 create mode 100644 lib/endpoints/vnc.js

diff --git a/docs/index.md b/docs/index.md
index 74592f3..1244366 100644
--- a/docs/index.md
+++ b/docs/index.md
@@ -712,21 +712,25 @@ JSON in the body:
 
 ### Authorization
 
-All API calls to CloudAPI require an Authorization header, which supports
-multiple ["schemes"](http://tools.ietf.org/html/rfc2617).  Currently CloudAPI
-supports only one Authentication mechanism due to PCI compliance restrictions:
+All API calls to CloudAPI require an Authorization header or signature, which
+supports multiple ["schemes"](http://tools.ietf.org/html/rfc2617).  Currently
+CloudAPI supports only one Authentication mechanism due to PCI compliance
+restrictions:
 
 * HTTP Signature Authentication Scheme.  This Scheme is outlined in
 [Appendix C](#Appendix-C).
 
-In order to leverage HTTP Signature Authentication, only RSA signing mechanisms
-are supported, and your keyId must be equal to the path returned from a
-[ListKeys](#ListKeys) API call.  For example, if your Triton login is `demo`,
-and you've uploaded an RSA SSH key with the name `foo`, an Authorization
-header would look like:
+In order to leverage HTTP Signature Authentication, only RSA and ECDSA signing
+mechanisms are supported, and your keyId must be equal to the path returned
+from a [ListKeys](#ListKeys) API call.  For example, if your Triton login is
+`demo`, and you've uploaded an RSA SSH key with the name `foo`, an
+Authorization header would look like:
 
     Authorization: Signature keyId=/demo/keys/foo,algorithm="rsa-sha256" ${Base64(sign($Date))}
 
+It is also permissible to use the full MD5 fingerprint of the key (in the
+standard colon-separated hexadecimal format) in place of the name `foo`.
+
 The default value to sign for CloudAPI requests is simply the value of the HTTP
 `Date` header.  For more information on the Date header value, see
 [RFC 2616](http://tools.ietf.org/html/rfc2616#section-14.18).  All requests to
@@ -740,6 +744,41 @@ in the npm `http-signature` module, which you can install with:
 
     npm install http-signature
 
+### Pre-signed URLs
+
+In common with Manta, CloudAPI (as of API version 8.4.0) also supports the use
+of pre-signed URLs to authenticate requests.  This is particularly useful with
+endpoints that upgrade to a WebSocket, as many WebSocket client implementations
+do not support setting custom headers (such as `Authorization`).
+
+Pre-signed URLs use a public-key signature in the same manner as the HTTP
+Signature scheme above, but the string to be signed is formatted differently:
+
+    $method[,$method2]\n
+    $http_host\n
+    $request_uri\n
+    key=val&...
+
+The `algorithm`, `expires`, `keyId`, `signature` (Base64-encoded) and
+optionally the list of `method` values, are given as query string parameters
+to the endpoint.
+
+Unlike HTTP signature, which signs the current `Date` and implicitly allows use
+only a set time into the future (to account for clock skew), pre-signed URLs
+are valid up until an arbitrary future expiry date.  The `expires` field is a
+positive integer containing the UNIX timestamp at which the signature should
+become invalid.
+
+The list of permissible `method` values is optional -- if not given, the
+signature will be validated against the signing string with just the request's
+actual HTTP method in its place.  If it is given, the list must include the
+request's actual HTTP method in order to be valid.
+
+The set of `key=val` query string encoded pairs should be lexicographically
+sorted by the `key`, and must include all query parameters to the endpoint
+(including parameters related to signing) other than `signature`. Note that
+this may mean including the list of `method` values in the string twice.
+
 ### Using cURL with CloudAPI
 
 Since [cURL](http://curl.haxx.se/) is commonly used to script requests to web
@@ -901,6 +940,13 @@ The set of supported *API versions* is given in the ping endpoint:
 
 The section describes API changes in CloudAPI versions.
 
+## 8.4.0
+
+- New endpoint, ConnectMachineVNC, which allows the use of a WebSocket to
+  connect to the VNC console of a KVM.
+- Support for pre-signed URLs for authentication (needed to make WebSockets
+  useable with browsers).
+
 ## 8.3.0
 
 - CreateMachine supports a new `affinity` field for specifying affinity rules.
@@ -4717,6 +4763,41 @@ or
     Transfer-Encoding: chunked
 
 
+## ConnectMachineVNC (GET /:login/machines/:id/vnc)
+
+Connects a websocket to the VNC console of a KVM instance.
+
+Returns an error if used on any non-KVM instance, or any instance that is not
+currently running.
+
+### Inputs
+
+* WebSocket upgrade headers
+
+### Returns
+
+* Upgrades to a WebSocket, which carries the VNC traffic in binary frames.
+  Accepts the subprotocol names `rfb` and `binary`. This is compatible with
+  e.g. the noVNC client.
+
+### Errors
+
+For all possible errors, see [CloudAPI HTTP Responses](#cloudapi-http-responses).
+
+**Error Code**   | **Description**
+---------------- | ---------------
+ResourceNotFound | If `:login` or `:id` does not exist
+MachineHasNoVNC  | If `:id` refers to a non-KVM VM with no VNC console
+MachineStopped   | If `:id` is not running
+UpgradeRequired  | If the WebSocket upgrade headers are missing or malformed
+
+### Notes
+
+It is recommended to use pre-signed URLs for authentication with this endpoint,
+as many WebSocket clients do not support sending custom HTTP headers with the
+Upgrade request.
+
+
 ## ResizeMachine (POST /:login/machines/:id?action=resize)
 
 Resize an instance to a new [package](#packages) (a.k.a. instance type).
diff --git a/lib/app.js b/lib/app.js
index 11802d1..bafe906 100644
--- a/lib/app.js
+++ b/lib/app.js
@@ -56,6 +56,7 @@ var auditLogger = require('./audit_logger');
 var rules = require('./rules');
 var tests = require('./tests');
 var volumeEndpoints = require('./endpoints/volumes');
+var vnc = require('./endpoints/vnc');
 
 // Account users, roles and policies:
 var users = require('./users');
@@ -465,6 +466,8 @@ module.exports = {
                     plugins = loadPlugins(config.plugins, pluginsCfg, log);
                 }
 
+                config.handleUpgrades = true;
+
                 server = restify.createServer(config);
 
                 server.use(restify.acceptParser(server.acceptable));
@@ -528,6 +531,7 @@ module.exports = {
                 });
 
                 // Run authentication and authorization before everything else
+                server.use(auth.preSignedUrl);
                 server.use(auth.signatureAuth);
                 server.use(auth.tokenAuth);
                 server.use(auth.assertAuthenticated);
@@ -663,6 +667,8 @@ module.exports = {
                 audit.mount(server, machineThrottle);
                 rules.mount(server, machineThrottle);
 
+                vnc.mount(server, machineThrottle);
+
                 analytics.mount(server, userThrottle(config, 'analytics'));
                 users.mount(server, userThrottle(config, 'users'), config);
                 policies.mount(server, userThrottle(config, 'policies'),
diff --git a/lib/auth.js b/lib/auth.js
index 24a64c6..d406c59 100644
--- a/lib/auth.js
+++ b/lib/auth.js
@@ -51,6 +51,7 @@ var httpSig = require('http-signature');
 var restify = require('restify');
 var semver = require('semver');
 var vasync = require('vasync');
+var jsprim = require('jsprim');
 
 ///--- Globals
 
@@ -660,6 +661,127 @@ function authorize(req, res, next) {
 }
 
 
+function preSignedUrl(req, res, next) {
+    var expires;
+    var log = req.log;
+    var q = req.query;
+    /* JSSTYLED */
+    var methods = (q.method || req.method).split(/\s*,\s*/);
+    var now = Math.floor(Date.now()/1000);
+
+    methods.sort();
+
+    log.debug('preSignedUrl: entered');
+
+    if (methods.indexOf(req.method) === -1) {
+        next(new Error(req.method + ' was not a signed method'));
+        return;
+    }
+
+    /* All of these are required fields for this to be a valid presigned URL. */
+    var missing = [
+        'algorithm',
+        'expires',
+        'keyId',
+        'signature'].filter(function isMissing(k) {
+            return (!q[k]);
+        });
+
+    /*
+     * If we're missing _all_ of the required fields, assume this isn't a pre-
+     * signed URL and continue processing.
+     *
+     * If we're missing some of the fields but have at least 1, then assume the
+     * user meant to supply a pre-signed URL but some fields are missing. This
+     * is an error.
+     */
+    if (missing.length > 1) {
+        next();
+        return;
+    } else if (missing.length > 0) {
+        next(new Error('parameters "' + missing.join(', ') + '" are required'));
+        return;
+    }
+
+    expires = jsprim.parseInteger(q.expires, { allowSign: false });
+    if (typeof (expires) !== 'number') {
+        log.debug(expires, 'error parsing "expires" in pre-signed URL');
+        next(new Error('expires is invalid'));
+        return;
+    }
+
+    log.debug({
+        expires: expires,
+        now: now
+    }, 'checking if request is expired');
+    if (now > expires) {
+        next(new Error('request expired'));
+        return;
+    }
+
+    var parsed = {
+        scheme: 'Signature',
+        algorithm: q.algorithm.toUpperCase(),
+        keyId: q.keyId,
+        params: {
+            keyId: q.keyId,
+            signature: q.signature,
+            role: q.role,
+            'role-tag': q['role-tag']
+        },
+        signature: q.signature,
+        signingString: ''
+    };
+
+    // Build the signing string, which is:
+    // METHOD\n
+    // $value_of_host_header
+    // REQUEST_URL\n
+    // key=val&...
+    // with sorted query params (lexicographically),
+    // minus the actual signature.
+    parsed.signingString =
+        methods.join(',') + '\n' +
+        req.header('host') + '\n' +
+        req.path() + '\n' +
+        Object.keys(q).sort(function sortQueryParams(a, b) {
+            return (a.localeCompare(b));
+        }).filter(function isNotSignature(k) {
+            return (k.toLowerCase() !== 'signature');
+        }).map(function convertToRFC3986(k) {
+            return (rfc3986(k) + '=' + rfc3986(q[k]));
+        }).join('&');
+
+    log.debug({signatureOptions: parsed}, 'preSignedUrl: parsed');
+
+    if (SIGN_ALGOS[parsed.algorithm] !== true) {
+        next(new Error(parsed.algorithm + ' is not a supported signing ' +
+            'algorithm'));
+        return;
+    }
+
+    req.authorization = {
+        role: q.role || '',
+        'role-tag': q['role-tag'] || '',
+        callerKey: q.keyId,
+        scheme: parsed.scheme,
+        signature: parsed
+    };
+
+    log.debug({auth: req.auth}, 'preSignedUrl: done');
+    next();
+}
+
+function rfc3986(str) {
+    /* JSSTYLED */
+    return (encodeURIComponent(str)
+            /* JSSTYLED */
+            .replace(/[!'()]/g, escape)
+            /* JSSTYLED */
+            .replace(/\*/g, '%2A'));
+}
+
+
 ///--- Exports
 
 module.exports = {
@@ -668,5 +790,6 @@ module.exports = {
     assertAuthenticated: assertAuthenticated,
     loadAccount: loadAccount,
     authnAllowedDcs: authnAllowedDcs,
-    authorize: authorize
+    authorize: authorize,
+    preSignedUrl: preSignedUrl
 };
diff --git a/lib/endpoints/vnc.js b/lib/endpoints/vnc.js
new file mode 100644
index 0000000..1e88772
--- /dev/null
+++ b/lib/endpoints/vnc.js
@@ -0,0 +1,304 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+
+var assert = require('assert-plus');
+var jsprim = require('jsprim');
+var restify = require('restify');
+var schemas = require('joyent-schemas').cloudapi;
+var util = require('util');
+var vasync = require('vasync');
+var watershed = require('watershed');
+var mooremachine = require('mooremachine');
+var net = require('net');
+
+var shed = new watershed.Watershed();
+
+function mount(server, before, pre) {
+    assert.object(server, 'server');
+    assert.ok(before, 'before');
+    assert.optionalArrayOfFunc(pre, 'pre');
+
+    pre = pre || [];
+
+    server.get({
+        path: '/:account/machines/:machine/vnc',
+        name: 'ConnectMachineVNC',
+        version: [ '8.4.0' ]
+    }, before, connectVNC);
+
+    return server;
+}
+
+function connectVNC(req, res, next) {
+    var vm = req.machine;
+    if (vm.brand !== 'kvm') {
+        res.send(400, new restify.RestError({
+            statusCode: 400,
+            restCode: 'MachineHasNoVNC',
+            message: 'Specified machine does not have a VNC console'
+        }));
+        next();
+        return;
+    }
+    if (vm.state !== 'running') {
+        res.send(400, new restify.RestError({
+            statusCode: 400,
+            restCode: 'MachineStopped',
+            message: 'Specified machine is stopped and cannot be connected to'
+        }));
+        next();
+        return;
+    }
+    if (!res.claimUpgrade) {
+        res.send(400, new restify.RestError({
+            statusCode: 400,
+            restCode: 'UpgradeRequired',
+            message: 'VNC connect endpoint is a websocket and must be Upgraded'
+        }));
+        next();
+        return;
+    }
+
+    /*
+     * Since cloudapi still runs with restify request domains enabled, we need
+     * to exit that domain here if we want any errors in the VNC FSM to be
+     * reported sensibly (since the request will end from restify's
+     * perspective once we send the 101).
+     *
+     * This can be removed once domains and the uncaughtException handler are
+     * turned off for cloudapi.
+     */
+    var reqdom = process.domain;
+    reqdom.exit();
+
+    var fsm = new VNCConnectionFSM();
+    fsm.handle(req, res, next);
+
+    reqdom.enter();
+}
+
+
+function VNCConnectionFSM() {
+    this.req = undefined;
+    this.res = undefined;
+    this.next = undefined;
+    this.err = undefined;
+    this.log = undefined;
+    this.upgrade = undefined;
+    this.ws = undefined;
+    this.socket = undefined;
+    this.host = undefined;
+    this.port = undefined;
+
+    mooremachine.FSM.call(this, 'init');
+}
+
+util.inherits(VNCConnectionFSM, mooremachine.FSM);
+
+VNCConnectionFSM.prototype.state_init = function state_init(S) {
+    S.on(this, 'handleAsserted', function handleAsserted() {
+        S.gotoState('upgrade');
+    });
+};
+
+VNCConnectionFSM.prototype.state_reject = function state_rejectsock(S) {
+    var err = new restify.InternalServerError();
+    var code = err.statusCode;
+    var data = JSON.stringify(err.body);
+    this.upgrade.socket.write('HTTP/1.1 ' + code + ' Upgrade Rejected\r\n' +
+        'Connection: close\r\n' +
+        'Content-Type: application/json\r\n' +
+        'Content-Length: ' + data.length + '\r\n\r\n');
+    this.upgrade.socket.end(data);
+    this.next();
+};
+
+VNCConnectionFSM.prototype.state_upgrade = function state_upgrade(S) {
+    try {
+        this.upgrade = this.res.claimUpgrade();
+        /*
+         * Since VNC prefers low latency over high bandwidth, disable Nagle's
+         * algorithm. This means that small data packets (e.g. mouse movements
+         * or key presses) will be sent immediately instead of waiting for
+         * further data.
+         */
+        this.upgrade.socket.setNoDelay(true);
+
+        this.ws = shed.accept(this.req, this.upgrade.socket, this.upgrade.head,
+            false, ['binary', 'rfb']);
+    } catch (ex) {
+        this.log.error(ex, 'websocket upgrade failed');
+        S.gotoState('reject');
+        return;
+    }
+    /*
+     * From restify's perspective, the HTTP request ends here. We set the
+     * statusCode so that the audit logs show that we upgraded to websockets.
+     */
+    this.res.statusCode = 101;
+    this.next();
+
+    /* Now we continue on to use the websocket. */
+    S.gotoState('getport');
+};
+
+VNCConnectionFSM.prototype.state_getport = function state_getport(S) {
+    var vm = this.req.machine;
+    var uri = '/servers/' + vm.compute_node + '/vms/' + vm.id + '/vnc';
+    var self = this;
+    this.req.sdc.cnapi.get(uri, S.callback(function gotVNCDetails(err, obj) {
+        if (err) {
+            self.log.error(err, 'failed to fetch VM VNC details from CNAPI');
+            self.err = new restify.InternalServerError('Failed to retrieve ' +
+                'VNC socket details');
+            S.gotoState('error');
+            return;
+        }
+        if (typeof (obj.host) !== 'string' || typeof (obj.port) !== 'number') {
+            self.log.error({ obj: obj }, 'CNAPI returned invalid VM VNC obj');
+            self.err = new restify.InternalServerError('Failed to retrieve ' +
+                'VNC socket details');
+            S.gotoState('error');
+            return;
+        }
+        self.host = obj.host;
+        self.port = obj.port;
+        self.log = self.log.child({ vncHost: obj.host, vncPort: obj.port });
+        self.log.debug('cnapi returned address for vnc');
+        S.gotoState('connect');
+    }));
+    S.on(this.ws, 'error', function onWsError(err) {
+        S.gotoState('error');
+    });
+};
+
+VNCConnectionFSM.prototype.state_error = function state_error(S) {
+    this.log.warn(this.err, 'vnc connection exited with error');
+    if (this.ws) {
+        try {
+            this.ws.end(JSON.stringify({ type: 'error', error: this.err }));
+        } catch (ex) {
+            this.ws.destroy();
+        }
+    }
+    if (this.socket) {
+        this.socket.destroy();
+    }
+};
+
+VNCConnectionFSM.prototype.state_connect = function state_connect(S) {
+    var self = this;
+
+    S.on(this.ws, 'error', function connectWsError(err) {
+        self.err = err;
+        S.gotoState('error');
+    });
+    S.on(this.ws, 'end', function connectWsEnd() {
+        S.gotoState('error');
+    });
+
+    this.socket = net.createConnection({
+        allowHalfOpen: true,
+        host: this.host,
+        port: this.port
+    });
+
+    S.on(this.socket, 'connect', function connected() {
+        S.gotoState('connected');
+    });
+    S.on(this.socket, 'error', function connectSockErr(err) {
+        self.log.error(err, 'failed to connect to VNC endpoint');
+        self.err = new restify.InternalServerError('Failed to connect to ' +
+                'VNC server');
+        S.gotoState('error');
+    });
+    S.timeout(5000, function connectTimeout() {
+        self.log.error('timeout while connecting to VNC endpoint');
+        self.err = new restify.InternalServerError('Timeout while connecting ' +
+            'to VNC server');
+        S.gotoState('error');
+    });
+};
+
+VNCConnectionFSM.prototype.state_connected = function state_connected(S) {
+    var self = this;
+    this.socket.setNoDelay(true);
+
+    S.on(this.ws, 'error', function vncWsError(err) {
+        self.log.error(err, 'error on websocket connection to client');
+        self.err = err;
+        S.gotoState('error');
+    });
+    S.on(this.ws, 'end', function vncWsEnd() {
+        S.gotoState('ws_ended');
+    });
+    S.on(this.ws, 'connectionReset', function vncWsReset() {
+        S.gotoState('ws_ended');
+    });
+
+    S.on(this.socket, 'end', function vncSockEnd() {
+        S.gotoState('sock_ended');
+    });
+    S.on(this.socket, 'error', function vncSockErr(err) {
+        self.log.error(err, 'error on VNC connection');
+        S.gotoState('error');
+    });
+
+    S.on(this.ws, 'binary', function vncWsGotData(buf) {
+        self.socket.write(buf);
+    });
+    S.on(this.socket, 'readable', function vncSockGotData() {
+        var buf;
+        while ((buf = self.socket.read()) !== null) {
+            self.ws.send(buf);
+        }
+    });
+};
+
+VNCConnectionFSM.prototype.state_ws_ended = function state_ws_ended(S) {
+    S.on(this.socket, 'close', function vncSockClose() {
+        S.gotoState('closed');
+    });
+    S.timeout(5000, function vncSockCloseTimeout() {
+        S.gotoState('error');
+    });
+    this.socket.end();
+    this.socket = null;
+};
+
+VNCConnectionFSM.prototype.state_sock_ended = function state_sock_ended(S) {
+    this.ws.end('Remote connection closed');
+    this.ws = null;
+    S.gotoState('closed');
+};
+
+VNCConnectionFSM.prototype.state_closed = function state_closed(S) {
+    if (this.socket) {
+        this.socket.destroy();
+    }
+    this.socket = null;
+    if (this.ws) {
+        this.ws.destroy();
+    }
+    this.ws = null;
+};
+
+VNCConnectionFSM.prototype.handle = function handle(req, res, next) {
+    this.req = req;
+    this.res = res;
+    this.next = next;
+    this.log = this.req.log.child({ component: 'VNCConnectionFSM' });
+
+    this.emit('handleAsserted');
+};
+
+module.exports = {
+    mount: mount
+};
diff --git a/package.json b/package.json
index bb23cae..cbcd5af 100644
--- a/package.json
+++ b/package.json
@@ -13,38 +13,41 @@
         "url": "git+ssh://git@github.com:joyent/sdc-cloudapi.git"
     },
     "dependencies": {
-        "vasync": "1.6.4",
+        "aperture": "git+https://github.com/joyent/node-aperture.git#016977",
+        "aperture-config": "git+https://github.com/joyent/aperture-config.git#master",
+        "asn1": "0.1.11",
+        "assert-plus": "1.0.0",
+        "bunyan": "1.8.1",
+        "clone": "0.1.5",
+        "ctype": "0.5.2",
+        "cueball": "2.1.1",
         "filed": "0.0.7",
         "http-signature": "1.1.0",
-        "mime": "1.2.7",
+        "joyent-schemas": "git+https://github.com/joyent/schemas.git#caf3a226ed0707f5da897e1da151cc6d97fccda2",
+        "jsprim": "2.0.0",
+        "kang": "1.1.0",
+        "keyapi": "git+https://github.com/joyent/keyapi.git#e14b3d582e1d9d338b7082d61f34ba8d1bbc540a",
+        "krill": "1.0.1",
         "libuuid": "0.2.1",
+        "mahi": "2.0.1",
+        "mime": "1.2.7",
+        "mooremachine": "^2.2.0",
+        "nodemailer": "0.3.29",
         "nopt": "2.0.0",
         "restify": "4.3.0",
-        "bunyan": "1.8.1",
-        "cueball": "2.1.1",
-        "kang": "1.1.0",
-        "krill": "1.0.1",
         "sdc-clients": "10.4.0",
-        "ufds": "1.3.0",
         "semver": "5.4.1",
-        "nodemailer": "0.3.29",
-        "clone": "0.1.5",
-        "assert-plus": "1.0.0",
-        "asn1": "0.1.11",
-        "ctype": "0.5.2",
-        "keyapi": "git+https://github.com/joyent/keyapi.git#e14b3d582e1d9d338b7082d61f34ba8d1bbc540a",
-        "aperture": "git+https://github.com/joyent/node-aperture.git#016977",
-        "mahi": "2.0.1",
-        "aperture-config": "git+https://github.com/joyent/aperture-config.git#master",
-        "joyent-schemas": "git+https://github.com/joyent/schemas.git#caf3a226ed0707f5da897e1da151cc6d97fccda2",
-        "jsprim": "0.6.1",
         "strsplit": "1.0.0",
+        "ufds": "1.3.0",
+        "vasync": "1.6.4",
         "verror": "1.10.0",
+        "watershed": "0.4.0",
         "xregexp": "3.1.0"
     },
     "devDependencies": {
         "tape": "3.5.0",
-        "smartdc": "8.1.0"
+        "smartdc": "8.1.0",
+        "sshpk": "1.13.1"
     },
     "sdcDependencies": {
         "imgapi": ">=2.1.0",
diff --git a/test/auth.test.js b/test/auth.test.js
index 66b2568..406b74a 100644
--- a/test/auth.test.js
+++ b/test/auth.test.js
@@ -14,6 +14,9 @@ var Keyapi = require('keyapi');
 var test = require('tape').test;
 var restify = require('restify');
 var vasync = require('vasync');
+var url = require('url');
+var sshpk = require('sshpk');
+var qs = require('querystring');
 
 var common = require('./common');
 var checkNotFound = common.checkNotFound;
@@ -72,6 +75,102 @@ test('signature auth', function (t) {
 });
 
 
+test('pre-signed url', function (t) {
+    var key = sshpk.parsePrivateKey(CLIENT.privateKey);
+    var path = '/my/keys';
+    var host = url.parse(SERVER.url).host;
+
+    var params = {};
+    params.algorithm = key.type + '-' + key.defaultHashAlgorithm();
+    params.expires = Math.round(Date.now() / 1000) + 300;
+    params.keyId = CLIENT.keyId;
+
+    var signstr = 'GET\n' + host + '\n' + path + '\n' + qs.stringify(params);
+    var signer = key.createSign();
+    signer.update(signstr);
+    params.signature = signer.sign().toString();
+
+    path += '?' + qs.stringify(params);
+
+    CLIENT.get(path, function (err, req, res, body) {
+        t.ifError(err);
+        t.equal(res.statusCode, 200);
+        common.checkHeaders(t, res.headers);
+        t.ok(body);
+        t.ok(Array.isArray(body));
+        t.ok(body.length);
+        t.end();
+    });
+});
+
+test('pre-signed url - expired', function (t) {
+    var key = sshpk.parsePrivateKey(CLIENT.privateKey);
+    var path = '/my/keys';
+    var host = url.parse(SERVER.url).host;
+
+    var params = {};
+    params.algorithm = key.type + '-' + key.defaultHashAlgorithm();
+    params.expires = Math.round(Date.now() / 1000) - 300;
+    params.keyId = CLIENT.keyId;
+
+    var signstr = 'GET\n' + host + '\n' + path + '\n' + qs.stringify(params);
+    var signer = key.createSign();
+    signer.update(signstr);
+    params.signature = signer.sign().toString();
+
+    path += '?' + qs.stringify(params);
+
+    CLIENT.get(path, function (err, req, res, body) {
+        t.ok(err);
+        t.end();
+    });
+});
+
+test('pre-signed url - missing params', function (t) {
+    var key = sshpk.parsePrivateKey(CLIENT.privateKey);
+    var path = '/my/keys';
+    var host = url.parse(SERVER.url).host;
+
+    var params = {};
+    params.expires = Math.round(Date.now() / 1000) + 300;
+    params.keyId = CLIENT.keyId;
+
+    var signstr = 'GET\n' + host + '\n' + path + '\n' + qs.stringify(params);
+    var signer = key.createSign();
+    signer.update(signstr);
+    params.signature = signer.sign().toString();
+
+    path += '?' + qs.stringify(params);
+
+    CLIENT.get(path, function (err, req, res, body) {
+        t.ok(err);
+        t.end();
+    });
+});
+
+test('pre-signed url - wrong host', function (t) {
+    var key = sshpk.parsePrivateKey(CLIENT.privateKey);
+    var path = '/my/keys';
+    var host = 'invalid.host.example.com';
+
+    var params = {};
+    params.algorithm = key.type + '-' + key.defaultHashAlgorithm();
+    params.expires = Math.round(Date.now() / 1000) + 300;
+    params.keyId = CLIENT.keyId;
+
+    var signstr = 'GET\n' + host + '\n' + path + '\n' + qs.stringify(params);
+    var signer = key.createSign();
+    signer.update(signstr);
+    params.signature = signer.sign().toString();
+
+    path += '?' + qs.stringify(params);
+
+    CLIENT.get(path, function (err, req, res, body) {
+        t.ok(err);
+        t.end();
+    });
+});
+
 // http-signature 0.10.x test
 var httpSignature = require('http-signature');
 function requestSigner(req) {
-- 
2.21.0

