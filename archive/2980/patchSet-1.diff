commit 1b85af3f37f6e2f84b3d00127b88e671eccb4f77
Author: Alex Wilson <alex.wilson@joyent.com>
Date:   2017-11-21T16:01:42-08:00 (1 year, 11 months ago)
    
    PUBAPI-804 Provide access to KVM Console for end users

diff --git a/lib/app.js b/lib/app.js
index 2d150fd69..a4686fb78 100644
--- a/lib/app.js
+++ b/lib/app.js
@@ -56,6 +56,7 @@ var auditLogger = require('./audit_logger');
 var rules = require('./rules');
 var tests = require('./tests');
 var volumeEndpoints = require('./endpoints/volumes');
+var vnc = require('./endpoints/vnc');
 
 // Account users, roles and policies:
 var users = require('./users');
@@ -465,6 +466,8 @@ module.exports = {
                     plugins = loadPlugins(config.plugins, pluginsCfg, log);
                 }
 
+                config.handleUpgrades = true;
+
                 server = restify.createServer(config);
 
                 server.use(restify.acceptParser(server.acceptable));
@@ -528,6 +531,7 @@ module.exports = {
                 });
 
                 // Run authentication and authorization before everything else
+                server.use(auth.preSignedUrl);
                 server.use(auth.signatureAuth);
                 server.use(auth.tokenAuth);
                 server.use(auth.assertAuthenticated);
@@ -663,6 +667,8 @@ module.exports = {
                 audit.mount(server, machineThrottle);
                 rules.mount(server, machineThrottle);
 
+                vnc.mount(server, machineThrottle);
+
                 analytics.mount(server, userThrottle(config, 'analytics'));
                 users.mount(server, userThrottle(config, 'users'), config);
                 policies.mount(server, userThrottle(config, 'policies'),
diff --git a/lib/auth.js b/lib/auth.js
index 24a64c6e5..f1ebe44e1 100644
--- a/lib/auth.js
+++ b/lib/auth.js
@@ -660,6 +660,118 @@ function authorize(req, res, next) {
 }
 
 
+function preSignedUrl(req, res, next) {
+    var expires;
+    var log = req.log;
+    /* JSSTYLED */
+    var methods = (req.query.method || req.method).split(/\s*,\s*/);
+    var now = Math.floor(Date.now()/1000);
+
+    methods.sort();
+
+    log.debug('preSignedUrl: entered');
+
+    if (methods.indexOf(req.method) === -1) {
+        next(new Error(req.method + ' was not a signed method'));
+        return;
+    }
+
+    var missing = [
+        'algorithm',
+        'expires',
+        'keyId',
+        'signature'].filter(function (k) {
+            return (!req.query[k]);
+        });
+
+    if (missing.length > 1) {
+        next();
+        return;
+    } else if (missing.length > 0) {
+        next(new Error('parameters "' + missing.join(', ') + '" are required'));
+        return;
+    }
+
+    try {
+        expires = parseInt(req.query.expires, 10);
+    } catch (e) {
+        next(new Error('expires is invalid'));
+        return;
+    }
+
+    log.debug({
+        expires: expires,
+        now: now
+    }, 'checking if request is  expired');
+    if (now > expires) {
+        next(new Error('request expired'));
+        return;
+    }
+
+
+    var parsed = {
+        scheme: 'Signature',
+        algorithm: req.query.algorithm.toUpperCase(),
+        keyId: req.query.keyId,
+        params: {
+            keyId: req.query.keyId,
+            signature: req.query.signature,
+            role: req.query.role,
+            'role-tag': req.query['role-tag']
+        },
+        signature: req.query.signature,
+        signingString: ''
+    };
+
+    // Build the signing string, which is:
+    // METHOD\n
+    // $value_of_host_header
+    // REQUEST_URL\n
+    // key=val&...
+    // with sorted query params (lexicographically),
+    // minus the actual signature.
+    parsed.signingString =
+        methods.join(',') + '\n' +
+        req.header('host') + '\n' +
+        req.path() + '\n' +
+        Object.keys(req.query).sort(function (a, b) {
+            return (a.localeCompare(b));
+        }).filter(function (k) {
+            return (k.toLowerCase() !== 'signature');
+        }).map(function (k) {
+            return (rfc3986(k) + '=' + rfc3986(req.query[k]));
+        }).join('&');
+
+    log.debug({signatureOptions: parsed}, 'preSignedUrl: parsed');
+
+    if (SIGN_ALGOS[parsed.algorithm] !== true) {
+        next(new Error(parsed.algorithm + ' is not a supported signing ' +
+            'algorithm'));
+        return;
+    }
+
+    req.authorization = {
+        role: req.query.role || '',
+        'role-tag': req.query['role-tag'] || '',
+        callerKey: req.query.keyId,
+        scheme: parsed.scheme,
+        signature: parsed
+    };
+
+    log.debug({auth: req.auth}, 'preSignedUrl: done');
+    next();
+}
+
+function rfc3986(str) {
+    /* JSSTYLED */
+    return (encodeURIComponent(str)
+            /* JSSTYLED */
+            .replace(/[!'()]/g, escape)
+            /* JSSTYLED */
+            .replace(/\*/g, '%2A'));
+}
+
+
 ///--- Exports
 
 module.exports = {
@@ -668,5 +780,6 @@ module.exports = {
     assertAuthenticated: assertAuthenticated,
     loadAccount: loadAccount,
     authnAllowedDcs: authnAllowedDcs,
-    authorize: authorize
+    authorize: authorize,
+    preSignedUrl: preSignedUrl
 };
diff --git a/lib/endpoints/vnc.js b/lib/endpoints/vnc.js
new file mode 100644
index 000000000..fdd8b8287
--- /dev/null
+++ b/lib/endpoints/vnc.js
@@ -0,0 +1,289 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+
+var assert = require('assert-plus');
+var jsprim = require('jsprim');
+var restify = require('restify');
+var schemas = require('joyent-schemas').cloudapi;
+var util = require('util');
+var vasync = require('vasync');
+var watershed = require('watershed');
+var mooremachine = require('mooremachine');
+var net = require('net');
+
+var shed = new watershed.Watershed();
+
+module.exports = {
+    mount: mount
+};
+
+function mount(server, before, pre) {
+    assert.object(server, 'server');
+    assert.ok(before, 'before');
+    assert.optionalArrayOfFunc(pre, 'pre');
+
+    pre = pre || [];
+
+    server.get({
+        path: '/:account/machines/:machine/vnc',
+        name: 'ConnectMachineVNC',
+        version: [ '8.1.0' ]
+    }, before, connectVNC);
+
+    return server;
+}
+
+function connectVNC(req, res, next) {
+    if (!res.claimUpgrade) {
+        res.send(400, new restify.RestError({
+            statusCode: 400,
+            restCode: 'UpgradeRequired',
+            message: 'VNC connect endpoint is a websocket and must be Upgraded'
+        }));
+        next();
+        return;
+    }
+
+    var fsm = new VNCConnectionFSM();
+    fsm.handle(req, res, next);
+}
+
+
+function VNCConnectionFSM() {
+    this.req = undefined;
+    this.res = undefined;
+    this.next = undefined;
+    this.err = null;
+    this.log = undefined;
+    this.upgrade = undefined;
+    this.ws = undefined;
+    this.socket = undefined;
+    this.host = undefined;
+    this.port = undefined;
+
+    var reqdom = process.domain;
+    reqdom.exit();
+    mooremachine.FSM.call(this, 'init');
+    reqdom.enter();
+}
+util.inherits(VNCConnectionFSM, mooremachine.FSM);
+VNCConnectionFSM.prototype.state_init = function (S) {
+    S.on(this, 'handleAsserted', function () {
+        S.gotoState('validate');
+    });
+};
+VNCConnectionFSM.prototype.state_validate = function (S) {
+    var vm = this.req.machine;
+    if (vm.brand !== 'kvm') {
+        this.err = new restify.RestError({
+            statusCode: 400,
+            restCode: 'MachineHasNoVNC',
+            message: 'Specified machine does not have a VNC console'
+        });
+        S.gotoState('reject');
+        return;
+    }
+    if (vm.state !== 'running') {
+        this.err = new restify.RestError({
+            statusCode: 400,
+            restCode: 'MachineStopped',
+            message: 'Specified machine is stopped and cannot be connected to'
+        });
+        S.gotoState('reject');
+        return;
+    }
+    if (!this.res.claimUpgrade) {
+        this.err = new restify.RestError({
+            statusCode: 400,
+            restCode: 'UpgradeRequired',
+            message: 'VNC connect endpoint is a websocket and must be Upgraded'
+        });
+        S.gotoState('reject');
+        return;
+    }
+    S.gotoState('upgrade');
+};
+VNCConnectionFSM.prototype.state_reject = function (S) {
+    this.res.send(this.err);
+    this.next();
+};
+VNCConnectionFSM.prototype.state_rejectsock = function (S) {
+    var code = this.err.statusCode;
+    if (typeof (code) !== 'number') {
+        code = 500;
+    }
+    var data = JSON.stringify(this.err.body || this.err);
+    this.upgrade.socket.write('HTTP/1.1 ' + code + ' Upgrade Rejected\r\n' +
+        'Connection: close\r\n' +
+        'Content-Type: application/json\r\n' +
+        'Content-Length: ' + data.length + '\r\n\r\n');
+    this.upgrade.socket.end(data);
+    this.next();
+};
+VNCConnectionFSM.prototype.state_upgrade = function (S) {
+    try {
+        this.upgrade = this.res.claimUpgrade();
+        this.upgrade.socket.setNoDelay(true);
+
+        this.ws = shed.accept(this.req, this.upgrade.socket, this.upgrade.head,
+            false, ['binary', 'rfb']);
+    } catch (ex) {
+        this.log.error(ex, 'websocket upgrade failed');
+        this.err = new restify.InternalServerError();
+        S.gotoState('rejectsock');
+        return;
+    }
+    this.res.statusCode = 101;
+    this.next();
+    S.gotoState('getport');
+};
+VNCConnectionFSM.prototype.state_getport = function (S) {
+    var vm = this.req.machine;
+    var uri = '/servers/' + vm.compute_node + '/vms/' + vm.id + '/vnc';
+    var self = this;
+    this.req.sdc.cnapi.get(uri, S.callback(function (err, obj) {
+        if (err) {
+            self.log.error(err, 'failed to fetch VM VNC details from CNAPI');
+            self.err = new restify.InternalServerError('Failed to retrieve ' +
+                'VNC socket details');
+            S.gotoState('error');
+            return;
+        }
+        if (typeof (obj.host) !== 'string' || typeof (obj.port) !== 'number') {
+            self.log.error({ obj: obj }, 'CNAPI returned invalid VM VNC obj');
+            self.err = new restify.InternalServerError('Failed to retrieve ' +
+                'VNC socket details');
+            S.gotoState('error');
+            return;
+        }
+        self.host = obj.host;
+        self.port = obj.port;
+        self.log = self.log.child({ vncHost: obj.host, vncPort: obj.port });
+        self.log.debug('cnapi returned address for vnc');
+        S.gotoState('connect');
+    }));
+    S.on(this.ws, 'error', function (err) {
+        S.gotoState('error');
+    });
+};
+VNCConnectionFSM.prototype.state_error = function (S) {
+    this.log.warn(this.err, 'vnc connection exited with error');
+    if (this.ws) {
+        try {
+            this.ws.end(JSON.stringify({ type: 'error', error: this.err }));
+        } catch (ex) {
+            this.ws.destroy();
+        }
+    }
+    if (this.socket) {
+        this.socket.destroy();
+    }
+};
+VNCConnectionFSM.prototype.state_connect = function (S) {
+    var self = this;
+
+    S.on(this.ws, 'error', function (err) {
+        self.err = err;
+        S.gotoState('error');
+    });
+    S.on(this.ws, 'end', function () {
+        S.gotoState('error');
+    });
+
+    this.socket = net.createConnection({
+        allowHalfOpen: true,
+        host: this.host,
+        port: this.port
+    });
+    S.on(this.socket, 'connect', function () {
+        S.gotoState('connected');
+    });
+    S.on(this.socket, 'error', function (err) {
+        self.log.error(err, 'failed to connect to VNC endpoint');
+        self.err = new restify.InternalServerError('Failed to connect to ' +
+                'VNC server');
+        S.gotoState('error');
+    });
+    S.timeout(5000, function () {
+        self.log.error('timeout while connecting to VNC endpoint');
+        self.err = new restify.InternalServerError('Timeout while connecting ' +
+            'to VNC server');
+        S.gotoState('error');
+    });
+};
+VNCConnectionFSM.prototype.state_connected = function (S) {
+    var self = this;
+    this.socket.setNoDelay(true);
+    S.on(this.ws, 'error', function (err) {
+        self.err = err;
+        S.gotoState('error');
+    });
+    S.on(this.ws, 'end', function () {
+        S.gotoState('ws_ended');
+    });
+    S.on(this.ws, 'connectionReset', function () {
+        S.gotoState('ws_ended');
+    });
+    S.on(this.socket, 'end', function () {
+        S.gotoState('sock_ended');
+    });
+    S.on(this.ws, 'error', function (err) {
+        self.log.error(err, 'error on websocket connection to client');
+        S.gotoState('error');
+    });
+    S.on(this.socket, 'error', function (err) {
+        self.log.error(err, 'error on VNC connection');
+        S.gotoState('error');
+    });
+    S.on(this.ws, 'binary', function (buf) {
+        self.socket.write(buf);
+    });
+    S.on(this.socket, 'readable', function () {
+        var buf;
+        while ((buf = self.socket.read()) !== null) {
+            self.ws.send(buf);
+        }
+    });
+};
+VNCConnectionFSM.prototype.state_ws_ended = function (S) {
+    S.on(this.socket, 'close', function () {
+        S.gotoState('closed');
+    });
+    S.timeout(5000, function () {
+        S.gotoState('error');
+    });
+    this.socket.end();
+    this.socket = null;
+};
+VNCConnectionFSM.prototype.state_sock_ended = function (S) {
+    this.ws.end('Remote connection closed');
+    this.ws = null;
+    S.gotoState('closed');
+};
+VNCConnectionFSM.prototype.state_closed = function (S) {
+    if (this.socket) {
+        this.socket.destroy();
+    }
+    this.socket = null;
+    if (this.ws) {
+        this.ws.destroy();
+    }
+    this.ws = null;
+};
+VNCConnectionFSM.prototype.handle = function (req, res, next) {
+    this.req = req;
+    this.res = res;
+    this.next = next;
+    this.log = this.req.log.child({ component: 'VNCConnectionFSM' });
+    var reqdom = process.domain;
+    reqdom.exit();
+    this.emit('handleAsserted');
+    reqdom.enter();
+};
diff --git a/package.json b/package.json
index 9dde7b0f2..6319105fc 100644
--- a/package.json
+++ b/package.json
@@ -13,33 +13,35 @@
         "url": "git+ssh://git@github.com:joyent/sdc-cloudapi.git"
     },
     "dependencies": {
-        "vasync": "1.6.4",
+        "aperture": "git+https://github.com/joyent/node-aperture.git#016977",
+        "aperture-config": "git+https://github.com/joyent/aperture-config.git#master",
+        "asn1": "0.1.11",
+        "assert-plus": "1.0.0",
+        "bunyan": "1.8.1",
+        "clone": "0.1.5",
+        "ctype": "0.5.2",
+        "cueball": "2.1.1",
         "filed": "0.0.7",
         "http-signature": "1.1.0",
-        "mime": "1.2.7",
+        "joyent-schemas": "git+https://github.com/joyent/schemas.git#caf3a226ed0707f5da897e1da151cc6d97fccda2",
+        "jsprim": "0.6.1",
+        "kang": "1.1.0",
+        "keyapi": "git+https://github.com/joyent/keyapi.git#e14b3d582e1d9d338b7082d61f34ba8d1bbc540a",
+        "krill": "1.0.1",
         "libuuid": "0.2.1",
+        "mahi": "2.0.1",
+        "mime": "1.2.7",
+        "mooremachine": "^2.2.0",
+        "nodemailer": "0.3.29",
         "nopt": "2.0.0",
         "restify": "4.3.0",
-        "bunyan": "1.8.1",
-        "cueball": "2.1.1",
-        "kang": "1.1.0",
-        "krill": "1.0.1",
         "sdc-clients": "10.4.0",
-        "ufds": "1.3.0",
         "semver": "2.2.1",
-        "nodemailer": "0.3.29",
-        "clone": "0.1.5",
-        "assert-plus": "1.0.0",
-        "asn1": "0.1.11",
-        "ctype": "0.5.2",
-        "keyapi": "git+https://github.com/joyent/keyapi.git#e14b3d582e1d9d338b7082d61f34ba8d1bbc540a",
-        "aperture": "git+https://github.com/joyent/node-aperture.git#016977",
-        "mahi": "2.0.1",
-        "aperture-config": "git+https://github.com/joyent/aperture-config.git#master",
-        "joyent-schemas": "git+https://github.com/joyent/schemas.git#caf3a226ed0707f5da897e1da151cc6d97fccda2",
-        "jsprim": "0.6.1",
         "strsplit": "1.0.0",
+        "ufds": "1.3.0",
+        "vasync": "1.6.4",
         "verror": "1.10.0",
+        "watershed": "0.4.0",
         "xregexp": "3.1.0"
     },
     "devDependencies": {
