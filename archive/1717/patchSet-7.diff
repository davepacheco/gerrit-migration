From f323e17f20c0b2e2e1f3a027f205e3bbf7f2be58 Mon Sep 17 00:00:00 2001
From: Robert Mustacchi <rm@joyent.com>
Date: Fri, 17 Mar 2017 18:49:59 +0000
Subject: [PATCH] OS-6022 want basic transceiver visibility OS-6023 ixgbe
 MAC_CAPAB_TRANSCEIVER support OS-6024 i40e MAC_CAPAB_TRANSCEIVER support
 Reviewed by: Patrick Mooney <patrick.mooney@joyent.com> Reviewed by: Jerry
 Jelinek <jerry.jelinek@joyent.com> Reviewed by: Ryan Zezeski
 <ryan.zeseski@joyent.com> Approved by: Patrick Mooney
 <patrick.mooney@joyent.com>

---
 manifest                                      |   9 +
 usr/src/cmd/Makefile                          |   3 +-
 usr/src/cmd/dltraninfo/Makefile               |  36 ++
 usr/src/cmd/dltraninfo/dltraninfo.c           | 356 ++++++++++++++++
 usr/src/man/man9e/Makefile                    |   8 +
 usr/src/man/man9e/mac_capab_transceiver.9e    | 383 ++++++++++++++++++
 usr/src/man/man9f/Makefile                    |   7 +
 usr/src/man/man9f/mac_transceiver_info.9f     |  93 +++++
 usr/src/uts/common/Makefile.files             |   6 +-
 usr/src/uts/common/io/dld/dld_drv.c           | 103 ++++-
 usr/src/uts/common/io/i40e/i40e_gld.c         |  41 ++
 usr/src/uts/common/io/ixgbe/ixgbe_gld.c       |  15 +
 usr/src/uts/common/io/ixgbe/ixgbe_main.c      |   3 +-
 usr/src/uts/common/io/ixgbe/ixgbe_sw.h        |   4 +
 .../uts/common/io/ixgbe/ixgbe_transceiver.c   | 169 ++++++++
 usr/src/uts/common/io/mac/mac.c               | 104 ++++-
 usr/src/uts/common/io/mac/mac_provider.c      |  16 +
 usr/src/uts/common/mapfiles/mac.mapfile       |   5 +-
 usr/src/uts/common/sys/dld.h                  |  25 +-
 usr/src/uts/common/sys/mac.h                  |   2 +-
 usr/src/uts/common/sys/mac_impl.h             |  20 +-
 usr/src/uts/common/sys/mac_provider.h         |  25 +-
 22 files changed, 1419 insertions(+), 14 deletions(-)
 create mode 100644 usr/src/cmd/dltraninfo/Makefile
 create mode 100644 usr/src/cmd/dltraninfo/dltraninfo.c
 create mode 100644 usr/src/man/man9e/mac_capab_transceiver.9e
 create mode 100644 usr/src/man/man9f/mac_transceiver_info.9f
 create mode 100644 usr/src/uts/common/io/ixgbe/ixgbe_transceiver.c

diff --git a/manifest b/manifest
index a502c55cbf..5f7ae71b45 100644
--- a/manifest
+++ b/manifest
@@ -5176,6 +5176,8 @@ f usr/lib/devfsadm/linkmod/SUNW_zfs_link.so 0755 root sys
 f usr/lib/devfsadm/linkmod/SUNW_zut_link.so 0755 root sys
 f usr/lib/diff3prog 0555 root bin
 f usr/lib/diffh 0555 root bin
+d usr/lib/dl 0755 root sys
+f usr/lib/dl/dltraninfo 0555 root bin
 f usr/lib/dscfglockd 0555 root bin
 d usr/lib/dtrace 0755 root bin
 d usr/lib/dtrace/64 0755 root bin
@@ -18954,6 +18956,8 @@ f usr/share/man/man9e/ks_snapshot.9e 0444 root bin
 f usr/share/man/man9e/ks_update.9e 0444 root bin
 s usr/share/man/man9e/MAC.9e=mac.9e
 f usr/share/man/man9e/mac.9e 0444 root bin
+f usr/share/man/man9e/mac_capab_transceiver.9e 0444 root bin
+s usr/share/man/man9e/mac_transceiver_kind.9e=mac_capab_transceiver.9e
 s usr/share/man/man9e/mc_close.9e=mc_open.9e
 f usr/share/man/man9e/mc_getcapab.9e 0444 root bin
 f usr/share/man/man9e/mc_getprop.9e 0444 root bin
@@ -18968,6 +18972,8 @@ f usr/share/man/man9e/mc_start.9e 0444 root bin
 s usr/share/man/man9e/mc_stop.9e=mc_start.9e
 f usr/share/man/man9e/mc_tx.9e 0444 root bin
 f usr/share/man/man9e/mc_unicst.9e 0444 root bin
+s usr/share/man/man9e/mct_info.9e=mac_capab_transceiver.9e
+s usr/share/man/man9e/mct_read.9e=mac_capab_transceiver.9e
 f usr/share/man/man9e/mmap.9e 0444 root bin
 f usr/share/man/man9e/open.9e 0444 root bin
 f usr/share/man/man9e/power.9e 0444 root bin
@@ -19796,6 +19802,9 @@ s usr/share/man/man9f/mac_prop_info_set_perm.9f=mac_prop_info.9f
 s usr/share/man/man9f/mac_prop_info_set_range_uint32.9f=mac_prop_info.9f
 f usr/share/man/man9f/mac_register.9f 0444 root bin
 f usr/share/man/man9f/mac_rx.9f 0444 root bin
+f usr/share/man/man9f/mac_transceiver_info.9f 0444 root bin
+s usr/share/man/man9f/mac_transceiver_info_set_present.9f=mac_transceiver_info.9f
+s usr/share/man/man9f/mac_transceiver_info_set_usable.9f=mac_transceiver_info.9f
 f usr/share/man/man9f/mac_tx_update.9f 0444 root bin
 s usr/share/man/man9f/mac_unregister.9f=mac_register.9f
 f usr/share/man/man9f/max.9f 0444 root bin
diff --git a/usr/src/cmd/Makefile b/usr/src/cmd/Makefile
index 3034abdb57..ff21feeb89 100644
--- a/usr/src/cmd/Makefile
+++ b/usr/src/cmd/Makefile
@@ -21,7 +21,7 @@
 
 #
 # Copyright (c) 1989, 2010, Oracle and/or its affiliates. All rights reserved.
-# Copyright 2016 Joyent, Inc.
+# Copyright (c) 2017, Joyent, Inc.
 # Copyright (c) 2012 by Delphix. All rights reserved.
 # Copyright (c) 2013 DEY Storage Systems, Inc. All rights reserved.
 # Copyright 2014 Garrett D'Amore <garrett@damore.org>
@@ -136,6 +136,7 @@ COMMON_SUBDIRS=		\
 	dispadmin	\
 	dladm		\
 	dlstat		\
+	dltraninfo	\
 	dmesg		\
 	dodatadm	\
 	dtrace		\
diff --git a/usr/src/cmd/dltraninfo/Makefile b/usr/src/cmd/dltraninfo/Makefile
new file mode 100644
index 0000000000..d873ca3671
--- /dev/null
+++ b/usr/src/cmd/dltraninfo/Makefile
@@ -0,0 +1,36 @@
+#
+# This file and its contents are supplied under the terms of the
+# Common Development and Distribution License ("CDDL"), version 1.0.
+# You may only use this file in accordance with the terms of version
+# 1.0 of the CDDL.
+#
+# A full copy of the text of the CDDL should have accompanied this
+# source.  A copy of the CDDL is also available via the Internet at
+# http://www.illumos.org/license/CDDL.
+#
+
+#
+# Copyright (c) 2017, Joyent, Inc.
+#
+
+PROG= dltraninfo
+
+include ../Makefile.cmd
+
+ROOTCMDDIR = $(ROOTLIB)/dl
+CFLAGS += $(CCVERBOSE)
+LDLIBS += -ldladm
+
+ROOTLIBDLFILES = $(PROG:%=$(ROOTLIB)/dl/%)
+
+.KEEP_STATE:
+
+all: $(PROG)
+
+install: all $(ROOTCMD)
+
+clean:
+
+lint:	lint_PROG
+
+include ../Makefile.targ
diff --git a/usr/src/cmd/dltraninfo/dltraninfo.c b/usr/src/cmd/dltraninfo/dltraninfo.c
new file mode 100644
index 0000000000..2e6f7ee2e1
--- /dev/null
+++ b/usr/src/cmd/dltraninfo/dltraninfo.c
@@ -0,0 +1,356 @@
+/*
+ * This file and its contents are supplied under the terms of the
+ * Common Development and Distribution License ("CDDL"), version 1.0.
+ * You may only use this file in accordance with the terms of version
+ * 1.0 of the CDDL.
+ *
+ * A full copy of the text of the CDDL should have accompanied this
+ * source.  A copy of the CDDL is also available via the Internet at
+ * http://www.illumos.org/license/CDDL.
+ */
+
+/*
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+
+/*
+ * Private utility to dump transceiver information for each physical datalink.
+ * Something like this should eventually be a part of dladm or similar.
+ */
+
+#include <stdio.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <strings.h>
+#include <errno.h>
+#include <ctype.h>
+#include <unistd.h>
+#include <limits.h>
+#include <stdarg.h>
+#include <libgen.h>
+
+#include <libdladm.h>
+#include <libdllink.h>
+#include <sys/dld.h>
+#include <sys/dld_ioc.h>
+#include <sys/dls_mgmt.h>
+
+#define	DLTRAN_KIND_LEN	64
+
+static dladm_handle_t dltran_hdl;
+static char dltran_dlerrmsg[DLADM_STRSIZE];
+static char **dltran_links;
+static int dltran_nlinks;	/* array size */
+static int dltran_clinks;	/* current count */
+static boolean_t dltran_tranid_set;
+static int dltran_tranid;
+static const char *dltran_progname;
+
+/* ARGSUSED */
+static int
+dltran_dump_transceivers(dladm_handle_t hdl, datalink_id_t linkid, void *arg)
+{
+	dladm_status_t status;
+	char name[MAXLINKNAMELEN];
+	dld_ioc_gettran_t gt;
+	uint_t count, i;
+
+	if ((status = dladm_datalink_id2info(hdl, linkid, NULL, NULL, NULL,
+	    name, sizeof (name))) != DLADM_STATUS_OK) {
+		(void) fprintf(stderr, "failed to get datalink name for link "
+		    "%d: %s", linkid, dladm_status2str(status,
+		    dltran_dlerrmsg));
+		return (DLADM_WALK_CONTINUE);
+	}
+
+	if (dltran_nlinks != NULL) {
+		for (i = 0; i < dltran_clinks; i++) {
+			if (strcmp(dltran_links[i], name) == 0)
+				break;
+		}
+		if (i == dltran_clinks)
+			return (DLADM_WALK_CONTINUE);
+	}
+
+	bzero(&gt, sizeof (gt));
+	gt.dgt_linkid = linkid;
+	gt.dgt_tran_id = DLDIOC_GETTRAN_GETNTRAN;
+
+	if (ioctl(dladm_dld_fd(hdl), DLDIOC_GETTRAN, &gt) != 0) {
+		(void) fprintf(stderr, "failed to get transceiver count "
+		    "for device %s: %s\n",
+		    name, strerror(errno));
+		return (DLADM_WALK_CONTINUE);
+	}
+
+
+	count = gt.dgt_tran_id;
+	(void) printf("%s: discovered %d transceivers\n", name, count);
+	for (i = 0; i < count; i++) {
+		if (dltran_tranid_set && i != dltran_tranid)
+			continue;
+		bzero(&gt, sizeof (gt));
+		gt.dgt_linkid = linkid;
+		gt.dgt_tran_id = i;
+
+		if (ioctl(dladm_dld_fd(hdl), DLDIOC_GETTRAN, &gt) != 0) {
+			(void) fprintf(stderr, "failed to get tran info for "
+			    "%s: %s\n", name, strerror(errno));
+			return (DLADM_WALK_CONTINUE);
+		}
+
+		(void) printf("\ttransceiver %d present: %s\n", i,
+		    gt.dgt_present ? "yes" : "no");
+		if (!gt.dgt_present)
+			continue;
+		(void) printf("\ttransceiver %d usable: %s\n", i,
+		    gt.dgt_usable ? "yes" : "no");
+	}
+
+	return (DLADM_WALK_CONTINUE);
+}
+
+/*
+ * This routine basically assumes that we'll have 16 byte aligned output to
+ * print out the human readable output.
+ */
+static void
+dltran_dump_page(uint8_t *buf, size_t nbytes, uint_t page)
+{
+	size_t i;
+	static boolean_t first = B_TRUE;
+
+	if (first) {
+		(void) printf("page  %*s    0", 4, "");
+		for (i = 1; i < 16; i++) {
+			if (i % 4 == 0 && i % 16 != 0) {
+				(void) printf(" ");
+			}
+
+			(void) printf("%2x", i);
+		}
+		(void) printf("  v123456789abcdef\n");
+		first = B_FALSE;
+	}
+	for (i = 0; i < nbytes; i++) {
+
+		if (i % 16 == 0) {
+			(void) printf("0x%02x  %04x:  ", page, i);
+		}
+
+		if (i % 4 == 0 && i % 16 != 0) {
+			(void) printf(" ");
+		}
+
+
+		(void) printf("%02x", buf[i]);
+
+		if (i % 16 == 15) {
+			int j;
+			(void) printf("  ");
+			for (j = i - (i % 16); j <= i; j++) {
+				if (!isprint(buf[j])) {
+					(void) printf(".");
+				} else {
+					(void) printf("%c", buf[j]);
+				}
+			}
+			(void) printf("\n");
+		}
+	}
+}
+
+/*
+ * We always read 256 bytes even though only the first 128 bytes are sometimes
+ * significant on a given page and others are reserved.
+ */
+static int
+dltran_read_page(datalink_id_t link, uint_t tranid, uint_t page, uint8_t *bufp,
+    size_t buflen)
+{
+	dld_ioc_tranio_t dti;
+
+	bzero(bufp, buflen);
+	bzero(&dti, sizeof (dti));
+
+	dti.dti_linkid = link;
+	dti.dti_tran_id = tranid;
+	dti.dti_page = page;
+	dti.dti_nbytes = buflen;
+	dti.dti_off = 0;
+	dti.dti_buf = (uintptr_t)(void *)bufp;
+
+	if (ioctl(dladm_dld_fd(dltran_hdl), DLDIOC_READTRAN, &dti) != 0) {
+		(void) fprintf(stderr, "failed to read transceiver page "
+		    "0x%2x: %s\n", page, strerror(errno));
+		return (1);
+	}
+
+	dltran_dump_page(bufp, dti.dti_nbytes, page);
+
+	return (0);
+}
+
+static boolean_t
+dltran_is_8472(uint8_t *buf)
+{
+	switch (buf[0]) {
+	case 0xc:
+	case 0xd:
+	case 0x11:
+		/*
+		 * Catch cases that refer explicitly to QSFP and newer.
+		 */
+		return (B_FALSE);
+	default:
+		break;
+	}
+
+	/*
+	 * Check the byte that indicates compliance with SFF 8472. Use this to
+	 * know if we can read page 0xa2 or not.
+	 */
+	if (buf[94] == 0)
+		return (B_FALSE);
+
+	return (B_TRUE);
+}
+
+static int
+dltran_read_link(const char *link)
+{
+	dladm_status_t status;
+	datalink_id_t linkid;
+	dld_ioc_gettran_t gt;
+	uint8_t buf[256];
+	int ret;
+
+	if ((status = dladm_name2info(dltran_hdl, link, &linkid, NULL, NULL,
+	    NULL)) != DLADM_STATUS_OK) {
+		(void) fprintf(stderr, "failed to get link id for link "
+		    "%s: %s\n", link,
+		    dladm_status2str(status, dltran_dlerrmsg));
+		return (1);
+	}
+
+	gt.dgt_linkid = linkid;
+	gt.dgt_tran_id = dltran_tranid;
+
+	if (ioctl(dladm_dld_fd(dltran_hdl), DLDIOC_GETTRAN, &gt) != 0) {
+		(void) fprintf(stderr, "failed to get transceiver information "
+		    "for %s: %s\n", link, strerror(errno));
+		return (1);
+	}
+
+	if ((ret = dltran_read_page(linkid, dltran_tranid, 0xa0, buf,
+	    sizeof (buf))) != 0) {
+		return (ret);
+	}
+
+	if (!dltran_is_8472(buf)) {
+		return (0);
+	}
+
+	return (dltran_read_page(linkid, dltran_tranid, 0xa2, buf,
+	    sizeof (buf)));
+}
+
+static void
+dltran_usage(const char *fmt, ...)
+{
+	if (fmt != NULL) {
+		va_list ap;
+
+		(void) fprintf(stderr, "%s: ", dltran_progname);
+		va_start(ap, fmt);
+		(void) vfprintf(stderr, fmt, ap);
+		va_end(ap);
+	}
+
+	(void) fprintf(stderr, "Usage: %s [-i id] [-l link]... [-r]\n"
+	    "\n"
+	    "\t-i id    specify a transceiver id to operate on\n"
+	    "\t-l link  specify a data link to operate on\n"
+	    "\t-r       read transceiver page\n",
+	    dltran_progname);
+}
+
+int
+main(int argc, char *argv[])
+{
+	int c;
+	char *eptr;
+	long l;
+	dladm_status_t status;
+	boolean_t do_read = B_FALSE;
+
+	dltran_progname = basename(argv[0]);
+
+	while ((c = getopt(argc, argv, ":hi:l:r")) != -1) {
+		switch (c) {
+		case 'i':
+			errno = 0;
+			l = strtol(optarg, &eptr, 10);
+			if (errno != 0 || *eptr != '\0' || l < 0 ||
+			    l > INT_MAX) {
+				(void) fprintf(stderr, "invalid value for -i: "
+				    "%s\n", optarg);
+				return (2);
+			}
+			dltran_tranid = (int)l;
+			dltran_tranid_set = B_TRUE;
+			break;
+		case 'l':
+			if (dltran_nlinks == dltran_clinks) {
+				char **p;
+				dltran_nlinks += 8;
+
+				p = realloc(dltran_links,
+				    sizeof (char **) * dltran_nlinks);
+				if (p == NULL) {
+					(void) fprintf(stderr, "failed to "
+					    "allocate space for %d links: %s\n",
+					    dltran_nlinks, strerror(errno));
+					return (1);
+				}
+				dltran_links = p;
+			}
+			dltran_links[dltran_clinks++] = optarg;
+			break;
+		case 'r':
+			do_read = B_TRUE;
+			break;
+		case ':':
+			dltran_usage("option -%c requires an "
+			    "operand\n", optopt);
+			return (2);
+		case '?':
+		default:
+			dltran_usage("unknown option: -%c\n", optopt);
+			return (2);
+		}
+	}
+
+	if (do_read && dltran_clinks != 1) {
+		(void) fprintf(stderr, "-r requires exactly one link "
+		    "specified with -l\n");
+		return (2);
+	}
+
+	if ((status = dladm_open(&dltran_hdl)) != DLADM_STATUS_OK) {
+		(void) fprintf(stderr, "failed to open /dev/dld: %s\n",
+		    dladm_status2str(status, dltran_dlerrmsg));
+		return (1);
+	}
+
+	if (do_read) {
+		return (dltran_read_link(dltran_links[0]));
+	}
+
+	(void) dladm_walk_datalink_id(dltran_dump_transceivers, dltran_hdl,
+	    NULL, DATALINK_CLASS_PHYS, DATALINK_ANY_MEDIATYPE,
+	    DLADM_OPT_ACTIVE);
+
+	return (0);
+}
diff --git a/usr/src/man/man9e/Makefile b/usr/src/man/man9e/Makefile
index 2d32bfbe34..0b68a25fa4 100644
--- a/usr/src/man/man9e/Makefile
+++ b/usr/src/man/man9e/Makefile
@@ -42,6 +42,7 @@ MANFILES=	Intro.9e		\
 		ks_snapshot.9e		\
 		ks_update.9e		\
 		mac.9e			\
+		mac_capab_transceiver.9e	\
 		mc_getcapab.9e		\
 		mc_getprop.9e		\
 		mc_getstat.9e		\
@@ -109,8 +110,11 @@ MANLINKS=	_info.9e		\
 		gldm_start.9e		\
 		gldm_stop.9e		\
 		MAC.9e			\
+		mac_transceiver_kind.9e	\
 		mc_close.9e		\
 		mc_stop.9e		\
+		mct_info.9e		\
+		mct_read.9e		\
 		intro.9e		\
 		tran_destroy_pkt.9e	\
 		tran_pkt_constructor.9e	\
@@ -148,6 +152,10 @@ gldm_stop.9e			:= LINKSRC = gld.9e
 mc_close.9e			:= LINKSRC = mc_open.9e
 mc_stop.9e			:= LINKSRC = mc_start.9e
 
+mac_transceiver_kind.9e		:= LINKSRC = mac_capab_transceiver.9e
+mct_info.9e			:= LINKSRC = mac_capab_transceiver.9e
+mct_read.9e			:= LINKSRC = mac_capab_transceiver.9e
+
 tran_setcap.9e			:= LINKSRC = tran_getcap.9e
 
 tran_destroy_pkt.9e		:= LINKSRC = tran_init_pkt.9e
diff --git a/usr/src/man/man9e/mac_capab_transceiver.9e b/usr/src/man/man9e/mac_capab_transceiver.9e
new file mode 100644
index 0000000000..558e7b84e5
--- /dev/null
+++ b/usr/src/man/man9e/mac_capab_transceiver.9e
@@ -0,0 +1,383 @@
+.\"
+.\" This file and its contents are supplied under the terms of the
+.\" Common Development and Distribution License ("CDDL"), version 1.0.
+.\" You may only use this file in accordance with the terms of version
+.\" 1.0 of the CDDL.
+.\"
+.\" A full copy of the text of the CDDL should have accompanied this
+.\" source.  A copy of the CDDL is also available via the Internet at
+.\" http://www.illumos.org/license/CDDL.
+.\"
+.\"
+.\" Copyright (c) 2017, Joyent, Inc.
+.\"
+.Dd Mar 24, 2017
+.Dt MAC_CAPAB_TRANSCEIVER 9E
+.Os
+.Sh NAME
+.Nm mac_capab_transciever ,
+.Nm mct_info ,
+.Nm mct_read
+.Nd MAC capability for networking transceivers
+.Sh SYNOPSIS
+.In sys/mac_provider.h
+.Vt typedef struct mac_capab_transceiver mac_capab_transceiver_t;
+.Ft int
+.Fo "mct_info"
+.Fa "void *driver"
+.Fa "uint_t id"
+.Fa "mac_transceiver_info_t *infop"
+.Fc
+.Ft int
+.Fo mct_read
+.Fa "void *driver"
+.Fa "uint_t id"
+.Fa "uint_t page"
+.Fa "void *buf"
+.Fa "size_t nbytes"
+.Fa "off_t offset"
+.Fa "size_t *nread"
+.Fc
+.Sh INTERFACE LEVEL
+.Sy Volatile -
+This interface is still evolving in illumos. API and ABI stability is
+not guaranteed.
+.Sh PARAMETERS
+.Bl -tag -width Fa
+.It Fa driver
+A pointer to the driver's private data that was passed in via the
+.Sy m_pdata
+member of the
+.Xr mac_register 9S
+structure to the
+.Xr mac_register 9F
+function.
+.It Fa id
+An integer value indicating which transceiver is being inquired about.
+.It Fa infop
+An opaque structure which is used to set information about the
+transceiver.
+.It Fa page
+A value that indicates which page from the i2c bus is being requested.
+.It Fa buf
+A pointer to which data should be written to when reading from the
+device.
+.It Fa nbytes
+A value indicating the number of bytes being asked to read into
+.Fa buf .
+.It Fa offset
+A value indicating the offset into the page to start reading data.
+.It Fa nread
+A value to be updated by the driver with the number of successfully read
+bytes.
+.El
+.Sh DESCRIPTION
+The
+.Sy MAC_CAPAB_TRANSCEIVER
+capability allows for GLDv3 networking device drivers to provide
+information to the system about their transceiver. Implementing this
+capability is optional. For more information on how to handle
+capabilities and how to indicate that a capability is not supported, see
+.Xr mc_getcapab 9E .
+.Pp
+This capability should be implemented if the device in question supports
+a Small Form Factor (SFF) transceiver. These are more commonly known by
+names such as SFP, SFP+, SFP28, QSFP+, and QSFP28. This interface does
+not apply to traditional copper Ethernet phys. These transceivers
+provide standardized information over the i2c bus at specific pages.
+.Ss Supported Standards
+.Bl -tag -width Sy
+.It Sy INF-8074
+The
+.Sy INF-8084
+standard was the original multiple source agreement (MSA) for SFP
+devices.  It proposed the original series of management pages at i2c
+page 0xa0.  This page contained up to 512 bytes, however, only the first
+96 bytes are standardized. Bytes 97 to 127 are reserved for the vendor.
+The remaining bytes are reserved by the specification. The management
+page was subsequently adopted by SFP+ devices.
+.It Sy SFF-8472
+The
+.Sy SFF-8472
+standard extended the original SFP MSA. This standard added a second i2c
+page at 0xa2, while maintaining the original page at 0xa0. The page at
+0xa0 is now explicitly 256 bytes. The page at 0xa2 is also 256 bytes.
+This standard was also adopted for all SFP28 parts, which are commonly
+used in transceivers for 25 Gb/s Ethernet.
+.It Sy SFF-8436
+The
+.Sy SFF-8436
+standard was developed for QSFP+ transceivers, which involve the
+bonding of 4 SFP+ links. QSFP+ is commonly used in the transceivers for
+40 Gb/s Ethernet.  This standard uses i2c page 0xa0 for read-only
+identification purposes. The lower half of the page is used for control,
+while the upper 128 bytes is similar to the
+.Sy INF-8084
+and
+.Sy SFF-8472
+standards.
+.It Sy SFF-8636
+The
+.Sy SFF-8636
+standard is a common management standard which is shared between both
+SAS and QSFP+ 28 Gb/s transceivers. The latter transceiver is commonly
+found in 100 Gb/s Ethernet. The transceiver's memory map is similar to
+that found in the
+.Sy SFF-8436
+specification. The identification information is found in the upper 128
+bytes of page 0xa0, while the lower part of the page is used for
+control, among other purposes.
+.El
+.Pp
+The following table summarizes the above information.
+.Bl -column "Sy SFF-8636" "1 Gb/s, 10 Gb/s, 25 Gb/s" "256 bytes" "0xa0, 0xa2" -offset indent
+.Em "Standard" Ta Em Speeds Ta Em Size Ta Em i2c pages
+.It INF-8074 Ta 1 Gb/s, 10 Gb/s Ta 128 bytes Ta 0xa0
+.It SFF-8472 Ta 1 Gb/s, 10 Gb/s, 25 GB/s Ta 512 bytes Ta 0xa0, 0xa2
+.It SFF-8436 Ta 40 Gb/s Ta 256 bytes Ta 0xa0
+.It SFF-8636 Ta 100 Gb/s Ta 256 bytes Ta 0xa0
+.El
+.Ss MAC Capability Structure
+When the device driver's
+.Xr mc_getcapab 9E
+function entry point is called with the capability requested set to
+.Sy MAC_CAPAB_TRANSCEIVER ,
+then the value of the capability structure is the following structure:
+.Bd -literal -offset indent
+typedef struct mac_capab_transceiver {
+	uint_t	mct_flags;
+	uint_t	mct_ntransceiveres;
+	int	(*mct_info)(void *driver, uint_t id,
+		    mac_transceiver_info_t *infop),
+	int	(*mct_read)(void *driver, uint_t id, uint_t page,
+		    void *buf, size_t nbytes, off_t offset,
+		    size_t *nread)
+} mac_capab_transceiver_t;
+.Ed
+.Pp
+If the device driver supports the
+.Sy MAC_CAPAB_TRANSCEIVER
+capability, it should fill in this structure, based on the following
+rules:
+.Bl -tag -width Sy
+.It Sy mct_flags
+The
+.Vt mct_flags
+member is used to negotiate extensions with the driver. MAC will set the
+value of
+.Vt mct_flags
+to include all of the currently known extensions. The driver should
+intersect this list with the set that they actually support. At this
+time, no such features are defined and the driver should set the member
+to
+.Sy 0 .
+.It Sy mct_ntransceivers
+The value of
+.Sy mct_ntransceivers
+indicates that the number of transceivers present in the device. For most
+devices, it is expected that this value will be set to one. However,
+some devices do support multiple transceivers and PHYs that show up
+behind a single logical MAC.
+.Pp
+It is expected that this value will not change across the lifetime of
+the device being attached. It is important to remember that this
+represents the total possible number of transceivers in the device, not
+how many are currently present and powered on.
+.Pp
+The number of transceivers will influence the
+.Fa id
+argument used in the
+.Fn mct_info
+and
+.Fn mct_read
+entry points. The transceiver IDs will start at zero and go to the value
+of
+.Fa mct_ntransceivers - 1 .
+It is up to the driver to keep the mapping between actual transceivers
+and the transceiver identifiers consistent.
+.It Sy mct_info
+The
+.Fn mct_info
+entry point is used to set basic information about the transceiver. This
+entry point is
+.Em required .
+If the device driver cannot implement this entry point, then it should
+not indicate that it supports the capability.
+.Pp
+The
+.Fn mct_info
+entry point should fill in information about the transceiver with an
+identifier of
+.Fa id .
+See the description above of
+.Sy mct_ntransceivers
+for more information on how the IDs are determined.
+.Pp
+The driver should then proceed to fill in basic information by calling
+the functions described in the section
+.Sx Information Functions .
+After successfully calling all of the functions, the driver should
+return
+.Sy 0 .
+Othewrise, it should return the appropriate error number. For a full
+list of error numbers, see
+.Xr Intro 2 .
+Common values are:
+.Bl -tag -width Er -offset width
+.It Er EINVAL
+The transceiver identifier
+.Fa id
+was invalid.
+.It Er ENOTSUP
+This instance of the devices does not support a transceiver. For
+example, a device which sometimes has copper PHYs and therefore this
+instance does not have any PHYs.
+.It Er EIO
+An error occurred while trying to read device registers. For example, an
+FM-aware device had an error.
+.El
+.It Sy mct_read
+The
+.Fn mct_read
+function is used to read information from a transceiver's i2c bus. The
+.Fn mct_read
+entry point is an
+.Em optional
+entry point.
+.Pp
+The transceiver should first check the value of
+.Fa id ,
+which indicates which transceiver information is being requested.  See
+the description above of
+.Sy mct_ntransceivers
+for more information on how the IDs are determined.
+.Pp
+The driver should try to read up to
+.Fa nbytes
+of data from the i2c bus at page
+.Fa page .
+The driver should start reading at offset
+.Fa offset .
+Finally, it should update the value in
+.Fa nread
+with the number of bytes written to the buffer
+.Fa buf .
+.Pp
+If for some reason the driver cannot read all of the requested bytes,
+that is acceptable. Instead it should perform a short read. This may
+occur because the transceiver does not allow reads at a requested region
+or the region is shorter than is common for most devices.
+.Pp
+Upon successful completion, the driver should ensure that
+.Fa nread
+has been updated and then return
+.Sy 0 .
+Otherwise, the driver should return the appropriate error number. For
+a full list of error numbers, see
+.Xr Intro 2 .
+Common values are:
+.Bl -tag -width Er -offset width
+.It Er EINVAL
+The value of
+.Fa id
+represented an invalid transceiver identifier. The transceiver i2c page
+.Fa page
+is not valid for this type of device. The value of
+.Fa offset
+is beyond the range supported for this
+.Fa page .
+.It Er EIO
+An error occurred while trying to read the device i2c pages.
+.El
+.El
+.Ss Transceiver Information Functions
+The
+.Fn mct_info
+entry point is the primary required entry point for a device driver
+which supports this capability. The information structure is opaque to
+the device driver. Instead, a series of informational functions is
+available to the device driver to call on the transceiver. The device
+drivers should try to call and fill in as many of these as possible.
+There are two different properties that a driver can set:
+.Bl -enum -offset indent
+.It
+Whether the transceiver is present.
+.It
+Whether the transceiver is usable.
+.El
+.Pp
+To set whether or not the transceiver is present, the driver should call
+.Xr mac_transceiver_info_set_present 9F .
+This is used to indicate whether the transceiver is plugged in or not.
+If the transceiver is a part of the NIC, then this function should
+always be called with the value set to
+.Dv B_TRUE .
+.Pp
+Finally, the driver has the ability to provide information about whether
+or not the transceiver is usable or not. A transceiver may be present,
+but not usable, if the hardware and firmware support a limited number of
+transceivers. To set this information, the driver should call
+.Xr mac_transceiver_info_set_usable 9F .
+If the transceiver is not present, then the driver should not call this
+function.
+.Ss Opaque Transceivers
+Some devices abstract the nature of the transceiver and do not allow
+direct access to the transceiver. In this case, if the device driver
+still has access to enough information to know if the transceiver is
+at least present, then it should still implement the
+.Fn mct_info
+entry point.
+.Ss Locking and Data Access
+Calls to get information about the transceivers may come at the same
+time as general I/O requests to the device to send or receive data. The
+driver should make sure that reading data from the i2c bus of the
+transceiver does not interfere with the device's functionality in this
+regard. Different locks should be used.
+.Pp
+On some devices, reading from the transceiver's i2c bus might cause a
+disruption of service to the device. For example, on some devices a phy
+reset may be required or come about as a side effect of trying to read
+the device. If any kind of disruption would be caused, then the driver
+must not implement the
+.Ft mct_read
+entry point.
+.Sh CONTEXT
+The various callback functions will be called from
+.Sy kernel
+context. These functions will never be called from
+.Sy interrupt
+context.
+.Sh SEE ALSO
+.Xr Intro 2 ,
+.Xr mac 9E ,
+.Xr mc_getcapab 9E ,
+.Xr mac_register 9F ,
+.Xr mac_transceiver_info_set_present 9F ,
+.Xr mac_transceiver_info_set_type 9F ,
+.Xr mac_transceiver_info_set_usable 9F ,
+.Xr mac_register 9S ,
+.Rs
+.%N INF-8074i
+.%T SFP (Small Formfactor Pluggable) Interface
+.%Q SFF Committee
+.%O Revision 1.0
+.%D May 12, 2001
+.Re
+.Rs
+.%N SFF-8472
+.%T Diagnostic Monitoring Interface for Optical Transceivers
+.%O Revision 12.2
+.%D November 21, 2014
+.Re
+.Rs
+.%N SFF-8436
+.%T QSFP+ 10 Gbs 4X PLUGGABLE TRANSCEIVER
+.%O Revision 4.8
+.%D October 31, 2013
+.Re
+.Rs
+.%N SFF-8636
+.%T Management Interface for Cabled Environments
+.%O Revision 2.7
+.%D January 26, 2016
+.Re
diff --git a/usr/src/man/man9f/Makefile b/usr/src/man/man9f/Makefile
index 30c1d87148..2fba3735d0 100644
--- a/usr/src/man/man9f/Makefile
+++ b/usr/src/man/man9f/Makefile
@@ -332,6 +332,7 @@ MANFILES=	ASSERT.9f				\
 		mac_prop_info.9f			\
 		mac_register.9f				\
 		mac_rx.9f				\
+		mac_transceiver_info.9f			\
 		mac_tx_update.9f			\
 		makecom.9f				\
 		makedevice.9f				\
@@ -999,6 +1000,8 @@ MANLINKS=	AVL_NEXT.9f					\
 		mac_prop_info_set_default_uint8.9f		\
 		mac_prop_info_set_perm.9f			\
 		mac_prop_info_set_range_uint32.9f		\
+		mac_transceiver_info_set_present.9f		\
+		mac_transceiver_info_set_usable.9f		\
 		mac_unregister.9f				\
 		makecom_g0.9f					\
 		makecom_g0_s.9f					\
@@ -1828,6 +1831,10 @@ mac_prop_info_set_default_uint32.9f	:= LINKSRC = mac_prop_info.9f
 mac_prop_info_set_default_uint64.9f	:= LINKSRC = mac_prop_info.9f
 mac_prop_info_set_perm.9f		:= LINKSRC = mac_prop_info.9f
 mac_prop_info_set_range_uint32.9f	:= LINKSRC = mac_prop_info.9f
+
+mac_transceiver_info_set_present.9f	:= LINKSRC = mac_transceiver.info.9f
+mac_transceiver_info_set_usable.9f	:= LINKSRC = mac_transceiver.info.9f
+
 mac_unregister.9f			:= LINKSRC = mac_register.9f
 
 makecom_g0.9f				:= LINKSRC = makecom.9f
diff --git a/usr/src/man/man9f/mac_transceiver_info.9f b/usr/src/man/man9f/mac_transceiver_info.9f
new file mode 100644
index 0000000000..56d3cdd258
--- /dev/null
+++ b/usr/src/man/man9f/mac_transceiver_info.9f
@@ -0,0 +1,93 @@
+.\"
+.\" This file and its contents are supplied under the terms of the
+.\" Common Development and Distribution License ("CDDL"), version 1.0.
+.\" You may only use this file in accordance with the terms of version
+.\" 1.0 of the CDDL.
+.\"
+.\" A full copy of the text of the CDDL should have accompanied this
+.\" source.  A copy of the CDDL is also available via the Internet at
+.\" http://www.illumos.org/license/CDDL.
+.\"
+.\"
+.\" Copyright (c) 2017, Joyent, Inc.
+.\"
+.Dd Feb 21, 2017
+.Dt MAC_TRANSCEIVER_INFO 9F
+.Os
+.Sh NAME
+.Nm mac_transceiver_info ,
+.Nm mac_transceiver_info_set_present ,
+.Nm mac_transceiver_info_set_usable
+.Nd set MAC transceiver property information
+.Sh SYNOPSIS
+.In sys/mac_provider.h
+.Ft void
+.Fo mac_transceiver_info_set_present
+.Fa "mac_transceiver_info_t *infop"
+.Fa "boolean_t present"
+.Fc
+.Ft void
+.Fo mac_transceiver_info_set_usable
+.Fa "mac_transceiver_info_t *infop"
+.Fa "boolean_t usable"
+.Fc
+.Sh INTERFACE LEVEL
+.Sy Volatile -
+This interface is still evolving in illumos. API and ABI stability is
+not guaranteed.
+.Sh PARAMETERS
+.Bl -tag -width Fa
+.It Fa infop
+A pointer to an opaque structure obtained as an argument to the
+.Xr mct_info 9E
+entry point.
+.It Fa present
+A boolean that indicates whether the transceiver is present.
+.It Fa usable
+A boolean that indicates whether the transceiver is usable.
+.El
+.Sh DESCRIPTION
+The
+.Fn mac_transceiver_set_present
+and
+.Fn mac_transceiver_set_usable
+functions are used to set information about a transceiver as part of the
+.Xr mct_info 9E
+entry point to obtain information about a MAC transceiver. For more
+information and background, see the
+.Sy Transceiver Information Functions
+section of
+.Xr mac_capab_transceiver 9E .
+.Pp
+The
+.Fn mct_transceiver_set_present
+function sets whether or not the transceiver is present and plugged into
+the system. If the transceiver is not plugged in, then the function
+should be called with
+.Fa present set to
+.Dv B_FALSE ,
+otehrwise it should use
+.Dv B_TRUE .
+.Pp
+The
+.Fn mct_transceiver_set_usable
+function determines whether or not the device can use the transceiver.
+If the device cannot use the transceiver, then it should call the
+function with
+.Fa usable
+set to
+.Dv B_FALSE .
+Otherwise, it should use
+.Dv B_TRUE .
+If the transceiver is not present, then this function should not be
+called.
+.Sh CONTEXT
+These functions should be called in response to handling the
+.Fn mct_info 9E
+entry point for transceivers in
+.Sy kernel
+context.
+.Sh SEE ALSO
+.Xr mac 9E ,
+.Xr mac_capab_transceiver 9E ,
+.Xr mct_info 9E
diff --git a/usr/src/uts/common/Makefile.files b/usr/src/uts/common/Makefile.files
index 40a98cb3b6..75395bbd32 100644
--- a/usr/src/uts/common/Makefile.files
+++ b/usr/src/uts/common/Makefile.files
@@ -24,9 +24,8 @@
 # Copyright (c) 2011, 2014 by Delphix. All rights reserved.
 # Copyright (c) 2013 by Saso Kiselkov. All rights reserved.
 # Copyright 2015 Nexenta Systems, Inc.  All rights reserved.
-# Copyright 2016 Joyent, Inc.
 # Copyright 2016 Garrett D'Amore <garrett@damore.org>
-# Copyright 2016 Joyent, Inc.
+# Copyright (c) 2017, Joyent, Inc.
 # Copyright 2016 OmniTI Computer Consulting, Inc.  All rights reserved.
 # Copyright 2016 Hans Rosenfeld <rosenfeld@grumpf.hope-2000.org>
 #
@@ -2027,7 +2026,8 @@ IPRB_OBJS =	iprb.o
 
 # illumos-written source files
 IXGBE_OBJS =    ixgbe_buf.o ixgbe_debug.o ixgbe_gld.o ixgbe_log.o ixgbe_main.o \
-		ixgbe_osdep.o ixgbe_rx.o ixgbe_stat.o ixgbe_tx.o
+		ixgbe_osdep.o ixgbe_rx.o ixgbe_stat.o ixgbe_transceiver.o \
+		ixgbe_tx.o
 
 # Intel-written source files
 IXGBE_INTC_OBJS	=	ixgbe_82598.o ixgbe_82599.o ixgbe_api.o ixgbe_common.o \
diff --git a/usr/src/uts/common/io/dld/dld_drv.c b/usr/src/uts/common/io/dld/dld_drv.c
index e65e8d8161..b08781e6e8 100644
--- a/usr/src/uts/common/io/dld/dld_drv.c
+++ b/usr/src/uts/common/io/dld/dld_drv.c
@@ -20,7 +20,7 @@
  */
 /*
  * Copyright (c) 2005, 2010, Oracle and/or its affiliates. All rights reserved.
- * Copyright 2015, Joyent Inc.
+ * Copyright (c) 2017, Joyent, Inc.
  */
 
 /*
@@ -1308,6 +1308,103 @@ drv_ioc_secobj_unset(void *karg, intptr_t arg, int mode, cred_t *cred,
 	return (0);
 }
 
+/* ARGSUSED */
+static int
+drv_ioc_gettran(void *karg, intptr_t arg, int mode, cred_t *cred,
+    int *rvalp)
+{
+	int			ret = 0;
+	mac_perim_handle_t	mph = NULL;
+	dls_dl_handle_t 	dlh = NULL;
+	dls_link_t		*dlp = NULL;
+	dld_ioc_gettran_t	*dgt = karg;
+
+	if ((ret = mac_perim_enter_by_linkid(dgt->dgt_linkid, &mph)) != 0)
+		goto done;
+
+	if ((ret = dls_devnet_hold_link(dgt->dgt_linkid, &dlh, &dlp)) != 0)
+		goto done;
+
+	/*
+	 * Make sure that this link belongs to the zone.
+	 */
+	if (crgetzoneid(cred) != dls_devnet_getownerzid(dlh)) {
+		ret = ENOENT;
+		goto done;
+	}
+
+	if (dgt->dgt_tran_id == DLDIOC_GETTRAN_GETNTRAN) {
+		ret = mac_transceiver_count(dlp->dl_mh, &dgt->dgt_tran_id);
+	} else {
+		ret = mac_transceiver_info(dlp->dl_mh, dgt->dgt_tran_id,
+		    &dgt->dgt_present, &dgt->dgt_usable);
+	}
+
+done:
+	if (dlh != NULL && dlp != NULL) {
+		dls_devnet_rele_link(dlh, dlp);
+	}
+
+	if (mph != NULL) {
+		mac_perim_exit(mph);
+	}
+
+	return (ret);
+}
+
+/* ARGSUSED */
+static int
+drv_ioc_readtran(void *karg, intptr_t arg, int mode, cred_t *cred,
+    int *rvalp)
+{
+	int			ret = 0;
+	mac_perim_handle_t	mph = NULL;
+	dls_dl_handle_t 	dlh = NULL;
+	dls_link_t		*dlp = NULL;
+	dld_ioc_tranio_t	*dti = karg;
+	uint8_t			buf[256];
+	size_t			nr;
+
+	/*
+	 * Be strict for the moment
+	 */
+	if (dti->dti_nbytes != 256 || dti->dti_off != 0)
+		return (EINVAL);
+
+	if ((ret = mac_perim_enter_by_linkid(dti->dti_linkid, &mph)) != 0)
+		goto done;
+
+	if ((ret = dls_devnet_hold_link(dti->dti_linkid, &dlh, &dlp)) != 0)
+		goto done;
+
+	/*
+	 * Make sure that this link belongs to the zone.
+	 */
+	if (crgetzoneid(cred) != dls_devnet_getownerzid(dlh)) {
+		ret = ENOENT;
+		goto done;
+	}
+
+	bzero(buf, sizeof (buf));
+	if ((ret = mac_transceiver_read(dlp->dl_mh, dti->dti_tran_id,
+	    dti->dti_page, buf, dti->dti_nbytes, dti->dti_off, &nr)) == 0) {
+		dti->dti_nbytes = nr;
+		ret = ddi_copyout(buf, (void *)(uintptr_t)dti->dti_buf,
+		    sizeof (buf), mode);
+	}
+
+done:
+	if (dlh != NULL && dlp != NULL) {
+		dls_devnet_rele_link(dlh, dlp);
+	}
+
+	if (mph != NULL) {
+		mac_perim_exit(mph);
+	}
+
+	return (ret);
+}
+
 /*
  * Note that ioctls that modify links have a NULL di_priv_func(), as
  * privileges can only be checked after we know the class of the link being
@@ -1347,6 +1444,10 @@ static dld_ioc_info_t drv_ioc_list[] = {
 	    drv_ioc_getprop, NULL},
 	{DLDIOC_GETHWGRP, DLDCOPYINOUT, sizeof (dld_ioc_hwgrpget_t),
 	    drv_ioc_hwgrpget, NULL},
+	{DLDIOC_GETTRAN, DLDCOPYINOUT, sizeof (dld_ioc_gettran_t),
+	    drv_ioc_gettran, NULL },
+	{DLDIOC_READTRAN, DLDCOPYINOUT, sizeof (dld_ioc_tranio_t),
+	    drv_ioc_readtran, NULL }
 };
 
 typedef struct dld_ioc_modentry {
diff --git a/usr/src/uts/common/io/i40e/i40e_gld.c b/usr/src/uts/common/io/i40e/i40e_gld.c
index 28b4387594..ea0718dfe7 100644
--- a/usr/src/uts/common/io/i40e/i40e_gld.c
+++ b/usr/src/uts/common/io/i40e/i40e_gld.c
@@ -572,11 +572,38 @@ i40e_fill_rx_group(void *arg, mac_ring_type_t rtype, const int index,
 	infop->mgi_count = i40e->i40e_num_trqpairs;
 }
 
+static int
+i40e_transceiver_info(void *arg, uint_t id, mac_transceiver_info_t *infop)
+{
+	boolean_t present, usable;
+	i40e_t *i40e = arg;
+
+	if (id != 0 || infop == NULL)
+		return (EINVAL);
+
+	mutex_enter(&i40e->i40e_general_lock);
+	present = !!(i40e->i40e_hw_space.phy.link_info.link_info &
+	    I40E_AQ_MEDIA_AVAILABLE);
+	if (present) {
+		usable = !!(i40e->i40e_hw_space.phy.link_info.an_info &
+		    I40E_AQ_QUALIFIED_MODULE);
+	} else {
+		usable = B_FALSE;
+	}
+	mutex_exit(&i40e->i40e_general_lock);
+
+	mac_transceiver_info_set_usable(infop, usable);
+	mac_transceiver_info_set_present(infop, present);
+
+	return (0);
+}
+
 static boolean_t
 i40e_m_getcapab(void *arg, mac_capab_t cap, void *cap_data)
 {
 	i40e_t *i40e = arg;
 	mac_capab_rings_t *cap_rings;
+	mac_capab_transceiver_t *mct;
 
 	switch (cap) {
 	case MAC_CAPAB_HCKSUM: {
@@ -619,6 +646,20 @@ i40e_m_getcapab(void *arg, mac_capab_t cap, void *cap_data)
 			return (B_FALSE);
 		}
 		break;
+	case MAC_CAPAB_TRANSCEIVER:
+		mct = cap_data;
+
+		/*
+		 * Firmware doesn't have a great way of telling us in advance
+		 * whether we'd expect a SFF transceiver. As such, we always
+		 * advertise the support for this capability.
+		 */
+		mct->mct_flags = 0;
+		mct->mct_ntransceivers = 1;
+		mct->mct_info = i40e_transceiver_info;
+		mct->mct_read = NULL;
+
+		return (B_TRUE);
 	default:
 		return (B_FALSE);
 	}
diff --git a/usr/src/uts/common/io/ixgbe/ixgbe_gld.c b/usr/src/uts/common/io/ixgbe/ixgbe_gld.c
index e00202c1f2..9dff2fe2db 100644
--- a/usr/src/uts/common/io/ixgbe/ixgbe_gld.c
+++ b/usr/src/uts/common/io/ixgbe/ixgbe_gld.c
@@ -27,6 +27,7 @@
  * Copyright (c) 2008, 2010, Oracle and/or its affiliates. All rights reserved.
  * Copyright 2012 Nexenta Systems, Inc. All rights reserved.
  * Copyright 2016 OmniTI Computer Consulting, Inc. All rights reserved.
+ * Copyright (c) 2017, Joyent, Inc.
  */
 
 #include "ixgbe_sw.h"
@@ -280,6 +281,20 @@ ixgbe_m_getcapab(void *arg, mac_capab_t cap, void *cap_data)
 		}
 		break;
 	}
+	case MAC_CAPAB_TRANSCEIVER: {
+		mac_capab_transceiver_t *mct = cap_data;
+
+		/*
+		 * Rather than try and guess based on the media type whether or
+		 * not we have a transceiver we can read, we instead will let
+		 * the actual function calls figure that out for us.
+		 */
+		mct->mct_flags = 0;
+		mct->mct_ntransceivers = 1;
+		mct->mct_info = ixgbe_transceiver_info;
+		mct->mct_read = ixgbe_transceiver_read;
+		return (B_TRUE);
+	}
 	default:
 		return (B_FALSE);
 	}
diff --git a/usr/src/uts/common/io/ixgbe/ixgbe_main.c b/usr/src/uts/common/io/ixgbe/ixgbe_main.c
index 490439011c..a30cd4fb07 100644
--- a/usr/src/uts/common/io/ixgbe/ixgbe_main.c
+++ b/usr/src/uts/common/io/ixgbe/ixgbe_main.c
@@ -25,7 +25,7 @@
 
 /*
  * Copyright (c) 2008, 2010, Oracle and/or its affiliates. All rights reserved.
- * Copyright 2017, Joyent, Inc.
+ * Copyright (c) 2017, Joyent, Inc.
  * Copyright 2012 Nexenta Systems, Inc. All rights reserved.
  * Copyright (c) 2013 Saso Kiselkov. All rights reserved.
  * Copyright (c) 2013 OSN Online Service Nuernberg GmbH. All rights reserved.
@@ -3748,6 +3748,7 @@ ixgbe_sfp_check(void *arg)
 	struct ixgbe_hw *hw = &ixgbe->hw;
 
 	mutex_enter(&ixgbe->gen_lock);
+	(void) hw->phy.ops.identify_sfp(hw);
 	if (eicr & IXGBE_EICR_GPI_SDP1_BY_MAC(hw)) {
 		/* clear the interrupt */
 		IXGBE_WRITE_REG(hw, IXGBE_EICR, IXGBE_EICR_GPI_SDP1_BY_MAC(hw));
diff --git a/usr/src/uts/common/io/ixgbe/ixgbe_sw.h b/usr/src/uts/common/io/ixgbe/ixgbe_sw.h
index 6cd03d571d..0a40284416 100644
--- a/usr/src/uts/common/io/ixgbe/ixgbe_sw.h
+++ b/usr/src/uts/common/io/ixgbe/ixgbe_sw.h
@@ -857,6 +857,10 @@ void ixgbe_fill_group(void *arg, mac_ring_type_t, const int,
 int ixgbe_rx_ring_intr_enable(mac_intr_handle_t);
 int ixgbe_rx_ring_intr_disable(mac_intr_handle_t);
 
+int ixgbe_transceiver_info(void *, uint_t, mac_transceiver_info_t *);
+int ixgbe_transceiver_read(void *, uint_t, uint_t, void *, size_t, off_t,
+    size_t *);
+
 /*
  * Function prototypes in ixgbe_gld.c
  */
diff --git a/usr/src/uts/common/io/ixgbe/ixgbe_transceiver.c b/usr/src/uts/common/io/ixgbe/ixgbe_transceiver.c
new file mode 100644
index 0000000000..28dee66ff6
--- /dev/null
+++ b/usr/src/uts/common/io/ixgbe/ixgbe_transceiver.c
@@ -0,0 +1,169 @@
+/*
+ * This file and its contents are supplied under the terms of the
+ * Common Development and Distribution License ("CDDL"), version 1.0.
+ * You may only use this file in accordance with the terms of version
+ * 1.0 of the CDDL.
+ *
+ * A full copy of the text of the CDDL should have accompanied this
+ * source.  A copy of the CDDL is also available via the Internet at
+ * http://www.illumos.org/license/CDDL.
+ */
+
+/*
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+
+/*
+ * Routines to get access to the phy and transceiver that require routines and
+ * definitions that aren't part of the common ixgbe API.
+ */
+
+#include "ixgbe_sw.h"
+#include "ixgbe_phy.h"
+
+static int
+ixgbe_transceiver_is_8472(ixgbe_t *ixgbe, boolean_t *valp)
+{
+	int32_t ret;
+	uint8_t rev, swap;
+	struct ixgbe_hw *hw = &ixgbe->hw;
+
+	ASSERT(MUTEX_HELD(&ixgbe->gen_lock));
+	if (hw->phy.ops.read_i2c_eeprom == NULL)
+		return (ENOTSUP);
+
+	ret = hw->phy.ops.read_i2c_eeprom(hw, IXGBE_SFF_SFF_8472_COMP, &rev);
+	if (ret != 0)
+		return (EIO);
+
+	ret = hw->phy.ops.read_i2c_eeprom(hw, IXGBE_SFF_SFF_8472_SWAP, &swap);
+	if (ret != 0)
+		return (EIO);
+
+	if (swap & IXGBE_SFF_ADDRESSING_MODE) {
+		ixgbe_log(ixgbe, "transceiver requires unsupported address "
+		    "change for page 0xa2. Access will only be allowed to "
+		    "page 0xa0.");
+	}
+
+	if (rev == IXGBE_SFF_SFF_8472_UNSUP ||
+	    (swap & IXGBE_SFF_ADDRESSING_MODE)) {
+		*valp = B_FALSE;
+	} else {
+		*valp = B_TRUE;
+	}
+
+	return (0);
+}
+
+/*
+ * Note, we presume that the mac perimeter is held during these calls. As such,
+ * we rely on that for guaranteeing that only one thread is calling the i2c
+ * routines at any time.
+ */
+int
+ixgbe_transceiver_info(void *arg, uint_t id, mac_transceiver_info_t *infop)
+{
+	ixgbe_t *ixgbe = arg;
+	struct ixgbe_hw *hw = &ixgbe->hw;
+	boolean_t present, usable, is8472;
+
+	if (id != 0 || infop == NULL)
+		return (EINVAL);
+
+	mutex_enter(&ixgbe->gen_lock);
+	if (ixgbe_get_media_type(&ixgbe->hw) == ixgbe_media_type_copper) {
+		mutex_exit(&ixgbe->gen_lock);
+		return (ENOTSUP);
+	}
+
+	/*
+	 * Make sure we have the latest sfp information. This is especially
+	 * important if the SFP is removed as that doesn't trigger interrupts in
+	 * our current configuration.
+	 */
+	(void) hw->phy.ops.identify_sfp(hw);
+	if (hw->phy.type == ixgbe_phy_none ||
+	    (hw->phy.type == ixgbe_phy_unknown &&
+	    hw->phy.sfp_type == ixgbe_sfp_type_not_present)) {
+		present = B_FALSE;
+		usable = B_FALSE;
+	} else {
+		present = B_TRUE;
+		usable = hw->phy.type != ixgbe_phy_sfp_unsupported;
+	}
+
+	mutex_exit(&ixgbe->gen_lock);
+
+	mac_transceiver_info_set_present(infop, present);
+	mac_transceiver_info_set_usable(infop, usable);
+
+	return (0);
+}
+
+/*
+ * Note, we presume that the mac perimeter is held during these calls. As such,
+ * we rely on that for guaranteeing that only one thread is calling the i2c
+ * routines at any time.
+ */
+int
+ixgbe_transceiver_read(void *arg, uint_t id, uint_t page, void *bp,
+    size_t nbytes, off_t offset, size_t *nread)
+{
+	ixgbe_t *ixgbe = arg;
+	struct ixgbe_hw *hw = &ixgbe->hw;
+	uint8_t *buf = bp;
+	size_t i;
+	boolean_t is8472;
+
+	if (id != 0 || buf == NULL || nbytes == 0 || nread == NULL ||
+	    (page != 0xa0 && page != 0xa2) || offset < 0)
+		return (EINVAL);
+
+	/*
+	 * Both supported pages have a length of 256 bytes, ensure nothing asks
+	 * us to go beyond that.
+	 */
+	if (nbytes > 256 || offset >= 256 || (offset + nbytes > 256)) {
+		return (EINVAL);
+	}
+
+	mutex_enter(&ixgbe->gen_lock);
+	if (ixgbe_get_media_type(&ixgbe->hw) == ixgbe_media_type_copper) {
+		mutex_exit(&ixgbe->gen_lock);
+		return (ENOTSUP);
+	}
+
+	if (hw->phy.ops.read_i2c_eeprom == NULL) {
+		mutex_exit(&ixgbe->gen_lock);
+		return (ENOTSUP);
+	}
+
+	if (ixgbe_transceiver_is_8472(ixgbe, &is8472) != 0) {
+		mutex_exit(&ixgbe->gen_lock);
+		return (EIO);
+	}
+
+	if (!is8472 && page == 0xa2) {
+		mutex_exit(&ixgbe->gen_lock);
+		return (EINVAL);
+	}
+
+	for (i = 0; i < nbytes; i++, offset++, bp++) {
+		int32_t ret;
+
+		if (page == 0xa0) {
+			ret = hw->phy.ops.read_i2c_eeprom(hw, offset, bp);
+		} else {
+			ret = hw->phy.ops.read_i2c_sff8472(hw, offset, bp);
+		}
+		if (ret != 0) {
+			mutex_exit(&ixgbe->gen_lock);
+			return (EIO);
+		}
+	}
+	mutex_exit(&ixgbe->gen_lock);
+	*nread = i;
+
+	return (0);
+}
diff --git a/usr/src/uts/common/io/mac/mac.c b/usr/src/uts/common/io/mac/mac.c
index 978b4684e0..f7ab66f389 100644
--- a/usr/src/uts/common/io/mac/mac.c
+++ b/usr/src/uts/common/io/mac/mac.c
@@ -21,7 +21,7 @@
 
 /*
  * Copyright (c) 2005, 2010, Oracle and/or its affiliates. All rights reserved.
- * Copyright 2016 Joyent, Inc.
+ * Copyright (c) 2017, Joyent, Inc.
  * Copyright 2015 Garrett D'Amore <garrett@damore.org>
  */
 
@@ -8046,3 +8046,105 @@ mac_check_primary_relocation(mac_client_impl_t *mcip, boolean_t rxhw)
 	}
 	return (mcip);
 }
+
+void
+mac_transceiver_init(mac_impl_t *mip)
+{
+	if (mac_capab_get((mac_handle_t)mip, MAC_CAPAB_TRANSCEIVER,
+	    &mip->mi_transceiver)) {
+		/*
+		 * The driver set a flag that we don't know about. In this case,
+		 * we need to warn about that case and ignore this capability.
+		 */
+		if (mip->mi_transceiver.mct_flags != 0) {
+			dev_err(mip->mi_dip, CE_WARN, "driver set transceiver "
+			    "flags to invalid value: 0x%x, ignoring "
+			    "capability", mip->mi_transceiver.mct_flags);
+			bzero(&mip->mi_transceiver,
+			    sizeof (mac_capab_transceiver_t));
+		}
+	} else {
+			bzero(&mip->mi_transceiver,
+			    sizeof (mac_capab_transceiver_t));
+	}
+}
+
+int
+mac_transceiver_count(mac_handle_t mh, uint_t *countp)
+{
+	mac_impl_t *mip = (mac_impl_t *)mh;
+
+	ASSERT(MAC_PERIM_HELD(mh));
+
+	if (mip->mi_transceiver.mct_ntransceivers == 0)
+		return (ENOTSUP);
+
+	*countp = mip->mi_transceiver.mct_ntransceivers;
+	return (0);
+}
+
+int
+mac_transceiver_info(mac_handle_t mh, uint_t tranid, boolean_t *present,
+    boolean_t *usable)
+{
+	int ret;
+	mac_transceiver_info_t info;
+
+	mac_impl_t *mip = (mac_impl_t *)mh;
+
+	ASSERT(MAC_PERIM_HELD(mh));
+
+	if (mip->mi_transceiver.mct_info == NULL ||
+	    mip->mi_transceiver.mct_ntransceivers == 0)
+		return (ENOTSUP);
+
+	if (tranid >= mip->mi_transceiver.mct_ntransceivers)
+		return (EINVAL);
+
+	bzero(&info, sizeof (mac_transceiver_info_t));
+	if ((ret = mip->mi_transceiver.mct_info(mip->mi_driver, tranid,
+	    &info)) != 0) {
+		return (ret);
+	}
+
+	*present = info.mti_present;
+	*usable = info.mti_usable;
+	return (0);
+}
+
+int
+mac_transceiver_read(mac_handle_t mh, uint_t tranid, uint_t page, void *buf,
+    size_t nbytes, off_t offset, size_t *nread)
+{
+	int ret;
+	size_t nr;
+	mac_impl_t *mip = (mac_impl_t *)mh;
+
+	ASSERT(MAC_PERIM_HELD(mh));
+
+	if (mip->mi_transceiver.mct_read == NULL)
+		return (ENOTSUP);
+
+	if (tranid >= mip->mi_transceiver.mct_ntransceivers)
+		return (EINVAL);
+
+	/*
+	 * All supported pages today are 256 bytes wide. Make sure offset +
+	 * nbytes never exceeds that.
+	 */
+	if (offset < 0 || offset >= 256 || nbytes > 256 ||
+	    offset + nbytes > 256)
+		return (EINVAL);
+
+	if (nread == NULL)
+		nread = &nr;
+	ret = mip->mi_transceiver.mct_read(mip->mi_driver, tranid, page, buf,
+	    nbytes, offset, nread);
+	if (ret == 0 && *nread > nbytes) {
+		dev_err(mip->mi_dip, CE_PANIC, "driver wrote %ld bytes into "
+		    "%ld byte sized buffer, possible memory corruption",
+		    *nread, nbytes);
+	}
+
+	return (ret);
+}
diff --git a/usr/src/uts/common/io/mac/mac_provider.c b/usr/src/uts/common/io/mac/mac_provider.c
index beb63937ed..610a75ab19 100644
--- a/usr/src/uts/common/io/mac/mac_provider.c
+++ b/usr/src/uts/common/io/mac/mac_provider.c
@@ -357,6 +357,8 @@ mac_register(mac_register_t *mregp, mac_handle_t *mhp)
 
 	mac_addr_factory_init(mip);
 
+	mac_transceiver_init(mip);
+
 	/*
 	 * Enforce the virtrualization level registered.
 	 */
@@ -1520,3 +1522,17 @@ mac_lso_get(mblk_t *mp, uint32_t *mss, uint32_t *flags)
 			*mss = (uint32_t)DB_LSOMSS(mp);
 	}
 }
+
+void
+mac_transceiver_info_set_present(mac_transceiver_info_t *infop,
+    boolean_t present)
+{
+	infop->mti_present = present;
+}
+
+void
+mac_transceiver_info_set_usable(mac_transceiver_info_t *infop,
+    boolean_t usable)
+{
+	infop->mti_usable = usable;
+}
diff --git a/usr/src/uts/common/mapfiles/mac.mapfile b/usr/src/uts/common/mapfiles/mac.mapfile
index 30462f80d5..3ffbee8563 100644
--- a/usr/src/uts/common/mapfiles/mac.mapfile
+++ b/usr/src/uts/common/mapfiles/mac.mapfile
@@ -10,7 +10,7 @@
 #
 
 #
-# Copyright 2016 Joyent, Inc.
+# Copyright (c) 2017, Joyent, Inc.
 #
 
 #
@@ -49,6 +49,9 @@ SYMBOL_SCOPE {
 	mac_register				{ FLAGS = EXTERN };
 	mac_rx					{ FLAGS = EXTERN };
 	mac_rx_ring				{ FLAGS = EXTERN };
+	mac_transceiver_info_set_present	{ FLAGS = EXTERN };
+	mac_transceiver_info_set_type		{ FLAGS = EXTERN };
+	mac_transceiver_info_set_usable		{ FLAGS = EXTERN };
 	mac_tx_ring_update			{ FLAGS = EXTERN };
 	mac_tx_update				{ FLAGS = EXTERN };
 	mac_unregister				{ FLAGS = EXTERN };
diff --git a/usr/src/uts/common/sys/dld.h b/usr/src/uts/common/sys/dld.h
index 4cd93be56e..5c15ca154e 100644
--- a/usr/src/uts/common/sys/dld.h
+++ b/usr/src/uts/common/sys/dld.h
@@ -21,7 +21,7 @@
 /*
  * Copyright 2010 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
- * Copyright 2011 Joyent, Inc.  All rights reserved.
+ * Copyright (c) 2017, Joyent, Inc.
  */
 
 #ifndef	_SYS_DLD_H
@@ -30,7 +30,7 @@
 /*
  * Data-Link Driver ioctl interfaces.
  *
- * Note that the datastructures defined here define an ioctl interface
+ * Note that the data structures defined here define an ioctl interface
  * that is shared betwen user and kernel space.  The dld driver thus
  * assumes that the structures have identical layout and size when
  * compiled in either IPL32 or LP64.
@@ -317,6 +317,27 @@ typedef struct dld_hwgrpinfo {
 	char	dhi_clnts[MAXCLIENTNAMELEN];
 } dld_hwgrpinfo_t;
 
+#define	DLDIOC_GETTRAN		DLDIOC(0x1e)
+
+#define	DLDIOC_GETTRAN_GETNTRAN	UINT32_MAX
+
+typedef struct dld_ioc_gettran {
+	datalink_id_t		dgt_linkid;
+	uint_t			dgt_tran_id;
+	boolean_t		dgt_present;
+	boolean_t		dgt_usable;
+} dld_ioc_gettran_t;
+
+#define	DLDIOC_READTRAN		DLDIOC(0x1f)
+typedef struct dld_ioc_tranio {
+	datalink_id_t	dti_linkid;
+	uint_t		dti_tran_id;
+	uint_t		dti_page;
+	uint_t		dti_nbytes;
+	uint_t		dti_off;
+	uint64_t	dti_buf;
+} dld_ioc_tranio_t;
+
 #if _LONG_LONG_ALIGNMENT == 8 && _LONG_LONG_ALIGNMENT_32 == 4
 #pragma pack()
 #endif
diff --git a/usr/src/uts/common/sys/mac.h b/usr/src/uts/common/sys/mac.h
index 79f2e85b35..5d572bdda6 100644
--- a/usr/src/uts/common/sys/mac.h
+++ b/usr/src/uts/common/sys/mac.h
@@ -21,7 +21,7 @@
 
 /*
  * Copyright (c) 2005, 2010, Oracle and/or its affiliates. All rights reserved.
- * Copyright 2016 Joyent, Inc.
+ * Copyright (c) 2017, Joyent, Inc.
  * Copyright (c) 2015 Garrett D'Amore <garrett@damore.org>
  */
 
diff --git a/usr/src/uts/common/sys/mac_impl.h b/usr/src/uts/common/sys/mac_impl.h
index 46293b1a74..1bbaf9810b 100644
--- a/usr/src/uts/common/sys/mac_impl.h
+++ b/usr/src/uts/common/sys/mac_impl.h
@@ -20,7 +20,7 @@
  */
 /*
  * Copyright (c) 2005, 2010, Oracle and/or its affiliates. All rights reserved.
- * Copyright 2015, Joyent, Inc.
+ * Copyright (c) 2017, Joyent, Inc.
  */
 
 #ifndef	_SYS_MAC_IMPL_H
@@ -475,6 +475,11 @@ struct mac_impl_s {
 
 	mac_ring_handle_t	mi_default_tx_ring;
 
+	/*
+	 * Transceiver capabilities. SL protected.
+	 */
+	mac_capab_transceiver_t	mi_transceiver;
+
 	/*
 	 * MAC address list. SL protected.
 	 */
@@ -911,6 +916,19 @@ extern mac_bridge_rx_t mac_bridge_rx_cb;
 extern mac_bridge_ref_t mac_bridge_ref_cb;
 extern mac_bridge_ls_t mac_bridge_ls_cb;
 
+/*
+ * MAC Transceiver related functions
+ */
+struct mac_transceiver_info {
+	boolean_t		mti_present;
+	boolean_t		mti_usable;
+};
+
+extern void mac_transceiver_init(mac_impl_t *);
+extern int mac_transceiver_count(mac_handle_t, uint_t *);
+extern int mac_transceiver_info(mac_handle_t, uint_t, boolean_t *, boolean_t *);
+extern int mac_transceiver_read(mac_handle_t, uint_t, uint_t, void *, size_t,
+    off_t, size_t *);
 
 #ifdef	__cplusplus
 }
diff --git a/usr/src/uts/common/sys/mac_provider.h b/usr/src/uts/common/sys/mac_provider.h
index 5f02451542..5a6eaed98b 100644
--- a/usr/src/uts/common/sys/mac_provider.h
+++ b/usr/src/uts/common/sys/mac_provider.h
@@ -21,7 +21,7 @@
 
 /*
  * Copyright (c) 2008, 2010, Oracle and/or its affiliates. All rights reserved.
- * Copyright 2015, Joyent, Inc.
+ * Copyright (c) 2017, Joyent, Inc.
  */
 
 #ifndef	_SYS_MAC_PROVIDER_H
@@ -108,7 +108,8 @@ typedef enum {
 	MAC_CAPAB_NO_ZCOPY	= 0x00100000, /* boolean only, no data */
 	MAC_CAPAB_LEGACY	= 0x00200000, /* data is mac_capab_legacy_t */
 	MAC_CAPAB_VRRP		= 0x00400000, /* data is mac_capab_vrrp_t */
-	MAC_CAPAB_OVERLAY	= 0x00800000  /* boolean only, no data */
+	MAC_CAPAB_OVERLAY	= 0x00800000, /* boolean only, no data */
+	MAC_CAPAB_TRANSCEIVER	= 0x01000000  /* mac_capab_transciever_t */
 } mac_capab_t;
 
 /*
@@ -433,6 +434,19 @@ typedef struct mac_capab_vrrp_s {
 	int		mcv_af;
 } mac_capab_vrrp_t;
 
+/*
+ * Transceiver capability
+ */
+typedef struct mac_transceiver_info mac_transceiver_info_t;
+
+typedef struct mac_capab_transceiver {
+	uint_t	mct_flags;
+	uint_t	mct_ntransceivers;
+	int	(*mct_info)(void *, uint_t, mac_transceiver_info_t *);
+	int	(*mct_read)(void *, uint_t, uint_t, void *, size_t, off_t,
+		    size_t *);
+} mac_capab_transceiver_t;
+
 /*
  * MAC registration interface
  */
@@ -543,6 +557,13 @@ extern void			mac_hcksum_set(mblk_t *, uint32_t, uint32_t,
 
 extern void			mac_lso_get(mblk_t *, uint32_t *, uint32_t *);
 
+extern void			mac_transceiver_info_set_present(
+				    mac_transceiver_info_t *,
+				    boolean_t);
+extern void			mac_transceiver_info_set_usable(
+				    mac_transceiver_info_t *,
+				    boolean_t);
+
 #endif	/* _KERNEL */
 
 #ifdef	__cplusplus
-- 
2.21.0

