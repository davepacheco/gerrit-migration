From e81e7baf66169974cac06b703d68386f191c02f1 Mon Sep 17 00:00:00 2001
From: Robert Mustacchi <rm@joyent.com>
Date: Mon, 18 Jun 2018 17:33:48 -0400
Subject: [PATCH] OS-6847 vxlan header allocation should think about mblk
 chains

---
 usr/src/uts/common/io/overlay/overlay.c       |  2 +-
 .../common/io/overlay/plugins/overlay_vxlan.c | 48 ++++++++++++++-----
 2 files changed, 36 insertions(+), 14 deletions(-)

diff --git a/usr/src/uts/common/io/overlay/overlay.c b/usr/src/uts/common/io/overlay/overlay.c
index 80013311fb..6862f764b9 100644
--- a/usr/src/uts/common/io/overlay/overlay.c
+++ b/usr/src/uts/common/io/overlay/overlay.c
@@ -1156,7 +1156,7 @@ overlay_m_tx(void *arg, mblk_t *mp_chain)
 			goto out;
 		}
 
-		ep->b_cont = mp;
+		ASSERT(ep->b_cont == mp || ep == mp);
 		ret = overlay_mux_tx(odd->odd_mux, &hdr, ep);
 		if (ret != 0)
 			goto out;
diff --git a/usr/src/uts/common/io/overlay/plugins/overlay_vxlan.c b/usr/src/uts/common/io/overlay/plugins/overlay_vxlan.c
index 8b4e4ecb42..18dd9fdb0e 100644
--- a/usr/src/uts/common/io/overlay/plugins/overlay_vxlan.c
+++ b/usr/src/uts/common/io/overlay/plugins/overlay_vxlan.c
@@ -10,7 +10,7 @@
  */
 
 /*
- * Copyright 2015 Joyent, Inc.
+ * Copyright 2018 Joyent, Inc.
  */
 
 /*
@@ -58,6 +58,20 @@ static uint16_t vxlan_defport = IPPORT_VXLAN;
  */
 boolean_t vxlan_fanout = B_TRUE;
 
+/*
+ * This represents the size in bytes that we want to allocate when allocating a
+ * vxlan header block. This is intended such that lower levels can try and use
+ * the message block that we allocate for the IP and UPD header. The hope is
+ * that even if this is tunneled, that this is enough space.
+ *
+ * The vxlan_noalloc_min value represents the minimum amount of space we need to
+ * consider not allocating a message block and just passing it down the stack in
+ * this form. This number assumes that we have a VLAN tag, so 18 byte Ethernet
+ * header, 20 byte IP header, 8 byte UDP header, and 8 byte VXLAN header.
+ */
+uint_t vxlan_alloc_size = 128;
+uint_t vxlan_noalloc_min = 54;
+
 static const char *vxlan_props[] = {
 	"vxlan/listen_ip",
 	"vxlan/listen_port",
@@ -150,22 +164,30 @@ vxlan_o_encap(void *arg, mblk_t *mp, ovep_encap_info_t *einfop,
 
 	ASSERT(einfop->ovdi_id < (1 << 24));
 
-	/*
-	 * This allocation could get hot. We may want to have a good way to
-	 * cache and handle this allocation the same way that IP does with
-	 * keeping around a message block per entry, or basically treating this
-	 * as an immutable message block in the system. Basically freemsg() will
-	 * be a nop, but we'll do the right thing with respect to the rest of
-	 * the chain.
-	 */
-	ob = allocb(VXLAN_HDR_LEN, 0);
-	if (ob == NULL)
-		return (ENOMEM);
+	if (DB_REF(mp) != 1 || mp->b_rptr - vxlan_noalloc_min < DB_BASE(mp)) {
+		/*
+		 * This allocation could get hot. We may want to have a good
+		 * way to cache and handle this allocation the same way that IP
+		 * does with keeping around a message block per entry, or
+		 * basically treating this as an immutable message block in the
+		 * system. Basically freemsg() will be a nop, but we'll do the
+		 * right thing with respect to the rest of the chain.
+		 */
+		ob = allocb(vxlan_alloc_size, 0);
+		if (ob == NULL)
+			return (ENOMEM);
+
+		ob->b_wptr = DB_LIM(ob);
+		ob->b_rptr = ob->b_wptr - VXLAN_HDR_LEN;
+		ob->b_cont = mp;
+	} else {
+		ob = mp;
+		mp->b_rptr -= VXLAN_HDR_LEN;
+	}
 
 	vxh = (vxlan_hdr_t *)ob->b_rptr;
 	vxh->vxlan_flags = ntohl(VXLAN_F_VDI);
 	vxh->vxlan_id = htonl((uint32_t)einfop->ovdi_id << VXLAN_ID_SHIFT);
-	ob->b_wptr += VXLAN_HDR_LEN;
 	*outp = ob;
 
 	return (0);
-- 
2.21.0

