commit d5762ef145d54f15a3080651ae8addb10cf0e404 (refs/changes/87/3687/3)
Author: Nick Zivkovic <nick.zivkovic@joyent.com>
Date:   2018-03-19T21:35:15+00:00 (1 year, 7 months ago)
    
    TRITON-255 net-agent must first admit that it has a problem

diff --git a/bin/net-agent.js b/bin/net-agent.js
index 5b009d2..aa0bb69 100644
--- a/bin/net-agent.js
+++ b/bin/net-agent.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2015, Joyent, Inc.
+ * Copyright 2016 Joyent, Inc.
  */
 
 /*
@@ -33,11 +33,6 @@ var sdcConfig;
 var agentConfig;
 var sysinfo;
 
-process.on('uncaughtException', function (e) {
-    console.error('uncaught exception:' + e.message);
-    console.log(e.stack);
-});
-
 function loadConfig(callback) {
     var configPath = '/opt/smartdc/agents/etc/net-agent.config.json';
 
diff --git a/lib/napi-client.js b/lib/napi-client.js
index a17ea24..37faaac 100644
--- a/lib/napi-client.js
+++ b/lib/napi-client.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2014, Joyent, Inc.
+ * Copyright 2016 Joyent, Inc.
  */
 
 /*
@@ -44,7 +44,7 @@ function NapiClient(options) {
  *
  * 1. NIC was removed from the VM or VM provision has failed (destroy)
  * 2. NIC doesn't exist and needs to be added (create)
- * 3. NIC exists and has to be udpated (update)
+ * 3. NIC exists and has to be updated (update)
  * 4. NIC exists and but has not changed, no need to do anything (noop)
  */
 NapiClient.prototype.updateNics = function (vm, nics, callback) {
@@ -127,7 +127,7 @@ NapiClient.prototype.updateNic = function (vm, newNic, napiNic, callback) {
 
     this.client.updateNic(nic.mac, nic, function (err) {
         if (err) {
-            log.error(err, 'Could not udpate NIC %s for VM %s',
+            log.error(err, 'Could not update NIC %s for VM %s',
                 nic.mac, vm.uuid);
             return callback(err);
         }
@@ -171,17 +171,15 @@ function _nicChanged(cur, old) {
     var fields = [ 'cn_uuid', 'vlan_id', 'nic_tag', 'primary', 'ip', 'netmask',
         'state' ].concat(ANTI_SPOOF_FIELDS);
     var field;
-    var diff = false;
 
     for (var i = 0; i < fields.length; i++) {
         field = fields[i];
         if (cur[field] !== old[field]) {
-            diff = true;
-            break;
+            return true;
         }
     }
 
-    return diff;
+    return false;
 }
 
 
diff --git a/lib/net-agent.js b/lib/net-agent.js
index 64604a2..58dcb02 100644
--- a/lib/net-agent.js
+++ b/lib/net-agent.js
@@ -5,15 +5,58 @@
  */
 
 /*
- * Copyright (c) 2014, Joyent, Inc.
+ * Copyright 2016 Joyent, Inc.
  */
 
 /*
- * net-agent.js
+ * Net-Agent and NAPI
+ * ==================
+ *
+ * VM Change Events
+ * ----------------
+ *
+ * Net-agent's job is to inform NAPI of any changes to any NICs that result
+ * from VM-related events. For instance, if a VM gets destroyed (either by
+ * VMAPI or an operator tool like vmadm or zoneadm) net-agent is responsible
+ * for telling NAPI that the NIC that used to belong to that VM should be
+ * destroyed.
+ *
+ * Net-agent responds to 4 kinds of changes to a VM:
+ *
+ *  - The VM's zone_state has changed
+ *  - The VM's zone configurations XML file has changed
+ *  - The VM's state has changed
+ *  - The VM has been destroyed
+ *
+ * Whenever a change is detected, net-agent walks its internal list of VM
+ * objects (which also contains the NIC info) and pushes the NIC objects to
+ * NAPI, forcing NAPI to overwrite the current NIC object with the same MAC
+ * address.
+ *
+ * Net-Agent and VMs
+ * =================
+ *
+ * Net-Agent loads all of VMs that are located on the same CN as it is, by
+ * executing `vmadm lookup`, and storing the VM objects in memory. This set of
+ * VM objects is known as the sample.
+ *
+ * Net-Agent listens for VM events by executing a child `zoneevent` command,
+ * and processing the JSON that it produces on stdout. `zoneevent` emits output
+ * whenever a property of the zone has changed. Note that it does not report
+ * higher-level VM properties (that are used by vmadm and vmapi).
+ *
+ * As Net-Agent receives these change events, it updates the changed properties
+ * of the VM objects in the sample. However, it is possible that one of the
+ * change-events does not make it to net-agent. In order to mitigate the drift
+ * between net-agent's picture of reality, and reality itself, net-agent also
+ * does a full `vmadm lookup` every minute, and emits state-change events if it
+ * detects a difference.
  */
 
+var assert = require('assert-plus');
 var async = require('async');
 var backoff = require('backoff');
+var vmadm = require('vmadm');
 
 var VM = require('./vm');
 var NAPI = require('./napi-client');
@@ -89,7 +132,7 @@ NetAgent.prototype.initializeEventWatcher = function () {
     var log = this.log;
     var eventWatcher = this.eventWatcher;
 
-    eventWatcher.on('state', function (uuid, state) {
+    eventWatcher.on('state', function vm_state_event(uuid, state) {
         log.debug('state event for %s state: %s', uuid, state);
         self.pushSample({
             uuid: uuid,
@@ -97,7 +140,7 @@ NetAgent.prototype.initializeEventWatcher = function () {
         });
     });
 
-    eventWatcher.on('zone_state', function (uuid, zone_state) {
+    eventWatcher.on('zone_state', function zone_state_event(uuid, zone_state) {
         log.debug('zone_state event for %s newstate: %s', uuid, zone_state);
         self.pushSample({
             uuid: uuid,
@@ -105,7 +148,7 @@ NetAgent.prototype.initializeEventWatcher = function () {
         });
     });
 
-    eventWatcher.on('zone_xml', function (uuid) {
+    eventWatcher.on('zone_xml', function zone_xml_event(uuid) {
         log.debug('fs.watch event on /etc/zones for %s', uuid);
         self.pushSample({
             uuid: uuid,
@@ -113,7 +156,7 @@ NetAgent.prototype.initializeEventWatcher = function () {
         });
     });
 
-    eventWatcher.on('destroyed', function (uuid) {
+    eventWatcher.on('destroyed', function zone_destroyed_event(uuid) {
         var vm = self.sample[uuid];
         if (!vm) {
             log.warn('VM %s appears to have gone away but ' +
@@ -123,10 +166,13 @@ NetAgent.prototype.initializeEventWatcher = function () {
 
         log.info('Found a destroyed VM %s', uuid);
         vm.state = 'destroyed';
-        self.pushSample({ uuid: uuid, cachedVm: vm });
+        self.pushSample({
+            uuid: uuid,
+            cachedVm: vm
+        });
     });
 
-    eventWatcher.on('err', function (err) {
+    eventWatcher.on('err', function zone_err_event(err) {
         log.error(err, 'eventWatcher saw en error');
     });
 };
@@ -140,7 +186,6 @@ NetAgent.prototype.setSample = function (sample) {
     });
 };
 
-
 /*
  * On startup, sendFullSample updates all NICs for all VMs on the server. This
  * will be a blocking call before we turn on the event listeners so we allow
@@ -199,16 +244,14 @@ NetAgent.prototype.sendSample = function (options, callback) {
         this.eventWatcher.removeState(options.uuid);
 
         self._updateVmNics(options, callback);
-
     } else {
         this.updateSample(options, function (err, sample) {
             if (err) {
                 log.error(err, 'updateSample failed, cannot sendSample');
                 callback(err);
-
             } else if (Object.keys(sample).length === 0) {
                 log.warn('empty sample returned by vmadm lookup');
-                 callback();
+                callback();
             } else {
                 self.eventWatcher.updateState(sample);
                 self.setSample(sample);
@@ -292,7 +335,6 @@ NetAgent.prototype.pushSample = function (options) {
     if (this.queues[uuid] === undefined) {
         this.queues[uuid] = this.createQueue(uuid);
     }
-
     this.queues[uuid].push(options);
 };
 
@@ -301,6 +343,8 @@ NetAgent.prototype.pushSample = function (options) {
  * Retries an update operation.
  */
 NetAgent.prototype.retryUpdate = function (fn, options, callback) {
+    assert.object(options);
+    assert.uuid(options.uuid);
     var log = this.log;
     var retryOpts = { initialDelay: 2000, maxDelay: 64000 };
 
@@ -326,17 +370,16 @@ NetAgent.prototype.retryUpdate = function (fn, options, callback) {
         return (_log);
     }
 
-    var retry = backoff.call(fn, function (err) {
+    var retry = backoff.call(fn, function backoffCallCb(err) {
         retry.removeAllListeners('backoff');
 
-        var attempts = retry.getResults().length;
+        var attempts = retry.getNumRetries();
 
         if (err) {
             log.error({ uuid: options.uuid },
                 'Could not retry operation after %d attempts', attempts);
             return callback(err);
         }
-
         return callback();
     });
 
@@ -359,9 +402,9 @@ NetAgent.prototype.createQueue = function (uuid) {
     var self = this;
     var log = this.log;
 
-    var queue = async.queue(function (opts, callback) {
+    var queue = async.queue(function qcb(opts, callback) {
         var fn = self.sendSample.bind(self, opts);
-        self.retryUpdate(fn, opts, function (err) {
+        self.retryUpdate(fn, opts, function retryUpdateCb(err) {
             if (err) {
                 log.error(err, 'Error updating NICs %', uuid);
                 return callback(err);
@@ -416,6 +459,7 @@ NetAgent.prototype.createQueue = function (uuid) {
 NetAgent.prototype.updateSample = function (options, callback) {
     if (!this._sampleQueue)
         this._sampleQueue = async.queue(updateSample.bind(this), 8);
+
     this._sampleQueue.push(options, callback);
 };
 
@@ -441,7 +485,7 @@ function updateSample(options, callback) {
 
         log.debug('Starting updateSample ' + query);
 
-        VM.list(searchOpts, function (err, vmobjs) {
+        vmadm.lookup(searchOpts, { log: log }, function (err, vmobjs) {
             var vmobj;
             var running = 0;
             var notRunning = 0;
@@ -450,7 +494,6 @@ function updateSample(options, callback) {
             if (err) {
                 log.error(err, 'ERROR: unable update VM list');
                 return cb(err);
-
             } else {
                 for (vmobj in vmobjs) {
                     vmobj = vmobjs[vmobj];
@@ -471,7 +514,7 @@ function updateSample(options, callback) {
                     notRunning: notRunning,
                     nonInventory: nonInventory
                 };
-                log.trace(lookupResults, 'Lookup query results');
+                log.info(lookupResults, 'Lookup query results');
 
                 return cb(null);
             }
@@ -501,7 +544,7 @@ function updateSample(options, callback) {
     var retry = backoff.call(lookup, function (err) {
         retry.removeAllListeners('backoff');
 
-        var attempts = retry.getResults().length;
+        var attempts = retry.getNumRetries();
         if (err) {
             log.error('Could not updateSample after %d attempts', attempts);
             return callback(err);
diff --git a/lib/vm.js b/lib/vm.js
index 2f7bbf7..6b0bc48 100644
--- a/lib/vm.js
+++ b/lib/vm.js
@@ -21,10 +21,13 @@ var util = require('util');
 var fs = require('fs');
 var path = require('path');
 var EventEmitter = require('events').EventEmitter;
+var vmadm = require('vmadm');
+var LineStream = require('lstream');
+var VError = require('verror');
+var forkexec = require('forkexec');
 
 var async = require('async');
 
-var VMADM = '/usr/sbin/vmadm';
 
 
 
@@ -38,44 +41,6 @@ function isLocal(vms, vm) {
     return null;
 }
 
-
-function listVMs(filter, fields, callback) {
-    if (!callback) {
-        callback = fields;
-        fields = undefined;
-    }
-
-    var args = ['lookup', '-j'];
-    for (var k in filter) {
-        args.push(k + '=' + filter[k]);
-    }
-    if (fields) {
-        args.push('-o', fields.join(','));
-    }
-
-    return execFile(VMADM, args, {maxBuffer: 32 * 1024 * 1024},
-        function (err, stdout, stderr) {
-
-        if (err) {
-            err.stdout = stdout;
-            err.stderr = stderr;
-            return callback(err);
-        }
-
-        var vms;
-
-        try {
-            vms = JSON.parse(stdout);
-        } catch (jsonErr) {
-            jsonErr.stdout = stdout;
-            return callback(jsonErr);
-        }
-
-        return callback(null, vms);
-    });
-}
-
-
 // These are the events being watched by the zoneevent watcher. When zones
 // don't switch to these zone_states we ignore them
 var watchEvents = {
@@ -83,7 +48,7 @@ var watchEvents = {
     running: true
 };
 
-var STATE_WATCHER_TIMEOUT = 30000;
+var STATE_WATCHER_TIMEOUT = 60 * 1000;
 
 /*
  * The EventWatcher will emit these events:
@@ -128,7 +93,7 @@ EventWatcher.prototype.start = function () {
 EventWatcher.prototype.updateState = function (objs) {
     var self = this;
 
-    Object.keys(objs).forEach(function (uuid) {
+    Object.keys(objs).forEach(function foreachobjs(uuid) {
         self.vmStates[uuid] = {
             state: objs[uuid].state,
             zone_state: objs[uuid].zone_state
@@ -166,10 +131,6 @@ EventWatcher.prototype.startStateWatcher = function () {
         }
 
         vmobjs.forEach(function (vm) {
-            // Only use inventory vms
-            if (vm.do_not_inventory) {
-                return;
-            }
 
             // Don't emit when states stay the same
             var current = self.getState(vm.uuid);
@@ -191,14 +152,33 @@ EventWatcher.prototype.startStateWatcher = function () {
         setTimeout(lookup, STATE_WATCHER_TIMEOUT);
     }
 
-    var lookup = listVMs.bind(null,
-        {}, ['uuid', 'state', 'zone_state', 'do_not_inventory'], onLookup);
+    /*
+     * We get a list of all VMs that don't have the do_not_inventory flag set.
+     * This flag is used by tests and ops to get some things done. For example
+     * it is used by the migrator script to signal to SDC that events for the
+     * target VM should be ignored.
+     */
+    var lookup = vmadm.lookup.bind(null, {}, {
+        fields: [
+            'uuid',
+            'state',
+            'zone_state'],
+         log: log,
+         include_dni: false
+    }, onLookup);
 
     lookup();
 };
 
-
 EventWatcher.prototype.startZoneWatcher = function () {
+    /*
+     * sendFullSample is called in an infinite retry loop. We don't want to
+     * create a swarm of zoneevent processes. Therefore we simply return from
+     * this function, if we already have one such process running.
+     */
+    if (this.zoneeventWatcher !== null) {
+        return;
+    }
     var log = this.log;
     var self = this;
 
@@ -209,32 +189,45 @@ EventWatcher.prototype.startZoneWatcher = function () {
 
     log.info('zoneevent running with pid ' + watcher.pid);
 
-    function onData(data) {
-        log.trace('zone event: ', data.toString());
-
-        // There can be more than one event in a single data event
-        var events = data.toString().split('\n');
-        events.forEach(processEvent);
-    }
-
-    function processEvent(event) {
-        if (event === '') {
-            return;
+    var stdoutStream = new LineStream();
+    var stderrStream = new LineStream();
+    watcher.stdout.pipe(stdoutStream);
+    watcher.stderr.pipe(stderrStream);
+    stdoutStream.on('readable', function () {
+        var event, line;
+        while ((line = stdoutStream.read()) !== null) {
+            event = JSON.parse(line.toString());
+            log.info({ event: event }, 'new zone event');
+            if (watchEvents[event.newstate]) {
+                self.emit('zone_state', event.zonename, event.newstate);
+            }
         }
-
-        event = JSON.parse(event);
-
-        // Only updateSample when it is an event we're watching
-        if (watchEvents[event.newstate]) {
-            self.emit('zone_state', event.zonename, event.newstate);
+    });
+    stderrStream.on('readable', function () {
+        var line;
+        while ((line = stderrStream.read()) !== null) {
+            log.error('zone event stderr: ', line.toString());
         }
-    }
-
-    watcher.stdout.on('data', onData);
+    });
     watcher.stdin.end();
+    var stdout_ended = false;
+    var watcher_exited = false;
+    watcher.stdout.on('end', function () {
+        stdout_ended = true;
+        if (watcher_exited) {
+            log.warn('zoneevent watcher exited.');
+            watcher = null;
+            self.zoneeventWatcher = null;
+        }
+    });
     watcher.on('exit', function (code) {
-        log.warn('zoneevent watcher exited.');
-        watcher = null;
+        if (stdout_ended) {
+            log.warn('zoneevent watcher exited.');
+            watcher = null;
+            self.zoneeventWatcher = null;
+        } else {
+            watcher_exited = true;
+        }
     });
 };
 
@@ -354,27 +347,41 @@ EventWatcher.prototype.checkZoneConfigChanges = function () {
  * Double-checks if a VM is actually destroyed
  */
 function checkDestroyed(uuid, callback) {
-    var cmd = '/usr/sbin/zoneadm list -pc | grep ' + uuid + ' || true';
-    exec(cmd, [], function (exitStatus, stdout, stderr) {
-        if (exitStatus) {
-            return callback(new Error(stderr.toString()));
+    var argv = ['/usr/sbin/zoneadm', 'list', '-pc'];
+    var args = {
+        argv: argv,
+        includeStderr: true,
+        timeout: 0
+    };
+    forkexec.forkExecWait(args, function (err, info) {
+        if (err) {
+            return callback(err);
+        }
+        if (info.status !== 0) {
+            return callback(new VError('zoneadm exited %d: %s', info.stderr));
+        } else {
+            if (info.stdout.length === 0) {
+                return callback(null, true);
+            }
+            var finalOut = info.stdout.split('\n').filter(function (l) {
+                return (l.indexOf(uuid) !== -1);
+            });
+            if (finalOut.length > 0) {
+                return callback(null, false);
+            } else {
+                return callback(null, true);
+            }
         }
-
-        var destroyed = (stdout.toString().trim() === '');
-        return callback(null, destroyed);
     });
 }
 
-
 function createEventWatcher(options) {
     assert.ok(options.log, 'EventWatcher options.log');
-
     return new EventWatcher(options);
 }
 
 
 module.exports = {
     isLocal: isLocal,
-    list: listVMs,
     createEventWatcher: createEventWatcher
 };
diff --git a/package.json b/package.json
index b87288c..033c298 100644
--- a/package.json
+++ b/package.json
@@ -6,12 +6,18 @@
     "private": true,
     "dependencies": {
         "async": "0.1.18",
-        "backoff": "2.3.0",
+        "vasync": "^1.6.4",
+        "assert-plus": "^1.0.0",
+        "backoff": "2.5.0",
         "bunyan": "1.3.2",
         "sdc-bunyan-serializers": "git+https://github.com/joyent/sdc-bunyan-serializers.git#aefc119",
-        "nodeunit": "0.7.4",
         "restify": "2.7.0",
-        "sdc-clients": "git+https://github.com/joyent/node-sdc-clients.git#c962959"
+        "sdc-clients": "^9.5.0",
+        "vmadm": "1.0.0",
+        "lstream": "0.0.4",
+        "verror": "^1.6.1",
+        "jsprim": "^1.3.0",
+        "forkexec": "^1.1.0"
     },
     "sdcDependencies": {
         "config-agent": ">=1.3.0"
