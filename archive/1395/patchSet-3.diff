commit 91b0352471f02cc7c1ea7e2f1c4762326d1ab6b7 (refs/changes/95/1395/3)
Author: Todd Whiteman <todd.whiteman@joyent.com>
Date:   2017-02-09T12:59:05-08:00 (2 years, 8 months ago)
    
    DOCKER-893 Improve docker pull reliability

diff --git a/lib/images.js b/lib/images.js
index 03ced87..0481392 100644
--- a/lib/images.js
+++ b/lib/images.js
@@ -74,6 +74,15 @@ var IMGAPI_251_MIN_PLATFORM = {
     '6.5': '20120614T001014Z'
 };
 
+/*
+ * DOCKER-893: Maintain an in-memory image cache (just the image/layer metadata)
+ * for the docker layers that have been downloaded, but not yet registered with
+ * an image. This is used when a docker image download fails, we keep all the
+ * successfully downloaded layers from that image in this cache. If the image is
+ * attempted to be downloaded again, this cache is checked to avoid
+ * re-downloading those layers.
+ */
+var DOCKER_IMAGE_CACHE = {};
 
 
 //---- Image model
@@ -2460,6 +2469,20 @@ function _dockerDownloadAndImportImage(opts, callback) {
             return callback(gErr);
         }
 
+        // Check if this image layer has already been downloaded before.
+        if (DOCKER_IMAGE_CACHE.hasOwnProperty(imgId)) {
+            var cachedItem = DOCKER_IMAGE_CACHE[imgId];
+            ctx.fileInfoFromImgId[imgId] = cachedItem.fileInfo;
+            ctx.imageFromImgId[imgId] = cachedItem.image;
+            ctx.alreadyExistsFromImgId[imgId] = true;
+
+            log.debug({imgId: imgId, uuid: uuid},
+                'dockerDownloadAndImportImage: image layer already cached');
+
+            callback();
+            return;
+        }
+
         log.debug({uuid: uuid, repo: rat.canonicalName, imgId: imgId},
             'AdminImportDockerImage: start import');
 
@@ -2627,11 +2650,66 @@ function _dockerDownloadAndImportImage(opts, callback) {
                 return;
             }
 
+            var addImageFileAttempts = 0;
             var lastUpdate = 0;
             var updateEvery = 512 * 1024;
             var startTs = Math.floor(new Date().getTime() / 1000);
 
             var compression = 'none';
+            var streamTimeoutHandler;
+
+            // Setup a timeout listener and handle connection timeout.
+            if (stream.connection) {
+                var DOCKER_READ_STREAM_TIMEOUT = 30 * 1000;
+                stream.connection.setTimeout(DOCKER_READ_STREAM_TIMEOUT);
+                streamTimeoutHandler = function onDockerStreamTimeout() {
+                    log.info({imgId: imgId, size: size, fileSize: fileSize},
+                        'dockerDownloadAndImportImage: '
+                        + 'createBlobReadStream connection timed out');
+                    ctx.resMessage({
+                        type: 'progress',
+                        payload: {
+                            id: imgId.substr(0, 12),
+                            status: 'Connection timed out',
+                            progressDetail: {
+                                current: size,
+                                total: fileSize,
+                                start: startTs
+                            }
+                        }
+                    });
+                    // Note that by destroying the stream this will result in a
+                    // call to finish() with an error, as the drc
+                    // createBlobReadStream handler has an 'end' handler that
+                    // validates the size and digest of downloaded data and
+                    // emits an error event when all the data wasn't downloaded.
+                    stream.destroy();
+                };
+                stream.connection.on('timeout', streamTimeoutHandler);
+            }
+
+            // Retry the download if there are attempts left.
+            function retryAddImageFile(rErr) {
+                addImageFileAttempts += 1;
+                if (addImageFileAttempts >= 5) {
+                    log.info({imgId: imgId, fileSize: fileSize},
+                        'dockerDownloadAndImportImage: download failed after '
+                        + '%d attempts', addImageFileAttempts);
+                    next(rErr);
+                    return;
+                }
+                // Give a short respite and then go again.
+                setTimeout(function () {
+                    if (ctx.downloadsCanceled) {
+                        next(new errors.DownloadError('Download canceled'));
+                        return;
+                    }
+                    log.info({imgId: imgId, fileSize: fileSize,
+                        retryNo: addImageFileAttempts},
+                        'dockerDownloadAndImportImage: retrying blob download');
+                    addImageFile(null, next);
+                }, 1000);
+            }
 
             if (stream.headers['content-length'] !== undefined) {
                 fileSize = Number(stream.headers['content-length']);
@@ -2641,7 +2719,17 @@ function _dockerDownloadAndImportImage(opts, callback) {
             var stor;  // the storage class
             var sha1;
             function finish_(fErr, tmpFilename, filename) {
+                // Remove connection timeout handler.
+                if (streamTimeoutHandler) {
+                    stream.connection.removeListener('timeout',
+                        streamTimeoutHandler);
+                    streamTimeoutHandler = null;
+                }
                 if (fErr) {
+                    if (fErr.name === 'DownloadError') {
+                        retryAddImageFile(fErr);
+                        return;
+                    }
                     return next(fErr);
                 } else if (ctx.downloadsCanceled) {
                     return next(new errors.DownloadError('Download canceled'));
@@ -2651,9 +2739,11 @@ function _dockerDownloadAndImportImage(opts, callback) {
                         'maximum allowed file size, %s',
                         size, MAX_IMAGE_SIZE_STR)));
                 } else if (fileSize >= 0 && size !== fileSize) {
-                    return next(new errors.DownloadError(format(
+                    // Retry - as there was an issue downloading all the bits.
+                    retryAddImageFile(new errors.DownloadError(format(
                         'Download error: "Content-Length" header, %s, does ' +
                         'not match downloaded size, %d', fileSize, size)));
+                    return;
                 }
 
                 sha1 = shasum.digest('hex');
@@ -2674,6 +2764,8 @@ function _dockerDownloadAndImportImage(opts, callback) {
                     filename: filename
                 };
 
+                log.info({imgId: imgId, fileSize: fileSize},
+                    'dockerDownloadAndImportImage: Download successful');
                 return next();
             }
             var finish = once(finish_);
@@ -3019,6 +3111,7 @@ function _dockerV2Pull(ctx, cb) {
     assert.object(ctx.regClientV2, 'ctx.regClientV2');
     assert.func(cb, 'cb');
 
+    var cacheDownloadedLayers = false;
     var req = ctx.req;
     var log = req.log;
     var resMessage = ctx.resMessage;
@@ -3075,6 +3168,8 @@ function _dockerV2Pull(ctx, cb) {
         function importImagesPart1(_, next) {
             var pullQueueError;
             ctx.downloadsCanceled = false;
+            cacheDownloadedLayers = true;
+
             var pullQueue = vasync.queue(function (imgInfo, nextImg) {
                 _dockerDownloadAndImportImage({
                     imgId: imgInfo.imgJson.id,
@@ -3109,6 +3204,7 @@ function _dockerV2Pull(ctx, cb) {
          *   db consistency.
          */
         function importImagesPart2(_, next) {
+            cacheDownloadedLayers = false;
             vasync.forEachPipeline({
                 inputs: reverseAncestry,
                 func: function (imgInfo, nextImg) {
@@ -3137,7 +3233,21 @@ function _dockerV2Pull(ctx, cb) {
 
             next();
         }
-    ]}, cb);
+    ]}, function (err) {
+        if (cacheDownloadedLayers) {
+            // There was a failure downloading one or more image layers - keep
+            // the downloaded image metadata in memory, so we can avoid
+            // downloading it again next time.
+            Object.keys(ctx.fileInfoFromImgId).forEach(function (id) {
+                DOCKER_IMAGE_CACHE[id] = {
+                    fileInfo: ctx.fileInfoFromImgId[id],
+                    image: ctx.imageFromImgId[id]
+                };
+            });
+        }
+
+        cb(err);
+    });
 }
 
 
@@ -3565,7 +3675,14 @@ function apiAdminImportDockerImage(req, res, callback) {
                      * `err.body.code` (if the response body was JSON with a
                      * "code"), else the contructor name is a code.
                      */
-                    code: err.code || (err.body && err.body.code) || err.name,
+                    // XXX: @Trent: Not sure if this is fallout from the Restify
+                    // errors changes, but the err.code does not end with
+                    // 'Error', i.e. a DownloadError has a code of 'Download',
+                    // but sdc-docker pullImage error handling is checking for
+                    // err.code *with* a Error suffix, i.e. 'DownloadError'.
+                    // What is the correct format or what should sdc-docker be
+                    // checking?
+                    code: err.name || err.code || (err.body && err.body.code),
                     message: err.message
                 }
             });
