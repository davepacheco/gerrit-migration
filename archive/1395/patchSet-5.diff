commit da1f2fc93b782efaec92062830aa6823e4a093eb (refs/changes/95/1395/5)
Author: Todd Whiteman <todd.whiteman@joyent.com>
Date:   2017-02-20T16:08:35-08:00 (2 years, 8 months ago)
    
    DOCKER-893 Improve docker pull reliability

diff --git a/docs/index.md b/docs/index.md
index 20a969c..c3dc4a8 100644
--- a/docs/index.md
+++ b/docs/index.md
@@ -652,6 +652,7 @@ Error codes that can be returned from IMGAPI endpoints.
 | OperatorOnly | 403 | Operator-only endpoint called by a non-operator. |
 | ImageUuidAlreadyExists | 409 | Attempt to import an image with a conflicting UUID |
 | Upload | 400 | There was a problem with the upload. |
+| Download | 400 | There was a problem with the download. |
 | StorageIsDown | 503 | Storage system is down. |
 | StorageUnsupported | 503 | The storage type for the image file is unsupported. |
 | RemoteSourceError | 503 | Error contacting the remote source. |
@@ -660,9 +661,11 @@ Error codes that can be returned from IMGAPI endpoints.
 | NotImageOwner | 422 | The caller is not the owner of this image. |
 | NotMantaPathOwner | 422 | The caller is not the owner of this Manta path. |
 | OriginDoesNotExist | 422 | No image exists with the UUID given in the "origin" field for image creation or import. |
+| OriginIsNotActive | 422 | An origin image of the given image exists, but is not active. |
 | InsufficientServerVersion | 422 | Image creation is not supported for this VM because the host server version is not of a recent enough version. |
 | ImageHasDependentImages | 422 | An error raised when attempting to delete an image which has dependent incremental images (images whose "origin" is this image). |
 | NotAvailable | 501 | Functionality is not available. |
+| NotImplemented | 400 | Attempt to use a feature that is not yet implemented |
 | InternalError | 500 | Internal Server Error |
 | ResourceNotFound | 404 | Not Found |
 | InvalidHeader | 400 | An invalid header was given in the request. |
diff --git a/lib/errors.js b/lib/errors.js
index 9dc06d1..256ea0d 100644
--- a/lib/errors.js
+++ b/lib/errors.js
@@ -524,6 +524,34 @@ function parseErrorFromStorage(err, message) {
     }
 }
 
+// Handle docker registry client errors and convert these errors into IMGAPI
+// errors. Note that err could be a docker registry client error, a node.js
+// http/connection error, an IMGAPI error or even a WError instance. Due to this
+// we use the common 'name' attribute of the error to check what type of error
+// it is and convert it into the error instance we want.
+function wrapErrorFromDrc(err) {
+    console.log('err.name: ', err.name);
+    if (err.name === 'BadDigestError') {
+        // Docker registry client digest error.
+        return new ValidationFailedError(err,
+            (err.message || err.toString()),
+            [ {field: 'digest', code: 'Invalid'} ]);
+    } else if (err.name === 'ConnectTimeoutError' || err.name === 'ENOTFOUND') {
+        // Node.js connection error.
+        return new RemoteSourceError(err, err.message);
+    } else if (err.name === 'DownloadError') {
+        // Docker registry client download error.
+        return new RemoteSourceError(err, err.message);
+    } else if (err.name === 'UnauthorizedError' ||
+        err.name === 'UNAUTHORIZED')
+    {
+        // Docker registry client unauthorzed error.
+        return new restify.UnauthorizedError(err, err.message);
+    } else {
+        return new restify.InternalError(err, err.message);
+    }
+}
+
 
 samples.InternalError = new restify.InternalError('boom');
 
@@ -566,8 +594,12 @@ module.exports = {
     // Helper function to parse errors that come from manta
     parseErrorFromStorage: parseErrorFromStorage,
 
+    // Helper function to wrap errors that come from docker registry client.
+    wrapErrorFromDrc: wrapErrorFromDrc,
+
     samples: samples
 };
+console.log('restify.UnauthorizedError: ', restify.UnauthorizedError);
 
 
 //---- mainline (to print out errors table for the docs)
diff --git a/lib/images.js b/lib/images.js
index 03ced87..8cb12a6 100644
--- a/lib/images.js
+++ b/lib/images.js
@@ -74,6 +74,15 @@ var IMGAPI_251_MIN_PLATFORM = {
     '6.5': '20120614T001014Z'
 };
 
+/*
+ * DOCKER-893: Maintain an in-memory image cache (just the image/layer metadata)
+ * for the docker layers that have been downloaded, but not yet registered with
+ * an image. This is used when a docker image download fails, we keep all the
+ * successfully downloaded layers from that image in this cache. If the image is
+ * attempted to be downloaded again, this cache is checked to avoid
+ * re-downloading those layers.
+ */
+var DOCKER_IMAGE_CACHE = {};
 
 
 //---- Image model
@@ -2460,6 +2469,20 @@ function _dockerDownloadAndImportImage(opts, callback) {
             return callback(gErr);
         }
 
+        // Check if this image layer has already been downloaded before.
+        if (DOCKER_IMAGE_CACHE.hasOwnProperty(imgId)) {
+            var cachedItem = DOCKER_IMAGE_CACHE[imgId];
+            ctx.fileInfoFromImgId[imgId] = cachedItem.fileInfo;
+            ctx.imageFromImgId[imgId] = cachedItem.image;
+            ctx.alreadyExistsFromImgId[imgId] = true;
+
+            log.debug({imgId: imgId, uuid: uuid},
+                'dockerDownloadAndImportImage: image layer already cached');
+
+            callback();
+            return;
+        }
+
         log.debug({uuid: uuid, repo: rat.canonicalName, imgId: imgId},
             'AdminImportDockerImage: start import');
 
@@ -2627,11 +2650,66 @@ function _dockerDownloadAndImportImage(opts, callback) {
                 return;
             }
 
+            var addImageFileAttempts = 0;
             var lastUpdate = 0;
             var updateEvery = 512 * 1024;
             var startTs = Math.floor(new Date().getTime() / 1000);
 
             var compression = 'none';
+            var streamTimeoutHandler;
+
+            // Setup a timeout listener and handle connection timeout.
+            if (stream.connection) {
+                var DOCKER_READ_STREAM_TIMEOUT = 30 * 1000;
+                stream.connection.setTimeout(DOCKER_READ_STREAM_TIMEOUT);
+                streamTimeoutHandler = function onDockerStreamTimeout() {
+                    log.info({imgId: imgId, size: size, fileSize: fileSize},
+                        'dockerDownloadAndImportImage: '
+                        + 'createBlobReadStream connection timed out');
+                    ctx.resMessage({
+                        type: 'progress',
+                        payload: {
+                            id: imgId.substr(0, 12),
+                            status: 'Connection timed out',
+                            progressDetail: {
+                                current: size,
+                                total: fileSize,
+                                start: startTs
+                            }
+                        }
+                    });
+                    // Note that by destroying the stream this will result in a
+                    // call to finish() with an error, as the drc
+                    // createBlobReadStream handler has an 'end' handler that
+                    // validates the size and digest of downloaded data and
+                    // emits an error event when all the data wasn't downloaded.
+                    stream.destroy();
+                };
+                stream.connection.on('timeout', streamTimeoutHandler);
+            }
+
+            // Retry the download if there are attempts left.
+            function retryAddImageFile(rErr) {
+                addImageFileAttempts += 1;
+                if (addImageFileAttempts >= 5) {
+                    log.info({imgId: imgId, fileSize: fileSize},
+                        'dockerDownloadAndImportImage: download failed after '
+                        + '%d attempts', addImageFileAttempts);
+                    next(rErr);
+                    return;
+                }
+                // Give a short respite and then go again.
+                setTimeout(function () {
+                    if (ctx.downloadsCanceled) {
+                        next(new errors.DownloadError('Download canceled'));
+                        return;
+                    }
+                    log.info({imgId: imgId, fileSize: fileSize,
+                        addImageFileAttempts: addImageFileAttempts},
+                        'dockerDownloadAndImportImage: retrying blob download');
+                    addImageFile(null, next);
+                }, 1000);
+            }
 
             if (stream.headers['content-length'] !== undefined) {
                 fileSize = Number(stream.headers['content-length']);
@@ -2641,7 +2719,17 @@ function _dockerDownloadAndImportImage(opts, callback) {
             var stor;  // the storage class
             var sha1;
             function finish_(fErr, tmpFilename, filename) {
+                // Remove connection timeout handler.
+                if (streamTimeoutHandler) {
+                    stream.connection.removeListener('timeout',
+                        streamTimeoutHandler);
+                    streamTimeoutHandler = null;
+                }
                 if (fErr) {
+                    if (fErr.name === 'DownloadError') {
+                        retryAddImageFile(fErr);
+                        return;
+                    }
                     return next(fErr);
                 } else if (ctx.downloadsCanceled) {
                     return next(new errors.DownloadError('Download canceled'));
@@ -2651,9 +2739,11 @@ function _dockerDownloadAndImportImage(opts, callback) {
                         'maximum allowed file size, %s',
                         size, MAX_IMAGE_SIZE_STR)));
                 } else if (fileSize >= 0 && size !== fileSize) {
-                    return next(new errors.DownloadError(format(
+                    // Retry - as there was an issue downloading all the bits.
+                    retryAddImageFile(new errors.DownloadError(format(
                         'Download error: "Content-Length" header, %s, does ' +
                         'not match downloaded size, %d', fileSize, size)));
+                    return;
                 }
 
                 sha1 = shasum.digest('hex');
@@ -2674,6 +2764,8 @@ function _dockerDownloadAndImportImage(opts, callback) {
                     filename: filename
                 };
 
+                log.info({imgId: imgId, fileSize: fileSize},
+                    'dockerDownloadAndImportImage: Download successful');
                 return next();
             }
             var finish = once(finish_);
@@ -3019,6 +3111,7 @@ function _dockerV2Pull(ctx, cb) {
     assert.object(ctx.regClientV2, 'ctx.regClientV2');
     assert.func(cb, 'cb');
 
+    var cacheDownloadedLayers = false;
     var req = ctx.req;
     var log = req.log;
     var resMessage = ctx.resMessage;
@@ -3075,6 +3168,8 @@ function _dockerV2Pull(ctx, cb) {
         function importImagesPart1(_, next) {
             var pullQueueError;
             ctx.downloadsCanceled = false;
+            cacheDownloadedLayers = true;
+
             var pullQueue = vasync.queue(function (imgInfo, nextImg) {
                 _dockerDownloadAndImportImage({
                     imgId: imgInfo.imgJson.id,
@@ -3109,6 +3204,7 @@ function _dockerV2Pull(ctx, cb) {
          *   db consistency.
          */
         function importImagesPart2(_, next) {
+            cacheDownloadedLayers = false;
             vasync.forEachPipeline({
                 inputs: reverseAncestry,
                 func: function (imgInfo, nextImg) {
@@ -3137,7 +3233,21 @@ function _dockerV2Pull(ctx, cb) {
 
             next();
         }
-    ]}, cb);
+    ]}, function (err) {
+        if (cacheDownloadedLayers) {
+            // There was a failure downloading one or more image layers - keep
+            // the downloaded image metadata in memory, so we can avoid
+            // downloading it again next time.
+            Object.keys(ctx.fileInfoFromImgId).forEach(function (id) {
+                DOCKER_IMAGE_CACHE[id] = {
+                    fileInfo: ctx.fileInfoFromImgId[id],
+                    image: ctx.imageFromImgId[id]
+                };
+            });
+        }
+
+        cb(err);
+    });
 }
 
 
@@ -3555,18 +3665,14 @@ function apiAdminImportDockerImage(req, res, callback) {
             // This is a chunked transfer so we can't return a restify error.
             log.info(err, 'error pulling image layers for %s',
                 context.repoAndRef);
+            // DOCKER-893: Guarantee that we're only returning an IMGAPI error.
+            var wrappedErr = errors.wrapErrorFromDrc(err);
             resMessage({
                 type: 'error',
                 id: repo,
                 error: {
-                    /*
-                     * `restify.RestError` instances will have `err.code`. More
-                     * vanilla `restify.HttpError` instances may have
-                     * `err.body.code` (if the response body was JSON with a
-                     * "code"), else the contructor name is a code.
-                     */
-                    code: err.code || (err.body && err.body.code) || err.name,
-                    message: err.message
+                    code: wrappedErr.code,
+                    message: wrappedErr.message
                 }
             });
         }
