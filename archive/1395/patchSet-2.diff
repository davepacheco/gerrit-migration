From 6d3eaa4dcd4b9199a930d5238ab6231ccb3dc755 Mon Sep 17 00:00:00 2001
From: Todd Whiteman <todd.whiteman@joyent.com>
Date: Wed, 1 Feb 2017 14:55:16 -0800
Subject: [PATCH] DOCKER-893 Improve docker pull reliability

---
 lib/images.js | 80 +++++++++++++++++++++++++++++++++++++++++++++++++--
 1 file changed, 78 insertions(+), 2 deletions(-)

diff --git a/lib/images.js b/lib/images.js
index 03ced87..11e658a 100644
--- a/lib/images.js
+++ b/lib/images.js
@@ -2627,11 +2627,66 @@ function _dockerDownloadAndImportImage(opts, callback) {
                 return;
             }
 
+            var addImageFileAttempts = 0;
             var lastUpdate = 0;
             var updateEvery = 512 * 1024;
             var startTs = Math.floor(new Date().getTime() / 1000);
 
             var compression = 'none';
+            var streamTimeoutHandler;
+
+            // Setup a timeout listener and handle connection timeout.
+            if (stream.connection) {
+                var DOCKER_READ_STREAM_TIMEOUT = 30 * 1000;
+                stream.connection.setTimeout(DOCKER_READ_STREAM_TIMEOUT);
+                streamTimeoutHandler = function onDockerStreamTimeout() {
+                    log.info({imgId: imgId, size: size, fileSize: fileSize},
+                        'dockerDownloadAndImportImage: '
+                        + 'createBlobReadStream connection timed out');
+                    ctx.resMessage({
+                        type: 'progress',
+                        payload: {
+                            id: imgId.substr(0, 12),
+                            status: 'Connection timed out',
+                            progressDetail: {
+                                current: size,
+                                total: fileSize,
+                                start: startTs
+                            }
+                        }
+                    });
+                    // Note that by destroying the stream this will result in a
+                    // call to finish() with an error, as the drc
+                    // createBlobReadStream handler has an 'end' handler that
+                    // validates the size and digest of downloaded data and
+                    // emits an error event when all the data wasn't downloaded.
+                    stream.destroy();
+                };
+                stream.connection.on('timeout', streamTimeoutHandler);
+            }
+
+            // Retry the download if there are attempts left.
+            function retryAddImageFile(rErr) {
+                addImageFileAttempts += 1;
+                if (addImageFileAttempts >= 5) {
+                    log.info({imgId: imgId, fileSize: fileSize},
+                        'dockerDownloadAndImportImage: download failed after '
+                        + '%d attempts', addImageFileAttempts);
+                    next(rErr);
+                    return;
+                }
+                // Give a short respite and then go again.
+                setTimeout(function () {
+                    if (ctx.downloadsCanceled) {
+                        next(new errors.DownloadError('Download canceled'));
+                        return;
+                    }
+                    log.info({imgId: imgId, fileSize: fileSize,
+                        retryNo: addImageFileAttempts},
+                        'dockerDownloadAndImportImage: retrying blob download');
+                    addImageFile(null, next);
+                }, 1000);
+            }
 
             if (stream.headers['content-length'] !== undefined) {
                 fileSize = Number(stream.headers['content-length']);
@@ -2641,7 +2696,17 @@ function _dockerDownloadAndImportImage(opts, callback) {
             var stor;  // the storage class
             var sha1;
             function finish_(fErr, tmpFilename, filename) {
+                // Remove connection timeout handler.
+                if (streamTimeoutHandler) {
+                    stream.connection.removeListener('timeout',
+                        streamTimeoutHandler);
+                    streamTimeoutHandler = null;
+                }
                 if (fErr) {
+                    if (fErr.name === 'DownloadError') {
+                        retryAddImageFile(fErr);
+                        return;
+                    }
                     return next(fErr);
                 } else if (ctx.downloadsCanceled) {
                     return next(new errors.DownloadError('Download canceled'));
@@ -2651,9 +2716,11 @@ function _dockerDownloadAndImportImage(opts, callback) {
                         'maximum allowed file size, %s',
                         size, MAX_IMAGE_SIZE_STR)));
                 } else if (fileSize >= 0 && size !== fileSize) {
-                    return next(new errors.DownloadError(format(
+                    // Retry - as there was an issue downloading all the bits.
+                    retryAddImageFile(new errors.DownloadError(format(
                         'Download error: "Content-Length" header, %s, does ' +
                         'not match downloaded size, %d', fileSize, size)));
+                    return;
                 }
 
                 sha1 = shasum.digest('hex');
@@ -2674,6 +2741,8 @@ function _dockerDownloadAndImportImage(opts, callback) {
                     filename: filename
                 };
 
+                log.info({imgId: imgId, fileSize: fileSize},
+                    'dockerDownloadAndImportImage: Download successful');
                 return next();
             }
             var finish = once(finish_);
@@ -3565,7 +3634,14 @@ function apiAdminImportDockerImage(req, res, callback) {
                      * `err.body.code` (if the response body was JSON with a
                      * "code"), else the contructor name is a code.
                      */
-                    code: err.code || (err.body && err.body.code) || err.name,
+                    // XXX: @Trent: Not sure if this is fallout from the Restify
+                    // errors changes, but the err.code does not end with
+                    // 'Error', i.e. a DownloadError has a code of 'Download',
+                    // but sdc-docker pullImage error handling is checking for
+                    // err.code *with* a Error suffix, i.e. 'DownloadError'.
+                    // What is the correct format or what should sdc-docker be
+                    // checking?
+                    code: err.name || err.code || (err.body && err.body.code),
                     message: err.message
                 }
             });
-- 
2.21.0

