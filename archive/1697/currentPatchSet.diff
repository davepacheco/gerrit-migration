From aaff4a0048bed23f78ff99e6b471b3e9429f377b Mon Sep 17 00:00:00 2001
From: Marsell Kukuljevic <marsell@joyent.com>
Date: Wed, 22 Mar 2017 22:46:39 +1300
Subject: [PATCH] PAPI-137: Clean up query string encoding in sdc-clients'
 papi.js PUBAPI-1380: Cloudapi should support wildcards in ListPackages
 Reviewed by: Trent Mick <trent.mick@joyent.com>

---
 CHANGES.md        |   2 +
 lib/papi.js       | 164 +++++++++++++++++++++-------------------------
 test/papi.test.js |   8 +--
 3 files changed, 81 insertions(+), 93 deletions(-)

diff --git a/CHANGES.md b/CHANGES.md
index 7b9852d..adaafe7 100644
--- a/CHANGES.md
+++ b/CHANGES.md
@@ -12,6 +12,8 @@
 
 ## not yet released
 
+- PUBAPI-1380 Cloudapi should support wildcards in ListPackages
+
 ## 10.1.0
 
 - joyent/node-sdc-clients#10 Add `params.sync` to VMAPI.getVm.
diff --git a/lib/papi.js b/lib/papi.js
index 0fd82da..f8f735d 100644
--- a/lib/papi.js
+++ b/lib/papi.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2016, Joyent, Inc.
+ * Copyright (c) 2017, Joyent, Inc.
  */
 
 /*
@@ -13,68 +13,9 @@
  */
 
 var assert = require('assert-plus');
-var clone = require('clone');
-var qs = require('querystring');
 var restifyClients = require('restify-clients');
 
 
-// ---- internal support
-
-/**
- * Escapes param data being sent to PAPI.
- *
- * PAPI accepts special characters used for LDIF filters in its params
- * when making queries. This is useful for ops, but undesirable for
- * most applications (and especially data that may carry taint from
- * outside). This function escapes data (both ldif and query forms) so
- * that they're safe to use as params passed to PAPI.
- *
- * @param data the data to escape
- * @param escape whether to escape the data for ldif
- */
-function escapeParam(data, escape) {
-    if (typeof (data) !== 'string')
-        return data;
-
-    // treat undefined as true as well
-    if (escape !== false) {
-        data = data.replace('(',  '{\\28}').
-                    replace(')',  '{\\29}').
-                    replace('\\', '{\\5c}').
-                    replace('*',  '{\\2a}').
-                    replace('/',  '{\\2f}');
-    }
-
-    return qs.escape(data);
-}
-
-
-/**
- * Append params to path.
- *
- * @param {String} path the path without params
- * @param {Object} options the args to apply to the end of the path
- */
-function createPath(path, options) {
-    assert.string(path, 'path');
-    assert.object(options, 'options');
-
-    var escape = options.escape;
-    delete options.escape;
-
-    var q = [];
-
-    Object.keys(options).forEach(function (k) {
-        q.push(k + '=' + escapeParam(options[k], escape));
-    });
-
-    if (q.length)
-        path += '?' + q.join('&');
-
-    return path;
-}
-
-
 // ---- client
 
 function PAPI(clientOpts) {
@@ -148,6 +89,14 @@ PAPI.prototype.add = function add(pkg, options, cb) {
 /**
  * Looks up a package by uuid.
  *
+ * Although this is a GET, it is possible to pass additional arguments to PAPI
+ * through the 'options' parameter.
+ *
+ * Be aware that when additional options are provided, option values which are
+ * strings will have PAPI wildcards (i.e. '*') escaped. This can be overridden
+ * with an option (escape = false), but don't do so unless you want to give
+ * any callers the ability to wildcard search.
+ *
  * @param {String} uuid for a package.
  * @param {Object} options params passed to PAPI
  * @param {Function} cb of the form f(err, pkg).
@@ -156,18 +105,38 @@ PAPI.prototype.add = function add(pkg, options, cb) {
 PAPI.prototype.get = function get(uuid, options, cb) {
     var self = this;
 
-    assert.string(uuid, 'uuid');
+    assert.uuid(uuid, 'uuid');
     assert.object(options, 'options');
+    assert.optionalObject(options.headers, 'options.headers');
+    assert.optionalBool(options.escape, 'options.escape');
     assert.func(cb, 'cb');
 
-    var opts = {};
+    var escape = (options.escape === undefined ? true : options.escape);
+    var headers = options.headers;
+    delete options.escape;
+    delete options.headers;
 
-    if (options.headers) {
-        opts.headers = options.headers;
-        delete options.headers;
-    }
+    var query = {};
 
-    opts.path = createPath('/packages/' + uuid, options);
+    Object.keys(options).forEach(function (k) {
+        var val = options[k];
+
+        if (escape && typeof (val) === 'string') {
+            /* JSSTYLED */
+            query[k] = val.replace(/\*/g, '{\\2a}');
+        } else {
+            query[k] = val;
+        }
+    });
+
+    var opts = {
+        path: '/packages/' + uuid,
+        query: query
+    };
+
+    if (headers) {
+        opts.headers = headers;
+    }
 
     return self.client.get(opts, function (err, req, res, pkg) {
         if (err) {
@@ -183,6 +152,10 @@ PAPI.prototype.get = function get(uuid, options, cb) {
 /**
  * Deletes a pkg record.
  *
+ * This is a risky endpoint to call -- see the PAPI docs regarding the
+ * DeletePackage endpoint for more details. As a result, this call will
+ * always fail unless you explicitly set 'options.force' to true.
+ *
  * @param {String} uuid the uuid of the record you received from get().
  * @param {Object} opt the uuid of the record you received from get().
  * @param {Function} cb of the form fn(err).
@@ -191,16 +164,23 @@ PAPI.prototype.get = function get(uuid, options, cb) {
 PAPI.prototype.del = function del(uuid, options, cb) {
     var self = this;
 
-    assert.string(uuid, 'uuid');
+    assert.uuid(uuid, 'uuid');
     assert.object(options, 'options');
+    assert.optionalObject(options.headers, 'options.headers');
+    assert.optionalBool(options.force, 'options.force');
     assert.func(cb, 'cb');
 
-    var opts = {};
+    var opts = {
+        path: '/packages/' + uuid
+    };
+
+    if (options.force) {
+        opts.query = { force: true };
+    }
+
     if (options.headers) {
         opts.headers = options.headers;
-        delete options.headers;
     }
-    opts.path = createPath('/packages/' + uuid, options);
 
     return self.client.del(opts, cb);
 };
@@ -227,7 +207,7 @@ PAPI.prototype.update = function update(uuid, changes, options, cb) {
         options = {};
     }
 
-    assert.string(uuid, 'uuid');
+    assert.uuid(uuid, 'uuid');
     assert.object(changes, 'changes');
     assert.func(cb, 'cb');
 
@@ -260,10 +240,10 @@ PAPI.prototype.update = function update(uuid, changes, options, cb) {
  * of packages matching the given search filter (retrieved by PAPI as
  * x-resource-count HTTP header).
  *
- * When passing a filter object (not a string), the query arguments will be
- * escaped according to ldif filter rules. This can be overridden with an
- * option, but don't do so unless you're 100% confident the query args
- * aren't potentially tainted.
+ * When passing a filter object (not a string), the query arguments will
+ * escape PAPI ListPackage wildcards. This can be overridden with an
+ * option (escape = false), but don't do so unless you want to give any
+ * callers the ability to wildcard search.
  *
  * @param {String or Object} provided LDAP filter.
  * @param {Object} pagination options when desired.
@@ -274,35 +254,41 @@ PAPI.prototype.list = function list(filter, options, cb) {
     var self = this;
 
     assert.object(options, 'options');
+    assert.optionalBool(options.escape, 'options.escape');
+    assert.optionalObject(options.headers, 'options.headers');
     assert.func(cb, 'cb');
 
-    var escape = options.escape;
-    delete options.escape;
+    var escape = (options.escape === undefined ? true : options.escape);
     var headers = options.headers;
+    delete options.escape;
     delete options.headers;
 
-    var q = [];
+    var query = {};
 
     if (typeof (filter) === 'string') {
-        q.push('filter=' + escapeParam(filter, false));
+        query.filter = filter;
     } else {
         Object.keys(filter).forEach(function (k) {
-            q.push(k + '=' + escapeParam(filter[k], escape));
+            var val = filter[k];
+
+            if (escape && typeof (val) === 'string') {
+                /* JSSTYLED */
+                query[k] = val.replace(/\*/g, '{\\2a}');
+            } else {
+                query[k] = val;
+            }
         });
     }
 
     Object.keys(options).forEach(function (k) {
-        q.push(k + '=' + options[k]);
+        query[k] = options[k];
     });
 
-    var p = '/packages';
+    var opts = {
+        path: '/packages',
+        query: query
+    };
 
-    // XXX should use opts.query instead
-    if (q.length) {
-        p = p + '?' + q.join('&');
-    }
-
-    var opts = {path: p};
     if (headers) {
         opts.headers = headers;
     }
diff --git a/test/papi.test.js b/test/papi.test.js
index 1874fd3..6ca10f8 100644
--- a/test/papi.test.js
+++ b/test/papi.test.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright 2016 Joyent, Inc.
+ * Copyright 2017 Joyent, Inc.
  */
 
 var bunyan = require('bunyan');
@@ -18,7 +18,7 @@ var PAPI = require('../lib/index').PAPI;
 
 // --- Globals
 
-var PAPI_IP = process.env.PAPI_IP || '10.99.99.30';
+var PAPI_IP = process.env.PAPI_IP || 'papi.coal.joyent.us';
 var PAPI_URL = 'http://' + PAPI_IP;
 var CUSTOMER = process.env.UFDS_ADMIN_UUID;
 
@@ -252,7 +252,7 @@ test('papi', function (tt) {
     });
 
 
-    tt.test(' list packages using wildcards withtou escaping', function (t) {
+    tt.test(' list packages using wildcards without escaping', function (t) {
         papi.list({ name: 'regular_*' }, { escape: false },
                   function (err, packages) {
             t.ifError(err);
@@ -280,4 +280,4 @@ test('papi', function (tt) {
         papi.close();
         t.end();
     });
-});
\ No newline at end of file
+});
-- 
2.21.0

