From 02093c94b2508552df9451821bfa5dc326e5e5d2 Mon Sep 17 00:00:00 2001
From: Alex Wilson <alex.wilson@joyent.com>
Date: Wed, 30 Nov 2016 18:11:47 -0800
Subject: [PATCH] CNS-180 use multiple connections to redis to avoid blocking

---
 lib/api-server.js            |  37 +++--
 lib/dns-server.js            | 260 ++++++++++++++++++++++-------------
 package.json                 |   2 +-
 server.js                    |  40 +++++-
 test/unit/dns-server.test.js |  12 +-
 test/unit/mock-redis.js      |  42 +++++-
 6 files changed, 271 insertions(+), 122 deletions(-)

diff --git a/lib/api-server.js b/lib/api-server.js
index 972af6e..8bed3de 100644
--- a/lib/api-server.js
+++ b/lib/api-server.js
@@ -37,8 +37,8 @@ var NS_TTL = consts.NS_TTL;
 function APIServer(opts) {
 	assert.object(opts, 'options');
 
-	assert.object(opts.client, 'options.client');
-	this.redis = opts.client;
+	assert.object(opts.redisPool, 'options.redisPool');
+	this.redisPool = opts.redisPool;
 
 	assert.object(opts.dnsServer, 'options.dnsServer');
 	this.dnsServer = opts.dnsServer;
@@ -122,7 +122,7 @@ function APIServer(opts) {
 		log: this.log,
 		config: this.config,
 		agent: agent,
-		client: this.redis,
+		redisPool: this.redisPool,
 		ufdsConnections: 1
 	};
 	popts.ufdsPool = createUfdsPool(popts);
@@ -213,7 +213,13 @@ function setupServer(addr) {
 
 	server.pre(function (req, res, next) {
 		req.log = slog.child({req: req, res: res});
-		next();
+		self.redisPool.claim(function (err, handle, redis) {
+			if (err)
+				throw (err);
+			req.redis = redis;
+			req.redisHandle = handle;
+			next();
+		});
 	});
 
 	server.use(restify.queryParser());
@@ -224,6 +230,13 @@ function setupServer(addr) {
 	server.on('after', restify.auditLogger({
 		log: slog
 	}));
+	server.on('after', function (req) {
+		if (req.redisHandle) {
+			req.redisHandle.release();
+			delete (req.redisHandle);
+			delete (req.redis);
+		}
+	});
 	server.on('uncaughtException', function (req, res, route, err) {
 		req.log.error(err);
 		res.send(err);
@@ -283,12 +296,11 @@ function ping_v1(req, res, next) {
 }
 
 function getVM_v1(req, res, next) {
-	var self = this;
 	var uuid = req.params.uuid;
 	var result = {};
 	result.uuid = uuid;
 
-	self.redis.hgetall('vm:' + uuid, function (err, val) {
+	req.redis.hgetall('vm:' + uuid, function (err, val) {
 		var e;
 		if (err) {
 			e = new Error('Error communicating with ' +
@@ -347,7 +359,7 @@ function getPeer_v1(req, res, next) {
 	});
 
 	function fetchSerials(_, cb) {
-		self.redis.hgetall('peer:' + addr, function (err, serials) {
+		req.redis.hgetall('peer:' + addr, function (err, serials) {
 			var rerr;
 			if (err) {
 				rerr = new Error('Error communicating with ' +
@@ -373,7 +385,7 @@ function getPeer_v1(req, res, next) {
 	}
 
 	function fetchVersion(_, cb) {
-		self.redis.get('peer:' + addr + ':version',
+		req.redis.get('peer:' + addr + ':version',
 		    function (err, ver) {
 			var rerr;
 			if (err) {
@@ -413,7 +425,7 @@ function getPeer_v1(req, res, next) {
 function delPeer_v1(req, res, next) {
 	var addr = normalizeIP(req.params.addr);
 
-	this.redis.del('peer:' + addr, 'peer:' + addr + ':version',
+	req.redis.del('peer:' + addr, 'peer:' + addr + ':version',
 	    function (err) {
 		if (err) {
 			next(err);
@@ -449,7 +461,7 @@ function getPeers_v1(req, res, next) {
 	});
 
 	function fetchSerials(_, cb) {
-		self.dnsServer.getPeerSerials(function (err, sres) {
+		self.dnsServer.getPeerSerials(req.redis, function (err, sres) {
 			if (err) {
 				cb(err);
 				return;
@@ -492,11 +504,10 @@ function getPeers_v1(req, res, next) {
 }
 
 function getZones_v1(req, res, next) {
-	var self = this;
 	var zoneNames = Object.keys(this.config.forward_zones);
 	var zones = [];
 
-	this.redis.keys('zone:*.arpa', function (err, keys) {
+	req.redis.keys('zone:*.arpa', function (err, keys) {
 		if (!err && keys !== null) {
 			for (var i = 0; i < keys.length; ++i) {
 				var k = keys[i].split(':')[1];
@@ -517,7 +528,7 @@ function getZones_v1(req, res, next) {
 		});
 
 		function addZone(z, cb) {
-			self.redis.get('zone:' + z + ':latest',
+			req.redis.get('zone:' + z + ':latest',
 			    function (err2, val) {
 				if (err2) {
 					var e = new Error('Redis error: ' +
diff --git a/lib/dns-server.js b/lib/dns-server.js
index 4e6ade1..5b30b2f 100644
--- a/lib/dns-server.js
+++ b/lib/dns-server.js
@@ -34,8 +34,8 @@ var MAX_NOTIFY_FAILURES = 5;
 function DNSServer(opts) {
 	assert.object(opts, 'options');
 
-	assert.object(opts.client, 'options.client');
-	this.redis = opts.client;
+	assert.object(opts.redisPool, 'options.redisPool');
+	this.redisPool = opts.redisPool;
 
 	assert.object(opts.config, 'options.config');
 	this.config = opts.config;
@@ -64,12 +64,37 @@ function DNSServer(opts) {
 	this.addPeer('::1');
 	this.addPeersFromConfig();
 
+	var self = this;
+
 	var s = this.server = named.createServer({log: this.log});
 
-	s.on('query', this.handleQuery.bind(this));
+	s.on('query', function (q, cb) {
+		q.log = self.log.child({
+			from: sprintf('%s/%s:%d', q.src.family, q.src.address,
+			    q.src.port),
+			qId: q.id,
+			qOp: q.operation(),
+			qName: q.name(),
+			qType: q.type()
+		});
+		self.redisPool.claim(function (err, handle, redis) {
+			if (err) {
+				q.log.error(err, 'failed to claim redis conn');
+				cb();
+				return;
+			}
+			q.redisHandle = handle;
+			q.redis = redis;
+			self.handleQuery(q, function () {
+				q.redisHandle.release();
+				delete (q.redisHandle);
+				delete (q.redis);
+				cb();
+			});
+		});
+	});
 	s.on('error', this.emit.bind(this, 'error'));
 
-	var self = this;
 	var listenCount = 0;
 	s.listenUdp({port: this.port, address: this.address}, function () {
 		log.info('listening on udp/%s:%d', self.address, self.port);
@@ -177,14 +202,6 @@ DNSServer.prototype.addPeersFromConfig = function () {
 DNSServer.prototype.handleQuery = function (q, cb) {
 	assert.object(q, 'query');
 
-	q.log = this.log.child({
-		from: sprintf('%s/%s:%d', q.src.family, q.src.address,
-		    q.src.port),
-		qId: q.id,
-		qOp: q.operation(),
-		qName: q.name(),
-		qType: q.type()
-	});
 	q.log.trace('begin query');
 
 	var name = q.name();
@@ -207,7 +224,7 @@ DNSServer.prototype.handleQuery = function (q, cb) {
 		return;
 	}
 
-	this.findZone(name, function (z) {
+	this.findZone(q, function (z) {
 		if (z === undefined) {
 			q.log.trace('failed to identify zone, ' +
 			    'sending servfail');
@@ -232,7 +249,7 @@ DNSServer.prototype.handleQuery = function (q, cb) {
 		 * generate an ENONAME response for these).
 		 */
 		if (type === 'SOA' && name === z) {
-			self.makeSOA(z, function (err, soa) {
+			self.makeSOA(q, z, function (err, soa) {
 				if (err) {
 					q.log.warn({err: err},
 					    'makesoa failed');
@@ -272,7 +289,7 @@ DNSServer.prototype.handleQuery = function (q, cb) {
 		 */
 		var leaf = name.slice(0, name.length - z.length - 1);
 
-		var r = self.redis;
+		var r = q.redis;
 		var k = 'zone:' + z;
 
 		r.hget(k, leaf, function (err, val) {
@@ -312,7 +329,7 @@ DNSServer.prototype.handleQuery = function (q, cb) {
 			} else {
 				q.setError('nxdomain');
 			}
-			self.makeSOA(z, function (err2, soa) {
+			self.makeSOA(q, z, function (err2, soa) {
 				if (err2) {
 					q.log.warn({err: err2},
 					    'makesoa failed');
@@ -334,7 +351,7 @@ DNSServer.prototype.handleQuery = function (q, cb) {
 DNSServer.prototype.addCNAMEs = function (recs, z, q, cb) {
 	const ZRE = new RegExp(('.' + z + '$').replace(/[.]/g, '\\.'));
 
-	var r = this.redis;
+	var r = q.redis;
 	var k = 'zone:' + z;
 	var cname = recs[0].args[0];
 	var leaf = cname.replace(ZRE, '');
@@ -357,7 +374,7 @@ DNSServer.prototype.addCNAMEs = function (recs, z, q, cb) {
 
 DNSServer.prototype.addAdditionals = function (recs, z, q, cb) {
 	const ZRE = new RegExp(('.' + z + '$').replace(/[.]/g, '\\.'));
-	var r = this.redis;
+	var r = q.redis;
 	var addns = {};
 
 	vasync.forEachParallel({
@@ -406,7 +423,9 @@ DNSServer.prototype.addAdditionals = function (recs, z, q, cb) {
  *
  * Guarantees that the "z" arg to the callback is a suffix of "name".
  */
-DNSServer.prototype.findZone = function (name, cb) {
+DNSServer.prototype.findZone = function (q, cb) {
+	assert.object(q, 'query');
+	var name = q.name();
 	assert.string(name, 'name');
 	assert.func(cb, 'callback');
 
@@ -422,8 +441,7 @@ DNSServer.prototype.findZone = function (name, cb) {
 	if (z === undefined) {
 		var parts = name.toLowerCase().split('.');
 		if (parts[parts.length - 1] === 'arpa') {
-			var r = this.redis;
-			r.keys('zone:*.arpa', function (err, keys) {
+			q.redis.keys('zone:*.arpa', function (err, keys) {
 				if (err || keys === null) {
 					cb(undefined);
 					return;
@@ -504,12 +522,10 @@ function rehydrate(r) {
 }
 
 /* Gets a list of all zones and their current serials. */
-DNSServer.prototype.getAllZones = function (cb) {
-	var self = this;
-
+DNSServer.prototype.getAllZones = function (r, cb) {
 	var zs = Object.keys(this.config.forward_zones);
 
-	this.redis.keys('zone:*.arpa', function (err, keys) {
+	r.keys('zone:*.arpa', function (err, keys) {
 		if (err || keys === null)
 			return;
 
@@ -527,7 +543,7 @@ DNSServer.prototype.getAllZones = function (cb) {
 
 		function getZoneSerial(z, scb) {
 			var zk = 'zone:' + z + ':latest';
-			self.redis.get(zk, function (err3, serStr) {
+			r.get(zk, function (err3, serStr) {
 				var res = {};
 				res.zone = z;
 				if (err) {
@@ -558,15 +574,45 @@ DNSServer.prototype.checkAndNotify = function () {
 	clearTimeout(self.notifyTimer);
 	delete (self.notifyTimer);
 
-	this.getAllZones(function (err, zs) {
-		var serials = {};
-		zs.forEach(function (z) {
-			if (z.serial !== undefined)
-				serials[z.zone] = z.serial;
-		});
+	function setNextTimer() {
+		if (self.notifyTimer !== undefined)
+			return;
+		/* Schedule the next check. */
+		self.notifyTimer = setTimeout(
+		    self.checkAndNotify.bind(self),
+		    self.notifyInterval);
+	}
+
+	this.redisPool.claim(function (rerr, handle, redis) {
+		if (rerr) {
+			self.log.error(rerr, 'failed claiming redis');
+			setNextTimer();
+			return;
+		}
+
+		self.getAllZones(redis, function (err, zs) {
+			if (err) {
+				self.log.error(err, 'failed listing zones');
+				handle.release();
+				setNextTimer();
+				return;
+			}
+
+			var serials = {};
+			zs.forEach(function (z) {
+				if (z.serial !== undefined)
+					serials[z.zone] = z.serial;
+			});
+
+			self.getPeerSerials(redis, function (err2, peers) {
+				if (err2) {
+					self.log.trace('no serial for %s, ' +
+					    'not sending NOTIFY');
+					handle.release();
+					setNextTimer();
+					return;
+				}
 
-		self.getPeerSerials(function (err2, peers) {
-			if (!err2) {
 				Object.keys(peers).forEach(function (peer) {
 					var zones = Object.keys(peers[peer]);
 					zones.forEach(function (z) {
@@ -578,21 +624,20 @@ DNSServer.prototype.checkAndNotify = function () {
 					});
 				});
 
-				self.garbageCollect(serials, peers);
-			}
+				handle.release();
 
-			if (self.notifyTimer !== undefined)
-				return;
-			/* Schedule the next check. */
-			self.notifyTimer = setTimeout(
-			    self.checkAndNotify.bind(self),
-			    self.notifyInterval);
+				self.garbageCollect(serials, peers,
+				    function () {
+					setNextTimer();
+				});
+			});
 		});
 	});
 };
 
 DNSServer.prototype.garbageCollect = function (serials, peers, cb) {
 	var self = this;
+	var redis;
 
 	/* First build the lookup of minimum required serial for each zone. */
 	var minSerial = Object.create(serials);
@@ -608,17 +653,28 @@ DNSServer.prototype.garbageCollect = function (serials, peers, cb) {
 		});
 	});
 
-	vasync.forEachPipeline({
-		func: doZone,
-		inputs: Object.keys(serials)
-	}, function (err, res) {
-		if (cb)
-			cb(err);
+	this.redisPool.claim(function (err, h, r) {
+		if (err) {
+			self.log.error(err, 'failed claiming redis for ' +
+			    'garbageCollect');
+			if (cb)
+				cb(err);
+			return;
+		}
+		redis = r;
+		vasync.forEachPipeline({
+			func: doZone,
+			inputs: Object.keys(serials)
+		}, function (err2, res) {
+			h.release();
+			if (cb)
+				cb(err2);
+		});
 	});
 
 	function doZone(zone, zcb) {
 		var k = 'zone:' + zone + ':all';
-		self.redis.lrange(k, 0, -1, function (err2, zserials) {
+		redis.lrange(k, 0, -1, function (err2, zserials) {
 			if (err2 || zserials === null || zserials === []) {
 				zcb(null);
 				return;
@@ -643,21 +699,20 @@ DNSServer.prototype.garbageCollect = function (serials, peers, cb) {
 				inputs: zserials
 			}, zcb);
 			function doSerial(serial, scb) {
-				self.dropSerial(zone, serial, scb);
+				self.dropSerial(redis, zone, serial, scb);
 			}
 		});
 	}
 };
 
-DNSServer.prototype.dropSerial = function (zone, serial, cb) {
+DNSServer.prototype.dropSerial = function (r, zone, serial, cb) {
 	var keys = [];
-	var self = this;
 	vasync.pipeline({
 		funcs: [findToKeys, findFromKeys, findNsRecKeys,
 		    dropKeys, remSerial]
 	}, cb);
 	function findToKeys(_, kcb) {
-		self.redis.keys('zone:' + zone + ':*:' + serial + ':*',
+		r.keys('zone:' + zone + ':*:' + serial + ':*',
 		    function (err, ks) {
 			if (err) {
 				kcb(err);
@@ -680,7 +735,7 @@ DNSServer.prototype.dropSerial = function (zone, serial, cb) {
 		});
 	}
 	function findFromKeys(_, kcb) {
-		self.redis.keys('zone:' + zone + ':' + serial + ':*',
+		r.keys('zone:' + zone + ':' + serial + ':*',
 		    function (err, ks) {
 			if (err) {
 				kcb(err);
@@ -703,7 +758,7 @@ DNSServer.prototype.dropSerial = function (zone, serial, cb) {
 		});
 	}
 	function findNsRecKeys(_, kcb) {
-		self.redis.keys('nsrecs:' + zone + ':' + serial,
+		r.keys('nsrecs:' + zone + ':' + serial,
 		    function (err, ks) {
 			if (err) {
 				kcb(err);
@@ -720,13 +775,13 @@ DNSServer.prototype.dropSerial = function (zone, serial, cb) {
 	function dropKeys(_, kcb) {
 		if (keys.length > 0) {
 			keys.push(kcb);
-			self.redis.del.apply(self.redis, keys);
+			r.del.apply(r, keys);
 		} else {
 			kcb();
 		}
 	}
 	function remSerial(_, kcb) {
-		self.redis.lrem('zone:' + zone + ':all', 1,
+		r.lrem('zone:' + zone + ':all', 1,
 		    String(serial), kcb);
 	}
 };
@@ -778,52 +833,60 @@ DNSServer.prototype.notify = function (peer, zone) {
 };
 
 DNSServer.prototype.getPeerVersions = function (cb) {
-	var self = this;
 	var peers = {};
-	this.redis.keys('peer:*:version', function (err, keys) {
-		if (err) {
-			cb(err);
+	this.redisPool.claim(function (rerr, handle, redis) {
+		if (rerr) {
+			cb(rerr);
 			return;
 		}
-		if (keys === null || keys.length === 0) {
-			cb(null, {});
-			return;
-		}
-
-		vasync.forEachParallel({
-			func: addPeer,
-			inputs: keys
-		}, function (err2, res) {
-			if (err2)
-				cb(err2);
-			else
-				cb(null, peers);
-		});
-
-		function addPeer(key, scb) {
-			var parts = key.split(':');
-			if (parts.length !== 3 || parts[2] !== 'version') {
-				scb();
+		redis.keys('peer:*:version', function (err, keys) {
+			if (err) {
+				handle.release();
+				cb(err);
 				return;
 			}
-			self.redis.get(key, function (err3, val) {
-				var host = parts[1];
-				if (err3) {
-					scb(err3);
+			if (keys === null || keys.length === 0) {
+				handle.release();
+				cb(null, {});
+				return;
+			}
+
+			vasync.forEachParallel({
+				func: addPeer,
+				inputs: keys
+			}, function (err2, res) {
+				handle.release();
+				if (err2)
+					cb(err2);
+				else
+					cb(null, peers);
+			});
+
+			function addPeer(key, scb) {
+				var parts = key.split(':');
+				if (parts.length !== 3 ||
+				    parts[2] !== 'version') {
+					scb();
 					return;
 				}
-				if (val !== null)
-					peers[host] = val;
-				scb();
-			});
-		}
+				redis.get(key, function (err3, val) {
+					var host = parts[1];
+					if (err3) {
+						scb(err3);
+						return;
+					}
+					if (val !== null)
+						peers[host] = val;
+					scb();
+				});
+			}
+		});
 	});
 };
 
-DNSServer.prototype.getPeerSerials = function (cb) {
-	var self = this;
+DNSServer.prototype.getPeerSerials = function (r, cb) {
 	var peers = {};
-	this.redis.keys('peer:*', function (err, keys) {
+	r.keys('peer:*', function (err, keys) {
 		if (err) {
 			cb(err);
 			return;
@@ -849,7 +912,7 @@ DNSServer.prototype.getPeerSerials = function (cb) {
 				scb();
 				return;
 			}
-			self.redis.hgetall(key, function (err3, obj) {
+			r.hgetall(key, function (err3, obj) {
 				if (err3) {
 					scb(err3);
 					return;
@@ -920,7 +983,7 @@ DNSServer.prototype.startUnblacklist = function (peer) {
  */
 DNSServer.prototype.handleTransfer = function (q, z, cb) {
 	var self = this;
-	var r = this.redis;
+	var r = q.redis;
 	var i;
 	var addr = q.src.address;
 
@@ -933,7 +996,7 @@ DNSServer.prototype.handleTransfer = function (q, z, cb) {
 		return;
 	}
 
-	this.makeSOA(z, function (err, soa) {
+	this.makeSOA(q, z, function (err, soa) {
 		if (err) {
 			q.log.warn({err: err}, 'makesoa failed');
 			q.setError('eserver');
@@ -1082,7 +1145,7 @@ DNSServer.prototype.handleTransfer = function (q, z, cb) {
 
 DNSServer.prototype.sendIxfrDiff = function (q, z, from, to, soa, cb) {
 	var self = this;
-	var r = this.redis;
+	var r = q.redis;
 
 	var rmKey = sprintf('zone:%s:%d:%d:remove', z, from, to);
 	var addKey = sprintf('zone:%s:%d:%d:add', z, from, to);
@@ -1181,12 +1244,13 @@ DNSServer.prototype.sendIxfrDiff = function (q, z, from, to, soa, cb) {
 /*
  * Generates an SOA (start-of-authority) record for a zone.
  */
-DNSServer.prototype.makeSOA = function (z, cb) {
+DNSServer.prototype.makeSOA = function (q, z, cb) {
+	assert.object(q, 'query');
 	assert.string(z, 'zone');
 	assert.func(cb, 'callback');
 
 	var self = this;
-	var r = this.redis;
+	var r = q.redis;
 
 	r.get('zone:' + z + ':latest', function (err, val) {
 		var serial;
diff --git a/package.json b/package.json
index 6230cb7..9562f93 100644
--- a/package.json
+++ b/package.json
@@ -26,7 +26,7 @@
     "assert-plus": "0.1.5",
     "bunyan": "1.5.1",
     "changefeed": "1.2.0",
-    "cueball": "1.1.1",
+    "cueball": "1.1.7",
     "dashdash": "1.10.1",
     "deep-equal": "1.0.1",
     "ipaddr.js": "1.0.3",
diff --git a/server.js b/server.js
index 3535fc1..13fa491 100644
--- a/server.js
+++ b/server.js
@@ -13,6 +13,7 @@ var DNSServer = require('./lib/dns-server');
 var APIServer = require('./lib/api-server');
 var restify = require('restify');
 var path = require('path');
+var cueball = require('cueball');
 
 var confPath;
 if (process.argv[2])
@@ -21,8 +22,6 @@ if (confPath === undefined)
 	confPath = path.join(__dirname, 'etc', 'config.json');
 var conf = config.parse(confPath);
 
-var client = redis.createClient(conf.redis_opts);
-
 var log = bunyan.createLogger({
 	name: 'cns',
 	level: process.env.LOGLEVEL || 'debug',
@@ -32,15 +31,48 @@ var log = bunyan.createLogger({
 	}
 });
 
+var res = cueball.resolverForIpOrDomain({ input: '127.0.0.1:6379' });
+var redisPool = new cueball.ConnectionPool({
+	resolver: res,
+	domain: 'localhost',
+	service: '_redis._tcp',
+	defaultPort: 6379,
+	log: log,
+	spares: 4,
+	maximum: 100,
+	recovery: {
+		default: {
+			timeout: 1000,
+			delay: 500,
+			retries: 5
+		}
+	},
+	constructor: function (backend) {
+		var c = redis.createClient({
+			host: backend.address,
+			port: backend.port,
+			enable_offline_queue: false,
+			max_attempts: 1
+		});
+		c.destroy = function () {
+			c.end(false);
+		};
+		c.unref = function () {};
+		c.ref = function () {};
+		return (c);
+	}
+});
+res.start();
+
 var s = new DNSServer({
-	client: client,
+	redisPool: redisPool,
 	log: log,
 	config: conf,
 	port: 53
 });
 
 var api = new APIServer({
-	client: client,
+	redisPool: redisPool,
 	log: log,
 	config: conf,
 	port: 80,
diff --git a/test/unit/dns-server.test.js b/test/unit/dns-server.test.js
index f971931..fa5c650 100644
--- a/test/unit/dns-server.test.js
+++ b/test/unit/dns-server.test.js
@@ -18,7 +18,7 @@ var MockRedis = require('./mock-redis');
 var utils = require('../../lib/utils');
 
 var sandbox;
-var redis;
+var redisPool, redis;
 var server;
 var currentSerial = 1;
 
@@ -31,8 +31,12 @@ test('setup sandbox', function (t) {
 		return (currentSerial);
 	});
 	t.equal(utils.currentSerial(), 1);
-	redis = new MockRedis();
-	t.end();
+	redisPool = MockRedis.createPool();
+	redisPool.claim(function (err, handle, r) {
+		t.ifError(err);
+		redis = r;
+		t.end();
+	});
 });
 
 test('create basic dataset', function (t) {
@@ -87,7 +91,7 @@ test('create basic dataset', function (t) {
 
 test('create server', function (t) {
 	server = new DNSServer({
-		client: redis,
+		redisPool: redisPool,
 		port: 9953,
 		address: '127.0.0.1',
 		config: {
diff --git a/test/unit/mock-redis.js b/test/unit/mock-redis.js
index 5e8a9c9..8f85b3f 100644
--- a/test/unit/mock-redis.js
+++ b/test/unit/mock-redis.js
@@ -8,12 +8,50 @@
 
 var assert = require('assert-plus');
 var minimatch = require('minimatch');
+var cueball = require('cueball');
+var util = require('util');
+var EventEmitter = require('events').EventEmitter;
 
 module.exports = MockRedis;
 
-function MockRedis() {
-	this.db = {};
+function MockRedis(db) {
+	this.db = db || {};
+	EventEmitter.call(this);
 }
+util.inherits(MockRedis, EventEmitter);
+MockRedis.createPool = function () {
+	var db = {};
+	var res = cueball.resolverForIpOrDomain({ input: '127.0.0.1:6379' });
+	var pool = new cueball.ConnectionPool({
+		domain: 'localhost',
+		resolver: res,
+		service: '_redis._tcp',
+		defaultPort: 6379,
+		spares: 4,
+		maximum: 100,
+		recovery: {
+			default: {
+				timeout: 100,
+				retries: 1,
+				delay: 0
+			}
+		},
+		constructor: function (backend) {
+			var c = new MockRedis(db);
+			setImmediate(function () {
+				c.emit('connect');
+			})
+			c.destroy = function () {
+				c.emit('end');
+			};
+			c.unref = function () {};
+			c.ref = function () {};
+			return (c);
+		}
+	});
+	res.start();
+	return (pool);
+};
 MockRedis.prototype.keys = function (filter, cb) {
 	var keys = Object.keys(this.db).filter(function (k) {
 		return (minimatch(k, filter));
-- 
2.21.0

