commit 402ca396155be554032f9fae7e0817b115234093 (refs/changes/32/4832/3)
Author: Jan Wyszynski <jan.wyszynski@joyent.com>
Date:   2018-09-13T01:56:08+00:00 (1 year, 1 month ago)
    
    MANTA-3945 garbage-collector loads index shard list incorrectly

diff --git a/cmd/server.js b/cmd/server.js
index a4599d0..07d56c2 100644
--- a/cmd/server.js
+++ b/cmd/server.js
@@ -182,13 +182,50 @@ load_index_shard_range(ctx, done)
 		return;
 	}
 
-	ctx.ctx_cfg.index_shard_lo = parseInt(
-			index_shards[0].host.charAt(0), 10);
+	/*
+	 * Today, garbage-collector instances are assigned shards in contiguous
+	 * inclusive ranges like [2,8]. This assignment scheme relies on the
+	 * convention that index shards in production deployments are given
+	 * consecutive numeric shard names: 2.moray.{{DOMAIN}},
+	 * 3.moray.{{DOMAIN}} ... 97.moray.{{DOMAIN}}. In order to ensure that
+	 * the collector doesn't attempt to process records for non-index
+	 * shards, it loads the complete index shard range from the SAPI Manta
+	 * application below.
+	 *
+	 * The list of shards in the SAPI Manta application's INDEX_MORAY_SHARDS
+	 * metadata array are not ordered. It is also not the case that the
+	 * shard whose name is the highest numeric value in the list contains
+	 * the "last" field (the "last" field is syntax required by hogan.js
+	 * template engine).
+	 *
+	 * In order to correctly filter operator requests to GC from shards that
+	 * are not index shards, we retrieve the full range of index shards by
+	 * finding the lowest and highest valued numeric shard names in the
+	 * list. Every time a request to change the range of shards a collector
+	 * should GC from is made, a check is done to ensure the new range is a
+	 * subset of the range of full index shards retrieved below.
+	 *
+	 * There is future work planned to remove the assumption of consecutive
+	 * numeric index shard names from the garbage-collector.
+	 */
+	function parse_shard_number(shard) {
+		return (parseInt(shard.substring(0, shard.indexOf('.')), 10));
+	}
+
+	var init = parse_shard_number(index_shards[0].host);
+
+	ctx.ctx_cfg.index_shard_lo = init;
+	ctx.ctx_cfg.index_shard_hi = init;
 
 	index_shards.forEach(function (shard) {
-		if (shard.last) {
-			ctx.ctx_cfg.index_shard_hi = parseInt(
-				shard.host.charAt(0), 10);
+		var shard_num = parse_shard_number(shard.host);
+
+		if (ctx.ctx_cfg.index_shard_lo > shard_num) {
+			ctx.ctx_cfg.index_shard_lo = shard_num;
+		}
+
+		if (ctx.ctx_cfg.index_shard_hi < shard_num) {
+			ctx.ctx_cfg.index_shard_hi = shard_num;
 		}
 	});
 
