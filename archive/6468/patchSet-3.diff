commit afad39ca8bcb6339bc193a36befa9ec698bfe46c
Author: Kelly McLaughlin <kelly.mclaughlin@joyent.com>
Date:   2019-06-20T07:10:46-06:00 (4 months ago)
    
    MANTA-4361 Add object update handler to boray

diff --git a/src/lib.rs b/src/lib.rs
index 8d6c9dc..3a26601 100644
--- a/src/lib.rs
+++ b/src/lib.rs
@@ -57,15 +57,29 @@ pub mod util {
 
         let method = msg.data.m.name.as_str();
         let ret = match method {
-            "getobject"    => object::get_handler(msg.id, &args, response, &pool, &log),
-            "createobject" => object::create_handler(msg.id, &args, response, &pool, &log),
-            "deleteobject" => object::delete_handler(msg.id, &args, response, &pool, &log),
-            "listobjects"  => object::list_handler(msg.id, &args, response, &pool, &log),
-            "getbucket"    => bucket::get_handler(msg.id, &args, response, &pool, &log),
-            "createbucket" => bucket::create_handler(msg.id, &args, response, &pool, &log),
-            "deletebucket" => bucket::delete_handler(msg.id, &args, response, &pool, &log),
-            "listbuckets"  => bucket::list_handler(msg.id, &args, response, &pool, &log),
-            _ => return Err(Error::new(ErrorKind::Other, format!("Unsupported functon: {}", method)))
+            "getobject"    =>
+                object::get_handler(msg.id, &args, response, &pool, &log),
+            "createobject" =>
+                object::create_handler(msg.id, &args, response, &pool, &log),
+            "updateobject" =>
+                object::update_handler(msg.id, &args, response, &pool, &log),
+            "deleteobject" =>
+                object::delete_handler(msg.id, &args, response, &pool, &log),
+
+            "listobjects"  =>
+                object::list_handler(msg.id, &args, response, &pool, &log),
+            "getbucket"    =>
+                bucket::get_handler(msg.id, &args, response, &pool, &log),
+            "createbucket" =>
+                bucket::create_handler(msg.id, &args, response, &pool, &log),
+            "deletebucket" =>
+                bucket::delete_handler(msg.id, &args, response, &pool, &log),
+            "listbuckets"  =>
+                bucket::list_handler(msg.id, &args, response, &pool, &log),
+            _ => {
+                let err_msg = format!("Unsupported functon: {}", method);
+                return Err(Error::new(ErrorKind::Other, err_msg))
+            }
         };
 
         // If we are here, then the method name was valid, and the request may or
diff --git a/src/object.rs b/src/object.rs
index 65f9eac..dc72878 100644
--- a/src/object.rs
+++ b/src/object.rs
@@ -129,6 +129,18 @@ pub struct CreateObjectPayload {
     pub properties     : Option<Value>
 }
 
+#[derive(Debug, Serialize, Deserialize)]
+pub struct UpdateObjectPayload {
+    pub owner          : Uuid,
+    pub bucket_id      : Uuid,
+    pub name           : String,
+    pub id             : Uuid,
+    pub vnode          : u64,
+    pub content_type   : String,
+    pub headers        : Hstore,
+    pub properties     : Option<Value>
+}
+
 #[derive(Debug, Serialize, Deserialize)]
 pub struct ListObjectsPayload {
     pub owner     : Uuid,
@@ -296,11 +308,61 @@ pub fn create_handler(msg_id: u32,
         .map_err(|_e| other_error("postgres error"))
 }
 
-pub fn delete_handler(msg_id: u32,
+pub fn update_handler(msg_id: u32,
                       args: &[Value],
                       mut response: Vec<FastMessage>,
                       pool: &ConnectionPool<PostgresConnection, StaticIpResolver, impl FnMut(&Backend) -> PostgresConnection + Send + 'static>,
                       log: &Logger) -> Result<Vec<FastMessage>, IOError> {
+    debug!(log, "handling updateobject function request");
+
+    let arg0 = match &args[0] {
+        Value::Object(_) => &args[0],
+        _ => return Err(other_error("Expected JSON object"))
+    };
+
+    let data_clone = arg0.clone();
+    let payload_result: Result<UpdateObjectPayload, _> =
+        serde_json::from_value(data_clone);
+
+    let payload = match payload_result {
+        Ok(o) => o,
+        Err(_) => return Err(other_error("Failed to parse JSON data as payload for updateobject function"))
+    };
+
+    // Make db request and form response
+    // let response_msg: Result<FastMessage, IOError> =
+    update(payload, pool)
+        .and_then(|maybe_resp| {
+            let method = String::from("updateobject");
+            match maybe_resp {
+                Some(resp) => {
+                    let value = array_wrap(serde_json::to_value(resp).unwrap());
+                    let msg = FastMessage::data(msg_id, FastMessageData::new(method, value));
+                    response.push(msg);
+                    Ok(response)
+                },
+                None => {
+                    let value = array_wrap(object_not_found());
+                    let err_msg = FastMessage::data(msg_id, FastMessageData::new(method, value));
+                    response.push(err_msg);
+                    Ok(response)
+                }
+            }
+        })
+        //TODO: Proper error handling
+        .map_err(|e| {
+            println!("Error: {}", e);
+            other_error("postgres error")
+        })
+}
+
+pub fn delete_handler(
+    msg_id: u32,
+    args: &[Value],
+    mut response: Vec<FastMessage>,
+    pool: &ConnectionPool<PostgresConnection, StaticIpResolver, impl FnMut(&Backend) -> PostgresConnection + Send + 'static>,
+    log: &Logger
+) -> Result<Vec<FastMessage>, IOError> {
     debug!(log, "handling deleteobject function request");
 
     let arg0 = match &args[0] {
@@ -468,6 +530,33 @@ fn create(payload: CreateObjectPayload,
         })
 }
 
+fn update(payload: UpdateObjectPayload,
+          pool: &ConnectionPool<PostgresConnection, StaticIpResolver, impl FnMut(&Backend) -> PostgresConnection + Send + 'static>)
+          -> Result<Option<ObjectResponse>, IOError>
+{
+    let mut conn = pool.claim().unwrap();
+    let mut txn = (*conn).transaction().unwrap();
+    let update_sql = update_sql(payload.vnode);
+
+    sql::txn_query(sql::Method::ObjectUpdate, &mut txn, update_sql.as_str(),
+                     &[&payload.content_type,
+                       &payload.headers,
+                       &payload.properties,
+                       &payload.owner,
+                       &payload.bucket_id,
+                       &payload.name])
+
+        .map_err(|e| {
+            let pg_err = format!("{}", e);
+            IOError::new(IOErrorKind::Other, pg_err)
+        })
+        .and_then(response)
+        .and_then(|response| {
+            txn.commit().unwrap();
+            Ok(response)
+        })
+}
+
 fn insert_delete_table_sql(vnode: u64) -> String {
     let vnode_str = vnode.to_string();
     ["INSERT INTO manta_bucket_",
@@ -509,6 +598,22 @@ fn create_sql(vnode: u64) -> String {
        sharks, properties"].concat()
 }
 
+fn update_sql(vnode: u64) -> String {
+    ["UPDATE manta_bucket_",
+     &vnode.to_string(),
+     &".manta_bucket_object \
+       SET content_type = $1,
+       headers = $2, \
+       properties = $3, \
+       modified = current_timestamp \
+       WHERE owner = $4 \
+       AND bucket_id = $5 \
+       AND name = $6 \
+       RETURNING id, owner, bucket_id, name, created, modified, \
+       content_length, content_md5, content_type, headers, \
+       sharks, properties"].concat()
+}
+
 fn delete_sql(vnode: u64) -> String {
     ["DELETE FROM manta_bucket_",
      &vnode.to_string(),
diff --git a/src/sql.rs b/src/sql.rs
index 206dddc..c91e8cb 100644
--- a/src/sql.rs
+++ b/src/sql.rs
@@ -24,7 +24,8 @@ pub enum Method {
     ObjectGet,
     ObjectList,
     ObjectDelete,
-    ObjectDeleteMove
+    ObjectDeleteMove,
+    ObjectUpdate
 }
 
 impl Method {
@@ -40,7 +41,8 @@ impl Method {
             Method::ObjectGet => "ObjectGet",
             Method::ObjectList => "ObjectList",
             Method::ObjectDelete => "ObjectDelete",
-            Method::ObjectDeleteMove => "ObjectDeleteMove"
+            Method::ObjectDeleteMove => "ObjectDeleteMove",
+            Method::ObjectUpdate => "ObjectUpdate"
         }
     }
 }
diff --git a/tests/rpc_handlers.rs b/tests/rpc_handlers.rs
index ba0ceaf..83180af 100644
--- a/tests/rpc_handlers.rs
+++ b/tests/rpc_handlers.rs
@@ -247,8 +247,47 @@ fn verify_rpc_handlers() {
     assert_eq!(get_object_response_result.unwrap(), BorayError::new(BorayErrorType::ObjectNotFound));
 
 
-    // Create an object
+    // Try to update an nonexistent object's metadata
     let object_id = Uuid::new_v4();
+
+    let mut update_headers = HashMap::new();
+    let _ = update_headers.insert(
+        "m-custom-header1".to_string(),
+        Some("customheaderval1".to_string())
+    );
+    let _ = update_headers.insert(
+        "m-custom-header2".to_string(),
+        Some("customheaderval2".to_string())
+    );
+
+    let update_object_payload = object::UpdateObjectPayload {
+        owner: owner_id,
+        bucket_id,
+        name: object.clone(),
+        id: object_id,
+        vnode: 1,
+        content_type: "text/html".into(),
+        headers: update_headers,
+        properties: None,
+    };
+
+    let update_object_json = serde_json::to_value(update_object_payload).unwrap();
+    let update_object_args = vec![update_object_json];
+    let mut update_object_result =
+        object::update_handler(msg_id, &update_object_args, vec![], &pool, &log);
+
+    assert!(update_object_result.is_ok());
+    let mut update_object_response = update_object_result.unwrap();
+    assert_eq!(update_object_response.len(), 1);
+
+    let update_object_response_result: Result<BorayError, _> =
+        serde_json::from_value(update_object_response[0].data.d[0].clone());
+    assert!(update_object_response_result.is_ok());
+    assert_eq!(update_object_response_result.unwrap(),
+               BorayError::new(BorayErrorType::ObjectNotFound));
+
+
+    // Create an object
     let shark1 = object::StorageNodeIdentifier {
         datacenter: "us-east-1".into(),
         manta_storage_id: "1.stor.us-east.joyent.com".into(),
@@ -298,7 +337,41 @@ fn verify_rpc_handlers() {
     let get_object_response_result: Result<object::ObjectResponse, _> =
         serde_json::from_value(get_object_response[0].data.d[0].clone());
     assert!(get_object_response_result.is_ok());
-    assert_eq!(get_object_response_result.unwrap().name, object);
+    let mut get_object_unwrapped_result = get_object_response_result.unwrap();
+    assert_eq!(get_object_unwrapped_result.name, object);
+    assert_eq!(&get_object_unwrapped_result.content_type, "text/plain");
+
+
+    // Update the object's metadata and verify it is successful
+    update_object_result =
+        object::update_handler(msg_id, &update_object_args, vec![], &pool, &log);
+
+    assert!(update_object_result.is_ok());
+    update_object_response = update_object_result.unwrap();
+    assert_eq!(update_object_response.len(), 1);
+
+    let update_object_response_result: Result<object::ObjectResponse, _> =
+        serde_json::from_value(update_object_response[0].data.d[0].clone());
+    assert!(update_object_response_result.is_ok());
+    let update_object_unwrapped_result = update_object_response_result.unwrap();
+    assert_eq!(update_object_unwrapped_result.name, object);
+    assert_eq!(&update_object_unwrapped_result.content_type, "text/html");
+
+
+    // Read object again and verify the metadata update
+    get_object_result =
+        object::get_handler(msg_id, &get_object_args, vec![], &pool, &log);
+
+    assert!(get_object_result.is_ok());
+    let get_object_response = get_object_result.unwrap();
+    assert_eq!(get_object_response.len(), 1);
+
+    let get_object_response_result: Result<object::ObjectResponse, _> =
+        serde_json::from_value(get_object_response[0].data.d[0].clone());
+    assert!(get_object_response_result.is_ok());
+    get_object_unwrapped_result = get_object_response_result.unwrap();
+    assert_eq!(get_object_unwrapped_result.name, object);
+    assert_eq!(&get_object_unwrapped_result.content_type, "text/html");
 
 
     // Delete object
