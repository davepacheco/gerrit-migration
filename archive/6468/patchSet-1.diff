From 192aeb832d7bf280ff7405400cdacfed3732c6df Mon Sep 17 00:00:00 2001
From: Kelly McLaughlin <kelly.mclaughlin@joyent.com>
Date: Wed, 19 Jun 2019 13:00:06 -0600
Subject: [PATCH] MANTA-4361 Add object update handler to boray

---
 src/lib.rs            |  32 +++++++++----
 src/object.rs         | 108 +++++++++++++++++++++++++++++++++++++++++-
 src/sql.rs            |   6 ++-
 tests/rpc_handlers.rs |  75 ++++++++++++++++++++++++++++-
 4 files changed, 207 insertions(+), 14 deletions(-)

diff --git a/src/lib.rs b/src/lib.rs
index 8d6c9dc..4967923 100644
--- a/src/lib.rs
+++ b/src/lib.rs
@@ -57,15 +57,29 @@ pub mod util {
 
         let method = msg.data.m.name.as_str();
         let ret = match method {
-            "getobject"    => object::get_handler(msg.id, &args, response, &pool, &log),
-            "createobject" => object::create_handler(msg.id, &args, response, &pool, &log),
-            "deleteobject" => object::delete_handler(msg.id, &args, response, &pool, &log),
-            "listobjects"  => object::list_handler(msg.id, &args, response, &pool, &log),
-            "getbucket"    => bucket::get_handler(msg.id, &args, response, &pool, &log),
-            "createbucket" => bucket::create_handler(msg.id, &args, response, &pool, &log),
-            "deletebucket" => bucket::delete_handler(msg.id, &args, response, &pool, &log),
-            "listbuckets"  => bucket::list_handler(msg.id, &args, response, &pool, &log),
-            _ => return Err(Error::new(ErrorKind::Other, format!("Unsupported functon: {}", method)))
+            "getobject"    =>
+                object::get_handler(msg.id, &args, response, &pool, &log),
+            "createobject" =>
+                object::create_handler(msg.id, &args, response, &pool, &log),
+            "updatebject" =>
+                object::update_handler(msg.id, &args, response, &pool, &log),
+            "deleteobject" =>
+                object::delete_handler(msg.id, &args, response, &pool, &log),
+
+            "listobjects"  =>
+                object::list_handler(msg.id, &args, response, &pool, &log),
+            "getbucket"    =>
+                bucket::get_handler(msg.id, &args, response, &pool, &log),
+            "createbucket" =>
+                bucket::create_handler(msg.id, &args, response, &pool, &log),
+            "deletebucket" =>
+                bucket::delete_handler(msg.id, &args, response, &pool, &log),
+            "listbuckets"  =>
+                bucket::list_handler(msg.id, &args, response, &pool, &log),
+            _ => {
+                let err_msg = format!("Unsupported functon: {}", method);
+                return Err(Error::new(ErrorKind::Other, err_msg))
+            }
         };
 
         // If we are here, then the method name was valid, and the request may or
diff --git a/src/object.rs b/src/object.rs
index 65f9eac..7293701 100644
--- a/src/object.rs
+++ b/src/object.rs
@@ -129,6 +129,18 @@ pub struct CreateObjectPayload {
     pub properties     : Option<Value>
 }
 
+#[derive(Debug, Serialize, Deserialize)]
+pub struct UpdateObjectPayload {
+    pub owner          : Uuid,
+    pub bucket_id      : Uuid,
+    pub name           : String,
+    pub id             : Uuid,
+    pub vnode          : u64,
+    pub content_type   : String,
+    pub headers        : Hstore,
+    pub properties     : Option<Value>
+}
+
 #[derive(Debug, Serialize, Deserialize)]
 pub struct ListObjectsPayload {
     pub owner     : Uuid,
@@ -296,11 +308,67 @@ pub fn create_handler(msg_id: u32,
         .map_err(|_e| other_error("postgres error"))
 }
 
-pub fn delete_handler(msg_id: u32,
+pub fn update_handler(msg_id: u32,
                       args: &[Value],
                       mut response: Vec<FastMessage>,
                       pool: &ConnectionPool<PostgresConnection, StaticIpResolver, impl FnMut(&Backend) -> PostgresConnection + Send + 'static>,
                       log: &Logger) -> Result<Vec<FastMessage>, IOError> {
+    debug!(log, "handling updateobject function request");
+
+    let arg0 = match &args[0] {
+        Value::Object(_) => &args[0],
+        _ => return Err(other_error("Expected JSON object"))
+    };
+
+    let data_clone = arg0.clone();
+    let payload_result: Result<UpdateObjectPayload, _> =
+        serde_json::from_value(data_clone);
+
+    let payload = match payload_result {
+        Ok(o) => o,
+        Err(_) => return Err(other_error("Failed to parse JSON data as payload for updateobject function"))
+    };
+
+    // Make db request and form response
+    let response_msg: Result<FastMessage, IOError> =
+        update(payload, pool)
+        .and_then(|affected_rows| {
+            let method = String::from("updateobject");
+            if affected_rows > 0 {
+                let value = array_wrap(serde_json::to_value(affected_rows).unwrap());
+                let msg = FastMessage::data(msg_id, FastMessageData::new(method, value));
+                Ok(msg)
+            } else {
+                let value = array_wrap(object_not_found());
+                let err_msg = FastMessage::data(msg_id, FastMessageData::new(method, value));
+                Ok(err_msg)
+            }
+        })
+        .or_else(|e| {
+            // TODO: Write a helper function to deconstruct the postgres::Error
+            // and populate meaningful name and message fields for the error
+            // dependent on the details of the postgres error.
+            let err_str = format!("{}", e);
+            let value = array_wrap(json!({
+                "name": "PostgresError",
+                "message": err_str
+            }));
+            let method = String::from("updateobject");
+            let err_msg_data = FastMessageData::new(method, value);
+            let err_msg = FastMessage::error(msg_id, err_msg_data);
+            Ok(err_msg)
+        });
+    response.push(response_msg.unwrap());
+    Ok(response)
+}
+
+pub fn delete_handler(
+    msg_id: u32,
+    args: &[Value],
+    mut response: Vec<FastMessage>,
+    pool: &ConnectionPool<PostgresConnection, StaticIpResolver, impl FnMut(&Backend) -> PostgresConnection + Send + 'static>,
+    log: &Logger
+) -> Result<Vec<FastMessage>, IOError> {
     debug!(log, "handling deleteobject function request");
 
     let arg0 = match &args[0] {
@@ -468,6 +536,31 @@ fn create(payload: CreateObjectPayload,
         })
 }
 
+fn update(payload: UpdateObjectPayload,
+          pool: &ConnectionPool<PostgresConnection, StaticIpResolver, impl FnMut(&Backend) -> PostgresConnection + Send + 'static>)
+          -> Result<u64, IOError>
+{
+    let mut conn = pool.claim().unwrap();
+    let mut txn = (*conn).transaction().unwrap();
+    let update_sql = update_sql(payload.vnode);
+
+    sql::txn_execute(sql::Method::ObjectUpdate, &mut txn, update_sql.as_str(),
+                     &[&payload.content_type,
+                       &payload.headers,
+                       &payload.properties,
+                       &payload.owner,
+                       &payload.bucket_id,
+                       &payload.name])
+        .and_then(|row_count| {
+            txn.commit().unwrap();
+            Ok(row_count)
+        })
+        .map_err(|e| {
+            let pg_err = format!("{}", e);
+            IOError::new(IOErrorKind::Other, pg_err)
+        })
+}
+
 fn insert_delete_table_sql(vnode: u64) -> String {
     let vnode_str = vnode.to_string();
     ["INSERT INTO manta_bucket_",
@@ -509,6 +602,19 @@ fn create_sql(vnode: u64) -> String {
        sharks, properties"].concat()
 }
 
+fn update_sql(vnode: u64) -> String {
+    ["UPDATE manta_bucket_",
+     &vnode.to_string(),
+     &".manta_bucket_object \
+       SET content_type = $1,
+       headers = $2, \
+       properties = $3, \
+       modified = current_timestamp \
+       WHERE owner = $4 \
+       AND bucket_id = $5 \
+       AND name = $6"].concat()
+}
+
 fn delete_sql(vnode: u64) -> String {
     ["DELETE FROM manta_bucket_",
      &vnode.to_string(),
diff --git a/src/sql.rs b/src/sql.rs
index 206dddc..c91e8cb 100644
--- a/src/sql.rs
+++ b/src/sql.rs
@@ -24,7 +24,8 @@ pub enum Method {
     ObjectGet,
     ObjectList,
     ObjectDelete,
-    ObjectDeleteMove
+    ObjectDeleteMove,
+    ObjectUpdate
 }
 
 impl Method {
@@ -40,7 +41,8 @@ impl Method {
             Method::ObjectGet => "ObjectGet",
             Method::ObjectList => "ObjectList",
             Method::ObjectDelete => "ObjectDelete",
-            Method::ObjectDeleteMove => "ObjectDeleteMove"
+            Method::ObjectDeleteMove => "ObjectDeleteMove",
+            Method::ObjectUpdate => "ObjectUpdate"
         }
     }
 }
diff --git a/tests/rpc_handlers.rs b/tests/rpc_handlers.rs
index ba0ceaf..db4dfea 100644
--- a/tests/rpc_handlers.rs
+++ b/tests/rpc_handlers.rs
@@ -247,8 +247,47 @@ fn verify_rpc_handlers() {
     assert_eq!(get_object_response_result.unwrap(), BorayError::new(BorayErrorType::ObjectNotFound));
 
 
-    // Create an object
+    // Try to update an nonexistent object's metadata
     let object_id = Uuid::new_v4();
+
+    let mut update_headers = HashMap::new();
+    let _ = update_headers.insert(
+        "m-custom-header1".to_string(),
+        Some("customheaderval1".to_string())
+    );
+    let _ = update_headers.insert(
+        "m-custom-header2".to_string(),
+        Some("customheaderval2".to_string())
+    );
+
+    let update_object_payload = object::UpdateObjectPayload {
+        owner: owner_id,
+        bucket_id,
+        name: object.clone(),
+        id: object_id,
+        vnode: 1,
+        content_type: "text/html".into(),
+        headers: update_headers,
+        properties: None,
+    };
+
+    let update_object_json = serde_json::to_value(update_object_payload).unwrap();
+    let update_object_args = vec![update_object_json];
+    let mut update_object_result =
+        object::update_handler(msg_id, &update_object_args, vec![], &pool, &log);
+
+    assert!(update_object_result.is_ok());
+    let update_object_response = update_object_result.unwrap();
+    assert_eq!(update_object_response.len(), 1);
+
+    let update_object_response_result: Result<BorayError, _> =
+        serde_json::from_value(update_object_response[0].data.d[0].clone());
+    assert!(update_object_response_result.is_ok());
+    assert_eq!(update_object_response_result.unwrap(),
+               BorayError::new(BorayErrorType::ObjectNotFound));
+
+
+    // Create an object
     let shark1 = object::StorageNodeIdentifier {
         datacenter: "us-east-1".into(),
         manta_storage_id: "1.stor.us-east.joyent.com".into(),
@@ -298,7 +337,39 @@ fn verify_rpc_handlers() {
     let get_object_response_result: Result<object::ObjectResponse, _> =
         serde_json::from_value(get_object_response[0].data.d[0].clone());
     assert!(get_object_response_result.is_ok());
-    assert_eq!(get_object_response_result.unwrap().name, object);
+    let mut get_object_unwrapped_result = get_object_response_result.unwrap();
+    assert_eq!(get_object_unwrapped_result.name, object);
+    assert_eq!(&get_object_unwrapped_result.content_type, "text/plain");
+
+
+    // Update the object's metadata and verify it is successful
+    update_object_result =
+        object::update_handler(msg_id, &update_object_args, vec![], &pool, &log);
+
+    assert!(update_object_result.is_ok());
+    let update_object_response = update_object_result.unwrap();
+    assert_eq!(update_object_response.len(), 1);
+
+    let update_object_response_result: Result<u64, _> =
+        serde_json::from_value(update_object_response[0].data.d[0].clone());
+    assert!(update_object_response_result.is_ok());
+    assert_eq!(update_object_response_result.unwrap(), 1);
+
+
+    // Read object again and verify the metadata update
+    get_object_result =
+        object::get_handler(msg_id, &get_object_args, vec![], &pool, &log);
+
+    assert!(get_object_result.is_ok());
+    let get_object_response = get_object_result.unwrap();
+    assert_eq!(get_object_response.len(), 1);
+
+    let get_object_response_result: Result<object::ObjectResponse, _> =
+        serde_json::from_value(get_object_response[0].data.d[0].clone());
+    assert!(get_object_response_result.is_ok());
+    get_object_unwrapped_result = get_object_response_result.unwrap();
+    assert_eq!(get_object_unwrapped_result.name, object);
+    assert_eq!(&get_object_unwrapped_result.content_type, "text/html");
 
 
     // Delete object
-- 
2.21.0

