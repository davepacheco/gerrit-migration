commit f9966155ec37242c615ae39e1da119d7f623995f (refs/changes/32/932/2)
Author: Alex Wilson <alex.wilson@joyent.com>
Date:   2016-11-21T16:39:53-08:00 (2 years, 11 months ago)
    
    joyent/node-cueball#46 want filter to restrict connection drop rate

diff --git a/lib/pool.js b/lib/pool.js
index 5c705d0..c1927f8 100644
--- a/lib/pool.js
+++ b/lib/pool.js
@@ -30,6 +30,48 @@ const EventEmitter = mod_events.EventEmitter;
 const Queue = require('./queue');
 const ConnectionFSM = require('./connection-fsm');
 
+var LP_RATE = 5; /* Hz */
+var LP_INT = Math.round(1000 / LP_RATE);
+var LP_TAPS = genTaps(128, -0.2);
+
+function genTaps(count, tc) {
+	var taps = new Float64Array(count);
+	var sum = 0.0;
+	for (var i = 0; i < count; ++i) {
+		taps[i] = Math.exp(tc * i);
+		sum += taps[i];
+	}
+	for (i = 0; i < count; ++i) {
+		taps[i] /= sum;
+	}
+	return (taps);
+}
+
+function LowPassFilter() {
+	this.lpf_s = new Float64Array(LP_TAPS.length);
+	this.lpf_p = 0;
+	this.lpf_int = 1.0 / LP_RATE;
+}
+LowPassFilter.prototype.put = function (v) {
+	this.lpf_s[this.lpf_p++] = v;
+	while (this.lpf_p >= LP_TAPS.length)
+		this.lpf_p -= LP_TAPS.length;
+};
+LowPassFilter.prototype.get = function () {
+	var i = this.lpf_p;
+	if (this.lpf_count < 1)
+		i--;
+	if (i < 0)
+		i += LP_TAPS.length;
+	var acc = 0.0;
+	for (var j = 0; j < LP_TAPS.length; ++j) {
+		acc += this.lpf_s[i] * LP_TAPS[j];
+		if (--i < 0)
+			i += LP_TAPS.length;
+	}
+	return (acc);
+};
+
 /*
  * A ConnectionPool holds a pool of ConnectionFSMs that are kept up to date
  * based on the output of a Resolver. At any given time the pool may contain:
@@ -104,6 +146,8 @@ function CueBallConnectionPool(options) {
 	this.p_inRebalance = false;
 	this.p_rebalScheduled = false;
 	this.p_startedResolver = false;
+	this.p_lpf = new LowPassFilter();
+	this.p_lpTimer = undefined;
 
 	this.p_idleq = new Queue();
 	this.p_initq = new Queue();
@@ -145,6 +189,22 @@ function CueBallConnectionPool(options) {
 	}, 60000);
 	this.p_shuffleTimerInst.unref();
 
+	this.p_lastRebalClamped = false;
+
+	this.p_lpTimer = setInterval(function () {
+		var conns = 0;
+		Object.keys(self.p_connections).forEach(function (k) {
+			conns += self.p_connections[k].length;
+		});
+		var spares = self.p_idleq.length + self.p_initq.length;
+		var busy = conns - spares;
+		self.p_lpf.put(busy + self.p_spares);
+
+		if (self.p_lastRebalClamped)
+			self.rebalance();
+	}, LP_INT);
+	this.p_lpTimer.unref();
+
 	FSM.call(this, 'starting');
 }
 mod_util.inherits(CueBallConnectionPool, FSM);
@@ -344,6 +404,7 @@ CueBallConnectionPool.prototype.state_stopped = function (S) {
 	this.p_backends = {};
 	clearInterval(this.p_rebalTimerInst);
 	clearInterval(this.p_shuffleTimerInst);
+	clearInterval(this.p_lpTimer);
 };
 
 CueBallConnectionPool.prototype.shouldRetryBackend = function (backend) {
@@ -420,6 +481,15 @@ CueBallConnectionPool.prototype._rebalance = function () {
 		extras = 0;
 
 	var target = busy + extras + this.p_spares;
+
+	var min = Math.ceil(this.p_lpf.get());
+	if (target < min * 1.05) {
+		target = min;
+		this.p_lastRebalClamped = true;
+	} else {
+		this.p_lastRebalClamped = false;
+	}
+
 	if (target > this.p_max)
 		target = this.p_max;
 
@@ -545,6 +615,8 @@ CueBallConnectionPool.prototype.addConnection = function (key) {
 			var node = self.p_idleq.push(fsm);
 			fsm.p_idleq_node = node;
 
+			self.rebalance();
+
 			return;
 		}
 
@@ -599,6 +671,8 @@ CueBallConnectionPool.prototype.claim = function (options, cb) {
 	mod_assert.optionalBool(options.errorOnEmpty, 'options.errorOnEmpty');
 	var errOnEmpty = options.errorOnEmpty;
 
+	this._incrCounter('claim');
+
 	if (this.isInState('stopping') || this.isInState('stopped')) {
 		setImmediate(function () {
 			if (!done)
diff --git a/package.json b/package.json
index ddd4283..dde05e3 100644
--- a/package.json
+++ b/package.json
@@ -1,6 +1,6 @@
 {
   "name": "cueball",
-  "version": "1.1.5",
+  "version": "1.1.6",
   "description": "",
   "main": "lib/index.js",
   "dependencies": {
