From 36667832d64f9b30e0b53da63d2cdcf4d55f317c Mon Sep 17 00:00:00 2001
From: Josh Wilsdon <josh@wilsdon.ca>
Date: Fri, 2 Nov 2018 12:51:06 -0700
Subject: [PATCH] TRITON-928 node-artedi histograms should be compatible with
 Prometheus

---
 CHANGES.md                    |  10 ++
 README.md                     |  35 ++++---
 docs/API.md                   |  75 +++++++++++++--
 docs/DESIGN.md                | 105 --------------------
 docs/migrating.md             | 171 +++++++++++++++++++++++++++++++++
 docs/private_api.md           |   2 -
 examples/artedi_v1_buckets.js | 103 ++++++++++++++++++++
 lib/buckets.js                | 127 +++++++++++++++++++++++++
 lib/collector.js              |  17 +++-
 lib/histogram.js              | 174 ++++++++--------------------------
 package.json                  |   2 +-
 test/basic.test.js            | 130 +++++++++++++++++--------
 test/buckets.test.js          | 169 +++++++++++++++++++++++++++++++++
 13 files changed, 817 insertions(+), 303 deletions(-)
 create mode 100644 docs/migrating.md
 create mode 100644 examples/artedi_v1_buckets.js
 create mode 100644 lib/buckets.js
 create mode 100644 test/buckets.test.js

diff --git a/CHANGES.md b/CHANGES.md
index c4cd2aa..5260a70 100644
--- a/CHANGES.md
+++ b/CHANGES.md
@@ -3,6 +3,16 @@
 ## Not yet released
 None
 
+## 2.0.0 [backward incompatible if you use histograms]
+* #17 Histogram buckets completely changed to be compatible with Prometheus. You
+  can now either pass in an array of bucket values. If you do not pass in bucket
+  values, you will get the default buckets:
+```
+[0.005, 0.01, 0.025, 0.05, 0.1, 0.25, 0.5, 1, 2.5, 5, 10]
+```
+* Important: see [docs/migrating.md](docs/migrating.md) for details on migrating
+  from node-artedi v1.x to v2.x.
+
 ## 1.4.1
 * #15 improve the performance of hashObj()
 
diff --git a/README.md b/README.md
index beafbbd..02f963f 100644
--- a/README.md
+++ b/README.md
@@ -39,12 +39,13 @@ collector.collect(artedi.FMT_PROM, function (err, metrics) {
 });
 
 var histogram = collector.histogram({
-    name: 'http_request_latency_ms',
-    help: 'latency of muskie http requests'
+    name: 'http_request_latency_seconds',
+    help: 'latency of muskie http requests',
+    buckets: [0.005, 0.01, 0.025, 0.05, 0.1, 0.25, 0.5, 1, 2.5, 5, 10]
 });
 
 // Observe a latency of 998ms for a 'putobjectdir' request.
-histogram.observe(998, {
+histogram.observe(0.998, {
     method: 'putobjectdir'
 });
 
@@ -59,17 +60,23 @@ collector.collect(artedi.FMT_PROM, function (err, metrics) {
     // Prints:
     // # HELP http_requests_completed count of muskie http requests completed
     // # TYPE http_requests_completed counter
-    // http_requests_completed{zone="e5d3",method="getobject",code="200"} 1
-    // # HELP http_request_latency_ms latency of muskie http requests
-    // # TYPE http_request_latency_ms histogram
-    // http_request_latency_ms{zone="e5d3",method="getobject",code="200",le="729"} 0
-    // http_request_latency_ms{zone="e5d3",method="getobject",code="200",le="2187"} 1
-    // http_request_latency_ms{zone="e5d3",method="getobject",code="200",le="3645"} 1
-    // http_request_latency_ms{zone="e5d3",method="getobject",code="200",le="5103"} 1
-    // http_request_latency_ms{zone="e5d3",method="getobject",code="200",le="6561"} 1
-    // http_request_latency_ms{zone="e5d3",method="getobject",code="200",le="+Inf"} 1
-    // http_request_latency_ms_count{zone="e5d3",method="getobject",code="200"} 1
-    // http_request_latency_ms_sum{zone="e5d3",method="getobject",code="200"} 998
+    // http_requests_completed{method="getobject",code="200",zone="e5d3"} 1
+    // # HELP http_request_latency_seconds latency of muskie http requests
+    // # TYPE http_request_latency_seconds histogram
+    // http_request_latency_seconds{method="putobjectdir",le="0.005"} 0
+    // http_request_latency_seconds{method="putobjectdir",le="0.01"} 0
+    // http_request_latency_seconds{method="putobjectdir",le="0.025"} 0
+    // http_request_latency_seconds{method="putobjectdir",le="0.05"} 0
+    // http_request_latency_seconds{method="putobjectdir",le="0.01"} 0
+    // http_request_latency_seconds{method="putobjectdir",le="0.25"} 0
+    // http_request_latency_seconds{method="putobjectdir",le="0.5"} 0
+    // http_request_latency_seconds{method="putobjectdir",le="1"} 1
+    // http_request_latency_seconds{method="putobjectdir",le="2.5"} 1
+    // http_request_latency_seconds{method="putobjectdir",le="5"} 1
+    // http_request_latency_seconds{method="putobjectdir",le="10"} 1
+    // http_request_latency_seconds{le="+Inf",method="putobjectdir"} 1
+    // http_request_latency_seconds_count{method="putobjectdir"} 1
+    // http_request_latency_seconds_sum{method="putobjectdir"} 0.998
 });
 ```
 
diff --git a/docs/API.md b/docs/API.md
index a714ebb..d1cbf2c 100644
--- a/docs/API.md
+++ b/docs/API.md
@@ -83,21 +83,29 @@ var gauge = collector.gauge({
 });
 ```
 ### collector.histogram(opts) : Histogram
-Creates a new Histogram object with the given options (incl. labels). This call
-is idempotent. `opts` must include 'help' and 'name' fields, and may optionally
-include a 'labels' object.
+Creates a new Histogram object with the given options (incl. labels and
+buckets). This call is idempotent. `opts` must include 'help' and 'name' fields,
+and may optionally include a 'labels' object and/or a buckets array.
 
 Example:
 ```javascript
 var histogram = collector.histogram({
-    name: 'http_request_latency_ms',
+    name: 'http_request_latency_seconds',
     help: 'latency of http requests',
     labels: {
         component: 'muskie'
-    }
+    },
+    buckets: [0.005, 0.01, 0.025, 0.05, 0.1, 0.25, 0.5, 1, 2.5, 5, 10]
 });
 ```
 
+Note: If `buckets` are not specified, the default buckets will be:
+
+```
+[0.005, 0.01, 0.025, 0.05, 0.1, 0.25, 0.5, 1, 2.5, 5, 10]
+```
+
+
 ### collector.addTriggerFunction(func(Collector, callback))
 Adds `func` to a list of triggers to call immediately before metrics are
 collected during a call to `collector.collect()`.
@@ -155,6 +163,13 @@ Example:
 var my_counter = collector.getCollector('http_requests_completed');
 ```
 
+### collector.FIXED_BUCKETS
+
+This is a boolean which is always `true` for node-artedi v2 and will be
+`undefined` for previous versions. This allows libraries that are passed a
+collector object to support both node-artedi v1 dynamic buckets and node-artedi
+v2 fixed buckets (see node-artedi#17 for more details).
+
 ## Counter
 Counters are the most simple of the collector types. They simply count
 up starting from zero. You can either increment a counter, or add
@@ -191,6 +206,7 @@ Example:
 counter.getValue( { operation: 'click' } );
 ```
 
+
 ## Gauge
 Gauges are similar to counters. Gauges can count up, or count down relative
 to their current value, or be set to an arbitrary value. Gauges start with an
@@ -233,11 +249,6 @@ count values that fall between a number of buckets.
 ### histogram.observe(value, labels)
 Increment buckets with a value >= `value`.
 
-Note that it isn't necessary to specify which
-buckets to use. Log/linear buckets are automatically generated. More details
-about log/linear buckets can be found at the
-[DTrace blog](http://dtrace.org/blogs/bmc/2011/02/08/llquantize/).
-
 Example:
 ```javascript
 histogram.observe(1111, {
@@ -245,3 +256,47 @@ histogram.observe(1111, {
     code: 204
 });
 ```
+
+### Bucket Generators
+Artedi includes several generator functions that help create `buckets` arrays
+for use with histograms.
+
+#### artedi.linearBuckets(min, width, count)
+Generate `count` buckets starting with `min` with each bucket being `width`
+larger than the previous.
+
+Example:
+```javascript
+artedi.linearBuckets(0.5, 0.5, 10);
+// returns [ 0.5, 1, 1.5, 2, 2.5, 3, 3.5, 4, 4.5, 5 ]
+```
+
+Note: The min parameter must be > 0. It will likely be common to use the same
+value for `width` and `min` as in the example above.
+
+#### artedi.exponentialBuckets(min, factor, count)
+Generate `count` buckets starting with `min` with each bucket being `factor`
+times larger than the previous.
+
+Example:
+```javascript
+artedi.exponentialBuckets(1, 2, 5);
+// returns [ 1, 2, 4, 8, 16 ]
+```
+
+#### artedi.logLinearBuckets(base, lowPower, highPower, bucketsPerMagnitude)
+Generate a set of log-linear buckets. This will create `bucketsPerMagnitude`
+buckets for the magnitude that contains base^lowPower, and each magnitude
+up to and including the magnitude that starts with highPower.
+
+Example:
+
+```javascript
+artedi.logLinearBuckets(10, -2, 1, 5);
+// returns [ 0.02, 0.04, 0.06, 0.08, 0.1, 0.2, 0.4, 0.6, 0.8, 1, 2, 4, 6, 8, 10, 20, 40, 60, 80, 100 ]
+```
+
+Note in the above example, the lowPower was -2 so we started with 10^-2 = 0.01
+and used that magnitude (10^-2 to 10^-1) as the first set of 5 buckets. Then we
+created buckets for the magnitudes 10^-1 to 10^0, 10^0 to 10^1 and finally 10^1
+(our highPower parameter) to 10^2.
diff --git a/docs/DESIGN.md b/docs/DESIGN.md
index b7281f3..8abedac 100644
--- a/docs/DESIGN.md
+++ b/docs/DESIGN.md
@@ -75,111 +75,6 @@ The reported metric from that operation will look something like this:
 marlin_agent_jobs_running{zone="e5d03bc",key="value",owner="kkantor"} 1
 ```
 
-### Log/Linear Buckets
-One of the major problems with creating histograms in existing metric clients
-is that they require the user to provide a static list of bucket values for
-values to fall into. There are some problems with this, and to understand them
-we first need to understand what role buckets serve.
-
-Buckets are upper bounds on the value being tracked. For example, if a histogram
-is tracking request latency, you may have the following buckets: [100, 200, 300,
-400, 500, Inf] where each number represents time to completion in milliseconds.
-Inf is a special bucket that counts ALL values, including those that are greater
-than the largest bucket. So the value of Inf is >= sum(all bucket counts). Each
-bucket counts values that are less than or equal to the bucket. So for a request
-that took 222ms, the 300, 400, 500, and Inf buckets will be incremented.
-
-This sounds good if we know that we'll have a normal distribution of inputs and
-we know the approximate values that we should be receiving. This makes a lot of
-sense for simple use cases, like a webserver that serves text files. The latency
-of something simple like that should be relatively consistent. The usefulness of
-static buckets degrades quickly when workloads become much more varied.
-
-In Muskie, for example, we have some operations that finish quickly
-(`putdirectory`), and some that can take a long time (`putobject`). The latency
-of `putdirectory` will be relatively stable and low when compared to
-`putobject`. The latency of `putobject` can vary widely based on how large the
-object being uploaded is. We would like fine granularity when monitoring the
-latency of `putdirectory`, and a coarse granularity when monitoring `putobject`.
-
-With current metric clients, we have to either know the
-expected behavior of our application, or sacrifice either fine or coarse
-granularity in order to get accurate measurements from histograms.
-
-Luckily, this problem has been solved in-house already! DTrace has support
-for log/linear quantization. In short, it gives us the ability to represent
-both fine and coarse granularity in the same histogram. For more information on
-log/linear quantization, see
-[this DTrace blog post](http://dtrace.org/blogs/bmc/2011/02/08/llquantize/).
-
-Rather than requiring the user to provide a static list of buckets, log/linear
-buckets can be automatically generated. They are still static buckets in that
-the value of the bucket itself doesn't change. They are, however, dynamic in that
-the number of buckets can expand out as needed by the client's observations.
-
-Let's take an example. If my application observes a latency of 6ms, this is what
-a set of log/linear buckets would produce:
-```
-# HELP muskie_request_latency_ms latency of requests completed
-# TYPE muskie_request_latency_ms histogram
-http_request_latency_ms{le="1"} 0
-http_request_latency_ms{le="3"} 0
-http_request_latency_ms{le="5"} 0
-http_request_latency_ms{le="7"} 1
-http_request_latency_ms{le="9"} 1
-http_request_latency_ms{le="+Inf"} 1
-http_request_latency_ms_count{} 1
-http_request_latency_ms_sum{} 6
-```
-
-Now if my application observes a latency of 600ms, this is what we receive:
-```
-# HELP http_request_latency_ms latency of requests completed
-# TYPE http_request_latency_ms histogram
-http_request_latency_ms{le="1"} 0
-http_request_latency_ms{le="3"} 0
-http_request_latency_ms{le="5"} 0
-http_request_latency_ms{le="7"} 1
-http_request_latency_ms{le="9"} 1
-http_request_latency_ms{le="81"} 1
-http_request_latency_ms{le="243"} 1
-http_request_latency_ms{le="405"} 1
-http_request_latency_ms{le="567"} 1
-http_request_latency_ms{le="729"} 2
-http_request_latency_ms{le="+Inf"} 2
-http_request_latency_ms_count{} 2
-http_request_latency_ms_sum{} 606
-```
-
-And then maybe we observe a latency of 60000ms!
-```
-# HELP http_request_latency_ms latency of requests completed
-# TYPE http_request_latency_ms histogram
-http_request_latency_ms{le="1"} 0
-http_request_latency_ms{le="3"} 0
-http_request_latency_ms{le="5"} 0
-http_request_latency_ms{le="7"} 1
-http_request_latency_ms{le="9"} 1
-http_request_latency_ms{le="81"} 1
-http_request_latency_ms{le="243"} 1
-http_request_latency_ms{le="405"} 1
-http_request_latency_ms{le="567"} 1
-http_request_latency_ms{le="729"} 2
-http_request_latency_ms{le="59049"} 2
-http_request_latency_ms{le="177147"} 3
-http_request_latency_ms{le="295245"} 3
-http_request_latency_ms{le="413343"} 3
-http_request_latency_ms{le="531441"} 3
-http_request_latency_ms{le="+Inf"} 3
-http_request_latency_ms_count{} 3
-http_request_latency_ms_sum{} 60606
-```
-
-We can see that log/linear buckets give us a lot of flexibility while only
-removing a slight bit of precision.
-
-Prometheus is fine with this way of adding additional buckets between
-scrape periods as long as we don't modify the bucket values themselves.
 
 ### Dynamic Labelling
 We can see in the last example that the metric inherited two labels, and
diff --git a/docs/migrating.md b/docs/migrating.md
new file mode 100644
index 0000000..4fa4ac9
--- /dev/null
+++ b/docs/migrating.md
@@ -0,0 +1,171 @@
+# Migrating from node-artedi v1.x to v2.x
+
+## Overview
+
+[node-artedi](https://github.com/joyent/node-artedi) version 2.0.0 is backward
+incompatible with version 1.x if you use histograms. If you do not use any
+histograms in your existing code, updating to version 2 will require no changes
+to your code.
+
+If you do use histograms, this document intends to help make the update a bit
+easier by explaining what you need to do in order to update.
+
+## Very brief description of the problems
+
+I recommend reading [the detailed description of the histogram
+problems in node-artedi#17](node-artedi#17) to get a full understanding of the
+problems fixed in version 2.x. This section will only give high level details.
+
+The problems with version 1.x surround the way buckets were generated for
+histograms. This was done such that the buckets available depended on the data
+instead of being defined in the code. This means that different combinations of
+labels for the same histogram would end up with different buckets. When this
+happens, using the histogram with `histogram_quantile` will lead to incorrect
+results.
+
+It is possible to get lucky and for the results to look somewhat reasonable. But
+unless the buckets for all the different combinations of labels being included
+in the `histogram_quantile` query are exactly the same, there will always be
+some amount of inaccuracy introduced.
+
+## What does this mean for your code?
+
+With version 2, you must now specify your buckets when creating a histogram and
+these will be the same regardless of other labels. This means that if you have
+existing code that looks like:
+
+```
+collector.histogram({
+    name: 'http_request_duration_seconds',
+    help: 'total time to process requests'
+});
+```
+
+in version 1.x this would have generated different buckets depending on what the
+input data looked like. The buckets could have ranged anywhere from 0.0001 to
+3,271,550,796. With version 2, if you use that same code you will end up with
+exactly the buckets:
+
+```
+[0.005, 0.01, 0.025, 0.05, 0.1, 0.25, 0.5, 1, 2.5, 5, 10]
+```
+
+which are roughly log-linear, but omit a few buckets. These do however match the
+buckets used by the official prometheus client.
+
+As part of upgrading, you'll need to choose whether to switch to the new default
+buckets or, if not, which buckets you'd like to use. One way to get some useful
+data on this, is to look at your existing Prometheus data created by
+node-artedi version 1.x and run a query like:
+
+```
+sum(http_request_duration_seconds{service="cnapi"}) by (le)
+```
+
+for the service you're upgrading. In this case with my test setup my cnapi
+service was using buckets (reformatted and sorted):
+
+```
+[
+    0.0001, 0.0002, 0.0003, 0.0004, 0.0005, 0.0006, 0.0007, 0.0008, 0.0009,
+    0.001, 0.002, 0.003, 0.004, 0.005, 0.006, 0.007, 0.008, 0.009,
+    0.01, 0.02, 0.03, 0.04, 0.05, 0.06, 0.07, 0.08, 0.09,
+    0.18, 0.27, 0.36, 0.45, 0.54, 0.63, 0.72, 0.81,
+    1.62, 2.43, 3.24, 4.05, 4.86, 5.67, 6.48, 7.29, 8.1,
+    684, 2052, 3420, 4788, 6156,
+    +Inf
+]
+```
+
+the `+Inf` bucket is automatically added and should not be included in the
+buckets array passed to `collector.histogram`. So in this case if I wanted, I
+could change the histogram creation call to:
+
+```
+collector.histogram({
+    name: 'http_request_duration_seconds',
+    help: 'total time to process requests',
+    buckets: [
+        0.0001, 0.0002, 0.0003, 0.0004, 0.0005, 0.0006, 0.0007, 0.0008, 0.0009,
+        0.001, 0.002, 0.003, 0.004, 0.005, 0.006, 0.007, 0.008, 0.009,
+        0.01, 0.02, 0.03, 0.04, 0.05, 0.06, 0.07, 0.08, 0.09,
+        0.18, 0.27, 0.36, 0.45, 0.54, 0.63, 0.72, 0.81,
+        1.62, 2.43, 3.24, 4.05, 4.86, 5.67, 6.48, 7.29, 8.1,
+        684, 2052, 3420, 4788, 6156
+    ]
+});
+```
+
+and have the same buckets as before just now we'd be properly passing them in
+and `histogram_quantile` will work correctly as long as we don't use that on old
+data since that would remain broken.
+
+I could also notice that the counts for some of these buckets are exactly the
+same. For example in my case the buckets:
+
+0.0001, 0.0002, 0.0003, 0.0004, 0.0005, 0.0006, 0.0007, 0.0008, 0.0009
+
+all had exactly the same sum value. This indicates that while we had some
+requests that took less than 0.0001 seconds, we had none that took between
+0.0001 and 0.0009 seconds. So I probably don't need to include all these
+buckets.
+
+Instead what I might decide is that I'd prefer to use log-linear buckets with
+a smaller number of linear buckets per magnitude. For example, I might decide to
+do:
+
+```
+collector.histogram({
+    name: 'http_request_duration_seconds',
+    help: 'total time to process requests',
+    buckets: artedi.logLinearBuckets(10, -4, 3, 4)
+});
+```
+
+after playing around with the node repl and finding that this gives me buckets
+like:
+
+```
+> artedi.logLinearBuckets(10, -4, 3, 4)
+[ 0.0003, 0.0005, 0.0008, 0.001, 0.0025, 0.005, 0.0075, 0.01, 0.025, 0.05, 0.075, 0.1, 0.25, 0.5, 0.75, 1, 2.5, 5, 7.5, 10, 25, 50, 75, 100, 250, 500, 750, 1000, 2500, 5000, 7500, 10000 ]
+>
+```
+
+which covers the same range of datapoints with fewer total buckets (32 vs 49)
+while also being spread much more evenly across each magnitude.
+
+There are 3 of these helper functions in order to [help you generate an array of
+bucket values](docs/API.md#bucket-generators).
+
+## What about my existing data?
+
+The unfortunate consequence of the problem here with node-artedi version 1.x is
+that any existing histogram data is likely to be some degree of nonsense. If
+you're not *really* attached to all your old data, the easiest thing to do would
+be:
+
+ 1. Update all your code to node-artedi version 2.x and fixed buckets
+ 2. Wipe out all your existing Prometheus data and start from scratch
+
+This will ensure that for all your histogram metrics, only good values exist and
+you should be safe to run `histogram_quantile` across any range of your new
+data.
+
+If you need to keep your existing data for some reason, or if you need a more
+gradual transition, what you can do instead is:
+
+ 1. Update your code to use node-artedi version 2.x
+ 2. Add *2* versions of each of your histogram metrics. E.g.
+    `http_request_duration_seconds` and `http_request_duration_seconds_v2`
+    and have your code update both. The first should use a set of buckets that
+    includes all the buckets you've used in your existing data. The second can
+    include the buckets you'd *like* to be using.
+ 3. Update your dashboards and application instances until everything is using
+    the _v2 version of your histograms.
+ 4. Remove the code that updates the old v1 histograms.
+
+In order to help with this, there's some code in
+[examples/artedi_v1_buckets.js](examples/artedi_v1_buckets.js) which you could
+use in your application to generate buckets that match those your application
+might have used with node-artedi version 1.x. You could also just hardcode the
+array of values you need in your application.
diff --git a/docs/private_api.md b/docs/private_api.md
index 4391ae9..1b53f13 100644
--- a/docs/private_api.md
+++ b/docs/private_api.md
@@ -189,5 +189,3 @@ metrics are collected. See collector.processTriggers() for more information.
 |prometheus|callback|iterates through the Counters, calling `prometheus()` on their `MetricVector` object. The results are stitched together and added to the result of calling `prometheus()` on the Gauge's MetricVector|None (string and error via callback)|
 
 `Histogram()` is called by the parent object's `histogram()` function.
-Buckets will be created using the log/linear method, similar to how it's done in
-[DTrace](http://dtrace.org/blogs/bmc/2011/02/08/llquantize/).
diff --git a/examples/artedi_v1_buckets.js b/examples/artedi_v1_buckets.js
new file mode 100644
index 0000000..bba31a5
--- /dev/null
+++ b/examples/artedi_v1_buckets.js
@@ -0,0 +1,103 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ *
+ * Copyright (c) 2018, Joyent, Inc.
+ */
+
+/*
+ * IMPORTANT:
+ *
+ * This file exists to provide an example of how to create buckets that are
+ * compatible with node-artedi version 1.x only for purposes of updating to
+ * node-artedi version 2.x (see docs/migrating.md).
+ *
+ * It is not recommended to use these buckets for new code.
+ *
+ */
+
+var assert = require('assert-plus');
+
+
+// These are all the different bucket values node-artedi 1.x could generate
+// which it called "log-linear" though these values are not compatible with
+// other log-linear quantizations such as llquantize in DTrace.
+var POSSIBLE_ARTEDI_1_BUCKETS = [
+    0.0001, 0.0002, 0.0003, 0.0004, 0.0005, 0.0006, 0.0007, 0.0008, 0.0009,
+    0.001, 0.002, 0.003, 0.004, 0.005, 0.006, 0.007, 0.008, 0.009,
+    0.01, 0.02, 0.03, 0.04, 0.05, 0.06, 0.07, 0.08, 0.09,
+    0.18, 0.27, 0.36, 0.45, 0.54, 0.63, 0.72, 0.81,
+    1.62, 2.43, 3.24, 4.05, 4.86, 5.67, 6.48, 7.29, 8.1,
+    25, 42, 59, 76,
+    228, 380, 532, 684,
+    2052, 3420, 4788, 6156,
+    18468, 30780, 43092, 55404,
+    166212, 277020, 387828, 498636,
+    1495908, 2493180, 3490452, 4487724,
+    13463172, 22438620, 31414068, 40389516,
+    121168548, 201947580, 282726612, 363505644,
+    1090516932, 1817528220, 2544539508, 3271550796 ];
+
+var POSSIBLE_ARTEDI_1_BUCKETS_MIN_MIN = POSSIBLE_ARTEDI_1_BUCKETS[0];
+var POSSIBLE_ARTEDI_1_BUCKETS_MAX_MIN =
+    POSSIBLE_ARTEDI_1_BUCKETS[POSSIBLE_ARTEDI_1_BUCKETS.length - 2];
+var POSSIBLE_ARTEDI_1_BUCKETS_MAX_MAX =
+    POSSIBLE_ARTEDI_1_BUCKETS[POSSIBLE_ARTEDI_1_BUCKETS.length - 1];
+
+
+function artedi1Buckets(min, max) {
+    if (max === undefined) {
+        max = POSSIBLE_ARTEDI_1_BUCKETS_MAX_MAX;
+    }
+    if (min === undefined) {
+        min = POSSIBLE_ARTEDI_1_BUCKETS_MIN_MIN;
+    }
+
+    assert.number(min, 'min', 'min is required');
+    assert.number(max, 'max', 'max is required');
+    assert.ok(min < max, 'min must be < max');
+    assert.ok(min <= POSSIBLE_ARTEDI_1_BUCKETS_MAX_MIN, 'min must be <= ' +
+        POSSIBLE_ARTEDI_1_BUCKETS_MAX_MIN);
+    assert.ok(max <= POSSIBLE_ARTEDI_1_BUCKETS_MAX_MAX, 'max must be <= ' +
+        POSSIBLE_ARTEDI_1_BUCKETS_MAX_MAX);
+
+    var begin;
+    var buckets = [];
+    var i;
+    var end;
+
+    // Shortcut in case they want everything
+    if (min === POSSIBLE_ARTEDI_1_BUCKETS_MIN_MIN &&
+        max === POSSIBLE_ARTEDI_1_BUCKETS_MAX_MAX) {
+
+        return (POSSIBLE_ARTEDI_1_BUCKETS.slice());
+    }
+
+    // find the lowest bucket that's >= min
+    i = 0;
+    while (POSSIBLE_ARTEDI_1_BUCKETS[i] < min) {
+        i++;
+    }
+    begin = i;
+
+    // find the highest bucket that's >= max
+    if (max === POSSIBLE_ARTEDI_1_BUCKETS_MAX_MAX) {
+        end = POSSIBLE_ARTEDI_1_BUCKETS.length - 1;
+    } else {
+        // work backward from the end
+        i = POSSIBLE_ARTEDI_1_BUCKETS.length - 1;
+        while (POSSIBLE_ARTEDI_1_BUCKETS[i] > max) {
+            i--;
+        }
+        end = i + 1;
+    }
+
+    return (POSSIBLE_ARTEDI_1_BUCKETS.slice(begin, end + 1));
+}
+
+
+module.exports = {
+    artedi1Buckets: artedi1Buckets,
+    POSSIBLE_ARTEDI_1_BUCKETS: POSSIBLE_ARTEDI_1_BUCKETS
+};
diff --git a/lib/buckets.js b/lib/buckets.js
new file mode 100644
index 0000000..2028158
--- /dev/null
+++ b/lib/buckets.js
@@ -0,0 +1,127 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ *
+ * Copyright (c) 2018, Joyent, Inc.
+ */
+
+var assert = require('assert-plus');
+
+
+function fixDecimals(value) {
+    var fixed;
+    var decimals;
+
+    // If the number is < 10, figure out the magnitude of the value and then
+    // use that to determine the appropriate number of decimal digits.
+    if (value < 10) {
+        decimals = Math.max(Math.abs(Math.floor(Math.log10(value))) + 1, 4);
+        fixed = +(value.toFixed(decimals));
+    } else {
+        fixed = Math.ceil(value);
+    }
+
+    return (fixed);
+}
+
+
+function linearBuckets(min, width, count) {
+    var buckets = [];
+    var i;
+    var n = min;
+
+    assert.number(min, 'min', 'min is required');
+    assert.number(width, 'width', 'width is required');
+    assert.number(count, 'count', 'count is required');
+    assert.ok(width > 0, 'width must be > 0');
+    assert.ok(count > 0, 'count must be > 0');
+    assert.ok(min > 0, 'min must be > 0, you probably want min=' + width);
+
+    for (i = 0; i < count; i++) {
+        buckets.push(fixDecimals(n));
+        n += width;
+    }
+
+    return (buckets);
+}
+
+
+function exponentialBuckets(min, factor, count) {
+    var buckets = [];
+    var i;
+    var n = min;
+
+    assert.number(min, 'min', 'min is required');
+    assert.number(factor, 'factor', 'factor is required');
+    assert.number(count, 'count', 'count is required');
+    assert.ok(min > 0, 'min must be > 0');
+
+    for (i = 0; i < count; i++) {
+        buckets.push(fixDecimals(n));
+        n *= factor;
+    }
+
+    return (buckets);
+}
+
+
+/*
+ * This function generates an array of log-linear buckets.
+ *
+ * For each magnitude from lowPower to highPower, we will create linear steps of
+ * width (base^magnitude) / bucketsPerMagnitude and add these values to the
+ * resulting array if they do not already fall into a smaller magnitude's
+ * buckets (since we will already have those datapoints at higher resolution)..
+ *
+ */
+function logLinearBuckets(base, lowPower, highPower, bucketsPerMagnitude) {
+    var bucketIdx;
+    var buckets = [];
+    var curMagnitudeLastBucket;
+    var exponent;
+    var prevMagnitudeLastBucket = 0;
+    var step;
+    var value;
+
+    assert.number(base, 'base');
+    assert.number(lowPower, 'lowPower');
+    assert.number(highPower, 'highPower');
+    assert.number(bucketsPerMagnitude, 'bucketsPerMagnitude');
+    assert.ok(lowPower < highPower, 'lowPower must be < highPower');
+    assert.ok(base > 0, 'base must be positive');
+    assert.ok(bucketsPerMagnitude > 0, 'bucketsPerMagnitude must be positive');
+
+    for (exponent = lowPower; exponent <= highPower; exponent++) {
+        // This will be the largest bucket in the magnitude
+        curMagnitudeLastBucket = Math.pow(base, exponent + 1);
+
+        // Figure out the size of each step in this magnitude.
+        step = curMagnitudeLastBucket / bucketsPerMagnitude;
+
+        for (bucketIdx = 1; bucketIdx < bucketsPerMagnitude; bucketIdx++) {
+            value = fixDecimals(bucketIdx * step);
+
+            // Skip values that are handled in finer detail by the previous
+            // magnitude's buckets.
+            if (value > prevMagnitudeLastBucket) {
+                buckets.push(value);
+            }
+        }
+
+        // Push the last one without multiplying by step, so that it ends
+        // exactly without worrying Javascript numbers.
+        buckets.push(fixDecimals(curMagnitudeLastBucket));
+
+        prevMagnitudeLastBucket = buckets[buckets.length - 1];
+    }
+
+    return (buckets);
+}
+
+
+module.exports = {
+    exponentialBuckets: exponentialBuckets,
+    linearBuckets: linearBuckets,
+    logLinearBuckets: logLinearBuckets
+};
diff --git a/lib/collector.js b/lib/collector.js
index 1ebff81..89c7c6d 100644
--- a/lib/collector.js
+++ b/lib/collector.js
@@ -3,7 +3,7 @@
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/.
  *
- * Copyright (c) 2017, Joyent, Inc.
+ * Copyright (c) 2018, Joyent, Inc.
  */
 
 var mod_assert = require('assert-plus');
@@ -14,6 +14,7 @@ var VError = require('verror').VError;
 var MultiError = require('verror').MultiError;
 
 var lib_utils = require('./utils');
+var lib_buckets = require('./buckets');
 var lib_counter = require('./counter');
 var lib_gauge = require('./gauge');
 var lib_histogram = require('./histogram');
@@ -74,6 +75,15 @@ function Collector(options) {
         this.staticLabels = null;
     }
 
+    /*
+     * Indicates this version uses fixed buckets per node-artedi#17 instead of
+     * the previous versions that supported dynamic buckets. We add this to the
+     * collector so that things like node-fast can support both node-artedi v1
+     * and node-artedi v2 by checking whether this is true on an otherwise
+     * unknown `collector` object.
+     */
+    this.FIXED_BUCKETS = true;
+
     this.registry = {};
     this.triggerRegistry = [];
 }
@@ -347,6 +357,9 @@ module.exports = {
     createCollector: function createCollector(options) {
         return (new Collector(options));
     },
+    exponentialBuckets: lib_buckets.exponentialBuckets,
     FMT_PROM: FMT_PROM,
-    FMT_PROM_0_0_4: FMT_PROM_0_0_4
+    FMT_PROM_0_0_4: FMT_PROM_0_0_4,
+    linearBuckets: lib_buckets.linearBuckets,
+    logLinearBuckets: lib_buckets.logLinearBuckets
 };
diff --git a/lib/histogram.js b/lib/histogram.js
index 988b709..2d2849b 100644
--- a/lib/histogram.js
+++ b/lib/histogram.js
@@ -17,6 +17,26 @@ var lib_gauge = require('./gauge');
 var lib_common = require('./common');
 var lib_provider = require('./provider');
 
+
+/*
+ * These default buckets match the official golang, javascript, rust and other
+ * client libraries.
+ */
+var DEFAULT_BUCKETS = [
+    0.005,
+    0.01,
+    0.025,
+    0.05,
+    0.1,
+    0.25,
+    0.5,
+    1,
+    2.5,
+    5,
+    10
+];
+
+
 /*
  * A Histogram is a type of collector that represents a series of Counters. Each
  * Counter corresponds to a certain range of values, called 'buckets.'
@@ -25,9 +45,13 @@ function Histogram(options) {
     mod_assert.object(options, 'options');
     mod_assert.string(options.name, 'options.name');
     mod_assert.string(options.help, 'options.help');
+    mod_assert.optionalArrayOfNumber(options.buckets, 'options.buckets');
     mod_assert.optionalObject(options.labels, 'options.labels');
     mod_assert.optionalObject(options.parentLabels, 'options.parentLabels');
 
+    var i;
+    var prevBucket = -1;
+
     this.staticLabels =
         mod_jsprim.mergeObjects(options.parentLabels, options.labels, null);
 
@@ -35,8 +59,17 @@ function Histogram(options) {
     this.help = options.help;
     this.type = lib_common.HISTOGRAM;
 
+    this.buckets = options.buckets || DEFAULT_BUCKETS;
     this.counters = {};
     this.gauge = new lib_gauge.Gauge(options);
+
+    // Assert that buckets are monotonic
+    for (i = 0; i < this.buckets.length; i++) {
+        mod_assert.ok(this.buckets[i] > prevBucket,
+            'buckets should be monotonic [' + this.buckets[i] +
+            ' > ' + prevBucket + ']');
+        prevBucket = this.buckets[i];
+    }
 }
 
 /* Public Functions */
@@ -58,17 +91,9 @@ Histogram.prototype.observe = function observe(value, pairs) {
         throw new VError('observe must be called with a value >= 0: %d', value);
     }
 
+    var i;
     var counter;
     var pairCopy;
-    var buckets;
-    var index, count, i, bucket;
-    var smaller;
-    var metric;
-
-    // For log-linear bucketing, we will produce five linear steps per log jump.
-    // At a point in the future, we may allow the user to provide this value,
-    // but five seems like a reasonable default.
-    var linearSteps = 5;
 
     pairs = mod_jsprim.mergeObjects(pairs, this.staticLabels, null);
     counter = this.labels(pairs);
@@ -76,73 +101,16 @@ Histogram.prototype.observe = function observe(value, pairs) {
     // Make a copy of the labels sent in.
     pairCopy = mod_jsprim.deepCopy(pairs);
 
-    /* Begin setting initial value for new buckets (if applicable). */
-
-    // Determine which bucket from the new order our value falls into.
-    buckets = getOrder(value, linearSteps);
-    if (!buckets) {
-        // The value passed in is too big (> 10 billion), so we just increment
-        // the +Inf counter, and add to the Gauge.
-        counter.increment({
-            le: '+Inf'
-        });
-        this.gauge.add(value, counter.staticLabels);
-        return;
-    }
-
-    // Find the largest bucket that the observed value falls into.
-    for (bucket in buckets) {
-        if (value <= buckets[bucket]) {
-            index = buckets[bucket];
-            break;
-        }
-    }
-
-    // Find the next-smallest bucket from the list of already-used buckets.
-    // The buckets are sorted when they are added to a metric vector.
-    for (bucket in counter.metricVec.buckets) {
-        if (counter.metricVec.buckets[bucket] < index) {
-            smaller = bucket;
-        }
-    }
-
-    // Check to see if the proper bucket for this value already exists in
-    // the bucket list.
-    if (counter.metricVec.buckets.indexOf(index) === -1) {
-        counter.metricVec.addBuckets(buckets);
-        if (smaller) {
-            // Copy value from the next-smallest bucket into the newly created
-            // buckets.
-            pairCopy['le'] = counter.metricVec.buckets[smaller];
-            count = counter.labels(pairCopy).value;
-            if (count > 0) {
-                for (bucket in buckets) {
-                    pairCopy['le'] = buckets[bucket];
-                    metric = counter.labels(pairCopy);
-                    if (metric.value === 0) {
-                        // We don't want to double the value of overlapping
-                        // buckets.
-                        counter.add(count, pairCopy);
-                    }
-                }
-            }
-        }
-    }
-    /* Done setting initial value for new buckets. */
-
-    // Now we need to increment the Counters for the buckets >= the value
-    // passed in.
-    buckets = counter.metricVec.buckets;
-    index = buckets.indexOf(index);
-    for (i = 0; i < buckets.length; i++) {
-        pairCopy['le'] = buckets[i];
-        if (i < index) {
-            // We don't need to increment buckets that are smaller than what we
-            // received, but we do want to zero them out if they don't exist.
+    // Increment the counters for each bucket(le) where "value" is <= the bucket
+    for (i = 0; i < this.buckets.length; i++) {
+        pairCopy['le'] = this.buckets[i];
+        if (value <= this.buckets[i]) {
+            counter.increment(pairCopy);
+        } else {
+            // We don't need to increment buckets that are smaller than value,
+            // but we do want to zero them out if they don't exist.
             counter.labels(pairCopy);
-            continue;
         }
-        counter.increment(pairCopy);
     }
 
     // Always increment the Inf Counter.
@@ -288,64 +256,6 @@ Histogram.prototype.defaultCounter = function defaultCounter() {
     return (this.counters['default']);
 };
 
-/*
- * Find (and return) a list of linear numbers that 'value' falls into.
- * The 'steps' argument is provided, as we may allow the user to specify
- * the number of linear 'steps' between logarithmic jumps. This idea is taken
- * from DTrace's log/linear quantization ('llquantize()').
- *
- * The 'steps' argument is ignored for retrieving the order of values less than
- * one.
- */
-function getOrder(value, steps) {
-    var i, j, bucketVal, width, next;
-    var buckets;
-
-    // These values are relatively arbitrary. It's possible that we may want to
-    // allow the user to change these at some point.
-    var factor = 10;
-    var low = 0;
-
-    // This is an arbitrary high watermark. Setting this allows us to ensure
-    // that our loop will always exit.
-    // The maximum value that we can observe (without it falling into only the
-    // +Inf bucket) is 3,486,784,401
-    var high = 13;
-
-    bucketVal = 0.0001; // smallest possible precision.
-    for (i = low; i <= high; i++) {
-        buckets = [];
-
-        next = bucketVal * factor;
-        if (bucketVal < 1) {
-            // Ignore the 'step' count for very small values.
-            width = bucketVal;
-        } else {
-            // Otherwise enforce that we don't have more than 'step' buckets.
-            width = next > steps ? next / steps : 1;
-        }
-
-        for (j = 0; bucketVal <= next; bucketVal += width, j++) {
-            if (bucketVal < 10) {
-                // only keep a few decimal places when decimal precision matters
-                bucketVal = +(bucketVal.toFixed(4));
-            } else {
-                bucketVal = Math.ceil(bucketVal);
-            }
-            buckets[j] = bucketVal;
-        }
-
-        // Overlap buckets so we get something like:
-        // [0-10], [10-100], [100-1000].
-        bucketVal -= width;
-        if (value <= buckets[buckets.length - 1]) {
-            // The number is within this order.
-            return (buckets);
-        }
-    }
-    return (null);
-}
-
 module.exports = {
     Histogram: Histogram
 };
diff --git a/package.json b/package.json
index 798fe58..67b1c09 100644
--- a/package.json
+++ b/package.json
@@ -1,6 +1,6 @@
 {
   "name": "artedi",
-  "version": "1.4.1",
+  "version": "2.0.0",
   "description": "a metric client library",
   "main": "lib/collector.js",
   "dependencies": {
diff --git a/test/basic.test.js b/test/basic.test.js
index 959d99f..dac58e5 100644
--- a/test/basic.test.js
+++ b/test/basic.test.js
@@ -337,7 +337,8 @@ mod_tape('histogram serialization tests', function (t) {
 
     var histogram = collector.histogram({
         name: 'bot_trolololol',
-        help: 'there is no help'
+        help: 'there is no help',
+        buckets: [0.81, 1.62, 2.43, 3.24, 4.05, 4.86, 5.67, 6.48, 7.29, 8.1]
     });
     var expected = '# HELP bot_trolololol there is no help\n';
     expected += '# TYPE bot_trolololol ' + common.HISTOGRAM + '\n';
@@ -388,7 +389,8 @@ mod_tape('histogram serialization tests', function (t) {
 
             histogram = collector.histogram({
                 name: 'http_request_latency',
-                help: 'latency of requests'
+                help: 'latency of requests',
+                buckets: [76, 228, 380, 532, 684]
             });
 
             histogram.observe(99);
@@ -426,7 +428,8 @@ mod_tape('histogram serialization tests', function (t) {
                 help: 'connection alive time',
                 labels: {
                     component: 'qball'
-                }
+                },
+                buckets: [76, 228, 380, 532, 684]
             });
 
             histogram.observe(101);
@@ -468,7 +471,8 @@ mod_tape('histogram serialization tests', function (t) {
                 help: 'connection alive time',
                 labels: {
                     component: 'cueball'
-                }
+                },
+                buckets: [76, 228, 380, 532, 684]
             });
 
             histogram.observe(101, {
@@ -504,13 +508,13 @@ mod_tape('histogram serialization tests', function (t) {
             collector = mod_artedi.createCollector();
             histogram = collector.histogram({
                 name: 'test_test1',
-                help: 'testhelp'
+                help: 'testhelp',
+                buckets: [8.1, 25, 42, 59, 76, 228, 380, 532, 684]
             });
 
             histogram.observe(10);
             histogram.observe(100);
-            // TODO We should have the +Inf label at the end. This works, but
-            // it would look nicer.
+
             expected = '' +
                 '# HELP test_test1 testhelp\n'
                 + '# TYPE test_test1 ' + common.HISTOGRAM + '\n'
@@ -519,11 +523,11 @@ mod_tape('histogram serialization tests', function (t) {
                 + 'test_test1{le="42"} 1\n'
                 + 'test_test1{le="59"} 1\n'
                 + 'test_test1{le="76"} 1\n'
-                + 'test_test1{le="+Inf"} 2\n'
                 + 'test_test1{le="228"} 2\n'
                 + 'test_test1{le="380"} 2\n'
                 + 'test_test1{le="532"} 2\n'
                 + 'test_test1{le="684"} 2\n'
+                + 'test_test1{le="+Inf"} 2\n'
                 + 'test_test1_count{} 2\n'
                 + 'test_test1_sum{} 110\n';
 
@@ -548,7 +552,8 @@ mod_tape('odd value tests', function (t) {
     });
     var hist = collector.histogram({
         name: 'histo',
-        help: 'histo help'
+        help: 'histo help',
+        buckets: [0.0001]
     });
 
     counter.add(0);
@@ -627,45 +632,96 @@ mod_tape('basic trigger tests', function (t) {
 });
 
 /*
- * Make sure log/linear buckets are working properly.
+ * Test that default buckets are what we expect
  */
-mod_tape('log/linear bucket tests', function (t) {
+mod_tape('default bucket tests', function (t) {
     var collector = mod_artedi.createCollector();
     var histo = collector.histogram({
         name: 'test_histogram',
         help: 'test help'
     });
-    var value;
-
-    /*
-     * Make sure we are copying values from lower to upper buckets properly.
-     * This is a result of MORAY-447, where we saw an overlapping bucket have
-     * its value doubled.
-     *
-     * To test the fix, we will:
-     *  - Create a set of small buckets.
-     *  - Create a set of large buckets.
-     *    - This should copy the values from the small buckets to large buckets.
-     *  - Record a value in the bucket below the smallest of the large buckets.
-     *    - Previously this would result in the lower values being re-copied to
-     *      the smallest of the large buckets (6561).
-     *    - Now it should correctly identify that the 6561 bucket already exists
-     *      meaning lower values should not be re-copied to the overlapping
-     *      bucket.
-     */
-    histo.observe(10); // Record three small values.
-    histo.observe(10);
-    histo.observe(10);
-    histo.observe(6157); // Record a value which will create larger buckets.
-    histo.observe(4788); // Record a value below the smallest larger bucket.
-
-    value = histo.defaultCounter().getValue({'le': 6156});
-    t.equals(value, 4, 'overlapping bucket values copied correctly');
 
+    t.deepEquals(histo.buckets,
+        [0.005, 0.01, 0.025, 0.05, 0.1, 0.25, 0.5, 1, 2.5, 5, 10],
+        'default buckets for histogram with no buckets opt');
+
+    t.end();
+});
+
+/*
+ * Test that non-monotonic buckets fail.
+ */
+mod_tape('non-monotonic buckets', function (t) {
+    var collector = mod_artedi.createCollector();
+
+    t.throws(function _badBuckets() {
+        collector.histogram({
+            name: 'test_histogram',
+            help: 'test help',
+            buckets: [ 1, 5, 10, 100, 50, 1000 ]
+        });
+    }, /buckets should be monotonic/,
+        'non-monotonic buckets should not be allowed');
 
     t.end();
 });
 
+/*
+ * Test that increment works properly.
+ */
+mod_tape('histogram buckets incremented', function (t) {
+    var collector = mod_artedi.createCollector();
+    var histo = collector.histogram({
+        name: 'test_histogram',
+        help: 'test help',
+        buckets: [ 1, 2, 3, 4, 5 ]
+    });
+
+    histo.observe(2);
+
+    // should have updated 2, 3, 4, 5, +Inf
+    collector.collect(mod_artedi.FMT_PROM, function (err2, str2) {
+        t.notOk(err2, 'no error for copying bucket values');
+        t.equals(str2, [
+            '# HELP test_histogram test help',
+            '# TYPE test_histogram histogram',
+            'test_histogram{le="1"} 0',
+            'test_histogram{le="2"} 1',
+            'test_histogram{le="3"} 1',
+            'test_histogram{le="4"} 1',
+            'test_histogram{le="5"} 1',
+            'test_histogram{le="+Inf"} 1',
+            'test_histogram_count{} 1',
+            'test_histogram_sum{} 2',
+            ''
+        ].join('\n'), 'observe(2) incremented all subsequent buckets');
+
+        histo.observe(0.5);
+
+        // should have updated 1, 2, 3, 4, 5, +Inf
+        collector.collect(mod_artedi.FMT_PROM, function (err, str) {
+            t.notOk(err, 'no error for copying bucket values');
+            t.equals(str, [
+                '# HELP test_histogram test help',
+                '# TYPE test_histogram histogram',
+                'test_histogram{le="1"} 1',
+                'test_histogram{le="2"} 2',
+                'test_histogram{le="3"} 2',
+                'test_histogram{le="4"} 2',
+                'test_histogram{le="5"} 2',
+                'test_histogram{le="+Inf"} 2',
+                'test_histogram_count{} 2',
+                'test_histogram_sum{} 2.5',
+                ''
+            ].join('\n'), 'observe(0.5) incremented all subsequent buckets');
+
+            t.end();
+        });
+    });
+
+});
+
+
 mod_tape('gauge expiry tests', function (t) {
     var collector = mod_artedi.createCollector();
     var expiryGauge1 = collector.gauge({
diff --git a/test/buckets.test.js b/test/buckets.test.js
new file mode 100644
index 0000000..98321d3
--- /dev/null
+++ b/test/buckets.test.js
@@ -0,0 +1,169 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ *
+ * Copyright (c) 2018, Joyent, Inc.
+ */
+
+var mod_tape = require('tape');
+
+var mod_artedi = require('..');
+
+function simpleTest(t, func, args, expected) {
+    t.deepEquals(mod_artedi[func].apply(null, args),
+        expected,
+        'test ' + func + '(' + args.join(', ') + ')');
+}
+
+
+mod_tape('linearBuckets', function (t) {
+
+    simpleTest(t, t.name,
+        [ 1, 1, 10 ],
+        [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ]);
+
+    t.throws(function _blowUp() {
+        simpleTest(t, t.name,
+            [ 0, 0.1, 10 ],
+            [ ]);
+    }, /min must be > 0/,
+        '0 should be invalid min for linearBuckets');
+
+    t.end();
+});
+
+
+mod_tape('exponentialBuckets', function (t) {
+
+    simpleTest(t, t.name,
+        [ 1, 2, 5 ],
+        [ 1, 2, 4, 8, 16 ]);
+
+    t.end();
+});
+
+
+mod_tape('logLinearBuckets', function (t) {
+
+    // Silence line length linting errors.
+    /* BEGIN JSSTYLED */
+    /* eslint-disable */
+
+    // These first tests were inspired by:
+    //
+    // https://github.com/illumos/illumos-gate/blob/7256a34efe9df75b638b9e812912ef7c5c68e208/usr/src/cmd/dtrace/test/tst/common/llquantize/tst.bases.d
+    //
+    // but the results here are what we expect, rather than what llquantize
+    // expects.
+
+    simpleTest(t, t.name,
+        [ 2, 0, 6, 2 ],
+        [ 1, 2,   // <= 2^1
+            4,    // <= 2^2
+            8,    // <= 2^3
+            16,   // <= 2^4
+            32,   // <= 2^5
+            64,   // <= 2^6
+            128   // <= 2^7 (contains the 2^6 magnitude)
+        ]);
+
+    simpleTest(t, t.name,
+        [ 3, 0, 1, 9 ],
+        [
+            0.3333, 0.6667, 1, 1.3333, 1.6667, 2, 2.3333, 2.6667, 3,  // <= 3^1
+            4, 5, 6, 7, 8, 9                                          // <= 3^2 (1, 2, 3 skipped)
+        ]);
+
+    simpleTest(t, t.name,
+        [ 4, 0, 1, 4 ],
+        [ 1, 2, 3, 4,  // <= 4^1
+            8, 12, 16  // <= 4^2
+        ]);
+
+    simpleTest(t, t.name,
+        [ 5, 0, 1, 25 ],
+        [
+            0.2, 0.4, 0.6, 0.8, 1, 1.2, 1.4, 1.6, 1.8, 2, 2.2, 2.4, 2.6, 2.8, 3, 3.2, 3.4, 3.6, 3.8, 4, 4.2, 4.4, 4.6, 4.8, 5,  // <= 5^1
+            6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25                                          // <= 5^2
+        ]);
+
+    simpleTest(t, t.name,
+        [ 6, 0, 3, 12 ],
+        [ 0.5, 1, 1.5, 2, 2.5, 3, 3.5, 4, 4.5, 5, 5.5, 6,        // <= 6^1
+            9, 12, 15, 18, 21, 24, 27, 30, 33, 36,               // <= 6^2
+            54, 72, 90, 108, 126, 144, 162, 180, 198, 216,       // <= 6^3
+            324, 432, 540, 648, 756, 864, 972, 1080, 1188, 1296  // <= 6^4
+        ]);
+
+    simpleTest(t, t.name,
+        [ 7, 0, 1, 7 ],
+        [ 1,                         // <= 7^0
+            2, 3, 4, 5, 6, 7,        // <= 7^1
+            14, 21, 28, 35, 42, 49   // <= 7^2
+        ]);
+
+    simpleTest(t, t.name,
+        [ 8, 0, 1, 16 ],
+        [ 0.5, 1, 1.5, 2, 2.5, 3, 3.5, 4, 4.5, 5, 5.5, 6, 6.5, 7, 7.5, 8,  // <= 8^1
+            12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56, 60, 64         // <= 8^2
+        ]);
+
+    simpleTest(t, t.name,
+        [ 9, 0, 1, 9 ],
+        [ 1, 2, 3, 4, 5, 6, 7, 8, 9,        // <= 9^1
+            18, 27, 36, 45, 54, 63, 72, 81  // <= 9^2
+        ]);
+
+    simpleTest(t, t.name,
+        [ 10, 0, 1, 10 ],
+        [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10,         // <= 10^1
+            20, 30, 40, 50, 60, 70, 80, 90, 100  // <= 10^2
+        ]);
+
+    // <end of DTrace copied tests>
+
+    simpleTest(t, t.name,
+        [ 10, -3, 1, 10 ],
+        [ 0.001, 0.002, 0.003, 0.004, 0.005, 0.006, 0.007, 0.008, 0.009, 0.01,  // <= 10^-2
+            0.02, 0.03, 0.04, 0.05, 0.06, 0.07, 0.08, 0.09, 0.1,                // <= 10^-1
+            0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1,                          // <= 10^0
+            2, 3, 4, 5, 6, 7, 8, 9, 10,                                         // <= 10^1
+            20, 30, 40, 50, 60, 70, 80, 90, 100                                 // <= 10^2
+        ]);
+
+    simpleTest(t, t.name,
+        [ 10, -3, 1, 20 ],
+        [ 0.0005, 0.001, 0.0015, 0.002, 0.0025, 0.003, 0.0035, 0.004, 0.0045, 0.005, 0.0055, 0.006, 0.0065, 0.007, 0.0075, 0.008, 0.0085, 0.009, 0.0095, 0.01,  // <= 10^-2
+            0.015, 0.02, 0.025, 0.03, 0.035, 0.04, 0.045, 0.05, 0.055, 0.06, 0.065, 0.07, 0.075, 0.08, 0.085, 0.09, 0.095, 0.1,                                 // <= 10^-1
+            0.15, 0.2, 0.25, 0.3, 0.35, 0.4, 0.45, 0.5, 0.55, 0.6, 0.65, 0.7, 0.75, 0.8, 0.85, 0.9, 0.95, 1,                                                    // <= 10^0
+            1.5, 2, 2.5, 3, 3.5, 4, 4.5, 5, 5.5, 6, 6.5, 7, 7.5, 8, 8.5, 9, 9.5, 10,                                                                            // <= 10^1
+            15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 85, 90, 95, 100                                                                             // <= 10^2
+        ]);
+
+    simpleTest(t, t.name,
+        [ 10, -3, 1, 4 ],
+        [   0.0025, 0.005, 0.0075, 0.01,  // <= 10^-2
+            0.025, 0.05, 0.075, 0.1,      // <= 10^-1
+            0.25, 0.5, 0.75, 1,           // <= 10^0
+            2.5, 5, 7.5, 10,              // <= 10^1
+            25, 50, 75, 100               // <= 10^2
+        ]);
+
+    simpleTest(t, t.name,
+        [ 10, 0, 1, 33 ],
+        [   // 0 - 10^1
+            0.303, 0.6061, 0.9091, 1.2121, 1.5152, 1.8182, 2.1212, 2.4242, 2.7273,
+            3.0303, 3.3333, 3.6364, 3.9394, 4.2424, 4.5455, 4.8485, 5.1515, 5.4545,
+            5.7576, 6.0606, 6.3636, 6.6667, 6.9697, 7.2727, 7.5758, 7.8788,
+            8.1818, 8.4848, 8.7879, 9.0909, 9.3939, 9.697, 10,
+            // 10^1 - 10^2
+            13, 16, 19, 22, 25, 28, 31, 34, 37, 40, 43, 46, 49, 52, 55, 58,
+            61, 64, 67, 70, 73, 76, 79, 82, 85, 88, 91, 94, 97, 100
+        ]);
+
+    t.end();
+
+    /* eslint-enable */
+    /* END JSSTYLED */
+});
-- 
2.21.0

