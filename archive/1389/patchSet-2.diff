From 49d1a535417143b9525c11b07f77628a025ccf09 Mon Sep 17 00:00:00 2001
From: "Joshua M. Clulow" <jmc@joyent.com>
Date: Wed, 8 Feb 2017 16:26:04 -0800
Subject: [PATCH] MANTA-3130 update muppet to haproxy 1.5.19 with event ports
 support

---
 Makefile               |  10 +-
 VERSION                |   2 +-
 doc/configuration.txt  |  10 +-
 doc/haproxy.1          |   5 +
 include/types/global.h |   5 +-
 src/cfgparse.c         |   3 +
 src/ev_evports.c       | 377 +++++++++++++++++++++++++++++++++++++++++
 src/haproxy.c          |  13 ++
 8 files changed, 420 insertions(+), 5 deletions(-)
 create mode 100644 src/ev_evports.c

diff --git a/Makefile b/Makefile
index e3199b23..eac9c205 100644
--- a/Makefile
+++ b/Makefile
@@ -34,6 +34,7 @@
 #   USE_ZLIB             : enable zlib library support.
 #   USE_CPU_AFFINITY     : enable pinning processes to CPU on Linux. Automatic.
 #   USE_TFO              : enable TCP fast open. Supported on Linux >= 3.7.
+#   USE_EVPORTS          : enable event ports on SunOS systems. Automatic.
 #
 # Options can be forced by specifying "USE_xxx=1" or can be disabled by using
 # "USE_xxx=" (empty string).
@@ -267,7 +268,8 @@ ifeq ($(TARGET),solaris)
   # This is for Solaris 8
   # We also enable getaddrinfo() which works since solaris 8.
   USE_POLL       = implicit
-  TARGET_CFLAGS  = -fomit-frame-pointer -DFD_SETSIZE=65536 -D_REENTRANT
+  USE_EVPORTS    = implicit
+  TARGET_CFLAGS  = -fno-omit-frame-pointer -DFD_SETSIZE=65536 -D_REENTRANT
   TARGET_LDFLAGS = -lnsl -lsocket
   USE_TPROXY     = implicit
   USE_LIBCRYPT    = implicit
@@ -462,6 +464,12 @@ OPTIONS_CFLAGS += -DUSE_MY_EPOLL
 BUILD_OPTIONS  += $(call ignore_implicit,USE_MY_EPOLL)
 endif
 
+ifneq ($(USE_EVPORTS),)
+OPTIONS_CFLAGS += -DENABLE_EVPORTS
+OPTIONS_OBJS   += src/ev_evports.o
+BUILD_OPTIONS  += $(call ignore_implicit,USE_EVPORTS)
+endif
+
 ifneq ($(USE_KQUEUE),)
 OPTIONS_CFLAGS += -DENABLE_KQUEUE
 OPTIONS_OBJS   += src/ev_kqueue.o
diff --git a/VERSION b/VERSION
index e7a15ceb..4ab32463 100644
--- a/VERSION
+++ b/VERSION
@@ -1 +1 @@
-1.5.19
+1.5.19-joyent1
diff --git a/doc/configuration.txt b/doc/configuration.txt
index b246bdea..c594f86b 100644
--- a/doc/configuration.txt
+++ b/doc/configuration.txt
@@ -474,6 +474,7 @@ The following keywords are supported in the "global" section :
    - maxsslconn
    - maxsslrate
    - noepoll
+   - noevports
    - nokqueue
    - nopoll
    - nosplice
@@ -852,6 +853,12 @@ noepoll
   equivalent to the command-line argument "-de". The next polling system
   used will generally be "poll". See also "nopoll".
 
+noevports
+  Disables the use of the event ports event polling system on SunOS systems
+  derived from Solaris 10 and later. It is equivalent to the command-line
+  argument "-dv". The next polling system used will generally be "poll". See
+  also "nopoll".
+
 nokqueue
   Disables the use of the "kqueue" event polling system on BSD. It is
   equivalent to the command-line argument "-dk". The next polling system
@@ -861,7 +868,8 @@ nopoll
   Disables the use of the "poll" event polling system. It is equivalent to the
   command-line argument "-dp". The next polling system used will be "select".
   It should never be needed to disable "poll" since it's available on all
-  platforms supported by HAProxy. See also "nokqueue" and "noepoll".
+  platforms supported by HAProxy. See also "nokqueue", "noepoll", and
+  "noevports".
 
 nosplice
   Disables the use of kernel tcp splicing between sockets on Linux. It is
diff --git a/doc/haproxy.1 b/doc/haproxy.1
index 20c9343c..416be2f8 100644
--- a/doc/haproxy.1
+++ b/doc/haproxy.1
@@ -102,6 +102,11 @@ in daemon mode.
 \fB\-dk\fP
 Disable use of \fBkqueue\fP(2). \fBkqueue\fP(2) is available only on BSD systems.
 
+.TP
+\fB\-dv\fP
+Disable use of event ports. Event ports are available only on SunOS systems
+derived from Solaris 10 and later (including illumos systems).
+
 .TP
 \fB\-ds\fP
 Disable use of speculative \fBepoll\fP(7). \fBepoll\fP(7) is available only on
diff --git a/include/types/global.h b/include/types/global.h
index f1525ae3..7133bc14 100644
--- a/include/types/global.h
+++ b/include/types/global.h
@@ -55,9 +55,10 @@
 #define GTUNE_USE_POLL           (1<<1)
 #define GTUNE_USE_EPOLL          (1<<2)
 #define GTUNE_USE_KQUEUE         (1<<3)
+#define GTUNE_USE_EVPORTS        (1<<4)
 /* platform-specific options */
-#define GTUNE_USE_SPLICE         (1<<4)
-#define GTUNE_USE_GAI            (1<<5)
+#define GTUNE_USE_SPLICE         (1<<5)
+#define GTUNE_USE_GAI            (1<<6)
 
 /* Access level for a stats socket */
 #define ACCESS_LVL_NONE     0
diff --git a/src/cfgparse.c b/src/cfgparse.c
index 9331415e..06304b62 100644
--- a/src/cfgparse.c
+++ b/src/cfgparse.c
@@ -596,6 +596,9 @@ int cfg_parse_global(const char *file, int linenum, char **args, int kwm)
 	else if (!strcmp(args[0], "nokqueue")) {
 		global.tune.options &= ~GTUNE_USE_KQUEUE;
 	}
+	else if (!strcmp(args[0], "noevports")) {
+		global.tune.options &= ~GTUNE_USE_EVPORTS;
+	}
 	else if (!strcmp(args[0], "nopoll")) {
 		global.tune.options &= ~GTUNE_USE_POLL;
 	}
diff --git a/src/ev_evports.c b/src/ev_evports.c
new file mode 100644
index 00000000..2833d393
--- /dev/null
+++ b/src/ev_evports.c
@@ -0,0 +1,377 @@
+/*
+ * FD polling functions for SunOS event ports.
+ *
+ * Copyright 2017 Joyent, Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ */
+
+/*
+ * The assertions in this file are cheap and we always want them enabled.
+ */
+#ifdef NDEBUG
+#undef NDEBUG
+#include <assert.h>
+#define NDEBUG
+#else
+#include <assert.h>
+#endif
+
+#include <unistd.h>
+#include <sys/time.h>
+#include <sys/types.h>
+
+#include <poll.h>
+#include <port.h>
+#include <errno.h>
+#include <syslog.h>
+
+#include <common/compat.h>
+#include <common/config.h>
+#include <common/ticks.h>
+#include <common/time.h>
+
+#include <types/global.h>
+
+#include <proto/fd.h>
+#include <proto/signal.h>
+#include <proto/task.h>
+#include <proto/log.h>
+
+/*
+ * Private data:
+ */
+static int evports_fd = -1;
+static port_event_t *evports_evlist = NULL;
+static int evports_evlist_max = 0;
+static int volatile evports_panic_errno = 0;
+
+/*
+ * Convert the "state" member of "fdtab" into an event ports event mask.
+ */
+static int evports_state_to_events(int state)
+{
+	int events = 0;
+
+	if (state & FD_EV_POLLED_W)
+		events |= POLLOUT;
+	if (state & FD_EV_POLLED_R)
+		events |= POLLIN;
+
+	return (events);
+}
+
+/*
+ * Associate or dissociate this file descriptor with the event port, using the
+ * specified event mask.  We are strict with failures, to ensure that we're not
+ * doing extra work.
+ */
+static void evports_resync_fd(int fd, int events)
+{
+	if (events == 0) {
+		if (port_dissociate(evports_fd, PORT_SOURCE_FD, fd) != 0) {
+			evports_panic_errno = errno;
+			send_log(NULL, LOG_EMERG,
+			    "port_dissociate failure: fd %d: %s\n",
+			    fd, strerror(errno));
+			abort();
+		}
+	} else {
+		if (port_associate(evports_fd, PORT_SOURCE_FD, fd, events,
+		    NULL) != 0) {
+			evports_panic_errno = errno;
+			send_log(NULL, LOG_EMERG,
+			    "port_associate failure: fd %d: %s\n",
+			    fd, strerror(errno));
+			abort();
+		}
+	}
+}
+
+/*
+ * Event Ports poller.  This routine interacts with the file descriptor
+ * management data structures and routines; see the large block comment in
+ * "src/fd.c" for more information.
+ */
+REGPRM2 static void evports_do_poll(struct poller *p, int exp)
+{
+	int i;
+	int wait_time;
+	struct timespec timeout;
+	int r;
+	int e = 0;
+	unsigned int nevlist;
+	int interrupted = 0;
+
+	/*
+	 * Scan the list of file descriptors with an updated status:
+	 */
+	for (i = 0; i < fd_nbupdt; i++) {
+		int stateold, statenew;
+		int fd = fd_updt[i];
+
+		fdtab[fd].updated = 0;
+		fdtab[fd].new = 0;
+
+		if (fdtab[fd].owner == NULL)
+			continue;
+
+		stateold = fdtab[fd].state;
+		statenew = fd_compute_new_polled_status(stateold);
+
+		/*
+		 * Check if the poll status has changed.  If it has, we need to
+		 * reassociate now to update the event mask for this file
+		 * descriptor.
+		 */
+		if ((stateold & FD_EV_POLLED_RW) !=
+		    (statenew & FD_EV_POLLED_RW)) {
+			int events = evports_state_to_events(statenew);
+
+			evports_resync_fd(fd, events);
+
+			fdtab[fd].state = statenew;
+		}
+
+		fd_alloc_or_release_cache_entry(fd, statenew);
+	}
+	fd_nbupdt = 0;
+
+	/*
+	 * Determine how long to wait for events to materialise on the port.
+	 */
+	if (fd_cache_num > 0 || run_queue > 0 || signal_queue_len > 0) {
+		/*
+		 * If there are other tasks ready to process, we don't want to
+		 * sleep at all.
+		 */
+		wait_time = 0;
+	} else if (exp == 0) {
+		wait_time = MAX_DELAY_MS;
+	} else if (tick_is_expired(exp, now_ms)) {
+		wait_time = 0;
+	} else {
+		wait_time = TICKS_TO_MS(tick_remain(now_ms, exp)) + 1;
+		if (wait_time > MAX_DELAY_MS) {
+			wait_time = MAX_DELAY_MS;
+		}
+	}
+
+	timeout.tv_sec = wait_time / 1000;
+	timeout.tv_nsec = (wait_time % 1000) * 1000000;
+
+	gettimeofday(&before_poll, NULL);
+	nevlist = 1;
+	if ((r = port_getn(evports_fd, evports_evlist, evports_evlist_max,
+	    &nevlist, &timeout)) != 0) {
+		switch (e = errno) {
+		case ETIME:
+			/*
+			 * Though the manual page has not historically made it
+			 * clear, port_getn() can return -1 with an errno of
+			 * ETIME and still have returned some number of events.
+			 */
+			e = 0;
+			r = 0;
+			if (nevlist == 0)
+				interrupted = 1;
+			break;
+
+		case EINTR:
+			nevlist = 0;
+			interrupted = 1;
+			break;
+
+		default:
+			evports_panic_errno = e;
+			send_log(NULL, LOG_EMERG,
+			    "port_getn failure: fd %d: %s\n",
+			    evports_fd, strerror(e));
+			abort();
+		}
+	}
+	tv_update_date(wait_time, interrupted);
+	measure_idle();
+
+	for (i = 0; i < nevlist; i++) {
+		int fd = evports_evlist[i].portev_object;
+		int events = evports_evlist[i].portev_events;
+		int rebind_events;
+
+		if (fdtab[fd].owner == NULL)
+			continue;
+
+		/*
+		 * By virtue of receiving an event for this file descriptor, it
+		 * is no longer associated with the port in question.  Store
+		 * the previous event mask so that we may reassociate after
+		 * processing is complete.
+		 */
+		rebind_events = evports_state_to_events(fdtab[fd].state);
+		assert(rebind_events != 0);
+
+		/*
+		 * Clear all but the persistent poll bits (ERR & HUP):
+		 */
+		fdtab[fd].ev &= FD_POLL_STICKY;
+
+		/*
+		 * Set bits based on the events we received from the port:
+		 */
+		if (events & POLLIN)
+			fdtab[fd].ev |= FD_POLL_IN;
+		if (events & POLLOUT)
+			fdtab[fd].ev |= FD_POLL_OUT;
+		if (events & POLLERR)
+			fdtab[fd].ev |= FD_POLL_ERR;
+		if (events & POLLHUP)
+			fdtab[fd].ev |= FD_POLL_HUP;
+
+		/*
+		 * Call connection processing callbacks.  Note that it's
+		 * possible for this processing to alter the required event
+		 * port assocation; i.e., the "state" member of the "fdtab"
+		 * entry.  If it changes, the fd will be placed on the updated
+		 * list for processing the next time we are called.
+		 */
+		fd_process_polled_events(fd);
+
+		/*
+		 * This file descriptor was closed during the processing of
+		 * polled events.  No need to reassociate.
+		 */
+		if (fdtab[fd].owner == NULL)
+			continue;
+
+		/*
+		 * Reassociate with the port, using the same event mask as
+		 * before.  This call will not result in a dissociation as we
+		 * asserted that _some_ events needed to be rebound above.
+		 *
+		 * Reassociating with the same mask allows us to mimic the
+		 * level-triggered behaviour of poll(2).  In the event that we
+		 * are interested in the same events on the next turn of the
+		 * loop, this represents no extra work.
+		 *
+		 * If this additional port_associate(3C) call becomes a
+		 * performance problem, we would need to verify that we can
+		 * correctly interact with the file descriptor cache and update
+		 * list (see "src/fd.c") to avoid reassociating here, or to use
+		 * a different events mask.
+		 */
+		evports_resync_fd(fd, rebind_events);
+	}
+}
+
+/*
+ * Initialisation of the event ports poller.
+ * Returns 0 in case of failure, non-zero in case of success.
+ */
+REGPRM1 static int evports_do_init(struct poller *p)
+{
+	p->private = NULL;
+
+	evports_evlist_max = global.tune.maxpollevents;
+	evports_evlist = calloc(evports_evlist_max, sizeof (port_event_t));
+	if (evports_evlist == NULL) {
+		goto fail;
+	}
+
+	if ((evports_fd = port_create()) == -1) {
+		goto fail;
+	}
+
+	return 1;
+
+fail:
+	free(evports_evlist);
+	evports_evlist = NULL;
+	evports_evlist_max = 0;
+	return 0;
+}
+
+/*
+ * Termination of the event ports poller.
+ * All resources are released and the poller is marked as inoperative.
+ */
+REGPRM1 static void evports_do_term(struct poller *p)
+{
+	if (evports_fd != -1) {
+		assert(close(evports_fd) == 0);
+		evports_fd = -1;
+	}
+
+	p->private = NULL;
+	p->pref = 0;
+
+	free(evports_evlist);
+	evports_evlist = NULL;
+	evports_evlist_max = 0;
+}
+
+/*
+ * Run-time check to make sure we can allocate the resources needed for
+ * the poller to function correctly.
+ * Returns 1 on success, otherwise 0.
+ */
+REGPRM1 static int evports_do_test(struct poller *p)
+{
+	int fd;
+
+	if ((fd = port_create()) == -1) {
+		return 0;
+	}
+
+	assert(close(fd) == 0);
+	return 1;
+}
+
+/*
+ * Close and recreate the event port after fork().  Returns 1 on success,
+ * otherwise 0.  If this function fails, "evports_do_term()" must be called to
+ * clean up the poller.
+ */
+REGPRM1 static int evports_do_fork(struct poller *p)
+{
+	if (evports_fd != -1) {
+		assert(close(evports_fd) == 0);
+	}
+
+	if ((evports_fd = port_create()) == -1) {
+		return 0;
+	}
+
+	return 1;
+}
+
+/*
+ * This constructor must be called before main() to register the event ports
+ * poller.
+ */
+__attribute__((constructor))
+static void evports_do_register(void)
+{
+	struct poller *p;
+
+	if (nbpollers >= MAX_POLLERS)
+		return;
+
+	assert(evports_fd == -1);
+	assert(evports_evlist == NULL);
+	assert(evports_evlist_max == 0);
+
+	p = &pollers[nbpollers++];
+
+	p->name = "evports";
+	p->pref = 300;
+	p->private = NULL;
+
+	p->init = evports_do_init;
+	p->term = evports_do_term;
+	p->test = evports_do_test;
+	p->fork = evports_do_fork;
+	p->poll = evports_do_poll;
+}
diff --git a/src/haproxy.c b/src/haproxy.c
index 53d9bec3..ae0c1375 100644
--- a/src/haproxy.c
+++ b/src/haproxy.c
@@ -386,6 +386,9 @@ void usage(char *name)
 #if defined(ENABLE_KQUEUE)
 		"        -dk disables kqueue() usage even when available\n"
 #endif
+#if defined(ENABLE_EVPORTS)
+		"        -dv disables event ports usage even when available\n"
+#endif
 #if defined(ENABLE_POLL)
 		"        -dp disables poll() usage even when available\n"
 #endif
@@ -556,6 +559,9 @@ void init(int argc, char **argv)
 #if defined(ENABLE_KQUEUE)
 	global.tune.options |= GTUNE_USE_KQUEUE;
 #endif
+#if defined(ENABLE_EVPORTS)
+	global.tune.options |= GTUNE_USE_EVPORTS;
+#endif
 #if defined(CONFIG_HAP_LINUX_SPLICE)
 	global.tune.options |= GTUNE_USE_SPLICE;
 #endif
@@ -597,6 +603,10 @@ void init(int argc, char **argv)
 			else if (*flag == 'd' && flag[1] == 'k')
 				global.tune.options &= ~GTUNE_USE_KQUEUE;
 #endif
+#if defined(ENABLE_EVPORTS)
+			else if (*flag == 'd' && flag[1] == 'v')
+				global.tune.options &= ~GTUNE_USE_EVPORTS;
+#endif
 #if defined(CONFIG_HAP_LINUX_SPLICE)
 			else if (*flag == 'd' && flag[1] == 'S')
 				global.tune.options &= ~GTUNE_USE_SPLICE;
@@ -858,6 +868,9 @@ void init(int argc, char **argv)
 	if (!(global.tune.options & GTUNE_USE_KQUEUE))
 		disable_poller("kqueue");
 
+	if (!(global.tune.options & GTUNE_USE_EVPORTS))
+		disable_poller("evports");
+
 	if (!(global.tune.options & GTUNE_USE_EPOLL))
 		disable_poller("epoll");
 
-- 
2.21.0

