commit 9c73964f6675de0ab36c73fa09d496f67b6bb054 (refs/changes/96/1696/1)
Author: Cody Peter Mello <cody.mello@joyent.com>
Date:   2017-03-22T01:06:48+00:00 (2 years, 7 months ago)
    
    NAPI-385 NAPI allowed multiple NIC MACs to have same IP
    NAPI-146 Specifying IPs w/o any network_uuid should take subnet into account
    NAPI-358 Updating "cn_uuid" should generate shootdown messages
    NAPI-365 Use node-moray-sandbox in unit tests
    NAPI-396 NIC provisions shouldn't retry forever
    NAPI-397 Calling UpdateNic on a fabric NIC crashes NAPI
    NAPI-400 Use Moray client v2

diff --git a/.gitignore b/.gitignore
index 0fbcfdd..a051ea4 100644
--- a/.gitignore
+++ b/.gitignore
@@ -1,5 +1,6 @@
 smf/manifests/napi.xml
 /build
+/coverage
 node_modules
 napi-pkg-*.tar.bz2
 config.json
diff --git a/Makefile b/Makefile
index 5646d88..b878482 100644
--- a/Makefile
+++ b/Makefile
@@ -5,7 +5,7 @@
 #
 
 #
-# Copyright (c) 2015, Joyent, Inc.
+# Copyright 2017, Joyent, Inc.
 #
 
 #
@@ -16,7 +16,8 @@
 # Tools
 #
 
-TAPE	:= ./node_modules/.bin/tape
+ISTANBUL	:= node_modules/.bin/istanbul
+FAUCET		:= node_modules/.bin/faucet
 
 #
 # Files
@@ -64,24 +65,25 @@ INSTDIR         := $(PKGDIR)/root/opt/smartdc/napi
 #
 
 .PHONY: all
-all: $(SMF_MANIFESTS) | $(TAPE) $(REPO_DEPS) sdc-scripts
-	$(NPM) install
+all: $(SMF_MANIFESTS) | $(NPM_EXEC) $(REPO_DEPS) sdc-scripts
+	$(NPM) install --production
 
 $(ESLINT): | $(NPM_EXEC)
+	$(NPM) install \
+	    eslint@`json -f package.json devDependencies.eslint` \
+	    eslint-plugin-joyent@`json -f package.json devDependencies.eslint-plugin-joyent`
+
+$(ISTANBUL): | $(NPM_EXEC)
 	$(NPM) install
 
-$(TAPE): | $(NPM_EXEC)
+$(FAUCET): | $(NPM_EXEC)
 	$(NPM) install
 
-CLEAN_FILES += $(TAPE) ./node_modules/tape
+CLEAN_FILES += ./node_modules/tape
 
 .PHONY: test
-test: $(TAPE)
-	@(for F in test/unit/*.test.js; do \
-		echo "# $$F" ;\
-		$(NODE_EXEC) $(TAPE) $$F ;\
-		[[ $$? == "0" ]] || exit 1; \
-	done)
+test: $(ISTANBUL) $(FAUCET)
+	$(ISTANBUL) cover --print none test/unit/run.js | $(FAUCET)
 
 #
 # Packaging targets
diff --git a/README.md b/README.md
index aefcc95..9123e73 100644
--- a/README.md
+++ b/README.md
@@ -5,7 +5,7 @@
 -->
 
 <!--
-    Copyright (c) 2016, Joyent, Inc.
+    Copyright 2017, Joyent, Inc.
 -->
 
 # sdc-napi
@@ -150,11 +150,17 @@ ensure all unit and integration tests pass before checkin.
 
 ## Running unit tests
 
-To run all tests:
+The unit tests require having Postgres installed. On Mac OS X and SmartOS, you
+can install it with:
+
+    pkgin in postgresql92-server postgresql92-client
+
+To run all of the unit tests:
 
     make test
 
-To run an individual test:
+This will also output code coverage information into `coverage/`. To run an
+individual test:
 
     ./test/runtest ./test/unit/testname.test.js
 
diff --git a/lib/apis/moray.js b/lib/apis/moray.js
index c2a5a75..50c56d0 100644
--- a/lib/apis/moray.js
+++ b/lib/apis/moray.js
@@ -21,6 +21,7 @@ var jsprim = require('jsprim');
 var restify = require('restify');
 var util = require('util');
 var util_common = require('../util/common');
+var VError = require('verror');
 
 
 
@@ -147,7 +148,7 @@ function initBucket(moray, bucket, callback) {
 
     moray.getBucket(name, function (err, prevBucket) {
         if (err) {
-            if (err.name === 'BucketNotFoundError') {
+            if (VError.hasCauseWithName(err, 'BucketNotFoundError')) {
                 // If this is a new creation and we have a bucket
                 // version, use it, since we don't need to migrate.
                 if (bucket.hasOwnProperty('version')) {
@@ -201,7 +202,7 @@ function initBucket(moray, bucket, callback) {
  */
 function delObj(moray, bucket, key, callback) {
     moray.delObject(bucket.name, key, function (err) {
-        if (err && err.name === 'ObjectNotFoundError') {
+        if (err && VError.hasCauseWithName(err, 'ObjectNotFoundError')) {
             return callback(new restify.ResourceNotFoundError(err,
                 '%s not found', bucket.desc));
         }
@@ -222,7 +223,7 @@ function delObj(moray, bucket, key, callback) {
 function getObj(moray, bucket, key, callback) {
     moray.getObject(bucket.name, key, function (err, res) {
         if (err) {
-            if (err.name === 'ObjectNotFoundError') {
+            if (VError.hasCauseWithName(err, 'ObjectNotFoundError')) {
                 return callback(new restify.ResourceNotFoundError(err,
                     '%s not found', bucket.desc));
             }
diff --git a/lib/migrate.js b/lib/migrate.js
index e7795bc..b03f812 100644
--- a/lib/migrate.js
+++ b/lib/migrate.js
@@ -311,15 +311,17 @@ function updateRecords(opts, callback) {
                 bucket: bucket.name
             }, 'updateRecords: batch');
 
-            moray.batch(batch, function (batchErr) {
-                if (batchErr) {
-                    if (batchErr.name === 'EtagConflictError') {
+            moray.batch(batch, function (bErr) {
+                if (bErr) {
+                    if (VError.hasCauseWithName(bErr, 'EtagConflictError')) {
                         // One of the batch objects has been updated from
                         // under us: try it again next time
-                        return next(batchErr, null, true);
+                        next(bErr, null, true);
+                        return;
                     }
 
-                    return next(batchErr, null, false);
+                    next(bErr, null, false);
+                    return;
                 }
 
                 processed += batch.length;
@@ -330,7 +332,7 @@ function updateRecords(opts, callback) {
                 }, 'updateRecords: records migrated');
 
                 // Migration succeeded - keep going
-                return next(null, null, true);
+                next(null, null, true);
             });
         });
     }, function (afterErr) {
diff --git a/lib/models/aggregation.js b/lib/models/aggregation.js
index 86bbdbf..baccf50 100644
--- a/lib/models/aggregation.js
+++ b/lib/models/aggregation.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright 2016, Joyent, Inc.
+ * Copyright 2017, Joyent, Inc.
  */
 
 /*
@@ -26,6 +26,7 @@ var util_common = require('../util/common');
 var util_mac = require('../util/mac');
 var validate = require('../util/validate');
 var vasync = require('vasync');
+var VError = require('verror');
 
 
 
@@ -215,7 +216,7 @@ function validateMACs(opts, name, list, callback) {
         if (invalidMACs.length !== 0) {
             var serverErr = new errors.invalidParam(name,
                 constants.msg.AGGR_BELONGS);
-            serverErr.invalid = invalidMACs;
+            serverErr.invalid = invalidMACs.sort();
             return callback(serverErr);
         }
 
@@ -247,6 +248,10 @@ function Aggr(params) {
 
     this.params.id = util.format('%s-%s', this.params.belongs_to_uuid,
         this.params.name);
+
+    this.etag = params.etag || null;
+
+    Object.seal(this);
 }
 
 Object.defineProperty(Aggr.prototype, 'id', {
@@ -274,6 +279,22 @@ Aggr.prototype.raw = function aggrRaw() {
 };
 
 
+/**
+ * Returns the raw Moray form of this aggregation for adding to a batch.
+ */
+Aggr.prototype.batch = function aggrBatch() {
+    return {
+        bucket: BUCKET.name,
+        key: this.id,
+        operation: 'put',
+        value: this.raw(),
+        option: {
+            etag: this.etag
+        }
+    };
+};
+
+
 /**
  * Returns the serialized (API-facing) form of the aggregation
  */
@@ -319,7 +340,7 @@ function createAggr(opts, callback) {
         app.moray.putObject(BUCKET.name, aggr.id, aggr.raw(),
             { etag: null }, function (err2) {
             if (err2) {
-                if (err2.name === 'EtagConflictError') {
+                if (VError.hasCauseWithName(err2, 'EtagConflictError')) {
                     return callback(new errors.InvalidParamsError(
                         constants.msg.INVALID_PARAMS, [
                             errors.duplicateParam('name',
@@ -349,10 +370,12 @@ function getAggr(opts, callback) {
         mod_moray.getObj(opts.app.moray, BUCKET, validated.id,
             function (err2, rec) {
             if (err2) {
-                return callback(err2);
+                callback(err2);
+                return;
             }
 
-            return callback(null, new Aggr(rec.value));
+            rec.value.etag = rec._etag;
+            callback(null, new Aggr(rec.value));
         });
     });
 }
@@ -443,7 +466,7 @@ function deleteAggr(opts, callback) {
 
         opts.app.moray.delObject(BUCKET.name, validated.id, function (err2) {
             if (err2) {
-                if (err2.name === 'ObjectNotFoundError') {
+                if (VError.hasCauseWithName(err2, 'ObjectNotFoundError')) {
                     return callback(new restify.ResourceNotFoundError(err2,
                         'aggregation not found'));
                 }
diff --git a/lib/models/ip/common.js b/lib/models/ip/common.js
index 009ab51..fcd7a6b 100644
--- a/lib/models/ip/common.js
+++ b/lib/models/ip/common.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright 2016, Joyent, Inc.
+ * Copyright 2017, Joyent, Inc.
  */
 
 /*
@@ -115,7 +115,7 @@ Object.defineProperty(IP.prototype, 'v6address', {
 /**
  * Returns an object suitable for passing to a moray batch
  */
-IP.prototype.batch = function ipBatch(opts) {
+IP.prototype.batch = function ipBatch() {
     var batchObj = {
         bucket: bucketName(this.params.network_uuid),
         key: this.key(),
@@ -126,18 +126,34 @@ IP.prototype.batch = function ipBatch(opts) {
         }
     };
 
-    if (opts && opts.free) {
-        batchObj.value = {
-            reserved: false
-        };
+    return batchObj;
+};
 
-        if (this.use_strings) {
-            batchObj.value.ipaddr = this.params.ip.toString();
-        } else {
-            batchObj.value.ip = this.params.ip.toLong();
-        }
+
+/**
+ * Returns an object suitable for passing to a Moray batch to unassign this
+ * IP from its owning NIC.
+ */
+IP.prototype.unassignBatch = function unassignIP() {
+    var raw = this.raw();
+
+    if (!this.params.reserved) {
+        delete raw.owner_uuid;
     }
 
+    delete raw.belongs_to_type;
+    delete raw.belongs_to_uuid;
+
+    var batchObj = {
+        bucket: bucketName(this.params.network_uuid),
+        key: this.key(),
+        operation: 'put',
+        value: raw,
+        options: {
+            etag: this.etag
+        }
+    };
+
     return batchObj;
 };
 
@@ -174,8 +190,9 @@ IP.prototype.provisionable = function ipProvisionable() {
  */
 IP.prototype.serialize = function ipSerialize() {
     var self = this;
-    var ser =  {
+    var ser = {
         ip: this.params.ip.toString(),
+        network_uuid: this.params.network.uuid,
         reserved: this.params.reserved ? true : false,
         free: this.params.reserved ? false : true
     };
@@ -187,10 +204,6 @@ IP.prototype.serialize = function ipSerialize() {
         }
     });
 
-    if (this.params.hasOwnProperty('network_uuid')) {
-        ser.network_uuid = this.params.network_uuid;
-    }
-
     return ser;
 };
 
diff --git a/lib/models/ip/provision.js b/lib/models/ip/provision.js
index ff52bc4..09fdcd1 100644
--- a/lib/models/ip/provision.js
+++ b/lib/models/ip/provision.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2014, Joyent, Inc.
+ * Copyright 2017, Joyent, Inc.
  */
 
 /*
@@ -15,6 +15,7 @@
 'use strict';
 
 var assert = require('assert-plus');
+var clone = require('clone');
 var common = require('./common');
 var constants = require('../../util/constants');
 var errors = require('../../util/errors');
@@ -31,11 +32,12 @@ var util_ip = require('../../util/ip.js');
  *
  * ## bucket structure
  *
- * There is one IP bucket per network, named napi_ips_<network UUID>, as
- * per bucketName() below.  The key is on .ip, which is the integer
- * representation of the IP address (this is therefore a unique index). The
- * bucket is created with certain keys pre-populated. A diagram of these keys
- * sorted in ascending order looks like this:
+ * There is one IP bucket per network, named napi_ips_<network UUID>, as per
+ * bucketName() below. For older networks, the key is in .ip, which is the
+ * integer representation of the IP address. Newer networks store it in .ipaddr,
+ * which uses the Postgres INET type. These are both unique keys. The bucket is
+ * created with certain keys pre-populated. A diagram of these keys sorted in
+ * ascending order looks like this:
  *
  *   +--------------------------------------------------------+
  *   |   | GW |     | PS |                | PE |         | BR |
@@ -202,72 +204,86 @@ var util_ip = require('../../util/ip.js');
 
 // --- Internal
 
+/**
+ * Gap length could be bigger than JavaScript's max int, so
+ * cap it off on the Postgres side before it gets to Moray.
+ */
+var MAX_GAP_LENGTH = 100;
+
+var GAP_IP_STR_SQL = util.format(
+    'SELECT * FROM (SELECT ipaddr+1 gap_start, least(coalesce(lead(ipaddr) ' +
+    'OVER (ORDER BY ipaddr) - ipaddr - 1, 0), %d) gap_length FROM %%s ' +
+    'WHERE ipaddr >= $1 AND ipaddr <= $2) t ' +
+    'WHERE gap_length > 0 LIMIT 1', MAX_GAP_LENGTH);
+
+var GAP_IP_NUM_SQL =
+    'SELECT * FROM (SELECT ip+1 gap_start, lead(ip) ' +
+    'OVER (ORDER BY ip) - ip - 1 gap_length FROM %s ' +
+    'WHERE ip >= $1 AND ip <= $2) t WHERE gap_length > 0 LIMIT 1';
+
+function ProvisionInfo(baseParams, network) {
+    this.params = clone(baseParams);
+    this.params.network = network;
+    this.params.network_uuid = network.uuid;
+    this.tries = 0;
+    this.noMoreGapIPs = false;
+    this.queue = [];
+
+    Object.seal(this);
+}
 
 
 /**
- * Create opts.ip, and add its batch item to opts.batch
+ * Construct a new IP object using the next queued address.
  */
-function addIPtoBatch(opts) {
-    if (opts.ipProvisionQueue[0].hasOwnProperty('ip')) {
-        opts.ipParams.ip = opts.ipProvisionQueue[0].ip;
-    }
+ProvisionInfo.prototype.shift = function getNextIP() {
+    var nextIP = this.queue.shift();
 
-    if (opts.ipProvisionQueue[0].hasOwnProperty('ipaddr')) {
-        opts.ipParams.ipaddr = opts.ipProvisionQueue[0].ipaddr;
-    }
+    assert.ok(nextIP, 'nextIP');
+    assert.ok(nextIP.ip, 'nextIP.ip');
 
-    opts.ipParams.etag = opts.ipProvisionQueue[0].etag;
-    opts.ip = new common.IP(opts.ipParams);
-    opts.batch.push(opts.ip.batch());
-}
+    var params = clone(this.params);
+    params.etag = nextIP.etag;
+    params.ip = nextIP.ip;
+
+    return new common.IP(params);
+};
 
 
 /**
  * Get the next "gap" IPs (with no existing moray record, but in the subnet
- * range) from the network specified by opts.validated.network_uuid.
+ * range) from the specified network.
  */
-function nextGapIPsOnNetwork(opts, callback) {
+function nextGapIPsOnNetwork(opts, network, callback) {
     var log = opts.log;
-    var params = opts.validated;
-
-    var bucket = common.getBucketObj(params.network_uuid);
-    var maxGapLength = 100; // gap length could be bigger than javascript's max
-                            // int, so cap it off on the postgres side before
-                            // it gets to moray
-    var min = util_ip.ipAddrMinus(params.network.provisionMin, 1);
-    var max = util_ip.ipAddrPlus(params.network.provisionMax, 1);
-    var gap;
-    var sql = util.format('select * from ' +
-        '(select ipaddr+1 gap_start, least(coalesce(lead(ipaddr) ' +
-        'over(order by ipaddr) - ipaddr - 1, 0), %d) gap_length from %s ' +
-        'where ipaddr >= inet(\'%s\') AND ipaddr <= inet(\'%s\')) t ' +
-        'where gap_length > 0 limit 1',
-            maxGapLength,
-            bucket.name,
-            min.toString(),
-            max.toString());
-
-    if (!params.network.ip_use_strings) {
-        sql = util.format(
-            'select * from (select ip+1 gap_start, lead(ip) ' +
-            'over(order by ip) - ip - 1 gap_length from %s ' +
-            'where ip >= %d AND ip <= %d) t where gap_length > 0 limit 1',
-            bucket.name,
-            min.toLong(),
-            max.toLong());
+
+    var provinfo = opts.ipProvisions[network.uuid];
+
+    var bucket = common.bucketName(network.uuid);
+    var min = util_ip.ipAddrMinus(network.provisionMin, 1);
+    var max = util_ip.ipAddrPlus(network.provisionMax, 1);
+    var gap, sql, args;
+
+    if (network.ip_use_strings) {
+        sql = util.format(GAP_IP_STR_SQL, bucket);
+        args = [ min.toString(), max.toString() ];
+    } else {
+        sql = util.format(GAP_IP_NUM_SQL, bucket);
+        args = [ min.toLong(), max.toLong() ];
     }
 
     log.debug({
-        tries: opts.ipProvisionTries,
+        tries: provinfo.tries,
         sql: sql,
-        network_uuid: params.network_uuid
+        args: args,
+        network_uuid: network.uuid
     }, 'nextGapIPsOnNetwork: finding gap IPs');
 
-    var req = opts.app.moray.sql(sql);
+    var req = opts.app.moray.sql(sql, args);
 
     req.once('record', function (r) {
         log.debug({
-            tries: opts.ipProvisionTries,
+            tries: provinfo.tries,
             rec: r
         }, 'nextGapIPsOnNetwork: gap data');
 
@@ -287,13 +303,14 @@ function nextGapIPsOnNetwork(opts, callback) {
             var freeErr = new Error('No free gap IPs');
             freeErr.noFreeIPs = true;
 
-            opts.noMoreGapIPs = true;
+            provinfo.noMoreGapIPs = true;
             log.debug({
-                network_uuid: params.network_uuid,
-                tries: opts.ipProvisionTries
+                network_uuid: network.uuid,
+                tries: provinfo.tries
             }, 'nextGapIPsOnNetwork: no free gap IPs');
 
-            return callback(freeErr);
+            callback(freeErr);
+            return;
         }
 
         if (!gap.hasOwnProperty('gap_start') ||
@@ -301,60 +318,61 @@ function nextGapIPsOnNetwork(opts, callback) {
             var pgErr = new Error('Invalid record from moray');
             log.error({ err: pgErr, gap: gap, sql: sql },
                 'Moray record missing required properties');
-            return callback(pgErr);
+            callback(pgErr);
+            return;
         }
 
         for (var i = 0; i < gap.gap_length; i++) {
-            opts.ipProvisionQueue.push({
+            provinfo.queue.push({
                 etag: null,
                 ip: util_ip.ipAddrPlus(util_ip.toIPAddr(gap.gap_start), i)
             });
         }
 
         log.debug({
-            network_uuid: params.network_uuid,
-            tries: opts.ipProvisionTries,
+            network_uuid: network.uuid,
+            tries: provinfo.tries,
             gap_start: gap.gap_start,
             gap_length: gap.gap_length,
             found: gap.gap_length - 1
         }, 'nextGapIPsOnNetwork: found gap IPs');
 
-        return callback();
+        callback();
     });
 }
 
 
 /**
- * Get the next previously freed IPs (where the record exists in moray, but has
- * reserved=false and belongs_to_uuid=null) from the network in
- * opts.validated.network_uuid.
+ * Get the next previously freed IPs (where the record exists in Moray, but has
+ * reserved=false and belongs_to_uuid=null) from the specified network.
  */
-function nextFreedIPsonNetwork(opts, callback) {
+function nextFreedIPsonNetwork(opts, network, callback) {
     var log = opts.log;
-    var params = opts.validated;
-    var bucket = common.getBucketObj(params.network_uuid);
+    var bucket = common.bucketName(network.uuid);
     var filter =
         util.format(
             '(&(ipaddr>=%s)(ipaddr<=%s)(!(belongs_to_uuid=*))(reserved=false))',
-            params.network.provisionMin.toString(),
-            params.network.provisionMax.toString());
+            network.provisionMin.toString(),
+            network.provisionMax.toString());
     var found = 0;
 
-    if (!params.network.ip_use_strings) {
+    var provinfo = opts.ipProvisions[network.uuid];
+
+    if (!network.ip_use_strings) {
         filter = util.format(
             '(&(ip>=%d)(ip<=%d)(!(belongs_to_uuid=*))(reserved=false))',
-            params.network.provisionMin.toLong(),
-            params.network.provisionMax.toLong());
+            network.provisionMin.toLong(),
+            network.provisionMax.toLong());
     }
 
     log.debug({
-        bucket: bucket.name,
-        tries: opts.ipProvisionTries,
+        bucket: bucket,
+        tries: provinfo.tries,
         filter: filter,
-        network_uuid: params.network_uuid
+        network_uuid: network.uuid
     }, 'nextFreedIPsonNetwork: finding freed IPs');
 
-    var req = opts.app.moray.findObjects(bucket.name, filter,
+    var req = opts.app.moray.findObjects(bucket, filter,
         { sort: { attribute: '_mtime', order: 'ASC' }, limit: 10 });
 
     req.once('error', function (err) {
@@ -364,27 +382,23 @@ function nextFreedIPsonNetwork(opts, callback) {
 
     req.on('record', function (obj) {
         found++;
-        opts.ipProvisionQueue.push({ ip: obj.key, etag: obj._etag });
+        provinfo.queue.push({ ip: obj.key, etag: obj._etag });
     });
 
     req.once('end', function () {
         if (found > 0) {
             log.debug({
                 found: found,
-                tries: opts.ipProvisionTries
+                tries: provinfo.tries
             }, 'nextFreedIPsonNetwork: found freed IPs');
-            return callback();
+            callback();
+            return;
         }
 
-        log.debug({ tries: opts.ipProvisionTries },
+        log.debug({ tries: provinfo.tries },
             'nextFreedIPsonNetwork: no freed IPs');
 
-        var fullErr =
-            new errors.SubnetFullError(constants.SUBNET_FULL_MSG);
-        fullErr.stop = true;
-        fullErr.context = bucket.name;
-
-        return callback(fullErr);
+        callback(new errors.SubnetFullError(network.uuid));
     });
 }
 
@@ -395,121 +409,85 @@ function nextFreedIPsonNetwork(opts, callback) {
 
 
 /**
- * Get the next IP on the given network, store it in opts.ip, and add its
- * batch item to opts.batch.
- *
- * This is intended to be called repeatedly by the nic model's
- * provision.nicAndIP(). Calling callback with err.stop will therefore end
- * the provisioning loop.
+ * Try to provision an IP:
+ * - If we've exceeded our tries, return stop error.
+ * - If we have items in our queue, remove and return the first one
+ *   via the callback.
+ * - Otherwise, get more IPs.
+ * - If there are no more to get, return a SubnetFullError with stop=true.
+ *
+ * This is intended to be called repeatedly by the NIC model's
+ * Provisioners, which implement provisioning for different scenarios.
+ * Calling the callback here with an error containing stop=true will
+ * therefore end the provisioning loop.
  *
  * @param opts {Object}:
- * - ipParams {Object}: parameters used for creating the IP (required)
+ * - baseParams {Object}: parameters used for creating the IP (required).
+ * @param network {Network}: The network to fetch the next IP for.
+ * @param callback {Function}
  */
-function nextIPonNetwork(opts, callback) {
-    // Try to provision an IP:
-    // - If we've exceeded our tries, return stop err
-    // - If we have an error, but it's not us, return queue[0] again
-    // - If we have an error and it's us, unshift the queue
-    // - If we have queue[0], return it
-    // - Otherwise, get more IPs
-    //   - If there are no more to get, return subnet full stop err
-
+function nextIPonNetwork(opts, network, callback) {
     assert.object(opts, 'opts');
-    assert.object(opts.ipParams, 'opts.ipParams');
+    assert.object(opts.baseParams, 'opts.baseParams');
 
-    if (!opts.hasOwnProperty('ipProvisionTries')) {
-        opts.ipProvisionTries = 0;
-    }
+    opts.log.debug('nextIPonNetwork: attempting IP allocation on %s network %s',
+        network.subnetType, network.uuid);
 
-    if (!opts.ipProvisionQueue) {
-        opts.ipProvisionQueue = [];
+    if (!opts.ipProvisions) {
+        opts.ipProvisions = {};
     }
 
-    // We've exceeded the maximum number tries: return stop err
-    if (opts.ipProvisionTries > constants.IP_PROVISION_RETRIES) {
-        opts.log.error({ tries: constants.IP_PROVISION_RETRIES },
-            'nextIPonNetwork: Exceeded IP provision retries');
-        var tryErr = new
-            errors.SubnetFullError(constants.SUBNET_FULL_MSG);
-        tryErr.stop = true;
-
-        return callback(tryErr);
+    if (!opts.ipProvisions[network.uuid]) {
+        opts.ipProvisions[network.uuid] =
+            new ProvisionInfo(opts.baseParams, network);
     }
 
-    var bucket = common.getBucketObj(opts.validated.network_uuid);
-
-    if (opts.err) {
-        if (opts.err.context && opts.err.context.bucket === bucket.name) {
-            // The error was because the IP we picked last time was already
-            // taken - remove it from the queue below
-            opts.log.debug('nextIPonNetwork: previous error due to us');
-
-        } else if (opts.ipProvisionQueue.length !== 0) {
-            // The error wasn't due to us, so if we have an IP, return it again
-            addIPtoBatch(opts);
-            opts.log.debug({ ip: opts.ip.serialize(), bucket: bucket.name },
-                'nextIPonNetwork: error not due to us: reusing IP');
-            return callback();
-        }
-    }
+    var provinfo = opts.ipProvisions[network.uuid];
 
-    if (opts.ipProvisionQueue.length !== 0) {
-        opts.ipProvisionQueue.shift();
+    // We've exceeded the maximum number of tries: return stop err
+    if (provinfo.tries > constants.IP_PROVISION_RETRIES) {
+        opts.log.error({ tries: constants.IP_PROVISION_RETRIES },
+            'nextIPonNetwork: Exceeded IP provision retries');
+        callback(new errors.SubnetFullError(network.uuid));
+        return;
     }
 
-    if (opts.ipProvisionQueue.length !== 0) {
+    if (provinfo.queue.length !== 0) {
         // We still have an IP in the queue to try - no need to fetch more
-        addIPtoBatch(opts);
-        opts.ipProvisionTries++;
+        var next = provinfo.shift();
+        provinfo.tries++;
 
         opts.log.debug({
-            next: opts.ip.serialize(),
-            queueLength: opts.ipProvisionQueue.length,
-            tries: opts.ipProvisionTries
+            next: next,
+            queueLength: provinfo.queue.length,
+            tries: provinfo.tries
         }, 'nextIPonNetwork: trying next IP in queue');
-        return callback();
+        callback(null, next);
+        return;
     }
 
     // There are no IPs left in the queue - try to get some more
     var selectionFn = nextGapIPsOnNetwork;
-    // XXX: need to put stuff like opts.noMoreGapIPs in its own sub-object!
-    if (opts.noMoreGapIPs) {
+    if (provinfo.noMoreGapIPs) {
         selectionFn = nextFreedIPsonNetwork;
     }
 
     opts.log.debug('nextIPonNetwork: selecting IPs with %s', selectionFn.name);
 
-    selectionFn(opts, function (err) {
+    selectionFn(opts, network, function (err) {
         if (err) {
-            opts.ipProvisionTries++;
-            return callback(err);
+            provinfo.tries++;
+            callback(err);
+            return;
         }
 
         opts.log.debug({
-            next: opts.ipProvisionQueue[0],
-            queueLength: opts.ipProvisionQueue.length,
-            tries: opts.ipProvisionTries
+            next: provinfo.queue[0],
+            queueLength: provinfo.queue.length,
+            tries: provinfo.tries
         }, 'nextIPonNetwork: queue after %s', selectionFn.name);
 
-        if (opts.noMoreGapIPs && opts.ipProvisionQueue.length === 0) {
-            var fullErr = new
-                errors.SubnetFullError(constants.SUBNET_FULL_MSG);
-            fullErr.stop = true;
-            fullErr.context = bucket.name;
-            return callback(err);
-        }
-
-        if (opts.ipProvisionQueue.length === 0) {
-            opts.log.error({ tries: opts.ipProvisionTries },
-                'nextIPonNetwork: empty IP provision queue');
-            var fallbackErr = new
-                errors.SubnetFullError(constants.SUBNET_FULL_MSG);
-            fallbackErr.stop = true;
-            return callback(fallbackErr);
-        }
-
-        addIPtoBatch(opts);
-        return callback();
+        callback(null, provinfo.shift());
     });
 }
 
diff --git a/lib/models/network-pool.js b/lib/models/network-pool.js
index a2114a6..97b35b0 100644
--- a/lib/models/network-pool.js
+++ b/lib/models/network-pool.js
@@ -164,8 +164,6 @@ function provisionableBy(params, uuid) {
  * Fetch the Network objects for each of the given UUIDs.
  */
 function getAllNetworks(app, log, uuids, callback) {
-    var networks = [];
-
     vasync.forEachParallel({
         inputs: uuids,
         func: function (uuid, cb) {
@@ -173,20 +171,18 @@ function getAllNetworks(app, log, uuids, callback) {
                 app: app,
                 log: log,
                 params: { uuid: uuid }
-            }, function (err, obj) {
-                if (obj) {
-                    networks.push(obj);
-                }
-
-                cb(err);
-            });
+            }, cb);
         }
-    }, function (err) {
+    }, function (err, results) {
         if (err) {
             callback(err);
             return;
         }
 
+        var networks = results.operations.map(function (entry) {
+            return entry.result;
+        });
+
         callback(null, networks);
     });
 }
diff --git a/lib/models/network.js b/lib/models/network.js
index 44c832c..9f92982 100644
--- a/lib/models/network.js
+++ b/lib/models/network.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright 2016, Joyent, Inc.
+ * Copyright 2017, Joyent, Inc.
  */
 
 /*
@@ -32,6 +32,7 @@ var util_subnet = require('../util/subnet');
 var UUID = require('node-uuid');
 var validate = require('../util/validate');
 var vasync = require('vasync');
+var VError = require('verror');
 /*
  * Circular dependencies required at end of file.
  */
@@ -107,6 +108,8 @@ var VALID_FIELDS = [
     'vlan_id'
 ];
 
+var CONTAINING_NET_SQL = 'SELECT uuid FROM ' + BUCKET.name +
+    ' WHERE subnet >> $1 AND vlan_id = $2 AND nic_tag = $3';
 
 var IMMUTABLE_FAB_PROP =
     'Fabric network updates for this field are not supported';
@@ -1401,12 +1404,12 @@ function createNetwork(opts, callback) {
             log.debug({ uuid: network.uuid, raw: raw },
                 'createNetwork: creating moray record');
 
-            app.moray.putObject(BUCKET.name, network.uuid, raw,
-                    function (err) {
+            app.moray.putObject(BUCKET.name, network.uuid, raw, { etag: null },
+                function (err) {
                 if (err) {
                     log.error(err, 'Error creating network');
 
-                    if (err.name === 'UniqueAttributeError') {
+                    if (VError.hasCauseWithName(err, 'UniqueAttributeError')) {
                         // name_str is the only unique parameter in this bucket
                         // right now, so it was the culprit
                         return cb(new errors.InvalidParamsError(
@@ -1910,17 +1913,19 @@ function deleteNetwork(opts, callback) {
         function del() {
             mod_moray.delObj(app.moray, BUCKET, params.uuid, function (err2) {
                 if (err2) {
-                    return callback(err2);
+                    callback(err2);
+                    return;
                 }
 
-                var ipsBucket = mod_ip.bucket(params.uuid);
-                app.moray.delBucket(ipsBucket.name, function (err3) {
-                    // The 'does not exist' error just means there were no IPs
-                    // in this network yet, so we haven't created the bucket
-                    if (err3 && err3.message.indexOf('does not exist') === -1) {
-                        return callback(err3);
+                var bucketName = mod_ip.bucketName(params.uuid);
+                app.moray.delBucket(bucketName, function (err3) {
+                    if (err3 &&
+                        VError.hasCauseWithName(err3, 'BucketNotFoundError')) {
+                        callback();
+                        return;
                     }
-                    return callback();
+
+                    callback(err3);
                 });
             });
         }
@@ -1928,6 +1933,32 @@ function deleteNetwork(opts, callback) {
 }
 
 
+/**
+ * Finds networks that contain the specified IP using the provided nic_tag
+ * and vlan_id. This function calls the callback with an array of UUIDs for
+ * all matching networks.
+ */
+function findContainingNetworks(opts, vlan_id, nic_tag, vnet_id, ip, callback) {
+    var sql = CONTAINING_NET_SQL;
+    var args = [ ip.toString(), vlan_id, nic_tag ];
+
+    if (vnet_id !== null) {
+        sql += ' AND vnet_id = $4';
+        args.push(vnet_id);
+    }
+
+    var req = opts.app.moray.sql(sql, args);
+    var uuids = [];
+    req.on('record', function (r) {
+        uuids.push(r.uuid);
+    });
+    req.on('error', callback);
+    req.on('end', function () {
+        callback(null, uuids);
+    });
+}
+
+
 /**
  * Initializes the networks bucket
  */
@@ -1936,6 +1967,34 @@ function initNetworksBucket(app, callback) {
 }
 
 
+function NetworkCache(app, log) {
+    this._cache = {};
+    this.app = app;
+    this.log = log;
+
+    Object.seal(this);
+}
+
+
+NetworkCache.prototype.get = function (uuid, callback) {
+    var self = this;
+    if (self._cache.hasOwnProperty(uuid)) {
+        callback(null, self._cache[uuid]);
+        return;
+    }
+
+    var params = { app: self.app, log: self.log, params: { uuid: uuid } };
+    getNetwork(params, function (err, res) {
+        if (err) {
+            callback(err);
+            return;
+        }
+
+        self._cache[uuid] = res;
+        callback(null, res);
+    });
+};
+
 
 module.exports = {
     bucket: function () { return BUCKET; },
@@ -1943,8 +2002,10 @@ module.exports = {
     del: deleteNetwork,
     get: getNetwork,
     init: initNetworksBucket,
+    findContaining: findContainingNetworks,
     list: listNetworks,
     listNetworksStream: listNetworksStream,
+    NetworkCache: NetworkCache,
     update: updateNetwork,
     Network: Network
 };
diff --git a/lib/models/nic/common.js b/lib/models/nic/common.js
index 7d013b5..1a63475 100644
--- a/lib/models/nic/common.js
+++ b/lib/models/nic/common.js
@@ -24,7 +24,6 @@ var mod_pool = require('../network-pool');
 var mod_portolan_moray = require('portolan-moray');
 var util = require('util');
 var validate = require('../../util/validate');
-var vasync = require('vasync');
 
 
 // --- Globals
@@ -37,6 +36,51 @@ var VALID_NIC_STATES = [ 'provisioning', 'stopped', 'running' ];
 // --- Internal helpers
 
 
+/**
+ * If an owner_uuid has been specified, and we haven't been explicitly
+ * told to ignore it, then make sure it's okay to provision on this
+ * network.
+ */
+function badOwnerUUID(parsedParams, network) {
+    var check_owner = !parsedParams.hasOwnProperty('check_owner') ||
+        parsedParams.check_owner;
+    if (parsedParams.hasOwnProperty('owner_uuid') && check_owner &&
+        !network.isOwner(parsedParams.owner_uuid)) {
+        return true;
+    }
+
+    return false;
+}
+
+
+/**
+ * Check that a network's NIC tag, VLAN ID, and owner match what's present on
+ * the NIC. If the VNET ID needs checking, check that, too.
+ */
+function checkNetwork(parsedParams, name, network) {
+    if (badOwnerUUID(parsedParams, network)) {
+        return errors.invalidParam('owner_uuid', constants.OWNER_MATCH_MSG);
+    }
+
+    if (parsedParams.nic_tag === undefined) {
+        parsedParams.nic_tag = network.nic_tag;
+    } else if (parsedParams.nic_tag !== network.nic_tag) {
+        return errors.invalidParam(name,
+            util.format(constants.fmt.NIC_TAGS_DIFFER,
+            parsedParams.nic_tag, network.nic_tag));
+    }
+
+    if (parsedParams.vlan_id === undefined) {
+        parsedParams.vlan_id = network.params.vlan_id;
+    } else if (parsedParams.vlan_id !== network.params.vlan_id) {
+        return errors.invalidParam(name,
+            util.format(constants.fmt.VLAN_IDS_DIFFER,
+            parsedParams.vlan_id, network.params.vlan_id));
+    }
+
+    return null;
+}
+
 
 /**
  * Validates a network UUID and ensures that the network exists
@@ -76,43 +120,44 @@ function validateNetworkUUID(name, uuid, callback) {
 /**
  * Validate that the subnet contains the IP address
  */
-function validateSubnetContainsIP(opts, parsedParams, callback) {
-    var app = opts.app;
-    var log = opts.log;
-
-    if (!parsedParams.network.subnet.contains(parsedParams.ip)) {
-
-        return callback(errors.invalidParam('ip', util.format(
-            constants.fmt.IP_OUTSIDE, parsedParams.ip,
-            parsedParams.network_uuid)));
+function validateSubnetContainsIP(opts, name, network, ip, callback) {
+    if (!network.subnet.contains(ip)) {
+        callback(errors.invalidParam(name, util.format(
+            constants.fmt.IP_OUTSIDE, ip.toString(), network.uuid)));
+        return;
     }
 
     var getOpts = {
-        app: app,
-        log: log,
-        params: parsedParams,
+        app: opts.app,
+        log: opts.log,
+        params: {
+            ip: ip,
+            network: network,
+            network_uuid: network.uuid
+        },
         // If it's missing in moray, return an object anyway:
         returnObject: true
     };
     mod_ip.get(getOpts, function (err, res) {
         if (err) {
             // XXX : return different error here
-            return callback(err);
+            callback(err);
+            return;
         }
 
-        // Don't allow taking another nic's IP on create if it's taken by
+        // Don't allow taking another NIC's IP on create if it's taken by
         // something else (server, zone)
         if (opts.create && !res.provisionable()) {
-            return callback(errors.usedByParam('ip',
+            callback(errors.usedByParam(name,
                 res.params.belongs_to_type,
                 res.params.belongs_to_uuid,
                 util.format(constants.fmt.IP_IN_USE,
                     res.params.belongs_to_type,
                     res.params.belongs_to_uuid)));
+            return;
         }
 
-        parsedParams._ip = res;
-        return callback();
+        callback(null, res);
     });
 }
 
@@ -203,128 +248,97 @@ function validateNetwork(opts, name, uuid, callback) {
 /**
  * Validate that the network parameters are valid
  */
-function validateNetworkParams(opts, params, parsedParams, callback) {
-    var app = opts.app;
-    var log = opts.log;
+function validateNetworkParams(opts, _, parsedParams, callback) {
+    var cErr;
 
     // Not allowed to provision an IP on a network pool
     if (parsedParams.ip && parsedParams.network_pool) {
-        return callback(errors.invalidParam('ip', constants.POOL_IP_MSG));
+        callback(errors.invalidParam('ip', constants.POOL_IP_MSG));
+        return;
     }
 
-    if (params.hasOwnProperty('network_uuid') &&
-        !parsedParams.hasOwnProperty('network')) {
-        // network validation has failed - we've already returned an invalid
-        // parameter error
-        return callback();
+    if (parsedParams.network) {
+        cErr = checkNetwork(parsedParams, 'network_uuid', parsedParams.network);
+        if (cErr !== null) {
+            callback(cErr);
+            return;
+        }
     }
 
-    // If the networks has owner_uuids, make sure we match one of them (or
-    // the UFDS admin UUID). Don't check if check_owner is set to false.
-    if (parsedParams.network && parsedParams.owner_uuid &&
-        (!parsedParams.hasOwnProperty('check_owner') ||
-        parsedParams.check_owner) &&
-        !parsedParams.network.isOwner(parsedParams.owner_uuid)) {
-        return callback(errors.invalidParam('owner_uuid',
-            constants.OWNER_MATCH_MSG));
+    if (!parsedParams.ip) {
+        callback();
+        return;
     }
 
-    // network_uuid and ip were specified, so just validate
-    if (parsedParams.ip && parsedParams.network) {
-        return validateSubnetContainsIP(opts, parsedParams, callback);
+    function saveIP(err, _ip) {
+        parsedParams._ip = _ip;
+        callback(err);
     }
 
-    if (!parsedParams.ip) {
-        return callback();
+    // network_uuid and ip were specified, so just validate
+    if (parsedParams.ip && parsedParams.network) {
+        validateSubnetContainsIP(opts, 'ip',
+            parsedParams.network, parsedParams.ip, saveIP);
+        return;
     }
 
-    // ip specified, but not network_uuid: vlan_id and nic_tag are needed to
-    // figure out what network the nic is on
+    // IP specified, but no network UUID: vlan_id and nic_tag are needed to
+    // figure out what network the NIC is on.
     var errs = [];
     ['nic_tag', 'vlan_id'].forEach(function (p) {
-        if (!parsedParams.hasOwnProperty('vlan_id')) {
+        if (!parsedParams.hasOwnProperty(p)) {
             errs.push(errors.missingParam(p, constants.msg.IP_NO_VLAN_TAG));
         }
     });
 
     if (errs.length !== 0) {
-        return callback(errs);
+        callback(errs);
+        return;
     }
 
-    var query = {
-        vlan_id: parsedParams.vlan_id,
-        nic_tag: parsedParams.nic_tag
-    };
+    lookupUnknownIP(opts, parsedParams, 'ip', parsedParams.ip, saveIP);
+}
+
+
+function lookupUnknownIP(opts, parsedParams, name, unknownIP, callback) {
+    var vlan_id = parsedParams.vlan_id;
+    var vnet_id = parsedParams.vnet_id || null;
+    var nic_tag = parsedParams.nic_tag;
 
-    return mod_net.list({ app: app, log: log, params: query },
-            function (err, res) {
+    mod_net.findContaining(opts, vlan_id, nic_tag, vnet_id, unknownIP,
+        function (err, uuids) {
         if (err) {
-            return callback(err);
+            callback(err);
+            return;
+        }
+
+        if (uuids.length === 0) {
+            callback(errors.invalidParam(name,
+                util.format(constants.fmt.IP_NONET, nic_tag, vlan_id,
+                unknownIP)));
+            return;
         }
 
-        if (res.length === 0) {
-            return callback(['nic_tag', 'vlan_id'].map(function (p) {
-                return errors.invalidParam(p,
-                'No networks found matching parameters');
-            }));
+        if (uuids.length > 1) {
+            callback(errors.invalidParam(name,
+                util.format(constants.fmt.IP_MULTI, uuids.sort().join(', '),
+                unknownIP)));
+            return;
         }
 
-        /*
-         * Handle the case where we have multiple subnets on one vlan ID
-         * by checking that our address is within one of the found networks.
-         */
-
-        vasync.forEachPipeline({
-            func: function (network, cb) {
-                parsedParams.network = network;
-                parsedParams.network_uuid = network.uuid;
-                validateSubnetContainsIP(opts, parsedParams, function (e) {
-                    if (e) {
-                        /*
-                         * Only InvalidParameter errors indicate that the IP
-                         * didn't match this network: others (such as duped
-                         * IP errors), we should bubble upwards.
-                         */
-                        if (e.code === 'InvalidParameter') {
-                            cb(null, { input: network, result: false });
-                            return;
-                        }
-                        cb(e);
-                        return;
-                    }
-                    cb(null, { input: network, result: true });
-                });
-            },
-            inputs: res
-        }, function (err2, res2) {
+        opts.network_cache.get(uuids[0], function (err2, network) {
             if (err2) {
-                /* If we can, simplify this down to a single error. */
-                if (err2.ase_errors && err2.ase_errors.length === 1) {
-                    return (callback(err2.ase_errors[0]));
-                }
-                return (callback(err2));
+                callback(err2);
+                return;
             }
 
-            var contained = res2.operations.filter(function (op) {
-                return (typeof (op.result) === 'object' &&
-                    op.result.result === true);
-            }).map(function (op) {
-                return (op.result.input);
-            });
-            if (contained.length < 1) {
-                return (callback(errors.invalidParam('ip', util.format(
-                    constants.fmt.IP_NONET, parsedParams.nic_tag,
-                    parsedParams.vlan_id, parsedParams.ip))));
-            }
-            if (contained.length > 1) {
-                var uuids = contained.map(function (n) { return (n.uuid); });
-                return (callback(errors.invalidParam('ip', util.format(
-                    constants.fmt.IP_MULTI, uuids.join(', '),
-                    parsedParams.ip))));
+            err2 = checkNetwork(parsedParams, name, network);
+            if (err2 !== null) {
+                callback(err2);
+                return;
             }
-            parsedParams.network = contained[0];
-            parsedParams.network_uuid = contained[0].uuid;
-            return (callback(null));
+
+            validateSubnetContainsIP(opts, name, network, unknownIP, callback);
         });
     });
 }
@@ -385,7 +399,8 @@ function listVnetCns(opts, callback) {
         }
 
         var vnetCns = Object.keys(cns.reduce(function (acc, cn) {
-            acc[cn.cn_uuid] = true; return acc;
+            acc[cn.cn_uuid] = true;
+            return acc;
         }, {}));
 
         opts.log.debug({ vnetCns: vnetCns }, 'listVnetCns: exit');
diff --git a/lib/models/nic/create.js b/lib/models/nic/create.js
index aeb0a90..b0ce442 100644
--- a/lib/models/nic/create.js
+++ b/lib/models/nic/create.js
@@ -15,6 +15,7 @@
 'use strict';
 
 var common = require('./common');
+var mod_net = require('../network');
 var mod_nicTag = require('../nic-tag');
 var provision = require('./provision');
 var validate = require('../../util/validate');
@@ -68,6 +69,7 @@ function validateParams(opts, callback) {
     var copts = {
         app: opts.app,
         log: opts.log,
+        network_cache: new mod_net.NetworkCache(opts.app, opts.log),
         create: true
     };
 
@@ -120,10 +122,7 @@ function create(opts, callback) {
             provision.nicAndIP
         ]
     }, function (err) {
-        if (err) {
-            return callback(err);
-        }
-        return callback(null, opts.nic);
+        callback(err, opts.nic);
     });
 }
 
diff --git a/lib/models/nic/del.js b/lib/models/nic/del.js
index bc08b47..0a1a425 100644
--- a/lib/models/nic/del.js
+++ b/lib/models/nic/del.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright 2016, Joyent, Inc.
+ * Copyright 2017, Joyent, Inc.
  */
 
 /*
@@ -16,7 +16,6 @@
 
 var common = require('./common');
 var getNic = require('./get').get;
-var mod_ip = require('../ip');
 var validate = require('../../util/validate');
 var vasync = require('vasync');
 
@@ -67,45 +66,33 @@ function addNicToBatch(opts, cb) {
     return cb();
 }
 
-function delIP(opts, cb) {
-    // XXX: Add the rest of this to the batch above as well!
-
+function delIPs(opts, callback) {
     if (!opts.existingNic || !opts.existingNic.ip) {
-        opts.log.debug('nic: delete: nic "%s" has no IP', opts.params.mac);
-        return cb();
+        opts.log.debug('nic: delete: nic "%s" has no IPs', opts.params.mac);
+        callback();
+        return;
     }
 
-    if (opts.existingNic.ip.params.belongs_to_uuid !==
-        opts.existingNic.params.belongs_to_uuid) {
-        opts.log.debug({ mac: opts.params.mac,
-            ip: opts.existingNic.ip.address },
-            'nic: delete: IP and nic belongs_to_uuid do not match');
-        return cb();
-    }
+    vasync.forEachParallel({
+        'inputs': [ opts.existingNic.ip ],
+        'func': delIP.bind(null, opts)
+    }, callback);
+}
 
-    // XXX: may want some way to override this and force the delete
-    if (opts.existingNic.ip.params.reserved) {
-        opts.log.debug('nic: delete: nic "%s" has a reserved IP',
-            opts.params.mac);
-        return mod_ip.update(opts.app, opts.log, {
-            ip: opts.existingNic.ip.address,
-            network: opts.existingNic.network,
-            network_uuid: opts.existingNic.network.params.uuid,
-            belongs_to_uuid:
-            opts.existingNic.ip.params.belongs_to_uuid,
-            belongs_to_type:
-            opts.existingNic.ip.params.belongs_to_type,
-            unassign: true
-        }, cb);
 
+function delIP(opts, ip, cb) {
+    if (ip.params.belongs_to_uuid === opts.existingNic.params.belongs_to_uuid) {
+        opts.batch.push(ip.unassignBatch());
     } else {
-        opts.log.debug('nic: delete: nic "%s": deleting IP', opts.params.mac);
-        return mod_ip.del(opts.app, opts.log, {
-            network: opts.existingNic.network,
-            network_uuid: opts.existingNic.network.uuid,
-            ip: opts.existingNic.ip.address
-        }, cb);
+        opts.log.warn({
+            nic_owner: opts.existingNic.params.belongs_to_uuid,
+            ip_owner: ip.params.belongs_to_uuid,
+            mac: opts.params.mac,
+            ip: ip.address
+        }, 'nic: delete: IP and NIC belongs_to_uuid do not match');
     }
+
+    cb();
 }
 
 
@@ -122,17 +109,19 @@ function del(opts, callback) {
     vasync.pipeline({
         arg: opts,
         funcs: [
-        validateDeleteParams,
-        getExistingNic,
-        listVnetCns,
-        addNicToBatch,
-        common.commitBatch,
-        delIP
-    ]}, function (err) {
+            validateDeleteParams,
+            getExistingNic,
+            listVnetCns,
+            addNicToBatch,
+            delIPs,
+            common.commitBatch
+        ]
+    }, function (err) {
         if (err) {
             opts.log.error(err, 'nic: delete: error');
         }
-        return callback(err);
+
+        callback(err);
     });
 }
 
diff --git a/lib/models/nic/obj.js b/lib/models/nic/obj.js
index acb7e87..85355d9 100644
--- a/lib/models/nic/obj.js
+++ b/lib/models/nic/obj.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2015, Joyent, Inc.
+ * Copyright 2017, Joyent, Inc.
  */
 
 /*
@@ -173,6 +173,7 @@ function Nic(params) {
     assert.optionalString(params.model, 'model');
     assert.optionalString(params.nic_tag, 'nic_tag');
     assert.optionalString(params.state, 'state');
+    assert.optionalString(params.ipaddr, 'ipaddr');
 
     params.state = params.state || constants.DEFAULT_NIC_STATE;
 
@@ -211,10 +212,15 @@ function Nic(params) {
         this.etag = null;
     }
 
+    this.ip = null;
+    this.network = null;
+
     if (params.hasOwnProperty('primary') &&
         typeof (params.primary) !== 'boolean') {
         this.params.primary = params.primary === 'true' ? true : false;
     }
+
+    Object.seal(this);
 }
 
 Object.defineProperty(Nic.prototype, 'mac', {
@@ -282,11 +288,6 @@ Nic.prototype.batch = function nicBatch(opts) {
             vnet_id: this.network.vnet_id
         }));
 
-        // Poor factoring of the create/update code means that this
-        // section is a no-op for updates of type 'update', which are instead
-        // created in update#updateParams - specifically, opts.vnetCns will
-        // be empty here in that case. This section does cover nic creation
-        // and updates of type 'provision'.
         var _vl3batch = mod_portolan_moray.vl3CnEventBatch({
             vnetCns: opts.vnetCns,
             vnet_id: this.network.vnet_id,
diff --git a/lib/models/nic/provision.js b/lib/models/nic/provision.js
index 4a7ee71..18833f3 100644
--- a/lib/models/nic/provision.js
+++ b/lib/models/nic/provision.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2015, Joyent, Inc.
+ * Copyright 2017, Joyent, Inc.
  */
 
 /*
@@ -15,133 +15,281 @@
 'use strict';
 
 var assert = require('assert-plus');
-var clone = require('clone');
 var common = require('./common');
 var constants = require('../../util/constants');
 var errors = require('../../util/errors');
 var mod_ip = require('../ip');
-var mod_net = require('../network');
+var mod_portolan_moray = require('portolan-moray');
 var Nic = require('./obj').Nic;
 var restify = require('restify');
 var util = require('util');
 var util_common = require('../../util/common');
 var util_mac = require('../../util/mac');
 var vasync = require('vasync');
+var VError = require('verror');
 
 
 
 // --- Internal functions
 
 
+/**
+ * If we have an existing NIC and it has provisioned IP addresses,
+ * check if it contains any addresses that we're no longer using,
+ * and free them.
+ */
+function freeOldIPs(opts, callback) {
+    if (!opts._removeIPs) {
+        callback();
+        return;
+    }
+
+    assert.object(opts.existingNic, 'opts.existingNic');
+
+    var mac = opts.existingNic.mac;
+    var cn_uuid = opts.existingNic.params.cn_uuid;
+
+    opts._removeIPs.forEach(function (oldIP) {
+        opts.batch.push(oldIP.unassignBatch());
+    });
+
+    /*
+     * If we're on a fabric NIC, then we need to update the Portolan entry for
+     * the IPs to mark them as deleted, and generate the appropriate VL3
+     * shootdowns, to indicate that they aren't mapped to the same NIC anymore.
+     */
+    if (opts.existingNic.isFabric()) {
+        opts._removeIPs.forEach(function (oldIP) {
+            var vlan_id = oldIP.params.network.params.vlan_id;
+            var vnet_id = oldIP.params.network.params.vnet_id;
+            var v6addr = oldIP.v6address;
+
+            var vl3batch = mod_portolan_moray.vl3CnEventBatch({
+                vnetCns: opts.vnetCns,
+                vnet_id: vnet_id,
+                ip: v6addr,
+                mac: mac,
+                vlan_id: vlan_id
+            });
+
+            vl3batch.push(mod_portolan_moray.overlayMappingBatch({
+                cn_uuid: cn_uuid,
+                deleted: true,
+                ip: v6addr,
+                mac: mac,
+                vnet_id: vnet_id
+            }));
+
+            opts.batch = opts.batch.concat(vl3batch);
+        });
+    }
+
+    callback();
+}
+
+
+function Provisioner() { }
 
 /**
- * Calls the next IP provisioning function, but prevents stop errors
- * from stopping the provisioning loop.
+ * Grab the next available IP address on the currently selected network.
  */
-function addNextIP(opts, callback) {
-    mod_ip.nextIPonNetwork(opts, function (err) {
-        if (err && err.stop) {
-            delete err.stop;
+Provisioner.prototype.fetchNextIP =
+    function fetchNextIP(opts, dontStop, callback) {
+    var self = this;
+    assert.object(self.network, 'Network selected');
+    mod_ip.nextIPonNetwork(opts, self.network, function (err, ip) {
+        if (err) {
+            if (dontStop && err.stop) {
+                delete err.stop;
+            }
+            callback(err);
+            return;
         }
 
-        return callback(err);
+        self.ip = ip;
+        self.batchIP(opts, callback);
     });
-}
+};
 
 
 /**
- * Provision a specific IP on a network
+ * Push the selected IP address and its batched form into nicAndIP's arrays.
  */
-function ipOnNetwork(opts, callback) {
-    assert.object(opts.ipParams, 'opts.ipParams');
+Provisioner.prototype.batchIP = function batchCurIP(opts, callback) {
+    assert.ok(this.ip, 'IP selected');
+    opts.ips.push(this.ip);
+    opts.batch.push(this.ip.batch());
+    callback();
+};
 
-    var params = opts.validated;
-    var ipBucket = mod_ip.bucket(params.network_uuid);
 
-    if (opts.ip && opts.err && opts.err.context &&
-        opts.err.context.bucket === ipBucket.name) {
+/**
+ * If there was a previous error, check if it was because of our chosen IP.
+ */
+Provisioner.prototype.haveEtagFailure = function checkEtagFail(err) {
+    if (!err) {
+        // No error yet.
+        return false;
+    }
+
+    if (this.ip === null) {
+        // We haven't selected an IP yet.
+        return false;
+    }
+
+    var cause = VError.findCauseByName(err, 'EtagConflictError');
+    if (cause === null) {
+        return false;
+    }
+
+    var key = this.ip.key();
+    var bucket = mod_ip.bucketName(this.network.uuid);
+    return (cause.context.bucket === bucket && cause.context.key === key);
+};
+
+
+/**
+ * Provisioner for handling specifically requested IP addresses.
+ */
+function IPProvision(ip, field) {
+    this.ip = ip;
+    this.network = ip.params.network;
+    this.field = field;
+
+    Object.seal(this);
+}
+util.inherits(IPProvision, Provisioner);
+
+
+IPProvision.prototype.provision = function provisionIP(opts, callback) {
+    if (this.haveEtagFailure(opts.err)) {
+        var usedIP = this.ip.address.toString();
+        var usedNet = this.network.uuid;
+        var usedMsg = util.format(constants.fmt.IP_EXISTS, usedIP, usedNet);
         var usedErr = new errors.InvalidParamsError(
             constants.msg.INVALID_PARAMS,
-            [ errors.duplicateParam('ip', util.format(
-                constants.fmt.IP_EXISTS, params.network_uuid)) ]);
+            [ errors.duplicateParam(this.field, usedMsg) ]);
         usedErr.stop = true;
-        return callback(usedErr);
+        callback(usedErr);
+    } else {
+        this.batchIP(opts, callback);
     }
+};
 
-    if (opts.ipParams.hasOwnProperty('_ip')) {
-        // The IP already exists in moray, but isn't taken by someone else
-        opts.ip = mod_ip.createUpdated(opts.ipParams._ip, opts.ipParams);
+
+/**
+ * Provisioner for finding available IPs on requested networks.
+ */
+function NetworkProvision(network) {
+    assert.object(network, 'network');
+
+    this.ip = null;
+    this.network = network;
+
+    Object.seal(this);
+}
+util.inherits(NetworkProvision, Provisioner);
+
+
+NetworkProvision.prototype.provision = function provisionNet(opts, callback) {
+    if (this.ip === null || this.haveEtagFailure(opts.err)) {
+        // We haven't chosen an IP yet, or the previous one was taken
+        // by someone else.
+        this.fetchNextIP(opts, false, callback);
     } else {
-        opts.ip = new mod_ip.IP(opts.ipParams);
+        // Reuse the already selected IP.
+        this.batchIP(opts, callback);
     }
+};
+
+
+/**
+ * Provisioner for finding IPs on networks in a given pool.
+ */
+function NetworkPoolProvision(pool, field) {
+    assert.object(pool, 'pool');
+    assert.string(field, 'field');
 
-    opts.batch.push(opts.ip.batch());
+    this.ip = null;
+    this.network = null;
+    this.pool = pool;
+    this.field = field;
+    this.pools = pool.params._networks.slice();
 
-    return callback();
+    Object.seal(this);
 }
+util.inherits(NetworkPoolProvision, Provisioner);
 
 
 /**
- * Provision an IP on a network pool
+ * Move on to the next network pool, and provision an IP from it.
  */
-function ipOnNetworkPool(opts, callback) {
-    var params = opts.validated;
-
-    if (!opts.poolUUIDs) {
-        opts.poolUUIDs = clone(params.network_pool.networks);
-        opts.log.debug({ poolUUIDs: opts.poolUUIDs },
-            'ipOnNetworkPool: network list');
+NetworkPoolProvision.prototype.nextNetwork =
+    function nextNetworkPool(opts, callback) {
+    var next = this.pools.shift();
+    if (!next) {
+        var fullErr = new errors.InvalidParamsError('Invalid parameters',
+            [ errors.invalidParam(this.field,
+                constants.POOL_FULL_MSG) ]);
+        fullErr.stop = true;
+        callback(fullErr);
+        return;
     }
 
-    var haveNetErr = (opts.err && opts.err.context ===
-        mod_ip.bucketName(params.network_uuid));
+    opts.log.debug({ nextUUID: next.uuid }, 'Trying next network in pool');
+
+    this.network = next;
+    this.fetchNextIP(opts, true, callback);
+};
 
-    // We've been through this function before, but the problem wasn't us -
-    // just allow nextIPonNetwork() to handle things
-    if (params.network && !haveNetErr) {
-        return addNextIP(opts, callback);
+
+/**
+ * Check if we've failed a provision on the currently selected network.
+ */
+NetworkPoolProvision.prototype.haveNetFailure = function (err) {
+    if (!err) {
+        // No error yet.
+        return false;
     }
 
-    if (!params.network || haveNetErr) {
-        var nextUUID = opts.poolUUIDs.shift();
-        if (!nextUUID) {
-            var fullErr = new errors.InvalidParamsError('Invalid parameters',
-                [ errors.invalidParam('network_uuid',
-                    constants.POOL_FULL_MSG) ]);
-            fullErr.stop = true;
-            return callback(fullErr);
-        }
+    if (err.name !== 'SubnetFullError') {
+        return false;
+    }
 
-        opts.log.debug({ nextUUID: nextUUID }, 'Trying next network in pool');
+    return (err.network_uuid === this.network.uuid);
+};
 
-        var netGetOpts = {
-            app: opts.app,
-            log: opts.log,
-            params: { uuid: nextUUID }
-        };
-        return mod_net.get(netGetOpts, function (err, res) {
-            if (err) {
-                opts.log.error(err, 'provisionIPonNetworkPool: error getting ' +
-                    'network %s', nextUUID);
-                return callback(err);
-            }
 
-            // Add the correct network params to the provisioning params
-            // object:
-            opts.validated.network = res;
-            opts.validated.network_uuid = res.uuid;
-            opts.ipParams = mod_ip.params(opts.validated);
+NetworkPoolProvision.prototype.provision =
+    function provisionPool(opts, callback) {
 
-            // XXX: reset IP properties here
-            // XXX: refactor into a mod_ip.removeIPproperties?
-            delete opts.ipProvisionTries;
-            delete opts.noMoreGapIPs;
+    if (this.network === null || this.haveNetFailure(opts.err)) {
+        // We haven't selected a network, or the chosen one is full.
+        this.nextNetwork(opts, callback);
+    } else if (this.ip === null || this.haveEtagFailure(opts.err)) {
+        // Our selected IP has been taken: pick another
+        this.fetchNextIP(opts, true, callback);
+    } else {
+        // Our current selection is fine, try it again
+        this.batchIP(opts, callback);
+    }
+};
 
-            return addNextIP(opts, callback);
-        });
+
+/**
+ * Test if we've failed to provision a new NIC due to a conflict in MAC address.
+ */
+function nicEtagFail(err) {
+    if (!err) {
+        return false;
     }
 
-    return addNextIP(opts, callback);
+    var cause = VError.findCauseByName(err, 'EtagConflictError');
+    if (cause === null) {
+        return false;
+    }
+
+    return (cause.context.bucket === common.BUCKET.name);
 }
 
 
@@ -156,26 +304,22 @@ function macSupplied(opts, callback) {
 
     opts.log.debug({}, 'macSupplied: enter');
 
-    if (opts.nic && opts.err && opts.err.context &&
-        opts.err.context.bucket === common.BUCKET.name) {
-
+    if (opts.nic && nicEtagFail(opts.err)) {
         var usedErr = new errors.InvalidParamsError(
             constants.msg.INVALID_PARAMS, [ errors.duplicateParam('mac') ]);
         usedErr.stop = true;
-        return callback(usedErr);
+        callback(usedErr);
+        return;
     }
 
     opts.nic = new Nic(opts.validated);
-    if (opts.ip) {
-        opts.nic.ip = opts.ip;
-        opts.nic.network = opts.validated.network;
+    if (opts.ips.length > 0) {
+        assert.equal(opts.ips.length, 1, 'opts.ips.length === 1');
+        opts.nic.ip = opts.ips[0];
+        opts.nic.network = opts.nic.ip.params.network;
     }
 
-    if (opts.nic.isFabric() && opts.vnetCns) {
-        opts.nic.vnetCns = opts.vnetCns;
-    }
-
-    return callback();
+    callback();
 }
 
 
@@ -194,26 +338,29 @@ function randomMAC(opts, callback) {
 
     // If we've already supplied a MAC address and the error isn't for our
     // bucket, we don't need to generate a new MAC - just re-add the existing
-    // nic to the batch
-    if (validated.mac && (!opts.err || !opts.err.hasOwnProperty('context') ||
-        opts.err.context.bucket !== 'napi_nics')) {
-
+    // NIC to the batch.
+    if (validated.mac && !nicEtagFail(opts.err)) {
         opts.nic = new Nic(validated);
-        if (opts.ip) {
-            opts.nic.ip = opts.ip;
-            opts.nic.network = opts.validated.network;
+        if (opts.ips.length > 0) {
+            assert.equal(opts.ips.length, 1, 'opts.ips.length === 1');
+            opts.nic.ip = opts.ips[0];
+            opts.nic.network = opts.nic.ip.params.network;
         }
 
-        return callback();
+        callback();
+        return;
     }
 
     if (opts.macTries > constants.MAC_RETRIES) {
-        opts.log.error({ start: opts.startMac, num: validated.mac,
-            tries: opts.macTries },
-            'Could not provision nic after %d tries', opts.macTries);
+        opts.log.error({
+            start: opts.startMac,
+            num: validated.mac,
+            tries: opts.macTries
+        }, 'Could not provision nic after %d tries', opts.macTries);
         var err = new restify.InternalError('no more free MAC addresses');
         err.stop = true;
-        return callback(err);
+        callback(err);
+        return;
     }
 
     opts.macTries++;
@@ -236,13 +383,14 @@ function randomMAC(opts, callback) {
     }
 
     opts.nic = new Nic(validated);
-    if (opts.ip) {
-        opts.nic.ip = opts.ip;
-        opts.nic.network = opts.validated.network;
+    if (opts.ips.length > 0) {
+        assert.equal(opts.ips.length, 1, 'opts.ips.length === 1');
+        opts.nic.ip = opts.ips[0];
+        opts.nic.network = opts.nic.ip.params.network;
     }
 
     opts.log.debug({}, 'randomMAC: exit');
-    return callback();
+    callback();
 }
 
 
@@ -256,11 +404,8 @@ function randomMAC(opts, callback) {
  */
 function addParams(opts, callback) {
     opts.nicFn = opts.validated.mac ? macSupplied : randomMAC;
-    opts.ipParams = mod_ip.params(opts.validated);
-    if (opts.validated.hasOwnProperty('_ip')) {
-        opts.ipParams._ip = opts.validated._ip;
-    }
-    return callback();
+    opts.baseParams = mod_ip.params(opts.validated);
+    callback();
 }
 
 /**
@@ -272,10 +417,23 @@ function addNicToBatch(opts) {
         vnetCns: opts.vnetCns,
         ip: opts.nic.ip ? opts.nic.ip.v6address : 'none'
     }, 'addNicToBatch: entry');
+
     opts.batch = opts.batch.concat(opts.nic.batch({
-       log: opts.log,
-       vnetCns: opts.vnetCns
+        log: opts.log,
+        vnetCns: opts.vnetCns
     }));
+
+    if (opts.shootdownNIC) {
+        assert.object(opts.existingNic, 'opts.existingNic');
+        assert.ok(opts.existingNic.isFabric(), 'opts.existingNic.isFabric()');
+
+        opts.batch = opts.batch.concat(mod_portolan_moray.vl2CnEventBatch({
+            log: opts.log,
+            vnetCns: opts.vnetCns,
+            vnet_id: opts.existingNic.network.vnet_id,
+            mac: opts.existingNic.mac
+        }));
+    }
 }
 
 
@@ -283,28 +441,30 @@ function addNicToBatch(opts) {
  * If the network provided is a fabric network, fetch the list of CNs also
  * on that fabric network, for the purpose of SVP log generation.
  */
-function listVnetCns(opts, cb) {
-    var network = opts.validated.network;
+function listVnetCns(opts, callback) {
+    assert.array(opts.ips, 'ips');
 
-    // we don't always have a network upon creation
-    if (!network || !network.fabric) {
-        return cb(null);
+    // We aren't on any fabric networks.
+    if (opts.ips.length === 0 || !opts.ips[0].params.network.fabric) {
+        callback(null);
+        return;
     }
 
     var listOpts = {
         moray: opts.app.moray,
         log: opts.log,
-        vnet_id: network.vnet_id
+        vnet_id: opts.ips[0].params.network.vnet_id
     };
 
     common.listVnetCns(listOpts, function (listErr, vnetCns) {
         if (listErr) {
-            return cb(listErr);
+            callback(listErr);
+            return;
         }
 
         opts.log.debug({ vnetCns: vnetCns }, 'provision.listVnetCns exit');
         opts.vnetCns = vnetCns;
-        return cb(null);
+        callback(null);
     });
 }
 
@@ -317,84 +477,126 @@ function nicBatch(opts, cb) {
     return cb();
 }
 
+
+function runProvisions(opts, provisioners, callback) {
+    vasync.forEachPipeline({
+        inputs: provisioners,
+        func: function (provisioner, cb) {
+            provisioner.provision(opts, cb);
+        }
+    }, callback);
+}
+
+
 /**
- * Provisions a nic and optional IP - contains a critical section that ensures
- * via retries that ips (and, less likely, MACs) are not duplicated.
+ * Provisions a NIC and optional IPs. This code uses Moray etags on each object
+ * it creates/updates inside its .batch() to avoid conflicting with concurrent
+ * requests. If a conflict occurs, the provision attempt is restarted, and new
+ * IPs or MAC addresses selected as needed.
  *
  * @param opts {Object}:
- * - ipParams {Object}: parameters used for creating the IP (required)
+ * - baseParams {Object}: parameters used for creating the IP
  * - nicFn {Function}: function that populates opts.nic
  */
 function nicAndIP(opts, callback) {
-    assert.object(opts.ipParams, 'opts.ipParams');
-    assert.ok(opts.nicFn, 'opts.nicFn');
+    assert.object(opts.baseParams, 'opts.baseParams');
+    assert.func(opts.nicFn, 'opts.nicFn');
 
-    var funcs = [ ];
+    var retries = 0;
     var params = opts.validated;
 
-    if (params.network_pool) {
-        funcs.push(ipOnNetworkPool);
+    var provisioners = [];
+
+    if (params._ip) {
+        // Want a specific IP
+        var updated = mod_ip.createUpdated(params._ip, opts.baseParams);
+        provisioners.push(new IPProvision(updated, 'ip'));
+    } else if (params.network_pool) {
+        provisioners.push(
+            new NetworkPoolProvision(params.network_pool, 'network_uuid'));
     } else if (params.network) {
-        if (params.ip) {
-            // Want a specific IP
-            funcs.push(ipOnNetwork);
-        } else {
-            // Just provision the next IP on the network
-            funcs.push(mod_ip.nextIPonNetwork);
-        }
+        // Just provision the next IP on the network
+        provisioners.push(
+            new NetworkProvision(params.network, 'network_uuid'));
     }
 
     opts.log.debug({
         nicProvFn: opts.nicFn.name,
         // We could only be provisioning a nic:
-        ipProvFn: funcs.length === 0 ? 'none' : funcs[0].name,
-        ipParams: opts.ipParams,
+        ipProvFn: provisioners.length === 0 ? 'none' : 'some',
+        baseParams: opts.baseParams,
         validated: opts.validated,
         vnetCns: opts.vnetCns || 'none'
     }, 'provisioning nicAndIP');
 
-    // locates the vnetCns in the create and update/provision code paths.
-    funcs.push(listVnetCns);
-
-    // This function needs to go after the IP provisioning functions in the
-    // chain, as the nic needs a pointer to what IP address it has
-    funcs.push(opts.nicFn);
-
-    funcs.push(nicBatch);
-
-    funcs.push(common.commitBatch);
-
     util_common.repeat(function (cb) {
-        // Reset opts.batch - it is the responsibility for functions in the
-        // pipeline to re-add their batch data each time through the loop
+        // Reset opts.{batch,ips} - it is the responsibility for functions in
+        // the pipeline to re-add their batch data each time through the loop.
         opts.batch = [];
+        opts.ips = [];
 
         vasync.pipeline({
             arg: opts,
-            funcs: funcs
+            funcs: [
+                // 1. Determine what IPs to provision and batch them.
+                function (_, cb2) { runProvisions(opts, provisioners, cb2); },
+
+                // 2. Locate the CNs we need to inform of overlay IP changes.
+                listVnetCns,
+
+                // 3. Free any addresses we no longer need.
+                freeOldIPs,
+
+                // 4. Using our IPs, create the NIC object.
+                opts.nicFn,
+
+                // 5. Batch the NIC.
+                nicBatch,
+
+                // 6. Commit everything in our batch.
+                common.commitBatch
+            ]
         }, function (err) {
             if (err) {
                 opts.log.warn({ err: err, final: err.stop }, 'error in repeat');
-                if (err.stop) {
+                if (err.stop || retries > constants.NIC_PROVISION_RETRIES) {
                     // No more to be done:
-                    return cb(err, null, false);
+                    cb(err, null, false);
+                    return;
                 }
 
-                // Need to retry. Set opts.err so the functions in funcs
-                // can determine if they need to change their params
+                /*
+                 * Unfortunately we don't have a great way to classify errors
+                 * here, so we can't really tell what's fatal/non-fatal. Most
+                 * errors are non-fatal (EtagConflictErrors, errors connecting
+                 * to Moray, Moray errors connecting to Postgres, etc.), so we
+                 * retry. We limit the number of retries that we do so that we
+                 * not only eventually terminate, but also avoid running up the
+                 * Postgres sequence that Moray uses on each bucket.
+                 */
+                retries += 1;
+
+                /*
+                 * Save the error so that the pipeline functions can determine
+                 * if they need to select new values for the provision.
+                 */
                 opts.err = err;
-                return cb(null, null, true);
+
+                cb(null, null, true);
+                return;
             }
-            return cb(null, opts.nic, false);
+
+            cb(null, opts.nic, false);
         });
     }, function (err, res) {
         if (err) {
-            return callback(err);
+            callback(err);
+            return;
         }
 
         opts.log.info({ params: params, obj: res.serialize() }, 'Created nic');
 
-        return callback(null, res);
+        callback(null, res);
     });
 }
 
diff --git a/lib/models/nic/update.js b/lib/models/nic/update.js
index 45de1fe..15d6370 100644
--- a/lib/models/nic/update.js
+++ b/lib/models/nic/update.js
@@ -20,8 +20,8 @@ var constants = require('../../util/constants');
 var errors = require('../../util/errors');
 var getNic = require('./get').get;
 var mod_ip = require('../ip');
+var mod_net = require('../network');
 var mod_nicTag = require('../nic-tag');
-var mod_portolan_moray = require('portolan-moray');
 var Nic = require('./obj').Nic;
 var provision = require('./provision');
 var util = require('util');
@@ -89,13 +89,16 @@ var UPDATE_SCHEMA = {
 
     after: [
         function (opts, original, parsed, cb2) {
-            // Only add the old IP's network if we're not
-            // updating to a new network
-            assert.object(opts.existingNic);
-            if (!parsed.hasOwnProperty('network') && opts.existingNic &&
-                opts.existingNic.hasOwnProperty('network')) {
-                parsed.network = opts.existingNic.network;
-                parsed.network_uuid = opts.existingNic.network.uuid;
+            assert.object(opts.existingNic, 'existingNic');
+            var oldNIC = opts.existingNic;
+
+            if (!parsed.hasOwnProperty('ip') && oldNIC.ip !== null) {
+                parsed._ip = oldNIC.ip;
+            }
+
+            if (!parsed.hasOwnProperty('network') && oldNIC.network !== null) {
+                parsed.network = oldNIC.network;
+                parsed.network_uuid = oldNIC.network.uuid;
             }
 
             common.validateNetworkParams(opts, original, parsed, cb2);
@@ -118,43 +121,17 @@ function addUpdatedNic(opts, callback) {
         opts.nic = new Nic(getUpdatedNicParams(opts));
     } catch (nicErr) {
         // XXX: wrap this error with WError
-        return callback(nicErr);
+        callback(nicErr);
+        return;
     }
 
-    opts.nic.ip = opts.ip;
-    opts.nic.network = opts.validated.network;
-
-    return callback();
-}
-
-
-/**
- * Used the updated parameters in opts.validated to create a new opts.nic
- * and opts.ip, and adds them to opts.batch
- */
-function addNicAndIPtoBatch(opts, ipObj, network) {
-    var newIP;
-
-    try {
-        opts.nic = new Nic(getUpdatedNicParams(opts));
-    } catch (nicErr) {
-        // XXX: wrap this error with WError
-        throw nicErr;
+    if (opts.ips.length > 0) {
+        assert.equal(opts.ips.length, 1, 'opts.ips.length === 1');
+        opts.nic.ip = opts.ips[0];
+        opts.nic.network = opts.nic.ip.params.network;
     }
 
-    if (ipObj) {
-        // Use the new nic's params to populate the new IP: this ensures
-        // it gets any updated parameters
-        newIP = mod_ip.createUpdated(ipObj, opts.nic.params);
-        opts.nic.ip = newIP;
-        opts.nic.network = network;
-    }
-
-    provision.addNicToBatch(opts);
-
-    if (newIP) {
-        opts.batch.push(newIP.batch());
-    }
+    callback();
 }
 
 
@@ -202,186 +179,89 @@ function validateUpdateParams(opts, callback) {
         app: opts.app,
         log: opts.log,
         create: false,
+        network_cache: new mod_net.NetworkCache(opts.app, opts.log),
         existingNic: opts.existingNic
     };
 
     validate.params(UPDATE_SCHEMA, uopts, opts.params, function (err, res) {
         opts.validated = res;
 
-        if (opts.log.debug()) {
-            opts.log.debug({ validated: res }, 'validated params');
-        }
+        opts.log.trace({ validated: res }, 'validated params');
 
-        return callback(err);
+        callback(err);
     });
 }
 
-
-/**
- * Determine what sort of update type this is and set opts.updateType
- * accordingly, so that later functions in the update chain can run.
- */
-function setUpdateType(opts, callback) {
-    opts.log.trace('setUpdateType: entry');
-
-    var oldNic = opts.existingNic;
-    var oldIP = oldNic.params.ip;
-
-    opts.updateType = 'update';
-
-    if (!oldIP && opts.validated.network_uuid) {
-        // The nic didn't have an IP before, but we want one: let
-        // provisionIP() handle
-        opts.updateType = 'provision';
-        opts.log.debug({ updateType: opts.updateType }, 'update type');
-        return callback();
-    }
-
-    opts.log.debug({ updateType: opts.updateType }, 'update type');
-    return callback();
+function v6address(ip) {
+    return ip.v6address;
 }
 
-
 /**
- * If opts.updateType is 'provision', try to provision an IP with the
- * updated nic params
+ * Provision any new IPs that we need, free old ones, and update NIC properties.
  */
-function provisionIP(opts, callback) {
-    opts.log.trace('provisionIP: entry');
+function prepareUpdate(opts, callback) {
 
-    if (opts.updateType !== 'provision') {
-        return callback();
-    }
+    opts.log.trace('provisionIP: entry');
 
     opts.nicFn = addUpdatedNic;
-    opts.ipParams = mod_ip.params(getUpdatedNicParams(opts));
+    opts.baseParams = mod_ip.params(getUpdatedNicParams(opts));
 
-    var existingIP = opts.validated._ip;
-    if (existingIP && existingIP.provisionable()) {
-        // We're provisioning an existing IP, and it's OK to be provisioned:
-        // add _ip so that provision.ipOnNetwork() will use it
-        opts.ipParams._ip = existingIP;
+    if (!opts.validated.hasOwnProperty('_ip')) {
+        callback();
+        return;
     }
 
-    return provision.nicAndIP(opts, callback);
-}
-
-
-/**
- * If opts.update is 'update', update both the nic and IP. If changing IPs,
- * free the old one (but only if its ownership hasn't changed out from
- * under us).
- */
-function updateParams(opts, callback) {
-    opts.log.trace('updateParams: entry');
-
-    if (opts.updateType !== 'update') {
-        return callback();
+    var oldNIC = opts.existingNic;
+    var oldIPs = oldNIC.ip !== null ? [ oldNIC.ip ] : [];
+    var nicOwner = oldNIC.params.belongs_to_uuid;
+
+    var ips = [ opts.validated._ip ];
+
+    /*
+     * When the cn_uuid of a fabric NIC changes, we need to generate
+     * a shootdown so that CNs remove their now incorrect mappings.
+     */
+    var fabric = oldNIC.isFabric();
+    var oldCN = oldNIC.params.cn_uuid;
+    var newCN = opts.validated.cn_uuid;
+    if (fabric && newCN && oldCN !== newCN) {
+        opts.shootdownNIC = true;
     }
 
-    var newIP = opts.validated._ip;
-    var oldNic = opts.existingNic;
-    var oldIP = oldNic.ip;
-    var changingIP = false;
+    opts._removeIPs = [];
 
-    var paramIP = opts.existingNic.ip;
-    var paramNet = opts.existingNic.network;
+    var newAddrs = ips.map(v6address);
+    var oldAddrs = oldIPs.map(v6address);
 
-    if (oldIP && newIP &&
-        oldIP.address.toString() !== newIP.address.toString()) {
-        // We are changing the nic from one IP address to another
-        changingIP = true;
-        paramIP = newIP;
-        paramNet = opts.validated.network;
+    oldIPs.forEach(function (oldIP) {
+        // Avoid freeing if IP ownership has changed underneath us.
+        if (newAddrs.indexOf(oldIP.v6address) === -1 &&
+            nicOwner === oldIP.params.belongs_to_uuid) {
+            opts._removeIPs.push(oldIP);
+        }
+    });
+
+    // Check that all IPs we're adding are okay to use.
+    vasync.forEachPipeline({
+        'inputs': ips.filter(function (newIP) {
+            return (oldAddrs.indexOf(newIP.v6address) === -1);
+        }),
+        'func': function (ip, cb) {
+            if (ip.provisionable()) {
+                cb();
+                return;
+            }
 
-        if (oldIP.params.hasOwnProperty('belongs_to_uuid') &&
-            newIP.params.hasOwnProperty('belongs_to_uuid') &&
-            oldIP.params.belongs_to_uuid !== newIP.params.belongs_to_uuid) {
             var oldUsedErr = new errors.InvalidParamsError(
                 constants.msg.INVALID_PARAMS, [ errors.usedByParam('ip',
-                    newIP.params.belongs_to_type, newIP.params.belongs_to_uuid,
+                    ip.params.belongs_to_type, ip.params.belongs_to_uuid,
                     util.format(constants.fmt.IP_IN_USE,
-                        newIP.params.belongs_to_type,
-                        newIP.params.belongs_to_uuid))
+                        ip.params.belongs_to_type,
+                        ip.params.belongs_to_uuid))
                 ]);
-            oldUsedErr.stop = true;
-            return callback(oldUsedErr);
+            cb(oldUsedErr);
         }
-    }
-
-    // due to poor factoring of create/update operations, udpates of
-    // type 'update' get the appropriate SVP logs created after the updated
-    // nic object is created below. See also Nic.batch.
-    opts.vnetCns = [];
-    try {
-        addNicAndIPtoBatch(opts, paramIP, paramNet);
-    } catch (batchErr) {
-        return callback(batchErr);
-    }
-
-    if (changingIP && oldIP.params.belongs_to_uuid ===
-        oldNic.params.belongs_to_uuid) {
-        opts.batch.push(oldIP.batch({ free: true }));
-    }
-
-    // SVP logs must be updated when the MAC:IP mappings change, since the MAC
-    // is not updatable, we are only concerned with IP changes. We may need
-    // to create logs for one, none, or both of the following situations:
-    //   - the existing nic is on a fabric network (requires VL2 logs)
-    //   - the updated nic is on a fabric network (requires VL3 logs)
-    vasync.parallel({
-        funcs: [
-            function _existingVnetCns(cb) {
-                if (!changingIP || !opts.existingNic.isFabric()) {
-                    return cb();
-                }
-                common.listVnetCns({
-                    vnet_id: opts.existingNic.vnet_id,
-                    moray: opts.moray,
-                    log: opts.log
-                }, function (listErr, cns) {
-                    if (listErr) {
-                        return cb(listErr);
-                    }
-                    opts.batch.concat(mod_portolan_moray.vl2CnEventBatch({
-                        log: opts.log,
-                        vnetCns: cns,
-                        vnet_id: opts.existingNic.vnet_id,
-                        mac: opts.existingNic.mac
-                    }));
-                    return cb();
-                });
-            },
-            function _updatedVnetCns(cb) {
-                if (!changingIP || !opts.nic.isFabric()) {
-                    return cb();
-                }
-                common.listVnetCns({
-                    vnet_id: opts.nic.vnet_id,
-                    moray: opts.moray,
-                    log: opts.log
-                }, function (listErr, cns) {
-                    if (listErr) {
-                        return cb(listErr);
-                    }
-                    opts.batch.concat(mod_portolan_moray.vl3CnEventBatch({
-                        log: opts.log,
-                        vnetCns: cns,
-                        vnet_id: opts.nic.vnet_id,
-                        ip: opts.nic.ip,
-                        mac: opts.nic.mac,
-                        vlan_id: opts.nic.vlan_id
-                    }));
-                    return cb();
-                });
-            }
-        ]
-    }, function (listErr, results) {
-        if (listErr) {
-            return callback(listErr);
-        }
-        return common.commitBatch(opts, callback);
-    });
+    }, callback);
 }
 
 
@@ -394,19 +274,14 @@ function updateParams(opts, callback) {
 function update(opts, callback) {
     opts.log.trace('nic.update: entry');
 
-    var funcs = [
-        getExistingNic,
-        validateUpdateParams,
-        setUpdateType,
-        provisionIP,
-        updateParams
-    ];
-
-    opts.batch = [];
-
     vasync.pipeline({
         arg: opts,
-        funcs: funcs
+        funcs: [
+            getExistingNic,
+            validateUpdateParams,
+            prepareUpdate,
+            provision.nicAndIP
+        ]
     }, function (err) {
         if (err) {
             opts.log.error({
@@ -416,7 +291,8 @@ function update(opts, callback) {
                 params: opts.validated
             }, 'Error updating nic');
 
-            return callback(err);
+            callback(err);
+            return;
         }
 
         opts.log.info({
@@ -425,7 +301,7 @@ function update(opts, callback) {
             after: opts.nic.serialize()
         }, 'Updated nic');
 
-        return callback(null, opts.nic);
+        callback(null, opts.nic);
     });
 }
 
diff --git a/lib/models/vlan.js b/lib/models/vlan.js
index 9c450ec..d1ea612 100644
--- a/lib/models/vlan.js
+++ b/lib/models/vlan.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright 2016, Joyent, Inc.
+ * Copyright 2017, Joyent, Inc.
  */
 
 /*
@@ -21,6 +21,7 @@ var mod_fabric = require('./fabric');
 var mod_moray = require('../apis/moray');
 var mod_net = require('./network');
 var validate = require('../util/validate');
+var VError = require('verror');
 
 
 
@@ -241,7 +242,7 @@ function createFabricVLAN(opts, callback) {
             if (err2) {
                 // XXX: distinguish between which of these conflicted, and
                 // retry if it was the fabric
-                if (err2.name === 'EtagConflictError') {
+                if (VError.hasCauseWithName(err2, 'EtagConflictError')) {
                     return callback(new errors.InUseError(
                         constants.msg.VLAN_USED, [
                             errors.duplicateParam('vlan_id',
diff --git a/lib/napi.js b/lib/napi.js
index d31acaa..ae38974 100644
--- a/lib/napi.js
+++ b/lib/napi.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2015, Joyent, Inc.
+ * Copyright 2017, Joyent, Inc.
  */
 
 /*
@@ -262,7 +262,6 @@ NAPI.prototype.createMorayClient = function createMorayClient() {
         port: self.config.moray.port,
         reconnect: true,
         retry: {
-            retries: Infinity,
             maxTimeout: 6000,
             minTimeout: 100
         }
@@ -364,12 +363,14 @@ NAPI.prototype.init = function serverInit() {
         });
     }
 
-    // node-moray's version API returns the version as the first argument of the
-    // callback (and never returns an error)
-    this.moray.version({ log: self.moray.log }, function (v) {
-        self.morayVersion = v;
-        modelInitRetry();
-    });
+    /*
+     * There's no good way to deal with Moray versions currently (see RFD 33
+     * for a discussion of this), so for now we just hardcode version 2 until
+     * we have a way to enforce talking to a minimum Moray version.
+     */
+    self.morayVersion = 2;
+
+    modelInitRetry();
 };
 
 
diff --git a/lib/util/constants.js b/lib/util/constants.js
index 4b11955..4c00b14 100644
--- a/lib/util/constants.js
+++ b/lib/util/constants.js
@@ -62,14 +62,18 @@ var MESSAGES = {
 
 // Messages that need to be formatted with util.format
 var FORMAT_MESSAGES = {
-    IP_EXISTS: 'IP exists on network %s',
+    IP_EXISTS: 'IP %s exists on network %s',
     IP_IN_USE: 'IP in use by %s "%s"',
     IP_INVALID: 'Invalid IP %s',
     IP_OUTSIDE: 'IP address %s is outside the subnet for given network %s',
     IP_NONET: 'No networks matching this nic_tag ("%s") and vlan_id (%d) ' +
         'contained the IP address %s',
     IP_MULTI: 'Multiple (overlapping) networks (%s) matching this nic_tag ' +
-        'and vlan_id contain the IP address %s'
+        'and vlan_id contain the IP address %s',
+    NIC_TAGS_DIFFER: 'The nic_tag of all specified IPv4 and IPv6 networks ' +
+        'must match (have "%s" and "%s")',
+    VLAN_IDS_DIFFER: 'The vlan_id of all specified IPv4 and IPv6 networks ' +
+        'must match (have %d and %d)'
 };
 
 var ADMIN_UUID;
@@ -144,6 +148,7 @@ module.exports = {
         MTU_NETWORK_MIN + ' and ' + MTU_MAX,
     MTU_NETWORK_GT_NICTAG: 'network mtu must be under nic_tag mtu',
     MTU_NICTAG_UPDATE_MSG: 'nic_tag mtu update must support existing networks',
+    NIC_PROVISION_RETRIES: 100,
     OWNER_MATCH_MSG: 'network owner_uuids do not match',
     POOL_FULL_MSG: 'all networks in pool are full',
     POOL_IP_MSG: 'IP cannot be specified with a network pool',
diff --git a/lib/util/errors.js b/lib/util/errors.js
index 53a1c5c..4fa940f 100644
--- a/lib/util/errors.js
+++ b/lib/util/errors.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2015, Joyent, Inc.
+ * Copyright 2017, Joyent, Inc.
  */
 
 /*
@@ -114,20 +114,23 @@ util.inherits(InUseError, restify.InvalidArgumentError);
 /**
  * Base class for subnet full error
  */
-function SubnetFullError(message) {
-    assert.string(message, 'message');
+function SubnetFullError(network_uuid) {
+    assert.uuid(network_uuid, 'network_uuid');
 
     restify.RestError.call(this, {
         restCode: 'SubnetFull',
         statusCode: 507,
-        message: message,
+        message: constants.SUBNET_FULL_MSG,
         body: {
             code: 'SubnetFull',
-            message: message
+            message: constants.SUBNET_FULL_MSG,
+            network_uuid: network_uuid
         }
     });
 
     this.name = 'SubnetFullError';
+    this.network_uuid = network_uuid;
+    this.stop = true;
 }
 
 util.inherits(SubnetFullError, restify.RestError);
diff --git a/package.json b/package.json
index da72861..a79731d 100644
--- a/package.json
+++ b/package.json
@@ -14,23 +14,23 @@
     "ip6addr": "0.2.1",
     "jsprim": "1.2.2",
     "lomstream": "1.1.0",
-    "moray": "git+https://github.com/joyent/node-moray.git#b84ef0e",
+    "moray": "^2.0.0",
     "node-uuid": "1.4.7",
-    "portolan-moray": "git+https://github.com/joyent/sdc-portolan-moray.git#c756be9",
+    "portolan-moray": "git+https://github.com/joyent/sdc-portolan-moray.git#5f266f3",
     "restify": "4.1.1",
     "restify-warden": "0.1.1",
     "sdc-clients": "9.2.0",
     "tape": "4.5.1",
     "trace-event": "1.3.0",
     "vasync": "1.6.4",
-    "verror": "1.6.1"
+    "verror": "^1.9.0"
   },
   "devDependencies": {
+    "moray-sandbox": "0.1.0",
+    "faucet": "0.0.1",
+    "istanbul": "^0.4.0",
     "eslint": "2.13.1",
-    "eslint-plugin-joyent": "1.0.1",
-    "crc": "0.2.1",
-    "ldapjs": "0.5.7",
-    "xtend": "4.0.0"
+    "eslint-plugin-joyent": "1.0.1"
   },
   "scripts": {
     "start": "./sbin/napid",
diff --git a/test/integration/fabrics-invalid.test.js b/test/integration/fabrics-invalid.test.js
index b7a99df..b5f08af 100644
--- a/test/integration/fabrics-invalid.test.js
+++ b/test/integration/fabrics-invalid.test.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2015, Joyent, Inc.
+ * Copyright 2017, Joyent, Inc.
  */
 
 /*
@@ -15,16 +15,17 @@
 'use strict';
 
 var common = require('../lib/common');
-var extend = require('xtend');
 var fmt = require('util').format;
 var h = require('./helpers');
 var mod_err = require('../lib/err');
+var mod_jsprim = require('jsprim');
 var mod_uuid = require('node-uuid');
 var mod_fabric_net = require('../lib/fabric-net');
 var mod_vasync = require('vasync');
 var mod_vlan = require('../lib/vlan');
 var test = require('../lib/fabrics').testIfEnabled;
 
+var extend = mod_jsprim.mergeObjects;
 
 
 // --- Globals
diff --git a/test/integration/fabrics.test.js b/test/integration/fabrics.test.js
index e0ecf62..e08bf18 100644
--- a/test/integration/fabrics.test.js
+++ b/test/integration/fabrics.test.js
@@ -14,14 +14,15 @@
 
 'use strict';
 
+var assert = require('assert-plus');
 var clone = require('clone');
 var config = require('../lib/config');
 var constants = require('../../lib/util/constants');
-var extend = require('xtend');
 var h = require('./helpers');
 var mod_err = require('../lib/err');
 var mod_uuid = require('node-uuid');
 var mod_fabric_net = require('../lib/fabric-net');
+var mod_jsprim = require('jsprim');
 var mod_nic = require('../lib/nic');
 var mod_nic_tag = require('../lib/nic-tag');
 var mod_net = require('../lib/net');
@@ -29,6 +30,8 @@ var mod_portolan = require('../lib/portolan');
 var mod_vlan = require('../lib/vlan');
 var test = require('../lib/fabrics').testIfEnabled;
 
+var extend = mod_jsprim.mergeObjects;
+
 
 
 // --- Globals
@@ -131,7 +134,7 @@ var NETS = [
 
     // -- On VLANS[2] (OWNERS[1])
 
-    // 3: same subnet range as 2, but different owner
+    // 3: same subnet range and VLAN as 2, but different owner
     {
         vlan_id: VLANS[2].vlan_id,
         subnet: '192.168.0.0/24',
@@ -159,17 +162,57 @@ var NETS = [
 
 ];
 var VMS = [
+    mod_uuid.v4(),
+    mod_uuid.v4(),
     mod_uuid.v4(),
     mod_uuid.v4(),
     mod_uuid.v4()
 ];
 var SERVERS = [
     mod_uuid.v4(),
+    mod_uuid.v4(),
+
+    // Nothing goes on SERVERS[2], so its event log is always empty
     mod_uuid.v4()
 ];
 var SERVER_NICS = [];
 
 
+// --- Internal helper functions
+
+
+function checkEventLog(t, opts) {
+    assert.object(t);
+    assert.object(opts);
+
+    t.test('Shootdowns generated for SERVERS[0]', function (t2) {
+        mod_portolan.logReq(t2, {
+            params: {
+                cn_uuid: SERVERS[0]
+            },
+            exp: opts.log1
+        });
+    });
+
+    t.test('Shootdowns generated for SERVERS[1]', function (t2) {
+        mod_portolan.logReq(t2, {
+            params: {
+                cn_uuid: SERVERS[1]
+            },
+            exp: opts.log2
+        });
+    });
+
+    t.test('Shootdowns generated for SERVERS[2]', function (t2) {
+        mod_portolan.logReq(t2, {
+            params: {
+                cn_uuid: SERVERS[2]
+            },
+            exp: opts.log3
+        });
+    });
+}
+
 
 // XXX: make test() here something that checks if overlays are enabled,
 // and if not, fails and ends the test
@@ -821,7 +864,7 @@ test('provision server nics', function (t) {
         });
     });
 
-    t.test('REAL_NETS[0]: fail to provision underlay nic', function (t2) {
+    t.test('REAL_NETS[0]: fail to provision underlay NIC', function (t2) {
         mod_nic.provision(t2, {
             fillInMissing: true,
             net: REAL_NETS[0].uuid,
@@ -836,7 +879,7 @@ test('provision server nics', function (t) {
         });
     });
 
-    t.test('REAL_NETS[0]: provision underlay nic', function (t2) {
+    t.test('REAL_NETS[0]: provision SERVERS[0] underlay NIC', function (t2) {
         mod_nic.provision(t2, {
             fillInMissing: true,
             net: REAL_NETS[0].uuid,
@@ -855,7 +898,6 @@ test('provision server nics', function (t) {
         });
     });
 
-
     t.test('underlay mapping created', function (t2) {
         SERVER_NICS.push(mod_nic.lastCreated());
         t.ok(SERVER_NICS[1], 'have last created nic');
@@ -873,6 +915,42 @@ test('provision server nics', function (t) {
         });
     });
 
+    t.test('REAL_NETS[0]: provision SERVERS[1] underlay NIC', function (t2) {
+        mod_nic.provision(t2, {
+            fillInMissing: true,
+            net: REAL_NETS[0].uuid,
+            params: {
+                belongs_to_type: 'server',
+                belongs_to_uuid: SERVERS[1],
+                owner_uuid: ADMIN_OWNER,
+                underlay: true
+            },
+            exp: mod_net.addNetParams(REAL_NETS[0], {
+                belongs_to_type: 'server',
+                belongs_to_uuid: SERVERS[1],
+                owner_uuid: ADMIN_OWNER,
+                underlay: true
+            })
+        });
+    });
+
+    t.test('underlay mapping created', function (t2) {
+        SERVER_NICS.push(mod_nic.lastCreated());
+        t.ok(SERVER_NICS[2], 'have last created nic');
+        t.ok(SERVER_NICS[2].underlay, 'nic has underlay property');
+
+        mod_portolan.underlayMapping(t2, {
+            params: {
+                cn_uuid: SERVERS[1]
+            },
+            exp: {
+                cn_uuid: SERVERS[1],
+                ip: SERVER_NICS[2].ip,
+                port: constants.VXLAN_PORT
+            }
+        });
+    });
+
     // XXX: disallow provisioning fabric networks on the underlay nic tag!
 
 });
@@ -1136,35 +1214,304 @@ test('update nics', function (t) {
             expErr: mod_err.invalidParam('nic_tag', 'nic tag does not exist')
         });
     });
-
 });
 
+test('basic shootdown tests', function (t) {
+    var nic1, nic2;
+    var vnet_id, vlan_id;
+    var nic_tag = mod_fabric_net.nicTag(t, NETS[0]);
+    var newIP = NETS[1].provision_end_ip;
 
-test('delete server nic', function (t) {
+    // NIC <n>, Virtual Layer <n>, shootdown <n>
+    var nic1vl3s1;
+    var nic1vl3s2;
+    var nic1vl2s1;
+    var nic2vl3s1;
 
-    t.test('delete server nic', function (t2) {
-        t.ok(SERVER_NICS[1], 'have underlay nic');
-        t.ok(SERVER_NICS[1].underlay, 'nic has underlay property');
+    t.test('clear event log for SERVERS[0]', function (t2) {
+        mod_portolan.logReq(t2, {
+            params: {
+                cn_uuid: SERVERS[0]
+            },
+            partialExp: {}
+        });
+    });
+
+    t.test('clear event log for SERVERS[1]', function (t2) {
+        mod_portolan.logReq(t2, {
+            params: {
+                cn_uuid: SERVERS[1]
+            },
+            partialExp: {}
+        });
+    });
+
+    t.test('provision nic1', function (t2) {
+        mod_nic.provision(t2, {
+            fillInMissing: true,
+            net: NETS[1].uuid,
+            params: {
+                belongs_to_type: 'zone',
+                belongs_to_uuid: VMS[3],
+                cn_uuid: SERVERS[0],
+                owner_uuid: OWNERS[0]
+            },
+            exp: mod_net.addNetParams(NETS[1], {
+                belongs_to_type: 'zone',
+                belongs_to_uuid: VMS[3],
+                cn_uuid: SERVERS[0],
+                fabric: true,
+                nic_tag: nic_tag,
+                owner_uuid: OWNERS[0]
+            })
+        });
+    });
+
+    t.test('overlay mapping updated', function (t2) {
+        nic1 = mod_nic.lastCreated();
+        t.ok(nic1, 'last created nic');
+
+        vnet_id = mod_portolan.nicVnetID(t, nic1);
+        vlan_id = nic1.vlan_id;
+
+        nic1vl3s1 = {
+            vnet_id: vnet_id,
+            version: 1,
+            record: {
+                type: 'SVP_LOG_VL3',
+                ip: nic1.ip,
+                mac: nic1.mac,
+                vlan: vlan_id,
+                vnet_id: vnet_id
+            }
+        };
+
+        nic1vl2s1 = {
+            vnet_id: vnet_id,
+            version: 1,
+            record: {
+                type: 'SVP_LOG_VL2',
+                mac: nic1.mac,
+                vnet_id: vnet_id
+            }
+        };
+
+        mod_portolan.overlayMapping(t2, {
+            params: {
+                nic: nic1
+            },
+            exp: {
+                cn_uuid: SERVERS[0],
+                deleted: false,
+                ip: nic1.ip,
+                mac: nic1.mac,
+                version: 1,
+                vnet_id: vnet_id
+            }
+        });
+    });
+
+    t.test('Checking VL3 shootdowns', function (t2) {
+        checkEventLog(t2, {
+            log1: [ extend(nic1vl3s1, { cn_uuid: SERVERS[0] }) ],
+            log2: [],
+            log3: []
+        });
+    });
+
+    t.test('provision nic2', function (t2) {
+        mod_nic.provision(t2, {
+            fillInMissing: true,
+            net: NETS[1].uuid,
+            params: {
+                belongs_to_type: 'zone',
+                belongs_to_uuid: VMS[4],
+                cn_uuid: SERVERS[1],
+                owner_uuid: OWNERS[0]
+            },
+            exp: mod_net.addNetParams(NETS[1], {
+                belongs_to_type: 'zone',
+                belongs_to_uuid: VMS[4],
+                cn_uuid: SERVERS[1],
+                fabric: true,
+                nic_tag: nic_tag,
+                owner_uuid: OWNERS[0]
+            })
+        });
+    });
+
+    t.test('overlay mapping updated', function (t2) {
+        nic2 = mod_nic.lastCreated();
+        t.ok(nic2, 'last created nic');
 
+        nic2vl3s1 = {
+            vnet_id: vnet_id,
+            version: 1,
+            record: {
+                type: 'SVP_LOG_VL3',
+                ip: nic2.ip,
+                mac: nic2.mac,
+                vlan: vlan_id,
+                vnet_id: vnet_id
+            }
+        };
+
+        mod_portolan.overlayMapping(t2, {
+            params: {
+                nic: nic2
+            },
+            exp: {
+                cn_uuid: SERVERS[1],
+                deleted: false,
+                ip: nic2.ip,
+                mac: nic2.mac,
+                version: 1,
+                vnet_id: vnet_id
+            }
+        });
+    });
+
+    t.test('Checking VL3 shootdowns', function (t2) {
+        checkEventLog(t2, {
+            log1: [ extend(nic2vl3s1, { cn_uuid: SERVERS[0] }) ],
+            log2: [],
+            log3: []
+        });
+    });
+
+    t.test('NAPI-397: update fabric NIC to new IP address', function (t2) {
+        var params = {
+            ip: newIP
+        };
+        mod_nic.updateAndGet(t2, {
+            mac: nic1.mac,
+            params: params,
+            exp: extend(nic1, params)
+        });
+    });
+
+    t.test('old overlay mapping updated to deleted=true', function (t2) {
+        mod_portolan.overlayMapping(t2, {
+            params: {
+                nic: nic1
+            },
+            skipVL2: true,
+            expErr: mod_portolan.notFoundErr()
+        });
+    });
+
+    t.test('new overlay mapping updated', function (t2) {
+        nic1.ip = newIP;
+        nic1vl3s2 = {
+            vnet_id: vnet_id,
+            version: 1,
+            record: {
+                type: 'SVP_LOG_VL3',
+                ip: newIP,
+                mac: nic1.mac,
+                vlan: vlan_id,
+                vnet_id: vnet_id
+            }
+        };
+
+        mod_portolan.overlayMapping(t2, {
+            params: {
+                nic: nic1
+            },
+            exp: {
+                cn_uuid: SERVERS[0],
+                deleted: false,
+                ip: newIP,
+                mac: nic1.mac,
+                version: 1,
+                vnet_id: vnet_id
+            }
+        });
+    });
+
+    t.test('Checking VL3 shootdowns', function (t2) {
+        checkEventLog(t2, {
+            log1: [
+                extend(nic1vl3s1, { cn_uuid: SERVERS[0] }),
+                extend(nic1vl3s2, { cn_uuid: SERVERS[0] })
+            ],
+            log2: [
+                extend(nic1vl3s1, { cn_uuid: SERVERS[1] }),
+                extend(nic1vl3s2, { cn_uuid: SERVERS[1] })
+            ],
+            log3: []
+        });
+    });
+
+    t.test('NAPI-358: update nic1.cn_uuid to SERVERS[1]', function (t2) {
+        nic1.cn_uuid = SERVERS[1];
+
+        mod_nic.updateAndGet(t2, {
+            mac: nic1.mac,
+            params: {
+                cn_uuid: SERVERS[1]
+            },
+            exp: nic1
+        });
+    });
+
+    t.test('new overlay mapping updated', function (t2) {
+        mod_portolan.overlayMapping(t2, {
+            params: {
+                nic: nic1
+            },
+            exp: {
+                cn_uuid: SERVERS[1],
+                deleted: false,
+                ip: newIP,
+                mac: nic1.mac,
+                version: 1,
+                vnet_id: vnet_id
+            }
+        });
+    });
+
+    t.test('Checking VL2 & VL3 shootdowns', function (t2) {
+        checkEventLog(t2, {
+            log1: [
+                extend(nic1vl3s2, { cn_uuid: SERVERS[0] }),
+                extend(nic1vl2s1, { cn_uuid: SERVERS[0] })
+            ],
+            log2: [
+                extend(nic1vl3s2, { cn_uuid: SERVERS[1] }),
+                extend(nic1vl2s1, { cn_uuid: SERVERS[1] })
+            ],
+            log3: []
+        });
+    });
+
+    t.test('deleting nic1', function (t2) {
         mod_nic.del(t2, {
-            mac: SERVER_NICS[1].mac,
+            mac: nic1.mac,
             exp: {}
         });
     });
 
-
-    t.test('underlay mapping removed', function (t2) {
-        mod_portolan.underlayMapping(t2, {
+    t.test('overlay mapping updated to deleted=true', function (t2) {
+        mod_portolan.overlayMapping(t2, {
             params: {
-                cn_uuid: SERVERS[0]
+                nic: nic1
             },
             expErr: mod_portolan.notFoundErr()
         });
     });
 
+    t.test('Checking VL2 & VL3 shootdowns', function (t2) {
+        checkEventLog(t2, {
+            log1: [ extend(nic1vl2s1, { cn_uuid: SERVERS[0] }) ],
+            log2: [ extend(nic1vl2s1, { cn_uuid: SERVERS[1] }) ],
+            log3: []
+        });
+    });
 });
 
 
+
 test('provision gateway', function (t) {
 
     var gw = mod_uuid.v4();
@@ -1393,6 +1740,79 @@ test('NAPI-348: Provision with fabric nic_tag', function (t) {
 });
 
 
+test('Provision fabric NIC - IP specified w/o network_uuid', function (t) {
+    var ip = '192.168.0.150';
+    var mac = h.randomMAC();
+    var nic_tag = mod_fabric_net.nicTag(t, NETS[3]);
+    var params = {
+        ip: ip,
+        nic_tag: nic_tag,
+        vlan_id: NETS[3].vlan_id,
+        belongs_to_type: 'zone',
+        belongs_to_uuid: VMS[2],
+        primary: false,
+        state: 'running',
+        cn_uuid: SERVERS[0],
+        owner_uuid: OWNERS[1]
+    };
+    var exp = mod_net.addNetParams(NETS[3],
+        extend(params, { fabric: true, network_uuid: NETS[3] }));
+
+    t.test('NETS[3]: provision', function (t2) {
+        mod_nic.createAndGet(t2, {
+            mac: mac,
+            params: params,
+            exp: exp
+        });
+    });
+
+    t.test('overlay mapping added', function (t2) {
+        var nic = mod_nic.lastCreated();
+        t.ok(nic, 'last created nic');
+
+        mod_portolan.overlayMapping(t2, {
+            params: {
+                nic: nic
+            },
+            exp: {
+                cn_uuid: SERVERS[0],
+                deleted: false,
+                ip: ip,
+                mac: mac,
+                version: 1,
+                vnet_id: mod_portolan.nicVnetID(t, nic)
+            }
+        });
+    });
+});
+
+
+// --- Delete tests
+
+
+test('delete server nic', function (t) {
+    t.test('delete server nic', function (t2) {
+        t.ok(SERVER_NICS[1], 'have underlay nic');
+        t.ok(SERVER_NICS[1].underlay, 'nic has underlay property');
+
+        mod_nic.del(t2, {
+            mac: SERVER_NICS[1].mac,
+            exp: {}
+        });
+    });
+
+
+    t.test('underlay mapping removed', function (t2) {
+        mod_portolan.underlayMapping(t2, {
+            params: {
+                cn_uuid: SERVERS[0]
+            },
+            expErr: mod_portolan.notFoundErr()
+        });
+    });
+});
+
+
 // Create network tests:
 //
 // - Can't create public (non-RFC1918) nets
diff --git a/test/integration/migration-1.2.0-networks.test.js b/test/integration/migration-1.2.0-networks.test.js
index 544163e..7835531 100644
--- a/test/integration/migration-1.2.0-networks.test.js
+++ b/test/integration/migration-1.2.0-networks.test.js
@@ -15,8 +15,8 @@
 'use strict';
 
 var constants = require('../../lib/util/constants');
-var extend = require('xtend');
 var mod_ip = require('../lib/ip');
+var mod_jsprim = require('jsprim');
 var mod_migr = require('../lib/migration');
 var mod_net = require('../lib/net');
 var mod_nic = require('../lib/nic');
@@ -25,6 +25,7 @@ var mod_server = require('../lib/server');
 var mod_uuid = require('node-uuid');
 var test = require('tape');
 
+var extend = mod_jsprim.mergeObjects;
 
 
 // --- Globals
diff --git a/test/integration/networks.test.js b/test/integration/networks.test.js
index ec3e4d1..7f1c2bd 100644
--- a/test/integration/networks.test.js
+++ b/test/integration/networks.test.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2015, Joyent, Inc.
+ * Copyright 2017, Joyent, Inc.
  */
 
 /*
@@ -15,15 +15,16 @@
 'use strict';
 
 var constants = require('../../lib/util/constants');
-var extend = require('xtend');
 var fmt = require('util').format;
 var h = require('./helpers');
+var mod_jsprim = require('jsprim');
 var mod_net = require('../lib/net');
 var mod_uuid = require('node-uuid');
 var mod_vasync = require('vasync');
 var test = require('tape');
 var util = require('util');
 
+var extend = mod_jsprim.mergeObjects;
 
 
 // --- Globals
diff --git a/test/integration/nics.test.js b/test/integration/nics.test.js
index 9a77d30..29f21bd 100644
--- a/test/integration/nics.test.js
+++ b/test/integration/nics.test.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2015, Joyent, Inc.
+ * Copyright 2017, Joyent, Inc.
  */
 
 /*
@@ -358,8 +358,10 @@ test('POST /nics (with IP already reserved)', function (t) {
                 network_uuid: state.networks[0].uuid
             },
             expErr: h.invalidParamErr({ errors: [
-                mod_err.duplicateParam('ip', util.format(
-                    constants.fmt.IP_EXISTS, state.networks[0].uuid))
+                mod_err.usedByParam('ip', d.params.belongs_to_type,
+                    d.params.belongs_to_uuid,
+                    util.format(constants.fmt.IP_IN_USE,
+                        d.params.belongs_to_type, d.params.belongs_to_uuid))
             ] })
         });
     });
diff --git a/test/integration/provision.test.js b/test/integration/provision.test.js
index f8c4211..1b77cc1 100644
--- a/test/integration/provision.test.js
+++ b/test/integration/provision.test.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2015, Joyent, Inc.
+ * Copyright 2017, Joyent, Inc.
  */
 
 /*
@@ -90,7 +90,7 @@ function expPoolFull(t, err) {
 /**
  * Checks to make sure the error matches the subnet full error
  */
-function expSubnetFull(t, err) {
+function expSubnetFull(t, network_uuid, err) {
     t.ok(err, 'error returned');
     if (!err) {
         return;
@@ -99,7 +99,8 @@ function expSubnetFull(t, err) {
     t.equal(err.statusCode, 507, 'status code');
     t.deepEqual(err.body, {
         code: 'SubnetFull',
-        message: constants.SUBNET_FULL_MSG
+        message: constants.SUBNET_FULL_MSG,
+        network_uuid: network_uuid
     }, 'error');
 }
 
@@ -119,7 +120,7 @@ function expProvisionFail(t, opts) {
         if (opts.pool) {
             expPoolFull(t, err);
         } else {
-            expSubnetFull(t, err);
+            expSubnetFull(t, opts.network_uuid, err);
         }
 
         if (res) {
@@ -860,7 +861,7 @@ test('update network provision range', function (t) {
         napi.provisionNic(state.networks[1].uuid, params, function (err, res) {
             // If we pass in null, we expect the provision to fail
             if (!expected) {
-                expSubnetFull(t, err);
+                expSubnetFull(t, state.networks[1].uuid, err);
                 return cb();
             }
 
diff --git a/test/lib/common.js b/test/lib/common.js
index 3a32e28..9448aca 100644
--- a/test/lib/common.js
+++ b/test/lib/common.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2015, Joyent, Inc.
+ * Copyright 2017, Joyent, Inc.
  */
 
 /*
@@ -290,6 +290,7 @@ function afterAPIcall(t, opts, callback, err, obj, _, res) {
     }
 
     if (opts.reqType === 'create') {
+        assert.notEqual('s', opts.type.slice(-1));
         addToState(opts, opts.type + 's', obj);
     }
 
@@ -339,6 +340,7 @@ function afterAPIdelete(t, opts, callback, err, obj, req, res) {
 function afterAPIlist(t, opts, callback, err, obj, _, res) {
     assert.string(opts.type, 'opts.type');
     assert.string(opts.id, 'opts.id');
+    assert.optionalArray(opts.present, 'opts.present');
 
     var desc = opts.desc ? (' ' + opts.desc) : '';
     var id = opts.id;
@@ -418,6 +420,11 @@ function allCreated(type) {
 }
 
 
+function clearCreated(type) {
+    CREATED[type] = [];
+}
+
+
 /**
  * Assert the arguments to one of the helper functions are correct
  */
@@ -435,6 +442,20 @@ function assertArgs(t, opts, callback) {
 }
 
 
+/**
+ * Assert the arguments to one of the list helper functions are correct
+ */
+function assertArgsList(t, opts, callback) {
+    assert.object(t, 't');
+    assert.object(opts, 'opts');
+    assert.optionalObject(opts.params, 'opts.params');
+    assert.optionalObject(opts.expErr, 'opts.expErr');
+    assert.optionalBool(opts.deepEqual, 'opts.deepEqual');
+    assert.optionalArrayOfObject(opts.present, 'opts.present');
+    assert.optionalFunc(callback, 'callback');
+}
+
+
 /**
  * Creates a NAPI client for the configured NAPI instance, with a unique
  * req_id.
@@ -606,7 +627,9 @@ module.exports = {
     afterAPIlist: afterAPIlist,
     allCreated: allCreated,
     assertArgs: assertArgs,
+    assertArgsList: assertArgsList,
     badLimitOffTests: badLimitOffTests,
+    clearCreated: clearCreated,
     commonErrors: commonErrors,
     createClient: createClient,
     doneErr: doneErr,
diff --git a/test/lib/fabric-net.js b/test/lib/fabric-net.js
index 62d9a37..3ebd298 100644
--- a/test/lib/fabric-net.js
+++ b/test/lib/fabric-net.js
@@ -138,6 +138,8 @@ function delAllCreatedFabricNets(t) {
         return t.end();
     }
 
+    common.clearCreated('fabric-networks');
+
     mod_vasync.forEachParallel({
         inputs: created,
         func: function _delOne(net, cb) {
diff --git a/test/lib/migration.js b/test/lib/migration.js
index 0ebb3f6..88902c3 100644
--- a/test/lib/migration.js
+++ b/test/lib/migration.js
@@ -22,6 +22,7 @@ var mod_moray = require('moray');
 var mod_server = require('./server');
 var mod_vasync = require('vasync');
 var napi_moray = require('../../lib/apis/moray');
+var VError = require('verror');
 
 
 
@@ -206,7 +207,8 @@ function initTestBucket(t, opts) {
 
         function _delOldBucket(_, cb) {
             client.delBucket(bucketName, function (delErr) {
-                if (delErr && delErr.name === 'BucketNotFoundError') {
+                if (delErr &&
+                    VError.hasCauseWithName(delErr, 'BucketNotFoundError')) {
                     t.ok(delErr, 'bucket not found: ' + bucketName);
                     return cb();
                 }
diff --git a/test/lib/mock-moray.js b/test/lib/mock-moray.js
deleted file mode 100644
index 2c2e28a..0000000
--- a/test/lib/mock-moray.js
+++ /dev/null
@@ -1,778 +0,0 @@
-/*
- * This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/.
- */
-
-/*
- * Copyright (c) 2015, Joyent, Inc.
- */
-
-/*
- * Mock moray object for unit tests
- */
-
-'use strict';
-
-var assert = require('assert-plus');
-var crc = require('crc');
-var clone = require('clone');
-var EventEmitter = require('events').EventEmitter;
-var ldapjs = require('ldapjs');
-var util = require('util');
-var util_ip = require('../../lib/util/ip.js');
-var verror = require('verror');
-
-
-
-// --- Globals
-
-
-
-var BUCKETS = {};
-var BUCKET_VALUES = {};
-var LAST_MORAY_ERROR;
-var MORAY_ERRORS = {};
-
-
-
-// --- Internal
-
-
-
-/**
- * If there's an error in MORAY_ERRORS for the given operation, return it.
- */
-function getNextMorayError(op, details) {
-    if (!MORAY_ERRORS.hasOwnProperty(op) ||
-        typeof (MORAY_ERRORS[op]) !== 'object' ||
-        MORAY_ERRORS[op].length === 0) {
-        return;
-    }
-
-    var morayErr = MORAY_ERRORS[op].shift();
-
-    // Allow passing null in the array to allow interleaving successes and
-    // errors
-    if (morayErr === null) {
-        return;
-    }
-
-    LAST_MORAY_ERROR = clone(details);
-    LAST_MORAY_ERROR.op = op;
-    LAST_MORAY_ERROR.msg = morayErr.message;
-
-    return morayErr;
-}
-
-
-/**
- * Returns a not found error for the bucket
- */
-function bucketNotFoundErr(bucket) {
-    var err = new verror.VError('bucket "%s" does not exist', bucket);
-    err.name = 'BucketNotFoundError';
-    return err;
-}
-
-
-/**
- * Do etag checks on a record
- */
-function checkEtag(opts, bucket, key, batch) {
-    if (!opts || !opts.hasOwnProperty('etag')) {
-        return;
-    }
-
-    var errOpts = {};
-    if (batch) {
-        errOpts = {
-            context: {
-                bucket: bucket
-            }
-        };
-    }
-
-    if (BUCKET_VALUES[bucket].hasOwnProperty(key)) {
-        if (opts.etag === null) {
-            throw etagConflictErr(util.format('key "%s" already exists', key),
-                errOpts);
-        }
-
-        var obj = BUCKET_VALUES[bucket][key];
-        if (opts.etag !== obj._etag) {
-            throw etagConflictErr(
-                util.format('wanted to put etag "%s", but object has etag "%s"',
-                    opts.etag, obj._etag), errOpts);
-        }
-    }
-}
-
-
-/**
- * Generates an etag for an object
- */
-function eTag(val) {
-    return (crc.hex32(crc.crc32(JSON.stringify(val))));
-}
-
-
-/**
- * Returns a not found error for the bucket
- */
-function etagConflictErr(msg, otherOpts) {
-    var err = new verror.VError(msg);
-    err.name = 'EtagConflictError';
-
-    if (otherOpts) {
-        for (var o in otherOpts) {
-            err[o] = otherOpts[o];
-        }
-    }
-
-    return err;
-}
-
-
-function matchObj(filter, origObj) {
-    // The LDAP matching function .matches() assumes that the
-    // values are strings, so stringify properties so that matches
-    // work correctly.  The exception is arrays - it's able to walk
-    // an array and match each element individually.
-    var obj = {};
-    for (var k in origObj.value) {
-        var val = origObj.value[k];
-        if (val === undefined) {
-            continue;
-        } else if (util.isArray(val)) {
-            obj[k] = clone(origObj.value[k]);
-        } else {
-            obj[k] = origObj.value[k].toString();
-        }
-    }
-
-    if (filter.matches(obj)) {
-        return true;
-    }
-
-    return false;
-}
-
-
-/**
- * Returns an object not found error
- */
-function objectNotFoundErr(key) {
-    var err = new verror.VError('key "%s" does not exist', key);
-    err.name = 'ObjectNotFoundError';
-    return err;
-}
-
-
-
-// --- Fake moray object
-
-
-
-function FakeMoray(opts) {
-    assert.object(opts, 'opts');
-    assert.object(opts.log, 'opts.log');
-
-    this.log = opts.log.child({ component: 'mock-moray' });
-    this._version = opts.version || 2;
-    BUCKET_VALUES = {};
-    EventEmitter.call(this);
-}
-
-util.inherits(FakeMoray, EventEmitter);
-
-
-FakeMoray.prototype._del = function _del(bucket, key) {
-    var err = getNextMorayError('delObject', { bucket: bucket, key: key });
-    if (err) {
-        throw err;
-    }
-
-    if (!BUCKET_VALUES.hasOwnProperty(bucket)) {
-        throw bucketNotFoundErr(bucket);
-    }
-
-    if (!BUCKET_VALUES[bucket].hasOwnProperty(key)) {
-        throw objectNotFoundErr(key);
-    }
-
-    delete BUCKET_VALUES[bucket][key];
-};
-
-
-FakeMoray.prototype._put = function _store(bucket, key, val) {
-    var obj = {
-        _etag: eTag(val),
-        key: key,
-        value: clone(val)
-    };
-
-    this.log.trace({ bucket: bucket, obj: obj }, '_put object');
-    BUCKET_VALUES[bucket][key] = obj;
-};
-
-
-FakeMoray.prototype._updateObjects =
-    function _updateObjects(bucket, fields, filter) {
-    assert.object(fields, 'fields');
-    assert.string(filter, 'filter');
-
-    // XXX: should throw if trying to set a non-indexed field
-
-    var filterObj = ldapjs.parseFilter(filter);
-    for (var r in BUCKET_VALUES[bucket]) {
-        if (matchObj(filterObj, BUCKET_VALUES[bucket][r])) {
-            for (var nk in fields) {
-                BUCKET_VALUES[bucket][r].value[nk] = fields[nk];
-            }
-        }
-    }
-};
-
-
-
-
-FakeMoray.prototype.batch = function _batch(data, callback) {
-    assert.arrayOfObject(data, 'data');
-
-    var err = getNextMorayError('batch', { batch: data });
-    if (err) {
-        return callback(err);
-    }
-
-    for (var b in data) {
-        var item = data[b];
-        assert.string(item.operation, 'item.operation');
-        assert.string(item.bucket, 'item.bucket');
-
-        var knownOp = false;
-        ['delete', 'put', 'update'].forEach(function (opt) {
-            if (item.operation === opt) {
-                knownOp = true;
-            }
-        });
-
-        if (!knownOp) {
-            throw new verror.VError('Unknown moray operation "%s"',
-                item.operation);
-        }
-
-        if (item.operation !== 'update') {
-            assert.string(item.key, 'item.key');
-        }
-
-        if (item.operation === 'put') {
-            assert.object(item.value, 'item.value');
-            if (!BUCKET_VALUES.hasOwnProperty(item.bucket)) {
-                return callback(bucketNotFoundErr(item.bucket));
-            }
-
-            try {
-                checkEtag(item.options, item.bucket, item.key, true);
-            } catch (eTagErr) {
-                return callback(eTagErr);
-            }
-
-            this._put(item.bucket, item.key, item.value);
-        }
-
-        if (item.operation === 'delete') {
-            try {
-                this._del(item.bucket, item.key);
-            } catch (err2) {
-                return callback(err2);
-            }
-        }
-
-        if (item.operation === 'update') {
-            if (!BUCKET_VALUES.hasOwnProperty(item.bucket)) {
-                return callback(bucketNotFoundErr(item.bucket));
-            }
-
-            this._updateObjects(item.bucket, item.fields, item.filter);
-        }
-    }
-
-    return callback();
-};
-
-
-FakeMoray.prototype.close = function morayClose() {
-    return;
-};
-
-
-FakeMoray.prototype.createBucket =
-    function createBucket(bucket, schema, callback) {
-
-    var err = getNextMorayError('createBucket', { bucket: bucket });
-    if (err) {
-        return callback(err);
-    }
-
-    BUCKETS[bucket] = clone(schema);
-    BUCKET_VALUES[bucket] = {};
-    return callback();
-};
-
-
-FakeMoray.prototype.delBucket = function delBucket(bucket, callback) {
-    var err = getNextMorayError('delBucket', { bucket: bucket });
-    if (err) {
-        return callback(err);
-    }
-
-    if (!BUCKET_VALUES.hasOwnProperty(bucket)) {
-        return callback(bucketNotFoundErr(bucket));
-    }
-
-    delete BUCKET_VALUES[bucket];
-    return callback();
-};
-
-
-FakeMoray.prototype.delObject = function delObject(bucket, key, callback) {
-    try {
-        this._del(bucket, key);
-        return callback();
-    } catch (err) {
-        return callback(err);
-    }
-};
-
-
-FakeMoray.prototype.findObjects = function findObjects(bucket, filter, opts) {
-    var res = new EventEmitter;
-    var filterObj = ldapjs.parseFilter(filter);
-    var limit = opts.limit || 1000;
-    var offset = opts.offset || 0;
-    var i;
-
-    function compareTo(a, b) {
-        /*
-         * Whenever NAPI sorts, it sorts on a field which is the same
-         * as its key. These fields are either IP addresses or strings,
-         * so we first attempt comparing it as an IP address and then
-         * as a string to mock what Moray does.
-         */
-        try {
-            return util_ip.compareTo(a, b);
-        } catch (_) {
-            if (a < b) {
-                return -1;
-            } else if (a > b) {
-                return 1;
-            } else {
-                return 0;
-            }
-        }
-    }
-
-    process.nextTick(function () {
-        var err = getNextMorayError('findObjects',
-            { bucket: bucket, filter: filter });
-        if (err) {
-            res.emit('error', err);
-            return;
-        }
-
-        if (!BUCKET_VALUES.hasOwnProperty(bucket)) {
-            res.emit('error', bucketNotFoundErr(bucket));
-            return;
-        }
-
-        // Whenever we call findObjects, it's either unsorted or sorted by ASC,
-        // so just sort them ASC every time
-        var keys = Object.keys(BUCKET_VALUES[bucket]).sort(compareTo);
-        i = 0;
-        keys.forEach(function (r) {
-            var val = BUCKET_VALUES[bucket][r];
-            if (matchObj(filterObj, val)) {
-                if (i >= offset && i < offset + limit) {
-                    res.emit('record', clone(val));
-                }
-                i++;
-            }
-        });
-
-        res.emit('end');
-    });
-
-    return res;
-};
-
-
-FakeMoray.prototype.getBucket = function getBucket(bucket, callback) {
-    var err = getNextMorayError('getBucket', { bucket: bucket });
-    if (err) {
-        return callback(err);
-    }
-
-    if (!BUCKETS.hasOwnProperty(bucket)) {
-        return callback(bucketNotFoundErr(bucket));
-    }
-
-    return callback(null, clone(BUCKETS[bucket]));
-};
-
-
-FakeMoray.prototype.getObject = function getObject(bucket, key, callback) {
-    var err = getNextMorayError('getObject', { bucket: bucket, key: key });
-    if (err) {
-        return callback(err);
-    }
-
-    if (!BUCKET_VALUES.hasOwnProperty(bucket)) {
-        return callback(bucketNotFoundErr(bucket));
-    }
-
-    if (!BUCKET_VALUES[bucket].hasOwnProperty(key)) {
-        return callback(objectNotFoundErr(key));
-    }
-
-    var rec = clone(BUCKET_VALUES[bucket][key]);
-    this.log.trace({ bucket: bucket, key: key, rec: rec }, 'got object');
-    return callback(null, rec);
-};
-
-
-FakeMoray.prototype.putObject =
-    function putObject(bucket, key, value, opts, callback) {
-    if (typeof (opts) === 'function') {
-        callback = opts;
-        opts = {};
-    }
-
-    var err = getNextMorayError('putObject',
-            { bucket: bucket, key: key, value: value, opts: opts });
-    if (err) {
-        return callback(err);
-    }
-
-    if (!BUCKET_VALUES.hasOwnProperty(bucket)) {
-        return callback(bucketNotFoundErr(bucket));
-    }
-
-    try {
-        checkEtag(opts, bucket, key);
-    } catch (eTagErr) {
-        return callback(eTagErr);
-    }
-
-    this._put(bucket, key, value);
-    return callback();
-};
-
-
-FakeMoray.prototype.reindexObjects =
-        function reindexObjects(_bucket, _count, _opts, callback) {
-    return callback(null, { processed: 0 });
-};
-
-
-FakeMoray.prototype.sql = function sql(str) {
-    // Mock out PG's gap detection and subnet filtering
-
-    if (/subnet >> inet\(/.test(str)) {
-        // This is from the network overlap detection code: just return an
-        // EventEmitter that immediately ends (as if there were no overlapping
-        // networks found):
-        var evt = new EventEmitter();
-        setImmediate(function () {
-            evt.emit('end');
-        });
-
-        return evt;
-    }
-
-    /* BEGIN JSSTYLED */
-    var bucket = str.match(/from ([a-z0-9_]+)/);
-    var limit = str.match(/limit (\d+)/) || undefined;
-    var minIP = str.match(/>= inet\('([a-f0-9.:]+)'/);
-    var maxIP = str.match(/<= inet\('([a-f0-9.:]+)'/);
-    var min = str.match(/>= (\d+)/);
-    var max  = str.match(/<= (\d+)/);
-    var subnet = str.match(/<< inet('([a-f0-9.:/]+)')/);
-    var subnet_start_ip = str.match(/>> inet('([a-f0-9.:]+)')/);
-    /* END JSSTYLED */
-
-    if (limit) {
-        limit = Number(limit[1]);
-    }
-
-    bucket = bucket[1];
-
-    if (minIP && maxIP) {
-        return this._gapIP({
-            min: util_ip.toIPAddr(minIP[1]),
-            max: util_ip.toIPAddr(maxIP[1]),
-            bucket: bucket,
-            limit: limit
-        });
-    }
-
-    if (min && max) {
-        return this._gapNumber({
-            min: Number(min[1]),
-            max: Number(max[1]),
-            bucket: bucket,
-            limit: limit
-        });
-    }
-
-    if (subnet && subnet_start_ip) {
-        return this._subnetFilter({
-            subnet: subnet[1],
-            subnet_start_ip: util_ip.toIPAddr(subnet_start_ip[1]),
-            bucket: bucket,
-            limit: limit
-        });
-    }
-
-    return null;
-};
-
-
-FakeMoray.prototype._subnetFilter = function _subnetFilter(opts) {
-    var subnet = opts.subnet;
-    var subnetStart = opts.subnet_start_ip;
-    var bucket = opts.bucket;
-    var limit = opts.limit;
-
-    assert.string(subnet);
-    assert.object(subnetStart);
-    assert.string(bucket);
-    assert.optionalNumber(limit);
-
-    var bits = Number(subnet.split('/')[1]);
-
-    var res = new EventEmitter();
-    setImmediate(function () {
-        var err = getNextMorayError('sql', { opts: opts });
-        if (err) {
-            res.emit('error', err);
-            return;
-        }
-
-        if (!BUCKET_VALUES.hasOwnProperty(bucket)) {
-            res.emit('error', bucketNotFoundErr(bucket));
-            return;
-        }
-
-        var bucketKeys = Object.keys(BUCKET_VALUES[bucket]).sort();
-        var found = 0;
-        for (var i in bucketKeys) {
-            var value = BUCKET_VALUES[bucket][bucketKeys[i]].value;
-            var other = value.subnet.split('/');
-            var otherSubnet = util_ip.toIPAddr(other[0]);
-            var otherBits = Number(other[1]);
-            if (subnetStart.match(otherSubnet, otherBits) ||
-                otherSubnet.match(subnetStart, bits)) {
-                if (limit && found < limit) {
-                    res.emit('record', value);
-                }
-                found++;
-            }
-        }
-        res.emit('end');
-    });
-    return res;
-};
-
-
-FakeMoray.prototype._gapNumber = function _gapNumber(opts) {
-    var min = opts.min;
-    var max = opts.max;
-    var bucket = opts.bucket;
-    var limit = opts.limit;
-
-    assert.number(min);
-    assert.number(max);
-    assert.string(bucket);
-    assert.optionalNumber(limit);
-
-    var res = new EventEmitter();
-    setImmediate(function () {
-        var err = getNextMorayError('sql', { opts: opts });
-        if (err) {
-            res.emit('error', err);
-            return;
-        }
-
-        if (!BUCKET_VALUES.hasOwnProperty(bucket)) {
-            res.emit('error', bucketNotFoundErr(bucket));
-            return;
-        }
-
-        var bucketKeys = Object.keys(BUCKET_VALUES[bucket]).map(function (k) {
-            return Number(k);
-        }).sort();
-        var found = 0;
-        var last = bucketKeys[0];
-        for (var i in bucketKeys) {
-            var ip = bucketKeys[i];
-            if ((ip - last) > 1 && (last + 1) <= max && (last + 1) >= min) {
-                if (limit && found < limit) {
-                    res.emit('record', {
-                        // XXX is this right?
-                        gap_length: ip - last + 1,
-                        gap_start: last + 1
-                    });
-                }
-                found++;
-                break;
-            }
-            last = ip;
-        }
-        res.emit('end');
-    });
-    return res;
-};
-
-
-FakeMoray.prototype._gapIP = function _gapIP(opts) {
-    var min = util_ip.toIPAddr(opts.min);
-    var max = util_ip.toIPAddr(opts.max);
-    var bucket = opts.bucket;
-    var limit = opts.limit;
-
-    assert.object(min);
-    assert.object(max);
-    assert.string(bucket);
-    assert.optionalNumber(limit);
-
-    function lte(a, b) {
-        return util_ip.compareTo(a, b) <= 0;
-    }
-
-    function gt(a, b) {
-        return util_ip.compareTo(a, b) > 0;
-    }
-
-    function gte(a, b) {
-        return util_ip.compareTo(a, b) >= 0;
-    }
-
-    function plus(a, b) {
-        return util_ip.ipAddrPlus(a, b);
-    }
-
-    var res = new EventEmitter();
-    setImmediate(function () {
-        var err = getNextMorayError('sql', { opts: opts });
-        if (err) {
-            res.emit('error', err);
-            return;
-        }
-
-        if (!BUCKET_VALUES.hasOwnProperty(bucket)) {
-            res.emit('error', bucketNotFoundErr(bucket));
-            return;
-        }
-
-        var bucketKeys = Object.keys(BUCKET_VALUES[bucket]).map(function (k) {
-            return util_ip.toIPAddr(k);
-        }).sort(util_ip.compareTo);
-        var found = 0;
-        var last = bucketKeys[0];
-        for (var i in bucketKeys) {
-            var ip = bucketKeys[i];
-            if (gt(ip, plus(last, 1)) && // ip > last + 1, or (ip - last) > 1
-                lte(plus(last, 1), max) && // (last + 1) <= max
-                gte(plus(last, 1), min)) { // (last + 1) >= min
-
-                if (limit && found < limit) {
-                    res.emit('record', {
-                        // XXX ipaddr minus ipaddr not implemented,
-                        // so just return something for gap length
-                        gap_length: 100,
-                        gap_start: plus(last, 1).toString() // last + 1
-                    });
-                }
-                found++;
-                break;
-            }
-            last = ip;
-        }
-        res.emit('end');
-    });
-    return res;
-};
-
-
-
-
-FakeMoray.prototype.updateBucket =
-    function updateBucket(bucket, schema, callback) {
-
-    BUCKETS[bucket] = clone(schema);
-    return callback();
-};
-
-
-
-FakeMoray.prototype.updateObjects =
-    function updateObjects(bucket, fields, filter, callback) {
-    assert.object(bucket, 'bucket');
-
-    if (!BUCKET_VALUES.hasOwnProperty(bucket)) {
-        return callback(bucketNotFoundErr(bucket));
-    }
-
-    this._updateObjects(bucket, fields, filter);
-    return callback();
-};
-
-
-
-FakeMoray.prototype.version = function version(opts, callback) {
-    var self = this;
-    if (typeof (opts) === 'function') {
-        callback = opts;
-    }
-    setImmediate(function () {
-        return callback(self._version);
-    });
-};
-
-
-
-// --- Exports
-
-
-
-function createClient(opts) {
-    var client = new FakeMoray(opts);
-    process.nextTick(function () {
-        client.emit('connect');
-    });
-
-    return client;
-}
-
-
-
-module.exports = {
-    get _bucketSchemas() {
-        return BUCKETS;
-    },
-    get _buckets() {
-        return BUCKET_VALUES;
-    },
-    get _errors() {
-        return MORAY_ERRORS;
-    },
-    set _errors(obj) {
-        MORAY_ERRORS = obj;
-    },
-    get _lastError() {
-        return LAST_MORAY_ERROR;
-    },
-    FakeMoray: FakeMoray,
-    createClient: createClient
-};
diff --git a/test/lib/moray.js b/test/lib/moray.js
index 15302e0..cf4fbfe 100644
--- a/test/lib/moray.js
+++ b/test/lib/moray.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2015, Joyent, Inc.
+ * Copyright 2017, Joyent, Inc.
  */
 
 /*
@@ -15,155 +15,82 @@
 'use strict';
 
 var assert = require('assert-plus');
-var mock_moray = require('./mock-moray');
 var mod_ip = require('../../lib/models/ip');
-var util = require('util');
-var util_ip = require('../../lib/util/ip');
 var util_mac = require('../../lib/util/mac');
 
 
-
-// --- Exports
-
-
-
-/**
- * Returns a moray bucket
- */
-function getBucket(name) {
-    return mock_moray._buckets[name];
-}
-
-
-/**
- * Returns the moray buckets
- */
-function getBuckets() {
-    return mock_moray._buckets;
-}
+// --- Internals
 
 
-/**
- * Returns a moray bucket's schema
- */
-function getBucketSchema(name) {
-    return mock_moray._bucketSchemas[name];
+function extractValue(callback) {
+    return function (err, res) {
+        if (res) {
+            res = res.value;
+        }
+        callback(err, res);
+    };
 }
 
 
-/**
- * Gets mock moray errors
- */
-function getErrors() {
-    return mock_moray._errors;
-}
+// --- Exports
 
 
 /**
- * Gets an IP record from fake moray
+ * Gets an IP record from Moray.
  */
-function getIP(network, ip) {
-    var buckets = mock_moray._buckets;
-    var bucketName = mod_ip.bucket(network).name;
-    if (!buckets.hasOwnProperty(bucketName)) {
-        return util.format('Bucket %s not found', bucketName);
-    }
-
-    var rec = buckets[bucketName][ip];
-    if (rec) {
-        return rec.value;
-    }
-
-    return null;
+function getIP(moray, network, ip, callback) {
+    var bucket = mod_ip.bucketName(network);
+    moray.getObject(bucket, ip, extractValue(callback));
 }
 
 
 /**
- * Gets all IP records for a network from fake moray
+ * Gets all IP records for a network from Moray, sorted by address.
  */
-function getIPs(network) {
-    var buckets = mock_moray._buckets;
-    var bucketName = mod_ip.bucket(network).name;
-    if (!buckets.hasOwnProperty(bucketName)) {
-        return util.format('Bucket %s not found', bucketName);
-    }
-
-    return Object.keys(buckets[bucketName]).map(function (key) {
-        return buckets[bucketName][key].value;
-    }).sort(function (a, b) {
-        if (a.hasOwnProperty('ipaddr')) {
-            return util_ip.compareTo(a.ipaddr, b.ipaddr);
+function getIPs(moray, network, callback) {
+    var bucket = mod_ip.bucketName(network);
+    var ips = [];
+    var res = moray.findObjects(bucket, '(ipaddr=*)', {
+        sort: {
+            attribute: 'ipaddr',
+            order: 'ASC'
         }
-
-        return util_ip.compareTo(a.ip, b.ip);
     });
+    res.on('error', callback);
+    res.on('record', function (obj) { ips.push(obj.value); });
+    res.on('end', function () { callback(null, ips); });
 }
 
 
 /**
- * Returns the last moray error
- */
-function getLastError() {
-    return mock_moray._lastError;
-}
-
-
-/**
- * Gets all nic records from fake moray, sorted by MAC address
+ * Gets a NIC record from Moray.
  */
-function getNic(mac) {
+function getNic(moray, mac, callback) {
     var macNum = util_mac.aton(mac);
     assert.number(macNum, 'Not a valid MAC address');
-
-    return getObj('napi_nics', macNum);
-}
-
-/**
- * Gets all nic records from fake moray, sorted by MAC address
- */
-function getNics() {
-    var bucket = mock_moray._buckets.napi_nics;
-    assert.object(bucket, 'bucket');
-
-    return Object.keys(bucket).sort().map(function (key) {
-        return bucket[key];
-    });
+    moray.getObject('napi_nics', macNum.toString(), extractValue(callback));
 }
 
 
 /**
- * Returns an object from a moray bucket
- */
-function getObj(bucketName, key) {
-    var bucket = mock_moray._buckets[bucketName];
-    assert.object(bucket, 'bucket');
-    var obj = bucket[key];
-    if (obj) {
-        return obj.value;
-    }
-
-    return null;
-}
-
-/**
- * Sets moray to return errors for the given operations
+ * Counts all NIC records in Moray.
  */
-function setErrors(obj) {
-    mock_moray._errors = obj;
+function countNics(moray, callback) {
+    var nics = 0;
+    var res = moray.findObjects('napi_nics', '(mac=*)');
+    res.on('error', callback);
+    res.on('record', function (_) {
+        nics += 1;
+    });
+    res.on('end', function () {
+        callback(null, nics);
+    });
 }
 
 
-
 module.exports = {
-    getBucket: getBucket,
-    getBuckets: getBuckets,
-    getBucketSchema: getBucketSchema,
-    getErrors: getErrors,
     getIP: getIP,
     getIPs: getIPs,
-    getLastError: getLastError,
     getNic: getNic,
-    getNics: getNics,
-    getObj: getObj,
-    setErrors: setErrors
+    countNics: countNics
 };
diff --git a/test/lib/net.js b/test/lib/net.js
index 36becfa..9215c51 100644
--- a/test/lib/net.js
+++ b/test/lib/net.js
@@ -33,6 +33,7 @@ var doneErr = common.doneErr;
 var NIC_NET_PARAMS = [
     'gateway',
     'gateway_provisioned',
+    'internet_nat',
     'mtu',
     'netmask',
     'nic_tag',
@@ -146,6 +147,8 @@ function delAllCreatedNets(t) {
         return t.end();
     }
 
+    common.clearCreated('networks');
+
     mod_vasync.forEachParallel({
         inputs: created,
         func: function _delOne(net, cb) {
diff --git a/test/lib/nic-tag.js b/test/lib/nic-tag.js
index e871552..49f9955 100644
--- a/test/lib/nic-tag.js
+++ b/test/lib/nic-tag.js
@@ -109,6 +109,8 @@ function delAllCreatedTags(t) {
         return t.end();
     }
 
+    common.clearCreated('nic_tags');
+
     mod_vasync.forEachParallel({
         inputs: created,
         func: function _delOne(tag, cb) {
diff --git a/test/lib/nic.js b/test/lib/nic.js
index af9b9db..415efa6 100644
--- a/test/lib/nic.js
+++ b/test/lib/nic.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2015, Joyent, Inc.
+ * Copyright 2017, Joyent, Inc.
  */
 
 /*
@@ -162,6 +162,8 @@ function delAllCreatedNics(t) {
         return t.end();
     }
 
+    common.clearCreated('nics');
+
     mod_vasync.forEachParallel({
         inputs: created,
         func: function _delOne(nic, cb) {
@@ -233,11 +235,7 @@ function lastCreatedNic() {
  * List networks
  */
 function listNics(t, opts, callback) {
-    assert.object(t, 't');
-    assert.object(opts, 'opts');
-    assert.optionalBool(opts.deepEqual, 'opts.deepEqual');
-    assert.optionalArrayOfObject(opts.present, 'opts.present');
-    assert.optionalObject(opts.expErr, 'opts.expErr');
+    common.assertArgsList(t, opts, callback);
 
     var client = opts.client || mod_client.get();
     var params = opts.params || {};
diff --git a/test/lib/portolan.js b/test/lib/portolan.js
index 8045c93..79557a5 100644
--- a/test/lib/portolan.js
+++ b/test/lib/portolan.js
@@ -23,6 +23,7 @@ var mod_moray = require('moray');
 var mod_portolan_moray = require('portolan-moray');
 var util_ip = require('../../lib/util/ip');
 var util_mac = require('../../lib/util/mac');
+var vasync = require('vasync');
 
 var doneErr = common.doneErr;
 var doneRes = common.doneRes;
@@ -39,6 +40,19 @@ var MORAY_CLIENT;
 
 // --- Internal
 
+function toMorayObj(exp) {
+    assert.object(exp);
+
+    // Convert colon-delimited MAC addresses to numeric form
+    if (exp.mac) {
+        exp.mac = util_mac.aton(exp.mac);
+    }
+
+    // Ensure IP addresses are in v6 notation
+    if (exp.ip) {
+        exp.ip = util_ip.toIPAddr(exp.ip).toString({ format: 'v6' });
+    }
+}
 
 
 function afterMoray(t, opts, callback, err, realObj) {
@@ -65,33 +79,72 @@ function afterMoray(t, opts, callback, err, realObj) {
         return doneErr(err, t, callback);
     }
 
-    // Convert numeric MAC addrs to real addresses
-    if (obj.mac) {
-        obj.mac = util_mac.ntoa(obj.mac);
-    }
-
     if (opts.exp) {
         exp = clone(opts.exp);
-        if (exp.ip) {
-            exp.ip = util_ip.toIPAddr(exp.ip).toString({ format: 'v6' });
-        }
-
+        toMorayObj(exp);
         t.deepEqual(obj, exp, 'expected object');
     }
 
     if (opts.partialExp) {
+        exp = clone(opts.partialExp);
+        toMorayObj(exp);
+
         var partialRes = {};
-        for (var p in opts.partialExp) {
+        for (var p in exp) {
             partialRes[p] = obj[p];
         }
 
-        t.deepEqual(partialRes, opts.partialExp, 'partial result');
+        t.deepEqual(partialRes, exp, 'partial result');
     }
 
     return doneRes(obj, t, callback);
 }
 
 
+function afterLogList(t, opts, callback, err, realObj) {
+    assert.optionalArrayOfObject(opts.exp);
+
+    var exp;
+    var obj;
+
+    if (realObj) {
+        obj = clone(realObj);
+    }
+
+    if (opts.expErr) {
+        t.ok(err, 'expected err');
+        if (!err) {
+            t.deepEqual(obj, {}, 'object returned instead of error');
+            doneRes(realObj, t, callback);
+            return;
+        }
+
+        t.deepEqual(err, opts.expErr, 'expected error');
+        doneErr(err, t, callback);
+        return;
+    }
+
+    t.ifErr(err, 'lookup err');
+    if (err) {
+        doneErr(err, t, callback);
+        return;
+    }
+
+    if (opts.exp) {
+        exp = clone(opts.exp);
+        exp.forEach(function (ev) {
+            toMorayObj(ev.record);
+        });
+        obj.forEach(function (ev) {
+            delete ev.id;
+        });
+        t.deepEqual(obj, exp, 'expected array of objects');
+    }
+
+    doneRes(realObj, t, callback);
+}
+
+
 function getMorayClient(callback) {
     if (MORAY_CLIENT) {
         callback(null, MORAY_CLIENT);
@@ -188,9 +241,7 @@ function overlayMapping(t, opts, callback) {
             vl2_vnet_id: vnetID
         };
 
-        mod_portolan_moray.vl2Lookup(vl2Opts,
-                afterMoray.bind(null, t, opts, function () {
-
+        function vl3Check() {
             var vl3Opts = {
                 log: log,
                 moray: client,
@@ -201,7 +252,14 @@ function overlayMapping(t, opts, callback) {
 
             mod_portolan_moray.vl3Lookup(vl3Opts,
                 afterMoray.bind(null, t, opts, callback));
-        }));
+        }
+
+        if (opts.skipVL2) {
+            vl3Check();
+        } else {
+            mod_portolan_moray.vl2Lookup(vl2Opts,
+                afterMoray.bind(null, t, opts, vl3Check));
+        }
     });
 }
 
@@ -233,10 +291,60 @@ function underlayMapping(t, opts, callback) {
 }
 
 
+function logReq(t, opts, callback) {
+    common.assertArgsList(t, opts, callback);
+    assert.string(opts.params.cn_uuid, 'opts.params.cn_uuid');
+
+    opts.type = 'event';
+
+    getMorayClient(function (err, client) {
+        if (err) {
+            callback(err);
+            return;
+        }
+
+        var lookupOpts = {
+            log: log,
+            limit: 1000,
+            moray: client,
+            noCache: true,
+            cnUuid: opts.params.cn_uuid
+        };
+
+        mod_portolan_moray.logReq(lookupOpts,
+            afterLogList.bind(null, t, opts, function (lErr, res) {
+            if (lErr) {
+                doneErr(lErr, t, callback);
+                return;
+            }
+
+            vasync.forEachParallel({
+                inputs: res,
+                func: function (entry, cb) {
+                    mod_portolan_moray.logRm({
+                        log: log,
+                        moray: client,
+                        uuid: entry.id
+                    }, cb);
+                }
+            }, function (dErr) {
+                if (dErr) {
+                    doneErr(dErr, t, callback);
+                    return;
+                }
+
+                doneRes(res, t, callback);
+            });
+        }));
+    });
+}
+
+
 module.exports = {
     closeClient: closeClient,
     notFoundErr: portolanNotFoundErr,
     nicVnetID: nicVnetID,
+    logReq: logReq,
     overlayMapping: overlayMapping,
     underlayMapping: underlayMapping
 };
diff --git a/test/lib/server.js b/test/lib/server.js
index 837ae6d..5240a3c 100644
--- a/test/lib/server.js
+++ b/test/lib/server.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2015, Joyent, Inc.
+ * Copyright 2017, Joyent, Inc.
  */
 
 /*
@@ -16,9 +16,8 @@
 
 var common = require('./common');
 var config = require('./config');
-var FakeWFclient = require('./mock-wf').FakeWFclient;
-var log = require('./log');
-var mock_moray = require('./mock-moray');
+var mod_log = require('./log');
+var moray_sandbox = require('moray-sandbox');
 var mod_client = require('./client');
 var NAPI = require('../../lib/napi').NAPI;
 
@@ -28,26 +27,55 @@ var NAPI = require('../../lib/napi').NAPI;
 
 
 
-var SERVER;
+var MULTI_SUITE_RUN = false;
+var PGHANDLE = null;
+var SERVER = null;
 
 
 
-// --- Exports
+// --- Internals
+
+
+function getPG(log, callback) {
+    if (PGHANDLE !== null) {
+        callback(null, PGHANDLE);
+    } else {
+        moray_sandbox.createPG(log, function (err, pg) {
+            if (pg) {
+                PGHANDLE = pg;
+            }
+            callback(err, pg);
+        });
+    }
+}
 
 
 
+// --- Exports
+
+
 /**
  * Close the server
  */
 function closeServer(t) {
+    function done() {
+        if (!MULTI_SUITE_RUN) {
+            stopPG();
+        }
+
+        t.end();
+    }
+
     if (!SERVER) {
-        t.ok(true, 'no server to close');
-        return t.end();
+        t.pass('no server to close');
+        done();
+        return;
     }
 
     SERVER.stop(function (err) {
+        SERVER = null;
         t.ifErr(err, 'stopping server');
-        return t.end();
+        done();
     });
 }
 
@@ -69,58 +97,105 @@ function createServer(t) {
 }
 
 
+/**
+ * Stops the Postgres server so that it can be cleaned up
+ */
+function stopPG() {
+    if (PGHANDLE !== null) {
+        PGHANDLE.stop();
+        PGHANDLE = null;
+    }
+}
+
+
+/**
+ * Create a new Moray instance, spinning up a new Postgres instance if needed.
+ */
+function setupMoray(log, callback) {
+    getPG(log, function (pgErr, pg) {
+        if (pgErr) {
+            callback(pgErr);
+            return;
+        }
+
+        pg.spawnMoray(callback);
+    });
+}
+
+
 /**
  * Create a test server
  */
 function createTestServer(opts, callback) {
-    var server = new NAPI({
-        config: config.server,
-        log: log.child({
-            component: 'test-server'
-        })
+    if (SERVER !== null) {
+        throw new Error('Cannot run multiple NAPI servers at once!');
+    }
+
+    var log_child = mod_log.child({
+        component: 'test-server'
     });
-    SERVER = server;
 
-    server.wfapi = new FakeWFclient({ log: log });
+    function startWithMoray(err, moray) {
+        if (err) {
+            callback(err);
+            return;
+        }
+
+        var server = new NAPI({
+            config: config.server,
+            log: log_child
+        });
+        SERVER = server;
 
-    if (opts.unitTest) {
         server.initialDataLoaded = true;
-        server.moray = new mock_moray.FakeMoray({ log: log });
-    }
+        server.moray = moray;
 
-    server.on('connected', function _afterConnect() {
-        log.debug('server connected');
-        server.init();
-    });
+        server.on('connected', function _afterConnect() {
+            log_child.debug('server connected');
+            server.init();
+        });
 
-    server.on('initialized', function _afterReady() {
-        log.debug('server initialized');
+        server.on('initialized', function _afterReady() {
+            log_child.debug('server initialized');
 
-        var client = common.createClient(SERVER.info().url);
-        mod_client.set(client);
-        return callback(null, { server: SERVER, client: client });
-    });
+            var client = common.createClient(SERVER.info().url);
+            mod_client.set(client);
+            callback(null, { server: SERVER, client: client, moray: moray });
+        });
 
-    server.start(function _afterStart(startErr) {
-        log.debug('server started');
-        if (startErr) {
-            return callback(startErr);
-        }
+        server.start(function _afterStart(startErr) {
+            log_child.debug('server started');
+            if (startErr) {
+                callback(startErr);
+                return;
+            }
 
-        if (opts.unitTest) {
             // This is normally emitted when the moray client connects, but
-            // we have a mock moray client that doesn't actuall connect to
-            // anything:
+            // we took care of setting the Moray client to the mock ourselves:
             server.emit('connected');
-        }
-    });
+        });
+    }
+
+    if (opts.moray) {
+        startWithMoray(null, opts.moray);
+    } else {
+        setupMoray(log_child, startWithMoray);
+    }
 }
 
 
 
 module.exports = {
+    set MULTI_SUITE_RUN(val) {
+        MULTI_SUITE_RUN = val;
+    },
+    get MULTI_SUITE_RUN() {
+        return MULTI_SUITE_RUN;
+    },
     _create: createTestServer,
     close: closeServer,
     create: createServer,
+    setupMoray: setupMoray,
+    stopPG: stopPG,
     get: function () { return SERVER; }
 };
diff --git a/test/lib/vlan.js b/test/lib/vlan.js
index 8277691..986a6b7 100644
--- a/test/lib/vlan.js
+++ b/test/lib/vlan.js
@@ -116,6 +116,8 @@ function delAllCreatedVLANs(t) {
         return t.end();
     }
 
+    common.clearCreated('vlans');
+
     mod_vasync.forEachParallel({
         inputs: created,
         func: function _delOne(vlan, cb) {
diff --git a/test/unit/aggregations.test.js b/test/unit/aggregations.test.js
index 13c40c1..fe5ed4c 100644
--- a/test/unit/aggregations.test.js
+++ b/test/unit/aggregations.test.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright 2016, Joyent, Inc.
+ * Copyright 2017, Joyent, Inc.
  */
 
 /*
@@ -20,9 +20,9 @@ var clone = require('clone');
 var constants = require('../../lib/util/constants');
 var mod_aggr = require('../lib/aggr');
 var mod_err = require('../../lib/util/errors');
-var mod_moray = require('../lib/moray');
 var mod_nic = require('../lib/nic');
 var mod_nic_tag = require('../lib/nic-tag');
+var mod_server = require('../lib/server');
 var mod_uuid = require('node-uuid');
 var test = require('tape');
 var util = require('util');
@@ -35,6 +35,7 @@ var vasync = require('vasync');
 
 
 
+var MORAY;
 var NAPI;
 var owner = 'e597afe2-b4a6-4842-81d3-f5a7a98404b1';
 var state = {
@@ -154,13 +155,17 @@ function createParamErrs(t, param, baseParams, list) {
 
 
 test('setup', function (t) {
+    h.reset();
+
     t.plan(6);
 
     t.test('create client and server', function (t2) {
-        h.createClientAndServer(function (err, res) {
+        h.createClientAndServer(function (err, res, moray) {
+            MORAY = moray;
             NAPI = res;
             t2.ifError(err, 'server creation');
             t2.ok(NAPI, 'client');
+            t2.ok(MORAY, 'moray');
             t2.end();
         });
     });
@@ -255,14 +260,17 @@ test('create', function (t) {
                 return t2.end();
             }
 
-            var morayObj = mod_moray.getObj('napi_aggregations', exp.id);
-            t2.ok(morayObj, 'got moray object');
-            res.macs = params.macs.map(function (m) {
-                return util_mac.aton(m);
-            });
+            MORAY.getObject('napi_aggregations', exp.id,
+                function (err2, morayObj) {
+                t2.ifError(err2, 'Getting aggregation should succeed');
+                t2.ok(morayObj, 'Got Moray object');
+                res.macs = params.macs.map(function (m) {
+                    return util_mac.aton(m);
+                });
 
-            t2.deepEqual(morayObj, res, 'raw moray object');
-            return t2.end();
+                t2.deepEqual(morayObj.value, res, 'Raw Moray object');
+                t2.end();
+            });
         });
     });
 
@@ -384,7 +392,7 @@ test('create', function (t) {
 
 
     t.test('invalid: nic has wrong belongs_to_type', function (t2) {
-        var macs = [ state.zone_nics[0].mac, state.zone_nics[1].mac ];
+        var macs = [ state.zone_nics[0].mac, state.zone_nics[1].mac ].sort();
 
         mod_aggr.create(t2, {
             params: {
@@ -685,11 +693,6 @@ test('delete', function (t) {
 
 // --- Teardown
 
+test('delete nics', mod_nic.delAllCreated);
 
-
-test('teardown', function (t) {
-    h.stopServer(function (err) {
-        t.ifError(err, 'server stop');
-        return t.end();
-    });
-});
+test('Stop server', mod_server.close);
diff --git a/test/unit/helpers.js b/test/unit/helpers.js
index 9870935..bbb6e25 100644
--- a/test/unit/helpers.js
+++ b/test/unit/helpers.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright 2016, Joyent, Inc.
+ * Copyright 2017, Joyent, Inc.
  */
 
 /*
@@ -35,13 +35,17 @@ var NON_OBJECT_PARAMS = [
     new Boolean(true), // eslint-disable-line
     [ 5 ]
 ];
-var SERVER;
 
 
 
 // --- Exports
 
 
+function reset() {
+    NET_NUM = 2;
+    NET_IPS = {};
+}
+
 
 /**
  * Copies over all keys in from to to
@@ -58,23 +62,26 @@ function copyParams(from, to) {
  * requests)
  */
 function createClient(t) {
-    return common.createClient(SERVER.info().url, t);
+    return common.createClient(mod_server.get().info().url, t);
 }
 
 
 /**
  * Creates a test NAPI server, and returns a client for accessing it
  */
-function createClientAndServer(callback) {
-    mod_server._create({
-        unitTest: true
-    }, function (err, res) {
+function createClientAndServer(opts, callback) {
+    if (callback === undefined) {
+        callback = opts;
+        opts = {};
+    }
+
+    mod_server._create(opts, function (err, res) {
         if (err) {
-            return callback(err);
+            callback(err);
+            return;
         }
 
-        SERVER = res.server;
-        return callback(null, res.client);
+        callback(null, res.client, res.moray);
     });
 }
 
@@ -113,7 +120,7 @@ function missingParam(field, message) {
 /**
  * Get the next provisionable IP address for the network object passed in
  */
-function nextProvisionableIP(net) {
+function nextProvisionableIP(net, willFail) {
     assert.object(net, 'net');
     if (!NET_IPS.hasOwnProperty(net.uuid)) {
         assert.string(net.provision_start_ip, 'net.provision_start_ip');
@@ -122,20 +129,12 @@ function nextProvisionableIP(net) {
     }
 
     var curr = NET_IPS[net.uuid];
-    NET_IPS[net.uuid] = util_ip.ipAddrPlus(curr, 1);
-    return curr.toString();
-}
 
-
-/**
- * Stops the test NAPI server
- */
-function stopServer(callback) {
-    if (!SERVER) {
-        return callback();
+    if (!willFail) {
+        NET_IPS[net.uuid] = util_ip.ipAddrPlus(curr, 1);
     }
 
-    return SERVER.stop(callback);
+    return curr.toString();
 }
 
 
@@ -183,7 +182,7 @@ function validNicparams(override) {
  */
 function validIPv4NetworkParams(override) {
     var newNet = {
-        name: 'myname',
+        name: 'myname' + NET_NUM,
         nic_tag: 'nic_tag',
         provision_end_ip: util.format('10.0.%d.254', NET_NUM),
         provision_start_ip: util.format('10.0.%d.1', NET_NUM),
@@ -208,12 +207,12 @@ function validIPv4NetworkParams(override) {
 function validIPv6NetworkParams(override) {
     var NET_HEX = NET_NUM.toString(16);
     var newNet = {
-        name: 'myname',
+        name: 'myname' + NET_NUM,
         nic_tag: 'nic_tag',
-        provision_end_ip: util.format('fc00:%s::ffff:ffff:ffff:ffff', NET_HEX),
-        provision_start_ip: util.format('fc00:%s::1', NET_HEX),
+        provision_end_ip: util.format('fd00:%s::ffff:ffff:ffff:ffff', NET_HEX),
+        provision_start_ip: util.format('fd00:%s::1', NET_HEX),
         resolvers: ['2001:4860:4860::8888', '2001:4860:4860::8844'],
-        subnet: util.format('fc00:%s::/64', NET_HEX),
+        subnet: util.format('fd00:%s::/64', NET_HEX),
         vlan_id: 0,
         mtu: constants.MTU_DEFAULT
     };
@@ -243,10 +242,7 @@ module.exports = {
     },
     randomMAC: common.randomMAC,
     reqOpts: common.reqOpts,
-    get server() {
-        return SERVER;
-    },
-    stopServer: stopServer,
+    reset: reset,
     uuidSort: common.uuidSort,
     validIPparams: validIPparams,
     validNicparams: validNicparams,
diff --git a/test/unit/ips.test.js b/test/unit/ips.test.js
index 4107705..f93597b 100644
--- a/test/unit/ips.test.js
+++ b/test/unit/ips.test.js
@@ -20,6 +20,7 @@ var common = require('../lib/common');
 var h = require('./helpers');
 var mod_err = require('../../lib/util/errors');
 var mod_uuid = require('node-uuid');
+var mod_server = require('../lib/server');
 var test = require('tape');
 var util = require('util');
 var vasync = require('vasync');
@@ -766,9 +767,4 @@ test('Listing IPv4 failures', function (t) {
 
 
 
-test('Stop server', function (t) {
-    h.stopServer(function (err) {
-        t.ifError(err, 'server stop');
-        t.end();
-    });
-});
+test('Stop server', mod_server.close);
diff --git a/test/unit/network-owner.test.js b/test/unit/network-owner.test.js
index b51de4a..514dffc 100644
--- a/test/unit/network-owner.test.js
+++ b/test/unit/network-owner.test.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2015, Joyent, Inc.
+ * Copyright 2017, Joyent, Inc.
  */
 
 /*
@@ -18,6 +18,7 @@ var constants = require('../../lib/util/constants');
 var helpers = require('./helpers');
 var mod_err = require('../../lib/util/errors');
 var mod_nic = require('../lib/nic');
+var mod_server = require('../lib/server');
 var mod_uuid = require('node-uuid');
 var test = require('tape');
 var util_ip = require('../../lib/util/ip');
@@ -311,6 +312,8 @@ function updatePoolFailure(uuid, params, invalidNets, t) {
 
 
 test('setup', function (t) {
+    helpers.reset();
+
     t.plan(7);
 
     t.test('create client and server', function (t2) {
@@ -547,7 +550,7 @@ test('pool update', function (t) {
 
 
 test('nic provision', function (t) {
-    t.plan(7);
+    t.plan(8);
 
     t.test('on network pool with same owner_uuid', function (t2) {
         return provisionNic(pools[0].uuid, { owner_uuid: owner }, t2,
@@ -565,25 +568,42 @@ test('nic provision', function (t) {
 
 
     t.test('with a different owner_uuid', function (t2) {
-        NAPI.provisionNic(nets[0].uuid, {
+        mod_nic.provision(t2, {
+            net: nets[0].uuid,
+            params: {
                 belongs_to_type: 'zone',
                 belongs_to_uuid: mod_uuid.v4(),
                 owner_uuid: mod_uuid.v4()
-        }, function (err, res) {
-            t2.ok(err, 'error returned');
-            if (!err) {
-                return t2.end();
-            }
-
-            t2.equal(err.statusCode, 422, 'status code');
-            t2.deepEqual(err.body, helpers.invalidParamErr({
+            },
+            expCode: 422,
+            expErr: helpers.invalidParamErr({
                 errors: [
                     mod_err.invalidParam('owner_uuid',
                         constants.OWNER_MATCH_MSG)
                 ]
-            }), 'Error body');
+            })
+        });
+    });
 
-            return t2.end();
+
+    t.test('with a different owner_uuid and no network_uuid', function (t2) {
+        mod_nic.create(t2, {
+            mac: helpers.randomMAC(),
+            params: {
+                belongs_to_type: 'zone',
+                belongs_to_uuid: mod_uuid.v4(),
+                owner_uuid: mod_uuid.v4(),
+                vlan_id: nets[0].vlan_id,
+                nic_tag: nets[0].nic_tag,
+                ip: helpers.nextProvisionableIP(nets[0], true)
+            },
+            expCode: 422,
+            expErr: helpers.invalidParamErr({
+                errors: [
+                    mod_err.invalidParam('owner_uuid',
+                        constants.OWNER_MATCH_MSG)
+                ]
+            })
         });
     });
 
@@ -901,9 +921,4 @@ test('reserve', function (t) {
 
 
 
-test('Stop server', function (t) {
-    helpers.stopServer(function (err) {
-        t.ifError(err, 'server stop');
-        t.end();
-    });
-});
+test('Stop server', mod_server.close);
diff --git a/test/unit/network-pools.test.js b/test/unit/network-pools.test.js
index 67b524b..21be0e2 100644
--- a/test/unit/network-pools.test.js
+++ b/test/unit/network-pools.test.js
@@ -20,11 +20,11 @@ var common = require('../lib/common');
 var constants = require('../../lib/util/constants');
 var h = require('./helpers');
 var mod_err = require('../../lib/util/errors');
-var mod_moray = require('../lib/moray');
 var mod_net = require('../lib/net');
 var mod_nic = require('../lib/nic');
 var mod_tag = require('../lib/nic-tag');
 var mod_pool = require('../lib/pool');
+var mod_server = require('../lib/server');
 var mod_uuid = require('node-uuid');
 var repeat = require('../../lib/util/common').repeat;
 var test = require('tape');
@@ -37,6 +37,7 @@ var vasync = require('vasync');
 
 
 
+var MORAY;
 var NAPI;
 var NETS = [];
 var POOLS = [];
@@ -117,10 +118,15 @@ function createNet(t, extra) {
 
 
 test('Initial setup', function (t) {
-    h.createClientAndServer(function (err, res) {
+    h.reset();
+
+    h.createClientAndServer(function (err, res, moray) {
         t.ifError(err, 'server creation');
         t.ok(res, 'client');
+        t.ok(moray, 'moray');
+
         NAPI = res;
+        MORAY = moray;
 
         if (!NAPI) {
             return t.end();
@@ -672,12 +678,13 @@ test('Update pool: remove owner_uuids', function (t) {
             delete POOLS[1].owner_uuids;
             t2.deepEqual(res, POOLS[1], 'owner_uuids removed');
 
-            var morayObj = mod_moray.getObj('napi_network_pools',
-                POOLS[1].uuid);
-
-            t2.ok(!morayObj.hasOwnProperty('owner_uuids'),
-                'owner_uuids property no longer present in moray');
-            return t2.end();
+            MORAY.getObject('napi_network_pools', POOLS[1].uuid,
+                function (err2, morayObj) {
+                t2.ifError(err2, 'Getting pool should succeed');
+                t2.ok(!morayObj.value.hasOwnProperty('owner_uuids'),
+                    'owner_uuids property no longer present in moray');
+                t2.end();
+            });
         });
     });
 
@@ -703,14 +710,15 @@ test('Update pool: remove owner_uuids', function (t) {
             POOLS[1].owner_uuids = params.owner_uuids.sort();
             t2.deepEqual(res, POOLS[1], 'owner_uuids added');
 
-            var morayObj = mod_moray.getObj('napi_network_pools',
-                POOLS[1].uuid);
-            t2.ok(morayObj, 'got moray object');
-
-            t2.equal(morayObj.owner_uuids, ','
-                + params.owner_uuids.sort().join(',') + ',',
-                'owner_uuids updated in moray');
-            return t2.end();
+            MORAY.getObject('napi_network_pools', POOLS[1].uuid,
+                function (err2, morayObj) {
+                t2.ifError(err2, 'Getting pool should succeed');
+                t2.ok(morayObj, 'got moray object');
+                t2.equal(morayObj.value.owner_uuids, ','
+                    + params.owner_uuids.sort().join(',') + ',',
+                    'owner_uuids updated in moray');
+                t2.end();
+            });
         });
     });
 
@@ -1039,6 +1047,53 @@ test('Provision nic - on network pool', function (t) {
 
 
 
+test('Provision NIC on pool: Retry after QueryTimeoutErrors', function (t) {
+    var params = {
+        belongs_to_type: 'zone',
+        belongs_to_uuid: mod_uuid.v4(),
+        owner_uuid: mod_uuid.v4()
+    };
+
+    var fakeErr = new Error('Timed out');
+    fakeErr.name = 'QueryTimeoutError';
+
+    /*
+     * The sql() error will prevent NAPI from selecting an IP from
+     * the network. It will then retry, and fail to submit with
+     * batch(). After these errors, it will still use the originally
+     * selected IP, since it didn't actually need to change.
+     */
+    MORAY.setMockErrors({
+        sql: [ fakeErr ],
+        batch: [ fakeErr, fakeErr, fakeErr ]
+    });
+
+    t.test('NIC provision', function (t2) {
+        mod_nic.provision(t2, {
+            net: POOLS[1].uuid,
+            params: params,
+            exp: mod_nic.addDefaultParams({
+                belongs_to_type: params.belongs_to_type,
+                belongs_to_uuid: params.belongs_to_uuid,
+                owner_uuid: params.owner_uuid,
+                ip: h.nextProvisionableIP(NETS[4])
+            }, NETS[4])
+        });
+    });
+
+    t.test('Confirm that NAPI hit the errors', function (t2) {
+        // Make sure we actually hit all of the errors:
+        t2.deepEqual(MORAY.getMockErrors(), {
+            sql: [ ],
+            batch: [ ]
+        }, 'no more batch errors left');
+        t2.end();
+    });
+});
+
+
+
+
 // --- Delete tests
 
 
@@ -1072,11 +1127,6 @@ test('Delete network in IPv6 pool', function (t) {
 
 // --- Teardown
 
+test('delete nics', mod_nic.delAllCreated);
 
-
-test('Stop server', function (t) {
-    h.stopServer(function (err) {
-        t.ifError(err, 'server stop');
-        t.end();
-    });
-});
+test('Stop server', mod_server.close);
diff --git a/test/unit/networks.test.js b/test/unit/networks.test.js
index 43243f1..9a13b76 100644
--- a/test/unit/networks.test.js
+++ b/test/unit/networks.test.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright 2016, Joyent, Inc.
+ * Copyright 2017, Joyent, Inc.
  */
 
 /*
@@ -23,6 +23,7 @@ var mod_err = require('../../lib/util/errors');
 var mod_ip = require('../../lib/models/ip');
 var mod_moray = require('../lib/moray');
 var mod_net = require('../lib/net');
+var mod_server = require('../lib/server');
 var mod_test_err = require('../lib/err');
 var mod_uuid = require('node-uuid');
 var test = require('tape');
@@ -39,6 +40,7 @@ var CONF = require('../config.json');
 // 65 character string:
 var LONG_STR =
     'xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx';
+var MORAY;
 var NAPI;
 var TAG;
 var MSG = {
@@ -58,10 +60,14 @@ var USE_STRINGS = true;
 
 
 test('Initial setup', function (t) {
-    h.createClientAndServer(function (err, res) {
+    h.reset();
+
+    h.createClientAndServer(function (err, res, moray) {
         t.ifError(err, 'server creation');
         t.ok(res, 'client');
+        t.ok(moray, 'moray');
         NAPI = res;
+        MORAY = moray;
         if (!NAPI) {
             t.end();
         }
@@ -904,14 +910,16 @@ test('Update provision range', function (t) {
             });
 
         }, function (_, cb) {
-            t.deepEqual(mod_moray.getIPs(net.uuid), [
-                placeholderRec('10.1.2.9'),
-                placeholderRec('10.1.2.251'),
-                adminOtherRec('10.1.2.255')
-            ], 'moray IPs');
-
-            return cb();
+            mod_moray.getIPs(MORAY, net.uuid, function (err, ips) {
+                t.ifError(err, 'Getting IPs shouldn\'t fail');
+                t.deepEqual(ips, [
+                    placeholderRec('10.1.2.9'),
+                    placeholderRec('10.1.2.251'),
+                    adminOtherRec('10.1.2.255')
+                ], 'Moray IPs');
 
+                cb();
+            });
         }, function (_, cb) {
             var ip = '10.1.2.19';
             var params = {
@@ -971,17 +979,18 @@ test('Update provision range', function (t) {
             });
 
         }, function (_, cb) {
-            t.deepEqual(mod_moray.getIPs(net.uuid), [
-                placeholderRec('10.1.2.9'),
-                zoneRec('10.1.2.19'),
-                zoneRec('10.1.2.241'),
-                placeholderRec('10.1.2.251'),
-                adminOtherRec('10.1.2.255')
-            ], 'moray list after first update');
-
-            return cb();
-
+            mod_moray.getIPs(MORAY, net.uuid, function (err, ips) {
+                t.ifError(err, 'Getting IPs shouldn\'t fail');
+                t.deepEqual(ips, [
+                    placeholderRec('10.1.2.9'),
+                    zoneRec('10.1.2.19'),
+                    zoneRec('10.1.2.241'),
+                    placeholderRec('10.1.2.251'),
+                    adminOtherRec('10.1.2.255')
+                ], 'moray list after first update');
 
+                cb();
+            });
         }, function (_, cb) {
             var updates = [
                 {
@@ -1134,16 +1143,19 @@ test('Update provision range', function (t) {
                         t.equal(res2[ip], p[ip], u.desc + ': ' + ip);
                     });
 
-                    t.deepEqual(mod_moray.getIPs(net.uuid), u.morayAfter,
-                        u.desc + ': moray');
+                    mod_moray.getIPs(MORAY, net.uuid, function (mErr, ipObjs) {
+                        t.ifError(mErr, 'Getting IPs shouldn\'t fail');
+                        t.deepEqual(ipObjs, u.morayAfter, u.desc + ': moray');
 
-                    NAPI.listIPs(net.uuid, function (err3, ips) {
-                        if (h.ifErr(t, err3, u.desc + ': listing IPs')) {
-                            return cb2(err3);
-                        }
+                        NAPI.listIPs(net.uuid, function (err3, ips) {
+                            if (h.ifErr(t, err3, u.desc + ': listing IPs')) {
+                                cb2(err3);
+                                return;
+                            }
 
-                        t.deepEqual(ips, u.ipList, u.desc + ': IP list');
-                        return cb2();
+                            t.deepEqual(ips, u.ipList, u.desc + ': IP list');
+                            cb2();
+                        });
                     });
                 });
             }
@@ -1282,7 +1294,7 @@ test('Update network - invalid parameters', function (t) {
 
 
 test('Update network - unset owner_uuids', function (t) {
-    t.plan(14);
+    t.plan(16);
 
     var exp;
     var networks = [];
@@ -1304,16 +1316,19 @@ test('Update network - unset owner_uuids', function (t) {
 
     t.test('moray state after create', function (t2) {
         exp = networks[0];
-        var obj = mod_moray.getObj('napi_networks', exp.uuid);
-        t2.ok(obj, 'Have moray obj');
-
-        if (obj) {
-            t2.equal(obj.owner_uuids, ',' + owners.join(',') + ',',
-                'owner_uuids');
-            t2.deepEqual(obj.owner_uuids_arr, owners, 'owner_uuids_arr');
-        }
+        MORAY.getObject('napi_networks', exp.uuid, function (err, obj) {
+            t2.ifError(err, 'Getting network shouldn\'t fail');
+            t2.ok(obj, 'Have Moray obj');
+
+            if (obj) {
+                obj = obj.value;
+                t2.equal(obj.owner_uuids, ',' + owners.join(',') + ',',
+                    'owner_uuids');
+                t2.deepEqual(obj.owner_uuids_arr, owners, 'owner_uuids_arr');
+            }
 
-        return t2.end();
+            t2.end();
+        });
     });
 
     t.test('list after create', function (t2) {
@@ -1352,17 +1367,20 @@ test('Update network - unset owner_uuids', function (t) {
 
     t.test('moray state after update', function (t2) {
         exp = networks[0];
-        var obj = mod_moray.getObj('napi_networks', exp.uuid);
-        t2.ok(obj, 'Have moray obj');
-
-        if (obj) {
-            t2.ok(!obj.hasOwnProperty('owner_uuids'),
-                'no owner_uuids property');
-            t2.ok(!obj.hasOwnProperty('owner_uuids_arr'),
-                'no owner_uuids property');
-        }
+        MORAY.getObject('napi_networks', exp.uuid, function (err, obj) {
+            t2.ifError(err, 'Getting network shouldn\'t fail');
+            t2.ok(obj, 'Have Moray obj');
+
+            if (obj) {
+                obj = obj.value;
+                t2.ok(!obj.hasOwnProperty('owner_uuids'),
+                    'no owner_uuids property');
+                t2.ok(!obj.hasOwnProperty('owner_uuids_arr'),
+                    'no owner_uuids property');
+            }
 
-        return t2.end();
+            t2.end();
+        });
     });
 
     t.test('list after update', function (t2) {
@@ -1404,26 +1422,28 @@ test('Update network - unset owner_uuids', function (t) {
 
     t.test('moray state after empty array create', function (t2) {
         exp = networks[1];
-        var obj = mod_moray.getObj('napi_networks', exp.uuid);
-        t2.ok(obj, 'Have moray obj');
-
-        if (obj) {
-            t2.ok(!obj.hasOwnProperty('owner_uuids'),
-                'no owner_uuids property');
-            t2.ok(!obj.hasOwnProperty('owner_uuids_arr'),
-                'no owner_uuids_arr property');
-        }
+        MORAY.getObject('napi_networks', exp.uuid, function (err, obj) {
+            t2.ifError(err, 'Getting network shouldn\'t fail');
+            t2.ok(obj, 'Have Moray obj');
+
+            if (obj) {
+                obj = obj.value;
+                t2.ok(!obj.hasOwnProperty('owner_uuids'),
+                    'no owner_uuids property');
+                t2.ok(!obj.hasOwnProperty('owner_uuids_arr'),
+                    'no owner_uuids_arr property');
+            }
 
-        return t2.end();
+            t2.end();
+        });
     });
 
     t.test('list after empty create', function (t2) {
-        mod_net.get(t2, {
+        mod_net.list(t2, {
             params: {
-                provisionable_by: owners[1],
-                uuid: exp.uuid
+                provisionable_by: owners[1]
             },
-            exp: exp
+            present: [ exp ]
         });
     });
 
@@ -1437,16 +1457,29 @@ test('Update network - unset owner_uuids', function (t) {
         });
     });
 
-    t.test('get after moray object change', function (t2) {
-        var obj = mod_moray.getObj('napi_networks', exp.uuid);
-        obj.owner_uuids = ',,';
+    t.test('NAPI-186: owner_uuids=",," should be okay', function (t2) {
+        // The string ',,' should be okay to return from Moray.
+        MORAY.getObject('napi_networks', exp.uuid, function (gErr, res) {
+            if (h.ifErr(t2, gErr, 'getObject() error')) {
+                t2.end();
+                return;
+            }
 
-        mod_net.get(t2, {
-            params: {
-                provisionable_by: owners[1],
-                uuid: exp.uuid
-            },
-            exp: exp
+            delete res.value.owner_uuids_arr;
+            res.value.owner_uuids = ',,';
+
+            MORAY.putObject('napi_networks', exp.uuid, res.value,
+                function (pErr) {
+                t2.ifError(pErr, 'Putting new network object should succeed');
+
+                mod_net.get(t2, {
+                    params: {
+                        provisionable_by: owners[1],
+                        uuid: exp.uuid
+                    },
+                    exp: exp
+                });
+            });
         });
     });
 
@@ -1458,6 +1491,41 @@ test('Update network - unset owner_uuids', function (t) {
             } ]
         });
     });
+
+    t.test('owner_uuids_arr=[] should be okay', function (t2) {
+        // An empty array should be okay to return from Moray.
+        MORAY.getObject('napi_networks', exp.uuid, function (gErr, res) {
+            if (h.ifErr(t2, gErr, 'getObject() error')) {
+                t2.end();
+                return;
+            }
+
+            res.value.owner_uuids_arr = [];
+            exp.owner_uuids = [];
+
+            MORAY.putObject('napi_networks', exp.uuid, res.value,
+                function (pErr) {
+                t2.ifError(pErr, 'Putting new network object should succeed');
+
+                mod_net.get(t2, {
+                    params: {
+                        provisionable_by: owners[1],
+                        uuid: exp.uuid
+                    },
+                    exp: exp
+                });
+            });
+        });
+    });
+
+    t.test('list after moray object change', function (t2) {
+        mod_net.list(t2, {
+            present: [ {
+                uuid: exp.uuid,
+                owner_uuids: []
+            } ]
+        });
+    });
 });
 
 
@@ -1488,9 +1556,4 @@ test('Listing Network failures', function (t) {
 
 
 
-test('Stop server', function (t) {
-    h.stopServer(function (err) {
-        t.ifError(err, 'server stop');
-        t.end();
-    });
-});
+test('Stop server', mod_server.close);
diff --git a/test/unit/nic-tags.test.js b/test/unit/nic-tags.test.js
index de911a5..8b49620 100644
--- a/test/unit/nic-tags.test.js
+++ b/test/unit/nic-tags.test.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2015, Joyent, Inc.
+ * Copyright 2017, Joyent, Inc.
  */
 
 /*
@@ -18,7 +18,7 @@ var assert = require('assert-plus');
 var common = require('../lib/common');
 var h = require('./helpers');
 var mod_err = require('../../lib/util/errors');
-var mod_moray = require('../lib/moray');
+var mod_server = require('../lib/server');
 var constants = require('../../lib/util/constants');
 var test = require('tape');
 
@@ -29,6 +29,7 @@ var test = require('tape');
 
 
 var INVALID_MSG = 'must only contain numbers, letters and underscores';
+var MORAY;
 var NAPI;
 var cur = 0;
 
@@ -58,10 +59,14 @@ function newTag(t, callback) {
 
 
 test('Create client and server', function (t) {
-    h.createClientAndServer(function (err, res) {
+    h.reset();
+
+    h.createClientAndServer(function (err, res, moray) {
         t.ifError(err, 'server creation');
         t.ok(res, 'client');
+        t.ok(moray, 'moray');
         NAPI = res;
+        MORAY = moray;
         t.end();
     });
 });
@@ -74,26 +79,29 @@ test('Create client and server', function (t) {
 test('Create nic tag', function (t) {
     NAPI.createNicTag('newtagname', function (err, obj, req, res) {
         if (h.ifErr(t, err, 'nic tag create')) {
-            return t.end();
+            t.end();
+            return;
         }
 
-        var added = mod_moray.getObj('napi_nic_tags', 'newtagname');
         t.equal(res.statusCode, 200, 'status code');
-        var expObj = {
-            name: 'newtagname',
-            uuid: added.uuid,
-            mtu: constants.MTU_DEFAULT
-        };
-        t.deepEqual(obj, expObj, 'create response');
-
-        NAPI.getNicTag('newtagname', function (err2, res2) {
-            if (h.ifErr(t, err2, 'nic tag get')) {
-                return t.end();
-            }
-
-            t.deepEqual(res2, expObj, 'get response');
+        MORAY.getObject('napi_nic_tags', 'newtagname', function (mErr, added) {
+            t.ifError(mErr, 'Getting NIC tag should succeed');
+            var expObj = {
+                name: 'newtagname',
+                uuid: added.value.uuid,
+                mtu: constants.MTU_DEFAULT
+            };
+            t.deepEqual(obj, expObj, 'create response');
+
+            NAPI.getNicTag('newtagname', function (err2, res2) {
+                if (h.ifErr(t, err2, 'nic tag get')) {
+                    t.end();
+                    return;
+                }
 
-            return t.end();
+                t.deepEqual(res2, expObj, 'get response');
+                t.end();
+            });
         });
     });
 });
@@ -181,25 +189,30 @@ test('Create nic tag - with MTU', function (t) {
     NAPI.createNicTag('newtagnamemtu', { mtu: constants.MTU_MAX },
         function (err, obj, req, res) {
         if (h.ifErr(t, err, 'nic tag create - MTU')) {
-            return t.end();
+            t.end();
+            return;
         }
 
-        var added = mod_moray.getObj('napi_nic_tags', 'newtagnamemtu');
         t.equal(res.statusCode, 200, 'status code - MTU');
-        var expObj = {
-            name: 'newtagnamemtu',
-            uuid: added.uuid,
-            mtu: constants.MTU_MAX
-        };
-        t.deepEqual(obj, expObj, 'create response - MTU');
-
-        NAPI.getNicTag('newtagnamemtu', function (_err, _obj) {
-            if (h.ifErr(t, _err, 'nic tag get - MTU')) {
-                return t.end();
-            }
+        MORAY.getObject('napi_nic_tags', 'newtagnamemtu',
+            function (mErr, added) {
+            t.ifError(mErr, 'Getting NIC tag should succeed');
+            var expObj = {
+                name: 'newtagnamemtu',
+                uuid: added.value.uuid,
+                mtu: constants.MTU_MAX
+            };
+            t.deepEqual(obj, expObj, 'create response - MTU');
+
+            NAPI.getNicTag('newtagnamemtu', function (gErr, tagObj) {
+                if (h.ifErr(t, gErr, 'nic tag get - MTU')) {
+                    t.end();
+                    return;
+                }
 
-            t.deepEqual(_obj, expObj, 'get response - MTU');
-            return t.end();
+                t.deepEqual(tagObj, expObj, 'get response - MTU');
+                t.end();
+            });
         });
     });
 });
@@ -268,29 +281,33 @@ test('Create admin nic tag - with default MTU', function (t) {
     NAPI.createNicTag('admin', { mtu: constants.MTU_DEFAULT },
         function (err, obj, req, res) {
         if (h.ifErr(t, err, 'nic tag create ')) {
-            return t.end();
+            t.end();
+            return;
         }
 
-        var added = mod_moray.getObj('napi_nic_tags', 'admin');
         t.equal(res.statusCode, 200, 'status code');
-        var expObj = {
-            name: 'admin',
-            uuid: added.uuid,
-            mtu: constants.MTU_DEFAULT
-        };
-        t.deepEqual(obj, expObj, 'create response');
-
-        NAPI.getNicTag('admin', function (_err, _obj) {
-            if (h.ifErr(t, _err, 'nic tag get')) {
-                return t.end();
-            }
+        MORAY.getObject('napi_nic_tags', 'admin', function (mErr, added) {
+            t.ifError(mErr, 'Getting NIC tag should succeed');
+            var expObj = {
+                name: 'admin',
+                uuid: added.value.uuid,
+                mtu: constants.MTU_DEFAULT
+            };
+            t.deepEqual(obj, expObj, 'create response');
+
+            NAPI.getNicTag('admin', function (gErr, _obj) {
+                if (h.ifErr(t, gErr, 'nic tag get')) {
+                    t.end();
+                    return;
+                }
 
-            t.deepEqual(_obj, expObj, 'get response');
+                t.deepEqual(_obj, expObj, 'get response');
 
-            // clean up 'admin' nictag, tested elsewhere.
-            return NAPI.deleteNicTag('admin', function (__err) {
-                t.ifError(__err, 'err cleaning up admin nic tag');
-                return t.end();
+                // clean up 'admin' nictag, tested elsewhere.
+                NAPI.deleteNicTag('admin', function (dErr) {
+                    t.ifError(dErr, 'err cleaning up admin nic tag');
+                    t.end();
+                });
             });
         });
     });
@@ -800,9 +817,4 @@ test('Listing Nic Tag failures', function (t) {
 // --- Teardown
 
 
-test('Stop server', function (t) {
-    h.stopServer(function (err) {
-        t.ifError(err, 'server stop');
-        t.end();
-    });
-});
+test('Stop server', mod_server.close);
diff --git a/test/unit/nics.test.js b/test/unit/nics.test.js
index b77f958..9377a8a 100644
--- a/test/unit/nics.test.js
+++ b/test/unit/nics.test.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright 2016, Joyent, Inc.
+ * Copyright 2017, Joyent, Inc.
  */
 
 /*
@@ -16,16 +16,17 @@
 
 var common = require('../lib/common');
 var constants = require('../../lib/util/constants');
-var extend = require('xtend');
 var fmt = require('util').format;
 var h = require('./helpers');
 var ip_common = require('../../lib/models/ip/common');
 var mod_err = require('../../lib/util/errors');
 var mod_ip = require('../lib/ip');
+var mod_jsprim = require('jsprim');
 var mod_moray = require('../lib/moray');
 var mod_net = require('../lib/net');
 var mod_nic = require('../lib/nic');
 var mod_nicTag = require('../lib/nic-tag');
+var mod_server = require('../lib/server');
 var mod_uuid = require('node-uuid');
 var test = require('tape');
 var util = require('util');
@@ -33,6 +34,7 @@ var util_ip = require('../../lib/util/ip');
 var util_mac = require('../../lib/util/mac');
 var vasync = require('vasync');
 
+var extend = mod_jsprim.mergeObjects;
 
 
 // --- Globals
@@ -40,10 +42,12 @@ var vasync = require('vasync');
 
 
 var ADMIN_NET;
+var MORAY;
 var NAPI;
 var NET;
 var NET2;
 var NET3;
+var NET4;
 var PROV_MAC_NET;
 
 
@@ -56,14 +60,18 @@ var BAD_TYPE_ERRMSG = 'must be one of: "other", "server", "zone"';
 
 
 test('Initial setup', function (t) {
+    h.reset();
+
     var num = h.NET_NUM;
     var netParams = h.validNetworkParams();
 
     t.test('create client and server', function (t2) {
-        h.createClientAndServer(function (err, res) {
+        h.createClientAndServer(function (err, res, moray) {
             t2.ifError(err, 'server creation');
             t2.ok(res, 'client');
+            t2.ok(moray, 'moray');
             NAPI = res;
+            MORAY = moray;
 
             t2.end();
         });
@@ -75,6 +83,12 @@ test('Initial setup', function (t) {
         });
     });
 
+    t.test('create nic_tag2', function (t2) {
+        mod_nicTag.create(t2, {
+            name: 'nic_tag2'
+        });
+    });
+
     t.test('create net', function (t2) {
         mod_net.create(t2, {
             params: netParams,
@@ -121,6 +135,26 @@ test('Initial setup', function (t) {
         });
     });
 
+    t.test('create net4', function (t2) {
+        num = h.NET_NUM;
+        var params = h.validNetworkParams({
+            vlan_id: NET2.vlan_id,
+            nic_tag: NET2.nic_tag,
+            subnet: NET2.subnet,
+            provision_start_ip: NET2.provision_start_ip,
+            provision_end_ip: NET2.provision_end_ip
+        });
+        mod_net.create(t2, {
+            params: params,
+            partialExp: params
+        }, function (_, res) {
+            NET4 = res;
+            NET4.num = num;
+
+            t2.end();
+        });
+    });
+
     t.test('create admin net', function (t2) {
         num = h.NET_NUM;
         var params = h.validNetworkParams({ name: 'admin' });
@@ -370,10 +404,28 @@ test('Create nic - invalid params', function (t) {
         [ 'nic_tag and vlan_id do not match any networks',
             { ip: '10.0.2.3', belongs_to_type: type, belongs_to_uuid: uuid,
                 nic_tag: NET.nic_tag, owner_uuid: owner, vlan_id: 656 },
-                [ mod_err.invalidParam('nic_tag',
-                    'No networks found matching parameters'),
-                mod_err.invalidParam('vlan_id',
-                    'No networks found matching parameters') ] ],
+                [ mod_err.invalidParam('ip', util.format(
+                    constants.fmt.IP_NONET, NET.nic_tag, 656, '10.0.2.3')) ] ],
+
+        [ 'nic_tag and vlan_id present, IP matches multiple subnets',
+            { ip: h.nextProvisionableIP(NET2, true), belongs_to_type: type,
+                belongs_to_uuid: uuid, nic_tag: NET2.nic_tag,
+                owner_uuid: owner, vlan_id: NET2.vlan_id },
+                [ mod_err.invalidParam('ip', util.format(constants.fmt.IP_MULTI,
+                    [ NET2.uuid, NET4.uuid ].sort().join(', '),
+                    h.nextProvisionableIP(NET2, true))) ] ],
+
+        [ 'vlan_id different between NIC parameters and network',
+            { belongs_to_type: type, belongs_to_uuid: uuid, owner_uuid: owner,
+                network_uuid: NET.uuid, vlan_id: 47 },
+                [ mod_err.invalidParam('network_uuid', util.format(
+                    constants.fmt.VLAN_IDS_DIFFER, 47, 0)) ] ],
+
+        [ 'nic_tag different between NIC parameters and network',
+            { belongs_to_type: type, belongs_to_uuid: uuid, owner_uuid: owner,
+                network_uuid: NET.uuid, nic_tag: 'nic_tag2' },
+                [ mod_err.invalidParam('network_uuid', util.format(
+                    constants.fmt.NIC_TAGS_DIFFER, 'nic_tag2', 'nic_tag')) ] ],
 
         [ 'belongs_to_type must be a valid value',
             { ip: '10.0.2.3', belongs_to_type: 'router', belongs_to_uuid: uuid,
@@ -470,7 +522,7 @@ test('Create nic - invalid params', function (t) {
 
 
 test('Create nic - empty nic_tags_provided', function (t) {
-    t.plan(8);
+    t.plan(9);
     var d = {};
 
     t.test('create', function (t2) {
@@ -527,6 +579,16 @@ test('Create nic - empty nic_tags_provided', function (t) {
         });
     });
 
+    t.test('search for nic_tags_provided=tag52', function (t2) {
+        mod_nic.list(t2, {
+            params: {
+                nic_tags_provided: [ 'tag52' ]
+            },
+            deepEqual: true,
+            present: [ d.exp ]
+        });
+    });
+
     t.test('unset nic_tags_provided', function (t2) {
         delete d.exp.nic_tags_provided;
 
@@ -540,11 +602,12 @@ test('Create nic - empty nic_tags_provided', function (t) {
     });
 
     t.test('moray: after update', function (t2) {
-        var mNic = mod_moray.getNic(d.exp.mac);
-        t2.ok(!mNic.hasOwnProperty('nic_tags_provided'),
-            'nic_tags_provided unset on moray object');
-
-        return t2.end();
+        mod_moray.getNic(MORAY, d.exp.mac, function (err, mNic) {
+            t2.ifError(err, 'Should get the NIC successfully');
+            t2.ok(!mNic.hasOwnProperty('nic_tags_provided'),
+                'nic_tags_provided unset on moray object');
+            t2.end();
+        });
     });
 
     t.test('set nic_tags_provided again', function (t2) {
@@ -670,105 +733,227 @@ test('Provision nic: exceed MAC retries', function (t) {
         belongs_to_uuid: mod_uuid.v4(),
         owner_uuid: mod_uuid.v4()
     };
-    var numNicsBefore = mod_moray.getNics().length;
+    var numNicsBefore;
 
-    var errs = [ ];
-    for (var i = 0; i < constants.MAC_RETRIES + 1; i++) {
-        var fakeErr = new Error('Already exists');
-        fakeErr.name = 'EtagConflictError';
-        fakeErr.context = { bucket: 'napi_nics' };
-        errs.push(fakeErr);
-    }
-    mod_moray.setErrors({ batch: errs });
+    t.test('Get count of NICs before', function (t2) {
+        mod_moray.countNics(MORAY, function (err, count) {
+            t2.ifError(err, 'Count should succeed');
+            numNicsBefore = count;
+            t2.end();
+        });
+    });
 
-    NAPI.provisionNic(PROV_MAC_NET.uuid, params, function (err) {
-        t.ok(err, 'error returned');
-        if (!err) {
-            return t.end();
+    t.test('Provision new NIC', function (t2) {
+        var errs = [ ];
+        for (var i = 0; i < constants.MAC_RETRIES + 1; i++) {
+            var fakeErr = new Error('Already exists');
+            fakeErr.name = 'EtagConflictError';
+            fakeErr.context = { bucket: 'napi_nics' };
+            errs.push(fakeErr);
         }
+        MORAY.setMockErrors({ batch: errs });
 
-        t.equal(err.statusCode, 500, 'status code');
-        t.deepEqual(err.body, {
-            code: 'InternalError',
-            message: 'no more free MAC addresses'
-        }, 'Error body');
+        NAPI.provisionNic(PROV_MAC_NET.uuid, params, function (err) {
+            t2.ok(err, 'error returned');
+            if (!err) {
+                t2.end();
+                return;
+            }
+
+            t2.equal(err.statusCode, 500, 'status code');
+            t2.deepEqual(err.body, {
+                code: 'InternalError',
+                message: 'no more free MAC addresses'
+            }, 'Error body');
+
+            t2.end();
+        });
+    });
 
-        // Confirm that the IP was freed
+    t.test('Confirm that the IP is free', function (t2) {
         NAPI.getIP(PROV_MAC_NET.uuid, PROV_MAC_NET.provision_start_ip,
             function (err2, res) {
-            if (h.ifErr(t, err2, 'getIP error')) {
-                return t.end();
+            if (h.ifErr(t2, err2, 'getIP error')) {
+                t2.end();
+                return;
             }
 
-            t.equal(res.free, true, 'IP has been freed');
-            var ipRec = mod_moray.getIP(PROV_MAC_NET.uuid,
-                PROV_MAC_NET.provision_start_ip);
-            t.ok(!ipRec, 'IP record does not exist in moray');
+            t2.equal(res.free, true, 'IP has been freed');
+            mod_moray.getIP(MORAY, PROV_MAC_NET.uuid,
+                PROV_MAC_NET.provision_start_ip, function (err3, ipRec) {
+                t2.ok(err3, 'Getting IP should fail');
+                t2.ok(!ipRec, 'IP record does not exist in moray');
 
-            t.equal(mod_moray.getNics().length, numNicsBefore,
-                'no new nic records added');
+                mod_moray.countNics(MORAY, function (err4, numNicsAfter) {
+                    t2.ifError(err4, 'Count should succeed');
+                    t2.equal(numNicsAfter, numNicsBefore,
+                        'no new nic records added');
 
-            // Make sure we actually hit all of the errors:
-            t.deepEqual(mod_moray.getErrors(), {
-                batch: [ ]
-            }, 'no more batch errors left');
+                    // Make sure we actually hit all of the errors:
+                    t2.deepEqual(MORAY.getMockErrors(), {
+                        batch: [ ]
+                    }, 'no more batch errors left');
 
-            return t.end();
+                    t2.end();
+                });
+            });
         });
     });
 });
 
 
 test('Provision nic: exceed IP retries', function (t) {
+    var numNicsBefore;
     var params = {
         belongs_to_type: 'zone',
         belongs_to_uuid: mod_uuid.v4(),
         owner_uuid: mod_uuid.v4()
     };
-    var numNicsBefore = mod_moray.getNics().length;
 
-    var errs = [ ];
+    var startIP = h.nextProvisionableIP(PROV_MAC_NET, true);
+    var ips = [];
     for (var i = 0; i < constants.IP_PROVISION_RETRIES + 2; i++) {
-        var fakeErr = new Error('Already exists');
-        fakeErr.name = 'EtagConflictError';
-        fakeErr.context = { bucket: ip_common.bucketName(PROV_MAC_NET.uuid) };
-        errs.push(fakeErr);
+        ips.push(util_ip.ipAddrPlus(util_ip.toIPAddr(startIP), i).toString());
     }
-    mod_moray.setErrors({ batch: errs });
 
-    NAPI.provisionNic(PROV_MAC_NET.uuid, params, function (err) {
-        t.ok(err, 'error returned');
-        if (!err) {
-            return t.end();
-        }
+    t.test('Count NICs before provision attempt', function (t2) {
+        mod_moray.countNics(MORAY, function (err, count) {
+            t2.ifError(err, 'Count should succeed');
+            numNicsBefore = count;
+            t2.end();
+        });
+    });
 
-        t.equal(err.statusCode, 507, 'status code');
-        t.deepEqual(err.body, {
-            code: 'SubnetFull',
-            message: constants.SUBNET_FULL_MSG
-        }, 'Error body');
+    t.test('Attempt NIC provision', function (t2) {
+        var errs = ips.map(function (curr) {
+            var fakeErr = new Error('Already exists');
+            fakeErr.name = 'EtagConflictError';
+            fakeErr.context = {
+                bucket: ip_common.bucketName(PROV_MAC_NET.uuid),
+                key: curr
+            };
+            return fakeErr;
+        });
+        MORAY.setMockErrors({ batch: errs });
 
-        // Confirm that the IP was freed
-        NAPI.getIP(PROV_MAC_NET.uuid, PROV_MAC_NET.provision_start_ip,
-            function (err2, res) {
-            if (h.ifErr(t, err2, 'getIP error')) {
-                return t.end();
+        mod_nic.provision(t2, {
+            net: PROV_MAC_NET.uuid,
+            params: params,
+            expCode: 507,
+            expErr: {
+                code: 'SubnetFull',
+                message: constants.SUBNET_FULL_MSG,
+                network_uuid: PROV_MAC_NET.uuid
             }
+        });
+    });
 
-            t.equal(res.free, true, 'IP has been freed');
-            var ipRec = mod_moray.getIP(PROV_MAC_NET.uuid,
-                PROV_MAC_NET.provision_start_ip);
-            t.ok(!ipRec, 'IP record does not exist in moray');
+    t.test('No new NICs created', function (t2) {
+        // Make sure we actually hit all of the errors:
+        t2.deepEqual(MORAY.getMockErrors(), {
+            batch: [ ]
+        }, 'no more batch errors left');
 
-            t.equal(mod_moray.getNics().length, numNicsBefore,
+        mod_moray.countNics(MORAY, function (err4, numNicsAfter) {
+            t2.ifError(err4, 'Counting NICs should succeed');
+            t2.equal(numNicsAfter, numNicsBefore,
                 'no new nic records added');
+            t2.end();
+        });
+    });
 
-            // Make sure we actually hit all of the errors:
-            t.deepEqual(mod_moray.getErrors(), {
-                batch: [ ]
-            }, 'no more batch errors left');
+    ips.forEach(function (ip) {
+        t.test('Confirm that the IP is free: ' + ip, function (t2) {
+            NAPI.getIP(PROV_MAC_NET.uuid, ip, function (err2, res) {
+                if (h.ifErr(t2, err2, 'getIP error')) {
+                    t2.end();
+                    return;
+                }
+
+                t2.equal(res.free, true, 'IP has been freed');
+                mod_moray.getIP(MORAY, PROV_MAC_NET.uuid,
+                    PROV_MAC_NET.provision_start_ip, function (err3, ipRec) {
+                    t2.ok(err3, 'Getting IP should fail');
+                    t2.ok(!ipRec, 'IP record does not exist in moray');
+                    t2.end();
+                });
+            });
+        });
+    });
+});
+
+
+test('Provision NIC w/ IP: IP taken during provision', function (t) {
+    var params = {
+        belongs_to_type: 'zone',
+        belongs_to_uuid: mod_uuid.v4(),
+        owner_uuid: mod_uuid.v4(),
+        ip: h.nextProvisionableIP(PROV_MAC_NET, true)
+    };
+    var numNicsBefore;
+
+    t.test('Count NICs before provision attempt', function (t2) {
+        mod_moray.countNics(MORAY, function (err, count) {
+            t2.ifError(err, 'Count should succeed');
+            numNicsBefore = count;
+            t2.end();
+        });
+    });
+
+    t.test('Attempt NIC provision', function (t2) {
+        var fakeErr = new Error('Already exists');
+        fakeErr.name = 'EtagConflictError';
+        fakeErr.context = {
+            bucket: ip_common.bucketName(PROV_MAC_NET.uuid),
+            key: params.ip
+        };
+        MORAY.setMockErrors({ batch: [ fakeErr ] });
+
+        mod_nic.provision(t2, {
+            net: PROV_MAC_NET.uuid,
+            params: params,
+            expCode: 422,
+            expErr: h.invalidParamErr({
+                errors: [
+                    mod_err.duplicateParam('ip', fmt(constants.fmt.IP_EXISTS,
+                        params.ip, PROV_MAC_NET.uuid))
+                ]
+            })
+        });
+    });
+
+    t.test('Confirm that the IP is free', function (t2) {
+        // Make sure we actually hit all of the errors:
+        t2.deepEqual(MORAY.getMockErrors(), {
+            batch: [ ]
+        }, 'no more batch errors left');
+
+        mod_ip.get(t2, {
+            net: PROV_MAC_NET.uuid,
+            ip: params.ip,
+            exp: {
+                free: true,
+                ip: params.ip,
+                network_uuid: PROV_MAC_NET.uuid,
+                reserved: false
+            }
+        });
+    });
+
+    t.test('Confirm no new records created', function (t2) {
+        mod_moray.getIP(MORAY, PROV_MAC_NET.uuid, params.ip,
+            function (err3, ipRec) {
+            t2.ok(err3, 'Getting IP should fail');
+            t2.ok(!ipRec, 'IP record does not exist in moray');
+
+            mod_moray.countNics(MORAY, function (err4, numNicsAfter) {
+                t2.ifError(err4, 'Counting NICs should succeed');
+                t2.equal(numNicsAfter, numNicsBefore,
+                    'no new nic records added');
+
+                t2.end();
+            });
 
-            return t.end();
         });
     });
 });
@@ -789,7 +974,7 @@ test('Provision nic: MAC retry', function (t) {
         fakeErr.name = 'EtagConflictError';
         fakeErr.context = { bucket: 'napi_nics' };
 
-        mod_moray.setErrors({ batch: [ fakeErr, fakeErr ] });
+        MORAY.setMockErrors({ batch: [ fakeErr, fakeErr ] });
 
         NAPI.provisionNic(PROV_MAC_NET.uuid, params, function (err, res) {
             if (h.ifErr(t2, err, 'provision nic with retry')) {
@@ -799,22 +984,24 @@ test('Provision nic: MAC retry', function (t) {
             d.mac = res.mac;
             t2.ok(res.mac, 'MAC address');
 
-            var morayObj = mod_moray.getNic(res.mac);
-            t2.ok(morayObj, 'found moray object');
-            if (morayObj) {
-                t2.equal(morayObj.mac, util_mac.aton(res.mac),
-                    'correct mac in moray object');
-            }
+            mod_moray.getNic(MORAY, res.mac, function (err2, morayObj) {
+                t2.ifError(err2, 'Should get NIC successfully');
+                t2.ok(morayObj, 'found moray object');
+                if (morayObj) {
+                    t2.equal(morayObj.mac, util_mac.aton(res.mac),
+                        'correct mac in moray object');
+                }
 
-            t2.equal(res.network_uuid, PROV_MAC_NET.uuid,
-                'network_uuid correct');
+                t2.equal(res.network_uuid, PROV_MAC_NET.uuid,
+                    'network_uuid correct');
 
-            // Make sure we actually hit those errors:
-            t2.deepEqual(mod_moray.getErrors(), {
-                batch: [ ]
-            }, 'no more batch errors left');
+                // Make sure we actually hit those errors:
+                t2.deepEqual(MORAY.getMockErrors(), {
+                    batch: [ ]
+                }, 'no more batch errors left');
 
-            return t2.end();
+                t2.end();
+            });
         });
     });
 
@@ -842,7 +1029,7 @@ test('Provision nic: MAC retry', function (t) {
         fakeErr.name = 'EtagConflictError';
         fakeErr.context = { bucket: 'napi_nics' };
 
-        mod_moray.setErrors({ batch: [ fakeErr, fakeErr ] });
+        MORAY.setMockErrors({ batch: [ fakeErr, fakeErr ] });
 
         mod_nic.create(t2, {
             mac: d.mac,
@@ -851,17 +1038,19 @@ test('Provision nic: MAC retry', function (t) {
                     errors: [ mod_err.duplicateParam('mac') ]
                 })
         }, function () {
-            var morayObj = mod_moray.getNic(d.mac);
-            t2.equal(morayObj, null, 'moray object does not exist');
+            mod_moray.getNic(MORAY, d.mac, function (err, morayObj) {
+                t2.ok(err, 'Get should fail');
+                t2.equal(morayObj, undefined, 'moray object does not exist');
 
-            // We should have bailed after the first iteration of the loop:
-            t2.equal(mod_moray.getErrors().batch.length, 1,
-                'one error left');
+                // We should have bailed after the first iteration of the loop:
+                t2.equal(MORAY.getMockErrors().batch.length, 1,
+                    'one error left');
 
-            // Reset moray errors
-            mod_moray.setErrors({ });
+                // Reset moray errors
+                MORAY.setMockErrors({ });
 
-            return t2.end();
+                t2.end();
+            });
         });
     });
 
@@ -893,7 +1082,7 @@ test('Provision nic: IP retry', function (t) {
         fakeErr.name = 'EtagConflictError';
         fakeErr.context = { bucket: ip_common.bucketName(PROV_MAC_NET.uuid) };
 
-        mod_moray.setErrors({ batch: [ fakeErr, fakeErr ] });
+        MORAY.setMockErrors({ batch: [ fakeErr, fakeErr ] });
 
         NAPI.provisionNic(PROV_MAC_NET.uuid, params, function (err, res) {
             if (h.ifErr(t2, err, 'provision nic with retry')) {
@@ -903,22 +1092,24 @@ test('Provision nic: IP retry', function (t) {
             d.mac = res.mac;
             t2.ok(res.mac, 'MAC address');
 
-            var morayObj = mod_moray.getNic(res.mac);
-            t2.ok(morayObj, 'found moray object');
-            if (morayObj) {
-                t2.equal(morayObj.mac, util_mac.aton(res.mac),
-                    'correct mac in moray object');
-            }
+            mod_moray.getNic(MORAY, res.mac, function (err2, morayObj) {
+                t2.ifError(err2, 'Get should succeed');
+                t2.ok(morayObj, 'found moray object');
+                if (morayObj) {
+                    t2.equal(morayObj.mac, util_mac.aton(res.mac),
+                        'correct mac in moray object');
+                }
 
-            t2.equal(res.network_uuid, PROV_MAC_NET.uuid,
-                'network_uuid correct');
+                t2.equal(res.network_uuid, PROV_MAC_NET.uuid,
+                    'network_uuid correct');
 
-            // Make sure we actually hit those errors:
-            t2.deepEqual(mod_moray.getErrors(), {
-                batch: [ ]
-            }, 'no more batch errors left');
+                // Make sure we actually hit those errors:
+                t2.deepEqual(MORAY.getMockErrors(), {
+                    batch: [ ]
+                }, 'no more batch errors left');
 
-            return t2.end();
+                t2.end();
+            });
         });
     });
 
@@ -948,34 +1139,37 @@ test('Provision nic: IP retry', function (t) {
         fakeErr.name = 'EtagConflictError';
         fakeErr.context = { bucket: ip_common.bucketName(PROV_MAC_NET.uuid) };
 
-        mod_moray.setErrors({ batch: [ fakeErr, fakeErr ] });
+        MORAY.setMockErrors({ batch: [ fakeErr, fakeErr ] });
 
         mod_nic.create(t2, {
             mac: d.mac,
             params: params,
             partialExp: params
         }, function (err, res) {
-            if (err) {
-                return t2.end();
+            if (h.ifErr(t2, err, 'Create should succeed')) {
+                t2.end();
+                return;
             }
 
             t2.ok(res.mac, 'MAC address');
-            var morayObj = mod_moray.getNic(res.mac);
-            t2.ok(morayObj, 'found moray object');
-            if (morayObj) {
-                t2.equal(morayObj.mac, util_mac.aton(res.mac),
-                    'correct mac in moray object');
-            }
+            mod_moray.getNic(MORAY, res.mac, function (err2, morayObj) {
+                t2.ifError(err2, 'Get should succeed');
+                t2.ok(morayObj, 'found moray object');
+                if (morayObj) {
+                    t2.equal(morayObj.mac, util_mac.aton(res.mac),
+                        'correct mac in moray object');
+                }
 
-            t2.equal(res.network_uuid, PROV_MAC_NET.uuid,
-                'network_uuid correct');
+                t2.equal(res.network_uuid, PROV_MAC_NET.uuid,
+                    'network_uuid correct');
 
-            // Make sure we actually hit those errors:
-            t2.deepEqual(mod_moray.getErrors(), {
-                batch: [ ]
-            }, 'no more batch errors left');
+                // Make sure we actually hit those errors:
+                t2.deepEqual(MORAY.getMockErrors(), {
+                    batch: [ ]
+                }, 'no more batch errors left');
 
-            return t2.end();
+                t2.end();
+            });
         });
     });
 
@@ -990,6 +1184,52 @@ test('Provision nic: IP retry', function (t) {
 });
 
 
+test('Provision NIC: Retry after QueryTimeoutErrors', function (t) {
+    var params = {
+        belongs_to_type: 'zone',
+        belongs_to_uuid: mod_uuid.v4(),
+        owner_uuid: mod_uuid.v4()
+    };
+
+    t.test('NIC provision', function (t2) {
+        var fakeErr = new Error('Timed out');
+        fakeErr.name = 'QueryTimeoutError';
+
+        /*
+         * The sql() error will prevent NAPI from selecting an IP from
+         * the first network in the pool. It will then retry, and fail
+         * to submit with batch(). After these errors, it will still
+         * use the originally selected IP, since it didn't actually need
+         * to change.
+         */
+        MORAY.setMockErrors({
+            sql: [ fakeErr ],
+            batch: [ fakeErr, fakeErr, fakeErr ]
+        });
+
+        mod_nic.provision(t2, {
+            net: NET2.uuid,
+            params: params,
+            exp: mod_nic.addDefaultParams({
+                belongs_to_type: params.belongs_to_type,
+                belongs_to_uuid: params.belongs_to_uuid,
+                owner_uuid: params.owner_uuid,
+                ip: h.nextProvisionableIP(NET2)
+            }, NET2)
+        });
+    });
+
+    t.test('Confirm that NAPI hit the errors', function (t2) {
+        // Make sure we actually hit all of the errors:
+        t2.deepEqual(MORAY.getMockErrors(), {
+            sql: [ ],
+            batch: [ ]
+        }, 'no more batch errors left');
+        t2.end();
+    });
+});
+
+
 test('Provision nic - with IP', function (t) {
     t.plan(7);
     var d = {};
@@ -1081,8 +1321,9 @@ test('Provision nic - with IP', function (t) {
             },
             expErr: h.invalidParamErr({
                 errors: [
-                    mod_err.duplicateParam('ip', util.format(
-                        constants.fmt.IP_EXISTS, NET2.uuid))
+                    mod_err.usedByParam('ip', 'zone', d.exp.belongs_to_uuid,
+                        util.format(constants.fmt.IP_IN_USE,
+                            'zone', d.exp.belongs_to_uuid))
                 ]
             })
         });
@@ -1175,6 +1416,231 @@ test('(PNDS) Provision nic - with different state', function (t) {
 });
 
 
+test('Provision NIC - IP specified w/o network_uuid', function (t) {
+    var mac1 = h.randomMAC();
+    var mac2 = h.randomMAC();
+    var base = {
+        belongs_to_type: 'zone',
+        owner_uuid: mod_uuid.v4(),
+        ip: h.nextProvisionableIP(NET3),
+        vlan_id: NET3.vlan_id,
+        nic_tag: NET3.nic_tag
+    };
+    var params1 = extend(base, { belongs_to_uuid: mod_uuid.v4() });
+    var params2 = extend(base, { belongs_to_uuid: mod_uuid.v4() });
+
+    t.test('create', function (t2) {
+        mod_nic.createAndGet(t2, {
+            mac: mac1,
+            params: params1,
+            partialExp: extend(params1, {
+                network_uuid: NET3.uuid
+            })
+        });
+    });
+
+    t.test('get IPv4 address', function (t2) {
+        mod_ip.get(t2, {
+            net: NET3.uuid,
+            ip: params1.ip,
+            exp: {
+                belongs_to_type: params1.belongs_to_type,
+                belongs_to_uuid: params1.belongs_to_uuid,
+                owner_uuid: params1.owner_uuid,
+                ip: params1.ip,
+                network_uuid: NET3.uuid,
+                free: false,
+                reserved: false
+            }
+        });
+    });
+
+    t.test('another NIC cannot steal the IP', function (t2) {
+        mod_nic.create(t2, {
+            mac: mac2,
+            params: params2,
+            expCode: 422,
+            expErr: h.invalidParamErr({
+                errors: [
+                    mod_err.usedByParam('ip', 'zone', params1.belongs_to_uuid,
+                        util.format(constants.fmt.IP_IN_USE,
+                            'zone', params1.belongs_to_uuid))
+                ]
+            })
+        });
+    });
+});
+
+
+
+
+
+// --- Get tests
+
+
+
+test('Get NIC with bad MAC address', function (t) {
+    mod_nic.get(t, {
+        mac: 'foo',
+        expCode: 422,
+        expErr: h.invalidParamErr({
+            errors: [ mod_err.invalidParam('mac', 'invalid MAC address') ]
+        })
+    });
+});
+
+
+
+// --- Delete tests
+
+
+
+test('Delete NIC with bad MAC address', function (t) {
+    mod_nic.del(t, {
+        mac: 'foo',
+        expCode: 422,
+        expErr: h.invalidParamErr({
+            errors: [ mod_err.invalidParam('mac', 'invalid MAC address') ]
+        })
+    });
+});
+
+
+test('Delete a nonexistent NIC', function (t) {
+    mod_nic.del(t, {
+        mac: h.randomMAC(),
+        expCode: 404,
+        expErr: {
+            code: 'ResourceNotFound',
+            message: 'nic not found'
+        }
+    });
+});
+
+
+test('Delete a NIC w/o any addresses on it', function (t) {
+    var nic;
+    var params = {
+        belongs_to_type: 'zone',
+        belongs_to_uuid: mod_uuid.v4(),
+        owner_uuid: mod_uuid.v4()
+    };
+
+    t.test('provision', function (t2) {
+        NAPI.post({ path: '/nics' }, params, function (err, res) {
+            if (h.ifErr(t2, err, 'provision new nic')) {
+                t2.end();
+                return;
+            }
+
+            nic = res;
+            for (var p in params) {
+                t2.equal(nic[p], params[p], p + ' correct');
+            }
+
+            t2.notOk(res.hasOwnProperty('ip'), 'NIC has no IP');
+
+            t2.end();
+        });
+    });
+
+    t.test('delete nic', function (t2) {
+        mod_nic.del(t2, { mac: nic.mac });
+    });
+
+    t.test('confirm nic deleted', function (t2) {
+        mod_nic.get(t2, {
+            mac: nic.mac,
+            expCode: 404,
+            expErr: {
+                code: 'ResourceNotFound',
+                message: 'nic not found'
+            }
+        });
+    });
+});
+
+
+test('Delete a NIC w/ an address on it', function (t) {
+    var nic;
+    var ip = h.nextProvisionableIP(NET2);
+    var params = {
+        belongs_to_type: 'zone',
+        belongs_to_uuid: mod_uuid.v4(),
+        owner_uuid: mod_uuid.v4()
+    };
+
+    t.test('provision', function (t2) {
+        NAPI.provisionNic(NET2.uuid, params, function (err, res) {
+            if (h.ifErr(t, err, 'provision nic')) {
+                t.end();
+                return;
+            }
+
+            nic = mod_nic.addDefaultParams({
+                mac: res.mac,
+                belongs_to_type: params.belongs_to_type,
+                belongs_to_uuid: params.belongs_to_uuid,
+                ip: ip,
+                owner_uuid: params.owner_uuid,
+                state: 'provisioning'
+            }, NET2);
+
+            t.deepEqual(res, nic, 'result');
+
+            mod_nic.get(t2, {
+                mac: res.mac,
+                exp: nic
+            });
+        });
+    });
+
+    t.test('check that ip is taken', function (t2) {
+        mod_ip.get(t2, {
+            net: NET2.uuid,
+            ip: ip,
+            exp: {
+                belongs_to_type: nic.belongs_to_type,
+                belongs_to_uuid: nic.belongs_to_uuid,
+                free: false,
+                ip: ip,
+                network_uuid: NET2.uuid,
+                owner_uuid: nic.owner_uuid,
+                reserved: false
+            }
+        });
+    });
+
+    t.test('delete nic', function (t2) {
+        mod_nic.del(t2, { mac: nic.mac });
+    });
+
+    t.test('confirm nic deleted', function (t2) {
+        mod_nic.get(t2, {
+            mac: nic.mac,
+            expCode: 404,
+            expErr: {
+                code: 'ResourceNotFound',
+                message: 'nic not found'
+            }
+        });
+    });
+
+    t.test('check that ip is now free', function (t2) {
+        mod_ip.get(t2, {
+            net: NET2.uuid,
+            ip: ip,
+            exp: {
+                free: true,
+                ip: ip,
+                network_uuid: NET2.uuid,
+                reserved: false
+            }
+        });
+    });
+});
+
+
 
 // --- Update tests
 
@@ -1204,7 +1670,7 @@ test('Update nic - provision IP', function (t) {
         d.exp = mod_nic.addDefaultParams({
             belongs_to_type: d.params.belongs_to_type,
             belongs_to_uuid: d.params.belongs_to_uuid,
-            ip: NET3.provision_start_ip,
+            ip: h.nextProvisionableIP(NET3),
             mac: d.mac,
             owner_uuid: d.params.owner_uuid
         }, NET3);
@@ -1228,7 +1694,7 @@ test('Update nic - provision IP', function (t) {
     t.test('get IP', function (t2) {
         mod_ip.get(t2, {
             net: NET3.uuid,
-            ip: NET3.provision_start_ip,
+            ip: d.exp.ip,
             exp: {
                 belongs_to_type: d.exp.belongs_to_type,
                 belongs_to_uuid: d.exp.belongs_to_uuid,
@@ -1244,7 +1710,7 @@ test('Update nic - provision IP', function (t) {
 
 
 test('Update nic - IP parameters updated', function (t) {
-    t.plan(6);
+    t.plan(5);
     var d = {};
 
     t.test('create', function (t2) {
@@ -1315,21 +1781,6 @@ test('Update nic - IP parameters updated', function (t) {
             }
         });
     });
-
-    t.test('update when moray IP object has changed', function (t2) {
-        var ipObj = mod_moray.getIP(NET.uuid, d.exp.ip);
-        t2.ok(ipObj, 'have IP object');
-        ipObj.network = {};
-
-        ipObj = mod_moray.getIP(NET.uuid, d.exp.ip);
-        t2.deepEqual(ipObj.network, {});
-
-        mod_nic.update(t2, {
-            mac: d.mac,
-            params: d.exp,
-            exp: d.exp
-        });
-    });
 });
 
 
@@ -1677,10 +2128,9 @@ test('Update nic - invalid params', function (t) {
         [ 'nic_tag and vlan_id do not match any networks',
             { ip: fmt('10.0.%d.3', NET.num), nic_tag: NET.nic_tag,
                 vlan_id: 656 },
-            [ mod_err.invalidParam('nic_tag',
-                'No networks found matching parameters'),
-            mod_err.invalidParam('vlan_id',
-                'No networks found matching parameters') ] ],
+            [ mod_err.invalidParam('ip', util.format(
+                constants.fmt.IP_NONET, NET.nic_tag, 656,
+                fmt('10.0.%d.3', NET.num))) ] ],
 
         [ 'state must be a valid state',
             { ip: fmt('10.0.%d.2', NET.num), network_uuid: NET.uuid,
@@ -1846,6 +2296,74 @@ test('Update nic - change state', function (t) {
 
 });
 
+test('Update nic - set "reserved" flag', function (t) {
+    var params = {
+        belongs_to_type: 'zone',
+        belongs_to_uuid: mod_uuid.v4(),
+        owner_uuid: mod_uuid.v4()
+    };
+
+    var ip = h.nextProvisionableIP(NET2);
+
+    t.test('provision', function (t2) {
+        mod_nic.provision(t2, {
+            net: NET2.uuid,
+            params: params,
+            partialExp: extend(params, {
+                ip: ip,
+                state: constants.DEFAULT_NIC_STATE
+            })
+        });
+    });
+
+    t.test('get IP: "reserved" should be false', function (t2) {
+        mod_ip.get(t2, {
+            net: NET2.uuid,
+            ip: ip,
+            exp: {
+                belongs_to_type: params.belongs_to_type,
+                belongs_to_uuid: params.belongs_to_uuid,
+                free: false,
+                ip: ip,
+                network_uuid: NET2.uuid,
+                owner_uuid: params.owner_uuid,
+                reserved: false
+            }
+        });
+    });
+
+    t.test('update: change state', function (t2) {
+        var updateParams = {
+            reserved: true
+        };
+
+        mod_nic.update(t2, {
+            mac: mod_nic.lastCreated().mac,
+            params: updateParams,
+            partialExp: extend(params, {
+                ip: ip,
+                state: constants.DEFAULT_NIC_STATE
+            })
+        });
+    });
+
+    t.test('get IP: "reserved" should be true', function (t2) {
+        mod_ip.get(t2, {
+            net: NET2.uuid,
+            ip: ip,
+            exp: {
+                belongs_to_type: params.belongs_to_type,
+                belongs_to_uuid: params.belongs_to_uuid,
+                free: false,
+                ip: ip,
+                network_uuid: NET2.uuid,
+                owner_uuid: params.owner_uuid,
+                reserved: true
+            }
+        });
+    });
+});
+
 
 test('Update nic moray failure getting IP / network', function (t) {
     var params = {
@@ -1873,7 +2391,7 @@ test('Update nic moray failure getting IP / network', function (t) {
             null,
             new Error('Oh no!')
         ];
-        mod_moray.setErrors({ getObject: errs });
+        MORAY.setMockErrors({ getObject: errs });
 
         mod_nic.update(t2, {
             mac: mod_nic.lastCreated().mac,
@@ -1889,10 +2407,10 @@ test('Update nic moray failure getting IP / network', function (t) {
 
     t.test('check error', function (t2) {
         // Make sure we made it to the correct error
-        t2.deepEqual(mod_moray.getErrors().getObject, [],
+        t2.deepEqual(MORAY.getMockErrors().getObject, [],
             'no errors remaining');
 
-        t2.deepEqual(mod_moray.getLastError(), {
+        t2.deepEqual(MORAY.getLastMockError(), {
             bucket: ip_common.bucketName(NET2.uuid),
             key: mod_nic.lastCreated().ip,
             op: 'getObject',
@@ -1917,6 +2435,59 @@ test('Update nic moray failure getting IP / network', function (t) {
 });
 
 
+test('Update NIC to sibling NIC\'s IP is disallowed (NAPI-385)', function (t) {
+    var params = {
+        belongs_to_type: 'zone',
+        belongs_to_uuid: mod_uuid.v4(),
+        owner_uuid: mod_uuid.v4()
+    };
+
+    var ip1 = h.nextProvisionableIP(NET2);
+    var ip2 = h.nextProvisionableIP(NET2);
+
+    var nic2;
+
+    t.test('provision nic1', function (t2) {
+        mod_nic.provision(t2, {
+            net: NET2.uuid,
+            params: params,
+            partialExp: extend(params, {
+                ip: ip1,
+                network_uuid: NET2.uuid
+            })
+        });
+    });
+
+    t.test('provision nic2', function (t2) {
+        mod_nic.provision(t2, {
+            net: NET2.uuid,
+            params: params,
+            partialExp: extend(params, {
+                ip: ip2,
+                network_uuid: NET2.uuid
+            })
+        });
+    });
+
+    t.test('update nic2 to nic1\'s IP', function (t2) {
+        nic2 = mod_nic.lastCreated();
+
+        mod_nic.update(t2, {
+            mac: nic2.mac,
+            params: { ip: ip1 },
+            expCode: 422,
+            expErr: h.invalidParamErr({
+                errors: [
+                    mod_err.usedByParam('ip', 'zone', params.belongs_to_uuid,
+                        util.format(constants.fmt.IP_IN_USE,
+                            'zone', params.belongs_to_uuid))
+                ]
+            })
+        });
+    });
+});
+
+
 // Provision a nic, then change that IP's belongs_to_uuid to something
 // else.  Deleting the nic should not free the IP (since it now belongs
 // to something else).
@@ -2051,11 +2622,12 @@ test('antispoof options', function (t) {
             d.mac = res.mac;
             t2.equal(res.ip, h.nextProvisionableIP(NET2), 'IP');
 
-            var morayObj = mod_moray.getNic(res.mac);
-            t2.ok(!morayObj.hasOwnProperty('network'),
-                'moray object does not have network in it');
-
-            return t2.end();
+            mod_moray.getNic(MORAY, res.mac, function (err2, morayObj) {
+                t2.ifError(err2, 'Get should succeed');
+                t2.ok(!morayObj.hasOwnProperty('network'),
+                    'moray object does not have network in it');
+                t2.end();
+            });
         });
     });
 
@@ -2086,16 +2658,18 @@ test('antispoof options', function (t) {
             params: d.updateParams,
             exp: d.exp
         }, function (err, res) {
-            if (err) {
-                return t2.end();
+            if (h.ifErr(t2, err, 'Update should succeed')) {
+                t2.end();
+                return;
             }
 
-            // Confirm that the fields have been removed from moray
-            var morayObj = mod_moray.getNic(res.mac);
-            t2.ok(!morayObj.hasOwnProperty('network'),
-                'moray object does not have network in it');
-
-            return t2.end();
+            // Confirm that the fields have been removed from Moray
+            mod_moray.getNic(MORAY, res.mac, function (err2, morayObj) {
+                t2.ifError(err2, 'Get should succeed');
+                t2.ok(!morayObj.hasOwnProperty('network'),
+                    'Moray object does not have network in it');
+                t2.end();
+            });
         });
     });
 
@@ -2117,16 +2691,18 @@ test('antispoof options', function (t) {
             params: d.updateParams,
             exp: d.exp
         }, function (err, res) {
-            if (err) {
-                return t2.end();
+            if (h.ifErr(t2, err, 'Update should succeed')) {
+                t2.end();
+                return;
             }
 
-            // Confirm that the fields have been removed from moray
-            var morayObj = mod_moray.getNic(res.mac);
-            t2.ok(!morayObj.hasOwnProperty('network'),
-                'moray object does not have network in it');
-
-            return t2.end();
+            // Confirm that the fields have been removed from Moray
+            mod_moray.getNic(MORAY, res.mac, function (err2, morayObj) {
+                t2.ifError(err2, 'Get should succeed');
+                t2.ok(!morayObj.hasOwnProperty('network'),
+                    'Moray object does not have network in it');
+                t2.end();
+            });
         });
     });
 
@@ -2263,10 +2839,35 @@ test('Listing Nics failures', function (t) {
     }
 });
 
+test('List all NICs', function (t) {
+    mod_nic.list(t, {
+        present: common.allCreated('nics').map(function (nic) {
+            return { mac: nic.mac };
+        })
+    });
+});
+
+
+test('List 2 NICs', function (t) {
+    mod_nic.list(t, {
+        params: {
+            limit: 2
+        }
+    }, function (err, res) {
+        if (h.ifErr(t, err, 'list nics error')) {
+            t.end();
+            return;
+        }
+
+        t.equal(res.length, 2, 'correct number of NICs returned');
+        t.end();
+    });
+});
+
+
+
 
 // XXX: More tests:
-// - create nic with IP, then create another nic with the same IP.  Old nic
-//   should no longer have that IP
 // - should not allow updating an IP to outside the subnet (if only the IP
 //   is specified)
 
@@ -2274,11 +2875,6 @@ test('Listing Nics failures', function (t) {
 
 // --- Teardown
 
+test('delete nics', mod_nic.delAllCreated);
 
-
-test('Stop server', function (t) {
-    h.stopServer(function (err) {
-        t.ifError(err, 'server stop');
-        t.end();
-    });
-});
+test('Stop server', mod_server.close);
diff --git a/test/unit/run.js b/test/unit/run.js
new file mode 100644
index 0000000..becc33e
--- /dev/null
+++ b/test/unit/run.js
@@ -0,0 +1,42 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright 2017, Joyent, Inc.
+ * Copyright 2014 Patrick Mooney.  All rights reserved.
+ */
+
+'use strict';
+
+var assert = require('assert');
+var fs = require('fs');
+var mod_server = require('../lib/server');
+var path = require('path');
+var test = require('tape');
+
+function runTests(directory) {
+    mod_server.MULTI_SUITE_RUN = true;
+
+    fs.readdir(directory, function (err, files) {
+        assert.ifError(err);
+        files.filter(function (f) {
+            return (/\.test\.js$/.test(f));
+        }).map(function (f) {
+            return (path.join(directory, f));
+        }).forEach(require);
+
+        test('Shutdown Postgres', function (t) {
+            mod_server.stopPG();
+            t.end();
+        });
+    });
+}
+
+// --- Run All Tests
+
+(function main() {
+    runTests(__dirname);
+})();
diff --git a/test/unit/search-ips.test.js b/test/unit/search-ips.test.js
index b9974e6..b39414a 100644
--- a/test/unit/search-ips.test.js
+++ b/test/unit/search-ips.test.js
@@ -20,6 +20,7 @@ var h = require('./helpers');
 var mod_err = require('../../lib/util/errors');
 var mod_net = require('../lib/net');
 var mod_nicTag = require('../lib/nic-tag');
+var mod_server = require('../lib/server');
 var mod_uuid = require('node-uuid');
 var test = require('tape');
 
@@ -235,9 +236,4 @@ test('IP not in any networks', function (t) {
 
 
 
-test('Stop server', function (t) {
-    h.stopServer(function (err) {
-        t.ifError(err, 'server stop');
-        t.end();
-    });
-});
+test('Stop server', mod_server.close);
