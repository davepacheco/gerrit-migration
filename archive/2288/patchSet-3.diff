From 741b5d482be62957cb9463d403810d8ae226ac8b Mon Sep 17 00:00:00 2001
From: Cody Peter Mello <cody.mello@joyent.com>
Date: Wed, 19 Apr 2017 00:12:33 +0000
Subject: [PATCH] MORAY-412 Upgrade to a more recent node-postgres

---
 lib/pg.js    | 331 +++++++++++++++++++++++++++++----------------------
 package.json |   5 +-
 2 files changed, 194 insertions(+), 142 deletions(-)

diff --git a/lib/pg.js b/lib/pg.js
index 48dfb38..d923ca8 100644
--- a/lib/pg.js
+++ b/lib/pg.js
@@ -15,6 +15,7 @@ var util = require('util');
 var assert = require('assert-plus');
 var bunyan = require('bunyan');
 var clone = require('clone');
+var jsprim = require('jsprim');
 var libuuid = require('libuuid');
 var once = require('once');
 var pg = require('pg');
@@ -39,7 +40,7 @@ var SERIALIZERS = {
     client: function _serializeClient(c) {
         return ({
             id: c._moray_id,
-            currentQuery: (c.activeQuery || {}).text,
+            currentQuery: jsprim.pluck(c, 'client.activeQuery.text'),
             timeout: c._queryTimeout,
             txn: c._moray_txn
         });
@@ -49,7 +50,7 @@ var SERIALIZERS = {
 
 
 
-///--- Postgres Query Wrapper
+///--- Postgres Client Wrapper Class
 
 function qCleanup(req, res) {
     if (req) {
@@ -66,17 +67,83 @@ function qCleanup(req, res) {
 }
 
 
-// This is a "bound" function, so 'this' is always set to the current
-// PG connection
-function query(sql, args) {
+/*
+ * This client wraps the node-postgres client to provide some useful helper
+ * methods, and also to provide timeouts and DTrace probes inside the query
+ * function.
+ */
+function PGClient(options) {
+    assert.object(options, 'options');
+    assert.object(options.client, 'options.client');
+    assert.object(options.log, 'options.log');
+    assert.object(options.pool, 'options.pool');
+    assert.number(options.queryTimeout, 'options.queryTimeout');
+
+    if (++CLIENT_ID >= 4294967295) // 2^32 -1
+        CLIENT_ID = 1;
+
+    this.client = options.client;
+    this.client.on('error', this._handleClientError.bind(this));
+
+    this.pool = options.pool;
+
+    this._moray_id = CLIENT_ID;
+    this._defaultTimeout = options.queryTimeout;
+    this._queryTimeout = options.queryTimeout;
+    this._moray_txn = false;
+
+    this.log = options.log.child({
+        component: 'PGClient',
+        moray_id: this._moray_id
+    }, true);
+}
+
+
+/*
+ * The underlying Postgres will emit errors when it has a connection
+ * problem. This can fire multiple times: once when the connection goes
+ * away, and again if we try to make a query using this client. When
+ * this happens, we mark this client as having failed so that the pool
+ * will remove us once we're released.
+ */
+PGClient.prototype._handleClientError = function (err) {
+    this.log.error({
+        err: err,
+        client: this
+    }, 'pg: client emitted an error');
+
+    this._moray_had_err = true;
+};
+
+
+/*
+ * Set a timeout for queries ("queryTimeout" in the configuration).
+ */
+PGClient.prototype.setTimeout = function setQueryTimeout(timeout) {
+    assert.finite(timeout, 'timeout');
+    assert.ok(timeout >= 0, 'timeout >= 0');
+    this._queryTimeout = timeout;
+};
+
+
+/*
+ * Restore default timeout in case it was changed, and return this
+ * client back to the pool.
+ */
+PGClient.prototype.release = function clientRelease() {
+    assert.equal(false, this._moray_txn, 'finished transaction');
+    this.setTimeout(this._defaultTimeout);
+    this.pool.release(this);
+};
+
+
+PGClient.prototype.query = function clientQuery(sql, args) {
     assert.string(sql, 'sql');
-    if (typeof (arguments[arguments.length - 1]) === 'function')
-        throw new TypeError('query: callback style illegal');
+    assert.optionalArray(args, 'args');
 
     // Clean up whitespace so queries are normalized to DTrace
     sql = sql.replace(/(\r\n|\n|\r)/gm, '').replace(/\s+/, ' ');
 
-    var done;
     var log = this.log;
     var req;
     var res = new EventEmitter();
@@ -84,14 +151,14 @@ function query(sql, args) {
     var timer;
     var reqid = libuuid.create();
 
-    done = once(function endOrError(event, arg) {
+    function done(event, arg) {
         res.emit(event, arg);
 
         clearTimeout(timer);
         qCleanup(req, res);
-    });
+    }
 
-    req = this._query.apply(this, arguments);
+    req = new pg.Query(sql, args);
 
     req.on('row', function onRow(row) {
         dtrace['query-row'].fire(function () {
@@ -147,6 +214,8 @@ function query(sql, args) {
         }, this._queryTimeout);
     }
 
+    this.client.query(req);
+
     dtrace['query-start'].fire(function () {
         return ([reqid, sql]);
     });
@@ -159,130 +228,131 @@ function query(sql, args) {
     }, 'pg.query: started');
 
     return (res);
-}
+};
 
-///--- End Query API
 
+PGClient.prototype.begin = function transactionBegin(level, cb) {
+    var self = this;
 
+    if (typeof (level) === 'function') {
+        cb = level;
+        level = 'READ COMMITTED';
+    }
+    assert.func(cb, 'callback');
 
-///--- Pool Functions
+    var q = self.query('BEGIN TRANSACTION ISOLATION LEVEL ' + level);
 
-function pgSetup(options) {
-    assert.object(options, 'options');
-    assert.object(options.client, 'options.client');
-    assert.object(options.log, 'options.log');
-    assert.object(options.pool, 'options.pool');
-    assert.number(options.queryTimeout, 'options.queryTimeout');
+    q.once('error', function (err) {
+        self._moray_had_err = true;
+        self.release();
+        cb(err);
+    });
 
-    var client = options.client;
-    var log = options.log;
-    var pool = options.pool;
+    q.once('end', function (_) {
+        self._moray_txn = true;
+        cb();
+    });
+};
 
-    if (++CLIENT_ID >= 4294967295) // 2^32 -1
-        CLIENT_ID = 1;
 
-    client._moray_id = CLIENT_ID;
-    client._queryTimeout = options.queryTimeout;
-    client._moray_txn = false;
+PGClient.prototype.commit = function transactionCommit(cb) {
+    assert.func(cb, 'callback');
 
-    client.connection.stream.setKeepAlive(true);
-    client.log = log.child({
-        component: 'PGClient',
-        moray_id: client._moray_id
-    }, true);
-    client.release = pool.release.bind(pool, client);
+    var self = this;
 
-    // Overwrite query so we can have timeouts, DTrace, etc.
-    client._query = client.query.bind(client);
-    client.query = query.bind(client);
+    function _cb(err) {
+        self._moray_txn = false;
+        self.release();
+        cb(err);
+    }
 
-    // Some friendly wrappers
-    client.begin = function begin(level, cb) {
-        if (typeof (level) === 'function') {
-            cb = level;
-            level = 'READ COMMITTED';
-        }
-        assert.func(cb, 'callback');
-        cb = once(cb);
+    /*
+     * Don't time out the final "COMMIT" query. Sending back a
+     * QueryTimeoutError would needlessly complicate things for
+     * the consumer and for us, since Postgres would still be
+     * processing the query after we give up on it, and possibly
+     * succeed or fail. Handling this would make proper management
+     * of our PG connections more complicated.
+     *
+     * Given that "timeout" doesn't actually introduce an
+     * upper-bound on the overall Moray RPC but instead controls
+     * how long we wait for a response to each of the SQL queries
+     * we make, clients who actually want an upper-bound on how
+     * long an RPC takes should implement the appropriate logic
+     * on their end.
+     */
+    self.setTimeout(0);
+
+    var q = self.query('COMMIT');
+
+    q.once('error', function (err) {
+        self._moray_had_err = true;
+        _cb(err);
+    });
 
-        var q = client.query('BEGIN TRANSACTION ISOLATION LEVEL ' + level);
-        q.once('error', function (err) {
-            client._moray_had_err = true;
-            pool.release(client);
-            cb(err);
-        });
-        q.once('end', function () {
-            client._moray_txn = true;
-            cb();
-        });
-    };
-    client.commit = function commit(cb) {
-        assert.func(cb, 'callback');
-        cb = once(cb);
+    q.once('end', function (_) {
+        _cb(null);
+    });
+};
 
-        function _cb(err) {
-            client._moray_txn = false;
-            pool.release(client);
-            cb(err);
-        }
 
-        /*
-         * Don't time out the final "COMMIT" query. Sending back a
-         * QueryTimeoutError would needlessly complicate things for
-         * the consumer and for us, since Postgres would still be
-         * processing the query after we give up on it, and possibly
-         * succeed or fail. Handling this would make proper management
-         * of our PG connections more complicated.
-         *
-         * Given that "timeout" doesn't actually introduce an
-         * upper-bound on the overall Moray RPC but instead controls
-         * how long we wait for a response to each of the SQL queries
-         * we make, clients who actually want an upper-bound on how
-         * long an RPC takes should implement the appropriate logic
-         * on their end.
-         */
-        client.setTimeout(0);
-
-        var q = client.query('COMMIT');
-        q.once('error', _cb);
-        q.once('end', function () {
-            _cb();
-        });
-    };
+PGClient.prototype.rollback = function transactionRollback(cb) {
+    assert.optionalFunc(cb, 'callback');
 
-    client.rollback = function rollback(cb) {
-        assert.optionalFunc(cb, 'callback');
-        cb = once(cb || function () {});
+    var self = this;
 
-        function _cb(err) {
-            client._moray_txn = false;
-            pool.release(client);
+    function _cb(err) {
+        self._moray_txn = false;
+        self.release();
+        if (cb) {
             cb(err);
         }
+    }
 
-        if (client._moray_txn) {
-            var q = client.query('ROLLBACK');
-            q.once('error', function (err) {
-                client._moray_had_err = true;
-                _cb(err);
-            });
-            q.once('end', function () {
-                _cb();
-            });
-        } else {
-            _cb();
-        }
-    };
-}
+    if (!self._moray_txn) {
+        _cb();
+        return;
+    }
 
+    var q = self.query('ROLLBACK');
+
+    q.once('error', function (err) {
+        self._moray_had_err = true;
+        _cb(err);
+    });
+
+    q.once('end', function (_) {
+        _cb(null);
+    });
+};
+
+
+PGClient.prototype.close = function closePGClient() {
+    var self = this;
+
+    self.log.warn({ client: self }, 'pg: destroying connection');
+
+    self.client.end(function () {
+        self.client = null;
+        self._deadbeef = true;
+    });
+};
+
+
+///--- End Postgres Client Wrapper Class
+
+
+
+///--- Pool Functions
 
 function pgAssert(_pg) {
-    assert.ok(_pg, 'pg handle');
-    assert.ok(_pg.connection, 'pg connection');
-    assert.ok(_pg.connection.stream, 'pg stream');
-    assert.ok(_pg.connection.stream.readable, 'pg readable');
-    assert.ok(!_pg.connection.stream.destroyed, 'pg not destroyed');
-    assert.ok(_pg.connection.stream.writable, 'pg writable');
+    assert.ok(_pg, 'pg client wrapper');
+    assert.ok(_pg.client, 'pg handle');
+    assert.ok(_pg.client.connection, 'pg connection');
+    assert.ok(_pg.client.connection.stream, 'pg stream');
+    assert.ok(_pg.client.connection.stream.readable, 'pg readable');
+    assert.ok(!_pg.client.connection.stream.destroyed, 'pg not destroyed');
+    assert.ok(_pg.client.connection.stream.writable, 'pg writable');
 
     return (!_pg._moray_had_err);
 }
@@ -318,10 +388,13 @@ function pgCreate(opts) {
     var log = opts.log;
 
     function _pgCreate(cb) {
-
         cb = once(cb);
 
-        var client = new pg.Client(opts.url);
+        var client = new pg.Client({
+            connectionString: opts.url,
+            keepAlive: true
+        });
+
         if (opts.connectTimeout > 0) {
             var timer = setTimeout(function () {
                 // do not remove error listener as node may
@@ -342,7 +415,7 @@ function pgCreate(opts) {
 
             client.removeAllListeners('error');
 
-            pgSetup({
+            var pgc = new PGClient({
                 client: client,
                 connectTimeout: opts.connectTimeout,
                 log: opts.log,
@@ -351,7 +424,7 @@ function pgCreate(opts) {
                 url: opts.url
             });
 
-            cb(null, client);
+            cb(null, pgc);
         });
 
         client.once('error', function onError(err) {
@@ -374,20 +447,8 @@ function pgCreate(opts) {
 
 
 function pgDestroy(opts) {
-    var log = opts.log;
-
     function _pgDestroy(client) {
-        log.warn({client: client}, 'pg: destroying connection');
-
-        client.removeAllListeners('connect');
-        client.removeAllListeners('end');
-        client.removeAllListeners('error');
-        client.removeAllListeners('row');
-
-        if (client.connection && client.connection.stream)
-            client.connection.stream.destroy();
-
-        client._deadbeef = true;
+        client.close();
     }
 
     return (_pgDestroy);
@@ -522,14 +583,6 @@ PGPool.prototype.checkout = function checkout(callback) {
                 client: client
             }, 'checkout: done');
 
-            // MANTA-1458 - hack!
-            client._defaultTimeout = client._queryTimeout;
-            client.setTimeout = function setTimeout(t) {
-                assert.finite(t, 't is finite');
-                assert.ok(t >= 0, 't >= 0');
-
-                client._queryTimeout = t;
-            };
             callback(null, client);
         }
     });
@@ -539,8 +592,6 @@ PGPool.prototype.checkout = function checkout(callback) {
 PGPool.prototype.release = function release(client) {
     assert.object(client, 'client');
 
-    // MANTA-1458 - unhack!
-    client._queryTimeout = client._defaultTimeout;
     this.pool.release(client);
 
     this.log.trace({
diff --git a/package.json b/package.json
index 1fbdfc9..37da867 100644
--- a/package.json
+++ b/package.json
@@ -8,7 +8,7 @@
     "dependencies": {
         "ajv": "4.11.4",
         "assert-plus": "1.0.0",
-        "bunyan": "0.22.1",
+        "bunyan": "1.8.10",
         "bunyan-syslog": "0.2.2",
         "clone": "0.1.11",
         "crc": "0.2.1",
@@ -16,6 +16,7 @@
         "deep-equal": "0.0.0",
         "fast": "2.2.3",
         "ip6addr": "0.1.1",
+        "jsprim": "1.4.0",
         "kang": "1.2.0",
         "moray-filter": "1.0.0",
         "libuuid": "0.1.3",
@@ -25,7 +26,7 @@
         "moray": "3.1.1",
         "microtime": "0.5.1",
         "once": "1.3.0",
-        "pg": "2.11.0",
+        "pg": "6.2.4",
         "pg-parse-float": "0.0.1",
         "pooling": "0.4.5",
         "posix-getopt": "1.0.0",
-- 
2.21.0

