commit 524d877618fcb64151a3b6086f266b3964c7db38 (refs/changes/77/2577/3)
Author: Joshua M. Clulow <jmc@joyent.com>
Date:   2017-09-15T21:38:19+00:00 (2 years, 1 month ago)
    
    joyent/node-manta#325 ask server for fully qualified upload path
    Reviewed by: Jordan Hendricks <jordan.hendricks@joyent.com>
    Approved by: David Pacheco <dap@joyent.com>

diff --git a/CHANGES.md b/CHANGES.md
index 5e0aba6..c77cf37 100644
--- a/CHANGES.md
+++ b/CHANGES.md
@@ -2,6 +2,8 @@
 
 ## not yet released
 
+- joyent/node-manta#325 ask server for fully qualified upload path
+
 ## 5.0.0
 
 If you do not check explicitly for `ResourceNotFoundErrors` from multipart
diff --git a/README.md b/README.md
index db87be0..b2dc1d0 100644
--- a/README.md
+++ b/README.md
@@ -118,7 +118,8 @@ versions. First you must create "test/node.paths" (based on
 # License
 
 The MIT License (MIT)
-Copyright 2016 Joyent
+
+Copyright (c) 2017, Joyent, Inc.
 
 Permission is hereby granted, free of charge, to any person obtaining a copy of
 this software and associated documentation files (the "Software"), to deal in
diff --git a/lib/client.js b/lib/client.js
index 928a9b7..65cc1e5 100644
--- a/lib/client.js
+++ b/lib/client.js
@@ -497,58 +497,6 @@ function resultToInfoCb(_path, cb) {
 }
 
 
-/*
- * Given an account and multipart upload operation (plus an upload id and a
- * part number, if relevant), this function returns the correct url to send
- * a multipart upload related request to.
- *
- * In the current implementation of multipart uploads, parts of an upload are
- * stored at /<account>/uploads/[0-f]/<upload uuid>, where the parent directory
- * is the first character in the upload uuid. It is possible this may change in
- * the future, in order to allow for more simultaneously ongoing multipart
- * uploads.
- *
- * To allow clients an easier way to avoid knowing this exact path structure,
- * Muskie supports a redirect mechanism in which a client can do a normal
- * multipart upload request to the path /<account>/uploads/<upload uuid>,
- * and muskie will redirect it to the correct path, which the client can then
- * use for the request.
- *
- * We can implement this mechanism in the future, but for now, we just hardcode
- * the prefix.
- */
-function uploadURL(account, op, id, partNum) {
-    assert.string(account, 'account');
-    assert.string(op, 'op');
-
-    var ops = UPLOAD_OPS;
-    var baseURL = '/' + account + '/uploads';
-
-    if (op === ops.CREATE) {
-        return (baseURL);
-    } else {
-        assert.uuid(id, 'id');
-        assert.ok(id.length > 0);
-
-        var url = baseURL + '/' + id.charAt(0) + '/' + id;
-
-        switch (op) {
-            case ops.COMMIT:
-                return (url + '/commit');
-            case ops.ABORT:
-                return (url + '/abort');
-            case ops.GET:
-                return (url + '/state');
-            case ops.UPLOAD:
-                assert.number(partNum, 'partNum');
-                return (url + '/' + partNum);
-            default:
-                assert.fail('Invalid operation: ' + op);
-                return (undefined);
-        }
-    }
-}
-
 
 ///--- API
 
@@ -3288,6 +3236,129 @@ MantaClient.prototype.path = function _getPath(p, skipEncode) {
 
 ///--- Multipart Uploads API
 
+/*
+ * Given an account and multipart upload operation (plus an upload id and a
+ * part number, if relevant), this function returns the correct URL to send a
+ * multipart upload related request to.
+ *
+ * Multipart uploads are stored in subdirectories of the "/<account>/uploads"
+ * top-level directory.  The exact structure is not a committed interface: it
+ * can differ between different Manta deployments and can change over time with
+ * server-side configuration changes.  As such, the API allows the consumer to
+ * locate the full path to a multipart upload directory simply by knowing the
+ * ID of the upload.
+ *
+ * This function makes a request to the server as if the upload directory was
+ * anchored directly at the top level.  The server will respond with a redirect
+ * to the full path, which we use to construct the correct path for the
+ * nominated multipart upload operation.
+ */
+MantaClient.prototype._uploadURL = function _uploadURL(uu, done) {
+    assert.func(done, 'done');
+    assert.object(uu, 'uu');
+    assert.string(uu.uu_account, 'uu_account');
+    assert.string(uu.uu_op, 'uu_op');
+
+    var self = this;
+
+    var baseURL = '/' + uu.uu_account + '/uploads';
+
+    if (uu.uu_op === UPLOAD_OPS.CREATE) {
+        /*
+         * The create path is simply the top-level uploads directory.
+         */
+        setImmediate(done, null, baseURL);
+        return;
+    }
+
+    /*
+     * Manta allows us to make a request to the top-level upload directory as
+     * if the multipart upload was anchored there.  The response will be a
+     * redirect to the fully-qualified upload directory.
+     */
+    assert.uuid(uu.uu_id, 'uu_id');
+    assert.object(uu.uu_opts, 'uu_opts');
+    var idurl = baseURL + '/' + uu.uu_id;
+    var options = createOptions({
+        path: idurl
+    }, uu.uu_opts);
+
+    var log = this.log.child({
+        path: idurl,
+        req_id: options.id
+    }, true);
+
+    log.debug('_uploadURL: entered');
+
+    self.signRequest({ headers: options.headers }, function (serr) {
+        if (serr) {
+            serr = new Verror(serr, 'signing request');
+            log.debug(serr);
+            done(serr);
+            return;
+        }
+
+        self.client.head(options, function (err, req) {
+            if (err) {
+                err = new Verror(err, 'locating upload');
+                log.debug(err);
+                done(err);
+                return;
+            }
+
+            req.on('result', function (rerr, res) {
+                if (rerr && rerr.statusCode === 404) {
+                    log.debug(rerr);
+                    rerr = new FeatureNotSupportedError(rerr,
+                        'multipart upload');
+                    log.debug(rerr);
+                    done(rerr);
+                    return;
+                }
+
+                if (rerr) {
+                    rerr = new Verror(err, 'locating upload');
+                    log.debug(rerr);
+                    done(rerr);
+                    return;
+                }
+
+                if (res.statusCode !== 301) {
+                    res.resume();
+
+                    rerr = new Verror('locating upload: unexpected status %d',
+                        res.statusCode);
+                    log.debug(rerr);
+                    done(rerr);
+                    return;
+                }
+
+                var finalURL;
+
+                switch (uu.uu_op) {
+                case UPLOAD_OPS.COMMIT:
+                    finalURL = res.headers['location'] + '/commit';
+                    break;
+                case UPLOAD_OPS.ABORT:
+                    finalURL = res.headers['location'] + '/abort';
+                    break;
+                case UPLOAD_OPS.GET:
+                    finalURL = res.headers['location'] + '/state';
+                    break;
+                case UPLOAD_OPS.UPLOAD:
+                    assert.number(uu.uu_partNum, 'partNum');
+                    finalURL = res.headers['location'] + '/' + uu.uu_partNum;
+                    break;
+                default:
+                    throw (new Verror('Invalid operation: %s', uu.uu_op));
+                }
+
+                done(null, finalURL);
+            });
+        });
+    });
+};
+
 
 /*
  * Creates a multipart upload in Manta.
@@ -3321,76 +3392,90 @@ MantaClient.prototype.createUpload = function createUpload(p, opts, cb) {
     assert.optionalString(opts.md5, 'opts.md5');
     assert.func(cb, 'callback');
 
-    var url = uploadURL(opts.account, UPLOAD_OPS.CREATE);
-    var objectPath = this.path(p);
-
-    var createOpts = jsprim.deepCopy(opts);
-    if (createOpts.headers) {
-        // We don't want headers for the target object to be interpreted as
-        // headers on the request, so we don't pass those to createOptions().
-        delete createOpts.headers;
-    }
+    var self = this;
 
-    var options = createOptions({
-        accept: 'application/json',
-        contentType: 'application/json',
-        path: url
-    }, createOpts);
+    self._uploadURL({
+        uu_op: UPLOAD_OPS.CREATE,
+        uu_account: opts.account,
+        uu_opts: opts
+    }, function (uerr, url) {
+        if (uerr) {
+            cb(uerr);
+            return;
+        }
 
-    var targetObjectHeaders = {};
-    if (opts.headers) {
-        targetObjectHeaders = jsprim.deepCopy(opts.headers);
-    }
+        var objectPath = self.path(p);
 
-    if (opts.copies) {
-        targetObjectHeaders['durability-level'] = opts.copies;
-    }
+        var createOpts = jsprim.deepCopy(opts);
+        if (createOpts.headers) {
+            /*
+             * We don't want headers for the target object to be interpreted as
+             * headers on the request, so we don't pass those to
+             * createOptions().
+             */
+            delete createOpts.headers;
+        }
 
-    if (opts.size) {
-        targetObjectHeaders['content-length'] = opts.size;
-    }
+        var options = createOptions({
+            accept: 'application/json',
+            contentType: 'application/json',
+            path: url
+        }, createOpts);
 
-    if (opts.md5) {
-        targetObjectHeaders['content-md5'] = opts.md5;
-    }
+        var targetObjectHeaders = {};
+        if (opts.headers) {
+            targetObjectHeaders = jsprim.deepCopy(opts.headers);
+        }
 
-    var log = this.log.child({
-        path: url,
-        req_id: options.id
-    }, true);
+        if (opts.copies) {
+            targetObjectHeaders['durability-level'] = opts.copies;
+        }
 
-    var self = this;
+        if (opts.size) {
+            targetObjectHeaders['content-length'] = opts.size;
+        }
 
-    log.debug('createUpload: entered');
-    self.signRequest({
-        headers: options.headers
-    }, function onSignRequest(err) {
-        if (err) {
-            err = new Verror(err, 'signing request');
-            log.debug(err);
-            cb(err);
-            return;
+        if (opts.md5) {
+            targetObjectHeaders['content-md5'] = opts.md5;
         }
 
-        var body = {
-            objectPath: objectPath,
-            headers: targetObjectHeaders
-        };
+        var log = self.log.child({
+            path: url,
+            req_id: options.id
+        }, true);
 
-        self.jsonClient.post(options, body, function (err2, req, res, obj) {
-            if (err2) {
-                log.debug(err2);
-                if (err2.statusCode === 404) {
-                    cb(new FeatureNotSupportedError(err2, 'multipart upload'));
+        log.debug('createUpload: entered');
+        self.signRequest({
+            headers: options.headers
+        }, function onSignRequest(err) {
+            if (err) {
+                err = new Verror(err, 'signing request');
+                log.debug(err);
+                cb(err);
+                return;
+            }
+
+            var body = {
+                objectPath: objectPath,
+                headers: targetObjectHeaders
+            };
+
+            self.jsonClient.post(options, body, function (err2, req, res, obj) {
+                if (err2) {
+                    log.debug(err2);
+                    if (err2.statusCode === 404) {
+                        cb(new FeatureNotSupportedError(err2,
+                            'multipart upload'));
+                    } else {
+                        cb(err2);
+                    }
                 } else {
-                    cb(err2);
+                    cb(null, obj);
                 }
-            } else {
-                cb(null, obj);
-            }
-        });
+            });
 
-        return;
+            return;
+        });
     });
 };
 
@@ -3414,63 +3499,73 @@ function uploadPart(stream, id, partNum, opts, cb) {
     assert.string(opts.account, 'opts.account');
     assert.func(cb, 'callback');
 
-    var op = UPLOAD_OPS.UPLOAD;
-    var url = uploadURL(opts.account, op, id, partNum);
-
-    var options = createOptions({
-        accept: 'application/json',
-        expect: '100-continue',
-        path: url
-    }, opts);
-
-    var log = this.log.child({
-        path: url,
-            req_id: options.id
-    }, true);
-
     var self = this;
 
-    log.debug('uploadPart: entered');
-    self.signRequest({
-        headers: options.headers
-    }, function onSignRequest(err) {
-        if (err) {
-            err = new Verror(err, 'signing request');
-            log.debug(err);
-            cb(err);
+    self._uploadURL({
+        uu_op: UPLOAD_OPS.UPLOAD,
+        uu_account: opts.account,
+        uu_id: id,
+        uu_partNum: partNum,
+        uu_opts: opts
+    }, function (uerr, url) {
+        if (uerr) {
+            cb(uerr);
             return;
         }
 
-        function reqCb(req) {
-            req.once('continue', function onContinue() {
-                log.debug('uploadPart: continue received');
-                if (stream.readable) {
-                    stream.pipe(req);
-                    stream.resume();
-                } else {
-                    req.end();
-                }
-            });
-        }
+        var options = createOptions({
+            accept: 'application/json',
+            expect: '100-continue',
+            path: url
+        }, opts);
 
-        self.client.put(options, onRequestCallback({
-            cb: cb,
-            log: log,
-            name: 'uploadPart',
-            onResult: onResultCallback({
-                cb: function onResultCb(err2, res) {
-                    if (err2 && err2.statusCode === 404) {
-                        cb(new FeatureNotSupportedError(err2,
-                            'multipart upload'));
+        var log = self.log.child({
+            path: url,
+                req_id: options.id
+        }, true);
+
+        log.debug('uploadPart: entered');
+        self.signRequest({
+            headers: options.headers
+        }, function onSignRequest(err) {
+            if (err) {
+                err = new Verror(err, 'signing request');
+                log.debug(err);
+                cb(err);
+                return;
+            }
+
+            function reqCb(req) {
+                req.once('continue', function onContinue() {
+                    log.debug('uploadPart: continue received');
+                    if (stream.readable) {
+                        stream.pipe(req);
+                        stream.resume();
                     } else {
-                        cb(err2, res);
+                        req.end();
                     }
-                },
+                });
+            }
+
+            self.client.put(options, onRequestCallback({
+                cb: cb,
                 log: log,
-                name: 'uploadPart'
-            }),
-            reqCb: reqCb
-        }));
+                name: 'uploadPart',
+                onResult: onResultCallback({
+                    cb: function onResultCb(err2, res) {
+                        if (err2 && err2.statusCode === 404) {
+                            cb(new FeatureNotSupportedError(err2,
+                                'multipart upload'));
+                        } else {
+                            cb(err2, res);
+                        }
+                    },
+                    log: log,
+                    name: 'uploadPart'
+                }),
+                reqCb: reqCb
+            }));
+        });
     });
 };
 
@@ -3490,44 +3585,56 @@ MantaClient.prototype.abortUpload = function abortUpload(id, opts, cb) {
     assert.string(opts.account, 'opts.account');
     assert.func(cb, 'callback');
 
-    var url = uploadURL(opts.account, UPLOAD_OPS.ABORT, id);
-    var options = createOptions({
-        path: url
-    }, opts);
-
-    var log = this.log.child({
-        path: url,
-        req_id: options.id
-    }, true);
-
     var self = this;
-    log.debug('abortUpload: entered');
-    self.signRequest({
-        headers: options.headers
-    }, function onSignRequest(err) {
-        if (err) {
-            err = new Verror(err, 'signing request');
-            log.debug(err);
-            cb(err);
+
+    self._uploadURL({
+        uu_op: UPLOAD_OPS.ABORT,
+        uu_account: opts.account,
+        uu_id: id,
+        uu_opts: opts
+    }, function (uerr, url) {
+        if (uerr) {
+            cb(uerr);
             return;
         }
 
-        self.jsonClient.post(options, function (err2, req, res, obj) {
-            if (err2) {
-                log.debug(err2);
-                if (err2.statusCode === 404) {
-                    cb(new FeatureNotSupportedError(err2, 'multipart upload'));
+        var options = createOptions({
+            path: url
+        }, opts);
+
+        var log = self.log.child({
+            path: url,
+            req_id: options.id
+        }, true);
+
+        log.debug('abortUpload: entered');
+        self.signRequest({
+            headers: options.headers
+        }, function onSignRequest(err) {
+            if (err) {
+                err = new Verror(err, 'signing request');
+                log.debug(err);
+                cb(err);
+                return;
+            }
+
+            self.jsonClient.post(options, function (err2, req, res, obj) {
+                if (err2) {
+                    log.debug(err2);
+                    if (err2.statusCode === 404) {
+                        cb(new FeatureNotSupportedError(err2,
+                            'multipart upload'));
+                    } else {
+                        cb(err2);
+                    }
                 } else {
-                    cb(err2);
+                    cb();
                 }
-            } else {
-                cb();
-            }
+            });
         });
     });
 };
 
-
 /*
  * Gets information about an upload, including its state, the path the
  * object will be uploaded to, headers for the object, and how many
@@ -3545,40 +3652,52 @@ MantaClient.prototype.getUpload = function getUpload(id, opts, cb) {
     assert.string(opts.account, 'opts.account');
     assert.func(cb, 'callback');
 
-    var url = uploadURL(opts.account, UPLOAD_OPS.GET, id);
-    var options = createOptions({
-        path: url
-    }, opts);
-
-    var log = this.log.child({
-        path: url,
-        req_id: options.id
-    }, true);
-
     var self = this;
 
-    log.debug('getUpload: entered');
-    self.signRequest({
-        headers: options.headers
-    }, function onSignRequest(err) {
-        if (err) {
-            err = new Verror(err, 'signing request');
-            log.debug(err);
-            cb(err);
+    self._uploadURL({
+        uu_op: UPLOAD_OPS.GET,
+        uu_account: opts.account,
+        uu_id: id,
+        uu_opts: opts
+    }, function (uerr, url) {
+        if (uerr) {
+            cb(uerr);
             return;
         }
 
-        self.jsonClient.get(options, function (err2, req, res, obj) {
-            if (err2) {
-                log.debug(err2);
-                if (err2.statusCode === 404) {
-                    cb(new FeatureNotSupportedError(err2, 'multipart upload'));
+        var options = createOptions({
+            path: url
+        }, opts);
+
+        var log = self.log.child({
+            path: url,
+            req_id: options.id
+        }, true);
+
+        log.debug('getUpload: entered');
+        self.signRequest({
+            headers: options.headers
+        }, function onSignRequest(err) {
+            if (err) {
+                err = new Verror(err, 'signing request');
+                log.debug(err);
+                cb(err);
+                return;
+            }
+
+            self.jsonClient.get(options, function (err2, req, res, obj) {
+                if (err2) {
+                    log.debug(err2);
+                    if (err2.statusCode === 404) {
+                        cb(new FeatureNotSupportedError(err2,
+                            'multipart upload'));
+                    } else {
+                        cb(err2);
+                    }
                 } else {
-                    cb(err2);
+                    cb(null, obj);
                 }
-            } else {
-                cb(null, obj);
-            }
+            });
         });
     });
 };
@@ -3600,42 +3719,55 @@ MantaClient.prototype.commitUpload = function commitUpload(id, p, opts, cb) {
     assert.string(opts.account, 'opts.account');
     assert.func(cb, 'callback');
 
-    var url = uploadURL(opts.account, UPLOAD_OPS.COMMIT, id);
-    var options = createOptions({
-        accept: 'application/json',
-        contentType: 'application/json',
-        path: url
-    }, opts);
-
-    var log = this.log.child({
-        path: url,
-        req_id: options.id
-    }, true);
-
     var self = this;
-    log.debug('commitUpload: entered');
-    self.signRequest({
-        headers: options.headers
-    }, function onSignRequest(err) {
-        if (err) {
-            err = new Verror(err, 'signing request');
-            log.debug(err);
-            cb(err);
+
+    self._uploadURL({
+        uu_op: UPLOAD_OPS.COMMIT,
+        uu_account: opts.account,
+        uu_id: id,
+        uu_opts: opts
+    }, function (uerr, url) {
+        if (uerr) {
+            cb(uerr);
             return;
         }
 
-        var body = { parts:  p };
-        self.jsonClient.post(options, body, function (err2, req, res) {
-            if (err2) {
-                log.debug(err2);
-                if (err2.statusCode === 404) {
-                    cb(new FeatureNotSupportedError(err2, 'multipart upload'));
+        var options = createOptions({
+            accept: 'application/json',
+            contentType: 'application/json',
+            path: url
+        }, opts);
+
+        var log = self.log.child({
+            path: url,
+            req_id: options.id
+        }, true);
+
+        log.debug('commitUpload: entered');
+        self.signRequest({
+            headers: options.headers
+        }, function onSignRequest(err) {
+            if (err) {
+                err = new Verror(err, 'signing request');
+                log.debug(err);
+                cb(err);
+                return;
+            }
+
+            var body = { parts:  p };
+            self.jsonClient.post(options, body, function (err2, req, res) {
+                if (err2) {
+                    log.debug(err2);
+                    if (err2.statusCode === 404) {
+                        cb(new FeatureNotSupportedError(err2,
+                            'multipart upload'));
+                    } else {
+                        cb(err2);
+                    }
                 } else {
-                    cb(err2);
+                    cb(null, res);
                 }
-            } else {
-                cb(null, res);
-            }
+            });
         });
     });
 };
