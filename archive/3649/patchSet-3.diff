From 3df22d59d3ad68cf84ff3dc0b963142282aed748 Mon Sep 17 00:00:00 2001
From: Dan McDonald <danmcd@joyent.com>
Date: Tue, 13 Mar 2018 14:37:06 -0400
Subject: [PATCH] New SVP messages & a version addition, but still WIP, on
 varpd

---
 usr/src/lib/varpd/svp/common/libvarpd_svp.c   | 91 ++++++++++++++++++-
 usr/src/lib/varpd/svp/common/libvarpd_svp.h   |  9 ++
 .../lib/varpd/svp/common/libvarpd_svp_prot.h  | 33 ++++++-
 .../varpd/svp/common/libvarpd_svp_remote.c    | 51 +++++++++++
 4 files changed, 181 insertions(+), 3 deletions(-)

diff --git a/usr/src/lib/varpd/svp/common/libvarpd_svp.c b/usr/src/lib/varpd/svp/common/libvarpd_svp.c
index 1f68939476..f03a4cb60c 100644
--- a/usr/src/lib/varpd/svp/common/libvarpd_svp.c
+++ b/usr/src/lib/varpd/svp/common/libvarpd_svp.c
@@ -360,7 +360,8 @@ static umem_cache_t *svp_lookup_cache;
 typedef enum svp_lookup_type {
 	SVP_L_UNKNOWN	= 0x0,
 	SVP_L_VL2	= 0x1,
-	SVP_L_VL3	= 0x2
+	SVP_L_VL3	= 0x2,
+	SVP_L_RVL3	= 0x3
 } svp_lookup_type_t;
 
 typedef struct svp_lookup {
@@ -374,6 +375,10 @@ typedef struct svp_lookup {
 			varpd_arp_handle_t	*svl_vah;
 			uint8_t			*svl_out;
 		} svl_vl3;
+		struct svl_lookup_rvl3 {
+			varpd_query_handle_t	*svl_handle;
+			overlay_target_point_t	*svl_point;
+		} svl_rvl3;
 	} svl_u;
 	svp_query_t				svl_query;
 } svp_lookup_t;
@@ -493,12 +498,35 @@ svp_shootdown_cb(svp_t *svp, const uint8_t *vl2mac, const struct in6_addr *uip,
 	libvarpd_inject_varp(svp->svp_hdl, vl2mac, NULL);
 }
 
+static void
+svp_rvl3_lookup_cb(svp_t *svp, svp_status_t status, /* XXX KEBE SAYS MORE */
+    void *arg)
+{
+	svp_lookup_t *svl = arg;
+	overlay_target_point_t *otp;
+
+	if (status != SVP_S_OK) {
+		libvarpd_plugin_query_reply(svl->svl_u.svl_rvl3.svl_handle,
+		    VARPD_LOOKUP_DROP);
+		umem_cache_free(svp_lookup_cache, svl);
+		return;
+	}
+
+	otp = svl->svl_u.svl_rvl3.svl_point;
+	/* XXX KEBE SAYS FILL ME IN! */
+	
+	libvarpd_plugin_query_reply(svl->svl_u.svl_rvl3.svl_handle,
+	    VARPD_LOOKUP_OK);
+	umem_cache_free(svp_lookup_cache, svl);
+}
+
 static svp_cb_t svp_defops = {
 	svp_vl2_lookup_cb,
 	svp_vl3_lookup_cb,
 	svp_vl2_invalidate_cb,
 	svp_vl3_inject_cb,
-	svp_shootdown_cb
+	svp_shootdown_cb,
+	svp_rvl3_lookup_cb,
 };
 
 static boolean_t
@@ -588,6 +616,57 @@ varpd_svp_destroy(void *arg)
 	umem_free(svp, sizeof (svp_t));
 }
 
+static void
+varpd_svp_lookup_l3(svp_t *svp, varpd_query_handle_t *vqh,
+    const overlay_targ_lookup_t *otl, overlay_target_point_t *otp)
+{
+	svp_lookup_t *slp;
+	uint32_t type;
+	const struct in6_addr *src = &otl->otl_addru.otlu_l3.otl3_srcip,
+	    *dst = &otl->otl_addru.otlu_l3.otl3_dstip;
+
+	/*
+	 * otl is an L3 request, so we have src/dst IPs for the inner packet.
+	 * We also have the vlan.
+	 *
+	 * Assume kernel's overlay module is caching well, so we are directly
+	 * going to query (i.e. no caching up here of actual destinations).
+	 *
+	 * Our existing remote sever (svp_remote), but with the new message
+	 * SVP_R_REMOTE_VL3_REQ.  Our naming of these functions already has
+	 * "remote" in it, but we'll use "rvl3" instead of "vl3".
+	 */
+
+	/* XXX KEBE SAYS DO SOME otl verification too... */
+	if (IN6_IS_ADDR_V4MAPPED(src)) {
+		if (!IN6_IS_ADDR_V4MAPPED(dst)) {
+			libvarpd_plugin_query_reply(vqh, VARPD_LOOKUP_DROP);
+			return;
+		}
+		type = SVP_VL3_IP;
+	} else {
+		if (IN6_IS_ADDR_V4MAPPED(dst)) {
+			libvarpd_plugin_query_reply(vqh, VARPD_LOOKUP_DROP);
+			return;
+		}
+		type = SVP_VL3_IPV6;
+	}
+
+	slp = umem_cache_alloc(svp_lookup_cache, UMEM_DEFAULT);
+	if (slp == NULL) {
+		libvarpd_plugin_query_reply(vqh, VARPD_LOOKUP_DROP);
+		return;
+	}
+
+	slp->svl_type = SVP_L_RVL3;
+	slp->svl_u.svl_rvl3.svl_handle = vqh;
+	slp->svl_u.svl_rvl3.svl_point = otp;
+
+	/* XXX KEBE SAYS FILL IN ARGS PROPERLY... */
+	svp_remote_rvl3_lookup(svp, &slp->svl_query, src, dst, type,
+	    otl->otl_vnetid, slp);
+}
+
 static void
 varpd_svp_lookup(void *arg, varpd_query_handle_t *vqh,
     const overlay_targ_lookup_t *otl, overlay_target_point_t *otp)
@@ -595,6 +674,14 @@ varpd_svp_lookup(void *arg, varpd_query_handle_t *vqh,
 	svp_lookup_t *slp;
 	svp_t *svp = arg;
 
+	/*
+	 * Shuffle off L3 lookups to their own codepath.
+	 */
+	if (otl->otl_l3req) {
+		varpd_svp_lookup_l3(svp, vqh, otl, otp);
+		return;
+	}
+
 	/*
 	 * Check if this is something that we need to proxy, eg. arp or ndp.
 	 */
diff --git a/usr/src/lib/varpd/svp/common/libvarpd_svp.h b/usr/src/lib/varpd/svp/common/libvarpd_svp.h
index 6a8cea61ae..b32bf5c3e7 100644
--- a/usr/src/lib/varpd/svp/common/libvarpd_svp.h
+++ b/usr/src/lib/varpd/svp/common/libvarpd_svp.h
@@ -74,6 +74,8 @@ typedef union svp_query_data {
 	svp_vl3_ack_t	sdq_vl3a;
 	svp_log_req_t	sdq_logr;
 	svp_lrm_ack_t	sdq_lrma;
+	svp_rvl3_req_t	sqd_rvl3r;
+	svp_rvl3_ack_t	sqd_rvl3a;
 } svp_query_data_t;
 
 typedef void (*svp_query_f)(svp_query_t *, void *);
@@ -245,6 +247,8 @@ typedef void (*svp_vl3_inject_f)(svp_t *, const uint16_t,
     const struct in6_addr *, const uint8_t *, const uint8_t *);
 typedef void (*svp_shootdown_f)(svp_t *, const uint8_t *,
     const struct in6_addr *, const uint16_t uport);
+/* XXX KEBE SAYS FILL ME IN! */
+typedef void (*svp_rvl3_lookup_f)(svp_t *, svp_status_t, void *);
 
 typedef struct svp_cb {
 	svp_vl2_lookup_f	scb_vl2_lookup;
@@ -252,6 +256,7 @@ typedef struct svp_cb {
 	svp_vl2_invalidation_f	scb_vl2_invalidate;
 	svp_vl3_inject_f	scb_vl3_inject;
 	svp_shootdown_f		scb_shootdown;
+	svp_rvl3_lookup_f	scb_rvl3_lookup;
 } svp_cb_t;
 
 /*
@@ -285,6 +290,10 @@ extern void svp_remote_vl3_lookup(svp_t *, svp_query_t *,
     const struct sockaddr *, void *);
 extern void svp_remote_vl2_lookup(svp_t *, svp_query_t *, const uint8_t *,
     void *);
+extern void svp_remote_rvl3_lookup(svp_t *, svp_query_t *,
+    const struct in6_addr *,const struct in6_addr *, uint32_t, uint32_t,
+    void *);
+
 
 /*
  * Init functions
diff --git a/usr/src/lib/varpd/svp/common/libvarpd_svp_prot.h b/usr/src/lib/varpd/svp/common/libvarpd_svp_prot.h
index 16dbdbec05..6ca5d60226 100644
--- a/usr/src/lib/varpd/svp/common/libvarpd_svp_prot.h
+++ b/usr/src/lib/varpd/svp/common/libvarpd_svp_prot.h
@@ -34,6 +34,8 @@ extern "C" {
  */
 
 #define	SVP_VERSION_ONE	1
+#define	SVP_VERSION_TWO	2
+/* XXX KEBE SAYS -- we are not yet ready to bump this. */
 #define	SVP_CURRENT_VERSION	SVP_VERSION_ONE
 
 typedef struct svp_req {
@@ -58,7 +60,9 @@ typedef enum svp_op {
 	SVP_R_LOG_ACK		= 0x0A,
 	SVP_R_LOG_RM		= 0x0B,
 	SVP_R_LOG_RM_ACK	= 0x0C,
-	SVP_R_SHOOTDOWN		= 0x0D
+	SVP_R_SHOOTDOWN		= 0x0D,
+	SVP_R_REMOTE_VL3_REQ	= 0x0E,
+	SVP_R_REMOTE_VL3_ACK	= 0x0F
 } svp_op_t;
 
 typedef enum svp_status {
@@ -119,6 +123,33 @@ typedef struct svp_vl3_ack {
 	uint8_t		sl3a_uip[16];
 } svp_vl3_ack_t;
 
+/*
+ * A client issues the SVP_R_REMOTE_VL3_REQ for a far-remote (cross-DC) VL3 IP
+ * address.  The server may take longer because it may query cross-DC to get
+ * the answer for our response.
+ */
+typedef struct svp_rvl3_req {
+	uint8_t		srl3r_srcip[16];
+	uint8_t		srl3r_dstip[16];
+	uint32_t	srl3r_type;	/* Same as SVP_R_VL3_REQ */
+	uint32_t	srl3r_vnetid;
+	/* KEBE ASKS -> should the request include the guess for the dcid? */
+} svp_rvl3_req_t;
+
+/*
+ * The remote-VL3 response contains more than the regular VL3 one, because
+ * overlay needs to rewrite the MAC header completely.
+ */
+typedef struct svp_rvl3_ack {
+	uint32_t	srl3a_status;
+	uint8_t		srl3a_dstmac[ETHERADDRL]; /* MAC of the target. */
+	uint8_t		srl3a_srcmac[ETHERADDRL]; /* MAC of the target's rtr */
+	uint16_t	srl3a_vlanid;
+	uint16_t	srl3a_uport;
+	uint32_t	srl3a_dcid;	/* Remote Data Center ID. */
+	uint8_t		srl3a_uip[16];
+} svp_rvl3_ack_t;
+
 /*
  * SVP_R_BULK_REQ requests a bulk dump of data. Currently we have two kinds of
  * data tables that we need to dump: VL3->VL2 mappings and VL2->UL3 mappings.
diff --git a/usr/src/lib/varpd/svp/common/libvarpd_svp_remote.c b/usr/src/lib/varpd/svp/common/libvarpd_svp_remote.c
index 8d482e4a12..c8032dd651 100644
--- a/usr/src/lib/varpd/svp/common/libvarpd_svp_remote.c
+++ b/usr/src/lib/varpd/svp/common/libvarpd_svp_remote.c
@@ -245,6 +245,8 @@ svp_remote_attach(svp_remote_t *srp, svp_t *svp)
 		libvarpd_panic("missing callback scb_vl2_invalidate");
 	if (svp->svp_cb.scb_vl3_inject == NULL)
 		libvarpd_panic("missing callback scb_vl3_inject");
+	if (svp->svp_cb.scb_rvl3_lookup == NULL)
+		libvarpd_panic("missing callback scb_rvl3_lookup");
 
 	check.svp_vid = svp->svp_vid;
 	if (avl_find(&srp->sr_tree, &check, &where) != NULL)
@@ -351,6 +353,55 @@ svp_remote_vl2_lookup(svp_t *svp, svp_query_t *sqp, const uint8_t *mac,
 	mutex_exit(&srp->sr_lock);
 }
 
+static void
+svp_remote_rvl3_lookup_cb(svp_query_t *sqp, void *arg)
+{
+	svp_t *svp = sqp->sq_svp;
+	svp_rvl3_ack_t *rvl3a = (svp_rvl3_ack_t *)sqp->sq_wdata;
+
+	if (sqp->sq_status == SVP_S_OK) {
+		svp->svp_cb.scb_rvl3_lookup(svp, sqp->sq_status,
+		    /* XXX KEBE SAYS MORE HERE */ arg);
+	} else {
+	}
+}
+
+void
+svp_remote_rvl3_lookup(svp_t *svp, svp_query_t *sqp, const struct in6_addr *src,
+    const struct in6_addr *dst, uint32_t type, uint32_t vnetid, void *arg)
+{
+	svp_remote_t *srp;
+	svp_rvl3_req_t *rvl3r = &sqp->sq_rdun.sqd_rvl3r;
+
+	srp = svp->svp_remote;
+	sqp->sq_func = svp_remote_rvl3_lookup_cb;
+	sqp->sq_arg = arg;
+	sqp->sq_svp = svp;
+	sqp->sq_state = SVP_QUERY_INIT;
+	sqp->sq_header.svp_ver = htons(SVP_CURRENT_VERSION);
+	sqp->sq_header.svp_op = htons(SVP_R_REMOTE_VL3_REQ);
+	sqp->sq_header.svp_size = htonl(sizeof (svp_vl2_req_t));
+	sqp->sq_header.svp_id = id_alloc(svp_idspace);
+	if (sqp->sq_header.svp_id == (id_t)-1)
+		libvarpd_panic("failed to allcoate from svp_idspace: %d",
+		    errno);
+	sqp->sq_header.svp_crc32 = htonl(0);
+	sqp->sq_rdata = rvl3r;
+
+	bcopy(src, rvl3r->srl3r_srcip, sizeof (struct in6_addr));
+	bcopy(dst, rvl3r->srl3r_dstip, sizeof (struct in6_addr));
+	/* Caller should've checked both are the same type... */
+	rvl3r->srl3r_type = type;
+	rvl3r->srl3r_vnetid = vnetid;
+
+	mutex_enter(&srp->sr_lock);
+	if (!svp_remote_conn_queue(srp, sqp)) {
+		sqp->sq_status = SVP_S_FATAL;
+		sqp->sq_func(sqp, arg);
+	}
+	mutex_exit(&srp->sr_lock);
+}
+
 static void
 svp_remote_vl3_lookup_cb(svp_query_t *sqp, void *arg)
 {
-- 
2.21.0

