commit 204cd5676ffad444035d91e5d23f9f8979df6af2 (refs/changes/45/3545/2)
Author: Joshua M. Clulow <jmc@joyent.com>
Date:   2018-03-06T00:52:50+00:00 (1 year, 7 months ago)
    
    MANTA-3141 binder saturated, manta sadness ensues

diff --git a/.gitignore b/.gitignore
index 7a34aae..44f1e83 100644
--- a/.gitignore
+++ b/.gitignore
@@ -9,3 +9,6 @@ cscope.out
 smf/manifests/*.xml
 *.tar.bz2
 core
+obj/
+balancer
+smf_adjust
diff --git a/.gitmodules b/.gitmodules
index d56577f..abd430d 100644
--- a/.gitmodules
+++ b/.gitmodules
@@ -13,3 +13,6 @@
 [submodule "deps/zookeeper-common"]
 	path = deps/zookeeper-common
 	url = https://github.com/joyent/zookeeper-common.git
+[submodule "deps/mname-balancer"]
+	path = deps/mname-balancer
+	url = https://github.com/joyent/mname-balancer.git
diff --git a/Makefile b/Makefile
index 93db64d..42cbcf1 100644
--- a/Makefile
+++ b/Makefile
@@ -5,26 +5,30 @@
 #
 
 #
-# Copyright (c) 2017, Joyent, Inc.
+# Copyright (c) 2018, Joyent, Inc.
 #
 
 #
 # Files
 #
-JS_FILES	:= $(shell ls *.js) $(shell find lib test -name '*.js')
-JSL_CONF_NODE	 = tools/jsl.node.conf
-JSL_FILES_NODE   = $(JS_FILES)
-JSSTYLE_FILES	 = $(JS_FILES)
-JSSTYLE_FLAGS    = -f tools/jsstyle.conf
-SMF_MANIFESTS_IN = smf/manifests/binder.xml.in deps/zookeeper-common/smf/manifests/zookeeper.xml.in
+JS_FILES :=		$(shell ls *.js) $(shell find lib test -name '*.js')
+JSL_CONF_NODE =		tools/jsl.node.conf
+JSL_FILES_NODE =	$(JS_FILES)
+JSSTYLE_FILES =		$(JS_FILES)
+JSSTYLE_FLAGS =		-f tools/jsstyle.conf
+SMF_MANIFESTS_IN =	smf/manifests/single-binder.xml.in \
+			smf/manifests/multi-binder.xml.in \
+			smf/manifests/binder-balancer.xml.in \
+			smf/manifests/mksockdir.xml.in \
+			deps/zookeeper-common/smf/manifests/zookeeper.xml.in
 
 #
 # Variables
 #
 
-NODE_PREBUILT_TAG	= zone
-NODE_PREBUILT_VERSION	:= v0.12.9
-NODE_PREBUILT_IMAGE	= fd2cc906-8938-11e3-beab-4359c665ac99
+NODE_PREBUILT_TAG =		zone
+NODE_PREBUILT_VERSION :=	v0.12.9
+NODE_PREBUILT_IMAGE =		fd2cc906-8938-11e3-beab-4359c665ac99
 
 include ./tools/mk/Makefile.defs
 ifeq ($(shell uname -s),SunOS)
@@ -38,21 +42,22 @@ include ./tools/mk/Makefile.smf.defs
 #
 # Env vars
 #
-PATH	:= $(NODE_INSTALL)/bin:${PATH}
+PATH :=			$(NODE_INSTALL)/bin:${PATH}
 
 #
 # MG Variables
 #
 
-RELEASE_TARBALL         := binder-pkg-$(STAMP).tar.bz2
-ROOT                    := $(shell pwd)
-RELSTAGEDIR             := /tmp/$(STAMP)
+RELEASE_TARBALL :=	binder-pkg-$(STAMP).tar.bz2
+ROOT :=			$(shell pwd)
+RELSTAGEDIR :=		/tmp/$(STAMP)
 
 #
 # Tools
 #
-BUNYAN		:= $(NODE) ./node_modules/.bin/bunyan
-NODEUNIT	:= $(NODE) ./node_modules/.bin/nodeunit
+BUNYAN :=		$(NODE) ./node_modules/.bin/bunyan
+NODEUNIT :=		$(NODE) ./node_modules/.bin/nodeunit
+CTFCONVERT :=		$(ROOT)/tmp/ctftools/bin/ctfconvert
 
 #
 # Repo-specific targets
@@ -66,6 +71,60 @@ check:: deps/zookeeper-common/.git
 
 CLEAN_FILES += $(NODEUNIT) ./node_modules/nodeunit npm-shrinkwrap.json
 
+#
+# We need to build some C software, and to make it debuggable we should
+# include CTF information.  Download the CTF tools:
+#
+STAMP_CTF :=		tmp/ctftools/.stamp
+$(STAMP_CTF):
+	rm -rf tmp/ctftools
+	./tools/download_ctftools
+	touch $@
+
+CLEAN_FILES += tmp/ctftools tmp/ctftools.*.tar.gz
+
+#
+# A load balancer sits in front of binder, built from the "mname-balancer.git"
+# repository.
+#
+.PHONY: balancer
+balancer: | $(STAMP_CTF) deps/mname-balancer/.git
+	@mkdir -p $(ROOT)/tmp/balancer.obj
+	cd deps/mname-balancer && $(MAKE) PROG=$(ROOT)/balancer \
+	    OBJ_DIR=$(ROOT)/tmp/balancer.obj \
+	    CTFCONVERT=$(CTFCONVERT) \
+	    $(ROOT)/balancer
+
+CLEAN_FILES += tmp/balancer.obj balancer
+
+#
+# The "smf_adjust" tool is used to configure instances of the binder SMF
+# service.
+#
+SMF_ADJUST_OBJS =	smf_adjust.o \
+			nvlist_equal.o \
+			utils.o \
+			smfx.o
+
+SMF_ADJUST_LIBS =	-lscf -lumem -lavl -lnvpair
+
+SMF_ADJUST_CFLAGS =	-gdwarf-2 -m32 -std=c99 -D__EXTENSIONS__ \
+			-Wall -Wextra -Werror \
+			-pthread -Wno-unused-parameter \
+			-Isrc/
+
+SMF_ADJUST_OBJDIR =	tmp/smf_adjust.obj
+
+CLEAN_FILES +=		tmp/smf_adjust.obj smf_adjust
+
+smf_adjust: $(SMF_ADJUST_OBJS:%=$(SMF_ADJUST_OBJDIR)/%) | $(STAMP_CTF)
+	gcc -o $@ $^ $(SMF_ADJUST_CFLAGS) $(SMF_ADJUST_LIBS)
+	$(CTFCONVERT) -l $@ $@
+
+$(SMF_ADJUST_OBJDIR)/%.o: src/%.c
+	@mkdir -p $(@D)
+	gcc -o $@ -c $(SMF_ADJUST_CFLAGS) $<
+
 .PHONY: test
 test: $(NODE_EXEC) all
 	$(NODEUNIT) test/*.test.js 2>&1 | $(BUNYAN)
@@ -76,7 +135,7 @@ scripts: deps/manta-scripts/.git
 	cp deps/manta-scripts/*.sh $(BUILD)/scripts
 
 .PHONY: release
-release: all $(SMF_MANIFESTS)
+release: all $(SMF_MANIFESTS) balancer smf_adjust
 	@echo "Building $(RELEASE_TARBALL)"
 	@mkdir -p $(RELSTAGEDIR)/root/opt/smartdc/binder
 	@mkdir -p $(RELSTAGEDIR)/root/opt/smartdc/boot
@@ -84,28 +143,34 @@ release: all $(SMF_MANIFESTS)
 	@touch $(RELSTAGEDIR)/site/.do-not-delete-me
 	@mkdir -p $(RELSTAGEDIR)/root
 	@mkdir -p $(RELSTAGEDIR)/root/opt/smartdc/binder/etc
-	cp -r   $(ROOT)/lib \
-		$(ROOT)/main.js \
-		$(ROOT)/node_modules \
-		$(ROOT)/package.json \
-		$(ROOT)/sapi_manifests \
-		$(ROOT)/deps/zookeeper-common/sapi_manifests \
-		$(ROOT)/deps/zookeeper-common/smf \
-		$(ROOT)/smf \
-		$(RELSTAGEDIR)/root/opt/smartdc/binder
+	cp -r $(ROOT)/lib \
+	    $(ROOT)/main.js \
+	    $(ROOT)/node_modules \
+	    $(ROOT)/package.json \
+	    $(ROOT)/sapi_manifests \
+	    $(ROOT)/deps/zookeeper-common/sapi_manifests \
+	    $(ROOT)/deps/zookeeper-common/smf \
+	    $(ROOT)/smf \
+	    $(ROOT)/bin \
+	    $(RELSTAGEDIR)/root/opt/smartdc/binder
+	cp \
+	    $(ROOT)/balancer \
+	    $(ROOT)/smf_adjust \
+	    $(RELSTAGEDIR)/root/opt/smartdc/binder/lib/
 	mkdir -p $(RELSTAGEDIR)/root/opt/smartdc/binder/build
 	cp -r \
-		$(ROOT)/build/node \
-		$(ROOT)/build/scripts \
-		$(RELSTAGEDIR)/root/opt/smartdc/binder/build
+	    $(ROOT)/build/node \
+	    $(ROOT)/build/scripts \
+	    $(RELSTAGEDIR)/root/opt/smartdc/binder/build
 	mkdir -p $(RELSTAGEDIR)/root/opt/smartdc/boot/scripts
 	cp -R $(RELSTAGEDIR)/root/opt/smartdc/binder/build/scripts/* \
 	    $(RELSTAGEDIR)/root/opt/smartdc/boot/scripts/
 	cp -R $(ROOT)/deps/sdc-scripts/* \
 	    $(RELSTAGEDIR)/root/opt/smartdc/boot/
 	cp -R $(ROOT)/boot/* $(RELSTAGEDIR)/root/opt/smartdc/boot/
-	cp -R $(ROOT)/deps/zookeeper-common/boot/* $(RELSTAGEDIR)/root/opt/smartdc/boot/
-	(cd $(RELSTAGEDIR) && $(TAR) -jcf $(ROOT)/$(RELEASE_TARBALL) root site)
+	cp -R $(ROOT)/deps/zookeeper-common/boot/* \
+	    $(RELSTAGEDIR)/root/opt/smartdc/boot/
+	cd $(RELSTAGEDIR) && $(TAR) -jcf $(ROOT)/$(RELEASE_TARBALL) root site
 	@rm -rf $(RELSTAGEDIR)
 
 
diff --git a/bin/balstat b/bin/balstat
new file mode 100755
index 0000000..f15232a
--- /dev/null
+++ b/bin/balstat
@@ -0,0 +1,32 @@
+#!/bin/bash
+#
+# This Source Code Form is subject to the terms of the Mozilla Public
+# License, v. 2.0. If a copy of the MPL was not distributed with this
+# file, You can obtain one at http://mozilla.org/MPL/2.0/.
+#
+
+#
+# Copyright (c) 2018, Joyent, Inc.
+#
+
+#
+# Gather some basic information about the running balancer process.  This
+# script is emphatically not a replacement for a real control plane, but in a
+# pinch should make it easy to see backend health and remote peer associations.
+#
+
+printf 'BACKENDS:\n\n'
+
+printf '%12s %8s %4s %8s %s\n' 'OBJECT' 'BACKEND' 'OK?' '#REMOTES' 'SOCKET PATH'
+mdb -o nostop -p $(pgrep -x balancer) -e "g_backends::walk avl | \
+    ::printf \"%12p %8d %4d %8d %s\\n\" backend_t . be_id be_ok be_remotes \
+    be_path" 2>/dev/null
+
+printf '\nREMOTE PEERS:\n\n'
+
+printf '%12s %8s %12s\n' 'OBJECT' 'BACKEND' 'REMOTE IP'
+mdb -o nostop -p $(pgrep -x balancer) -e "g_remotes::walk avl | \
+    ::printf \"%12p %8d %12I\\n\" remote_t . rem_backend rem_addr.S_un.S_addr" \
+    2>/dev/null
+
+printf '\n'
diff --git a/boot/setup.sh b/boot/setup.sh
index 7cdbb65..e3ce38d 100755
--- a/boot/setup.sh
+++ b/boot/setup.sh
@@ -1,5 +1,4 @@
 #!/bin/bash
-# -*- mode: shell-script; fill-column: 80; -*-
 #
 # This Source Code Form is subject to the terms of the Mozilla Public
 # License, v. 2.0. If a copy of the MPL was not distributed with this
@@ -7,9 +6,16 @@
 #
 
 #
-# Copyright (c) 2014, Joyent, Inc.
+# Copyright (c) 2018, Joyent, Inc.
 #
 
+#
+# The "BINDER_PROCS_PER_ZONE" SAPI property allows the operator to increase the
+# number of instances of the binder SMF service created for this zone.  Cap
+# this value at a reasonable maximum of 32 processes.
+#
+MANTA_BINDER_MAX_PROCS=32
+
 export PS4='[\D{%FT%TZ}] ${BASH_SOURCE}:${LINENO}: ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
 set -o xtrace
 
@@ -46,7 +52,30 @@ if [[ ${FLAVOR} == "manta" ]]; then
     echo "Adding local manifest directories"
     manta_add_manifest_dir "/opt/smartdc/binder"
 
-    manta_common_setup "binder"
+    echo "Adding log rotation rules"
+    for (( i = 1; i <= MANTA_BINDER_MAX_PROCS; i++ )); do
+        ii=$(( 5300 + i ))
+        #
+        # If there are multiple binder processes configured, there will be
+        # multiple log files.  We need to upload each one with a distinct name,
+        # so we add the instance number before the zone UUID.
+        #
+        if ! logadm -w "binder-$ii" -C 48 -c -p 1h \
+          -t "/var/log/manta/upload/binder_$ii.\$nodename_%FT%H:00:00.log" \
+          "/var/svc/log/*binder-$ii.log"; then
+            fatal "could not add log rotation rule for instance $inum"
+        fi
+    done
+    if ! manta_add_logadm_entry 'binder-balancer'; then
+        fatal" could not add log rotation rule for balancer"
+    fi
+
+    #
+    # In order to arrange for specific log rotation behaviour, we opt out of
+    # the current logadm configuration step provided by "manta_common_setup".
+    #
+    skip_logrotate=1
+    manta_common_setup "binder" "$skip_logrotate"
 
     echo "Setting up ZooKeeper"
     # manta_setup_zookeeper
@@ -54,11 +83,37 @@ if [[ ${FLAVOR} == "manta" ]]; then
 
     zk_common_import ${SVC_ROOT}
 
-    echo "Installing binder"
-    svccfg import ${SVC_ROOT}/smf/manifests/binder.xml
-    # || \
-    #     fatal "unable to import binder"
-    # svcadm enable binder || fatal "unable to start binder"
+    echo "Installing binder socket directory SMF service"
+    if ! svccfg import ${SVC_ROOT}/smf/manifests/mksockdir.xml; then
+        fatal "unable to import binder socket directory service"
+    fi
+
+    echo "Installing binder balancer SMF service"
+    if ! svccfg import ${SVC_ROOT}/smf/manifests/binder-balancer.xml; then
+        fatal "unable to import binder balancer service"
+    fi
+
+    echo "Installing binder SMF service"
+    if ! svccfg import ${SVC_ROOT}/smf/manifests/multi-binder.xml; then
+        fatal "unable to import binder service"
+    fi
+
+    #
+    # Determine the desired number of binder instances for this zone.
+    #
+    nprocs=1
+    if ! res=$(json -f $METADATA BINDER_PROCS_PER_ZONE); then
+        fatal "unable to load metadata JSON"
+    fi
+    if [[ -n $res && $res -gt 1 && $res -le $MANTA_BINDER_MAX_PROCS ]]; then
+        nprocs=$res
+    fi
+
+    echo "Configuring instances of binder SMF service"
+    if ! /opt/smartdc/binder/lib/smf_adjust -s 'svc:/manta/application/binder' \
+      -b binder -B 5301 -i $nprocs; then
+        fatal "unable to configure instances of binder SMF service"
+    fi
 
     manta_common_setup_end
 
@@ -77,7 +132,7 @@ else # FLAVOR == "sdc"
     zk_common_import ${SVC_ROOT}
 
     echo "Importing binder SMF manifest."
-    svccfg import /opt/smartdc/binder/smf/manifests/binder.xml \
+    svccfg import /opt/smartdc/binder/smf/manifests/single-binder.xml \
         || fatal "unable to import binder manifest"
     svcadm enable binder || fatal "unable to start binder"
 
diff --git a/deps/mname-balancer b/deps/mname-balancer
new file mode 160000
index 0000000..1521b33
--- /dev/null
+++ b/deps/mname-balancer
@@ -0,0 +1 @@
+Subproject commit 1521b336b8537dbdf0d6aa1fd80d026e03ce7ca6
diff --git a/lib/server.js b/lib/server.js
index 2ebe05f..6aa2ba8 100644
--- a/lib/server.js
+++ b/lib/server.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2014, Joyent, Inc.
+ * Copyright (c) 2018, Joyent, Inc.
  */
 
 var assert = require('assert-plus');
@@ -543,7 +543,29 @@ function createServer(options) {
         });
 
         server.start = function start(callback) {
-                var done = 0;
+                var remaining = 2;
+                var check = function () {
+                        if (--remaining > 0) {
+                                return;
+                        }
+
+                        if (typeof (callback) === 'function') {
+                                setImmediate(callback);
+                        }
+                };
+
+                if (options.balancerSocket) {
+                        remaining++;
+                        server.listenBalancer({
+                                path: options.balancerSocket
+                        }, function () {
+                                options.log.info({
+                                        path: options.balancerSocket
+                                }, 'Balancer service started');
+                                check();
+                        });
+                }
+
                 server.listenUdp({
                         port: options.port,
                         address: options.host
@@ -552,8 +574,7 @@ function createServer(options) {
                                 host: options.host,
                                 port: options.port
                         }, 'UDP DNS service started');
-                        if (++done >= 2 && typeof (callback) === 'function')
-                                callback();
+                        check();
                 });
                 server.listenTcp({
                         port: options.port,
@@ -563,8 +584,7 @@ function createServer(options) {
                                 host: options.host,
                                 port: options.port
                         }, 'TCP DNS service started');
-                        if (++done >= 2 && typeof (callback) === 'function')
-                                callback();
+                        check();
                 });
         };
 
diff --git a/main.js b/main.js
index 10d1c36..f7493d9 100644
--- a/main.js
+++ b/main.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2014, Joyent, Inc.
+ * Copyright (c) 2018, Joyent, Inc.
  */
 
 var fs = require('fs');
@@ -49,7 +49,7 @@ var LOG = bunyan.createLogger({
 function parseOptions() {
         var option;
         var opts = {};
-        var parser = new getopt.BasicParser('hva:s:p:f:', process.argv);
+        var parser = new getopt.BasicParser('hva:b:s:p:f:', process.argv);
 
         while ((option = parser.getopt()) !== undefined) {
                 switch (option.option) {
@@ -57,6 +57,10 @@ function parseOptions() {
                         opts.expiry = parseInt(option.optarg, 10);
                         break;
 
+                case 'b':
+                        opts.balancerSocket = option.optarg;
+                        break;
+
                 case 'f':
                         opts.configFile = option.optarg;
                         break;
@@ -113,6 +117,16 @@ function usage(msg) {
 }
 
 
+function safeUnlink(socketPath) {
+        try {
+                fs.unlinkSync(socketPath);
+        } catch (ex) {
+                if (ex && ex.code && ex.code !== 'ENOENT') {
+                        LOG.warn(ex, 'unlinking socket path "%s"', socketPath);
+                }
+        }
+}
+
 
 function run(opts) {
         vasync.pipeline({
@@ -135,11 +149,40 @@ function run(opts) {
                                         opts.recursion);
                                 _.recursion.on('ready', subcb);
                         },
+                        function initBalancer(_, subcb) {
+                                if (!opts.balancerSocket) {
+                                        setImmediate(subcb);
+                                        return;
+                                }
+
+                                process.on('SIGTERM', function () {
+                                        /*
+                                         * When the SMF service is disabled, we
+                                         * want to unlink our socket from the
+                                         * socket directory so that the load
+                                         * balancer knows we might not be
+                                         * coming back.
+                                         */
+                                        LOG.info('caught SIGTERM; unlinking ' +
+                                            'socket "%s"', opts.balancerSocket);
+                                        safeUnlink(opts.balancerSocket);
+                                        process.exit(0);
+                                });
+
+                                /*
+                                 * Unlink our socket path now, in case a stale
+                                 * socket remains in the file system.
+                                 */
+                                safeUnlink(opts.balancerSocket);
+
+                                setImmediate(subcb);
+                        },
                         function initServer(_, subcb) {
                                 _.server = core.createServer({
                                         name: NAME,
                                         log: LOG,
                                         port: opts.port,
+                                        balancerSocket: opts.balancerSocket,
                                         recursion: _.recursion,
                                         zkCache: _.zkCache,
                                         dnsDomain: opts.dnsDomain,
diff --git a/package.json b/package.json
index 5f4e700..3d18af3 100644
--- a/package.json
+++ b/package.json
@@ -1,7 +1,7 @@
 {
   "name": "binder",
   "description": "SmartDataService DNS Service",
-  "version": "1.1.0",
+  "version": "1.2.0",
   "author": "Joyent (joyent.com)",
   "license": "MPL-2.0",
   "private": true,
@@ -10,7 +10,7 @@
     "bunyan": "1.5.1",
     "clone": "0.1.1",
     "lru-cache": "2.7.0",
-    "mname": "1.3.5",
+    "mname": "https://github.com/joyent/node-mname.git#balancer",
     "mooremachine": "^2.1.0",
     "mname-client": "0.6.0",
     "posix-getopt": "1.0.0",
diff --git a/smf/manifests/binder-balancer.xml.in b/smf/manifests/binder-balancer.xml.in
new file mode 100644
index 0000000..6a46e88
--- /dev/null
+++ b/smf/manifests/binder-balancer.xml.in
@@ -0,0 +1,60 @@
+<?xml version="1.0"?>
+<!DOCTYPE service_bundle SYSTEM "/usr/share/lib/xml/dtd/service_bundle.dtd.1">
+<!--
+    This Source Code Form is subject to the terms of the Mozilla Public
+    License, v. 2.0. If a copy of the MPL was not distributed with this
+    file, You can obtain one at http://mozilla.org/MPL/2.0/.
+-->
+
+<!--
+    Copyright (c) 2018, Joyent, Inc.
+-->
+
+<service_bundle type="manifest" name="binder-balancer">
+    <service name="manta/application/binder-balancer" type="service"
+      version="1">
+        <create_default_instance enabled="true" />
+        <single_instance />
+
+        <dependency type="service" name="network" grouping="require_all"
+          restart_on="error">
+            <service_fmri value="svc:/milestone/network:default" />
+        </dependency>
+
+        <dependency type="service" name="filesystem" grouping="require_all"
+          restart_on="error">
+            <service_fmri value="svc:/system/filesystem/local" />
+        </dependency>
+
+        <dependency type="service" name="mdata" grouping="require_all"
+          restart_on="none">
+            <service_fmri value="svc:/smartdc/mdata:execute" />
+        </dependency>
+
+        <dependency type="service" name="config-agent" grouping="optional_all"
+          restart_on="none">
+            <service_fmri value="svc:/smartdc/application/config-agent" />
+        </dependency>
+
+        <exec_method type="method" name="start" timeout_seconds="10"
+          exec="/opt/smartdc/binder/lib/balancer -s /var/run/binder/sockets
+          &amp;">
+            <method_context working_directory="/tmp">
+                <method_credential user="nobody" group="nobody"
+                  privileges="basic,net_privaddr" />
+            </method_context>
+        </exec_method>
+
+        <exec_method type="method" name="refresh" exec=":kill"
+          timeout_seconds="30" />
+
+        <exec_method type="method" name="stop" exec=":kill"
+          timeout_seconds="30" />
+
+        <template>
+            <common_name>
+                <loctext xml:lang="C">Binder Loadbalancer</loctext>
+            </common_name>
+        </template>
+    </service>
+</service_bundle>
diff --git a/smf/manifests/mksockdir.xml.in b/smf/manifests/mksockdir.xml.in
new file mode 100644
index 0000000..cf36ae0
--- /dev/null
+++ b/smf/manifests/mksockdir.xml.in
@@ -0,0 +1,40 @@
+<?xml version="1.0"?>
+<!DOCTYPE service_bundle SYSTEM "/usr/share/lib/xml/dtd/service_bundle.dtd.1">
+<!--
+    This Source Code Form is subject to the terms of the Mozilla Public
+    License, v. 2.0. If a copy of the MPL was not distributed with this
+    file, You can obtain one at http://mozilla.org/MPL/2.0/.
+-->
+
+<!--
+    Copyright (c) 2018, Joyent, Inc.
+-->
+
+<service_bundle type="manifest" name="binder-mksockdir">
+    <service name="manta/application/binder-mksockdir" type="service"
+      version="1">
+        <create_default_instance enabled="true" />
+        <single_instance />
+
+        <dependency type="service" name="filesystem" grouping="require_all"
+          restart_on="error">
+            <service_fmri value="svc:/system/filesystem/local" />
+        </dependency>
+
+        <exec_method type="method" name="start" timeout_seconds="60"
+          exec="/bin/bash /opt/smartdc/binder/smf/methods/mksockdir" />
+
+        <exec_method type="method" name="stop" timeout_seconds="10"
+          exec=":true" />
+
+        <property_group name="startd" type="framework">
+            <propval name="duration" type="astring" value="transient" />
+        </property_group>
+
+        <template>
+            <common_name>
+                <loctext xml:lang="C">Create binder socket directory</loctext>
+            </common_name>
+        </template>
+    </service>
+</service_bundle>
diff --git a/smf/manifests/multi-binder.xml.in b/smf/manifests/multi-binder.xml.in
new file mode 100644
index 0000000..8bca1e3
--- /dev/null
+++ b/smf/manifests/multi-binder.xml.in
@@ -0,0 +1,93 @@
+<?xml version="1.0"?>
+<!DOCTYPE service_bundle SYSTEM "/usr/share/lib/xml/dtd/service_bundle.dtd.1">
+<!--
+    This Source Code Form is subject to the terms of the Mozilla Public
+    License, v. 2.0. If a copy of the MPL was not distributed with this
+    file, You can obtain one at http://mozilla.org/MPL/2.0/.
+-->
+
+<!--
+    Copyright (c) 2018, Joyent, Inc.
+-->
+
+<service_bundle type="manifest" name="binder">
+    <service name="manta/application/binder" type="service" version="1">
+	<dependency name="network"
+		    grouping="require_all"
+		    restart_on="error"
+		    type="service">
+	    <service_fmri value="svc:/milestone/network:default" />
+	</dependency>
+
+	<dependency name="filesystem"
+		    grouping="require_all"
+		    restart_on="error"
+		    type="service">
+	    <service_fmri value="svc:/system/filesystem/local" />
+	</dependency>
+
+	<dependency name="mdata"
+		    grouping="require_all"
+		    restart_on="none"
+		    type="service">
+	    <service_fmri value="svc:/smartdc/mdata:execute" />
+	</dependency>
+
+	<dependency name="mksockdir"
+		    grouping="require_all"
+		    restart_on="none"
+		    type="service">
+		<service_fmri
+		    value="svc:/manta/application/binder-mksockdir:default" />
+	</dependency>
+
+        <dependency name="config-agent"
+                    grouping="optional_all"
+                    restart_on="none"
+                    type="service">
+            <service_fmri value="svc:/smartdc/application/config-agent" />
+        </dependency>
+
+	<dependency name="zookeeper"
+		    grouping="optional_all"
+		    restart_on="error"
+		    type="service">
+	    <service_fmri value="svc:smartdc/application/zookeeper" />
+	</dependency>
+
+	<exec_method type="method"
+		     name="start"
+		     exec="node --abort_on_uncaught_exception main.js
+		     -p %{config/instance} -b %{config/socket_path} &amp;"
+		     timeout_seconds="10">
+	    <method_context working_directory="/opt/smartdc/binder">
+                <method_credential user="nobody"
+                                   group="nobody"
+                                   privileges="basic,net_privaddr"/>
+                <method_environment>
+                    <envvar name="PATH"
+                            value="/opt/smartdc/binder/build/node/bin:/opt/local/bin:/usr/bin:/usr/sbin:/bin"/>
+                    <envvar name="LD_PRELOAD_32"
+                            value="/usr/lib/extendedFILE.so.1" />
+		</method_environment>
+            </method_context>
+	</exec_method>
+
+	<exec_method type="method"
+		     name="refresh"
+		     exec=":kill"
+		     timeout_seconds="10" />
+
+	<exec_method type="method"
+		     name="stop"
+		     exec=":kill"
+		     timeout_seconds="10" />
+
+	<template>
+	    <common_name>
+		<loctext xml:lang="C">Joyent DNS-ZooKeeper Service</loctext>
+	    </common_name>
+	</template>
+
+    </service>
+</service_bundle>
diff --git a/smf/manifests/binder.xml.in b/smf/manifests/single-binder.xml.in
similarity index 100%
rename from smf/manifests/binder.xml.in
rename to smf/manifests/single-binder.xml.in
diff --git a/smf/methods/mksockdir b/smf/methods/mksockdir
new file mode 100755
index 0000000..e30d2f6
--- /dev/null
+++ b/smf/methods/mksockdir
@@ -0,0 +1,29 @@
+#!/bin/bash
+#
+# This Source Code Form is subject to the terms of the Mozilla Public
+# License, v. 2.0. If a copy of the MPL was not distributed with this
+# file, You can obtain one at http://mozilla.org/MPL/2.0/.
+#
+
+#
+# Copyright (c) 2018, Joyent, Inc.
+#
+
+SOCKDIR='/var/run/binder/sockets'
+
+if ! /usr/bin/mkdir -p "$SOCKDIR"; then
+	printf 'ERROR: could not create "%s"\n' "$SOCKDIR" >&2
+	exit 1
+fi
+
+if ! /usr/bin/chown nobody:nobody "$SOCKDIR"; then
+	printf 'ERROR: could not chown "%s" to "nobody"\n' "$SOCKDIR" >&2
+	exit 1
+fi
+
+if ! /usr/bin/chmod 770 "$SOCKDIR"; then
+	printf 'ERROR: could not chmod 770 "%s"\n' "$SOCKDIR" >&2
+	exit 1
+fi
+
+exit 0
diff --git a/src/nvlist_equal.c b/src/nvlist_equal.c
new file mode 100644
index 0000000..beac726
--- /dev/null
+++ b/src/nvlist_equal.c
@@ -0,0 +1,291 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2018, Joyent, Inc.
+ */
+
+#include <sys/debug.h>
+#include <string.h>
+#include "nvlist_equal.h"
+
+#define	COMPARE_BASIC_TYPE(a, b, load, type)				\
+	do {								\
+		type av, bv;						\
+									\
+		VERIFY0(load(a, &av));					\
+		VERIFY0(load(b, &bv));					\
+									\
+		return (av == bv);					\
+	} while (0)
+
+#define	COMPARE_BASIC_ARRAY(a, b, load, type)				\
+	do {								\
+		type *av, *bv;						\
+		uint_t an, bn;						\
+									\
+		VERIFY0(load(a, &av, &an));				\
+		VERIFY0(load(b, &bv, &bn));				\
+									\
+		if (an != bn) {						\
+			return (false);					\
+		}							\
+									\
+		for (uint_t i = 0; i < an; i++) {			\
+			if (av[i] != bv[i]) {				\
+				return (false);				\
+			}						\
+		}							\
+									\
+		return (true);						\
+	} while (0)
+
+bool
+nvpair_equal(nvpair_t *a, nvpair_t *b)
+{
+	if (nvpair_type(a) != nvpair_type(b)) {
+		return (false);
+	}
+
+	switch (nvpair_type(a)) {
+	case DATA_TYPE_NVLIST: {
+		nvlist_t *av, *bv;
+
+		VERIFY0(nvpair_value_nvlist(a, &av));
+		VERIFY0(nvpair_value_nvlist(b, &bv));
+
+		/*
+		 * XXX This will abort if the nested nvlists were not allocated
+		 * with NV_UNIQUE_NAME.
+		 */
+		bool equal;
+		VERIFY0(nvlist_equal(av, bv, &equal));
+
+		return (equal);
+	}
+
+	case DATA_TYPE_NVLIST_ARRAY: {
+		nvlist_t **av, **bv;
+		uint_t an, bn;
+
+		VERIFY0(nvpair_value_nvlist_array(a, &av, &an));
+		VERIFY0(nvpair_value_nvlist_array(b, &bv, &bn));
+
+		if (an != bn) {
+			return (false);
+		}
+
+		for (uint_t i = 0; i < an; i++) {
+			/*
+			 * XXX This will abort if the nested nvlists were not
+			 * allocated with NV_UNIQUE_NAME.
+			 */
+			bool equal;
+			VERIFY0(nvlist_equal(av[i], bv[i], &equal));
+
+			if (!equal) {
+				return (false);
+			}
+		}
+
+		return (true);
+	}
+
+	case DATA_TYPE_BOOLEAN: {
+		return (true);
+	}
+
+	case DATA_TYPE_BOOLEAN_VALUE: {
+		boolean_t av, bv;
+
+		VERIFY0(nvpair_value_boolean_value(a, &av));
+		VERIFY0(nvpair_value_boolean_value(b, &bv));
+
+		return (!!av == !!bv);
+	}
+
+	case DATA_TYPE_BOOLEAN_ARRAY: {
+		boolean_t *av, *bv;
+		uint_t an, bn;
+
+		VERIFY0(nvpair_value_boolean_array(a, &av, &an));
+		VERIFY0(nvpair_value_boolean_array(b, &bv, &bn));
+
+		if (an != bn) {
+			return (false);
+		}
+
+		for (uint_t i = 0; i < an; i++) {
+			if (!!av != !!bv) {
+				return (false);
+			}
+		}
+
+		return (true);
+	}
+
+	case DATA_TYPE_STRING: {
+		char *av, *bv;
+
+		VERIFY0(nvpair_value_string(a, &av));
+		VERIFY0(nvpair_value_string(b, &bv));
+
+		return (strcmp(av, bv) == 0);
+	}
+
+	case DATA_TYPE_STRING_ARRAY: {
+		char **av, **bv;
+		uint_t an, bn;
+
+		VERIFY0(nvpair_value_string_array(a, &av, &an));
+		VERIFY0(nvpair_value_string_array(b, &bv, &bn));
+
+		if (an != bn) {
+			return (false);
+		}
+
+		for (uint_t i = 0; i < an; i++) {
+			if (strcmp(av[i], bv[i]) != 0) {
+				return (false);
+			}
+		}
+
+		return (true);
+	}
+
+	case DATA_TYPE_BYTE:
+		COMPARE_BASIC_TYPE(a, b, nvpair_value_byte, uchar_t);
+		break;
+
+	case DATA_TYPE_BYTE_ARRAY:
+		COMPARE_BASIC_ARRAY(a, b, nvpair_value_byte_array, uchar_t);
+		break;
+
+	case DATA_TYPE_INT8:
+		COMPARE_BASIC_TYPE(a, b, nvpair_value_int8, int8_t);
+		break;
+
+	case DATA_TYPE_INT8_ARRAY:
+		COMPARE_BASIC_ARRAY(a, b, nvpair_value_int8_array, int8_t);
+		break;
+
+	case DATA_TYPE_UINT8:
+		COMPARE_BASIC_TYPE(a, b, nvpair_value_uint8, uint8_t);
+		break;
+
+	case DATA_TYPE_UINT8_ARRAY:
+		COMPARE_BASIC_ARRAY(a, b, nvpair_value_uint8_array, uint8_t);
+		break;
+
+	case DATA_TYPE_INT16:
+		COMPARE_BASIC_TYPE(a, b, nvpair_value_int16, int16_t);
+		break;
+
+	case DATA_TYPE_INT16_ARRAY:
+		COMPARE_BASIC_ARRAY(a, b, nvpair_value_int16_array, int16_t);
+		break;
+
+	case DATA_TYPE_UINT16:
+		COMPARE_BASIC_TYPE(a, b, nvpair_value_uint16, uint16_t);
+		break;
+
+	case DATA_TYPE_UINT16_ARRAY:
+		COMPARE_BASIC_ARRAY(a, b, nvpair_value_uint16_array, uint16_t);
+		break;
+
+	case DATA_TYPE_INT32:
+		COMPARE_BASIC_TYPE(a, b, nvpair_value_int32, int32_t);
+		break;
+
+	case DATA_TYPE_INT32_ARRAY:
+		COMPARE_BASIC_ARRAY(a, b, nvpair_value_int32_array, int32_t);
+		break;
+
+	case DATA_TYPE_UINT32:
+		COMPARE_BASIC_TYPE(a, b, nvpair_value_uint32, uint32_t);
+		break;
+
+	case DATA_TYPE_UINT32_ARRAY:
+		COMPARE_BASIC_ARRAY(a, b, nvpair_value_uint32_array, uint32_t);
+		break;
+
+	case DATA_TYPE_INT64:
+		COMPARE_BASIC_TYPE(a, b, nvpair_value_int64, int64_t);
+		break;
+
+	case DATA_TYPE_INT64_ARRAY:
+		COMPARE_BASIC_ARRAY(a, b, nvpair_value_int64_array, int64_t);
+		break;
+
+	case DATA_TYPE_UINT64:
+		COMPARE_BASIC_TYPE(a, b, nvpair_value_uint64, uint64_t);
+		break;
+
+	case DATA_TYPE_UINT64_ARRAY:
+		COMPARE_BASIC_ARRAY(a, b, nvpair_value_uint64_array, uint64_t);
+		break;
+
+	case DATA_TYPE_HRTIME:
+		COMPARE_BASIC_TYPE(a, b, nvpair_value_hrtime, hrtime_t);
+		break;
+
+	case DATA_TYPE_DOUBLE:
+		COMPARE_BASIC_TYPE(a, b, nvpair_value_double, double);
+		break;
+
+	case DATA_TYPE_UNKNOWN:
+		abort();
+		break;
+	}
+
+	abort();
+}
+
+static bool
+nvlist_equal_half(nvlist_t *a, nvlist_t *b)
+{
+	VERIFY3P(a, !=, NULL);
+	VERIFY3P(b, !=, NULL);
+
+	for (nvpair_t *ap = nvlist_next_nvpair(a, NULL); ap != NULL;
+	    ap = nvlist_next_nvpair(a, ap)) {
+		int r;
+		nvpair_t *bp;
+
+		if ((r = nvlist_lookup_nvpair(b, nvpair_name(ap), &bp)) != 0) {
+			if (r == EINVAL && !nvlist_exists(b, nvpair_name(ap))) {
+				/*
+				 * There appears to be a bug in
+				 * nvlist_lookup_nvpair() causing it to return
+				 * EINVAL under some conditions where it should
+				 * really return ENOENT.
+				 */
+				r = ENOENT;
+			}
+			VERIFY3S(r, ==, ENOENT);
+
+			return (false);
+		}
+
+		if (!nvpair_equal(ap, bp)) {
+			return (false);
+		}
+	}
+
+	return (true);
+}
+
+/*
+ * Deep equality check for two nvlists allocated with NV_UNIQUE_NAME, and using
+ * only a limited range of data types (see the case block).
+ */
+int
+nvlist_equal(nvlist_t *a, nvlist_t *b, bool *equal)
+{
+	*equal = nvlist_equal_half(a, b) && nvlist_equal_half(b, a);
+
+	return (0);
+}
diff --git a/src/nvlist_equal.h b/src/nvlist_equal.h
new file mode 100644
index 0000000..b421de7
--- /dev/null
+++ b/src/nvlist_equal.h
@@ -0,0 +1,20 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2018, Joyent, Inc.
+ */
+
+#include <libnvpair.h>
+#include <stdbool.h>
+
+#ifndef	_NVLIST_EQUAL_H
+#define	_NVLIST_EQUAL_H
+
+extern bool nvpair_equal(nvpair_t *, nvpair_t *);
+extern int nvlist_equal(nvlist_t *, nvlist_t *, bool *);
+
+#endif	/* !_NVLIST_EQUAL_H */
diff --git a/src/smf_adjust.c b/src/smf_adjust.c
new file mode 100644
index 0000000..4a37ea9
--- /dev/null
+++ b/src/smf_adjust.c
@@ -0,0 +1,1082 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2018, Joyent, Inc.
+ */
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <stdarg.h>
+#include <stdbool.h>
+#include <err.h>
+#include <strings.h>
+#include <unistd.h>
+#include <errno.h>
+#include <time.h>
+#include <limits.h>
+#include <sys/avl.h>
+#include <sys/debug.h>
+#include <libnvpair.h>
+#include <libscf.h>
+
+#include "smfx.h"
+#include "utils.h"
+#include "nvlist_equal.h"
+
+
+
+#define	BINDER_SOCKET_PATH	"/var/run/binder/sockets/%ld"
+
+#define	SCF_SNAPSHOT_RUNNING	"running"
+
+static int nvlist_to_pg(scf_propertygroup_t *pg, nvlist_t *targ);
+static int pg_to_nvlist(scf_propertygroup_t *pg, nvlist_t **nvlp);
+
+static ssize_t max_scf_fmri_size;
+static ssize_t max_scf_name_size;
+static ssize_t max_scf_pg_type_size;
+static ssize_t max_scf_value_size;
+
+typedef struct inst {
+	long inst_number;
+	char *inst_name;
+
+	char *inst_fmri;
+
+	bool inst_needed;
+	bool inst_exists;
+
+	scf_instance_t *inst_instance;
+
+	avl_node_t inst_node;
+} inst_t;
+
+avl_tree_t g_insts;
+
+static int
+insts_compar(const void *first, const void *second)
+{
+	const inst_t *finst = first;
+	const inst_t *sinst = second;
+
+	int ret = strcmp(finst->inst_name, sinst->inst_name);
+
+	return (ret > 0 ? 1 : ret < 0 ? -1 : 0);
+}
+
+static int
+insts_add_common(const char *name, const char *base, unsigned idx, bool needed)
+{
+	inst_t *inst;
+
+	if ((inst = calloc(1, sizeof (*inst))) == NULL) {
+		return (-1);
+	}
+
+	if (name != NULL) {
+		if ((inst->inst_name = strdup(name)) == NULL) {
+			free(inst);
+			return (-1);
+		}
+	} else {
+		if (asprintf(&inst->inst_name, "%s-%u", base, idx) < 0) {
+			free(inst);
+			return (-1);
+		}
+	}
+
+	inst->inst_number = idx;
+	inst->inst_needed = needed;
+
+	avl_add(&g_insts, inst);
+
+	return (0);
+}
+
+static int
+insts_add_planned(const char *base, unsigned idx)
+{
+	return (insts_add_common(NULL, base, idx, true));
+}
+
+static int
+insts_add_unwanted(const char *name)
+{
+	return (insts_add_common(name, NULL, 0, false));
+}
+
+static inst_t *
+insts_lookup(const char *name)
+{
+	inst_t search;
+
+	search.inst_name = (char *)name;
+
+	return (avl_find(&g_insts, &search, NULL));
+}
+
+static int
+configure_scf(void)
+{
+	max_scf_fmri_size = scf_limit(SCF_LIMIT_MAX_FMRI_LENGTH) + 1;
+	max_scf_name_size = scf_limit(SCF_LIMIT_MAX_NAME_LENGTH) + 1;
+	max_scf_pg_type_size = scf_limit(SCF_LIMIT_MAX_PG_TYPE_LENGTH) + 1;
+	max_scf_value_size = scf_limit(SCF_LIMIT_MAX_VALUE_LENGTH) + 1;
+
+	if (max_scf_fmri_size < 1 || max_scf_name_size < 1 ||
+	    max_scf_pg_type_size < 1 || max_scf_value_size < 1) {
+		errx(1, "sizes are not > 0");
+	}
+
+	return (0);
+}
+
+static void
+fatal_scf(const char *name)
+{
+	errx(1, "%s: %s", name, scf_strerror(scf_error()));
+}
+
+static int
+remove_instance(smfx_t *smfx, scf_service_t *service, const char *name)
+{
+	scf_instance_t *i;
+	if (smfx_load_instance(smfx, service, name, &i) != 0) {
+		errno = EINVAL;
+		return (-1);
+	}
+
+	/*
+	 * Determine the full FMRI for this instance.
+	 */
+	char *fmri;
+	if (smfx_instance_fmri(smfx, i, &fmri) != 0) {
+		scf_instance_destroy(i);
+		errno = EINVAL;
+		return (-1);
+	}
+
+	/*
+	 * First we need to make sure the instance is not running.
+	 */
+	for (;;) {
+		char *st;
+
+		if ((st = smf_get_state(fmri)) == NULL) {
+			if (scf_error() == SCF_ERROR_NOT_FOUND) {
+				/*
+				 * Could it be that the service has never
+				 * been started!
+				 */
+				(void) smf_disable_instance(fmri, 0);
+				goto wait;
+			}
+			fatal_scf("smf_get_state");
+		}
+
+		printf("remove_instance: %s in state \"%s\"\n", fmri, st);
+
+		if (strcmp(st, SCF_STATE_STRING_DISABLED) == 0 ||
+		    strcmp(st, SCF_STATE_STRING_MAINT) == 0) {
+			printf("\tservice is offline\n");
+			break;
+		}
+
+		/*
+		 * This service is neither disabled, nor in the
+		 * maintenance state.  Try to disable it.
+		 */
+		printf("\tdisabling...\n");
+		if (smf_disable_instance(fmri, 0) != 0) {
+			fatal_scf("smf_disable_instance");
+		}
+
+wait:
+		sleep_ms(100);
+	}
+
+	/*
+	 * Now that the instance is not online, delete it.
+	 */
+	if (scf_instance_delete(i) != 0) {
+		fatal_scf("scf_instance_delete");
+	}
+
+	scf_instance_destroy(i);
+	free(fmri);
+	return (0);
+}
+
+static int
+nvpair_to_value(nvpair_t *nvp, scf_value_t *value, scf_type_t *typep)
+{
+	scf_type_t type;
+
+	switch (nvpair_type(nvp)) {
+	case DATA_TYPE_STRING: {
+		char *val;
+
+		VERIFY0(nvpair_value_string(nvp, &val));
+
+		if (scf_value_set_astring(value, val) != 0) {
+			fatal_scf("scf_value_set_astring");
+		}
+		type = SCF_TYPE_ASTRING;
+		break;
+	}
+
+	case DATA_TYPE_BOOLEAN_VALUE: {
+		boolean_t val;
+
+		VERIFY0(nvpair_value_boolean_value(nvp, &val));
+
+		scf_value_set_boolean(value, val ? 1 : 0);
+		type = SCF_TYPE_BOOLEAN;
+		break;
+	}
+
+	case DATA_TYPE_INT64: {
+		int64_t val;
+
+		VERIFY0(nvpair_value_int64(nvp, &val));
+
+		scf_value_set_integer(value, val);
+		type = SCF_TYPE_INTEGER;
+		break;
+	}
+
+	case DATA_TYPE_UINT64: {
+		uint64_t val;
+
+		VERIFY0(nvpair_value_uint64(nvp, &val));
+
+		scf_value_set_count(value, val);
+		type = SCF_TYPE_COUNT;
+		break;
+	}
+
+	default:
+		/*
+		 * Unsupported value type.
+		 */
+		VERIFY(!"unsupported value type");
+	}
+
+	if (typep != NULL) {
+		*typep = type;
+	}
+	return (0);
+}
+
+static int
+refresh_instance(smfx_t *smfx, scf_instance_t *i)
+{
+	char *fmri;
+	if (smfx_instance_fmri(smfx, i, &fmri) != 0) {
+		scf_instance_destroy(i);
+		return (-1);
+	}
+
+	if (smf_refresh_instance(fmri) != 0) {
+		fatal_scf("smf_disable_instance");
+	}
+
+	free(fmri);
+	return (0);
+}
+
+static int
+configure_instance(smfx_t *smfx, scf_instance_t *i, nvlist_t *targ)
+{
+	scf_handle_t *scf = scf_instance_handle(i);
+	nvlist_t *current = NULL, *fromsnap = NULL;
+	scf_propertygroup_t *pg = NULL, *cpg = NULL;
+
+	/*
+	 * Ensure that the property group exists and obtain a reference to it.
+	 */
+	if (smfx_ensure_pg(smfx, i, &pg, "config", SCF_GROUP_APPLICATION) !=
+	    0) {
+		errno = EINVAL;
+		return (-1);
+	}
+
+	/*
+	 * First, determine whether we need to make an update at all.  Check
+	 * to see if the current contents of the property group match our
+	 * desired contents.
+	 */
+	if (pg_to_nvlist(pg, &current) != 0) {
+		err(1, "pg_to_nvlist");
+	}
+
+	bool no_update;
+	if (nvlist_equal(current, targ, &no_update) != 0) {
+		err(1, "nvlist_equal");
+	}
+
+	if (no_update) {
+		printf("\t\tno update to pg required!\n");
+	} else {
+		printf("\t\tupdating pg from:\n");
+		dump_nvlist(current, 24);
+		printf("\t\t... to:\n");
+		dump_nvlist(targ, 24);
+		printf("\n");
+
+		if (nvlist_to_pg(pg, targ) != 0) {
+			err(1, "nvlist_to_pg");
+		}
+	}
+
+	bool refresh = false;
+	scf_snapshot_t *snap = NULL;
+
+	if (smfx_load_snapshot(smfx, i, SCF_SNAPSHOT_RUNNING, &snap) != 0) {
+		if (smfx_scf_error(smfx) != SCF_ERROR_NOT_FOUND) {
+			errx(1, "loading running snapshot: %s",
+			    smfx_errmsg(smfx));
+		}
+
+		printf("\t\tsnapshot \"%s\" not found\n",
+		    SCF_SNAPSHOT_RUNNING);
+
+		refresh = true;
+		goto refresh;
+	}
+
+	if ((cpg = scf_pg_create(scf)) == NULL) {
+		fatal_scf("scf_pg_create");
+	}
+
+	/*
+	 * We were able to find the "running" snapshot for this instance.
+	 * Let's load the contents of the "config" property group so that we
+	 * can determine if a refresh is required.
+	 */
+	if (scf_instance_get_pg_composed(i, snap, "config", cpg) != 0) {
+		if (scf_error() == SCF_ERROR_NOT_FOUND) {
+			/*
+			 * The property group does not appear in the
+			 * running snapshot at all.
+			 */
+			printf("\t\t\t\"config\" not in snapshot\n");
+			refresh = true;
+			goto refresh;
+		}
+
+		fatal_scf("scf_instance_get_pg_composed");
+	}
+
+	if (pg_to_nvlist(cpg, &fromsnap) != 0) {
+		err(1, "pg_to_nvlist (fromsnap)");
+	}
+
+	bool snapeq;
+	if (nvlist_equal(targ, fromsnap, &snapeq) != 0) {
+		err(1, "nvlist_equal (targ, fromsnap)");
+	}
+
+	if (!snapeq) {
+		printf("\t\tin snapshot, \"config\" exists:\n");
+		dump_nvlist(fromsnap, 24);
+		printf("\t\t... but needs to be:\n");
+		dump_nvlist(targ, 24);
+		printf("\n");
+
+		refresh = true;
+		goto refresh;
+	}
+
+refresh:
+	if (refresh) {
+		printf("\t\trefreshing...\n");
+		if (refresh_instance(smfx, i) != 0) {
+			warn("refreshing instance: %s", smfx_errmsg(smfx));
+		}
+	} else {
+		printf("\t\tno refresh required\n");
+	}
+
+	nvlist_free(current);
+	nvlist_free(fromsnap);
+	scf_pg_destroy(pg);
+	scf_pg_destroy(cpg);
+	return (0);
+}
+
+static int
+enable_instance(smfx_t *smfx, scf_instance_t *i, bool wait_for_online)
+{
+	char *fmri;
+	if (smfx_instance_fmri(smfx, i, &fmri) != 0) {
+		errno = EINVAL;
+		return (-1);
+	}
+
+	hrtime_t start = gethrtime();
+
+	char *st = NULL;
+again:
+	free(st);
+	if ((st = smf_get_state(fmri)) == NULL) {
+		fatal_scf("smf_get_state");
+	}
+
+	if (strcmp(st, SCF_STATE_STRING_ONLINE) == 0) {
+		/*
+		 * The service is already online; no action is required.
+		 */
+		goto done;
+	}
+
+	if (strcmp(st, SCF_STATE_STRING_MAINT) == 0 ||
+	    strcmp(st, SCF_STATE_STRING_DEGRADED) == 0) {
+		/*
+		 * The service is in the maintenance or degraded state.
+		 * Attempt to clear this state.
+		 */
+		if (smf_restore_instance(fmri) != 0) {
+			fatal_scf("smf_restore_instance");
+		}
+
+		goto wait;
+	}
+
+	if (strcmp(st, SCF_STATE_STRING_DISABLED) == 0 ||
+	    strcmp(st, SCF_STATE_STRING_UNINIT) == 0) {
+		/*
+		 * The service is disabled or has not yet been seen by
+		 * svc.startd.  Refresh the instance to ensure visibility of
+		 * the latest property group changes, and then enable the
+		 * instance.
+		 */
+		if (smf_refresh_instance(fmri) != 0) {
+			fatal_scf("smf_restore_instance");
+		}
+		if (smf_enable_instance(fmri, 0) != 0) {
+			fatal_scf("smf_restore_instance");
+		}
+
+		goto wait;
+	}
+
+	/*
+	 * The service is otherwise in an intermediate state and we do not
+	 * have a remedial action to take.
+	 */
+	if (!wait_for_online) {
+		printf("WARNING: not waiting, but \"%s\" in state \"%s\"\n",
+		    fmri, st);
+	}
+
+wait:
+	if (wait_for_online) {
+		/*
+		 * Don't wait more than 60 seconds for this situation to correct
+		 * itself.
+		 */
+		hrtime_t duration = gethrtime() - start;
+		if (duration > SEC2NSEC(60)) {
+			free(fmri);
+			free(st);
+			errno = ETIMEDOUT;
+			return (-1);
+		}
+
+		sleep_ms(100);
+		goto again;
+	}
+
+done:
+	free(fmri);
+	free(st);
+	return (0);
+}
+
+/*
+ * Create an nvlist which contains the properties from a property group.
+ */
+static int
+pg_to_nvlist(scf_propertygroup_t *pg, nvlist_t **nvlp)
+{
+	int e;
+	nvlist_t *nvl = NULL;
+	char *n = NULL, *sv = NULL;
+	scf_handle_t *scf = scf_pg_handle(pg);
+
+	*nvlp = NULL;
+
+	if ((e = nvlist_alloc(&nvl, NV_UNIQUE_NAME, 0)) != 0) {
+		goto fail;
+	}
+
+	if ((n = malloc(max_scf_name_size)) == NULL ||
+	    (sv = malloc(max_scf_value_size)) == NULL) {
+		e = errno;
+		goto fail;
+	}
+
+	/*
+	 * Allocate iterator objects.
+	 */
+	scf_iter_t *itp = NULL, *itv = NULL;
+	if ((itp = scf_iter_create(scf)) == NULL ||
+	    (itv = scf_iter_create(scf)) == NULL) {
+		fatal_scf("scf_iter_create");
+	}
+	scf_property_t *prop = NULL;
+	if ((prop = scf_property_create(scf)) == NULL) {
+		fatal_scf("scf_property_create");
+	}
+	scf_value_t *value = NULL;
+	if ((value = scf_value_create(scf)) == NULL) {
+		fatal_scf("scf_value_create");
+	}
+
+	/*
+	 * Walk the properties in the specified property group so that we
+	 * can construct an nvlist with the values we find.
+	 */
+	if (scf_iter_pg_properties(itp, pg) != 0) {
+		fatal_scf("scf_iter_pg_properties");
+	}
+
+	for (;;) {
+		int r;
+		if ((r = scf_iter_next_property(itp, prop)) < 0) {
+			fatal_scf("scf_iter_next_property");
+		} else if (r == 0) {
+			/*
+			 * No more properties.
+			 */
+			break;
+		}
+		VERIFY3S(r, ==, 1);
+
+		n[0] = '\0';
+		if (scf_property_get_name(prop, n, max_scf_name_size) < 0) {
+			fatal_scf("scf_pg_get_name");
+		}
+
+		/*
+		 * Walk each of the values for this property.  Note that we
+		 * only want one value per property at this time; multi-valued
+		 * properties will result in an error.
+		 */
+		scf_iter_reset(itv);
+		if (scf_iter_property_values(itv, prop) != 0) {
+			fatal_scf("scf_iter_property_values");
+		}
+
+		for (;;) {
+			if ((r = scf_iter_next_value(itv, value)) < 0) {
+				fatal_scf("scf_iter_next_value");
+			} else if (r == 0) {
+				/*
+				 * No more values.
+				 */
+				break;
+			}
+			VERIFY3S(r, ==, 1);
+
+			if (nvlist_exists(nvl, n)) {
+				warnx("property \"%s\" has more than one "
+				    "value", n);
+				e = EPROTO;
+				goto fail;
+			}
+
+			switch (scf_value_type(value)) {
+			case SCF_TYPE_ASTRING: {
+				sv[0] = '\0';
+				if (scf_value_get_astring(value, sv,
+				    max_scf_value_size) < 0) {
+					fatal_scf("scf_value_get_astring");
+				}
+
+				if ((e = nvlist_add_string(nvl, n, sv)) != 0) {
+					goto fail;
+				}
+
+				break;
+			}
+
+			case SCF_TYPE_BOOLEAN: {
+				uint8_t out;
+
+				if (scf_value_get_boolean(value, &out) != 0) {
+					fatal_scf("scf_value_get_boolean");
+				}
+
+				if ((e = nvlist_add_boolean_value(nvl, n, out ?
+				    B_TRUE : B_FALSE)) != 0) {
+					goto fail;
+				}
+
+				break;
+			}
+
+			case SCF_TYPE_COUNT: {
+				uint64_t out;
+
+				if (scf_value_get_count(value, &out) != 0) {
+					fatal_scf("scf_value_get_count");
+				}
+
+				if ((e = nvlist_add_uint64(nvl, n, out)) != 0) {
+					goto fail;
+				}
+
+				break;
+			}
+
+			case SCF_TYPE_INTEGER: {
+				int64_t out;
+
+				if (scf_value_get_integer(value, &out) != 0) {
+					fatal_scf("scf_value_get_integer");
+				}
+
+				if ((e = nvlist_add_int64(nvl, n, out)) != 0) {
+					goto fail;
+				}
+
+				break;
+			}
+
+			default:
+				warnx("invalid type for property \"%s\"", n);
+				e = EPROTO;
+				goto fail;
+			}
+		}
+	}
+
+fail:
+	scf_property_destroy(prop);
+	scf_value_destroy(value);
+	scf_iter_destroy(itp);
+	scf_iter_destroy(itv);
+	free(n);
+	free(sv);
+	if (e == 0) {
+		*nvlp = nvl;
+		return (0);
+	} else {
+		nvlist_free(nvl);
+
+		errno = e;
+		return (-1);
+	}
+}
+
+/*
+ * Update a property group so that its contents exactly match the contents we
+ * get from this nvlist.
+ */
+static int
+nvlist_to_pg(scf_propertygroup_t *pg, nvlist_t *targ)
+{
+	scf_handle_t *scf = scf_pg_handle(pg);
+
+	/*
+	 * First, load a view of the current property group into an nvlist,
+	 * as they are easier to work with.
+	 */
+	nvlist_t *cur;
+	if (pg_to_nvlist(pg, &cur) != 0) {
+		return (-1);
+	}
+
+	/*
+	 * Allocate and start a transaction in case we need to make changes
+	 * to the property group.
+	 */
+	bool dirty = false;
+	scf_transaction_t *txn;
+	if ((txn = scf_transaction_create(scf)) == NULL) {
+		fatal_scf("scf_transaction_create");
+	}
+	if (scf_transaction_start(txn, pg) != 0) {
+		fatal_scf("scf_transaction_start");
+	}
+
+	/*
+	 * Using the current nvlist, check to see if there are any properties
+	 * which do not exist in the target nvlist.  These properties will need
+	 * to be removed from the property group.
+	 */
+	for (nvpair_t *nvp = nvlist_next_nvpair(cur, NULL); nvp != NULL;
+	    nvp = nvlist_next_nvpair(cur, nvp)) {
+		if (nvlist_exists(targ, nvpair_name(nvp))) {
+			continue;
+		}
+
+		scf_transaction_entry_t *entry;
+		if ((entry = scf_entry_create(scf)) == NULL) {
+			fatal_scf("scf_entry_create");
+		}
+
+		dirty = true;
+		if (scf_transaction_property_delete(txn, entry,
+		    nvpair_name(nvp)) != 0) {
+			fatal_scf("scf_transaction_property_delete");
+		}
+	}
+
+	/*
+	 * Now that we have arranged to remove any properties that are in the
+	 * current list but not in the target list, we can do one pass through
+	 * the target list and check to see if we need to add or update any
+	 * properties.
+	 */
+	for (nvpair_t *nvp = nvlist_next_nvpair(targ, NULL); nvp != NULL;
+	    nvp = nvlist_next_nvpair(targ, nvp)) {
+		/*
+		 * Allocate the objects required to update a property.
+		 */
+		scf_transaction_entry_t *entry;
+		if ((entry = scf_entry_create(scf)) == NULL) {
+			fatal_scf("scf_entry_create");
+		}
+		scf_value_t *value;
+		if ((value = scf_value_create(scf)) == NULL) {
+			fatal_scf("scf_value_create");
+		}
+
+		scf_type_t type;
+		if (nvpair_to_value(nvp, value, &type) != 0) {
+			err(1, "nvpair_to_value");
+		}
+
+		if (!nvlist_exists(cur, nvpair_name(nvp))) {
+			/*
+			 * Add a new property to the property group.
+			 */
+			dirty = true;
+			if (scf_transaction_property_new(txn, entry,
+			    nvpair_name(nvp), type) != 0) {
+				fatal_scf("scf_transaction_property_new");
+			}
+
+			if (scf_entry_add_value(entry, value) != 0) {
+				fatal_scf("scf_entry_add_value");
+			}
+			continue;
+		}
+
+		nvpair_t *curnvp;
+		VERIFY0(nvlist_lookup_nvpair(cur, nvpair_name(nvp), &curnvp));
+
+		if (nvpair_equal(nvp, curnvp)) {
+			/*
+			 * The property exists already, and the target value
+			 * matches the current value.
+			 */
+			scf_value_destroy(value);
+			scf_entry_destroy(entry);
+			continue;
+		}
+
+		/*
+		 * The property exists already, but does not have the correct
+		 * value.
+		 */
+		dirty = true;
+		if (scf_transaction_property_change_type(txn, entry,
+		    nvpair_name(nvp), type) != 0) {
+			fatal_scf("scf_transaction_property_change_type");
+		}
+
+		if (scf_entry_add_value(entry, value) != 0) {
+			fatal_scf("scf_entry_add_value");
+		}
+	}
+
+	if (dirty) {
+		int r;
+
+		if ((r = scf_transaction_commit(txn)) < 0) {
+			fatal_scf("scf_transaction_commit");
+		} else if (r == 0) {
+			/*
+			 * XXX What to do with a concurrent modification,
+			 * early in the morning?
+			 */
+			abort();
+		}
+		VERIFY3S(r, ==, 1);
+	}
+	scf_transaction_destroy_children(txn);
+	scf_transaction_destroy(txn);
+	nvlist_free(cur);
+	return (0);
+}
+
+int
+main(int argc, char *argv[])
+{
+	int c;
+	const char *base = NULL;
+	const char *sfmri = NULL;
+	long instance_count = 1;
+	long base_number = 1;
+	smfx_t *smfx = NULL;
+	char smfx_msg[SMFX_ERROR_SIZE];
+	bool wait_for_start = false;
+
+	/*
+	 * We would like each line emitted by printf(3C) to appear promptly in
+	 * the log file that this command is generally redirected to.
+	 */
+	(void) setlinebuf(stdout);
+
+	while ((c = getopt(argc, argv, ":B:b:i:s:w")) != -1) {
+		switch (c) {
+		case 'B':
+			if (parse_long(optarg, &base_number, 10) != 0 ||
+			    base_number < 0 || base_number > 65535) {
+				err(1, "-%c requires integer from 0 to 65535",
+				    optopt);
+			}
+			break;
+
+		case 'b':
+			base = optarg;
+			break;
+
+		case 's':
+			sfmri = optarg;
+			break;
+
+		case 'i':
+			if (parse_long(optarg, &instance_count, 10) != 0 ||
+			    instance_count < 0 || instance_count > 32) {
+				err(1, "-%c requires integer from 0 to 32",
+				    optopt);
+			}
+			break;
+
+		case 'w':
+			wait_for_start = true;
+			break;
+
+		case ':':
+			errx(1, "Option -%c requires an operand", optopt);
+			break;
+
+		case '?':
+			errx(1, "Unrecognised option: -%c", optopt);
+			break;
+
+		default:
+			abort();
+		}
+	}
+
+	if (sfmri == NULL) {
+		errx(1, "Must provide service FMRI (-s)");
+	}
+
+	if (base == NULL) {
+		errx(1, "Must provide base instance name (-b)");
+	}
+
+	if (configure_scf() != 0) {
+		return (1);
+	}
+
+	if (smfx_alloc(&smfx, smfx_msg) != 0) {
+		errx(1, "smfx_alloc: %s", smfx_msg);
+	}
+
+	scf_service_t *service = NULL;
+	if (smfx_locate_service(smfx, sfmri, &service) != 0) {
+		errx(1, "could not locate service: %s", smfx_errmsg(smfx));
+	}
+
+	char *sn = safe_zalloc(max_scf_name_size);
+	if (scf_service_get_name(service, sn, max_scf_name_size) < 0) {
+		fatal_scf("scf_service_get_name");
+	}
+
+	printf("service name: %s\n", sn);
+	free(sn);
+
+	/*
+	 * Generate the list of expected instances.
+	 */
+	avl_create(&g_insts, insts_compar, sizeof (inst_t), offsetof(inst_t,
+	    inst_node));
+
+	for (unsigned k = 0; k < (unsigned)instance_count; k++) {
+		if (insts_add_planned(base, k + base_number) != 0) {
+			err(1, "inst_add_common");
+		}
+	}
+
+	/*
+	 * Get the list of instances which currently exist in the system.
+	 */
+	char *ina = safe_zalloc(max_scf_name_size);
+	scf_instance_t *instance = NULL;
+	if (smfx_instance_create(smfx, &instance) != 0) {
+		errx(1, "listing instances: %s", smfx_errmsg(smfx));
+	}
+
+	scf_iter_t *i_instance;
+	if ((i_instance = scf_iter_create(smfx_handle(smfx))) == NULL) {
+		fatal_scf("scf_iter_create (instance)");
+	}
+
+	if (scf_iter_service_instances(i_instance, service) != 0) {
+		fatal_scf("scf_iter_service_instances");
+	}
+	for (unsigned j = 0; ; j++) {
+		int q;
+
+		if ((q = scf_iter_next_instance(i_instance, instance)) < 0) {
+			fatal_scf("scf_iter_next_instance");
+		} else if (q == 0) {
+			break;
+		}
+		VERIFY3S(q, ==, 1);
+
+		if (scf_instance_get_name(instance, ina,
+		    max_scf_name_size) < 0) {
+			fatal_scf("scf_instance_get_name");
+		}
+
+		inst_t *i;
+		if ((i = insts_lookup(ina)) == NULL) {
+			/*
+			 * If we discover an instance during the walk which was
+			 * not added to the set during the planning phase, it
+			 * is surplus to requirements and will be torn down.
+			 */
+			if (insts_add_unwanted(ina) != 0) {
+				err(1, "insts_add_unwanted");
+			}
+
+			i = insts_lookup(ina);
+		}
+		i->inst_exists = true;
+	}
+	free(ina);
+	scf_iter_destroy(i_instance);
+
+	/*
+	 * Print out what we have found:
+	 */
+	printf("--- INSTANCES TO REMOVE\n");
+	for (inst_t *i = avl_last(&g_insts); i != NULL;
+	    i = AVL_PREV(&g_insts, i)) {
+		if (!i->inst_needed && i->inst_exists) {
+			printf("\t%s\n", i->inst_name);
+
+			if (remove_instance(smfx, service, i->inst_name) != 0) {
+				err(1, "remove_instance");
+			}
+
+			i->inst_exists = false;
+
+			printf("\n");
+		}
+	}
+
+	printf("--- INSTANCE LOAD/CREATE\n");
+	for (inst_t *i = avl_first(&g_insts); i != NULL;
+	    i = AVL_NEXT(&g_insts, i)) {
+		if (i->inst_needed) {
+			printf("\t%s\n", i->inst_name);
+
+			if (smfx_ensure_instance(smfx, service, i->inst_name,
+			    &i->inst_instance) != 0) {
+				errx(1, "ensuring instance \"%s\" exists: %s",
+				    i->inst_name, smfx_errmsg(smfx));
+			}
+
+			i->inst_exists = true;
+
+			printf("\n");
+		}
+	}
+
+	printf("--- INSTANCE CONFIGURATION\n");
+	for (inst_t *i = avl_first(&g_insts); i != NULL;
+	    i = AVL_NEXT(&g_insts, i)) {
+		if (i->inst_needed) {
+			printf("\t%s\n", i->inst_name);
+
+			/*
+			 * Create an nvlist with the full set of properties
+			 * that need to be in the "config" property group
+			 * for this instance.
+			 */
+			nvlist_t *targ;
+			int r;
+			if ((r = nvlist_alloc(&targ, NV_UNIQUE_NAME, 0)) != 0) {
+				errno = r;
+				err(1, "nvlist_alloc");
+			}
+
+			if ((r = nvlist_add_uint64(targ, "instance",
+			    i->inst_number)) != 0) {
+				errno = r;
+				err(1, "nvlist_add_string");
+			}
+
+			char buf[1000];
+			snprintf(buf, sizeof (buf), BINDER_SOCKET_PATH,
+			    i->inst_number);
+			if ((r = nvlist_add_string(targ, "socket_path", buf)) !=
+			    0) {
+				errno = r;
+				err(1, "nvlist_add_string");
+			}
+
+			if (configure_instance(smfx, i->inst_instance,
+			    targ) != 0) {
+				if (errno == EINVAL) {
+					errx(1,
+					    "configuring instance \"%s\": %s",
+					    i->inst_name, smfx_errmsg(smfx));
+				}
+				err(1, "configure_instance");
+			}
+
+			if (enable_instance(smfx, i->inst_instance,
+			    wait_for_start) != 0) {
+				if (errno == ETIMEDOUT) {
+					errx(1, "timed out enabling instance "
+					    "\"%s\"", i->inst_name);
+				}
+				VERIFY3S(errno, ==, EINVAL);
+				errx(1, "enabling instance \"%s\": %s",
+				    i->inst_name, smfx_errmsg(smfx));
+			}
+
+			nvlist_free(targ);
+
+			printf("\n");
+		}
+	}
+
+	inst_t *i;
+	void *cookie = NULL;
+	while ((i = avl_destroy_nodes(&g_insts, &cookie)) != NULL) {
+		scf_instance_destroy(i->inst_instance);
+		free(i->inst_name);
+		free(i->inst_fmri);
+		free(i);
+	}
+	avl_destroy(&g_insts);
+
+	smfx_free(smfx);
+	return (0);
+}
diff --git a/src/smfx.c b/src/smfx.c
new file mode 100644
index 0000000..d3933f4
--- /dev/null
+++ b/src/smfx.c
@@ -0,0 +1,434 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2018, Joyent, Inc.
+ */
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <stdarg.h>
+#include <stdbool.h>
+#include <err.h>
+#include <strings.h>
+#include <unistd.h>
+#include <errno.h>
+#include <time.h>
+#include <limits.h>
+#include <sys/avl.h>
+#include <sys/debug.h>
+#include <libnvpair.h>
+#include <libscf.h>
+
+#include "utils.h"
+#include "nvlist_equal.h"
+#include "smfx.h"
+
+struct smfx {
+	scf_handle_t *smfx_scf;
+	scf_scope_t *smfx_scope;
+
+	scf_error_t smfx_err;
+	char smfx_errmsg[SMFX_ERROR_SIZE];
+};
+
+scf_handle_t *
+smfx_handle(smfx_t *smfx)
+{
+	return (smfx->smfx_scf);
+}
+
+scf_error_t
+smfx_scf_error(smfx_t *smfx)
+{
+	return (smfx->smfx_err);
+}
+
+const char *
+smfx_errmsg(smfx_t *smfx)
+{
+	return (smfx->smfx_errmsg);
+}
+
+static void
+make_errmsg_scf(char *errmsg, const char *func)
+{
+	if (errmsg == NULL) {
+		return;
+	}
+
+	(void) snprintf(errmsg, SMFX_ERROR_SIZE, "%s: %s", func,
+	    scf_strerror(scf_error()));
+}
+
+static void
+make_errmsg_errno(char *errmsg, const char *func, int en)
+{
+	if (errmsg == NULL) {
+		return;
+	}
+
+	const char *es = strerror(en);
+	if (es == NULL) {
+		(void) snprintf(errmsg, SMFX_ERROR_SIZE, "%s: errno %d",
+		    func, en);
+	} else {
+		(void) snprintf(errmsg, SMFX_ERROR_SIZE, "%s: %s", func, es);
+	}
+}
+
+static void
+record_scf_error(smfx_t *smfx, const char *func)
+{
+	make_errmsg_scf(smfx->smfx_errmsg, func);
+	smfx->smfx_err = scf_error();
+}
+
+static void
+record_errno(smfx_t *smfx, const char *func)
+{
+	make_errmsg_errno(smfx->smfx_errmsg, func, errno);
+	smfx->smfx_err = SCF_ERROR_INTERNAL;
+}
+
+static void
+record_custom_error(smfx_t *smfx, const char *fmt, ...)
+{
+	va_list ap;
+	va_start(ap, fmt);
+
+	(void) vsnprintf(smfx->smfx_errmsg, SMFX_ERROR_SIZE, fmt, ap);
+
+	va_end(ap);
+}
+
+int
+smfx_alloc(smfx_t **smfxp, char *errmsg)
+{
+	smfx_t *smfx;
+
+	if ((smfx = calloc(1, sizeof (*smfx))) == NULL) {
+		make_errmsg_errno(errmsg, "calloc", errno);
+		return (-1);
+	}
+	smfx->smfx_err = SCF_ERROR_NONE;
+
+	if ((smfx->smfx_scf = scf_handle_create(SCF_VERSION)) == NULL) {
+		make_errmsg_scf(errmsg, "scf_handle_create");
+		free(smfx);
+		return (-1);
+	}
+
+	if (scf_handle_bind(smfx->smfx_scf) != 0) {
+		make_errmsg_scf(errmsg, "scf_handle_bind");
+		scf_handle_destroy(smfx->smfx_scf);
+		free(smfx);
+		return (-1);
+	}
+
+	if ((smfx->smfx_scope = scf_scope_create(smfx->smfx_scf)) == NULL) {
+		make_errmsg_scf(errmsg, "scf_scope_create");
+		scf_handle_destroy(smfx->smfx_scf);
+		free(smfx);
+		return (-1);
+	}
+
+	if (scf_handle_get_scope(smfx->smfx_scf, SCF_SCOPE_LOCAL,
+	    smfx->smfx_scope) != 0) {
+		make_errmsg_scf(errmsg, "scf_handle_get_scope");
+		scf_scope_destroy(smfx->smfx_scope);
+		scf_handle_destroy(smfx->smfx_scf);
+		free(smfx);
+		return (-1);
+	}
+
+	*smfxp = smfx;
+	return (0);
+}
+
+void
+smfx_free(smfx_t *smfx)
+{
+	if (smfx == NULL) {
+		return;
+	}
+
+	scf_scope_destroy(smfx->smfx_scope);
+	scf_handle_destroy(smfx->smfx_scf);
+	free(smfx);
+}
+
+/*
+ * Create the "config" property group if it does not exist.  If it does exist,
+ * load it.
+ */
+int
+smfx_ensure_pg(smfx_t *smfx, scf_instance_t *i, scf_propertygroup_t **pgp,
+    const char *pgname, const char *group_type)
+{
+	if (pgp != NULL) {
+		*pgp = NULL;
+	}
+
+	scf_propertygroup_t *pg;
+	if ((pg = scf_pg_create(smfx->smfx_scf)) == NULL) {
+		record_scf_error(smfx, "scf_pg_create");
+		return (-1);
+	}
+
+	/*
+	 * Try to add the property group.
+	 */
+	if (scf_instance_add_pg(i, pgname, group_type, 0, pg) != 0) {
+		if (scf_error() != SCF_ERROR_EXISTS) {
+			record_scf_error(smfx, "scf_instance_add_pg");
+			goto bail;
+		}
+
+		if (scf_instance_get_pg(i, pgname, pg) != 0) {
+			record_scf_error(smfx, "scf_instance_get_pg");
+			goto bail;
+		}
+
+		/*
+		 * Check to make sure it has the correct type.
+		 */
+		size_t typesz = scf_limit(SCF_LIMIT_MAX_PG_TYPE_LENGTH) + 1;
+		char *type;
+		if ((type = malloc(typesz)) == NULL) {
+			record_errno(smfx, "malloc (pg type string)");
+			goto bail;
+		}
+
+		if (scf_pg_get_type(pg, type, typesz) < 0) {
+			record_scf_error(smfx, "scf_pg_get_type");
+			goto bail;
+		}
+
+		if (strcmp(type, group_type) != 0) {
+			record_custom_error(smfx, "group \"%s\" has type "
+			    "\"%s\", wanted \"%s\"", pgname, type, group_type);
+			free(type);
+			goto bail;
+		}
+
+		free(type);
+	}
+
+	if (pgp != NULL) {
+		*pgp = pg;
+	}
+	return (0);
+
+bail:
+	scf_pg_destroy(pg);
+	return (-1);
+}
+
+static int
+flush_status(smfx_t *smfx, scf_instance_t *i)
+{
+	char *fmri;
+	if (smfx_instance_fmri(smfx, i, &fmri) != 0) {
+		return (-1);
+	}
+
+	for (;;) {
+		char *st;
+		if ((st = smf_get_state(fmri)) != NULL) {
+			/*
+			 * If we were able to get the service state, everything
+			 * is fine.
+			 */
+			free(st);
+			free(fmri);
+			return (0);
+		}
+		free(st);
+
+		if (scf_error() != SCF_ERROR_NOT_FOUND) {
+			record_scf_error(smfx, "smf_get_state");
+			goto bail;
+		}
+
+		/*
+		 * Under some conditions a newly created service will not yet
+		 * have the property which reflects whether it is enabled or
+		 * disabled.  We can force the system to flush out a valid
+		 * value by disabling the service.
+		 */
+		if (smf_refresh_instance(fmri) != 0) {
+			record_scf_error(smfx, "smf_refresh_instance");
+			goto bail;
+		}
+		if (smf_disable_instance(fmri, 0) != 0) {
+			record_scf_error(smfx, "smf_disable_instance");
+			goto bail;
+		}
+
+		/*
+		 * Sleep for a short period and check again.
+		 */
+		sleep_ms(10);
+		continue;
+
+bail:
+		free(st);
+		free(fmri);
+		return (-1);
+	}
+}
+
+int
+smfx_ensure_instance(smfx_t *smfx, scf_service_t *service, const char *name,
+    scf_instance_t **out)
+{
+	scf_instance_t *i;
+	if (smfx_instance_create(smfx, &i) != 0) {
+		return (-1);
+	}
+
+	if (scf_service_add_instance(service, name, i) != 0) {
+		if (scf_error() != SCF_ERROR_EXISTS) {
+			record_scf_error(smfx, "scf_service_add_instance");
+			scf_instance_destroy(i);
+			return (-1);
+		}
+
+		/*
+		 * The instance exists already, so load it.
+		 */
+		if (scf_service_get_instance(service, name, i) != 0) {
+			record_scf_error(smfx, "scf_service_get_instance");
+			scf_instance_destroy(i);
+			return (-1);
+		}
+	}
+
+	/*
+	 * Poke the restarter to ensure this service is marked as disabled and
+	 * all appropriate properties get created.
+	 */
+	if (flush_status(smfx, i) != 0) {
+		return (-1);
+	}
+
+	if (out != NULL) {
+		*out = i;
+	} else {
+		scf_instance_destroy(i);
+	}
+	return (0);
+}
+
+
+int
+smfx_locate_service(smfx_t *smfx, const char *n, scf_service_t **service)
+{
+	*service = NULL;
+
+	scf_service_t *s;
+	if ((s = scf_service_create(smfx->smfx_scf)) == NULL) {
+		record_scf_error(smfx, "scf_service_create");
+		return (-1);
+	}
+
+	if (scf_handle_decode_fmri(smfx->smfx_scf, n, smfx->smfx_scope, s, NULL,
+	    NULL, NULL, SCF_DECODE_FMRI_EXACT) != 0) {
+		if (scf_error() == SCF_ERROR_NOT_FOUND) {
+			record_custom_error(smfx, "service \"%s\" not found",
+			    n);
+		} else if (scf_error() == SCF_ERROR_CONSTRAINT_VIOLATED) {
+			record_custom_error(smfx, "\"%s\" is not a valid SMF "
+			    "service FMRI", n);
+		} else {
+			record_scf_error(smfx, "scf_handle_decode_fmri");
+		}
+
+		scf_service_destroy(s);
+		return (-1);
+	}
+
+	*service = s;
+	return (0);
+}
+
+int
+smfx_instance_fmri(smfx_t *smfx, scf_instance_t *i, char **fmri)
+{
+	ssize_t sz;
+	if ((sz = scf_instance_to_fmri(i, NULL, 0)) < 0) {
+		record_scf_error(smfx, "scf_instance_to_fmri");
+		return (-1);
+	}
+
+	char *t;
+	if ((t = malloc(sz + 1)) == NULL) {
+		record_errno(smfx, "malloc (fmri string)");
+		return (-1);
+	}
+
+	if (scf_instance_to_fmri(i, t, sz + 1) < 0) {
+		record_scf_error(smfx, "scf_instance_to_fmri");
+	}
+
+	*fmri = t;
+	return (0);
+}
+
+int
+smfx_load_instance(smfx_t *smfx, scf_service_t *service, const char *name,
+    scf_instance_t **out)
+{
+	scf_instance_t *i;
+	if (smfx_instance_create(smfx, &i) != 0) {
+		return (-1);
+	}
+
+	if (scf_service_get_instance(service, name, i) != 0) {
+		record_scf_error(smfx, "scf_service_get_instance");
+		scf_instance_destroy(i);
+		return (-1);
+	}
+
+	*out = i;
+	return (0);
+}
+
+int
+smfx_load_snapshot(smfx_t *smfx, scf_instance_t *i, const char *name,
+    scf_snapshot_t **snapp)
+{
+	scf_snapshot_t *snap;
+	if ((snap = scf_snapshot_create(smfx->smfx_scf)) == NULL) {
+		record_scf_error(smfx, "scf_create_snapshot");
+		return (-1);
+	}
+
+	if (scf_instance_get_snapshot(i, name, snap) != 0) {
+		record_scf_error(smfx, "scf_instance_get_snapshot");
+		scf_snapshot_destroy(snap);
+		return (-1);
+	}
+
+	*snapp = snap;
+	return (0);
+}
+
+int
+smfx_instance_create(smfx_t *smfx, scf_instance_t **out)
+{
+	*out = NULL;
+
+	scf_instance_t *i;
+	if ((i = scf_instance_create(smfx->smfx_scf)) == NULL) {
+		record_scf_error(smfx, "scf_instance_create");
+		return (-1);
+	}
+
+	*out = i;
+	return (0);
+}
diff --git a/src/smfx.h b/src/smfx.h
new file mode 100644
index 0000000..8118b4b
--- /dev/null
+++ b/src/smfx.h
@@ -0,0 +1,44 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2018, Joyent, Inc.
+ */
+
+#ifndef	_SMFX_H
+#define	_SMFX_H
+
+#define	SMFX_ERROR_SIZE		2048
+
+typedef struct smfx smfx_t;
+
+extern int smfx_alloc(smfx_t **, char *);
+extern void smfx_free(smfx_t *);
+
+extern int smfx_locate_service(smfx_t *, const char *, scf_service_t **);
+
+extern const char *smfx_errmsg(smfx_t *);
+extern scf_error_t smfx_scf_error(smfx_t *);
+
+extern int smfx_ensure_pg(smfx_t *, scf_instance_t *, scf_propertygroup_t **,
+    const char *, const char *);
+
+
+extern int smfx_instance_create(smfx_t *, scf_instance_t **);
+extern int smfx_ensure_instance(smfx_t *, scf_service_t *, const char *,
+    scf_instance_t **);
+
+extern int smfx_load_instance(smfx_t *, scf_service_t *, const char *,
+    scf_instance_t **);
+
+extern int smfx_load_snapshot(smfx_t *, scf_instance_t *, const char *,
+    scf_snapshot_t **);
+
+extern int smfx_instance_fmri(smfx_t *, scf_instance_t *, char **);
+
+extern scf_handle_t *smfx_handle(smfx_t *smfx);
+
+#endif	/* !_SMFX_H */
diff --git a/src/utils.c b/src/utils.c
new file mode 100644
index 0000000..8deeab4
--- /dev/null
+++ b/src/utils.c
@@ -0,0 +1,103 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2018, Joyent, Inc.
+ */
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <stdarg.h>
+#include <stdbool.h>
+#include <err.h>
+#include <strings.h>
+#include <unistd.h>
+#include <errno.h>
+#include <time.h>
+#include <limits.h>
+#include <sys/avl.h>
+#include <sys/debug.h>
+#include <libnvpair.h>
+
+#include "utils.h"
+
+void
+sleep_ms(int ms)
+{
+	static clockid_t sleep_clock = CLOCK_HIGHRES;
+	struct timespec ts;
+
+	ts.tv_sec = ms / 1000;
+	ts.tv_nsec = MSEC2NSEC(ms % 1000);
+
+	for (;;) {
+		if (clock_nanosleep(sleep_clock, 0, &ts, &ts) == 0) {
+			break;
+		}
+
+		if (errno == EINTR) {
+			continue;
+		}
+
+		if (errno == EPERM && sleep_clock == CLOCK_HIGHRES) {
+			/*
+			 * In the past, the non-adjustable clock was not
+			 * universally available in zones and to non-root
+			 * users.  Try again with the wall clock.
+			 */
+			sleep_clock = CLOCK_REALTIME;
+			continue;
+		}
+
+		VERIFY3S(errno, !=, EINVAL);
+		err(1, "clock_nanosleep");
+	}
+}
+
+void *
+safe_zalloc(size_t sz)
+{
+	void *ret;
+
+	if ((ret = calloc(1, sz)) == NULL) {
+		err(1, "calloc(%u)", sz);
+	}
+
+	return (ret);
+}
+
+int
+parse_long(const char *input, long *output, int base)
+{
+	char *endp;
+	long ret;
+
+	errno = 0;
+	ret = strtol(input, &endp, base);
+
+	if (ret == 0 && errno == EINVAL) {
+		return (-1);
+	} else if ((ret == LONG_MAX || ret == LONG_MIN) && errno == ERANGE) {
+		return (-1);
+	}
+
+	/*
+	 * Any other error would appear to be a programmer error.
+	 */
+	VERIFY3S(errno, ==, 0);
+
+	if (*endp != '\0') {
+		/*
+		 * The string contained trailing detritus after the numeric
+		 * portion.
+		 */
+		errno = EINVAL;
+		return (-1);
+	}
+
+	*output = ret;
+	return (0);
+}
diff --git a/src/utils.h b/src/utils.h
new file mode 100644
index 0000000..4dfa695
--- /dev/null
+++ b/src/utils.h
@@ -0,0 +1,39 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2018, Joyent, Inc.
+ */
+
+#ifndef	_UTILS_H
+#define	_UTILS_H
+
+/*
+ * It would appear that some of these definitions in "sys/time.h" have not
+ * existed for as long as we would like.  For now, replicate them here if the
+ * system does not provide them.
+ */
+#ifndef	SEC
+#define	SEC				1
+#endif
+#ifndef	MILLISEC
+#define	MILLISEC			1000
+#endif
+#ifndef	NANOSEC
+#define	NANOSEC				1000000000LL
+#endif
+#ifndef	SEC2NSEC
+#define	SEC2NSEC(m)			((hrtime_t)(m) * (NANOSEC / SEC))
+#endif
+#ifndef	MSEC2NSEC
+#define	MSEC2NSEC(m)			((hrtime_t)(m) * (NANOSEC / MILLISEC))
+#endif
+
+extern void sleep_ms(int ms);
+extern void *safe_zalloc(size_t sz);
+extern int parse_long(const char *input, long *output, int base);
+
+#endif	/* !_UTILS_H */
diff --git a/tools/download_ctftools b/tools/download_ctftools
new file mode 100755
index 0000000..7b1f6c1
--- /dev/null
+++ b/tools/download_ctftools
@@ -0,0 +1,84 @@
+#!/bin/bash
+#
+# This Source Code Form is subject to the terms of the Mozilla Public
+# License, v. 2.0. If a copy of the MPL was not distributed with this
+# file, You can obtain one at http://mozilla.org/MPL/2.0/.
+#
+
+#
+# Copyright (c) 2018, Joyent, Inc.
+#
+
+#
+# This program will download a prebuilt copy of the CTF tools from Manta.
+# These tools have been built using a technique to ensure they can be run on a
+# sufficiently old platform.  More details are available at:
+#
+#	https://github.com/jclulow/ctftools
+#
+
+MANTA_URL='https://us-east.manta.joyent.com'
+BASE_PATH='/Joyent_Dev/public/ctftools'
+TARBALL='ctftools.20141030T081701Z.9543159.tar.gz'
+
+TOP=$(cd "$(dirname "$0")/.." && pwd)
+TMPDIR="$TOP/tmp"
+CTFDIR="$TOP/tmp/ctftools"
+
+if ! /usr/bin/mkdir -p "$TMPDIR"; then
+	printf 'ERROR: could not mkdir "%s"\n' "$TMPDIR" >&2
+	exit 1
+fi
+
+if [[ ! -f "$TMPDIR/$TARBALL" ]]; then
+	#
+	# Try to download the tarball from Manta.
+	#
+	start_time=$SECONDS
+	rm -f "$TMPDIR/$TARBALL.tmp"
+	while :; do
+		if (( $SECONDS > start_time + 120 )); then
+			printf 'ERROR: timed out trying to download tools\n' >&2
+			exit 1
+		fi
+
+		if ! curl -sSf -o "$TMPDIR/$TARBALL.tmp" \
+		    "$MANTA_URL/$BASE_PATH/$TARBALL"; then
+			printf 'WARNING: download failure (retrying)\n' >&2
+			sleep 5
+			continue
+		fi
+
+		if ! /usr/bin/gzip -t "$TMPDIR/$TARBALL.tmp"; then
+			printf 'WARNING: download gzip invalid (retrying)\n' >&2
+			sleep 5
+			continue
+		fi
+
+		if ! /usr/bin/mv "$TMPDIR/$TARBALL.tmp" "$TMPDIR/$TARBALL"; then
+			printf 'ERROR: could not move tarball into place\n' >&2
+			exit 1
+		fi
+
+		break
+	done
+fi
+
+#
+# Extract the tarball
+#
+if ! /usr/bin/mkdir -p "$CTFDIR"; then
+	printf 'ERROR: could not mkdir "%s"\n' "$CTFDIR" >&2
+	exit 1
+fi
+
+if ! cd "$CTFDIR"; then
+	exit 1
+fi
+
+if ! /usr/bin/tar xfz "$TMPDIR/$TARBALL"; then
+	printf 'ERROR: could not extract tarball\n' >&2
+	exit 1
+fi
+
+exit 0
diff --git a/tools/jsl.node.conf b/tools/jsl.node.conf
index 0b8e8ea..5207686 100644
--- a/tools/jsl.node.conf
+++ b/tools/jsl.node.conf
@@ -120,6 +120,7 @@
 +define require
 +define setInterval
 +define setTimeout
++define setImmediate
 +define Buffer
 +define JSON
 +define Math
