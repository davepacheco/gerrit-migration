From 4db27151775500006b6bd3d5703ababacf8be474 Mon Sep 17 00:00:00 2001
From: Jason King <jason.king@joyent.com>
Date: Mon, 22 Jan 2018 19:28:10 +0000
Subject: [PATCH] OS-6325 PKCS#11 softtoken should use explicit_bzero

---
 .../pkcs11/libpkcs11/common/metaAttrManager.c | 10 ++-
 .../libpkcs11/common/metaObjectManager.c      |  6 ++
 .../pkcs11/pkcs11_kernel/common/kernelKeys.c  | 12 +--
 .../pkcs11_kernel/common/kernelObjectUtil.c   |  4 +-
 .../pkcs11_kernel/common/kernelSoftCommon.c   |  9 ++-
 .../pkcs11/pkcs11_kernel/common/kernelUtil.c  |  3 +-
 .../pkcs11_softtoken/common/softAESCrypt.c    |  9 ++-
 .../pkcs11/pkcs11_softtoken/common/softASN1.c | 25 +++----
 .../common/softAttributeUtil.c                | 32 +++++---
 .../common/softBlowfishCrypt.c                | 11 ++-
 .../pkcs11_softtoken/common/softDESCrypt.c    |  9 ++-
 .../pkcs11_softtoken/common/softDecryptUtil.c | 29 ++++----
 .../pkcs11_softtoken/common/softDigestUtil.c  |  3 +-
 .../pkcs11_softtoken/common/softEncryptUtil.c | 42 ++++++-----
 .../pkcs11_softtoken/common/softKeysUtil.c    | 21 +++---
 .../pkcs11_softtoken/common/softKeystore.c    | 57 +++++++++++---
 .../common/softKeystoreUtil.c                 | 74 ++++++++++++++++++-
 .../pkcs11/pkcs11_softtoken/common/softMAC.c  |  9 ++-
 .../pkcs11/pkcs11_softtoken/common/softSSL.c  |  8 +-
 .../pkcs11_softtoken/common/softSignUtil.c    | 19 +++--
 .../pkcs11_softtoken/common/softSlotToken.c   |  6 +-
 21 files changed, 278 insertions(+), 120 deletions(-)

diff --git a/usr/src/lib/pkcs11/libpkcs11/common/metaAttrManager.c b/usr/src/lib/pkcs11/libpkcs11/common/metaAttrManager.c
index 76fae97a64..6f776af91f 100644
--- a/usr/src/lib/pkcs11/libpkcs11/common/metaAttrManager.c
+++ b/usr/src/lib/pkcs11/libpkcs11/common/metaAttrManager.c
@@ -22,6 +22,7 @@
  * Copyright 2007 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
  * Copyright 2012 Milan Jurik. All rights reserved.
+ * Copyright (c) 2018, Joyent, Inc.
  */
 
 #include <string.h>
@@ -525,7 +526,8 @@ dealloc_attributes(generic_attr_t *attributes, size_t num_attributes)
 		 * extra work to just do them all. [Most attributes are just
 		 * 1 or 4 bytes]
 		 */
-		bzero(attr->attribute.pValue, attr->attribute.ulValueLen);
+		explicit_bzero(attr->attribute.pValue,
+		    attr->attribute.ulValueLen);
 
 		if (attr->isMalloced)
 			free(attr->attribute.pValue);
@@ -563,13 +565,15 @@ attribute_set_value(CK_ATTRIBUTE *new_attr,
 		/* Existing storage is sufficient to store new value. */
 
 		/* bzero() out any data that won't be overwritten. */
-		bzero((char *)attr->attribute.pValue + new_attr->ulValueLen,
+		explicit_bzero((char *)attr->attribute.pValue +
+		    new_attr->ulValueLen,
 		    attr->attribute.ulValueLen - new_attr->ulValueLen);
 
 	} else if (new_attr->ulValueLen <= sizeof (attr->generic_data)) {
 		/* Use generic storage to avoid a malloc. */
 
-		bzero(attr->attribute.pValue, attr->attribute.ulValueLen);
+		explicit_bzero(attr->attribute.pValue,
+		    attr->attribute.ulValueLen);
 		if (attr->isMalloced) {
 			/*
 			 * If app sets a large value (triggering a malloc),
diff --git a/usr/src/lib/pkcs11/libpkcs11/common/metaObjectManager.c b/usr/src/lib/pkcs11/libpkcs11/common/metaObjectManager.c
index b50b912056..cbd618cd2b 100644
--- a/usr/src/lib/pkcs11/libpkcs11/common/metaObjectManager.c
+++ b/usr/src/lib/pkcs11/libpkcs11/common/metaObjectManager.c
@@ -20,6 +20,7 @@
  */
 /*
  * Copyright (c) 2004, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2018, Joyent, Inc.
  */
 
 
@@ -596,6 +597,8 @@ meta_object_dealloc(meta_session_t *session, meta_object_t *object,
 
 	if (object->clone_template) {
 		for (i = 0; i < object->clone_template_size; i++) {
+			explicit_bzero((object->clone_template)[i].pValue,
+			    (object->clone_template)[i].ulValueLen);
 			free(((object->clone_template)[i]).pValue);
 		}
 		free(object->clone_template);
@@ -859,6 +862,8 @@ finish:
 	if (attrs_with_val) {
 		for (i = 0; i < num_attrs; i++) {
 			if (attrs_with_val[i].pValue != NULL) {
+				explicit_bzero(attrs_with_val[i].pValue,
+				    attrs_with_val[i].ulValueLen);
 				free(attrs_with_val[i].pValue);
 			}
 		}
@@ -1491,6 +1496,7 @@ finish:
 	}
 
 	if (wrappedKey) {
+		explicit_bzero(wrappedKey, wrappedKeyLen);
 		free(wrappedKey);
 	}
 
diff --git a/usr/src/lib/pkcs11/pkcs11_kernel/common/kernelKeys.c b/usr/src/lib/pkcs11/pkcs11_kernel/common/kernelKeys.c
index 530b3fd8a4..33b4b12f24 100644
--- a/usr/src/lib/pkcs11/pkcs11_kernel/common/kernelKeys.c
+++ b/usr/src/lib/pkcs11/pkcs11_kernel/common/kernelKeys.c
@@ -343,20 +343,20 @@ key_gen_by_value(CK_MECHANISM_PTR pMechanism, CK_ATTRIBUTE_PTR pTemplate,
 	}
 	new_objp->is_lib_obj = B_TRUE;
 	new_objp->session_handle = (CK_SESSION_HANDLE)session_p;
-	(void) free(newTemplate);
-	bzero(key_buf, key_len);
-	(void) free(key_buf);
+	free(newTemplate);
+	explicit_bzero(key_buf, key_len);
+	free(key_buf);
 	return (CKR_OK);
 
 failed_exit:
 	free_attributes(obj_ngk.ngk_in_attributes, &obj_ngk.ngk_in_count);
 	free_attributes(obj_ngk.ngk_out_attributes, &obj_ngk.ngk_out_count);
 	if (key_buf != NULL) {
-		bzero(key_buf, key_len);
-		(void) free(key_buf);
+		explicit_bzero(key_buf, key_len);
+		free(key_buf);
 	}
 	if (newTemplate != NULL) {
-		(void) free(newTemplate);
+		free(newTemplate);
 	}
 	return (rv);
 }
diff --git a/usr/src/lib/pkcs11/pkcs11_kernel/common/kernelObjectUtil.c b/usr/src/lib/pkcs11/pkcs11_kernel/common/kernelObjectUtil.c
index a8c16f2e60..83a8827bec 100644
--- a/usr/src/lib/pkcs11/pkcs11_kernel/common/kernelObjectUtil.c
+++ b/usr/src/lib/pkcs11/pkcs11_kernel/common/kernelObjectUtil.c
@@ -21,6 +21,7 @@
 /*
  * Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
+ * Copyright (c) 2018, Joyent, Inc.
  */
 
 #include <stdio.h>
@@ -77,7 +78,8 @@ kernel_cleanup_object(kernel_object_t *objp)
 	 */
 	if (objp->class == CKO_SECRET_KEY) {
 		if (OBJ_SEC(objp) != NULL && OBJ_SEC_VALUE(objp) != NULL) {
-			bzero(OBJ_SEC_VALUE(objp), OBJ_SEC_VALUE_LEN(objp));
+			explicit_bzero(OBJ_SEC_VALUE(objp),
+			    OBJ_SEC_VALUE_LEN(objp));
 			free(OBJ_SEC_VALUE(objp));
 			OBJ_SEC_VALUE(objp) = NULL;
 			OBJ_SEC_VALUE_LEN(objp) = 0;
diff --git a/usr/src/lib/pkcs11/pkcs11_kernel/common/kernelSoftCommon.c b/usr/src/lib/pkcs11/pkcs11_kernel/common/kernelSoftCommon.c
index 84af97182a..dfdcb2eb84 100644
--- a/usr/src/lib/pkcs11/pkcs11_kernel/common/kernelSoftCommon.c
+++ b/usr/src/lib/pkcs11/pkcs11_kernel/common/kernelSoftCommon.c
@@ -22,10 +22,9 @@
 /*
  * Copyright 2007 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
+ * Copyright (c) 2018, Joyent, Inc.
  */
 
-#pragma ident	"%Z%%M%	%I%	%E% SMI"
-
 #include <pthread.h>
 #include <errno.h>
 #include <stdio.h>
@@ -236,14 +235,16 @@ free_soft_ctx(void *s, int opflag)
 	if (opflag & OP_SIGN) {
 		if (session_p->sign.context == NULL)
 			return;
-		bzero(session_p->sign.context, sizeof (soft_hmac_ctx_t));
+		explicit_bzero(session_p->sign.context,
+		    sizeof (soft_hmac_ctx_t));
 		free(session_p->sign.context);
 		session_p->sign.context = NULL;
 		session_p->sign.flags = 0;
 	} else if (opflag & OP_VERIFY) {
 		if (session_p->verify.context == NULL)
 			return;
-		bzero(session_p->verify.context, sizeof (soft_hmac_ctx_t));
+		explicit_bzero(session_p->verify.context,
+		    sizeof (soft_hmac_ctx_t));
 		free(session_p->verify.context);
 		session_p->verify.context = NULL;
 		session_p->verify.flags = 0;
diff --git a/usr/src/lib/pkcs11/pkcs11_kernel/common/kernelUtil.c b/usr/src/lib/pkcs11/pkcs11_kernel/common/kernelUtil.c
index e6f914e070..59456de706 100644
--- a/usr/src/lib/pkcs11/pkcs11_kernel/common/kernelUtil.c
+++ b/usr/src/lib/pkcs11/pkcs11_kernel/common/kernelUtil.c
@@ -20,6 +20,7 @@
  */
 /*
  * Copyright (c) 2003, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2018, Joyent, Inc.
  */
 
 #include <stdlib.h>
@@ -481,7 +482,7 @@ free_key_attributes(crypto_key_t *key)
 	    (key->ck_count > 0) && key->ck_attrs != NULL) {
 		for (i = 0; i < key->ck_count; i++) {
 			if (key->ck_attrs[i].oa_value != NULL) {
-				bzero(key->ck_attrs[i].oa_value,
+				explicit_bzero(key->ck_attrs[i].oa_value,
 				    key->ck_attrs[i].oa_value_len);
 				free(key->ck_attrs[i].oa_value);
 			}
diff --git a/usr/src/lib/pkcs11/pkcs11_softtoken/common/softAESCrypt.c b/usr/src/lib/pkcs11/pkcs11_softtoken/common/softAESCrypt.c
index bc8edcdc4c..facf433b7b 100644
--- a/usr/src/lib/pkcs11/pkcs11_softtoken/common/softAESCrypt.c
+++ b/usr/src/lib/pkcs11/pkcs11_softtoken/common/softAESCrypt.c
@@ -22,6 +22,7 @@
 /*
  * Copyright (c) 2003, 2010, Oracle and/or its affiliates. All rights reserved.
  * Copyright 2014 Nexenta Systems, Inc.  All rights reserved.
+ * Copyright (c) 2018, Joyent, Inc.
  */
 
 #include <pthread.h>
@@ -489,11 +490,11 @@ cleanup:
 	(void) pthread_mutex_lock(&session_p->session_mutex);
 	aes_ctx = (aes_ctx_t *)soft_aes_ctx->aes_cbc;
 	if (aes_ctx != NULL) {
-		bzero(aes_ctx->ac_keysched, aes_ctx->ac_keysched_len);
+		explicit_bzero(aes_ctx->ac_keysched, aes_ctx->ac_keysched_len);
 		free(soft_aes_ctx->aes_cbc);
 	}
 
-	bzero(soft_aes_ctx->key_sched, soft_aes_ctx->keysched_len);
+	explicit_bzero(soft_aes_ctx->key_sched, soft_aes_ctx->keysched_len);
 	free(soft_aes_ctx->key_sched);
 	free(session_p->encrypt.context);
 	session_p->encrypt.context = NULL;
@@ -852,11 +853,11 @@ cleanup:
 	(void) pthread_mutex_lock(&session_p->session_mutex);
 	aes_ctx = (aes_ctx_t *)soft_aes_ctx->aes_cbc;
 	if (aes_ctx != NULL) {
-		bzero(aes_ctx->ac_keysched, aes_ctx->ac_keysched_len);
+		explicit_bzero(aes_ctx->ac_keysched, aes_ctx->ac_keysched_len);
 		free(soft_aes_ctx->aes_cbc);
 	}
 
-	bzero(soft_aes_ctx->key_sched, soft_aes_ctx->keysched_len);
+	explicit_bzero(soft_aes_ctx->key_sched, soft_aes_ctx->keysched_len);
 	free(soft_aes_ctx->key_sched);
 	free(session_p->decrypt.context);
 	session_p->decrypt.context = NULL;
diff --git a/usr/src/lib/pkcs11/pkcs11_softtoken/common/softASN1.c b/usr/src/lib/pkcs11/pkcs11_softtoken/common/softASN1.c
index 4e5f5ddca4..ecfdff6809 100644
--- a/usr/src/lib/pkcs11/pkcs11_softtoken/common/softASN1.c
+++ b/usr/src/lib/pkcs11/pkcs11_softtoken/common/softASN1.c
@@ -22,6 +22,7 @@
 /*
  * Copyright (c) 2004, 2010, Oracle and/or its affiliates. All rights reserved.
  * Copyright 2012 Milan Jurik. All rights reserved.
+ * Copyright (c) 2018, Joyent. Inc.
  */
 
 #include <stdlib.h>
@@ -87,7 +88,7 @@ pad_bigint_attr(biginteger_t *src, biginteger_t *dst)
 	 * clear out potentially sensitive data before that happens.
 	 */
 	if (dst->big_value != NULL)
-		(void) memset(dst->big_value, 0x0, dst->big_value_len);
+		explicit_bzero(dst->big_value, dst->big_value_len);
 
 	padding = (src->big_value[0] < 0x80) ? 0 : 1;
 	dst->big_value_len = src->big_value_len + padding;
@@ -339,7 +340,7 @@ rsa_pri_to_asn1(soft_object_t *objp, uchar_t *buf, ulong_t *buf_len)
 cleanup_rsapri2asn:
 
 	if (tmp_pad.big_value != NULL) {
-		(void) memset(tmp_pad.big_value, 0x0, tmp_pad.big_value_len);
+		explicit_bzero(tmp_pad.big_value, tmp_pad.big_value_len);
 		free(tmp_pad.big_value);
 	}
 
@@ -528,7 +529,7 @@ dsa_pri_to_asn1(soft_object_t *objp, uchar_t *buf, ulong_t *buf_len)
 cleanup_dsapri2asn:
 
 	if (tmp_pad.big_value != NULL) {
-		(void) memset(tmp_pad.big_value, 0x0, tmp_pad.big_value_len);
+		explicit_bzero(tmp_pad.big_value, tmp_pad.big_value_len);
 		free(tmp_pad.big_value);
 	}
 
@@ -702,7 +703,7 @@ dh_pri_to_asn1(soft_object_t *objp, uchar_t *buf, ulong_t *buf_len)
 cleanup_dhpri2asn:
 
 	if (tmp_pad.big_value != NULL) {
-		(void) memset(tmp_pad.big_value, 0x0, tmp_pad.big_value_len);
+		explicit_bzero(tmp_pad.big_value, tmp_pad.big_value_len);
 		free(tmp_pad.big_value);
 	}
 
@@ -894,7 +895,7 @@ x942_dh_pri_to_asn1(soft_object_t *objp, uchar_t *buf, ulong_t *buf_len)
 cleanup_x942dhpri2asn:
 
 	if (tmp_pad.big_value != NULL) {
-		(void) memset(tmp_pad.big_value, 0x0, tmp_pad.big_value_len);
+		explicit_bzero(tmp_pad.big_value, tmp_pad.big_value_len);
 		free(tmp_pad.big_value);
 	}
 
@@ -1241,8 +1242,7 @@ error_asn2rsapri:
 cleanup_asn2rsapri:
 
 	if (tmp_nopad.big_value != NULL) {
-		(void) memset(tmp_nopad.big_value, 0x0,
-		    tmp_nopad.big_value_len);
+		explicit_bzero(tmp_nopad.big_value, tmp_nopad.big_value_len);
 		free(tmp_nopad.big_value);
 	}
 
@@ -1449,8 +1449,7 @@ error_asn2dsapri:
 cleanup_asn2dsapri:
 
 	if (tmp_nopad.big_value != NULL) {
-		(void) memset(tmp_nopad.big_value, 0x0,
-		    tmp_nopad.big_value_len);
+		explicit_bzero(tmp_nopad.big_value, tmp_nopad.big_value_len);
 		free(tmp_nopad.big_value);
 	}
 
@@ -1633,8 +1632,7 @@ error_asn2dhpri:
 cleanup_asn2dhpri:
 
 	if (tmp_nopad.big_value != NULL) {
-		(void) memset(tmp_nopad.big_value, 0x0,
-		    tmp_nopad.big_value_len);
+		explicit_bzero(tmp_nopad.big_value, tmp_nopad.big_value_len);
 		free(tmp_nopad.big_value);
 	}
 
@@ -1841,8 +1839,7 @@ error_asn2x942dhpri:
 cleanup_asn2x942dhpri:
 
 	if (tmp_nopad.big_value != NULL) {
-		(void) memset(tmp_nopad.big_value, 0x0,
-		    tmp_nopad.big_value_len);
+		explicit_bzero(tmp_nopad.big_value, tmp_nopad.big_value_len);
 		free(tmp_nopad.big_value);
 	}
 
@@ -1864,7 +1861,7 @@ cleanup_asn2x942dhpri:
 CK_RV
 soft_asn1_to_object(soft_object_t *objp, uchar_t *buf, ulong_t buf_len)
 {
-	CK_RV 		rv = CKR_OK;
+	CK_RV		rv = CKR_OK;
 	CK_OBJECT_CLASS class = objp->class;
 	CK_KEY_TYPE	keytype = objp->key_type;
 	private_key_obj_t *pvk;
diff --git a/usr/src/lib/pkcs11/pkcs11_softtoken/common/softAttributeUtil.c b/usr/src/lib/pkcs11/pkcs11_softtoken/common/softAttributeUtil.c
index d6e77c8016..d5cd170ffb 100644
--- a/usr/src/lib/pkcs11/pkcs11_softtoken/common/softAttributeUtil.c
+++ b/usr/src/lib/pkcs11/pkcs11_softtoken/common/softAttributeUtil.c
@@ -22,10 +22,12 @@
  * Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
  * Copyright 2012 Milan Jurik. All rights reserved.
+ * Copyright (c) 2018, Joyent, Inc.
  */
 
 #include <stdlib.h>
 #include <string.h>
+#include <strings.h>
 #include <security/cryptoki.h>
 #include <sys/crypto/common.h>
 #include <arcfour.h>
@@ -324,7 +326,7 @@ cleanup_cert_attr(cert_attr_t *attr)
 {
 	if (attr) {
 		if (attr->value) {
-			(void) memset(attr->value, 0, attr->length);
+			explicit_bzero(attr->value, attr->length);
 			free(attr->value);
 		}
 		attr->value = NULL;
@@ -345,8 +347,11 @@ copy_cert_attr(cert_attr_t *src_attr, cert_attr_t **dest_attr)
 
 	/* free memory if its already allocated */
 	if (*dest_attr != NULL) {
-		if ((*dest_attr)->value != (CK_BYTE *)NULL)
+		if ((*dest_attr)->value != (CK_BYTE *)NULL) {
+			explicit_bzero((*dest_attr)->value,
+			    (*dest_attr)->length);
 			free((*dest_attr)->value);
+		}
 	} else {
 		*dest_attr = malloc(sizeof (cert_attr_t));
 		if (*dest_attr == NULL)
@@ -421,7 +426,9 @@ soft_cleanup_extra_attr(soft_object_t *object_p)
 	extra_attr = object_p->extra_attrlistp;
 	while (extra_attr) {
 		tmp = extra_attr->next;
-		if (extra_attr->attr.pValue)
+		if (extra_attr->attr.pValue != NULL) {
+			explicit_bzero(extra_attr->attr.pValue,
+			    extra_attr->attr.ulValueLen);
 			/*
 			 * All extra attributes in the extra attribute
 			 * list have pValue points to the value of the
@@ -429,6 +436,7 @@ soft_cleanup_extra_attr(soft_object_t *object_p)
 			 * Free the storage for the value of the attribute.
 			 */
 			free(extra_attr->attr.pValue);
+		}
 
 		/* Free the storage for the attribute_info struct. */
 		free(extra_attr);
@@ -672,9 +680,12 @@ set_extra_attr_to_object(soft_object_t *object_p, CK_ATTRIBUTE_TYPE type,
 	    (template->ulValueLen > 0)) {
 		if (template->ulValueLen > extra_attr->attr.ulValueLen) {
 			/* The old buffer is too small to hold the new value. */
-			if (extra_attr->attr.pValue != NULL)
+			if (extra_attr->attr.pValue != NULL) {
+				explicit_bzero(extra_attr->attr.pValue,
+				    extra_attr->attr.ulValueLen);
 				/* Free storage for the old attribute value. */
 				free(extra_attr->attr.pValue);
+			}
 
 			/* Allocate storage for the new attribute value. */
 			extra_attr->attr.pValue = malloc(template->ulValueLen);
@@ -931,8 +942,7 @@ get_cert_attr_from_template(cert_attr_t **dest, CK_ATTRIBUTE_PTR src)
 		 */
 		if (*dest != NULL) {
 			if ((*dest)->value != NULL) {
-				(void) memset((*dest)->value, 0,
-				    (*dest)->length);
+				explicit_bzero((*dest)->value, (*dest)->length);
 				free((*dest)->value);
 			}
 		} else {
@@ -988,7 +998,8 @@ void
 string_attr_cleanup(CK_ATTRIBUTE_PTR template)
 {
 
-	if (template->pValue) {
+	if (template->pValue != NULL) {
+		explicit_bzero(template->pValue, template->ulValueLen);
 		free(template->pValue);
 		template->pValue = NULL;
 		template->ulValueLen = 0;
@@ -1007,7 +1018,7 @@ bigint_attr_cleanup(biginteger_t *big)
 		return;
 
 	if (big->big_value) {
-		(void) memset(big->big_value, 0, big->big_value_len);
+		explicit_bzero(big->big_value, big->big_value_len);
 		free(big->big_value);
 		big->big_value = NULL;
 		big->big_value_len = 0;
@@ -1151,14 +1162,14 @@ soft_cleanup_object_bigint_attrs(soft_object_t *object_p)
 			/* cleanup key data area */
 			if (OBJ_SEC_VALUE(object_p) != NULL &&
 			    OBJ_SEC_VALUE_LEN(object_p) > 0) {
-				(void) memset(OBJ_SEC_VALUE(object_p), 0,
+				explicit_bzero(OBJ_SEC_VALUE(object_p),
 				    OBJ_SEC_VALUE_LEN(object_p));
 				free(OBJ_SEC_VALUE(object_p));
 			}
 			/* cleanup key schedule data area */
 			if (OBJ_KEY_SCHED(object_p) != NULL &&
 			    OBJ_KEY_SCHED_LEN(object_p) > 0) {
-				(void) memset(OBJ_KEY_SCHED(object_p), 0,
+				explicit_bzero(OBJ_KEY_SCHED(object_p),
 				    OBJ_KEY_SCHED_LEN(object_p));
 				free(OBJ_KEY_SCHED(object_p));
 			}
@@ -6334,6 +6345,7 @@ soft_copy_secret_key_attr(secret_key_obj_t *old_secret_key_obj_p,
 	    old_secret_key_obj_p->keysched_len > 0) {
 		sk->key_sched = malloc(old_secret_key_obj_p->keysched_len);
 		if (sk->key_sched == NULL) {
+			explicit_bzero(sk->sk_value, sk->sk_value_len);
 			free(sk);
 			return (CKR_HOST_MEMORY);
 		}
diff --git a/usr/src/lib/pkcs11/pkcs11_softtoken/common/softBlowfishCrypt.c b/usr/src/lib/pkcs11/pkcs11_softtoken/common/softBlowfishCrypt.c
index 9abbce2592..8d94017bea 100644
--- a/usr/src/lib/pkcs11/pkcs11_softtoken/common/softBlowfishCrypt.c
+++ b/usr/src/lib/pkcs11/pkcs11_softtoken/common/softBlowfishCrypt.c
@@ -21,6 +21,7 @@
 /*
  * Copyright 2008 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
+ * Copyright (c) 2018, Joyent, Inc.
  */
 
 #include <pthread.h>
@@ -298,12 +299,13 @@ cleanup:
 	(void) pthread_mutex_lock(&session_p->session_mutex);
 	blowfish_ctx = (blowfish_ctx_t *)soft_blowfish_ctx->blowfish_cbc;
 	if (blowfish_ctx != NULL) {
-		bzero(blowfish_ctx->bc_keysched,
+		explicit_bzero(blowfish_ctx->bc_keysched,
 		    blowfish_ctx->bc_keysched_len);
 		free(soft_blowfish_ctx->blowfish_cbc);
 	}
 
-	bzero(soft_blowfish_ctx->key_sched, soft_blowfish_ctx->keysched_len);
+	explicit_bzero(soft_blowfish_ctx->key_sched,
+	    soft_blowfish_ctx->keysched_len);
 	free(soft_blowfish_ctx->key_sched);
 	free(session_p->encrypt.context);
 	session_p->encrypt.context = NULL;
@@ -466,12 +468,13 @@ cleanup:
 	(void) pthread_mutex_lock(&session_p->session_mutex);
 	blowfish_ctx = (blowfish_ctx_t *)soft_blowfish_ctx->blowfish_cbc;
 	if (blowfish_ctx != NULL) {
-		bzero(blowfish_ctx->bc_keysched,
+		explicit_bzero(blowfish_ctx->bc_keysched,
 		    blowfish_ctx->bc_keysched_len);
 		free(soft_blowfish_ctx->blowfish_cbc);
 	}
 
-	bzero(soft_blowfish_ctx->key_sched, soft_blowfish_ctx->keysched_len);
+	explicit_bzero(soft_blowfish_ctx->key_sched,
+	    soft_blowfish_ctx->keysched_len);
 	free(soft_blowfish_ctx->key_sched);
 	free(session_p->decrypt.context);
 	session_p->decrypt.context = NULL;
diff --git a/usr/src/lib/pkcs11/pkcs11_softtoken/common/softDESCrypt.c b/usr/src/lib/pkcs11/pkcs11_softtoken/common/softDESCrypt.c
index 8159e93624..d626da10c6 100644
--- a/usr/src/lib/pkcs11/pkcs11_softtoken/common/softDESCrypt.c
+++ b/usr/src/lib/pkcs11/pkcs11_softtoken/common/softDESCrypt.c
@@ -21,6 +21,7 @@
 
 /*
  * Copyright (c) 2003, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2018, Joyent, Inc.
  */
 
 #include <pthread.h>
@@ -449,11 +450,11 @@ cleanup:
 	(void) pthread_mutex_lock(&session_p->session_mutex);
 	des_ctx = (des_ctx_t *)soft_des_ctx->des_cbc;
 	if (des_ctx != NULL) {
-		bzero(des_ctx->dc_keysched, des_ctx->dc_keysched_len);
+		explicit_bzero(des_ctx->dc_keysched, des_ctx->dc_keysched_len);
 		free(soft_des_ctx->des_cbc);
 	}
 
-	bzero(soft_des_ctx->key_sched, soft_des_ctx->keysched_len);
+	explicit_bzero(soft_des_ctx->key_sched, soft_des_ctx->keysched_len);
 	free(soft_des_ctx->key_sched);
 	free(session_p->encrypt.context);
 	session_p->encrypt.context = NULL;
@@ -778,11 +779,11 @@ cleanup:
 	(void) pthread_mutex_lock(&session_p->session_mutex);
 	des_ctx = (des_ctx_t *)soft_des_ctx->des_cbc;
 	if (des_ctx != NULL) {
-		bzero(des_ctx->dc_keysched, des_ctx->dc_keysched_len);
+		explicit_bzero(des_ctx->dc_keysched, des_ctx->dc_keysched_len);
 		free(soft_des_ctx->des_cbc);
 	}
 
-	bzero(soft_des_ctx->key_sched, soft_des_ctx->keysched_len);
+	explicit_bzero(soft_des_ctx->key_sched, soft_des_ctx->keysched_len);
 	free(soft_des_ctx->key_sched);
 	free(session_p->decrypt.context);
 	session_p->decrypt.context = NULL;
diff --git a/usr/src/lib/pkcs11/pkcs11_softtoken/common/softDecryptUtil.c b/usr/src/lib/pkcs11/pkcs11_softtoken/common/softDecryptUtil.c
index 355c3b5bdd..fd3c5495dc 100644
--- a/usr/src/lib/pkcs11/pkcs11_softtoken/common/softDecryptUtil.c
+++ b/usr/src/lib/pkcs11/pkcs11_softtoken/common/softDecryptUtil.c
@@ -21,6 +21,7 @@
 
 /*
  * Copyright (c) 2003, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2018, Joyent, Inc.
  */
 
 #include <pthread.h>
@@ -151,7 +152,7 @@ cbc_common:
 		    soft_des_ctx->ivec, key_p->key_type);
 
 		if (soft_des_ctx->des_cbc == NULL) {
-			bzero(soft_des_ctx->key_sched,
+			explicit_bzero(soft_des_ctx->key_sched,
 			    soft_des_ctx->keysched_len);
 			free(soft_des_ctx->key_sched);
 			free(session_p->decrypt.context);
@@ -207,7 +208,7 @@ cbc_common:
 		    soft_aes_ctx->ivec);
 
 		if (soft_aes_ctx->aes_cbc == NULL) {
-			bzero(soft_aes_ctx->key_sched,
+			explicit_bzero(soft_aes_ctx->key_sched,
 			    soft_aes_ctx->keysched_len);
 			free(soft_aes_ctx->key_sched);
 			free(session_p->decrypt.context);
@@ -247,7 +248,7 @@ cbc_common:
 		    pMechanism->pParameter);
 
 		if (soft_aes_ctx->aes_cbc == NULL) {
-			bzero(soft_aes_ctx->key_sched,
+			explicit_bzero(soft_aes_ctx->key_sched,
 			    soft_aes_ctx->keysched_len);
 			free(soft_aes_ctx->key_sched);
 			free(session_p->decrypt.context);
@@ -292,7 +293,7 @@ cbc_common:
 		    soft_blowfish_ctx->ivec);
 
 		if (soft_blowfish_ctx->blowfish_cbc == NULL) {
-			bzero(soft_blowfish_ctx->key_sched,
+			explicit_bzero(soft_blowfish_ctx->key_sched,
 			    soft_blowfish_ctx->keysched_len);
 			free(soft_blowfish_ctx->key_sched);
 			free(session_p->decrypt.context = NULL);
@@ -554,7 +555,7 @@ soft_decrypt_final(soft_session_t *session_p, CK_BYTE_PTR pLastPart,
 			rv = CKR_ENCRYPTED_DATA_LEN_RANGE;
 			/* Cleanup memory space. */
 			free(soft_des_ctx->des_cbc);
-			bzero(soft_des_ctx->key_sched,
+			explicit_bzero(soft_des_ctx->key_sched,
 			    soft_des_ctx->keysched_len);
 			free(soft_des_ctx->key_sched);
 
@@ -608,7 +609,7 @@ soft_decrypt_final(soft_session_t *session_p, CK_BYTE_PTR pLastPart,
 
 			/* Cleanup memory space. */
 			free(soft_des_ctx->des_cbc);
-			bzero(soft_des_ctx->key_sched,
+			explicit_bzero(soft_des_ctx->key_sched,
 			    soft_des_ctx->keysched_len);
 			free(soft_des_ctx->key_sched);
 
@@ -641,7 +642,8 @@ soft_decrypt_final(soft_session_t *session_p, CK_BYTE_PTR pLastPart,
 
 		/* Cleanup memory space. */
 		free(soft_des_ctx->des_cbc);
-		bzero(soft_des_ctx->key_sched, soft_des_ctx->keysched_len);
+		explicit_bzero(soft_des_ctx->key_sched,
+		    soft_des_ctx->keysched_len);
 		free(soft_des_ctx->key_sched);
 
 		break;
@@ -663,7 +665,7 @@ soft_decrypt_final(soft_session_t *session_p, CK_BYTE_PTR pLastPart,
 			rv = CKR_ENCRYPTED_DATA_LEN_RANGE;
 			/* Cleanup memory space. */
 			free(soft_aes_ctx->aes_cbc);
-			bzero(soft_aes_ctx->key_sched,
+			explicit_bzero(soft_aes_ctx->key_sched,
 			    soft_aes_ctx->keysched_len);
 			free(soft_aes_ctx->key_sched);
 
@@ -717,7 +719,7 @@ soft_decrypt_final(soft_session_t *session_p, CK_BYTE_PTR pLastPart,
 
 			/* Cleanup memory space. */
 			free(soft_aes_ctx->aes_cbc);
-			bzero(soft_aes_ctx->key_sched,
+			explicit_bzero(soft_aes_ctx->key_sched,
 			    soft_aes_ctx->keysched_len);
 			free(soft_aes_ctx->key_sched);
 
@@ -747,7 +749,7 @@ soft_decrypt_final(soft_session_t *session_p, CK_BYTE_PTR pLastPart,
 
 		/* Cleanup memory space. */
 		free(soft_aes_ctx->aes_cbc);
-		bzero(soft_aes_ctx->key_sched, soft_aes_ctx->keysched_len);
+		explicit_bzero(soft_aes_ctx->key_sched, soft_aes_ctx->keysched_len);
 		free(soft_aes_ctx->key_sched);
 
 		break;
@@ -784,7 +786,8 @@ soft_decrypt_final(soft_session_t *session_p, CK_BYTE_PTR pLastPart,
 
 		/* Cleanup memory space. */
 		free(ctr_ctx);
-		bzero(soft_aes_ctx->key_sched, soft_aes_ctx->keysched_len);
+		explicit_bzero(soft_aes_ctx->key_sched,
+		    soft_aes_ctx->keysched_len);
 		free(soft_aes_ctx->key_sched);
 
 		break;
@@ -805,7 +808,7 @@ soft_decrypt_final(soft_session_t *session_p, CK_BYTE_PTR pLastPart,
 		}
 
 		free(soft_blowfish_ctx->blowfish_cbc);
-		bzero(soft_blowfish_ctx->key_sched,
+		explicit_bzero(soft_blowfish_ctx->key_sched,
 		    soft_blowfish_ctx->keysched_len);
 		free(soft_blowfish_ctx->key_sched);
 
@@ -815,7 +818,7 @@ soft_decrypt_final(soft_session_t *session_p, CK_BYTE_PTR pLastPart,
 	case CKM_RC4:
 	{
 		ARCFour_key *key = (ARCFour_key *)session_p->decrypt.context;
-		bzero(key, sizeof (*key));
+		explicit_bzero(key, sizeof (*key));
 		*pulLastPartLen = 0;
 		break;
 	}
diff --git a/usr/src/lib/pkcs11/pkcs11_softtoken/common/softDigestUtil.c b/usr/src/lib/pkcs11/pkcs11_softtoken/common/softDigestUtil.c
index f1f685ed40..d1d0dbd17b 100644
--- a/usr/src/lib/pkcs11/pkcs11_softtoken/common/softDigestUtil.c
+++ b/usr/src/lib/pkcs11/pkcs11_softtoken/common/softDigestUtil.c
@@ -21,6 +21,7 @@
 /*
  * Copyright 2008 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
+ * Copyright (c) 2018, Joyent, Inc.
  */
 
 #include <strings.h>
@@ -302,7 +303,7 @@ soft_digest_common(soft_session_t *session_p, CK_BYTE_PTR pData,
 
 	/* Paranoia on behalf of C_DigestKey callers: bzero the context */
 	if (session_p->digest.flags & CRYPTO_KEY_DIGESTED) {
-		bzero(session_p->digest.context, len);
+		explicit_bzero(session_p->digest.context, len);
 		session_p->digest.flags &= ~CRYPTO_KEY_DIGESTED;
 	}
 	*pulDigestLen = digestLen;
diff --git a/usr/src/lib/pkcs11/pkcs11_softtoken/common/softEncryptUtil.c b/usr/src/lib/pkcs11/pkcs11_softtoken/common/softEncryptUtil.c
index aebacaa868..9091ea9595 100644
--- a/usr/src/lib/pkcs11/pkcs11_softtoken/common/softEncryptUtil.c
+++ b/usr/src/lib/pkcs11/pkcs11_softtoken/common/softEncryptUtil.c
@@ -22,6 +22,7 @@
 /*
  * Copyright (c) 2003, 2010, Oracle and/or its affiliates. All rights reserved.
  * Copyright 2015 Nexenta Systems, Inc.  All rights reserved.
+ * Copyright (c) 2018, Joyent, Inc.
  */
 
 #include <pthread.h>
@@ -175,7 +176,7 @@ cbc_common:
 		    soft_des_ctx->ivec, key_p->key_type);
 
 		if (soft_des_ctx->des_cbc == NULL) {
-			bzero(soft_des_ctx->key_sched,
+			explicit_bzero(soft_des_ctx->key_sched,
 			    soft_des_ctx->keysched_len);
 			free(soft_des_ctx->key_sched);
 			free(session_p->encrypt.context);
@@ -239,7 +240,7 @@ cbc_common:
 			    soft_aes_ctx->ivec);
 		}
 		if (soft_aes_ctx->aes_cbc == NULL) {
-			bzero(soft_aes_ctx->key_sched,
+			explicit_bzero(soft_aes_ctx->key_sched,
 			    soft_aes_ctx->keysched_len);
 			free(soft_aes_ctx->key_sched);
 			free(session_p->encrypt.context);
@@ -278,7 +279,7 @@ cbc_common:
 		    pMechanism->pParameter);
 
 		if (soft_aes_ctx->aes_cbc == NULL) {
-			bzero(soft_aes_ctx->key_sched,
+			explicit_bzero(soft_aes_ctx->key_sched,
 			    soft_aes_ctx->keysched_len);
 			free(soft_aes_ctx->key_sched);
 			free(session_p->encrypt.context);
@@ -341,7 +342,7 @@ cbc_common:
 		    soft_blowfish_ctx->ivec);
 
 		if (soft_blowfish_ctx->blowfish_cbc == NULL) {
-			bzero(soft_blowfish_ctx->key_sched,
+			explicit_bzero(soft_blowfish_ctx->key_sched,
 			    soft_blowfish_ctx->keysched_len);
 			free(soft_blowfish_ctx->key_sched);
 			free(session_p->encrypt.context);
@@ -628,7 +629,7 @@ soft_encrypt_final(soft_session_t *session_p, CK_BYTE_PTR pLastEncryptedPart,
 
 			/* Cleanup memory space. */
 			free(soft_des_ctx->des_cbc);
-			bzero(soft_des_ctx->key_sched,
+			explicit_bzero(soft_des_ctx->key_sched,
 			    soft_des_ctx->keysched_len);
 			free(soft_des_ctx->key_sched);
 		}
@@ -659,7 +660,8 @@ soft_encrypt_final(soft_session_t *session_p, CK_BYTE_PTR pLastEncryptedPart,
 
 		/* Cleanup memory space. */
 		free(soft_des_ctx->des_cbc);
-		bzero(soft_des_ctx->key_sched, soft_des_ctx->keysched_len);
+		explicit_bzero(soft_des_ctx->key_sched,
+		    soft_des_ctx->keysched_len);
 		free(soft_des_ctx->key_sched);
 
 		break;
@@ -723,7 +725,7 @@ soft_encrypt_final(soft_session_t *session_p, CK_BYTE_PTR pLastEncryptedPart,
 
 			/* Cleanup memory space. */
 			free(soft_aes_ctx->aes_cbc);
-			bzero(soft_aes_ctx->key_sched,
+			explicit_bzero(soft_aes_ctx->key_sched,
 			    soft_aes_ctx->keysched_len);
 			free(soft_aes_ctx->key_sched);
 		}
@@ -763,7 +765,7 @@ soft_encrypt_final(soft_session_t *session_p, CK_BYTE_PTR pLastEncryptedPart,
 
 			/* Cleanup memory space. */
 			free(soft_aes_ctx->aes_cbc);
-			bzero(soft_aes_ctx->key_sched,
+			explicit_bzero(soft_aes_ctx->key_sched,
 			    soft_aes_ctx->keysched_len);
 			free(soft_aes_ctx->key_sched);
 		}
@@ -791,7 +793,8 @@ soft_encrypt_final(soft_session_t *session_p, CK_BYTE_PTR pLastEncryptedPart,
 
 		/* Cleanup memory space. */
 		free(soft_aes_ctx->aes_cbc);
-		bzero(soft_aes_ctx->key_sched, soft_aes_ctx->keysched_len);
+		explicit_bzero(soft_aes_ctx->key_sched,
+		    soft_aes_ctx->keysched_len);
 		free(soft_aes_ctx->key_sched);
 
 		break;
@@ -827,7 +830,8 @@ soft_encrypt_final(soft_session_t *session_p, CK_BYTE_PTR pLastEncryptedPart,
 
 		/* Cleanup memory space. */
 		free(ctr_ctx);
-		bzero(soft_aes_ctx->key_sched, soft_aes_ctx->keysched_len);
+		explicit_bzero(soft_aes_ctx->key_sched,
+		    soft_aes_ctx->keysched_len);
 		free(soft_aes_ctx->key_sched);
 
 		break;
@@ -852,7 +856,7 @@ soft_encrypt_final(soft_session_t *session_p, CK_BYTE_PTR pLastEncryptedPart,
 		}
 
 		free(soft_blowfish_ctx->blowfish_cbc);
-		bzero(soft_blowfish_ctx->key_sched,
+		explicit_bzero(soft_blowfish_ctx->key_sched,
 		    soft_blowfish_ctx->keysched_len);
 		free(soft_blowfish_ctx->key_sched);
 		break;
@@ -865,7 +869,7 @@ soft_encrypt_final(soft_session_t *session_p, CK_BYTE_PTR pLastEncryptedPart,
 		*pulLastEncryptedPartLen = 0;
 		if (pLastEncryptedPart == NULL)
 			goto clean1;
-		bzero(key, sizeof (*key));
+		explicit_bzero(key, sizeof (*key));
 		break;
 	}
 	default:
@@ -921,11 +925,11 @@ soft_crypt_cleanup(soft_session_t *session_p, boolean_t encrypt,
 		if (soft_des_ctx != NULL) {
 			des_ctx = (des_ctx_t *)soft_des_ctx->des_cbc;
 			if (des_ctx != NULL) {
-				bzero(des_ctx->dc_keysched,
+				explicit_bzero(des_ctx->dc_keysched,
 				    des_ctx->dc_keysched_len);
 				free(soft_des_ctx->des_cbc);
 			}
-			bzero(soft_des_ctx->key_sched,
+			explicit_bzero(soft_des_ctx->key_sched,
 			    soft_des_ctx->keysched_len);
 			free(soft_des_ctx->key_sched);
 		}
@@ -944,11 +948,11 @@ soft_crypt_cleanup(soft_session_t *session_p, boolean_t encrypt,
 		if (soft_aes_ctx != NULL) {
 			aes_ctx = (aes_ctx_t *)soft_aes_ctx->aes_cbc;
 			if (aes_ctx != NULL) {
-				bzero(aes_ctx->ac_keysched,
+				explicit_bzero(aes_ctx->ac_keysched,
 				    aes_ctx->ac_keysched_len);
 				free(soft_aes_ctx->aes_cbc);
 			}
-			bzero(soft_aes_ctx->key_sched,
+			explicit_bzero(soft_aes_ctx->key_sched,
 			    soft_aes_ctx->keysched_len);
 			free(soft_aes_ctx->key_sched);
 		}
@@ -965,12 +969,12 @@ soft_crypt_cleanup(soft_session_t *session_p, boolean_t encrypt,
 			blowfish_ctx =
 			    (blowfish_ctx_t *)soft_blowfish_ctx->blowfish_cbc;
 			if (blowfish_ctx != NULL) {
-				bzero(blowfish_ctx->bc_keysched,
+				explicit_bzero(blowfish_ctx->bc_keysched,
 				    blowfish_ctx->bc_keysched_len);
 				free(soft_blowfish_ctx->blowfish_cbc);
 			}
 
-			bzero(soft_blowfish_ctx->key_sched,
+			explicit_bzero(soft_blowfish_ctx->key_sched,
 			    soft_blowfish_ctx->keysched_len);
 			free(soft_blowfish_ctx->key_sched);
 		}
@@ -982,7 +986,7 @@ soft_crypt_cleanup(soft_session_t *session_p, boolean_t encrypt,
 		ARCFour_key *key = (ARCFour_key *)active_op->context;
 
 		if (key != NULL)
-			bzero(key, sizeof (*key));
+			explicit_bzero(key, sizeof (*key));
 		break;
 	}
 
diff --git a/usr/src/lib/pkcs11/pkcs11_softtoken/common/softKeysUtil.c b/usr/src/lib/pkcs11/pkcs11_softtoken/common/softKeysUtil.c
index a48ade7224..15e1493ae3 100644
--- a/usr/src/lib/pkcs11/pkcs11_softtoken/common/softKeysUtil.c
+++ b/usr/src/lib/pkcs11/pkcs11_softtoken/common/softKeysUtil.c
@@ -21,6 +21,7 @@
 /*
  * Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
+ * Copyright (c) 2018, Joyent, Inc.
  */
 
 #include <pthread.h>
@@ -823,23 +824,23 @@ digest_done:
 
 cleanup:
 	if (A) {
-		bzero(A, Alen);
+		explicit_bzero(A, Alen);
 		free(A);
 	}
 	if (Ai) {
-		bzero(Ai, AiLen);
+		explicit_bzero(Ai, AiLen);
 		free(Ai);
 	}
 	if (B) {
-		bzero(B, Blen);
+		explicit_bzero(B, Blen);
 		free(B);
 	}
 	if (D) {
-		bzero(D, Dlen);
+		explicit_bzero(D, Dlen);
 		free(D);
 	}
 	if (I) {
-		bzero(I, Ilen);
+		explicit_bzero(I, Ilen);
 		free(I);
 	}
 	return (rv);
@@ -1400,6 +1401,8 @@ soft_generate_pkcs5_pbkdf2_key(soft_session_t *session_p,
 		keydata += hLen;
 	}
 	(void) soft_delete_object(session_p, hmac_key, B_FALSE, B_FALSE);
+	if (params->ulSaltSourceDataLen > 0)
+		explicit_bzero(salt, params->ulSaltSourceDataLen);
 	free(salt);
 
 	return (rv);
@@ -1535,13 +1538,13 @@ soft_wrapkey(soft_session_t *session_p, CK_MECHANISM_PTR pMechanism,
 cleanup_wrap:
 	if (padded_data != NULL && padded_len != plain_len) {
 		/* Clear buffer before returning to memory pool. */
-		(void) memset(padded_data, 0x0, padded_len);
+		explicit_bzero(padded_data, padded_len);
 		free(padded_data);
 	}
 
 	if ((hkey_p->class != CKO_SECRET_KEY) && (plain_data != NULL)) {
 		/* Clear buffer before returning to memory pool. */
-		(void) memset(plain_data, 0x0, plain_len);
+		explicit_bzero(plain_data, plain_len);
 		free(plain_data);
 	}
 
@@ -1822,7 +1825,7 @@ soft_unwrapkey(soft_session_t *session_p, CK_MECHANISM_PTR pMechanism,
 
 	if (new_objp->class != CKO_SECRET_KEY) {
 		/* Clear buffer before returning to memory pool. */
-		(void) memset(plain_data, 0x0, plain_len);
+		explicit_bzero(plain_data, plain_len);
 		free(plain_data);
 	}
 
@@ -1834,7 +1837,7 @@ cleanup_unwrap:
 	/* The decrypted private key buffer must be freed explicitly. */
 	if ((new_objp->class != CKO_SECRET_KEY) && (plain_data != NULL)) {
 		/* Clear buffer before returning to memory pool. */
-		(void) memset(plain_data, 0x0, plain_len);
+		explicit_bzero(plain_data, plain_len);
 		free(plain_data);
 	}
 
diff --git a/usr/src/lib/pkcs11/pkcs11_softtoken/common/softKeystore.c b/usr/src/lib/pkcs11/pkcs11_softtoken/common/softKeystore.c
index cab06ce41d..e50624da0a 100644
--- a/usr/src/lib/pkcs11/pkcs11_softtoken/common/softKeystore.c
+++ b/usr/src/lib/pkcs11/pkcs11_softtoken/common/softKeystore.c
@@ -98,8 +98,12 @@ soft_gen_hashed_pin(CK_UTF8CHAR_PTR pPin, char **result, char **salt)
 	}
 
 	if ((*result = crypt((char *)pPin, *salt)) == NULL) {
-		if (new_salt)
+		if (new_salt) {
+			size_t saltlen = strlen(*salt) + 1;
+
+			explicit_bzero(*salt, saltlen);
 			free(*salt);
+		}
 		return (-1);
 	}
 
@@ -119,6 +123,7 @@ soft_verify_pin(CK_UTF8CHAR_PTR pPin, CK_ULONG ulPinLen)
 	uchar_t	*tmp_pin = NULL;
 	boolean_t pin_initialized = B_FALSE;
 	CK_RV	rv = CKR_OK;
+	size_t	len = 0;
 
 	/*
 	 * Check to see if keystore is initialized.
@@ -189,13 +194,21 @@ soft_verify_pin(CK_UTF8CHAR_PTR pPin, CK_ULONG ulPinLen)
 	}
 
 cleanup:
-	if (salt)
+	if (salt) {
+		len = strlen(salt) + 1;
+		explicit_bzero(salt, len);
 		free(salt);
-	if (tmp_pin)
+	}
+	if (tmp_pin) {
+		len = strlen((char *)tmp_pin) + 1;
+		explicit_bzero(tmp_pin, len);
 		free(tmp_pin);
-	if (ks_cryptpin)
+	}
+	if (ks_cryptpin) {
+		len = strlen(ks_cryptpin) + 1;
+		explicit_bzero(ks_cryptpin, len);
 		free(ks_cryptpin);
-
+	}
 	return (rv);
 }
 
@@ -213,6 +226,7 @@ soft_setpin(CK_UTF8CHAR_PTR pOldPin, CK_ULONG ulOldPinLen,
 	boolean_t pin_initialized = B_FALSE;
 	uchar_t	*tmp_old_pin = NULL, *tmp_new_pin = NULL;
 	CK_RV	rv = CKR_OK;
+	size_t	len = 0;
 
 	/*
 	 * Check to see if keystore is initialized.
@@ -290,14 +304,26 @@ soft_setpin(CK_UTF8CHAR_PTR pOldPin, CK_ULONG ulOldPinLen,
 	}
 
 cleanup:
-	if (salt)
+	if (salt) {
+		len = strlen(salt) + 1;
+		explicit_bzero(salt, len);
 		free(salt);
-	if (ks_cryptpin)
+	}
+	if (ks_cryptpin) {
+		len = strlen(ks_cryptpin) + 1;
+		explicit_bzero(ks_cryptpin, len);
 		free(ks_cryptpin);
-	if (tmp_old_pin)
+	}
+	if (tmp_old_pin) {
+		len = strlen((char *)tmp_old_pin) + 1;
+		explicit_bzero(tmp_old_pin, len);
 		free(tmp_old_pin);
-	if (tmp_new_pin)
+	}
+	if (tmp_new_pin) {
+		len = strlen((char *)tmp_new_pin) + 1;
+		explicit_bzero(tmp_new_pin, len);
 		free(tmp_new_pin);
+	}
 
 	return (rv);
 }
@@ -476,6 +502,7 @@ soft_keystore_unpack_obj(soft_object_t *obj, ks_obj_t *ks_obj)
 
 		rv = soft_add_extra_attr(&template, obj);
 		if (template.pValue) {
+			explicit_bzero(template.pValue, template.ulValueLen);
 			free(template.pValue);
 		}
 
@@ -543,6 +570,7 @@ soft_unpack_obj_attribute(uchar_t *buf, biginteger_t *key_dest,
 		rv = get_bigint_attr_from_template(key_dest, &template);
 	}
 
+	explicit_bzero(template.pValue, template.ulValueLen);
 	free(template.pValue);
 	if (rv != CKR_OK) {
 		return (rv);
@@ -1861,6 +1889,7 @@ soft_put_object_to_keystore(soft_object_t *objp)
 		if ((soft_keystore_put_new_obj(buf, len, B_TRUE,
 		    B_FALSE, &objp->ks_handle)) == -1) {
 			(void) pthread_mutex_unlock(&soft_slot.slot_mutex);
+			explicit_bzero(buf, len);
 			free(buf);
 			return (CKR_FUNCTION_FAILED);
 		}
@@ -1868,11 +1897,13 @@ soft_put_object_to_keystore(soft_object_t *objp)
 		if ((soft_keystore_put_new_obj(buf, len, B_FALSE,
 		    B_FALSE, &objp->ks_handle)) == -1) {
 			(void) pthread_mutex_unlock(&soft_slot.slot_mutex);
+			explicit_bzero(buf, len);
 			free(buf);
 			return (CKR_FUNCTION_FAILED);
 		}
 	}
 	(void) pthread_mutex_unlock(&soft_slot.slot_mutex);
+	explicit_bzero(buf, len);
 	free(buf);
 	return (CKR_OK);
 
@@ -1900,6 +1931,7 @@ soft_modify_object_to_keystore(soft_object_t *objp)
 		return (CKR_FUNCTION_FAILED);
 	}
 
+	explicit_bzero(buf, len);
 	free(buf);
 	return (CKR_OK);
 
@@ -1942,8 +1974,10 @@ soft_get_token_objects_from_keystore(ks_search_type_t type)
 
 		/* Free the ks_obj list */
 		ks_obj_next = ks_obj->next;
-		if (ks_obj->buf)
+		if (ks_obj->buf) {
+			explicit_bzero(ks_obj->buf, ks_obj->size);
 			free(ks_obj->buf);
+		}
 		free(ks_obj);
 		ks_obj = ks_obj_next;
 	}
@@ -1953,6 +1987,7 @@ soft_get_token_objects_from_keystore(ks_search_type_t type)
 cleanup:
 	while (ks_obj) {
 		ks_obj_next = ks_obj->next;
+		explicit_bzero(ks_obj->buf, ks_obj->size);
 		free(ks_obj->buf);
 		free(ks_obj);
 		ks_obj = ks_obj_next;
@@ -2304,7 +2339,7 @@ soft_keystore_crypt(soft_object_t *key_p, uchar_t *ivec, boolean_t encrypt,
 		    soft_aes_ctx->ivec);
 
 		if (soft_aes_ctx->aes_cbc == NULL) {
-			bzero(soft_aes_ctx->key_sched,
+			explicit_bzero(soft_aes_ctx->key_sched,
 			    soft_aes_ctx->keysched_len);
 			free(soft_aes_ctx->key_sched);
 			if (encrypt) {
diff --git a/usr/src/lib/pkcs11/pkcs11_softtoken/common/softKeystoreUtil.c b/usr/src/lib/pkcs11/pkcs11_softtoken/common/softKeystoreUtil.c
index 0ebfa871e9..d179279411 100644
--- a/usr/src/lib/pkcs11/pkcs11_softtoken/common/softKeystoreUtil.c
+++ b/usr/src/lib/pkcs11/pkcs11_softtoken/common/softKeystoreUtil.c
@@ -470,8 +470,10 @@ create_keystore()
 	(void) lock_file(fd, B_FALSE, B_FALSE);
 
 	(void) close(fd);
-	if (hashed_pin_salt)
+	if (hashed_pin_salt) {
+		explicit_bzero(hashed_pin_salt, hashed_pin_salt_len);
 		free(hashed_pin_salt);
+	}
 	return (0);
 
 cleanup:
@@ -892,6 +894,7 @@ get_hashed_pin(int fd, char **hashed_pin)
 
 	if ((readn_nointr(fd, *hashed_pin, hashed_pin_size))
 	    != (ssize_t)hashed_pin_size) {
+		explicit_bzero(*hashed_pin, hashed_pin_size + 1);
 		free(*hashed_pin);
 		*hashed_pin = NULL;
 		return (CKR_FUNCTION_FAILED);
@@ -1320,58 +1323,70 @@ reencrypt_obj(soft_object_t *new_enc_key, soft_object_t *new_hmac_key,
 	decrypted_len = 0;
 	if (soft_keystore_crypt(enc_key, old_iv, B_FALSE, buf, nread,
 	    NULL, &decrypted_len) != CKR_OK) {
+		explicit_bzero(buf, nread);
 		free(buf);
 		goto cleanup;
 	}
 
 	decrypted_buf = malloc(decrypted_len);
 	if (decrypted_buf == NULL) {
+		explicit_bzero(buf, nread);
 		free(buf);
 		goto cleanup;
 	}
 
 	if (soft_keystore_crypt(enc_key, old_iv, B_FALSE, buf, nread,
 	    decrypted_buf, &decrypted_len) != CKR_OK) {
+		explicit_bzero(buf, nread);
+		explicit_bzero(decrypted_buf, decrypted_len);
 		free(buf);
 		free(decrypted_buf);
 		goto cleanup;
 	}
 
+	explicit_bzero(buf, nread);
 	free(buf);
 
 	/* re-encrypt with new key */
 	encrypted_len = 0;
 	if (soft_keystore_crypt(new_enc_key, iv, B_TRUE, decrypted_buf,
 	    decrypted_len, NULL, &encrypted_len) != CKR_OK) {
+		explicit_bzero(decrypted_buf, decrypted_len);
 		free(decrypted_buf);
 		goto cleanup;
 	}
 
 	buf = malloc(encrypted_len);
 	if (buf == NULL) {
+		explicit_bzero(decrypted_buf, decrypted_len);
 		free(decrypted_buf);
 		goto cleanup;
 	}
 
 	if (soft_keystore_crypt(new_enc_key, iv, B_TRUE, decrypted_buf,
 	    decrypted_len, buf, &encrypted_len) != CKR_OK) {
+		explicit_bzero(buf, encrypted_len);
+		explicit_bzero(decrypted_buf, decrypted_len);
 		free(buf);
 		free(decrypted_buf);
 		goto cleanup;
 	}
 
+	explicit_bzero(decrypted_buf, decrypted_len);
 	free(decrypted_buf);
 
 	/* calculate hmac on re-encrypted data using new hmac key */
 	hmac_len = OBJ_HMAC_SIZE;
 	if (soft_keystore_hmac(new_hmac_key, B_TRUE, buf,
 	    encrypted_len, hmac, &hmac_len) != CKR_OK) {
+		explicit_bzero(buf, encrypted_len);
 		free(buf);
 		goto cleanup;
 	}
 
 	/* just for sanity check */
 	if (hmac_len != OBJ_HMAC_SIZE) {
+		explicit_bzero(buf, encrypted_len);
 		free(buf);
 		goto cleanup;
 	}
@@ -1379,6 +1394,7 @@ reencrypt_obj(soft_object_t *new_enc_key, soft_object_t *new_hmac_key,
 	/* write new hmac */
 	if (writen_nointr(new_fd, (char *)hmac, OBJ_HMAC_SIZE)
 	    != OBJ_HMAC_SIZE) {
+		explicit_bzero(buf, encrypted_len);
 		free(buf);
 		goto cleanup;
 	}
@@ -1386,9 +1402,11 @@ reencrypt_obj(soft_object_t *new_enc_key, soft_object_t *new_hmac_key,
 	/* write re-encrypted buffer to temp file */
 	if (writen_nointr(new_fd, (void *)buf, encrypted_len)
 	    != encrypted_len) {
+		explicit_bzero(buf, encrypted_len);
 		free(buf);
 		goto cleanup;
 	}
+	explicit_bzero(buf, encrypted_len);
 	free(buf);
 	ret_val = 0;
 
@@ -1547,10 +1565,12 @@ soft_keystore_setpin(uchar_t *oldpin, uchar_t *newpin, boolean_t lock_held)
 		}
 		if (writen_nointr(tmp_ks_fd, (void *)new_crypt_salt,
 		    KS_KEY_SALT_SIZE) != KS_KEY_SALT_SIZE) {
+			explicit_bzero(new_crypt_salt, KS_KEY_SALT_SIZE);
 			free(new_crypt_salt);
 			(void) soft_cleanup_object(new_crypt_key);
 			goto cleanup;
 		}
+		explicit_bzero(new_crypt_salt, KS_KEY_SALT_SIZE);
 		free(new_crypt_salt);
 
 		if (soft_gen_hmac_key(newpin, &new_hmac_key, &new_hmac_salt)
@@ -1560,9 +1580,11 @@ soft_keystore_setpin(uchar_t *oldpin, uchar_t *newpin, boolean_t lock_held)
 		}
 		if (writen_nointr(tmp_ks_fd, (void *)new_hmac_salt,
 		    KS_HMAC_SALT_SIZE) != KS_HMAC_SALT_SIZE) {
+			explicit_bzero(new_hmac_salt, KS_HMAC_SALT_SIZE);
 			free(new_hmac_salt);
 			goto cleanup3;
 		}
+		explicit_bzero(new_hmac_salt, KS_HMAC_SALT_SIZE);
 		free(new_hmac_salt);
 	} else {
 		if (soft_gen_crypt_key(newpin, &new_crypt_key,
@@ -1612,12 +1634,14 @@ soft_keystore_setpin(uchar_t *oldpin, uchar_t *newpin, boolean_t lock_held)
 
 	if ((readn_nointr(fd, hashed_pin_salt, hashed_pin_salt_length)) !=
 	    (ssize_t)hashed_pin_salt_length) {
+		explicit_bzero(hashed_pin_salt, hashed_pin_salt_length + 1);
 		free(hashed_pin_salt);
 		goto cleanup3;
 	}
 
 	if ((writen_nointr(tmp_ks_fd, hashed_pin_salt, hashed_pin_salt_length))
 	    != (ssize_t)hashed_pin_salt_length) {
+		explicit_bzero(hashed_pin_salt, hashed_pin_salt_length + 1);
 		free(hashed_pin_salt);
 		goto cleanup3;
 	}
@@ -1627,10 +1651,12 @@ soft_keystore_setpin(uchar_t *oldpin, uchar_t *newpin, boolean_t lock_held)
 	/* old hashed pin length and value can be ignored, generate new one */
 	if (soft_gen_hashed_pin(newpin, &new_hashed_pin,
 	    &hashed_pin_salt) < 0) {
+		explicit_bzero(hashed_pin_salt, hashed_pin_salt_length + 1);
 		free(hashed_pin_salt);
 		goto cleanup3;
 	}
 
+	explicit_bzero(hashed_pin_salt, hashed_pin_salt_length + 1);
 	free(hashed_pin_salt);
 
 	if (new_hashed_pin == NULL) {
@@ -1764,9 +1790,11 @@ cleanup:
 		}
 	}
 	if (crypt_salt != NULL) {
+		explicit_bzero(crypt_salt, KS_KEY_SALT_SIZE);
 		free(crypt_salt);
 	}
 	if (hmac_salt != NULL) {
+		explicit_bzero(hmac_salt, KS_HMAC_SALT_SIZE);
 		free(hmac_salt);
 	}
 	(void) close(fd);
@@ -1856,16 +1884,18 @@ cleanup:
 	(void) lock_file(fd, B_TRUE, B_FALSE);
 	(void) close(fd);
 	if (crypt_salt != NULL) {
+		explicit_bzero(crypt_salt, KS_KEY_SALT_SIZE);
 		free(crypt_salt);
 	}
 	if (hmac_salt != NULL) {
+		explicit_bzero(hmac_salt, KS_HMAC_SALT_SIZE);
 		free(hmac_salt);
 	}
 	return (ret_val);
 }
 
 /*
- * 	FUNCTION: soft_keystore_get_objs
+ *	FUNCTION: soft_keystore_get_objs
  *
  *	ARGUMENTS:
  *
@@ -1980,6 +2010,7 @@ cleanup:
 	tmp = *result_obj_list;
 	while (tmp) {
 		*result_obj_list = tmp->next;
+		explicit_bzero(tmp->buf, tmp->size);
 		free(tmp->buf);
 		free(tmp);
 		tmp = *result_obj_list;
@@ -2087,6 +2118,7 @@ soft_keystore_get_single_obj(ks_obj_handle_t *ks_handle,
 		hmac_size = OBJ_HMAC_SIZE;
 		if (soft_keystore_hmac(hmac_key, B_FALSE, buf,
 		    nread, obj_hmac, &hmac_size) != CKR_OK) {
+			explicit_bzero(buf, nread);
 			free(buf);
 			rv = CKR_FUNCTION_FAILED;
 			goto cleanup;
@@ -2095,6 +2127,7 @@ soft_keystore_get_single_obj(ks_obj_handle_t *ks_handle,
 		/* decrypt object */
 		if (soft_keystore_crypt(enc_key, iv, B_FALSE, buf, nread,
 		    NULL, &out_len) != CKR_OK) {
+			explicit_bzero(buf, nread);
 			free(buf);
 			rv = CKR_FUNCTION_FAILED;
 			goto cleanup;
@@ -2102,6 +2135,7 @@ soft_keystore_get_single_obj(ks_obj_handle_t *ks_handle,
 
 		decrypted_buf = malloc(sizeof (uchar_t) * out_len);
 		if (decrypted_buf == NULL) {
+			explicit_bzero(buf, nread);
 			free(buf);
 			rv = CKR_HOST_MEMORY;
 			goto cleanup;
@@ -2109,6 +2143,8 @@ soft_keystore_get_single_obj(ks_obj_handle_t *ks_handle,
 
 		if (soft_keystore_crypt(enc_key, iv, B_FALSE, buf, nread,
 		    decrypted_buf, &out_len) != CKR_OK) {
+			explicit_bzero(buf, nread);
+			explicit_bzero(decrypted_buf, out_len);
 			free(decrypted_buf);
 			free(buf);
 			rv = CKR_FUNCTION_FAILED;
@@ -2126,12 +2162,16 @@ soft_keystore_get_single_obj(ks_obj_handle_t *ks_handle,
 		 */
 		obj->buf = malloc(sizeof (uchar_t) * (out_len - MAXPATHLEN));
 		if (obj->buf == NULL) {
+			explicit_bzero(buf, nread);
+			explicit_bzero(decrypted_buf, out_len);
 			free(decrypted_buf);
 			free(buf);
 			rv = CKR_HOST_MEMORY;
 			goto cleanup;
 		}
 		(void) memcpy(obj->buf, decrypted_buf + MAXPATHLEN, obj->size);
+		explicit_bzero(buf, nread);
+		explicit_bzero(decrypted_buf, out_len);
 		free(decrypted_buf);
 		free(buf);
 		*return_obj = obj;
@@ -2155,7 +2195,7 @@ cleanup:
 
 
 /*
- * 	FUNCTION: soft_keystore_put_new_obj
+ *	FUNCTION: soft_keystore_put_new_obj
  *
  *	ARGUMENTS:
  *		buf: buffer containing un-encrypted data
@@ -2336,12 +2376,14 @@ soft_keystore_put_new_obj(uchar_t *buf, size_t len, boolean_t public,
 		if (soft_keystore_crypt(enc_key, iv,
 		    B_TRUE, prepared_buf, prepared_len,
 		    NULL, &out_len) != CKR_OK) {
+			explicit_bzero(prepared_buf, prepared_len);
 			free(prepared_buf);
 			goto cleanup2;
 		}
 
 		encrypted_buf = malloc(out_len * sizeof (char));
 		if (encrypted_buf == NULL) {
+			explicit_bzero(prepared_buf, prepared_len);
 			free(prepared_buf);
 			goto cleanup2;
 		}
@@ -2349,21 +2391,26 @@ soft_keystore_put_new_obj(uchar_t *buf, size_t len, boolean_t public,
 		if (soft_keystore_crypt(enc_key, iv,
 		    B_TRUE, prepared_buf, prepared_len,
 		    encrypted_buf, &out_len) != CKR_OK) {
+			explicit_bzero(encrypted_buf, out_len);
+			explicit_bzero(prepared_buf, prepared_len);
 			free(encrypted_buf);
 			free(prepared_buf);
 			goto cleanup2;
 		}
+		explicit_bzero(prepared_buf, prepared_len);
 		free(prepared_buf);
 
 		/* calculate HMAC of encrypted object */
 		hmac_size = OBJ_HMAC_SIZE;
 		if (soft_keystore_hmac(hmac_key, B_TRUE, encrypted_buf,
 		    out_len, obj_hmac, &hmac_size) != CKR_OK) {
+			explicit_bzero(encrypted_buf, out_len);
 			free(encrypted_buf);
 			goto cleanup2;
 		}
 
 		if (hmac_size != OBJ_HMAC_SIZE) {
+			explicit_bzero(encrypted_buf, out_len);
 			free(encrypted_buf);
 			goto cleanup2;
 		}
@@ -2371,6 +2418,7 @@ soft_keystore_put_new_obj(uchar_t *buf, size_t len, boolean_t public,
 		/* write hmac */
 		if (writen_nointr(obj_fd, (void *)obj_hmac,
 		    sizeof (obj_hmac)) != sizeof (obj_hmac)) {
+			explicit_bzero(encrypted_buf, out_len);
 			free(encrypted_buf);
 			goto cleanup2;
 		}
@@ -2378,10 +2426,12 @@ soft_keystore_put_new_obj(uchar_t *buf, size_t len, boolean_t public,
 		/* write encrypted object */
 		if (writen_nointr(obj_fd, (void *)encrypted_buf, out_len)
 		    != out_len) {
+			explicit_bzero(encrypted_buf, out_len);
 			free(encrypted_buf);
 			goto cleanup2;
 		}
 
+		explicit_bzero(encrypted_buf, out_len);
 		free(encrypted_buf);
 	}
 
@@ -2421,6 +2471,8 @@ soft_keystore_put_new_obj(uchar_t *buf, size_t len, boolean_t public,
 		}
 	}
 	(void) close(fd);
+	explicit_bzero(obj_hmac, sizeof (obj_hmac));
+	explicit_bzero(iv, sizeof (iv));
 	return (0);
 
 cleanup2:
@@ -2438,6 +2490,8 @@ cleanup:
 	}
 
 	(void) close(fd);
+	explicit_bzero(obj_hmac, sizeof (obj_hmac));
+	explicit_bzero(iv, sizeof (iv));
 	return (-1);
 }
 
@@ -2591,43 +2645,52 @@ soft_keystore_modify_obj(ks_obj_handle_t *ks_handle, uchar_t *buf,
 
 		encrypted_buf = malloc(out_len * sizeof (char));
 		if (encrypted_buf == NULL) {
+			explicit_bzero(prepared_buf, prepared_len);
 			free(prepared_buf);
 			goto cleanup2;
 		}
 
 		if (soft_keystore_crypt(enc_key, iv, B_TRUE, prepared_buf,
 		    prepared_len, encrypted_buf, &out_len) != CKR_OK) {
+			explicit_bzero(prepared_buf, prepared_len);
+			explicit_bzero(encrypted_buf, out_len);
 			free(encrypted_buf);
 			free(prepared_buf);
 			goto cleanup2;
 		}
 
+		explicit_bzero(prepared_buf, prepared_len);
 		free(prepared_buf);
 
 		/* calculate hmac on encrypted buf */
 		hmac_size = OBJ_HMAC_SIZE;
 		if (soft_keystore_hmac(hmac_key, B_TRUE, encrypted_buf,
 		    out_len, obj_hmac, &hmac_size) != CKR_OK) {
+			explicit_bzero(encrypted_buf, out_len);
 			free(encrypted_buf);
 			goto cleanup2;
 		}
 
 		if (hmac_size != OBJ_HMAC_SIZE) {
+			explicit_bzero(encrypted_buf, out_len);
 			free(encrypted_buf);
 			goto cleanup2;
 		}
 
 		if (writen_nointr(tmp_fd, (char *)obj_hmac, OBJ_HMAC_SIZE)
 		    != OBJ_HMAC_SIZE) {
+			explicit_bzero(encrypted_buf, out_len);
 			free(encrypted_buf);
 			goto cleanup2;
 		}
 
 		if (writen_nointr(tmp_fd, (void *)encrypted_buf, out_len)
 		    != out_len) {
+			explicit_bzero(encrypted_buf, out_len);
 			free(encrypted_buf);
 			goto cleanup2;
 		}
+		explicit_bzero(encrypted_buf, out_len);
 		free(encrypted_buf);
 	}
 	(void) close(tmp_fd);
@@ -2665,6 +2728,8 @@ soft_keystore_modify_obj(ks_obj_handle_t *ks_handle, uchar_t *buf,
 
 	(void) close(fd);
 
+	explicit_bzero(iv, sizeof (iv));
+	explicit_bzero(obj_hmac, sizeof (obj_hmac));
 	return (0); /* All operations completed successfully */
 
 cleanup2:
@@ -2679,6 +2744,8 @@ cleanup:
 	(void) lock_file(ks_fd, B_FALSE, B_FALSE);
 	(void) close(ks_fd);
 	(void) remove(tmp_ks_name);
+	explicit_bzero(iv, sizeof (iv));
+	explicit_bzero(obj_hmac, sizeof (obj_hmac));
 	return (-1);
 }
 
@@ -2803,6 +2870,7 @@ soft_keystore_get_pin_salt(char **salt)
 
 	if ((readn_nointr(fd, *salt, hashed_pin_salt_size))
 	    != (ssize_t)hashed_pin_salt_size) {
+		explicit_bzero(*salt, hashed_pin_salt_size + 1);
 		free(*salt);
 		goto cleanup;
 	}
diff --git a/usr/src/lib/pkcs11/pkcs11_softtoken/common/softMAC.c b/usr/src/lib/pkcs11/pkcs11_softtoken/common/softMAC.c
index b5930bf89e..c2d5fdffcc 100644
--- a/usr/src/lib/pkcs11/pkcs11_softtoken/common/softMAC.c
+++ b/usr/src/lib/pkcs11/pkcs11_softtoken/common/softMAC.c
@@ -22,10 +22,9 @@
 /*
  * Copyright 2005 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
+ * Copyright (c) 2018, Joyent, Inc.
  */
 
-#pragma ident	"%Z%%M%	%I%	%E% SMI"
-
 #include <pthread.h>
 #include <sys/md5.h>
 #include <sys/sha1.h>
@@ -562,11 +561,13 @@ clean_exit:
 	(void) pthread_mutex_lock(&session_p->session_mutex);
 
 	if (sign_op) {
-		bzero(session_p->sign.context, sizeof (soft_hmac_ctx_t));
+		explicit_bzero(session_p->sign.context,
+		    sizeof (soft_hmac_ctx_t));
 		free(session_p->sign.context);
 		session_p->sign.context = NULL;
 	} else {
-		bzero(session_p->verify.context, sizeof (soft_hmac_ctx_t));
+		explicit_bzero(session_p->verify.context,
+		    sizeof (soft_hmac_ctx_t));
 		free(session_p->verify.context);
 		session_p->verify.context = NULL;
 	}
diff --git a/usr/src/lib/pkcs11/pkcs11_softtoken/common/softSSL.c b/usr/src/lib/pkcs11/pkcs11_softtoken/common/softSSL.c
index fb28932fd0..cce103baa7 100644
--- a/usr/src/lib/pkcs11/pkcs11_softtoken/common/softSSL.c
+++ b/usr/src/lib/pkcs11/pkcs11_softtoken/common/softSSL.c
@@ -925,8 +925,10 @@ soft_ssl_key_and_mac_derive(soft_session_t *sp, CK_MECHANISM_PTR mech,
 	if (new_tmpl_allocated)
 		free(new_tmpl);
 
-	if (export_keys != NULL)
+	if (export_keys != NULL) {
+		explicit_bzero(export_keys, 2 * MD5_HASH_SIZE);
 		free(export_keys);
+	}
 
 	return (rv);
 
@@ -955,8 +957,10 @@ out_err:
 	if (new_tmpl_allocated)
 		free(new_tmpl);
 
-	if (export_keys != NULL)
+	if (export_keys != NULL) {
+		explicit_bzero(export_keys, 2 * MD5_HASH_SIZE);
 		free(export_keys);
+	}
 
 	return (rv);
 }
diff --git a/usr/src/lib/pkcs11/pkcs11_softtoken/common/softSignUtil.c b/usr/src/lib/pkcs11/pkcs11_softtoken/common/softSignUtil.c
index f8824df2dd..ccf746dc40 100644
--- a/usr/src/lib/pkcs11/pkcs11_softtoken/common/softSignUtil.c
+++ b/usr/src/lib/pkcs11/pkcs11_softtoken/common/softSignUtil.c
@@ -22,6 +22,7 @@
  * Copyright 2007 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
  * Copyright 2014 Nexenta Systems, Inc.  All rights reserved.
+ * Copyright (c) 2018, Joyent, Inc.
  */
 
 #include <stdlib.h>
@@ -562,8 +563,10 @@ soft_sign_verify_cleanup(soft_session_t *session_p, boolean_t sign,
 	case CKM_SHA384_HMAC:
 	case CKM_SHA512_HMAC_GENERAL:
 	case CKM_SHA512_HMAC:
-		if (active_op->context != NULL)
-			bzero(active_op->context, sizeof (soft_hmac_ctx_t));
+		if (active_op->context != NULL) {
+			explicit_bzero(active_op->context,
+			    sizeof (soft_hmac_ctx_t));
+		}
 		break;
 	case CKM_DES_MAC_GENERAL:
 	case CKM_DES_MAC:
@@ -572,8 +575,10 @@ soft_sign_verify_cleanup(soft_session_t *session_p, boolean_t sign,
 			session_p->encrypt.context = NULL;
 			session_p->encrypt.flags = 0;
 		}
-		if (active_op->context != NULL)
-			bzero(active_op->context, sizeof (soft_des_ctx_t));
+		if (active_op->context != NULL) {
+			explicit_bzero(active_op->context,
+			    sizeof (soft_des_ctx_t));
+		}
 		break;
 
 	case CKM_AES_CMAC_GENERAL:
@@ -583,8 +588,10 @@ soft_sign_verify_cleanup(soft_session_t *session_p, boolean_t sign,
 			session_p->encrypt.context = NULL;
 			session_p->encrypt.flags = 0;
 		}
-		if (active_op->context != NULL)
-			bzero(active_op->context, sizeof (soft_aes_ctx_t));
+		if (active_op->context != NULL) {
+			explicit_bzero(active_op->context,
+			    sizeof (soft_aes_ctx_t));
+		}
 		break;
 
 	}
diff --git a/usr/src/lib/pkcs11/pkcs11_softtoken/common/softSlotToken.c b/usr/src/lib/pkcs11/pkcs11_softtoken/common/softSlotToken.c
index 602b72486e..3f4fbb9ab2 100644
--- a/usr/src/lib/pkcs11/pkcs11_softtoken/common/softSlotToken.c
+++ b/usr/src/lib/pkcs11/pkcs11_softtoken/common/softSlotToken.c
@@ -337,8 +337,12 @@ C_GetTokenInfo(CK_SLOT_ID slotID, CK_TOKEN_INFO_PTR pInfo)
 			pInfo->flags |= CKF_USER_PIN_TO_BE_CHANGED;
 	}
 
-	if (ks_cryptpin)
+	if (ks_cryptpin != NULL) {
+		size_t cplen = strlen(ks_cryptpin) + 1;
+
+		explicit_bzero(ks_cryptpin, cplen);
 		free(ks_cryptpin);
+	}
 
 	/* Provide information about a token in the provided buffer */
 	(void) strncpy((char *)pInfo->label, SOFT_TOKEN_LABEL, 32);
-- 
2.21.0

