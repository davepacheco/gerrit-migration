From e1b3cce9a3b5568128fc8f10492ab4f80d639ef1 Mon Sep 17 00:00:00 2001
From: Jan Wyszynski <jan.wyszynski@joyent.com>
Date: Wed, 18 Oct 2017 19:38:00 +0000
Subject: [PATCH] joyent/node-zkstream#25 add createWithEmptyParents client api

---
 README.md          |  29 ++++-
 lib/client.js      |  67 +++++++++++
 package.json       |   2 +-
 test/basic.test.js | 269 +++++++++++++++++++++++++++++++++++++++++++++
 4 files changed, 363 insertions(+), 4 deletions(-)

diff --git a/README.md b/README.md
index 76d326e..2291c24 100644
--- a/README.md
+++ b/README.md
@@ -141,10 +141,33 @@ Parameters
  - `path`: a String, path to the node to be created
  - `data`: a Buffer
  - `options`: an optional Object, with keys:
-   - `flags`: an optional Array of Strings, can be `'ephemeral'` or
-              `'sequential'`
+   - `flags`: an optional Array of Strings, can be `'EPHEMERAL'` or
+              `'SEQUENTIAL'`
    - `acl`: an optional Array of ACL objects
- - `cb`: an optional Function `(err)`
+ - `cb`: a Function `(err)`
+
+
+
+### `Client#createWithEmptyParents(path, data[, options[, cb]])`
+
+Creates a new node at the given path, creating any intermediate path
+components and populating them with the data string `null`. If any
+of the intermediate znodes already exist, their ACLs will not be
+modified. Any intermediate component that doesn't exist will
+be created with the ACLs given in the `options` object, if they
+are provided.
+
+Parameters:
+ - `path`: a String, path to the node to be created
+ - `data`: a Buffer
+ - `options`: an optional Object, with keys:
+   - `flags`: an optional Array of String, can be `'EPHEMERAL'` or
+              `'SEQUENTIAL'`. These flags will only be applied to
+              the node represented by the final path component, and
+              not to any of the intermediate (parent) nodes. These
+              intermediate nodes will be created with no flags.
+   - `acl`: an optional Array of ACL objects
+ - `cb`: a Function `(err)`
 
 
 
diff --git a/lib/client.js b/lib/client.js
index 5e50a44..95fbac8 100644
--- a/lib/client.js
+++ b/lib/client.js
@@ -355,6 +355,73 @@ ZKClient.prototype.create = function (path, data, options, cb) {
 	req.once('error', cb);
 };
 
+ZKClient.prototype.createWithEmptyParents = function (path, data, options, cb) {
+	mod_assert.string(path, 'path');
+	mod_assert.buffer(data, 'data');
+	mod_assert.optionalObject(options, 'options');
+	mod_assert.func(cb, 'callback');
+	if (options === undefined || options === null)
+		options = {};
+	mod_assert.optionalArrayOfObject(options.acl, 'options.acl');
+	mod_assert.optionalArrayOfString(options.flags, 'options.flags');
+
+	if (options.acl === undefined || options.acl === null) {
+		options.acl = [ {
+			id: { scheme: 'world', id: 'anyone' },
+			perms: ['read', 'write', 'create', 'delete', 'admin']
+		} ];
+	}
+
+	if (options.flags === undefined || options.flags === null) {
+		options.flags = [];
+	}
+
+	var conn = this.currentConnection();
+	if (conn === undefined || !conn.isInState('connected')) {
+		setImmediate(cb, new mod_errors.ZKNotConnectedError());
+		return;
+	}
+
+	var currentPath = '';
+	var nodes = path.split('/').slice(1);
+	var nullBuffer = new Buffer('null', 'ascii');
+	var count = 0;
+
+	var self = this;
+	mod_vasync.forEachPipeline({
+		func: function (node, next) {
+			currentPath = currentPath + '/' + node;
+			count++;
+			var last = (count === nodes.length);
+			var nodeData = (last) ? data : nullBuffer;
+
+			// All newly created parent nodes are ordinary
+			// persistent nodes. The options are only applied to the
+			// final node.
+			var opts = (last) ? options : {};
+
+			self.create(currentPath, nodeData, opts,
+			    function (err, pktPath) {
+				if (err && (last ||
+				    err.code !== 'NODE_EXISTS')) {
+					next(err);
+					return;
+				}
+				next(null, pktPath);
+			});
+		},
+		inputs: nodes
+	}, function (err, results) {
+		if (err) {
+			cb(err);
+		} else {
+			// Last entry contains the absolute path of the final
+			// created node in the happy path.
+			cb(null, results.successes[results.successes.length-1]);
+		}
+	});
+};
+
 ZKClient.prototype.set = function (path, data, version, cb) {
 	mod_assert.string(path, 'path');
 	mod_assert.buffer(data, 'data');
diff --git a/package.json b/package.json
index a9d8f23..bf0e01a 100644
--- a/package.json
+++ b/package.json
@@ -1,6 +1,6 @@
 {
   "name": "zkstream",
-  "version": "0.9.0",
+  "version": "0.10.0",
   "description": "",
   "main": "lib/index.js",
   "dependencies": {
diff --git a/test/basic.test.js b/test/basic.test.js
index 7f35312..a9d0b52 100644
--- a/test/basic.test.js
+++ b/test/basic.test.js
@@ -11,6 +11,8 @@ const mod_zk = require('./zkserver');
 const mod_zkc = require('../lib/index');
 const mod_net = require('net');
 const mod_bunyan = require('bunyan');
+const mod_util = require('util');
+const mod_vasync = require('vasync');
 
 var log = mod_bunyan.createLogger({
 	name: 'zkstream-test',
@@ -298,6 +300,273 @@ mod_tape.test('create a new node', function (t) {
 	});
 });
 
+mod_tape.test('createWithEmptyParents - basic', function (t) {
+	var zkc = new mod_zkc.Client({
+		log: log,
+		address: '127.0.0.1',
+		port: 2181
+	});
+
+	zkc.on('close', function () {
+		t.end();
+	});
+
+	zkc.on('connect', function () {
+		mod_vasync.pipeline({ funcs: [
+			function (_, callback) {
+				var d = new Buffer('hi there', 'ascii');
+				zkc.createWithEmptyParents('/hi/there', d, {},
+				    function (err, path) {
+					t.strictEqual(path, '/hi/there');
+					callback(err);
+				});
+			},
+			function (_, callback) {
+				zk.cli('get', '/hi', function (err, output) {
+					t.strictEqual(output, 'null\n');
+					callback(err);
+				});
+			},
+			function (_, callback) {
+				zk.cli('get', '/hi/there',
+				    function (err, output) {
+					t.strictEqual(output, 'hi there\n');
+					callback(err);
+				});
+			}
+		]}, function (err, results) {
+			t.error(err);
+			zkc.close();
+		});
+	});
+});
+
+mod_tape.test('createWithEmptyParents - no parent overwrite', function (t) {
+	var zkc = new mod_zkc.Client({
+		log: log,
+		address: '127.0.0.1',
+		port: 2181
+	});
+
+	zkc.on('close', function () {
+		t.end();
+	});
+
+	zkc.on('connect', function () {
+		mod_vasync.pipeline({ funcs: [
+			function (_, callback) {
+				var d = new Buffer('exist', 'ascii');
+				zkc.create('/exist', d, {},
+				    function (err) {
+					callback(err);
+				});
+			},
+			function (_, callback) {
+				var d = new Buffer('new', 'ascii');
+				zkc.createWithEmptyParents('/exist/new', d, {},
+				    function (err, path) {
+					t.strictEqual(path, '/exist/new');
+					callback(err);
+				});
+			},
+			function (_, callback) {
+				zkc.get('/exist', function (err, data) {
+					t.strictEqual(data.toString(),
+					    'exist');
+					callback(err);
+				});
+			},
+			function (_, callback) {
+				zkc.get('/exist/new', function (err, data) {
+					t.strictEqual(data.toString(), 'new');
+					callback(err);
+				});
+			}
+		]}, function (err, results) {
+			t.error(err);
+			zkc.close();
+		});
+	});
+});
+
+mod_tape.test('createWithEmptyParents - create existing node', function (t) {
+	var zkc = new mod_zkc.Client({
+		log: log,
+		address: '127.0.0.1',
+		port: 2181
+	});
+
+	zkc.on('close', function () {
+		t.end();
+	});
+
+	zkc.on('connect', function () {
+		mod_vasync.pipeline({ funcs: [
+			function (_, callback) {
+				var d = new Buffer('new', 'ascii');
+				zkc.createWithEmptyParents('/new/path', d, {},
+				    function (err, path) {
+					t.strictEqual(path, '/new/path');
+					callback(err);
+				});
+			},
+			function (_, callback) {
+				var d = new Buffer('overwrite', 'ascii');
+				zkc.createWithEmptyParents('/new/path', d, {},
+				    function (err) {
+					t.ok(err, 'node already exists');
+					t.strictEqual(err.code, 'NODE_EXISTS');
+					callback();
+				});
+			},
+			function (_, callback) {
+				zkc.get('/new/path', function (err, data) {
+					t.ok(data, 'expects node data');
+					t.strictEqual(data.toString(), 'new');
+					callback();
+				});
+			}
+		]}, function (err, results) {
+			t.error(err);
+			zkc.close();
+		});
+	});
+});
+
+mod_tape.test('createWithEmptyParents - no ephemeral parents', function (t) {
+	var zkc = new mod_zkc.Client({
+		log: log,
+		address: '127.0.0.1',
+		port: 2181
+	});
+
+	zkc.on('close', function () {
+		t.end();
+	});
+
+	// The Client#stat API method returns a property called `ephemeralOwner`
+	// in the stat structure passed to its callback. This property
+	// represents a connection ID that corresponds to the session keeping
+	// the node alive. This is the value it returns when the node is not
+	// ephemeral.
+	var emptyOwnerId = Buffer.from([0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	    0x00, 0x00]);
+
+	function createEphemNode(_, callback) {
+		var d = new Buffer('ephemeral', 'ascii');
+		zkc.createWithEmptyParents('/no/ephem/parents/child', d,
+		    { flags: ['EPHEMERAL'] }, function (err, path) {
+			t.strictEqual(path, '/no/ephem/parents/child');
+			t.error(err);
+			callback(err);
+		});
+	}
+
+	// This function verifies two things. First it checks that the parents
+	// were not created as sequential nodes. It does this by stating all the
+	// prefixes of the full path to check that they are retrievable by the
+	// expected name. Second, it checks for the presence of the
+	// ephemeralOwner property in the stat structure for all the prefixes.
+	// This field should only be present for ephemeral nodes.
+	function checkParentsNotEphem(_, callback) {
+		var dirname = '/no/ephem/parents';
+		var parents = dirname.split('/').splice(1);
+		var currentPath = '';
+		parents.forEach(function (node) {
+			currentPath = currentPath + '/' + node;
+			zkc.stat(currentPath, function (err, stat) {
+				t.error(err);
+				if (stat) {
+					t.ok(stat.ephemeralOwner.equals(
+					    emptyOwnerId), 'parent node ' +
+					    'is not ephemeral');
+				}
+			});
+		});
+		callback();
+	}
+
+	function checkFinalEphem(_, callback) {
+		zkc.stat('/no/ephem/parents/child',
+		    function (err, stat) {
+			t.error(err);
+			t.ok(stat, 'missing stat structure');
+			t.ok(!stat.ephemeralOwner.equals(emptyOwnerId),
+			    'missing ephemeralOwner');
+			callback();
+		});
+	}
+
+	zkc.on('connect', function () {
+		mod_vasync.pipeline({ funcs: [
+			createEphemNode,
+			checkParentsNotEphem,
+			checkFinalEphem
+		]}, function (err, results) {
+			t.error(err);
+			zkc.close();
+		});
+	});
+});
+
+mod_tape.test('createWithEmptyParents - no sequential parents', function (t) {
+	var zkc = new mod_zkc.Client({
+		log: log,
+		address: '127.0.0.1',
+		port: 2181
+	});
+
+	zkc.on('close', function () {
+		t.end();
+	});
+
+	var path = '/no/seq/parents/child';
+
+
+	function runPipeline(createdPath) {
+
+		function checkNoSequentialParents(_, callback) {
+		        var parentPath = '/no/seq/parents';
+			var parents = parentPath.split('/').splice(1);
+			var currentPath = '';
+			parents.forEach(function (node) {
+				currentPath = currentPath + '/' + node;
+				zkc.stat(currentPath, function (sErr, stat) {
+				    t.error(sErr);
+				    t.ok(stat, 'missing stat structure');
+				});
+			});
+			callback();
+		}
+
+		function checkSequentialChild(_, callback) {
+			zkc.stat(createdPath, function (sErr, stat) {
+				t.error(sErr);
+				t.ok(stat, 'missing stat structure');
+				callback(sErr);
+			});
+		}
+
+		mod_vasync.pipeline({ funcs: [
+			checkNoSequentialParents,
+			checkSequentialChild
+		]}, function (pErr, results) {
+			t.error(pErr);
+			zkc.close();
+		});
+	}
+
+	zkc.on('connect', function () {
+		var d = new Buffer('sequence node', 'ascii');
+		zkc.createWithEmptyParents(path, d,
+		    { flags: ['SEQUENTIAL'] },
+		    function (err, sequentialPath) {
+			t.error(err);
+			runPipeline(sequentialPath);
+		});
+	});
+});
+
 mod_tape.test('create a large node', function (t) {
 	var zkc = new mod_zkc.Client({
 		log: log,
-- 
2.21.0

