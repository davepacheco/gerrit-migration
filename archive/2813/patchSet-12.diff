commit b8b44e6c6938606dda49f4eb11fa840687654d91 (refs/changes/13/2813/12)
Author: Jan Wyszynski <jan.wyszynski@joyent.com>
Date:   2017-11-17T23:10:15+00:00 (1 year, 11 months ago)
    
    joyent/node-zkstream#25 add createWithEmptyParents client api

diff --git a/README.md b/README.md
index 76d326e..63f94b5 100644
--- a/README.md
+++ b/README.md
@@ -141,10 +141,32 @@ Parameters
  - `path`: a String, path to the node to be created
  - `data`: a Buffer
  - `options`: an optional Object, with keys:
-   - `flags`: an optional Array of Strings, can be `'ephemeral'` or
-              `'sequential'`
+   - `flags`: an optional Array of Strings, can be `'EPHEMERAL'` or
+              `'SEQUENTIAL'`
    - `acl`: an optional Array of ACL objects
- - `cb`: an optional Function `(err)`
+ - `cb`: a Function `(err)`
+
+
+
+### `Client#createWithEmptyParents(path, data[, options[, cb]])`
+
+Creates a new node at the given path, creating any intermediate path
+components and populating them with the data string `null`. If any
+of the intermediate znodes already exist, their ACLs will not be
+modified. Any intermediate component that doesn't exist will
+be created with the ACLs given in the `options` object, if they
+are provided.
+
+Parameters:
+ - `path`: a String, path to the node to be created
+ - `data`: a Buffer
+ - `options`: an optional Object, with keys:
+   - `flags`: an optional Array of String, can be `'EPHEMERAL'` or
+              `'SEQUENTIAL'`. These flags will only be applied to
+              the node represented by the final path component, and
+              not to any of the intermediate (parent) nodes.
+   - `acl`: an optional Array of ACL objects
+ - `cb`: a Function `(err)`
 
 
 
diff --git a/lib/client.js b/lib/client.js
index 5e50a44..e032517 100644
--- a/lib/client.js
+++ b/lib/client.js
@@ -355,6 +355,70 @@ ZKClient.prototype.create = function (path, data, options, cb) {
 	req.once('error', cb);
 };
 
+ZKClient.prototype.createWithEmptyParents = function (path, data, options, cb) {
+	mod_assert.string(path, 'path');
+	mod_assert.buffer(data, 'data');
+	mod_assert.optionalObject(options, 'options');
+	mod_assert.func(cb, 'callback');
+	if (options === undefined || options === null)
+		options = {};
+	mod_assert.optionalArrayOfObject(options.acl, 'options.acl');
+	mod_assert.optionalArrayOfString(options.flags, 'options.flags');
+
+	if (options.acl === undefined || options.acl === null) {
+		options.acl = [ {
+			id: { scheme: 'world', id: 'anyone' },
+			perms: ['read', 'write', 'create', 'delete', 'admin']
+		} ];
+	}
+
+	if (options.flags === undefined || options.flags === null) {
+		options.flags = [];
+	}
+
+	var conn = this.currentConnection();
+	if (conn === undefined || !conn.isInState('connected')) {
+		setImmediate(cb, new mod_errors.ZKNotConnectedError());
+		return;
+	}
+
+	var currentPath = '';
+	var nodes = path.split('/').slice(1);
+	var nullBuffer = new Buffer('null', 'ascii');
+	var count = 0;
+
+	var self = this;
+	mod_vasync.forEachPipeline({
+		func: function (node, next) {
+			currentPath = currentPath + '/' + node;
+			count++;
+			var last = (count === nodes.length);
+			var nodeData = (last) ? data : nullBuffer;
+
+			self.create(currentPath, nodeData, options,
+			    function (err) {
+				if (!err || (!last && err &&
+				    err.code === 'NODE_EXISTS')) {
+					if (last) {
+						next(null);
+					} else {
+						next();
+					}
+				} else {
+					next(err);
+				}
+			});
+		},
+		inputs: nodes
+	}, function (err, results) {
+		if (err) {
+			cb(err);
+		} else {
+			cb(null);
+		}
+	});
+};
+
 ZKClient.prototype.set = function (path, data, version, cb) {
 	mod_assert.string(path, 'path');
 	mod_assert.buffer(data, 'data');
diff --git a/package.json b/package.json
index a9d8f23..bf0e01a 100644
--- a/package.json
+++ b/package.json
@@ -1,6 +1,6 @@
 {
   "name": "zkstream",
-  "version": "0.9.0",
+  "version": "0.10.0",
   "description": "",
   "main": "lib/index.js",
   "dependencies": {
diff --git a/test/basic.test.js b/test/basic.test.js
index 7f35312..5e8d6b2 100644
--- a/test/basic.test.js
+++ b/test/basic.test.js
@@ -11,6 +11,7 @@ const mod_zk = require('./zkserver');
 const mod_zkc = require('../lib/index');
 const mod_net = require('net');
 const mod_bunyan = require('bunyan');
+const mod_vasync = require('vasync');
 
 var log = mod_bunyan.createLogger({
 	name: 'zkstream-test',
@@ -298,6 +299,136 @@ mod_tape.test('create a new node', function (t) {
 	});
 });
 
+mod_tape.test('createWithEmptyParents - basic', function (t) {
+	var zkc = new mod_zkc.Client({
+		log: log,
+		address: '127.0.0.1',
+		port: 2181
+	});
+
+	zkc.on('close', function () {
+		t.end();
+	});
+
+	zkc.on('connect', function () {
+		mod_vasync.pipeline({ funcs: [
+			function (_, callback) {
+				var d = new Buffer('hi there', 'ascii');
+				zkc.createWithEmptyParents('/hi/there', d, {},
+				    function (err) {
+					callback(err);
+				});
+			},
+			function (_, callback) {
+				zk.cli('get', '/hi', function (err, output) {
+					t.strictEqual(output, 'null\n');
+					callback(err);
+				});
+			},
+			function (_, callback) {
+				zk.cli('get', '/hi/there',
+				    function (err, output) {
+					t.strictEqual(output, 'hi there\n');
+					callback(err);
+				});
+			}
+		]}, function (err, results) {
+			t.error(err);
+			zkc.close();
+		});
+	});
+});
+
+mod_tape.test('createWithEmptyParents - no parent overwrite', function (t) {
+	var zkc = new mod_zkc.Client({
+		log: log,
+		address: '127.0.0.1',
+		port: 2181
+	});
+
+	zkc.on('close', function () {
+		t.end();
+	});
+
+	zkc.on('connect', function () {
+		mod_vasync.pipeline({ funcs: [
+			function (_, callback) {
+				var d = new Buffer('exist', 'ascii');
+				zkc.create('/exist', d, {},
+				    function (err) {
+					callback(err);
+				});
+			},
+			function (_, callback) {
+				var d = new Buffer('new', 'ascii');
+				zkc.createWithEmptyParents('/exist/new', d, {},
+				    function (err) {
+					callback(err);
+				});
+			},
+			function (_, callback) {
+				zkc.get('/exist', function (err, data) {
+					t.strictEqual(data.toString(),
+					    'exist');
+					callback(err);
+				});
+			},
+			function (_, callback) {
+				zkc.get('/exist/new', function (err, data) {
+					t.strictEqual(data.toString(), 'new');
+					callback(err);
+				});
+			}
+		]}, function (err, results) {
+			t.error(err);
+			zkc.close();
+		});
+	});
+});
+
+mod_tape.test('createWithEmptyParents - create existing node', function (t) {
+	var zkc = new mod_zkc.Client({
+		log: log,
+		address: '127.0.0.1',
+		port: 2181
+	});
+
+	zkc.on('close', function () {
+		t.end();
+	});
+
+	zkc.on('connect', function () {
+		mod_vasync.pipeline({ funcs: [
+			function (_, callback) {
+				var d = new Buffer('new', 'ascii');
+				zkc.createWithEmptyParents('/new/path', d, {},
+				    function (err) {
+					callback(err);
+				});
+			},
+			function (_, callback) {
+				var d = new Buffer('overwrite', 'ascii');
+				zkc.createWithEmptyParents('/new/path', d, {},
+				    function (err) {
+					t.ok(err, 'node already exists');
+					t.strictEqual(err.code, 'NODE_EXISTS');
+					callback();
+				});
+			},
+			function (_, callback) {
+				zkc.get('/new/path', function (err, data) {
+					t.ok(data, 'expects node data');
+					t.strictEqual(data.toString(), 'new');
+					callback();
+				});
+			}
+		]}, function (err, results) {
+			t.error(err);
+			zkc.close();
+		});
+	});
+});
+
 mod_tape.test('create a large node', function (t) {
 	var zkc = new mod_zkc.Client({
 		log: log,
