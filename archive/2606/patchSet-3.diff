From 5a9f0b6950c30bbf08256afcde7dfc74570d3cee Mon Sep 17 00:00:00 2001
From: Kody A Kantor <kody.kantor@gmail.com>
Date: Tue, 19 Sep 2017 19:19:54 +0000
Subject: [PATCH] joyent/node-artedi#5 Implement AbsoluteGauge
 joyent/node-artedi#6 Implement basic triggered metrics joyent/node-artedi#7
 artedi shouldn't attach timestamps to prometheus metrics joyent/node-artedi#8
 artedi collectors should share more code

---
 CHANGES.adoc         |   9 --
 CHANGES.md           |  13 +++
 docs/API.md          |  64 ++++++++++----
 docs/DESIGN.md       |   5 +-
 docs/private_api.md  |  26 ++----
 lib/collector.js     | 187 +++++++++++++++++++++++++++++----------
 lib/common.js        |  60 ++++++++++++-
 lib/counter.js       |  34 +-------
 lib/gauge.js         |  63 ++++----------
 lib/histogram.js     |   8 +-
 lib/metric.js        |  10 ++-
 lib/metric_vector.js |   3 +-
 lib/utils.js         |   5 +-
 package.json         |   3 +-
 test/basic.test.js   | 203 ++++++++++++++++++++++++-------------------
 15 files changed, 416 insertions(+), 277 deletions(-)
 delete mode 100644 CHANGES.adoc
 create mode 100644 CHANGES.md

diff --git a/CHANGES.adoc b/CHANGES.adoc
deleted file mode 100644
index 1c521ca..0000000
--- a/CHANGES.adoc
+++ /dev/null
@@ -1,9 +0,0 @@
-:toc: macro
-
-# Changelog
-
-toc::[]
-
-## v0.x
-
-### unreleased
diff --git a/CHANGES.md b/CHANGES.md
new file mode 100644
index 0000000..62e8352
--- /dev/null
+++ b/CHANGES.md
@@ -0,0 +1,13 @@
+# Changelog
+
+## Not yet released
+None
+
+## 1.1.0
+* #5 Implement AbsoluteGauge
+* #6 Implement basic triggered metrics
+* #7 artedi shouldn't attach timestamps to prometheus metrics
+* #8 artedi collectors should share more code
+
+## 1.0.0
+* #3 Support Prometheus-style counters and histograms
diff --git a/docs/API.md b/docs/API.md
index 3dce5a5..74d70e7 100644
--- a/docs/API.md
+++ b/docs/API.md
@@ -2,7 +2,6 @@
 * [Collector](#collector)
 * [Counter](#counter)
 * [Gauge](#gauge)
-* [Absolute Gauge](#absolutegauge)
 * [Histogram](#histogram)
 
 ## Intro
@@ -49,7 +48,7 @@ var counter = collector.counter({
 });
 ```
 ### collector.gauge(opts) : Gauge
-Create a new Gauge object with the given options (incl. labels). This call is
+Creates a new Gauge object with the given options (incl. labels). This call is
 idempotent. `opts` must include 'help' and 'name' fields, and may optionally
 include a 'labels' object.
 
@@ -63,7 +62,6 @@ var gauge = collector.gauge({
     }
 });
 ```
-
 ### collector.histogram(opts) : Histogram
 Creates a new Histogram object with the given options (incl. labels). This call
 is idempotent. `opts` must include 'help' and 'name' fields, and may optionally
@@ -80,9 +78,37 @@ var histogram = collector.histogram({
 });
 ```
 
+### collector.addTriggerFunction(func(Collector, callback))
+Adds `func` to a list of triggers to call immediately before metrics are
+collected during a call to `collector.collect()`.
+
+`func` must take 'callback' and 'collector' arguments and invoke the callback to
+signal the end of the trigger. The callback can be invoked with an Error
+argument if an error occurs during trigger execution.
+
+The Collector that is passed into the trigger is a handle to the Collector that
+the trigger was registered with.
+
+Example:
+```javascript
+function myTrigger(m_collector, cb) {
+    var my_counter = m_collector.getCollector('http_requests_completed');
+    my_counter.increment(); // Increment a counter.
+    cb(null); // No error occurred.
+}
+
+collector.addTriggerFunction(myTrigger);
+```
+
 ### collector.collect(format, callback(err, string))
-Iterate through the list of previously-instantiated collectors, calling the
-serialization function corresponding to `format` on each collector.
+Iterates through the list of previously provided trigger functions, invoking
+each trigger. Triggers are invoked in parallel. After all of the trigger
+functions have returned, the previously-instantiated collectors serialize their
+metrics in the provided format.
+
+If an error occurs during the execution of either triggers or collector
+serialization, collection will stop and an error will be returned through the
+callback.
 
 Valid values for `format` are in the global `artedi` namespace. Currently, the
 valid values are `FMT_PROM` and `FMT_PROM_0_0_4`. `FMT_PROM` will always point
@@ -99,6 +125,16 @@ collector.collect(artedi.FMT_PROM, function (err, str) {
     console.log(str);
 });
 ```
+
+### collector.getCollector(name) : child collector
+Finds a child collector with the given `name`, and returns it, if it exists. If
+the collector doesn't exist, `null` is returned.
+
+Example:
+```javascript
+var my_counter = collector.getCollector('http_requests_completed');
+```
+
 ## Counter
 Counters are the most simple of the collector types. They simply count
 up starting from zero. You can either increment a counter, or add
@@ -128,8 +164,8 @@ counter.add(100, {
 
 ## Gauge
 Gauges are similar to counters. Gauges can count up, or count down relative
-to their current value. Gauges start with an initial value of `0`. If you want
-a gauge that can be set to arbitrary values, look at [AbsoluteGauge](#absolutegauge).
+to their current value, or be set to an arbitrary value. Gauges start with an
+initial value of `0`.
 
 ### gauge.add(value, labels)
 Add `value` to the metric represented by `labels`.
@@ -141,22 +177,12 @@ gauge.add(10, {
 });
 ```
 
-## AbsoluteGauge
-AbsoluteGauges are metrics that can only be set to an arbitrary value. These are
-useful for tracking things like the current amount of memory available on a
-system, or the async lag of a postgres peer. If you need to 'move' a gauge
-relative to its current position, you probably want to use [Gauge](#gauge)
-instead.
-
-### absoluteGauge.set(value, labels)
+### gauge.set(value, labels)
 Set the metric represented by `labels` to `value`.
 
-The `AbsoluteGauge` object has not yet been implemented. `AbsoluteGauge` is
-going to be implemented in one of the first post-1.0 releases.
-
 Example:
 ```javascript
-absoluteGauge.set(123, {
+gauge.set(123, {
     tableName: 'manta'
 });
 ```
diff --git a/docs/DESIGN.md b/docs/DESIGN.md
index 1a1c146..ffd55a4 100644
--- a/docs/DESIGN.md
+++ b/docs/DESIGN.md
@@ -274,9 +274,8 @@ period. At collection time, the each of the metrics in the 'trigger registry'
 could be invoked. This is similar to existing solutions, like
 [boolean health checks](http://metrics.dropwizard.io/3.2.2/getting-started.html#health-checks).
 
-Further implementation details have to be worked out when we implement Triggered
-Metrics. Triggered Metrics will be implemented soon after the initial release,
-as they're a necessary feature to efficiently gather some types of metrics.
+Basic triggered metrics (type 1) from above) are implemented in node-artedi
+version 1.1.0. Type 2) triggered metrics are not yet implemented.
 
 ### Children are leaf collectors
 Children cannot be created from children. That is, a user can't call
diff --git a/docs/private_api.md b/docs/private_api.md
index a6730f7..d64689a 100644
--- a/docs/private_api.md
+++ b/docs/private_api.md
@@ -106,17 +106,22 @@ API.md by describing the private functions, as well as 'class variables'.
 | Variable | Type | Value |
 |----------|------|-----------------|
 |registry  | object | key/value mapping of unique collector names -> child collectors|
+|triggerRegistry | array | Array of trigger functions |
 
 `registry` keeps references to all of the previously-instantiated child
 collectors. When it is time to serialize metrics, the Collector iterates through
 this map and calls the serialization method of choice on each child collector.
 The results are concatenated and returned to the user.
 
+`triggerRegistry` keeps references to functions that will be invoked before
+metrics are collected. See collector.processTriggers() for more information.
+
 | Function | Arguments | Result | Return Value|
 |----------|-----------|--------|-------------|
 |Collector | opts      | see `createCollector()`| see `createCollector()`|
 |register  |collector object|if the given collector has already been registered, returns an error. Otherwise, adds the collector to `registry`|error, or null|
-|getCollector|name|returns the collector with the full name of `name`, or null if not present in `registry`|collector object, or null|
+|processTriggers | array, callback | Iterates through triggers in the triggerRegistry, calling each function |
+|processCollectors | array, callback | Iterates through child collectors in the registry, calling a serialization function on each|
 
 `Collector()` is called by the public `createCollector` function.
 
@@ -154,25 +159,6 @@ The results are concatenated and returned to the user.
 
 `Gauge()` is called by the Collector object's `gauge()` function.
 
-### AbsoluteGauge
-AbsoluteGauge is not yet implemented.
-
-| Variable | Type | Value |
-|----------|------|-----------------|
-|name|string|full name of what is being tracked, resulting from concatenation of namespace, subsystem, and collector name|
-|help|string|user-provided string explaining this collector|
-|metricVec|MetricVector|empty to start, is populated as the user performs metric operations|
-|type|string|'gauge,' used during serialization|
-|staticLabels|object|key/value mapping of labels that will be present in all metrics collected by this collector|
-
-| Function | Arguments | Result | Return Value|
-|----------|-----------|--------|-------------|
-|AbsoluteGauge |parent, opts|creates an AbsoluteGauge object from traits available in the parent, and options passed in|a new AbsoluteGauge object|
-|labels|object|returns a metric that have *exactly* the label key/value pairs provided. If none exists, one is created|A Metric object|
-|prometheus|callback   |returns all of the Gauge's metrics in prometheus format as a string|None (string and error via callback)|
-
-`AbsoluteGauge()` is called by the Collector object's `absoluteGauge()` function.
-
 ### Histogram
 | Variable | Type | Value |
 |----------|------|-----------------|
diff --git a/lib/collector.js b/lib/collector.js
index 3238003..3239fa5 100644
--- a/lib/collector.js
+++ b/lib/collector.js
@@ -9,6 +9,7 @@
 var mod_assert = require('assert-plus');
 var mod_vasync = require('vasync');
 var mod_jsprim = require('jsprim');
+var mod_verror = require('verror');
 var VError = require('verror').VError;
 var MultiError = require('verror').MultiError;
 
@@ -49,6 +50,11 @@ var FMT_PROM = FMT_PROM_0_0_4;
  *      first created the counter), we can simply return the counter that has
  *      already been created without having lost any important metrics.
  *
+ *
+ * The Collector object also keeps track of a list of trigger functions. These
+ * trigger functions will be kicked off when the collect() function is called.
+ * For more information, see Collector.collect() and
+ * Collector.processTriggers().
  */
 function Collector(options) {
     mod_assert.optionalObject(options, 'options');
@@ -69,6 +75,7 @@ function Collector(options) {
     }
 
     this.registry = {};
+    this.triggerRegistry = [];
 }
 
 /* Public Functions */
@@ -98,9 +105,15 @@ Collector.prototype.histogram = function histogram(options) {
 };
 
 /*
- * We will tell each collector that is a child of this Collector to produce
- * machine-readable output that we can report back to whatever is scraping
- * this process.
+ * This function pulls together the metrics that have been collected by each
+ * of the child collectors.
+ *
+ * First, we kick off all of the registered metric triggers. Those are expected
+ * to modify a number of metrics.
+ *
+ * Next, we will tell each collector that is a child of this Collector to
+ * produce machine-readable output that we can report back to whatever is
+ * scraping this process.
  *
  * For example, if this collector has two child collectors (a Counter and
  * a Histogram), this instructs both to produce Prometheus-style output and
@@ -110,45 +123,51 @@ Collector.prototype.collect = function collect(format, cb) {
     mod_assert.string(format, 'format');
     mod_assert.func(cb, 'cb');
 
-    var str = '';
-    var errors = [];
-    var queue;
-    var multiError = null;
-
-    if (format === FMT_PROM) {
-
-        var promCallback = function promCallback(err, metricString) {
-            mod_assert.string(metricString, 'metricString');
-            if (err) {
-                errors.push(err);
-            }
-            str += metricString;
-        };
-
-        var dispatchCollect = function dispatchCollect(collector, callback) {
-            collector.prometheus(callback);
-        };
-
-        queue = mod_vasync.queue(dispatchCollect, 10);
-        mod_jsprim.forEachKey(this.registry, function (_, collector) {
-            queue.push(collector, promCallback);
-        });
-        queue.close();
-
-    } else {
-        errors.push(new VError('Unknown serialization format: ' + format));
-        cb(multiError, str);
-        return;
-    }
-
-    queue.once('end', function () {
-        if (errors.length > 0) {
-            multiError = new MultiError(errors);
+    /*
+     * First, process trigger functions.
+     * Second, serialize the metrics.
+     */
+    mod_vasync.pipeline({
+        'funcs': [
+            this.processTriggers,
+            this.processCollectors
+        ],
+        'arg': [this, format]
+    }, function (err, result) {
+        if (err) {
+            cb(err, null);
+            return;
         }
-        cb(multiError, str);
+        /*
+         * result.operations[1].result is the result of the processCollectors()
+         * call.
+         */
+        cb(null, result.operations[1].result);
     });
 };
 
+/*
+ * Adds the given trigger function to the trigger registry. A function added
+ * through this API will be called when metrics are scraped from this collector.
+ *
+ * Functions passed in must take a callback, and returns an error (if one
+ * occurs) through the callback function.
+ */
+Collector.prototype.addTriggerFunction = function addTriggerFunction(func) {
+    mod_assert.func(func, 'func');
+    this.triggerRegistry.push(func);
+};
+
+/*
+ * Finds finds the named collector in the registry and returns it. If none
+ * exists, returns 'null.'
+ */
+Collector.prototype.getCollector = function getCollector(name) {
+    if (!mod_jsprim.hasKey(this.registry, name)) {
+        return (null);
+    }
+    return (this.registry[name]);
+};
 
 
 /* Private Functions */
@@ -228,14 +247,94 @@ Collector.prototype.register = function register(collector) {
 };
 
 /*
- * Finds finds the named collector in the registry and returns it. If none
- * exists, returns 'null.'
+ * Iterate through the registry of child collectors and kick off the
+ * serialization tasks for the given serialization format.
  */
-Collector.prototype.getCollector = function getCollector(name) {
-    if (!mod_jsprim.hasKey(this.registry, name)) {
-        return (null);
+Collector.prototype.processCollectors = function processCollectors(args, cb) {
+    var str = '';
+    var errors = [];
+    var queue;
+    var multiError = null;
+    var dispatch, promCallback;
+
+    // The 'this' object and serialization format are passed in as arguments.
+    var obj = args[0];
+    var format = args[1];
+
+    if (format === FMT_PROM) {
+
+        // When metrics are done being serialized, append them to the cumulative
+        // reporting string.
+        promCallback = function collectDone(err, metricString) {
+            mod_assert.string(metricString, 'metricString');
+            if (err) {
+                errors.push(err);
+            }
+            str += metricString;
+        };
+        // Instruct each collector to serialize their metrics.
+        dispatch = function dispatchCollect(collector, callback) {
+            collector.prometheus(callback);
+        };
+
+        // Add each child collector to the serialization queue.
+        queue = mod_vasync.queue(dispatch, 10);
+        mod_jsprim.forEachKey(obj.registry, function (_, collector) {
+            queue.push(collector, promCallback);
+        });
+        queue.close();
+        queue.once('end', function () {
+            if (errors.length > 0) {
+                multiError = new MultiError(errors);
+            }
+            cb(multiError, str);
+        });
+
+
+    } else {
+        errors.push(new VError('Unknown serialization format: ' + format));
+        cb(multiError, str);
+        return;
     }
-    return (this.registry[name]);
+};
+
+/*
+ * Go through the trigger registry and kick off any triggers that the user may
+ * have specified. If the user didn't specify any triggers this function just
+ * creates and closes an empty vasync queue.
+ *
+ * We allow a maximum of five concurrent triggers.
+ */
+Collector.prototype.processTriggers = function processTriggers(args, cb) {
+    var triggerCallback, dispatch;
+    var triggerQueue;
+    var triggerErrors = [];
+
+    var obj = args[0];
+
+    // Kick off each trigger.
+    dispatch = function dispatchTrigger(trigger, callback) {
+        trigger(obj, callback);
+    };
+
+    // Allow up to five concurrent triggers.
+    triggerQueue = mod_vasync.queue(dispatch, 5);
+
+    // When a trigger ends, retain errors (if any).
+    triggerCallback = function triggerDone(err) {
+        if (err) {
+            triggerErrors.push(err);
+        }
+    };
+
+    // Add all of the triggers from the registry to the queue.
+    triggerQueue.push(obj.triggerRegistry, triggerCallback);
+    triggerQueue.close();
+
+    triggerQueue.once('end', function () {
+        cb(mod_verror.errorFromList(triggerErrors));
+        return;
+    });
 };
 
 module.exports = {
diff --git a/lib/common.js b/lib/common.js
index 5023885..dad45d1 100644
--- a/lib/common.js
+++ b/lib/common.js
@@ -5,12 +5,68 @@
  *
  * Copyright (c) 2017, Joyent, Inc.
  */
+var mod_assert = require('assert-plus');
+var mod_jsprim = require('jsprim');
+var mod_util = require('util');
+
+var lib_metric_vector = require('./metric_vector');
+
+function constructor(options, obj) {
+    mod_assert.object(options, 'options');
+    mod_assert.string(options.name, 'options.name');
+    mod_assert.string(options.help, 'options.help');
+    mod_assert.optionalObject(options.labels, 'options.labels');
+    mod_assert.optionalObject(options.parentLabels, 'options.parentLabels');
+
+    obj.staticLabels =
+        mod_jsprim.mergeObjects(options.parentLabels, options.labels, null);
+
+    obj.help = options.help;
+    obj.name = options.name;
+    obj.metricVec = new lib_metric_vector.MetricVector({
+        name: obj.name,
+        labels: obj.staticLabels
+    });
+}
 
 /*
- * These are a few global constants used in various places in this library.
+ * Returns a Metric object that represents the labels passed in. If a Metric
+ * exists with the given labels in the MetricVector, it will be returned without
+ * creating a new Metric. If no labels are specified, the 'default' metric
+ * (that is, the Metric with no labels) is returned.
  */
+function labels(pairs, obj) {
+    mod_assert.optionalObject(pairs, 'pairs');
+
+    if (!pairs || mod_jsprim.isEmpty(pairs)) {
+        return (obj.metricVec.getDefault());
+    }
+
+    return (obj.metricVec.createOrGetWithLabels(pairs));
+}
+
+/*
+ * Call the 'prometheus()' function on the MetricVector object, which represents
+ * all of the metrics. Additionally, append the HELP and TYPE lines that are
+ * specific to this metric.
+ */
+function prometheus(cb, obj) {
+    mod_assert.func(cb, 'cb');
+    var str = mod_util.format('%s %s %s\n', '# HELP', obj.name, obj.help);
+    str += mod_util.format('%s %s %s\n', '# TYPE', obj.name, obj.type);
+
+    obj.metricVec.prometheus(function (err, metrics) {
+        str += metrics;
+        cb(err, str);
+    });
+}
+
 module.exports = {
+    prometheus: prometheus,
+    constructor: constructor,
+    labels: labels,
     COUNTER: 'counter',
     GAUGE: 'gauge',
-    HISTOGRAM: 'histogram'
+    HISTOGRAM: 'histogram',
+    ABS_GAUGE: 'absgauge'
 };
diff --git a/lib/counter.js b/lib/counter.js
index d8f4749..266d671 100644
--- a/lib/counter.js
+++ b/lib/counter.js
@@ -5,13 +5,10 @@
  *
  * Copyright (c) 2017, Joyent, Inc.
  */
-var mod_util = require('util');
 
 var mod_assert = require('assert-plus');
-var mod_jsprim = require('jsprim');
 var VError = require('verror').VError;
 
-var lib_metric_vector = require('./metric_vector');
 var lib_common = require('./common');
 
 /*
@@ -19,22 +16,8 @@ var lib_common = require('./common');
  * functions 'add()' and 'increment()'.
  */
 function Counter(options) {
-    mod_assert.object(options, 'options');
-    mod_assert.string(options.name, 'options.name');
-    mod_assert.string(options.help, 'options.help');
-    mod_assert.optionalObject(options.labels, 'options.labels');
-    mod_assert.optionalObject(options.parentLabels, 'options.parentLabels');
-
-    this.staticLabels =
-        mod_jsprim.mergeObjects(options.labels, options.parentLabels, null);
-
-    this.name = options.name;
-    this.help = options.help;
-    this.metricVec = new lib_metric_vector.MetricVector({
-        name: this.name,
-        labels: this.staticLabels
-    });
     this.type = lib_common.COUNTER;
+    lib_common.constructor(options, this);
 }
 
 /* Public Functions */
@@ -72,12 +55,7 @@ Counter.prototype.add = function add(value, pairs) {
  * (that is, the Metric with no labels) is returned.
  */
 Counter.prototype.labels = function labels(pairs) {
-    mod_assert.optionalObject(pairs);
-    if (!pairs || mod_jsprim.isEmpty(pairs)) { // User passed in '{}'.
-        return (this.metricVec.getDefault());
-    }
-
-    return (this.metricVec.createOrGetWithLabels(pairs));
+    return (lib_common.labels(pairs, this));
 };
 
 /*
@@ -86,13 +64,7 @@ Counter.prototype.labels = function labels(pairs) {
  * specific to this metric.
  */
 Counter.prototype.prometheus = function prometheus(cb) {
-    var str = mod_util.format('%s %s %s\n', '# HELP', this.name, this.help);
-    str += mod_util.format('%s %s %s\n', '# TYPE', this.name, this.type);
-
-    this.metricVec.prometheus(function (err, metrics) {
-        str += metrics;
-        cb(err, str);
-    });
+    lib_common.prometheus(cb, this);
 };
 
 module.exports = {
diff --git a/lib/gauge.js b/lib/gauge.js
index 1efef03..8929c17 100644
--- a/lib/gauge.js
+++ b/lib/gauge.js
@@ -5,12 +5,8 @@
  *
  * Copyright (c) 2017, Joyent, Inc.
  */
-var mod_util = require('util');
-
 var mod_assert = require('assert-plus');
-var mod_jsprim = require('jsprim');
 
-var lib_metric_vector = require('./metric_vector');
 var lib_common = require('./common');
 
 /*
@@ -19,28 +15,14 @@ var lib_common = require('./common');
  * function.
  */
 function Gauge(options) {
-    mod_assert.object(options, 'options');
-    mod_assert.string(options.name, 'options.name');
-    mod_assert.string(options.help, 'options.help');
-    mod_assert.optionalObject(options.labels, 'options.labels');
-    mod_assert.optionalObject(options.parentLabels, 'options.parentLabels');
-
-    this.staticLabels =
-        mod_jsprim.mergeObjects(options.parentLabels, options.labels, null);
-
-    this.help = options.help;
     this.type = lib_common.GAUGE;
-    this.name = options.name;
-    this.metricVec = new lib_metric_vector.MetricVector({
-        name: this.name,
-        labels: this.staticLabels
-    });
+    lib_common.constructor(options, this);
 }
 
- /*
-  * Add 'value' to the Metric represented by the labels, 'pairs.' This uses the
-  * 'labels()' function to find the metric represented by 'pairs.'
-  */
+/*
+ * Add 'value' to the Metric represented by the labels, 'pairs.' This uses the
+ * 'labels()' function to find the metric represented by 'pairs.'
+ */
 Gauge.prototype.add = function add(value, pairs) {
     mod_assert.optionalObject(pairs, 'pairs');
     mod_assert.number(value, 'value');
@@ -49,38 +31,23 @@ Gauge.prototype.add = function add(value, pairs) {
     metric.add(value);
 };
 
-/* Private Functions */
 /*
- * Returns a Metric object that represents the labels passed in. If a Metric
- * exists with the given labels in the MetricVector, it will be returned without
- * creating a new Metric. If no labels are specified, the 'default' metric
- * (that is, the Metric with no labels) is returned.
+ * Sets the value of the Metric represented by the labels, 'pairs.'
  */
-Gauge.prototype.labels = function labels(pairs) {
+Gauge.prototype.set = function set(value, pairs) {
     mod_assert.optionalObject(pairs, 'pairs');
+    mod_assert.number(value, 'value');
 
-    if (!pairs || mod_jsprim.isEmpty(pairs)) {
-        return (this.metricVec.getDefault());
-    }
-
-    return (this.metricVec.createOrGetWithLabels(pairs));
+    var metric = this.labels(pairs);
+    metric.set(value);
 };
 
-/*
- * Call the 'prometheus()' function on the MetricVector object, which represents
- * all of the metrics. Additionally, append the HELP and TYPE lines that are
- * specific to this metric.
- */
+/* Private Functions */
+Gauge.prototype.labels = function labels(pairs) {
+    return (lib_common.labels(pairs, this));
+};
 Gauge.prototype.prometheus = function prometheus(cb) {
-    mod_assert.func(cb, 'cb');
-    var str = mod_util.format('%s %s %s\n', '# HELP', this.name, this.help);
-    str += mod_util.format('%s %s %s\n', '# TYPE', this.name, this.type);
-
-    this.metricVec.prometheus(function (err, metrics) {
-        str += metrics;
-        cb(err, str);
-    });
-
+    lib_common.prometheus(cb, this);
 };
 
 module.exports = {
diff --git a/lib/histogram.js b/lib/histogram.js
index c12db74..50ce9ef 100644
--- a/lib/histogram.js
+++ b/lib/histogram.js
@@ -252,14 +252,12 @@ Histogram.prototype.prometheus = function prometheus(cb) {
         str += mod_util.format('%s_count{%s}', this.name, labelStr);
 
         // Append the +Inf value to the _count field, since they are the same.
-        str += mod_util.format(' %s %d\n',
-                this.counters[counter].metricVec.metrics[infHash].value,
-                this.counters[counter].metricVec.metrics[infHash].timestamp);
+        str += mod_util.format(' %d\n',
+                this.counters[counter].metricVec.metrics[infHash].value);
 
         // Read the _sum Gauge.
         str += mod_util.format('%s_sum{%s}', this.name, labelStr);
-        str += mod_util.format(' %d %d\n', this.gauge.labels(labelObj).value,
-            this.gauge.labels(labelObj).timestamp);
+        str += mod_util.format(' %d\n', this.gauge.labels(labelObj).value);
     }
 
     cb(null, str);
diff --git a/lib/metric.js b/lib/metric.js
index 051b928..522e88a 100644
--- a/lib/metric.js
+++ b/lib/metric.js
@@ -22,6 +22,7 @@ function Metric(options) {
     mod_assert.optionalObject(options, 'options');
     this.labels = options ? options.labels : {};
     this.value = 0;
+    // Unix time in milliseconds of when this metric was last updated.
     this.timestamp = 0;
 }
 
@@ -34,7 +35,14 @@ Metric.prototype.add = function add(num) {
     mod_assert.number(num, 'num');
 
     this.value += num;
-    this.timestamp = Date.now(); // Current unix time in milliseconds.
+    this.timestamp = Date.now();
+};
+
+Metric.prototype.set = function set(num) {
+    mod_assert.number(num, 'num');
+
+    this.value = num;
+    this.timestamp = Date.now();
 };
 
 module.exports = {
diff --git a/lib/metric_vector.js b/lib/metric_vector.js
index 0620645..70dcf68 100644
--- a/lib/metric_vector.js
+++ b/lib/metric_vector.js
@@ -149,8 +149,7 @@ MetricVector.prototype.prometheus = function prometheus(cb) {
         labelStr = labelStr.substring(0, labelStr.length - 1);
 
         // Put together the whole string.
-        str += mod_util.format('%s{%s} %d %d\n', name, labelStr, metric.value,
-            metric.timestamp);
+        str += mod_util.format('%s{%s} %d\n', name, labelStr, metric.value);
 
         labelStr = '';
     });
diff --git a/lib/utils.js b/lib/utils.js
index a95b075..495ce79 100644
--- a/lib/utils.js
+++ b/lib/utils.js
@@ -10,7 +10,7 @@ var mod_assert = require('assert-plus');
 var mod_jsprim = require('jsprim');
 var VError = require('verror').VError;
 
-var mod_md5 = require('md5');
+var mod_crypto = require('crypto');
 
 /*
  * This is a similar regex to the one used in the golang prometheus client lib.
@@ -43,12 +43,13 @@ function shallowClone(obj) {
 function hashObj(obj) {
     mod_assert.object(obj, 'obj');
 
+    var hash = mod_crypto.createHash('md5');
     var newObj = {};
     var keys = Object.keys(obj).sort();
     keys.forEach(function (key) {
         newObj[key] = obj[key];
     });
-    return (mod_md5(JSON.stringify(newObj)));
+    return (hash.update(JSON.stringify(newObj)).digest('hex'));
 }
 
 /*
diff --git a/package.json b/package.json
index 8500a5a..0af4aa2 100644
--- a/package.json
+++ b/package.json
@@ -1,12 +1,11 @@
 {
   "name": "artedi",
-  "version": "1.0.0",
+  "version": "1.1.0",
   "description": "a metric client library",
   "main": "lib/collector.js",
   "dependencies": {
     "assert-plus": "1.0.0",
     "jsprim": "1.4.0",
-    "md5": "2.2.1",
     "vasync": "1.6.4",
     "verror": "1.10.0"
   },
diff --git a/test/basic.test.js b/test/basic.test.js
index 5cf0bb6..d833ffe 100644
--- a/test/basic.test.js
+++ b/test/basic.test.js
@@ -161,6 +161,32 @@ mod_tape('label tests', function (t) {
     t.end();
 });
 
+mod_tape('absolute gauge tests', function (t) {
+    var collector = mod_artedi.createCollector();
+    var abs_gauge = collector.gauge({
+        name: 'my_abs_gauge',
+        help: 'abs gauge help'
+    });
+
+    abs_gauge.set(100, {});
+    t.equals(abs_gauge.metricVec.getDefault().value, 100,
+            'basic absolute gauge set value');
+
+    abs_gauge.set(0, {});
+    t.equals(abs_gauge.metricVec.getDefault().value, 0,
+            'basic absolute gauge set value to zero');
+
+    abs_gauge.set(-1000.1234, {});
+    t.equals(abs_gauge.metricVec.getDefault().value, -1000.1234,
+            'basic absolute gauge set value to negative float');
+
+    t.throws(function () {
+        abs_gauge.set('hello', {});
+    }, 'set gauge value to a string');
+
+    t.end();
+});
+
 /*
  * Test that prometheus serialization happens properly.
  * A few things to test:
@@ -186,8 +212,8 @@ mod_tape('counter serialization tests', function (t) {
             collector.collect(mod_artedi.FMT_PROM, function (err, str) {
                 t.notOk(err, 'no error for no metrics');
                 t.equals(str, expected, 'no metrics, only comments');
+                cb();
             });
-            cb();
         },
 
         function (_, cb) {
@@ -196,14 +222,13 @@ mod_tape('counter serialization tests', function (t) {
                 user: 'kkantor'
             });
 
-            resetTimestamps(counter.metricVec);
             var oneDemerit = expected +
-                'bot_demerits{trollcon="4",user="kkantor"} 1 0\n';
+                'bot_demerits{trollcon="4",user="kkantor"} 1\n';
             collector.collect(mod_artedi.FMT_PROM, function (err, str) {
                 t.notOk(err, 'no error for two labels');
                 t.equals(str, oneDemerit, 'two label increment');
+                cb();
             });
-            cb();
         },
 
         function (_, cb) {
@@ -213,16 +238,15 @@ mod_tape('counter serialization tests', function (t) {
                 trollcon: '4'
             });
 
-            resetTimestamps(counter.metricVec);
             /* BEGIN JSSTYLED */
             // eslint-disable-next-line max-len
-            var lots = expected + 'bot_demerits{trollcon="4",user="kkantor"} 1001 0\n';
+            var lots = expected + 'bot_demerits{trollcon="4",user="kkantor"} 1001\n';
             /* END JSSTYLED */
             collector.collect(mod_artedi.FMT_PROM, function (err, str) {
                 t.notOk(err, 'no error for reversed labels');
                 t.equals(str, lots, 'reversed label add');
+                cb();
             });
-            cb();
         },
 
         function (_, cb) {
@@ -235,17 +259,16 @@ mod_tape('counter serialization tests', function (t) {
             counter.increment();
             counter.increment();
 
-            resetTimestamps(counter.metricVec);
             expected = '' +
                 '# HELP test help\n' +
                 '# TYPE test ' + common.COUNTER + '\n' +
-                'test{} 3 0\n';
+                'test{} 3\n';
 
             collector.collect(mod_artedi.FMT_PROM, function (err, str) {
                 t.notOk(err, 'no error for default counter');
                 t.equals(str, expected, 'default counter');
+                cb();
             });
-            cb();
         }]
     }, function (_, result) {
         t.end();
@@ -268,8 +291,8 @@ mod_tape('histogram serialization tests', function (t) {
             collector.collect(mod_artedi.FMT_PROM, function (err, str) {
                 t.notOk(err, 'no error for no metrics');
                 t.equals(str, expected, 'no labels or data points');
+                cb();
             });
-            cb();
         },
 
         function (_, cb) {
@@ -278,25 +301,20 @@ mod_tape('histogram serialization tests', function (t) {
             });
 
             expected = expected +
-                'bot_trolololol{key="value",le="1"} 1 0\n' +
-                'bot_trolololol{key="value",le="3"} 1 0\n' +
-                'bot_trolololol{key="value",le="5"} 1 0\n' +
-                'bot_trolololol{key="value",le="7"} 1 0\n' +
-                'bot_trolololol{key="value",le="9"} 1 0\n' +
-                'bot_trolololol{le="+Inf",key="value"} 1 0\n' +
-                'bot_trolololol_count{key="value"} 1 0\n' +
-                'bot_trolololol_sum{key="value"} 1 0\n';
-
-            resetTimestamps(histogram.gauge.metricVec);
-            Object.keys(histogram.counters).forEach(function (counter) {
-                resetTimestamps(histogram.counters[counter].metricVec);
-            });
+                'bot_trolololol{key="value",le="1"} 1\n' +
+                'bot_trolololol{key="value",le="3"} 1\n' +
+                'bot_trolololol{key="value",le="5"} 1\n' +
+                'bot_trolololol{key="value",le="7"} 1\n' +
+                'bot_trolololol{key="value",le="9"} 1\n' +
+                'bot_trolololol{le="+Inf",key="value"} 1\n' +
+                'bot_trolololol_count{key="value"} 1\n' +
+                'bot_trolololol_sum{key="value"} 1\n';
 
             collector.collect(mod_artedi.FMT_PROM, function (err, str) {
                 t.notOk(err, 'no error for single label');
                 t.equals(str, expected, 'single label');
+                cb();
             });
-            cb();
         },
 
         function (_, cb) {
@@ -316,26 +334,21 @@ mod_tape('histogram serialization tests', function (t) {
             expected = '' +
                 '# HELP http_request_latency latency of requests\n' +
                 '# TYPE http_request_latency ' + common.HISTOGRAM + '\n' +
-                'http_request_latency{service="muskie",le="81"} 0 0\n' +
-                'http_request_latency{service="muskie",le="243"} 1 0\n' +
-                'http_request_latency{service="muskie",le="405"} 1 0\n' +
-                'http_request_latency{service="muskie",le="567"} 1 0\n' +
-                'http_request_latency{service="muskie",le="729"} 1 0\n' +
-                'http_request_latency{le="+Inf",service="muskie"} 1 0\n' +
-                'http_request_latency_count{service="muskie"} 1 0\n' +
-                'http_request_latency_sum{service="muskie"} 99 0\n';
-
-            resetTimestamps(histogram.gauge.metricVec);
-            Object.keys(histogram.counters).forEach(function (counter) {
-                resetTimestamps(histogram.counters[counter].metricVec);
-            });
+                'http_request_latency{service="muskie",le="81"} 0\n' +
+                'http_request_latency{service="muskie",le="243"} 1\n' +
+                'http_request_latency{service="muskie",le="405"} 1\n' +
+                'http_request_latency{service="muskie",le="567"} 1\n' +
+                'http_request_latency{service="muskie",le="729"} 1\n' +
+                'http_request_latency{le="+Inf",service="muskie"} 1\n' +
+                'http_request_latency_count{service="muskie"} 1\n' +
+                'http_request_latency_sum{service="muskie"} 99\n';
 
             collector.collect(mod_artedi.FMT_PROM, function (err, str) {
                 t.notOk(err, 'no error for collector labels');
                 t.equals(str, expected, 'Collector labels and no Histogram' +
                     ' labels');
+                cb();
             });
-            cb();
         },
 
         function (_, cb) {
@@ -361,29 +374,23 @@ mod_tape('histogram serialization tests', function (t) {
             expected = '' +
             '# HELP web_conn_alive_time connection alive time\n' +
             '# TYPE web_conn_alive_time ' + common.HISTOGRAM + '\n' +
-            'web_conn_alive_time{service="muskie",component="qball",le="81"} 0 0\n' +
-            'web_conn_alive_time{service="muskie",component="qball",le="243"} 1 0\n' +
-            'web_conn_alive_time{service="muskie",component="qball",le="405"} 1 0\n' +
-            'web_conn_alive_time{service="muskie",component="qball",le="567"} 1 0\n' +
-            'web_conn_alive_time{service="muskie",component="qball",le="729"} 1 0\n' +
-            'web_conn_alive_time{le="+Inf",service="muskie",component="qball"} 1 0\n' +
-            'web_conn_alive_time_count{service="muskie",component="qball"} 1 0\n' +
-            'web_conn_alive_time_sum{service="muskie",component="qball"} 101 0\n';
+            'web_conn_alive_time{service="muskie",component="qball",le="81"} 0\n' +
+            'web_conn_alive_time{service="muskie",component="qball",le="243"} 1\n' +
+            'web_conn_alive_time{service="muskie",component="qball",le="405"} 1\n' +
+            'web_conn_alive_time{service="muskie",component="qball",le="567"} 1\n' +
+            'web_conn_alive_time{service="muskie",component="qball",le="729"} 1\n' +
+            'web_conn_alive_time{le="+Inf",service="muskie",component="qball"} 1\n' +
+            'web_conn_alive_time_count{service="muskie",component="qball"} 1\n' +
+            'web_conn_alive_time_sum{service="muskie",component="qball"} 101\n';
             /* eslint-enable */
             /* END JSSTYLED */
 
-            resetTimestamps(histogram.gauge.metricVec);
-            Object.keys(histogram.counters).forEach(function (counter) {
-                resetTimestamps(histogram.counters[counter].metricVec);
-            });
             collector.collect(mod_artedi.FMT_PROM, function (err, str) {
                 t.notOk(err, 'no error for inherited labels');
                 t.equals(str, expected, 'inherited Histogram and Collector' +
                     ' labels');
+                cb();
             });
-
-
-            cb();
         },
 
         function (_, cb) {
@@ -413,27 +420,23 @@ mod_tape('histogram serialization tests', function (t) {
             var expected4 = '' +
             '# HELP webapi_conn_alive_time connection alive time\n' +
             '# TYPE webapi_conn_alive_time ' + common.HISTOGRAM + '\n' +
-            'webapi_conn_alive_time{err="ECONNRESET",service="muskie",component="cueball",le="81"} 0 0\n' +
-            'webapi_conn_alive_time{err="ECONNRESET",service="muskie",component="cueball",le="243"} 1 0\n' +
-            'webapi_conn_alive_time{err="ECONNRESET",service="muskie",component="cueball",le="405"} 1 0\n' +
-            'webapi_conn_alive_time{err="ECONNRESET",service="muskie",component="cueball",le="567"} 1 0\n' +
-            'webapi_conn_alive_time{err="ECONNRESET",service="muskie",component="cueball",le="729"} 1 0\n' +
-            'webapi_conn_alive_time{le="+Inf",err="ECONNRESET",service="muskie",component="cueball"} 1 0\n' +
-            'webapi_conn_alive_time_count{err="ECONNRESET",service="muskie",component="cueball"} 1 0\n' +
-            'webapi_conn_alive_time_sum{err="ECONNRESET",service="muskie",component="cueball"} 101 0\n';
+            'webapi_conn_alive_time{err="ECONNRESET",service="muskie",component="cueball",le="81"} 0\n' +
+            'webapi_conn_alive_time{err="ECONNRESET",service="muskie",component="cueball",le="243"} 1\n' +
+            'webapi_conn_alive_time{err="ECONNRESET",service="muskie",component="cueball",le="405"} 1\n' +
+            'webapi_conn_alive_time{err="ECONNRESET",service="muskie",component="cueball",le="567"} 1\n' +
+            'webapi_conn_alive_time{err="ECONNRESET",service="muskie",component="cueball",le="729"} 1\n' +
+            'webapi_conn_alive_time{le="+Inf",err="ECONNRESET",service="muskie",component="cueball"} 1\n' +
+            'webapi_conn_alive_time_count{err="ECONNRESET",service="muskie",component="cueball"} 1\n' +
+            'webapi_conn_alive_time_sum{err="ECONNRESET",service="muskie",component="cueball"} 101\n';
             /* eslint-enable */
             /* END JSSTYLED */
 
-            resetTimestamps(histogram.gauge.metricVec);
-            Object.keys(histogram.counters).forEach(function (counter) {
-                resetTimestamps(histogram.counters[counter].metricVec);
-            });
             collector.collect(mod_artedi.FMT_PROM, function (err, str) {
                 t.notOk(err, 'no error for dynamic and static labels');
                 t.equals(str, expected4, 'dynamic labels, and static labels' +
                     ' from Histogram and Collector');
+                cb();
             });
-            cb();
         },
 
         function (_, cb) {
@@ -445,35 +448,31 @@ mod_tape('histogram serialization tests', function (t) {
 
             histogram.observe(1);
             histogram.observe(100);
-            resetTimestamps(histogram.gauge.metricVec);
-            Object.keys(histogram.counters).forEach(function (counter) {
-                resetTimestamps(histogram.counters[counter].metricVec);
-            });
             // TODO We should have the +Inf label at the end. This works, but
             // it would look nicer.
             expected = '' +
                 '# HELP test_test1 testhelp\n' +
                 '# TYPE test_test1 ' + common.HISTOGRAM + '\n' +
-                'test_test1{le="1"} 1 0\n' +
-                'test_test1{le="3"} 1 0\n' +
-                'test_test1{le="5"} 1 0\n' +
-                'test_test1{le="7"} 1 0\n' +
-                'test_test1{le="9"} 1 0\n' +
-                'test_test1{le="+Inf"} 2 0\n' +
-                'test_test1{le="81"} 1 0\n' +
-                'test_test1{le="243"} 2 0\n' +
-                'test_test1{le="405"} 2 0\n' +
-                'test_test1{le="567"} 2 0\n' +
-                'test_test1{le="729"} 2 0\n' +
-                'test_test1_count{} 2 0\n' +
-                'test_test1_sum{} 101 0\n';
+                'test_test1{le="1"} 1\n' +
+                'test_test1{le="3"} 1\n' +
+                'test_test1{le="5"} 1\n' +
+                'test_test1{le="7"} 1\n' +
+                'test_test1{le="9"} 1\n' +
+                'test_test1{le="+Inf"} 2\n' +
+                'test_test1{le="81"} 1\n' +
+                'test_test1{le="243"} 2\n' +
+                'test_test1{le="405"} 2\n' +
+                'test_test1{le="567"} 2\n' +
+                'test_test1{le="729"} 2\n' +
+                'test_test1_count{} 2\n' +
+                'test_test1_sum{} 101\n';
             collector.collect(mod_artedi.FMT_PROM, function (err, str) {
                 t.notOk(err, 'no error for copying bucket values');
                 t.equals(str, expected, 'initial values copied from ' +
                     'low-order buckets to high-order buckets');
+                cb();
             });
 
-            cb();
         }]
     }, function (_, result) {
         t.end();
@@ -529,8 +528,34 @@ mod_tape('odd value tests', function (t) {
     t.end();
 });
 
-function resetTimestamps(metricVec) {
-    Object.keys(metricVec.metrics).forEach(function (metric) {
-        metricVec.metrics[metric].timestamp = 0;
+/*
+ * Test basic functionality for triggers.
+ *
+ * This test primarily checks if a trigger function gets called.
+ *
+ * The previous tests will have already tested if metric serialization works
+ * _without_ having specified any triggers.
+ */
+mod_tape('basic trigger tests', function (t) {
+    var collector = mod_artedi.createCollector();
+    collector.counter({
+        name: 'test_counter',
+        help: 'test help'
+    });
+    var called = false;
+
+    collector.addTriggerFunction(function triggerTest(coll, cb) {
+        t.ok(coll, 'collector object present');
+        var my_counter = coll.getCollector('test_counter');
+        t.ok(my_counter, 'collector object correct');
+        t.equals(my_counter.name, 'test_counter', 'counter object is valid');
+        called = true;
+        cb();
+    });
+
+    collector.collect(mod_artedi.FMT_PROM, function (err, _) {
+        t.notOk(err, 'no error from triggered metrics');
+        t.ok(called, 'trigger function called');
+        t.end();
     });
-}
+});
-- 
2.21.0

