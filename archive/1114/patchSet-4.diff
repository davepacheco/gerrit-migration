From 3a63412a8aeeb4c163e60def3e64ceb1435af289 Mon Sep 17 00:00:00 2001
From: Orlando Vazquez <ovazquez@gmail.com>
Date: Wed, 4 Jan 2017 14:03:51 -0800
Subject: [PATCH] CNAPI-683 CNAPI should log waitlist requests

---
 lib/models/waitlist.js | 48 +++++++++++++++++++++++++++++++++---------
 1 file changed, 38 insertions(+), 10 deletions(-)

diff --git a/lib/models/waitlist.js b/lib/models/waitlist.js
index be13ae9..21c0581 100644
--- a/lib/models/waitlist.js
+++ b/lib/models/waitlist.js
@@ -187,6 +187,14 @@ WaitlistDirector.prototype.onUpdate = function (timestamp, tickets) {
                 delete self.callbacks[ticket.uuid];
                 fecb();
                 return;
+            } else if (
+                ticket.status === 'active' &&
+                !self.callbacks[ticket.uuid])
+            {
+                self.log.info(
+                    { ticket: ticket },
+                    'onUpdate: ticket %s active but no callbacks found',
+                    ticket.uuid);
             } else {
                 self.log.info(
                     { ticket: ticket }, 'nothing to do for ticket %s onUpdate',
@@ -207,6 +215,8 @@ WaitlistDirector.prototype.onUpdate = function (timestamp, tickets) {
 WaitlistDirector.prototype.waitForTicketByUuid = function (uuid, callback) {
     var self = this;
 
+    self.log.info('waitForTicketByUuid: ticket %s', uuid);
+
     ModelWaitlist.getTicket(uuid, function (error, t) {
         if (error) {
             callback(new VError('fetching ticket %s', uuid));
@@ -602,7 +612,6 @@ ModelWaitlist.prototype.ensureServerQueue = function (callback) {
     var serverqueue = null;
     var etag = null;
     var moray = ModelWaitlist.getMoray();
-    var attempts = 0;
 
     vasync.waterfall([
         function (wfcb) {
@@ -640,11 +649,10 @@ ModelWaitlist.prototype.ensureServerQueue = function (callback) {
                        (VError.hasCauseWithName(err, 'EtagConflictError') ||
                        (VError.hasCauseWithName(err, 'UniqueAttributeError'))))
                     {
-                        attempts++;
                         self.log.warn({ err: err },
-                            'waitlist collision on queue ' +
-                            'initialization after %s attempts, retrying',
-                            attempts);
+                            'waitlist collision on queue initialization, ' +
+                            'retrying');
+
                         process.nextTick(function () {
                             self.ensureServerQueue(wfcb);
                         });
@@ -895,15 +903,19 @@ function (ticket, serverqueue, etag, callback) {
     }
 
     ticket.status = 'finished';
-    ticket.updated_at = (new Date()).toISOString();
-    ticket.updated_at =
-    serverqueue.updated_at =
-        (new Date()).toISOString();
+    ticket.updated_at = serverqueue.updated_at = (new Date()).toISOString();
 
     var queue = serverqueue.tickets[key];
     var ticketIdx = queue.indexOf(ticket.uuid);
 
-    // This is the payload we will submit to moray.batch
+    /**
+     * Craft the payload we will submit to moray.batch()
+     *
+     * This includes:
+     *   - modifying the metadata on the finished ticket
+     *   - remove finished ticket from the queue it's in
+     *   - modifying the metadata on the next ticket in the queue
+     */
     var data = [
         {
             bucket: buckets.waitlist_tickets.name,
@@ -971,6 +983,11 @@ function (ticket, serverqueue, etag, callback) {
             self.log.info({ batch: data },
                           'doing batch write after finishing %s', ticket.uuid);
             moray.batch(data, function (err, meta) {
+                if (err) {
+                    self.log.warn({ err: err },
+                        'batch error after finishing %s', ticket.uuid);
+                }
+
                 if (err &&
                    (VError.hasCauseWithName(err, 'EtagConflictError') ||
                    (VError.hasCauseWithName(err, 'UniqueAttributeError'))))
@@ -978,9 +995,17 @@ function (ticket, serverqueue, etag, callback) {
                     process.nextTick(function () {
                         self.ensureServerQueue(function (err2, resp) {
                             if (err2) {
+                                self.log.info(
+                                    { err: err2 },
+                                    'ensureServerQueue error %s', ticket.uuid);
                                 wfcb(err2);
                                 return;
                             }
+                            self.log.info(
+                                { err: err },
+                                'retrying ' +
+                                'self.finishTicketUpdateQueueActivateNext %s',
+                                ticket.uuid);
                             self.finishTicketUpdateQueueActivateNext(
                                 ticket,
                                 resp.serverqueue,
@@ -995,6 +1020,9 @@ function (ticket, serverqueue, etag, callback) {
         }
     ],
     function (wferr) {
+        self.log.info(
+            { err: wferr }, 'error self.finishTicketUpdateQueueActivateNext %s',
+            ticket.uuid);
         callback(wferr);
     });
 };
-- 
2.21.0

