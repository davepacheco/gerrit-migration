From 850f91da8079df9dbeac82f12e4e1889e264c2e0 Mon Sep 17 00:00:00 2001
From: Robert Mustacchi <rm@joyent.com>
Date: Sat, 1 Jul 2017 05:38:06 +0000
Subject: [PATCH] snapshot ccid driver

---
 manifest                                      |    8 +
 usr/src/cmd/Makefile                          |    1 +
 usr/src/cmd/ccidadm/Makefile                  |   55 +
 usr/src/cmd/ccidadm/ccidadm.c                 |  864 +++
 usr/src/cmd/devfsadm/cfg_link.c               |   28 +
 usr/src/cmd/devfsadm/cfg_link.h               |    1 +
 usr/src/cmd/devfsadm/usb_link.c               |   33 +-
 usr/src/cmd/mdb/common/modules/usba/prtusb.c  |   31 +
 usr/src/common/ccid/atr.c                     | 1602 +++++
 usr/src/common/ccid/atr.h                     |  197 +
 usr/src/common/ccid/ccid_t1.c                 |  928 +++
 usr/src/common/ccid/ccid_t1.h                 |  286 +
 usr/src/lib/Makefile                          |    2 +
 usr/src/lib/cfgadm_plugins/Makefile           |    2 +-
 usr/src/lib/cfgadm_plugins/ccid/Makefile      |   67 +
 usr/src/lib/cfgadm_plugins/ccid/Makefile.com  |   70 +
 .../lib/cfgadm_plugins/ccid/amd64/Makefile    |   21 +
 .../cfgadm_plugins/ccid/common/cfga_ccid.c    |  412 ++
 .../cfgadm_plugins/ccid/common/mapfile-vers   |   42 +
 usr/src/lib/cfgadm_plugins/ccid/i386/Makefile |   20 +
 .../lib/cfgadm_plugins/ccid/sparc/Makefile    |   20 +
 .../lib/cfgadm_plugins/ccid/sparcv9/Makefile  |   21 +
 usr/src/lib/libcmdutils/common/nicenum.c      |   19 +-
 usr/src/lib/libcmdutils/libcmdutils.h         |    1 +
 usr/src/lib/libpcsc/Makefile                  |   44 +
 usr/src/lib/libpcsc/Makefile.com              |   34 +
 usr/src/lib/libpcsc/amd64/Makefile            |   19 +
 usr/src/lib/libpcsc/common/libpcsc.c          |  639 ++
 usr/src/lib/libpcsc/common/llib-lpcsc         |   20 +
 usr/src/lib/libpcsc/common/mapfile-vers       |   50 +
 usr/src/lib/libpcsc/common/winscard.h         |  139 +
 usr/src/lib/libpcsc/common/wintypes.h         |   50 +
 usr/src/lib/libpcsc/i386/Makefile             |   18 +
 usr/src/man/man7d/Makefile                    |    1 +
 usr/src/man/man7d/ccid.7d                     |  517 ++
 usr/src/man/man7i/uccid.7i                    |  470 ++
 usr/src/test/os-tests/tests/uccid/Makefile    |   90 +
 usr/src/test/os-tests/tests/uccid/atrparse.c  |  731 +++
 .../test/os-tests/tests/uccid/excl-badread.c  |   80 +
 .../test/os-tests/tests/uccid/excl-basic.c    |   65 +
 .../test/os-tests/tests/uccid/excl-close.c    |   81 +
 usr/src/test/os-tests/tests/uccid/excl-loop.c |   84 +
 .../test/os-tests/tests/uccid/excl-nonblock.c |   99 +
 .../test/os-tests/tests/uccid/excl-reset.c    |   65 +
 .../test/os-tests/tests/uccid/notxn-poll.c    |   57 +
 usr/src/test/os-tests/tests/uccid/pollin.c    |   64 +
 usr/src/test/os-tests/tests/uccid/pollout.c   |   68 +
 usr/src/test/os-tests/tests/uccid/status.c    |   97 +
 .../test/os-tests/tests/uccid/txn-pollerr.c   |   88 +
 usr/src/test/os-tests/tests/uccid/yk.c        |   78 +
 usr/src/uts/common/Makefile.files             |    2 +
 usr/src/uts/common/Makefile.rules             |    8 +
 usr/src/uts/common/io/usb/clients/ccid/ccid.c | 5180 +++++++++++++++++
 usr/src/uts/common/sys/Makefile               |    7 +
 usr/src/uts/common/sys/Makefile.syshdrs       |    5 +
 usr/src/uts/common/sys/sunddi.h               |    2 +
 .../uts/common/sys/usb/clients/ccid/ccid.h    |  315 +
 .../uts/common/sys/usb/clients/ccid/uccid.h   |  134 +
 usr/src/uts/intel/ccid/Makefile               |   56 +
 59 files changed, 14182 insertions(+), 6 deletions(-)
 create mode 100644 usr/src/cmd/ccidadm/Makefile
 create mode 100644 usr/src/cmd/ccidadm/ccidadm.c
 create mode 100644 usr/src/common/ccid/atr.c
 create mode 100644 usr/src/common/ccid/atr.h
 create mode 100644 usr/src/common/ccid/ccid_t1.c
 create mode 100644 usr/src/common/ccid/ccid_t1.h
 create mode 100644 usr/src/lib/cfgadm_plugins/ccid/Makefile
 create mode 100644 usr/src/lib/cfgadm_plugins/ccid/Makefile.com
 create mode 100644 usr/src/lib/cfgadm_plugins/ccid/amd64/Makefile
 create mode 100644 usr/src/lib/cfgadm_plugins/ccid/common/cfga_ccid.c
 create mode 100644 usr/src/lib/cfgadm_plugins/ccid/common/mapfile-vers
 create mode 100644 usr/src/lib/cfgadm_plugins/ccid/i386/Makefile
 create mode 100644 usr/src/lib/cfgadm_plugins/ccid/sparc/Makefile
 create mode 100644 usr/src/lib/cfgadm_plugins/ccid/sparcv9/Makefile
 create mode 100644 usr/src/lib/libpcsc/Makefile
 create mode 100644 usr/src/lib/libpcsc/Makefile.com
 create mode 100644 usr/src/lib/libpcsc/amd64/Makefile
 create mode 100644 usr/src/lib/libpcsc/common/libpcsc.c
 create mode 100644 usr/src/lib/libpcsc/common/llib-lpcsc
 create mode 100644 usr/src/lib/libpcsc/common/mapfile-vers
 create mode 100644 usr/src/lib/libpcsc/common/winscard.h
 create mode 100644 usr/src/lib/libpcsc/common/wintypes.h
 create mode 100644 usr/src/lib/libpcsc/i386/Makefile
 create mode 100644 usr/src/man/man7d/ccid.7d
 create mode 100644 usr/src/man/man7i/uccid.7i
 create mode 100644 usr/src/test/os-tests/tests/uccid/Makefile
 create mode 100644 usr/src/test/os-tests/tests/uccid/atrparse.c
 create mode 100644 usr/src/test/os-tests/tests/uccid/excl-badread.c
 create mode 100644 usr/src/test/os-tests/tests/uccid/excl-basic.c
 create mode 100644 usr/src/test/os-tests/tests/uccid/excl-close.c
 create mode 100644 usr/src/test/os-tests/tests/uccid/excl-loop.c
 create mode 100644 usr/src/test/os-tests/tests/uccid/excl-nonblock.c
 create mode 100644 usr/src/test/os-tests/tests/uccid/excl-reset.c
 create mode 100644 usr/src/test/os-tests/tests/uccid/notxn-poll.c
 create mode 100644 usr/src/test/os-tests/tests/uccid/pollin.c
 create mode 100644 usr/src/test/os-tests/tests/uccid/pollout.c
 create mode 100644 usr/src/test/os-tests/tests/uccid/status.c
 create mode 100644 usr/src/test/os-tests/tests/uccid/txn-pollerr.c
 create mode 100644 usr/src/test/os-tests/tests/uccid/yk.c
 create mode 100644 usr/src/uts/common/io/usb/clients/ccid/ccid.c
 create mode 100644 usr/src/uts/common/sys/usb/clients/ccid/ccid.h
 create mode 100644 usr/src/uts/common/sys/usb/clients/ccid/uccid.h
 create mode 100644 usr/src/uts/intel/ccid/Makefile

diff --git a/manifest b/manifest
index 0be23336c1..788007eaf6 100644
--- a/manifest
+++ b/manifest
@@ -5272,6 +5272,7 @@ s usr/lib/amd64/libpam.so=../../../lib/amd64/libpam.so.1
 f usr/lib/amd64/libpanel.so.1 0755 root bin
 s usr/lib/amd64/libpanel.so=libpanel.so.1
 f usr/lib/amd64/libpcidb.so.1 0755 root bin
+f usr/lib/amd64/libpcsc.so.1 0755 root bin
 f usr/lib/amd64/libpctx.so.1 0755 root bin
 s usr/lib/amd64/libpctx.so=libpctx.so.1
 f usr/lib/amd64/libpicl.so.1 0755 root bin
@@ -5541,8 +5542,12 @@ f usr/lib/brand/shared/common.ksh 0444 root bin
 f usr/lib/brand/shared/query 0755 root bin
 f usr/lib/brand/shared/uninstall.ksh 0444 root bin
 f usr/lib/bridged 0555 root bin
+d usr/lib/ccid 0755 root bin
+f usr/lib/ccid/ccidadm 0555 root bin
 d usr/lib/cfgadm 0755 root bin
 d usr/lib/cfgadm/amd64 0755 root bin
+f usr/lib/cfgadm/amd64/ccid.so.1 0755 root bin
+s usr/lib/cfgadm/amd64/ccid.so=ccid.so.1
 f usr/lib/cfgadm/amd64/fp.so.1 0755 root bin
 s usr/lib/cfgadm/amd64/fp.so=fp.so.1
 f usr/lib/cfgadm/amd64/ib.so.1 0755 root bin
@@ -5557,6 +5562,8 @@ f usr/lib/cfgadm/amd64/shp.so.1 0755 root bin
 s usr/lib/cfgadm/amd64/shp.so=shp.so.1
 f usr/lib/cfgadm/amd64/usb.so.1 0755 root bin
 s usr/lib/cfgadm/amd64/usb.so=usb.so.1
+f usr/lib/cfgadm/ccid.so.1 0755 root bin
+s usr/lib/cfgadm/ccid.so=ccid.so.1
 f usr/lib/cfgadm/fp.so.1 0755 root bin
 s usr/lib/cfgadm/fp.so=fp.so.1
 f usr/lib/cfgadm/ib.so.1 0755 root bin
@@ -6777,6 +6784,7 @@ s usr/lib/libpam.so=../../lib/libpam.so.1
 f usr/lib/libpanel.so.1 0755 root bin
 s usr/lib/libpanel.so=libpanel.so.1
 f usr/lib/libpcidb.so.1 0755 root bin
+f usr/lib/libpcsc.so.1 0755 root bin
 f usr/lib/libpctx.so.1 0755 root bin
 s usr/lib/libpctx.so=libpctx.so.1
 f usr/lib/libpicl.so.1 0755 root bin
diff --git a/usr/src/cmd/Makefile b/usr/src/cmd/Makefile
index fdbb25c9a0..ff2705beb4 100644
--- a/usr/src/cmd/Makefile
+++ b/usr/src/cmd/Makefile
@@ -83,6 +83,7 @@ COMMON_SUBDIRS=		\
 	cal		\
 	captoinfo	\
 	cat		\
+	ccidadm		\
 	cdrw		\
 	cfgadm		\
 	checkeq		\
diff --git a/usr/src/cmd/ccidadm/Makefile b/usr/src/cmd/ccidadm/Makefile
new file mode 100644
index 0000000000..c32282fa65
--- /dev/null
+++ b/usr/src/cmd/ccidadm/Makefile
@@ -0,0 +1,55 @@
+#
+# This file and its contents are supplied under the terms of the
+# Common Development and Distribution License ("CDDL"), version 1.0.
+# You may only use this file in accordance with the terms of version
+# 1.0 of the CDDL.
+#
+# A full copy of the text of the CDDL should have accompanied this
+# source.  A copy of the CDDL is also available via the Internet at
+# http://www.illumos.org/license/CDDL.
+#
+
+#
+# Copyright (c) 2017, Joyent, Inc.
+#
+
+PROG= ccidadm
+
+include ../Makefile.cmd
+include ../Makefile.ctf
+
+ROOTCMDDIR = $(ROOTLIB)/ccid
+CFLAGS += $(CCVERBOSE)
+LDLIBS += -lofmt -lcmdutils
+SRCS = ccidadm.c atr.c
+OBJS = $(SRCS:%.c=%.o)
+LNSRCS = ccidadm.c $(SRC)/common/ccid/atr.c
+CPPFLAGS += -I$(SRC)/common/ccid
+
+ROOTCCIDFILES = $(PROG:%=$(ROOTCMDDIR)/%)
+
+.KEEP_STATE:
+
+$(PROG): $(OBJS)
+	$(LINK.c) -o $@ $(OBJS) $(LDLIBS)
+	$(POST_PROCESS)
+
+%.o: %.c
+	$(COMPILE.c) $<
+	$(POST_PROCESS_O)
+
+%.o: $(SRC)/common/ccid/%.c
+	$(COMPILE.c) $<
+	$(POST_PROCESS_O)
+
+all: $(PROG)
+
+install: all $(ROOTCMD)
+
+clean:
+	$(RM) $(OBJS)
+
+lint:	$$(LNSRCS)
+	$(LINT.c) $(LNSRCS) $(LDLIBS)
+
+include ../Makefile.targ
diff --git a/usr/src/cmd/ccidadm/ccidadm.c b/usr/src/cmd/ccidadm/ccidadm.c
new file mode 100644
index 0000000000..9357008877
--- /dev/null
+++ b/usr/src/cmd/ccidadm/ccidadm.c
@@ -0,0 +1,864 @@
+/*
+ * This file and its contents are supplied under the terms of the
+ * Common Development and Distribution License ("CDDL"), version 1.0.
+ * You may only use this file in accordance with the terms of version
+ * 1.0 of the CDDL.
+ *
+ * A full copy of the text of the CDDL should have accompanied this
+ * source.  A copy of the CDDL is also available via the Internet at
+ * http://www.illumos.org/license/CDDL.
+ */
+
+/*
+ * Copyright (c) 2017, Joyent, Inc. 
+ */
+
+/*
+ * Print out information about a CCID device.
+ */
+
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <err.h>
+#include <stdlib.h>
+#include <strings.h>
+#include <unistd.h>
+#include <ofmt.h>
+#include <libgen.h>
+#include <ctype.h>
+#include <errno.h>
+#include <limits.h>
+#include <libcmdutils.h>
+#include <fts.h>
+
+#include <sys/usb/clients/ccid/uccid.h>
+#include <atr.h>
+
+#define	EXIT_USAGE	2
+
+static const char *ccidadm_pname;
+
+#define	CCID_ROOT	"/dev/ccid/"
+
+typedef enum {
+	CCIDADM_LIST_DEVICE,
+	CCIDADM_LIST_PRODUCT,
+	CCIDADM_LIST_STATE,
+	CCIDADM_LIST_TRANSPORT
+} ccidadm_list_index_t;
+
+typedef struct ccidadm_pair {
+	uint32_t	ccp_val;
+	const char	*ccp_name;
+} ccidadm_pair_t;
+
+typedef struct ccid_list_ofmt_arg {
+	const char		*cloa_name;
+	uccid_cmd_status_t	*cloa_status;
+} ccid_list_ofmt_arg_t;
+
+/*
+ * Attempt to open a CCID slot specified by a user. In general, we exepect that
+ * users will use a path like "ccid0/slot0". However, they may also specify a
+ * full path. If the card boolean is set to true, that means that they may have
+ * just specified "ccid0", so we need to try to open up the default slot.
+ */
+static int
+ccidadm_open(const char *base, boolean_t card)
+{
+	int fd;
+	char buf[PATH_MAX];
+
+	/*
+	 * For an absolute path, just try the base path. If it doesn't match our
+	 * prefix, simulate ENOENT.
+	 */
+	if (strncmp(base, CCID_ROOT, strlen(CCID_ROOT)) == 0) {
+		return (open(base, O_RDWR));
+	} else if (base[0] == '/') {
+		errno = ENOENT;
+		return (-1);
+	}
+
+	/*
+	 * For a card, try to append slot0 first.
+	 */
+	if (card) {
+		if (snprintf(buf, sizeof (buf), "%s/%s/slot0", CCID_ROOT,
+		    base) >= sizeof (buf)) {
+			errno = ENAMETOOLONG;
+			return (-1);
+		}
+
+		if ((fd = open(buf, O_RDWR)) >= 0) {
+			return (fd);
+		}
+
+		if (errno != ENOENT && errno != ENOTDIR) {
+			return (fd);
+		}
+	}
+
+	if (snprintf(buf, sizeof (buf), "%s/%s", CCID_ROOT, base) >= sizeof (buf)) {
+		errno = ENAMETOOLONG;
+		return (-1);
+	}
+
+	return (open(buf, O_RDWR));
+}
+
+static void
+ccidadm_iter(boolean_t readeronly, boolean_t newline,
+    void(*cb)(int, const char *, void *), void *arg)
+{
+	FTS *fts;
+	FTSENT *ent;
+	char *const paths[] = { CCID_ROOT, NULL };
+	int fd;
+	boolean_t first = B_TRUE;
+
+	fts = fts_open(paths, FTS_LOGICAL | FTS_NOCHDIR, NULL);
+	if (fts == NULL) {
+		err(EXIT_FAILURE, "failed to create directory stream");
+	}
+
+	while ((ent = fts_read(fts)) != NULL) {
+		const char *name;
+
+		/* Skip the root and post-order dirs */
+		if (ent->fts_level == 0 || ent->fts_info == FTS_DP) {
+			continue;
+		}
+		if (readeronly && ent->fts_level != 1) {
+			continue;
+		} else if (!readeronly && ent->fts_level != 2) {
+			continue;
+		}
+
+		if (ent->fts_info == FTS_ERR || ent->fts_info == FTS_NS) {
+			warn("skipping %s, failed to get information: %s", ent->fts_name,
+			    strerror(ent->fts_errno));
+			continue;
+		}
+
+		name = ent->fts_path + strlen(CCID_ROOT);
+		if ((fd = ccidadm_open(name, readeronly)) < 0) {
+			err(EXIT_FAILURE, "failed to open %s", name);
+		}
+
+		if (!first && newline) {
+			(void) printf("\n");
+		}
+		first = B_FALSE;
+		cb(fd, name, arg);
+		(void) close(fd);
+	}
+
+	(void) fts_close(fts);
+}
+
+static void
+ccidadm_list_slot_status_str(uccid_cmd_status_t *ucs, char *buf, uint_t buflen)
+{
+	if (!(ucs->ucs_status & UCCID_STATUS_F_CARD_PRESENT)) {
+		(void) snprintf(buf, buflen, "missing");
+		return;
+	}
+
+	if (ucs->ucs_status & UCCID_STATUS_F_CARD_ACTIVE) {
+		(void) snprintf(buf, buflen, "activated");
+		return;
+	}
+
+	(void) snprintf(buf, buflen, "unactivated");
+}
+
+static boolean_t
+ccidadm_list_slot_transport_str(uccid_cmd_status_t *ucs, char *buf, uint_t buflen)
+{
+	const char *prot;
+	const char *tran;
+	uint_t bits = CCID_CLASS_F_TPDU_XCHG | CCID_CLASS_F_SHORT_APDU_XCHG |
+	    CCID_CLASS_F_EXT_APDU_XCHG;
+
+	switch (ucs->ucs_class.ccd_dwFeatures & bits) {
+	case 0:
+		tran = "Character";
+		break;
+	case CCID_CLASS_F_TPDU_XCHG:
+		tran = "TPDU";
+		break;
+	case CCID_CLASS_F_SHORT_APDU_XCHG:
+	case CCID_CLASS_F_EXT_APDU_XCHG:
+		tran = "APDU";
+		break;
+	default:
+		tran = "Unknown";
+		break;
+	}
+
+	if ((ucs->ucs_status & UCCID_STATUS_F_PARAMS_VALID) != 0) {
+		switch (ucs->ucs_prot) {
+		case UCCID_PROT_T0:
+			prot = " (T=0)";
+			break;
+		case UCCID_PROT_T1:
+			prot = " (T=1)";
+			break;
+		default:
+			prot = "";
+			break;
+		}
+	} else {
+		prot = "";
+	}
+
+	return (snprintf(buf, buflen, "%s%s", tran, prot) < buflen);
+}
+
+static boolean_t
+ccidadm_list_ofmt_cb(ofmt_arg_t *ofmt, char *buf, uint_t buflen)
+{
+	ccid_list_ofmt_arg_t *cloa = ofmt->ofmt_cbarg;
+
+	switch (ofmt->ofmt_id) {
+	case CCIDADM_LIST_DEVICE:
+		if (snprintf(buf, buflen, "%s", cloa->cloa_name) >= buflen) {
+			return (B_FALSE);
+		}
+		break;
+	case CCIDADM_LIST_PRODUCT:
+		if (snprintf(buf, buflen, "%s", cloa->cloa_status->ucs_product) >=
+		    buflen) {
+			return (B_FALSE);
+		}
+		break;
+	case CCIDADM_LIST_STATE:
+		ccidadm_list_slot_status_str(cloa->cloa_status, buf, buflen);
+		break;
+	case CCIDADM_LIST_TRANSPORT:
+		return (ccidadm_list_slot_transport_str(cloa->cloa_status, buf,
+		    buflen));
+		break;
+	default:
+		return (B_FALSE);
+	}
+
+	return (B_TRUE);
+}
+
+static void
+ccidadm_list_slot(int slotfd, const char *name, void *arg)
+{
+	uccid_cmd_status_t ucs;
+	ofmt_handle_t ofmt = arg;
+	ccid_list_ofmt_arg_t cloa;
+
+	bzero(&ucs, sizeof (ucs));
+	ucs.ucs_version = UCCID_CURRENT_VERSION;
+
+	if (ioctl(slotfd, UCCID_CMD_STATUS, &ucs) != 0) {
+		err(EXIT_FAILURE, "failed to issue status ioctl to %s", name);
+	}
+
+	if ((ucs.ucs_status & UCCID_STATUS_F_PRODUCT_VALID) == 0) {
+		(void) strlcpy(ucs.ucs_product, "<unknown>",
+		    sizeof (ucs.ucs_product));
+	}
+
+	cloa.cloa_name = name;
+	cloa.cloa_status = &ucs;
+	ofmt_print(ofmt, &cloa);
+}
+
+static ofmt_field_t ccidadm_list_fields[] = {
+	{ "PRODUCT",	24,	CCIDADM_LIST_PRODUCT,	ccidadm_list_ofmt_cb },
+	{ "DEVICE",	16,	CCIDADM_LIST_DEVICE, 	ccidadm_list_ofmt_cb },
+	{ "CARD STATE",	12,	CCIDADM_LIST_STATE, 	ccidadm_list_ofmt_cb },
+	{ "TRANSPORT",  10,	CCIDADM_LIST_TRANSPORT,	ccidadm_list_ofmt_cb },
+	{ NULL,		0,	0,			NULL	}
+};
+
+/* ARGSUSED */
+static void
+ccidadm_do_list(int argc, char *argv[])
+{
+	ofmt_handle_t ofmt;
+
+	if (argc != 0) {
+		errx(EXIT_USAGE, "list command does not take arguments\n");
+	}
+
+	if (ofmt_open(NULL, ccidadm_list_fields, 0, 0, &ofmt) != OFMT_SUCCESS) {
+		errx(EXIT_FAILURE, "failed to initialize ofmt state");
+	}
+
+	ccidadm_iter(B_FALSE, B_FALSE, ccidadm_list_slot, ofmt);
+	ofmt_close(ofmt);
+}
+
+static void
+ccidadm_list_usage(FILE *out)
+{
+	(void) fprintf(out, "\tlist\n");
+}
+
+/* XXX Probably fold this back into the atr common code */
+static void
+ccidadm_atr_hexdump(const uint8_t *buf, size_t nbytes)
+{
+	size_t i;
+
+	/* Print out the header */
+	(void) printf("%*s    0", 4, "");
+	for (i = 1; i < 16; i++) {
+		if (i % 4 == 0 && i % 16 != 0) {
+			(void) printf(" ");
+		}
+
+		(void) printf("%2x", i);
+	}
+	(void) printf("  0123456789abcdef\n");
+
+	/* Print out data */
+	for (i = 0; i < nbytes; i++) {
+
+		if (i % 16 == 0) {
+			(void) printf("%04x:  ", i);
+		}
+
+		if (i % 4 == 0 && i % 16 != 0) {
+			(void) printf(" ");
+		}
+
+		(void) printf("%02x", buf[i]);
+
+		if (i % 16 == 15 || i + 1 == nbytes) {
+			int j;
+			for (j = (i % 16); j <= 16; j++) {
+				if (j % 4 == 0 && j % 16 != 0) {
+					(void) printf(" ");
+				}
+
+				(void) printf("  ");
+			}
+
+			for (j = i - (i % 16); j <= i; j++) {
+				if (!isprint(buf[j])) {
+					(void) printf(".");
+				} else {
+					(void) printf("%c", buf[j]);
+				}
+			}
+			(void) printf("\n");
+		}
+	}
+}
+
+/*
+ * Print out logical information about the ICC's ATR. This includes information
+ * about what protocols it supports, required negotiation, etc.
+ */
+static void
+ccidadm_atr_props(uccid_cmd_status_t *ucs)
+{
+	int ret;
+	atr_data_t *data;
+	atr_protocol_t prots, defprot;
+	boolean_t negotiate;
+	atr_data_rate_choice_t rate;
+	uint32_t bps;
+
+	if ((data = atr_data_alloc()) == NULL) {
+		err(EXIT_FAILURE, "failed to allocate memory for "
+		    "ATR data");
+	}
+
+	ret = atr_parse(ucs->ucs_atr, ucs->ucs_atrlen, data);
+	if (ret != ATR_CODE_OK) {
+		errx(EXIT_FAILURE, "failed to parse ATR data: %s",
+		    atr_strerror(ret));
+	}
+
+	prots = atr_supported_protocols(data);
+	(void) printf("ICC supports protocol(s): ");
+	if (prots == ATR_P_NONE) {
+		(void) printf("none\n");
+		return;
+	}
+
+	(void) printf("%s\n", atr_protocol_to_string(prots));
+
+	negotiate = atr_params_negotiable(data);
+	defprot = atr_default_protocol(data);
+
+	if (negotiate) {
+		(void) printf("Card protocol is negotiable; starts with "
+		    "default %s parameters\n", atr_protocol_to_string(defprot));
+	} else {
+		(void) printf("Card protocol is not negotiable; starts with "
+		    "specific %s parameters\n", atr_protocol_to_string(defprot));
+	}
+
+	/*
+	 * For each supported protocol, figure out parameters we would negotiate.
+	 * We only need to warn about auto-negotiation if this is TPDU and
+	 * specific bits are missing. XXX Mask for TDPU and maybe character?
+	 */
+	if ((ucs->ucs_class.ccd_dwFeatures & (CCID_CLASS_F_AUTO_PARAM_NEG |
+	    CCID_CLASS_F_AUTO_PPS)) == 0) {
+		(void) printf("CCID/ICC require explicit TPDU parameter/PPS "
+		    "negotiation\n");
+	}
+
+	/*
+	 * Determine which set of Di/Fi values we should use and how we should
+	 * get there (note a reader may not have to set them).
+	 */
+	rate = atr_data_rate(data, &ucs->ucs_class, NULL, 0, &bps);
+	switch (rate) {
+	case ATR_RATE_USEDEFAULT:
+		(void) printf("Reader will run ICC at the default (Di=1/Fi=1) "
+		    "speed\n");
+		break;
+	case ATR_RATE_USEATR:
+		(void) printf("Reader will run ICC at ICC's Di/Fi values\n");
+		break;
+	case ATR_RATE_USEATR_SETRATE:
+		(void) printf("Reader will run ICC at ICC's Di/Fi values, but "
+		    "must set data rate to %u bps\n", bps);
+		break;
+	case ATR_RATE_UNSUPPORTED:
+		(void) printf("Reader cannot run ICC due to Di/Fi mismatch\n");
+		break;
+	default:
+		(void) printf("Cannot determine Di/Fi rate, unexpected "
+		    "value: %u\n", rate);
+		break;
+	}
+	if (prots & ATR_P_T0) {
+		uint8_t fi, di;
+		atr_convention_t conv;
+		atr_clock_stop_t clock;
+
+		fi = atr_fi_index(data);
+		di = atr_di_index(data);
+		conv = atr_convention(data);
+		clock = atr_clock_stop(data);
+		(void) printf("T=0 properties that would be negotiated:\n");
+		(void) printf("  + Fi/Fmax Index: %u (Fi %s/Fmax %s MHz)\n",
+		    fi, atr_fi_index_to_string(fi),
+		    atr_fmax_index_to_string(fi));
+		(void) printf("  + Di Index: %u (Di %s)\n", di,
+		    atr_di_index_to_string(di));
+		(void) printf("  + Clock Convention: %u (%s)\n", conv,
+		    atr_convention_to_string(conv));
+		(void) printf("  + Extra Guardtime: %u\n",
+		    atr_extra_guardtime(data));
+		(void) printf("  + WI: %u\n", atr_t0_wi(data));
+		(void) printf("  + Clock Stop: %u (%s)\n", clock,
+		    atr_clock_stop_to_string(clock));
+	}
+
+	if (prots & ATR_P_T1) {
+		uint8_t fi, di;
+		atr_clock_stop_t clock;
+		atr_t1_checksum_t cksum;
+
+		fi = atr_fi_index(data);
+		di = atr_di_index(data);
+		clock = atr_clock_stop(data);
+		cksum = atr_t1_checksum(data);
+		(void) printf("T=1 properties that would be negotiated:\n");
+		(void) printf("  + Fi/Fmax Index: %u (Fi %s/Fmax %s MHz)\n",
+		    fi, atr_fi_index_to_string(fi),
+		    atr_fmax_index_to_string(fi));
+		(void) printf("  + Di Index: %u (Di %s)\n", di,
+		    atr_di_index_to_string(di));
+		(void) printf("  + Checksum: %s\n", cksum == ATR_T1_CHECKSUM_CRC ?
+		    "CRC" : "LRC");
+		(void) printf("  + Extra Guardtime: %u\n",
+		    atr_extra_guardtime(data));
+		(void) printf("  + BWI: %u\n", atr_t1_bwi(data));
+		(void) printf("  + CWI: %u\n", atr_t1_cwi(data));
+		(void) printf("  + Clock Stop: %u (%s)\n", clock,
+		    atr_clock_stop_to_string(clock));
+		(void) printf("  + IFSC: %u\n", atr_t1_ifsc(data));
+		(void) printf("  + CCID Supports NAD: %s\n",
+		    ucs->ucs_class.ccd_dwFeatures & CCID_CLASS_F_ALTNAD_SUP ?
+		    "yes" : "no");
+	}
+
+	atr_data_free(data);
+}
+
+static void
+ccidadm_atr_verbose(uccid_cmd_status_t *ucs)
+{
+	int ret;
+	atr_data_t *data;
+
+	if ((data = atr_data_alloc()) == NULL) {
+		err(EXIT_FAILURE, "failed to allocate memory for "
+		    "ATR data");
+	}
+
+	ret = atr_parse(ucs->ucs_atr, ucs->ucs_atrlen, data);
+	if (ret != ATR_CODE_OK) {
+		errx(EXIT_FAILURE, "failed to parse ATR data: %s",
+		    atr_strerror(ret));
+	}
+	atr_data_dump(data, stdout);
+	atr_data_free(data);
+}
+
+typedef struct cciadm_atr_args {
+	boolean_t caa_hex;
+	boolean_t caa_props;
+	boolean_t caa_verbose;
+} ccidadm_atr_args_t;
+
+static void
+ccidadm_atr_fetch(int fd, const char *name, void *arg)
+{
+	uccid_cmd_status_t ucs;
+	ccidadm_atr_args_t *caa = arg;
+
+	bzero(&ucs, sizeof (ucs));
+	ucs.ucs_version = UCCID_CURRENT_VERSION;
+
+	if (ioctl(fd, UCCID_CMD_STATUS, &ucs) != 0) {
+		err(EXIT_FAILURE, "failed to issue status ioctl to %s",
+		    name);
+	}
+
+	if (ucs.ucs_atrlen == 0) {
+		warnx("slot %s has no card inserted or activated", name);
+		return;
+	}
+
+	(void) printf("ATR for %s (%u bytes)\n", name, ucs.ucs_atrlen);
+	if (caa->caa_props) {
+		ccidadm_atr_props(&ucs);
+	}
+
+	if (caa->caa_hex) {
+		ccidadm_atr_hexdump(ucs.ucs_atr, ucs.ucs_atrlen);
+	}
+
+	if (caa->caa_verbose) {
+		ccidadm_atr_verbose(&ucs);
+	}
+}
+
+static void
+ccidadm_do_atr(int argc, char *argv[])
+{
+	uint_t i;
+	int c;
+	ccidadm_atr_args_t caa;
+
+	bzero(&caa, sizeof (caa));
+	optind = 0;
+	while ((c = getopt(argc, argv, "vpx")) != -1) {
+		switch (c) {
+		case 'v':
+			caa.caa_verbose = B_TRUE;
+			break;
+		case 'p':
+			caa.caa_props = B_TRUE;
+			break;
+		case 'x':
+			caa.caa_hex = B_TRUE;
+			break;
+		case ':':
+			errx(EXIT_USAGE, "Option -%c requires an argument\n", optopt);
+			break;
+		case '?':
+			errx(EXIT_USAGE, "Unknown option: -%c\n", optopt);
+			break;
+		}
+	}
+
+	if (!caa.caa_verbose && !caa.caa_props && !caa.caa_hex) {
+		caa.caa_props = B_TRUE;
+	}
+
+	argc -= optind;
+	argv += optind;
+
+	if (argc == 0) {
+		ccidadm_iter(B_FALSE, B_TRUE, ccidadm_atr_fetch, &caa);
+	}
+
+	for (i = 0; i < argc; i++) {
+		int fd;
+
+		if ((fd = ccidadm_open(argv[i], B_FALSE)) < 0) {
+			warn("failed to open %s", argv[i]);
+			errx(EXIT_FAILURE, "valid CCID slot?");
+		}
+
+		ccidadm_atr_fetch(fd, argv[i], &caa);
+		(void) close(fd);
+		if (i + 1 < argc) {
+			(void) printf("\n");
+		}
+	}
+}
+
+static void
+ccidadm_atr_usage(FILE *out)
+{
+	(void) fprintf(out, "\tatr [-pvx]\t[device] ...\n");
+}
+
+static void
+ccidadm_print_pairs(uint32_t val, ccidadm_pair_t *ccp)
+{
+	while (ccp->ccp_name != NULL) {
+		if ((val & ccp->ccp_val) == ccp->ccp_val) {
+			(void) printf("    + %s\n", ccp->ccp_name);
+		}
+		ccp++;
+	}
+}
+
+static ccidadm_pair_t ccidadm_p_protocols[] = {
+	{ 0x01, "T=0" },
+	{ 0x02, "T=1" },
+	{ 0x0, NULL }
+};
+
+static ccidadm_pair_t ccidadm_p_voltages[] = {
+	{ CCID_CLASS_VOLT_5_0,	"5.0 V" },
+	{ CCID_CLASS_VOLT_3_0, "3.0 V" },
+	{ CCID_CLASS_VOLT_1_8, "1.8 V" },
+	{ 0x0, NULL }
+};
+
+static ccidadm_pair_t ccidadm_p_syncprots[] = {
+	{ 0x01, "2-Wire Support" },
+	{ 0x02, "3-Wire Support" },
+	{ 0x04, "I2C Support" },
+	{ 0x0, NULL }
+};
+
+static ccidadm_pair_t ccidadm_p_mechanical[] = {
+	{ CCID_CLASS_MECH_CARD_ACCEPT, "Card Accept Mechanism" },
+	{ CCID_CLASS_MECH_CARD_EJECT, "Card Eject Mechanism" },
+	{ CCID_CLASS_MECH_CARD_CAPTURE, "Card Capture Mechanism" },
+	{ CCID_CLASS_MECH_CARD_LOCK, "Card Lock/Unlock Mechanism" },
+	{ 0x0, NULL }
+};
+
+static ccidadm_pair_t ccidadm_p_features[] = {
+	{ CCID_CLASS_F_AUTO_PARAM_ATR, "Automatic parameter configuration based on ATR data" },
+	{ CCID_CLASS_F_AUTO_ICC_ACTIVATE, "Automatic activation on ICC insertion" },
+	{ CCID_CLASS_F_AUTO_ICC_VOLTAGE, "Automatic ICC voltage selection" },
+	{ CCID_CLASS_F_AUTO_ICC_CLOCK, "Automatic ICC clock frequency change" },
+	{ CCID_CLASS_F_AUTO_BAUD, "Automatic baud rate change" },
+	{ CCID_CLASS_F_AUTO_PARAM_NEG, "Automatic parameter negotiation by CCID" },
+	{ CCID_CLASS_F_AUTO_PPS, "Automatic PPS made by CCID" },
+	{ CCID_CLASS_F_ICC_CLOCK_STOP, "CCID can set ICC in clock stop mode" },
+	{ CCID_CLASS_F_ALTNAD_SUP, "NAD value other than zero accepted" },
+	{ CCID_CLASS_F_AUTO_IFSD, "Automatic IFSD exchange" },
+	{ CCID_CLASS_F_TPDU_XCHG, "TPDU support" },
+	{ CCID_CLASS_F_SHORT_APDU_XCHG, "Short APDU support" },
+	{ CCID_CLASS_F_EXT_APDU_XCHG, "Short and Extended APDU support" },
+	{ CCID_CLASS_F_WAKE_UP, "USB Wake Up signaling support" },
+	{ 0x0, NULL }
+};
+
+static ccidadm_pair_t ccidadm_p_pin[] = {
+	{ CCID_CLASS_PIN_VERIFICATION, "PIN verification" },
+	{ CCID_CLASS_PIN_MODIFICATION, "PIN modification" },
+	{ 0x0, NULL }
+};
+
+/* ARGSUSED */
+static void
+ccidadm_reader_print(int fd, const char *name, void *unused)
+{
+	uccid_cmd_status_t ucs;
+	ccid_class_descr_t *cd;
+	char nnbuf[NN_NUMBUF_SZ + 1];
+
+	bzero(&ucs, sizeof (uccid_cmd_status_t));
+	ucs.ucs_version = UCCID_VERSION_ONE;
+
+	if (ioctl(fd, UCCID_CMD_STATUS, &ucs) != 0) {
+		err(EXIT_FAILURE, "failed to issue status ioctl to %s",
+		    name);
+	}
+
+	cd = &ucs.ucs_class;
+	(void) printf("Reader %s, CCID class v%u.%u device:\n", name,
+	    CCID_VERSION_MAJOR(cd->ccd_bcdCCID),
+	    CCID_VERSION_MINOR(cd->ccd_bcdCCID));
+
+	if ((ucs.ucs_status & UCCID_STATUS_F_PRODUCT_VALID) == 0) {
+		(void) strlcpy(ucs.ucs_product, "<unknown>",
+		    sizeof (ucs.ucs_product));
+	}
+
+	if ((ucs.ucs_status & UCCID_STATUS_F_SERIAL_VALID) == 0) {
+		(void) strlcpy(ucs.ucs_serial, "<unknown>",
+		    sizeof (ucs.ucs_serial));
+	}
+
+	(void) printf("  Product: %s\n", ucs.ucs_product);
+	(void) printf("  Serial: %s\n", ucs.ucs_serial);
+	(void) printf("  Slots Present: %u\n", cd->ccd_bMaxSlotIndex + 1);
+	(void) printf("  Maximum Busy Slots: %u\n", cd->ccd_bMaxCCIDBusySlots);
+	(void) printf("  Supported Voltages:\n");
+	ccidadm_print_pairs(cd->ccd_bVoltageSupport, ccidadm_p_voltages);
+	(void) printf("  Supported Protocols:\n");
+	ccidadm_print_pairs(cd->ccd_dwProtocols, ccidadm_p_protocols);
+	nicenum_scale(cd->ccd_dwDefaultClock, 1000, nnbuf,
+	    sizeof (nnbuf), NN_DIVISOR_1000 | NN_UNIT_SPACE);
+	(void) printf("  Default Clock: %sHz\n", nnbuf);
+	nicenum_scale(cd->ccd_dwMaximumClock, 1000, nnbuf,
+	    sizeof (nnbuf), NN_DIVISOR_1000 | NN_UNIT_SPACE);
+	(void) printf("  Maximum Clock: %sHz\n", nnbuf);
+	(void) printf("  Supported Clock Rates: %u\n",
+	    cd->ccd_bNumClockSupported);
+	nicenum_scale(cd->ccd_dwDataRate, 1, nnbuf, sizeof (nnbuf),
+	    NN_DIVISOR_1000 | NN_UNIT_SPACE);
+	(void) printf("  Default Data Rate: %sbps\n", nnbuf);
+	nicenum_scale(cd->ccd_dwMaxDataRate, 1, nnbuf, sizeof (nnbuf),
+	    NN_DIVISOR_1000 | NN_UNIT_SPACE);
+	(void) printf("  Maximum Data Rate: %sbps\n", nnbuf);
+	(void) printf("  Supported Data Rates: %u\n",
+	    cd->ccd_bNumDataRatesSupported);
+	(void) printf("  Maximum IFSD (T=1 only): %u\n", cd->ccd_dwMaxIFSD);
+	if (cd->ccd_dwSyncProtocols != 0) {
+		(void) printf("  Synchronous Protocols Supported:\n");
+		ccidadm_print_pairs(cd->ccd_dwSyncProtocols, ccidadm_p_syncprots);
+	}
+	if (cd->ccd_dwMechanical != 0) {
+		(void) printf("  Mechanical Features:\n");
+		ccidadm_print_pairs(cd->ccd_dwMechanical, ccidadm_p_mechanical);
+	}
+	if (cd->ccd_dwFeatures != 0) {
+		(void) printf("  Device Features:\n");
+		ccidadm_print_pairs(cd->ccd_dwFeatures, ccidadm_p_features);
+	}
+	(void) printf("  Maximum Message Length: %u bytes\n",
+	    cd->ccd_dwMaxCCIDMessageLength);
+	if (cd->ccd_dwFeatures & CCID_CLASS_F_EXT_APDU_XCHG) {
+		if (cd->ccd_bClassGetResponse == 0xff) {
+			(void) printf("  Default Get Response Class: echo\n");
+		} else {
+			(void) printf("  Default Get Response Class: %u\n",
+			    cd->ccd_bClassGetResponse);
+		}
+		if (cd->ccd_bClassEnvelope == 0xff) {
+			(void) printf("  Default Envelope Class: echo\n");
+		} else {
+			(void) printf("  Default Envelope Class: %u\n",
+			    cd->ccd_bClassEnvelope);
+		}
+	}
+	if (cd->ccd_wLcdLayout != 0) {
+		(void) printf("  %2ux%2u LCD present\n",
+		    cd->ccd_wLcdLayout >> 16, cd->ccd_wLcdLayout & 0xff);
+	}
+
+	if (cd->ccd_bPinSupport) {
+		(void) printf("  Pin Support:\n");
+		ccidadm_print_pairs(cd->ccd_bPinSupport, ccidadm_p_pin);
+	}
+}
+
+static void
+ccidadm_do_reader(int argc, char *argv[])
+{
+	int i;
+
+	/* XXX argc == 0, dump all */
+	if (argc == 0) {
+		ccidadm_iter(B_TRUE, B_TRUE, ccidadm_reader_print, NULL);
+	}
+
+	for (i = 0; i < argc; i++) {
+		int fd;
+
+		if ((fd = ccidadm_open(argv[i], B_TRUE)) < 0) {
+			warn("failed to open %s", argv[i]);
+			errx(EXIT_FAILURE, "valid ccid reader");
+		}
+
+		ccidadm_reader_print(fd, argv[i], NULL);
+		(void) close(fd);
+		if (i + 1 < argc) {
+			(void) printf("\n");
+		}
+	}
+}
+
+static void
+ccidadm_reader_usage(FILE *out)
+{
+	(void) fprintf(out, "\treader\t\t[reader] ...\n");
+}
+
+typedef struct ccidadm_cmdtab {
+	const char *cc_name;
+	void (*cc_op)(int, char *[]);
+	void (*cc_usage)(FILE *);
+} ccidadm_cmdtab_t;
+
+static ccidadm_cmdtab_t ccidadm_cmds[] = {
+	{ "list", ccidadm_do_list, ccidadm_list_usage },
+	{ "atr", ccidadm_do_atr, ccidadm_atr_usage },
+	{ "reader", ccidadm_do_reader, ccidadm_reader_usage },
+	{ NULL }
+};
+
+static int
+ccidadm_usage(const char *format, ...)
+{
+	ccidadm_cmdtab_t *tab;
+
+	if (format != NULL) {
+		va_list ap;
+
+		va_start(ap, format);
+		(void) fprintf(stderr, "%s: ", ccidadm_pname);
+		(void) vfprintf(stderr, format, ap);
+		(void) fprintf(stderr, "\n");
+		va_end(ap);
+	}
+
+	(void) fprintf(stderr, "usage:  %s <subcommand> <args> ...\n\n", ccidadm_pname);
+	(void) fprintf(stderr, "Subcommands:\n");
+	for (tab = ccidadm_cmds; tab->cc_name != NULL; tab++) {
+		tab->cc_usage(stderr);
+	}
+
+	return (EXIT_USAGE);
+}
+
+int
+main(int argc, char *argv[])
+{
+	ccidadm_cmdtab_t *tab;
+
+	ccidadm_pname = basename(argv[0]);
+	if (argc < 2) {
+		return (ccidadm_usage("missing required subcommand"));
+	}
+
+	for (tab = ccidadm_cmds; tab->cc_name != NULL; tab++) {
+		if (strcmp(argv[1], tab->cc_name) == 0) {
+			argc -= 2;
+			argv += 2;
+			tab->cc_op(argc, argv);
+			return (EXIT_SUCCESS);
+		}
+	}
+
+	return (ccidadm_usage("unknown command: %s", argv[1]));
+}
diff --git a/usr/src/cmd/devfsadm/cfg_link.c b/usr/src/cmd/devfsadm/cfg_link.c
index e7229325ac..29f3901691 100644
--- a/usr/src/cmd/devfsadm/cfg_link.c
+++ b/usr/src/cmd/devfsadm/cfg_link.c
@@ -59,6 +59,7 @@ static int	pci_cfg_creat_cb(di_minor_t minor, di_node_t node);
 static int	ib_cfg_creat_cb(di_minor_t minor, di_node_t node);
 static int	sata_cfg_creat_cb(di_minor_t minor, di_node_t node);
 static int	sdcard_cfg_creat_cb(di_minor_t minor, di_node_t node);
+static int	ccid_cfg_creat_cb(di_minor_t minor, di_node_t node);
 
 static di_node_t	pci_cfg_chassis_node(di_node_t, di_prom_handle_t);
 static char	*pci_cfg_slotname(di_node_t, di_prom_handle_t, minor_t);
@@ -120,6 +121,9 @@ static devfsadm_create_t cfg_create_cbt[] = {
 	},
 	{ "attachment-point", DDI_NT_SDCARD_ATTACHMENT_POINT, NULL,
 	    TYPE_EXACT, ILEVEL_0, sdcard_cfg_creat_cb
+	},
+	{ "attachment-point", DDI_NT_CCID_ATTACHMENT_POINT, NULL,
+	    TYPE_EXACT, ILEVEL_0, ccid_cfg_creat_cb
 	}
 };
 
@@ -153,6 +157,9 @@ static devfsadm_remove_t cfg_remove_cbt[] = {
 	{ "attachment-point", SDCARD_CFG_LINK_RE, RM_POST|RM_HOT|RM_ALWAYS,
 	    ILEVEL_0, devfsadm_rm_all
 	},
+	{ "attachment-point", CCID_CFG_LINK_RE, RM_POST|RM_HOT|RM_ALWAYS,
+	    ILEVEL_0, devfsadm_rm_all
+	}
 };
 
 DEVFSADM_REMOVE_INIT_V0(cfg_remove_cbt);
@@ -1246,3 +1253,24 @@ serid_printable(uint64_t *seridp)
 	return (1);
 
 }
+
+/*
+ * Create a link for cfgadm that points back to the normal ccid links in
+ * /dev/ccid.
+ */
+static int
+ccid_cfg_creat_cb(di_minor_t minor, di_node_t node)
+{
+	const char *minor_nm;
+	char cfg_path[MAXPATHLEN];
+
+	if ((minor_nm = di_minor_name(minor)) == NULL) {
+		return (DEVFSADM_CONTINUE);
+	}
+
+	(void) snprintf(cfg_path, sizeof (cfg_path), "%s/ccid%d/%s", CFG_DIRNAME,
+	    di_instance(node),  minor_nm);
+
+	(void) devfsadm_mklink(cfg_path, node, minor, 0);
+	return (DEVFSADM_CONTINUE);
+}
diff --git a/usr/src/cmd/devfsadm/cfg_link.h b/usr/src/cmd/devfsadm/cfg_link.h
index e2bb24864d..fdd78bcfe2 100644
--- a/usr/src/cmd/devfsadm/cfg_link.h
+++ b/usr/src/cmd/devfsadm/cfg_link.h
@@ -43,6 +43,7 @@ extern "C" {
 #define	SDCARD_CFG_LINK_RE	"^cfg/sdcard[0-9]+/[0-9]+$"
 #define	PCI_CFG_PATH_LINK_RE	\
 	"^cfg/(.*(pci[0-9]|pcie[0-9]|Slot[0-9]|\\<pci\\>|\\<pcie\\>).*)$"
+#define	CCID_CFG_LINK_RE	"^cfg/ccid[0-9]+/slot[0-9]+$"
 
 #define	CFG_DIRNAME		"cfg"
 
diff --git a/usr/src/cmd/devfsadm/usb_link.c b/usr/src/cmd/devfsadm/usb_link.c
index ac6a8447fb..1136b91d0d 100644
--- a/usr/src/cmd/devfsadm/usb_link.c
+++ b/usr/src/cmd/devfsadm/usb_link.c
@@ -37,6 +37,8 @@ static int usb_process(di_minor_t minor, di_node_t node);
 
 static void ugen_create_link(char *p_path, char *node_name,
     di_node_t node, di_minor_t minor);
+static void ccid_create_link(char *p_path, char *node_name,
+    di_node_t node, di_minor_t minor);
 
 
 /* Rules for creating links */
@@ -81,6 +83,8 @@ static devfsadm_create_t usb_cbt[] = {
 						ILEVEL_0, usb_process },
 	{ "usb", DDI_NT_NEXUS, "hwahc", DRV_EXACT|TYPE_EXACT,
 						ILEVEL_0, usb_process },
+	{ "usb", DDI_NT_CCID_ATTACHMENT_POINT, "ccid", DRV_EXACT|TYPE_EXACT,
+						ILEVEL_0, usb_process },
 };
 
 /* For debug printing (-V filter) */
@@ -105,6 +109,7 @@ DEVFSADM_CREATE_INIT_V0(usb_cbt);
 #define	USB_LINK_RE_WHOST	"^usb/whost[0-9]+$"
 #define	USB_LINK_RE_HWARC	"^usb/hwarc[0-9]+$"
 #define	USB_LINK_RE_WUSB_CA	"^usb/wusb_ca[0-9]+$"
+#define	USB_LINK_RE_CCID	"^ccid/ccid[0-9]+/slot[0-9]+$"
 
 /* Rules for removing links */
 static devfsadm_remove_t usb_remove_cbt[] = {
@@ -138,7 +143,9 @@ static devfsadm_remove_t usb_remove_cbt[] = {
 	{ "usb", USB_LINK_RE_HWARC, RM_POST | RM_HOT | RM_ALWAYS, ILEVEL_0,
 			devfsadm_rm_all },
 	{ "usb", USB_LINK_RE_WUSB_CA, RM_POST | RM_HOT | RM_ALWAYS, ILEVEL_0,
-			devfsadm_rm_all }
+			devfsadm_rm_all },
+	{ "usb", USB_LINK_RE_CCID, RM_POST | RM_HOT | RM_ALWAYS, ILEVEL_0,
+		devfsadm_rm_all }
 };
 
 /*
@@ -220,6 +227,7 @@ driver_name_table_entry_t driver_name_table[] = {
 	{ "hubd",	DRIVER_HUBD },
 	{ "ohci",	DRIVER_OHCI },
 	{ "ehci",	DRIVER_EHCI },
+	{ "xhci",	DRIVER_XHCI },
 	{ "uhci",	DRIVER_UHCI },
 	{ "xhci",	DRIVER_XHCI },
 	{ "usb_ac",	DRIVER_USB_AC },
@@ -306,6 +314,13 @@ usb_process(di_minor_t minor, di_node_t node)
 		return (DEVFSADM_CONTINUE);
 	}
 
+	if (strcmp(di_minor_nodetype(minor), DDI_NT_CCID_ATTACHMENT_POINT) == 0) {
+		ccid_create_link(p_path, minor_nm, node, minor);
+		free(l_path);
+		free(p_path);
+		return (DEVFSADM_CONTINUE);
+	}
+
 	/* Figure out which rules to apply */
 	switch (index) {
 	case DRIVER_HUBD:
@@ -493,3 +508,19 @@ ugen_create_link(char *p_path, char *node_name,
 
 	free(buf);
 }
+
+/*
+ * Create a CCID related link.
+ */
+static void
+ccid_create_link(char *p_path, char *minor_nm, di_node_t node, di_minor_t minor)
+{
+	char l_path[MAXPATHLEN];
+
+	(void) snprintf(l_path, sizeof (l_path), "ccid/ccid%d/%s",
+	    di_instance(node), minor_nm);
+
+	devfsadm_print(debug_mid, "mklink %s -> %s\n", l_path, p_path);
+
+	(void) devfsadm_mklink(l_path, node, minor, 0);
+}
diff --git a/usr/src/cmd/mdb/common/modules/usba/prtusb.c b/usr/src/cmd/mdb/common/modules/usba/prtusb.c
index 9f6ffc4177..7f32ea3d83 100644
--- a/usr/src/cmd/mdb/common/modules/usba/prtusb.c
+++ b/usr/src/cmd/mdb/common/modules/usba/prtusb.c
@@ -484,6 +484,32 @@ static usb_descr_item_t usb_vs_format_dv_descr[] = {
 };
 static uint_t usb_vs_format_dv_item = 6;
 
+static usb_descr_item_t usb_ccid_descr[] = {
+	{1, "bLength"},
+	{1, "bDescriptorType"},
+	{2, "bcdCCID"},
+	{1, "bMaxSlotIndex"},
+	{1, "bVoltageSupport"},
+	{4, "dwProtocols"},
+	{4, "dwDefaultClock"},
+	{4, "dwMaximumClock"},
+	{1, "bNumClockSupported"},
+	{4, "dwDataRate"},
+	{4, "dwMaxDataRate"},
+	{1, "bNumDataRatesSupported"},
+	{4, "dwMaxIFSD"},
+	{4, "dwSyncProtocols"},
+	{4, "dwMechanical"},
+	{4, "dwFeatures"},
+	{4, "dwMaxCCIDMessageLength"},
+	{1, "bClassGetResponse"},
+	{1, "bClassEnvelope"},
+	{2, "wLcdLayout"},
+	{1, "bPinSupport"},
+	{1, "bMaxCCIDBusySlots"}
+};
+static uint_t usb_ccid_item = 22;
+
 
 /* ****************************************************************** */
 
@@ -1131,6 +1157,11 @@ prt_usb_desc(uintptr_t usb_cfg, uint_t cfg_len)
 				mdb_printf("WA Descriptor\n");
 				print_descr(paddr, nlen, usb_wa_descr,
 				    usb_wa_item);
+			} else if (usb_if.bInterfaceClass == 0xb &&
+			    usb_if.bInterfaceSubClass == 0x0) {
+				mdb_printf("CCID Descriptor\n");
+				print_descr(paddr, nlen, usb_ccid_descr,
+				    usb_ccid_item);
 			} else {
 				mdb_printf("HID Descriptor\n");
 				print_descr(paddr, nlen, usb_hid_descr,
diff --git a/usr/src/common/ccid/atr.c b/usr/src/common/ccid/atr.c
new file mode 100644
index 0000000000..52a7cb870c
--- /dev/null
+++ b/usr/src/common/ccid/atr.c
@@ -0,0 +1,1602 @@
+/*
+ * This file and its contents are supplied under the terms of the
+ * Common Development and Distribution License ("CDDL"), version 1.0.
+ * You may only use this file in accordance with the terms of version
+ * 1.0 of the CDDL.
+ *
+ * A full copy of the text of the CDDL should have accompanied this
+ * source.  A copy of the CDDL is also available via the Internet at
+ * http://www.illumos.org/license/CDDL.
+ */
+
+/*
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+
+/*
+ * ATR parsing routines shared between userland (ccidadm) and the kernel (CCID
+ * driver)
+ */
+
+#include "atr.h"
+#include <sys/debug.h>
+#include <sys/limits.h>
+
+#ifdef	_KERNEL
+#include <sys/inttypes.h>
+#include <sys/sunddi.h>
+#include <sys/kmem.h>
+#else
+#include <inttypes.h>
+#include <strings.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <ctype.h>
+#endif
+
+/*
+ * The ATR must have at least 2 bytes and then may have up to 33 bytes. The
+ * first byte is always TS and the second required byte is T0.
+ */
+#define	ATR_TS_IDX	0
+#define	ATR_T0_IDX	1
+
+/*
+ * There are two valid values for TS. It must either be 0x3F or 0x3B. This is
+ * required per ISO/IEC 7816-3:2006 section 8.1.
+ */
+#define	ATR_TS_INVERSE	0x3F
+#define	ATR_TS_DIRECT	0x3B
+
+/*
+ * After TS, each word is used t indicate a combination of protocol and the
+ * number of bits defined for that protocol. The lower nibble is treated as the
+ * protocol. The upper nibble is treated to indicate which of four defined words
+ * are present. These are usually referred to as TA, TB, TC, and TD. TD is
+ * always used to indicate the next protocol and the number of bytes present for
+ * that. T0 works in a similar way, except that it defines the number of
+ * historical bytes present in its protocol section and then it refers to a set
+ * of pre-defined global bytes that may be present.
+ */
+#define	ATR_TD_PROT(x)	((x) & 0x0f)
+#define	ATR_TD_NBITS(x)	(((x) & 0xf0) >> 4)
+#define	ATR_TA_MASK	0x1
+#define	ATR_TB_MASK	0x2
+#define	ATR_TC_MASK	0x4
+#define	ATR_TD_MASK	0x8
+
+#define	ATR_TA1_FTABLE(x)	(((x) & 0xf0) >> 4)
+#define	ATR_TA1_DITABLE(x)	((x) & 0x0f)
+
+#define	ATR_TA2_CANCHANGE(x)	(((x) & 0x80) == 0)
+#define	ATR_TA2_HONORTA1(x)	(((x) & 0x10) == 0)
+#define	ATR_TA2_PROTOCOL(x)	((x) & 0x0f)
+
+/*
+ * When the checksum is required in the ATR, each byte must XOR to zero.
+ */
+#define	ATR_CKSUM_TARGET	0
+
+/*
+ * Maximum number of historic ATR bytes. This is limited by the fact that it's a
+ * 4-bit nibble.
+ */
+#define	ATR_HISTORICAL_MAX	15
+
+/*
+ * The maximum number of TA, TB, TC, and TD levels that can be encountered in a
+ * given structure. In the best case, there are 30 bytes available (TS, T0, and
+ * TCK use the others). Given that each one of these needs 4 bytes to be
+ * represented, the maximum number of layers that can fit is seven.
+ */
+#define	ATR_TI_MAX	7
+
+/*
+ * Defined protocol values. See ISO/IEC 7816-3:2006 8.2.3 for this list.
+ * Reserved values are noted but not defined.
+ */
+#define	ATR_PROTOCOL_T0		0
+#define	ATR_PROTOCOL_T1		1
+
+#define	ATR_T1_TB0_CWI(x)	((x) & 0x0f)
+#define	ATR_T1_TB0_BWI(x)	(((x) & 0xf0) >> 4)
+#define	ATR_T1_TC0_CRC(x)	(((x) & 0x01) != 0)
+
+/*
+ * T=2 and T=3 are reserved for future full-duplex operation.
+ * T=4 is reserved for enhacned half-duplex character transmission.
+ * T=5-13 are reserved for future use by ISO/IEC JTC 1/SC 17.
+ * T=14 is for protocols not standardized by ISO/IEC JTC 1/SC 17.
+ */
+#define	ATR_PROTOCOL_T15	15
+
+#define	ATR_T15_TA0_CLOCK(x)	(((x) & 0xc0) >> 6)
+#define	ATR_T15_TA0_VOLTAGE(x)	((x) & 0x3f)
+
+#define	ATR_T15_TB0_SPU_STANDARD(x)	(((x & 0x80)) != 0)
+
+/*
+ * Various definitions for the configuration of historical data. This comes from
+ * ISO/IEC 7816-4:2013 Section 12.1.1.
+ */
+
+/*
+ * The first historical byte is used to indicate the encoding of the data. Only
+ * values 0x00, 0x80-0x8f are defined. All others are proprietary. 0x81-0x8f are
+ * reserved for future use.
+ */
+#define	ATR_HIST_CAT_MAND_STATUS	0x00
+#define	ATR_HIST_CAT_TLV_STATUS		0x80
+#define	ATR_HIST_CAT_RFU_MIN		0x81
+#define	ATR_HIST_CAT_RFU_MAX		0x8f
+
+/*
+ * From ISO/IEC 7816-3:2006 Section 8.3.
+ *
+ * The default value for Fi is 372 which is table entry 1. The default value for
+ * Di is 1, which is table entry 1.
+ */
+#define	ATR_FI_DEFAULT_INDEX	1
+#define	ATR_DI_DEFAULT_INDEX	1
+#define	ATR_EXTRA_GUARDTIME_DEFAULT	0
+
+/*
+ * From ISO/IEC 7816-3:2006 Section 10.2.
+ */
+#define	ATR_T0_WI_DEFAULT	10
+
+/*
+ * From ISO/IEC 7816-3:2006 Section 11.4.3.
+ */
+#define	ATR_T1_CWI_DEFAULT	13
+
+/*
+ * From ISO/IEC 7816-3:2006 Section 11.4.3.
+ */
+#define	ATR_T1_BWI_DEFAULT	4
+
+/*
+ * From ISO/IEC 7816-3:2006 Section 11.4.2.
+ */
+#define	ATR_T1_IFSC_DEFAULT	32
+
+/*
+ * From ISO/IEC 7816-3:2006 Section 11.4.4
+ */
+#define	ATR_T1_CHECKSUM_DEFAULT	ATR_T1_CHECKSUM_LRC
+
+/*
+ * Definitions for PPS construction. These are derived from ISO/IEC 7816-3:2006
+ * section 9, Protocol and parameters selection.
+ */
+#define	PPS_LEN_MIN	3	/* PPSS, PPS0, PCK */
+#define	PPS_LEN_MAX	PPS_BUFFER_MAX
+#define	PPS_PPSS_INDEX	0
+#define	PPS_PPSS_VAL	0xff
+#define	PPS_PPS0_INDEX	0x01
+#define	PPS_PPS0_PROT(x)	((x) & 0x0f)
+#define	PPS_PPS0_PPS1		(1 << 4)
+#define	PPS_PPS0_PPS2		(1 << 5)
+#define	PPS_PPS0_PPS3		(1 << 6)
+#define	PPS_PPS1_SETVAL(f, d)	((((f) & 0x0f) << 4) | ((d) & 0x0f))
+
+/*
+ * This enum and subsequent structure is used to represent a single level of
+ * 'T'. This includes the possibility for all three values to be set and records
+ * the protocol.
+ */
+typedef enum atr_ti_flags {
+	ATR_TI_HAVE_TA	= 1 << 0,
+	ATR_TI_HAVE_TB	= 1 << 1,
+	ATR_TI_HAVE_TC	= 1 << 2,
+	ATR_TI_HAVE_TD	= 1 << 3
+} atr_ti_flags_t;
+
+typedef struct atr_ti {
+	uint8_t		atrti_protocol;
+	uint8_t		atrti_ti_val;
+	uint8_t		atrti_td_idx;
+	atr_ti_flags_t	atrti_flags;
+	uint8_t		atrti_ta;
+	uint8_t		atrti_tb;
+	uint8_t		atrti_tc;
+	uint8_t		atrti_td;
+} atr_ti_t;
+
+typedef enum atr_flags {
+	ATR_F_USES_DIRECT	= 1 << 0,
+	ATR_F_USES_INVERSE	= 1 << 1,
+	ATR_F_HAS_CHECKSUM	= 1 << 2,
+	ATR_F_VALID		= 1 << 3
+} atr_flags_t;
+
+
+struct atr_data {
+	atr_flags_t	atr_flags;
+	uint8_t		atr_nti;
+	atr_ti_t	atr_ti[ATR_TI_MAX];
+	uint8_t		atr_nhistoric;
+	uint8_t		atr_historic[ATR_HISTORICAL_MAX];
+	uint8_t 	atr_cksum;
+	uint8_t		atr_raw[ATR_LEN_MAX];
+	uint8_t		atr_nraw;
+};
+
+/*
+ * These tables maps the bit values for Fi from 7816-3:2006 section 8.3 Table 7.
+ */
+static uint_t atr_fi_valtable[16] = {
+	372,		/* 0000 */
+	372,		/* 0001 */
+	558,		/* 0010 */
+	744,		/* 0011 */
+	1116,		/* 0100 */
+	1488,		/* 0101 */
+	1860,		/* 0110 */
+	0,		/* 0111 */
+	0,		/* 1000 */
+	512,		/* 1001 */
+	768,		/* 1010 */
+	1024,		/* 1011 */
+	1536,		/* 1100 */
+	2048,		/* 1101 */
+	0,		/* 1110 */
+	0		/* 1111 */
+};
+
+static const char *atr_fi_table[16] = {
+	"372",		/* 0000 */
+	"372",		/* 0001 */
+	"558",		/* 0010 */
+	"744",		/* 0011 */
+	"1116",		/* 0100 */
+	"1488",		/* 0101 */
+	"1860",		/* 0110 */
+	"RFU",		/* 0111 */
+	"RFU",		/* 1000 */
+	"512",		/* 1001 */
+	"768",		/* 1010 */
+	"1024",		/* 1011 */
+	"1536",		/* 1100 */
+	"2048",		/* 1101 */
+	"RFU",		/* 1110 */
+	"RFU",		/* 1111 */
+};
+
+/*
+ * This table maps the bit values for Fi from 7816-3:2006 section 8.3 Table 7.
+ */
+static const char *atr_fmax_table[16] = {
+	"4",		/* 0000 */
+	"5",		/* 0001 */
+	"6",		/* 0010 */
+	"8",		/* 0011 */
+	"12",		/* 0100 */
+	"16",		/* 0101 */
+	"20",		/* 0110 */
+	"-",		/* 0111 */
+	"-",		/* 1000 */
+	"5",		/* 1001 */
+	"7.5",		/* 1010 */
+	"10",		/* 1011 */
+	"15",		/* 1100 */
+	"20",		/* 1101 */
+	"-",		/* 1110 */
+	"-",		/* 1111 */
+};
+
+/*
+ * This table maps the bit values for Fi from 7816-3:2006 section 8.3 Table 8.
+ */
+static uint_t atr_di_valtable[16] = {
+	0,		/* 0000 */
+	1,		/* 0001 */
+	2,		/* 0010 */
+	4,		/* 0011 */
+	8,		/* 0100 */
+	16,		/* 0101 */
+	32,		/* 0110 */
+	64,		/* 0111 */
+	12,		/* 1000 */
+	20,		/* 1001 */
+	0,		/* 1010 */
+	0,		/* 1011 */
+	0,		/* 1100 */
+	0,		/* 1101 */
+	0,		/* 1110 */
+	0		/* 1111 */
+};
+
+/*
+ * This table maps the bit values for Fi from 7816-3:2006 section 8.3 Table 8.
+ */
+static const char *atr_di_table[16] = {
+	"RFU",		/* 0000 */
+	"1",		/* 0001 */
+	"2",		/* 0010 */
+	"4",		/* 0011 */
+	"8",		/* 0100 */
+	"16",		/* 0101 */
+	"32",		/* 0110 */
+	"64",		/* 0111 */
+	"12",		/* 1000 */
+	"20",		/* 1001 */
+	"RFU",		/* 1010 */
+	"RFU",		/* 1011 */
+	"RFU",		/* 1100 */
+	"RFU",		/* 1101 */
+	"RFU",		/* 1110 */
+	"RFU",		/* 1111 */
+};
+
+/*
+ * This table maps the bit values for Fi from 7816-3:2006 section 8.3 Table 9.
+ */
+static const char *atr_clock_table[4] = {
+	"disallowed",		/* 00 */
+	"signal low",		/* 01 */
+	"signal high",		/* 10 */
+	"signal low or high"	/* 11 */
+};
+
+uint_t
+atr_fi_index_to_value(uint8_t val)
+{
+	if (val >= sizeof (atr_fi_valtable) / sizeof (atr_fi_valtable[0])) {
+		return (0);
+	}
+
+	return (atr_fi_valtable[val]);
+}
+
+const char *
+atr_fi_index_to_string(uint8_t val)
+{
+	if (val >= sizeof (atr_fi_table) / sizeof (atr_fi_table[0])) {
+		return ("<invalid>");
+	}
+
+	return (atr_fi_table[val]);
+}
+
+const char *
+atr_fmax_index_to_string(uint8_t val)
+{
+	if (val >= sizeof (atr_fmax_table) / sizeof (atr_fmax_table[0])) {
+		return ("<invalid>");
+	}
+
+	return (atr_fmax_table[val]);
+}
+
+uint_t
+atr_di_index_to_value(uint8_t val)
+{
+	if (val >= sizeof (atr_di_valtable) / sizeof (atr_di_valtable[0])) {
+		return (0);
+	}
+
+	return (atr_di_valtable[val]);
+}
+const char *
+atr_di_index_to_string(uint8_t val)
+{
+	if (val >= sizeof (atr_di_table) / sizeof (atr_di_table[0])) {
+		return ("<invalid>");
+	}
+
+	return (atr_di_table[val]);
+}
+
+const char *
+atr_clock_stop_to_string(atr_clock_stop_t val)
+{
+	if (val >= sizeof (atr_clock_table) / sizeof (atr_clock_table[0])) {
+		return ("<invalid>");
+	}
+
+	return (atr_clock_table[val]);
+}
+
+const char *
+atr_protocol_to_string(atr_protocol_t prot)
+{
+	if (prot == ATR_P_NONE) {
+		return ("none");
+	}
+
+	if ((prot & ATR_P_T0) == ATR_P_T0) {
+		return ("T=0");
+	} else if ((prot & ATR_P_T1) == ATR_P_T1) {
+		return ("T=1");
+	} else {
+		return ("T=0, T=1");
+	}
+}
+
+const char *
+atr_convention_to_string(atr_convention_t conv)
+{
+	if (conv == ATR_CONVENTION_DIRECT) {
+		return ("direct");
+	} else if (conv == ATR_CONVENTION_INVERSE) {
+		return ("inverse");
+	} else {
+		return ("<invalid convention>");
+	}
+}
+
+const char *
+atr_strerror(atr_parsecode_t code)
+{
+	switch (code) {
+	case ATR_CODE_OK:
+		return ("ATR parsed successfully");
+	case ATR_CODE_TOO_SHORT:
+		return ("Specified buffer too short");
+	case ATR_CODE_TOO_LONG:
+		return ("Specified buffer too long");
+	case ATR_CODE_INVALID_TS:
+		return ("ATR has invalid TS byte value");
+	case ATR_CODE_OVERRUN:
+		return ("ATR data requires more bytes than provided");
+	case ATR_CODE_UNDERRUN:
+		return ("ATR data did not use all provided bytes");
+	case ATR_CODE_CHECKSUM_ERROR:
+		return ("ATR data did not checksum correctly");
+	case ATR_CODE_INVALID_TD1:
+		return ("ATR data has invalid protocol in TD1");
+	default:
+		return ("Unknown Parse Code");
+	}
+}
+
+static uint_t
+atr_count_cbits(uint8_t x)
+{
+	uint_t ret = 0;
+
+	if (x & ATR_TA_MASK)
+		ret++;
+	if (x & ATR_TB_MASK)
+		ret++;
+	if (x & ATR_TC_MASK)
+		ret++;
+	if (x & ATR_TD_MASK)
+		ret++;
+	return (ret);
+}
+
+/*
+ * Parse out ATR values. Focus on only parsing it and not interpretting it.
+ * Interpretation should be done in other functions that can walk over the data
+ * and be more protocol-aware.
+ */
+atr_parsecode_t
+atr_parse(const uint8_t *buf, size_t len, atr_data_t *data)
+{
+	uint_t nhist, cbits, ncbits, idx, Ti, prot;
+	uint_t ncksum = 0;
+	atr_ti_t *atp;
+
+	/*
+	 * Zero out data in case someone's come back around for another loop on
+	 * the same data.
+	 */
+	bzero(data, sizeof (atr_data_t));
+
+	if (len < ATR_LEN_MIN) {
+		return (ATR_CODE_TOO_SHORT);
+	}
+
+	if (len > ATR_LEN_MAX) {
+		return (ATR_CODE_TOO_LONG);
+	}
+
+	if (buf[ATR_TS_IDX] != ATR_TS_INVERSE &&
+	    buf[ATR_TS_IDX] != ATR_TS_DIRECT) {
+		return (ATR_CODE_INVALID_TS);
+	}
+
+	bcopy(buf, data->atr_raw, len);
+	data->atr_nraw = len;
+
+	if (buf[ATR_TS_IDX] == ATR_TS_DIRECT) {
+		data->atr_flags |= ATR_F_USES_DIRECT;
+	} else {
+		data->atr_flags |= ATR_F_USES_INVERSE;
+	}
+
+	/*
+	 * The protocol of T0 is the number of historical bits present.
+	 */
+	nhist = ATR_TD_PROT(buf[ATR_T0_IDX]);
+	cbits = ATR_TD_NBITS(buf[ATR_T0_IDX]);
+	idx = ATR_T0_IDX + 1;
+	ncbits = atr_count_cbits(cbits);
+
+	/*
+	 * Ti is used to track the current iteration of T[A,B,C,D] that we are
+	 * on, as the ISO/IEC standard suggests. The way that values are
+	 * interpretted depends on the value of Ti.
+	 *
+	 * When Ti is one, TA, TB, and TC represent global properties. TD's
+	 * protocol represents the preferred protocol.
+	 *
+	 * When Ti is two TA, TB, and TC also represent global properties.
+	 * However, TC only has meaning if the protocol is T=0.
+	 *
+	 * When Ti is 15, it indicates more global properties.
+	 *
+	 * For all other values of Ti, the meaning depends on the protocol in
+	 * question and they are all properties specific to that protocol.
+	 */
+	Ti = 1;
+	/*
+	 * Initialize prot to an invalid protocol to help us deal with the
+	 * normal workflow and make sure that we don't mistakenly do anything.
+	 */
+	prot = UINT32_MAX;
+	for (;;) {
+		atp = &data->atr_ti[data->atr_nti];
+		data->atr_nti++;
+		ASSERT3U(data->atr_nti, <=, ATR_TI_MAX);
+
+		/*
+		 * Make sure that we have enough space to read all the cbits.
+		 * idx points to the first cbit, which could also potentially be
+		 * over the length of the buffer. This is why we subtract one
+		 * from idx when doing the calculation.
+		 */
+		if (idx - 1 + ncbits >= len) {
+			return (ATR_CODE_OVERRUN);
+		}
+
+		ASSERT3U(Ti, !=, 0);
+
+		/*
+		 * At the moment we opt to ignore reserved protocols.
+		 */
+		atp->atrti_protocol = prot;
+		atp->atrti_ti_val = Ti;
+		atp->atrti_td_idx = idx - 1;
+
+		if (cbits & ATR_TA_MASK) {
+			atp->atrti_flags |= ATR_TI_HAVE_TA;
+			atp->atrti_ta = buf[idx];
+			idx++;
+		}
+
+		if (cbits & ATR_TB_MASK) {
+			atp->atrti_flags |= ATR_TI_HAVE_TB;
+			atp->atrti_tb = buf[idx];
+			idx++;
+		}
+
+		if (cbits & ATR_TC_MASK) {
+			atp->atrti_flags |= ATR_TI_HAVE_TC;
+			atp->atrti_tc = buf[idx];
+			idx++;
+		}
+
+		if (cbits & ATR_TD_MASK) {
+			atp->atrti_flags |= ATR_TI_HAVE_TD;
+			atp->atrti_td = buf[idx];
+			cbits = ATR_TD_NBITS(buf[idx]);
+			prot = ATR_TD_PROT(buf[idx]);
+			ncbits = atr_count_cbits(cbits);
+			if (prot != 0)
+				ncksum = 1;
+
+			/*
+			 * T=15 is not allowed in TD1 per 8.2.3.
+			 */
+			if (Ti == 1 && prot == 0xf)
+				return (ATR_CODE_INVALID_TD1);
+
+			idx++;
+			/*
+			 * Encountering TD means that once we take the next loop
+			 * and we need to increment Ti.
+			 */
+			Ti++;
+		} else {
+			break;
+		}
+	}
+
+	/*
+	 * We've parsed all of the cbits. At this point, we should take into
+	 * account all of the historical bits and potentially the checksum.
+	 */
+	if (idx - 1 + nhist + ncksum >= len) {
+		return (ATR_CODE_OVERRUN);
+	}
+
+	if (idx + nhist + ncksum != len) {
+		return (ATR_CODE_UNDERRUN);
+	}
+
+	if (nhist > 0) {
+		data->atr_nhistoric = nhist;
+		bcopy(&buf[idx], data->atr_historic, nhist);
+	}
+
+	if (ncksum > 0) {
+		size_t i;
+		uint8_t val;
+
+		/*
+		 * Per ISO/IEC 7816-3:2006 Section 8.2.5 the checksum is all
+		 * bytes excluding TS. Therefore, we must start at byte 1.
+		 */
+		for (val = 0, i = 1; i < len; i++) {
+			val ^= buf[i];
+		}
+
+		if (val != ATR_CKSUM_TARGET) {
+			return (ATR_CODE_CHECKSUM_ERROR);
+		}
+		data->atr_flags |= ATR_F_HAS_CHECKSUM;
+		data->atr_cksum = buf[len - 1];
+	}
+
+	data->atr_flags |= ATR_F_VALID;
+	return (ATR_CODE_OK);
+}
+
+uint8_t
+atr_fi_default_index(void)
+{
+	return (ATR_FI_DEFAULT_INDEX);
+}
+
+uint8_t
+atr_di_default_index(void)
+{
+	return (ATR_DI_DEFAULT_INDEX);
+}
+
+/*
+ * Parse the data to determine which protocols are supported in this atr data.
+ * Based on this, users can come and ask us to fill in protocol information.
+ */
+atr_protocol_t
+atr_supported_protocols(atr_data_t *data)
+{
+	uint_t i;
+	atr_protocol_t prot;
+
+	if ((data->atr_flags & ATR_F_VALID) == 0)
+		return (ATR_P_NONE);
+
+	/*
+	 * Based on 8.2.3 of ISO/IEC 7816-3:2006, if TD1 is present, then that
+	 * indicates the first protocol. However, if it is not present, then
+	 * that implies that T=0 is the only supported protocol. Otherwise, all
+	 * protocols are referenced in ascending order. The first entry in
+	 * atr_ti refers to data from T0, so the protocol in the second entry
+	 * would have the TD1 data.
+	 */
+	if (data->atr_nti < 2) {
+		return (ATR_P_T0);
+	}
+
+	prot = ATR_P_NONE;
+	for (i = 0; i < data->atr_nti; i++) {
+		switch (data->atr_ti[i].atrti_protocol) {
+		case ATR_PROTOCOL_T0:
+			prot |= ATR_P_T0;
+			break;
+		case ATR_PROTOCOL_T1:
+			prot |= ATR_P_T1;
+			break;
+		default:
+			continue;
+		}
+	}
+
+	/*
+	 * It's possible we've found nothing specific in the above loop (for
+	 * example, only T=15 global bits were found). In that case, the card
+	 * defaults to T=0.
+	 */
+	if (prot == ATR_P_NONE)
+		prot = ATR_P_T0;
+
+	return (prot);
+}
+
+boolean_t
+atr_params_negotiable(atr_data_t *data)
+{
+	/* If for some reason we're called with invalid data, assume it's not */
+	if ((data->atr_flags & ATR_F_VALID) == 0)
+		return (B_FALSE);
+
+
+	/*
+	 * Whether or not we're negotiable is in the second global page, so atr
+	 * index 1. If TA2 is missing, then the card always is negotiable.
+	 */
+	if (data->atr_nti < 2 ||
+	    (data->atr_ti[1].atrti_flags & ATR_TI_HAVE_TA) == 0) {
+		return (B_TRUE);
+	}
+
+	if (ATR_TA2_CANCHANGE(data->atr_ti[1].atrti_ta)) {
+		return (B_TRUE);
+	}
+
+	return (B_FALSE);
+}
+
+atr_protocol_t
+atr_default_protocol(atr_data_t *data)
+{
+	uint8_t prot;
+
+	if ((data->atr_flags & ATR_F_VALID) == 0)
+		return (ATR_P_NONE);
+	/*
+	 * If we don't have an TA2 byte, then the system defaults to T=0.
+	 */
+	if (data->atr_nti < 2) {
+		return (ATR_P_T0);
+	}
+
+	/*
+	 * If TA2 is present, then it encodes the default protocol. Ohterwise,
+	 * we have to grab the protocol value from TD1, which is called the
+	 * 'first offered protocol'.
+	 */
+	if ((data->atr_ti[1].atrti_flags & ATR_TI_HAVE_TA) != 0) {
+		prot = ATR_TA2_PROTOCOL(data->atr_ti[1].atrti_ta);
+	} else {
+		prot = data->atr_ti[1].atrti_protocol;
+	}
+
+	switch (prot) {
+	case ATR_PROTOCOL_T0:
+		return (ATR_P_T0);
+	case ATR_PROTOCOL_T1:
+		return (ATR_P_T1);
+	default:
+		return (ATR_P_NONE);
+	}
+}
+
+uint8_t
+atr_fi_index(atr_data_t *data)
+{
+	if (data->atr_nti < 1) {
+		return (ATR_FI_DEFAULT_INDEX);
+	}
+
+	/*
+	 * If TA is specified, it is present in TA1. TA2 may override its
+	 * presence, so if it is here, check that first to determine whether or
+	 * not we should check TA1.
+	 */
+	if (data->atr_nti >= 2 &&
+	    (data->atr_ti[1].atrti_flags & ATR_TI_HAVE_TA) != 0) {
+		if (!ATR_TA2_HONORTA1(data->atr_ti[1].atrti_ta)) {
+			return (ATR_FI_DEFAULT_INDEX);
+		}
+	}
+
+	if ((data->atr_ti[0].atrti_flags & ATR_TI_HAVE_TA) != 0) {
+		return (ATR_TA1_FTABLE(data->atr_ti[0].atrti_ta));
+	}
+
+	return (ATR_FI_DEFAULT_INDEX);
+}
+
+uint8_t
+atr_di_index(atr_data_t *data)
+{
+	if (data->atr_nti < 1) {
+		return (ATR_DI_DEFAULT_INDEX);
+	}
+
+	/*
+	 * If TA is specified, it is present in TA1. TA2 may override its
+	 * presence, so if it is here, check that first to determine whether or
+	 * not we should check TA1.
+	 */
+	if (data->atr_nti >= 2 &&
+	    (data->atr_ti[1].atrti_flags & ATR_TI_HAVE_TA) != 0) {
+		if (!ATR_TA2_HONORTA1(data->atr_ti[1].atrti_ta)) {
+			return (ATR_DI_DEFAULT_INDEX);
+		}
+	}
+
+	if ((data->atr_ti[0].atrti_flags & ATR_TI_HAVE_TA) != 0) {
+		return (ATR_TA1_DITABLE(data->atr_ti[0].atrti_ta));
+	}
+
+	return (ATR_DI_DEFAULT_INDEX);
+}
+
+atr_convention_t
+atr_convention(atr_data_t *data)
+{
+	if ((data->atr_flags & ATR_F_USES_DIRECT) != 0) {
+		return (ATR_CONVENTION_DIRECT);
+	}
+	return (ATR_CONVENTION_INVERSE);
+}
+
+uint8_t
+atr_extra_guardtime(atr_data_t *data)
+{
+	if ((data->atr_flags & ATR_F_VALID) == 0)
+		return (ATR_EXTRA_GUARDTIME_DEFAULT);
+
+	if (data->atr_nti >= 1 &&
+	    (data->atr_ti[0].atrti_flags & ATR_TI_HAVE_TC) != 0) {
+		return (data->atr_ti[0].atrti_tc);
+	}
+
+	return (ATR_EXTRA_GUARDTIME_DEFAULT);
+}
+
+uint8_t
+atr_t0_wi(atr_data_t *data)
+{
+	if ((data->atr_flags & ATR_F_VALID) == 0)
+		return (ATR_T0_WI_DEFAULT);
+
+	/*
+	 * This is stored in the optional global byte in TC2; however, it only
+	 * applies to T=0.
+	 */
+	if (data->atr_nti >= 2 &&
+	    data->atr_ti[1].atrti_protocol == ATR_PROTOCOL_T0 &&
+	    (data->atr_ti[1].atrti_flags & ATR_TI_HAVE_TC) != 0) {
+		return (data->atr_ti[1].atrti_tc);
+	}
+
+	return (ATR_T0_WI_DEFAULT);
+}
+
+uint8_t
+atr_t1_cwi(atr_data_t *data)
+{
+	uint8_t i;
+
+	if (data->atr_nti <= 2) {
+		return (ATR_T1_CWI_DEFAULT);
+	}
+
+	for (i = 2; i < data->atr_nti; i++) {
+		if (data->atr_ti[i].atrti_protocol == ATR_PROTOCOL_T1) {
+			if ((data->atr_ti[i].atrti_flags & ATR_TI_HAVE_TB) !=
+			    0) {
+				uint8_t tb = data->atr_ti[i].atrti_tb;
+				return (ATR_T1_TB0_CWI(tb));
+			}
+
+			return (ATR_T1_CWI_DEFAULT);
+		}
+	}
+
+	return (ATR_T1_CWI_DEFAULT);
+}
+
+atr_clock_stop_t
+atr_clock_stop(atr_data_t *data)
+{
+	uint8_t i;
+
+	for (i = 0; i < data->atr_nti; i++) {
+		if (data->atr_ti[i].atrti_protocol == ATR_PROTOCOL_T15) {
+			if ((data->atr_ti[i].atrti_flags & ATR_TI_HAVE_TA) !=
+			    0) {
+				uint8_t ta = data->atr_ti[i].atrti_ta;
+				return (ATR_T15_TA0_CLOCK(ta));
+			}
+
+			return (ATR_CLOCK_STOP_NONE);
+		}
+	}
+
+	return (ATR_CLOCK_STOP_NONE);
+}
+
+atr_t1_checksum_t
+atr_t1_checksum(atr_data_t *data)
+{
+	uint8_t i;
+
+	if (data->atr_nti <= 2) {
+		return (ATR_T1_CHECKSUM_DEFAULT);
+	}
+
+	for (i = 2; i < data->atr_nti; i++) {
+		if (data->atr_ti[i].atrti_protocol == ATR_PROTOCOL_T1) {
+			if ((data->atr_ti[i].atrti_flags & ATR_TI_HAVE_TC) !=
+			    0) {
+				if (ATR_T1_TC0_CRC(data->atr_ti[i].atrti_tc)) {
+					return (ATR_T1_CHECKSUM_CRC);
+				} else {
+					return (ATR_T1_CHECKSUM_LRC);
+				}
+			}
+
+			return (ATR_T1_CHECKSUM_DEFAULT);
+		}
+	}
+
+	return (ATR_T1_CHECKSUM_DEFAULT);
+
+}
+
+uint8_t
+atr_t1_bwi(atr_data_t *data)
+{
+	uint8_t i;
+
+	if (data->atr_nti <= 2) {
+		return (ATR_T1_BWI_DEFAULT);
+	}
+
+	for (i = 2; i < data->atr_nti; i++) {
+		if (data->atr_ti[i].atrti_protocol == ATR_PROTOCOL_T1) {
+			if ((data->atr_ti[i].atrti_flags & ATR_TI_HAVE_TB) !=
+			    0) {
+				uint8_t tb = data->atr_ti[i].atrti_tb;
+				return (ATR_T1_TB0_BWI(tb));
+			}
+
+			return (ATR_T1_BWI_DEFAULT);
+		}
+	}
+
+	return (ATR_T1_BWI_DEFAULT);
+}
+
+uint8_t
+atr_t1_ifsc(atr_data_t *data)
+{
+	uint8_t i;
+
+	if (data->atr_nti <= 2) {
+		return (ATR_T1_IFSC_DEFAULT);
+	}
+
+	for (i = 2; i < data->atr_nti; i++) {
+		if (data->atr_ti[i].atrti_protocol == ATR_PROTOCOL_T1) {
+			if ((data->atr_ti[i].atrti_flags & ATR_TI_HAVE_TA) !=
+			    0) {
+				return (data->atr_ti[i].atrti_ta);
+			}
+
+			return (ATR_T1_IFSC_DEFAULT);
+		}
+	}
+
+	return (ATR_T1_IFSC_DEFAULT);
+}
+
+/*
+ * Attempt to determine which set of data rates we should be able to use for a
+ * given class of protocol. Here we want to do the calculation based on the CCID
+ * specification, section 9.4.x. To use these higher rates we need:
+ *
+ * + Reader's data rate > frequency * Di / Fi.
+ *
+ * To determine which rate and frequency we use, we look at the reader's
+ * features. If the reader supports both the Automatic baud rate and automatic
+ * ICC clock frequency change, then we use the _maximum_ rate. Otherwise we will
+ * indicate that we can use the ATR's properties, but will require changing the
+ * default data rate.
+ *
+ * Now, some ICC devices are not negotiable. In those cases, we'll see if we can
+ * fit it in with either the default or maximum data rates. If not, then we'll
+ * not be able to support this card.
+ *
+ * There are two wrinkles that exist in this. The first is supported frequencies
+ * and data rates. If there are no additional data rates supported, then all of
+ * the data rates between the default and max are supported. If not, then only
+ * those specified in the data rates array are supported.
+ *
+ * The second hurdle is that we need to do this division and try and avoid the
+ * pitfalls of floating point arithmetic, as floating point is not allowed in
+ * the kernel (and this is shared). Importantly that means only integers are
+ * allowed here.
+ */
+/* ARGSUSED */
+atr_data_rate_choice_t
+atr_data_rate(atr_data_t *data, ccid_class_descr_t *class, uint32_t *rates,
+    uint_t nrates, uint32_t *dataratep)
+{
+	uint_t nfeats = CCID_CLASS_F_AUTO_ICC_CLOCK | CCID_CLASS_F_AUTO_BAUD;
+	uint8_t di, fi;
+	uint_t dival, fival;
+	boolean_t autospeed, negotiable, exprates;
+	uint64_t maxval, defval;
+
+	if ((data->atr_flags & ATR_F_VALID) == 0)
+		return (ATR_RATE_UNSUPPORTED);
+
+	di = atr_di_index(data);
+	fi = atr_fi_index(data);
+	dival = atr_di_index_to_value(di);
+	fival = atr_fi_index_to_value(fi);
+	autospeed = (class->ccd_dwFeatures & nfeats) == nfeats;
+	exprates = class->ccd_bNumDataRatesSupported != 0;
+	negotiable = atr_params_negotiable(data);
+
+	/*
+	 * XXX We don't quite support cards with fixed rates at this time as
+	 * it's not clear what that rate should be. If it's negotiable, we'll
+	 * let them run at the default. Otherwise, we have to fail the request
+	 * until we implement the logic to search their data rates.
+	 */
+	if (exprates) {
+		if (negotiable) {
+			return (ATR_RATE_USEDEFAULT);
+		}
+		return (ATR_RATE_UNSUPPORTED);
+	}
+
+	/*
+	 * This indicates that the card gave us values that were reserved for
+	 * future use. If we could negotiate it, then just stick with the
+	 * default paramters. Otherwise, return that we can't support this ICC.
+	 */
+	if (dival == 0 || fival == 0) {
+		if (negotiable)
+			return (ATR_RATE_USEDEFAULT);
+		return (ATR_RATE_UNSUPPORTED);
+	}
+
+	/*
+	 * Calculate the maximum and default values.
+	 */
+	maxval = class->ccd_dwMaximumClock * 1000;
+	maxval *= dival;
+	maxval /= fival;
+
+	defval = class->ccd_dwDefaultClock * 1000;
+	defval *= dival;
+	defval /= fival;
+
+	/*
+	 * We're allowed any set of data rates between the default and the
+	 * maximum. Check if the maximum data rate will work for either the
+	 * default or maximum clock. If so, then we can use the cards rates.
+	 * Otherwise we should use thwe can use the ICC's rates. Otherwise we
+	 * should use the default rates. To account for the fact that we may
+	 * have had a fractional value, we require a strict greater than
+	 * comparison.
+	 */
+	if ((uint64_t)class->ccd_dwMaxDataRate > maxval ||
+	    (uint64_t)class->ccd_dwMaxDataRate > defval) {
+		if (autospeed) {
+			return (ATR_RATE_USEATR);
+		}
+	}
+
+	/*
+	 * If the CCID reader can't handle the ICC's proposed rates, then fall
+	 * back to the defaults if we're allowed to negotiate. Otherwise, we're
+	 * not able to use this ICC.
+	 */
+	if (negotiable) {
+		return (ATR_RATE_USEDEFAULT);
+	}
+
+	return (ATR_RATE_UNSUPPORTED);
+}
+
+void
+atr_data_reset(atr_data_t *data)
+{
+	bzero(data, sizeof (&data));
+}
+
+#ifdef	_KERNEL
+atr_data_t *
+atr_data_alloc(void)
+{
+	return (kmem_zalloc(sizeof (atr_data_t), KM_SLEEP));
+}
+
+void
+atr_data_free(atr_data_t *data)
+{
+	if (data == NULL)
+		return;
+
+	kmem_free(data, sizeof (atr_data_t));
+}
+
+/*
+ * Make sure that the response we got from the ICC is valid. For the ICC to
+ * valid it must pass checksum and have the PPSS value set correctly. The
+ * protocol must match what we requested; however, the PPS1-3 bits are a bit
+ * different. They may only be set in the response if we set them in the
+ * request. However, they do not have to be set in the response.
+ */
+boolean_t
+atr_pps_valid(void *reqbuf, size_t reqlen, void *respbuf, size_t resplen)
+{
+	uint8_t val, i, reqidx, respidx;
+	uint8_t *req = reqbuf, *resp = respbuf;
+
+	if (resplen > PPS_LEN_MAX || resplen < PPS_LEN_MIN)
+		return (B_FALSE);
+
+	/*
+	 * Before we validate the data, make sure the checksum is valid.
+	 */
+	for (i = 0, val = 0; i < resplen; i++) {
+		val ^= resp[i];
+	}
+
+	/* Checksum failure */
+	if (val != 0) {
+		return (B_FALSE);
+	}
+
+	/*
+	 * We should always have PPSS echoed back as we set it.
+	 */
+	if (resp[PPS_PPSS_INDEX] != PPS_PPSS_VAL) {
+		return (B_FALSE);
+	}
+
+	/*
+	 * Go through and make sure the number of bytes present makes sense for
+	 * the number of bits set in PPS1.
+	 */
+	val = PPS_LEN_MIN;
+	if (resp[PPS_PPS0_INDEX] & PPS_PPS0_PPS1)
+		val++;
+	if (resp[PPS_PPS0_INDEX] & PPS_PPS0_PPS2)
+		val++;
+	if (resp[PPS_PPS0_INDEX] & PPS_PPS0_PPS3)
+		val++;
+	if (val != resplen)
+		return (B_FALSE);
+
+	/*
+	 * Now we've finally verified that the response is syntactically valid.
+	 * We must go through and make sure that it is semantically valid.
+	 */
+	if (PPS_PPS0_PROT(req[PPS_PPS0_INDEX]) !=
+	    PPS_PPS0_PROT(resp[PPS_PPS0_INDEX])) {
+		return (B_FALSE);
+	}
+
+	/*
+	 * When checking the PPS bit and extensions, we first check in the
+	 * response as a bit in the request is allowed to not be in the
+	 * response. But not the opposite way around. We also have to keep track
+	 * of the fact that the index for values will vary.
+	 */
+	reqidx = respidx = PPS_PPS0_INDEX + 1;
+	if ((resp[PPS_PPS0_INDEX] & PPS_PPS0_PPS1) != 0) {
+		if ((req[PPS_PPS0_INDEX] & PPS_PPS0_PPS1) == 0) {
+			return (B_FALSE);
+		}
+
+		if (req[reqidx] != resp[respidx]) {
+			return (B_FALSE);
+		}
+
+		reqidx++;
+		respidx++;
+	} else if ((req[PPS_PPS0_INDEX] & PPS_PPS0_PPS1) != 0) {
+		reqidx++;
+	}
+
+	if ((resp[PPS_PPS0_INDEX] & PPS_PPS0_PPS2) != 0) {
+		if ((req[PPS_PPS0_INDEX] & PPS_PPS0_PPS2) == 0) {
+			return (B_FALSE);
+		}
+
+		if (req[reqidx] != resp[respidx]) {
+			return (B_FALSE);
+		}
+
+		reqidx++;
+		respidx++;
+	} else if ((req[PPS_PPS0_INDEX] & PPS_PPS0_PPS2) != 0) {
+		reqidx++;
+	}
+
+	if ((resp[PPS_PPS0_INDEX] & PPS_PPS0_PPS3) != 0) {
+		/*
+		 * At this time, we never specify PPS3 in a request. Therefore
+		 * if it is present in the response, treat this as an invalid
+		 * request.
+		 */
+		return (B_FALSE);
+	}
+
+	return (B_TRUE);
+}
+
+uint_t
+atr_pps_generate(uint8_t *buf, size_t buflen, atr_protocol_t prot,
+    boolean_t pps1, uint8_t fi, uint8_t di, boolean_t pps2, uint8_t spu)
+{
+	uint8_t protval, cksum, i;
+	uint_t len = 0;
+
+	if (buflen < PPS_BUFFER_MAX)
+		return (0);
+
+	buf[PPS_PPSS_INDEX] = PPS_PPSS_VAL;
+	switch (prot) {
+	case ATR_P_T0:
+		protval = 0;
+		break;
+	case ATR_P_T1:
+		protval = 1;
+		break;
+	default:
+		return (0);
+	}
+
+	buf[PPS_PPS0_INDEX] = PPS_PPS0_PROT(protval);
+	len = 2;
+	if (pps1) {
+		buf[PPS_PPS0_INDEX] |= PPS_PPS0_PPS1;
+		buf[len++] = PPS_PPS1_SETVAL(fi, di);
+	}
+
+	if (pps2) {
+		buf[PPS_PPS0_INDEX] |= PPS_PPS0_PPS2;
+		buf[len++] = spu;
+	}
+
+	/*
+	 * The checksum must xor to zero.
+	 */
+	for (i = 0, cksum = 0; i < len; i++) {
+		cksum ^= buf[i];
+	}
+	buf[len++] = cksum;
+	return (len);
+}
+
+/*
+ * The caller of this wants to know if the Fi/Di values that they proposed were
+ * accepted. The caller must have already called atr_pps_valid(). At this point,
+ * we can say that the value was accepted if the PPS1 bit is set.
+ */
+boolean_t
+atr_pps_fidi_accepted(void *respbuf, size_t len)
+{
+	uint8_t *resp = respbuf;
+	return ((resp[PPS_PPS0_INDEX] & PPS_PPS0_PPS1) != 0);
+}
+
+#else	/* !_KERNEL */
+atr_data_t *
+atr_data_alloc(void)
+{
+	return (calloc(sizeof (atr_data_t), 1));
+}
+
+void
+atr_data_free(atr_data_t *data)
+{
+	if (data == NULL)
+		return;
+	free(data);
+}
+
+/*
+ * This table maps the bit values for Fi from 7816-3:2006 section 8.3 Table 9.
+ * The table is up to 6 bits wide. Entries not present are RFU. We use NULL as a
+ * sentinel to indicate that.
+ */
+static const char *atr_voltage_table[64] = {
+	NULL,			/* 00 0000 */
+	"5V",			/* 00 0001 */
+	"3V",			/* 00 0010 */
+	"5V, 3V",		/* 00 0011 */
+	"1.5V",			/* 00 0100 */
+	NULL,			/* 00 0101 */
+	"3V, 1.5V",		/* 00 0110 */
+	"5V, 3V, 1.5V"		/* 00 0111 */
+};
+
+static void
+atr_data_dump_ta(atr_ti_t *atp, FILE *out, uint_t level)
+{
+	uint8_t ta;
+
+	if (!(atp->atrti_flags & ATR_TI_HAVE_TA)) {
+		return;
+	}
+
+	ta = atp->atrti_ta;
+	(void) fprintf(out, "   %c%c%c+-> TA%u 0x%02x",
+	    atp->atrti_flags & ATR_TI_HAVE_TD ? '|' : ' ',
+	    atp->atrti_flags & ATR_TI_HAVE_TC ? '|' : ' ',
+	    atp->atrti_flags & ATR_TI_HAVE_TB ? '|' : ' ',
+	    atp->atrti_ti_val, ta);
+	switch (atp->atrti_ti_val) {
+	case 1:
+		(void) fprintf(out, "; Fi: %s, F(max): %s MHz, Di: %s",
+		    atr_fi_table[ATR_TA1_FTABLE(ta)],
+		    atr_fmax_table[ATR_TA1_FTABLE(ta)],
+		    atr_di_table[ATR_TA1_DITABLE(ta)]);
+		break;
+	case 2:
+		(void) fprintf(out, "; ICC in %s mode; %shonoring TA1; default "
+		    "T=%u",
+		    ATR_TA2_CANCHANGE(ta) ? "negotiable" : "specific",
+		    ATR_TA2_HONORTA1(ta) ? "" : "not ",
+		    ATR_TA2_PROTOCOL(ta));
+		break;
+	default:
+		switch (atp->atrti_protocol) {
+		case ATR_PROTOCOL_T1:
+			if (level != 0)
+				break;
+			if (ta == 0 || ta == 0xff) {
+				(void) fprintf(out, "; IFSC: RFU");
+			} else {
+				(void) fprintf(out, "; IFSC: %u", ta);
+			}
+			break;
+		case ATR_PROTOCOL_T15:
+			if (level != 0)
+				break;
+			(void) fprintf(out, "; Clock stop: %s, Supported "
+			    "Voltage: %s",
+			    atr_clock_table[ATR_T15_TA0_CLOCK(ta)],
+			    atr_voltage_table[ATR_T15_TA0_VOLTAGE(ta)] != NULL ?
+			    atr_voltage_table[ATR_T15_TA0_VOLTAGE(ta)] : "RFU");
+			break;
+		default:
+			break;
+		}
+	}
+	(void) fprintf(out, "\n");
+}
+
+static void
+atr_data_dump_tb(atr_ti_t *atp, FILE *out, uint_t level)
+{
+	uint8_t tb;
+
+	if (!(atp->atrti_flags & ATR_TI_HAVE_TB)) {
+		return;
+	}
+
+	tb = atp->atrti_tb;
+	(void) fprintf(out, "   %c%c+--> TB%u 0x%02x",
+	    atp->atrti_flags & ATR_TI_HAVE_TD ? '|' : ' ',
+	    atp->atrti_flags & ATR_TI_HAVE_TC ? '|' : ' ',
+	    atp->atrti_ti_val, tb);
+	switch (atp->atrti_ti_val) {
+	case 1:
+	case 2:
+		(void) fprintf(out, "; deprecated");
+		break;
+	default:
+		switch (atp->atrti_protocol) {
+		case ATR_PROTOCOL_T1:
+			if (level != 0)
+				break;
+			(void) fprintf(out, "; CWI: %u, BWI: %u\n",
+			    ATR_T1_TB0_CWI(tb),
+			    ATR_T1_TB0_BWI(tb));
+			break;
+		case ATR_PROTOCOL_T15:
+			if (level != 0)
+				break;
+			/* XXX Find how to decode these */
+			(void) fprintf(out, "; SPU: %s",
+			    ATR_T15_TB0_SPU_STANDARD(tb) ? "standard" :
+			    "proprietary");
+			break;
+		default:
+			break;
+		}
+	}
+	(void) fprintf(out, "\n");
+}
+
+static void
+atr_data_dump_tc(atr_ti_t *atp, FILE *out, uint_t level)
+{
+	uint8_t tc;
+
+	if (!(atp->atrti_flags & ATR_TI_HAVE_TC)) {
+		return;
+	}
+
+	tc = atp->atrti_tc;
+	(void) fprintf(out, "   %c+---> TC%u 0x%02x",
+	    atp->atrti_flags & ATR_TI_HAVE_TD ? '|' : ' ',
+	    atp->atrti_ti_val, tc);
+
+	switch (atp->atrti_ti_val) {
+	case 1:
+		(void) fprintf(out, "; Extra Guard Time Integer: %u", tc);
+		break;
+	case 2:
+		if (atp->atrti_protocol != ATR_PROTOCOL_T0) {
+			(void) fprintf(out, "; illegal value -- only valid for "
+			    "T=0");
+		} else {
+			(void) fprintf(out, "; Waiting Time Integer: %u", tc);
+		}
+		break;
+	default:
+		switch (atp->atrti_protocol) {
+		case ATR_PROTOCOL_T1:
+			if (level != 0)
+				break;
+			(void) fprintf(out, "; Error Detection Code: %s",
+			    ATR_T1_TC0_CRC(tc) ? "CRC" : "LRC");
+			break;
+		default:
+			break;
+		}
+	}
+	(void) fprintf(out, "\n");
+}
+
+static void
+atr_data_hexdump_historical(atr_data_t *data, FILE *out)
+{
+	size_t i;
+	(void) fprintf(out, "Dumping raw historical bytes\n");
+
+	/* Print out the header */
+	(void) printf("%*s    0", 4, "");
+	for (i = 1; i < 16; i++) {
+		if (i % 4 == 0 && i % 16 != 0) {
+			(void) printf(" ");
+		}
+
+		(void) printf("%2x", i);
+	}
+	(void) printf("  0123456789abcdef\n");
+
+	for (i = 0; i < data->atr_nhistoric; i++) {
+
+		if (i % 16 == 0) {
+			(void) printf("%04x:  ", i);
+		}
+
+		if (i % 4 == 0 && i % 16 != 0) {
+			(void) printf(" ");
+		}
+
+		(void) printf("%02x", data->atr_historic[i]);
+	}
+
+	for (; (i % 16) != 0; i++) {
+		if (i % 4 == 0 && i % 16 != 0) {
+			(void) printf(" ");
+		}
+		(void) printf("--");
+	}
+
+	(void) printf("  ");
+	for (i = 0; i < data->atr_nhistoric; i++) {
+		if (!isprint(data->atr_historic[i])) {
+			(void) printf(".");
+		} else {
+			(void) printf("%c", data->atr_historic[i]);
+		}
+	}
+	(void) printf("\n");
+}
+
+static void
+atr_data_dump_historical(atr_data_t *data, FILE *out)
+{
+	uint8_t cat;
+
+	(void) fprintf(out, "Historic Data: %u bytes", data->atr_nhistoric);
+	if (data->atr_nhistoric == 0) {
+		(void) fprintf(out, "\n");
+		return;
+	}
+
+	cat = data->atr_historic[0];
+	(void) fprintf(out, "; format (0x%02x) ", cat);
+	if (cat == ATR_HIST_CAT_MAND_STATUS) {
+
+	} else if (cat == ATR_HIST_CAT_TLV_STATUS) {
+
+	} else if (cat >= ATR_HIST_CAT_RFU_MIN && cat <= ATR_HIST_CAT_RFU_MAX) {
+		(void) fprintf(out, "reserved\n");
+		atr_data_hexdump_historical(data, out);
+		return;
+	} else {
+		(void) fprintf(out, "proprietary\n");
+		atr_data_hexdump_historical(data, out);
+		return;
+	}
+
+	/*
+	 * XXX Process one or more TLVs.
+	 */
+}
+
+void
+atr_data_dump(atr_data_t *data, FILE *out)
+{
+	uint8_t i, level;
+	if ((data->atr_flags & ATR_F_VALID) == 0)
+		return;
+
+	(void) fprintf(out, "TS  0x%02u - ", data->atr_raw[0]);
+	if (data->atr_flags & ATR_F_USES_DIRECT) {
+		(void) fprintf(out, "direct convention\n");
+	} else {
+		(void) fprintf(out, "inverse convention\n");
+	}
+
+	level = 0;
+	for (i = 0; i < data->atr_nti; i++) {
+		atr_ti_t *atp = &data->atr_ti[i];
+
+		/*
+		 * Various protocols may appear multiple times, indicating
+		 * different sets of bits each time. When dealing with T0 and
+		 * TD1, the protocol doesn't matter. Otherwise if we have the
+		 * same value, we should increment this.
+		 */
+		if (i <= 2) {
+			level = 0;
+		} else if (atp->atrti_protocol ==
+		    data->atr_ti[i - 1].atrti_protocol) {
+			level++;
+		} else {
+			level = 0;
+		}
+
+		if (i == 0) {
+			(void) fprintf(out, "T0  ");
+		} else {
+			(void) fprintf(out, "TD%u ", i);
+		}
+		(void) fprintf(out, "0x%02x\n",
+		    data->atr_raw[atp->atrti_td_idx]);
+		(void) fprintf(out, "      |+-> ");
+		if (i == 0) {
+			(void) fprintf(out, "%u historical bytes\n",
+			    data->atr_nhistoric);
+		} else {
+			(void) fprintf(out, "protocol T=%u\n",
+			    atp->atrti_protocol);
+		}
+		(void) fprintf(out, "      v\n");
+		(void) fprintf(out, " 0r%u%u%u%u\n",
+		    atp->atrti_flags & ATR_TI_HAVE_TD ? 1 : 0,
+		    atp->atrti_flags & ATR_TI_HAVE_TC ? 1 : 0,
+		    atp->atrti_flags & ATR_TI_HAVE_TB ? 1 : 0,
+		    atp->atrti_flags & ATR_TI_HAVE_TA ? 1 : 0);
+
+		atr_data_dump_ta(atp, out, level);
+		atr_data_dump_tb(atp, out, level);
+		atr_data_dump_tc(atp, out, level);
+		if (atp->atrti_flags & ATR_TI_HAVE_TD) {
+			(void) fprintf(out, "   v\n");
+		}
+	}
+
+	atr_data_dump_historical(data, out);
+
+	if (data->atr_flags & ATR_F_HAS_CHECKSUM) {
+		(void) fprintf(out, "TCK  0x%02x\n", data->atr_cksum);
+	} else {
+		(void) fprintf(out, "TCK  ----; Checksum not present\n");
+	}
+
+}
+#endif	/* _KERNEL */
diff --git a/usr/src/common/ccid/atr.h b/usr/src/common/ccid/atr.h
new file mode 100644
index 0000000000..c559c94115
--- /dev/null
+++ b/usr/src/common/ccid/atr.h
@@ -0,0 +1,197 @@
+/*
+ * This file and its contents are supplied under the terms of the
+ * Common Development and Distribution License ("CDDL"), version 1.0.
+ * You may only use this file in accordance with the terms of version
+ * 1.0 of the CDDL.
+ *
+ * A full copy of the text of the CDDL should have accompanied this
+ * source.  A copy of the CDDL is also available via the Internet at
+ * http://www.illumos.org/license/CDDL.
+ */
+
+/*
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+
+#ifndef _ATR_H
+#define	_ATR_H
+
+/*
+ * Parse Anser-To-Reset values. This header file is private to illumos and
+ * should not be shipped or used by applications.
+ *
+ * This is based on ISO/IEC 7816-3:2006. It has been designed such that if newer
+ * revisions come out that define reserved values, they will be ignored until
+ * this code is updated.
+ */
+
+#include <sys/types.h>
+#include <sys/usb/clients/ccid/ccid.h>
+#ifndef	_KERNEL
+#include <stdio.h>
+#endif
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*
+ * The ATR must have at least 2 bytes and then may have up to 33 bytes.
+ */
+#define	ATR_LEN_MIN	2
+#define	ATR_LEN_MAX	33
+
+typedef enum atr_parsecode {
+	ATR_CODE_OK	= 0,
+	ATR_CODE_TOO_SHORT,
+	ATR_CODE_TOO_LONG,
+	ATR_CODE_INVALID_TS,
+	ATR_CODE_OVERRUN,
+	ATR_CODE_UNDERRUN,
+	ATR_CODE_CHECKSUM_ERROR,
+	ATR_CODE_INVALID_TD1
+} atr_parsecode_t;
+
+typedef enum atr_protocol {
+	ATR_P_NONE	= 0,
+	ATR_P_T0	= 1 << 0,
+	ATR_P_T1	= 1 << 1
+} atr_protocol_t;
+
+typedef enum atr_convention {
+	ATR_CONVENTION_DIRECT 	= 0x00,
+	ATR_CONVENTION_INVERSE 	= 0x01
+} atr_convention_t;
+
+typedef enum atr_clock_stop {
+	ATR_CLOCK_STOP_NONE	= 0x00,
+	ATR_CLOCK_STOP_LOW	= 0x01,
+	ATR_CLOCK_STOP_HI	= 0x02,
+	ATR_CLOCK_STOP_BOTH	= 0x03
+} atr_clock_stop_t;
+
+typedef enum atr_data_rate_choice {
+	/*
+	 * Indicates that the reader cannot support the data rate needed for the
+	 * ICC.
+	 */
+	ATR_RATE_UNSUPPORTED	= 0x00,
+	/*
+	 * Indicates that the reader supports the ICC present, but must run at
+	 * the protocol's default rate (Di index = Fi index = 1)
+	 */
+	ATR_RATE_USEDEFAULT	= 0x01,
+	/*
+	 * The reader supports the Di/Fi values that the ICC proposed in its ATR
+	 * and no action beyond setting the parameters of the reader is required
+	 * (this may be automatic depending on the reader's dwFeatures).
+	 */
+	ATR_RATE_USEATR		= 0x02,
+	/*
+	 * The reader can use the features of the ATR specified. However, it
+	 * must change the data rate or frequency that the card is running at to
+	 * proceed.
+	 */
+	ATR_RATE_USEATR_SETRATE	= 0x03
+} atr_data_rate_choice_t;
+
+typedef enum atr_t1_checksum {
+	ATR_T1_CHECKSUM_LRC	= 0x00,
+	ATR_T1_CHECKSUM_CRC	= 0x01
+} atr_t1_checksum_t;
+
+typedef struct atr_data atr_data_t;
+
+/*
+ * Allocate and free ATR data.
+ */
+extern atr_data_t *atr_data_alloc(void);
+extern void atr_data_free(atr_data_t *);
+
+/*
+ * Reset an allocated ATR data to be ready to parse something else.
+ */
+extern void atr_data_reset(atr_data_t *);
+
+/*
+ * Parse the ATR data into an opaque structure that organizes the data and
+ * allows for various queries to be made on it later.
+ */
+extern atr_parsecode_t atr_parse(const uint8_t *, size_t, atr_data_t *data);
+extern const char *atr_strerror(atr_parsecode_t);
+
+/*
+ * Get an eumeration of supported protocols in this ATR data. Note that if a
+ * reserved protocol is encountered, we may not report it as we don't know of it
+ * at this time.
+ */
+extern atr_protocol_t atr_supported_protocols(atr_data_t *);
+
+/*
+ * Based on the ATR determine what the default protocol is and whether or not it
+ * supports negotiation. When a ICC is not negotiable, it will always start up
+ * with a sepcific protocol and parameters based on the ATR and be ready to use.
+ * Otherwise, the card will be in a negotiable mode and be set to a default set
+ * of parameters.
+ */
+extern boolean_t atr_params_negotiable(atr_data_t *);
+extern atr_protocol_t atr_default_protocol(atr_data_t *);
+
+/*
+ * Protocol default values.
+ */
+extern uint8_t atr_fi_default_index(void);
+extern uint8_t atr_di_default_index(void);
+
+/*
+ * Obtain the table indexes that should be used by the device.
+ */
+extern uint8_t atr_fi_index(atr_data_t *);
+extern uint8_t atr_di_index(atr_data_t *);
+extern atr_convention_t atr_convention(atr_data_t *);
+extern uint8_t atr_extra_guardtime(atr_data_t *);
+extern uint8_t atr_t0_wi(atr_data_t *);
+extern atr_t1_checksum_t atr_t1_checksum(atr_data_t *);
+extern uint8_t atr_t1_bwi(atr_data_t *);
+extern uint8_t atr_t1_cwi(atr_data_t *);
+extern atr_clock_stop_t atr_clock_stop(atr_data_t *);
+extern uint8_t atr_t1_ifsc(atr_data_t *);
+
+/*
+ * Use this function to determine what set of Di and Fi values should be used by
+ * a reader, based on the parameters from the ATR and the reader's cclass.
+ */
+extern atr_data_rate_choice_t atr_data_rate(atr_data_t *, ccid_class_descr_t *,
+    uint32_t *, uint_t, uint32_t *);
+
+#ifndef	_KERNEL
+extern void atr_data_dump(atr_data_t *, FILE *);
+#endif
+
+/*
+ * String and table index values.
+ */
+extern const char *atr_protocol_to_string(atr_protocol_t);
+extern uint_t atr_fi_index_to_value(uint8_t);
+extern const char *atr_fi_index_to_string(uint8_t);
+extern const char *atr_fmax_index_to_string(uint8_t);
+extern uint_t atr_di_index_to_value(uint8_t);
+extern const char *atr_di_index_to_string(uint8_t);
+extern const char *atr_clock_stop_to_string(atr_clock_stop_t);
+extern const char *atr_convention_to_string(atr_convention_t);
+
+/*
+ * Functions for generating and testing PPS values. Before calling
+ * atr_pps_fidi_accepted(), one must call atr_pps_valid().
+ */
+#define	PPS_BUFFER_MAX	6
+extern uint_t atr_pps_generate(uint8_t *, size_t, atr_protocol_t, boolean_t,
+    uint8_t, uint8_t, boolean_t, uint8_t);
+extern boolean_t atr_pps_valid(void *, size_t, void *, size_t);
+extern boolean_t atr_pps_fidi_accepted(void *, size_t);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _ATR_H */
diff --git a/usr/src/common/ccid/ccid_t1.c b/usr/src/common/ccid/ccid_t1.c
new file mode 100644
index 0000000000..5ce5d1e018
--- /dev/null
+++ b/usr/src/common/ccid/ccid_t1.c
@@ -0,0 +1,928 @@
+/*
+ * This file and its contents are supplied under the terms of the
+ * Common Development and Distribution License ("CDDL"), version 1.0.
+ * You may only use this file in accordance with the terms of version
+ * 1.0 of the CDDL.
+ *
+ * A full copy of the text of the CDDL should have accompanied this
+ * source.  A copy of the CDDL is also available via the Internet at
+ * http://www.illumos.org/license/CDDL.
+ */
+
+/*
+ * Copyright (c) 2017 Joyent, Inc.
+ */
+
+/*
+ * This implements the T=1 protocol state machine. It is implemented in common
+ * code so it can be plugged into testing frameworks in userland without needing
+ * the full CCID driver.
+ */
+
+#include <atr.h>
+#include <ccid_t1.h>
+
+#include <sys/sysmacros.h>
+#include <sys/debug.h>
+#include <sys/strsun.h>
+#ifdef _KERNEL
+#include <sys/types.h>
+#include <sys/sunddi.h>
+#include <sys/varargs.h>
+#include <sys/strsubr.h>
+#else
+#include <strings.h>
+#include <stdio.h>
+#include <stdarg.h>
+#endif
+
+/*
+ * Track the state of the T=1 protocol. In general, there is a notion of us
+ * sending a series of one or more blocks that may be chained. Each block will
+ * receive an acknowledgement. When we send the last block that we care about,
+ * then we will receive a response which will consist of one or more blocks.
+ *
+ * These data blocks are called I-blocks. The acknowledgement blocks are called
+ * R-blocks. There are also a special third type of block called S-blocks. The
+ * S-Blocks are not used for data, but for protocol-level requests.
+ *
+ * The OS will always initiate requests. The ICC cannot initiate requests.
+ *
+ * There are a series of conditions that may cause the transmission to fail. In
+ * the T=1 specification, these transition us to a series of escalating retry
+ * steps:
+ *
+ *   o Retransmission
+ *   o Use of S(RESYNCH) request
+ *   o Warm reset
+ *
+ * The rest of this file provides routines to construct headers, epilogues, and
+ * more.
+ */
+
+typedef enum {
+	T1_T_IBLOCK,
+	T1_T_RBLOCK,
+	T1_T_SBLOCK
+} t1_block_type_t;
+
+const char *
+t1_errmsg(t1_state_t *t1)
+{
+	return (t1->t1_msgbuf);
+}
+
+static t1_validate_t
+t1_invalid(t1_state_t *t1, t1_validate_t v, const char *fmt, ...)
+{
+	va_list ap;
+
+	t1->t1_validate = v;
+	va_start(ap, fmt);
+	(void) vsnprintf(t1->t1_msgbuf, sizeof (t1->t1_msgbuf), fmt, ap);
+	va_end(ap);
+	return (v);
+}
+
+/*
+ * Initialize all of our T=1 state when a new ICC has been inserted.
+ */
+void
+t1_state_icc_init(t1_state_t *t1, atr_data_t *atr, size_t maxlen)
+{
+	size_t csz;
+	uint8_t t1len, ifsc;
+
+	/*
+	 * Before we reinitialize, if any reply chain had been left behind, free
+	 * it.
+	 */
+	freemsgchain(t1->t1_reply_chain);
+	bzero(t1, sizeof (t1_state_t));
+
+	t1len = sizeof (t1_hdr_t);
+	t1->t1_checksum = atr_t1_checksum(atr);
+	switch (t1->t1_checksum) {
+	case ATR_T1_CHECKSUM_LRC:
+		t1len += T1_LRC_LENGTH;
+		break;
+	case ATR_T1_CHECKSUM_CRC:
+		t1len += T1_CRC_LENGTH;
+		break;
+	}
+
+	/*
+	 * When looking at our maximum buffer size, we need to subtract both the
+	 * CCID header length and the length of a t1 prologue and epilogue.
+	 * The length field for a T1 header is a uint8_t. Therefore, if the
+	 * card's size is larger for some reason, we further shrink that amount
+	 * to fit within our constraints.
+	 */
+	csz = maxlen - sizeof (ccid_header_t) - t1len;
+	if (csz > T1_SIZE_MAX)
+		csz = T1_SIZE_MAX;
+	ifsc = atr_t1_ifsc(atr);
+	t1->t1_maxlen = MIN((uint8_t)csz, ifsc);
+	t1->t1_protlen = t1len;
+	t1->t1_send_ns = T1_IBLOCK_NS_DEFVAL;
+	t1->t1_recv_ns = T1_IBLOCK_NS_DEFVAL;
+
+	t1->t1_flags |= T1_F_ICC_INIT;
+}
+
+void
+t1_state_icc_fini(t1_state_t *t1)
+{
+	VERIFY(t1->t1_flags & T1_F_ICC_INIT);
+	VERIFY0(t1->t1_flags & T1_F_ALL_CMD_FLAGS);
+	VERIFY3P(t1->t1_reply_chain, ==, NULL);
+
+	bzero(t1, sizeof (*t1));
+}
+
+/*
+ * A new command has been started. Reset all of our state tracking for this new
+ * command.
+ */
+void
+t1_state_cmd_init(t1_state_t *t1, const void *ubuf, size_t ulen)
+{
+	VERIFY((t1->t1_flags & T1_F_ICC_INIT) != 0);
+
+	t1->t1_ubuf = ubuf;
+	t1->t1_ulen = ulen;
+	t1->t1_uoff = 0;
+
+	bzero(t1->t1_cmdbuf, sizeof (t1->t1_cmdbuf));
+	t1->t1_cmdlen = 0;
+	bzero(t1->t1_altbuf, sizeof (t1->t1_altbuf));
+	t1->t1_altlen = 0;
+
+	/*
+	 * If any mblk chain has been left behind, clean it up now.
+	 */
+	freemsgchain(t1->t1_reply_chain);
+	t1->t1_reply_chain = NULL;
+	t1->t1_flags |= T1_F_CMD_SENDING;
+}
+
+mblk_t *
+t1_state_cmd_reply_take(t1_state_t *t1)
+{
+	mblk_t *mp;
+	VERIFY3U(t1->t1_flags & T1_F_CMD_DONE, !=, 0);
+	mp = t1->t1_reply_chain;
+	t1->t1_reply_chain = NULL;
+	return (mp);
+}
+
+/*
+ * The user has told us that they're done. Clean up some of the initial state to
+ * make it ready again.
+ */
+void
+t1_state_cmd_fini(t1_state_t *t1)
+{
+	t1->t1_flags &= ~T1_F_ALL_CMD_FLAGS;
+	t1->t1_ubuf = NULL;
+	t1->t1_ulen = 0;
+	t1->t1_uoff = 0;
+	bzero(t1->t1_cmdbuf, sizeof (t1->t1_cmdbuf));
+	bzero(t1->t1_altbuf, sizeof (t1->t1_altbuf));
+	t1->t1_validate = T1_VALIDATE_OK;
+	bzero(t1->t1_msgbuf, sizeof (t1->t1_msgbuf));
+	t1->t1_resend_count = 0;
+	freemsgchain(t1->t1_reply_chain);
+	t1->t1_reply_chain = NULL;
+}
+
+static void
+t1_header_iblock(t1_hdr_t *hdr, uint8_t ns, boolean_t chain, uint8_t len)
+{
+	VERIFY3U(len, <=, T1_SIZE_MAX);
+
+	hdr->t1h_nad = 0;
+	hdr->t1h_pcb = T1_TYPE_IBLOCK;
+
+	if ((ns & 0x1) != 0) {
+		hdr->t1h_pcb |= T1_IBLOCK_NS;
+	}
+
+	if (chain) {
+		hdr->t1h_pcb |= T1_IBLOCK_M;
+	}
+
+	hdr->t1h_len = len;
+}
+
+static void
+t1_header_rblock(t1_hdr_t *hdr, uint8_t nr, t1_rblock_status_t status)
+{
+	hdr->t1h_nad = 0;
+	hdr->t1h_pcb = T1_TYPE_RBLOCK;
+	if ((nr & 0x1) != 0) {
+		hdr->t1h_pcb |= T1_RBLOCK_NR;
+	}
+	hdr->t1h_pcb |= status;
+	hdr->t1h_len = 0;
+}
+
+static void
+t1_header_sblock(t1_hdr_t *hdr, t1_sblock_op_t op, uint8_t len)
+{
+	hdr->t1h_nad = 0;
+	hdr->t1h_pcb = T1_TYPE_SBLOCK | op;
+	hdr->t1h_len = len;
+}
+
+/*
+ * Checksum len bytes of buf and then store the checksum.
+ */
+static uint8_t
+t1_checksum_lrc(const uint8_t *buf, size_t len)
+{
+	uint8_t cksum = 0;
+	size_t i;
+
+	for (i = 0; i < len; i++) {
+		cksum ^= buf[i];
+	}
+
+	return (cksum);
+}
+
+static void
+t1_checksum(t1_state_t *t1, void *buf, size_t len)
+{
+	uint8_t *u8 = buf;
+	switch (t1->t1_checksum) {
+	case ATR_T1_CHECKSUM_LRC:
+		u8[len] = t1_checksum_lrc(buf, len);
+		break;
+	case ATR_T1_CHECKSUM_CRC:
+	default:
+		/* XXX Implement me */
+		VERIFY(0);
+	}
+}
+
+static boolean_t
+t1_checksum_check(t1_state_t *t1, const void *buf, size_t len)
+{
+	uint8_t val;
+	switch (t1->t1_checksum) {
+	case ATR_T1_CHECKSUM_LRC:
+		val = t1_checksum_lrc(buf, len);
+		return (val == 0);
+	case ATR_T1_CHECKSUM_CRC:
+	default:
+		/* XXX Implement me */
+		return (B_FALSE);
+	}
+
+}
+
+static t1_validate_t
+t1_validate_hdr(t1_state_t *t1, const void *buf, size_t len,
+    t1_block_type_t *typep)
+{
+	uint8_t seq;
+	const t1_hdr_t *hdr;
+
+	/*
+	 * Do we have enough data to cover the protocol prologue and epilogue?
+	 */
+	if (len < t1->t1_protlen) {
+		return (t1_invalid(t1, T1_VALIDATE_SHORT, "data payload (%ld) "
+		    "less than required protocol length (%u)", len,
+		    t1->t1_protlen));
+	}
+
+	/*
+	 * We have a slight Chicken and Egg problem. We want to look at the
+	 * contents of the T=1 header, but it may not have passed its checksum.
+	 * To deal with that we start with the assumption that we got all the
+	 * data that we expect. In other words that the ccid length equals the
+	 * message block length. We'll validate the checksum based on that raw
+	 * data. Later, we'll go back and make sure that the header makes
+	 * semantic sense.
+	 */
+	if (!t1_checksum_check(t1, buf, len)) {
+		return (t1_invalid(t1, T1_VALIDATE_BAD_CKSUM,
+		    "invalid checksum"));
+	}
+
+	hdr = buf;
+	if (hdr->t1h_nad != T1_DEFAULT_NAD) {
+		return (t1_invalid(t1, T1_VALIDATE_BAD_NAD, "received invalid "
+		    "NAD value %u, expected %u", hdr->t1h_nad, T1_DEFAULT_NAD));
+	}
+
+	if ((hdr->t1h_pcb & T1_TYPE_IMASK) == T1_TYPE_IBLOCK) {
+		*typep = T1_T_IBLOCK;
+
+		if ((hdr->t1h_pcb & T1_IBLOCK_RSVD) != 0) {
+			return (t1_invalid(t1, T1_VALIDATE_BAD_RBLOCK,
+			    "received I-block with non-zero reserved bits: %x",
+			    hdr->t1h_pcb & T1_IBLOCK_RSVD));
+		}
+
+		/*
+		 * Check the length. We save checking for a length of zero in
+		 * other conditions, as it may or may not be valid depending on
+		 * the chaining situation.
+		 *
+		 * XXX Maybe we should add a chaining flag and check it here.
+		 * But we'd want to make sure it was the last entry in the chain
+		 * only.
+		 */
+		if (hdr->t1h_len == T1_INF_RESERVED) {
+			return (t1_invalid(t1, T1_VALIDATE_RESV_LEN,
+			    "received I-block with reserved length: %u",
+			    T1_INF_RESERVED));
+		}
+
+		/*
+		 * Check the sequence value. Because we've received a I-block,
+		 * we need to check against the receiving value.
+		 */
+		seq = (hdr->t1h_pcb & T1_IBLOCK_NS) != 0;
+		if (seq != t1->t1_recv_ns) {
+			return (t1_invalid(t1, T1_VALIDATE_BAD_NS,
+			    "received I-block with opposite NS value, expected "
+			    "%u", t1->t1_recv_ns));
+		}
+	} else if ((hdr->t1h_pcb & T1_TYPE_RSMASK) == T1_TYPE_RBLOCK) {
+		*typep = T1_T_RBLOCK;
+
+		if ((hdr->t1h_pcb & T1_RBLOCK_RESV_MASK) != 0) {
+			return (t1_invalid(t1, T1_VALIDATE_BAD_RBLOCK,
+			    "received R-block with reserved bits set in PCB: "
+			    "0x%x", hdr->t1h_pcb));
+		}
+
+		switch (hdr->t1h_pcb & T1_RBLOCK_STATUS_MASK) {
+		case T1_RBLOCK_STATUS_OK:
+		case T1_RBLOCK_STATUS_PARITY:
+		case T1_RBLOCK_STATUS_ERROR:
+			break;
+		default:
+			return (t1_invalid(t1, T1_VALIDATE_BAD_RBLOCK,
+			    "received R-block with reserved status: 0x%x",
+			    hdr->t1h_pcb & T1_RBLOCK_STATUS_MASK));
+		}
+
+		/*
+		 * We explicitly don't validate the value in N(R). Because the
+		 * way that it is used will vary between normal and error based
+		 * operation.
+		 */
+		if (hdr->t1h_len != 0) {
+			return (t1_invalid(t1, T1_VALIDATE_BAD_LEN, "invalid "
+			    "header length, expected 0, received %u",
+			    hdr->t1h_len));
+		}
+	} else if ((hdr->t1h_pcb & T1_TYPE_RSMASK) == T1_TYPE_SBLOCK) {
+		uint8_t explen;
+
+		*typep = T1_T_SBLOCK;
+
+		switch (hdr->t1h_pcb & T1_SBLOCK_OP_MASK) {
+		case T1_SBLOCK_REQ_RESYNCH:
+		case T1_SBLOCK_RESP_RSYNCH:
+		case T1_SBLOCK_REQ_ABORT:
+		case T1_SBLOCK_RESP_ABORT:
+			explen = 0;
+			break;
+		case T1_SBLOCK_REQ_WTX:
+		case T1_SBLOCK_RESP_WTX:
+		case T1_SBLOCK_REQ_IFS:
+		case T1_SBLOCK_RESP_IFS:
+			explen = 1;
+			break;
+		default:
+			return (t1_invalid(t1, T1_VALIDATE_BAD_SBLOCK_OP,
+			    "Found invalid S-block operation: %x",
+			    hdr->t1h_pcb & T1_SBLOCK_OP_MASK));
+		}
+
+		if (explen != hdr->t1h_len) {
+			return (t1_invalid(t1, T1_VALIDATE_BAD_LEN, "header "
+			    "length value (%d) does not match length required "
+			    "for S-block (%d)", hdr->t1h_len, explen));
+		}
+	} else {
+		return (t1_invalid(t1, T1_VALIDATE_BAD_PCB, "received invalid "
+		    "PCB header type: %u", hdr->t1h_pcb & T1_TYPE_RSMASK));
+	}
+
+	if (hdr->t1h_len + t1->t1_protlen != len) {
+		return (t1_invalid(t1, T1_VALIDATE_BAD_LEN, "t1 message "
+		    "logical length (%u), does not match actual length (%u)",
+		    hdr->t1h_len + t1->t1_protlen, len));
+	}
+
+	return (T1_VALIDATE_OK);
+}
+
+/*
+ * XXX Commonize with the above. This should only have a check that it's an
+ * sblock, that it's the right op, and the value.
+ */
+static t1_validate_t
+t1_validate_sblock(t1_state_t *t1, const void *buf, size_t len,
+    t1_sblock_op_t op)
+{
+	uint8_t explen;
+	const t1_hdr_t *hdr;
+
+	/*
+	 * Do we have enough data to cover the protocol prologue and epilogue?
+	 */
+	if (len < t1->t1_protlen) {
+		return (t1_invalid(t1, T1_VALIDATE_SHORT, "data payload (%ld) "
+		    "less than required protocol length (%u)", len,
+		    t1->t1_protlen));
+	}
+
+	/*
+	 * We have a slight Chicken and Egg problem. We want to look at the
+	 * contents of the T=1 header, but it may not have passed its checksum.
+	 * To deal with that we start with the assumption that we got all the
+	 * data that we expect. In other words that the ccid length equals the
+	 * message block length. We'll validate the checksum based on that raw
+	 * data. Later, we'll go back and make sure that the header makes
+	 * semantic sense.
+	 */
+	if (!t1_checksum_check(t1, buf, len)) {
+		return (t1_invalid(t1, T1_VALIDATE_BAD_CKSUM,
+		    "invalid checksum"));
+	}
+
+	hdr = buf;
+	if (hdr->t1h_nad != T1_DEFAULT_NAD) {
+		return (t1_invalid(t1, T1_VALIDATE_BAD_NAD, "received invalid "
+		    "NAD value %u, expected %u", hdr->t1h_nad, T1_DEFAULT_NAD));
+	}
+
+
+	if ((hdr->t1h_pcb & T1_TYPE_RSMASK) != T1_TYPE_SBLOCK) {
+		return (t1_invalid(t1, T1_VALIDATE_BAD_PCB, "invalid pcb mode "
+		    "bits for S-block. Expected %u, found %u", T1_TYPE_SBLOCK,
+		    hdr->t1h_pcb & T1_TYPE_RSMASK));
+	}
+
+	if ((hdr->t1h_pcb & T1_SBLOCK_OP_MASK) != op) {
+		return (t1_invalid(t1, T1_VALIDATE_BAD_SBLOCK_OP, "found wrong "
+		    "S-block operation. Expected %x, found %x", op,
+		    hdr->t1h_pcb & T1_SBLOCK_OP_MASK));
+	}
+
+	/* XXX This had some gcc7 warnings, come back and verify it's correct */
+	switch (op) {
+	case T1_SBLOCK_REQ_RESYNCH:
+	case T1_SBLOCK_RESP_RSYNCH:
+	case T1_SBLOCK_REQ_ABORT:
+	case T1_SBLOCK_RESP_ABORT:
+		explen = 0;
+		break;
+	case T1_SBLOCK_REQ_WTX:
+	case T1_SBLOCK_RESP_WTX:
+	case T1_SBLOCK_REQ_IFS:
+	case T1_SBLOCK_RESP_IFS:
+		explen = 1;
+		break;
+	default:
+		return (t1_invalid(t1, T1_VALIDATE_BAD_SBLOCK_OP, "asked to "
+		    "process S-block operation 0x%x with an operation type "
+		    "that isn't an S-block", op));
+	}
+
+	if (explen != hdr->t1h_len) {
+		return (t1_invalid(t1, T1_VALIDATE_BAD_LEN, "header length "
+		    "value (%d) does not match length required for S-block "
+		    "(%d)", hdr->t1h_len, explen));
+	}
+
+	if (hdr->t1h_len + t1->t1_protlen != len) {
+		return (t1_invalid(t1, T1_VALIDATE_BAD_LEN, "t1 message "
+		    "logical length (%u), does not match actual length (%u)",
+		    hdr->t1h_len + t1->t1_protlen, len));
+	}
+
+	return (T1_VALIDATE_OK);
+}
+
+/*
+ * Validate that the reply to the IFSD request is valid and also matches our
+ * request.
+ */
+t1_validate_t
+t1_ifsd_resp(t1_state_t *t1, const void *buf, size_t len)
+{
+	t1_validate_t t;
+	const t1_hdr_t *reqhdr, *resphdr;
+
+	if ((t = t1_validate_sblock(t1, buf, len, T1_SBLOCK_RESP_IFS)) !=
+	    T1_VALIDATE_OK) {
+		return (t);
+	}
+
+	reqhdr = (const t1_hdr_t *)t1->t1_altbuf;
+	resphdr = buf;
+	if (reqhdr->t1h_data[0] != resphdr->t1h_data[0]) {
+		return (t1_invalid(t1, T1_VALIDATE_BAD_IFS, "ICC did not echo "
+		    "requested IFS (%u), received %u", reqhdr->t1h_data[0],
+		    resphdr->t1h_data[0]));
+	}
+
+	return (T1_VALIDATE_OK);
+}
+
+void
+t1_ifsd(t1_state_t *t1, size_t ifsd, const void **cmdbuf, size_t *lenp)
+{
+	t1_hdr_t *hdr;
+	uint8_t val;
+
+	VERIFY((t1->t1_flags & T1_F_ICC_INIT) != 0);
+
+	if (ifsd > T1_SIZE_MAX) {
+		val = T1_SIZE_MAX;
+	} else {
+		val = (uint8_t)ifsd;
+	}
+
+	/*
+	 * Per ISO/IEC 7816-3:2006, 0x00, and 0xff are reserved values.
+	 */
+	VERIFY3U(val, !=, 0x00);
+	VERIFY3U(val, !=, 0xff);
+
+	t1->t1_altlen = t1->t1_protlen + T1_SBLOCK_IFS_SIZE;
+	hdr = (t1_hdr_t *)t1->t1_altbuf;
+	t1_header_sblock(hdr, T1_SBLOCK_REQ_IFS, T1_SBLOCK_IFS_SIZE);
+	hdr->t1h_data[0] = ifsd;
+	t1_checksum(t1, t1->t1_altbuf, sizeof (t1_hdr_t) + T1_SBLOCK_IFS_SIZE);
+
+	*cmdbuf = t1->t1_altbuf;
+	*lenp = t1->t1_altlen;
+}
+
+/*
+ * Generate the next I-block which may be part of a chain.
+ */
+static void
+t1_generate_iblock(t1_state_t *t1)
+{
+	t1_hdr_t *hdr;
+	uint8_t len;
+	size_t mrem;
+	boolean_t chain;
+
+	/*
+	 * First, determine how much data we need to send and if well end up
+	 * having more data to send after this.
+	 */
+	mrem = t1->t1_ulen - t1->t1_uoff;
+	VERIFY3U(mrem, !=, 0);
+
+	if (mrem > t1->t1_maxlen) {
+		len = t1->t1_maxlen;
+		chain = B_TRUE;
+	} else {
+		len = (uint8_t)mrem;
+		chain = B_FALSE;
+		t1->t1_flags |= T1_F_DONE_SENDING;
+	}
+	len = MIN(t1->t1_maxlen, t1->t1_ulen - t1->t1_uoff);
+	VERIFY3U(len, !=, 0);
+
+	hdr = (t1_hdr_t *)t1->t1_cmdbuf;
+	t1_header_iblock(hdr, t1->t1_send_ns, chain, len);
+	bcopy(t1->t1_ubuf + t1->t1_uoff, hdr->t1h_data, len);
+	t1_checksum(t1, t1->t1_cmdbuf, len + sizeof (t1_hdr_t));
+	t1->t1_cmdlen = len + t1->t1_protlen;
+	t1->t1_uoff += len;
+	t1->t1_flags |= T1_F_DATA_VALID;
+}
+
+/*
+ * When sending an R-block, we always use the current expected receive sequence
+ * number. This value is incremented every time we receive a message. If we are
+ * sending a retransmit, then the current receive sequence number will be the
+ * value we expected to receive. Otherwise, it will be the value we next expect,
+ * which is what we acknowledge with.
+ */
+static void
+t1_generate_rblock(t1_state_t *t1, t1_rblock_status_t status)
+{
+	t1_hdr_t *hdr;
+
+	hdr = (t1_hdr_t *)t1->t1_cmdbuf;
+	t1_header_rblock(hdr, t1->t1_recv_ns, status);
+	t1_checksum(t1, t1->t1_cmdbuf, sizeof (t1_hdr_t));
+	t1->t1_cmdlen = t1->t1_protlen;
+	t1->t1_flags |= T1_F_DATA_VALID;
+}
+
+t1_action_t
+t1_step(t1_state_t *t1)
+{
+	if ((t1->t1_flags & T1_F_CMD_SMASK) != 0) {
+		/* XXX Implement me */
+		VERIFY(0);
+		return (T1_ACTION_SEND_COMMAND);
+	}
+
+	if (t1->t1_flags & T1_F_CMD_ERROR) {
+		/*
+		 * XXX In theory when we have a validation error or otherwise,
+		 * we should actually use this as a chance to follow the series
+		 * of actions to resynch, among other things. However, at this
+		 * time, we instead opt to reset.
+		 */
+		return (T1_ACTION_WARM_RESET);
+	}
+
+	if (t1->t1_flags & T1_F_CMD_RESEND) {
+		/*
+		 * XXX We should check the resend count here and resend it if
+		 * the count is not too high. For the time being, issue a reset.
+		 */
+		return (T1_ACTION_WARM_RESET);
+	}
+
+	switch (t1->t1_flags & T1_F_CMD_MASK) {
+	case T1_F_CMD_SENDING:
+		t1_generate_iblock(t1);
+		break;
+	case T1_F_CMD_RECEIVING:
+		t1_generate_rblock(t1, T1_RBLOCK_STATUS_OK);
+		break;
+	case T1_F_CMD_DONE:
+		return (T1_ACTION_DONE);
+	default:
+		/* XXX */
+		return (T1_ACTION_WARM_RESET);
+	}
+
+	return (T1_ACTION_SEND_COMMAND);
+}
+
+/*
+ * When we receive an I-Block from the ICC that will be done only once we have
+ * finished sending. Note, the sequence number on the I-Block has already been
+ * checked. Here we need to:
+ *
+ *  o Make sure that the state machine is in a state where we should be
+ *    receiving I-Blocks
+ *  o If this was in response to the last sent block, then we need to both
+ *    toggle the expected sending sequence and toggle the state flags to say
+ *    that we're receiving.
+ *  o Check for the zero-length case
+ *  o Save the data for future processing
+ *  o Toggle the expected sequence for reciving
+ */
+t1_validate_t
+t1_reply_iblock(t1_state_t *t1, mblk_t *mp)
+{
+	const t1_hdr_t *t1h;
+	t1_state_flags_t donesend = T1_F_CMD_SENDING | T1_F_DONE_SENDING;
+
+	/*
+	 * Check that either we're done sending or that we're in the receiving
+	 * state.
+	 */
+	if ((t1->t1_flags & donesend) == donesend) {
+		t1->t1_flags &= ~donesend;
+		t1->t1_flags |= T1_F_CMD_RECEIVING;
+		t1->t1_send_ns ^= 1;
+	} else if ((t1->t1_flags & T1_F_CMD_RECEIVING) == 0) {
+		t1->t1_flags |= T1_F_CMD_ERROR;
+		return (t1_invalid(t1, T1_VALIDATE_BAD_IBLOCK, "received "
+		    "unexpected I-block per state flags (0x%x)", t1->t1_flags));
+	}
+
+	/*
+	 * Check if the more flag is set. If not, note that this is the last
+	 * I-block that we expect to receive.
+	 */
+	t1h = (const t1_hdr_t *)mp->b_rptr;
+	if ((t1h->t1h_pcb & T1_IBLOCK_M) == 0) {
+		t1->t1_flags |= T1_F_CMD_DONE;
+		t1->t1_flags &= ~T1_F_CMD_RECEIVING;
+	}
+
+	/*
+	 * Check for a zero-length I-Block. This is only allowed as the last
+	 * entry in a chain. If not, then this is an error. The presence of a
+	 * chain is done based on having received message blocks.
+	 */
+	if (t1h->t1h_len == 0 && ((t1->t1_flags & T1_F_CMD_DONE) != 0 ||
+	    t1->t1_reply_chain == NULL)) {
+		t1->t1_flags |= T1_F_CMD_ERROR;
+		return (t1_invalid(t1, T1_VALIDATE_BAD_IBLOCK, "received "
+		    "zero length I-block with more bit set"));
+	}
+
+	/*
+	 * Append the mblock. We need to increment the read pointer for the
+	 * prologue and decrement the write pointer for the checksum.
+	 */
+	mp->b_rptr += sizeof (t1_hdr_t);
+	switch (t1->t1_checksum) {
+	case ATR_T1_CHECKSUM_LRC:
+		mp->b_wptr -= T1_LRC_LENGTH;
+		break;
+	case ATR_T1_CHECKSUM_CRC:
+		mp->b_wptr -= T1_CRC_LENGTH;
+		break;
+	}
+
+	if (t1->t1_reply_chain == NULL) {
+		t1->t1_reply_chain = mp;
+	} else {
+		mblk_t *last = t1->t1_reply_chain;
+		while (last->b_cont != NULL)
+			last = last->b_cont;
+		last->b_cont = mp;
+	}
+
+	t1->t1_recv_ns ^= 1;
+
+	return (T1_VALIDATE_OK);
+}
+
+/*
+ * When we receive an R-Block from the ICC there will be two different cases
+ * that arise:
+ *
+ *   1. We have sent a chain and it is acknowledging it
+ *   2. We have received an error and it is asking us to retransmit
+ *
+ * At this time, any occurence of instance two means that we issue a warm reset
+ * request. We don't really support the full proper execution of ISO/IEC
+ * 7816-3:2006.
+ *
+ * In the case of the first case, now that we've had a successful
+ * acknowledgement, we need to go through and do the following:
+ *
+ *   o Toggle the expected sending sequence
+ */
+t1_validate_t
+t1_reply_rblock(t1_state_t *t1, const t1_hdr_t *hdr)
+{
+	uint8_t nr;
+	boolean_t seqmatch;
+	t1_rblock_status_t status;
+
+	/*
+	 * To determine if this was trying to indicate to us that we received an
+	 * error, we need to check two different things. We need to see if the
+	 * sequence value matches what we last sent or not. If not, then it is
+	 * an acknowledgement and the status in the R-Block should be zero.
+	 *
+	 * If instead it does match, then the status should be non-zero and that
+	 * should tell us to retransmit. XXX We don't support retransmits at
+	 * this time and therefore we'll just go ahead and note that this is an
+	 * error.
+	 *
+	 * If we get a case where the R-Block doesn't make semantic sense then
+	 * we'll consider that an error and issue a warm reset. Though in theory
+	 * we could request a retransmit from the ICC.
+	 */
+	status = hdr->t1h_pcb & T1_RBLOCK_STATUS_MASK;
+	nr = (hdr->t1h_pcb & T1_RBLOCK_NR) != 0;
+	seqmatch = nr == t1->t1_send_ns;
+	if ((seqmatch && status == T1_RBLOCK_STATUS_OK) ||
+	    (!seqmatch && status != T1_RBLOCK_STATUS_OK)) {
+		/*
+		 * XXX This represents the mismatch. This doesn't make semantic
+		 * sense.
+		 */
+		t1->t1_flags |= T1_F_CMD_ERROR;
+		return (t1_invalid(t1, T1_VALIDATE_BAD_RBLOCK, "sequence match "
+		    "(%u) does not make sense with R-block status code (%u)",
+		    seqmatch, status));
+	}
+
+	if (seqmatch) {
+		/*
+		 * This is the retransmit case. We should resend things.
+		 */
+		t1->t1_resend_count++;
+		t1->t1_flags |= T1_F_CMD_RESEND;
+		return (T1_VALIDATE_OK);
+	}
+
+	/*
+	 * Check if we're expecting a chaining style acknowledgement. If not,
+	 * then this is a bad block.
+	 */
+	if ((t1->t1_flags & T1_F_CMD_SENDING) == 0 ||
+	    (t1->t1_flags & T1_F_DONE_SENDING) != 0) {
+		t1->t1_flags |= T1_F_CMD_ERROR;
+		return (t1_invalid(t1, T1_VALIDATE_BAD_RBLOCK, "received "
+		    "acknowledgement R-block not in receipt to a chain"));
+	}
+
+	/*
+	 * Now that we've finally acknowledged this block we've sent, go ahead
+	 * and update the sequence number.
+	 */
+	t1->t1_send_ns ^= 1;
+
+	return (T1_VALIDATE_OK);
+}
+
+/*
+ * It is possible to receive an S-block at any time. Depending on the type of
+ * S-block, different operations will need to occur. There are four different
+ * types of S-Block commands:
+ *
+ *  o RESYNCH - This is used to reset the communication betwen the reader and
+ *  		the ICC. In theory only the reader is allowed to issue this. If
+ *  		we receive any kind of RESYNCH request, we note that as an error
+ *  		and will issue a warm reset.
+ *
+ *  o IFS -	This is used to change the size of the data that can be
+ *  		transmitted. This may be issued by the reader or the ICC. The
+ *  		issuer is describing what size it is that they need to change.
+ *  		When the ICC is first detected, we will issue an IFS request to
+ *  		increase the reader's IFS. At any time, the ICC is allowed to
+ *  		issue an IFS request. However, the initial value is determined
+ *  		based on the ATR.
+ *
+ *  o ABORT -	This is used to cancel a chain or series of commands. At this
+ *  		time, the framework does not issue aborts. If we receive one
+ *  		from the card, then we will issue a warm reset and fail the
+ *  		command.
+ *
+ *  o WTX -	This is usd by the card to indicate that it is still processing;
+ *  		however it requires additional time. When this is received, we
+ *  		must acknowledge it. However, we must also increase the default
+ *  		waiting time here and in the command.
+ */
+t1_validate_t
+t1_reply_sblock(t1_state_t *t1, const t1_hdr_t *hdr)
+{
+	/*
+	 * XXX We need to impelemnt this. For the time being state that there's
+	 * an error on this that says we need to reset the device.
+	 */
+	t1->t1_flags |= T1_F_CMD_ERROR;
+	return (T1_VALIDATE_OK);
+}
+
+/*
+ * We've received an arbitrary reply from the ICC. Depending on where we are
+ * in working with a chain, this may be an I-block or it may be an R-block.
+ * However, the ICC is allowed to interrupt us with an S-block at various times.
+ *
+ * XXX We should maybe work in the fact that we had a time out into this for
+ * proper state machine execution or we can keep treating a timeout as a fatal
+ * error. In this case we're referring to a CCID level timeout, not a USB level
+ * timeout.
+ */
+t1_validate_t
+t1_reply(t1_state_t *t1, mblk_t *mp)
+{
+	t1_validate_t t;
+	t1_block_type_t type;
+	const t1_hdr_t *hdr;
+
+	/*
+	 * First validate that the blob of data that we've received makes some
+	 * amount of sense. If it does, then we'll see if it makes semantic
+	 * sense (in other words, it's something that we expected to receive).
+	 *
+	 * XXX In a number of these cases we should probably consider
+	 * transmitting an R-block rather than just resetting the device.
+	 */
+	if ((t = t1_validate_hdr(t1, mp->b_rptr, MBLKL(mp), &type)) !=
+	    T1_VALIDATE_OK) {
+		t1->t1_flags |= T1_F_CMD_ERROR;
+		return (t);
+	}
+
+	hdr = (const t1_hdr_t *)mp->b_rptr;
+	switch (type) {
+	case T1_T_IBLOCK:
+		return (t1_reply_iblock(t1, mp));
+	case T1_T_RBLOCK:
+		return (t1_reply_rblock(t1, hdr));
+	case T1_T_SBLOCK:
+		return (t1_reply_sblock(t1, hdr));
+	}
+
+	return (T1_ACTION_WARM_RESET);
+}
+
+void
+t1_data(t1_state_t *t1, const void **bufp, size_t *lenp)
+{
+	VERIFY((t1->t1_flags & T1_F_DATA_VALID) != 0);
+	*bufp = t1->t1_cmdbuf;
+	*lenp = t1->t1_cmdlen;
+}
diff --git a/usr/src/common/ccid/ccid_t1.h b/usr/src/common/ccid/ccid_t1.h
new file mode 100644
index 0000000000..763a52cdec
--- /dev/null
+++ b/usr/src/common/ccid/ccid_t1.h
@@ -0,0 +1,286 @@
+/*
+ * This file and its contents are supplied under the terms of the
+ * Common Development and Distribution License ("CDDL"), version 1.0.
+ * You may only use this file in accordance with the terms of version
+ * 1.0 of the CDDL.
+ *
+ * A full copy of the text of the CDDL should have accompanied this
+ * source.  A copy of the CDDL is also available via the Internet at
+ * http://www.illumos.org/license/CDDL.
+ */
+
+/*
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+
+#ifndef _T1_H
+#define	_T1_H
+
+/*
+ * Definitions for the T=1 protocol.
+ */
+
+#include <sys/types.h>
+#include <sys/stream.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#pragma pack(1)
+typedef struct t1_hdr {
+	uint8_t		t1h_nad;
+	uint8_t		t1h_pcb;
+	uint8_t		t1h_len;
+	uint8_t		t1h_data[];
+} t1_hdr_t;
+#pragma pack()
+
+/*
+ * Per ISO/IEC 7816-3:2006 11.3.1 the maximum amount of data that we can put in
+ * the len member of structure is 254 bytes. The value 255 is reserved for
+ * future use.
+ */
+#define	T1_SIZE_MAX	254
+
+/*
+ * The buffer size used for a full T=1 command that includes the maximum size
+ * message (T1_SIZE_MAX), the largest size checksum length (2), and a header
+ * size (3 bytes), plus one extra byte of padding. 254 + 3 + 2 + 1 = 260.
+ */
+#define	T1_BUF_MAX	260
+
+/*
+ * Per ISO/IEC 7816-3:2006 11.4.2, the default values of the IFSC and IFSD are
+ * 32 bytes.
+ */
+#define	T1_IFSC_DEFAULT	32
+#define	T1_IFSD_DEFAULT	32
+
+/*
+ * These macros are used to determine what type the data is. An I-Block has the
+ * msb set to zero; however, the other types use two bits to determine what the
+ * type is.
+ */
+#define	T1_TYPE_IBLOCK	0x00
+#define	T1_TYPE_RBLOCK	0x80
+#define	T1_TYPE_SBLOCK	0xc0
+#define	T1_TYPE_IMASK	0x80
+#define	T1_TYPE_RSMASK	0xc0
+
+#define	T1_IBLOCK_NS	0x40
+#define	T1_IBLOCK_M	0x20
+#define	T1_IBLOCK_RSVD	0x1f
+
+/*
+ * The T1 NS sequence must always start at 0 per ISO/IEC 7816-3:2006 11.6.2.1.
+ * This is a one bit counter. To increment it we always do an xor with 1.
+ */
+#define	T1_IBLOCK_NS_DEFVAL	0
+
+#define	T1_RBLOCK_NR	0x10
+/*
+ * The way that the specification describes the values of the PCB, any case
+ * where the following bits are non-zero is reserved for future use.
+ */
+#define	T1_RBLOCK_RESV_MASK	0x2c
+#define	T1_RBLOCK_STATUS_MASK	0x03
+
+typedef enum t1_rblock_status {
+	T1_RBLOCK_STATUS_OK 	= 0x00,
+	T1_RBLOCK_STATUS_PARITY	= 0x01,
+	T1_RBLOCK_STATUS_ERROR	= 0x02
+} t1_rblock_status_t;
+
+#define	T1_SBLOCK_OP_MASK	0x3f
+
+typedef enum t1_sblock_op {
+	T1_SBLOCK_REQ_RESYNCH	= 0x00,
+	T1_SBLOCK_RESP_RSYNCH	= 0x20,
+	T1_SBLOCK_REQ_IFS	= 0x01,
+	T1_SBLOCK_RESP_IFS	= 0x21,
+	T1_SBLOCK_REQ_ABORT	= 0x02,
+	T1_SBLOCK_RESP_ABORT	= 0x22,
+	T1_SBLOCK_REQ_WTX	= 0x03,
+	T1_SBLOCK_RESP_WTX	= 0x23
+} t1_sblock_op_t;
+
+/*
+ * Size in bytes for the IFS related requests.
+ */
+#define	T1_SBLOCK_IFS_SIZE	1
+
+/*
+ * The default node address value (used in t1h_nad). The node address is a
+ * potential way to try and multiplex a series of messages going to an ICC. We
+ * always use the default address and never change this, which is zero. Not all
+ * CCID readers support sending with alternative addresses.
+ */
+#define	T1_DEFAULT_NAD	0
+
+/*
+ * Reserved value for INF (t1h_len). Per ISO/IEC 7816-3:2006, 11.3.2.3, a value
+ * of 0xff is always reserved.
+ */
+#define	T1_INF_RESERVED	0xff
+
+/*
+ * Length of the checksum in bytes. There are two different checksums defined by
+ * ISO/IEC 7816-3:2006. The one in use is determined based on the ATR.
+ */
+#define	T1_LRC_LENGTH	1
+#define	T1_CRC_LENGTH	2
+
+/*
+ * List of status values we might return when parsing a response.
+ */
+typedef enum {
+	T1_VALIDATE_OK	= 0,
+	T1_VALIDATE_SHORT,
+	T1_VALIDATE_BAD_CKSUM,
+	T1_VALIDATE_BAD_PCB,
+	T1_VALIDATE_BAD_NAD,
+	T1_VALIDATE_BAD_SBLOCK_OP,
+	T1_VALIDATE_BAD_LEN,
+	T1_VALIDATE_RESV_LEN,
+	T1_VALIDATE_BAD_IFS,
+	T1_VALIDATE_BAD_IBLOCK,
+	T1_VALIDATE_BAD_NS,
+	T1_VALIDATE_BAD_RBLOCK,
+	T1_VALIDATE_BAD_NR,
+} t1_validate_t;
+
+typedef enum t1_state_flags {
+	T1_F_ICC_INIT		= 1 << 0,
+	T1_F_CMD_SENDING 	= 1 << 1,
+	T1_F_CMD_RECEIVING 	= 1 << 2,
+	T1_F_CMD_ERROR		= 1 << 3,
+	T1_F_CMD_DONE		= 1 << 4,
+	T1_F_CMD_SRESP		= 1 << 5,
+	T1_F_DATA_VALID		= 1 << 6,
+	T1_F_DONE_SENDING	= 1 << 7,
+	T1_F_CMD_RESEND		= 1 << 8,
+} t1_state_flags_t;
+
+#define	T1_F_CMD_MASK	(T1_F_CMD_SENDING | T1_F_CMD_RECEIVING | \
+    T1_F_CMD_DONE | T1_F_CMD_SRESP | T1_F_CMD_ERROR)
+#define	T1_F_CMD_SMASK	(T1_F_CMD_SRESP)
+#define	T1_F_ALL_CMD_FLAGS	(~T1_F_ICC_INIT)
+
+/*
+ * State tracking structure that is used for T=1 operations.
+ */
+typedef struct t1_state {
+	t1_state_flags_t	t1_flags;
+	/*
+	 * The type of T=1 checksum that is in use.
+	 */
+	atr_t1_checksum_t	t1_checksum;
+	/*
+	 * The maximum size of the user data that we can use for a T=1 message.
+	 */
+	uint8_t			t1_maxlen;
+	/*
+	 * The number of bytes we need to allocate to cover the prologue and
+	 * eiplogue of a message.
+	 */
+	uint8_t			t1_protlen;
+	/*
+	 * The value of the sending and receiving sequence number that we
+	 * expect. The sending and receiving values are separate.
+	 */
+	uint8_t			t1_send_ns;
+	uint8_t			t1_recv_ns;
+	/*
+	 * Pointer to the command buffer with the user data to send and the
+	 * buffer's length.
+	 */
+	const void		*t1_ubuf;
+	size_t			t1_ulen;
+	/*
+	 * Offset into the user's command buffer.
+	 */
+	size_t			t1_uoff;
+	/*
+	 * Buffer to assemble a command in.
+	 */
+	uint8_t			t1_cmdbuf[T1_BUF_MAX];
+	size_t			t1_cmdlen;
+	/*
+	 * A secondary buffer to use in case we get a reply that has an S-Block.
+	 */
+	uint8_t			t1_altbuf[T1_BUF_MAX];
+	size_t			t1_altlen;
+	/*
+	 * Used to place validation messages.
+	 */
+	t1_validate_t		t1_validate;
+	char			t1_msgbuf[1024];
+	/*
+	 * Running count of how many times we've reissued a given command.
+	 */
+	uint8_t			t1_resend_count;
+	/*
+	 * mblk(9S) reply data.
+	 */
+	mblk_t			*t1_reply_chain;
+} t1_state_t;
+
+/*
+ * Called when a new ICC has been inserted or reset to initialize the T=1 state
+ * again for the ICC.
+ */
+extern void t1_state_icc_init(t1_state_t *, atr_data_t *, size_t);
+extern void t1_state_icc_fini(t1_state_t *);
+
+/*
+ * Called when a new command should be sent out the ICC.
+ */
+extern void t1_state_cmd_init(t1_state_t *, const void *, size_t);
+extern mblk_t *t1_state_cmd_reply_take(t1_state_t *);
+extern void t1_state_cmd_fini(t1_state_t *);
+
+/*
+ * Called to generate the data buffer for sending a T=1 IFSD request.
+ */
+extern void t1_ifsd(t1_state_t *, size_t, const void **, size_t *);
+extern t1_validate_t t1_ifsd_resp(t1_state_t *, const void *, size_t);
+
+/*
+ * Obtain a more detailed error message when a T=1 validation error occurs.
+ */
+extern const char *t1_errmsg(t1_state_t *);
+
+typedef enum {
+	T1_ACTION_SEND_COMMAND,
+	T1_ACTION_WARM_RESET,
+	T1_ACTION_DONE
+} t1_action_t;
+
+/*
+ * These three functions are used to advance the T=1 state machine. The
+ * t1_reply() functino should be used when we receive a reply from the ICC.
+ *
+ * The t1_step() function is used to basically figure out what to do next. This
+ * may mean preparing another command or realizing that we're done with
+ * everything that we need to. It may also mean that we encounter an error and
+ * need to reset the card.
+ *
+ * The t1_data() function is used to get the data for the next command to
+ * execute and its length so a command can be executed.
+ */
+
+extern t1_validate_t t1_reply(t1_state_t *, mblk_t *);
+extern t1_action_t t1_step(t1_state_t *);
+extern void t1_data(t1_state_t *, const void **, size_t *);
+
+/*
+ * Used to indicate that we're done processing a command.
+ */
+extern void t1_finicmd(t1_state_t *, const mblk_t **);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _T1_H */
diff --git a/usr/src/lib/Makefile b/usr/src/lib/Makefile
index cb326e5e45..1363c5cc1b 100644
--- a/usr/src/lib/Makefile
+++ b/usr/src/lib/Makefile
@@ -181,6 +181,7 @@ SUBDIRS +=				\
 	libofmt		\
 	libpam		\
 	libpcidb	\
+	libpcsc		\
 	libpctx		\
 	libpicl		\
 	libpicltree	\
@@ -448,6 +449,7 @@ HDRSUBDIRS=				\
 	libofmt		\
 	libpam		\
 	libpcidb	\
+	libpcsc		\
 	libpctx		\
 	libpicl		\
 	libpicltree	\
diff --git a/usr/src/lib/cfgadm_plugins/Makefile b/usr/src/lib/cfgadm_plugins/Makefile
index 00d258b20a..46ab473ed4 100644
--- a/usr/src/lib/cfgadm_plugins/Makefile
+++ b/usr/src/lib/cfgadm_plugins/Makefile
@@ -26,7 +26,7 @@
 
 include $(SRC)/Makefile.master
 
-COMMON_SUBDIRS= scsi pci usb ib fp shp sbd
+COMMON_SUBDIRS= scsi pci usb ib fp shp sbd ccid
 sparc_SUBDIRS=	ac sysctrl
 
 i386_SUBDIRS= sata
diff --git a/usr/src/lib/cfgadm_plugins/ccid/Makefile b/usr/src/lib/cfgadm_plugins/ccid/Makefile
new file mode 100644
index 0000000000..848d334f97
--- /dev/null
+++ b/usr/src/lib/cfgadm_plugins/ccid/Makefile
@@ -0,0 +1,67 @@
+#
+# CDDL HEADER START
+#
+# The contents of this file are subject to the terms of the
+# Common Development and Distribution License (the "License").
+# You may not use this file except in compliance with the License.
+#
+# You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
+# or http://www.opensolaris.org/os/licensing.
+# See the License for the specific language governing permissions
+# and limitations under the License.
+#
+# When distributing Covered Code, include this CDDL HEADER in each
+# file and include the License file at usr/src/OPENSOLARIS.LICENSE.
+# If applicable, add the following below this CDDL HEADER, with the
+# fields enclosed by brackets "[]" replaced with your own identifying
+# information: Portions Copyright [yyyy] [name of copyright owner]
+#
+# CDDL HEADER END
+#
+#
+# Copyright 2008 Sun Microsystems, Inc.  All rights reserved.
+# Use is subject to license terms.
+#
+#
+
+include		../../Makefile.lib
+
+$(INTEL_BLD)SUBDIRS =	$(MACH) $(BUILD64) $(MACH64)
+
+all :=		TARGET= all
+clean :=	TARGET= clean
+clobber :=	TARGET= clobber
+delete :=	TARGET= delete
+install :=	TARGET= install
+lint := 	TARGET= lint
+_msg :=		TARGET= _msg
+package := 	TARGET= package
+
+SED=	sed
+GREP=	grep
+
+.KEEP_STATE:
+
+all clean delete install lint package: $(SUBDIRS)
+clobber: $(SUBDIRS)
+	$(RM) $(POFILE) $(POFILES)
+
+$(SUBDIRS):	FRC
+	@cd $@; pwd; $(MAKE) $(TARGET)
+
+#
+# We don't build any gettext libraries here
+#
+_msg:
+
+$(POFILE):	$(POFILES)
+	$(RM) $@
+	$(CAT) $(POFILES) > $@
+
+$(POFILES):
+	$(RM) messages.po
+	$(XGETTEXT) $(XGETFLAGS) `$(GREP) -l gettext */*.[ch]`
+	$(SED) -e '/^# msg/d' -e '/^domain/d' messages.po > $@
+	$(RM) messages.po
+
+FRC:
diff --git a/usr/src/lib/cfgadm_plugins/ccid/Makefile.com b/usr/src/lib/cfgadm_plugins/ccid/Makefile.com
new file mode 100644
index 0000000000..84df66a97d
--- /dev/null
+++ b/usr/src/lib/cfgadm_plugins/ccid/Makefile.com
@@ -0,0 +1,70 @@
+#
+# CDDL HEADER START
+#
+# The contents of this file are subject to the terms of the
+# Common Development and Distribution License (the "License").
+# You may not use this file except in compliance with the License.
+#
+# You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
+# or http://www.opensolaris.org/os/licensing.
+# See the License for the specific language governing permissions
+# and limitations under the License.
+#
+# When distributing Covered Code, include this CDDL HEADER in each
+# file and include the License file at usr/src/OPENSOLARIS.LICENSE.
+# If applicable, add the following below this CDDL HEADER, with the
+# fields enclosed by brackets "[]" replaced with your own identifying
+# information: Portions Copyright [yyyy] [name of copyright owner]
+#
+# CDDL HEADER END
+#
+#
+# Copyright 2006 Sun Microsystems, Inc.  All rights reserved.
+# Use is subject to license terms.
+#
+
+LIBRARY= ccid.a
+VERS= .1
+
+OBJECTS= cfga_ccid.o
+
+# include library definitions
+include ../../../Makefile.lib
+
+SRCDIR =	../common
+ROOTLIBDIR=	$(ROOT)/usr/lib/cfgadm
+ROOTLIBDIR64=	$(ROOTLIBDIR)/$(MACH64)
+
+LIBS=	$(DYNLIB)
+
+LINTFLAGS +=	-DDEBUG
+LINTFLAGS64 +=	-DDEBUG
+
+CFLAGS +=	$(CCVERBOSE)
+CFLAGS64 +=	$(CCVERBOSE)
+
+LDLIBS +=	-lc
+
+.KEEP_STATE:
+
+all:	$(LIBS)
+
+lint:	lintcheck
+
+# Install rules
+
+$(ROOTLIBDIR)/%: % $(ROOTLIBDIR)
+	$(INS.file)
+
+$(ROOTLIBDIR64)/%: % $(ROOTLIBDIR64)
+	$(INS.file)
+
+$(ROOTLIBDIR) $(ROOTLIBDIR64):
+	$(INS.dir)
+
+# include library targets
+include ../../../Makefile.targ
+
+objs/%.o pics/%.o: ../common/%.c
+	$(COMPILE.c) -o $@ $<
+	$(POST_PROCESS_O)
diff --git a/usr/src/lib/cfgadm_plugins/ccid/amd64/Makefile b/usr/src/lib/cfgadm_plugins/ccid/amd64/Makefile
new file mode 100644
index 0000000000..5901061730
--- /dev/null
+++ b/usr/src/lib/cfgadm_plugins/ccid/amd64/Makefile
@@ -0,0 +1,21 @@
+#
+# This file and its contents are supplied under the terms of the
+# Common Development and Distribution License ("CDDL"), version 1.0.
+# You may only use this file in accordance with the terms of version
+# 1.0 of the CDDL.
+#
+# A full copy of the text of the CDDL should have accompanied this
+# source.  A copy of the CDDL is also available via the Internet at
+# http://www.illumos.org/license/CDDL.
+#
+
+#
+# Copyright (c) 2017, Joyent, Inc.
+#
+
+include ../Makefile.com
+include ../../../Makefile.lib.64
+
+.KEEP_STATE:
+
+install: all $(ROOTLIBS64) $(ROOTLINKS64)
diff --git a/usr/src/lib/cfgadm_plugins/ccid/common/cfga_ccid.c b/usr/src/lib/cfgadm_plugins/ccid/common/cfga_ccid.c
new file mode 100644
index 0000000000..6cc1ee879f
--- /dev/null
+++ b/usr/src/lib/cfgadm_plugins/ccid/common/cfga_ccid.c
@@ -0,0 +1,412 @@
+/*
+ * This file and its contents are supplied under the terms of the
+ * Common Development and Distribution License ("CDDL"), version 1.0.
+ * You may only use this file in accordance with the terms of version
+ * 1.0 of the CDDL.
+ *
+ * A full copy of the text of the CDDL should have accompanied this
+ * source.  A copy of the CDDL is also available via the Internet at
+ * http://www.illumos.org/license/CDDL.
+ */
+
+/*
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+
+/*
+ * CCID cfgadm plugin
+ */
+
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <stdio.h>
+#include <stdarg.h>
+#include <errno.h>
+#include <string.h>
+#include <strings.h>
+#include <stdlib.h>
+
+#include <sys/usb/clients/ccid/uccid.h>
+
+#define	CFGA_PLUGIN_LIB
+#include <config_admin.h>
+
+int cfga_version = CFGA_HSL_V2;
+
+static cfga_err_t
+cfga_ccid_error(cfga_err_t err, char **errp, const char *fmt, ...)
+{
+	va_list ap;
+
+	if (errp == NULL)
+		return (err);
+
+	/*
+	 * Try to format a string. However because we have to return allocated
+	 * memory, if this fails, then we have no error.
+	 */
+	va_start(ap, fmt);
+	(void) vasprintf(errp, fmt, ap); 
+	va_end(ap);
+
+	return (err);
+}
+
+cfga_err_t
+cfga_ccid_modify(uccid_cmd_icc_modify_t *modify, const char *ap,
+    struct cfga_confirm *confp, struct cfga_msg *msgp, char **errp,
+    boolean_t force)
+{
+	int fd;
+	uccid_cmd_status_t ucs;
+	uccid_cmd_txn_begin_t begin;
+	boolean_t held = B_FALSE;
+
+	/*
+	 * Check ap is valid by doing a status request.
+	 */
+	if ((fd = open(ap, O_RDWR)) < 0) {
+		return (cfga_ccid_error(CFGA_LIB_ERROR, errp,
+		    "failed to open %s: %s", ap, strerror(errno)));
+	}
+
+	bzero(&ucs, sizeof (ucs));
+	ucs.ucs_version = UCCID_VERSION_ONE;
+
+	if (ioctl(fd, UCCID_CMD_STATUS, &ucs) != 0) {
+		int e = errno;
+		if (errno == ENODEV) {
+			(void) close(fd);
+			return (cfga_ccid_error(CFGA_LIB_ERROR, errp,
+			    "ap %s going away", ap));
+		}
+		(void) close(fd);
+		return (cfga_ccid_error(CFGA_ERROR, errp,
+		    "ioctl on ap %s failed: %s", ap, strerror(e)));
+	}
+
+	/*
+	 * Attempt to get a hold. If we cannot obtain a hold, we will not
+	 * perform this unless the user has said we should force this.
+	 */
+	bzero(&begin, sizeof (begin));
+	begin.uct_version = UCCID_CURRENT_VERSION;
+	begin.uct_flags = UCCID_TXN_DONT_BLOCK;
+	if (ioctl(fd, UCCID_CMD_TXN_BEGIN, &begin) != 0) {
+		if (errno != EBUSY) {
+			int e = errno;
+			(void) close(fd);
+			return (cfga_ccid_error(CFGA_ERROR, errp, "failed to "
+			    "begin ccid transaction on ap %s: %s", ap,
+			    strerror(e)));
+		}
+
+		/*
+		 * If the user didn't force this operation, prompt if we would
+		 * interfere.
+		 */
+		if (!force) {
+			int confirm = 0;
+			const char *prompt = "CCID slot is held exclusively "
+			    "by another program.  Proceeding may interrupt "
+			    "their functionality. Continue?";
+			if (confp != NULL && confp->appdata_ptr != NULL) {
+				confirm = (*confp->confirm)(confp->appdata_ptr,
+				    prompt);
+			}
+
+			if (confirm == 0) {
+				(void) close(fd);
+				return (CFGA_NACK);
+			}
+		}
+	} else {
+		held = B_TRUE;
+	}
+
+	if (ioctl(fd, UCCID_CMD_ICC_MODIFY, modify) != 0) {
+		int e = errno;
+		(void) close (fd);
+		return (cfga_ccid_error(CFGA_ERROR, errp,
+		    "failed to modify state on ap %s: %s", ap,
+		    strerror(e)));
+	}
+
+	if (held) {
+		uccid_cmd_txn_end_t end;
+
+		bzero(&end, sizeof (end));
+		end.uct_version = UCCID_CURRENT_VERSION;
+		end.uct_flags = UCCID_TXN_END_RELEASE;
+
+		if (ioctl(fd, UCCID_CMD_TXN_END, &end) != 0) {
+			int e = errno;
+			(void) close(fd);
+			return (cfga_ccid_error(CFGA_ERROR, errp, "failed to "
+			    "end transaction on ap %s: %s", ap,
+			    strerror(e)));
+		}
+	}
+
+	(void) close(fd);
+	return (CFGA_OK);
+
+}
+
+cfga_err_t
+cfga_change_state(cfga_cmd_t cmd, const char *ap, const char *opts,
+    struct cfga_confirm *confp, struct cfga_msg *msgp, char **errp,
+    cfga_flags_t flags)
+{
+	uccid_cmd_icc_modify_t modify;
+
+	if (errp != NULL) {
+		*errp = NULL;
+	}
+
+	if (ap == NULL) {
+		return (cfga_ccid_error(CFGA_APID_NOEXIST, errp, NULL));
+	}
+
+	if (opts != NULL) {
+		return (cfga_ccid_error(CFGA_ERROR, errp,
+		    "hardware specific options are not supported"));
+	}
+
+	bzero(&modify, sizeof (modify));
+	modify.uci_version = UCCID_CURRENT_VERSION;
+	switch (cmd) {
+	case CFGA_CMD_CONFIGURE:
+		modify.uci_action = UCCID_ICC_POWER_ON;
+		break;
+	case CFGA_CMD_UNCONFIGURE:
+		modify.uci_action = UCCID_ICC_POWER_OFF;
+		break;
+	default:
+		(void) cfga_help(msgp, opts, flags);
+		return (CFGA_OPNOTSUPP);
+	}
+
+	return (cfga_ccid_modify(&modify, ap, confp, msgp, errp,
+	    (flags & CFGA_FLAG_FORCE) != 0));
+}
+
+cfga_err_t
+cfga_private_func(const char *function, const char *ap, const char *opts,
+    struct cfga_confirm *confp, struct cfga_msg *msgp, char **errp,
+    cfga_flags_t flags)
+{
+	uccid_cmd_icc_modify_t modify;
+
+	if (errp != NULL) {
+		*errp = NULL;
+	}
+
+	if (function == NULL) {
+		return (CFGA_ERROR);
+	}
+
+	if (ap == NULL) {
+		return (cfga_ccid_error(CFGA_APID_NOEXIST, errp, NULL));
+	}
+
+	if (opts != NULL) {
+		return (cfga_ccid_error(CFGA_ERROR, errp,
+		    "hardware specific options are not supported"));
+	}
+
+	if (strcmp(function, "warm_reset") != 0) {
+		return (CFGA_OPNOTSUPP);
+	}
+
+	bzero(&modify, sizeof (modify));
+	modify.uci_version = UCCID_CURRENT_VERSION;
+	modify.uci_action = UCCID_ICC_WARM_RESET;
+
+	return (cfga_ccid_modify(&modify, ap, confp, msgp, errp,
+	    (flags & CFGA_FLAG_FORCE) != 0));
+}
+
+/*
+ * We don't support the test entry point for CCID.
+ */
+cfga_err_t
+cfga_test(const char *ap, const char *opts, struct cfga_msg *msgp, char **errp,
+    cfga_flags_t flags)
+{
+	(void) cfga_help(msgp, opts, flags);
+	return (CFGA_OPNOTSUPP);
+}
+
+static void
+cfga_ccid_fill_info(const uccid_cmd_status_t *ucs, char *buf, size_t len)
+{
+	const char *product, *serial, *tran, *prot;
+	uint_t bits = CCID_CLASS_F_TPDU_XCHG | CCID_CLASS_F_SHORT_APDU_XCHG |
+	    CCID_CLASS_F_EXT_APDU_XCHG;
+
+	if ((ucs->ucs_status & UCCID_STATUS_F_PRODUCT_VALID) != NULL) {
+		product = ucs->ucs_product;
+	} else {
+		product = "<unknown>";
+	}
+
+	if ((ucs->ucs_status & UCCID_STATUS_F_SERIAL_VALID) != NULL) {
+		serial = ucs->ucs_serial;
+	} else {
+		serial = "<unknown>";
+	}
+
+	switch (ucs->ucs_class.ccd_dwFeatures & bits) {
+	case 0:
+		tran = "Character";
+		break;
+	case CCID_CLASS_F_TPDU_XCHG:
+		tran = "TPDU";
+		break;
+	case CCID_CLASS_F_SHORT_APDU_XCHG:
+	case CCID_CLASS_F_EXT_APDU_XCHG:
+		tran = "APDU";
+		break;
+	default:
+		tran = "Unknown";
+		break;
+	}
+
+	if ((ucs->ucs_status & UCCID_STATUS_F_PARAMS_VALID) != 0) {
+		switch (ucs->ucs_prot) {
+		case UCCID_PROT_T0:
+			prot = " (T=0)";
+			break;
+		case UCCID_PROT_T1:
+			prot = " (T=1)";
+			break;
+		default:
+			prot = "<unknown>";
+			break;
+		}
+	} else {
+		prot = "<unknown>";
+	}
+
+	if ((ucs->ucs_status & UCCID_STATUS_F_CARD_ACTIVE) != 0) {
+		(void) snprintf(buf, len, "Product: %s Serial: %s "
+		    "Transport: %s Protocol: %s", product, serial,
+		    tran, prot);
+	} else {
+		(void) snprintf(buf, len, "Product: %s Serial: %s ",
+		    product, serial);
+	}
+}
+
+cfga_err_t
+cfga_list_ext(const char *ap, struct cfga_list_data **ap_list, int *nlist,
+    const char *opts, const char *listopts, char **errp, cfga_flags_t flags)
+{
+	int fd;
+	uccid_cmd_status_t ucs;
+	struct cfga_list_data *cld;
+
+	if (errp != NULL) {
+		*errp = NULL;
+	}
+
+	if (ap == NULL) {
+		return (cfga_ccid_error(CFGA_APID_NOEXIST, errp, NULL));
+	}
+
+	if (opts != NULL) {
+		return (cfga_ccid_error(CFGA_ERROR, errp,
+		    "hardware specific options are not supported"));
+	}
+
+	if ((fd = open(ap, O_RDWR)) < 0) {
+		return (cfga_ccid_error(CFGA_LIB_ERROR, errp,
+		    "failed to open %s: %s", ap, strerror(errno)));
+	}
+
+	bzero(&ucs, sizeof (ucs));
+	ucs.ucs_version = UCCID_VERSION_ONE;
+
+	if (ioctl(fd, UCCID_CMD_STATUS, &ucs) != 0) {
+		int e = errno;
+		(void) close(fd);
+		if (e == ENODEV) {
+			return (cfga_ccid_error(CFGA_LIB_ERROR, errp,
+			    "ap %s going away", ap));
+		}
+		return (cfga_ccid_error(CFGA_ERROR, errp,
+		    "ioctl on ap %s failed: %s", ap, strerror(e)));
+	}
+	(void) close(fd);
+
+	if ((cld = calloc(1, sizeof (*cld))) == NULL) {
+		return (cfga_ccid_error(CFGA_LIB_ERROR, errp, "failed to "
+		    "allocate memory for list entry"));
+	}
+
+	if (snprintf(cld->ap_log_id, sizeof (cld->ap_log_id), "ccid%d/slot%u",
+	    ucs.ucs_instance, ucs.ucs_slot) >= sizeof (cld->ap_log_id)) {
+		free(cld);
+		return (cfga_ccid_error(CFGA_LIB_ERROR, errp, "ap %s logical id "
+		    "was too large", ap));
+	}
+
+	if (strlcpy(cld->ap_phys_id, ap, sizeof (cld->ap_phys_id)) >=
+	    sizeof (cld->ap_phys_id)) {
+		free(cld);
+		return (cfga_ccid_error(CFGA_LIB_ERROR, errp, "ap %s physical id was too long", ap));
+	}
+
+	cld->ap_class[0] = '\0';
+
+	if ((ucs.ucs_status & UCCID_STATUS_F_CARD_PRESENT) != 0) {
+		cld->ap_r_state = CFGA_STAT_CONNECTED;
+		if ((ucs.ucs_status & UCCID_STATUS_F_CARD_ACTIVE) != 0) {
+			cld->ap_o_state = CFGA_STAT_CONFIGURED;
+		} else {
+			cld->ap_o_state = CFGA_STAT_UNCONFIGURED;
+		}
+	} else {
+		cld->ap_r_state = CFGA_STAT_EMPTY;
+		cld->ap_o_state = CFGA_STAT_UNCONFIGURED;
+	}
+
+	/*
+	 * XXX We should probably have a way to indicate that there's an error
+	 * when the ICC is basically foobar'd. We should also allow the status
+	 * ioctl to know that the slot is resetting or something else is going
+	 * on I guess.
+	 */
+	cld->ap_cond = CFGA_COND_OK;
+	cld->ap_busy = 0;
+	cld->ap_status_time = (time_t)-1;
+	cfga_ccid_fill_info(&ucs, cld->ap_info, sizeof (cld->ap_info));
+	if (strlcpy(cld->ap_type, "icc", sizeof (cld->ap_type)) >= sizeof (cld->ap_type)) {
+		free(cld);
+		return (cfga_ccid_error(CFGA_LIB_ERROR, errp,
+		    "ap %s type overflowed ICC field", ap));
+	}
+
+	*ap_list = cld;
+	*nlist = 1;
+	return (CFGA_OK);
+}
+
+cfga_err_t
+cfga_help(struct cfga_msg *msgp, const char *opts, cfga_flags_t flags)
+{
+	(*msgp->message_routine)(msgp, "CCID specific commands:\n");
+	(*msgp->message_routine)(msgp, " cfgadm -c [configure|unconfigure] ap_id [ap_id...]\n");
+	(*msgp->message_routine)(msgp, " cfgadm -x warm_reset ap_id [ap_id...]\n");
+
+	return (CFGA_OK);
+}
+
+int
+cfga_ap_id_cmp(const cfga_ap_log_id_t ap_id1, const cfga_ap_log_id_t ap_id2)
+{
+	return (strcmp(ap_id1, ap_id2));
+}
diff --git a/usr/src/lib/cfgadm_plugins/ccid/common/mapfile-vers b/usr/src/lib/cfgadm_plugins/ccid/common/mapfile-vers
new file mode 100644
index 0000000000..c67dbed449
--- /dev/null
+++ b/usr/src/lib/cfgadm_plugins/ccid/common/mapfile-vers
@@ -0,0 +1,42 @@
+#
+# This file and its contents are supplied under the terms of the
+# Common Development and Distribution License ("CDDL"), version 1.0.
+# You may only use this file in accordance with the terms of version
+# 1.0 of the CDDL.
+#
+# A full copy of the text of the CDDL should have accompanied this
+# source.  A copy of the CDDL is also available via the Internet at
+# http://www.illumos.org/license/CDDL.
+#
+
+#
+# Copyright (c) 2017, Joyent, Inc.
+#
+
+#
+# MAPFILE HEADER START
+#
+# WARNING:  STOP NOW.  DO NOT MODIFY THIS FILE.
+# Object versioning must comply with the rules detailed in
+#
+#	usr/src/lib/README.mapfiles
+#
+# You should not be making modifications here until you've read the most current
+# copy of that file. If you need help, contact a gatekeeper for guidance.
+#
+# MAPFILE HEADER END
+#
+
+$mapfile_version 2
+
+SYMBOL_VERSION SUNWprivate_1.1 {
+    global:
+	cfga_change_state;
+	cfga_help;
+	cfga_list_ext;
+	cfga_private_func;
+	cfga_test;
+	cfga_version;
+    local:
+	*;
+};
diff --git a/usr/src/lib/cfgadm_plugins/ccid/i386/Makefile b/usr/src/lib/cfgadm_plugins/ccid/i386/Makefile
new file mode 100644
index 0000000000..2fac4622dc
--- /dev/null
+++ b/usr/src/lib/cfgadm_plugins/ccid/i386/Makefile
@@ -0,0 +1,20 @@
+#
+# This file and its contents are supplied under the terms of the
+# Common Development and Distribution License ("CDDL"), version 1.0.
+# You may only use this file in accordance with the terms of version
+# 1.0 of the CDDL.
+#
+# A full copy of the text of the CDDL should have accompanied this
+# source.  A copy of the CDDL is also available via the Internet at
+# http://www.illumos.org/license/CDDL.
+#
+
+#
+# Copyright (c) 2017, Joyent, Inc.
+#
+
+include ../Makefile.com
+
+.KEEP_STATE:
+
+install: all $(ROOTLIBS) $(ROOTLINKS)
diff --git a/usr/src/lib/cfgadm_plugins/ccid/sparc/Makefile b/usr/src/lib/cfgadm_plugins/ccid/sparc/Makefile
new file mode 100644
index 0000000000..2fac4622dc
--- /dev/null
+++ b/usr/src/lib/cfgadm_plugins/ccid/sparc/Makefile
@@ -0,0 +1,20 @@
+#
+# This file and its contents are supplied under the terms of the
+# Common Development and Distribution License ("CDDL"), version 1.0.
+# You may only use this file in accordance with the terms of version
+# 1.0 of the CDDL.
+#
+# A full copy of the text of the CDDL should have accompanied this
+# source.  A copy of the CDDL is also available via the Internet at
+# http://www.illumos.org/license/CDDL.
+#
+
+#
+# Copyright (c) 2017, Joyent, Inc.
+#
+
+include ../Makefile.com
+
+.KEEP_STATE:
+
+install: all $(ROOTLIBS) $(ROOTLINKS)
diff --git a/usr/src/lib/cfgadm_plugins/ccid/sparcv9/Makefile b/usr/src/lib/cfgadm_plugins/ccid/sparcv9/Makefile
new file mode 100644
index 0000000000..5901061730
--- /dev/null
+++ b/usr/src/lib/cfgadm_plugins/ccid/sparcv9/Makefile
@@ -0,0 +1,21 @@
+#
+# This file and its contents are supplied under the terms of the
+# Common Development and Distribution License ("CDDL"), version 1.0.
+# You may only use this file in accordance with the terms of version
+# 1.0 of the CDDL.
+#
+# A full copy of the text of the CDDL should have accompanied this
+# source.  A copy of the CDDL is also available via the Internet at
+# http://www.illumos.org/license/CDDL.
+#
+
+#
+# Copyright (c) 2017, Joyent, Inc.
+#
+
+include ../Makefile.com
+include ../../../Makefile.lib.64
+
+.KEEP_STATE:
+
+install: all $(ROOTLIBS64) $(ROOTLINKS64)
diff --git a/usr/src/lib/libcmdutils/common/nicenum.c b/usr/src/lib/libcmdutils/common/nicenum.c
index 8e3202f792..4c9cf7687f 100644
--- a/usr/src/lib/libcmdutils/common/nicenum.c
+++ b/usr/src/lib/libcmdutils/common/nicenum.c
@@ -22,6 +22,7 @@
 /*
  * Copyright (c) 2005, 2010, Oracle and/or its affiliates. All rights reserved.
  * Copyright 2017 Jason king
+ * Copyright (c) 2017, Joyent, Inc.
  */
 
 #include <stdio.h>
@@ -90,7 +91,11 @@ nicenum_scale(uint64_t n, size_t units, char *buf, size_t buflen,
 		 * If this is an even multiple of the base, always display
 		 * without any decimal precision.
 		 */
-		rc = snprintf(buf, buflen, "%llu%c", n / divisor, u);
+		if ((flags & NN_UNIT_SPACE) != 0) {
+			rc = snprintf(buf, buflen, "%llu %c", n / divisor, u);
+		} else {
+			rc = snprintf(buf, buflen, "%llu%c", n / divisor, u);
+		}
 	} else {
 		/*
 		 * We want to choose a precision that reflects the best choice
@@ -104,9 +109,15 @@ nicenum_scale(uint64_t n, size_t units, char *buf, size_t buflen,
 		 */
 		int i;
 		for (i = 2; i >= 0; i--) {
-			if ((rc = snprintf(buf, buflen, "%.*f%c", i,
-			    (double)n / divisor, u)) <= 5)
-				break;
+			if ((flags & NN_UNIT_SPACE) != 0) {
+				if ((rc = snprintf(buf, buflen, "%.*f %c", i,
+				    (double)n / divisor, u)) <= 5)
+					break;
+			} else {
+				if ((rc = snprintf(buf, buflen, "%.*f%c", i,
+				    (double)n / divisor, u)) <= 5)
+					break;
+			}
 		}
 	}
 
diff --git a/usr/src/lib/libcmdutils/libcmdutils.h b/usr/src/lib/libcmdutils/libcmdutils.h
index c9a61aab4d..c37a22c770 100644
--- a/usr/src/lib/libcmdutils/libcmdutils.h
+++ b/usr/src/lib/libcmdutils/libcmdutils.h
@@ -163,6 +163,7 @@ extern int findnextuid(uid_t, uid_t, uid_t *);
 extern int findnextgid(gid_t, gid_t, gid_t *);
 
 #define	NN_DIVISOR_1000		(1U << 0)
+#define	NN_UNIT_SPACE		(1U << 1)
 
 /* Minimum size for the output of nicenum, including NULL */
 #define	NN_NUMBUF_SZ		(6)
diff --git a/usr/src/lib/libpcsc/Makefile b/usr/src/lib/libpcsc/Makefile
new file mode 100644
index 0000000000..7f2723b5d1
--- /dev/null
+++ b/usr/src/lib/libpcsc/Makefile
@@ -0,0 +1,44 @@
+#
+# This file and its contents are supplied under the terms of the
+# Common Development and Distribution License ("CDDL"), version 1.0.
+# You may only use this file in accordance with the terms of version
+# 1.0 of the CDDL.
+#
+# A full copy of the text of the CDDL should have accompanied this
+# source.  A copy of the CDDL is also available via the Internet at
+# http://www.illumos.org/license/CDDL.
+#
+
+#
+# Copyright (c) 2017 Joyent, Inc.
+#
+
+include		../Makefile.lib
+
+HDRS =		wintypes.h winscard.h
+HDRDIR =	common
+SUBDIRS =	$(MACH)
+$(BUILD64)SUBDIRS +=	$(MACH64)
+
+all :=		TARGET = all
+clean :=	TARGET = clean
+clobber :=	TARGET = clobber
+install :=	TARGET = install
+lint :=		TARGET = lint
+
+.KEEP_STATE:
+
+all clean clobber lint: $(SUBDIRS)
+
+install: 	$(SUBDIRS) install_h
+
+install_h: 	$(ROOTHDRS)
+
+check:		$(CHECKHDRS)
+
+$(SUBDIRS):  FRC
+	@cd $@; pwd; $(MAKE) $(TARGET)
+
+FRC:
+
+include ../Makefile.targ
diff --git a/usr/src/lib/libpcsc/Makefile.com b/usr/src/lib/libpcsc/Makefile.com
new file mode 100644
index 0000000000..2ad8acd1d0
--- /dev/null
+++ b/usr/src/lib/libpcsc/Makefile.com
@@ -0,0 +1,34 @@
+#
+# This file and its contents are supplied under the terms of the
+# Common Development and Distribution License ("CDDL"), version 1.0.
+# You may only use this file in accordance with the terms of version
+# 1.0 of the CDDL.
+#
+# A full copy of the text of the CDDL should have accompanied this
+# source.  A copy of the CDDL is also available via the Internet at
+# http://www.illumos.org/license/CDDL.
+#
+
+#
+# Copyright (c) 2017 Joyent, Inc.  All rights reserved.
+#
+
+LIBRARY =	libpcsc.a
+VERS =		.1
+OBJECTS =	libpcsc.o
+
+include ../../Makefile.lib
+
+LIBS =		$(DYNLIB) $(LINTLIB)
+LDLIBS +=	-lc
+CPPFLAGS +=	-I../common
+
+SRCDIR =	../common
+
+.KEEP_STATE:
+
+all:	$(LIBS)
+
+lint:	lintcheck
+
+include ../../Makefile.targ
diff --git a/usr/src/lib/libpcsc/amd64/Makefile b/usr/src/lib/libpcsc/amd64/Makefile
new file mode 100644
index 0000000000..4d3cfa1f81
--- /dev/null
+++ b/usr/src/lib/libpcsc/amd64/Makefile
@@ -0,0 +1,19 @@
+#
+# This file and its contents are supplied under the terms of the
+# Common Development and Distribution License ("CDDL"), version 1.0.
+# You may only use this file in accordance with the terms of version
+# 1.0 of the CDDL.
+#
+# A full copy of the text of the CDDL should have accompanied this
+# source.  A copy of the CDDL is also available via the Internet at
+# http://www.illumos.org/license/CDDL.
+#
+
+#
+# Copyright (c) 2017 Joyent, Inc.
+#
+
+include ../Makefile.com
+include ../../Makefile.lib.64
+
+install: all $(ROOTLIBS64) $(ROOTLINKS64) $(ROOTLINT64)
diff --git a/usr/src/lib/libpcsc/common/libpcsc.c b/usr/src/lib/libpcsc/common/libpcsc.c
new file mode 100644
index 0000000000..71a1d93aaa
--- /dev/null
+++ b/usr/src/lib/libpcsc/common/libpcsc.c
@@ -0,0 +1,639 @@
+/*
+ * This file and its contents are supplied under the terms of the
+ * Common Development and Distribution License ("CDDL"), version 1.0.
+ * You may only use this file in accordance with the terms of version
+ * 1.0 of the CDDL.
+ *
+ * A full copy of the text of the CDDL should have accompanied this
+ * source.  A copy of the CDDL is also available via the Internet at
+ * http://www.illumos.org/license/CDDL.
+ */
+
+/*
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+
+#include <stdlib.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <fts.h>
+#include <errno.h>
+#include <strings.h>
+#include <unistd.h>
+#include <sys/debug.h>
+#include <sys/filio.h>
+#include <sys/usb/clients/ccid/uccid.h>
+
+#include <winscard.h>
+
+/*
+ * Implementation of the PCSC library leveraging the uccid framework.
+ */
+
+/*
+ * The library handle is basically unused today. We keep this around such that
+ * consumers which expect to receive a non-NULL opaque handle have something
+ * they can use.
+ */
+typedef struct pcsc_hdl {
+	hrtime_t pcsc_create_time;
+} pcsc_hdl_t;
+
+typedef struct pcsc_card {
+	int pcc_fd;
+} pcsc_card_t;
+
+/*
+ * Required globals
+ */
+SCARD_IO_REQUEST g_rgSCardT0Pci = {
+	SCARD_PROTOCOL_T0,
+	0
+};
+
+SCARD_IO_REQUEST g_rgSCardT1Pci = {
+	SCARD_PROTOCOL_T1,
+	0
+};
+
+SCARD_IO_REQUEST g_rgSCardRawPci = {
+	SCARD_PROTOCOL_RAW,
+	0
+};
+
+const char *
+pcsc_stringify_error(const LONG err)
+{
+	switch (err) {
+	case SCARD_S_SUCCESS:
+		return ("no error");
+	case SCARD_F_INTERNAL_ERROR:
+		return ("internal error");
+	case SCARD_E_CANCELLED:
+		return ("request cancelled");
+	case SCARD_E_INVALID_HANDLE:
+		return ("invalid handle");
+	case SCARD_E_INVALID_PARAMETER:
+		return ("invalid parameter");
+	case SCARD_E_NO_MEMORY:
+		return ("no memory");
+	case SCARD_E_INSUFFICIENT_BUFFER:
+		return ("buffer was insufficiently sized");
+	case SCARD_E_INVALID_VALUE:
+		return ("invalid value passed");
+	case SCARD_E_UNKNOWN_READER:
+		return ("unknown reader");
+	case SCARD_E_TIMEOUT:
+		return ("timeout occurred");
+	case SCARD_E_SHARING_VIOLATION:
+		return ("sharing violation");
+	case SCARD_E_NO_SMARTCARD:
+		return ("no smartcard present");
+	case SCARD_E_UNKNOWN_CARD:
+		return ("unknown ICC");
+	case SCARD_E_PROTO_MISMATCH:
+		return ("protocol mismatch");
+	case SCARD_F_COMM_ERROR:
+		return ("communication error");
+	case SCARD_F_UNKNOWN_ERROR:
+		return ("unknown error");
+	case SCARD_E_READER_UNAVAILABLE:
+		return ("reader unavailable");
+	case SCARD_E_NO_SERVICE:
+		return ("service error");
+	case SCARD_E_UNSUPPORTED_FEATURE:
+		return ("ICC requires unsupported feature");
+	case SCARD_E_NO_READERS_AVAILABLE:
+		return ("no readers avaiable");
+	case SCARD_W_UNSUPPORTED_CARD:
+		return ("ICC unsupported");
+	case SCARD_W_UNPOWERED_CARD:
+		return ("ICC is not powered");
+	case SCARD_W_RESET_CARD:
+		return ("ICC was reset");
+	case SCARD_W_REMOVED_CARD:
+		return ("ICC has been removed");
+	default:
+		return ("unknown error");
+	}
+}
+
+
+/*
+ * This is called when a caller wishes to open a new Library context.
+ */
+/* ARGSUSED */
+LONG
+SCardEstablishContext(DWORD scope, LPCVOID unused0, LPCVOID unused1,
+    LPSCARDCONTEXT outp)
+{
+	pcsc_hdl_t *hdl;
+
+	if (outp == NULL) {
+		return (SCARD_E_INVALID_PARAMETER);
+	}
+
+	if (scope != SCARD_SCOPE_SYSTEM) {
+		return (SCARD_E_INVALID_VALUE);
+	}
+
+	hdl = calloc(1, sizeof (pcsc_hdl_t));
+	if (hdl == NULL) {
+		return (SCARD_E_NO_MEMORY);
+	}
+
+	hdl->pcsc_create_time = gethrtime();
+	*outp = hdl;
+	return (SCARD_S_SUCCESS);
+}
+
+/*
+ * This is called to free a library context from a client.
+ */
+LONG
+SCardReleaseContext(SCARDCONTEXT hdl)
+{
+	free(hdl);
+	return (SCARD_S_SUCCESS);
+}
+
+/*
+ * This is called to release memory allocated by the library. No, it doesn't
+ * make sense to take a const pointer when being given memory to free. It just
+ * means we have to cast it, but remember: this isn't our API.
+ */
+/* ARGSUSED */
+LONG
+SCardFreeMemory(SCARDCONTEXT unused, LPCVOID mem)
+{
+	free((void *)mem);
+	return (SCARD_S_SUCCESS);
+}
+
+/*
+ * This is called by a caller to get a list of readers that exist in the system.
+ * If lenp is set to SCARD_AUTOALLOCATE, then we are responsible for dealing
+ * with this memory.
+ */
+/* ARGSUSED */
+LONG
+SCardListReaders(SCARDCONTEXT unused, LPCSTR groups, LPSTR bufp, LPDWORD lenp)
+{
+	FTS *fts;
+	FTSENT *ent;
+	char *const root[] = { "/dev/ccid", NULL };
+	char *ubuf;
+	char **readers;
+	uint32_t len, ulen, npaths, nalloc, off, i;
+	int ret;
+
+	if (groups != NULL || lenp == NULL) {
+		return (SCARD_E_INVALID_PARAMETER);
+	}
+
+	fts = fts_open(root, FTS_LOGICAL | FTS_NOCHDIR, NULL);
+	if (fts == NULL) {
+		switch (errno) {
+		case ENOENT:
+		case ENOTDIR:
+			return (SCARD_E_NO_READERS_AVAILABLE);
+		case ENOMEM:
+		case EAGAIN:
+			return (SCARD_E_NO_MEMORY);
+		default:
+			return (SCARD_E_NO_SERVICE);
+		}
+	}
+
+	npaths = nalloc = 0;
+	/*
+	 * Account for the NUL we'll have to place at the end of this.
+	 */
+	len = 1;
+	readers = NULL;
+	while ((ent = fts_read(fts)) != NULL) {
+		size_t plen;
+
+		if (ent->fts_level != 2 || ent->fts_info == FTS_DP)
+			continue;
+
+		if (ent->fts_info == FTS_ERR || ent->fts_info == FTS_NS)
+			continue;
+
+		if (S_ISCHR(ent->fts_statp->st_mode) == 0)
+			continue;
+
+		plen = strlen(ent->fts_path) + 1;
+		if (UINT32_MAX - len <= plen) {
+			/*
+			 * I mean, it's true. But I wish I could just give you
+			 * EOVERFLOW.
+			 */
+			ret = SCARD_E_INSUFFICIENT_BUFFER;
+			goto out;
+		}
+
+		if (npaths == nalloc) {
+			char **tmp;
+
+			nalloc += 8;
+			tmp = reallocarray(readers, nalloc, sizeof (char *));
+			if (tmp == NULL) {
+				ret = SCARD_E_NO_MEMORY;
+				goto out;
+			}
+			readers = tmp;
+		}
+		readers[npaths] = strdup(ent->fts_path);
+		npaths++;
+		len += plen;
+	}
+
+	if (npaths == 0) {
+		ret = SCARD_E_NO_READERS_AVAILABLE;
+		goto out;
+	}
+
+	ulen = *lenp;
+	*lenp = len;
+	if (ulen != SCARD_AUTOALLOCATE) {
+		if (bufp == NULL) {
+			ret = SCARD_S_SUCCESS;
+			goto out;
+		}
+
+		if (ulen < len) {
+			ret = SCARD_E_INSUFFICIENT_BUFFER;
+			goto out;
+		}
+
+		ubuf = bufp;
+	} else {
+		char **bufpp;
+		if (bufp == NULL) {
+			ret = SCARD_E_INVALID_PARAMETER;
+			goto out;
+		}
+
+		ubuf = malloc(ulen);
+		if (ubuf == NULL) {
+			ret = SCARD_E_NO_MEMORY;
+			goto out;
+		}
+
+		bufpp = (void *)bufp;
+		*bufpp = ubuf;
+	}
+	ret = SCARD_S_SUCCESS;
+
+	for (off = 0, i = 0; i < npaths; i++) {
+		size_t slen = strlen(readers[i]) + 1;
+		bcopy(readers[i], ubuf + off, slen);
+		off += slen;
+		VERIFY3U(off, <=, len);
+	}
+	VERIFY3U(off, ==, len - 1);
+	ubuf[off] = '\0';
+out:
+	for (i = 0; i < npaths; i++) {
+		free(readers[i]);
+	}
+	free(readers);
+	(void) fts_close(fts);
+	return (ret);
+}
+
+/* ARGSUSED */
+LONG
+SCardConnect(SCARDCONTEXT hdl, LPCSTR reader, DWORD mode, DWORD prots,
+    LPSCARDHANDLE iccp, LPDWORD protp)
+{
+	int ret;
+	uccid_cmd_status_t ucs;
+	pcsc_card_t *card;
+
+	if (reader == NULL) {
+		return (SCARD_E_UNKNOWN_READER);
+	}
+
+	if (iccp == NULL || protp == NULL) {
+		return (SCARD_E_INVALID_PARAMETER);
+	}
+
+	if (mode != SCARD_SHARE_SHARED) {
+		return (SCARD_E_INVALID_VALUE);
+	}
+
+	if ((prots & ~(SCARD_PROTOCOL_T0 | SCARD_PROTOCOL_T1 |
+	    SCARD_PROTOCOL_RAW | SCARD_PROTOCOL_T15)) != 0) {
+		return (SCARD_E_INVALID_VALUE);
+	}
+
+	if ((prots & (SCARD_PROTOCOL_T0 | SCARD_PROTOCOL_T1)) == 0) {
+		return (SCARD_E_UNSUPPORTED_FEATURE);
+	}
+
+	if ((card = malloc(sizeof (*card))) == NULL) {
+		return (SCARD_E_NO_MEMORY);
+	}
+
+	if ((card->pcc_fd = open(reader, O_RDWR)) < 0) {
+		free(card);
+		switch (errno) {
+		case ENOENT:
+			return (SCARD_E_UNKNOWN_READER);
+		default:
+			return (SCARD_F_UNKNOWN_ERROR);
+		}
+	}
+
+	/*
+	 * Get the status of this slot and find out information about the slot.
+	 * We need to see if there's an ICC present and if it matches the
+	 * current protocol. If not, then we have to fail this.
+	 */
+	bzero(&ucs, sizeof (uccid_cmd_status_t));
+	ucs.ucs_version = UCCID_CURRENT_VERSION;
+	if (ioctl(card->pcc_fd, UCCID_CMD_STATUS, &ucs) != 0) {
+		ret = SCARD_F_UNKNOWN_ERROR;
+		goto cleanup;
+	}
+
+	if ((ucs.ucs_status & UCCID_STATUS_F_CARD_PRESENT) == 0) {
+		ret = SCARD_E_NO_SMARTCARD;
+		goto cleanup;
+	}
+
+	if ((ucs.ucs_status & UCCID_STATUS_F_CARD_ACTIVE) == 0) {
+		ret = SCARD_W_UNPOWERED_CARD;
+		goto cleanup;
+	}
+
+	if ((ucs.ucs_status & UCCID_STATUS_F_PARAMS_VALID) == 0) {
+		ret = SCARD_W_UNSUPPORTED_CARD;
+		goto cleanup;
+	}
+
+	if ((ucs.ucs_prot & prots) == 0) {
+		ret = SCARD_E_PROTO_MISMATCH;
+		goto cleanup;
+	}
+
+	*protp = ucs.ucs_prot;
+	*iccp = card;
+	return (SCARD_S_SUCCESS);
+cleanup:
+	(void) close(card->pcc_fd);
+	free(card);
+	return (ret);
+}
+
+LONG
+SCardDisconnect(SCARDHANDLE arg, DWORD disposition)
+{
+	pcsc_card_t *card = arg;
+
+	if (arg == NULL) {
+		return (SCARD_E_INVALID_HANDLE);
+	}
+
+	if (disposition != SCARD_LEAVE_CARD) {
+		return (SCARD_E_INVALID_VALUE);
+	}
+
+	if (close(card->pcc_fd) != 0) {
+		return (SCARD_F_UNKNOWN_ERROR);
+	}
+
+	free(card);
+	return (SCARD_S_SUCCESS);
+}
+
+LONG
+SCardBeginTransaction(SCARDHANDLE arg)
+{
+	uccid_cmd_txn_begin_t txn;
+	pcsc_card_t *card = arg;
+
+	if (card == NULL) {
+		return (SCARD_E_INVALID_HANDLE);
+	}
+
+	/*
+	 * The semantics of pcsc are taht this operation does not block, but
+	 * instead fails if we cannot grab it immediately.
+	 */
+	bzero(&txn, sizeof (uccid_cmd_txn_begin_t));
+	txn.uct_version = UCCID_CURRENT_VERSION;
+	txn.uct_flags = UCCID_TXN_DONT_BLOCK;
+
+	if (ioctl(card->pcc_fd, UCCID_CMD_TXN_BEGIN, &txn) != 0) {
+		VERIFY3S(errno, !=, EFAULT);
+		switch (errno) {
+		case ENODEV:
+			return (SCARD_E_READER_UNAVAILABLE);
+		case EEXIST:
+			/*
+			 * This is an odd case. It's used to tell us that we
+			 * already ahve it. For now, just treat it as success.
+			 */
+			return (SCARD_S_SUCCESS);
+		case EBUSY:
+			return (SCARD_E_SHARING_VIOLATION);
+		/*
+		 * EINPROGRESS is a weird case. It means that we were tryign to
+		 * grab a hold while another instance using the same handle was.
+		 * For now, treat it as an unknown error.
+		 */
+		case EINPROGRESS:
+		case EINTR:
+		default:
+			return (SCARD_F_UNKNOWN_ERROR);
+		}
+	}
+	return (SCARD_S_SUCCESS);
+}
+
+LONG
+SCardEndTransaction(SCARDHANDLE arg, DWORD state)
+{
+	uccid_cmd_txn_end_t txn;
+	pcsc_card_t *card = arg;
+
+	if (card == NULL) {
+		return (SCARD_E_INVALID_HANDLE);
+	}
+
+	bzero(&txn, sizeof (uccid_cmd_txn_end_t));
+	txn.uct_version = UCCID_CURRENT_VERSION;
+
+	switch (state) {
+	case SCARD_LEAVE_CARD:
+		txn.uct_flags = UCCID_TXN_END_RELEASE;
+		break;
+	case SCARD_RESET_CARD:
+		txn.uct_flags = UCCID_TXN_END_RESET;
+		break;
+	case SCARD_UNPOWER_CARD:
+	case SCARD_EJECT_CARD:
+	default:
+		return (SCARD_E_INVALID_VALUE);
+	}
+
+	if (ioctl(card->pcc_fd, UCCID_CMD_TXN_END, &txn) != 0) {
+		VERIFY3S(errno, !=, EFAULT);
+		switch (errno) {
+		case ENODEV:
+			return (SCARD_E_READER_UNAVAILABLE);
+		case ENXIO:
+			return (SCARD_E_SHARING_VIOLATION);
+		default:
+			return (SCARD_F_UNKNOWN_ERROR);
+		}
+	}
+	return (SCARD_S_SUCCESS);
+}
+
+LONG
+SCardReconnect(SCARDHANDLE arg, DWORD mode, DWORD prots, DWORD init,
+    LPDWORD protp)
+{
+	uccid_cmd_status_t ucs;
+	pcsc_card_t *card = arg;
+
+	if (card == NULL) {
+		return (SCARD_E_INVALID_HANDLE);
+	}
+
+	if (protp == NULL) {
+		return (SCARD_E_INVALID_PARAMETER);
+	}
+
+	if (mode != SCARD_SHARE_SHARED) {
+		return (SCARD_E_INVALID_VALUE);
+	}
+
+	if ((prots & ~(SCARD_PROTOCOL_T0 | SCARD_PROTOCOL_T1 |
+	    SCARD_PROTOCOL_RAW | SCARD_PROTOCOL_T15)) != 0) {
+		return (SCARD_E_INVALID_VALUE);
+	}
+
+	if ((prots & (SCARD_PROTOCOL_T0 | SCARD_PROTOCOL_T1)) == 0) {
+		return (SCARD_E_UNSUPPORTED_FEATURE);
+	}
+
+	if (init != SCARD_LEAVE_CARD) {
+		return (SCARD_E_INVALID_VALUE);
+	}
+
+	/*
+	 * Get the status of this slot and find out information about the slot.
+	 * We need to see if there's an ICC present and if it matches the
+	 * current protocol. If not, then we have to fail this.
+	 */
+	bzero(&ucs, sizeof (uccid_cmd_status_t));
+	ucs.ucs_version = UCCID_CURRENT_VERSION;
+	if (ioctl(card->pcc_fd, UCCID_CMD_STATUS, &ucs) != 0) {
+		return (SCARD_F_UNKNOWN_ERROR);
+	}
+
+	if ((ucs.ucs_status & UCCID_STATUS_F_CARD_PRESENT) == 0) {
+		return (SCARD_W_REMOVED_CARD);
+	}
+
+	if ((ucs.ucs_status & UCCID_STATUS_F_CARD_ACTIVE) == 0) {
+		return (SCARD_W_UNPOWERED_CARD);
+	}
+
+	if ((ucs.ucs_status & UCCID_STATUS_F_PARAMS_VALID) == 0) {
+		return (SCARD_W_UNSUPPORTED_CARD);
+	}
+
+	if ((ucs.ucs_prot & prots) == 0) {
+		return (SCARD_E_PROTO_MISMATCH);
+	}
+
+	*protp = ucs.ucs_prot;
+	return (SCARD_S_SUCCESS);
+}
+
+/* ARGSUSED */
+LONG
+SCardTransmit(SCARDHANDLE arg, const SCARD_IO_REQUEST *sendreq,
+    LPCBYTE sendbuf, DWORD sendlen, SCARD_IO_REQUEST *recvreq, LPBYTE recvbuf,
+    LPDWORD recvlenp)
+{
+	int len;
+	ssize_t ret;
+	pcsc_card_t *card = arg;
+
+	if (card == NULL) {
+		return (SCARD_E_INVALID_HANDLE);
+	}
+
+	/*
+	 * Ignore sendreq / recvreq.
+	 */
+	if (sendbuf == NULL || recvbuf == NULL || recvlenp == NULL) {
+		return (SCARD_E_INVALID_PARAMETER);
+	}
+
+	/*
+	 * The CCID write will always consume all data or none.
+	 */
+	ret = write(card->pcc_fd, sendbuf, sendlen);
+	if (ret == -1) {
+		switch (errno) {
+		case E2BIG:
+			return (SCARD_E_INVALID_PARAMETER);
+		case ENODEV:
+			return (SCARD_E_READER_UNAVAILABLE);
+		case EACCES:
+		case EBUSY:
+			return (SCARD_E_SHARING_VIOLATION);
+		case ENXIO:
+			return (SCARD_W_REMOVED_CARD);
+		case EFAULT:
+			return (SCARD_E_INVALID_PARAMETER);
+		case ENOMEM:
+		default:
+			return (SCARD_F_UNKNOWN_ERROR);
+		}
+	}
+	ASSERT3S(ret, ==, sendlen);
+
+	/*
+	 * Now, we should be able to block in read.
+	 */
+	ret = read(card->pcc_fd, recvbuf, *recvlenp);
+	if (ret == -1) {
+		switch (errno) {
+		case EINVAL:
+		case EOVERFLOW:
+			/*
+			 * This means that we need to update len with the real
+			 * one.
+			 */
+			if (ioctl(card->pcc_fd, FIONREAD, &len) != 0) {
+				return (SCARD_F_UNKNOWN_ERROR);
+			}
+			*recvlenp = len;
+			return (SCARD_E_INSUFFICIENT_BUFFER);
+		case ENODEV:
+			return (SCARD_E_READER_UNAVAILABLE);
+		case EACCES:
+		case EBUSY:
+			return (SCARD_E_SHARING_VIOLATION);
+		case EFAULT:
+			return (SCARD_E_INVALID_PARAMETER);
+		case ENODATA:
+		default:
+			return (SCARD_F_UNKNOWN_ERROR);
+		}
+	}
+
+	*recvlenp = ret;
+
+	return (SCARD_S_SUCCESS);
+}
diff --git a/usr/src/lib/libpcsc/common/llib-lpcsc b/usr/src/lib/libpcsc/common/llib-lpcsc
new file mode 100644
index 0000000000..095477b210
--- /dev/null
+++ b/usr/src/lib/libpcsc/common/llib-lpcsc
@@ -0,0 +1,20 @@
+/*
+ * This file and its contents are supplied under the terms of the
+ * Common Development and Distribution License ("CDDL"), version 1.0.
+ * You may only use this file in accordance with the terms of version
+ * 1.0 of the CDDL.
+ *
+ * A full copy of the text of the CDDL should have accompanied this
+ * source.  A copy of the CDDL is also available via the Internet at
+ * http://www.illumos.org/license/CDDL.
+ */
+
+/*
+ * Copyright (c) 2017 Joyent, Inc.
+ */
+
+/* LINTLIBRARY */
+/* PROTOLIB1 */
+
+#include <wintypes.h>
+#include <winscard.h>
diff --git a/usr/src/lib/libpcsc/common/mapfile-vers b/usr/src/lib/libpcsc/common/mapfile-vers
new file mode 100644
index 0000000000..2c8929c6e9
--- /dev/null
+++ b/usr/src/lib/libpcsc/common/mapfile-vers
@@ -0,0 +1,50 @@
+#
+# This file and its contents are supplied under the terms of the
+# Common Development and Distribution License ("CDDL"), version 1.0.
+# You may only use this file in accordance with the terms of version
+# 1.0 of the CDDL.
+#
+# A full copy of the text of the CDDL should have accompanied this
+# source.  A copy of the CDDL is also available via the Internet at
+# http://www.illumos.org/license/CDDL.
+#
+
+#
+# Copyright (c) 2017, Joyent, Inc.
+#
+
+#
+# MAPFILE HEADER START
+#
+# WARNING:  STOP NOW.  DO NOT MODIFY THIS FILE.
+# Object versioning must comply with the rules detailed in
+#
+#	usr/src/lib/README.mapfiles
+#
+# You should not be making modifications here until you've read the most current
+# copy of that file. If you need help, contact a gatekeeper for guidance.
+#
+# MAPFILE HEADER END
+#
+
+$mapfile_version 2
+
+SYMBOL_VERSION SUNWprivate {
+    global:
+	g_rgSCardRawPci;
+	g_rgSCardT0Pci;
+	g_rgSCardT1Pci;
+	SCardEstablishContext;
+	SCardReleaseContext;
+	SCardFreeMemory;
+	SCardListReaders;
+	SCardConnect;
+	SCardDisconnect;
+	SCardBeginTransaction;
+	SCardEndTransaction;
+	SCardReconnect;
+	SCardTransmit;
+	pcsc_stringify_error;
+    local:
+	*;
+};
diff --git a/usr/src/lib/libpcsc/common/winscard.h b/usr/src/lib/libpcsc/common/winscard.h
new file mode 100644
index 0000000000..f697f8f7ff
--- /dev/null
+++ b/usr/src/lib/libpcsc/common/winscard.h
@@ -0,0 +1,139 @@
+/*
+ * This file and its contents are supplied under the terms of the
+ * Common Development and Distribution License ("CDDL"), version 1.0.
+ * You may only use this file in accordance with the terms of version
+ * 1.0 of the CDDL.
+ *
+ * A full copy of the text of the CDDL should have accompanied this
+ * source.  A copy of the CDDL is also available via the Internet at
+ * http://www.illumos.org/license/CDDL.
+ */
+
+/*
+ * Copyright (c) 2017 Joyent, Inc.
+ */
+
+#ifndef _WINSCARD_H
+#define	_WINSCARD_H
+
+/*
+ * This library provides a compatability interface with programs designed
+ * against the PC SmartCard Library. This originates from Microsoft and has been
+ * used on a few different forms over the years by folks. The purpose of this
+ * library is for compatability.
+ *
+ * New consumers should not use this library and instead should leverage
+ * uccid(7I) instead.
+ */
+
+#include <stdint.h>
+#include <wintypes.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*
+ * This is a departure from the PCSC system which treats this as a LONG. We
+ * don't, because we'd like a single value that makes sense across j
+ */
+typedef void *SCARDCONTEXT;
+typedef void **PSCARDCONTEXT;
+typedef void **LPSCARDCONTEXT;
+typedef void *SCARDHANDLE;
+typedef void **PSCARDHANDLE;
+typedef void **LPSCARDHANDLE;
+
+/*
+ * Convenentionally this is suppsoed to be packed.
+ */
+#pragma pack(1)
+typedef struct {
+	unsigned long dwProtocol;
+	unsigned long cbPciLength;
+} SCARD_IO_REQUEST, *PSCARD_IO_REQUEST, *LPSCARD_IO_REQUEST;
+#pragma pack()
+
+extern SCARD_IO_REQUEST g_rgSCardT0Pci, g_rgSCardT1Pci, g_rgSCardRawPci;
+#define	SCARD_PCI_T0	(&g_rgSCardT0Pci)
+#define	SCARD_PCI_T1	(&g_rgSCardT1Pci)
+#define	SCARD_PCI_RAW	(&g_rgSCardRawPci)
+
+/*
+ * Return values and error codes. We strive to use the same error codes as
+ * Microsoft.
+ */
+#define	SCARD_S_SUCCESS			((LONG)0x00000000)
+#define	SCARD_F_INTERNAL_ERROR		((LONG)0x80100001)
+#define	SCARD_E_CANCELLED		((LONG)0x80100002)
+#define	SCARD_E_INVALID_HANDLE		((LONG)0x80100003)
+#define	SCARD_E_INVALID_PARAMETER	((LONG)0x80100004)
+#define	SCARD_E_NO_MEMORY		((LONG)0x80100006)
+#define	SCARD_E_INSUFFICIENT_BUFFER	((LONG)0x80100008)
+#define	SCARD_E_UNKNOWN_READER		((LONG)0x80100009)
+#define	SCARD_E_TIMEOUT			((LONG)0x8010000a)
+#define	SCARD_E_SHARING_VIOLATION	((LONG)0x8010000b)
+#define	SCARD_E_NO_SMARTCARD		((LONG)0x8010000c)
+#define	SCARD_E_UNKNOWN_CARD		((LONG)0x8010000d)
+#define	SCARD_E_PROTO_MISMATCH		((LONG)0x8010000f)
+#define	SCARD_E_INVALID_VALUE		((LONG)0x80100011)
+#define	SCARD_F_COMM_ERROR		((LONG)0x80100013)
+#define	SCARD_F_UNKNOWN_ERROR		((LONG)0x80100014)
+#define	SCARD_E_READER_UNAVAILABLE	((LONG)0x80100017)
+#define	SCARD_E_NO_SERVICE		((LONG)0x8010001D)
+#define	SCARD_E_UNSUPPORTED_FEATURE	((LONG)0x80100022)
+#define	SCARD_E_NO_READERS_AVAILABLE	((LONG)0x8010002E)
+#define	SCARD_W_UNSUPPORTED_CARD	((LONG)0x80100065)
+#define	SCARD_W_UNPOWERED_CARD		((LONG)0x80100067)
+#define	SCARD_W_RESET_CARD   		((LONG)0x80100068)
+#define	SCARD_W_REMOVED_CARD		((LONG)0x80100069)
+
+#define	SCARD_SCOPE_USER		0x0000
+#define	SCARD_SCOPE_TERMINAL		0x0001
+#define	SCARD_SCOPE_GLOBAL		0x0002
+#define	SCARD_SCOPE_SYSTEM		0x0003
+
+#define	SCARD_SHARE_EXCLUSIVE	0x0001
+#define	SCARD_SHARE_SHARED	0x0002
+#define	SCARD_SHARE_DIRECT	0x0003
+
+#define	SCARD_PROTOCOL_T0	0x0001
+#define	SCARD_PROTOCOL_T1	0x0002
+#define	SCARD_PROTOCOL_RAW	0x0004
+#define	SCARD_PROTOCOL_T15	0x0008
+
+#define	SCARD_LEAVE_CARD	0x0000
+#define	SCARD_RESET_CARD	0x0001
+#define	SCARD_UNPOWER_CARD	0x0002
+#define	SCARD_EJECT_CARD	0x0003
+
+/*
+ * This is used to indicate that the framework should allocate memory.
+ */
+#define	SCARD_AUTOALLOCATE		UINT32_MAX
+
+extern LONG SCardEstablishContext(DWORD, LPCVOID, LPCVOID, LPSCARDCONTEXT);
+extern LONG SCardReleaseContext(SCARDCONTEXT);
+
+extern LONG SCardListReaders(SCARDCONTEXT, LPCSTR, LPSTR, LPDWORD);
+
+extern LONG SCardFreeMemory(SCARDCONTEXT, LPCVOID);
+
+extern LONG SCardConnect(SCARDCONTEXT, LPCSTR, DWORD, DWORD, LPSCARDHANDLE,
+    LPDWORD);
+extern LONG SCardDisconnect(SCARDHANDLE, DWORD);
+
+extern LONG SCardBeginTransaction(SCARDHANDLE);
+extern LONG SCardEndTransaction(SCARDHANDLE, DWORD);
+extern LONG SCardReconnect(SCARDHANDLE, DWORD, DWORD, DWORD, LPDWORD);
+
+extern LONG SCardTransmit(SCARDHANDLE, const SCARD_IO_REQUEST *, LPCBYTE,
+    DWORD, SCARD_IO_REQUEST *, LPBYTE, LPDWORD);
+
+extern const char *pcsc_stringify_error(const LONG);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _WINSCARD_H */
diff --git a/usr/src/lib/libpcsc/common/wintypes.h b/usr/src/lib/libpcsc/common/wintypes.h
new file mode 100644
index 0000000000..a4c1189b92
--- /dev/null
+++ b/usr/src/lib/libpcsc/common/wintypes.h
@@ -0,0 +1,50 @@
+/*
+ * This file and its contents are supplied under the terms of the
+ * Common Development and Distribution License ("CDDL"), version 1.0.
+ * You may only use this file in accordance with the terms of version
+ * 1.0 of the CDDL.
+ *
+ * A full copy of the text of the CDDL should have accompanied this
+ * source.  A copy of the CDDL is also available via the Internet at
+ * http://www.illumos.org/license/CDDL.
+ */
+
+/*
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+
+#ifndef _WINTYPES_H
+#define	_WINTYPES_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*
+ * While we don't want to, this expects that we have Win32 style type names.
+ * Deal with conversions between Win32 and reality. Remember that Windows is an
+ * ILP32 system, but it is a LLP64 system.
+ */
+
+typedef uint8_t BYTE;
+typedef uint8_t *LPBYTE;
+typedef const uint8_t *LPCBYTE;
+typedef const void *LPCVOID;
+typedef uint32_t DWORD;
+typedef uint32_t *LPDWORD;
+typedef int32_t	LONG;
+typedef char *LPSTR;
+typedef const char *LPCSTR;
+
+/*
+ * Include a few deprecated types because folks still use them.
+ */
+typedef char *LPTSTR;
+typedef const char *LPCTSTR;
+typedef char *LPCWSTR;
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _WINTYPES_H */
diff --git a/usr/src/lib/libpcsc/i386/Makefile b/usr/src/lib/libpcsc/i386/Makefile
new file mode 100644
index 0000000000..0a22fa4dc3
--- /dev/null
+++ b/usr/src/lib/libpcsc/i386/Makefile
@@ -0,0 +1,18 @@
+#
+# This file and its contents are supplied under the terms of the
+# Common Development and Distribution License ("CDDL"), version 1.0.
+# You may only use this file in accordance with the terms of version
+# 1.0 of the CDDL.
+#
+# A full copy of the text of the CDDL should have accompanied this
+# source.  A copy of the CDDL is also available via the Internet at
+# http://www.illumos.org/license/CDDL.
+#
+
+#
+# Copyright (c) 2017 Joyent, Inc.
+#
+
+include ../Makefile.com
+
+install: all $(ROOTLIBS) $(ROOTLINKS) $(ROOTLINT)
diff --git a/usr/src/man/man7d/Makefile b/usr/src/man/man7d/Makefile
index c652a3134f..327c7b73b9 100644
--- a/usr/src/man/man7d/Makefile
+++ b/usr/src/man/man7d/Makefile
@@ -36,6 +36,7 @@ _MANFILES=	aac.7d		\
 		blkdev.7d	\
 		bnxe.7d		\
 		bscv.7d		\
+		ccid.7d		\
 		chxge.7d	\
 		console.7d	\
 		cpuid.7d	\
diff --git a/usr/src/man/man7d/ccid.7d b/usr/src/man/man7d/ccid.7d
new file mode 100644
index 0000000000..bdf6f32d69
--- /dev/null
+++ b/usr/src/man/man7d/ccid.7d
@@ -0,0 +1,517 @@
+.\"
+.\" This file and its contents are supplied under the terms of the
+.\" Common Development and Distribution License ("CDDL"), version 1.0.
+.\" You may only use this file in accordance with the terms of version
+.\" 1.0 of the CDDL.
+.\"
+.\" A full copy of the text of the CDDL should have accompanied this
+.\" source.  A copy of the CDDL is also available via the Internet at
+.\" http://www.illumos.org/license/CDDL.
+.\"
+.\"
+.\" Copyright 2019 Joyent, Inc.
+.\"
+.Dd February 14, 2019
+.Dt CCID 7D
+.Os
+.Sh NAME
+.Nm ccid
+.Nd chip card interface device USB client class driver
+.Sh SYNOPSIS
+.Pa /dev/ccid/
+.In sys/usb/clients/ccid/uccid.h
+.Sh INTERFACE LEVEL
+.Sy Volatile
+The interfaces provided by this driver are private at this time and
+subject to change.
+It should not be relied upon.
+.Sh DESCRIPTION
+The
+.Nm
+driver is a USB CCID (chip card interface device) class device driver.
+.Pp
+The driver exposes interfaces that allow consumers to send and receive
+APDUs (application protocol data unit) to a given smart card that is
+plugged into a reader.
+The driver also provides interfaces to obtain status information, the
+ATR (answer to reset), and obtain exclusive access to the device.
+In addition, the system exposes control of CCID devices through
+.Xr cfgadm 1M
+and allows programs to watch for changes through event ports.
+This is accomplished through a combination of the standard
+.Xr open 2 ,
+.Xr ioctl 2 ,
+.Xr read 2 ,
+and
+.Xr write 2
+system calls as well as through
+.Xr port_associate 3C
+and
+.Xr port_get 3C .
+.Ss Supported Devices
+The CCID specification allows for readers to come in different flavors.
+These different flavors supprot different communciation protocols and
+have different levels of automation for determining the protocol and
+transfers that are requierd.
+At this time, the following protcols are supported:
+.Bl -bullet -offset indent
+.It
+APDU
+.It
+TPDU T=1
+.El
+.Pp
+At this time, TPDU T=0 and character level readers are not supported by
+the driver.
+Readers in this category will still attach and generate events; however,
+I/O cannot be performed to them.
+.Pp
+In addition, at this time the driver does not support devices which
+require manually setting the clock and data rates to support an ICC.
+.Ss Device Model
+Each CCID class device provides a number of slots.
+Each slot may have an independent ICC (integrated circuit card or Smart
+Card) inserted into it.
+Each device, or reader, has its own directory under
+.Pa /dev/ccid
+based on its device number.
+Inside of each directory is a character device for each slot.
+A slot exists regardless of whether or not an ICC is inserted into it.
+As long as a CCID device is present in the system, its device nodes will
+be present.
+.Pp
+Slots are enumerated using the pattern:
+.Pa /dev/ccid/ccid%instance/slot%slot .
+For example, all the slots that belong to CCID instance 5 will be
+enumerated under the directory
+.Pa /dev/ccid/ccid5 .
+Slots are numbered starting at zero for each reader and increment from
+there.
+For example, the second physical slot would be numbered as slot one.
+If this were on CCID instance zero, then we would find a character
+device at:
+.Pa /dev/ccid/ccid0/slot1 .
+.Pp
+To enumerate all of the ccid devices present on the system, one could
+read all of the directories under
+.Pa /dev/ccid .
+To enumerate all of the slots on a device, one could read all of the
+direcotires under a particular CCID device, such as:
+.Pa /dev/ccid/ccid0 .
+The number of slots is also obtainable through various ioctls that will
+be discussed later on.
+It's important to note that while slot numbering will always be
+consistent for a given device, the CCID numbering is based on the driver
+instance.
+Therefore, it is possible for a device to change device numbers.
+To deal with this, symlinks based on other properties will be provided
+(for example, the USB serial number).
+.Pp
+All of the CCID devices in the system can also be listed by using the
+.Xr ccidadm 1M
+command.
+.Ss I/O Model
+To send and receive responses to commands, a program must open up the
+corresponding slot's device node.
+In many of the commands that use an ICC, there is a logical notion of
+state associated with the ICC that is mutated by performing commands on
+it.
+For example, a command might be issued that uses a PIN to unlock a slot
+or that selects a particular PIV applet for use.
+Because of this, all I/O to a given device must be performed inside the
+context of a transaction.
+When a program begins a transaction, it is guaranteed that no one else
+may send commands to the ICC.
+When a program is finished, it must explicitly end the transaction,
+which may have the side effect of resetting the ICC.
+If a program with an open transaction crashes or closes the file
+descriptor without taking other actions, then the transaction will be
+automatically closed.
+Without a transaction open, it will still be possible to issue ioctls
+that obtain the status of the slot and the reader.
+.Pp
+While in an active transaction, a program may send commands to a card.
+Sending a command and reading a response are done through the
+traditional
+.Xr read 2
+and
+.Xr write 2
+family of system calls.
+To submit a command, the program would issue a
+.Xr write 2
+family system call that contained the payload to send to the ICC.
+Once submitted, the call would return and the program would be able to
+issue a
+.Xr read 2
+system call to obtain the results.
+Once a command has been submitted, it is illegal to submit another one.
+The next command cannot be submitted until the response has been fully
+consumed.
+Similarly, if a command has not been submitted, one cannot issue a
+.Xr read 2
+system call to obtain results.
+Only a single thread may be blocked waiting to submit a command or
+.Pp
+To facilitate non-blocking operation, the underlying file descriptor may
+be opened with
+.Dv O_NONBLOCK .
+To determine whether or not certain events have occurred, event ports
+may be used.
+The exact event ports and the semantics of events are detailed in a
+later section.
+.Pp
+One important note is that readers with multiple slots often still only
+allow I/O a single command to be outstanding across all of the slots in
+the system.
+Because transactions are on a per-slot basis, it is still possible for a
+command submission to block even though one has a transaction open.
+.Pp
+While a transaction is open, various events can occur that cause a fatal
+error on the transaction.
+These include:
+.Bl -bullet -offset indent
+.It
+USB CCID reader removed
+.It
+ICC removed
+.It
+A fatal error while communicating to the device
+.It
+An administrator issued an ioctl to power off or reset the ICC
+.El
+.Pp
+Once such a fatal error has occurred, all new I/O will fail though it
+will still be possible to read any successfully completed commands.
+To clear the error state the program will need to end the transaction
+and begin a new one or close the file descriptor if the device has been
+removed.
+It is possible to obtain more detailed information about the error
+through the
+.Dv UCCID_CMD_ERROR_INFO
+command.
+.Ss Opening Devices, Exclusive Access, and Performing I/O
+To perform I/O to a particular card, one must first open the slot of
+interest.
+Opening the slot requires that the process be in the global zone and
+that it have the privilege
+.Sy PRIV_SYS_DEVICES .
+The device node can be opened through the
+.Xr open 2
+or
+.Xr openat 2
+system calls.
+Programs must request that the device be opened both for reading and
+writing
+.Po Dv O_RDWR Pc .
+.Pp
+Once the device has been opened, the program may issue ioctls or use
+event ports to get status information and watch for events on the
+system.
+.Pp
+To perform general I/O to the card, a program must be in the context of
+a transaction as discussed in the
+.Sx I/O model
+section.
+To open a transaction, a program must issue the
+.Dv UCCID_CMD_TXN_BEGIN
+command through the
+.Xr ioctl 2
+system call.
+.Pp
+When a program is done, it must issue the
+.Dv UCCID_CMD_TXN_END
+command to release the transaction.
+As part of issuing the command, the program must determine a disposition
+of what it would like done with the card when it has completed.
+These options include leaving the ICC alone and resetting the ICC.
+For many use cases, such as those where a pin is entered or the ICC's
+state is mutated, a reset is the recommended option.
+If the program crashes or closes the file descriptor without issuing a
+transaction end, then the ICC will be reset.
+.Pp
+Please see the ioctl listing in the
+.Sx IOCTLS
+section for more information on the command structure.
+.Ss Device Status and ATR
+Once a slot has been opened, any caller may issue commands to get the
+status of the slot.
+This can also be used to obtain the ATR (answer to reset) of an ICC that
+is present on the slot, if it is known.
+.Pp
+While exclusive access is not required to issue these commands, there is
+no guarantee that they will not have changed between the time that the
+program issued the command and it obtains a transaction.
+.Pp
+To obtain information about the reader, slot, and the ATR, one should
+issue the
+.Dv UCCID_CMD_STATUS
+command.
+Please see the ioctl listing in the
+.Sx IOCTLS
+section for more information.
+.Ss Event Model
+There are a number of different classes of events that can be watched
+for.
+Watching for events is performed on a per-slot basis and uses event
+ports to allow for a richer set of events than the traditional usage of
+.Xr poll 2.
+The following events can be watched for:
+.Bl -tag -offset indent -width "Ready to retrieve command results"
+.It ICC insertion
+This event fires when the ICC is inserted into a slot.
+For readers that have a non-removable ICC, this event will fire a single
+time.
+This is an edge triggered event.
+.It ICC removal
+This event fires when the ICC is removed from a slot.
+This event will never fire if an ICC cannot physically be removed from a
+device.
+This is an edge triggered event.
+.It ICC powered on
+This event fires whenever the ICC is powered on.
+This is an edge triggered event.
+.It ICC powered off
+This event fires whenever the ICC is powered off.
+This is an edge triggered event.
+.It Ready for transaction
+This event fires whenever a transaction can be initiated on the slot.
+This is a level triggered event, it will remain asserted while it is
+possible to obtain a transaction.
+It is possible that there are multiple programs that are waiting for a
+transaction to occur.
+In such a case, there is no guarantee that a program that obtains this
+event will be the one to obtain the next transaction.
+.It Ready for command submission
+This event fires whenever it is possible for a command to be submitted.
+It should not fire if the user does not have a transaction.
+This is a level triggered event that will remain valid until a command
+is submitted or a transaction error occurs.
+.It Ready to retrieve command results
+This event fires whenever a command has completed.
+This is a level triggered event that will remain valid until a command
+has been consumed.
+.It Transaction Error
+This event fires whenever something occurs that would invalidate a
+transaction.
+The generation of this event cannot be masked though it will only fire
+if a program is in a transaction.
+This event is level triggered and will persist until the transaction
+ends.
+.It Device Removed
+This event fires whenever the reader itself is removed.
+The generation of this event cannot be masked.
+This event is level triggered and will persist until the file descriptor
+is closed.
+.El
+.Pp
+To ensure that level triggered events are not missed, a generation
+number is associated with each event.
+For more information on the detailed event ports structures, please see
+the section
+.Sx IOCTLS .
+.Sh IOCTLS
+This section lists the different commands that may be issued to a CCID
+device through the
+.Xr ioctl 2
+system call.
+.Sh SYSTEM CALLS
+This section lists the different system calls that may be issued to a
+CCID device.
+.Ss open
+.Ss close
+.Ss write
+.Ss read
+.Ss close
+.Sh EVENTS
+This section describes the event payload format that is used with event
+ports.
+An event port is created with the
+.Xr port_create 3C
+function and then events are associated with it through the
+.Xr port_associate 3C
+function.
+Events are retrieved through the
+.Xr port_get 3C
+or
+.Xr port_getn 3C
+functions.
+.Pp
+The
+.Nm
+driver defines its own event source using the
+.Dv PORT_SOURCE_DEVICE
+object type.
+For more background on the types of events and their classes, see the
+section
+.Sx Event Model .
+The following macros represent different events that are used:
+.Bl -hang -offset indent -width UCCID_EVENT_COMMAND_SUBMISSION_READY
+.It Dv UCCID_EVENT_ICC_INSERTED
+Indicates interest in events when the ICC is inserted.
+.It Dv UCCID_EVENT_ICC_REMOVED
+Indicates interest in events when the ICC is removed.
+.It Dv UCCID_EVENT_ICC_POWERED_ON
+Indicates interest in events when the ICC is powered on.
+.It Dv UCCID_EVENT_ICC_POWERED_OFF
+Indicates interest in events when the ICC is powered off.
+.It Dv UCCID_EVENT_TRANSACTION_READY
+Indicates interest in events when a transaction can be initiated.
+.It Dv UCCID_EVENT_COMMAND_SUBMISSION_READY
+Indicates interest in events when a command can be submitted.
+.It Dv UCCID_EVENT_COMMAND_COMPLETED
+Indicates interest in events when a command is completed.
+.It Dv UCCID_EVENT_TRANSACTION_ERROR
+Indicates that a fatal error to the transaction occurred.
+.It Dv UCCID_EVENT_READER_GONE
+Indicates that the CCID reader has been removed from the system.
+.El
+.Pp
+The above values are used to select events to listen for and are used to
+indicate what events have fired.
+As discussed in the
+.Sx Event Model
+section, the ICC related events are normally edge triggered.
+To facilitate the detection of such events, there is a 64-bit generation
+associated with each one.
+Every time an event occurs, the generation for that event is increased.
+If the generation of an event does not match the current generation,
+then the event will immediately trigger.
+The current generation is available in the
+.Dv UCCID_CMD_STATUS
+command discussed in the
+.Sx IOCTLS
+section.
+.Pp
+To associate a CCID event with an event port, the program must use the
+following structure and issue a call to
+.Xr port_associate 3C
+with the type
+.Dv PORT_SOURCE_DEVICE .
+The CCID specific structure for this is:
+.Bd -literal -offset indent
+typedef struct uccid_event {
+	int32_t		ce_fd;
+	uint32_t	ce_version;
+	uint64_t	ce_size;
+	uint64_t	ce_desired;
+	uint64_t	ce_fired;
+	uint64_t	ce_icc_insert_gen;
+	uint64_t	ce_icc_remove_gen;
+	uint64_t	ce_icc_on_gen;
+	uint64_t	ce_icc_off_gen;
+} uccid_event_t;
+.Ed
+.Pp
+The
+.Fa ce_fd
+member should be filled in with the value of the file descriptor of the
+slot which you are asking about.
+.Pp
+The
+.Fa ce_version
+member should be set to the value
+.Dv UCCID_VERSION_ONE .
+.Pp
+The
+.Fa ce_size
+member should be set to the size of the
+.Ft uccid_event_t
+structure.
+.Pp
+The
+.Fa ce_desired
+member should be set to the bitwise-inclusive-OR of all of the events
+which are desired.
+There is no need to set either
+.Dv UCCID_EVENT_TRANSACTION_ERROR
+or
+.Dv UCCID_EVENT_READER_GONE
+as these will always be generated.
+.Pp
+The
+.Fa ce_actual
+event should be set to zero.
+This will be filled in with the actual set of events that caused this to
+fire.
+.Pp
+The
+.Fa ce_icc_insert_gen
+should be set to the current generation of the ICC insertion event that
+has occurred.
+This should be set to the value from the most recent
+.Dv UCCID_CMD_STATUS
+information that was read or set to zero.
+This will be filled in with the new generation of the event when it
+fires.
+If the
+.Dv UCCID_EVENT_ICC_INSERTED
+event is not in
+.Fa ce_desired
+then this field should be set to zero.
+.Pp
+The
+.Fa ce_icc_remove_gen
+should be set to the current generation of the ICC removal event that
+has occurred.
+This should be set to the value from the most recent
+.Dv UCCID_CMD_STATUS
+information that was read or set to zero.
+This will be filled in with the new generation of the event when it
+fires.
+If the
+.Dv UCCID_EVENT_ICC_REMOVED
+event is not in
+.Fa ce_desired
+then this field should be set to zero.
+.Pp
+The
+.Fa ce_icc_on_gen
+should be set to the current generation of the ICC power on event that
+has occurred.
+This should be set to the value from the most recent
+.Dv UCCID_CMD_STATUS
+information that was read or set to zero.
+This will be filled in with the new generation of the event when it
+fires.
+If the
+.Dv UCCID_EVENT_ICC_POWERED_ON
+event is not in
+.Fa ce_desired
+then this field should be set to zero.
+.Pp
+The
+.Fa ce_icc_off_gen
+should be set to the current generation of the ICC removal event that
+has occurred.
+This should be set to the value from the most recent
+.Dv UCCID_CMD_STATUS
+information that was read or set to zero.
+This will be filled in with the new generation of the event when it
+fires.
+If the
+.Dv UCCID_EVENT_ICC_POWERED_OFF
+event is not in
+.Fa ce_desired
+then this field should be set to zero.
+.Sh SEE ALSO
+.Xr ccidadm 1M ,
+.Xr cfgadm 1M ,
+.Xr close 2 ,
+.Xr ioctl 2 ,
+.Xr open 2 ,
+.Xr read 2 ,
+.Xr write 2 ,
+.Xr port_associate 3C ,
+.Xr port_get 3C
+.Rs
+.%T Universal Serial Bus Device Class: Smart Card CCID
+.%O Revision 1.1
+.%D April 22, 2005
+.Re
+.Rs
+.%Q ISO/IEC
+.%B Identification Cards - Integrated Circuits
+.%N Part 3: Cards with contacts — Electrical interface and transmission protocols
+.%O ISO/IEC 7616-3:2006
+.%D 2006
+.Re
diff --git a/usr/src/man/man7i/uccid.7i b/usr/src/man/man7i/uccid.7i
new file mode 100644
index 0000000000..75f767d39b
--- /dev/null
+++ b/usr/src/man/man7i/uccid.7i
@@ -0,0 +1,470 @@
+.\"
+.\" This file and its contents are supplied under the terms of the
+.\" Common Development and Distribution License ("CDDL"), version 1.0.
+.\" You may only use this file in accordance with the terms of version
+.\" 1.0 of the CDDL.
+.\"
+.\" A full copy of the text of the CDDL should have accompanied this
+.\" source.  A copy of the CDDL is also available via the Internet at
+.\" http://www.illumos.org/license/CDDL.
+.\"
+.\"
+.\" Copyright 2016 Joyent, Inc.
+.\"
+.Dd September 16, 2017
+.Dt UCCID 7I
+.Os
+.Sh NAME
+.Nm uccid
+.Nd user CCID command interface
+.Sh SYNOPSIS
+.In sys/usb/clients/ccid/uccid.h
+.Pa /dev/ccid/
+.Sh DESCRIPTION
+The
+.Nm
+command allows for a userland daemon to open and perform operations on a CCID class device.
+.Pp
+This interface allows for userland programs to be send APDU (application protocol data unit) to a given smart card and receive information back from the controller.
+This also abstracts out some of the finer grained differences between different classes of controllers and allows for exclusive access to devices.
+.Pp
+The
+.Nm
+commands operate on device nodes through a combination of the standard
+.Xr open 2 ,
+.Xr read 2 ,
+.Xr write 2 ,
+and
+.Xr poll 2
+system calls and provides several commands that may be issued through
+the
+.Xr ioctl 2
+system call.
+.Ss Device Nodes
+A given CCID class device provides a number of slots.
+Inside of each slot a card may or may not be present.
+A character device is created to represent each
+.Em slot
+of a CCID class device.
+This means that as long as a given CCID class device is present, then there will be a minor node for the slot, regardless of whether a card or not is present.
+.Pp
+A character device will be created under
+.Pa /dev
+for each slot of a CCID class device.
+Slots will be enumerated at
+.Pa /dev/ccid/ccid%d/slot%d .
+For example, all the slots under CCID instance 5 will be found in the
+directory
+.Pa /dev/ccid/ccid5/ .
+Slot two on the first enumerated CCID instance 0 will be found at
+.Pa /dev/ccid/ccid0/slot2 .
+While the enumeration of slots within a device should always be
+consistent (subject to the device), the instance number of a device may
+change.
+Additional symlinks to device directories may be present based on
+properties such as a USB serial number.
+.Ss Opening Devices, Exclusive Access, and Transactions
+A given slot may be opened through its path under
+.Pa /dev .
+To open a device, the user must be in the global zone and must have the
+.Sy PRIV_SYS_DEVICES
+privilege.
+To access the device node, the driver should call
+.Xr open 2
+or
+.Xr openat 2 .
+The device node must be opened for both read and write
+.Pq Dv O_RDWR .
+If only one of read or write is specified, the open will fail.
+.Pp
+To send commands to and from the device, a user must have exclusive
+access.
+Exclusive access can be obtained in one of two ways.
+The first is to use the
+.Dv O_EXCL
+flag during a call to
+.Xr open 2 .
+The second is to perform the
+.Dv UCCID_CMD_TXN_BEGIN
+command through
+.Xr ioctl 2 .
+.Pp
+Exclusive access is obtained on a slot level.
+Once granted, exclusive access is maintained regardless if cards are
+inserted or removed.
+To drop exclusive access, the driver may perform the
+.Dv UCCID_CMD_TXN_END
+command or close the file descriptor.
+If a process holding exclusive access exits or crashes, the system will
+behave as though it called
+.Xr close 2
+on the file descriptor.
+.Pp
+If something else already has exclusive access, then callers will block
+until exclusive access is relinquished.
+If there are multiple callers seeking exclusive access blocked, the order
+at which they will be granted that access is undefined.
+If the caller does not wish to block while obtaining exclusive access,
+it may use the
+.Dv O_NDELAY
+or
+.Dv UCCID_TXN_F_DONT_BLOCK
+flag as needed.
+See the later discussions of
+.Xr open 2
+and the
+.Dv UCCID_CMD_TXN_BEGIN
+command for more information.
+.Pp
+Once exclusive access is obtained, a client may send any number of APDUs
+or issue any number of commands that it desires.
+.Pp
+A well behaved client will ensure that it does not have any outstanding
+I/O when it drops exclusive access.
+If any threads are blocked in the read or write family of routines, they
+will error out.
+Any outstanding commands that have not been read, will be dropped.
+.Pp
+It is important that a given caller only attempt to have exclusive
+access to a single slot at any given time.
+Otherwise, if the caller is holding onto exclusive access on one device
+while attempting to obtain exclusive access to another, there is a
+chance of deadlock with another caller that is attempting to obtain
+exclusive access to multiple slots in a different order.
+.Ss Device Status and ATR
+Once the device is open, any caller may issue commands to get the status
+of the slot and to obtain the ATR (answer to reset) data of a card, if
+it is present in the slot.
+.Pp
+A caller may issues these commands if they do not have exclusive access;
+however, there is no guarantee that it will not have changed by the time
+the caller obtains exclusive access.
+As such, it is not recommended to ask for the ATR data while exclusive
+access is not present.
+.Pp
+The status of the slot is used to indicate if a card is present in the
+slot and if so, whether or not the card has been activated and is thus
+ready for use.
+To obtain this information, issue the
+.Dv UCCID_CMD_STATUS
+command.
+See the
+.Sx COMMANDS
+section for details of the structure.
+.Pp
+To obtain the ATR data, callers may issue the
+.Dv UCCID_CMD_GETATR
+command.
+This command can be used to both fetch the actual data and to get the
+size of the ATR payload, which may vary from card to card.
+.Ss Performing I/O
+Once exclusive access is obtained, the caller may use the
+.Xr read 2
+and
+.Xr write 2
+family of system calls to send and receive APDUs to the device.
+I/O to a CCID class device functions must always send and receive an
+entire APDU.
+This is similar to the behavior of reading and writing data to a
+datagram class socket.
+.Pp
+To send a command, the caller should issue a system call from the
+.Xr write 2
+family.
+That command will be sent to the driver by the host.
+Only once the command has been fully sent to the device, will the write
+system call return.
+Once the write is finished, the caller should use the
+.Xr read 2
+family of system calls to obtain the result.
+If the caller would rather use non-blocking I/O, it may poll on the
+device and wait for a
+.Dv POLLIN
+event.
+.Pp
+The caller does not need to worry about the framing of APDU data to and from
+a CCID class device.
+This will be handled by a combination of hardware and the CCID driver
+framework.
+.Pp
+If no card is present or the caller does not have exclusive access, then
+reads and writes will always fail.
+If a card is removed, outstanding I/O operations will all fail, even if
+another card is inserted before all of the commands can be failed.
+.Pp
+CCID class devices may only have one outstanding command on a given
+slot.
+While callers may issue multiple commands to the driver only a single
+command will be issued to a given slot at any given time.
+Other commands will be blocked and processed in turn.
+It is recommended that callers do not issue multiple commands as the
+ordering of said commands is not guaranteed.
+.Ss Card Insertion and Removal Notifications
+XXX
+.Sh SYSTEM CALLS
+.Ss open family
+The
+.Xr open 2
+and
+.Xr openat 2
+system calls are used to open a device.
+For more details, see the
+.Sx Opening Devices, Exclusive Access, and Transactions
+section.
+.Pp
+The following flags that may be passed to open have special
+significance:
+.Bl -tag -width Dv
+.It Dv O_EXCL
+Request exclusive access to the device.
+This will block until access is available unless
+.Dv O_NDELAY
+is also specified.
+.It Dv O_NDELAY
+Indicates that if exclusive access it not available, fail immediately.
+This flag may not be specified without
+.Dv O_EXCL .
+.It Dv O_NONBLOCK
+Indicates that non-blocking
+.Xr read 2
+and
+.Xr write 2
+system calls should be performed.
+This may be changed at any time through the
+.Dv F_SETFL
+command to
+.Xr fcntl 2 .
+.El
+.Ss read family
+The
+.Xr read 2 ,
+.Xr readv 2 ,
+.Xr pread 2 ,
+and
+.Xr preadv 2
+systems calls reads an entire APDU response into one or more buffers.
+Each read of the device will consume an entire CCID APDU response,
+similar to operating on a datagram device.
+If the
+.Dv O_NONBLOCK
+flag has been specified and no data is available, the system call will
+return immediately.
+File offsets are ignored and in the case of
+.Xr read 2
+and
+.Xr readv 2 ,
+explicitly reset.
+.Pp
+If no card is present in the slot or the caller does not have exclusive
+access, a read will always fail.
+.Ss write
+The
+.Xr write 2 ,
+.Xr writev 2 ,
+.Xr pwrite 2 ,
+and
+.Xr pwritev 2
+system calls transmit an entire APDU to a device.
+Once the command has been fully transfered, the write will return.
+If there are multiple outstanding commands in flight, the write will
+block and the order of commands is not guaranteed.
+The
+.Dv O_NONBLOCK
+flag is ignored when writing.
+File offsets are ignored and in the case of
+.Xr write 2
+and
+.Xr writev 2 ,
+explicitly reset.
+.Pp
+If no card is present in the slot or a caller does not have exclusive
+access, a write will always fail.
+.Ss poll
+The slot device can be polled for
+.Dv POLLIN
+which is used to indicate that a command is readable or it may be polled
+for
+.Dv POLLHUP
+which is used to indicate that a card has been removed from a slot.
+No other poll flags will be issued by the device.
+.Pp
+If no card is present in the slot or a caller does not have exclusive
+access, all attempts to poll will fail.
+.Ss ioctl
+The
+.Xr ioctl 2
+system call behaves normally.
+Valid commands are listed in the
+.Sx COMMANDS
+section.
+.Ss close
+The
+.Xr close 2
+system call behaves normally.
+When the final
+.Xr close 2
+is performed from a given handle, any exclusive access will be
+discarded.
+If a file descriptor has been duplicated through the means of the
+.Xr dup 2
+family of system calls, then the final close refers to the time when all
+such duplicated file descriptors have been closed.
+.Sh COMMANDS
+For each of the commands listed below, a specific structure accompanies
+it.
+The first member of each of these structures is a version field which
+represents the current form of the structure.
+Callers should always set this member to
+.Dv UCCID_CURRENT_VERSION .
+.Ss UCCID_CMD_TXN_BEGIN
+The
+.Dv UCCID_CMD_TXN_BEGIN
+command is used to begin a transaction.
+The command will block until exclusive access is available to the
+caller.
+If the caller does not wish to block, it should set the
+.Dv UCCID_TXN_F_DONT_BLOCK
+flag.
+.Pp
+The command uses the following structure:
+.Bd -literal -offset indent
+typedef struct	uccid_cmd_txn_begin {
+	uint_t	uct_version;
+	uint_t	uct_flags;
+} uccid_cmd_txn_begin_t;
+.Ed
+.Pp
+The fields of the
+.Vt uccid_cmd_txn_begin_t
+have the following meanings:
+.Bl -tag -width Fa
+.It Fa uct_version
+Indicates the current version of the structure.
+Should be set to
+.Dv UCCID_CURRENT_VERSION .
+.It Fa uct_flags
+Flags that impact the behavior of the command.
+The following flags are
+defined:
+.Bl -tag -width Dv
+.It Dv UCCID_TXN_F_DONT_BLOCK
+The command should not block for exclusive access.
+If exclusive access is not available, then the command will fail
+immediately.
+.El
+.Pp
+If an unknown flag is specified, an error will be generated.
+.El
+.Ss UCCID_CMD_TXN_END
+The
+.Dv UCCID_CMD_TXN_END
+command is used to end a transaction whether it was started through the
+.Dv UCCID_CMD_TXN_BEGIN
+command or by passing
+.Dv O_EXCL
+to the
+.Xr open 2
+system call.
+.Pp
+The command uses the following structure:
+.Bd -literal -offset indent
+typedef struct	uccid_cmd_txn_end {
+	uint_t	uct_version;
+} uccid_cmd_txn_end_t;
+.Ed
+.Pp
+The fields of the
+.Vt uccid_cmd_txn_end_t
+have the following meanings:
+.Bl -tag -width Fa
+.It Fa uct_version
+Indicates the current version of the structure.
+Should be set to
+.Dv UCCID_CURRENT_VERSION .
+.El
+.Ss UCCID_CMD_STATUS
+This command is used to obtain the status of the slot.
+It may be used regardless of whether or not the caller has exclusive
+access.
+.Pp
+The command uses the following structure:
+.Bd -literal -offset indent
+typedef struct	uccid_cmd_status {
+	uint_t	ucs_version;
+	uint_t	ucs_status;
+} uccid_cmd_status_t;
+.Ed
+.Pp
+The fields of the
+.Vt uccid_cmd_status_t
+have the following meanings:
+.Bl -tag -width Fa
+.It Fa ucs_version
+Indicates the current version of the structure.
+Should be set to
+.Dv UCCID_CURRENT_VERSION .
+.It Fa ucs_status
+This value is ignored when issuing the command.
+On return, it will be filled in with various flags that describe the
+current status of the slot.
+The following flags are defined:
+.Bl -tag -width Dv
+.It Dv UCCID_STATUS_F_CARD_PRESENT
+A card has been inserted into the slot of the CCID class device.
+.It Dv UCCID_STATUS_F_CARD_ACTIVE
+The inserted card has been successfully activated.
+.El
+.Pp
+The
+.Dv UCCID_STATUS_F_CARD_ACTIVE
+flag will only be set if the
+.Dv UCCID_STATUS_F_CARD_PRESENT
+flag is set.
+.El
+.Ss UCCID_CMD_GETATR
+The
+.Dv UCCID_CMD_GETATR
+command is used to obtain the ATR (answer to reset) data from a card
+that is present in the slot.
+This command does not require exclusive access; however, there is
+nothing that guarantees the ATR data will not have changed by the time
+exclusive access is granted.
+To obtain the size of the ATR data, the caller should set the buffer
+length to zero.
+It will be filled in to indicate the required size of the buffer
+otherwise.
+.Pp
+The command uses the following structure:
+.Bd -literal -offset indent
+typedef struct uccid_cmd_getatr {
+	uint_t	ucg_version;
+	uint_t	ucg_buflen;
+	/* XXX should this just be a static buffer with a likely maximum size? */
+	void	*ucg_buffer;
+} uccid_cmd_getattr_t;
+.Ed
+.Pp
+The fields of the
+.Vt uccid_cmd_getatr_t
+have the following meanings:
+.Bl -tag -width Fa
+.It Fa ucg_version
+Indicates the current version of the structure.
+Should be set to
+.Dv UCCID_CURRENT_VERSION .
+.It Fa ucg_buflen
+Indicates the size in bytes of the buffer
+.Fa ucg_buffer .
+.It Fa ucg_buffer
+A pointer to a buffer to place the ATR data.
+.El
+.Pp
+When this command is issued, the system will check the size of
+.Fa ucg_buflen .
+If it is sufficient to hold the ATR data, then the ATR data will be
+copied out into
+.Fa ucb_buffer
+and the number of bytes written will be placed into
+.Fa ucb_buflen .
+If the buffer length is insufficient or zero, then no copying will
+occur; however, the buffer length will be updated.
diff --git a/usr/src/test/os-tests/tests/uccid/Makefile b/usr/src/test/os-tests/tests/uccid/Makefile
new file mode 100644
index 0000000000..614309c494
--- /dev/null
+++ b/usr/src/test/os-tests/tests/uccid/Makefile
@@ -0,0 +1,90 @@
+#
+# This file and its contents are supplied under the terms of the
+# Common Development and Distribution License ("CDDL"), version 1.0.
+# You may only use this file in accordance with the terms of version
+# 1.0 of the CDDL.
+#
+# A full copy of the text of the CDDL should have accompanied this
+# source.  A copy of the CDDL is also available via the Internet at
+# http://www.illumos.org/license/CDDL.
+#
+
+#
+# Copyright (c) 2017, Joyent, Inc.
+#
+
+include $(SRC)/Makefile.master
+
+ROOTOPTPKG = $(ROOT)/opt/os-tests
+TESTDIR = $(ROOTOPTPKG)/tests/uccid
+
+PROGS = 		\
+	atrparse	\
+	excl-basic	\
+	excl-badread	\
+	excl-close	\
+	excl-loop	\
+	excl-nonblock	\
+	excl-reset	\
+	notxn-poll	\
+	status		\
+	pollin		\
+	pollout		\
+	txn-pollerr	\
+	yk
+
+DATA = \
+	smartcard_list.txt
+
+COMMON_OBJS = \
+	atr.o
+
+atrparse := EXTRA_OBJS = $(COMMON_OBJS)
+
+LNPROGS = $(PROGS:%=%.ln)
+
+include $(SRC)/cmd/Makefile.cmd
+include $(SRC)/test/Makefile.com
+
+CMDS = $(PROGS:%=$(TESTDIR)/%)
+$(CMDS) := FILEMODE = 0555
+$(ROOTDATA) := FILEMODE = 0444
+
+CPPFLAGS += -D_REENTRANT -I$(SRC)/common/ccid/
+
+all: $(PROGS)
+
+install: all $(CMDS) $(ROOTDATA)
+
+lint: $(LNPROGS)
+
+clobber: clean
+	-$(RM) $(PROGS)
+
+clean:
+	-$(RM) *.o
+
+$(PROGS): $(COMMON_OBJS)
+
+$(CMDS): $(TESTDIR) $(PROGS)
+
+$(TESTDIR):
+	$(INS.dir)
+
+$(TESTDIR)/%: %
+	$(INS.file)
+
+%.o: $(SRC)/common/ccid/%.c
+	$(COMPILE.c) -o $@ -c $<
+	$(POST_PROCESS_O)
+
+%.o: %.c
+	$(COMPILE.c) -o $@ -c $<
+	$(POST_PROCESS_O)
+
+%: %.o
+	$(LINK.c) -o $@ $< $(EXTRA_OBJS)
+	$(POST_PROCESS)
+
+%.ln: %
+	$(LINT.c) $<.c $(LDLIBS)
diff --git a/usr/src/test/os-tests/tests/uccid/atrparse.c b/usr/src/test/os-tests/tests/uccid/atrparse.c
new file mode 100644
index 0000000000..034fd37732
--- /dev/null
+++ b/usr/src/test/os-tests/tests/uccid/atrparse.c
@@ -0,0 +1,731 @@
+/*
+ * This file and its contents are supplied under the terms of the
+ * Common Development and Distribution License ("CDDL"), version 1.0.
+ * You may only use this file in accordance with the terms of version
+ * 1.0 of the CDDL.
+ *
+ * A full copy of the text of the CDDL should have accompanied this
+ * source.  A copy of the CDDL is also available via the Internet at
+ * http://www.illumos.org/license/CDDL.
+ */
+
+/*
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+
+/*
+ * Verify that we can grab a basic exclusive lock through an ioctl on the slot.
+ * Then that we can release it afterwards.
+ */
+
+#include <err.h>
+#include <stdlib.h>
+
+#include <atr.h>
+
+typedef struct atr_vals {
+} atr_vals_t;
+
+typedef struct atr_test {
+	const char *ar_test;
+	uint8_t ar_len;
+	uint8_t ar_buf[64];
+	atr_parsecode_t ar_retval;
+	/* Everything after this is data from the ATR */
+	atr_protocol_t ar_sup;
+	atr_protocol_t ar_def;
+	boolean_t ar_neg;
+	uint8_t ar_fi;
+	uint8_t ar_di;
+	atr_convention_t ar_conv;
+	uint8_t ar_guard;
+	atr_clock_stop_t ar_stop;
+	/* These will be checked based on sup prot */
+	uint8_t ar_t0_wi;
+	atr_t1_checksum_t  ar_t1_cksum;
+	uint8_t ar_t1_bwi;
+	uint8_t ar_t1_cwi;
+	uint8_t ar_t1_ifsc;
+} atr_test_t;
+
+atr_test_t atr_tests[] = {
+	{ "zero-length data", 0, { 0 }, ATR_CODE_TOO_SHORT },
+	{ "No T0", 1, { 0x3f }, ATR_CODE_TOO_SHORT },
+	{ "Too much data", 34, { 0 }, ATR_CODE_TOO_LONG },
+	{ "Overrun T0 (1)", 2, { 0x3b, 0x10 }, ATR_CODE_OVERRUN },
+	{ "Overrun T0 (2)", 2, { 0x3b, 0x80 }, ATR_CODE_OVERRUN },
+	{ "Overrun T0 (3)", 2, { 0x3b, 0x01 }, ATR_CODE_OVERRUN },
+	{ "Overrun T0 (4)", 2, { 0x3b, 0x11 }, ATR_CODE_OVERRUN },
+	{ "Overrun T0 (5)", 2, { 0x3b, 0xff }, ATR_CODE_OVERRUN },
+	{ "Overrun TD1", 3, { 0x3b, 0x80, 0x10 }, ATR_CODE_OVERRUN },
+	{ "Overrun TD2", 4, { 0x3b, 0x80, 0x80, 0x10 }, ATR_CODE_OVERRUN },
+	{ "Overrun TD", 33, { 0x3b, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+	    0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+	    0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+	    0x80, 0x80, 0x80 }, ATR_CODE_OVERRUN },
+	{ "T0 w/ T=15 and no cksum", 5, { 0x3b, 0x80, 0x80, 0x1f, 0x00 },
+	    ATR_CODE_OVERRUN },
+	{ "Bad TS (1)", 2, { 0x3a, 0x00 }, ATR_CODE_INVALID_TS },
+	{ "Bad TS (2)", 2, { 0xff, 0x00 }, ATR_CODE_INVALID_TS },
+	{ "T0 w/ T=15 and bad cksum", 6, { 0x3b, 0x80, 0x80, 0x1f, 0x00, 0x00 },
+	    ATR_CODE_CHECKSUM_ERROR },
+	{ "T0 w/ T=15 and bad cksum (make sure no TS)", 6, { 0x3b, 0x80, 0x80, 0x1f, 0x00, 0x24 },
+	    ATR_CODE_CHECKSUM_ERROR },
+	{ "T=15 in TD1", 4, { 0x3b, 0x80, 0x0f, 0x8f }, ATR_CODE_INVALID_TD1 },
+	{
+		.ar_test = "Minimal T0 Direct",
+		.ar_len = 2,
+		.ar_buf = { 0x3b, 0x00 },
+		.ar_sup = ATR_P_T0,
+		.ar_def = ATR_P_T0,
+		.ar_neg = B_TRUE,
+		.ar_fi = 1,
+		.ar_di = 1,
+		.ar_conv = ATR_CONVENTION_DIRECT,
+		.ar_guard = 0,
+		.ar_stop = ATR_CLOCK_STOP_NONE,
+		.ar_t0_wi = 10,
+	}, {
+		.ar_test = "Minimal T0 Inverse",
+		.ar_len = 2,
+		.ar_buf = { 0x3f, 0x00 },
+		.ar_sup = ATR_P_T0,
+		.ar_def = ATR_P_T0,
+		.ar_neg = B_TRUE,
+		.ar_fi = 1,
+		.ar_di = 1,
+		.ar_conv = ATR_CONVENTION_INVERSE,
+		.ar_guard = 0,
+		.ar_stop = ATR_CLOCK_STOP_NONE,
+		.ar_t0_wi = 10,
+	}, {
+		.ar_test = "T0 Fi/Di (1)",
+		.ar_len = 3,
+		.ar_buf = { 0x3b, 0x10, 0x24 },
+		.ar_sup = ATR_P_T0,
+		.ar_def = ATR_P_T0,
+		.ar_neg = B_TRUE,
+		.ar_fi = 2,
+		.ar_di = 4,
+		.ar_conv = ATR_CONVENTION_DIRECT,
+		.ar_guard = 0,
+		.ar_stop = ATR_CLOCK_STOP_NONE,
+		.ar_t0_wi = 10,
+	}, {
+		.ar_test = "T0 Fi/Di (2)",
+		.ar_len = 3,
+		.ar_buf = { 0x3b, 0x10, 0x93 },
+		.ar_sup = ATR_P_T0,
+		.ar_def = ATR_P_T0,
+		.ar_neg = B_TRUE,
+		.ar_fi = 9,
+		.ar_di = 3,
+		.ar_conv = ATR_CONVENTION_DIRECT,
+		.ar_guard = 0,
+		.ar_stop = ATR_CLOCK_STOP_NONE,
+		.ar_t0_wi = 10,
+	}, {
+		.ar_test = "T0 Ignore deprecated TB1",
+		.ar_len = 3,
+		.ar_buf = { 0x3b, 0x20, 0x42 },
+		.ar_sup = ATR_P_T0,
+		.ar_def = ATR_P_T0,
+		.ar_neg = B_TRUE,
+		.ar_fi = 1,
+		.ar_di = 1,
+		.ar_conv = ATR_CONVENTION_DIRECT,
+		.ar_guard = 0,
+		.ar_stop = ATR_CLOCK_STOP_NONE,
+		.ar_t0_wi = 10,
+	}, {
+		.ar_test = "T0 Ignore deprecated TB2",
+		.ar_len = 4,
+		.ar_buf = { 0x3b, 0x80, 0x20, 0x42 },
+		.ar_sup = ATR_P_T0,
+		.ar_def = ATR_P_T0,
+		.ar_neg = B_TRUE,
+		.ar_fi = 1,
+		.ar_di = 1,
+		.ar_conv = ATR_CONVENTION_DIRECT,
+		.ar_guard = 0,
+		.ar_stop = ATR_CLOCK_STOP_NONE,
+		.ar_t0_wi = 10,
+	}, {
+		.ar_test = "T0 Ignore deprecated TB1/TB2",
+		.ar_len = 5,
+		.ar_buf = { 0x3b, 0xa0, 0x55, 0x20, 0x42 },
+		.ar_sup = ATR_P_T0,
+		.ar_def = ATR_P_T0,
+		.ar_neg = B_TRUE,
+		.ar_fi = 1,
+		.ar_di = 1,
+		.ar_conv = ATR_CONVENTION_DIRECT,
+		.ar_guard = 0,
+		.ar_stop = ATR_CLOCK_STOP_NONE,
+		.ar_t0_wi = 10,
+	}, {
+		.ar_test = "T0 Encode TC1",
+		.ar_len = 3,
+		.ar_buf = { 0x3b, 0x40, 0x23 },
+		.ar_sup = ATR_P_T0,
+		.ar_def = ATR_P_T0,
+		.ar_neg = B_TRUE,
+		.ar_fi = 1,
+		.ar_di = 1,
+		.ar_conv = ATR_CONVENTION_DIRECT,
+		.ar_guard = 0x23,
+		.ar_stop = ATR_CLOCK_STOP_NONE,
+		.ar_t0_wi = 10,
+	}, {
+		.ar_test = "T0 TA2 says neg",
+		.ar_len = 4,
+		.ar_buf = { 0x3b, 0x80, 0x10, 0x00 },
+		.ar_sup = ATR_P_T0,
+		.ar_def = ATR_P_T0,
+		.ar_neg = B_TRUE,
+		.ar_fi = 1,
+		.ar_di = 1,
+		.ar_conv = ATR_CONVENTION_DIRECT,
+		.ar_guard = 0,
+		.ar_stop = ATR_CLOCK_STOP_NONE,
+		.ar_t0_wi = 10,
+	}, {
+		.ar_test = "T0 TA2 says not neg",
+		.ar_len = 4,
+		.ar_buf = { 0x3b, 0x80, 0x10, 0x80 },
+		.ar_sup = ATR_P_T0,
+		.ar_def = ATR_P_T0,
+		.ar_neg = B_FALSE,
+		.ar_fi = 1,
+		.ar_di = 1,
+		.ar_conv = ATR_CONVENTION_DIRECT,
+		.ar_guard = 0,
+		.ar_stop = ATR_CLOCK_STOP_NONE,
+		.ar_t0_wi = 10,
+	}, {
+		.ar_test = "T0 TA2 says not neg, honor Fi/Di",
+		.ar_len = 5,
+		.ar_buf = { 0x3b, 0x90, 0x24, 0x10, 0x80 },
+		.ar_sup = ATR_P_T0,
+		.ar_def = ATR_P_T0,
+		.ar_neg = B_FALSE,
+		.ar_fi = 2,
+		.ar_di = 4,
+		.ar_conv = ATR_CONVENTION_DIRECT,
+		.ar_guard = 0,
+		.ar_stop = ATR_CLOCK_STOP_NONE,
+		.ar_t0_wi = 10,
+	}, {
+		.ar_test = "T0 TA2 says not neg, don't honor Fi/Di",
+		.ar_len = 5,
+		.ar_buf = { 0x3b, 0x90, 0x24, 0x10, 0x90 },
+		.ar_sup = ATR_P_T0,
+		.ar_def = ATR_P_T0,
+		.ar_neg = B_FALSE,
+		.ar_fi = 1,
+		.ar_di = 1,
+		.ar_conv = ATR_CONVENTION_DIRECT,
+		.ar_guard = 0,
+		.ar_stop = ATR_CLOCK_STOP_NONE,
+		.ar_t0_wi = 10,
+	}, {
+		.ar_test = "T0 TC2 set",
+		.ar_len = 4,
+		.ar_buf = { 0x3b, 0x80, 0x40, 0x35 },
+		.ar_sup = ATR_P_T0,
+		.ar_def = ATR_P_T0,
+		.ar_neg = B_TRUE,
+		.ar_fi = 1,
+		.ar_di = 1,
+		.ar_conv = ATR_CONVENTION_DIRECT,
+		.ar_guard = 0,
+		.ar_stop = ATR_CLOCK_STOP_NONE,
+		.ar_t0_wi = 0x35,
+	}, {
+		.ar_test = "T0 T15 empty (requires checksum)",
+		.ar_len = 5,
+		.ar_buf = { 0x3b, 0x80, 0x80, 0x0f, 0x0f },
+		.ar_sup = ATR_P_T0,
+		.ar_def = ATR_P_T0,
+		.ar_neg = B_TRUE,
+		.ar_fi = 1,
+		.ar_di = 1,
+		.ar_conv = ATR_CONVENTION_DIRECT,
+		.ar_guard = 0,
+		.ar_stop = ATR_CLOCK_STOP_NONE,
+		.ar_t0_wi = 10,
+	}, {
+		.ar_test = "T0 T15 Clock Stop (1)",
+		.ar_len = 6,
+		.ar_buf = { 0x3b, 0x80, 0x80, 0x1f, 0x07, 0x18 },
+		.ar_sup = ATR_P_T0,
+		.ar_def = ATR_P_T0,
+		.ar_neg = B_TRUE,
+		.ar_fi = 1,
+		.ar_di = 1,
+		.ar_conv = ATR_CONVENTION_DIRECT,
+		.ar_guard = 0,
+		.ar_stop = ATR_CLOCK_STOP_NONE,
+		.ar_t0_wi = 10,
+	}, {
+		.ar_test = "T0 T15 Clock Stop (2)",
+		.ar_len = 6,
+		.ar_buf = { 0x3b, 0x80, 0x80, 0x1f, 0x47, 0x58 },
+		.ar_sup = ATR_P_T0,
+		.ar_def = ATR_P_T0,
+		.ar_neg = B_TRUE,
+		.ar_fi = 1,
+		.ar_di = 1,
+		.ar_conv = ATR_CONVENTION_DIRECT,
+		.ar_guard = 0,
+		.ar_stop = ATR_CLOCK_STOP_LOW,
+		.ar_t0_wi = 10,
+	}, {
+		.ar_test = "T0 T15 Clock Stop (3)",
+		.ar_len = 6,
+		.ar_buf = { 0x3b, 0x80, 0x80, 0x1f, 0x87, 0x98 },
+		.ar_sup = ATR_P_T0,
+		.ar_def = ATR_P_T0,
+		.ar_neg = B_TRUE,
+		.ar_fi = 1,
+		.ar_di = 1,
+		.ar_conv = ATR_CONVENTION_DIRECT,
+		.ar_guard = 0,
+		.ar_stop = ATR_CLOCK_STOP_HI,
+		.ar_t0_wi = 10,
+	}, {
+		.ar_test = "T0 T15 Clock Stop (4)",
+		.ar_len = 6,
+		.ar_buf = { 0x3b, 0x80, 0x80, 0x1f, 0xc7, 0xd8 },
+		.ar_sup = ATR_P_T0,
+		.ar_def = ATR_P_T0,
+		.ar_neg = B_TRUE,
+		.ar_fi = 1,
+		.ar_di = 1,
+		.ar_conv = ATR_CONVENTION_DIRECT,
+		.ar_guard = 0,
+		.ar_stop = ATR_CLOCK_STOP_BOTH,
+		.ar_t0_wi = 10,
+	}, {
+		.ar_test = "T0 with random prots",
+		.ar_len = 7,
+		.ar_buf = { 0x3b, 0x80, 0x84, 0x85, 0x88, 0x0f, 0x06 },
+		.ar_sup = ATR_P_T0,
+		/*
+		 * This comes from the fact that TD1 is T=4 and that isn't
+		 * supported in the system.
+		 */
+		.ar_def = ATR_P_NONE,
+		.ar_neg = B_TRUE,
+		.ar_fi = 1,
+		.ar_di = 1,
+		.ar_conv = ATR_CONVENTION_DIRECT,
+		.ar_guard = 0,
+		.ar_stop = ATR_CLOCK_STOP_NONE,
+		.ar_t0_wi = 10,
+	}, {
+		.ar_test = "Actual ATR (1, Yubikey4)",
+		.ar_len = 18,
+		.ar_buf = { 0x3b, 0xf8, 0x13, 0x00, 0x00, 0x81, 0x31, 0xfe,
+		    0x15, 0x59, 0x75, 0x62, 0x69, 0x6b, 0x65, 0x79, 0x34,
+		    0xd4 },
+		.ar_sup = ATR_P_T1,
+		.ar_def = ATR_P_T1,
+		.ar_neg = B_TRUE,
+		.ar_fi = 1,
+		.ar_di = 3,
+		.ar_conv = ATR_CONVENTION_DIRECT,
+		.ar_guard = 0,
+		.ar_stop = ATR_CLOCK_STOP_NONE,
+		.ar_t1_cksum = ATR_T1_CHECKSUM_LRC,
+		.ar_t1_bwi = 1,
+		.ar_t1_cwi = 5,
+		.ar_t1_ifsc = 254
+	}, {
+		.ar_test = "Actual ATR (2)",
+		.ar_len = 19,
+		.ar_buf = { 0x3b, 0xf9, 0x18, 0x00, 0x00, 0x81, 0x31, 0xfe,
+		    0x45, 0x4a, 0x32, 0x44, 0x30, 0x38, 0x31, 0x5f, 0x50, 0x56,
+		    0xb6 },
+		.ar_sup = ATR_P_T1,
+		.ar_def = ATR_P_T1,
+		.ar_neg = B_TRUE,
+		.ar_fi = 1,
+		.ar_di = 8,
+		.ar_conv = ATR_CONVENTION_DIRECT,
+		.ar_guard = 0,
+		.ar_stop = ATR_CLOCK_STOP_NONE,
+		.ar_t1_cksum = ATR_T1_CHECKSUM_LRC,
+		.ar_t1_bwi = 4,
+		.ar_t1_cwi = 5,
+		.ar_t1_ifsc = 254
+	}, {
+		.ar_test = "Actual ATR (3)",
+		.ar_len = 22,
+		.ar_buf = { 0x3b, 0xfc, 0x18, 0x00, 0x00, 0x81, 0x31, 0x80,
+		    0x45, 0x90, 0x67, 0x46, 0x4a, 0x00, 0x64, 0x16, 0x6, 0xf2,
+		    0x72, 0x7e, 0x00, 0xe0 },
+		.ar_sup = ATR_P_T1,
+		.ar_def = ATR_P_T1,
+		.ar_neg = B_TRUE,
+		.ar_fi = 1,
+		.ar_di = 8,
+		.ar_conv = ATR_CONVENTION_DIRECT,
+		.ar_guard = 0,
+		.ar_stop = ATR_CLOCK_STOP_NONE,
+		.ar_t1_cksum = ATR_T1_CHECKSUM_LRC,
+		.ar_t1_bwi = 4,
+		.ar_t1_cwi = 5,
+		.ar_t1_ifsc = 128
+	}, {
+		.ar_test = "Minimal T=1",
+		.ar_len = 4,
+		.ar_buf = { 0x3b, 0x80, 0x01, 0x81 },
+		.ar_sup = ATR_P_T1,
+		.ar_def = ATR_P_T1,
+		.ar_neg = B_TRUE,
+		.ar_fi = 1,
+		.ar_di = 1,
+		.ar_conv = ATR_CONVENTION_DIRECT,
+		.ar_guard = 0,
+		.ar_stop = ATR_CLOCK_STOP_NONE,
+		.ar_t1_cksum = ATR_T1_CHECKSUM_LRC,
+		.ar_t1_bwi = 4,
+		.ar_t1_cwi = 13,
+		.ar_t1_ifsc = 32
+	}, {
+		.ar_test = "T=1 Fi/Di",
+		.ar_len = 5,
+		.ar_buf = { 0x3b, 0x90, 0x34, 0x01, 0xa5 },
+		.ar_sup = ATR_P_T1,
+		.ar_def = ATR_P_T1,
+		.ar_neg = B_TRUE,
+		.ar_fi = 3,
+		.ar_di = 4,
+		.ar_conv = ATR_CONVENTION_DIRECT,
+		.ar_guard = 0,
+		.ar_stop = ATR_CLOCK_STOP_NONE,
+		.ar_t1_cksum = ATR_T1_CHECKSUM_LRC,
+		.ar_t1_bwi = 4,
+		.ar_t1_cwi = 13,
+		.ar_t1_ifsc = 32
+	}, {
+		.ar_test = "T=1 TA2 says neg, T=1 def",
+		.ar_len = 5,
+		.ar_buf = { 0x3b, 0x80, 0x11, 0x11, 0x80 },
+		.ar_sup = ATR_P_T1,
+		.ar_def = ATR_P_T1,
+		.ar_neg = B_TRUE,
+		.ar_fi = 1,
+		.ar_di = 1,
+		.ar_conv = ATR_CONVENTION_DIRECT,
+		.ar_guard = 0,
+		.ar_stop = ATR_CLOCK_STOP_NONE,
+		.ar_t1_cksum = ATR_T1_CHECKSUM_LRC,
+		.ar_t1_bwi = 4,
+		.ar_t1_cwi = 13,
+		.ar_t1_ifsc = 32
+	}, {
+		.ar_test = "T=0, T=1 TA2 says neg, T=0 def",
+		.ar_len = 6,
+		.ar_buf = { 0x3b, 0x80, 0x90, 0x10, 0x01, 0x01 },
+		.ar_sup = ATR_P_T0 | ATR_P_T1,
+		.ar_def = ATR_P_T0,
+		.ar_neg = B_TRUE,
+		.ar_fi = 1,
+		.ar_di = 1,
+		.ar_conv = ATR_CONVENTION_DIRECT,
+		.ar_guard = 0,
+		.ar_stop = ATR_CLOCK_STOP_NONE,
+		.ar_t0_wi = 10,
+		.ar_t1_cksum = ATR_T1_CHECKSUM_LRC,
+		.ar_t1_bwi = 4,
+		.ar_t1_cwi = 13,
+		.ar_t1_ifsc = 32
+	}, {
+		.ar_test = "T=0, T=1 TA2 says neg, T=1 def",
+		.ar_len = 6,
+		.ar_buf = { 0x3b, 0x80, 0x90, 0x11, 0x01, 0x00 },
+		.ar_sup = ATR_P_T0 | ATR_P_T1,
+		.ar_def = ATR_P_T1,
+		.ar_neg = B_TRUE,
+		.ar_fi = 1,
+		.ar_di = 1,
+		.ar_conv = ATR_CONVENTION_DIRECT,
+		.ar_guard = 0,
+		.ar_stop = ATR_CLOCK_STOP_NONE,
+		.ar_t0_wi = 10,
+		.ar_t1_cksum = ATR_T1_CHECKSUM_LRC,
+		.ar_t1_bwi = 4,
+		.ar_t1_cwi = 13,
+		.ar_t1_ifsc = 32
+	}, {
+		.ar_test = "T=0, T=1 TA2 says not neg, T=0 def",
+		.ar_len = 6,
+		.ar_buf = { 0x3b, 0x80, 0x90, 0x90, 0x01, 0x81 },
+		.ar_sup = ATR_P_T0 | ATR_P_T1,
+		.ar_def = ATR_P_T0,
+		.ar_neg = B_FALSE,
+		.ar_fi = 1,
+		.ar_di = 1,
+		.ar_conv = ATR_CONVENTION_DIRECT,
+		.ar_guard = 0,
+		.ar_stop = ATR_CLOCK_STOP_NONE,
+		.ar_t0_wi = 10,
+		.ar_t1_cksum = ATR_T1_CHECKSUM_LRC,
+		.ar_t1_bwi = 4,
+		.ar_t1_cwi = 13,
+		.ar_t1_ifsc = 32
+	}, {
+		.ar_test = "T=0, T=1 TA2 says not neg, T=1 def",
+		.ar_len = 6,
+		.ar_buf = { 0x3b, 0x80, 0x90, 0x81, 0x01, 0x90 },
+		.ar_sup = ATR_P_T0 | ATR_P_T1,
+		.ar_def = ATR_P_T1,
+		.ar_neg = B_FALSE,
+		.ar_fi = 1,
+		.ar_di = 1,
+		.ar_conv = ATR_CONVENTION_DIRECT,
+		.ar_guard = 0,
+		.ar_stop = ATR_CLOCK_STOP_NONE,
+		.ar_t0_wi = 10,
+		.ar_t1_cksum = ATR_T1_CHECKSUM_LRC,
+		.ar_t1_bwi = 4,
+		.ar_t1_cwi = 13,
+		.ar_t1_ifsc = 32
+	}, {
+		.ar_test = "T=1, BWI/CWI",
+		.ar_len = 6,
+		.ar_buf = { 0x3b, 0x80, 0x81, 0x21, 0x59, 0x79 },
+		.ar_sup = ATR_P_T1,
+		.ar_def = ATR_P_T1,
+		.ar_neg = B_TRUE,
+		.ar_fi = 1,
+		.ar_di = 1,
+		.ar_conv = ATR_CONVENTION_DIRECT,
+		.ar_guard = 0,
+		.ar_stop = ATR_CLOCK_STOP_NONE,
+		.ar_t1_cksum = ATR_T1_CHECKSUM_LRC,
+		.ar_t1_bwi = 5,
+		.ar_t1_cwi = 9,
+		.ar_t1_ifsc = 32
+	}, {
+		.ar_test = "T=1, IFSC",
+		.ar_len = 6,
+		.ar_buf = { 0x3b, 0x80, 0x81, 0x11, 0x49, 0x59 },
+		.ar_sup = ATR_P_T1,
+		.ar_def = ATR_P_T1,
+		.ar_neg = B_TRUE,
+		.ar_fi = 1,
+		.ar_di = 1,
+		.ar_conv = ATR_CONVENTION_DIRECT,
+		.ar_guard = 0,
+		.ar_stop = ATR_CLOCK_STOP_NONE,
+		.ar_t1_cksum = ATR_T1_CHECKSUM_LRC,
+		.ar_t1_bwi = 4,
+		.ar_t1_cwi = 13,
+		.ar_t1_ifsc = 73
+	}, {
+		.ar_test = "T=1, Checksum (LRC)",
+		.ar_len = 6,
+		.ar_buf = { 0x3b, 0x80, 0x81, 0x41, 0x00, 0x40 },
+		.ar_sup = ATR_P_T1,
+		.ar_def = ATR_P_T1,
+		.ar_neg = B_TRUE,
+		.ar_fi = 1,
+		.ar_di = 1,
+		.ar_conv = ATR_CONVENTION_DIRECT,
+		.ar_guard = 0,
+		.ar_stop = ATR_CLOCK_STOP_NONE,
+		.ar_t1_cksum = ATR_T1_CHECKSUM_LRC,
+		.ar_t1_bwi = 4,
+		.ar_t1_cwi = 13,
+		.ar_t1_ifsc = 32
+	}, {
+		.ar_test = "T=1, Checksum (CRC)",
+		.ar_len = 6,
+		.ar_buf = { 0x3b, 0x80, 0x81, 0x41, 0x01, 0x41 },
+		.ar_sup = ATR_P_T1,
+		.ar_def = ATR_P_T1,
+		.ar_neg = B_TRUE,
+		.ar_fi = 1,
+		.ar_di = 1,
+		.ar_conv = ATR_CONVENTION_DIRECT,
+		.ar_guard = 0,
+		.ar_stop = ATR_CLOCK_STOP_NONE,
+		.ar_t1_cksum = ATR_T1_CHECKSUM_CRC,
+		.ar_t1_bwi = 4,
+		.ar_t1_cwi = 13,
+		.ar_t1_ifsc = 32
+	}
+};
+
+static void
+atr_parse_failed(atr_test_t *test, const char *fmt, ...)
+{
+	va_list ap;
+
+	va_start(ap, fmt);
+	(void) fprintf(stderr, "Test \"%s\" failed: ", test->ar_test);
+	(void) vfprintf(stderr, fmt, ap);
+	(void) fprintf(stderr, "\n");
+	va_end(ap);
+}
+
+static uint_t
+atr_parse_one(atr_data_t *data, atr_test_t *test)
+{
+	uint_t err = 0;
+	atr_parsecode_t ret;
+	atr_protocol_t sup, def;
+	boolean_t neg;
+	uint8_t fi, di, guard;
+	atr_convention_t conv;
+	atr_clock_stop_t stop;
+
+	ret = atr_parse(test->ar_buf, test->ar_len, data); 
+	if (ret != test->ar_retval) {
+		atr_parse_failed(test, "found unexpected return "
+		    "value: %u (%s), expected: %u", ret, atr_strerror(ret),
+		    test->ar_retval);
+		return (1);
+	}
+
+	/* Don't test anything else if it's not OK */
+	if (ret != ATR_CODE_OK)
+		return (0);
+
+	sup = atr_supported_protocols(data);
+	def = atr_default_protocol(data);
+	neg = atr_params_negotiable(data);
+	fi = atr_fi_index(data);
+	di = atr_di_index(data);
+	conv = atr_convention(data);
+	guard = atr_extra_guardtime(data);
+	stop = atr_clock_stop(data);
+
+	if (sup != test->ar_sup) {
+		atr_parse_failed(test, "Found mismatched supported "
+		    "protocols: %u, expected: %u", sup, test->ar_sup);
+		err++;
+	}
+
+	if (def != test->ar_def) {
+		atr_parse_failed(test, "Found mismatched default "
+		    "protocols: %u, expected: %u", def, test->ar_def);
+		err++;
+	}
+
+	if (neg != test->ar_neg) {
+		atr_parse_failed(test, "Found mismatched negotiable bit: "
+		   "%u, expected %u", neg, test->ar_neg);
+	       err++;	
+	}
+
+	if (fi != test->ar_fi) {
+		atr_parse_failed(test, "Found mismatched fi index: "
+		    "%u, expected: %u", fi, test->ar_fi);
+		err++;
+	}
+
+	if (di != test->ar_di) {
+		atr_parse_failed(test, "Found mismatched di index: "
+		    "%u, expected: %u", di, test->ar_di);
+		err++;
+	}
+
+	if (conv != test->ar_conv) {
+		atr_parse_failed(test, "Found mismatched TS convention: "
+		    "%u, expected: %u", conv, test->ar_conv);
+		err++;
+	}
+
+	if (guard != test->ar_guard) {
+		atr_parse_failed(test, "Found mismatched extra guardtime: "
+		    "%u, expected: %u", guard, test->ar_guard);
+		err++;
+	}
+
+	if (stop != test->ar_stop) {
+		atr_parse_failed(test, "Found mismatched clock stop: "
+		    "%u, expected: %u", stop, test->ar_stop);
+		err++;
+	}
+
+	if ((sup & ATR_P_T0) != 0) {
+		uint8_t wi;
+
+		wi = atr_t0_wi(data);
+		if (wi != test->ar_t0_wi) {
+			atr_parse_failed(test, "Found mismatched T0 wi: "
+			    "%u, expected: %u", wi, test->ar_t0_wi);
+			err++;
+		}
+	}
+
+	if ((sup & ATR_P_T1) != 0) {
+		atr_t1_checksum_t cksum;
+		uint8_t bwi, cwi, ifsc;
+
+		cksum = atr_t1_checksum(data);
+		bwi = atr_t1_bwi(data);
+		cwi = atr_t1_cwi(data);
+		ifsc = atr_t1_ifsc(data);
+
+		if (cksum != test->ar_t1_cksum) {
+			atr_parse_failed(test, "Found mistmatched T1 checksum: "
+			    "%u, expected: %u", cksum, test->ar_t1_cksum);
+			err++;
+		}
+
+		if (bwi != test->ar_t1_bwi) {
+			atr_parse_failed(test, "Found mistmatched T1 bwi: "
+			    "%u, expected: %u", bwi, test->ar_t1_bwi);
+			err++;
+		}
+
+		if (cwi != test->ar_t1_cwi) {
+			atr_parse_failed(test, "Found mistmatched T1 cwi: "
+			    "%u, expected: %u", cwi, test->ar_t1_cwi);
+			err++;
+		}
+
+		if (ifsc != test->ar_t1_ifsc) {
+			atr_parse_failed(test, "Found mistmatched T1 ifsc: "
+			    "%u, expected: %u", ifsc, test->ar_t1_ifsc);
+			err++;
+		}
+	}
+
+	if (err > 0) {
+		atr_data_dump(data, stderr);
+		return (1);
+	}
+
+	return (0);
+}
+
+int
+main(void)
+{
+	uint_t i;
+	uint_t errs = 0;
+	atr_data_t *data;
+
+	data = atr_data_alloc();
+	if (data == NULL) {
+		errx(EXIT_FAILURE, "failed to allocate atr_data_t");
+	}
+
+	for (i = 0; i < sizeof (atr_tests) / sizeof (atr_test_t); i++) {
+		atr_data_reset(data);
+		errs += atr_parse_one(data, &atr_tests[i]);
+	}
+
+	atr_data_free(data);
+
+	if (errs != 0) {
+		warnx("%d test(s) failed", errs);
+	}
+	return (errs != 0 ? EXIT_FAILURE : EXIT_SUCCESS);
+}
diff --git a/usr/src/test/os-tests/tests/uccid/excl-badread.c b/usr/src/test/os-tests/tests/uccid/excl-badread.c
new file mode 100644
index 0000000000..c75d6e8bbd
--- /dev/null
+++ b/usr/src/test/os-tests/tests/uccid/excl-badread.c
@@ -0,0 +1,80 @@
+/*
+ * This file and its contents are supplied under the terms of the
+ * Common Development and Distribution License ("CDDL"), version 1.0.
+ * You may only use this file in accordance with the terms of version
+ * 1.0 of the CDDL.
+ *
+ * A full copy of the text of the CDDL should have accompanied this
+ * source.  A copy of the CDDL is also available via the Internet at
+ * http://www.illumos.org/license/CDDL.
+ */
+
+/*
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+
+/*
+ * Verify various bad read conditions fail successfully.
+ */
+
+#include <err.h>
+#include <stdlib.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <strings.h>
+#include <unistd.h>
+#include <errno.h>
+
+#include <sys/usb/clients/ccid/uccid.h>
+
+int
+main(int argc, char *argv[])
+{
+	int fd;
+	uccid_cmd_txn_begin_t begin;
+	ssize_t ret;
+	char buf[500];
+
+	if (argc != 2) {
+		errx(EXIT_FAILURE, "missing required ccid path");
+	}
+
+	if ((fd = open(argv[1], O_RDWR)) < 0) {
+		err(EXIT_FAILURE, "failed to open %s", argv[1]);
+	}
+
+	bzero(&begin, sizeof (begin));
+	begin.uct_version = UCCID_CURRENT_VERSION;
+
+	/*
+	 * Read without having a transaction
+	 */
+	ret = read(fd, buf, sizeof (buf));
+	if (ret != -1) {
+		errx(EXIT_FAILURE, "read succeeded when it should have failed "
+		    "(EACCES case), returned %ld", ret);
+	}
+
+	if (errno != EACCES) {
+		errx(EXIT_FAILURE, "found wrong value for errno. Expected "
+		    "%d, received %d", EACCES, errno);
+	}
+
+	if (ioctl(fd, UCCID_CMD_TXN_BEGIN, &begin) != 0) {
+		err(EXIT_FAILURE, "failed to issue begin ioctl");
+	}
+
+	ret = read(fd, buf, sizeof (buf));
+	if (ret != -1) {
+		errx(EXIT_FAILURE, "read succeeded when it should have failed "
+		    "(ENODATA case), returned %ld", ret);
+	}
+
+	if (errno != ENODATA) {
+		errx(EXIT_FAILURE, "found wrong value for errno. Expected "
+		    "%d, received %d", ENODATA, errno);
+	}
+
+	return (0);
+}
diff --git a/usr/src/test/os-tests/tests/uccid/excl-basic.c b/usr/src/test/os-tests/tests/uccid/excl-basic.c
new file mode 100644
index 0000000000..38c52d8321
--- /dev/null
+++ b/usr/src/test/os-tests/tests/uccid/excl-basic.c
@@ -0,0 +1,65 @@
+/*
+ * This file and its contents are supplied under the terms of the
+ * Common Development and Distribution License ("CDDL"), version 1.0.
+ * You may only use this file in accordance with the terms of version
+ * 1.0 of the CDDL.
+ *
+ * A full copy of the text of the CDDL should have accompanied this
+ * source.  A copy of the CDDL is also available via the Internet at
+ * http://www.illumos.org/license/CDDL.
+ */
+
+/*
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+
+/*
+ * Verify that we can grab a basic exclusive lock through an ioctl on the slot.
+ * Then that we can release it afterwards.
+ */
+
+#include <err.h>
+#include <stdlib.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <strings.h>
+#include <unistd.h>
+
+#include <sys/usb/clients/ccid/uccid.h>
+
+int
+main(int argc, char *argv[])
+{
+	int fd;
+	uint_t i;
+	uccid_cmd_txn_begin_t begin;
+	uccid_cmd_txn_end_t end;
+
+	if (argc != 2) {
+		errx(EXIT_FAILURE, "missing required ccid path");
+	}
+
+	if ((fd = open(argv[1], O_RDWR)) < 0) {
+		err(EXIT_FAILURE, "failed to open %s", argv[1]);
+	}
+
+	bzero(&begin, sizeof (begin));
+	bzero(&end, sizeof (end));
+
+	begin.uct_version = UCCID_CURRENT_VERSION;
+	end.uct_version = UCCID_CURRENT_VERSION;
+	end.uct_flags = UCCID_TXN_END_RELEASE;
+
+	for (i = 0; i < 10; i++) {
+		if (ioctl(fd, UCCID_CMD_TXN_BEGIN, &begin) != 0) {
+			err(EXIT_FAILURE, "failed to issue begin ioctl");
+		}
+
+		if (ioctl(fd, UCCID_CMD_TXN_END, &end) != 0) {
+			err(EXIT_FAILURE, "failed to issue end ioctl");
+		}
+	}
+
+	return (0);
+}
diff --git a/usr/src/test/os-tests/tests/uccid/excl-close.c b/usr/src/test/os-tests/tests/uccid/excl-close.c
new file mode 100644
index 0000000000..1fd1e327aa
--- /dev/null
+++ b/usr/src/test/os-tests/tests/uccid/excl-close.c
@@ -0,0 +1,81 @@
+/*
+ * This file and its contents are supplied under the terms of the
+ * Common Development and Distribution License ("CDDL"), version 1.0.
+ * You may only use this file in accordance with the terms of version
+ * 1.0 of the CDDL.
+ *
+ * A full copy of the text of the CDDL should have accompanied this
+ * source.  A copy of the CDDL is also available via the Internet at
+ * http://www.illumos.org/license/CDDL.
+ */
+
+/*
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+
+/*
+ * Verify that if a child grabs an exclusive lock and calls exit, we can grab it
+ * again.
+ */
+
+#include <err.h>
+#include <stdlib.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <strings.h>
+#include <unistd.h>
+#include <errno.h>
+#include <sys/wait.h>
+
+#include <sys/usb/clients/ccid/uccid.h>
+
+int
+main(int argc, char *argv[])
+{
+	int fd, estat;
+	pid_t pid;
+	uccid_cmd_txn_begin_t begin;
+
+	if (argc != 2) {
+		errx(EXIT_FAILURE, "missing required ccid path");
+	}
+
+	bzero(&begin, sizeof (begin));
+	begin.uct_version = UCCID_CURRENT_VERSION;
+
+	pid = fork();
+	if (pid == 0) {
+		fd = open(argv[1], O_RDWR);
+		if (fd < 0) {
+			err(EXIT_FAILURE, "failed to open %s", argv[1]);
+		}
+
+		if (ioctl(fd, UCCID_CMD_TXN_BEGIN, &begin) != 0) {
+			err(EXIT_FAILURE, "failed to issue begin ioctl");
+		}
+
+		_exit(0);
+	}
+
+	estat = -1;
+	if (waitpid(pid, &estat, 0) == -1) {
+		err(EXIT_FAILURE, "failed to wait for pid %d", pid);
+	}
+
+	if (estat != 0) {
+		errx(EXIT_FAILURE, "child exited with non-zero value (%d)",
+		    estat);
+	}
+
+	fd = open(argv[1], O_RDWR);
+	if (fd < 0) {
+		err(EXIT_FAILURE, "failed to open %s", argv[1]);
+	}
+
+	if (ioctl(fd, UCCID_CMD_TXN_BEGIN, &begin) != 0) {
+		err(EXIT_FAILURE, "failed to issue begin ioctl");
+	}
+
+	return (0);
+}
diff --git a/usr/src/test/os-tests/tests/uccid/excl-loop.c b/usr/src/test/os-tests/tests/uccid/excl-loop.c
new file mode 100644
index 0000000000..81bf9366f8
--- /dev/null
+++ b/usr/src/test/os-tests/tests/uccid/excl-loop.c
@@ -0,0 +1,84 @@
+/*
+ * This file and its contents are supplied under the terms of the
+ * Common Development and Distribution License ("CDDL"), version 1.0.
+ * You may only use this file in accordance with the terms of version
+ * 1.0 of the CDDL.
+ *
+ * A full copy of the text of the CDDL should have accompanied this
+ * source.  A copy of the CDDL is also available via the Internet at
+ * http://www.illumos.org/license/CDDL.
+ */
+
+/*
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+
+/*
+ * Verify that we can grab a basic exclusive lock and then if we try to get
+ * another lock it fails. Regardless of whether we do so through open(2) or
+ * ioctl(2).
+ */
+
+#include <err.h>
+#include <stdlib.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <strings.h>
+#include <unistd.h>
+#include <errno.h>
+#include <sys/debug.h>
+
+#include <sys/usb/clients/ccid/uccid.h>
+
+int
+main(int argc, char *argv[])
+{
+	int fd, ret;
+	uccid_cmd_txn_begin_t begin;
+	uccid_cmd_txn_end_t end;
+
+	if (argc != 2) {
+		errx(EXIT_FAILURE, "missing required ccid path");
+	}
+
+	if ((fd = open(argv[1], O_RDWR)) < 0) {
+		err(EXIT_FAILURE, "failed to open %s", argv[1]);
+	}
+
+	bzero(&begin, sizeof (begin));
+	bzero(&end, sizeof (end));
+
+	begin.uct_version = UCCID_CURRENT_VERSION;
+	end.uct_version = UCCID_CURRENT_VERSION;
+	end.uct_flags = UCCID_TXN_END_RELEASE;
+
+	if (ioctl(fd, UCCID_CMD_TXN_BEGIN, &begin) != 0) {
+		err(EXIT_FAILURE, "failed to issue begin ioctl");
+	}
+
+	ret = ioctl(fd, UCCID_CMD_TXN_BEGIN, &begin);
+	VERIFY3S(ret, ==, -1);
+	VERIFY3S(errno, ==, EEXIST);
+
+	if (ioctl(fd, UCCID_CMD_TXN_END, &end) != 0) {
+		err(EXIT_FAILURE, "failed to issue end ioctl");
+	}
+
+	VERIFY0(close(fd));
+
+	if ((fd = open(argv[1], O_RDWR)) < 0) {
+		err(EXIT_FAILURE, "failed to open %s", argv[1]);
+	}
+
+	ret = ioctl(fd, UCCID_CMD_TXN_BEGIN, &begin);
+	VERIFY0(ret);
+
+	ret = ioctl(fd, UCCID_CMD_TXN_BEGIN, &begin);
+	VERIFY3S(ret, ==, -1);
+	VERIFY3S(errno, ==, EEXIST);
+
+	VERIFY0(close(fd));
+
+	return (0);
+}
diff --git a/usr/src/test/os-tests/tests/uccid/excl-nonblock.c b/usr/src/test/os-tests/tests/uccid/excl-nonblock.c
new file mode 100644
index 0000000000..9d4a2bc8d5
--- /dev/null
+++ b/usr/src/test/os-tests/tests/uccid/excl-nonblock.c
@@ -0,0 +1,99 @@
+/*
+ * This file and its contents are supplied under the terms of the
+ * Common Development and Distribution License ("CDDL"), version 1.0.
+ * You may only use this file in accordance with the terms of version
+ * 1.0 of the CDDL.
+ *
+ * A full copy of the text of the CDDL should have accompanied this
+ * source.  A copy of the CDDL is also available via the Internet at
+ * http://www.illumos.org/license/CDDL.
+ */
+
+/*
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+
+/*
+ * Verify that if we've grabbed an exclusive lock, another thread fails to grab
+ * it as a non-blocking lock.
+ */
+
+#include <err.h>
+#include <stdlib.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <strings.h>
+#include <unistd.h>
+#include <sys/debug.h>
+#include <thread.h>
+#include <errno.h>
+
+#include <sys/usb/clients/ccid/uccid.h>
+
+void *
+nonblock_thread(void *arg)
+{
+	uccid_cmd_txn_begin_t begin;
+	int ret;
+	int fd = (uintptr_t)arg;
+
+
+	bzero(&begin, sizeof (begin));
+
+	begin.uct_version = UCCID_CURRENT_VERSION;
+	begin.uct_flags = UCCID_TXN_DONT_BLOCK;
+
+	ret = ioctl(fd, UCCID_CMD_TXN_BEGIN, &begin);
+	VERIFY3S(ret, ==, -1);
+	VERIFY3S(errno, ==, EBUSY);
+
+	return (NULL);
+}
+
+int
+main(int argc, char *argv[])
+{
+	int fda, fdb;
+	uccid_cmd_txn_begin_t begin;
+	uccid_cmd_txn_end_t end;
+	thread_t thr;
+
+	if (argc != 2) {
+		errx(EXIT_FAILURE, "missing required ccid path");
+	}
+
+	if ((fda = open(argv[1], O_RDWR)) < 0) {
+		err(EXIT_FAILURE, "failed to open %s", argv[1]);
+	}
+
+	if ((fdb = open(argv[1], O_RDWR)) < 0) {
+		err(EXIT_FAILURE, "failed to open %s", argv[1]);
+	}
+
+	bzero(&begin, sizeof (begin));
+	bzero(&end, sizeof (end));
+
+	begin.uct_version = UCCID_CURRENT_VERSION;
+	end.uct_version = UCCID_CURRENT_VERSION;
+	end.uct_flags = UCCID_TXN_END_RELEASE;
+
+	if (ioctl(fda, UCCID_CMD_TXN_BEGIN, &begin) != 0) {
+		err(EXIT_FAILURE, "failed to issue begin ioctl");
+	}
+
+	if (thr_create(NULL, 0, nonblock_thread, (void *)(uintptr_t)fdb, 0,
+	    &thr) != 0) {
+		err(EXIT_FAILURE, "failed to create thread");
+	}
+
+	if (thr_join(thr, NULL, NULL) != 0) {
+		err(EXIT_FAILURE, "failed to join therad");
+	}
+
+	if (ioctl(fda, UCCID_CMD_TXN_END, &end) != 0) {
+		err(EXIT_FAILURE, "failed to issue end ioctl");
+	}
+
+	return (0);
+}
diff --git a/usr/src/test/os-tests/tests/uccid/excl-reset.c b/usr/src/test/os-tests/tests/uccid/excl-reset.c
new file mode 100644
index 0000000000..58d4956670
--- /dev/null
+++ b/usr/src/test/os-tests/tests/uccid/excl-reset.c
@@ -0,0 +1,65 @@
+/*
+ * This file and its contents are supplied under the terms of the
+ * Common Development and Distribution License ("CDDL"), version 1.0.
+ * You may only use this file in accordance with the terms of version
+ * 1.0 of the CDDL.
+ *
+ * A full copy of the text of the CDDL should have accompanied this
+ * source.  A copy of the CDDL is also available via the Internet at
+ * http://www.illumos.org/license/CDDL.
+ */
+
+/*
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+
+/*
+ * Verify that we can grab a basic exclusive lock through an ioctl on the slot.
+ * Then that we can release it afterwards.
+ */
+
+#include <err.h>
+#include <stdlib.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <strings.h>
+#include <unistd.h>
+
+#include <sys/usb/clients/ccid/uccid.h>
+
+int
+main(int argc, char *argv[])
+{
+	int fd;
+	uint_t i;
+	uccid_cmd_txn_begin_t begin;
+	uccid_cmd_txn_end_t end;
+
+	if (argc != 2) {
+		errx(EXIT_FAILURE, "missing required ccid path");
+	}
+
+	if ((fd = open(argv[1], O_RDWR)) < 0) {
+		err(EXIT_FAILURE, "failed to open %s", argv[1]);
+	}
+
+	bzero(&begin, sizeof (begin));
+	bzero(&end, sizeof (end));
+
+	begin.uct_version = UCCID_CURRENT_VERSION;
+	end.uct_version = UCCID_CURRENT_VERSION;
+	end.uct_flags = UCCID_TXN_END_RESET;
+
+	for (i = 0; i < 10; i++) {
+		if (ioctl(fd, UCCID_CMD_TXN_BEGIN, &begin) != 0) {
+			err(EXIT_FAILURE, "failed to issue begin ioctl");
+		}
+
+		if (ioctl(fd, UCCID_CMD_TXN_END, &end) != 0) {
+			err(EXIT_FAILURE, "failed to issue end ioctl");
+		}
+	}
+
+	return (0);
+}
diff --git a/usr/src/test/os-tests/tests/uccid/notxn-poll.c b/usr/src/test/os-tests/tests/uccid/notxn-poll.c
new file mode 100644
index 0000000000..e1fa7b1057
--- /dev/null
+++ b/usr/src/test/os-tests/tests/uccid/notxn-poll.c
@@ -0,0 +1,57 @@
+/*
+ * This file and its contents are supplied under the terms of the
+ * Common Development and Distribution License ("CDDL"), version 1.0.
+ * You may only use this file in accordance with the terms of version
+ * 1.0 of the CDDL.
+ *
+ * A full copy of the text of the CDDL should have accompanied this
+ * source.  A copy of the CDDL is also available via the Internet at
+ * http://www.illumos.org/license/CDDL.
+ */
+
+/*
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+
+/*
+ * Verify that trying to poll without a transcation / excl access results in an
+ * error.
+ */
+
+#include <err.h>
+#include <stdlib.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/debug.h>
+#include <fcntl.h>
+#include <strings.h>
+#include <unistd.h>
+#include <errno.h>
+#include <poll.h>
+
+#include <sys/usb/clients/ccid/uccid.h>
+
+int
+main(int argc, char *argv[])
+{
+	int fd, ret;
+	struct pollfd pfds[1];
+
+	if (argc != 2) {
+		errx(EXIT_FAILURE, "missing required ccid path");
+	}
+
+	if ((fd = open(argv[1], O_RDWR)) < 0) {
+		err(EXIT_FAILURE, "failed to open %s", argv[1]);
+	}
+
+	pfds[0].fd = fd;
+	pfds[0].events = POLLIN;
+	pfds[0].revents = 0;
+
+	ret = poll(pfds, 1, 0);
+	VERIFY3S(ret, ==, -1);
+	VERIFY3S(errno, ==, EACCES);
+
+	return (0);
+}
diff --git a/usr/src/test/os-tests/tests/uccid/pollin.c b/usr/src/test/os-tests/tests/uccid/pollin.c
new file mode 100644
index 0000000000..b5ccd0c453
--- /dev/null
+++ b/usr/src/test/os-tests/tests/uccid/pollin.c
@@ -0,0 +1,64 @@
+/*
+ * This file and its contents are supplied under the terms of the
+ * Common Development and Distribution License ("CDDL"), version 1.0.
+ * You may only use this file in accordance with the terms of version
+ * 1.0 of the CDDL.
+ *
+ * A full copy of the text of the CDDL should have accompanied this
+ * source.  A copy of the CDDL is also available via the Internet at
+ * http://www.illumos.org/license/CDDL.
+ */
+
+/*
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+
+/*
+ * Open up a device and make sure we get pollout by default.
+ */
+
+#include <err.h>
+#include <stdlib.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <strings.h>
+#include <unistd.h>
+#include <errno.h>
+#include <poll.h>
+
+#include <sys/usb/clients/ccid/uccid.h>
+
+int
+main(int argc, char *argv[])
+{
+	int fd, ret;
+	struct pollfd pfds[1];
+	uccid_cmd_txn_begin_t begin;
+
+	if (argc != 2) {
+		errx(EXIT_FAILURE, "missing required ccid path");
+	}
+
+	if ((fd = open(argv[1], O_RDWR)) < 0) {
+		err(EXIT_FAILURE, "failed to open %s", argv[1]);
+	}
+
+	bzero(&begin, sizeof (begin));
+	begin.uct_version = UCCID_CURRENT_VERSION;
+	if (ioctl(fd, UCCID_CMD_TXN_BEGIN, &begin) != 0) {
+		err(EXIT_FAILURE, "failed to issue begin ioctl");
+	}
+
+	pfds[0].fd = fd;
+	pfds[0].events = POLLIN;
+	pfds[0].revents = 0;
+
+	ret = poll(pfds, 1, 0);
+	if (ret != 0) {
+		err(EXIT_FAILURE, "poll didn't return 0, returned %d "
+		    "(errno %d)", ret, errno);
+	}
+
+	return (0);
+}
diff --git a/usr/src/test/os-tests/tests/uccid/pollout.c b/usr/src/test/os-tests/tests/uccid/pollout.c
new file mode 100644
index 0000000000..38592bc41b
--- /dev/null
+++ b/usr/src/test/os-tests/tests/uccid/pollout.c
@@ -0,0 +1,68 @@
+/*
+ * This file and its contents are supplied under the terms of the
+ * Common Development and Distribution License ("CDDL"), version 1.0.
+ * You may only use this file in accordance with the terms of version
+ * 1.0 of the CDDL.
+ *
+ * A full copy of the text of the CDDL should have accompanied this
+ * source.  A copy of the CDDL is also available via the Internet at
+ * http://www.illumos.org/license/CDDL.
+ */
+
+/*
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+
+/*
+ * Open up a device and make sure we don't get pollin by default.
+ */
+
+#include <err.h>
+#include <stdlib.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <strings.h>
+#include <unistd.h>
+#include <errno.h>
+#include <poll.h>
+
+#include <sys/usb/clients/ccid/uccid.h>
+
+int
+main(int argc, char *argv[])
+{
+	int fd, ret;
+	struct pollfd pfds[1];
+	uccid_cmd_txn_begin_t begin;
+
+	if (argc != 2) {
+		errx(EXIT_FAILURE, "missing required ccid path");
+	}
+
+	if ((fd = open(argv[1], O_RDWR)) < 0) {
+		err(EXIT_FAILURE, "failed to open %s", argv[1]);
+	}
+
+	bzero(&begin, sizeof (begin));
+	begin.uct_version = UCCID_CURRENT_VERSION;
+	if (ioctl(fd, UCCID_CMD_TXN_BEGIN, &begin) != 0) {
+		err(EXIT_FAILURE, "failed to issue begin ioctl");
+	}
+
+	pfds[0].fd = fd;
+	pfds[0].events = POLLOUT;
+	pfds[0].revents = 0;
+
+	ret = poll(pfds, 1, 0);
+	if (ret != 1) {
+		err(EXIT_FAILURE, "poll didn't return 1, returned %d "
+		    "(errno %d)", ret, errno);
+	}
+
+	if (!(pfds[0].revents & POLLOUT)) {
+		err(EXIT_FAILURE, "missing pollout, got %d", pfds[0].revents);
+	}
+
+	return (0);
+}
diff --git a/usr/src/test/os-tests/tests/uccid/status.c b/usr/src/test/os-tests/tests/uccid/status.c
new file mode 100644
index 0000000000..8f9c4173b2
--- /dev/null
+++ b/usr/src/test/os-tests/tests/uccid/status.c
@@ -0,0 +1,97 @@
+/*
+ * This file and its contents are supplied under the terms of the
+ * Common Development and Distribution License ("CDDL"), version 1.0.
+ * You may only use this file in accordance with the terms of version
+ * 1.0 of the CDDL.
+ *
+ * A full copy of the text of the CDDL should have accompanied this
+ * source.  A copy of the CDDL is also available via the Internet at
+ * http://www.illumos.org/license/CDDL.
+ */
+
+/*
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+
+/*
+ * Verify that we can issue various status ioctls regardless of whether or not
+ * we have exclusive access on our handle. Also, check some of the failure
+ * modes.
+ */
+
+#include <err.h>
+#include <stdlib.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <strings.h>
+#include <unistd.h>
+#include <sys/debug.h>
+#include <errno.h>
+#include <sys/mman.h>
+#include <sys/param.h>
+
+#include <sys/usb/clients/ccid/uccid.h>
+
+int
+main(int argc, char *argv[])
+{
+	int fd, efd, ret;
+	uccid_cmd_status_t ucs;
+	uccid_cmd_txn_begin_t begin;
+	void *badaddr;
+
+	if (argc != 2) {
+		errx(EXIT_FAILURE, "missing required ccid path");
+	}
+
+	if ((fd = open(argv[1], O_RDWR)) < 0) {
+		err(EXIT_FAILURE, "failed to open %s", argv[1]);
+	}
+
+	if ((efd = open(argv[1], O_RDWR)) < 0) {
+		err(EXIT_FAILURE, "failed to open %s", argv[1]);
+	}
+
+	bzero(&begin, sizeof (begin));
+	begin.uct_version = UCCID_CURRENT_VERSION;
+	if (ioctl(efd, UCCID_CMD_TXN_BEGIN, &begin) != 0) {
+		err(EXIT_FAILURE, "failed to issue begin ioctl");
+	}
+
+	bzero(&ucs, sizeof (ucs));
+	ucs.ucs_version = UCCID_CURRENT_VERSION;
+
+	ret = ioctl(fd, UCCID_CMD_STATUS, &ucs);
+	VERIFY3S(ret, ==, 0);
+
+	ret = ioctl(efd, UCCID_CMD_STATUS, &ucs);
+	VERIFY3S(ret, ==, 0);
+
+	ucs.ucs_version = UCCID_VERSION_ONE - 1;
+	ret = ioctl(efd, UCCID_CMD_STATUS, &ucs);
+	VERIFY3S(ret, ==, -1);
+	VERIFY3S(errno, ==, EINVAL);
+
+	ucs.ucs_version = UCCID_VERSION_ONE + 1;
+	ret = ioctl(efd, UCCID_CMD_STATUS, &ucs);
+	VERIFY3S(ret, ==, -1);
+	VERIFY3S(errno, ==, EINVAL);
+
+	ucs.ucs_version = UCCID_VERSION_ONE - 1;
+	ret = ioctl(fd, UCCID_CMD_STATUS, &ucs);
+	VERIFY3S(ret, ==, -1);
+	VERIFY3S(errno, ==, EINVAL);
+
+	ucs.ucs_version = UCCID_VERSION_ONE + 1;
+	ret = ioctl(fd, UCCID_CMD_STATUS, &ucs);
+	VERIFY3S(ret, ==, -1);
+	VERIFY3S(errno, ==, EINVAL);
+
+	badaddr = mmap(NULL, PAGESIZE, PROT_READ, MAP_PRIVATE | MAP_ANON, -1,
+	    0);
+	VERIFY3P(badaddr, !=, MAP_FAILED);
+	VERIFY0(munmap(badaddr, PAGESIZE));
+
+	return (0);
+}
diff --git a/usr/src/test/os-tests/tests/uccid/txn-pollerr.c b/usr/src/test/os-tests/tests/uccid/txn-pollerr.c
new file mode 100644
index 0000000000..c70e5e986e
--- /dev/null
+++ b/usr/src/test/os-tests/tests/uccid/txn-pollerr.c
@@ -0,0 +1,88 @@
+/*
+ * This file and its contents are supplied under the terms of the
+ * Common Development and Distribution License ("CDDL"), version 1.0.
+ * You may only use this file in accordance with the terms of version
+ * 1.0 of the CDDL.
+ *
+ * A full copy of the text of the CDDL should have accompanied this
+ * source.  A copy of the CDDL is also available via the Internet at
+ * http://www.illumos.org/license/CDDL.
+ */
+
+/*
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+
+/*
+ * Verify that closing a transaction while polling generates POLLERR.
+ */
+
+#include <err.h>
+#include <stdlib.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <strings.h>
+#include <unistd.h>
+#include <errno.h>
+#include <sys/debug.h>
+#include <poll.h>
+#include <port.h>
+
+#include <sys/usb/clients/ccid/uccid.h>
+
+int
+main(int argc, char *argv[])
+{
+	int fd, port;
+	uccid_cmd_txn_end_t end;
+	uccid_cmd_txn_begin_t begin;
+	port_event_t pe;
+	timespec_t to;
+
+	if (argc != 2) {
+		errx(EXIT_FAILURE, "missing required ccid path");
+	}
+
+	if ((port = port_create()) == -1) {
+		err(EXIT_FAILURE, "failed to create event port: %d",
+		    port);
+	}
+
+	if ((fd = open(argv[1], O_RDWR | O_EXCL)) < 0) {
+		err(EXIT_FAILURE, "failed to open %s", argv[1]);
+	}
+
+	bzero(&begin, sizeof (begin));
+	begin.uct_version = UCCID_CURRENT_VERSION;
+	if (ioctl(fd, UCCID_CMD_TXN_BEGIN, &begin) != 0) {
+		err(EXIT_FAILURE, "failed to issue begin ioctl");
+	}
+
+	/*
+	 * Do not poll for pollout here, since by default, after grabbing a
+	 * transaction, the device is writeable.
+	 */
+	if (port_associate(port, PORT_SOURCE_FD, fd, POLLIN, NULL) != 0) {
+		err(EXIT_FAILURE, "failed to associate");
+	}
+
+	bzero(&end, sizeof (end));
+	end.uct_version = UCCID_CURRENT_VERSION;
+	end.uct_flags = UCCID_TXN_END_RELEASE;
+
+	if (ioctl(fd, UCCID_CMD_TXN_END, &end) != 0) {
+		err(EXIT_FAILURE, "failed to issue end ioctl");
+	}
+
+	bzero(&to, sizeof (timespec_t));
+	if (port_get(port, &pe, &to) != 0) {
+		err(EXIT_FAILURE, "failed to port_get()");
+	}
+
+	VERIFY3S(pe.portev_source, ==, PORT_SOURCE_FD);
+	VERIFY3S(pe.portev_object, ==, fd);
+	VERIFY3S(pe.portev_events & POLLERR, !=, 0);
+
+	return (0);
+}
diff --git a/usr/src/test/os-tests/tests/uccid/yk.c b/usr/src/test/os-tests/tests/uccid/yk.c
new file mode 100644
index 0000000000..6fc449c742
--- /dev/null
+++ b/usr/src/test/os-tests/tests/uccid/yk.c
@@ -0,0 +1,78 @@
+/*
+ * This file and its contents are supplied under the terms of the
+ * Common Development and Distribution License ("CDDL"), version 1.0.
+ * You may only use this file in accordance with the terms of version
+ * 1.0 of the CDDL.
+ *
+ * A full copy of the text of the CDDL should have accompanied this
+ * source.  A copy of the CDDL is also available via the Internet at
+ * http://www.illumos.org/license/CDDL.
+ */
+
+/*
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+
+/*
+ * Attempt to open a YubiKey class device and get the basic information applet
+ * through an APDU.
+ */
+
+#include <err.h>
+#include <stdlib.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <strings.h>
+#include <unistd.h>
+#include <errno.h>
+
+#include <sys/usb/clients/ccid/uccid.h>
+
+static const uint8_t yk_req[] = {
+	0x00, 0xa4, 0x04, 0x00, 0x07, 0xa0, 0x00, 0x00, 0x05, 0x27, 0x20, 0x01
+};
+
+int
+main(int argc, char *argv[])
+{
+	int fd;
+	ssize_t ret, i;
+	uccid_cmd_txn_begin_t begin;
+	uint8_t buf[UCCID_APDU_SIZE_MAX];
+
+	if (argc != 2) {
+		errx(EXIT_FAILURE, "missing required ccid path");
+	}
+
+	if ((fd = open(argv[1], O_RDWR)) < 0) {
+		err(EXIT_FAILURE, "failed to open %s", argv[1]);
+	}
+
+	bzero(&begin, sizeof (begin));
+	begin.uct_version = UCCID_CURRENT_VERSION;
+
+	if (ioctl(fd, UCCID_CMD_TXN_BEGIN, &begin) != 0) {
+		err(EXIT_FAILURE, "failed to issue begin ioctl");
+	}
+
+	if ((ret = write(fd, yk_req, sizeof (yk_req))) < 0) {
+		err(EXIT_FAILURE, "failed to write data");
+	}
+
+	if ((ret = read(fd, buf, sizeof (buf))) < 0) {
+		err(EXIT_FAILURE, "failed to read data");
+	}
+
+	(void) printf("read %d bytes\n", ret);
+	for (i = 0; i < ret; i++) {
+		(void) printf("%02x", buf[i]);
+		if (i == (ret - 1) || (i % 16) == 15) {
+			(void) printf("\n");
+		} else {
+			(void) printf(" ");
+		}
+	}
+
+	return (0);
+}
diff --git a/usr/src/uts/common/Makefile.files b/usr/src/uts/common/Makefile.files
index 78894e23f2..18e88c807c 100644
--- a/usr/src/uts/common/Makefile.files
+++ b/usr/src/uts/common/Makefile.files
@@ -1816,6 +1816,8 @@ USB_IA_OBJS += usb_ia.o
 
 SCSA2USB_OBJS += scsa2usb.o usb_ms_bulkonly.o usb_ms_cbi.o
 
+CCID_OBJS += ccid.o atr.o ccid_t1.o
+
 IPF_OBJS += cfw.o ip_fil_solaris.o fil.o solaris.o ip_state.o ip_frag.o \
 	    ip_nat.o ip_proxy.o ip_auth.o ip_pool.o ip_htable.o ip_lookup.o \
 	    ip_log.o misc.o ip_compat.o ip_nat6.o drand48.o
diff --git a/usr/src/uts/common/Makefile.rules b/usr/src/uts/common/Makefile.rules
index ffdf386a39..238bc9ea44 100644
--- a/usr/src/uts/common/Makefile.rules
+++ b/usr/src/uts/common/Makefile.rules
@@ -1207,6 +1207,14 @@ $(OBJS_DIR)/%.o:		$(UTSBASE)/common/io/usb/clients/audio/usb_ah/%.c
 	$(COMPILE.c) -o $@ $<
 	$(CTFCONVERT_O)
 
+$(OBJS_DIR)/%.o:		$(UTSBASE)/common/io/usb/clients/ccid/%.c
+	$(COMPILE.c) -o $@ $<
+	$(CTFCONVERT_O)
+
+$(OBJS_DIR)/%.o:		$(COMMONBASE)/ccid/%.c
+	$(COMPILE.c) -o $@ $<
+	$(CTFCONVERT_O)
+
 $(OBJS_DIR)/%.o:		$(UTSBASE)/common/io/usb/clients/usbskel/%.c
 	$(COMPILE.c) -o $@ $<
 	$(CTFCONVERT_O)
diff --git a/usr/src/uts/common/io/usb/clients/ccid/ccid.c b/usr/src/uts/common/io/usb/clients/ccid/ccid.c
new file mode 100644
index 0000000000..0108a81d6e
--- /dev/null
+++ b/usr/src/uts/common/io/usb/clients/ccid/ccid.c
@@ -0,0 +1,5180 @@
+/*
+ * This file and its contents are supplied under the terms of the
+ * Common Development and Distribution License ("CDDL"), version 1.0.
+ * You may only use this file in accordance with the terms of version
+ * 1.0 of the CDDL.
+ *
+ * A full copy of the text of the CDDL should have accompanied this
+ * source.  A copy of the CDDL is also available via the Internet at
+ * http://www.illumos.org/license/CDDL.
+ */
+
+/*
+ * Copyright (c) 2017, Joyent, Inc. 
+ */
+
+/*
+ * USB CCID class driver
+ *
+ * Slot Detection
+ * --------------
+ *
+ * A CCID reader has one or more slots, each of which may or may not have a card
+ * present. Some devices actually have a card that's permanently plugged in
+ * while other readers allow for cards to be inserted and removed. We model all
+ * CCID readers that don't have removable cards as ones that are removable, but
+ * never fire any events. Removable devices are required to have an Interrupt-IN
+ * pipe.
+ *
+ * Each slot starts in an unknown state. After attaching we always kick off a
+ * discovery. When a change event comes in, that causes us to kick off a
+ * discovery again, though we focus it only on those endpoints that have noted a
+ * change. At attach time we logically mark that every endpoint has changed,
+ * allowing us to figure out what its actual state is. We don't rely on any
+ * initial Interrupt-IN polling to allow for the case where either the hardware
+ * doesn't report it or to better handle the devices without an Interrupt-IN
+ * entry. Just because we open up the Interupt-IN pipe, hardware is not
+ * obligated to tell us, as the adding and removing a driver will not cause a
+ * power cycle.
+ *
+ * The Interrupt-IN exception callback may need to restart polling. In addition,
+ * we may fail to start or restart polling due to a transient issue. In cases
+ * where the attempt to start polling has failed, we try again in one second
+ * with a timeout.
+ *
+ * Discovery is run through a taskq. The various slots are checked serially. If
+ * a discovery is running when another change event comes in, we flag ourselves
+ * for a follow up run. This means that it's possible that we end up processing
+ * items early and that the follow up run is ignored.
+ *
+ * Two state flags are used to keep track of this dance: CCID_F_WORKER_REQUESTED
+ * and CCID_F_WORKER_RUNNING. The first is used to indicate that discovery is
+ * desired. The second is to indicate that it is actively running. When
+ * discovery is requested, the caller first checks to make sure the current
+ * flags. If neither flag is set, then it knows that it can kick off discovery.
+ * Regardless if it can kick off the taskq, it always sets requested. Once the
+ * taskq entry starts, it removes any DISCOVER_REQUESTED flags and sets
+ * DISCOVER_RUNNING. If at the end of discovery, we find that another request
+ * has been made, the discovery function will kick off another entry in the
+ * taskq.
+ *
+ * The one possible problem with this model is that it means that we aren't
+ * throttling the set of incoming requests with respect to taskq dispatches.
+ * However, because these are only driven by an Interrupt-IN pipe, it is hoped
+ * that the frequency will be rather reduced. If it turns out that that's not
+ * the case, we may need to use a timeout or another trick to ensure that only
+ * one discovery per tick or so is initialized. The main reason we don't just do
+ * that off the bat and add a delay is because of contactless cards which may
+ * need to be acted upon in a soft real-time fashion.
+ *
+ * Command Handling
+ * ----------------
+ *
+ * Commands are issued to a CCID reader on a Bulk-OUT pipe. Responses are
+ * generated as a series of one or more messages on a Bulk-IN pipe. To correlate
+ * these commands a sequence number is used. This sequence number is one byte
+ * and can be in the range [ CCID_SEQ_MIN, CCID_SEQ_MAX ]. To keep track of the
+ * allocatd IDs we leverage an ID space.
+ *
+ * A CCID reader contains a number of slots. Each slot can be addressed
+ * separately as each slot represents a separate place that a card may be
+ * inserted or not. A given slot may only have a single outstanding command. A
+ * given CCID reader may only have a number of commands outstanding to the CCID
+ * device as a whole based on a value in the class descriptor (see the
+ * ccd_bMacCCIDBusySlots member of the ccid_class_descr_t).
+ *
+ * To simplify the driver, we only support issuing a single command to a CCID
+ * reader at any given time. All commands that are outstanding are queued in a
+ * global list ccid_command_queue. The head of the queue is the current command
+ * that we believe is outstanding to the reader or will be shortly. The command
+ * is issued by sending a Bulk-OUT request with a CCID header. Once we have the
+ * Bulk-OUT request acknowledged, we begin sending Bulk-IN messages to the
+ * controller. Once the Bulk-IN message is acknowledged, then we complete the
+ * command proceed to the next command. This is summarized in the following
+ * state machine:
+ *
+ * XXX
+ *
+ * APDU and TPDU Processing and Parameter Selection
+ * ------------------------------------------------
+ *
+ * Readers provide four different modes for us to be able to transmit data to
+ * and from the card. These are:
+ *
+ * 1. Character Mode 2. TPDU Mode 3. Short APDU Mode 4. Extended APDU Mode
+ *
+ * Devices either support mode 1, mode 2, mode 3, or mode 3 and 4. All readers
+ * that support extended APDUs support short APDUs. At this time, we do not
+ * support character mode.
+ *
+ * The ICC and the reader need to be in agreement in order for them to be able
+ * to exchange information. The ICC indicates what it supports by replying to a
+ * power on command with an ATR (answer to reset). This data can be parsed to
+ * indicate which of two protocols the ICC supports. These protocols are
+ * referred to as:
+ *
+ *  o T=0
+ *  o T=1
+ *
+ * These protocols are defined in the ISO/IEC 7816-3:2006 specification. When a
+ * reader supports an APDU mode, then it does not have to worry about the
+ * underlying protocol and can just send an application data unit (APDU).
+ * Otherwise, the reader must take the application data (APDU) and transform it
+ * into the form required by the corresponding protocol.
+ *
+ * There are several parameters that need to be negotiated to insure that the
+ * protocols work correctly. To negotiate these parameters and to select a
+ * protocol, the reader must construct a PPS (protocol and parameters structure)
+ * request and exchange that with the ICC. A reader may optionally take care of
+ * performing this and indicates its support for this in dwFeatures member of
+ * the USB class descriptor.
+ *
+ * In addition, the reader itself must often be told of these configuration
+ * changes through the means of a CCID_REQUEST_SET_PARAMS command. Once both of
+ * these have been performed, the reader and ICC can communicate to their hearts
+ * desire.
+ *
+ * Both the negotiation and the setting of the parameters can be performed
+ * automatically by the CCID reader. When the reader supports APDU exchanges,
+ * then it must support some aspects of this negotiation. Because of that, we
+ * never consider performing this for APDU related activity and only worry about
+ * this for TPDU transfers.
+ *
+ * In the ATR data the device can indicate whether or not it supports
+ * negotiating this information. If the hardware does not support negotiation,
+ * then it likely does not support a PPS and in which case we need to program
+ * the hardware with the parameters indicated by the ATR through a
+ * CCID_REQUEST_SET_PARAMS command and do not need to negotiation a PPS.
+ * 
+ * Many ICC devices support negotiation. When an ICC supporting negotiation is
+ * first turned on then it enters into a default mode and uses the default
+ * values while in that mode. The PPS may be used to change the protocol as well
+ * as several parameters. Once the PPS has been agreed upon, this driver just
+ * send a CCID_REQUEST_SET_PARAMS command to inform the reader what is going on.
+ *
+ * If the CCID reader supports neither of the hardware related mechanisms for a
+ * PPS exchange, then we must do both of these. If hardware supports automatic
+ * parameter negotiation then we do not need to send either the PPS or the
+ * CCID_REQUEST_SET_PARAMS command.
+ *
+ * The ATR offers us what the hardware's maximum value of Di and Fi are. If the
+ * reader supports higher speeds, then we will 
+ *
+ * XXX At the moment we're not adjusting any of the Di or Fi values beyond their
+ * default.
+ *
+ * To summarize this all, the following is the flow chart we perform after
+ * successfully powering on the device:
+ *
+ *  - If the reader supports APDU transfers, then we are done.
+ *     XXX Depending on level of automation we may need to still do things.
+ *  - If the reader supports 
+ *
+ * User I/O Basics
+ * ---------------
+ *
+ * A user performs I/O by writing APDUs (Application Protocol Data Units). A
+ * user issues a system call that ends up in write(9E) (write(2), writev(2),
+ * pwrite(2), pwritev(2), etc.). The user data is consumed by the CCID driver
+ * and a series of commands will then be issued to the device, depending on the
+ * protocol mode. The write(9E) call does not block for this to finish. Once
+ * write(9E) has returned, the user may block in a read(2) related system call
+ * or poll for POLLIN.
+ *
+ * A thread may not call read(9E) without having called write(9E). This model is
+ * due to the limited capability of hardware. Only a single command can be going
+ * on a given slot and due to the fact that many commands change the hardware
+ * state, we do not try to multiplex multiple calls to write() or read().
+ *
+ *
+ * User I/O, Transaction Ends, ICC removals, and Reader Removals
+ * -------------------------------------------------------------
+ *
+ * While the I/O model given to user land is somewhat simple, there are a lot of
+ * tricky pieces to get right because we are in a multi-threaded pre-emptible
+ * system. In general, there are four different levels of state that we need to
+ * keep track of:
+ *
+ *   1. User threads in I/O
+ *   2. Kernel protocol level support (T=1, apdu, etc.).
+ *   3. Slot/ICC state
+ *   4. CCID Reader state
+ *
+ * Of course, each level cares about the state above it. The kernel protocol
+ * level state (2), cares about the User threads in I/O (1). The same is true
+ * with the other levels caring about the levels above it. With this in mind
+ * there are three non-data path things that can go wrong:
+ *
+ *   A. The user can end a transaction (whether through an ioctl or close(9E)).
+ *   B. The ICC can be removed
+ *   C. The CCID device can be removed or is reset at a USB level.
+ *
+ * Each of these has implications on the outstanding I/O and other states of
+ * the world. When events of type A occur, we need to clean up states 1 and 2.
+ * Then events of type B occur we need to clean up states 1-3. When events of
+ * type C occur we need to clean up states 1-4. The following discusses how we
+ * should clean up these different states:
+ *
+ * Cleaning up State 1:
+ *
+ *   To clean up the User threads in I/O there are three different cases to
+ *   consider. The first is cleaning up a thread that is in the middle of
+ *   write(9E). The second is cleaning up thread that is blocked in read(9E).
+ *   The third is dealing with threads that are stuck in chpoll(9E).
+ *
+ *   To handle the write case, we have a series of flags that is on the CCID
+ *   slot's I/O structure (ccid_io_t, cs_io on the ccid_slot_t). When a thread
+ *   begins its I/O it will set the CCID_IO_F_PREPARING flag. This flag is used
+ *   to indicate that there is a thread that is performing a write(9E), but it
+ *   is not holding the ccid_mutex because of the operations that it is taking.
+ *   Once it has finished, the thread will remove that flag and instead
+ *   CCID_IO_F_IN_PROGRESS will be set. If we find that the CCID_IO_F_PREPARING
+ *   flag is set, then we will need to wait for it to be removed before
+ *   continuing. The fact that there is an outstanding physical I/O will be
+ *   dealt with when we clean up state 2.
+ *
+ *   To handle the read case, we have a flag on the ccid_minor_t which indicates
+ *   that a thread is blocked on a condition variable (cm_read_cv), waiting for
+ *   the I/O to complete. The way this gets cleaned up varies a bit on each of
+ *   the different cases as each one will trigger a different error to the
+ *   thread. In all cases, the condition variable will be signaled. Then,
+ *   whenever the thread comes out of the condition variable it will always
+ *   check the state to see if it has been woken up because the transaction is
+ *   being closed, the ICC has been removed, or the reader is being
+ *   disconnected. In all such cases, the thread in read will end up receiving
+ *   an error (ECANCELED, ENXIO, and ENODEV respectively).
+ *
+ *   If we have hit the case that this needs to be cleaned up, then the
+ *   CCID_MINOR_F_READ_WAITING flag will be set on the ccid_minor_t's flags
+ *   member (cm_flags). In this case, the broader system must change the
+ *   corresponding system state flag for the appropriate condition, signal the
+ *   read cv, and then wait on an additional cv in the minor, the
+ *   ccid_iowait_cv).
+ *
+ *   Cleaning up the poll state is somewhat simpler. If any of the conditions
+ *   (A-C) occur, then we must flag POLLERR. In addition if B and C occur, then
+ *   we will flag POLLHUP at the same time. This will guarantee that any threads
+ *   in poll(9E) are woken up.
+ *
+ * Cleaning up State 2.
+ *
+ *   While the user I/O thread is a somewhat straightforward, the kernel
+ *   protocol level is a bit more complicated. The core problem is that when a
+ *   user issues a logical I/O through an APDU, that may result in a series of
+ *   one or protocol level, physical commands. The core crux of the issue with
+ *   cleaning up this state is twofold:
+ *
+ *     1. We don't want to block a user thread while I/O is outstanding
+ *     2. We need to take one of several steps to clean up the aforementioned
+ *        I/O
+ *
+ *   To try and deal with that, there are a number of different things that we
+ *   do. The first thing we do is that we clean up the user state based on the
+ *   notes in cleaning up in State 1. Importantly we need to _block_ on this
+ *   activity.
+ *
+ *   Once that is done, we need to proceed to step 2. The way that this happens
+ *   will depend on the protocol in use and the state that it has. For example,
+ *   when performing APDU processing, this is as simple as waiting for that
+ *   command to complete and/or potentially issues an abort or reset. However,
+ *   for TPDU T=1 processing, we may need to issue subsequent commands to abort
+ *   the state. The amount of work that we do depends on what the user
+ *   configured options are when they ended the transaction. They may tell us to
+ *   either reset or to keep the card in the same state.
+ *
+ *   While this is ongoing an additional flag (XXX) will be set on the slot to
+ *   make sure that we know that we can't issue new I/O or that we can't proceed
+ *   to the next transaction until this phase is finished. XXX This feels rather
+ *   rough.
+ *
+ * Cleaning up State 3
+ *
+ *   When the ICC is removed, this is not dissimilar to the previous states. To
+ *   handle this we need to first make sure that state 1 and state 2 are
+ *   finished being cleaned up. We will have to _block_ on this from the worker
+ *   thread. The problem is that we have certain values such as the operations
+ *   vector, the ATR data, etc. that we need to make sure are still valid while
+ *   we're in the process of cleaning up state. Only once all that is done
+ *   should we consider processing a new ICC insertion or dealing with other
+ *   aspects of this. The one good side is that if the ICC was removed, then it
+ *   should be simpler to handle all of the outstanding I/O.
+ *
+ *   XXX We need more details about how all this happens, etc.
+ *
+ * Cleaning up State 4
+ *
+ *   When the reader is removed, then we need to clean up all the prior states.
+ *   However, this is somewhat simpler than the other cases, as once this
+ *   happens our detach endpoint will be called to clean up all of our
+ *   resources. Therefore, before we call detach, we need to explicitly clean up
+ *   state 1; however, we then at this time leave all the remaining state to be
+ *   cleaned up during detach(9E) as part of normal tear down.
+ *
+ *   XXX Is that really true, this seems like a lot of BS.
+ */
+
+/*
+ * Various XXX:
+ *
+ * o If hardware says that the ICC became shut down / disactivated. Should we
+ * explicitly reactivate it as part of something or just make that a future
+ * error?
+ *  - Should we provide an ioctl to try to reactivate?
+ *
+ * o There is a series of edge cases that we need to handle with both read /
+ *   write. These include:
+ *
+ *   + I/O in flight when end transaction occurs
+ *       o Quiesce the I/O (may involve reset and abort) from a kernel
+ *         perspective
+ *       o Hand off to next transaction only when above is complete
+ *       o POLLERR should signaled on the minor's pollhead
+ *   + I/O in flight when ICC is removed
+ *       o Quiesce the I/O from a kernel perspective
+ *       o End the I/O with an ENXIO (maybe ECONNRESET?) from a user perspective
+ *       o Kernel worker thread should block on kernel clean up, but not user
+ *         consumption. We should not call into rx function to try and consume /
+ *         clean up. It should get cleaned up by other functions.
+ *       o POLLOUT is not signalled until both I/O is consumed and new ICC is
+ *         present
+ *       o POLLIN | POLLHUP should be signaled
+ *   + I/O in flight when reader is removed
+ *       o Ensure that I/O is quiesced from a kernel perspective, nothing should
+ *         be queued for user
+ *       o POLLERR | POLLHUP should be signaled to tell the user that this I/O
+ *         is not coming back.
+ *   + Blocked in read when an end transaction occurs
+ *       o Quiesce the I/O (may involve reset and abort) form a kernel
+ *         perspective
+ *       o Signal and wake up the thread blocked in read(), it should get
+ *         ECANCELED
+ *       o Don't allow the transaction hand off to progress until read thread is
+ *         gone
+ *       o Follow all of the I/O in flight when transaction ends steps
+ *   + Blocked in read when an ICC is removed
+ *       o follow all I/O in flight when ICC is removed steps
+ *       o Signal and wake up the thread blocked in read() to get the error set
+ *         on disconnect.
+ *   + Blocked in read when an reader is removed
+ *       o Follow all normal I/O steps when reader removed
+ *       o Signal and wake up the thread blocked in read(). It should check the
+ *         DISCONNECTED, not the DETACHED flag.
+ *   + Unread, but completed I/O when an end transaction occurs w/ ICC
+ *       o Consume logical I/O state. Do not signal in this case
+ *       o Potentially warm reset ICC
+ *       o POLLERR should be raised with transaction end
+ *   + Unread, but completed I/O when an end transaction occurs w/o ICC
+ *       o Consume logical I/O state. Do not signal.
+ *       o POLLERR should be raised with transaction end
+ *   + Unread, but completed I/O when the ICC is removed
+ *       o XXX This one is tricky, because we might want to reset our T=1 state
+ *         on insertion of a new ICC before this is read. Ugh. Maybe we should
+ *         pull out the mblk_t chain when the I/O is completed so we can
+ *         disassociate this state. 
+ *       o Still need to signal POLLHUP, but POLLIN should already have been
+ *         done
+ *   + Unread, but completed I/O when the reader is removed
+ *       o POLLERR | POLLHUP? should be signaled on the device
+ *       o Outstanding I/O should be cleaned up as part of minor close
+ *
+ * o Proper POLLOUT on ICC insertion / activation
+ *
+ *
+ *
+ * o XXX We're not properly handling the case where we get a transport error,
+ * say we get a time extension and we fail to schedule the next bulk request.
+ * While today we'll clean up the I/O corectly, the actual ICC will still be
+ * expecting us to take action. In which case we should request a reset and make
+ * sure that write is blocked on that.
+ */
+
+#include <sys/modctl.h>
+#include <sys/errno.h>
+#include <sys/conf.h>
+#include <sys/ddi.h>
+#include <sys/sunddi.h>
+#include <sys/cmn_err.h>
+#include <sys/sysmacros.h>
+#include <sys/stream.h>
+#include <sys/strsun.h>
+#include <sys/strsubr.h>
+#include <sys/filio.h>
+
+#define	USBDRV_MAJOR_VER	2
+#define	USBDRV_MINOR_VER	0
+#include <sys/usb/usba.h>
+#include <sys/usb/usba/usbai_private.h>
+#include <sys/usb/clients/ccid/ccid.h>
+#include <sys/usb/clients/ccid/uccid.h>
+
+#include <atr.h>
+#include <ccid_t1.h>
+
+/*
+ * Set the amount of parallelism we'll want to have from kernel threads which
+ * are processing CCID requests. This is used to size the number of asynchronous
+ * requests in the pipe policy. A single command can only ever be outstanding to
+ * a single slot. However, multiple slots may potentially be able to be
+ * scheduled in parallel. However, we don't actually support this at all and
+ * we'll only ever issue a single command. This basically covers the ability to
+ * have some other asynchronous operation outstanding if needed.
+ */
+#define	CCID_NUM_ASYNC_REQS	2
+
+/*
+ * This is the number of Bulk-IN requests that we will have cached per CCID
+ * device. While many commands will generate a single response, the commands
+ * also have the ability to generate time extensions, which means that we'll
+ * want to be able to schedule another Bulk-IN request immediately. If we run
+ * out, we will attempt to refill said cache and will not fail commands
+ * needlessly.
+ */
+#define	CCID_BULK_NALLOCED		16
+
+/*
+ * XXX This is a time in seconds for the bulk-out command to run and be
+ * submitted. We'll need to evaluate this and see if it actually makes sense.
+ */
+#define	CCID_BULK_OUT_TIMEOUT	5
+#define	CCID_BULK_IN_TIMEOUT	5
+
+/*
+ * There are two different Interrupt-IN packets that we might receive. The
+ * first, RDR_to_PC_HardwareError, is a fixed four byte packet. However, the
+ * other one, RDR_to_PC_NotifySlotChange, varies in size as it has two bits per
+ * potential slot plus one byte that's always used. The maximum number of slots
+ * in a device is 256. This means there can be up to 64 bytes worth of data plus
+ * the extra byte, so 65 bytes.
+ */
+#define	CCID_INTR_RESPONSE_SIZE	65
+
+/*
+ * Minimum and maximum minor ids. We treat the maximum valid 32-bit minor as
+ * what we can use due to issues in some file systems and the minors that they
+ * can use. We reserved zero as an invalid minor number to make it easier to
+ * tell if things have been initailized or not.
+ */
+#define	CCID_MINOR_MIN		1
+#define	CCID_MINOR_MAX		MAXMIN32
+#define	CCID_MINOR_INVALID	0
+
+/*
+ * This value represents the minimum size value that we require in the CCID
+ * class descriptor's dwMaxCCIDMessageLength member. We got to 64 bytes based on
+ * the required size of a bulk transfer packet size. Especially as many CCID
+ * devices are these class of speeds. The specification does require that the
+ * minimu size of the dwMaxCCIDMessageLength member is at least the size of its
+ * bulk endpoint packet size.
+ */
+#define	CCID_MIN_MESSAGE_LENGTH	64
+
+/*
+ * Required forward declarations.
+ */
+struct ccid;
+struct ccid_slot;
+struct ccid_minor;
+struct ccid_command;
+
+/*
+ * This structure is used to map between the global set of minor numbers and the
+ * things represented by them.
+ */
+typedef struct ccid_minor_idx {
+	id_t cmi_minor;
+	avl_node_t cmi_avl;
+	boolean_t cmi_isslot;
+	union {
+		struct ccid_slot *cmi_slot;
+		struct ccid_minor *cmi_user;
+	} cmi_data;
+} ccid_minor_idx_t;
+
+typedef enum ccid_minor_flags {
+	CCID_MINOR_F_WAITING		= 1 << 0,
+	CCID_MINOR_F_HAS_EXCL		= 1 << 1,
+	CCID_MINOR_F_TXN_RESET		= 1 << 2,
+	CCID_MINOR_F_READ_WAITING	= 1 << 3,
+} ccid_minor_flags_t;
+
+typedef struct ccid_minor {
+	ccid_minor_idx_t	cm_idx;		/* WO */
+	cred_t			*cm_opener;	/* WO */
+	struct ccid_slot	*cm_slot;	/* WO */
+	list_node_t		cm_minor_list;
+	list_node_t		cm_excl_list;
+	kcondvar_t		cm_read_cv;
+	kcondvar_t		cm_iowait_cv;
+	kcondvar_t		cm_excl_cv;
+	ccid_minor_flags_t	cm_flags;
+	struct pollhead		cm_pollhead;
+} ccid_minor_t;
+
+typedef enum ccid_slot_flags {
+	CCID_SLOT_F_CHANGED		= 1 << 0,
+	CCID_SLOT_F_INTR_GONE		= 1 << 1,
+	CCID_SLOT_F_INTR_ADD		= 1 << 2,
+	CCID_SLOT_F_PRESENT		= 1 << 3,
+	CCID_SLOT_F_ACTIVE		= 1 << 4,
+	CCID_SLOT_F_NEED_TXN_RESET	= 1 << 5,
+	CCID_SLOT_F_NEED_IO_TEARDOWN	= 1 << 6,
+} ccid_slot_flags_t;
+
+#define	CCID_SLOT_F_INTR_MASK	(CCID_SLOT_F_CHANGED | CCID_SLOT_F_INTR_GONE | \
+    CCID_SLOT_F_INTR_ADD)
+#define	CCID_SLOT_F_WORK_MASK	(CCID_SLOT_F_INTR_MASK | \
+    CCID_SLOT_F_NEED_TXN_RESET)
+#define	CCID_SLOT_F_NOEXCL_MASK	(CCID_SLOT_F_NEED_TXN_RESET | CCID_SLOT_F_NEED_IO_TEARDOWN)
+
+typedef void (*icc_init_func_t)(struct ccid *, struct ccid_slot *);
+typedef int (*icc_transmit_func_t)(struct ccid *, struct ccid_slot *);
+typedef void (*icc_complete_func_t)(struct ccid *, struct ccid_slot *,
+    struct ccid_command *);
+typedef void (*icc_teardown_func_t)(struct ccid *, struct ccid_slot *, int);
+typedef void (*icc_fini_func_t)(struct ccid *, struct ccid_slot *);
+
+typedef struct ccid_icc {
+	atr_data_t		*icc_atr_data;
+	atr_protocol_t		icc_protocols;
+	atr_protocol_t		icc_cur_protocol;
+	ccid_params_t		icc_params;
+	icc_init_func_t		icc_init;
+	icc_transmit_func_t	icc_tx;
+	icc_complete_func_t	icc_complete;
+	icc_teardown_func_t	icc_teardown;
+	icc_fini_func_t		icc_fini;
+} ccid_icc_t;
+
+/*
+ * Structure used to take care of and map I/O requests and things. This may not
+ * make sense as we develop the T=0 and T=1 code.
+ */
+typedef enum ccid_io_flags {
+	/*
+	 * This flag is used during the period that a thread has started calling
+	 * into ccid_write(9E), but before it has finished queuing up the write.
+	 * This blocks pollout or another thread in write.
+	 */
+	CCID_IO_F_PREPARING	= 1 << 0,
+	/*
+	 * This flag is used once a ccid_write() ICC tx function has
+	 * successfully completed. While this is set, the device is not
+	 * writable; however, it is legal to call ccid_read() and block. This
+	 * flag will remain set until the actual write is done. This indicates
+	 * that the transmission protocol has finished.
+	 */
+	CCID_IO_F_IN_PROGRESS	= 1 << 1,
+	/*
+	 * This flag is used to indicate that the logical I/O has completed in
+	 * one way or the other and that a reader can consume data. When this
+	 * flag is set, then POLLIN | POLLRDNORM should be signaled. Until the
+	 * I/O is consumed via ccid_read(), calls to ccid_write() will fail with
+	 * EBUSY. When this flag is set, the kernel protocol level should be
+	 * idle and it should be safe to tear down.
+	 */
+	CCID_IO_F_DONE		= 1 << 2,
+	/*
+	 * This flag is used to indicate that a given I/O has been abandoned by
+	 * the user and that we need to clean things up before the ICC is usable
+	 * again. 
+	 *
+	 * XXX Should this really be set? I'm now starting to wonder if this
+	 * would make more sent to have like we have the resetting flag.
+	 * Especially if for T=1 we issue an abort.
+	 */
+	CCID_IO_F_ABANDONED	= 1 << 3
+} ccid_io_flags_t;
+
+/*
+ * If any of the flags in the POLLOUT group are set, then the device is not
+ * writeable. The same distinction isn't true for POLLIN. We are only readable 
+ * if CCID_IO_F_DONE is set. However, you are allowed to call read as soon as
+ * CCID_IO_F_IN_PROGRESS is set.
+ */
+#define	CCID_IO_F_POLLOUT_FLAGS	(CCID_IO_F_PREPARING | CCID_IO_F_IN_PROGRESS | \
+    CCID_IO_F_DONE)
+#define	CCID_IO_F_ALL_FLAGS	(CCID_IO_F_PREPARING | CCID_IO_F_IN_PROGRESS | \
+    CCID_IO_F_DONE | CCID_IO_F_ABANDONED)
+
+typedef struct ccid_io {
+	ccid_io_flags_t	ci_flags;
+	size_t		ci_ilen;
+	uint8_t		ci_ibuf[CCID_APDU_LEN_MAX];
+	mblk_t		*ci_omp;
+	kcondvar_t	ci_cv;
+	struct ccid_command *ci_command;
+	int		ci_errno;
+	mblk_t		*ci_data;
+	t1_state_t	ci_t1;
+} ccid_io_t;
+
+typedef struct ccid_slot {
+	ccid_minor_idx_t	cs_idx;		/* WO */
+	uint_t			cs_slotno;	/* WO */
+	struct ccid		*cs_ccid;	/* WO */
+	ccid_slot_flags_t	cs_flags;
+	ccid_class_voltage_t	cs_voltage;
+	mblk_t			*cs_atr;
+	struct ccid_command	*cs_command;
+	ccid_minor_t		*cs_excl_minor;
+	list_t			cs_excl_waiters;
+	list_t			cs_minors;
+	ccid_icc_t		cs_icc;
+	ccid_io_t		cs_io;
+} ccid_slot_t;
+
+typedef enum ccid_attach_state {
+	CCID_ATTACH_USB_CLIENT	= 1 << 0,
+	CCID_ATTACH_MUTEX_INIT	= 1 << 1,
+	CCID_ATTACH_TASKQ	= 1 << 2,
+	CCID_ATTACH_CMD_LIST	= 1 << 3,
+	CCID_ATTACH_OPEN_PIPES	= 1 << 4,
+	CCID_ATTACH_SEQ_IDS	= 1 << 5,
+	CCID_ATTACH_SLOTS	= 1 << 6,
+	CCID_ATTACH_HOTPLUG_CB	= 1 << 7,
+	CCID_ATTACH_INTR_ACTIVE	= 1 << 8,
+	CCID_ATTACH_MINORS	= 1 << 9,
+} ccid_attach_state_t;
+
+typedef enum ccid_flags {
+	CCID_F_HAS_INTR		= 1 << 0,
+	CCID_F_NEEDS_PPS	= 1 << 1,
+	CCID_F_NEEDS_PARAMS	= 1 << 2,
+	CCID_F_NEEDS_DATAFREQ	= 1 << 3,
+	CCID_F_NEEDS_IFSD	= 1 << 4,
+	CCID_F_DETACHING	= 1 << 5,
+	CCID_F_WORKER_REQUESTED	= 1 << 6,
+	CCID_F_WORKER_RUNNING	= 1 << 7,
+	CCID_F_DISCONNECTED	= 1 << 8
+} ccid_flags_t;
+
+#define	CCID_F_WORKER_MASK	(CCID_F_WORKER_REQUESTED | \
+    CCID_F_WORKER_RUNNING)
+#define	CCID_F_ICC_INIT_MASK	(CCID_F_NEEDS_PPS | CCID_F_NEEDS_PARAMS | \
+    CCID_F_NEEDS_IFSD | CCID_F_NEEDS_DATAFREQ)
+
+typedef struct ccid_stats {
+	uint64_t	cst_intr_errs;
+	uint64_t	cst_intr_restart;
+	uint64_t	cst_intr_unknown;
+	uint64_t	cst_intr_slot_change;
+	uint64_t	cst_intr_hwerr;
+	uint64_t	cst_intr_inval;
+	uint64_t	cst_ndiscover;
+	hrtime_t	cst_lastdiscover;
+} ccid_stats_t;
+
+typedef struct ccid {
+	dev_info_t		*ccid_dip;
+	kmutex_t		ccid_mutex;
+	ccid_attach_state_t	ccid_attach;
+	ccid_flags_t		ccid_flags;
+	id_space_t		*ccid_seqs;
+	ddi_taskq_t		*ccid_taskq;
+	usb_client_dev_data_t	*ccid_dev_data;
+	ccid_class_descr_t	ccid_class;		/* WO */
+	usb_ep_xdescr_t		ccid_bulkin_xdesc;	/* WO */
+	usb_pipe_handle_t	ccid_bulkin_pipe;	/* WO */
+	usb_ep_xdescr_t		ccid_bulkout_xdesc;	/* WO */
+	usb_pipe_handle_t	ccid_bulkout_pipe;	/* WO */
+	usb_ep_xdescr_t		ccid_intrin_xdesc;	/* WO */
+	usb_pipe_handle_t	ccid_intrin_pipe;	/* WO */
+	usb_pipe_handle_t	ccid_control_pipe;	/* WO */
+	uint_t			ccid_nslots;		/* WO */
+	size_t			ccid_bufsize;		/* WO */
+	ccid_slot_t		*ccid_slots;
+	timeout_id_t		ccid_poll_timeout;
+	ccid_stats_t		ccid_stats;
+	list_t			ccid_command_queue;
+	list_t			ccid_complete_queue;
+	usb_bulk_req_t		*ccid_bulkin_cache[CCID_BULK_NALLOCED];
+	uint_t			ccid_bulkin_alloced;
+	usb_bulk_req_t		*ccid_bulkin_dispatched;
+} ccid_t;
+
+/*
+ * Command structure for an individual CCID command that we issue to a
+ * controller. Note that the command caches a copy of some of the data that's
+ * normally inside the CCID header in host-endian fashion.
+ */
+typedef enum ccid_command_state {
+	CCID_COMMAND_ALLOCATED	= 0x0,
+	CCID_COMMAND_QUEUED,
+	CCID_COMMAND_DISPATCHED,
+	CCID_COMMAND_REPLYING,
+	CCID_COMMAND_COMPLETE,
+	CCID_COMMAND_TRANSPORT_ERROR,
+	CCID_COMMAND_CCID_ABORTED
+} ccid_command_state_t;
+
+typedef enum ccid_command_flags {
+	CCID_COMMAND_F_USER	= 1 << 0,
+} ccid_command_flags_t;
+
+typedef struct ccid_command {
+	list_node_t		cc_list_node;
+	kcondvar_t		cc_cv;
+	uint8_t			cc_mtype;
+	uint8_t			cc_slot;
+	ccid_command_state_t	cc_state;
+	ccid_command_flags_t	cc_flags;
+	int			cc_usb;
+	usb_cr_t		cc_usbcr;
+	size_t			cc_reqlen;
+	id_t			cc_seq;
+	usb_bulk_req_t		*cc_ubrp;
+	ccid_t			*cc_ccid;
+	hrtime_t		cc_queue_time;
+	hrtime_t		cc_dispatch_time;
+	hrtime_t		cc_dispatch_cb_time;
+	hrtime_t		cc_response_time;
+	hrtime_t		cc_completion_time;
+	mblk_t			*cc_response;
+} ccid_command_t;
+
+/*
+ * ddi_soft_state(9F) pointer. This is used for instances of a CCID controller.
+ */
+static void *ccid_softstate;
+
+/*
+ * This is used to keep track of our minor nodes. We have two different kinds of
+ * minor nodes. The first are CCID slots. The second are cloned opens of those
+ * slots. Each of these items has a ccid_minor_idx_t embedded in them that is
+ * used to index them in an AVL tree. Given that the number of entries that
+ * should be present here is unlikely to be terribly large at any given time, it
+ * is hoped that an AVL tree will suffice for now.
+ */
+static kmutex_t ccid_idxlock;
+static avl_tree_t ccid_idx;
+static id_space_t *ccid_minors;
+
+/*
+ * Required Forwards
+ */
+static void ccid_intr_poll_init(ccid_t *);
+static void ccid_worker_request(ccid_t *);
+static void ccid_command_dispatch(ccid_t *);
+static void ccid_command_free(ccid_command_t *);
+static int ccid_bulkin_schedule(ccid_t *);
+static void ccid_command_bcopy(ccid_command_t *, const void *, size_t);
+
+/*
+ * XXX Are these needed?
+ */
+static int ccid_write_apdu(ccid_t *, ccid_slot_t *);
+static void ccid_complete_apdu(ccid_t *, ccid_slot_t *, ccid_command_t *);
+static void ccid_teardown_apdu(ccid_t *, ccid_slot_t *, int);
+
+static void ccid_init_tpdu_t1(ccid_t *, ccid_slot_t *);
+static int ccid_write_tpdu_t1(ccid_t *, ccid_slot_t *);
+static void ccid_complete_tpdu_t1(ccid_t *, ccid_slot_t *, ccid_command_t *);
+static void ccid_teardown_tpdu_t1(ccid_t *, ccid_slot_t *, int);
+static void ccid_fini_tpdu_t1(ccid_t *, ccid_slot_t *);
+
+
+static int
+ccid_idx_comparator(const void *l, const void *r)
+{
+	const ccid_minor_idx_t *lc = l, *rc = r;
+
+	if (lc->cmi_minor > rc->cmi_minor)
+		return (1);
+	if (lc->cmi_minor < rc->cmi_minor)
+		return (-1);
+	return (0);
+}
+
+static void
+ccid_error(ccid_t *ccid, const char *fmt, ...)
+{
+	va_list ap;
+
+	va_start(ap, fmt);
+	if (ccid != NULL) {
+		vdev_err(ccid->ccid_dip, CE_WARN, fmt, ap);
+	} else {
+		vcmn_err(CE_WARN, fmt, ap);
+	}
+	va_end(ap);
+}
+
+static void
+ccid_minor_idx_free(ccid_minor_idx_t *idx)
+{
+	ccid_minor_idx_t *ip;
+
+	VERIFY3S(idx->cmi_minor, !=, CCID_MINOR_INVALID);
+	mutex_enter(&ccid_idxlock);
+	ip = avl_find(&ccid_idx, idx, NULL);
+	VERIFY3P(idx, ==, ip);
+	avl_remove(&ccid_idx, idx);
+	id_free(ccid_minors, idx->cmi_minor);
+	idx->cmi_minor = CCID_MINOR_INVALID;
+	mutex_exit(&ccid_idxlock);
+}
+
+static boolean_t
+ccid_minor_idx_alloc(ccid_minor_idx_t *idx, boolean_t sleep)
+{
+	id_t id;
+	ccid_minor_idx_t *ip;
+	avl_index_t where;
+
+	mutex_enter(&ccid_idxlock);
+	if (sleep) {
+		id = id_alloc(ccid_minors);
+	} else {
+		id = id_alloc_nosleep(ccid_minors);
+	}
+	if (id == -1) {
+		mutex_exit(&ccid_idxlock);
+		return (B_FALSE);
+	}
+	idx->cmi_minor = id;
+	ip = avl_find(&ccid_idx, idx, &where);
+	VERIFY3P(ip, ==, NULL);
+	avl_insert(&ccid_idx, idx, where);
+	mutex_exit(&ccid_idxlock);
+
+	return (B_TRUE);
+}
+
+static ccid_minor_idx_t *
+ccid_minor_find(minor_t m)
+{
+	ccid_minor_idx_t i = { 0 };
+	ccid_minor_idx_t *ret;
+
+	i.cmi_minor = m;
+	mutex_enter(&ccid_idxlock);
+	ret = avl_find(&ccid_idx, &i, NULL);
+	mutex_exit(&ccid_idxlock);
+
+	return (ret);
+}
+
+static ccid_minor_idx_t *
+ccid_minor_find_user(minor_t m)
+{
+	ccid_minor_idx_t *idx;
+
+	idx = ccid_minor_find(m);
+	if (idx == NULL) {
+		return (NULL);
+	}
+	ASSERT0(idx->cmi_isslot);
+	if (idx->cmi_isslot)
+		return (NULL);
+	return (idx);
+}
+
+/*
+ * Check if the conditions are met to signal the next exclusive holder. For this
+ * to be true, there should be no one holding it. In addition, there must be
+ * someone in the queue waiting. Finally, we want to make sure that the ICC, if
+ * present, is in a state where it could handle these kinds of issues. That
+ * means that we shouldn't have an outstanding I/O question or warm reset
+ * ongoing. However, we must not block this on the condition of an ICC being
+ * present. But, if the reader has been disconnected, don't signal anyone.
+ */
+static void
+ccid_slot_excl_maybe_signal(ccid_slot_t *slot)
+{
+	ccid_minor_t *cmp;
+
+	VERIFY(MUTEX_HELD(&slot->cs_ccid->ccid_mutex));
+
+	if ((slot->cs_ccid->ccid_flags & CCID_F_DISCONNECTED) != 0)
+		return;
+	if (slot->cs_excl_minor != NULL)
+		return;
+	if ((slot->cs_flags & CCID_SLOT_F_NOEXCL_MASK) != 0)
+		return;
+	cmp = list_head(&slot->cs_excl_waiters);
+	if (cmp == NULL)
+		return;
+	cv_signal(&cmp->cm_excl_cv);
+}
+
+static void
+ccid_slot_excl_rele(ccid_slot_t *slot)
+{
+	ccid_minor_t *cmp;
+	ccid_t *ccid = slot->cs_ccid;
+
+	VERIFY(MUTEX_HELD(&ccid->ccid_mutex));
+	VERIFY3P(slot->cs_excl_minor, !=, NULL);
+
+	cmp = slot->cs_excl_minor;
+
+	/*
+	 * If we have an outstanding command left by the user when they've
+	 * closed the slot, we need to clean up this command. We need to call
+	 * the protocol specific handler here to determine what to do. If the
+	 * command has completed, but the user has never called read, then it
+	 * will simply clean it up. Otherwise it will indicate that there is
+	 * some amount of external state still ongoing to take care of and clean
+	 * up later.
+	 */
+	if (slot->cs_icc.icc_teardown != NULL) {
+		slot->cs_icc.icc_teardown(ccid, slot, ECANCELED);
+	}
+
+	/*
+	 * There may either be a thread blocked in read or in the process of
+	 * preparing a write. In either case, we need to make sure that they're
+	 * woken up or finish, before we finish tear down.
+	 */
+	while ((cmp->cm_flags & CCID_MINOR_F_READ_WAITING) != 0 ||
+	    (slot->cs_io.ci_flags & CCID_IO_F_PREPARING) != 0) {
+		cv_wait(&cmp->cm_iowait_cv, &ccid->ccid_mutex);
+	}
+
+	/*
+	 * At this point, we hold the lock and there should be no other threads
+	 * that are past the basic sanity checks. So at this point, note that
+	 * this minor no longer has exclusive access (causing other read/write
+	 * calls to fail) and start the process of cleaning up the outstanding
+	 * I/O on the slot. It is OK that at this point the thread may try to
+	 * obtain exclusive access again. It will end up blocking on everything
+	 * else.
+	 */
+	cmp->cm_flags &= ~CCID_MINOR_F_HAS_EXCL;
+	slot->cs_excl_minor = NULL;
+
+	/*
+	 * If at this point, we have an I/O that's noted as being done, but no
+	 * one blocked in read, then we need to clean that up. The ICC teardown
+	 * function is only designed to take care of in-flight I/Os.
+	 */
+	if ((slot->cs_io.ci_flags & CCID_IO_F_DONE) != 0) {
+		freemsg(slot->cs_io.ci_data);
+		slot->cs_io.ci_data = NULL;
+		slot->cs_io.ci_errno = 0;
+		slot->cs_io.ci_flags &= ~CCID_IO_F_DONE;
+		slot->cs_io.ci_ilen = 0;
+		bzero(slot->cs_io.ci_ibuf, sizeof (slot->cs_io.ci_ibuf));
+	}
+
+	/*
+	 * Regardless of when we're polling, we need to go through and error
+	 * out.
+	 */
+	pollwakeup(&cmp->cm_pollhead, POLLERR);
+
+	/*
+	 * If we've been asked to reset the device before handing it off,
+	 * schedule that. Otherwise, allow the next entry in the queue to get
+	 * woken up and given access to the device.
+	 */
+	if (cmp->cm_flags & CCID_MINOR_F_TXN_RESET) {
+		slot->cs_flags |= CCID_SLOT_F_NEED_TXN_RESET;
+		ccid_worker_request(ccid);
+	} else {
+		ccid_slot_excl_maybe_signal(slot);
+	}
+}
+
+static int
+ccid_slot_excl_req(ccid_slot_t *slot, ccid_minor_t *cmp, boolean_t nosleep)
+{
+	ccid_minor_t *check;
+
+	VERIFY(MUTEX_HELD(&slot->cs_ccid->ccid_mutex));
+
+	if (slot->cs_excl_minor == cmp) {
+		VERIFY(cmp->cm_flags & CCID_MINOR_F_HAS_EXCL);
+		return (EEXIST);
+	}
+
+	if (cmp->cm_flags & CCID_MINOR_F_WAITING) {
+		return (EINPROGRESS);
+	}
+
+	/*
+	 * If we were asked to try and fail quickly, do that before the main
+	 * loop.
+	 */
+	if (nosleep && slot->cs_excl_minor != NULL &&
+	    (slot->cs_flags & CCID_SLOT_F_NOEXCL_MASK) == 0) {
+		return (EBUSY);
+	}
+
+	/*
+	 * Mark that we're waiting in case we race with another thread trying to
+	 * claim exclusive access for this. Insert ourselves on the wait list.
+	 * If for some reason we get a signal, then we can't know for certain if
+	 * we had a signal / cv race. In such a case, we always wake up the
+	 * next person in the queue (potentially spuriously).
+	 */
+	cmp->cm_flags |= CCID_MINOR_F_WAITING;
+	list_insert_tail(&slot->cs_excl_waiters, cmp);
+	while (slot->cs_excl_minor != NULL ||
+	    (slot->cs_flags & CCID_SLOT_F_NOEXCL_MASK) != 0) {
+		if (cv_wait_sig(&cmp->cm_excl_cv, &slot->cs_ccid->ccid_mutex) ==
+		    0) {
+			/*
+			 * Remove ourselves from the list, but only signal the
+			 * next thread if 
+			 */
+			list_remove(&slot->cs_excl_waiters, cmp);
+			cmp->cm_flags &= ~CCID_MINOR_F_WAITING;
+			ccid_slot_excl_maybe_signal(slot);
+			return (EINTR);
+		}
+
+		/*
+		 * Check if the reader is going away. If so, then we're done
+		 * here.
+		 */
+		if ((slot->cs_ccid->ccid_flags & CCID_F_DISCONNECTED) != 0) {
+			list_remove(&slot->cs_excl_waiters, cmp);
+			cmp->cm_flags &= ~CCID_MINOR_F_WAITING;
+			return (ENODEV);
+		}
+
+		/* XXX Waiting on a lock, need to reassert usability of device /
+		 * going awayness */
+	}
+
+	VERIFY3P(cmp, ==, list_head(&slot->cs_excl_waiters));
+	VERIFY0(slot->cs_flags & CCID_SLOT_F_NOEXCL_MASK);
+	list_remove(&slot->cs_excl_waiters, cmp);
+
+	cmp->cm_flags &= ~CCID_MINOR_F_WAITING;
+	cmp->cm_flags |= CCID_MINOR_F_HAS_EXCL;
+	slot->cs_excl_minor = cmp;
+	return (0);
+}
+
+/*
+ * Check whether or not we're in a state that we can signal a POLLIN. To be able
+ * to signal a POLLIN (meaning that we can read) the following must be true:
+ *
+ *   o There is a client that has an exclusive hold open
+ *   o There is a data which is readable by the client (an I/O is done).
+ *
+ * Unlike with pollout, we don't care about the state of the ICC.
+ */
+static void
+ccid_slot_pollin_signal(ccid_slot_t *slot)
+{
+	ccid_t *ccid = slot->cs_ccid;
+	ccid_minor_t *cmp;
+
+	VERIFY(MUTEX_HELD(&ccid->ccid_mutex));
+}
+
+/*
+ * Check whether or not we're in a state that we can signal a POLLOUT. To be
+ * able to signal a POLLOUT (meaning that we can write) the following must be
+ * true:
+ *
+ *   o There is a minor which has an exclusive hold on the device 
+ *   o There is no outstanding I/O activity going on, meaning that there is no
+ *     operation in progress and any write data has been consumed.
+ *   o There is an ICC present
+ *   o There is no outstanding I/O cleanup being done, whether a T=1 abort, a
+ *     warm reset, or something else.
+ */
+static void
+ccid_slot_pollout_signal(ccid_slot_t *slot)
+{
+	ccid_t *ccid = slot->cs_ccid;
+	ccid_minor_t *cmp;
+
+	VERIFY(MUTEX_HELD(&ccid->ccid_mutex));
+}
+
+static void
+ccid_slot_io_teardown_done(ccid_slot_t *slot)
+{
+	ccid_t *ccid = slot->cs_ccid;
+
+	VERIFY(MUTEX_HELD(&ccid->ccid_mutex));
+	slot->cs_flags &= ~CCID_SLOT_F_NEED_IO_TEARDOWN;
+	cv_broadcast(&slot->cs_io.ci_cv);
+
+	/*
+	 * XXX Check if we're in a state where we should signal pollout, as we
+	 * might be.
+	 */
+}
+
+/*
+ * XXX This will probably need to change when we start doing TPDU processing.
+ */
+static size_t
+ccid_command_resp_length(ccid_command_t *cc)
+{
+	uint32_t len;
+	const ccid_header_t *cch;
+
+	VERIFY3P(cc, !=, NULL);
+	VERIFY3P(cc->cc_response, !=, NULL);
+
+	/*
+	 * Fetch out an arbitrarily aligned LE uint32_t value from the header.
+	 */
+	cch = (ccid_header_t *)cc->cc_response->b_rptr;
+	bcopy(&cch->ch_length, &len, sizeof (len));
+	len = LE_32(len);
+	return (len);
+}
+
+static uint8_t
+ccid_command_resp_param2(ccid_command_t *cc)
+{
+	uint8_t val;
+	const ccid_header_t *cch;
+
+	VERIFY3P(cc, !=, NULL);
+	VERIFY3P(cc->cc_response, !=, NULL);
+
+	cch = (ccid_header_t *)cc->cc_response->b_rptr;
+	bcopy(&cch->ch_param2, &val, sizeof (val));
+	return (val);
+}
+
+/*
+ * Complete a single command. The way that a command completes depends on the
+ * kind of command that occurs. If this is commad is flagged as a user command,
+ * that implies that it must be handled in a different way from administrative
+ * commands. User commands are placed into the minor to consume via a read(9E).
+ * Non-user commands are placed into a completion queue and must be picked up
+ * via the ccid_command_poll() interface.
+ */
+static void
+ccid_command_complete(ccid_command_t *cc)
+{
+	ccid_t *ccid = cc->cc_ccid;
+
+	VERIFY(MUTEX_HELD(&ccid->ccid_mutex));
+	cc->cc_completion_time = gethrtime();
+	list_remove(&ccid->ccid_command_queue, cc);
+
+	if (cc->cc_flags & CCID_COMMAND_F_USER) {
+		ccid_slot_t *slot;
+
+		slot = &ccid->ccid_slots[cc->cc_slot];
+		/*
+		 * If the user ops vector has been destroyed, free this command.
+		 * There's not much we can do at this point. Otherwise, deliver
+		 * it.
+		 *
+		 * XXX This doesn't make sense
+		 */
+		if (slot->cs_icc.icc_complete == NULL) {
+			ccid_command_free(cc);
+		} else {
+			slot->cs_icc.icc_complete(ccid, slot, cc);
+		}
+	} else {
+		list_insert_tail(&ccid->ccid_complete_queue, cc);
+		cv_broadcast(&cc->cc_cv);
+	}
+
+	/*
+	 * Finally, we also need to kick off the next command.
+	 */
+	ccid_command_dispatch(ccid);
+}
+
+static void
+ccid_command_state_transition(ccid_command_t *cc, ccid_command_state_t state)
+{
+	VERIFY(MUTEX_HELD(&cc->cc_ccid->ccid_mutex));
+
+	cc->cc_state = state;
+	cv_broadcast(&cc->cc_cv);
+}
+
+static void
+ccid_command_transport_error(ccid_command_t *cc, int usb_status, usb_cr_t cr)
+{
+	VERIFY(MUTEX_HELD(&cc->cc_ccid->ccid_mutex));
+
+	ccid_command_state_transition(cc, CCID_COMMAND_TRANSPORT_ERROR);
+	cc->cc_usb = usb_status;
+	cc->cc_usbcr = cr;
+	cc->cc_response = NULL;
+
+	ccid_command_complete(cc);
+}
+
+static void
+ccid_command_status_decode(ccid_command_t *cc, ccid_reply_command_status_t *comp,
+    ccid_reply_icc_status_t *iccp, ccid_command_err_t *errp)
+{
+	ccid_header_t cch;
+	size_t mblen;
+
+	VERIFY3S(cc->cc_state, ==, CCID_COMMAND_COMPLETE);
+	VERIFY3P(cc->cc_response, !=, NULL);
+	mblen = msgsize(cc->cc_response);
+	VERIFY3U(mblen, >=, sizeof (cch));
+
+	bcopy(cc->cc_response->b_rptr, &cch, sizeof (cch));
+	if (comp != NULL) {
+		*comp = CCID_REPLY_STATUS(cch.ch_param0);
+	}
+
+	if (iccp != NULL) { 
+		*iccp = CCID_REPLY_ICC(cch.ch_param0);
+	}
+
+	if (errp != NULL) {
+		*errp = cch.ch_param1;
+	}
+}
+
+static void
+ccid_reply_bulk_cb(usb_pipe_handle_t ph, usb_bulk_req_t *ubrp)
+{
+	size_t mlen;
+	ccid_t *ccid;
+	ccid_header_t cch;
+	ccid_command_t *cc;
+
+	boolean_t header_valid = B_FALSE;
+
+	VERIFY(ubrp->bulk_data != NULL);
+	mlen = msgsize(ubrp->bulk_data);
+	ccid = (ccid_t *)ubrp->bulk_client_private;
+	mutex_enter(&ccid->ccid_mutex);
+
+	/*
+	 * Before we do anything else, we should mark that this Bulk-IN request
+	 * is no longer being dispatched.
+	 */
+	VERIFY3P(ubrp, ==, ccid->ccid_bulkin_dispatched);
+	ccid->ccid_bulkin_dispatched = NULL;
+
+	if ((cc = list_head(&ccid->ccid_command_queue)) == NULL) {
+		/*
+		 * This is certainly an odd case. This means that we got some
+		 * response but there are no entries in the queue. Go ahead and
+		 * free this. We're done here.
+		 */
+		mutex_exit(&ccid->ccid_mutex);
+		usb_free_bulk_req(ubrp);
+		return;
+	}
+
+	if (mlen >= sizeof (ccid_header_t)) {
+		bcopy(ubrp->bulk_data->b_rptr, &cch, sizeof (cch));
+		header_valid = B_TRUE;
+	}
+
+	/*
+	 * If the current command isn't in the replying state, then something is
+	 * clearly wrong and this probably isn't intended for the current
+	 * command. That said, if we have enough bytes, let's check the sequence
+	 * number as that might be indicative of a bug otherwise.
+	 */
+	if (cc->cc_state != CCID_COMMAND_REPLYING) {
+		if (header_valid) {
+			VERIFY3S(cch.ch_seq, !=, cc->cc_seq);
+		}
+		mutex_exit(&ccid->ccid_mutex);
+		usb_free_bulk_req(ubrp);
+		return;
+	}
+
+	/*
+	 * CCID section 6.2.7 says that if we get a short or zero length packet,
+	 * then we need to treat that as though the running command was aborted
+	 * for some reason. However, section 3.1.3 talks about sending zero
+	 * length packets on general principle.  To further complicate things,
+	 * we don't have the sequence number.
+	 *
+	 * If we have an outstanding command still, then we opt to treat the
+	 * zero length packet as an abort.
+	 */
+	if (!header_valid) {
+		ccid_command_state_transition(cc, CCID_COMMAND_CCID_ABORTED);
+		ccid_command_complete(cc);
+		mutex_exit(&ccid->ccid_mutex);
+		usb_free_bulk_req(ubrp);
+		return;
+	}
+
+	/*
+	 * If the sequence number doesn't match the head of the list then we
+	 * should be very suspect of the hardware at this point. At a minimum we
+	 * should fail this command, 
+	 */
+	if (cch.ch_seq != cc->cc_seq) {
+		/*
+		 * XXX we should fail this command in a way to indicate that
+		 * this has happened and figure out how to clean up.
+		 */
+		mutex_exit(&ccid->ccid_mutex);
+		usb_free_bulk_req(ubrp);
+		return;
+	}
+
+	/*
+	 * Check that we have all the bytes that we were told we'd have. If we
+	 * dno't, simulate this as an aborted command. XXX is this the right
+	 * thing to do?
+	 */
+	if (LE_32(cch.ch_length) + sizeof (ccid_header_t) > mlen) {
+		ccid_command_state_transition(cc, CCID_COMMAND_CCID_ABORTED);
+		ccid_command_complete(cc);
+		mutex_exit(&ccid->ccid_mutex);
+		usb_free_bulk_req(ubrp);
+		return;
+	}
+
+	/*
+	 * This response is for us. Before we complete the command check to see
+	 * what the state of the command is. If the command indicates that more
+	 * time has been requested, then we need to schedule a new Bulk-IN
+	 * request.
+	 *
+	 * XXX Should we actually just always honor this and not check the
+	 * message type?
+	 *
+	 * XXX What about checking that the slot makes sense?
+	 *
+	 * XXX What about checking if the thing didn't post us all the bytes
+	 * that it said it would
+	 */
+	if (CCID_REPLY_STATUS(cch.ch_param0) == CCID_REPLY_STATUS_MORE_TIME) {
+		int ret;
+
+		ret = ccid_bulkin_schedule(ccid);
+		if (ret != USB_SUCCESS) {
+			ccid_command_transport_error(cc, ret, USB_CR_OK); 
+		}
+		mutex_exit(&ccid->ccid_mutex);
+		usb_free_bulk_req(ubrp);
+		return;
+	}
+
+	/*
+	 * Take the message block from the Bulk-IN request and store it on the
+	 * command. We wnat this regardless if it succeeded, failed, or we have
+	 * some unexpected status value.
+	 */
+	cc->cc_response = ubrp->bulk_data;
+	ubrp->bulk_data = NULL;
+	ccid_command_state_transition(cc, CCID_COMMAND_COMPLETE);
+	ccid_command_complete(cc);
+	mutex_exit(&ccid->ccid_mutex);
+	usb_free_bulk_req(ubrp);
+}
+
+static void
+ccid_reply_bulk_exc_cb(usb_pipe_handle_t ph, usb_bulk_req_t *ubrp)
+{
+	ccid_t *ccid;
+	ccid_command_t *cc;
+
+	ccid = (ccid_t *)ubrp->bulk_client_private;
+	mutex_enter(&ccid->ccid_mutex);
+
+	/*
+	 * Before we do anything else, we should mark that this Bulk-IN request
+	 * is no longer being dispatched.
+	 */
+	VERIFY3P(ubrp, ==, ccid->ccid_bulkin_dispatched);
+	ccid->ccid_bulkin_dispatched = NULL;
+
+	/*
+	 * While there are many different reasons that the Bulk-IN request could
+	 * have failed, each of these are treated as a transport error. If we
+	 * have a dispatched command, then we treat this as corresponding to
+	 * that command. Otherwise, we drop this.
+	 */
+	if ((cc = list_head(&ccid->ccid_command_queue)) != NULL) {
+		if (cc->cc_state == CCID_COMMAND_REPLYING) {
+			ccid_command_transport_error(cc, USB_SUCCESS,
+			    ubrp->bulk_completion_reason);
+		}
+	}
+	mutex_exit(&ccid->ccid_mutex);
+	usb_free_bulk_req(ubrp);
+}
+
+/*
+ * Fill the Bulk-IN cache. If we do not entirely fill this, that's fine. If
+ * there are no scheduled resources then we'll deal with that when we actually
+ * get there.
+ */
+static void
+ccid_bulkin_cache_refresh(ccid_t *ccid)
+{
+	VERIFY(MUTEX_HELD(&ccid->ccid_mutex));
+	while (ccid->ccid_bulkin_alloced < CCID_BULK_NALLOCED) {
+		usb_bulk_req_t *ubrp;
+
+		ubrp = usb_alloc_bulk_req(ccid->ccid_dip, ccid->ccid_bufsize, 0);
+		if (ubrp == NULL)
+			return;
+
+		ubrp->bulk_len = ccid->ccid_bufsize;
+		ubrp->bulk_timeout = CCID_BULK_IN_TIMEOUT;
+		ubrp->bulk_client_private = (usb_opaque_t)ccid;
+		ubrp->bulk_attributes = USB_ATTRS_SHORT_XFER_OK |
+		    USB_ATTRS_AUTOCLEARING;
+		ubrp->bulk_cb = ccid_reply_bulk_cb;
+		ubrp->bulk_exc_cb = ccid_reply_bulk_exc_cb;
+
+		ccid->ccid_bulkin_cache[ccid->ccid_bulkin_alloced] = ubrp;
+		ccid->ccid_bulkin_alloced++;
+	}
+
+}
+
+static usb_bulk_req_t *
+ccid_bulkin_cache_get(ccid_t *ccid)
+{
+	usb_bulk_req_t *ubrp;
+
+	VERIFY(MUTEX_HELD(&ccid->ccid_mutex));
+
+	if (ccid->ccid_bulkin_alloced == 0) {
+		ccid_bulkin_cache_refresh(ccid);
+		if (ccid->ccid_bulkin_alloced == 0)
+			return (NULL);
+	}
+
+	ccid->ccid_bulkin_alloced--;
+	ubrp = ccid->ccid_bulkin_cache[ccid->ccid_bulkin_alloced];
+	VERIFY3P(ubrp, !=, NULL);
+	ccid->ccid_bulkin_cache[ccid->ccid_bulkin_alloced] = NULL;
+
+	return (ubrp);
+}
+
+/*
+ * Attempt to schedule a Bulk-In request. Note that only one should ever be
+ * scheduled at any time.
+ */
+static int
+ccid_bulkin_schedule(ccid_t *ccid)
+{
+	VERIFY(MUTEX_HELD(&ccid->ccid_mutex));
+	if (ccid->ccid_bulkin_dispatched == NULL) {
+		usb_bulk_req_t *ubrp;
+		int ret;
+
+		ubrp = ccid_bulkin_cache_get(ccid);
+		if (ubrp == NULL) {
+			return (USB_NO_RESOURCES);
+		}
+
+		if ((ret = usb_pipe_bulk_xfer(ccid->ccid_bulkin_pipe, ubrp,
+		    0)) != USB_SUCCESS) {
+			ccid_error(ccid, "failed to schedule Bulk-In response: %d", ret);
+			usb_free_bulk_req(ubrp);
+			return (ret);
+		}
+
+		ccid->ccid_bulkin_dispatched = ubrp;
+	}
+
+	return (USB_SUCCESS);
+}
+
+/*
+ * Make sure that the head of the queue has been dispatched. If a dispatch to
+ * the device fails, fail the command and try the next one.
+ */
+static void
+ccid_command_dispatch(ccid_t *ccid)
+{
+	ccid_command_t *cc;
+
+	VERIFY(MUTEX_HELD(&ccid->ccid_mutex));
+	while ((cc = list_head(&ccid->ccid_command_queue)) != NULL) {
+		int ret;
+
+		if (ccid->ccid_flags & CCID_F_DETACHING)
+			return;
+
+		/*
+		 * Head of the queue is already being processed. We're done
+		 * here.
+		 */
+		if (cc->cc_state > CCID_COMMAND_QUEUED) {
+			return;
+		}
+
+		/*
+		 * Mark the command as being dispatched to the device. This
+		 * prevents anyone else from getting in and confusing things.
+		 */
+		ccid_command_state_transition(cc, CCID_COMMAND_DISPATCHED);
+		cc->cc_dispatch_time = gethrtime();
+
+		/*
+		 * Drop the global lock while we schedule the USB I/O. 
+		 */
+		mutex_exit(&ccid->ccid_mutex);
+
+		ret = usb_pipe_bulk_xfer(ccid->ccid_bulkout_pipe, cc->cc_ubrp,
+		    0);
+		mutex_enter(&ccid->ccid_mutex);
+		if (ret != USB_SUCCESS) {
+			/*
+			 * We don't need to free the usb_bulk_req_t here as it
+			 * will be taken care of when the command itself is
+			 * freed.
+			 */
+			ccid_error(ccid, "Bulk pipe dispatch failed: %d\n", ret);
+			ccid_command_transport_error(cc, ret, USB_CR_OK);
+		}
+	}
+}
+
+static int
+ccid_command_queue(ccid_t *ccid, ccid_command_t *cc)
+{
+	id_t seq;
+	ccid_header_t *cchead;
+
+	seq = id_alloc_nosleep(ccid->ccid_seqs);
+	if (seq == -1)
+		return (ENOMEM);
+	cc->cc_seq = seq;
+	VERIFY3U(seq, <=, UINT8_MAX);
+	cchead = (void *)cc->cc_ubrp->bulk_data->b_rptr;
+	cchead->ch_seq = (uint8_t)seq;
+
+	mutex_enter(&ccid->ccid_mutex);
+	/*
+	 * Take a shot at filling up our reply cache while we're submitting this
+	 * command.
+	 */
+	ccid_bulkin_cache_refresh(ccid);
+	list_insert_tail(&ccid->ccid_command_queue, cc);
+	ccid_command_state_transition(cc, CCID_COMMAND_QUEUED);
+	cc->cc_queue_time = gethrtime();
+	ccid_command_dispatch(ccid);
+	mutex_exit(&ccid->ccid_mutex);
+
+	return (0);
+}
+
+/*
+ * Normal callback for Bulk-Out requests which represents commands issued to the
+ * device.
+ */
+static void
+ccid_dispatch_bulk_cb(usb_pipe_handle_t ph, usb_bulk_req_t *ubrp)
+{
+	int ret;
+	ccid_command_t *cc = (void *)ubrp->bulk_client_private;
+	ccid_t *ccid = cc->cc_ccid;
+
+	mutex_enter(&ccid->ccid_mutex);
+	VERIFY3S(cc->cc_state, ==, CCID_COMMAND_DISPATCHED);
+	ccid_command_state_transition(cc, CCID_COMMAND_REPLYING);
+	cc->cc_dispatch_cb_time = gethrtime();
+
+	/*
+	 * Since we have successfully sent the command, give it a Bulk-In
+	 * response to reply to us with. If that fails, we'll note a transport
+	 * error which will kick off the next command if needed.
+	 */
+	ret = ccid_bulkin_schedule(ccid);
+	if (ret != USB_SUCCESS) {
+		ccid_command_transport_error(cc, ret, USB_CR_OK); 
+	}
+	mutex_exit(&ccid->ccid_mutex);
+}
+
+/*
+ * Exception callback for the Bulk-Out requests which represent commands issued
+ * to the device.
+ */
+static void
+ccid_dispatch_bulk_exc_cb(usb_pipe_handle_t ph, usb_bulk_req_t *ubrp)
+{
+	ccid_command_t *cc = (void *)ubrp->bulk_client_private;
+	ccid_t *ccid = cc->cc_ccid;
+
+	mutex_enter(&ccid->ccid_mutex);
+	ccid_command_transport_error(cc, USB_SUCCESS,
+	    ubrp->bulk_completion_reason);
+	mutex_exit(&ccid->ccid_mutex);
+}
+
+static void
+ccid_command_free(ccid_command_t *cc)
+{
+	VERIFY0(list_link_active(&cc->cc_list_node));
+	VERIFY(cc->cc_state == CCID_COMMAND_ALLOCATED ||
+	    cc->cc_state >= CCID_COMMAND_COMPLETE);
+
+	if (cc->cc_response != NULL) {
+		freemsgchain(cc->cc_response);
+		cc->cc_response = NULL;
+	}
+
+	if (cc->cc_ubrp != NULL) {
+		usb_free_bulk_req(cc->cc_ubrp);
+		cc->cc_ubrp = NULL;
+	}
+
+	if (cc->cc_seq != 0) {
+		id_free(cc->cc_ccid->ccid_seqs, cc->cc_seq);
+		cc->cc_seq = 0;
+	}
+
+	cv_destroy(&cc->cc_cv);
+	kmem_free(cc, sizeof (ccid_command_t));
+}
+
+/*
+ * Copy len bytes of data from buf into the allocated message block.
+ */
+static void
+ccid_command_bcopy(ccid_command_t *cc, const void *buf, size_t len)
+{
+	size_t mlen;
+
+	mlen = msgsize(cc->cc_ubrp->bulk_data);
+	VERIFY3U(mlen + len, >=, len);
+	VERIFY3U(mlen + len, >=, mlen);
+	mlen += len;
+	VERIFY3U(mlen, <=, cc->cc_ubrp->bulk_len);
+
+	bcopy(buf, cc->cc_ubrp->bulk_data->b_wptr, len);
+	cc->cc_ubrp->bulk_data->b_wptr += len;
+}
+
+/*
+ * Allocate a command of a specific size and parameters. This will allocate a
+ * USB bulk transfer that the caller will copy data to.
+ */
+static int
+ccid_command_alloc(ccid_t *ccid, ccid_slot_t *slot, boolean_t block,
+    mblk_t *datamp, size_t datasz, uint8_t mtype, uint8_t param0,
+    uint8_t param1, uint8_t param2, ccid_command_t **ccp)
+{
+	size_t allocsz;
+	int kmflag, usbflag;
+	ccid_command_t *cc;
+	ccid_header_t *cchead;
+
+	switch (mtype) {
+	case CCID_REQUEST_POWER_ON:
+	case CCID_REQUEST_POWER_OFF:
+	case CCID_REQUEST_SLOT_STATUS:
+	case CCID_REQUEST_GET_PARAMS:
+	case CCID_REQUEST_RESET_PARAMS:
+	case CCID_REQUEST_ICC_CLOCK:
+	case CCID_REQUEST_T0APDU:
+	case CCID_REQUEST_MECHANICAL:
+	case CCID_REQEUST_ABORT:
+		if (datasz != 0)
+			return (EINVAL);
+		break;
+	case CCID_REQUEST_TRANSFER_BLOCK:
+	case CCID_REQUEST_ESCAPE:
+	case CCID_REQUEST_SECURE:
+	case CCID_REQUEST_SET_PARAMS:
+	case CCID_REQUEST_DATA_CLOCK:
+		break;
+	default:
+		return (EINVAL);
+	}
+
+	if (block) {
+		kmflag = KM_SLEEP;
+		usbflag = USB_FLAGS_SLEEP;
+	} else {
+		kmflag = KM_NOSLEEP | KM_NORMALPRI;
+		usbflag = 0;
+	}
+
+	if (datasz + sizeof (ccid_header_t) < datasz)
+		return (EINVAL);
+	if (datasz + sizeof (ccid_header_t) > ccid->ccid_bufsize)
+		return (EINVAL);
+
+	cc = kmem_zalloc(sizeof (ccid_command_t), kmflag);
+	if (cc == NULL)
+		return (ENOMEM);
+
+	allocsz = datasz + sizeof (ccid_header_t);
+	if (datamp == NULL) {
+		cc->cc_ubrp = usb_alloc_bulk_req(ccid->ccid_dip, allocsz, usbflag);
+	} else {
+		cc->cc_ubrp = usb_alloc_bulk_req(ccid->ccid_dip, 0, usbflag);
+	}
+	if (cc->cc_ubrp == NULL) {
+		kmem_free(cc, sizeof (ccid_command_t));
+		return (ENOMEM);
+	}
+
+	list_link_init(&cc->cc_list_node);
+	cv_init(&cc->cc_cv, NULL, CV_DRIVER, NULL);
+	cc->cc_mtype = mtype;
+	cc->cc_slot = slot->cs_slotno;
+	cc->cc_reqlen = datasz;
+	cc->cc_ccid = ccid;
+	cc->cc_state = CCID_COMMAND_ALLOCATED;
+
+	/*
+	 * Fill in bulk request attributes. Note that short transfers out
+	 * are not OK.
+	 */
+	if (datamp != NULL) {
+		cc->cc_ubrp->bulk_data = datamp;
+	}
+	cc->cc_ubrp->bulk_len = allocsz;
+	cc->cc_ubrp->bulk_timeout = CCID_BULK_OUT_TIMEOUT;
+	cc->cc_ubrp->bulk_client_private = (usb_opaque_t)cc;
+	cc->cc_ubrp->bulk_attributes = USB_ATTRS_AUTOCLEARING;
+	cc->cc_ubrp->bulk_cb = ccid_dispatch_bulk_cb;
+	cc->cc_ubrp->bulk_exc_cb = ccid_dispatch_bulk_exc_cb;
+
+	/*
+	 * Fill in the command header. We fill in everything except the sequence
+	 * number, which is done by the actual dispatch code.
+	 */
+	cchead = (void *)cc->cc_ubrp->bulk_data->b_rptr;
+	cchead->ch_mtype = mtype;
+	cchead->ch_length = LE_32(datasz);
+	cchead->ch_slot = slot->cs_slotno;
+	cchead->ch_seq = 0;
+	cchead->ch_param0 = param0;
+	cchead->ch_param1 = param1;
+	cchead->ch_param2 = param2;
+	cc->cc_ubrp->bulk_data->b_wptr += sizeof (ccid_header_t);
+	*ccp = cc;
+
+	return (0);
+}
+
+/*
+ * The rest of the stack is in charge of timing out commands and potentially
+ * aborting them. At this point in time, there's no specific timeout aspect
+ * here.
+ */
+static void
+ccid_command_poll(ccid_t *ccid, ccid_command_t *cc)
+{
+	VERIFY0(cc->cc_flags & CCID_COMMAND_F_USER);
+
+	mutex_enter(&ccid->ccid_mutex);
+	while (cc->cc_state < CCID_COMMAND_COMPLETE) {
+		cv_wait(&cc->cc_cv, &ccid->ccid_mutex);
+	}
+
+	/*
+	 * Treat this as a consumption and remove it from the completion list.
+	 */
+#ifdef DEBUG
+	ccid_command_t *check;
+	for (check = list_head(&ccid->ccid_complete_queue); check != NULL;
+	    check = list_next(&ccid->ccid_complete_queue, check)) {
+		if (cc == check)
+			break;
+	}
+	ASSERT3P(check, !=, NULL);
+#endif
+	VERIFY(list_link_active(&cc->cc_list_node));
+	list_remove(&ccid->ccid_complete_queue, cc);
+	mutex_exit(&ccid->ccid_mutex);
+}
+
+static int
+ccid_command_power_off(ccid_t *ccid, ccid_slot_t *cs)
+{
+	int ret;
+	ccid_command_t *cc;
+	ccid_reply_icc_status_t cis;
+	ccid_reply_command_status_t crs;
+
+	if ((ret = ccid_command_alloc(ccid, cs, B_TRUE, NULL, 0,
+	    CCID_REQUEST_POWER_OFF, 0, 0, 0, &cc)) != 0) {
+		return (ret);
+	}
+
+	if ((ret = ccid_command_queue(ccid, cc)) != 0) {
+		ccid_command_free(cc);
+		return (ret);
+	}
+
+	ccid_command_poll(ccid, cc);
+
+	if (cc->cc_state != CCID_COMMAND_COMPLETE) {
+		ret = EIO;
+		goto done;
+	}
+
+	ccid_command_status_decode(cc, &crs, &cis, NULL);
+	if (crs == CCID_REPLY_STATUS_FAILED) {
+		if (cis == CCID_REPLY_ICC_MISSING) {
+			ret = ENXIO;
+		} else {
+			ret = EIO;
+		}
+	} else {
+		ret = 0;
+	}
+done:
+	ccid_command_free(cc);
+	return (ret);
+}
+
+static int
+ccid_command_power_on(ccid_t *ccid, ccid_slot_t *cs, ccid_class_voltage_t volt,
+    mblk_t **atrp)
+{
+	int ret;
+	ccid_command_t *cc;
+	ccid_reply_command_status_t crs;
+	ccid_reply_icc_status_t cis;
+	ccid_command_err_t cce;
+
+	if (atrp == NULL)
+		return (EINVAL);
+
+	*atrp = NULL;
+
+	switch (volt) {
+	case CCID_CLASS_VOLT_AUTO:
+	case CCID_CLASS_VOLT_5_0:
+	case CCID_CLASS_VOLT_3_0:
+	case CCID_CLASS_VOLT_1_8:
+		break;
+	default:
+		return (EINVAL);
+	}
+
+	if ((ret = ccid_command_alloc(ccid, cs, B_TRUE, NULL, 0,
+	    CCID_REQUEST_POWER_ON, volt, 0, 0, &cc)) != 0) {
+		return (ret);
+	}
+
+	if ((ret = ccid_command_queue(ccid, cc)) != 0) {
+		ccid_command_free(cc);
+		return (ret);
+	}
+
+	ccid_command_poll(ccid, cc);
+
+	if (cc->cc_state != CCID_COMMAND_COMPLETE) {
+		ret = EIO;
+		goto done;
+	}
+
+	/*
+	 * XXX Assume slot and message type logic is being done for us. Look for
+	 * a few specific errors here:
+	 *
+	 * - ICC_MUTE via a few potential ways
+	 * - Bad voltage
+	 */
+	ccid_command_status_decode(cc, &crs, &cis, &cce);
+	if (crs == CCID_REPLY_STATUS_FAILED) {
+		if (cis == CCID_REPLY_ICC_MISSING) {
+			ret = ENXIO;
+		} else if (cis == CCID_REPLY_ICC_INACTIVE &&
+		    cce == 7) {
+			/*
+			 * This means that byte 7 was invalid. In other words,
+			 * that the voltage wasn't correct. See Table 6.1-2
+			 * 'Errors' in the CCID r1.1.0 spec.
+			 */
+			ret = ENOTSUP;
+		} else {
+			ret = EIO;
+		}
+	} else {
+		size_t len;
+
+		len = ccid_command_resp_length(cc);
+		if (len == 0) {
+			/*
+			 * XXX Could probably use more descriptive errors and
+			 * not errnos
+			 */
+			ret = EINVAL;
+			goto done;
+		}
+
+#ifdef	DEBUG
+		/*
+		 * This should have already been checked by the response
+		 * framework, but sanity check this again.
+		 */
+		size_t mlen = msgsize(cc->cc_response);
+		VERIFY3U(mlen, >=, len + sizeof (ccid_header_t));
+#endif
+
+		/*
+		 * Munge the message block to have the ATR. We want to make sure
+		 * that the write pointer is set to the maximum length that we
+		 * got back from the driver (the message block could strictly
+		 * speaking be larger, because we got a larger transfer for some
+		 * reason).
+		 */
+		cc->cc_response->b_rptr += sizeof (ccid_header_t);
+		cc->cc_response->b_wptr = cc->cc_response->b_rptr + len;
+		*atrp = cc->cc_response;
+		cc->cc_response = NULL;
+		ret = 0;
+	}
+
+done:
+	ccid_command_free(cc);
+	return (ret);
+}
+
+static int
+ccid_command_get_parameters(ccid_t *ccid, ccid_slot_t *slot,
+    atr_protocol_t *protp, ccid_params_t *paramsp)
+{
+	int ret;
+	uint8_t prot;
+	size_t mlen;
+	ccid_header_t cch;
+	ccid_command_t *cc;
+	ccid_reply_command_status_t crs;
+	ccid_reply_icc_status_t cis;
+	const void *cpbuf;
+
+	if ((ret = ccid_command_alloc(ccid, slot, B_TRUE, NULL, 0,
+	   CCID_REQUEST_GET_PARAMS, 0, 0, 0, &cc)) != 0) {
+		return (ret);
+	}
+
+	if ((ret = ccid_command_queue(ccid, cc)) != 0) {
+		ccid_command_free(cc);
+		return (ret);
+	}
+
+	ccid_command_poll(ccid, cc);
+
+	if (cc->cc_state != CCID_COMMAND_COMPLETE) {
+		ret = EIO;
+		goto done;
+	}
+
+	ccid_command_status_decode(cc, &crs, &cis, NULL);
+	if (crs != CCID_REPLY_STATUS_COMPLETE) {
+		if (cis == CCID_REPLY_ICC_MISSING) {
+			ret = ENXIO;
+		} else {
+			ret = EIO;
+		}
+		goto done;
+	}
+
+	/*
+	 * The protocol is in ch_param2 of the header.
+	 */
+	prot = ccid_command_resp_param2(cc);
+	mlen = ccid_command_resp_length(cc);
+	cpbuf = cc->cc_response->b_rptr + sizeof (ccid_header_t);
+
+	ret = 0;
+	switch (prot) {
+	case 0:
+		if (mlen < sizeof (ccid_params_t0_t)) {
+			ret = EOVERFLOW;
+			goto done;
+		}
+		*protp = ATR_P_T0;
+		bcopy(cpbuf, &paramsp->ccp_t0, sizeof (ccid_params_t0_t));
+		break;
+	case 1:
+		if (mlen < sizeof (ccid_params_t1_t)) {
+			ret = EOVERFLOW;
+			goto done;
+		}
+		*protp = ATR_P_T1;
+		bcopy(cpbuf, &paramsp->ccp_t1, sizeof (ccid_params_t1_t));
+		break;
+	default:
+		ret = ECHRNG;
+		break;
+	}
+
+done:
+	ccid_command_free(cc);
+	return (ret);
+}
+
+static int
+ccid_command_set_parameters(ccid_t *ccid, ccid_slot_t *slot, atr_protocol_t protocol, void *params)
+{
+	int ret;
+	ccid_command_t *cc;
+	uint8_t prot;
+	size_t len;
+	ccid_reply_command_status_t crs;
+	ccid_reply_icc_status_t cis;
+	ccid_command_err_t cce;
+
+	switch (protocol) {
+	case ATR_P_T0:
+		prot = 0;
+		len = sizeof (ccid_params_t0_t);
+		break;
+	case ATR_P_T1:
+		prot = 1;
+		len = sizeof (ccid_params_t1_t);
+		break;
+	default:
+		return (EINVAL);
+	}
+
+	if ((ret = ccid_command_alloc(ccid, slot, B_TRUE, NULL, len,
+	   CCID_REQUEST_SET_PARAMS, prot, 0, 0, &cc)) != 0) {
+		return (ret);
+	}
+	ccid_command_bcopy(cc, params, len);
+	if ((ret = ccid_command_queue(ccid, cc)) != 0) {
+		ccid_command_free(cc);
+		return (ret);
+	}
+
+	ccid_command_poll(ccid, cc);
+
+	if (cc->cc_state != CCID_COMMAND_COMPLETE) {
+		ret = EIO;
+		goto done;
+	}
+
+	ccid_command_status_decode(cc, &crs, &cis, &cce);
+	if (crs != CCID_REPLY_STATUS_COMPLETE) {
+		if (cis == CCID_REPLY_ICC_MISSING) {
+			ret = ENXIO;
+		} else {
+			ccid_error(ccid, "failed to set parameters on slot %u: "
+			    "%u\n", slot->cs_slotno, cce);
+			ret = EIO;
+		}
+	} else {
+		ret = 0;
+	}
+
+done:
+	ccid_command_free(cc);
+	return (ret);
+}
+
+/*
+ * Initiate a polled data transfer. This should not be used for any user I/O,
+ * only for PPS and IFSD transactions while initializing the card. Generally
+ * this is only used for CCID devices that support TPDU.
+ */
+static int
+ccid_command_transfer(ccid_t *ccid, ccid_slot_t *slot, const void *buf,
+    size_t len, mblk_t **outp)
+{
+	int ret;
+	ccid_command_t *cc;
+	uint8_t *datap;
+	ccid_reply_command_status_t crs;
+	ccid_reply_icc_status_t cis;
+	ccid_command_err_t cce;
+
+	if (buf == NULL || len == 0 || outp == NULL)
+		return (EINVAL);
+
+	*outp = NULL;
+	if ((ret = ccid_command_alloc(ccid, slot, B_TRUE, NULL, len,
+	   CCID_REQUEST_TRANSFER_BLOCK, 0, 0, 0, &cc)) != 0) {
+		return (ret);
+	}
+
+	ccid_command_bcopy(cc, buf, len);
+
+	if ((ret = ccid_command_queue(ccid, cc)) != 0) {
+		ccid_command_free(cc);
+		return (ret);
+	}
+
+	ccid_command_poll(ccid, cc);
+
+	if (cc->cc_state != CCID_COMMAND_COMPLETE) {
+		ret = EIO;
+		goto done;
+	}
+
+	ccid_command_status_decode(cc, &crs, &cis, &cce);
+	if (crs == CCID_REPLY_STATUS_COMPLETE) {
+		mblk_t *mp;
+
+		/* Take ownership of the data from the command */
+		mp = cc->cc_response;
+		cc->cc_response = NULL;
+		mp->b_rptr += sizeof (ccid_header_t);
+		*outp = mp;
+		ret = 0;
+	} else {
+		if (cis == CCID_REPLY_ICC_MISSING) {
+			ret = ENXIO;
+		} else {
+			ret = EIO;
+		}
+	}
+
+done:
+	ccid_command_free(cc);
+	return (ret);
+}
+
+static void
+ccid_intr_pipe_cb(usb_pipe_handle_t ph, usb_intr_req_t *uirp)
+{
+	mblk_t *mp;
+	size_t msglen, explen;
+	uint_t i;
+	boolean_t change;
+	ccid_t *ccid = (ccid_t *)uirp->intr_client_private;
+
+	mp = uirp->intr_data;
+	if (mp == NULL)
+		goto done;
+
+	msglen = msgsize(mp);
+	if (msglen == 0)
+		goto done;
+
+	switch (mp->b_rptr[0]) {
+	case CCID_INTR_CODE_SLOT_CHANGE:
+		mutex_enter(&ccid->ccid_mutex);
+		ccid->ccid_stats.cst_intr_slot_change++;
+
+		explen = 1 + ((2 * ccid->ccid_nslots + (NBBY-1)) / NBBY);
+		if (msglen < explen) {
+			ccid->ccid_stats.cst_intr_inval++;
+			mutex_exit(&ccid->ccid_mutex);
+			goto done;
+		}
+
+		change = B_FALSE;
+		for (i = 0; i < ccid->ccid_nslots; i++) {
+			uint_t byte = (i * 2 / NBBY) + 1;
+			uint_t shift = i * 2 % NBBY;
+			uint_t present = 1 << shift;
+			uint_t delta = 2 << shift;
+
+			if (mp->b_rptr[byte] & delta) {
+				ccid_slot_t *slot = &ccid->ccid_slots[i];
+
+				slot->cs_flags &= ~CCID_SLOT_F_INTR_MASK;
+				slot->cs_flags |= CCID_SLOT_F_CHANGED;
+				if (mp->b_rptr[byte] & present) {
+					slot->cs_flags |= CCID_SLOT_F_INTR_ADD;
+				} else {
+					slot->cs_flags |= CCID_SLOT_F_INTR_GONE;
+				}
+				change = B_TRUE;
+			}
+		}
+
+		if (change) {
+			ccid_worker_request(ccid);
+		}
+		mutex_exit(&ccid->ccid_mutex);
+		break;
+	case CCID_INTR_CODE_HW_ERROR:
+		mutex_enter(&ccid->ccid_mutex);
+		ccid->ccid_stats.cst_intr_hwerr++;
+
+		if (msglen < sizeof (ccid_intr_hwerr_t)) {
+			ccid->ccid_stats.cst_intr_inval++;
+			mutex_exit(&ccid->ccid_mutex);
+			goto done;
+		}
+
+		/* XXX what should we do with this? */
+		mutex_exit(&ccid->ccid_mutex);
+		break;
+	default:
+		mutex_enter(&ccid->ccid_mutex);
+		ccid->ccid_stats.cst_intr_unknown++;
+		mutex_exit(&ccid->ccid_mutex);
+		break;
+	}
+
+done:
+	usb_free_intr_req(uirp);
+}
+
+static void
+ccid_intr_pipe_except_cb(usb_pipe_handle_t ph, usb_intr_req_t *uirp)
+{
+	ccid_t *ccid = (ccid_t *)uirp->intr_client_private;
+
+	ccid->ccid_stats.cst_intr_errs++;
+	switch (uirp->intr_completion_reason) {
+	case USB_CR_PIPE_RESET:
+	case USB_CR_NO_RESOURCES:
+		ccid->ccid_stats.cst_intr_restart++;
+		ccid_intr_poll_init(ccid);
+		break;
+	default:
+		break;
+	}
+	usb_free_intr_req(uirp);
+}
+
+/*
+ * Clean up all the state associated with this slot and its ICC.
+ */
+static void
+ccid_slot_teardown(ccid_t *ccid, ccid_slot_t *slot, boolean_t signal)
+{
+	VERIFY(MUTEX_HELD(&ccid->ccid_mutex));
+
+	if (slot->cs_icc.icc_fini != NULL) {
+		slot->cs_icc.icc_fini(ccid, slot);
+	}
+
+	atr_data_reset(slot->cs_icc.icc_atr_data);
+	slot->cs_icc.icc_protocols = ATR_P_NONE;
+	slot->cs_icc.icc_cur_protocol = ATR_P_NONE;
+	slot->cs_icc.icc_init = NULL;
+	slot->cs_icc.icc_tx = NULL;
+	slot->cs_icc.icc_complete = NULL;
+	slot->cs_icc.icc_teardown = NULL;
+	slot->cs_icc.icc_fini = NULL;
+
+	slot->cs_voltage = 0;
+	freemsgchain(slot->cs_atr);
+	slot->cs_atr = NULL;
+
+	if (signal && slot->cs_excl_minor != NULL) {
+		pollwakeup(&slot->cs_excl_minor->cm_pollhead, POLLHUP);
+	}
+}
+
+/*
+ * The given CCID slot has been removed. Clean up.
+ */
+static void
+ccid_slot_removed(ccid_t *ccid, ccid_slot_t *slot, boolean_t notify)
+{
+	VERIFY(MUTEX_HELD(&ccid->ccid_mutex));
+	if ((slot->cs_flags & CCID_SLOT_F_PRESENT) == 0) {
+		VERIFY0(slot->cs_flags & CCID_SLOT_F_ACTIVE);
+		return;
+	}
+
+	/*
+	 * This slot is gone, mark the flags accordingly.
+	 */
+	slot->cs_flags &= ~CCID_SLOT_F_PRESENT;
+	slot->cs_flags &= ~CCID_SLOT_F_ACTIVE;
+
+	/*
+	 * If there is outstanding user I/O, then we need to go ahead and take
+	 * care of that. Once this function returns, the user I/O will have been
+	 * dealt with; however, before we can tear down things, we need to make
+	 * sure that the logical I/O has been completed.
+	 */
+	if (slot->cs_icc.icc_teardown != NULL) {
+		slot->cs_icc.icc_teardown(ccid, slot, ENXIO);
+	}
+
+	while ((slot->cs_flags & CCID_SLOT_F_NEED_IO_TEARDOWN) != 0) {
+		cv_wait(&slot->cs_io.ci_cv, &ccid->ccid_mutex);
+	}
+
+	/*
+	 * Now that we've finished completely waiting for the logical I/O to be
+	 * torn down, it's safe for us to proceed with the rest of the needed
+	 * tear down.
+	 */
+	ccid_slot_teardown(ccid, slot, B_TRUE);
+}
+
+static boolean_t
+ccid_slot_send_pps(ccid_t *ccid, ccid_slot_t *slot, atr_data_t *data,
+    uint8_t *fi, uint8_t *di, atr_protocol_t prot)
+{
+	mblk_t *mp;
+	uint_t len;
+	boolean_t changefi;
+	int ret;
+	uint8_t pps[PPS_BUFFER_MAX];
+
+	if (fi == NULL && di == NULL) {
+		len = atr_pps_generate(pps, sizeof (pps), prot, B_FALSE, 0, 0,
+		    B_FALSE, 0);
+	} else if (fi != NULL && di != NULL) {
+		len = atr_pps_generate(pps, sizeof (pps), prot, B_TRUE, *fi,
+		    *di, B_FALSE, 0);
+	} else {
+		return (B_FALSE);
+	}
+
+	if (len == 0) {
+		ccid_error(ccid, "!failed to generate pps data");
+		return (B_FALSE);
+	}
+
+	if ((ret = ccid_command_transfer(ccid, slot, pps, len, &mp)) != 0) {
+		ccid_error(ccid, "!failed to perform PPS exchange: %d", ret);
+		return (B_FALSE);
+	}
+
+	if (!atr_pps_valid(pps, sizeof (pps), mp->b_rptr, msgsize(mp))) {
+		ccid_error(ccid, "!PPS reply was invalid\n");
+		return (B_FALSE);
+	}
+
+	/*
+	 * If the proposed Fi/Di values that we sent in the PPS were not
+	 * accepted, then we need to use the default index values.
+	 */
+	if (!atr_pps_fidi_accepted(mp->b_rptr, msgsize(mp))) {
+		*fi = atr_fi_default_index();
+		*di = atr_di_default_index();
+	}
+
+	return (B_TRUE);
+}
+
+static boolean_t
+ccid_slot_params_t0_init(ccid_t *ccid, ccid_slot_t *slot, atr_data_t *data,
+    uint8_t fi, uint8_t di)
+{
+	int ret;
+	ccid_params_t0_t p;
+	atr_convention_t conv;
+	atr_clock_stop_t stop;
+
+	bzero(&p, sizeof (p));
+	conv = atr_convention(data);
+	/* XXX Macroify */
+	p.cp0_bmFindexDindex = ((fi & 0x0f) << 4) | (di & 0x0f);
+	/* B0 is set t0 0 for T=0 */
+	p.cp0_bmTCCKST0 = 0;
+	if (conv == ATR_CONVENTION_INVERSE) {
+		p.cp0_bmTCCKST0 |= CCID_P_TCCKST0_INVERSE;
+	} else {
+		p.cp0_bmTCCKST0 |= CCID_P_TCCKST0_DIRECT;
+	}
+	p.cp0_bGuardTimeT0 = atr_extra_guardtime(data);
+	p.cp0_bWaitingIntegerT0 = atr_t0_wi(data);
+	p.cp0_bClockStop = atr_clock_stop(data);
+
+	if ((ret = ccid_command_set_parameters(ccid, slot, ATR_P_T0,
+	    &p)) != 0) {
+		ccid_error(ccid, "failed to set T=0 params on slot %u: %d",
+		    slot->cs_slotno, ret);
+		return (B_FALSE);
+	}
+
+	return (B_TRUE);
+}
+
+static boolean_t
+ccid_slot_params_t1_init(ccid_t *ccid, ccid_slot_t *slot, atr_data_t *data,
+    uint8_t fi, uint8_t di)
+{
+	int ret;
+	uint8_t bwi, cwi;
+	ccid_params_t1_t p;
+	atr_convention_t conv;
+	atr_t1_checksum_t cksum;
+
+	bzero(&p, sizeof (p));
+	/* XXX Macroify */
+	conv = atr_convention(data);
+	cksum = atr_t1_checksum(data);
+	bwi = atr_t1_bwi(data);
+	cwi = atr_t1_cwi(data);
+	p.cp1_bmFindexDindex = ((fi & 0x0f) << 4) | (di & 0x0f);
+	p.cp1_bmTCCKST1 = 0x10;
+	if (cksum == ATR_T1_CHECKSUM_CRC) {
+		p.cp1_bmTCCKST1 |= 0x1;
+	}
+	if (conv == ATR_CONVENTION_INVERSE) {
+		p.cp1_bmTCCKST1 |= 0x02;
+	}
+	p.cp1_bGuardTimeT1 = atr_extra_guardtime(data);
+	p.cp1_bmWaitingIntegersT1 = ((bwi & 0x0f) << 4) | (cwi & 0x0f);
+	p.cp1_bClockStop = atr_clock_stop(data);
+	p.cp1_bIFSC = atr_t1_ifsc(data);
+
+	/*
+	 * We always set NAD to zero. NAD is used as a way to multiplex logical
+	 * connections in T=1. However, we only ever have a single writer so
+	 * this functionality is not useful. In addition, several readers don't
+	 * support non-zero NAD values.
+	 */
+	p.cp1_bNadValue = 0;
+
+	if ((ret = ccid_command_set_parameters(ccid, slot, ATR_P_T1,
+	    &p)) != 0) {
+		ccid_error(ccid, "failed to set T=1 params on slot %u: %d",
+		    slot->cs_slotno, ret);
+		return (B_FALSE);
+	}
+
+	return (B_TRUE);
+}
+
+static boolean_t
+ccid_slot_t1_ifsd(ccid_t *ccid, ccid_slot_t *slot)
+{
+	const void *buf;
+	size_t len;
+	mblk_t *mp;
+	int ret;
+	t1_validate_t t1v;
+
+	t1_ifsd(&slot->cs_io.ci_t1, ccid->ccid_class.ccd_dwMaxIFSD, &buf, &len);
+
+	if ((ret = ccid_command_transfer(ccid, slot, buf, len, &mp)) != 0) {
+		ccid_error(ccid, "!failed to perform IFSD exchange: %d", ret);
+		return (B_FALSE);
+	}
+
+	t1v = t1_ifsd_resp(&slot->cs_io.ci_t1, mp->b_rptr, MBLKL(mp));
+	freemsg(mp);
+	if (t1v != T1_VALIDATE_OK) {
+		ccid_error(ccid, "received invalid t1 response (%u): %s", t1v,
+		    t1_errmsg(&slot->cs_io.ci_t1));
+		return (B_FALSE);
+	}
+
+	return (B_TRUE);
+}
+
+static void
+ccid_slot_setup_functions(ccid_t *ccid, ccid_slot_t *slot)
+{
+	uint_t bits = CCID_CLASS_F_TPDU_XCHG | CCID_CLASS_F_SHORT_APDU_XCHG |
+	    CCID_CLASS_F_EXT_APDU_XCHG;
+	switch (ccid->ccid_class.ccd_dwFeatures & bits) {
+	case CCID_CLASS_F_SHORT_APDU_XCHG:
+	case CCID_CLASS_F_EXT_APDU_XCHG:
+		slot->cs_icc.icc_init = NULL;
+		slot->cs_icc.icc_tx = ccid_write_apdu;
+		slot->cs_icc.icc_complete = ccid_complete_apdu;
+		slot->cs_icc.icc_teardown = ccid_teardown_apdu;
+		slot->cs_icc.icc_fini = NULL;
+		break;
+	case CCID_CLASS_F_TPDU_XCHG:
+		switch (slot->cs_icc.icc_cur_protocol) {
+		case ATR_P_T1:
+			/*
+			 * At this time, we don't support the use of the CRC
+			 * checksum for CCID devices. This is mostly because we
+			 * haven't found any ICC devices that support its use.
+			 * As such, if for some reason the parameters indicate
+			 * that we're using T=1 and that we've specified the CRC
+			 * versus LRC, we need to regretfully note that we can't
+			 * perform I/O.
+			 */
+			if (atr_t1_checksum(slot->cs_icc.icc_atr_data) ==
+			    ATR_T1_CHECKSUM_CRC) {
+				ccid_error(ccid, "!ICC uses unsupported T=1 CRC "
+				    "checksum. Please report this so support "
+				    "can be added");
+				slot->cs_icc.icc_tx = NULL;
+				slot->cs_icc.icc_complete = NULL;
+				slot->cs_icc.icc_teardown = NULL;
+				break;
+			}
+
+			slot->cs_icc.icc_init = ccid_init_tpdu_t1;
+			slot->cs_icc.icc_tx = ccid_write_tpdu_t1;
+			slot->cs_icc.icc_complete = ccid_complete_tpdu_t1;
+			slot->cs_icc.icc_teardown = ccid_teardown_tpdu_t1;
+			slot->cs_icc.icc_fini = ccid_fini_tpdu_t1;
+			break;
+		case ATR_P_T0:
+		default:
+			slot->cs_icc.icc_tx = NULL;
+			slot->cs_icc.icc_complete = NULL;
+			slot->cs_icc.icc_teardown = NULL;
+			break;
+		}
+		break;
+	default:
+		slot->cs_icc.icc_tx = NULL;
+		slot->cs_icc.icc_complete = NULL;
+		slot->cs_icc.icc_teardown = NULL;
+	}
+
+	/*
+	 * When we don't have a supported tx function, we don't want to end
+	 * up blocking attach. It's important we attach so that users can try
+	 * and determine information about the ICC and reader.
+	 */
+	if (slot->cs_icc.icc_tx == NULL) {
+		ccid_error(ccid, "CCID does not support I/O transfers to ICC");
+	}
+}
+
+/*
+ * We have an ICC present in a slot. Before we can send commands to it, we
+ * initialize the slot in some form or fashion. The steps that we must take
+ * depend on the features that the card presents. To prepare the slot we must
+ * make sure the following are set:
+ *
+ * - Negotiate and send the PPS (CCID_F_NEEDS_PPS)
+ * - Set the CCID reader's parameters (CCID_F_NEEDS_PARAMS)
+ * - Set the CCID reader's clock and data rate (CCID_F_NEEDS_DATAFREQ)
+ * - Snapshot the current paramters being used for userland
+ * - Set the IFSD for T=1 (CCID_F_NEEDS_IFSD)
+ */
+static boolean_t
+ccid_slot_params_init(ccid_t *ccid, ccid_slot_t *slot, mblk_t *atr)
+{
+	int ret;
+	boolean_t neg;
+	atr_parsecode_t p;
+	atr_protocol_t sup, def, prot, usable;
+	atr_data_t *data;
+
+	/*
+	 * Hardware handles all initialization features. There's nothing else
+	 * that we need to do for now.
+	 */
+	if ((ccid->ccid_flags & CCID_F_ICC_INIT_MASK) == 0)
+		return (B_TRUE);
+
+	/*
+	 * Use the slot's atr data structure. This is only used when we're in
+	 * the worker context, so it should be safe to access in a lockless
+	 * fashion.
+	 */
+	data = slot->cs_icc.icc_atr_data;
+	atr_data_reset(data);
+	if ((p = atr_parse(atr->b_rptr, msgsize(atr), data)) != ATR_CODE_OK) {
+		ccid_error(ccid, "!failed to parse ATR data from slot %d: %s",
+		    slot->cs_slotno, atr_strerror(p));
+		return (B_FALSE);
+	}
+
+	/*
+	 * Snapshot the supported and default protocols. Snapshot whether we can
+	 * negotiate this or not.
+	 */
+	def = atr_default_protocol(data);
+	sup = atr_supported_protocols(data);
+	neg = atr_params_negotiable(data);
+	usable = sup & ccid->ccid_class.ccd_dwProtocols;
+
+	/*
+	 * We need to check if the reader supports the protocols supported by
+	 * the ICC. If it does not, then we cannot use this ICC. If the reader
+	 * uses an APDU mode, then we do not enforce this restriction. This is
+	 * because some NFC readers that support APDU end up lying about the
+	 * protocols supported and the ATRs.
+	 */
+	if ((ccid->ccid_class.ccd_dwFeatures & (CCID_CLASS_F_SHORT_APDU_XCHG |
+	    CCID_CLASS_F_EXT_APDU_XCHG)) == 0 && usable == 0) {
+		ccid_error(ccid, "!reader and ICC do not support common "
+		    "protocols, reader 0x%x, ICC 0x%x\n",
+		    ccid->ccid_class.ccd_dwProtocols, sup);
+		return (B_FALSE);
+	}
+
+	/*
+	 * If we need to send a PPS or we need to send parameters to the ICC,
+	 * then we must go through and determine what the values we're sending
+	 * should be.
+	 *
+	 * If the card has automatic parameter negotiation according to various
+	 * specifications, then we don't bother trying to change the protocol
+	 * and thus we don't enter this if block.
+	 *
+	 * If we need to manually set the data and frequency, see if the ATR
+	 * logic allows us to. If not, then there's nothing that we can really
+	 * do.
+	 */
+	if ((ccid->ccid_flags & (CCID_F_NEEDS_PPS | CCID_F_NEEDS_PARAMS |
+	    CCID_F_NEEDS_DATAFREQ)) != 0) {
+		atr_data_rate_choice_t rate;
+		uint8_t fi, di;
+		boolean_t changeprot;
+
+		/*
+		 * In the future, here is where we should gather and use the
+		 * discrete data rate and clocks and make sure that we have them
+		 * (or have already done so when we first loaded the reader).
+		 */
+		if ((ccid->ccid_flags & CCID_F_NEEDS_DATAFREQ) != 0 &&
+		    (ccid->ccid_class.ccd_bNumClockSupported != 0 ||
+		    ccid->ccid_class.ccd_bNumDataRatesSupported != 0)) {
+			ccid_error(ccid, "!fetching discrete clocks and data "
+			    "rates is not supported, reader will be limited to "
+			    "the default clock and data rate");
+		}
+
+		rate = atr_data_rate(data, &ccid->ccid_class, NULL, 0, NULL);
+		switch (rate) {
+		case ATR_RATE_UNSUPPORTED:
+			ccid_error(ccid, "!cannot use Fi/Di (%u/%u) values "
+			    "for ICC", fi, di);
+			return (B_FALSE);
+		case ATR_RATE_USEDEFAULT:
+			fi = atr_fi_default_index();
+			di = atr_fi_default_index();
+			break;
+		case ATR_RATE_USEATR:
+			fi = atr_fi_index(data);
+			di = atr_di_index(data);
+			break;
+		case ATR_RATE_USEATR_SETRATE:
+			/*
+			 * This case covers the times when CCID_F_NEEDS_DATAFREQ
+			 * is set and we'd need to gather those.
+			 */
+			ccid_error(ccid, "!ccid driver does not support "
+			    "manual data rate setting for ICC, cannot activate");
+			return (B_FALSE);
+		default:
+			ccid_error(ccid, "!unsupported data rate choice: %u",
+			    rate);
+			return (B_FALSE);
+		}
+
+		/*
+		 * Determine what protocol we're going to negotiate or use to
+		 * set parameters. Prefer T=1 if present. If not negotiable, use
+		 * the default. Keep in mind, we have to consider which
+		 * protocols the CCID reader supports as well.
+		 */
+		if (neg) {
+			if (usable & ATR_P_T1)
+				prot = ATR_P_T1;
+			else
+				prot = ATR_P_T0;
+		} else {
+			prot = def;
+			if ((def & usable) == 0) {
+				ccid_error(ccid, "!ICC does not support "
+				    "negotiation and default protocol (0x%x) "
+				    "is not supported by the reader", def);
+				return (B_FALSE);
+			}
+		}
+
+		changeprot = prot != def;
+
+		/*
+		 * Determine whether or not we need to send a PPS. We need to if
+		 * we're going to change the protocol, if we need to change the
+		 * Di/Fi values or we need to change the protocol, and if the
+		 * hardware requires that we perform all this work. If we're
+		 * sending a PPS, we do not have to send a new value of Fi and
+		 * Di, but we must send a protocol.
+		 */
+		if ((ccid->ccid_flags & CCID_F_NEEDS_PPS) != 0 && neg &&
+		    (changeprot || rate != ATR_RATE_USEDEFAULT)) {
+			uint8_t *fip, *dip;
+
+			if (rate != ATR_RATE_USEDEFAULT) {
+				fip = &fi;
+				dip = &di;
+			} else {
+				fip = dip = NULL;
+			}
+			ccid_slot_send_pps(ccid, slot, data, fip, dip, prot);
+		}
+
+		/*
+		 * Now that we've (potentially) sent a PPS which has changed our
+		 * parameters, we need to move on and send a CCID_SET_PARAMETERS
+		 * command to make sure that the reader honors these.
+		 */
+		if ((ccid->ccid_flags & CCID_F_NEEDS_PARAMS) != 0) {
+			if (prot == ATR_P_T0) {
+				if (!ccid_slot_params_t0_init(ccid, slot, data,
+				    fi, di)) {
+					ccid_error(ccid, "!failed to send T=0 "
+					    "paramters to device");
+				}
+			} else if (prot == ATR_P_T1) {
+				if (!ccid_slot_params_t1_init(ccid, slot, data,
+				    fi, di)) {
+					ccid_error(ccid, "!failed to send T=1 "
+					    "paramters to device");
+				}
+			}
+		}
+	}
+
+	if ((ret = ccid_command_get_parameters(ccid, slot, &prot,
+	    &slot->cs_icc.icc_params)) != 0) {
+		ccid_error(ccid, "failed to get parameters for slot %u: %d",
+		    slot->cs_slotno, ret);
+		return (B_FALSE);
+	}
+
+	/*
+	 * Now that we have the parameters locked in. Set up the ICC function
+	 * parameters and initialize the ICC engine.
+	 */
+	slot->cs_icc.icc_protocols = sup;
+	slot->cs_icc.icc_cur_protocol = prot;
+
+	ccid_slot_setup_functions(ccid, slot);
+
+	if (slot->cs_icc.icc_init != NULL) {
+		slot->cs_icc.icc_init(ccid, slot);
+	}
+
+	/*
+	 * If we're using the T=1 protocol and operating at a TPDU level, then
+	 * we need to initialize the state machine and potentially set the IFSD.
+	 *
+	 * If the reader is using APDU exchanges with the ICC then we don't
+	 * bother trying to set the IFSD as we don't want to get in the way of
+	 * any operations it is taking.
+	 */
+	if (prot == ATR_P_T1 &&
+	    (ccid->ccid_class.ccd_dwFeatures & (CCID_CLASS_F_SHORT_APDU_XCHG |
+	    CCID_CLASS_F_EXT_APDU_XCHG)) == 0) {
+
+		/*
+		 * While it is strictly possible to drive on in the face of an
+		 * IFSD negotiation failure, that likely means that something
+		 * else is wrong and that we are better off failing to
+		 * initialize this reader.
+		 */
+		if ((ccid->ccid_flags & CCID_F_NEEDS_IFSD) != 0) {
+			if (!ccid_slot_t1_ifsd(ccid, slot)) {
+				ccid_error(ccid, "failed to initialize IFSD");
+				return (B_FALSE);
+			}
+		}
+	}
+
+	return (B_TRUE);
+}
+
+
+static void
+ccid_slot_inserted(ccid_t *ccid, ccid_slot_t *slot)
+{
+	uint_t nvolts = 4;
+	uint_t cvolt = 0;
+	mblk_t *atr = NULL;
+	ccid_class_voltage_t volts[4] = { CCID_CLASS_VOLT_AUTO,
+	    CCID_CLASS_VOLT_5_0, CCID_CLASS_VOLT_3_0, CCID_CLASS_VOLT_1_8 };
+
+	VERIFY(MUTEX_HELD(&ccid->ccid_mutex));
+	if ((slot->cs_flags & CCID_SLOT_F_ACTIVE) != 0) {
+		return;
+	}
+
+	slot->cs_flags |= CCID_SLOT_F_PRESENT;
+	mutex_exit(&ccid->ccid_mutex);
+
+	/*
+	 * Now, we need to activate this ccid device before we can do anything
+	 * with it. First, power on the device. There are two hardware features
+	 * which may be at play. There may be automatic voltage detection and
+	 * automatic activation on insertion. In theory, when either of those
+	 * are present, we should always try to use the auto voltage.
+	 *
+	 * What's less clear in the specification is if the Auto-Voltage
+	 * property is present is if we should try manual voltages or not. For
+	 * the moment we do.
+	 *
+	 * Also, don't forget to drop the lock while performing this I/O.
+	 * Nothing else should be able to access the ICC yet, as there is no
+	 * minor node present.
+	 */
+	if ((ccid->ccid_class.ccd_dwFeatures &
+	    (CCID_CLASS_F_AUTO_ICC_ACTIVATE | CCID_CLASS_F_AUTO_ICC_VOLTAGE)) ==
+	    0) {
+		/* Skip auto-voltage */
+		cvolt++;
+	}
+
+	for (; cvolt < nvolts; cvolt++) {
+		int ret;
+
+		if (volts[cvolt] != CCID_CLASS_VOLT_AUTO &&
+		    (ccid->ccid_class.ccd_bVoltageSupport & volts[cvolt]) ==
+		    0) {
+			continue;
+		}
+
+		if ((ret = ccid_command_power_on(ccid, slot, volts[cvolt],
+		    &atr)) != 0) {
+			freemsg(atr);
+			atr = NULL;
+
+			/*
+			 * If we got ENXIO, then we know that there is no CCID
+			 * present. This could happen for a number of reasons.
+			 * For example, we could have just started up and no
+			 * card was plugged in (we default to assuming that one
+			 * is). Also, some readers won't really tell us that
+			 * nothing is there until after the power on fails,
+			 * hence why we don't bother with doing a status check
+			 * and just try to power on.
+			 */
+			if (ret == ENXIO) {
+				mutex_enter(&ccid->ccid_mutex);
+				slot->cs_flags &= ~CCID_SLOT_F_PRESENT;
+				return;
+			}
+
+			/*
+			 * If we fail to power off the card, check to make sure
+			 * it hasn't been removed.
+			 */
+			ret = ccid_command_power_off(ccid, slot);
+			if (ret == ENXIO) {
+				mutex_enter(&ccid->ccid_mutex);
+				slot->cs_flags &= ~CCID_SLOT_F_PRESENT;
+				return;
+			}
+			continue;
+		}
+
+		break;
+	}
+
+	if (cvolt >= nvolts) {
+		ccid_error(ccid, "!failed to activate and power on ICC, no "
+		    "supported voltages found");
+		freemsg(atr);
+		mutex_enter(&ccid->ccid_mutex);
+		return;
+	}
+
+	if (!ccid_slot_params_init(ccid, slot, atr)) {
+		ccid_error(ccid, "!failed to set slot paramters for ICC");
+		freemsg(atr);
+		mutex_enter(&ccid->ccid_mutex);
+		ccid_slot_teardown(ccid, slot, B_FALSE);
+		return;
+	}
+
+	mutex_enter(&ccid->ccid_mutex);
+
+	slot->cs_voltage = volts[cvolt];
+	slot->cs_atr = atr;
+	slot->cs_flags |= CCID_SLOT_F_ACTIVE;
+}
+
+static boolean_t
+ccid_slot_reset(ccid_t *ccid, ccid_slot_t *slot)
+{
+	int ret;
+
+	VERIFY(MUTEX_HELD(&ccid->ccid_mutex));
+	VERIFY(ccid->ccid_flags & CCID_SLOT_F_NEED_TXN_RESET);
+	VERIFY(ccid->ccid_flags & CCID_F_WORKER_RUNNING);
+
+	/*
+	 * If there is outstanding user I/O, then we need to go ahead and take
+	 * care of that. Once this function returns, the user I/O will have been
+	 * dealt with; however, before we can tear down things, we need to make
+	 * sure that the logical I/O has been completed.
+	 */
+	if (slot->cs_icc.icc_teardown != NULL) {
+		slot->cs_icc.icc_teardown(ccid, slot, ENXIO);
+	}
+
+	while ((slot->cs_flags & CCID_SLOT_F_NEED_IO_TEARDOWN) != 0) {
+		cv_wait(&slot->cs_io.ci_cv, &ccid->ccid_mutex);
+	}
+
+	/*
+	 * Now that we've finished this, try and power off the ICC.
+	 */
+	mutex_exit(&ccid->ccid_mutex);
+	ret = ccid_command_power_off(ccid, slot);
+	mutex_enter(&ccid->ccid_mutex);
+
+	/*
+	 * If we failed to power off the ICC because the ICC is removed, then
+	 * just return that we failed, so that we can let the next lap clean
+	 * things up by noting that the ICC has been removed.
+	 */
+	if (ret != 0 && ret == ENXIO) {
+		return (B_FALSE);
+	}
+
+	if (ret != 0) {
+		ccid_error(ccid, "failed to reset slot %d for next txn: %d; "
+		    "taking another lap", ret);
+		return (B_FALSE);
+	}
+
+	ccid->ccid_flags &= ~CCID_SLOT_F_ACTIVE;
+
+	ccid_slot_teardown(ccid, slot, B_TRUE);
+	mutex_exit(&ccid->ccid_mutex);
+
+	/*
+	 * Mimic a slot insertion to power this back on. Don't worry about
+	 * success or failure, because as far as we care for resetting it, we've
+	 * done our duty once we've powered it off successfully.
+	 */
+	(void) ccid_slot_inserted(ccid, slot);
+	mutex_enter(&ccid->ccid_mutex);
+
+	return (B_TRUE);
+}
+
+/*
+ * We've been asked to perform some amount of work on the various slots that we
+ * have. This may be because the slot needs to be reset due to the completion of
+ * a transaction or it may be because an ICC inside of the slot has been
+ * removed.
+ */
+static void
+ccid_worker(void *arg)
+{
+	uint_t i;
+	ccid_t *ccid = arg;
+
+	mutex_enter(&ccid->ccid_mutex);
+	ccid->ccid_stats.cst_ndiscover++;
+	ccid->ccid_stats.cst_lastdiscover = gethrtime();
+	if (ccid->ccid_flags & CCID_F_DETACHING) {
+		ccid->ccid_flags &= ~CCID_F_WORKER_MASK;
+		mutex_exit(&ccid->ccid_mutex);
+		return;
+	}
+	ccid->ccid_flags |= CCID_F_WORKER_RUNNING;
+	ccid->ccid_flags &= ~CCID_F_WORKER_REQUESTED;
+
+	for (i = 0; i < ccid->ccid_nslots; i++) {
+		ccid_slot_t *slot = &ccid->ccid_slots[i];
+		ccid_reply_icc_status_t ss;
+		int ret;
+		uint_t flags;
+		boolean_t skip_reset;
+
+		VERIFY(MUTEX_HELD(&ccid->ccid_mutex));
+
+		/*
+		 * Snapshot the flags before we start processing the worker. At
+		 * this time we clear out all of the change flags as we'll be
+		 * operating on the device. We do not clear the
+		 * CCID_SLOT_F_NEED_TXN_RESET flag, as we want to make sure that
+		 * this is maintained until we're done here.
+		 */
+		flags = slot->cs_flags & CCID_SLOT_F_WORK_MASK;
+		slot->cs_flags &= ~CCID_SLOT_F_INTR_MASK;
+
+		if (flags & CCID_SLOT_F_CHANGED) {
+			if (flags & CCID_SLOT_F_INTR_GONE) {
+				ccid_slot_removed(ccid, slot, B_TRUE);
+			} else {
+				ccid_slot_inserted(ccid, slot);
+				if (slot->cs_flags & CCID_SLOT_F_ACTIVE) {
+					ccid_slot_excl_maybe_signal(slot);
+				}
+			}
+			VERIFY(MUTEX_HELD(&ccid->ccid_mutex));
+		}
+
+		if (flags & CCID_SLOT_F_NEED_TXN_RESET) {
+			/*
+			 * If the CCID_SLOT_F_PRESENT flag is set, then we
+			 * should attempt to power off and power on the ICC in
+			 * an attempt to reset it. If this fails, trigger
+			 * another worker that needs to operate.
+			 */
+			if (flags & CCID_SLOT_F_PRESENT) {
+				if (!ccid_slot_reset(ccid, slot)) {
+					ccid_worker_request(ccid);
+					continue;
+				}
+			}
+
+			VERIFY(MUTEX_HELD(&ccid->ccid_mutex));
+			slot->cs_flags &= ~CCID_SLOT_F_NEED_TXN_RESET;
+			/*
+			 * XXX The signaling in all of this worker logic makes
+			 * no sense.
+			 */
+			ccid_slot_excl_maybe_signal(slot);
+		}
+	}
+
+	/*
+	 * If we have a request to operate again, delay before we consider this,
+	 * to make sure we don't do too much work ourselves.
+	 */
+	if (ccid->ccid_flags & CCID_F_WORKER_REQUESTED) {
+		mutex_exit(&ccid->ccid_mutex);
+		delay(drv_usectohz(1000) * 10);
+		mutex_enter(&ccid->ccid_mutex);
+	}
+
+	ccid->ccid_flags &= ~CCID_F_WORKER_RUNNING;
+	if (ccid->ccid_flags & CCID_F_DETACHING) {
+		mutex_exit(&ccid->ccid_mutex);
+		return;
+	}
+
+	if ((ccid->ccid_flags & CCID_F_WORKER_REQUESTED) != 0) {
+		(void) ddi_taskq_dispatch(ccid->ccid_taskq, ccid_worker, ccid,
+		    DDI_SLEEP);
+	}
+	mutex_exit(&ccid->ccid_mutex);
+}
+
+static void
+ccid_worker_request(ccid_t *ccid)
+{
+	boolean_t run;
+
+	VERIFY(MUTEX_HELD(&ccid->ccid_mutex));
+	if (ccid->ccid_flags & CCID_F_DETACHING) {
+		return;
+	}
+
+	run = (ccid->ccid_flags & CCID_F_WORKER_MASK) == 0; 
+	ccid->ccid_flags |= CCID_F_WORKER_REQUESTED;
+	if (run) {
+		mutex_exit(&ccid->ccid_mutex);
+		(void) ddi_taskq_dispatch(ccid->ccid_taskq, ccid_worker, ccid,
+		    DDI_SLEEP);
+		mutex_enter(&ccid->ccid_mutex);
+	}
+}
+
+static void
+ccid_intr_restart_timeout(void *arg)
+{
+	ccid_t *ccid = arg;
+
+	mutex_enter(&ccid->ccid_mutex);
+	if (ccid->ccid_flags & CCID_F_DETACHING) {
+		ccid->ccid_poll_timeout = NULL;
+		mutex_exit(&ccid->ccid_mutex);
+	}
+	mutex_exit(&ccid->ccid_mutex);
+
+	ccid_intr_poll_init(ccid);
+}
+
+/*
+ * Search for the current class descriptor from the configuration cloud and
+ * parse it for our use. We do this by first finding the current interface
+ * descriptor and expecting it to be one of the next descriptors 
+ */
+static boolean_t
+ccid_parse_class_desc(ccid_t *ccid)
+{
+	uint_t i;
+	size_t len, tlen;
+	usb_client_dev_data_t *dp;
+	usb_alt_if_data_t *alt;
+
+	/*
+	 * Establish the target length we're looking for from usb_parse_data().
+	 * Note that we cannot use the sizeof (ccid_class_descr_t) for this
+	 * because that function does not know how to account for the padding at
+	 * the end of the target structure (which is resasonble). So we manually
+	 * figure out the number of bytes it should in theory write.
+	 */
+	tlen = offsetof(ccid_class_descr_t, ccd_bMaxCCIDBusySlots) +
+	    sizeof (ccid->ccid_class.ccd_bMaxCCIDBusySlots);
+	dp = ccid->ccid_dev_data;
+	alt = &dp->dev_curr_cfg->cfg_if[dp->dev_curr_if].if_alt[0];
+	for (i = 0; i < alt->altif_n_cvs; i++) {
+		usb_cvs_data_t *cvs = &alt->altif_cvs[i];
+		if (cvs->cvs_buf == NULL)
+			continue;
+		if (cvs->cvs_buf_len != CCID_DESCR_LENGTH)
+			continue;
+		if (cvs->cvs_buf[1] != CCID_DESCR_TYPE)
+			continue;
+		if ((len = usb_parse_data("ccscc3lcllc5lccscc", cvs->cvs_buf,
+		    cvs->cvs_buf_len, &ccid->ccid_class,
+		    sizeof (ccid->ccid_class))) >= tlen) {
+			return (B_TRUE);
+		}
+		ccid_error(ccid, "faild to parse CCID class descriptor from "
+		    "cvs %u, expected %lu bytes, received %lu", i, tlen, len);
+	}
+
+	ccid_error(ccid, "failed to find matching CCID class descriptor");
+	return (B_FALSE);
+}
+
+/*
+ * Verify whether or not we can support this CCID reader.
+ */
+static boolean_t
+ccid_supported(ccid_t *ccid)
+{
+	usb_client_dev_data_t *dp;
+	usb_alt_if_data_t *alt;
+	ccid_class_features_t feat;
+	uint_t bits;
+	uint16_t ver = ccid->ccid_class.ccd_bcdCCID;
+
+	if (CCID_VERSION_MAJOR(ver) != CCID_VERSION_ONE) {
+		ccid_error(ccid, "refusing to attach to CCID with unsupported "
+		   "version %x.%2x", CCID_VERSION_MAJOR(ver),
+		   CCID_VERSION_MINOR(ver));
+		return (B_FALSE);
+	}
+
+	/*
+	 * Check the number of endpoints. This should have either two or three.
+	 * If three, that means we should expect an interrupt-IN endpoint.
+	 * Otherwise, we shouldn't. Any other value indicates something weird
+	 * that we should ignore.
+	 */
+	dp = ccid->ccid_dev_data;
+	alt = &dp->dev_curr_cfg->cfg_if[dp->dev_curr_if].if_alt[0];
+	switch (alt->altif_descr.bNumEndpoints) {
+	case 2:
+		ccid->ccid_flags &= ~CCID_F_HAS_INTR;
+		break;
+	case 3:
+		ccid->ccid_flags |= CCID_F_HAS_INTR;
+		break;
+	default:
+		ccid_error(ccid, "refusing to attach to CCID with unsupported "
+		    "number of endpoints: %d", alt->altif_descr.bNumEndpoints);
+		return (B_FALSE);
+	}
+
+	/*
+	 * Try and determine the appropriate buffer size. This can be a little
+	 * tricky. The class descriptor tells us the maximum size that the
+	 * reader excepts. While it may be tempting to try and use a larger
+	 * value such as the maximum size, the readers really don't like
+	 * receiving bulk transfers that large. However, there are also reports
+	 * of readers that will overwrite to a fixed minimum size. XXX which
+	 * devices were those and should this be a p2roundup on the order of 256
+	 * bytes maybe?
+	 */
+	ccid->ccid_bufsize = ccid->ccid_class.ccd_dwMaxCCIDMessageLength;
+	if (ccid->ccid_bufsize < CCID_MIN_MESSAGE_LENGTH) {
+		ccid_error(ccid, "CCID reader maximum CCID message length (%u) is "
+		    "less than minimum packet length (%u)", ccid->ccid_bufsize,
+		    CCID_MIN_MESSAGE_LENGTH);
+		return (B_FALSE);
+	}
+
+	/*
+	 * At this time, we do not require that the system have automatic ICC
+	 * activation or automatic ICC voltage. These are handled automatically
+	 * by the system.
+	 */
+	feat = ccid->ccid_class.ccd_dwFeatures;
+
+	/*
+	 * Check the number of data rates that are supported by the reader. If
+	 * the reader has a non-zero value and we don't support automatic
+	 * negotiation then warn about that.
+	 */
+	if (ccid->ccid_class.ccd_bNumDataRatesSupported != 0 &&
+	    (feat & CCID_CLASS_F_AUTO_BAUD) == 0) {
+		ccid_error(ccid, "!CCID reader only supports fixed clock rates, "
+		    "data will be limited to default values");
+	}
+
+	/*
+	 * Check which automatic features the reader provides and which features
+	 * it does not. Missing features will require additional work before a
+	 * card can be activated. Note, this also applies to APDU based devices
+	 * which may need to have various aspects of the device negotiated.
+	 */
+
+	/*
+	 * The footnote for these two bits in CCID r1.1.0 indicates that
+	 * when neither are missing we have to do the PPS negotiation
+	 * ourselves.
+	 */
+	bits = CCID_CLASS_F_AUTO_PARAM_NEG | CCID_CLASS_F_AUTO_PPS;
+	if ((feat & bits) == 0) {
+		ccid->ccid_flags |= CCID_F_NEEDS_PPS;
+	}
+
+	if ((feat & CCID_CLASS_F_AUTO_PARAM_NEG) == 0) {
+		ccid->ccid_flags |= CCID_F_NEEDS_PARAMS;
+	}
+
+	bits = CCID_CLASS_F_AUTO_BAUD | CCID_CLASS_F_AUTO_ICC_CLOCK;
+	if ((feat & bits) != bits) {
+		ccid->ccid_flags |= CCID_F_NEEDS_DATAFREQ;
+	}
+
+	/*
+	 * XXX This should probably check on the actual support for T=1. If it
+	 * doesn't exist, we should probably ignore it.
+	 */
+	if ((feat & CCID_CLASS_F_AUTO_IFSD) == 0) {
+		ccid->ccid_flags |= CCID_F_NEEDS_IFSD;
+
+		/*
+		 * If there is no support for negotiating the IFSD, we need to
+		 * check to make sure that the IFSD that's supported is at least
+		 * the default size. If it is less than the default T=1 size,
+		 * then we should probably reject this reader for the time
+		 * being. It is possible that we could support it at a smaller
+		 * IFSD; however, ISO/IEC 7816-3:2006 recommends that it be at
+		 * least 20 bytes.
+		 */
+		if (ccid->ccid_class.ccd_dwMaxIFSD < T1_IFSD_DEFAULT) {
+			ccid_error(ccid, "CCID reader max IFSD (%d) is less "
+			    "T=1 default", ccid->ccid_class.ccd_dwMaxIFSD,
+			    T1_IFSD_DEFAULT);
+			return (B_FALSE);
+		}
+	}
+
+	return (B_TRUE);
+}
+
+static boolean_t
+ccid_open_pipes(ccid_t *ccid)
+{
+	int ret;
+	usb_ep_data_t *ep;
+	usb_client_dev_data_t *data;
+	usb_pipe_policy_t policy;
+
+	data = ccid->ccid_dev_data;
+
+	/*
+	 * First fill all the descriptors.
+	 */
+	ep = usb_lookup_ep_data(ccid->ccid_dip, data, data->dev_curr_if, 0, 0,
+	    USB_EP_ATTR_BULK, USB_EP_DIR_IN);
+	if (ep == NULL) {
+		ccid_error(ccid, "failed to find CCID Bulk-IN endpoint");
+		return (B_FALSE);
+	}
+
+	if ((ret = usb_ep_xdescr_fill(USB_EP_XDESCR_CURRENT_VERSION,
+	    ccid->ccid_dip, ep, &ccid->ccid_bulkin_xdesc)) != USB_SUCCESS) {
+		ccid_error(ccid, "failed to fill Bulk-IN xdescr: %d", ret);
+		return (B_FALSE);
+	}
+
+	ep = usb_lookup_ep_data(ccid->ccid_dip, data, data->dev_curr_if, 0, 0,
+	    USB_EP_ATTR_BULK, USB_EP_DIR_OUT);
+	if (ep == NULL) {
+		ccid_error(ccid, "failed to find CCID Bulk-OUT endpoint");
+		return (B_FALSE);
+	}
+
+	if ((ret = usb_ep_xdescr_fill(USB_EP_XDESCR_CURRENT_VERSION,
+	    ccid->ccid_dip, ep, &ccid->ccid_bulkout_xdesc)) != USB_SUCCESS) {
+		ccid_error(ccid, "failed to fill Bulk-OUT xdescr: %d", ret);
+		return (B_FALSE);
+	}
+
+	if (ccid->ccid_flags & CCID_F_HAS_INTR) {
+		ep = usb_lookup_ep_data(ccid->ccid_dip, data, data->dev_curr_if,
+		    0, 0, USB_EP_ATTR_INTR, USB_EP_DIR_IN);
+		if (ep == NULL) {
+			ccid_error(ccid, "failed to find CCID Intr-IN "
+			    "endpoint");
+			return (B_FALSE);
+		}
+
+		if ((ret = usb_ep_xdescr_fill(USB_EP_XDESCR_CURRENT_VERSION,
+		    ccid->ccid_dip, ep, &ccid->ccid_intrin_xdesc)) !=
+		    USB_SUCCESS) {
+			ccid_error(ccid, "failed to fill Intr-OUT xdescr: %d",
+			    ret);
+			return (B_FALSE);
+		}
+	}
+
+	/*
+	 * Now open up the pipes.
+	 */
+
+	/*
+	 * First determine the maximum number of asynchronous requests. This
+	 * determines the maximum 
+	 */
+	bzero(&policy, sizeof (policy));
+	policy.pp_max_async_reqs = CCID_NUM_ASYNC_REQS;
+
+	if ((ret = usb_pipe_xopen(ccid->ccid_dip, &ccid->ccid_bulkin_xdesc,
+	    &policy, USB_FLAGS_SLEEP, &ccid->ccid_bulkin_pipe)) != USB_SUCCESS) {
+		ccid_error(ccid, "failed to open Bulk-IN pipe: %d\n", ret);
+		return (B_FALSE);
+	}
+
+	if ((ret = usb_pipe_xopen(ccid->ccid_dip, &ccid->ccid_bulkout_xdesc,
+	    &policy, USB_FLAGS_SLEEP, &ccid->ccid_bulkout_pipe)) != USB_SUCCESS) {
+		ccid_error(ccid, "failed to open Bulk-OUT pipe: %d\n", ret);
+		usb_pipe_close(ccid->ccid_dip, ccid->ccid_bulkin_pipe,
+		    USB_FLAGS_SLEEP, NULL, NULL);
+		ccid->ccid_bulkin_pipe = NULL;
+		return (B_FALSE);
+	}
+
+	if (ccid->ccid_flags & CCID_F_HAS_INTR) {
+		if ((ret = usb_pipe_xopen(ccid->ccid_dip,
+		    &ccid->ccid_intrin_xdesc, &policy, USB_FLAGS_SLEEP,
+		    &ccid->ccid_intrin_pipe)) != USB_SUCCESS) {
+			ccid_error(ccid, "failed to open Intr-IN pipe: %d\n",
+			    ret);
+			usb_pipe_close(ccid->ccid_dip, ccid->ccid_bulkin_pipe,
+			    USB_FLAGS_SLEEP, NULL, NULL);
+			ccid->ccid_bulkin_pipe = NULL;
+			usb_pipe_close(ccid->ccid_dip, ccid->ccid_bulkout_pipe,
+			    USB_FLAGS_SLEEP, NULL, NULL);
+			ccid->ccid_bulkout_pipe = NULL;
+			return (B_FALSE);
+		}
+	}
+
+	ccid->ccid_control_pipe = data->dev_default_ph;
+	return (B_TRUE);
+}
+
+static void
+ccid_slots_fini(ccid_t *ccid)
+{
+	uint_t i;
+
+	for (i = 0; i < ccid->ccid_nslots; i++) {
+		VERIFY3U(ccid->ccid_slots[i].cs_slotno, ==, i);
+
+		if (ccid->ccid_slots[i].cs_command != NULL) {
+			ccid_command_free(ccid->ccid_slots[i].cs_command);
+			ccid->ccid_slots[i].cs_command = NULL;
+		}
+
+		cv_destroy(&ccid->ccid_slots[i].cs_io.ci_cv);
+		freemsgchain(ccid->ccid_slots[i].cs_atr);
+		atr_data_free(ccid->ccid_slots[i].cs_icc.icc_atr_data);
+		list_destroy(&ccid->ccid_slots[i].cs_minors);
+		list_destroy(&ccid->ccid_slots[i].cs_excl_waiters);
+	}
+
+	ddi_remove_minor_node(ccid->ccid_dip, NULL);
+	kmem_free(ccid->ccid_slots, sizeof (ccid_slot_t) * ccid->ccid_nslots);
+	ccid->ccid_nslots = 0;
+	ccid->ccid_slots = NULL;
+}
+
+static boolean_t
+ccid_slots_init(ccid_t *ccid)
+{
+	uint_t i;
+
+	/*
+	 * The class descriptor has the maximum index that one can index into.
+	 * We therefore have to add one to determine the actual number of slots
+	 * that exist.
+	 */
+	ccid->ccid_nslots = ccid->ccid_class.ccd_bMaxSlotIndex + 1;
+	ccid->ccid_slots = kmem_zalloc(sizeof (ccid_slot_t) * ccid->ccid_nslots,
+	    KM_SLEEP);
+	for (i = 0; i < ccid->ccid_nslots; i++) {
+		/*
+		 * We initialize every possible slot as having changed to make
+		 * sure that we have a chance to discover it. See the slot
+		 * detection section in the big theory statement for more info.
+		 */
+		ccid->ccid_slots[i].cs_flags |= CCID_SLOT_F_CHANGED;
+		ccid->ccid_slots[i].cs_slotno = i;
+		ccid->ccid_slots[i].cs_ccid = ccid;
+		ccid->ccid_slots[i].cs_icc.icc_atr_data = atr_data_alloc();
+		ccid->ccid_slots[i].cs_idx.cmi_minor = CCID_MINOR_INVALID;
+		ccid->ccid_slots[i].cs_idx.cmi_isslot = B_TRUE;
+		ccid->ccid_slots[i].cs_idx.cmi_data.cmi_slot =
+		    &ccid->ccid_slots[i];
+		cv_init(&ccid->ccid_slots[i].cs_io.ci_cv, NULL, CV_DRIVER, NULL);
+		list_create(&ccid->ccid_slots[i].cs_minors, sizeof (ccid_minor_t),
+		   offsetof(ccid_minor_t, cm_minor_list)); 
+		list_create(&ccid->ccid_slots[i].cs_excl_waiters, sizeof (ccid_minor_t),
+		   offsetof(ccid_minor_t, cm_excl_list)); 
+	}
+
+	return (B_TRUE);
+}
+
+static void
+ccid_minors_fini(ccid_t *ccid)
+{
+	uint_t i;
+
+	ddi_remove_minor_node(ccid->ccid_dip, NULL);
+	for (i = 0; i < ccid->ccid_nslots; i++) {
+		if (ccid->ccid_slots[i].cs_idx.cmi_minor == CCID_MINOR_INVALID)
+			continue;
+		ccid_minor_idx_free(&ccid->ccid_slots[i].cs_idx);
+	}
+}
+
+static boolean_t
+ccid_minors_init(ccid_t *ccid)
+{
+	uint_t i;
+
+	for (i = 0; i < ccid->ccid_nslots; i++) {
+		char buf[32];
+
+		(void) ccid_minor_idx_alloc(&ccid->ccid_slots[i].cs_idx, B_TRUE);
+
+		(void) snprintf(buf, sizeof (buf), "slot%d", i);
+		if (ddi_create_minor_node(ccid->ccid_dip, buf, S_IFCHR,
+		    ccid->ccid_slots[i].cs_idx.cmi_minor,
+		    DDI_NT_CCID_ATTACHMENT_POINT, 0) != DDI_SUCCESS) {
+			ccid_minors_fini(ccid);
+			return (B_FALSE);
+		}
+	}
+
+	return (B_TRUE);
+}
+
+static void
+ccid_intr_poll_fini(ccid_t *ccid)
+{
+	if (ccid->ccid_flags & CCID_F_HAS_INTR) {
+		timeout_id_t tid;
+		mutex_enter(&ccid->ccid_mutex);
+		tid = ccid->ccid_poll_timeout;
+		ccid->ccid_poll_timeout = NULL;
+		mutex_exit(&ccid->ccid_mutex);
+		(void) untimeout(tid);
+		usb_pipe_stop_intr_polling(ccid->ccid_intrin_pipe,
+		    USB_FLAGS_SLEEP);
+	} else {
+		VERIFY3P(ccid->ccid_intrin_pipe, ==, NULL);
+	}
+}
+
+static void
+ccid_intr_poll_init(ccid_t *ccid)
+{
+	int ret;
+	usb_intr_req_t *uirp;
+
+	uirp = usb_alloc_intr_req(ccid->ccid_dip, 0, USB_FLAGS_SLEEP);
+	uirp->intr_client_private = (usb_opaque_t)ccid;
+	uirp->intr_attributes = USB_ATTRS_SHORT_XFER_OK |
+	    USB_ATTRS_AUTOCLEARING;
+	uirp->intr_len = CCID_INTR_RESPONSE_SIZE;
+	uirp->intr_cb = ccid_intr_pipe_cb;
+	uirp->intr_exc_cb = ccid_intr_pipe_except_cb;
+
+	mutex_enter(&ccid->ccid_mutex);
+	if (ccid->ccid_flags & CCID_F_DETACHING) {
+		mutex_exit(&ccid->ccid_mutex);
+		usb_free_intr_req(uirp);
+		return;
+	}
+
+	if ((ret = usb_pipe_intr_xfer(ccid->ccid_intrin_pipe, uirp,
+	    USB_FLAGS_SLEEP)) != USB_SUCCESS) {
+		ccid_error(ccid, "!failed to start polling on CCID Intr-IN "
+		    "pipe: %d", ret);
+		ccid->ccid_poll_timeout = timeout(ccid_intr_restart_timeout,
+		    ccid, drv_usectohz(1000000));
+		usb_free_intr_req(uirp);
+	}
+	mutex_exit(&ccid->ccid_mutex);
+}
+
+static void
+ccid_cleanup_bulkin(ccid_t *ccid)
+{
+	uint_t i;
+
+	VERIFY3P(ccid->ccid_bulkin_dispatched, ==, NULL);
+	for (i = 0; i < ccid->ccid_bulkin_alloced; i++) {
+		VERIFY3P(ccid->ccid_bulkin_cache[i], !=, NULL);
+		usb_free_bulk_req(ccid->ccid_bulkin_cache[i]);
+		ccid->ccid_bulkin_cache[i] = NULL;
+	}
+
+#ifdef	DEBUG
+	for (i = 0; i < CCID_BULK_NALLOCED; i++) {
+		VERIFY3P(ccid->ccid_bulkin_cache[i], ==, NULL);
+	}
+#endif
+	ccid->ccid_bulkin_alloced = 0;
+}
+
+static int
+ccid_disconnect_cb(dev_info_t *dip)
+{
+	int inst;
+	ccid_t *ccid;
+	uint_t i;
+
+	if (dip == NULL)
+		goto done;
+
+	inst = ddi_get_instance(dip);
+	ccid = ddi_get_soft_state(ccid_softstate, inst);
+	if (ccid == NULL)
+		goto done;
+	VERIFY3P(dip, ==, ccid->ccid_dip);
+
+	/*
+	 * XXX We need to check this and throw errors throughout, throw out
+	 * poll, etc.
+	 */
+	mutex_enter(&ccid->ccid_mutex);
+	/*
+	 * First, set the disconnected flag. This will make sure that anyone
+	 * that tries to make additional operations will be kicked out. This
+	 * flag is checked by detach and by users.
+	 */
+	ccid->ccid_flags |= CCID_F_DISCONNECTED;
+
+	/*
+	 * First, go through any threads that are blocked on a minor for
+	 * exclusive access. They should be woken up and they'll fail due to the
+	 * fact that we've set the disconnected flag above.
+	 */
+	for (i = 0; i < ccid->ccid_nslots; i++) {
+		ccid_minor_t *cmp;
+		ccid_slot_t *slot = &ccid->ccid_slots[i];
+
+		for (cmp = list_head(&slot->cs_excl_waiters); cmp != NULL;
+		    cmp = list_next(&slot->cs_excl_waiters, cmp)) {
+			cv_signal(&cmp->cm_excl_cv);
+		}
+	}
+
+	/*
+	 * Now, we need to basically wake up anyone blocked in read and make
+	 * sure that they don't wait there forever and make sure that anyone
+	 * polling gets a POLLHUP. We can't really distinguish between this and
+	 * an ICC being removed. It will be discovered when someone tries to do
+	 * an operation and they receive an EXDEV. We only need to do this on
+	 * minors that have exclusive access. Don't worry about them finishing
+	 * up, this'll be done as part of detach.
+	 */
+	for (i = 0; i < ccid->ccid_nslots; i++) {
+		ccid_minor_t *cmp;
+		ccid_slot_t *slot = &ccid->ccid_slots[i];
+		if (slot->cs_excl_minor == NULL)
+			continue;
+
+		pollwakeup(&slot->cs_excl_minor->cm_pollhead,
+		    POLLHUP | POLLERR);
+		cv_signal(&slot->cs_excl_minor->cm_read_cv);
+	}
+
+	/*
+	 * XXX If there are outstanding commands, they should ultimately be
+	 * cleaned up as the USB commands themselves time out. It's not clear
+	 * that we need to clean them up ourselves or how all those callbacks
+	 * will function exactly.
+	 */
+	mutex_exit(&ccid->ccid_mutex);
+
+done:
+	return (USB_SUCCESS);
+}
+
+static usb_event_t ccid_usb_events = {
+	ccid_disconnect_cb,
+	NULL,
+	NULL,
+	NULL
+};
+
+static void
+ccid_cleanup(dev_info_t *dip)
+{
+	int inst;
+	ccid_t *ccid;
+
+	if (dip == NULL)
+		return;
+
+	inst = ddi_get_instance(dip);
+	ccid = ddi_get_soft_state(ccid_softstate, inst);
+	if (ccid == NULL)
+		return;
+	VERIFY3P(dip, ==, ccid->ccid_dip);
+
+	/*
+	 * Make sure we set the detaching flag so anything running in the
+	 * background knows to stop.
+	 */
+	mutex_enter(&ccid->ccid_mutex);
+	ccid->ccid_flags |= CCID_F_DETACHING;
+	mutex_exit(&ccid->ccid_mutex);
+
+	if (ccid->ccid_attach & CCID_ATTACH_MINORS) {
+		ccid_minors_fini(ccid);
+		ccid->ccid_attach &= ~CCID_ATTACH_MINORS;
+	}
+
+	if (ccid->ccid_attach & CCID_ATTACH_INTR_ACTIVE) {
+		ccid_intr_poll_fini(ccid);
+		ccid->ccid_attach &= ~CCID_ATTACH_INTR_ACTIVE;
+	}
+
+	/*
+	 * At this point, we have shut down the interrupt pipe, the last place
+	 * aside from a user that could have kicked off I/O. So finally wait for
+	 * any worker threads.
+	 */
+	if (ccid->ccid_taskq != NULL) {
+		ddi_taskq_wait(ccid->ccid_taskq);
+		mutex_enter(&ccid->ccid_mutex);
+		VERIFY0(ccid->ccid_flags & CCID_F_WORKER_MASK);
+		mutex_exit(&ccid->ccid_mutex);
+	}
+
+	if (ccid->ccid_attach & CCID_ATTACH_HOTPLUG_CB) {
+		usb_unregister_event_cbs(dip, &ccid_usb_events);
+		ccid->ccid_attach &= ~CCID_ATTACH_HOTPLUG_CB;
+	}
+
+	if (ccid->ccid_attach & CCID_ATTACH_SLOTS) {
+		ccid_slots_fini(ccid);
+		ccid->ccid_attach &= ~CCID_ATTACH_SLOTS;
+	}
+
+	if (ccid->ccid_attach & CCID_ATTACH_SEQ_IDS) {
+		id_space_destroy(ccid->ccid_seqs);
+		ccid->ccid_seqs = NULL;
+		ccid->ccid_attach &= ~CCID_ATTACH_SEQ_IDS;
+	}
+
+	if (ccid->ccid_attach & CCID_ATTACH_OPEN_PIPES) {
+		usb_pipe_close(dip, ccid->ccid_bulkin_pipe, USB_FLAGS_SLEEP,
+		    NULL, NULL);
+		ccid->ccid_bulkin_pipe = NULL;
+		usb_pipe_close(dip, ccid->ccid_bulkout_pipe, USB_FLAGS_SLEEP,
+		    NULL, NULL);
+		ccid->ccid_bulkout_pipe = NULL;
+		if (ccid->ccid_flags & CCID_F_HAS_INTR) {
+			usb_pipe_close(dip, ccid->ccid_intrin_pipe,
+			    USB_FLAGS_SLEEP, NULL, NULL);
+			ccid->ccid_intrin_pipe = NULL;
+		} else {
+			VERIFY3P(ccid->ccid_intrin_pipe, ==, NULL);
+		}
+		ccid->ccid_control_pipe = NULL;
+		ccid->ccid_attach &= ~CCID_ATTACH_OPEN_PIPES;
+	}
+
+	/*
+	 * Now that all of the pipes are closed. If we happened to have any
+	 * cached bulk requests, we should free them.
+	 */
+	ccid_cleanup_bulkin(ccid);
+
+	if (ccid->ccid_attach & CCID_ATTACH_CMD_LIST) {
+		ccid_command_t *cc;
+
+		while ((cc = list_remove_head(&ccid->ccid_command_queue)) !=
+		    NULL) {
+			ccid_command_free(cc);
+		}
+		list_destroy(&ccid->ccid_command_queue);
+
+		while ((cc = list_remove_head(&ccid->ccid_complete_queue)) !=
+		    NULL) {
+			ccid_command_free(cc);
+		}
+		list_destroy(&ccid->ccid_complete_queue);
+	}
+
+	if (ccid->ccid_attach & CCID_ATTACH_TASKQ) {
+		ddi_taskq_destroy(ccid->ccid_taskq);
+		ccid->ccid_taskq = NULL;
+		ccid->ccid_attach &= ~CCID_ATTACH_TASKQ;
+	}
+
+	if (ccid->ccid_attach & CCID_ATTACH_MUTEX_INIT) {
+		mutex_destroy(&ccid->ccid_mutex);
+		ccid->ccid_attach &= ~CCID_ATTACH_MUTEX_INIT;
+	}
+
+	if (ccid->ccid_attach & CCID_ATTACH_USB_CLIENT) {
+		usb_client_detach(dip, ccid->ccid_dev_data);
+		ccid->ccid_dev_data = NULL;
+		ccid->ccid_attach &= ~CCID_ATTACH_USB_CLIENT;
+	}
+
+	ASSERT0(ccid->ccid_attach);
+	ddi_soft_state_free(ccid_softstate, inst);
+}
+
+static int
+ccid_attach(dev_info_t *dip, ddi_attach_cmd_t cmd)
+{
+	ccid_t *ccid;
+	int inst, ret;
+	char buf[64];
+
+	if (cmd != DDI_ATTACH)
+		return (DDI_FAILURE);
+
+	inst = ddi_get_instance(dip);
+	if (ddi_soft_state_zalloc(ccid_softstate, inst) != DDI_SUCCESS) {
+		ccid_error(NULL, "failed to allocate soft state for ccid "
+		    "instance %d", inst);
+		return (DDI_FAILURE);
+	}
+
+	ccid = ddi_get_soft_state(ccid_softstate, inst);
+	ccid->ccid_dip = dip;
+
+	if ((ret = usb_client_attach(dip, USBDRV_VERSION, 0)) != USB_SUCCESS) {
+		ccid_error(ccid, "failed to attach to usb client: %d", ret);
+		goto cleanup;
+	}
+	ccid->ccid_attach |= CCID_ATTACH_USB_CLIENT;
+
+	if ((ret = usb_get_dev_data(dip, &ccid->ccid_dev_data, USB_PARSE_LVL_IF,
+	    0)) != USB_SUCCESS) {
+		ccid_error(ccid, "failed to get usb device data: %d", ret);
+		goto cleanup;
+	}
+
+	mutex_init(&ccid->ccid_mutex, NULL, MUTEX_DRIVER,
+	    ccid->ccid_dev_data->dev_iblock_cookie);
+	ccid->ccid_attach |= CCID_ATTACH_MUTEX_INIT;
+
+	(void) snprintf(buf, sizeof (buf), "ccid%d_taskq", inst);
+	ccid->ccid_taskq = ddi_taskq_create(dip, buf, 1, TASKQ_DEFAULTPRI, 0);
+	if (ccid->ccid_taskq == NULL) {
+		ccid_error(ccid, "failed to create CCID taskq");
+		goto cleanup;
+	}
+	ccid->ccid_attach |= CCID_ATTACH_TASKQ;
+
+	list_create(&ccid->ccid_command_queue, sizeof (ccid_command_t),
+	    offsetof(ccid_command_t, cc_list_node));
+	list_create(&ccid->ccid_complete_queue, sizeof (ccid_command_t),
+	    offsetof(ccid_command_t, cc_list_node));
+
+	if (!ccid_parse_class_desc(ccid)) {
+		ccid_error(ccid, "failed to parse CCID class descriptor");
+		goto cleanup;
+	}
+
+	if (!ccid_supported(ccid)) {
+		ccid_error(ccid, "CCID reader is not supported, not attaching");
+		goto cleanup;
+	}
+
+	if (!ccid_open_pipes(ccid)) {
+		ccid_error(ccid, "failed to open CCID pipes, not attaching");
+		goto cleanup;
+	}
+	ccid->ccid_attach |= CCID_ATTACH_OPEN_PIPES;
+
+	(void) snprintf(buf, sizeof (buf), "ccid%d_seqs", inst);
+	if ((ccid->ccid_seqs = id_space_create(buf, CCID_SEQ_MIN,
+	    CCID_SEQ_MAX + 1)) == NULL) {
+		ccid_error(ccid, "failed to create CCID sequence id space");
+		goto cleanup;
+	}
+	ccid->ccid_attach |= CCID_ATTACH_SEQ_IDS;
+
+	if (!ccid_slots_init(ccid)) {
+		ccid_error(ccid, "failed to initialize CCID slot structures");
+		goto cleanup;
+	}
+	ccid->ccid_attach |= CCID_ATTACH_SLOTS;
+
+	if (usb_register_event_cbs(dip, &ccid_usb_events, 0) != USB_SUCCESS) {
+		ccid_error(ccid, "failed to register USB hotplug callbacks");
+		goto cleanup;
+	}
+	ccid->ccid_attach |= CCID_ATTACH_HOTPLUG_CB;
+
+	/*
+	 * Before we enable the interrupt pipe, take a shot at priming our
+	 * bulkin_cache.
+	 */
+	mutex_enter(&ccid->ccid_mutex);
+	ccid_bulkin_cache_refresh(ccid);
+	mutex_exit(&ccid->ccid_mutex);
+
+	if (ccid->ccid_flags & CCID_F_HAS_INTR) {
+		ccid_intr_poll_init(ccid);
+	}
+	ccid->ccid_attach |= CCID_ATTACH_INTR_ACTIVE;
+
+	/*
+	 * Create minor nodes for each slot.
+	 */
+	if (!ccid_minors_init(ccid)) {
+		ccid_error(ccid, "failed to create minor nodes");
+		goto cleanup;
+	}
+	ccid->ccid_attach |= CCID_ATTACH_MINORS;
+
+	mutex_enter(&ccid->ccid_mutex);
+	ccid_worker_request(ccid);
+	mutex_exit(&ccid->ccid_mutex);
+
+	return (DDI_SUCCESS);
+
+cleanup:
+	ccid_cleanup(dip);
+	return (DDI_SUCCESS);
+}
+
+static int
+ccid_getinfo(dev_info_t *dip, ddi_info_cmd_t cmd, void *arg, void **outp)
+{
+	return (DDI_FAILURE);
+}
+
+static int
+ccid_detach(dev_info_t *dip, ddi_detach_cmd_t cmd)
+{
+	int inst;
+	uint_t i;
+	ccid_t *ccid;
+
+	if (cmd != DDI_DETACH)
+		return (DDI_FAILURE);
+
+	inst = ddi_get_instance(dip);
+	ccid = ddi_get_soft_state(ccid_softstate, inst);
+	VERIFY3P(ccid, !=, NULL);
+	VERIFY3P(dip, ==, ccid->ccid_dip);
+
+	mutex_enter(&ccid->ccid_mutex);
+
+	/*
+	 * If the device hasn't been disconnected from a USB sense, refuse to
+	 * detach. Otherwise, there's no way to guarantee that the ccid
+	 * driver will be attached when a user hotplugs an ICC.
+	 */
+	if ((ccid->ccid_flags & CCID_F_DISCONNECTED) == 0) {
+		mutex_exit(&ccid->ccid_mutex);
+		return (DDI_FAILURE);
+	}
+
+	if (list_is_empty(&ccid->ccid_command_queue) == 0 ||
+	    list_is_empty(&ccid->ccid_complete_queue) == 0) {
+		mutex_exit(&ccid->ccid_mutex);
+		return (DDI_FAILURE);
+	}
+	mutex_exit(&ccid->ccid_mutex);
+
+	ccid_cleanup(dip);
+	return (DDI_SUCCESS);
+}
+
+static void
+ccid_minor_free(ccid_minor_t *cmp)
+{
+	ccid_command_t *cc;
+
+	/*
+	 * Clean up queued commands.
+	 */
+	VERIFY3U(cmp->cm_idx.cmi_minor, ==, CCID_MINOR_INVALID);
+	crfree(cmp->cm_opener);
+	cv_destroy(&cmp->cm_iowait_cv);
+	cv_destroy(&cmp->cm_read_cv);
+	cv_destroy(&cmp->cm_excl_cv);
+	kmem_free(cmp, sizeof (ccid_minor_t));
+
+}
+
+static int
+ccid_open(dev_t *devp, int flag, int otyp, cred_t *credp)
+{
+	int ret;
+	ccid_minor_idx_t *idx;
+	ccid_minor_t *cmp;
+	ccid_slot_t *slot;
+
+	/*
+	 * Always check the zone first, to make sure we lie about it existing.
+	 */
+	if (crgetzoneid(credp) != GLOBAL_ZONEID)
+		return (ENOENT);
+
+	if (otyp & (FNDELAY | FEXCL))
+		return (EINVAL);
+
+	if (drv_priv(credp) != 0)
+		return (EPERM);
+
+	if (otyp & OTYP_BLK || !(otyp & OTYP_CHR))
+		return (ENOTSUP);
+
+	/* XXX We should maybe reduce this for just getting the status */
+	if ((flag & (FREAD | FWRITE)) != (FREAD | FWRITE))
+		return (EINVAL);
+
+	idx = ccid_minor_find(getminor(*devp));
+	if (idx == NULL) {
+		return (ENOENT);
+	}
+
+	/*
+	 * We don't expect anyone to be able to get a non-slot related minor. If
+	 * that somehow happens, guard against it and error out.
+	 */
+	if (!idx->cmi_isslot) {
+		return (ENOENT);
+	}
+
+	slot = idx->cmi_data.cmi_slot;
+	cmp = kmem_zalloc(sizeof (ccid_minor_t), KM_SLEEP);
+
+	cmp->cm_idx.cmi_minor = CCID_MINOR_INVALID;
+	cmp->cm_idx.cmi_isslot = B_FALSE;
+	cmp->cm_idx.cmi_data.cmi_user = cmp;
+	if (!ccid_minor_idx_alloc(&cmp->cm_idx, B_FALSE)) {
+		kmem_free(cmp, sizeof (ccid_minor_t));
+		return (ENOSPC);
+	}
+	cv_init(&cmp->cm_excl_cv, NULL, CV_DRIVER, NULL);
+	cv_init(&cmp->cm_read_cv, NULL, CV_DRIVER, NULL);
+	cv_init(&cmp->cm_iowait_cv, NULL, CV_DRIVER, NULL);
+	cmp->cm_opener = crdup(credp);
+	cmp->cm_slot = slot;
+	*devp = makedevice(getmajor(*devp), cmp->cm_idx.cmi_minor);
+
+	mutex_enter(&slot->cs_ccid->ccid_mutex);
+	list_insert_tail(&slot->cs_minors, cmp);
+	mutex_exit(&slot->cs_ccid->ccid_mutex);
+
+	return (0);
+}
+
+/*
+ * Copy a command which may have a message block chain out to the user.
+ */
+static int
+ccid_read_copyout(struct uio *uiop, const mblk_t *mp)
+{
+	offset_t off;
+
+	off = uiop->uio_loffset;
+	VERIFY3P(mp->b_next, ==, NULL);
+
+	for (; mp != NULL; mp = mp->b_cont) {
+		int ret;
+
+		if (MBLKL(mp) == 0)
+			continue;
+
+		ret = uiomove(mp->b_rptr, MBLKL(mp), UIO_READ, uiop);
+		if (ret != 0) {
+			return (EFAULT);
+		}
+	}
+
+	uiop->uio_loffset = off;
+	return (0);
+}
+
+/*
+ * Called to indicate that we are ready for a user to consume the I/O.
+ */
+static void
+ccid_user_io_done(ccid_t *ccid, ccid_slot_t *slot)
+{
+	ccid_minor_t *cmp;
+
+	VERIFY(MUTEX_HELD(&ccid->ccid_mutex));
+
+	slot->cs_io.ci_flags &= ~CCID_IO_F_IN_PROGRESS;
+	slot->cs_io.ci_flags |= CCID_IO_F_DONE;
+	cmp = slot->cs_excl_minor;
+	if (cmp != NULL) {
+		pollwakeup(&cmp->cm_pollhead, POLLIN | POLLRDNORM);
+		cv_signal(&cmp->cm_read_cv);
+	}
+}
+
+static void
+ccid_teardown_tpdu_t1(ccid_t *ccid, ccid_slot_t *slot, int error)
+{
+	/*
+	 * First check if there's an I/O in progress. If not, then we're done
+	 * here and there's nothing for us to really do.
+	 */
+	if ((slot->cs_io.ci_flags & CCID_IO_F_IN_PROGRESS) == 0) {
+		return;
+	}
+
+	/*
+	 * There's an outstanding I/O. The first thing we need to do is to
+	 * complete the command from a user perspective so we can disassociate
+	 * our state from it.
+	 */
+	slot->cs_io.ci_errno = error;
+	ccid_user_io_done(ccid, slot);
+
+	/*
+	 * Set the fact that the slot should block until such an I/O is
+	 * complete. We cannot do anything about outstanding T=1 behavior at
+	 * this point in time. The only thing that we can do is wait for the
+	 * next command completion and then act upon it.
+	 */
+	slot->cs_flags |= CCID_SLOT_F_NEED_IO_TEARDOWN;
+}
+
+static void
+ccid_init_tpdu_t1(ccid_t *ccid, ccid_slot_t *slot)
+{
+	t1_state_icc_init(&slot->cs_io.ci_t1, slot->cs_icc.icc_atr_data,
+	    ccid->ccid_bufsize);
+}
+
+static void
+ccid_fini_tpdu_t1(ccid_t *ccid, ccid_slot_t *slot)
+{
+	t1_state_icc_fini(&slot->cs_io.ci_t1);
+}
+
+/*
+ * This is called in response to us having a command completed for a T=1 TPDU.
+ * At this point we need to go through and now advance the state machine that
+ * we've created and figure out what the next step is. Unlike with APDU level
+ * transfers, we may need to go and send additional commands for the clients
+ * APDU.
+ */
+static void
+ccid_complete_tpdu_t1(ccid_t *ccid, ccid_slot_t *slot, ccid_command_t *cc)
+{
+	const void *buf;
+	size_t len;
+	mblk_t *mp;
+	int ret;
+	ccid_reply_command_status_t crs;
+	ccid_reply_icc_status_t cis;
+	t1_validate_t t1err;
+	t1_state_t *t1 = &slot->cs_io.ci_t1;
+
+	VERIFY(MUTEX_HELD(&ccid->ccid_mutex));
+	VERIFY3P(slot->cs_io.ci_command, ==, cc);
+
+	/*
+	 * XXX First check whether or not we've been asked to teardown this I/O.
+	 * The steps that we take for this teardown will depend on what's going
+	 * on with the ICC or reader. Presuming that the ICC is still present
+	 * and not being reset, we'll need to terminate this gracefully.
+	 * Otherwise, we can basically not worry about cleaning this up beyond
+	 * the logical state because the hardware is being reset or going away,
+	 * so we don't have to issue new commands.
+	 */
+	if ((slot->cs_flags & CCID_SLOT_F_NEED_IO_TEARDOWN) != 0) {
+		if ((slot->cs_flags & CCID_SLOT_F_NEED_TXN_RESET) != 0 ||
+		    (slot->cs_flags & CCID_SLOT_F_ACTIVE) == 0) {
+			/* We can just drop our state now. */
+			t1_state_cmd_fini(&slot->cs_io.ci_t1);
+			ccid_slot_io_teardown_done(slot);
+			return;
+		}
+
+		cmn_err(CE_PANIC, "implement T=1 abort logic");
+	}
+
+	/*
+	 * XXX At this time we do not properly implement the state machine that
+	 * is described by the ISO/IEC 7816-3:2006 specification. If we get
+	 * errors at a reader level or a failure to transmit the command, that
+	 * might leave the ICC in an arbitrary state. We need to handle this and
+	 * go from there. It's likely that we should treat this as a warm reset
+	 * case like everything else and basically return EIO.
+	 */
+	if (cc->cc_state > CCID_COMMAND_COMPLETE) {
+		/*
+		 * XXX Take out the system until we fix this.
+		 */
+		cmn_err(CE_PANIC, "implement cc->cc_state > CCID_COMMAND_COMPLETED case");
+	}
+
+	/*
+	 * Check the CCID command level case. If we were told the slot is going
+	 * away, mark that and notify the user that the command is done.
+	 * 
+	 * XXX In terms of failure we should be looking at one of several
+	 * different things here. We should see if there was a bit error, etc.
+	 * and act accordingly per the spec.
+	 */
+	ccid_command_status_decode(cc, &crs, &cis, NULL);
+	if (crs == CCID_REPLY_STATUS_FAILED && cis == CCID_REPLY_ICC_MISSING) {
+		/*
+		 * The ICC was removed. The user will likely be notified of this
+		 * at some point soon. Keep the ccid_command_t around until they
+		 * call read for debugging purposes.
+		 */
+		slot->cs_io.ci_errno = ENXIO;
+		ccid_user_io_done(ccid, slot);
+		return;
+	} else if (crs != CCID_REPLY_STATUS_COMPLETE) {
+		/* XXX */
+		cmn_err(CE_PANIC, "implement crs != CCID_REPLY_STATUS_COMPLETE case");
+	}
+
+	/*
+	 * The system has already verified that the CCID payload length makes
+	 * sense for the message block, so we do not need to check that here as
+	 * we take ownership of the message block from the command and free the
+	 * command.
+	 */
+	mp = cc->cc_response;
+	cc->cc_response = NULL;
+	mp->b_rptr += sizeof (ccid_header_t);
+
+	slot->cs_io.ci_command = NULL;
+	ccid_command_free(cc);
+	cc = NULL;
+
+	if ((t1err = t1_reply(t1, mp)) != T1_VALIDATE_OK) {
+		ccid_error(ccid, "!Received t1 error (%u): %s", t1err, t1_errmsg(t1));
+	}
+
+	switch (t1_step(t1)) {
+	case T1_ACTION_SEND_COMMAND:
+		break;
+	case T1_ACTION_WARM_RESET:
+		/* XXX Actually issue the reset */
+		slot->cs_io.ci_errno = EIO;
+		ccid_user_io_done(ccid, slot);
+		return;
+	case T1_ACTION_DONE:
+		/*
+		 * Complete and free this I/O from a T=1 perspective. The data
+		 * will be saved for the user.
+		 */
+		slot->cs_io.ci_errno = 0;
+		slot->cs_io.ci_data = t1_state_cmd_reply_take(&slot->cs_io.ci_t1);
+		t1_state_cmd_fini(&slot->cs_io.ci_t1);
+		VERIFY3P(slot->cs_io.ci_data, !=, NULL);
+		ccid_user_io_done(ccid, slot);
+		return;
+	}
+
+	/*
+	 * We've been asked to send another command by the T=1 state machine. Do
+	 * so.
+	 */
+	t1_data(t1, &buf, &len);
+	/*
+	 * XXX Right now we're purposefully not dropping the lock across the
+	 * command allocation. I'm not sure if that's good or not. THe problem
+	 * is that if we drop it, we need to make sure that the ICC state is
+	 * still good. If not, then we would need to throw this out, but it
+	 * means that the system can advance in the face of memory pressure,
+	 * which is good.
+	 *
+	 * XXX We need to actually ask the T=1 state machine for the WTX for
+	 * this block. We also may need to adjust the timeout on the USB command.
+	 */
+	if ((ret = ccid_command_alloc(ccid, slot, B_FALSE, NULL, len,
+	    CCID_REQUEST_TRANSFER_BLOCK, 0, 0, 0,
+	    &cc)) != 0) {
+		slot->cs_io.ci_errno = ENOMEM;
+		ccid_user_io_done(ccid, slot);
+		return;
+	}
+	cc->cc_flags |= CCID_COMMAND_F_USER;
+	ccid_command_bcopy(cc, buf, len);
+
+	/*
+	 * Now, finally drop the lock to queue the command and mark that this is
+	 * our current command.
+	 *
+	 * XXX We should probably put the preparing flag here.
+	 */
+	slot->cs_io.ci_command = cc;
+	mutex_exit(&ccid->ccid_mutex);
+
+	if ((ret = ccid_command_queue(ccid, cc)) != 0) {
+		mutex_enter(&ccid->ccid_mutex);
+		/* XXX Do we need to clean up the T=1 state here potentially? Or
+		 * can we leave it to be cleaned up by something else that next
+		 * uses it? Because we've dropped the lock, it's not clear what
+		 * we can or cannot do.
+		 *
+		 * XXX For the moment I'm going to mark this command done. This
+		 * is really getting far too complicated.
+		 */
+		slot->cs_io.ci_command = NULL;
+		ccid_command_free(cc);
+		slot->cs_io.ci_errno = ENOMEM;
+		ccid_user_io_done(ccid, slot);
+		return;
+	}
+
+	mutex_enter(&ccid->ccid_mutex);
+}
+
+static int
+ccid_write_tpdu_t1(ccid_t *ccid, ccid_slot_t *slot)
+{
+	int ret;
+	ccid_command_t *cc;
+	const void *buf;
+	size_t len;
+
+	VERIFY(MUTEX_HELD(&ccid->ccid_mutex));
+
+	/*
+	 * Initialize a new command and kick off the internal state machine.
+	 */
+	t1_state_cmd_init(&slot->cs_io.ci_t1, slot->cs_io.ci_ibuf,
+	    slot->cs_io.ci_ilen);
+
+	switch (t1_step(&slot->cs_io.ci_t1)) {
+	case T1_ACTION_SEND_COMMAND:
+		break;
+	case T1_ACTION_WARM_RESET:
+	case T1_ACTION_DONE:
+		/* XXX Figure out if this can happen. */
+		return (EIO);
+	}
+
+	t1_data(&slot->cs_io.ci_t1, &buf, &len);
+
+	/*
+	 * XXX Right now we're purposefully not dropping the lock across the
+	 * command allocation. I'm not sure if that's good or not. The problem
+	 * is that if we drop it, we need to make sure that the ICC state is
+	 * still good. If not, then we would need to throw this out, but it
+	 * means that the system can advance in the face of memory pressure,
+	 * which is good.
+	 */
+	if ((ret = ccid_command_alloc(ccid, slot, B_FALSE, NULL, len,
+	    CCID_REQUEST_TRANSFER_BLOCK, 0, 0, 0,
+	    &cc)) != 0) {
+		/* XXX Invalidate command state? */
+		return (ret);
+	}
+	cc->cc_flags |= CCID_COMMAND_F_USER;
+	ccid_command_bcopy(cc, buf, len);
+
+	/*
+	 * Before we submit this command, assign it to our internal state. We
+	 * need to do this before we submit the command. Otherwise, we could be
+	 * pathologically scheduled and not get the chance.
+	 */
+	slot->cs_io.ci_command = cc;
+
+	/*
+	 * Now, finally drop the lock to queue the command.
+	 */
+	mutex_exit(&ccid->ccid_mutex);
+
+	if ((ret = ccid_command_queue(ccid, cc)) != 0) {
+		mutex_enter(&ccid->ccid_mutex);
+		/* XXX Do we need to clean up the T=1 state here potentially? Or
+		 * can we leave it to be cleaned up by something else that next
+		 * uses it? Becuse we've dropped the lock, it's not clear what
+		 * we can or cannot do.
+		 */
+		slot->cs_io.ci_command = NULL;
+		ccid_command_free(cc);
+		return (ret);
+	}
+
+	mutex_enter(&ccid->ccid_mutex);
+
+	return (0);
+}
+
+/*
+ * This is called in a few different sitautions. It's called when an exclusive
+ * hold is being released by a user on a the slot. It's also called when the ICC
+ * is removed, the reader has been unplugged, or the ICC is being reset. In all
+ * these cases we need to make sure that I/O is taken care of and we won't be
+ * leaving behind vestigial garbage.
+ */
+static void
+ccid_teardown_apdu(ccid_t *ccid, ccid_slot_t *slot, int error)
+{
+	ccid_command_t *cc;
+
+	VERIFY(MUTEX_HELD(&ccid->ccid_mutex));
+
+	/*
+	 * If no I/O is in progress, then there's nothing to do at our end.
+	 */
+	if ((slot->cs_io.ci_flags & CCID_IO_F_IN_PROGRESS) == 0) {
+		return;
+	}
+
+	slot->cs_io.ci_errno = error;
+	ccid_user_io_done(ccid, slot);
+
+	/*
+	 * There is still I/O going on. We need to mark this on the slot such
+	 * that no one can gain ownership of it or issue commands. This will
+	 * block hand off of a slot.
+	 */
+	slot->cs_flags |= CCID_SLOT_F_NEED_IO_TEARDOWN;
+}
+
+/*
+ * This function is called in response to a CCID command completing.
+ */
+static void
+ccid_complete_apdu(ccid_t *ccid, ccid_slot_t *slot, ccid_command_t *cc)
+{
+	ccid_minor_t *cmp;
+	ccid_reply_command_status_t crs;
+	ccid_reply_icc_status_t cis;
+	ccid_command_err_t cce;
+
+	VERIFY(MUTEX_HELD(&ccid->ccid_mutex));
+	VERIFY3P(slot->cs_io.ci_command, ==, cc);
+
+	/*
+	 * This completion could be called due to the fact that a user is no
+	 * longer present, but we still have outstanding work to do in the
+	 * stack. As such, we need to go through and check if the flag was set
+	 * on the slot during teardown and if so, clean it up now.
+	 *
+	 * XXX Once this is done, we may be able to proceed with I/O depending
+	 * on what else is happening. So signal that fact or at least check.
+	 * This needs to do more than just signal on a CV, we may need to do
+	 * various POLL activities.
+	 */
+	if ((slot->cs_flags & CCID_SLOT_F_NEED_IO_TEARDOWN) != 0) {
+		ccid_command_free(cc);
+		slot->cs_io.ci_command = NULL;
+		ccid_slot_io_teardown_done(slot);
+		return;
+	}
+
+	/*
+	 * Process this command and figure out what we should logically be
+	 * returning to the user.
+	 *
+	 * XXX If the command did not complete successfully, then we need to
+	 * request that the slot be reset.
+	 */
+	if (cc->cc_state != CCID_COMMAND_COMPLETE) {
+		slot->cs_io.ci_errno = EIO;
+		goto consume;
+	}
+
+	ccid_command_status_decode(cc, &crs, &cis, &cce);
+	if (crs == CCID_REPLY_STATUS_COMPLETE) {
+		mblk_t *mp;
+
+		mp = cc->cc_response;
+		cc->cc_response = NULL;
+		mp->b_rptr += sizeof (ccid_header_t);
+		slot->cs_io.ci_errno = 0;
+		slot->cs_io.ci_data = mp;
+	} else if (cis == CCID_REPLY_ICC_MISSING) {
+		slot->cs_io.ci_errno = ENXIO;
+	} else {
+		/*
+		 * XXX There are a few more semantic things we can do
+		 * with the errors here that we're throwing out and
+		 * lumping as EIO. Oh well.
+		 */
+		slot->cs_io.ci_errno = EIO;
+	}
+
+	/*
+	 * Now, we can go ahead and wake up a reader to process this command.
+	 */
+consume:
+	slot->cs_io.ci_command = NULL;
+	ccid_command_free(cc);
+	ccid_user_io_done(ccid, slot);
+}
+
+/*
+ * We have the user buffer in the CCID slot. Given that, transform it into
+ * something that we can send to the device. For APDU's this is simply creating
+ * a transfer command and copying it into that buffer.
+ */
+static int
+ccid_write_apdu(ccid_t *ccid, ccid_slot_t *slot)
+{
+	int ret;
+	ccid_command_t *cc;
+
+	VERIFY(MUTEX_HELD(&ccid->ccid_mutex));
+
+	if ((ret = ccid_command_alloc(ccid, slot, B_FALSE, NULL,
+	    slot->cs_io.ci_ilen, CCID_REQUEST_TRANSFER_BLOCK, 0, 0, 0,
+	    &cc)) != 0) {
+		mutex_enter(&ccid->ccid_mutex);
+		return (ret);
+	}
+
+	cc->cc_flags |= CCID_COMMAND_F_USER;
+	ccid_command_bcopy(cc, slot->cs_io.ci_ibuf, slot->cs_io.ci_ilen);
+
+	slot->cs_io.ci_command = cc;
+	mutex_exit(&ccid->ccid_mutex);
+
+	if ((ret = ccid_command_queue(ccid, cc)) != 0) {
+		mutex_enter(&ccid->ccid_mutex);
+		slot->cs_io.ci_command = NULL;
+		ccid_command_free(cc);
+		return (ret);
+	}
+
+	mutex_enter(&ccid->ccid_mutex);
+
+	return (0);
+}
+
+static int
+ccid_read(dev_t dev, struct uio *uiop, cred_t *credp)
+{
+	int ret;
+	ccid_minor_idx_t *idx;
+	ccid_minor_t *cmp;
+	ccid_slot_t *slot;
+	ccid_t *ccid;
+	boolean_t done;
+
+	if (uiop->uio_resid <= 0) {
+		return (EINVAL);
+	}
+
+	if ((idx = ccid_minor_find(getminor(dev))) == NULL) {
+		return (ENOENT);
+	}
+
+	if (idx->cmi_isslot) {
+		return (ENXIO);
+	}
+
+	cmp = idx->cmi_data.cmi_user;
+	slot = cmp->cm_slot;
+	ccid = slot->cs_ccid;
+
+	mutex_enter(&ccid->ccid_mutex);
+	if ((ccid->ccid_flags & CCID_F_DISCONNECTED) != 0) {
+		mutex_exit(&ccid->ccid_mutex);
+		return (ENODEV);
+	}
+
+	/*
+	 * First, check if we have exclusive access. If not, we're done.
+	 */
+	if (!(cmp->cm_flags & CCID_MINOR_F_HAS_EXCL)) {
+		mutex_exit(&ccid->ccid_mutex);
+		return (EACCES);
+	}
+
+	/*
+	 * While it's tempting to mirror ccid_write() here and check if we have
+	 * a tx or rx function, that actually has no relevance on read. The only
+	 * thing that matters is whether or not we actually have an I/O.
+	 */
+
+	/*
+	 * If there's been no write I/O issued, then this read is not allowed.
+	 * While this may seem like a silly constraint, it certainly simplifies
+	 * a lot of the surrounding logic and fits with the current consumer
+	 * model.
+	 */
+	if ((slot->cs_io.ci_flags & (CCID_IO_F_IN_PROGRESS | CCID_IO_F_DONE)) == 0) {
+		mutex_exit(&ccid->ccid_mutex);
+		return (ENODATA);
+	}
+
+	/*
+	 * If another thread is already blocked in read, then don't allow them
+	 * in. We only want to allow one thread to attempt to consume a read,
+	 * just as we only allow one thread to initiate a write.
+	 */
+	if ((cmp->cm_flags & CCID_MINOR_F_READ_WAITING) != 0) {
+		mutex_exit(&ccid->ccid_mutex);
+		return (EBUSY);
+	}
+
+	/*
+	 * Check if an I/O has completed. Once it has, call the protocol
+	 * specific code. Note that the lock may be dropped after polling. In
+	 * such a case we will have to logically recheck several conditions.
+	 *
+	 * Note, we don't really care if the slot is active or not as I/O could
+	 * have been in flight while the slot was inactive.
+	 */
+	while ((slot->cs_io.ci_flags & CCID_IO_F_DONE) == 0) {
+		if (uiop->uio_fmode & FNONBLOCK) {
+			mutex_exit(&ccid->ccid_mutex);
+			return (EWOULDBLOCK);
+		}
+
+		/*
+		 * While we perform a cv_wait_sig() we'll end up dropping the
+		 * CCID mutex. This means that we need to notify the rest of the
+		 * driver that a thread is blocked in read. This is used not
+		 * only for excluding multiple threads trying to read from the
+		 * device, but more importantly so that we know that if the ICC
+		 * or reader are removed, that we need to wake up this thread.
+		 */
+		cmp->cm_flags |= CCID_MINOR_F_READ_WAITING;
+		ret = cv_wait_sig(&cmp->cm_read_cv, &ccid->ccid_mutex);
+		cmp->cm_flags &= ~CCID_MINOR_F_READ_WAITING;
+		cv_signal(&cmp->cm_iowait_cv);
+
+		if (ret == 0) {
+			mutex_exit(&ccid->ccid_mutex);
+			return (EINTR);
+		}
+
+		/*
+		 * Check if the reader has been removed. We do not need to check
+		 * for other conditions, as we'll end up being told that the I/O
+		 * is done and that the error has been set.
+		 */
+		if ((ccid->ccid_flags & CCID_F_DISCONNECTED) != 0) {
+			mutex_exit(&ccid->ccid_mutex);
+			return (ENODEV);
+		}
+	}
+
+	/*
+	 * We'll either have an error or data available for the user at this
+	 * point that we can copy out. We need to make sure that it's not too
+	 * large. The data should have already been adjusted such that we only
+	 * have data payloads.
+	 */
+	done = B_FALSE;
+	if (slot->cs_io.ci_errno == 0) {
+		size_t mlen;
+
+		mlen = msgsize(slot->cs_io.ci_data);
+		if (mlen > uiop->uio_resid) {
+			ret = EOVERFLOW;
+		} else {
+			if ((ret = ccid_read_copyout(uiop, slot->cs_io.ci_data)) == 0) {
+				done = B_TRUE;
+			}
+		}
+	} else {
+		ret = slot->cs_io.ci_errno;
+		done = B_TRUE;
+	}
+
+	if (done) {
+		/*
+		 * XXX Commonize this with the I/O cleanup in
+		 * ccid_slot_excl_rele().
+		 */
+		freemsg(slot->cs_io.ci_data);
+		slot->cs_io.ci_data = NULL;
+		slot->cs_io.ci_errno = 0;
+		slot->cs_io.ci_flags &= ~CCID_IO_F_DONE;
+		slot->cs_io.ci_ilen = 0;
+		bzero(slot->cs_io.ci_ibuf, sizeof (slot->cs_io.ci_ibuf));
+		/* XXX Signal next write may be able to happen at this point */
+	}
+
+	mutex_exit(&ccid->ccid_mutex);
+
+	return (ret);
+}
+
+static int
+ccid_write(dev_t dev, struct uio *uiop, cred_t *credp)
+{
+	int ret;
+	ccid_minor_idx_t *idx;
+	ccid_minor_t *cmp;
+	ccid_slot_t *slot;
+	ccid_t *ccid;
+	mblk_t *mp = NULL;
+	size_t len, cbytes;
+
+	if (uiop->uio_resid > CCID_APDU_LEN_MAX) {
+		return (E2BIG);
+	}
+
+	if (uiop->uio_resid <= 0) {
+		return (EINVAL);
+	}
+
+	len = uiop->uio_resid;
+	idx = ccid_minor_find(getminor(dev));
+	if (idx == NULL) {
+		return (ENOENT);
+	}
+
+	if (idx->cmi_isslot) {
+		return (ENXIO);
+	}
+
+	cmp = idx->cmi_data.cmi_user;
+	slot = cmp->cm_slot;
+	ccid = slot->cs_ccid;
+
+	/*
+	 * Now that we have the slot, verify whether or not we can perform this
+	 * I/O.
+	 */
+	mutex_enter(&ccid->ccid_mutex);
+	if ((ccid->ccid_flags & CCID_F_DISCONNECTED) != 0) {
+		mutex_exit(&ccid->ccid_mutex);
+		return (ENODEV);
+	}
+
+	/*
+	 * Check if we have exclusive access and if there's a card present. If
+	 * not, both are errors.
+	 */
+	if (!(cmp->cm_flags & CCID_MINOR_F_HAS_EXCL)) {
+		mutex_exit(&ccid->ccid_mutex);
+		return (EACCES);
+	}
+
+	if (!(slot->cs_flags & CCID_SLOT_F_ACTIVE)) {
+		mutex_exit(&ccid->ccid_mutex);
+		return (ENXIO);
+	}
+
+	/*
+	 * Make sure that we have a supported transmit function.
+	 */
+	if (slot->cs_icc.icc_tx == NULL) {
+		mutex_exit(&ccid->ccid_mutex);
+		return (ENOTSUP);
+	}
+
+	/*
+	 * See if another command is in progress. If so, try to claim it.
+	 * Otherwise, fail with EBUSY. Note, we only fail for commands that are
+	 * user initiated. There may be other commands that are ongoing in the
+	 * system.
+	 */
+	if ((slot->cs_io.ci_flags & CCID_IO_F_POLLOUT_FLAGS) != 0) {
+		mutex_exit(&ccid->ccid_mutex);
+		return (EBUSY);
+	}
+
+	/*
+	 * Use uiocopy and not uiomove. This way if we fail for whatever reason,
+	 * we don't have to worry about restoring the original buffer.
+	 */
+	if (uiocopy(slot->cs_io.ci_ibuf, len, UIO_WRITE, uiop, &cbytes) != 0) {
+		mutex_exit(&ccid->ccid_mutex);
+		return (EFAULT);
+	}
+
+	slot->cs_io.ci_ilen = len;
+	slot->cs_io.ci_flags |= CCID_IO_F_PREPARING;
+	slot->cs_io.ci_omp = NULL;
+
+	/*
+	 * Now that we're here, go ahead and call the actual tx function.
+	 */
+	if ((ret = slot->cs_icc.icc_tx(ccid, slot)) != 0) {
+		/*
+		 * The command wasn't actually transmitted. In this case we need
+		 * to reset the copied in data and signal anyone who is polling
+		 * that this is writeable again. We don't have to worry about
+		 * readers at this point, as they won't get in unless
+		 * CCID_IO_F_IN_PROGRESS has been set.
+		 */
+		slot->cs_io.ci_ilen = 0;
+		bzero(slot->cs_io.ci_ibuf, sizeof (slot->cs_io.ci_ibuf));
+		slot->cs_io.ci_flags &= ~CCID_IO_F_PREPARING;
+		/*
+		 * XXX We should be checking more conditions then just this. We
+		 * don't want to signal, if for example, we're disconnected, or
+		 * we're going to end up going away, etc.
+		 */
+		if (slot->cs_excl_minor != NULL) {
+			pollwakeup(&slot->cs_excl_minor->cm_pollhead, POLLOUT);
+		}
+	} else {
+		slot->cs_io.ci_flags &= ~CCID_IO_F_PREPARING;
+		slot->cs_io.ci_flags |= CCID_IO_F_IN_PROGRESS;
+		uiop->uio_resid -= cbytes;
+	}
+	/*
+	 * Notify a waiter that we've moved on.
+	 */
+	cv_signal(&slot->cs_excl_minor->cm_iowait_cv);
+	mutex_exit(&ccid->ccid_mutex);
+
+	return (ret);
+}
+
+static int
+ccid_ioctl_status(ccid_slot_t *slot, intptr_t arg, int mode)
+{
+	uccid_cmd_status_t ucs;
+	ccid_t *ccid = slot->cs_ccid;
+
+	if (ddi_copyin((void *)arg, &ucs, sizeof (ucs), mode & FKIOCTL) != 0)
+		return (EFAULT);
+
+	if (ucs.ucs_version != UCCID_VERSION_ONE)
+		return (EINVAL);
+
+	ucs.ucs_status = 0;
+	mutex_enter(&slot->cs_ccid->ccid_mutex);
+	if ((slot->cs_ccid->ccid_flags & CCID_F_DISCONNECTED) != 0) {
+		mutex_exit(&slot->cs_ccid->ccid_mutex);
+		return (ENODEV);
+	}
+
+	ucs.ucs_instance = ddi_get_instance(slot->cs_ccid->ccid_dip);
+	ucs.ucs_slot = slot->cs_slotno;
+
+	if (slot->cs_flags & CCID_SLOT_F_PRESENT)
+		ucs.ucs_status |= UCCID_STATUS_F_CARD_PRESENT;
+	if (slot->cs_flags & CCID_SLOT_F_ACTIVE)
+		ucs.ucs_status |= UCCID_STATUS_F_CARD_ACTIVE;
+
+	if (slot->cs_atr != NULL) {
+		ucs.ucs_atrlen = MIN(UCCID_ATR_MAX, MBLKL(slot->cs_atr));
+		bcopy(slot->cs_atr->b_rptr, ucs.ucs_atr, ucs.ucs_atrlen);
+	} else {
+		bzero(ucs.ucs_atr, sizeof (ucs.ucs_atr));
+		ucs.ucs_atrlen = 0;
+	}
+
+	bcopy(&ccid->ccid_class, &ucs.ucs_class, sizeof (ucs.ucs_class));
+
+	if (ccid->ccid_dev_data->dev_product != NULL) {
+		(void) strlcpy(ucs.ucs_product, ccid->ccid_dev_data->dev_product,
+		    sizeof (ucs.ucs_product));
+		ucs.ucs_status |= UCCID_STATUS_F_PRODUCT_VALID;
+	} else {
+		ucs.ucs_product[0] = '\0';
+	}
+
+	if (ccid->ccid_dev_data->dev_serial != NULL) {
+		(void) strlcpy(ucs.ucs_serial, ccid->ccid_dev_data->dev_serial,
+		    sizeof (ucs.ucs_serial));
+		ucs.ucs_status |= UCCID_STATUS_F_SERIAL_VALID;
+	} else {
+		ucs.ucs_serial[0] = '\0';
+	}
+	mutex_exit(&slot->cs_ccid->ccid_mutex);
+
+	if ((slot->cs_flags & CCID_SLOT_F_ACTIVE) != 0) {
+		ucs.ucs_status |= UCCID_STATUS_F_PARAMS_VALID;
+		ucs.ucs_prot = slot->cs_icc.icc_cur_protocol;
+		ucs.ucs_params = slot->cs_icc.icc_params;
+	}
+
+	if (ddi_copyout(&ucs, (void *)arg, sizeof (ucs), mode & FKIOCTL) != 0)
+		return (EFAULT);
+
+	return (0);
+}
+
+static int
+ccid_ioctl_txn_begin(ccid_slot_t *slot, ccid_minor_t *cmp, intptr_t arg, int mode)
+{
+	int ret;
+	uccid_cmd_txn_begin_t uct;
+	boolean_t nowait;
+
+	if (ddi_copyin((void *)arg, &uct, sizeof (uct), mode & FKIOCTL) != 0)
+		return (EFAULT);
+
+	if (uct.uct_version != UCCID_VERSION_ONE)
+		return (EINVAL);
+
+	if ((uct.uct_flags & ~UCCID_TXN_DONT_BLOCK) != 0)
+		return (EINVAL);
+	nowait = (uct.uct_flags & UCCID_TXN_DONT_BLOCK) != 0;
+
+	mutex_enter(&slot->cs_ccid->ccid_mutex);
+	if ((slot->cs_ccid->ccid_flags & CCID_F_DISCONNECTED) != 0) {
+		mutex_exit(&slot->cs_ccid->ccid_mutex);
+		return (ENODEV);
+	}
+	ret = ccid_slot_excl_req(slot, cmp, nowait);
+	mutex_exit(&slot->cs_ccid->ccid_mutex);
+
+	return (ret);
+}
+
+static int
+ccid_ioctl_txn_end(ccid_slot_t *slot, ccid_minor_t *cmp, intptr_t arg, int mode)
+{
+	int ret;
+	uccid_cmd_txn_end_t uct;
+	boolean_t nowait;
+
+	if (ddi_copyin((void *)arg, &uct, sizeof (uct), mode & FKIOCTL) != 0) {
+		return (EFAULT);
+	}
+
+	if (uct.uct_version != UCCID_VERSION_ONE) {
+		return (EINVAL);
+	}
+
+	if ((uct.uct_flags & ~(UCCID_TXN_END_RESET |
+	    UCCID_TXN_END_RELEASE)) != 0) {
+		return (EINVAL);
+	}
+
+	/*
+	 * Require at least one of these flags to be set.
+	 */
+	if ((((uct.uct_flags & UCCID_TXN_END_RESET) != 0) ^
+	    ((uct.uct_flags & UCCID_TXN_END_RELEASE) != 0)) == 0) {
+		return (EINVAL);
+	}
+
+	mutex_enter(&slot->cs_ccid->ccid_mutex);
+	if ((slot->cs_ccid->ccid_flags & CCID_F_DISCONNECTED) != 0) {
+		mutex_exit(&slot->cs_ccid->ccid_mutex);
+		return (ENODEV);
+	}
+
+	/* XXX ENXIO may not be a good idea here */
+	if (slot->cs_excl_minor != cmp) {
+		mutex_exit(&slot->cs_ccid->ccid_mutex);
+		return (ENXIO);
+	}
+	VERIFY3S(cmp->cm_flags & CCID_MINOR_F_HAS_EXCL, !=, 0);
+
+	if (uct.uct_flags & UCCID_TXN_END_RESET) {
+		cmp->cm_flags |= CCID_MINOR_F_TXN_RESET;
+	}
+	ccid_slot_excl_rele(slot);
+	mutex_exit(&slot->cs_ccid->ccid_mutex);
+
+	return (0);
+}
+
+static int
+ccid_ioctl_fionread(ccid_slot_t *slot, ccid_minor_t *cmp, intptr_t arg, int mode)
+{
+	int data;
+
+	mutex_enter(&slot->cs_ccid->ccid_mutex);
+	if ((slot->cs_ccid->ccid_flags & CCID_F_DISCONNECTED) != 0) {
+		mutex_exit(&slot->cs_ccid->ccid_mutex);
+		return (ENODEV);
+	}
+
+	if (!(cmp->cm_flags & CCID_MINOR_F_HAS_EXCL)) {
+		mutex_exit(&slot->cs_ccid->ccid_mutex);
+		return (EACCES);
+	}
+
+	if ((slot->cs_io.ci_flags & CCID_IO_F_DONE) != 0) {
+		mutex_exit(&slot->cs_ccid->ccid_mutex);
+		return (ENODATA);
+	}
+
+	/*
+	 * If there's an error, claim that there's at least one byte to read
+	 * even if it means we'll get the error and consume it. FIONREAD only
+	 * allows up to an int of data. Realistically because we don't allow
+	 * extended APDUs, the amount of data here should be always less than
+	 * INT_MAX.
+	 */
+	if (slot->cs_io.ci_errno != 0) {
+		data = 1;
+	} else {
+		size_t s = msgsize(slot->cs_io.ci_data);
+		data = MIN(s, INT_MAX);
+	}
+
+	if (ddi_copyout(&data, (void *)arg, sizeof (data), mode & FKIOCTL) != 0) {
+		mutex_exit(&slot->cs_ccid->ccid_mutex);
+		return (EFAULT);
+	}
+
+	mutex_exit(&slot->cs_ccid->ccid_mutex);
+	return (0);
+}
+
+static int
+ccid_ioctl_icc_modify(ccid_slot_t *slot, intptr_t arg, int mode)
+{
+	int ret;
+	uccid_cmd_icc_modify_t uci;
+	ccid_t *ccid;
+
+	if (ddi_copyin((void *)arg, &uci, sizeof (uci), mode & FKIOCTL) != 0) {
+		return (EFAULT);
+	}
+
+	if (uci.uci_version != UCCID_VERSION_ONE) {
+		return (EINVAL);
+	}
+
+	switch (uci.uci_action) {
+	case UCCID_ICC_POWER_ON:
+	case UCCID_ICC_POWER_OFF:
+	case UCCID_ICC_WARM_RESET:
+		break;
+	default:
+		return (EINVAL);
+	}
+
+	ccid = slot->cs_ccid;
+	mutex_enter(&ccid->ccid_mutex);
+	if ((slot->cs_ccid->ccid_flags & CCID_F_DISCONNECTED) != 0) {
+		mutex_exit(&slot->cs_ccid->ccid_mutex);
+		return (ENODEV);
+	}
+
+	/*
+	 * XXX
+	 */
+
+	mutex_exit(&ccid->ccid_mutex);
+
+	return (0);
+}
+
+static int
+ccid_ioctl(dev_t dev, int cmd, intptr_t arg, int mode, cred_t *credp, int
+    *rvalp)
+{
+	ccid_minor_idx_t *idx;
+	ccid_slot_t *slot;
+	ccid_minor_t *cmp;
+
+	idx = ccid_minor_find_user(getminor(dev));
+	if (idx == NULL) {
+		return (ENOENT);
+	}
+
+	if (idx->cmi_isslot) {
+		return (ENXIO);
+	}
+
+	cmp = idx->cmi_data.cmi_user;
+	slot = cmp->cm_slot;
+
+	switch (cmd) {
+	case UCCID_CMD_TXN_BEGIN:
+		return (ccid_ioctl_txn_begin(slot, cmp, arg, mode));
+	case UCCID_CMD_TXN_END:
+		return (ccid_ioctl_txn_end(slot, cmp, arg, mode));
+	case UCCID_CMD_STATUS:
+		return (ccid_ioctl_status(slot, arg, mode));
+	case FIONREAD:
+		return (ccid_ioctl_fionread(slot, cmp, arg, mode));
+	case UCCID_CMD_ICC_MODIFY:
+		return (ccid_ioctl_icc_modify(slot, arg, mode));
+	default:
+		break;
+	}
+
+	return (ENOTTY);
+}
+
+static int
+ccid_chpoll(dev_t dev, short events, int anyyet, short *reventsp,
+    struct pollhead **phpp)
+{
+	short ready = 0;
+	ccid_minor_idx_t *idx;
+	ccid_minor_t *cmp;
+	ccid_slot_t *slot;
+	ccid_t *ccid;
+
+	idx = ccid_minor_find_user(getminor(dev));
+	if (idx == NULL) {
+		return (ENOENT);
+	}
+
+	if (idx->cmi_isslot) {
+		return (ENXIO);
+	}
+
+	/*
+	 * First tear down the global index entry.
+	 */
+	cmp = idx->cmi_data.cmi_user;
+	slot = cmp->cm_slot;
+	ccid = slot->cs_ccid;
+
+	mutex_enter(&ccid->ccid_mutex);
+	if ((ccid->ccid_flags & CCID_F_DISCONNECTED) != 0) {
+		mutex_exit(&ccid->ccid_mutex);
+		return (ENODEV);
+	}
+
+	if (!(cmp->cm_flags & CCID_MINOR_F_HAS_EXCL)) {
+		mutex_exit(&ccid->ccid_mutex);
+		return (EACCES);
+	}
+
+	/*
+	 * If the CCID_IO_F_DONE flag is set, then we're always readable.
+	 * However, flags are insufficient to be writeable.
+	 */
+	if ((slot->cs_io.ci_flags & CCID_IO_F_DONE) != 0) {
+		ready |= POLLIN | POLLRDNORM;
+	} else if ((slot->cs_io.ci_flags & CCID_IO_F_POLLOUT_FLAGS) == 0) {
+		/*
+		 * XXX This isn't quite true, as we need to consider other
+		 * states of the device, ICC present, etc.
+		 */
+		ready |= POLLOUT;
+	}
+
+	if (!(slot->cs_flags & CCID_SLOT_F_PRESENT)) {
+		ready |= POLLHUP;
+	}
+
+	*reventsp = ready & events;
+	if ((*reventsp == 0 && !anyyet) || (events & POLLET)) {
+		*phpp = &cmp->cm_pollhead;
+	}
+
+	mutex_exit(&ccid->ccid_mutex);
+
+	return (0);
+}
+
+static int
+ccid_close(dev_t dev, int flag, int otyp, cred_t *credp)
+{
+	ccid_minor_idx_t *idx;
+	ccid_minor_t *cmp;
+	ccid_slot_t *slot;
+
+	idx = ccid_minor_find_user(getminor(dev));
+	if (idx == NULL) {
+		return (ENOENT);
+	}
+
+	/*
+	 * First tear down the global index entry.
+	 */
+	cmp = idx->cmi_data.cmi_user;
+	slot = cmp->cm_slot;
+	ccid_minor_idx_free(idx);
+
+	/*
+	 * If the minor node was closed without an explicit transaction end,
+	 * then we need to assume that the reader's ICC is in an arbitrary
+	 * state. For example, the ICC could have a specific PIV applet
+	 * selected. In such a case, the only safe thing to do is to force a
+	 * reset.
+	 */
+	mutex_enter(&slot->cs_ccid->ccid_mutex);
+	if ((cmp->cm_flags & CCID_MINOR_F_HAS_EXCL) != 0) {
+		cmp->cm_flags |= CCID_MINOR_F_TXN_RESET;
+		ccid_slot_excl_rele(slot);
+	}
+
+	list_remove(&slot->cs_minors, cmp);
+	mutex_exit(&slot->cs_ccid->ccid_mutex);
+
+	pollhead_clean(&cmp->cm_pollhead);
+	ccid_minor_free(cmp);
+
+	return (0);
+}
+
+static struct cb_ops ccid_cb_ops = {
+	ccid_open,		/* cb_open */
+	ccid_close,		/* cb_close */
+	nodev,			/* cb_strategy */
+	nodev,			/* cb_print */
+	nodev,			/* cb_dump */
+	ccid_read,		/* cb_read */
+	ccid_write,		/* cb_write */
+	ccid_ioctl,		/* cb_ioctl */
+	nodev,			/* cb_devmap */
+	nodev,			/* cb_mmap */
+	nodev,			/* cb_segmap */
+	ccid_chpoll,		/* cb_chpoll */
+	ddi_prop_op,		/* cb_prop_op */
+	NULL,			/* cb_stream */
+	D_MP,			/* cb_flag */
+	CB_REV,			/* cb_rev */
+	nodev,			/* cb_aread */
+	nodev			/* cb_awrite */
+};
+
+static struct dev_ops ccid_dev_ops = {
+	DEVO_REV,		/* devo_rev */
+	0,			/* devo_refcnt */
+	ccid_getinfo,		/* devo_getinfo */
+	nulldev,		/* devo_identify */
+	nulldev,		/* devo_probe */
+	ccid_attach,		/* devo_attach */
+	ccid_detach,		/* devo_detach */
+	nodev,			/* devo_reset */
+	&ccid_cb_ops,		/* devo_cb_ops */
+	NULL,			/* devo_bus_ops */
+	NULL,			/* devo_power */
+	ddi_quiesce_not_supported /* devo_quiesce */
+};
+
+static struct modldrv ccid_modldrv = {
+	&mod_driverops,
+	"USB CCID",
+	&ccid_dev_ops
+};
+
+static struct modlinkage ccid_modlinkage = {
+	MODREV_1,
+	{ &ccid_modldrv, NULL }
+};
+
+int
+_init(void)
+{
+	int ret;
+
+	if ((ret = ddi_soft_state_init(&ccid_softstate, sizeof (ccid_t),
+	    0)) != 0) {
+		return (ret);
+	}
+
+	if ((ccid_minors = id_space_create("ccid_minors", CCID_MINOR_MIN, INT_MAX)) == NULL) {
+		ddi_soft_state_fini(&ccid_softstate);
+		return (ret);
+	}
+
+	if ((ret = mod_install(&ccid_modlinkage)) != 0) {
+		id_space_destroy(ccid_minors);
+		ccid_minors = NULL;
+		ddi_soft_state_fini(&ccid_softstate);
+		return (ret);
+	}
+
+	mutex_init(&ccid_idxlock, NULL, MUTEX_DRIVER, NULL);
+	avl_create(&ccid_idx, ccid_idx_comparator, sizeof (ccid_minor_idx_t),
+	    offsetof(ccid_minor_idx_t, cmi_avl));
+
+	return (ret);
+}
+
+int
+_info(struct modinfo *modinfop)
+{
+	return (mod_info(&ccid_modlinkage, modinfop));
+}
+
+int
+_fini(void)
+{
+	int ret;
+
+	if ((ret = mod_remove(&ccid_modlinkage)) != 0) {
+		return (ret);
+	}
+
+	avl_destroy(&ccid_idx);
+	mutex_destroy(&ccid_idxlock);
+	id_space_destroy(ccid_minors);
+	ccid_minors = NULL;
+	ddi_soft_state_fini(&ccid_softstate);
+
+	return (ret);
+}
diff --git a/usr/src/uts/common/sys/Makefile b/usr/src/uts/common/sys/Makefile
index cee6dfb94d..7ae4558f97 100644
--- a/usr/src/uts/common/sys/Makefile
+++ b/usr/src/uts/common/sys/Makefile
@@ -1040,6 +1040,10 @@ USBWCMHDRS=		\
 UGENHDRS=           \
 	usb_ugen.h
 
+USBCCIDHDRS = \
+	ccid.h \
+	uccid.h
+
 HOTPLUGHDRS=	\
 	hpcsvc.h	\
 	hpctrl.h
@@ -1186,6 +1190,7 @@ CHECKHDRS=						\
 	$(SYSEVENTHDRS:%.h=sysevent/%.check)            \
 	$(CONTRACTHDRS:%.h=contract/%.check)            \
 	$(USBAUDHDRS:%.h=usb/clients/audio/%.check)   \
+	$(USBCCIDHDRS:%.h=usb/clients/ccid/%.check)	\
 	$(USBHUBDHDRS:%.h=usb/hubd/%.check)		\
 	$(USBHIDHDRS:%.h=usb/clients/hid/%.check)	\
 	$(USBMSHDRS:%.h=usb/clients/mass_storage/%.check)	\
@@ -1260,6 +1265,7 @@ CHECKHDRS=						\
 	$(ROOTUSBCDCHDRS)       \
 	$(ROOTUSBVIDHDRS)       \
 	$(ROOTUSBWCMHDRS)	\
+	$(ROOTUSBCCIDHDRS)	\
 	$(ROOTUGENHDRS)		\
 	$(ROOT1394HDRS)         \
 	$(ROOTHOTPLUGHDRS)	\
@@ -1318,6 +1324,7 @@ install_h:			\
 	$(ROOTUWBHDRS)		\
 	$(ROOTUWBAHDRS)		\
 	$(ROOTUSBHDRS)		\
+	$(ROOTUSBCCIDHDRS)	\
 	$(ROOTUSBAUDHDRS)	\
 	$(ROOTUSBHUBDHDRS)	\
 	$(ROOTUSBHIDHDRS)	\
diff --git a/usr/src/uts/common/sys/Makefile.syshdrs b/usr/src/uts/common/sys/Makefile.syshdrs
index dee5eef53a..c1a354e590 100644
--- a/usr/src/uts/common/sys/Makefile.syshdrs
+++ b/usr/src/uts/common/sys/Makefile.syshdrs
@@ -149,6 +149,9 @@ usb/clients/mass_storage/%.check:	usb/clients/mass_storage/%.h
 usb/clients/printer/%.check:  usb/clients/printer/%.h
 	$(DOT_H_CHECK)
 
+usb/clients/ccid/%.check:	usb/clients/ccid/%.h
+	$(DOT_H_CHECK)
+
 usb/clients/usbcdc/%.check:	usb/clients/usbcdc/%.h
 	$(DOT_H_CHECK)
 
@@ -231,6 +234,7 @@ ROOTDIRS=			\
 	$(ROOTDIR)/usb/clients/usbcdc  \
 	$(ROOTDIR)/usb/clients/video/usbvc  \
 	$(ROOTDIR)/usb/clients/usbinput/usbwcm \
+	$(ROOTDIR)/usb/clients/ccid \
 	$(ROOTDIR)/usb/clients/ugen  \
 	$(ROOTDIR)/1394         \
 	$(ROOTDIR)/rsm		\
@@ -311,6 +315,7 @@ ROOTUSBPRNHDRS= $(USBPRNHDRS:%=$(ROOTDIR)/usb/clients/printer/%)
 ROOTUSBCDCHDRS= $(USBCDCHDRS:%=$(ROOTDIR)/usb/clients/usbcdc/%)
 ROOTUSBVIDHDRS= $(USBVIDHDRS:%=$(ROOTDIR)/usb/clients/video/usbvc/%)
 ROOTUSBWCMHDRS= $(USBWCMHDRS:%=$(ROOTDIR)/usb/clients/usbinput/usbwcm/%)
+ROOTUSBCCIDHDRS= $(USBCCIDHDRS:%=$(ROOTDIR)/usb/clients/ccid/%)
 ROOTUGENHDRS= $(UGENHDRS:%=$(ROOTDIR)/usb/clients/ugen/%)
 
 ROOT1394HDRS= $(I1394HDRS:%=$(ROOTDIR)/1394/%)
diff --git a/usr/src/uts/common/sys/sunddi.h b/usr/src/uts/common/sys/sunddi.h
index 8ce8508114..4d943b8e89 100644
--- a/usr/src/uts/common/sys/sunddi.h
+++ b/usr/src/uts/common/sys/sunddi.h
@@ -247,6 +247,8 @@ extern "C" {
 						/* Fabric Devices */
 #define	DDI_NT_IB_ATTACHMENT_POINT	"ddi_ctl:attachment_point:ib"
 						/* IB devices */
+#define	DDI_NT_CCID_ATTACHMENT_POINT	"ddi_ctl:attachment_point:ccid"
+						/* CCID devices */
 
 #define	DDI_NT_AV_ASYNC "ddi_av:async"		/* asynchronous AV device */
 #define	DDI_NT_AV_ISOCH "ddi_av:isoch"		/* isochronous AV device */
diff --git a/usr/src/uts/common/sys/usb/clients/ccid/ccid.h b/usr/src/uts/common/sys/usb/clients/ccid/ccid.h
new file mode 100644
index 0000000000..20e841141f
--- /dev/null
+++ b/usr/src/uts/common/sys/usb/clients/ccid/ccid.h
@@ -0,0 +1,315 @@
+/*
+ * This file and its contents are supplied under the terms of the
+ * Common Development and Distribution License ("CDDL"), version 1.0.
+ * You may only use this file in accordance with the terms of version
+ * 1.0 of the CDDL.
+ *
+ * A full copy of the text of the CDDL should have accompanied this
+ * source.  A copy of the CDDL is also available via the Internet at
+ * http://www.illumos.org/license/CDDL.
+ */
+
+/*
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+
+#ifndef _SYS_USB_CCID_H
+#define	_SYS_USB_CCID_H
+
+/*
+ * CCID class driver definitions.
+ */
+
+#include <sys/stdint.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*
+ * Values for various Hardware, Mechanical, and Pin features. These come from
+ * the device's class descriptor.
+ */
+typedef enum ccid_class_voltage {
+	CCID_CLASS_VOLT_AUTO	= 0x00,
+	CCID_CLASS_VOLT_5_0	= 0x01,
+	CCID_CLASS_VOLT_3_0	= 0x02,
+	CCID_CLASS_VOLT_1_8	= 0x04
+} ccid_class_voltage_t;
+
+typedef enum ccid_class_mechanical {
+	CCID_CLASS_MECH_CARD_ACCEPT	= 0x01,
+	CCID_CLASS_MECH_CARD_EJECT	= 0x02,
+	CCID_CLASS_MECH_CARD_CAPTURE	= 0x04,
+	CCID_CLASS_MECH_CARD_LOCK	= 0x08
+} ccid_class_mechanical_t;
+
+typedef enum ccid_class_features {
+	CCID_CLASS_F_AUTO_PARAM_ATR	= 0x00000002,
+	CCID_CLASS_F_AUTO_ICC_ACTIVATE	= 0x00000004,
+	CCID_CLASS_F_AUTO_ICC_VOLTAGE	= 0x00000008,
+	CCID_CLASS_F_AUTO_ICC_CLOCK	= 0x00000010,
+	CCID_CLASS_F_AUTO_BAUD		= 0x00000020,
+	CCID_CLASS_F_AUTO_PARAM_NEG	= 0x00000040,
+	CCID_CLASS_F_AUTO_PPS		= 0x00000080,
+	CCID_CLASS_F_ICC_CLOCK_STOP	= 0x00000100,
+	CCID_CLASS_F_ALTNAD_SUP		= 0x00000200,
+	CCID_CLASS_F_AUTO_IFSD		= 0x00000400,
+	CCID_CLASS_F_TPDU_XCHG		= 0x00010000,
+	CCID_CLASS_F_SHORT_APDU_XCHG	= 0x00020000,
+	CCID_CLASS_F_EXT_APDU_XCHG	= 0x00040000,
+	CCID_CLASS_F_WAKE_UP		= 0x00100000
+} ccid_class_features_t;
+
+typedef enum ccid_class_pin {
+	CCID_CLASS_PIN_VERIFICATION	= 0x01,
+	CCID_CLASS_PIN_MODIFICATION	= 0x02
+} ccid_class_pin_t;
+
+/*
+ * CCID Class Descriptor
+ *
+ * This structure represents the CCID class descriptor. Note, it should not be a
+ * packed structure. This is designed to be a native representation. The raw
+ * structure will be parsed into this instead.
+ */
+typedef struct ccid_class_descr {
+	uint8_t		ccd_bLength;
+	uint8_t		ccd_bDescriptorType;
+	uint16_t	ccd_bcdCCID;
+	uint8_t		ccd_bMaxSlotIndex;
+	uint8_t		ccd_bVoltageSupport;
+	uint32_t	ccd_dwProtocols;
+	uint32_t	ccd_dwDefaultClock;
+	uint32_t	ccd_dwMaximumClock;
+	uint8_t		ccd_bNumClockSupported;
+	uint32_t	ccd_dwDataRate;
+	uint32_t	ccd_dwMaxDataRate;
+	uint8_t		ccd_bNumDataRatesSupported;
+	uint32_t	ccd_dwMaxIFSD;
+	uint32_t	ccd_dwSyncProtocols;
+	uint32_t	ccd_dwMechanical;
+	uint32_t	ccd_dwFeatures;
+	uint32_t	ccd_dwMaxCCIDMessageLength;
+	uint8_t		ccd_bClassGetResponse;
+	uint8_t		ccd_bClassEnvelope;
+	uint16_t	ccd_wLcdLayout;
+	uint8_t		ccd_bPinSupport;
+	uint8_t		ccd_bMaxCCIDBusySlots;
+} ccid_class_descr_t;
+
+/*
+ * Definitions for the supported versions of the CCID specification. The version
+ * is encoded in binary encoded decimal. The major version is in the upper 8
+ * bits and the minor version is in the lower 8 bits. We currently check for the
+ * major version to match.
+ */
+#define	CCID_VERSION_MAJOR(ver)	(((ver) & 0xff00) >> 8)
+#define	CCID_VERSION_MINOR(ver)	((ver) & 0x00ff)
+#define	CCID_VERSION_ONE	0x01
+
+/*
+ * This structure is used as the data for the CCID_REQUEST_SET_PARAMS request
+ * and the CCID_RESPONSE_PARAMETERS response. There are different structures for
+ * T=0 and T=1. These come from CCID r1.1 / Section 6.1.7.
+ */
+#pragma pack(1)
+typedef struct ccid_params_t0 {
+	uint8_t cp0_bmFindexDindex;
+	uint8_t cp0_bmTCCKST0;
+	uint8_t cp0_bGuardTimeT0;
+	uint8_t cp0_bWaitingIntegerT0;
+	uint8_t	cp0_bClockStop;
+} ccid_params_t0_t;
+
+#define	CCID_P_TCCKST0_DIRECT	0x00
+#define	CCID_P_TCCKST0_INVERSE	0x02
+
+typedef struct ccid_params_t1 {
+	uint8_t cp1_bmFindexDindex;
+	uint8_t cp1_bmTCCKST1;
+	uint8_t cp1_bGuardTimeT1;
+	uint8_t cp1_bmWaitingIntegersT1;
+	uint8_t cp1_bClockStop;
+	uint8_t cp1_bIFSC;
+	uint8_t cp1_bNadValue;
+} ccid_params_t1_t;
+#pragma pack()
+
+typedef union ccid_params {
+	ccid_params_t0_t ccp_t0;
+	ccid_params_t1_t ccp_t1;
+} ccid_params_t;
+
+/*
+ * Everything below this point is reserved for the kernel.
+ */
+#ifdef	_KERNEL
+
+/*
+ * These values come from CCID r1.1.0 Table 5.1-1 'Smart Card Device
+ * Descriptors'
+ */
+#define	CCID_DESCR_TYPE		0x21
+#define	CCID_DESCR_LENGTH	0x36
+
+
+/*
+ * Minimum and maximum value for a sequence number in the CCID specification.
+ * The sequence is a 1 byte unsigned value. The values are inclusive. We reserve
+ * the value of 0x00 so that we can use it as a sentinel in the ccid_command_t
+ * structure to know when we should or shouldn't free a command structure's
+ * sequence number back to the id space.
+ */
+#define	CCID_SEQ_MIN	0x01
+#define	CCID_SEQ_MAX	UINT8_MAX
+
+
+/*
+ * All structures from the specification must be packed.
+ */
+
+#pragma pack(1)
+
+/*
+ * Interrupt-IN messages codes.
+ */
+typedef enum ccid_intr_code {
+	CCID_INTR_CODE_SLOT_CHANGE	= 0x50,
+	CCID_INTR_CODE_HW_ERROR		= 0x51
+} ccid_intr_code_t;
+
+typedef enum ccid_intr_hwerr_code {
+	CCID_INTR_HWERR_OVERCURRENT	= 0x01
+} ccid_intr_hwerr_code_t;
+
+typedef struct ccid_intr_slot {
+	uint8_t	cis_type;
+	uint8_t	cis_state[];
+} ccid_intr_slot_t;
+
+typedef struct ccid_intr_hwerr {
+	uint8_t	cih_type;
+	uint8_t	cih_slot;
+	uint8_t	cih_seq;
+	uint8_t	cih_code;
+} ccid_intr_hwerr_t;
+
+/*
+ * Message request codes. These codes are based on CCID r1.1.0 Table 6.1-1
+ * 'Summary of Bulk-Out Messages'. The name from the standard is to the right of
+ * the enum.
+ */
+typedef enum ccid_request_code {
+	CCID_REQUEST_POWER_ON		= 0x62,	/* PC_to_RDR_IccPowerOn */
+	CCID_REQUEST_POWER_OFF		= 0x63,	/* PC_to_RDR_IccPowerOff */
+	CCID_REQUEST_SLOT_STATUS	= 0x65,	/* PC_to_RDR_GetSlotStatus */
+	CCID_REQUEST_TRANSFER_BLOCK	= 0x6f,	/* PC_to_RDR_XfrBlock */
+	CCID_REQUEST_GET_PARAMS		= 0x6c,	/* PC_to_RDR_GetParameters */
+	CCID_REQUEST_RESET_PARAMS	= 0x6d,	/* PC_to_RDR_ResetParameters */
+	CCID_REQUEST_SET_PARAMS		= 0x61,	/* PC_to_RDR_SetParameters */
+	CCID_REQUEST_ESCAPE		= 0x6b,	/* PC_to_RDR_Escape */
+	CCID_REQUEST_ICC_CLOCK		= 0x6e,	/* PC_to_RDR_IccClock */
+	CCID_REQUEST_T0APDU		= 0x6a,	/* PC_to_RDR_T0APDU */
+	CCID_REQUEST_SECURE		= 0x69,	/* PC_to_RDR_Secure */
+	CCID_REQUEST_MECHANICAL		= 0x71,	/* PC_to_RDR_Mechanica */
+	CCID_REQEUST_ABORT		= 0x72,	/* PC_to_RDR_Abort */
+	CCID_REQUEST_DATA_CLOCK		= 0x73 	/* PC_to_RDR_SetDataRateAnd */
+						/* ClockFrequency */
+} ccid_request_code_t;
+
+/*
+ * Message request codes. These codes are based on CCID r1.1.0 Table 6.2-1
+ * 'Summary of Bulk-In Messages'. The name from the standard is to the right of
+ * the enum.
+ */
+typedef enum ccid_response_code {
+	CCID_RESPONSE_DATA_BLOCK	= 0x80,	/* RDR_to_PC_DataBlock */
+	CCID_RESPONSE_SLOT_STATUS	= 0x81,	/* RDR_to_PC_SlotStatus */
+	CCID_RESPONSE_PARAMETERS	= 0x82, /* RDR_to_PC_Parameters */
+	CCID_RESPONSE_ESCAPE		= 0x83,	/* RDR_to_PC_Escape */
+	CCID_RESPONSE_DATA_CLOCK	= 0x84	/* RDR_to_PC_DataRateAnd */
+						/* Clock Frequency */
+} ccid_response_code_t;
+
+/*
+ * This represents the CCID command header that is used for every request and
+ * response.
+ */
+typedef struct ccid_header {
+	uint8_t		ch_mtype;
+	uint32_t	ch_length;	/* Length of ch_data in bytes */
+	uint8_t		ch_slot;	/* CCID slot to target */
+	uint8_t		ch_seq;		/* Request/Response sequence num */
+	uint8_t		ch_param0;	/* Request/Response specific */
+	uint8_t		ch_param1;	/* Request/Response specific */
+	uint8_t		ch_param2;	/* Request/Response specific */
+	uint8_t		ch_data[];	/* Optional Request/Response Data */
+} ccid_header_t;
+
+/*
+ * This structure is used as the data for the CCID_REQUEST_DATA_CLOCK and
+ * CCID_RESPONSE_DATA_CLOCK commands.
+ */
+typedef struct ccid_data_clock {
+	uint32_t	cdc_clock;
+	uint32_t	cdc_data;
+} ccid_data_clock_t;
+
+/*
+ * Macros and constants to take apart the slot status (in ch_param1) when a CCID
+ * reply comes in.
+ */
+#define	CCID_REPLY_ICC(x)	(x & 0x3)
+#define	CCID_REPLY_STATUS(x)	((x & 0xc0) >> 6)
+
+typedef enum {
+	CCID_REPLY_ICC_ACTIVE = 0,
+	CCID_REPLY_ICC_INACTIVE,
+	CCID_REPLY_ICC_MISSING
+} ccid_reply_icc_status_t;
+
+typedef enum {
+	CCID_REPLY_STATUS_COMPLETE = 0,
+	CCID_REPLY_STATUS_FAILED,
+	CCID_REPLY_STATUS_MORE_TIME
+} ccid_reply_command_status_t;
+
+/*
+ * Errors that are defined based when commands fail. These are based on CCID
+ * r.1.1.0 Table 6.2-2 'Slot error register when bmCommandStatus = 1'.
+ */
+typedef enum ccid_command_err {
+	CCID_ERR_CMD_ABORTED	= 0xff,
+	CCID_ERR_ICC_MUTE	= 0xfe,
+	CCID_ERR_XFR_PARITY_ERROR	= 0xfd,
+	CCID_ERR_XFR_OVERRUN	= 0xfc,
+	CCID_ERR_HW_ERROR	= 0xfb,
+	CCID_ERR_BAD_ATR_TS	= 0xf8,
+	CCID_ERR_BAD_ATR_TCK	= 0xf7,
+	CCID_ERR_ICC_PROTOCOL_NOT_SUPPORTED = 0xf6,
+	CCID_ERR_ICC_CLASS_NOT_SUPPORTED = 0xf5,
+	CCID_ERR_PROCEDURE_BYTE_CONFLICT = 0xf4,
+	CCID_ERR_DEACTIVATED_PROTOCOL = 0xf3,
+	CCID_ERR_BUSY_WITH_AUTO_SEQUENCE = 0xf2,
+	CCID_ERR_PIN_TIMEOUT = 0xf0,
+	CCID_ERR_PIN_CANCELLED = 0xef,
+	CCID_ERR_CMD_SLOT_BUSY = 0xe0,
+	CCID_ERR_CMD_NOT_SUPPORTED = 0x00
+} ccid_command_err_t;
+
+/*
+ * Maximum size of an APDU (application data unit) payload. There are both short
+ * and extended ADPUs. At this time, we only support the short ADPUs.
+ */
+#define	CCID_APDU_LEN_MAX	261
+
+#pragma pack()
+
+#endif	/* _KERNEL */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _SYS_USB_CCID_H */
diff --git a/usr/src/uts/common/sys/usb/clients/ccid/uccid.h b/usr/src/uts/common/sys/usb/clients/ccid/uccid.h
new file mode 100644
index 0000000000..d44099c398
--- /dev/null
+++ b/usr/src/uts/common/sys/usb/clients/ccid/uccid.h
@@ -0,0 +1,134 @@
+/*
+ * This file and its contents are supplied under the terms of the
+ * Common Development and Distribution License ("CDDL"), version 1.0.
+ * You may only use this file in accordance with the terms of version
+ * 1.0 of the CDDL.
+ *
+ * A full copy of the text of the CDDL should have accompanied this
+ * source.  A copy of the CDDL is also available via the Internet at
+ * http://www.illumos.org/license/CDDL.
+ */
+
+/*
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+
+#ifndef _SYS_USB_UCCID_H
+#define	_SYS_USB_UCCID_H
+
+/*
+ * Definitions for the userland CCID interface.
+ */
+
+#include <sys/types.h>
+#include <sys/usb/clients/ccid/ccid.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*
+ * The maximum size of a normal APDU. This is the upper bound of what a user can
+ * read or write to a given card.
+ */
+#define	UCCID_APDU_SIZE_MAX	261
+
+/*
+ * This is the maximum length of an ATR as per ISO/IEC 7816-3:2006.
+ */
+#define	UCCID_ATR_MAX		33
+
+
+#define	UCCID_IOCTL	(('u' << 24) | ('c' << 16) | ('d') << 8)
+
+#define	UCCID_VERSION_ONE	1
+#define	UCCID_CURRENT_VERSION	UCCID_VERSION_ONE
+
+#define	UCCID_TXN_DONT_BLOCK	0x01
+
+typedef struct uccid_cmd_txn_begin {
+	uint32_t	uct_version;
+	uint32_t	uct_flags;
+} uccid_cmd_txn_begin_t;
+
+/*
+ * Attempt to obtain exclusive access. If the UCN_TXN_DONT_BLOCK flag is
+ * specified, the ioctl will return immediately if exclusive access cannot be
+ * gained. Otherwise, it will block in an interruptable fashion. The argument is
+ * a uccid_cmd_txn_begin_t.
+ */
+#define	UCCID_CMD_TXN_BEGIN	(UCCID_IOCTL | 0x01)
+
+typedef struct uccid_cmd_txn_end {
+	uint32_t	uct_version;
+	uint32_t	uct_flags;
+} uccid_cmd_txn_end_t;
+
+/*
+ * Reliquish exclusive access. Takes a uccid_cmd_txn_end_t. The callers should
+ * specify one of UCCID_TXN_END_RESET or UCCID_TXN_END_RELEASE. These indicate
+ * what behavior should be taken when we release the transaction. It is
+ * considered an error if neither is specified. If the caller exits without
+ * calling this function, then the ICC will be reset.
+ */
+#define	UCCID_CMD_TXN_END	(UCCID_IOCTL | 0x02)
+#define	UCCID_TXN_END_RESET	0x01
+#define	UCCID_TXN_END_RELEASE	0x02
+
+/*
+ * Protocol definitions. This should match common/ccid/atr.h.
+ */
+typedef enum {
+	UCCID_PROT_T0	= 1 << 0,
+	UCCID_PROT_T1	= 1 << 1
+} uccid_prot_t;
+
+/*
+ * Bits for UCS Status
+ */
+#define	UCCID_STATUS_F_CARD_PRESENT	0x01
+#define	UCCID_STATUS_F_CARD_ACTIVE	0x02
+#define	UCCID_STATUS_F_PRODUCT_VALID	0x04
+#define	UCCID_STATUS_F_SERIAL_VALID	0x08
+#define	UCCID_STATUS_F_PARAMS_VALID	0x10
+
+typedef struct uccid_cmd_status {
+	uint32_t	ucs_version;
+	uint32_t	ucs_status;
+	int32_t		ucs_instance;
+	uint32_t	ucs_slot;
+	uint8_t		ucs_atr[UCCID_ATR_MAX];
+	uint8_t		ucs_atrlen;
+	uint8_t		ucs_pad[6];
+	int8_t		ucs_product[256];
+	int8_t		ucs_serial[256];
+	ccid_class_descr_t	ucs_class;
+	uccid_prot_t	ucs_prot;
+	ccid_params_t	ucs_params;
+} uccid_cmd_status_t;
+
+/*
+ * Obtain the status of the slot. Fills in ucs_flags.
+ */
+#define	UCCID_CMD_STATUS	(UCCID_IOCTL | 0x3)
+
+#define	UCCID_ICC_POWER_ON	0x01
+#define	UCCID_ICC_POWER_OFF	0x02
+#define	UCCID_ICC_WARM_RESET	0x03
+
+typedef struct uccid_cmd_icc_modify {
+	uint32_t uci_version;
+	uint32_t uci_action;
+} uccid_cmd_icc_modify_t;
+
+/*
+ * Modify the state of the ICC, if present.
+ */
+#define	UCCID_CMD_ICC_MODIFY	(UCCID_IOCTL | 0x04)
+
+#ifdef __cplusplus
+}
+#endif
+
+
+#endif /* _SYS_USB_UCCID_H */
diff --git a/usr/src/uts/intel/ccid/Makefile b/usr/src/uts/intel/ccid/Makefile
new file mode 100644
index 0000000000..2237a73d8b
--- /dev/null
+++ b/usr/src/uts/intel/ccid/Makefile
@@ -0,0 +1,56 @@
+#
+# This file and its contents are supplied under the terms of the
+# Common Development and Distribution License ("CDDL"), version 1.0.
+# You may only use this file in accordance with the terms of version
+# 1.0 of the CDDL.
+#
+# A full copy of the text of the CDDL should have accompanied this
+# source.  A copy of the CDDL is also available via the Internet at
+# http://www.illumos.org/license/CDDL.
+#
+
+#
+# Copyright (c) 2017, Joyent, Inc.
+#
+
+UTSBASE = ../..
+
+MODULE		= ccid
+OBJECTS		= $(CCID_OBJS:%=$(OBJS_DIR)/%)
+LINTS		= $(CCID_OBJS:%.o=$(LINTS_DIR)/%.ln)
+ROOTMODULE	= $(ROOT_DRV_DIR)/$(MODULE)
+
+include $(UTSBASE)/intel/Makefile.intel
+
+ALL_TARGET	= $(BINARY)
+LINT_TARGET	= $(MODULE).lint
+INSTALL_TARGET	= $(BINARY) $(ROOTMODULE)
+CPPFLAGS 	+= -I$(SRC)/common/ccid
+
+#
+# XXX For dev
+#
+CERRWARN	+= -_gcc=-Wno-unused-function
+CERRWARN	+= -_gcc=-Wno-unused-variable
+
+LDFLAGS		+= -dy -N misc/usba
+
+.KEEP_STATE:
+
+def:		$(DEF_DEPS)
+
+all:		$(ALL_DEPS)
+
+clean:		$(CLEAN_DEPS)
+
+clobber:	$(CLOBBER_DEPS)
+
+lint:		$(LINT_DEPS)
+
+modlintlib:	$(MODLINTLIB_DEPS)
+
+clean.lint:	$(CLEAN_LINT_DEPS)
+
+install:	$(INSTALL_DEPS)
+
+include $(UTSBASE)/intel/Makefile.targ
-- 
2.17.2 (Apple Git-113)

