From 0507444c65c4ffc6d27510312c51f674d797aceb Mon Sep 17 00:00:00 2001
From: Cody Peter Mello <cody.mello@joyent.com>
Date: Mon, 22 Oct 2018 18:07:06 +0000
Subject: [PATCH] OS-7316 Want support for RT (record terminator) variable in
 nawk(1)

---
 usr/src/cmd/awk/awk.h                         |  1 +
 usr/src/cmd/awk/lib.c                         | 51 +++++++++--
 usr/src/cmd/awk/tran.c                        |  2 +
 usr/src/pkg/manifests/system-test-utiltest.mf |  1 +
 usr/src/test/util-tests/tests/awk/tests/T.rt  | 87 +++++++++++++++++++
 5 files changed, 136 insertions(+), 6 deletions(-)
 create mode 100755 usr/src/test/util-tests/tests/awk/tests/T.rt

diff --git a/usr/src/cmd/awk/awk.h b/usr/src/cmd/awk/awk.h
index c95a74101a..6e1c3025e4 100644
--- a/usr/src/cmd/awk/awk.h
+++ b/usr/src/cmd/awk/awk.h
@@ -149,6 +149,7 @@ extern Cell	*nfloc;		/* NF */
 extern Cell	*ofsloc;	/* OFS */
 extern Cell	*orsloc;	/* ORS */
 extern Cell	*rsloc;		/* RS */
+extern Cell	*rtloc;		/* RT */
 extern Cell	*rstartloc;	/* RSTART */
 extern Cell	*rlengthloc;	/* RLENGTH */
 extern Cell	*subseploc;	/* SUBSEP */
diff --git a/usr/src/cmd/awk/lib.c b/usr/src/cmd/awk/lib.c
index 3ed8513bbc..d67795032a 100644
--- a/usr/src/cmd/awk/lib.c
+++ b/usr/src/cmd/awk/lib.c
@@ -69,6 +69,8 @@ char	*record;
 size_t	recsize	= RECSIZE;
 static char	*fields;
 static size_t	fieldssize = RECSIZE;
+static char	*rtbuf;
+static size_t	rtbufsize = RECSIZE;
 
 Cell	**fldtab;	/* pointers to Cells */
 char	inputFS[100] = " ";
@@ -256,10 +258,16 @@ int
 readrec(char **pbuf, size_t *pbufsize, FILE *inf)	/* read one record into buf */
 {
 	int sep, c;
-	char *rr, *buf = *pbuf;
+	char *rr, *rt, *buf = *pbuf;
 	size_t bufsize = *pbufsize;
 	char *rs = getsval(rsloc);
 
+	if (rtbuf == NULL && (rtbuf = malloc(rtbufsize)) == NULL)
+		FATAL("out of memory in initgetrec");
+
+	rr = buf;
+	rt = rtbuf;
+
 	if ((sep = *rs) == 0) {
 		sep = '\n';
 		/* skip leading \n's */
@@ -268,17 +276,40 @@ readrec(char **pbuf, size_t *pbufsize, FILE *inf)	/* read one record into buf */
 		if (c != EOF)
 			(void) ungetc(c, inf);
 	}
-	for (rr = buf; ; ) {
-		while ((c = getc(inf)) != sep && c != EOF) {
+	while ((c = getc(inf)) != EOF) {
+		if (c != sep) {
 			if (rr-buf+1 > bufsize)
 				if (!adjbuf(&buf, &bufsize, 1+rr-buf, recsize, &rr, "readrec 1"))
 					FATAL("input record `%.30s...' too long", buf);
 			*rr++ = c;
+			continue;
+		}
+
+		if (*rs == sep) {
+			*rt++ = sep;
+			break;
 		}
-		if (*rs == sep || c == EOF)
+
+		if ((c = getc(inf)) == '\n') { /* 2 in a row */
+			*rt++ = '\n';
+			*rt++ = '\n';
+			/* read any further \n's */
+			while ((c = getc(inf)) == '\n' && c != EOF) {
+				if (rt-rtbuf+1 > rtbufsize)
+					(void) adjbuf(&rtbuf, &rtbufsize,
+					    1+rt-rtbuf, recsize, &rt, "readrec 1");
+				*rt++ = '\n';
+			}
+			if (c != EOF)
+				(void) ungetc(c, inf);
 			break;
-		if ((c = getc(inf)) == '\n' || c == EOF) /* 2 in a row */
+		}
+
+		if (c == EOF) {
+			*rt++ = '\n';
 			break;
+		}
+
 		if (!adjbuf(&buf, &bufsize, 2+rr-buf, recsize, &rr, "readrec 2"))
 			FATAL("input record `%.30s...' too long", buf);
 		*rr++ = '\n';
@@ -286,12 +317,20 @@ readrec(char **pbuf, size_t *pbufsize, FILE *inf)	/* read one record into buf */
 	}
 	if (!adjbuf(&buf, &bufsize, 1+rr-buf, recsize, &rr, "readrec 3"))
 		FATAL("input record `%.30s...' too long", buf);
+	if (!adjbuf(&rtbuf, &rtbufsize, 1+rt-rtbuf, recsize, &rt, "readrec 4"))
+		FATAL("input record `%.30s...' too long", buf);
 	*rr = '\0';
+	*rt = '\0';
 	dprintf(("readrec saw <%s>, returns %d\n",
 	    buf, c == EOF && rr == buf ? 0 : 1));
 	*pbuf = buf;
 	*pbufsize = bufsize;
-	return (c == EOF && rr == buf ? 0 : 1);
+	if (c == EOF && rr == buf) {
+		return (0);
+	} else {
+		(void) setsval(rtloc, rtbuf);
+		return (1);
+	}
 }
 
 /* get ARGV[n] */
diff --git a/usr/src/cmd/awk/tran.c b/usr/src/cmd/awk/tran.c
index ce61483597..2380f36f48 100644
--- a/usr/src/cmd/awk/tran.c
+++ b/usr/src/cmd/awk/tran.c
@@ -88,6 +88,7 @@ Cell	*fnrloc;	/* FNR */
 Cell	*ofsloc;	/* OFS */
 Cell	*orsloc;	/* ORS */
 Cell	*rsloc;		/* RS */
+Cell	*rtloc;		/* RT */
 Array	*ARGVtab;	/* symbol table containing ARGV[...] */
 Array	*ENVtab;	/* symbol table containing ENVIRON[...] */
 Cell	*rstartloc;	/* RSTART */
@@ -134,6 +135,7 @@ syminit(void)	/* initialize symbol table with builtin vars */
 	FS = &fsloc->sval;
 	rsloc = setsymtab("RS", "\n", 0.0, STR|DONTFREE, symtab);
 	RS = &rsloc->sval;
+	rtloc = setsymtab("RT", "", 0.0, STR|DONTFREE, symtab);
 	ofsloc = setsymtab("OFS", " ", 0.0, STR|DONTFREE, symtab);
 	OFS = &ofsloc->sval;
 	orsloc = setsymtab("ORS", "\n", 0.0, STR|DONTFREE, symtab);
diff --git a/usr/src/pkg/manifests/system-test-utiltest.mf b/usr/src/pkg/manifests/system-test-utiltest.mf
index bef34a7edb..82d5090984 100644
--- a/usr/src/pkg/manifests/system-test-utiltest.mf
+++ b/usr/src/pkg/manifests/system-test-utiltest.mf
@@ -1054,6 +1054,7 @@ file path=opt/util-tests/tests/awk/tests/T.overflow mode=0555
 file path=opt/util-tests/tests/awk/tests/T.re mode=0555
 file path=opt/util-tests/tests/awk/tests/T.recache mode=0555
 file path=opt/util-tests/tests/awk/tests/T.redir mode=0555
+file path=opt/util-tests/tests/awk/tests/T.rt mode=0555
 file path=opt/util-tests/tests/awk/tests/T.split mode=0555
 file path=opt/util-tests/tests/awk/tests/T.sub mode=0555
 file path=opt/util-tests/tests/awk/tests/T.system mode=0555
diff --git a/usr/src/test/util-tests/tests/awk/tests/T.rt b/usr/src/test/util-tests/tests/awk/tests/T.rt
new file mode 100755
index 0000000000..9e24af6abb
--- /dev/null
+++ b/usr/src/test/util-tests/tests/awk/tests/T.rt
@@ -0,0 +1,87 @@
+#!/bin/bash
+
+if [[ -z "$AWK" || -z "$WORKDIR" ]]; then
+    printf '$AWK and $WORKDIR must be set\n' >&2
+    exit 1
+fi
+
+TEMP0=$WORKDIR/test.temp.0
+TEMP1=$WORKDIR/test.temp.1
+TEMP2=$WORKDIR/test.temp.2
+
+RESULT=0
+
+fail() {
+	echo "$1" >&2
+	RESULT=1
+}
+
+echo T.rt: tests for the RT variable
+
+$AWK 'BEGIN { print (RT == "" ? "true" : "false"); }' > $TEMP1
+printf 'true\n' > $TEMP2
+diff $TEMP1 $TEMP2 || fail 'BAD: T.rt RT is set to "" in BEGIN'
+
+printf 'a\n' > $TEMP0
+$AWK '{ print (RT == "\n" ? "true" : "false"); }' $TEMP0 > $TEMP1
+printf 'true\n' > $TEMP2
+diff $TEMP1 $TEMP2 || fail 'BAD: T.rt RT is set to "\n"'
+
+printf 'a' > $TEMP0
+$AWK '{ print (RT == "" ? "true" : "false"); }' $TEMP0 > $TEMP1
+printf 'true\n' > $TEMP2
+diff $TEMP1 $TEMP2 || fail 'BAD: T.rt RT is set to ""'
+
+$AWK 'BEGIN { "echo hello" | getline; print (RT == "\n" ? "true" : "false"); }' > $TEMP1
+printf 'true\n' > $TEMP2
+diff $TEMP1 $TEMP2 || fail 'BAD: T.rt RT is set to "\n" (getline)'
+
+$AWK 'BEGIN { "printf a" | getline; print (RT == "" ? "true" : "false"); }' > $TEMP1
+printf 'true\n' > $TEMP2
+diff $TEMP1 $TEMP2 || fail 'BAD: T.rt RT is set to "" (getline)'
+
+$AWK 'BEGIN { "echo hello" | getline v; print (RT == "\n" ? "true" : "false"); }' > $TEMP1
+printf 'true\n' > $TEMP2
+diff $TEMP1 $TEMP2 || fail 'BAD: T.rt RT is set to "\n" (getline var)'
+
+$AWK 'BEGIN {
+	RT = "foo";
+	getline < "/etc/passwd";
+	print (RT == "\n" ? "true" : "false");
+}' > $TEMP1
+printf 'true\n' > $TEMP2
+diff $TEMP1 $TEMP2 || fail 'BAD: T.rt RT is set to "\n" (getline < file)'
+
+$AWK 'BEGIN {
+	RT = "foo";
+	getline v < "/etc/passwd";
+	print (RT == "\n" ? "true" : "false");
+}' > $TEMP1
+printf 'true\n' > $TEMP2
+diff $TEMP1 $TEMP2 || fail 'BAD: T.rt RT is set to "\n" (getline var < file)'
+
+# Single newline at end
+printf '\n\n\n\n\na\n\na b\na b c d\nq r s t u\n\n\n\n\nv w x y z\n' > $TEMP0
+$AWK 'BEGIN { RS = ""; } { print NF, length(RT); }' $TEMP0 > $TEMP1
+printf '1 2\n11 5\n5 1\n' > $TEMP2
+diff $TEMP1 $TEMP2 || fail 'BAD: T.rt empty RS variable (1 newline at end)'
+
+# Two newlines at end
+printf '\n\n\n\n\na\n\na b\na b c d\nq r s t u\n\n\n\n\nv w x y z\n\n' > $TEMP0
+$AWK 'BEGIN { RS = ""; } { print NF, length(RT); }' $TEMP0 > $TEMP1
+printf '1 2\n11 5\n5 2\n' > $TEMP2
+diff $TEMP1 $TEMP2 || fail 'BAD: T.rt empty RS variable (2 newlines at end)'
+
+# Multiple newlines at end
+printf 'a\n\na b\na b c d\nq r s t u\n\n\n\n\nv w x y z\n\n\n\n' > $TEMP0
+$AWK 'BEGIN { RS = ""; } { print NF, length(RT); }' $TEMP0 > $TEMP1
+printf '1 2\n11 5\n5 4\n' > $TEMP2
+diff $TEMP1 $TEMP2 || fail 'BAD: T.rt empty RS variable (many newlines at end)'
+
+# No newlines at end
+printf 'a\n\na b\na b c d\nq r s t u\n\n\n\n\nv w x y z' > $TEMP0
+$AWK 'BEGIN { RS = ""; } { print NF, length(RT); }' $TEMP0 > $TEMP1
+printf '1 2\n11 5\n5 0\n' > $TEMP2
+diff $TEMP1 $TEMP2 || fail 'BAD: T.rt empty RS variable (no ending newline)'
+
+exit $RESULT
-- 
2.21.0

