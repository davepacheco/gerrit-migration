commit 50e90ffbf283e119502d8204b3b3a26cfbe48cf2
Author: Cody Peter Mello <cody.mello@joyent.com>
Date:   2018-11-13T05:02:53+00:00 (11 months ago)
    
    OS-7316 Want support for RT (record terminator) variable in nawk(1)

diff --git a/usr/src/cmd/awk/awk.h b/usr/src/cmd/awk/awk.h
index 01495d108d..dfbed45e9d 100644
--- a/usr/src/cmd/awk/awk.h
+++ b/usr/src/cmd/awk/awk.h
@@ -149,6 +149,7 @@ extern Cell	*nfloc;		/* NF */
 extern Cell	*ofsloc;	/* OFS */
 extern Cell	*orsloc;	/* ORS */
 extern Cell	*rsloc;		/* RS */
+extern Cell	*rtloc;		/* RT */
 extern Cell	*rstartloc;	/* RSTART */
 extern Cell	*rlengthloc;	/* RLENGTH */
 extern Cell	*subseploc;	/* SUBSEP */
diff --git a/usr/src/cmd/awk/lib.c b/usr/src/cmd/awk/lib.c
index bec53b6e32..ee4cce2966 100644
--- a/usr/src/cmd/awk/lib.c
+++ b/usr/src/cmd/awk/lib.c
@@ -69,6 +69,8 @@ char	*record;
 size_t	recsize	= RECSIZE;
 static char	*fields;
 static size_t	fieldssize = RECSIZE;
+static char	*rtbuf;
+static size_t	rtbufsize = RECSIZE;
 
 Cell	**fldtab;	/* pointers to Cells */
 char	inputFS[100] = " ";
@@ -256,10 +258,16 @@ int
 readrec(char **pbuf, size_t *pbufsize, FILE *inf)	/* read one record into buf */
 {
 	int sep, c;
-	char *rr, *buf = *pbuf;
+	char *rr, *rt, *buf = *pbuf;
 	size_t bufsize = *pbufsize;
 	char *rs = getsval(rsloc);
 
+	if (rtbuf == NULL && (rtbuf = malloc(rtbufsize)) == NULL)
+		FATAL("out of memory in initgetrec");
+
+	rr = buf;
+	rt = rtbuf;
+
 	if ((sep = *rs) == 0) {
 		sep = '\n';
 		/* skip leading \n's */
@@ -268,17 +276,40 @@ readrec(char **pbuf, size_t *pbufsize, FILE *inf)	/* read one record into buf */
 		if (c != EOF)
 			(void) ungetc(c, inf);
 	}
-	for (rr = buf; ; ) {
-		while ((c = getc(inf)) != sep && c != EOF) {
+	while ((c = getc(inf)) != EOF) {
+		if (c != sep) {
 			if (rr-buf+1 > bufsize)
 				if (!adjbuf(&buf, &bufsize, 1+rr-buf, recsize, &rr, "readrec 1"))
 					FATAL("input record `%.30s...' too long", buf);
 			*rr++ = c;
+			continue;
+		}
+
+		if (*rs == sep) {
+			*rt++ = sep;
+			break;
 		}
-		if (*rs == sep || c == EOF)
+
+		if ((c = getc(inf)) == '\n') { /* 2 in a row */
+			*rt++ = '\n';
+			*rt++ = '\n';
+			/* read any further \n's */
+			while ((c = getc(inf)) == '\n' && c != EOF) {
+				if (rt-rtbuf+1 > rtbufsize)
+					(void) adjbuf(&rtbuf, &rtbufsize,
+					    1+rt-rtbuf, recsize, &rt, "readrec 1");
+				*rt++ = '\n';
+			}
+			if (c != EOF)
+				(void) ungetc(c, inf);
 			break;
-		if ((c = getc(inf)) == '\n' || c == EOF) /* 2 in a row */
+		}
+
+		if (c == EOF) {
+			*rt++ = '\n';
 			break;
+		}
+
 		if (!adjbuf(&buf, &bufsize, 2+rr-buf, recsize, &rr, "readrec 2"))
 			FATAL("input record `%.30s...' too long", buf);
 		*rr++ = '\n';
@@ -286,12 +317,20 @@ readrec(char **pbuf, size_t *pbufsize, FILE *inf)	/* read one record into buf */
 	}
 	if (!adjbuf(&buf, &bufsize, 1+rr-buf, recsize, &rr, "readrec 3"))
 		FATAL("input record `%.30s...' too long", buf);
+	if (!adjbuf(&rtbuf, &rtbufsize, 1+rt-rtbuf, recsize, &rt, "readrec 4"))
+		FATAL("input record `%.30s...' too long", buf);
 	*rr = '\0';
+	*rt = '\0';
 	dprintf(("readrec saw <%s>, returns %d\n",
 	    buf, c == EOF && rr == buf ? 0 : 1));
 	*pbuf = buf;
 	*pbufsize = bufsize;
-	return (c == EOF && rr == buf ? 0 : 1);
+	if (c == EOF && rr == buf) {
+		return (0);
+	} else {
+		(void) setsval(rtloc, rtbuf);
+		return (1);
+	}
 }
 
 /* get ARGV[n] */
diff --git a/usr/src/cmd/awk/tran.c b/usr/src/cmd/awk/tran.c
index 417bede66d..ba9a685d93 100644
--- a/usr/src/cmd/awk/tran.c
+++ b/usr/src/cmd/awk/tran.c
@@ -88,6 +88,7 @@ Cell	*fnrloc;	/* FNR */
 Cell	*ofsloc;	/* OFS */
 Cell	*orsloc;	/* ORS */
 Cell	*rsloc;		/* RS */
+Cell	*rtloc;		/* RT */
 Array	*ARGVtab;	/* symbol table containing ARGV[...] */
 Array	*ENVtab;	/* symbol table containing ENVIRON[...] */
 Cell	*rstartloc;	/* RSTART */
@@ -132,6 +133,7 @@ syminit(void)	/* initialize symbol table with builtin vars */
 	FS = &fsloc->sval;
 	rsloc = setsymtab("RS", "\n", 0.0, STR|DONTFREE, symtab);
 	RS = &rsloc->sval;
+	rtloc = setsymtab("RT", "", 0.0, STR|DONTFREE, symtab);
 	ofsloc = setsymtab("OFS", " ", 0.0, STR|DONTFREE, symtab);
 	OFS = &ofsloc->sval;
 	orsloc = setsymtab("ORS", "\n", 0.0, STR|DONTFREE, symtab);
diff --git a/usr/src/man/man1/nawk.1 b/usr/src/man/man1/nawk.1
index 7734155f19..5fec573a52 100644
--- a/usr/src/man/man1/nawk.1
+++ b/usr/src/man/man1/nawk.1
@@ -711,6 +711,20 @@ The subscript separator string for multi-dimensional arrays. The default value
 is \fB\e034\fR\&.
 .RE
 
+.SS "/usr/bin/nawk"
+.LP
+The following variable is supported for \fB/usr/bin/nawk\fR only:
+.sp
+.ne 2
+.na
+\fB\fBRT\fR\fR
+.ad
+.RS 12n
+The record terminator for the most recent record read. For most records this
+will be the same value as \fBRS\fR. At the end of a file with no trailing
+separator value, though, this will be set to the empty string (\fB""\fR).
+.RE
+
 .SS "Regular Expressions"
 .LP
 The \fBnawk\fR utility makes use of the extended regular expression notation
diff --git a/usr/src/pkg/manifests/system-test-utiltest.mf b/usr/src/pkg/manifests/system-test-utiltest.mf
index 1a17f8271c..188641a4f5 100644
--- a/usr/src/pkg/manifests/system-test-utiltest.mf
+++ b/usr/src/pkg/manifests/system-test-utiltest.mf
@@ -1058,6 +1058,7 @@ file path=opt/util-tests/tests/awk/tests/T.overflow mode=0555
 file path=opt/util-tests/tests/awk/tests/T.re mode=0555
 file path=opt/util-tests/tests/awk/tests/T.recache mode=0555
 file path=opt/util-tests/tests/awk/tests/T.redir mode=0555
+file path=opt/util-tests/tests/awk/tests/T.rt mode=0555
 file path=opt/util-tests/tests/awk/tests/T.split mode=0555
 file path=opt/util-tests/tests/awk/tests/T.sub mode=0555
 file path=opt/util-tests/tests/awk/tests/T.system mode=0555
diff --git a/usr/src/test/util-tests/tests/awk/tests/T.rt b/usr/src/test/util-tests/tests/awk/tests/T.rt
new file mode 100755
index 0000000000..585f3ca3e1
--- /dev/null
+++ b/usr/src/test/util-tests/tests/awk/tests/T.rt
@@ -0,0 +1,99 @@
+#!/bin/bash
+
+if [[ -z "$AWK" || -z "$WORKDIR" ]]; then
+    printf '$AWK and $WORKDIR must be set\n' >&2
+    exit 1
+fi
+
+TEMP0=$WORKDIR/test.temp.0
+TEMP1=$WORKDIR/test.temp.1
+TEMP2=$WORKDIR/test.temp.2
+
+RESULT=0
+
+fail() {
+	echo "$1" >&2
+	RESULT=1
+}
+
+echo T.rt: tests for the RT variable
+
+$AWK 'BEGIN { print (RT == "" ? "true" : "false"); }' > $TEMP1
+printf 'true\n' > $TEMP2
+diff $TEMP1 $TEMP2 || fail 'BAD: T.rt RT is set to "" in BEGIN'
+
+printf 'a\n' > $TEMP0
+$AWK '{ print (RT == "\n" ? "true" : "false"); }' $TEMP0 > $TEMP1
+printf 'true\n' > $TEMP2
+diff $TEMP1 $TEMP2 || fail 'BAD: T.rt RT is set to "\n"'
+
+printf 'a' > $TEMP0
+$AWK '{ print (RT == "" ? "true" : "false"); }' $TEMP0 > $TEMP1
+printf 'true\n' > $TEMP2
+diff $TEMP1 $TEMP2 || fail 'BAD: T.rt RT is set to ""'
+
+$AWK 'BEGIN { "echo hello" | getline; print (RT == "\n" ? "true" : "false"); }' > $TEMP1
+printf 'true\n' > $TEMP2
+diff $TEMP1 $TEMP2 || fail 'BAD: T.rt RT is set to "\n" (getline)'
+
+$AWK 'BEGIN { "printf a" | getline; print (RT == "" ? "true" : "false"); }' > $TEMP1
+printf 'true\n' > $TEMP2
+diff $TEMP1 $TEMP2 || fail 'BAD: T.rt RT is set to "" (getline)'
+
+$AWK 'BEGIN { "echo hello" | getline v; print (RT == "\n" ? "true" : "false"); }' > $TEMP1
+printf 'true\n' > $TEMP2
+diff $TEMP1 $TEMP2 || fail 'BAD: T.rt RT is set to "\n" (getline var)'
+
+$AWK 'BEGIN {
+	RT = "foo";
+	getline < "/etc/passwd";
+	print (RT == "\n" ? "true" : "false");
+}' > $TEMP1
+printf 'true\n' > $TEMP2
+diff $TEMP1 $TEMP2 || fail 'BAD: T.rt RT is set to "\n" (getline < file)'
+
+$AWK 'BEGIN {
+	RT = "foo";
+	getline v < "/etc/passwd";
+	print (RT == "\n" ? "true" : "false");
+}' > $TEMP1
+printf 'true\n' > $TEMP2
+diff $TEMP1 $TEMP2 || fail 'BAD: T.rt RT is set to "\n" (getline var < file)'
+
+# Single newline at end
+printf '\n\n\n\n\na\n\na b\na b c d\nq r s t u\n\n\n\n\nv w x y z\n' > $TEMP0
+$AWK 'BEGIN { RS = ""; } { print NF, length(RT); }' $TEMP0 > $TEMP1
+printf '1 2\n11 5\n5 1\n' > $TEMP2
+diff $TEMP1 $TEMP2 || fail 'BAD: T.rt empty RS variable (1 newline at end)'
+
+# Two newlines at end
+printf '\n\n\n\n\na\n\na b\na b c d\nq r s t u\n\n\n\n\nv w x y z\n\n' > $TEMP0
+$AWK 'BEGIN { RS = ""; } { print NF, length(RT); }' $TEMP0 > $TEMP1
+printf '1 2\n11 5\n5 2\n' > $TEMP2
+diff $TEMP1 $TEMP2 || fail 'BAD: T.rt empty RS variable (2 newlines at end)'
+
+# Multiple newlines at end
+printf 'a\n\na b\na b c d\nq r s t u\n\n\n\n\nv w x y z\n\n\n\n' > $TEMP0
+$AWK 'BEGIN { RS = ""; } { print NF, length(RT); }' $TEMP0 > $TEMP1
+printf '1 2\n11 5\n5 4\n' > $TEMP2
+diff $TEMP1 $TEMP2 || fail 'BAD: T.rt empty RS variable (many newlines at end)'
+
+# No newlines at end
+printf 'a\n\na b\na b c d\nq r s t u\n\n\n\n\nv w x y z' > $TEMP0
+$AWK 'BEGIN { RS = ""; } { print NF, length(RT); }' $TEMP0 > $TEMP1
+printf '1 2\n11 5\n5 0\n' > $TEMP2
+diff $TEMP1 $TEMP2 || fail 'BAD: T.rt empty RS variable (no ending newline)'
+
+# Non-newline separators
+
+printf 'a\036' > $TEMP0
+$AWK 'BEGIN { RS="\036" } { print (RT == "\036" ? "true" : "false"), length(RS); }' $TEMP0 > $TEMP1
+printf 'true 1\n' > $TEMP2
+diff $TEMP1 $TEMP2 || fail 'BAD: T.rt RT is set to "\036" (RS="\036")'
+
+printf 'a' > $TEMP0
+$AWK 'BEGIN { RS="\036" } { print (RT == "" ? "true" : "false"), length(RS); }' $TEMP0 > $TEMP1
+printf 'true 1\n' > $TEMP2
+diff $TEMP1 $TEMP2 || fail 'BAD: T.rt RT is set to "" (RS="\036")'
+
+exit $RESULT
