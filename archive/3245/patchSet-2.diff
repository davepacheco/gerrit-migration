From bc511c7361a6715c646127e735bf475dbb857b2a Mon Sep 17 00:00:00 2001
From: John Levon <john.levon@joyent.com>
Date: Wed, 17 Jan 2018 22:05:38 +0000
Subject: [PATCH] OS-6565 remove KMDB branch debugging support OS-6566 ::crregs
 could do with cr2/cr3 support OS-6567 ::ttrace should be able to filter by
 thread

---
 usr/src/cmd/mdb/Makefile.kmdb.files           |   3 +-
 usr/src/cmd/mdb/common/kmdb/kmdb_dpi_impl.h   |  12 +-
 usr/src/cmd/mdb/common/kmdb/kmdb_kvm.c        |  17 +-
 usr/src/cmd/mdb/common/kmdb/kvm.h             |   8 +-
 usr/src/cmd/mdb/common/kmdb/kvm_cpu.c         |  98 ----
 usr/src/cmd/mdb/common/kmdb/kvm_cpu.h         |  64 ---
 usr/src/cmd/mdb/common/kmdb/kvm_cpu_impl.h    |  64 ---
 usr/src/cmd/mdb/common/mdb/mdb_cmds.c         |   7 +-
 usr/src/cmd/mdb/common/mdb/mdb_kproc.c        |   5 +-
 usr/src/cmd/mdb/common/mdb/mdb_proc.c         |   3 +-
 usr/src/cmd/mdb/common/mdb/mdb_rawfile.c      |   5 +-
 usr/src/cmd/mdb/common/mdb/mdb_target.c       |  46 +-
 usr/src/cmd/mdb/common/mdb/mdb_target.h       |  16 +-
 usr/src/cmd/mdb/common/mdb/mdb_target_impl.h  |   3 +-
 usr/src/cmd/mdb/common/mdb/mdb_value.c        |   5 +-
 usr/src/cmd/mdb/i86pc/modules/unix/unix.c     |  34 +-
 usr/src/cmd/mdb/i86pc/modules/unix/unix_sup.h |   4 +-
 usr/src/cmd/mdb/i86pc/modules/unix/unix_sup.s |  22 +-
 usr/src/cmd/mdb/intel/Makefile.kmdb           |   4 +-
 usr/src/cmd/mdb/intel/ia32/Makefile.kmdb      |   6 +-
 usr/src/cmd/mdb/intel/ia32/kmdb/kvm_cpu_p6.c  | 194 --------
 usr/src/cmd/mdb/intel/kmdb/kaif.c             |  80 +---
 usr/src/cmd/mdb/intel/kmdb/kmdb_dpi_isadep.c  |  22 +-
 usr/src/cmd/mdb/intel/kmdb/kmdb_dpi_isadep.h  |   8 +-
 usr/src/cmd/mdb/intel/kmdb/kmdb_kdi_isadep.c  |  10 +-
 usr/src/cmd/mdb/intel/kmdb/kmdb_kdi_isadep.h  |   5 +-
 usr/src/cmd/mdb/intel/kmdb/kvm_cpu_amd.c      | 213 ---------
 usr/src/cmd/mdb/intel/kmdb/kvm_cpu_p4.c       | 418 ------------------
 usr/src/cmd/mdb/intel/kmdb/kvm_isadep.c       |  26 +-
 usr/src/cmd/mdb/intel/kmdb/kvm_isadep.h       |   5 +-
 usr/src/cmd/mdb/intel/mdb/kvm_amd64dep.c      |   5 +-
 usr/src/cmd/mdb/intel/mdb/kvm_ia32dep.c       |   5 +-
 usr/src/cmd/mdb/sparc/kmdb/kvm_isadep.c       |  11 +-
 usr/src/cmd/mdb/sparc/mdb/kvm_v7dep.c         |   5 +-
 usr/src/cmd/mdb/sparc/mdb/kvm_v9dep.c         |   5 +-
 usr/src/uts/intel/amd64/sys/kdi_regs.h        |  19 +-
 usr/src/uts/intel/ia32/sys/kdi_regs.h         |  18 +-
 usr/src/uts/intel/kdi/amd64/kdi_asm.s         |  99 +----
 usr/src/uts/intel/kdi/ia32/kdi_asm.s          |  98 +---
 usr/src/uts/intel/kdi/kdi_idt.c               | 124 +-----
 usr/src/uts/intel/kdi/kdi_idthdl.s            |  36 +-
 usr/src/uts/intel/kdi/kdi_offsets.in          |  11 +-
 usr/src/uts/intel/os/arch_kdi.c               |   3 +-
 usr/src/uts/intel/sys/controlregs.h           |   5 +-
 usr/src/uts/intel/sys/kdi_machimpl.h          |   7 +-
 usr/src/uts/intel/sys/kdi_regs.h              |  23 +-
 46 files changed, 154 insertions(+), 1727 deletions(-)
 delete mode 100644 usr/src/cmd/mdb/common/kmdb/kvm_cpu.c
 delete mode 100644 usr/src/cmd/mdb/common/kmdb/kvm_cpu.h
 delete mode 100644 usr/src/cmd/mdb/common/kmdb/kvm_cpu_impl.h
 delete mode 100644 usr/src/cmd/mdb/intel/ia32/kmdb/kvm_cpu_p6.c
 delete mode 100644 usr/src/cmd/mdb/intel/kmdb/kvm_cpu_amd.c
 delete mode 100644 usr/src/cmd/mdb/intel/kmdb/kvm_cpu_p4.c

diff --git a/usr/src/cmd/mdb/Makefile.kmdb.files b/usr/src/cmd/mdb/Makefile.kmdb.files
index a82206d42c..ca10ca72a1 100644
--- a/usr/src/cmd/mdb/Makefile.kmdb.files
+++ b/usr/src/cmd/mdb/Makefile.kmdb.files
@@ -25,7 +25,7 @@
 
 #
 # Copyright (c) 2012 by Delphix. All rights reserved.
-# Copyright (c) 2012 Joyent, Inc. All rights reserved.
+# Copyright (c) 2018 Joyent, Inc. All rights reserved.
 #
 
 KMDBSRCS += \
@@ -37,7 +37,6 @@ KMDBSRCS += \
 	mdb_callb.c \
 	mdb_cmdbuf.c \
 	mdb_cmds.c \
-	kvm_cpu.c \
 	kmdb_conf.c \
 	kmdb_context.c \
 	kmdb_create.c \
diff --git a/usr/src/cmd/mdb/common/kmdb/kmdb_dpi_impl.h b/usr/src/cmd/mdb/common/kmdb/kmdb_dpi_impl.h
index a94cfae990..f07a40cd5f 100644
--- a/usr/src/cmd/mdb/common/kmdb/kmdb_dpi_impl.h
+++ b/usr/src/cmd/mdb/common/kmdb/kmdb_dpi_impl.h
@@ -21,13 +21,13 @@
 /*
  * Copyright 2007 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
+ *
+ * Copyright 2018 Joyent, Inc.
  */
 
 #ifndef _KMDB_DPI_IMPL_H
 #define	_KMDB_DPI_IMPL_H
 
-#pragma ident	"%Z%%M%	%I%	%E% SMI"
-
 #include <setjmp.h>
 #ifdef	__sparc
 #include <sys/regset.h>
@@ -86,19 +86,11 @@ struct dpi_ops {
 	int (*dpo_wapt_match)(kmdb_wapt_t *);
 
 	int (*dpo_step)(void);
-#if defined(__i386) || defined(__amd64)
-	void (*dpo_step_branch)(void);
-#endif
 
 	uintptr_t (*dpo_call)(uintptr_t, uint_t, const uintptr_t *);
 
 	void (*dpo_dump_crumbs)(uintptr_t, int);
 
-#if defined(__i386) || defined(__amd64)
-	void (*dpo_msr_add)(const kdi_msr_t *);
-	uint64_t (*dpo_msr_get)(int, uint_t);
-#endif
-
 #ifdef __sparc
 	void (*dpo_kernpanic)(int);
 #endif
diff --git a/usr/src/cmd/mdb/common/kmdb/kmdb_kvm.c b/usr/src/cmd/mdb/common/kmdb/kmdb_kvm.c
index c14261f0ae..316ed77e8e 100644
--- a/usr/src/cmd/mdb/common/kmdb/kmdb_kvm.c
+++ b/usr/src/cmd/mdb/common/kmdb/kmdb_kvm.c
@@ -21,6 +21,8 @@
 /*
  * Copyright (c) 2004, 2010, Oracle and/or its affiliates. All rights reserved.
  * Copyright (c) 2013 by Delphix. All rights reserved.
+ *
+ * Copyright 2018 Joyent, Inc.
  */
 
 #include <kmdb/kmdb_kvm.h>
@@ -549,7 +551,6 @@ kmt_dmod_status(char *msg, int state)
 static int
 kmt_status_dcmd(uintptr_t addr, uint_t flags, int argc, const mdb_arg_t *argv)
 {
-	kmt_data_t *kmt = mdb.m_target->t_data;
 	struct utsname uts;
 	char uuid[37];
 	kreg_t tt;
@@ -578,11 +579,6 @@ kmt_status_dcmd(uintptr_t addr, uint_t flags, int argc, const mdb_arg_t *argv)
 	}
 	mdb_printf("image uuid: %s\n", uuid);
 
-	if (kmt->kmt_cpu != NULL) {
-		mdb_printf("CPU-specific support: %s\n",
-		    kmt_cpu_name(kmt->kmt_cpu));
-	}
-
 	mdb_printf("DTrace state: %s\n", (kmdb_kdi_dtrace_get_state() ==
 	    KDI_DTSTATE_DTRACE_ACTIVE ? "active (debugger breakpoints cannot "
 	    "be armed)" : "inactive"));
@@ -2392,9 +2388,6 @@ kmt_destroy(mdb_tgt_t *t)
 	if (kmt->kmt_trapmap != NULL)
 		mdb_free(kmt->kmt_trapmap, BT_SIZEOFMAP(kmt->kmt_trapmax));
 
-	if (kmt->kmt_cpu != NULL)
-		kmt_cpu_destroy(kmt->kmt_cpu);
-
 	if (kmt != NULL)
 		mdb_free(kmt, sizeof (kmt_data_t));
 }
@@ -2435,7 +2428,6 @@ static const mdb_tgt_ops_t kmt_ops = {
 	(int (*)()) mdb_tgt_notsup,		/* t_run */
 	kmt_step,				/* t_step */
 	kmt_step_out,				/* t_step_out */
-	kmt_step_branch,			/* t_step_branch */
 	kmt_next,				/* t_next */
 	kmt_continue,				/* t_cont */
 	(int (*)()) mdb_tgt_notsup,		/* t_signal */
@@ -2504,10 +2496,6 @@ kmt_sync(mdb_tgt_t *t)
 		(void) mdb_tgt_sespec_activate_all(t);
 	}
 
-	if (kmt->kmt_cpu_retry && ((kmt->kmt_cpu = kmt_cpu_create(t)) !=
-	    NULL || errno != EAGAIN))
-		kmt->kmt_cpu_retry = FALSE;
-
 	(void) mdb_tgt_status(t, &t->t_status);
 }
 
@@ -2536,7 +2524,6 @@ kmdb_kvm_create(mdb_tgt_t *t, int argc, const char *argv[])
 	kmt_init_isadep(t);
 
 	kmt->kmt_symavail = FALSE;
-	kmt->kmt_cpu_retry = TRUE;
 
 	bzero(&kmt_defbp_list, sizeof (mdb_list_t));
 
diff --git a/usr/src/cmd/mdb/common/kmdb/kvm.h b/usr/src/cmd/mdb/common/kmdb/kvm.h
index 414a79eca9..ccd906048a 100644
--- a/usr/src/cmd/mdb/common/kmdb/kvm.h
+++ b/usr/src/cmd/mdb/common/kmdb/kvm.h
@@ -21,13 +21,13 @@
 /*
  * Copyright 2007 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
+ *
+ * Copyright 2018 Joyent, Inc.
  */
 
 #ifndef _KVM_H
 #define	_KVM_H
 
-#pragma ident	"%Z%%M%	%I%	%E% SMI"
-
 /*
  * The kmdb target
  */
@@ -36,7 +36,6 @@
 #include <mdb/mdb_target.h>
 #include <kmdb/kmdb_dpi.h>
 #include <kmdb/kvm_isadep.h>
-#include <kmdb/kvm_cpu.h>
 
 #include <sys/kobj.h>
 
@@ -86,8 +85,6 @@ typedef struct kmt_data {
 	mdb_map_t	kmt_map;		/* Persistant map for callers */
 	ulong_t		*kmt_trapmap;
 	size_t		kmt_trapmax;
-	kmt_cpu_t	*kmt_cpu;		/* CPU-specific plugin */
-	int		kmt_cpu_retry;		/* Try CPU detect again? */
 	int		kmt_symavail;		/* Symbol resolution allowed */
 	uint_t		kmt_narmedbpts;		/* Number of armed brkpts */
 #if defined(__i386) || defined(__amd64)
@@ -143,7 +140,6 @@ extern ssize_t kmt_ioread(mdb_tgt_t *, void *, size_t, uintptr_t);
 extern ssize_t kmt_iowrite(mdb_tgt_t *, const void *, size_t, uintptr_t);
 
 extern int kmt_step_out(mdb_tgt_t *, uintptr_t *);
-extern int kmt_step_branch(mdb_tgt_t *);
 extern int kmt_next(mdb_tgt_t *, uintptr_t *);
 
 extern int kmt_stack(uintptr_t, uint_t, int, const mdb_arg_t *);
diff --git a/usr/src/cmd/mdb/common/kmdb/kvm_cpu.c b/usr/src/cmd/mdb/common/kmdb/kvm_cpu.c
deleted file mode 100644
index ad4ecf4c13..0000000000
--- a/usr/src/cmd/mdb/common/kmdb/kvm_cpu.c
+++ /dev/null
@@ -1,98 +0,0 @@
-/*
- * CDDL HEADER START
- *
- * The contents of this file are subject to the terms of the
- * Common Development and Distribution License, Version 1.0 only
- * (the "License").  You may not use this file except in compliance
- * with the License.
- *
- * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
- * or http://www.opensolaris.org/os/licensing.
- * See the License for the specific language governing permissions
- * and limitations under the License.
- *
- * When distributing Covered Code, include this CDDL HEADER in each
- * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
- * If applicable, add the following below this CDDL HEADER, with the
- * fields enclosed by brackets "[]" replaced with your own identifying
- * information: Portions Copyright [yyyy] [name of copyright owner]
- *
- * CDDL HEADER END
- */
-/*
- * Copyright 2004 Sun Microsystems, Inc.  All rights reserved.
- * Use is subject to license terms.
- */
-
-#pragma ident	"%Z%%M%	%I%	%E% SMI"
-
-/*
- * CPU-specific target implementation
- *
- * Each CPU provides a set of debugging facilities.  We have per-CPU "modules",
- * each of which exposes a kmt_cpu_t.  When initialized, these modules will
- * install dcmds, walkers, and the like in order to allow the user to take
- * advantage of features specific to the CPU being used.
- */
-
-#include <kmdb/kmdb_kdi.h>
-#include <kmdb/kvm_cpu_impl.h>
-#include <mdb/mdb_target.h>
-#include <mdb/mdb_err.h>
-#include <mdb/mdb.h>
-
-static kmt_cpu_ctor_f *const kmt_cpu_ctors[] = {
-#if defined(__i386) || defined(__amd64)
-	kmt_cpu_amd_create,
-	kmt_cpu_p4_create,
-#if defined(__i386)
-	kmt_cpu_p6_create,
-#endif	/* __i386 */
-#endif	/* __i386 || __amd64 */
-	NULL
-};
-
-kmt_cpu_t *
-kmt_cpu_create(mdb_tgt_t *t)
-{
-	kmt_cpu_t *cpu;
-	int retry = 0;
-	int i;
-
-	for (i = 0; kmt_cpu_ctors[i] != NULL; i++) {
-		if ((cpu = kmt_cpu_ctors[i](t)) != NULL)
-			return (cpu);
-		else if (errno == EAGAIN)
-			retry = 1;
-	}
-
-	if (retry)
-		(void) set_errno(EAGAIN);
-
-	return (NULL);
-}
-
-void
-kmt_cpu_destroy(kmt_cpu_t *cpu)
-{
-	if (cpu != NULL)
-		cpu->kmt_cpu_ops->kco_destroy(cpu);
-}
-
-int
-kmt_cpu_step_branch(mdb_tgt_t *t, kmt_cpu_t *cpu)
-{
-	if (cpu == NULL || cpu->kmt_cpu_ops->kco_step_branch == NULL)
-		return (set_errno(EMDB_TGTHWNOTSUP));
-
-	return (cpu->kmt_cpu_ops->kco_step_branch(cpu, t));
-}
-
-const char *
-kmt_cpu_name(kmt_cpu_t *cpu)
-{
-	if (cpu == NULL)
-		return ("none");
-	else
-		return (cpu->kmt_cpu_ops->kco_name(cpu));
-}
diff --git a/usr/src/cmd/mdb/common/kmdb/kvm_cpu.h b/usr/src/cmd/mdb/common/kmdb/kvm_cpu.h
deleted file mode 100644
index 3a315a2329..0000000000
--- a/usr/src/cmd/mdb/common/kmdb/kvm_cpu.h
+++ /dev/null
@@ -1,64 +0,0 @@
-/*
- * CDDL HEADER START
- *
- * The contents of this file are subject to the terms of the
- * Common Development and Distribution License, Version 1.0 only
- * (the "License").  You may not use this file except in compliance
- * with the License.
- *
- * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
- * or http://www.opensolaris.org/os/licensing.
- * See the License for the specific language governing permissions
- * and limitations under the License.
- *
- * When distributing Covered Code, include this CDDL HEADER in each
- * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
- * If applicable, add the following below this CDDL HEADER, with the
- * fields enclosed by brackets "[]" replaced with your own identifying
- * information: Portions Copyright [yyyy] [name of copyright owner]
- *
- * CDDL HEADER END
- */
-/*
- * Copyright 2004 Sun Microsystems, Inc.  All rights reserved.
- * Use is subject to license terms.
- */
-
-#ifndef _KVM_CPU_H
-#define	_KVM_CPU_H
-
-#pragma ident	"%Z%%M%	%I%	%E% SMI"
-
-/*
- * CPU-specific target implementation
- *
- * Each CPU provides a set of debugging facilities.  We have per-CPU "modules",
- * each of which exposes a kmt_cpu_t.  When initialized, these modules will
- * install dcmds, walkers, and the like in order to allow the user to take
- * advantage of features specific to the CPU being used.
- */
-
-#include <mdb/mdb_target.h>
-
-#include <sys/types.h>
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-typedef struct kmt_cpu kmt_cpu_t;
-
-extern kmt_cpu_t *kmt_cpu_create(mdb_tgt_t *);
-extern void kmt_cpu_destroy(kmt_cpu_t *);
-
-extern const char *kmt_cpu_name(kmt_cpu_t *);
-
-#if defined(__i386) || defined(__amd64)
-extern int kmt_cpu_step_branch(mdb_tgt_t *, kmt_cpu_t *);
-#endif
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* _KVM_CPU_H */
diff --git a/usr/src/cmd/mdb/common/kmdb/kvm_cpu_impl.h b/usr/src/cmd/mdb/common/kmdb/kvm_cpu_impl.h
deleted file mode 100644
index a22b8c973d..0000000000
--- a/usr/src/cmd/mdb/common/kmdb/kvm_cpu_impl.h
+++ /dev/null
@@ -1,64 +0,0 @@
-/*
- * CDDL HEADER START
- *
- * The contents of this file are subject to the terms of the
- * Common Development and Distribution License, Version 1.0 only
- * (the "License").  You may not use this file except in compliance
- * with the License.
- *
- * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
- * or http://www.opensolaris.org/os/licensing.
- * See the License for the specific language governing permissions
- * and limitations under the License.
- *
- * When distributing Covered Code, include this CDDL HEADER in each
- * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
- * If applicable, add the following below this CDDL HEADER, with the
- * fields enclosed by brackets "[]" replaced with your own identifying
- * information: Portions Copyright [yyyy] [name of copyright owner]
- *
- * CDDL HEADER END
- */
-/*
- * Copyright 2004 Sun Microsystems, Inc.  All rights reserved.
- * Use is subject to license terms.
- */
-
-#ifndef _KVM_CPU_IMPL_H
-#define	_KVM_CPU_IMPL_H
-
-#pragma ident	"%Z%%M%	%I%	%E% SMI"
-
-#include <kmdb/kvm_cpu.h>
-#include <mdb/mdb_target.h>
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-typedef struct kmt_cpu_ops {
-	void (*kco_destroy)(kmt_cpu_t *);
-	const char *(*kco_name)(kmt_cpu_t *);
-	int (*kco_step_branch)(kmt_cpu_t *, mdb_tgt_t *);
-} kmt_cpu_ops_t;
-
-struct kmt_cpu {
-	kmt_cpu_ops_t *kmt_cpu_ops;	/* Pointer to ops vector */
-	void *kmt_cpu_data;		/* Private storage */
-};
-
-typedef kmt_cpu_t *kmt_cpu_ctor_f(mdb_tgt_t *);
-
-#if defined(__i386) || defined(__amd64)
-extern kmt_cpu_ctor_f kmt_cpu_amd_create;
-extern kmt_cpu_ctor_f kmt_cpu_p4_create;
-#if defined(__i386)
-extern kmt_cpu_ctor_f kmt_cpu_p6_create;
-#endif	/* __i386 */
-#endif	/* __i386 || __amd64 */
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* _KVM_CPU_IMPL_H */
diff --git a/usr/src/cmd/mdb/common/mdb/mdb_cmds.c b/usr/src/cmd/mdb/common/mdb/mdb_cmds.c
index 3b61c9ec3f..e6d0b528b9 100644
--- a/usr/src/cmd/mdb/common/mdb/mdb_cmds.c
+++ b/usr/src/cmd/mdb/common/mdb/mdb_cmds.c
@@ -26,7 +26,7 @@
 
 /*
  * Copyright (c) 2012 by Delphix. All rights reserved.
- * Copyright (c) 2015 Joyent, Inc. All rights reserved.
+ * Copyright (c) 2018 Joyent, Inc. All rights reserved.
  * Copyright (c) 2013 Josef 'Jeff' Sipek <jeffpc@josefsipek.net>
  * Copyright (c) 2015 by Delphix. All rights reserved.
  */
@@ -2652,11 +2652,6 @@ cmd_step(uintptr_t addr, uint_t flags, int argc, const mdb_arg_t *argv)
 			name = "step (out)";
 			argv++;
 			argc--;
-		} else if (strcmp(argv->a_un.a_str, "branch") == 0) {
-			func = &mdb_tgt_step_branch;
-			name = "step (branch)";
-			argv++;
-			argc--;
 		} else if (strcmp(argv->a_un.a_str, "over") == 0) {
 			func = &mdb_tgt_next;
 			name = "step (over)";
diff --git a/usr/src/cmd/mdb/common/mdb/mdb_kproc.c b/usr/src/cmd/mdb/common/mdb/mdb_kproc.c
index 41e57b60b5..b61b0a2b0b 100644
--- a/usr/src/cmd/mdb/common/mdb/mdb_kproc.c
+++ b/usr/src/cmd/mdb/common/mdb/mdb_kproc.c
@@ -21,10 +21,10 @@
 /*
  * Copyright 2008 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
+ *
+ * Copyright 2018 Joyent, Inc.
  */
 
-#pragma ident	"%Z%%M%	%I%	%E% SMI"
-
 /*
  * Kernel Process View Target
  *
@@ -919,7 +919,6 @@ static const mdb_tgt_ops_t kproc_ops = {
 	(int (*)()) mdb_tgt_notsup,		/* t_run */
 	(int (*)()) mdb_tgt_notsup,		/* t_step */
 	(int (*)()) mdb_tgt_notsup,		/* t_step_out */
-	(int (*)()) mdb_tgt_notsup,		/* t_step_branch */
 	(int (*)()) mdb_tgt_notsup,		/* t_next */
 	(int (*)()) mdb_tgt_notsup,		/* t_cont */
 	(int (*)()) mdb_tgt_notsup,		/* t_signal */
diff --git a/usr/src/cmd/mdb/common/mdb/mdb_proc.c b/usr/src/cmd/mdb/common/mdb/mdb_proc.c
index 0b061d26a6..6c9f0aa5f4 100644
--- a/usr/src/cmd/mdb/common/mdb/mdb_proc.c
+++ b/usr/src/cmd/mdb/common/mdb/mdb_proc.c
@@ -24,7 +24,7 @@
  * Use is subject to license terms.
  */
 /*
- * Copyright 2015 Joyent, Inc.
+ * Copyright 2018 Joyent, Inc.
  * Copyright (c) 2014 by Delphix. All rights reserved.
  */
 
@@ -4695,7 +4695,6 @@ static const mdb_tgt_ops_t proc_ops = {
 	pt_run,					/* t_run */
 	pt_step,				/* t_step */
 	pt_step_out,				/* t_step_out */
-	(int (*)()) mdb_tgt_notsup,		/* t_step_branch */
 	pt_next,				/* t_next */
 	pt_continue,				/* t_cont */
 	pt_signal,				/* t_signal */
diff --git a/usr/src/cmd/mdb/common/mdb/mdb_rawfile.c b/usr/src/cmd/mdb/common/mdb/mdb_rawfile.c
index affd518083..d2857a6579 100644
--- a/usr/src/cmd/mdb/common/mdb/mdb_rawfile.c
+++ b/usr/src/cmd/mdb/common/mdb/mdb_rawfile.c
@@ -21,10 +21,10 @@
 /*
  * Copyright 2008 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
+ *
+ * Copyright 2018 Joyent, Inc.
  */
 
-#pragma ident	"%Z%%M%	%I%	%E% SMI"
-
 /*
  * Raw File Target
  *
@@ -391,7 +391,6 @@ static const mdb_tgt_ops_t rawfile_ops = {
 	(int (*)()) mdb_tgt_notsup,		/* t_run */
 	(int (*)()) mdb_tgt_notsup,		/* t_step */
 	(int (*)()) mdb_tgt_notsup,		/* t_step_out */
-	(int (*)()) mdb_tgt_notsup,		/* t_step_branch */
 	(int (*)()) mdb_tgt_notsup,		/* t_next */
 	(int (*)()) mdb_tgt_notsup,		/* t_cont */
 	(int (*)()) mdb_tgt_notsup,		/* t_signal */
diff --git a/usr/src/cmd/mdb/common/mdb/mdb_target.c b/usr/src/cmd/mdb/common/mdb/mdb_target.c
index 4319f6b27c..edeac638e9 100644
--- a/usr/src/cmd/mdb/common/mdb/mdb_target.c
+++ b/usr/src/cmd/mdb/common/mdb/mdb_target.c
@@ -21,6 +21,8 @@
 /*
  * Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
+ *
+ * Copyright 2018 Joyent, Inc.
  */
 
 /*
@@ -182,8 +184,7 @@
  * Define convenience macro for referencing target flag pending continue bits.
  */
 #define	T_CONT_BITS	\
-	(MDB_TGT_F_STEP | MDB_TGT_F_STEP_OUT | MDB_TGT_F_STEP_BRANCH | \
-	MDB_TGT_F_NEXT | MDB_TGT_F_CONT)
+	(MDB_TGT_F_STEP | MDB_TGT_F_STEP_OUT | MDB_TGT_F_NEXT | MDB_TGT_F_CONT)
 
 mdb_tgt_t *
 mdb_tgt_create(mdb_tgt_ctor_f *ctor, int flags, int argc, const char *argv[])
@@ -390,7 +391,7 @@ mdb_tgt_auxv(mdb_tgt_t *t, const auxv_t **auxvp)
 
 ssize_t
 mdb_tgt_aread(mdb_tgt_t *t, mdb_tgt_as_t as,
-	void *buf, size_t n, mdb_tgt_addr_t addr)
+    void *buf, size_t n, mdb_tgt_addr_t addr)
 {
 	if (t->t_flags & MDB_TGT_F_ASIO)
 		return (t->t_ops->t_aread(t, as, buf, n, addr));
@@ -410,7 +411,7 @@ mdb_tgt_aread(mdb_tgt_t *t, mdb_tgt_as_t as,
 
 ssize_t
 mdb_tgt_awrite(mdb_tgt_t *t, mdb_tgt_as_t as,
-	const void *buf, size_t n, mdb_tgt_addr_t addr)
+    const void *buf, size_t n, mdb_tgt_addr_t addr)
 {
 	if (!(t->t_flags & MDB_TGT_F_RDWR))
 		return (set_errno(EMDB_TGTRDONLY));
@@ -499,7 +500,7 @@ mdb_tgt_vtop(mdb_tgt_t *t, mdb_tgt_as_t as, uintptr_t va, physaddr_t *pap)
 
 ssize_t
 mdb_tgt_readstr(mdb_tgt_t *t, mdb_tgt_as_t as, char *buf,
-	size_t nbytes, mdb_tgt_addr_t addr)
+    size_t nbytes, mdb_tgt_addr_t addr)
 {
 	ssize_t n, nread = mdb_tgt_aread(t, as, buf, nbytes, addr);
 	char *p;
@@ -533,7 +534,7 @@ done:
 
 ssize_t
 mdb_tgt_writestr(mdb_tgt_t *t, mdb_tgt_as_t as,
-	const char *buf, mdb_tgt_addr_t addr)
+    const char *buf, mdb_tgt_addr_t addr)
 {
 	ssize_t nwritten = mdb_tgt_awrite(t, as, buf, strlen(buf) + 1, addr);
 	return (nwritten > 0 ? nwritten - 1 : nwritten);
@@ -541,7 +542,7 @@ mdb_tgt_writestr(mdb_tgt_t *t, mdb_tgt_as_t as,
 
 int
 mdb_tgt_lookup_by_name(mdb_tgt_t *t, const char *obj,
-	const char *name, GElf_Sym *symp, mdb_syminfo_t *sip)
+    const char *name, GElf_Sym *symp, mdb_syminfo_t *sip)
 {
 	mdb_syminfo_t info;
 	GElf_Sym sym;
@@ -572,7 +573,7 @@ found:
 
 int
 mdb_tgt_lookup_by_addr(mdb_tgt_t *t, uintptr_t addr, uint_t flags,
-	char *buf, size_t len, GElf_Sym *symp, mdb_syminfo_t *sip)
+    char *buf, size_t len, GElf_Sym *symp, mdb_syminfo_t *sip)
 {
 	mdb_syminfo_t info;
 	GElf_Sym sym;
@@ -603,7 +604,7 @@ mdb_tgt_lookup_by_addr(mdb_tgt_t *t, uintptr_t addr, uint_t flags,
  */
 int
 mdb_tgt_lookup_by_scope(mdb_tgt_t *t, const char *s, GElf_Sym *symp,
-	mdb_syminfo_t *sip)
+    mdb_syminfo_t *sip)
 {
 	const char *object = MDB_TGT_OBJ_EVERY;
 	const char *name = s;
@@ -633,7 +634,7 @@ mdb_tgt_lookup_by_scope(mdb_tgt_t *t, const char *s, GElf_Sym *symp,
 
 int
 mdb_tgt_symbol_iter(mdb_tgt_t *t, const char *obj, uint_t which,
-	uint_t type, mdb_tgt_sym_f *cb, void *p)
+    uint_t type, mdb_tgt_sym_f *cb, void *p)
 {
 	if ((which != MDB_TGT_SYMTAB && which != MDB_TGT_DYNSYM) ||
 	    (type & ~(MDB_TGT_BIND_ANY | MDB_TGT_TYPE_ANY)) != 0)
@@ -644,7 +645,7 @@ mdb_tgt_symbol_iter(mdb_tgt_t *t, const char *obj, uint_t which,
 
 ssize_t
 mdb_tgt_readsym(mdb_tgt_t *t, mdb_tgt_as_t as, void *buf, size_t nbytes,
-	const char *obj, const char *name)
+    const char *obj, const char *name)
 {
 	GElf_Sym sym;
 
@@ -656,7 +657,7 @@ mdb_tgt_readsym(mdb_tgt_t *t, mdb_tgt_as_t as, void *buf, size_t nbytes,
 
 ssize_t
 mdb_tgt_writesym(mdb_tgt_t *t, mdb_tgt_as_t as, const void *buf,
-	size_t nbytes, const char *obj, const char *name)
+    size_t nbytes, const char *obj, const char *name)
 {
 	GElf_Sym sym;
 
@@ -1088,8 +1089,6 @@ tgt_continue(mdb_tgt_t *t, mdb_tgt_status_t *tsp,
 		t_cont = t->t_ops->t_step;
 	else if (t->t_flags & MDB_TGT_F_NEXT)
 		t_cont = t->t_ops->t_step;
-	else if (t->t_flags & MDB_TGT_F_STEP_BRANCH)
-		t_cont = t->t_ops->t_cont;
 	else if (t->t_flags & MDB_TGT_F_STEP_OUT)
 		t_cont = t->t_ops->t_cont;
 
@@ -1121,16 +1120,6 @@ tgt_continue(mdb_tgt_t *t, mdb_tgt_status_t *tsp,
 			return (-1); /* errno is set for us */
 	}
 
-	/*
-	 * To handle step-branch, we ask the target to enable it for the coming
-	 * continue.  Step-branch is incompatible with step, so don't enable it
-	 * if we're going to be stepping.
-	 */
-	if (t->t_flags & MDB_TGT_F_STEP_BRANCH && t_cont == t->t_ops->t_cont) {
-		if (t->t_ops->t_step_branch(t) == -1)
-			return (-1); /* errno is set for us */
-	}
-
 	(void) mdb_signal_block(SIGHUP);
 	(void) mdb_signal_block(SIGTERM);
 	mdb_intr_disable();
@@ -1395,13 +1384,6 @@ mdb_tgt_step_out(mdb_tgt_t *t, mdb_tgt_status_t *tsp)
 	return (tgt_request_continue(t, tsp, 0, t->t_ops->t_cont));
 }
 
-int
-mdb_tgt_step_branch(mdb_tgt_t *t, mdb_tgt_status_t *tsp)
-{
-	t->t_flags |= MDB_TGT_F_STEP_BRANCH; /* set flag even if tgt not busy */
-	return (tgt_request_continue(t, tsp, 0, t->t_ops->t_cont));
-}
-
 int
 mdb_tgt_next(mdb_tgt_t *t, mdb_tgt_status_t *tsp)
 {
@@ -1864,7 +1846,7 @@ mdb_tgt_nop()
 
 int
 mdb_tgt_xdata_insert(mdb_tgt_t *t, const char *name, const char *desc,
-	ssize_t (*copy)(mdb_tgt_t *, void *, size_t))
+    ssize_t (*copy)(mdb_tgt_t *, void *, size_t))
 {
 	mdb_xdata_t *xdp;
 
diff --git a/usr/src/cmd/mdb/common/mdb/mdb_target.h b/usr/src/cmd/mdb/common/mdb/mdb_target.h
index b511ba07c3..c36b85e2f3 100644
--- a/usr/src/cmd/mdb/common/mdb/mdb_target.h
+++ b/usr/src/cmd/mdb/common/mdb/mdb_target.h
@@ -22,6 +22,8 @@
 /*
  * Copyright 2005 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
+ *
+ * Copyright 2018 Joyent, Inc.
  */
 
 #ifndef	_MDB_TARGET_H
@@ -79,13 +81,12 @@ extern int kmdb_kvm_create(mdb_tgt_t *, int, const char *[]);
 #define	MDB_TGT_F_NOSTOP	0x0020	/* Do not stop target on attach */
 #define	MDB_TGT_F_STEP		0x0040	/* Single-step is pending */
 #define	MDB_TGT_F_STEP_OUT	0x0080	/* Step-out is pending */
-#define	MDB_TGT_F_STEP_BRANCH	0x0100	/* Step-branch is pending */
-#define	MDB_TGT_F_NEXT		0x0200	/* Step-over is pending */
-#define	MDB_TGT_F_CONT		0x0400	/* Continue is pending */
-#define	MDB_TGT_F_BUSY		0x0800	/* Target is busy executing */
-#define	MDB_TGT_F_ASIO		0x1000	/* Use t_aread and t_awrite for i/o */
-#define	MDB_TGT_F_UNLOAD	0x2000	/* Unload has been requested */
-#define	MDB_TGT_F_ALL		0x3fff	/* Mask of all valid flags */
+#define	MDB_TGT_F_NEXT		0x0100	/* Step-over is pending */
+#define	MDB_TGT_F_CONT		0x0200	/* Continue is pending */
+#define	MDB_TGT_F_BUSY		0x0400	/* Target is busy executing */
+#define	MDB_TGT_F_ASIO		0x0800	/* Use t_aread and t_awrite for i/o */
+#define	MDB_TGT_F_UNLOAD	0x1000	/* Unload has been requested */
+#define	MDB_TGT_F_ALL		0x1fff	/* Mask of all valid flags */
 
 typedef int mdb_tgt_ctor_f(mdb_tgt_t *, int, const char *[]);
 
@@ -352,7 +353,6 @@ extern int mdb_tgt_status(mdb_tgt_t *, mdb_tgt_status_t *);
 extern int mdb_tgt_run(mdb_tgt_t *, int, const struct mdb_arg *);
 extern int mdb_tgt_step(mdb_tgt_t *, mdb_tgt_status_t *);
 extern int mdb_tgt_step_out(mdb_tgt_t *, mdb_tgt_status_t *);
-extern int mdb_tgt_step_branch(mdb_tgt_t *, mdb_tgt_status_t *);
 extern int mdb_tgt_next(mdb_tgt_t *, mdb_tgt_status_t *);
 extern int mdb_tgt_continue(mdb_tgt_t *, mdb_tgt_status_t *);
 extern int mdb_tgt_signal(mdb_tgt_t *, int);
diff --git a/usr/src/cmd/mdb/common/mdb/mdb_target_impl.h b/usr/src/cmd/mdb/common/mdb/mdb_target_impl.h
index 7f78bc4879..28e42234ea 100644
--- a/usr/src/cmd/mdb/common/mdb/mdb_target_impl.h
+++ b/usr/src/cmd/mdb/common/mdb/mdb_target_impl.h
@@ -23,7 +23,7 @@
  * Use is subject to license terms.
  */
 /*
- * Copyright (c) 2012, Joyent, Inc.  All rights reserved.
+ * Copyright (c) 2018, Joyent, Inc.  All rights reserved.
  */
 
 #ifndef	_MDB_TARGET_IMPL_H
@@ -104,7 +104,6 @@ typedef struct mdb_tgt_ops {
 	int (*t_run)(mdb_tgt_t *, int, const struct mdb_arg *);
 	int (*t_step)(mdb_tgt_t *, mdb_tgt_status_t *);
 	int (*t_step_out)(mdb_tgt_t *, uintptr_t *);
-	int (*t_step_branch)(mdb_tgt_t *);
 	int (*t_next)(mdb_tgt_t *, uintptr_t *);
 	int (*t_cont)(mdb_tgt_t *, mdb_tgt_status_t *);
 	int (*t_signal)(mdb_tgt_t *, int);
diff --git a/usr/src/cmd/mdb/common/mdb/mdb_value.c b/usr/src/cmd/mdb/common/mdb/mdb_value.c
index 2292b0cf03..c50d971a49 100644
--- a/usr/src/cmd/mdb/common/mdb/mdb_value.c
+++ b/usr/src/cmd/mdb/common/mdb/mdb_value.c
@@ -21,10 +21,10 @@
 /*
  * Copyright 2008 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
+ *
+ * Copyright 2018 Joyent, Inc.
  */
 
-#pragma ident	"%Z%%M%	%I%	%E% SMI"
-
 /*
  * Immediate Value Target
  *
@@ -142,7 +142,6 @@ static const mdb_tgt_ops_t value_ops = {
 	(int (*)()) mdb_tgt_notsup,		/* t_run */
 	(int (*)()) mdb_tgt_notsup,		/* t_step */
 	(int (*)()) mdb_tgt_notsup,		/* t_step_out */
-	(int (*)()) mdb_tgt_notsup,		/* t_step_branch */
 	(int (*)()) mdb_tgt_notsup,		/* t_next */
 	(int (*)()) mdb_tgt_notsup,		/* t_cont */
 	(int (*)()) mdb_tgt_notsup,		/* t_signal */
diff --git a/usr/src/cmd/mdb/i86pc/modules/unix/unix.c b/usr/src/cmd/mdb/i86pc/modules/unix/unix.c
index 4bce7100ef..a168eef2e3 100644
--- a/usr/src/cmd/mdb/i86pc/modules/unix/unix.c
+++ b/usr/src/cmd/mdb/i86pc/modules/unix/unix.c
@@ -20,7 +20,7 @@
  */
 /*
  * Copyright (c) 1999, 2010, Oracle and/or its affiliates. All rights reserved.
- * Copyright 2015 Joyent, Inc.
+ * Copyright 2018 Joyent, Inc.
  */
 
 #include <mdb/mdb_modapi.h>
@@ -409,6 +409,7 @@ static struct {
 typedef struct ttrace_dcmd {
 	processorid_t ttd_cpu;
 	uint_t ttd_extended;
+	uintptr_t ttd_kthread;
 	trap_trace_ctl_t ttd_ttc[NCPU];
 } ttrace_dcmd_t;
 
@@ -478,6 +479,10 @@ ttrace_walk(uintptr_t addr, trap_trace_rec_t *rec, ttrace_dcmd_t *dcmd)
 	if (dcmd->ttd_cpu != -1 && cpu != dcmd->ttd_cpu)
 		return (WALK_NEXT);
 
+	if (dcmd->ttd_kthread != 0 &&
+	    dcmd->ttd_kthread != rec->ttr_curthread)
+		return (WALK_NEXT);
+
 	mdb_printf("%3d %15llx ", cpu, rec->ttr_stamp);
 
 	for (i = 0; ttrace_hdlr[i].t_hdlr != NULL; i++) {
@@ -537,7 +542,8 @@ ttrace(uintptr_t addr, uint_t flags, int argc, const mdb_arg_t *argv)
 	}
 
 	if (mdb_getopts(argc, argv,
-	    'x', MDB_OPT_SETBITS, TRUE, &dcmd.ttd_extended, NULL) != argc)
+	    'x', MDB_OPT_SETBITS, TRUE, &dcmd.ttd_extended,
+	    't', MDB_OPT_UINTPTR, &dcmd.ttd_kthread, NULL) != argc)
 		return (DCMD_USAGE);
 
 	if (DCMD_HDRSPEC(flags)) {
@@ -886,7 +892,7 @@ x86_featureset_cmd(uintptr_t addr, uint_t flags, int argc,
 static int
 crregs_dcmd(uintptr_t addr, uint_t flags, int argc, const mdb_arg_t *argv)
 {
-	ulong_t cr0, cr4;
+	ulong_t cr0, cr2, cr3, cr4;
 	static const mdb_bitmask_t cr0_flag_bits[] = {
 		{ "PE",		CR0_PE,		CR0_PE },
 		{ "MP",		CR0_MP,		CR0_MP },
@@ -902,6 +908,12 @@ crregs_dcmd(uintptr_t addr, uint_t flags, int argc, const mdb_arg_t *argv)
 		{ NULL,		0,		0 }
 	};
 
+	static const mdb_bitmask_t cr3_flag_bits[] = {
+		{ "PCD",	CR3_PCD,	CR3_PCD },
+		{ "PWT",	CR3_PWT,	CR3_PWT },
+		{ NULL,		0,		0, }
+	};
+
 	static const mdb_bitmask_t cr4_flag_bits[] = {
 		{ "VME",	CR4_VME,	CR4_VME },
 		{ "PVI",	CR4_PVI,	CR4_PVI },
@@ -916,6 +928,7 @@ crregs_dcmd(uintptr_t addr, uint_t flags, int argc, const mdb_arg_t *argv)
 		{ "OSXMMEXCPT",	CR4_OSXMMEXCPT,	CR4_OSXMMEXCPT },
 		{ "VMXE",	CR4_VMXE,	CR4_VMXE },
 		{ "SMXE",	CR4_SMXE,	CR4_SMXE },
+		{ "PCIDE",	CR4_PCIDE,	CR4_PCIDE },
 		{ "OSXSAVE",	CR4_OSXSAVE,	CR4_OSXSAVE },
 		{ "SMEP",	CR4_SMEP,	CR4_SMEP },
 		{ "SMAP",	CR4_SMAP,	CR4_SMAP },
@@ -923,9 +936,22 @@ crregs_dcmd(uintptr_t addr, uint_t flags, int argc, const mdb_arg_t *argv)
 	};
 
 	cr0 = kmdb_unix_getcr0();
+	cr2 = kmdb_unix_getcr2();
+	cr3 = kmdb_unix_getcr3();
 	cr4 = kmdb_unix_getcr4();
 	mdb_printf("%%cr0 = 0x%08x <%b>\n", cr0, cr0, cr0_flag_bits);
+	mdb_printf("%%cr2 = 0x%08x <%a>\n", cr2, cr2);
+
+	if ((cr4 & CR4_PCIDE)) {
+		mdb_printf("%%cr3 = 0x%08x <pfn:%lu pcid:%u>\n",
+		    cr3 >> MMU_PAGESHIFT, cr3 & MMU_PAGEOFFSET);
+	} else {
+		mdb_printf("%%cr3 = 0x%08x <pfn:%lu flags:%b>\n", cr3,
+		    cr3 >> MMU_PAGESHIFT, cr3, cr3_flag_bits);
+	}
+
 	mdb_printf("%%cr4 = 0x%08x <%b>\n", cr4, cr4, cr4_flag_bits);
+
 	return (DCMD_OK);
 }
 #endif
@@ -933,7 +959,7 @@ crregs_dcmd(uintptr_t addr, uint_t flags, int argc, const mdb_arg_t *argv)
 static const mdb_dcmd_t dcmds[] = {
 	{ "gate_desc", ":", "dump a gate descriptor", gate_desc },
 	{ "idt", ":[-v]", "dump an IDT", idt },
-	{ "ttrace", "[-x]", "dump trap trace buffers", ttrace },
+	{ "ttrace", "[-x] [-t kthread]", "dump trap trace buffers", ttrace },
 	{ "vatopfn", ":[-a as]", "translate address to physical page",
 	    va2pfn_dcmd },
 	{ "report_maps", ":[-m]",
diff --git a/usr/src/cmd/mdb/i86pc/modules/unix/unix_sup.h b/usr/src/cmd/mdb/i86pc/modules/unix/unix_sup.h
index b272baaf59..4c155373ea 100644
--- a/usr/src/cmd/mdb/i86pc/modules/unix/unix_sup.h
+++ b/usr/src/cmd/mdb/i86pc/modules/unix/unix_sup.h
@@ -10,7 +10,7 @@
  */
 
 /*
- * Copyright 2015 Joyent, Inc.
+ * Copyright 2018 Joyent, Inc.
  */
 
 #ifndef _UNIX_SUP_H
@@ -27,6 +27,8 @@ extern "C" {
 #endif
 
 extern ulong_t kmdb_unix_getcr0(void);
+extern ulong_t kmdb_unix_getcr2(void);
+extern ulong_t kmdb_unix_getcr3(void);
 extern ulong_t kmdb_unix_getcr4(void);
 
 #ifdef __cplusplus
diff --git a/usr/src/cmd/mdb/i86pc/modules/unix/unix_sup.s b/usr/src/cmd/mdb/i86pc/modules/unix/unix_sup.s
index f7d4e168c0..407123c7e0 100644
--- a/usr/src/cmd/mdb/i86pc/modules/unix/unix_sup.s
+++ b/usr/src/cmd/mdb/i86pc/modules/unix/unix_sup.s
@@ -10,7 +10,7 @@
  */
 
 /*
- * Copyright 2015 Joyent, Inc.
+ * Copyright 2018 Joyent, Inc.
  */
 
 #if !defined(__lint)
@@ -43,6 +43,16 @@ kmdb_unix_getcr4(void)
 	ret
 	SET_SIZE(kmdb_unix_getcr0)
 
+	ENTRY(kmdb_unix_getcr2)
+	movq %cr2, %rax
+	ret
+	SET_SIZE(kmdb_unix_getcr2)
+
+	ENTRY(kmdb_unix_getcr3)
+	movq %cr3, %rax
+	ret
+	SET_SIZE(kmdb_unix_getcr3)
+
 	ENTRY(kmdb_unix_getcr4)
 	movq %cr4, %rax
 	ret
@@ -54,6 +64,16 @@ kmdb_unix_getcr4(void)
 	ret
 	SET_SIZE(kmdb_unix_getcr0)
 
+	ENTRY(kmdb_unix_getcr2)
+	movl %cr2, %eax
+	ret
+	SET_SIZE(kmdb_unix_getcr2)
+
+	ENTRY(kmdb_unix_getcr3)
+	movl %cr3, %eax
+	ret
+	SET_SIZE(kmdb_unix_getcr3)
+
 	ENTRY(kmdb_unix_getcr4)
 	movl %cr4, %eax
 	ret
diff --git a/usr/src/cmd/mdb/intel/Makefile.kmdb b/usr/src/cmd/mdb/intel/Makefile.kmdb
index f0b2e9cac7..0a2a5e8581 100644
--- a/usr/src/cmd/mdb/intel/Makefile.kmdb
+++ b/usr/src/cmd/mdb/intel/Makefile.kmdb
@@ -22,6 +22,8 @@
 # Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
 # Use is subject to license terms.
 #
+# Copyright 2018 Joyent, Inc.
+#
 
 PROMSRCS += \
 	prom_env.c \
@@ -36,8 +38,6 @@ KMDBSRCS += \
 	kmdb_fault_isadep.c \
 	kmdb_kdi_isadep.c \
 	kmdb_promif_isadep.c \
-	kvm_cpu_amd.c \
-	kvm_cpu_p4.c \
 	kvm_isadep.c
 
 KMDBML += \
diff --git a/usr/src/cmd/mdb/intel/ia32/Makefile.kmdb b/usr/src/cmd/mdb/intel/ia32/Makefile.kmdb
index 53b19b535d..03ea80eb9e 100644
--- a/usr/src/cmd/mdb/intel/ia32/Makefile.kmdb
+++ b/usr/src/cmd/mdb/intel/ia32/Makefile.kmdb
@@ -22,8 +22,7 @@
 # Copyright 2007 Sun Microsystems, Inc.  All rights reserved.
 # Use is subject to license terms.
 #
-#ident	"%Z%%M%	%I%	%E% SMI"
-#
+# Copyright 2018 Joyent, Inc.
 
 KMDBML += \
 	kaif_invoke.s \
@@ -31,7 +30,6 @@ KMDBML += \
 
 KMDBSRCS += \
 	mdb_ia32util.c \
-	kmdb_makecontext.c \
-	kvm_cpu_p6.c
+	kmdb_makecontext.c
 
 SACPPFLAGS = -D__$(MACH)
diff --git a/usr/src/cmd/mdb/intel/ia32/kmdb/kvm_cpu_p6.c b/usr/src/cmd/mdb/intel/ia32/kmdb/kvm_cpu_p6.c
deleted file mode 100644
index b3c3982ca6..0000000000
--- a/usr/src/cmd/mdb/intel/ia32/kmdb/kvm_cpu_p6.c
+++ /dev/null
@@ -1,194 +0,0 @@
-/*
- * CDDL HEADER START
- *
- * The contents of this file are subject to the terms of the
- * Common Development and Distribution License (the "License").
- * You may not use this file except in compliance with the License.
- *
- * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
- * or http://www.opensolaris.org/os/licensing.
- * See the License for the specific language governing permissions
- * and limitations under the License.
- *
- * When distributing Covered Code, include this CDDL HEADER in each
- * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
- * If applicable, add the following below this CDDL HEADER, with the
- * fields enclosed by brackets "[]" replaced with your own identifying
- * information: Portions Copyright [yyyy] [name of copyright owner]
- *
- * CDDL HEADER END
- */
-/*
- * Copyright 2007 Sun Microsystems, Inc.  All rights reserved.
- * Use is subject to license terms.
- */
-
-#pragma ident	"%Z%%M%	%I%	%E% SMI"
-
-/*
- * This plugin supports debugging functionality unique to Intel processors based
- * on the P6 core (Pentium Pro, Pentium II, and Pentium III).  It does not
- * support the Pentium M processor, which uses a P4-style branch trace stack.
- * The Pentium M is supported by the P4 plugin.
- */
-
-#include <kmdb/kvm_cpu_impl.h>
-#include <kmdb/kmdb_dpi.h>
-#include <kmdb/kmdb_kdi.h>
-#include <kmdb/kvm.h>
-#include <mdb/mdb_err.h>
-#include <mdb/mdb.h>
-
-#include <sys/x86_archext.h>
-
-typedef struct kmt_cpu_p6 {
-	uint64_t p6_debugctl;
-} kmt_cpu_p6_t;
-
-/*
- * The debugctl value in this struct needs to outlive the destruction of the
- * kmt_cpu_t.  It needs to be around for the final exit from the debugger so
- * we can do the final write of the debugctl MSR.
- */
-static kmt_cpu_p6_t kmt_cpu_p6;
-
-static void
-kmt_p6_branch(uint_t cpuid, const char *label, uint_t msr)
-{
-	char buf[BUFSIZ];
-	uintptr_t addr;
-
-	addr = (uintptr_t)kmdb_dpi_msr_get_by_cpu(cpuid, msr);
-
-	mdb_printf("%s: %p %A\n", label, addr, addr);
-
-	if (mdb_dis_ins2str(mdb.m_disasm, mdb.m_target,
-	    MDB_TGT_AS_VIRT, buf, sizeof (buf), addr) != addr)
-		mdb_printf("%*s  %s\n", strlen(label), "", buf);
-}
-
-/*ARGSUSED*/
-static int
-kmt_p6_branches(uintptr_t addr, uint_t flags, int argc, const mdb_arg_t *argv)
-{
-	intptr_t cpuid = DPI_MASTER_CPUID;
-
-	if (mdb_getopts(argc, argv,
-	    'c', MDB_OPT_UINTPTR, &cpuid,
-	    NULL) != argc)
-		return (DCMD_USAGE);
-
-	kmt_p6_branch(cpuid, "LastBranchToIP     ", MSR_LBR_TO);
-	kmt_p6_branch(cpuid, "LastBranchFromIP   ", MSR_LBR_FROM);
-	kmt_p6_branch(cpuid, "LastExceptionToIP  ", MSR_LEX_TO);
-	kmt_p6_branch(cpuid, "LastExceptionFromIP", MSR_LEX_FROM);
-
-	return (0);
-}
-
-/*
- * MSRs that we want to track.  These will be read each time the debugger is
- * entered.
- */
-static const kdi_msr_t kmt_p6_msr[] = {
-	{ MSR_DEBUGCTL,	KDI_MSR_CLEARENTRY },
-	{ MSR_DEBUGCTL,	KDI_MSR_WRITEDELAY, &kmt_cpu_p6.p6_debugctl },
-	{ MSR_LBR_TO,	KDI_MSR_READ },
-	{ MSR_LBR_FROM,	KDI_MSR_READ },
-	{ MSR_LEX_TO,	KDI_MSR_READ },
-	{ MSR_LEX_FROM,	KDI_MSR_READ },
-	{ NULL }
-};
-
-/*ARGSUSED*/
-static void
-kmt_p6_destroy(kmt_cpu_t *cpu)
-{
-	/* Leave LBR on */
-
-	mdb_free(cpu, sizeof (kmt_cpu_t));
-}
-
-/*ARGSUSED*/
-static const char *
-kmt_p6_name(kmt_cpu_t *cpu)
-{
-	return ("Intel P6 family (Pentium Pro, Pentium II, Pentium III)");
-}
-
-/*ARGSUSED*/
-static void
-kmt_p6_btf_clear(mdb_tgt_t *t, int id, void *arg)
-{
-	kmt_cpu_p6_t *p6 = arg;
-	kreg_t efl;
-
-	p6->p6_debugctl &= ~DEBUGCTL_BTF;
-
-	(void) kmdb_dpi_get_register("eflags", &efl);
-	efl &= ~(1 << KREG_EFLAGS_TF_SHIFT);
-	(void) kmdb_dpi_set_register("eflags", efl);
-}
-
-/* Enable branch stepping, to be disabled on the next debugger entry */
-static int
-kmt_p6_step_branch(kmt_cpu_t *cpu, mdb_tgt_t *t)
-{
-	kmt_cpu_p6_t *p6 = cpu->kmt_cpu_data;
-	kreg_t efl;
-
-	(void) kmdb_dpi_get_register("eflags", &efl);
-	(void) kmdb_dpi_set_register("eflags",
-	    (efl | (1 << KREG_EFLAGS_TF_SHIFT)));
-
-	p6->p6_debugctl |= DEBUGCTL_BTF;
-
-	return (mdb_tgt_add_fault(t, KMT_TRAP_ALL,
-	    MDB_TGT_SPEC_HIDDEN | MDB_TGT_SPEC_TEMPORARY,
-	    kmt_p6_btf_clear, p6));
-}
-
-static kmt_cpu_ops_t kmt_p6_ops = {
-	kmt_p6_destroy,
-	kmt_p6_name,
-	kmt_p6_step_branch
-};
-
-static const mdb_dcmd_t kmt_p6_dcmds[] = {
-	{ "branches", NULL, "describe the recently-taken branches",
-	    kmt_p6_branches },
-	{ NULL }
-};
-
-/* See 07/04 AP-485 Intel Processor Identification and the CPUID Instruction */
-#define	KMT_CPU_FAMILY_P6	0x6
-#define	KMT_CPU_MODEL_PM_9	0x9	/* Pentium M, model 9 */
-#define	KMT_CPU_MODEL_PM_D	0xd	/* Pentium M, model d */
-
-kmt_cpu_t *
-kmt_cpu_p6_create(mdb_tgt_t *t)
-{
-	uint_t vendor, family, model;
-	kmt_cpu_t *cpu;
-
-	if (kmdb_kdi_get_cpuinfo(&vendor, &family, &model) < 0)
-		return (NULL); /* errno is set for us */
-
-	if (vendor != X86_VENDOR_Intel || family != KMT_CPU_FAMILY_P6 ||
-	    model == KMT_CPU_MODEL_PM_9 || model == KMT_CPU_MODEL_PM_D) {
-		(void) set_errno(ENOTSUP);
-		return (NULL);
-	}
-
-	cpu = mdb_zalloc(sizeof (kmt_cpu_t), UM_SLEEP);
-	cpu->kmt_cpu_ops = &kmt_p6_ops;
-	cpu->kmt_cpu_data = &kmt_cpu_p6;
-
-	kmdb_dpi_msr_add(kmt_p6_msr);
-
-	kmt_cpu_p6.p6_debugctl = DEBUGCTL_LBR; /* enable LBR on resume */
-
-	(void) mdb_tgt_register_dcmds(t, kmt_p6_dcmds, MDB_MOD_FORCE);
-
-	return (cpu);
-}
diff --git a/usr/src/cmd/mdb/intel/kmdb/kaif.c b/usr/src/cmd/mdb/intel/kmdb/kaif.c
index 207ddca12a..c1be6aae0f 100644
--- a/usr/src/cmd/mdb/intel/kmdb/kaif.c
+++ b/usr/src/cmd/mdb/intel/kmdb/kaif.c
@@ -21,10 +21,10 @@
 /*
  * Copyright 2007 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
+ *
+ * Copyright 2018 Joyent, Inc.
  */
 
-#pragma ident	"%Z%%M%	%I%	%E% SMI"
-
 /*
  * The debugger/"PROM" interface layer
  *
@@ -603,38 +603,6 @@ kaif_step(void)
 	}
 }
 
-/*
- * The target has already configured the chip for branch step, leaving us to
- * actually make the machine go.  Due to a number of issues involving
- * the potential alteration of system state via instructions like sti, cli,
- * pushfl, and popfl, we're going to treat this like a normal system resume.
- * All CPUs will be released, on the kernel's IDT.  Our primary concern is
- * the alteration/storage of our TF'd EFLAGS via pushfl and popfl.  There's no
- * real workaround - we don't have opcode breakpoints - so the best we can do is
- * to ensure that the world won't end if someone does bad things to EFLAGS.
- *
- * Two things can happen:
- *  1. EFLAGS.TF may be cleared, either maliciously or via a popfl from saved
- *     state.  The CPU will continue execution beyond the branch, and will not
- *     reenter the debugger unless brought/sent in by other means.
- *  2. Someone may pushlf the TF'd EFLAGS, and may stash a copy of it somewhere.
- *     When the saved version is popfl'd back into place, the debugger will be
- *     re-entered on a single-step trap.
- */
-static void
-kaif_step_branch(void)
-{
-	kreg_t fl;
-
-	(void) kmdb_dpi_get_register(FLAGS_REG_NAME, &fl);
-	(void) kmdb_dpi_set_register(FLAGS_REG_NAME,
-	    (fl | (1 << KREG_EFLAGS_TF_SHIFT)));
-
-	kmdb_dpi_resume_master();
-
-	(void) kmdb_dpi_set_register(FLAGS_REG_NAME, fl);
-}
-
 /*ARGSUSED*/
 static uintptr_t
 kaif_call(uintptr_t funcva, uint_t argc, const uintptr_t argv[])
@@ -724,47 +692,6 @@ kaif_modchg_cancel(void)
 	kaif_modchg_cb = NULL;
 }
 
-static void
-kaif_msr_add(const kdi_msr_t *msrs)
-{
-	kdi_msr_t *save;
-	size_t nr_msrs = 0;
-	size_t i;
-
-	while (msrs[nr_msrs].msr_num != 0)
-		nr_msrs++;
-	/* we want to copy the terminating kdi_msr_t too */
-	nr_msrs++;
-
-	save = mdb_zalloc(sizeof (kdi_msr_t) * nr_msrs * kaif_ncpusave,
-	    UM_SLEEP);
-
-	for (i = 0; i < kaif_ncpusave; i++)
-		bcopy(msrs, &save[nr_msrs * i], sizeof (kdi_msr_t) * nr_msrs);
-
-	kmdb_kdi_set_debug_msrs(save);
-}
-
-static uint64_t
-kaif_msr_get(int cpuid, uint_t num)
-{
-	kdi_cpusave_t *save;
-	kdi_msr_t *msr;
-	int i;
-
-	if ((save = kaif_cpuid2save(cpuid)) == NULL)
-		return (-1); /* errno is set for us */
-
-	msr = save->krs_msr;
-
-	for (i = 0; msr[i].msr_num != 0; i++) {
-		if (msr[i].msr_num == num && (msr[i].msr_type & KDI_MSR_READ))
-			return (msr[i].kdi_msr_val);
-	}
-
-	return (0);
-}
-
 void
 kaif_trap_set_debugger(void)
 {
@@ -884,9 +811,6 @@ dpi_ops_t kmdb_dpi_ops = {
 	kaif_wapt_disarm,
 	kaif_wapt_match,
 	kaif_step,
-	kaif_step_branch,
 	kaif_call,
 	kaif_dump_crumbs,
-	kaif_msr_add,
-	kaif_msr_get,
 };
diff --git a/usr/src/cmd/mdb/intel/kmdb/kmdb_dpi_isadep.c b/usr/src/cmd/mdb/intel/kmdb/kmdb_dpi_isadep.c
index 719e36b8dc..100cbe4be1 100644
--- a/usr/src/cmd/mdb/intel/kmdb/kmdb_dpi_isadep.c
+++ b/usr/src/cmd/mdb/intel/kmdb/kmdb_dpi_isadep.c
@@ -21,10 +21,10 @@
 /*
  * Copyright 2007 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
+ *
+ * Copyright 2018 Joyent, Inc.
  */
 
-#pragma ident	"%Z%%M%	%I%	%E% SMI"
-
 /*
  * Intel-specific portions of the DPI
  */
@@ -142,21 +142,3 @@ kmdb_dpi_reboot(void)
 	 */
 	longjmp(kmdb_dpi_entry_pcb, KMDB_DPI_CMD_REBOOT);
 }
-
-void
-kmdb_dpi_msr_add(const kdi_msr_t *msrs)
-{
-	mdb.m_dpi->dpo_msr_add(msrs);
-}
-
-uint64_t
-kmdb_dpi_msr_get(uint_t msr)
-{
-	return (mdb.m_dpi->dpo_msr_get(DPI_MASTER_CPUID, msr));
-}
-
-uint64_t
-kmdb_dpi_msr_get_by_cpu(int cpuid, uint_t msr)
-{
-	return (mdb.m_dpi->dpo_msr_get(cpuid, msr));
-}
diff --git a/usr/src/cmd/mdb/intel/kmdb/kmdb_dpi_isadep.h b/usr/src/cmd/mdb/intel/kmdb/kmdb_dpi_isadep.h
index 2565c1f843..b2dce29712 100644
--- a/usr/src/cmd/mdb/intel/kmdb/kmdb_dpi_isadep.h
+++ b/usr/src/cmd/mdb/intel/kmdb/kmdb_dpi_isadep.h
@@ -21,13 +21,13 @@
 /*
  * Copyright 2007 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
+ *
+ * Copyright 2018 Joyent, Inc.
  */
 
 #ifndef _KMDB_DPI_ISADEP_H
 #define	_KMDB_DPI_ISADEP_H
 
-#pragma ident	"%Z%%M%	%I%	%E% SMI"
-
 #ifndef _ASM
 #include <mdb/mdb_isautil.h>
 #include <sys/kdi_machimpl.h>
@@ -43,10 +43,6 @@ extern void kmdb_dpi_handle_fault(kreg_t, kreg_t, kreg_t, int);
 
 extern void kmdb_dpi_reboot(void) __NORETURN;
 
-extern void kmdb_dpi_msr_add(const kdi_msr_t *);
-extern uint64_t kmdb_dpi_msr_get(uint_t);
-extern uint64_t kmdb_dpi_msr_get_by_cpu(int, uint_t);
-
 #endif /* _ASM */
 
 #ifdef __cplusplus
diff --git a/usr/src/cmd/mdb/intel/kmdb/kmdb_kdi_isadep.c b/usr/src/cmd/mdb/intel/kmdb/kmdb_kdi_isadep.c
index a556c90041..2214c7c0ce 100644
--- a/usr/src/cmd/mdb/intel/kmdb/kmdb_kdi_isadep.c
+++ b/usr/src/cmd/mdb/intel/kmdb/kmdb_kdi_isadep.c
@@ -21,10 +21,10 @@
 /*
  * Copyright 2007 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
+ *
+ * Copyright 2018 Joyent, Inc.
  */
 
-#pragma ident	"%Z%%M%	%I%	%E% SMI"
-
 #include <sys/types.h>
 #include <sys/kdi_impl.h>
 #include <sys/segments.h>
@@ -103,12 +103,6 @@ kmdb_kdi_update_drreg(kdi_drreg_t *drreg)
 	mdb.m_kdi->mkdi_update_drreg(drreg);
 }
 
-void
-kmdb_kdi_set_debug_msrs(kdi_msr_t *msrs)
-{
-	mdb.m_kdi->mkdi_set_debug_msrs(msrs);
-}
-
 void
 kmdb_kdi_memrange_add(caddr_t base, size_t len)
 {
diff --git a/usr/src/cmd/mdb/intel/kmdb/kmdb_kdi_isadep.h b/usr/src/cmd/mdb/intel/kmdb/kmdb_kdi_isadep.h
index 1813b382e3..a4ebf625b6 100644
--- a/usr/src/cmd/mdb/intel/kmdb/kmdb_kdi_isadep.h
+++ b/usr/src/cmd/mdb/intel/kmdb/kmdb_kdi_isadep.h
@@ -21,13 +21,13 @@
 /*
  * Copyright 2007 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
+ *
+ * Copyright 2018 Joyent, Inc.
  */
 
 #ifndef _KMDB_KDI_ISADEP_H
 #define	_KMDB_KDI_ISADEP_H
 
-#pragma ident	"%Z%%M%	%I%	%E% SMI"
-
 #include <sys/types.h>
 #include <sys/kdi_machimpl.h>
 
@@ -45,7 +45,6 @@ extern void kmdb_kdi_deactivate(void);
 extern void kmdb_kdi_idt_switch(kdi_cpusave_t *);
 
 extern void kmdb_kdi_update_drreg(kdi_drreg_t *);
-extern void kmdb_kdi_set_debug_msrs(kdi_msr_t *);
 
 extern uintptr_t kmdb_kdi_get_userlimit(void);
 
diff --git a/usr/src/cmd/mdb/intel/kmdb/kvm_cpu_amd.c b/usr/src/cmd/mdb/intel/kmdb/kvm_cpu_amd.c
deleted file mode 100644
index 6b67853220..0000000000
--- a/usr/src/cmd/mdb/intel/kmdb/kvm_cpu_amd.c
+++ /dev/null
@@ -1,213 +0,0 @@
-/*
- * CDDL HEADER START
- *
- * The contents of this file are subject to the terms of the
- * Common Development and Distribution License (the "License").
- * You may not use this file except in compliance with the License.
- *
- * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
- * or http://www.opensolaris.org/os/licensing.
- * See the License for the specific language governing permissions
- * and limitations under the License.
- *
- * When distributing Covered Code, include this CDDL HEADER in each
- * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
- * If applicable, add the following below this CDDL HEADER, with the
- * fields enclosed by brackets "[]" replaced with your own identifying
- * information: Portions Copyright [yyyy] [name of copyright owner]
- *
- * CDDL HEADER END
- */
-/*
- * Copyright 2007 Sun Microsystems, Inc.  All rights reserved.
- * Use is subject to license terms.
- */
-
-#pragma ident	"%Z%%M%	%I%	%E% SMI"
-
-/*
- * Debugging functionality unique to 64-bit AMD processors.
- */
-
-#include <kmdb/kvm_cpu_impl.h>
-#include <kmdb/kmdb_dpi.h>
-#include <kmdb/kmdb_kdi.h>
-#include <kmdb/kvm.h>
-#include <mdb/mdb_err.h>
-#include <mdb/mdb.h>
-
-#include <sys/x86_archext.h>
-
-typedef struct kmt_cpu_amd {
-	uint64_t amd_debugctl;		/* value for debugctl MSR */
-	const kdi_msr_t *amd_msrs;	/* MSR r/w list */
-	uint_t amd_family;		/* CPUID family */
-	uint_t amd_model;		/* CPUID model */
-} kmt_cpu_amd_t;
-
-/*
- * The debugctl value in this struct needs to outlive the destruction of the
- * kmt_cpu_t.  It needs to be around for the final exit from the debugger so
- * we can do the final write of the debugctl MSR.
- */
-static kmt_cpu_amd_t kmt_cpu_amd;
-
-static void
-kmt_amd_branch(uint_t cpuid, const char *label, uint_t msr)
-{
-	char buf[BUFSIZ];
-	uintptr_t addr;
-
-	addr = (uintptr_t)kmdb_dpi_msr_get_by_cpu(cpuid, msr);
-
-	mdb_printf("%s: %p %A\n", label, addr, addr);
-
-	if (mdb_dis_ins2str(mdb.m_disasm, mdb.m_target,
-	    MDB_TGT_AS_VIRT, buf, sizeof (buf), addr) != addr)
-		mdb_printf("%*s  %s\n", strlen(label), "", buf);
-}
-
-/*
- * MSRs for AMD processors with simple branch tracing facilities.  We'll use
- * this array if we can access listed LBR/LEX MSRs.
- */
-static const kdi_msr_t kmt_amd_msrs[] = {
-	{ MSR_DEBUGCTL,	KDI_MSR_CLEARENTRY },
-	{ MSR_DEBUGCTL,	KDI_MSR_WRITEDELAY, &kmt_cpu_amd.amd_debugctl },
-	{ MSR_LBR_TO,	KDI_MSR_READ },
-	{ MSR_LBR_FROM,	KDI_MSR_READ },
-	{ MSR_LEX_TO,	KDI_MSR_READ },
-	{ MSR_LEX_FROM,	KDI_MSR_READ },
-	{ NULL }
-};
-
-/*
- * Fallback MSR list for use if we can't read the LBR/LEX MSRs.
- */
-static const kdi_msr_t kmt_amdunk_msrs[] = {
-	{ MSR_DEBUGCTL,	KDI_MSR_CLEARENTRY },
-	{ MSR_DEBUGCTL,	KDI_MSR_WRITEDELAY, &kmt_cpu_amd.amd_debugctl },
-	{ NULL }
-};
-
-/*ARGSUSED*/
-static void
-kmt_amd_destroy(kmt_cpu_t *cpu)
-{
-	/* Leave LBR on */
-
-	mdb_free(cpu, sizeof (kmt_cpu_t));
-}
-
-/*ARGSUSED*/
-static const char *
-kmt_amd_name(kmt_cpu_t *cpu)
-{
-	return ("AMD");
-}
-
-/*ARGSUSED*/
-static void
-kmt_amd_btf_clear(mdb_tgt_t *t, int id, void *arg)
-{
-	kmt_cpu_amd_t *amd = arg;
-	kreg_t efl;
-
-	amd->amd_debugctl &= ~DEBUGCTL_BTF;
-
-	(void) kmdb_dpi_get_register("rflags", &efl);
-	efl &= ~(1 << KREG_EFLAGS_TF_SHIFT);
-	(void) kmdb_dpi_set_register("rflags", efl);
-}
-
-/* Enable branch stepping, to be disabled on the next debugger entry */
-static int
-kmt_amd_step_branch(kmt_cpu_t *cpu, mdb_tgt_t *t)
-{
-	kmt_cpu_amd_t *amd = cpu->kmt_cpu_data;
-	kreg_t efl;
-
-	(void) kmdb_dpi_get_register("rflags", &efl);
-	(void) kmdb_dpi_set_register("rflags",
-	    (efl | (1 << KREG_EFLAGS_TF_SHIFT)));
-
-	amd->amd_debugctl |= DEBUGCTL_BTF;
-
-	return (mdb_tgt_add_fault(t, KMT_TRAP_ALL,
-	    MDB_TGT_SPEC_HIDDEN | MDB_TGT_SPEC_TEMPORARY,
-	    kmt_amd_btf_clear, amd));
-}
-
-static kmt_cpu_ops_t kmt_amd_ops = {
-	kmt_amd_destroy,
-	kmt_amd_name,
-	kmt_amd_step_branch
-};
-
-/*ARGSUSED*/
-static int
-kmt_amd_branches(uintptr_t addr, uint_t flags, int argc,
-    const mdb_arg_t *argv)
-{
-	intptr_t cpuid = DPI_MASTER_CPUID;
-
-	if (kmt_cpu_amd.amd_msrs == kmt_amdunk_msrs) {
-		warn("branch tracing unavailable on unknown AMD CPU "
-		    "(id: %x/%x)\n", kmt_cpu_amd.amd_family,
-		    kmt_cpu_amd.amd_model);
-		return (DCMD_ERR);
-	}
-
-	if (mdb_getopts(argc, argv,
-	    'c', MDB_OPT_UINTPTR, &cpuid,
-	    NULL) != argc)
-		return (DCMD_USAGE);
-
-	kmt_amd_branch(cpuid, "LastBranchToIP     ", MSR_LBR_TO);
-	kmt_amd_branch(cpuid, "LastBranchFromIP   ", MSR_LBR_FROM);
-	kmt_amd_branch(cpuid, "LastExceptionToIP  ", MSR_LEX_TO);
-	kmt_amd_branch(cpuid, "LastExceptionFromIP", MSR_LEX_FROM);
-
-	return (0);
-}
-
-static const mdb_dcmd_t kmt_amd_dcmds[] = {
-	{ "branches", NULL, "describe the recently-taken branches",
-	    kmt_amd_branches },
-	{ NULL }
-};
-
-kmt_cpu_t *
-kmt_cpu_amd_create(mdb_tgt_t *t)
-{
-	uint_t vendor, family, model;
-	kmt_cpu_t *cpu;
-
-	if (kmdb_kdi_get_cpuinfo(&vendor, &family, &model) < 0)
-		return (NULL); /* errno is set for us */
-
-	if (vendor != X86_VENDOR_AMD) {
-		(void) set_errno(ENOTSUP);
-		return (NULL);
-	}
-
-	kmt_cpu_amd.amd_family = family;
-	kmt_cpu_amd.amd_model = model;
-	kmt_cpu_amd.amd_msrs = kmt_amdunk_msrs;
-	kmt_cpu_amd.amd_debugctl = DEBUGCTL_LBR; /* Enable LBR on resume */
-
-	cpu = mdb_zalloc(sizeof (kmt_cpu_t), UM_SLEEP);
-	cpu->kmt_cpu_ops = &kmt_amd_ops;
-	cpu->kmt_cpu_data = &kmt_cpu_amd;
-
-	/*
-	 * Use the LBR/LEX MSRs if this CPU supports them.
-	 */
-	if (kmt_msr_validate(kmt_amd_msrs))
-		kmt_cpu_amd.amd_msrs = kmt_amd_msrs;
-
-	(void) mdb_tgt_register_dcmds(t, kmt_amd_dcmds, MDB_MOD_FORCE);
-	kmdb_dpi_msr_add(kmt_cpu_amd.amd_msrs);
-
-	return (cpu);
-}
diff --git a/usr/src/cmd/mdb/intel/kmdb/kvm_cpu_p4.c b/usr/src/cmd/mdb/intel/kmdb/kvm_cpu_p4.c
deleted file mode 100644
index 50694fe76e..0000000000
--- a/usr/src/cmd/mdb/intel/kmdb/kvm_cpu_p4.c
+++ /dev/null
@@ -1,418 +0,0 @@
-/*
- * CDDL HEADER START
- *
- * The contents of this file are subject to the terms of the
- * Common Development and Distribution License (the "License").
- * You may not use this file except in compliance with the License.
- *
- * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
- * or http://www.opensolaris.org/os/licensing.
- * See the License for the specific language governing permissions
- * and limitations under the License.
- *
- * When distributing Covered Code, include this CDDL HEADER in each
- * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
- * If applicable, add the following below this CDDL HEADER, with the
- * fields enclosed by brackets "[]" replaced with your own identifying
- * information: Portions Copyright [yyyy] [name of copyright owner]
- *
- * CDDL HEADER END
- */
-/*
- * Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
- * Use is subject to license terms.
- */
-
-/*
- * This plugin supports debugging functionality unique to Intel processors based
- * on the NetBurst (P4) microarchitecture.  It also supports the Pentium M, a
- * processor which uses the P6 family code but provides a P4-style branch
- * tracing stack.
- */
-
-#include <kmdb/kvm_cpu_impl.h>
-#include <kmdb/kmdb_dpi.h>
-#include <kmdb/kmdb_kdi.h>
-#include <kmdb/kvm.h>
-#include <mdb/mdb_err.h>
-#include <mdb/mdb_debug.h>
-#include <mdb/mdb.h>
-
-#include <sys/x86_archext.h>
-
-/*
- * As of this writing, Intel has three different flavors of branch stack.
- * They're essentially the same, but the MSR addresses, stack size, and access
- * methods differ.  We've got one kmt_p4_flavor_t for each type of branch
- * stack.
- */
-typedef struct kmt_p4_flavor {
-	const char *p4f_name;			/* name for CPU support */
-	const kdi_msr_t *p4f_msrs;		/* MSR r/w list */
-	int (*p4f_branches)(const struct kmt_p4_flavor *, uint_t,
-	    intptr_t, int);			/* dumper for CPU branch stk */
-	uint_t p4f_msr_tos;			/* branch stk index MSR */
-	uint_t p4f_lbrstk_from_base;		/* low "from" branch stk MSR */
-	uint_t p4f_lbrstk_to_base;		/* low "to" branch stk MSR */
-	size_t p4f_lbrstk_num;			/* number of entries in stk */
-} kmt_p4_flavor_t;
-
-typedef struct kmt_cpu_p4 {
-	uint64_t p4_debugctl;			/* value for debugctl MSR */
-	const kmt_p4_flavor_t *p4_flavor;	/* parameters for this proc */
-	uint_t p4_model;			/* CPUID model */
-} kmt_cpu_p4_t;
-
-/* See 07/04 AP-485 Intel Processor Identification and the CPUID Instruction */
-#define	KMT_CPU_FAMILY_P6	0x6	/* For this plugin, the Pentium M */
-#define	KMT_CPU_FAMILY_P4	0xf	/* "Netburst" CPUs (P4s) */
-#define	KMT_CPU_MODEL_PM_9	0x9	/* Pentium M, model 9 */
-#define	KMT_CPU_MODEL_PM_D	0xd	/* Pentium M, model d */
-
-
-static kmt_cpu_p4_t kmt_cpu_p4;
-
-static void
-kmt_p4_branch(uintptr_t from, uintptr_t to, int verbose)
-{
-	if (verbose) {
-		uintptr_t addr = mdb_dis_previns(mdb.m_disasm, mdb.m_target,
-		    MDB_TGT_AS_VIRT, from, 3);
-
-		mdb_printf("%<b>%-39a %-39a%</b>\n", from, to);
-
-		while (addr <= from) {
-			char buf[80];
-			uintptr_t next;
-			char *c;
-
-			if ((next = mdb_dis_ins2str(mdb.m_disasm, mdb.m_target,
-			    MDB_TGT_AS_VIRT, buf, sizeof (buf), addr)) == addr)
-				(void) strcpy(buf, "???");
-
-			for (c = buf + strlen(buf) - 1;
-			    c > buf && (*c == ' ' || *c == '\t');
-			    c--)
-			;
-
-			if (*c == '>') {
-				while (c > buf && *c != '<')
-					c--;
-
-				if (*c == '<')
-					*c = '\0';
-			}
-
-			if (addr == from) {
-				mdb_printf("\t%<b>%-#32a%8T%s%</b>\n",
-				    addr, buf);
-			} else {
-				mdb_printf("\t%-#32a%8T%s\n", addr, buf);
-			}
-
-			if (next == addr)
-				break;
-
-			addr = next;
-		}
-		mdb_printf("\n");
-	} else {
-		mdb_printf("%-39a %-39a\n", from, to);
-	}
-}
-
-#ifndef __amd64
-static int
-kmt_p4_branches_unified(const kmt_p4_flavor_t *p4f, uint_t tos, intptr_t cpuid,
-    int verbose)
-{
-	uint_t cur;
-	int i;
-
-	for (cur = tos, i = 0; i < p4f->p4f_lbrstk_num;
-	    i++, cur = (cur + p4f->p4f_lbrstk_num - 1) % p4f->p4f_lbrstk_num) {
-		uint64_t rec = kmdb_dpi_msr_get_by_cpu(cpuid,
-		    p4f->p4f_lbrstk_from_base + cur);
-
-		kmt_p4_branch((rec & 0xffffffff), rec >> 32, verbose);
-	}
-
-	return (0);
-}
-#endif	/* !__amd64 */
-
-static int
-kmt_p4_branches_split(const kmt_p4_flavor_t *p4f, uint_t tos, intptr_t cpuid,
-    int verbose)
-{
-	uint_t cur;
-	int i;
-
-	for (cur = tos, i = 0; i < p4f->p4f_lbrstk_num;
-	    i++, cur = (cur + p4f->p4f_lbrstk_num - 1) % p4f->p4f_lbrstk_num) {
-		uintptr_t from = (uintptr_t)kmdb_dpi_msr_get_by_cpu(cpuid,
-		    p4f->p4f_lbrstk_from_base + cur);
-		uintptr_t to = (uintptr_t)kmdb_dpi_msr_get_by_cpu(cpuid,
-		    p4f->p4f_lbrstk_to_base + cur);
-
-		kmt_p4_branch(from, to, verbose);
-	}
-
-	return (0);
-}
-
-#ifndef __amd64
-static const kdi_msr_t kmt_p4orig_msrs[] = {
-	{ MSR_DEBUGCTL,		KDI_MSR_CLEARENTRY },
-	{ MSR_DEBUGCTL,		KDI_MSR_WRITEDELAY, &kmt_cpu_p4.p4_debugctl },
-	{ MSR_P4_LBSTK_TOS,	KDI_MSR_READ },
-	{ MSR_P4_LBSTK_0,	KDI_MSR_READ },
-	{ MSR_P4_LBSTK_1,	KDI_MSR_READ },
-	{ MSR_P4_LBSTK_2,	KDI_MSR_READ },
-	{ MSR_P4_LBSTK_3,	KDI_MSR_READ },
-	{ NULL }
-};
-
-static const kmt_p4_flavor_t kmt_p4_original = {
-	"Intel Pentium 4 (pre-Prescott)",
-	kmt_p4orig_msrs, kmt_p4_branches_unified, MSR_P4_LBSTK_TOS,
-	MSR_P4_LBSTK_0, MSR_P4_LBSTK_0, 4
-};
-
-static const kdi_msr_t kmt_p6m_msrs[] = {
-	{ MSR_DEBUGCTL,		KDI_MSR_CLEARENTRY },
-	{ MSR_DEBUGCTL,		KDI_MSR_WRITEDELAY, &kmt_cpu_p4.p4_debugctl },
-	{ MSR_P6M_LBSTK_TOS,	KDI_MSR_READ },
-	{ MSR_P6M_LBSTK_0,	KDI_MSR_READ },
-	{ MSR_P6M_LBSTK_1,	KDI_MSR_READ },
-	{ MSR_P6M_LBSTK_2,	KDI_MSR_READ },
-	{ MSR_P6M_LBSTK_3,	KDI_MSR_READ },
-	{ MSR_P6M_LBSTK_4,	KDI_MSR_READ },
-	{ MSR_P6M_LBSTK_5,	KDI_MSR_READ },
-	{ MSR_P6M_LBSTK_6,	KDI_MSR_READ },
-	{ MSR_P6M_LBSTK_7,	KDI_MSR_READ },
-	{ NULL }
-};
-
-static const kmt_p4_flavor_t kmt_p6_m = {
-	"Intel Pentium M",
-	kmt_p6m_msrs, kmt_p4_branches_unified, MSR_P6M_LBSTK_TOS,
-	MSR_P6M_LBSTK_0, MSR_P6M_LBSTK_0, 8
-};
-#endif	/* __amd64 */
-
-static const kdi_msr_t kmt_prp4_msrs[] = {
-	{ MSR_DEBUGCTL,		KDI_MSR_CLEARENTRY },
-	{ MSR_DEBUGCTL,		KDI_MSR_WRITEDELAY, &kmt_cpu_p4.p4_debugctl },
-	{ MSR_PRP4_LBSTK_TOS,	KDI_MSR_READ },
-	{ MSR_PRP4_LBSTK_FROM_0, KDI_MSR_READ },
-	{ MSR_PRP4_LBSTK_FROM_1, KDI_MSR_READ },
-	{ MSR_PRP4_LBSTK_FROM_2, KDI_MSR_READ },
-	{ MSR_PRP4_LBSTK_FROM_3, KDI_MSR_READ },
-	{ MSR_PRP4_LBSTK_FROM_4, KDI_MSR_READ },
-	{ MSR_PRP4_LBSTK_FROM_5, KDI_MSR_READ },
-	{ MSR_PRP4_LBSTK_FROM_6, KDI_MSR_READ },
-	{ MSR_PRP4_LBSTK_FROM_7, KDI_MSR_READ },
-	{ MSR_PRP4_LBSTK_FROM_8, KDI_MSR_READ },
-	{ MSR_PRP4_LBSTK_FROM_9, KDI_MSR_READ },
-	{ MSR_PRP4_LBSTK_FROM_10, KDI_MSR_READ },
-	{ MSR_PRP4_LBSTK_FROM_11, KDI_MSR_READ },
-	{ MSR_PRP4_LBSTK_FROM_12, KDI_MSR_READ },
-	{ MSR_PRP4_LBSTK_FROM_13, KDI_MSR_READ },
-	{ MSR_PRP4_LBSTK_FROM_14, KDI_MSR_READ },
-	{ MSR_PRP4_LBSTK_FROM_15, KDI_MSR_READ },
-	{ MSR_PRP4_LBSTK_TO_0,	KDI_MSR_READ },
-	{ MSR_PRP4_LBSTK_TO_1,	KDI_MSR_READ },
-	{ MSR_PRP4_LBSTK_TO_2,	KDI_MSR_READ },
-	{ MSR_PRP4_LBSTK_TO_3,	KDI_MSR_READ },
-	{ MSR_PRP4_LBSTK_TO_4,	KDI_MSR_READ },
-	{ MSR_PRP4_LBSTK_TO_5,	KDI_MSR_READ },
-	{ MSR_PRP4_LBSTK_TO_6,	KDI_MSR_READ },
-	{ MSR_PRP4_LBSTK_TO_7,	KDI_MSR_READ },
-	{ MSR_PRP4_LBSTK_TO_8,	KDI_MSR_READ },
-	{ MSR_PRP4_LBSTK_TO_9,	KDI_MSR_READ },
-	{ MSR_PRP4_LBSTK_TO_10,	KDI_MSR_READ },
-	{ MSR_PRP4_LBSTK_TO_11,	KDI_MSR_READ },
-	{ MSR_PRP4_LBSTK_TO_12,	KDI_MSR_READ },
-	{ MSR_PRP4_LBSTK_TO_13,	KDI_MSR_READ },
-	{ MSR_PRP4_LBSTK_TO_14,	KDI_MSR_READ },
-	{ MSR_PRP4_LBSTK_TO_15,	KDI_MSR_READ },
-	{ NULL }
-};
-
-static const kmt_p4_flavor_t kmt_p4_prescott = {
-	"Intel Pentium 4 (Prescott)",
-	kmt_prp4_msrs, kmt_p4_branches_split, MSR_PRP4_LBSTK_TOS,
-	MSR_PRP4_LBSTK_FROM_0, MSR_PRP4_LBSTK_TO_0, 16
-};
-
-static const kdi_msr_t kmt_p4unk_msrs[] = {
-	{ MSR_DEBUGCTL,		KDI_MSR_CLEARENTRY },
-	{ MSR_DEBUGCTL,		KDI_MSR_WRITEDELAY, &kmt_cpu_p4.p4_debugctl },
-	{ NULL }
-};
-
-static const kmt_p4_flavor_t kmt_p4_unknown = {
-	"Unrecognized Intel Pentium 4",
-	kmt_p4unk_msrs, NULL, 0,
-	0, 0, 0
-};
-
-/*ARGSUSED*/
-static void
-kmt_p4_destroy(kmt_cpu_t *cpu)
-{
-	/* Leave LBR on */
-
-	mdb_free(cpu, sizeof (kmt_cpu_t));
-}
-
-/*ARGSUSED*/
-static const char *
-kmt_p4_name(kmt_cpu_t *cpu)
-{
-	return (kmt_cpu_p4.p4_flavor->p4f_name);
-}
-
-/*ARGSUSED*/
-static void
-kmt_p4_btf_clear(mdb_tgt_t *t, int id, void *arg)
-{
-	kmt_cpu_p4_t *p4 = arg;
-	kreg_t efl;
-
-	p4->p4_debugctl &= ~DEBUGCTL_BTF;
-
-	(void) kmdb_dpi_get_register("eflags", &efl);
-	efl &= ~(1 << KREG_EFLAGS_TF_SHIFT);
-	(void) kmdb_dpi_set_register("eflags", efl);
-}
-
-static int
-kmt_p4_step_branch(kmt_cpu_t *cpu, mdb_tgt_t *t)
-{
-	kmt_cpu_p4_t *p4 = cpu->kmt_cpu_data;
-	kreg_t efl;
-
-	(void) kmdb_dpi_get_register("eflags", &efl);
-	(void) kmdb_dpi_set_register("eflags",
-	    (efl | (1 << KREG_EFLAGS_TF_SHIFT)));
-
-	p4->p4_debugctl |= DEBUGCTL_BTF;
-
-	return (mdb_tgt_add_fault(t, KMT_TRAP_ALL,
-	    MDB_TGT_SPEC_HIDDEN | MDB_TGT_SPEC_TEMPORARY,
-	    kmt_p4_btf_clear, p4));
-}
-
-static kmt_cpu_ops_t kmt_p4_ops = {
-	kmt_p4_destroy,
-	kmt_p4_name,
-	kmt_p4_step_branch
-};
-
-/*ARGSUSED*/
-static int
-kmt_p4_branches(uintptr_t addr, uint_t flags, int argc, const mdb_arg_t *argv)
-{
-	const kmt_p4_flavor_t *p4f = kmt_cpu_p4.p4_flavor;
-	intptr_t cpuid = DPI_MASTER_CPUID;
-	uint_t tos;
-	int verbose = FALSE;
-
-	if (p4f->p4f_branches == NULL) {
-		warn("branch tracing unavailable on unknown P4 CPU "
-		    "(model %x)\n", kmt_cpu_p4.p4_model);
-		return (DCMD_ERR);
-	}
-
-	if (mdb_getopts(argc, argv,
-	    'c', MDB_OPT_UINTPTR, &cpuid,
-	    'v', MDB_OPT_SETBITS, TRUE, &verbose,
-	    NULL) != argc)
-		return (DCMD_USAGE);
-
-	ASSERT(!(p4f->p4f_lbrstk_num & (p4f->p4f_lbrstk_num - 1)));
-
-	tos = (uintptr_t)kmdb_dpi_msr_get_by_cpu(cpuid, p4f->p4f_msr_tos);
-	tos &= p4f->p4f_lbrstk_num - 1;
-
-	mdb_printf("%<u>%-39s %-39s%</u>\n", "FROM", "TO");
-
-	return (p4f->p4f_branches(p4f, tos, cpuid, verbose));
-}
-
-static const mdb_dcmd_t kmt_p4_dcmds[] = {
-	{ "branches", NULL, "describe the recently-taken branches",
-	    kmt_p4_branches },
-	{ NULL }
-};
-
-/*ARGSUSED*/
-const kmt_p4_flavor_t *
-cpu2flavor(uint_t vendor, uint_t family, uint_t model)
-{
-	if (vendor != X86_VENDOR_Intel)
-		return (NULL);
-
-#ifndef __amd64
-	if (family == KMT_CPU_FAMILY_P6) {
-		if (model == KMT_CPU_MODEL_PM_9 || model == KMT_CPU_MODEL_PM_D)
-			return (&kmt_p6_m);
-		else
-			return (NULL);
-	}
-
-	if (family == KMT_CPU_FAMILY_P4 && model < 3)
-		return (&kmt_p4_original);
-#endif	/* !__amd64 */
-
-	if (family == KMT_CPU_FAMILY_P4) {
-		/*
-		 * If this is a model 3, then we've got a Prescott.  On the
-		 * other hand, this could be the future, and Intel could have
-		 * released a whizzy new processor.  Users shouldn't have to
-		 * wait for us to patch the debugger for each new P4 model,
-		 * so we'll try to use this CPU as a Prescott.  In the past,
-		 * when Intel has changed the branch stack, they've done it by
-		 * moving the MSRs, returning #gp's for the old ones.  Our
-		 * Prescott check will therefore be an attempt to read the
-		 * Prescott MSRs.  This attempt should fail if Intel has changed
-		 * the branch stack again.
-		 */
-		if (kmt_msr_validate(kmt_prp4_msrs))
-			return (&kmt_p4_prescott);
-		else
-			return (&kmt_p4_unknown);
-	}
-
-	return (NULL);
-}
-
-kmt_cpu_t *
-kmt_cpu_p4_create(mdb_tgt_t *t)
-{
-	uint_t vendor, family, model;
-	kmt_cpu_t *cpu;
-
-	if (kmdb_kdi_get_cpuinfo(&vendor, &family, &model) < 0)
-		return (NULL); /* errno is set for us */
-
-	if ((kmt_cpu_p4.p4_flavor = cpu2flavor(vendor, family, model)) ==
-	    NULL) {
-		(void) set_errno(ENOTSUP);
-		return (NULL);
-	}
-
-	kmt_cpu_p4.p4_model = model;
-	kmt_cpu_p4.p4_debugctl = DEBUGCTL_LBR; /* enable LBR on resume */
-
-	cpu = mdb_zalloc(sizeof (kmt_cpu_t), UM_SLEEP);
-	cpu->kmt_cpu_ops = &kmt_p4_ops;
-	cpu->kmt_cpu_data = &kmt_cpu_p4;
-
-	kmdb_dpi_msr_add(kmt_cpu_p4.p4_flavor->p4f_msrs);
-	(void) mdb_tgt_register_dcmds(t, kmt_p4_dcmds, MDB_MOD_FORCE);
-
-	return (cpu);
-}
diff --git a/usr/src/cmd/mdb/intel/kmdb/kvm_isadep.c b/usr/src/cmd/mdb/intel/kmdb/kvm_isadep.c
index a76cc5ba3d..cc25f355f1 100644
--- a/usr/src/cmd/mdb/intel/kmdb/kvm_isadep.c
+++ b/usr/src/cmd/mdb/intel/kmdb/kvm_isadep.c
@@ -21,16 +21,15 @@
 /*
  * Copyright 2007 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
+ *
+ * Copyright 2018 Joyent, Inc.
  */
 
-#pragma ident	"%Z%%M%	%I%	%E% SMI"
-
 /*
  * isa-dependent portions of the kmdb target
  */
 
 #include <kmdb/kvm.h>
-#include <kmdb/kvm_cpu.h>
 #include <kmdb/kmdb_kdi.h>
 #include <kmdb/kmdb_asmutil.h>
 #include <mdb/mdb_debug.h>
@@ -101,14 +100,6 @@ kmt_step_out(mdb_tgt_t *t, uintptr_t *p)
 	return (mdb_isa_step_out(t, p, pc, fp, sp, instr));
 }
 
-int
-kmt_step_branch(mdb_tgt_t *t)
-{
-	kmt_data_t *kmt = t->t_data;
-
-	return (kmt_cpu_step_branch(t, kmt->kmt_cpu));
-}
-
 /*
  * Return the address of the next instruction following a call, or return -1
  * and set errno to EAGAIN if the target should just single-step.
@@ -356,19 +347,6 @@ kmt_wrmsr(uintptr_t addr, uint_t flags, int argc, const mdb_arg_t *argv)
 	return (DCMD_OK);
 }
 
-int
-kmt_msr_validate(const kdi_msr_t *msr)
-{
-	uint64_t val;
-
-	for (/* */; msr->msr_num != 0; msr++) {
-		if (kmt_rwmsr(msr->msr_num, &val, rdmsr) < 0)
-			return (0);
-	}
-
-	return (1);
-}
-
 /*ARGSUSED*/
 ssize_t
 kmt_write(mdb_tgt_t *t, const void *buf, size_t nbytes, uintptr_t addr)
diff --git a/usr/src/cmd/mdb/intel/kmdb/kvm_isadep.h b/usr/src/cmd/mdb/intel/kmdb/kvm_isadep.h
index e944c6ca8b..0f9f5f1935 100644
--- a/usr/src/cmd/mdb/intel/kmdb/kvm_isadep.h
+++ b/usr/src/cmd/mdb/intel/kmdb/kvm_isadep.h
@@ -21,13 +21,13 @@
 /*
  * Copyright 2007 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
+ *
+ * Copyright 2018 Joyent, Inc.
  */
 
 #ifndef _KVM_ISADEP_H
 #define	_KVM_ISADEP_H
 
-#pragma ident	"%Z%%M%	%I%	%E% SMI"
-
 #ifdef __cplusplus
 extern "C" {
 #endif
@@ -45,7 +45,6 @@ extern int kmt_wrmsr(uintptr_t, uint_t, int, const mdb_arg_t *);
 
 extern int kmt_rdpcicfg(uintptr_t, uint_t, int, const mdb_arg_t *);
 extern int kmt_wrpcicfg(uintptr_t, uint_t, int, const mdb_arg_t *);
-extern int kmt_msr_validate(const kdi_msr_t *);
 
 #ifdef __cplusplus
 }
diff --git a/usr/src/cmd/mdb/intel/mdb/kvm_amd64dep.c b/usr/src/cmd/mdb/intel/mdb/kvm_amd64dep.c
index b3ecd9caed..b878fef855 100644
--- a/usr/src/cmd/mdb/intel/mdb/kvm_amd64dep.c
+++ b/usr/src/cmd/mdb/intel/mdb/kvm_amd64dep.c
@@ -21,10 +21,10 @@
 /*
  * Copyright 2008 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
+ *
+ * Copyright 2018 Joyent, Inc.
  */
 
-#pragma ident	"%Z%%M%	%I%	%E% SMI"
-
 /*
  * Libkvm Kernel Target Intel 64-bit component
  *
@@ -138,7 +138,6 @@ const mdb_tgt_ops_t kt_amd64_ops = {
 	(int (*)()) mdb_tgt_notsup,		/* t_run */
 	(int (*)()) mdb_tgt_notsup,		/* t_step */
 	(int (*)()) mdb_tgt_notsup,		/* t_step_out */
-	(int (*)()) mdb_tgt_notsup,		/* t_step_branch */
 	(int (*)()) mdb_tgt_notsup,		/* t_next */
 	(int (*)()) mdb_tgt_notsup,		/* t_cont */
 	(int (*)()) mdb_tgt_notsup,		/* t_signal */
diff --git a/usr/src/cmd/mdb/intel/mdb/kvm_ia32dep.c b/usr/src/cmd/mdb/intel/mdb/kvm_ia32dep.c
index 3850fddd89..64cbaff939 100644
--- a/usr/src/cmd/mdb/intel/mdb/kvm_ia32dep.c
+++ b/usr/src/cmd/mdb/intel/mdb/kvm_ia32dep.c
@@ -21,10 +21,10 @@
 /*
  * Copyright 2008 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
+ *
+ * Copyright 2018 Joyent, Inc.
  */
 
-#pragma ident	"%Z%%M%	%I%	%E% SMI"
-
 /*
  * Libkvm Kernel Target Intel 32-bit component
  *
@@ -138,7 +138,6 @@ const mdb_tgt_ops_t kt_ia32_ops = {
 	(int (*)()) mdb_tgt_notsup,		/* t_run */
 	(int (*)()) mdb_tgt_notsup,		/* t_step */
 	(int (*)()) mdb_tgt_notsup,		/* t_step_out */
-	(int (*)()) mdb_tgt_notsup,		/* t_step_branch */
 	(int (*)()) mdb_tgt_notsup,		/* t_next */
 	(int (*)()) mdb_tgt_notsup,		/* t_cont */
 	(int (*)()) mdb_tgt_notsup,		/* t_signal */
diff --git a/usr/src/cmd/mdb/sparc/kmdb/kvm_isadep.c b/usr/src/cmd/mdb/sparc/kmdb/kvm_isadep.c
index ad9fa6d940..2ee4aad89d 100644
--- a/usr/src/cmd/mdb/sparc/kmdb/kvm_isadep.c
+++ b/usr/src/cmd/mdb/sparc/kmdb/kvm_isadep.c
@@ -22,10 +22,10 @@
 /*
  * Copyright 2006 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
+ *
+ * Copyright 2018 Joyent, Inc.
  */
 
-#pragma ident	"%Z%%M%	%I%	%E% SMI"
-
 /*
  * isa-dependent portions of the kmdb target
  */
@@ -377,13 +377,6 @@ kmt_step_out(mdb_tgt_t *t, uintptr_t *p)
 	return (0);
 }
 
-/*ARGSUSED*/
-int
-kmt_step_branch(mdb_tgt_t *t)
-{
-	return (set_errno(EMDB_TGTHWNOTSUP));
-}
-
 static const char *
 regno2name(int idx)
 {
diff --git a/usr/src/cmd/mdb/sparc/mdb/kvm_v7dep.c b/usr/src/cmd/mdb/sparc/mdb/kvm_v7dep.c
index dcf9dd7ae3..fe0e7dc8a6 100644
--- a/usr/src/cmd/mdb/sparc/mdb/kvm_v7dep.c
+++ b/usr/src/cmd/mdb/sparc/mdb/kvm_v7dep.c
@@ -21,10 +21,10 @@
 /*
  * Copyright 2008 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
+ *
+ * Copyright 2018 Joyent, Inc.
  */
 
-#pragma ident	"%Z%%M%	%I%	%E% SMI"
-
 /*
  * Libkvm Kernel Target SPARC v7 component
  *
@@ -404,7 +404,6 @@ const mdb_tgt_ops_t kt_sparcv7_ops = {
 	(int (*)()) mdb_tgt_notsup,		/* t_run */
 	(int (*)()) mdb_tgt_notsup,		/* t_step */
 	(int (*)()) mdb_tgt_notsup,		/* t_step_out */
-	(int (*)()) mdb_tgt_notsup,		/* t_step_branch */
 	(int (*)()) mdb_tgt_notsup,		/* t_next */
 	(int (*)()) mdb_tgt_notsup,		/* t_cont */
 	(int (*)()) mdb_tgt_notsup,		/* t_signal */
diff --git a/usr/src/cmd/mdb/sparc/mdb/kvm_v9dep.c b/usr/src/cmd/mdb/sparc/mdb/kvm_v9dep.c
index 68a3b8fb1e..c551fa6714 100644
--- a/usr/src/cmd/mdb/sparc/mdb/kvm_v9dep.c
+++ b/usr/src/cmd/mdb/sparc/mdb/kvm_v9dep.c
@@ -21,10 +21,10 @@
 /*
  * Copyright 2008 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
+ *
+ * Copyright 2018 Joyent, Inc.
  */
 
-#pragma ident	"%Z%%M%	%I%	%E% SMI"
-
 /*
  * Libkvm Kernel Target SPARC v9 component
  *
@@ -217,7 +217,6 @@ const mdb_tgt_ops_t kt_sparcv9_ops = {
 	(int (*)()) mdb_tgt_notsup,		/* t_run */
 	(int (*)()) mdb_tgt_notsup,		/* t_step */
 	(int (*)()) mdb_tgt_notsup,		/* t_step_out */
-	(int (*)()) mdb_tgt_notsup,		/* t_step_branch */
 	(int (*)()) mdb_tgt_notsup,		/* t_next */
 	(int (*)()) mdb_tgt_notsup,		/* t_cont */
 	(int (*)()) mdb_tgt_notsup,		/* t_signal */
diff --git a/usr/src/uts/intel/amd64/sys/kdi_regs.h b/usr/src/uts/intel/amd64/sys/kdi_regs.h
index d3dc3dced1..945e0f8c95 100644
--- a/usr/src/uts/intel/amd64/sys/kdi_regs.h
+++ b/usr/src/uts/intel/amd64/sys/kdi_regs.h
@@ -22,13 +22,13 @@
 /*
  * Copyright 2007 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
+ *
+ * Copyright 2018 Joyent, Inc.
  */
 
 #ifndef _AMD64_SYS_KDI_REGS_H
 #define	_AMD64_SYS_KDI_REGS_H
 
-#pragma ident	"%Z%%M%	%I%	%E% SMI"
-
 #ifdef __cplusplus
 extern "C" {
 #endif
@@ -75,21 +75,6 @@ extern "C" {
 #define	KDIREG_SP	KDIREG_RSP
 #define	KDIREG_FP	KDIREG_RBP
 
-#ifdef _ASM
-
-/* Patch point for MSR clearing. */
-#define	KDI_MSR_PATCH \
-	nop; nop; nop; nop; \
-	nop; nop; nop; nop; \
-	nop; nop; nop; nop; \
-	nop; nop; nop; nop; \
-	nop
-
-#endif	/* _ASM */
-
-#define	KDI_MSR_PATCHOFF	8	/* bytes of code before patch point */
-#define	KDI_MSR_PATCHSZ		17	/* bytes in KDI_MSR_PATCH, above */
-
 #ifdef __cplusplus
 }
 #endif
diff --git a/usr/src/uts/intel/ia32/sys/kdi_regs.h b/usr/src/uts/intel/ia32/sys/kdi_regs.h
index 3012272815..e87948189a 100644
--- a/usr/src/uts/intel/ia32/sys/kdi_regs.h
+++ b/usr/src/uts/intel/ia32/sys/kdi_regs.h
@@ -22,13 +22,13 @@
 /*
  * Copyright 2007 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
+ *
+ * Copyright 2018 Joyent, Inc.
  */
 
 #ifndef _IA32_SYS_KDI_REGS_H
 #define	_IA32_SYS_KDI_REGS_H
 
-#pragma ident	"%Z%%M%	%I%	%E% SMI"
-
 #ifdef __cplusplus
 extern "C" {
 #endif
@@ -66,20 +66,6 @@ extern "C" {
 #define	KDIREG_SP	KDIREG_ESP
 #define	KDIREG_FP	KDIREG_EBP
 
-#ifdef _ASM
-
-/* Patch point for MSR clearing. */
-#define	KDI_MSR_PATCH \
-	nop; nop; nop; nop; \
-	nop; nop; nop; nop; \
-	nop; nop; nop; nop; \
-	nop
-
-#endif /* _ASM */
-
-#define	KDI_MSR_PATCHOFF	8	/* bytes of code before patch point */
-#define	KDI_MSR_PATCHSZ		13	/* bytes in KDI_MSR_PATCH, above */
-
 #ifdef __cplusplus
 }
 #endif
diff --git a/usr/src/uts/intel/kdi/amd64/kdi_asm.s b/usr/src/uts/intel/kdi/amd64/kdi_asm.s
index d3729c7ac4..ea6f404af4 100644
--- a/usr/src/uts/intel/kdi/amd64/kdi_asm.s
+++ b/usr/src/uts/intel/kdi/amd64/kdi_asm.s
@@ -22,10 +22,10 @@
 /*
  * Copyright 2007 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
+ *
+ * Copyright 2018 Joyent, Inc.
  */
 
-#pragma ident	"%Z%%M%	%I%	%E% SMI"
-
 /*
  * Debugger entry for both master and slave CPUs
  */
@@ -162,15 +162,10 @@
 /*
  * Given the address of the current CPU's cpusave area in %rax, the following
  * macro restores the debugging state to said CPU.  Restored state includes
- * the debug registers from the global %dr variables, and debugging MSRs from
- * the CPU save area.  This code would be in a separate routine, but for the
- * fact that some of the MSRs are jump-sensitive.  As such, we need to minimize
- * the number of jumps taken subsequent to the update of said MSRs.  We can
- * remove one jump (the ret) by using a macro instead of a function for the
- * debugging state restoration code.
+ * the debug registers from the global %dr variables.
  *
- * Takes the cpusave area in %rdi as a parameter, clobbers %rax-%rdx
- */	
+ * Takes the cpusave area in %rdi as a parameter.
+ */
 #define	KDI_RESTORE_DEBUGGING_STATE \
 	pushq	%rdi;						\
 	leaq	kdi_drreg(%rip), %r15;				\
@@ -194,50 +189,7 @@
 	movl	$3, %edi;					\
 	movq	DRADDR_OFF(3)(%r15), %rsi;			\
 	call	kdi_dreg_set;					\
-	popq	%rdi;						\
-								\
-	/*							\
-	 * Write any requested MSRs.				\
-	 */							\
-	movq	KRS_MSR(%rdi), %rbx;				\
-	cmpq	$0, %rbx;					\
-	je	3f;						\
-1:								\
-	movl	MSR_NUM(%rbx), %ecx;				\
-	cmpl	$0, %ecx;					\
-	je	3f;						\
-								\
-	movl	MSR_TYPE(%rbx), %edx;				\
-	cmpl	$KDI_MSR_WRITE, %edx;				\
-	jne	2f;						\
-								\
-	movq	MSR_VALP(%rbx), %rdx;				\
-	movl	0(%rdx), %eax;					\
-	movl	4(%rdx), %edx;					\
-	wrmsr;							\
-2:								\
-	addq	$MSR_SIZE, %rbx;				\
-	jmp	1b;						\
-3:								\
-	/*							\
-	 * We must not branch after re-enabling LBR.  If	\
-	 * kdi_wsr_wrexit_msr is set, it contains the number	\
-	 * of the MSR that controls LBR.  kdi_wsr_wrexit_valp	\
-	 * contains the value that is to be written to enable	\
-	 * LBR.							\
-	 */							\
-	leaq	kdi_msr_wrexit_msr(%rip), %rcx;			\
-	movl	(%rcx), %ecx;					\
-	cmpl	$0, %ecx;					\
-	je	1f;						\
-								\
-	leaq	kdi_msr_wrexit_valp(%rip), %rdx;		\
-	movq	(%rdx), %rdx;					\
-	movl	0(%rdx), %eax;					\
-	movl	4(%rdx), %edx;					\
-								\
-	wrmsr;							\
-1:
+	popq	%rdi;
 
 /*
  * Each cpusave buffer has an area set aside for a ring buffer of breadcrumbs.
@@ -400,21 +352,13 @@ kdi_cmnint(void)
  */
 
 #if defined(__lint)
-char kdi_slave_entry_patch;
-
 void
 kdi_slave_entry(void)
 {
 }
 #else /* __lint */
-	.globl	kdi_slave_entry_patch;
-
 	ENTRY_NP(kdi_slave_entry)
 
-	/* kdi_msr_add_clrentry knows where this is */
-kdi_slave_entry_patch:
-	KDI_MSR_PATCH;
-
 	/*
 	 * Cross calls are implemented as function calls, so our stack currently
 	 * looks like one you'd get from a zero-argument function call.  That
@@ -537,37 +481,6 @@ kdi_slave_entry_patch:
 
 	movq	%r15, %rax	/* restore cpu save area to rax */
 
-	/*
-	 * Save any requested MSRs.
-	 */
-	movq	KRS_MSR(%rax), %rcx
-	cmpq	$0, %rcx
-	je	no_msr
-
-	pushq	%rax		/* rdmsr clobbers %eax */
-	movq	%rcx, %rbx
-
-1:
-	movl	MSR_NUM(%rbx), %ecx
-	cmpl	$0, %ecx
-	je	msr_done
-
-	movl	MSR_TYPE(%rbx), %edx
-	cmpl	$KDI_MSR_READ, %edx
-	jne	msr_next
-
-	rdmsr			/* addr in %ecx, value into %edx:%eax */
-	movl	%eax, MSR_VAL(%rbx)
-	movl	%edx, _CONST(MSR_VAL + 4)(%rbx)
-
-msr_next:
-	addq	$MSR_SIZE, %rbx
-	jmp	1b
-
-msr_done:
-	popq	%rax
-
-no_msr:
 	clrq	%rbp		/* stack traces should end here */
 
 	pushq	%rax
diff --git a/usr/src/uts/intel/kdi/ia32/kdi_asm.s b/usr/src/uts/intel/kdi/ia32/kdi_asm.s
index fbf207a99e..4f7e2ec7ad 100644
--- a/usr/src/uts/intel/kdi/ia32/kdi_asm.s
+++ b/usr/src/uts/intel/kdi/ia32/kdi_asm.s
@@ -22,10 +22,10 @@
 /*
  * Copyright 2007 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
+ *
+ * Copyright 2018 Joyent, Inc.
  */
 
-#pragma ident	"%Z%%M%	%I%	%E% SMI"
-
 /*
  * Debugger entry for both master and slave CPUs
  */
@@ -77,15 +77,8 @@
 /*
  * Given the address of the current CPU's cpusave area in %edi, the following
  * macro restores the debugging state to said CPU.  Restored state includes
- * the debug registers from the global %dr variables, and debugging MSRs from
- * the CPU save area.  This code would be in a separate routine, but for the
- * fact that some of the MSRs are jump-sensitive.  As such, we need to minimize
- * the number of jumps taken subsequent to the update of said MSRs.  We can
- * remove one jump (the ret) by using a macro instead of a function for the
- * debugging state restoration code.
- *
- * Takes the cpusave area in %edi as a parameter, clobbers %eax-%edx
- */	
+ * the debug registers from the global %dr variables.
+ */
 #define	KDI_RESTORE_DEBUGGING_STATE \
 	leal	kdi_drreg, %ebx;				\
 								\
@@ -117,48 +110,7 @@
 	pushl	DRADDR_OFF(3)(%ebx);				\
 	pushl	$3;						\
 	call	kdi_dreg_set;					\
-	addl	$8, %esp;					\
-								\
-	/*							\
-	 * Write any requested MSRs.				\
-	 */							\
-	movl	KRS_MSR(%edi), %ebx;				\
-	cmpl	$0, %ebx;					\
-	je	3f;						\
-1:								\
-	movl	MSR_NUM(%ebx), %ecx;				\
-	cmpl	$0, %ecx;					\
-	je	3f;						\
-								\
-	movl	MSR_TYPE(%ebx), %edx;				\
-	cmpl	$KDI_MSR_WRITE, %edx;				\
-	jne	2f;						\
-								\
-	movl	MSR_VALP(%ebx), %edx;				\
-	movl	0(%edx), %eax;					\
-	movl	4(%edx), %edx;					\
-	wrmsr;							\
-2:								\
-	addl	$MSR_SIZE, %ebx;				\
-	jmp	1b;						\
-3:								\
-	/*							\
-	 * We must not branch after re-enabling LBR.  If	\
-	 * kdi_wsr_wrexit_msr is set, it contains the number	\
-	 * of the MSR that controls LBR.  kdi_wsr_wrexit_valp	\
-	 * contains the value that is to be written to enable	\
-	 * LBR.							\
-	 */							\
-	movl	kdi_msr_wrexit_msr, %ecx;			\
-	cmpl	$0, %ecx;					\
-	je	1f;						\
-								\
-	movl	kdi_msr_wrexit_valp, %edx;			\
-	movl	0(%edx), %eax;					\
-	movl	4(%edx), %edx;					\
-								\
-	wrmsr;							\
-1:
+	addl	$8, %esp;
 
 #define	KDI_RESTORE_REGS() \
 	/* Discard savfp and savpc */ \
@@ -374,21 +326,13 @@ kdi_cmnint(void)
  */
 
 #if defined(__lint)
-char kdi_slave_entry_patch;
-
 void
 kdi_slave_entry(void)
 {
 }
 #else /* __lint */
-	.globl	kdi_slave_entry_patch;
-
 	ENTRY_NP(kdi_slave_entry)
 
-	/* kdi_msr_add_clrentry knows where this is */
-kdi_slave_entry_patch:
-	KDI_MSR_PATCH;
-
 	/*
 	 * Cross calls are implemented as function calls, so our stack
 	 * currently looks like one you'd get from a zero-argument function
@@ -542,42 +486,12 @@ kdi_slave_entry_patch:
 	movl	%edi, %eax
 	popl	%edi
 
-	/*
-	 * Save any requested MSRs.
-	 */
-	movl	KRS_MSR(%eax), %ecx
-	cmpl	$0, %ecx
-	je	no_msr
-
-	pushl	%eax		/* rdmsr clobbers %eax */
-	movl	%ecx, %ebx
-1:
-	movl	MSR_NUM(%ebx), %ecx
-	cmpl	$0, %ecx
-	je	msr_done
-
-	movl	MSR_TYPE(%ebx), %edx
-	cmpl	$KDI_MSR_READ, %edx
-	jne	msr_next
-
-	rdmsr			/* addr in %ecx, value into %edx:%eax */
-	movl	%eax, MSR_VAL(%ebx)
-	movl	%edx, _CONST(MSR_VAL + 4)(%ebx)
-
-msr_next:
-	addl	$MSR_SIZE, %ebx
-	jmp	1b
-
-msr_done:
-	popl	%eax
-
-no_msr:
 	clr	%ebp		/* stack traces should end here */
 
 	pushl	%eax
 	call	kdi_debugger_entry
 	popl	%eax
- 
+
 	jmp	kdi_resume
 
 	SET_SIZE(kdi_save_common_state)
diff --git a/usr/src/uts/intel/kdi/kdi_idt.c b/usr/src/uts/intel/kdi/kdi_idt.c
index 73d9628e62..64e2b225d5 100644
--- a/usr/src/uts/intel/kdi/kdi_idt.c
+++ b/usr/src/uts/intel/kdi/kdi_idt.c
@@ -21,6 +21,8 @@
 /*
  * Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
+ *
+ * Copyright 2018 Joyent, Inc.
  */
 
 /*
@@ -100,9 +102,6 @@ uint32_t	kdi_fs;
 uint32_t	kdi_gs;
 #endif
 
-uint_t		kdi_msr_wrexit_msr;
-uint64_t	*kdi_msr_wrexit_valp;
-
 uintptr_t	kdi_kernel_handler;
 
 int		kdi_trap_switch;
@@ -121,7 +120,6 @@ extern idt_hdlr_f kdi_traperr13, kdi_traperr14, kdi_trap16, kdi_trap17;
 extern idt_hdlr_f kdi_trap18, kdi_trap19, kdi_trap20, kdi_ivct32;
 extern idt_hdlr_f kdi_invaltrap;
 extern size_t kdi_ivct_size;
-extern char kdi_slave_entry_patch;
 
 typedef struct kdi_gate_spec {
 	uint_t kgs_vec;
@@ -194,46 +192,6 @@ kdi_idt_init(selector_t sel)
 	}
 }
 
-/*
- * Patch caller-provided code into the debugger's IDT handlers.  This code is
- * used to save MSRs that must be saved before the first branch.  All handlers
- * are essentially the same, and end with a branch to kdi_cmnint.  To save the
- * MSR, we need to patch in before the branch.  The handlers have the following
- * structure: KDI_MSR_PATCHOFF bytes of code, KDI_MSR_PATCHSZ bytes of
- * patchable space, followed by more code.
- */
-void
-kdi_idt_patch(caddr_t code, size_t sz)
-{
-	int i;
-
-	ASSERT(sz <= KDI_MSR_PATCHSZ);
-
-	for (i = 0; i < sizeof (kdi_idt) / sizeof (struct gate_desc); i++) {
-		gate_desc_t *gd;
-		uchar_t *patch;
-
-		if (i == T_DBLFLT)
-			continue;	/* uses kernel's handler */
-
-		gd = &kdi_idt[i];
-		patch = ((uchar_t *)(uintptr_t)GATESEG_GETOFFSET(gd)) +
-		    KDI_MSR_PATCHOFF;
-
-		/*
-		 * We can't ASSERT that there's a nop here, because this may be
-		 * a debugger restart.  In that case, we're copying the new
-		 * patch point over the old one.
-		 */
-		/* FIXME: dtrace fbt ... */
-		bcopy(code, patch, sz);
-
-		/* Fill the rest with nops to be sure */
-		while (sz < KDI_MSR_PATCHSZ)
-			patch[sz++] = 0x90; /* nop */
-	}
-}
-
 static void
 kdi_idt_gates_install(selector_t sel, int saveold)
 {
@@ -279,79 +237,6 @@ kdi_idt_sync(void)
 	kdi_idt_gates_install(KCS_SEL, KDI_IDT_SAVE);
 }
 
-/*
- * On some processors, we'll need to clear a certain MSR before proceeding into
- * the debugger.  Complicating matters, this MSR must be cleared before we take
- * any branches.  We have patch points in every trap handler, which will cover
- * all entry paths for master CPUs.  We also have a patch point in the slave
- * entry code.
- */
-static void
-kdi_msr_add_clrentry(uint_t msr)
-{
-#ifdef __amd64
-	uchar_t code[] = {
-		0x51, 0x50, 0x52,		/* pushq %rcx, %rax, %rdx */
-		0xb9, 0x00, 0x00, 0x00, 0x00,	/* movl $MSRNUM, %ecx */
-		0x31, 0xc0,			/* clr %eax */
-		0x31, 0xd2,			/* clr %edx */
-		0x0f, 0x30,			/* wrmsr */
-		0x5a, 0x58, 0x59		/* popq %rdx, %rax, %rcx */
-	};
-	uchar_t *patch = &code[4];
-#else
-	uchar_t code[] = {
-		0x60,				/* pushal */
-		0xb9, 0x00, 0x00, 0x00, 0x00,	/* movl $MSRNUM, %ecx */
-		0x31, 0xc0,			/* clr %eax */
-		0x31, 0xd2,			/* clr %edx */
-		0x0f, 0x30,			/* wrmsr */
-		0x61				/* popal */
-	};
-	uchar_t *patch = &code[2];
-#endif
-
-	bcopy(&msr, patch, sizeof (uint32_t));
-
-	kdi_idt_patch((caddr_t)code, sizeof (code));
-
-	bcopy(code, &kdi_slave_entry_patch, sizeof (code));
-}
-
-static void
-kdi_msr_add_wrexit(uint_t msr, uint64_t *valp)
-{
-	kdi_msr_wrexit_msr = msr;
-	kdi_msr_wrexit_valp = valp;
-}
-
-void
-kdi_set_debug_msrs(kdi_msr_t *msrs)
-{
-	int nmsrs, i;
-
-	ASSERT(kdi_cpusave[0].krs_msr == NULL);
-
-	/* Look in CPU0's MSRs for any special MSRs. */
-	for (nmsrs = 0; msrs[nmsrs].msr_num != 0; nmsrs++) {
-		switch (msrs[nmsrs].msr_type) {
-		case KDI_MSR_CLEARENTRY:
-			kdi_msr_add_clrentry(msrs[nmsrs].msr_num);
-			break;
-
-		case KDI_MSR_WRITEDELAY:
-			kdi_msr_add_wrexit(msrs[nmsrs].msr_num,
-			    msrs[nmsrs].kdi_msr_valp);
-			break;
-		}
-	}
-
-	nmsrs++;
-
-	for (i = 0; i < kdi_ncpusave; i++)
-		kdi_cpusave[i].krs_msr = &msrs[nmsrs * i];
-}
-
 void
 kdi_update_drreg(kdi_drreg_t *drreg)
 {
@@ -395,7 +280,7 @@ void
 kdi_cpu_init(void)
 {
 	kdi_idt_gates_install(KCS_SEL, KDI_IDT_NOSAVE);
-	/* Load the debug registers and MSRs */
+	/* Load the debug registers. */
 	kdi_cpu_debug_init(&kdi_cpusave[CPU->cpu_id]);
 }
 
@@ -449,9 +334,6 @@ kdi_activate(kdi_main_t main, kdi_cpusave_t *cpusave, uint_t ncpusave)
 	kdi_drreg.dr_ctl = KDIREG_DRCTL_RESERVED;
 	kdi_drreg.dr_stat = KDIREG_DRSTAT_RESERVED;
 
-	kdi_msr_wrexit_msr = 0;
-	kdi_msr_wrexit_valp = NULL;
-
 	if (boothowto & RB_KMDB) {
 		kdi_idt_gates_install(KMDBCODE_SEL, KDI_IDT_NOSAVE);
 	} else {
diff --git a/usr/src/uts/intel/kdi/kdi_idthdl.s b/usr/src/uts/intel/kdi/kdi_idthdl.s
index 03a2f90ed7..359df2a8f8 100644
--- a/usr/src/uts/intel/kdi/kdi_idthdl.s
+++ b/usr/src/uts/intel/kdi/kdi_idthdl.s
@@ -21,10 +21,10 @@
 /*
  * Copyright 2007 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
+ *
+ * Copyright 2018 Joyent, Inc.
  */
 
-#pragma ident	"%Z%%M%	%I%	%E% SMI"
-
 /*
  * Companion to kdi_idt.c - the implementation of the trap and interrupt
  * handlers.  For the most part, these handlers do the same thing - they
@@ -39,33 +39,13 @@
 /* Nothing in this file is of interest to lint. */
 #if !defined(__lint)
 
-/* 
+/*
  * The default ASM_ENTRY_ALIGN (16) wastes far too much space.  Pay no
  * attention to the fleet of nop's we're adding to each handler.
  */
 #undef	ASM_ENTRY_ALIGN
 #define	ASM_ENTRY_ALIGN	8
 
-/*
- * We need the .align in ENTRY_NP (defined to be ASM_ENTRY_ALIGN) to match our
- * manual .align (KDI_MSR_PATCHOFF) in order to ensure that the space reserved
- * at the beginning of the handler for code is exactly KDI_MSR_PATCHOFF bytes
- * long.  Note that the #error below isn't supported by the preprocessor invoked
- * by as(1), and won't stop the build, but it'll emit a noticeable error message
- * which won't escape the filters.
- */
-#if ASM_ENTRY_ALIGN != KDI_MSR_PATCHOFF
-#error "ASM_ENTRY_ALIGN != KDI_MSR_PATCHOFF"
-this won't assemble
-#endif
-
-/*
- * kdi_idt_patch will, on certain processors, replace the patch points below
- * with MSR-clearing code.  kdi_id_patch has intimate knowledge of the size of
- * the nop hole, as well as the structure of the handlers.  Do not change
- * anything here without also changing kdi_idt_patch.
- */
-
 /*
  * Generic trap and interrupt handlers.
  */
@@ -102,40 +82,30 @@ this won't assemble
 #define	MKIVCT(n) \
 	ENTRY_NP(kdi_ivct/**/n/**/);	\
 	TRAP_ERR(n);			\
-	.align	KDI_MSR_PATCHOFF;	\
-	KDI_MSR_PATCH;			\
 	jmp	kdi_cmnint;		\
 	SET_SIZE(kdi_ivct/**/n/**/)
 
 #define	MKTRAPHDLR(n) \
 	ENTRY_NP(kdi_trap/**/n);	\
 	TRAP_ERR(n);			\
-	.align	KDI_MSR_PATCHOFF;	\
-	KDI_MSR_PATCH;			\
 	jmp	kdi_cmnint;		\
 	SET_SIZE(kdi_trap/**/n/**/)
 
 #define	MKTRAPERRHDLR(n) \
 	ENTRY_NP(kdi_traperr/**/n);	\
 	TRAP_NOERR(n);			\
-	.align	KDI_MSR_PATCHOFF;	\
-	KDI_MSR_PATCH;			\
 	jmp	kdi_cmnint;		\
 	SET_SIZE(kdi_traperr/**/n)
 
 #define	MKNMIHDLR \
 	ENTRY_NP(kdi_int2);		\
 	TRAP_NOERR(2);			\
-	.align	KDI_MSR_PATCHOFF;	\
-	KDI_MSR_PATCH;			\
 	jmp	kdi_nmiint;		\
 	SET_SIZE(kdi_int2)
 
 #define	MKINVALHDLR \
 	ENTRY_NP(kdi_invaltrap);	\
 	TRAP_NOERR(255);		\
-	.align	KDI_MSR_PATCHOFF;	\
-	KDI_MSR_PATCH;			\
 	jmp	kdi_cmnint;		\
 	SET_SIZE(kdi_invaltrap)
 
diff --git a/usr/src/uts/intel/kdi/kdi_offsets.in b/usr/src/uts/intel/kdi/kdi_offsets.in
index 80c0c24334..212fdc9f4c 100644
--- a/usr/src/uts/intel/kdi/kdi_offsets.in
+++ b/usr/src/uts/intel/kdi/kdi_offsets.in
@@ -2,6 +2,8 @@
 \ Copyright 2007 Sun Microsystems, Inc.  All rights reserved.
 \ Use is subject to license terms.
 \
+\ Copyright 2018 Joyent, Inc.
+\
 \ CDDL HEADER START
 \
 \ The contents of this file are subject to the terms of the
@@ -21,8 +23,6 @@
 \
 \ CDDL HEADER END
 \
-\ ident	"%Z%%M%	%I%	%E% SMI"
-\
 \ CPU-save structure offsets for use in assembly code.
 \
 \ Keep in sync with kdi_state.h
@@ -47,12 +47,6 @@ kdi_drreg_t
 		dr_stat
 		dr_addr
 
-kdi_msr_t	MSR_SIZE
-		msr_num
-		msr_type
-		_u._msr_valp			MSR_VALP
-		_u._msr_val			MSR_VAL
-
 kdi_cpusave_t	KRS_SIZE
 		krs_gregs
 		krs_dr
@@ -61,7 +55,6 @@ kdi_cpusave_t	KRS_SIZE
 		krs_gdt
 		krs_idt
 		krs_cr0
-		krs_msr
 		krs_cpu_state
 		krs_curcrumbidx
 		krs_curcrumb
diff --git a/usr/src/uts/intel/os/arch_kdi.c b/usr/src/uts/intel/os/arch_kdi.c
index 4aa852ae2c..9677013ea5 100644
--- a/usr/src/uts/intel/os/arch_kdi.c
+++ b/usr/src/uts/intel/os/arch_kdi.c
@@ -21,6 +21,8 @@
 /*
  * Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
+ *
+ * Copyright 2018 Joyent, Inc.
  */
 
 /*
@@ -154,7 +156,6 @@ mach_kdi_init(kdi_t *kdi)
 	kdi->mkdi_deactivate = kdi_deactivate;
 	kdi->mkdi_idt_switch = kdi_idt_switch;
 	kdi->mkdi_update_drreg = kdi_update_drreg;
-	kdi->mkdi_set_debug_msrs = kdi_set_debug_msrs;
 	kdi->mkdi_get_userlimit = kdi_get_userlimit;
 	kdi->mkdi_get_cpuinfo = kdi_get_cpuinfo;
 	kdi->mkdi_stop_slaves = kdi_stop_slaves;
diff --git a/usr/src/uts/intel/sys/controlregs.h b/usr/src/uts/intel/sys/controlregs.h
index 41a4a72191..6ae1afb3eb 100644
--- a/usr/src/uts/intel/sys/controlregs.h
+++ b/usr/src/uts/intel/sys/controlregs.h
@@ -21,6 +21,8 @@
 /*
  * Copyright (c) 2004, 2010, Oracle and/or its affiliates. All rights reserved.
  * Copyright 2015, Joyent, Inc.
+ *
+ * Copyright 2018 Joyent, Inc.
  */
 
 #ifndef	_SYS_CONTROLREGS_H
@@ -108,12 +110,13 @@ extern "C" {
 					/* 0x1000 reserved */
 #define	CR4_VMXE	0x2000
 #define	CR4_SMXE	0x4000
+#define	CR4_PCIDE	0x20000		/* PCID enable */
 #define	CR4_OSXSAVE	0x40000		/* OS xsave/xrestore support	*/
 #define	CR4_SMEP	0x100000	/* NX for user pages in kernel */
 #define	CR4_SMAP	0x200000	/* kernel can't access user pages */
 
 #define	FMT_CR4						\
-	"\20\26smap\25smep\23osxsav"			\
+	"\20\26smap\25smep\23osxsav\22pcide"		\
 	"\17smxe\16vmxe\13xmme\12fxsr\11pce\10pge"	\
 	"\7mce\6pae\5pse\4de\3tsd\2pvi\1vme"
 
diff --git a/usr/src/uts/intel/sys/kdi_machimpl.h b/usr/src/uts/intel/sys/kdi_machimpl.h
index 0d9de7d750..f4d9270254 100644
--- a/usr/src/uts/intel/sys/kdi_machimpl.h
+++ b/usr/src/uts/intel/sys/kdi_machimpl.h
@@ -21,13 +21,13 @@
 /*
  * Copyright 2007 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
+ *
+ * Copyright 2018 Joyent, Inc.
  */
 
 #ifndef _SYS_KDI_MACHIMPL_H
 #define	_SYS_KDI_MACHIMPL_H
 
-#pragma ident	"%Z%%M%	%I%	%E% SMI"
-
 /*
  * The Kernel/Debugger interface.  The operations provided by the kdi_t,
  * defined below, comprise the Debugger -> Kernel portion of the interface,
@@ -59,7 +59,6 @@ typedef struct kdi_mach {
 	void (*mkdi_idt_switch)(kdi_cpusave_t *);
 
 	void (*mkdi_update_drreg)(kdi_drreg_t *);
-	void (*mkdi_set_debug_msrs)(kdi_msr_t *);
 
 	uintptr_t (*mkdi_get_userlimit)(void);
 
@@ -80,7 +79,6 @@ typedef struct kdi_mach {
 #define	mkdi_deactivate			kdi_mach.mkdi_deactivate
 #define	mkdi_idt_switch			kdi_mach.mkdi_idt_switch
 #define	mkdi_update_drreg		kdi_mach.mkdi_update_drreg
-#define	mkdi_set_debug_msrs		kdi_mach.mkdi_set_debug_msrs
 #define	mkdi_get_userlimit		kdi_mach.mkdi_get_userlimit
 #define	mkdi_get_cpuinfo		kdi_mach.mkdi_get_cpuinfo
 #define	mkdi_stop_slaves		kdi_mach.mkdi_stop_slaves
@@ -98,7 +96,6 @@ extern void kdi_setdr3(ulong_t), kdi_setdr6(ulong_t), kdi_setdr7(ulong_t);
 extern ulong_t kdi_dreg_get(int);
 extern void kdi_dreg_set(int, ulong_t);
 extern void kdi_update_drreg(kdi_drreg_t *);
-extern void kdi_set_debug_msrs(kdi_msr_t *);
 extern void kdi_cpu_debug_init(kdi_cpusave_t *);
 
 extern void kdi_cpu_init(void);
diff --git a/usr/src/uts/intel/sys/kdi_regs.h b/usr/src/uts/intel/sys/kdi_regs.h
index eb813e8888..f5d264c244 100644
--- a/usr/src/uts/intel/sys/kdi_regs.h
+++ b/usr/src/uts/intel/sys/kdi_regs.h
@@ -21,13 +21,13 @@
 /*
  * Copyright 2007 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
+ *
+ * Copyright 2018 Joyent, Inc.
  */
 
 #ifndef _SYS_KDI_REGS_H
 #define	_SYS_KDI_REGS_H
 
-#pragma ident	"%Z%%M%	%I%	%E% SMI"
-
 #ifndef _ASM
 #include <sys/types.h>
 #include <sys/segments.h>
@@ -55,11 +55,6 @@ extern "C" {
 #define	KDIREG_DRSTAT_RESERVED		0xffff0ff0
 #define	KDIREG_DRCTL_RESERVED		0x00000700
 
-#define	KDI_MSR_READ		0x1	/* read during entry (unlimited) */
-#define	KDI_MSR_WRITE		0x2	/* write during exit (unlimited) */
-#define	KDI_MSR_WRITEDELAY	0x4	/* write after last branch (<= 1) */
-#define	KDI_MSR_CLEARENTRY	0x3	/* clear before 1st branch (<= 1) */
-
 #ifndef _ASM
 
 /*
@@ -86,18 +81,6 @@ typedef struct kdi_drreg {
 	greg_t			dr_addr[KDI_MAXWPIDX + 1];
 } kdi_drreg_t;
 
-typedef struct kdi_msr {
-	uint_t		msr_num;
-	uint_t		msr_type;
-	union {
-		uint64_t *_msr_valp;
-		uint64_t _msr_val;
-	} _u;
-} kdi_msr_t;
-
-#define	kdi_msr_val	_u._msr_val
-#define	kdi_msr_valp	_u._msr_valp
-
 /*
  * Data structure used to hold all of the state for a given CPU.
  */
@@ -111,8 +94,6 @@ typedef struct kdi_cpusave {
 
 	greg_t			krs_cr0;	/* saved %cr0 */
 
-	kdi_msr_t		*krs_msr;	/* ptr to MSR save area */
-
 	uint_t			krs_cpu_state;	/* KDI_CPU_STATE_* mstr/slv */
 	uint_t			krs_cpu_flushed; /* Have caches been flushed? */
 	uint_t			krs_cpu_id;	/* this CPU's ID */
-- 
2.21.0

