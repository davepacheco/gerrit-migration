commit 27bb23b64399cd4b4acd46a8d41e21489365cb99 (refs/changes/32/3032/1)
Author: Trent Mick <trentm@gmail.com>
Date:   2017-12-04T13:58:04-08:00 (1 year, 10 months ago)
    
    HEAD-2380 'sdc-usbkey mount --nofoldcase' option

diff --git a/tools/cmd/sdc-usbkey.js b/tools/cmd/sdc-usbkey.js
index 1f8e84e0..4afdd73b 100644
--- a/tools/cmd/sdc-usbkey.js
+++ b/tools/cmd/sdc-usbkey.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright 2016 Joyent, Inc.
+ * Copyright (c) 2017, Joyent, Inc.
  */
 
 
@@ -124,8 +124,14 @@ do_mount(subcmd, opts, args, callback)
         return;
     }
 
+    var mount_options = {};
+    if (opts.nofoldcase) {
+        mount_options.foldcase = false;
+    }
+
     lib_usbkey.ensure_usbkey_mounted({
-        timeout: TIMEOUT_MOUNT
+        timeout: TIMEOUT_MOUNT,
+        mount_options: mount_options
     }, function (err, mtpt) {
         if (err) {
             callback(err);
@@ -141,7 +147,12 @@ Usbkey.prototype.do_mount.options = [
         names: [ 'help', 'h', '?' ],
         type: 'bool',
         help: 'Print this help message.'
-    }
+    },
+    {
+        name: 'nofoldcase',
+        type: 'bool',
+        help: 'Mount the USB key without folding case.'
+    },
 ];
 Usbkey.prototype.do_mount.help = [
     'Mount the USB key if it is not mounted.',
diff --git a/tools/lib/oscmds.js b/tools/lib/oscmds.js
index 471b6bc7..1374c598 100644
--- a/tools/lib/oscmds.js
+++ b/tools/lib/oscmds.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright 2016 Joyent, Inc.
+ * Copyright (c) 2017, Joyent, Inc.
  */
 
 
@@ -120,6 +120,8 @@ mount(options, callback)
         for (var k in options.mt_options) {
             if (options.mt_options[k] === true) {
                 o_args.push(k);
+            } else if (options.mt_options[k] === false) {
+                o_args.push('no' + k);
             } else {
                 mod_assert.string(options.mt_options[k], 'mt_options[' + k +
                   ']');
diff --git a/tools/lib/usbkey.js b/tools/lib/usbkey.js
index 7d598ef6..cfb5c195 100644
--- a/tools/lib/usbkey.js
+++ b/tools/lib/usbkey.js
@@ -5,10 +5,9 @@
  */
 
 /*
- * Copyright 2016 Joyent, Inc.
+ * Copyright (c) 2017, Joyent, Inc.
  */
 
-
 var mod_fs = require('fs');
 var mod_path = require('path');
 var mod_child = require('child_process');
@@ -26,14 +25,39 @@ var dprintf = lib_common.dprintf;
 var DEFAULT_MOUNTPOINT = '/mnt/usbkey';
 var SVCPROP = '/bin/svcprop';
 
-var MOUNT_OPTIONS = {
+var DEFAULT_MOUNT_OPTIONS = {
+    /*
+     * To ensure a consistent view of files on the key, we must
+     * mount with "foldcase" enabled.
+     */
     foldcase: true,
-    noatime: true,
+    atime: false,
+    /*
+     * Allow access to files with the "system" or "hidden" bits
+     * set.
+     */
     hidden: true,
+    /*
+     * Constrain filesystem timestamps such that they will fit within a
+     * 32-bit time_t.
+     */
     clamptime: true,
     rw: true
 };
-mod_assert.ok(valid_usbkey_mount_options(MOUNT_OPTIONS));
+
+
+function
+obj_copy(obj, target) {
+    if (!target) {
+        target = {};
+    }
+
+    Object.keys(obj).forEach(function (k) {
+        target[k] = obj[k];
+    });
+
+    return (target);
+}
 
 /*
  * The expected mountpoint for the USB key FAT filesystem is configured as a
@@ -99,31 +123,46 @@ ensure_mountpoint_exists(mtpt, callback)
 }
 
 function
-valid_usbkey_mount_options(options)
+equiv_usbkey_mount_options(a, b)
 {
-    mod_assert.object(options, 'options');
+    mod_assert.object(a, 'a');
+    mod_assert.object(b, 'b');
+
+    var get_mount_option = function (obj, name) {
+        var val = null;
+        if (obj.hasOwnProperty(name)) {
+            mod_assert.bool(obj[name], name);
+            val = obj[name];
+        } else if (obj.hasOwnProperty('no' + name)) {
+            mod_assert.bool(obj['no' + name], 'no' + name);
+            val = !obj['no' + name];
+        }
+        return (val);
+    }
 
-    if (!options.hidden || options.nohidden) {
-        /*
-         * Allow access to files with the "system" or "hidden" bits
-         * set.
-         */
+    /*
+     * To test for equivalency, we require both `a` and `b` to define either
+     * of the <name> or no<name> options. Otherwise, we'd have to know the
+     * default value from mount_pcfs(1M), and that isn't straightforward
+     * (varies by previous Solaris releases, not always documented, depends
+     * on the media type).
+     */
+    var equiv_mount_option = function (name) {
+        var a_val = get_mount_option(a, name);
+        var b_val = get_mount_option(b, name);
+        return (a_val === b_val);
+    };
+
+    if (! equiv_mount_option('hidden')) {
+        dprintf('mount options differ: hidden');
         return (false);
     }
-
-    if (!options.foldcase || options.nofoldcase) {
-        /*
-         * To ensure a consistent view of files on the key, we must _always_
-         * mount with "foldcase" enabled.
-         */
+    if (! equiv_mount_option('foldcase')) {
+        dprintf('mount options differ: foldcase');
         return (false);
     }
-
-    if (!options.clamptime || options.noclamptime) {
-        /*
-         * Constrain filesystem timestamps such that they will fit within a
-         * 32-bit time_t.
-         */
+    if (! equiv_mount_option('clamptime')) {
+        dprintf('mount options differ: clamptime');
         return (false);
     }
 
@@ -384,9 +423,10 @@ ensure_usbkey_unmounted(options, callback)
 }
 
 function
-usbkey_mount_status_common(mountpoint, callback)
+usbkey_mount_status_common(mountpoint, mount_options, callback)
 {
     mod_assert.string(mountpoint, 'mountpoint');
+    mod_assert.object(mount_options, 'mount_options');
     mod_assert.func(callback, 'callback');
 
     var status = {
@@ -424,14 +464,14 @@ usbkey_mount_status_common(mountpoint, callback)
 
         mod_assert.strictEqual(mi.mi_mountpoint, mountpoint);
         if (mi.mi_fstype !== 'pcfs' ||
-          !valid_usbkey_mount_options(mi.mi_options)) {
+          !equiv_usbkey_mount_options(mi.mi_options, mount_options)) {
             /*
              * The mount does not match both the expected filesystem
              * type and the expected mount options.
              */
-            dprintf('"%s" is mounted, but with incorrect options: %j\n',
+            dprintf('"%s" is mounted, but with different options: %j\n',
                 mi.mi_mountpoint, mi.mi_options);
-            status.message = 'mounted, but with incorrect options';
+            status.message = 'mounted, but with different options';
             callback(null, status);
             return;
         }
@@ -481,7 +521,8 @@ get_usbkey_mount_status(callback)
 
         dprintf('configured usbkey mountpoint: "%s"\n', mtpt);
 
-        usbkey_mount_status_common(mtpt, function (err, status) {
+        usbkey_mount_status_common(mtpt, DEFAULT_MOUNT_OPTIONS,
+          function (err, status) {
             if (err) {
                 callback(new VError(err, 'could not get mount status'));
                 return;
@@ -498,9 +539,14 @@ ensure_usbkey_mounted(options, callback)
     mod_assert.object(options, 'options');
     mod_assert.optionalNumber(options.timeout, 'options.timeout');
     mod_assert.optionalBool(options.ignore_missing, 'options.ignore_missing');
+    mod_assert.optionalObject(options.mount_options, 'options.mount_options');
     mod_assert.func(callback, 'callback');
 
-    mod_assert.ok(valid_usbkey_mount_options(MOUNT_OPTIONS));
+    var mount_options = DEFAULT_MOUNT_OPTIONS;
+    if (options.mount_options) {
+        mount_options = obj_copy(DEFAULT_MOUNT_OPTIONS);
+        obj_copy(options.mount_options, mount_options);
+    }
 
     dprintf('ensuring usb key is mounted...\n');
 
@@ -548,7 +594,7 @@ ensure_usbkey_mounted(options, callback)
         }
 
         dprintf('fetching mount status for "%s"\n', mtpt);
-        usbkey_mount_status_common(mtpt, function (err, status) {
+        usbkey_mount_status_common(mtpt, mount_options, function (err, status) {
             if (err) {
                 callback(new VError(err, 'could not inspect mounted ' +
                   'filesystems'));
@@ -571,7 +617,7 @@ ensure_usbkey_mounted(options, callback)
                     mt_fstype: 'pcfs',
                     mt_mountpoint: mtpt,
                     mt_special: specials[0],
-                    mt_options: MOUNT_OPTIONS
+                    mt_options: mount_options
                 }, function (_err) {
                     if (!_err) {
                         /*
