From 5f181390cf85f77e7455d64495e4f71a4a3e3061 Mon Sep 17 00:00:00 2001
From: Richard Bradley <richard.bradley@joyent.com>
Date: Wed, 13 Dec 2017 09:22:39 +0000
Subject: [PATCH] MANATEE-380 would like `manatee-adm promote`

---
 Makefile            |   1 +
 README.md           |  50 +++++++++++++++++
 lib/manatee-peer.js |  55 ++++++++++++++++++
 lib/schemas.js      |  26 +++++++++
 lib/sim.js          |  39 +++++++++++++
 lib/validation.js   |  36 ++++++++++++
 test/tst.promote.js | 134 ++++++++++++++++++++++++++++++++++++++++++++
 7 files changed, 341 insertions(+)
 create mode 100644 test/tst.promote.js

diff --git a/Makefile b/Makefile
index 03314c3..b63f6f8 100644
--- a/Makefile
+++ b/Makefile
@@ -43,6 +43,7 @@ test:
 	node test/tst.onwm_newpeer.js
 	node test/tst.cluster_setup_onwm.js
 	node test/tst.freeze.js
+	node test/tst.promote.js
 	@echo all tests passed
 
 include Makefile.targ
diff --git a/README.md b/README.md
index c47f894..aff133b 100644
--- a/README.md
+++ b/README.md
@@ -309,6 +309,42 @@ The primary will come up as primary, see that the cluster must be transitioning
 to normal mode, and declare a new generation with the newly-deployed peer as the
 sync.  After that, the cluster behaves like a normal cluster.
 
+## Planned promotions
+
+A topology change in Manatee takes place when the cluster determines that a peer
+has gone missing and another peer is available to takeover in that role.  This
+is done by watching for changes to the active peers (i.e. the presence of their
+ephemeral nodes in ZooKeeper), but depending on ZooKeeper configuration this
+could be a lengthy period of time before the cluster notices.  For situations
+where a known topology change is going to happen (e.g. when upgrading the
+cluster), Manatee will watch for a special object in ZooKeeper and proactively
+take actions on the request, instead of waiting for a timeout of the applicable
+ephemeral node.
+
+This object is named `promote` in the cluster's state and is described below in
+the "Data structures" section.  When an operator puts this object, each peer in
+the cluster will get a "clusterStateChange" event and, as part of its evaluation
+of this state, validate the promotion request against the current state of the
+cluster.  If this request is invalid, the request is ignored and a message
+logged.  If this request is valid, the primary (or in the event of a deposition
+of the primary, the sync) will put a new state object into ZooKeeper reflecting
+the intended state of the cluster (e.g. new primary required, async chain
+changes).  Each peer will then receive a subsequent "clusterStateChange"
+notification and take the appropriate actions defined in this state.
+
+The original `promote` object will not be re-written to the cluster's state when
+a promotion request is acted upon.  When the promotion request is invalid, the
+object will remain in the cluster's state until removed by either the operator
+or a subsequent change in cluster state.
+
+The cluster will never act on a promotion request where the current time is
+greater than that in the `promote.time`, or in the case where any other of the
+properties do not match the current state of the cluster (e.g. if
+`promote.generation` doesn't match `clusterState.generation`).  This has the
+effect of protecting the cluster from acting on a promotion request where there
+might have been a natural takeover in the time between when the operator was
+building this object and putting it into ZooKeeper.
+
 # Implementation notes
 
 ## Data structures
@@ -356,6 +392,20 @@ comparing the identities of two peers, only the `id` field is used.**
   versions.
 * `oneNodeWriteMode`: if true, then the cluster is configured for one-node-write
   mode.  See above for details.
+* `promote`: an object containing the intent of an operator-initiated promotion
+  for an individual peer.  See below for details.
+
+#### clusterState.promote
+
+`promote` is an object that is validated separately to the clusterState object.
+Its properties are expected to be as follows:
+
+* `id` (string): id of the peer to be promoted (see "peer identifier")
+* `role` (string): current role of the peer to be promoted
+* `asyncIndex` (integer): position in the async chain (if "role" is "async")
+* `generation` (integer): generation of the cluster that the promotion is taking
+  place in
+* `time` (string): deadline for the promotion to happen within
 
 ### pg config
 
diff --git a/lib/manatee-peer.js b/lib/manatee-peer.js
index b6d242f..55f3a11 100644
--- a/lib/manatee-peer.js
+++ b/lib/manatee-peer.js
@@ -14,11 +14,13 @@
 
 var mod_assertplus = require('assert-plus');
 var mod_events = require('events');
+var mod_extsprintf = require('extsprintf');
 var mod_jsprim = require('jsprim');
 var mod_util = require('util');
 var mod_vasync = require('vasync');
 var VError = require('verror');
 
+var sprintf = mod_extsprintf.sprintf;
 var mod_validation = require('./validation');
 var mod_lsn = require('pg-lsn');
 var EventEmitter = mod_events.EventEmitter;
@@ -478,6 +480,14 @@ ManateePeer.prototype.evalClusterState = function (norest)
 		return;
 	}
 
+	/*
+	 * Determine if there is an operator-defined promotion that has been
+	 * requested (by way of a "promote" object on our ZooKeeper state) and
+	 * take action if required.
+	 */
+	if (this.promotion())
+		return;
+
 	/*
 	 * If the generation has changed, then go back to square one (unless
 	 * we think we're the primary but no longer are, in which case it's game
@@ -707,6 +717,51 @@ ManateePeer.prototype.startTransitionToNormalMode = function ()
 	});
 };
 
+/*
+ * Validates and acts on a "promote" object in the state object so long as it's
+ * applicable to this peer.
+ */
+ManateePeer.prototype.promotion = function ()
+{
+	var promote, whichasync, isTakeover, newasyncs;
+
+	promote = mod_validation.validatePromoteRequest(this.mp_zkstate);
+	if (!promote) {
+		return (false);
+	} else if (promote instanceof Error) {
+		this.mp_log.info({err: promote},
+		    'attempted to promote but invalid');
+		return (false);
+	}
+
+	/*
+	 * Only a sync can depose a primary, which is what needs to happen if
+	 * the sync is being promoted.  For any other promotion, the primary is
+	 * responsible.
+	 */
+	if (promote.role === MP_ROLE_SYNC) {
+		if (this.mp_role !== MP_ROLE_SYNC)
+			return (false);
+	} else {
+		if (this.mp_role !== MP_ROLE_PRIMARY)
+			return (false);
+	}
+
+	whichasync = promote.asyncIndex || 0;
+
+	isTakeover = (whichasync === 0);
+
+	if (isTakeover) {
+		var takeoverMsg = sprintf('promotion of "%s"', promote.id);
+		this.startTakeover(takeoverMsg, this.mp_zkstate.initWal);
+	} else {
+		newasyncs = mod_jsprim.deepCopy(this.mp_zkstate.async);
+		newasyncs.push(newasyncs.splice(whichasync-1, 1)[0]);
+		this.startUpdateAsyncs(newasyncs);
+	}
+	return (true);
+};
+
 ManateePeer.prototype.startTakeover = function (reason, minwal)
 {
 	var peer = this;
diff --git a/lib/schemas.js b/lib/schemas.js
index ad2cee4..e00e775 100644
--- a/lib/schemas.js
+++ b/lib/schemas.js
@@ -78,3 +78,29 @@ exports.pgStatus = {
 	}
     }
 };
+
+exports.promote = {
+    'type': 'object',
+    'properties': {
+	'id': sStringRequired,
+	'role': {
+	    'enum': [ 'sync', 'async' ],
+	    'required': true
+	},
+	/*
+	 * "asyncIndex" can only be null if "role" is not "async", validated in
+	 * lib/validation.js
+	 */
+	'asyncIndex': {
+	    'type': [ 'null', 'integer' ]
+	},
+	'generation': {
+	    'type': 'integer',
+	    'required': true
+	},
+	'time': {
+	    'type': 'integer',
+	    'required': true
+	}
+    }
+};
diff --git a/lib/sim.js b/lib/sim.js
index b8d9586..b0166bd 100644
--- a/lib/sim.js
+++ b/lib/sim.js
@@ -109,6 +109,8 @@ function Simulator(args)
 	        'list simulated peers' ],
 	    [ 'peer', this.cmdPeer, 'peer([raw])',
 	        'dump peer\'s current state' ],
+	    [ 'promote', this.cmdPromote, 'promote([object])',
+		'simulate a promotion request' ],
 	    [ 'rmpeer', this.cmdRmPeer, 'rmpeer(id)',
 	        'simulate a peer being removed from the ZK cluster' ],
 	    [ 'setClusterState', this.cmdSetClusterState,
@@ -713,6 +715,43 @@ Simulator.prototype.onRest = function ()
 	cmd.callback(null, cmd.rv);
 };
 
+Simulator.prototype.cmdPromote = function (promote)
+{
+	var zkstate;
+	var force = false;
+
+	mod_assertplus.object(promote, 'promote');
+	mod_assertplus.string(promote.id, 'promote.id');
+	mod_assertplus.string(promote.role, 'promote.role');
+	mod_assertplus.optionalNumber(promote.asyncIndex, 'promote.asyncIndex');
+	mod_assertplus.number(promote.generation, 'promote.generation');
+
+	if (promote.force) {
+		force = true;
+		delete promote.force;
+	}
+
+	zkstate = this.ms_zk.currentClusterState();
+	zkstate.promote = promote;
+
+	/*
+	 * We only simulate one peer, and in this case the sync might need to
+	 * depose the primary. For this specific scenario we must explicitly
+	 * perform this action via the cmdDepose method.
+	 *
+	 * Because we still want to test the role/id validation inside the state
+	 * machine, the "force" option is made available to allow the programmer
+	 * to force an update to ZooKeeper in order to trigger this check.
+	 */
+	if (promote.role === 'sync' && !force) {
+		this.cmdDepose();
+	} else {
+		this.ms_zk.setClusterState(zkstate);
+	}
+
+	return (this.simpleZkState(this.ms_zk.currentClusterState()));
+};
+
 /*
  * Given an acyclic, plain-old JavaScript object constructed from another
  * context that contains nothing but Objects, Arrays, and booleans, construct an
diff --git a/lib/validation.js b/lib/validation.js
index e73b015..98782ce 100644
--- a/lib/validation.js
+++ b/lib/validation.js
@@ -29,6 +29,7 @@ var schemas = require('./schemas');
 exports.validateZkState = validateZkState;
 exports.validateZkPeers = validateZkPeers;
 exports.validatePgStatus = validatePgStatus;
+exports.validatePromoteRequest = validatePromoteRequest;
 
 function validateZkState(clusterState)
 {
@@ -82,3 +83,38 @@ function validateAndCopy(schema, obj)
 		return (error);
 	return (mod_jsprim.deepCopy(obj));
 }
+
+function validatePromoteRequest(clusterState)
+{
+	var promote, error;
+	promote = mod_jsprim.pluck(clusterState, 'promote');
+
+	if (!promote)
+		return (undefined);
+
+	error = validateAndCopy(schemas.promote, promote);
+	if (error instanceof Error)
+		return (error);
+
+	if (promote.generation !== clusterState.generation)
+		return (new VError('generation does not match'));
+
+	if (promote.time < new Date().getTime())
+		return (new VError('deadline has passed'));
+
+	if (promote.role === 'async') {
+		if (!promote.hasOwnProperty('asyncIndex')) {
+			return (new VError(
+			    'asyncIndex required but is missing'));
+		}
+		if (promote.id !== clusterState.async[promote.asyncIndex].id) {
+			return (new VError('asyncIndex refers to wrong peer'));
+		}
+	} else {
+		if (promote.id !== clusterState[promote.role].id) {
+			return (new VError('id refers to peer in wrong role'));
+		}
+	}
+
+	return (clusterState.promote);
+}
diff --git a/test/tst.promote.js b/test/tst.promote.js
new file mode 100644
index 0000000..de029ce
--- /dev/null
+++ b/test/tst.promote.js
@@ -0,0 +1,134 @@
+var mod_jsprim = require('jsprim');
+var mod_test = require('./common');
+var ignoredState, sim, cmds;
+
+ignoredState = {
+    'clusterState': {
+	'generation': 2,
+	'primary': 'node1',
+	'sync': 'node3',
+	'async': [ 'node4', 'node2', 'node5' ],
+	'initWal': '0/0000000a'
+    },
+    'activeNodes': [ 'node1', 'node2', 'node3', 'node4', 'node5' ]
+};
+
+sim = mod_test.createTestSimulator();
+
+cmds = [
+    { 'cmd': 'addpeer', 'args': [ 'node1' ] },
+    { 'cmd': 'addpeer' },
+    { 'cmd': 'addpeer' },
+    { 'cmd': 'addpeer' },
+    { 'cmd': 'addpeer' },
+    { 'cmd': 'startPeer' },
+    { 'cmd': 'zk', 'check': {
+	'clusterState': {
+	    'generation': 1,
+	    'primary': 'node1',
+	    'sync': 'node2',
+	    'async': [ 'node3', 'node4', 'node5' ],
+	    'initWal': '0/00000000'
+	},
+	'activeNodes': [ 'node1', 'node2', 'node3', 'node4', 'node5' ]
+    } },
+    { 'cmd': 'echo', 'args': [ 'test: promote first async' ] },
+    { 'cmd': 'promote', 'args': [ {
+	'id': 'node3',
+	'role': 'async',
+	'asyncIndex': 0,
+	'generation': 1,
+	'time': new Date().getTime() + (5 * 1000)
+    } ] },
+    { 'cmd': 'zk', 'check': {
+	'clusterState': {
+	    'generation': 2,
+	    'primary': 'node1',
+	    'sync': 'node3',
+	    'async': [ 'node4', 'node5', 'node2' ],
+	    'initWal': '0/0000000a'
+	},
+	'activeNodes': [ 'node1', 'node2', 'node3', 'node4', 'node5' ]
+    } },
+    { 'cmd': 'echo', 'args': [ 'test: promote last async' ] },
+    { 'cmd': 'promote', 'args': [ {
+	'id': 'node2',
+	'role': 'async',
+	'asyncIndex': 2,
+	'generation': 2,
+	'time': new Date().getTime() + (5 * 1000)
+    } ] },
+    { 'cmd': 'zk', 'check': {
+	'clusterState': {
+	    'generation': 2,
+	    'primary': 'node1',
+	    'sync': 'node3',
+	    'async': [ 'node4', 'node2', 'node5' ],
+	    'initWal': '0/0000000a'
+	},
+	'activeNodes': [ 'node1', 'node2', 'node3', 'node4', 'node5' ]
+    } },
+    { 'cmd': 'echo', 'args': [ 'test: ignore (promote primary)' ] },
+    { 'cmd': 'promote', 'args': [ {
+	'id': 'node1',
+	'role': 'primary',
+	'generation': 2,
+	'time': new Date().getTime() + (5 * 1000)
+    } ] },
+    { 'cmd': 'zk', 'check': ignoredState },
+    { 'cmd': 'echo', 'args': [ 'test: ignore (deadline missed)' ] },
+    { 'cmd': 'promote', 'args': [ {
+	'id': 'node5',
+	'role': 'async',
+	'asyncIndex': 2,
+	'generation': 2,
+	'time': new Date().getTime() - 1000
+    } ] },
+    { 'cmd': 'zk', 'check': ignoredState },
+    { 'cmd': 'echo', 'args': [ 'test: ignore (invalid id/role)' ] },
+    { 'cmd': 'promote', 'args': [ {
+	'id': 'node4',
+	'role': 'sync',
+	'generation': 2,
+	'time': new Date().getTime(),
+	'force': true
+    } ] },
+    { 'cmd': 'zk', 'check': ignoredState },
+    { 'cmd': 'echo', 'args': [ 'test: ignore (invalid asyncIndex)' ] },
+    { 'cmd': 'promote', 'args': [ {
+	'id': 'node2',
+	'role': 'async',
+	'asyncIndex': 2,
+	'generation': 2,
+	'time': new Date().getTime() + (5 * 1000)
+    } ] },
+    { 'cmd': 'zk', 'check': ignoredState },
+    { 'cmd': 'echo', 'args': [ 'test: ignore (promote sync, no asyncs)' ] },
+    { 'cmd': 'echo', 'args': [ 'test: ignore (invalid role)' ] },
+    { 'cmd': 'promote', 'args': [ {
+	'id': 'node1',
+	'role': 'test',
+	'generation': 2,
+	'time': new Date().getTime() + (5 * 1000)
+    } ] },
+    { 'cmd': 'echo', 'args': [ 'test: promote sync' ] },
+    { 'cmd': 'promote', 'args': [ {
+	'id': 'node3',
+	'role': 'sync',
+	'generation': 1,
+	'time': new Date().getTime() + (5 * 1000)
+    } ] },
+    { 'cmd': 'zk', 'check': {
+	'clusterState': {
+	    'generation': 3,
+	    'primary': 'node3',
+	    'sync': 'node4',
+	    'async': [ 'node2', 'node5' ],
+	    'deposed': [ 'node1' ],
+	    'initWal': '0/00000014'
+	},
+	'activeNodes': [ 'node1', 'node2', 'node3', 'node4', 'node5' ]
+    } }
+];
+
+mod_test.runTestCommands(sim, cmds, process.argv[2] == '-v');
-- 
2.21.0

