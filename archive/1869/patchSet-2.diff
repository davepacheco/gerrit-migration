From 1a2495be4616b95b8c41bc1942524ffc1d1ac8aa Mon Sep 17 00:00:00 2001
From: Hans Rosenfeld <hans.rosenfeld@joyent.com>
Date: Wed, 26 Apr 2017 18:05:53 +0200
Subject: [PATCH] OS-6086 make pcplusmp and apix warning-free

---
 usr/src/uts/i86pc/apix/Makefile             |   3 -
 usr/src/uts/i86pc/io/apix/apix.c            |   8 +-
 usr/src/uts/i86pc/io/mp_platform_common.c   |   3 +-
 usr/src/uts/i86pc/io/mp_platform_misc.c     | 149 ++++++++++----------
 usr/src/uts/i86pc/io/pcplusmp/apic.c        |   8 +-
 usr/src/uts/i86pc/io/pcplusmp/apic_common.c |   2 +-
 usr/src/uts/i86pc/io/pcplusmp/apic_introp.c |  11 +-
 usr/src/uts/i86pc/pcplusmp/Makefile         |  16 +--
 usr/src/uts/i86pc/sys/apix.h                |   4 +-
 9 files changed, 97 insertions(+), 107 deletions(-)

diff --git a/usr/src/uts/i86pc/apix/Makefile b/usr/src/uts/i86pc/apix/Makefile
index c562707a10..21df6e6098 100644
--- a/usr/src/uts/i86pc/apix/Makefile
+++ b/usr/src/uts/i86pc/apix/Makefile
@@ -63,9 +63,6 @@ $(NOT_RELEASE_BUILD)DEBUG_DEFS	+= $(DEBUG_FLGS)
 #
 LDFLAGS		+= -dy -N misc/acpica
 
-CERRWARN	+= -_gcc=-Wno-uninitialized
-CERRWARN	+= -_gcc=-Wno-unused-function
-
 #
 #	Default build targets.
 #
diff --git a/usr/src/uts/i86pc/io/apix/apix.c b/usr/src/uts/i86pc/io/apix/apix.c
index 85890a1db6..bab7a3c6c5 100644
--- a/usr/src/uts/i86pc/io/apix/apix.c
+++ b/usr/src/uts/i86pc/io/apix/apix.c
@@ -1609,8 +1609,8 @@ apix_set_cpu(apix_vector_t *vecp, int new_cpu, int *result)
 	ddi_acc_handle_t handle;
 	ddi_intr_msix_t *msix_p = NULL;
 	ushort_t msix_ctrl;
-	uintptr_t off;
-	uint32_t mask;
+	uintptr_t off = 0;
+	uint32_t mask = 0;
 
 	ASSERT(LOCK_HELD(&apix_lock));
 	*result = ENXIO;
@@ -1668,8 +1668,8 @@ apix_grp_set_cpu(apix_vector_t *vecp, int new_cpu, int *result)
 	apix_vector_t *newp, *vp;
 	uint32_t orig_cpu = vecp->v_cpuid;
 	int orig_vect = vecp->v_vector;
-	int i, num_vectors, cap_ptr, msi_mask_off;
-	uint32_t msi_pvm;
+	int i, num_vectors, cap_ptr, msi_mask_off = 0;
+	uint32_t msi_pvm = 0;
 	ushort_t msi_ctrl;
 	ddi_acc_handle_t handle;
 	dev_info_t *dip;
diff --git a/usr/src/uts/i86pc/io/mp_platform_common.c b/usr/src/uts/i86pc/io/mp_platform_common.c
index 36ebd180ca..a2c54a42af 100644
--- a/usr/src/uts/i86pc/io/mp_platform_common.c
+++ b/usr/src/uts/i86pc/io/mp_platform_common.c
@@ -21,6 +21,7 @@
 /*
  * Copyright (c) 2007, 2010, Oracle and/or its affiliates. All rights reserved.
  * Copyright 2016 Nexenta Systems, Inc.
+ * Copyright 2017 Joyent, Inc.
  */
 /*
  * Copyright (c) 2010, Intel Corporation.
@@ -329,7 +330,7 @@ apic_probe_common(char *modname)
 	caddr_t	biosdatap;
 	caddr_t	mpct = 0;
 	caddr_t	fptr;
-	int	i, mpct_size, mapsize, retval = PSM_FAILURE;
+	int	i, mpct_size = 0, mapsize, retval = PSM_FAILURE;
 	ushort_t	ebda_seg, base_mem_size;
 	struct	apic_mpfps_hdr	*fpsp;
 	struct	apic_mp_cnf_hdr	*hdrp;
diff --git a/usr/src/uts/i86pc/io/mp_platform_misc.c b/usr/src/uts/i86pc/io/mp_platform_misc.c
index 3737a59a8d..5126c52c30 100644
--- a/usr/src/uts/i86pc/io/mp_platform_misc.c
+++ b/usr/src/uts/i86pc/io/mp_platform_misc.c
@@ -20,6 +20,7 @@
  */
 /*
  * Copyright (c) 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright 2017 Joyent, Inc.
  */
 /*
  * Copyright (c) 2010, Intel Corporation.
@@ -644,7 +645,7 @@ apic_delspl_common(int irqno, int ipl, int min_ipl, int max_ipl)
 			ASSERT(hwpri >= 0);
 			ASSERT(hwpri < MAXIPL);
 			max_ipl = apic_vectortoipl[hwpri];
-			apic_ipls[apic_ipls_index] = max_ipl;
+			apic_ipls[apic_ipls_index] = (uchar_t)max_ipl;
 
 			irqp = irqheadptr;
 			while (irqp) {
@@ -945,7 +946,7 @@ defconf:
  */
 static int
 apic_share_vector(int irqno, iflag_t *intr_flagp, short intr_index, int ipl,
-	uchar_t ioapicindex, uchar_t ipin, apic_irq_t **irqptrp)
+    uchar_t ioapicindex, uchar_t ipin, apic_irq_t **irqptrp)
 {
 #ifdef DEBUG
 	apic_irq_t *tmpirqp = NULL;
@@ -1050,19 +1051,22 @@ static int
 apic_setup_irq_table(dev_info_t *dip, int irqno, struct apic_io_intr *intrp,
     struct intrspec *ispec, iflag_t *intr_flagp, int type)
 {
-	int origirq = ispec->intrspec_vec;
-	uchar_t ipl = ispec->intrspec_pri;
+	int origirq;
+	uchar_t ipl;
 	int	newirq, intr_index;
 	uchar_t	ipin, ioapic, ioapicindex, vector;
 	apic_irq_t *irqptr;
 	major_t	major;
 	dev_info_t	*sdip;
 
+	ASSERT(ispec != NULL);
+
+	origirq = ispec->intrspec_vec;
+	ipl = ispec->intrspec_pri;
+
 	DDI_INTR_IMPLDBG((CE_CONT, "apic_setup_irq_table: dip=0x%p type=%d "
 	    "irqno=0x%x origirq=0x%x\n", (void *)dip, type, irqno, origirq));
 
-	ASSERT(ispec != NULL);
-
 	major =  (dip != NULL) ? ddi_driver_major(dip) : 0;
 
 	if (DDI_INTR_IS_MSI_OR_MSIX(type)) {
@@ -1121,10 +1125,7 @@ apic_setup_irq_table(dev_info_t *dip, int irqno, struct apic_io_intr *intrp,
 		intr_index = DEFAULT_INDEX;
 	}
 
-	if (ispec == NULL) {
-		APIC_VERBOSE_IOAPIC((CE_WARN, "No intrspec for irqno = %x\n",
-		    irqno));
-	} else if ((vector = apic_allocate_vector(ipl, irqno, 0)) == 0) {
+	if ((vector = apic_allocate_vector(ipl, irqno, 0)) == 0) {
 		if ((newirq = apic_share_vector(irqno, intr_flagp, intr_index,
 		    ipl, ioapicindex, ipin, &irqptr)) != -1) {
 			irqptr->airq_ipl = ipl;
@@ -1228,60 +1229,67 @@ apic_bind_intr(dev_info_t *dip, int irq, uchar_t ioapicid, uchar_t intin)
 	if (apic_nproc == 1)
 		return (0);
 
-	drv_name = NULL;
-	rc = DDI_PROP_NOT_FOUND;
-	major = (major_t)-1;
-	if (dip != NULL) {
-		name = ddi_get_name(dip);
-		major = ddi_name_to_major(name);
-		drv_name = ddi_major_to_name(major);
-		instance = ddi_get_instance(dip);
-		if (apic_intr_policy == INTR_ROUND_ROBIN_WITH_AFFINITY) {
-			i = apic_min_device_irq;
-			for (; i <= apic_max_device_irq; i++) {
-
-				if ((i == irq) || (apic_irq_table[i] == NULL) ||
-				    (apic_irq_table[i]->airq_mps_intr_index
-				    == FREE_INDEX))
-					continue;
-
-				if ((apic_irq_table[i]->airq_major == major) &&
-				    (!(apic_irq_table[i]->airq_cpu &
-				    IRQ_USER_BOUND))) {
-
-					cpu = apic_irq_table[i]->airq_cpu;
-
-					cmn_err(CE_CONT,
-					    "!%s: %s (%s) instance #%d "
-					    "irq 0x%x vector 0x%x ioapic 0x%x "
-					    "intin 0x%x is bound to cpu %d\n",
-					    psm_name,
-					    name, drv_name, instance, irq,
-					    apic_irq_table[irq]->airq_vector,
-					    ioapicid, intin, cpu);
-					return (cpu);
-				}
+	if (dip == NULL) {
+		iflag = intr_clear();
+		lock_set(&apic_ioapic_lock);
+		bind_cpu = apic_get_next_bind_cpu();
+		lock_clear(&apic_ioapic_lock);
+		intr_restore(iflag);
+
+		cmn_err(CE_CONT, "!%s: irq 0x%x "
+		    "vector 0x%x ioapic 0x%x intin 0x%x is bound to cpu %d\n",
+		    psm_name, irq, apic_irq_table[irq]->airq_vector, ioapicid,
+		    intin, bind_cpu & ~IRQ_USER_BOUND);
+
+		return ((uint32_t)bind_cpu);
+	}
+
+	name = ddi_get_name(dip);
+	major = ddi_name_to_major(name);
+	drv_name = ddi_major_to_name(major);
+	instance = ddi_get_instance(dip);
+	if (apic_intr_policy == INTR_ROUND_ROBIN_WITH_AFFINITY) {
+		i = apic_min_device_irq;
+		for (; i <= apic_max_device_irq; i++) {
+			if ((i == irq) || (apic_irq_table[i] == NULL) ||
+			    (apic_irq_table[i]->airq_mps_intr_index
+			    == FREE_INDEX))
+				continue;
+
+			if ((apic_irq_table[i]->airq_major == major) &&
+			    (!(apic_irq_table[i]->airq_cpu & IRQ_USER_BOUND))) {
+				cpu = apic_irq_table[i]->airq_cpu;
+
+				cmn_err(CE_CONT,
+				    "!%s: %s (%s) instance #%d "
+				    "irq 0x%x vector 0x%x ioapic 0x%x "
+				    "intin 0x%x is bound to cpu %d\n",
+				    psm_name,
+				    name, drv_name, instance, irq,
+				    apic_irq_table[irq]->airq_vector,
+				    ioapicid, intin, cpu);
+				return (cpu);
 			}
 		}
-		/*
-		 * search for "drvname"_intpt_bind_cpus property first, the
-		 * syntax of the property should be "a[,b,c,...]" where
-		 * instance 0 binds to cpu a, instance 1 binds to cpu b,
-		 * instance 3 binds to cpu c...
-		 * ddi_getlongprop() will search /option first, then /
-		 * if "drvname"_intpt_bind_cpus doesn't exist, then find
-		 * intpt_bind_cpus property.  The syntax is the same, and
-		 * it applies to all the devices if its "drvname" specific
-		 * property doesn't exist
-		 */
-		(void) strcpy(prop_name, drv_name);
-		(void) strcat(prop_name, "_intpt_bind_cpus");
-		rc = ddi_getlongprop(DDI_DEV_T_ANY, dip, 0, prop_name,
-		    (caddr_t)&prop_val, &prop_len);
-		if (rc != DDI_PROP_SUCCESS) {
-			rc = ddi_getlongprop(DDI_DEV_T_ANY, dip, 0,
-			    "intpt_bind_cpus", (caddr_t)&prop_val, &prop_len);
-		}
+	}
+	/*
+	 * search for "drvname"_intpt_bind_cpus property first, the
+	 * syntax of the property should be "a[,b,c,...]" where
+	 * instance 0 binds to cpu a, instance 1 binds to cpu b,
+	 * instance 3 binds to cpu c...
+	 * ddi_getlongprop() will search /option first, then /
+	 * if "drvname"_intpt_bind_cpus doesn't exist, then find
+	 * intpt_bind_cpus property.  The syntax is the same, and
+	 * it applies to all the devices if its "drvname" specific
+	 * property doesn't exist
+	 */
+	(void) strcpy(prop_name, drv_name);
+	(void) strcat(prop_name, "_intpt_bind_cpus");
+	rc = ddi_getlongprop(DDI_DEV_T_ANY, dip, 0, prop_name,
+	    (caddr_t)&prop_val, &prop_len);
+	if (rc != DDI_PROP_SUCCESS) {
+		rc = ddi_getlongprop(DDI_DEV_T_ANY, dip, 0,
+		    "intpt_bind_cpus", (caddr_t)&prop_val, &prop_len);
 	}
 	if (rc == DDI_PROP_SUCCESS) {
 		for (i = count = 0; i < (prop_len - 1); i++)
@@ -1317,6 +1325,7 @@ apic_bind_intr(dev_info_t *dip, int irq, uchar_t ioapicid, uchar_t intin)
 		 * not up, then post_cpu_start will handle it.
 		 */
 	}
+
 	if (rc != DDI_PROP_SUCCESS) {
 		iflag = intr_clear();
 		lock_set(&apic_ioapic_lock);
@@ -1325,17 +1334,11 @@ apic_bind_intr(dev_info_t *dip, int irq, uchar_t ioapicid, uchar_t intin)
 		intr_restore(iflag);
 	}
 
-	if (drv_name != NULL)
-		cmn_err(CE_CONT, "!%s: %s (%s) instance %d irq 0x%x "
-		    "vector 0x%x ioapic 0x%x intin 0x%x is bound to cpu %d\n",
-		    psm_name, name, drv_name, instance, irq,
-		    apic_irq_table[irq]->airq_vector, ioapicid, intin,
-		    bind_cpu & ~IRQ_USER_BOUND);
-	else
-		cmn_err(CE_CONT, "!%s: irq 0x%x "
-		    "vector 0x%x ioapic 0x%x intin 0x%x is bound to cpu %d\n",
-		    psm_name, irq, apic_irq_table[irq]->airq_vector, ioapicid,
-		    intin, bind_cpu & ~IRQ_USER_BOUND);
+	cmn_err(CE_CONT, "!%s: %s (%s) instance %d irq 0x%x "
+	    "vector 0x%x ioapic 0x%x intin 0x%x is bound to cpu %d\n",
+	    psm_name, name, drv_name, instance, irq,
+	    apic_irq_table[irq]->airq_vector, ioapicid, intin,
+	    bind_cpu & ~IRQ_USER_BOUND);
 
 	return ((uint32_t)bind_cpu);
 }
diff --git a/usr/src/uts/i86pc/io/pcplusmp/apic.c b/usr/src/uts/i86pc/io/pcplusmp/apic.c
index 8523112173..4a03f6d0a1 100644
--- a/usr/src/uts/i86pc/io/pcplusmp/apic.c
+++ b/usr/src/uts/i86pc/io/pcplusmp/apic.c
@@ -995,7 +995,7 @@ apic_alloc_msi_vectors(dev_info_t *dip, int inum, int count, int pri,
 {
 	int	rcount, i;
 	uchar_t	start, irqno;
-	uint32_t cpu;
+	uint32_t cpu = 0;
 	major_t	major;
 	apic_irq_t	*irqptr;
 
@@ -1067,7 +1067,7 @@ apic_alloc_msi_vectors(dev_info_t *dip, int inum, int count, int pri,
 		irqptr->airq_vector = (uchar_t)(start + i);
 		irqptr->airq_ioapicindex = (uchar_t)inum;	/* start */
 		irqptr->airq_intin_no = (uchar_t)rcount;
-		irqptr->airq_ipl = pri;
+		irqptr->airq_ipl = (uchar_t)pri;
 		irqptr->airq_vector = start + i;
 		irqptr->airq_origirq = (uchar_t)(inum + i);
 		irqptr->airq_share_id = 0;
@@ -1144,7 +1144,7 @@ apic_alloc_msix_vectors(dev_info_t *dip, int inum, int count, int pri,
 		apic_min_device_irq = min(irqno, apic_min_device_irq);
 		irqptr = apic_irq_table[irqno];
 		irqptr->airq_vector = (uchar_t)vector;
-		irqptr->airq_ipl = pri;
+		irqptr->airq_ipl = (uchar_t)pri;
 		irqptr->airq_origirq = (uchar_t)(inum + i);
 		irqptr->airq_share_id = 0;
 		irqptr->airq_mps_intr_index = MSIX_INDEX;
@@ -1186,7 +1186,7 @@ apic_allocate_vector(int ipl, int irq, int pri)
 			continue;
 		if (apic_vector_to_irq[i] == APIC_RESV_IRQ) {
 			apic_vector_to_irq[i] = (uchar_t)irq;
-			return (i);
+			return ((uchar_t)i);
 		}
 	}
 
diff --git a/usr/src/uts/i86pc/io/pcplusmp/apic_common.c b/usr/src/uts/i86pc/io/pcplusmp/apic_common.c
index 7498150d49..3892bc3f85 100644
--- a/usr/src/uts/i86pc/io/pcplusmp/apic_common.c
+++ b/usr/src/uts/i86pc/io/pcplusmp/apic_common.c
@@ -846,7 +846,7 @@ apic_cpu_add(psm_cpu_request_t *reqp)
 	int i, rv = 0;
 	ulong_t iflag;
 	boolean_t first = B_TRUE;
-	uchar_t localver;
+	uchar_t localver = 0;
 	uint32_t localid, procid;
 	processorid_t cpuid = (processorid_t)-1;
 	mach_cpu_add_arg_t *ap;
diff --git a/usr/src/uts/i86pc/io/pcplusmp/apic_introp.c b/usr/src/uts/i86pc/io/pcplusmp/apic_introp.c
index 472e73afeb..cde24b0109 100644
--- a/usr/src/uts/i86pc/io/pcplusmp/apic_introp.c
+++ b/usr/src/uts/i86pc/io/pcplusmp/apic_introp.c
@@ -21,6 +21,7 @@
 /*
  * Copyright (c) 2005, 2010, Oracle and/or its affiliates. All rights reserved.
  * Copyright 2013 Pluribus Networks, Inc.
+ * Copyright 2017 Joyent, Inc.
  */
 
 /*
@@ -227,7 +228,7 @@ apic_find_multi_vectors(int pri, int count)
 				break;
 			navail++;
 			if (navail >= count)
-				return (start);
+				return ((uchar_t)start);
 			i++;
 		}
 	}
@@ -505,9 +506,9 @@ apic_grp_set_cpu(int irqno, int new_cpu, int *result)
 	apic_irq_t *irqps[PCI_MSI_MAX_INTRS];
 	int i;
 	int cap_ptr;
-	int msi_mask_off;
+	int msi_mask_off = 0;
 	ushort_t msi_ctrl;
-	uint32_t msi_pvm;
+	uint32_t msi_pvm = 0;
 	ddi_acc_handle_t handle;
 	int num_vectors = 0;
 	uint32_t vector;
@@ -657,7 +658,7 @@ apic_get_vector_intr_info(int vecirq, apic_get_intr_t *intr_params_p)
 	    PSMGI_INTRBY_VEC)
 		irqno = apic_vector_to_irq[vecirq];
 	else
-		irqno = vecirq;
+		irqno = (uchar_t)vecirq;
 
 	irq_p = apic_irq_table[irqno];
 
@@ -700,7 +701,7 @@ apic_get_vector_intr_info(int vecirq, apic_get_intr_t *intr_params_p)
 				if (av_dev->av_vector && av_dev->av_dip)
 					i++;
 			intr_params_p->avgi_num_devs =
-			    MIN(intr_params_p->avgi_num_devs, i);
+			    (uchar_t)MIN(intr_params_p->avgi_num_devs, i);
 		}
 
 		/* There are no viable dips to return. */
diff --git a/usr/src/uts/i86pc/pcplusmp/Makefile b/usr/src/uts/i86pc/pcplusmp/Makefile
index 92c455017d..6795ea994a 100644
--- a/usr/src/uts/i86pc/pcplusmp/Makefile
+++ b/usr/src/uts/i86pc/pcplusmp/Makefile
@@ -24,7 +24,7 @@
 # Copyright 2007 Sun Microsystems, Inc.  All rights reserved.
 # Use is subject to license terms.
 #
-# Copyright 2016, Joyent, Inc.
+# Copyright 2017, Joyent, Inc.
 #
 
 #
@@ -67,20 +67,6 @@ $(NOT_RELEASE_BUILD)DEBUG_DEFS	+= $(DEBUG_FLGS)
 #
 LDFLAGS		+= -dy -N misc/acpica
 
-CERRWARN	+= -_gcc=-Wno-unused-function
-
-#
-# For now, disable these lint checks; maintainers should endeavor
-# to investigate and remove these for maximum lint coverage.
-# Please do not carry these forward to new Makefiles.
-#
-LINTTAGS	+= -erroff=E_BAD_PTR_CAST_ALIGN
-LINTTAGS	+= -erroff=E_SUPPRESSION_DIRECTIVE_UNUSED
-LINTTAGS	+= -erroff=E_STATIC_UNUSED
-LINTTAGS	+= -erroff=E_ASSIGN_NARROW_CONV
-
-CERRWARN	+= -_gcc=-Wno-uninitialized
-
 #
 #	Default build targets.
 #
diff --git a/usr/src/uts/i86pc/sys/apix.h b/usr/src/uts/i86pc/sys/apix.h
index 8237d2e455..f3b775086f 100644
--- a/usr/src/uts/i86pc/sys/apix.h
+++ b/usr/src/uts/i86pc/sys/apix.h
@@ -20,6 +20,7 @@
  */
 /*
  * Copyright (c) 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright 2017 Joyent, Inc.
  */
 
 #ifndef __SYS_APIX_APIX_H
@@ -287,11 +288,12 @@ extern struct apix_rebind_info apix_rebindinfo;
 
 #define	APIX_DO_FAKE_INTR(_cpu, _vector)\
 	if (APIX_IS_FAKE_INTR(_vector)) {\
-		struct autovec *tp;\
+		struct autovec *tp = NULL;\
 		if ((_cpu) == apix_rebindinfo.i_old_cpuid)\
 			tp = apix_rebindinfo.i_old_av;\
 		else if ((_cpu) == apix_rebindinfo.i_new_cpuid)\
 			tp = apix_rebindinfo.i_new_av;\
+		ASSERT(tp != NULL);\
 		if (tp->av_vector != NULL &&\
 		    (tp->av_flags & AV_PENTRY_PEND) == 0) {\
 			tp->av_flags |= AV_PENTRY_PEND;\
-- 
2.21.0

