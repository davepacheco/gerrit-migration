From 96aa67ca3c8f9cc4c8cd39b6ac6fd5b5d062cea8 Mon Sep 17 00:00:00 2001
From: Marsell Kukuljevic <marsell@joyent.com>
Date: Wed, 13 Feb 2019 23:42:39 +0100
Subject: [PATCH] TRITON-1227 Windows snapshot script needs to be under 3000
 bytes long

---
 Makefile                                      |  8 ++++
 .../README.windows-prepare-image.md           | 35 ++++++++++++++++
 tools/prepare-image/windows-prepare-image     | 42 -------------------
 3 files changed, 43 insertions(+), 42 deletions(-)
 create mode 100644 tools/prepare-image/README.windows-prepare-image.md

diff --git a/Makefile b/Makefile
index 3194ff1..0b0d68b 100644
--- a/Makefile
+++ b/Makefile
@@ -97,6 +97,14 @@ test: | $(NODEUNIT)
 	#./test/runtests -lp  # test local 'public' mode
 	#./test/runtests -l   # test local 'dc' mode
 
+.PHONY:
+check-windows-prepare-image:
+	BYTES=$$(wc -c $(TOP)/tools/prepare-image/windows-prepare-image | awk '/\d+/{ print $$1}' ) ;\
+	if [[ $$BYTES -gt 3000 ]]; then \
+		echo "error: 'windows-prepare-image' is more than 3000 bytes"; \
+		exit 1; \
+	fi
+
 # We get the IMGAPI errors table from "lib/errors.js". This should be re-run
 # for "lib/errors.js" changes!
 .PHONY: doc-update-error-table
diff --git a/tools/prepare-image/README.windows-prepare-image.md b/tools/prepare-image/README.windows-prepare-image.md
new file mode 100644
index 0000000..c1813b6
--- /dev/null
+++ b/tools/prepare-image/README.windows-prepare-image.md
@@ -0,0 +1,35 @@
+Due to TOOLS-2126, the upper limit on the number of bytes that can be retrieved
+by mdata-get -- used to pull the prepare script into the VM for execution --
+is 3000 bytes.
+
+In order to reduce windows-prepare-image below 3000 bytes, the header comment
+is moved here until TOOLS-2126 is fixed:
+
+# Set Window's cleanmgr to (nearly) max, and run it. This cleans up most
+# temporary (files, cache) and unneeded data (outdated installation data).
+#
+# In order for this script to work, a Windows image needs to have mdata-get.exe,
+# mdata-put.exe and prepare_image_runner.ps1 installed in C:\smartdc\bin, and
+# prepare_image_runner.ps1 should be run by Windows on every boot. Upon boot,
+# prepare_image_runner.ps1 will then check if "sdc:operator-script" metadata
+# (seen as internal_metadata."operator-script" in "vmadm get" output) is present
+# over COM2, and run it. If it's not present, booting continues as normal.
+#
+# Apparently, the only way to get cleanmgr to run without displaying a final
+# information dialog -- thus hanging image creation -- is through the /autoclean
+# flag. We abuse this by setting all available cleanup options in the registry
+# to be run by autoclean. Since the VM will be rolled back after image creation,
+# this change is not a problem.
+#
+# There are also a couple very expensive cleanmgr checks that increase
+# cleanmgr's run time up to 5x, which we cannot afford with the 5m time limit
+# imposed on image creation between prepare-script 'running' and
+# final 'error'/'success' calls. The only way to disable these checks outright
+# is to temporarily move their registry keys, which we do as well.
+#
+# After that, cleanmgr is run, then moving the expensive registry keys back.
+#
+# Unfortunately, cleanmgr /autoclean appears to contain its own logic about when
+# it will clean up something. As a result, we also empty recycle bins and clear
+# most temp and log directories manually.
+
diff --git a/tools/prepare-image/windows-prepare-image b/tools/prepare-image/windows-prepare-image
index ba689c6..62f6519 100644
--- a/tools/prepare-image/windows-prepare-image
+++ b/tools/prepare-image/windows-prepare-image
@@ -3,34 +3,6 @@
 # file, You can obtain one at http://mozilla.org/MPL/2.0/.
 #
 # Copyright (c) 2018, Joyent, Inc.
-#
-# Set Window's cleanmgr to (nearly) max, and run it. This cleans up most
-# temporary (files, cache) and unneeded data (outdated installation data).
-#
-# In order for this script to work, a Windows image needs to have mdata-get.exe,
-# mdata-put.exe and prepare_image_runner.ps1 installed in C:\smartdc\bin, and
-# prepare_image_runner.ps1 should be run by Windows on every boot. Upon boot,
-# prepare_image_runner.ps1 will then check if "sdc:operator-script" metadata
-# (seen as internal_metadata."operator-script" in "vmadm get" output) is present
-# over COM2, and run it. If it's not present, booting continues as normal.
-#
-# Apparently, the only way to get cleanmgr to run without displaying a final
-# information dialog -- thus hanging image creation -- is through the /autoclean
-# flag. We abuse this by setting all available cleanup options in the registry
-# to be run by autoclean. Since the VM will be rolled back after image creation,
-# this change is not a problem.
-#
-# There are also a couple very expensive cleanmgr checks that increase
-# cleanmgr's run time up to 5x, which we cannot afford with the 5m time limit
-# imposed on image creation between prepare-script 'running' and
-# final 'error'/'success' calls. The only way to disable these checks outright
-# is to temporarily move their registry keys, which we do as well.
-#
-# After that, cleanmgr is run, then moving the expensive registry keys back.
-#
-# Unfortunately, cleanmgr /autoclean appears to contain its own logic about when
-# it will clean up something. As a result, we also empty recycle bins and clear
-# most temp and log directories manually.
 
 $parent_path = 'HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\VolumeCaches'
 $tmp_parent_path = 'HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer'
@@ -61,10 +33,8 @@ function error($msg) {
 }
 
 
-echo 'Starting run...'
 mput 'state' 'running'
 
-echo "Disabling particularly expensive cleanmgr operations"
 foreach ($cleanup in $expensive_cleanups) {
     try {
         Move-Item -LiteralPath (setting_path $cleanup) `
@@ -72,7 +42,6 @@ foreach ($cleanup in $expensive_cleanups) {
     } catch [System.Management.Automation.PSInvalidOperationException] {}
 }
 
-echo 'Marking all other checks for /autoclean'
 try {
     $cleanups = (Get-Item -LiteralPath $parent_path).GetSubKeyNames()
 } catch {
@@ -101,18 +70,13 @@ try {
     error 'Bad Set-Item'
 }
 
-echo 'Running cleanmgr...'
 try {
-    # Out-Null needed to block script until cleanmgr completes
     c:\windows\system32\cleanmgr.exe /autoclean | Out-Null
 } catch [System.Management.Automation.CommandNotFoundException] {
-    # Ignore, in case we are dealing with a 2012r2 instance without
-    # Desktop Experience installed
 } catch {
     error 'Bad cleanmgr'
 }
 
-echo 'Unmarking other checks /autoclean'
 try {
     foreach ($path in $add_auto_paths) {
         Set-ItemProperty -LiteralPath $path -Name 'Autorun' `
@@ -122,7 +86,6 @@ try {
     error 'Bad auto undo'
 }
 
-echo 'Reenabling expensive cleanmgr operations'
 foreach ($cleanup in $expensive_cleanups) {
     try {
         Move-Item -LiteralPath (tmp_path $cleanup) `
@@ -130,18 +93,14 @@ foreach ($cleanup in $expensive_cleanups) {
     } catch [System.Management.Automation.PSInvalidOperationException] {}
 }
 
-echo 'Empty Recycle Bins'
 try {
      Clear-RecycleBin -Confirm:$false -ErrorAction Stop
 } catch [System.ComponentModel.Win32Exception],
         [System.Management.Automation.CommandNotFoundException] {
-    # Ignore, in case we are dealing with a Powershell older than 5.1 on 2012r2.
-    # By default, 2012r2 has Powershell 4.0, but updates can increase it to 5.1
 } catch {
     error 'Bad empty recycle'
 }
 
-echo 'Clear out temp and log directories'
 foreach ($path in $clean_dirs) {
     try {
         Remove-Item -Path $path -Recurse -Force -ErrorAction Stop
@@ -150,4 +109,3 @@ foreach ($path in $clean_dirs) {
 
 
 mput 'state' 'success'
-echo 'Done!'
-- 
2.21.0

