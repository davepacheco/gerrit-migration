commit 4060149a3810762a2e615c6cbc43a0c75c8d9d86
Author: Trent Mick <trentm@gmail.com>
Date:   2019-07-24T17:26:29-07:00 (3 months ago)
    
    MANTA-4432 converting node-manta's test suite from nodeunit to node-tap

diff --git a/.gitignore b/.gitignore
index fc23e5a..c6a8ec9 100644
--- a/.gitignore
+++ b/.gitignore
@@ -8,6 +8,6 @@ cscope.po.out
 cscope.out
 smf/manifests/bapi.xml
 /manta-*.tgz
-/test/node.paths
 /npm-debug.log
 /share/manta.completion
+/test.tap
diff --git a/Makefile b/Makefile
index 3b697b5..bdb7a8e 100644
--- a/Makefile
+++ b/Makefile
@@ -1,5 +1,5 @@
 #
-# Copyright 2016 Joyent, Inc.
+# Copyright 2019 Joyent, Inc.
 #
 
 #
@@ -7,8 +7,11 @@
 #
 # Get md2man-roff from <https://github.com/sunaku/md2man>
 MD2MAN                  := md2man-roff
-NODEUNIT		:= ./node_modules/.bin/nodeunit
 NPM			:= npm
+TAP_EXEC = ./node_modules/.bin/tap
+TEST_JOBS ?= 10
+TEST_TIMEOUT_S ?= 1200
+TEST_FILTER ?= .*
 
 #
 # Files
@@ -44,73 +47,21 @@ COMPLETION_FILE=share/manta.completion
 all: $(SMF_MANIFESTS) deps completion
 
 .PHONY: deps
-deps: | $(REPO_DEPS) $(NPM_EXEC)
+deps $(TAP_EXEC): | $(REPO_DEPS) $(NPM_EXEC)
 	$(NPM_ENV) $(NPM) install
 
-# Use "TEST_FILTER" to limit test files run, e.g.:
-#    make test TEST_FILTER=muntar
-.PHONY: test
-test: deps
-	unset MANTA_DEFAULT_CONTENT_TYPE; \
-		if [[ -z "$(TEST_FILTER)" ]]; then \
-			$(NODEUNIT) test/*.test.js; \
-		else \
-			echo "# Running subset of tests matching TEST_FILTER=$(TEST_FILTER)"; \
-			$(NODEUNIT) $(NODEUNIT_ARGS) $(shell ls test/*.test.js | grep "$(TEST_FILTER)"); \
-		fi
 
-#
-# Test with a bunch of node versions.
-#
-# This requires a "test/node.paths" file that looks something like
-# "test/node.paths.example".
-#
-# Note: 'test4' is here last on the assumption that Node v4 is the most common
-# current node version for a developer, so a 'make testall' will leave one
-# with a node_modules/ for that version.
-#
-.PHONY: testall
-testall: test8 test6 test012 test010 test4
-
-.PHONY: test8
-test8:
-	@([[ -f test/node.paths ]] || (echo "no test/node.paths" && exit 1) \
-		&& echo "# Test with node `$(shell awk '/^8/ { print $$2 }' test/node.paths)/node --version`" \
-		&& PATH="$(shell awk '/^8/ { print $$2 }' test/node.paths):$(PATH)" \
-			NPM_CONFIG_LOGLEVEL=silent NPM_CONFIG_PROGRESS=false \
-			make clean test)
-
-.PHONY: test6
-test6:
-	@([[ -f test/node.paths ]] || (echo "no test/node.paths" && exit 1) \
-		&& echo "# Test with node `$(shell awk '/^6/ { print $$2 }' test/node.paths)/node --version`" \
-		&& PATH="$(shell awk '/^6/ { print $$2 }' test/node.paths):$(PATH)" \
-			NPM_CONFIG_LOGLEVEL=silent NPM_CONFIG_PROGRESS=false \
-			make clean test)
-
-.PHONY: test4
-test4:
-	@([[ -f test/node.paths ]] || (echo "no test/node.paths" && exit 1) \
-		&& echo "# Test with node `$(shell awk '/^4/ { print $$2 }' test/node.paths)/node --version`" \
-		&& PATH="$(shell awk '/^4/ { print $$2 }' test/node.paths):$(PATH)" \
-			NPM_CONFIG_LOGLEVEL=silent NPM_CONFIG_PROGRESS=false \
-			make clean test)
-
-.PHONY: test012
-test012:
-	@([[ -f test/node.paths ]] || (echo "no test/node.paths" && exit 1) \
-		&& echo "# Test with node `$(shell awk '/^0\.12/ { print $$2 }' test/node.paths)/node --version`" \
-		&& PATH="$(shell awk '/^0\.12/ { print $$2 }' test/node.paths):$(PATH)" \
-			NPM_CONFIG_LOGLEVEL=silent NPM_CONFIG_PROGRESS=false \
-			make clean test)
-
-.PHONY: test010
-test010:
-	@([[ -f test/node.paths ]] || (echo "no test/node.paths" && exit 1) \
-		&& echo "# Test with node `$(shell awk '/^0\.10/ { print $$2 }' test/node.paths)/node --version`" \
-		&& PATH="$(shell awk '/^0\.10/ { print $$2 }' test/node.paths):$(PATH)" \
-			NPM_CONFIG_LOGLEVEL=silent NPM_CONFIG_PROGRESS=false \
-			make clean test)
+.PHONY: ensure-node-v6-or-greater-for-test-suite
+ensure-node-v6-or-greater-for-test-suite: | $(TAP_EXEC)
+	@NODE_VER=$(shell node --version) && \
+	    ./node_modules/.bin/semver -r '>=6.x' $$NODE_VER >/dev/null || \
+	    (echo "error: node-tap@12 runner requires node v6 or greater: you have $$NODE_VER"; exit 1)
+
+.PHONY: test
+test: ensure-node-v6-or-greater-for-test-suite | $(TAP_EXEC)
+	@testFiles="$(shell ls test/unit/*.test.js test/integration/*.test.js | egrep "$(TEST_FILTER)")" && \
+	    test -z "$$testFiles" || \
+	    NODE_NDEBUG= $(TAP_EXEC) --timeout $(TEST_TIMEOUT_S) -j $(TEST_JOBS) -o ./test.tap $$testFiles
 
 
 $(MAN_OUTDIR):
diff --git a/README.md b/README.md
index a51c358..106fbe0 100644
--- a/README.md
+++ b/README.md
@@ -141,27 +141,71 @@ Docs can be found here:
 
 # Testing
 
-Running this test suite will create files in Manta (using your current
-`MANTA_*` environment variables).
+node-manta has both unit tests ("test/unit/*.test.js") and integration tests
+("test/integration/*.test.js"). Integration tests require `MANTA_` envvars for
+configuration and will run tests against the configured Manta.
 
-    make test
+Usage:
 
-The set of test files run can be filtered:
+    make test [TEST-VARS]               # run all sets
+    node test/.../foo.test.js           # run a specific test file
+    make test [TEST_FILTER=unit/]       # run just the unit tests
 
-    make test TEST_FILTER=muntar
+    # trace-logging of test code
+    make test TEST_LOG_LEVEL=trace TEST_JOBS=1 2> >(bunyan)
 
-As well, you can get debug/trace logging (note that we intentionally avoid
-`LOG_LEVEL` because the `m*` tools use that and sharing the same envvar can
-break tests):
+Test output is node-tap's default "classic" output. Full TAP output is written
+to "test.tap". You can use `TAP=1` to have TAP output emited to stdout.
 
-    make test TEST_LOG_LEVEL=trace 2>&1 | bunyan
+## Test vars
 
+The following `MANTA_...` envvars configure the test run and `TEST_...`
+envvars can tweak how the tests are run. As well, a number of node-tap
+`TAP_...` envvars are available -- run `./node_modules/.bin/tap` for docs
+on those.
 
-There is a mechanism to re-build and test with a number of installed node
-versions. First you must create "test/node.paths" (based on
-"test/node.paths.example") and then:
+- The usual `MANTA_USER`, `MANTA_URL`, `MANTA_KEY_ID` and other vars apply
+  for integration tests.
 
-    make testall
+- `MANTA_TEST_ROLE` is used for some tests that need an RBAC subrole. Those
+  tests are skipped if this isn't set.
+
+- `TEST_LOG_LEVEL=<bunyan log level name>` - This can be used to get debug and
+  trace-level logging of test code. This intentionally avoids using `LOG_LEVEL`
+  which is used by the `m*` tools. E.g.: use the following to run one test
+  file at a time and get rendered trace logging
+
+        make test TEST_LOG_LEVEL=trace TEST_JOBS=1 2> >(bunyan)
+
+- `TEST_FILTER=<grep pattern for test file paths>` - By default all "\*.test.js"
+  in the "test/unit/" and "test/integration" dirs are run. To run just
+  those with "image" in the name, use `make test TEST_FILTER=image`.
+
+- `TEST_JOBS=<number of test files to run concurrently>` - By default this is
+  10. Set to 1 to run tests serially.
+
+- `TEST_TIMEOUT_S=<number of seconds timeout for each test file>` - By default
+  this is 1200 (10 minutes). Ideally tests are written to take much less than
+  10 minutes.
+
+- `TAP=1` to have the test suite emit TAP output. This is a node-tap envvar.
+
+
+## Testing Development Guide
+
+- Unit tests (i.e. not requiring the cloudapi endpoint) in "unit/\*.test.js".
+  Integration tests "integration/\*.test.js".
+
+- We are using node-tap. Read [RFD
+  139](https://github.com/joyent/rfd/blob/master/rfd/0139/README.md#guidelines-for-using-node-tap-in-triton-repos)
+  for some guidelines for node-tap usage. The more common we can make some
+  basic usage patterns in the many Triton repos, the easier the maintenance.
+
+- Node-tap supports running test files in parallel, and `make test` by
+  default runs tests in parallel. Therefore:
+    - Ensure that test files do not depend on each other and can run
+      concurrently.
+    - Prefer more and smaller and more targetted test files.
 
 
 # License
@@ -190,10 +234,12 @@ OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
 ```
 
+
 # Bugs
 
 See https://github.com/joyent/node-manta/issues.
 
+
 # Release process
 
 Here is how to cut a release:
diff --git a/package.json b/package.json
index 911a3eb..b28255c 100644
--- a/package.json
+++ b/package.json
@@ -39,7 +39,8 @@
     },
     "devDependencies": {
         "forkexec": "^1.0.0",
-        "nodeunit": "^0.11.3"
+        "semver": "^6.3.0",
+        "tap": "^12.7.0"
     },
     "directories": {
         "bin": "./bin",
@@ -49,8 +50,5 @@
     "engines": {
         "node": ">=0.10"
     },
-    "scripts": {
-        "test": "./node_modules/.bin/nodeunit test/*.test.js"
-    },
     "license": "MIT"
 }
diff --git a/test/integration/client-mpu.test.js b/test/integration/client-mpu.test.js
new file mode 100644
index 0000000..23a8183
--- /dev/null
+++ b/test/integration/client-mpu.test.js
@@ -0,0 +1,343 @@
+/*
+ * Copyright 2019 Joyent, Inc.
+ */
+
+/*
+ * Testing the client MPU-related methods
+ */
+
+var exec = require('child_process').exec;
+var crypto = require('crypto');
+var fs = require('fs');
+
+var jsprim = require('jsprim');
+var libuuid = require('uuid');
+var MemoryStream = require('readable-stream/passthrough.js');
+var test = require('tap').test;
+
+var logging = require('../lib/logging');
+var testutils = require('../lib/utils');
+var manta = require('../../lib');
+
+
+/*
+ * Globals
+ */
+
+var client;
+var log = logging.createLogger();
+
+var ROOT = '/' + (process.env.MANTA_USER || 'admin') + '/stor';
+var UPLOAD1; // committed upload
+var UPLOAD2; // aborted upload
+var PATH1 = ROOT + '/committed-obj';
+var PATH2 = ROOT + '/aborted-obj';
+var PATH3 = ROOT + '/#311-test';
+var ETAGS1 = [];
+
+var testOpts = {
+    skip: !testutils.isMpuEnabledSync(log) &&
+        'this Manta does not support multipart upload (MPU)'
+};
+
+
+/*
+ * Tests
+ */
+
+test('mpu client usage', testOpts, function (suite) {
+
+    suite.test('setup', function (t) {
+        var url = process.env.MANTA_URL || 'http://localhost:8080';
+        var user = process.env.MANTA_USER || 'admin';
+
+        function createClient(signer) {
+            // `client` is intentionally global.
+            client = manta.createClient({
+                connectTimeout: 1000,
+                log: log,
+                rejectUnauthorized: !process.env.MANTA_TLS_INSECURE,
+                sign: signer,
+                url: url,
+                user: user
+            });
+
+            t.end();
+        }
+
+        if (process.env.MANTA_KEY_ID) {
+            createClient(manta.cliSigner({
+                user: user,
+                keyId: process.env.MANTA_KEY_ID
+            }));
+        } else {
+            var f = process.env.SSH_KEY || process.env.HOME + '/.ssh/id_rsa';
+            var cmd = 'ssh-keygen -l -f ' +
+                f + ' ' +
+                '| awk \'{print $2}\'';
+            fs.readFile(f, 'utf8', function (err, key) {
+                if (err) {
+                    t.error(err);
+                    t.end();
+                    return;
+                }
+
+                exec(cmd, function (err2, stdout, stderr) {
+                    if (err2) {
+                        t.error(err2);
+                        t.end();
+                        return;
+                    }
+                    createClient(manta.privateKeySigner({
+                        key: key,
+                        keyId: stdout.replace('\n', ''),
+                        user: user
+                    }));
+                });
+            });
+        }
+    });
+
+
+    suite.test('create upload', function (t) {
+        var opts = {
+            account: client.user
+        };
+
+        client.createUpload(PATH1, opts, function (err, obj) {
+            t.ifError(err);
+            if (err) {
+                t.end();
+                return;
+            }
+
+            t.ok(obj);
+            t.ok(obj.id);
+            UPLOAD1 = obj.id;
+            t.end();
+        });
+    });
+
+    suite.test('upload part', function (t) {
+        var text = 'The lazy brown fox \nsomething \nsomething foo';
+        var stream = new MemoryStream();
+        var opts = {
+            account: client.user,
+            md5: crypto.createHash('md5').update(text).digest('base64'),
+            size: Buffer.byteLength(text),
+            type: 'text/plain'
+        };
+
+        var pn = 0;
+        client.uploadPart(stream, UPLOAD1, pn, opts, function (err, res) {
+            t.ifError(err);
+            if (err) {
+                t.end();
+                return;
+            }
+
+            t.ok(res);
+            t.ok(res.headers && res.headers.etag);
+            ETAGS1[pn] = res.headers.etag;
+            t.end();
+        });
+
+        setImmediate(function () {
+            stream.write(text);
+            stream.end();
+        });
+    });
+
+    suite.test('get upload', function (t) {
+        var opts = {
+            account: client.user
+        };
+
+        client.getUpload(UPLOAD1, opts, function (err, upload) {
+            t.ifError(err);
+            if (err) {
+                t.end();
+                return;
+            }
+
+            t.ok(upload);
+            t.equal(upload.id, UPLOAD1);
+            t.equal(upload.state, 'created');
+            t.end();
+        });
+    });
+
+    suite.test('commit upload', function (t) {
+        var opts = {
+            account: client.user
+        };
+
+        client.commitUpload(UPLOAD1, ETAGS1, opts, function (err, res) {
+            t.ifError(err);
+            if (err) {
+                t.end();
+                return;
+            }
+            t.ok(res);
+            t.equal(res.statusCode, 201);
+            client.getUpload(UPLOAD1, opts, function (err2, upload) {
+                t.ifError(err2);
+                if (err2) {
+                    t.end();
+                    return;
+                }
+                t.ok(upload);
+                t.equal(upload.id, UPLOAD1);
+                t.equal(upload.state, 'done');
+                t.equal(upload.result, 'committed');
+
+                client.get(PATH1, function (err3, stream) {
+                    t.ifError(err3);
+                    if (err3) {
+                        t.end();
+                        return;
+                    }
+
+                    var text = 'The lazy brown fox \nsomething \nsomething foo';
+                    var data = '';
+                    stream.setEncoding('utf8');
+                    stream.on('data', function (chunk) {
+                        data += chunk;
+                    });
+                    stream.on('end', function (chunk) {
+                        t.equal(data, text);
+
+                        client.unlink(PATH1, opts, function (err4) {
+                            t.ifError(err4);
+                            t.end();
+                        });
+                    });
+                });
+            });
+        });
+    });
+
+    suite.test('errant commit upload returns undefined res', function (t) {
+        var opts = {
+            account: client.user
+        };
+        client.commitUpload(libuuid.v4(), ETAGS1, opts, function (err, res) {
+            t.ok(err);
+            t.ok(res === undefined);
+            t.end();
+        });
+    });
+
+    suite.test('abort upload', function (t) {
+        var opts = {
+            account: client.user
+        };
+
+        client.createUpload(PATH2, opts, function (err, obj) {
+            t.ifError(err);
+            if (err) {
+                t.end();
+                return;
+            }
+
+            t.ok(obj);
+            t.ok(obj.id);
+            UPLOAD2 = obj.id;
+
+            client.abortUpload(UPLOAD2, opts, function (err2) {
+                t.ifError(err2);
+                if (err2) {
+                    t.end();
+                    return;
+                }
+                client.getUpload(UPLOAD2, opts, function (err3, upload) {
+                    t.ifError(err3);
+                    if (err3) {
+                        t.end();
+                        return;
+                    }
+                    t.ok(upload);
+                    t.equal(upload.id, UPLOAD2);
+                    t.equal(upload.state, 'done');
+                    t.equal(upload.result, 'aborted');
+
+                    t.end();
+                });
+            });
+        });
+    });
+
+    suite.test('#311: create upload with special headers', function (t) {
+        /*
+         * Test adding some headers to the target object that are also parsed by
+         * the Manta client, to ensure the headers for the target object are
+         * sent in the body of the `mpu-create` request, not as headers on the
+         * request itself.
+         */
+        var headers = {
+            'accept':  'acceptstring',
+            'role': 'rolestring',
+            'content-length': 10,
+            'content-md5': 'md5string',
+            'content-type': 'text/plain',
+            'expect': '100-continue',
+            'location': 'locationstring',
+            'x-request-id': 'requestidstring'
+        };
+
+        var createOpts = {
+            account: client.user,
+            headers: headers
+        };
+
+        client.createUpload(PATH3, createOpts, function (err, obj) {
+            t.ifError(err);
+            if (err) {
+                t.end();
+                return;
+            }
+
+            t.ok(obj);
+            t.ok(obj.id);
+            var id = obj.id;
+
+            var getOpts = {
+                account: client.user
+            };
+            client.getUpload(id, getOpts, function (err2, upload) {
+                t.ifError(err2);
+                if (err2) {
+                    t.end();
+                    return;
+                }
+
+                t.ok(upload);
+                t.equal(upload.id, id);
+                t.ok(upload.headers);
+                t.ok(jsprim.deepEqual(headers, upload.headers));
+
+                var abortOpts = {
+                    account: client.user
+                };
+                client.abortUpload(id, abortOpts, function (err3) {
+                    t.ifError(err3);
+                    if (err3) {
+                        t.end();
+                        return;
+                    }
+                    t.end();
+                });
+            });
+        });
+    });
+
+    suite.test('teardown', function (t) {
+        if (client) {
+            client.close();
+            client = null;
+        }
+        t.end();
+    });
+
+    suite.end();
+});
diff --git a/test/client.test.js b/test/integration/client.test.js
similarity index 54%
rename from test/client.test.js
rename to test/integration/client.test.js
index 28955a6..1cbec84 100644
--- a/test/client.test.js
+++ b/test/integration/client.test.js
@@ -1,26 +1,24 @@
 /*
- * Copyright 2016 Joyent, Inc.
+ * Copyright 2019 Joyent, Inc.
  */
 
 var exec = require('child_process').exec;
-var crypto = require('crypto');
 var fs = require('fs');
 var path = require('path');
 
-var bunyan = require('bunyan');
-var jsprim = require('jsprim');
 var libuuid = require('uuid');
 var MemoryStream = require('readable-stream/passthrough.js');
-var verror = require('verror');
+var test = require('tap').test;
 
-var logging = require('./lib/logging');
-var manta = require('../lib');
+var logging = require('../lib/logging');
+var manta = require('../../lib');
 
 
 /*
  * Globals
  */
 
+var client;
 var log = logging.createLogger();
 
 var JOB;
@@ -33,38 +31,22 @@ var CHILD2 = SUBDIR2 + '/child2-' + libuuid.v4().split('-')[0]; // link
 var NOENTSUB1 = SUBDIR1 + '/a/b/c';
 var NOENTSUB2 = SUBDIR1 + '/d/e/f';
 var SPECIALOBJ1 = SUBDIR1 + '/' + 'before-\r-after';
-var MPU_ENABLED;
-var UPLOAD1; // committed upload
-var UPLOAD2; // aborted upload
-var PATH1 = ROOT + '/committed-obj';
-var PATH2 = ROOT + '/aborted-obj';
-var PATH3 = ROOT + '/#311-test';
-var ETAGS1 = [];
 
 var SUBDIR1_NOBJECTS = 1;
 var SUBDIR1_NDIRECTORIES = 2;
 
 
 /*
- * Helper functions
- */
-
-function test(name, testfunc) {
-    module.exports[name] = testfunc;
-}
-
-
-/*
- * Pre- and Post-test actions
+ * Tests
  */
 
-module.exports.setUp = function (cb) {
-    var self = this;
+test('setup', function (t) {
     var url = process.env.MANTA_URL || 'http://localhost:8080';
     var user = process.env.MANTA_USER || 'admin';
 
     function createClient(signer) {
-        self.client = manta.createClient({
+        // `client` is intentionally global.
+        client = manta.createClient({
             connectTimeout: 1000,
             log: log,
             rejectUnauthorized: (process.env.MANTA_TLS_INSECURE ? false : true),
@@ -73,7 +55,7 @@ module.exports.setUp = function (cb) {
             user: user
         });
 
-        cb();
+        t.end();
     }
 
     if (process.env.MANTA_KEY_ID) {
@@ -88,13 +70,15 @@ module.exports.setUp = function (cb) {
             '| awk \'{print $2}\'';
         fs.readFile(f, 'utf8', function (err, key) {
             if (err) {
-                cb(err);
+                t.error(err);
+                t.end();
                 return;
             }
 
             exec(cmd, function (err2, stdout, stderr) {
                 if (err2) {
-                    (cb(err2));
+                    t.error(err2);
+                    t.end();
                     return;
                 }
                 createClient(manta.privateKeySigner({
@@ -102,39 +86,24 @@ module.exports.setUp = function (cb) {
                     keyId: stdout.replace('\n', ''),
                     user: user
                 }));
-                return;
             });
-            return;
         });
     }
-};
-
-
-module.exports.tearDown = function (cb) {
-    if (this.client) {
-        this.client.close();
-        delete this.client;
-    }
-    cb();
-};
-
+});
 
-/*
- * Tests
- */
 
 test('mkdir', function (t) {
-    this.client.mkdir(SUBDIR1, function (err) {
+    client.mkdir(SUBDIR1, function (err) {
         t.ifError(err);
-        t.done();
+        t.end();
     });
 });
 
 
 test('mkdir (sub)', function (t) {
-    this.client.mkdir(SUBDIR2, function (err) {
+    client.mkdir(SUBDIR2, function (err) {
         t.ifError(err);
-        t.done();
+        t.end();
     });
 });
 
@@ -144,9 +113,9 @@ test('put', function (t) {
     var size = Buffer.byteLength(text);
     var stream = new MemoryStream();
 
-    this.client.put(CHILD1, stream, {size: size}, function (err) {
+    client.put(CHILD1, stream, {size: size}, function (err) {
         t.ifError(err);
-        t.done();
+        t.end();
     });
 
     process.nextTick(function () {
@@ -161,9 +130,9 @@ test('#231: put (special characters)', function (t) {
     var size = Buffer.byteLength(text);
     var stream = new MemoryStream();
 
-    this.client.put(SPECIALOBJ1, stream, {size: size}, function (err) {
+    client.put(SPECIALOBJ1, stream, {size: size}, function (err) {
         t.ifError(err);
-        t.done();
+        t.end();
     });
 
     process.nextTick(function () {
@@ -173,7 +142,7 @@ test('#231: put (special characters)', function (t) {
 });
 
 test('#231: ls (special characters)', function (t) {
-    this.client.ls(SUBDIR1, function (err, res) {
+    client.ls(SUBDIR1, function (err, res) {
         t.ifError(err);
 
         var found = false;
@@ -184,13 +153,13 @@ test('#231: ls (special characters)', function (t) {
 
         res.on('end', function () {
             t.ok(found);
-            t.done();
+            t.end();
         });
     });
 });
 
 test('#231: get (special characters)', function (t) {
-    this.client.get(SPECIALOBJ1, function (err, stream) {
+    client.get(SPECIALOBJ1, function (err, stream) {
         t.ifError(err);
 
         var data = '';
@@ -200,16 +169,16 @@ test('#231: get (special characters)', function (t) {
         });
         stream.on('end', function (chunk) {
             t.equal(data, 'my filename can mess stuff up\n');
-            t.done();
+            t.end();
         });
     });
 });
 
 
 test('#231: rm (special characters)', function (t) {
-    this.client.unlink(SPECIALOBJ1, function (err) {
+    client.unlink(SPECIALOBJ1, function (err) {
         t.ifError(err);
-        t.done();
+        t.end();
     });
 });
 
@@ -219,21 +188,20 @@ test('chattr', function (t) {
             'm-foo': 'bar'
         }
     };
-    var self = this;
 
-    this.client.info(CHILD1, function (err, info) {
+    client.info(CHILD1, function (err, info) {
         t.ifError(err);
         t.ok(info);
 
         if (!info) {
-            t.done();
+            t.end();
             return;
         }
 
-        self.client.chattr(CHILD1, opts, function onChattr(err1) {
+        client.chattr(CHILD1, opts, function onChattr(err1) {
             t.ok(!err1, 'err1: ' + err1);
 
-            self.client.info(CHILD1, function onInfo(err2, info2) {
+            client.info(CHILD1, function onInfo(err2, info2) {
                 t.ok(!err2, 'err2: ' + err2);
                 t.ok(info2, 'got info2: ' + info2);
                 if (info2) {
@@ -245,7 +213,7 @@ test('chattr', function (t) {
                         'info2.etag is unchanged: before=' + info.etag
                         + ' after=' + info2.etag);
                 }
-                t.done();
+                t.end();
             });
         });
     });
@@ -253,13 +221,12 @@ test('chattr', function (t) {
 
 
 test('put (zero byte streaming)', function (t) {
-    var self = this;
     var stream = fs.createReadStream('/dev/null');
 
     stream.once('open', function () {
-        self.client.put(CHILD1, stream, function (err) {
+        client.put(CHILD1, stream, function (err) {
             t.ifError(err);
-            t.done();
+            t.end();
         });
     });
 });
@@ -270,9 +237,9 @@ test('put without mkdirp', function (t) {
     var size = Buffer.byteLength(text);
     var stream = new MemoryStream();
 
-    this.client.put(NOENTSUB1, stream, { size: size }, function (err) {
+    client.put(NOENTSUB1, stream, { size: size }, function (err) {
         t.ok(err);
-        t.done();
+        t.end();
     });
 
     process.nextTick(function () {
@@ -286,12 +253,12 @@ test('put with mkdirp', function (t) {
     var size = Buffer.byteLength(text);
     var stream = new MemoryStream();
 
-    this.client.put(NOENTSUB2, stream, {
+    client.put(NOENTSUB2, stream, {
         size: size,
         mkdirs: true
     }, function (err) {
         t.ifError(err);
-        t.done();
+        t.end();
     });
 
     process.nextTick(function () {
@@ -301,7 +268,6 @@ test('put with mkdirp', function (t) {
 });
 
 test('streams', function (t) {
-    var client = this.client;
     var stream = new MemoryStream();
     var text = 'The lazy brown fox streamed some text';
     var w = client.createWriteStream(CHILD1, {type: 'text/plain'});
@@ -311,7 +277,7 @@ test('streams', function (t) {
 
     w.once('error', function (err) {
         t.ifError(err);
-        t.done();
+        t.end();
     });
     w.once('close', function (res) {
         t.ok(res);
@@ -328,33 +294,41 @@ test('streams', function (t) {
         r.once('open', function (res2) {
             opened = true;
         });
+        r.once('close', function (res2) {
+            t.equal(res2.statusCode, 200);
+            t.ok(opened);
+        });
         r.once('end', function () {
             t.equal(str, text);
+            t.end();
         });
 
         r.pipe(s);
 
-        r.once('close', function (res2) {
-            t.equal(res2.statusCode, 200);
-            t.ok(opened);
-            t.done();
-        });
     });
 });
 
 
 test('put MD5 mismatch', function (t) {
     var text = 'The lazy brown fox \nsomething \nsomething foo';
+    var buf;
+    // https://nodejs.org/fr/docs/guides/buffer-constructor-deprecation/
+    if (Buffer.from && Buffer.from !== Uint8Array.from) {
+        buf = Buffer.from(text);
+    } else {
+        // Deprecated;
+        buf = new Buffer(text);
+    }
     var size = Buffer.byteLength(text);
     var opts = {
-        md5: new Buffer(text).toString('base64'),
+        md5: buf.toString('base64'),
         size: size
     };
     var stream = new MemoryStream();
 
-    this.client.put(CHILD1, stream, opts, function (err) {
+    client.put(CHILD1, stream, opts, function (err) {
         t.ok(err);
-        t.done();
+        t.end();
     });
 
     process.nextTick(function () {
@@ -373,9 +347,9 @@ test('GH-72 content-length: undefined', function (t) {
     var text = 'The lazy brown fox \nsomething \nsomething foo';
     var stream = new MemoryStream();
 
-    this.client.put(CHILD1, stream, opts, function (err) {
+    client.put(CHILD1, stream, opts, function (err) {
         t.ifError(err);
-        t.done();
+        t.end();
     });
 
     process.nextTick(function () {
@@ -386,11 +360,9 @@ test('GH-72 content-length: undefined', function (t) {
 
 
 test('ls', function (t) {
-    t.expect(3 + 2 * (SUBDIR1_NOBJECTS + SUBDIR1_NDIRECTORIES));
-
     var dirs = 0;
     var objs = 0;
-    this.client.ls(SUBDIR1, function (err, res) {
+    client.ls(SUBDIR1, function (err, res) {
         t.ifError(err);
         res.on('object', function (obj) {
             objs++;
@@ -405,16 +377,14 @@ test('ls', function (t) {
         res.once('end', function () {
             t.equal(objs, SUBDIR1_NOBJECTS);
             t.equal(dirs, SUBDIR1_NDIRECTORIES);
-            t.done();
+            t.end();
         });
     });
 });
 
 
 test('createListStream', function (t) {
-    t.expect(2 + 2 * (SUBDIR1_NOBJECTS + SUBDIR1_NDIRECTORIES));
-
-    var lstr = this.client.createListStream(SUBDIR1);
+    var lstr = client.createListStream(SUBDIR1);
 
     var dirs = 0;
     var objs = 0;
@@ -436,15 +406,15 @@ test('createListStream', function (t) {
     lstr.once('end', function () {
         t.equal(objs, SUBDIR1_NOBJECTS);
         t.equal(dirs, SUBDIR1_NDIRECTORIES);
-        t.done();
+        t.end();
     });
 });
 
 
 test('createListStream (dir only)', function (t) {
-    t.expect(2 * (SUBDIR1_NDIRECTORIES));
+    var numDirs = 0;
 
-    var lstr = this.client.createListStream(SUBDIR1, {
+    var lstr = client.createListStream(SUBDIR1, {
         type: 'directory'
     });
 
@@ -456,18 +426,20 @@ test('createListStream (dir only)', function (t) {
         while ((obj = lstr.read()) !== null) {
             t.ok(obj);
             t.ok(obj.type === 'directory');
+            numDirs++;
         }
     });
     lstr.once('end', function () {
-        t.done();
+        t.equal(numDirs, SUBDIR1_NDIRECTORIES);
+        t.end();
     });
 });
 
 
 test('createListStream (object only)', function (t) {
-    t.expect(2 * (SUBDIR1_NOBJECTS));
+    var numObjs = 0;
 
-    var lstr = this.client.createListStream(SUBDIR1, {
+    var lstr = client.createListStream(SUBDIR1, {
         type: 'object'
     });
 
@@ -479,24 +451,26 @@ test('createListStream (object only)', function (t) {
         while ((obj = lstr.read()) !== null) {
             t.ok(obj);
             t.ok(obj.type === 'object');
+            numObjs++;
         }
     });
     lstr.once('end', function () {
-        t.done();
+        t.equal(numObjs, SUBDIR1_NOBJECTS);
+        t.end();
     });
 });
 
 
 test('ln', function (t) {
-    this.client.ln(CHILD1, CHILD2, function (err) {
+    client.ln(CHILD1, CHILD2, function (err) {
         t.ifError(err);
-        t.done();
+        t.end();
     });
 });
 
 
 test('info (link)', function (t) {
-    this.client.info(CHILD2, function (err, type) {
+    client.info(CHILD2, function (err, type) {
         t.ifError(err);
         t.ok(type);
         if (type) {
@@ -506,23 +480,22 @@ test('info (link)', function (t) {
             t.ok(type.etag);
             t.ok(type.md5);
         }
-        t.done();
+        t.end();
     });
 });
 
 
 test('ftw', function (t) {
     var text = 'The lazy brown fox \nsomething \nsomething foo';
-    var self = this;
     var size = Buffer.byteLength(text);
     var stream = new MemoryStream();
 
-    this.client.mkdirp(SUBDIR2, function (err) {
+    client.mkdirp(SUBDIR2, function (err) {
         t.ifError(err);
-        self.client.put(CHILD1, stream, {size: size}, function (err2) {
+        client.put(CHILD1, stream, {size: size}, function (err2) {
             t.ifError(err);
 
-            self.client.ftw(SUBDIR1, function (err3, res) {
+            client.ftw(SUBDIR1, function (err3, res) {
                 t.ifError(err3);
                 t.ok(res);
 
@@ -540,7 +513,7 @@ test('ftw', function (t) {
 
                 res.once('end', function () {
                     t.equal(count, 2);
-                    t.done();
+                    t.end();
                 });
             });
         });
@@ -556,17 +529,17 @@ test('ftw', function (t) {
 test('create job (simple grep)', function (t) {
     var j = 'grep foo';
 
-    this.client.createJob(j, function (err, job) {
+    client.createJob(j, function (err, job) {
         t.ifError(err);
         t.ok(job);
         JOB = job;
-        t.done();
+        t.end();
     });
 });
 
 
 test('get job', function (t) {
-    this.client.job(JOB, function (err, job) {
+    client.job(JOB, function (err, job) {
         t.ifError(err);
         t.ok(job);
         t.equal(job.id, JOB);
@@ -576,7 +549,7 @@ test('get job', function (t) {
         t.ok(job.phases);
         t.ok(!job.cancelled);
         t.ok(!job.inputDone);
-        t.done();
+        t.end();
     });
 });
 
@@ -587,9 +560,9 @@ test('add input keys', function (t) {
         CHILD2
     ];
 
-    this.client.addJobKey(JOB, keys, function (err) {
+    client.addJobKey(JOB, keys, function (err) {
         t.ifError(err);
-        t.done();
+        t.end();
     });
 });
 
@@ -599,10 +572,10 @@ test('get job input', function (t) {
     function cb(err) {
         t.ifError(err);
         t.equal(keys, 2);
-        t.done();
+        t.end();
     }
 
-    this.client.jobInput(JOB, function (err, res) {
+    client.jobInput(JOB, function (err, res) {
         t.ifError(err);
         t.ok(res);
 
@@ -618,28 +591,27 @@ test('get job input', function (t) {
 
 
 test('end job', function (t) {
-    this.client.endJob(JOB, function (err) {
+    client.endJob(JOB, function (err) {
         t.ifError(err);
-        t.done();
+        t.end();
     });
 });
 
 
 test('wait for job', function (t) {
     var attempts = 1;
-    var client = this.client;
 
     function getState() {
         client.job(JOB, function (err, job) {
             t.ifError(err);
             if (err) {
-                t.done();
+                t.end();
             } else if (job.state === 'done') {
-                t.done();
+                t.end();
             } else {
                 if (++attempts >= 60) {
                     t.ok(!attempts);
-                    t.done();
+                    t.end();
                 } else {
                     setTimeout(getState, 1000);
                 }
@@ -656,10 +628,10 @@ test('get job output', function (t) {
     function cb(err) {
         t.ifError(err);
         t.ok(_keys > 0);
-        t.done();
+        t.end();
     }
 
-    this.client.jobOutput(JOB, function (err, res) {
+    client.jobOutput(JOB, function (err, res) {
         t.ifError(err);
         t.ok(res);
 
@@ -675,20 +647,18 @@ test('get job output', function (t) {
 
 
 test('create and cancel job', function (t) {
-    var self = this;
-
-    this.client.createJob('grep foo', function (err, job) {
+    client.createJob('grep foo', function (err, job) {
         t.ifError(err);
         t.ok(job);
-        self.client.cancelJob(job, function (err2) {
+        client.cancelJob(job, function (err2) {
             t.ifError(err2);
-            self.client.job(job, function (err3, job2) {
+            client.job(job, function (err3, job2) {
                 t.ifError(err3);
                 t.ok(job2);
                 t.ok(job2.cancelled);
                 t.ok(job2.inputDone);
                 // t.equal(job2.state, 'done');
-                t.done();
+                t.end();
             });
         });
     });
@@ -696,328 +666,35 @@ test('create and cancel job', function (t) {
 
 
 test('unlink object', function (t) {
-    this.client.unlink(CHILD2, function (err) {
+    client.unlink(CHILD2, function (err) {
         t.ifError(err);
-        t.done();
+        t.end();
     });
 });
 
 
 test('unlink link', function (t) {
-    this.client.unlink(CHILD1, function (err) {
+    client.unlink(CHILD1, function (err) {
         t.ifError(err);
-        t.done();
+        t.end();
     });
 });
 
 
 test('rmr', function (t) {
-    this.client.rmr(SUBDIR1, function (err) {
+    client.rmr(SUBDIR1, function (err) {
         t.ifError(err);
-        t.done();
+        t.end();
     });
 });
 
 
 test('mkdirp/rmr', function (t) {
-    var self = this;
-    this.client.mkdirp(SUBDIR2, function (err) {
+    client.mkdirp(SUBDIR2, function (err) {
         t.ifError(err);
-        self.client.rmr(SUBDIR1, function (err2) {
+        client.rmr(SUBDIR1, function (err2) {
             t.ifError(err2);
-            t.done();
-        });
-    });
-});
-
-test('create upload', function (t) {
-    var opts = {
-        account: this.client.user
-    };
-
-    this.client.createUpload(PATH1, opts, function (err, obj) {
-        if (err && verror.hasCauseWithName(err, 'FeatureNotSupportedError')) {
-            MPU_ENABLED = false;
-            console.log('WARNING: skipping test "create upload": multipart ' +
-                'upload is not enabled on this Manta deployment');
-            t.done();
-            return;
-        }
-        MPU_ENABLED = true;
-
-        t.ifError(err);
-        if (err) {
-            t.done();
-            return;
-        }
-
-        t.ok(obj);
-        t.ok(obj.id);
-        UPLOAD1 = obj.id;
-        t.done();
-    });
-});
-
-test('upload part', function (t) {
-    if (!MPU_ENABLED) {
-        console.log('WARNING: skipping test "upload part": multipart ' +
-            'upload is not enabled on this Manta deployment');
-        t.done();
-        return;
-    }
-
-    var text = 'The lazy brown fox \nsomething \nsomething foo';
-    var stream = new MemoryStream();
-    var opts = {
-        account: this.client.user,
-        md5: crypto.createHash('md5').update(text).digest('base64'),
-        size: Buffer.byteLength(text),
-        type: 'text/plain'
-    };
-
-    var pn = 0;
-    this.client.uploadPart(stream, UPLOAD1, pn, opts, function (err, res) {
-        t.ifError(err);
-        if (err) {
-            t.done();
-            return;
-        }
-
-        t.ok(res);
-        t.ok(res.headers && res.headers.etag);
-        ETAGS1[pn] = res.headers.etag;
-        t.done();
-    });
-
-    setImmediate(function () {
-        stream.write(text);
-        stream.end();
-    });
-});
-
-test('get upload', function (t) {
-    if (!MPU_ENABLED) {
-        console.log('WARNING: skipping test "get upload": multipart ' +
-            'upload is not enabled on this Manta deployment');
-        t.done();
-        return;
-    }
-
-    var opts = {
-        account: this.client.user
-    };
-
-    this.client.getUpload(UPLOAD1, opts, function (err, upload) {
-        t.ifError(err);
-        if (err) {
-            t.done();
-            return;
-        }
-
-        t.ok(upload);
-        t.equal(upload.id, UPLOAD1);
-        t.equal(upload.state, 'created');
-        t.done();
-    });
-});
-
-test('commit upload', function (t) {
-    if (!MPU_ENABLED) {
-        console.log('WARNING: skipping test "commit upload": multipart ' +
-            'upload is not enabled on this Manta deployment');
-        t.done();
-        return;
-    }
-
-    var opts = {
-        account: this.client.user
-    };
-
-    var self = this;
-    self.client.commitUpload(UPLOAD1, ETAGS1, opts, function (err, res) {
-        t.ifError(err);
-        if (err) {
-            t.done();
-            return;
-        }
-        t.ok(res);
-        t.equal(res.statusCode, 201);
-        self.client.getUpload(UPLOAD1, opts, function (err2, upload) {
-            t.ifError(err2);
-            if (err2) {
-                t.done();
-                return;
-            }
-            t.ok(upload);
-            t.equal(upload.id, UPLOAD1);
-            t.equal(upload.state, 'done');
-            t.equal(upload.result, 'committed');
-
-            self.client.get(PATH1, function (err3, stream) {
-                t.ifError(err3);
-                if (err3) {
-                    t.done();
-                    return;
-                }
-
-                var text = 'The lazy brown fox \nsomething \nsomething foo';
-                var data = '';
-                stream.setEncoding('utf8');
-                stream.on('data', function (chunk) {
-                    data += chunk;
-                });
-                stream.on('end', function (chunk) {
-                    t.equal(data, text);
-
-                    self.client.unlink(PATH1, opts, function (err4) {
-                        t.ifError(err4);
-                        if (err4) {
-                            t.done();
-                            return;
-                        }
-                        t.done();
-                    });
-                });
-            });
-        });
-    });
-});
-
-test('errant commit upload returns undefined res', function (t) {
-    if (!MPU_ENABLED) {
-        console.log('WARNING: skipping test "commit upload": multipart ' +
-            'upload is not enabled on this Manta deployment');
-        t.done();
-        return;
-    }
-
-    var opts = {
-        account: this.client.user
-    };
-    var self = this;
-    self.client.commitUpload(libuuid.v4(), ETAGS1, opts, function (err, res) {
-        t.ok(err);
-        t.ok(res === undefined);
-        t.done();
-    });
-});
-
-test('abort upload', function (t) {
-    if (!MPU_ENABLED) {
-        console.log('WARNING: skipping test "abort upload": multipart ' +
-            'upload is not enabled on this Manta deployment');
-        t.done();
-        return;
-    }
-
-    var opts = {
-        account: this.client.user
-    };
-
-    var self = this;
-    this.client.createUpload(PATH2, opts, function (err, obj) {
-        t.ifError(err);
-        if (err) {
-            t.done();
-            return;
-        }
-
-        t.ok(obj);
-        t.ok(obj.id);
-        UPLOAD2 = obj.id;
-
-        self.client.abortUpload(UPLOAD2, opts, function (err2) {
-            t.ifError(err2);
-            if (err2) {
-                t.done();
-                return;
-            }
-            self.client.getUpload(UPLOAD2, opts, function (err3, upload) {
-                t.ifError(err3);
-                if (err3) {
-                    t.done();
-                    return;
-                }
-                t.ok(upload);
-                t.equal(upload.id, UPLOAD2);
-                t.equal(upload.state, 'done');
-                t.equal(upload.result, 'aborted');
-
-                t.done();
-            });
-        });
-    });
-});
-
-test('#311: create upload with special headers', function (t) {
-    if (!MPU_ENABLED) {
-        console.log('WARNING: skipping test: "#311: create upload with ' +
-            'special headers": multipart upload is not enabled on this ' +
-            'Manta deployment');
-        t.done();
-        return;
-    }
-
-    /*
-     * Test adding some headers to the target object that are also parsed by
-     * the Manta client, to ensure the headers for the target object are sent
-     * in the body of the `mpu-create` request, not as headers on the request
-     * itself.
-     */
-    var headers = {
-        'accept':  'acceptstring',
-        'role': 'rolestring',
-        'content-length': 10,
-        'content-md5': 'md5string',
-        'content-type': 'text/plain',
-        'expect': '100-continue',
-        'location': 'locationstring',
-        'x-request-id': 'requestidstring'
-    };
-
-    var self = this;
-    var createOpts = {
-        account: self.client.user,
-        headers: headers
-    };
-
-    self.client.createUpload(PATH3, createOpts, function (err, obj) {
-        t.ifError(err);
-        if (err) {
-            t.done();
-            return;
-        }
-
-        t.ok(obj);
-        t.ok(obj.id);
-        var id = obj.id;
-
-        var getOpts = {
-            account: self.client.user
-        };
-        self.client.getUpload(id, getOpts, function (err2, upload) {
-            t.ifError(err2);
-            if (err2) {
-                t.done();
-                return;
-            }
-
-            t.ok(upload);
-            t.equal(upload.id, id);
-            t.ok(upload.headers);
-            t.ok(jsprim.deepEqual(headers, upload.headers));
-
-            var abortOpts = {
-                account: self.client.user
-            };
-            self.client.abortUpload(id, abortOpts, function (err3) {
-                t.ifError(err3);
-                if (err3) {
-                    t.done();
-                    return;
-                }
-                t.done();
-            });
+            t.end();
         });
     });
 });
@@ -1025,17 +702,17 @@ test('#311: create upload with special headers', function (t) {
 
 test('GH-196 getPath ~~/', function (t) {
     // confirm that evaluating ~~/ works with and without ENV variables
-    var user = this.client.user;
+    var user = client.user;
     var old = process.env.MANTA_USER;
 
     process.env.MANTA_USER = user;
-    t.equal(decodeURIComponent(this.client.path('~~/')), '/' + user);
+    t.equal(decodeURIComponent(client.path('~~/')), '/' + user);
     delete process.env.MANTA_USER;
-    t.equal(decodeURIComponent(this.client.path('~~/')), '/' + user);
+    t.equal(decodeURIComponent(client.path('~~/')), '/' + user);
     process.env.MANTA_USER = old;
     // The plain export depends on the ENV variable
     t.equal(decodeURIComponent(manta.path('~~/')), '/' + user);
-    t.done();
+    t.end();
 });
 
 
@@ -1052,7 +729,7 @@ test('#180: Invalid key results in no client error', function (t) {
             rejectUnauthorized: (process.env.MANTA_TLS_INSECURE ? false : true)
         });
     });
-    t.done();
+    t.end();
 });
 
 test('MANTA-2812 null signer', function (t) {
@@ -1069,7 +746,7 @@ test('MANTA-2812 null signer', function (t) {
 
         c.ls(PUBLIC, function (err2) {
             t.ifError(err2);
-            t.done();
+            t.end();
         });
     });
 });
@@ -1088,7 +765,16 @@ test('MANTA-2812 undefined signer', function (t) {
 
         c.ls(PUBLIC, function (err2) {
             t.ifError(err2);
-            t.done();
+            t.end();
         });
     });
 });
+
+
+test('teardown', function (t) {
+    if (client) {
+        client.close();
+        client = null;
+    }
+    t.end();
+});
diff --git a/test/corpus/259-emptydir.tar b/test/integration/corpus/259-emptydir.tar
similarity index 100%
rename from test/corpus/259-emptydir.tar
rename to test/integration/corpus/259-emptydir.tar
diff --git a/test/corpus/tar1.tar b/test/integration/corpus/tar1.tar
similarity index 100%
rename from test/corpus/tar1.tar
rename to test/integration/corpus/tar1.tar
diff --git a/test/mchmod.test.js b/test/integration/mchmod.test.js
similarity index 71%
rename from test/mchmod.test.js
rename to test/integration/mchmod.test.js
index 7c53a19..4069b7e 100644
--- a/test/mchmod.test.js
+++ b/test/integration/mchmod.test.js
@@ -11,15 +11,16 @@ var forkExecWait = require('forkexec').forkExecWait;
 var fs = require('fs');
 var libuuid = require('uuid');
 var path = require('path');
+var test = require('tap').test;
 var vasync = require('vasync');
 var sprintf = require('extsprintf').sprintf;
 
-var logging = require('./lib/logging');
+var logging = require('../lib/logging');
 
 
 var log = logging.createLogger();
 
-var BINDIR = path.resolve(__dirname, '../bin');
+var BINDIR = path.resolve(__dirname, '../../bin');
 var MMKDIR = path.resolve(BINDIR, 'mmkdir');
 var MCHMOD = path.resolve(BINDIR, 'mchmod');
 var MPUT = path.resolve(BINDIR, 'mput');
@@ -65,13 +66,13 @@ for (i = 1; i <= 3; i++) {
     });
 }
 
+var testOpts = {
+    skip: !process.env.MANTA_TEST_ROLE && 'MANTA_TEST_ROLE envvar not set'
+};
 
-// ---- helper functions
 
-function test(name, testfunc) {
-    module.exports[name] = testfunc;
-}
 
+// ---- helper functions
 
 function unlinkIfExists(targ) {
     try {
@@ -91,9 +92,9 @@ function unlinkIfExists(targ) {
  * These tests require a role to be configured in triton to work properly so it
  * is condtional upon the user setting MANTA_TEST_ROLE in the environment.
  */
-if (process.env.MANTA_TEST_ROLE) {
+test('mchmod with role-tag', testOpts, function (suite) {
 
-    test('setup: create test tree at ' + TESTDIR, function (t) {
+    suite.test('setup: create test tree at ' + TESTDIR, function (t) {
         var tmpFile = path.join(TMPDIR, 'node-manta-test-tmp-file-'
             + process.pid);
 
@@ -136,11 +137,11 @@ if (process.env.MANTA_TEST_ROLE) {
             }
         }, function (err) {
             t.ifError(err, err);
-            t.done();
+            t.end();
         });
     });
 
-    test('minfo to verify lack of --role-tag header', function (t) {
+    suite.test('minfo to verify lack of --role-tag header', function (t) {
 
         // Expect the role-tag header
         var role = process.env.MANTA_TEST_ROLE;
@@ -153,19 +154,19 @@ if (process.env.MANTA_TEST_ROLE) {
         forkExecWait({
             argv: argv1
         }, function (err, info) {
-               t.ifError(err, err);
+            t.ifError(err, err);
 
-               t.equal(info.stderr, '', 'no stderr');
+            t.equal(info.stderr, '', 'no stderr');
 
-               var headerIndex = info.stdout.indexOf(expectedHeader);
-               t.equal(headerIndex, -1,
-                   'minfo response doe not contain role-tag header');
+            var headerIndex = info.stdout.indexOf(expectedHeader);
+            t.equal(headerIndex, -1,
+                'minfo response does not contain role-tag header');
 
-               t.done();
-           });
+            t.end();
+        });
     });
 
-    test('mchmod to add role-tag', function (t) {
+    suite.test('mchmod to add role-tag', function (t) {
 
         // Expect the role-tag header
         var role = process.env.MANTA_TEST_ROLE;
@@ -186,26 +187,26 @@ if (process.env.MANTA_TEST_ROLE) {
         forkExecWait({
             argv: argv1
         }, function (err, info) {
-               t.ifError(err, err);
+            t.ifError(err, err);
 
-               t.equal(info.stderr, '', 'no stderr');
+            t.equal(info.stderr, '', 'no stderr');
 
-               forkExecWait({
-                   argv: argv2
-               }, function (err2, info2) {
-                      t.ifError(err2, err2);
-                      t.equal(info2.stderr, '', 'no stderr');
+            forkExecWait({
+                argv: argv2
+            }, function (err2, info2) {
+                t.ifError(err2, err2);
+                t.equal(info2.stderr, '', 'no stderr');
 
-                      var headerIndex = info2.stdout.indexOf(expectedHeader);
-                      t.notEqual(headerIndex, -1,
-                          'minfo response contains role-tag header');
+                var headerIndex = info2.stdout.indexOf(expectedHeader);
+                t.notEqual(headerIndex, -1,
+                    'minfo response contains role-tag header');
 
-                      t.done();
-                  });
-           });
+                t.end();
+            });
+        });
     });
 
-    test('mchmod to remove role-tag', function (t) {
+    suite.test('mchmod to remove role-tag', function (t) {
 
         // Expect the role-tag header
         var role = process.env.MANTA_TEST_ROLE;
@@ -226,43 +227,45 @@ if (process.env.MANTA_TEST_ROLE) {
         forkExecWait({
             argv: argv1
         }, function (err, info) {
-               t.ifError(err, err);
+            t.ifError(err, err);
 
-               t.equal(info.stderr, '', 'no stderr');
+            t.equal(info.stderr, '', 'no stderr');
 
-               forkExecWait({
-                   argv: argv2
-               }, function (err2, info2) {
-                      t.ifError(err2, err2);
-                      t.equal(info2.stderr, '', 'no stderr');
+            forkExecWait({
+                argv: argv2
+            }, function (err2, info2) {
+                t.ifError(err2, err2);
+                t.equal(info2.stderr, '', 'no stderr');
 
-                      var headerIndex = info2.stdout.indexOf(expectedHeader);
-                      t.equal(headerIndex, -1,
-                          'minfo response does not contain role-tag header');
+                var headerIndex = info2.stdout.indexOf(expectedHeader);
+                t.equal(headerIndex, -1,
+                    'minfo response does not contain role-tag header');
 
-                      t.done();
-                  });
-           });
+                t.end();
+            });
+        });
     });
 
-    test('cleanup: rm test tree ' + TESTDIR, function (t) {
+    suite.test('cleanup: rm test tree ' + TESTDIR, function (t) {
         // Sanity checks that we don't `mrm -r` a non-test dir.
         assert.ok(TESTDIR);
         assert.ok(TESTDIR.indexOf('node-manta-test') !== -1);
 
         forkExecWait({ argv: [ MRM, '-r', TESTDIR ]}, function (err) {
             t.ifError(err, err);
-            t.done();
+            t.end();
         });
     });
 
 
-    test('cleanup: rm tmp directory ' + TMPDIR, function (t) {
+    suite.test('cleanup: rm tmp directory ' + TMPDIR, function (t) {
         var tmpFile = path.join(TMPDIR, 'node-manta-test-tmp-file-'
             + process.pid);
 
         unlinkIfExists(tmpFile);
 
-        t.done();
+        t.end();
     });
-}
+
+    suite.end();
+});
diff --git a/test/mfind.test.js b/test/integration/mfind.test.js
similarity index 92%
rename from test/mfind.test.js
rename to test/integration/mfind.test.js
index 209c5af..6cf44f0 100644
--- a/test/mfind.test.js
+++ b/test/integration/mfind.test.js
@@ -1,5 +1,5 @@
 /*
- * Copyright 2018 Joyent, Inc.
+ * Copyright 2019 Joyent, Inc.
  */
 
 /*
@@ -12,16 +12,17 @@ var format = require('util').format;
 var fs = require('fs');
 var libuuid = require('uuid');
 var path = require('path');
+var test = require('tap').test;
 var vasync = require('vasync');
 
-var logging = require('./lib/logging');
+var logging = require('../lib/logging');
 
 
 // ---- globals
 
 var log = logging.createLogger();
 
-var BINDIR = path.resolve(__dirname, '../bin');
+var BINDIR = path.resolve(__dirname, '../../bin');
 var MFIND = path.resolve(BINDIR, 'mfind');
 var MMKDIR = path.resolve(BINDIR, 'mmkdir');
 var MPUT = path.resolve(BINDIR, 'mput');
@@ -53,13 +54,6 @@ var TESTTREE = [
 ];
 
 
-// ---- helper functions
-
-function test(name, testfunc) {
-    module.exports[name] = testfunc;
-}
-
-
 // ---- tests
 
 test('setup: create test tree at ' + TESTDIR, function (t) {
@@ -93,7 +87,7 @@ test('setup: create test tree at ' + TESTDIR, function (t) {
         }
     }, function (err) {
         t.ifError(err, err);
-        t.done();
+        t.end();
     });
 });
 
@@ -107,7 +101,7 @@ test('check if operator (mfind forbidden)', function (t) {
         } else {
             OPER = true;
         }
-        t.done();
+        t.end();
     });
 });
 
@@ -120,7 +114,7 @@ test('mfind (no arguments)', function (t) {
     }, function (err, info) {
         t.ok(err, 'mfind should fail');
         t.ok(/^path required/m.test(info.stderr), 'path required in stderr');
-        t.done();
+        t.end();
     });
 });
 
@@ -132,7 +126,7 @@ test('mfind TESTDIR', function (t) {
         t.ok(/afile.txt$/m.test(info.stdout), 'afile.txt in stdout');
         t.ok(/adir$/m.test(info.stdout), 'adir in stdout');
         t.ok(/adir\/bfile.txt$/m.test(info.stdout), 'adir/bfile.txt in stdout');
-        t.done();
+        t.end();
     });
 });
 
@@ -145,7 +139,7 @@ test('mfind TESTDIR TESTDIR (same argument multiple times)', function (t) {
         argv: [MFIND, TESTDIR, TESTDIR]
     }, function (err, info) {
         t.ifError(err, err);
-        t.done();
+        t.end();
     });
 });
 
@@ -171,7 +165,7 @@ test('mfind -j TESTDIR', function (t) {
         t.equal(typeof (hit['parent']), 'string',
             'have "parent" (string) field');
         t.equal(typeof (hit['depth']), 'number', 'have "depth" (string) field');
-        t.done();
+        t.end();
     });
 });
 
@@ -181,7 +175,7 @@ test('mfind TESTDIR/afile.txt', function (t) {
     }, function (err, info) {
         t.ifError(err, err);
         t.ok(/afile.txt$/m.test(info.stdout), 'afile.txt in stdout');
-        t.done();
+        t.end();
     });
 });
 
@@ -193,7 +187,7 @@ test('mfind TESTDIR/notafile.txt', function (t) {
         t.equal(info.status, 1);
         t.ok(/notafile\.txt/m.test(info.stderr), 'notafile.txt in stderr');
         t.ok(/NotFound/m.test(info.stderr), 'NotFound in stderr');
-        t.done();
+        t.end();
     });
 });
 
@@ -206,15 +200,16 @@ test('mfind TESTDIR/notafile.txt TESTDIR/afile.txt', function (t) {
         t.ok(/afile.txt$/m.test(info.stdout), 'afile.txt in stdout');
         t.ok(/notafile\.txt/m.test(info.stderr), 'notafile.txt in stderr');
         t.ok(/NotFound/m.test(info.stderr), 'NotFound in stderr');
-        t.done();
+        t.end();
     });
 });
 
 test('mfind /poseidon/stor TESTDIR/afile.txt', function (t) {
     if (OPER === true) {
-        console.log('WARNING: skipping mfind forbidden test: user is an ' +
-            'operator');
-        t.done();
+        t.ok(true, 'mfind forbidden test', {
+            skip: 'MANTA_USER=' + process.env.MANTA_USER + ' is an operator'
+        });
+        t.end();
         return;
     }
     forkExecWait({
@@ -226,7 +221,7 @@ test('mfind /poseidon/stor TESTDIR/afile.txt', function (t) {
         /* t.ok(!/afile.txt$/m.test(info.stdout), 'afile.txt in stdout'); */
         t.ok(/poseidon\/stor/m.test(info.stderr), 'poseidon/stor in stderr');
         t.ok(/Forbidden/m.test(info.stderr), 'Forbidden in stderr');
-        t.done();
+        t.end();
     });
 });
 
@@ -237,6 +232,6 @@ test('cleanup: rm test tree ' + TESTDIR, function (t) {
 
     forkExecWait({argv: [MRM, '-r', TESTDIR]}, function (err) {
         t.ifError(err, err);
-        t.done();
+        t.end();
     });
 });
diff --git a/test/mget.test.js b/test/integration/mget.test.js
similarity index 96%
rename from test/mget.test.js
rename to test/integration/mget.test.js
index bebdf77..5326295 100644
--- a/test/mget.test.js
+++ b/test/integration/mget.test.js
@@ -1,5 +1,5 @@
 /*
- * Copyright 2018 Joyent, Inc.
+ * Copyright 2019 Joyent, Inc.
  */
 
 /*
@@ -11,15 +11,16 @@ var forkExecWait = require('forkexec').forkExecWait;
 var fs = require('fs');
 var libuuid = require('uuid');
 var path = require('path');
+var test = require('tap').test;
 var vasync = require('vasync');
 var sprintf = require('extsprintf').sprintf;
 
-var logging = require('./lib/logging');
+var logging = require('../lib/logging');
 
 
 var log = logging.createLogger();
 
-var BINDIR = path.resolve(__dirname, '../bin');
+var BINDIR = path.resolve(__dirname, '../../bin');
 var MGET = path.resolve(BINDIR, 'mget');
 var MMKDIR = path.resolve(BINDIR, 'mmkdir');
 var MPUT = path.resolve(BINDIR, 'mput');
@@ -66,10 +67,6 @@ for (i = 1; i <= 3; i++) {
 
 // ---- helper functions
 
-function test(name, testfunc) {
-    module.exports[name] = testfunc;
-}
-
 function unlinkIfExists(targ) {
     try {
         fs.unlinkSync(targ);
@@ -125,7 +122,7 @@ test('setup: create test tree at ' + TESTDIR, function (t) {
         }
     }, function (err) {
         t.ifError(err, err);
-        t.done();
+        t.end();
     });
 });
 
@@ -155,7 +152,7 @@ test('mget TESTDIR/02.data', function (t) {
         t.equal(info.stderr, '', 'no stderr');
         t.equal(info.stdout, expected, 'stdout from mget');
 
-        t.done();
+        t.end();
     });
 });
 
@@ -187,7 +184,7 @@ test('mget TESTDIR/01.data TESTDIR/02.data TESTDIR/03.data', function (t) {
         t.equal(info.stderr, '', 'no stderr');
         t.equal(info.stdout, expected, 'stdout from mget');
 
-        t.done();
+        t.end();
     });
 });
 
@@ -224,7 +221,7 @@ test('mget TESTDIR/01.txt TESTDIR/02.txt TESTDIR/03.txt', function (t) {
         t.equal(info.stderr, '', 'no stderr');
         t.equal(info.stdout, expected, 'stdout from mget');
 
-        t.done();
+        t.end();
     });
 });
 
@@ -272,7 +269,7 @@ test('mget -o TMPFILE TESTDIR/01.txt TESTDIR/02.txt TESTDIR/03.txt',
 
         unlinkIfExists(tmpFile);
 
-        t.done();
+        t.end();
     });
 });
 
@@ -311,7 +308,7 @@ test('mget -O TESTDIR/01.txt',
 
         unlinkIfExists(file);
 
-        t.done();
+        t.end();
     });
 });
 
@@ -353,7 +350,7 @@ test('mget TESTDIR/01.txt TESTDIR/02.txt TESTDIR/XX.txt TESTDIR/03.txt',
         t.ok(info.stderr.match(/^mget: ResourceNotFoundError/, 'stderr'));
         t.equal(info.stdout, expected, 'expected stdout');
 
-        t.done();
+        t.end();
     });
 });
 
@@ -403,7 +400,7 @@ test('mget -o TMPFILE TESTDIR/01.txt TESTDIR/02.txt TESTDIR/XX.txt ' +
 
         unlinkIfExists(tmpFile);
 
-        t.done();
+        t.end();
     });
 });
 
@@ -415,6 +412,6 @@ test('cleanup: rm test tree ' + TESTDIR, function (t) {
 
     forkExecWait({ argv: [ MRM, '-r', TESTDIR ]}, function (err) {
         t.ifError(err, err);
-        t.done();
+        t.end();
     });
 });
diff --git a/test/mjob-simple.test.js b/test/integration/mjob-simple.test.js
similarity index 89%
rename from test/mjob-simple.test.js
rename to test/integration/mjob-simple.test.js
index e236a82..698cfc3 100644
--- a/test/mjob-simple.test.js
+++ b/test/integration/mjob-simple.test.js
@@ -1,5 +1,5 @@
 /*
- * Copyright 2016 Joyent, Inc.
+ * Copyright 2019 Joyent, Inc.
  */
 
 /*
@@ -11,22 +11,19 @@
 var assert = require('assert-plus');
 var path = require('path');
 var spawn = require('child_process').spawn;
+var test = require('tap').test;
 
-var logging = require('./lib/logging');
+var logging = require('../lib/logging');
 
 
 // ---- globals
 
 var log = logging.createLogger();
-var MJOB = path.resolve(__dirname, '../bin/mjob');
+var MJOB = path.resolve(__dirname, '../../bin/mjob');
 
 
 // ---- helper functions
 
-function test(name, testfunc) {
-    module.exports[name] = testfunc;
-}
-
 /*
  * For some reason that I don't want to chase right now, running the following
  * hangs:
@@ -77,6 +74,6 @@ test('mjob create --close -or "echo hello"', function (t) {
         t.ifError(err, err);
         t.equal(stderr, '', 'stderr is empty: ' + stderr);
         t.equal(stdout, 'hello\n', 'stdout mismatch');
-        t.done();
+        t.end();
     });
 });
diff --git a/test/mln.test.js b/test/integration/mln.test.js
similarity index 95%
rename from test/mln.test.js
rename to test/integration/mln.test.js
index e12c5a6..ebb66ab 100644
--- a/test/mln.test.js
+++ b/test/integration/mln.test.js
@@ -1,5 +1,5 @@
 /*
- * Copyright 2017 Joyent, Inc.
+ * Copyright 2019 Joyent, Inc.
  */
 
 /*
@@ -11,15 +11,16 @@ var forkExecWait = require('forkexec').forkExecWait;
 var fs = require('fs');
 var libuuid = require('uuid');
 var path = require('path');
+var test = require('tap').test;
 var vasync = require('vasync');
 var sprintf = require('extsprintf').sprintf;
 
-var logging = require('./lib/logging');
+var logging = require('../lib/logging');
 
 
 var log = logging.createLogger();
 
-var BINDIR = path.resolve(__dirname, '../bin');
+var BINDIR = path.resolve(__dirname, '../../bin');
 var MGET = path.resolve(BINDIR, 'mget');
 var MMKDIR = path.resolve(BINDIR, 'mmkdir');
 var MPUT = path.resolve(BINDIR, 'mput');
@@ -69,11 +70,6 @@ for (i = 1; i <= 3; i++) {
 
 // ---- helper functions
 
-function test(name, testfunc) {
-    module.exports[name] = testfunc;
-}
-
-
 function unlinkIfExists(targ) {
     try {
         fs.unlinkSync(targ);
@@ -129,7 +125,7 @@ test('setup: create test tree at ' + TESTDIR, function (t) {
         }
     }, function (err) {
         t.ifError(err, err);
-        t.done();
+        t.end();
     });
 });
 
@@ -171,7 +167,7 @@ test('mln ', function (t) {
                       t.equal(info3.stderr, '', 'no stderr');
 
                       t.equal(info2.stdout, info3.stdout, 'stdout from mget');
-                      t.done();
+                      t.end();
                   });
            });
     });
@@ -221,7 +217,7 @@ if (process.env.MANTA_TEST_ROLE) {
                       t.notEqual(headerIndex, -1,
                           'minfo response contains header');
 
-                      t.done();
+                      t.end();
                   });
            });
     });
@@ -235,7 +231,7 @@ test('cleanup: rm test tree ' + TESTDIR, function (t) {
 
     forkExecWait({ argv: [ MRM, '-r', TESTDIR ]}, function (err) {
         t.ifError(err, err);
-        t.done();
+        t.end();
     });
 });
 
@@ -245,5 +241,5 @@ test('cleanup: rm tmp directory ' + TMPDIR, function (t) {
 
     unlinkIfExists(tmpFile);
 
-    t.done();
+    t.end();
 });
diff --git a/test/mmkdir.test.js b/test/integration/mmkdir.test.js
similarity index 62%
rename from test/mmkdir.test.js
rename to test/integration/mmkdir.test.js
index 7651918..c82f19b 100644
--- a/test/mmkdir.test.js
+++ b/test/integration/mmkdir.test.js
@@ -1,5 +1,5 @@
 /*
- * Copyright 2018 Joyent, Inc.
+ * Copyright 2019 Joyent, Inc.
  */
 
 /*
@@ -11,15 +11,16 @@ var forkExecWait = require('forkexec').forkExecWait;
 var fs = require('fs');
 var libuuid = require('uuid');
 var path = require('path');
+var test = require('tap').test;
 var vasync = require('vasync');
 var sprintf = require('extsprintf').sprintf;
 
-var logging = require('./lib/logging');
+var logging = require('../lib/logging');
 
 
 var log = logging.createLogger();
 
-var BINDIR = path.resolve(__dirname, '../bin');
+var BINDIR = path.resolve(__dirname, '../../bin');
 var MMKDIR = path.resolve(BINDIR, 'mmkdir');
 var MRM = path.resolve(BINDIR, 'mrm');
 var MINFO = path.resolve(BINDIR, 'minfo');
@@ -28,13 +29,9 @@ var TESTDIR = sprintf('/%s/stor/node-manta-test-mput-%s',
     process.env.MANTA_USER || 'admin',
     libuuid.v4().split('-')[0]);
 
-
-
-// ---- helper functions
-
-function test(name, testfunc) {
-    module.exports[name] = testfunc;
-}
+var testOpts = {
+    skip: !process.env.MANTA_TEST_ROLE && 'MANTA_TEST_ROLE envvar not set'
+};
 
 
 // ---- tests
@@ -46,8 +43,8 @@ function test(name, testfunc) {
  * a role to be configured in triton to work properly so it is condtional
  * upon the user setting MANTA_TEST_ROLE in the environment.
  */
-if (process.env.MANTA_TEST_ROLE) {
-    test('mmkdir with --role-tag option', function (t) {
+test('mmkdir with role-tag', testOpts, function (suite) {
+    suite.test('mmkdir with --role-tag option', function (t) {
         // Expect the role-tag header
         var role = process.env.MANTA_TEST_ROLE;
         var expectedHeader = 'role-tag: ' + role;
@@ -67,33 +64,35 @@ if (process.env.MANTA_TEST_ROLE) {
         forkExecWait({
             argv: argv1
         }, function (err, info) {
-               t.ifError(err, err);
+            t.ifError(err, err);
 
-               t.equal(info.stderr, '', 'no stderr');
+            t.equal(info.stderr, '', 'no stderr');
 
-               forkExecWait({
-                   argv: argv2
-               }, function (err2, info2) {
-                      t.ifError(err2, err2);
-                      t.equal(info2.stderr, '', 'no stderr');
+            forkExecWait({
+                argv: argv2
+            }, function (err2, info2) {
+                t.ifError(err2, err2);
+                t.equal(info2.stderr, '', 'no stderr');
 
-                      var headerIndex = info2.stdout.indexOf(expectedHeader);
-                      t.notEqual(headerIndex, -1,
-                          'minfo response contains header');
+                var headerIndex = info2.stdout.indexOf(expectedHeader);
+                t.notEqual(headerIndex, -1,
+                    'minfo response contains header');
 
-                      t.done();
-                  });
-           });
+                t.end();
+            });
+        });
     });
 
-    test('cleanup: rm test directory ' + TESTDIR, function (t) {
+    suite.test('cleanup: rm test directory ' + TESTDIR, function (t) {
         // Sanity checks that we don't `mrm -r` a non-test dir.
         assert.ok(TESTDIR);
         assert.ok(TESTDIR.indexOf('node-manta-test') !== -1);
 
         forkExecWait({ argv: [ MRM, '-r', TESTDIR ]}, function (err) {
             t.ifError(err, err);
-            t.done();
+            t.end();
         });
     });
-}
+
+    suite.end();
+});
diff --git a/test/integration/mmpu.test.js b/test/integration/mmpu.test.js
new file mode 100644
index 0000000..abb073f
--- /dev/null
+++ b/test/integration/mmpu.test.js
@@ -0,0 +1,612 @@
+/*
+ * Copyright 2019 Joyent, Inc.
+ */
+
+/*
+ * Test `mmpu` workflow: create an upload, upload a part, get the upload,
+ * and then commit it. Repeat the same process for abort.
+ *
+ * We also check that the `list` and `parts` subcommands output what we expect
+ * at various points in the process.
+ */
+
+var assert = require('assert-plus');
+var crypto = require('crypto');
+var forkExecWait = require('forkexec').forkExecWait;
+var format = require('util').format;
+var fs = require('fs');
+var libuuid = require('uuid');
+var path = require('path');
+var test = require('tap').test;
+var vasync = require('vasync');
+
+var logging = require('../lib/logging');
+var testutils = require('../lib/utils');
+var manta = require('../../lib');
+
+
+// ---- globals
+
+var log = logging.createLogger();
+
+var MANTA_USER = process.env.MANTA_USER || 'admin';
+
+var BINDIR = path.resolve(__dirname, '../../bin');
+var MGET = path.resolve(BINDIR, 'mget');
+var MMPU = path.resolve(BINDIR, 'mmpu');
+var MRM = path.resolve(BINDIR, 'mrm');
+
+// mmpu subcommands
+var CREATE = 'create';
+var UPLOAD = 'upload';
+var GET = 'get';
+var LIST = 'list';
+var PARTS = 'parts';
+var ABORT = 'abort';
+var COMMIT = 'commit';
+
+// object paths
+var C_OBJ_PATH = format('/%s/stor/node-manta-test-mmpu-%s-commit',
+    MANTA_USER, MANTA_USER);
+var A_OBJ_PATH = format('/%s/stor/node-manta-test-mmpu-%s-abort',
+    MANTA_USER, MANTA_USER);
+
+// upload ids
+var C_ID;
+var A_ID;
+
+// upload paths
+var C_UPLOADPATH;
+var A_UPLOADPATH;
+
+// part etags
+var C_ETAG0;
+var A_ETAG0;
+
+// object to upload
+var TEXT = 'asdfghjk;';
+var TEXT_SIZE = TEXT.length.toString();
+var TEXT_MD5 = crypto.createHash('md5').update(TEXT).digest('base64');
+
+var testOpts = {
+    skip: !testutils.isMpuEnabledSync(log) &&
+        'this Manta does not support multipart upload (MPU)'
+};
+
+
+// ---- tests
+
+test('mmpu', testOpts, function (suite) {
+
+    // Exercise all possible create flags here.
+    suite.test('mmpu create C_OBJ_PATH -c 1 -H m-custom-header:foo ' +
+            '-s TEXT_SIZE -m TEXT_MD5', function (t) {
+        var argv = [
+            MMPU, CREATE, C_OBJ_PATH,
+            '-c', '1',
+            '-H', 'm-custom-header:foo',
+            '-s', TEXT_SIZE,
+            '-m', TEXT_MD5
+        ];
+
+        forkExecWait({
+            argv: argv
+        }, function (err, info) {
+            t.ifError(err, err);
+            if (!err) {
+                t.ok(info);
+                t.ok(info.stdout);
+                C_ID = info.stdout.replace('\n', '');
+            }
+            t.end();
+        });
+    });
+
+    // Get the upload we are going to commit, and verify the attributes match
+    // what was specified on create.
+    suite.test('mmpu get C_ID', function (t) {
+        var argv = [ MMPU, GET, C_ID ];
+
+        forkExecWait({
+            argv: argv
+        }, function (err, info) {
+            t.ifError(err, err);
+            if (!err) {
+                t.ok(info);
+                var upload = JSON.parse(info.stdout);
+                t.ok(upload);
+                if (!upload) {
+                    t.end();
+                    return;
+                }
+
+                var headers = upload.headers;
+                t.ok(headers);
+                if (!headers) {
+                    t.end();
+                    return;
+                }
+
+                t.equal(headers['durability-level'], 1);
+                t.equal(headers['content-length'], Number(TEXT_SIZE));
+                t.equal(headers['content-md5'], TEXT_MD5);
+                t.equal(headers['m-custom-header'], 'foo');
+                t.equal(upload.state, 'created');
+
+                C_UPLOADPATH = upload.partsDirectory;
+            } else {
+                console.log(err);
+                console.log(info.stderr);
+            }
+
+            t.end();
+        });
+    });
+
+
+    // Check that the values specified as flags overwrite the header values.
+    suite.test('mmpu create A_OBJ_PATH -c 1 -s TEXT_SIZE -m TEXT_MD5' +
+            '-H durability-level 3 -H content-length:10 -H content-md5:foo',
+            function (t) {
+        var argv = [
+            MMPU, CREATE, A_OBJ_PATH,
+            '-c', '1',
+            '-s', TEXT_SIZE,
+            '-m', TEXT_MD5,
+            '-H', 'durability-level:3',
+            '-H', 'content-length:10',
+            '-H', 'content-md5:foo'
+        ];
+
+        forkExecWait({
+            argv: argv
+        }, function (err, info) {
+            t.ifError(err, err);
+            if (!err) {
+                t.ok(info);
+                t.ok(info.stdout);
+                A_ID = info.stdout.replace('\n', '');
+            }
+            t.end();
+        });
+    });
+
+
+    // Get the upload we are going to abort, and verify the attributes match
+    // what was specified on create.
+    suite.test('mmpu get A_ID', function (t) {
+        var argv = [ MMPU, GET, A_ID ];
+
+        forkExecWait({
+            argv: argv
+        }, function (err, info) {
+            t.ifError(err, err);
+            if (!err) {
+                t.ok(info);
+                var upload = JSON.parse(info.stdout);
+                t.ok(upload);
+                if (!upload) {
+                    t.end();
+                    return;
+                }
+
+                var headers = upload.headers;
+                if (!headers) {
+                    t.end();
+                    return;
+                }
+
+                t.ok(headers);
+                t.equal(headers['durability-level'], 1);
+                t.equal(headers['content-length'], Number(TEXT_SIZE));
+                t.equal(headers['content-md5'], TEXT_MD5);
+                t.equal(upload.state, 'created');
+
+                A_UPLOADPATH = upload.partsDirectory;
+            } else {
+                console.log(err);
+                console.log(info.stderr);
+            }
+
+            t.end();
+        });
+
+    });
+
+    // Check that no parts have been uploaded for C_ID.
+    suite.test('mmpu parts C_ID: pre-upload', function (t) {
+        var argv = [ MMPU, PARTS, C_ID ];
+
+        forkExecWait({
+            argv: argv
+        }, function (err, info) {
+            t.ifError(err, err);
+            if (!err) {
+                t.equal(info.stdout, '');
+            } else {
+                console.log(err);
+                console.log(info.stderr);
+            }
+
+            t.end();
+        });
+    });
+
+    // Check that no parts have been uploaded for A_ID.
+    suite.test('mmpu parts A_ID: pre-upload', function (t) {
+        var argv = [ MMPU, PARTS, A_ID ];
+
+        forkExecWait({
+            argv: argv
+        }, function (err, info) {
+            t.ifError(err, err);
+            if (!err) {
+                t.equal(info.stdout, '');
+            } else {
+                console.log(err);
+                console.log(info.stderr);
+            }
+
+            t.end();
+        });
+    });
+
+    // Check that we see the new uploads in `mmpu list`.
+    suite.test('mmpu list', function (t) {
+        var argv = [ MMPU, LIST ];
+
+        forkExecWait({
+            argv: argv
+        }, function (err, info) {
+            t.ifError(err, err);
+
+            var cFound, aFound = false;
+
+            if (!err) {
+                var split = info.stdout.split('\n');
+                var c = C_UPLOADPATH;
+                var a = A_UPLOADPATH;
+
+                split.forEach(function (line) {
+                    if (line === c) {
+                        cFound = true;
+                    } else if (line === a) {
+                        aFound = true;
+                    }
+                });
+
+                t.ok(cFound);
+                t.ok(aFound);
+            } else {
+                console.log(err);
+                console.log(info.stderr);
+            }
+
+            t.end();
+        });
+    });
+
+
+    // Upload a part from a file to the commit object.
+    suite.test('mmpu upload C_ID 0 -f tmpFile', function (t) {
+        var tmpFile = '/var/tmp/node-manta-mmpu-test-tmp-file-' + process.pid;
+
+        function mkTmpFile(_, cb) {
+            fs.writeFile(tmpFile, TEXT, cb);
+        }
+
+        function upload(_, cb) {
+            var argv = [ MMPU, UPLOAD, C_ID,
+                '0',
+                '-f', tmpFile
+            ];
+
+            forkExecWait({
+                argv: argv
+            }, function (err, info) {
+                if (err) {
+                    cb(err);
+                } else {
+                     C_ETAG0 = info.stdout.replace('\n', '');
+                     cb();
+                }
+            });
+        }
+
+        function rmTmpFile(_, cb) {
+            fs.unlink(tmpFile, cb);
+        }
+
+        vasync.pipeline({
+            funcs: [
+                mkTmpFile,
+                upload,
+                rmTmpFile
+            ]
+        }, function (err, results) {
+            t.ifError(err, err);
+            t.end();
+        });
+    });
+
+
+    // Upload a part from a stream to the abort object.
+    suite.test('mmpu upload A_ID 0', function (t) {
+        var argv = [ MMPU, UPLOAD, A_ID,
+            '0'
+        ];
+
+        var child = forkExecWait({
+            argv: argv
+        }, function (err, info) {
+            t.ifError(err, err);
+            if (!err) {
+                A_ETAG0 = info.stdout.replace('\n', '');
+            } else {
+                console.log(err);
+                console.log(info.stderr);
+            }
+            t.end();
+        });
+
+        setImmediate(function () {
+            child.stdin.write(TEXT);
+            child.stdin.end();
+        });
+    });
+
+    // Check that one part has been uploaded for C_ID.
+    suite.test('mmpu parts C_ID: post-upload', function (t) {
+        var argv = [ MMPU, PARTS, C_ID ];
+
+        forkExecWait({
+            argv: argv
+        }, function (err, info) {
+            t.ifError(err, err);
+            if (!err) {
+                var expectedStdout = C_UPLOADPATH + '/0\n';
+                t.equal(info.stdout, expectedStdout);
+            } else {
+                console.log(err);
+                console.log(info.stderr);
+            }
+
+            t.end();
+        });
+    });
+
+    // Check that one part has been uploaded for A_ID.
+    suite.test('mmpu parts A_ID: post-upload', function (t) {
+        var argv = [ MMPU, PARTS, A_ID ];
+
+        forkExecWait({
+            argv: argv
+        }, function (err, info) {
+            t.ifError(err, err);
+            if (!err) {
+                var expectedStdout = A_UPLOADPATH + '/0\n';
+                t.equal(info.stdout, expectedStdout);
+            } else {
+                console.log(err);
+                console.log(info.stderr);
+            }
+
+            t.end();
+        });
+    });
+
+
+    // Check that `mmpu list -p` now includes the parts that have been uploaded.
+    suite.test('mmpu list -p', function (t) {
+        var argv = [ MMPU, LIST, '-p' ];
+
+        forkExecWait({
+            argv: argv
+        }, function (err, info) {
+            t.ifError(err, err);
+
+            var c = C_UPLOADPATH;
+            var a = A_UPLOADPATH;
+            var c0 = c + '/0';
+            var a0 = a + '/0';
+
+            var cFound, aFound, c0Found, a0Found = false;
+
+            if (!err) {
+                var split = info.stdout.split('\n');
+                split.forEach(function (line) {
+                    if (line === c) {
+                        cFound = true;
+                    } else if (line === a) {
+                        aFound = true;
+                    } else if (line === c0) {
+                        c0Found = true;
+                    } else if (line === a0) {
+                        a0Found = true;
+                    }
+                });
+
+                t.ok(cFound);
+                t.ok(aFound);
+                t.ok(c0Found);
+                t.ok(a0Found);
+            } else {
+                console.log(err);
+                console.log(info.stderr);
+            }
+
+            t.end();
+        });
+    });
+
+
+    // Check that `mmpu list` (without -p) does not show the parts that have
+    // been uploaded.
+    suite.test('mmpu list: post part upload', function (t) {
+        var argv = [ MMPU, LIST ];
+
+        forkExecWait({
+            argv: argv
+        }, function (err, info) {
+            t.ifError(err, err);
+
+            var c = C_UPLOADPATH;
+            var a = A_UPLOADPATH;
+            var c0 = c + '/0';
+            var a0 = a + '/0';
+
+            var cFound, aFound, c0Found, a0Found = false;
+
+            if (!err) {
+                var split = info.stdout.split('\n');
+                split.forEach(function (line) {
+                    if (line === c) {
+                        cFound = true;
+                    } else if (line === a) {
+                        aFound = true;
+                    } else if (line === c0) {
+                        c0Found = true;
+                    } else if (line === a0) {
+                        a0Found = true;
+                    }
+                });
+
+                t.ok(cFound);
+                t.ok(aFound);
+                t.ok(!c0Found);
+                t.ok(!a0Found);
+            } else {
+                console.log(err);
+                console.log(info.stderr);
+            }
+
+            t.end();
+        });
+    });
+
+
+
+    // Commit the object, do an mget of it to verify it's the object we expect,
+    // and remove it to clean up.
+    suite.test('mmpu commit C_ID C_ETAG0', function (t) {
+        function commit(_, cb) {
+            var argv = [ MMPU, COMMIT, C_ID, C_ETAG0 ];
+
+            forkExecWait({
+                argv: argv
+            }, function (err, info) {
+                if (err) {
+                    cb(err);
+                } else {
+                    cb();
+                }
+            });
+        }
+
+        function checkCommitState(_, cb) {
+            var argv = [ MMPU, GET, C_ID ];
+
+            forkExecWait({
+                argv: argv
+            }, function (err, info) {
+                if (err) {
+                    cb(err);
+                } else {
+                    var upload = JSON.parse(info.stdout);
+                    t.ok(upload.state, 'done');
+                    t.ok(upload.result, 'committed');
+                    cb();
+                }
+            });
+        }
+
+        function getCommitObj(_, cb) {
+            var argv = [ MGET, C_OBJ_PATH ];
+
+            forkExecWait({
+                argv: argv
+            }, function (err, info) {
+                if (err) {
+                    cb(err);
+                } else {
+                    var output = info.stdout.replace('\n', '');
+                    t.equal(TEXT, output);
+                    cb();
+                }
+            });
+        }
+
+        function rmCommitObj(_, cb) {
+            var argv = [ MRM, C_OBJ_PATH ];
+
+            forkExecWait({
+                argv: argv
+            }, function (err, info) {
+                if (err) {
+                    cb(err);
+                } else {
+                     cb();
+                }
+            });
+        }
+
+        vasync.pipeline({
+            funcs: [
+                commit,
+                checkCommitState,
+                getCommitObj,
+                rmCommitObj
+            ]
+        }, function (err, results) {
+            t.ifError(err, err);
+            t.end();
+        });
+    });
+
+
+    // Abort the object being uploaded to A_OBJ_PATH.
+    suite.test('mmpu abort A_ID', function (t) {
+        function abort(_, cb) {
+            var argv = [ MMPU, ABORT, A_ID ];
+
+            forkExecWait({
+                argv: argv
+            }, function (err, info) {
+                if (err) {
+                    cb(err);
+                } else {
+                    cb();
+                }
+            });
+        }
+
+        function checkAbortState(_, cb) {
+            var argv = [ MMPU, GET, A_ID ];
+
+            forkExecWait({
+                argv: argv
+            }, function (err, info) {
+                if (err) {
+                    cb(err);
+                } else {
+                    var upload = JSON.parse(info.stdout);
+                    t.ok(upload.state, 'done');
+                    t.ok(upload.result, 'aborted');
+                    cb();
+                }
+            });
+        }
+
+        vasync.pipeline({
+            funcs: [
+                abort,
+                checkAbortState
+            ]
+        }, function (err, results) {
+            t.ifError(err, err);
+            t.end();
+        });
+    });
+
+    suite.end();
+});
diff --git a/test/mput.test.js b/test/integration/mput.test.js
similarity index 95%
rename from test/mput.test.js
rename to test/integration/mput.test.js
index 76278c6..9c8f37f 100644
--- a/test/mput.test.js
+++ b/test/integration/mput.test.js
@@ -1,5 +1,5 @@
 /*
- * Copyright 2017 Joyent, Inc.
+ * Copyright 2019 Joyent, Inc.
  */
 
 /*
@@ -11,15 +11,16 @@ var forkExecWait = require('forkexec').forkExecWait;
 var fs = require('fs');
 var libuuid = require('uuid');
 var path = require('path');
+var test = require('tap').test;
 var vasync = require('vasync');
 var sprintf = require('extsprintf').sprintf;
 
-var logging = require('./lib/logging');
+var logging = require('../lib/logging');
 
 
 var log = logging.createLogger();
 
-var BINDIR = path.resolve(__dirname, '../bin');
+var BINDIR = path.resolve(__dirname, '../../bin');
 var MGET = path.resolve(BINDIR, 'mget');
 var MMKDIR = path.resolve(BINDIR, 'mmkdir');
 var MPUT = path.resolve(BINDIR, 'mput');
@@ -68,11 +69,6 @@ for (i = 1; i <= 3; i++) {
 
 // ---- helper functions
 
-function test(name, testfunc) {
-    module.exports[name] = testfunc;
-}
-
-
 function unlinkIfExists(targ) {
     try {
         fs.unlinkSync(targ);
@@ -120,7 +116,7 @@ test('setup: create test tree at ' + TESTDIR, function (t) {
         }
     }, function (err) {
         t.ifError(err, err);
-        t.done();
+        t.end();
     });
 });
 
@@ -165,7 +161,7 @@ test('mput with custom header value with colons', function (t) {
             var headerIndex = info2.stdout.indexOf(expectedHeader);
             t.notEqual(headerIndex, -1, 'minfo response contains header');
 
-            t.done();
+            t.end();
         });
     });
 });
@@ -219,7 +215,7 @@ if (process.env.MANTA_TEST_ROLE) {
                       t.notEqual(headerIndex, -1,
                           'minfo response contains header');
 
-                      t.done();
+                      t.end();
                   });
            });
     });
@@ -233,7 +229,7 @@ test('cleanup: rm test tree ' + TESTDIR, function (t) {
 
     forkExecWait({ argv: [ MRM, '-r', TESTDIR ]}, function (err) {
         t.ifError(err, err);
-        t.done();
+        t.end();
     });
 });
 
@@ -243,5 +239,5 @@ test('cleanup: rm tmp directory ' + TMPDIR, function (t) {
 
     unlinkIfExists(tmpFile);
 
-    t.done();
+    t.end();
 });
diff --git a/test/mrm.test.js b/test/integration/mrm.test.js
similarity index 93%
rename from test/mrm.test.js
rename to test/integration/mrm.test.js
index 1cb3988..e4d4641 100644
--- a/test/mrm.test.js
+++ b/test/integration/mrm.test.js
@@ -1,5 +1,5 @@
 /*
- * Copyright 2018 Joyent, Inc.
+ * Copyright 2019 Joyent, Inc.
  */
 
 /*
@@ -11,12 +11,13 @@ var fs = require('fs');
 var forkExecWait = require('forkexec').forkExecWait;
 var libuuid = require('uuid');
 var path = require('path');
+var test = require('tap').test;
 var vasync = require('vasync');
 var sprintf = require('extsprintf').sprintf;
 
-var utils = require('./lib/utils');
+var utils = require('../lib/utils');
 
-var BINDIR = path.resolve(__dirname, '../bin');
+var BINDIR = path.resolve(__dirname, '../../bin');
 var MMKDIR = path.resolve(BINDIR, 'mmkdir');
 var MRM = path.resolve(BINDIR, 'mrm');
 var MPUT = path.resolve(BINDIR, 'mput');
@@ -39,16 +40,13 @@ for (var i = 0; i < NUMSUBDIRS; i++) {
 
 // ---- helper functions
 
-function test(name, testfunc) {
-    module.exports[name] = testfunc;
-}
-
 function safePath(p) {
     assert.string(p);
     assert(p.indexOf('node-manta-test') !== -1);
 }
 
 // ---- tests
+
 test('setup: create test tree at ' + TESTDIR, function (t) {
     vasync.pipeline({funcs: [
         function (_, cb) {
@@ -76,7 +74,7 @@ test('setup: create test tree at ' + TESTDIR, function (t) {
         }
     ]}, function (err) {
         t.ifError(err, err);
-        t.done();
+        t.end();
     });
 });
 
@@ -86,7 +84,7 @@ test('mrm (no arguments)', function (t) {
     }, function (err, info) {
         t.ok(err, 'mrm should fail');
         t.ok(/^path required/m.test(info.stderr), 'path required in stderr');
-        t.done();
+        t.end();
     });
 });
 
@@ -96,7 +94,7 @@ test('mrm -I fails without tty', function (t) {
     }, function (err, info) {
         t.ok(err, 'mrm should fail');
         t.ok(/^stdin must be a tty/m.test(info.stderr), 'stdin must be a tty');
-        t.done();
+        t.end();
     });
 });
 
@@ -109,7 +107,7 @@ test('mrm 1 directory', function (t) {
         argv: [MRM, '-r', p]
     }, function (err) {
         t.ifError(err, err);
-        t.done();
+        t.end();
     });
 });
 
@@ -156,7 +154,7 @@ test('remove remaining directories', function (t) {
         }
     ]}, function (err) {
         t.ifError(err, err);
-        t.done();
+        t.end();
     });
 });
 
@@ -169,7 +167,7 @@ test('mrm 1 object', function (t) {
         argv: [MRM, p]
     }, function (err) {
         t.ifError(err, err);
-        t.done();
+        t.end();
     });
 });
 
@@ -216,7 +214,7 @@ test('remove remaining objects', function (t) {
         }
     ]}, function (err) {
         t.ifError(err, err);
-        t.done();
+        t.end();
     });
 });
 
@@ -224,12 +222,12 @@ test('ensure test tree is empty', function (t) {
     utils.mls(TESTDIR, function (err, list) {
         if (err) {
             t.ifError(err, err);
-            t.done();
+            t.end();
             return;
         }
 
         t.equal(list.length, 0, '0 remaining entities');
-        t.done();
+        t.end();
     });
 });
 
@@ -239,6 +237,6 @@ test('cleanup: rm test tree ' + TESTDIR, function (t) {
 
     forkExecWait({ argv: [MRM, '-r', TESTDIR]}, function (err) {
         t.ifError(err, err);
-        t.done();
+        t.end();
     });
 });
diff --git a/test/mrmdir.test.js b/test/integration/mrmdir.test.js
similarity index 90%
rename from test/mrmdir.test.js
rename to test/integration/mrmdir.test.js
index fb4fc86..f26b542 100644
--- a/test/mrmdir.test.js
+++ b/test/integration/mrmdir.test.js
@@ -1,5 +1,5 @@
 /*
- * Copyright 2018 Joyent, Inc.
+ * Copyright 2019 Joyent, Inc.
  */
 
 /*
@@ -10,12 +10,13 @@ var assert = require('assert-plus');
 var forkExecWait = require('forkexec').forkExecWait;
 var libuuid = require('uuid');
 var path = require('path');
+var test = require('tap').test;
 var vasync = require('vasync');
 var sprintf = require('extsprintf').sprintf;
 
-var utils = require('./lib/utils');
+var utils = require('../lib/utils');
 
-var BINDIR = path.resolve(__dirname, '../bin');
+var BINDIR = path.resolve(__dirname, '../../bin');
 var MMKDIR = path.resolve(BINDIR, 'mmkdir');
 var MRM = path.resolve(BINDIR, 'mrm');
 var MRMDIR = path.resolve(BINDIR, 'mrmdir');
@@ -30,13 +31,9 @@ for (var i = 0; i < NUMSUBDIRS; i++) {
     SUBDIRS.push(path.join(TESTDIR, i.toString()));
 }
 
-// ---- helper functions
-
-function test(name, testfunc) {
-    module.exports[name] = testfunc;
-}
 
 // ---- tests
+
 test('setup: create test tree at ' + TESTDIR, function (t) {
     vasync.pipeline({funcs: [
         function (_, cb) {
@@ -53,7 +50,7 @@ test('setup: create test tree at ' + TESTDIR, function (t) {
         }
     ]}, function (err) {
         t.ifError(err, err);
-        t.done();
+        t.end();
     });
 });
 
@@ -63,7 +60,7 @@ test('mrmdir (no arguments)', function (t) {
     }, function (err, info) {
         t.ok(err, 'mrmdir should fail');
         t.ok(/^path required/m.test(info.stderr), 'path required in stderr');
-        t.done();
+        t.end();
     });
 });
 
@@ -73,7 +70,7 @@ test('mrmdir -I fails without tty', function (t) {
     }, function (err, info) {
         t.ok(err, 'mrmdir should fail');
         t.ok(/^stdin must be a tty/m.test(info.stderr), 'stdin must be a tty');
-        t.done();
+        t.end();
     });
 });
 
@@ -84,7 +81,7 @@ test('mrmdir 1 directory', function (t) {
         argv: [MRMDIR, p]
     }, function (err) {
         t.ifError(err, err);
-        t.done();
+        t.end();
     });
 });
 
@@ -123,7 +120,7 @@ test('remove remaining directories', function (t) {
         }
     ]}, function (err) {
         t.ifError(err, err);
-        t.done();
+        t.end();
     });
 });
 
@@ -131,12 +128,12 @@ test('ensure test tree is empty', function (t) {
     utils.mls(TESTDIR, function (err, list) {
         if (err) {
             t.ifError(err, err);
-            t.done();
+            t.end();
             return;
         }
 
         t.equal(list.length, 0, '0 remaining entities');
-        t.done();
+        t.end();
     });
 });
 
@@ -147,6 +144,6 @@ test('cleanup: rm test tree ' + TESTDIR, function (t) {
 
     forkExecWait({ argv: [MRM, '-r', TESTDIR]}, function (err) {
         t.ifError(err, err);
-        t.done();
+        t.end();
     });
 });
diff --git a/test/msign.test.js b/test/integration/msign.test.js
similarity index 91%
rename from test/msign.test.js
rename to test/integration/msign.test.js
index 730c824..b09a861 100644
--- a/test/msign.test.js
+++ b/test/integration/msign.test.js
@@ -1,5 +1,5 @@
 /*
- * Copyright 2018 Joyent, Inc.
+ * Copyright 2019 Joyent, Inc.
  */
 
 /*
@@ -9,22 +9,18 @@
 var f = require('util').format;
 var forkExecWait = require('forkexec').forkExecWait;
 var path = require('path');
+var test = require('tap').test;
 var url = require('url');
 
+
 // ---- globals
 
-var BINDIR = path.resolve(__dirname, '../bin');
+var BINDIR = path.resolve(__dirname, '../../bin');
 var MSIGN = path.resolve(BINDIR, 'msign');
 
 // This doesn't really matter - msign doesn't check to see if the object exists
 var PATH = '~~/stor/foo';
 
-// ---- helper functions
-
-function test(name, testfunc) {
-    module.exports[name] = testfunc;
-}
-
 
 // ---- tests
 
@@ -34,7 +30,7 @@ test('msign (no arguments)', function (t) {
     }, function (err, info) {
         t.ok(err, 'msign should fail');
         t.ok(/^path required/m.test(info.stderr), 'path required in stderr');
-        t.done();
+        t.end();
     });
 });
 
@@ -61,7 +57,7 @@ test(f('msign %s', PATH), function (t) {
         t.ok(q.expires, 'expires');
         t.ok(q.keyId, 'keyId');
 
-        t.done();
+        t.end();
     });
 });
 
@@ -79,9 +75,9 @@ test(f('msign -e <expires> %s', PATH), function (t) {
         var q = signed.query;
 
         t.ok(q, 'query');
-        t.equal(q.expires, expires, 'expires');
+        t.equal(Number(q.expires), expires, 'expires');
 
-        t.done();
+        t.end();
     });
 });
 
@@ -107,7 +103,7 @@ test(f('msign -E 1h %s', PATH), function (t) {
         t.ok(q.expires >= expires, 'q.expires >= expires');
         t.ok(q.expires < expires + 5, 'q.expires < expires + 5');
 
-        t.done();
+        t.end();
     });
 });
 
@@ -125,7 +121,7 @@ test(f('msign -E 1h %s', PATH), function (t) {
             argv: [MSIGN, '-E', expires, PATH]
         }, function (err, info) {
             t.ifError(err, err);
-            t.done();
+            t.end();
         });
     });
 });
@@ -150,7 +146,7 @@ test(f('msign -E 1h %s', PATH), function (t) {
             t.ok(err, 'msign should fail');
             t.ok(/invalid expires: /m.test(info.stderr),
                 'invalid expires in stderr');
-            t.done();
+            t.end();
         });
     });
 });
@@ -162,6 +158,6 @@ test('msign -E and -e together', function (t) {
         t.ok(err, 'msign should fail');
         t.ok(/-e and -E cannot be specified together/m.test(info.stderr),
             '-e and -E cannot be specified together in stderr');
-        t.done();
+        t.end();
     });
 });
diff --git a/test/muntar.test.js b/test/integration/muntar.test.js
similarity index 84%
rename from test/muntar.test.js
rename to test/integration/muntar.test.js
index 0af51a1..a5741a7 100644
--- a/test/muntar.test.js
+++ b/test/integration/muntar.test.js
@@ -1,5 +1,5 @@
 /*
- * Copyright 2016 Joyent, Inc.
+ * Copyright 2019 Joyent, Inc.
  */
 
 var exec = require('child_process').exec;
@@ -10,16 +10,18 @@ var libuuid = require('uuid');
 var MemoryStream = require('readable-stream/passthrough.js');
 var bunyan = require('bunyan');
 var format = require('util').format;
+var test = require('tap').test;
 var vasync = require('vasync');
 
-var logging = require('./lib/logging');
-var manta = require('../lib');
+var logging = require('../lib/logging');
+var manta = require('../../lib');
 
 
 /*
  * Globals
  */
 
+var client;
 var log = logging.createLogger();
 
 var ROOT = '/' + (process.env.MANTA_USER || 'admin') + '/stor';
@@ -28,26 +30,16 @@ var TSTDIR = ROOT + '/node-manta-test-muntar-' + libuuid.v4().split('-')[0];
 
 
 /*
- * Helper functions
- */
-
-function test(name, testfunc) {
-    module.exports[name] = testfunc;
-}
-
-
-
-/*
- * Pre- and Post-test actions
+ * Tests
  */
 
-module.exports.setUp = function (cb) {
-    var self = this;
+test('setup', function (t) {
     var url = process.env.MANTA_URL || 'http://localhost:8080';
     var user = process.env.MANTA_USER || 'admin';
 
     function createClient(signer) {
-        self.client = manta.createClient({
+        // `client` is intentionally global.
+        client = manta.createClient({
             connectTimeout: 1000,
             log: log,
             rejectUnauthorized: (process.env.MANTA_TLS_INSECURE ?
@@ -57,7 +49,7 @@ module.exports.setUp = function (cb) {
             user: user
         });
 
-        cb();
+        t.end();
     }
 
     if (process.env.MANTA_KEY_ID) {
@@ -72,13 +64,15 @@ module.exports.setUp = function (cb) {
             '| awk \'{print $2}\'';
         fs.readFile(f, 'utf8', function (err, key) {
             if (err) {
-                cb(err);
+                t.error(err);
+                t.end();
                 return;
             }
 
             exec(cmd, function (err2, stdout, stderr) {
                 if (err2) {
-                    (cb(err2));
+                    t.error(err2);
+                    t.end();
                     return;
                 }
                 createClient(manta.privateKeySigner({
@@ -86,28 +80,12 @@ module.exports.setUp = function (cb) {
                     keyId: stdout.replace('\n', ''),
                     user: user
                 }));
-                return;
             });
-            return;
         });
     }
-};
-
-
-module.exports.tearDown = function (cb) {
-    if (this.client) {
-        this.client.close();
-        delete this.client;
-    }
-    cb();
-};
-
+});
 
-/*
- * Tests
- */
 
-// muntar tests
 var cases = [
     {
         tarpath: 'corpus/tar1.tar',
@@ -146,18 +124,17 @@ cases.forEach(function (c, i) {
     }
 
     var name = format('muntar case %d: %s', i, c.tarpath);
-    var cmd = format('%s -f %s %s', path.resolve(__dirname, '../bin/muntar'),
+    var cmd = format('%s -f %s %s', path.resolve(__dirname, '../../bin/muntar'),
         path.resolve(__dirname, c.tarpath), TSTDIR);
     log.debug({caseName: name, cmd: cmd}, 'run case');
 
     test(name, function (t) {
-        var self = this;
         exec(cmd, function (err, stdout, stderr) {
             t.ifError(err);
             vasync.forEachPipeline({
                 func: function checkOne(check, cb) {
                     var mpath = path.join(TSTDIR, check.path);
-                    self.client.info(mpath, function (err2, info) {
+                    client.info(mpath, function (err2, info) {
                         t.ifError(err2, err2);
                         if (!err2) {
                             t.equal(info.type, check.type, format(
@@ -179,11 +156,20 @@ cases.forEach(function (c, i) {
                 },
                 inputs: c.checks
             }, function (err3, results) {
-                self.client.rmr(TSTDIR, function (rmErr) {
+                client.rmr(TSTDIR, function (rmErr) {
                     t.ifError(rmErr, rmErr);
-                    t.done();
+                    t.end();
                 });
             });
         });
     });
 });
+
+
+test('teardown', function (t) {
+    if (client) {
+        client.close();
+        client = null;
+    }
+    t.end();
+});
diff --git a/test/lib/utils.js b/test/lib/utils.js
index cf2658b..57618bb 100644
--- a/test/lib/utils.js
+++ b/test/lib/utils.js
@@ -3,12 +3,17 @@
  */
 
 var assert = require('assert-plus');
+var execFileSync = require('child_process').execFileSync;
+var format = require('util').format;
+var os = require('os');
 var path = require('path');
 
 var forkExecWait = require('forkexec').forkExecWait;
+var VError = require('verror');
 
 var BINDIR = path.resolve(__dirname, '../../bin');
 var MLS = path.resolve(BINDIR, 'mls');
+var MMPU = path.resolve(BINDIR, 'mmpu');
 
 /*
  * Call `mls` on the given path and return a JSON array of objects for each
@@ -46,4 +51,59 @@ function mls(p, cb) {
     });
 }
 
-module.exports.mls = mls;
+
+/*
+ * *Synchronously* determine if this Manta supports MPU (multipart upload).
+ * Doing so synchronously allows one to use the value for tap test() options.
+ *
+ * Limitation: This (a) creates a multipart upload object and (b) uses string
+ * comparison of an error message to determine support. It would be nicer to
+ * have a lighter-weight and crisper mechanism to check for support. Would
+ * the presence of `uploads/` in `mls` output suffice?
+ *
+ * This returns `true` or `false`. If something unexpected happens, it throws
+ * an error.
+ */
+function isMpuEnabledSync(log) {
+    assert.string(process.env.MANTA_USER, 'process.env.MANTA_USER');
+    assert.object(log, 'log');
+
+    var NOT_SUPPORTED_MSG = 'mmpu create: error: multipart upload is ' +
+        'not supported for this Manta deployment';
+
+    var checkPath = format('/%s/stor/node-manta-is-mmpu-enabled-%s',
+        process.env.MANTA_USER, os.hostname());
+    var uploadUuid;
+    try {
+        uploadUuid = execFileSync(MMPU, ['create', checkPath], {
+            stdio: 'pipe', // to not emit stderr to parent's stderr
+            encoding: 'utf8'
+        }).trim();
+    } catch (createErr) {
+        if (createErr.stderr.trim() === NOT_SUPPORTED_MSG) {
+            return (false);
+        } else {
+            throw new VError(createErr,
+                'could not determine whether MPU is supported by this Manta');
+        }
+    }
+    log.trace({uploadUuid: uploadUuid, checkPath: checkPath},
+        'created test MPU upload');
+
+    // If we get here, then MPU is supported. Before returning let's abort
+    // the upload we started.
+    try {
+        execFileSync(MMPU, ['abort', uploadUuid], {encoding: 'utf8'});
+    } catch (abortErr) {
+        log.trace({err: abortErr, uploadUuid: uploadUuid},
+            'silently ignoring attempt to abort test MPU upload');
+    }
+
+    return (true);
+}
+
+
+module.exports = {
+    isMpuEnabledSync: isMpuEnabledSync,
+    mls: mls
+};
diff --git a/test/mmpu.test.js b/test/mmpu.test.js
deleted file mode 100644
index e447a95..0000000
--- a/test/mmpu.test.js
+++ /dev/null
@@ -1,717 +0,0 @@
-/*
- * Copyright 2017 Joyent, Inc.
- */
-
-/*
- * Test `mmpu` workflow: create an upload, upload a part, get the upload,
- * and then commit it. Repeat the same process for abort.
- *
- * We also check that the `list` and `parts` subcommands output what we expect
- * at various points in the process.
- */
-
-var assert = require('assert-plus');
-var crypto = require('crypto');
-var exec = require('child_process').exec;
-var forkExecWait = require('forkexec').forkExecWait;
-var format = require('util').format;
-var fs = require('fs');
-var libuuid = require('uuid');
-var path = require('path');
-var vasync = require('vasync');
-
-var logging = require('./lib/logging');
-var manta = require('../lib');
-
-
-// ---- globals
-
-var log = logging.createLogger();
-
-var MANTA_USER = process.env.MANTA_USER || 'admin';
-
-var BINDIR = path.resolve(__dirname, '../bin');
-var MGET = path.resolve(BINDIR, 'mget');
-var MMPU = path.resolve(BINDIR, 'mmpu');
-var MRM = path.resolve(BINDIR, 'mrm');
-
-var MPU_ENABLED;
-
-// mmpu subcommands
-var CREATE = 'create';
-var UPLOAD = 'upload';
-var GET = 'get';
-var LIST = 'list';
-var PARTS = 'parts';
-var ABORT = 'abort';
-var COMMIT = 'commit';
-
-// object paths
-var C_OBJ_PATH = format('/%s/stor/node-manta-test-mmpu-%s-commit',
-    MANTA_USER, MANTA_USER);
-var A_OBJ_PATH = format('/%s/stor/node-manta-test-mmpu-%s-abort',
-    MANTA_USER, MANTA_USER);
-
-// upload ids
-var C_ID;
-var A_ID;
-
-// upload paths
-var C_UPLOADPATH;
-var A_UPLOADPATH;
-
-// part etags
-var C_ETAG0;
-var A_ETAG0;
-
-// object to upload
-var TEXT = 'asdfghjk;';
-var TEXT_SIZE = TEXT.length.toString();
-var TEXT_MD5 = crypto.createHash('md5').update(TEXT).digest('base64');
-
-
-// ---- helper functions
-
-function test(name, testfunc) {
-    module.exports[name] = testfunc;
-}
-
-
-// ---- tests
-
-// Exercise all possible create flags here.
-test('mmpu create C_OBJ_PATH -c 1 -H m-custom-header:foo -s TEXT_SIZE ' +
-'-m TEXT_MD5', function (t) {
-    var argv = [
-        MMPU, CREATE, C_OBJ_PATH,
-        '-c', '1',
-        '-H', 'm-custom-header:foo',
-        '-s', TEXT_SIZE,
-        '-m', TEXT_MD5
-    ];
-
-    forkExecWait({
-        argv: argv
-    }, function (err, info) {
-        if (err && info.stderr === 'mmpu create: error: multipart upload is ' +
-            'not supported for this Manta deployment\n') {
-            MPU_ENABLED = false;
-            console.log('WARNING: skipping test: multipart ' +
-                'upload is not enabled on this Manta deployment');
-            t.done();
-            return;
-        }
-        MPU_ENABLED = true;
-
-        t.ifError(err, err);
-        if (!err) {
-            t.ok(info);
-            t.ok(info.stdout);
-            C_ID = info.stdout.replace('\n', '');
-        }
-        t.done();
-    });
-});
-
-// Get the upload we are going to commit, and verify the attributes match
-// what was specified on create.
-test('mmpu get C_ID', function (t) {
-    if (!MPU_ENABLED) {
-        console.log('WARNING: skipping test: multipart ' +
-            'upload is not enabled on this Manta deployment');
-        t.done();
-        return;
-    }
-
-    var argv = [ MMPU, GET, C_ID ];
-
-    forkExecWait({
-        argv: argv
-    }, function (err, info) {
-        t.ifError(err, err);
-        if (!err) {
-            t.ok(info);
-            var upload = JSON.parse(info.stdout);
-            t.ok(upload);
-            if (!upload) {
-                t.done();
-                return;
-            }
-
-            var headers = upload.headers;
-            t.ok(headers);
-            if (!headers) {
-                t.done();
-                return;
-            }
-
-            t.equal(headers['durability-level'], 1);
-            t.equal(headers['content-length'], TEXT_SIZE);
-            t.equal(headers['content-md5'], TEXT_MD5);
-            t.equal(headers['m-custom-header'], 'foo');
-            t.equal(upload.state, 'created');
-
-            C_UPLOADPATH = upload.partsDirectory;
-        } else {
-            console.log(err);
-            console.log(info.stderr);
-        }
-
-        t.done();
-    });
-});
-
-
-// Check that the values specified as flags overwrite the header values.
-test('mmpu create A_OBJ_PATH -c 1 -s TEXT_SIZE -m TEXT_MD5' +
-'-H durability-level 3 -H content-length:10 -H content-md5:foo', function (t) {
-    if (!MPU_ENABLED) {
-        console.log('WARNING: skipping test: multipart ' +
-            'upload is not enabled on this Manta deployment');
-        t.done();
-        return;
-    }
-
-    var argv = [
-        MMPU, CREATE, A_OBJ_PATH,
-        '-c', '1',
-        '-s', TEXT_SIZE,
-        '-m', TEXT_MD5,
-        '-H', 'durability-level:3',
-        '-H', 'content-length:10',
-        '-H', 'content-md5:foo'
-    ];
-
-    forkExecWait({
-        argv: argv
-    }, function (err, info) {
-        t.ifError(err, err);
-        if (!err) {
-            t.ok(info);
-            t.ok(info.stdout);
-            A_ID = info.stdout.replace('\n', '');
-        }
-        t.done();
-    });
-});
-
-
-// Get the upload we are going to abort, and verify the attributes match
-// what was specified on create.
-test('mmpu get A_ID', function (t) {
-    if (!MPU_ENABLED) {
-        console.log('WARNING: skipping test: multipart ' +
-            'upload is not enabled on this Manta deployment');
-        t.done();
-        return;
-    }
-
-    var argv = [ MMPU, GET, A_ID ];
-
-    forkExecWait({
-        argv: argv
-    }, function (err, info) {
-        t.ifError(err, err);
-        if (!err) {
-            t.ok(info);
-            var upload = JSON.parse(info.stdout);
-            t.ok(upload);
-            if (!upload) {
-                t.done();
-                return;
-            }
-
-            var headers = upload.headers;
-            if (!headers) {
-                t.done();
-                return;
-            }
-
-            t.ok(headers);
-            t.equal(headers['durability-level'], 1);
-            t.equal(headers['content-length'], TEXT_SIZE);
-            t.equal(headers['content-md5'], TEXT_MD5);
-            t.equal(upload.state, 'created');
-
-            A_UPLOADPATH = upload.partsDirectory;
-        } else {
-            console.log(err);
-            console.log(info.stderr);
-        }
-
-        t.done();
-    });
-
-});
-
-// Check that no parts have been uploaded for C_ID.
-test('mmpu parts C_ID: pre-upload', function (t) {
-    if (!MPU_ENABLED) {
-        console.log('WARNING: skipping test: multipart ' +
-            'upload is not enabled on this Manta deployment');
-        t.done();
-        return;
-    }
-
-    var argv = [ MMPU, PARTS, C_ID ];
-
-    forkExecWait({
-        argv: argv
-    }, function (err, info) {
-        t.ifError(err, err);
-        if (!err) {
-            t.equal(info.stdout, '');
-        } else {
-            console.log(err);
-            console.log(info.stderr);
-        }
-
-        t.done();
-    });
-});
-
-// Check that no parts have been uploaded for A_ID.
-test('mmpu parts A_ID: pre-upload', function (t) {
-    if (!MPU_ENABLED) {
-        console.log('WARNING: skipping test: multipart ' +
-            'upload is not enabled on this Manta deployment');
-        t.done();
-        return;
-    }
-
-    var argv = [ MMPU, PARTS, A_ID ];
-
-    forkExecWait({
-        argv: argv
-    }, function (err, info) {
-        t.ifError(err, err);
-        if (!err) {
-            t.equal(info.stdout, '');
-        } else {
-            console.log(err);
-            console.log(info.stderr);
-        }
-
-        t.done();
-    });
-});
-
-// Check that we see the new uploads in `mmpu list`.
-test('mmpu list', function (t) {
-    if (!MPU_ENABLED) {
-        console.log('WARNING: skipping test: multipart ' +
-            'upload is not enabled on this Manta deployment');
-        t.done();
-        return;
-    }
-
-    var argv = [ MMPU, LIST ];
-
-    forkExecWait({
-        argv: argv
-    }, function (err, info) {
-        t.ifError(err, err);
-
-        var cFound, aFound = false;
-
-        if (!err) {
-            var split = info.stdout.split('\n');
-            var c = C_UPLOADPATH;
-            var a = A_UPLOADPATH;
-
-            split.forEach(function (line) {
-                if (line === c) {
-                    cFound = true;
-                } else if (line === a) {
-                    aFound = true;
-                }
-            });
-
-            t.ok(cFound);
-            t.ok(aFound);
-        } else {
-            console.log(err);
-            console.log(info.stderr);
-        }
-
-        t.done();
-    });
-});
-
-
-// Upload a part from a file to the commit object.
-test('mmpu upload C_ID 0 -f tmpFile', function (t) {
-    if (!MPU_ENABLED) {
-        console.log('WARNING: skipping test: multipart ' +
-            'upload is not enabled on this Manta deployment');
-        t.done();
-        return;
-    }
-
-    var tmpFile = '/var/tmp/node-manta-mmpu-test-tmp-file-' + process.pid;
-
-    function mkTmpFile(_, cb) {
-        fs.writeFile(tmpFile, TEXT, cb);
-    }
-
-    function upload(_, cb) {
-        var argv = [ MMPU, UPLOAD, C_ID,
-            '0',
-            '-f', tmpFile
-        ];
-
-        forkExecWait({
-            argv: argv
-        }, function (err, info) {
-            if (err) {
-                cb(err);
-            } else {
-                 C_ETAG0 = info.stdout.replace('\n', '');
-                 cb();
-            }
-        });
-    }
-
-    function rmTmpFile(_, cb) {
-        fs.unlink(tmpFile, cb);
-    }
-
-    vasync.pipeline({
-        funcs: [
-            mkTmpFile,
-            upload,
-            rmTmpFile
-        ]
-    }, function (err, results) {
-        t.ifError(err, err);
-        t.done();
-    });
-});
-
-
-// Upload a part from a stream to the abort object.
-test('mmpu upload A_ID 0', function (t) {
-    if (!MPU_ENABLED) {
-        console.log('WARNING: skipping test: multipart ' +
-            'upload is not enabled on this Manta deployment');
-        t.done();
-        return;
-    }
-
-    var argv = [ MMPU, UPLOAD, A_ID,
-        '0'
-    ];
-
-    var child = forkExecWait({
-        argv: argv
-    }, function (err, info) {
-        t.ifError(err, err);
-        if (!err) {
-            A_ETAG0 = info.stdout.replace('\n', '');
-        } else {
-            console.log(err);
-            console.log(info.stderr);
-        }
-        t.done();
-    });
-
-    setImmediate(function () {
-        child.stdin.write(TEXT);
-        child.stdin.end();
-    });
-});
-
-// Check that one part has been uploaded for C_ID.
-test('mmpu parts C_ID: post-upload', function (t) {
-    if (!MPU_ENABLED) {
-        console.log('WARNING: skipping test: multipart ' +
-            'upload is not enabled on this Manta deployment');
-        t.done();
-        return;
-    }
-
-    var argv = [ MMPU, PARTS, C_ID ];
-
-    forkExecWait({
-        argv: argv
-    }, function (err, info) {
-        t.ifError(err, err);
-        if (!err) {
-            var expectedStdout = C_UPLOADPATH + '/0\n';
-            t.equal(info.stdout, expectedStdout);
-        } else {
-            console.log(err);
-            console.log(info.stderr);
-        }
-
-        t.done();
-    });
-});
-
-// Check that one part has been uploaded for A_ID.
-test('mmpu parts A_ID: post-upload', function (t) {
-    if (!MPU_ENABLED) {
-        console.log('WARNING: skipping test: multipart ' +
-            'upload is not enabled on this Manta deployment');
-        t.done();
-        return;
-    }
-
-    var argv = [ MMPU, PARTS, A_ID ];
-
-    forkExecWait({
-        argv: argv
-    }, function (err, info) {
-        t.ifError(err, err);
-        if (!err) {
-            var expectedStdout = A_UPLOADPATH + '/0\n';
-            t.equal(info.stdout, expectedStdout);
-        } else {
-            console.log(err);
-            console.log(info.stderr);
-        }
-
-        t.done();
-    });
-});
-
-
-// Check that `mmpu list -p` now includes the parts that have been uploaded.
-test('mmpu list -p', function (t) {
-    if (!MPU_ENABLED) {
-        console.log('WARNING: skipping test: multipart ' +
-            'upload is not enabled on this Manta deployment');
-        t.done();
-        return;
-    }
-
-    var argv = [ MMPU, LIST, '-p' ];
-
-    forkExecWait({
-        argv: argv
-    }, function (err, info) {
-        t.ifError(err, err);
-
-        var c = C_UPLOADPATH;
-        var a = A_UPLOADPATH;
-        var c0 = c + '/0';
-        var a0 = a + '/0';
-
-        var cFound, aFound, c0Found, a0Found = false;
-
-        if (!err) {
-            var split = info.stdout.split('\n');
-            split.forEach(function (line) {
-                if (line === c) {
-                    cFound = true;
-                } else if (line === a) {
-                    aFound = true;
-                } else if (line === c0) {
-                    c0Found = true;
-                } else if (line === a0) {
-                    a0Found = true;
-                }
-            });
-
-            t.ok(cFound);
-            t.ok(aFound);
-            t.ok(c0Found);
-            t.ok(a0Found);
-        } else {
-            console.log(err);
-            console.log(info.stderr);
-        }
-
-        t.done();
-    });
-});
-
-
-// Check that `mmpu list` (without -p) does not show the parts that have been
-// uploaded.
-test('mmpu list: post part upload', function (t) {
-    if (!MPU_ENABLED) {
-        console.log('WARNING: skipping test: multipart ' +
-            'upload is not enabled on this Manta deployment');
-        t.done();
-        return;
-    }
-
-    var argv = [ MMPU, LIST ];
-
-    forkExecWait({
-        argv: argv
-    }, function (err, info) {
-        t.ifError(err, err);
-
-        var c = C_UPLOADPATH;
-        var a = A_UPLOADPATH;
-        var c0 = c + '/0';
-        var a0 = a + '/0';
-
-        var cFound, aFound, c0Found, a0Found = false;
-
-        if (!err) {
-            var split = info.stdout.split('\n');
-            split.forEach(function (line) {
-                if (line === c) {
-                    cFound = true;
-                } else if (line === a) {
-                    aFound = true;
-                } else if (line === c0) {
-                    c0Found = true;
-                } else if (line === a0) {
-                    a0Found = true;
-                }
-            });
-
-            t.ok(cFound);
-            t.ok(aFound);
-            t.ok(!c0Found);
-            t.ok(!a0Found);
-        } else {
-            console.log(err);
-            console.log(info.stderr);
-        }
-
-        t.done();
-    });
-});
-
-
-
-// Commit the object, do an mget of it to verify it's the object we expect,
-// and remove it to clean up.
-test('mmpu commit C_ID C_ETAG0', function (t) {
-    if (!MPU_ENABLED) {
-        console.log('WARNING: skipping test: multipart ' +
-            'upload is not enabled on this Manta deployment');
-        t.done();
-        return;
-    }
-
-    function commit(_, cb) {
-        var argv = [ MMPU, COMMIT, C_ID, C_ETAG0 ];
-
-        forkExecWait({
-            argv: argv
-        }, function (err, info) {
-            if (err) {
-                cb(err);
-            } else {
-                cb();
-            }
-        });
-    }
-
-    function checkCommitState(_, cb) {
-        var argv = [ MMPU, GET, C_ID ];
-
-        forkExecWait({
-            argv: argv
-        }, function (err, info) {
-            if (err) {
-                cb(err);
-            } else {
-                var upload = JSON.parse(info.stdout);
-                t.ok(upload.state, 'done');
-                t.ok(upload.result, 'committed');
-                cb();
-            }
-        });
-    }
-
-    function getCommitObj(_, cb) {
-        var argv = [ MGET, C_OBJ_PATH ];
-
-        forkExecWait({
-            argv: argv
-        }, function (err, info) {
-            if (err) {
-                cb(err);
-            } else {
-                var output = info.stdout.replace('\n', '');
-                t.equal(TEXT, output);
-                cb();
-            }
-        });
-    }
-
-    function rmCommitObj(_, cb) {
-        var argv = [ MRM, C_OBJ_PATH ];
-
-        forkExecWait({
-            argv: argv
-        }, function (err, info) {
-            if (err) {
-                cb(err);
-            } else {
-                 cb();
-            }
-        });
-    }
-
-    vasync.pipeline({
-        funcs: [
-            commit,
-            checkCommitState,
-            getCommitObj,
-            rmCommitObj
-        ]
-    }, function (err, results) {
-        t.ifError(err, err);
-        t.done();
-    });
-});
-
-
-// Abort the object being uploaded to A_OBJ_PATH.
-test('mmpu abort A_ID', function (t) {
-    if (!MPU_ENABLED) {
-        console.log('WARNING: skipping test: multipart ' +
-            'upload is not enabled on this Manta deployment');
-        t.done();
-        return;
-    }
-
-    function abort(_, cb) {
-        var argv = [ MMPU, ABORT, A_ID ];
-
-        forkExecWait({
-            argv: argv
-        }, function (err, info) {
-            if (err) {
-                cb(err);
-            } else {
-                cb();
-            }
-        });
-    }
-
-    function checkAbortState(_, cb) {
-        var argv = [ MMPU, GET, A_ID ];
-
-        forkExecWait({
-            argv: argv
-        }, function (err, info) {
-            if (err) {
-                cb(err);
-            } else {
-                var upload = JSON.parse(info.stdout);
-                t.ok(upload.state, 'done');
-                t.ok(upload.result, 'aborted');
-                cb();
-            }
-        });
-    }
-
-    vasync.pipeline({
-        funcs: [
-            abort,
-            checkAbortState
-        ]
-    }, function (err, results) {
-        t.ifError(err, err);
-        t.done();
-    });
-});
diff --git a/test/node.paths.example b/test/node.paths.example
deleted file mode 100644
index c89df60..0000000
--- a/test/node.paths.example
+++ /dev/null
@@ -1,5 +0,0 @@
-8 ~/opt/node-8/bin
-6 ~/opt/node-6/bin
-4 ~/opt/node-4/bin
-0.12 ~/opt/node-0.12/bin
-0.10 ~/opt/node-0.10/bin
diff --git a/test/completion.test.js b/test/unit/completion.test.js
similarity index 81%
rename from test/completion.test.js
rename to test/unit/completion.test.js
index 9b4035e..cb042f7 100644
--- a/test/completion.test.js
+++ b/test/unit/completion.test.js
@@ -1,5 +1,5 @@
 /*
- * Copyright 2018 Joyent, Inc.
+ * Copyright 2019 Joyent, Inc.
  */
 
 /*
@@ -11,20 +11,13 @@ var fs = require('fs');
 var path = require('path');
 
 var forkExecWait = require('forkexec').forkExecWait;
+var test = require('tap').test;
 
 /*
  * Globals
  */
 
-var binDir = path.resolve(__dirname, '..', 'bin');
-
-/*
- * Helper functions
- */
-
-function test(name, testfunc) {
-    module.exports[name] = testfunc;
-}
+var binDir = path.resolve(__dirname, '../../bin');
 
 /*
  * Tests
@@ -46,7 +39,7 @@ fs.readdirSync(binDir).forEach(function (name) {
                 'no stderr output from "' + name + ' --completion"');
             t.ok(/COMPREPLY/.test(info.stdout), 'stdout from "' + name +
                 ' --completion" looks like Bash completion code');
-            t.done();
+            t.end();
         });
     });
 });
diff --git a/test/options.test.js b/test/unit/options.test.js
similarity index 92%
rename from test/options.test.js
rename to test/unit/options.test.js
index d991973..3d5da9f 100644
--- a/test/options.test.js
+++ b/test/unit/options.test.js
@@ -1,5 +1,5 @@
 /*
- * Copyright 2017 Joyent, Inc.
+ * Copyright 2019 Joyent, Inc.
  */
 
 /*
@@ -8,9 +8,10 @@
 
 var forkExecWait = require('forkexec').forkExecWait;
 var path = require('path');
+var test = require('tap').test;
 var vasync = require('vasync');
 
-var BINDIR = path.resolve(__dirname, '../bin');
+var BINDIR = path.resolve(__dirname, '../../bin');
 
 const ALLCMDS = [ 'mchattr', 'mchmod', 'mfind', 'mget', 'minfo',
                   'mln', 'mlogin', 'mls', 'mmd5', 'mmkdir', 'mput',
@@ -25,11 +26,6 @@ function resolveCommand(cmd) {
 }
 
 
-function test(name, testfunc) {
-    module.exports[name] = testfunc;
-}
-
-
 function forkCmdWithOption(input, option, cb) {
     forkExecWait({
         argv: [ input.cmd,
@@ -83,13 +79,12 @@ function inputObject(testObj) {
  * result in a warning about the missing URL. This verifies the fix for
  * https://github.com/joyent/node-manta/issues/328.
  */
-
 test('Run commands with --help with no manta URL specified', function (t) {
     vasync.forEachPipeline({
         inputs: ALLCMDS.map(inputObject(t)),
         func: forkHelpOption
     }, function (err, results) {
-           t.done();
+           t.end();
        });
 });
 
@@ -104,6 +99,6 @@ test('Run commands with --version with no manta URL specified', function (t) {
         inputs: ALLCMDS.map(inputObject(t)),
         func: forkVersionOption
     }, function (err, results) {
-           t.done();
+           t.end();
        });
 });
diff --git a/test/trackmarker.test.js b/test/unit/trackmarker.test.js
similarity index 95%
rename from test/trackmarker.test.js
rename to test/unit/trackmarker.test.js
index b7cc454..8b71b90 100644
--- a/test/trackmarker.test.js
+++ b/test/unit/trackmarker.test.js
@@ -1,12 +1,10 @@
 /*
- * Copyright 2015 Joyent, Inc.
+ * Copyright 2019 Joyent, Inc.
  */
 
-var mod_trackmarker = require('../lib/trackmarker');
+var test = require('tap').test;
+var mod_trackmarker = require('../../lib/trackmarker');
 
-function test(name, testfunc) {
-    module.exports[name] = testfunc;
-}
 
 var SCENARIOS = [
     {
@@ -128,6 +126,6 @@ SCENARIOS.forEach(function (scenario) {
             });
         });
         check_scenario(t, scenario, count++, tm, results);
-        t.done();
+        t.end();
     });
 });
diff --git a/test/utils.test.js b/test/unit/utils.test.js
similarity index 91%
rename from test/utils.test.js
rename to test/unit/utils.test.js
index 5cf2d77..5c90fec 100644
--- a/test/utils.test.js
+++ b/test/unit/utils.test.js
@@ -1,14 +1,13 @@
 /*
- * Copyright 2018 Joyent, Inc.
+ * Copyright 2019 Joyent, Inc.
  */
 
 var f = require('util').format;
 
-var manta = require('..');
+var test = require('tap').test;
+
+var manta = require('../..');
 
-function test(name, testfunc) {
-    module.exports[name] = testfunc;
-}
 
 // a name on the left should match the name on the right
 // when escaped.
@@ -31,7 +30,7 @@ test('escapePath encoding', function (t) {
         var s = _test[0];
         t.equal(manta.escapePath(s), _test[1]);
     });
-    t.done();
+    t.end();
 });
 
 test('prettyBytes', function (t) {
@@ -80,5 +79,5 @@ test('prettyBytes', function (t) {
             manta.prettyBytes(value);
         }, f('prettyBytes(%j) throws', value));
     });
-    t.done();
+    t.end();
 });
diff --git a/tools/jsl.node.conf b/tools/jsl.node.conf
index e8711c7..bb93f65 100644
--- a/tools/jsl.node.conf
+++ b/tools/jsl.node.conf
@@ -1,5 +1,5 @@
 #
-# Configuration File for JavaScript Lint 
+# Configuration File for JavaScript Lint
 #
 # This configuration file can be used to lint a collection of scripts, or to enable
 # or disable warnings for scripts that are linted via the command line.
@@ -124,6 +124,7 @@
 +define Buffer
 +define JSON
 +define Math
++define Uint8Array
 
 ### JavaScript Version
 # To change the default JavaScript version:
@@ -136,4 +137,3 @@
 # To add a set of files, use "+process FileName", "+process Folder\Path\*.js",
 # or "+process Folder\Path\*.htm".
 #
-
