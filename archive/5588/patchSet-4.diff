commit a4266071f6a5c26e0af4c141ed4393d558617029
Author: Orlando Vazquez <ovazquez@gmail.com>
Date:   2019-02-14T14:37:54-08:00 (8 months ago)
    
    TRITON-1180 cnapi waitlist ticket race if serverwaitlistticketrelease starts and completes during serverwaitlistticketcreate

diff --git a/lib/endpoints/waitlist.js b/lib/endpoints/waitlist.js
index 37c690c..ca12362 100644
--- a/lib/endpoints/waitlist.js
+++ b/lib/endpoints/waitlist.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2018, Joyent, Inc.
+ * Copyright (c) 2019, Joyent, Inc.
  */
 
 /*
@@ -145,9 +145,8 @@ function handlerControllerWaitlistList(req, res, next) {
 
 ControllerWaitlist.createTicket =
 function handlerControllerWaitlistCreateTicket(req, res, next) {
-    var waitlist = req.stash.server.getWaitlist();
     req.params.reqid = req.getId();
-    waitlist.createTicket(req.params, function (error, uuid, tickets) {
+    ModelWaitlist.createTicket(req.params, function (error, uuid, tickets) {
         if (error) {
             next(new restify.InternalError(error.message));
             return;
diff --git a/lib/models/waitlist.js b/lib/models/waitlist.js
index cb12338..accb5b7 100644
--- a/lib/models/waitlist.js
+++ b/lib/models/waitlist.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2018, Joyent, Inc.
+ * Copyright (c) 2019, Joyent, Inc.
  */
 
 /*
@@ -17,6 +17,7 @@
 
 var assert = require('assert-plus');
 var async = require('async');
+var backoff = require('backoff');
 var libuuid = require('libuuid');
 var once = require('once');
 var sprintf = require('sprintf').sprintf;
@@ -36,8 +37,9 @@ var TICKET_STATUS_FINISHED = 'finished';
 var TICKET_STATUS_QUEUED = 'queued';
 
 // Ticket modify operations
-var TICKET_OPERATION_UPDATE = 'update';
 var TICKET_OPERATION_DELETE = 'delete';
+var TICKET_OPERATION_CREATE = 'create';
+var TICKET_OPERATION_UPDATE = 'update';
 
 // Moray bucket
 var MORAY_BUCKET_WAITLIST_TICKETS = buckets.waitlist_tickets.name;
@@ -119,7 +121,7 @@ function WaitlistDirectorStart() {
         // If there are tickets with an updated_at time later than the last
         // time we last checked, process those tickets.
         if (tickets && tickets.length) {
-            self.log.info({ tickets: tickets },
+            self.log.debug({ tickets: tickets },
                            'tickets updated since %s (started at %s)',
                            date ? date.toISOString() : 'start-up',
                            start.toISOString());
@@ -158,7 +160,7 @@ function WaitlistDirectorOnUpdate(timestamp, tickets) {
     assert.optionalDate(timestamp, 'timestamp');
     assert.array(tickets, 'tickets');
 
-    self.log.info({ tickets: tickets },
+    self.log.debug({ tickets: tickets },
         'onUpdate: called with %d tickets', tickets.length);
 
     async.forEach(
@@ -207,12 +209,12 @@ function WaitlistDirectorOnUpdate(timestamp, tickets) {
             } else if (
                 ticket.status === TICKET_STATUS_ACTIVE &&
                 !self.callbacks[ticket.uuid]) {
-                self.log.warn(
+                self.log.debug(
                     { ticket: ticket },
                     'onUpdate: ticket %s active but no callbacks found',
                     ticket.uuid);
             } else {
-                self.log.info(
+                self.log.debug(
                     { ticket: ticket }, 'nothing to do for ticket %s onUpdate',
                     ticket.uuid);
             }
@@ -601,24 +603,19 @@ function modelWaitlistFindNextTickets(opts, callback) {
     assert.string(opts.id, 'opts.id');
     assert.string(opts.scope, 'opts.scope');
     assert.string(opts.server_uuid, 'opts.server_uuid');
-    assert.optionalNumber(opts.limit, 'opts.limit');
-    assert.optionalBool(opts.omitActive, 'opts.omitActive');
-    assert.optionalUuid(opts.omitTicketUuid, 'opts.omitTicketUuid');
 
     var filter = sprintf(
         '(&' +
             '(server_uuid=%s)' +
             '(scope=%s)' +
             '(id=%s)' +
-            (opts.omitActive ? '(!(status=active))' : '') +
-            (opts.omitTicketUuid
-                ? '(!(uuid=' + opts.omitTicketUuid + '))' : '') +
-            '(!(status=finished))' +
-            '(!(status=expired))' +
-        ')', opts.server_uuid, opts.scope, opts.id);
+            '(|(status=%s)' +
+            '(status=%s))' +
+        ')',
+        opts.server_uuid, opts.scope, opts.id,
+        TICKET_STATUS_ACTIVE, TICKET_STATUS_QUEUED);
 
     var findOpts = {
-        limit: opts.limit,
         sort: {
             attribute: 'created_at',
             order: 'ASC'
@@ -632,30 +629,117 @@ function modelWaitlistFindNextTickets(opts, callback) {
             return;
         }
 
-        tickets = tickets.map(function (t) {
+        var results = tickets.map(function (t) {
             return { ticket: t.value, etag: t._etag };
         });
 
-        self.log.trace({ filter: filter, tickets: tickets },
+        self.log.debug({ filter: filter, tickets: results },
             'findNextTickets: found tickets');
 
-        callback(err, tickets);
+        callback(err, results);
     });
 };
 
 /*
- * Update a ticket in moray, and activate the next ticket (by creation_date)
- * with the same set formed by `ticket.scope`, `ticket.server_uuid`, and
- * `ticket.id`.
+ * Check if there are tickets with status=`active` for a given `scope`,
+ * `server_uuid` and `id`. If none match, take the oldest by `created_at` and
+ * update its status (to 'active').
+ */
+
+ModelWaitlist.activateOneTicket =
+function ModelWaitlistActivateOne(opts, callback) {
+    var self = this;
+    var ticket;
+    var etag;
+
+    assert.object(opts, 'opts');
+    assert.string(opts.id, 'opts.id');
+    assert.string(opts.scope, 'opts.scope');
+    assert.string(opts.server_uuid, 'opts.server_uuid');
+
+    vasync.waterfall([
+        function findNextTickets(next) {
+            self.log.debug(opts,
+                'activateOneTicket: finding next ticket to activate');
+            ModelWaitlist.findNextTickets(opts,
+            function _onFindNextTickets(err, results) {
+                if (err) {
+                    next(err);
+                    return;
+                }
+
+                if (results.length === 0) {
+                    self.log.debug(opts,
+                        'activateOneTicket: no tickets to activate');
+                    next();
+                    return;
+                }
+
+                var activeCount = results.filter(function (i) {
+                    return i.ticket.status === TICKET_STATUS_ACTIVE;
+                }).length;
+
+                if (activeCount > 1) {
+                    self.log.error(
+                        { opts: opts, results: results },
+                        'activateOneTicket: ' +
+                        'found more than one active ticket');
+                    next();
+                    return;
+                }
+
+                if (activeCount > 0) {
+                    next();
+                    return;
+                }
+
+                ticket = results[0].ticket;
+                etag = results[0].etag;
+                next();
+            });
+        },
+        function activateOldest(next) {
+            if (!ticket) {
+                next();
+                return;
+            }
+            ticket.status = TICKET_STATUS_ACTIVE;
+            ticket.updated_at = (new Date()).toISOString();
+
+            ModelWaitlist.getMoray().putObject(
+                MORAY_BUCKET_WAITLIST_TICKETS,
+                ticket.uuid,
+                ticket,
+                { etag: etag },
+                function _onPutObject(puterror) {
+                    if (puterror) {
+                        callback(
+                            VError(puterror, 'failed to updated ticket'));
+                        return;
+                    }
+                    next();
+                });
+        }
+    ], callback);
+};
+
+
+/* BEGIN JSSTYLED */
+/*
+ * Perform a primitive operation on a ticket, and subsequently ensure there
+ * if there are tickets for the same `ticket.scope`, `ticket.server_uuid` and
+ * `ticket.id` that one is active.
  *
  * @param {Object} opts
- * @param {Object} opts.ticket
- * @param {String} opts.ticketEtag
- * @param {Function} callback `function (err, { ticket: ticket, etag: etag })`
+ * @param {Object} opts.operation TICKET_OPERATION_CREATE, TICKET_OPERATION_DELETE, TICKET_OPERATION_UPDATE
+ * @param {Object} opts.ticket_uuid
+ * @param {Object} opts.ticket Used as the full payload of a new ticket or a partial update to be applied o over an existing ticket
+ * @param {Function} callback `function (err)`
  */
+/* END JSSTYLED */
 
-ModelWaitlist.modifyTicketActivateNext =
-function ModelWaitlistUpdateTicketActivateNext(opts, callback) {
+ModelWaitlist.doTicketOperationActivateNext =
+function ModelWaitlistTicketOperation(opts, callback) {
     var self = this;
 
     assert.object(opts, 'opts');
@@ -663,20 +747,26 @@ function ModelWaitlistUpdateTicketActivateNext(opts, callback) {
     assert.uuid(opts.ticket_uuid, 'opts.ticket_uuid');
     assert.func(callback, 'callback');
 
-    if (opts.operation === TICKET_OPERATION_UPDATE) {
-        assert.object(opts.update, 'opts.update');
-    }
+    if (opts.operation === TICKET_OPERATION_CREATE ||
+        opts.operation === TICKET_OPERATION_UPDATE) {
 
-    var moray = ModelWaitlist.getMoray();
+        assert.object(opts.payload, 'opts.payload');
+    }
 
     var ticket_uuid = opts.ticket_uuid;
     var ticket;
     var ticketEtag;
-    var batchOperations = [];
 
     vasync.waterfall([
         // Look up ticket with given ticket uuid.
         function doGetTicket(next) {
+            if (opts.operation === TICKET_OPERATION_CREATE) {
+                ticket = opts.payload;
+                ticketEtag = null;
+                next();
+                return;
+            }
+
             ModelWaitlist.getTicket(opts.ticket_uuid,
             function _onGetTicket(geterror, result) {
                 if (geterror) {
@@ -692,143 +782,96 @@ function ModelWaitlistUpdateTicketActivateNext(opts, callback) {
                 }
 
                 self.log.debug({ result: result },
-                    'modifyTicketActivateNext: getTicket result');
+                    'doTicketOperationActivateNext: getTicket result');
 
                 ticket = result.ticket;
                 ticketEtag = result.etag;
-                ticket.updated_at = (new Date()).toISOString();
-
-                // If update passed in, override the ticket values with it.
-                if (opts.update) {
-                    for (var i in opts.update) {
-                        ticket[i] = opts.update[i];
-                    }
-                }
 
                 next();
             });
         },
 
-        // Set up batch call to delete or update ticket for given ticket uuid
-        // depending on operation.
-        function doSetupBatch(next) {
-            if (opts.operation === TICKET_OPERATION_DELETE) {
-                batchOperations.push({
-                    bucket: MORAY_BUCKET_WAITLIST_TICKETS,
-                    key: ticket.uuid,
-                    operation: 'delete',
-                    options: {
-                        etag: ticketEtag
-                    }
-                });
-            } else if (opts.operation === TICKET_OPERATION_UPDATE) {
-                batchOperations.push({
-                    bucket: MORAY_BUCKET_WAITLIST_TICKETS,
-                    key: ticket.uuid,
-                    operation: 'put',
-                    value: ticket,
-                    options: {
-                        etag: ticketEtag
-                    }
-                });
-            } else {
-                self.log.error('unknown operation %s', opts.operation);
-            }
-
-            self.log.info({ operation: opts.operation,
-                batchData: batchOperations },
-                'updateTicketActivateNext: batch batchOperations');
-
-            next();
-        },
+        function doUpdates(next) {
+            var morayOpts = { etag: ticketEtag };
 
-        // Look up the next ticket to be activated so we can activate it at
-        // the same time as we update/delete the ticket that was passed in.
-        function doFindNextTicket(next) {
-            ModelWaitlist.findNextTickets({
-                server_uuid: ticket.server_uuid,
-                limit: 1,
-                omitActive: true,
-                omitTicketUuid: ticket.uuid,
-                id: ticket.id,
-                scope: ticket.scope
-            },
-            function onFindTicket(err, results) {
-                if (err) {
-                    next(err);
-                    return;
-                }
-
-                // If there are no more tickets to activate we can skip
-                // everything after this.
-                if (!results.length) {
-                    next();
-                    return;
-                }
-
-                var nextTicket = results[0].ticket;
-                var nextEtag = results[0].etag;
-
-                // If there was a subsequent ticket to our given one waiting
-                // to be activated, update its values and write it back out.
-                // Otherwise, we can skip this part.
+            if (opts.operation === TICKET_OPERATION_DELETE) {
+                ModelWaitlist.getMoray().delObject(
+                    MORAY_BUCKET_WAITLIST_TICKETS,
+                    opts.ticket_uuid,
+                    morayOpts,
+                    function (delError) {
+                        if (delError) {
+                            next(VError(delError,
+                                'failed to delete ticket %s from moray',
+                                ticket.uuid));
+                            return;
+                        }
+                        next();
+                    });
+            } else if (opts.operation === TICKET_OPERATION_UPDATE ||
+                       opts.operation === TICKET_OPERATION_CREATE) {
 
-                if (!nextTicket) {
-                    self.log.info('no ticket following update of %s',
-                        ticket.uuid);
-                    next();
-                    return;
+                // Override the ticket values.
+                for (var i in opts.payload) {
+                    ticket[i] = opts.payload[i];
                 }
 
-                nextTicket.updated_at = (new Date()).toISOString();
-                nextTicket.status = TICKET_STATUS_ACTIVE;
+                ticket.updated_at = (new Date()).toISOString();
 
-                self.log.info({ nextTicket: nextTicket },
-                    'ticket to be activated');
+                ModelWaitlist.getMoray().putObject(
+                    MORAY_BUCKET_WAITLIST_TICKETS,
+                    ticket.uuid,
+                    ticket,
+                    morayOpts,
+                    function (putError) {
+                        if (putError) {
+                            next(VError(putError,
+                                'failed to write ticket %s to moray',
+                                ticket.uuid));
+                            return;
+                        }
+                        next();
+                    });
+            } else {
+                self.log.error('unknown operation %s', opts.operation);
+            }
+        },
 
-                batchOperations.push({
-                    bucket: MORAY_BUCKET_WAITLIST_TICKETS,
-                    key: nextTicket.uuid,
-                    operation: 'put',
-                    value: nextTicket,
-                    options: {
-                        etag: nextEtag
+        // If there are tickets for this server/scope/id, make sure one of them
+        // is considered active (having `status` = 'active'). If one is not
+        // active, activate the oldest one.
+        //
+        // We'll wrap this with `backoff` so that if we get an etag conflict we
+        // can reattempt the operation.  If we get a conflict and we retry and
+        // there is an active ticket now, then can stop, having satisfied our
+        // requirement that a ticket be in status='active'.
+
+        function activateOneTicket(next) {
+            var call = backoff.call(
+                ModelWaitlist.activateOneTicket.bind(self),
+                {
+                    server_uuid: ticket.server_uuid,
+                    scope: ticket.scope,
+                    id: ticket.id
+                },
+                function _onBackoffCall(err) {
+                    if (err) {
+                        self.log.error(err,
+                            'activateOneTicket: returned error');
                     }
+                    next();
                 });
-                next();
-            });
-        },
-
-        // Actually execute the batch.
-        function batchUpdate(next) {
-            self.log.debug({
-                batch: batchOperations
-            }, 'performing batch operation to activate next ticket');
-
-            moray.batch(batchOperations, function (err, _meta) {
-                if (err &&
-                    (VError.hasCauseWithName(err,
-                        'EtagConflictError') ||
-                    (VError.hasCauseWithName(err,
-                        'UniqueAttributeError')))) {
-
-                    self.log.warn({ err: err },
-                        'modifyTicketActivateNext: batch conflict, retrying');
-
-                    self.modifyTicketActivateNext(opts, next);
-                    return;
-                } else if (err) {
-                    next(new VError(err,
-                        'updateTicketActivateNext: batch error'));
-                    return;
-                }
 
-                next();
+            call.retryIf(function _onRetryIf(err) {
+                return VError.hasCauseWithName(err, 'EtagConflictError');
             });
+            call.setStrategy(new backoff.ExponentialStrategy());
+            call.failAfter(10);
+            call.start();
         }
     ],
-    function (wferr) {
-        self.log.info({ err: wferr }, 'updateTicketActivateNext: finished');
+    function _onModifyWfEnd(wferr) {
+        self.log.debug({ err: wferr }, 'updateTicketActivateNext: finished');
         callback(wferr);
     });
 };
@@ -836,9 +879,10 @@ function ModelWaitlistUpdateTicketActivateNext(opts, callback) {
 
 /* BEGIN JSSTYLED */
 /*
- * Create a new ticket record and write it into moray. If there are existing
- * tickets for the same `server_uuid`, `scope` and `id`, the new ticket will
- * receive a status of 'queued'.
+ * Create a new ticket record. Ticket execution order depends on ticket age
+ * (oldest tickets first), grouped by server UUID, scope and id. Tickets are first
+ * created with a status of 'queued'. As tickets are released, subsequent
+ * tickets are activated (status=active).
  *
  * @param opts {Object}
  * @param opts.scope {String} ticket scope
@@ -851,10 +895,9 @@ function ModelWaitlistUpdateTicketActivateNext(opts, callback) {
  */
 /* END JSSTYLED */
 
-ModelWaitlist.prototype.createTicket =
-function ModelWaitlistCreateTicket(opts, callback) {
-    var self = this;
 
+ModelWaitlist.createTicket =
+function ModelWaitlistCreateTicket(opts, callback) {
     assert.object(opts, 'opts');
     assert.string(opts.scope, 'opts.scope');
     assert.string(opts.id, 'opts.id');
@@ -865,102 +908,46 @@ function ModelWaitlistCreateTicket(opts, callback) {
     assert.func(callback, 'callback');
 
     var ticket = {
-        uuid: libuuid.create(),
-        server_uuid: this.uuid,
-        scope: opts.scope,
-        id: opts.id,
-        expires_at: opts.expires_at,
+        action: opts.action,
         created_at: (new Date()).toISOString(),
-        updated_at: (new Date()).toISOString(),
+        expires_at: opts.expires_at,
+        extra: opts.extra || {},
+        id: opts.id,
         reqid: opts.req_id,
-        extra: opts.extra || {}
+        scope: opts.scope,
+        server_uuid: opts.server_uuid,
+        status: TICKET_STATUS_QUEUED,
+        updated_at: (new Date()).toISOString(),
+        uuid: libuuid.create()
     };
 
+    ModelWaitlist.doTicketOperationActivateNext({
+        ticket_uuid: ticket.uuid,
+        operation: TICKET_OPERATION_CREATE,
+        payload: ticket
+    }, function (err) {
+        if (err) {
+            callback(err);
+            return;
+        }
 
-    if (jsprim.hasKey(opts, 'action')) {
-        ticket.action = opts.action;
-    }
-
-    self.log.info({
-        ticket: ticket
-    }, 'creating ticket %s', ticket.uuid);
-
-    var tickets;
-
-    vasync.waterfall([
-        /*
-         * Check if there are existing tickets for this server/scope/id
-         * combination. If there are, we'll set this ticket's status to
-         * 'queued'. If there are no currently queued or active tickets, we'll
-         * make this one 'active'.
-         */
-        function determineWhetherToActivate(next) {
-            ModelWaitlist.findNextTickets({
-                server_uuid: self.uuid,
-                scope: opts.scope,
-                id: opts.id
-            }, function _onDetermineWhetherToActivate(err, _tickets) {
-                if (err) {
-                    next(err);
-                    return;
-                }
-
-                tickets = _tickets.map(function (t) {
-                    return t.ticket;
-                });
+        ModelWaitlist.findNextTickets({
+            server_uuid: opts.server_uuid,
+            scope: opts.scope,
+            id: opts.id
+        }, function _onFindNextTickets(findErr, _tickets) {
+            if (findErr) {
+                callback(findErr);
+                return;
+            }
 
-                if (tickets.length) {
-                    ticket.status = TICKET_STATUS_QUEUED;
-                } else {
-                    ticket.status = TICKET_STATUS_ACTIVE;
-                }
-                next();
+            var tickets = _tickets.map(function (t) {
+                return t.ticket;
             });
-        },
 
-        /*
-         * Write this ticket object out to moray.
-         */
-        function writeTicketToMoray(next) {
-            ModelWaitlist.getMoray().putObject(
-                MORAY_BUCKET_WAITLIST_TICKETS,
-                ticket.uuid,
-                ticket,
-                function (puterror) {
-                    if (puterror) {
-                        next(VError(puterror,
-                            'failed to write ticket %s to moray',
-                            ticket.uuid));
-                        return;
-                    }
-                    next();
-                });
-        },
-        /*
-         * Finally, look up the ticket queue one more time, and return it to
-         * the caller.
-         */
-
-        function refreshTickets(next) {
-            ModelWaitlist.findNextTickets({
-                server_uuid: self.uuid,
-                scope: opts.scope,
-                id: opts.id
-            }, function _onFindNextTickets(err, _tickets) {
-                if (err) {
-                    next(err);
-                    return;
-                }
+            callback(null, ticket.uuid, tickets);
+        });
 
-                tickets = _tickets.map(function (t) {
-                    return t.ticket;
-                });
-                next();
-            });
-        }
-    ],
-    function endWaterfall(wferror) {
-        callback(wferror, ticket.uuid, tickets);
     });
 };
 
@@ -978,10 +965,10 @@ function ModelWaitlistExpireTicket(ticket_uuid, callback) {
 
     self.log.info({ uuid: ticket_uuid }, 'going to expire ticket');
 
-    ModelWaitlist.modifyTicketActivateNext({
+    ModelWaitlist.doTicketOperationActivateNext({
         ticket_uuid: ticket_uuid,
         operation: TICKET_OPERATION_UPDATE,
-        update: {
+        payload: {
             status: TICKET_STATUS_EXPIRED
         }
     }, callback);
@@ -1005,10 +992,10 @@ function ModelWaitlistReleaseTicket(ticket_uuid, callback) {
 
     self.log.info({ uuid: ticket_uuid }, 'going to release ticket');
 
-    ModelWaitlist.modifyTicketActivateNext({
+    ModelWaitlist.doTicketOperationActivateNext({
         ticket_uuid: ticket_uuid,
         operation: TICKET_OPERATION_UPDATE,
-        update: {
+        payload: {
             status: TICKET_STATUS_FINISHED
         }
     }, callback);
@@ -1023,6 +1010,7 @@ function ModelWaitlistReleaseTicket(ticket_uuid, callback) {
  * @param ticket_uuid {String} The ticket to be released.
  * @param callback {Function} `function (err)`
  */
+
 ModelWaitlist.deleteTicket =
 function ModelWaitlistDeleteTicket(ticket_uuid, callback) {
     var self = this;
@@ -1031,7 +1019,7 @@ function ModelWaitlistDeleteTicket(ticket_uuid, callback) {
 
     self.log.info({ uuid: ticket_uuid }, 'going to delete ticket');
 
-    ModelWaitlist.modifyTicketActivateNext({
+    ModelWaitlist.doTicketOperationActivateNext({
         ticket_uuid: ticket_uuid,
         operation: TICKET_OPERATION_DELETE
     }, callback);
@@ -1124,38 +1112,4 @@ ModelWaitlist.prototype.countTickets = function (callback) {
 };
 
 
-
-ModelWaitlist.prototype.updateTicket = function (uuid, params, callback) {
-    ModelWaitlist.getTicket(uuid, function (geterror, result) {
-        if (geterror) {
-            callback(
-                VError(geterror, 'failed to retrieve ticket %s', uuid));
-            return;
-        }
-
-        var ticket = result.ticket;
-
-        if (params.status) {
-            ticket.status = params.status;
-        }
-
-        ticket.updated_at = (new Date()).toISOString();
-
-        ModelWaitlist.getMoray().putObject(
-            MORAY_BUCKET_WAITLIST_TICKETS,
-            uuid,
-            ticket,
-            function (puterror) {
-                if (puterror) {
-                    callback(
-                        VError(puterror, 'failed to store updated ticket'));
-                    return;
-                }
-                callback();
-            });
-    });
-};
-
-
-
 module.exports = ModelWaitlist;
diff --git a/package.json b/package.json
index 285b84d..08ee5ec 100644
--- a/package.json
+++ b/package.json
@@ -1,13 +1,14 @@
 {
   "name": "cnapi",
   "description": "SmartDataCenter Compute Node API",
-  "version": "1.19.4",
+  "version": "1.19.5",
   "author": "Joyent (joyent.com)",
   "private": true,
   "dependencies": {
     "amqp": "0.2.6",
     "assert-plus": "1.0.0",
     "async": "1.5.2",
+    "backoff": "2.5.0",
     "bunyan": "1.8.5",
     "dapi": "git+https://github.com/joyent/sdc-designation.git#e70e8e91f97496a7df3140dd061b1a48b73d3251",
     "deep-equal": "1.0.1",
