From f8cb28c02631b972e564b7c2d4c389fa08c0be56 Mon Sep 17 00:00:00 2001
From: Orlando Vazquez <ovazquez@gmail.com>
Date: Fri, 8 Mar 2019 09:52:28 -0800
Subject: [PATCH] TRITON-1180 cnapi waitlist ticket race if
 serverwaitlistticketrelease starts and completes during
 serverwaitlistticketcreate Reviewed by: Josh Wilsdon <josh@wilsdon.ca>
 Approved by: Josh Wilsdon <josh@wilsdon.ca>

---
 lib/endpoints/index.js    |   3 +
 lib/endpoints/waitlist.js |   3 +-
 lib/models/waitlist.js    | 717 +++++++++++++++++++++++---------------
 package.json              |   3 +-
 4 files changed, 448 insertions(+), 278 deletions(-)

diff --git a/lib/endpoints/index.js b/lib/endpoints/index.js
index b1a907c..df0dc9e 100644
--- a/lib/endpoints/index.js
+++ b/lib/endpoints/index.js
@@ -19,6 +19,7 @@ var jsprim = require('jsprim');
 
 var ModelImage = require('../models/image');
 var ModelServer = require('../models/server');
+var ModelWaitlist = require('../models/waitlist');
 
 var allocations = require('./allocations');
 var errors = require('../errors');
@@ -389,6 +390,8 @@ function attachTo(http, app) {
 
 
         send.taskCallbacks = taskCallbacks;
+        send.pendingActivationsByServer =
+            ModelWaitlist.pendingActivationsByServer;
 
         res.send(send);
     });
diff --git a/lib/endpoints/waitlist.js b/lib/endpoints/waitlist.js
index ddf598c..2c374de 100644
--- a/lib/endpoints/waitlist.js
+++ b/lib/endpoints/waitlist.js
@@ -144,9 +144,8 @@ function handlerControllerWaitlistList(req, res, next) {
 
 ControllerWaitlist.createTicket =
 function handlerControllerWaitlistCreateTicket(req, res, next) {
-    var waitlist = req.stash.server.getWaitlist();
     req.params.reqid = req.getId();
-    waitlist.createTicket(req.params, function (error, uuid, tickets) {
+    ModelWaitlist.createTicket(req.params, function (error, uuid, tickets) {
         if (error) {
             next(new restify.InternalError(error.message));
             return;
diff --git a/lib/models/waitlist.js b/lib/models/waitlist.js
index cb12338..df62745 100644
--- a/lib/models/waitlist.js
+++ b/lib/models/waitlist.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2018, Joyent, Inc.
+ * Copyright (c) 2019, Joyent, Inc.
  */
 
 /*
@@ -17,6 +17,7 @@
 
 var assert = require('assert-plus');
 var async = require('async');
+var backoff = require('backoff');
 var libuuid = require('libuuid');
 var once = require('once');
 var sprintf = require('sprintf').sprintf;
@@ -36,8 +37,9 @@ var TICKET_STATUS_FINISHED = 'finished';
 var TICKET_STATUS_QUEUED = 'queued';
 
 // Ticket modify operations
-var TICKET_OPERATION_UPDATE = 'update';
 var TICKET_OPERATION_DELETE = 'delete';
+var TICKET_OPERATION_CREATE = 'create';
+var TICKET_OPERATION_UPDATE = 'update';
 
 // Moray bucket
 var MORAY_BUCKET_WAITLIST_TICKETS = buckets.waitlist_tickets.name;
@@ -45,6 +47,9 @@ var MORAY_BUCKET_WAITLIST_TICKETS = buckets.waitlist_tickets.name;
 // How long, (in ms), between checks to moray for ticket updates
 var WAITLIST_PERIOD_MS = 500;
 
+// Period (ms) between attempts to ensure activation of tickets.
+var WAITLIST_PERIODIC_ACTIVATION_PERIOD_MS = 60 * 1000;
+
 // How long, (in ms), between attempts to clean old tickets out of moray
 var WAITLIST_CLEANUP_PERIOD_MS = 3600 * 1000;
 
@@ -92,6 +97,24 @@ function WaitlistDirectorStart() {
     WaitlistDirector.cleanupTimeout =
         setTimeout(cleanupIntervalFn, WAITLIST_CLEANUP_PERIOD_MS);
 
+    // Ensure we don't stop activating tickets.
+    activationTimerFn();
+
+    function activationTimerFn() {
+        WaitlistDirector.activationTimer = setTimeout(function () {
+            self.ensureServerQueuesHaveActiveTickets(
+            function (activateError) {
+                activationTimerFn();
+
+                if (activateError) {
+                    self.log.error({ error: activateError },
+                        'error ensuring server queues have active tickets');
+                }
+            });
+        }, WAITLIST_PERIODIC_ACTIVATION_PERIOD_MS);
+
+    }
+
     function intervalFn() {
         var params = { timestamp: lastCheck && new Date(lastCheck - 1000) };
         start = new Date();
@@ -308,6 +331,7 @@ ModelWaitlist.init = function (app) {
         ModelWaitlist[p] = ModelBase.staticFn[p];
     });
 
+    ModelWaitlist.pendingActivationsByServer = {};
     ModelWaitlist.log = app.getLog();
 };
 
@@ -584,41 +608,47 @@ function ModelWaitlistQuery(filter, findOpts, callback) {
 };
 
 
+/* BEGIN JSSTYLED */
 /*
- * Look up in moray which tickets should be activated next, given a scope and
- * id. Calls callback with active and queued tickets.
+ * Look up active and queued tickets, given a scope and id. Calls callback with
+ * an array of ticket records.
+ * Calls `callback` with an array of responses resembling:
+ *     {
+ *         ticket: ticketObj,
+ *         etag: ticketEtagString
+ *     }
  *
  * @param opts {Object}
+ * @param opts.server_uuid {String} scope/id apply to the server given by this UUID
  * @param opts.scope {String} The ticket scope
  * @param opts.id {String} The id of resource within given scope
  * @param callback {Function} `function (err, responses)`
  */
+/* END JSSTYLED */
 
-ModelWaitlist.findNextTickets =
-function modelWaitlistFindNextTickets(opts, callback) {
+ModelWaitlist.getServerQueue =
+function ModelWaitlistGetServerQueue(opts, callback) {
     var self = this;
 
+    assert.object(opts, 'opts');
     assert.string(opts.id, 'opts.id');
     assert.string(opts.scope, 'opts.scope');
     assert.string(opts.server_uuid, 'opts.server_uuid');
-    assert.optionalNumber(opts.limit, 'opts.limit');
-    assert.optionalBool(opts.omitActive, 'opts.omitActive');
-    assert.optionalUuid(opts.omitTicketUuid, 'opts.omitTicketUuid');
 
+    // Find all the tickets for a given server, scope, and id. They must be
+    // have a status of 'active' or 'queued'.
     var filter = sprintf(
         '(&' +
             '(server_uuid=%s)' +
             '(scope=%s)' +
             '(id=%s)' +
-            (opts.omitActive ? '(!(status=active))' : '') +
-            (opts.omitTicketUuid
-                ? '(!(uuid=' + opts.omitTicketUuid + '))' : '') +
-            '(!(status=finished))' +
-            '(!(status=expired))' +
-        ')', opts.server_uuid, opts.scope, opts.id);
+            '(|(status=%s)' +
+            '(status=%s))' +
+        ')',
+        opts.server_uuid, opts.scope, opts.id,
+        TICKET_STATUS_ACTIVE, TICKET_STATUS_QUEUED);
 
     var findOpts = {
-        limit: opts.limit,
         sort: {
             attribute: 'created_at',
             order: 'ASC'
@@ -632,30 +662,283 @@ function modelWaitlistFindNextTickets(opts, callback) {
             return;
         }
 
-        tickets = tickets.map(function (t) {
+        var results = tickets.map(function (t) {
             return { ticket: t.value, etag: t._etag };
         });
 
-        self.log.trace({ filter: filter, tickets: tickets },
-            'findNextTickets: found tickets');
+        self.log.debug({ filter: filter, tickets: results },
+            'getServerQueue: found tickets');
 
-        callback(err, tickets);
+        callback(err, results);
     });
 };
 
 /*
- * Update a ticket in moray, and activate the next ticket (by creation_date)
- * with the same set formed by `ticket.scope`, `ticket.server_uuid`, and
- * `ticket.id`.
+ * The WaitlistDirector will call this function periodically. This function
+ * will look at the `ModelWaitlist.pendingActivationsByServer` object, and
+ * iterate over the keys, which are UUIDs of servers which have started, but
+ * not yet completed, trying to activate the next ticket in a queue. Each item
+ * is an array of objects resembling:
+ *
+ *   { scope: 'vm', id: 'e8e94f38-3a58-11e9-9148-6362d081387f' }
+ *
+ * Every time we go to check that a ticket is active for a queue, we add an
+ * entry to this object. By doing this, we can make sure we don't get into a
+ * situation where we have queue'd tickets but none are active, when they
+ * should be.
+ *
+ * Most of the time, this function should have very little to do. It's only in
+ * the situation where we may have an extremely busy datacenter, which could
+ * lead to an increased number of etag conflicts, where even with retry/backoff
+ * it is possible we could time out and leave no tickets active. We want to
+ * make sure even in such a situation, queues are can still make forward
+ * progress.
+ */
+
+WaitlistDirector.prototype.ensureServerQueuesHaveActiveTickets =
+function WaitlistDirectorEnsureServerQueuesHaveActiveTickets(callback) {
+    var self = this;
+    var pa = ModelWaitlist.pendingActivationsByServer;
+
+    self.log.debug('ensuring tickets for %d servers', Object.keys(pa).length);
+
+    // Iterate over all servers.
+    vasync.forEachPipeline({
+        inputs: Object.keys(pa),
+        func: function _iterActivateServerQueues(server_uuid, next) {
+            activateServerQueues(server_uuid, next);
+        }
+    }, callback);
+
+    function activateServerQueues(server_uuid, cb) {
+        // Iterate over all of server's queues (scope/id groups).
+        self.log.debug('ensuring tickets for %s (%d queues)',
+            server_uuid, pa[server_uuid].length);
+
+        vasync.forEachPipeline({
+            inputs: pa[server_uuid],
+            func: function _iterActivateQueueTickets(queue, next) {
+                var opts = {
+                    server_uuid: server_uuid,
+                    scope: queue.scope,
+                    id: queue.id
+                };
+                self.log.debug(
+                    { queue: opts },
+                    'ensureServerQueuesHaveActiveTickets: activation check');
+                ModelWaitlist.activateOneTicket(opts, next);
+            }
+        }, cb);
+    }
+};
+
+
+/*
+ * Add a server/scope/id to list of waitlist queues that need to be checked
+ * periodically for activation.
+ * @param opts {Object}
+ * @param opts.server_uuid {String} Server UUID
+ * @param opts.scope {String} Waitlist scope to match
+ * @param opts.id {String} Waitlist id to match
+ */
+
+WaitlistDirector.addToPendingActivations =
+function WaitlistDirectorAddToPendingActivations(opts) {
+    var log = ModelWaitlist.log;
+    var pending = ModelWaitlist.pendingActivationsByServer;
+
+    assert.object(opts, 'opts');
+    assert.uuid(opts.server_uuid, 'opts.server_uuid');
+    assert.string(opts.scope, 'opts.scope');
+    assert.string(opts.id, 'opts.id');
+
+    log.debug('addToPendingActivations: adding %s/%s to %s',
+        opts.scope, opts.id, opts.server_uuid);
+
+    if (!pending.hasOwnProperty(opts.server_uuid)) {
+        pending[opts.server_uuid] = [];
+    }
+
+    // Check if we already have an instance (> 0) of this particular scope/id
+    // in the list for this server.
+    var foundQueue = (0 < pending[opts.server_uuid].filter(
+        function _filterFunc(i) {
+            return (i.scope === opts.scope && i.id === opts.id);
+        }).length);
+
+    if (!foundQueue) {
+        pending[opts.server_uuid].push({ scope: opts.scope, id: opts.id });
+    }
+};
+
+
+/*
+ * Remove a server/scope/id from the list of waitlist queues that need to be
+ * checked periodically for activation.
+ *
+ * @param opts {Object}
+ * @param opts.server_uuid {String} Server UUID
+ * @param opts.scope {String} Waitlist scope to match
+ * @param opts.id {String} Waitlist id to match
+ */
+
+WaitlistDirector.removeFromPendingActivations =
+function WaitlistDirectorRemoveFromPendingActivations(opts) {
+    var log = ModelWaitlist.log;
+    var pending = ModelWaitlist.pendingActivationsByServer;
+
+    assert.object(opts, 'opts');
+    assert.uuid(opts.server_uuid, 'opts.server_uuid');
+    assert.string(opts.scope, 'opts.scope');
+    assert.string(opts.id, 'opts.id');
+
+    log.debug('removeFromPendingActivations: removing %s/%s from %s',
+        opts.scope, opts.id, opts.server_uuid);
+
+    if (!pending.hasOwnProperty(opts.server_uuid)) {
+        log.debug('removeFromPendingActivations: '
+            + 'wanted to clear up %s but had no record of it',
+            opts.scope, opts.id, opts.server_uuid);
+        return;
+    }
+
+    pending[opts.server_uuid] =
+        pending[opts.server_uuid].filter(function _filterFunc(i) {
+            return !(i.scope === opts.scope && i.id === opts.id);
+        });
+
+    if (pending[opts.server_uuid].length === 0) {
+        delete pending[opts.server_uuid];
+    }
+};
+
+
+/* BEGIN JSSTYLED */
+/*
+ * Check if there are tickets with status=`active` for a given `scope`,
+ * `server_uuid` and `id`. If none match, take the oldest with
+ * `status`='queued' by `created_at` and update its status (to 'active'). Calls
+ * `callback` with the UUID of the created ticket as well as the current list
+ * of tickets for this server/scope/id.
+ *
+ * @param opts {Object}
+ * @param opts.server_uuid {String} scope/id apply to the server given by this uuid
+ * @param opts.scope {String} ticket scope
+ * @param opts.id {String} The id of resource within given scope
+ * @param callback {Function} `function (err, createdTicketUuid, arrayOfTickets)`
+ */
+/* END JSSTYLED */
+
+ModelWaitlist.activateOneTicket =
+function ModelWaitlistActivateOne(opts, callback) {
+    var self = this;
+    var ticket;
+    var etag;
+
+    assert.object(opts, 'opts');
+    assert.uuid(opts.server_uuid, 'opts.server_uuid');
+    assert.string(opts.id, 'opts.id');
+    assert.string(opts.scope, 'opts.scope');
+
+    vasync.waterfall([
+        function addToPendingActivations(next) {
+            WaitlistDirector.addToPendingActivations(opts);
+            next();
+        },
+        function getServerQueue(next) {
+            self.log.debug(opts,
+                'activateOneTicket: finding next ticket to activate');
+            ModelWaitlist.getServerQueue(opts,
+            function _onFindNextTickets(err, results) {
+                if (err) {
+                    next(err);
+                    return;
+                }
+
+                if (results.length === 0) {
+                    self.log.debug(opts,
+                        'activateOneTicket: ' +
+                        'no tickets found matching criteria');
+                    next();
+                    return;
+                }
+
+                var activeCount = results.filter(function (i) {
+                    return i.ticket.status === TICKET_STATUS_ACTIVE;
+                }).length;
+
+                if (activeCount > 1) {
+                    self.log.error(
+                        { opts: opts, results: results },
+                        'activateOneTicket: ' +
+                        'found more than one active ticket for criteria');
+                    next();
+                    return;
+                }
+
+                if (activeCount > 0) {
+                    self.log.debug(opts,
+                        'activateOneTicket: ' +
+                        'found an active ticket so nothing to do');
+                    next();
+                    return;
+                }
+
+                ticket = results[0].ticket;
+                etag = results[0].etag;
+                next();
+            });
+        },
+        function activateOldest(next) {
+            // If `ticket` is unset, it means we found an active ticket for
+            // this queue, so we can remove it from pending activations. We
+            // only care about the case when we only have queued tickets.
+            if (!ticket) {
+                WaitlistDirector.removeFromPendingActivations(opts);
+                next();
+                return;
+            }
+
+            // If `ticket` is set, we have a ticket we need to activate.
+
+            ticket.status = TICKET_STATUS_ACTIVE;
+            ticket.updated_at = (new Date()).toISOString();
+
+            ModelWaitlist.getMoray().putObject(
+                MORAY_BUCKET_WAITLIST_TICKETS,
+                ticket.uuid,
+                ticket,
+                { etag: etag },
+                function _onActivateOnePut(puterror) {
+                    if (puterror) {
+                        next(VError(puterror, 'failed to updated ticket'));
+                        return;
+                    }
+                    WaitlistDirector.removeFromPendingActivations(opts);
+                    next();
+                });
+        }
+    ], callback);
+};
+
+
+/* BEGIN JSSTYLED */
+/*
+ * Create, update or delete a ticket, and subsequently ensure if there are no
+ * active tickets for the same `ticket.scope`, `ticket.server_uuid` and
+ * `ticket.id` we take the oldest queued ticket (if any) matching the criteria
+ * and make it active.
  *
  * @param {Object} opts
- * @param {Object} opts.ticket
- * @param {String} opts.ticketEtag
- * @param {Function} callback `function (err, { ticket: ticket, etag: etag })`
+ * @param {Object} opts.operation TICKET_OPERATION_CREATE, TICKET_OPERATION_DELETE, TICKET_OPERATION_UPDATE
+ * @param {Object} opts.ticket_uuid
+ * @param {Object} opts.ticket Used as the full payload of a new ticket or a partial update to be applied o over an existing ticket
+ * @param {Function} callback `function (err)`
  */
+/* END JSSTYLED */
 
-ModelWaitlist.modifyTicketActivateNext =
-function ModelWaitlistUpdateTicketActivateNext(opts, callback) {
+ModelWaitlist.ticketOperationActivateNext =
+function ModelWaitlistTicketOperation(opts, callback) {
     var self = this;
 
     assert.object(opts, 'opts');
@@ -663,20 +946,33 @@ function ModelWaitlistUpdateTicketActivateNext(opts, callback) {
     assert.uuid(opts.ticket_uuid, 'opts.ticket_uuid');
     assert.func(callback, 'callback');
 
-    if (opts.operation === TICKET_OPERATION_UPDATE) {
-        assert.object(opts.update, 'opts.update');
-    }
+    // Only care about payload when creating or updating
+    if (opts.operation === TICKET_OPERATION_CREATE ||
+        opts.operation === TICKET_OPERATION_UPDATE) {
 
-    var moray = ModelWaitlist.getMoray();
+        assert.object(opts.payload, 'opts.payload');
+    }
 
     var ticket_uuid = opts.ticket_uuid;
     var ticket;
     var ticketEtag;
-    var batchOperations = [];
 
     vasync.waterfall([
-        // Look up ticket with given ticket uuid.
+        // In the cases of TICKET_OPERATION_DELETE and
+        // TICKET_OPERATION_UPDATE we need to look up the existing ticket
+        // so that we can submit the etag with the request.
+        // In addition, TICKET_OPERATION_UPDATE over-writes a subset of
+        // the returned ticket's values when it writes the ticket back to the
+        // database.
+
         function doGetTicket(next) {
+            if (opts.operation === TICKET_OPERATION_CREATE) {
+                ticket = opts.payload;
+                ticketEtag = null;
+                next();
+                return;
+            }
+
             ModelWaitlist.getTicket(opts.ticket_uuid,
             function _onGetTicket(geterror, result) {
                 if (geterror) {
@@ -692,143 +988,96 @@ function ModelWaitlistUpdateTicketActivateNext(opts, callback) {
                 }
 
                 self.log.debug({ result: result },
-                    'modifyTicketActivateNext: getTicket result');
+                    'ticketOperationActivateNext: getTicket result');
 
                 ticket = result.ticket;
                 ticketEtag = result.etag;
-                ticket.updated_at = (new Date()).toISOString();
-
-                // If update passed in, override the ticket values with it.
-                if (opts.update) {
-                    for (var i in opts.update) {
-                        ticket[i] = opts.update[i];
-                    }
-                }
 
                 next();
             });
         },
 
-        // Set up batch call to delete or update ticket for given ticket uuid
-        // depending on operation.
-        function doSetupBatch(next) {
-            if (opts.operation === TICKET_OPERATION_DELETE) {
-                batchOperations.push({
-                    bucket: MORAY_BUCKET_WAITLIST_TICKETS,
-                    key: ticket.uuid,
-                    operation: 'delete',
-                    options: {
-                        etag: ticketEtag
-                    }
-                });
-            } else if (opts.operation === TICKET_OPERATION_UPDATE) {
-                batchOperations.push({
-                    bucket: MORAY_BUCKET_WAITLIST_TICKETS,
-                    key: ticket.uuid,
-                    operation: 'put',
-                    value: ticket,
-                    options: {
-                        etag: ticketEtag
-                    }
-                });
-            } else {
-                self.log.error('unknown operation %s', opts.operation);
-            }
-
-            self.log.info({ operation: opts.operation,
-                batchData: batchOperations },
-                'updateTicketActivateNext: batch batchOperations');
-
-            next();
-        },
-
-        // Look up the next ticket to be activated so we can activate it at
-        // the same time as we update/delete the ticket that was passed in.
-        function doFindNextTicket(next) {
-            ModelWaitlist.findNextTickets({
-                server_uuid: ticket.server_uuid,
-                limit: 1,
-                omitActive: true,
-                omitTicketUuid: ticket.uuid,
-                id: ticket.id,
-                scope: ticket.scope
-            },
-            function onFindTicket(err, results) {
-                if (err) {
-                    next(err);
-                    return;
-                }
-
-                // If there are no more tickets to activate we can skip
-                // everything after this.
-                if (!results.length) {
-                    next();
-                    return;
-                }
-
-                var nextTicket = results[0].ticket;
-                var nextEtag = results[0].etag;
+        function doUpdates(next) {
+            var morayOpts = { etag: ticketEtag };
 
-                // If there was a subsequent ticket to our given one waiting
-                // to be activated, update its values and write it back out.
-                // Otherwise, we can skip this part.
+            if (opts.operation === TICKET_OPERATION_DELETE) {
+                ModelWaitlist.getMoray().delObject(
+                    MORAY_BUCKET_WAITLIST_TICKETS,
+                    opts.ticket_uuid,
+                    morayOpts,
+                    function (delError) {
+                        if (delError) {
+                            next(VError(delError,
+                                'failed to delete ticket %s from moray',
+                                ticket.uuid));
+                            return;
+                        }
+                        next();
+                    });
+            } else if (opts.operation === TICKET_OPERATION_UPDATE ||
+                       opts.operation === TICKET_OPERATION_CREATE) {
 
-                if (!nextTicket) {
-                    self.log.info('no ticket following update of %s',
-                        ticket.uuid);
-                    next();
-                    return;
+                // Override the ticket values.
+                for (var i in opts.payload) {
+                    ticket[i] = opts.payload[i];
                 }
 
-                nextTicket.updated_at = (new Date()).toISOString();
-                nextTicket.status = TICKET_STATUS_ACTIVE;
+                ticket.updated_at = (new Date()).toISOString();
 
-                self.log.info({ nextTicket: nextTicket },
-                    'ticket to be activated');
+                ModelWaitlist.getMoray().putObject(
+                    MORAY_BUCKET_WAITLIST_TICKETS,
+                    ticket.uuid,
+                    ticket,
+                    morayOpts,
+                    function (putError) {
+                        if (putError) {
+                            next(VError(putError,
+                                'failed to write ticket %s to moray',
+                                ticket.uuid));
+                            return;
+                        }
+                        next();
+                    });
+            } else {
+                self.log.error('unknown operation %s', opts.operation);
+            }
+        },
 
-                batchOperations.push({
-                    bucket: MORAY_BUCKET_WAITLIST_TICKETS,
-                    key: nextTicket.uuid,
-                    operation: 'put',
-                    value: nextTicket,
-                    options: {
-                        etag: nextEtag
+        // If there are tickets for this server/scope/id, make sure one of them
+        // is considered active (having `status` = 'active'). If one is not
+        // active, activate the oldest one.
+        //
+        // We'll wrap this with `backoff` so that if we get an etag conflict we
+        // can re-attempt the operation. If we get a conflict and we retry and
+        // there is an active ticket now, then can stop, having satisfied our
+        // requirement that a ticket be in status='active'.
+
+        function activateOneTicket(next) {
+            var call = backoff.call(
+                ModelWaitlist.activateOneTicket.bind(self),
+                {
+                    server_uuid: ticket.server_uuid,
+                    scope: ticket.scope,
+                    id: ticket.id
+                },
+                function _onBackoffCall(err) {
+                    if (err) {
+                        self.log.error(err,
+                            'activateOneTicket: returned error');
                     }
+                    next();
                 });
-                next();
-            });
-        },
-
-        // Actually execute the batch.
-        function batchUpdate(next) {
-            self.log.debug({
-                batch: batchOperations
-            }, 'performing batch operation to activate next ticket');
-
-            moray.batch(batchOperations, function (err, _meta) {
-                if (err &&
-                    (VError.hasCauseWithName(err,
-                        'EtagConflictError') ||
-                    (VError.hasCauseWithName(err,
-                        'UniqueAttributeError')))) {
 
-                    self.log.warn({ err: err },
-                        'modifyTicketActivateNext: batch conflict, retrying');
-
-                    self.modifyTicketActivateNext(opts, next);
-                    return;
-                } else if (err) {
-                    next(new VError(err,
-                        'updateTicketActivateNext: batch error'));
-                    return;
-                }
-
-                next();
+            call.retryIf(function _onRetryIf(err) {
+                return VError.hasCauseWithName(err, 'EtagConflictError');
             });
+            call.setStrategy(new backoff.ExponentialStrategy());
+            call.failAfter(10);
+            call.start();
         }
     ],
-    function (wferr) {
-        self.log.info({ err: wferr }, 'updateTicketActivateNext: finished');
+    function _onModifyWfEnd(wferr) {
+        self.log.debug({ err: wferr }, 'ticketOperationActivateNext: finished');
         callback(wferr);
     });
 };
@@ -836,9 +1085,10 @@ function ModelWaitlistUpdateTicketActivateNext(opts, callback) {
 
 /* BEGIN JSSTYLED */
 /*
- * Create a new ticket record and write it into moray. If there are existing
- * tickets for the same `server_uuid`, `scope` and `id`, the new ticket will
- * receive a status of 'queued'.
+ * Create a new ticket record. Ticket execution order depends on ticket age
+ * (oldest tickets first), grouped by server UUID, scope and id. Tickets are first
+ * created with a status of 'queued'. As tickets are released, subsequent
+ * tickets are activated (status=active).
  *
  * @param opts {Object}
  * @param opts.scope {String} ticket scope
@@ -847,14 +1097,13 @@ function ModelWaitlistUpdateTicketActivateNext(opts, callback) {
  * @param opts.action {OptionalString} action associated with this ticket
  * @param opts.req_id {OptionalString} restify request id
  * @param opts.extra {OptionalObject} arbitrary metadata set by caller
- * @param callback {Function} `function (err, createdTicketUuid)`
+ * @param callback {Function} `function (err, createdTicketUuid, currentTicketQueue)`
  */
 /* END JSSTYLED */
 
-ModelWaitlist.prototype.createTicket =
-function ModelWaitlistCreateTicket(opts, callback) {
-    var self = this;
 
+ModelWaitlist.createTicket =
+function ModelWaitlistCreateTicket(opts, callback) {
     assert.object(opts, 'opts');
     assert.string(opts.scope, 'opts.scope');
     assert.string(opts.id, 'opts.id');
@@ -865,93 +1114,39 @@ function ModelWaitlistCreateTicket(opts, callback) {
     assert.func(callback, 'callback');
 
     var ticket = {
-        uuid: libuuid.create(),
-        server_uuid: this.uuid,
-        scope: opts.scope,
-        id: opts.id,
-        expires_at: opts.expires_at,
+        action: opts.action,
         created_at: (new Date()).toISOString(),
-        updated_at: (new Date()).toISOString(),
+        expires_at: opts.expires_at,
+        extra: opts.extra || {},
+        id: opts.id,
         reqid: opts.req_id,
-        extra: opts.extra || {}
+        scope: opts.scope,
+        server_uuid: opts.server_uuid,
+        status: TICKET_STATUS_QUEUED,
+        updated_at: (new Date()).toISOString(),
+        uuid: libuuid.create()
     };
-
-
-    if (jsprim.hasKey(opts, 'action')) {
-        ticket.action = opts.action;
-    }
-
-    self.log.info({
-        ticket: ticket
-    }, 'creating ticket %s', ticket.uuid);
-
     var tickets;
 
     vasync.waterfall([
-        /*
-         * Check if there are existing tickets for this server/scope/id
-         * combination. If there are, we'll set this ticket's status to
-         * 'queued'. If there are no currently queued or active tickets, we'll
-         * make this one 'active'.
-         */
-        function determineWhetherToActivate(next) {
-            ModelWaitlist.findNextTickets({
-                server_uuid: self.uuid,
-                scope: opts.scope,
-                id: opts.id
-            }, function _onDetermineWhetherToActivate(err, _tickets) {
-                if (err) {
-                    next(err);
-                    return;
-                }
-
-                tickets = _tickets.map(function (t) {
-                    return t.ticket;
-                });
-
-                if (tickets.length) {
-                    ticket.status = TICKET_STATUS_QUEUED;
-                } else {
-                    ticket.status = TICKET_STATUS_ACTIVE;
-                }
-                next();
-            });
+        function doActivate(next) {
+            ModelWaitlist.ticketOperationActivateNext({
+                ticket_uuid: ticket.uuid,
+                operation: TICKET_OPERATION_CREATE,
+                payload: ticket
+            }, next);
         },
-
-        /*
-         * Write this ticket object out to moray.
-         */
-        function writeTicketToMoray(next) {
-            ModelWaitlist.getMoray().putObject(
-                MORAY_BUCKET_WAITLIST_TICKETS,
-                ticket.uuid,
-                ticket,
-                function (puterror) {
-                    if (puterror) {
-                        next(VError(puterror,
-                            'failed to write ticket %s to moray',
-                            ticket.uuid));
-                        return;
-                    }
-                    next();
-                });
-        },
-        /*
-         * Finally, look up the ticket queue one more time, and return it to
-         * the caller.
-         */
-
-        function refreshTickets(next) {
-            ModelWaitlist.findNextTickets({
-                server_uuid: self.uuid,
+        function doFind(next) {
+            // Look up and return the "next" tickets
+            ModelWaitlist.getServerQueue({
+                server_uuid: opts.server_uuid,
                 scope: opts.scope,
                 id: opts.id
-            }, function _onFindNextTickets(err, _tickets) {
-                if (err) {
-                    next(err);
+            }, function _onFindNextTickets(findErr, _tickets) {
+                if (findErr) {
+                    next(findErr);
                     return;
                 }
-
                 tickets = _tickets.map(function (t) {
                     return t.ticket;
                 });
@@ -959,9 +1154,14 @@ function ModelWaitlistCreateTicket(opts, callback) {
             });
         }
     ],
-    function endWaterfall(wferror) {
-        callback(wferror, ticket.uuid, tickets);
+    function (err) {
+        if (err) {
+            callback(err);
+            return;
+        }
+        callback(null, ticket.uuid, tickets);
     });
+
 };
 
 /**
@@ -978,10 +1178,10 @@ function ModelWaitlistExpireTicket(ticket_uuid, callback) {
 
     self.log.info({ uuid: ticket_uuid }, 'going to expire ticket');
 
-    ModelWaitlist.modifyTicketActivateNext({
+    ModelWaitlist.ticketOperationActivateNext({
         ticket_uuid: ticket_uuid,
         operation: TICKET_OPERATION_UPDATE,
-        update: {
+        payload: {
             status: TICKET_STATUS_EXPIRED
         }
     }, callback);
@@ -1005,10 +1205,10 @@ function ModelWaitlistReleaseTicket(ticket_uuid, callback) {
 
     self.log.info({ uuid: ticket_uuid }, 'going to release ticket');
 
-    ModelWaitlist.modifyTicketActivateNext({
+    ModelWaitlist.ticketOperationActivateNext({
         ticket_uuid: ticket_uuid,
         operation: TICKET_OPERATION_UPDATE,
-        update: {
+        payload: {
             status: TICKET_STATUS_FINISHED
         }
     }, callback);
@@ -1023,6 +1223,7 @@ function ModelWaitlistReleaseTicket(ticket_uuid, callback) {
  * @param ticket_uuid {String} The ticket to be released.
  * @param callback {Function} `function (err)`
  */
+
 ModelWaitlist.deleteTicket =
 function ModelWaitlistDeleteTicket(ticket_uuid, callback) {
     var self = this;
@@ -1031,7 +1232,7 @@ function ModelWaitlistDeleteTicket(ticket_uuid, callback) {
 
     self.log.info({ uuid: ticket_uuid }, 'going to delete ticket');
 
-    ModelWaitlist.modifyTicketActivateNext({
+    ModelWaitlist.ticketOperationActivateNext({
         ticket_uuid: ticket_uuid,
         operation: TICKET_OPERATION_DELETE
     }, callback);
@@ -1124,38 +1325,4 @@ ModelWaitlist.prototype.countTickets = function (callback) {
 };
 
 
-
-ModelWaitlist.prototype.updateTicket = function (uuid, params, callback) {
-    ModelWaitlist.getTicket(uuid, function (geterror, result) {
-        if (geterror) {
-            callback(
-                VError(geterror, 'failed to retrieve ticket %s', uuid));
-            return;
-        }
-
-        var ticket = result.ticket;
-
-        if (params.status) {
-            ticket.status = params.status;
-        }
-
-        ticket.updated_at = (new Date()).toISOString();
-
-        ModelWaitlist.getMoray().putObject(
-            MORAY_BUCKET_WAITLIST_TICKETS,
-            uuid,
-            ticket,
-            function (puterror) {
-                if (puterror) {
-                    callback(
-                        VError(puterror, 'failed to store updated ticket'));
-                    return;
-                }
-                callback();
-            });
-    });
-};
-
-
-
 module.exports = ModelWaitlist;
diff --git a/package.json b/package.json
index 7cbe498..92413ab 100644
--- a/package.json
+++ b/package.json
@@ -1,13 +1,14 @@
 {
   "name": "cnapi",
   "description": "SmartDataCenter Compute Node API",
-  "version": "1.21.0",
+  "version": "1.21.1",
   "author": "Joyent (joyent.com)",
   "private": true,
   "dependencies": {
     "amqp": "0.2.6",
     "assert-plus": "1.0.0",
     "async": "1.5.2",
+    "backoff": "2.5.0",
     "bunyan": "1.8.5",
     "dapi": "git+https://github.com/joyent/sdc-designation.git#296a786be98c325c9f30eff4dce16ed04047c9b5",
     "deep-object-diff": "1.1.0",
-- 
2.21.0

