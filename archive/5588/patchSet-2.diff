From 2376c3f7d6676fa3a92e626a857334eaf13d8c04 Mon Sep 17 00:00:00 2001
From: Orlando Vazquez <ovazquez@gmail.com>
Date: Thu, 14 Feb 2019 12:44:47 -0800
Subject: [PATCH] TRITON-1180 cnapi waitlist ticket race if
 serverwaitlistticketrelease starts and completes during
 serverwaitlistticketcreate

---
 lib/endpoints/waitlist.js |   3 +-
 lib/models/waitlist.js    | 422 +++++++++++++++++---------------------
 package.json              |   3 +-
 3 files changed, 188 insertions(+), 240 deletions(-)

diff --git a/lib/endpoints/waitlist.js b/lib/endpoints/waitlist.js
index 37c690c..26a3793 100644
--- a/lib/endpoints/waitlist.js
+++ b/lib/endpoints/waitlist.js
@@ -145,9 +145,8 @@ function handlerControllerWaitlistList(req, res, next) {
 
 ControllerWaitlist.createTicket =
 function handlerControllerWaitlistCreateTicket(req, res, next) {
-    var waitlist = req.stash.server.getWaitlist();
     req.params.reqid = req.getId();
-    waitlist.createTicket(req.params, function (error, uuid, tickets) {
+    ModelWaitlist.createTicket(req.params, function (error, uuid, tickets) {
         if (error) {
             next(new restify.InternalError(error.message));
             return;
diff --git a/lib/models/waitlist.js b/lib/models/waitlist.js
index cb12338..0f46e61 100644
--- a/lib/models/waitlist.js
+++ b/lib/models/waitlist.js
@@ -17,6 +17,7 @@
 
 var assert = require('assert-plus');
 var async = require('async');
+var backoff = require('backoff');
 var libuuid = require('libuuid');
 var once = require('once');
 var sprintf = require('sprintf').sprintf;
@@ -36,8 +37,9 @@ var TICKET_STATUS_FINISHED = 'finished';
 var TICKET_STATUS_QUEUED = 'queued';
 
 // Ticket modify operations
-var TICKET_OPERATION_UPDATE = 'update';
 var TICKET_OPERATION_DELETE = 'delete';
+var TICKET_OPERATION_CREATE = 'create';
+var TICKET_OPERATION_UPDATE = 'update';
 
 // Moray bucket
 var MORAY_BUCKET_WAITLIST_TICKETS = buckets.waitlist_tickets.name;
@@ -632,17 +634,92 @@ function modelWaitlistFindNextTickets(opts, callback) {
             return;
         }
 
-        tickets = tickets.map(function (t) {
+        var results = tickets.map(function (t) {
             return { ticket: t.value, etag: t._etag };
         });
 
-        self.log.trace({ filter: filter, tickets: tickets },
+        self.log.info({ filter: filter, tickets: results },
             'findNextTickets: found tickets');
 
-        callback(err, tickets);
+        callback(err, results);
     });
 };
 
+/*
+ * Check if there are tickets with status=`active` for a given `scope`,
+ * `server_uuid` and `id`. If none match, take the oldest by `created_at` and
+ * update its status (to 'active').
+ */
+
+ModelWaitlist.activateOneTicket =
+function ModelWaitlistActivateOne(opts, callback) {
+    var self = this;
+    var ticket;
+    var etag;
+
+    assert.object(opts, 'opts');
+    assert.string(opts.id, 'opts.id');
+    assert.string(opts.scope, 'opts.scope');
+    assert.string(opts.server_uuid, 'opts.server_uuid');
+    assert.optionalNumber(opts.limit, 'opts.limit');
+    assert.optionalBool(opts.omitActive, 'opts.omitActive');
+    assert.optionalUuid(opts.omitTicketUuid, 'opts.omitTicketUuid');
+
+    vasync.waterfall([
+        function findNextTickets(next) {
+            self.log.info('finding next ticket to activate');
+            ModelWaitlist.findNextTickets(opts,
+            function _onFindNextTickets(err, results) {
+                if (err) {
+                    next(err);
+                    return;
+                }
+
+                if (!results.length) {
+                    next();
+                    return;
+                }
+
+                var foundActive = (0 < results.filter(function (i) {
+                    return i.ticket.status === 'active';
+                }).length);
+
+                if (foundActive) {
+                    next();
+                    return;
+                }
+
+                ticket = results[0].ticket;
+                etag = results[0].etag;
+                next();
+            });
+        },
+        function activateOldest(next) {
+            if (!ticket) {
+                next();
+                return;
+            }
+            ticket.status = 'active';
+            ticket.updated_at = (new Date()).toISOString();
+
+            ModelWaitlist.getMoray().putObject(
+                MORAY_BUCKET_WAITLIST_TICKETS,
+                ticket.uuid,
+                ticket,
+                { etag: etag },
+                function _onPutObject(puterror) {
+                    if (puterror) {
+                        callback(
+                            VError(puterror, 'failed to updated ticket'));
+                        return;
+                    }
+                    next();
+                });
+        }
+    ], callback);
+};
+
+
 /*
  * Update a ticket in moray, and activate the next ticket (by creation_date)
  * with the same set formed by `ticket.scope`, `ticket.server_uuid`, and
@@ -667,16 +744,23 @@ function ModelWaitlistUpdateTicketActivateNext(opts, callback) {
         assert.object(opts.update, 'opts.update');
     }
 
-    var moray = ModelWaitlist.getMoray();
+    if (opts.operation === TICKET_OPERATION_CREATE) {
+        assert.object(opts.create, 'opts.create');
+    }
 
     var ticket_uuid = opts.ticket_uuid;
     var ticket;
     var ticketEtag;
-    var batchOperations = [];
 
     vasync.waterfall([
         // Look up ticket with given ticket uuid.
         function doGetTicket(next) {
+            if (opts.operation === TICKET_OPERATION_CREATE) {
+                ticket = opts.create;
+                next();
+                return;
+            }
+
             ModelWaitlist.getTicket(opts.ticket_uuid,
             function _onGetTicket(geterror, result) {
                 if (geterror) {
@@ -696,7 +780,6 @@ function ModelWaitlistUpdateTicketActivateNext(opts, callback) {
 
                 ticket = result.ticket;
                 ticketEtag = result.etag;
-                ticket.updated_at = (new Date()).toISOString();
 
                 // If update passed in, override the ticket values with it.
                 if (opts.update) {
@@ -709,122 +792,72 @@ function ModelWaitlistUpdateTicketActivateNext(opts, callback) {
             });
         },
 
-        // Set up batch call to delete or update ticket for given ticket uuid
-        // depending on operation.
-        function doSetupBatch(next) {
+        function doUpdates(next) {
+            var putOpts = {};
+
             if (opts.operation === TICKET_OPERATION_DELETE) {
-                batchOperations.push({
-                    bucket: MORAY_BUCKET_WAITLIST_TICKETS,
-                    key: ticket.uuid,
-                    operation: 'delete',
-                    options: {
-                        etag: ticketEtag
-                    }
-                });
-            } else if (opts.operation === TICKET_OPERATION_UPDATE) {
-                batchOperations.push({
-                    bucket: MORAY_BUCKET_WAITLIST_TICKETS,
-                    key: ticket.uuid,
-                    operation: 'put',
-                    value: ticket,
-                    options: {
-                        etag: ticketEtag
-                    }
-                });
+                ModelWaitlist.getMoray().delObject(
+                    MORAY_BUCKET_WAITLIST_TICKETS,
+                    opts.ticket_uuid,
+                    function (delError) {
+                        if (delError) {
+                            next(VError(delError,
+                                'failed to delete ticket %s from moray',
+                                ticket.uuid));
+                            return;
+                        }
+                        next();
+                    });
+            } else if (opts.operation === TICKET_OPERATION_UPDATE ||
+                       opts.operation === TICKET_OPERATION_CREATE) {
+
+                if (ticketEtag) {
+                    putOpts.etag = ticketEtag;
+                }
+                ticket.updated_at = (new Date()).toISOString();
+                ModelWaitlist.getMoray().putObject(
+                    MORAY_BUCKET_WAITLIST_TICKETS,
+                    ticket.uuid,
+                    ticket,
+                    { etag: ticketEtag },
+                    function (putError) {
+                        if (putError) {
+                            next(VError(putError,
+                                'failed to write ticket %s to moray',
+                                ticket.uuid));
+                            return;
+                        }
+                        next();
+                    });
             } else {
                 self.log.error('unknown operation %s', opts.operation);
             }
-
-            self.log.info({ operation: opts.operation,
-                batchData: batchOperations },
-                'updateTicketActivateNext: batch batchOperations');
-
-            next();
         },
 
-        // Look up the next ticket to be activated so we can activate it at
-        // the same time as we update/delete the ticket that was passed in.
-        function doFindNextTicket(next) {
-            ModelWaitlist.findNextTickets({
-                server_uuid: ticket.server_uuid,
-                limit: 1,
-                omitActive: true,
-                omitTicketUuid: ticket.uuid,
-                id: ticket.id,
-                scope: ticket.scope
-            },
-            function onFindTicket(err, results) {
-                if (err) {
-                    next(err);
-                    return;
-                }
-
-                // If there are no more tickets to activate we can skip
-                // everything after this.
-                if (!results.length) {
-                    next();
-                    return;
-                }
-
-                var nextTicket = results[0].ticket;
-                var nextEtag = results[0].etag;
-
-                // If there was a subsequent ticket to our given one waiting
-                // to be activated, update its values and write it back out.
-                // Otherwise, we can skip this part.
-
-                if (!nextTicket) {
-                    self.log.info('no ticket following update of %s',
-                        ticket.uuid);
-                    next();
-                    return;
-                }
-
-                nextTicket.updated_at = (new Date()).toISOString();
-                nextTicket.status = TICKET_STATUS_ACTIVE;
-
-                self.log.info({ nextTicket: nextTicket },
-                    'ticket to be activated');
-
-                batchOperations.push({
-                    bucket: MORAY_BUCKET_WAITLIST_TICKETS,
-                    key: nextTicket.uuid,
-                    operation: 'put',
-                    value: nextTicket,
-                    options: {
-                        etag: nextEtag
+        function activateOneTicket(next) {
+            self.log.warn('XXX got here');
+            var call = backoff.call(
+                ModelWaitlist.activateOneTicket.bind(self),
+                {
+                    server_uuid: ticket.server_uuid,
+                    scope: ticket.scope,
+                    id: ticket.id
+                },
+                function (err) {
+                    self.log.warn(err, 'XXX actiavetOne done');
+                    if (err) {
+                        self.log.warn(err, 'activateOneTicket: returned error');
                     }
+                    next();
                 });
-                next();
-            });
-        },
-
-        // Actually execute the batch.
-        function batchUpdate(next) {
-            self.log.debug({
-                batch: batchOperations
-            }, 'performing batch operation to activate next ticket');
-
-            moray.batch(batchOperations, function (err, _meta) {
-                if (err &&
-                    (VError.hasCauseWithName(err,
-                        'EtagConflictError') ||
-                    (VError.hasCauseWithName(err,
-                        'UniqueAttributeError')))) {
-
-                    self.log.warn({ err: err },
-                        'modifyTicketActivateNext: batch conflict, retrying');
 
-                    self.modifyTicketActivateNext(opts, next);
-                    return;
-                } else if (err) {
-                    next(new VError(err,
-                        'updateTicketActivateNext: batch error'));
-                    return;
-                }
-
-                next();
+            call.retryIf(function (err) {
+                self.log.warn(err, 'XXX retryIf');
+                return VError.hasCauseWithName(err, 'EtagConflictError');
             });
+            call.setStrategy(new backoff.ExponentialStrategy());
+            call.failAfter(10);
+            call.start();
         }
     ],
     function (wferr) {
@@ -836,9 +869,10 @@ function ModelWaitlistUpdateTicketActivateNext(opts, callback) {
 
 /* BEGIN JSSTYLED */
 /*
- * Create a new ticket record and write it into moray. If there are existing
- * tickets for the same `server_uuid`, `scope` and `id`, the new ticket will
- * receive a status of 'queued'.
+ * Create a new ticket record. Ticket execution order depends on ticket age
+ * (oldest tickets first), grouped by server UUID, scope and id. Tickets are first
+ * created with a status of 'queued'. As tickets are released, subsequent
+ * tickets are activated (status=active).
  *
  * @param opts {Object}
  * @param opts.scope {String} ticket scope
@@ -851,7 +885,8 @@ function ModelWaitlistUpdateTicketActivateNext(opts, callback) {
  */
 /* END JSSTYLED */
 
-ModelWaitlist.prototype.createTicket =
+
+ModelWaitlist.createTicket =
 function ModelWaitlistCreateTicket(opts, callback) {
     var self = this;
 
@@ -865,102 +900,48 @@ function ModelWaitlistCreateTicket(opts, callback) {
     assert.func(callback, 'callback');
 
     var ticket = {
-        uuid: libuuid.create(),
-        server_uuid: this.uuid,
-        scope: opts.scope,
-        id: opts.id,
-        expires_at: opts.expires_at,
+        action: opts.action,
         created_at: (new Date()).toISOString(),
-        updated_at: (new Date()).toISOString(),
+        expires_at: opts.expires_at,
+        extra: opts.extra || {},
+        id: opts.id,
         reqid: opts.req_id,
-        extra: opts.extra || {}
+        scope: opts.scope,
+        server_uuid: opts.server_uuid,
+        status: TICKET_STATUS_QUEUED,
+        updated_at: (new Date()).toISOString(),
+        uuid: libuuid.create()
     };
 
+    self.log.info({ uuid: ticket.uuid }, 'going to create ticket');
 
-    if (jsprim.hasKey(opts, 'action')) {
-        ticket.action = opts.action;
-    }
-
-    self.log.info({
-        ticket: ticket
-    }, 'creating ticket %s', ticket.uuid);
-
-    var tickets;
-
-    vasync.waterfall([
-        /*
-         * Check if there are existing tickets for this server/scope/id
-         * combination. If there are, we'll set this ticket's status to
-         * 'queued'. If there are no currently queued or active tickets, we'll
-         * make this one 'active'.
-         */
-        function determineWhetherToActivate(next) {
-            ModelWaitlist.findNextTickets({
-                server_uuid: self.uuid,
-                scope: opts.scope,
-                id: opts.id
-            }, function _onDetermineWhetherToActivate(err, _tickets) {
-                if (err) {
-                    next(err);
-                    return;
-                }
+    ModelWaitlist.modifyTicketActivateNext({
+        ticket_uuid: ticket.uuid,
+        operation: TICKET_OPERATION_CREATE,
+        create: ticket
+    }, function (err) {
+        if (err) {
+            callback(err);
+            return;
+        }
 
-                tickets = _tickets.map(function (t) {
-                    return t.ticket;
-                });
+        ModelWaitlist.findNextTickets({
+            server_uuid: opts.server_uuid,
+            scope: opts.scope,
+            id: opts.id
+        }, function _onFindNextTickets(findErr, _tickets) {
+            if (findErr) {
+                callback(findErr);
+                return;
+            }
 
-                if (tickets.length) {
-                    ticket.status = TICKET_STATUS_QUEUED;
-                } else {
-                    ticket.status = TICKET_STATUS_ACTIVE;
-                }
-                next();
+            var tickets = _tickets.map(function (t) {
+                return t.ticket;
             });
-        },
 
-        /*
-         * Write this ticket object out to moray.
-         */
-        function writeTicketToMoray(next) {
-            ModelWaitlist.getMoray().putObject(
-                MORAY_BUCKET_WAITLIST_TICKETS,
-                ticket.uuid,
-                ticket,
-                function (puterror) {
-                    if (puterror) {
-                        next(VError(puterror,
-                            'failed to write ticket %s to moray',
-                            ticket.uuid));
-                        return;
-                    }
-                    next();
-                });
-        },
-        /*
-         * Finally, look up the ticket queue one more time, and return it to
-         * the caller.
-         */
-
-        function refreshTickets(next) {
-            ModelWaitlist.findNextTickets({
-                server_uuid: self.uuid,
-                scope: opts.scope,
-                id: opts.id
-            }, function _onFindNextTickets(err, _tickets) {
-                if (err) {
-                    next(err);
-                    return;
-                }
+            callback(null, ticket.uuid, tickets);
+        });
 
-                tickets = _tickets.map(function (t) {
-                    return t.ticket;
-                });
-                next();
-            });
-        }
-    ],
-    function endWaterfall(wferror) {
-        callback(wferror, ticket.uuid, tickets);
     });
 };
 
@@ -1023,6 +1004,7 @@ function ModelWaitlistReleaseTicket(ticket_uuid, callback) {
  * @param ticket_uuid {String} The ticket to be released.
  * @param callback {Function} `function (err)`
  */
+
 ModelWaitlist.deleteTicket =
 function ModelWaitlistDeleteTicket(ticket_uuid, callback) {
     var self = this;
@@ -1124,38 +1106,4 @@ ModelWaitlist.prototype.countTickets = function (callback) {
 };
 
 
-
-ModelWaitlist.prototype.updateTicket = function (uuid, params, callback) {
-    ModelWaitlist.getTicket(uuid, function (geterror, result) {
-        if (geterror) {
-            callback(
-                VError(geterror, 'failed to retrieve ticket %s', uuid));
-            return;
-        }
-
-        var ticket = result.ticket;
-
-        if (params.status) {
-            ticket.status = params.status;
-        }
-
-        ticket.updated_at = (new Date()).toISOString();
-
-        ModelWaitlist.getMoray().putObject(
-            MORAY_BUCKET_WAITLIST_TICKETS,
-            uuid,
-            ticket,
-            function (puterror) {
-                if (puterror) {
-                    callback(
-                        VError(puterror, 'failed to store updated ticket'));
-                    return;
-                }
-                callback();
-            });
-    });
-};
-
-
-
 module.exports = ModelWaitlist;
diff --git a/package.json b/package.json
index 285b84d..08ee5ec 100644
--- a/package.json
+++ b/package.json
@@ -1,13 +1,14 @@
 {
   "name": "cnapi",
   "description": "SmartDataCenter Compute Node API",
-  "version": "1.19.4",
+  "version": "1.19.5",
   "author": "Joyent (joyent.com)",
   "private": true,
   "dependencies": {
     "amqp": "0.2.6",
     "assert-plus": "1.0.0",
     "async": "1.5.2",
+    "backoff": "2.5.0",
     "bunyan": "1.8.5",
     "dapi": "git+https://github.com/joyent/sdc-designation.git#e70e8e91f97496a7df3140dd061b1a48b73d3251",
     "deep-equal": "1.0.1",
-- 
2.21.0

