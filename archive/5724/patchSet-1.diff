commit 0ed81bc4af67b38f875317e74c98dcf9bb6dc063
Author: Dave Eddy <dave@daveeddy.com>
Date:   2019-03-06T14:01:43-05:00 (7 months ago)
    
    joyent/electric-boray#5 code cleanup from electric-moray fork

diff --git a/lib/bucket_moray_client.js b/lib/bucket_moray_client.js
deleted file mode 100644
index ac6c679..0000000
--- a/lib/bucket_moray_client.js
+++ /dev/null
@@ -1,91 +0,0 @@
-/*
- * This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/.
- */
-
-/*
- * Copyright (c) 2019, Joyent, Inc.
- */
-
-var assert = require('assert-plus');
-var clone = require('clone');
-var fs = require('fs');
-var boray = require('boray');
-var url = require('url');
-var verror = require('verror');
-
-/*
- * Create moray clients in order to interact with moray instances.  Available
- * moray clients are listed in the ring configuration in LevelDB, which we
- * access in electric moray via node-fash.
- */
-function createClient(options, callback) {
-    assert.object(options, 'options');
-    assert.object(options.log, 'options.log');
-    // assert.object(options.ring, 'options.ring');
-    assert.array(options.pnodes, 'options.pnodes');
-    assert.object(options.morayOptions, 'options.morayOptions');
-    assert.func(callback, 'options.callback');
-
-    var log = options.log;
-
-    var clientMap = {};
-    var clientArray = [];
-
-    options.dataDirector.getPnodes(function (err, pnodes) {
-        if (err) {
-            throw new verror.VError(err, 'unable to get pnodes');
-        }
-
-        assert.arrayOfString(pnodes, 'pnodes');
-
-        pnodes.forEach(function (pnode) {
-            var pnodeUrl = url.parse(pnode);
-            assert.string(pnodeUrl.port, 'pnodeUrl.port');
-            assert.string(pnodeUrl.hostname, 'pnodeUrl.hostname');
-
-            log.info({
-                url: pnodeUrl
-            }, 'creating moray client');
-
-            var morayargs = clone(options.morayOptions);
-            if (!morayargs.cueballOptions) {
-                morayargs.cueballOptions = {};
-            }
-            morayargs.unwrapErrors = true;
-            morayargs.host = pnodeUrl.hostname;
-            morayargs.cueballOptions.defaultPort = parseInt(pnodeUrl.port, 10);
-            morayargs.log = options.log.child({
-                component: 'moray-client-' + pnodeUrl.hostname
-            });
-
-            var client = boray.createClient(morayargs);
-            clientMap[pnode] = client;
-            clientArray.push(client);
-
-            if (clientArray.length === pnodes.length) {
-                // write ready cookie when clients have connected
-                log.info('all moray clients instantiated writing ready cookie');
-                try {
-                    fs.writeFileSync('/var/tmp/electric-moray-ready', null);
-                } catch (e) {
-                    throw new verror.VError(e, 'unable to write ready cookie');
-                }
-            }
-        });
-
-        if (clientArray.length <= 0) {
-            throw new verror.VError('No moray clients exist!');
-        }
-
-        return callback(null, {
-            map: clientMap,
-            array: clientArray
-        });
-    });
-}
-
-module.exports = {
-    createClient: createClient
-};
diff --git a/lib/bucket_server.js b/lib/bucket_server.js
deleted file mode 100644
index 58f0859..0000000
--- a/lib/bucket_server.js
+++ /dev/null
@@ -1,877 +0,0 @@
-/*
- * This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/.
- */
-
-/*
- * Copyright (c) 2019, Joyent, Inc.
- */
-
-var assert = require('assert-plus');
-var artedi = require('artedi');
-var fast = require('fast');
-var fs = require('fs');
-var kang = require('kang');
-var net = require('net');
-var os = require('os');
-var restify = require('restify');
-var uuid = require('node-uuid');
-var vasync = require('vasync');
-var verror = require('verror');
-
-var moray_client = require('./moray_client');
-var errors = require('./errors');
-var data_placement = require('./data_placement');
-
-var InvocationError = errors.InvocationError;
-
-var KANG_VERSION = '1.2.0';
-
-var CB_ARGS_SCHEMA = [
-    { name: 'owner', type: 'string' },
-    { name: 'name', type: 'string' }
-];
-
-var DB_ARGS_SCHEMA = [
-    { name: 'owner', type: 'string' },
-    { name: 'name', type: 'string' }
-];
-
-var LB_ARGS_SCHEMA = [
-    { name: 'owner', type: 'string' }
-];
-
-var GB_ARGS_SCHEMA = [
-    { name: 'owner', type: 'string' },
-    { name: 'name', type: 'string' }
-];
-
-var GO_ARGS_SCHEMA = [
-    { name: 'owner', type: 'string' },
-    { name: 'bucket_id', type: 'string' },
-    { name: 'name', type: 'string' }
-];
-
-var PO_ARGS_SCHEMA = [
-    { name: 'owner', type: 'string' },
-    { name: 'bucket_id', type: 'string' },
-    { name: 'name', type: 'string' },
-    { name: 'content_length', type: 'number' },
-    { name: 'content_md5', type: 'string' },
-    { name: 'content_type', type: 'string' },
-    { name: 'headers', type: 'object' },
-    { name: 'sharks', type: 'object' },
-    { name: 'properties', type: 'object' }
-];
-
-var LO_ARGS_SCHEMA = [
-    { name: 'owner', type: 'string' },
-    { name: 'bucket_id', type: 'string' }
-];
-
-function createServer(options, callback) {
-    assert.object(options, 'options');
-    assert.func(callback, 'callback');
-
-    var log = options.log;
-    var opts = {
-        log: options.log
-    };
-
-    // remove ready flag
-    log.info('server.createServer: removing ready cookie on startup');
-    try {
-        fs.unlinkSync('/var/tmp/electric-moray-ready');
-    } catch (e) {
-        // ignore failures if file DNE
-    }
-
-    data_placement.createDataDirector({
-        log: options.log
-    }, function (err, dataDirector) {
-        if (err) {
-            throw new verror.VError(err, 'unable to instantiate data director');
-        }
-
-        opts.dataDirector = dataDirector;
-
-        log.info('creating moray clients');
-        moray_client.createBucketClient({
-            pnodes: opts.dataDirector.getPnodes(),
-            morayOptions: options.morayOptions,
-            log: options.log
-        }, function (cErr, clients) {
-            if (cErr) {
-                throw new verror.VError(cErr, 'unable to create moray clients');
-            }
-
-            opts.clients = clients;
-            // opts.indexShards = options.ringCfg.indexShards;
-
-            var labels = {
-                datacenter: options.datacenter,
-                server: options.server_uuid,
-                zonename: os.hostname(),
-                pid: process.pid
-            };
-
-            var collector = artedi.createCollector({
-                labels: labels
-            });
-
-            var socket = net.createServer({ 'allowHalfOpen': true });
-            var server = new fast.FastServer({
-                collector: collector,
-                log: log.child({ component: 'fast' }),
-                server: socket
-            });
-
-            var methods = [
-                { rpcmethod: 'getbucket', rpchandler: getBucket(opts) },
-                { rpcmethod: 'createbucket', rpchandler: createBucket(opts) },
-                { rpcmethod: 'deletebucket', rpchandler: delBucket(opts) },
-                { rpcmethod: 'listbuckets', rpchandler: listBuckets(opts) },
-                { rpcmethod: 'getobject', rpchandler: getObject(opts) },
-                { rpcmethod: 'putobject', rpchandler: putObject(opts) },
-                { rpcmethod: 'deleteobject', rpchandler: delObject(opts) },
-                { rpcmethod: 'listobjects', rpchandler: listObjects(opts) }
-            ];
-
-            methods.forEach(function (rpc) {
-                server.registerRpcMethod(rpc);
-            });
-
-            var kangOpts = {
-                service_name: 'electric-moray',
-                version: KANG_VERSION,
-                uri_base: '/kang',
-                ident: os.hostname + '/' + process.pid,
-                list_types: server.kangListTypes.bind(server),
-                list_objects: server.kangListObjects.bind(server),
-                get: server.kangGetObject.bind(server),
-                stats: server.kangStats.bind(server)
-            };
-
-            var monitorServer = restify.createServer({
-                name: 'Monitor'
-            });
-
-            monitorServer.get('/kang/.*', kang.knRestifyHandler(kangOpts));
-
-            monitorServer.get('/metrics',
-                function getMetricsHandler(req, res, next) {
-                    req.on('end', function () {
-                        assert.ok(collector, 'collector');
-                        collector.collect(artedi.FMT_PROM,
-                            function (cerr, metrics) {
-                                if (cerr) {
-                                    next(new verror.VError(err));
-                                    return;
-                                }
-                                res.setHeader('Content-Type',
-                                    'text/plain; version 0.0.4');
-                                res.send(metrics);
-                        });
-                        next();
-                    });
-                    req.resume();
-            });
-
-            monitorServer.listen(options.monitorPort, options.bindip,
-                function () {
-                    log.info('monitor server started on port %d',
-                        options.monitorPort);
-            });
-
-            socket.on('listening', function () {
-                log.info('moray listening on %d', options.port);
-                callback(null, {
-                    dataDirector: opts.dataDirector,
-                    // ring: opts.ring,
-                    clientList: Object.keys(opts.clients.map)
-                });
-            });
-
-            socket.on('error', function (serr) {
-                log.error(serr, 'server error');
-            });
-
-            socket.listen(options.port, options.bindip);
-        });
-    });
-}
-
-function invalidArgs(rpc, argv, types) {
-    var route = rpc.methodName();
-    var len = types.length;
-
-    if (argv.length !== len) {
-        rpc.fail(new InvocationError(
-            '%s expects %d argument%s %d',
-            route, len, len === 1 ? '' : 's', argv.length));
-        return true;
-    }
-
-    for (var i = 0; i < len; i++) {
-        var name = types[i].name;
-        var type = types[i].type;
-        var val = argv[i];
-
-        // 'array' is not a primitive type in javascript, but certain
-        // rpcs expect them. Since typeof ([]) === 'object', we need to
-        // special case this check to account for these expectations.
-        if (type === 'array') {
-            if (!Array.isArray(val)) {
-                rpc.fail(new InvocationError('%s expects "%s" (args[%d]) to ' +
-                            'be of type array but received type %s instead',
-                            route, name, i, typeof (val)));
-                return true;
-            }
-            continue;
-        }
-
-        if (type === 'object' && val === null) {
-            rpc.fail(new InvocationError('%s expects "%s" (args[%d]) to ' +
-                        'be an object but received the value "null"', route,
-                        name, i));
-            return true;
-        }
-
-        if (typeof (argv[i]) !== types[i].type) {
-            rpc.fail(new InvocationError('%s expects "%s" (args[%d]) to be ' +
-                'of type %s but received type %s instead (%j)', route, name, i,
-                type, typeof (val), val));
-            return true;
-        }
-    }
-
-    return false;
-}
-
-
-function createBucket(options) {
-    assert.object(options, 'options');
-    assert.object(options.log, 'options.log');
-    assert.object(options.clients, 'options.clients');
-
-    function _createBucket(rpc) {
-        var argv = rpc.argv();
-
-        if (invalidArgs(rpc, argv, CB_ARGS_SCHEMA)) {
-            return;
-        }
-
-        var o = argv[0];
-        var b = argv[1];
-
-        var id = options.req_id || uuid.v1();
-
-        // dtrace['createbucket-start'].fire(function () {
-        //     return ([msgid, id, b, k, opts._value]);
-        // });
-
-        var log = options.log.child({
-            req_id: id
-        });
-
-        log.debug({
-            owner: o,
-            bucket: b
-        }, 'createBucket: entered');
-
-        options.dataDirector.getBucketLocation(o, b, function (err, location) {
-            if (err) {
-                rpc.fail(err);
-                return;
-            }
-
-            var vnode = location.vnode;
-            var pnode = location.pnode;
-            log.info('pnode: ' + pnode);
-            var client = options.clients.map[pnode];
-
-            log.info('client: ' + client);
-
-            client.createBucket(o, b, vnode, function (pErr, meta) {
-                log.debug({
-                    err: pErr,
-                    meta: meta
-                }, 'createBucket: returned');
-
-                // dtrace['createbucket-done'].fire(function () {
-                //     return ([msgid]);
-                // });
-
-                if (pErr) {
-                    rpc.fail(pErr);
-                } else {
-                    // Add shard information to the response.
-                    meta._node = location;
-
-                    rpc.write(meta);
-                    rpc.end();
-                }
-            });
-        });
-    }
-
-    return _createBucket;
-}
-
-
-function getBucket(options) {
-    assert.object(options, 'options');
-    assert.object(options.log, 'options.log');
-    assert.object(options.clients, 'options.clients');
-
-    function _getBucket(rpc) {
-        var argv = rpc.argv();
-
-        if (invalidArgs(rpc, argv, GB_ARGS_SCHEMA)) {
-            return;
-        }
-
-        var o = argv[0];
-        var b = argv[1];
-
-        var id = options.req_id || uuid.v1();
-        var log = options.log.child({
-            req_id: id
-        });
-
-        log.debug({
-            owner: o,
-            bucket: b
-        }, 'getBucket: entered');
-
-        options.dataDirector.getBucketLocation(o, b, function (err, location) {
-            if (err) {
-                rpc.fail(err);
-                return;
-            }
-
-            var vnode = location.vnode;
-            var pnode = location.pnode;
-
-            options.clients.map[pnode].getBucket(o, b, vnode,
-                function (gErr, rbucket) {
-                log.debug({
-                    err: gErr,
-                    bucket: rbucket
-                }, 'getBucket: returned');
-
-
-                /*
-                 * serialize the deserialized bucket response. To make this
-                 * faster, we could:
-                 * 1) modify the moray client to make deserializing optional.
-                 * 2) directly hook up the streams by modifying the underlying
-                 * node-fast stream.
-                 */
-                if (gErr) {
-                    rpc.fail(gErr);
-                } else {
-                    rpc.write(rbucket);
-                    rpc.end();
-                }
-            });
-        });
-    }
-
-    return _getBucket;
-}
-
-
-function delBucket(options) {
-    assert.object(options, 'options');
-    assert.object(options.log, 'options.log');
-    assert.object(options.clients, 'options.clients');
-
-    function _delBucket(rpc) {
-        var argv = rpc.argv();
-
-        if (invalidArgs(rpc, argv, DB_ARGS_SCHEMA)) {
-            return;
-        }
-
-        var o = argv[0];
-        var b = argv[1];
-
-        var id = options.req_id || uuid.v1();
-        var log = options.log.child({
-            req_id: id
-        });
-
-        log.debug({
-            owner: o,
-            bucket: b
-        }, 'deleteBucket: entered');
-
-        options.dataDirector.getBucketLocation(o, b, function (err, location) {
-            if (err) {
-                rpc.fail(err);
-                return;
-            }
-
-            var vnode = location.vnode;
-            var pnode = location.pnode;
-
-            options.clients.map[pnode].deleteBucket(o, b, vnode,
-                function (gErr, rbucket) {
-                log.debug({
-                    err: gErr,
-                    bucket: rbucket
-                }, 'deleteBucket: returned');
-
-
-                /*
-                 * serialize the deserialized bucket response. To make this
-                 * faster, we could:
-                 * 1) modify the moray client to make deserializing optional.
-                 * 2) directly hook up the streams by modifying the underlying
-                 * node-fast stream.
-                 */
-                if (gErr) {
-                    rpc.fail(gErr);
-                } else {
-                    // rpc.write(rbucket);
-                    rpc.end();
-                }
-            });
-        });
-    }
-
-    return _delBucket;
-}
-
-function listBuckets(options) {
-    assert.object(options, 'options');
-    assert.object(options.log, 'options.log');
-    assert.object(options.clients, 'options.clients');
-
-    function _listBuckets(rpc) {
-        var argv = rpc.argv();
-
-        if (invalidArgs(rpc, argv, LB_ARGS_SCHEMA)) {
-            return;
-        }
-
-        var o = argv[0];
-
-        var id = options.req_id || uuid.v1();
-        var log = options.log.child({
-            req_id: id
-        });
-
-        log.debug({
-            owner: o
-        }, 'listBuckets: entered');
-
-        var pnodes = Object.keys(options.clients.map);
-        var vnodes = {};
-
-        // convert pnodes to vnodes
-        pnodes.forEach(function (pnode) {
-            var nodes = options.dataDirector.getVnodes(pnode);
-            nodes.forEach(function (vnode) {
-                vnodes[vnode] = options.clients.map[pnode];
-            });
-        });
-
-        vasync.forEachPipeline({
-            inputs: Object.keys(vnodes),
-            func: function (vnode, cb) {
-                var client = vnodes[vnode];
-
-                vnode = parseInt(vnode, 10);
-
-                log.debug({vnode: vnode, owner: o}, 'listBuckets vasync');
-
-                var res = client.listBuckets(o, vnode);
-
-                /*
-                 * Format the record to look like a find/search result
-                 */
-                res.on('record', function (record) {
-                    /*
-                     * name: r.key.split('/').pop(),
-                     * etag: r.value.etag,
-                     * size: r.value.contentLength,
-                     * type: r.value.type,
-                     * contentType: r.value.contentType,
-                     * contentMD5: r.value.contentMD5,
-                     * mtime: new Date(r.value.mtime).toISOString()
-                     */
-                    var obj = {
-                        key: record.name,
-                        value: {
-                            type: 'bucket',
-                            mtime: record.created
-                        }
-                    };
-                    rpc.write(obj);
-                });
-
-                res.on('end', function () {
-                    cb();
-                });
-
-                res.once('error', function (err) {
-                    cb(err);
-                });
-            }
-        }, function (err, results) {
-            if (err) {
-                log.error(err, 'listBuckets error');
-                rpc.fail(err);
-                return;
-            }
-
-            rpc.end();
-        });
-    }
-
-    return _listBuckets;
-}
-
-
-function putObject(options) {
-    assert.object(options, 'options');
-    assert.object(options.log, 'options.log');
-    assert.object(options.clients, 'options.clients');
-
-    function _putObject(rpc) {
-        var argv = rpc.argv();
-
-        if (invalidArgs(rpc, argv, PO_ARGS_SCHEMA)) {
-            return;
-        }
-
-        var o = argv[0];
-        var b = argv[1];
-        var k = argv[2];
-        var content_length = argv[3];
-        var content_md5 = argv[4];
-        var content_type = argv[5];
-        var headers = argv[6];
-        var sharks = argv[7];
-        var props = argv[8];
-
-        var id = options.req_id || uuid.v1();
-
-        // dtrace['putobject-start'].fire(function () {
-        //     return ([msgid, id, b, k, opts._value]);
-        // });
-
-        var log = options.log.child({
-            req_id: id
-        });
-
-        log.debug({
-            owner: o,
-            bucket: b,
-            key: k
-        }, 'putObject: entered');
-
-        options.dataDirector.getObjectLocation(o, b, k,
-            function (err, location) {
-
-            if (err) {
-                rpc.fail(err);
-                return;
-            }
-
-            var vnode = location.vnode;
-            var pnode = location.pnode;
-            var client = options.clients.map[pnode];
-
-            if (props.constructor === Object &&
-                Object.keys(props).length === 0) {
-
-                props = null;
-            }
-
-            client.putObject(o, b, k, content_length, content_md5, content_type,
-                headers, sharks, props, vnode, function (pErr, meta) {
-                log.debug({
-                    err: pErr,
-                    meta: meta
-                }, 'putObject: returned');
-
-                // dtrace['putobject-done'].fire(function () {
-                //     return ([msgid]);
-                // });
-
-                if (pErr) {
-                    rpc.fail(pErr);
-                } else {
-                    // Add shard information to the response.
-                    meta._node = location;
-
-                    rpc.write(meta);
-                    rpc.end();
-                }
-            });
-        });
-    }
-
-    return _putObject;
-}
-
-
-function getObject(options) {
-    assert.object(options, 'options');
-    assert.object(options.log, 'options.log');
-    assert.object(options.clients, 'options.clients');
-
-    function _getObject(rpc) {
-        var argv = rpc.argv();
-
-        if (invalidArgs(rpc, argv, GO_ARGS_SCHEMA)) {
-            return;
-        }
-
-        var o = argv[0];
-        var b = argv[1];
-        var k = argv[2];
-
-        var id = options.req_id || uuid.v1();
-
-        // dtrace['getobject-start'].fire(function () {
-        //     return ([msgid, id, b, k]);
-        // });
-
-        var log = options.log.child({
-            req_id: id
-        });
-
-        log.debug({
-            owner: o,
-            bucket: b,
-            key: k
-        }, 'getObject: entered');
-
-        options.dataDirector.getObjectLocation(o, b, k,
-            function (err, location) {
-
-            if (err) {
-                rpc.fail(err);
-                return;
-            }
-
-            var pnode = location.pnode;
-            var vnode = location.vnode;
-            var client = options.clients.map[pnode];
-
-            client.getObject(o, b, k, vnode, function (gErr, obj) {
-                log.debug({
-                    err: gErr,
-                    obj: obj
-                }, 'getObject: returned');
-
-                // MANTA-1400: set the vnode info for debugging purposes
-                if (obj) {
-                    obj._node = location;
-                }
-
-                log.debug({
-                    obj: obj
-                }, 'sanitized object');
-
-                // dtrace['getobject-done'].fire(function () {
-                //     return ([msgid, obj]);
-                // });
-
-                if (gErr) {
-                    rpc.fail(gErr);
-                } else {
-                    rpc.write(obj);
-                    rpc.end();
-                }
-            });
-        });
-    }
-
-    return _getObject;
-}
-
-function delObject(options) {
-    assert.object(options, 'options');
-    assert.object(options.log, 'options.log');
-    assert.object(options.clients, 'options.clients');
-
-    function _delObject(rpc) {
-        var argv = rpc.argv();
-
-        if (invalidArgs(rpc, argv, GO_ARGS_SCHEMA)) {
-            return;
-        }
-
-        var o = argv[0];
-        var b = argv[1];
-        var k = argv[2];
-
-        var id = options.req_id || uuid.v1();
-
-        // dtrace['getobject-start'].fire(function () {
-        //     return ([msgid, id, b, k]);
-        // });
-
-        var log = options.log.child({
-            req_id: id
-        });
-
-        log.debug({
-            owner: o,
-            bucket: b,
-            key: k
-        }, 'delObject: entered');
-
-        options.dataDirector.getObjectLocation(o, b, k,
-            function (err, location) {
-
-            if (err) {
-                rpc.fail(err);
-                return;
-            }
-
-            var pnode = location.pnode;
-            var vnode = location.vnode;
-            var client = options.clients.map[pnode];
-
-            client.deleteObject(o, b, k, vnode, function (gErr, obj) {
-                log.debug({
-                    err: gErr,
-                    obj: obj
-                }, 'delObject: returned');
-
-                // MANTA-1400: set the vnode info for debugging purposes
-                if (obj) {
-                    obj._node = location;
-                }
-
-                log.debug({
-                    obj: obj
-                }, 'sanitized object');
-
-                // dtrace['getobject-done'].fire(function () {
-                //     return ([msgid, obj]);
-                // });
-
-                if (gErr) {
-                    rpc.fail(gErr);
-                } else {
-                    rpc.end();
-                }
-            });
-        });
-    }
-
-    return _delObject;
-}
-
-function listObjects(options) {
-    assert.object(options, 'options');
-    assert.object(options.log, 'options.log');
-    assert.object(options.clients, 'options.clients');
-
-    function _listObjects(rpc) {
-        var argv = rpc.argv();
-
-        if (invalidArgs(rpc, argv, LO_ARGS_SCHEMA)) {
-            return;
-        }
-
-        var owner = argv[0];
-        var bucket_id = argv[1];
-
-        var id = options.req_id || uuid.v1();
-
-        // dtrace['getobject-start'].fire(function () {
-        //     return ([msgid, id, b, k]);
-        // });
-
-        var log = options.log.child({
-            req_id: id
-        });
-
-        log.debug({
-            owner: owner,
-            bucket_id: bucket_id
-        }, 'listObjects: entered');
-
-        var pnodes = Object.keys(options.clients.map);
-        var vnodes = {};
-
-        // convert pnodes to vnodes
-        pnodes.forEach(function (pnode) {
-            var nodes = options.dataDirector.getVnodes(pnode);
-            nodes.forEach(function (vnode) {
-                vnodes[vnode] = options.clients.map[pnode];
-            });
-        });
-
-        vasync.forEachPipeline({
-            inputs: Object.keys(vnodes),
-            func: function (vnode, cb) {
-                var client = vnodes[vnode];
-
-                vnode = parseInt(vnode, 10);
-
-                log.debug({vnode: vnode, owner: owner}, 'listObjects vasync');
-
-                var res = client.listObjects(owner, bucket_id, vnode);
-
-                /*
-                 * Format the record to look like a find/search result
-                 */
-                res.on('record', function (record) {
-                    /*
-                     * name: r.key.split('/').pop(),
-                     * etag: r.value.etag,
-                     * size: r.value.contentLength,
-                     * type: r.value.type,
-                     * contentType: r.value.contentType,
-                     * contentMD5: r.value.contentMD5,
-                     * mtime: new Date(r.value.mtime).toISOString()
-                     */
-                    var obj = {
-                        key: record.name,
-                        value: {
-                            type: 'bucketobject',
-                            etag: record.id,
-                            mtime: record.created,
-                            contentType: record.content_type,
-                            contentMD5: record.content_md5,
-                            contentLength: record.content_length
-                        }
-                    };
-                    rpc.write(obj);
-                });
-
-                res.on('end', function () {
-                    cb();
-                });
-
-                res.once('error', function (err) {
-                    cb(err);
-                });
-            }
-        }, function (err, results) {
-            if (err) {
-                log.error(err, 'listObjects error');
-                rpc.fail(err);
-                return;
-            }
-
-            rpc.end();
-        });
-    }
-
-    return _listObjects;
-}
-
-module.exports = {
-    createServer: createServer
-};
diff --git a/lib/bucket_status_server.js b/lib/bucket_status_server.js
deleted file mode 100644
index 968ffd1..0000000
--- a/lib/bucket_status_server.js
+++ /dev/null
@@ -1,72 +0,0 @@
-/*
- * This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/.
- */
-
-/*
- * Copyright (c) 2019, Joyent, Inc.
- */
-
-var assert = require('assert-plus');
-var restify = require('restify');
-
-/*
- * Serves HTTP requests for electric-moray process state access.
- */
-function createStatusServer(options, callback) {
-    assert.object(options, 'options');
-    assert.object(options.log, 'options.log');
-    assert.number(options.port, 'options.port');
-    assert.object(options.dataDirector, 'options.dataDirector');
-    assert.arrayOfString(options.clientList, 'options.clientList');
-    assert.func(callback, 'callback');
-
-    var opts = {
-        log: options.log,
-        startTime: (new Date()).toISOString(),
-        clientList: options.clientList,
-        indexShards: options.indexShards
-    };
-
-    /*
-     * REST API server to access the status of an electric-moray instance.
-     */
-    var server = restify.createServer({
-        name: 'electric-moray-status'
-    });
-
-    server.get('/status', createStatusHandler(opts));
-
-    server.on('error', callback);
-
-    server.listen(options.port, function () {
-        opts.log.info('status server listening on port %d', options.port);
-        callback();
-    });
-
-}
-
-/*
- * Exposes the current configured state of an electric-moray process, providing
- * some details about this process and SMF identity.  This information enables
- * other systems to correlate the output of svcs(1) with this status object.
- */
-function createStatusHandler(opts) {
-    return (function statusHandler(req, res, next) {
-        var body = {
-            smf_fmri: process.env.SMF_FMRI || null,
-            pid: process.pid,
-            start_time: opts.startTime,
-            client_list: opts.clientList,
-            index_shards: opts.indexShards
-        };
-
-        res.send(200, body);
-        next();
-    });
-}
-
-module.exports = {
-    createStatusServer: createStatusServer
-};
diff --git a/lib/index.js b/lib/index.js
index cb38a6f..762e149 100644
--- a/lib/index.js
+++ b/lib/index.js
@@ -10,12 +10,8 @@
 
 var server = require('./server');
 var status_server = require('./status_server');
-var bucket_server = require('./bucket_server');
-var bucket_status_server = require('./bucket_status_server');
 
 module.exports = {
     createServer: server.createServer,
-    createStatusServer: status_server.createStatusServer,
-    createBucketServer: bucket_server.createServer,
-    createBucketStatusServer: bucket_status_server.createStatusServer
+    createStatusServer: status_server.createStatusServer
 };
diff --git a/lib/server.js b/lib/server.js
index fdaa7fe..58f0859 100644
--- a/lib/server.js
+++ b/lib/server.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2018, Joyent, Inc.
+ * Copyright (c) 2019, Joyent, Inc.
  */
 
 var assert = require('assert-plus');
@@ -17,106 +17,62 @@ var net = require('net');
 var os = require('os');
 var restify = require('restify');
 var uuid = require('node-uuid');
-var util = require('util');
 var vasync = require('vasync');
 var verror = require('verror');
 
 var moray_client = require('./moray_client');
-var dtrace = require('./dtrace');
 var errors = require('./errors');
-var schema = require('./schema');
-var ring = require('./ring');
+var data_placement = require('./data_placement');
 
 var InvocationError = errors.InvocationError;
-var ReadOnlyError = errors.ReadOnlyError;
 
-var ALLOWED_BATCH_OPS = [
-    'put',
-    'delete'
-];
-var READ_ONLY = 'ro';
 var KANG_VERSION = '1.2.0';
 
-var B_ARGS_SCHEMA = [
-    { name: 'requests', type: 'array' },
-    { name: 'options', type: 'object' }
-];
-
 var CB_ARGS_SCHEMA = [
-    { name: 'bucket', type: 'string' },
-    { name: 'config', type: 'object' },
-    { name: 'options', type: 'object' }
+    { name: 'owner', type: 'string' },
+    { name: 'name', type: 'string' }
 ];
 
 var DB_ARGS_SCHEMA = [
-    { name: 'bucket', type: 'string' },
-    { name: 'options', type: 'object' }
+    { name: 'owner', type: 'string' },
+    { name: 'name', type: 'string' }
 ];
 
-var DO_ARGS_SCHEMA = [
-    { name: 'bucket', type: 'string' },
-    { name: 'key', type: 'string' },
-    { name: 'options', type: 'object' }
-];
-
-var DM_ARGS_SCHEMA = [
-    { name: 'bucket', type: 'string' },
-    { name: 'filter', type: 'string' },
-    { name: 'options', type: 'object' }
-];
-
-var FO_ARGS_SCHEMA = [
-    { name: 'bucket', type: 'string' },
-    { name: 'filter', type: 'string' },
-    { name: 'options', type: 'object' }
+var LB_ARGS_SCHEMA = [
+    { name: 'owner', type: 'string' }
 ];
 
 var GB_ARGS_SCHEMA = [
-    { name: 'options', type: 'object' },
-    { name: 'bucket', type: 'string' }
+    { name: 'owner', type: 'string' },
+    { name: 'name', type: 'string' }
 ];
 
 var GO_ARGS_SCHEMA = [
-    { name: 'bucket', type: 'string' },
-    { name: 'key', type: 'string' },
-    { name: 'options', type: 'object' }
-];
-
-var GT_ARGS_SCHEMA = [
-    { name: 'options', type: 'object' }
+    { name: 'owner', type: 'string' },
+    { name: 'bucket_id', type: 'string' },
+    { name: 'name', type: 'string' }
 ];
 
 var PO_ARGS_SCHEMA = [
-    { name: 'bucket', type: 'string' },
-    { name: 'key', type: 'string' },
-    { name: 'value', type: 'object' },
-    { name: 'options', type: 'object' }
-];
-
-var SQL_ARGS_SCHEMA = [
-    { name: 'statement', type: 'string' },
-    { name: 'values', type: 'array' },
-    { name: 'options', type: 'object' }
-];
-
-var UB_ARGS_SCHEMA = [
+    { name: 'owner', type: 'string' },
+    { name: 'bucket_id', type: 'string' },
     { name: 'name', type: 'string' },
-    { name: 'config', type: 'object' },
-    { name: 'options', type: 'object' }
+    { name: 'content_length', type: 'number' },
+    { name: 'content_md5', type: 'string' },
+    { name: 'content_type', type: 'string' },
+    { name: 'headers', type: 'object' },
+    { name: 'sharks', type: 'object' },
+    { name: 'properties', type: 'object' }
 ];
 
-var UO_ARGS_SCHEMA = [
-    { name: 'bucket', type: 'string' },
-    { name: 'fields', type: 'object' },
-    { name: 'filter', type: 'string' },
-    { name: 'options', type: 'object' }
+var LO_ARGS_SCHEMA = [
+    { name: 'owner', type: 'string' },
+    { name: 'bucket_id', type: 'string' }
 ];
 
-
 function createServer(options, callback) {
     assert.object(options, 'options');
     assert.func(callback, 'callback');
-    assert.string(options.ringLocation, 'options.ringLocation');
 
     var log = options.log;
     var opts = {
@@ -131,20 +87,18 @@ function createServer(options, callback) {
         // ignore failures if file DNE
     }
 
-    ring.loadRing({
-        log: options.log,
-        location: options.ringLocation,
-        leveldbCfg: options.ringCfg.leveldbCfg
-    }, function (err, _ring) {
+    data_placement.createDataDirector({
+        log: options.log
+    }, function (err, dataDirector) {
         if (err) {
-            throw new verror.VError(err, 'unable to instantiate hash ring');
+            throw new verror.VError(err, 'unable to instantiate data director');
         }
 
-        opts.ring = _ring;
+        opts.dataDirector = dataDirector;
 
         log.info('creating moray clients');
-        moray_client.createClient({
-            ring: opts.ring,
+        moray_client.createBucketClient({
+            pnodes: opts.dataDirector.getPnodes(),
             morayOptions: options.morayOptions,
             log: options.log
         }, function (cErr, clients) {
@@ -153,7 +107,7 @@ function createServer(options, callback) {
             }
 
             opts.clients = clients;
-            opts.indexShards = options.ringCfg.indexShards;
+            // opts.indexShards = options.ringCfg.indexShards;
 
             var labels = {
                 datacenter: options.datacenter,
@@ -174,19 +128,14 @@ function createServer(options, callback) {
             });
 
             var methods = [
-                { rpcmethod: 'batch', rpchandler: batch(opts) },
-                { rpcmethod: 'createBucket', rpchandler: createBucket(opts) },
-                { rpcmethod: 'delBucket', rpchandler: delBucket(opts) },
-                { rpcmethod: 'delObject', rpchandler: delObject(opts) },
-                { rpcmethod: 'deleteMany', rpchandler: deleteMany(opts) },
-                { rpcmethod: 'findObjects', rpchandler: findObjects(opts) },
-                { rpcmethod: 'getBucket', rpchandler: getBucket(opts) },
-                { rpcmethod: 'getObject', rpchandler: getObject(opts) },
-                { rpcmethod: 'getTokens', rpchandler: getTokens(opts) },
-                { rpcmethod: 'putObject', rpchandler: putObject(opts) },
-                { rpcmethod: 'sql', rpchandler: sql(opts) },
-                { rpcmethod: 'updateBucket', rpchandler: updateBucket(opts) },
-                { rpcmethod: 'updateObjects', rpchandler: updateObjects(opts) }
+                { rpcmethod: 'getbucket', rpchandler: getBucket(opts) },
+                { rpcmethod: 'createbucket', rpchandler: createBucket(opts) },
+                { rpcmethod: 'deletebucket', rpchandler: delBucket(opts) },
+                { rpcmethod: 'listbuckets', rpchandler: listBuckets(opts) },
+                { rpcmethod: 'getobject', rpchandler: getObject(opts) },
+                { rpcmethod: 'putobject', rpchandler: putObject(opts) },
+                { rpcmethod: 'deleteobject', rpchandler: delObject(opts) },
+                { rpcmethod: 'listobjects', rpchandler: listObjects(opts) }
             ];
 
             methods.forEach(function (rpc) {
@@ -238,7 +187,8 @@ function createServer(options, callback) {
             socket.on('listening', function () {
                 log.info('moray listening on %d', options.port);
                 callback(null, {
-                    ring: opts.ring,
+                    dataDirector: opts.dataDirector,
+                    // ring: opts.ring,
                     clientList: Object.keys(opts.clients.map)
                 });
             });
@@ -258,7 +208,8 @@ function invalidArgs(rpc, argv, types) {
 
     if (argv.length !== len) {
         rpc.fail(new InvocationError(
-            '%s expects %d argument%s', route, len, len === 1 ? '' : 's'));
+            '%s expects %d argument%s %d',
+            route, len, len === 1 ? '' : 's', argv.length));
         return true;
     }
 
@@ -289,8 +240,8 @@ function invalidArgs(rpc, argv, types) {
 
         if (typeof (argv[i]) !== types[i].type) {
             rpc.fail(new InvocationError('%s expects "%s" (args[%d]) to be ' +
-                'of type %s but received type %s instead', route, name, i,
-                type, typeof (val)));
+                'of type %s but received type %s instead (%j)', route, name, i,
+                type, typeof (val), val));
             return true;
         }
     }
@@ -298,83 +249,11 @@ function invalidArgs(rpc, argv, types) {
     return false;
 }
 
-/*
- * Returns a list of pnodes that are not safe for write operations. Parameters
- * are a bunyan logger for the child process that called this function, and an
- * options hash containing:
- *      "indexShards"       an array of index pnodes from our configuration file
- *      "clients"           a list of moray client tracking objects
- */
-function listReadOnlyPnodes(log, options) {
-    assert.object(log, 'log');
-    assert.object(options, 'options');
-    assert.arrayOfObject(options.indexShards, 'options.indexShards');
-    assert.object(options.clients, 'options.clients');
-
-    log.debug({
-        indexShards: options.indexShards,
-        clients: options.clients
-    }, 'listReadOnlyPnodes: entered');
-
-    var pnodes = Object.keys(options.clients.map);
-    var readOnlyPnodes = pnodes.filter(function (pnode) {
-        return (isReadOnlyPnode(log, options.indexShards, pnode));
-    });
-
-    return readOnlyPnodes;
-}
-
-/*
- * Checks if a moray client is set to read-only mode. Parameters are as follows:
- *      "log"               a bunyan logger
- *      "indexShards"       an array of index pnodes from our configuration file
- *      "pnode"             a physical node name
- */
-function isReadOnlyPnode(log, indexShards, pnode) {
-    assert.object(log, 'log');
-    assert.arrayOfObject(indexShards, 'indexShards');
-    assert.string(pnode, 'pnode');
-
-    log.debug({
-        indexShards: indexShards,
-        pnode: pnode
-    }, 'isReadOnlyPnode: entered');
-
-    var readOnlyStatus = null;
-    for (var i = 0; i < indexShards.length; i++) {
-        var shard = indexShards[i];
-        assert.optionalBool(shard.readOnly, 'shard.readOnly');
-        assert.string(shard.host, 'shard.host');
-        var shard_url = 'tcp://' + shard.host + ':2020';
-        if (shard_url === pnode) {
-            /*
-             * A shard in indexShards may not have a 'readOnly' field, which
-             * would mean it is not set to read-only mode.
-             */
-            readOnlyStatus = !!shard.readOnly;
-            return readOnlyStatus;
-        }
-    }
-
-    /*
-     * If no shard's host field in indexShards matches the pnode passed to this
-     * function, we are in an inconsistent state, and it is safer to assume that
-     * the pnode is read-only than the alternative, which may result in writes
-     * in error.
-     */
-    log.warn({
-        indexShards: indexShards,
-        pnode: pnode
-    }, 'isReadOnlyPnode: pnode not found in indexShards');
-    return true;
-}
-
 
 function createBucket(options) {
     assert.object(options, 'options');
     assert.object(options.log, 'options.log');
     assert.object(options.clients, 'options.clients');
-    assert.object(options.indexShards, 'options.indexShards');
 
     function _createBucket(rpc) {
         var argv = rpc.argv();
@@ -383,63 +262,55 @@ function createBucket(options) {
             return;
         }
 
-        var name = argv[0];
-        var cfg = argv[1];
-        var opts = argv[2];
+        var o = argv[0];
+        var b = argv[1];
+
+        var id = options.req_id || uuid.v1();
+
+        // dtrace['createbucket-start'].fire(function () {
+        //     return ([msgid, id, b, k, opts._value]);
+        // });
 
-        var id = opts.req_id || uuid.v1();
         var log = options.log.child({
             req_id: id
         });
 
         log.debug({
-            bucket: name,
-            cfg: cfg,
-            opts: opts
+            owner: o,
+            bucket: b
         }, 'createBucket: entered');
 
-        if (options.ring.ro_) {
-            log.debug({
-                bucket: name,
-                cfg: cfg,
-                opts: opts,
-                ro: options.ring.ro_
-            }, 'createBucket: failed shard is read only');
-            rpc.fail(new ReadOnlyError());
-            return;
-        }
-        var err = [];
-        var done = 0;
+        options.dataDirector.getBucketLocation(o, b, function (err, location) {
+            if (err) {
+                rpc.fail(err);
+                return;
+            }
 
-        var readOnlyPnodes = listReadOnlyPnodes(log, options);
-        if (readOnlyPnodes.length > 0) {
-            rpc.fail(new ReadOnlyError(readOnlyPnodes.join(', ')));
-            return;
-        }
+            var vnode = location.vnode;
+            var pnode = location.pnode;
+            log.info('pnode: ' + pnode);
+            var client = options.clients.map[pnode];
+
+            log.info('client: ' + client);
 
-        options.clients.array.forEach(function (client) {
-            client.createBucket(name, cfg, opts, function (err2) {
+            client.createBucket(o, b, vnode, function (pErr, meta) {
                 log.debug({
-                    err: err2,
-                    client: client.host
+                    err: pErr,
+                    meta: meta
                 }, 'createBucket: returned');
 
-                if (err2) {
-                    err.push(err2);
-                }
+                // dtrace['createbucket-done'].fire(function () {
+                //     return ([msgid]);
+                // });
 
-                if (++done === options.clients.array.length) {
-                    var multiError = err[0]
-                        ? new verror.MultiError(err) : null;
-                    log.debug({
-                        err: multiError
-                    }, 'createBucket: finished all shards');
-
-                    if (multiError) {
-                        rpc.fail(multiError);
-                    } else {
-                        rpc.end();
-                    }
+                if (pErr) {
+                    rpc.fail(pErr);
+                } else {
+                    // Add shard information to the response.
+                    meta._node = location;
+
+                    rpc.write(meta);
+                    rpc.end();
                 }
             });
         });
@@ -448,6 +319,7 @@ function createBucket(options) {
     return _createBucket;
 }
 
+
 function getBucket(options) {
     assert.object(options, 'options');
     assert.object(options.log, 'options.log');
@@ -460,34 +332,36 @@ function getBucket(options) {
             return;
         }
 
-        var opts = argv[0];
-        var bucket = argv[1];
+        var o = argv[0];
+        var b = argv[1];
 
-        var id = opts.req_id || uuid.v1();
+        var id = options.req_id || uuid.v1();
         var log = options.log.child({
             req_id: id
         });
 
         log.debug({
-            bucket: bucket,
-            opts: opts
+            owner: o,
+            bucket: b
         }, 'getBucket: entered');
 
-        // randomly pick a client -- since all bucket configs are the same;
-        options.ring.getNode(uuid(), uuid(), function (err, hNode) {
+        options.dataDirector.getBucketLocation(o, b, function (err, location) {
             if (err) {
                 rpc.fail(err);
                 return;
             }
 
-            var pnode = hNode.pnode;
-            options.clients.map[pnode].getBucket(bucket, opts,
+            var vnode = location.vnode;
+            var pnode = location.pnode;
+
+            options.clients.map[pnode].getBucket(o, b, vnode,
                 function (gErr, rbucket) {
                 log.debug({
                     err: gErr,
                     bucket: rbucket
                 }, 'getBucket: returned');
 
+
                 /*
                  * serialize the deserialized bucket response. To make this
                  * faster, we could:
@@ -498,22 +372,6 @@ function getBucket(options) {
                 if (gErr) {
                     rpc.fail(gErr);
                 } else {
-                    rbucket.index = JSON.stringify(rbucket.index);
-                    rbucket.pre.forEach(function (fn, index) {
-                        rbucket.pre[index] = fn.toString();
-                    });
-                    rbucket.pre = JSON.stringify(rbucket.pre);
-                    rbucket.post.forEach(function (fn, index) {
-                        rbucket.post[index] = fn.toString();
-                    });
-                    rbucket.post = JSON.stringify(rbucket.post);
-                    rbucket.options = JSON.stringify(rbucket.options);
-                    rbucket.mtime = JSON.stringify(rbucket.mtime.toString());
-                    if (rbucket.hasOwnProperty('reindex_active')) {
-                        rbucket.reindex_active = JSON.stringify(
-                            rbucket.reindex_active);
-                    }
-
                     rpc.write(rbucket);
                     rpc.end();
                 }
@@ -524,232 +382,232 @@ function getBucket(options) {
     return _getBucket;
 }
 
-function updateBucket(options) {
+
+function delBucket(options) {
     assert.object(options, 'options');
     assert.object(options.log, 'options.log');
     assert.object(options.clients, 'options.clients');
 
-    function _updateBucket(rpc) {
+    function _delBucket(rpc) {
         var argv = rpc.argv();
 
-        if (invalidArgs(rpc, argv, UB_ARGS_SCHEMA)) {
+        if (invalidArgs(rpc, argv, DB_ARGS_SCHEMA)) {
             return;
         }
 
-        var name = argv[0];
-        var cfg = argv[1];
-        var opts = argv[2];
+        var o = argv[0];
+        var b = argv[1];
 
-        var id = opts.req_id || uuid.v1();
+        var id = options.req_id || uuid.v1();
         var log = options.log.child({
             req_id: id
         });
 
         log.debug({
-            bucket: name,
-            cfg: cfg,
-            opts: opts
-        }, 'updateBucket: entered');
-
-        if (options.ring.ro_) {
-            log.debug({
-                bucket: name,
-                cfg: cfg,
-                opts: opts,
-                ro: options.ring.ro_
-            }, 'updateBucket: failed shard is read only');
-            rpc.fail(new ReadOnlyError());
-            return;
-        }
+            owner: o,
+            bucket: b
+        }, 'deleteBucket: entered');
 
-        var err = [];
-        var done = 0;
+        options.dataDirector.getBucketLocation(o, b, function (err, location) {
+            if (err) {
+                rpc.fail(err);
+                return;
+            }
 
-        var readOnlyPnodes = listReadOnlyPnodes(log, options);
-        if (readOnlyPnodes.length > 0) {
-            rpc.fail(new ReadOnlyError(readOnlyPnodes.join(', ')));
-            return;
-        }
+            var vnode = location.vnode;
+            var pnode = location.pnode;
 
-        options.clients.array.forEach(function (client) {
-            client.updateBucket(name, cfg, opts, function (err2) {
+            options.clients.map[pnode].deleteBucket(o, b, vnode,
+                function (gErr, rbucket) {
                 log.debug({
-                    err: err2
-                }, 'updateBucket: returned');
+                    err: gErr,
+                    bucket: rbucket
+                }, 'deleteBucket: returned');
 
-                if (err2) {
-                    err.push(err2);
-                }
 
-                if (++done === options.clients.array.length) {
-                    var multiError = err[0] ?
-                        new verror.MultiError(err) : null;
-                    log.debug({
-                        err: multiError
-                    }, 'updateBucket: finished all shards');
-
-                    if (multiError) {
-                        rpc.fail(multiError);
-                    } else {
-                        rpc.end();
-                    }
+                /*
+                 * serialize the deserialized bucket response. To make this
+                 * faster, we could:
+                 * 1) modify the moray client to make deserializing optional.
+                 * 2) directly hook up the streams by modifying the underlying
+                 * node-fast stream.
+                 */
+                if (gErr) {
+                    rpc.fail(gErr);
+                } else {
+                    // rpc.write(rbucket);
+                    rpc.end();
                 }
             });
         });
     }
 
-    return _updateBucket;
+    return _delBucket;
 }
 
-function delBucket(options) {
+function listBuckets(options) {
     assert.object(options, 'options');
     assert.object(options.log, 'options.log');
     assert.object(options.clients, 'options.clients');
 
-    function _delBucket(rpc) {
+    function _listBuckets(rpc) {
         var argv = rpc.argv();
 
-        if (invalidArgs(rpc, argv, DB_ARGS_SCHEMA)) {
+        if (invalidArgs(rpc, argv, LB_ARGS_SCHEMA)) {
             return;
         }
 
-        var name = argv[0];
-        var opts = argv[1];
+        var o = argv[0];
 
-        var id = opts.req_id || uuid.v1();
+        var id = options.req_id || uuid.v1();
         var log = options.log.child({
             req_id: id
         });
 
         log.debug({
-            bucket: name,
-            opts: opts
-        }, 'delBucket: entered');
-
-        if (options.ring.ro_) {
-            log.debug({
-                bucket: name,
-                opts: opts,
-                ro: options.ring.ro_
-            }, 'deleteBucket: failed shard is read only');
-            rpc.fail(new ReadOnlyError());
-            return;
-        }
+            owner: o
+        }, 'listBuckets: entered');
 
-        var err = [];
-        var done = 0;
+        var pnodes = Object.keys(options.clients.map);
+        var vnodes = {};
 
-        var readOnlyPnodes = listReadOnlyPnodes(log, options);
-        if (readOnlyPnodes.length > 0) {
-            rpc.fail(new ReadOnlyError(readOnlyPnodes.join(', ')));
-            return;
-        }
+        // convert pnodes to vnodes
+        pnodes.forEach(function (pnode) {
+            var nodes = options.dataDirector.getVnodes(pnode);
+            nodes.forEach(function (vnode) {
+                vnodes[vnode] = options.clients.map[pnode];
+            });
+        });
 
-        options.clients.array.forEach(function (client) {
-            client.delBucket(name, opts, function (err2) {
-                log.debug({
-                    err: err2
-                }, 'delBucket: returned');
+        vasync.forEachPipeline({
+            inputs: Object.keys(vnodes),
+            func: function (vnode, cb) {
+                var client = vnodes[vnode];
 
-                if (err2) {
-                    err.push(err2);
-                }
+                vnode = parseInt(vnode, 10);
 
-                if (++done === options.clients.array.length) {
-                    var multiError = err[0] ?
-                        new verror.MultiError(err) : null;
-                    log.debug({
-                        err: multiError
-                    }, 'delBucket: finished all shards');
-
-                    if (multiError) {
-                        rpc.fail(multiError);
-                    } else {
-                        rpc.end();
-                    }
-                }
-            });
+                log.debug({vnode: vnode, owner: o}, 'listBuckets vasync');
+
+                var res = client.listBuckets(o, vnode);
+
+                /*
+                 * Format the record to look like a find/search result
+                 */
+                res.on('record', function (record) {
+                    /*
+                     * name: r.key.split('/').pop(),
+                     * etag: r.value.etag,
+                     * size: r.value.contentLength,
+                     * type: r.value.type,
+                     * contentType: r.value.contentType,
+                     * contentMD5: r.value.contentMD5,
+                     * mtime: new Date(r.value.mtime).toISOString()
+                     */
+                    var obj = {
+                        key: record.name,
+                        value: {
+                            type: 'bucket',
+                            mtime: record.created
+                        }
+                    };
+                    rpc.write(obj);
+                });
+
+                res.on('end', function () {
+                    cb();
+                });
+
+                res.once('error', function (err) {
+                    cb(err);
+                });
+            }
+        }, function (err, results) {
+            if (err) {
+                log.error(err, 'listBuckets error');
+                rpc.fail(err);
+                return;
+            }
+
+            rpc.end();
         });
     }
 
-    return _delBucket;
+    return _listBuckets;
 }
 
+
 function putObject(options) {
     assert.object(options, 'options');
     assert.object(options.log, 'options.log');
     assert.object(options.clients, 'options.clients');
 
     function _putObject(rpc) {
-        var msgid = rpc.requestId();
         var argv = rpc.argv();
 
         if (invalidArgs(rpc, argv, PO_ARGS_SCHEMA)) {
             return;
         }
 
-        var b = argv[0];
-        var k = argv[1];
-        var v = argv[2];
-        var opts = argv[3];
+        var o = argv[0];
+        var b = argv[1];
+        var k = argv[2];
+        var content_length = argv[3];
+        var content_md5 = argv[4];
+        var content_type = argv[5];
+        var headers = argv[6];
+        var sharks = argv[7];
+        var props = argv[8];
 
-        var id = opts.req_id || uuid.v1();
+        var id = options.req_id || uuid.v1();
 
-        dtrace['putobject-start'].fire(function () {
-            return ([msgid, id, b, k, opts._value]);
-        });
+        // dtrace['putobject-start'].fire(function () {
+        //     return ([msgid, id, b, k, opts._value]);
+        // });
 
         var log = options.log.child({
             req_id: id
         });
 
         log.debug({
+            owner: o,
             bucket: b,
-            key: k,
-            value: v,
-            opts: opts
+            key: k
         }, 'putObject: entered');
 
-        options.ring.getNode(b, k, function (err, node) {
+        options.dataDirector.getObjectLocation(o, b, k,
+            function (err, location) {
+
             if (err) {
                 rpc.fail(err);
                 return;
             }
-            if (node.data && node.data === READ_ONLY) {
-                log.debug({
-                    bucket: b,
-                    key: k,
-                    value: v,
-                    opts: opts,
-                    node: node
-                }, 'putObject: failed vnode is read only');
-                rpc.fail(new ReadOnlyError());
-                return;
-            }
-            v.vnode = node.vnode;
-            var pnode = node.pnode;
+
+            var vnode = location.vnode;
+            var pnode = location.pnode;
             var client = options.clients.map[pnode];
 
-            if (isReadOnlyPnode(log, options.indexShards, pnode)) {
-                rpc.fail(new ReadOnlyError(pnode));
-                return;
+            if (props.constructor === Object &&
+                Object.keys(props).length === 0) {
+
+                props = null;
             }
 
-            client.putObject(b, k, v, opts, function (pErr, meta) {
+            client.putObject(o, b, k, content_length, content_md5, content_type,
+                headers, sharks, props, vnode, function (pErr, meta) {
                 log.debug({
                     err: pErr,
                     meta: meta
                 }, 'putObject: returned');
 
-                dtrace['putobject-done'].fire(function () {
-                    return ([msgid]);
-                });
+                // dtrace['putobject-done'].fire(function () {
+                //     return ([msgid]);
+                // });
 
                 if (pErr) {
                     rpc.fail(pErr);
                 } else {
                     // Add shard information to the response.
-                    meta._node = node;
+                    meta._node = location;
 
                     rpc.write(meta);
                     rpc.end();
@@ -768,67 +626,62 @@ function getObject(options) {
     assert.object(options.clients, 'options.clients');
 
     function _getObject(rpc) {
-        var msgid = rpc.requestId();
         var argv = rpc.argv();
 
         if (invalidArgs(rpc, argv, GO_ARGS_SCHEMA)) {
             return;
         }
 
-        var b = argv[0];
-        var k = argv[1];
-        var opts = argv[2];
+        var o = argv[0];
+        var b = argv[1];
+        var k = argv[2];
 
-        var id = opts.req_id || uuid.v1();
+        var id = options.req_id || uuid.v1();
 
-        dtrace['getobject-start'].fire(function () {
-            return ([msgid, id, b, k]);
-        });
+        // dtrace['getobject-start'].fire(function () {
+        //     return ([msgid, id, b, k]);
+        // });
 
         var log = options.log.child({
             req_id: id
         });
 
         log.debug({
+            owner: o,
             bucket: b,
-            key: k,
-            opts: opts
+            key: k
         }, 'getObject: entered');
 
-        options.ring.getNode(b, k, function (err, node) {
+        options.dataDirector.getObjectLocation(o, b, k,
+            function (err, location) {
+
             if (err) {
                 rpc.fail(err);
                 return;
             }
-            var pnode = node.pnode;
+
+            var pnode = location.pnode;
+            var vnode = location.vnode;
             var client = options.clients.map[pnode];
-            client.getObject(b, k, opts, function (gErr, obj) {
+
+            client.getObject(o, b, k, vnode, function (gErr, obj) {
                 log.debug({
                     err: gErr,
                     obj: obj
                 }, 'getObject: returned');
 
-                // delete the vnode from the value, as the vnode is only used
-                // internally
-                if (obj && obj.value) {
-                    delete obj.value.vnode;
-                }
-                if (obj && obj._value) {
-                    delete obj._value.vnode;
-                }
-
                 // MANTA-1400: set the vnode info for debugging purposes
                 if (obj) {
-                    obj._node = node;
+                    obj._node = location;
                 }
 
                 log.debug({
                     obj: obj
                 }, 'sanitized object');
 
-                dtrace['getobject-done'].fire(function () {
-                    return ([msgid, obj]);
-                });
+                // dtrace['getobject-done'].fire(function () {
+                //     return ([msgid, obj]);
+                // });
 
                 if (gErr) {
                     rpc.fail(gErr);
@@ -849,68 +702,65 @@ function delObject(options) {
     assert.object(options.clients, 'options.clients');
 
     function _delObject(rpc) {
-        var msgid = rpc.requestId();
         var argv = rpc.argv();
 
-        if (invalidArgs(rpc, argv, DO_ARGS_SCHEMA)) {
+        if (invalidArgs(rpc, argv, GO_ARGS_SCHEMA)) {
             return;
         }
 
-        var b = argv[0];
-        var k = argv[1];
-        var opts = argv[2];
+        var o = argv[0];
+        var b = argv[1];
+        var k = argv[2];
 
-        var id = opts.req_id || uuid.v1();
+        var id = options.req_id || uuid.v1();
 
-        dtrace['delobject-start'].fire(function () {
-            return ([msgid, id, b, k]);
-        });
+        // dtrace['getobject-start'].fire(function () {
+        //     return ([msgid, id, b, k]);
+        // });
 
         var log = options.log.child({
             req_id: id
         });
 
         log.debug({
+            owner: o,
             bucket: b,
-            key: k,
-            opts: opts
+            key: k
         }, 'delObject: entered');
 
-        options.ring.getNode(b, k, function (err, node) {
+        options.dataDirector.getObjectLocation(o, b, k,
+            function (err, location) {
+
             if (err) {
                 rpc.fail(err);
                 return;
             }
-            if (node.data && node.data === READ_ONLY) {
-                log.debug({
-                    bucket: b,
-                    key: k,
-                    opts: opts,
-                    node: node
-                }, 'delObject: failed vnode is read only');
-                rpc.fail(new ReadOnlyError());
-                return;
-            }
 
-            var pnode = node.pnode;
+            var pnode = location.pnode;
+            var vnode = location.vnode;
             var client = options.clients.map[pnode];
 
-            if (isReadOnlyPnode(log, options.indexShards, pnode)) {
-                rpc.fail(new ReadOnlyError(pnode));
-                return;
-            }
-
-            client.delObject(b, k, opts, function (dErr) {
+            client.deleteObject(o, b, k, vnode, function (gErr, obj) {
                 log.debug({
-                    err: dErr
+                    err: gErr,
+                    obj: obj
                 }, 'delObject: returned');
 
-                dtrace['delobject-done'].fire(function () {
-                    return ([msgid]);
-                });
+                // MANTA-1400: set the vnode info for debugging purposes
+                if (obj) {
+                    obj._node = location;
+                }
 
-                if (dErr) {
-                    rpc.fail(dErr);
+                log.debug({
+                    obj: obj
+                }, 'sanitized object');
+
+                // dtrace['getobject-done'].fire(function () {
+                //     return ([msgid, obj]);
+                // });
+
+                if (gErr) {
+                    rpc.fail(gErr);
                 } else {
                     rpc.end();
                 }
@@ -921,450 +771,105 @@ function delObject(options) {
     return _delObject;
 }
 
-
-function findObjects(options) {
+function listObjects(options) {
     assert.object(options, 'options');
     assert.object(options.log, 'options.log');
     assert.object(options.clients, 'options.clients');
 
-    function _findObjects(rpc) {
-        var msgid = rpc.requestId();
+    function _listObjects(rpc) {
         var argv = rpc.argv();
 
-        if (invalidArgs(rpc, argv, FO_ARGS_SCHEMA)) {
+        if (invalidArgs(rpc, argv, LO_ARGS_SCHEMA)) {
             return;
         }
 
-        var b = argv[0];
-        var f = argv[1];
-        var opts = argv[2];
+        var owner = argv[0];
+        var bucket_id = argv[1];
 
-        var id = opts.req_id || uuid.v1();
+        var id = options.req_id || uuid.v1();
 
-        dtrace['findobjects-start'].fire(function () {
-            return ([msgid, id, b, f]);
-        });
+        // dtrace['getobject-start'].fire(function () {
+        //     return ([msgid, id, b, k]);
+        // });
 
         var log = options.log.child({
             req_id: id
         });
 
         log.debug({
-            bucket: b,
-            filter: f,
-            opts: opts
-        }, 'find: entered');
-
-        if (!opts.hashkey && !opts.token) {
-            var errMsg = 'Invalid search request, requires either token or ' +
-                         'hashkey';
-            log.debug({
-                bucket: b,
-                filter: f,
-                opts: opts
-            }, errMsg);
-
-            dtrace['findobjects-done'].fire(function () {
-                return ([msgid, -1]);
+            owner: owner,
+            bucket_id: bucket_id
+        }, 'listObjects: entered');
+
+        var pnodes = Object.keys(options.clients.map);
+        var vnodes = {};
+
+        // convert pnodes to vnodes
+        pnodes.forEach(function (pnode) {
+            var nodes = options.dataDirector.getVnodes(pnode);
+            nodes.forEach(function (vnode) {
+                vnodes[vnode] = options.clients.map[pnode];
             });
+        });
 
-            rpc.fail(new Error(errMsg));
-            return;
-        }
+        vasync.forEachPipeline({
+            inputs: Object.keys(vnodes),
+            func: function (vnode, cb) {
+                var client = vnodes[vnode];
 
-        var client;
-        if (opts.token) {
-            client = opts.token ? options.clients.map[opts.token] : null;
-            if (!client) {
-                log.debug({token: opts.token}, 'findObject: Invalid Token');
-                dtrace['findobjects-done'].fire(function () {
-                    return ([msgid, -1]);
-                });
-                rpc.fail(new Error('Invalid Token ' + opts.token));
-                return;
-            }
-            processRequest();
-        } else {
-            // just pass in the key, no transformation is needed since the
-            // hashkey is explicitly specified here.
-            options.ring.getNodeNoSchema(opts.hashkey, function (err, node) {
-                log.debug({
-                    err: err,
-                    node: node
-                }, 'find: returned from getNodeNoSchema');
-                if (err) {
-                    dtrace['findobjects-done'].fire(function () {
-                        return ([msgid, -1]);
-                    });
-                    rpc.fail(err);
-                    return;
-                }
-                client = options.clients.map[node.pnode];
-                processRequest();
-            });
-        }
+                vnode = parseInt(vnode, 10);
 
-        function processRequest() {
-            var req = client.findObjects(b, f, opts);
+                log.debug({vnode: vnode, owner: owner}, 'listObjects vasync');
 
-            req.once('error', function (err) {
-                log.debug({
-                    err: err
-                }, 'findObject: done');
-                dtrace['findobjects-done'].fire(function () {
-                    return ([msgid, -1]);
-                });
-                rpc.fail(err);
-            });
+                var res = client.listObjects(owner, bucket_id, vnode);
 
-            var total = 0;
-            req.on('record', function (obj) {
-                total++;
-                log.debug({
-                    obj: obj
-                }, 'findObject: gotRecord');
-                // delete the vnode from the value, as the vnode is only used
-                // internally
-                if (obj && obj.value) {
-                    delete obj.value.vnode;
-                }
-                if (obj && obj._value) {
-                    delete obj._value.vnode;
-                }
-                dtrace['findobjects-record'].fire(function () {
-                    return ([msgid,
-                        obj.key,
-                        obj._id,
-                        obj._etag,
-                    obj._value]);
+                /*
+                 * Format the record to look like a find/search result
+                 */
+                res.on('record', function (record) {
+                    /*
+                     * name: r.key.split('/').pop(),
+                     * etag: r.value.etag,
+                     * size: r.value.contentLength,
+                     * type: r.value.type,
+                     * contentType: r.value.contentType,
+                     * contentMD5: r.value.contentMD5,
+                     * mtime: new Date(r.value.mtime).toISOString()
+                     */
+                    var obj = {
+                        key: record.name,
+                        value: {
+                            type: 'bucketobject',
+                            etag: record.id,
+                            mtime: record.created,
+                            contentType: record.content_type,
+                            contentMD5: record.content_md5,
+                            contentLength: record.content_length
+                        }
+                    };
+                    rpc.write(obj);
                 });
-                rpc.write(obj);
-            });
 
-            req.on('end', function () {
-                log.debug('findObject: done');
-                dtrace['findobjects-done'].fire(function () {
-                    return ([msgid, total]);
+                res.on('end', function () {
+                    cb();
                 });
-                rpc.end();
-            });
-        }
-    }
-
-    return _findObjects;
-}
-
-/*
- * We don't currently support deleteMany operations.
- */
-function deleteMany(options) {
-    assert.object(options, 'options');
-    assert.object(options.log, 'options.log');
-    assert.object(options.clients, 'options.clients');
-
-    function _deleteMany(rpc) {
-        var argv = rpc.argv();
-
-        if (invalidArgs(rpc, argv, DM_ARGS_SCHEMA)) {
-            return;
-        }
-
-        var b = argv[0];
-        var f = argv[1];
-        var opts = argv[2];
-
-        var id = opts.req_id || uuid.v1();
-        var log = options.log.child({
-            req_id: id
-        });
-
-        log.debug({
-            bucket: b,
-            filter: f,
-            opts: opts
-        }, 'deleteMany: entered');
-        rpc.fail(new Error('Operation not supported'));
-    }
-
-    return _deleteMany;
-}
 
-function getTokens(options) {
-    assert.object(options, 'options');
-    assert.object(options.log, 'options.log');
-    assert.object(options.clients, 'options.clients');
-
-    function _getTokens(rpc) {
-        var argv = rpc.argv();
-
-        if (invalidArgs(rpc, argv, GT_ARGS_SCHEMA)) {
-            return;
-        }
-
-        var opts = argv[0];
-
-        var id = opts.req_id || uuid.v1();
-        var log = options.log.child({
-            req_id: id
-        });
-
-        log.debug({
-            opts: opts
-        }, 'getTokens: entered');
-
-        options.ring.getPnodes(function (err, pnodes) {
-            if (err) {
-                rpc.fail(new verror.VError(err, 'unable to get pnodes'));
-                return;
-            }
-            log.debug({
-                pnodes: pnodes
-            }, 'getTokens: returned');
-            rpc.write(pnodes);
-            rpc.end();
-        });
-    }
-
-    return _getTokens;
-}
-
-function sql(options) {
-    assert.object(options, 'options');
-    assert.object(options.log, 'options.log');
-    assert.object(options.clients, 'options.clients');
-
-    function _sql(rpc) {
-        var argv = rpc.argv();
-
-        if (invalidArgs(rpc, argv, SQL_ARGS_SCHEMA)) {
-            return;
-        }
-
-        var stmt = argv[0];
-        var values = argv[1];
-        var opts = argv[2];
-
-        var id = opts.req_id || uuid.v1();
-        var log = options.log.child({
-            req_id: id
-        });
-
-        log.debug({
-            stmt: stmt,
-            values: values,
-            opts: opts
-        }, 'sql: entered');
-
-        if (options.ring.ro_ && !opts.readOnlyOverride) {
-            log.debug({
-                opts: opts,
-                ro: options.ring.ro_
-            }, 'sql: failed shard is read only');
-            rpc.fail(new ReadOnlyError());
-            return;
-        }
-
-        var err = [];
-
-        var barrier = vasync.barrier();
-        barrier.on('drain', function () {
-            var multiError = err[0] ? new verror.MultiError(err) : null;
-            log.debug({
-                err: multiError,
-                stmt: stmt,
-                values: values,
-                opts: opts
-            }, 'sql: finished all shards');
-            if (multiError) {
-                rpc.fail(multiError);
-            } else {
-                rpc.end();
+                res.once('error', function (err) {
+                    cb(err);
+                });
             }
-        });
-
-        var readOnlyPnodes = listReadOnlyPnodes(log, options);
-        if (readOnlyPnodes.length > 0) {
-            rpc.fail(new ReadOnlyError(readOnlyPnodes.join(', ')));
-            return;
-        }
-
-        options.clients.array.forEach(function (client, index) {
-            barrier.start(index);
-            var req = client.sql(stmt, values, opts);
-
-            req.on('record', function (rec) {
-                rpc.write(rec);
-            });
-
-            req.on('error', function (err2) {
-                err.push(err2);
-                barrier.done(index);
-            });
-
-            req.on('end', function () {
-                barrier.done(index);
-            });
-        });
-    }
-
-    return _sql;
-}
-
-/*
- * We don't currently support update operations.
- */
-function updateObjects(options) {
-    assert.object(options, 'options');
-    assert.object(options.log, 'options.log');
-    assert.object(options.clients, 'options.clients');
-
-    function _updateObjects(rpc) {
-        var argv = rpc.argv();
-
-        if (invalidArgs(rpc, argv, UO_ARGS_SCHEMA)) {
-            return;
-        }
-
-        var b = argv[0];
-        var fields = argv[1];
-        var f = argv[2];
-        var opts = argv[3];
-
-        var id = opts.req_id || uuid.v1();
-        var log = options.log.child({
-            req_id: id
-        });
-
-        log.debug({
-            bucket: b,
-            fields: fields,
-            filter: f,
-            opts: opts
-        }, 'update: entered');
-
-        rpc.fail(new Error('Operation not supported'));
-    }
-
-    return _updateObjects;
-}
-
-
-/*
- * Batching is only supported in a very limited case: for modifications when all
- * of the requests have keys with the same value after transformation (if
- * appropriate for their bucket), which allows us to be sure that all of the
- * values live on the same shard.
- *
- * The operations 'update' and 'deleteMany' are not allowed since they cannot be
- * guaranteed to only affect values on a single shard.
- */
-function batch(options) {
-    assert.object(options, 'options');
-    assert.object(options.log, 'options.log');
-    assert.object(options.clients, 'options.clients');
-
-    function _batch(rpc) {
-        var msgid = rpc.requestId();
-        var argv = rpc.argv();
-
-        if (invalidArgs(rpc, argv, B_ARGS_SCHEMA)) {
-            return;
-        }
-
-        var requests = argv[0];
-        var opts = argv[1];
-
-        var id = opts.req_id || uuid.v1();
-        var log = options.log.child({
-            req_id: id
-        });
-
-        log.debug({
-            requests: requests,
-            opts: opts
-        }, 'batch: entered');
-
-        dtrace['batch-start'].fire(function () {
-            return ([msgid, id]);
-        });
-
-        function done(err, meta) {
-            dtrace['batch-done'].fire(function () {
-                return ([msgid]);
-            });
-
+        }, function (err, results) {
             if (err) {
-                log.debug(err, 'batch: failed');
+                log.error(err, 'listObjects error');
                 rpc.fail(err);
-            } else {
-                log.debug({ meta: meta }, 'batch: done');
-                rpc.write(meta);
-                rpc.end();
-            }
-        }
-
-        if (!Array.isArray(requests) || requests.length === 0) {
-            done(new InvocationError('%s expects "requests" (args[0]) to be ' +
-                        'an array with at least one request but received an ' +
-                        'empty array', rpc.methodName()));
-            return;
-        }
-
-        for (var i = 0; i < requests.length; i++) {
-            var request = requests[i];
-
-            if (request.operation !== undefined && request.operation !== null &&
-                ALLOWED_BATCH_OPS.indexOf(request.operation) === -1) {
-                done(new Error(JSON.stringify(request.operation) +
-                    ' is not an allowed batch operation'));
-                return;
-            }
-
-            if (typeof (request.key) !== 'string') {
-                done(new Error('all batch requests must have a "key"'));
                 return;
             }
 
-            if (typeof (request.bucket) !== 'string') {
-                done(new Error('all batch requests must have a "bucket"'));
-                return;
-            }
-        }
-
-        options.ring.getNodeBatch(requests, function (err, node) {
-            if (err) {
-                done(err);
-                return;
-            }
-
-            if (node.data && node.data === READ_ONLY) {
-                log.debug({
-                    requests: requests,
-                    opts: opts,
-                    node: node
-                }, 'batch: failed vnode is read only');
-
-                dtrace['batch-done'].fire(function () {
-                    return ([msgid]);
-                });
-
-                rpc.fail(new ReadOnlyError());
-                return;
-            }
-
-            var pnode = node.pnode;
-            var client = options.clients.map[pnode];
-
-            if (isReadOnlyPnode(log, options.indexShards, pnode)) {
-                rpc.fail(new ReadOnlyError(pnode));
-                return;
-            }
-
-            client.batch(requests, opts, done);
+            rpc.end();
         });
     }
 
-    return _batch;
+    return _listObjects;
 }
 
 module.exports = {
diff --git a/lib/status_server.js b/lib/status_server.js
index 280e05d..968ffd1 100644
--- a/lib/status_server.js
+++ b/lib/status_server.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2018, Joyent, Inc.
+ * Copyright (c) 2019, Joyent, Inc.
  */
 
 var assert = require('assert-plus');
@@ -18,7 +18,7 @@ function createStatusServer(options, callback) {
     assert.object(options, 'options');
     assert.object(options.log, 'options.log');
     assert.number(options.port, 'options.port');
-    assert.object(options.ring, 'options.ring');
+    assert.object(options.dataDirector, 'options.dataDirector');
     assert.arrayOfString(options.clientList, 'options.clientList');
     assert.func(callback, 'callback');
 
diff --git a/main.js b/main.js
index f519c9a..cfdc07a 100644
--- a/main.js
+++ b/main.js
@@ -176,7 +176,7 @@ function run(options) {
     opts.log = LOG;
     opts.name = NAME;
 
-    app.createBucketServer(opts, function (err, res) {
+    app.createServer(opts, function (err, res) {
         if (err) {
             LOG.fatal(err, 'startup failed');
             process.exit(1);
@@ -196,7 +196,7 @@ function run(options) {
         //     return;
         // });
 
-        app.createBucketStatusServer({
+        app.createStatusServer({
             log: LOG.child({ component: 'statusServer' }),
             dataDirector: res.dataDirector,
             clientList: res.clientList,
