From 3e33520a8acc4b8e3673aa3e12cf41d0105543ae Mon Sep 17 00:00:00 2001
From: John Levon <john.levon@joyent.com>
Date: Fri, 28 Sep 2018 09:06:49 +0000
Subject: [PATCH] OS-7265 bhyve should build with newer gcc Reviewed by: Hans
 Rosenfeld <hans.rosenfeld@joyent.com> Reviewed by: Patrick Mooney
 <patrick.mooney@joyent.com> Approved by: Patrick Mooney
 <patrick.mooney@joyent.com>

---
 usr/src/cmd/bhyve/block_if.c                  |  6 +++-
 usr/src/cmd/bhyve/pci_emul.c                  |  6 +++-
 usr/src/cmd/bhyve/pci_virtio_console.c        | 12 ++++++++
 usr/src/cmd/bhyve/pci_virtio_net.c            |  6 ++--
 usr/src/cmd/bhyve/vga.c                       | 10 ++++++-
 usr/src/compat/freebsd/sys/types.h            |  5 +---
 usr/src/uts/i86pc/io/vmm/intel/vmx.c          |  4 +++
 usr/src/uts/i86pc/io/vmm/io/vrtc.c            | 28 +++++++++++++++++++
 usr/src/uts/i86pc/io/vmm/vmm.c                | 13 +++++++++
 .../uts/i86pc/io/vmm/vmm_instruction_emul.c   |  4 ++-
 usr/src/uts/i86pc/io/vmm/vmm_sol_dev.c        |  4 +--
 usr/src/uts/i86pc/io/vmm/vmm_sol_vm.c         |  2 --
 usr/src/uts/i86pc/io/vmm/x86.c                |  3 +-
 13 files changed, 88 insertions(+), 15 deletions(-)

diff --git a/usr/src/cmd/bhyve/block_if.c b/usr/src/cmd/bhyve/block_if.c
index 010f010c38..53d8507f8e 100644
--- a/usr/src/cmd/bhyve/block_if.c
+++ b/usr/src/cmd/bhyve/block_if.c
@@ -28,6 +28,10 @@
  * $FreeBSD$
  */
 
+/*
+ * Copyright 2018 Joyent, Inc.
+ */
+
 #include <sys/cdefs.h>
 __FBSDID("$FreeBSD$");
 
@@ -276,8 +280,8 @@ blockif_proc(struct blockif_ctxt *bc, struct blockif_elem *be, uint8_t *buf)
 #ifndef __FreeBSD__
 	case BOP_WRITE_SYNC:
 		sync = B_TRUE;
-		/* FALLTHROUGH */
 #endif
+		/* FALLTHROUGH */
 	case BOP_WRITE:
 		if (bc->bc_rdonly) {
 			err = EROFS;
diff --git a/usr/src/cmd/bhyve/pci_emul.c b/usr/src/cmd/bhyve/pci_emul.c
index a35a830f7e..8af6a37498 100644
--- a/usr/src/cmd/bhyve/pci_emul.c
+++ b/usr/src/cmd/bhyve/pci_emul.c
@@ -38,7 +38,7 @@
  * http://www.illumos.org/license/CDDL.
  *
  * Copyright 2014 Pluribus Networks Inc.
- * Copyright 2017 Joyent, Inc.
+ * Copyright 2018 Joyent, Inc.
  */
 
 #include <sys/cdefs.h>
@@ -652,7 +652,11 @@ pci_emul_alloc_pbar(struct pci_devinst *pdi, int idx, uint64_t hostbase,
 		break;
 	default:
 		printf("pci_emul_alloc_base: invalid bar type %d\n", type);
+#ifdef FreeBSD
 		assert(0);
+#else
+		abort();
+#endif
 	}
 
 	if (baseptr != NULL) {
diff --git a/usr/src/cmd/bhyve/pci_virtio_console.c b/usr/src/cmd/bhyve/pci_virtio_console.c
index c2f5f8fe60..c4ee10d53a 100644
--- a/usr/src/cmd/bhyve/pci_virtio_console.c
+++ b/usr/src/cmd/bhyve/pci_virtio_console.c
@@ -28,6 +28,10 @@
  * SUCH DAMAGE.
  */
 
+/*
+ * Copyright 2018 Joyent, Inc.
+ */
+
 #include <sys/cdefs.h>
 __FBSDID("$FreeBSD$");
 
@@ -590,14 +594,22 @@ pci_vtcon_notify_tx(void *vsc, struct vqueue_info *vq)
 	struct pci_vtcon_softc *sc;
 	struct pci_vtcon_port *port;
 	struct iovec iov[1];
+#ifdef __FreeBSD__
 	uint16_t idx, n;
+#else
+	uint16_t idx;
+#endif
 	uint16_t flags[8];
 
 	sc = vsc;
 	port = pci_vtcon_vq_to_port(sc, vq);
 
 	while (vq_has_descs(vq)) {
+#ifdef __FreeBSD__
 		n = vq_getchain(vq, &idx, iov, 1, flags);
+#else
+		vq_getchain(vq, &idx, iov, 1, flags);
+#endif
 		if (port != NULL)
 			port->vsp_cb(port, port->vsp_arg, iov, 1);
 
diff --git a/usr/src/cmd/bhyve/pci_virtio_net.c b/usr/src/cmd/bhyve/pci_virtio_net.c
index 7a1c1f580a..a3fe72474b 100644
--- a/usr/src/cmd/bhyve/pci_virtio_net.c
+++ b/usr/src/cmd/bhyve/pci_virtio_net.c
@@ -38,7 +38,7 @@
  * http://www.illumos.org/license/CDDL.
  *
  * Copyright 2013 Pluribus Networks Inc.
- * Copyright 2017 Joyent, Inc.
+ * Copyright 2018 Joyent, Inc.
  */
 
 #include <sys/cdefs.h>
@@ -975,7 +975,9 @@ pci_vtnet_init(struct vmctx *ctx, struct pci_devinst *pi, char *opts)
 	const char *env_msi;
 	char *devname;
 	char *vtopts;
+#ifdef __FreeBSD__
 	int mac_provided;
+#endif
 	int use_msix;
 
 	sc = calloc(1, sizeof(struct pci_vtnet_softc));
@@ -1007,8 +1009,8 @@ pci_vtnet_init(struct vmctx *ctx, struct pci_devinst *pi, char *opts)
 	 * Attempt to open the tap device and read the MAC address
 	 * if specified
 	 */
-	mac_provided = 0;
 #ifdef	__FreeBSD__
+	mac_provided = 0;
 	sc->vsc_tapfd = -1;
 #endif
 	sc->vsc_nmd = NULL;
diff --git a/usr/src/cmd/bhyve/vga.c b/usr/src/cmd/bhyve/vga.c
index 26526c40b6..a5f68ec543 100644
--- a/usr/src/cmd/bhyve/vga.c
+++ b/usr/src/cmd/bhyve/vga.c
@@ -25,7 +25,7 @@
  */
 
 /*
- * Copyright 2017 Joyent, Inc.
+ * Copyright 2018 Joyent, Inc.
  */
 
 #include <sys/cdefs.h>
@@ -367,7 +367,11 @@ vga_mem_rd_handler(struct vmctx *ctx, uint64_t addr, void *arg1)
 		/*
 		 * monochrome text mode: base 0xb0000 size 32kb
 		 */
+#ifdef __FreeBSD__
 		assert(0);
+#else
+		abort();
+#endif
 	case 0x3:
 		/*
 		 * color text mode and CGA: base 0xb8000 size 32kb
@@ -431,7 +435,11 @@ vga_mem_wr_handler(struct vmctx *ctx, uint64_t addr, uint8_t val, void *arg1)
 		/*
 		 * monochrome text mode: base 0xb0000 size 32kb
 		 */
+#ifdef __FreeBSD__
 		assert(0);
+#else
+		abort();
+#endif
 	case 0x3:
 		/*
 		 * color text mode and CGA: base 0xb8000 size 32kb
diff --git a/usr/src/compat/freebsd/sys/types.h b/usr/src/compat/freebsd/sys/types.h
index 0a2cdda951..63731da42e 100644
--- a/usr/src/compat/freebsd/sys/types.h
+++ b/usr/src/compat/freebsd/sys/types.h
@@ -11,6 +11,7 @@
 
 /*
  * Copyright 2014 Pluribus Networks Inc.
+ * Copyright 2018 Joyent, Inc.
  */
 
 #ifndef _COMPAT_FREEBSD_SYS_TYPES_H_
@@ -75,10 +76,6 @@ typedef char		vm_memattr_t;
 typedef _Bool bool;
 #endif
 
-#if defined(_KERNEL) && !defined(offsetof)
-#define	offsetof(s, m)	((size_t)(&(((s *)0)->m)))
-#endif
-
 #if defined(_KERNEL)
 typedef struct __dev_info **device_t;
 #endif
diff --git a/usr/src/uts/i86pc/io/vmm/intel/vmx.c b/usr/src/uts/i86pc/io/vmm/intel/vmx.c
index 3abba57031..1df2271b3a 100644
--- a/usr/src/uts/i86pc/io/vmm/intel/vmx.c
+++ b/usr/src/uts/i86pc/io/vmm/intel/vmx.c
@@ -1175,9 +1175,13 @@ vmx_vminit(struct vm *vm, pmap_t pmap)
 static int
 vmx_handle_cpuid(struct vm *vm, int vcpu, struct vmxctx *vmxctx)
 {
+#ifdef __FreeBSD__
 	int handled, func;
 	
 	func = vmxctx->guest_rax;
+#else
+	int handled;
+#endif
 
 	handled = x86_emulate_cpuid(vm, vcpu,
 				    (uint32_t*)(&vmxctx->guest_rax),
diff --git a/usr/src/uts/i86pc/io/vmm/io/vrtc.c b/usr/src/uts/i86pc/io/vmm/io/vrtc.c
index 8452d28cd2..0d61631626 100644
--- a/usr/src/uts/i86pc/io/vmm/io/vrtc.c
+++ b/usr/src/uts/i86pc/io/vmm/io/vrtc.c
@@ -283,25 +283,33 @@ rtc_to_secs(struct vrtc *vrtc)
 	struct clocktime ct;
 	struct timespec ts;
 	struct rtcdev *rtc;
+#ifdef __FreeBSD__
 	struct vm *vm;
+#endif
 	int century, error, hour, pm, year;
 
 	KASSERT(VRTC_LOCKED(vrtc), ("%s: vrtc not locked", __func__));
 
+#ifdef __FreeBSD__
 	vm = vrtc->vm;
+#endif
 	rtc = &vrtc->rtcdev;
 
 	bzero(&ct, sizeof(struct clocktime));
 
 	error = rtcget(rtc, rtc->sec, &ct.sec);
 	if (error || ct.sec < 0 || ct.sec > 59) {
+#ifdef __FreeBSD__
 		VM_CTR2(vm, "Invalid RTC sec %#x/%d", rtc->sec, ct.sec);
+#endif
 		goto fail;
 	}
 
 	error = rtcget(rtc, rtc->min, &ct.min);
 	if (error || ct.min < 0 || ct.min > 59) {
+#ifdef __FreeBSD__
 		VM_CTR2(vm, "Invalid RTC min %#x/%d", rtc->min, ct.min);
+#endif
 		goto fail;
 	}
 
@@ -331,14 +339,18 @@ rtc_to_secs(struct vrtc *vrtc)
 			if (pm)
 				ct.hour += 12;
 		} else {
+#ifdef __FreeBSD__
 			VM_CTR2(vm, "Invalid RTC 12-hour format %#x/%d",
 			    rtc->hour, ct.hour);
+#endif
 			goto fail;
 		}
 	}
 
 	if (error || ct.hour < 0 || ct.hour > 23) {
+#ifdef __FreeBSD__
 		VM_CTR2(vm, "Invalid RTC hour %#x/%d", rtc->hour, ct.hour);
+#endif
 		goto fail;
 	}
 
@@ -352,37 +364,47 @@ rtc_to_secs(struct vrtc *vrtc)
 
 	error = rtcget(rtc, rtc->day_of_month, &ct.day);
 	if (error || ct.day < 1 || ct.day > 31) {
+#ifdef __FreeBSD__
 		VM_CTR2(vm, "Invalid RTC mday %#x/%d", rtc->day_of_month,
 		    ct.day);
+#endif
 		goto fail;
 	}
 
 	error = rtcget(rtc, rtc->month, &ct.mon);
 	if (error || ct.mon < 1 || ct.mon > 12) {
+#ifdef __FreeBSD__
 		VM_CTR2(vm, "Invalid RTC month %#x/%d", rtc->month, ct.mon);
+#endif
 		goto fail;
 	}
 
 	error = rtcget(rtc, rtc->year, &year);
 	if (error || year < 0 || year > 99) {
+#ifdef __FreeBSD__
 		VM_CTR2(vm, "Invalid RTC year %#x/%d", rtc->year, year);
+#endif
 		goto fail;
 	}
 
 	error = rtcget(rtc, rtc->century, &century);
 	ct.year = century * 100 + year;
 	if (error || ct.year < POSIX_BASE_YEAR) {
+#ifdef __FreeBSD__
 		VM_CTR2(vm, "Invalid RTC century %#x/%d", rtc->century,
 		    ct.year);
+#endif
 		goto fail;
 	}
 
 	error = clock_ct_to_ts(&ct, &ts);
 	if (error || ts.tv_sec < 0) {
+#ifdef __FreeBSD__
 		VM_CTR3(vm, "Invalid RTC clocktime.date %04d-%02d-%02d",
 		    ct.year, ct.mon, ct.day);
 		VM_CTR3(vm, "Invalid RTC clocktime.time %02d:%02d:%02d",
 		    ct.hour, ct.min, ct.sec);
+#endif
 		goto fail;
 	}
 	return (ts.tv_sec);		/* success */
@@ -391,7 +413,9 @@ fail:
 	 * Stop updating the RTC if the date/time fields programmed by
 	 * the guest are invalid.
 	 */
+#ifdef __FreeBSD__
 	VM_CTR0(vrtc->vm, "Invalid RTC date/time programming detected");
+#endif
 	return (VRTC_BROKEN_TIME);
 }
 
@@ -399,7 +423,9 @@ static int
 vrtc_time_update(struct vrtc *vrtc, time_t newtime, sbintime_t newbase)
 {
 	struct rtcdev *rtc;
+#ifdef __FreeBSD__
 	sbintime_t oldbase;
+#endif
 	time_t oldtime;
 	uint8_t alarm_sec, alarm_min, alarm_hour;
 
@@ -414,9 +440,11 @@ vrtc_time_update(struct vrtc *vrtc, time_t newtime, sbintime_t newbase)
 	VM_CTR2(vrtc->vm, "Updating RTC secs from %#lx to %#lx",
 	    oldtime, newtime);
 
+#ifdef __FreeBSD__
 	oldbase = vrtc->base_uptime;
 	VM_CTR2(vrtc->vm, "Updating RTC base uptime from %#lx to %#lx",
 	    oldbase, newbase);
+#endif
 	vrtc->base_uptime = newbase;
 
 	if (newtime == oldtime)
diff --git a/usr/src/uts/i86pc/io/vmm/vmm.c b/usr/src/uts/i86pc/io/vmm/vmm.c
index 21ebb38995..4d8cf1748d 100644
--- a/usr/src/uts/i86pc/io/vmm/vmm.c
+++ b/usr/src/uts/i86pc/io/vmm/vmm.c
@@ -1015,7 +1015,11 @@ vm_iommu_modify(struct vm *vm, boolean_t map)
 	int i, sz;
 	vm_paddr_t gpa, hpa;
 	struct mem_map *mm;
+#ifdef __FreeBSD__
 	void *vp, *cookie, *host_domain;
+#else
+	void *vp, *cookie, *host_domain __unused;
+#endif
 
 	sz = PAGE_SIZE;
 	host_domain = iommu_host_domain();
@@ -1531,7 +1535,11 @@ static int
 vm_handle_hlt(struct vm *vm, int vcpuid, bool intr_disabled, bool *retu)
 {
 	struct vcpu *vcpu;
+#ifdef __FreeBSD__
 	const char *wmesg;
+#else
+	const char *wmesg __unused;
+#endif
 	int t, vcpu_halted, vm_halted;
 
 	KASSERT(!CPU_ISSET(vcpuid, &vm->halted_cpus), ("vcpu already halted"));
@@ -1743,10 +1751,15 @@ vm_handle_inst_emul(struct vm *vm, int vcpuid, bool *retu)
 static int
 vm_handle_suspend(struct vm *vm, int vcpuid, bool *retu)
 {
+#ifdef __FreeBSD__
 	int i, done;
 	struct vcpu *vcpu;
 
 	done = 0;
+#else
+	int i;
+	struct vcpu *vcpu;
+#endif
 	vcpu = &vm->vcpu[vcpuid];
 
 	CPU_SET_ATOMIC(vcpuid, &vm->suspended_cpus);
diff --git a/usr/src/uts/i86pc/io/vmm/vmm_instruction_emul.c b/usr/src/uts/i86pc/io/vmm/vmm_instruction_emul.c
index ccb615cbe0..1a2f493dd1 100644
--- a/usr/src/uts/i86pc/io/vmm/vmm_instruction_emul.c
+++ b/usr/src/uts/i86pc/io/vmm/vmm_instruction_emul.c
@@ -39,7 +39,7 @@
  * http://www.illumos.org/license/CDDL.
  *
  * Copyright 2015 Pluribus Networks Inc.
- * Copyright 2017 Joyent, Inc.
+ * Copyright 2018 Joyent, Inc.
  */
 
 #include <sys/cdefs.h>
@@ -99,6 +99,7 @@ enum {
 #define	VIE_OP_F_NO_MODRM	(1 << 3)
 #define	VIE_OP_F_NO_GLA_VERIFICATION (1 << 4)
 
+#ifdef _KERNEL
 static const struct vie_op two_byte_opcodes[256] = {
 	[0xB6] = {
 		.op_byte = 0xB6,
@@ -230,6 +231,7 @@ static const struct vie_op one_byte_opcodes[256] = {
 		.op_type = VIE_OP_TYPE_PUSH,
 	}
 };
+#endif
 
 /* struct vie.mod */
 #define	VIE_MOD_INDIRECT		0
diff --git a/usr/src/uts/i86pc/io/vmm/vmm_sol_dev.c b/usr/src/uts/i86pc/io/vmm/vmm_sol_dev.c
index 817d88111f..ec26944aea 100644
--- a/usr/src/uts/i86pc/io/vmm/vmm_sol_dev.c
+++ b/usr/src/uts/i86pc/io/vmm/vmm_sol_dev.c
@@ -996,7 +996,7 @@ vmmdev_do_ioctl(vmm_softc_t *sc, int cmd, intptr_t arg, int md,
 		 * If they want a ulong_t or less, make sure they receive the
 		 * low bits with all the useful information.
 		 */
-		if (size <= tempset.cpub[0]) {
+		if (size <= sizeof (tempset.cpub[0])) {
 			srcp = &tempset.cpub[0];
 		}
 
@@ -1012,7 +1012,7 @@ vmmdev_do_ioctl(vmm_softc_t *sc, int cmd, intptr_t arg, int md,
 
 		ASSERT(size > 0 && size <= sizeof (tempset));
 		if (error == 0 &&
-		    ddi_copyout(&tempset, vm_cpuset.cpus, size, md)) {
+		    ddi_copyout(srcp, vm_cpuset.cpus, size, md)) {
 			error = EFAULT;
 			break;
 		}
diff --git a/usr/src/uts/i86pc/io/vmm/vmm_sol_vm.c b/usr/src/uts/i86pc/io/vmm/vmm_sol_vm.c
index 520ebf9a22..95b0e13a95 100644
--- a/usr/src/uts/i86pc/io/vmm/vmm_sol_vm.c
+++ b/usr/src/uts/i86pc/io/vmm/vmm_sol_vm.c
@@ -694,7 +694,6 @@ eptable_mapout(eptable_map_t *map, uintptr_t va)
 		mutex_exit(&map->em_lock);
 		return;
 	} else {
-		pfn_t oldpfn;
 		const size_t pagesize = LEVEL_SIZE((uint_t)ept->ept_level);
 
 		if (!EPT_MAPS_PAGE(ept->ept_level, entry)) {
@@ -706,7 +705,6 @@ eptable_mapout(eptable_map_t *map, uintptr_t va)
 		 * XXXJOY: Just clean the entry for now. Assume(!) that
 		 * invalidation is going to occur anyways.
 		 */
-		oldpfn = EPT_PTE_PFN(ptes[idx]);
 		ept->ept_valid_cnt--;
 		ptes[idx] = (x86pte_t)0;
 		map->em_wired -= (pagesize >> PAGESHIFT);
diff --git a/usr/src/uts/i86pc/io/vmm/x86.c b/usr/src/uts/i86pc/io/vmm/x86.c
index d6426bde44..5a6d7f9dd7 100644
--- a/usr/src/uts/i86pc/io/vmm/x86.c
+++ b/usr/src/uts/i86pc/io/vmm/x86.c
@@ -38,6 +38,7 @@
  * http://www.illumos.org/license/CDDL.
  *
  * Copyright 2014 Pluribus Networks Inc.
+ * Copyright 2018 Joyent, Inc.
  */
 
 #include <sys/cdefs.h>
@@ -222,8 +223,8 @@ x86_emulate_cpuid(struct vm *vm, int vcpu_id,
 			/* XXXJOY: Wire up with our own TSC logic */
 			if (tsc_is_invariant && smp_tsc)
 				regs[3] |= AMDPM_TSC_INVARIANT;
-			break;
 #endif /* __FreeBSD__ */
+			break;
 
 		case CPUID_0000_0001:
 			do_cpuid(1, regs);
-- 
2.21.0

