From b3ffdf842055631bf3339cf977c33bfe4ea4bc5c Mon Sep 17 00:00:00 2001
From: John Levon <john.levon@joyent.com>
Date: Tue, 30 Apr 2019 10:17:54 +0000
Subject: [PATCH] TRITON-1353 Triton systems should ship with HT disabled

---
 bin/build-tar-image     |   5 +-
 build.spec              |   1 +
 tools/bin/sdc-server    | 366 +++++++++++++++++++++++++++++++++++++++-
 tools/cmd/sdc-usbkey.js |  50 ++++++
 tools/lib/usbkey.js     | 106 +++++++++++-
 5 files changed, 517 insertions(+), 11 deletions(-)

diff --git a/bin/build-tar-image b/bin/build-tar-image
index ebb895f9..ab06a06b 100755
--- a/bin/build-tar-image
+++ b/bin/build-tar-image
@@ -188,11 +188,13 @@ function generate_loader_config
 
     serial_dev=$(build_spec serial-dev)
     os_console=$(build_spec console)
+    ht_enabled=$(build_spec ht_enabled)
     ipxe=$(build_spec ipxe)
 
-    [[ -z "$ipxe" ]] && ipxe="true"
+    [[ -z "${ipxe}" ]] && ipxe="true"
     [[ -z "${serial_dev}" ]] && serial_dev="ttyb"
     [[ -z "${os_console}" ]] && os_console="${serial_dev}"
+    [[ -z "${ht_enabled}" ]] && ht_enabled="false"
 
     case "${serial_dev}" in
     ttya) lconsole="ttya,ttyb,ttyc,ttyd" ;;
@@ -225,6 +227,7 @@ function generate_loader_config
     cp -f ${STAGE}/boot/loader.conf.tmpl ${STAGE}/boot/loader.conf
 
     echo "ipxe=\"${ipxe}\"" >>${STAGE}/boot/loader.conf
+    echo "ht_enabled=\"${ht_enabled}\"" >>${STAGE}/boot/loader.conf
     echo "console=\"${lconsole}\"" >>${STAGE}/boot/loader.conf
     echo "os_console=\"${os_console}\"" >>${STAGE}/boot/loader.conf
 }
diff --git a/build.spec b/build.spec
index 21cd7d78..505dbb19 100644
--- a/build.spec
+++ b/build.spec
@@ -5,6 +5,7 @@
   "coal-enable-serial": true,
   "no-rabbit": true,
   "clean-cache": true,
+  "ht_enabled": false,
   "// joyent-build": "set to true to enable ancillary repository use",
 
   "features": {
diff --git a/tools/bin/sdc-server b/tools/bin/sdc-server
index 9f189ddc..0ab7516e 100755
--- a/tools/bin/sdc-server
+++ b/tools/bin/sdc-server
@@ -6,7 +6,7 @@
  */
 
 /*
- * Copyright (c) 2019, Joyent, Inc.
+ * Copyright 2019 Joyent, Inc.
  */
 
 //
@@ -26,6 +26,8 @@ var readline = require('readline');
 var netconfig = require('triton-netconfig');
 var util = require('util');
 var vasync = require('vasync');
+var logger = require('/usr/node/node_modules/bunyan');
+var usbkey = require('../lib/usbkey');
 
 var SDC_MODULES = '/opt/smartdc/node_modules';
 var restifyClients = require(SDC_MODULES +
@@ -49,6 +51,8 @@ function usage()
         '    delete [-f] <uuid>                    - remove all CNAPI information about',
         '                                            this server',
         '    jobs <uuid>                           - list all jobs for this server',
+        '    get [<uuid>] param                    - get parameter (for a server)',
+        '    set [<uuid>] param value              - set parameter (for a server)',
         '    list                                  - list all servers in this DC',
         '    lookup [-h1jHc] [field=val ...]       - lookup servers matching given fields',
         '    ips <uuid>                            - output the IPs for this server',
@@ -87,6 +91,38 @@ function setup_usage()
     /* END JSSTYLED */
 }
 
+function get_usage()
+{
+    /* BEGIN JSSTYLED */
+    console.log([
+        '',
+        'Usage:',
+        '        /opt/smartdc/bin/sdc-server get [<uuid>] param',
+        '',
+        'Possible params:',
+        '',
+        '    ht_enabled <true|false>                           - Hyper-threading enabled on boot',
+        ''
+    ].join('\n'));
+    /* END JSSTYLED */
+}
+
+function set_usage()
+{
+    /* BEGIN JSSTYLED */
+    console.log([
+        '',
+        'Usage:',
+        '        /opt/smartdc/bin/sdc-server set [<uuid>] param=value',
+        '',
+        'Possible params:',
+        '',
+        '    ht_enabled <true|false>                           - Hyper-threading enabled on boot',
+        ''
+    ].join('\n'));
+    /* END JSSTYLED */
+}
+
 function isUUID(str) {
     var re = /^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$/;
     if (!str) {
@@ -145,6 +181,20 @@ function createClient(api, callback) {
             });
             callback(null, handle);
             return;
+        case 'SAPI':
+            handle = new sdcClients.SAPI({
+                url: 'http://' + sdc_config.sapi_admin_ips,
+                log: new logger({
+                    name: 'sdc-server',
+                    stream: process.stderr,
+                    level: 'error',
+                    serializers: logger.stdSerializers
+                    }),
+                version: '~2',
+                agent: false
+            });
+            callback(null, handle);
+            return;
         case 'WFAPI':
             handle = restifyClients.createJsonClient({
                 url: 'http://' + sdc_config.workflow_domain,
@@ -1045,6 +1095,276 @@ function runServerWorkflow(server_uuid, func, options, callback)
     ], callback);
 }
 
+function setServerKernelArg(server_uuid, name, value, callback)
+{
+    assert.string(server_uuid, 'server_uuid');
+    assert.string(name, 'name');
+    assert.string(value, 'value');
+    assert.func(callback, 'callback');
+
+    var cnapi;
+
+    vasync.pipeline({ 'funcs': [
+        function createCNAPIClient(_, cb) {
+            createClient('CNAPI', function (err, handle) {
+                if (!err) {
+                    cnapi = handle;
+                } else {
+                    err.api = 'CNAPI';
+                }
+                cb(err);
+            });
+        }, function setKernelArg(_, cb) {
+            cnapi.listServers({uuids: server_uuid}, function (err, servers) {
+                if (servers.length !== 1) {
+                    cb(new Error('unknown server ' + server_uuid));
+                    return;
+                }
+
+                var server = servers[0];
+
+                if (err) {
+                    err.api = 'CNAPI';
+                    cb(err);
+                    return;
+                }
+
+                if (server.headnode) {
+                    usbkey.set_variable(name, value, cb);
+                } else {
+                    var params = { kernel_args: {} };
+                    params.kernel_args[name] = value;
+
+                    cnapi.setBootParams(server_uuid, params, {}, cb);
+                }
+            });
+        }
+    ]}, callback);
+}
+
+/*
+ * Set a default CNAPI parameter via SAPI. this will only be reflected
+ * once each CNAPI instance's config-agent notices the change. It's not
+ * ideal, but right now, there's no simple way to refresh all instances.
+ */
+function setSAPIParam(name, value, callback)
+{
+    assert.string(name, 'name');
+    assert.string(value, 'value');
+    assert.func(callback, 'callback');
+
+    var sapi;
+    var app;
+    var svc;
+
+    vasync.pipeline({ 'funcs': [
+        function createSAPIClient(_, cb) {
+            createClient('SAPI', function (err, handle) {
+                if (!err) {
+                    sapi = handle;
+                } else {
+                    err.api = 'SAPI';
+                }
+                cb(err);
+            });
+        }, function getSdcApp(_, cb) {
+            sapi.listApplications({ name: 'sdc' }, function (err, apps) {
+                if (!err)
+                    app = apps[0];
+                cb(err);
+            });
+        }, function getCnapiService(_, cb) {
+            var searchOpts = {name: 'cnapi', application_uuid: app.uuid};
+            sapi.listServices(searchOpts, function (err, svcs) {
+                if (!err)
+                    svc = svcs[0];
+                cb(err);
+            });
+        }, function setServiceMetadata(_, cb) {
+            var md = {};
+            md[name] = value;
+
+            sapi.updateService(svc.uuid, {metadata: md}, function (err) {
+                cb(err);
+            });
+        }
+    ]}, callback);
+}
+
+function setParam(server_uuid, name, value, callback)
+{
+    assert.optionalString(server_uuid, 'server_uuid');
+    assert.string(name, 'name');
+    assert.string(value, 'value');
+    assert.func(callback, 'callback');
+
+    switch (name) {
+        case 'ht_enabled':
+            if (['false', 'true'].indexOf(value) === -1) {
+                set_usage();
+                callback(new Error('incorrect value ' + value +
+                    ' for ' + name));
+                break;
+            }
+
+            if (server_uuid) {
+                setServerKernelArg(server_uuid, name, value, callback);
+            } else {
+                setSAPIParam('HT_ENABLED_DEFAULT', value, callback);
+            }
+
+            break;
+
+        default:
+            callback(new Error('unknown server parameter ' + name));
+            break;
+    }
+}
+
+function getSAPIParam(name, default_value, callback)
+{
+    assert.string(name, 'name');
+    assert.func(callback, 'callback');
+
+    var sapi;
+    var app;
+    var svc;
+
+    vasync.pipeline({ 'funcs': [
+        function createSAPIClient(_, cb) {
+            createClient('SAPI', function (err, handle) {
+                if (!err) {
+                    sapi = handle;
+                } else {
+                    err.api = 'SAPI';
+                }
+                cb(err);
+            });
+        }, function getSdcApp(_, cb) {
+            sapi.listApplications({ name: 'sdc' }, function (err, apps) {
+                if (!err)
+                    app = apps[0];
+                cb(err);
+            });
+        }, function getCnapiService(_, cb) {
+            var searchOpts = {name: 'cnapi', application_uuid: app.uuid};
+            sapi.listServices(searchOpts, function (err, svcs) {
+                if (!err)
+                    svc = svcs[0];
+                cb(err);
+            });
+        }, function getServiceMetadata(_, cb) {
+            sapi.getService(svc.uuid, function (err, service) {
+                if (err) {
+                    err.api = 'SAPI';
+                } else {
+                    var value = service.metadata[name];
+                    if (typeof (value) !== 'undefined') {
+                        console.log(value);
+                    } else {
+                        console.log(default_value);
+                    }
+                }
+
+                cb(err);
+            });
+        }
+    ]}, callback);
+}
+
+function getServerKernelArg(server_uuid, name, sapi_param, callback)
+{
+    assert.string(server_uuid, 'server_uuid');
+    assert.string(name, 'name');
+    assert.func(callback, 'callback');
+
+    var cnapi;
+
+    vasync.pipeline({ 'funcs': [
+        function createCNAPIClient(_, cb) {
+            createClient('CNAPI', function (err, handle) {
+                if (!err) {
+                    cnapi = handle;
+                } else {
+                    err.api = 'CNAPI';
+                }
+                cb(err);
+            });
+        }, function getKernelArg(_, cb) {
+            cnapi.listServers({uuids: server_uuid}, function (err, servers) {
+                if (servers.length !== 1) {
+                    cb(new Error('unknown server ' + server_uuid));
+                    return;
+                }
+
+                var server = servers[0];
+
+                if (err) {
+                    err.api = 'CNAPI';
+                    cb(err);
+                    return;
+                }
+
+                if (server.headnode) {
+                    usbkey.get_variable(name, function (err, value) {
+                        if (!err) {
+                            if (value !== null) {
+                                console.log(value);
+                            } else {
+                                console.log('unset');
+                            }
+                        }
+
+                        cb(err);
+                    });
+
+                    return;
+                }
+
+                cnapi.getBootParams(server_uuid, {}, function (err, params) {
+                    if (err) {
+                        err.api = 'CNAPI';
+                        cb(err);
+                        return;
+                    }
+
+                    var value = params.kernel_args[name];
+                    if (typeof (value) !== 'undefined') {
+                        console.log(value);
+                        cb();
+                        return;
+                    }
+
+                    getSAPIParam(sapi_param, false, cb);
+                });
+            });
+        }
+    ]}, callback);
+}
+
+function getParam(server_uuid, param, callback)
+{
+    assert.optionalString(server_uuid, 'server_uuid');
+    assert.string(param, 'param');
+    assert.func(callback, 'callback');
+
+    switch (param) {
+        case 'ht_enabled':
+            if (server_uuid) {
+                getServerKernelArg(server_uuid, param,
+                    'HT_ENABLED_DEFAULT', callback);
+            } else {
+                getSAPIParam('HT_ENABLED_DEFAULT', false, callback);
+            }
+
+            break;
+
+        default:
+            callback(new Error('unknown server parameter ' + param));
+            break;
+    }
+}
+
 function dispatchCommand(command, args, callback)
 {
     var rl;
@@ -1249,6 +1569,50 @@ function dispatchCommand(command, args, callback)
 
             break;
 
+        case 'get':
+            if (args.length === 1 && ['help', '-h'].indexOf(args[0]) !== -1) {
+                get_usage();
+                callback();
+                return;
+            }
+
+            server_uuid = undefined;
+
+            if (isUUID(args[0])) {
+                server_uuid = args.shift();
+            }
+
+            if (args.length !== 1) {
+                get_usage();
+                callback(new Error('incorrect arguments for ' + command));
+                return;
+            }
+
+            getParam(server_uuid, args[0], callback);
+            break;
+
+        case 'set':
+            if (args.length === 1 && ['help', '-h'].indexOf(args[0]) !== -1) {
+                set_usage();
+                callback();
+                return;
+            }
+
+            server_uuid = undefined;
+
+            if (isUUID(args[0])) {
+                server_uuid = args.shift();
+            }
+
+            if (args.length !== 2) {
+                set_usage();
+                callback(new Error('incorrect arguments for ' + command));
+                return;
+            }
+
+            setParam(server_uuid, args[0], args[1], callback);
+            break;
+
         default:
             usage();
             callback(new Error('unknown command: ' + command));
diff --git a/tools/cmd/sdc-usbkey.js b/tools/cmd/sdc-usbkey.js
index d1e40035..968619d7 100644
--- a/tools/cmd/sdc-usbkey.js
+++ b/tools/cmd/sdc-usbkey.js
@@ -558,6 +558,56 @@ Usbkey.prototype.do_update.help = [
     '{{options}}'
 ].join('\n');
 
+/*
+ * sdc-usbkey get-variable
+ */
+Usbkey.prototype.do_get_variable = function
+do_get_variable(subcmd, opts, args, callback)
+{
+    var self = this;
+
+    if (opts.help) {
+        self.do_help('help', {}, [ subcmd ], callback);
+        return;
+    }
+
+    if (args.length != 1) {
+        self.do_help('help', {}, [ subcmd ], callback);
+        return;
+    }
+
+    if (!self._global_zone_only(callback)) {
+        return;
+    }
+
+    lib_usbkey.get_variable(args[0], function (err, value) {
+        if (!err) {
+            if (value !== null) {
+                console.log(value);
+            } else {
+                console.log('unset');
+            }
+        }
+
+        callback(err);
+    });
+};
+Usbkey.prototype.do_get_variable.options = [
+    {
+        names: [ 'help', 'h', '?' ],
+        type: 'bool',
+        help: 'Print this help message.'
+    }
+];
+Usbkey.prototype.do_get_variable.help = [
+    'Get a bootloader variable',
+    '',
+    'Usage:',
+    '     sdc-usbkey get-variable <name>',
+    '',
+    '{{options}}'
+].join('\n');
+
 /*
  * sdc-usbkey set-variable
  */
diff --git a/tools/lib/usbkey.js b/tools/lib/usbkey.js
index d8c4c2a6..eaf330fc 100644
--- a/tools/lib/usbkey.js
+++ b/tools/lib/usbkey.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2019, Joyent, Inc.
+ * Copyright 2019 Joyent, Inc.
  */
 
 var mod_fs = require('fs');
@@ -997,6 +997,92 @@ ensure_usbkey_mounted(options, callback)
     });
 }
 
+function
+get_variable_loader(mountpoint, name, callback)
+{
+    mod_assert.string(mountpoint, 'mountpoint');
+    mod_assert.string(name, 'name');
+    mod_assert.func(callback, 'callback');
+
+    var search = '^\\s*' + name + '\\s*=\\s*"?\([^"]*\)"?\\s*$';
+    var file = mountpoint + '/boot/loader.conf';
+
+    mod_fs.readFile(file, 'utf8', function (err, data) {
+        var i;
+
+        if (err) {
+            callback(new VError(err, 'failed to read ' + file));
+            return;
+        }
+
+        var lines = data.replace(/\n$/, '').split(mod_os.EOL);
+
+        for (i = 0; i < lines.length; i++) {
+            var m = lines[i].match(search);
+            if (m) {
+                 callback(null, m[1]);
+                 return;
+            }
+        }
+
+        mod_fs.readFile(mountpoint + '/boot/loader.conf.local',
+            'utf8', function (err, data) {
+                var i;
+
+            if (err) {
+                callback(null, null);
+                return;
+            }
+
+            var lines = data.replace(/\n$/, '').split(mod_os.EOL);
+
+            for (i = 0; i < lines.length; i++) {
+                var m = lines[i].match(search);
+                if (m) {
+                    callback(null, m[1]);
+                    return;
+                }
+            }
+
+            callback(null, null);
+        });
+    });
+}
+
+function
+get_variable(name, callback)
+{
+    mod_assert.string(name, 'name');
+    mod_assert.func(callback, 'callback');
+
+    ensure_usbkey_mounted({}, function (err) {
+        if (err) {
+            callback(err);
+            return;
+        }
+
+        get_usbkey_mount_status({}, function (err, status) {
+            if (err) {
+                callback(err);
+                return;
+            }
+
+            switch (status.version) {
+            case 1:
+                callback(new VError('get variable is not supported for grub'));
+                return;
+            case 2:
+                get_variable_loader(status.mountpoint, name, callback);
+                return;
+            default:
+                callback(new VError('unknown USB key version ' +
+                    status.version));
+                return;
+            }
+        });
+    });
+}
+
 function
 sedfile(file, search, replace, callback)
 {
@@ -1070,7 +1156,15 @@ set_variable_grub(mountpoint, name, value, callback)
     } else if (name === 'os_console') {
         search = '^\\s*variable\\s+os_console\\s+.*$';
         replace = 'variable ' + name + ' ' + value;
+    } else if (name === 'ht_enabled') {
+        callback(new VError('setting kernel argument ' + name + ' ' + value +
+            'is not supported for grub; please edit menu.lst by hand'));
     } else {
+        /*
+         * Note that we're forced to assume here that this is a grub setting,
+         * rather than a boot argument, as we cannot differentiate. This is
+         * why we explicitly check for ht_enabled above.
+         */
         search = '^\\s*' + name + '\\s+.*$';
         replace = name + ' ' + value;
     }
@@ -1105,14 +1199,7 @@ set_variable_loader(mountpoint, name, value, callback)
     var search = '^\\s*' + name + '\\s*=\\s*.*$';
     var replace = name + '=' + value;
 
-    sedfile(mountpoint + '/boot/loader.conf', search, replace, function (err) {
-        if (err) {
-            callback(err);
-            return;
-        }
-
-        callback();
-    });
+    sedfile(mountpoint + '/boot/loader.conf', search, replace, callback);
 }
 
 function
@@ -1155,6 +1242,7 @@ module.exports = {
     ensure_usbkey_unmounted: ensure_usbkey_unmounted,
     ensure_usbkey_mounted: ensure_usbkey_mounted,
     get_usbkey_mount_status: get_usbkey_mount_status,
+    get_variable: get_variable,
     set_variable: set_variable
 };
 
-- 
2.21.0

