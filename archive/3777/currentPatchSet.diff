commit ba250ec130185222dba24661e2c394ac5890678e (refs/changes/77/3777/3)
Author: Jason King <jason.king@joyent.com>
Date:   2018-04-09T16:04:02-05:00 (1 year, 6 months ago)
    
    Add router flag for VL2 entries

diff --git a/usr/src/uts/common/io/overlay/overlay.c b/usr/src/uts/common/io/overlay/overlay.c
index c2f79d06ef..82532f8caf 100644
--- a/usr/src/uts/common/io/overlay/overlay.c
+++ b/usr/src/uts/common/io/overlay/overlay.c
@@ -1072,7 +1072,6 @@ overlay_m_tx(void *arg, mblk_t *mp_chain)
 	bzero(&hdr, sizeof (struct msghdr));
 
 	bzero(&einfo, sizeof (ovep_encap_info_t));
-	einfo.ovdi_id = odd->odd_vid;
 	mp = mp_chain;
 	while (mp != NULL) {
 		socklen_t slen;
@@ -1082,13 +1081,8 @@ overlay_m_tx(void *arg, mblk_t *mp_chain)
 		mp->b_next = NULL;
 		ep = NULL;
 
-		/*
-		 * TODO: we probably need to change 'storage' to a
-		 * refheld overlay_target_entry_t and also maybe set
-		 * local vlan from packet header for check below
-		 */
 		ret = overlay_target_lookup(odd, mp,
-		    (struct sockaddr *)&storage, &slen);
+		    (struct sockaddr *)&storage, &slen, &einfo.ovdi_id);
 		if (ret != OVERLAY_TARGET_OK) {
 			if (ret == OVERLAY_TARGET_DROP)
 				freemsg(mp);
@@ -1096,17 +1090,6 @@ overlay_m_tx(void *arg, mblk_t *mp_chain)
 			continue;
 		}
 
-		/*
-		 * TODO:
-		 *	set hdr.msg_name from target_entry
-		 *
-		 *	if !local:
-		 *		check fabric attachment
-		 *		modify vlan tag, VL2 mac addresses
-		 *
-		 *	set einfo.ovdi_id to vnet id (move into loop since
-		 *	things cannot assume to all have same vnet id anymore)
-		 */
 		hdr.msg_name = &storage;
 		hdr.msg_namelen = slen;
 
diff --git a/usr/src/uts/common/io/overlay/overlay_target.c b/usr/src/uts/common/io/overlay/overlay_target.c
index cb79bfdfdb..b605d36b8c 100644
--- a/usr/src/uts/common/io/overlay/overlay_target.c
+++ b/usr/src/uts/common/io/overlay/overlay_target.c
@@ -306,15 +306,11 @@ overlay_target_quiesce(overlay_target_t *ott)
 /*
  * This functions assumes that the destination mode is OVERLAY_PLUGIN_D_IP |
  * OVERLAY_PLUGIN_D_PORT. As we don't have an implementation of anything else at
- * this time, say for NVGRE, we drop all packets that mcuh this.
- *
- * XXX: It might be better to replace the 'sock' argument with
- * overlay_target_entry_t** and set it with the found entry in the case
- * of OVERLAY_TARGET_OK.
+ * this time, say for NVGRE, we drop all packets that match this.
  */
 int
 overlay_target_lookup(overlay_dev_t *odd, mblk_t *mp, struct sockaddr *sock,
-    socklen_t *slenp)
+    socklen_t *slenp, uint64_t *vidp)
 {
 	int ret;
 	struct sockaddr_in6 *v6;
@@ -324,6 +320,8 @@ overlay_target_lookup(overlay_dev_t *odd, mblk_t *mp, struct sockaddr *sock,
 
 	ASSERT(odd->odd_target != NULL);
 
+	*vidp = odd->odd_vid;
+
 	/*
 	 * At this point, the overlay device is in a mux which means that it's
 	 * been activated. At this point, parts of the target, such as the mode
@@ -359,15 +357,6 @@ overlay_target_lookup(overlay_dev_t *odd, mblk_t *mp, struct sockaddr *sock,
 	if (mac_header_info(odd->odd_mh, mp, &mhi) != 0)
 		return (OVERLAY_TARGET_DROP);
 
-	/*
-	 * TODO: compare mhi.mhi_daddr with odd->macaddr.
-	 * If match,
-	 * 	get VL3 dest from mp
-	 * 	lookup target using VL3 dest
-	 * otherwise,
-	 * 	lookup target using VL2 dest (existing refhash_lookup() call
-	 * 	below)
-	 */
 	mutex_enter(&ott->ott_lock);
 	entry = refhash_lookup(ott->ott_u.ott_dyn.ott_dhash,
 	    mhi.mhi_daddr);
@@ -378,11 +367,6 @@ overlay_target_lookup(overlay_dev_t *odd, mblk_t *mp, struct sockaddr *sock,
 			mutex_exit(&ott->ott_lock);
 			return (OVERLAY_TARGET_DROP);
 		}
-		/*
-		 * TODO: set entry->ote_dcid, if VL3 lookup, copy dst addr
-		 * into entry->ote_ip.  Probably zero out the address we're
-		 * not lookup up (VL2 or VL3) as well.
-		 */
 		bcopy(mhi.mhi_daddr, entry->ote_addr, ETHERADDRL);
 		entry->ote_chead = entry->ote_ctail = mp;
 		entry->ote_mbsize = msgsize(mp);
@@ -401,6 +385,9 @@ overlay_target_lookup(overlay_dev_t *odd, mblk_t *mp, struct sockaddr *sock,
 	mutex_enter(&entry->ote_lock);
 	if (entry->ote_flags & OVERLAY_ENTRY_F_DROP) {
 		ret = OVERLAY_TARGET_DROP;
+	} else if (entry->ote_flags & OVERLAY_ENTRY_F_ROUTER) {
+		/* TODO: Lookup route info, adjust headers, and set vidp */
+		ret = OVERLAY_TARGET_DROP;
 	} else if (entry->ote_flags & OVERLAY_ENTRY_F_VALID) {
 		bcopy(&entry->ote_dest.otp_ip, &v6->sin6_addr,
 		    sizeof (struct in6_addr));
@@ -688,6 +675,16 @@ overlay_target_lookup_respond(overlay_target_hdl_t *thdl, void *arg)
 	const overlay_targ_resp_t *otr = arg;
 	overlay_target_entry_t *entry;
 	mblk_t *mp;
+	boolean_t is_router = B_FALSE;
+
+	/*
+	 * If we ever support a protocol that uses MAC addresses as the UL
+	 * destination address, this check should probably include checking
+	 * that otp_mac is also all zeros.
+	 */
+	if (IN6_IS_ADDR_UNSPECIFIED(&otr->otr_answer.otp_ip) &&
+	    otr->otr_answer.otp_port == 0)
+		is_router = B_TRUE;
 
 	mutex_enter(&thdl->oth_lock);
 	for (entry = list_head(&thdl->oth_outstanding); entry != NULL;
@@ -708,6 +705,8 @@ overlay_target_lookup_respond(overlay_target_hdl_t *thdl, void *arg)
 	    sizeof (overlay_target_point_t));
 	entry->ote_flags &= ~OVERLAY_ENTRY_F_PENDING;
 	entry->ote_flags |= OVERLAY_ENTRY_F_VALID;
+	if (is_router)
+		entry->ote_flags |= OVERLAY_ENTRY_F_ROUTER;
 	mp = entry->ote_chead;
 	entry->ote_chead = NULL;
 	entry->ote_ctail = NULL;
@@ -718,7 +717,7 @@ overlay_target_lookup_respond(overlay_target_hdl_t *thdl, void *arg)
 	/*
 	 * For now do an in-situ drain.
 	 *
-	 * TODO: overlay_m_tx() will need to perform remote fabric attachment
+	 * TODO: overlay_m_tx() may need to perform remote fabric attachment
 	 * checks, which may leave mblk_t's left in the msg chain for
 	 * mblk_t's whose connectivity with the target entry are unknown.
 	 * This will then need to deal with the leftovers.
@@ -1128,31 +1127,34 @@ overlay_target_cache_get(overlay_target_hdl_t *thdl, void *arg)
 		    sizeof (overlay_target_point_t));
 	} else {
 		overlay_target_entry_t *ote;
-		ote = refhash_lookup(ott->ott_u.ott_dyn.ott_dhash,
-		    otc->otc_entry.otce_mac);
-		if (ote != NULL) {
-			mutex_enter(&ote->ote_lock);
-			if ((ote->ote_flags &
-			    OVERLAY_ENTRY_F_VALID_MASK) != 0) {
-				if (ote->ote_flags & OVERLAY_ENTRY_F_DROP) {
-					otc->otc_entry.otce_flags =
-					    OVERLAY_TARGET_CACHE_DROP;
-				} else {
-					otc->otc_entry.otce_flags = 0;
-					bcopy(&ote->ote_dest,
-					    &otc->otc_entry.otce_dest,
-					    sizeof (overlay_target_point_t));
-				}
-				ret = 0;
+		if ((ote = refhash_lookup(ott->ott_u.ott_dyn.ott_dhash,
+		    otc->otc_entry.otce_mac)) == NULL) {
+			ret = ENOENT;
+			goto done;
+		}
+
+		mutex_enter(&ote->ote_lock);
+		if ((ote->ote_flags & OVERLAY_ENTRY_F_VALID_MASK) != 0) {
+			if (ote->ote_flags & OVERLAY_ENTRY_F_DROP) {
+				otc->otc_entry.otce_flags =
+				    OVERLAY_TARGET_CACHE_DROP;
+			} else if (ote->ote_flags & OVERLAY_ENTRY_F_ROUTER) {
+				otc->otc_entry.otce_flags =
+				    OVERLAY_TARGET_CACHE_ROUTER;
 			} else {
-				ret = ENOENT;
+				otc->otc_entry.otce_flags = 0;
+				bcopy(&ote->ote_dest,
+				    &otc->otc_entry.otce_dest,
+				    sizeof (overlay_target_point_t));
 			}
-			mutex_exit(&ote->ote_lock);
+			ret = 0;
 		} else {
 			ret = ENOENT;
 		}
+		mutex_exit(&ote->ote_lock);
 	}
 
+done:
 	mutex_exit(&ott->ott_lock);
 	overlay_hold_rele(odd);
 
@@ -1169,7 +1171,12 @@ overlay_target_cache_set(overlay_target_hdl_t *thdl, void *arg)
 	overlay_targ_cache_t *otc = arg;
 	mblk_t *mp = NULL;
 
-	if (otc->otc_entry.otce_flags & ~OVERLAY_TARGET_CACHE_DROP)
+	if (otc->otc_entry.otce_flags &
+	    ~(OVERLAY_TARGET_CACHE_DROP | OVERLAY_TARGET_CACHE_ROUTER))
+		return (EINVAL);
+
+	if (otc->otc_entry.otce_flags ==
+	    (OVERLAY_TARGET_CACHE_DROP | OVERLAY_TARGET_CACHE_ROUTER))
 		return (EINVAL);
 
 	odd = overlay_hold_by_dlid(otc->otc_linkid);
@@ -1211,6 +1218,8 @@ overlay_target_cache_set(overlay_target_hdl_t *thdl, void *arg)
 		ote->ote_flags |= OVERLAY_ENTRY_F_DROP;
 	} else {
 		ote->ote_flags |= OVERLAY_ENTRY_F_VALID;
+		if (otc->otc_entry.otce_flags & OVERLAY_TARGET_CACHE_ROUTER)
+			ote->ote_flags |= OVERLAY_ENTRY_F_ROUTER;
 		bcopy(&otc->otc_entry.otce_dest, &ote->ote_dest,
 		    sizeof (overlay_target_point_t));
 		mp = ote->ote_chead;
diff --git a/usr/src/uts/common/sys/overlay_impl.h b/usr/src/uts/common/sys/overlay_impl.h
index 7d42bfca19..5fd81a11e7 100644
--- a/usr/src/uts/common/sys/overlay_impl.h
+++ b/usr/src/uts/common/sys/overlay_impl.h
@@ -157,7 +157,8 @@ typedef enum overlay_target_entry_flags {
 	OVERLAY_ENTRY_F_PENDING		= 0x01,	/* lookup in progress */
 	OVERLAY_ENTRY_F_VALID		= 0x02,	/* entry is currently valid */
 	OVERLAY_ENTRY_F_DROP		= 0x04,	/* always drop target */
-	OVERLAY_ENTRY_F_VALID_MASK	= 0x06
+	OVERLAY_ENTRY_F_ROUTER		= 0x08, /* entry is for router */
+	OVERLAY_ENTRY_F_VALID_MASK	= 0x0e,
 } overlay_target_entry_flags_t;
 
 typedef struct overlay_target_entry {
@@ -223,7 +224,7 @@ extern void overlay_target_free(overlay_dev_t *);
 #define	OVERLAY_TARGET_DROP	1
 #define	OVERLAY_TARGET_ASYNC	2
 extern int overlay_target_lookup(overlay_dev_t *, mblk_t *, struct sockaddr *,
-    socklen_t *);
+    socklen_t *, uint64_t *);
 extern void overlay_target_quiesce(overlay_target_t *);
 extern void overlay_target_fini(void);
 
diff --git a/usr/src/uts/common/sys/overlay_target.h b/usr/src/uts/common/sys/overlay_target.h
index b205266baf..376d7e5495 100644
--- a/usr/src/uts/common/sys/overlay_target.h
+++ b/usr/src/uts/common/sys/overlay_target.h
@@ -302,6 +302,7 @@ typedef struct overlay_targ_list {
 #define	OVERLAY_TARGET_ITER_MAX	500
 
 #define	OVERLAY_TARGET_CACHE_DROP	0x01
+#define	OVERLAY_TARGET_CACHE_ROUTER	0x02
 
 typedef struct overlay_targ_cache_entry {
 	uint8_t			otce_mac[ETHERADDRL];
