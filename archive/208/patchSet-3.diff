From 8bb79752193a02aef13742810032c137caef9804 Mon Sep 17 00:00:00 2001
From: Patrick Mooney <pmooney@pfmooney.com>
Date: Fri, 5 Aug 2016 15:32:00 +0000
Subject: [PATCH] OS-5577 tmpfs reports incorrect sizing via statvfs OS-5578
 lint errors in tmpfs OS-5581 tmpfs panic on DEBUG platform Reviewed by:
 Robert Mustacchi <rm@joyent.com>

---
 usr/src/uts/common/fs/tmpfs/tmp_subr.c   | 41 ++++++++++++++++++++----
 usr/src/uts/common/fs/tmpfs/tmp_tnode.c  |  3 +-
 usr/src/uts/common/fs/tmpfs/tmp_vfsops.c | 19 ++++++++---
 usr/src/uts/common/sys/fs/tmp.h          |  1 +
 4 files changed, 51 insertions(+), 13 deletions(-)

diff --git a/usr/src/uts/common/fs/tmpfs/tmp_subr.c b/usr/src/uts/common/fs/tmpfs/tmp_subr.c
index cea31fd3ff..38f3ab9efd 100644
--- a/usr/src/uts/common/fs/tmpfs/tmp_subr.c
+++ b/usr/src/uts/common/fs/tmpfs/tmp_subr.c
@@ -60,17 +60,31 @@ tmp_kmem_zalloc(struct tmount *tm, size_t size, int flag)
 {
 	void *buf;
 	zone_t *zone;
+	size_t pages;
 
-	zone = tm->tm_vfsp->vfs_zone;
 	mutex_enter(&tm->tm_contents);
+	zone = tm->tm_vfsp->vfs_zone;
 	if (tm->tm_anonmem + size > tm->tm_anonmax ||
 	    tm->tm_anonmem + size < tm->tm_anonmem ||
 	    size + ptob(tmpfs_minfree) <= size ||
-	    !anon_checkspace(size + ptob(tmpfs_minfree), zone) ||
-	    anon_try_resv_zone(size, zone) == 0) {
+	    !anon_checkspace(size + ptob(tmpfs_minfree), zone)) {
+		mutex_exit(&tm->tm_contents);
+		return (NULL);
+	}
+
+	/*
+	 * Only make anonymous memory reservations when a page boundary is
+	 * crossed.  This is necessary since the anon_resv functions rounds up
+	 * to PAGESIZE internally.
+	 */
+	pages = btopr(tm->tm_allocmem + size);
+	pages -= btopr(tm->tm_allocmem);
+	if (pages > 0 && anon_try_resv_zone(ptob(pages), zone) == 0) {
 		mutex_exit(&tm->tm_contents);
 		return (NULL);
 	}
+
+	tm->tm_allocmem += size;
 	tm->tm_anonmem += size;
 	mutex_exit(&tm->tm_contents);
 
@@ -79,8 +93,10 @@ tmp_kmem_zalloc(struct tmount *tm, size_t size, int flag)
 		mutex_enter(&tm->tm_contents);
 		ASSERT(tm->tm_anonmem > tm->tm_anonmem - size);
 		tm->tm_anonmem -= size;
+		if (pages > 0) {
+			anon_unresv_zone(ptob(pages), zone);
+		}
 		mutex_exit(&tm->tm_contents);
-		anon_unresv_zone(size, tm->tm_vfsp->vfs_zone);
 	}
 
 	return (buf);
@@ -89,12 +105,23 @@ tmp_kmem_zalloc(struct tmount *tm, size_t size, int flag)
 void
 tmp_kmem_free(struct tmount *tm, void *buf, size_t size)
 {
+	size_t pages;
+
 	kmem_free(buf, size);
 	mutex_enter(&tm->tm_contents);
 	ASSERT(tm->tm_anonmem > tm->tm_anonmem - size);
 	tm->tm_anonmem -= size;
+	pages = btopr(tm->tm_allocmem);
+	tm->tm_allocmem -= size;
+	pages -= btopr(tm->tm_allocmem);
+	/*
+	 * Like the tmp_kmem_zalloc case, only unreserve anonymous memory when
+	 * a page boundary has been crossed.
+	 */
+	if (pages > 0) {
+		anon_unresv_zone(size, tm->tm_vfsp->vfs_zone);
+	}
 	mutex_exit(&tm->tm_contents);
-	anon_unresv_zone(size, tm->tm_vfsp->vfs_zone);
 }
 
 int
@@ -127,7 +154,7 @@ tmp_taccess(void *vtp, int mode, struct cred *cred)
  */
 int
 tmp_sticky_remove_access(struct tmpnode *dir, struct tmpnode *entry,
-	struct cred *cr)
+    struct cred *cr)
 {
 	uid_t uid = crgetuid(cr);
 
@@ -196,7 +223,7 @@ tmp_convnum(char *str, size_t *maxbytes)
 	 * system's total available swap size as the initial value. Perform the
 	 * intermediate calculation in pages to avoid overflow.
 	 */
-	if (*c == '\%') {
+	if (*c == '%') {
 		u_longlong_t cap;
 
 		if (*(c + 1) != '\0')
diff --git a/usr/src/uts/common/fs/tmpfs/tmp_tnode.c b/usr/src/uts/common/fs/tmpfs/tmp_tnode.c
index 91ff8bb7fa..13ea356924 100644
--- a/usr/src/uts/common/fs/tmpfs/tmp_tnode.c
+++ b/usr/src/uts/common/fs/tmpfs/tmp_tnode.c
@@ -281,7 +281,6 @@ tmpnode_trunc(
 {
 	size_t oldsize = tp->tn_size;
 	size_t delta;
-	struct vnode *vp = TNTOV(tp);
 	timestruc_t now;
 	int error = 0;
 
@@ -365,7 +364,7 @@ tmpnode_trunc(
 			/* Delete anon array for tmpnode */
 			ASSERT(tp->tn_nblocks == 0);
 			ASSERT(anon_get_ptr(tp->tn_anon, 0) == NULL);
-			ASSERT(!vn_has_cached_data(vp));
+			ASSERT(!vn_has_cached_data(TNTOV(tp)));
 
 			anon_release(tp->tn_anon, tp->tn_asize);
 			tp->tn_anon = NULL;
diff --git a/usr/src/uts/common/fs/tmpfs/tmp_vfsops.c b/usr/src/uts/common/fs/tmpfs/tmp_vfsops.c
index 3d73364bcd..6013134be2 100644
--- a/usr/src/uts/common/fs/tmpfs/tmp_vfsops.c
+++ b/usr/src/uts/common/fs/tmpfs/tmp_vfsops.c
@@ -350,6 +350,16 @@ tmp_mount(vfs_t *vfsp, vnode_t *mvp, struct mounta *uap, cred_t *cr)
 	tm->tm_mntpath = kmem_zalloc(dpn.pn_pathlen + 1, KM_SLEEP);
 	(void) strcpy(tm->tm_mntpath, dpn.pn_path);
 
+	/*
+	 * Preemptively set vfs_zone before any of the tmp_kmem_* functions are
+	 * called.  That field is not populated until after a successful
+	 * VFS_MOUNT when domount() sets vfsp metadata via vfs_add().  An
+	 * accurate value is required for proper swap usage accounting.
+	 */
+	ASSERT0(uap->flags & MS_REMOUNT);
+	ASSERT(vfsp->vfs_zone == NULL);
+	vfsp->vfs_zone = curproc->p_zone;
+
 	/*
 	 * allocate and initialize root tmpnode structure
 	 */
@@ -759,18 +769,19 @@ tmp_statvfs(struct vfs *vfsp, struct statvfs64 *sbp)
 	 * If tm_anonmax for this mount is less than the available swap space
 	 * (minus the amount tmpfs can't use), use that instead
 	 */
-	if (blocks > tmpfs_minfree)
+	if (blocks > tmpfs_minfree && tm->tm_anonmax > tm->tm_anonmem) {
 		sbp->f_bfree = MIN(blocks - tmpfs_minfree,
-		    tm->tm_anonmax - tm->tm_anonmem);
-	else
+		    btop(tm->tm_anonmax) - btopr(tm->tm_anonmem));
+	} else {
 		sbp->f_bfree = 0;
+	}
 
 	sbp->f_bavail = sbp->f_bfree;
 
 	/*
 	 * Total number of blocks is what's available plus what's been used
 	 */
-	sbp->f_blocks = (fsblkcnt64_t)(sbp->f_bfree + tm->tm_anonmem);
+	sbp->f_blocks = (fsblkcnt64_t)(sbp->f_bfree + btopr(tm->tm_anonmem));
 
 	if (eff_zid != GLOBAL_ZONEUNIQID &&
 	    zp->zone_max_swap_ctl != UINT64_MAX) {
diff --git a/usr/src/uts/common/sys/fs/tmp.h b/usr/src/uts/common/sys/fs/tmp.h
index bd5a0c1f4f..e4e81cc498 100644
--- a/usr/src/uts/common/sys/fs/tmp.h
+++ b/usr/src/uts/common/sys/fs/tmp.h
@@ -46,6 +46,7 @@ struct tmount {
 	size_t		tm_anonmax;	/* file system max anon reservation */
 	size_t		tm_anonmem;	/* bytes of reserved anon memory */
 					/* and allocated kmem for the fs */
+	size_t		tm_allocmem;	/* bytes alloced from tmp_kmem_ funcs */
 	dev_t		tm_dev;		/* unique dev # of mounted `device' */
 	uint_t		tm_gen;		/* pseudo generation number for files */
 	kmutex_t	tm_contents;	/* lock for tmount structure */
-- 
2.21.0

