From a101b0ddc1ec51f7a4efa69c9c03914650ac1a83 Mon Sep 17 00:00:00 2001
From: "Pedro P. Candel" <pedro@joyent.com>
Date: Fri, 8 Jul 2016 18:16:41 +0200
Subject: [PATCH] TOOLS-1336: `update-gz-tools` includes updates of CNs USB
 keys.

Deprecates "/usbkey/scripts/update_cn_tools", taking care to download
and extract cn_tools straight from sdcadm itself, avoiding the need
for extra Ur connections.
---
 lib/cli/do_update_gz_tools.js |  11 +-
 lib/sdcadm.js                 | 247 +++++++++++++++++++++++++++++++++-
 2 files changed, 254 insertions(+), 4 deletions(-)

diff --git a/lib/cli/do_update_gz_tools.js b/lib/cli/do_update_gz_tools.js
index 4bdcb61..00c2819 100644
--- a/lib/cli/do_update_gz_tools.js
+++ b/lib/cli/do_update_gz_tools.js
@@ -47,7 +47,8 @@ function do_update_gz_tools(subcmd, opts, args, cb) {
         image: opts.latest ? 'latest' : args[0],
         progress: progress,
         justDownload: opts.just_download,
-        forceReinstall: opts.force_reinstall
+        forceReinstall: opts.force_reinstall,
+        concurrency: opts.concurrency
     }, finish);
 
 }
@@ -71,6 +72,14 @@ do_update_gz_tools.options = [
         names: ['just-download'],
         type: 'bool',
         help: 'Download the GZ Tools installer for later usage.'
+    },
+    {
+        names: ['concurrency', 'j'],
+        type: 'integer',
+        'default': 5,
+        help: 'Number of concurrent servers downloading cn_tools file or ' +
+            'being updated simultaneously. Default: 5',
+        helpArg: 'N'
     }
 ];
 do_update_gz_tools.help = (
diff --git a/lib/sdcadm.js b/lib/sdcadm.js
index 1a7c047..68dd3ae 100644
--- a/lib/sdcadm.js
+++ b/lib/sdcadm.js
@@ -2179,6 +2179,27 @@ SdcAdm.prototype.updateGzTools = function updateGzTools(options, callback) {
                 common.execFilePlus({argv: argv, log: self.log}, next);
             },
 
+            // REVIEW: Note that /usbkey/scripts/update_cn_tools behaviour is
+            // to left all these backup files around. Do we want to cleanup
+            // such files or is it OK to keep them, given they're not in the
+            // USB key but into cache dir?
+            function backupCNToolsFile(_, next) {
+                if (!fs.existsSync('/usbkey/extra/joysetup/cn_tools.tar.gz')) {
+                    next();
+                    return;
+                }
+                // Keep same format used by /usbkey/scripts/update_cn_tools
+                var cnToolsTimestamp = new Date().toISOString().
+                    replace(/[\-|:|T]/g, '').split('.')[0];
+                var argv = [
+                    'mv',
+                    '/usbkey/extra/joysetup/cn_tools.tar.gz',
+                    '/usbkey/extra/joysetup/cn_tools.' + cnToolsTimestamp +
+                        '.tar.gz'
+                ];
+                common.execFilePlus({argv: argv, log: self.log}, next);
+            },
+
             function removeScriptsDir(_, next) {
                 var argv = [
                     'rm', '-rf',
@@ -2205,6 +2226,15 @@ SdcAdm.prototype.updateGzTools = function updateGzTools(options, callback) {
                 common.execFilePlus({argv: argv, log: self.log}, next);
             },
 
+            function copyCnToolsToUSBKey(_, next) {
+                var argv = [
+                    'cp',
+                    tmpToolsDir + '/cn_tools.tar.gz',
+                    '/usbkey/extra/joysetup/cn_tools.tar.gz'
+                ];
+                common.execFilePlus({argv: argv, log: self.log}, next);
+            },
+
             function copyDefaultDirToUsbKey(_, next) {
                 var cmd = ['cp', tmpToolsDir + '/default/*',
                     '/mnt/usbkey/default'];
@@ -2283,7 +2313,11 @@ SdcAdm.prototype.updateGzTools = function updateGzTools(options, callback) {
         });
     }
 
-    vasync.pipeline({funcs: [
+    var context = {
+        urconn: null
+    };
+
+    vasync.pipeline({arg: context, funcs: [
         function getChannelIfNeeded(_, next) {
             self.getDefaultChannel(function (err, channel) {
                 // Will not fail the whole operation due to channel not found
@@ -2337,6 +2371,7 @@ SdcAdm.prototype.updateGzTools = function updateGzTools(options, callback) {
 
             });
         },
+
         function ensureSdcInstance(_, next) {
             var filters = {
                 state: 'active',
@@ -2355,6 +2390,7 @@ SdcAdm.prototype.updateGzTools = function updateGzTools(options, callback) {
                 return next();
             });
         },
+
         function saveHistory(_, next) {
             if (justDownload) {
                 return next();
@@ -2376,6 +2412,7 @@ SdcAdm.prototype.updateGzTools = function updateGzTools(options, callback) {
                 return next();
             });
         },
+
         function downloadTarball(_, next) {
             if (filepath) {
                 progress('Using gz-tools tarball file %s', filepath);
@@ -2396,6 +2433,7 @@ SdcAdm.prototype.updateGzTools = function updateGzTools(options, callback) {
                 }
             }
         },
+
         function decompressTarball(_, next) {
             if (justDownload) {
                 deleteOnFinish = false;
@@ -2415,24 +2453,226 @@ SdcAdm.prototype.updateGzTools = function updateGzTools(options, callback) {
         function validateTarballContents(_, next) {
             validateTarballFiles(next);
         },
+
         function (_, next) {
             if (justDownload) {
                 return next();
             }
             updateSdcFiles(next);
         },
+
         function (_, next) {
             if (justDownload) {
                 return next();
             }
             updateScripts(next);
         },
-        function (_, next) {
+
+       /*
+        * cn_tools and USB keys update across CNs
+        * Check for Ur availability first, as we cannot proceed without
+        * it:
+        */
+        function urDiscoveryGetReady(ctx, next) {
             if (justDownload) {
                 return next();
             }
-            updateCnTools(next);
+
+            self.getUrConnection(function (err, urconn) {
+                if (err) {
+                    self.log.debug({
+                        err: err
+                    }, 'ur error');
+                    next(new errors.InternalError({
+                        cause: err,
+                        message: 'ur not available (check RabbitMQ)'
+                    }));
+                    return;
+                }
+
+                self.log.debug('ur connected');
+                ctx.urconn = urconn;
+                next();
+            });
+        },
+
+        function findServersToUpdate(ctx, next) {
+            if (justDownload) {
+                return next();
+            }
+            progress('Finding servers to update');
+            // Do we want to update all the servers or just setup ones?
+            self.cnapi.listServers({
+                setup: true
+            }, function (err, servers) {
+                if (err) {
+                    return next(new errors.SDCClientError(err, 'cnapi'));
+                }
+                ctx.serversToUpdate = servers;
+                next();
+            });
+        },
+
+        function urDiscovery(ctx, next) {
+            if (justDownload) {
+                return next();
+            }
+
+            common.urDiscovery({
+                sdcadm: self,
+                progress: progress,
+                nodes: ctx.serversToUpdate.map(
+                    function (s) { return s.uuid; }),
+                urconn: ctx.urconn
+            }, function (err, urAvailServers) {
+                if (err) {
+                    return next(err);
+                }
+                ctx.urServersToUpdate = urAvailServers;
+                return next();
+            });
+        },
+
+        function updateCNTools(ctx, next) {
+            if (justDownload) {
+                return next();
+            }
+
+            progress('Starting cn_tools update on %d servers',
+                ctx.urServersToUpdate.length);
+
+            var tools_url = format('http://%s/extra/joysetup/cn_tools.tar.gz',
+                    self.config.assets_admin_ip);
+
+            var downloadAndExtractCmd = [
+                '',
+                'TOOLS_URL="' + tools_url + '"',
+                'TOOLS_FILE="/tmp/cn_tools.$$.tar.gz"',
+                '',
+                'if ! /usr/bin/curl -sSf "${TOOLS_URL}" -o ' +
+                    '"${TOOLS_FILE}"; then',
+                '    rm -f "${TOOLS_FILE}"',
+                '    echo "failed to download tools tarball"',
+                '    exit 1',
+                'fi',
+                '',
+                'mkdir -p /opt/smartdc',
+                'if ! /usr/bin/tar xzof "${TOOLS_FILE}" -C /opt/smartdc; then',
+                '    rm -f "${TOOLS_FILE}"',
+                '    echo "failed to extract tools tarball"',
+                '    exit 2',
+                'fi',
+                'rm -f "${TOOLS_FILE}"',
+                '',
+                'exit 0',
+                ''
+            ].join('\n');
+
+            var updateUSBKeyCmd = [
+                '',
+                '/opt/smartdc/bin/sdc-usbkey update --ignore-missing',
+                'if [[ "$?" -ne "0" ]]; then',
+                '   exit $?',
+                'fi',
+                '',
+                'exit 0',
+                ''
+            ].join('\n');
+
+
+            vasync.forEachPipeline({
+                inputs: [
+                    {
+                        str: downloadAndExtractCmd,
+                        progbarName: 'Download and extract cn_tools',
+                        timeout: 10 * 60 * 1000
+                    },
+                    {
+                        str: updateUSBKeyCmd,
+                        progbarName: 'Update USBKey',
+                        timeout: 10 * 60 * 1000
+                    }
+                ],
+                func: function runUrQueue(cmd, nextCmd) {
+                    assert.object(ctx.urconn, 'ctx.urconn');
+                    var queueOpts = {
+                        sdcadm: self,
+                        urConnection: ctx.urconn,
+                        log: self.log,
+                        progress: progress,
+                        command: cmd.str,
+                        concurrency: options.concurrency,
+                        timeout: cmd.timeout
+                    };
+
+                    var bar;
+                    if (process.stderr.isTTY) {
+                        bar = new ProgressBar({
+                            size: ctx.urServersToUpdate.length,
+                            bytes: false,
+                            filename: cmd.progbarName
+                        });
+                        queueOpts.progbar = bar;
+                        bar.advance(0); // Draw initial progbar at 0.
+                    }
+                    self.log.trace(
+                        {command: cmd.str, concurrency: options.rate},
+                        'runUrQueue');
+
+                    var rq = ur.runQueue(queueOpts, function (err, results) {
+                        if (err) {
+                            return nextCmd(new errors.UpdateError(
+                                err, 'unexpected runQueue error'));
+                        }
+
+                        var errs = [];
+                        results.forEach(function (r) {
+                            if (r.error || r.result.exit_status !== 0) {
+                                errs.push(new errors.UpdateError(format(
+                                    '%s failed on server %s (%s): %j',
+                                    cmd.progbarName, r.uuid, r.hostname,
+                                    r.error || r.result)));
+                            }
+                        });
+                        if (errs.length === 1) {
+                            nextCmd(errs[0]);
+                        } else if (errs.length > 1) {
+                            nextCmd(new errors.MultiError(errs));
+                        } else {
+                            nextCmd();
+                        }
+                    });
+
+                    rq.on('success', function onSuccess(server, result) {
+                        // A non-zero exit from the command is a "success".
+                        if (result.exit_status !== 0) {
+                            var errmsg = format(
+                                '%s failed on server %s (%s): %j',
+                                cmd.progbarName, server.uuid,
+                                server.hostname, result);
+                            if (cmd.logFile) {
+                                errmsg += ' (log file on server: ' +
+                                    cmd.logFile + ')';
+                            }
+                            if (bar) {
+                                bar.log(errmsg);
+                            } else {
+                                console.log(errmsg);
+                            }
+                        }
+                    });
+
+                    rq.start();
+                    ctx.urServersToUpdate.forEach(function (us) {
+                        rq.add_server(us);
+                    });
+                    rq.close();
+                }
+            }, function doneCmds(err, _) {
+                next(err);
+            });
         },
+
         function (_, next) {
             if (deleteOnFinish) {
                 cleanup(next);
@@ -2440,6 +2680,7 @@ SdcAdm.prototype.updateGzTools = function updateGzTools(options, callback) {
                 next();
             }
         }
+
     ]}, function (err) {
         if (justDownload) {
             callback(err);
-- 
2.21.0

