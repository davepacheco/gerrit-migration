From 08c9baa95274a2d2cc76da0c1c250db91cfa0973 Mon Sep 17 00:00:00 2001
From: Nick Zivkovic <nick.zivkovic@joyent.com>
Date: Sat, 4 Nov 2017 00:10:29 +0000
Subject: [PATCH] NAPI-434 Want way to automatically generate unused subnets

---
 docs/index.md                           |  10 +-
 lib/models/network.js                   | 354 +++++++++++++++++++---
 lib/util/autoalloc.js                   | 147 ++++++++++
 lib/util/constants.js                   |   1 +
 lib/util/errors.js                      |  32 +-
 lib/util/validate.js                    |  18 ++
 test/integration/fabrics.test.js        | 107 +++++++
 test/unit/networks-subnet-alloc.test.js | 372 ++++++++++++++++++++++++
 test/unit/networks.test.js              |   6 +-
 test/unit/util-alloc.test.js            | 120 ++++++++
 10 files changed, 1122 insertions(+), 45 deletions(-)
 create mode 100644 lib/util/autoalloc.js
 create mode 100644 test/unit/networks-subnet-alloc.test.js
 create mode 100644 test/unit/util-alloc.test.js

diff --git a/docs/index.md b/docs/index.md
index c2d9318..9c7c78b 100644
--- a/docs/index.md
+++ b/docs/index.md
@@ -847,7 +847,12 @@ Create a new fabric network on a VLAN.
 ### Inputs
 
 The parameters to this endpoint are the same as to [CreateNetwork](#CreateNetwork),
-but with some fields removed:
+but with some fields removed, and others added. Note that for fabrics, a user
+can manually specify a subnet or ask NAPI to automatically choose one for them.
+This means that there are two separate sets of parameters that are mutually
+exclusive. The following are the allocation params: `[subnet,
+provision_start_ip, provision_end_ip]`. And these are the manual params:
+`[subnet_alloc, family, subnet_prefix]`.
 
 | Field              | Type             | Description                                                                               |
 | ------------------ | ---------------- | ----------------------------------------------------------------------------------------- |
@@ -856,6 +861,9 @@ but with some fields removed:
 | subnet             | CIDR             | Subnet                                                                                    |
 | provision_start_ip | IP               | First IP address to allow provisioning on                                                 |
 | provision_end_ip   | IP               | Last IP address to allow provisioning on                                                  |
+| subnet_alloc       | Boolean          | Automatically choose subnet                                                               |
+| family             | String           | Address family: only 'ipv4' supported                             |
+| subnet_prefix      | Number           | Number of prefix bits (only 24-bit prefixes supported)                        |
 | gateway            | IP               | Gateway IP address (Optional)                                                             |
 | internet_nat       | Boolean          | Provision a NAT zone on the gateway address (Optional) (default: true)                    |
 | resolvers          | Array of IPs     | Resolver IP addresses (Optional)                                                          |
diff --git a/lib/models/network.js b/lib/models/network.js
index b2fa213..e117aef 100644
--- a/lib/models/network.js
+++ b/lib/models/network.js
@@ -32,6 +32,7 @@ var UUID = require('node-uuid');
 var validate = require('../util/validate');
 var vasync = require('vasync');
 var VError = require('verror');
+var autoalloc = require('../util/autoalloc');
 /*
  * Circular dependencies required at end of file.
  */
@@ -151,15 +152,18 @@ var CREATE_SCHEMA = {
         nic_tag: function _nicTagExists(opts, name, tags, callback) {
             mod_nicTag.validateExists(true, opts, name, tags, callback);
         },
-        provision_end_ip: validate.IP,
-        provision_start_ip: validate.IP,
-        subnet: validate.subnet,
         vlan_id: validate.VLAN
     },
     optional: {
         description: validate.string,
         // XXX: allow this?
         fabric: validate.bool,
+        subnet_alloc: validate.bool,
+        family: validate.enum(['ipv4']),
+        subnet_prefix: validate.subnetPrefix,
+        subnet: validate.subnet,
+        provision_end_ip: validate.IP,
+        provision_start_ip: validate.IP,
         fields: validate.fieldsArray(VALID_FIELDS),
         gateway: validateGateway,
         internet_nat: validate.bool,
@@ -172,6 +176,7 @@ var CREATE_SCHEMA = {
     },
     after: [
         validateFabricOwner,
+        validateSubnetAlloc,
         validateProvisionRange,
         validateNicTagMTU
     ]
@@ -246,7 +251,9 @@ var GET_SCHEMA = {
 
 // --- Internal
 
-
+function getMarkerSubnet(net_obj) {
+    return (net_obj.subnet);
+}
 
 /**
  * Given a NIC, return a UsedBy error description for a 'nic',
@@ -681,6 +688,78 @@ function validateProvisionRangeUpdate(opts, params, parsed, cb) {
     }, null, toValidate, cb);
 }
 
+function validateSubnetAutoAlloc(_opts, _, parsedParams, callback) {
+    var errs = [];
+    if (parsedParams.subnet) {
+        errs.push(new errors.invalidParam('subnet',
+            'Manual allocation parameter not allowed'));
+    }
+    if (parsedParams.provision_start_ip) {
+        errs.push(new errors.invalidParam('provision_start_ip',
+            'Manual allocation parameter not allowed'));
+    }
+    if (parsedParams.provision_end_ip) {
+        errs.push(new errors.invalidParam('provision_end_ip',
+            'Manual allocation parameter not allowed'));
+    }
+
+    if (!parsedParams.family) {
+        errs.push(new errors.missingParam('family'));
+    }
+    if (!parsedParams.subnet_prefix) {
+        errs.push(new errors.missingParam('subnet_prefix'));
+    }
+    if (!parsedParams.vnet_id) {
+        errs.push(new errors.missingParam('vnet_id'));
+    }
+    errors.sortErrsByField(errs);
+    if (errs.length > 0) {
+        callback(errs);
+        return;
+    }
+    callback();
+}
+
+function validateSubnetParamsAlloc(_opts, _, parsedParams, callback) {
+    var errs = [];
+    if (parsedParams.subnet_alloc) {
+        errs.push(new errors.invalidParam('subnet_alloc',
+            'Auto allocation parameter not allowed'));
+    }
+    if (parsedParams.subnet_prefix) {
+        errs.push(new errors.invalidParam('subnet_prefix',
+            'Auto allocation parameter not allowed'));
+    }
+    if (!parsedParams.provision_start_ip) {
+        errs.push(new errors.missingParam('provision_start_ip'));
+    }
+    if (!parsedParams.provision_end_ip) {
+        errs.push(new errors.missingParam('provision_end_ip'));
+    }
+    errors.sortErrsByField(errs);
+    if (errs.length > 0) {
+        callback(errs);
+        return;
+    }
+    callback();
+}
+
+/*
+ * Validates that these two sets of params do not overlap:
+ *
+ *    [subnet, provision_start_ip, provision_end_ip]
+ *    [subnet_alloc, family, subnet_prefix]
+ *
+ * Also validates that params.fabric = true and vnet_id = defined for
+ * subnet_alloc path.
+ */
+function validateSubnetAlloc(opts, original, parsedParams, callback) {
+    if (parsedParams.subnet_alloc) {
+        validateSubnetAutoAlloc(opts, original, parsedParams, callback);
+    } else {
+        validateSubnetParamsAlloc(opts, original, parsedParams, callback);
+    }
+}
 
 /**
  * Validates that:
@@ -689,8 +768,11 @@ function validateProvisionRangeUpdate(opts, params, parsed, cb) {
  * * that end doesn't come before start.
  */
 function validateProvisionRange(opts, _, parsedParams, callback) {
-    if (!parsedParams.subnet_start || !parsedParams.subnet_bits) {
-        return callback();
+    if (parsedParams.subnet_alloc || !parsedParams.subnet_start ||
+        !parsedParams.subnet_bits || !parsedParams.provision_start ||
+        !parsedParams.provision_end) {
+        callback();
+        return;
     }
 
     var errs = [];
@@ -980,39 +1062,23 @@ function validateRoutes(_, name, val, callback) {
  * Validates parameters and returns a network object if all parameters are
  * valid, or an error otherwise
  */
-function createValidNetwork(opts, callback) {
+function createNetworkObject(opts) {
     var app = opts.app;
     var log = opts.log;
     var params = opts.params;
 
-    var copts = {
-        app: app,
-        fabric: opts.fabric,
-        log: log,
-        owner_uuid: opts.owner_uuid
-    };
-
-    validate.params(CREATE_SCHEMA, copts, params,
-        function (err, validatedParams) {
-        if (err) {
-            return callback(err);
-        }
-
-        // If we're creating a new network, use strings to populate the
-        // network's IP table.
-        validatedParams.ip_use_strings = true;
+    // If we're creating a new network, use strings to populate the
+    // network's IP table.
+    params.ip_use_strings = true;
 
-        // Auto-assign gateway IP if internet_nat is requested but gateway
-        // is unset.
-        if (validatedParams.fabric && validatedParams.internet_nat &&
-                !validatedParams.gateway) {
-
-            validatedParams.gateway = validatedParams.provision_start_ip;
-        }
+    // Auto-assign gateway IP if internet_nat is requested but gateway
+    // is unset.
+    if (params.fabric && params.internet_nat && !params.gateway) {
+        params.gateway = params.provision_start_ip;
+    }
 
-        return callback(null, new Network(validatedParams));
-    });
-}
+    return new Network(params);
+};
 
 
 /**
@@ -1461,6 +1527,175 @@ Network.prototype.matches = function matchesIntersection(intersection) {
     return true;
 };
 
+/*
+ * Hits the napi_networks bucket, and filters the results according to 'filter'
+ * which is a string.
+ */
+function listFilteredNetworks(opts, filter, attr, callback) {
+    var app = opts.app;
+    var log = opts.log;
+    var offset, limit;
+
+    mod_moray.listObjs({
+        defaultFilter: '(uuid=*)',
+        filter: filter,
+        limit: limit,
+        log: log,
+        offset: offset,
+        bucket: BUCKET,
+        model: Network,
+        moray: app.moray,
+        sort: {
+            attribute: attr,
+            order: 'ASC'
+        }
+    }, callback);
+}
+
+/*
+ * Add an additionaly boolean expression to the filter, that includes only all
+ * subnets that appear after 'marker'.
+ */
+function addSubnetMarkerToFilter(filter, marker) {
+    if (marker) {
+        return '(&' + filter + '!(subnet<=' + marker + '))';
+    }
+    return filter;
+}
+
+/*
+ * Wraps listFilteredNetworks in a LOMStream. Looks at 10 networks at a time.
+ */
+function listFilteredNetworksStream(opts, baseFilter, marker, attr) {
+    var dupOpts = jsprim.deepCopy(opts);
+    var filter;
+
+    var s = new lomstream.LOMStream({
+        fetch: function (opts2, lobj, _datacb, cb) {
+            var copyOpts = jsprim.deepCopy(opts2);
+            copyOpts.params.limit = lobj.limit;
+            filter = addSubnetMarkerToFilter(baseFilter, lobj.marker);
+
+            listFilteredNetworks(opts2, filter, attr, function (err, nets) {
+                if (err) {
+                    cb(err);
+                    return;
+                }
+
+                cb(null, { done: nets.length === 0, results: nets });
+                return;
+            });
+        },
+        marker: marker,
+        limit: 10,
+        fetcharg: dupOpts
+    });
+    return s;
+}
+
+/*
+ * Walks all subnets in sorted order, such that walker() is called on a sliding
+ * pair of subnets. Callback gets called when we've walked all pairs.
+ * NOTE: there is no canonical way to bail out of walking a stream, so we just
+ * walk it to the end, and don't offer the caller any capability to abort.
+ */
+function subnetPairs(opts, walker, callback) {
+    var filter = '(vnet_id=' + opts.params.vnet_id + ')';
+
+
+    // Sliding window of 2 subnets
+    var pair = [];
+
+    function updatePair(sub) {
+        pair.push(sub);
+        while (pair.length > 2) {
+            pair.shift();
+        }
+    }
+
+    var stream = listFilteredNetworksStream(opts, filter, getMarkerSubnet,
+        'subnet');
+
+    stream.on('error', callback);
+
+    stream.on('readable', function () {
+        var network;
+        for (;;) {
+            network = stream.read(1);
+
+            if (network === null) {
+                return;
+            }
+            updatePair(network.subnet);
+
+            if (pair.length === 2) {
+                walker(pair);
+            }
+        }
+
+    });
+
+    stream.on('end', function () {
+        if (pair.length < 2) {
+            walker(pair);
+        }
+        callback();
+    });
+}
+
+
+function allocateSubnet(opts, callback) {
+    var newSub = null;
+    var firstSeen = null;
+    var lastSeen = null;
+    var plen = opts.params.subnet_prefix;
+
+    function subnetWalker (pair) {
+        if (firstSeen === null) {
+            firstSeen = pair[0];
+        }
+
+        lastSeen = pair[(pair.length - 1)];
+        assert.ok(pair.length <= 2);
+        if (pair.length === 0) {
+            newSub = '10.0.0.0/' + plen;
+        } else if (pair.length === 1 ||
+                   autoalloc.haveGapBetweenSubnets(pair[0], pair[1], plen)) {
+
+            if (newSub === null) {
+                newSub = autoalloc.incrementSubnet(pair[0], plen);
+            }
+        }
+    }
+
+    subnetPairs(opts, subnetWalker, function (err) {
+        if (err) {
+            callback(err);
+            return;
+        }
+        if (newSub) {
+            callback(null, newSub);
+            return;
+        }
+
+        if (!err && !newSub) {
+            // We have not found a gap, but there may be space before or after
+            // the stream of subnets we've just walked. We try to increment or
+            // decrement the lastSeen and firstSeen subnets respectively.
+            newSub = autoalloc.incrementSubnet(lastSeen, plen);
+            if (newSub === null) {
+                newSub = autoalloc.decrementSubnet(firstSeen, plen);
+            }
+
+            if (newSub !== null) {
+                callback(null, newSub);
+                return;
+            }
+        }
+
+        callback(new errors.SubnetsExhaustedError());
+    });
+}
 
 
 // --- Exported functions
@@ -1489,22 +1724,62 @@ function createNetwork(opts, callback) {
     var log = opts.log;
     var network;
     var params = opts.params;
+    var validatedParams;
+    var copts = {
+        app: app,
+        fabric: opts.fabric,
+        log: log,
+        owner_uuid: opts.owner_uuid
+    };
 
     log.debug(params, 'createNetwork: entry');
 
     vasync.pipeline({
         funcs: [
-        function _createNetObj(_, cb) {
-            createValidNetwork(opts, function (err, res) {
+        function _validateHttpParams(_, cb) {
+            validate.params(CREATE_SCHEMA, copts, opts.params,
+                function (err, validParams) {
+                    if (err) {
+                        cb(err);
+                        return;
+                    }
+                    validatedParams = validParams;
+                    cb();
+            });
+        },
+        function _allocateSubnet(_, cb) {
+            if (!validatedParams.subnet_alloc) {
+                cb();
+                return;
+            }
+            allocateSubnet(opts, function (err, res) {
                 if (err) {
-                    return cb(err);
+                    cb(err);
+                    return;
                 }
-
-                network = res;
-                return cb();
+                var subnet = ipaddr.createCIDR(res);
+                validatedParams.subnet = res;
+                validatedParams.subnet_start = subnet.address();
+                var provrange = autoalloc.allocProvisionRange(res);
+                validatedParams.provision_start_ip = provrange[0];
+                validatedParams.provision_end_ip = provrange[1];
+                cb();
             });
         },
 
+        function _createNetObj(_, cb) {
+            var vopts = {
+                app: app,
+                fabric: opts.fabric,
+                log: log,
+                owner_uuid: opts.owner_uuid,
+                params: validatedParams
+            };
+            network = createNetworkObject(vopts);
+            return cb();
+        },
+
+
         function _createNet(_, cb) {
             var raw = network.raw();
             log.debug({ uuid: network.uuid, raw: raw },
@@ -1762,6 +2037,7 @@ function validateListNetworks(params, callback) {
 }
 
 
+
 /**
  * Lists networks, filtering by parameters
  */
diff --git a/lib/util/autoalloc.js b/lib/util/autoalloc.js
new file mode 100644
index 0000000..d320404
--- /dev/null
+++ b/lib/util/autoalloc.js
@@ -0,0 +1,147 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright 2017, Joyent, Inc.
+ */
+
+'use strict';
+
+var assert = require('assert-plus');
+var ipaddr = require('ip6addr');
+
+function allocProvisionRange(subnet) {
+    if (typeof (subnet) === 'string') {
+        subnet = ipaddr.createCIDR(subnet);
+    }
+    var first = subnet.first();
+    var last = subnet.last();
+    return [first.toString(), last.toString()];
+}
+
+/* Subnets overlap if s1.maximum >= s2.minimum */
+var IP_10_0_0_0 = ipaddr.parse('10.0.0.0');
+var IP_172_16_0_0 = ipaddr.parse('172.16.0.0');
+var IP_192_168_0_0 = ipaddr.parse('192.168.0.0');
+
+var IP_10_255_255_255 = ipaddr.parse('10.255.255.255');
+var IP_172_31_255_255 = ipaddr.parse('172.31.255.255');
+
+function previousAddr(addr) {
+    if (addr.compare(IP_10_0_0_0) === 0) {
+        throw new Error('address should always be decrementable');
+    } else if (addr.compare(IP_172_16_0_0) === 0) {
+        return IP_10_255_255_255;
+    } else if (addr.compare(IP_192_168_0_0) === 0) {
+        return IP_172_31_255_255;
+    } else {
+        return addr.offset(-1);
+    }
+}
+
+function subnetsAdjacent(sn1, sn2) {
+    var prev = previousAddr(sn2.address());
+    return sn1.contains(prev);
+}
+
+/*
+ * We percieve a gap between two subnets is they don't overlap and are not
+ * adjacent.
+ */
+function haveGapBetweenSubnets(s1, s2, plen) {
+    // XXX TODO even if we have a gap we might not be able to allocate from it
+    // because the prefix-length might not allow it.
+    // i.e.
+    //      There is a gap between 10.0.10.0/24 and 10.2.1.0/24
+    //      But if we need /12, we can get a non-verlapping 10.X,
+    //      from that gap.
+    //      IOW: There is a gap between 10.0/24 and 10.2/24, but between
+    //      10.0/12 and 10.2/12 i.e.:  10.[000000|00] and 10.[000000|10]
+    return (!subnetsAdjacent(s1, s2));
+}
+
+
+function ip (s) {
+    return (ipaddr.parse(s));
+}
+
+/*
+ * We decrement a subnet's prefix by one, starting from leftmost possible byte.
+ * Return NULL if we can't.
+ */
+function decSubImpl(addr, plen) {
+    var new_addr = addr.first().offset(-1);
+    var new_addr2 = addr.first().offset(-2);
+    if (new_addr2.compare(ip('9.255.255.255')) === 0) {
+        return null;
+    } else if (new_addr2.compare(ip('172.15.255.255')) === 0) {
+        new_addr = ipaddr.parse('10.255.255.0');
+    } else if (new_addr2.compare(ip('192.167.255.255')) === 0) {
+        new_addr = ipaddr.parse('172.31.0.0');
+    }
+    if (addr.contains(new_addr)) {
+        new_addr = new_addr2;
+    }
+
+    return ipaddr.createCIDR(new_addr, plen);
+}
+
+/*
+ * We increment a subnet's prefix by one, starting from left-most possible byte.
+ * Return NULL if we can't.
+ * XXX, currently we can's increment any component that's not a full-sized byte.
+ * For example, if we have 10.224.0.0/12, we can't increment the first 4 bits of
+ * 224 to be 240. However, we should eventually gain this capability in the
+ * future. Bitwise operation in JS are error prone.
+ */
+function incSubImpl(addr, plen) {
+    var new_addr = addr.last().offset(1);
+    var new_addr2 = addr.last().offset(2);
+    if (new_addr2.compare(ip('11.0.0.0')) === 0) {
+        new_addr = ipaddr.parse('172.16.0.0');
+    } else if (new_addr2.compare(ip('172.32.0.0')) === 0) {
+        new_addr = ipaddr.parse('192.168.0.0');
+    } else if (new_addr2.compare(ip('192.169.0.0')) === 0) {
+        return null;
+    }
+    if (addr.contains(new_addr)) {
+        new_addr = new_addr2;
+    }
+
+    return ipaddr.createCIDR(new_addr, plen);
+}
+
+/*
+ * Increment a subnet's prefix, but restrict the prefix length of the resulting
+ * subnet to 'nlen'-bits.
+ *
+ *  10.88.0.0/16 ===> 10.89.0.0/'nlen'
+ */
+function incrementSubnet(cidr, nlen) {
+    assert.number(nlen, 'nlen');
+    var plen = cidr.prefixLength();
+    var adjustedCIDR = ipaddr.createCIDR(cidr.address(), Math.min(plen, nlen));
+    var naddr = incSubImpl(adjustedCIDR, nlen);
+    return naddr ? naddr.toString() : null;
+}
+
+/*
+ * Same as above but decrements.
+ */
+function decrementSubnet(cidr, nlen) {
+    assert.number(nlen, 'nlen');
+    var plen = cidr.prefixLength();
+    var adjustedCIDR = ipaddr.createCIDR(cidr.address(), Math.min(plen, nlen));
+    var naddr = decSubImpl(adjustedCIDR, nlen);
+    return naddr ? naddr.toString() : null;
+}
+
+module.exports = {
+    allocProvisionRange: allocProvisionRange,
+    decrementSubnet: decrementSubnet,
+    incrementSubnet: incrementSubnet,
+    haveGapBetweenSubnets: haveGapBetweenSubnets
+};
diff --git a/lib/util/constants.js b/lib/util/constants.js
index 537439e..4053d64 100644
--- a/lib/util/constants.js
+++ b/lib/util/constants.js
@@ -178,6 +178,7 @@ module.exports = {
         'provision_start_ip must be before provision_end_ip',
     SERVER_UNDERLAY_MSG: 'Only server NICs can be underlay NICs',
     SUBNET_FULL_MSG: 'no more free IPs',
+    SUBNETS_EXHAUSTED_MSG: 'out of subnets',
     SUBNET_GATEWAY_MISMATCH: 'gateway should match subnet type (%s)',
     SUBNET_RESOLVER_MISMATCH: 'resolvers should match subnet type (%s)',
     SUBNET_ROUTE_DST_MISMATCH:
diff --git a/lib/util/errors.js b/lib/util/errors.js
index 0fa6fd0..8fdecfb 100644
--- a/lib/util/errors.js
+++ b/lib/util/errors.js
@@ -135,6 +135,23 @@ function SubnetFullError(network_uuid) {
 
 util.inherits(SubnetFullError, restify.RestError);
 
+function SubnetsExhaustedError() {
+
+    restify.RestError.call(this, {
+        restCode: 'SubnetsExhaustedError',
+        statusCode: 507,
+        message: constants.SUBNETS_EXHAUSTED_MSG,
+        body: {
+            code: 'SubnetsExhaustedError',
+            message: constants.SUBNETS_EXHAUSTED_MSG
+        }
+    });
+
+    this.name = 'SubnetsExhaustedError';
+    this.stop = true;
+}
+
+util.inherits(SubnetsExhaustedError, restify.RestError);
 
 /**
  * Base error class for when all networks in a pool are full.
@@ -306,6 +323,17 @@ function usedByParam(field, type, id, message) {
     return paramErr;
 }
 
+function sortErrsByField(errs) {
+    errs.sort(function (a, b) {
+        if (a.field < b.field) {
+            return -1;
+        }
+        if (a.field > b.field) {
+            return 1;
+        }
+        return 0;
+    });
+}
 
 
 module.exports = {
@@ -321,7 +349,9 @@ module.exports = {
     nictagMtuInvalidForNetworks: nictagMtuInvalidForNetworks,
     PoolFullError: PoolFullError,
     SubnetFullError: SubnetFullError,
+    SubnetsExhaustedError: SubnetsExhaustedError,
     unknownParams: unknownParams,
     usedBy: usedBy,
-    usedByParam: usedByParam
+    usedByParam: usedByParam,
+    sortErrsByField: sortErrsByField
 };
diff --git a/lib/util/validate.js b/lib/util/validate.js
index 1d00a3e..cfd9223 100644
--- a/lib/util/validate.js
+++ b/lib/util/validate.js
@@ -53,6 +53,23 @@ function validateBoolean(_, name, val, callback) {
     return callback(new errors.invalidParam(name, 'must be a boolean value'));
 }
 
+/**
+ * Currently validates that prefix is 24, but will validate (8,32) when SDC
+ * grows support for that.
+ */
+function validateSubnetPrefix(_, name, val, callback) {
+    if (typeof (val) !== 'number') {
+        callback(new errors.invalidParam(name, 'Subnet prefix should be number'));
+        return;
+    }
+
+    if (val !== 24) {
+        callback(new errors.invalidParam(name, 'Only /24 is supported'));
+        return;
+    }
+
+    callback(null, val);
+}
 
 /**
  * Validates that a value is one of the values present in an array that
@@ -341,6 +358,7 @@ function validateVxlanID(_, name, vlan_id, callback) {
 
 module.exports = {
     bool: validateBoolean,
+    subnetPrefix: validateSubnetPrefix,
     enum: validateEnum,
     fieldsArray: warden.fieldsArray,
     IP: validateIP,
diff --git a/test/integration/fabrics.test.js b/test/integration/fabrics.test.js
index cc2f31f..6605274 100644
--- a/test/integration/fabrics.test.js
+++ b/test/integration/fabrics.test.js
@@ -41,6 +41,8 @@ var extend = mod_jsprim.mergeObjects;
 var ADMIN_OWNER = config.server.ufdsAdminUuid;
 var CREATED = {};
 var OWNERS = [
+    mod_uuid.v4(),
+    mod_uuid.v4(),
     mod_uuid.v4(),
     mod_uuid.v4(),
     mod_uuid.v4()
@@ -74,8 +76,21 @@ var VLANS = [
         name: mod_vlan.randomName(),
         owner_uuid: OWNERS[2],
         vlan_id: 44
+    },
+
+    {
+        name: mod_vlan.randomName(),
+        owner_uuid: OWNERS[3],
+        vlan_id: 45
+    },
+
+    {
+        name: mod_vlan.randomName(),
+        owner_uuid: OWNERS[4],
+        vlan_id: 45
     }
 ];
+
 // Real (non-fabric networks):
 var REAL_NETS = [
     h.validNetworkParams({ nic_tag: UNDERLAY_NIC_TAG }),
@@ -159,9 +174,33 @@ var NETS = [
         owner_uuid: VLANS[3].owner_uuid,
         provision_start_ip: '172.16.1.1',
         provision_end_ip: '172.16.3.254'
+    },
+
+    // 5: Used for testing subnet alloc
+    {
+        vlan_id: VLANS[4].vlan_id,
+        subnet_alloc: true,
+        subnet_prefix: 24,
+        family: 'ipv4',
+        // Also double-check that the MTU is correct:
+        mtu: OVERLAY_MTU,
+        name: mod_fabric_net.generateName(),
+        owner_uuid: VLANS[4].owner_uuid
+    },
+    // 6: Used for testing subnet alloc
+    {
+        vlan_id: VLANS[5].vlan_id,
+        subnet_alloc: true,
+        subnet_prefix: 24,
+        family: 'ipv4',
+        // Also double-check that the MTU is correct:
+        mtu: OVERLAY_MTU,
+        name: mod_fabric_net.generateName(),
+        owner_uuid: VLANS[5].owner_uuid
     }
 
 ];
+
 var VMS = [
     mod_uuid.v4(),
     mod_uuid.v4(),
@@ -321,6 +360,35 @@ test('create VLANs', function (t) {
         });
     });
 
+    t.test('create vlan: 4', function (t2) {
+        mod_vlan.createAndGet(t2, {
+            params: extend(VLANS[4], {
+                // Specify at least owner_uuid and vlan_id - these are required
+                // by mod_vlan.delAllCreated() in the test teardown.
+                fields: [ 'name', 'owner_uuid', 'vlan_id' ]
+            }),
+            exp: {
+                name: VLANS[4].name,
+                owner_uuid: VLANS[4].owner_uuid,
+                vlan_id: VLANS[4].vlan_id
+            }
+        });
+    });
+
+    t.test('create vlan: 5', function (t2) {
+        mod_vlan.createAndGet(t2, {
+            params: extend(VLANS[5], {
+                // Specify at least owner_uuid and vlan_id - these are required
+                // by mod_vlan.delAllCreated() in the test teardown.
+                fields: [ 'name', 'owner_uuid', 'vlan_id' ]
+            }),
+            exp: {
+                name: VLANS[5].name,
+                owner_uuid: VLANS[5].owner_uuid,
+                vlan_id: VLANS[5].vlan_id
+            }
+        });
+    });
 });
 
 
@@ -547,6 +615,45 @@ test('create network', function (t) {
         });
     });
 
+    t.test('create network: 5', function (t2) {
+        mod_fabric_net.createAndGet(t2, {
+            params: extend(NETS[5], {
+                // mod_fabric_net.delAllCreated() needs uuid, owner_uuid and
+                // vlan_id in order to delete the network:
+                fields: [ 'name', 'owner_uuid', 'subnet', 'uuid', 'vlan_id' ]
+            }),
+            partialExp: {
+                name: NETS[5].name,
+                owner_uuid: NETS[5].owner_uuid,
+                // uuid gets filled in by createAndGet()
+                vlan_id: NETS[5].vlan_id
+            }
+        }, function (_err, res) {
+            t.ok(typeof (res.subnet) !== 'undefined', 'Subnet present');
+            t2.end();
+        });
+    });
+
+    t.test('create network: 6', function (t2) {
+        mod_fabric_net.createAndGet(t2, {
+            params: extend(NETS[6], {
+                // mod_fabric_net.delAllCreated() needs uuid, owner_uuid and
+                // vlan_id in order to delete the network:
+                fields: [ 'name', 'owner_uuid', 'subnet', 'uuid', 'vlan_id' ]
+            }),
+            partialExp: {
+                name: NETS[6].name,
+                owner_uuid: NETS[6].owner_uuid,
+                // uuid gets filled in by createAndGet()
+                vlan_id: NETS[6].vlan_id
+            }
+        }, function (_err, res) {
+            t.ok(typeof (res.subnet) !== 'undefined', 'Subnet present');
+            t2.end();
+            t.end();
+        });
+    });
+
 });
 
 
diff --git a/test/unit/networks-subnet-alloc.test.js b/test/unit/networks-subnet-alloc.test.js
new file mode 100644
index 0000000..49742d2
--- /dev/null
+++ b/test/unit/networks-subnet-alloc.test.js
@@ -0,0 +1,372 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright 2017, Joyent, Inc.
+ */
+
+/*
+ * Unit tests for subnet allocation.
+ */
+
+'use strict';
+
+var h = require('./helpers');
+var mod_err = require('../../lib/util/errors');
+var mod_vlan = require('../lib/vlan');
+var mod_fabric_net = require('../lib/fabric-net');
+var mod_server = require('../lib/server');
+var test = require('tape');
+var mod_uuid = require('node-uuid');
+
+
+// --- Globals
+
+var NETS = [];
+var TAG;
+var VLAN = {
+    name: mod_vlan.randomName(),
+    owner_uuid: mod_uuid.v4(),
+    vlan_id: 20
+};
+var VLAN_extra = {
+    name: mod_vlan.randomName(),
+    owner_uuid: mod_uuid.v4(),
+    vlan_id: 21
+};
+var NAPI;
+
+
+// --- Setup
+
+test('Initial setup', function (t) {
+    h.reset();
+
+    t.test('Start server', function (t2) {
+        h.createClientAndServer(function (err, res) {
+            t2.ifError(err, 'server creation');
+            t2.ok(res, 'client');
+            NAPI = res;
+            if (!NAPI) {
+                t2.end();
+                return;
+            }
+            NAPI.createNicTag('sdc_overlay', function (err2, res2) {
+                TAG = res2;
+                t2.ifError(err2, 'nic tag');
+                t2.ok(TAG, 'created NIC tag');
+                t2.end();
+            });
+        });
+    });
+
+    t.test('Create VLAN', function (t2) {
+        mod_vlan.createAndGet(t2, {
+            params: VLAN,
+            exp: VLAN
+        }, function (err, res) {
+            t2.ifError(err, 'vlan get');
+            t2.ok(res, 'vlan');
+            t2.end();
+        });
+    });
+
+    t.test('Create VLAN extra', function (t2) {
+        mod_vlan.createAndGet(t2, {
+            params: VLAN_extra,
+            exp: VLAN_extra
+        }, function (err, res) {
+            t2.ifError(err, 'vlan get');
+            t2.ok(res, 'vlan');
+            t2.end();
+            t.end();
+        });
+    });
+
+
+});
+
+// Tests
+
+// We want to test the auto-allocation code, especially edge-cases in the
+// allocator --- i.e. out-of-subnets, no gap between 2 subnets, and so forth.
+// Since we control all the data that goes into postgres from these unit tests,
+// we can also verify that the expected subnet was allocated.
+
+
+// We also want to test the behaviour related to different prefix-lengths.
+
+// Want to test these code-paths:
+// auto-alloc when we have 0 subnets, should be 10.0.0.0/24
+// auto-alloc when we have >1 subnet, but no gaps
+//      So, auto-alloc again, and we have: 10.1.0.0/24 (no gap)
+//      Another auto-alloc should give us 10.2.0.0/24
+// auto-alloc when we have >1 subnets and 1 gap
+//      So, man-alloc 10.4.0.0/24
+//      Another auto-alloc should give us 10.3.0.0/24
+// Keep allocating subnets until we run out.
+// Unit test the increment and decrement functionality (isolated from PG)
+//      Ok we want to test each of the jumps between 10, 172, 192
+
+test('Create networks', function (t) {
+    t.test('Create w/ auto1', function (t2) {
+        mod_fabric_net.create(t2, {
+            fillInMissing: true,
+            params: {
+                subnet_alloc: true,
+                owner_uuid: VLAN.owner_uuid,
+                family: 'ipv4',
+                subnet_prefix: 24,
+                name: mod_fabric_net.generateName(),
+                vlan_id: VLAN.vlan_id
+            },
+            partialExp: {
+                vlan_id: VLAN.vlan_id,
+                family: 'ipv4',
+                subnet: '10.0.0.0/24'
+            }
+        }, function (_, res) {
+            NETS.push(res);
+            t2.end();
+        });
+    });
+    t.test('Create w/ auto2', function (t2) {
+        mod_fabric_net.create(t2, {
+            fillInMissing: true,
+            params: {
+                subnet_alloc: true,
+                family: 'ipv4',
+                owner_uuid: VLAN.owner_uuid,
+                subnet_prefix: 24,
+                name: mod_fabric_net.generateName(),
+                vlan_id: VLAN.vlan_id
+            },
+            partialExp: {
+                vlan_id: VLAN.vlan_id,
+                family: 'ipv4'
+            }
+        }, function (_, res) {
+            t2.equal(res.subnet, '10.0.1.0/24');
+            NETS.push(res);
+            t2.end();
+        });
+    });
+    t.test('Create w/ manual', function (t2) {
+        mod_fabric_net.create(t2, {
+            fillInMissing: true,
+            params: {
+                subnet: '10.0.3.0/24',
+                provision_start_ip: '10.0.3.1',
+                provision_end_ip: '10.0.3.254',
+                name: mod_fabric_net.generateName(),
+                owner_uuid: VLAN.owner_uuid,
+                vlan_id: VLAN.vlan_id
+            },
+            partialExp: {
+                vlan_id: VLAN.vlan_id,
+                family: 'ipv4'
+            }
+        }, function (_, res) {
+            t2.equal(res.subnet, '10.0.3.0/24');
+            NETS.push(res);
+            t2.end();
+        });
+    });
+    t.test('Create w/ manual missing/mixed params', function (t2) {
+        var errs = [];
+        errs.push(new mod_err.missingParam('provision_start_ip'));
+        errs.push(new mod_err.invalidParam('subnet_prefix',
+            'Auto allocation parameter not allowed'));
+        mod_err.sortErrsByField(errs);
+        var errBody = {
+            code: 'InvalidParameters',
+            errors: errs,
+            message: 'Invalid parameters'
+        };
+        mod_fabric_net.create(t2, {
+            fillInMissing: false,
+            params: {
+                subnet: '10.0.3.0/24',
+                subnet_prefix: 24,
+                provision_end_ip: '10.0.3.254',
+                name: mod_fabric_net.generateName(),
+                owner_uuid: VLAN.owner_uuid,
+                vlan_id: VLAN.vlan_id
+            },
+            expCode: 422,
+            expErr: errBody
+        }, function (_, res) {
+            t2.end();
+        });
+    });
+    t.test('Create w/ auto3', function (t2) {
+        mod_fabric_net.create(t2, {
+            fillInMissing: true,
+            params: {
+                subnet_alloc: true,
+                family: 'ipv4',
+                owner_uuid: VLAN.owner_uuid,
+                subnet_prefix: 24,
+                name: mod_fabric_net.generateName(),
+                vlan_id: VLAN.vlan_id
+            },
+            partialExp: {
+                vlan_id: VLAN.vlan_id,
+                family: 'ipv4'
+            }
+        }, function (_, res) {
+            t2.equal(res.subnet, '10.0.2.0/24');
+            NETS.push(res);
+            t2.end();
+        });
+    });
+
+    t.test('Create w/ auto4 missing/mixed params', function (t2) {
+        var errs = [];
+        errs.push(new mod_err.missingParam('family'));
+        errs.push(new mod_err.missingParam('subnet_prefix'));
+        errs.push(new mod_err.invalidParam('subnet',
+            'Manual allocation parameter not allowed'));
+        mod_err.sortErrsByField(errs);
+        var errBody = {
+            code: 'InvalidParameters',
+            errors: errs,
+            message: 'Invalid parameters'
+        };
+        mod_fabric_net.create(t2, {
+            fillInMissing: true,
+            params: {
+                subnet_alloc: true,
+                subnet: '10.0.0.0/8',
+                owner_uuid: VLAN.owner_uuid,
+                name: mod_fabric_net.generateName(),
+                vlan_id: VLAN.vlan_id
+            },
+            expCode: 422,
+            expErr: errBody
+        });
+    });
+
+
+    t.test('Delete Networks', function (t2) {
+        mod_fabric_net.delAllCreated(t2);
+    });
+
+
+    // We create 3 subnets, that consume all available addresses:
+    // 10.0.0.0/8, 172.16.0.0/16, 192.168.0.0/24
+    // When we try to auto-alloc we should get an exhausted-subnets error
+    t.test('Exhaustion and Owner Test', function (t2) {
+        t2.test('Create sub 1/3', function (t3) {
+            mod_fabric_net.create(t3, {
+                fillInMissing: true,
+                params: {
+                    subnet: '10.0.0.0/8',
+                    provision_start_ip: '10.0.0.1',
+                    provision_end_ip: '10.255.255.254',
+                    owner_uuid: VLAN.owner_uuid,
+                    name: mod_fabric_net.generateName(),
+                    vlan_id: VLAN.vlan_id
+                },
+                partialExp: {
+                    vlan_id: VLAN.vlan_id,
+                    family: 'ipv4'
+                }
+            }, function (_, res) {
+                NETS.push(res);
+                t3.end();
+            });
+        });
+        t2.test('Create sub 2/3', function (t3) {
+            mod_fabric_net.create(t3, {
+                fillInMissing: true,
+                params: {
+                    subnet: '172.16.0.0/12',
+                    provision_start_ip: '172.16.0.1',
+                    provision_end_ip: '172.31.255.254',
+                    owner_uuid: VLAN.owner_uuid,
+                    name: mod_fabric_net.generateName(),
+                    vlan_id: VLAN.vlan_id
+                },
+                partialExp: {
+                    vlan_id: VLAN.vlan_id,
+                    family: 'ipv4'
+                }
+            }, function (_, res) {
+                NETS.push(res);
+                t3.end();
+            });
+        });
+        t2.test('Create sub 3/3', function (t3) {
+            mod_fabric_net.create(t3, {
+                fillInMissing: true,
+                params: {
+                    subnet: '192.168.0.0/16',
+                    provision_start_ip: '192.168.0.1',
+                    provision_end_ip: '192.168.255.254',
+                    owner_uuid: VLAN.owner_uuid,
+                    name: mod_fabric_net.generateName(),
+                    vlan_id: VLAN.vlan_id
+                },
+                partialExp: {
+                    vlan_id: VLAN.vlan_id,
+                    family: 'ipv4'
+                }
+            }, function (_, res) {
+                NETS.push(res);
+                t3.end();
+            });
+        });
+        var err = new mod_err.SubnetsExhaustedError();
+        var errBody = err.body;
+        t2.test('Attempt Auto Alloc', function (t3) {
+            mod_fabric_net.create(t3, {
+                fillInMissing: true,
+                params: {
+                    subnet_alloc: true,
+                    family: 'ipv4',
+                    owner_uuid: VLAN.owner_uuid,
+                    subnet_prefix: 24,
+                    name: mod_fabric_net.generateName(),
+                    vlan_id: VLAN.vlan_id
+                },
+                expCode: 507,
+                expErr: errBody
+            }, function () {
+                t3.end();
+            });
+        });
+        t2.test('Auto Alloc Diff Owner', function (t3) {
+            mod_fabric_net.create(t3, {
+                fillInMissing: true,
+                params: {
+                    subnet_alloc: true,
+                    family: 'ipv4',
+                    owner_uuid: VLAN_extra.owner_uuid,
+                    subnet_prefix: 24,
+                    name: mod_fabric_net.generateName(),
+                    vlan_id: VLAN_extra.vlan_id
+                },
+                partialExp: {
+                    vlan_id: VLAN_extra.vlan_id,
+                    family: 'ipv4'
+                }
+            }, function (_, res) {
+                t3.equal(res.subnet, '10.0.0.0/24');
+                NETS.push(res);
+                t3.end();
+            });
+        });
+    });
+
+    t.end();
+});
+
+// --- Teardown
+
+test('delete networks', mod_fabric_net.delAllCreated);
+
+test('Stop server', mod_server.close);
diff --git a/test/unit/networks.test.js b/test/unit/networks.test.js
index 3869a5f..f829c50 100644
--- a/test/unit/networks.test.js
+++ b/test/unit/networks.test.js
@@ -153,8 +153,7 @@ test('Create network - missing parameters', function (t) {
 
         t.equal(err.statusCode, 422, 'status code');
         t.deepEqual(err.body, h.invalidParamErr({
-            errors: ['name', 'nic_tag', 'provision_end_ip',
-                'provision_start_ip', 'subnet', 'vlan_id'].map(function (name) {
+            errors: ['name', 'nic_tag', 'vlan_id'].map(function (name) {
                     return {
                         code: 'MissingParameter',
                         field: name,
@@ -178,8 +177,7 @@ test('Create network - missing and invalid parameters', function (t) {
 
         t.equal(err.statusCode, 422, 'status code');
         t.deepEqual(err.body, h.invalidParamErr({
-            errors: ['name', 'nic_tag', 'provision_end_ip',
-                'subnet', 'vlan_id'].map(function (name) {
+            errors: ['name', 'nic_tag', 'vlan_id'].map(function (name) {
                     return {
                         code: 'MissingParameter',
                         field: name,
diff --git a/test/unit/util-alloc.test.js b/test/unit/util-alloc.test.js
new file mode 100644
index 0000000..01d6eb8
--- /dev/null
+++ b/test/unit/util-alloc.test.js
@@ -0,0 +1,120 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright 2017, Joyent, Inc.
+ */
+
+'use strict';
+var test = require('tape');
+var mod_alloc = require('../../lib/util/autoalloc');
+var ipaddr = require('ip6addr');
+var assert = require('assert');
+
+function c (s) {
+    return (ipaddr.createCIDR(s));
+}
+
+var IP_10_0_0_0 = ipaddr.parse('10.0.0.0');
+var IP_172_16_0_0 = ipaddr.parse('172.16.0.0');
+var IP_192_168_0_0 = ipaddr.parse('192.168.0.0');
+
+var IP_10_255_255_255 = ipaddr.parse('10.255.255.255');
+var IP_172_31_255_255 = ipaddr.parse('172.31.255.255');
+
+function previousAddr(addr) {
+    if (addr.compare(IP_10_0_0_0) === 0) {
+        throw new Error('address should always be decrementable');
+    } else if (addr.compare(IP_172_16_0_0) === 0) {
+        return IP_10_255_255_255;
+    } else if (addr.compare(IP_192_168_0_0) === 0) {
+        return IP_172_31_255_255;
+    } else {
+        return addr.offset(-1);
+    }
+
+}
+
+function subnetsAdjacent(sn1, sn2) {
+    var prev = previousAddr(sn2.address());
+    return sn1.contains(prev);
+
+}
+
+
+
+// --- Unit test functions in lib/util/autoalloc.js
+
+test('Alloc Utility Functions', function (t) {
+    t.test('incrementSubnets', function (t2) {
+        t2.equal(null, mod_alloc.incrementSubnet(c('192.168.255.0/24'), 24));
+        t2.equal('10.0.1.0/24',
+                mod_alloc.incrementSubnet(c('10.0.0.0/24'), 24));
+        t2.equal('172.16.0.0/24',
+                mod_alloc.incrementSubnet(c('10.255.255.0/24'), 24));
+        t2.equal('192.168.0.0/24',
+                mod_alloc.incrementSubnet(c('172.31.255.0/24'), 24));
+        t2.equal('10.0.3.0/24',
+                 mod_alloc.incrementSubnet(c('10.0.2.0/25'), 24));
+        t2.end();
+    });
+    t.test('decrementSubnets', function (t2) {
+        t2.equal(null, mod_alloc.decrementSubnet(c('10.0.0.0/24'), 24));
+        t2.equal('10.0.0.0/24',
+                mod_alloc.decrementSubnet(c('10.0.1.0/24'), 24));
+        t2.equal('10.255.255.0/24',
+                mod_alloc.decrementSubnet(c('172.16.0.0/24'), 24));
+        t2.equal('172.31.0.0/24',
+                 mod_alloc.decrementSubnet(c('192.168.0.0/24'), 24));
+        t2.equal('10.0.1.0/24',
+                mod_alloc.decrementSubnet(c('10.0.2.128/25'), 24));
+        t2.end();
+    });
+});
+
+test('Adjacency Tests', function (t) {
+
+    // Moving up through /24s:
+    assert.equal(subnetsAdjacent(c('10.0.0.0/24'), c('10.0.1.0/24')), true);
+    assert.equal(subnetsAdjacent(c('10.0.1.0/24'), c('10.0.2.0/24')), true);
+    assert.equal(subnetsAdjacent(c('10.0.2.0/24'), c('10.0.3.0/24')), true);
+
+    // Non-adjacent /24s:
+    assert.equal(subnetsAdjacent(c('10.0.0.0/24'), c('10.0.2.0/24')), false);
+    assert.equal(subnetsAdjacent(c('10.0.5.0/24'), c('172.16.0.0/24')), false);
+    assert.equal(subnetsAdjacent(c('172.16.0.0/24'), c('172.16.2.0/24')), false);
+    assert.equal(subnetsAdjacent(c('192.168.0.0/24'), c('192.168.2.0/24')), false);
+
+    // Adjacent subnets of different prefix lengths:
+    assert.equal(subnetsAdjacent(c('10.0.1.128/25'), c('10.0.2.0/26')), true);
+    assert.equal(subnetsAdjacent(c('10.0.1.0/24'), c('10.0.2.0/26')), true);
+    assert.equal(subnetsAdjacent(c('10.0.1.0/24'), c('10.0.2.0/30')), true);
+
+    // Non-adjacent subnets of different prefix lengths:
+    assert.equal(subnetsAdjacent(c('10.0.0.0/25'), c('10.0.1.0/24')), false);
+    assert.equal(subnetsAdjacent(c('10.0.1.0/30'), c('10.0.2.0/24')), false);
+    assert.equal(subnetsAdjacent(c('10.0.2.0/32'), c('10.0.3.0/24')), false);
+
+    // Ignore non-RFC 1918 spaces for the purposes of adjacency:
+    assert.equal(subnetsAdjacent(c('10.0.0.0/8'), c('172.16.0.0/30')), true);
+    assert.equal(subnetsAdjacent(c('172.31.0.0/16'), c('192.168.0.0/26')), true);
+
+    // Non-adjacent spaces:
+    assert.equal(subnetsAdjacent(c('10.0.0.0/24'), c('172.16.0.0/30')), false);
+    assert.equal(subnetsAdjacent(c('172.31.0.0/24'), c('192.168.0.0/26')), false);
+
+    // IPv6 ULA adjacent:
+    assert.equal(subnetsAdjacent(c('fd00::/16'), c('fd01::/16')), true);
+    assert.equal(subnetsAdjacent(c('fd01::/16'), c('fd02::/16')), true);
+    assert.equal(subnetsAdjacent(c('fd00:3::/32'), c('fd00:4::/32')), true);
+    assert.equal(subnetsAdjacent(c('fd00:3::/32'), c('fd00:4::/64')), true);
+
+    // IPv6 ULA non-adjacent:
+    assert.equal(subnetsAdjacent(c('fd00::/16'), c('fd02::/16')), false);
+    assert.equal(subnetsAdjacent(c('fd00::/16'), c('fd4e::/16')), false);
+    t.end();
+
+});
-- 
2.21.0

