From 5c92078a194b4a3178dba75d76d25b834de97434 Mon Sep 17 00:00:00 2001
From: Nick Zivkovic <nick.zivkovic@joyent.com>
Date: Sat, 4 Nov 2017 00:10:29 +0000
Subject: [PATCH] NAPI-434 Want way to automatically generate unused subnets

---
 lib/models/network.js                   | 336 +++++++++++++++++++++++-
 lib/util/autoalloc.js                   | 167 ++++++++++++
 lib/util/constants.js                   |   1 +
 lib/util/errors.js                      |  18 ++
 lib/util/validate.js                    |  31 +++
 test/integration/fabrics.test.js        |  54 ++++
 test/unit/networks-subnet-alloc.test.js | 314 ++++++++++++++++++++++
 test/unit/networks.test.js              |   6 +-
 8 files changed, 918 insertions(+), 9 deletions(-)
 create mode 100644 lib/util/autoalloc.js
 create mode 100644 test/unit/networks-subnet-alloc.test.js

diff --git a/lib/models/network.js b/lib/models/network.js
index b2fa213..0d35a6d 100644
--- a/lib/models/network.js
+++ b/lib/models/network.js
@@ -32,6 +32,7 @@ var UUID = require('node-uuid');
 var validate = require('../util/validate');
 var vasync = require('vasync');
 var VError = require('verror');
+var autoalloc = require('../util/autoalloc');
 /*
  * Circular dependencies required at end of file.
  */
@@ -151,15 +152,18 @@ var CREATE_SCHEMA = {
         nic_tag: function _nicTagExists(opts, name, tags, callback) {
             mod_nicTag.validateExists(true, opts, name, tags, callback);
         },
-        provision_end_ip: validate.IP,
-        provision_start_ip: validate.IP,
-        subnet: validate.subnet,
         vlan_id: validate.VLAN
     },
     optional: {
         description: validate.string,
         // XXX: allow this?
         fabric: validate.bool,
+        subnet_alloc: validate.bool,
+        family: validate.addrFamily,
+        subnet_prefix: validate.subnetPrefix,
+        subnet: validate.subnet,
+        provision_end_ip: validate.IP,
+        provision_start_ip: validate.IP,
         fields: validate.fieldsArray(VALID_FIELDS),
         gateway: validateGateway,
         internet_nat: validate.bool,
@@ -172,6 +176,7 @@ var CREATE_SCHEMA = {
     },
     after: [
         validateFabricOwner,
+        validateSubnetAlloc,
         validateProvisionRange,
         validateNicTagMTU
     ]
@@ -246,7 +251,15 @@ var GET_SCHEMA = {
 
 // --- Internal
 
+function getMarkerSubnet(net_obj) {
+    return (net_obj.subnet);
+}
 
+var AUTO_ALLOC_FILTERS = [
+    '(&(subnet>=10.0.0.0/8)(subnet<=10.255.255.255/32))',
+    '(&(subnet>=172.16.0.0/12)(subnet<=172.31.255.255/32))',
+    '(&(subnet>=192.168.0.0/16)(subnet<=192.168.255.255/32))'
+];
 
 /**
  * Given a NIC, return a UsedBy error description for a 'nic',
@@ -681,6 +694,94 @@ function validateProvisionRangeUpdate(opts, params, parsed, cb) {
     }, null, toValidate, cb);
 }
 
+function validateSubnetAutoAlloc(_opts, _, parsedParams, callback) {
+    var mixed_params = [];
+    var missing_params = [];
+    if (parsedParams.subnet) {
+        mixed_params.push('subnet');
+    }
+    if (parsedParams.provision_start_ip) {
+        mixed_params.push('provision_start_ip');
+    }
+    if (parsedParams.provision_end_ip) {
+        mixed_params.push('provision_end_ip');
+    }
+    if (mixed_params.length > 0) {
+        mixed_params.sort();
+        callback(new errors.invalidParam('subnet_auto_alloc',
+            'Manual allocation params detected: ' +
+            mixed_params));
+        return;
+    }
+
+    if (!parsedParams.family) {
+        missing_params.push('family');
+    }
+    if (!parsedParams.subnet_prefix) {
+        missing_params.push('subnet_prefix');
+    }
+    if (!parsedParams.vnet_id) {
+        missing_params.push('vnet_id');
+    }
+    if (missing_params.length > 0) {
+        missing_params.sort();
+        callback(new errors.invalidParam('subnet_auto_alloc',
+            'params missing:' + missing_params));
+        return;
+    }
+    callback();
+}
+
+function validateSubnetParamsAlloc(_opts, _, parsedParams, callback) {
+    var mixed_params = [];
+    var missing_params = [];
+    if (parsedParams.subnet_alloc) {
+        mixed_params.push('subnet_alloc');
+    }
+    if (parsedParams.addr_prefix) {
+        mixed_params.push('addr_prefix');
+    }
+    if (parsedParams.subnet_prefix) {
+        mixed_params.push('subnet_prefix');
+    }
+    if (mixed_params.length > 0) {
+        mixed_params.sort();
+        callback(new errors.invalidParam('subnet_params_alloc',
+            'Auto allocation params detected: ' +
+            mixed_params));
+        return;
+    }
+    if (!parsedParams.provision_start_ip) {
+        missing_params.push('provision_start_ip');
+    }
+    if (!parsedParams.provision_end_ip) {
+        missing_params.push('provision_end_ip');
+    }
+    if (missing_params.length > 0) {
+        missing_params.sort();
+        callback(new errors.invalidParam('subnet_params_alloc',
+            'params missing:' + missing_params));
+        return;
+    }
+    callback();
+}
+
+/*
+ * Validates that these two sets of params do not overlap:
+ *
+ *    [subnet, provision_start_ip, provision_end_ip]
+ *    [subnet_alloc, family, subnet_prefix]
+ *
+ * Also validates that params.fabric = true and vnet_id = defined for
+ * subnet_alloc path.
+ */
+function validateSubnetAlloc(opts, origin, parsedParams, callback) {
+    if (parsedParams.subnet_alloc) {
+        validateSubnetAutoAlloc(opts, origin, parsedParams, callback);
+    } else {
+        validateSubnetParamsAlloc(opts, origin, parsedParams, callback);
+    }
+}
 
 /**
  * Validates that:
@@ -689,8 +790,10 @@ function validateProvisionRangeUpdate(opts, params, parsed, cb) {
  * * that end doesn't come before start.
  */
 function validateProvisionRange(opts, _, parsedParams, callback) {
-    if (!parsedParams.subnet_start || !parsedParams.subnet_bits) {
-        return callback();
+    if (parsedParams.subnet_alloc || !parsedParams.subnet_start ||
+        !parsedParams.subnet_bits) {
+        callback();
+        return;
     }
 
     var errs = [];
@@ -1461,6 +1564,188 @@ Network.prototype.matches = function matchesIntersection(intersection) {
     return true;
 };
 
+/*
+ * Hits the napi_networks bucket, and filters the results according to 'filter'
+ * which is a string.
+ */
+function listFilteredNetworks(opts, filter, attr, callback) {
+    var app = opts.app;
+    var log = opts.log;
+    var offset, limit;
+
+    mod_moray.listObjs({
+        defaultFilter: '(uuid=*)',
+        filter: filter,
+        limit: limit,
+        log: log,
+        offset: offset,
+        bucket: BUCKET,
+        model: Network,
+        moray: app.moray,
+        sort: {
+            attribute: attr,
+            order: 'ASC'
+        }
+    }, callback);
+}
+
+/*
+ * Add an additionaly boolean expression to the filter, that includes only all
+ * subnets that appear after 'marker'.
+ */
+function addSubnetMarkerToFilter(filter, marker) {
+    if (marker) {
+        return '(&' + filter + '!(subnet<=' + marker + '))';
+    }
+    return filter;
+}
+
+/*
+ * Wraps listFilteredNetworks in a LOMStream. Looks at 10 networks at a time.
+ */
+function listFilteredNetworksStream(opts, baseFilter, marker, attr) {
+    var dupOpts = jsprim.deepCopy(opts);
+    var filter;
+
+    var s = new lomstream.LOMStream({
+        fetch: function (opts2, lobj, _datacb, cb) {
+            var copyOpts = jsprim.deepCopy(opts2);
+            copyOpts.params.limit = lobj.limit;
+            filter = addSubnetMarkerToFilter(baseFilter, lobj.marker);
+
+            listFilteredNetworks(opts2, filter, attr, function (err, nets) {
+                var done = false;
+
+                if (err) {
+                    cb(err);
+                    return;
+                }
+
+                if (nets.length === 0) {
+                    done = true;
+                }
+                cb(null, { done: done, results: nets });
+                return;
+            });
+        },
+        marker: marker,
+        limit: 10,
+        fetcharg: dupOpts
+    });
+    return s;
+}
+
+/*
+ * Walks all subnets in sorted order, such that walker() is called on a sliding
+ * pair of subnets. Callback gets called when we've walked all pairs.
+ * NOTE: there is no canonical way to bail out of walking a stream, so we just
+ * walk it to the end, and don't offer the caller any capability to abort.
+ */
+function subnetPairs(opts, walker, callback) {
+
+    var filter = '(|';
+    filter += '(vnet_id=' + opts.params.vnet_id + ')';
+    filter += AUTO_ALLOC_FILTERS[0];
+    if (opts.params.subnet_prefix >= 12) {
+        filter += AUTO_ALLOC_FILTERS[1];
+    }
+    if (opts.params.subnet_prefix >= 16) {
+        filter += AUTO_ALLOC_FILTERS[2];
+    }
+    filter += ')';
+
+
+    // Sliding window of 2 subnets
+    var pair = [];
+
+    function updatePair(sub) {
+        pair.push(sub);
+        while (pair.length > 2) {
+            pair.shift();
+        }
+    }
+
+    var stream = listFilteredNetworksStream(opts, filter, getMarkerSubnet,
+        'subnet');
+
+    stream.on('error', callback);
+
+    stream.on('readable', function () {
+        var network;
+        for (;;) {
+            network = stream.read(1);
+            if (network === null) {
+                return;
+            }
+            updatePair(network.subnet);
+
+            // We sometimes have duplicates
+            if (pair.length === 2 &&
+                ipaddr.compareCIDR(pair[0], pair[1]) !== 0) {
+                walker(pair);
+            }
+        }
+
+    });
+
+    stream.on('end', function () {
+        if (pair.length < 2) {
+            walker(pair);
+        }
+        callback();
+    });
+}
+
+
+function allocateSubnet(opts, callback) {
+    var new_sub = null;
+    var first_seen = null;
+    var last_seen = null;
+    var plen = opts.params.subnet_prefix;
+    subnetPairs(opts, function (pair) {
+        if (first_seen === null) {
+            first_seen = pair[0];
+        }
+
+        last_seen = pair[(pair.length - 1)];
+        assert.ok(pair.length <= 2);
+        if (pair.length === 0) {
+            new_sub = '10.0.0.0/' + plen;
+        } else if (pair.length === 1 ||
+            autoalloc.haveGapBetweenSubnets(pair[0], pair[1], plen)) {
+
+            if (new_sub === null) {
+                new_sub = autoalloc.incrementSubnet(pair[0], plen);
+            }
+        }
+    }, function (err) {
+        if (err) {
+            callback(err);
+            return;
+        }
+        if (new_sub) {
+            callback(null, new_sub);
+            return;
+        }
+
+        if (!err && !new_sub) {
+            // We have not found a gap, but there may be space before or after
+            // the stream of subnets we've just walked. We try to increment or
+            // decrement the last_seen and first_seen subnets respectively.
+            new_sub = autoalloc.incrementSubnet(last_seen, plen);
+            if (new_sub === null) {
+                new_sub = autoalloc.decrementSubnet(first_seen, plen);
+            }
+
+            if (new_sub !== null) {
+                callback(null, new_sub);
+                return;
+            }
+        }
+
+        callback(new errors.SubnetsExhaustedError());
+    });
+}
 
 
 // --- Exported functions
@@ -1489,11 +1774,50 @@ function createNetwork(opts, callback) {
     var log = opts.log;
     var network;
     var params = opts.params;
+    var copts = {
+        app: app,
+        fabric: opts.fabric,
+        log: log,
+        owner_uuid: opts.owner_uuid
+    };
 
     log.debug(params, 'createNetwork: entry');
 
     vasync.pipeline({
         funcs: [
+        function _validateHttpParams(_, cb) {
+            validate.params(CREATE_SCHEMA, copts, opts.params,
+                function (err, _validatedParams) {
+                    if (err) {
+                        cb(err);
+                        return;
+                    }
+                    cb();
+            });
+        },
+        function _allocateSubnet(_, cb) {
+            if (!params.subnet_alloc) {
+                cb();
+                return;
+            }
+            allocateSubnet(opts, function (err, res) {
+                if (err) {
+                    cb(err);
+                    return;
+                }
+                opts.params.subnet = res;
+                var provrange = autoalloc.allocProvisionRange(res);
+                opts.params.provision_start_ip = provrange[0];
+                opts.params.provision_end_ip = provrange[1];
+                // We zero these out, because they would cause the object
+                // construction to fail in the next pipeline-pass.
+                delete opts.params.subnet_alloc;
+                delete opts.params.family;
+                delete opts.params.subnet_prefix;
+                cb();
+            });
+        },
+
         function _createNetObj(_, cb) {
             createValidNetwork(opts, function (err, res) {
                 if (err) {
@@ -1505,6 +1829,7 @@ function createNetwork(opts, callback) {
             });
         },
 
+
         function _createNet(_, cb) {
             var raw = network.raw();
             log.debug({ uuid: network.uuid, raw: raw },
@@ -1762,6 +2087,7 @@ function validateListNetworks(params, callback) {
 }
 
 
+
 /**
  * Lists networks, filtering by parameters
  */
diff --git a/lib/util/autoalloc.js b/lib/util/autoalloc.js
new file mode 100644
index 0000000..7681de3
--- /dev/null
+++ b/lib/util/autoalloc.js
@@ -0,0 +1,167 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright 2017, Joyent, Inc.
+ */
+
+'use strict';
+var assert = require('assert-plus');
+var ipaddr = require('ip6addr');
+
+function allocProvisionRange(subnet) {
+    if (typeof (subnet) === 'string') {
+        subnet = ipaddr.createCIDR(subnet);
+    }
+    var first;
+    var last;
+    first = subnet.first();
+    last = subnet.last();
+    return [first.toString(), last.toString()];
+}
+
+/* Subnets overlap if s1.maximum >= s2.minimum */
+function subnetsOverlap(sn1, sn2, plen) {
+    assert.ok(ipaddr.compareCIDR(sn1, sn2) < 0);
+    var s1;
+    var s2;
+    if (sn1.prefixLength() !== plen) {
+        s1 = ipaddr.createCIDR(sn1.address(), plen);
+    } else {
+        s1 = sn1;
+    }
+    if (sn2.prefixLength() !== plen) {
+        s2 = ipaddr.createCIDR(sn2.address(), plen);
+    } else {
+        s2 = sn2;
+    }
+    var range1_max = s1.last();
+    var range2_min = s2.first();
+
+    return (ipaddr.compare(range1_max, range2_min) > 0);
+}
+
+var IP_10_0_0_0 = ipaddr.parse('10.0.0.0');
+var IP_172_16_0_0 = ipaddr.parse('172.16.0.0');
+var IP_192_168_0_0 = ipaddr.parse('192.168.0.0');
+
+var IP_10_255_255_255 = ipaddr.parse('10.255.255.255');
+var IP_172_31_255_255 = ipaddr.parse('172.31.255.255');
+
+function previousAddr(addr) {
+    if (addr.compare(IP_10_0_0_0) === 0) {
+        throw new Error('address should always be decrementable');
+    } else if (addr.compare(IP_172_16_0_0) === 0) {
+        return IP_10_255_255_255;
+    } else if (addr.compare(IP_192_168_0_0) === 0) {
+        return IP_172_31_255_255;
+    } else {
+        return addr.offset(-1);
+    }
+}
+
+function subnetsAdjacent(sn1, sn2) {
+    var prev = previousAddr(sn2.address());
+    return sn1.contains(prev);
+}
+
+/*
+ * We percieve a gap between two subnets is they don't overlap and are not
+ * adjacent.
+ */
+function haveGapBetweenSubnets(s1, s2, plen) {
+    // XXX TODO even if we have a gap we might not be able to allocate from it
+    // because the prefix-length might not allow it.
+    // i.e.
+    //      There is a gap between 10.0.10.0/24 and 10.2.1.0/24
+    //      But if we need /12, we can get a non-verlapping 10.X,
+    //      from that gap.
+    //      IOW: There is a gap between 10.0/24 and 10.2/24, but between
+    //      10.0/12 and 10.2/12 i.e.:  10.[000000|00] and 10.[000000|10]
+    return (!subnetsOverlap(s1, s2, plen) && !subnetsAdjacent(s1, s2));
+}
+
+/*
+ * We decrement a subnet's prefix by one, starting from leftmost possible byte.
+ * Return NULL if we can't.
+ */
+function decSubImpl(addr, plen) {
+    var new_addr = addr.first().offset(-1);
+    var new_addr2 = addr.first().offset(-2);
+    if (new_addr2.toString() === '9.255.255.255') {
+        return null;
+    } else if (new_addr2.toString() === '172.15.255.255') {
+        new_addr = ipaddr.parse('10.255.255.0');
+    } else if (new_addr2.toString() === '192.167.255.255') {
+        new_addr = ipaddr.parse('172.31.0.0');
+    }
+    if (addr.contains(new_addr)) {
+        new_addr = new_addr2;
+    }
+
+    return ipaddr.createCIDR(new_addr, plen);
+}
+
+/*
+ * We increment a subnet's prefix by one, starting from left-most possible byte.
+ * Return NULL if we can't.
+ * XXX, currently we can's increment any component that's not a full-sized byte.
+ * For example, if we have 10.224.0.0/12, we can't increment the first 4 bits of
+ * 224 to be 240. However, we should eventually gain this capability in the
+ * future. Bitwise operation in JS are error prone.
+ */
+function incSubImpl(addr, plen) {
+    var new_addr = addr.last().offset(1);
+    var new_addr2 = addr.last().offset(2);
+    if (new_addr2.toString() === '11.0.0.0') {
+        new_addr = ipaddr.parse('172.16.0.0');
+    } else if (new_addr2.toString() === '172.32.0.0') {
+        new_addr = ipaddr.parse('192.168.0.0');
+    } else if (new_addr2.toString() === '192.169.0.0') {
+        return null;
+    }
+    if (addr.contains(new_addr)) {
+        new_addr = new_addr2;
+    }
+
+    return ipaddr.createCIDR(new_addr, plen);
+}
+
+/*
+ * Increment a subnet's prefix, but restrict the prefix length of the resulting
+ * subnet to 'desired_plen'-bits.
+ *
+ *  10.88.0.0/16 ===> 10.89.0.0/'desired_plen'
+ */
+function incrementSubnet(subnet, desired_plen) {
+    var cidr = subnet;
+    var plen = cidr.prefixLength();
+    var nlen = desired_plen;
+    assert.ok(typeof (nlen) !== 'undefined');
+    assert.ok(nlen !== null);
+    var naddr = incSubImpl(cidr, Math.min(plen, nlen));
+    return naddr ? naddr.toString() : null;
+}
+
+/*
+ * Same as above but decrements.
+ */
+function decrementSubnet(subnet, desired_plen) {
+    var cidr = subnet;
+    var plen = cidr.prefixLength();
+    var nlen = desired_plen;
+    assert.ok(typeof (nlen) !== 'undefined');
+    assert.ok(nlen !== null);
+    var naddr = decSubImpl(cidr, Math.min(plen, nlen));
+    return naddr ? naddr.toString() : null;
+}
+
+module.exports = {
+    allocProvisionRange: allocProvisionRange,
+    decrementSubnet: decrementSubnet,
+    incrementSubnet: incrementSubnet,
+    haveGapBetweenSubnets: haveGapBetweenSubnets
+};
diff --git a/lib/util/constants.js b/lib/util/constants.js
index 537439e..4053d64 100644
--- a/lib/util/constants.js
+++ b/lib/util/constants.js
@@ -178,6 +178,7 @@ module.exports = {
         'provision_start_ip must be before provision_end_ip',
     SERVER_UNDERLAY_MSG: 'Only server NICs can be underlay NICs',
     SUBNET_FULL_MSG: 'no more free IPs',
+    SUBNETS_EXHAUSTED_MSG: 'out of subnets',
     SUBNET_GATEWAY_MISMATCH: 'gateway should match subnet type (%s)',
     SUBNET_RESOLVER_MISMATCH: 'resolvers should match subnet type (%s)',
     SUBNET_ROUTE_DST_MISMATCH:
diff --git a/lib/util/errors.js b/lib/util/errors.js
index 0fa6fd0..13d1b25 100644
--- a/lib/util/errors.js
+++ b/lib/util/errors.js
@@ -135,6 +135,23 @@ function SubnetFullError(network_uuid) {
 
 util.inherits(SubnetFullError, restify.RestError);
 
+function SubnetsExhaustedError() {
+
+    restify.RestError.call(this, {
+        restCode: 'SubnetsExhausted',
+        statusCode: 507,
+        message: constants.SUBNETS_EXHAUSTED_MSG,
+        body: {
+            code: 'SubnetsExhausted',
+            message: constants.SUBNETS_EXHAUSTED_MSG
+        }
+    });
+
+    this.name = 'SubnetsExhausted';
+    this.stop = true;
+}
+
+util.inherits(SubnetsExhaustedError, restify.RestError);
 
 /**
  * Base error class for when all networks in a pool are full.
@@ -321,6 +338,7 @@ module.exports = {
     nictagMtuInvalidForNetworks: nictagMtuInvalidForNetworks,
     PoolFullError: PoolFullError,
     SubnetFullError: SubnetFullError,
+    SubnetsExhaustedError: SubnetsExhaustedError,
     unknownParams: unknownParams,
     usedBy: usedBy,
     usedByParam: usedByParam
diff --git a/lib/util/validate.js b/lib/util/validate.js
index 1d00a3e..3f9916c 100644
--- a/lib/util/validate.js
+++ b/lib/util/validate.js
@@ -53,6 +53,35 @@ function validateBoolean(_, name, val, callback) {
     return callback(new errors.invalidParam(name, 'must be a boolean value'));
 }
 
+/**
+ * Currently validates that family is 'ipv4', but will validate 'ipv6' when
+ * Triton grows support for that.
+ */
+function validateAddrFamily(_, name, val, callback) {
+    if (val === 'ipv4') {
+        callback(null, val);
+        return;
+    }
+
+    callback(new errors.invalidParam(name, 'must be ipv4 not ' + val));
+}
+
+/**
+ * Currently validates that prefix is 24, but will validate (8,32) when SDC
+ * grows support for that.
+ */
+function validateSubnetPrefix(_, name, val, callback) {
+    if (typeof (val) === 'string') {
+        val = parseInt(val, 10);
+    }
+
+    if (val !== 24) {
+        callback(new errors.invalidParam(name, 'Only /24 is supported'));
+        return;
+    }
+
+    callback(null, val);
+}
 
 /**
  * Validates that a value is one of the values present in an array that
@@ -341,6 +370,8 @@ function validateVxlanID(_, name, vlan_id, callback) {
 
 module.exports = {
     bool: validateBoolean,
+    addrFamily: validateAddrFamily,
+    subnetPrefix: validateSubnetPrefix,
     enum: validateEnum,
     fieldsArray: warden.fieldsArray,
     IP: validateIP,
diff --git a/test/integration/fabrics.test.js b/test/integration/fabrics.test.js
index cc2f31f..98d2d50 100644
--- a/test/integration/fabrics.test.js
+++ b/test/integration/fabrics.test.js
@@ -41,6 +41,7 @@ var extend = mod_jsprim.mergeObjects;
 var ADMIN_OWNER = config.server.ufdsAdminUuid;
 var CREATED = {};
 var OWNERS = [
+    mod_uuid.v4(),
     mod_uuid.v4(),
     mod_uuid.v4(),
     mod_uuid.v4()
@@ -74,8 +75,15 @@ var VLANS = [
         name: mod_vlan.randomName(),
         owner_uuid: OWNERS[2],
         vlan_id: 44
+    },
+
+    {
+        name: mod_vlan.randomName(),
+        owner_uuid: OWNERS[3],
+        vlan_id: 45
     }
 ];
+
 // Real (non-fabric networks):
 var REAL_NETS = [
     h.validNetworkParams({ nic_tag: UNDERLAY_NIC_TAG }),
@@ -159,9 +167,22 @@ var NETS = [
         owner_uuid: VLANS[3].owner_uuid,
         provision_start_ip: '172.16.1.1',
         provision_end_ip: '172.16.3.254'
+    },
+
+    // 5: Used for testing subnet alloc
+    {
+        vlan_id: VLANS[4].vlan_id,
+        subnet_alloc: true,
+        subnet_prefix: 24,
+        family: 'ipv4',
+        // Also double-check that the MTU is correct:
+        mtu: OVERLAY_MTU,
+        name: mod_fabric_net.generateName(),
+        owner_uuid: VLANS[4].owner_uuid
     }
 
 ];
+
 var VMS = [
     mod_uuid.v4(),
     mod_uuid.v4(),
@@ -321,6 +342,20 @@ test('create VLANs', function (t) {
         });
     });
 
+    t.test('create vlan: 4', function (t2) {
+        mod_vlan.createAndGet(t2, {
+            params: extend(VLANS[4], {
+                // Specify at least owner_uuid and vlan_id - these are required
+                // by mod_vlan.delAllCreated() in the test teardown.
+                fields: [ 'name', 'owner_uuid', 'vlan_id' ]
+            }),
+            exp: {
+                name: VLANS[4].name,
+                owner_uuid: VLANS[4].owner_uuid,
+                vlan_id: VLANS[4].vlan_id
+            }
+        });
+    });
 });
 
 
@@ -547,6 +582,25 @@ test('create network', function (t) {
         });
     });
 
+    t.test('create network: 5', function (t2) {
+        mod_fabric_net.createAndGet(t2, {
+            params: extend(NETS[5], {
+                // mod_fabric_net.delAllCreated() needs uuid, owner_uuid and
+                // vlan_id in order to delete the network:
+                fields: [ 'name', 'owner_uuid', 'subnet', 'uuid', 'vlan_id' ]
+            }),
+            partialExp: {
+                name: NETS[5].name,
+                owner_uuid: NETS[5].owner_uuid,
+                // uuid gets filled in by createAndGet()
+                vlan_id: NETS[5].vlan_id
+            }
+        }, function (_err, res) {
+            t.ok(typeof (res.subnet) !== 'undefined', 'Subnet present');
+            t.end();
+        });
+    });
+
 });
 
 
diff --git a/test/unit/networks-subnet-alloc.test.js b/test/unit/networks-subnet-alloc.test.js
new file mode 100644
index 0000000..a990aa5
--- /dev/null
+++ b/test/unit/networks-subnet-alloc.test.js
@@ -0,0 +1,314 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright 2017, Joyent, Inc.
+ */
+
+/*
+ * Unit tests for listing networks.
+ */
+
+'use strict';
+
+var h = require('./helpers');
+var mod_err = require('../../lib/util/errors');
+var mod_alloc = require('../../lib/util/autoalloc');
+var mod_vlan = require('../lib/vlan');
+var mod_fabric_net = require('../lib/fabric-net');
+var mod_server = require('../lib/server');
+var test = require('tape');
+var ipaddr = require('ip6addr');
+var mod_uuid = require('node-uuid');
+
+function c(s) {
+    return (ipaddr.createCIDR(s));
+}
+
+// --- Globals
+
+var NETS = [];
+var TAG;
+var VLAN = {
+    name: mod_vlan.randomName(),
+    owner_uuid: mod_uuid.v4(),
+    vlan_id: 20
+};
+var NAPI;
+
+
+// --- Setup
+
+test('Initial setup', function (t) {
+    h.reset();
+
+    t.test('Start server', function (t2) {
+        h.createClientAndServer(function (err, res) {
+            t2.ifError(err, 'server creation');
+            t2.ok(res, 'client');
+            NAPI = res;
+            if (!NAPI) {
+                t2.end();
+                return;
+            }
+            NAPI.createNicTag('sdc_overlay', function (err2, res2) {
+                TAG = res2;
+                t2.ifError(err2, 'nic tag');
+                t2.ok(TAG, 'created NIC tag');
+                t2.end();
+            });
+        });
+    });
+
+    t.test('Create VLAN', function (t2) {
+        mod_vlan.createAndGet(t2, {
+            params: VLAN,
+            exp: VLAN
+        }, function (err, res) {
+            t2.ifError(err, 'vlan get');
+            t2.ok(res, 'vlan');
+            t2.end();
+            t.end();
+        });
+    });
+
+
+});
+
+// Tests
+
+// We want to test the auto-allocation code, especially edge-cases in the
+// allocator --- i.e. out-of-subnets, no gap between 2 subnets, and so forth.
+// Since we control all the data that goes into postgres from these unit tests,
+// we can also verify that the expected subnet was allocated.
+
+
+// We also want to test the behaviour related to different prefix-lengths.
+
+// Want to test these code-paths:
+// auto-alloc when we have 0 subnets, should be 10.0.0.0/24
+// auto-alloc when we have >1 subnet, but no gaps
+//      So, auto-alloc again, and we have: 10.1.0.0/24 (no gap)
+//      Another auto-alloc should give us 10.2.0.0/24
+// auto-alloc when we have >1 subnets and 1 gap
+//      So, man-alloc 10.4.0.0/24
+//      Another auto-alloc should give us 10.3.0.0/24
+// Keep allocating subnets until we run out.
+// Unit test the increment and decrement functionality (isolated from PG)
+//      Ok we want to test each of the jumps between 10, 172, 192
+
+test('Create networks', function (t) {
+    t.test('Create w/ auto1', function (t2) {
+        mod_fabric_net.create(t2, {
+            fillInMissing: true,
+            params: {
+                subnet_alloc: true,
+                owner_uuid: VLAN.owner_uuid,
+                family: 'ipv4',
+                subnet_prefix: 24,
+                name: mod_fabric_net.generateName(),
+                vlan_id: VLAN.vlan_id
+            },
+            partialExp: {
+                vlan_id: VLAN.vlan_id,
+                family: 'ipv4'
+            }
+        }, function (_, res) {
+            t2.equal(res.subnet, '10.0.0.0/24');
+            NETS.push(res);
+            t2.end();
+        });
+    });
+    t.test('Create w/ auto2', function (t2) {
+        mod_fabric_net.create(t2, {
+            fillInMissing: true,
+            params: {
+                subnet_alloc: true,
+                family: 'ipv4',
+                owner_uuid: VLAN.owner_uuid,
+                subnet_prefix: 24,
+                name: mod_fabric_net.generateName(),
+                vlan_id: VLAN.vlan_id
+            },
+            partialExp: {
+                vlan_id: VLAN.vlan_id,
+                family: 'ipv4'
+            }
+        }, function (_, res) {
+            t2.equal(res.subnet, '10.0.1.0/24');
+            NETS.push(res);
+            t2.end();
+        });
+    });
+    t.test('Create w/ manual', function (t2) {
+        mod_fabric_net.create(t2, {
+            fillInMissing: true,
+            params: {
+                subnet: '10.0.3.0/24',
+                provision_start_ip: '10.0.3.1',
+                provision_end_ip: '10.0.3.254',
+                name: mod_fabric_net.generateName(),
+                owner_uuid: VLAN.owner_uuid,
+                vlan_id: VLAN.vlan_id
+            },
+            partialExp: {
+                vlan_id: VLAN.vlan_id,
+                family: 'ipv4'
+            }
+        }, function (_, res) {
+            t2.equal(res.subnet, '10.0.3.0/24');
+            NETS.push(res);
+            t2.end();
+        });
+    });
+    t.test('Create w/ auto3', function (t2) {
+        mod_fabric_net.create(t2, {
+            fillInMissing: true,
+            params: {
+                subnet_alloc: true,
+                family: 'ipv4',
+                owner_uuid: VLAN.owner_uuid,
+                subnet_prefix: 24,
+                name: mod_fabric_net.generateName(),
+                vlan_id: VLAN.vlan_id
+            },
+            partialExp: {
+                vlan_id: VLAN.vlan_id,
+                family: 'ipv4'
+            }
+        }, function (_, res) {
+            t2.equal(res.subnet, '10.0.2.0/24');
+            NETS.push(res);
+            t2.end();
+        });
+    });
+
+    t.test('Delete Networks', function (t2) {
+        mod_fabric_net.delAllCreated(t2);
+    });
+
+
+    // We create 3 subnets, that consume all available addresses:
+    // 10.0.0.0/8, 172.16.0.0/16, 192.168.0.0/24
+    // When we try to auto-alloc we should get an exhausted-subnets error
+    t.test('Exhaustion Test', function (t2) {
+        t2.test('Create sub 1/3', function (t3) {
+            mod_fabric_net.create(t3, {
+                fillInMissing: true,
+                params: {
+                    subnet: '10.0.0.0/8',
+                    provision_start_ip: '10.0.0.1',
+                    provision_end_ip: '10.255.255.254',
+                    owner_uuid: VLAN.owner_uuid,
+                    name: mod_fabric_net.generateName(),
+                    vlan_id: VLAN.vlan_id
+                },
+                partialExp: {
+                    vlan_id: VLAN.vlan_id,
+                    family: 'ipv4'
+                }
+            }, function (_, res) {
+                NETS.push(res);
+                t3.end();
+            });
+        });
+        t2.test('Create sub 2/3', function (t3) {
+            mod_fabric_net.create(t3, {
+                fillInMissing: true,
+                params: {
+                    subnet: '172.16.0.0/12',
+                    provision_start_ip: '172.16.0.1',
+                    provision_end_ip: '172.31.255.254',
+                    owner_uuid: VLAN.owner_uuid,
+                    name: mod_fabric_net.generateName(),
+                    vlan_id: VLAN.vlan_id
+                },
+                partialExp: {
+                    vlan_id: VLAN.vlan_id,
+                    family: 'ipv4'
+                }
+            }, function (_, res) {
+                NETS.push(res);
+                t3.end();
+            });
+        });
+        t2.test('Create sub 3/3', function (t3) {
+            mod_fabric_net.create(t3, {
+                fillInMissing: true,
+                params: {
+                    subnet: '192.168.0.0/16',
+                    provision_start_ip: '192.168.0.1',
+                    provision_end_ip: '192.168.255.254',
+                    owner_uuid: VLAN.owner_uuid,
+                    name: mod_fabric_net.generateName(),
+                    vlan_id: VLAN.vlan_id
+                },
+                partialExp: {
+                    vlan_id: VLAN.vlan_id,
+                    family: 'ipv4'
+                }
+            }, function (_, res) {
+                NETS.push(res);
+                t3.end();
+            });
+        });
+        var err = new mod_err.SubnetsExhaustedError();
+        var errBody = err.body;
+        t2.test('Attempt Auto Alloc', function (t3) {
+            mod_fabric_net.create(t3, {
+                fillInMissing: true,
+                params: {
+                    subnet_alloc: true,
+                    family: 'ipv4',
+                    owner_uuid: VLAN.owner_uuid,
+                    subnet_prefix: 24,
+                    name: mod_fabric_net.generateName(),
+                    vlan_id: VLAN.vlan_id
+                },
+                expCode: 507,
+                expErr: errBody
+            }, function () {
+                t3.end();
+            });
+        });
+    });
+
+    t.end();
+});
+
+
+// --- Unit test functions in lib/util/autoalloc.js
+
+test('Alloc Utility Functions', function (t) {
+    t.test('incrementSubnets', function (t2) {
+        t2.equal(null, mod_alloc.incrementSubnet(c('192.168.255.255/24'), 24));
+        t2.equal('10.0.1.0/24',
+                mod_alloc.incrementSubnet(c('10.0.0.0/24'), 24));
+        t2.equal('172.16.0.0/24',
+                mod_alloc.incrementSubnet(c('10.255.255.0/24'), 24));
+        t2.equal('192.168.0.0/24',
+                mod_alloc.incrementSubnet(c('172.31.255.0/24'), 24));
+        t2.end();
+    });
+    t.test('decrementSubnets', function (t2) {
+        t2.equal(null, mod_alloc.decrementSubnet(c('10.0.0.0/24'), 24));
+        t2.equal('10.0.0.0/24',
+                mod_alloc.decrementSubnet(c('10.0.1.0/24'), 24));
+        t2.equal('10.255.255.0/24',
+                mod_alloc.decrementSubnet(c('172.16.0.0/24'), 24));
+        t2.equal('172.31.0.0/24',
+                mod_alloc.decrementSubnet(c('192.168.0.0/24'), 24));
+        t2.end();
+    });
+});
+
+
+
+// --- Teardown
+
+test('delete networks', mod_fabric_net.delAllCreated);
+
+test('Stop server', mod_server.close);
diff --git a/test/unit/networks.test.js b/test/unit/networks.test.js
index 3869a5f..f829c50 100644
--- a/test/unit/networks.test.js
+++ b/test/unit/networks.test.js
@@ -153,8 +153,7 @@ test('Create network - missing parameters', function (t) {
 
         t.equal(err.statusCode, 422, 'status code');
         t.deepEqual(err.body, h.invalidParamErr({
-            errors: ['name', 'nic_tag', 'provision_end_ip',
-                'provision_start_ip', 'subnet', 'vlan_id'].map(function (name) {
+            errors: ['name', 'nic_tag', 'vlan_id'].map(function (name) {
                     return {
                         code: 'MissingParameter',
                         field: name,
@@ -178,8 +177,7 @@ test('Create network - missing and invalid parameters', function (t) {
 
         t.equal(err.statusCode, 422, 'status code');
         t.deepEqual(err.body, h.invalidParamErr({
-            errors: ['name', 'nic_tag', 'provision_end_ip',
-                'subnet', 'vlan_id'].map(function (name) {
+            errors: ['name', 'nic_tag', 'vlan_id'].map(function (name) {
                     return {
                         code: 'MissingParameter',
                         field: name,
-- 
2.21.0

