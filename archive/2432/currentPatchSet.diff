From 3f4231c94997db9472fb1b76cb0f01d1e9b581c5 Mon Sep 17 00:00:00 2001
From: Jan Wyszynski <jan.wyszynski@joyent.com>
Date: Thu, 17 Aug 2017 21:27:53 +0000
Subject: [PATCH] MANTA-3220 MPU shark selection should try to connect to
 several sets of sharks

---
 lib/uploads/create.js | 139 ++++++++++++++++++++++++++++++++++++++++--
 package.json          |   4 +-
 2 files changed, 136 insertions(+), 7 deletions(-)

diff --git a/lib/uploads/create.js b/lib/uploads/create.js
index e2be04f..05e9987 100644
--- a/lib/uploads/create.js
+++ b/lib/uploads/create.js
@@ -16,6 +16,7 @@ var path = require('path');
 var restify = require('restify');
 var util = require('util');
 var verror = require('verror');
+var vasync = require('vasync');
 
 var auth = require('../auth');
 var common = require('../common');
@@ -32,6 +33,107 @@ var sprintf = util.format;
 
 ///--- Helpers
 
+
+/*
+ * Attempts to grab a running pool for a given shark from cueball
+ * to ensure that muskie had a recent active connection to the
+ * shark. If it didn't, one will be created with the cueball
+ * createPool api method. This function is used in chooseSharks to
+ * pick an appropriate shark for a new mpu-create operation.
+ */
+function ensureSharkHasPool(req, shark, callback) {
+    var host = shark.manta_storage_id;
+
+    var sharkInfo = {
+        shark: host,            // hostname of the shark
+        result: null,           // 'ok' or 'fail'
+        timeTotal: null,        // time spent deciding whether to use a shark
+        _startTime: Date.now(), // decision start time
+        error: null             // error encounter if connection failed
+    };
+
+    var pool = req.sharkAgent.getPool(host);
+    if (pool) {
+        req.log.debug({
+            shark: shark,
+            pool: pool.getState()
+        }, 'ensureSharkHasPool: got existing pool');
+    } else {
+        req.sharkAgent.createPool(host);
+        pool = req.sharkAgent.getPool(host);
+        req.log.debug({
+            shark: shark,
+            pool: pool.getState()
+        }, 'ensureSharkHasPool: created pool for shark');
+    }
+
+    req.sharksContacted.push(sharkInfo);
+
+    if (pool.isInState('running')) {
+        sharkInfo.result = 'ok';
+        sharkInfo.timeTotal = Date.now() - sharkInfo._startTime;
+        setImmediate(callback, null, shark);
+    } else if (pool.isInState('starting') || pool.isInState('failed')) {
+        var timedOut = false;
+        var sharkTimeout = setTimeout(function () {
+            timedOut = true;
+            req.log.debug({
+                shark: shark,
+                state: pool.getState()
+            }, 'ensureSharkHasPool: pool state change timeout');
+            sharkInfo.result = 'fail';
+            sharkInfo.timeTotal = Date.now() - sharkInfo._startTime;
+            sharkInfo.error = new Error('timed out waiting for shark pool ' +
+                'state change.');
+            callback();
+        }, req.sharkConfig.connectTimeout);
+
+        function onStateChanged(st) {
+            if (timedOut) {
+                return;
+            }
+            req.log.debug({
+                shark: shark,
+                state: st
+            }, 'ensureSharkHasPool: pool state changed');
+            if (st === 'running') {
+                clearTimeout(sharkTimeout);
+                sharkInfo.result = 'ok';
+                sharkInfo.timeTotal = Date.now() - sharkInfo._startTime;
+                callback(null, shark);
+            } else if (st === 'starting' || st === 'failed') {
+                // According to the cueball api docs, it is possible for a pool
+                // in the 'failed' state to recover a connection one of it's
+                // backends and transition back into the 'running' state.
+                pool.once('stateChanged', onStateChanged);
+            } else {
+                assert.ok(st === 'stopped' || st === 'stopping');
+                req.log.debug({
+                    state: st
+                }, 'ensureSharkHasPool: pool in inactive state');
+                clearTimeout(sharkTimeout);
+                sharkInfo.result = 'fail';
+                sharkInfo.timeTotal = Date.now() - sharkInfo._startTime;
+                sharkInfo.error = new verror.VError('pool changed to an ' +
+                        'inactive state %s', st);
+                callback();
+            }
+        }
+        pool.once('stateChanged', onStateChanged);
+
+    } else {
+        // With this assertion, we guard against the case where the pool
+        // is in a state that is not documented in the cueball api docs.
+        assert.ok(pool.isInState('stopped') || pool.isInState('stopping'));
+        sharkInfo.result = 'fail';
+        sharkInfo.timeTotal = Date.now() - sharkInfo._startTime;
+        sharkInfo.error = new verror.VError('found shark pool in ' +
+            'terminal state: %s', pool.getState());
+        callback();
+    }
+}
+
+
 /*
  * Selects the sharks for the upload through the picker.choose interface.
  *
@@ -39,7 +141,7 @@ var sprintf = util.format;
  * the durability-level and the content-length headers, respectively, or
  * set to a default value.
  */
-function chooseSharks(req, size, copies, cb) {
+function chooseSharks(req, res, size, copies, cb) {
     assert.object(req, 'req');
     assert.number(size, 'size');
     assert.number(copies, 'copies');
@@ -55,14 +157,41 @@ function chooseSharks(req, size, copies, cb) {
             replicas: copies,
             size: size
         };
+
         req.picker.choose(opts, function (err, sharks) {
             if (err) {
                 cb(err);
             } else {
+                var funcs = [];
+
+                req._sharks = sharks;
                 log.debug({
-                    sharks: sharks[0]
-                }, 'upload: sharks chosen');
-                cb(null, sharks[0]);
+                    sharks: req._sharks
+                }, 'chooseSharks: entered');
+                req.sharksContacted = [];
+
+                function trySharks(sharkSet, callback) {
+                    vasync.forEachParallel({
+                        func: ensureSharkHasPool.bind(null, req),
+                        inputs: sharkSet
+                    }, callback);
+                }
+
+                sharks.forEach(function (sharkSet) {
+                    funcs.push(trySharks.bind(null, sharkSet));
+                });
+                vasync.tryEach(funcs, function (err2, results) {
+                    req.sharks = results.successes || [];
+                    if (req.sharks.length === 0) {
+                        cb(new SharksExhaustedError(res), null);
+                        return;
+                    }
+                    log.debug({
+                        attempted: req.sharksContacted,
+                        chosen: req.sharks
+                    }, 'chooseSharks: done');
+                    cb(null, req.sharks);
+                });
             }
         });
     }
@@ -287,7 +416,7 @@ function createUpload(req, res, next) {
     var s = req.upload.mpuSize;
     var c = req.upload.mpuCopies;
 
-    chooseSharks(req, s, c, function (err, sharks) {
+    chooseSharks(req, res, s, c, function (err, sharks) {
         if (err) {
             next(err);
         } else {
diff --git a/package.json b/package.json
index ea869c3..150aaa1 100644
--- a/package.json
+++ b/package.json
@@ -15,7 +15,7 @@
         "backoff": "2.3.0",
         "bunyan": "0.22.1",
         "bunyan-syslog": "0.2.2",
-        "cueball": "2.2.9",
+        "cueball": "2.3.0",
         "dashdash": "1.3.2",
         "deep-equal": "0.0.0",
         "dtrace-provider": "0.2.8",
@@ -34,7 +34,7 @@
         "moray": "3.1.1",
         "once": "1.3.0",
         "restify": "2.6.3",
-        "vasync": "^1.5.0",
+        "vasync": "2.0.0",
         "verror": "^1.9.0",
         "watershed": "0.3.0",
         "xtend": "2.1.1"
-- 
2.21.0

