commit b6da5ceaa60ca76e501a7e9188c50bfaca3751a2 (refs/changes/32/4232/2)
Author: Jason King <jason.king@joyent.com>
Date:   2018-06-15T12:48:48-05:00 (1 year, 4 months ago)
    
    Route removal

diff --git a/usr/src/uts/common/io/overlay/overlay_target.c b/usr/src/uts/common/io/overlay/overlay_target.c
index 973aa77187..156271e553 100644
--- a/usr/src/uts/common/io/overlay/overlay_target.c
+++ b/usr/src/uts/common/io/overlay/overlay_target.c
@@ -203,7 +203,6 @@ overlay_ip_cmp(const void *a, const void *b)
 	return (0);
 }
 
-/* ARGSUSED */
 static void
 overlay_target_entry_dtor(void *arg)
 {
@@ -220,6 +219,32 @@ overlay_target_entry_dtor(void *arg)
 	kmem_cache_free(overlay_entry_cache, ote);
 }
 
+static void
+overlay_target_entry_l2sarc_dtor(void *arg)
+{
+	overlay_target_entry_t *ote = arg;
+	overlay_target_t *ott = ote->ote_ott;
+
+	ASSERT(MUTEX_HELD(&ott->ott_lock));
+	ASSERT3S((ote->ote_flags & OVERLAY_FLAG_F_VL3), ==, 0);
+
+	avl_remove(&ott->ott_u.ott_dyn.ott_tree, ote);
+	overlay_target_entry_dtor(ote);
+}
+
+static void
+overlay_target_entry_l3sarc_dtor(void *arg)
+{
+	overlay_target_entry_t *ote = arg;
+	overlay_target_t *ott = ote->ote_ott;
+
+	ASSERT(MUTEX_HELD(&ott->ott_lock));
+	ASSERT3S((ote->ote_flags & OVERLAY_FLAG_F_VL3), ==, OVERLAY_FLAG_F_VL3);
+
+	avl_remove(&ott->ott_u.ott_dyn.ott_l3tree, ote);
+	overlay_target_entry_dtor(ote);
+}
+
 static int
 overlay_mac_avl(const void *a, const void *b)
 {
@@ -309,40 +334,20 @@ overlay_target_free(overlay_dev_t *odd)
 		return;
 
 	if (odd->odd_target->ott_mode == OVERLAY_TARGET_DYNAMIC) {
-		sarc_t *cp = odd->odd_target->ott_u.ott_dyn.ott_dhash;
-		avl_tree_t *ap = &odd->odd_target->ott_u.ott_dyn.ott_tree;
-		sarc_t *cp3 = odd->odd_target->ott_u.ott_dyn.ott_l3dhash;
-		avl_tree_t *ap3 = &odd->odd_target->ott_u.ott_dyn.ott_l3tree;
-		overlay_target_entry_t *ote;
-
-		/*
-		 * Our VL3 AVL tree and hashtable contain the same elements,
-		 * therefore we should just remove it from the tree, but then
-		 * delete the entries when we remove them from the hash table
-		 * (which happens through the sarc dtor).
-		 */
-		while ((ote = avl_first(ap3)) != NULL)
-			avl_remove(ap3, ote);
-		avl_destroy(ap3);
-
-		while ((ote = sarc_first(cp3)) != NULL)
-			sarc_remove(cp3, ote);
-		sarc_destroy(cp3);
-
+		mutex_enter(&odd->odd_target);
 		/*
-		 * Our AVL tree and hashtable contain the same elements,
-		 * therefore we should just remove it from the tree, but then
-		 * delete the entries when we remove them from the hash table
-		 * (which happens through the sarc dtor).
+		 * Our VL3 AVL tree and hashtable contain the same elements.
+		 * Additionally, when an entry is removed from the sarc cache,
+		 * the entry is removed from the corresponding AVL tree.
+		 * Deleting the sarc cache will destroy any remaining entries,
+		 * so all we need to do is destroy the sarc caches.
 		 */
-		while ((ote = avl_first(ap)) != NULL)
-			avl_remove(ap, ote);
-
-		avl_destroy(ap);
-
-		while ((ote = sarc_first(cp)) != NULL)
-			sarc_remove(cp, ote);
-		sarc_destroy(cp);
+		sarc_destroy(odd->odd_target->ott_u.ott_dyn.ott_dhash);
+		sarc_destroy(odd->odd_target->ott_u.ott_dyn.ott_l3dhash);
+		ASSERT(avl_is_empty(&odd->odd_target->ott_u.ott_dyn.ott_tree));
+		ASSERT(avl_is_empty(
+		    &odd->odd_target->ott_u.ott_dyn.ott_l3tree));
+		mutex_exit(&odd->odd_target);
 	}
 
 	ASSERT(odd->odd_target->ott_ocount == 0);
@@ -921,7 +926,7 @@ overlay_target_info(overlay_target_hdl_t *thdl, void *arg)
 static sarc_ops_t overlay_sarc_l2_ops = {
 	.sao_hash = overlay_mac_hash,
 	.sao_cmp = overlay_mac_cmp,
-	.sao_dtor = overlay_target_entry_dtor,
+	.sao_dtor = overlay_target_entry_l2sarc_dtor,
 	.sao_fetch = sarc_nofetch,
 	.sao_evict = sarc_noevict
 };
@@ -929,7 +934,7 @@ static sarc_ops_t overlay_sarc_l2_ops = {
 static sarc_ops_t overlay_sarc_l3_ops = {
 	.sao_hash = overlay_ip_hash,
 	.sao_cmp = overlay_ip_cmp,
-	.sao_dtor = overlay_target_entry_dtor,
+	.sao_dtor = overlay_target_entry_l3sarc_dtor,
 	.sao_fetch = sarc_nofetch,
 	.sao_evict = sarc_noevict
 };
@@ -2104,6 +2109,98 @@ overlay_target_cache_iter_copyout(void *ubuf, void *buf, size_t bufsize,
 	return (0);
 }
 
+/* ARGSUSED */
+static int
+overlay_target_cache_remove_net(overlay_target_hdl_t *thdl, void *arg)
+{
+	overlay_targ_cache_net_t *otcn = arg;
+	overlay_targ_cache_net_entry_t *otcne = &otcn->otcn_entry;
+	overlay_dev_t *odd = NULL;
+	overlay_target_t *ott = NULL;
+	overlay_target_entry_t *ote = NULL, *ote_next = NULL;
+	avl_tree_t *avl = NULL;
+	avl_index_t where = { 0 };
+	overlay_target_vl3_t cmp = { 0 };
+
+	odd = overlay_hold_by_dlid(otcn->otcn_linkid);
+	if (odd == NULL)
+		return (ENOENT);
+
+	cmp.otvl3_src_vlan = otcne->otcne_vlan;
+	/*
+	 * XXX We assume we are passed the net address (i.e. host portion
+	 * derived from prefixlen is all 0s).  Should we go ahead and just
+	 * do that here as a precaution, return an error, create the net
+	 * address from the src/dst address + prefixlen?
+	 */
+	bcopy(&otcne->otcne_src, &cmp.otvl3_src, sizeof (cmp.otvl3_src));
+	bcopy(&otcne->otcne_dst, &cmp.otvl3_dst, sizeof (cmp.otvl3_dst));
+
+	mutex_enter(&odd->odd_lock);
+	if (!(odd->odd_flags & OVERLAY_F_VARPD)) {
+		mutex_exit(&odd->odd_lock);
+		overlay_hold_rele(odd);
+		return (ENXIO);
+	}
+	ott = odd->odd_target;
+	if (ott->ott_mode != OVERLAY_TARGET_DYNAMIC) {
+		mutex_exit(&odd->odd_lock);
+		overlay_hold_rele(odd);
+		return (ENOTSUP);
+	}
+	mutex_enter(&ott->ott_lock);
+	mutex_exit(&odd->odd_lock);
+	avl = &ott->ott_u.ott_dyn.ott_l3tree;
+
+	/*
+	 * For deleting all the entries between two networks, we first locate
+	 * the entry just before the given net addresses.  VL3 target entries
+	 * are sorted by <src ip, dst ip, src vlan>, so the subnet address
+	 * (i.e. 192.168.1.0) will always sort before any addresses within
+	 * the subnet.  Therefore, the entry just before where the subnet
+	 * addresses would go the entry that immediately preceeds any
+	 * potential matching entries (note that we should never actually
+	 * have the subnet addresses stored as target entries as that would
+	 * not make any sense).  We find the entry immediately before where
+	 * any potential entries are (or if NULL, that means any potential
+	 * matches would be the first entries when sorted), then start
+	 * iterating through the subsequent entries until we either exhaust
+	 * all our entries, or find an entry no longer in range.  The latter
+	 * indicating we've iterated all potential matches.
+	 */
+
+	/*
+	 * Find where the network address would be in the tree, but should
+	 * never actually see them in the tree.
+	 */
+	VERIFY3P(avl_find(avl, &cmp, &where), ==, NULL);
+
+	ote = avl_nearest(avl, where, AVL_BEFORE);
+	if (ote == NULL)
+		ote = avl_first(avl);
+	else
+		ote = AVL_NEXT(avl, ote);
+
+#define	IN_RANGE(_ote, _otcne)						\
+    (IN6_ARE_PREFIXEDADDR_EQUAL(&(_ote)->ote_u.ote_vl3.otvl3_src,	\
+    &(_otcne)->otcne_src, (_otcne)->otcne_src_prefixlen) &&		\
+    IN6_ARE_PREFIXEDADDR_EQUAL(&(_ote)->ote_u.ote_vl3.otvl3_dst,	\
+    &(_otcne)->otcne_dst, (_otcne)->otcne_dst_prefixlen) &&		\
+    (_ote)->ote_u.ote_vl3.otvl3_src_vlan == (_otcne)->otcne_vlan)
+
+	while (ote != NULL && IN_RANGE(ote, otcne)) {
+		ote_next = AVL_NEXT(avl, ote);
+		sarc_remove(ott->ott_u.ott_dyn.ott_l3dhash, ote);
+		ote = ote_next;
+	}
+
+#undef	IN_RANGE
+
+	mutex_exit(&ott->ott_lock);
+	overlay_hold_rele(odd);
+	return (0);
+}
+
 static overlay_target_ioctl_t overlay_target_ioctab[] = {
 	{ OVERLAY_TARG_INFO, B_TRUE, B_TRUE,
 		NULL, overlay_target_info,
@@ -2164,6 +2261,9 @@ static overlay_target_ioctl_t overlay_target_ioctab[] = {
 		overlay_target_cache_iter,
 		overlay_target_cache_iter_copyout,
 		sizeof (overlay_targ_cache_iter_t)		},
+	{ OVERLAY_TARG_CACHE_REMOVE_NET, B_TRUE, B_TRUE,
+		NULL, overlay_target_cache_remove_net,
+		NULL, sizeof (overlay_targ_cache_net_t)	},
 	{ 0 }
 };
 
diff --git a/usr/src/uts/common/io/overlay/sarc.c b/usr/src/uts/common/io/overlay/sarc.c
index 3c7b33ca8a..9320cae5c5 100644
--- a/usr/src/uts/common/io/overlay/sarc.c
+++ b/usr/src/uts/common/io/overlay/sarc.c
@@ -154,6 +154,7 @@ sarc_destroy(sarc_t *s)
 		for (;;) {
 			if ((lnk = list_remove_head(l)) == NULL)
 				break;
+			ASSERT0(lnk->sal_refcnt);
 			obj = link_to_obj(s, lnk);
 			s->sarc_ops.sao_dtor(obj);
 		}
