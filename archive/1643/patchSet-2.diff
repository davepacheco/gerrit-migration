commit 95a21bb91a8f0250df427fc8ab431fbf44e6c697 (refs/changes/43/1643/2)
Author: Trent Mick <trentm@gmail.com>
Date:   2017-05-17T15:32:16-07:00 (2 years, 5 months ago)
    
    NET-371 add support for multiple headnodes to hn-netfile
    Reviewed by: Cody Peter Mello <cody.mello@joyent.com>

diff --git a/bin/hn-netfile b/bin/hn-netfile
index a2118ef..9931490 100755
--- a/bin/hn-netfile
+++ b/bin/hn-netfile
@@ -1,4 +1,4 @@
-#!/opt/smartdc/booter/node/bin/node
+#!/opt/smartdc/booter/node/bin/node --abort-on-uncaught-exception
 
 /*
  * This Source Code Form is subject to the terms of the Mozilla Public
@@ -7,24 +7,57 @@
  */
 
 /*
- * Copyright (c) 2015, Joyent, Inc.
+ * Copyright (c) 2017, Joyent, Inc.
  */
 
 /*
- * Generate boot-time net config file for the headnode
+ * Generate boot-time net config (i.e. for /mnt/usbkey/boot/networking.json)
+ * for the given headnode.
  */
 
+var mod_assert = require('assert-plus');
 var mod_boot_files = require('../lib/boot-files');
 var mod_bunyan = require('bunyan');
+var mod_child_process = require('child_process');
 var mod_clients = require('../lib/clients');
+var mod_dashdash = require('dashdash');
 var mod_fs = require('fs');
 var mod_net_file = require('../lib/net-file');
+var mod_restify = require('restify');
+var mod_util = require('util');
 var mod_vasync = require('vasync');
 
 
+// ---- globals
+
+var NAME = 'hn-netfile';
+var OPTIONS = [
+    {
+        names: ['verbose', 'v'],
+        type: 'bool',
+        help: 'Verbose output.'
+    },
+    {
+        names: ['help', 'h'],
+        type: 'bool',
+        help: 'Print this help and exit.'
+    }
+];
+
+var log = mod_bunyan.createLogger({
+    name: NAME,
+    level: 'info',
+    serializers: mod_restify.bunyan.serializers,
+    streams: [ { stream: process.stderr } ]
+});
+
+var format = mod_util.format;
+var execFile = mod_child_process.execFile;
+
+
+// ---- support functions
 
 function loadConfig(opts, callback) {
-    opts.current = 'Loading config file';
     opts.config = JSON.parse(mod_fs.readFileSync(opts.configFile, 'utf-8'));
     // Ensure that the clients don't keep the connection open:
     opts.config.agent = false;
@@ -34,14 +67,8 @@ function loadConfig(opts, callback) {
 
 
 function createClients(opts, callback) {
-    opts.current = 'Creating clients';
-    opts.cnapi = mod_clients.createCNAPIclient(opts.config);
-    opts.log = mod_bunyan.createLogger({
-        name: 'hn-netfile',
-        level: 'info',
-        serializers: mod_bunyan.stdSerializers
-    });
-    opts.napi = mod_clients.createNAPIclient(opts.config);
+    opts.cnapi = mod_clients.createCNAPIclient(opts.config, opts.log);
+    opts.napi = mod_clients.createNAPIclient(opts.config, opts.log);
 
     var bootOpts = mod_boot_files.bootOpts(opts);
     for (var b in bootOpts) {
@@ -52,32 +79,84 @@ function createClients(opts, callback) {
 }
 
 
-function getHeadnodeUUID(opts, callback) {
-    opts.current = 'Getting headonde UUID from CNAPI';
-    opts.cnapi.listServers({ hostname: 'headnode' }, function (err, list) {
+/*
+ * If a headnode (hostname or UUID) was not given on the command line, then
+ * we want to get the current server UUID (via `mdata-get sdc:server_uuid`).
+ */
+function ensureHeadnodeHostnameOrUuid(opts, callback) {
+    if (opts.headnodeHostnameOrUuid) {
+        callback();
+        return;
+    }
+
+    execFile('/usr/sbin/mdata-get', ['sdc:server_uuid'],
+            function (err, stdout, stderr) {
         if (err) {
-            return callback(err);
+            callback(new Error(format(
+                'Error calling mdata-get: %s stdout=%j stderr=%j',
+                err, stdout, stderr)));
+            return;
         }
 
-        if (!list || list.length === 0) {
-            return callback(new Error(
-                'Could not find a server with hostname "headnode" in CNAPI'));
+        var serverUuid = stdout.trim();
+        if (!serverUuid) {
+            callback(new Error(
+                'mdata-get did not return a value for serverUuid'));
+            return;
         }
 
-        opts.cn_uuid = list[0].uuid;
+        log.debug({uuid: serverUuid}, 'Current server UUID from mdata-get');
+        opts.headnodeHostnameOrUuid = serverUuid;
+
+        callback();
+    });
+}
+
+function getHeadnodeInfo(opts, callback) {
+    mod_assert.string(opts.headnodeHostnameOrUuid,
+        'opts.headnodeHostnameOrUuid');
+
+    var i;
 
-        if (!opts.cn_uuid) {
-            return callback(new Error(
-                'Could not get headnode UUID from CNAPI'));
+    opts.cnapi.listServers({headnode: true}, function (err, headnodes) {
+        if (err) {
+            callback(err);
+            return;
         }
 
-        return callback();
+        // Try `uuid` match first ...
+        var headnode;
+        for (i = 0; i < headnodes.length; i++) {
+            if (headnodes[i].uuid === opts.headnodeHostnameOrUuid) {
+                headnode = headnodes[i];
+                break;
+            }
+        }
+
+        // ... then `hostname`.
+        if (!headnode) {
+            for (i = 0; i < headnodes.length; i++) {
+                if (headnodes[i].hostname === opts.headnodeHostnameOrUuid) {
+                    headnode = headnodes[i];
+                    break;
+                }
+            }
+        }
+
+        if (headnode) {
+            opts.cn_uuid = headnode.uuid;
+            opts.hostname = headnode.hostname;
+            callback();
+        } else {
+            callback(new Error('Could not find a headnode=true server "'
+                + opts.headnodeHostnameOrUuid + '" in CNAPI'));
+        }
     });
 }
 
 
 function getNics(opts, callback) {
-    opts.current = 'Getting nics';
+    log.debug({cn_uuid: opts.cn_uuid}, 'getNics');
     opts.napi.getNics(opts.cn_uuid, function (err, list) {
         if (err) {
             return callback(err);
@@ -100,16 +179,19 @@ function getNics(opts, callback) {
 
 
 function genNetFile(opts, callback) {
-    opts.current = 'Generating networking file';
     opts.netFile = mod_net_file.generate(opts);
     return callback();
 }
 
 
-function outputNetFile() {
+/*
+ * Generate and return networking.json file content for the given headnode.
+ */
+function getNetFile(headnodeHostnameOrUuid, callback) {
     var opts = {
+        log: log,
         configFile: __dirname + '/../config.json',
-        hostname: 'headnode'
+        headnodeHostnameOrUuid: headnodeHostnameOrUuid
     };
 
     mod_vasync.pipeline({
@@ -117,23 +199,72 @@ function outputNetFile() {
         funcs: [
             loadConfig,
             createClients,
-            getHeadnodeUUID,
+            ensureHeadnodeHostnameOrUuid,
+            getHeadnodeInfo,
             getNics,
             mod_clients.napiGetAggrs,
             mod_clients.napiGetNicTags,
             genNetFile
-    ] }, function (err, res) {
+    ] }, function (err) {
         if (err) {
-            return console.error(opts.current + ': ' + err.message);
+            callback(err);
+        } else {
+            callback(null, opts.netFile);
         }
+    });
+}
 
-        if (!opts.netFile) {
-            return console.error('No net file generated');
-        }
 
-        return console.log(JSON.stringify(opts.netFile, null, 2));
+// ---- mainline
+
+function main(argv) {
+    mod_assert.arrayOfString(argv, 'argv');
+
+    var parser = mod_dashdash.createParser({options: OPTIONS});
+    try {
+        var opts = parser.parse(argv);
+    } catch (argvErr) {
+        console.error('%s: error: %s', NAME, argvErr.message);
+        process.exit(1);
+    }
+
+    if (opts.verbose) {
+        log.level('trace');
+        log.src = true;
+    }
+
+    if (opts.help) {
+        console.log([
+            'Generate a headnode networking config file.',
+            '',
+            'Usage:',
+            '    %s [OPTIONS] [HEADNODE-HOSTNAME-OR-UUID]',
+            '',
+            'Options:',
+            parser.help().trimRight(),
+            '',
+            'If the HEADNODE-HOSTNAME-OR-UUIR argument is not given, it will',
+            'default to using the current server.'
+        ].join('\n'), argv[1]);
+        process.exit(0);
+    }
+
+    var headnodeHostnameOrUuid = opts._args[0];
+
+    getNetFile(headnodeHostnameOrUuid, function (err, netFile) {
+        if (err) {
+            console.error('%s: error: %s', NAME, err.stack);
+            process.exit(1);
+        } else if (!netFile) {
+            console.error('%s: error: no networking config file was generated',
+                NAME);
+            process.exit(1);
+        } else {
+            console.log(JSON.stringify(netFile, null, 2));
+        }
     });
 }
 
-
-outputNetFile();
+if (require.main === module) {
+    main(process.argv);
+}
diff --git a/package.json b/package.json
index e9fba61..049b420 100644
--- a/package.json
+++ b/package.json
@@ -1,12 +1,13 @@
 {
   "name": "booter",
   "description": "DHCP server for booting SDC compute nodes",
-  "version": "1.1.0",
+  "version": "1.3.0",
   "author": "Joyent (joyent.com)",
   "private": true,
   "dependencies": {
     "assert-plus": "0.1.2",
-    "bunyan": "1.2.3",
+    "bunyan": "1.8.8",
+    "dashdash": "1.14.1",
     "findit": "2.0.0",
     "mkdirp": "0.5.0",
     "node-uuid": "1.2.0",
diff --git a/tools/rsync-to b/tools/rsync-to
new file mode 100755
index 0000000..f28cfe0
--- /dev/null
+++ b/tools/rsync-to
@@ -0,0 +1,47 @@
+#!/bin/bash
+#
+# This Source Code Form is subject to the terms of the Mozilla Public
+# License, v. 2.0. If a copy of the MPL was not distributed with this
+# file, You can obtain one at http://mozilla.org/MPL/2.0/.
+#
+
+#
+# Copyright 2017 Joyent, Inc.
+#
+
+#
+# Rsync this working copy to the install on the given HN.
+#
+
+#set -o xtrace
+set -o errexit
+
+TOP=$(cd $(dirname $0)/../; pwd)
+NODE=$1
+
+if [[ -z "$ZONE" ]]; then
+    ZONE=$(ssh $NODE "vmadm lookup -1 alias=dhcpd0" 2>/dev/null)
+fi
+echo "ZONE: $ZONE"
+
+extraOpts=
+if [[ $(uname -s) != "SunOS" ]]; then
+    extraOpts="--exclude *.node --exclude build"
+fi
+
+rsync -av ${TOP}/ \
+    $NODE:/zones/$ZONE/root/opt/smartdc/booter/ \
+    $extraOpts \
+    --exclude .git/ \
+    --exclude /deps/ \
+    --exclude /boot/ \
+    --exclude /src/ \
+    --exclude /tmp/
+
+state=$(ssh ${NODE} svcs -z ${ZONE} -H -o state dhcpd)
+if [[ "$state" == "maintenance" ]]; then
+    ssh ${NODE} svcadm -z ${ZONE} clear dhcpd
+else
+    ssh ${NODE} svcadm -z ${ZONE} restart dhcpd
+fi
+ssh ${NODE} svcadm -z ${ZONE} restart config-agent
