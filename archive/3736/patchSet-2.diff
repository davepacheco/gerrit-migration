commit f3dd6bbdb5eb130fec3102d9cf8987028655de02 (refs/changes/36/3736/2)
Author: Patrick Mooney <pmooney@pfmooney.com>
Date:   2018-03-29T17:57:22+00:00 (1 year, 6 months ago)
    
    OS-6837 bhyve must use separate ipi vector for PIR

diff --git a/usr/src/cmd/mdb/i86pc/modules/apix/apix.c b/usr/src/cmd/mdb/i86pc/modules/apix/apix.c
index 62ede1fd26..ca168f2cdb 100644
--- a/usr/src/cmd/mdb/i86pc/modules/apix/apix.c
+++ b/usr/src/cmd/mdb/i86pc/modules/apix/apix.c
@@ -20,6 +20,7 @@
  */
 /*
  * Copyright (c) 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright 2018 Joyent, Inc.
  */
 
 #include "intr_common.h"
@@ -170,5 +171,9 @@ _mdb_init(void)
 		if (GELF_ST_TYPE(sym.st_info) == STT_FUNC)
 			gld_intr_addr = (uintptr_t)sym.st_value;
 
+	if (mdb_readvar(&apic_pir_vect, "apic_pir_vect") == -1) {
+		apic_pir_vect = -1;
+	}
+
 	return (&modinfo);
 }
diff --git a/usr/src/cmd/mdb/i86pc/modules/common/intr_common.c b/usr/src/cmd/mdb/i86pc/modules/common/intr_common.c
index 00f6afcbf8..86c24040fa 100644
--- a/usr/src/cmd/mdb/i86pc/modules/common/intr_common.c
+++ b/usr/src/cmd/mdb/i86pc/modules/common/intr_common.c
@@ -20,6 +20,7 @@
  */
 /*
  * Copyright (c) 2006, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright 2018 Joyent, Inc.
  */
 
 #include "intr_common.h"
@@ -29,6 +30,7 @@
 
 int		option_flags;
 uintptr_t	gld_intr_addr;
+int		apic_pir_vect;
 static struct av_head softvec_tbl[LOCK_LEVEL + 1];
 
 static char *businfo_array[] = {
@@ -302,11 +304,16 @@ apic_interrupt_dump(apic_irq_t *irqp, struct av_head *avp,
 
 	} else {
 		if (irqp->airq_mps_intr_index == RESERVE_INDEX &&
-		    !irqp->airq_share)
-			mdb_printf("poke_cpu");
-		else if (mdb_vread(&avhp, sizeof (struct autovec),
-		    (uintptr_t)avp->avh_link) != -1)
+		    !irqp->airq_share) {
+			if (irqp->airq_vector == apic_pir_vect) {
+				mdb_printf("pir_ipi");
+			} else {
+				mdb_printf("poke_cpu");
+			}
+		} else if (mdb_vread(&avhp, sizeof (struct autovec),
+		    (uintptr_t)avp->avh_link) != -1) {
 			mdb_printf("%a", avhp.av_vector);
+		}
 	}
 	mdb_printf("\n");
 }
@@ -446,10 +453,15 @@ apix_interrupt_ipi_dump(apix_vector_t *vectp, struct autovec *avp,
 		mdb_printf("%-9s %-3s %s%-3s %-6s %-3s %-6s %-3d   %-9s ",
 		    cpu_vector, "-  ", evtchn, ipl, "-   ", "Edg",
 		    intr_type, vectp->v_share, ioapic_iline);
-	if (!vectp->v_share)
-		mdb_printf("poke_cpu");
-	else
+	if (!vectp->v_share) {
+		if (vectp->v_vector == apic_pir_vect) {
+			mdb_printf("pir_ipi");
+		} else {
+			mdb_printf("poke_cpu");
+		}
+	} else {
 		mdb_printf("%a", avp->av_vector);
+	}
 
 	mdb_printf("\n");
 }
diff --git a/usr/src/cmd/mdb/i86pc/modules/common/intr_common.h b/usr/src/cmd/mdb/i86pc/modules/common/intr_common.h
index d2d92594ba..531cca5f2a 100644
--- a/usr/src/cmd/mdb/i86pc/modules/common/intr_common.h
+++ b/usr/src/cmd/mdb/i86pc/modules/common/intr_common.h
@@ -20,6 +20,7 @@
  */
 /*
  * Copyright (c) 2006, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright 2018 Joyent, Inc.
  */
 
 #ifndef _MDB_INTR_COMMON_H
@@ -73,6 +74,9 @@ extern int	option_flags;
  */
 extern uintptr_t	gld_intr_addr;
 
+/* cached the PIR ipi vector to differentiate it from poke_cpu */
+extern int	apic_pir_vect;
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/usr/src/cmd/mdb/i86pc/modules/pcplusmp/pcplusmp.c b/usr/src/cmd/mdb/i86pc/modules/pcplusmp/pcplusmp.c
index a682707337..bb24b0ae70 100644
--- a/usr/src/cmd/mdb/i86pc/modules/pcplusmp/pcplusmp.c
+++ b/usr/src/cmd/mdb/i86pc/modules/pcplusmp/pcplusmp.c
@@ -20,6 +20,7 @@
  */
 /*
  * Copyright (c) 2005, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright 2018 Joyent, Inc.
  */
 
 #include "intr_common.h"
@@ -116,5 +117,9 @@ _mdb_init(void)
 		if (GELF_ST_TYPE(sym.st_info) == STT_FUNC)
 			gld_intr_addr = (uintptr_t)sym.st_value;
 
+	if (mdb_readvar(&apic_pir_vect, "apic_pir_vect") == -1) {
+		apic_pir_vect = -1;
+	}
+
 	return (&modinfo);
 }
diff --git a/usr/src/compat/freebsd/amd64/machine/smp.h b/usr/src/compat/freebsd/amd64/machine/smp.h
index 4c4007bf9d..9c4f2d111b 100644
--- a/usr/src/compat/freebsd/amd64/machine/smp.h
+++ b/usr/src/compat/freebsd/amd64/machine/smp.h
@@ -11,6 +11,7 @@
 
 /*
  * Copyright 2013 Pluribus Networks Inc.
+ * Copyright 2018 Joyent, Inc.
  */
 
 #ifndef _COMPAT_FREEBSD_AMD64_MACHINE_SMP_H_
@@ -19,20 +20,11 @@
 #ifdef _KERNEL
 
 /*
- * APIC-related definitions would normally be stored in x86/include/apicvar.h,
- * accessed here via x86/include/x86_smp.h.  Until it becomes necessary to
- * implment that whole chain of includes, those definitions are short-circuited
- * into this file.
+ * APIC-related functions are replaced with native calls rather than shims
+ * which attempt to replicate the FreeBSD interfaces.  This is empty, but will
+ * remain present to appease sources which wish to include the path.
  */
 
-#define	IDTVEC(name)	idtvec_ ## name
-
-extern int idtvec_justreturn;
-
-extern int lapic_ipi_alloc(int *);
-extern void lapic_ipi_free(int vec);
-
-
 #endif /* _KERNEL */
 
 #endif	/* _COMPAT_FREEBSD_AMD64_MACHINE_SMP_H_ */
diff --git a/usr/src/uts/i86pc/io/apix/apix.c b/usr/src/uts/i86pc/io/apix/apix.c
index 34baee53e1..f61b54e2c8 100644
--- a/usr/src/uts/i86pc/io/apix/apix.c
+++ b/usr/src/uts/i86pc/io/apix/apix.c
@@ -166,7 +166,8 @@ static struct	psm_ops apix_ops = {
 	apic_state,		/* save, restore apic state for S3 */
 	apic_cpu_ops,		/* CPU control interface. */
 
-	apic_cached_ipivect,
+	apic_get_pir_ipivect,
+	apic_send_pir_ipi,
 };
 
 struct psm_ops *psmops = &apix_ops;
@@ -384,6 +385,8 @@ apix_init()
 		apic_have_32bit_cr8 = 1;
 #endif
 
+	apic_pir_vect = apix_get_ipivect(XC_CPUPOKE_PIL, -1);
+
 	/*
 	 * Initialize IRM pool parameters
 	 */
@@ -1127,9 +1130,11 @@ x2apic_update_psm()
 	 * being apix_foo as opposed to apic_foo and x2apic_foo.
 	 */
 	pops->psm_send_ipi = x2apic_send_ipi;
-
 	send_dirintf = pops->psm_send_ipi;
 
+	pops->psm_send_pir_ipi = x2apic_send_pir_ipi;
+	psm_send_pir_ipi = pops->psm_send_pir_ipi;
+
 	apic_mode = LOCAL_X2APIC;
 	apic_change_ops();
 }
@@ -2588,6 +2593,8 @@ apic_switch_ipi_callback(boolean_t enter)
 		if (apic_poweron_cnt == 0) {
 			pops->psm_send_ipi = apic_common_send_ipi;
 			send_dirintf = pops->psm_send_ipi;
+			pops->psm_send_pir_ipi = apic_common_send_pir_ipi;
+			psm_send_pir_ipi = pops->psm_send_pir_ipi;
 		}
 		apic_poweron_cnt++;
 	} else {
@@ -2596,6 +2603,8 @@ apic_switch_ipi_callback(boolean_t enter)
 		if (apic_poweron_cnt == 0) {
 			pops->psm_send_ipi = x2apic_send_ipi;
 			send_dirintf = pops->psm_send_ipi;
+			pops->psm_send_pir_ipi = x2apic_send_pir_ipi;
+			psm_send_pir_ipi = pops->psm_send_pir_ipi;
 		}
 	}
 	lock_clear(&apic_mode_switch_lock);
diff --git a/usr/src/uts/i86pc/io/apix/apix_regops.c b/usr/src/uts/i86pc/io/apix/apix_regops.c
index 1432b66a81..3c28e829ab 100644
--- a/usr/src/uts/i86pc/io/apix/apix_regops.c
+++ b/usr/src/uts/i86pc/io/apix/apix_regops.c
@@ -25,13 +25,14 @@
 /*
  * Copyright 2014 Josef 'Jeff' Sipek <jeffpc@josefsipek.net>
  * Copyright (c) 2014 by Delphix. All rights reserved.
- * Copyright 2017 Joyent, Inc.
+ * Copyright 2018 Joyent, Inc.
  */
 
 #include <sys/cpuvar.h>
 #include <sys/psm.h>
 #include <sys/archsystm.h>
 #include <sys/apic.h>
+#include <sys/apic_common.h>
 #include <sys/sunddi.h>
 #include <sys/ddi_impldefs.h>
 #include <sys/mach_intr.h>
@@ -218,6 +219,34 @@ x2apic_send_ipi(int cpun, int ipl)
 	intr_restore(flag);
 }
 
+void
+x2apic_send_pir_ipi(processorid_t cpun)
+{
+	const int vector = apic_pir_vect;
+	ulong_t flag;
+
+	ASSERT(apic_mode == LOCAL_X2APIC);
+	ASSERT((vector >= APIC_BASE_VECT) && (vector <= APIC_SPUR_INTR));
+
+	/* Serialize as described in x2apic_send_ipi() above. */
+	atomic_or_ulong(&flag, 1);
+
+	flag = intr_clear();
+
+	/* Self-IPI for inducing PIR makes no sense. */
+	if ((cpun != psm_get_cpu_id())) {
+#ifdef	DEBUG
+		/* Only for debugging. (again, see: x2apic_send_ipi) */
+		APIC_AV_PENDING_SET();
+#endif	/* DEBUG */
+
+		apic_reg_ops->apic_write_int_cmd(apic_cpus[cpun].aci_local_id,
+		    vector);
+	}
+
+	intr_restore(flag);
+}
+
 /*
  * Generates IPI to another CPU depending on the local APIC mode.
  * apic_send_ipi() and x2apic_send_ipi() depends on the configured
@@ -250,3 +279,16 @@ apic_common_send_ipi(int cpun, int ipl)
 	    vector);
 	intr_restore(flag);
 }
+
+void
+apic_common_send_pir_ipi(processorid_t cpun)
+{
+	const int mode = apic_local_mode();
+
+	if (mode == LOCAL_X2APIC) {
+		x2apic_send_pir_ipi(cpun);
+		return;
+	}
+
+	apic_send_pir_ipi(cpun);
+}
diff --git a/usr/src/uts/i86pc/io/pcplusmp/apic.c b/usr/src/uts/i86pc/io/pcplusmp/apic.c
index 9cc88491c1..93ee3380ed 100644
--- a/usr/src/uts/i86pc/io/pcplusmp/apic.c
+++ b/usr/src/uts/i86pc/io/pcplusmp/apic.c
@@ -201,7 +201,8 @@ static struct	psm_ops apic_ops = {
 	apic_state,			/* save, restore apic state for S3 */
 	apic_cpu_ops,			/* CPU control interface. */
 
-	apic_cached_ipivect,
+	apic_get_pir_ipivect,
+	apic_send_pir_ipi,
 };
 
 struct psm_ops *psmops = &apic_ops;
@@ -298,6 +299,8 @@ apic_init(void)
 		apic_ipltopri[j] = (i << APIC_IPL_SHIFT) + APIC_BASE_VECT;
 	apic_init_common();
 
+	apic_pir_vect = apic_get_ipivect(XC_CPUPOKE_PIL, -1);
+
 #if !defined(__amd64)
 	if (cpuid_have_cr8access(CPU))
 		apic_have_32bit_cr8 = 1;
diff --git a/usr/src/uts/i86pc/io/pcplusmp/apic_common.c b/usr/src/uts/i86pc/io/pcplusmp/apic_common.c
index 74d06c7f38..d849d96ea1 100644
--- a/usr/src/uts/i86pc/io/pcplusmp/apic_common.c
+++ b/usr/src/uts/i86pc/io/pcplusmp/apic_common.c
@@ -130,6 +130,8 @@ int cmci_cpu_setup_registered;
 
 lock_t apic_mode_switch_lock;
 
+int apic_pir_vect;
+
 /*
  * Patchable global variables.
  */
@@ -629,6 +631,31 @@ apic_send_ipi(int cpun, int ipl)
 	intr_restore(flag);
 }
 
+void
+apic_send_pir_ipi(processorid_t cpun)
+{
+	const int vector = apic_pir_vect;
+	ulong_t flag;
+
+	ASSERT((vector >= APIC_BASE_VECT) && (vector <= APIC_SPUR_INTR));
+
+	flag = intr_clear();
+
+	/* Self-IPI for inducing PIR makes no sense. */
+	if ((cpun != psm_get_cpu_id())) {
+		APIC_AV_PENDING_SET();
+		apic_reg_ops->apic_write_int_cmd(apic_cpus[cpun].aci_local_id,
+		    vector);
+	}
+
+	intr_restore(flag);
+}
+
+int
+apic_get_pir_ipivect(void)
+{
+	return (apic_pir_vect);
+}
 
 /*ARGSUSED*/
 void
@@ -1707,14 +1734,3 @@ apic_get_ioapicid(uchar_t ioapicindex)
 
 	return (apic_io_id[ioapicindex]);
 }
-
-int
-apic_cached_ipivect(int ipl, int type)
-{
-	uchar_t vector = 0;
-
-	if (type != -1 && ipl >= 0 && ipl <= MAXIPL) {
-		vector = apic_resv_vector[ipl];
-	}
-	return ((vector != 0) ? vector : -1);
-}
diff --git a/usr/src/uts/i86pc/io/psm/uppc.c b/usr/src/uts/i86pc/io/psm/uppc.c
index dae3040b68..c22154d1a7 100644
--- a/usr/src/uts/i86pc/io/psm/uppc.c
+++ b/usr/src/uts/i86pc/io/psm/uppc.c
@@ -177,7 +177,8 @@ static struct	psm_ops uppc_ops = {
 	uppc_state,				/* psm_state		*/
 	(int (*)(psm_cpu_request_t *))NULL,	/* psm_cpu_ops		*/
 
-	(int (*)(int, int))NULL,		/* psm_cached_ipivect	*/
+	(int (*)(void))NULL,			/* psm_get_pir_ipivect	*/
+	(void (*)(processorid_t))NULL,		/* psm_send_pir_ipi	*/
 };
 
 
diff --git a/usr/src/uts/i86pc/io/vmm/intel/vmx.c b/usr/src/uts/i86pc/io/vmm/intel/vmx.c
index 89573cccec..4bf335a7c5 100644
--- a/usr/src/uts/i86pc/io/vmm/intel/vmx.c
+++ b/usr/src/uts/i86pc/io/vmm/intel/vmx.c
@@ -53,6 +53,7 @@ __FBSDID("$FreeBSD$");
 
 #ifndef __FreeBSD__
 #include <sys/x86_archext.h>
+#include <sys/smp_impldefs.h>
 #endif
 
 #include <vm/vm.h>
@@ -518,8 +519,10 @@ vmx_disable(void *arg __unused)
 static int
 vmx_cleanup(void)
 {
+#ifdef __FreeBSD__
 	if (pirvec >= 0)
 		lapic_ipi_free(pirvec);
+#endif
 
 	if (vpid_unr != NULL) {
 		delete_unrhdr(vpid_unr);
@@ -739,19 +742,30 @@ vmx_init(int ipinum)
 		    MSR_VMX_TRUE_PINBASED_CTLS, PINBASED_POSTED_INTERRUPT, 0,
 		    &tmp);
 		if (error == 0) {
+#ifdef __FreeBSD__
 			pirvec = lapic_ipi_alloc(&IDTVEC(justreturn));
 			if (pirvec < 0) {
-#ifdef __FreeBSD__
 				if (bootverbose) {
 					printf("vmx_init: unable to allocate "
 					    "posted interrupt vector\n");
 				}
-#endif
 			} else {
 				posted_interrupts = 1;
 				TUNABLE_INT_FETCH("hw.vmm.vmx.use_apic_pir",
 				    &posted_interrupts);
 			}
+#else
+			/*
+			 * If the PSM-provided interfaces for requesting and
+			 * using a PIR IPI vector are present, use them for
+			 * posted interrupts.
+			 */
+			if (psm_get_pir_ipivect != NULL &&
+			    psm_send_pir_ipi != NULL) {
+				pirvec = psm_get_pir_ipivect();
+				posted_interrupts = 1;
+			}
+#endif
 		}
 	}
 
@@ -3546,8 +3560,11 @@ vmx_enable_x2apic_mode(struct vlapic *vlapic)
 static void
 vmx_post_intr(struct vlapic *vlapic, int hostcpu)
 {
-
+#ifdef __FreeBSD__
 	ipi_cpu(hostcpu, pirvec);
+#else
+	psm_send_pir_ipi(hostcpu);
+#endif
 }
 
 /*
diff --git a/usr/src/uts/i86pc/io/vmm/vmm.c b/usr/src/uts/i86pc/io/vmm/vmm.c
index 2e5198310c..4131294a56 100644
--- a/usr/src/uts/i86pc/io/vmm/vmm.c
+++ b/usr/src/uts/i86pc/io/vmm/vmm.c
@@ -370,7 +370,7 @@ vmm_init(void)
 	if (vmm_ipinum < 0)
 		vmm_ipinum = IPI_AST;
 #else
-	/* XXX: verify for EPT settings */
+	/* We use cpu_poke() for IPIs */
 	vmm_ipinum = 0;
 #endif
 
@@ -411,8 +411,10 @@ vmm_handler(module_t mod, int what, void *arg)
 		if (error == 0) {
 			vmm_resume_p = NULL;
 			iommu_cleanup();
+#ifdef __FreeBSD__
 			if (vmm_ipinum != IPI_AST)
 				lapic_ipi_free(vmm_ipinum);
+#endif
 			error = VMM_CLEANUP();
 			/*
 			 * Something bad happened - prevent new
diff --git a/usr/src/uts/i86pc/io/vmm/vmm_sol_glue.c b/usr/src/uts/i86pc/io/vmm/vmm_sol_glue.c
index 32f54e85d8..e38e600c32 100644
--- a/usr/src/uts/i86pc/io/vmm/vmm_sol_glue.c
+++ b/usr/src/uts/i86pc/io/vmm/vmm_sol_glue.c
@@ -635,38 +635,6 @@ vmm_sol_glue_cleanup(void)
 	fpu_save_area_cleanup();
 }
 
-int idtvec_justreturn;
-
-int
-lapic_ipi_alloc(int *id)
-{
-	/* Only poke_cpu() equivalent is supported */
-	VERIFY(id == &idtvec_justreturn);
-
-	/*
-	 * This is only used by VMX to allocate a do-nothing vector for
-	 * interrupting other running CPUs.  The cached poke_cpu() vector
-	 * as an "allocation" is perfect for this.
-	 */
-	if (psm_cached_ipivect != NULL) {
-		return (psm_cached_ipivect(XC_CPUPOKE_PIL, PSM_INTR_POKE));
-	}
-
-	return (-1);
-}
-
-void
-lapic_ipi_free(int vec)
-{
-	VERIFY(vec > 0);
-
-	/*
-	 * A cached vector was used in the first place.
-	 * No deallocation is necessary
-	 */
-	return;
-}
-
 
 /* From FreeBSD's sys/kern/subr_clock.c */
 
diff --git a/usr/src/uts/i86pc/os/mp_machdep.c b/usr/src/uts/i86pc/os/mp_machdep.c
index feb14d9fc1..48e14c0f9f 100644
--- a/usr/src/uts/i86pc/os/mp_machdep.c
+++ b/usr/src/uts/i86pc/os/mp_machdep.c
@@ -146,10 +146,11 @@ void (*gethrestimef)(timestruc_t *) = pc_gethrestime;
 void (*psm_notify_error)(int, char *) = (void (*)(int, char *))NULL;
 int (*psm_get_clockirq)(int) = NULL;
 int (*psm_get_ipivect)(int, int) = NULL;
-int (*psm_cached_ipivect)(int, int) = NULL;
 uchar_t (*psm_get_ioapicid)(uchar_t) = NULL;
 uint32_t (*psm_get_localapicid)(uint32_t) = NULL;
 uchar_t (*psm_xlate_vector_by_irq)(uchar_t) = NULL;
+int (*psm_get_pir_ipivect)(void) = NULL;
+void (*psm_send_pir_ipi)(processorid_t) = NULL;
 
 int (*psm_clkinit)(int) = NULL;
 void (*psm_timer_reprogram)(hrtime_t) = NULL;
@@ -1155,7 +1156,9 @@ mach_smpinit(void)
 	}
 
 	psm_get_ipivect = pops->psm_get_ipivect;
-	psm_cached_ipivect = pops->psm_cached_ipivect;
+	psm_get_pir_ipivect = pops->psm_get_pir_ipivect;
+	psm_send_pir_ipi = pops->psm_send_pir_ipi;
+
 
 	(void) add_avintr((void *)NULL, XC_HI_PIL, xc_serv, "xc_intr",
 	    (*pops->psm_get_ipivect)(XC_HI_PIL, PSM_INTR_IPI_HI),
diff --git a/usr/src/uts/i86pc/sys/apic.h b/usr/src/uts/i86pc/sys/apic.h
index 828ef5b20d..0352a154af 100644
--- a/usr/src/uts/i86pc/sys/apic.h
+++ b/usr/src/uts/i86pc/sys/apic.h
@@ -20,7 +20,7 @@
  */
 /*
  * Copyright (c) 1993, 2010, Oracle and/or its affiliates. All rights reserved.
- * Copyright 2017 Joyent, Inc.
+ * Copyright 2018 Joyent, Inc.
  */
 /*
  * Copyright (c) 2010, Intel Corporation.
@@ -831,6 +831,7 @@ extern void apic_change_eoi();
 extern void apic_send_EOI(uint32_t);
 extern void apic_send_directed_EOI(uint32_t);
 extern uint_t apic_calibrate(volatile uint32_t *, uint16_t *);
+extern void x2apic_send_pir_ipi(processorid_t);
 
 extern volatile uint32_t *apicadr;	/* virtual addr of local APIC   */
 extern int apic_forceload;
@@ -877,6 +878,7 @@ extern void apic_change_ops();
 extern void apic_common_send_ipi(int, int);
 extern void apic_set_directed_EOI_handler();
 extern int apic_directed_EOI_supported();
+extern void apic_common_send_pir_ipi(processorid_t);
 
 extern apic_intrmap_ops_t *apic_vt_ops;
 
diff --git a/usr/src/uts/i86pc/sys/apic_common.h b/usr/src/uts/i86pc/sys/apic_common.h
index 582041d8b5..72bc05e817 100644
--- a/usr/src/uts/i86pc/sys/apic_common.h
+++ b/usr/src/uts/i86pc/sys/apic_common.h
@@ -115,6 +115,8 @@ extern int	apic_panic_on_apic_error;
 
 extern int	apic_verbose;
 
+extern int	apic_pir_vect;
+
 #ifdef DEBUG
 extern int	apic_debug;
 extern int	apic_restrict_vector;
@@ -182,7 +184,8 @@ extern void	apic_shutdown(int cmd, int fcn);
 extern void	apic_preshutdown(int cmd, int fcn);
 extern processorid_t	apic_get_next_processorid(processorid_t cpun);
 extern uint_t	apic_calibrate(volatile uint32_t *, uint16_t *);
-extern int	apic_cached_ipivect(int, int);
+extern int	apic_get_pir_ipivect(void);
+extern void	apic_send_pir_ipi(processorid_t);
 
 extern int apic_error_intr();
 extern void apic_cpcovf_mask_clear(void);
diff --git a/usr/src/uts/i86pc/sys/psm_types.h b/usr/src/uts/i86pc/sys/psm_types.h
index b7f8e746da..6b779373b5 100644
--- a/usr/src/uts/i86pc/sys/psm_types.h
+++ b/usr/src/uts/i86pc/sys/psm_types.h
@@ -192,7 +192,8 @@ struct 	psm_ops {
 #if defined(PSMI_1_7)
 	int	(*psm_cpu_ops)(psm_cpu_request_t *reqp);
 
-	int	(*psm_cached_ipivect)(int ipl, int type);
+	int	(*psm_get_pir_ipivect)(void);
+	void	(*psm_send_pir_ipi)(processorid_t cpu);
 #endif
 };
 
diff --git a/usr/src/uts/i86pc/sys/smp_impldefs.h b/usr/src/uts/i86pc/sys/smp_impldefs.h
index 16dcf9cbfe..2848b1b3c2 100644
--- a/usr/src/uts/i86pc/sys/smp_impldefs.h
+++ b/usr/src/uts/i86pc/sys/smp_impldefs.h
@@ -74,6 +74,8 @@ extern int (*psm_state)(psm_state_request_t *); /* psm state save/restore */
 extern uchar_t (*psm_get_ioapicid)(uchar_t);	/* get io-apic id */
 extern uint32_t (*psm_get_localapicid)(uint32_t);	/* get local-apic id */
 extern uchar_t (*psm_xlate_vector_by_irq)(uchar_t); /* get vector for an irq */
+extern int (*psm_get_pir_ipivect)(void); /* get PIR (for VMM) ipi vect	*/
+extern void (*psm_send_pir_ipi)(processorid_t);	/* send PIR ipi		*/
 
 extern int (*slvltovect)(int);	/* ipl interrupt priority level		*/
 extern int (*setlvl)(int, int *); /* set intr pri represented by vect	*/
diff --git a/usr/src/uts/i86xpv/io/psm/xpv_psm.c b/usr/src/uts/i86xpv/io/psm/xpv_psm.c
index 16b75f85b9..7f1ac2170a 100644
--- a/usr/src/uts/i86xpv/io/psm/xpv_psm.c
+++ b/usr/src/uts/i86xpv/io/psm/xpv_psm.c
@@ -1676,7 +1676,8 @@ static struct psm_ops xen_psm_ops = {
 	(int (*)(psm_state_request_t *))NULL,	/* psm_state		*/
 	(int (*)(psm_cpu_request_t *))NULL,	/* psm_cpu_ops		*/
 
-	(int (*)(int, int))NULL,		/* psm_cached_ipivect	*/
+	(int (*)(void))NULL,			/* psm_get_pir_ipivect	*/
+	(void (*)(processorid_t))NULL,		/* psm_send_pir_ipi	*/
 };
 
 static struct psm_info xen_psm_info = {
diff --git a/usr/src/uts/i86xpv/io/psm/xpv_uppc.c b/usr/src/uts/i86xpv/io/psm/xpv_uppc.c
index 741f7c342d..fa6a079826 100644
--- a/usr/src/uts/i86xpv/io/psm/xpv_uppc.c
+++ b/usr/src/uts/i86xpv/io/psm/xpv_uppc.c
@@ -895,7 +895,8 @@ static struct psm_ops xen_uppc_ops = {
 	(int (*)(psm_state_request_t *))NULL,	/* psm_state		*/
 	(int (*)(psm_cpu_request_t *))NULL,	/* psm_cpu_ops		*/
 
-	(int (*)(int, int))NULL,		/* psm_cached_ipivect	*/
+	(int (*)(void))NULL,			/* psm_get_pir_ipivect	*/
+	(void (*)(processorid_t))NULL,		/* psm_send_pir_ipi	*/
 };
 
 static struct psm_info xen_uppc_info = {
