commit 8859531b19aa6f40f48ff3aefe5102eacb5228da (refs/changes/96/2196/3)
Author: Kelly McLaughlin <kelly.mclaughlin@joyent.com>
Date:   2017-07-14T14:14:37-06:00 (2 years, 3 months ago)
    
    joyent/node-manta#312 Custom header input should tolerate ':' characters

diff --git a/CHANGES.md b/CHANGES.md
index 608cfe8..305ed35 100644
--- a/CHANGES.md
+++ b/CHANGES.md
@@ -2,6 +2,10 @@
 
 ## not yet released
 
+## 4.4.2
+
+- joyent/node-manta#312 Custom header input should tolerate ':' characters
+
 ## 4.4.1
 
 - joyent/node-manta#302 Create a manual page for `mmpu`
diff --git a/bin/mget b/bin/mget
index 571e666..484cd0d 100755
--- a/bin/mget
+++ b/bin/mget
@@ -6,6 +6,7 @@
 
 var fs = require('fs');
 var path = require('path-platform');
+var strsplit = require('strsplit');
 
 var assert = require('assert-plus');
 var bunyan = require('bunyan');
@@ -16,46 +17,51 @@ var vasync = require('vasync');
 var manta = require('../lib');
 
 
-var NAME = path.basename(process.argv[1]);
-var LOG = bunyan.createLogger({
-    name: NAME,
-    level: (process.env.LOG_LEVEL || 'info'),
-    stream: process.stderr
-});
-
-var OPTIONS_PARSER = dashdash.createParser({
-    options: manta.DEFAULT_CLI_OPTIONS.concat([
-        {
-            group: NAME + ' options'
-        },
-        {
-            names: ['header', 'H'],
-            type: 'arrayOfString',
-            help: 'HTTP headers to include',
-            helpArg: 'HEADER'
-        },
-        {
-            names: ['quiet', 'q'],
-            type: 'bool',
-            help: 'disable the progress bar'
-        },
-        {
-            names: ['progress'],
-            type: 'bool',
-            help: 'force the progress bar to draw, even when stderr redirected'
-        },
-        {
-            names: ['output', 'o'],
-            type: 'string',
-            help: 'write output to <file> instead of stdout'
-        },
-        {
-            names: ['remote-name', 'O'],
-            type: 'bool',
-            help: 'write output to a file using remote object name as filename'
-        }
-    ])
-});
+/**
+ * Create a dashdash options parser for this command
+ *
+ * @param {String} name: Required. The command name.
+ * @returns {Object} A dashdash options parser for the command.
+ */
+function optionsParser(name) {
+    var parser = dashdash.createParser({
+        options: manta.DEFAULT_CLI_OPTIONS.concat([
+            {
+                group: name + ' options'
+            },
+            {
+                names: ['header', 'H'],
+                type: 'arrayOfString',
+                help: 'HTTP headers to include',
+                helpArg: 'HEADER'
+            },
+            {
+                names: ['quiet', 'q'],
+                type: 'bool',
+                help: 'disable the progress bar'
+            },
+            {
+                names: ['progress'],
+                type: 'bool',
+                help: 'force the progress bar to draw, even when \
+                       stderr redirected'
+            },
+            {
+                names: ['output', 'o'],
+                type: 'string',
+                help: 'write output to <file> instead of stdout'
+            },
+            {
+                names: ['remote-name', 'O'],
+                type: 'bool',
+                help: 'write output to a file using remote object name as \
+                       filename'
+            }
+        ])
+    });
+
+    return (parser);
+}
 
 
 function ifError(err) {
@@ -66,53 +72,6 @@ function ifError(err) {
 }
 
 
-function parseOptions() {
-    var opts;
-
-    try {
-        opts = OPTIONS_PARSER.parse(process.argv);
-        manta.checkBinEnv(opts);
-    } catch (e) {
-        manta.cli_usage(OPTIONS_PARSER, e.message, 'path...');
-    }
-
-    manta.cli_logger(opts, LOG);
-
-    if (opts.help)
-        manta.cli_usage(OPTIONS_PARSER, false, 'path...');
-
-    manta.cliVersionCheckPrintAndExit(opts);
-    manta.cliCompletionCheckPrintAndExit(opts, OPTIONS_PARSER, NAME, ['mpath']);
-
-    if (opts._args.length < 1)
-        manta.cli_usage(OPTIONS_PARSER, 'path required', 'path...');
-
-    opts.paths = opts._args;
-
-    if (opts.remote_name) {
-        if (opts.paths.length !== 1) {
-            manta.cli_usage(OPTIONS_PARSER, '--remote-name only works with ' +
-              'a single object path', 'path...');
-        } else {
-            opts.output = path.posix.basename(opts.paths[0]);
-        }
-    }
-
-    opts.headers = {};
-    (opts.header || []).forEach(function (h) {
-        if (h.indexOf(':') === -1) {
-            manta.cli_usage(OPTIONS_PARSER,
-                            'header must be in the form of "[header]: value"',
-                            'path...');
-        }
-        var tmp = h.split(':');
-        opts.headers[tmp[0]] = tmp[1].trim();
-    });
-
-    return (opts);
-}
-
-
 function downloadOne(dlo, done) {
     assert.object(dlo, 'dlo');
     assert.bool(dlo.dlo_progress, 'dlo.dlo_progress');
@@ -168,8 +127,43 @@ function downloadOne(dlo, done) {
 }
 
 
+/**
+ * Handle command-specific options parsing and checking.
+ *
+ * @param {Object} opts: Required. A parsed options object.
+ * @param {Object} parser: Required. A dashdash option parser.
+ * @returns {Object} A possibly mutated version of the `opts` input parameter.
+ */
+function parseCmdOptions(opts, parser) {
+    if (opts.remote_name) {
+        if (opts.paths.length !== 1) {
+            manta.cli_usage(parser, '--remote-name only works with ' +
+                            'a single object path', 'path...');
+        } else {
+            opts.output = path.posix.basename(opts.paths[0]);
+        }
+    }
+
+    return (opts);
+}
+
+
 (function main() {
-    var opts = parseOptions();
+    var name = path.basename(process.argv[1]);
+    var log = bunyan.createLogger({
+        name: name,
+        level: (process.env.LOG_LEVEL || 'info'),
+        stream: process.stderr
+    });
+    var parser = optionsParser(name);
+    var parseArgs = {
+        name: name,
+        parser: parser,
+        argTypes: ['mpath'],
+        parseCmdOptions: parseCmdOptions,
+        log: log
+    };
+    var opts = manta.parseOptions(parseArgs);
     var client = manta.createBinClient(opts);
     var drawProgressBar = true;
 
diff --git a/bin/mmkdir b/bin/mmkdir
index c376c60..96e85eb 100755
--- a/bin/mmkdir
+++ b/bin/mmkdir
@@ -1,10 +1,11 @@
 #!/usr/bin/env node
 // -*- mode: js -*-
 /*
- * Copyright 2016 Joyent, Inc.
+ * Copyright 2017 Joyent, Inc.
  */
 
 var path = require('path');
+var strsplit = require('strsplit');
 var url = require('url');
 
 var bunyan = require('bunyan');
@@ -13,44 +14,44 @@ var dashdash = require('dashdash');
 var manta = require('../lib');
 
 
+///--- Functions
 
-///--- Globals
-
-var NAME = path.basename(process.argv[1]);
-var LOG = bunyan.createLogger({
-    name: NAME,
-    level: (process.env.LOG_LEVEL || 'info'),
-    stream: process.stderr
-});
-
-var OPTIONS_PARSER = dashdash.createParser({
-    options: manta.DEFAULT_CLI_OPTIONS.concat([
-        {
-            group: NAME + ' options'
-        },
-        {
-            names: ['header', 'H'],
-            type: 'arrayOfString',
-            help: 'HTTP headers to include',
-            helpArg: 'HEADER'
-        },
-        {
-            names: ['parents', 'p'],
-            type: 'bool',
-            help: 'no error if existing, make parent directories as needed'
-        },
-        {
-            names: ['role-tag'],
-            type: 'arrayOfString',
-            help: 'role tags to apply to the created directory',
-            helpArg: 'TAG,TAG...'
-        }
-    ])
-});
+/**
+ * Create a dashdash options parser for this command
+ *
+ * @param {String} name: Required. The command name.
+ * @returns {Object} A dashdash options parser for the command.
+ */
+function optionsParser(name) {
+    var parser = dashdash.createParser({
+        options: manta.DEFAULT_CLI_OPTIONS.concat([
+            {
+                group: name + ' options'
+            },
+            {
+                names: ['header', 'H'],
+                type: 'arrayOfString',
+                help: 'HTTP headers to include',
+                helpArg: 'HEADER'
+            },
+            {
+                names: ['parents', 'p'],
+                type: 'bool',
+                help: 'no error if existing, make parent directories as needed'
+            },
+            {
+                names: ['role-tag'],
+                type: 'arrayOfString',
+                help: 'role tags to apply to the created directory',
+                helpArg: 'TAG,TAG...'
+            }
+        ])
+    });
 
+    return (parser);
 
+}
 
-///--- Functions
 
 function ifError(err) {
     if (err) {
@@ -60,42 +61,21 @@ function ifError(err) {
 }
 
 
-function parseOptions() {
-    var opts;
-
-    try {
-        opts = OPTIONS_PARSER.parse(process.argv);
-        manta.checkBinEnv(opts);
-    } catch (e) {
-        manta.cli_usage(OPTIONS_PARSER, e.message, 'path...');
-    }
-
-    manta.cli_logger(opts, LOG);
-
-    if (opts.help)
-        manta.cli_usage(OPTIONS_PARSER, false, 'path...');
-
-    manta.cliVersionCheckPrintAndExit(opts);
-    manta.cliCompletionCheckPrintAndExit(opts, OPTIONS_PARSER, NAME, ['mdir']);
-
-    opts.headers = {};
-    (opts.header || []).forEach(function (h) {
-        if (h.indexOf(':') === -1) {
-            manta.cli_usage(OPTIONS_PARSER,
-                            'header must be in the form of "[header]: value"',
-                            'path...');
-        }
-        var tmp = h.split(':');
-        opts.headers[tmp[0]] = tmp[1].trim();
-    });
-
+/**
+ * Handle command-specific options parsing and checking.
+ *
+ * @param {Object} opts: Required. A parsed options object.
+ * @param {Object} parser: Required. A dashdash option parser.
+ * @returns {Object} A possibly mutated version of the `opts` input parameter.
+ */
+function parseCmdOptions(opts, parser) {
     if (opts['role-tag'] && opts['role-tag'].length === 1) {
         /* JSSTYLED */
         opts['role-tag'] = opts['role-tag'][0].split(/\s*,\s*/);
     }
 
     if (opts._args.length < 1)
-        manta.cli_usage(OPTIONS_PARSER, 'path required', 'path...');
+        manta.cli_usage(parser, 'path required', 'path...');
 
     opts.paths = opts._args.map(function (p) {
         ifError(manta.assertPath(p, true));
@@ -110,7 +90,21 @@ function parseOptions() {
 ///--- Mainline
 (function main() {
     var done = 0;
-    var options = parseOptions();
+    var name = path.basename(process.argv[1]);
+    var log = bunyan.createLogger({
+        name: name,
+        level: (process.env.LOG_LEVEL || 'info'),
+        stream: process.stderr
+    });
+    var parser = optionsParser(name);
+    var parseArgs = {
+        name: name,
+        parser: parser,
+        argTypes: ['mdir'],
+        parseCmdOptions: parseCmdOptions,
+        log: log
+    };
+    var options = manta.parseOptions(parseArgs);
     var client = manta.createBinClient(options);
     var headers = {
         headers: options.headers || {}
diff --git a/bin/mput b/bin/mput
index 36fd08c..7a62ef4 100755
--- a/bin/mput
+++ b/bin/mput
@@ -7,6 +7,7 @@
 var crypto = require('crypto');
 var fs = require('fs');
 var path = require('path');
+var strsplit = require('strsplit');
 var url = require('url');
 
 var backoff = require('backoff');
@@ -17,72 +18,72 @@ var once = require('once');
 var manta = require('../lib');
 
 
+///--- Functions
 
-///--- Globals
-
-var NAME = path.basename(process.argv[1]);
-var LOG = bunyan.createLogger({
-    name: NAME,
-    level: (process.env.LOG_LEVEL || 'info'),
-    stream: process.stderr
-});
-
-var OPTIONS_PARSER = dashdash.createParser({
-    options: manta.DEFAULT_CLI_OPTIONS.concat([
-        {
-            group: NAME + ' options'
-        },
-        {
-            names: ['copies', 'c'],
-            type: 'positiveInteger',
-            help: 'number of copies to make',
-            helpArg: 'COPIES',
-            'default': 2
-        },
-        {
-            names: ['file', 'f'],
-            type: 'string',
-            help: 'local file to upload',
-            helpArg: 'FILE'
-        },
-        {
-            names: ['header', 'H'],
-            type: 'arrayOfString',
-            help: 'HTTP headers to include',
-            helpArg: 'HEADER'
-        },
-        {
-            names: ['md5', 'm'],
-            type: 'bool',
-            help: 'calculate MD5 and then upload (requires -f/--file)'
-        },
-        {
-            names: ['parents', 'p'],
-            type: 'bool',
-            help: 'create parent directories as needed'
-        },
-        {
-            names: ['quiet', 'q'],
-            type: 'bool',
-            help: 'disable the progress bar'
-        },
-        {
-            names: ['progress'],
-            type: 'bool',
-            help: 'force the progress bar to draw, even when stderr redirected'
-        },
-        {
-            names: ['role-tag'],
-            type: 'arrayOfString',
-            help: 'role tags to apply to the created object',
-            helpArg: 'TAG,TAG...'
-        }
-    ])
-});
-
+/**
+ * Create a dashdash options parser for this command
+ *
+ * @param {String} name: Required. The command name.
+ * @returns {Object} A dashdash options parser for the command.
+ */
+function optionsParser(name) {
+    var parser = dashdash.createParser({
+        options: manta.DEFAULT_CLI_OPTIONS.concat([
+            {
+                group: name + ' options'
+            },
+            {
+                names: ['copies', 'c'],
+                type: 'positiveInteger',
+                help: 'number of copies to make',
+                nhelpArg: 'COPIES',
+                default: 2
+            },
+            {
+                names: ['file', 'f'],
+                type: 'string',
+                help: 'local file to upload',
+                helpArg: 'FILE'
+            },
+            {
+                names: ['header', 'H'],
+                type: 'arrayOfString',
+                help: 'HTTP headers to include',
+                helpArg: 'HEADER'
+            },
+            {
+                names: ['md5', 'm'],
+                type: 'bool',
+                help: 'calculate MD5 and then upload (requires -f/--file)'
+            },
+            {
+                names: ['parents', 'p'],
+                type: 'bool',
+                help: 'create parent directories as needed'
+            },
+            {
+                names: ['quiet', 'q'],
+                type: 'bool',
+                help: 'disable the progress bar'
+            },
+            {
+                names: ['progress'],
+                type: 'bool',
+                help: 'force the progress bar to draw, even when \
+                       stderr redirected'
+            },
+            {
+                names: ['role-tag'],
+                type: 'arrayOfString',
+                help: 'role tags to apply to the created object',
+                helpArg: 'TAG,TAG...'
+            }
+        ])
+    });
 
+    return (parser);
+}
 
-///--- Functions
 
 function ifError(err) {
     if (!err)
@@ -102,45 +103,20 @@ function ifError(err) {
 }
 
 
-function parseOptions() {
-    var opts;
-
-    try {
-        opts = OPTIONS_PARSER.parse(process.argv);
-        manta.checkBinEnv(opts);
-    } catch (e) {
-        manta.cli_usage(OPTIONS_PARSER, e.message, 'path...');
-    }
-
-    manta.cli_logger(opts, LOG);
-
-    if (opts.help)
-        manta.cli_usage(OPTIONS_PARSER, false, 'path...');
-
-    manta.cliVersionCheckPrintAndExit(opts);
-    manta.cliCompletionCheckPrintAndExit(opts, OPTIONS_PARSER, NAME,
-        ['mpath', 'none']);
-
+/**
+ * Handle command-specific options parsing and checking.
+ *
+ * @param {Object} opts: Required. A parsed options object.
+ * @param {Object} parser: Required. A dashdash option parser.
+ * @returns {Object} A possibly mutated version of the `opts` input parameter.
+ */
+function parseCmdOptions(opts, parser) {
     if (opts.md5 && !opts.file)
-        manta.cli_usage(OPTIONS_PARSER, '--md5 requires --file', 'path...');
-
-    if (opts._args.length < 1)
-        manta.cli_usage(OPTIONS_PARSER, 'path required', 'path...');
+        manta.cli_usage(parser, '--md5 requires --file', 'path...');
 
     ifError(manta.assertPath(opts._args[0], true));
     opts.path = manta.path(opts._args[0], true);
 
-    opts.headers = {};
-    (opts.header || []).forEach(function (h) {
-        if (h.indexOf(':') === -1) {
-            manta.cli_usage(OPTIONS_PARSER,
-                            'header must be in the form of "[header]: value"',
-                            'path...');
-        }
-        var tmp = h.split(':');
-        opts.headers[tmp[0]] = tmp[1].trim();
-    });
-
     if (opts['role-tag'] && opts['role-tag'].length === 1) {
         /* JSSTYLED */
         opts['role-tag'] = opts['role-tag'][0].split(/\s*,\s*/);
@@ -155,12 +131,26 @@ function printEntry(obj) {
 }
 
 
-
 ///--- Mainline
 
 (function main() {
     var bar = null;
-    var options = parseOptions();
+    var argTypes = ['mpath', 'none'];
+    var name = path.basename(process.argv[1]);
+    var log = bunyan.createLogger({
+        name: name,
+        level: (process.env.LOG_LEVEL || 'info'),
+        stream: process.stderr
+    });
+    var parser = optionsParser(name);
+    var parseArgs = {
+        name: name,
+        parser: parser,
+        argTypes: argTypes,
+        parseCmdOptions: parseCmdOptions,
+        log: log
+    };
+    var options = manta.parseOptions(parseArgs);
 
     var client = manta.createBinClient(options);
     var headers = options.headers || {};
@@ -276,7 +266,7 @@ function printEntry(obj) {
                     // precondition was not met, then bail out without retrying:
                     if (error && error.name === 'PreconditionFailedError')
                         ifError(error);
-                    LOG.debug({
+                    log.debug({
                         err: error,
                         num: num,
                         delay: delay
diff --git a/bin/muntar b/bin/muntar
index f50e3db..afea540 100755
--- a/bin/muntar
+++ b/bin/muntar
@@ -8,6 +8,7 @@ var fs = require('fs');
 var url = require('url');
 
 var mod_path = require('path');
+var strsplit = require('strsplit');
 
 var bunyan = require('bunyan');
 var dashdash = require('dashdash');
@@ -19,67 +20,73 @@ var http = require('http');
 var https = require('https');
 var tar = require('tar');
 
+
 ///--- Globals
 
-var NAME = mod_path.basename(process.argv[1]);
 var IN_PROGRESS = {};
-var LOG = bunyan.createLogger({
-    name: NAME,
-    level: (process.env.LOG_LEVEL || 'info'),
-    stream: process.stderr
-});
 var MAX_SOCKETS = parseInt(process.env.MANTA_MAX_SOCKETS || 1000, 10);
 
-var OPTIONS_PARSER = dashdash.createParser({
-    options: manta.DEFAULT_CLI_OPTIONS.concat([
-        {
-            group: NAME + ' options'
-        },
-        {
-            names: ['copies', 'c'],
-            type: 'positiveInteger',
-            help: 'number of copies to make',
-            helpArg: 'COPIES',
-            'default': 2
-        },
-        {
-            names: ['file', 'f'],
-            type: 'string',
-            help: 'local file to upload (required)',
-            helpArg: 'FILE'
-        },
-        {
-            names: ['header', 'H'],
-            type: 'arrayOfString',
-            help: 'HTTP headers to include',
-            helpArg: 'HEADER'
-        },
-        {
-            names: ['parallel', 'p'],
-            type: 'positiveInteger',
-            help: 'limit concurrent operations (default 20)',
-            'default': 20,
-            helpArg: 'NUM'
-        },
-        {
-            names: ['retries', 'r'],
-            type: 'positiveInteger',
-            help: 'number of retries on error (default 3)',
-            'default': 3,
-            helpArg: 'RETRIES'
-        },
-        {
-            names: ['role-tag'],
-            type: 'arrayOfString',
-            help: 'role tags to apply to the destination object',
-            helpArg: 'TAG,TAG...'
-        }
-    ])
-});
 
+///--- Functions
+
+/**
+ * Create a dashdash options parser for this command
+ *
+ * @param {String} name: Required. The command name.
+ * @returns {Object} A dashdash options parser for the command.
+ */
+function optionsParser(name) {
+    var parser = dashdash.createParser({
+        options: manta.DEFAULT_CLI_OPTIONS.concat([
+            {
+                group: name + ' options'
+            },
+            {
+                names: ['copies', 'c'],
+                type: 'positiveInteger',
+                help: 'number of copies to make',
+                helpArg: 'COPIES',
+                default: 2
+            },
+            {
+                names: ['file', 'f'],
+                type: 'string',
+                help: 'local file to upload (required)',
+                helpArg: 'FILE'
+            },
+            {
+                names: ['header', 'H'],
+                type: 'arrayOfString',
+                help: 'HTTP headers to include',
+                helpArg: 'HEADER'
+            },
+            {
+                names: ['parallel', 'p'],
+                type: 'positiveInteger',
+                help: 'limit concurrent operations (default 20)',
+                default: 20,
+                helpArg: 'NUM'
+            },
+            {
+                names: ['retries', 'r'],
+                type: 'positiveInteger',
+                help: 'number of retries on error (default 3)',
+                default: 3,
+                helpArg: 'RETRIES'
+            },
+            {
+                names: ['role-tag'],
+                type: 'arrayOfString',
+                help: 'role tags to apply to the destination object',
+                helpArg: 'TAG,TAG...'
+            }
+        ])
+    });
+
+    return (parser);
 
+}
 
-///--- Functions
 
 function ifError(err) {
     if (err) {
@@ -89,45 +96,20 @@ function ifError(err) {
 }
 
 
-function parseOptions() {
-    var opts;
-
-    try {
-        opts = OPTIONS_PARSER.parse(process.argv);
-        manta.checkBinEnv(opts);
-    } catch (e) {
-        manta.cli_usage(OPTIONS_PARSER, e.message, 'path');
-    }
-
-    manta.cli_logger(opts, LOG);
-
-    if (opts.help)
-        manta.cli_usage(OPTIONS_PARSER, false, 'path');
-
-    manta.cliVersionCheckPrintAndExit(opts);
-    manta.cliCompletionCheckPrintAndExit(opts, OPTIONS_PARSER, NAME,
-        ['mpath', 'none']);
-
+/**
+ * Handle command-specific options parsing and checking.
+ *
+ * @param {Object} opts: Required. A parsed options object.
+ * @param {Object} parser: Required. A dashdash option parser.
+ * @returns {Object} A possibly mutated version of the `opts` input parameter.
+ */
+function parseCmdOptions(opts, parser) {
     if (!opts.file)
-        manta.cli_usage(OPTIONS_PARSER, 'file is a required argument', 'path');
-
-    if (opts._args.length < 1)
-        manta.cli_usage(OPTIONS_PARSER, 'path required', 'path');
+        manta.cli_usage(parser, 'file is a required argument', 'path');
 
     ifError(manta.assertPath(opts._args[0], true));
     opts.path = manta.path(opts._args[0], true);
 
-    opts.headers = {};
-    (opts.header || []).forEach(function (h) {
-        if (h.indexOf(':') === -1) {
-            manta.cli_usage(OPTIONS_PARSER,
-                            'header must be in the form of "[header]: value"',
-                            'path...');
-        }
-        var tmp = h.split(':');
-        opts.headers[tmp[0]] = tmp[1].trim();
-    });
-
     if (opts['role-tag'] && opts['role-tag'].length === 1) {
         /* JSSTYLED */
         opts['role-tag'] = opts['role-tag'][0].split(/\s*,\s*/);
@@ -186,7 +168,7 @@ function put(client, path, stream, opts, cb) {
  * pausing the tar parsing, each worker needs to take its own pass through
  * the tarball.
  */
-function worker(client, tarball, callback) {
+function worker(client, tarball, callback, log) {
     var entry = 0;
     var inflight = 1;
     var stream = fs.createReadStream(tarball.file);
@@ -223,12 +205,12 @@ function worker(client, tarball, callback) {
                     tarball.retry[_entry] = 0;
 
                 if (tarball.retry[_entry]++ >= tarball.options.retries) {
-                    LOG.debug({ err: err, num: tarball.retry[_entry] },
+                    log.debug({ err: err, num: tarball.retry[_entry] },
                         'put to ' + path + ' failed; aborting');
                     ifError(err);
                 }
 
-                LOG.debug({ err: err, num: tarball.retry[_entry] },
+                log.debug({ err: err, num: tarball.retry[_entry] },
                     'put to ' + path + ' failed; retrying');
                 e.resume();
             }
@@ -272,7 +254,22 @@ function worker(client, tarball, callback) {
 ///--- Mainline
 
 (function main() {
-    var options = parseOptions();
+    var name = mod_path.basename(process.argv[1]);
+    var log = bunyan.createLogger({
+        name: name,
+        level: (process.env.LOG_LEVEL || 'info'),
+        stream: process.stderr
+    });
+    var parser = optionsParser(name);
+    var argTypes = ['mpath', 'none'];
+    var parseArgs = {
+        name: name,
+        parser: parser,
+        argTypes: argTypes,
+        parseCmdOptions: parseCmdOptions,
+        log: log
+    };
+    var options = manta.parseOptions(parseArgs);
 
     http.globalAgent.maxSockets = MAX_SOCKETS;
     https.globalAgent.maxSockets = MAX_SOCKETS;
@@ -298,7 +295,7 @@ function worker(client, tarball, callback) {
             return;
         }
 
-        worker(client, tarball, lastdone);
+        worker(client, tarball, lastdone, log);
     }
 
     function cb() {
@@ -309,5 +306,5 @@ function worker(client, tarball, callback) {
     }
 
     for (var i = 0; i < options.parallel; i++)
-        worker(client, tarball, cb);
+        worker(client, tarball, cb, log);
 })();
diff --git a/lib/index.js b/lib/index.js
index 54d278a..71b02e2 100644
--- a/lib/index.js
+++ b/lib/index.js
@@ -3,6 +3,7 @@
 var auth = require('smartdc-auth');
 var cc = require('./create_client');
 var manta = require('./client');
+var options = require('./options');
 var progbar = require('progbar');
 var Queue = require('./queue');
 var StringStream = require('./string_stream');
@@ -48,5 +49,6 @@ module.exports = {
     StringStream: StringStream,
     path: manta.path,
     jobPath: manta.jobPath,
-    escapePath: utils.escapePath
+    escapePath: utils.escapePath,
+    parseOptions: options.parseOptions
 };
diff --git a/lib/options.js b/lib/options.js
new file mode 100644
index 0000000..3fbffed
--- /dev/null
+++ b/lib/options.js
@@ -0,0 +1,82 @@
+/*
+ * Copyright 2017 Joyent, Inc.
+ */
+
+var assert = require('assert-plus');
+var strsplit = require('strsplit');
+
+var cc = require('./create_client');
+
+module.exports = {
+    parseOptions: parseOptions
+};
+
+
+/**
+ * Parse the common command options and then check any command-specific options
+ *  represented by the caller as a function from opts Object to options Object
+ *
+ *
+ * @param {Object} args: Required. Object to specify parsing arguments with
+ *                       the following fields:
+ *      - `name`: String. The command name.
+ *      - `parser`: Object. A dashdash options parser.
+ *      - `argTypes`: Array of String. An array of types for positional
+ *                    arguments to this command. See 'argtypes' docs here:
+ *                    // JSSTYLED
+ *                    <https://github.com/trentm/node-dashdash/blob/1dd7379640462a21ca6d92502803de830b4acfa2/lib/dashdash.js#L753-L760>
+ *      - `parseCmdOptions`: Function. A function takes a parsed options
+ *                           object and a parser instance as input and
+ *                           performs command-specific options options
+ *                           parsing. The options object is returned and
+ *                           may be mutated by the function.
+ *      - `log`: Object. Bunyan Logger instance
+ * @returns {Object} Parsed `opts`. It has special keys `_args` (the
+ *                   remaining args from `argv`) and `_order` (gives the
+ *                   order that options were specified).
+ */
+function parseOptions(args) {
+    assert.object(args, 'args');
+    assert.string(args.name, 'args.name');
+    assert.object(args.parser, 'args.parser');
+    assert.optionalArrayOfString(args.argTypes, 'args.argTypes');
+    assert.func(args.parseCmdOptions, 'args.parseCmdOptions');
+    assert.object(args.log, 'args.log');
+
+    var parser = args.parser;
+    var opts;
+
+    try {
+        opts = parser.parse(process.argv);
+        cc.checkBinEnv(opts);
+    } catch (e) {
+        cc.usage(parser, e.message, 'path...');
+    }
+
+    cc.setupLogger(opts, args.log);
+
+    if (opts.help)
+        cc.usage(parser, false, 'path...');
+
+    cc.versionCheckPrintAndExit(opts);
+    cc.completionCheckPrintAndExit(opts, parser, args.name, args.argTypes);
+
+    if (opts._args.length < 1)
+        cc.usage(parser, 'path required', 'path...');
+
+    opts.paths = opts._args;
+
+    opts.headers = {};
+    (opts.header || []).forEach(function (h) {
+        if (h.indexOf(':') === -1) {
+            cc.usage(parser, 'header must be in the form of "[header]: value"',
+                     'path...');
+        }
+        var tokens = strsplit(h, ':', 2);
+        opts.headers[tokens[0]] = tokens[1].trim();
+    });
+
+    args.parseCmdOptions(opts, parser);
+
+    return (opts);
+}
\ No newline at end of file
diff --git a/package.json b/package.json
index 6e072ff..b9dd171 100644
--- a/package.json
+++ b/package.json
@@ -7,7 +7,7 @@
         "type": "git",
         "url": "git://github.com/joyent/node-manta.git"
     },
-    "version": "4.4.1",
+    "version": "4.4.2",
     "main": "./lib/index.js",
     "dependencies": {
         "assert-plus": "^1.0.0",
diff --git a/test/mput.test.js b/test/mput.test.js
new file mode 100644
index 0000000..4a32f53
--- /dev/null
+++ b/test/mput.test.js
@@ -0,0 +1,190 @@
+/*
+ * Copyright 2017 Joyent, Inc.
+ */
+
+/*
+ * Test the "mput" command.
+ */
+
+var assert = require('assert-plus');
+var forkExecWait = require('forkexec').forkExecWait;
+var fs = require('fs');
+var libuuid = require('uuid');
+var path = require('path');
+var vasync = require('vasync');
+var sprintf = require('extsprintf').sprintf;
+
+var logging = require('./lib/logging');
+
+
+var log = logging.createLogger();
+
+var BINDIR = path.resolve(__dirname, '../bin');
+var MGET = path.resolve(BINDIR, 'mget');
+var MMKDIR = path.resolve(BINDIR, 'mmkdir');
+var MPUT = path.resolve(BINDIR, 'mput');
+var MRM = path.resolve(BINDIR, 'mrm');
+var MINFO = path.resolve(BINDIR, 'minfo');
+
+var TMPDIR = process.env.TMPDIR || '/tmp';
+
+var TESTDIR = sprintf('/%s/stor/node-manta-test-mput-%s',
+    process.env.MANTA_USER || 'admin',
+    libuuid.v4().split('-')[0]);
+var TESTTREE = [
+    {
+        path: TESTDIR,
+        type: 'directory'
+    }
+];
+
+/*
+ * Create three regular UNIX text files (linefeed separated, with a terminating
+ * linefeed).
+ */
+var i;
+for (i = 1; i <= 3; i++) {
+    TESTTREE.push({
+        path: sprintf('%s/%02d.txt', TESTDIR, i),
+        type: 'object',
+        content: sprintf('%s\nfile (%02d)\n',
+            [ 'first', 'second', 'third' ][i - 1], i)
+    });
+}
+
+/*
+ * Create three data files that contain only a single character.  Of particular
+ * note is the lack of a trailing linefeed.
+ */
+for (i = 1; i <= 3; i++) {
+    TESTTREE.push({
+        path: sprintf('%s/%02d.data', TESTDIR, i),
+        type: 'object',
+        content: sprintf('%s', String.fromCharCode('a'.charCodeAt(0) + i - 1))
+    });
+}
+
+
+// ---- helper functions
+
+function test(name, testfunc) {
+    module.exports[name] = testfunc;
+}
+
+function unlinkIfExists(targ) {
+    try {
+        fs.unlinkSync(targ);
+    } catch (ex) {
+        if (ex.code === 'ENOENT')
+            return;
+
+        throw (ex);
+    }
+}
+
+
+// ---- tests
+
+test('setup: create test tree at ' + TESTDIR, function (t) {
+    var tmpFile = path.join(TMPDIR, 'node-manta-test-tmp-file-' + process.pid);
+
+    vasync.forEachPipeline({
+        inputs: TESTTREE,
+        func: function createTreeItem(item, next) {
+            log.trace({ item: item }, 'create test tree item');
+
+            switch (item.type) {
+            case 'directory':
+                forkExecWait({argv: [MMKDIR, '-p', item.path]}, next);
+                return;
+
+            case 'object':
+                /*
+                 * Would like a 'stdin' option to `forkExecWait`. For now I'll
+                 * quick hack with a local file. An alternative would be
+                 * to use the manta client.
+                 */
+                vasync.pipeline({ funcs: [
+                    function mkTmpFile(_, next2) {
+                        fs.writeFile(tmpFile, item.content, next2);
+                    }
+                ]}, next);
+                return;
+
+            default:
+                t.ifError(new Error('invalid test tree type: ' + item.type));
+                return;
+            }
+        }
+    }, function (err) {
+        t.ifError(err, err);
+        t.done();
+    });
+});
+
+
+/*
+ * Put a file with a custom header whose value include colons. This verifies the
+ * fix for https://github.com/joyent/node-manta/issues/312.
+ */
+test('mput with custom header value with colons', function (t) {
+    // Expect the header to include the full timestamp including the colons
+    var expectedHeader = 'm-start-time: 2017-06-30T18:18:18Z';
+
+    var tmpFile = path.join(TMPDIR, 'node-manta-test-tmp-file-' + process.pid);
+
+    var argv1 = [
+        MPUT,
+        '-H',
+        sprintf('%s', expectedHeader),
+        '-f',
+        sprintf('%s', tmpFile),
+        sprintf('%s/%02d.data', TESTDIR, 1)
+    ];
+
+    var argv2 = [
+        MINFO,
+        sprintf('%s/%02d.data', TESTDIR, 1)
+    ];
+
+    forkExecWait({
+        argv: argv1
+    }, function (err, info) {
+        t.ifError(err, err);
+
+        t.equal(info.stderr, '', 'no stderr');
+
+        forkExecWait({
+          argv: argv2
+        }, function (err2, info2) {
+            t.ifError(err2, err2);
+            t.equal(info2.stderr, '', 'no stderr');
+
+            var headerIndex = info2.stdout.indexOf(expectedHeader);
+            t.notEqual(headerIndex -1, 'minfo response contains header');
+
+            t.done();
+        });
+    });
+});
+
+
+test('cleanup: rm test tree ' + TESTDIR, function (t) {
+    // Sanity checks that we don't `mrm -r` a non-test dir.
+    assert.ok(TESTDIR);
+    assert.ok(TESTDIR.indexOf('node-manta-test') !== -1);
+
+    forkExecWait({ argv: [ MRM, '-r', TESTDIR ]}, function (err) {
+        t.ifError(err, err);
+        t.done();
+    });
+});
+
+
+test('cleanup: rm tmp directory ' + TMPDIR, function (t) {
+    var tmpFile = path.join(TMPDIR, 'node-manta-test-tmp-file-' + process.pid);
+
+    unlinkIfExists(tmpFile);
+
+    t.done();
+});
