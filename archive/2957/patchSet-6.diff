From 5876d6252d35b894b137db5b6f6963ed98410a76 Mon Sep 17 00:00:00 2001
From: Alex Wilson <alex.wilson@joyent.com>
Date: Thu, 16 Nov 2017 15:31:29 -0800
Subject: [PATCH] joyent/node-watershed#5 Want support for negotiating
 sub-protocols

---
 CHANGES.md       |  5 ++++
 README.md        | 20 ++++++++++++-
 lib/watershed.js | 60 +++++++++++++++++++++++++++++++++-----
 package.json     |  2 +-
 test/basic.js    | 75 +++++++++++++++++++++++++++++++++++++++++++++---
 5 files changed, 149 insertions(+), 13 deletions(-)

diff --git a/CHANGES.md b/CHANGES.md
index aa6bbed..9651e6f 100644
--- a/CHANGES.md
+++ b/CHANGES.md
@@ -2,6 +2,11 @@
 
 ## not yet released
 
+## 0.4.0
+
+* Support for Websocket sub-protocol negotiation
+* Documented `detached`/raw socket argument to `accept()`
+
 ## 0.3.4
 
 * Receiving a ping would crash the WatershedConnection while trying to
diff --git a/README.md b/README.md
index ea7fd92..0e96daf 100644
--- a/README.md
+++ b/README.md
@@ -11,7 +11,7 @@ peculiarities, curiosities, and fallback mechanisms.
 The core of this library is a Factory-style class `Watershed`.  It has several
 static methods:
 
-#### Watershed.accept(http.ServerRequest, net.Socket, Buffer)
+#### Watershed.accept(http.ServerRequest, net.Socket, Buffer[, Boolean[, String[] ]])
 
 Responds to a client's request to Upgrade an HTTP connection to a WebSocket and
 returns a `WatershedConnection`, which is also an `EventEmitter`.
@@ -41,6 +41,19 @@ srv.on('upgrade', function(req, socket, head) {
 });
 ```
 
+The additional penultimate boolean argument may be used when implementing a
+websocket-to-websocket proxy.  If set to `true`, then `accept()` returns the
+raw underlying `Socket` of the connection and does not construct a
+`WatershedConnection` instance.  No event handlers will be placed on the
+socket, meaning you are free to continue using it directly (e.g. calling
+`pipe()` on it to join it to a backend socket).
+
+The final list-of-strings argument can be optionally provided to allow for the
+use of WebSocket subprotocol negotiation.  It is a list of case-sensitive
+string names of supported subprotocols.  If given, and protocol negotiation
+takes place, the chosen subprotocol can be found with the `getProtocol()`
+method.
+
 #### Watershed.generateKey()
 
 Returns a random, Base64-encoded 16-byte value suitable for use as the
@@ -120,6 +133,11 @@ responds with a PONG frame for each inbound PING frame.
 Emitted for each inbound PONG frame.  The only argument will be a `Buffer`
 containing the nonce in the pong response.
 
+#### WatershedConnection.getProtocol()
+
+Returns the negotiated subprotocol, if any, for this connection, as a String.
+If no subprotocol negotiation took place, this method returns `null`.
+
 #### WatershedConnection.send(data)
 
 Sends a frame through the socket.  The single argument `data` may be a
diff --git a/lib/watershed.js b/lib/watershed.js
index fd58fdc..d55dedb 100644
--- a/lib/watershed.js
+++ b/lib/watershed.js
@@ -59,15 +59,19 @@ _sha1(str)
 
 
 function
-_generateResponse(wskey)
+_generateResponse(wskey, proto)
 {
 	var wsaccept = _sha1(wskey + MAGIC_WEBSOCKET_UUID);
-	return ([
+	var lines = [
 		'HTTP/1.1 101 The Watershed Moment',
 		'Upgrade: websocket',
 		'Connection: Upgrade',
 		'Sec-WebSocket-Accept: ' + wsaccept
-	].join('\r\n') + '\r\n\r\n');
+	];
+	if (proto !== undefined) {
+		lines.push('Sec-WebSocket-Protocol: ' + proto);
+	}
+	return (lines.join('\r\n') + '\r\n\r\n');
 }
 
 function
@@ -136,7 +140,7 @@ generateKey()
  *    'pong':   a PONG frame arrived; (parameter will be a nonce Buffer.)
  */
 Watershed.prototype.accept = function
-accept(req, socket, head, detached)
+accept(req, socket, head, detached, protocols)
 {
 	var remote = socket.remoteAddress + ':' + socket.remotePort;
 	var local = socket.localAddress + ':' + socket.localPort;
@@ -161,11 +165,34 @@ accept(req, socket, head, detached)
 	if (wsver && wsver !== '13')
 		throw (new Error('Unsupported Sec-WebSocket-Version'));
 
+	var proto;
+	var supported = {};
+	var protoHead = req.headers['sec-websocket-protocol'];
+	if (protoHead && protocols) {
+		protocols.forEach(function (pr) {
+			supported[pr] = true;
+		});
+		var protosWanted = protoHead.split(/, */g);
+		for (var i = 0; i < protosWanted.length; ++i) {
+			if (supported[protosWanted[i]]) {
+				proto = protosWanted[i];
+				break;
+			}
+		}
+		if (proto === undefined) {
+			throw (new Error('Client and server have no matching ' +
+			    'sub-protocols'));
+		}
+	} else if (protoHead) {
+		throw (new Error('Client requested a sub-protocol but no ' +
+		    'supported sub-protocols were provided to accept()'));
+	}
+
 	/*
 	 * Write the response that lets the client know we've accepted the
 	 * Upgrade to WebSockets:
 	 */
-	socket.write(_generateResponse(wskey));
+	socket.write(_generateResponse(wskey, proto));
 
 	if (detached === true) {
 		/*
@@ -179,7 +206,8 @@ accept(req, socket, head, detached)
 		localShouldMask: false,
 		type: 'accept',
 		remote: remote,
-		local: local
+		local: local,
+		protocol: proto
 	};
 	return (new WatershedConnection(options, socket));
 };
@@ -206,6 +234,8 @@ connect(res, socket, head, wskey, detached)
 	/*
 	 * Check for the requisite headers in the Upgrade response:
 	 */
+	if (res.statusCode !== 101)
+		throw (new Error('Invalid Upgrade status code'));
 	var connection = res.headers['connection'];
 	if (!connection || connection.toLowerCase() !== 'upgrade')
 		throw (new Error('Missing Connection Header'));
@@ -218,6 +248,7 @@ connect(res, socket, head, wskey, detached)
 	var wsver = res.headers['sec-websocket-version'];
 	if (wsver && wsver !== '13')
 		throw (new Error('Unsupported Sec-WebSocket-Version'));
+	var proto = res.headers['sec-websocket-protocol'];
 
 	if (detached === true) {
 		/*
@@ -231,7 +262,8 @@ connect(res, socket, head, wskey, detached)
 		localShouldMask: true,
 		type: 'connect',
 		remote: remote,
-		local: local
+		local: local,
+		protocol: proto
 	};
 	return (new WatershedConnection(options, socket));
 };
@@ -264,6 +296,9 @@ WatershedConnection(options, socket)
 	self._socket = socket;
 	self._remote = options.remote;
 	self._local = options.local;
+	self._proto = null;
+	if (options.protocol)
+		self._proto = options.protocol;
 
 	self._check_for_http_header = true;
 
@@ -353,6 +388,17 @@ WatershedConnection(options, socket)
 }
 util.inherits(WatershedConnection, EventEmitter);
 
+/*
+ * Public: WatershedConnection.getProtocol()
+ *
+ * Returns the negotiated sub-protocol chosen during accept().
+ */
+WatershedConnection.prototype.getProtocol = function
+getProtocol()
+{
+	return (this._proto);
+};
+
 /*
  * Public: WatershedConnection.end(reason)
  *
diff --git a/package.json b/package.json
index 8fd91a3..71b96b2 100644
--- a/package.json
+++ b/package.json
@@ -1,6 +1,6 @@
 {
 	"name": "watershed",
-	"version": "0.3.4",
+	"version": "0.4.0",
 	"description": "simple websockets (RFC6455) client and server",
 	"main": "./lib/watershed.js",
 	"author": "Joshua M. Clulow <jmc@joyent.com>",
diff --git a/test/basic.js b/test/basic.js
index f500260..32a5e5a 100644
--- a/test/basic.js
+++ b/test/basic.js
@@ -12,7 +12,7 @@ var wskey = shed.generateKey();
 var CLIENT;
 var HTTP;
 var SERVER;
-
+var SERVER_ERR;
 
 function failOnMessage(msg) {
 	throw new Error('received unexpected message: ' + msg.toString());
@@ -29,7 +29,14 @@ test('setup server', function (t) {
 	HTTP = http.createServer();
 	HTTP.listen(9554);
 	HTTP.on('upgrade', function (req, socket, head) {
-		SERVER = shed.accept(req, socket, head);
+		try {
+			SERVER = shed.accept(req, socket, head, false,
+			    ['test1', 'test2']);
+		} catch (err) {
+			socket.end('HTTP/1.1 400 Bad Request\r\n' +
+			    'Connection: close\r\n\r\n');
+			return;
+		}
 		SERVER.on('text', failOnMessage);
 		SERVER.on('binary', failOnMessage);
 		SERVER.on('end', failOnEnd);
@@ -53,6 +60,8 @@ test('setup client', function (t) {
 	req.on('upgrade', function (res, socket, head) {
 		socket.setNoDelay(true);
 		CLIENT = shed.connect(res, socket, head, wskey);
+		t.strictEqual(CLIENT.getProtocol(), null);
+		t.strictEqual(SERVER.getProtocol(), null);
 		CLIENT.on('text', failOnMessage);
 		CLIENT.on('binary', failOnMessage);
 		CLIENT.on('end', failOnEnd);
@@ -137,16 +146,74 @@ test('server sends BINARY', function (t) {
 	SERVER.send(new Buffer('hello'));
 });
 
-test('teardown', function (t) {
+test('teardown connection', function (t) {
 	CLIENT.removeListener('end', failOnEnd);
 	SERVER.removeListener('end', failOnEnd);
 
 	CLIENT.on('end', function (code, reason) {
 		t.equal(code, 'NORMAL', 'normal close');
 		t.equal(reason, 'test ended', 'server sent reason');
-		HTTP.close();
 		t.end();
 	});
 
 	SERVER.end('test ended');
+
+	CLIENT = null;
+	SERVER = null;
+});
+
+test('negotiate supported subprotocol', function (t) {
+	var options = {
+		port: 9554,
+		hostname: '127.0.0.1',
+		headers: {
+			'connection': 'upgrade',
+			'upgrade': 'websocket',
+			'Sec-WebSocket-Key': wskey,
+			'Sec-WebSocket-Version': 13,
+			'Sec-WebSocket-Protocol': 'foobar, test1, test2'
+		}
+	};
+	var req = http.request(options);
+	req.end();
+	req.on('upgrade', function (res, socket, head) {
+		socket.setNoDelay(true);
+		var client = shed.connect(res, socket, head, wskey);
+		t.strictEqual(client.getProtocol(), 'test1');
+		t.strictEqual(SERVER.getProtocol(), 'test1');
+
+		SERVER.removeListener('end', failOnEnd);
+		SERVER.once('end', function () {
+			t.end();
+		});
+		client.end('done');
+	});
+});
+
+test('negotiation failure', function (t) {
+	var options = {
+		port: 9554,
+		hostname: '127.0.0.1',
+		headers: {
+			'connection': 'upgrade',
+			'upgrade': 'websocket',
+			'Sec-WebSocket-Key': wskey,
+			'Sec-WebSocket-Version': 13,
+			'Sec-WebSocket-Protocol': 'foobar, aaaa'
+		}
+	};
+	var req = http.request(options);
+	req.end();
+	req.on('upgrade', function (res, socket, head) {
+		t.fail();
+	});
+	req.on('response', function (res) {
+		t.equal(res.statusCode, 400);
+		t.end();
+	});
+});
+
+test('teardown server', function (t) {
+	HTTP.close();
+	t.end();
 });
-- 
2.21.0

