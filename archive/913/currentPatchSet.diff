From f4bb6bab0dfe865ae551cc908e245bc8440a75d9 Mon Sep 17 00:00:00 2001
From: "Joshua M. Clulow" <jmc@joyent.com>
Date: Mon, 5 Dec 2016 16:58:16 -0800
Subject: [PATCH] OS-5799 Smart Array firmware 8.00 does not work with MSI
 OS-5800 identify and record firmware version of Smart Array controllers
 Reviewed by: Robert Mustacchi <rm@joyent.com> Approved by: Patrick Mooney
 <patrick.mooney@joyent.com>

---
 .../uts/common/io/scsi/adapters/smrt/smrt.c   |  15 +-
 .../common/io/scsi/adapters/smrt/smrt_ciss.c  | 185 +++++++++++++++++-
 .../io/scsi/adapters/smrt/smrt_ciss_simple.c  |  70 +++++++
 .../io/scsi/adapters/smrt/smrt_commands.c     |  78 ++++++--
 .../io/scsi/adapters/smrt/smrt_interrupts.c   |  51 ++++-
 .../io/scsi/adapters/smrt/smrt_logvol.c       |   7 +-
 .../uts/common/sys/scsi/adapters/smrt/smrt.h  |  25 ++-
 .../common/sys/scsi/adapters/smrt/smrt_scsi.h |  57 +++++-
 8 files changed, 452 insertions(+), 36 deletions(-)

diff --git a/usr/src/uts/common/io/scsi/adapters/smrt/smrt.c b/usr/src/uts/common/io/scsi/adapters/smrt/smrt.c
index fa925395b7..b182d1dab3 100644
--- a/usr/src/uts/common/io/scsi/adapters/smrt/smrt.c
+++ b/usr/src/uts/common/io/scsi/adapters/smrt/smrt.c
@@ -170,6 +170,8 @@ smrt_attach(dev_info_t *dip, ddi_attach_cmd_t cmd)
 {
 	uint32_t instance;
 	smrt_t *smrt;
+	boolean_t check_for_interrupts = B_FALSE;
+	int r;
 
 	if (cmd != DDI_ATTACH) {
 		return (DDI_FAILURE);
@@ -281,6 +283,7 @@ smrt_attach(dev_info_t *dip, ddi_attach_cmd_t cmd)
 	 * command completion interrupts from the controller.
 	 */
 	smrt_intr_set(smrt, B_TRUE);
+	check_for_interrupts = B_TRUE;
 
 	/*
 	 * Register the maintenance routine for periodic execution:
@@ -292,8 +295,10 @@ smrt_attach(dev_info_t *dip, ddi_attach_cmd_t cmd)
 	/*
 	 * Discover the set of logical volumes attached to this controller:
 	 */
-	if (smrt_logvol_discover(smrt, SMRT_LOGVOL_DISCOVER_TIMEOUT) != 0) {
-		dev_err(dip, CE_WARN, "could not discover logical volumes");
+	if ((r = smrt_logvol_discover(smrt, SMRT_LOGVOL_DISCOVER_TIMEOUT)) !=
+	    0) {
+		dev_err(dip, CE_WARN, "could not discover logical volumes "
+		    "(%d)", r);
 		goto fail;
 	}
 
@@ -305,6 +310,12 @@ smrt_attach(dev_info_t *dip, ddi_attach_cmd_t cmd)
 	return (DDI_SUCCESS);
 
 fail:
+	if (check_for_interrupts) {
+		if (smrt->smrt_stats.smrts_claimed_interrupts == 0) {
+			dev_err(dip, CE_WARN, "controller did not interrupt "
+			    "during attach");
+		}
+	}
 	smrt_cleanup(smrt);
 	return (DDI_FAILURE);
 }
diff --git a/usr/src/uts/common/io/scsi/adapters/smrt/smrt_ciss.c b/usr/src/uts/common/io/scsi/adapters/smrt/smrt_ciss.c
index 99b396c0e4..9de93fda45 100644
--- a/usr/src/uts/common/io/scsi/adapters/smrt/smrt_ciss.c
+++ b/usr/src/uts/common/io/scsi/adapters/smrt/smrt_ciss.c
@@ -15,6 +15,8 @@
 
 #include <sys/scsi/adapters/smrt/smrt.h>
 
+static int smrt_ctlr_versions(smrt_t *, uint16_t, smrt_versions_t *);
+
 /*
  * The maximum number of seconds to wait for the controller to come online.
  */
@@ -265,6 +267,7 @@ int
 smrt_submit(smrt_t *smrt, smrt_command_t *smcm)
 {
 	VERIFY(MUTEX_HELD(&smrt->smrt_mutex));
+	VERIFY(smcm->smcm_type != SMRT_CMDTYPE_PREINIT);
 
 	/*
 	 * If the controller is currently being reset, do not allow command
@@ -373,6 +376,11 @@ smrt_process_finishq_one(smrt_command_t *smcm)
 		smrt_command_free(smcm);
 		mutex_enter(&smrt->smrt_mutex);
 		return;
+
+	case SMRT_CMDTYPE_PREINIT:
+		dev_err(smrt->smrt_dip, CE_PANIC, "preinit command "
+		    "completed after initialisation");
+		return;
 	}
 
 	panic("unknown command type");
@@ -760,7 +768,7 @@ smrt_ctlr_init(smrt_t *smrt)
 	 * Initialise an appropriate Transport Method.  For now, this driver
 	 * only supports the "Simple" method.
 	 */
-	if ((e = smrt_ctlr_init_simple(smrt)) != 0) {
+	if ((e = smrt_ctlr_init_simple(smrt)) != DDI_SUCCESS) {
 		return (e);
 	}
 
@@ -779,6 +787,20 @@ smrt_ctlr_init(smrt_t *smrt)
 	    &smrt->smrt_ct->HeartBeat);
 	smrt->smrt_last_heartbeat_time = gethrtime();
 
+	/*
+	 * Determine the firmware version of the controller so that we can
+	 * select which type of interrupts to use.
+	 */
+	if ((e = smrt_ctlr_versions(smrt, SMRT_LOGVOL_DISCOVER_TIMEOUT,
+	    &smrt->smrt_versions)) != 0) {
+		dev_err(smrt->smrt_dip, CE_WARN, "could not identify "
+		    "controller (%d)", e);
+		return (DDI_FAILURE);
+	}
+
+	dev_err(smrt->smrt_dip, CE_NOTE, "!firmware rev %s",
+	    smrt->smrt_versions.smrtv_firmware_rev);
+
 	return (DDI_SUCCESS);
 }
 
@@ -900,6 +922,167 @@ smrt_lockup_check(smrt_t *smrt)
 	}
 }
 
+/*
+ * Probe the controller with the IDENTIFY CONTROLLER request.  This is a BMIC
+ * command, so it must be submitted to the controller and we must poll for its
+ * completion.  This functionality is only presently used during controller
+ * initialisation, so it uses the special pre-initialisation path for command
+ * allocation and submission.
+ */
+static int
+smrt_ctlr_identify(smrt_t *smrt, uint16_t timeout,
+    smrt_identify_controller_t *resp)
+{
+	smrt_command_t *smcm;
+	smrt_identify_controller_req_t smicr;
+	int r;
+	size_t sz;
+
+	/*
+	 * Allocate a command with a data buffer; the controller will fill it
+	 * with identification information.  There is some suggestion in the
+	 * firmware-level specification that the buffer length should be a
+	 * multiple of 512 bytes for some controllers, so we round up.
+	 */
+	sz = P2ROUNDUP_TYPED(sizeof (*resp), 512, size_t);
+	if ((smcm = smrt_command_alloc_preinit(smrt, sz, KM_SLEEP)) == NULL) {
+		return (ENOMEM);
+	}
+
+	/*
+	 * This BMIC command is addressed to the controller itself.  The
+	 * Masked Peripheral Device addressing mode is used, with a LUN of 0.
+	 */
+	smrt_write_lun_addr_phys(&smcm->smcm_va_cmd->Header.LUN, B_TRUE,
+	    0, 0);
+
+	smcm->smcm_va_cmd->Request.CDBLen = sizeof (smicr);
+	smcm->smcm_va_cmd->Request.Timeout = timeout;
+	smcm->smcm_va_cmd->Request.Type.Type = CISS_TYPE_CMD;
+	smcm->smcm_va_cmd->Request.Type.Attribute = CISS_ATTR_ORDERED;
+	smcm->smcm_va_cmd->Request.Type.Direction = CISS_XFER_READ;
+
+	/*
+	 * Construct the IDENTIFY CONTROLLER request CDB.  Note that any
+	 * reserved fields in the request must be filled with zeroes.
+	 */
+	bzero(&smicr, sizeof (smicr));
+	smicr.smicr_opcode = CISS_SCMD_BMIC_READ;
+	smicr.smicr_lun = 0;
+	smicr.smicr_command = CISS_BMIC_IDENTIFY_CONTROLLER;
+	bcopy(&smicr, &smcm->smcm_va_cmd->Request.CDB[0],
+	    MIN(CISS_CDBLEN, sizeof (smicr)));
+
+	/*
+	 * Send the command to the device and poll for its completion.
+	 */
+	smcm->smcm_status |= SMRT_CMD_STATUS_POLLED;
+	smcm->smcm_expiry = gethrtime() + timeout * NANOSEC;
+	if ((r = smrt_preinit_command_simple(smrt, smcm)) != 0) {
+		VERIFY3S(r, ==, ETIMEDOUT);
+		VERIFY0(smcm->smcm_status & SMRT_CMD_STATUS_POLL_COMPLETE);
+
+		/*
+		 * This command timed out, but the driver is not presently
+		 * initialised to the point where we can try to abort it.
+		 * The command was created with the PREINIT type, so it
+		 * does not appear in the global command tracking list.
+		 * In order to avoid problems with DMA from the controller,
+		 * we have to leak the command allocation.
+		 */
+		smcm = NULL;
+		goto out;
+	}
+
+	if (smcm->smcm_status & SMRT_CMD_STATUS_RESET_SENT) {
+		/*
+		 * The controller was reset while we were trying to identify
+		 * it.  Report failure.
+		 */
+		r = EIO;
+		goto out;
+	}
+
+	if (smcm->smcm_status & SMRT_CMD_STATUS_ERROR) {
+		ErrorInfo_t *ei = smcm->smcm_va_err;
+
+		if (ei->CommandStatus != CISS_CMD_DATA_UNDERRUN) {
+			dev_err(smrt->smrt_dip, CE_WARN, "identify "
+			    "controller error: status 0x%x",
+			    ei->CommandStatus);
+			r = EIO;
+			goto out;
+		}
+	}
+
+	if (resp != NULL) {
+		/*
+		 * Copy the identify response out for the caller.
+		 */
+		bcopy(smcm->smcm_internal->smcmi_va, resp, sizeof (*resp));
+	}
+
+	r = 0;
+
+out:
+	if (smcm != NULL) {
+		smrt_command_free(smcm);
+	}
+	return (r);
+}
+
+/*
+ * The firmware versions in an IDENTIFY CONTROLLER response generally take
+ * the form of a four byte ASCII string containing a dotted decimal version
+ * number; e.g., "8.00".
+ *
+ * This function sanitises the firmware version, replacing unexpected
+ * values with a question mark.
+ */
+static void
+smrt_copy_firmware_version(uint8_t *src, char *dst)
+{
+	for (unsigned i = 0; i < 4; i++) {
+		/*
+		 * Make sure that this is a 7-bit clean ASCII value.
+		 */
+		char c = src[i] <= 0x7f ? (char)(src[i] & 0x7f) : '?';
+
+		if (isalnum(c) || c == '.' || c == ' ') {
+			dst[i] = c;
+		} else {
+			dst[i] = '?';
+		}
+	}
+	dst[4] = '\0';
+}
+
+/*
+ * Using an IDENTIFY CONTROLLER request, determine firmware and controller
+ * version details.  See the comments for "smrt_ctlr_identify()" for more
+ * details about calling context.
+ */
+static int
+smrt_ctlr_versions(smrt_t *smrt, uint16_t timeout, smrt_versions_t *smrtv)
+{
+	smrt_identify_controller_t smic;
+	int r;
+
+	if ((r = smrt_ctlr_identify(smrt, timeout, &smic)) != 0) {
+		return (r);
+	}
+
+	smrtv->smrtv_hardware_version = smic.smic_hardware_version;
+	smrt_copy_firmware_version(smic.smic_firmware_rev,
+	    smrtv->smrtv_firmware_rev);
+	smrt_copy_firmware_version(smic.smic_recovery_rev,
+	    smrtv->smrtv_recovery_rev);
+	smrt_copy_firmware_version(smic.smic_bootblock_rev,
+	    smrtv->smrtv_bootblock_rev);
+
+	return (0);
+}
+
 int
 smrt_ctlr_reset(smrt_t *smrt)
 {
diff --git a/usr/src/uts/common/io/scsi/adapters/smrt/smrt_ciss_simple.c b/usr/src/uts/common/io/scsi/adapters/smrt/smrt_ciss_simple.c
index a84c7597cc..1b3d7b2602 100644
--- a/usr/src/uts/common/io/scsi/adapters/smrt/smrt_ciss_simple.c
+++ b/usr/src/uts/common/io/scsi/adapters/smrt/smrt_ciss_simple.c
@@ -119,6 +119,76 @@ smrt_submit_simple(smrt_t *smrt, smrt_command_t *smcm)
 	smrt_put32(smrt, CISS_I2O_INBOUND_POST_Q, smcm->smcm_pa_cmd);
 }
 
+/*
+ * Submit a command to the controller by posting it to the Inbound Post Queue
+ * Register.  Immediately begin polling on the completion of that command.
+ *
+ * NOTE: This function is for controller initialisation only.  It discards
+ * completions of commands other than the expected command as spurious, and
+ * will not interact correctly with the rest of the driver once it is running.
+ */
+int
+smrt_preinit_command_simple(smrt_t *smrt, smrt_command_t *smcm)
+{
+	/*
+	 * The controller must be initialised to use the Simple Transport
+	 * Method, but not be marked RUNNING.  The command to process must be a
+	 * PREINIT command with the expected tag number, marked for polling.
+	 */
+	VERIFY(smrt->smrt_ctlr_mode == SMRT_CTLR_MODE_SIMPLE);
+	VERIFY(!(smrt->smrt_status & SMRT_CTLR_STATUS_RUNNING));
+	VERIFY(smcm->smcm_type == SMRT_CMDTYPE_PREINIT);
+	VERIFY(smcm->smcm_status & SMRT_CMD_STATUS_POLLED);
+	VERIFY3U(smcm->smcm_tag, ==, SMRT_PRE_TAG_NUMBER);
+
+	/*
+	 * Submit this command to the controller.
+	 */
+	smcm->smcm_status |= SMRT_CMD_STATUS_INFLIGHT;
+	smrt_put32(smrt, CISS_I2O_INBOUND_POST_Q, smcm->smcm_pa_cmd);
+
+	/*
+	 * Poll the controller for completions until we see the command we just
+	 * sent, or the timeout expires.
+	 */
+	for (;;) {
+		uint32_t none = 0xffffffff;
+		uint32_t opq = smrt_get32(smrt, CISS_I2O_OUTBOUND_POST_Q);
+		uint32_t tag;
+
+		if (smcm->smcm_expiry != 0) {
+			/*
+			 * This command has an expiry time.  Check to see
+			 * if it has already passed:
+			 */
+			if (smcm->smcm_expiry < gethrtime()) {
+				return (ETIMEDOUT);
+			}
+		}
+
+		if (opq == none) {
+			delay(drv_usectohz(10 * 1000));
+			continue;
+		}
+
+		if ((tag = CISS_OPQ_READ_TAG(opq)) != SMRT_PRE_TAG_NUMBER) {
+			dev_err(smrt->smrt_dip, CE_WARN, "unexpected tag 0x%x"
+			    " completed during driver init", tag);
+			delay(drv_usectohz(10 * 1000));
+			continue;
+		}
+
+		smcm->smcm_status &= ~SMRT_CMD_STATUS_INFLIGHT;
+		if (CISS_OPQ_READ_ERROR(opq) != 0) {
+			smcm->smcm_status |= SMRT_CMD_STATUS_ERROR;
+		}
+		smcm->smcm_time_complete = gethrtime();
+		smcm->smcm_status |= SMRT_CMD_STATUS_POLL_COMPLETE;
+
+		return (0);
+	}
+}
+
 int
 smrt_ctlr_init_simple(smrt_t *smrt)
 {
diff --git a/usr/src/uts/common/io/scsi/adapters/smrt/smrt_commands.c b/usr/src/uts/common/io/scsi/adapters/smrt/smrt_commands.c
index 914e7b926a..d4b658e0c8 100644
--- a/usr/src/uts/common/io/scsi/adapters/smrt/smrt_commands.c
+++ b/usr/src/uts/common/io/scsi/adapters/smrt/smrt_commands.c
@@ -46,14 +46,6 @@ static ddi_device_acc_attr_t smrt_command_dev_attr = {
 static void smrt_contig_free(smrt_dma_t *);
 
 
-extern __GNU_INLINE size_t
-smrt_round_up(size_t offset)
-{
-	size_t gran = 0x20;
-
-	return ((offset + (gran - 1)) & ~(gran - 1));
-}
-
 static int
 smrt_check_command_type(smrt_command_type_t type)
 {
@@ -65,6 +57,7 @@ smrt_check_command_type(smrt_command_type_t type)
 	case SMRT_CMDTYPE_ABORTQ:
 	case SMRT_CMDTYPE_SCSA:
 	case SMRT_CMDTYPE_INTERNAL:
+	case SMRT_CMDTYPE_PREINIT:
 		return (type);
 	}
 
@@ -155,8 +148,8 @@ smrt_contig_free(smrt_dma_t *smdma)
 	bzero(smdma, sizeof (*smdma));
 }
 
-smrt_command_t *
-smrt_command_alloc(smrt_t *smrt, smrt_command_type_t type, int kmflags)
+static smrt_command_t *
+smrt_command_alloc_impl(smrt_t *smrt, smrt_command_type_t type, int kmflags)
 {
 	smrt_command_t *smcm;
 
@@ -175,10 +168,10 @@ smrt_command_alloc(smrt_t *smrt, smrt_command_type_t type, int kmflags)
 	 * physical address of each block should be 32-byte aligned.
 	 */
 	size_t contig_size = 0;
-	contig_size += smrt_round_up(sizeof (CommandList_t));
+	contig_size += P2ROUNDUP_TYPED(sizeof (CommandList_t), 32, size_t);
 
 	size_t errorinfo_offset = contig_size;
-	contig_size += smrt_round_up(sizeof (ErrorInfo_t));
+	contig_size += P2ROUNDUP_TYPED(sizeof (ErrorInfo_t), 32, size_t);
 
 	if (smrt_contig_alloc(smrt, &smcm->smcm_contig, contig_size,
 	    kmflags, (void **)&smcm->smcm_va_cmd, &smcm->smcm_pa_cmd) !=
@@ -204,6 +197,47 @@ smrt_command_alloc(smrt_t *smrt, smrt_command_type_t type, int kmflags)
 	smcm->smcm_va_cmd->ErrDesc.Addr = smcm->smcm_pa_err;
 	smcm->smcm_va_cmd->ErrDesc.Len = sizeof (ErrorInfo_t);
 
+	return (smcm);
+}
+
+smrt_command_t *
+smrt_command_alloc_preinit(smrt_t *smrt, size_t datasize, int kmflags)
+{
+	smrt_command_t *smcm;
+
+	if ((smcm = smrt_command_alloc_impl(smrt, SMRT_CMDTYPE_PREINIT,
+	    kmflags)) == NULL) {
+		return (NULL);
+	}
+
+	/*
+	 * Note that most driver infrastructure has not been initialised at
+	 * this time.  All commands are submitted to the controller serially,
+	 * using a pre-specified tag, and are not attached to the command
+	 * tracking list.
+	 */
+	smcm->smcm_tag = SMRT_PRE_TAG_NUMBER;
+	smcm->smcm_va_cmd->Header.Tag.tag_value = SMRT_PRE_TAG_NUMBER;
+
+	if (smrt_command_attach_internal(smrt, smcm, datasize, kmflags) != 0) {
+		smrt_command_free(smcm);
+		return (NULL);
+	}
+
+	return (smcm);
+}
+
+smrt_command_t *
+smrt_command_alloc(smrt_t *smrt, smrt_command_type_t type, int kmflags)
+{
+	smrt_command_t *smcm;
+
+	VERIFY(type != SMRT_CMDTYPE_PREINIT);
+
+	if ((smcm = smrt_command_alloc_impl(smrt, type, kmflags)) == NULL) {
+		return (NULL);
+	}
+
 	/*
 	 * Insert into the per-controller command list.
 	 */
@@ -295,18 +329,20 @@ smrt_command_free(smrt_command_t *smcm)
 
 	smrt_contig_free(&smcm->smcm_contig);
 
-	mutex_enter(&smrt->smrt_mutex);
+	if (smcm->smcm_type != SMRT_CMDTYPE_PREINIT) {
+		mutex_enter(&smrt->smrt_mutex);
 
-	/*
-	 * Ensure we are not trying to free a command that is in the finish or
-	 * abort queue.
-	 */
-	VERIFY(!list_link_active(&smcm->smcm_link_abort));
-	VERIFY(!list_link_active(&smcm->smcm_link_finish));
+		/*
+		 * Ensure we are not trying to free a command that is in the
+		 * finish or abort queue.
+		 */
+		VERIFY(!list_link_active(&smcm->smcm_link_abort));
+		VERIFY(!list_link_active(&smcm->smcm_link_finish));
 
-	list_remove(&smrt->smrt_commands, smcm);
+		list_remove(&smrt->smrt_commands, smcm);
 
-	mutex_exit(&smrt->smrt_mutex);
+		mutex_exit(&smrt->smrt_mutex);
+	}
 
 	kmem_free(smcm, sizeof (*smcm));
 }
diff --git a/usr/src/uts/common/io/scsi/adapters/smrt/smrt_interrupts.c b/usr/src/uts/common/io/scsi/adapters/smrt/smrt_interrupts.c
index 84d38184aa..9e1ee9c2cd 100644
--- a/usr/src/uts/common/io/scsi/adapters/smrt/smrt_interrupts.c
+++ b/usr/src/uts/common/io/scsi/adapters/smrt/smrt_interrupts.c
@@ -30,6 +30,32 @@ smrt_interrupt_type_name(int type)
 	}
 }
 
+static boolean_t
+smrt_try_msix(smrt_t *smrt)
+{
+	char *fwver = smrt->smrt_versions.smrtv_firmware_rev;
+
+	if (fwver[0] == '8' && fwver[1] == '.' && isdigit(fwver[2]) &&
+	    isdigit(fwver[3])) {
+		/*
+		 * Version 8.00 of the Smart Array firmware appears to have
+		 * broken MSI support on at least one controller.  We could
+		 * blindly try MSI-X everywhere, except that on at least some
+		 * 6.XX firmware versions, MSI-X interrupts do not appear
+		 * to be triggered for Simple Transport Method command
+		 * completions.
+		 *
+		 * For now, assume we should try for MSI-X with all 8.XX
+		 * versions of the firmware.
+		 */
+		dev_err(smrt->smrt_dip, CE_NOTE, "!trying MSI-X interrupts "
+		    "to work around 8.XX firmware defect");
+		return (B_TRUE);
+	}
+
+	return (B_FALSE);
+}
+
 static int
 smrt_interrupts_disable(smrt_t *smrt)
 {
@@ -146,9 +172,23 @@ smrt_interrupts_setup(smrt_t *smrt)
 	}
 
 	/*
-	 * The specification is somewhat unclear of the precise nature of MSI-X
-	 * support with Smart Array controllers, particularly with respect to
-	 * the Simple Transport Method, so we'll just try for classical MSI.
+	 * At least one firmware version has been released for the Smart Array
+	 * line with entirely defective MSI support.  The specification is
+	 * somewhat unclear on the precise nature of MSI-X support with Smart
+	 * Array controllers, particularly with respect to the Simple Transport
+	 * Method, but for those broken firmware versions we need to try
+	 * anyway.
+	 */
+	if (smrt_try_msix(smrt) && (types & DDI_INTR_TYPE_MSIX)) {
+		if (smrt_interrupts_alloc(smrt, DDI_INTR_TYPE_MSIX) ==
+		    DDI_SUCCESS) {
+			goto add_handler;
+		}
+	}
+
+	/*
+	 * If MSI-X is not available, or not expected to work, fall back to
+	 * MSI.
 	 */
 	if (types & DDI_INTR_TYPE_MSI) {
 		if (smrt_interrupts_alloc(smrt, DDI_INTR_TYPE_MSI) ==
@@ -158,7 +198,10 @@ smrt_interrupts_setup(smrt_t *smrt)
 	}
 
 	/*
-	 * If MSI is not available, fall back to fixed interrupts.
+	 * If neither MSI-X nor MSI is available, fall back to fixed
+	 * interrupts.  Note that the use of fixed interrupts has been
+	 * observed, with some combination of controllers and systems, to
+	 * result in interrupts stopping completely at random times.
 	 */
 	if (types & DDI_INTR_TYPE_FIXED) {
 		if (smrt_interrupts_alloc(smrt, DDI_INTR_TYPE_FIXED) ==
diff --git a/usr/src/uts/common/io/scsi/adapters/smrt/smrt_logvol.c b/usr/src/uts/common/io/scsi/adapters/smrt/smrt_logvol.c
index 67267ecb60..449280d3ca 100644
--- a/usr/src/uts/common/io/scsi/adapters/smrt/smrt_logvol.c
+++ b/usr/src/uts/common/io/scsi/adapters/smrt/smrt_logvol.c
@@ -202,7 +202,7 @@ smrt_logvol_discover(smrt_t *smrt, uint16_t timeout)
 	smrt_write_lun_addr_phys(&smcm->smcm_va_cmd->Header.LUN, B_TRUE,
 	    0, 0);
 
-	smcm->smcm_va_cmd->Request.CDBLen = 12;
+	smcm->smcm_va_cmd->Request.CDBLen = sizeof (smrllr);
 	smcm->smcm_va_cmd->Request.Timeout = timeout;
 	smcm->smcm_va_cmd->Request.Type.Type = CISS_TYPE_CMD;
 	smcm->smcm_va_cmd->Request.Type.Attribute = CISS_ATTR_ORDERED;
@@ -225,8 +225,7 @@ smrt_logvol_discover(smrt_t *smrt, uint16_t timeout)
 	 * Send the command to the device.
 	 */
 	smcm->smcm_status |= SMRT_CMD_STATUS_POLLED;
-	if (smrt_submit(smrt, smcm) != 0) {
-		r = EIO;
+	if ((r = smrt_submit(smrt, smcm)) != 0) {
 		goto out;
 	}
 
@@ -235,7 +234,7 @@ smrt_logvol_discover(smrt_t *smrt, uint16_t timeout)
 	 */
 	smcm->smcm_expiry = gethrtime() + timeout * NANOSEC;
 	if ((r = smrt_poll_for(smrt, smcm)) != 0) {
-		VERIFY(r == ETIMEDOUT);
+		VERIFY3S(r, ==, ETIMEDOUT);
 		VERIFY0(smcm->smcm_status & SMRT_CMD_STATUS_POLL_COMPLETE);
 
 		/*
diff --git a/usr/src/uts/common/sys/scsi/adapters/smrt/smrt.h b/usr/src/uts/common/sys/scsi/adapters/smrt/smrt.h
index e9e381f519..39b6d414b9 100644
--- a/usr/src/uts/common/sys/scsi/adapters/smrt/smrt.h
+++ b/usr/src/uts/common/sys/scsi/adapters/smrt/smrt.h
@@ -33,6 +33,7 @@
 #include <sys/sunddi.h>
 #include <sys/sdt.h>
 #include <sys/policy.h>
+#include <sys/ctype.h>
 
 #if !defined(_LITTLE_ENDIAN) || !defined(_BIT_FIELDS_LTOH)
 /*
@@ -81,9 +82,11 @@ typedef enum smrt_init_level {
  * having the controller confuse us by double-reporting the completion of a
  * particular tag, we try to reuse them as infrequently as possible.  In
  * practice, this means looping through a range of values.  The minimum and
- * maximum value are defined below.
+ * maximum value are defined below.  A single command tag value is set aside
+ * for polled commands sent prior to full initialisation of the driver.
  */
-#define	SMRT_MIN_TAG_NUMBER			0x00000100
+#define	SMRT_PRE_TAG_NUMBER			0x00000bad
+#define	SMRT_MIN_TAG_NUMBER			0x00001000
 #define	SMRT_MAX_TAG_NUMBER			0x0fffffff
 
 /*
@@ -164,6 +167,19 @@ typedef struct smrt_stats {
 	uint64_t smrts_ignored_scsi_cmds;
 } smrt_stats_t;
 
+typedef struct smrt_versions {
+	uint8_t smrtv_hardware_version;
+
+	/*
+	 * These strings must be large enough to hold the 4 byte version string
+	 * retrieved from an IDENTIFY CONTROLLER response, as well as the
+	 * terminating NUL byte:
+	 */
+	char smrtv_firmware_rev[5];
+	char smrtv_recovery_rev[5];
+	char smrtv_bootblock_rev[5];
+} smrt_versions_t;
+
 /*
  * Per-Controller Structure
  */
@@ -181,6 +197,7 @@ struct smrt {
 	uint32_t smrt_bus_support;
 	uint32_t smrt_maxcmds;
 	uint32_t smrt_sg_cnt;
+	smrt_versions_t smrt_versions;
 
 	/*
 	 * The transport mode of the controller.
@@ -419,6 +436,7 @@ typedef enum smrt_command_type {
 	SMRT_CMDTYPE_INTERNAL = 1,
 	SMRT_CMDTYPE_ABORTQ,
 	SMRT_CMDTYPE_SCSA,
+	SMRT_CMDTYPE_PREINIT,
 } smrt_command_type_t;
 
 struct smrt_command {
@@ -501,6 +519,7 @@ void smrt_submit_simple(smrt_t *, smrt_command_t *);
 int smrt_retrieve(smrt_t *);
 void smrt_retrieve_simple(smrt_t *);
 int smrt_poll_for(smrt_t *, smrt_command_t *);
+int smrt_preinit_command_simple(smrt_t *, smrt_command_t *);
 
 /*
  * Interrupt service routines.
@@ -521,7 +540,6 @@ void smrt_intr_set(smrt_t *, boolean_t);
 int smrt_ctlr_init(smrt_t *);
 void smrt_ctlr_teardown(smrt_t *);
 int smrt_ctlr_reset(smrt_t *);
-int smrt_ctlr_ping(smrt_t *, int);
 int smrt_ctlr_wait_for_state(smrt_t *, smrt_wait_state_t);
 int smrt_ctlr_init_simple(smrt_t *);
 void smrt_ctlr_teardown_simple(smrt_t *);
@@ -556,6 +574,7 @@ void smrt_process_abortq(smrt_t *);
  */
 smrt_command_t *smrt_command_alloc(smrt_t *, smrt_command_type_t,
     int);
+smrt_command_t *smrt_command_alloc_preinit(smrt_t *, size_t, int);
 int smrt_command_attach_internal(smrt_t *, smrt_command_t *, size_t,
     int);
 void smrt_command_free(smrt_command_t *);
diff --git a/usr/src/uts/common/sys/scsi/adapters/smrt/smrt_scsi.h b/usr/src/uts/common/sys/scsi/adapters/smrt/smrt_scsi.h
index c6a0665eb1..cca02e4637 100644
--- a/usr/src/uts/common/sys/scsi/adapters/smrt/smrt_scsi.h
+++ b/usr/src/uts/common/sys/scsi/adapters/smrt/smrt_scsi.h
@@ -41,6 +41,15 @@ extern "C" {
 #define	CISS_SCMD_REPORT_LOGICAL_LUNS		0xC2
 #define	CISS_SCMD_REPORT_PHYSICAL_LUNS		0xC3
 
+/*
+ * These command opcodes are _not_ in the usual vendor-specific space, but are
+ * nonetheless vendor-specific.  They allow BMIC commands to be written to and
+ * read from the controller.  If a command transfers no data, the specification
+ * suggests that BMIC_WRITE (0x27) is appropriate.
+ */
+#define	CISS_SCMD_BMIC_READ			0x26
+#define	CISS_SCMD_BMIC_WRITE			0x27
+
 /*
  * CISS Messages
  *
@@ -62,9 +71,19 @@ extern "C" {
 
 #define	CISS_MSG_NOP				0x3
 
+/*
+ * BMIC Commands
+ *
+ * These commands allow for the use of non-standard facilities specific to the
+ * Smart Array firmware.  They are sent to the controller through a specially
+ * constructed CDB with the CISS_SCMD_BMIC_READ or CISS_SCMD_BMIC_WRITE opcode.
+ */
+#define	CISS_BMIC_IDENTIFY_CONTROLLER		0x11
+
 /*
  * The following packed structures are used to ease the manipulation of SCSI
- * commands sent to, and status information returned from, the controller.
+ * and BMIC commands sent to, and status information returned from, the
+ * controller.
  */
 #pragma pack(1)
 
@@ -96,6 +115,42 @@ typedef struct smrt_report_logical_lun_req {
 	uint8_t smrllr_control;
 } smrt_report_logical_lun_req_t;
 
+/*
+ * Request structure for the BMIC command IDENTIFY CONTROLLER.  This structure
+ * is written into the CDB with the CISS_SCMD_BMIC_READ SCSI opcode.  Reserved
+ * fields should be filled with zeroes.
+ */
+typedef struct smrt_identify_controller_req {
+	uint8_t smicr_opcode;
+	uint8_t smicr_lun;
+	uint8_t smicr_reserved1[4];
+	uint8_t smicr_command;
+	uint8_t smicr_reserved2[2];
+	uint8_t smicr_reserved3[1];
+	uint8_t smicr_reserved4[6];
+} smrt_identify_controller_req_t;
+
+/*
+ * Response structure for IDENTIFY CONTROLLER.  This structure is used to
+ * interpret the response the controller will write into the data buffer.
+ */
+typedef struct smrt_identify_controller {
+	uint8_t smic_logical_drive_count;
+	uint32_t smic_config_signature;
+	uint8_t smic_firmware_rev[4];
+	uint8_t smic_recovery_rev[4];
+	uint8_t smic_hardware_version;
+	uint8_t smic_bootblock_rev[4];
+
+	/*
+	 * These are obsolete for SAS controllers:
+	 */
+	uint32_t smic_drive_present_map;
+	uint32_t smic_external_drive_map;
+
+	uint32_t smic_board_id;
+} smrt_identify_controller_t;
+
 #pragma pack()
 
 #ifdef	__cplusplus
-- 
2.21.0

