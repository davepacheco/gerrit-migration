From e5b406312e5d04f7824914eb10a8ae0f17a09af8 Mon Sep 17 00:00:00 2001
From: "Joshua M. Clulow" <jmc@joyent.com>
Date: Sat, 4 Feb 2017 00:05:28 -0800
Subject: [PATCH] MANTA-3140 moray_gc could work both smarter and harder

---
 bin/moray_gc.js      | 291 ++++++++++++++++++++++++++++---------------
 lib/batch_stream.js  |  97 +++++++++++++++
 lib/maxsockets.js    |  67 ++++++++++
 lib/moray_cleaner.js | 242 +++++++++++++++++++++++++----------
 package.json         |   4 +-
 5 files changed, 531 insertions(+), 170 deletions(-)
 create mode 100644 lib/batch_stream.js
 create mode 100644 lib/maxsockets.js

diff --git a/bin/moray_gc.js b/bin/moray_gc.js
index 84bacc7..98487f6 100755
--- a/bin/moray_gc.js
+++ b/bin/moray_gc.js
@@ -7,24 +7,36 @@
  */
 
 /*
- * Copyright (c) 2014, Joyent, Inc.
+ * Copyright (c) 2017, Joyent, Inc.
  */
 
+/*
+ * This program streams one object at a time per shard, up to a limit.  We need
+ * to allow at least one, and perhaps several, concurrent HTTP connections.
+ * See the comments in "maxsockets.js" for more information.
+ */
+var SHARD_PARALLELISM = 32;
+require('../lib/maxsockets')(SHARD_PARALLELISM * 4);
+
+
+var assert = require('assert-plus');
 var bunyan = require('bunyan');
 var exec = require('child_process').exec;
 var fs = require('fs');
-var getopt = require('posix-getopt');
 var lib = require('../lib');
 var manta = require('manta');
-var path = require('path');
+var vasync = require('vasync');
+var verror = require('verror');
+var stream = require('stream');
 
+var VE = verror.VError;
 
-///--- Globals
 
 var LOG = bunyan.createLogger({
         level: (process.env.LOG_LEVEL || 'info'),
         name: 'moray_gc',
-        stream: process.stdout
+        stream: process.stdout,
+        serializers: bunyan.stdSerializers
 });
 var MANTA_CONFIG = (process.env.MANTA_CONFIG ||
                     '/opt/smartdc/common/etc/config.json');
@@ -33,7 +45,7 @@ var MANTA_USER = MANTA_CLIENT.user;
 var MORAY_CLEANUP_PATH = '/' + MANTA_USER + '/stor/manta_gc/moray';
 var PID_FILE = '/var/tmp/moray_gc.pid';
 var CRON_START = new Date();
-var MORAY_CLEANER = lib.createMorayCleaner({ log: LOG });
+var MORAY_CLEANER = lib.createMorayCleaner({ log: LOG, batchSize: 1000 });
 MORAY_CLEANER.on('error', function (err) {
         LOG.fatal(err);
         var returnCode = auditCron(err);
@@ -41,141 +53,217 @@ MORAY_CLEANER.on('error', function (err) {
 });
 
 
+/*
+ * Called for each Manta object created by the garbage collection job.  This
+ * function streams the contents of the input object from Manta, processing
+ * each directive in the object to remove old records from the particular Moray
+ * shard.
+ */
+function cleanShardOneObject(log, shard, input, cb) {
+        assert.object(log, 'log');
+        assert.string(shard, 'shard');
+        assert.string(input, 'input');
+        assert.func(cb, 'cb');
 
-///--- Helpers
-
-function morayCleanShard(shard, obj, cb) {
-        var dir = MORAY_CLEANUP_PATH + '/' + shard;
-        var o = dir + '/' + obj.name;
-
-        LOG.info({ shard: shard, object: o }, 'Processing object.');
+        log.info('deleting moray records listed in cleanup object');
 
-        MANTA_CLIENT.get(o, {}, function (err, stream) {
+        MANTA_CLIENT.get(input, {}, function (err, strom) {
                 if (err) {
-                        cb(err);
+                        cb(VE(err, 'get "%s"', input));
                         return;
                 }
 
-                //The Moray Cleaner will unpause.
-                stream.pause();
-
-                MORAY_CLEANER.clean({
+                /*
+                 * The Moray cleaner stream knows how to interpret the contents
+                 * of the garbage collection input objects.  See the comments
+                 * in "lib/moray_cleaner.js" for more information.
+                 */
+                var mcs = MORAY_CLEANER.cleanStream({
                         shard: shard,
-                        stream: stream,
-                        object: o
-                }, function () {
-                        MANTA_CLIENT.unlink(o, {}, function (err2) {
-                                if (err2) {
-                                        cb(err2);
+                        object: input
+                });
+
+                mcs.once('error', function (mcsErr) {
+                        cb(VE(mcsErr, 'cleanStream "%s"', input));
+                });
+                mcs.once('workComplete', function () {
+                        MANTA_CLIENT.unlink(input, {}, function (ulErr) {
+                                if (ulErr) {
+                                        cb(VE(ulErr, 'unlink "%s"', input));
                                         return;
                                 }
-                                LOG.info({ obj: o }, 'Done with obj.');
+                                log.info('cleanup object complete');
                                 cb();
                         });
                 });
+
+                strom.pipe(mcs);
         });
 }
 
-function morayCleanObjects(shard, objects, cb) {
-        if (objects.length < 1) {
-                cb();
-                return;
-        }
 
-        var obj = objects.shift();
-        LOG.info({ shard: shard, obj: obj }, 'Going to clean shard.');
-        morayCleanShard(shard, obj, function (err) {
+/*
+ * For a particular Moray shard, look in the cleanup directory: "dir", a Manta
+ * path.  This directory contains objects that are the output of the garbage
+ * collection Manta job.  Each object contains a list of Moray records marked
+ * for deletion.
+ */
+function cleanShardDirectory(log, shard, dir, cb) {
+        assert.object(log, 'log');
+        assert.string(shard, 'shard');
+        assert.string(dir, 'dir');
+        assert.func(cb, 'cb');
+
+        log.info('cleaning shard');
+
+        var errs = [];
+        var finished = false;
+        var outstanding = false;
+        var nobjects = 0;
+
+        var finish = function (err) {
                 if (err) {
-                        cb(err);
+                        errs.push(err);
+                }
+
+                if (finished || outstanding) {
+                        /*
+                         * Don't call the callback twice.  If the list stream
+                         * fails while a call to "cleanShardOneObject()" is
+                         * in progress, don't call the callback until that
+                         * operation completes.
+                         */
                         return;
                 }
-                morayCleanObjects(shard, objects, cb);
+                finished = true;
+
+                if (errs.length === 0) {
+                        log.info('cleaned %d shard objects', nobjects);
+                        setImmediate(cb);
+                } else {
+                        log.info('cleaned %d shard objects (before error)',
+                            nobjects);
+                        setImmediate(cb, errs.length === 1 ? errs[0] :
+                            new verror.MultiError(errs));
+                }
+        };
+
+        var ls = MANTA_CLIENT.createListStream(dir, { type: 'object' });
+        ls.on('error', function (err) {
+                finish(VE(err, 'listing "%s"', dir));
         });
-}
 
+        var w = new stream.Writable({ objectMode: true, highWaterMark: 0 });
+        w.on('error', finish);
+        w.on('finish', function () {
+                finish();
+        });
 
-function cleanShard(shard, cb) {
-        var dir = MORAY_CLEANUP_PATH + '/' + shard;
-        LOG.info({ shard: shard, dir: dir }, 'Cleaning up shard.');
-        MANTA_CLIENT.ls(dir, function (err, res) {
-                if (err) {
-                        cb(err);
+        /*
+         * For each directory entry from the list stream, invoke
+         * "cleanShardOneObject()" to download that object and process its
+         * contents.
+         */
+        w._write = function (ent, _, next) {
+                if (finished)
                         return;
-                }
 
-                var objects = [];
+                assert.strictEqual(ent.type, 'object', 'wanted objects only');
+                assert.strictEqual(ent.parent, dir, 'unexpected directory');
 
-                res.on('object', function (obj) {
-                        objects.push(obj);
-                });
+                var input = dir + '/' + ent.name;
 
-                res.on('error', function (err2) {
-                        cb(err2);
-                });
+                outstanding = true;
+                cleanShardOneObject(log.child({ input: input }), shard, input,
+                    function (err) {
+                        outstanding = false;
 
-                res.on('end', function () {
-                        if (objects.length === 0) {
-                                LOG.info({ shard: shard },
-                                         'Shard already clean, ' +
-                                         'no objects found.');
-                                cb();
+                        if (err) {
+                                next(VE(err, 'cleanShardOneObject: ' +
+                                    'shard "%s", input "%s"', shard,
+                                    input));
                                 return;
                         }
-                        morayCleanObjects(shard, objects, function (err3) {
-                                cb(err3);
-                        });
+
+                        nobjects++;
+                        next();
                 });
-        });
+        };
+
+        ls.pipe(w);
 }
 
 
-function cleanShards(shards, cb) {
-        if (shards.length < 1) {
-                cb();
-                return;
-        }
+/*
+ * This routine lists entries in the top-level Moray cleanup directory,
+ * MORAY_CLEANUP_PATH.  Each child directory represents a Moray shard for which
+ * we may have clean up work to do.
+ */
+function startGc(cb) {
+        var errs = [];
+        var q = vasync.queuev({
+                worker: function (shard, next) {
+                        assert.string(shard, 'shard');
+                        assert.func(next, 'next');
+
+                        var dir = MORAY_CLEANUP_PATH + '/' + shard;
+                        var log = LOG.child({ shard: shard, dir: dir });
+
+                        cleanShardDirectory(log, shard, dir, function (err) {
+                                if (err) {
+                                        next(VE(err, 'cleanShardDirectory "%s"',
+                                            shard));
+                                        return;
+                                }
 
-        var shard = shards.shift();
-        cleanShard(shard, function (err) {
-                if (err) {
-                        cb(err);
+                                next();
+                        });
+                },
+                concurrency: SHARD_PARALLELISM
+        });
+        q.on('end', function () {
+                if (errs.length === 0) {
+                        cb();
                         return;
                 }
-                cleanShards(shards, cb);
+
+                cb(errs.length === 1 ? errs[0] : new verror.MultiError(errs));
         });
-}
+        var qCallback = function (qErr) {
+                if (!qErr)
+                        return;
 
+                errs.push(qErr);
+                LOG.error({ err: qErr }, 'shard cleaning failure; draining ' +
+                    'already issued tasks');
+                q.kill();
+        };
 
-function startGc(cb) {
-        MANTA_CLIENT.ls(MORAY_CLEANUP_PATH, {}, function (err, res) {
-                if (err) {
-                        cb(err);
+        var ls = MANTA_CLIENT.createListStream(MORAY_CLEANUP_PATH,
+            { type: 'directory' });
+
+        ls.on('error', function (err) {
+                if (err.name === 'ResourceNotFoundError') {
+                        LOG.info({ path: MORAY_CLEANUP_PATH },
+                            'No directories yet for manta gc.');
+                        q.close();
                         return;
                 }
 
-                var shards = [];
-
-                res.on('directory', function (dir) {
-                        var shard = dir.name;
-                        shards.push(shard);
-                });
+                qCallback(VE(err, 'listing "%s"', MORAY_CLEANUP_PATH));
+        });
+        ls.on('readable', function () {
+                var dir;
 
-                res.on('error', function (err2) {
-                        if (err2 && err2.name === 'ResourceNotFoundError') {
-                                LOG.info({ path: MORAY_CLEANUP_PATH },
-                                         'No directories yet for manta gc.');
-                                cb();
-                                return;
-                        }
-                        cb(err2);
-                });
+                while ((dir = ls.read()) !== null) {
+                        assert.strictEqual(dir.type, 'directory',
+                            'wanted directories only');
 
-                res.on('end', function () {
-                        LOG.info({ shards: shards }, 'Going to clean shards.');
-                        cleanShards(shards, function (err2) {
-                                cb(err2);
-                        });
-                });
+                        q.push(dir.name, qCallback);
+                }
+        });
+        ls.on('end', function () {
+                q.close();
         });
 }
 
@@ -186,7 +274,12 @@ function checkAlreadyRunning(cb) {
                 fs.writeFileSync(PID_FILE, process.pid, 'utf8');
                 startGc(function (err) {
                         cleanupPidFile(function () {
-                                cb(err);
+                                if (err) {
+                                        cb(VE(err, 'startGc'));
+                                        return;
+                                }
+
+                                cb();
                         });
                 });
         }
@@ -264,8 +357,6 @@ function auditCron(err) {
 }
 
 
-///--- Main
-
 checkAlreadyRunning(function (err) {
         if (err) {
                 LOG.fatal(err);
diff --git a/lib/batch_stream.js b/lib/batch_stream.js
new file mode 100644
index 0000000..ff8f08c
--- /dev/null
+++ b/lib/batch_stream.js
@@ -0,0 +1,97 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright 2017 Joyent, Inc.
+ */
+
+var assert = require('assert-plus');
+var util = require('util');
+var stream = require('stream');
+
+
+/*
+ * This object mode Transform stream collects all input objects into
+ * batches, releasing them as output only once the batch grows to
+ * the specified size.
+ *
+ * The "opts" object has one property: "batchSize", the integer number
+ * of objects to include in each batch.
+ *
+ * This stream is not prescriptive about the structure of input objects.
+ * Each output object has two properties:
+ *
+ *      "batchId"       the ordinal number of this batch within the
+ *                      stream, starting at an ID of 0.
+ *
+ *      "entries"       an array of input objects in the order they
+ *                      were written to the stream.
+ */
+function BatchStream(opts) {
+        var self = this;
+
+        assert.object(opts, 'opts');
+        assert.number(opts.batchSize, 'opts.batchSize');
+        assert.ok(opts.batchSize >= 1 && opts.batchSize < 100000,
+            'opts.batchSize must be in the range [1, 100000)');
+
+        stream.Transform.call(this, {
+                objectMode: true,
+                highWaterMark: 0
+        });
+
+        self.bs_batchSize = opts.batchSize;
+        self.bs_batch = [];
+        self.bs_batchId = 0;
+        self.bs_objectCount = 0;
+}
+util.inherits(BatchStream, stream.Transform);
+
+BatchStream.prototype.bsCommit = function bsCommit(done) {
+        var self = this;
+
+        if (self.bs_batch.length > 0) {
+                var batch = {
+                        batchId: self.bs_batchId++,
+                        entries: self.bs_batch
+                };
+
+                self.bs_batch = [];
+
+                self.push(batch);
+        }
+
+        setImmediate(done);
+};
+
+BatchStream.prototype._transform = function bsTransform(obj, _, done) {
+        var self = this;
+
+        /*
+         * Collect a batch of input objects.  We only pass objects on
+         * once we have assembled a full batch.  If there is a final,
+         * short batch, it will be emitted by our _flush() routine.
+         */
+        self.bs_batch.push(obj);
+        self.bs_objectCount++;
+        if (self.bs_batch.length < self.bs_batchSize) {
+                setImmediate(done);
+                return;
+        }
+
+        self.bsCommit(done);
+};
+
+BatchStream.prototype._flush = function bsFlush(done) {
+        var self = this;
+
+        self.bsCommit(done);
+};
+
+
+module.exports = {
+        BatchStream: BatchStream
+};
diff --git a/lib/maxsockets.js b/lib/maxsockets.js
new file mode 100644
index 0000000..02fee64
--- /dev/null
+++ b/lib/maxsockets.js
@@ -0,0 +1,67 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+
+function checkNumber(num) {
+        if (typeof (num) !== 'number' || isNaN(num) || !isFinite(num)) {
+                return (false);
+        }
+
+        return (true);
+}
+
+function maxSocketsFixNeeded() {
+        if (!process || !process.versions || !process.versions.node)
+                return (true);
+
+        var components = process.versions.node.split('.').map(function (c) {
+                var ret = parseInt(c, 10);
+
+                return (checkNumber(ret) ? ret : null);
+        });
+
+        /*
+         * If we cannot identify the version, or if this is a version of
+         * Node prior to 0.12.0, we must set maxSockets.
+         */
+        if (components.length !== 3 ||
+            components[0] === null || components[1] === null ||
+            (components[0] <= 0 && components[1] < 12)) {
+                return (true);
+        }
+
+        /*
+         * Subsequent versions of Node shipped with a default maxSockets
+         * value of Infinity.
+         */
+        return (false);
+}
+
+/*
+ * The maximum number of concurrent HTTP(S) connections that Node will make has
+ * historically been quite low.  Prior to 0.12.0, the default "maxSockets"
+ * value was 5.
+ *
+ * If a program needs to make a large number of concurrent HTTP requests,
+ * particularly to the same server, it needs to increase the limit.  This must
+ * be done before the Manta client library is imported, due to the way the
+ * restify client interacts with these essentially global values.
+ */
+module.exports = function setMaxSockets(maxSockets) {
+        if (!checkNumber(maxSockets) || maxSockets < 1) {
+                throw (new Error('maxSockets must be a positive integer, ' +
+                    'not "' + maxSockets + '"'));
+        }
+
+        if (!maxSocketsFixNeeded())
+                return;
+
+        require('http').globalAgent.maxSockets = maxSockets;
+        require('https').globalAgent.maxSockets = maxSockets;
+};
diff --git a/lib/moray_cleaner.js b/lib/moray_cleaner.js
index 5838643..ec5a981 100644
--- a/lib/moray_cleaner.js
+++ b/lib/moray_cleaner.js
@@ -5,21 +5,26 @@
  */
 
 /*
- * Copyright (c) 2014, Joyent, Inc.
+ * Copyright (c) 2017, Joyent, Inc.
  */
 
-var carrier = require('carrier');
+var assert = require('assert-plus');
 var events = require('events');
 var moray = require('moray');
 var util = require('util');
-var vasync = require('vasync');
+var stream = require('stream');
+var lstream = require('lstream');
+var vstream = require('vstream');
+var VE = require('verror').VError;
+
+var BatchStream = require('./batch_stream').BatchStream;
 
 
 
 ///--- Globals
 
 var MORAY_BUCKET = 'manta_delete_log';
-var MORAY_CONNECT_TIMEOUT = 1000;
+var MORAY_CONNECT_TIMEOUT = 10000;
 var MORAY_PORT = 2020;
 
 
@@ -31,8 +36,13 @@ var MORAY_PORT = 2020;
  * manta_delete_log table.
  */
 function MorayCleaner(opts, listener) {
+        assert.object(opts, 'opts');
+        assert.object(opts.log, 'opts.log');
+        assert.number(opts.batchSize, 'opts.batchSize');
+
         var self = this;
         this.log = opts.log;
+        this.batchSize = opts.batchSize;
         this.morayClients = {};
         this.rowsDeleted = 0;
         this.rowsAlreadyDeleted = 0;
@@ -66,7 +76,9 @@ function deleteFromMoray(opts, cb) {
                         log.error({
                                 line: line
                         }, 'Is supposed to be a moray gc line,');
-                        cb({ name: 'BadLine', message: 'Bad Line' });
+                        cb(VE({ info: { line: line, shard: expectedShard }},
+                            'malformed input line'));
+                        return;
                 }
 
                 var type = parts[0];
@@ -176,72 +188,164 @@ MorayCleaner.prototype.close = function close(cb) {
 };
 
 
-/**
- * Given a stream of lines like so:
- *   moray + [TAB] + [moray hostname] + [TAB] + [objectId] + [TAB] +
- *     [delete time]
+/*
+ * This stream is used as part of the implementation of
+ * MorayCleaner#cleanStream().  It accepts batches of garbage collection
+ * directives, as split into lines by "lstream" and subsequently assembled into
+ * batches by a "BatchStream".  Each instance of this class is connected to a
+ * parent MorayCleaner, through which it obtains a connection to the
+ * appropriate Moray shard.  Each input line is parsed and the nominated
+ * records are deleted using a bulk Moray operation.  Once all input has been
+ * processed and all outstanding Moray operations have completed, the stream
+ * emits the "workComplete" event.
+ */
+function MorayCleanerStream(opts) {
+        var self = this;
+
+        assert.object(opts, 'opts');
+        assert.object(opts.log, 'opts.log');
+        assert.string(opts.shard, 'opts.shard');
+        assert.string(opts.object, 'opts.object');
+        assert.object(opts.parent, 'opts.parent');
+
+        stream.Writable.call(this, {
+                objectMode: true,
+                highWaterMark: 0
+        });
+
+        self.mcs_log = opts.log;
+        self.mcs_shard = opts.shard;
+        self.mcs_object = opts.object;
+        self.mcs_parent = opts.parent;
+        self.mcs_client = null;
+
+        self.mcs_inputComplete = false;
+        self.mcs_inCommit = false;
+        self.mcs_pendingCommit = null;
+
+        self.on('finish', function () {
+                self.mcs_inputComplete = true;
+
+                self.mcs_log.debug('finish event');
+
+                setImmediate(self.emit.bind(self, 'workComplete'));
+        });
+
+        self.mcs_parent.getMorayClient(self.mcs_shard, function (client) {
+                self.mcs_log.debug('getMorayClient ok');
+                self.mcs_client = client;
+
+                if (self.mcs_pendingCommit !== null) {
+                        var pc = self.mcs_pendingCommit;
+                        self.mcs_pendingCommit = null;
+
+                        self.mcsCommit(pc.pc_batch, pc.pc_callback);
+                }
+        });
+}
+util.inherits(MorayCleanerStream, stream.Writable);
+
+MorayCleanerStream.prototype.mcsCommit = function mcsCommit(batch, done) {
+        var self = this;
+
+        assert.object(batch, 'batch');
+        assert.ok(Array.isArray(batch.entries), 'batch.entries');
+        assert.func(done, 'done');
+
+        if (batch.entries.length < 1) {
+                setImmediate(done);
+                return;
+        }
+
+        if (self.mcs_client === null) {
+                /*
+                 * We need to wait for the Moray client before we try to
+                 * perform any database operations.
+                 */
+                assert.strictEqual(self.mcs_pendingCommit, null,
+                    'a commit is already pending!');
+                self.mcs_pendingCommit = {
+                        pc_batch: batch,
+                        pc_callback: done
+                };
+                return;
+        }
+
+        assert.strictEqual(self.mcs_inCommit, false, 'mcsCommit re-entry');
+        self.mcs_inCommit = true;
+
+        deleteFromMoray({
+                self: self.mcs_parent,
+                lines: batch.entries,
+                expectedShard: self.mcs_shard,
+                client: self.mcs_client
+        }, function (err) {
+                if (err) {
+                        done(VE(err, 'deleteFromMoray("%s", "%s")',
+                            self.mcs_shard, self.mcs_object));
+                        return;
+                }
+
+                self.mcs_inCommit = false;
+
+                done();
+        });
+};
+
+MorayCleanerStream.prototype._write = function mcsWrite(batch, _, done) {
+        var self = this;
+
+        self.mcsCommit(batch, done);
+};
+
+/*
+ * Accepts a stream of newline delimited records of the form:
+ *
+ *   moray + [TAB] + [moray hostname] + [TAB] + [objectId] +
+ *       [TAB] + [delete time]
  *
- * Will clean the relevant lines from the manta_delete_log table of the Moray
- * shard.
+ * For each line, delete the matching object (if it exists) from the
+ * "manta_delete_log" table of the Moray shard.
  */
-MorayCleaner.prototype.clean = function clean(opts, cb) {
+MorayCleaner.prototype.cleanStream = function cleanStream(opts) {
         var self = this;
-        var log = self.log;
-        var shard = opts.shard;
-        var stream = opts.stream;
-        var object = opts.object;
-        var maxInBatch = 100;
-
-        log.debug({ object: object }, 'Moray Cleaner Object Entering.');
-
-        var queue = vasync.queue(function (opts2, cb2) {
-                var lines = opts2.lines;
-                var client = opts2.client;
-
-                deleteFromMoray({
-                        self: self,
-                        lines: lines,
-                        expectedShard: shard,
-                        client: client
-                }, function (err) {
-                        if (err) {
-                                self.emit('error', err);
-                        }
-                        cb2();
-                });
-        }, 1);
-
-        queue.on('end', cb);
-
-        self.getMorayClient(shard, function (client) {
-                var car = carrier.carry(stream);
-
-                var lines = [];
-                car.on('line', function (line) {
-                        lines.push(line);
-                        if (lines.length === maxInBatch) {
-                                queue.push.call(queue, {
-                                        lines: lines,
-                                        client: client
-                                });
-                                lines = [];
-                        }
-                });
-
-                car.on('error', function (err) {
-                        self.emit('error', err);
-                });
-
-                car.on('end', function () {
-                        log.debug({ object: object },
-                                 'Carrier for object ended.');
-                        queue.push.call(queue, {
-                                lines: lines,
-                                client: client
-                        });
-                        queue.close();
-                });
-
-                stream.resume();
+        var log = self.log.child({
+                object: opts.object
         });
+
+        log.debug('creating moray cleaner stream');
+
+        var cleaner = new MorayCleanerStream({
+                shard: opts.shard,
+                object: opts.object,
+                parent: self,
+                log: log
+        });
+
+        /*
+         * Use PipelineStream to return a combination of several processing
+         * stages: chunking lines in the input into per-line strings, then
+         * collecting those strings into batches, then finally cleaning them
+         * via batched Moray requests.
+         */
+        var mcs = new vstream.PipelineStream({
+                streams: [
+                        new lstream({ highWaterMark: 0 }),
+                        new BatchStream({ batchSize: self.batchSize }),
+                        cleaner
+                ],
+                streamOpts: {
+                        highWaterMark: 0,
+                        objectMode: true
+                }
+        });
+
+        /*
+         * Forward the "workComplete" event from the internal
+         * MorayCleanerStream to the consumer of the combined PipelineStream
+         * we return.
+         */
+        cleaner.on('workComplete', mcs.emit.bind(mcs, 'workComplete'));
+
+        return (mcs);
 };
diff --git a/package.json b/package.json
index 0e85f05..b9d7f0e 100644
--- a/package.json
+++ b/package.json
@@ -22,7 +22,9 @@
                 "moray": "git+ssh://git@github.com:joyent/node-moray.git#fd5781bc25a9bfe2ba82167664639753fb9f0ca5",
                 "posix-getopt": "1.0.0",
                 "sprintf-js": "0.0.7",
-                "vasync": "1.6.1"
+                "vasync": "1.6.1",
+                "verror": "^1.9.0",
+                "vstream": "0.1.0"
         },
         "devDependencies": {
                 "nodeunit": "0.7.4"
-- 
2.21.0

