From 19d9285be8dbb86c0d1cf736e78a47c6a7e6fa0c Mon Sep 17 00:00:00 2001
From: Mike Gerdts <mike.gerdts@joyent.com>
Date: Wed, 28 Mar 2018 15:03:57 +0000
Subject: [PATCH] OS-6834 zfd logging needs to be more generic

---
 usr/src/cmd/zoneadmd/Makefile.com |   2 +-
 usr/src/cmd/zoneadmd/log.c        | 849 ++++++++++++++++++++++++++++++
 usr/src/cmd/zoneadmd/zcons.c      |   8 +
 usr/src/cmd/zoneadmd/zfd.c        | 260 ++-------
 usr/src/cmd/zoneadmd/zoneadmd.c   |  35 +-
 usr/src/cmd/zoneadmd/zoneadmd.h   |  18 +-
 6 files changed, 928 insertions(+), 244 deletions(-)
 create mode 100644 usr/src/cmd/zoneadmd/log.c

diff --git a/usr/src/cmd/zoneadmd/Makefile.com b/usr/src/cmd/zoneadmd/Makefile.com
index 75d7d82396..7f78fb2e05 100644
--- a/usr/src/cmd/zoneadmd/Makefile.com
+++ b/usr/src/cmd/zoneadmd/Makefile.com
@@ -30,7 +30,7 @@ include ../../Makefile.ctf
 
 ROOTCMDDIR=	$(ROOTLIB)/zones
 
-OBJS= zoneadmd.o zcons.o zfd.o vplat.o
+OBJS= zoneadmd.o zcons.o zfd.o vplat.o log.o
 
 CFLAGS += $(CCVERBOSE)
 LDLIBS += -lsocket -lzonecfg -lnsl -ldevinfo -ldevice -lnvpair \
diff --git a/usr/src/cmd/zoneadmd/log.c b/usr/src/cmd/zoneadmd/log.c
new file mode 100644
index 0000000000..69a58ca14e
--- /dev/null
+++ b/usr/src/cmd/zoneadmd/log.c
@@ -0,0 +1,849 @@
+/*
+ * This file and its contents are supplied under the terms of the
+ * Common Development and Distribution License ("CDDL"), version 1.0.
+ * You may only use this file in accordance with the terms of version
+ * 1.0 of the CDDL.
+ *
+ * A full copy of the text of the CDDL should have accompanied this
+ * source.  A copy of the CDDL is also available via the Internet at
+ * http://www.illumos.org/license/CDDL.
+ */
+
+/*
+ * Copyright 2018 Joyent, Inc.
+ */
+
+/*
+ * zoneadmd logging
+ *
+ * zoneadmd logs to log files under <zonepath>/logs.  Each log entry is a json
+ * structure of the form:
+ *
+ *   {
+ *     "log": "some message\n",
+ *     "stream": "stderr",
+ *     "time": "2018-03-28T13:25:02.670423000Z"
+ *   }
+ *
+ * Unlike the example above, the entries in the log file are not pretty-printed.
+ * Messages are processed so that they have the proper json escapes for
+ * problematic characters.  Excessively long messages may be truncated.
+ *
+ * To use these interfaces:
+ *
+ *	int logid;
+ *
+ *	logstream_init(zlogp);
+ *
+ *	logid = logstream_open(zlogp, "stdio.log", "stdout", flags);
+ *	if (logid < 0) { ... handle error ... }
+ *	...
+ *	logstream_write(logid, buf, len);
+ *	...
+ *	logstream_close(logid);
+ *
+ * logstream_init() needs to be called only once.
+ *
+ * logstream_open() opens a log file (if not already open) and associates the
+ * specified stream with it.  When logstream_write() will be called with
+ * partial lines (e.g. console output with slow uart emulation), the
+ * LS_LINE_BUFFERED flag is recommended to prevent extreme log file bloat due to
+ * timestamp and json overhead.  The zlog_t reference that is passed to
+ * logstream_open() is used only during logstream_open().
+ *
+ * Log rotation
+ *
+ * Two attributes, zlog-maxsize and zlog-keep-rotated are used for automatic log
+ * rotation.  zlog-maxsize is the approximate maximum size of a log before it is
+ * automatically rotated.  Rotated logs are renamed as <log>.<iso-8601-stamp>.
+ * If zlog-keep-rotated is specified and is an integer greater than zero, only
+ * that number of rotated logs will be retained.
+ *
+ * If zlog-maxsize is not specified, log rotation will not happen automatically.
+ * An external log rotation program may rename the log file(s), then send
+ * SIGHUP to zoneadmd.
+ *
+ * Log rotation can be forced with SIGUSR1.  In this case, the log will be
+ * rotated as though it hit the maximum size and will be subject to retention
+ * rules described above.
+ *
+ * Locking strategy
+ *
+ * Callers need not worry about locking.  In the interest of simplicity, a
+ * single global lock is used to protect the state of the log files and the
+ * associated streams.  Locking is necessary because reboots and log rotations
+ * can cause various state changes.  Without locking, races could cause log
+ * entries to be directed to the wrong file descriptors.
+ *
+ * The simplistic global lock complicates error reporting within logging
+ * routines.  All calls to zerror() in this file must be done using the ZERROR()
+ * macro to prevent recursive mutex_lock() calls.  When ZERROR()-based recursion
+ * is detected, the message will not be logged here, but may be logged via
+ * syslog.  See zerror().
+ */
+
+#include <assert.h>
+#include <dirent.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <signal.h>
+#include <stdio.h>
+#include <strings.h>
+#include <synch.h>
+#include <time.h>
+#include <thread.h>
+#include <unistd.h>
+#include <wchar.h>
+
+#include <sys/stat.h>
+#include <sys/sysmacros.h>
+#include <sys/time.h>
+#include <sys/types.h>
+
+#include "zoneadmd.h"
+
+/*
+ * Currently we only expect stdout, stderr, zoneadmd, and console.  Increase
+ * MAX_ZLOG_STREAMS if more streams are added.  If the count increases
+ * significantly, logfile_t and logstream_t elements should be dynamically
+ * allocated and the algorithms associated with opening and closing them should
+ * become more efficient.
+ */
+#define	MAX_LOG_STREAMS 4
+
+#define	ZLOG_MAXSZ	"zlog-max-size"		/* zonecfg attr */
+#define	ZLOG_KEEP	"zlog-keep-rotated"	/* zonecfg attr */
+
+#define	ARRAY_SIZE(x) (sizeof (x) / sizeof (x[0]))
+#define	ZERROR(args)							\
+	{								\
+		if (logstream_lock_held()) {				\
+			logging_in_zerror = B_TRUE;			\
+		}							\
+		zerror args;						\
+		if (logstream_lock_held()) {				\
+			logging_in_zerror = B_FALSE;			\
+		}							\
+	}
+
+typedef struct logfile {
+	char	lf_path[MAXPATHLEN];	/* log file name (absolute path) */
+	char	lf_name[MAXNAMELEN];	/* tail of log file name */
+	int	lf_fd;			/* file descriptor */
+	size_t	lf_size;		/* Current size */
+	boolean_t lf_write_err;		/* Avoid spamming console via logsys */
+} logfile_t;
+
+typedef struct logstream {
+	char		ls_stream[MAXNAMELEN];	/* stdout, stderr, etc. */
+	char		ls_buf[BUFSIZ];	/* For LS_LINE_BUFFERED */
+	int		ls_buflen;	/* For LS_LINE_BUFFERED */
+	logstream_flags_t ls_flags;
+	logfile_t	*ls_logfile;	/* N streams per log file */
+} logstream_t;
+
+/*
+ * MAX_LOG_STREAMS is a small number so we allocate in the simplest way.
+ */
+static logstream_t streams[MAX_LOG_STREAMS];
+static logfile_t logfiles[MAX_LOG_STREAMS];
+
+static boolean_t logging_initialized = B_FALSE;
+static uint64_t logging_rot_size;		/* See ZLOG_MAXSZ */
+static uint64_t logging_rot_keep;		/* See ZLOG_KEEP */
+static thread_t logging_lock_holder = -1;	/* Thread holds logging_lock */
+static boolean_t logging_in_zerror = B_FALSE;	/* See ZERROR() */
+static int logging_pending_sig = 0;		/* Signal recvd while logging */
+static mutex_t logging_lock;			/* The global logging lock */
+
+static void logstream_sighandler(int);
+static void rotate_log(logfile_t *);
+
+static void
+logstream_lock(void)
+{
+	int ret;
+
+	assert(logging_initialized);
+
+	ret = mutex_lock(&logging_lock);
+	assert(ret == 0);
+
+	logging_lock_holder = thr_self();
+}
+
+static void
+logstream_unlock(void)
+{
+	int ret;
+	int err = errno;
+	int sig = logging_pending_sig;
+
+	logging_pending_sig = 0;
+	logging_lock_holder = -1;
+	ret = mutex_unlock(&logging_lock);
+	assert(ret == 0);
+
+	/*
+	 * If a signal arrived while this thread was holding the lock, call the
+	 * handler.
+	 */
+	if (sig != 0) {
+		logstream_sighandler(sig);
+	}
+
+	errno = err;
+}
+
+static boolean_t
+logstream_lock_held(void)
+{
+	return (logging_lock_holder == thr_self());
+}
+
+static void
+close_log(logfile_t *lfp)
+{
+	int err;
+
+	assert(logstream_lock_held());
+
+	/*
+	 * Something may have gone wrong during log rotation, leading to a
+	 * zombie log.
+	 */
+	if (lfp->lf_fd == -1) {
+		return;
+	}
+
+	err = close(lfp->lf_fd);
+	assert(err == 0);
+	lfp->lf_fd = -1;
+}
+
+static void
+open_log(logfile_t *lfp)
+{
+	struct stat64 sb;
+	int err;
+
+	assert(logstream_lock_held());
+	assert(lfp->lf_fd == -1);
+
+	lfp->lf_fd = open(lfp->lf_path, O_WRONLY | O_APPEND | O_CREAT, 0600);
+	if (lfp->lf_fd == -1) {
+		ZERROR((&logsys, B_TRUE, "Cannot open log file %s",
+		    lfp->lf_path));
+		lfp->lf_write_err = B_TRUE;
+		return;
+	}
+
+	err = fstat64(lfp->lf_fd, &sb);
+	assert(err == 0);
+	lfp->lf_size = sb.st_size;
+	lfp->lf_write_err = B_FALSE;
+}
+
+static void
+logstream_sighandler(int sig)
+{
+	int i;
+
+	/*
+	 * Protect against recursive mutex enters when a signal comes during
+	 * logging.  This will cause this function to be called again just after
+	 * this thread drops the lock.
+	 */
+	if (logstream_lock_held()) {
+		logging_pending_sig = sig;
+		return;
+	}
+
+	logstream_lock();
+
+	for (i = 0; i < ARRAY_SIZE(logfiles); i++) {
+		/* Inactive logfile slot */
+		if (logfiles[i].lf_name[0] == '\0') {
+			continue;
+		}
+
+		switch (sig) {
+		case SIGHUP:
+			close_log(&logfiles[i]);
+			open_log(&logfiles[i]);
+			break;
+		case SIGUSR1:
+			rotate_log(&logfiles[i]);
+			break;
+		default:
+			ZERROR((&logsys, B_FALSE, "unhandled signal %d", sig));
+		}
+	}
+
+	logstream_unlock();
+}
+
+void
+get_attr_uint64(zlog_t *zlogp, zone_dochandle_t handle, const char *name,
+    uint64_t *valp)
+{
+	struct zone_attrtab tab = { 0 };
+	char *p;
+	uint64_t val;
+
+	(void) strlcpy(tab.zone_attr_name, name, sizeof (tab.zone_attr_name));
+	if (zonecfg_lookup_attr(handle, &tab) != Z_OK) {
+		return;
+	}
+
+	errno = 0;
+	val = strtol(tab.zone_attr_value, &p, 10);
+	if (errno != 0 && *p == '\0') {
+		ZERROR((zlogp, errno != 0, "Bad value '%s' for 'attr name=%s'",
+		    tab.zone_attr_value, tab.zone_attr_name));
+		return;
+	}
+
+	*valp = val;
+}
+
+void
+logstream_init(zlog_t *zlogp)
+{
+	zone_dochandle_t handle;
+	int err;
+	int i;
+
+	assert(!logging_initialized);
+
+	err = mutex_init(&logging_lock, USYNC_THREAD | LOCK_ERRORCHECK, 0);
+	assert(err == 0);
+
+	for (i = 0; i < ARRAY_SIZE(logfiles); i++) {
+		logfiles[i].lf_fd = -1;
+	}
+
+	logging_initialized = B_TRUE;
+
+	/* Now it is safe to use zlogp */
+
+	if ((handle = zonecfg_init_handle()) == NULL ||
+	    zonecfg_get_handle(zone_name, handle) != Z_OK) {
+		ZERROR((zlogp, B_FALSE, "failed to open zone configuration "
+		    "while initializing logging"));
+	} else {
+		get_attr_uint64(zlogp, handle, ZLOG_MAXSZ, &logging_rot_size);
+		get_attr_uint64(zlogp, handle, ZLOG_KEEP, &logging_rot_keep);
+	}
+
+	zonecfg_fini_handle(handle);
+
+	/*
+	 * This thread should receive SIGHUP so that it can close the log
+	 * file and reopen it during log rotation.  SIGUSR1 can be used to force
+	 * a log rotation.
+	 */
+	sigset(SIGHUP, logstream_sighandler);
+	sigset(SIGUSR1, logstream_sighandler);
+}
+
+static boolean_t
+is_rotated_file(const char *base, const char *file)
+{
+	const char *ext;
+	int pos;
+
+	if (strncmp(base, file, strlen(base)) != 0) {
+		return (B_FALSE);
+	}
+
+	ext = file + strlen(base);
+	if (strlen(ext) != strlen(".YYYYmmddTHHMMSSZ")) {
+		return (B_FALSE);
+	}
+	for (pos = 0; ext[pos] != '\0'; pos++) {
+		if (pos == 0) {
+			if (ext[pos] != '.') {
+				return (B_FALSE);
+			}
+			continue;
+		}
+		if ((pos > 0 && pos < 9) || (pos > 9 && pos < 16)) {
+			if (!isdigit(ext[pos])) {
+				return (B_FALSE);
+			}
+			continue;
+		}
+		if (pos == 9) {
+			if (ext[pos] != 'T') {
+				return (B_FALSE);
+			}
+			continue;
+		}
+		if (pos == 16) {
+			if (ext[pos] != 'Z') {
+				return (B_FALSE);
+			}
+			continue;
+		}
+		abort();
+	}
+	return (B_TRUE);
+}
+
+/*
+ * Rotate a single log file.  The global lock must be held while this is called.
+ */
+static void
+rotate_log(logfile_t *lfp)
+{
+	time_t t;
+	struct tm gtm;
+	char path[MAXPATHLEN];
+	char **keepers;
+	int i, j;
+	char *p;
+	DIR *dir;
+	struct dirent *dirent;
+	size_t len;
+
+	assert(logstream_lock_held());
+
+	if ((t = time(NULL)) == (time_t)-1 || gmtime_r(&t, &gtm) == NULL) {
+		ZERROR((&logsys, B_TRUE, "failed to format time"));
+		return;
+	}
+
+	(void) snprintf(path, sizeof (path), "%s.%d%02d%02dT%02d%02d%02dZ",
+	    lfp->lf_path, gtm.tm_year + 1900, gtm.tm_mon + 1, gtm.tm_mday,
+	    gtm.tm_hour, gtm.tm_min, gtm.tm_sec);
+
+	if (rename(lfp->lf_path, path) != 0) {
+		ZERROR((&logsys, B_TRUE, "failed to rotate log file "
+		    "'%s' to '%s'", lfp->lf_path, path));
+	}
+
+	close_log(lfp);
+	open_log(lfp);
+
+	if (logging_rot_keep == 0) {
+		return;
+	}
+
+	/*
+	 * Remove old logs.
+	 */
+	if ((p = strrchr(path, '/')) == NULL) {
+		ZERROR((&logsys, B_FALSE, "%s expected path '%s' to have '/'",
+		    __func__, path));
+		return;
+	}
+	*p = NULL;
+
+	if ((dir = opendir(path)) == NULL) {
+		ZERROR((&logsys, B_TRUE, "%s directory '%s'", __func__, path));
+		return;
+	}
+
+	/* Set up keepers array to store the files that are being kept. */
+	len = strlen(lfp->lf_name) + strlen(".YYYYmmddTHHMMSSZ") + 1;
+
+	keepers = calloc(logging_rot_keep, sizeof (keepers[0]) + len);
+	if (keepers == NULL) {
+		ZERROR((&logsys, B_TRUE, "%s allocation of %llu bytes failed",
+		    __func__, logging_rot_keep * len));
+		(void) closedir(dir);
+		return;
+	}
+	p = (char *)&keepers[logging_rot_keep];
+
+	for (i = 0; i < logging_rot_keep; i++) {
+		keepers[i] = p;
+		p += len;
+	}
+	assert(p == ((char *)keepers) +
+	    logging_rot_keep * (sizeof (keepers[0]) + len));
+
+	/*
+	 * Traverse the log directory looking for rotated logs matching
+	 * <lf_name>.<timestamp>.  Populate the keepers array (newest first)
+	 * using insertion sort.  If a file falls off the end of the array,
+	 * delete it.
+	 */
+	while ((dirent = readdir(dir)) != NULL) {
+		size_t clen;
+
+		if (!is_rotated_file(lfp->lf_name, dirent->d_name)) {
+			continue;
+		}
+		for (i = 0; i < logging_rot_keep; i++) {
+			/* Fill empty slot */
+			if (keepers[i][0] == '\0') {
+				clen = strlcpy(keepers[i], dirent->d_name, len);
+				assert(clen + 1 == len);
+
+				goto nextfile;
+			}
+
+			/* Older than current slot, try next. */
+			if (strcmp(dirent->d_name, keepers[i]) < 0) {
+				continue;
+			}
+
+			/* Insert here */
+			for (j = logging_rot_keep - 1; j >= i; j--) {
+				if (j == logging_rot_keep - 1 &&
+				    keepers[j][0] != 0) {
+					if (unlinkat(dirfd(dir),
+					    keepers[j], 0) != 0) {
+						ZERROR((&logsys, B_TRUE,
+						    "unlink %s", keepers[j]));
+					}
+				}
+
+				if (j == i) {
+					break;
+				}
+
+				assert(j > 0);
+				clen = strlcpy(keepers[j], keepers[j - 1], len);
+				assert(clen == 0 || clen + 1 == len);
+			}
+			clen = strlcpy(keepers[i], dirent->d_name, len);
+			assert(clen + 1 == len);
+
+			goto nextfile;
+		}
+		assert(i == logging_rot_keep);
+		if (unlinkat(dirfd(dir), dirent->d_name, 0) != 0) {
+			ZERROR((&logsys, B_TRUE, "unlink '%s'",
+			    dirent->d_name));
+		}
+nextfile:
+		;
+	}
+
+	free(keepers);
+	(void) closedir(dir);
+}
+
+/*
+ * Modify the input string with json escapes. Since the destination can thus
+ * be larger than the source, it may get truncated, although we do use a
+ * larger buffer.
+ */
+static void
+escape_json(char *sbuf, int slen, char *dbuf, int dlen)
+{
+	int i;
+	mbstate_t mbr;
+	wchar_t c;
+	size_t sz;
+
+	bzero(&mbr, sizeof (mbr));
+
+	sbuf[slen] = '\0';
+	i = 0;
+	while (i < dlen && (sz = mbrtowc(&c, sbuf, MB_CUR_MAX, &mbr)) > 0) {
+		switch (c) {
+		case '\\':
+			dbuf[i++] = '\\';
+			dbuf[i++] = '\\';
+			break;
+
+		case '"':
+			dbuf[i++] = '\\';
+			dbuf[i++] = '"';
+			break;
+
+		case '\b':
+			dbuf[i++] = '\\';
+			dbuf[i++] = 'b';
+			break;
+
+		case '\f':
+			dbuf[i++] = '\\';
+			dbuf[i++] = 'f';
+			break;
+
+		case '\n':
+			dbuf[i++] = '\\';
+			dbuf[i++] = 'n';
+			break;
+
+		case '\r':
+			dbuf[i++] = '\\';
+			dbuf[i++] = 'r';
+			break;
+
+		case '\t':
+			dbuf[i++] = '\\';
+			dbuf[i++] = 't';
+			break;
+
+		default:
+			if ((c >= 0x00 && c <= 0x1f) ||
+			    (c > 0x7f && c <= 0xffff)) {
+
+				i += snprintf(&dbuf[i], (dlen - i), "\\u%04x",
+				    (int)(0xffff & c));
+			} else if (c >= 0x20 && c <= 0x7f) {
+				dbuf[i++] = 0xff & c;
+			}
+
+			break;
+		}
+		sbuf += sz;
+	}
+
+	if (i == dlen)
+		dbuf[--i] = '\0';
+	else
+		dbuf[i] = '\0';
+}
+
+/*
+ * We output to the log file as json.
+ * ex. for string 'msg\n' on the zone's stdout:
+ *    {"log":"msg\n","stream":"stdout","time":"2014-10-24T20:12:11.101973117Z"}
+ *
+ * We use ns in the last field of the timestamp for compatibility.
+ *
+ * We keep track of the size of the log file and rotate it when we exceed
+ * the log size limit (if one is set).
+ */
+void
+logstream_write(int ls, char *buf, int len)
+{
+	struct timeval tv;
+	int olen;
+	char ts[64];
+	char nbuf[BUFSIZ * 2];
+	/* Sized for nbuf + ls_stream + timestamp + json stuff */
+	char obuf[BUFSIZ * 2 + MAXNAMELEN + 64];
+	logstream_t *stream;
+	logfile_t *logfile;
+	ssize_t wlen;
+
+	if (ls == -1) {
+		return;
+	}
+	assert(ls >= 0 && ls < ARRAY_SIZE(streams));
+
+	/* Prevent recursion */
+	if (logstream_lock_held() && logging_in_zerror)
+		return;
+
+	logstream_lock();
+
+	stream = &streams[ls];
+
+	/*
+	 * In line-buffered mode, avoid emitting ~64 bytes of json for very
+	 * small buffer lengths.  Instead, emit a json entry if a message
+	 * contains a newline or it fills stream->ls_buf.
+	 */
+	if ((stream->ls_flags & LS_LINE_BUFFERED) != 0) {
+		int tocopy = MIN(len, sizeof (stream->ls_buf) -
+		    stream->ls_buflen);
+		int left;
+		char *p;
+
+		/* buf could have '\0', so strrchr() is not an option */
+		for (p = &buf[tocopy - 1]; p > buf && *p != '\n'; p--)
+			;
+		if (*p == '\n') {
+			tocopy = p - buf + 1;
+		}
+		assert(tocopy <= len);
+
+		left = len - tocopy;
+
+		(void) memcpy(&stream->ls_buf[stream->ls_buflen], buf, tocopy);
+		stream->ls_buflen += tocopy;
+
+		if (stream->ls_buflen < sizeof (stream->ls_buf) && *p != '\n') {
+			assert(left == 0);
+			logstream_unlock();
+			return;
+		}
+		escape_json(stream->ls_buf, stream->ls_buflen, nbuf,
+		    sizeof (nbuf));
+
+		left = MIN(left, sizeof (stream->ls_buf));
+		(void) memcpy(stream->ls_buf, &buf[tocopy], left);
+		stream->ls_buflen = left;
+	} else {
+		escape_json(buf, len, nbuf, sizeof (nbuf));
+	}
+
+	if (gettimeofday(&tv, NULL) != 0) {
+		logstream_unlock();
+		return;
+	}
+	(void) strftime(ts, sizeof (ts), "%FT%T", gmtime(&tv.tv_sec));
+
+
+	logfile = stream->ls_logfile;
+	if (stream->ls_stream[0] == '\0' || logfile == NULL) {
+		logstream_unlock();
+		return;
+	}
+
+	olen = snprintf(obuf, sizeof (obuf),
+	    "{\"log\":\"%s\",\"stream\":\"%s\",\"time\":\"%s.%ldZ\"}\n",
+	    nbuf, stream->ls_stream, ts, tv.tv_usec * 1000);
+	if (olen >= sizeof (obuf)) {
+		/*
+		 * For this unlikely case, there's not a great way to truncate
+		 * obuf without risking creation of a corrupt json stream.  We
+		 * could truncate buf and try again, but it's really a
+		 * programming error if we've made it here.
+		 */
+		logstream_unlock();
+		ZERROR((&logsys, B_FALSE, "log message buffer size too small "
+		    "(olen %lu)", olen));
+		return;
+	}
+
+	wlen = write(logfile->lf_fd, obuf, olen);
+	if (wlen > 0) {
+		logfile->lf_size += wlen;
+
+		if (logging_rot_size > 0 &&
+		    logfile->lf_size > logging_rot_size) {
+			rotate_log(logfile);
+		}
+	}
+
+	if (wlen != olen && !logfile->lf_write_err) {
+		logfile->lf_write_err = B_TRUE;
+		if (wlen == -1) {
+			ZERROR((&logsys, B_TRUE, "log file fd %d '%s' "
+			    "write failed", logfile->lf_fd, logfile->lf_path));
+		} else {
+			ZERROR((&logsys, B_TRUE, "log file fd %d '%s': ",
+			    "short write (%lu of %lu)", logfile->lf_fd,
+			    logfile->lf_path, wlen, olen));
+		}
+	}
+
+	logstream_unlock();
+}
+
+int
+logstream_open(zlog_t *zlogp, const char *logname, const char *stream,
+    logstream_flags_t flags)
+{
+	int ls = -1;
+	int i;
+	logstream_t *lsp;
+	logfile_t *lfp = NULL;
+
+	logstream_lock();
+
+	/*
+	 * Find an empty logstream_t and verify that the stream is not already
+	 * open.
+	 */
+	for (i = 0; i < ARRAY_SIZE(streams); i++) {
+		if (ls == -1 && streams[i].ls_stream[0] == '\0') {
+			assert(streams[i].ls_logfile == NULL);
+			ls = i;
+			continue;
+		}
+		if (strcmp(stream, streams[i].ls_stream) == 0) {
+			logstream_unlock();
+			ZERROR((zlogp, B_FALSE, "log stream %s already open",
+			    stream));
+			return (-1);
+		}
+	}
+
+	/* Find an existing or available logfile_t */
+	for (i = 0; i < ARRAY_SIZE(logfiles); i++) {
+		if (lfp == NULL && logfiles[i].lf_name[0] == '\0') {
+			lfp = &logfiles[i];
+		}
+		if (strcmp(logname, logfiles[i].lf_name) == 0) {
+			lfp = &logfiles[i];
+			break;
+		}
+	}
+	if (lfp->lf_name[0] == '\0') {
+		struct stat64 sb;
+
+		if (strlcpy(lfp->lf_name, logname, sizeof (lfp->lf_name)) >=
+		    sizeof (lfp->lf_name)) {
+			abort();
+		}
+		(void) snprintf(lfp->lf_path, sizeof (lfp->lf_path), "%s/logs",
+		    zonepath);
+		(void) mkdir(lfp->lf_path, 0700);
+
+		(void) snprintf(lfp->lf_path, sizeof (lfp->lf_path),
+		    "%s/logs/%s", zonepath, logname);
+
+		open_log(lfp);
+		if (lfp->lf_fd == -1) {
+			logstream_unlock();
+			return (-1);
+		}
+
+		if (fstat64(lfp->lf_fd, &sb) == 0) {
+			lfp->lf_size = sb.st_size;
+		}
+	}
+
+	lsp = &streams[ls];
+	if (strlcpy(lsp->ls_stream, stream, sizeof (lsp->ls_stream)) >=
+	    sizeof (lsp->ls_stream)) {
+		abort();
+	}
+
+	lsp->ls_flags = flags;
+	lsp->ls_logfile = lfp;
+
+	logstream_unlock();
+
+	return (ls);
+}
+
+void
+logstream_close(int ls)
+{
+	logstream_t *lsp;
+	logfile_t *lfp;
+	int i;
+
+	if (ls == -1) {
+		return;
+	}
+	assert(ls >= 0 && ls < ARRAY_SIZE(streams));
+
+	logstream_lock();
+
+	lsp = &streams[ls];
+	lfp = lsp->ls_logfile;
+
+	assert(lsp->ls_stream[0] != '\0');
+	assert(lfp != NULL);
+
+	(void) memset(lsp, 0, sizeof (*lsp));
+
+	for (i = 0; i < ARRAY_SIZE(streams); i++) {
+		if (streams[i].ls_logfile == lfp) {
+			logstream_unlock();
+			return;
+		}
+	}
+
+	/* No more streams using this log file so return to initial state */
+
+	close_log(lfp);
+
+	(void) memset(lfp, 0, sizeof (*lfp));
+	lfp->lf_fd = -1;
+
+	logstream_unlock();
+}
diff --git a/usr/src/cmd/zoneadmd/zcons.c b/usr/src/cmd/zoneadmd/zcons.c
index af4fafe46a..d208909fc3 100644
--- a/usr/src/cmd/zoneadmd/zcons.c
+++ b/usr/src/cmd/zoneadmd/zcons.c
@@ -744,6 +744,10 @@ do_console_io(zlog_t *zlogp, int consfd, int servfd)
 	char clilocale[MAXPATHLEN];
 	pid_t clipid = 0;
 	int disconnect = 0;
+	int conslog;
+
+	conslog = logstream_open(zlogp, "console.log", "console",
+	    LS_LINE_BUFFERED);
 
 	/* console side, watch for read events */
 	pollfds[0].fd = consfd;
@@ -783,6 +787,9 @@ do_console_io(zlog_t *zlogp, int consfd, int servfd)
 				if (cc <= 0 && (errno != EINTR) &&
 				    (errno != EAGAIN))
 					break;
+
+				logstream_write(conslog, ibuf, cc);
+
 				/*
 				 * Lose I/O if no one is listening
 				 */
@@ -891,6 +898,7 @@ do_console_io(zlog_t *zlogp, int consfd, int servfd)
 		(void) shutdown(clifd, SHUT_RDWR);
 		(void) close(clifd);
 	}
+	logstream_close(conslog);
 }
 
 int
diff --git a/usr/src/cmd/zoneadmd/zfd.c b/usr/src/cmd/zoneadmd/zfd.c
index 48334b182a..73ecd98e7e 100644
--- a/usr/src/cmd/zoneadmd/zfd.c
+++ b/usr/src/cmd/zoneadmd/zfd.c
@@ -83,15 +83,10 @@
 
 #include "zoneadmd.h"
 
-static zlog_t	*zlogp;
 static int	shutting_down = 0;
 static thread_t logger_tid;
-static int	logfd = -1;
-static size_t	log_sz = 0;
-static size_t	log_rot_sz = 0;
-static char	log_name[MAXNAMELEN] = "stdio.log";
-
-static void rotate_log();
+size_t		log_rot_sz = 0;
+char		log_name[MAXNAMELEN] = "stdio.log";
 
 /*
  * The eventstream is a simple one-directional flow of messages implemented
@@ -100,7 +95,6 @@ static void rotate_log();
 static int eventstream[2] = {-1, -1};
 
 #define	ZLOG_MODE		"zlog-mode"
-#define	ZLOG_MAXSZ		"zlog-max-size"
 #define	ZLOG_NAME		"zlog-name"
 #define	ZFDNEX_DEVTREEPATH	"/pseudo/zfdnex@2"
 #define	ZFDNEX_FILEPATH		"/devices/pseudo/zfdnex@2"
@@ -615,127 +609,6 @@ test_client(int clifd)
 	return (0);
 }
 
-/*
- * Modify the input string with json escapes. Since the destination can thus
- * be larger than the source, it may get truncated, although we do use a
- * larger buffer.
- */
-static void
-escape_json(char *sbuf, int slen, char *dbuf, int dlen)
-{
-	int i;
-	mbstate_t mbr;
-	wchar_t c;
-	size_t sz;
-
-	bzero(&mbr, sizeof (mbr));
-
-	sbuf[slen] = '\0';
-	i = 0;
-	while (i < dlen && (sz = mbrtowc(&c, sbuf, MB_CUR_MAX, &mbr)) > 0) {
-		switch (c) {
-		case '\\':
-			dbuf[i++] = '\\';
-			dbuf[i++] = '\\';
-			break;
-
-		case '"':
-			dbuf[i++] = '\\';
-			dbuf[i++] = '"';
-			break;
-
-		case '\b':
-			dbuf[i++] = '\\';
-			dbuf[i++] = 'b';
-			break;
-
-		case '\f':
-			dbuf[i++] = '\\';
-			dbuf[i++] = 'f';
-			break;
-
-		case '\n':
-			dbuf[i++] = '\\';
-			dbuf[i++] = 'n';
-			break;
-
-		case '\r':
-			dbuf[i++] = '\\';
-			dbuf[i++] = 'r';
-			break;
-
-		case '\t':
-			dbuf[i++] = '\\';
-			dbuf[i++] = 't';
-			break;
-
-		default:
-			if ((c >= 0x00 && c <= 0x1f) ||
-			    (c > 0x7f && c <= 0xffff)) {
-
-				i += snprintf(&dbuf[i], (dlen - i), "\\u%04x",
-				    (int)(0xffff & c));
-			} else if (c >= 0x20 && c <= 0x7f) {
-				dbuf[i++] = 0xff & c;
-			}
-
-			break;
-		}
-		sbuf += sz;
-	}
-
-	if (i == dlen)
-		dbuf[--i] = '\0';
-	else
-		dbuf[i] = '\0';
-}
-
-/*
- * We output to the log file as json.
- * ex. for string 'msg\n' on the zone's stdout:
- *    {"log":"msg\n","stream":"stdout","time":"2014-10-24T20:12:11.101973117Z"}
- *
- * We use ns in the last field of the timestamp for compatability.
- *
- * We keep track of the size of the log file and rotate it when we exceed
- * the log size limit (if one is set).
- */
-static void
-wr_log_msg(char *buf, int len, int from)
-{
-	struct timeval tv;
-	int olen;
-	char ts[64];
-	char nbuf[BUFSIZ * 2];
-	char obuf[BUFSIZ * 2];
-	static boolean_t log_wr_err = B_FALSE;
-
-	if (logfd == -1)
-		return;
-
-	escape_json(buf, len, nbuf, sizeof (nbuf));
-
-	if (gettimeofday(&tv, NULL) != 0)
-		return;
-	(void) strftime(ts, sizeof (ts), "%FT%T", gmtime(&tv.tv_sec));
-
-	olen = snprintf(obuf, sizeof (obuf),
-	    "{\"log\":\"%s\",\"stream\":\"%s\",\"time\":\"%s.%ldZ\"}\n",
-	    nbuf, (from == 1) ? "stdout" : "stderr", ts, tv.tv_usec * 1000);
-
-	if (write(logfd, obuf, olen) != olen) {
-		if (!log_wr_err) {
-			zerror(zlogp, B_TRUE, "log file write error");
-			log_wr_err = B_TRUE;
-		}
-		return;
-	}
-
-	log_sz += olen;
-	if (log_rot_sz > 0 && log_sz >= log_rot_sz)
-		rotate_log();
-}
-
 /*
  * We want to sleep for a little while but need to be responsive if the zone is
  * halting. We poll/sleep on the event stream so we can notice if we're halting.
@@ -789,7 +662,7 @@ halt_sleep(int slptime)
  */
 static void
 do_zfd_io(int gzctlfd, int gzservfd, int gzerrfd, int stdinfd, int stdoutfd,
-    int stderrfd)
+    int stderrfd, int logout, int logerr)
 {
 	struct pollfd pollfds[8];
 	char ibuf[BUFSIZ + 1];
@@ -803,6 +676,7 @@ do_zfd_io(int gzctlfd, int gzservfd, int gzerrfd, int stdinfd, int stdoutfd,
 	uint_t flags = 0;
 	boolean_t stdin_ready = B_FALSE;
 	int slptime = 250;	/* initial poll sleep time in ms */
+	zlog_t *zlogp = &logsys;
 
 	/* client control socket, watch for read events */
 	pollfds[0].fd = ctlfd;
@@ -940,7 +814,7 @@ do_zfd_io(int gzctlfd, int gzservfd, int gzerrfd, int stdinfd, int stdoutfd,
 				    (errno != EAGAIN))
 					break;
 				if (cc > 0) {
-					wr_log_msg(ibuf, cc, 1);
+					logstream_write(logout, ibuf, cc);
 
 					/*
 					 * Lose output if no one is listening,
@@ -969,7 +843,7 @@ do_zfd_io(int gzctlfd, int gzservfd, int gzerrfd, int stdinfd, int stdoutfd,
 				    (errno != EAGAIN))
 					break;
 				if (cc > 0) {
-					wr_log_msg(ibuf, cc, 2);
+					logstream_write(logerr, ibuf, cc);
 
 					/*
 					 * Lose output if no one is listening,
@@ -1121,66 +995,6 @@ open_fd(zlog_t *zlogp, int id, int rw)
 	return (-1);
 }
 
-static void
-open_logfile()
-{
-	char logpath[MAXPATHLEN];
-
-	logfd = -1;
-	log_sz = 0;
-
-	(void) snprintf(logpath, sizeof (logpath), "%s/logs", zonepath);
-	(void) mkdir(logpath, 0700);
-
-	(void) snprintf(logpath, sizeof (logpath), "%s/logs/%s", zonepath,
-	    log_name);
-
-	if ((logfd = open(logpath, O_WRONLY | O_APPEND | O_CREAT,
-	    0600)) == -1) {
-		zerror(zlogp, B_TRUE, "failed to open log file");
-	} else {
-		struct stat64 sb;
-
-		if (fstat64(logfd, &sb) == 0)
-			log_sz = sb.st_size;
-	}
-}
-
-static void
-rotate_log()
-{
-	time_t t;
-	struct tm gtm;
-	char onm[MAXPATHLEN], rnm[MAXPATHLEN];
-
-	if ((t = time(NULL)) == (time_t)-1 || gmtime_r(&t, &gtm) == NULL) {
-		zerror(zlogp, B_TRUE, "failed to format time");
-		return;
-	}
-
-	(void) snprintf(rnm, sizeof (rnm),
-	    "%s/logs/%s.%d%02d%02dT%02d%02d%02dZ",
-	    zonepath, log_name, gtm.tm_year + 1900, gtm.tm_mon + 1, gtm.tm_mday,
-	    gtm.tm_hour, gtm.tm_min, gtm.tm_sec);
-	(void) snprintf(onm, sizeof (onm), "%s/logs/%s", zonepath, log_name);
-
-	(void) close(logfd);
-	if (rename(onm, rnm) != 0)
-		zerror(zlogp, B_TRUE, "failed to rotate log file");
-	open_logfile();
-}
-
-
-/* ARGSUSED */
-void
-hup_handler(int i)
-{
-	if (logfd != -1) {
-		(void) close(logfd);
-		open_logfile();
-	}
-}
-
 /*
  * Body of the worker thread to log the zfd's stdout and stderr to a log file
  * and to perform interactive IO to the stdin, stdout and stderr zfd's.
@@ -1197,24 +1011,19 @@ srvr(void *modearg)
 	int gzoutfd = -1;
 	int stdinfd = -1;
 	int stdoutfd = -1;
-	sigset_t blockset;
 	int gzerrfd = -1;
 	int stderrfd = -1;
 	int flags;
 	int len;
 	char ibuf[BUFSIZ + 1];
+	zlog_t *zlogp = &logsys;
+	int logout = -1;
+	int logerr = -1;
 
-	if (!shutting_down && mode->zmode_gzlogging)
-		open_logfile();
-
-	/*
-	 * This thread should receive SIGHUP so that it can close the log
-	 * file, and reopen it, during log rotation.
-	 */
-	sigset(SIGHUP, hup_handler);
-	(void) sigfillset(&blockset);
-	(void) sigdelset(&blockset, SIGHUP);
-	(void) thr_sigsetmask(SIG_BLOCK, &blockset, NULL);
+	if (!shutting_down && mode->zmode_gzlogging) {
+		logout = logstream_open(zlogp, log_name, "stdout", 0);
+		logerr = logstream_open(zlogp, log_name, "stderr", 0);
+	}
 
 	if (!shutting_down) {
 		if (pipe(eventstream) != 0) {
@@ -1255,7 +1064,7 @@ srvr(void *modearg)
 		}
 
 		do_zfd_io(gzctlfd, gzoutfd, gzerrfd, stdinfd, stdoutfd,
-		    stderrfd);
+		    stderrfd, logout, logerr);
 death:
 		destroy_server_sock(gzctlfd, "ctl");
 		destroy_server_sock(gzoutfd, "out");
@@ -1278,8 +1087,9 @@ death:
 	 */
 	flags = fcntl(stdoutfd, F_GETFL, 0);
 	if (fcntl(stdoutfd, F_SETFL, flags | O_NONBLOCK) != -1) {
-		while ((len = read(stdoutfd, ibuf, BUFSIZ)) > 0)
-			wr_log_msg(ibuf, len, 1);
+		while ((len = read(stdoutfd, ibuf, BUFSIZ)) > 0) {
+			logstream_write(logout, ibuf, len);
+		}
 	}
 	(void) close(stdoutfd);
 
@@ -1287,8 +1097,9 @@ death:
 		(void) close(stdinfd);
 		flags = fcntl(stderrfd, F_GETFL, 0);
 		if (fcntl(stderrfd, F_SETFL, flags | O_NONBLOCK) != -1) {
-			while ((len = read(stderrfd, ibuf, BUFSIZ)) > 0)
-				wr_log_msg(ibuf, len, 2);
+			while ((len = read(stderrfd, ibuf, BUFSIZ)) > 0) {
+				logstream_write(logerr, ibuf, len);
+			}
 		}
 		(void) close(stderrfd);
 	}
@@ -1298,8 +1109,8 @@ death:
 	eventstream[0] = -1;
 	(void) close(eventstream[1]);
 	eventstream[1] = -1;
-	if (logfd != -1)
-		(void) close(logfd);
+	logstream_close(logout);
+	logstream_close(logerr);
 }
 
 /*
@@ -1320,8 +1131,8 @@ death:
  * -t-             n      y       n
  * ---             n      n       n
  *
- * This function also obtains a maximum log size while it is reading the
- * zone configuration.
+ * This function also obtains any custom name for stdio.log while it is reading
+ * the zone configuration.
  */
 static void
 get_mode_logmax(zfd_mode_t *mode)
@@ -1373,17 +1184,6 @@ get_mode_logmax(zfd_mode_t *mode)
 			continue;
 		}
 
-		if (strcmp(ZLOG_MAXSZ, attr.zone_attr_name) == 0) {
-			char *p;
-			long lval;
-
-			p = attr.zone_attr_value;
-			lval = strtol(p, &p, 10);
-			if (*p == '\0')
-				log_rot_sz = (size_t)lval;
-			continue;
-		}
-
 		if (strcmp(ZLOG_NAME, attr.zone_attr_name) == 0) {
 			(void) strlcpy(log_name, attr.zone_attr_value,
 			    sizeof (log_name));
@@ -1397,19 +1197,18 @@ done:
 }
 
 void
-create_log_thread(zlog_t *logp, zoneid_t id)
+create_log_thread(zlog_t *logp)
 {
 	int res;
 
 	shutting_down = 0;
-	zlogp = logp;
 
 	get_mode_logmax(&mode);
 	if (mode.zmode_n_stddevs == 0)
 		return;
 
-	if (init_zfd_devs(zlogp, &mode) == -1) {
-		zerror(zlogp, B_FALSE,
+	if (init_zfd_devs(&logsys, &mode) == -1) {
+		zerror(&logsys, B_FALSE,
 		    "zfd setup: device initialization failed");
 		return;
 	}
@@ -1417,7 +1216,8 @@ create_log_thread(zlog_t *logp, zoneid_t id)
 	res = thr_create(NULL, 0, (void * (*)(void *))srvr, (void *)&mode, 0,
 	    &logger_tid);
 	if (res != 0) {
-		zerror(zlogp, B_FALSE, "error %d creating logger thread", res);
+		zerror(&logsys, B_FALSE, "error %d creating logger thread",
+		    res);
 		logger_tid = 0;
 	}
 }
@@ -1436,5 +1236,5 @@ destroy_log_thread()
 		logger_tid = 0;
 	}
 
-	(void) destroy_zfd_devs(zlogp);
+	(void) destroy_zfd_devs(&logsys);
 }
diff --git a/usr/src/cmd/zoneadmd/zoneadmd.c b/usr/src/cmd/zoneadmd/zoneadmd.c
index 60af30d40b..90aad2e141 100644
--- a/usr/src/cmd/zoneadmd/zoneadmd.c
+++ b/usr/src/cmd/zoneadmd/zoneadmd.c
@@ -141,6 +141,8 @@ static int	zone_door = -1;
 boolean_t in_death_throes = B_FALSE;	/* daemon is dying */
 boolean_t bringup_failure_recovery = B_FALSE; /* ignore certain failures */
 
+static int platlog = -1;	/* Handle for <zonepath>/logs/platform.log */
+
 #if !defined(TEXT_DOMAIN)		/* should be defined by cc -D */
 #define	TEXT_DOMAIN	"SYS_TEST"	/* Use this only if it wasn't */
 #endif
@@ -223,17 +225,14 @@ zerror(zlog_t *zlogp, boolean_t use_strerror, const char *fmt, ...)
 {
 	va_list alist;
 	char buf[MAXPATHLEN * 2]; /* enough space for err msg with a path */
-	char *bp;
+	char *bp, *bp_nozone;
 	int saved_errno = errno;
 
-	if (zlogp == NULL)
-		return;
 	if (zlogp == &logsys)
-		(void) snprintf(buf, sizeof (buf), "[zone '%s'] ",
-		    zone_name);
+		(void) snprintf(buf, sizeof (buf), "[zone '%s'] ", zone_name);
 	else
 		buf[0] = '\0';
-	bp = &(buf[strlen(buf)]);
+	bp = bp_nozone = &(buf[strlen(buf)]);
 
 	/*
 	 * In theory, the locale pointer should be set to either "C" or a
@@ -250,6 +249,12 @@ zerror(zlog_t *zlogp, boolean_t use_strerror, const char *fmt, ...)
 	if (use_strerror)
 		(void) snprintf(bp, sizeof (buf) - (bp - buf), ": %s",
 		    strerror(saved_errno));
+
+	logstream_write(platlog, bp_nozone, strlen(bp_nozone));
+	logstream_write(platlog, "\n", 1);
+	if (zlogp == NULL)
+		return;
+
 	if (zlogp == &logsys) {
 		(void) syslog(LOG_ERR, "%s", buf);
 	} else if (zlogp->logfile != NULL) {
@@ -1286,7 +1291,7 @@ zone_bootup(zlog_t *zlogp, const char *bootargs, int zstate, boolean_t debug)
 	notify_zonestatd(zone_id);
 
 	/* Startup a thread to perform zfd logging/tty svc for the zone. */
-	create_log_thread(zlogp, zone_id);
+	create_log_thread(zlogp);
 
 	if (zone_boot(zoneid) == -1) {
 		zerror(zlogp, B_TRUE, "unable to boot zone");
@@ -2168,7 +2173,7 @@ top:
 			 * so use logsys.
 			 */
 			if ((zid = getzoneidbyname(zone_name)) != -1) {
-				create_log_thread(&logsys, zid);
+				create_log_thread(&logsys);
 			}
 
 			/* recover the global configuration snapshot */
@@ -2608,6 +2613,13 @@ main(int argc, char *argv[])
 
 	openlog("zoneadmd", LOG_PID, LOG_DAEMON);
 
+	/*
+	 * Allow logging to <zonepath>/logs/<file>.
+	 */
+	logstream_init(zlogp);
+	platlog = logstream_open(zlogp, "platform.log", "zoneadmd",
+	    LS_LINE_BUFFERED);
+
 	/*
 	 * The eventstream is used to publish state changes in the zone
 	 * from the door threads to the console I/O poller.
@@ -2627,7 +2639,6 @@ main(int argc, char *argv[])
 	if (make_daemon_exclusive(zlogp) == -1)
 		goto child_out;
 
-
 	/*
 	 * Create/join a new session; we need to be careful of what we do with
 	 * the console from now on so we don't end up being the session leader
@@ -2637,9 +2648,13 @@ main(int argc, char *argv[])
 
 	/*
 	 * This thread shouldn't be receiving any signals; in particular,
-	 * SIGCHLD should be received by the thread doing the fork().
+	 * SIGCHLD should be received by the thread doing the fork().  The
+	 * exceptions are SIGHUP and SIGUSR1 for log rotation, set up by
+	 * logstream_init().
 	 */
 	(void) sigfillset(&blockset);
+	(void) sigdelset(&blockset, SIGHUP);
+	(void) sigdelset(&blockset, SIGUSR1);
 	(void) thr_sigsetmask(SIG_BLOCK, &blockset, NULL);
 
 	/*
diff --git a/usr/src/cmd/zoneadmd/zoneadmd.h b/usr/src/cmd/zoneadmd/zoneadmd.h
index 0a347e9b82..7edfabf026 100644
--- a/usr/src/cmd/zoneadmd/zoneadmd.h
+++ b/usr/src/cmd/zoneadmd/zoneadmd.h
@@ -22,7 +22,7 @@
 /*
  * Copyright (c) 2003, 2010, Oracle and/or its affiliates. All rights reserved.
  * Copyright 2014 Nexenta Systems, Inc. All rights reserved.
- * Copyright 2017 Joyent, Inc.
+ * Copyright 2018 Joyent, Inc.
  */
 
 #ifndef	_ZONEADMD_H
@@ -33,6 +33,9 @@ extern "C" {
 #endif
 
 #include <libdladm.h>
+#include <libzonecfg.h>
+#include <thread.h>
+#include <synch.h>
 
 /*
  * Multi-threaded programs should avoid MT-unsafe library calls (i.e., any-
@@ -162,8 +165,17 @@ extern void zcons_statechanged();
 /*
  * Zone FD log thread creation.
  */
-extern void create_log_thread(zlog_t *, zoneid_t);
-extern void destroy_log_thread();
+typedef enum {
+	LS_LINE_BUFFERED = 0x1		/* Write when \n found or full buffer */
+} logstream_flags_t;
+
+extern void create_log_thread(zlog_t *);
+extern void destroy_log_thread(void);
+extern void logstream_init(zlog_t *);
+extern int logstream_open(zlog_t *, const char *, const char *,
+    logstream_flags_t);
+extern void logstream_write(int, char *, int);
+extern void logstream_close(int);
 
 /*
  * Contract handling.
-- 
2.21.0

