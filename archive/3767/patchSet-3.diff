From 562fdf26392f34f2df212e0d8b5471ab43451136 Mon Sep 17 00:00:00 2001
From: Mike Gerdts <mike.gerdts@joyent.com>
Date: Wed, 28 Mar 2018 15:03:57 +0000
Subject: [PATCH] OS-6834 zfd logging needs to be more generic OS-6867 zoneadmd
 escape_json() modifies byte after input buffer OS-6868 zoneadmd escape_json()
 mishandles null and incomplete characters OS-6485 zoneadmd wr_log_msg() gets
 nanoseconds wrong

---
 usr/src/cmd/zoneadmd/Makefile.com |   2 +-
 usr/src/cmd/zoneadmd/log.c        | 913 ++++++++++++++++++++++++++++++
 usr/src/cmd/zoneadmd/zcons.c      |  24 +-
 usr/src/cmd/zoneadmd/zfd.c        | 301 ++--------
 usr/src/cmd/zoneadmd/zoneadmd.c   |  74 ++-
 usr/src/cmd/zoneadmd/zoneadmd.h   |  22 +-
 6 files changed, 1047 insertions(+), 289 deletions(-)
 create mode 100644 usr/src/cmd/zoneadmd/log.c

diff --git a/usr/src/cmd/zoneadmd/Makefile.com b/usr/src/cmd/zoneadmd/Makefile.com
index 75d7d82396..7f78fb2e05 100644
--- a/usr/src/cmd/zoneadmd/Makefile.com
+++ b/usr/src/cmd/zoneadmd/Makefile.com
@@ -30,7 +30,7 @@ include ../../Makefile.ctf
 
 ROOTCMDDIR=	$(ROOTLIB)/zones
 
-OBJS= zoneadmd.o zcons.o zfd.o vplat.o
+OBJS= zoneadmd.o zcons.o zfd.o vplat.o log.o
 
 CFLAGS += $(CCVERBOSE)
 LDLIBS += -lsocket -lzonecfg -lnsl -ldevinfo -ldevice -lnvpair \
diff --git a/usr/src/cmd/zoneadmd/log.c b/usr/src/cmd/zoneadmd/log.c
new file mode 100644
index 0000000000..73b0370beb
--- /dev/null
+++ b/usr/src/cmd/zoneadmd/log.c
@@ -0,0 +1,913 @@
+/*
+ * This file and its contents are supplied under the terms of the
+ * Common Development and Distribution License ("CDDL"), version 1.0.
+ * You may only use this file in accordance with the terms of version
+ * 1.0 of the CDDL.
+ *
+ * A full copy of the text of the CDDL should have accompanied this
+ * source.  A copy of the CDDL is also available via the Internet at
+ * http://www.illumos.org/license/CDDL.
+ */
+
+/*
+ * Copyright 2018 Joyent, Inc.
+ */
+
+/*
+ * zoneadmd logging
+ *
+ * zoneadmd logs to log files under <zonepath>/logs.  Each log entry is a json
+ * structure of the form:
+ *
+ *   {
+ *     "log": "some message\n",
+ *     "stream": "stderr",
+ *     "time": "2018-03-28T13:25:02.670423000Z"
+ *   }
+ *
+ * Unlike the example above, the entries in the log file are not pretty-printed.
+ * Messages are processed so that they have the proper json escapes for
+ * problematic characters.  Excessively long messages may be truncated.
+ *
+ * To use these interfaces:
+ *
+ *	int logid;
+ *
+ *	logstream_init(zlogp);
+ *
+ *	logid = logstream_open("stdio.log", "stdout", flags);
+ *	...
+ *	logstream_write(logid, buf, len);
+ *	...
+ *	logstream_close(logid);
+ *
+ * logstream_init() needs to be called only once.
+ *
+ * logstream_open() opens a log file (if not already open) and associates the
+ * specified stream with it.
+ *
+ * The following flag is supported:
+ *
+ *   LS_LINE_BUFFERED	Buffer writes until a newline is encountered or the
+ *			buffer fills.  This should only be used with streams
+ *			that are written to by a single thread.  The timestamp
+ *			on log messages are the time that the log entry was
+ *			written to the log file.  This means the timestamp is
+ *			the time when the console user hits enter, not the time
+ *			that the prompt was printed.
+ *
+ * Line buffering is particularly useful for bhyve console logging because
+ * bhyve's UART emulation causes read() calls in zcons.c to return far fewer
+ * than 10 characters at a time.  Without line buffering, a small number of
+ * logged characters are accompanied by about 64 characters of timestamp and
+ * other overhead.  Line buffering saves quite a lot of space and makes the log
+ * much easier to read.
+ *
+ *
+ * Log rotation
+ *
+ * Two attributes, zlog-max-size and zlog-keep-rotated are used for automatic
+ * log rotation.  zlog-max-size is the approximate maximum size of a log before
+ * it is automatically rotated.  Rotated logs are renamed as
+ * <log>.<iso-8601-stamp>.  If zlog-keep-rotated is specified and is an integer
+ * greater than zero, only that number of rotated logs will be retained.
+ *
+ * If zlog-max-size is not specified, log rotation will not happen
+ * automatically.  An external log rotation program may rename the log file(s),
+ * then send SIGHUP to zoneadmd.
+ *
+ * Log rotation can be forced with SIGUSR1.  In this case, the log will be
+ * rotated as though it hit the maximum size and will be subject to retention
+ * rules described above.
+ *
+ *
+ * Locking strategy
+ *
+ * Callers need not worry about locking.  In the interest of simplicity, a
+ * single global lock is used to protect the state of the log files and the
+ * associated streams.  Locking is necessary because reboots and log rotations
+ * can cause various state changes.  Without locking, races could cause log
+ * entries to be directed to the wrong file descriptors.
+ *
+ * The simplistic global lock complicates error reporting within logging
+ * routines.  zerror() must not be called while holding logging_lock.  Rather,
+ * logstream_err() should be used to log via syslog.
+ */
+
+#include <assert.h>
+#include <dirent.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <glob.h>
+#include <signal.h>
+#include <stdarg.h>
+#include <stdio.h>
+#include <strings.h>
+#include <synch.h>
+#include <syslog.h>
+#include <time.h>
+#include <thread.h>
+#include <unistd.h>
+
+#include <sys/debug.h>
+#include <sys/stat.h>
+#include <sys/sysmacros.h>
+#include <sys/time.h>
+#include <sys/types.h>
+#include <sys/varargs.h>
+
+#include "zoneadmd.h"
+
+/*
+ * Currently we only expect stdout, stderr, zoneadmd, and console.  Increase
+ * MAX_ZLOG_STREAMS if more streams are added.  If the count increases
+ * significantly, logfile_t and logstream_t elements should be dynamically
+ * allocated and the algorithms associated with opening and closing them should
+ * become more efficient.
+ */
+#define	MAX_LOG_STREAMS 4
+
+#define	ZLOG_MAXSZ	"zlog-max-size"		/* zonecfg attr */
+#define	ZLOG_KEEP	"zlog-keep-rotated"	/* zonecfg attr */
+#define	ZLOG_KEEP_MAX	1000			/* number of log files */
+
+typedef struct logfile {
+	char	lf_path[MAXPATHLEN];	/* log file name (absolute path) */
+	char	lf_name[MAXNAMELEN];	/* tail of log file name */
+	int	lf_fd;			/* file descriptor */
+	size_t	lf_size;		/* Current size */
+	boolean_t lf_write_err;		/* Avoid spamming console via logsys */
+	boolean_t lf_closing;		/* Avoid rotation recursion */
+} logfile_t;
+
+typedef struct logstream {
+	char		ls_stream[MAXNAMELEN];	/* stdout, stderr, etc. */
+	char		ls_buf[BUFSIZ * 2];	/* Not-yet written data, json */
+	int		ls_buflen;
+	logstream_flags_t ls_flags;
+	logfile_t	*ls_logfile;		/* N streams per log file */
+} logstream_t;
+
+typedef struct jsonpair {
+	const char *jp_key;
+	const char *jp_val;
+} jsonpair_t;
+
+/*
+ * MAX_LOG_STREAMS is a small number so we allocate in the simplest way.
+ */
+static logstream_t streams[MAX_LOG_STREAMS];
+static logfile_t logfiles[MAX_LOG_STREAMS];
+
+static boolean_t logging_initialized = B_FALSE;
+static uint64_t logging_rot_size;		/* See ZLOG_MAXSZ */
+static uint64_t logging_rot_keep;		/* See ZLOG_KEEP */
+static int logging_pending_sig = 0;		/* Signal recvd while logging */
+static mutex_t logging_lock;			/* The global logging lock */
+
+static void logstream_flush_all(logfile_t *);
+static void logstream_sighandler(int);
+static void rotate_log(logfile_t *);
+static size_t make_json(jsonpair_t *, int, char *, size_t);
+static void logfile_write(logfile_t *, const char *, size_t);
+
+/*
+ * If errors are encountered while logging_lock is held, we can't use zerror().
+ */
+static void
+logstream_err(boolean_t use_strerror, const char *fmt, ...)
+{
+	va_list alist;
+	char buf[MAXPATHLEN * 2];
+	char *bp;
+	int saved_errno = errno;
+
+	(void) snprintf(buf, sizeof (buf), "[zone %s] ", zone_name);
+
+	bp = &buf[strlen(buf)];
+
+	va_start(alist, fmt);
+	(void) vsnprintf(bp, sizeof (buf) - (bp - buf), fmt, alist);
+	va_end(alist);
+
+	if (use_strerror) {
+		bp = &buf[strlen(buf)];
+		(void) snprintf(bp, sizeof (buf) - (bp - buf), ": %s",
+		    strerror(saved_errno));
+	}
+	syslog(LOG_ERR, "%s", buf);
+
+	errno = saved_errno;
+}
+
+static void
+logstream_lock(void)
+{
+	int ret;
+
+	assert(logging_initialized);
+
+	ret = mutex_lock(&logging_lock);
+	assert(ret == 0);
+}
+
+static void
+logstream_unlock(void)
+{
+	int ret;
+	int err = errno;
+	int sig = logging_pending_sig;
+
+	logging_pending_sig = 0;
+	ret = mutex_unlock(&logging_lock);
+	assert(ret == 0);
+
+	/*
+	 * If a signal arrived while this thread was holding the lock, call the
+	 * handler.
+	 */
+	if (sig != 0) {
+		logstream_sighandler(sig);
+	}
+
+	errno = err;
+}
+
+static void
+logfile_write_event(logfile_t *lfp, const char *stream, const char *event)
+{
+	char buf[BUFSIZ];
+	size_t len;
+	jsonpair_t pairs[] = {
+		{ "event", event },
+		{ "stream", stream }
+	};
+
+	len = make_json(pairs, ARRAY_SIZE(pairs), buf, sizeof (buf));
+	if (len >= sizeof (buf)) {
+		logstream_err(B_FALSE, "%s: buffer too small. Need %llu bytes, "
+		    "have %llu bytes", __func__, len + 1, sizeof (buf));
+		return;
+	}
+
+	logfile_write(lfp, buf, len);
+}
+
+static void
+close_log(logfile_t *lfp, const char *why)
+{
+	int err;
+
+	assert(MUTEX_HELD(&logging_lock));
+
+	/*
+	 * Something may have gone wrong during log rotation, leading to a
+	 * zombie log.
+	 */
+	if (lfp->lf_fd == -1) {
+		return;
+	}
+
+	lfp->lf_closing = B_TRUE;
+
+	logstream_flush_all(lfp);
+
+	logfile_write_event(lfp, "logfile", why);
+
+	err = close(lfp->lf_fd);
+	assert(err == 0);
+
+	lfp->lf_size = 0;
+	lfp->lf_fd = -1;
+}
+
+static void
+open_log(logfile_t *lfp, const char *why)
+{
+	struct stat64 sb;
+	int err;
+
+	assert(MUTEX_HELD(&logging_lock));
+	assert(lfp->lf_fd == -1);
+
+	lfp->lf_fd = open(lfp->lf_path,
+	    O_WRONLY | O_APPEND | O_CREAT | O_CLOEXEC, 0600);
+	if (lfp->lf_fd == -1) {
+		logstream_err(B_TRUE, "Cannot open log file %s",
+		    lfp->lf_path);
+		lfp->lf_write_err = B_TRUE;
+		return;
+	}
+
+	err = fstat64(lfp->lf_fd, &sb);
+	assert(err == 0);
+	lfp->lf_size = sb.st_size;
+	lfp->lf_write_err = B_FALSE;
+	lfp->lf_closing = B_FALSE;
+
+	logfile_write_event(lfp, "logfile", why);
+}
+
+static void
+logstream_sighandler(int sig)
+{
+	int i;
+
+	/*
+	 * Protect against recursive mutex enters when a signal comes during
+	 * logging.  This will cause this function to be called again just after
+	 * this thread drops the lock.
+	 */
+	if (MUTEX_HELD(&logging_lock)) {
+		logging_pending_sig = sig;
+		return;
+	}
+
+	logstream_lock();
+
+	for (i = 0; i < ARRAY_SIZE(logfiles); i++) {
+		/* Inactive logfile slot */
+		if (logfiles[i].lf_name[0] == '\0') {
+			continue;
+		}
+
+		switch (sig) {
+		case SIGHUP:
+			close_log(&logfiles[i], "close-rotate");
+			open_log(&logfiles[i], "open-rotate");
+			break;
+		case SIGUSR1:
+			rotate_log(&logfiles[i]);
+			break;
+		default:
+			logstream_err(B_FALSE, "unhandled signal %d", sig);
+		}
+	}
+
+	logstream_unlock();
+}
+
+static void
+get_attr_uint64(zlog_t *zlogp, zone_dochandle_t handle, const char *name,
+    uint64_t max, uint64_t *valp)
+{
+	struct zone_attrtab tab = { 0 };
+	char *p;
+	uint64_t val;
+
+	ASSERT(!MUTEX_HELD(&logging_lock));
+
+	(void) strlcpy(tab.zone_attr_name, name, sizeof (tab.zone_attr_name));
+	if (zonecfg_lookup_attr(handle, &tab) != Z_OK) {
+		return;
+	}
+
+	errno = 0;
+	val = strtol(tab.zone_attr_value, &p, 10);
+	if (errno != 0 && *p == '\0') {
+		zerror(zlogp, errno != 0, "Bad value '%s' for 'attr name=%s'",
+		    tab.zone_attr_value, tab.zone_attr_name);
+		return;
+	}
+	if (val > max) {
+		zerror(zlogp, B_FALSE, "Value of attr '%s' is too large. "
+		    "Reducing to %lu", name, max);
+		val = max;
+	}
+
+	*valp = val;
+}
+
+void
+logstream_init(zlog_t *zlogp)
+{
+	zone_dochandle_t handle;
+	int err;
+	int i;
+
+	assert(!logging_initialized);
+
+	err = mutex_init(&logging_lock, USYNC_THREAD | LOCK_ERRORCHECK, 0);
+	assert(err == 0);
+
+	for (i = 0; i < ARRAY_SIZE(logfiles); i++) {
+		logfiles[i].lf_fd = -1;
+	}
+
+	logging_initialized = B_TRUE;
+
+	/* Now it is safe to use zlogp */
+
+	if ((handle = zonecfg_init_handle()) == NULL ||
+	    zonecfg_get_handle(zone_name, handle) != Z_OK) {
+		zerror(zlogp, B_FALSE, "failed to open zone configuration "
+		    "while initializing logging");
+	} else {
+		get_attr_uint64(zlogp, handle, ZLOG_MAXSZ, UINT64_MAX,
+		    &logging_rot_size);
+		get_attr_uint64(zlogp, handle, ZLOG_KEEP, ZLOG_KEEP_MAX,
+		    &logging_rot_keep);
+	}
+
+	zonecfg_fini_handle(handle);
+
+	/*
+	 * This thread should receive SIGHUP so that it can close the log
+	 * file and reopen it during log rotation.  SIGUSR1 can be used to force
+	 * a log rotation.
+	 */
+	sigset(SIGHUP, logstream_sighandler);
+	sigset(SIGUSR1, logstream_sighandler);
+}
+
+/*
+ * Rotate a single log file.  The global lock must be held while this is called.
+ */
+static void
+rotate_log(logfile_t *lfp)
+{
+	time_t t;
+	struct tm gtm;
+	char path[MAXPATHLEN];
+	int64_t i;
+	size_t len;
+	glob_t glb = { 0 };
+	int err;
+
+	assert(MUTEX_HELD(&logging_lock));
+
+	if (lfp->lf_closing) {
+		return;
+	}
+
+	if ((t = time(NULL)) == (time_t)-1 || gmtime_r(&t, &gtm) == NULL) {
+		logstream_err(B_TRUE, "failed to format time");
+		return;
+	}
+
+	(void) snprintf(path, sizeof (path), "%s.%04d%02d%02dT%02d%02d%02dZ",
+	    lfp->lf_path, gtm.tm_year + 1900, gtm.tm_mon + 1, gtm.tm_mday,
+	    gtm.tm_hour, gtm.tm_min, gtm.tm_sec);
+
+	if (rename(lfp->lf_path, path) != 0) {
+		logstream_err(B_TRUE, "failed to rotate log file "
+		    "'%s' to '%s'", lfp->lf_path, path);
+	}
+
+	close_log(lfp, "close-rotate");
+	open_log(lfp, "open-rotate");
+
+	if (logging_rot_keep == 0) {
+		return;
+	}
+
+	/*
+	 * Remove old logs.
+	 */
+	len = snprintf(path, sizeof (path),
+	    /* <lf_path>.YYYYmmdd */
+	    "%s.[12][0-9][0-9][0-9][01][0-9][0-3][0-9]"
+	    /* THHMMSSZ */
+	    "T[012][0-9][0-5][0-9][0-6][0-9]Z", lfp->lf_path);
+	if (len >= sizeof (path)) {
+		logstream_err(B_FALSE, "log rotation glob too long");
+		return;
+	}
+
+	if ((err = glob(path, GLOB_LIMIT, NULL, &glb)) != 0) {
+		if (err != GLOB_NOMATCH) {
+			globfree(&glb);
+			logstream_err(B_TRUE, "glob terminated with error %d",
+			    err);
+		}
+		return;
+	}
+
+	if (glb.gl_pathc <= logging_rot_keep) {
+		globfree(&glb);
+		return;
+	}
+
+	for (i = glb.gl_pathc - logging_rot_keep - 1; i >= 0; i--) {
+		if (unlink(glb.gl_pathv[i]) != 0) {
+			logstream_err(B_TRUE, "log rotation could not remove "
+			    "%s", glb.gl_pathv[i]);
+		}
+	}
+	globfree(&glb);
+}
+
+/*
+ * Modify the input string with json escapes. Since the destination can thus
+ * be larger than the source, multiple calls may be required to fully convert
+ * sbuf to json.
+ *
+ *   sbuf, slen		Source buffer and the number of bytes in it to process
+ *   dbuf, dlen		Destination buffer and its size.  On return, the result
+ *			is always null terminated.
+ *   scntp		On return, *scntp stores number of scnt bytes consumed
+ *   dcntp		On return, *dcntp stores number of bytes stored in dcnt,
+ *			excluding trailing nul.
+ *   nlp		If non-NULL, line-buffered mode is enabled.  Processing
+ *			will stop at the first newline and *nlp will be set to
+ *			true.
+ *
+ * This function makes no attempt to handle wide characters properly because
+ * the messages that come in may be using any character encoding.  Since
+ * characters other than 7-bit ASCII are not directly readable in the log
+ * anyway, it is better to log the raw data and leave it to specialized log
+ * readers to interpret non-ASCII data.
+ */
+static void
+escape_json(const char *sbuf, int slen, char *dbuf, int dlen, int *scntp,
+    int *dcntp, boolean_t *nlp)
+{
+	int i;
+	char c;
+	const char *save_sbuf = sbuf;
+	const char *sbuf_end = sbuf + slen - 1;
+
+	if (nlp != NULL) {
+		*nlp = B_FALSE;
+	}
+
+	i = 0;
+	while (i < (dlen - 1) && sbuf <= sbuf_end) {
+		c = sbuf[0];
+
+		switch (c) {
+		case '\\':
+			dbuf[i++] = '\\';
+			dbuf[i++] = '\\';
+			break;
+
+		case '"':
+			dbuf[i++] = '\\';
+			dbuf[i++] = '"';
+			break;
+
+		case '\b':
+			dbuf[i++] = '\\';
+			dbuf[i++] = 'b';
+			break;
+
+		case '\f':
+			dbuf[i++] = '\\';
+			dbuf[i++] = 'f';
+			break;
+
+		case '\n':
+			dbuf[i++] = '\\';
+			dbuf[i++] = 'n';
+			if (nlp != NULL) {
+				*nlp = B_TRUE;
+				sbuf++;
+				goto out;
+			}
+			break;
+
+		case '\r':
+			dbuf[i++] = '\\';
+			dbuf[i++] = 'r';
+			break;
+
+		case '\t':
+			dbuf[i++] = '\\';
+			dbuf[i++] = 't';
+			break;
+
+		default:
+			if (c >= 0x20 && c < 0x7f) {
+				dbuf[i++] = c;
+			} else {
+				int len;
+
+				len = snprintf(&dbuf[i], (dlen - i), "\\u%04x",
+				    (int)(0xff & c));
+				if (len >= dlen - i) {
+					/* Buffer is full. Force a flush. */
+					if (nlp != NULL) {
+						*nlp = B_TRUE;
+					}
+					goto out;
+				}
+
+				i += len;
+			}
+			break;
+		}
+		sbuf++;
+	}
+
+out:
+	dbuf[i] = '\0';
+
+	*dcntp = i;
+	*scntp = sbuf - save_sbuf;
+
+	assert(*dcntp < dlen);
+	assert(*scntp <= slen);
+
+	/* Buffer is full. Force a flush. */
+	if (nlp != NULL && i == dlen - 1) {
+		*nlp = B_TRUE;
+	}
+}
+
+/*
+ * Like write(2), but to a logfile_t and with retries on short writes.
+ */
+static void
+logfile_write(logfile_t *lfp, const char *buf, size_t buflen)
+{
+	ssize_t wlen;
+	size_t wanted = buflen;
+
+	while (buflen > 0) {
+		wlen = write(lfp->lf_fd, buf, buflen);
+		if (wlen == -1) {
+			if (lfp->lf_write_err) {
+				lfp->lf_write_err = B_TRUE;
+				logstream_err(B_TRUE, "log file fd %d '%s': "
+				    "failed to write %llu of %llu bytes",
+				    lfp->lf_fd, lfp->lf_path, buflen, wanted);
+			}
+			return;
+		}
+		buf += wlen;
+		buflen -= wlen;
+		lfp->lf_size += wlen;
+
+		lfp->lf_write_err = B_FALSE;
+	}
+
+	if (lfp->lf_size > logging_rot_size) {
+		rotate_log(lfp);
+	}
+}
+
+/*
+ * Convert the json pairs into a json object.  A "time" element is added to
+ * every object.  Returns the number of bytes that would have been written to
+ * buf if bufsz had buf been sufficiently large (excluding the terminating null
+ * byte).  Like snprintf().
+ */
+static size_t
+make_json(jsonpair_t *pairs, int npairs, char *buf, size_t bufsz)
+{
+	struct tm gtm;
+	struct timeval tv;
+	char ts[32];
+	size_t len = 0;
+	int i;
+	const char *key, *val, *start, *end;
+
+	assert(npairs > 0);
+
+	if (gettimeofday(&tv, NULL) != 0 ||
+	    gmtime_r(&tv.tv_sec, &gtm) == NULL) {
+		logstream_err(B_TRUE, "failed to get time of day");
+		abort();
+	}
+
+	if (snprintf(ts, sizeof (ts), "%04d-%02d-%02dT%02d:%02d:%02d.%09ldZ",
+	    gtm.tm_year + 1900, gtm.tm_mon + 1, gtm.tm_mday,
+	    gtm.tm_hour, gtm.tm_min, gtm.tm_sec, tv.tv_usec * 100) >=
+	    sizeof (ts)) {
+		logstream_err(B_FALSE, "timestamp buffer too small");
+		abort();
+	}
+
+	start = "{";
+	end = "";
+	for (i = 0; i <= npairs; i++) {
+		if (i < npairs) {
+			key = pairs[i].jp_key;
+			val = pairs[i].jp_val;
+		} else {
+			key = "time";
+			val = ts;
+			end = "}\n";
+		}
+
+		len += snprintf(bufsz > len ? buf + len : NULL,
+		    bufsz > len ? bufsz - len : 0, "%s\"%s\":\"%s\"%s",
+		    start, key, val, end);
+
+		start = ",";
+	}
+
+	return (len);
+}
+
+static void
+logstream_write_json(logstream_t *lsp)
+{
+	char obuf[sizeof (lsp->ls_buf) + sizeof (lsp->ls_stream) + 64];
+	size_t len;
+	jsonpair_t pairs[] = {
+		{ "log", lsp->ls_buf },
+		{ "stream", lsp->ls_stream },
+	};
+
+	if (lsp->ls_buflen == 0) {
+		return;
+	}
+
+	len = make_json(pairs, ARRAY_SIZE(pairs), obuf, sizeof (obuf));
+	lsp->ls_buflen = 0;
+	if (len >= sizeof (obuf)) {
+		logstream_err(B_FALSE, "%s: buffer too small. Need %llu bytes, "
+		    "have %llu bytes", __func__, len + 1, sizeof (obuf));
+		return;
+	}
+
+	logfile_write(lsp->ls_logfile, obuf, len);
+}
+
+/*
+ * We output to the log file as json.
+ * ex. for string 'msg\n' on the zone's stdout:
+ *    {"log":"msg\n","stream":"stdout","time":"2014-10-24T20:12:11.101973117Z"}
+ *
+ * We use ns in the last field of the timestamp for compatibility.
+ *
+ * We keep track of the size of the log file and rotate it when we exceed
+ * the log size limit (if one is set).
+ */
+void
+logstream_write(int ls, char *buf, int len)
+{
+	logstream_t *lsp;
+	int scnt, dcnt;
+	boolean_t newline;
+	boolean_t buffered;
+
+	if (ls == -1 || len == 0) {
+		return;
+	}
+	assert(ls >= 0 && ls < ARRAY_SIZE(streams));
+
+	logstream_lock();
+
+	lsp = &streams[ls];
+	if (lsp->ls_stream[0] == '\0' || lsp->ls_logfile == NULL || len == 0) {
+		logstream_unlock();
+		return;
+	}
+
+	buffered = !!(lsp->ls_flags & LS_LINE_BUFFERED);
+
+	do {
+		escape_json(buf, len, lsp->ls_buf + lsp->ls_buflen,
+		    sizeof (lsp->ls_buf) - lsp->ls_buflen,
+		    &scnt, &dcnt, buffered ? &newline : NULL);
+
+		lsp->ls_buflen += dcnt;
+		buf += scnt;
+		len -= scnt;
+
+		if (!buffered || newline) {
+			logstream_write_json(lsp);
+		}
+	} while (len > 0 && (!buffered || newline));
+
+	logstream_unlock();
+}
+
+static void
+logstream_flush(int ls)
+{
+	logstream_t *lsp;
+
+	assert(MUTEX_HELD(&logging_lock));
+
+	lsp = &streams[ls];
+	if (lsp->ls_stream[0] == '\0' || lsp->ls_logfile == NULL) {
+		return;
+	}
+	logstream_write_json(lsp);
+}
+
+static void
+logstream_flush_all(logfile_t *lfp)
+{
+	int i;
+
+	assert(MUTEX_HELD(&logging_lock));
+
+	for (i = 0; i < ARRAY_SIZE(streams); i++) {
+		if (streams[i].ls_logfile == lfp) {
+			logstream_flush(i);
+		}
+	}
+}
+
+int
+logstream_open(const char *logname, const char *stream, logstream_flags_t flags)
+{
+	int ls = -1;
+	int i;
+	logstream_t *lsp;
+	logfile_t *lfp = NULL;
+
+	assert(strlen(logname) < sizeof (lfp->lf_name));
+	assert(strlen(stream) < sizeof (lsp->ls_stream));
+
+	logstream_lock();
+
+	/*
+	 * Find an empty logstream_t and verify that the stream is not already
+	 * open.
+	 */
+	for (i = 0; i < ARRAY_SIZE(streams); i++) {
+		if (ls == -1 && streams[i].ls_stream[0] == '\0') {
+			assert(streams[i].ls_logfile == NULL);
+			ls = i;
+			continue;
+		}
+		if (strcmp(stream, streams[i].ls_stream) == 0) {
+			logstream_unlock();
+			logstream_err(B_FALSE, "log stream %s already open",
+			    stream);
+			return (-1);
+		}
+	}
+	assert(ls != -1);
+
+	/* Find an existing or available logfile_t */
+	for (i = 0; i < ARRAY_SIZE(logfiles); i++) {
+		if (lfp == NULL && logfiles[i].lf_name[0] == '\0') {
+			lfp = &logfiles[i];
+		}
+		if (strcmp(logname, logfiles[i].lf_name) == 0) {
+			lfp = &logfiles[i];
+			break;
+		}
+	}
+	if (lfp->lf_name[0] == '\0') {
+		(void) strlcpy(lfp->lf_name, logname, sizeof (lfp->lf_name));
+		(void) snprintf(lfp->lf_path, sizeof (lfp->lf_path), "%s/logs",
+		    zonepath);
+		(void) mkdir(lfp->lf_path, 0700);
+
+		(void) snprintf(lfp->lf_path, sizeof (lfp->lf_path),
+		    "%s/logs/%s", zonepath, logname);
+
+		open_log(lfp, "open");
+		if (lfp->lf_fd == -1) {
+			logstream_unlock();
+			return (-1);
+		}
+	}
+
+	lsp = &streams[ls];
+	(void) strlcpy(lsp->ls_stream, stream, sizeof (lsp->ls_stream));
+
+	lsp->ls_flags = flags;
+	lsp->ls_logfile = lfp;
+
+	logstream_unlock();
+
+	return (ls);
+}
+
+void
+logstream_close(int ls)
+{
+	logstream_t *lsp;
+	logfile_t *lfp;
+	int i;
+
+	if (ls == -1) {
+		return;
+	}
+	assert(ls >= 0 && ls < ARRAY_SIZE(streams));
+
+	logstream_lock();
+	logstream_flush(ls);
+
+	lsp = &streams[ls];
+	lfp = lsp->ls_logfile;
+
+	assert(lsp->ls_stream[0] != '\0');
+	assert(lfp != NULL);
+
+	(void) memset(lsp, 0, sizeof (*lsp));
+
+	for (i = 0; i < ARRAY_SIZE(streams); i++) {
+		if (streams[i].ls_logfile == lfp) {
+			logstream_unlock();
+			return;
+		}
+	}
+
+	/* No more streams using this log file so return to initial state */
+
+	close_log(lfp, "close");
+
+	(void) memset(lfp, 0, sizeof (*lfp));
+	lfp->lf_fd = -1;
+
+	logstream_unlock();
+}
diff --git a/usr/src/cmd/zoneadmd/zcons.c b/usr/src/cmd/zoneadmd/zcons.c
index af4fafe46a..ce398faf30 100644
--- a/usr/src/cmd/zoneadmd/zcons.c
+++ b/usr/src/cmd/zoneadmd/zcons.c
@@ -22,7 +22,7 @@
 /*
  * Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
- * Copyright 2015 Joyent, Inc.
+ * Copyright 2018 Joyent, Inc.
  * Copyright 2015 Nexenta Systems, Inc. All rights reserved.
  */
 
@@ -40,10 +40,10 @@
  *
  *                                      Global Zone | Non-Global Zone
  *                        .--------------.          |
- *        .-----------.   | zoneadmd -z  |          | .--------. .---------.
- *        | zlogin -C |   |     myzone   |          | | ttymon | | syslogd |
- *        `-----------'   `--------------'          | `--------' `---------'
- *                  |       |       | |             |      |       |
+ *        .-----------.   | zoneadmd -z  |--.       | .--------. .---------.
+ *        | zlogin -C |   |     myzone   |  |       | | ttymon | | syslogd |
+ *        `-----------'   `--------------'  V       | `--------' `---------'
+ *                  |       |       | | console.log |      |       |
  *  User            |       |       | |             |      V       V
  * - - - - - - - - -|- - - -|- - - -|-|- - - - - - -|- - /dev/zconsole - - -
  *  Kernel          V       V       | |                        |
@@ -81,6 +81,8 @@
  *   functions as a two-way proxy for console I/O, relaying user input
  *   to the master side of the console, and relaying output from the
  *   zone to the user.
+ *
+ * - Logging output to <zonepath>/logs/console.log.
  */
 
 #include <sys/types.h>
@@ -734,7 +736,7 @@ test_client(int clifd)
  * messages) can be output in the user's locale.
  */
 static void
-do_console_io(zlog_t *zlogp, int consfd, int servfd)
+do_console_io(zlog_t *zlogp, int consfd, int servfd, int conslog)
 {
 	struct pollfd pollfds[4];
 	char ibuf[BUFSIZ];
@@ -783,6 +785,9 @@ do_console_io(zlog_t *zlogp, int consfd, int servfd)
 				if (cc <= 0 && (errno != EINTR) &&
 				    (errno != EAGAIN))
 					break;
+
+				logstream_write(conslog, ibuf, cc);
+
 				/*
 				 * Lose I/O if no one is listening
 				 */
@@ -939,6 +944,9 @@ serve_console(zlog_t *zlogp)
 	zone_state_t zstate;
 	char conspath[MAXPATHLEN];
 	static boolean_t cons_warned = B_FALSE;
+	int conslog;
+
+	conslog = logstream_open("console.log", "console", LS_LINE_BUFFERED);
 
 	(void) snprintf(conspath, sizeof (conspath),
 	    "/dev/zcons/%s/%s", zone_name, ZCONS_MASTER_NAME);
@@ -1005,7 +1013,7 @@ serve_console(zlog_t *zlogp)
 			goto death;
 		}
 
-		do_console_io(zlogp, masterfd, serverfd);
+		do_console_io(zlogp, masterfd, serverfd, conslog);
 
 		/*
 		 * We would prefer not to do this, but hostile zone processes
@@ -1046,4 +1054,6 @@ death:
 
 	destroy_console_sock(serverfd);
 	(void) destroy_console_devs(zlogp);
+
+	logstream_close(conslog);
 }
diff --git a/usr/src/cmd/zoneadmd/zfd.c b/usr/src/cmd/zoneadmd/zfd.c
index 48334b182a..3ccc6575da 100644
--- a/usr/src/cmd/zoneadmd/zfd.c
+++ b/usr/src/cmd/zoneadmd/zfd.c
@@ -83,16 +83,10 @@
 
 #include "zoneadmd.h"
 
-static zlog_t	*zlogp;
 static int	shutting_down = 0;
 static thread_t logger_tid;
-static int	logfd = -1;
-static size_t	log_sz = 0;
-static size_t	log_rot_sz = 0;
 static char	log_name[MAXNAMELEN] = "stdio.log";
 
-static void rotate_log();
-
 /*
  * The eventstream is a simple one-directional flow of messages implemented
  * with a pipe. It is used to wake up the poller when it needs to shutdown.
@@ -100,7 +94,6 @@ static void rotate_log();
 static int eventstream[2] = {-1, -1};
 
 #define	ZLOG_MODE		"zlog-mode"
-#define	ZLOG_MAXSZ		"zlog-max-size"
 #define	ZLOG_NAME		"zlog-name"
 #define	ZFDNEX_DEVTREEPATH	"/pseudo/zfdnex@2"
 #define	ZFDNEX_FILEPATH		"/devices/pseudo/zfdnex@2"
@@ -342,7 +335,7 @@ error:
 }
 
 static int
-init_server_sock(zlog_t *zlogp, int *servfd, char *nm)
+init_server_sock(int *servfd, char *nm)
 {
 	int resfd = -1;
 	struct sockaddr_un servaddr;
@@ -353,20 +346,21 @@ init_server_sock(zlog_t *zlogp, int *servfd, char *nm)
 	    SERVER_SOCKPATH, zone_name, nm);
 
 	if ((resfd = socket(AF_UNIX, SOCK_STREAM, 0)) == -1) {
-		zerror(zlogp, B_TRUE, "server setup: could not create socket");
+		zerror(&logplat, B_TRUE,
+		    "server setup: could not create socket");
 		goto err;
 	}
 	(void) unlink(servaddr.sun_path);
 
 	if (bind(resfd, (struct sockaddr *)&servaddr, sizeof (servaddr))
 	    == -1) {
-		zerror(zlogp, B_TRUE,
+		zerror(&logplat, B_TRUE,
 		    "server setup: could not bind to socket");
 		goto err;
 	}
 
 	if (listen(resfd, 4) == -1) {
-		zerror(zlogp, B_TRUE,
+		zerror(&logplat, B_TRUE,
 		    "server setup: could not listen on socket");
 		goto err;
 	}
@@ -615,127 +609,6 @@ test_client(int clifd)
 	return (0);
 }
 
-/*
- * Modify the input string with json escapes. Since the destination can thus
- * be larger than the source, it may get truncated, although we do use a
- * larger buffer.
- */
-static void
-escape_json(char *sbuf, int slen, char *dbuf, int dlen)
-{
-	int i;
-	mbstate_t mbr;
-	wchar_t c;
-	size_t sz;
-
-	bzero(&mbr, sizeof (mbr));
-
-	sbuf[slen] = '\0';
-	i = 0;
-	while (i < dlen && (sz = mbrtowc(&c, sbuf, MB_CUR_MAX, &mbr)) > 0) {
-		switch (c) {
-		case '\\':
-			dbuf[i++] = '\\';
-			dbuf[i++] = '\\';
-			break;
-
-		case '"':
-			dbuf[i++] = '\\';
-			dbuf[i++] = '"';
-			break;
-
-		case '\b':
-			dbuf[i++] = '\\';
-			dbuf[i++] = 'b';
-			break;
-
-		case '\f':
-			dbuf[i++] = '\\';
-			dbuf[i++] = 'f';
-			break;
-
-		case '\n':
-			dbuf[i++] = '\\';
-			dbuf[i++] = 'n';
-			break;
-
-		case '\r':
-			dbuf[i++] = '\\';
-			dbuf[i++] = 'r';
-			break;
-
-		case '\t':
-			dbuf[i++] = '\\';
-			dbuf[i++] = 't';
-			break;
-
-		default:
-			if ((c >= 0x00 && c <= 0x1f) ||
-			    (c > 0x7f && c <= 0xffff)) {
-
-				i += snprintf(&dbuf[i], (dlen - i), "\\u%04x",
-				    (int)(0xffff & c));
-			} else if (c >= 0x20 && c <= 0x7f) {
-				dbuf[i++] = 0xff & c;
-			}
-
-			break;
-		}
-		sbuf += sz;
-	}
-
-	if (i == dlen)
-		dbuf[--i] = '\0';
-	else
-		dbuf[i] = '\0';
-}
-
-/*
- * We output to the log file as json.
- * ex. for string 'msg\n' on the zone's stdout:
- *    {"log":"msg\n","stream":"stdout","time":"2014-10-24T20:12:11.101973117Z"}
- *
- * We use ns in the last field of the timestamp for compatability.
- *
- * We keep track of the size of the log file and rotate it when we exceed
- * the log size limit (if one is set).
- */
-static void
-wr_log_msg(char *buf, int len, int from)
-{
-	struct timeval tv;
-	int olen;
-	char ts[64];
-	char nbuf[BUFSIZ * 2];
-	char obuf[BUFSIZ * 2];
-	static boolean_t log_wr_err = B_FALSE;
-
-	if (logfd == -1)
-		return;
-
-	escape_json(buf, len, nbuf, sizeof (nbuf));
-
-	if (gettimeofday(&tv, NULL) != 0)
-		return;
-	(void) strftime(ts, sizeof (ts), "%FT%T", gmtime(&tv.tv_sec));
-
-	olen = snprintf(obuf, sizeof (obuf),
-	    "{\"log\":\"%s\",\"stream\":\"%s\",\"time\":\"%s.%ldZ\"}\n",
-	    nbuf, (from == 1) ? "stdout" : "stderr", ts, tv.tv_usec * 1000);
-
-	if (write(logfd, obuf, olen) != olen) {
-		if (!log_wr_err) {
-			zerror(zlogp, B_TRUE, "log file write error");
-			log_wr_err = B_TRUE;
-		}
-		return;
-	}
-
-	log_sz += olen;
-	if (log_rot_sz > 0 && log_sz >= log_rot_sz)
-		rotate_log();
-}
-
 /*
  * We want to sleep for a little while but need to be responsive if the zone is
  * halting. We poll/sleep on the event stream so we can notice if we're halting.
@@ -789,7 +662,7 @@ halt_sleep(int slptime)
  */
 static void
 do_zfd_io(int gzctlfd, int gzservfd, int gzerrfd, int stdinfd, int stdoutfd,
-    int stderrfd)
+    int stderrfd, int logout, int logerr)
 {
 	struct pollfd pollfds[8];
 	char ibuf[BUFSIZ + 1];
@@ -845,7 +718,7 @@ do_zfd_io(int gzctlfd, int gzservfd, int gzerrfd, int stdinfd, int stdoutfd,
 
 		ret = poll(pollfds, 8, -1);
 		if (ret == -1 && errno != EINTR) {
-			zerror(zlogp, B_TRUE, "poll failed");
+			zerror(&logplat, B_TRUE, "poll failed");
 			/* we are hosed, close connection */
 			break;
 		}
@@ -858,7 +731,7 @@ do_zfd_io(int gzctlfd, int gzservfd, int gzerrfd, int stdinfd, int stdoutfd,
 		} else if (pollfds[0].revents) {
 			/* bail if any error occurs */
 			pollerr = pollfds[0].revents;
-			zerror(zlogp, B_FALSE, "closing connection "
+			zerror(&logplat, B_FALSE, "closing connection "
 			    "with control channel, pollerr %d\n", pollerr);
 			break;
 		}
@@ -882,7 +755,7 @@ do_zfd_io(int gzctlfd, int gzservfd, int gzerrfd, int stdinfd, int stdoutfd,
 				} else if (pollfds[1].revents & (POLLERR |
 				    POLLNVAL))  {
 					pollerr = pollfds[1].revents;
-					zerror(zlogp, B_FALSE,
+					zerror(&logplat, B_FALSE,
 					    "closing connection "
 					    "with client, pollerr %d\n",
 					    pollerr);
@@ -940,7 +813,7 @@ do_zfd_io(int gzctlfd, int gzservfd, int gzerrfd, int stdinfd, int stdoutfd,
 				    (errno != EAGAIN))
 					break;
 				if (cc > 0) {
-					wr_log_msg(ibuf, cc, 1);
+					logstream_write(logout, ibuf, cc);
 
 					/*
 					 * Lose output if no one is listening,
@@ -951,7 +824,7 @@ do_zfd_io(int gzctlfd, int gzservfd, int gzerrfd, int stdinfd, int stdoutfd,
 				}
 			} else {
 				pollerr = pollfds[2].revents;
-				zerror(zlogp, B_FALSE,
+				zerror(&logplat, B_FALSE,
 				    "closing connection with stdout zfd, "
 				    "pollerr %d\n", pollerr);
 				break;
@@ -969,7 +842,7 @@ do_zfd_io(int gzctlfd, int gzservfd, int gzerrfd, int stdinfd, int stdoutfd,
 				    (errno != EAGAIN))
 					break;
 				if (cc > 0) {
-					wr_log_msg(ibuf, cc, 2);
+					logstream_write(logerr, ibuf, cc);
 
 					/*
 					 * Lose output if no one is listening,
@@ -981,7 +854,7 @@ do_zfd_io(int gzctlfd, int gzservfd, int gzerrfd, int stdinfd, int stdoutfd,
 				}
 			} else {
 				pollerr = pollfds[3].revents;
-				zerror(zlogp, B_FALSE,
+				zerror(&logplat, B_FALSE,
 				    "closing connection with stderr zfd, "
 				    "pollerr %d\n", pollerr);
 				break;
@@ -1025,7 +898,7 @@ do_zfd_io(int gzctlfd, int gzservfd, int gzerrfd, int stdinfd, int stdoutfd,
 				 * first. If we see this, tear everything down
 				 * and start over.
 				 */
-				zerror(zlogp, B_FALSE, "GZ zfd stdin/stdout "
+				zerror(&logplat, B_FALSE, "GZ zfd stdin/stdout "
 				    "connection attempt with no GZ control\n");
 				break;
 			}
@@ -1046,7 +919,7 @@ do_zfd_io(int gzctlfd, int gzservfd, int gzerrfd, int stdinfd, int stdoutfd,
 				/*
 				 * Same conditions apply to stderr as stdin/out.
 				 */
-				zerror(zlogp, B_FALSE, "GZ zfd stderr "
+				zerror(&logplat, B_FALSE, "GZ zfd stderr "
 				    "connection attempt with no GZ control\n");
 				break;
 			}
@@ -1082,7 +955,7 @@ do_zfd_io(int gzctlfd, int gzservfd, int gzerrfd, int stdinfd, int stdoutfd,
 }
 
 static int
-open_fd(zlog_t *zlogp, int id, int rw)
+open_fd(int id, int rw)
 {
 	int fd;
 	int flag = O_NONBLOCK | O_NOCTTY | O_CLOEXEC;
@@ -1104,7 +977,7 @@ open_fd(zlog_t *zlogp, int id, int rw)
 			 * control element is received.
 			 */
 			if (ioctl(fd, I_SRDOPT, RNORM|RPROTDIS) == -1) {
-				zerror(zlogp, B_TRUE,
+				zerror(&logplat, B_TRUE,
 				    "failed to set options on zfd");
 				return (-1);
 			}
@@ -1117,70 +990,10 @@ open_fd(zlog_t *zlogp, int id, int rw)
 		(void) sleep(1);
 	}
 
-	zerror(zlogp, B_TRUE, "failed to open zfd");
+	zerror(&logplat, B_TRUE, "failed to open zfd");
 	return (-1);
 }
 
-static void
-open_logfile()
-{
-	char logpath[MAXPATHLEN];
-
-	logfd = -1;
-	log_sz = 0;
-
-	(void) snprintf(logpath, sizeof (logpath), "%s/logs", zonepath);
-	(void) mkdir(logpath, 0700);
-
-	(void) snprintf(logpath, sizeof (logpath), "%s/logs/%s", zonepath,
-	    log_name);
-
-	if ((logfd = open(logpath, O_WRONLY | O_APPEND | O_CREAT,
-	    0600)) == -1) {
-		zerror(zlogp, B_TRUE, "failed to open log file");
-	} else {
-		struct stat64 sb;
-
-		if (fstat64(logfd, &sb) == 0)
-			log_sz = sb.st_size;
-	}
-}
-
-static void
-rotate_log()
-{
-	time_t t;
-	struct tm gtm;
-	char onm[MAXPATHLEN], rnm[MAXPATHLEN];
-
-	if ((t = time(NULL)) == (time_t)-1 || gmtime_r(&t, &gtm) == NULL) {
-		zerror(zlogp, B_TRUE, "failed to format time");
-		return;
-	}
-
-	(void) snprintf(rnm, sizeof (rnm),
-	    "%s/logs/%s.%d%02d%02dT%02d%02d%02dZ",
-	    zonepath, log_name, gtm.tm_year + 1900, gtm.tm_mon + 1, gtm.tm_mday,
-	    gtm.tm_hour, gtm.tm_min, gtm.tm_sec);
-	(void) snprintf(onm, sizeof (onm), "%s/logs/%s", zonepath, log_name);
-
-	(void) close(logfd);
-	if (rename(onm, rnm) != 0)
-		zerror(zlogp, B_TRUE, "failed to rotate log file");
-	open_logfile();
-}
-
-
-/* ARGSUSED */
-void
-hup_handler(int i)
-{
-	if (logfd != -1) {
-		(void) close(logfd);
-		open_logfile();
-	}
-}
-
 /*
  * Body of the worker thread to log the zfd's stdout and stderr to a log file
  * and to perform interactive IO to the stdin, stdout and stderr zfd's.
@@ -1197,65 +1010,59 @@ srvr(void *modearg)
 	int gzoutfd = -1;
 	int stdinfd = -1;
 	int stdoutfd = -1;
-	sigset_t blockset;
 	int gzerrfd = -1;
 	int stderrfd = -1;
 	int flags;
 	int len;
 	char ibuf[BUFSIZ + 1];
+	int logout = -1;
+	int logerr = -1;
 
-	if (!shutting_down && mode->zmode_gzlogging)
-		open_logfile();
-
-	/*
-	 * This thread should receive SIGHUP so that it can close the log
-	 * file, and reopen it, during log rotation.
-	 */
-	sigset(SIGHUP, hup_handler);
-	(void) sigfillset(&blockset);
-	(void) sigdelset(&blockset, SIGHUP);
-	(void) thr_sigsetmask(SIG_BLOCK, &blockset, NULL);
+	if (!shutting_down && mode->zmode_gzlogging) {
+		logout = logstream_open(log_name, "stdout", 0);
+		logerr = logstream_open(log_name, "stderr", 0);
+	}
 
 	if (!shutting_down) {
 		if (pipe(eventstream) != 0) {
-			zerror(zlogp, B_TRUE, "failed to open logger control "
-			    "pipe");
+			zerror(&logplat, B_TRUE, "failed to open logger "
+			    "control pipe");
 			return;
 		}
 	}
 
 	while (!shutting_down) {
-		if (init_server_sock(zlogp, &gzctlfd, "ctl") == -1) {
-			zerror(zlogp, B_FALSE,
+		if (init_server_sock(&gzctlfd, "ctl") == -1) {
+			zerror(&logplat, B_FALSE,
 			    "server setup: control socket init failed");
 			goto death;
 		}
-		if (init_server_sock(zlogp, &gzoutfd, "out") == -1) {
-			zerror(zlogp, B_FALSE,
+		if (init_server_sock(&gzoutfd, "out") == -1) {
+			zerror(&logplat, B_FALSE,
 			    "server setup: stdout socket init failed");
 			goto death;
 		}
-		if (init_server_sock(zlogp, &gzerrfd, "err") == -1) {
-			zerror(zlogp, B_FALSE,
+		if (init_server_sock(&gzerrfd, "err") == -1) {
+			zerror(&logplat, B_FALSE,
 			    "server setup: stderr socket init failed");
 			goto death;
 		}
 
 		if (mode->zmode_n_stddevs == 1) {
-			if ((stdinfd = open_fd(zlogp, 0, O_RDWR)) == -1) {
+			if ((stdinfd = open_fd(0, O_RDWR)) == -1) {
 				goto death;
 			}
 			stdoutfd = stdinfd;
 		} else {
-			if ((stdinfd = open_fd(zlogp, 0, O_WRONLY)) == -1 ||
-			    (stdoutfd = open_fd(zlogp, 1, O_RDONLY)) == -1 ||
-			    (stderrfd = open_fd(zlogp, 2, O_RDONLY)) == -1) {
+			if ((stdinfd = open_fd(0, O_WRONLY)) == -1 ||
+			    (stdoutfd = open_fd(1, O_RDONLY)) == -1 ||
+			    (stderrfd = open_fd(2, O_RDONLY)) == -1) {
 				goto death;
 			}
 		}
 
 		do_zfd_io(gzctlfd, gzoutfd, gzerrfd, stdinfd, stdoutfd,
-		    stderrfd);
+		    stderrfd, logout, logerr);
 death:
 		destroy_server_sock(gzctlfd, "ctl");
 		destroy_server_sock(gzoutfd, "out");
@@ -1278,8 +1085,9 @@ death:
 	 */
 	flags = fcntl(stdoutfd, F_GETFL, 0);
 	if (fcntl(stdoutfd, F_SETFL, flags | O_NONBLOCK) != -1) {
-		while ((len = read(stdoutfd, ibuf, BUFSIZ)) > 0)
-			wr_log_msg(ibuf, len, 1);
+		while ((len = read(stdoutfd, ibuf, BUFSIZ)) > 0) {
+			logstream_write(logout, ibuf, len);
+		}
 	}
 	(void) close(stdoutfd);
 
@@ -1287,8 +1095,9 @@ death:
 		(void) close(stdinfd);
 		flags = fcntl(stderrfd, F_GETFL, 0);
 		if (fcntl(stderrfd, F_SETFL, flags | O_NONBLOCK) != -1) {
-			while ((len = read(stderrfd, ibuf, BUFSIZ)) > 0)
-				wr_log_msg(ibuf, len, 2);
+			while ((len = read(stderrfd, ibuf, BUFSIZ)) > 0) {
+				logstream_write(logerr, ibuf, len);
+			}
 		}
 		(void) close(stderrfd);
 	}
@@ -1298,8 +1107,8 @@ death:
 	eventstream[0] = -1;
 	(void) close(eventstream[1]);
 	eventstream[1] = -1;
-	if (logfd != -1)
-		(void) close(logfd);
+	logstream_close(logout);
+	logstream_close(logerr);
 }
 
 /*
@@ -1320,8 +1129,8 @@ death:
  * -t-             n      y       n
  * ---             n      n       n
  *
- * This function also obtains a maximum log size while it is reading the
- * zone configuration.
+ * This function also obtains any custom name for stdio.log while it is reading
+ * the zone configuration.
  */
 static void
 get_mode_logmax(zfd_mode_t *mode)
@@ -1373,17 +1182,6 @@ get_mode_logmax(zfd_mode_t *mode)
 			continue;
 		}
 
-		if (strcmp(ZLOG_MAXSZ, attr.zone_attr_name) == 0) {
-			char *p;
-			long lval;
-
-			p = attr.zone_attr_value;
-			lval = strtol(p, &p, 10);
-			if (*p == '\0')
-				log_rot_sz = (size_t)lval;
-			continue;
-		}
-
 		if (strcmp(ZLOG_NAME, attr.zone_attr_name) == 0) {
 			(void) strlcpy(log_name, attr.zone_attr_value,
 			    sizeof (log_name));
@@ -1397,12 +1195,11 @@ done:
 }
 
 void
-create_log_thread(zlog_t *logp, zoneid_t id)
+create_log_thread(zlog_t *zlogp)
 {
 	int res;
 
 	shutting_down = 0;
-	zlogp = logp;
 
 	get_mode_logmax(&mode);
 	if (mode.zmode_n_stddevs == 0)
@@ -1423,7 +1220,7 @@ create_log_thread(zlog_t *logp, zoneid_t id)
 }
 
 void
-destroy_log_thread()
+destroy_log_thread(zlog_t *zlogp)
 {
 	if (logger_tid != 0) {
 		int stop = 1;
diff --git a/usr/src/cmd/zoneadmd/zoneadmd.c b/usr/src/cmd/zoneadmd/zoneadmd.c
index 60af30d40b..ac39c0fe80 100644
--- a/usr/src/cmd/zoneadmd/zoneadmd.c
+++ b/usr/src/cmd/zoneadmd/zoneadmd.c
@@ -128,7 +128,8 @@ char pre_statechg_hook[2 * MAXPATHLEN];
 char post_statechg_hook[2 * MAXPATHLEN];
 char query_hook[2 * MAXPATHLEN];
 
-zlog_t logsys;
+zlog_t logsys;			/* log to syslog */
+zlog_t logplat;			/* log to platform.log */
 
 mutex_t	lock = DEFAULTMUTEX;	/* to serialize stuff */
 mutex_t	msglock = DEFAULTMUTEX;	/* for calling setlocale() */
@@ -141,6 +142,8 @@ static int	zone_door = -1;
 boolean_t in_death_throes = B_FALSE;	/* daemon is dying */
 boolean_t bringup_failure_recovery = B_FALSE; /* ignore certain failures */
 
+static int platloghdl = -1;	/* Handle for <zonepath>/logs/platform.log */
+
 #if !defined(TEXT_DOMAIN)		/* should be defined by cc -D */
 #define	TEXT_DOMAIN	"SYS_TEST"	/* Use this only if it wasn't */
 #endif
@@ -223,17 +226,14 @@ zerror(zlog_t *zlogp, boolean_t use_strerror, const char *fmt, ...)
 {
 	va_list alist;
 	char buf[MAXPATHLEN * 2]; /* enough space for err msg with a path */
-	char *bp;
+	char *bp, *bp_nozone;
 	int saved_errno = errno;
 
-	if (zlogp == NULL)
-		return;
 	if (zlogp == &logsys)
-		(void) snprintf(buf, sizeof (buf), "[zone '%s'] ",
-		    zone_name);
+		(void) snprintf(buf, sizeof (buf), "[zone '%s'] ", zone_name);
 	else
 		buf[0] = '\0';
-	bp = &(buf[strlen(buf)]);
+	bp = bp_nozone = &(buf[strlen(buf)]);
 
 	/*
 	 * In theory, the locale pointer should be set to either "C" or a
@@ -250,15 +250,28 @@ zerror(zlog_t *zlogp, boolean_t use_strerror, const char *fmt, ...)
 	if (use_strerror)
 		(void) snprintf(bp, sizeof (buf) - (bp - buf), ": %s",
 		    strerror(saved_errno));
+
+	(void) strlcat(buf, "\n", sizeof (buf));
+
+	logstream_write(platloghdl, bp_nozone, strlen(bp_nozone));
+
+	if (zlogp == NULL || zlogp == &logplat) {
+		return;
+	}
+
 	if (zlogp == &logsys) {
+		bp = strrchr(buf, '\n');
+		if (bp != NULL && bp[1] == '\0') {
+			*bp = '\0';
+		}
 		(void) syslog(LOG_ERR, "%s", buf);
 	} else if (zlogp->logfile != NULL) {
-		(void) fprintf(zlogp->logfile, "%s\n", buf);
+		(void) fprintf(zlogp->logfile, "%s", buf);
 	} else {
 		size_t buflen;
 		size_t copylen;
 
-		buflen = snprintf(zlogp->log, zlogp->loglen, "%s\n", buf);
+		buflen = snprintf(zlogp->log, zlogp->loglen, "%s", buf);
 		copylen = MIN(buflen, zlogp->loglen);
 		zlogp->log += copylen;
 		zlogp->loglen -= copylen;
@@ -1108,7 +1121,7 @@ restartinit(brand_handle_t bh)
  * application will be terminated.
  */
 static boolean_t
-is_app_svc_dep(brand_handle_t bh)
+is_app_svc_dep(void)
 {
 	struct zone_attrtab a;
 
@@ -1198,7 +1211,7 @@ zone_bootup(zlog_t *zlogp, const char *bootargs, int zstate, boolean_t debug)
 	 * See if we need to setup contract dependencies between the zone's
 	 * primary application and any of its services.
 	 */
-	app_svc_dep = is_app_svc_dep(bh);
+	app_svc_dep = is_app_svc_dep();
 
 	brand_close(bh);
 
@@ -1224,6 +1237,7 @@ zone_bootup(zlog_t *zlogp, const char *bootargs, int zstate, boolean_t debug)
 		goto bad;
 	}
 
+	/* LINTED: E_NOP_IF_STMT */
 	if ((st.st_mode & S_IFMT) == S_IFLNK) {
 		/* symlink, we'll have to wait and resolve when we boot */
 	} else if ((st.st_mode & S_IXUSR) == 0) {
@@ -1286,16 +1300,16 @@ zone_bootup(zlog_t *zlogp, const char *bootargs, int zstate, boolean_t debug)
 	notify_zonestatd(zone_id);
 
 	/* Startup a thread to perform zfd logging/tty svc for the zone. */
-	create_log_thread(zlogp, zone_id);
+	create_log_thread(zlogp);
 
 	if (zone_boot(zoneid) == -1) {
 		zerror(zlogp, B_TRUE, "unable to boot zone");
-		destroy_log_thread();
+		destroy_log_thread(zlogp);
 		goto bad;
 	}
 
 	if (brand_poststatechg(zlogp, zstate, Z_BOOT, debug) != 0) {
-		destroy_log_thread();
+		destroy_log_thread(zlogp);
 		goto bad;
 	}
 
@@ -1328,12 +1342,12 @@ zone_halt(zlog_t *zlogp, boolean_t unmount_cmd, boolean_t rebooting, int zstate,
 	if (vplat_teardown(zlogp, unmount_cmd, rebooting, debug) != 0) {
 		if (!bringup_failure_recovery)
 			zerror(zlogp, B_FALSE, "unable to destroy zone");
-		destroy_log_thread();
+		destroy_log_thread(zlogp);
 		return (-1);
 	}
 
 	/* Shut down is done, stop the log thread */
-	destroy_log_thread();
+	destroy_log_thread(zlogp);
 
 	if (unmount_cmd == B_FALSE &&
 	    brand_poststatechg(zlogp, zstate, Z_HALT, debug) != 0)
@@ -1586,6 +1600,8 @@ server(void *cookie, char *args, size_t alen, door_desc_t *dp,
 	 * it is time for us to shut down zoneadmd.
 	 */
 	if (zargp == DOOR_UNREF_DATA) {
+		logstream_close(platloghdl);
+
 		/*
 		 * See comment at end of main() for info on the last rites.
 		 */
@@ -1697,7 +1713,7 @@ server(void *cookie, char *args, size_t alen, door_desc_t *dp,
 			rval = -1;
 			goto out;
 		}
-		zlogp = &logsys;	/* Log errors to syslog */
+		zlogp = &logplat;	/* Log errors to platform.log */
 	}
 
 	/*
@@ -2154,8 +2170,6 @@ top:
 		 * state.
 		 */
 		if (zstate > ZONE_STATE_INSTALLED) {
-			static zoneid_t zid;
-
 			zerror(zlogp, B_FALSE,
 			    "zone '%s': WARNING: zone is in state '%s', but "
 			    "zoneadmd does not appear to be available; "
@@ -2165,10 +2179,10 @@ top:
 			/*
 			 * Startup a thread to perform the zfd logging/tty svc
 			 * for the zone. zlogp won't be valid for much longer
-			 * so use logsys.
+			 * so use logplat.
 			 */
-			if ((zid = getzoneidbyname(zone_name)) != -1) {
-				create_log_thread(&logsys, zid);
+			if (getzoneidbyname(zone_name) != -1) {
+				create_log_thread(&logplat);
 			}
 
 			/* recover the global configuration snapshot */
@@ -2608,6 +2622,15 @@ main(int argc, char *argv[])
 
 	openlog("zoneadmd", LOG_PID, LOG_DAEMON);
 
+	/*
+	 * Allow logging to <zonepath>/logs/<file>.
+	 */
+	logstream_init(zlogp);
+	platloghdl = logstream_open("platform.log", "zoneadmd", 0);
+
+	/* logplat looks the same as logsys, but logs to platform.log */
+	logplat = logsys;
+
 	/*
 	 * The eventstream is used to publish state changes in the zone
 	 * from the door threads to the console I/O poller.
@@ -2627,7 +2650,6 @@ main(int argc, char *argv[])
 	if (make_daemon_exclusive(zlogp) == -1)
 		goto child_out;
 
-
 	/*
 	 * Create/join a new session; we need to be careful of what we do with
 	 * the console from now on so we don't end up being the session leader
@@ -2637,9 +2659,13 @@ main(int argc, char *argv[])
 
 	/*
 	 * This thread shouldn't be receiving any signals; in particular,
-	 * SIGCHLD should be received by the thread doing the fork().
+	 * SIGCHLD should be received by the thread doing the fork().  The
+	 * exceptions are SIGHUP and SIGUSR1 for log rotation, set up by
+	 * logstream_init().
 	 */
 	(void) sigfillset(&blockset);
+	(void) sigdelset(&blockset, SIGHUP);
+	(void) sigdelset(&blockset, SIGUSR1);
 	(void) thr_sigsetmask(SIG_BLOCK, &blockset, NULL);
 
 	/*
diff --git a/usr/src/cmd/zoneadmd/zoneadmd.h b/usr/src/cmd/zoneadmd/zoneadmd.h
index 0a347e9b82..a170759e50 100644
--- a/usr/src/cmd/zoneadmd/zoneadmd.h
+++ b/usr/src/cmd/zoneadmd/zoneadmd.h
@@ -22,7 +22,7 @@
 /*
  * Copyright (c) 2003, 2010, Oracle and/or its affiliates. All rights reserved.
  * Copyright 2014 Nexenta Systems, Inc. All rights reserved.
- * Copyright 2017 Joyent, Inc.
+ * Copyright 2018 Joyent, Inc.
  */
 
 #ifndef	_ZONEADMD_H
@@ -33,6 +33,9 @@ extern "C" {
 #endif
 
 #include <libdladm.h>
+#include <libzonecfg.h>
+#include <thread.h>
+#include <synch.h>
 
 /*
  * Multi-threaded programs should avoid MT-unsafe library calls (i.e., any-
@@ -85,7 +88,8 @@ typedef struct zlog {
 	char *locale;	/* locale to use for gettext() */
 } zlog_t;
 
-extern zlog_t logsys;
+extern zlog_t logsys;		/* syslog */
+extern zlog_t logplat;		/* platform.log */
 
 extern mutex_t lock;
 extern mutex_t msglock;
@@ -160,10 +164,18 @@ extern void serve_console(zlog_t *);
 extern void zcons_statechanged();
 
 /*
- * Zone FD log thread creation.
+ * Logging routines
  */
-extern void create_log_thread(zlog_t *, zoneid_t);
-extern void destroy_log_thread();
+typedef enum {
+	LS_LINE_BUFFERED = 0x1		/* Write when \n found or full buffer */
+} logstream_flags_t;
+
+extern void create_log_thread(zlog_t *);
+extern void destroy_log_thread(zlog_t *);
+extern void logstream_init(zlog_t *);
+extern int logstream_open(const char *, const char *, logstream_flags_t);
+extern void logstream_write(int, char *, int);
+extern void logstream_close(int);
 
 /*
  * Contract handling.
-- 
2.21.0

