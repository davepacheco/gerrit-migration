From 7b827ccd7e492f6b13e8275ca5fcc89ff625f4c4 Mon Sep 17 00:00:00 2001
From: Kelly McLaughlin <kelly.mclaughlin@joyent.com>
Date: Tue, 11 Jun 2019 11:57:28 -0600
Subject: [PATCH] MANTA-4330 Boray Reports Error When Trying to Create a Bucket
 that Exists Already, Causing Connection Close

---
 src/bucket.rs         | 75 ++++++++++++++++++++++---------------------
 src/lib.rs            |  1 +
 src/object.rs         | 26 ++++-----------
 tests/rpc_handlers.rs | 34 +++++++++++---------
 4 files changed, 64 insertions(+), 72 deletions(-)

diff --git a/src/bucket.rs b/src/bucket.rs
index 8bdd0cc..4c1b6a3 100644
--- a/src/bucket.rs
+++ b/src/bucket.rs
@@ -16,8 +16,9 @@ use serde_json::{json, Value};
 use slog::{Logger, debug};
 use uuid::Uuid;
 
-use crate::util::Rows;
+use crate::error::{BorayError, BorayErrorType};
 use crate::sql;
+use crate::util::Rows;
 
 type Timestamptz = chrono::DateTime<chrono::Utc>;
 
@@ -55,35 +56,35 @@ pub struct ListBucketsPayload {
     pub offset   : u64
 }
 
-#[derive(Debug, Default, Serialize, Deserialize, PartialEq)]
-pub struct BucketNotFoundError {
-    pub name    : String,
-    pub message : String
-}
-
-impl BucketNotFoundError {
-    pub fn new() -> Self {
-        BucketNotFoundError {
-            name: "BucketNotFoundError".into(),
-            message: "requested bucket not found".into()
-        }
-    }
-}
-
-#[derive(Debug, Default, Serialize, Deserialize, PartialEq)]
-pub struct BucketAlreadyExistsError {
-    pub name    : String,
-    pub message : String
-}
-
-impl BucketAlreadyExistsError {
-    pub fn new() -> Self {
-        BucketAlreadyExistsError {
-            name: "BucketAlreadyExistsError".into(),
-            message: "requested bucket already exists".into()
-        }
-    }
-}
+// #[derive(Debug, Default, Serialize, Deserialize, PartialEq)]
+// pub struct BucketNotFoundError {
+//     pub name    : String,
+//     pub message : String
+// }
+
+// impl BucketNotFoundError {
+//     pub fn new() -> Self {
+//         BucketNotFoundError {
+//             name: "BucketNotFoundError".into(),
+//             message: "requested bucket not found".into()
+//         }
+//     }
+// }
+
+// #[derive(Debug, Default, Serialize, Deserialize, PartialEq)]
+// pub struct BucketAlreadyExistsError {
+//     pub name    : String,
+//     pub message : String
+// }
+
+// impl BucketAlreadyExistsError {
+//     pub fn new() -> Self {
+//         BucketAlreadyExistsError {
+//             name: "BucketAlreadyExistsError".into(),
+//             message: "requested bucket already exists".into()
+//         }
+//     }
+// }
 
 fn array_wrap(v: Value) -> Value {
     Value::Array(vec![v])
@@ -92,15 +93,15 @@ fn array_wrap(v: Value) -> Value {
 pub fn bucket_not_found() -> Value {
     // The data for this JSON conversion is locally controlled
     // so unwrapping the result is ok here.
-    serde_json::to_value(BucketNotFoundError::new())
-        .expect("failed to encode a BucketNotFoundError")
+    serde_json::to_value(BorayError::new(BorayErrorType::BucketNotFound))
+        .expect("failed to encode a BucketNotFound error")
 }
 
 pub fn bucket_already_exists() -> Value {
     // The data for this JSON conversion is locally controlled
     // so unwrapping the result is ok here.
-    serde_json::to_value(BucketAlreadyExistsError::new())
-        .expect("failed to encode a BucketAlreadyExistsError")
+    serde_json::to_value(BorayError::new(BorayErrorType::BucketAlreadyExists))
+        .expect("failed to encode a BucketAlreadyExists error")
 }
 
 pub fn get_handler(msg_id: u32,
@@ -137,7 +138,7 @@ pub fn get_handler(msg_id: u32,
                 },
                 None => {
 
-                    let err_msg = FastMessage::error(msg_id, FastMessageData::new(method, bucket_not_found()));
+                    let err_msg = FastMessage::data(msg_id, FastMessageData::new(method, bucket_not_found()));
                     response.push(err_msg);
                     Ok(response)
                 }
@@ -242,7 +243,7 @@ pub fn create_handler(msg_id: u32,
                     Ok(response)
                 },
                 None => {
-                    let err_msg = FastMessage::error(msg_id, FastMessageData::new(method, bucket_already_exists()));
+                    let err_msg = FastMessage::data(msg_id, FastMessageData::new(method, bucket_already_exists()));
                     response.push(err_msg);
                     Ok(response)
                 }
@@ -284,7 +285,7 @@ pub fn delete_handler(msg_id: u32,
                 let msg = FastMessage::data(msg_id, FastMessageData::new(method, value));
                 Ok(msg)
             } else {
-                let err_msg = FastMessage::error(msg_id, FastMessageData::new(method, bucket_not_found()));
+                let err_msg = FastMessage::data(msg_id, FastMessageData::new(method, bucket_not_found()));
                 Ok(err_msg)
             }
         })
diff --git a/src/lib.rs b/src/lib.rs
index b2afdd4..8d6c9dc 100644
--- a/src/lib.rs
+++ b/src/lib.rs
@@ -3,6 +3,7 @@
  */
 
 pub mod bucket;
+pub mod error;
 pub mod metrics;
 pub mod object;
 pub mod opts;
diff --git a/src/object.rs b/src/object.rs
index 783f808..1801aa2 100644
--- a/src/object.rs
+++ b/src/object.rs
@@ -23,6 +23,7 @@ use cueball_static_resolver::StaticIpResolver;
 use cueball_postgres_connection::PostgresConnection;
 use rust_fast::protocol::{FastMessage, FastMessageData};
 
+use crate::error::{BorayError, BorayErrorType};
 use crate::util::Rows;
 use crate::sql;
 
@@ -139,26 +140,11 @@ pub struct ListObjectsPayload {
     pub offset    : u64
 }
 
-#[derive(Debug, Default, Serialize, Deserialize, PartialEq)]
-pub struct ObjectNotFoundError {
-    pub name    : String,
-    pub message : String
-}
-
-impl ObjectNotFoundError {
-    pub fn new() -> Self {
-        ObjectNotFoundError {
-            name: "ObjectNotFoundError".into(),
-            message: "requested object not found".into()
-        }
-    }
-}
-
-fn object_not_found() -> Value {
+pub fn object_not_found() -> Value {
     // The data for this JSON conversion is locally controlled
     // so unwrapping the result is ok here.
-    serde_json::to_value(ObjectNotFoundError::new())
-        .expect("failed to encode an ObjectNotFound Error")
+    serde_json::to_value(BorayError::new(BorayErrorType::ObjectNotFound))
+        .expect("failed to encode a ObjectNotFound error")
 }
 
 pub fn get_handler(msg_id: u32,
@@ -193,7 +179,7 @@ pub fn get_handler(msg_id: u32,
                     Ok(response)
                 },
                 None => {
-                    let err_msg = FastMessage::error(msg_id, FastMessageData::new(method, object_not_found()));
+                    let err_msg = FastMessage::data(msg_id, FastMessageData::new(method, object_not_found()));
                     response.push(err_msg);
                     Ok(response)
                 }
@@ -341,7 +327,7 @@ pub fn delete_handler(msg_id: u32,
                 let msg = FastMessage::data(msg_id, FastMessageData::new(method, value));
                 Ok(msg)
             } else {
-                let err_msg = FastMessage::error(msg_id, FastMessageData::new(method, object_not_found()));
+                let err_msg = FastMessage::data(msg_id, FastMessageData::new(method, object_not_found()));
                 Ok(err_msg)
             }
         })
diff --git a/tests/rpc_handlers.rs b/tests/rpc_handlers.rs
index 7b7b77a..7e40310 100644
--- a/tests/rpc_handlers.rs
+++ b/tests/rpc_handlers.rs
@@ -17,6 +17,7 @@ use cueball_static_resolver::StaticIpResolver;
 use cueball_postgres_connection::{PostgresConnection, PostgresConnectionConfig};
 
 use boray::bucket;
+use boray::error::{BorayError, BorayErrorType};
 use boray::object;
 
 // This test suite requres PostgreSQL and pg_tmp
@@ -119,11 +120,11 @@ fn verify_rpc_handlers() {
     let get_bucket_response = get_bucket_result.unwrap();
     assert_eq!(get_bucket_response.len(), 1);
 
-    let get_bucket_response_result: Result<bucket::BucketNotFoundError, _> =
+    let get_bucket_response_result: Result<BorayError, _> =
         serde_json::from_value(get_bucket_response[0].data.d.clone());
     assert!(get_bucket_response_result.is_ok());
-    assert_eq!(get_bucket_response_result.unwrap(), bucket::BucketNotFoundError::new());
-
+    assert_eq!(get_bucket_response_result.unwrap(),
+               BorayError::new(BorayErrorType::BucketNotFound));
 
     // Create a bucket
     let create_bucket_payload = bucket::CreateBucketPayload {
@@ -170,11 +171,11 @@ fn verify_rpc_handlers() {
     let create_bucket_response = create_bucket_result.unwrap();
     assert_eq!(create_bucket_response.len(), 1);
 
-    let create_bucket_response_result: Result<bucket::BucketAlreadyExistsError, _> =
+    let create_bucket_response_result: Result<BorayError, _> =
         serde_json::from_value(create_bucket_response[0].data.d.clone());
     assert!(create_bucket_response_result.is_ok());
     assert_eq!(create_bucket_response_result.unwrap(),
-               bucket::BucketAlreadyExistsError::new());
+               BorayError::new(BorayErrorType::BucketAlreadyExists));
 
     // Delete bucket
 
@@ -200,10 +201,10 @@ fn verify_rpc_handlers() {
     let get_bucket_response = get_bucket_result.unwrap();
     assert_eq!(get_bucket_response.len(), 1);
 
-    let get_bucket_response_result: Result<bucket::BucketNotFoundError, _> =
+    let get_bucket_response_result: Result<BorayError, _> =
         serde_json::from_value(get_bucket_response[0].data.d.clone());
     assert!(get_bucket_response_result.is_ok());
-    assert_eq!(get_bucket_response_result.unwrap(), bucket::BucketNotFoundError::new());
+    assert_eq!(get_bucket_response_result.unwrap(), BorayError::new(BorayErrorType::BucketNotFound));
 
 
     // Attempt to delete a nonexistent bucket and verify an error is returned
@@ -214,10 +215,11 @@ fn verify_rpc_handlers() {
     let delete_bucket_response = delete_bucket_result.unwrap();
     assert_eq!(delete_bucket_response.len(), 1);
 
-    let delete_bucket_response_result: Result<bucket::BucketNotFoundError, _> =
+    let delete_bucket_response_result: Result<BorayError, _> =
         serde_json::from_value(delete_bucket_response[0].data.d.clone());
     assert!(delete_bucket_response_result.is_ok());
-    assert_eq!(delete_bucket_response_result.unwrap(), bucket::BucketNotFoundError::new());
+    assert_eq!(delete_bucket_response_result.unwrap(),
+               BorayError::new(BorayErrorType::BucketNotFound));
 
 
     // Try to read an object
@@ -239,10 +241,10 @@ fn verify_rpc_handlers() {
     let get_object_response = get_object_result.unwrap();
     assert_eq!(get_object_response.len(), 1);
 
-    let get_object_response_result: Result<object::ObjectNotFoundError, _> =
+    let get_object_response_result: Result<BorayError, _> =
         serde_json::from_value(get_object_response[0].data.d.clone());
     assert!(get_object_response_result.is_ok());
-    assert_eq!(get_object_response_result.unwrap(), object::ObjectNotFoundError::new());
+    assert_eq!(get_object_response_result.unwrap(), BorayError::new(BorayErrorType::ObjectNotFound));
 
 
     // Create an object
@@ -324,10 +326,11 @@ fn verify_rpc_handlers() {
     let get_object_response = get_object_result.unwrap();
     assert_eq!(get_object_response.len(), 1);
 
-    let get_object_response_result: Result<object::ObjectNotFoundError, _> =
+    let get_object_response_result: Result<BorayError, _> =
         serde_json::from_value(get_object_response[0].data.d.clone());
     assert!(get_object_response_result.is_ok());
-    assert_eq!(get_object_response_result.unwrap(), object::ObjectNotFoundError::new());
+    assert_eq!(get_object_response_result.unwrap(),
+               BorayError::new(BorayErrorType::ObjectNotFound));
 
     // Delete the object again and verify it is not found
     delete_object_result =
@@ -337,10 +340,11 @@ fn verify_rpc_handlers() {
     let delete_object_response = delete_object_result.unwrap();
     assert_eq!(delete_object_response.len(), 1);
 
-    let delete_object_response_result: Result<object::ObjectNotFoundError, _> =
+    let delete_object_response_result: Result<BorayError, _> =
         serde_json::from_value(delete_object_response[0].data.d.clone());
     assert!(delete_object_response_result.is_ok());
-    assert_eq!(delete_object_response_result.unwrap(), object::ObjectNotFoundError::new());
+    assert_eq!(delete_object_response_result.unwrap(),
+               BorayError::new(BorayErrorType::ObjectNotFound));
 
     // List buckets and confirm none are found
 
-- 
2.21.0

