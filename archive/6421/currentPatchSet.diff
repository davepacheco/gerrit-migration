commit ffa1699da13978cf74e6f4ebd06bed7c7859c359
Author: Kelly McLaughlin <kelly.mclaughlin@joyent.com>
Date:   2019-06-11T14:05:30-06:00 (4 months ago)
    
    MANTA-4330 Boray Reports Error When Trying to Create a Bucket that Exists Already, Causing Connection Close

diff --git a/src/bucket.rs b/src/bucket.rs
index 8bdd0cc..f5f27f1 100644
--- a/src/bucket.rs
+++ b/src/bucket.rs
@@ -16,8 +16,9 @@ use serde_json::{json, Value};
 use slog::{Logger, debug};
 use uuid::Uuid;
 
-use crate::util::Rows;
+use crate::error::{BorayError, BorayErrorType};
 use crate::sql;
+use crate::util::Rows;
 
 type Timestamptz = chrono::DateTime<chrono::Utc>;
 
@@ -55,36 +56,6 @@ pub struct ListBucketsPayload {
     pub offset   : u64
 }
 
-#[derive(Debug, Default, Serialize, Deserialize, PartialEq)]
-pub struct BucketNotFoundError {
-    pub name    : String,
-    pub message : String
-}
-
-impl BucketNotFoundError {
-    pub fn new() -> Self {
-        BucketNotFoundError {
-            name: "BucketNotFoundError".into(),
-            message: "requested bucket not found".into()
-        }
-    }
-}
-
-#[derive(Debug, Default, Serialize, Deserialize, PartialEq)]
-pub struct BucketAlreadyExistsError {
-    pub name    : String,
-    pub message : String
-}
-
-impl BucketAlreadyExistsError {
-    pub fn new() -> Self {
-        BucketAlreadyExistsError {
-            name: "BucketAlreadyExistsError".into(),
-            message: "requested bucket already exists".into()
-        }
-    }
-}
-
 fn array_wrap(v: Value) -> Value {
     Value::Array(vec![v])
 }
@@ -92,15 +63,15 @@ fn array_wrap(v: Value) -> Value {
 pub fn bucket_not_found() -> Value {
     // The data for this JSON conversion is locally controlled
     // so unwrapping the result is ok here.
-    serde_json::to_value(BucketNotFoundError::new())
-        .expect("failed to encode a BucketNotFoundError")
+    serde_json::to_value(BorayError::new(BorayErrorType::BucketNotFound))
+        .expect("failed to encode a BucketNotFound error")
 }
 
 pub fn bucket_already_exists() -> Value {
     // The data for this JSON conversion is locally controlled
     // so unwrapping the result is ok here.
-    serde_json::to_value(BucketAlreadyExistsError::new())
-        .expect("failed to encode a BucketAlreadyExistsError")
+    serde_json::to_value(BorayError::new(BorayErrorType::BucketAlreadyExists))
+        .expect("failed to encode a BucketAlreadyExists error")
 }
 
 pub fn get_handler(msg_id: u32,
@@ -136,8 +107,8 @@ pub fn get_handler(msg_id: u32,
                     Ok(response)
                 },
                 None => {
-
-                    let err_msg = FastMessage::error(msg_id, FastMessageData::new(method, bucket_not_found()));
+                    let value = array_wrap(bucket_not_found());
+                    let err_msg = FastMessage::data(msg_id, FastMessageData::new(method, value));
                     response.push(err_msg);
                     Ok(response)
                 }
@@ -242,7 +213,8 @@ pub fn create_handler(msg_id: u32,
                     Ok(response)
                 },
                 None => {
-                    let err_msg = FastMessage::error(msg_id, FastMessageData::new(method, bucket_already_exists()));
+                    let value = array_wrap(bucket_already_exists());
+                    let err_msg = FastMessage::data(msg_id, FastMessageData::new(method, value));
                     response.push(err_msg);
                     Ok(response)
                 }
@@ -284,7 +256,8 @@ pub fn delete_handler(msg_id: u32,
                 let msg = FastMessage::data(msg_id, FastMessageData::new(method, value));
                 Ok(msg)
             } else {
-                let err_msg = FastMessage::error(msg_id, FastMessageData::new(method, bucket_not_found()));
+                let value = array_wrap(bucket_not_found());
+                let err_msg = FastMessage::data(msg_id, FastMessageData::new(method, value));
                 Ok(err_msg)
             }
         })
diff --git a/src/error.rs b/src/error.rs
new file mode 100644
index 0000000..886aeea
--- /dev/null
+++ b/src/error.rs
@@ -0,0 +1,53 @@
+use serde_derive::{Deserialize, Serialize};
+
+pub enum BorayErrorType {
+    BucketAlreadyExists,
+    BucketNotFound,
+    ObjectNotFound
+}
+
+impl ToString for BorayErrorType {
+    fn to_string(&self) -> String {
+        match *self {
+            BorayErrorType::BucketAlreadyExists => "BucketAlreadyExists".into(),
+            BorayErrorType::BucketNotFound      => "BucketNotFound".into(),
+            BorayErrorType::ObjectNotFound      => "ObjectNotFound".into()
+        }
+    }
+}
+
+impl BorayErrorType {
+    fn message(&self) -> String {
+        match *self {
+            BorayErrorType::BucketAlreadyExists =>
+                "requested bucket already exists".into(),
+            BorayErrorType::BucketNotFound =>
+                "requested bucket not found".into(),
+            BorayErrorType::ObjectNotFound =>
+                "requested object not found".into()
+        }
+    }
+}
+
+#[derive(Debug, Default, Serialize, Deserialize, PartialEq)]
+pub struct BorayError {
+    pub error: BorayInnerError
+}
+
+#[derive(Debug, Default, Serialize, Deserialize, PartialEq)]
+pub struct BorayInnerError {
+    pub name    : String,
+    pub message : String
+}
+
+impl BorayError {
+    pub fn new(error: BorayErrorType) -> Self {
+        let inner = BorayInnerError {
+            name: error.to_string(),
+            message: error.message()
+        };
+        BorayError {
+            error: inner
+        }
+    }
+}
diff --git a/src/lib.rs b/src/lib.rs
index b2afdd4..8d6c9dc 100644
--- a/src/lib.rs
+++ b/src/lib.rs
@@ -3,6 +3,7 @@
  */
 
 pub mod bucket;
+pub mod error;
 pub mod metrics;
 pub mod object;
 pub mod opts;
diff --git a/src/object.rs b/src/object.rs
index 783f808..65f9eac 100644
--- a/src/object.rs
+++ b/src/object.rs
@@ -23,6 +23,7 @@ use cueball_static_resolver::StaticIpResolver;
 use cueball_postgres_connection::PostgresConnection;
 use rust_fast::protocol::{FastMessage, FastMessageData};
 
+use crate::error::{BorayError, BorayErrorType};
 use crate::util::Rows;
 use crate::sql;
 
@@ -139,26 +140,11 @@ pub struct ListObjectsPayload {
     pub offset    : u64
 }
 
-#[derive(Debug, Default, Serialize, Deserialize, PartialEq)]
-pub struct ObjectNotFoundError {
-    pub name    : String,
-    pub message : String
-}
-
-impl ObjectNotFoundError {
-    pub fn new() -> Self {
-        ObjectNotFoundError {
-            name: "ObjectNotFoundError".into(),
-            message: "requested object not found".into()
-        }
-    }
-}
-
-fn object_not_found() -> Value {
+pub fn object_not_found() -> Value {
     // The data for this JSON conversion is locally controlled
     // so unwrapping the result is ok here.
-    serde_json::to_value(ObjectNotFoundError::new())
-        .expect("failed to encode an ObjectNotFound Error")
+    serde_json::to_value(BorayError::new(BorayErrorType::ObjectNotFound))
+        .expect("failed to encode a ObjectNotFound error")
 }
 
 pub fn get_handler(msg_id: u32,
@@ -193,7 +179,8 @@ pub fn get_handler(msg_id: u32,
                     Ok(response)
                 },
                 None => {
-                    let err_msg = FastMessage::error(msg_id, FastMessageData::new(method, object_not_found()));
+                    let value = array_wrap(object_not_found());
+                    let err_msg = FastMessage::data(msg_id, FastMessageData::new(method, value));
                     response.push(err_msg);
                     Ok(response)
                 }
@@ -341,7 +328,8 @@ pub fn delete_handler(msg_id: u32,
                 let msg = FastMessage::data(msg_id, FastMessageData::new(method, value));
                 Ok(msg)
             } else {
-                let err_msg = FastMessage::error(msg_id, FastMessageData::new(method, object_not_found()));
+                let value = array_wrap(object_not_found());
+                let err_msg = FastMessage::data(msg_id, FastMessageData::new(method, value));
                 Ok(err_msg)
             }
         })
diff --git a/tests/rpc_handlers.rs b/tests/rpc_handlers.rs
index 7b7b77a..ba0ceaf 100644
--- a/tests/rpc_handlers.rs
+++ b/tests/rpc_handlers.rs
@@ -17,6 +17,7 @@ use cueball_static_resolver::StaticIpResolver;
 use cueball_postgres_connection::{PostgresConnection, PostgresConnectionConfig};
 
 use boray::bucket;
+use boray::error::{BorayError, BorayErrorType};
 use boray::object;
 
 // This test suite requres PostgreSQL and pg_tmp
@@ -119,11 +120,11 @@ fn verify_rpc_handlers() {
     let get_bucket_response = get_bucket_result.unwrap();
     assert_eq!(get_bucket_response.len(), 1);
 
-    let get_bucket_response_result: Result<bucket::BucketNotFoundError, _> =
-        serde_json::from_value(get_bucket_response[0].data.d.clone());
+    let get_bucket_response_result: Result<BorayError, _> =
+        serde_json::from_value(get_bucket_response[0].data.d[0].clone());
     assert!(get_bucket_response_result.is_ok());
-    assert_eq!(get_bucket_response_result.unwrap(), bucket::BucketNotFoundError::new());
-
+    assert_eq!(get_bucket_response_result.unwrap(),
+               BorayError::new(BorayErrorType::BucketNotFound));
 
     // Create a bucket
     let create_bucket_payload = bucket::CreateBucketPayload {
@@ -170,11 +171,11 @@ fn verify_rpc_handlers() {
     let create_bucket_response = create_bucket_result.unwrap();
     assert_eq!(create_bucket_response.len(), 1);
 
-    let create_bucket_response_result: Result<bucket::BucketAlreadyExistsError, _> =
-        serde_json::from_value(create_bucket_response[0].data.d.clone());
+    let create_bucket_response_result: Result<BorayError, _> =
+        serde_json::from_value(create_bucket_response[0].data.d[0].clone());
     assert!(create_bucket_response_result.is_ok());
     assert_eq!(create_bucket_response_result.unwrap(),
-               bucket::BucketAlreadyExistsError::new());
+               BorayError::new(BorayErrorType::BucketAlreadyExists));
 
     // Delete bucket
 
@@ -200,10 +201,10 @@ fn verify_rpc_handlers() {
     let get_bucket_response = get_bucket_result.unwrap();
     assert_eq!(get_bucket_response.len(), 1);
 
-    let get_bucket_response_result: Result<bucket::BucketNotFoundError, _> =
-        serde_json::from_value(get_bucket_response[0].data.d.clone());
+    let get_bucket_response_result: Result<BorayError, _> =
+        serde_json::from_value(get_bucket_response[0].data.d[0].clone());
     assert!(get_bucket_response_result.is_ok());
-    assert_eq!(get_bucket_response_result.unwrap(), bucket::BucketNotFoundError::new());
+    assert_eq!(get_bucket_response_result.unwrap(), BorayError::new(BorayErrorType::BucketNotFound));
 
 
     // Attempt to delete a nonexistent bucket and verify an error is returned
@@ -214,10 +215,11 @@ fn verify_rpc_handlers() {
     let delete_bucket_response = delete_bucket_result.unwrap();
     assert_eq!(delete_bucket_response.len(), 1);
 
-    let delete_bucket_response_result: Result<bucket::BucketNotFoundError, _> =
-        serde_json::from_value(delete_bucket_response[0].data.d.clone());
+    let delete_bucket_response_result: Result<BorayError, _> =
+        serde_json::from_value(delete_bucket_response[0].data.d[0].clone());
     assert!(delete_bucket_response_result.is_ok());
-    assert_eq!(delete_bucket_response_result.unwrap(), bucket::BucketNotFoundError::new());
+    assert_eq!(delete_bucket_response_result.unwrap(),
+               BorayError::new(BorayErrorType::BucketNotFound));
 
 
     // Try to read an object
@@ -239,10 +241,10 @@ fn verify_rpc_handlers() {
     let get_object_response = get_object_result.unwrap();
     assert_eq!(get_object_response.len(), 1);
 
-    let get_object_response_result: Result<object::ObjectNotFoundError, _> =
-        serde_json::from_value(get_object_response[0].data.d.clone());
+    let get_object_response_result: Result<BorayError, _> =
+        serde_json::from_value(get_object_response[0].data.d[0].clone());
     assert!(get_object_response_result.is_ok());
-    assert_eq!(get_object_response_result.unwrap(), object::ObjectNotFoundError::new());
+    assert_eq!(get_object_response_result.unwrap(), BorayError::new(BorayErrorType::ObjectNotFound));
 
 
     // Create an object
@@ -324,10 +326,11 @@ fn verify_rpc_handlers() {
     let get_object_response = get_object_result.unwrap();
     assert_eq!(get_object_response.len(), 1);
 
-    let get_object_response_result: Result<object::ObjectNotFoundError, _> =
-        serde_json::from_value(get_object_response[0].data.d.clone());
+    let get_object_response_result: Result<BorayError, _> =
+        serde_json::from_value(get_object_response[0].data.d[0].clone());
     assert!(get_object_response_result.is_ok());
-    assert_eq!(get_object_response_result.unwrap(), object::ObjectNotFoundError::new());
+    assert_eq!(get_object_response_result.unwrap(),
+               BorayError::new(BorayErrorType::ObjectNotFound));
 
     // Delete the object again and verify it is not found
     delete_object_result =
@@ -337,10 +340,11 @@ fn verify_rpc_handlers() {
     let delete_object_response = delete_object_result.unwrap();
     assert_eq!(delete_object_response.len(), 1);
 
-    let delete_object_response_result: Result<object::ObjectNotFoundError, _> =
-        serde_json::from_value(delete_object_response[0].data.d.clone());
+    let delete_object_response_result: Result<BorayError, _> =
+        serde_json::from_value(delete_object_response[0].data.d[0].clone());
     assert!(delete_object_response_result.is_ok());
-    assert_eq!(delete_object_response_result.unwrap(), object::ObjectNotFoundError::new());
+    assert_eq!(delete_object_response_result.unwrap(),
+               BorayError::new(BorayErrorType::ObjectNotFound));
 
     // List buckets and confirm none are found
 
