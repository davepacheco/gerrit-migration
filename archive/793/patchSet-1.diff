From ef02797227dd4d5904923b27c051e7dbf66aaced Mon Sep 17 00:00:00 2001
From: Alex Wilson <alex.wilson@joyent.com>
Date: Wed, 26 Oct 2016 19:19:19 -0700
Subject: [PATCH] MANTA-3017 binder needs to serve NXDOMAIN/NODATA for SRV
 names it owns

---
 lib/server.js | 44 ++++++++++++++++++++++++++++++++------------
 1 file changed, 32 insertions(+), 12 deletions(-)

diff --git a/lib/server.js b/lib/server.js
index 0b7f444..08158d7 100644
--- a/lib/server.js
+++ b/lib/server.js
@@ -154,12 +154,22 @@ function resolve(options, query, cb) {
                                 options.recursion.resolve(query, cb);
                                 return;
                         }
-                        //The correct thing to do here would be to return a Name
-                        // Error (code 3, see rfc1035, 4.1.1), but clients take
-                        // that as an authoritative answer and don't try the
-                        // next dns server in /etc/resolv.conf.  So, we lie and
-                        // say Server error (code 2).
-                        query.setError('eserver');
+                        /*
+                         * You might expect we would return an NXDOMAIN or
+                         * NODATA response here.
+                         *
+                         * Many of our resolvers use binder as a recursive
+                         * nameserver, higher up their priority list than public
+                         * DNS. This means that if we serve them such a response
+                         * here for a name we don't handle, they will
+                         * immediately return an error to their users and not
+                         * try public DNS.
+                         *
+                         * If we return SERVFAIL though, they will try the next
+                         * server, which is the behaviour we want (even though
+                         * as a result we're not RFC compliant).
+                         */
+                        query.setError('servfail');
                 } else {
                         var addr;
 
@@ -173,7 +183,14 @@ function resolve(options, query, cb) {
 
                         if (service !== undefined &&
                             record.type !== 'service') {
-                                query.setError('eserver');
+                                /*
+                                 * The user asked for an SRV record on something
+                                 * that isn't a valid service (e.g. it's a
+                                 * specific instance of it). We know we own this
+                                 * name, so we can safely return a NODATA
+                                 * response.
+                                 */
+                                query.setError('noerror');
                                 req.stamp('build_response');
                                 query.respond();
                                 cb();
@@ -200,11 +217,14 @@ function resolve(options, query, cb) {
                                 if (service !== undefined &&
                                     (service !== s.srvce ||
                                     protocol !== s.proto)) {
-                                        query.setError('eserver');
-                                        req.log.error({
-                                                query: query,
-                                                record: record
-                                        }, 'bad zk info');
+                                        /*
+                                         * The user asked for a SRV record for
+                                         * a service/protocol name that didn't
+                                         * match the one registered. We know
+                                         * we own this name, though, so serve
+                                         * them an NXDOMAIN.
+                                         */
+                                        query.setError('nxdomain');
                                         break;
                                 }
                                 // Inefficient, but easy to reason about.
-- 
2.21.0

