From 7212189f1398f2e4c0b5252bd970cdc3e141231e Mon Sep 17 00:00:00 2001
From: Alex Wilson <alex.wilson@joyent.com>
Date: Tue, 4 Sep 2018 17:40:37 -0700
Subject: [PATCH] TRITON-749 CNS reaper marks things as reaped *before* reaping
 them Reviewed by: Robert Mustacchi <rm@joyent.com>

---
 lib/reaper-stream.js | 67 +++++++++++++++++++++++++++++++++++++++-----
 1 file changed, 60 insertions(+), 7 deletions(-)

diff --git a/lib/reaper-stream.js b/lib/reaper-stream.js
index 8cf49ee..a998189 100644
--- a/lib/reaper-stream.js
+++ b/lib/reaper-stream.js
@@ -23,6 +23,33 @@ var FSM = require('mooremachine').FSM;
 /* Attempt to reap VMs that haven't been visited in REAP_TIME seconds. */
 var DEFAULT_REAP_TIME = 3600;
 
+/*
+ * The Reaper FSM's job is to periodically go around looking for any VMs that
+ * we haven't processed an update about in a while (REAP_TIME seconds) and
+ * force us to reconsider them by pushing them into the pipeline.
+ *
+ * It has to do this without overwhelming the pipeline, so it throttles its
+ * insertions using a timer, and adjusts that timer upwards every time the
+ * pipeline is full (.push() returns false).
+ *
+ * Each time the reaper runs, it first gathers up a list of *all* VMs known
+ * to CNS (state listVms). Then it works slowly through this list (state next),
+ * checking each to see if it needs to be reaped (checkLastVisited, checkReaped)
+ * and then finally dispensing it into the pipeline (fetchAndPush). In between,
+ * it sleeps in order to throttle the rate at which it dispenses them.
+ *
+ * If the fetchAndPush found that the pipeline is full, it moves to the
+ * sleep_full state, which sleeps and adjusts the sleep time upwards for the
+ * next sleep (up to maxSleep). If it found the pipeline was not full, it
+ * moves to the sleep state, which sleeps and justs the sleep time downwards
+ * until it hits minSleep. In this way if there is a transient condition that
+ * causes the pipeline to fill up for a short period, we will back off during
+ * that time, and then resume our normal reaping rate when it clears.
+ *
+ * Maintaining a reasonably high reaping rate is important for CNS' correctness
+ * -- if any changefeed notifications are missed about removed VMs, this is the
+ * only backstop that pulls them out of DNS.
+ */
 function ReaperFSM(strm, opts) {
 	assert.object(opts, 'options');
 
@@ -178,6 +205,7 @@ ReaperFSM.prototype.state_checkLastVisited = function (S) {
 
 ReaperFSM.prototype.state_checkReaped = function (S) {
 	var self = this;
+	var log = self.log.child({uuid: self.vmuuid});
 	S.timeout(1000, function () {
 		self.lastError = new Error(
 		    'Timed out waiting for redis response');
@@ -198,8 +226,33 @@ ReaperFSM.prototype.state_checkReaped = function (S) {
 		 * forget that it existed now.
 		 */
 		if (val !== null) {
-			self.redis.del('vm:' + self.vmuuid);
-			S.gotoState('next');
+			/*
+			 * Double-check that the last_recs is actually empty,
+			 * though, before we do.
+			 *
+			 * If we throw away a VM and it still has last_recs
+			 * entries then it's very difficult to ever get rid of
+			 * the records about that VM in future, so we're extra
+			 * paranoid.
+			 */
+			self.redis.hget('vm:' + self.vmuuid, 'last_recs',
+			    S.callback(function (err2, val2) {
+				if (err2 || val2 === null || val2 === '{}') {
+					self.redis.del('vm:' + self.vmuuid);
+					S.gotoState('next');
+					return;
+				}
+
+				/*
+				 * Mostly this would happen because we crashed
+				 * or broke while processing this VM for
+				 * removal last time. We'll retry it here.
+				 */
+				log.warn({ last_recs: val2 }, 'tried to ' +
+				    'delete reaped VM, but last_recs is not ' +
+				    'empty');
+				S.gotoState('fetchAndPush');
+			}));
 			return;
 		}
 
@@ -224,16 +277,16 @@ ReaperFSM.prototype.state_fetchAndPush = function (S) {
 			return;
 		}
 
-		if (obj.state === 'destroyed' || obj.destroyed ||
-		    obj.state === 'failed' || obj.state === 'incomplete') {
-			self.redis.hset('vm:' + self.vmuuid, 'reaped', 'yes');
-		}
-
 		if (self.stream.push(obj) === false) {
 			S.gotoState('sleep_full');
 			return;
 		}
 
+		if (obj.state === 'destroyed' || obj.destroyed ||
+		    obj.state === 'failed' || obj.state === 'incomplete') {
+			self.redis.hset('vm:' + self.vmuuid, 'reaped', 'yes');
+		}
+
 		S.gotoState('sleep');
 	}));
 };
-- 
2.21.0

