From 31f534472fd57acee0686326e871cb8ba9800f79 Mon Sep 17 00:00:00 2001
From: Patrick Mooney <pmooney@pfmooney.com>
Date: Thu, 2 Mar 2017 18:57:49 +0000
Subject: [PATCH] OS-5722 lxbrand should hide pid 0

---
 usr/src/uts/common/brand/lx/os/lx_misc.c      |  13 +-
 usr/src/uts/common/brand/lx/os/lx_pid.c       | 121 ++++++++----------
 .../uts/common/brand/lx/procfs/lx_prsubr.c    |  58 ++++-----
 .../uts/common/brand/lx/procfs/lx_prvnops.c   |  33 ++---
 4 files changed, 91 insertions(+), 134 deletions(-)

diff --git a/usr/src/uts/common/brand/lx/os/lx_misc.c b/usr/src/uts/common/brand/lx/os/lx_misc.c
index 4a512f09af..54e5331e99 100644
--- a/usr/src/uts/common/brand/lx/os/lx_misc.c
+++ b/usr/src/uts/common/brand/lx/os/lx_misc.c
@@ -24,7 +24,7 @@
  */
 
 /*
- * Copyright 2016, Joyent, Inc.
+ * Copyright (c) 2017, Joyent, Inc.
  */
 
 #include <sys/errno.h>
@@ -923,18 +923,17 @@ lx_stol_hwaddr(const struct sockaddr_dl *src, struct sockaddr *dst, int *size)
 void
 lx_sigfd_translate(k_siginfo_t *infop)
 {
-	infop->si_signo = lx_stol_signo(infop->si_signo, LX_SIGKILL);
+	zone_t *zone = curproc->p_zone;
 
+	infop->si_signo = lx_stol_signo(infop->si_signo, LX_SIGKILL);
 	infop->si_status = lx_stol_status(infop->si_status, LX_SIGKILL);
-
 	infop->si_code = lx_stol_sigcode(infop->si_code);
-
 	infop->si_errno = lx_errno(infop->si_errno, EINVAL);
 
-	if (infop->si_pid == curproc->p_zone->zone_proc_initpid) {
+	/* Map zsched and zone init to pid 1 */
+	if (infop->si_pid == zone->zone_proc_initpid ||
+	    infop->si_pid == zone->zone_zsched->p_pid) {
 		infop->si_pid = 1;
-	} else if (infop->si_pid == curproc->p_zone->zone_zsched->p_pid) {
-		infop->si_pid = 0;
 	}
 }
 
diff --git a/usr/src/uts/common/brand/lx/os/lx_pid.c b/usr/src/uts/common/brand/lx/os/lx_pid.c
index 7e85295726..34622f3c6f 100644
--- a/usr/src/uts/common/brand/lx/os/lx_pid.c
+++ b/usr/src/uts/common/brand/lx/os/lx_pid.c
@@ -22,7 +22,7 @@
 /*
  * Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
- * Copyright 2016, Joyent, Inc.
+ * Copyright (c) 2017, Joyent, Inc.
  */
 
 #include <sys/types.h>
@@ -394,40 +394,32 @@ retry:
 
 /*
  * Given an lwp, return the Linux pid of its parent.  If the caller
- * wants them, we return the Solaris (pid, tid) as well.
+ * wants them, we return the SunOS (pid, tid) as well.
  */
 pid_t
 lx_lwp_ppid(klwp_t *lwp, pid_t *ppidp, id_t *ptidp)
 {
 	lx_lwp_data_t *lwpd = lwptolxlwp(lwp);
 	proc_t *p = lwptoproc(lwp);
-	struct lx_pid *hp;
-	pid_t zoneinit = curproc->p_zone->zone_proc_initpid;
-	pid_t lppid, ppid;
-
-	/*
-	 * Be sure not to return a parent pid that should be invisible
-	 * within this zone.
-	 */
-	ppid = ((p->p_flag & SZONETOP)
-	    ? curproc->p_zone->zone_zsched->p_pid : p->p_ppid);
+	const pid_t zoneinit = p->p_zone->zone_proc_initpid;
+	const pid_t ppid = p->p_ppid;
 
 	/*
-	 * If the parent process's pid is the zone's init process, force it
-	 * to the Linux init pid value of 1.
+	 * Report a ppid of 1 for processes which are children to either init
+	 * or a process outside the zone.
 	 */
-	if (ppid == zoneinit)
-		ppid = 1;
+	if (ppid == zoneinit || (p->p_flag & SZONETOP) != 0) {
+		goto ppid_is_zinit;
+	}
 
 	/*
-	 * There are two cases in which the Linux definition of a 'parent'
-	 * matches that of Solaris:
+	 * Our native concept of a 'parent pid' matches Linux in two cases:
 	 *
-	 * - if our tgid is the same as our PID, then we are either the
-	 *   first thread in the process or a CLONE_THREAD thread.
+	 * - TGID and PID are equal: This is either the first thread in the
+	 *   process or one created with CLONE_THREAD.
 	 *
-	 * - if the brand lwp value for ppid is 0, then we are either the
-	 *   child of a differently-branded process or a CLONE_PARENT thread.
+	 * - The brand lwp value for PPID is 0: This is either the child of a
+	 *   differently-branded process or was created with the CLONE_PARENT.
 	 */
 	if (p->p_pid == lwpd->br_tgid || lwpd->br_ppid == 0) {
 		if (ppidp != NULL)
@@ -438,58 +430,51 @@ lx_lwp_ppid(klwp_t *lwp, pid_t *ppidp, id_t *ptidp)
 	}
 
 	/*
-	 * Set the default Linux parent pid to be the pid of the zone's init
-	 * process; this will get converted back to the Linux default of 1
-	 * later.
-	 */
-	lppid = zoneinit;
-
-	/*
-	 * If the process's parent isn't init, try and look up the Linux "pid"
-	 * corresponding to the process's parent.
+	 * In all other cases, we are looking for the parent of this specific
+	 * thread, which in Linux refers to the thread that clone(2)d it.   We
+	 * stashed that thread's PID away when this thread was created.
 	 */
-	if (ppid != 1) {
-		/*
-		 * In all other cases, we are looking for the parent of this
-		 * specific thread, which in Linux refers to the thread that
-		 * clone()d it.   We stashed that thread's PID away when this
-		 * thread was created.
-		 */
-		mutex_enter(&hash_lock);
-		for (hp = ltos_pid_hash[LTOS_HASH(lwpd->br_ppid)]; hp != NULL;
-		    hp = hp->lxp_ltos_next) {
-			if (lwpd->br_ppid == hp->lxp_lpid) {
-				/*
-				 * We found the PID we were looking for, but
-				 * since we cached its value in this LWP's brand
-				 * structure, it has exited and been reused by
-				 * another process.
-				 */
-				if (hp->lxp_start > lwptot(lwp)->t_start)
-					break;
-
-				lppid = lwpd->br_ppid;
-				if (ppidp != NULL)
-					*ppidp = hp->lxp_spid;
-				if (ptidp != NULL)
-					*ptidp = hp->lxp_stid;
-
+	mutex_enter(&hash_lock);
+	for (struct lx_pid *hp = ltos_pid_hash[LTOS_HASH(lwpd->br_ppid)];
+	    hp != NULL; hp = hp->lxp_ltos_next) {
+		if (lwpd->br_ppid == hp->lxp_lpid) {
+			/*
+			 * The PID matches, but there are a couple cases when
+			 * the translation is not suitable:
+			 *
+			 * - The cached start time is too young, indicating
+			 *   that the thread exited and the PID was reused by
+			 *   another process.
+			 * - The parent is zoneinit
+			 *
+			 * In both cases, a result of ppid=1 is yielded.
+			 */
+			if (hp->lxp_start > lwptot(lwp)->t_start ||
+			    lwpd->br_ppid == zoneinit) {
 				break;
 			}
-		}
-		mutex_exit(&hash_lock);
-	}
-
-	if (lppid == zoneinit) {
-		lppid = 1;
 
-		if (ppidp != NULL)
-			*ppidp = lppid;
-		if (ptidp != NULL)
-			*ptidp = -1;
+			/* Good match, yield the result */
+			if (ppidp != NULL)
+				*ppidp = hp->lxp_spid;
+			if (ptidp != NULL)
+				*ptidp = hp->lxp_stid;
+			mutex_exit(&hash_lock);
+			return (lwpd->br_ppid);
+		}
 	}
+	mutex_exit(&hash_lock);
+	/*
+	 * If no match is found in the Linux->SunOS translation hash, fall back
+	 * to assuming the zone init process as the parent.
+	 */
 
-	return (lppid);
+ppid_is_zinit:
+	if (ppidp != NULL)
+		*ppidp = 1;
+	if (ptidp != NULL)
+		*ptidp = -1;
+	return (1);
 }
 
 void
diff --git a/usr/src/uts/common/brand/lx/procfs/lx_prsubr.c b/usr/src/uts/common/brand/lx/procfs/lx_prsubr.c
index 6f7f742b12..d103868737 100644
--- a/usr/src/uts/common/brand/lx/procfs/lx_prsubr.c
+++ b/usr/src/uts/common/brand/lx/procfs/lx_prsubr.c
@@ -199,29 +199,21 @@ lxpr_lock_pid(lxpr_node_t *lxpnp, pid_t pid, zombok_t zombie_ok,
 	zone_t *zone = LXPTOZ(lxpnp);
 	proc_t *p;
 	kthread_t *t;
+	lx_pid_flag_t flags = LXP_PRLOCK;
 
 	ASSERT(!MUTEX_HELD(&pidlock));
 
-retry:
-	if (pid == 0) {
-		/*
-		 * Present zsched as pid 0 for the zone.  There is no worry
-		 * about zsched disappearing during sprlock_proc() since the
-		 * zone (and zsched) will persist until all zone filesystems,
-		 * include this one, are unmounted.
-		 */
-		p = zone->zone_zsched;
-		mutex_enter(&p->p_lock);
-		sprlock_proc(p);
-	} else {
-		lx_pid_flag_t flags = LXP_PRLOCK;
+	/* Consider zsched to be invisible to LX */
+	if (pid == zone->zone_zsched->p_pid) {
+		return (NULL);
+	}
+	if (zombie_ok == ZOMB_OK) {
+		flags |= LXP_ZOMBOK;
+	}
 
-		if (zombie_ok == ZOMB_OK) {
-			flags |= LXP_ZOMBOK;
-		}
-		if (lx_lpid_lock(pid, zone, flags, &p, &t) != 0) {
-			return (NULL);
-		}
+retry:
+	if (lx_lpid_lock(pid, zone, flags, &p, &t) != 0) {
+		return (NULL);
 	}
 
 	/*
@@ -322,27 +314,25 @@ lxpr_fixpid(zone_t *zone, proc_t *p, pid_t *pidp, pid_t *ppidp)
 	ASSERT(p != NULL);
 	ASSERT(pidp != NULL);
 	ASSERT(zone->zone_brand == &lx_brand);
+	ASSERT(pid != zone->zone_zsched->p_pid);
 
 	if (pid == zone->zone_proc_initpid) {
 		pid = 1;
 		ppid = 0;	/* parent pid for init is 0 */
-	} else if (pid == zone->zone_zsched->p_pid) {
-		pid = 0;	/* zsched is pid 0 */
-		ppid = 0;	/* parent pid for zsched is itself */
 	} else {
-		/*
-		 * Make sure not to reference parent PIDs that reside outside
-		 * the zone
-		 */
-		if ((p->p_flag & SZONETOP) != 0) {
-			ppid = 0;
-		}
-
-		/*
-		 * Convert ppid to the Linux default of 1 if our parent is the
-		 * zone's init process
-		 */
 		if (ppid == zone->zone_proc_initpid) {
+			/*
+			 * Convert ppid to the Linux default of 1 if our parent
+			 * is the zone's init process
+			 */
+			ppid = 1;
+		} else if (ppid == zone->zone_zsched->p_pid ||
+		    (p->p_flag & SZONETOP) != 0) {
+			/*
+			 * Additionally, if the process has no valid parent
+			 * inside the zone (or its parent is zsched), lie and
+			 * claim init as the parent.
+			 */
 			ppid = 1;
 		}
 	}
diff --git a/usr/src/uts/common/brand/lx/procfs/lx_prvnops.c b/usr/src/uts/common/brand/lx/procfs/lx_prvnops.c
index 57c22690d4..2bf605baa3 100644
--- a/usr/src/uts/common/brand/lx/procfs/lx_prvnops.c
+++ b/usr/src/uts/common/brand/lx/procfs/lx_prvnops.c
@@ -2167,10 +2167,7 @@ lxpr_read_status_common(lxpr_node_t *lxpnp, lxpr_uiobuf_t *uiobuf,
 		return;
 	}
 
-	/*
-	 * Convert pid to the Linux default of 1 if we're the zone's init
-	 * process or if we're the zone's zsched the pid is 0.
-	 */
+	/* Translate the pid (e.g. initpid to 1) */
 	lxpr_fixpid(LXPTOZ(lxpnp), p, &pid, &ppid);
 
 	if (t != NULL) {
@@ -2384,9 +2381,7 @@ lxpr_read_pid_tid_stat(lxpr_node_t *lxpnp, lxpr_uiobuf_t *uiobuf)
 		return;
 	}
 
-	/*
-	 * Set Linux defaults if we're the zone's init process
-	 */
+	/* Set Linux defaults if we're the zone's init process */
 	pid = p->p_pid;
 	lxpr_fixpid(zone, p, &pid, &ppid);
 	if (pid == 1) {
@@ -2395,12 +2390,6 @@ lxpr_read_pid_tid_stat(lxpr_node_t *lxpnp, lxpr_uiobuf_t *uiobuf)
 		psgid = (gid_t)-1;
 		spid = 0;
 		psdev = 0;
-	} else if (pid == 0) {
-		/* zsched process */
-		pgpid = 0;
-		psgid = (gid_t)-1;
-		spid = 0;
-		psdev = 0;
 	} else {
 		pgpid = p->p_pgrp;
 		mutex_enter(&p->p_splock);
@@ -6305,22 +6294,19 @@ lxpr_readdir_procdir(lxpr_node_t *lxpnp, uio_t *uiop, int *eofp)
 
 		/*
 		 * Skip indices for which there is no pid_entry, PIDs for
-		 * which there is no corresponding process, a PID of 0,
-		 * and anything the security policy doesn't allow
-		 * us to look at.
+		 * which there is no corresponding process, a PID of 0, the
+		 * zsched process for the zone, and anything the security
+		 * policy doesn't allow us to look at.
 		 */
 		if ((p = pid_entry(i)) == NULL || p->p_stat == SIDL ||
 		    p->p_pid == 0 || p->p_zone != zone ||
+		    p == zone->zone_zsched ||
 		    secpolicy_basic_procinfo(CRED(), p, curproc) != 0) {
 			mutex_exit(&pidlock);
 			goto next;
 		}
 
-		/*
-		 * Convert pid to the Linux default of 1 if we're the zone's
-		 * init process, or 0 if zsched, otherwise use the value from
-		 * the proc structure
-		 */
+		/* Translate the pid (e.g. initpid to 1) */
 		lxpr_fixpid(LXPTOZ(lxpnp), p, &pid, NULL);
 		raw_pid = p->p_pid;
 
@@ -7300,10 +7286,7 @@ lxpr_readlink(vnode_t *vp, uio_t *uiop, cred_t *cr, caller_context_t *ct)
 	} else {
 		switch (lxpnp->lxpr_type) {
 		case LXPR_SELF:
-			/*
-			 * Convert pid to the Linux default of 1 if we're the
-			 * zone's init process or 0 if zsched.
-			 */
+			/* Translate the pid (e.g. initpid to 1) */
 			lxpr_fixpid(LXPTOZ(lxpnp), curproc, &pid, NULL);
 
 			/*
-- 
2.21.0

