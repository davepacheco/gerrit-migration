From 9899e984f1ab561042cf8fe1e7a47a4c5d902686 Mon Sep 17 00:00:00 2001
From: Ryan Zezeski <rpz@joyent.com>
Date: Wed, 17 Aug 2016 14:28:15 -0700
Subject: [PATCH] OS-4601 lxbrand clock_getres() returns success for invalid
 clocks

---
 usr/src/uts/common/brand/lx/syscall/lx_timer.c | 15 +++++++++++----
 1 file changed, 11 insertions(+), 4 deletions(-)

diff --git a/usr/src/uts/common/brand/lx/syscall/lx_timer.c b/usr/src/uts/common/brand/lx/syscall/lx_timer.c
index c102334156..17ca59b534 100644
--- a/usr/src/uts/common/brand/lx/syscall/lx_timer.c
+++ b/usr/src/uts/common/brand/lx/syscall/lx_timer.c
@@ -257,15 +257,22 @@ lx_clock_getres(int clock, timespec_t *tp)
 {
 	lx_clock_backend_t *backend;
 
-	if (tp == NULL) {
-		return (0);
-	}
-
 	if ((backend = LX_CLOCK_BACKEND(clock)) == NULL) {
 		lx_clock_unsupported(clock);
 		return (set_errno(EINVAL));
 	}
 
+	/*
+	 * It is important this check is performed after the clock
+	 * check. Both glibc and musl, in their clock_getcpuclockid(),
+	 * use clock_getres() with a NULL tp to validate a clock
+	 * value. Performing the tp check before the clock check could
+	 * indicate a valid clock to libc when it shouldn't.
+	 */
+	if (tp == NULL) {
+		return (0);
+	}
+
 	return (backend->lclk_clock_getres(backend->lclk_ntv_id, tp));
 }
 
-- 
2.21.0

