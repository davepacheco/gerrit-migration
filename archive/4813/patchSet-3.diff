From c6a46fce4173404a1ddd92e98d565ff9e301a009 Mon Sep 17 00:00:00 2001
From: Robert Mustacchi <rm@joyent.com>
Date: Fri, 7 Sep 2018 06:23:36 +0000
Subject: [PATCH] OS-7167 Need support for new EPYC ISA extensions

---
 usr/src/common/dis/i386/dis_tables.c          | 210 ++++++++++++------
 usr/src/common/elfcap/elfcap.c                |  32 +++
 usr/src/common/elfcap/elfcap.h                |   6 +-
 .../util-tests/tests/dis/i386/32.clflush.out  |   4 +
 .../util-tests/tests/dis/i386/32.clflush.s    |  29 +++
 .../util-tests/tests/dis/i386/64.clflush.out  |   4 +
 .../util-tests/tests/dis/i386/64.clflush.s    |  29 +++
 .../util-tests/tests/dis/i386/64.fsbase.out   |   8 +
 .../util-tests/tests/dis/i386/64.fsbase.s     |  34 +++
 .../util-tests/tests/dis/i386/tst.mwait.out   |   2 +
 .../util-tests/tests/dis/i386/tst.mwait.s     |   4 +-
 .../uts/common/brand/lx/procfs/lx_prvnops.c   |   6 +-
 usr/src/uts/common/sys/auxv_386.h             |  52 +++--
 usr/src/uts/i86pc/os/cpuid.c                  |  80 ++++++-
 usr/src/uts/intel/ia32/os/archdep.c           |   7 +-
 usr/src/uts/intel/sys/x86_archext.h           |  78 ++++++-
 16 files changed, 473 insertions(+), 112 deletions(-)
 create mode 100644 usr/src/test/util-tests/tests/dis/i386/32.clflush.out
 create mode 100644 usr/src/test/util-tests/tests/dis/i386/32.clflush.s
 create mode 100644 usr/src/test/util-tests/tests/dis/i386/64.clflush.out
 create mode 100644 usr/src/test/util-tests/tests/dis/i386/64.clflush.s
 create mode 100644 usr/src/test/util-tests/tests/dis/i386/64.fsbase.out
 create mode 100644 usr/src/test/util-tests/tests/dis/i386/64.fsbase.s

diff --git a/usr/src/common/dis/i386/dis_tables.c b/usr/src/common/dis/i386/dis_tables.c
index 78a9881b2a..afb2b551b2 100644
--- a/usr/src/common/dis/i386/dis_tables.c
+++ b/usr/src/common/dis/i386/dis_tables.c
@@ -21,7 +21,7 @@
  */
 /*
  * Copyright (c) 2003, 2010, Oracle and/or its affiliates. All rights reserved.
- * Copyright 2017 Joyent, Inc.
+ * Copyright 2018 Joyent, Inc.
  */
 
 /*
@@ -30,7 +30,7 @@
  */
 
 /*	Copyright (c) 1988 AT&T	*/
-/*	  All Rights Reserved  	*/
+/*	  All Rights Reserved	*/
 
 #include	"dis_tables.h"
 
@@ -44,8 +44,8 @@
  *
  * The behavior of this file can be controlled by one of the following flags:
  *
- * 	DIS_TEXT	Include text for disassembly
- * 	DIS_MEM		Include memory-size calculations
+ *	DIS_TEXT	Include text for disassembly
+ *	DIS_MEM		Include memory-size calculations
  *
  * Either or both of these can be defined.
  *
@@ -65,7 +65,7 @@ extern size_t strlcat(char *, const char *, size_t);
 #endif
 
 
-#define		TERM 	0	/* used to indicate that the 'indirect' */
+#define		TERM	0	/* used to indicate that the 'indirect' */
 				/* field terminates - no pointer.	*/
 
 /* Used to decode instructions. */
@@ -115,7 +115,7 @@ enum {
 	SEG,
 	MR,
 	RM,
-	RM_66r,		/* RM, but with a required 0x66 prefix */ 
+	RM_66r,		/* RM, but with a required 0x66 prefix */
 	IA,
 	MA,
 	SD,
@@ -134,7 +134,7 @@ enum {
 	NORM,		/* instructions w/o ModR/M byte, no memory access */
 	IMPLMEM,	/* instructions w/o ModR/M byte, implicit mem access */
 	O,		/* for call	*/
-	JTAB,		/* jump table 	*/
+	JTAB,		/* jump table	*/
 	IMUL,		/* for 186 iimul instr  */
 	CBW,		/* so data16 can be evaluated for cbw and variants */
 	MvI,		/* for 186 logicals */
@@ -169,7 +169,7 @@ enum {
 	MMO,		/* Prefixable MMX/SIMD-Int	mm/mem	-> mm */
 	MMOIMPL,	/* Prefixable MMX/SIMD-Int	mm	-> mm (mem) */
 	MMO3P,		/* Prefixable MMX/SIMD-Int	mm	-> r32,imm8 */
-	MMOM3,		/* Prefixable MMX/SIMD-Int	mm	-> r32 	*/
+	MMOM3,		/* Prefixable MMX/SIMD-Int	mm	-> r32	*/
 	MMOS,		/* Prefixable MMX/SIMD-Int	mm	-> mm/mem */
 	MMOMS,		/* Prefixable MMX/SIMD-Int	mm	-> mem */
 	MMOPM,		/* MMX/SIMD-Int			mm/mem	-> mm,imm8 */
@@ -187,33 +187,34 @@ enum {
 	XMMOXMM,	/* Prefixable SIMD		xmm/mem	-> mm	*/
 	XMMOM,		/* Prefixable SIMD		xmm	-> mem */
 	XMMOMS,		/* Prefixable SIMD		mem	-> xmm */
-	XMM,		/* SIMD 			xmm/mem	-> xmm */
+	XMM,		/* SIMD				xmm/mem	-> xmm */
 	XMM_66r,	/* SIMD 0x66 prefix required	xmm/mem	-> xmm */
-	XMM_66o,	/* SIMD 0x66 prefix optional 	xmm/mem	-> xmm */
+	XMM_66o,	/* SIMD 0x66 prefix optional	xmm/mem	-> xmm */
 	XMMXIMPL,	/* SIMD				xmm	-> xmm (mem) */
 	XMM3P,		/* SIMD				xmm	-> r32,imm8 */
 	XMM3PM_66r,	/* SIMD 0x66 prefix required	xmm	-> r32/mem,imm8 */
-	XMMP,		/* SIMD 			xmm/mem w/to xmm,imm8 */
+	XMMP,		/* SIMD				xmm/mem w/to xmm,imm8 */
 	XMMP_66o,	/* SIMD 0x66 prefix optional	xmm/mem w/to xmm,imm8 */
 	XMMP_66r,	/* SIMD 0x66 prefix required	xmm/mem w/to xmm,imm8 */
-	XMMPRM,		/* SIMD 			r32/mem -> xmm,imm8 */
+	XMMPRM,		/* SIMD				r32/mem -> xmm,imm8 */
 	XMMPRM_66r,	/* SIMD 0x66 prefix required	r32/mem -> xmm,imm8 */
 	XMMS,		/* SIMD				xmm	-> xmm/mem */
-	XMMM,		/* SIMD 			mem	-> xmm */
+	XMMM,		/* SIMD				mem	-> xmm */
 	XMMM_66r,	/* SIMD	0x66 prefix required	mem	-> xmm */
 	XMMMS,		/* SIMD				xmm	-> mem */
-	XMM3MX,		/* SIMD 			r32/mem -> xmm */
-	XMM3MXS,	/* SIMD 			xmm	-> r32/mem */
-	XMMSH,		/* SIMD 			xmm,imm8 */
-	XMMXM3,		/* SIMD 			xmm/mem -> r32 */
-	XMMX3,		/* SIMD 			xmm	-> r32 */
-	XMMXMM,		/* SIMD 			xmm/mem	-> mm */
-	XMMMX,		/* SIMD 			mm	-> xmm */
-	XMMXM,		/* SIMD 			xmm	-> mm */
-        XMMX2I,		/* SIMD				xmm -> xmm, imm, imm */
-        XMM2I,		/* SIMD				xmm, imm, imm */
+	XMM3MX,		/* SIMD				r32/mem -> xmm */
+	XMM3MXS,	/* SIMD				xmm	-> r32/mem */
+	XMMSH,		/* SIMD				xmm,imm8 */
+	XMMXM3,		/* SIMD				xmm/mem -> r32 */
+	XMMX3,		/* SIMD				xmm	-> r32 */
+	XMMXMM,		/* SIMD				xmm/mem	-> mm */
+	XMMMX,		/* SIMD				mm	-> xmm */
+	XMMXM,		/* SIMD				xmm	-> mm */
+	XMMX2I,		/* SIMD				xmm -> xmm, imm, imm */
+	XMM2I,		/* SIMD				xmm, imm, imm */
 	XMMFENCE,	/* SIMD lfence or mfence */
 	XMMSFNC,	/* SIMD sfence (none or mem) */
+	FSGS,		/* FSGSBASE if reg */
 	XGETBV_XSETBV,
 	VEX_NONE,	/* VEX  no operand */
 	VEX_MO,		/* VEX	mod_rm		               -> implicit reg */
@@ -221,21 +222,21 @@ enum {
 	VEX_VRMrX,	/* VEX  mod_rm, VEX.vvvv               -> mod_rm */
 	VEX_RRX,	/* VEX  VEX.vvvv, mod_reg              -> mod_rm */
 	VEX_RMRX,	/* VEX  VEX.vvvv, mod_rm, imm8[7:4]    -> mod_reg */
-	VEX_MX,         /* VEX  mod_rm                         -> mod_reg */
-	VEX_MXI,        /* VEX  mod_rm, imm8                   -> mod_reg */
-	VEX_XXI,        /* VEX  mod_rm, imm8                   -> VEX.vvvv */
-	VEX_MR,         /* VEX  mod_rm                         -> mod_reg */
-	VEX_RRI,        /* VEX  mod_reg, mod_rm                -> implicit(eflags/r32) */
-	VEX_RX,         /* VEX  mod_reg                        -> mod_rm */
-	VEX_KRR,        /* VEX  mod_rm                         -> mod_reg */
-	VEX_KMR,        /* VEX  mod_reg                        -> mod_rm */
-	VEX_KRM,        /* VEX  mod_rm                         -> mod_reg */
-	VEX_RR,         /* VEX  mod_rm                         -> mod_reg */
-	VEX_RRi,        /* VEX  mod_rm, imm8                   -> mod_reg */
-	VEX_RM,         /* VEX  mod_reg                        -> mod_rm */
+	VEX_MX,		/* VEX  mod_rm                         -> mod_reg */
+	VEX_MXI,	/* VEX  mod_rm, imm8                   -> mod_reg */
+	VEX_XXI,	/* VEX  mod_rm, imm8                   -> VEX.vvvv */
+	VEX_MR,		/* VEX  mod_rm                         -> mod_reg */
+	VEX_RRI,	/* VEX  mod_reg, mod_rm                -> implicit(eflags/r32) */
+	VEX_RX,		/* VEX  mod_reg                        -> mod_rm */
+	VEX_KRR,	/* VEX  mod_rm                         -> mod_reg */
+	VEX_KMR,	/* VEX  mod_reg                        -> mod_rm */
+	VEX_KRM,	/* VEX  mod_rm                         -> mod_reg */
+	VEX_RR,		/* VEX  mod_rm                         -> mod_reg */
+	VEX_RRi,	/* VEX  mod_rm, imm8                   -> mod_reg */
+	VEX_RM,		/* VEX  mod_reg                        -> mod_rm */
 	VEX_RIM,	/* VEX  mod_reg, imm8                  -> mod_rm */
-	VEX_RRM,        /* VEX  VEX.vvvv, mod_reg              -> mod_rm */
-	VEX_RMX,        /* VEX  VEX.vvvv, mod_rm               -> mod_reg */
+	VEX_RRM,	/* VEX  VEX.vvvv, mod_reg              -> mod_rm */
+	VEX_RMX,	/* VEX  VEX.vvvv, mod_rm               -> mod_reg */
 	VEX_SbVM,	/* VEX  SIB, VEX.vvvv                  -> mod_rm */
 	VMx,		/* vmcall/vmlaunch/vmresume/vmxoff */
 	VMxo,		/* VMx instruction with optional prefix */
@@ -243,8 +244,8 @@ enum {
 	BLS,		/* BLSR, BLSMSK, BLSI */
 	FMA,		/* FMA instructions, all VEX_RMrX */
 	ADX,		/* ADX instructions, support REX.w, mod_rm->mod_reg */
-	EVEX_RX,        /* EVEX  mod_reg                      -> mod_rm */
-	EVEX_MX,        /* EVEX  mod_rm                       -> mod_reg */
+	EVEX_RX,	/* EVEX  mod_reg                      -> mod_rm */
+	EVEX_MX,	/* EVEX  mod_rm                       -> mod_reg */
 	EVEX_RMrX	/* EVEX  EVEX.vvvv, mod_rm            -> mod_reg */
 };
 
@@ -565,7 +566,7 @@ const instable_t dis_opPause = TNS("pause", NORM);
  */
 const instable_t dis_op0F00[8] = {
 
-/*  [0]  */	TNS("sldt",M),		TNS("str",M),		TNSy("lldt",M), 	TNSy("ltr",M),
+/*  [0]  */	TNS("sldt",M),		TNS("str",M),		TNSy("lldt",M),		TNSy("ltr",M),
 /*  [4]  */	TNSZ("verr",M,2),	TNSZ("verw",M,2),	INVALID,		INVALID,
 };
 
@@ -576,7 +577,7 @@ const instable_t dis_op0F00[8] = {
 const instable_t dis_op0F01[8] = {
 
 /*  [0]  */	TNSZ("sgdt",VMx,6),	TNSZ("sidt",MONITOR_MWAIT,6),	TNSZ("lgdt",XGETBV_XSETBV,6),	TNSZ("lidt",SVM,6),
-/*  [4]  */	TNSZ("smsw",M,2),	INVALID, 		TNSZ("lmsw",M,2),	TNS("invlpg",SWAPGS_RDTSCP),
+/*  [4]  */	TNSZ("smsw",M,2),	INVALID,		TNSZ("lmsw",M,2),	TNS("invlpg",SWAPGS_RDTSCP),
 };
 
 /*
@@ -589,13 +590,21 @@ const instable_t dis_op0F18[8] = {
 };
 
 /*
- * 	Decode table for 0x0FAE opcodes -- SIMD state save/restore
+ *	Decode table for 0x0FAE opcodes -- SIMD state save/restore
  */
 const instable_t dis_op0FAE[8] = {
-/*  [0]  */	TNSZ("fxsave",M,512),	TNSZ("fxrstor",M,512),	TNS("ldmxcsr",M),	TNS("stmxcsr",M),
+/*  [0]  */	TNSZ("fxsave",FSGS,512),TNSZ("fxrstor",FSGS,512),TNS("ldmxcsr",FSGS),	TNS("stmxcsr",FSGS),
 /*  [4]  */	TNSZ("xsave",M,512),	TNS("lfence",XMMFENCE), TNS("mfence",XMMFENCE),	TNS("sfence",XMMSFNC),
 };
 
+/*
+ *	Decode table for 0xF30FAE opcodes -- FSGSBASE
+ */
+const instable_t dis_opF30FAE[8] = {
+/*  [0]  */	TNSx("rdfsbase",FSGS),	TNSx("rdgsbase",FSGS),	TNSx("wrfsbase",FSGS),	TNSx("wrgsbase",FSGS),
+/*  [4]  */	INVALID,		INVALID,		INVALID,		INVALID,
+};
+
 /*
  *	Decode table for 0x0FBA opcodes
  */
@@ -607,7 +616,7 @@ const instable_t dis_op0FBA[8] = {
 };
 
 /*
- * 	Decode table for 0x0FC7 opcode (group 9)
+ *	Decode table for 0x0FC7 opcode (group 9)
  */
 
 const instable_t dis_op0FC7[8] = {
@@ -617,7 +626,7 @@ const instable_t dis_op0FC7[8] = {
 };
 
 /*
- * 	Decode table for 0x0FC7 opcode (group 9) mode 3
+ *	Decode table for 0x0FC7 opcode (group 9) mode 3
  */
 
 const instable_t dis_op0FC7m3[8] = {
@@ -627,7 +636,7 @@ const instable_t dis_op0FC7m3[8] = {
 };
 
 /*
- * 	Decode table for 0x0FC7 opcode with 0x66 prefix
+ *	Decode table for 0x0FC7 opcode with 0x66 prefix
  */
 
 const instable_t dis_op660FC7[8] = {
@@ -637,7 +646,7 @@ const instable_t dis_op660FC7[8] = {
 };
 
 /*
- * 	Decode table for 0x0FC7 opcode with 0xF3 prefix
+ *	Decode table for 0x0FC7 opcode with 0xF3 prefix
  */
 
 const instable_t dis_opF30FC7[8] = {
@@ -670,7 +679,7 @@ const instable_t dis_op0F7123[4][8] = {
 /*      .4 */	TNS("psrad",MMOSH),	INVALID,		TNS("pslld",MMOSH),	INVALID,
 }, {
 /*  [73].0 */	INVALID,		INVALID,		TNS("psrlq",MMOSH),	TNS("INVALID",MMOSH),
-/*      .4 */	INVALID,		INVALID, 		TNS("psllq",MMOSH),	TNS("INVALID",MMOSH),
+/*      .4 */	INVALID,		INVALID,		TNS("psllq",MMOSH),	TNS("INVALID",MMOSH),
 } };
 
 /*
@@ -1881,8 +1890,8 @@ const instable_t dis_opAVX660F3A[256] = {
 };
 
 /*
- * 	Decode table for 0x0F0D which uses the first byte of the mod_rm to
- * 	indicate a sub-code.
+ *	Decode table for 0x0F0D which uses the first byte of the mod_rm to
+ *	indicate a sub-code.
  */
 const instable_t dis_op0F0D[8] = {
 /*  [00]  */	INVALID,		TNS("prefetchw",PREF),	TNS("prefetchwt1",PREF),INVALID,
@@ -1956,7 +1965,7 @@ const instable_t dis_op0F[16][16] = {
 /*  [BC]  */	TS("bsf",MRw),		TS("bsr",MRw),		TS("movsb",MOVZ),	TNS("movswl",MOVZ),
 }, {
 /*  [C0]  */	TNS("xaddb",XADDB),	TS("xadd",RMw),		TNSZ("cmpps",XMMOPM,16),TNS("movnti",RM),
-/*  [C4]  */	TNSZ("pinsrw",MMOPRM,2),TNS("pextrw",MMO3P), 	TNSZ("shufps",XMMOPM,16),IND(dis_op0FC7),
+/*  [C4]  */	TNSZ("pinsrw",MMOPRM,2),TNS("pextrw",MMO3P),	TNSZ("shufps",XMMOPM,16),IND(dis_op0FC7),
 /*  [C8]  */	INVALID,		INVALID,		INVALID,		INVALID,
 /*  [CC]  */	INVALID,		INVALID,		INVALID,		INVALID,
 }, {
@@ -2039,7 +2048,7 @@ const instable_t dis_opAVX0F[16][16] = {
 /*  [BC]  */	INVALID,		INVALID,		INVALID,		INVALID,
 }, {
 /*  [C0]  */	INVALID,		INVALID,		TNSZ("vcmpps",VEX_RMRX,16),INVALID,
-/*  [C4]  */	INVALID,		INVALID,	 	TNSZ("vshufps",VEX_RMRX,16),INVALID,
+/*  [C4]  */	INVALID,		INVALID,		TNSZ("vshufps",VEX_RMRX,16),INVALID,
 /*  [C8]  */	INVALID,		INVALID,		INVALID,		INVALID,
 /*  [CC]  */	INVALID,		INVALID,		INVALID,		INVALID,
 }, {
@@ -2365,7 +2374,7 @@ const instable_t dis_distable[16][16] = {
 /* [B,8] */	TS("mov",IR),		TS("mov",IR),		TS("mov",IR),		TS("mov",IR),
 /* [B,C] */	TS("mov",IR),		TS("mov",IR),		TS("mov",IR),		TS("mov",IR),
 }, {
-/* [C,0] */	IND(dis_opC0),		IND(dis_opC1), 		TNSyp("ret",RET),	TNSyp("ret",NORM),
+/* [C,0] */	IND(dis_opC0),		IND(dis_opC1),		TNSyp("ret",RET),	TNSyp("ret",NORM),
 /* [C,4] */	TNSx("les",MR),		TNSx("lds",MR),		TNS("movb",IMw),	TS("mov",IMw),
 /* [C,8] */	TNSyp("enter",ENTER),	TNSyp("leave",NORM),	TNS("lret",RET),	TNS("lret",NORM),
 /* [C,C] */	TNS("int",INT3),	TNS("int",INTx),	TNSx("into",NORM),	TNS("iret",NORM),
@@ -2484,7 +2493,7 @@ static int isize64[] = {1, 2, 4, 8};
  *
  * We further have to subdivide this based on the value of VEX_W and the value
  * of VEX_L. The array is constructed to be indexed as:
- * 	[opcode - 0x90][VEX_W][VEX_L].
+ *	[opcode - 0x90][VEX_W][VEX_L].
  */
 /* w = 0, 0x90 */
 typedef struct dis_gather_regs {
@@ -2917,7 +2926,7 @@ dtrace_get_operand(dis86_t *x, uint_t mode, uint_t r_m, int wbit, int opindex)
 	uint_t ss;		/* scale-factor from opcode */
 	uint_t index;		/* index register number */
 	uint_t base;		/* base register number */
-	int dispsize;   	/* size of displacement in bytes */
+	int dispsize;		/* size of displacement in bytes */
 #ifdef DIS_TEXT
 	char *opnd = x->d86_opnd[opindex].d86_opnd;
 #endif
@@ -3156,7 +3165,7 @@ dtrace_get_operand(dis86_t *x, uint_t mode, uint_t r_m, int wbit, int opindex)
 /*
  * Similar, but for 2 operands plus an immediate.
  * vbit indicates direction
- * 	0 for "opcode imm, r, r_m" or
+ *	0 for "opcode imm, r, r_m" or
  *	1 for "opcode imm, r_m, r"
  */
 #define	THREEOPERAND(x, mode, reg, r_m, rex_prefix, wbit, w2, immsize, vbit) { \
@@ -4016,8 +4025,8 @@ not_avx512:
 				/*
 				 * Calculate our offset in dis_op0F
 				 */
-				if ((uintptr_t)dp - (uintptr_t)dis_op0F
-				    > sizeof (dis_op0F))
+				if ((uintptr_t)dp - (uintptr_t)dis_op0F >
+				    sizeof (dis_op0F))
 					goto error;
 
 				off = ((uintptr_t)dp - (uintptr_t)dis_op0F) /
@@ -4030,6 +4039,19 @@ not_avx512:
 			}
 		}
 		break;
+	case FSGS:
+		if (rep_prefix == 0xf3) {
+			if ((uintptr_t)dp - (uintptr_t)dis_op0FAE >
+			    sizeof (dis_op0FAE))
+				goto error;
+
+			off = ((uintptr_t)dp - (uintptr_t)dis_op0FAE) /
+			    sizeof (instable_t);
+			dp = (instable_t *)&dis_opF30FAE[off];
+			rep_prefix = 0;
+		} else if (rep_prefix != 0x00) {
+			goto error;
+		}
 	}
 
 	/*
@@ -4419,6 +4441,24 @@ just_mem:
 		} else if (mode == 3 && r_m == 1) {
 #ifdef DIS_TEXT
 			(void) strncpy(x->d86_mnem, "rdtscp", OPLEN);
+#endif
+			NOMEM;
+			break;
+		} else if (mode == 3 && r_m == 2) {
+#ifdef DIS_TEXT
+			(void) strncpy(x->d86_mnem, "monitorx", OPLEN);
+#endif
+			NOMEM;
+			break;
+		} else if (mode == 3 && r_m == 3) {
+#ifdef DIS_TEXT
+			(void) strncpy(x->d86_mnem, "mwaitx", OPLEN);
+#endif
+			NOMEM;
+			break;
+		} else if (mode == 3 && r_m == 4) {
+#ifdef DIS_TEXT
+			(void) strncpy(x->d86_mnem, "clzero", OPLEN);
 #endif
 			NOMEM;
 			break;
@@ -5184,22 +5224,44 @@ xmmprm:
 		dtrace_get_modrm(x, &mode, &reg, &r_m);
 
 		/* sfence doesn't take operands */
+		if (mode != REG_ONLY) {
+			if (opnd_size_prefix == 0x66) {
 #ifdef DIS_TEXT
-		if (mode == REG_ONLY) {
-			(void) strlcat(x->d86_mnem, "sfence", OPLEN);
-		} else {
-			(void) strlcat(x->d86_mnem, "clflush", OPLEN);
+				(void) strlcat(x->d86_mnem, "clflushopt",
+				    OPLEN);
+#endif
+			} else if (opnd_size_prefix == 0) {
+#ifdef DIS_TEXT
+				(void) strlcat(x->d86_mnem, "clflush", OPLEN);
+#endif
+			} else {
+				/* Unknown instruction */
+				goto error;
+			}
+
 			dtrace_rex_adjust(rex_prefix, mode, &reg, &r_m);
 			dtrace_get_operand(x, mode, r_m, BYTE_OPND, 0);
 			NOMEM;
+#ifdef DIS_TEXT
+		} else {
+			(void) strlcat(x->d86_mnem, "sfence", OPLEN);
+#endif
 		}
-#else
-		if (mode != REG_ONLY) {
-			dtrace_rex_adjust(rex_prefix, mode, &reg, &r_m);
-			dtrace_get_operand(x, mode, r_m, LONG_OPND, 0);
+		break;
+
+	case FSGS:
+		/*
+		 * The FSGSBASE instructions are taken only when the mode is set
+		 * to registers. They share opcodes with instructions like
+		 * fxrstor, stmxcsr, etc. We handle the repz prefix earlier.
+		 */
+		wbit = WBIT(opcode2);
+		dtrace_get_modrm(x, &mode, &reg, &r_m);
+		dtrace_rex_adjust(rex_prefix, mode, NULL, &r_m);
+		dtrace_get_operand(x, mode, r_m, wbit, 0);
+		if (mode == REG_ONLY) {
 			NOMEM;
 		}
-#endif
 		break;
 
 	/*
@@ -5224,8 +5286,8 @@ xmmprm:
 			/*
 			 * Only the following exact byte sequences are allowed:
 			 *
-			 * 	0f ae e8	lfence
-			 * 	0f ae f0	mfence
+			 *	0f ae e8	lfence
+			 *	0f ae f0	mfence
 			 */
 			if ((uint8_t)x->d86_bytes[x->d86_len - 1] != 0xe8 &&
 			    (uint8_t)x->d86_bytes[x->d86_len - 1] != 0xf0)
@@ -5235,7 +5297,15 @@ xmmprm:
 			if (reg == 5) {
 				(void) strncpy(x->d86_mnem, "xrstor", OPLEN);
 			} else if (reg == 6) {
-				(void) strncpy(x->d86_mnem, "xsaveopt", OPLEN);
+				if (opnd_size_prefix == 0x66) {
+					(void) strncpy(x->d86_mnem, "clwb",
+					    OPLEN);
+				} else if (opnd_size_prefix == 0x00) {
+					(void) strncpy(x->d86_mnem, "xsaveopt",
+					    OPLEN);
+				} else {
+					goto error;
+				}
 			} else {
 				goto error;
 			}
diff --git a/usr/src/common/elfcap/elfcap.c b/usr/src/common/elfcap/elfcap.c
index 54aca25364..a23448f96b 100644
--- a/usr/src/common/elfcap/elfcap.c
+++ b/usr/src/common/elfcap/elfcap.c
@@ -391,6 +391,38 @@ static const elfcap_desc_t hw2_386[ELFCAP_NUM_HW2_386] = {
 	{						/* 0x00100000 */
 		AV_386_2_SHA, STRDESC("AV_386_2_SHA"),
 		STRDESC("SHA"), STRDESC("sha"),
+	},
+	{						/* 0x00200000 */
+		AV_386_2_FSGSBASE, STRDESC("AV_386_2_FSGSBASE"),
+		STRDESC("FSGSBASE"), STRDESC("fsgsbase")
+	},
+	{						/* 0x00400000 */
+		AV_386_2_CLFLUSHOPT, STRDESC("AV_386_2_CLFLUSHOPT"),
+		STRDESC("CLFLUSHOPT"), STRDESC("clflushopt")
+	},
+	{						/* 0x00800000 */
+		AV_386_2_CLWB, STRDESC("AV_386_2_CLWB"),
+		STRDESC("CLWB"), STRDESC("clwb")
+	},
+	{						/* 0x01000000 */
+		AV_386_2_MONITORX, STRDESC("AV_386_2_MONITORX"),
+		STRDESC("MONITORX"), STRDESC("monitorx")
+	},
+	{						/* 0x02000000 */
+		AV_386_2_CLZERO, STRDESC("AV_386_2_CLZERO"),
+		STRDESC("CLZERO"), STRDESC("clzero")
+	},
+	{						/* 0x04000000 */
+		AV_386_2_XOP, STRDESC("AV_386_2_XOP"),
+		STRDESC("XOP"), STRDESC("xop")
+	},
+	{						/* 0x08000000 */
+		AV_386_2_FMA4, STRDESC("AV_386_2_FMA4"),
+		STRDESC("FMA4"), STRDESC("fma4")
+	},
+	{						/* 0x10000000 */
+		AV_386_2_TBM, STRDESC("AV_386_2_TBM"),
+		STRDESC("TBM"), STRDESC("tbm")
 	}
 };
 
diff --git a/usr/src/common/elfcap/elfcap.h b/usr/src/common/elfcap/elfcap.h
index 123514b0a6..7dafb11575 100644
--- a/usr/src/common/elfcap/elfcap.h
+++ b/usr/src/common/elfcap/elfcap.h
@@ -50,8 +50,8 @@ typedef uint32_t elfcap_mask_t;
 
 typedef enum {
 	ELFCAP_STYLE_FULL =	1,	/* Full formal name (e.g. AV_386_SSE) */
-	ELFCAP_STYLE_UC = 	2,	/* Informal upper case (e.g. SSE) */
-	ELFCAP_STYLE_LC = 	3,	/* Informal lower case (e.g. sse) */
+	ELFCAP_STYLE_UC =	2,	/* Informal upper case (e.g. SSE) */
+	ELFCAP_STYLE_LC =	3,	/* Informal lower case (e.g. sse) */
 
 	ELFCAP_STYLE_F_ICMP =	0x0100	 /* Use case insensitive strcmp */
 } elfcap_style_t;
@@ -115,7 +115,7 @@ typedef enum {
 #define	ELFCAP_NUM_SF1			3
 #define	ELFCAP_NUM_HW1_SPARC		17
 #define	ELFCAP_NUM_HW1_386		32
-#define	ELFCAP_NUM_HW2_386		21
+#define	ELFCAP_NUM_HW2_386		29
 
 
 /*
diff --git a/usr/src/test/util-tests/tests/dis/i386/32.clflush.out b/usr/src/test/util-tests/tests/dis/i386/32.clflush.out
new file mode 100644
index 0000000000..a1d308ef41
--- /dev/null
+++ b/usr/src/test/util-tests/tests/dis/i386/32.clflush.out
@@ -0,0 +1,4 @@
+    libdis_test:     66 0f ae 30        clwb   (%eax)
+    libdis_test+0x4: 0f ae 3b           clflush (%ebx)
+    libdis_test+0x7: 66 0f ae 39        clflushopt (%ecx)
+    libdis_test+0xb: 0f 01 fc           clzero 
diff --git a/usr/src/test/util-tests/tests/dis/i386/32.clflush.s b/usr/src/test/util-tests/tests/dis/i386/32.clflush.s
new file mode 100644
index 0000000000..98cc6ca07f
--- /dev/null
+++ b/usr/src/test/util-tests/tests/dis/i386/32.clflush.s
@@ -0,0 +1,29 @@
+/*
+ * This file and its contents are supplied under the terms of the
+ * Common Development and Distribution License ("CDDL"), version 1.0.
+ * You may only use this file in accordance with the terms of version
+ * 1.0 of the CDDL.
+ *
+ * A full copy of the text of the CDDL should have accompanied this
+ * source.  A copy of the CDDL is also available via the Internet at
+ * http://www.illumos.org/license/CDDL.
+ */
+
+/*
+ * Copyright (c) 2018, Joyent, Inc.
+ */
+
+/*
+ * Test various cache related instructions.
+ */
+
+.text
+.align 16
+.globl libdis_test
+.type libdis_test, @function
+libdis_test:
+	clwb		(%eax)
+	clflush		(%ebx)
+	clflushopt	(%ecx)
+	clzero
+.size libdis_test, [.-libdis_test]
diff --git a/usr/src/test/util-tests/tests/dis/i386/64.clflush.out b/usr/src/test/util-tests/tests/dis/i386/64.clflush.out
new file mode 100644
index 0000000000..03f8c439ca
--- /dev/null
+++ b/usr/src/test/util-tests/tests/dis/i386/64.clflush.out
@@ -0,0 +1,4 @@
+    libdis_test:     66 0f ae 30        clwb   (%rax)
+    libdis_test+0x4: 0f ae 3b           clflush (%rbx)
+    libdis_test+0x7: 66 0f ae 39        clflushopt (%rcx)
+    libdis_test+0xb: 0f 01 fc           clzero 
diff --git a/usr/src/test/util-tests/tests/dis/i386/64.clflush.s b/usr/src/test/util-tests/tests/dis/i386/64.clflush.s
new file mode 100644
index 0000000000..b3749da509
--- /dev/null
+++ b/usr/src/test/util-tests/tests/dis/i386/64.clflush.s
@@ -0,0 +1,29 @@
+/*
+ * This file and its contents are supplied under the terms of the
+ * Common Development and Distribution License ("CDDL"), version 1.0.
+ * You may only use this file in accordance with the terms of version
+ * 1.0 of the CDDL.
+ *
+ * A full copy of the text of the CDDL should have accompanied this
+ * source.  A copy of the CDDL is also available via the Internet at
+ * http://www.illumos.org/license/CDDL.
+ */
+
+/*
+ * Copyright (c) 2018, Joyent, Inc.
+ */
+
+/*
+ * Test various cache related instructions.
+ */
+
+.text
+.align 16
+.globl libdis_test
+.type libdis_test, @function
+libdis_test:
+	clwb		(%rax)
+	clflush		(%rbx)
+	clflushopt	(%rcx)
+	clzero
+.size libdis_test, [.-libdis_test]
diff --git a/usr/src/test/util-tests/tests/dis/i386/64.fsbase.out b/usr/src/test/util-tests/tests/dis/i386/64.fsbase.out
new file mode 100644
index 0000000000..2c38da53db
--- /dev/null
+++ b/usr/src/test/util-tests/tests/dis/i386/64.fsbase.out
@@ -0,0 +1,8 @@
+    libdis_test:      f3 48 0f ae c0     rdfsbase %rax
+    libdis_test+0x5:  f3 48 0f ae cb     rdgsbase %rbx
+    libdis_test+0xa:  f3 48 0f ae d1     wrfsbase %rcx
+    libdis_test+0xf:  f3 48 0f ae da     wrgsbase %rdx
+    libdis_test+0x14: f3 0f ae c0        rdfsbase %eax
+    libdis_test+0x18: f3 0f ae cb        rdgsbase %ebx
+    libdis_test+0x1c: f3 0f ae d1        wrfsbase %ecx
+    libdis_test+0x20: f3 0f ae da        wrgsbase %edx
diff --git a/usr/src/test/util-tests/tests/dis/i386/64.fsbase.s b/usr/src/test/util-tests/tests/dis/i386/64.fsbase.s
new file mode 100644
index 0000000000..e06bf84420
--- /dev/null
+++ b/usr/src/test/util-tests/tests/dis/i386/64.fsbase.s
@@ -0,0 +1,34 @@
+/*
+ * This file and its contents are supplied under the terms of the
+ * Common Development and Distribution License ("CDDL"), version 1.0.
+ * You may only use this file in accordance with the terms of version
+ * 1.0 of the CDDL.
+ *
+ * A full copy of the text of the CDDL should have accompanied this
+ * source.  A copy of the CDDL is also available via the Internet at
+ * http://www.illumos.org/license/CDDL.
+ */
+
+/*
+ * Copyright (c) 2018, Joyent, Inc.
+ */
+
+/*
+ * Test FSGSBASE related instructions.
+ */
+
+.text
+.align 16
+.globl libdis_test
+.type libdis_test, @function
+libdis_test:
+	rdfsbase	%rax
+	rdgsbase	%rbx
+	wrfsbase	%rcx
+	wrgsbase	%rdx
+
+	rdfsbase	%eax
+	rdgsbase	%ebx
+	wrfsbase	%ecx
+	wrgsbase	%edx
+.size libdis_test, [.-libdis_test]
diff --git a/usr/src/test/util-tests/tests/dis/i386/tst.mwait.out b/usr/src/test/util-tests/tests/dis/i386/tst.mwait.out
index 8a6b07233e..e763ca946f 100644
--- a/usr/src/test/util-tests/tests/dis/i386/tst.mwait.out
+++ b/usr/src/test/util-tests/tests/dis/i386/tst.mwait.out
@@ -1,2 +1,4 @@
     libdis_test:     0f 01 c8           monitor 
     libdis_test+0x3: 0f 01 c9           mwait  
+    libdis_test+0x6: 0f 01 fb           mwaitx 
+    libdis_test+0x9: 0f 01 fa           monitorx 
diff --git a/usr/src/test/util-tests/tests/dis/i386/tst.mwait.s b/usr/src/test/util-tests/tests/dis/i386/tst.mwait.s
index 5ce9422a3b..85a5194e4f 100644
--- a/usr/src/test/util-tests/tests/dis/i386/tst.mwait.s
+++ b/usr/src/test/util-tests/tests/dis/i386/tst.mwait.s
@@ -10,7 +10,7 @@
  */
 
 /*
- * Copyright 2016 Joyent, Inc.
+ * Copyright (c) 2018, Joyent, Inc.
  */
 
 /*
@@ -24,4 +24,6 @@
 libdis_test:
 	monitor
 	mwait
+	mwaitx
+	monitorx
 .size libdis_test, [.-libdis_test]
diff --git a/usr/src/uts/common/brand/lx/procfs/lx_prvnops.c b/usr/src/uts/common/brand/lx/procfs/lx_prvnops.c
index 15203cee91..e5ca432bbd 100644
--- a/usr/src/uts/common/brand/lx/procfs/lx_prvnops.c
+++ b/usr/src/uts/common/brand/lx/procfs/lx_prvnops.c
@@ -4256,7 +4256,7 @@ lxpr_read_diskstats(lxpr_node_t *lxpnp, lxpr_uiobuf_t *uiobuf)
 		 *	2 - minor mumber
 		 *	3 - device name
 		 *	4 - reads completed successfully
-		 * 	5 - reads merged
+		 *	5 - reads merged
 		 *	6 - sectors read
 		 *	7 - time spent reading (ms)
 		 *	8 - writes completed
@@ -5349,7 +5349,7 @@ lxpr_read_sys_net_ipv4_tcp_max_syn_bl(lxpr_node_t *lxpnp, lxpr_uiobuf_t *uiobuf)
  *	tcp_rexmit_interval_initial:	 1000
  *	tcp_rexmit_interval_min:	  400
  *	tcp_rexmit_interval_max:	60000
- * 	tcp_rexmit_interval_extra:	    0
+ *	tcp_rexmit_interval_extra:	    0
  * Not in tcp(7p) man page.
  *
  * From the tunables guide:
@@ -5833,7 +5833,7 @@ lx_cpuinfo_mapping_t lx_cpuinfo_mappings[] = {
 	{ LXCS_CPUIDX1_ECX, CPUID_AMD_ECX_3DNP,		"3dnowprefetch" },
 	{ LXCS_CPUIDX1_ECX, CPUID_AMD_ECX_OSVW,		"osvw" },
 	{ LXCS_CPUIDX1_ECX, CPUID_AMD_ECX_IBS,		"ibs" },
-	{ LXCS_CPUIDX1_ECX, CPUID_AMD_ECX_SSE5,		"xop" },
+	{ LXCS_CPUIDX1_ECX, CPUID_AMD_ECX_XOP,		"xop" },
 	{ LXCS_CPUIDX1_ECX, CPUID_AMD_ECX_SKINIT,	"skinit" },
 	{ LXCS_CPUIDX1_ECX, CPUID_AMD_ECX_WDT,		"wdt" },
 	{ LXCS_CPUIDX1_ECX, CPUID_AMD_ECX_LWP,		"lwp" },
diff --git a/usr/src/uts/common/sys/auxv_386.h b/usr/src/uts/common/sys/auxv_386.h
index 0f367a4b19..80b1b44bab 100644
--- a/usr/src/uts/common/sys/auxv_386.h
+++ b/usr/src/uts/common/sys/auxv_386.h
@@ -86,29 +86,39 @@ extern "C" {
 /*
  * Flags used in AT_SUN_HWCAP2 elements
  */
-#define	AV_386_2_F16C		0x00001	/* F16C half percision extensions */
-#define	AV_386_2_RDRAND		0x00002	/* RDRAND insn */
-#define	AV_386_2_BMI1		0x00004 /* BMI1 insns */
-#define	AV_386_2_BMI2		0x00008 /* BMI2 insns */
-#define	AV_386_2_FMA		0x00010	/* FMA insns */
-#define	AV_386_2_AVX2		0x00020	/* AVX2 insns */
-#define	AV_386_2_ADX		0x00040	/* ADX insns */
-#define	AV_386_2_RDSEED		0x00080	/* RDSEED insn */
-#define	AV_386_2_AVX512F	0x00100	/* AVX512 foundation insns */
-#define	AV_386_2_AVX512DQ	0x00200	/* AVX512DQ insns */
-#define	AV_386_2_AVX512IFMA	0x00400	/* AVX512IFMA insns */
-#define	AV_386_2_AVX512PF	0x00800	/* AVX512PF insns */
-#define	AV_386_2_AVX512ER	0x01000	/* AVX512ER insns */
-#define	AV_386_2_AVX512CD	0x02000	/* AVX512CD insns */
-#define	AV_386_2_AVX512BW	0x04000	/* AVX512BW insns */
-#define	AV_386_2_AVX512VL	0x08000	/* AVX512VL insns */
-#define	AV_386_2_AVX512VBMI	0x10000	/* AVX512VBMI insns */
-#define	AV_386_2_AVX512VPOPCDQ	0x20000	/* AVX512VPOPCNTDQ insns */
-#define	AV_386_2_AVX512_4NNIW	0x40000	/* AVX512 4NNIW insns */
-#define	AV_386_2_AVX512_4FMAPS	0x80000	/* AVX512 4FMAPS insns */
-#define	AV_386_2_SHA		0x100000 /* SHA insns */
+#define	AV_386_2_F16C		0x00000001 /* F16C half percision extensions */
+#define	AV_386_2_RDRAND		0x00000002 /* RDRAND insn */
+#define	AV_386_2_BMI1		0x00000004 /* BMI1 insns */
+#define	AV_386_2_BMI2		0x00000008 /* BMI2 insns */
+#define	AV_386_2_FMA		0x00000010 /* FMA insns */
+#define	AV_386_2_AVX2		0x00000020 /* AVX2 insns */
+#define	AV_386_2_ADX		0x00000040 /* ADX insns */
+#define	AV_386_2_RDSEED		0x00000080 /* RDSEED insn */
+#define	AV_386_2_AVX512F	0x00000100 /* AVX512 foundation insns */
+#define	AV_386_2_AVX512DQ	0x00000200 /* AVX512DQ insns */
+#define	AV_386_2_AVX512IFMA	0x00000400 /* AVX512IFMA insns */
+#define	AV_386_2_AVX512PF	0x00000800 /* AVX512PF insns */
+#define	AV_386_2_AVX512ER	0x00001000 /* AVX512ER insns */
+#define	AV_386_2_AVX512CD	0x00002000 /* AVX512CD insns */
+#define	AV_386_2_AVX512BW	0x00004000 /* AVX512BW insns */
+#define	AV_386_2_AVX512VL	0x00008000 /* AVX512VL insns */
+#define	AV_386_2_AVX512VBMI	0x00010000 /* AVX512VBMI insns */
+#define	AV_386_2_AVX512VPOPCDQ	0x00020000 /* AVX512VPOPCNTDQ insns */
+#define	AV_386_2_AVX512_4NNIW	0x00040000 /* AVX512 4NNIW insns */
+#define	AV_386_2_AVX512_4FMAPS	0x00080000 /* AVX512 4FMAPS insns */
+#define	AV_386_2_SHA		0x00100000 /* SHA insns */
+#define	AV_386_2_FSGSBASE	0x00200000 /* FSBASE/GSBASE */
+#define	AV_386_2_CLFLUSHOPT	0x00400000 /* CLFLUSHOPT instr */
+#define	AV_386_2_CLWB		0x00800000 /* CLWB insn */
+#define	AV_386_2_MONITORX	0x01000000 /* MONITORX insns */
+#define	AV_386_2_CLZERO		0x02000000 /* CLZERO */
+#define	AV_386_2_XOP		0x04000000 /* XOP */
+#define	AV_386_2_FMA4		0x08000000 /* FMA4 */
+#define	AV_386_2_TBM		0x10000000 /* TBM */
 
 #define	FMT_AV_386_2							\
+	"\35tbm\34fma4"							\
+	"\33xop\32clzero\31monitorx\030clwb\027clflushopt\026fsgsbase"	\
 	"\025sha\024avx512_4fmaps\023avx512_4nniw\022avx512vpopcntdq"	\
 	"\021avx512vbmi\020avx512vl\017avx512bw\016avx512cd"		\
 	"\015avx512er\014avx512pf\013avx512ifma\012avx512dq\011avx512f"	\
diff --git a/usr/src/uts/i86pc/os/cpuid.c b/usr/src/uts/i86pc/os/cpuid.c
index 5324034fcf..d82d5866c6 100644
--- a/usr/src/uts/i86pc/os/cpuid.c
+++ b/usr/src/uts/i86pc/os/cpuid.c
@@ -219,7 +219,14 @@ static char *x86_feature_names[NUM_X86_FEATURES] = {
 	"ssb_no",
 	"stibp_all",
 	"flush_cmd",
-	"l1d_vmentry_no"
+	"l1d_vmentry_no",
+	"fsgsbase",
+	"clflushopt",
+	"clwb",
+	"monitorx",
+	"xop",
+	"fma4",
+	"tbm"
 };
 
 boolean_t
@@ -1480,12 +1487,21 @@ cpuid_pass1(cpu_t *cpu, uchar_t *featureset)
 		if (ecp->cp_ebx & CPUID_INTC_EBX_7_0_ADX)
 			add_x86_feature(featureset, X86FSET_ADX);
 
+		if (ecp->cp_ebx & CPUID_INTC_EBX_7_0_FSGSBASE)
+			add_x86_feature(featureset, X86FSET_FSGSBASE);
+
+		if (ecp->cp_ebx & CPUID_INTC_EBX_7_0_CLFLUSHOPT)
+			add_x86_feature(featureset, X86FSET_CLFLUSHOPT);
+
 		if (cpi->cpi_vendor == X86_VENDOR_Intel) {
 			if (ecp->cp_ebx & CPUID_INTC_EBX_7_0_INVPCID)
 				add_x86_feature(featureset, X86FSET_INVPCID);
 
 			if (ecp->cp_ebx & CPUID_INTC_EBX_7_0_MPX)
 				add_x86_feature(featureset, X86FSET_MPX);
+
+			if (ecp->cp_ebx & CPUID_INTC_EBX_7_0_CLWB)
+				add_x86_feature(featureset, X86FSET_CLWB);
 		}
 	}
 
@@ -1904,6 +1920,22 @@ cpuid_pass1(cpu_t *cpu, uchar_t *featureset)
 			if (cp->cp_ecx & CPUID_AMD_ECX_TOPOEXT) {
 				add_x86_feature(featureset, X86FSET_TOPOEXT);
 			}
+
+			if (cp->cp_ecx & CPUID_AMD_ECX_XOP) {
+				add_x86_feature(featureset, X86FSET_XOP);
+			}
+
+			if (cp->cp_ecx & CPUID_AMD_ECX_FMA4) {
+				add_x86_feature(featureset, X86FSET_FMA4);
+			}
+
+			if (cp->cp_ecx & CPUID_AMD_ECX_TBM) {
+				add_x86_feature(featureset, X86FSET_TBM);
+			}
+
+			if (cp->cp_ecx & CPUID_AMD_ECX_MONITORX) {
+				add_x86_feature(featureset, X86FSET_MONITORX);
+			}
 			break;
 		default:
 			break;
@@ -1930,6 +1962,28 @@ cpuid_pass1(cpu_t *cpu, uchar_t *featureset)
 			(void) __cpuid_insn(cp);
 			platform_cpuid_mangle(cpi->cpi_vendor, 0x80000008, cp);
 
+			/*
+			 * AMD uses ebx for some extended functions.
+			 */
+			if (cpi->cpi_vendor == X86_VENDOR_AMD) {
+				/*
+				 * While we're here, check for the AMD "Error
+				 * Pointer Zero/Restore" feature. This can be
+				 * used to setup the FP save handlers
+				 * appropriately.
+				 */
+				if (cp->cp_ebx & CPUID_AMD_EBX_ERR_PTR_ZERO) {
+					cpi->cpi_fp_amd_save = 0;
+				} else {
+					cpi->cpi_fp_amd_save = 1;
+				}
+
+				if (cp->cp_ebx & CPUID_AMD_EBX_CLZERO) {
+					add_x86_feature(featureset,
+					    X86FSET_CLZERO);
+				}
+			}
+
 			/*
 			 * Virtual and physical address limits from
 			 * cpuid override previously guessed values.
@@ -2053,11 +2107,6 @@ cpuid_pass1(cpu_t *cpu, uchar_t *featureset)
 	cpi->cpi_socket = _cpuid_skt(cpi->cpi_vendor, cpi->cpi_family,
 	    cpi->cpi_model, cpi->cpi_step);
 
-	/*
-	 * While we're here, check for the AMD "Error Pointer Zero/Restore"
-	 * feature. This can be used to setup the FP save handlers
-	 * appropriately.
-	 */
 	if (cpi->cpi_vendor == X86_VENDOR_AMD) {
 		if (cpi->cpi_xmaxeax >= 0x80000008 &&
 		    cpi->cpi_extd[8].cp_ebx & CPUID_AMD_EBX_ERR_PTR_ZERO) {
@@ -3286,6 +3335,12 @@ cpuid_pass4(cpu_t *cpu, uint_t *hwcap_out)
 			hwcap_flags_2 |= AV_386_2_RDSEED;
 		if (*ebx & CPUID_INTC_EBX_7_0_SHA)
 			hwcap_flags_2 |= AV_386_2_SHA;
+		if (*ebx & CPUID_INTC_EBX_7_0_FSGSBASE)
+			hwcap_flags_2 |= AV_386_2_FSGSBASE;
+		if (*ebx & CPUID_INTC_EBX_7_0_CLWB)
+			hwcap_flags_2 |= AV_386_2_CLWB;
+		if (*ebx & CPUID_INTC_EBX_7_0_CLFLUSHOPT)
+			hwcap_flags_2 |= AV_386_2_CLFLUSHOPT;
 
 	}
 
@@ -3295,6 +3350,11 @@ cpuid_pass4(cpu_t *cpu, uint_t *hwcap_out)
 		    "see the CPUID(7D) man page for details\n");
 	}
 
+	/*
+	 * Check a few miscilaneous features.
+	 */
+	if (is_x86_feature(x86_featureset, X86FSET_CLZERO))
+		hwcap_flags_2 |= AV_386_2_CLZERO;
 
 	if (cpi->cpi_xmaxeax < 0x80000001)
 		goto pass4_done;
@@ -3379,6 +3439,14 @@ cpuid_pass4(cpu_t *cpu, uint_t *hwcap_out)
 				hwcap_flags |= AV_386_AMD_SSE4A;
 			if (*ecx & CPUID_AMD_ECX_LZCNT)
 				hwcap_flags |= AV_386_AMD_LZCNT;
+			if (*ecx & CPUID_AMD_ECX_XOP)
+				hwcap_flags_2 |= AV_386_2_XOP;
+			if (*ecx & CPUID_AMD_ECX_FMA4)
+				hwcap_flags_2 |= AV_386_2_FMA4;
+			if (*ecx & CPUID_AMD_ECX_TBM)
+				hwcap_flags_2 |= AV_386_2_TBM;
+			if (*ecx & CPUID_AMD_ECX_MONITORX)
+				hwcap_flags_2 |= AV_386_2_MONITORX;
 			break;
 
 		case X86_VENDOR_Intel:
diff --git a/usr/src/uts/intel/ia32/os/archdep.c b/usr/src/uts/intel/ia32/os/archdep.c
index 830daa0af7..7994ea2b24 100644
--- a/usr/src/uts/intel/ia32/os/archdep.c
+++ b/usr/src/uts/intel/ia32/os/archdep.c
@@ -23,7 +23,7 @@
  */
 
 /*	Copyright (c) 1984, 1986, 1987, 1988, 1989 AT&T	*/
-/*	  All Rights Reserved  	*/
+/*	  All Rights Reserved	*/
 /*
  * Copyright (c) 2018, Joyent, Inc.
  * Copyright 2012 Nexenta Systems, Inc.  All rights reserved.
@@ -1035,6 +1035,11 @@ bind_hwcap(void)
 	 * 32-bit processes can -always- use the lahf/sahf instructions
 	 */
 	auxv_hwcap32 |= AV_386_AHF;
+
+	/*
+	 * 32-bit processes can -never- use fsgsbase instructions.
+	 */
+	auxv_hwcap32_2 = ~AV_386_2_FSGSBASE;
 #endif
 
 	if (auxv_hwcap32_include || auxv_hwcap32_exclude ||
diff --git a/usr/src/uts/intel/sys/x86_archext.h b/usr/src/uts/intel/sys/x86_archext.h
index 35c28be3f8..22fba7bad7 100644
--- a/usr/src/uts/intel/sys/x86_archext.h
+++ b/usr/src/uts/intel/sys/x86_archext.h
@@ -90,7 +90,7 @@ extern "C" {
  */
 
 #define	CPUID_INTC_ECX_SSE3	0x00000001	/* Yet more SSE extensions */
-#define	CPUID_INTC_ECX_PCLMULQDQ 0x00000002 	/* PCLMULQDQ insn */
+#define	CPUID_INTC_ECX_PCLMULQDQ 0x00000002	/* PCLMULQDQ insn */
 #define	CPUID_INTC_ECX_DTES64	0x00000004	/* 64-bit DS area */
 #define	CPUID_INTC_ECX_MON	0x00000008	/* MONITOR/MWAIT */
 #define	CPUID_INTC_ECX_DSCPL	0x00000010	/* CPL-qualified debug store */
@@ -171,7 +171,7 @@ extern "C" {
 #define	CPUID_AMD_ECX_3DNP	0x00000100	/* AMD: 3DNowPrefectch */
 #define	CPUID_AMD_ECX_OSVW	0x00000200	/* AMD: OSVW */
 #define	CPUID_AMD_ECX_IBS	0x00000400	/* AMD: IBS */
-#define	CPUID_AMD_ECX_SSE5	0x00000800	/* AMD: Extended AVX */
+#define	CPUID_AMD_ECX_XOP	0x00000800	/* AMD: Extended Operation */
 #define	CPUID_AMD_ECX_SKINIT	0x00001000	/* AMD: SKINIT */
 #define	CPUID_AMD_ECX_WDT	0x00002000	/* AMD: WDT */
 				/* 0x00004000 - reserved */
@@ -183,10 +183,21 @@ extern "C" {
 				/* 0x00100000 - reserved */
 #define	CPUID_AMD_ECX_TBM	0x00200000	/* AMD: trailing bit manips. */
 #define	CPUID_AMD_ECX_TOPOEXT	0x00400000	/* AMD: Topology Extensions */
+#define	CPUID_AMD_ECX_PCEC	0x00800000	/* AMD: Core ext perf counter */
+#define	CUPID_AMD_ECX_PCENB	0x01000000	/* AMD: NB ext perf counter */
+				/* 0x02000000 - reserved */
+#define	CPUID_AMD_ECX_DBKP	0x40000000	/* AMD: Data breakpoint */
+#define	CPUID_AMD_ECX_PERFTSC	0x08000000	/* AMD: TSC Perf Counter */
+#define	CPUID_AMD_ECX_PERFL3	0x10000000	/* AMD: L3 Perf Counter */
+#define	CPUID_AMD_ECX_MONITORX	0x20000000	/* AMD: clzero */
+				/* 0x40000000 - reserved */
+				/* 0x80000000 - reserved */
 
 /*
  * AMD uses %ebx for some of their features (extended function 0x80000008).
  */
+#define	CPUID_AMD_EBX_CLZERO		0x000000001 /* AMD: CLZERO instr */
+#define	CPUID_AMD_EBX_IRCMSR		0x000000002 /* AMD: Ret. instrs MSR */
 #define	CPUID_AMD_EBX_ERR_PTR_ZERO	0x000000004 /* AMD: FP Err. Ptr. Zero */
 #define	CPUID_AMD_EBX_IBPB		0x000001000 /* AMD: IBPB */
 #define	CPUID_AMD_EBX_IBRS		0x000004000 /* AMD: IBRS */
@@ -214,20 +225,32 @@ extern "C" {
  * with the potential use of additional sub-leaves in the future, we now
  * specifically label the EBX features with their leaf and sub-leaf.
  */
+#define	CPUID_INTC_EBX_7_0_FSGSBASE	0x00000001	/* FSGSBASE */
+#define	CPUID_INTC_EBX_7_0_TSC_ADJ	0x00000002	/* TSC adjust MSR */
+#define	CPUID_INTC_EBX_7_0_SGX		0x00000004	/* SGX */
 #define	CPUID_INTC_EBX_7_0_BMI1		0x00000008	/* BMI1 instrs */
 #define	CPUID_INTC_EBX_7_0_HLE		0x00000010	/* HLE */
 #define	CPUID_INTC_EBX_7_0_AVX2		0x00000020	/* AVX2 supported */
+/* Bit 6 is reserved */
 #define	CPUID_INTC_EBX_7_0_SMEP		0x00000080	/* SMEP in CR4 */
 #define	CPUID_INTC_EBX_7_0_BMI2		0x00000100	/* BMI2 instrs */
+#define	CPUID_INTC_EBX_7_0_ENH_REP_MOV	0x00000200	/* Enhanced REP MOVSB */
 #define	CPUID_INTC_EBX_7_0_INVPCID	0x00000400	/* invpcid instr */
+#define	CPUID_INTC_EBX_7_0_RTM		0x00000800	/* RTM instrs */
+#define	CPUID_INTC_EBX_7_0_PQM		0x00001000	/* QoS Monitoring */
+#define	CPUID_INTC_EBX_7_0_DEP_CSDS	0x00002000	/* Deprecates CS/DS */
 #define	CPUID_INTC_EBX_7_0_MPX		0x00004000	/* Mem. Prot. Ext. */
+#define	CPUID_INTC_EBX_7_0_PQE		0x00080000	/* QoS Enforcement */
 #define	CPUID_INTC_EBX_7_0_AVX512F	0x00010000	/* AVX512 foundation */
 #define	CPUID_INTC_EBX_7_0_AVX512DQ	0x00020000	/* AVX512DQ */
 #define	CPUID_INTC_EBX_7_0_RDSEED	0x00040000	/* RDSEED instr */
 #define	CPUID_INTC_EBX_7_0_ADX		0x00080000	/* ADX instrs */
 #define	CPUID_INTC_EBX_7_0_SMAP		0x00100000	/* SMAP in CR 4 */
 #define	CPUID_INTC_EBX_7_0_AVX512IFMA	0x00200000	/* AVX512IFMA */
+/* Bit 22 is reserved */
+#define	CPUID_INTC_EBX_7_0_CLFLUSHOPT	0x00800000	/* CLFLUSOPT */
 #define	CPUID_INTC_EBX_7_0_CLWB		0x01000000	/* CLWB */
+#define	CPUID_INTC_EBX_7_0_PTRACE	0x02000000	/* Processor Trace */
 #define	CPUID_INTC_EBX_7_0_AVX512PF	0x04000000	/* AVX512PF */
 #define	CPUID_INTC_EBX_7_0_AVX512ER	0x08000000	/* AVX512ER */
 #define	CPUID_INTC_EBX_7_0_AVX512CD	0x10000000	/* AVX512CD */
@@ -241,17 +264,50 @@ extern "C" {
 	CPUID_INTC_EBX_7_0_AVX512ER | CPUID_INTC_EBX_7_0_AVX512CD | \
 	CPUID_INTC_EBX_7_0_AVX512BW | CPUID_INTC_EBX_7_0_AVX512VL)
 
+#define	CPUID_INTC_ECX_7_0_PREFETCHWT1	0x00000001	/* PREFETCHWT1 */
 #define	CPUID_INTC_ECX_7_0_AVX512VBMI	0x00000002	/* AVX512VBMI */
 #define	CPUID_INTC_ECX_7_0_UMIP		0x00000004	/* UMIP */
 #define	CPUID_INTC_ECX_7_0_PKU		0x00000008	/* umode prot. keys */
 #define	CPUID_INTC_ECX_7_0_OSPKE	0x00000010	/* OSPKE */
+#define	CPUID_INTC_ECX_7_0_WAITPKG	0x00000020	/* WAITPKG */
+#define	CPUID_INTC_ECX_7_0_AVX512VBMI2	0x00000040	/* AVX512 VBMI2 */
+/* bit 7 is reserved */
+#define	CPUID_INTC_ECX_7_0_GFNI		0x00000100	/* GFNI */
+#define	CPUID_INTC_ECX_7_0_VAES		0x00000200	/* VAES */
+#define	CPUID_INTC_ECX_7_0_VPCLMULQDQ	0x00000400	/* VPCLMULQDQ */
+#define	CPUID_INTC_ECX_7_0_AVX512VNNI	0x00000800	/* AVX512 VNNI */
+#define	CPUID_INTC_ECX_7_0_AVX512BITALG	0x00001000	/* AVX512 BITALG */
+/* bit 13 is reserved */
 #define	CPUID_INTC_ECX_7_0_AVX512VPOPCDQ 0x00004000	/* AVX512 VPOPCNTDQ */
+/* bits 15-16 are reserved */
+/* bits 17-21 are the value of MAWAU */
+#define	CPUID_INTC_ECX_7_0_RDPID	0x00400000	/* RPID, IA32_TSC_AUX */
+/* bits 23-24 are reserved */
+#define	CPUID_INTC_ECX_7_0_CLDEMOTE	0x02000000	/* Cache line demote */
+/* bit 26 is resrved */
+#define	CPUID_INTC_ECX_7_0_MOVDIRI	0x08000000	/* MOVDIRI insn */
+#define	CPUID_INTC_ECX_7_0_MOVDIR64B	0x10000000	/* MOVDIR64B insn */
+/* bit 29 is reserved */
+#define	CPUID_INTC_ECX_7_0_SGXLC	0x40000000	/* SGX Launch config */
+/* bit 31 is reserved */
 
+/*
+ * While CPUID_INTC_ECX_7_0_GFNI, CPUID_INTC_ECX_7_0_VAES, and
+ * CPUID_INTC_ECX_7_0_VPCLMULQDQ all have AVX512 components, they are still
+ * valid when AVX512 is not. However, the following flags all are only valid
+ * when AVX512 is present.
+ */
 #define	CPUID_INTC_ECX_7_0_ALL_AVX512 \
-	(CPUID_INTC_ECX_7_0_AVX512VBMI | CPUID_INTC_ECX_7_0_AVX512VPOPCDQ)
+	(CPUID_INTC_ECX_7_0_AVX512VBMI | CPUID_INTC_ECX_7_0_AVX512VNNI | \
+	CPUID_INTC_ECX_7_0_AVX512BITALG | CPUID_INTC_ECX_7_0_AVX512VPOPCDQ)
 
+/* bits 0-1 are reserved */
 #define	CPUID_INTC_EDX_7_0_AVX5124NNIW	0x00000004	/* AVX512 4NNIW */
 #define	CPUID_INTC_EDX_7_0_AVX5124FMAPS	0x00000008	/* AVX512 4FMAPS */
+#define	CPUID_INTC_EDX_7_0_FSREPMOV	0x00000010	/* fast short rep mov */
+/* bits 5-17 are resreved */
+#define	CPUID_INTC_EDX_7_0_PCONFIG	0x00040000	/* PCONFIG */
+/* bits 19-26 are reserved */
 #define	CPUID_INTC_EDX_7_0_SPEC_CTRL	0x04000000	/* Spec, IBPB, IBRS */
 #define	CPUID_INTC_EDX_7_0_STIBP	0x08000000	/* STIBP */
 #define	CPUID_INTC_EDX_7_0_FLUSH_CMD	0x10000000	/* IA32_FLUSH_CMD */
@@ -323,10 +379,10 @@ extern "C" {
 #define	MSR_PRP4_LBSTK_FROM_5	0x685
 #define	MSR_PRP4_LBSTK_FROM_6	0x686
 #define	MSR_PRP4_LBSTK_FROM_7	0x687
-#define	MSR_PRP4_LBSTK_FROM_8 	0x688
+#define	MSR_PRP4_LBSTK_FROM_8	0x688
 #define	MSR_PRP4_LBSTK_FROM_9	0x689
 #define	MSR_PRP4_LBSTK_FROM_10	0x68a
-#define	MSR_PRP4_LBSTK_FROM_11 	0x68b
+#define	MSR_PRP4_LBSTK_FROM_11	0x68b
 #define	MSR_PRP4_LBSTK_FROM_12	0x68c
 #define	MSR_PRP4_LBSTK_FROM_13	0x68d
 #define	MSR_PRP4_LBSTK_FROM_14	0x68e
@@ -340,7 +396,7 @@ extern "C" {
 #define	MSR_PRP4_LBSTK_TO_6	0x6c6
 #define	MSR_PRP4_LBSTK_TO_7	0x6c7
 #define	MSR_PRP4_LBSTK_TO_8	0x6c8
-#define	MSR_PRP4_LBSTK_TO_9 	0x6c9
+#define	MSR_PRP4_LBSTK_TO_9	0x6c9
 #define	MSR_PRP4_LBSTK_TO_10	0x6ca
 #define	MSR_PRP4_LBSTK_TO_11	0x6cb
 #define	MSR_PRP4_LBSTK_TO_12	0x6cc
@@ -510,6 +566,14 @@ extern "C" {
 #define	X86FSET_STIBP_ALL	80
 #define	X86FSET_FLUSH_CMD	81
 #define	X86FSET_L1D_VM_NO	82
+#define	X86FSET_FSGSBASE	83
+#define	X86FSET_CLFLUSHOPT	84
+#define	X86FSET_CLWB		85
+#define	X86FSET_MONITORX	86
+#define	X86FSET_CLZERO		87
+#define	X86FSET_XOP		88
+#define	X86FSET_FMA4		89
+#define	X86FSET_TBM		90
 
 /*
  * Intel Deep C-State invariant TSC in leaf 0x80000007.
@@ -834,7 +898,7 @@ extern "C" {
 
 #if defined(_KERNEL) || defined(_KMEMUSER)
 
-#define	NUM_X86_FEATURES	83
+#define	NUM_X86_FEATURES	91
 extern uchar_t x86_featureset[];
 
 extern void free_x86_featureset(void *featureset);
-- 
2.21.0

