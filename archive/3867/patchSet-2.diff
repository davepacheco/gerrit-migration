commit bf97f495ff3ba15a6672bf98dda2c22905045cd9 (refs/changes/67/3867/2)
Author: Alex Wilson <alex.wilson@joyent.com>
Date:   2018-04-25T14:39:48-07:00 (1 year, 5 months ago)
    
    OS-6906 LX not setting "accessed" bit in GDT, KPTI sadness ensues

diff --git a/usr/src/uts/common/brand/lx/sys/lx_ldt.h b/usr/src/uts/common/brand/lx/sys/lx_ldt.h
index 825933e86c..5ed4078dd3 100644
--- a/usr/src/uts/common/brand/lx/sys/lx_ldt.h
+++ b/usr/src/uts/common/brand/lx/sys/lx_ldt.h
@@ -63,7 +63,7 @@ struct ldt_info {
 	USEGD_SETBASE(desc, (info)->base_addr);				\
 	USEGD_SETLIMIT(desc, (info)->limit);				\
 	(desc)->usd_type = ((info)->contents << 2) | 			\
-	    ((info)->read_exec_only ^ 1) << 1 | 0x10;			\
+	    ((info)->read_exec_only ^ 1) << 1 | SDT_S | SDT_A;		\
 	(desc)->usd_dpl = SEL_UPL;					\
 	(desc)->usd_p = (info)->seg_not_present ^ 1;			\
 	(desc)->usd_def32 = (info)->seg_32bit;				\
diff --git a/usr/src/uts/intel/ia32/os/desctbls.c b/usr/src/uts/intel/ia32/os/desctbls.c
index 5ef56b034c..0a7a847dec 100644
--- a/usr/src/uts/intel/ia32/os/desctbls.c
+++ b/usr/src/uts/intel/ia32/os/desctbls.c
@@ -178,8 +178,6 @@ static struct interposing_handler brand_tbl[3];
  * can understand.
  */
 
-#if defined(__amd64)
-
 /*
  * In long mode we have the new L or long mode attribute bit
  * for code segments. Only the conforming bit in type is used along
@@ -193,6 +191,8 @@ set_usegd(user_desc_t *dp, uint_t lmode, void *base, size_t size,
     uint_t type, uint_t dpl, uint_t gran, uint_t defopsz)
 {
 	ASSERT(lmode == SDP_SHORT || lmode == SDP_LONG);
+	/* This should never be a "system" segment. */
+	ASSERT3U(type & SDT_S, !=, 0);
 
 	/*
 	 * 64-bit long mode.
@@ -205,6 +205,14 @@ set_usegd(user_desc_t *dp, uint_t lmode, void *base, size_t size,
 		 */
 		dp->usd_def32 = defopsz;	/* 0 = 16, 1 = 32-bit ops */
 
+	/*
+	 * We should always set the "accessed" bit (SDT_A), otherwise the CPU
+	 * will write to the GDT whenever we change segment registers around.
+	 * With KPTI on, the GDT is read-only in the user page table, which
+	 * causes crashes if we don't set this.
+	 */
+	ASSERT3U(type & SDT_A, !=, 0);
+
 	dp->usd_long = lmode;	/* 64-bit mode */
 	dp->usd_type = type;
 	dp->usd_dpl = dpl;
@@ -218,31 +226,6 @@ set_usegd(user_desc_t *dp, uint_t lmode, void *base, size_t size,
 	dp->usd_hilimit = (uintptr_t)size >> 16;
 }
 
-#elif defined(__i386)
-
-/*
- * Install user segment descriptor for code and data.
- */
-void
-set_usegd(user_desc_t *dp, void *base, size_t size, uint_t type,
-    uint_t dpl, uint_t gran, uint_t defopsz)
-{
-	dp->usd_lolimit = size;
-	dp->usd_hilimit = (uintptr_t)size >> 16;
-
-	dp->usd_lobase = (uintptr_t)base;
-	dp->usd_midbase = (uintptr_t)base >> 16;
-	dp->usd_hibase = (uintptr_t)base >> (16 + 8);
-
-	dp->usd_type = type;
-	dp->usd_dpl = dpl;
-	dp->usd_p = 1;
-	dp->usd_def32 = defopsz;	/* 0 = 16, 1 = 32 bit operands */
-	dp->usd_gran = gran;		/* 0 = bytes, 1 = pages */
-}
-
-#endif	/* __i386 */
-
 /*
  * Install system segment descriptor for LDT and TSS segments.
  */
@@ -391,15 +374,25 @@ set_gatesegd(gate_desc_t *dp, void (*func)(void), selector_t sel,
 void
 gdt_update_usegd(uint_t sidx, user_desc_t *udp)
 {
-#if defined(__xpv)
+	/* This should never be a "system" segment, but it might be null. */
+	if (udp->usd_p != 0 || udp->usd_type != 0)
+		ASSERT3U(udp->usd_type & SDT_S, !=, 0);
 
+#if defined(__xpv)
 	uint64_t dpa = CPU->cpu_m.mcpu_gdtpa + sizeof (*udp) * sidx;
 
 	if (HYPERVISOR_update_descriptor(pa_to_ma(dpa), *(uint64_t *)udp))
 		panic("gdt_update_usegd: HYPERVISOR_update_descriptor");
 
 #else	/* __xpv */
-
+	/*
+	 * We should always set the "accessed" bit (SDT_A), otherwise the CPU
+	 * will write to the GDT whenever we change segment registers around.
+	 * With KPTI on, the GDT is read-only in the user page table, which
+	 * causes crashes if we don't set this.
+	 */
+	if (udp->usd_p != 0 || udp->usd_type != 0)
+		ASSERT3U(udp->usd_type & SDT_A, !=, 0);
 	CPU->cpu_gdt[sidx] = *udp;
 
 #endif	/* __xpv */
@@ -412,8 +405,11 @@ gdt_update_usegd(uint_t sidx, user_desc_t *udp)
 int
 ldt_update_segd(user_desc_t *ldp, user_desc_t *udp)
 {
-#if defined(__xpv)
+	/* This should never be a "system" segment, but it might be null. */
+	if (udp->usd_p != 0 || udp->usd_type != 0)
+		ASSERT3U(udp->usd_type & SDT_S, !=, 0);
 
+#if defined(__xpv)
 	uint64_t dpa;
 
 	dpa = mmu_ptob(hat_getpfnum(kas.a_hat, (caddr_t)ldp)) |
@@ -428,6 +424,14 @@ ldt_update_segd(user_desc_t *ldp, user_desc_t *udp)
 
 #else	/* __xpv */
 
+	/*
+	 * We should always set the "accessed" bit (SDT_A), otherwise the CPU
+	 * will write to the LDT whenever we change segment registers around.
+	 * With KPTI on, the LDT is read-only in the user page table, which
+	 * causes crashes if we don't set this.
+	 */
+	if (udp->usd_p != 0 || udp->usd_type != 0)
+		ASSERT3U(udp->usd_type & SDT_A, !=, 0);
 	*ldp = *udp;
 
 #endif	/* __xpv */
diff --git a/usr/src/uts/intel/ia32/os/sysi86.c b/usr/src/uts/intel/ia32/os/sysi86.c
index cd1129ea1f..f0cba7d7d5 100644
--- a/usr/src/uts/intel/ia32/os/sysi86.c
+++ b/usr/src/uts/intel/ia32/os/sysi86.c
@@ -284,9 +284,12 @@ ssd_to_usd(struct ssd *ssd, user_desc_t *usd)
 	USEGD_SETLIMIT(usd, ssd->ls);
 
 	/*
-	 * set type, dpl and present bits.
+	 * Set type, dpl and present bits.
+	 *
+	 * Force the "accessed" bit to on so that we don't run afoul of
+	 * KPTI.
 	 */
-	usd->usd_type = ssd->acc1;
+	usd->usd_type = ssd->acc1 | SDT_A;
 	usd->usd_dpl = ssd->acc1 >> 5;
 	usd->usd_p = ssd->acc1 >> (5 + 2);
 
diff --git a/usr/src/uts/intel/sys/segments.h b/usr/src/uts/intel/sys/segments.h
index 84eb363f00..19bac38e57 100644
--- a/usr/src/uts/intel/sys/segments.h
+++ b/usr/src/uts/intel/sys/segments.h
@@ -482,6 +482,9 @@ void init_boot_gdt(user_desc_t *);
 #define	SDT_MEMERC	30	/* execute read conforming */
 #define	SDT_MEMERAC	31	/* execute read accessed conforming */
 
+#define	SDT_A		0x01	/* accessed bit */
+#define	SDT_S		0x10	/* S-bit at the top of "type" for usegs */
+
 /*
  * Entries in the Interrupt Descriptor Table (IDT)
  */
