From 1436d54580f1c4a257c82c438ba282a9a149b732 Mon Sep 17 00:00:00 2001
From: Patrick Mooney <pmooney@pfmooney.com>
Date: Mon, 18 Jul 2016 18:56:45 +0000
Subject: [PATCH] OS-5518 devpoll write feigns success in the face of EINTR
 OS-5520 epoll_ctl not allowed to emit EINTR Reviewed by: Jerry Jelinek
 <jerry.jelinek@joyent.com> Reviewed by: Bryan Cantrill <bryan@joyent.com>

---
 usr/src/lib/libc/port/sys/epoll.c |  9 +++++++++
 usr/src/uts/common/io/devpoll.c   | 20 ++++++++++++++++++--
 2 files changed, 27 insertions(+), 2 deletions(-)

diff --git a/usr/src/lib/libc/port/sys/epoll.c b/usr/src/lib/libc/port/sys/epoll.c
index b8992e064b..543856b2ec 100644
--- a/usr/src/lib/libc/port/sys/epoll.c
+++ b/usr/src/lib/libc/port/sys/epoll.c
@@ -165,9 +165,18 @@ epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)
 	}
 
 	epoll[i].dpep_pollfd.events = ev;
+retry:
 	res = write(epfd, epoll, sizeof (epoll[0]) * (i + 1));
 
 	if (res == -1) {
+		if (errno == EINTR) {
+			/*
+			 * Linux does not document EINTR as an allowed error
+			 * for epoll_ctl.  The write must be retried if it is
+			 * not done automatically via SA_RESTART.
+			 */
+			goto retry;
+		}
 		if (errno == ELOOP) {
 			/*
 			 * Convert the specific /dev/poll error about an fd
diff --git a/usr/src/uts/common/io/devpoll.c b/usr/src/uts/common/io/devpoll.c
index f4b4b4563a..4fce431e00 100644
--- a/usr/src/uts/common/io/devpoll.c
+++ b/usr/src/uts/common/io/devpoll.c
@@ -641,6 +641,7 @@ dpwrite(dev_t dev, struct uio *uiop, cred_t *credp)
 	uintptr_t	limit;
 	int		error, size;
 	ssize_t		uiosize;
+	size_t		copysize;
 	nfds_t		pollfdnum;
 	struct pollhead	*php = NULL;
 	polldat_t	*pdp;
@@ -706,11 +707,19 @@ dpwrite(dev_t dev, struct uio *uiop, cred_t *credp)
 	 * here for every call.
 	 */
 	uiop->uio_loffset = 0;
-	if ((error = uiomove((caddr_t)pollfdp, uiosize, UIO_WRITE, uiop))
-	    != 0) {
+
+	/*
+	 * Use uiocopy instead of uiomove when populating pollfdp, keeping
+	 * uio_resid untouched for now.  Write syscalls will translate EINTR
+	 * into a success if they detect "successfully transfered" data via an
+	 * updated uio_resid.  Falsely suppressing such errors is disastrous.
+	 */
+	if ((error = uiocopy((caddr_t)pollfdp, uiosize, UIO_WRITE, uiop,
+	    &copysize)) != 0) {
 		kmem_free(pollfdp, uiosize);
 		return (error);
 	}
+
 	/*
 	 * We are about to enter the core portion of dpwrite(). Make sure this
 	 * write has exclusive access in this portion of the code, i.e., no
@@ -983,6 +992,13 @@ bypass:
 	cv_broadcast(&dpep->dpe_cv);
 	mutex_exit(&dpep->dpe_lock);
 	kmem_free(pollfdp, uiosize);
+	if (error == 0) {
+		/*
+		 * The state of uio_resid is updated only after the pollcache
+		 * is successfully modified.
+		 */
+		uioskip(uiop, copysize);
+	}
 	return (error);
 }
 
-- 
2.21.0

