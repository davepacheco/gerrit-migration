commit 5066aa632344afc1c1f06d74de6d1da7ca6330f5 (refs/changes/86/186/1)
Author: Dave Pacheco <dap@joyent.com>
Date:   2016-08-01T15:56:11-07:00 (3 years, 2 months ago)
    
    joyent/node-cmdutil#2 add function for prompting user for confirmation

diff --git a/CHANGES.md b/CHANGES.md
new file mode 100644
index 0000000..aa1ed32
--- /dev/null
+++ b/CHANGES.md
@@ -0,0 +1,9 @@
+# Change log
+
+## v1.1.0
+
+* #2 add function for prompting user for confirmation
+
+## v1.0.0
+
+Initial stable release.
diff --git a/LICENSE b/LICENSE
index 3770214..82a5cb8 100644
--- a/LICENSE
+++ b/LICENSE
@@ -1,4 +1,4 @@
-Copyright (c) 2015, Joyent, Inc. All rights reserved.
+Copyright (c) 2016, Joyent, Inc. All rights reserved.
 
 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
diff --git a/README.md b/README.md
index df90d1e..d827943 100644
--- a/README.md
+++ b/README.md
@@ -9,6 +9,8 @@ written in Node.
 * [exitOnEpipe](#exitOnEpipe): exit normally (with status 0) when EPIPE is seen
   on stdout.  This causes Node programs to behave like other programs do by
   default on most Unix-like systems.  See details below.
+* [confirm](#confirm): print a message to stdout, read one byte of input,
+  and test whether it appears affirmative
 
 You should also check out:
 
@@ -368,6 +370,26 @@ could be handled, but there's not a great way to do this from this context, and
 it's uncommon that people intend to handle other errors on stdout anyway.
 
 
+## confirm(args, callback)
+
+`confirm(args, callback)` emits a message to stdout, waits for the user to input
+a single byte (in raw mode, if it's a TTY), and invokes `callback` with an
+optional error (if something went wrong) and a boolean value indicating whether
+the confirmation was either "y" or "Y" (for "yes").
+
+The only supported argument inside `args` is:
+
+* `message`: the message to print to stdout (verbatim)
+
+`callback` is invoked as `callback(err, result)`.  If something went wrong,
+`err` is non-null.  Otherwise, `result` is a boolean indicating whether the
+user input was affirmative.  Command-line tools should probably consider an
+error as equivalent to a `false` value of `result`.
+
+The behavior is undefined if stdin has already emitted 'end' when this function
+is called.
+
+
 # Contributions
 
 Contributions welcome.  Code should be "make prepush" clean.  To run "make
diff --git a/examples/confirm.js b/examples/confirm.js
new file mode 100644
index 0000000..62714db
--- /dev/null
+++ b/examples/confirm.js
@@ -0,0 +1,13 @@
+var cmdutil = require('../lib/cmdutil');
+var message = process.argv.length >= 3 ?
+    process.argv[2] : 'Are you sure that you want to confirm? (y/[n]) ';
+cmdutil.confirm({
+    'message': message
+}, function (err, result) {
+	if (err) {
+		cmdutil.fail(err);
+	}
+
+	console.error('result: ', result);
+	process.exit(result ? 0 : 1);
+});
diff --git a/lib/cmdutil.js b/lib/cmdutil.js
index 37415c1..0da4c52 100644
--- a/lib/cmdutil.js
+++ b/lib/cmdutil.js
@@ -15,6 +15,7 @@ exports.usage = usage;
 exports.warn = warn;
 exports.fail = fail;
 exports.exitOnEpipe = exitOnEpipe;
+exports.confirm = confirm;
 
 var usageMessage = null;
 var progname = mod_path.basename(process.argv[1]);
@@ -119,3 +120,92 @@ function exitOnEpipe()
 		throw (err);
 	});
 }
+
+/*
+ * See README.md.
+ */
+function confirm(args, callback)
+{
+	var cstate;
+
+	mod_assertplus.object(args, 'args');
+	mod_assertplus.string(args.message, 'args.message');
+
+	/*
+	 * This object encapsulates the state of this asynchronous operation.
+	 */
+	cstate = {
+	    /* prompt message */
+	    'cf_message': args.message,
+
+	    /* streams used for output and input */
+	    'cf_outstream': process.stdout,
+	    'cf_instream': process.stdin,
+
+	    /* input is a tty */
+	    'cf_intty': null,
+	    'cf_inraw': null,
+
+	    /* data read from input */
+	    'cf_read': null,
+
+	    /* asynchronous error, if any */
+	    'cf_error': null,
+
+	    /* user callback to be invoked */
+	    'cf_callback': callback
+	};
+
+	cstate.cf_intty = cstate.cf_instream.isTTY;
+	if (cstate.cf_intty) {
+		cstate.cf_inraw = cstate.cf_instream.isRaw;
+		if (!cstate.cf_inraw) {
+			cstate.cf_instream.setRawMode(true);
+		}
+	}
+
+	cstate.cf_outstream.write(cstate.cf_message);
+	cstate.cf_read = cstate.cf_instream.read(1);
+	if (cstate.cf_read === null) {
+		cstate.cf_instream.once('readable', function () {
+			cstate.cf_read = cstate.cf_instream.read(1);
+			if (cstate.cf_read === null) {
+				/*
+				 * We assume that this means end-of-stream.
+				 * There doesn't appear to be a programmatic way
+				 * to tell that, though.
+				 *
+				 * Worse, it's not clear if there's any
+				 * documented way to know if the end-of-stream
+				 * had been reached before we even started
+				 * reading from it.
+				 */
+				cstate.cf_error = new Error(
+				    'read end-of-stream');
+			}
+
+			confirmFini(cstate);
+		});
+	} else {
+		setImmediate(confirmFini, cstate);
+	}
+}
+
+function confirmFini(cstate)
+{
+	var ch;
+
+	cstate.cf_outstream.write('\n');
+
+	if (cstate.cf_error !== null) {
+		cstate.cf_callback(cstate.cf_error);
+		return;
+	}
+
+	if (cstate.cf_intty && !cstate.cf_inraw) {
+		cstate.cf_instream.setRawMode(false);
+	}
+
+	ch = cstate.cf_read.toString('utf8');
+	cstate.cf_callback(null, ch.toLowerCase() == 'y');
+}
diff --git a/package.json b/package.json
index 244f50f..fc64905 100644
--- a/package.json
+++ b/package.json
@@ -1,6 +1,6 @@
 {
 	"name": "cmdutil",
-	"version": "1.0.0",
+	"version": "1.1.0",
 	"description": "common command-line program library functions",
 	"main": "./lib/cmdutil.js",
 	"author": "Joyent (joyent.com)",
diff --git a/test/tst.confirm.sh b/test/tst.confirm.sh
new file mode 100644
index 0000000..d08ee39
--- /dev/null
+++ b/test/tst.confirm.sh
@@ -0,0 +1,36 @@
+#!/bin/bash
+
+#
+# Tests the "confirm" function.
+#
+
+source "$(dirname ${BASH_SOURCE[0]})/common.sh"
+
+function main
+{
+	set -o errexit
+
+	echo "test: stdin from /dev/null"
+	( confirm < /dev/null ) && fail "expected failure"
+
+	echo "test: confirm 'yes'"
+	( echo -n y | confirm ) || fail "expected success"
+
+	echo "test: confirm 'YES'"
+	( echo -n Y | confirm ) || fail "expected success"
+
+	echo "test: confirm 'no'"
+	( echo -n n | confirm ) && fail "expected failure"
+
+	echo "test: confirm garbage"
+	( echo garbage | confirm ) && fail "expected failure"
+
+	return 0
+}
+
+function confirm
+{
+	node $exdir/confirm.js
+}
+
+main
