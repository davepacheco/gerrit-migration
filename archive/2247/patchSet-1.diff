From 2c13c507c64b29cedeff9e9872e59a0e5d84378c Mon Sep 17 00:00:00 2001
From: Hans Rosenfeld <hans.rosenfeld@joyent.com>
Date: Thu, 20 Jul 2017 17:45:45 +0200
Subject: [PATCH] OS-6248 nvmeadm doesn't handle namespaces with EUI64

---
 usr/src/cmd/nvmeadm/nvmeadm.c | 47 +++++++++++++----------------------
 1 file changed, 17 insertions(+), 30 deletions(-)

diff --git a/usr/src/cmd/nvmeadm/nvmeadm.c b/usr/src/cmd/nvmeadm/nvmeadm.c
index 13cace3ead..e965a8ccad 100644
--- a/usr/src/cmd/nvmeadm/nvmeadm.c
+++ b/usr/src/cmd/nvmeadm/nvmeadm.c
@@ -54,7 +54,7 @@ struct nvme_process_arg {
 	int npa_argc;
 	char **npa_argv;
 	char *npa_name;
-	uint32_t npa_nsid;
+	char *npa_nsid;
 	boolean_t npa_isns;
 	const nvmeadm_cmd_t *npa_cmd;
 	di_node_t npa_node;
@@ -313,21 +313,8 @@ main(int argc, char **argv)
 		if (npa.npa_name != NULL) {
 			tmp = strchr(npa.npa_name, '/');
 			if (tmp != NULL) {
-				unsigned long nsid;
 				*tmp++ = '\0';
-				errno = 0;
-				nsid = strtoul(tmp, NULL, 10);
-				if (nsid >= UINT32_MAX || errno != 0) {
-					warn("invalid namespace %s", tmp);
-					exitcode--;
-					continue;
-				}
-				if (nsid == 0) {
-					warnx("invalid namespace %s", tmp);
-					exitcode--;
-					continue;
-				}
-				npa.npa_nsid = nsid;
+				npa.npa_nsid = tmp;
 				npa.npa_isns = B_TRUE;
 			}
 		}
@@ -339,10 +326,10 @@ main(int argc, char **argv)
 
 		if (found == 0) {
 			if (npa.npa_name != NULL) {
-				warnx("%s%.*s%.*d: no such controller or "
+				warnx("%s%.*s%.*s: no such controller or "
 				    "namespace", npa.npa_name,
-				    npa.npa_nsid > 0 ? -1 : 0, "/",
-				    npa.npa_nsid > 0 ? -1 : 0, npa.npa_nsid);
+				    npa.npa_isns ? -1 : 0, "/",
+				    npa.npa_isns ? -1 : 0, npa.npa_nsid);
 			} else {
 				warnx("no controllers found");
 			}
@@ -388,7 +375,7 @@ static boolean_t
 nvme_match(nvme_process_arg_t *npa)
 {
 	char *name;
-	uint32_t nsid = 0;
+	char *nsid = 0;
 
 	if (npa->npa_name == NULL)
 		return (B_TRUE);
@@ -405,12 +392,12 @@ nvme_match(nvme_process_arg_t *npa)
 	free(name);
 
 	if (npa->npa_isns) {
-		if (npa->npa_nsid == 0)
+		if (npa->npa_nsid == NULL)
 			return (B_TRUE);
-		nsid = strtoul(di_minor_name(npa->npa_minor), NULL, 10);
+		nsid = di_minor_name(npa->npa_minor);
 	}
 
-	if (npa->npa_isns && npa->npa_nsid != nsid)
+	if (npa->npa_isns && strcmp(npa->npa_nsid, nsid) != 0)
 		return (B_FALSE);
 
 	return (B_TRUE);
@@ -589,7 +576,7 @@ usage_identify(const char *c_name)
 static int
 do_identify(int fd, const nvme_process_arg_t *npa)
 {
-	if (npa->npa_nsid == 0) {
+	if (!npa->npa_isns) {
 		nvme_capabilities_t *cap;
 
 		cap = nvme_capabilities(fd);
@@ -627,7 +614,7 @@ do_get_logpage_error(int fd, const nvme_process_arg_t *npa)
 	size_t bufsize = sizeof (nvme_error_log_entry_t) * nlog;
 	nvme_error_log_entry_t *elog;
 
-	if (npa->npa_nsid != 0)
+	if (npa->npa_isns)
 		errx(-1, "Error Log not available on a per-namespace basis");
 
 	elog = nvme_get_logpage(fd, NVME_LOGPAGE_ERROR, &bufsize);
@@ -651,7 +638,7 @@ do_get_logpage_health(int fd, const nvme_process_arg_t *npa)
 	size_t bufsize = sizeof (nvme_health_log_t);
 	nvme_health_log_t *hlog;
 
-	if (npa->npa_nsid != 0) {
+	if (npa->npa_isns) {
 		if (npa->npa_idctl->id_lpa.lp_smart == 0)
 			errx(-1, "SMART/Health information not available "
 			    "on a per-namespace basis on this controller");
@@ -676,7 +663,7 @@ do_get_logpage_fwslot(int fd, const nvme_process_arg_t *npa)
 	size_t bufsize = sizeof (nvme_fwslot_log_t);
 	nvme_fwslot_log_t *fwlog;
 
-	if (npa->npa_nsid != 0)
+	if (npa->npa_isns)
 		errx(-1, "Firmware Slot information not available on a "
 		    "per-namespace basis");
 
@@ -805,9 +792,9 @@ do_get_features(int fd, const nvme_process_arg_t *npa)
 	if (npa->npa_argc == 0) {
 		(void) printf("%s: Get Features\n", npa->npa_name);
 		for (feat = &features[0]; feat->f_feature != 0; feat++) {
-			if ((npa->npa_nsid != 0 &&
+			if ((npa->npa_isns &&
 			    (feat->f_getflags & NVMEADM_NS) == 0) ||
-			    (npa->npa_nsid == 0 &&
+			    (!npa->npa_isns &&
 			    (feat->f_getflags & NVMEADM_CTRL) == 0))
 				continue;
 
@@ -841,9 +828,9 @@ do_get_features(int fd, const nvme_process_arg_t *npa)
 			continue;
 		}
 
-		if ((npa->npa_nsid != 0 &&
+		if ((npa->npa_isns &&
 		    (feat->f_getflags & NVMEADM_NS) == 0) ||
-		    (npa->npa_nsid == 0 &&
+		    (!npa->npa_isns &&
 		    (feat->f_getflags & NVMEADM_CTRL) == 0)) {
 			warnx("feature %s %s supported for namespaces",
 			    feat->f_name, (feat->f_getflags & NVMEADM_NS) != 0 ?
-- 
2.21.0

