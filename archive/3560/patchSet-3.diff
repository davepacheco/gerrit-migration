From c0bc50df8a5e95d61b5e50febeca16a11fe712d7 Mon Sep 17 00:00:00 2001
From: Patrick Mooney <pmooney@pfmooney.com>
Date: Thu, 8 Mar 2018 05:42:00 +0000
Subject: [PATCH] OS-6701 mac_fix_cksum breaks ethernet header

---
 usr/src/uts/common/io/mac/mac_util.c | 69 +++++++++++++++++++++++-----
 1 file changed, 58 insertions(+), 11 deletions(-)

diff --git a/usr/src/uts/common/io/mac/mac_util.c b/usr/src/uts/common/io/mac/mac_util.c
index e83af37f16..1e7cfeea21 100644
--- a/usr/src/uts/common/io/mac/mac_util.c
+++ b/usr/src/uts/common/io/mac/mac_util.c
@@ -20,6 +20,7 @@
  */
 /*
  * Copyright (c) 2008, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright 2018 Joyent, Inc.
  */
 
 /*
@@ -107,6 +108,7 @@ mac_fix_cksum(mblk_t *mp_chain)
 		uint32_t offset;
 		struct ether_header *ehp;
 		uint16_t sap;
+		mblk_t *skipped_hdr = NULL;
 
 		hcksum_retrieve(mp, NULL, NULL, &start, &stuff, &end, &value,
 		    &flags);
@@ -150,6 +152,12 @@ mac_fix_cksum(mblk_t *mp_chain)
 			offset = sizeof (struct ether_header);
 		}
 
+		/*
+		 * If the first mblk in the chain for this packet contains only
+		 * the ethernet header, skip past it for now.  Packets with
+		 * their data contained in only a single mblk can then use the
+		 * fastpaths tuned to that possibility.
+		 */
 		if (MBLKL(mp) <= offset) {
 			offset -= MBLKL(mp);
 			if (mp->b_cont == NULL) {
@@ -164,6 +172,7 @@ mac_fix_cksum(mblk_t *mp_chain)
 				mp = mp1;
 				continue;
 			}
+			skipped_hdr = mp;
 			mp = mp->b_cont;
 		}
 
@@ -266,21 +275,17 @@ mac_fix_cksum(mblk_t *mp_chain)
 		if (flags & HCK_PARTIALCKSUM) {
 			uint16_t *up, partial, cksum;
 			uchar_t *ipp; /* ptr to beginning of IP header */
+			mblk_t *old_mp = NULL;
 
 			if (mp->b_cont != NULL) {
-				mblk_t *mp1;
+				mblk_t *new_mp;
 
-				mp1 = msgpullup(mp, offset + end);
-				if (mp1 == NULL)
+				new_mp = msgpullup(mp, offset + end);
+				if (new_mp == NULL) {
 					continue;
-				mp1->b_next = mp->b_next;
-				mp->b_next = NULL;
-				freemsg(mp);
-				if (prev != NULL)
-					prev->b_next = mp1;
-				else
-					new_chain = mp1;
-				mp = mp1;
+				}
+				old_mp = mp;
+				mp = new_mp;
 			}
 
 			ipp = mp->b_rptr + offset;
@@ -302,6 +307,48 @@ mac_fix_cksum(mblk_t *mp_chain)
 			flags &= ~HCK_PARTIALCKSUM;
 			flags |= HCK_FULLCKSUM_OK;
 			value = 0;
+
+			/*
+			 * If 'mp' is the result of a msgpullup(), it needs to
+			 * be properly reattached into the existing chain of
+			 * messages before continuing.
+			 */
+			if (old_mp != NULL) {
+				if (skipped_hdr != NULL) {
+					/*
+					 * If the ethernet header was cast
+					 * aside before checksum calculation,
+					 * reattach it now.  That mblk will
+					 * still be properly linked into the
+					 * existing chain.
+					 */
+					skipped_hdr->b_cont = mp;
+					mp = skipped_hdr;
+					skipped_hdr = NULL;
+				} else {
+					/* Link the new mblk into the chain. */
+					mp->b_next = old_mp->b_next;
+
+					if (prev != NULL)
+						prev->b_next = mp;
+					else
+						new_chain = mp;
+				}
+
+				old_mp->b_next = NULL;
+				freemsg(old_mp);
+			}
+		}
+
+		/*
+		 * If the ethernet header was skipped earlier, seek back to it.
+		 * It is what the new cksum information should be associated
+		 * against, and contain the proper b_next reference in the
+		 * chain, should it exist.
+		 */
+		if (skipped_hdr != NULL) {
+			ASSERT3P(skipped_hdr->b_cont, ==, mp);
+			mp = skipped_hdr;
 		}
 
 		(void) hcksum_assoc(mp, NULL, NULL, start, stuff, end,
-- 
2.21.0

