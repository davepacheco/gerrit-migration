commit d758b17c531dafb4e54076b5316421ce3874dcfa (refs/changes/60/3560/1)
Author: Patrick Mooney <pmooney@pfmooney.com>
Date:   2018-03-08T06:08:04+00:00 (1 year, 7 months ago)
    
    OS-6701 mac_fix_cksum breaks ethernet header

diff --git a/usr/src/uts/common/io/mac/mac_util.c b/usr/src/uts/common/io/mac/mac_util.c
index e83af37f16..d1591807a1 100644
--- a/usr/src/uts/common/io/mac/mac_util.c
+++ b/usr/src/uts/common/io/mac/mac_util.c
@@ -20,6 +20,7 @@
  */
 /*
  * Copyright (c) 2008, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright 2018 Joyent, Inc.
  */
 
 /*
@@ -107,6 +108,7 @@ mac_fix_cksum(mblk_t *mp_chain)
 		uint32_t offset;
 		struct ether_header *ehp;
 		uint16_t sap;
+		mblk_t *skipped_hdr = NULL;
 
 		hcksum_retrieve(mp, NULL, NULL, &start, &stuff, &end, &value,
 		    &flags);
@@ -164,6 +166,7 @@ mac_fix_cksum(mblk_t *mp_chain)
 				mp = mp1;
 				continue;
 			}
+			skipped_hdr = mp;
 			mp = mp->b_cont;
 		}
 
@@ -266,21 +269,17 @@ mac_fix_cksum(mblk_t *mp_chain)
 		if (flags & HCK_PARTIALCKSUM) {
 			uint16_t *up, partial, cksum;
 			uchar_t *ipp; /* ptr to beginning of IP header */
+			mblk_t *old_mp = NULL;
 
 			if (mp->b_cont != NULL) {
-				mblk_t *mp1;
+				mblk_t *new_mp;
 
-				mp1 = msgpullup(mp, offset + end);
-				if (mp1 == NULL)
+				new_mp = msgpullup(mp, offset + end);
+				if (new_mp == NULL) {
 					continue;
-				mp1->b_next = mp->b_next;
-				mp->b_next = NULL;
-				freemsg(mp);
-				if (prev != NULL)
-					prev->b_next = mp1;
-				else
-					new_chain = mp1;
-				mp = mp1;
+				}
+				old_mp = mp;
+				mp = new_mp;
 			}
 
 			ipp = mp->b_rptr + offset;
@@ -302,6 +301,36 @@ mac_fix_cksum(mblk_t *mp_chain)
 			flags &= ~HCK_PARTIALCKSUM;
 			flags |= HCK_FULLCKSUM_OK;
 			value = 0;
+
+			/*
+			 * If 'mp' is the result of a msgpullup(), it needs to
+			 * be properly reattached into the existing chain of
+			 * messages before continuing.
+			 */
+			if (old_mp != NULL) {
+				if (skipped_hdr != NULL) {
+					/*
+					 * If the ethernet header was cast
+					 * aside before checksum calculation,
+					 * reattach it now.  That mblk will
+					 * still be properly linked into the
+					 * existing chain.
+					 */
+					skipped_hdr->b_cont = mp;
+					mp = skipped_hdr;
+				} else {
+					/* Link the new mblk into the chain. */
+					mp->b_next = old_mp->b_next;
+					old_mp->b_next = NULL;
+
+					if (prev != NULL)
+						prev->b_next = mp;
+					else
+						new_chain = mp;
+				}
+
+				freemsg(old_mp);
+			}
 		}
 
 		(void) hcksum_assoc(mp, NULL, NULL, start, stuff, end,
