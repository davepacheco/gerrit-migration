commit 0c1ad945781242bb0b33267501347a6a5a8d73ce (refs/changes/90/2190/2)
Author: Cody Peter Mello <cody.mello@joyent.com>
Date:   2017-07-08T00:36:16+00:00 (2 years, 3 months ago)
    
    MANATEE-335 Ship both Postgres 9.2 and 9.6 in manta-manatee images

diff --git a/lib/postgresMgr.js b/lib/postgresMgr.js
index 4efe456..5665808 100644
--- a/lib/postgresMgr.js
+++ b/lib/postgresMgr.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright 2016 Joyent, Inc.
+ * Copyright (c) 2017, Joyent, Inc.
  */
 
 /**
@@ -25,11 +25,14 @@ var backoff = require('backoff');
 var ZfsClient = require('./zfsClient');
 var ConfParser = require('./confParser');
 var EventEmitter = require('events').EventEmitter;
+var forkexec = require('forkexec');
 var fs = require('fs');
+var mod_forkexec = require('forkexec');
+var mod_jsprim = require('jsprim');
+var path = require('path');
 var pg = require('pg');
 var Client = pg.Client;
 var shelljs = require('shelljs');
-var mod_forkexec = require('forkexec');
 var spawn = require('child_process').spawn;
 var exec = require('child_process').exec;
 var once = require('once');
@@ -41,6 +44,172 @@ var util = require('util');
 var vasync = require('vasync');
 var verror = require('verror');
 
+
+// --- Globals
+
+var INT_REQUIRED = {
+    type: 'integer',
+    required: true
+};
+
+var STR_REQUIRED = {
+    type: 'string',
+    required: true
+};
+
+var CONFIG_SCHEMA = {
+    type: 'object',
+    properties: {
+        // /manatee/pg/data
+        dataDir: STR_REQUIRED,
+        // postgres
+        dbUser: STR_REQUIRED,
+        // 10000
+        healthChkInterval: INT_REQUIRED,
+        // 60000
+        healthChkTimeout: INT_REQUIRED,
+        // 300000
+        opsTimeout: INT_REQUIRED,
+        // /opt/smartdc/manatee/etc/
+        postgresConfDir: STR_REQUIRED,
+        // postgresql.manta.coal.conf
+        postgresConfFile: STR_REQUIRED,
+        // recovery.conf
+        recoveryConfFile: STR_REQUIRED,
+        // pg_hba.conf
+        hbaConfFile: STR_REQUIRED,
+        // 60000
+        replicationTimeout: INT_REQUIRED,
+        snapShotterCfg: {
+            type: 'object'
+        },
+        // tcp://postgres@10.77.77.8:5432/postgres
+        url: STR_REQUIRED,
+        zfsClientCfg: {
+            type: 'object'
+        },
+        // false
+        oneNodeWriteMode: {
+            type: 'boolean'
+        },
+        // 60
+        pgConnectTimeout: INT_REQUIRED,
+        // "/path/.../to/.../manatee-config.json"
+        dataConfig: STR_REQUIRED,
+        defaultVersion: {
+            type: 'string',
+            required: true,
+            enum: [ '9.2', '9.6' ]
+        },
+        // /opt/local/postgres/
+        pgBaseDir: STR_REQUIRED,
+        versions: {
+            type: 'object',
+            required: true,
+            properties: {
+                '9.2': STR_REQUIRED,
+                '9.6': STR_REQUIRED
+            }
+        },
+        pgTunables: {
+            type: 'object',
+            required: true,
+            properties: {
+                synchronous_commit: {
+                    type: 'string',
+                    required: true,
+                    enum: [
+                        'on',
+                        'remote_apply',
+                        'remote_write'
+                    ]
+                },
+                // "30s", "1h", etc.
+                checkpoint_timeout: { type: 'string' },
+                checkpoint_segments: { type: 'integer' },
+                max_wal_size: { type: 'string' }
+            }
+        }
+    }
+};
+
+
+/**
+ * postgresql.conf values
+ */
+var CHECKPOINT_TIMEOUT = 'checkpoint_timeout';
+var EFFECTIVE_CACHE_SIZE = 'effective_cache_size';
+var PRIMARY_CONNINFO = 'primary_conninfo';
+var READ_ONLY = 'default_transaction_read_only';
+var SYNCHRONOUS_COMMIT = 'synchronous_commit';
+var SYNCHRONOUS_STANDBY_NAMES = 'synchronous_standby_names';
+
+var PRIMARY_CONNINFO_STR =
+    '\'host=%s port=%s user=%s application_name=%s connect_timeout=%s\'';
+
+// 9.2 only:
+var CHECKPOINT_SEGMENTS = 'checkpoint_segments';
+
+// 9.6 only:
+var MAX_WAL_SIZE = 'max_wal_size';
+
+/**
+ * replication status query.
+ */
+var PG_STAT_REPLICATION =
+    'select * from pg_stat_replication where application_name = \'%s\'';
+
+
+// --- Internal helpers
+
+/**
+ * Postgres versions are made up of two components: major and minor numbers.
+ * The major numbers are things like "9.2" and "9.6", while the minor number
+ * is the part after the last dot, e.g., the "4" in "9.2.4".
+ */
+function stripMinor(version) {
+    assert.string(version, 'version');
+
+    var pos = version.lastIndexOf('.');
+    assert.number(pos, 'pos');
+
+    return (version.substring(0, pos));
+}
+
+/**
+ * Postgres 9.2 was relaxed about values for "synchronous_standby_names", but
+ * in 9.6 we need to add double quotes around the value (as well as the single
+ * quotes).
+ */
+function formatStandbyName(name) {
+    return util.format('\'"%s"\'', name);
+}
+
+/**
+ * Update (or create) a symbolic link to point at a new path.
+ */
+function updateSymlink(srcpath, dstpath) {
+    var curpath = null;
+
+    try {
+        curpath = fs.readlinkSync(dstpath);
+    } catch (e) {
+        if (e.code !== 'ENOENT') {
+            throw e;
+        }
+    }
+
+    if (curpath === null) {
+        fs.symlinkSync(srcpath, dstpath);
+    } else if (curpath !== srcpath) {
+        fs.unlinkSync(dstpath);
+        fs.symlinkSync(srcpath, dstpath);
+    }
+}
+
+
+// --- Exported functions
+
 /**
  * The manager which manages interactions with PostgreSQL.
  * Responsible for initializing, starting, stopping, and health checking a
@@ -80,39 +249,7 @@ var verror = require('verror');
 function PostgresMgr(options) {
     assert.object(options, 'options');
     assert.object(options.log, 'options.log');
-
-    // /manatee/pg/data
-    assert.string(options.dataDir, 'options.dataDir');
-    // postgres
-    assert.string(options.dbUser, 'options.dbUser');
-    // /opt/smartdc/manatee/etc/pg_hba.conf
-    assert.string(options.hbaConf, 'options.hbaConf');
-    // 10000
-    assert.number(options.healthChkInterval, 'options.healthChkInterval');
-    // 60000
-    assert.number(options.healthChkTimeout, 'options.healthChkTimeout');
-    // 300000
-    assert.number(options.opsTimeout, 'options.opsTimeout');
-    // /opt/local/bin/initdb
-    assert.string(options.pgInitDbPath, 'options.pgInitDbPath');
-    // /opt/smartdc/manatee/etc/postgresql.manta.coal.conf
-    assert.string(options.postgresConf, 'options.postgresConf');
-    // /opt/local/bin/postgres
-    assert.string(options.postgresPath, 'options.postgresPath');
-    // /opt/smartdc/manatee/etc/recovery.conf
-    assert.string(options.recoveryConf, 'options.recoveryConf');
-    // 60000
-    assert.number(options.replicationTimeout, 'options.replicationTimeout');
-    // [ Object object ]
-    assert.object(options.snapShotterCfg, 'options.snapShotterCfg');
-    // tcp://postgres@10.77.77.8:5432/postgres
-    assert.string(options.url, 'options.url');
-    // [ Object object ]
-    assert.object(options.zfsClientCfg, 'options.zfsClientCfg');
-    // false
-    assert.optionalBool(options.oneNodeWriteMode, 'options.oneNodeWriteMode');
-    // 60
-    assert.number(options.pgConnectTimeout, 'options.pgConnectTimeout');
+    assert.ifError(mod_jsprim.validateJsonObject(CONFIG_SCHEMA, options));
 
     EventEmitter.call(this);
 
@@ -125,30 +262,23 @@ function PostgresMgr(options) {
 
     /** @type {string} The dir on disk where the postgres instance is located */
     self._dataDir = options.dataDir;
+    self._defaultVersion = options.defaultVersion;
+    self._pgBaseDir = options.pgBaseDir;
+    self._versions = options.versions;
+    self._dataConf = path.resolve(options.dataConfig);
 
-    /*
-     * paths to the postgres commands
-     */
-    /** @type {string} Path to the pg_init binary. */
-    self._pgInitDbPath = options.pgInitDbPath;
-    /** @type {string} Path to the postgres binary */
-    self._postgresPath = options.postgresPath;
+    self._confDir = options.postgresConfDir;
+
+    self.hbaConfFile = options.hbaConfFile;
+    self.postgresConfFile = options.postgresConfFile;
+    self.recoveryConfFile = options.recoveryConfFile;
+
+    self._hbaConfPath = path.join(self._dataDir, 'pg_hba.conf');
+    self._postgresConfPath = path.join(self._dataDir, 'postgresql.conf');
+    self._recoveryConfPath = path.join(self._dataDir, 'recovery.conf');
+
+    self._tunables = options.pgTunables;
 
-    /*
-     * Paths to the pg configs
-     */
-    /** @type {string} Path to the master hba config file */
-    self._hbaConf = options.hbaConf;
-    /** @type {string} Path to the master postgres config file */
-    self._postgresConf = options.postgresConf;
-    /** @type {string} Path to the master recovery config file */
-    self._recoveryConf = options.recoveryConf;
-    /** @type {string} Path to the hba config file */
-    self._hbaConfPath = self._dataDir + '/' + 'pg_hba.conf';
-    /** @type {string} Path to the postgres config file */
-    self._postgresConfPath = self._dataDir + '/' + 'postgresql.conf';
-    /** @type {string} Path to the recovery config file */
-    self._recoveryConfPath = self._dataDir + '/' + 'recovery.conf';
 
     /** @type {url} The URL of this postgres instance */
     self._url = url.parse(options.url);
@@ -276,50 +406,175 @@ module.exports = PostgresMgr;
 util.inherits(PostgresMgr, EventEmitter);
 
 /**
- * @constant
- * @type {string}
- * @default
+ * Get the version that we expect the Postgres data to be for:
+ *
+ * - If the configuration file that the sitter writes out is present,
+ *   use the version stored in there.
+ * - If <PG_DIR>/PG_VERSION exists, then we should be on a system that
+ *   has already initialized a 9.2 database. Assert that, and then use
+ *   Postgres 9.2 paths.
+ * - If we haven't intialized a database yet, then use the configured
+ *   default paths.
+ *
+ * This function then returns an object with two fields, to be written
+ * out in manatee-config.json:
+ *
+ * - "initialized", the version of Postgres that the database had been
+ *   initialized with.
+ * - "current", the version of Postgres that the database on-disk data
+ *   should be used with.
  */
-PostgresMgr.prototype.SYNCHRONOUS_STANDBY_NAMES = 'synchronous_standby_names';
+PostgresMgr.prototype.getVersionInfo = function () {
+    var vfile = path.join(this._dataDir, 'PG_VERSION');
+    var pgc = null;
+    var curver = null;
 
-/**
- * @constant
- * @type {string}
- * @default
- */
-PostgresMgr.prototype.SYNCHRONOUS_COMMIT = 'synchronous_commit';
+    try {
+        pgc = JSON.parse(fs.readFileSync(this._dataConf, 'utf8'));
+    } catch (e) {
+        if (e.code !== 'ENOENT') {
+            throw e;
+        }
+    }
 
-/**
- * @constant
- * @type {string}
- * @default
- */
-PostgresMgr.prototype.PRIMARY_CONNINFO = 'primary_conninfo';
+    try {
+        curver = fs.readFileSync(vfile, 'utf8').trim();
+    } catch (e) {
+        if (e.code !== 'ENOENT') {
+            throw e;
+        }
+    }
+
+    if (pgc === null) {
+        if (curver === null) {
+            // First time booting, use default version:
+            return ({
+                initialized: this._versions[this._defaultVersion],
+                current: this._versions[this._defaultVersion]
+            });
+        } else {
+            // First time using a sitter that writes manatee-config.json:
+            assert.equal(curver, '9.2');
+            return ({
+                initialized: '9.2.4',
+                current: this._versions['9.2']
+            });
+        }
+    }
+
+    assert.object(pgc, 'pgc');
+    assert.string(pgc.initialized, 'pgc.initialized');
+    assert.string(pgc.current, 'pgc.current');
+
+    var major = stripMinor(pgc.current);
+    var current = this._versions[major];
+
+    assert.string(current, 'current');
+    assert.equal(pgc.current, current, 'patch version matches');
+
+    if (curver !== null) {
+        /*
+         * The PG_VERSION file doesn't always exist (e.g., during a rebuild
+         * we delete all of the contents of the data/ directory), but when
+         * it does, we do a sanity check here to make sure it hasn't been
+         * manipulated underneath us.
+         */
+        assert.equal(curver, major, 'PG_VERSION == current major');
+    }
+
+    return ({
+        initialized: pgc.initialized,
+        current: current
+    });
+};
 
-/**
- * @constant
- * @type {string}
- * @default
- */
-PostgresMgr.prototype.READ_ONLY = 'default_transaction_read_only';
 
 /**
- * postgresql.conf values
- * @constant
- * @type {string}
- * @default
+ * We support configuring several Postgres options through SAPI tunables,
+ * and then put them into the config file when we generate it. Since some
+ * options are only valid in Postgres 9.2 or 9.6, we need to switch on the
+ * version here.
  */
-PostgresMgr.prototype.PRIMARY_CONNINFO_STR =
-    '\'host=%s port=%s user=%s application_name=%s connect_timeout=%s\'';
+PostgresMgr.prototype.getTunables = function (version) {
+    var self = this;
+    var options = {};
+
+    function copy(name) {
+        if (mod_jsprim.hasKey(self._tunables, name)) {
+            options[name] = self._tunables[name];
+        }
+    }
+
+    copy(EFFECTIVE_CACHE_SIZE);
+    copy(CHECKPOINT_TIMEOUT);
+
+    if (mod_jsprim.startsWith(version, '9.2.')) {
+        copy(CHECKPOINT_SEGMENTS);
+    } else {
+        copy(MAX_WAL_SIZE);
+    }
+
+    return (options);
+};
+
 
 /**
- * replication status query.
- * @constant
- * @type {string}
- * @default
+ * We ship multiple versions of Postgres, and need to be able to run the
+ * appropriate version of the binaries, with suitable versions of the
+ * configuration files. We determine the relevant version here, and then
+ * generate the proper paths.
  */
-PostgresMgr.prototype.PG_STAT_REPLICATION =
-    'select * from pg_stat_replication where application_name = \'%s\'';
+PostgresMgr.prototype.resolveVersionedPaths = function () {
+    var verinfo = this.getVersionInfo();
+    var version = verinfo.current;
+
+    /*
+     * Write out all of our versioning information to the dataset.
+     */
+    fs.writeFileSync(this._dataConf, JSON.stringify(verinfo));
+
+    /*
+     * Update the "current" symbolic link, in case we're running for the
+     * first time after upgrading the Postgres database.
+     */
+    var pgVersDir = path.join(this._pgBaseDir, version);
+    var pgCurrDir = path.join(this._pgBaseDir, 'current');
+    updateSymlink(pgVersDir, pgCurrDir);
+
+    /*
+     * Set up paths to the Postgres commands.
+     */
+    this.dbBinDir = path.join(pgVersDir, 'bin');
+    this._pgInitDbPath = path.join(this.dbBinDir, 'initdb');
+    this._postgresPath = path.join(this.dbBinDir, 'postgres');
+
+    /*
+     * Set up paths to the Postgres configuration files.
+     */
+    var etcDir = path.join(this._confDir, stripMinor(version));
+    this._postgresConf = path.join(etcDir, this.postgresConfFile);
+    this._recoveryConf = path.join(etcDir, this.recoveryConfFile);
+    this._hbaConf = path.join(etcDir, this.hbaConfFile);
+
+    /*
+     * Get appropriate configuration options for this PG version.
+     */
+    this._additionalPgOptions = this.getTunables(version);
+
+    this._log.info({
+        versions: verinfo,
+        binaries: {
+            initdb: this._pgInitDbPath,
+            postgres: this._pgInitDbPath
+        },
+        tunables: this._additionalPgOptions,
+        configs: {
+            'pg_hba.conf': this._hbaConf,
+            'postgresql.conf': this._postgresConf,
+            'recovery.conf': this._recoveryConf
+        }
+    }, 'loaded versioning information');
+};
 
 /**
  * Start up the PG instance.  Will return an error if postgres is already
@@ -709,9 +964,10 @@ PostgresMgr.prototype._waitForStandby = function (stdby) {
         },
         function _enableWrites(_, cb) {
             var confOpts = {};
-            confOpts[self.SYNCHRONOUS_COMMIT] = 'remote_write';
-            confOpts[self.SYNCHRONOUS_STANDBY_NAMES] =
-                '\'' + stdby + '\'';
+            confOpts[SYNCHRONOUS_COMMIT] =
+                self._tunables.synchronous_commit;
+            confOpts[SYNCHRONOUS_STANDBY_NAMES] =
+                formatStandbyName(stdby);
             self._updatePgConf(confOpts, cb);
         },
         function _sighup(_, cb) {
@@ -778,9 +1034,10 @@ PostgresMgr.prototype._primary = function _primary(stdby, callback) {
         },
         function _updateConfigs(_, cb) {
             var confOpts = {};
-            confOpts[self.SYNCHRONOUS_COMMIT] = 'remote_write';
+            confOpts[SYNCHRONOUS_COMMIT] =
+                self._tunables.synchronous_commit;
             if (!self._oneNodeWriteMode) {
-                confOpts[self.READ_ONLY] = 'on';
+                confOpts[READ_ONLY] = 'on';
             } else {
                 log.warn('enable write mode with only one ' +
                          'node, may cause WAL corruption!');
@@ -850,14 +1107,18 @@ PostgresMgr.prototype._updateStandby = function _updateStandby(stdby,
         },
         function _updateConfigs(_, cb) {
             var confOpts = {};
-            confOpts[self.SYNCHRONOUS_COMMIT] = 'remote_write';
+            confOpts[SYNCHRONOUS_COMMIT] =
+                self._tunables.synchronous_commit;
             if (stdby) {
-                confOpts[self.SYNCHRONOUS_STANDBY_NAMES] = '\'' + stdby + '\'';
-                // if there is a standby, we always want to stay in read-only
-                // mode
-                confOpts[self.READ_ONLY] = 'on';
+                /*
+                 * If there is a standby, we always want to stay in read-only
+                 * mode.
+                 */
+                confOpts[SYNCHRONOUS_STANDBY_NAMES] =
+                    formatStandbyName(stdby);
+                confOpts[READ_ONLY] = 'on';
             } else if (!self._oneNodeWriteMode) {
-                confOpts[self.READ_ONLY] = 'on';
+                confOpts[READ_ONLY] = 'on';
             } else {
                 log.warn('enable write mode with only one node, may cause ' +
                          'WAL corruption!');
@@ -933,13 +1194,13 @@ PostgresMgr.prototype._standby = function _standby(primUrl,
     function updatePrimaryConnInfo(cb) {
         var opts = {};
         var value = sprintf(
-            self.PRIMARY_CONNINFO_STR,
+            PRIMARY_CONNINFO_STR,
             primaryUrl.hostname,
             primaryUrl.port,
             primaryUrl.auth,
             self._url.href,
             self._pgConnectTimeout);
-        opts[self.PRIMARY_CONNINFO] = value;
+        opts[PRIMARY_CONNINFO] = value;
         self._updateRecoveryConf(opts, cb);
     }
 
@@ -995,6 +1256,8 @@ PostgresMgr.prototype._standby = function _standby(primUrl,
         },
         // update primary_conninfo to point to the new (host, port) pair
         function _updatePrimaryConnInfo(_, cb) {
+            self.resolveVersionedPaths();
+
             updatePrimaryConnInfo(function (err) {
                 _.isRestore = err;
                 return cb();
@@ -1006,7 +1269,7 @@ PostgresMgr.prototype._standby = function _standby(primUrl,
                 return cb();
             } else {
                 var opts = {};
-                opts[self.SYNCHRONOUS_COMMIT] = 'off';
+                opts[SYNCHRONOUS_COMMIT] = 'off';
                 self._updatePgConf(opts, function (err) {
                     _.isRestore = err;
                     return cb();
@@ -1027,20 +1290,24 @@ PostgresMgr.prototype._standby = function _standby(primUrl,
         // following run only if _.isRestore is needed
         function _restore(_, cb) {
             if (!_.isRestore) {
-                return cb();
-            } else {
-                restore(function (err) {
-                    // restore the original backup if zfs recv fails.
-                    if (err) {
-                        self._zfsClient.restoreDataset(backupSnapshot,
-                                                       function () {
-                            return cb(err);
-                        });
-                    } else {
-                        return cb();
-                    }
-                });
+                cb();
+                return;
             }
+
+            log.warn({ err: _.isRestore }, 'PostgresMgr._standby: ' +
+                'failed to move into standby state, performing restore');
+
+            restore(function (err) {
+                // restore the original backup if zfs recv fails.
+                if (err) {
+                    self._zfsClient.restoreDataset(backupSnapshot,
+                        function () {
+                        return cb(err);
+                    });
+                } else {
+                    return cb();
+                }
+            });
         },
         // update primary info since the zfs dataset from the primary will not
         // contain standby information
@@ -1058,7 +1325,7 @@ PostgresMgr.prototype._standby = function _standby(primUrl,
                 return cb();
             } else {
                 var opts = {};
-                opts[self.SYNCHRONOUS_COMMIT] = 'off';
+                opts[SYNCHRONOUS_COMMIT] = 'off';
                 self._updatePgConf(opts, function (err) {
                     if (err) {
                         _.isRestore = err;
@@ -1313,6 +1580,8 @@ PostgresMgr.prototype._start = function _start(cb) {
     var intervalId = null;
     cb = once(cb);
 
+    self.resolveVersionedPaths();
+
     /**
      * Always reset and clear the healthcheck before callback.
      * This callback is invoked when the child PG process has started.
@@ -1484,7 +1753,7 @@ PostgresMgr.prototype._initDb = function (callback) {
             });
 
         },
-        function setDataDirOnwership(_, cb) {
+        function setDataDirOwnership(_, cb) {
             var cmd = 'chown -R ' + self._dbUser + ' '  + self._dataDir;
             log.info({cmd: cmd},
                 'PostgresMgr.initDb: changing datadir ownership to postgres');
@@ -1498,11 +1767,15 @@ PostgresMgr.prototype._initDb = function (callback) {
 
         },
         function _initDb(_, cb) {
+            self.resolveVersionedPaths();
+
             var args = [ 'sudo', '-u', self._dbUser,
                          self._pgInitDbPath, '--encoding=UTF-8', '--locale=C',
                          '-D', self._dataDir ];
+
             log.info({cmd: 'initdb', argv: args},
-                     'PostgresMgr.initDb: initializing db');
+                'PostgresMgr.initDb: initializing db');
+
             mod_forkexec.forkExecWait({ argv: args }, function (err, info) {
                 // ignore errors since the db could already be initialized
                 log.info(info, 'PostgresMgr.initDb: initdb returned');
@@ -1519,9 +1792,8 @@ PostgresMgr.prototype._initDb = function (callback) {
                 shelljs.cp('-f', self._postgresConf, self._dataDir +
                     '/postgresql.conf');
 
-                return cb();
+                cb();
             });
-
         }
     ], arg: {}}, function (err) {
         log.info({err: err}, 'PostgresMgr.initDb: finished');
@@ -1733,9 +2005,10 @@ PostgresMgr.prototype._sighup = function (callback) {
  * Manatee, meaning that keys in the current config not present in the default
  * config will be lost.
  */
-PostgresMgr.prototype._updatePgConf = function (options, cb) {
-    var self = this;
-    self._updateConf(options, self._postgresConf, self._postgresConfPath, cb);
+PostgresMgr.prototype._updatePgConf = function (updates, cb) {
+    var options =
+        mod_jsprim.mergeObjects(updates, null, this._additionalPgOptions);
+    this._updateConf(options, this._postgresConf, this._postgresConfPath, cb);
 };
 
 
@@ -1929,7 +2202,7 @@ PostgresMgr.prototype._checkRepl = function (stdby) {
 PostgresMgr.prototype._checkReplStatus = function (stdby, callback) {
     var self = this;
     var log = self._log;
-    var query = sprintf(self.PG_STAT_REPLICATION, stdby);
+    var query = sprintf(PG_STAT_REPLICATION, stdby);
     log.info({standby: stdby, query: query},
              'PostgresMgr.checkReplStatus: entering');
     self._queryDb(query, function (err, result) {
diff --git a/lib/zfsClient.js b/lib/zfsClient.js
index ceccd19..2340177 100644
--- a/lib/zfsClient.js
+++ b/lib/zfsClient.js
@@ -358,9 +358,13 @@ ZfsClient.prototype.assertDataset = function assertDataset(callback) {
             log.debug({
                 cmd: cmd
             }, 'ZfsClient.assertDataset: unmounting dataset for setup');
-            exec(cmd, function (err) {
-                log.info({err: err},
-                    'ZfsClient.assertDataset: unmount finished');
+            exec(cmd, function (err, stdout, stderr) {
+                log.info({
+                    err: err,
+                    stdout: stdout,
+                    stderr: stderr
+                }, 'ZfsClient.assertDataset: unmount finished');
+
                 // the unmount will fail if the dataset is already unmounted so
                 // ignore it.
                 return cb();
diff --git a/package.json b/package.json
index 6624337..1ade043 100644
--- a/package.json
+++ b/package.json
@@ -27,6 +27,7 @@
         "extsprintf": "1.3.0",
         "iniparser": "1.0.5",
         "forkexec": "1.1.0",
+        "jsprim": "1.4.0",
         "manatee-state-machine": "git://github.com/joyent/manatee-state-machine#master",
         "manta": "1.2.6",
         "node-uuid": "1.4.1",
