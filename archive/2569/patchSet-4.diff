From 7220f6b605da7ebc7200447f86ef145d8905abea Mon Sep 17 00:00:00 2001
From: Josh Wilsdon <josh@wilsdon.ca>
Date: Wed, 20 Sep 2017 13:28:05 -0700
Subject: [PATCH] PUBAPI-1420 Add ability to mount NFS volumes with
 CreateMachine endpoint Reviewed by: Julien Gilli <julien.gilli@joyent.com>

---
 CHANGES.md                   |   1 +
 lib/do_instance/do_create.js | 109 ++++++++++++++++++++++++++++++++++-
 2 files changed, 108 insertions(+), 2 deletions(-)

diff --git a/CHANGES.md b/CHANGES.md
index 8b00156..168f7b1 100644
--- a/CHANGES.md
+++ b/CHANGES.md
@@ -8,6 +8,7 @@ Known issues:
 ## not yet released
 
 - [joyent/node-triton#226] added new `triton volume sizes` subcommand.
+- [PUBAPI-1420] added support for mounting volumes in LX and SmartOS instances.
 
 ## 5.3.1
 
diff --git a/lib/do_instance/do_create.js b/lib/do_instance/do_create.js
index cc0c636..4301b2b 100644
--- a/lib/do_instance/do_create.js
+++ b/lib/do_instance/do_create.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright 2016 Joyent, Inc.
+ * Copyright 2017 Joyent, Inc.
  *
  * `triton instance create ...`
  */
@@ -20,6 +20,62 @@ var distractions = require('../distractions');
 var errors = require('../errors');
 var mat = require('../metadataandtags');
 
+function parseVolume(volume) {
+    var components;
+    var volMode;
+    var volMountpoint;
+    var volName;
+    var VALID_MODES = ['ro', 'rw'];
+    var VALID_VOLUME_NAME_REGEXP = /^[a-zA-Z0-9][a-zA-Z0-9_\.\-]+$/;
+
+    assert.string(volume, 'volume');
+
+    components = volume.split(':');
+    if (components.length !== 2 && components.length !== 3) {
+        return new errors.UsageError('invalid volume specified, must be in ' +
+            'the form "<volume name>:<mount path>[:<mode>]", got: "' + volume +
+            '"');
+    }
+
+    volName = components[0];
+    volMountpoint = components[1];
+    volMode = components[2];
+
+    // first component should be a volume name. We only check here that it
+    // syntactically looks like a volume name, we'll leave the upstream to
+    // determine if it's not actually a volume.
+    if (!VALID_VOLUME_NAME_REGEXP.test(volName)) {
+        return new errors.UsageError('invalid volume name, got: "' + volume +
+            '"');
+    }
+
+    // second component should be an absolute path
+    // NOTE: if we ever move past node 0.10, we could use path.isAbsolute(path)
+    if (volMountpoint.length === 0 || volMountpoint[0] !== '/') {
+        return new errors.UsageError('invalid volume mountpoint, must be ' +
+            'absolute path, got: "' + volume + '"');
+    }
+    if (volMountpoint.indexOf('\0') !== -1) {
+        return new errors.UsageError('invalid volume mountpoint, contains ' +
+            'invalid characters, got: "' + volume + '"');
+    }
+    if (volMountpoint.search(/[^\/]/) === -1) {
+        return new errors.UsageError('invalid volume mountpoint, must contain' +
+            ' at least one non-/ character, got: "' + volume + '"');
+    }
+
+    // third component is optional mode: 'ro' or 'rw'
+    if (components.length === 3 && VALID_MODES.indexOf(volMode) === -1) {
+        return new errors.UsageError('invalid volume mode, got: "' + volume +
+            '"');
+    }
+
+    return {
+        mode: volMode || 'rw',
+        mountpoint: volMountpoint,
+        name: volName
+    };
+}
 
 function do_create(subcmd, opts, args, cb) {
     if (opts.help) {
@@ -132,6 +188,42 @@ function do_create(subcmd, opts, args, cb) {
             next();
         },
 
+        /*
+         * Make sure if volumes were passed, they're in the correct form.
+         */
+        function parseVolumes(ctx, next) {
+            var idx;
+            var validationErrs = [];
+            var parsedObj;
+            var volumes = [];
+
+            if (!opts.volume) {
+                next();
+                return;
+            }
+
+            for (idx = 0; idx < opts.volume.length; idx++) {
+                parsedObj = parseVolume(opts.volume[idx]);
+                if (parsedObj instanceof Error) {
+                    validationErrs.push(parsedObj);
+                } else {
+                    // if it's not an error, it's a volume
+                    volumes.push(parsedObj);
+                }
+            }
+
+            if (validationErrs.length > 0) {
+                next(new errors.MultiError(validationErrs));
+                return;
+            }
+
+            if (volumes.length > 0) {
+                ctx.volumes = volumes;
+            }
+
+            next();
+        },
+
         /*
          * Determine `ctx.locality` according to what CloudAPI supports
          * based on `ctx.affinities` parsed earlier.
@@ -274,12 +366,15 @@ function do_create(subcmd, opts, args, cb) {
         },
 
         function createInst(ctx, next) {
+            assert.optionalArrayOfObject(ctx.volumes, 'ctx.volumes');
+
             var createOpts = {
                 name: opts.name,
                 image: ctx.img.id,
                 'package': ctx.pkg && ctx.pkg.id,
                 networks: ctx.nets && ctx.nets.map(
-                    function (net) { return net.id; })
+                    function (net) { return net.id; }),
+                volumes: ctx.volumes && ctx.volumes
             };
             if (ctx.locality) {
                 createOpts.locality = ctx.locality;
@@ -495,6 +590,16 @@ do_create.options = [
         names: ['json', 'j'],
         type: 'bool',
         help: 'JSON stream output.'
+    },
+    {
+        names: ['volume', 'v'],
+        type: 'arrayOfString',
+        help: 'Mount a volume into the instance (non-KVM only). ARG is ' +
+            '"<volume-name:/mount/point>[:access-mode]" where access mode is ' +
+            'one of "ro" for read-only or "rw" for read-write (default). For ' +
+            'example: "-v myvolume:/mnt:ro" to mount "myvolume" read-only on ' +
+            '/mnt in this instance.'
+
     }
 ];
 
-- 
2.21.0

