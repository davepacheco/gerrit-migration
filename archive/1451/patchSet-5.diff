From e73c7fd417741500ce3b05b3bdf430442b0cab93 Mon Sep 17 00:00:00 2001
From: Cody Peter Mello <cody.mello@joyent.com>
Date: Tue, 7 Feb 2017 00:30:41 +0000
Subject: [PATCH] MORAY-390 Upgrade Moray to node-fast v2 MORAY-408 Need better
 bucket manipulation tests

---
 Makefile                     |   1 +
 package.json                 |   1 +
 test/buckets.test.js         |  29 +++
 test/cli-sanity.test.js      |   4 +
 test/helper.js               |  58 +++++-
 test/invalid-buckets.test.js | 249 ++++++++++++++++++++++++
 test/invalid-fast.test.js    | 361 +++++++++++++++++++++++++++++++++++
 7 files changed, 701 insertions(+), 2 deletions(-)
 create mode 100644 test/invalid-buckets.test.js
 create mode 100644 test/invalid-fast.test.js

diff --git a/Makefile b/Makefile
index 3d3e066..cb0743b 100644
--- a/Makefile
+++ b/Makefile
@@ -66,6 +66,7 @@ test: | $(FAUCET) $(MORAY_TEST_ENV_FILE)
 	$(CTRUN) node test/close-handles.test.js | $(FAUCET) && \
 	$(CTRUN) node test/buckets.test.js | $(FAUCET) && \
 	$(CTRUN) node test/objects.test.js | $(FAUCET) && \
+	$(CTRUN) node test/invalid-fast.test.js | $(FAUCET) && \
 	$(CTRUN) node test/sql.test.js | $(FAUCET) && \
 	$(CTRUN) node test/integ.test.js | $(FAUCET) && \
 	$(CTRUN) node test/arrays.test.js | $(FAUCET) && \
diff --git a/package.json b/package.json
index 10b0a7d..4c532d5 100644
--- a/package.json
+++ b/package.json
@@ -12,6 +12,7 @@
 		"assert-plus": "1.0.0",
 		"bunyan": "^1.8.1",
 		"cmdutil": "^1.0.0",
+		"fast": "^2.2.2",
 		"faucet": "0.0.1",
 		"forkexec": "^1.1.0",
 		"kang": "1.0.1",
diff --git a/test/buckets.test.js b/test/buckets.test.js
index 95571f4..b20ca90 100644
--- a/test/buckets.test.js
+++ b/test/buckets.test.js
@@ -370,6 +370,18 @@ test('update bucket (versioned not ok 2 -> 1)', function (t) {
 });
 
 
+test('update bucket (bucket not found)', function (t) {
+    c.updateBucket('nonexistent', { }, function (err) {
+        t.ok(err, 'error returned');
+        if (err) {
+            t.ok(VError.hasCauseWithName(err, 'BucketNotFoundError'),
+                'BucketNotFoundError');
+        }
+        t.end();
+    });
+});
+
+
 test('create bucket bad index type', function (t) {
     c.createBucket(b, {index: {foo: 'foo'}}, function (err) {
         t.ok(err);
@@ -507,6 +519,23 @@ test('delete missing bucket', function (t) {
 });
 
 
+[ 'buckets_config', 'moray', 'search' ].forEach(function (bucket) {
+    test('delete reserved bucket: "' + bucket + '"', function (t) {
+        c.delBucket(bucket, function (err) {
+            t.ok(err, 'error returned');
+            if (err && VError.hasCauseWithName(err, 'InvalidBucketNameError')) {
+                t.ok(jsprim.endsWith(err.message,
+                    bucket + ' is not a valid bucket name'),
+                    'InvalidBucketNameError');
+            } else {
+                t.ifError(err);
+            }
+            t.end();
+        });
+    });
+});
+
+
 test('MORAY-378 - Bucket cache cleared on bucket delete', function (t) {
     vasync.pipeline({ funcs: [
         // Create the initial bucket.
diff --git a/test/cli-sanity.test.js b/test/cli-sanity.test.js
index 168d7ff..ac9eb3e 100644
--- a/test/cli-sanity.test.js
+++ b/test/cli-sanity.test.js
@@ -284,6 +284,10 @@ function runNormalSequence(t)
             runCmd([ 'morayping' ], callback);
         },
 
+        function pingDeep(_, callback) {
+            runCmd([ 'morayping', '-d' ], callback);
+        },
+
         function version(_, callback) {
             runCmd([ 'morayversion' ], callback);
         },
diff --git a/test/helper.js b/test/helper.js
index af54ac4..2f18ade 100644
--- a/test/helper.js
+++ b/test/helper.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2016, Joyent, Inc.
+ * Copyright (c) 2017, Joyent, Inc.
  */
 
 var assert = require('assert-plus');
@@ -13,6 +13,9 @@ var child = require('child_process');
 var forkexec = require('forkexec');
 var fs = require('fs');
 var jsprim = require('jsprim');
+var mod_fast = require('fast');
+var mod_net = require('net');
+var mod_url = require('url');
 var path = require('path');
 var stream = require('stream');
 var util = require('util');
@@ -54,12 +57,62 @@ function createClient(opts) {
     clientparams.log = createLogger();
 
     if (opts && opts.unwrapErrors) {
-    	clientparams.unwrapErrors = opts.unwrapErrors;
+        clientparams.unwrapErrors = opts.unwrapErrors;
     }
 
     return (moray.createClient(clientparams));
 }
 
+/*
+ * Make a Fast RPC to the Moray server.
+ *
+ * Normally tests would use the Moray client, but the client performs some
+ * sanity checks, and enforces certain behaviour. This function allows for
+ * testing how the Moray server handles bad parameters, and nonexistent
+ * endpoints.
+ *
+ * Arguments:
+ * - opts (Object):
+ *   - log, a Bunyan logger
+ *   - call, the Fast parameters to pass to rpcBufferAndCallback()
+ * - cb (Function), callback that gets passed rpcBufferAndCallback's results
+ */
+function makeFastRequest(opts, cb) {
+    assert.object(opts, 'opts');
+    assert.func(cb, 'callback');
+
+    var host, port;
+
+    if (process.env['MORAY_TEST_SERVER_REMOTE']) {
+        var parsed = mod_url.parse(process.env['MORAY_TEST_SERVER_REMOTE']);
+        host = parsed.hostname;
+        port = parsed.port;
+    } else {
+        host = '127.0.0.1';
+        port = 2020;
+    }
+
+    var socket = mod_net.connect(port, host);
+
+    socket.on('error', cb);
+
+    socket.on('connect', function () {
+        socket.removeListener('error', cb);
+
+        var client = new mod_fast.FastClient({
+            log: opts.log,
+            nRecentRequests: 100,
+            transport: socket
+        });
+
+        client.rpcBufferAndCallback(opts.call, function (err, data, ndata) {
+            client.detach();
+            socket.destroy();
+            cb(err, data, ndata);
+        });
+    });
+}
+
 function multipleServersSupported() {
     return (!process.env['MORAY_TEST_SERVER_REMOTE']);
 }
@@ -240,6 +293,7 @@ function defineStatelessTestCase(tape, func, tc) {
 ///--- Exports
 
 module.exports = {
+    makeFastRequest: makeFastRequest,
     multipleServersSupported: multipleServersSupported,
     createLogger: createLogger,
     createClient: createClient,
diff --git a/test/invalid-buckets.test.js b/test/invalid-buckets.test.js
new file mode 100644
index 0000000..94af12c
--- /dev/null
+++ b/test/invalid-buckets.test.js
@@ -0,0 +1,249 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright 2017, Joyent, Inc.
+ */
+
+var assert = require('assert-plus');
+var jsprim = require('jsprim');
+var test = require('tape');
+var vasync = require('vasync');
+var VError = require('verror');
+
+var helper = require('./helper.js');
+
+var fmt = require('util').format;
+
+///--- Globals
+
+var LOG = helper.createLogger('invalid-moray-fast');
+
+var str64 = '';
+for (var i = 0; i < 64; i++) {
+    str64 += 'a';
+}
+
+
+var VALID_BUCKET = {
+    index: { },
+    options: { version: 1 }
+};
+
+var DEFAULT_BUCKET = {
+    name: 'mybucket',
+    config: VALID_BUCKET
+};
+
+var BAD_BUCKETS = [
+    // Bad bucket names
+    {
+        name: 'moray',
+        errname: 'InvalidBucketNameError',
+        errmsg: 'is not a valid bucket name'
+    },
+    {
+        name: 'search',
+        errname: 'InvalidBucketNameError',
+        errmsg: 'is not a valid bucket name'
+    },
+    {
+        name: 'buckets_config',
+        errname: 'InvalidBucketNameError',
+        errmsg: 'is not a valid bucket name'
+    },
+    {
+        name: '_name',
+        errname: 'InvalidBucketNameError',
+        errmsg: 'is not a valid bucket name'
+    },
+    {
+        name: 'a-b',
+        errname: 'InvalidBucketNameError',
+        errmsg: 'is not a valid bucket name'
+    },
+    {
+        name: '1b',
+        errname: 'InvalidBucketNameError',
+        errmsg: 'is not a valid bucket name'
+    },
+    {
+        name: str64,
+        errname: 'InvalidBucketNameError',
+        errmsg: 'is not a valid bucket name'
+    },
+    {
+        name: '',
+        errname: 'InvocationError',
+        errmsg: 'createBucket expects "bucket" (args[0]) to be ' +
+            'a nonempty string: bucket should NOT be shorter than 1 characters'
+    },
+
+    // Bad triggers
+    {
+        config: { pre: 'hello' },
+        errname: 'InvalidBucketConfigError',
+        errmsg: 'bucket.pre should be array'
+    },
+    {
+        config: { pre: [ 'hello' ] },
+        errname: 'NotFunctionError',
+        errmsg: 'trigger not function must be [Function]'
+    },
+    {
+        config: { pre: [ '"hello"' ] },
+        errname: 'NotFunctionError',
+        errmsg: 'pre must be [Function]'
+    },
+    {
+        config: { post: 'hello' },
+        errname: 'InvalidBucketConfigError',
+        errmsg: 'bucket.post should be array'
+    },
+    {
+        config: { post: [ 'hello' ] },
+        errname: 'NotFunctionError',
+        errmsg: 'trigger not function must be [Function]'
+    },
+    {
+        config: { post: [ '"hello"' ] },
+        errname: 'NotFunctionError',
+        errmsg: 'post must be [Function]'
+    },
+
+    // Bad values for bucket.index
+    {
+        config: { index: 5 },
+        errname: 'InvalidBucketConfigError',
+        errmsg: 'bucket.index should be object'
+    },
+    {
+        config: { index: [ ] },
+        errname: 'InvalidBucketConfigError',
+        errmsg: 'bucket.index should be object'
+    },
+
+    // Bad indexes
+    {
+        config: { index: { foo: null } },
+        errname: 'InvalidBucketConfigError',
+        errmsg: 'bucket.index[\'foo\'] should be object'
+    },
+    {
+        config: { index: { foo: [] } },
+        errname: 'InvalidBucketConfigError',
+        errmsg: 'bucket.index[\'foo\'] should be object'
+    },
+    {
+        config: { index: { foo: { } } },
+        errname: 'InvalidBucketConfigError',
+        errmsg: 'bucket.index[\'foo\'] should have required property \'type\''
+    },
+    {
+        config: {
+            index: {
+               foo: { type: 'invalid' }
+            }
+        },
+        errname: 'InvalidBucketConfigError',
+        errmsg: 'bucket.index[\'foo\'].type should be ' +
+            'equal to one of the allowed values'
+    },
+    {
+        config: {
+            index: {
+                foo: {
+                    type: 'string',
+                    unique: 'yes'
+                }
+            }
+        },
+        errname: 'InvalidBucketConfigError',
+        errmsg: 'bucket.index[\'foo\'].unique should be boolean'
+    },
+    {
+        config: {
+            index: {
+                foo: {
+                    type: 'string',
+                    invalid: 'foo'
+                }
+            }
+        },
+        errname: 'InvalidBucketConfigError',
+        errmsg: 'bucket.index[\'foo\'] should NOT have additional properties'
+    },
+
+    // Bad values for bucket.options
+    {
+        config: { options: 'opts' },
+        errname: 'InvalidBucketConfigError',
+        errmsg: 'bucket.options should be object'
+    },
+    {
+        config: { options: [ ] },
+        errname: 'InvalidBucketConfigError',
+        errmsg: 'bucket.options should be object'
+    },
+
+    // Bad bucket versions
+    {
+        config: { options: { version: '2' } },
+        errname: 'InvalidBucketConfigError',
+        errmsg: 'bucket.options.version should be integer'
+    },
+    {
+        config: { options: { version: 2.2 } },
+        errname: 'InvalidBucketConfigError',
+        errmsg: 'bucket.options.version should be integer'
+    },
+    {
+        config: { options: { version: -2 } },
+        errname: 'InvalidBucketConfigError',
+        errmsg: 'bucket.options.version should be >= 0'
+    }
+];
+
+///--- Tests
+
+
+BAD_BUCKETS.forEach(function (cfg) {
+    cfg = jsprim.mergeObjects(DEFAULT_BUCKET, cfg);
+    assert.string(cfg.errname, 'errname');
+    assert.string(cfg.errmsg, 'errmsg');
+    assert.string(cfg.name, 'name');
+    assert.object(cfg.config, 'config');
+
+    test(cfg.errname + ': ' + cfg.errmsg, function (t) {
+        helper.makeFastRequest({
+            log: LOG,
+            call: {
+                rpcmethod: 'createBucket',
+                rpcargs: [ cfg.name, cfg.config, {} ],
+                maxObjectsToBuffer: 100
+            }
+        }, function (err, data, ndata) {
+            var cause;
+
+            t.ok(err, 'expected error');
+            t.deepEqual([], data, 'expected no results');
+            t.deepEqual(0, ndata, 'expected no results');
+
+            if (err) {
+                cause = VError.findCauseByName(err, cfg.errname);
+                t.ok(cause, 'expected a ' + cfg.errname);
+                if (cause && cause.message.indexOf(cfg.errmsg) !== -1) {
+                    t.pass('correct error message');
+                } else {
+                    t.equal(err.message, cfg.errmsg, 'correct error message');
+                }
+            }
+
+            t.end();
+        });
+    });
+});
+
diff --git a/test/invalid-fast.test.js b/test/invalid-fast.test.js
new file mode 100644
index 0000000..aa0b9e0
--- /dev/null
+++ b/test/invalid-fast.test.js
@@ -0,0 +1,361 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright 2017, Joyent, Inc.
+ */
+
+var assert = require('assert-plus');
+var test = require('tape');
+var vasync = require('vasync');
+var VError = require('verror');
+
+var helper = require('./helper.js');
+
+var fmt = require('util').format;
+
+///--- Globals
+
+var LOG = helper.createLogger('invalid-moray-fast');
+
+var BAD_RPCS = [
+
+    // Invalid RPC methods
+    {
+        method: 'bogusName',
+        args: [ ],
+        errname: 'FastError',
+        errmsg: 'unsupported RPC method: "bogusName"'
+    },
+
+    // Invalid PutObjects
+    {
+        method: 'putObject',
+        args: [ 'mybucket', 'mykey', [ 1, 2, 3 ], {} ],
+        errname: 'InvocationError',
+        errmsg: 'putObject expects "value" (args[2]) to be an object'
+    },
+
+    // Invalid DeleteObjects
+    {
+        method: 'delObject',
+        args: [ 'mybucket', 3041, {} ],
+        errname: 'InvocationError',
+        errmsg: 'delObject expects "key" (args[1]) to be a nonempty string'
+    },
+
+    // Invalid GetObjects
+    {
+        method: 'getObject',
+        args: [ true, 'mykey', {} ],
+        errname: 'InvocationError',
+        errmsg: 'getObject expects "bucket" (args[0]) to be a nonempty string'
+    },
+
+    // Invalid FindObjects
+    {
+        method: 'findObjects',
+        args: [ 'mybucket', [ '(a=5)' ], {} ],
+        errname: 'InvocationError',
+        errmsg: 'findObjects expects "filter" (args[1]) to be a nonempty string'
+    },
+    {
+        method: 'findObjects',
+        args: [ 'mybucket', '(a=5)', { sort: 5 } ],
+        errname: 'InvocationError',
+        errmsg: 'findObjects expects "options" (args[2]) to be ' +
+            'a valid options object: options.sort should be'
+    },
+    {
+        method: 'findObjects',
+        args: [
+            'mybucket',
+            '(a=5)',
+            { sort: { attribute: 'foo', order: 'bad' } }
+        ],
+        errname: 'InvocationError',
+        errmsg: 'options.sort.order should be equal to ' +
+            'one of the allowed values'
+    },
+
+    // Invalid ReindexObjects
+    {
+        method: 'reindexObjects',
+        args: [ 'mybucket', -20, {} ],
+        errname: 'InvocationError',
+        errmsg: 'reindexObjects expects "count" (args[1]) to be ' +
+            'a nonnegative integer'
+    },
+
+    // Invalid DeleteMany
+    {
+        method: 'deleteMany',
+        args: [ 'mybucket', '(a=5)', null ],
+        errname: 'InvocationError',
+        errmsg: 'deleteMany expects "options" (args[2]) to be ' +
+            'a valid options object'
+    },
+
+    // Invalid UpdateObjects
+    {
+        method: 'updateObjects',
+        args: [ 'mybucket', 'a=5', '(a=6)', {} ],
+        errname: 'InvocationError',
+        errmsg: 'updateObjects expects "fields" (args[1]) to be an object'
+    },
+
+    // Invalid Batches
+    {
+        method: 'batch',
+        args: [
+            { operation: 'delete', bucket: 'mybucket', key: 'mykey' },
+            {}
+        ],
+        errname: 'InvocationError',
+        errmsg: 'batch expects "requests" (args[0]) to be an array'
+    },
+    {
+        method: 'batch',
+        args: [
+            [ { operation: 'delete' } ],
+            {}
+        ],
+        errname: 'InvocationError',
+        errmsg: 'batch expects "requests" (args[0]) to be an array of ' +
+            'valid request objects: requests[0] should have ' +
+            'required property \'bucket\''
+    },
+    {
+        method: 'batch',
+        args: [
+            [
+                { operation: 'put', bucket: 'mybucket', key: 'mykey' },
+                { operation: 'invalid', bucket: 'mybucket' }
+            ],
+            {}
+        ],
+        errname: 'InvocationError',
+        errmsg: 'batch expects "requests" (args[0]) to be an array of ' +
+            'valid request objects: requests[1].operation should be ' +
+            'equal to one of the allowed values'
+    },
+
+    // Invalid CreateBuckets
+    {
+        method: 'createBucket',
+        args: [ true, { index: {} }, {} ],
+        errname: 'InvocationError',
+        errmsg: 'createBucket expects "bucket" (args[0]) to be ' +
+            'a nonempty string'
+    },
+
+    // Invalid DeleteBuckets
+    {
+        method: 'delBucket',
+        args: [ null, {} ],
+        errname: 'InvocationError',
+        errmsg: 'delBucket expects "bucket" (args[0]) to be a nonempty string'
+    },
+
+    // Invalid GetBuckets
+    {
+        method: 'getBucket',
+        args: [ null, 'mybucket' ],
+        errname: 'InvocationError',
+        errmsg: 'getBucket expects "options" (args[0]) to be ' +
+            'a valid options object'
+    },
+
+    // Invalid UpdateBuckets
+    {
+        method: 'updateBucket',
+        args: [ 'mybucket', false, {} ],
+        errname: 'InvocationError',
+        errmsg: 'updateBucket expects "config" (args[1]) to be an object'
+    },
+    {
+        method: 'updateBucket',
+        args: [ 'mybucket', {}, { no_reindex: 1 } ],
+        errname: 'InvocationError',
+        errmsg: 'updateBucket expects "options" (args[2]) to be ' +
+            'a valid options object: options.no_reindex should be boolean'
+    },
+
+    // Invalid ListBuckets
+    {
+        method: 'listBuckets',
+        args: [ [ ] ],
+        errname: 'InvocationError',
+        errmsg: 'listBuckets expects "options" (args[0]) to be ' +
+            'a valid options object'
+    },
+
+    // Invalid SQL
+    {
+        method: 'sql',
+        args: [ 'SELECT now();', null, {} ],
+        errname: 'InvocationError',
+        errmsg: 'sql expects "values" (args[1]) to be an array'
+    },
+    {
+        method: 'sql',
+        args: [ 'SELECT now();', [], { req_id: 'foo' } ],
+        errname: 'InvocationError',
+        errmsg: 'sql expects "options" (args[2]) to be ' +
+            'a valid options object: options.req_id should match format "uuid"'
+    },
+    {
+        method: 'sql',
+        args: [ 'SELECT now();', [], { timeout: -1 } ],
+        errname: 'InvocationError',
+        errmsg: 'sql expects "options" (args[2]) to be ' +
+            'a valid options object: options.timeout should be >= 0'
+    },
+
+
+    // Invalid Pings
+    {
+        method: 'ping',
+        args: [ null ],
+        errname: 'InvocationError',
+        errmsg: 'ping expects "options" (args[0]) to be ' +
+            'a valid options object: options should be object'
+    },
+    {
+        method: 'ping',
+        args: [ [] ],
+        errname: 'InvocationError',
+        errmsg: 'ping expects "options" (args[0]) to be ' +
+            'a valid options object: options should be object'
+    },
+    {
+        method: 'ping',
+        args: [ { deep: 1 } ],
+        errname: 'InvocationError',
+        errmsg: 'ping expects "options" (args[0]) to be ' +
+            'a valid options object: options.deep should be boolean'
+    },
+
+    // Invalid Versions
+    {
+        method: 'version',
+        args: [ null ],
+        errname: 'InvocationError',
+        errmsg: 'version expects "options" (args[0]) to be ' +
+           'a valid options object'
+    },
+
+    // Invalid GetTokens
+    {
+        method: 'getTokens',
+        args: [ null ],
+        errname: 'InvocationError',
+        errmsg: 'getTokens expects "options" (args[0]) to be ' +
+            'a valid options object'
+    }
+];
+
+var RPC_ARG_COUNTS = [
+    { method: 'createBucket', count: 3 },
+    { method: 'getBucket', count: 2 },
+    { method: 'listBuckets', count: 1 },
+    { method: 'updateBucket', count: 3 },
+    { method: 'delBucket', count: 2 },
+    { method: 'putObject', count: 4 },
+    { method: 'batch', count: 2 },
+    { method: 'getObject', count: 3 },
+    { method: 'delObject', count: 3 },
+    { method: 'findObjects', count: 3 },
+    { method: 'updateObjects', count: 4 },
+    { method: 'reindexObjects', count: 3 },
+    { method: 'deleteMany', count: 3 },
+    { method: 'getTokens', count: 1 },
+    { method: 'sql', count: 3 },
+    { method: 'ping', count: 1 },
+    { method: 'version', count: 1 }
+];
+
+
+///--- Tests
+
+BAD_RPCS.forEach(function (cfg) {
+    assert.string(cfg.errname, 'errname');
+    assert.string(cfg.errmsg, 'errmsg');
+    assert.string(cfg.method, 'method');
+    assert.array(cfg.args, 'args');
+
+    test(cfg.errname + ': ' + cfg.errmsg, function (t) {
+        helper.makeFastRequest({
+            log: LOG,
+            call: {
+                rpcmethod: cfg.method,
+                rpcargs: cfg.args,
+                maxObjectsToBuffer: 100
+            }
+        }, function (err, data, ndata) {
+            var cause;
+
+            t.ok(err, 'expected error');
+            t.deepEqual([], data, 'expected no results');
+            t.deepEqual(0, ndata, 'expected no results');
+
+            if (err) {
+                cause = VError.findCauseByName(err, cfg.errname);
+                t.ok(cause, 'expected a ' + cfg.errname);
+                if (cause && cause.message.indexOf(cfg.errmsg) !== -1) {
+                    t.pass('correct error message');
+                } else {
+                    t.equal(err.message, cfg.errmsg, 'correct error message');
+                }
+            }
+
+            t.end();
+        });
+    });
+});
+
+
+RPC_ARG_COUNTS.forEach(function (cfg) {
+    assert.string(cfg.method, 'method');
+    assert.number(cfg.count, 'count');
+
+    var args = [];
+    for (var i = 1; i < cfg.count; i++) {
+        args.push(i);
+    }
+
+    var msg = fmt('%s expects %d argument%s',
+        cfg.method, cfg.count, cfg.count === 1 ? '' : 's');
+
+    test(cfg.method + ' expects rcpargs.length == ' + cfg.count, function (t) {
+        helper.makeFastRequest({
+            log: LOG,
+            call: {
+                rpcmethod: cfg.method,
+                rpcargs: args,
+                maxObjectsToBuffer: 100
+            }
+        }, function (err, data, ndata) {
+            var cause;
+
+            t.ok(err, 'expected error');
+            t.deepEqual([], data, 'expected no results');
+            t.deepEqual(0, ndata, 'expected no results');
+
+            if (err) {
+                cause = VError.findCauseByName(err, 'InvocationError');
+                t.ok(cause, 'expected a ' + cfg.errname);
+                if (cause && cause.message.indexOf(cfg.errmsg) !== -1) {
+                    t.pass('correct error message');
+                } else {
+                    t.equal(msg, cause.message, 'correct error message');
+                }
+            }
+
+            t.end();
+        });
+    });
+});
-- 
2.21.0

