commit 4b12fb7aeda34ec1a22f5b7b91964cf075ba0ffa (refs/changes/79/3279/3)
Author: Julien Gilli <julien.gilli@joyent.com>
Date:   2018-02-08T12:14:55-08:00 (1 year, 8 months ago)
    
    TRITON-93 Routes are not populated consistently when provisioning new instances

diff --git a/src/vm/common/vmtest.js b/src/vm/common/vmtest.js
index 2bf8d623..38aedf89 100644
--- a/src/vm/common/vmtest.js
+++ b/src/vm/common/vmtest.js
@@ -51,9 +51,14 @@ var IMAGES_SOURCE = 'https://images.joyent.com/';
 
 exports.CURRENT_DOCKER_IMAGE_UUID = process.env['DOCKER_BASE_IMAGE_UUID'];
 exports.CURRENT_SMARTOS_UUID = '01b2c898-945f-11e1-a523-af1afbe22822';
-exports.CURRENT_UBUNTU_UUID = '71101322-43a5-11e1-8f01-cf2a3031a7f4';
+
+// ubuntu-14.04
+exports.CURRENT_UBUNTU_LX_IMAGE_UUID = '04179d8e-188a-11e7-af4a-1349e98cbd17';
+
 exports.CURRENT_UBUNTU_NAME = 'ubuntu-10.04';
 exports.CURRENT_UBUNTU_SIZE = 5120;
+exports.CURRENT_UBUNTU_UUID = '71101322-43a5-11e1-8f01-cf2a3031a7f4';
+
 
 exports.on_new_vm = function(t, uuid, payload, state, fnlist, callback)
 {
diff --git a/src/vm/lib/metadata/agent.js b/src/vm/lib/metadata/agent.js
index e340892e..786dae87 100644
--- a/src/vm/lib/metadata/agent.js
+++ b/src/vm/lib/metadata/agent.js
@@ -156,6 +156,7 @@ var path = require('path');
 var util = require('util');
 var vasync = require('vasync');
 var VM = require('/usr/vm/node_modules/VM');
+var vmload = require('/usr/vm/node_modules/vmload');
 var ZWatch = require('./zwatch');
 
 var sdc_fields = [
@@ -341,7 +342,26 @@ MetadataAgent.prototype.createZoneLog = function (type, zonename) {
     return (self.zlog[zonename]);
 };
 
-MetadataAgent.prototype.updateZone = function updateZone(zonename, callback) {
+/**
+ * Update the zones cache for the zone with name "zonename", and call "callback"
+ * when done.
+ *
+ * @param zonename {String} the name of the zone for which to update the cache
+ * @param opts {Object} an object with the following properties:
+ *   - forceReload {Boolean} if true, bypasses the cache and always reload that
+ *     zone's information from disk. False by default.
+ * @param callback {Function} a function called when the operation is complete.
+ *   The signature of that function is callback(err), where "err" is an Error
+ *   object that represents the cause of failure if updating the zone cache
+ *   failed.
+ */
+MetadataAgent.prototype.updateZone =
+function updateZone(zonename, opts, callback) {
+    assert.string(zonename, 'zonename');
+    assert.object(opts, 'opts');
+    assert.optionalBool(opts.forceReload, 'opts.forceReload');
+    assert.func(callback, 'callback');
+
     var self = this;
     var log = self.log;
 
@@ -349,6 +369,11 @@ MetadataAgent.prototype.updateZone = function updateZone(zonename, callback) {
     assert.func(callback, 'callback');
 
     function shouldLoad(cb) {
+        if (opts.forceReload) {
+            cb(null, true);
+            return;
+        }
+
         if (!self.zones.hasOwnProperty(zonename)) {
             // don't have a cache, load this guy
             log.info({zonename: zonename},
@@ -357,40 +382,51 @@ MetadataAgent.prototype.updateZone = function updateZone(zonename, callback) {
             return;
         }
 
-        // We do have a cached version, we'll reload only if timestamp of the
-        // XML file changed. The vmadm operations we care about will "touch"
-        // this file to update the last_modified if they don't change it
-        // directly.
-        fs.stat('/etc/zones/' + zonename + '.xml', function (err, stats) {
-            var old_mtime;
-
-            if (err && err.code === 'ENOENT') {
-                // VM has disappeared, purge from cache
-                self.purgeZoneCache(zonename);
-                cb(null, false);
-                return;
-            } else if (err) {
-                log.error({err: err, zonename: zonename},
-                    'cannot fs.stat(), reloading');
-                cb(err);
-                return;
-            }
+        // We do have a cached version, we'll reload only if its last modified
+        // timestamp changed.
+        vmload.getLastModified(zonename, path.join('/zones', zonename), log,
+            function onLastModifiedLoaded(get_last_mod_err, last_modified_iso) {
+                var old_mtime_iso;
 
-            // we just did a successful stat, we really should have
-            // self.zones[zonename]
-            assert.object(self.zones[zonename], 'self.zones[' + zonename + ']');
+                if (get_last_mod_err) {
+                    log.error({
+                        err: get_last_mod_err,
+                        zonename: zonename
+                    }, 'Error when getting last_modified for zone');
+                    // We couldn't find the last modified time for this zone,
+                    // the VM probably disappeared, so we're removing it from
+                    // the cache.
+                    self.purgeZoneCache(zonename);
+                    cb(null, false);
+                    return;
+                }
 
-            old_mtime = (new Date(self.zones[zonename].last_modified));
-            if (stats.mtime.getTime() > old_mtime.getTime()) {
-                log.info({zonename: zonename},
-                    'last_modified was updated, reloading');
-                cb(null, true);
-                return;
-            }
+                // We just retrieved the last modified time for the zone, which
+                // means it exists, so we really should have
+                // self.zones[zonename],
+                assert.object(self.zones[zonename],
+                    'self.zones[' + zonename + ']');
+
+                old_mtime_iso = self.zones[zonename].last_modified;
+                assert.string(old_mtime_iso, 'old_mtime_iso');
+                assert.string(last_modified_iso, 'last_modified_iso');
+
+                log.info({
+                    old_mtime_ms: old_mtime_iso,
+                    last_modified_ms: last_modified_iso,
+                    zonename: zonename
+                }, 'old last_modified vs newly-loaded last_modifed for zone');
+
+                if (last_modified_iso > old_mtime_iso) {
+                    log.info({zonename: zonename},
+                        'last_modified was updated, reloading');
+                    cb(null, true);
+                    return;
+                }
 
-            log.trace('using cache for: ' + zonename);
-            cb(null, false);
-        });
+                log.trace('using cache for: ' + zonename);
+                cb(null, false);
+            });
     }
 
     shouldLoad(function (err, load) {
@@ -670,7 +706,7 @@ function handleZoneCreated(zonename) {
     function _dummyCb() {
     }
 
-    self.updateZone(zonename, function (error) {
+    self.updateZone(zonename, {}, function (error) {
         if (error) {
             self.log.error({err: error}, 'Error updating '
                 + 'attributes: ' + error.message);
@@ -1252,7 +1288,7 @@ MetadataAgent.prototype.makeMetadataHandler = function (zone, socket) {
                 // that depends on it, please add a note about that here
                 // otherwise expect it will be removed on you sometime.
                 if (want === 'nics' && vmobj.hasOwnProperty('nics')) {
-                    self.updateZone(zone, function (error) {
+                    self.updateZone(zone, {}, function (error) {
                         if (error) {
                             // updating our cache for this VM failed, so we'll
                             // use the existing data.
@@ -1274,7 +1310,7 @@ MetadataAgent.prototype.makeMetadataHandler = function (zone, socket) {
                     // reload metadata trying to get the new ones w/o zone
                     // reboot. To ensure these are fresh we always run
                     // updateZone which reloads the data if stale.
-                    self.updateZone(zone, function (error) {
+                    self.updateZone(zone, {}, function (error) {
                         if (error) {
                             // updating our cache for this VM failed, so we'll
                             // use the existing data.
@@ -1295,7 +1331,7 @@ MetadataAgent.prototype.makeMetadataHandler = function (zone, socket) {
                     && vmobj.hasOwnProperty('tmpfs')) {
                     // We want tmpfs to reload the cache right away because we
                     // might be depending on a /etc/vfstab update
-                    self.updateZone(zone, function (error) {
+                    self.updateZone(zone, {}, function (error) {
                         if (error) {
                             // updating our cache for this VM failed, so we'll
                             // use the existing data.
@@ -1315,7 +1351,31 @@ MetadataAgent.prototype.makeMetadataHandler = function (zone, socket) {
 
                     var vmRoutes = [];
 
-                    self.updateZone(zone, function (error) {
+                    /*
+                     * Always reload the information about the zone, including
+                     * its routes, so that lxinit can have the most up to date
+                     * information about them when it sets static routes. This
+                     * should not have a significant performance impact since
+                     * the sdc:routes metadata information is queried only once
+                     * at boot time, and we don't expect users to query that
+                     * information frequently. Using the last modified time of
+                     * the zones cache to compare it with the last modified time
+                     * of the routes.json zone configuration file would not
+                     * allow us to determine when to use the cache and when to
+                     * reload the zone's information because with node v0.10.x,
+                     * which is the version used by vmadm, fs.stat's output
+                     * resolution is 1 second. Any change to the routes
+                     * information happening in the same second as the previous
+                     * change to a zone configuration would not trigger a
+                     * reload. We could write a binary add-on to handle that,
+                     * but it seems it would introduce a lot of complexity for
+                     * no significant benefit. Hopefully we can move to node
+                     * v0.12.x or later at some point and rely on a better
+                     * resolution for fs.*stat APIs.
+                     */
+                    self.updateZone(zone, {
+                        forceReload: true
+                    }, function (error) {
                         if (error) {
                             // updating our cache for this VM failed, so we'll
                             // use the existing data.
diff --git a/src/vm/node_modules/vmload/index.js b/src/vm/node_modules/vmload/index.js
index 16476b2f..c8ab9a92 100644
--- a/src/vm/node_modules/vmload/index.js
+++ b/src/vm/node_modules/vmload/index.js
@@ -1535,6 +1535,7 @@ function loadZonexmlObjects(uuid, cache, options, callback)
 }
 
 module.exports = {
+    getLastModified: getLastModified,
     getVmobj: getVmobj,
     getVmobjs: getVmobjs,
     getZoneData: getZoneData
diff --git a/src/vm/tests/test-routes.js b/src/vm/tests/test-routes-joyent-minimal.js
similarity index 99%
rename from src/vm/tests/test-routes.js
rename to src/vm/tests/test-routes-joyent-minimal.js
index 3fa231c2..44b4e8d8 100644
--- a/src/vm/tests/test-routes.js
+++ b/src/vm/tests/test-routes-joyent-minimal.js
@@ -1,6 +1,6 @@
-// Copyright 2017 Joyent, Inc.
+// Copyright 2018 Joyent, Inc.
 //
-// Tests for specifying static routes
+// Tests for specifying static routes in joyent-minimal zones
 //
 
 var assert = require('assert');
@@ -30,7 +30,7 @@ var INVALID_NIC = 'Route gateway: "%s" '
 var INVALID_VAL = 'Invalid value(s) for: %s';
 
 var payload = {
-    alias: 'test-routes-' + process.pid,
+    alias: 'test-routes-joyent-minimal' + process.pid,
     autoboot: false,
     brand: 'joyent-minimal',
     do_not_inventory: true
diff --git a/src/vm/tests/test-routes-lx.js b/src/vm/tests/test-routes-lx.js
new file mode 100644
index 00000000..b838e2b5
--- /dev/null
+++ b/src/vm/tests/test-routes-lx.js
@@ -0,0 +1,119 @@
+// Copyright 2018 Joyent, Inc.
+//
+// Tests for specifying static routes in LX zones
+//
+
+var async = require('/usr/node/node_modules/async');
+var cp = require('child_process');
+var format = require('util').format;
+var VM = require('/usr/vm/node_modules/VM');
+var vmtest = require('../common/vmtest.js');
+
+// this puts test stuff in global, so we need to tell jsl about that:
+/* jsl:import ../node_modules/nodeunit-plus/index.js */
+require('nodeunit-plus');
+
+var PAYLOAD_TEMPLATE = {
+    alias: 'test-routes-lx' + process.pid,
+    brand: 'lx',
+    do_not_inventory: true,
+    kernel_version: '3.13.0'
+};
+
+test('setting custom static routes for LX branded zones', function(t) {
+    var state = {
+        brand: 'lx'
+    };
+    var vm;
+
+    var routes = {
+        '172.20.42.0/24': '172.19.1.1',
+        '172.22.2.0/24': '172.19.1.1'
+    };
+
+    var expectedRoutesInZone = {
+        '172.19.1.0': '0.0.0.0',
+        '172.20.42.0': '172.19.1.1',
+        '172.22.2.0': '172.19.1.1'
+    };
+
+    var customRoutesVmPayload = {
+        archive_on_delete: true,
+        autoboot: true,
+        nics: [
+            { nic_tag: 'admin',
+              ip: '172.19.1.2',
+              netmask: '255.255.255.0' }
+        ],
+        maintain_resolvers: true,
+        nowait: false,
+        routes: routes
+    };
+
+    for (var k in PAYLOAD_TEMPLATE) {
+        customRoutesVmPayload[k] = PAYLOAD_TEMPLATE[k];
+    }
+
+    vmtest.on_new_vm(t, vmtest.CURRENT_UBUNTU_LX_IMAGE_UUID,
+        customRoutesVmPayload, state, [
+        function waitVmRunning(cb) {
+            var MAX_NB_TRIES = 20;
+            var nbTries = 0;
+            var RETRY_PERIOD_MS = 5000;
+
+            setTimeout(function checkVmRunning() {
+                ++nbTries;
+
+                VM.load(state.uuid, function (loadErr, vmObj) {
+                    t.ifError(loadErr,
+                        'loading VM after create should succeed');
+                    if (vmObj && vmObj.state === 'running') {
+                        vm = vmObj;
+                        cb();
+                    } else if (vmObj.state === 'failed' ||
+                        vmObj.state === 'destroyed') {
+                        cb(new Error('test VM in state ' + vmObj.state))
+                    } else {
+                        if (nbTries >= MAX_NB_TRIES) {
+                            cb(new Error('Reached max number of retries'));
+                        } else {
+                            setTimeout(checkVmRunning, RETRY_PERIOD_MS);
+                        }
+                    }
+                });
+            }, RETRY_PERIOD_MS);
+        },
+
+        function checkRoutes(cb) {
+            cp.exec(format('/usr/sbin/zlogin %s /bin/netstat -rn |' +
+                'egrep -v \'Destination|routing\' | awk \'{ print $1,$2 }\'',
+                    vm.uuid), function (err, stdout, stderr) {
+                        if (err) {
+                            cb(err);
+                            return;
+                        }
+
+                        var actualRoutes = {};
+                        stdout.split(/\n/g).forEach(function (line) {
+                            var parts = line.split(' ');
+                            if (parts[0] == "" || parts[0] == "127.0.0.1") {
+                                return;
+                            }
+
+                            actualRoutes[parts[0]] = parts[1];
+                        });
+
+                        t.deepEqual(actualRoutes, expectedRoutesInZone,
+                            'routes in zone should be ' +
+                                JSON.stringify(expectedRoutesInZone) +
+                                ' and are: ' + JSON.stringify(actualRoutes));
+
+                        cb();
+                    });
+        }
+
+    ], function (err) {
+        t.ifError(err, 'test should not have encountered any error');
+        return t.end();
+    });
+});
