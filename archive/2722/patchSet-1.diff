commit e6c1904fc4267886e11e6903a18600e32b4d0b9d (refs/changes/22/2722/1)
Author: Patrick Mooney <pmooney@pfmooney.com>
Date:   2017-10-04T23:40:47+00:00 (2 years ago)
    
    OS-6376 want eventfd kernel API helpers

diff --git a/usr/src/uts/common/brand/lx/sys/lx_misc.h b/usr/src/uts/common/brand/lx/sys/lx_misc.h
index 19c50b9151..905c46e516 100644
--- a/usr/src/uts/common/brand/lx/sys/lx_misc.h
+++ b/usr/src/uts/common/brand/lx/sys/lx_misc.h
@@ -119,8 +119,6 @@ extern void lx_vsyscall_enter(proc_t *, klwp_t *, int);
 
 extern void lx_check_strict_failure(lx_lwp_data_t *);
 
-extern boolean_t lx_is_eventfd(file_t *);
-
 #endif
 
 #ifdef	__cplusplus
diff --git a/usr/src/uts/common/brand/lx/syscall/lx_aio.c b/usr/src/uts/common/brand/lx/syscall/lx_aio.c
index c821e72538..c4386bfb1b 100644
--- a/usr/src/uts/common/brand/lx/syscall/lx_aio.c
+++ b/usr/src/uts/common/brand/lx/syscall/lx_aio.c
@@ -113,6 +113,7 @@
 #include <sys/sysmacros.h>
 #include <sys/sdt.h>
 #include <sys/procfs.h>
+#include <sys/file.h>
 #include <sys/eventfd.h>
 
 #include <sys/lx_brand.h>
@@ -454,22 +455,12 @@ lx_io_finish_op(lx_io_ctx_t *cp, lx_io_elem_t *ep, boolean_t do_event)
 
 	/* Update the eventfd if necessary */
 	if (do_resfd) {
-		vnode_t *vp = resfp->f_vnode;
 		uint64_t val = 1;
 
 		set_active_fd(resfd);
-
 		if (do_event) {
-			/*
-			 * Eventfd notifications from AIO are special in that
-			 * they are not expected to block. This interface allows
-			 * the eventfd value to reach (but not cross) the
-			 * overflow value.
-			 */
-			(void) VOP_IOCTL(vp, EVENTFDIOC_POST, (intptr_t)&val,
-			    FKIOCTL, resfp->f_cred, NULL, NULL);
+			VERIFY0(eventfd_fp_post(resfp, val));
 		}
-
 		releasef(resfd);
 	}
 }
@@ -967,7 +958,7 @@ lx_io_submit(lx_aio_context_t cid, const long nr, uintptr_t **bpp)
 
 		if (cb.lxiocb_flags & LX_IOCB_FLAG_RESFD) {
 			if ((resfp = getf(cb.lxiocb_resfd)) == NULL ||
-			    !lx_is_eventfd(resfp)) {
+			    !eventfd_fp_check(resfp)) {
 				err = EINVAL;
 				releasef(cb.lxiocb_fd);
 				if (resfp != NULL)
diff --git a/usr/src/uts/common/brand/lx/syscall/lx_eventfd.c b/usr/src/uts/common/brand/lx/syscall/lx_eventfd.c
index 21205aa18a..c81cf40ee9 100644
--- a/usr/src/uts/common/brand/lx/syscall/lx_eventfd.c
+++ b/usr/src/uts/common/brand/lx/syscall/lx_eventfd.c
@@ -23,19 +23,6 @@
 #include <sys/vnode.h>
 #include <sys/eventfd.h>
 
-static major_t eventfd_major = 0;
-
-/* io_submit uses this to validate control block eventfd descriptors */
-boolean_t
-lx_is_eventfd(file_t *fp)
-{
-	vnode_t *vp = fp->f_vnode;
-
-	if (vp->v_type == VCHR && getmajor(vp->v_rdev) == eventfd_major)
-		return (B_TRUE);
-	return (B_FALSE);
-}
-
 long
 lx_eventfd2(uint_t initval, int flags)
 {
@@ -97,8 +84,6 @@ lx_eventfd2(uint_t initval, int flags)
 			goto error;
 	}
 
-	eventfd_major = getmajor(vp->v_rdev);
-
 	fp->f_vnode = vp;
 	mutex_exit(&fp->f_tlock);
 	setf(fd, fp);
diff --git a/usr/src/uts/common/io/eventfd.c b/usr/src/uts/common/io/eventfd.c
index e26cdfc78f..c0dfd135bc 100644
--- a/usr/src/uts/common/io/eventfd.c
+++ b/usr/src/uts/common/io/eventfd.c
@@ -20,13 +20,13 @@
 
 #include <sys/ddi.h>
 #include <sys/sunddi.h>
-#include <sys/eventfd.h>
 #include <sys/conf.h>
 #include <sys/vmem.h>
 #include <sys/sysmacros.h>
 #include <sys/filio.h>
 #include <sys/stat.h>
 #include <sys/file.h>
+#include <sys/eventfd.h>
 
 struct eventfd_state;
 typedef struct eventfd_state eventfd_state_t;
@@ -50,6 +50,17 @@ static vmem_t		*eventfd_minor;		/* minor number arena */
 static void		*eventfd_softstate;	/* softstate pointer */
 static eventfd_state_t	*eventfd_state;		/* global list of state */
 
+/* Cache the major number the driver is attached to. */
+static major_t		eventfd_major = DDI_MAJOR_T_NONE;
+
+/*
+ * Some kernel-internal notifications (like from LX AIO) are special in that
+ * they are not expected to block. This private ioctl permits the caller to
+ * post to an eventfd handle, allowing its value to reach (but not cross) the
+ * overflow value.
+ */
+#define	EVENTFDIOC_POST	(EVENTFDIOC | 2)
+
 /*ARGSUSED*/
 static int
 eventfd_open(dev_t *devp, int flag, int otyp, cred_t *cred_p)
@@ -287,10 +298,7 @@ eventfd_ioctl(dev_t dev, int cmd, intptr_t arg, int md, cred_t *cr, int *rv)
 		return (0);
 
 	case EVENTFDIOC_POST:
-		/*
-		 * This ioctl is expected to be kernel-internal, used only by
-		 * the AIO emulation in LX.
-		 */
+		/* This ioctl is expected to be kernel-internal. */
 		if ((md & FKIOCTL) == 0) {
 			break;
 		}
@@ -337,6 +345,33 @@ eventfd_close(dev_t dev, int flag, int otyp, cred_t *cred_p)
 	return (0);
 }
 
+boolean_t
+eventfd_fp_check(file_t *fp)
+{
+	vnode_t *vp = fp->f_vnode;
+
+	if (vp->v_type == VCHR && getmajor(vp->v_rdev) == eventfd_major &&
+	    eventfd_major != DDI_MAJOR_T_NONE) {
+		return (B_TRUE);
+	}
+
+	return (B_FALSE);
+}
+
+int
+eventfd_fp_post(file_t *fp, uint64_t val)
+{
+	vnode_t *vp = fp->f_vnode;
+
+	if (!eventfd_fp_check(fp)) {
+		return (EBADF);
+	}
+
+	(void) VOP_IOCTL(vp, EVENTFDIOC_POST, (intptr_t)&val, FKIOCTL,
+	    fp->f_cred, NULL, NULL);
+	return (0);
+}
+
 static int
 eventfd_attach(dev_info_t *devi, ddi_attach_cmd_t cmd)
 {
@@ -370,6 +405,7 @@ eventfd_attach(dev_info_t *devi, ddi_attach_cmd_t cmd)
 
 	ddi_report_dev(devi);
 	eventfd_devi = devi;
+	eventfd_major = ddi_driver_major(devi);
 
 	eventfd_minor = vmem_create("eventfd_minor", (void *)EVENTFDMNRN_CLONE,
 	    UINT32_MAX - EVENTFDMNRN_CLONE, 1, NULL, NULL, NULL, 0,
@@ -400,6 +436,7 @@ eventfd_detach(dev_info_t *dip, ddi_detach_cmd_t cmd)
 
 	ddi_remove_minor_node(eventfd_devi, NULL);
 	eventfd_devi = NULL;
+	eventfd_major = DDI_MAJOR_T_NONE;
 
 	ddi_soft_state_fini(&eventfd_softstate);
 	mutex_exit(&eventfd_lock);
diff --git a/usr/src/uts/common/sys/eventfd.h b/usr/src/uts/common/sys/eventfd.h
index b64a101348..17d597b8e5 100644
--- a/usr/src/uts/common/sys/eventfd.h
+++ b/usr/src/uts/common/sys/eventfd.h
@@ -47,13 +47,6 @@ typedef uint64_t eventfd_t;
 #define	EVENTFDIOC		(('e' << 24) | ('f' << 16) | ('d' << 8))
 #define	EVENTFDIOC_SEMAPHORE	(EVENTFDIOC | 1)	/* toggle sem state */
 
-/*
- * Kernel-internal method to write to eventfd while bypassing overflow limits,
- * therefore avoiding potential to block as well.  This is used to fulfill AIO
- * behavior in LX related to eventfd notification.
- */
-#define	EVENTFDIOC_POST		(EVENTFDIOC | 2)
-
 #ifndef _KERNEL
 
 extern int eventfd(unsigned int, int);
@@ -62,6 +55,9 @@ extern int eventfd_write(int, eventfd_t);
 
 #else
 
+extern boolean_t eventfd_fp_check(file_t *);
+extern int eventfd_fp_post(file_t *, uint64_t);
+
 #define	EVENTFDMNRN_EVENTFD	0
 #define	EVENTFDMNRN_CLONE	1
 #define	EVENTFD_VALMAX		(ULLONG_MAX - 1ULL)
diff --git a/usr/src/uts/intel/lx_brand/Makefile b/usr/src/uts/intel/lx_brand/Makefile
index 4eff474a49..b61d272b75 100644
--- a/usr/src/uts/intel/lx_brand/Makefile
+++ b/usr/src/uts/intel/lx_brand/Makefile
@@ -69,7 +69,7 @@ AS_INC_PATH	+= -I$(UTSBASE)/i86pc/genassym/$(OBJS_DIR)
 CFLAGS		+= $(CCVERBOSE)
 
 LDFLAGS		+= -dy -Nexec/elfexec -Nfs/fifofs -Nfs/sockfs -Ndrv/ip \
-		    -Nfs/zfs -Nmisc/klmmod -Nsys/sysacct
+		    -Nfs/zfs -Nmisc/klmmod -Nsys/sysacct -Nio/eventfd
 
 #
 # For now, disable these lint checks; maintainers should endeavor
