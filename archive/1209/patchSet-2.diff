commit 23a5df6baf448a8edf3f90d487ecb796f192f3aa (refs/changes/09/1209/2)
Author: Todd Whiteman <todd.whiteman@joyent.com>
Date:   2017-01-09T11:06:33-08:00 (2 years, 9 months ago)
    
    DOCKER-929 Support the docker v2.2 manifest format

diff --git a/docs/api/commands/build.md b/docs/api/commands/build.md
index 5d0ae8d..b774f4a 100644
--- a/docs/api/commands/build.md
+++ b/docs/api/commands/build.md
@@ -118,8 +118,7 @@ There should be informational output of the reason for failure output to
     $ docker build .
     Uploading context 10240 bytes
     Step 1 : FROM busybox
-    Pulling repository busybox
-     ---> e9aa60c60128MB/2.284 MB (100%) endpoint: https://cdn-registry-1.docker.io/v1/
+     ---> e9aa60c60128MB
     Step 2 : RUN ls -lh /
      ---> Running in 9c9e81692ae9
     total 24
@@ -296,34 +295,10 @@ unique to Triton.
 ### Docker build step divergence:
 
 * `ADD` with remote URL is unimplemented.
-* `ADD` with wildcard is unimplemented.
-* `image layers` are only created at the end of a successful build (instead of
-  after a successful instruction).
 * the build container is reused for each build step (instead of creating a new
   container)
 
-### Docker build multiple registry divergence:
-
-In Triton SDC Docker, the built image cannot reference images between two
-different registries.
-
-For example, this build would fail as it generates an image without a tag and
-thus the generated image is assigned a default registry of *docker.io* - and you
-cannot have images referencing two registries *docker.io* and *quay.io*:
-
-```
-    $ echo -e 'FROM quay.io/user/image\nLABEL key=val' | docker build -
-    ... build fails
-```
-
-the workaround would be to tag the image with a *quay.io* registry tag:
-
-```
-    $ echo -e 'FROM quay.io/user/image\nLABEL key=val' | docker build -t quay.io/user/othername -
-    ... build successful
-```
-
-
 ## Related
 
-- Insert a list of related Docker and CloudAPI methods here
+- [`docker commit`](../commands/commit.md)
+- [`docker images`](../commands/images.md)
diff --git a/docs/api/commands/commit.md b/docs/api/commands/commit.md
index 32781f4..2230365 100644
--- a/docs/api/commands/commit.md
+++ b/docs/api/commands/commit.md
@@ -1,19 +1,83 @@
 # commit
 
-## Divergence
+    Usage: docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]
+
+    Create a new image from a container's changes
+
+      -a, --author=""     Author (e.g., "John Hannibal Smith <hannibal@a-team.com>")
+      -c, --change=[]     Apply specified Dockerfile instructions while committing the image
+      --help              Print usage
+      -m, --message=""    Commit message
+      -p, --pause=true    Pause container during commit
+
+It can be useful to commit a container's file changes or settings into a new
+image. This allows you debug a container by running an interactive shell, or to
+export a working dataset to another server. Generally, it is better to use
+Dockerfiles to manage your images in a documented and maintainable way.
+
+The commit operation will not include any data contained in
+volumes mounted inside the container.
+
+By default, the container being committed and its processes will be paused
+while the image is committed. This reduces the likelihood of encountering data
+corruption during the process of creating the commit.  If this behavior is
+undesired, set the `--pause` option to false.
+
+The `--change` option will apply `Dockerfile` instructions to the image that is
+created.  Supported `Dockerfile` instructions:
+`CMD`|`ENTRYPOINT`|`ENV`|`EXPOSE`|`LABEL`|`ONBUILD`|`USER`|`VOLUME`|`WORKDIR`
+
+## Commit a container
 
-Commit works the same in Triton SDC Docker and Docker Inc, except for below caveat:
+    $ docker ps
+    ID                  IMAGE               COMMAND             CREATED             STATUS              PORTS
+    c3f279d17e0a        ubuntu:12.04        /bin/bash           7 days ago          Up 25 hours
+    197387f1b436        ubuntu:12.04        /bin/bash           7 days ago          Up 25 hours
+    $ docker commit c3f279d17e0a  svendowideit/testimage:version3
+    f5283438590d
+    $ docker images
+    REPOSITORY                        TAG                 ID                  CREATED             SIZE
+    svendowideit/testimage            version3            f5283438590d        16 seconds ago      335.7 MB
 
- * in Triton SDC Docker, an image cannot have tags that reference two different
-   registries. Example:
+## Commit a container with new configurations
+
+    $ docker ps
+    ID                  IMAGE               COMMAND             CREATED             STATUS              PORTS
+    c3f279d17e0a        ubuntu:12.04        /bin/bash           7 days ago          Up 25 hours
+    197387f1b436        ubuntu:12.04        /bin/bash           7 days ago          Up 25 hours
+    $ docker inspect -f "{{ .Config.Env }}" c3f279d17e0a
+    [HOME=/ PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin]
+    $ docker commit --change "ENV DEBUG true" c3f279d17e0a  svendowideit/testimage:version3
+    f5283438590d
+    $ docker inspect -f "{{ .Config.Env }}" f5283438590d
+    [HOME=/ PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin DEBUG=true]
+
+## Commit a container with new `CMD` and `EXPOSE` instructions
+
+    $ docker ps
+    ID                  IMAGE               COMMAND             CREATED             STATUS              PORTS
+    c3f279d17e0a        ubuntu:12.04        /bin/bash           7 days ago          Up 25 hours
+    197387f1b436        ubuntu:12.04        /bin/bash           7 days ago          Up 25 hours
+
+    $ docker commit --change='CMD ["apachectl", "-DFOREGROUND"]' -c "EXPOSE 80" c3f279d17e0a  svendowideit/testimage:version4
+    f5283438590d
+
+    $ docker run -d svendowideit/testimage:version4
+    89373736e2e7f00bc149bd783073ac43d0507da250e999f3f1036e0db60817c0
+
+    $ docker ps
+    ID                  IMAGE               COMMAND                 CREATED             STATUS              PORTS
+    89373736e2e7        testimage:version4  "apachectl -DFOREGROU"  3 seconds ago       Up 2 seconds        80/tcp
+    c3f279d17e0a        ubuntu:12.04        /bin/bash               7 days ago          Up 25 hours
+    197387f1b436        ubuntu:12.04        /bin/bash               7 days ago          Up 25 hours
+
+## Divergence
 
-    ```
-        $ docker run -d busybox sh -c "touch /newfile.txt && sleep 86400"
-        123456789
-        $ docker commit 123456789 tagname  (okay, same registry - 'docker.io')
-        $ docker commit 123456789 quay.io/user/tagname   (different registry - fails)
-    ```
+There is no known divergence between the Triton SDC Docker and Docker Inc.
+implementations of this method. Please contact Joyent support or file a ticket
+if you discover any.
 
 ## Related
 
-- Insert a list of related Docker and CloudAPI methods here
+- [`docker build`](../commands/build.md)
+- [`docker images`](../commands/images.md)
diff --git a/docs/api/commands/images.md b/docs/api/commands/images.md
index 9605320..fe37f61 100644
--- a/docs/api/commands/images.md
+++ b/docs/api/commands/images.md
@@ -127,4 +127,5 @@ if you discover any.
 
 - [`docker inspect`](../commands/inspect.md)
 - [`docker history`](../commands/history.md)
+- [`docker pull`](../commands/pull.md)
 - [`docker rmi`](../commands/rmi.md)
diff --git a/docs/api/commands/pull.md b/docs/api/commands/pull.md
index 9d9277c..0bea953 100644
--- a/docs/api/commands/pull.md
+++ b/docs/api/commands/pull.md
@@ -44,8 +44,6 @@ use `docker pull`:
 `docker pull -a` and `--disable-content-trust=true` are currently unsupported.
 Follow [DOCKER-531](http://smartos.org/bugview/DOCKER-531) for updates.
 
-Identifying a repo version by digest is not supported at this time. Use tag instead.
-
 The first status line from a `docker pull` shows a UUID:
 
     $ docker pull busybox
diff --git a/docs/api/divergence.md b/docs/api/divergence.md
index 6028f47..adb4507 100644
--- a/docs/api/divergence.md
+++ b/docs/api/divergence.md
@@ -111,11 +111,7 @@ expect it to get shorter by the day:
 ## Images and private registries
 
 SDC Docker supports the integration with Docker Hub and third party registries through
-Docker's Registry v1 and v2 API. The use of the short or long Image ID may not uniquely
-identify an image if images of the same ID exist in more than one repo. To work around
-this Registry API limitation in such rare case, use the repo, image and tag name in
-the image management API methods (e.g. `docker pull`, `docker inspect`) instead of
-the Image ID.
+Docker's Registry v2 API (the deprecated v1 API is not supported).
 
 ### Container Logging
 
diff --git a/docs/api/features/repos.md b/docs/api/features/repos.md
index c1ce8be..def19a7 100644
--- a/docs/api/features/repos.md
+++ b/docs/api/features/repos.md
@@ -4,9 +4,11 @@ SDC-Docker supports the use of Docker images maintained in the following registr
 
 - Docker Hub's public registry
 - Docker Hub's private registry
-- Self-hosted v1 and v2 Docker registry, including Docker Trusted Registry
-- quay.io v1 Docker registry
-- jFrog Artifactory v1 and v2 Docker registry
+- Self-hosted Docker registry, including Docker Trusted Registry
+- quay.io Docker registry
+- jFrog Artifactory Docker registry
+
+Note that Triton sdc-docker only supports v2 registries.
 
 You can connect to multiple registries at the same time and pull images from them
 without having to switch from one to another.
diff --git a/etc/scratch_image.json b/etc/scratch_image.json
index c8c4363..9e4f0a9 100644
--- a/etc/scratch_image.json
+++ b/etc/scratch_image.json
@@ -49,11 +49,14 @@
         "MacAddress": "",
         "OnBuild": null
     },
-    "created": "2015-12-01T12:00:00.000Z",
-    "docker_version": "1.9.0",
-    "id": "0000000000007363726174636800aeee14d7eabd60b564604d05000000000000",
+    "created": "2016-11-09T12:00:00.000Z",
+    "docker_version": "1.12.2",
     "os": "linux",
-    "parent": "",
-    "size": 0,
-    "virtual_size": 0
+    "size": 1024,
+    "rootfs": {
+        "type": "layers",
+        "diff_ids": [
+            "sha256:5f70bf18a086007016e948b04aed3b82103a36bea41755b6cddfaf10ace3c6ef"
+        ]
+    }
 }
diff --git a/etc/scratch_image.manifest b/etc/scratch_image.manifest
new file mode 100644
index 0000000..a460277
--- /dev/null
+++ b/etc/scratch_image.manifest
@@ -0,0 +1,16 @@
+{
+    "schemaVersion": 2,
+    "mediaType": "application/vnd.docker.distribution.manifest.v2+json",
+    "config": {
+        "mediaType": "application/vnd.docker.container.image.v1+json",
+        "size": 1533,
+        "digest": "sha256:3a97ef6fc490929f6a0b666cb21e12796067f4c8169fc0dd4d6a41dc2151c8ca"
+    },
+    "layers": [
+        {
+            "mediaType": "application/vnd.docker.image.rootfs.diff.tar.gzip",
+            "size": 32,
+            "digest": "sha256:a3ed95caeb02ffe68cdd9fd84406680ae93d633cb16422d00e8a7c22955b46d4"
+        }
+    ]
+}
diff --git a/lib/backends/sdc/build.js b/lib/backends/sdc/build.js
index 7a33c1c..1ce8eca 100644
--- a/lib/backends/sdc/build.js
+++ b/lib/backends/sdc/build.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2016, Joyent, Inc.
+ * Copyright (c) 2017, Joyent, Inc.
  *
  * Overview: Build an image, given a build context (tarball).
  */
@@ -16,12 +16,15 @@ var stream = require('stream');
 
 var assert = require('assert-plus');
 var drc = require('docker-registry-client');
+var jsprim = require('jsprim');
+var imgmanifest = require('imgmanifest');
 var LineStream = require('lstream');
 var once = require('once');
 var vasync = require('vasync');
 
 var common = require('../../common');
 var errors = require('../../../lib/errors');
+var ImageV2 = require('../../models/image-v2');
 var images = require('./images');
 var utils = require('./utils');
 
@@ -30,28 +33,6 @@ var utils = require('./utils');
 //---- globals
 
 
-/**
- * Return an image object in the docker inspect format.
- */
-function getImageInInspectFormat(dockerId, opts, callback) {
-    assert.string(dockerId, 'dockerId');
-    assert.object(opts, 'opts');
-    assert.string(opts.index_name, 'opts.index_name');
-    assert.object(opts.log, 'opts.log');
-    assert.object(opts.req, 'opts.req');
-    assert.string(opts.req_id, 'opts.req_id');
-
-    var inspectOpts = {
-        account: opts.req.account,
-        app: opts.req.app,
-        index_name: opts.index_name,
-        log: opts.log,
-        name: dockerId,
-        req_id: opts.req_id
-    };
-    opts.req.backend.inspectImage(inspectOpts, callback);
-}
-
 /**
  * Build an image, given build params and a build context (tarball).
  *
@@ -71,12 +52,9 @@ function buildImage(opts, callback) {
     assert.object(opts.res, 'opts.res');
     assert.string(opts.req_id, 'opts.req_id');
 
-    var allDockerImages = [];
-    var baseImageId = null;         // Base image id our build is based on.
-    var baseImageIndexName = null;  // Base index_name our build is based on.
     var buildFinishedSuccessfully = false;
     var dockerOpts = opts.dockerOpts;
-    var finalImageId = null;  // Final docker image id for resulting image.
+    var finalImageDigest = null;  // Final image digest for resulting image.
     var log = opts.log;
     var previousErr;
     var rat = opts.rat;
@@ -89,13 +67,16 @@ function buildImage(opts, callback) {
     var vmDockerId;
     var vmUuid;
 
+    if (!rat) {
+        rat = drc.parseRepoAndTag('');
+    }
+
     // There is the potential to run the callback twice, so make sure that never
     // happens.
     callback = once(callback);
 
     vasync.pipeline({ funcs: [
         buildGetScratchImage,
-        buildGetAllDockerImages,
         buildCreateContainer,
         buildGetVmObject,
         buildCnapiDockerBuild,
@@ -119,48 +100,6 @@ function buildImage(opts, callback) {
     }
 
 
-    function buildGetAllDockerImages(_, cb) {
-        // If nocache is specified, there is no need to lookup all images, as
-        // this list of images is *only* used for build caching.
-        if (dockerOpts.nocache) {
-            cb();
-            return;
-        }
-        var listOpts = {
-            account: req.account,
-            all: true,
-            app: req.app,
-            clientApiVersion: req.clientApiVersion,
-            log: log,
-            req_id: req_id,
-            skip_smartos: true
-        };
-        req.backend.listImages(listOpts, function _listImagesCb(err, imgs) {
-            if (err) {
-                cb(err);
-                return;
-            }
-            // Convert an img into the docker inspect format.
-            function getImageDetails(img, next) {
-                var inspectOpts = {
-                    index_name: img.IndexName,
-                    log: log,
-                    req: req,
-                    req_id: req_id
-                };
-                getImageInInspectFormat(img.Id, inspectOpts, next);
-            }
-            vasync.forEachPipeline({
-                'func': getImageDetails,
-                'inputs': imgs
-            }, function _getImageDetailsCb(err2, results) {
-                allDockerImages = results.successes;
-                cb(err2);
-            });
-        });
-    }
-
-
     function buildCreateContainer(_, cb) {
         var labels;
         try {
@@ -247,7 +186,7 @@ function buildImage(opts, callback) {
         cnapiBuildPayload.account_uuid = req.account.uuid;
         cnapiBuildPayload.command = 'build';  // Command type.
         cnapiBuildPayload.imgapi_url = req.app.config.imgapi.url;
-        cnapiBuildPayload.allDockerImages = allDockerImages;
+        cnapiBuildPayload.scratchImageUuid = scratchImage.image_uuid;
 
         /* CNAPI, go build for us. */
         cnapi.dockerBuild(vm.server_uuid, vmUuid,
@@ -330,7 +269,7 @@ function buildImage(opts, callback) {
                 response.error = err.message;
             }
             if (typeof (result) !== 'undefined') {
-                response['result'] = result;
+                response.result = result;
             }
             log.debug('response:', response);
             buildSocket.write(JSON.stringify(response) + '\n');
@@ -402,6 +341,19 @@ function buildImage(opts, callback) {
                         'stream': event.message
                     }) + '\n');
                     break;
+                case 'find_cached_image':
+                    var findOpts = {
+                        account_uuid: req.account.uuid,
+                        app: req.app,
+                        cmd: event.cmd,
+                        labels: event.labels,
+                        log: log,
+                        parentDigest: event.parentDigest
+                    };
+                    findCachedImage(findOpts, function _findImageCb(err, img) {
+                        sendEventResponse(event, err, img);
+                    });
+                    break;
                 case 'image_reprovision':
                     assert.string(event.cmdName, 'event.cmdName');
                     assert.string(event.imageName, 'event.imageName');
@@ -414,15 +366,13 @@ function buildImage(opts, callback) {
                         req_id: req_id,
                         res: res,
                         vm: vm
-                    }, function _pullReprovCb(err, result) {
-                        // Note: result.image is in docker inspect format.
+                    }, function _pullReprovCb(err, img) {
+                        // Note: img is an ImageV2 model instance.
                         if (!err) {
-                            baseImageId = result.image.Id;
-                            baseImageIndexName = result.index_name;
-                            log.debug('reprovisioned to baseImageId: %j',
-                                baseImageId);
+                            log.debug('reprovisioned to base image digest: %j',
+                                img.digest);
                         }
-                        sendEventResponse(event, err, result);
+                        sendEventResponse(event, err, img);
                     });
                     break;
                 case 'image_create':
@@ -435,7 +385,7 @@ function buildImage(opts, callback) {
                 case 'run':
                     runBuildCommand(
                     {
-                        dockerId: vmDockerId,
+                        vmDockerId: vmDockerId,
                         log: log,
                         req: req,
                         req_id: req_id,
@@ -446,24 +396,12 @@ function buildImage(opts, callback) {
                     });
                     break;
                 case 'build_finished':
-                    finalImageId = event.finalId;
-                    vasync.pipeline({ funcs: [
-                        function _doAddBaseImageHead(_result, next) {
-                            addBaseImageHead(baseImageId, finalImageId,
-                            {
-                                baseImageIndexName: baseImageIndexName,
-                                req: req,
-                                scratchImage: scratchImage
-                            }, next);
-                        },
-                        function _doTagImage(_result, next) {
-                            tagImage({
-                                    docker_id: finalImageId,
-                                    name: dockerOpts.tag,
-                                    req: req
-                                }, next);
-                        }
-                    ]}, function buildFinishPipeCb(err) {
+                    finalImageDigest = event.finalImageDigest;
+                    tagImage({
+                        digest: finalImageDigest,
+                        name: dockerOpts.tag,
+                        req: req
+                    }, function _tagImageCb(err) {
                         if (!err) {
                             buildFinishedSuccessfully = true;
                         }
@@ -495,9 +433,11 @@ function buildImage(opts, callback) {
                 return;
             } else {
                 // Send the successfully built image message.
+                var shortId = imgmanifest.shortDockerId(
+                    imgmanifest.dockerIdFromDigest(finalImageDigest));
                 res.write(JSON.stringify({
                     'stream': format('Successfully built %s\n',
-                        finalImageId.substr(0, 12))
+                        shortId)
                 }) + '\n');
             }
             callback(cleanuperr);
@@ -562,13 +502,55 @@ function buildImage(opts, callback) {
 }
 
 
+function findCachedImage(opts, callback) {
+    assert.string(opts.account_uuid, 'opts.account_uuid');
+    assert.object(opts.app, 'opts.app');
+    assert.string(opts.cmd, 'opts.cmd');
+    assert.optionalObject(opts.labels, 'opts.labels');
+    assert.object(opts.log, 'opts.log');
+    assert.optionalString(opts.parentDigest, 'opts.parentDigest');
+
+    var filter = {
+        parent: opts.parentDigest || '',
+        owner_uuid: opts.account_uuid
+    };
+
+    var log = opts.log;
+
+    ImageV2.list(opts.app, log, filter, function (err, imgs) {
+        if (err) {
+            callback(err);
+            return;
+        }
+
+        log.debug('findCachedImage: %d possible images', imgs.length);
+        var matchedImgs = imgs.filter(function _cachedImgFilter(img) {
+            // Images must have the same Cmd entry.
+            if (opts.cmd !== img.container_config.Cmd.join(' ')) {
+                return false;
+            }
+            // Some fields (like Labels) can also be set from the client, check
+            // that these fields are the same.
+            if (!(jsprim.deepEqual(opts.labels, img.image.config.Labels))) {
+                return false;
+            }
+
+            return true;
+        });
+
+        log.debug('findCachedImage: %d images matched', matchedImgs.length);
+        callback(null, matchedImgs && matchedImgs[0] || null);
+    });
+}
+
+
 function pullImage(opts, callback) {
     var imageName = opts.imageName;
     var log = opts.log;
     var req = opts.req;
     var res = opts.res;
 
-    log.debug('pullImage');
+    log.debug({imageName: imageName}, 'pullImage');
 
     // 1. Parse the image name.
     // 2. Pull the image if it's not already downloaded.
@@ -585,7 +567,6 @@ function pullImage(opts, callback) {
         app: req.app,
         log: log,
         account: req.account,
-        index_name: rat.index.name,
         name: imageName,
         includeSmartos: false
     };
@@ -656,45 +637,26 @@ function reprovisionFromImageUuid(image_uuid, opts, callback) {
  * reprovision the container with that image.
  */
 function pullAndReprovisionImage(opts, callback) {
-    pullImage(opts, function pullImage_callback(err, image) {
-        // Note: image is in the imgapi format.
+    pullImage(opts, function pullImage_callback(err, img) {
+        // Note: img is an Image model instance.
         if (err) {
             callback(err);
             return;
         }
         // Warning: pullImage can return a null image, which means an error
         // occurred (e.g. the requested image was not found).
-        if (!image) {
+        if (!img) {
             callback(new errors.DockerError(
                 'could not pull image: ' + opts.imageName));
             return;
         }
 
-        // DOCKER-748: Ensure the tag and the base image are from the same repo.
-        var index_name = opts.rat && opts.rat.index.name || 'docker.io';
-        if (index_name !== image.index_name) {
-            opts.log.warn('Build failure - using different registries: %s, %s',
-                index_name, image.index_name);
-            callback(new errors.DockerError(format(
-                'Cannot build an image that references different registries '
-                + '(%s, %s)', index_name, image.index_name)));
-            return;
-        }
-
-        reprovisionFromImageUuid(image.image_uuid, opts, function (rerr) {
+        reprovisionFromImageUuid(img.image_uuid, opts, function (rerr) {
             if (rerr) {
                 callback(rerr);
                 return;
             }
-            var dockerId = image.docker_id;
-            opts.index_name = image.index_name;
-            getImageInInspectFormat(dockerId, opts, function (ierr, iimg) {
-                if (ierr) {
-                    callback(ierr);
-                    return;
-                }
-                callback(null, { image: iimg, index_name: image.index_name });
-            });
+            callback(null, img);
         });
     });
 }
@@ -705,115 +667,28 @@ function pullAndReprovisionImage(opts, callback) {
  */
 function createImage(payload, opts, callback) {
     assert.object(payload, 'payload');
-    assert.string(payload.finalId, 'payload.finalId');
+    assert.string(payload.digest, 'payload.digest');
+    assert.bool(payload.head, 'payload.head');
     assert.object(payload.image, 'payload.image');
+    assert.string(payload.manifest_digest, 'payload.manifest_digest');
+    assert.string(payload.manifest_str, 'payload.manifest_str');
     assert.number(payload.size, 'payload.size');
-    assert.optionalNumber(payload.virtual_size, 'payload.virtual_size');
     assert.object(opts, 'opts');
-    assert.optionalObject(opts.rat, 'opts.rat');
     assert.object(opts.req, 'opts.req');
 
-    var rat = opts.rat;
     var req = opts.req;
-    var createOpts = {
-        payload: {
-            head: (payload.finalId === payload.image.id),
-            heads: [payload.finalId],
-            image: payload.image,
-            size: payload.size,
-            virtual_size: payload.virtual_size
-        },
-        rat: rat,
-        req: req
-    };
-
-    req.log.debug(format('Creating image %j', createOpts.payload));
-    req.backend.createImage(createOpts, callback);
-}
-
-
-/**
- * Update all parent images of finalImageId to include a head reference to
- * finalImageId (for sdc-docker image model).
- */
-function addBaseImageHead(baseImageId, finalImageId, opts, callback) {
-    assert.string(finalImageId, 'finalImageId');
-    assert.object(opts, 'opts');
-    assert.object(opts.req, 'opts.req');
-    assert.object(opts.scratchImage, 'opts.scratchImage');
-
-    if (!baseImageId || (baseImageId === opts.scratchImage.id)) {
-        callback();
-        return;
-    }
 
-    assert.string(baseImageId, 'baseImageId');
-    assert.string(opts.baseImageIndexName, 'opts.baseImageIndexName');
-    var req = opts.req;
-    var log = req.log;
-
-    // Find the base image.
-    var imageOpts = {
-        app: req.app,
-        log: log,
-        account: req.account,
-        name: baseImageId,
-        index_name: opts.baseImageIndexName,
-        includeSmartos: false
+    var modelOpts = {
+        digest: payload.digest,
+        head: payload.head,
+        image_uuid: payload.image_uuid,
+        manifest_digest: payload.manifest_digest,
+        manifest_str: payload.manifest_str,
+        owner_uuid: req.account.uuid,
+        size: payload.size
     };
-    req.backend.imgFromName(imageOpts, function (findErr, image) {
-        if (findErr) {
-            callback(findErr);
-            return;
-        }
-        if (!image) {
-            callback(new errors.DockerError(
-                'could not find base image: ' + baseImageId));
-            return;
-        }
-
-        // Update base image (and all base image parent images) to include the
-        // new head reference.
-        req.backend.getImageHistory({
-            account: req.account,
-            app: req.app,
-            img: image,
-            log: log
-        }, function (histErr, history) {
-            if (histErr) {
-                callback(new errors.DockerError(histErr,
-                    'could not create image layer'));
-                return;
-            }
-
-            vasync.forEachPipeline({
-                inputs: history,
-                func: addImageHead
-            }, function (err) {
-                if (err) {
-                    callback(new errors.DockerError(err,
-                        'could not create image layer'));
-                    return;
-                }
-                callback();
-            });
-
-            function addImageHead(img, next) {
-                log.debug('addImageHead img id: %s, head: %s',
-                    img.docker_id, finalImageId);
-                var addHeadOpts = {
-                    heads: [finalImageId],
-                    id: img.docker_id,
-                    index_name: img.index_name,
-                    req: req
-                };
-
-                req.log.debug(format('Adding %j to %j image heads',
-                    finalImageId, img.docker_id));
-                req.backend.addImageHeads(addHeadOpts, next);
-            }
-        });
-    });
+    var img = images.dockerImageJsonToModel(payload.image, modelOpts);
+    ImageV2.create(req.app, req.log, img, callback);
 }
 
 
@@ -822,7 +697,7 @@ function addBaseImageHead(baseImageId, finalImageId, opts, callback) {
  */
 function tagImage(opts, callback) {
     assert.object(opts, 'opts');
-    assert.string(opts.docker_id, 'opts.docker_id');
+    assert.string(opts.digest, 'opts.digest');
     assert.object(opts.req, 'opts.req');
     assert.optionalString(opts.name, 'opts.name');
 
@@ -831,8 +706,7 @@ function tagImage(opts, callback) {
         return;
     }
 
-    opts.req.log.debug(format('Adding tag %j to image with docker id %j',
-                            opts.name, opts.docker_id));
+    opts.req.log.debug({name: opts.name, digest: opts.digest}, 'Tag image');
     opts.req.backend.tagImage(opts, callback);
 }
 
@@ -860,7 +734,7 @@ function runBuildCommand(opts, callback) {
         AttachStdout: true,
         AttachStderr: true,
         Cmd: ['AttachConsole'], // To fix in cn-agent
-        Container: opts.dockerId,
+        Container: opts.vmDockerId,
         Tty: false
     };
 
@@ -891,7 +765,7 @@ function runBuildCommand(opts, callback) {
                 account: req.account,
                 app: req.app,
                 doNotEncodeData: true,  // Don't encode when writing to stream.
-                id: opts.dockerId,
+                id: opts.vmDockerId,
                 log: log,
                 payload: payload,
                 req_id: opts.req_id,
@@ -966,14 +840,12 @@ function commitImage(req, opts, callback) {
     assert.object(vm, 'vm');  // Should have been added by the backend.
 
     var baseImg;
-    var baseImageId = vm.internal_metadata['docker:imageid'];
     var commitFinishedSuccessfully = false;
-    var finalImageId = null;  // Final docker image id for resulting image.
+    var finalImageDigest = null;  // Final image digest for resulting image.
     var log = req.log;
     var previousErr;
     var rat;
     var req_id = req.getId();
-    var scratchImage;
     var socketOpts;
 
     // There is the potential to run the callback twice, so make sure that never
@@ -988,53 +860,33 @@ function commitImage(req, opts, callback) {
     }
 
     vasync.pipeline({ funcs: [
-        getScratchImage,
         findContainerImage,
-        checkTagRepository,
         startCnapiDockerCommit,
         runCnapiDockerCommit
     ]}, commitCleanup);
 
-
-    function getScratchImage(_, cb) {
-        req.app.backend.getScratchImage(req,
-        function _getScratchImageCb(err, sImg) {
-            if (err) {
-                log.error(err, 'getScratchImage failure');
-                cb(err);
-                return;
-            }
-            scratchImage = sImg;
-            cb();
-        });
-    }
-
     // Find the Image model for running container.
     function findContainerImage(_, cb) {
+        var digest = vm.internal_metadata['docker:imageid'];
+        if (!digest) {
+            cb(new errors.DockerError(
+                'No docker:imageid in vm internal metadata'));
+            return;
+        }
         var dockerImageOpts = {
             account: req.account,
             app: req.app,
+            digest: digest,
             log: log
         };
-        images.getDockerImageForUuid(vm.image_uuid, dockerImageOpts,
-            function _dockerImageUuidCb(err, imgModel) {
+        images.imgFromDigest(dockerImageOpts,
+            function _imgFromDigestCb(err, imgModel) {
                 baseImg = imgModel;
                 cb(err);
             }
         );
     }
 
-    function checkTagRepository(_, cb) {
-        // DOCKER-748: Ensure the tag and the image are in the same repository.
-        if (baseImg.index_name !== rat.index.name) {
-            cb(new errors.DockerError(format(
-                'Cannot create tag reference between different registries '
-                + '(%s, %s)', baseImg.index_name, rat.index.name)));
-            return;
-        }
-        cb();
-    }
-
     // Start the cn-agent commit task.
     function startCnapiDockerCommit(_, cb) {
         var cnapi = req.app.cnapi;
@@ -1057,8 +909,7 @@ function commitImage(req, opts, callback) {
 
         cnapiCommitPayload.account_uuid = req.account.uuid;
         cnapiCommitPayload.command = 'commit';  // Command type.
-        cnapiCommitPayload.fromImage = utils.imgobjToInspect(baseImg);
-        cnapiCommitPayload.fromImageUuid = vm.image_uuid;
+        cnapiCommitPayload.fromImg = baseImg;
         cnapiCommitPayload.imgapi_url = req.app.config.imgapi.url;
 
         /* CNAPI, commit the container to an image for us. */
@@ -1120,7 +971,7 @@ function commitImage(req, opts, callback) {
         {
             var line;
             var event;
-            while ((line = commitEventStream.read()) != null) {
+            while ((line = commitEventStream.read()) !== null) {
                 log.debug('commit: got commit event:', String(line));
                 try {
                     event = JSON.parse(line);
@@ -1128,57 +979,48 @@ function commitImage(req, opts, callback) {
                     log.error('Commit: invalid json: %s - ignoring', line);
                     continue;
                 }
-                switch (event.type) {
-                    case 'end':
-                        if (event.error) {
-                            // Will be passed to callback `cb`.
-                            commitError = new Error(event.error);
-                        }
-                        break;
-                    case 'message':
-                    case 'stdout':
-                        log.info('Commit event message: %s', event.message);
-                        break;
-                    case 'image_create':
-                        createImage(event.payload, { rat: rat, req: req },
-                            function _imageCreateCb(err, result)
-                        {
-                            sendEventResponse(event, err, result);
-                        });
-                        break;
-                    case 'commit_finished':
-                        finalImageId = event.finalId;
-                        vasync.pipeline({ funcs: [
-                            function _doAddBaseImageHead(_result, next) {
-                                addBaseImageHead(baseImageId, finalImageId,
-                                {
-                                    baseImageIndexName: baseImg.index_name,
-                                    req: req,
-                                    scratchImage: scratchImage
-                                }, next);
-                            },
-                            function _doTagImage(_result, next) {
-                                tagImage({
-                                        docker_id: finalImageId,
-                                        name: opts.tag,
-                                        req: req
-                                    }, next);
-                            }
-                        ]}, function commitFinishPipeCb(err) {
-                            if (!err) {
-                                commitFinishedSuccessfully = true;
-                            }
-                            sendEventResponse(event, err);
-                        });
-                        break;
-                    default:
-                        log.error('Unhandled commit event: %j', event);
-                        break;
-                }
-
+                onCommitEvent(event);
             }
         });
 
+        function onCommitEvent(event) {
+            switch (event.type) {
+                case 'end':
+                    if (event.error) {
+                        // Will be passed to callback `cb`.
+                        commitError = new Error(event.error);
+                    }
+                    break;
+                case 'message':
+                case 'stdout':
+                    log.info('Commit event message: %s', event.message);
+                    break;
+                case 'image_create':
+                    createImage(event.payload, { rat: rat, req: req },
+                        function _imageCreateCb(err, result)
+                    {
+                        sendEventResponse(event, err, result);
+                    });
+                    break;
+                case 'commit_finished':
+                    finalImageDigest = event.finalImageDigest;
+                    tagImage({
+                        digest: finalImageDigest,
+                        name: opts.tag,
+                        req: req
+                    }, function _tagImageCb(err) {
+                        if (!err) {
+                            commitFinishedSuccessfully = true;
+                        }
+                        sendEventResponse(event, err);
+                    });
+                    break;
+                default:
+                    log.error('Unhandled commit event: %j', event);
+                    break;
+            }
+        }
+
         commitEventStream.on('close', function _eventStreamCloseCb() {
             log.debug('commit: commitEventStream.close - closing socket');
         });
@@ -1213,7 +1055,7 @@ function commitImage(req, opts, callback) {
             callback(new errors.DockerError('Unexpected commit error'));
             return;
         }
-        callback(null, finalImageId);
+        callback(null, finalImageDigest);
     }
 
 
diff --git a/lib/backends/sdc/containers.js b/lib/backends/sdc/containers.js
index f0d04aa..b3e38d3 100644
--- a/lib/backends/sdc/containers.js
+++ b/lib/backends/sdc/containers.js
@@ -2250,10 +2250,8 @@ function buildVmPayload(opts, container, callback) {
                 payload.kernel_version = VM_DEFAULT_KERNEL_VERSION;
             }
 
-            if (imgConfig.Image) {
-                payload.internal_metadata['docker:imageid'] =
-                    opts.image.docker_id;
-            }
+            payload.internal_metadata['docker:imageid'] =
+                (opts.image.digest || opts.image.docker_id);
             if (container.Image) {
                 // the original name the user passed
                 payload.internal_metadata['docker:imagename'] = container.Image;
diff --git a/lib/backends/sdc/images.js b/lib/backends/sdc/images.js
index 31ab93b..e8eb87f 100644
--- a/lib/backends/sdc/images.js
+++ b/lib/backends/sdc/images.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright 2016, Joyent, Inc.
+ * Copyright 2017, Joyent, Inc.
  */
 
 /*
@@ -37,6 +37,7 @@
  */
 
 var assert = require('assert-plus');
+var crypto = require('crypto');
 var format = require('util').format;
 var fs = require('fs');
 var imgmanifest = require('imgmanifest');
@@ -50,6 +51,8 @@ var vasync = require('vasync');
 var common = require('../../common');
 var Image = require('../../models/image');
 var ImageTag = require('../../models/image-tag');
+var ImageV2 = require('../../models/image-v2');
+var ImageTagV2 = require('../../models/image-tag-v2');
 var errors = require('../../../lib/errors');
 var utils = require('./utils');
 
@@ -71,6 +74,38 @@ function getVmapiClient(config) {
 }
 
 
+/**
+ * Return the array of image tags for the given image.
+ */
+function tagsForImage(img, opts, callback) {
+    assert.object(img, 'img');
+    assert.object(opts, 'opts');
+    assert.object(opts.account, 'opts.account');
+    assert.object(opts.app, 'opts.app');
+    assert.object(opts.log, 'opts.log');
+    assert.optionalString(opts.index_name, 'opts.index_name');
+    assert.func(callback, 'callback');
+
+    var filter;
+
+    if (isV1Image(img)) {
+        filter = [
+            {owner_uuid: opts.account.uuid, docker_id: img.docker_id}
+        ];
+        if (opts.index_name) {
+            filter[0].index_name = opts.index_name;
+        }
+        ImageTag.list(opts.app, opts.log, filter, callback);
+        return;
+    }
+
+    filter = [
+        {owner_uuid: opts.account.uuid, digest: img.digest}
+    ];
+    ImageTagV2.list(opts.app, opts.log, filter, callback);
+}
+
+
 /**
  * Convert a docker image json layer (as given from docker hub) into a
  * sdc-docker Image model structure.
@@ -80,40 +115,27 @@ function getVmapiClient(config) {
  * @returns {Object} Image model object.
  */
 function dockerImageJsonToModel(imageJson, opts) {
+    assert.object(imageJson, 'imageJson');
     assert.object(opts, 'opts');
+    assert.string(opts.digest, 'opts.digest');
+    assert.optionalBool(opts.head, 'opts.head');
     assert.string(opts.image_uuid, 'opts.image_uuid');
-    assert.string(opts.index_name, 'opts.index_name');
+    assert.string(opts.manifest_str, 'opts.manifest_str');
+    assert.string(opts.manifest_digest, 'opts.manifest_digest');
     assert.optionalString(opts.owner_uuid, 'opts.owner_uuid');
+    assert.number(opts.size, 'opts.size');
 
     var modelObj = {
-        architecture: imageJson.architecture || 'amd64',
-        author: imageJson.author,
-        comment: imageJson.comment || '',
-        created: new Date(imageJson.created).getTime(),
-        docker_id: imageJson.id,
+        digest: opts.digest,
         head: (opts.head || false),
-        heads: (opts.heads || []),
+        image: imageJson,
         image_uuid: opts.image_uuid,
-        index_name: opts.index_name,
+        manifest_digest: opts.manifest_digest,
+        manifest_str: opts.manifest_str,
         owner_uuid: opts.owner_uuid,
-        private: true,
-        size: (opts.size || 0),
-        virtual_size: (opts.virtual_size || 0)
+        size: (opts.size || 0)
     };
 
-    if (imageJson.comment) {
-        modelObj.comment = imageJson.comment;
-    }
-    if (imageJson.container_config) {
-        modelObj.container_config = imageJson.container_config;
-    }
-    if (imageJson.config) {
-        modelObj.config = imageJson.config;
-    }
-    if (imageJson.parent) {
-        modelObj.parent = imageJson.parent;
-    }
-
     return modelObj;
 }
 
@@ -121,12 +143,12 @@ function dockerImageJsonToModel(imageJson, opts) {
 /**
  * Get all the images available to the given account.
  *
- * Dev note on `Uuid` field:
- * I've added a `Uuid` as required for "utils.js#imageFromUuid" (used for
- * `docker ps`) to function, and Todd added `IndexName` (for docker build
- * functionality). These two fields don't exist in Docker-land representation
- * of an image object. However, AFAICT the way `listImages` is currently used
- * that `Uuid` and `IndexName` field doesn't get exposed. IOW, no harm, no foul.
+ * Dev note on `Uuid` and `ExposedPorts` fields:
+ * Trent added a `Uuid` as required for "utils.js#imageFromUuid" (used for
+ * `docker ps` and `docker inspect`) to function. These two fields don't exist
+ * in Docker-land representation of an image object. However, AFAICT the way
+ * `listImages` is currently used is that the `Uuid` field doesn't get exposed.
+ * IOW, no harm, no foul.
  *
  * @param {Object} opts
  * @param {String} opts.account The account to which to limit access.
@@ -144,6 +166,7 @@ function listImages(opts, callback) {
     assert.optionalBool(opts.all, 'opts.all');
     assert.number(opts.clientApiVersion, 'opts.clientApiVersion');
     assert.optionalString(opts.filters, 'opts.filters');
+    assert.optionalBool(opts.skip_v1_images, 'opts.skip_v1_images');
     assert.optionalBool(opts.skip_smartos, 'opts.skip_smartos');
     assert.string(opts.req_id, 'opts.req_id');
 
@@ -161,7 +184,8 @@ function listImages(opts, callback) {
     if (!opts.skip_smartos) {
         funcs.push(listSmartOSImages);
     }
-    funcs.push(listDockerImages);
+    funcs.push(listDockerImagesV2);
+    funcs.push(listDockerImagesV1);
 
     vasync.parallel({funcs: funcs}, function (err) {
         if (err) {
@@ -259,7 +283,111 @@ function listImages(opts, callback) {
         return isMatch;
     }
 
-    function listDockerImages(next) {
+    function listDockerImagesV2(next) {
+        var params = { owner_uuid: opts.account.uuid };
+        var results = [];
+
+        if (!opts.all) {
+            params.head = true;
+        }
+
+        ImageV2.list(app, log, params, function (err, imgs) {
+            log.debug('listDockerImagesV2:: found %d imgs', imgs.length);
+            if (err) {
+                next(err);
+                return;
+            }
+
+            // Filter images when requested by the client.
+            if (!common.objEmpty(imageFilters)) {
+                log.debug({ 'imageFilters': imageFilters}, 'filtering images');
+                try {
+                    imgs = imgs.filter(imageFilter);
+                } catch (e) {
+                    next(e);
+                    return;
+                }
+            }
+
+            vasync.forEachParallel({
+                func: getTagsV2,
+                inputs: imgs
+            }, function (getErr) {
+                if (getErr) {
+                    next(getErr);
+                    return;
+                }
+
+                log.trace({imgs: results}, 'listImages: listDockerImagesV2');
+                dockerImages = dockerImages.concat(results);
+                next();
+            });
+        });
+
+        function _addImageV2(img, repoTags, repoDigests) {
+            assert.optionalArrayOfString(repoTags, 'repoTags');
+
+            if (!repoTags || repoTags.length === 0) {
+                repoTags = ['<none>:<none>'];
+            }
+            if (!repoDigests || repoDigests.length === 0) {
+                repoDigests = ['<none>@<none>'];
+            }
+            var imgConfig = img.config || {};
+            var dockerImage = {
+                Created: img.created,
+                Id: img.digest,
+                Labels: img.config.Labels || null,
+                ParentId: img.parent || '',
+                RepoTags: repoTags,
+                RepoDigests: repoDigests,
+                Size: img.size,
+                VirtualSize: img.size,
+                // Used by vmobjToInspect and vmobjToContainer (aka `docker
+                // inspect` and `docker ps`).
+                Uuid: img.image_uuid,
+                // Used by vmobjToInspect (aka `docker inspect`).
+                ExposedPorts: imgConfig.ExposedPorts
+            };
+
+            results.push(dockerImage);
+        }
+
+        function getTagsV2(img, cb) {
+            // Intermediate layers don't have tags.
+            if (!img.head) {
+                _addImageV2(img);
+                cb();
+                return;
+            }
+
+            tagsForImage(img, {app: app, log: log, account: opts.account},
+                    function (err, imgTags) {
+                if (err) {
+                    cb(err);
+                    return;
+                }
+                if (imgTags && imgTags.length > 0) {
+                    var repoTags = imgTags.map(function (it) {
+                        return it.repo + ':' + it.tag;
+                    });
+                    var repoDigests = imgTags.map(function (it) {
+                        return it.repo + '@' + it.digest;
+                    });
+                    _addImageV2(img, repoTags, repoDigests);
+                } else {
+                    _addImageV2(img);
+                }
+                cb();
+            });
+        }
+    }
+
+    function listDockerImagesV1(next) {
+        if (opts.skip_v1_images) {
+            next();
+            return;
+        }
         var params = { owner_uuid: opts.account.uuid };
         var results = [];
 
@@ -293,7 +421,7 @@ function listImages(opts, callback) {
                     return;
                 }
 
-                log.trace({imgs: results}, 'listImages: listDockerImages');
+                log.trace({imgs: results}, 'listImages: listDockerImagesV1');
                 dockerImages = dockerImages.concat(results);
                 next();
             });
@@ -339,18 +467,14 @@ function listImages(opts, callback) {
                 return;
             }
 
-            var getParams = {
-                owner_uuid: img.owner_uuid,
-                index_name: img.index_name,
-                docker_id: img.docker_id
-            };
-            ImageTag.list(app, log, getParams, function (err, imgTag) {
+            tagsForImage(img, {app: app, log: log, account: opts.account},
+                    function (err, imgTags) {
                 if (err) {
                     cb(err);
                     return;
                 }
-                if (imgTag) {
-                    var repoTags = imgTag.map(function (it) {
+                if (imgTags) {
+                    var repoTags = imgTags.map(function (it) {
                         return it.repo + ':' + it.tag;
                     });
                     pushImage(serialized, repoTags);
@@ -375,7 +499,7 @@ function listImages(opts, callback) {
  * @param {Object} opts.app App instance
  * @param callback {Function} `function (err, img)`
  */
-function imgFromImgInfo(opts, callback) {
+function imgFromImgInfoV1(opts, callback) {
     assert.object(opts, 'opts');
     assert.object(opts.account, 'opts.account');
     assert.string(opts.indexName, 'opts.indexName');
@@ -403,129 +527,67 @@ function imgFromImgInfo(opts, callback) {
 
 
 /**
- * Find the img (an 'Image' model object instance) for the named Docker
- * image (and for the given account).
- *
- * Given a name, e.g. 'cafe', that could be either a name or an id prefix,
- * Docker semantics say that *name* wins. That means we need to lookup by
- * name first, then fallback to imgId prefix.
- *
- * Ambiguity notes:
- * 1. One form of ambiguity is if an imgId prefix matches more than one imgId.
- *    For this case, this function returns no imgTag.
- * 2. There is another form. Because SDC's design of keeping Docker images from
- *    different registry hosts separate, even if they have the same imgId, we
- *    have a potential confusion for users and an *inherent ambiguity in
- *    referring to images by imgId*. E.g., the same busybox image pulled from
- *    docker.io and from quay.io will have the same imgId, but different
- *    imgUuid in SDC. For now, if such an ambiguity comes up we'll return
- *    an error here: `AmbiguousDockerImageIdError`.
- *
- * Theoretically, it is *sdc-docker's* data in moray that determines if a
- * particular image exists. However, the images are stored in IMGAPI and
- * can (whether by accident or not) be removed from IMGAPI without sdc-docker
- * knowing it. If the image is found in sdc-docker's database, but is not
- * in IMGAPI, then the sdc-docker DB entry will be removed to lazily clean up.
- *
- * Also, optionally (if `includeSmartos=true`), if a UUID for a SmartOS image
- * in the DC's IMGAPI is given, this returns a fake 'Image' model object
- * representing that IMGAPI image.
+ * Gets an image -- an ImageV2 model object -- from (account, digest).
  *
  * @param {Object} opts
- * @param {Object} opts.app App instance
- * @param {Object} opts.log Bunyan log instance
- * @param {String} opts.name An imgId, imgId prefix or image
- *      [REGHOST]NAME[:TAG] name.
  * @param {Object} opts.account
- * @param {Boolean} opts.index_name Optional. Used to avoid duplicate images.
- * @param {Boolean} opts.includeSmartos Optional. Default false. Set to true
- *      to include (faux) results
- * @param callback {Function} `function (err, img, imgTag)`
- *      `img` is an `Image` instance or will be undefined if no matching
- *      image or no *unambiguous* match was found.
- *      `imgTag` will be the `ImageTag` instance for `name` iff it was found
- *      by name. E.g. if `name` is an imgId, then `imgTag` will be undefined.
+ * @param {Object} opts.digest
+ * @param {Object} opts.log Bunyan log instance
+ * @param {Object} opts.app App instance
+ * @param callback {Function} `function (err, img)`
  */
-function imgFromName(opts, callback) {
-    assert.object(opts.app, 'opts.app');
-    assert.object(opts.log, 'opts.log');
-    assert.string(opts.name, 'opts.name');
+function imgFromImgInfoV2(opts, callback) {
+    assert.object(opts, 'opts');
     assert.object(opts.account, 'opts.account');
-    assert.optionalString(opts.index_name, 'opts.index_name');
-    assert.optionalBool(opts.includeSmartos, 'opts.includeSmartos');
-    var log = opts.log;
+    assert.string(opts.digest, 'opts.digest');
 
-    try {
-        var rat = drc.parseRepoAndTag(opts.name);
-    } catch (e) {
-        callback(new errors.DockerError(e, e.message));
-        return;
-    }
-    var name = rat.localName;
-    var tag = rat.tag;
+    var filter = {
+        owner_uuid: opts.account.uuid,
+        digest: opts.digest
+    };
+    ImageV2.list(opts.app, opts.log, filter, function (err, imgs) {
+        if (err) {
+            callback(err);
+            return;
+        } else if (!imgs.length) {
+            callback(new errors.ResourceNotFoundError(format(
+                'No such image: %s', opts.digest)));
+            return;
+        }
+        assert.equal(imgs.length, 1);
+        callback(null, imgs[0]);
+    });
+}
 
-    var imgUuid;
+
+function _imgFromNameV2(opts, callback) {
     var imgTag;
     var img;
     var imgIsGone = false;
+    var log = opts.log;
+    var name = opts.rat.localName;
+    var tag = opts.rat.tag;
+
+    log.debug({name: name, tag: tag}, '_imgFromNameV2');
 
     var imgapiOpts = common.objCopy(opts.app.config.imgapi);
     imgapiOpts.headers = { 'x-request-id': log.fields.req_id };
     var imgapi = new IMGAPI(imgapiOpts);
 
     vasync.pipeline({funcs: [
-        function findUuidInImgapi(_, next) {
-            if (!opts.includeSmartos || !common.isUUID(name)) {
-                next();
-                return;
-            }
-
-            var acct = opts.account.uuid;
-            var getOpts = {
-                os: 'smartos',
-                state: 'active'
-            };
-            imgapi.getImage(name, acct, getOpts, function (err, imgapiImg) {
-                if (err) {
-                    if (err.statusCode === 404) {
-                        next();
-                    } else {
-                        next(err);
-                    }
-                    return;
-                }
-                log.debug({imgName: name, imgapiImg: imgapiImg},
-                    'imgFromName: findUuidInImgapi');
-                // A faux `Image` model object for this IMGAPI image.
-                img = {
-                    image_uuid: imgapiImg.uuid,
-                    os: imgapiImg.os
-                };
-                next(true);  /* early abort */
-            });
-        },
-
         function findByName(_, next) {
             var filter = [
                 {repo: name, owner_uuid: opts.account.uuid, tag: tag}
             ];
-            if (opts.index_name) {
-                filter[0].index_name = opts.index_name;
-            }
-            ImageTag.list(opts.app, log, filter, function (err, imgTags) {
+            ImageTagV2.list(opts.app, log, filter, function (err, imgTags) {
                 if (err) {
                     next(err);
                 } else if (imgTags.length === 0) {
                     next();
                 } else {
                     imgTag = imgTags[0];
-                    // We can calculate the imgUuid from the ImageTag fields.
-                    imgUuid = imgmanifest.imgUuidFromDockerInfo({
-                        id: imgTag.docker_id,
-                        indexName: drc.parseRepo(imgTag.repo).index.name
-                    });
-                    log.debug({imgName: name, imgTag: imgTag, imgUuid: imgUuid},
-                        'imgFromName: findByName');
+                    log.debug({imgTag: imgTag},
+                        '_imgFromNameV2: found matching imgTag');
                     next();
                 }
             });
@@ -533,51 +595,40 @@ function imgFromName(opts, callback) {
 
         function findImage(_, next) {
             var filter = [];
-            if (imgUuid) {
-                // We've found an imgTag, get the `Image` for it.
-                filter.push(
-                    {image_uuid: imgUuid, owner_uuid: opts.account.uuid});
-            } else if (/^[0-9a-f]+$/.test(name) && name.length <= 64) {
-                // Else, could possibly be an imgId, search for that.
-                if (name.length === 64) {
-                    filter.push(
-                        {docker_id: name, owner_uuid: opts.account.uuid});
-                } else {
-                    filter.push(
-                        {docker_id: name + '*', owner_uuid: opts.account.uuid});
-                }
+            if (imgTag) {
+                // We've found an imgTag, get the `ImageV2` for it.
+                filter.push({
+                    digest: imgTag.digest,
+                    owner_uuid: opts.account.uuid
+                });
+            } else if (/^sha256:[0-9a-f]+$/.test(name)) {
+                // Else, could possibly be a digest, search for that.
+                filter.push({
+                    digest: name + '*',
+                    owner_uuid: opts.account.uuid
+                });
+            } else if (/^[0-9a-f]+$/.test(name)) {
+                // Else, could possibly be a docker Id, search for that.
+                filter.push({
+                    digest: 'sha256:' + name + '*',
+                    owner_uuid: opts.account.uuid
+                });
             } else {
                 next();
                 return;
             }
-            if (opts.index_name) {
-                filter[0].index_name = opts.index_name;
-            }
 
-            Image.list(opts.app, log, filter, function (err, imgs) {
+            ImageV2.list(opts.app, log, filter, function (err, imgs) {
                 if (err || imgs.length === 0) {
                     /*jsl:pass*/
                 } else if (imgs.length === 1) {
                     img = imgs[0];
                     log.debug({imgName: name, img: img},
-                        'imgFromName: findImage');
+                        '_imgFromNameV2: findImage');
                 } else {
-                    var imgIds = {};
-                    var indexNames = [];
-                    for (var i = 0; i < imgs.length; i++) {
-                        var ix = imgs[i];
-                        imgIds[ix.docker_id] = true;
-                        indexNames.push(ix.index_name);
-                    }
-                    if (Object.keys(imgIds).length === 1) {
-                        assert.ok(indexNames.length > 1);
-                        /*
-                         * We have multiple hits for a single imgId, this is
-                         * ambiguity case #2 described above.
-                         */
-                        err = new errors.AmbiguousDockerImageIdError(
-                            name, indexNames);
-                    }
+                    // Docker gives a 404 if multiple images are matched.
+                    next(true);  /* early abort */
+                    return;
                 }
                 next(err);
             });
@@ -612,8 +663,9 @@ function imgFromName(opts, callback) {
 
             log.debug({imgIsGone: imgIsGone, img: img},
                 'imgFromName: delImgRef');
-            Image.del(opts.app, log, img, next);
+            ImageV2.del(opts.app, log, img, next);
         },
+
         function delImgTagRef(_, next) {
             assert.ok(imgIsGone);
             if (!imgTag) {
@@ -622,7 +674,7 @@ function imgFromName(opts, callback) {
 
             log.debug({imgIsGone: imgIsGone, imgTag: imgTag},
                 'imgFromName: delImgTagRef');
-            ImageTag.del(opts.app, log, imgTag, next);
+            ImageTagV2.del(opts.app, log, imgTag, next);
         }
 
     ]}, function (err) {
@@ -639,247 +691,1217 @@ function imgFromName(opts, callback) {
     });
 }
 
-
 /**
- * Return the docker `Image` model for the given IMGAPI uuid.
- *
- * @param {String} image_uuid The IMGAPI uuid.
- * @param {Object} opts
- * @param {Object} opts.account User account object
- * @param {Object} opts.app App instance
- * @param {Object} opts.log Bunyan log instance
+ * Ambiguity notes (**only applies to v1 images**):
  *
- * @param callback {Function} `function (err, image)`
- *      On success: `err` is null, `image` is an Image model object.
- *      On error: `err` is an error object.
+ * 1. One form of ambiguity is if an imgId prefix matches more than one imgId.
+ *    For this case, this function returns no imgTag.
+ * 2. There is another form. Because SDC's design of keeping Docker images from
+ *    different registry hosts separate, even if they have the same imgId, we
+ *    have a potential confusion for users and an *inherent ambiguity in
+ *    referring to images by imgId*. E.g., the same busybox image pulled from
+ *    docker.io and from quay.io will have the same imgId, but different
+ *    imgUuid in SDC. For now, if such an ambiguity comes up we'll return
+ *    an error here: `AmbiguousDockerImageIdError`.
  */
-function getDockerImageForUuid(image_uuid, opts, callback) {
-    assert.string(image_uuid, 'image_uuid');
-    assert.object(opts, 'opts');
-    assert.object(opts.account, 'opts.account');
-    assert.object(opts.app, 'opts.app');
-    assert.object(opts.log, 'opts.log');
-
+function _imgFromNameV1(opts, callback) {
+    var imgTag;
     var img;
-    var imgapi = opts.app.imgapi;
+    var imgIsGone = false;
     var log = opts.log;
+    var name = opts.rat.localName;
+    var tag = opts.rat.tag;
 
-    vasync.pipeline({arg: {}, funcs: [
-        findImage,
-        checkImageInImgapi
-    ]}, function (err) {
-        if (err) {
-            callback(err);
-            return;
-        }
-        callback(null, img);
-    });
+    var imgapiOpts = common.objCopy(opts.app.config.imgapi);
+    imgapiOpts.headers = { 'x-request-id': log.fields.req_id };
+    var imgapi = new IMGAPI(imgapiOpts);
 
-    // Find the image in the sdc-docker database.
-    function findImage(_, next) {
-        var filter = [
-            {image_uuid: image_uuid, owner_uuid: opts.account.uuid}
-        ];
-        Image.list(opts.app, log, filter, function (err, imgs) {
-            if (err) {
-                next(err);
-                return;
+    vasync.pipeline({funcs: [
+        function findByName(_, next) {
+            var filter = [
+                {repo: name, owner_uuid: opts.account.uuid, tag: tag}
+            ];
+            if (opts.index_name) {
+                filter[0].index_name = opts.index_name;
             }
-            if (imgs.length === 0) {
-                next(new errors.ResourceNotFoundError(
-                    'No image with image_uuid: ' + image_uuid));
+            ImageTag.list(opts.app, log, filter, function (err, imgTags) {
+                if (err) {
+                    next(err);
+                } else if (imgTags.length === 0) {
+                    next();
+                } else {
+                    imgTag = imgTags[0];
+                    log.debug({imgName: name, imgTag: imgTag},
+                        '_imgFromNameV1: findByName');
+                    next();
+                }
+            });
+        },
+
+        function findImage(_, next) {
+            var filter = [];
+            if (imgTag) {
+                // We've found an imgTag, get the `Image` for it.
+                filter.push({docker_id: imgTag.docker_id,
+                    owner_uuid: opts.account.uuid});
+            } else if (/^[0-9a-f]+$/.test(name) && name.length <= 64) {
+                // Else, could possibly be an imgId, search for that.
+                if (name.length === 64) {
+                    filter.push(
+                        {docker_id: name, owner_uuid: opts.account.uuid});
+                } else {
+                    filter.push(
+                        {docker_id: name + '*', owner_uuid: opts.account.uuid});
+                }
+            } else {
+                next();
                 return;
             }
-            if (imgs.length > 1) {
-                next(new errors.DockerError('Error - multiple images found '
-                    + 'with the same image_uuid: ' + image_uuid));
-                return;
+            if (opts.index_name) {
+                filter[0].index_name = opts.index_name;
             }
-            img = imgs[0];
-            log.debug({img: img}, 'getDockerImageForUuid: findImage');
-            next(null, img);
-        });
-    }
 
-    // Check that the image is also in imgapi.
-    function checkImageInImgapi(_, next) {
-        assert.object(img, 'img');
-        imgapi.getImage(image_uuid, function (err, imgapiImg) {
-            if (err) {
-                if (err.statusCode === 404) {
-                    next(new errors.ResourceNotFoundError(
-                        'No imgapi image with image_uuid: ' + image_uuid));
-                    return;
+            Image.list(opts.app, log, filter, function (err, imgs) {
+                if (err || imgs.length === 0) {
+                    /*jsl:pass*/
+                } else if (imgs.length === 1) {
+                    img = imgs[0];
+                    log.debug({imgName: name, img: img},
+                        '_imgFromNameV1: findImage');
+                } else {
+                    var imgIds = {};
+                    var indexNames = [];
+                    for (var i = 0; i < imgs.length; i++) {
+                        var ix = imgs[i];
+                        imgIds[ix.docker_id] = true;
+                        indexNames.push(ix.index_name);
+                    }
+                    if (Object.keys(imgIds).length === 1) {
+                        assert.ok(indexNames.length > 1);
+                        /*
+                         * We have multiple hits for a single imgId, this is
+                         * ambiguity case #2 described above.
+                         */
+                        err = new errors.AmbiguousDockerImageIdError(
+                            name, indexNames);
+                    }
                 }
                 next(err);
-                return;
+            });
+        },
+
+        function isImageInImgapi(_, next) {
+            if (!img) {
+                return next(true); // early abort
             }
-            next();
-        });
-    }
-}
 
+            imgapi.getImage(img.image_uuid, function (err, imgapiImg) {
+                if (err) {
+                    if (err.statusCode === 404) {
+                        imgIsGone = true;
+                        next();
+                    } else {
+                        next(err);
+                    }
+                } else {
+                    next(true); // early abort
+                }
+            });
+        },
+
+        /*
+         * If we get here then we found an `img`, but it isn't in IMGAPI
+         * (`imgIsGone`). We need to clear these refs from the sdc-docker DB.
+         */
+        function delImgRef(_, next) {
+            assert.ok(img);
+            assert.ok(imgIsGone);
+
+            log.debug({imgIsGone: imgIsGone, img: img},
+                '_imgFromNameV1: delImgRef');
+            Image.del(opts.app, log, img, next);
+        },
+        function delImgTagRef(_, next) {
+            assert.ok(imgIsGone);
+            if (!imgTag) {
+                return next();
+            }
+
+            log.debug({imgIsGone: imgIsGone, imgTag: imgTag},
+                '_imgFromNameV1: delImgTagRef');
+            ImageTag.del(opts.app, log, imgTag, next);
+        }
+
+    ]}, function (err) {
+        if (err === true) { /* the signal for an early abort */
+            err = null;
+        }
+        if (err) {
+            callback(err);
+        } else if (imgIsGone) {
+            callback(null);
+        } else {
+            callback(null, img, imgTag);
+        }
+    });
+}
 
 /**
- * Return the history of the given image. This is an ordered array of
- * `Image` model instances starting from the given image, followed by its
- * parent, and so on.
+ * Find the img (an 'Image' or 'ImageV2' model object instance) for the named
+ * Docker image (and for the given account).
+ *
+ * Given a name, e.g. 'cafe', that could be either a name or an id prefix,
+ * Docker semantics say that *name* wins. That means we need to lookup by
+ * name first, then fallback to imgId prefix.
+ *
+ * Theoretically, it is *sdc-docker's* data in moray that determines if a
+ * particular image exists. However, the images (layers) are stored in IMGAPI
+ * and can (whether by accident or not) be removed from IMGAPI without
+ * sdc-docker knowing it. If the image is found in sdc-docker's database, but
+ * is not in IMGAPI, then the sdc-docker DB entry will be removed to lazily
+ * clean up.
+ *
+ * Also, optionally (if `includeSmartos=true`), if a UUID for a SmartOS image
+ * in the DC's IMGAPI is given, this returns a fake 'Image' model object
+ * representing that IMGAPI image.
  *
  * @param {Object} opts
  * @param {Object} opts.app App instance
  * @param {Object} opts.log Bunyan log instance
- * @param {String} opts.img The `Image` instance for which to get the history,
- *      e.g. from `imgFromName`.
+ * @param {String} opts.name An imgId, imgId prefix or image
+ *      [REGHOST]NAME[:TAG] name.
  * @param {Object} opts.account
- * @param callback {Function} `function (err, history)`
- *      On success: err is null, `history` is an array of image objects (as
- *      from `imgFromImgInfo`). On error: `err` is an error object and
- *      history is *the history determined up to the failure*.
+ * @param {Boolean} opts.index_name Optional. Used to avoid duplicate images.
+ * @param {Boolean} opts.includeSmartos Optional. Default false. Set to true
+ *      to include (faux) results
+ * @param callback {Function} `function (err, img, imgTag)`
+ *      `img` is an `Image` or `ImageV2` instance or will be undefined if no
+ *      matching image or no *unambiguous* match was found.
+ *      `imgTag` will be the `ImageTag` instance for `name` iff it was found
+ *      by name. E.g. if `name` is an imgId, then `imgTag` will be undefined.
  */
-function getImageHistory(opts, callback) {
-    assert.object(opts, 'opts');
+function imgFromName(opts, callback) {
     assert.object(opts.app, 'opts.app');
     assert.object(opts.log, 'opts.log');
-    assert.object(opts.img, 'opts.img');
+    assert.string(opts.name, 'opts.name');
     assert.object(opts.account, 'opts.account');
+    assert.optionalString(opts.index_name, 'opts.index_name');
+    assert.optionalBool(opts.includeSmartos, 'opts.includeSmartos');
+    var log = opts.log;
 
-    var history = [];
+    try {
+        var rat = drc.parseRepoAndTag(opts.name);
+    } catch (e) {
+        callback(new errors.DockerError(e, e.message));
+        return;
+    }
 
-    function addAndGetNextItem(img) {
-        history.push(img);
+    var imgTag;
+    var img;
+    var name = rat.localName;
 
-        if (!img.parent) {
-            callback(null, history);
-            return;
-        }
+    var imgapiOpts = common.objCopy(opts.app.config.imgapi);
+    imgapiOpts.headers = { 'x-request-id': log.fields.req_id };
+    var imgapi = new IMGAPI(imgapiOpts);
 
-        imgFromImgInfo({
-            app: opts.app,
-            log: opts.log,
-            account: opts.account,
-            indexName: img.index_name,
-            imgId: img.parent
-        }, function (err, parentImg) {
-            if (err) {
-                callback(err, history);
-            } else {
-                addAndGetNextItem(parentImg);
+    vasync.pipeline({funcs: [
+        function findUuidInImgapi(_, next) {
+            if (!opts.includeSmartos || !common.isUUID(name)) {
+                next();
+                return;
             }
-        });
-    }
 
-    addAndGetNextItem(opts.img);
-}
+            var acct = opts.account.uuid;
+            var getOpts = {
+                os: 'smartos',
+                state: 'active'
+            };
+            imgapi.getImage(name, acct, getOpts, function (err, imgapiImg) {
+                if (err) {
+                    if (err.statusCode === 404) {
+                        next();
+                    } else {
+                        next(err);
+                    }
+                    return;
+                }
+                log.debug({imgName: name, imgapiImg: imgapiImg},
+                    'imgFromName: findUuidInImgapi');
+                // A faux `Image` model object for this IMGAPI image.
+                img = {
+                    image_uuid: imgapiImg.uuid,
+                    os: imgapiImg.os
+                };
+                next(true);  /* early abort */
+            });
+        },
+
+        function findByManifestDigest(_, next) {
+            // Check if this a lookup by docker manifest digest.
+            if (!rat.digest) {
+                next();
+                return;
+            }
+            var dockerImageOpts = {
+                account: opts.account,
+                app: opts.app,
+                manifestDigest: rat.digest,
+                log: log
+            };
+            imgFromManifestDigest(dockerImageOpts,
+                function _imgFromDigestCb(err, _img) {
+                    if (_img && !err) {
+                        img = _img;
+                        next(true);  /* early abort */
+                        return;
+                    }
+                    next(err);
+                }
+            );
+        },
+
+        function findByImageDigest(_, next) {
+            // Check if this a lookup by docker image digest.
+            if (opts.name.length !== (64 + 7)
+                    || opts.name.substr(0, 7) !== 'sha256:') {
+                next();
+                return;
+            }
+            var dockerImageOpts = {
+                account: opts.account,
+                app: opts.app,
+                digest: opts.name,
+                log: log
+            };
+            imgFromDigest(dockerImageOpts,
+                function _imgFromDigestCb(err, _img) {
+                    if (_img && !err) {
+                        img = _img;
+                        next(true);  /* early abort */
+                        return;
+                    }
+                    next(err);
+                }
+            );
+        },
+
+        function findByNameV2(_, next) {
+            var v2Opts = common.objCopy(opts);
+            v2Opts.rat = rat;
+            v2Opts.imgapi = imgapi;
+            _imgFromNameV2(v2Opts, function (err, _img, _imgTag) {
+                img = _img;
+                imgTag = _imgTag;
+                if (img && !err) {
+                    next(true);  /* early abort */
+                    return;
+                }
+                next(err);
+            });
+        },
+
+        function findByNameV1(_, next) {
+            var v1Opts = common.objCopy(opts);
+            v1Opts.rat = rat;
+            v1Opts.imgapi = imgapi;
+            _imgFromNameV1(v1Opts, function (err, _img, _imgTag) {
+                img = _img;
+                imgTag = _imgTag;
+                next(err);
+            });
+        }
+    ]}, function (err) {
+        if (err === true) { /* the signal for an early abort */
+            err = null;
+        }
+        if (err) {
+            callback(err);
+        } else {
+            callback(null, img, imgTag);
+        }
+    });
+}
 
 
 /**
- * Find the special scratch docker image and callback with the image details.
+ * Return the docker `ImageV2` model for the given docker manifest digest.
  *
- * @param {Object} opts.req Request object.
- * @param callback {Function} `function (err, img)`
+ * @param {Object} opts
+ * @param {Object} opts.account User account object
+ * @param {Object} opts.app App instance
+ * @param {String} opts.manifestDigest The docker manifest digest.
+ * @param {Object} opts.log Bunyan log instance
+ *
+ * @param callback {Function} `function (err, image)`
+ *      On success: `err` is null, `image` is an ImageV2 model object.
+ *      On error: `err` is an error object.
  */
-function getScratchImage(req, callback) {
-    // Only need to find the image once - it should not change for the life of
-    // this process.
-    if (gScratchImage !== null) {
-        callback(null, gScratchImage);
-        return;
+function imgFromManifestDigest(opts, callback) {
+    assert.object(opts, 'opts');
+    assert.object(opts.account, 'opts.account');
+    assert.object(opts.app, 'opts.app');
+    assert.string(opts.manifestDigest, 'opts.manifestDigest');
+    assert.object(opts.log, 'opts.log');
+
+    var img;
+    var imgapi = opts.app.imgapi;
+    var log = opts.log;
+    var manifestDigest = opts.manifestDigest;
+
+    vasync.pipeline({arg: {}, funcs: [
+        findImage,
+        checkImageInImgapi
+    ]}, function (err) {
+        if (err) {
+            callback(err);
+            return;
+        }
+        callback(null, img);
+    });
+
+    // Find the image in the sdc-docker database.
+    function findImage(_, next) {
+        var filter = [
+            {manifest_digest: manifestDigest, owner_uuid: opts.account.uuid}
+        ];
+        ImageV2.list(opts.app, log, filter, function (err, imgs) {
+            if (err) {
+                next(err);
+                return;
+            }
+            if (imgs.length === 0) {
+                next(new errors.ResourceNotFoundError(
+                    'No image with manifest digest: ' + manifestDigest));
+                return;
+            }
+            if (imgs.length > 1) {
+                log.warn({imgs: imgs},
+                    'Multiple images found with same manifestDigest');
+                next(new errors.DockerError(
+                    'Error - multiple images with the same manifest digest: '
+                    + manifestDigest));
+                return;
+            }
+            img = imgs[0];
+            log.debug({img: img}, 'imgFromDigest: found img');
+            next(null, img);
+        });
     }
 
-    var app = req.app;
-    var imgapi = app.imgapi;
-    var log = req.log;
-    var imageJsonPath = path.normalize(
-        __dirname + '/../../../etc/scratch_image.json');
-    var imageTarPath = path.normalize(
-        __dirname + '/../../../etc/scratch_image.tar');
-    var imageJson = JSON.parse(fs.readFileSync(imageJsonPath, 'utf8'));
-    var req_id = req.getId();
+    // Check that the image is also in imgapi.
+    function checkImageInImgapi(_, next) {
+        assert.object(img, 'img');
+        imgapi.getImage(img.image_uuid, function (err) {
+            if (err) {
+                if (err.statusCode === 404) {
+                    next(new errors.ResourceNotFoundError(
+                        'No imgapi image with image_uuid: ' + img.image_uuid));
+                    return;
+                }
+                next(err);
+                return;
+            }
+            next();
+        });
+    }
+}
 
-    var rat = {
-        localName: '',
-        index: { name: 'docker.io' }
-    };
 
-    // Determine if the scratch image has been imported into IMGAPI.
-    var imageUuid = imgmanifest.imgUuidFromDockerInfo({
-        id: imageJson.id,
-        indexName: rat.index.name
-    });
+/**
+ * Return the docker `ImageV2` model for the given docker image digest.
+ *
+ * @param {Object} opts
+ * @param {Object} opts.account User account object
+ * @param {Object} opts.app App instance
+ * @param {String} opts.digest The docker image digest.
+ * @param {Object} opts.log Bunyan log instance
+ *
+ * @param callback {Function} `function (err, image)`
+ *      On success: `err` is null, `image` is an ImageV2 model object.
+ *      On error: `err` is an error object.
+ */
+function imgFromDigest(opts, callback) {
+    assert.object(opts, 'opts');
+    assert.object(opts.account, 'opts.account');
+    assert.object(opts.app, 'opts.app');
+    assert.string(opts.digest, 'opts.digest');
+    assert.object(opts.log, 'opts.log');
+
+    var digest = opts.digest;
+    var img;
+    var imgapi = opts.app.imgapi;
+    var log = opts.log;
 
     vasync.pipeline({arg: {}, funcs: [
-        imgapiFindScratchImage,
-        imgapiCreateScratchImage,
-        imgapiImportScratchImage,
-        imgapiActivateScratchImage
+        findImage,
+        checkImageInImgapi
     ]}, function (err) {
-        if (err === true) { /* the signal for an early abort */
-            err = null;
-        }
         if (err) {
             callback(err);
             return;
         }
-        var result = imageJsonToModel();
-        callback(null, result);
+        callback(null, img);
     });
 
-    function imgapiFindScratchImage(ctx, next) {
-        imgapi.getImage(imageUuid, function (err, imgapiImg) {
+    // Find the image in the sdc-docker database.
+    function findImage(_, next) {
+        var filter = [
+            {digest: digest, owner_uuid: opts.account.uuid}
+        ];
+        ImageV2.list(opts.app, log, filter, function (err, imgs) {
+            if (err) {
+                next(err);
+                return;
+            }
+            if (imgs.length === 0) {
+                next(new errors.ResourceNotFoundError(
+                    'No image with digest: ' + digest));
+                return;
+            }
+            if (imgs.length > 1) {
+                log.warn({imgs: imgs},
+                    'Multiple images found with same digest');
+                next(new errors.DockerError(
+                    'Error - multiple images found with the same digest: '
+                    + digest));
+                return;
+            }
+            img = imgs[0];
+            log.debug({img: img}, 'imgFromDigest: found img');
+            next(null, img);
+        });
+    }
+
+    // Check that the image is also in imgapi.
+    function checkImageInImgapi(_, next) {
+        assert.object(img, 'img');
+        imgapi.getImage(img.image_uuid, function (err) {
+            if (err) {
+                if (err.statusCode === 404) {
+                    next(new errors.ResourceNotFoundError(
+                        'No imgapi image with image_uuid: ' + img.image_uuid));
+                    return;
+                }
+                next(err);
+                return;
+            }
+            next();
+        });
+    }
+}
+
+
+/**
+ * Return the ancestry of the given image. This is an ordered array of
+ * `Image` model instances starting from the given image, followed by its
+ * parent, and so on.
+ *
+ * @param {Object} opts
+ * @param {Object} opts.app App instance
+ * @param {Object} opts.log Bunyan log instance
+ * @param {String} opts.img The `Image` instance for which to get the history,
+ *      e.g. from `imgFromName`.
+ * @param {Object} opts.account
+ * @param callback {Function} `function (err, ancestry, isPartialAncestry)`
+ *      On success: err is null, `history` is an array of image objects.
+ *      Note that it's possible that an image parent lookup may fail (we don't
+ *      have that parent image) at which point the image ancestry lookup will
+ *      stop and return the images is has up to that point, and
+ *      isPartialAncestry will be set to true.
+ */
+function getImageAncestry(opts, callback) {
+    assert.object(opts, 'opts');
+    assert.object(opts.app, 'opts.app');
+    assert.object(opts.log, 'opts.log');
+    assert.object(opts.img, 'opts.img');
+    assert.object(opts.account, 'opts.account');
+
+    var ancestry = [];
+
+    function checkAndCallback(err) {
+        if (err) {
+            if (err.restCode === 'ResourceNotFound' && ancestry.length >= 1) {
+                // It's okay, we didn't find a parent image, but we did find
+                // *some* images - that's expected in some cases.
+                callback(null, ancestry, true);
+                return;
+            }
+            callback(err);
+            return;
+        }
+        callback(null, ancestry, false);
+    }
+
+    function addAndGetNextItem(img) {
+        ancestry.push(img);
+
+        if (!img.parent) {
+            checkAndCallback(null);
+            return;
+        }
+
+        if (isV1Image(img)) {
+            imgFromImgInfoV1({
+                app: opts.app,
+                log: opts.log,
+                account: opts.account,
+                indexName: img.index_name,
+                imgId: img.parent
+            }, function (err, parentImg) {
+                if (err) {
+                    checkAndCallback(err);
+                } else {
+                    addAndGetNextItem(parentImg);
+                }
+            });
+            return;
+        }
+
+        imgFromImgInfoV2({
+            app: opts.app,
+            log: opts.log,
+            account: opts.account,
+            digest: img.parent
+        }, function (err, parentImg) {
+            if (err) {
+                checkAndCallback(err);
+            } else {
+                addAndGetNextItem(parentImg);
+            }
+        });
+
+    }
+
+    addAndGetNextItem(opts.img);
+}
+
+
+/**
+ * Return the docker history of the given image. This is an ordered array of
+ * changes made to the image, with the first change being at the end of the
+ * array. Each history entry is an object containing these fields:
+ *   {
+ *       Id: <string>
+ *       Created: <timestamp>,
+ *       CreatedBy: <author string>,
+ *       Size: <number>
+ *   }
+ *
+ * @param {Object} opts
+ * @param {Object} opts.app App instance
+ * @param {Object} opts.log Bunyan log instance
+ * @param {String} opts.img The `Image` instance for which to get the history,
+ *      e.g. from `imgFromName`.
+ * @param {Object} opts.account
+ * @param callback {Function} `function (err, history)`
+ *      On success: err is null, `history` is an array of image objects (as
+ *      from `imgFromImgInfo`). On error: `err` is an error object and
+ *      history is *the history determined up to the failure*.
+ */
+function getImageHistory(opts, callback) {
+    assert.object(opts, 'opts');
+    assert.object(opts.account, 'opts.account');
+    assert.object(opts.app, 'opts.app');
+    assert.object(opts.img, 'opts.img');
+    assert.object(opts.log, 'opts.log');
+
+    var history = [];
+
+    getImageAncestry(opts, function (err, ancestry) {
+        if (err) {
+            callback(err);
+            return;
+        }
+
+        // Get tags for the found images.
+        vasync.forEachPipeline({
+            inputs: ancestry,
+            func: function lookupAncestorTags(img, next) {
+                var createdBy = '';
+                if (img.container_config && img.container_config.Cmd) {
+                    createdBy = img.container_config.Cmd.join(' ');
+                }
+                var entry = {
+                    Id: img.digest || img.docker_id,
+                    Created: img.created,
+                    CreatedBy: createdBy,
+                    Size: img.size
+                };
+                history.push(entry);
+                tagsForImage(img, opts, function (tagErr, imgTags) {
+                    if (imgTags) {
+                        entry.Tags = imgTags.map(function _imgTagsMap(it) {
+                            return it.repo + ':' + it.tag;
+                        });
+                    }
+                    next();
+                });
+            }
+        }, function (pipeErr) {
+            if (pipeErr) {
+                callback(pipeErr);
+                return;
+            }
+
+            if (isV1Image(opts.img)) {
+                callback(null, history);
+                return;
+            }
+
+            // The V2 image has the full history on the ImageV2 instance, so use
+            // that history info to fill in any blanks (missing images).
+            var imgHist = opts.img.history;
+            if (imgHist.length > history.length) {
+                imgHist.slice(0, -(history.length)).reverse().map(function (h) {
+                    history.push({
+                        Id: '<missing>',
+                        Comment: h.comment || '',
+                        // Created needs to be epoch time in seconds, currenty:
+                        //   "2016-10-07T21:03:58.16783626Z"
+                        Created: Math.floor(
+                            (new Date(h.created)).getTime() / 1000),
+                        CreatedBy: h.created_by,
+                        Size: h.size || 0,
+                        Tags: null
+                    });
+                });
+            }
+
+            assert.equal(history.length, imgHist.length,
+                'History length should be equal');
+            callback(null, history);
+        });
+    });
+}
+
+
+/**
+ * Find the special scratch docker image and callback with the image details.
+ *
+ * @param {Object} opts.req Request object.
+ * @param callback {Function} `function (err, img)`
+ */
+function getScratchImage(req, callback) {
+    // Only need to find the image once - it should not change for the life of
+    // this process.
+    if (gScratchImage !== null) {
+        callback(null, gScratchImage);
+        return;
+    }
+
+    var app = req.app;
+    var imgapi = app.imgapi;
+    var log = req.log;
+    var imageJsonPath = path.normalize(
+        __dirname + '/../../../etc/scratch_image.json');
+    var imageManifestPath = path.normalize(
+        __dirname + '/../../../etc/scratch_image.manifest');
+    var imageTarPath = path.normalize(
+        __dirname + '/../../../etc/scratch_image.tar');
+    var imageStr = fs.readFileSync(imageJsonPath, 'utf8');
+    var imageJson = JSON.parse(imageStr);
+    var manifestStr = fs.readFileSync(imageManifestPath, 'utf8');
+    var manifest = JSON.parse(manifestStr);
+    var req_id = req.getId();
+
+    var rat = {
+        localName: '',
+        index: { name: 'docker.io' }
+    };
+
+    // Determine if the scratch image has been imported into IMGAPI.
+    var size = 0;
+    var layerDigests = manifest.layers.map(function (layer) {
+        size += layer.size;
+        return layer.digest;
+    });
+    var imageUuid = imgmanifest.imgUuidFromDockerDigests(layerDigests);
+    log.debug({uuid: imageUuid}, 'creating IMGAPI scratch image');
+
+    vasync.pipeline({arg: {}, funcs: [
+        imgapiFindScratchImage,
+        imgapiCreateScratchImage,
+        imgapiImportScratchImage,
+        imgapiActivateScratchImage
+    ]}, function (err) {
+        if (err === true) { /* the signal for an early abort */
+            err = null;
+        }
+        if (err) {
+            callback(err);
+            return;
+        }
+        var result = imageJsonToModel();
+        callback(null, result);
+    });
+
+    function imgapiFindScratchImage(ctx, next) {
+        imgapi.getImage(imageUuid, function (err, imgapiImg) {
+            if (err) {
+                if (err.statusCode === 404) { // no such image
+                    next();
+                } else {
+                    next(err);
+                }
+                return;
+            }
+            log.debug('getScratchImage: found scratch image in IMGAPI');
+            next(true);  /* early abort */
+        });
+    }
+
+    function imgapiCreateScratchImage(ctx, next) {
+        var opts = {
+            layerDigests: layerDigests,
+            rat: rat,
+            req: req
+        };
+        log.debug('getScratchImage: creating new scratch image in IMGAPI');
+        createImgapiDockerImage(imageJson, opts, function (err) {
+            next(err);
+        });
+    }
+
+    function imgapiImportScratchImage(ctx, next) {
+        var opts = {
+            'compression': 'none',
+            file: imageTarPath,
+            headers: { 'x-request-id': req_id },
+            uuid: imageUuid
+        };
+        log.debug('getScratchImage: importing scratch image file into IMGAPI');
+        imgapi.addImageFile(opts, next);
+    }
+
+    function imgapiActivateScratchImage(ctx, next) {
+        var opts = {
+            headers: { 'x-request-id': req_id }
+        };
+        log.debug('getScratchImage: imgapi.activateImage');
+        imgapi.activateImage(imageUuid, undefined, opts, next);
+    }
+
+    function imageJsonToModel() {
+        var manifestDigest = 'sha256' + (new crypto.Hash('sha256')).
+            update(manifestStr, 'binary').digest('hex');
+        var modelOpts = {
+            digest: manifest.config.digest,
+            head: true,
+            image_uuid: imageUuid,
+            manifest_str: manifestStr,
+            manifest_digest: manifestDigest,
+            size: size
+        };
+        return dockerImageJsonToModel(imageJson, modelOpts);
+    }
+}
+
+
+/* BEGIN JSSTYLED */
+/*
+ * Exploring `docker rmi ...` behaviour:
+ *
+
+$ docker history hello-world
+IMAGE               CREATED             CREATED BY                                      SIZE
+ef872312fe1b        7 months ago        /bin/sh -c #(nop) CMD [/hello]                  0 B
+7fa0dcdc88de        7 months ago        /bin/sh -c #(nop) ADD file:e524d9aa2d2d2b65c5   910 B
+511136ea3c5a        23 months ago
+
+ *
+ * - Docker: if a container is using that image, don't delete it.
+ *   SDC: We don't *need* to have that requirement. We can remove an image for
+ *   future provs, but current containers are fine. However, for now we'll
+ *   match that behaviour.
+ *
+
+$ docker rmi hello-world
+Error response from daemon: Conflict, cannot delete ef872312fe1b because the container 32a4a48c4b89 is using it, use -f to force
+FATA[0000] Error: failed to remove one or more images
+
+ *
+ * - '-f' will force remove that image even if a *stopped* container is using
+ *   it. It won't force remove an image with a *running* container using it.
+ *
+ *   TODO(trentm): Not sure this is accurate with subsequent 1.6.0 testing.
+ *      I was able to untag, but not delete the image id if there was a
+ *      stopped container.
+ *
+
+$ docker rmi -f hello-world
+Untagged: hello-world:latest
+Deleted: ef872312fe1bbc5e05aae626791a47ee9b032efa8f3bda39cc0be7b56bfe59b9
+Deleted: 7fa0dcdc88de9c8a856f648c1f8e0cf8141a505bbddb7ecc0c61f1ed5e086852
+
+ *
+ * - Note that the previous delete did not remove the 511136ea3c5a image
+ *   because it is used by other images.
+ *
+ * - Now that the image was force removed, in Docker-docker I can't start that
+ *   container
+ *
+
+$ docker start 32a4a48c4b89
+Error response from daemon: Cannot start container 32a4a48c4b89: Error getting container 32a4a48c4b8946bbf087930f5df9d55bed55ec2afa2d9cad16abb304edc11e5d from driver aufs: invalid argument
+FATA[0000] Error: failed to start one or more containers
+
+ *
+ * - If there are other tags on the image, then just untag it:
+ *
+
+$ docker rmi ef
+Untagged: ef:latest
+
+ *
+ * - Can't remove images that have children. This is effectively the same
+ *   thing as saying "non-head" images, as long as we trust we're keeping
+ *   our 'head' info up to date (in the Image model). Docker-docker's error
+ *   message leaves something to be desired. We'll do a little better.
+ *
+
+$ docker rmi b2eda1f5dec1
+Error response from daemon: Conflict, b2eda1f5dec1 wasn't deleted
+FATA[0000] Error: failed to remove one or more images
+
+ *
+ * - Deleting by imgId will will untag *all image tags to that id.
+ *
+
+$ docker rmi 156401cf89a1
+Untagged: postgres:9.1
+Untagged: postgres:9.1.14
+Deleted: 156401cf89a1e3486dfd2468aa55d807584ccdc6e122dc07fa0a7d1ddefd80e5
+...
+Deleted: 7ac189b455b8fd7704dde3cff6fcf940900c343e63c1d92558592959ce1a28aa
+
+*
+*    Unless that is tagged for separate repositories.
+*
+
+ubuntu@1fd15fd8-e5cd-6ef0-ab35-aae2181b7cd4:~$ docker images
+REPOSITORY                    TAG                 IMAGE ID            CREATED             VIRTUAL SIZE
+165.225.157.24:5001/busybox   latest              8c2e06607696        4 weeks ago         2.433 MB
+localhost:5001/busybox        latest              8c2e06607696        4 weeks ago         2.433 MB
+busybox                       latest              8c2e06607696        4 weeks ago         2.433 MB
+busybox                       trent               8c2e06607696        4 weeks ago         2.433 MB
+
+ubuntu@1fd15fd8-e5cd-6ef0-ab35-aae2181b7cd4:~$ docker rmi 8c2e06607696
+Error response from daemon: Conflict, cannot delete image 8c2e06607696 because it is tagged in multiple repositories, use -f to force
+FATA[0000] Error: failed to remove one or more images
+
+ *
+ * - TODO: Support 'noprune' option.
+ */
+/* END JSSTYLED */
+function _deleteImageV1(opts, callback) {
+    var DRY_RUN = false; // for development use only
+    var app = opts.app;
+    var dontDeleteImages = false; // Used when we just want to untag the image.
+    var log = opts.log;
+    var vmapi = getVmapiClient(app.config.vmapi);
+
+    var changes = [];
+
+    vasync.pipeline({arg: opts, funcs: [
+        ensureIsHeadImage,
+        getImgTags,
+        checkTagReferences,
+        verifyNotInUse,
+        getImgsToDelete,
+        getDatacenterRefcount,
+        untagHeads,
+        deleteImgs
+    ]}, function (err) {
+        callback(err, changes);
+    });
+
+    function ensureIsHeadImage(ctx, cb) {
+        if (ctx.img.head !== true) {
+            var heads = ctx.img.heads.map(function (imgId) {
+                return imgId.substr(0, 12);
+            }).join(', ');
+            var message = format('Conflict, %s wasn\'t deleted because it '
+                + 'is an intermediate layer being referenced by %s',
+                ctx.img.docker_id.substr(0, 12), heads);
+            cb(new errors.DockerError(message));
+        } else {
+            cb();
+        }
+    }
+
+    function getImgTags(ctx, cb) {
+        /*
+         * This is a head image, but we don't have an imgTag for it: IOW it
+         * was named by imgId. Find all imgTags for this guy for untagging.
+         *
+         * Note: if there are tags from more than one repository, then we
+         * should error out (see TODO above).
+         */
+        tagsForImage(ctx.img, {app: app, log: log, account: opts.account},
+                function (err, imgTags) {
+            if (err) {
+                cb(err);
+                return;
+            }
+            ctx.imgTags = imgTags;
+            cb();
+        });
+    }
+
+    function checkTagReferences(ctx, cb) {
+        // When an id (or prefix) is supplied, we can only remove the image if:
+        //   1) force is true, or
+        //   2) there is only one tag (or less) referencing this image
+        // else we can only remove the given tag (when the tag name is supplied)
+        // leaving the image (and any other tags) there.
+        log.debug({docker_id: ctx.img.docker_id, givenName: opts.name,
+            imgTags: ctx.imgTags}, 'deleteImage: checkTagReferences');
+        var givenName = opts.name;
+        if (ctx.img.docker_id.substr(0, givenName.length) === givenName) {
+            if (!opts.force && ctx.imgTags.length > 1) {
+                cb(new errors.DockerError(format('conflict: unable to delete '
+                    + '%s (must be forced) - image is referenced in one or '
+                    + 'more repositories', givenName)));
+                return;
+            }
+        } else if (ctx.imgTags.length > 1) {
+            // When a tag name is provided, if there are more than one tags we
+            // just want to untag the given one and leave the image and other
+            // tags still there.
+            assert.object(ctx.imgTag, 'ctx.imgTag');
+            dontDeleteImages = true;
+            ctx.imgTags = [ctx.imgTag];
+        }
+        cb();
+    }
+
+    function verifyNotInUse(ctx, cb) {
+        if (dontDeleteImages) {
+            cb();
+            return;
+        }
+
+        // If force === false this function will return an error if there is at
+        // least a running or stopped VM using the image.
+        // If force === true, it will return an error if there is at least a
+        // running VMusing the image
+        var query = {
+            docker: true,
+            state: (opts.force ? 'running' : 'active'),
+            image_uuid: ctx.img.image_uuid,
+            owner_uuid: opts.account.uuid
+        };
+
+        vmapi.listVms(query, {
+            headers: {'x-request-id': opts.req_id}
+        }, function (vmapiErr, vms) {
+            if (vmapiErr) {
+                cb(errors.vmapiErrorWrap(vmapiErr,
+                    'could not delete image'));
+                return;
+            } else if (vms.length === 0) {
+                cb();
+                return;
+            }
+
+            vms.sort(function (a, b) {
+                if (a.state < b.state)
+                    return -1;
+                if (a.state > b.state)
+                    return 1;
+                return 0;
+            });
+
+            var forceStr = opts.force ? 'force ' : '';
+            var messageFormat;
+            // If the vm is state=incomplete, we might not have
+            // internal_metadata.
+            var sId = utils.vmUuidToShortDockerId(vms[0].uuid);
+            if (vms[0].state === 'running') {
+                messageFormat = 'Conflict, cannot %sdelete %s because '
+                    + 'the running container %s is using it, stop it and '
+                    + 'use -f to force';
+            } else {
+                messageFormat = 'Conflict, cannot %sdelete %s because '
+                    + 'the container %s is using it, use -f to force';
+            }
+            var message = format(messageFormat, forceStr,
+                opts.name, sId);
+
+            cb(new errors.DockerError(message));
+        });
+    }
+
+    function getImgsToDelete(ctx, cb) {
+        getImageAncestry({
+            app: app,
+            log: log,
+            img: ctx.img,
+            account: opts.account
+        }, function (err, history, isPartialHistory) {
+            if (err) {
+                cb(new errors.DockerError(err, 'could not delete image'));
+            } else {
+                if (isPartialHistory) {
+                    /*
+                     * If we got a partial history, then carry on with the
+                     * delete. We don't want missing ancestry (e.g. due to
+                     * DOCKER-709) to block the user from deleting this
+                     * image.
+                     *
+                     * Only avenues to client-side output are 'Untagged' and
+                     * 'Deleted' keys.
+                     */
+                    log.warn({err: err, docker_id: ctx.img.docker_id},
+                        'deleteImage: getImgsToDelete: partial history');
+                    changes.push({ Deleted: format(
+                        'warning: %s missing some history: %s',
+                        opts.name, err) });
+                    ctx.imgsToDelete = history;
+                    cb();
+                }
+                ctx.imgsToDelete = history;
+                cb();
+            }
+        });
+    }
+
+    // Get all images that are ready to be deleted from IMGAPI.
+    function getDatacenterRefcount(ctx, cb) {
+        var params = {
+            index_name: ctx.img.index_name,
+            docker_id: ctx.img.docker_id,
+            limit: 1
+        };
+        Image.datacenterRefcount(app, log, params, function (err, count) {
+            if (err) {
+                cb(new errors.DockerError(err, 'could not delete image'));
+                return;
+            }
+            ctx.dcRefcount = count;
+            cb();
+        });
+    }
+
+    function untagHeads(ctx, cb) {
+        log.debug({imgTags: ctx.imgTags}, 'deleteImage: untagHeads');
+
+        vasync.forEachPipeline({
+            inputs: ctx.imgTags,
+            func: function untagOne(imgTag, nextImgTag) {
+                if (DRY_RUN) {
+                    changes.push({ Untagged: imgTag.repo + ':' + imgTag.tag });
+                    nextImgTag();
+                    return;
+                }
+                ImageTag.del(app, log, imgTag, function (err) {
+                    if (err) {
+                        nextImgTag(err);
+                    } else {
+                        changes.push({
+                            Untagged: imgTag.repo + ':' + imgTag.tag });
+                        nextImgTag();
+                    }
+                });
+            }
+        }, cb);
+    }
+
+    function deleteImgs(ctx, cb) {
+        if (dontDeleteImages) {
+            cb();
+            return;
+        }
+
+        vasync.forEachPipeline({
+            inputs: ctx.imgsToDelete,
+            func: deleteOneImg
+        }, function (err) {
             if (err) {
-                if (err.statusCode === 404) { // no such image
-                    next();
-                } else {
-                    next(err);
-                }
+                cb(new errors.DockerError(err, 'could not delete image'));
                 return;
             }
-            log.debug('getScratchImage: found scratch image in IMGAPI');
-            next(true);  /* early abort */
+            cb();
         });
-    }
 
-    function imgapiCreateScratchImage(ctx, next) {
-        var opts = {
-            rat: rat,
-            req: req
-        };
-        log.debug('getScratchImage: creating new scratch image in IMGAPI');
-        createImgapiDockerImage(imageJson, opts, function (err, imgapiImg) {
-            next(err);
-        });
-    }
+        /*
+         * `true` if we hit `ImageHasDependentImagesError` error from IMGAPI,
+         * in which case we'll not bother attempting to delete further b/c
+         * they'll hit the same error.
+         */
+        var hitImageHasDependentImagesError = false;
 
-    function imgapiImportScratchImage(ctx, next) {
-        var opts = {
-            'compression': 'none',
-            file: imageTarPath,
-            headers: { 'x-request-id': req_id },
-            uuid: imageUuid
-        };
-        log.debug('getScratchImage: importing scratch image file into IMGAPI');
-        imgapi.addImageFile(opts, next);
-    }
+        /*
+         * We only remove the image *ref* when it is no longer being
+         * used by the account. If this is the last usage of the image
+         * across the whole DC (dcRefcount===1), then actually delete
+         * from IMGAPI.
+         */
+        function deleteOneImg(img, nextImg) {
+            log.debug({imgId: img.docker_id, indexName: img.index_name},
+                'deleteImage: deleteOneImg');
+            if (DRY_RUN) {
+                changes.push({ Deleted: img.docker_id });
+                nextImg();
+                return;
+            }
 
-    function imgapiActivateScratchImage(ctx, next) {
-        var opts = {
-            headers: { 'x-request-id': req_id }
-        };
-        log.debug('getScratchImage: imgapi.activateImage');
-        imgapi.activateImage(imageUuid, undefined, opts, next);
-    }
+            if (img.refcount > 1) {
+                log.debug({imgId: img.docker_id, indexName: img.index_name},
+                    'deleteImage: remove %s from heads', ctx.img.docker_id);
+                var update = {
+                    owner_uuid: img.owner_uuid,
+                    index_name: img.index_name,
+                    docker_id: img.docker_id,
+                    // Update:
+                    heads: img.params.heads.filter(function (id) {
+                        return id !== ctx.img.docker_id;
+                    })
+                };
+                if (img.docker_id === ctx.img.docker_id) {
+                    /*
+                     * The Docker image being removed must no longer be
+                     * marked as a 'head', else it could be "deleted again"...
+                     * during which `dcRefcount` values are not valid. This
+                     * is DOCKER-709.
+                     */
+                    update.head = false;
+                }
+                Image.update(app, log, update, nextImg);
+            } else {
+                log.debug({imgId: img.docker_id, indexName: img.index_name},
+                    'deleteImage: delete image', ctx.img.docker_id);
+                Image.del(app, log, img, function (delErr) {
+                    if (delErr) {
+                        nextImg(delErr);
+                        return;
+                    }
 
-    function imageJsonToModel() {
-        var modelOpts = {
-            head: true,
-            heads: [],
-            image_uuid: imageUuid,
-            index_name: rat.index.name,
-            //owner_uuid: account_uuid,
-            size: 0,
-            virtual_size: 0
-        };
-        return dockerImageJsonToModel(imageJson, modelOpts);
+                    changes.push({ Deleted: img.docker_id });
+
+                    var isLastRef = (ctx.dcRefcount[img.docker_id]
+                                            !== undefined);
+                    if (!isLastRef || hitImageHasDependentImagesError) {
+                        nextImg();
+                        return;
+                    }
+
+                    log.debug({imgUuid: img.image_uuid},
+                        'deleteImage: delete imgapi image (last ref)');
+                    app.imgapi.deleteImage(img.image_uuid, {
+                        headers: {'x-request-id': opts.req_id}
+                    }, function (err) {
+                        if (err && err.restCode === 'ImageHasDependentImages') {
+                            hitImageHasDependentImagesError = true;
+                            log.info({imgUuid: img.image_uuid},
+                                'deleteImage: hit ImageHasDependentImages');
+                            err = null;
+                        }
+                        nextImg(err);
+                    });
+                });
+            }
+        }
     }
 }
 
@@ -980,84 +2002,35 @@ FATA[0000] Error: failed to remove one or more images
  * - TODO: Support 'noprune' option.
  */
 /* END JSSTYLED */
-function deleteImage(opts, callback) {
-    assert.object(opts, 'opts');
-    assert.optionalObject(opts.app, 'opts.app');
-    assert.bool(opts.force, 'opts.force');
-    assert.optionalObject(opts.log, 'opts.log');
-    assert.string(opts.name, 'opts.name');
-    assert.string(opts.req_id, 'opts.req_id');
-    assert.object(opts.account, 'opts.account');
-
+function _deleteImageV2(opts, callback) {
     var DRY_RUN = false; // for development use only
     var app = opts.app;
-    var dontDeleteImages = false; // Used when we just want to untag the image.
-    var log = opts.log;
-    var vmapi = getVmapiClient(this.config.vmapi);
     var changes = [];
-    log.debug({imgName: opts.name}, 'deleteImage');
+    var dockerId = imgmanifest.dockerIdFromDigest(opts.img.digest);
+    var log = opts.log;
+    var shortId = imgmanifest.shortDockerId(dockerId);
+    var vmapi = getVmapiClient(app.config.vmapi);
 
-    vasync.pipeline({arg: {}, funcs: [
-        getImg,
-        ensureIsHeadImage,
+    vasync.pipeline({arg: opts, funcs: [
         getImgTags,
         checkTagReferences,
+        checkJustUntagImage,
         verifyNotInUse,
         getImgsToDelete,
-        getDatacenterRefcount,
-        untagHeads,
-        deleteImgs
+        deleteDockerTags,
+        deleteImgapiLayers,
+        deleteDockerImages
     ]}, function (err) {
+        if (err === true) {
+            // Early abort marker.
+            err = null;
+        }
         callback(err, changes);
     });
 
-
-    function getImg(ctx, cb) {
-        imgFromName(opts, function (err, img, imgTag) {
-            if (err) {
-                cb(err);
-            } else if (!img) {
-                cb(new errors.ResourceNotFoundError(
-                    'No such image: ' + opts.name));
-            } else {
-                log.debug({img: img, imgTag: imgTag}, 'deleteImage: getImg');
-                ctx.img = img;
-                if (imgTag) {
-                    // Only set if `name` was not an imgId.
-                    ctx.imgTag = imgTag;
-                }
-                cb();
-            }
-        });
-    }
-
-    function ensureIsHeadImage(ctx, cb) {
-        if (ctx.img.head !== true) {
-            var heads = ctx.img.heads.map(function (imgId) {
-                return imgId.substr(0, 12);
-            }).join(', ');
-            var message = format('Conflict, %s wasn\'t deleted because it '
-                + 'is an intermediate layer being referenced by %s',
-                ctx.img.docker_id.substr(0, 12), heads);
-            cb(new errors.DockerError(message));
-        } else {
-            cb();
-        }
-    }
-
     function getImgTags(ctx, cb) {
-        /*
-         * This is a head image, but we don't have an imgTag for it: IOW it
-         * was named by imgId. Find all imgTags for this guy for untagging.
-         *
-         * Note: if there are tags from more than one repository, then we
-         * should error out (see TODO above).
-         */
-        var filter = {
-            docker_id: ctx.img.docker_id,
-            owner_uuid: opts.account.uuid
-        };
-        ImageTag.list(app, log, filter, function (err, imgTags) {
+        tagsForImage(ctx.img, {app: app, log: log, account: opts.account},
+                function (err, imgTags) {
             if (err) {
                 cb(err);
                 return;
@@ -1068,38 +2041,53 @@ function deleteImage(opts, callback) {
     }
 
     function checkTagReferences(ctx, cb) {
-        // When an id (or prefix) is supplied, we can only remove the image if:
-        //   1) force is true, or
-        //   2) there is only one tag (or less) referencing this image
-        // else we can only remove the given tag (when the tag name is supplied)
-        // leaving the image (and any other tags) there.
-        log.debug({docker_id: ctx.img.docker_id, givenName: opts.name,
+        // If there are multiple tags for this image, and the image was found
+        // using the digest (or digest prefix), we can only remove the image if
+        // force is set to true.
+        //
+        // Note: ctx.imgTag is only set if the image was found using the name
+        // and not the digest.
+        log.debug({digest: ctx.img.digest, givenName: opts.name,
             imgTags: ctx.imgTags}, 'deleteImage: checkTagReferences');
-        var givenName = opts.name;
-        if (ctx.img.docker_id.substr(0, givenName.length) === givenName) {
-            if (!opts.force && ctx.imgTags.length > 1) {
-                cb(new errors.DockerError(format('conflict: unable to delete '
-                    + '%s (must be forced) - image is referenced in one or '
-                    + 'more repositories', givenName)));
-                return;
-            }
-        } else if (ctx.imgTags.length > 1) {
-            // When a tag name is provided, if there are more than one tags we
-            // just want to untag the given one and leave the image and other
-            // tags still there.
-            assert.object(ctx.imgTag, 'ctx.imgTag');
-            dontDeleteImages = true;
-            ctx.imgTags = [ctx.imgTag];
+        if (!ctx.imgTag && !opts.force && ctx.imgTags.length > 1) {
+            cb(new errors.DockerError(format('conflict: unable to delete '
+                + '%s (must be forced) - image is referenced in one or '
+                + 'more repositories', shortId)));
+            return;
         }
         cb();
     }
 
-    function verifyNotInUse(ctx, cb) {
-        if (dontDeleteImages) {
-            cb();
+    function checkJustUntagImage(ctx, cb) {
+        // When a tag name is provided, if there are multiple tags for this
+        // image we just want to untag the given one and leave the image and
+        // other tags still there.
+        //
+        // Note: ctx.imgTag is only set if the image was found using the name
+        // and not the digest.
+        if (ctx.imgTag && ctx.imgTags.length > 1) {
+            if (DRY_RUN) {
+                changes.push({
+                    Untagged: ctx.imgTag.repo + ':' + ctx.imgTag.tag });
+                cb(true);
+                return;
+            }
+            ImageTagV2.del(app, log, ctx.imgTag, function (err) {
+                if (err) {
+                    cb(err);
+                } else {
+                    changes.push({
+                        Untagged: ctx.imgTag.repo + ':' + ctx.imgTag.tag });
+                    // Early abort - nothing more to do here.
+                    cb(true);
+                }
+            });
             return;
         }
+        cb();
+    }
 
+    function verifyNotInUse(ctx, cb) {
         // If force === false this function will return an error if there is at
         // least a running or stopped VM using the image.
         // If force === true, it will return an error if there is at least a
@@ -1137,74 +2125,49 @@ function deleteImage(opts, callback) {
             // internal_metadata.
             var sId = utils.vmUuidToShortDockerId(vms[0].uuid);
             if (vms[0].state === 'running') {
-                messageFormat = 'Conflict, cannot %sdelete %s because '
-                    + 'the running container %s is using it, stop it and '
-                    + 'use -f to force';
-            } else {
-                messageFormat = 'Conflict, cannot %sdelete %s because '
-                    + 'the container %s is using it, use -f to force';
-            }
-            var message = format(messageFormat, forceStr,
-                opts.name, sId);
-
-            cb(new errors.DockerError(message));
-        });
-    }
-
-    function getImgsToDelete(ctx, cb) {
-        getImageHistory({
-            app: app,
-            log: log,
-            img: ctx.img,
-            account: opts.account
-        }, function (err, history) {
-            if (err) {
-                if (history && Array.isArray(history) && history.length > 0) {
-                    /*
-                     * If we got a partial history, then carry on with the
-                     * delete. We don't want missing ancestry (e.g. due to
-                     * DOCKER-709) to block the user from deleting this
-                     * image.
-                     *
-                     * Only avenues to client-side output are 'Untagged' and
-                     * 'Deleted' keys.
-                     */
-                    log.warn({err: err, docker_id: ctx.img.docker_id},
-                        'deleteImage: getImgsToDelete: partial history');
-                    changes.push({ Deleted: format(
-                        'warning: %s missing some history: %s',
-                        opts.name, err) });
-                    ctx.imgsToDelete = history;
-                    cb();
-                } else {
-                    cb(new errors.DockerError(err, 'could not delete image'));
-                }
+                messageFormat = 'Conflict, cannot %sdelete %s because '
+                    + 'the running container %s is using it, stop it and '
+                    + 'use -f to force';
             } else {
-                ctx.imgsToDelete = history;
-                cb();
+                messageFormat = 'Conflict, cannot %sdelete %s because '
+                    + 'the container %s is using it, use -f to force';
             }
+            var message = format(messageFormat, forceStr,
+                opts.name, sId);
+
+            cb(new errors.DockerError(message));
         });
     }
 
-    // Get all images that are ready to be deleted from IMGAPI.
-    function getDatacenterRefcount(ctx, cb) {
-        var params = {
-            index_name: ctx.img.index_name,
-            docker_id: ctx.img.docker_id,
-            limit: 1
-        };
-        Image.datacenterRefcount(app, log, params, function (err, count) {
+    function getImgsToDelete(ctx, cb) {
+        getImageAncestry({
+            app: app,
+            log: log,
+            img: ctx.img,
+            account: opts.account
+        }, function (err, ancestry) {
             if (err) {
                 cb(new errors.DockerError(err, 'could not delete image'));
                 return;
             }
-            ctx.dcRefcount = count;
+
+            // Note: Don't delete an ancestor that is a head image.
+            var headFound = false;
+            ctx.imgsToDelete = [ancestry[0]].concat(ancestry.slice(1).
+                filter(function (_img) {
+                    headFound = headFound || _img.head;
+                    if (headFound) {
+                        return false;
+                    }
+                    return true;
+                }
+            ));
             cb();
         });
     }
 
-    function untagHeads(ctx, cb) {
-        log.debug({imgTags: ctx.imgTags}, 'deleteImage: untagHeads');
+    function deleteDockerTags(ctx, cb) {
+        log.debug({imgTags: ctx.imgTags}, 'deleteImage: deleteDockerTags');
 
         vasync.forEachPipeline({
             inputs: ctx.imgTags,
@@ -1214,7 +2177,7 @@ function deleteImage(opts, callback) {
                     nextImgTag();
                     return;
                 }
-                ImageTag.del(app, log, imgTag, function (err) {
+                ImageTagV2.del(app, log, imgTag, function (err) {
                     if (err) {
                         nextImgTag(err);
                     } else {
@@ -1227,16 +2190,125 @@ function deleteImage(opts, callback) {
         }, cb);
     }
 
-    function deleteImgs(ctx, cb) {
-        if (dontDeleteImages) {
-            cb();
+    function deleteImgapiLayers(ctx, cb) {
+        // Check the image layers in IMGAPI, if they are no longer referenced
+        // anywhere in the DC then the IMGAPI layer should be deleted.
+        var manifest;
+        try {
+            manifest = JSON.parse(ctx.img.manifest_str);
+        } catch (e) {
+            log.error({img: ctx.img}, 'Unable to parse image manifest_str');
+            cb(new errors.DockerError(e,
+                format('Unable to parse image manifest_str for image %s',
+                ctx.img.digest)));
             return;
         }
 
+        // Note that multiple images in the ancestry can reference the same
+        // IMGAPI uuid (i.e. a metadata layer change will have the same IMGAPI
+        // uuid as it's parent, as it has the same underlying filesystem bits).
+        var ownUuidRefCount = {};
+        ctx.imgsToDelete.forEach(function (img) {
+            ownUuidRefCount[img.image_uuid] =
+                1 + (ownUuidRefCount[img.image_uuid] || 0);
+        });
+
+        var hitImageHasDependentImagesError = false;
+        var diffIds = ctx.img.rootfs.diff_ids;
+        assert.equal(diffIds.length, manifest.layers.length,
+            'diff_ids length and manifest.layers length must be equal');
+
+        var layerDigests = [];
+        var layerInfos = manifest.layers.map(
+            function (layer, idx) {
+                layerDigests.push(layer.digest);
+                return {
+                    layerDigest: layer.digest,
+                    diffId: diffIds[idx],
+                    uuid: imgmanifest.imgUuidFromDockerDigests(layerDigests)
+                };
+            }
+        );
+
+        // Delete the images in reverse order (i.e. base layer is deleted last).
+        vasync.forEachPipeline({
+            func: deleteLayer,
+            inputs: layerInfos.reverse()
+        }, cb);
+
+        function deleteLayer(layerInfo, nextLayer) {
+            if (hitImageHasDependentImagesError) {
+                nextLayer();
+                return;
+            }
+
+            var layerDigest = layerInfo.layerDigest;
+            var uuid = layerInfo.uuid;
+
+            // Ensure no other docker image uses this *layer* in the *DC*.
+            var filter = [ { image_uuid: uuid } ];
+            ImageV2.list(opts.app, log, filter, function (lookupErr, imgs) {
+                if (lookupErr) {
+                    nextLayer(lookupErr);
+                    return;
+                }
+
+                var imageRefCnt = imgs.length;
+                // The image ancestry *may* include a reference to this layer,
+                // so negate the image's own reference in that case.
+                if (ownUuidRefCount[uuid]) {
+                    imageRefCnt -= 1;
+                    ownUuidRefCount[uuid] -= 1;
+                }
+                if (imageRefCnt >= 1) {
+                    // This image is referenced by another docker image.
+                    log.debug({layerDigest: layerDigest, refCnt: imageRefCnt,
+                        uuid: uuid}, 'deleteLayer: not deleting - '
+                        + 'layer is referenced by other images');
+                    // TODO: Should we add a 'Deleted' changes entry here? We
+                    // would need to check that these other referencing images
+                    // are not owned by this user.
+                    hitImageHasDependentImagesError = true;
+                    nextLayer();
+                    return;
+                }
+
+                // No other docker image references this layer - try and delete
+                // it from IMGAPI.
+                log.debug({layerDigest: layerDigest, uuid: uuid},
+                    'deleteLayer: deleting IMGAPI layer');
+                if (DRY_RUN) {
+                    changes.push({ Deleted: layerInfo.diffId });
+                    nextLayer();
+                    return;
+                }
+                app.imgapi.deleteImage(uuid, {
+                    headers: {'x-request-id': opts.req_id}
+                }, function (err) {
+                    if (err && err.restCode === 'ImageHasDependentImages') {
+                        // This origin is used by another IMGAPI image.
+                        hitImageHasDependentImagesError = true;
+                        log.info({layerDigest: layerDigest, uuid: uuid},
+                            'deleteLayer: hit ImageHasDependentImages');
+                        err = null;
+                    } else if (!err) {
+                        changes.push({ Deleted: layerInfo.diffId });
+                    }
+                    nextLayer(err);
+                });
+            });
+        }
+    }
+
+    function deleteDockerImages(ctx, cb) {
         vasync.forEachPipeline({
             inputs: ctx.imgsToDelete,
             func: deleteOneImg
         }, function (err) {
+            if (err === true) {
+                // Early abort - no error.
+                err = null;
+            }
             if (err) {
                 cb(new errors.DockerError(err, 'could not delete image'));
                 return;
@@ -1244,82 +2316,87 @@ function deleteImage(opts, callback) {
             cb();
         });
 
-        /*
-         * `true` if we hit `ImageHasDependentImagesError` error from IMGAPI,
-         * in which case we'll not bother attempting to delete further b/c
-         * they'll hit the same error.
-         */
-        var hitImageHasDependentImagesError = false;
-
-        /*
-         * We only remove the image *ref* when it is no longer being
-         * used by the account. If this is the last usage of the image
-         * across the whole DC (dcRefcount===1), then actually delete
-         * from IMGAPI.
+        /**
+         * Delete up the ancestor chain.
          */
         function deleteOneImg(img, nextImg) {
-            log.debug({imgId: img.docker_id, indexName: img.index_name},
-                'deleteImage: deleteOneImg');
+            if (img.digest !== ctx.img.digest) {
+                assert.equal(img.head, false, 'img.head should be false');
+            }
+
+            log.debug({digest: img.digest}, 'deleteImage: deleteOneImg');
             if (DRY_RUN) {
-                changes.push({ Deleted: img.docker_id });
+                changes.push({ Deleted: img.digest });
                 nextImg();
                 return;
             }
 
-            if (img.refcount > 1) {
-                log.debug({imgId: img.docker_id, indexName: img.index_name},
-                    'deleteImage: remove %s from heads', ctx.img.docker_id);
-                var update = {
-                    owner_uuid: img.owner_uuid,
-                    index_name: img.index_name,
-                    docker_id: img.docker_id,
-                    // Update:
-                    heads: img.params.heads.filter(function (id) {
-                        return id !== ctx.img.docker_id;
-                    })
-                };
-                if (img.docker_id === ctx.img.docker_id) {
-                    /*
-                     * The Docker image being removed must no longer be
-                     * marked as a 'head', else it could be "deleted again"...
-                     * during which `dcRefcount` values are not valid. This
-                     * is DOCKER-709.
-                     */
-                    update.head = false;
+            ImageV2.del(app, log, img, function (delErr) {
+                if (delErr) {
+                    nextImg(delErr);
+                    return;
                 }
-                Image.update(app, log, update, nextImg);
-            } else {
-                log.debug({imgId: img.docker_id, indexName: img.index_name},
-                    'deleteImage: delete image', ctx.img.docker_id);
-                Image.del(app, log, img, function (delErr) {
-                    if (delErr) {
-                        nextImg(delErr);
-                        return;
-                    }
-                    changes.push({ Deleted: img.docker_id });
 
-                    var isLastRef = (ctx.dcRefcount[img.docker_id]
-                                            !== undefined);
-                    if (!isLastRef || hitImageHasDependentImagesError) {
-                        nextImg();
-                        return;
-                    }
+                changes.push({ Deleted: img.digest });
+                nextImg();
+            });
+        }
+    }
+}
 
-                    log.debug({imgUuid: img.image_uuid},
-                        'deleteImage: delete imgapi image (last ref)');
-                    app.imgapi.deleteImage(img.image_uuid, {
-                        headers: {'x-request-id': opts.req_id}
-                    }, function (err) {
-                        if (err && err.restCode === 'ImageHasDependentImages') {
-                            hitImageHasDependentImagesError = true;
-                            log.info({imgUuid: img.image_uuid},
-                                'deleteImage: hit ImageHasDependentImages');
-                            err = null;
-                        }
-                        nextImg(err);
-                    });
-                });
+
+function deleteImage(opts, callback) {
+    assert.object(opts, 'opts');
+    assert.optionalObject(opts.app, 'opts.app');
+    assert.bool(opts.force, 'opts.force');
+    assert.optionalObject(opts.log, 'opts.log');
+    assert.string(opts.name, 'opts.name');
+    assert.string(opts.req_id, 'opts.req_id');
+    assert.object(opts.account, 'opts.account');
+
+    var changes;
+    var log = opts.log;
+
+    log.debug({imgName: opts.name}, 'deleteImage');
+
+    vasync.pipeline({funcs: [
+        getImg,
+        doDeleteImage
+    ]}, function (err) {
+        callback(err, changes);
+    });
+
+
+    function getImg(_, cb) {
+        imgFromName(opts, function (err, img, imgTag) {
+            if (err) {
+                cb(err);
+            } else if (!img) {
+                cb(new errors.ResourceNotFoundError(
+                    'No such image: ' + opts.name));
+            } else {
+                log.debug({img: img, imgTag: imgTag}, 'deleteImage: getImg');
+                opts.img = img;
+                if (imgTag) {
+                    // Only set if `name` was not an imgId.
+                    opts.imgTag = imgTag;
+                }
+                cb();
             }
+        });
+    }
+
+    function doDeleteImage(_, cb) {
+        if (isV1Image(opts.img)) {
+            _deleteImageV1(opts, function (err, _changes) {
+                changes = _changes;
+                cb(err);
+            });
+        } else {
+            _deleteImageV2(opts, function (err, _changes) {
+                changes = _changes;
+                cb(err);
+            });
         }
     }
 }
@@ -1338,7 +2415,7 @@ function inspectImage(opts, callback) {
     assert.object(opts.account, 'opts.account');
     assert.string(opts.name, 'opts.name');
     assert.object(opts.log, 'opts.log');
-    assert.optionalString(opts.index_name, 'opts.index_name');
+    assert.optionalString(opts.index_name, 'opts.index_name'); // For ImageV1.
 
     imgFromName(opts, function (err, img) {
         if (err) {
@@ -1348,13 +2425,7 @@ function inspectImage(opts, callback) {
                 'No such image: ' + opts.name));
         } else {
             // Get tags and return inspect info.
-            var filter = [
-                {owner_uuid: opts.account.uuid, docker_id: img.docker_id}
-            ];
-            if (opts.index_name) {
-                filter[0].index_name = opts.index_name;
-            }
-            ImageTag.list(opts.app, opts.log, filter, function (err2, imgTags) {
+            tagsForImage(img, opts, function _getImgTagsCb(err2, imgTags) {
                 if (err2) {
                     callback(err2);
                     return;
@@ -1538,7 +2609,7 @@ function pullImage(opts, callback) {
             regConfig: opts.req.headers['x-registry-config']
         };
 
-        opts.wfapi.createPullImageJob(jobOpts, function (err, juuid) {
+        opts.wfapi.createPullImageV2Job(jobOpts, function (err, juuid) {
             if (err) {
                 errorAndEnd(err);
                 next();
@@ -1576,11 +2647,13 @@ function pullImage(opts, callback) {
 function createImgapiDockerImage(imageJson, opts, callback) {
     assert.object(opts, 'opts');
     assert.optionalString(opts.account_uuid, 'opts.account_uuid');
+    assert.arrayOfString(opts.layerDigests, 'opts.layerDigests');
     assert.object(opts.rat, 'opts.rat');
     assert.object(opts.req, 'opts.req');
 
     opts.req.log.debug('opts.rat: ', opts.rat);
     var manifest = imgmanifest.imgManifestFromDockerInfo({
+        layerDigests: opts.layerDigests,
         imgJson: imageJson,
         owner: opts.account_uuid,
         public: false,
@@ -1603,179 +2676,79 @@ function createImgapiDockerImage(imageJson, opts, callback) {
 
 
 /**
- * Create new (unactivated) docker image - in imgapi and sdc-docker image model.
- *
- * @param opts {Object} Containing image payload information.
- * @param callback {Function} with signature fn(err, img).
- */
-function createImage(opts, callback) {
-    assert.object(opts, 'opts');
-    assert.object(opts.payload, 'opts.payload');
-    assert.object(opts.payload.image, 'opts.payload.image');
-    assert.optionalBool(opts.payload.head, 'opts.payload.head');
-    assert.optionalArrayOfString(opts.payload.heads, 'opts.payload.heads');
-    assert.number(opts.payload.size, 'opts.payload.size');
-    assert.optionalNumber(opts.payload.virtual_size,
-                        'opts.payload.virtual_size');
-    assert.optionalObject(opts.rat, 'opts.rat');
-    assert.object(opts.req, 'opts.req');
-
-    var rat = opts.rat;
-    var req = opts.req;
-    var account_uuid = req.account.uuid;
-    var imageJson = opts.payload.image;
-
-    if (!rat) {
-        // Empty repo/tag.
-        rat = {
-            localName: '',
-            index: { name: 'docker.io' }
-        };
-    }
-
-    vasync.pipeline({arg: {}, funcs: [
-        createImgapiImage,
-        createSdcDockerImageLayer
-    ]}, function _createImagePipelineCb(err, results) {
-        // Pass the sdc docker Image object back.
-        callback(err, results.successes[results.successes.length - 1]);
-    });
-
-    // Create imgapi image object.
-    function createImgapiImage(ctx, next) {
-        var imgOpts = {
-            account_uuid: account_uuid,
-            rat: rat,
-            req: req
-        };
-        createImgapiDockerImage(imageJson, imgOpts, function (err, imgapiImg) {
-            if (!err) {
-                ctx.image_uuid = imgapiImg.uuid;
-            }
-            next(err);
-        });
-    }
-
-    // Create sdc-docker image model.
-    function createSdcDockerImageLayer(ctx, next) {
-        var modelOpts = {
-            head: opts.payload.head,
-            heads: opts.payload.heads,
-            image_uuid: ctx.image_uuid,
-            index_name: rat.index.name,
-            owner_uuid: account_uuid,
-            size: opts.payload.size,
-            virtual_size: opts.payload.virtual_size
-        };
-        var img = dockerImageJsonToModel(imageJson, modelOpts);
-        req.log.debug('img: ', img);
-        Image.create(req.app, req.log, img, next);
-    }
-}
-
-
-/**
- * Update an image heads reference to include the given docker id.
- *
- * @param opts {Object} Containing image id, index_name and head information.
- * @param callback {Function} with signature fn(err, img).
- *
- * Warning: There is a race condition in which another call could modify the
- *          docker heads during the time between our fetch and update.
- */
-function addImageHeads(opts, callback) {
-    assert.object(opts, 'opts');
-    assert.arrayOfString(opts.heads, 'opts.heads');
-    assert.string(opts.id, 'opts.id');
-    assert.string(opts.index_name, 'opts.index_name');
-    assert.object(opts.req, 'opts.req');
-
-    var id = opts.id;
-    var req = opts.req;
-    var imageOpts = {
-        account: req.account,
-        app: req.app,
-        includeSmartos: false,
-        log: req.log,
-        index_name: opts.index_name,
-        name: id
-    };
-    req.backend.imgFromName(imageOpts, function (err, img) {
-        if (err) {
-            callback(err);
-        } else if (!img) {
-            callback(new errors.ResourceNotFoundError(
-                'No image found with id' + id));
-        } else {
-            var heads = img.heads || [];
-            opts.heads.forEach(function headForEach(headId) {
-                if (heads.indexOf(headId) === -1) {
-                    heads.push(headId);
-                }
-            });
-            Image.update(req.app, req.log, {
-                owner_uuid: img.owner_uuid,
-                index_name: img.index_name,
-                docker_id: img.docker_id,
-                // Update:
-                heads: heads
-            }, callback);
-        }
-    });
-}
-
-
-/**
- * Tags an image (given by docker_id) with the given name.
+ * Tags the given image digest with the given name.
  *
  * Accepted name examples:
  *   busybox
  *   toddw/mybusybox:latest
  *   my.registry.com:5000/ns/myname:head
  *
- * @param opts {Object} Contains image id and tag information.
+ * @param opts {Object} Contains image and tag information.
  * @param callback {Function} with signature fn(err, imgTag).
  */
 function tagImage(opts, callback) {
     assert.object(opts, 'opts');
-    assert.string(opts.docker_id, 'opts.docker_id');
     assert.string(opts.name, 'opts.name');
     assert.object(opts.req, 'opts.req');
+    assert.optionalString(opts.digest, 'opts.digest');
+    assert.optionalObject(opts.img, 'opts.img');
+    assert.optionalObject(opts.rat, 'opts.rat');
 
+    var digest = opts.digest;
+    var rat = opts.rat;
     var req = opts.req;
 
-    try {
-        var rat = drc.parseRepoAndTag(opts.name);
-    } catch (e) {
-        callback(new errors.DockerError(e, e.message));
-        return;
+    if (!rat) {
+        try {
+            rat = drc.parseRepoAndTag(opts.name);
+        } catch (e) {
+            callback(new errors.DockerError(e, e.message));
+            return;
+        }
+    }
+
+    if (!digest) {
+        assert.object(opts.img, 'opts.img or opts.digest must be provided');
+        if (isV1Image(opts.img)) {
+            callback(new errors.DockerError(
+                'Cannot tag old v1 images - repull or rebuild the image'));
+            return;
+        }
+        digest = opts.img.digest;
     }
 
     var params = {
-        docker_id: opts.docker_id,
-        index_name: rat.index.name,
+        digest: digest,
         owner_uuid: req.account.uuid,
         repo: rat.localName,
         tag: rat.tag
 
     };
-    ImageTag.create(req.app, req.log, params, callback);
+    ImageTagV2.create(req.app, req.log, params, callback);
+}
+
+
+/**
+ * Whether img is an instance of models.images.Image (aka v1 image).
+ */
+function isV1Image(img) {
+    return !img.hasOwnProperty('manifest_str');
 }
 
 
 // ---- exports
 
 module.exports = {
-    addImageHeads: addImageHeads,
-    createImage: createImage,
     deleteImage: deleteImage,
     dockerImageJsonToModel: dockerImageJsonToModel,
-    getDockerImageForUuid: getDockerImageForUuid,
     getImageHistory: getImageHistory,
     getScratchImage: getScratchImage,
+    isV1Image: isV1Image,
     listImages: listImages,
     inspectImage: inspectImage,
+    imgFromImgInfo: imgFromImgInfoV2,
     pullImage: pullImage,
+    imgFromDigest: imgFromDigest,
     imgFromName: imgFromName,
     tagImage: tagImage
 };
diff --git a/lib/backends/sdc/index.js b/lib/backends/sdc/index.js
index ca536d0..254af21 100644
--- a/lib/backends/sdc/index.js
+++ b/lib/backends/sdc/index.js
@@ -64,8 +64,6 @@ SdcBackend.prototype.containerArchiveStat =
     containers.containerArchiveStat;
 
 // images.js
-SdcBackend.prototype.addImageHeads = images.addImageHeads;
-SdcBackend.prototype.createImage = images.createImage;
 SdcBackend.prototype.deleteImage = images.deleteImage;
 SdcBackend.prototype.getImageHistory = images.getImageHistory;
 SdcBackend.prototype.getScratchImage = images.getScratchImage;
diff --git a/lib/backends/sdc/utils.js b/lib/backends/sdc/utils.js
index 7f34502..79fb34e 100644
--- a/lib/backends/sdc/utils.js
+++ b/lib/backends/sdc/utils.js
@@ -16,7 +16,6 @@ var restify = require('restify');
 var triton_tags = require('triton-tags');
 
 var common = require('../../common');
-var constants = require('../../constants');
 var Link = require('../../models/link');
 
 
@@ -893,12 +892,10 @@ function vmobjToInspect(opts, obj, vmData, callback) {
     _addLinks();
 }
 
-function imgobjToInspect(obj, imgTags) {
-    assert.object(obj, 'obj');
+function imgobjToInspect(image, imgTags) {
+    assert.object(image, 'image');
     assert.optionalArrayOfObject(imgTags, 'imgTags');
 
-    var image = obj.serialize();
-
     var dockerImage = {
         Architecture: image.architecture || 'amd64',
         Author: image.author,
@@ -906,17 +903,17 @@ function imgobjToInspect(obj, imgTags) {
         Config: image.config,
         Container: '', // which container?
         ContainerConfig: image.container_config,
-        Created: new Date(image.created),
-        DockerVersion: constants.SERVER_VERSION,
+        Created: image.createdISOString,
+        DockerVersion: image.docker_version,
         GraphDriver: {
             Data: null,
             Name: 'sdc-docker'
         },
-        Id: image.docker_id,
+        Id: image.digest || image.docker_id,
         Os: 'Linux',
         Parent: image.parent || '',
         RepoTags: [],
-        RepoDigests: [], // ?
+        RepoDigests: [],
         Size: image.size,
         VirtualSize: image.virtual_size
     };
@@ -926,6 +923,19 @@ function imgobjToInspect(obj, imgTags) {
         dockerImage.RepoTags = imgTags.map(function (it) {
             return it.repo + ':' + it.tag;
         });
+        if (image.manifest_digest) {
+            dockerImage.RepoDigests = imgTags.map(function (it) {
+                return it.repo + '@' + image.manifest_digest;
+            });
+        }
+    }
+
+    if (image.rootfs) {
+        // This came from a v2.2 image manifest.
+        dockerImage.RootFS = {
+            Type: image.rootfs.type,
+            Layers: image.rootfs.diff_ids
+        };
     }
 
     return dockerImage;
diff --git a/lib/endpoints/admin/image-tags.js b/lib/endpoints/admin/image-tags-v2.js
similarity index 64%
rename from lib/endpoints/admin/image-tags.js
rename to lib/endpoints/admin/image-tags-v2.js
index 2250aab..d991bf5 100644
--- a/lib/endpoints/admin/image-tags.js
+++ b/lib/endpoints/admin/image-tags-v2.js
@@ -5,31 +5,31 @@
  */
 
 /*
- * Copyright (c) 2015, Joyent, Inc.
+ * Copyright (c) 2016, Joyent, Inc.
  */
 
 var restify = require('restify');
-var ImageTag = require('../../models/image-tag');
+var ImageTagV2 = require('../../models/image-tag-v2');
 
 var UNSET_OWNER_UUID = '00000000-0000-0000-0000-000000000000';
 
 
 /**
- * GET /admin/image_tags
+ * GET /admin/image_tags_v2
  */
-function adminListImageTags(req, res, next) {
+function adminListImageTagsV2(req, res, next) {
     var params = {};
     if (req.query.owner_uuid) {
         params.owner_uuid = req.query.owner_uuid;
     }
-    if (req.query.docker_id) {
-        params.docker_id = req.query.docker_id;
+    if (req.query.digest) {
+        params.digest = req.query.digest;
     }
     if (req.query.tag) {
         params.tag = req.query.tag;
     }
 
-    ImageTag.list(req.app, req.log, params, function (err, tags) {
+    ImageTagV2.list(req.app, req.log, params, function (err, tags) {
         if (err) {
             next(err);
             return;
@@ -47,15 +47,15 @@ function adminListImageTags(req, res, next) {
 
 
 /**
- * POST /admin/image_tags
+ * POST /admin/image_tags_v2
  */
-function adminCreateImageTag(req, res, next) {
+function adminCreateImageTagV2(req, res, next) {
     var params = req.body;
     if (!params.owner_uuid || params.owner_uuid === UNSET_OWNER_UUID) {
         params.owner_uuid = req.app.config.adminUuid;
     }
 
-    ImageTag.create(req.app, req.log, params, function (err, tag) {
+    ImageTagV2.create(req.app, req.log, params, function (err, tag) {
         if (err) {
             next(err);
             return;
@@ -71,10 +71,10 @@ function adminCreateImageTag(req, res, next) {
  * Register all endpoints with the restify server
  */
 function register(http, before) {
-    http.get({ path: '/admin/image_tags', name: 'AdminListImageTags' },
-        before, adminListImageTags);
-    http.post({ path: '/admin/image_tags', name: 'AdminCreateImageTag' },
-        before, adminCreateImageTag);
+    http.get({ path: '/admin/image_tags_v2', name: 'AdminListImageTagsV2' },
+        before, adminListImageTagsV2);
+    http.post({ path: '/admin/image_tags_v2', name: 'AdminCreateImageTagV2' },
+        before, adminCreateImageTagV2);
 }
 
 
diff --git a/lib/endpoints/admin/images.js b/lib/endpoints/admin/images-v2.js
similarity index 56%
rename from lib/endpoints/admin/images.js
rename to lib/endpoints/admin/images-v2.js
index 9c2a215..efc3f27 100644
--- a/lib/endpoints/admin/images.js
+++ b/lib/endpoints/admin/images-v2.js
@@ -5,30 +5,27 @@
  */
 
 /*
- * Copyright (c) 2015, Joyent, Inc.
+ * Copyright (c) 2016, Joyent, Inc.
  */
 
-var Image = require('../../models/image');
+var ImageV2 = require('../../models/image-v2');
 
 var UNSET_OWNER_UUID = '00000000-0000-0000-0000-000000000000';
 
 
 /**
- * GET /admin/images
+ * GET /admin/images-v2
  */
-function adminListImages(req, res, next) {
+function adminListImagesV2(req, res, next) {
     var params = {};
     if (req.query.owner_uuid) {
         params.owner_uuid = req.query.owner_uuid;
     }
-    if (req.query.index_name) {
-        params.index_name = req.query.index_name;
-    }
-    if (req.query.docker_id) {
-        params.docker_id = req.query.docker_id;
+    if (req.query.digest) {
+        params.digest = req.query.digest;
     }
 
-    Image.list(req.app, req.log, params, function (err, images) {
+    ImageV2.list(req.app, req.log, params, function (err, images) {
         if (err) {
             next(err);
             return;
@@ -46,18 +43,15 @@ function adminListImages(req, res, next) {
 
 
 /**
- * POST /admin/images?action=create
- * POST /admin/images?action=update
+ * POST /admin/images-v2?action=create
  */
-function adminCreateImage(req, res, next) {
-    // XXX(trent): validate args
+function adminCreateImageV2(req, res, next) {
     var params = req.body;
     if (!params.owner_uuid || params.owner_uuid === UNSET_OWNER_UUID) {
         params.owner_uuid = req.app.config.adminUuid;
     }
 
-    var fn = (req.query.action === 'update' ? Image.update : Image.create);
-    fn.call(Image, req.app, req.log, params, function (err, img) {
+    ImageV2.create(req.app, req.log, params, function (err, img) {
         if (err) {
             next(err);
         } else {
@@ -72,10 +66,10 @@ function adminCreateImage(req, res, next) {
  * Register all endpoints with the restify server
  */
 function register(http, before) {
-    http.get({ path: '/admin/images', name: 'AdminListImages' },
-        before, adminListImages);
-    http.post({ path: '/admin/images', name: 'AdminCreateImage' },
-        before, adminCreateImage);
+    http.get({ path: '/admin/images-v2', name: 'AdminListImagesV2' },
+        before, adminListImagesV2);
+    http.post({ path: '/admin/images-v2', name: 'AdminCreateImageV2' },
+        before, adminCreateImageV2);
 }
 
 
diff --git a/lib/endpoints/admin/index.js b/lib/endpoints/admin/index.js
index 749b440..4d745ce 100644
--- a/lib/endpoints/admin/index.js
+++ b/lib/endpoints/admin/index.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2014, Joyent, Inc.
+ * Copyright (c) 2016, Joyent, Inc.
  */
 
 
@@ -16,8 +16,8 @@
  */
 var toRegister = {
     '/admin/progress': require('./progress'),
-    '/admin/images': require('./images'),
-    '/admin/image_tags': require('./image-tags')
+    '/admin/images_v2': require('./images-v2'),
+    '/admin/image_tags_v2': require('./image-tags-v2')
 };
 
 
diff --git a/lib/endpoints/commit.js b/lib/endpoints/commit.js
index c404a65..6e3728e 100644
--- a/lib/endpoints/commit.js
+++ b/lib/endpoints/commit.js
@@ -55,14 +55,13 @@ function commit(req, res, next) {
      */
     req.connection.setTimeout(10 * 60 * 1000);
 
-    req.backend.commitImage(req, commitOpts, function (err, imageId) {
+    req.backend.commitImage(req, commitOpts, function (err, digest) {
         if (err) {
             res.send(err);
         } else {
-            log.debug('docker commit finished successfully');
-            // Note: Docker returns sha256: {"Id":"sha256:93c3e0ca32...1453a"}
+            log.debug({digest: digest}, 'docker commit finished successfully');
             res.status(201);  // Okay - image was committed.
-            res.write(JSON.stringify({'Id': imageId}) + '\n');
+            res.write(JSON.stringify({'Id': digest}) + '\n');
         }
 
         res.end();
diff --git a/lib/endpoints/images.js b/lib/endpoints/images.js
index 5d3f081..84c9273 100644
--- a/lib/endpoints/images.js
+++ b/lib/endpoints/images.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2015, Joyent, Inc.
+ * Copyright (c) 2017, Joyent, Inc.
  */
 
 var drc = require('docker-registry-client');
@@ -85,10 +85,6 @@ function imageCreate(req, res, next) {
         next(new errors.DockerError(e, e.toString()));
         return;
     }
-    if (rat.digest) {
-        next(new errors.NotImplementedError('"docker pull" by @DIGEST'));
-        return;
-    }
     // TODO(DOCKER-587): is this `all = ...` accurate with digest in play?
     var all = (!req.query.tag
         && rat.tag && rat.tag === 'latest'
@@ -98,7 +94,12 @@ function imageCreate(req, res, next) {
         return;
     }
     if (req.query.tag) {
-        rat.tag = req.query.tag;
+        if (req.query.tag.substr(0, 7) === 'sha256:') {
+            rat.digest = req.query.tag;
+            rat.tag = '';
+        } else {
+            rat.tag = req.query.tag;
+        }
     }
 
 
@@ -161,9 +162,7 @@ function imageHistory(req, res, next) {
             next(histErr);
             return;
         }
-        var historyItems = history.map(
-            function (i) { return i.toHistoryItem(); });
-        res.send(historyItems);
+        res.send(history);
         next();
     });
 }
@@ -197,23 +196,16 @@ function imageTag(req, res, next) {
         repoAndTag += ':' + req.query.tag;
     }
 
+    // Ensure the tag name is valid.
     try {
-        var rat = drc.parseRepoAndTag(repoAndTag);
+        drc.parseRepoAndTag(repoAndTag);
     } catch (e) {
         next(new errors.DockerError(e, e.message));
         return;
     }
 
-    // DOCKER-748: Ensure the tag and the image are in the same repository.
-    if (req.image.index_name !== rat.index.name) {
-        next(new errors.DockerError(format(
-            'Cannot create tag reference between different registries (%s, %s)',
-            req.image.index_name, rat.index.name)));
-        return;
-    }
-
     req.backend.tagImage({
-        docker_id: req.image.docker_id,
+        img: req.image,
         name: repoAndTag,
         req: req
     }, function (err, history) {
diff --git a/lib/models/image-tag-v2.js b/lib/models/image-tag-v2.js
new file mode 100644
index 0000000..c8ae052
--- /dev/null
+++ b/lib/models/image-tag-v2.js
@@ -0,0 +1,198 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+
+/*
+ * Image tag v2 model - to be used with ImageV2 objects.
+ *
+ * This holds each tagged image for a given account (`owner_uuid`). IOW, this
+ * mapping:
+ *      (owner_uuid, repo, tag) => ImageV2.digest
+ */
+
+var assert = require('assert-plus');
+var drc = require('docker-registry-client');
+var fmt = require('util').format;
+var vasync = require('vasync');
+
+var moray = require('../moray');
+
+
+
+// --- Globals
+
+var BUCKET = {
+    desc: 'docker image tag v2',
+    name: 'docker_image_tags_v2',
+    schema: {
+        index: {
+            digest: { type: 'string' },
+            owner_uuid: { type: 'string' },
+            /*
+             * The "localName" for the Docker repo. See
+             * // JSSTYLED
+             * <https://github.com/joyent/node-docker-registry-client/tree/master#names>
+             */
+            repo: { type: 'string' },
+            tag: { type: 'string' }
+        }
+    },
+    version: 1
+};
+
+
+
+// --- Helpers
+
+function objectKey(params) {
+    assert.string(params.owner_uuid, 'params.owner_uuid');
+    assert.string(params.repo, 'params.repo');
+    assert.string(params.tag, 'params.tag');
+
+    return fmt('%s,%s,%s', params.owner_uuid, params.repo, params.tag);
+}
+
+
+// --- ImageTag object
+
+/**
+ * ImageTag model constructor
+ */
+function ImageTag(params) {
+    assert.object(params, 'image tag params');
+    assert.string(params.digest, 'params.digest');
+    assert.string(params.owner_uuid, 'params.owner_uuid');
+    assert.string(params.repo, 'params.repo');
+    assert.string(params.tag, 'params.tag');
+
+    this.params = params;
+
+    this.__defineGetter__('owner_uuid', function () {
+        return this.params.owner_uuid;
+    });
+    this.__defineGetter__('repo', function () {
+        return this.params.repo;
+    });
+    this.__defineGetter__('tag', function () {
+        return this.params.tag;
+    });
+    this.__defineGetter__('digest', function () {
+        return this.params.digest;
+    });
+}
+
+
+/**
+ * Returns the raw form of the image tag suitable for storing in moray,
+ * which is the same as the serialized form
+ */
+ImageTag.prototype.toJSON =
+    ImageTag.prototype.raw =
+    ImageTag.prototype.serialize =
+    function ()
+{
+    return {
+        owner_uuid: this.params.owner_uuid,
+        repo: this.params.repo,
+        tag: this.params.tag,
+        digest: this.params.digest
+    };
+};
+
+
+
+// --- Exported functions
+
+/**
+ * Creates a image tag.
+ */
+function createImageTag(app, log, params, callback) {
+    log.debug({params: params}, 'createImageTagV2: entry');
+
+    var imgTag = new ImageTag(params);
+    var key = objectKey(params);
+    app.moray.putObject(BUCKET.name, key, imgTag.raw(), function (err) {
+        if (err) {
+            return callback(err);
+        }
+        return callback(null, imgTag);
+    });
+}
+
+
+/**
+ * Lists all image tags
+ */
+function listImageTags(app, log, params, callback) {
+    log.trace({params: params}, 'listImageTagsV2: entry');
+
+    if (!Object.keys(params).length) {
+        params = '(digest=*)';
+    }
+
+    moray.listObjs({
+        filter: params,
+        log: log,
+        bucket: BUCKET,
+        model: ImageTag,
+        moray: app.moray
+    }, callback);
+}
+
+/**
+ * Deletes an image tag
+ */
+function deleteImageTag(app, log, params, callback) {
+    log.debug({params: params}, 'deleteImageTagV2: entry');
+    var key = objectKey(params);
+    moray.delObj(app.moray, BUCKET, key, callback);
+}
+
+
+/**
+ * Every funtion should just take care of replacing the column with a new
+ * value, or just return if it doesn't apply. When an updated object needs
+ * to be written every function should push a new item to the batch array.
+ */
+var migrations = [
+];
+
+
+/**
+ * Initializes the image tags bucket
+ */
+function initImageTagsBucket(app, callback) {
+    moray.initBucket(app.moray, BUCKET, function (err, updated, fromBucket) {
+        if (err) {
+            callback(err);
+            return;
+        }
+
+        // Run migrations when the bucket needed to be updated
+        if (updated) {
+            moray.migrateObjects({
+                app: app,
+                bucket: BUCKET,
+                fromBucket: fromBucket,
+                migrations: migrations
+            }, callback);
+        } else {
+            callback();
+        }
+    });
+}
+
+
+module.exports = {
+    create: createImageTag,
+    del: deleteImageTag,
+    init: initImageTagsBucket,
+    list: listImageTags,
+    ImageTag: ImageTag
+};
diff --git a/lib/models/image-v2.js b/lib/models/image-v2.js
new file mode 100644
index 0000000..aababa5
--- /dev/null
+++ b/lib/models/image-v2.js
@@ -0,0 +1,322 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+
+/*
+ * Image model v2
+ *
+ * The digest is the sha256 of the 'image JSON' (aka metadata).
+ * The image_uuid is the underlying layer (bits) - stored in IMGAPI.
+ */
+
+var assert = require('assert-plus');
+var format = require('util').format;
+
+var moray = require('../moray');
+
+
+
+// --- Globals
+
+var BUCKET = {
+    desc: 'docker image v2',
+    name: 'docker_images_v2',
+    schema: {
+        index: {
+            digest: { type: 'string' },
+            head: { type: 'boolean' },
+            image_uuid: { type: 'string' },
+            manifest_digest: { type: 'string' },
+            owner_uuid: { type: 'string' },
+            parent: { type: 'string' }
+        }
+    },
+    version: 1
+};
+
+
+
+// --- Helpers
+
+function objectKey(params) {
+    assert.string(params.digest, 'params.digest');
+    assert.string(params.owner_uuid, 'params.owner_uuid');
+
+    return format('%s,%s', params.owner_uuid, params.digest);
+}
+
+
+// --- ImageV2 object
+
+
+/**
+ * ImageV2 model constructor
+ */
+function ImageV2(params) {
+    assert.object(params, 'image params');
+    assert.string(params.digest, 'params.digest');
+    assert.bool(params.head, 'params.head');
+    assert.object(params.image, 'params.image');
+    assert.string(params.image_uuid, 'params.image_uuid');
+    assert.string(params.manifest_digest, 'params.manifest_digest');
+    assert.string(params.manifest_str, 'params.manifest_str');
+    assert.optionalString(params.parent, 'params.parent');
+    assert.string(params.owner_uuid, 'params.owner_uuid');
+    assert.number(params.size, 'params.size');
+
+    // Check that the image is correct.
+    var image = params.image;
+    assert.object(image.config, 'image.config');
+    assert.string(image.created, 'image.created');
+    assert.object(image.history, 'image.history');
+    assert.string(image.os, 'image.os');
+    assert.object(image.rootfs, 'image.rootfs');
+    // Optionals
+    assert.optionalString(image.architecture, 'image.architecture');
+    assert.optionalString(image.author, 'image.author');
+    assert.optionalString(image.comment, 'image.comment');
+    assert.optionalString(image.container, 'image.container');
+    assert.optionalObject(image.container_config, 'image.container_config');
+    assert.optionalString(image.docker_version, 'image.docker_version');
+    assert.optionalString(image.id, 'image.id');
+    assert.optionalString(image.parent, 'image.parent');
+
+    // Params.parent must be set in order to get indexing on parent.
+    if (!params.parent && params.image.parent) {
+        params.parent = params.image.parent;
+    } else if (params.parent) {
+        assert.equal(params.parent, params.image.parent,
+            'image.parent should equal params.parent');
+    }
+    // Cleanup parent to ensure it's a string (not null or undefined), this is
+    // so we can later search/filter against an empty parent string.
+    if (!params.parent) {
+        params.parent = '';
+    }
+
+    // Validate digests.
+    assert.ok(params.digest.indexOf(':') >= 0,
+        'digest must include a colon, got ' + params.parent);
+
+    this.params = params;
+
+    // image.created is an ISO timestamp string: "2016-10-07T21:03:58.16783626Z"
+    // but some of the docker APIs use a unix timestamp (seconds since 1970), so
+    // we create a separate unix timestamp entry from the given ISO timestamp
+    // string.
+    this.params.created = Math.floor(
+        (new Date(this.params.image.created).getTime()) / 1000);
+
+    // Accessor for computing the moray object key
+    this.__defineGetter__('key', function () {
+        return objectKey(this.params);
+    });
+    this.__defineGetter__('digest', function () {
+        return this.params.digest;
+    });
+    this.__defineGetter__('head', function () {
+        return this.params.head;
+    });
+    this.__defineGetter__('image', function () {
+        return this.params.image;
+    });
+    this.__defineGetter__('image_uuid', function () {
+        return this.params.image_uuid;
+    });
+    this.__defineGetter__('manifest_str', function () {
+        return this.params.manifest_str;
+    });
+    this.__defineGetter__('manifest_digest', function () {
+        return this.params.manifest_digest;
+    });
+    this.__defineGetter__('owner_uuid', function () {
+        return this.params.owner_uuid;
+    });
+    this.__defineGetter__('size', function () {
+        return this.params.size;
+    });
+
+    // Backwards compat for older image code.
+    this.__defineGetter__('author', function () {
+        return this.params.image.author;
+    });
+    this.__defineGetter__('architecture', function () {
+        return this.params.image.architecture;
+    });
+    this.__defineGetter__('comment', function () {
+        return this.params.image.comment;
+    });
+    this.__defineGetter__('config', function () {
+        // Warning: `config` can be null on base Docker images.
+        return this.params.image.config;
+    });
+    this.__defineGetter__('container_config', function () {
+        return this.params.image.container_config;
+    });
+    this.__defineGetter__('created', function () {
+        return this.params.created;
+    });
+    this.__defineGetter__('createdISOString', function () {
+        return this.params.image.created;
+    });
+    this.__defineGetter__('docker_version', function () {
+        return this.params.image.docker_version;
+    });
+    this.__defineGetter__('history', function () {
+        return this.params.image.history;
+    });
+    this.__defineGetter__('parent', function () {
+        return this.params.image.parent;
+    });
+    this.__defineGetter__('private', function () {
+        return false;
+    });
+    this.__defineGetter__('rootfs', function () {
+        return this.params.image.rootfs;
+    });
+}
+
+
+/**
+ * Returns the raw form of the image suitable for storing in moray,
+ * which is the same as the serialized form
+ */
+ImageV2.prototype.toJSON =
+    ImageV2.prototype.raw =
+    ImageV2.prototype.serialize =
+    function ()
+{
+    return {
+        digest: this.params.digest,
+        created: this.params.created,
+        head: this.params.head,
+        image: this.params.image,
+        image_uuid: this.params.image_uuid,
+        manifest_str: this.params.manifest_str,
+        manifest_digest: this.params.manifest_digest,
+        parent: this.params.parent,
+        owner_uuid: this.params.owner_uuid,
+        size: this.params.size
+    };
+};
+
+
+
+// --- Exported functions
+
+/**
+ * Creates a image
+ */
+function createImage(app, log, params, callback) {
+    log.debug({ params: params }, 'createImageV2: entry');
+
+    var image = new ImageV2(params);
+    app.moray.putObject(BUCKET.name, image.key, image.raw(), function (err) {
+        if (err) {
+            return callback(err);
+        }
+
+        return callback(null, image);
+    });
+}
+
+
+/**
+ * Lists all images
+ */
+function listImages(app, log, params, callback) {
+    log.debug({params: params}, 'listImagesV2: entry');
+
+    if (!Object.keys(params).length) {
+        params = '(digest=*)';
+    }
+
+    moray.listObjs({
+        filter: params,
+        log: log,
+        bucket: BUCKET,
+        model: ImageV2,
+        moray: app.moray
+    }, callback);
+}
+
+
+/**
+ * Updates an image
+ */
+function updateImage(app, log, params, callback) {
+    log.debug({params: params}, 'updateImageV2: entry');
+    var key = objectKey(params);
+    moray.updateObj({
+        moray: app.moray,
+        bucket: BUCKET,
+        key: key,
+        val: params
+    }, function (err, rec) {
+        if (err) {
+            return callback(err);
+        }
+
+        return callback(null, new ImageV2(rec.value));
+    });
+}
+
+
+/**
+ * Deletes an image
+ */
+function deleteImage(app, log, params, callback) {
+    log.debug({params: params}, 'deleteImageV2: entry');
+    var key = objectKey(params);
+    moray.delObj(app.moray, BUCKET, key, callback);
+}
+
+
+/**
+ * Every funtion should just take care of replacing the column with a new
+ * value, or just return if it doesn't apply. When an updated object needs
+ * to be written every function should push a new item to the batch array.
+ */
+var migrations = [
+];
+
+
+/**
+ * Initializes the images bucket.
+ */
+function initImagesBucket(app, callback) {
+    moray.initBucket(app.moray, BUCKET, function (err, updated, fromBucket) {
+        if (err) {
+            callback(err);
+            return;
+        }
+
+        // Run migrations when the bucket needs to be updated.
+        if (updated) {
+            moray.migrateObjects({
+                app: app,
+                bucket: BUCKET,
+                fromBucket: fromBucket,
+                migrations: migrations
+            }, callback);
+        } else {
+            callback();
+        }
+    });
+}
+
+
+module.exports = {
+    create: createImage,
+    del: deleteImage,
+    init: initImagesBucket,
+    list: listImages,
+    ImageV2: ImageV2,
+    update: updateImage
+};
diff --git a/lib/models/image.js b/lib/models/image.js
index 87d7146..b5a35ec 100644
--- a/lib/models/image.js
+++ b/lib/models/image.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2015, Joyent, Inc.
+ * Copyright (c) 2017, Joyent, Inc.
  */
 
 /*
@@ -14,12 +14,8 @@
 
 var assert = require('assert-plus');
 var format = require('util').format;
-var imgmanifest = require('imgmanifest');
 var once = require('once');
-var util = require('util');
-var vasync = require('vasync');
 
-var ImageTag = require('./image-tag');
 var moray = require('../moray');
 
 
@@ -123,6 +119,9 @@ function Image(params) {
     this.__defineGetter__('created', function () {
         return this.params.created;
     });
+    this.__defineGetter__('createdISOString', function () {
+        return new Date(this.params.created * 1000).toISOString();
+    });
     this.__defineGetter__('docker_id', function () {
         return this.params.docker_id;
     });
@@ -186,21 +185,6 @@ Image.prototype.toJSON =
 };
 
 
-Image.prototype.toHistoryItem = function toHistoryItem() {
-    var createdBy = '';
-    if (this.container_config && this.container_config.Cmd) {
-        createdBy = this.container_config.Cmd.join(' ');
-    }
-    var created = Math.floor((new Date(this.created)).getTime() / 1000);
-    return {
-        Id: this.docker_id,
-        Created: created,
-        CreatedBy: createdBy,
-        Size: this.size
-    };
-};
-
-
 
 // --- Exported functions
 
@@ -353,103 +337,7 @@ function datacenterRefcount(app, log, params, callback) {
  * value, or just return if it doesn't apply. When an updated object needs
  * to be written every function should push a new item to the batch array.
  */
-var migrations = [
-    {
-        fn: _addIndexName,
-        version: 2
-    },
-    {
-        fn: _updateImageUuids,
-        version: 3
-    },
-    {
-        fn: _updateKeysPrivateRegistries,
-        version: 4
-    }
-];
-
-
-/*
- * This migration will populate the index_name column values. We cheat here
- * knowing that before this migration the only index_name from which
- * pulls were supported was 'docker.io' -- so use that value.
- */
-function _addIndexName(opts) {
-    assert.object(opts, 'opts');
-
-    var batch = opts.batch;
-    var key = opts.key;
-    var value = opts.value;
-
-    if (value.index_name !== undefined) {
-        return;
-    }
-
-    value.index_name = 'docker.io';
-    batch.push({
-        bucket: BUCKET.name,
-        key: key,
-        value: value
-    });
-}
-
-
-/*
- * This migration will update the image_uuid values on every docker_image
- *   with a new UUID computed from docker_id and index_name
- */
-function _updateImageUuids(opts) {
-    assert.object(opts, 'opts');
-
-    var batch = opts.batch;
-    var key = opts.key;
-    var value = opts.value;
-
-    var uuid = imgmanifest.imgUuidFromDockerInfo({
-        id: value.docker_id,
-        indexName: value.index_name
-    });
-    value.image_uuid = uuid;
-
-    batch.push({
-        bucket: BUCKET.name,
-        key: key,
-        value: value
-    });
-}
-
-
-/*
- * This migration will update all object keys from
- *   owner_uuid-docker_id to owner_uuid-index_name-docker_id
- */
-function _updateKeysPrivateRegistries(opts) {
-    assert.object(opts, 'opts');
-
-    var batch = opts.batch;
-    var key = opts.key;
-    var value = opts.value;
-
-    // Ignore every object that was already migrated.
-    if (key.split('-').length > 6) {
-        return;
-    }
-
-    // TODO Image.prototype.key
-    var newKey = format('%s-%s-%s', value.owner_uuid,
-        value.index_name, value.docker_id);
-
-    // Add new object and delete old one
-    batch.push({
-        bucket: BUCKET.name,
-        key: newKey,
-        value: value
-    }, {
-        bucket: BUCKET.name,
-        operation: 'delete',
-        key: key
-    });
-}
+var migrations = [];
 
 
 /**
diff --git a/lib/models/index.js b/lib/models/index.js
index a77e086..1201a4c 100644
--- a/lib/models/index.js
+++ b/lib/models/index.js
@@ -14,6 +14,8 @@
 
 var image = require('./image');
 var image_tag = require('./image-tag');
+var image_v2 = require('./image-v2');
+var image_tag_v2 = require('./image-tag-v2');
 var link = require('./link');
 var vasync = require('vasync');
 
@@ -31,6 +33,8 @@ function initializeModels(app, callback) {
         inputs: [
             image,
             image_tag,
+            image_v2,
+            image_tag_v2,
             link
         ],
         func: function _initModel(mod, cb) {
diff --git a/lib/wfapi/index.js b/lib/wfapi/index.js
index 480e960..692a107 100644
--- a/lib/wfapi/index.js
+++ b/lib/wfapi/index.js
@@ -136,14 +136,13 @@ Wfapi.prototype.ping = function (callback) {
 };
 
 
-
 /*
- * Queues a pull-image job.
+ * Queues a pull-image-v2 job.
  *
  * @param options {Object} Required.
  * @param cb {Function} `function (err, jobUuid)`
  */
-Wfapi.prototype.createPullImageJob = function (options, cb) {
+Wfapi.prototype.createPullImageV2Job = function (options, cb) {
     var self = this;
     assert.object(options, 'options');
     assert.object(options.rat, 'options.rat');
@@ -153,8 +152,8 @@ Wfapi.prototype.createPullImageJob = function (options, cb) {
     assert.optionalString(options.regConfig, 'opts.regConfig');
 
     var params = {
-        task: 'pull-image',
-        target: format('/pull-image-%s', options.rat.canonicalName),
+        task: 'pull-image-v2',
+        target: format('/pull-image-v2-%s', options.rat.canonicalName),
         rat: options.rat,
         req_id: options.req_id,
         account_uuid: options.account.uuid,
@@ -168,7 +167,7 @@ Wfapi.prototype.createPullImageJob = function (options, cb) {
             return cb(err);
         }
         params.job_uuid = job.uuid;
-        self.log.debug(params, 'Pull image job params');
+        self.log.debug(params, 'Pull image v2 job params');
         return cb(null, job.uuid);
     });
 };
diff --git a/lib/wfapi/workflows/pull-image.js b/lib/wfapi/workflows/pull-image-v2.js
similarity index 60%
rename from lib/wfapi/workflows/pull-image.js
rename to lib/wfapi/workflows/pull-image-v2.js
index cbae6ba..fef0b4d 100644
--- a/lib/wfapi/workflows/pull-image.js
+++ b/lib/wfapi/workflows/pull-image-v2.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright 2016, Joyent, Inc.
+ * Copyright 2017, Joyent, Inc.
  */
 
 
@@ -20,9 +20,9 @@ var urlModule;
 var imgapiUrl;
 var dockerUrl;
 
-var VERSION = '1.4.3';
+var VERSION = '1.0.0';
 
-function pullImageLayers(job, cb) {
+function pullImageLayersV2(job, cb) {
     var queue = vasync.queue(processMessage, 5);
     var queueError;
 
@@ -36,8 +36,6 @@ function pullImageLayers(job, cb) {
     });
     var imgapi = new sdcClients.IMGAPI({url: imgapiUrl});
 
-    var virtualSize = 0;
-
     function processMessage(data, next) {
         if (data.type == 'error') {
             /*
@@ -49,11 +47,8 @@ function pullImageLayers(job, cb) {
                 queueError.name = data.error.code;
             }
             next();
-        } else if (data.type === 'data') {
+        } else if (data.type === 'create-docker-image') {
             createDockerImage(data, next);
-        } else if (data.type === 'head') {
-            job.params.head = data.head;
-            next();
         } else {
             // type 'progress' or 'status'
             if (data.type == 'progress'
@@ -64,30 +59,20 @@ function pullImageLayers(job, cb) {
         }
     }
 
-    // Inside this function we verify if the layer was already refcounted
-    // by this head image before. The idea is that we want to track how
-    // many head images are have a reference to this layer and when there
-    // are no more references to it we can safely remove it from the bucket
-    // when `docker rmi` is called
     function createDockerImage(data, next) {
-        assert.object(data.imgJson, 'data.imgJson');
-        assert.object(data.image, 'data.image');
-        assert.bool(data.private, 'data.private');
+        assert.string(data.digest, 'data.digest');
 
-        var imgJson = data.imgJson;
-        var imgId = imgJson.id;
-
-        var size = imgJson.Size || 0;
-        virtualSize += size;
+        job.log.info('createDockerImage:: data: %s', JSON.stringify(data));
 
         var query = {
             owner_uuid: job.params.account_uuid,
-            index_name: job.params.rat.index.name,
-            docker_id: imgId
+            digest: data.digest
         };
+        // Remeber the digest for tagging.
+        job.params.digest = data.digest;
 
         dockerAdmin.get({
-            path: '/admin/images',
+            path: '/admin/images-v2',
             query: query
         }, function (err, req, res, images) {
             if (err) {
@@ -95,55 +80,16 @@ function pullImageLayers(job, cb) {
                 return;
             }
 
-            var action;
-            var heads;
-
-            if (images.length) {
-                // Layer already exists:
-                // 1) check if this pull is already refcounted and return
-                // 2) update the refcount for this image
-                var image = images[0];
-                if (image.heads.indexOf(job.params.head) !== -1) {
-                    next();
-                    return;
-                }
-
-                action = 'update';
-                image.heads.push(job.params.head);
-                heads = image.heads;
-            } else {
-                action = 'create';
-                heads = [ job.params.head ];
-            }
-
-            var layer = {
-                author: imgJson.author,
-                created: new Date(imgJson.created).getTime(),
-                docker_id: imgId,
-                heads: heads,
-                image_uuid: data.image.uuid,
-                index_name: job.params.rat.index.name,
-                owner_uuid: job.params.account_uuid,
-                size: size,
-                virtual_size: virtualSize,
-                private: data.private
-            };
-
-            if (imgJson.container_config) {
-                layer.container_config = imgJson.container_config;
-            }
-            if (imgJson.config) {
-                layer.config = imgJson.config;
-            }
-            if (imgJson.parent) {
-                layer.parent = imgJson.parent;
-            }
-            if (job.params.head === imgId) {
-                layer.head = true;
+            if (images && images.length > 0) {
+                // Image with this digest already exists - no need to update, if
+                // they have the same digest then they have the same content.
+                next();
+                return;
             }
 
-            var path = '/admin/images?action=' + action;
-            dockerAdmin.post(path, layer, next);
+            var path = '/admin/images-v2?action=create';
+            data.owner_uuid = job.params.account_uuid;
+            dockerAdmin.post(path, data, next);
         });
     }
 
@@ -177,11 +123,8 @@ function pullImageLayers(job, cb) {
 
         lstream.on('readable', function () {
             var line;
-            while ((line = lstream.read()) != null) {
-                line = line.trim();
-
-                var data = JSON.parse(line);
-                queue.push(data);
+            while ((line = lstream.read()) !== null) {
+                queue.push(JSON.parse(line));
             }
         });
 
@@ -202,8 +145,7 @@ function pullImageLayers(job, cb) {
     });
 }
 
-function tagHeadImage(job, cb) {
-    // TODO(DOCKER-584): handle digest when supporting that.
+function tagImageV2(job, cb) {
     if (!job.params.rat.tag) {
         cb(null, 'No tag for head image');
         return;
@@ -218,13 +160,12 @@ function tagHeadImage(job, cb) {
 
     var data = {
         owner_uuid: job.params.account_uuid,
-        index_name: job.params.rat.index.name,
         repo: job.params.rat.localName,
         tag: job.params.rat.tag,
-        docker_id: job.params.head
+        digest: job.params.digest
     };
 
-    dockerAdmin.post('/admin/image_tags', data, function (createErr) {
+    dockerAdmin.post('/admin/image_tags_v2', data, function (createErr) {
         if (createErr) {
             cb(createErr);
             return;
@@ -236,13 +177,13 @@ function tagHeadImage(job, cb) {
 
 
 var workflow = module.exports = {
-    name: 'pull-image-' + VERSION,
+    name: 'pull-image-v2-' + VERSION,
     version: VERSION,
     chain: [ {
-        name: 'pull_image_layers',
+        name: 'pull_image_v2_layers',
         timeout: 3600,
         retry: 1,
-        body: pullImageLayers,
+        body: pullImageLayersV2,
         modules: {
             assert: 'assert-plus',
             LineStream: 'lstream',
@@ -252,10 +193,10 @@ var workflow = module.exports = {
             vasync: 'vasync'
         }
     }, {
-        name: 'tag_head_image',
+        name: 'tag_image_v2',
         timeout: 20,
         retry: 1,
-        body: tagHeadImage,
+        body: tagImageV2,
         modules: {
             restify: 'restify',
             urlModule: 'url'
diff --git a/package.json b/package.json
index 5a227c8..5c9aa7f 100644
--- a/package.json
+++ b/package.json
@@ -10,9 +10,10 @@
     "bunyan": "1.8.5",
     "effluent-logger": "git+https://github.com/joshwilsdon/effluent-logger.git#d662f161a07f94045ad2afb45442931511c40e51",
     "fwrule": "git+https://github.com/joyent/sdc-fwrule.git#d1174be",
-    "imgmanifest": "git+https://github.com/joyent/node-imgmanifest.git#91e5d80",
+    "imgmanifest": "3.0.0",
     "keyapi": "git+https://github.com/joyent/keyapi.git#e14b3d5",
     "libuuid": "0.2.1",
+    "jsprim": "1.3.1",
     "lru-cache": "2.5.0",
     "lstream": "0.0.4",
     "moray": "2.0.0",
diff --git a/sapi_manifests/docker/template b/sapi_manifests/docker/template
index 1bfa4b0..652cf95 100644
--- a/sapi_manifests/docker/template
+++ b/sapi_manifests/docker/template
@@ -54,7 +54,7 @@
     },
     "wfapi": {
         "forceMd5Check": true,
-        "workflows": ["pull-image"],
+        "workflows": ["pull-image-v2"],
         "url": "http://workflow.{{{datacenter_name}}}.{{{dns_domain}}}"
     },
 
diff --git a/test/integration/api-build.test.js b/test/integration/api-build.test.js
index 5ccd8d3..5259c83 100644
--- a/test/integration/api-build.test.js
+++ b/test/integration/api-build.test.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2016, Joyent, Inc.
+ * Copyright (c) 2017, Joyent, Inc.
  */
 
 /*
@@ -292,7 +292,7 @@ test('api: build image conflicts', function (tt) {
 
 
 /**
- * DOCKER-748: Cannot build an image that references multiple registries.
+ * DOCKER-756: Ensure can build an image that references multiple registries.
  */
 test('api: build across multiple registries', function (tt) {
     var imageName = 'quay.io/joyent/triton_alpine_inherit_test:latest';
@@ -310,6 +310,7 @@ test('api: build across multiple registries', function (tt) {
     });
 
     tt.test('docker build from alpine image (cross registry)', function (t) {
+        var dockerImageId;
         var tarStream;
 
         vasync.waterfall([
@@ -335,13 +336,24 @@ test('api: build across multiple registries', function (tt) {
 
                 function onbuild(err, result) {
                     t.ifErr(err, 'build should not error on post');
-                    var msg = result.body;
-                    if (msg.indexOf('different registries') === -1) {
-                        t.fail('expected a "different registries" error '
-                            + 'message, got: "' + msg + '"');
+                    var output = result.body;
+
+                    var hasSuccess = output.indexOf('Successfully built') >= 0;
+                    t.ok(hasSuccess,
+                        'output should contain: Successfully built');
+                    if (hasSuccess) {
+                        var reg = new RegExp('Successfully built (\\w+)');
+                        dockerImageId = output.match(reg)[1];
+                    } else {
+                        t.fail('Output: ' + output);
                     }
                     next();
                 }
+            },
+
+            function removeBuiltImage(next) {
+                t.ok(dockerImageId, 'Got the docker image id');
+                DOCKER_ALICE.del('/images/' + dockerImageId, next);
             }
 
         ], function allDone(err) {
diff --git a/test/integration/api-images-v1-v2.test.js b/test/integration/api-images-v1-v2.test.js
new file mode 100644
index 0000000..aac9b83
--- /dev/null
+++ b/test/integration/api-images-v1-v2.test.js
@@ -0,0 +1,341 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+
+/*
+ * Test docker images that use v1, v2 or both v1/v2 docker image buckets.
+ */
+
+var path = require('path');
+var util = require('util');
+
+var drc = require('docker-registry-client');
+var imgmanifest = require('imgmanifest');
+var libuuid = require('libuuid');
+var test = require('tape');
+var vasync = require('vasync');
+
+var h = require('./helpers');
+var imageV1 = require('../../lib/models/image');
+var imageTagV1 = require('../../lib/models/image-tag');
+var log = require('../lib/log');
+
+
+// --- Globals
+
+var ALICE;
+var DOCKER_ALICE;
+var gInitSuccessful = false;
+var gV1Image;
+var gV1ImageName = 'joyentunsupported/busybox_with_label_test_v1';
+var gV2Image;
+var gV2ImageName = 'joyentunsupported/busybox_with_label_test';
+var imgapiClient;
+var morayClient;
+var STATE = {
+    log: log
+};
+
+
+// --- Tests
+
+
+test('setup', function (tt) {
+
+    tt.test('docker env', function (t) {
+        h.initDockerEnv(t, STATE, {}, function (err, accounts) {
+            t.ifErr(err);
+            ALICE = accounts.alice;
+            t.end();
+        });
+    });
+
+    tt.test('docker client init', function (t) {
+        h.createDockerRemoteClient({user: ALICE}, function (err, client) {
+            t.ifErr(err, 'docker client init');
+            DOCKER_ALICE = client;
+            t.end();
+        });
+    });
+
+    tt.test('imgapi client init', function (t) {
+        h.createImgapiClient(function (err, client) {
+            t.ifErr(err, 'imgapi client init');
+            imgapiClient = client;
+            t.end();
+        });
+    });
+
+    tt.test('moray client init', function (t) {
+        h.createMorayClient(function (err, client) {
+            t.ifErr(err, 'moray client init');
+            morayClient = client;
+            t.end();
+        });
+    });
+});
+
+
+/**
+ * Create v1 and v2 docker images.
+ *
+ * To test a v2 image, we simply docker pull it.
+ * To test a v1 image, we need to jump through some hoops:
+ *  - manually create the IMGAPI image/file
+ *  - manually create the v1 image model (docker_images bucket)
+ */
+test('init docker images', function (tt) {
+    var app = {
+        moray: morayClient
+    };
+
+    tt.test('pull v2 busybox_with_label_test image', function (t) {
+        h.ensureImage({
+            name: gV2ImageName,
+            user: ALICE
+        }, function (err) {
+            t.error(err, 'should be no error pulling image');
+            t.end();
+        });
+    });
+
+    tt.test('inspect v2 image', function (t) {
+        var url = '/images/' + encodeURIComponent(gV2ImageName) + '/json';
+        DOCKER_ALICE.get(url, function (err, req, res, img) {
+            t.error(err, 'get v2 image');
+            gV2Image = img;
+            t.end();
+        });
+    });
+
+    tt.test('create v1 test image', function (t) {
+        var imageUuid = libuuid.create();
+        var dockerId = (imageUuid + imageUuid).replace(/-/g, '');
+        var v1ModelParams = {
+            'config': {
+                'Cmd': null,
+                'Env': null,
+                'ExposedPorts': null,
+                'Image': ''
+            },
+            'container_config': {
+                'Cmd': null,
+                'Env': null,
+                'ExposedPorts': null,
+                'Image': ''
+            },
+            'created': Date.now(),
+            'docker_id': dockerId,
+            'head': true,
+            'heads': [dockerId],
+            'index_name': 'docker.io',
+            'os': 'linux',
+            'owner_uuid': ALICE.account.uuid,
+            'size': 0,
+            'virtual_size': 0
+        };
+
+        vasync.pipeline({arg: {}, funcs: [
+            imgapiCreateDummyImage,
+            imgapiImportDummyImage,
+            imgapiActivateDummyImage,
+            sdcDockerCreateV1Model,
+            sdcDockerCreateV1ModelTag
+        ]}, function (err) {
+            t.error(err, 'should be no error creating dummy IMGAPI image');
+            if (!err) {
+                gInitSuccessful = true;
+            }
+            t.end();
+        });
+
+        function imgapiCreateDummyImage(ctx, next) {
+            var rat = drc.parseRepoAndTag(gV1ImageName);
+            log.debug('dummy: creating dummy image in IMGAPI');
+
+            var manifest = imgmanifest.imgManifestFromDockerInfo({
+                imgJson: v1ModelParams,
+                layerDigests: ['sha256:' + dockerId],
+                owner: ALICE.account.uuid,
+                public: false,
+                repo: rat
+            });
+            manifest.uuid = imageUuid; // Keep image_uuid the same.
+            log.debug({manifest: manifest}, 'createImage manifest');
+            imgapiClient.adminImportImage(manifest, next);
+        }
+
+        function imgapiImportDummyImage(ctx, next) {
+            var opts = {
+                compression: 'none',
+                file: path.normalize(
+                    __dirname + '/../../etc/scratch_image.tar'),
+                uuid: imageUuid
+            };
+            log.debug('dummy: importing dummy image file into IMGAPI');
+            imgapiClient.addImageFile(opts, next);
+        }
+
+        function imgapiActivateDummyImage(ctx, next) {
+            log.debug('dummy: imgapi.activateImage');
+            imgapiClient.activateImage(imageUuid, next);
+        }
+
+        function sdcDockerCreateV1Model(ctx, next) {
+            log.debug('dummy: sdcdocker.createV1Model');
+            v1ModelParams.image_uuid = imageUuid;
+            imageV1.create(app, log, v1ModelParams, function (err, img) {
+                gV1Image = img;
+                next(err);
+            });
+        }
+
+        function sdcDockerCreateV1ModelTag(ctx, next) {
+            log.debug('dummy: sdcdocker.createV1ModelTag');
+            var params = {
+                docker_id: gV1Image.docker_id,
+                index_name: 'docker.io',
+                owner_uuid: ALICE.account.uuid,
+                repo: gV1ImageName,
+                tag: 'latest'
+            };
+            imageTagV1.create(app, log, params, function (err) {
+                next(err);
+            });
+        }
+    });
+});
+
+
+// Ensure v1 and v2 images play nicely together.
+test('test docker v1/v2 images', function (tt) {
+    if (gInitSuccessful === false) {
+        tt.skip('image init failed');
+        tt.end();
+        return;
+    }
+
+    tt.test('list v1/v2 images', function (t) {
+        DOCKER_ALICE.get('/images/json',
+                function (err, req, res, images) {
+            t.error(err, 'should be no error retrieving images');
+            t.ok(images, 'images array');
+            t.ok(images.length >= 2, 'images length >= 2');
+
+            // Check that both the v1 and v2 images are listed.
+            var v1ImageExists = images.filter(function (img) {
+                return img.Id === gV1Image.docker_id;
+            }).length > 0;
+            t.ok(v1ImageExists, 'Expect list images to include v1 image');
+
+            var v2ImageExists = images.filter(function (img) {
+                return img.Id === gV2Image.Id;
+            }).length > 0;
+            t.ok(v2ImageExists, 'Expect list images to include v2 image');
+
+            t.end();
+        });
+    });
+
+    // Test when the v1 and v2 image have the same name.
+    tt.test('tag v2 image with v1 name', function (t) {
+        var url = util.format('/images/%s/tag?repo=%s&tag=latest',
+            gV2ImageName, gV1ImageName);
+        DOCKER_ALICE.post(url, onpost);
+        function onpost(err) {
+            t.error(err, 'should be no error tagging v2 image');
+            t.end();
+        }
+    });
+
+    tt.test('delete v2 image', function (t) {
+        DOCKER_ALICE.del('/images/' + encodeURIComponent(gV2ImageName), ondel);
+        function ondel(err) {
+            t.error(err, 'should be no error deleting v2 image');
+            t.end();
+        }
+    });
+
+    // Inspect the v1 image name (should give us the newly tagged v2 image).
+    tt.test('inspect v2 tagged image', function (t) {
+        var url = '/images/' + encodeURIComponent(gV1ImageName) + '/json';
+        DOCKER_ALICE.get(url, function (err, req, res, img) {
+            t.error(err, 'get v2 tagged image');
+            t.equal(img.Id, gV2Image.Id, 'inspect should give the v2 id');
+            t.end();
+        });
+    });
+
+    // Delete the v2 tagged image.
+    tt.test('delete v2 tagged image', function (t) {
+        DOCKER_ALICE.del('/images/' + encodeURIComponent(gV1ImageName), ondel);
+        function ondel(err) {
+            t.error(err, 'should be no error deleting v2 tagged image');
+            t.end();
+        }
+    });
+
+    tt.test('ensure v2 image is gone', function (t) {
+        DOCKER_ALICE.get('/images/json',
+                function (err, req, res, images) {
+            t.error(err, 'should be no error retrieving images');
+            t.ok(images, 'images array');
+            t.ok(images.length >= 1, 'images length >= 1');
+
+            // Check that both the v1 image exists and v2 image is gone.
+            var v1ImageExists = images.filter(function (img) {
+                return img.Id === gV1Image.docker_id;
+            }).length > 0;
+            t.ok(v1ImageExists, 'Expect list images to include v1 image');
+
+            var v2ImageExists = images.filter(function (img) {
+                return img.Id === gV2Image.Id;
+            }).length > 0;
+            t.notOk(v2ImageExists, 'Expect list images to exclude v2 image');
+
+            t.end();
+        });
+    });
+
+    tt.test('delete v1 image', function (t) {
+        DOCKER_ALICE.del('/images/' + encodeURIComponent(gV1ImageName), ondel);
+        function ondel(err) {
+            t.error(err, 'should be no error deleting v1 image');
+            t.end();
+        }
+    });
+
+    tt.test('ensure v1 and v2 images are gone', function (t) {
+        DOCKER_ALICE.get('/images/json',
+                function (err, req, res, images) {
+            t.error(err, 'should be no error retrieving images');
+            t.ok(images, 'images array');
+
+            // Check that both the v1 and v2 images are gone.
+            var v1ImageExists = images.filter(function (img) {
+                return img.Id === gV1Image.docker_id;
+            }).length > 0;
+            t.notOk(v1ImageExists, 'Expect list images to exclude v1 image');
+
+            var v2ImageExists = images.filter(function (img) {
+                return img.Id === gV2Image.Id;
+            }).length > 0;
+            t.notOk(v2ImageExists, 'Expect list images to exclude v2 image');
+
+            t.end();
+        });
+    });
+});
+
+
+test('teardown', function (tt) {
+    imgapiClient.close();
+    morayClient.close();
+    tt.end();
+});
diff --git a/test/integration/cli-image-tag.test.js b/test/integration/cli-image-tag.test.js
index a57f312..49a5a5d 100644
--- a/test/integration/cli-image-tag.test.js
+++ b/test/integration/cli-image-tag.test.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2016, Joyent, Inc.
+ * Copyright (c) 2017, Joyent, Inc.
  */
 
 /*
@@ -114,9 +114,9 @@ test('tag image', function (tt) {
 
 
 /**
- * DOCKER-748: Cannot build an image that references multiple registries.
+ * DOCKER-756: Check can tag an image that references multiple registries.
  */
-test('DOCKER-748: tag between different registries', function (tt) {
+test('DOCKER-756: tag between different registries', function (tt) {
 
     var tagName = 'quay.io/joyent/' + TAG_PREFIX + 'altbox';
 
@@ -128,12 +128,9 @@ test('DOCKER-748: tag between different registries', function (tt) {
 
     // Tag the image.
     tt.test('tag busybox image', function (t) {
-        cli.docker('tag busybox ' + tagName, {}, onComplete);
-        function onComplete(err, stdout, stderr) {
-            t.assert(err);
-            t.assert(String(err).indexOf('different registries') >= 0,
-                'should be a "different registries" error message');
+        cli.docker('tag busybox ' + tagName, {}, function onComplete(err) {
+            t.ifErr(err);
             t.end();
-        }
+        });
     });
 });
diff --git a/test/integration/helpers.js b/test/integration/helpers.js
index 5405801..8bfec45 100644
--- a/test/integration/helpers.js
+++ b/test/integration/helpers.js
@@ -13,10 +13,11 @@
  */
 
 var assert = require('assert-plus');
+var drc = require('docker-registry-client');
 var exec = require('child_process').exec;
 var fmt = require('util').format;
 var fs = require('fs');
-var mod_log = require('../lib/log');
+var moray = require('moray');
 var os = require('os');
 var path = require('path');
 var sdcClients = require('sdc-clients');
@@ -24,8 +25,10 @@ var restify = require('restify');
 var vasync = require('vasync');
 
 var common = require('../lib/common');
-var sdcCommon = require('../../lib/common');
+var configLoader = require('../../lib/config-loader.js');
 var constants = require('../../lib/constants');
+var mod_log = require('../lib/log');
+var sdcCommon = require('../../lib/common');
 
 
 // --- globals
@@ -1377,6 +1380,16 @@ function ensureImage(opts, callback) {
     var log;
     var name = opts.name;
 
+    // Check if the name includes a tag or digest.
+    try {
+        var rat = drc.parseRepoAndRef(name);
+    } catch (e) {
+        callback(new Error(fmt('Failed to parse image name %s: %s', name, e)));
+        return;
+    }
+
+    var encodedName = encodeURIComponent(rat.localName);
+
     vasync.pipeline({ arg: {}, funcs: [
         function getJsonClient(ctx, next) {
             // Get the json client.
@@ -1390,7 +1403,7 @@ function ensureImage(opts, callback) {
 
         // Check if the image has already been pulled.
         function checkImageExists(ctx, next) {
-            ctx.jsonClient.get('/images/' + name + '/json',
+            ctx.jsonClient.get('/images/' + encodedName + '/json',
                     function _getImage(err) {
                 if (!err) {
                     // Image found, all is good in the world.
@@ -1419,8 +1432,10 @@ function ensureImage(opts, callback) {
         // Image doesn't exist... pull it down.
         function pullImage(ctx, next) {
             log.debug({name: name}, 'ensureImage: pulling image');
-            var url = '/images/create?fromImage='
-                + encodeURIComponent(name);
+            var url = '/images/create?fromImage=' + encodedName;
+            if (rat.tag || rat.digest) {
+                url += '&tag=' + encodeURIComponent(rat.tag || rat.digest);
+            }
             ctx.httpClient.post(url, function _onPost(err, req) {
                 if (err) {
                     next(err);
@@ -1465,7 +1480,7 @@ function ensureImage(opts, callback) {
 
         // Check again to ensure the image now exists.
         function recheckImageExists(ctx, next) {
-            ctx.jsonClient.get('/images/' + name + '/json',
+            ctx.jsonClient.get('/images/' + encodedName + '/json',
                     function _getImage(err) {
                 if (err) {
                     log.error({name: name}, 'Error pulling image, body: %s',
@@ -1864,10 +1879,65 @@ function getSortedPackages(callback) {
 }
 
 
+function createMorayClient(callback) {
+    var log = mod_log;
+    var sdcDockerConfig = configLoader.loadConfigSync({log: log});
+
+    var morayConfig = {
+        host: sdcDockerConfig.moray.host,
+        noCache: true,
+        port: sdcDockerConfig.moray.port,
+        reconnect: true,
+        dns: {
+            resolvers: [sdcDockerConfig.binder.domain]
+        }
+    };
+
+    log.debug(morayConfig, 'Creating moray client');
+    morayConfig.log = log.child({
+        component: 'moray',
+        level: 'warn'
+    });
+    var client = moray.createClient(morayConfig);
+
+    function onMorayConnect() {
+        client.removeListener('error', onMorayError);
+        client.log.info('moray: connected');
+        callback(null, client);
+    }
+
+    function onMorayError(err) {
+        client.removeListener('connect', onMorayConnect);
+        client.log.error(err, 'moray: connection failed');
+        callback(err);
+    }
+
+    client.once('connect', onMorayConnect);
+    client.once('error', onMorayError);
+
+    return client;
+}
+
+
+function createImgapiClient(callback) {
+    var sdcDockerConfig = configLoader.loadConfigSync({log: mod_log});
+
+    var client = new sdcClients.IMGAPI({
+        agent: false,
+        log: mod_log,
+        url: sdcDockerConfig.imgapi.url,
+        userAgent: UA
+    });
+    callback(null, client);
+}
+
+
 // --- exports
 
 module.exports = {
     createDockerRemoteClient: createDockerRemoteClient,
+    createImgapiClient: createImgapiClient,
+    createMorayClient: createMorayClient,
     createSapiClient: createSapiClient,
     createFwapiClient: createFwapiClient,
     createPapiClient: createPapiClient,
