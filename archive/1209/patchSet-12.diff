commit 2035e42933a3701774d4db81237551df33735b37 (refs/changes/09/1209/12)
Author: Todd Whiteman <todd.whiteman@joyent.com>
Date:   2017-07-18T13:14:25-07:00 (2 years, 3 months ago)
    
    DOCKER-929 Support the docker v2.2 manifest format

diff --git a/docs/api/commands/build.md b/docs/api/commands/build.md
index 5d0ae8d..b774f4a 100644
--- a/docs/api/commands/build.md
+++ b/docs/api/commands/build.md
@@ -118,8 +118,7 @@ There should be informational output of the reason for failure output to
     $ docker build .
     Uploading context 10240 bytes
     Step 1 : FROM busybox
-    Pulling repository busybox
-     ---> e9aa60c60128MB/2.284 MB (100%) endpoint: https://cdn-registry-1.docker.io/v1/
+     ---> e9aa60c60128MB
     Step 2 : RUN ls -lh /
      ---> Running in 9c9e81692ae9
     total 24
@@ -296,34 +295,10 @@ unique to Triton.
 ### Docker build step divergence:
 
 * `ADD` with remote URL is unimplemented.
-* `ADD` with wildcard is unimplemented.
-* `image layers` are only created at the end of a successful build (instead of
-  after a successful instruction).
 * the build container is reused for each build step (instead of creating a new
   container)
 
-### Docker build multiple registry divergence:
-
-In Triton SDC Docker, the built image cannot reference images between two
-different registries.
-
-For example, this build would fail as it generates an image without a tag and
-thus the generated image is assigned a default registry of *docker.io* - and you
-cannot have images referencing two registries *docker.io* and *quay.io*:
-
-```
-    $ echo -e 'FROM quay.io/user/image\nLABEL key=val' | docker build -
-    ... build fails
-```
-
-the workaround would be to tag the image with a *quay.io* registry tag:
-
-```
-    $ echo -e 'FROM quay.io/user/image\nLABEL key=val' | docker build -t quay.io/user/othername -
-    ... build successful
-```
-
-
 ## Related
 
-- Insert a list of related Docker and CloudAPI methods here
+- [`docker commit`](../commands/commit.md)
+- [`docker images`](../commands/images.md)
diff --git a/docs/api/commands/commit.md b/docs/api/commands/commit.md
index 32781f4..2230365 100644
--- a/docs/api/commands/commit.md
+++ b/docs/api/commands/commit.md
@@ -1,19 +1,83 @@
 # commit
 
-## Divergence
+    Usage: docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]
+
+    Create a new image from a container's changes
+
+      -a, --author=""     Author (e.g., "John Hannibal Smith <hannibal@a-team.com>")
+      -c, --change=[]     Apply specified Dockerfile instructions while committing the image
+      --help              Print usage
+      -m, --message=""    Commit message
+      -p, --pause=true    Pause container during commit
+
+It can be useful to commit a container's file changes or settings into a new
+image. This allows you debug a container by running an interactive shell, or to
+export a working dataset to another server. Generally, it is better to use
+Dockerfiles to manage your images in a documented and maintainable way.
+
+The commit operation will not include any data contained in
+volumes mounted inside the container.
+
+By default, the container being committed and its processes will be paused
+while the image is committed. This reduces the likelihood of encountering data
+corruption during the process of creating the commit.  If this behavior is
+undesired, set the `--pause` option to false.
+
+The `--change` option will apply `Dockerfile` instructions to the image that is
+created.  Supported `Dockerfile` instructions:
+`CMD`|`ENTRYPOINT`|`ENV`|`EXPOSE`|`LABEL`|`ONBUILD`|`USER`|`VOLUME`|`WORKDIR`
+
+## Commit a container
 
-Commit works the same in Triton SDC Docker and Docker Inc, except for below caveat:
+    $ docker ps
+    ID                  IMAGE               COMMAND             CREATED             STATUS              PORTS
+    c3f279d17e0a        ubuntu:12.04        /bin/bash           7 days ago          Up 25 hours
+    197387f1b436        ubuntu:12.04        /bin/bash           7 days ago          Up 25 hours
+    $ docker commit c3f279d17e0a  svendowideit/testimage:version3
+    f5283438590d
+    $ docker images
+    REPOSITORY                        TAG                 ID                  CREATED             SIZE
+    svendowideit/testimage            version3            f5283438590d        16 seconds ago      335.7 MB
 
- * in Triton SDC Docker, an image cannot have tags that reference two different
-   registries. Example:
+## Commit a container with new configurations
+
+    $ docker ps
+    ID                  IMAGE               COMMAND             CREATED             STATUS              PORTS
+    c3f279d17e0a        ubuntu:12.04        /bin/bash           7 days ago          Up 25 hours
+    197387f1b436        ubuntu:12.04        /bin/bash           7 days ago          Up 25 hours
+    $ docker inspect -f "{{ .Config.Env }}" c3f279d17e0a
+    [HOME=/ PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin]
+    $ docker commit --change "ENV DEBUG true" c3f279d17e0a  svendowideit/testimage:version3
+    f5283438590d
+    $ docker inspect -f "{{ .Config.Env }}" f5283438590d
+    [HOME=/ PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin DEBUG=true]
+
+## Commit a container with new `CMD` and `EXPOSE` instructions
+
+    $ docker ps
+    ID                  IMAGE               COMMAND             CREATED             STATUS              PORTS
+    c3f279d17e0a        ubuntu:12.04        /bin/bash           7 days ago          Up 25 hours
+    197387f1b436        ubuntu:12.04        /bin/bash           7 days ago          Up 25 hours
+
+    $ docker commit --change='CMD ["apachectl", "-DFOREGROUND"]' -c "EXPOSE 80" c3f279d17e0a  svendowideit/testimage:version4
+    f5283438590d
+
+    $ docker run -d svendowideit/testimage:version4
+    89373736e2e7f00bc149bd783073ac43d0507da250e999f3f1036e0db60817c0
+
+    $ docker ps
+    ID                  IMAGE               COMMAND                 CREATED             STATUS              PORTS
+    89373736e2e7        testimage:version4  "apachectl -DFOREGROU"  3 seconds ago       Up 2 seconds        80/tcp
+    c3f279d17e0a        ubuntu:12.04        /bin/bash               7 days ago          Up 25 hours
+    197387f1b436        ubuntu:12.04        /bin/bash               7 days ago          Up 25 hours
+
+## Divergence
 
-    ```
-        $ docker run -d busybox sh -c "touch /newfile.txt && sleep 86400"
-        123456789
-        $ docker commit 123456789 tagname  (okay, same registry - 'docker.io')
-        $ docker commit 123456789 quay.io/user/tagname   (different registry - fails)
-    ```
+There is no known divergence between the Triton SDC Docker and Docker Inc.
+implementations of this method. Please contact Joyent support or file a ticket
+if you discover any.
 
 ## Related
 
-- Insert a list of related Docker and CloudAPI methods here
+- [`docker build`](../commands/build.md)
+- [`docker images`](../commands/images.md)
diff --git a/docs/api/commands/images.md b/docs/api/commands/images.md
index 9605320..fe37f61 100644
--- a/docs/api/commands/images.md
+++ b/docs/api/commands/images.md
@@ -127,4 +127,5 @@ if you discover any.
 
 - [`docker inspect`](../commands/inspect.md)
 - [`docker history`](../commands/history.md)
+- [`docker pull`](../commands/pull.md)
 - [`docker rmi`](../commands/rmi.md)
diff --git a/docs/api/commands/pull.md b/docs/api/commands/pull.md
index 9d9277c..0bea953 100644
--- a/docs/api/commands/pull.md
+++ b/docs/api/commands/pull.md
@@ -44,8 +44,6 @@ use `docker pull`:
 `docker pull -a` and `--disable-content-trust=true` are currently unsupported.
 Follow [DOCKER-531](http://smartos.org/bugview/DOCKER-531) for updates.
 
-Identifying a repo version by digest is not supported at this time. Use tag instead.
-
 The first status line from a `docker pull` shows a UUID:
 
     $ docker pull busybox
diff --git a/docs/api/divergence.md b/docs/api/divergence.md
index 2603cc0..a0b8b35 100644
--- a/docs/api/divergence.md
+++ b/docs/api/divergence.md
@@ -111,11 +111,7 @@ expect it to get shorter by the day:
 ## Images and private registries
 
 SDC Docker supports the integration with Docker Hub and third party registries through
-Docker's Registry v1 and v2 API. The use of the short or long Image ID may not uniquely
-identify an image if images of the same ID exist in more than one repo. To work around
-this Registry API limitation in such rare case, use the repo, image and tag name in
-the image management API methods (e.g. `docker pull`, `docker inspect`) instead of
-the Image ID.
+Docker's Registry v2 API (the deprecated v1 API is not supported).
 
 ### Container Logging
 
diff --git a/docs/api/features/repos.md b/docs/api/features/repos.md
index c1ce8be..def19a7 100644
--- a/docs/api/features/repos.md
+++ b/docs/api/features/repos.md
@@ -4,9 +4,11 @@ SDC-Docker supports the use of Docker images maintained in the following registr
 
 - Docker Hub's public registry
 - Docker Hub's private registry
-- Self-hosted v1 and v2 Docker registry, including Docker Trusted Registry
-- quay.io v1 Docker registry
-- jFrog Artifactory v1 and v2 Docker registry
+- Self-hosted Docker registry, including Docker Trusted Registry
+- quay.io Docker registry
+- jFrog Artifactory Docker registry
+
+Note that Triton sdc-docker only supports v2 registries.
 
 You can connect to multiple registries at the same time and pull images from them
 without having to switch from one to another.
diff --git a/etc/scratch_image.json b/etc/scratch_image.json
index c8c4363..9e4f0a9 100644
--- a/etc/scratch_image.json
+++ b/etc/scratch_image.json
@@ -49,11 +49,14 @@
         "MacAddress": "",
         "OnBuild": null
     },
-    "created": "2015-12-01T12:00:00.000Z",
-    "docker_version": "1.9.0",
-    "id": "0000000000007363726174636800aeee14d7eabd60b564604d05000000000000",
+    "created": "2016-11-09T12:00:00.000Z",
+    "docker_version": "1.12.2",
     "os": "linux",
-    "parent": "",
-    "size": 0,
-    "virtual_size": 0
+    "size": 1024,
+    "rootfs": {
+        "type": "layers",
+        "diff_ids": [
+            "sha256:5f70bf18a086007016e948b04aed3b82103a36bea41755b6cddfaf10ace3c6ef"
+        ]
+    }
 }
diff --git a/etc/scratch_image.manifest b/etc/scratch_image.manifest
new file mode 100644
index 0000000..e7ed0d1
--- /dev/null
+++ b/etc/scratch_image.manifest
@@ -0,0 +1,16 @@
+{
+   "schemaVersion": 2,
+   "mediaType": "application/vnd.docker.distribution.manifest.v2+json",
+   "config": {
+      "mediaType": "application/vnd.docker.container.image.v1+json",
+      "size": 1533,
+      "digest": "sha256:3a97ef6fc490929f6a0b666cb21e12796067f4c8169fc0dd4d6a41dc2151c8ca"
+   },
+   "layers": [
+      {
+         "mediaType": "application/vnd.docker.image.rootfs.diff.tar.gzip",
+         "size": 32,
+         "digest": "sha256:a3ed95caeb02ffe68cdd9fd84406680ae93d633cb16422d00e8a7c22955b46d4"
+      }
+   ]
+}
diff --git a/lib/backends/sdc/build.js b/lib/backends/sdc/build.js
index e214f9b..3f58a65 100644
--- a/lib/backends/sdc/build.js
+++ b/lib/backends/sdc/build.js
@@ -16,12 +16,15 @@ var stream = require('stream');
 
 var assert = require('assert-plus');
 var drc = require('docker-registry-client');
+var jsprim = require('jsprim');
+var imgmanifest = require('imgmanifest');
 var LineStream = require('lstream');
 var once = require('once');
 var vasync = require('vasync');
 
 var common = require('../../common');
 var errors = require('../../../lib/errors');
+var ImageV2 = require('../../models/image-v2');
 var images = require('./images');
 var utils = require('./utils');
 
@@ -30,28 +33,6 @@ var utils = require('./utils');
 //---- globals
 
 
-/**
- * Return an image object in the docker inspect format.
- */
-function getImageInInspectFormat(dockerId, opts, callback) {
-    assert.string(dockerId, 'dockerId');
-    assert.object(opts, 'opts');
-    assert.string(opts.index_name, 'opts.index_name');
-    assert.object(opts.log, 'opts.log');
-    assert.object(opts.req, 'opts.req');
-    assert.string(opts.req_id, 'opts.req_id');
-
-    var inspectOpts = {
-        account: opts.req.account,
-        app: opts.req.app,
-        index_name: opts.index_name,
-        log: opts.log,
-        name: dockerId,
-        req_id: opts.req_id
-    };
-    opts.req.backend.inspectImage(inspectOpts, callback);
-}
-
 /**
  * Build an image, given build params and a build context (tarball).
  *
@@ -71,12 +52,9 @@ function buildImage(opts, callback) {
     assert.object(opts.res, 'opts.res');
     assert.string(opts.req_id, 'opts.req_id');
 
-    var allDockerImages = [];
-    var baseImageId = null;         // Base image id our build is based on.
-    var baseImageIndexName = null;  // Base index_name our build is based on.
     var buildFinishedSuccessfully = false;
     var dockerOpts = opts.dockerOpts;
-    var finalImageId = null;  // Final docker image id for resulting image.
+    var finalImageDigest = null;  // Final image digest for resulting image.
     var log = opts.log;
     var previousErr;
     var rat = opts.rat;
@@ -89,13 +67,16 @@ function buildImage(opts, callback) {
     var vmDockerId;
     var vmUuid;
 
+    if (!rat) {
+        rat = drc.parseRepoAndTag('');
+    }
+
     // There is the potential to run the callback twice, so make sure that never
     // happens.
     callback = once(callback);
 
     vasync.pipeline({ funcs: [
         buildGetScratchImage,
-        buildGetAllDockerImages,
         buildCreateContainer,
         buildGetVmObject,
         buildCnapiDockerBuild,
@@ -119,48 +100,6 @@ function buildImage(opts, callback) {
     }
 
 
-    function buildGetAllDockerImages(_, cb) {
-        // If nocache is specified, there is no need to lookup all images, as
-        // this list of images is *only* used for build caching.
-        if (dockerOpts.nocache) {
-            cb();
-            return;
-        }
-        var listOpts = {
-            account: req.account,
-            all: true,
-            app: req.app,
-            clientApiVersion: req.clientApiVersion,
-            log: log,
-            req_id: req_id,
-            skip_smartos: true
-        };
-        req.backend.listImages(listOpts, function _listImagesCb(err, imgs) {
-            if (err) {
-                cb(err);
-                return;
-            }
-            // Convert an img into the docker inspect format.
-            function getImageDetails(img, next) {
-                var inspectOpts = {
-                    index_name: img.IndexName,
-                    log: log,
-                    req: req,
-                    req_id: req_id
-                };
-                getImageInInspectFormat(img.Id, inspectOpts, next);
-            }
-            vasync.forEachPipeline({
-                'func': getImageDetails,
-                'inputs': imgs
-            }, function _getImageDetailsCb(err2, results) {
-                allDockerImages = results.successes;
-                cb(err2);
-            });
-        });
-    }
-
-
     function buildCreateContainer(_, cb) {
         var labels;
         try {
@@ -247,7 +186,7 @@ function buildImage(opts, callback) {
         cnapiBuildPayload.account_uuid = req.account.uuid;
         cnapiBuildPayload.command = 'build';  // Command type.
         cnapiBuildPayload.imgapi_url = req.app.config.imgapi.url;
-        cnapiBuildPayload.allDockerImages = allDockerImages;
+        cnapiBuildPayload.scratchImageUuid = scratchImage.image_uuid;
 
         /* CNAPI, go build for us. */
         cnapi.dockerBuild(vm.server_uuid, vmUuid,
@@ -330,7 +269,7 @@ function buildImage(opts, callback) {
                 response.error = err.message;
             }
             if (typeof (result) !== 'undefined') {
-                response['result'] = result;
+                response.result = result;
             }
             log.debug('response:', response);
             buildSocket.write(JSON.stringify(response) + '\n');
@@ -402,6 +341,19 @@ function buildImage(opts, callback) {
                         'stream': event.message
                     }) + '\n');
                     break;
+                case 'find_cached_image':
+                    var findOpts = {
+                        account_uuid: req.account.uuid,
+                        app: req.app,
+                        cmd: event.cmd,
+                        labels: event.labels,
+                        log: log,
+                        parentDigest: event.parentDigest
+                    };
+                    findCachedImage(findOpts, function _findImageCb(err, img) {
+                        sendEventResponse(event, err, img);
+                    });
+                    break;
                 case 'image_reprovision':
                     assert.string(event.cmdName, 'event.cmdName');
                     assert.string(event.imageName, 'event.imageName');
@@ -414,15 +366,13 @@ function buildImage(opts, callback) {
                         req_id: req_id,
                         res: res,
                         vm: vm
-                    }, function _pullReprovCb(err, result) {
-                        // Note: result.image is in docker inspect format.
+                    }, function _pullReprovCb(err, img) {
+                        // Note: img is an ImageV2 model instance.
                         if (!err) {
-                            baseImageId = result.image.Id;
-                            baseImageIndexName = result.index_name;
-                            log.debug('reprovisioned to baseImageId: %j',
-                                baseImageId);
+                            log.debug('reprovisioned to base image digest: %j',
+                                img.config_digest);
                         }
-                        sendEventResponse(event, err, result);
+                        sendEventResponse(event, err, img);
                     });
                     break;
                 case 'image_create':
@@ -435,7 +385,7 @@ function buildImage(opts, callback) {
                 case 'run':
                     runBuildCommand(
                     {
-                        dockerId: vmDockerId,
+                        vmDockerId: vmDockerId,
                         log: log,
                         req: req,
                         req_id: req_id,
@@ -446,24 +396,12 @@ function buildImage(opts, callback) {
                     });
                     break;
                 case 'build_finished':
-                    finalImageId = event.finalId;
-                    vasync.pipeline({ funcs: [
-                        function _doAddBaseImageHead(_result, next) {
-                            addBaseImageHead(baseImageId, finalImageId,
-                            {
-                                baseImageIndexName: baseImageIndexName,
-                                req: req,
-                                scratchImage: scratchImage
-                            }, next);
-                        },
-                        function _doTagImage(_result, next) {
-                            tagImage({
-                                    docker_id: finalImageId,
-                                    name: dockerOpts.tag,
-                                    req: req
-                                }, next);
-                        }
-                    ]}, function buildFinishPipeCb(err) {
+                    finalImageDigest = event.finalImageDigest;
+                    tagImage({
+                        config_digest: finalImageDigest,
+                        name: dockerOpts.tag,
+                        req: req
+                    }, function _tagImageCb(err) {
                         if (!err) {
                             buildFinishedSuccessfully = true;
                         }
@@ -495,9 +433,11 @@ function buildImage(opts, callback) {
                 return;
             } else {
                 // Send the successfully built image message.
+                var shortId = imgmanifest.shortDockerId(
+                    imgmanifest.dockerIdFromDigest(finalImageDigest));
                 res.write(JSON.stringify({
                     'stream': format('Successfully built %s\n',
-                        finalImageId.substr(0, 12))
+                        shortId)
                 }) + '\n');
             }
             callback(cleanuperr);
@@ -562,13 +502,55 @@ function buildImage(opts, callback) {
 }
 
 
+function findCachedImage(opts, callback) {
+    assert.string(opts.account_uuid, 'opts.account_uuid');
+    assert.object(opts.app, 'opts.app');
+    assert.string(opts.cmd, 'opts.cmd');
+    assert.optionalObject(opts.labels, 'opts.labels');
+    assert.object(opts.log, 'opts.log');
+    assert.optionalString(opts.parentDigest, 'opts.parentDigest');
+
+    var filter = {
+        parent: opts.parentDigest || '',
+        owner_uuid: opts.account_uuid
+    };
+
+    var log = opts.log;
+
+    ImageV2.list(opts.app, log, filter, function (err, imgs) {
+        if (err) {
+            callback(err);
+            return;
+        }
+
+        log.debug('findCachedImage: %d possible images', imgs.length);
+        var matchedImgs = imgs.filter(function _cachedImgFilter(img) {
+            // Images must have the same Cmd entry.
+            if (opts.cmd !== img.container_config.Cmd.join(' ')) {
+                return false;
+            }
+            // Some fields (like Labels) can also be set from the client, check
+            // that these fields are the same.
+            if (!(jsprim.deepEqual(opts.labels, img.image.config.Labels))) {
+                return false;
+            }
+
+            return true;
+        });
+
+        log.debug('findCachedImage: %d images matched', matchedImgs.length);
+        callback(null, matchedImgs && matchedImgs[0] || null);
+    });
+}
+
+
 function pullImage(opts, callback) {
     var imageName = opts.imageName;
     var log = opts.log;
     var req = opts.req;
     var res = opts.res;
 
-    log.debug('pullImage');
+    log.debug({imageName: imageName}, 'pullImage');
 
     // 1. Parse the image name.
     // 2. Pull the image if it's not already downloaded.
@@ -585,7 +567,6 @@ function pullImage(opts, callback) {
         app: req.app,
         log: log,
         account: req.account,
-        index_name: rat.index.name,
         name: imageName,
         includeSmartos: false
     };
@@ -656,45 +637,26 @@ function reprovisionFromImageUuid(image_uuid, opts, callback) {
  * reprovision the container with that image.
  */
 function pullAndReprovisionImage(opts, callback) {
-    pullImage(opts, function pullImage_callback(err, image) {
-        // Note: image is in the imgapi format.
+    pullImage(opts, function pullImage_callback(err, img) {
+        // Note: img is an Image model instance.
         if (err) {
             callback(err);
             return;
         }
         // Warning: pullImage can return a null image, which means an error
         // occurred (e.g. the requested image was not found).
-        if (!image) {
+        if (!img) {
             callback(new errors.DockerError(
                 'could not pull image: ' + opts.imageName));
             return;
         }
 
-        // DOCKER-748: Ensure the tag and the base image are from the same repo.
-        var index_name = opts.rat && opts.rat.index.name || 'docker.io';
-        if (index_name !== image.index_name) {
-            opts.log.warn('Build failure - using different registries: %s, %s',
-                index_name, image.index_name);
-            callback(new errors.DockerError(format(
-                'Cannot build an image that references different registries '
-                + '(%s, %s)', index_name, image.index_name)));
-            return;
-        }
-
-        reprovisionFromImageUuid(image.image_uuid, opts, function (rerr) {
+        reprovisionFromImageUuid(img.image_uuid, opts, function (rerr) {
             if (rerr) {
                 callback(rerr);
                 return;
             }
-            var dockerId = image.docker_id;
-            opts.index_name = image.index_name;
-            getImageInInspectFormat(dockerId, opts, function (ierr, iimg) {
-                if (ierr) {
-                    callback(ierr);
-                    return;
-                }
-                callback(null, { image: iimg, index_name: image.index_name });
-            });
+            callback(null, img);
         });
     });
 }
@@ -705,115 +667,28 @@ function pullAndReprovisionImage(opts, callback) {
  */
 function createImage(payload, opts, callback) {
     assert.object(payload, 'payload');
-    assert.string(payload.finalId, 'payload.finalId');
+    assert.string(payload.config_digest, 'payload.config_digest');
+    assert.bool(payload.head, 'payload.head');
     assert.object(payload.image, 'payload.image');
+    assert.string(payload.manifest_digest, 'payload.manifest_digest');
+    assert.string(payload.manifest_str, 'payload.manifest_str');
     assert.number(payload.size, 'payload.size');
-    assert.optionalNumber(payload.virtual_size, 'payload.virtual_size');
     assert.object(opts, 'opts');
-    assert.optionalObject(opts.rat, 'opts.rat');
     assert.object(opts.req, 'opts.req');
 
-    var rat = opts.rat;
     var req = opts.req;
-    var createOpts = {
-        payload: {
-            head: (payload.finalId === payload.image.id),
-            heads: [payload.finalId],
-            image: payload.image,
-            size: payload.size,
-            virtual_size: payload.virtual_size
-        },
-        rat: rat,
-        req: req
-    };
-
-    req.log.debug(format('Creating image %j', createOpts.payload));
-    req.backend.createImage(createOpts, callback);
-}
-
-
-/**
- * Update all parent images of finalImageId to include a head reference to
- * finalImageId (for sdc-docker image model).
- */
-function addBaseImageHead(baseImageId, finalImageId, opts, callback) {
-    assert.string(finalImageId, 'finalImageId');
-    assert.object(opts, 'opts');
-    assert.object(opts.req, 'opts.req');
-    assert.object(opts.scratchImage, 'opts.scratchImage');
-
-    if (!baseImageId || (baseImageId === opts.scratchImage.id)) {
-        callback();
-        return;
-    }
 
-    assert.string(baseImageId, 'baseImageId');
-    assert.string(opts.baseImageIndexName, 'opts.baseImageIndexName');
-    var req = opts.req;
-    var log = req.log;
-
-    // Find the base image.
-    var imageOpts = {
-        app: req.app,
-        log: log,
-        account: req.account,
-        name: baseImageId,
-        index_name: opts.baseImageIndexName,
-        includeSmartos: false
+    var modelOpts = {
+        config_digest: payload.config_digest,
+        head: payload.head,
+        image_uuid: payload.image_uuid,
+        manifest_digest: payload.manifest_digest,
+        manifest_str: payload.manifest_str,
+        owner_uuid: req.account.uuid,
+        size: payload.size
     };
-    req.backend.imgFromName(imageOpts, function (findErr, image) {
-        if (findErr) {
-            callback(findErr);
-            return;
-        }
-        if (!image) {
-            callback(new errors.DockerError(
-                'could not find base image: ' + baseImageId));
-            return;
-        }
-
-        // Update base image (and all base image parent images) to include the
-        // new head reference.
-        req.backend.getImageHistory({
-            account: req.account,
-            app: req.app,
-            img: image,
-            log: log
-        }, function (histErr, history) {
-            if (histErr) {
-                callback(new errors.DockerError(histErr,
-                    'could not create image layer'));
-                return;
-            }
-
-            vasync.forEachPipeline({
-                inputs: history,
-                func: addImageHead
-            }, function (err) {
-                if (err) {
-                    callback(new errors.DockerError(err,
-                        'could not create image layer'));
-                    return;
-                }
-                callback();
-            });
-
-            function addImageHead(img, next) {
-                log.debug('addImageHead img id: %s, head: %s',
-                    img.docker_id, finalImageId);
-                var addHeadOpts = {
-                    heads: [finalImageId],
-                    id: img.docker_id,
-                    index_name: img.index_name,
-                    req: req
-                };
-
-                req.log.debug(format('Adding %j to %j image heads',
-                    finalImageId, img.docker_id));
-                req.backend.addImageHeads(addHeadOpts, next);
-            }
-        });
-    });
+    var img = images.dockerImageJsonToModel(payload.image, modelOpts);
+    ImageV2.create(req.app, req.log, img, callback);
 }
 
 
@@ -822,7 +697,7 @@ function addBaseImageHead(baseImageId, finalImageId, opts, callback) {
  */
 function tagImage(opts, callback) {
     assert.object(opts, 'opts');
-    assert.string(opts.docker_id, 'opts.docker_id');
+    assert.string(opts.config_digest, 'opts.config_digest');
     assert.object(opts.req, 'opts.req');
     assert.optionalString(opts.name, 'opts.name');
 
@@ -831,8 +706,8 @@ function tagImage(opts, callback) {
         return;
     }
 
-    opts.req.log.debug(format('Adding tag %j to image with docker id %j',
-                            opts.name, opts.docker_id));
+    opts.req.log.debug({name: opts.name, config_digest: opts.config_digest},
+        'Tag image');
     opts.req.backend.tagImage(opts, callback);
 }
 
@@ -860,7 +735,7 @@ function runBuildCommand(opts, callback) {
         AttachStdout: true,
         AttachStderr: true,
         Cmd: ['AttachConsole'], // To fix in cn-agent
-        Container: opts.dockerId,
+        Container: opts.vmDockerId,
         Tty: false
     };
 
@@ -891,7 +766,7 @@ function runBuildCommand(opts, callback) {
                 account: req.account,
                 app: req.app,
                 doNotEncodeData: true,  // Don't encode when writing to stream.
-                id: opts.dockerId,
+                id: opts.vmDockerId,
                 log: log,
                 payload: payload,
                 req_id: opts.req_id,
@@ -966,14 +841,12 @@ function commitImage(req, opts, callback) {
     assert.object(vm, 'vm');  // Should have been added by the backend.
 
     var baseImg;
-    var baseImageId = vm.internal_metadata['docker:imageid'];
     var commitFinishedSuccessfully = false;
-    var finalImageId = null;  // Final docker image id for resulting image.
+    var finalImageDigest = null;  // Final image digest for resulting image.
     var log = req.log;
     var previousErr;
     var rat;
     var req_id = req.getId();
-    var scratchImage;
     var socketOpts;
 
     // There is the potential to run the callback twice, so make sure that never
@@ -988,53 +861,33 @@ function commitImage(req, opts, callback) {
     }
 
     vasync.pipeline({ funcs: [
-        getScratchImage,
         findContainerImage,
-        checkTagRepository,
         startCnapiDockerCommit,
         runCnapiDockerCommit
     ]}, commitCleanup);
 
-
-    function getScratchImage(_, cb) {
-        req.app.backend.getScratchImage(req,
-        function _getScratchImageCb(err, sImg) {
-            if (err) {
-                log.error(err, 'getScratchImage failure');
-                cb(err);
-                return;
-            }
-            scratchImage = sImg;
-            cb();
-        });
-    }
-
     // Find the Image model for running container.
     function findContainerImage(_, cb) {
+        var config_digest = vm.internal_metadata['docker:imageid'];
+        if (!config_digest) {
+            cb(new errors.DockerError(
+                'No docker:imageid in vm internal metadata'));
+            return;
+        }
         var dockerImageOpts = {
             account: req.account,
             app: req.app,
+            config_digest: config_digest,
             log: log
         };
-        images.getDockerImageForUuid(vm.image_uuid, dockerImageOpts,
-            function _dockerImageUuidCb(err, imgModel) {
+        images.imgFromConfigDigest(dockerImageOpts,
+            function _imgFromDigestCb(err, imgModel) {
                 baseImg = imgModel;
                 cb(err);
             }
         );
     }
 
-    function checkTagRepository(_, cb) {
-        // DOCKER-748: Ensure the tag and the image are in the same repository.
-        if (baseImg.index_name !== rat.index.name) {
-            cb(new errors.DockerError(format(
-                'Cannot create tag reference between different registries '
-                + '(%s, %s)', baseImg.index_name, rat.index.name)));
-            return;
-        }
-        cb();
-    }
-
     // Start the cn-agent commit task.
     function startCnapiDockerCommit(_, cb) {
         var cnapi = req.app.cnapi;
@@ -1057,8 +910,7 @@ function commitImage(req, opts, callback) {
 
         cnapiCommitPayload.account_uuid = req.account.uuid;
         cnapiCommitPayload.command = 'commit';  // Command type.
-        cnapiCommitPayload.fromImage = utils.imgobjToInspect(baseImg);
-        cnapiCommitPayload.fromImageUuid = vm.image_uuid;
+        cnapiCommitPayload.fromImg = baseImg;
         cnapiCommitPayload.imgapi_url = req.app.config.imgapi.url;
 
         /* CNAPI, commit the container to an image for us. */
@@ -1120,7 +972,7 @@ function commitImage(req, opts, callback) {
         {
             var line;
             var event;
-            while ((line = commitEventStream.read()) != null) {
+            while ((line = commitEventStream.read()) !== null) {
                 log.debug('commit: got commit event:', String(line));
                 try {
                     event = JSON.parse(line);
@@ -1128,57 +980,48 @@ function commitImage(req, opts, callback) {
                     log.error('Commit: invalid json: %s - ignoring', line);
                     continue;
                 }
-                switch (event.type) {
-                    case 'end':
-                        if (event.error) {
-                            // Will be passed to callback `cb`.
-                            commitError = new Error(event.error);
-                        }
-                        break;
-                    case 'message':
-                    case 'stdout':
-                        log.info('Commit event message: %s', event.message);
-                        break;
-                    case 'image_create':
-                        createImage(event.payload, { rat: rat, req: req },
-                            function _imageCreateCb(err, result)
-                        {
-                            sendEventResponse(event, err, result);
-                        });
-                        break;
-                    case 'commit_finished':
-                        finalImageId = event.finalId;
-                        vasync.pipeline({ funcs: [
-                            function _doAddBaseImageHead(_result, next) {
-                                addBaseImageHead(baseImageId, finalImageId,
-                                {
-                                    baseImageIndexName: baseImg.index_name,
-                                    req: req,
-                                    scratchImage: scratchImage
-                                }, next);
-                            },
-                            function _doTagImage(_result, next) {
-                                tagImage({
-                                        docker_id: finalImageId,
-                                        name: opts.tag,
-                                        req: req
-                                    }, next);
-                            }
-                        ]}, function commitFinishPipeCb(err) {
-                            if (!err) {
-                                commitFinishedSuccessfully = true;
-                            }
-                            sendEventResponse(event, err);
-                        });
-                        break;
-                    default:
-                        log.error('Unhandled commit event: %j', event);
-                        break;
-                }
-
+                onCommitEvent(event);
             }
         });
 
+        function onCommitEvent(event) {
+            switch (event.type) {
+                case 'end':
+                    if (event.error) {
+                        // Will be passed to callback `cb`.
+                        commitError = new Error(event.error);
+                    }
+                    break;
+                case 'message':
+                case 'stdout':
+                    log.info('Commit event message: %s', event.message);
+                    break;
+                case 'image_create':
+                    createImage(event.payload, { rat: rat, req: req },
+                        function _imageCreateCb(err, result)
+                    {
+                        sendEventResponse(event, err, result);
+                    });
+                    break;
+                case 'commit_finished':
+                    finalImageDigest = event.finalImageDigest;
+                    tagImage({
+                        config_digest: finalImageDigest,
+                        name: opts.tag,
+                        req: req
+                    }, function _tagImageCb(err) {
+                        if (!err) {
+                            commitFinishedSuccessfully = true;
+                        }
+                        sendEventResponse(event, err);
+                    });
+                    break;
+                default:
+                    log.error('Unhandled commit event: %j', event);
+                    break;
+            }
+        }
+
         commitEventStream.on('close', function _eventStreamCloseCb() {
             log.debug('commit: commitEventStream.close - closing socket');
         });
@@ -1213,7 +1056,7 @@ function commitImage(req, opts, callback) {
             callback(new errors.DockerError('Unexpected commit error'));
             return;
         }
-        callback(null, finalImageId);
+        callback(null, finalImageDigest);
     }
 
 
diff --git a/lib/backends/sdc/containers.js b/lib/backends/sdc/containers.js
index b0ac7b5..6aa902c 100644
--- a/lib/backends/sdc/containers.js
+++ b/lib/backends/sdc/containers.js
@@ -2295,10 +2295,8 @@ function buildVmPayload(opts, container, callback) {
                 payload.kernel_version = VM_DEFAULT_KERNEL_VERSION;
             }
 
-            if (imgConfig.Image) {
-                payload.internal_metadata['docker:imageid'] =
-                    opts.image.docker_id;
-            }
+            payload.internal_metadata['docker:imageid'] =
+                (opts.image.config_digest || opts.image.docker_id);
             if (container.Image) {
                 // the original name the user passed
                 payload.internal_metadata['docker:imagename'] = container.Image;
diff --git a/lib/backends/sdc/images.js b/lib/backends/sdc/images.js
index 81eb54e..9bc1cc2 100644
--- a/lib/backends/sdc/images.js
+++ b/lib/backends/sdc/images.js
@@ -37,6 +37,7 @@
  */
 
 var assert = require('assert-plus');
+var crypto = require('crypto');
 var format = require('util').format;
 var fs = require('fs');
 var imgmanifest = require('imgmanifest');
@@ -50,6 +51,8 @@ var vasync = require('vasync');
 var common = require('../../common');
 var Image = require('../../models/image');
 var ImageTag = require('../../models/image-tag');
+var ImageV2 = require('../../models/image-v2');
+var ImageTagV2 = require('../../models/image-tag-v2');
 var errors = require('../../../lib/errors');
 var utils = require('./utils');
 
@@ -71,6 +74,38 @@ function getVmapiClient(config) {
 }
 
 
+/**
+ * Return the array of image tags for the given image.
+ */
+function tagsForImage(img, opts, callback) {
+    assert.object(img, 'img');
+    assert.object(opts, 'opts');
+    assert.object(opts.account, 'opts.account');
+    assert.object(opts.app, 'opts.app');
+    assert.object(opts.log, 'opts.log');
+    assert.optionalString(opts.index_name, 'opts.index_name');
+    assert.func(callback, 'callback');
+
+    var filter;
+
+    if (isV1Image(img)) {
+        filter = [
+            {owner_uuid: opts.account.uuid, docker_id: img.docker_id}
+        ];
+        if (opts.index_name) {
+            filter[0].index_name = opts.index_name;
+        }
+        ImageTag.list(opts.app, opts.log, filter, callback);
+        return;
+    }
+
+    filter = [
+        {owner_uuid: opts.account.uuid, config_digest: img.config_digest}
+    ];
+    ImageTagV2.list(opts.app, opts.log, filter, callback);
+}
+
+
 /**
  * Convert a docker image json layer (as given from docker hub) into a
  * sdc-docker Image model structure.
@@ -80,40 +115,27 @@ function getVmapiClient(config) {
  * @returns {Object} Image model object.
  */
 function dockerImageJsonToModel(imageJson, opts) {
+    assert.object(imageJson, 'imageJson');
     assert.object(opts, 'opts');
+    assert.string(opts.config_digest, 'opts.config_digest');
+    assert.optionalBool(opts.head, 'opts.head');
     assert.string(opts.image_uuid, 'opts.image_uuid');
-    assert.string(opts.index_name, 'opts.index_name');
+    assert.string(opts.manifest_str, 'opts.manifest_str');
+    assert.string(opts.manifest_digest, 'opts.manifest_digest');
     assert.optionalString(opts.owner_uuid, 'opts.owner_uuid');
+    assert.number(opts.size, 'opts.size');
 
     var modelObj = {
-        architecture: imageJson.architecture || 'amd64',
-        author: imageJson.author,
-        comment: imageJson.comment || '',
-        created: new Date(imageJson.created).getTime(),
-        docker_id: imageJson.id,
+        config_digest: opts.config_digest,
         head: (opts.head || false),
-        heads: (opts.heads || []),
+        image: imageJson,
         image_uuid: opts.image_uuid,
-        index_name: opts.index_name,
+        manifest_digest: opts.manifest_digest,
+        manifest_str: opts.manifest_str,
         owner_uuid: opts.owner_uuid,
-        private: true,
-        size: (opts.size || 0),
-        virtual_size: (opts.virtual_size || 0)
+        size: (opts.size || 0)
     };
 
-    if (imageJson.comment) {
-        modelObj.comment = imageJson.comment;
-    }
-    if (imageJson.container_config) {
-        modelObj.container_config = imageJson.container_config;
-    }
-    if (imageJson.config) {
-        modelObj.config = imageJson.config;
-    }
-    if (imageJson.parent) {
-        modelObj.parent = imageJson.parent;
-    }
-
     return modelObj;
 }
 
@@ -121,12 +143,6 @@ function dockerImageJsonToModel(imageJson, opts) {
 /**
  * Get all the images available to the given account.
  *
- * Dev note on `IndexName` field:
- * Todd added `IndexName` (for docker build functionality). This field doesn't
- * exist in Docker-land representation of an image object. However, AFAICT the
- * way `listImages` is currently used the `IndexName` field doesn't get exposed.
- * IOW, no harm, no foul.
- *
  * @param {Object} opts
  * @param {String} opts.account The account to which to limit access.
  * @param {Object} opts.all Include intermediate docker layer images.
@@ -143,6 +159,7 @@ function listImages(opts, callback) {
     assert.optionalBool(opts.all, 'opts.all');
     assert.number(opts.clientApiVersion, 'opts.clientApiVersion');
     assert.optionalString(opts.filters, 'opts.filters');
+    assert.optionalBool(opts.skipV1Images, 'opts.skipV1Images');
     assert.optionalBool(opts.skip_smartos, 'opts.skip_smartos');
     assert.string(opts.req_id, 'opts.req_id');
 
@@ -160,7 +177,10 @@ function listImages(opts, callback) {
     if (!opts.skip_smartos) {
         funcs.push(listSmartOSImages);
     }
-    funcs.push(listDockerImages);
+    funcs.push(listDockerImagesV2);
+    if (!opts.skipV1Images) {
+        funcs.push(listDockerImagesV1);
+    }
 
     vasync.parallel({funcs: funcs}, function (err) {
         if (err) {
@@ -257,7 +277,102 @@ function listImages(opts, callback) {
         return isMatch;
     }
 
-    function listDockerImages(next) {
+    function listDockerImagesV2(next) {
+        var params = { owner_uuid: opts.account.uuid };
+        var results = [];
+
+        if (!opts.all) {
+            params.head = true;
+        }
+
+        ImageV2.list(app, log, params, function (err, imgs) {
+            if (err) {
+                next(err);
+                return;
+            }
+
+            log.debug('listDockerImagesV2:: found %d imgs', imgs.length);
+
+            // Filter images when requested by the client.
+            if (!common.objEmpty(imageFilters)) {
+                log.debug({ 'imageFilters': imageFilters}, 'filtering images');
+                try {
+                    imgs = imgs.filter(imageFilter);
+                } catch (e) {
+                    next(e);
+                    return;
+                }
+            }
+
+            vasync.forEachParallel({
+                func: getTagsV2,
+                inputs: imgs
+            }, function (getErr) {
+                if (getErr) {
+                    next(getErr);
+                    return;
+                }
+
+                log.trace({imgs: results}, 'listImages: listDockerImagesV2');
+                dockerImages = dockerImages.concat(results);
+                next();
+            });
+        });
+
+        function _addImageV2(img, repoTags, repoDigests) {
+            assert.optionalArrayOfString(repoTags, 'repoTags');
+
+            if (!repoTags || repoTags.length === 0) {
+                repoTags = ['<none>:<none>'];
+            }
+            if (!repoDigests || repoDigests.length === 0) {
+                repoDigests = ['<none>@<none>'];
+            }
+            var dockerImage = {
+                Created: img.created,
+                Id: img.config_digest,
+                Labels: img.config.Labels || null,
+                ParentId: img.parent || '',
+                RepoDigests: repoDigests,
+                RepoTags: repoTags,
+                Size: img.size,
+                VirtualSize: img.size
+            };
+
+            results.push(dockerImage);
+        }
+
+        function getTagsV2(img, cb) {
+            // Intermediate layers don't have tags.
+            if (!img.head) {
+                _addImageV2(img);
+                cb();
+                return;
+            }
+
+            tagsForImage(img, {app: app, log: log, account: opts.account},
+                    function (err, imgTags) {
+                if (err) {
+                    cb(err);
+                    return;
+                }
+                if (imgTags && imgTags.length > 0) {
+                    var repoTags = imgTags.map(function (it) {
+                        return it.repo + ':' + it.tag;
+                    });
+                    var repoDigests = imgTags.map(function (it) {
+                        return it.repo + '@' + it.config_digest;
+                    });
+                    _addImageV2(img, repoTags, repoDigests);
+                } else {
+                    _addImageV2(img);
+                }
+                cb();
+            });
+        }
+    }
+
+    function listDockerImagesV1(next) {
         var params = { owner_uuid: opts.account.uuid };
         var results = [];
 
@@ -291,7 +406,7 @@ function listImages(opts, callback) {
                     return;
                 }
 
-                log.trace({imgs: results}, 'listImages: listDockerImages');
+                log.trace({imgs: results}, 'listImages: listDockerImagesV1');
                 dockerImages = dockerImages.concat(results);
                 next();
             });
@@ -308,13 +423,11 @@ function listImages(opts, callback) {
                 RepoTags: (repoTags && repoTags.length
                     ? repoTags : ['<none>:<none>']),
                 Id: img.docker_id,
-                IndexName: img.index_name,
                 Created: Math.floor((new Date(img.created))
                             .getTime() / 1000),
                 Cmd: imgConfig.Cmd,
                 Env: imgConfig.Env,
                 Entrypoint: imgConfig.Entrypoint,
-                ExposedPorts: imgConfig.ExposedPorts,
                 ParentId: img.parent || '',
                 Size: img.size,
                 Tty: imgConfig.Tty,
@@ -336,18 +449,14 @@ function listImages(opts, callback) {
                 return;
             }
 
-            var getParams = {
-                owner_uuid: img.owner_uuid,
-                index_name: img.index_name,
-                docker_id: img.docker_id
-            };
-            ImageTag.list(app, log, getParams, function (err, imgTag) {
+            tagsForImage(img, {app: app, log: log, account: opts.account},
+                    function (err, imgTags) {
                 if (err) {
                     cb(err);
                     return;
                 }
-                if (imgTag) {
-                    var repoTags = imgTag.map(function (it) {
+                if (imgTags) {
+                    var repoTags = imgTags.map(function (it) {
                         return it.repo + ':' + it.tag;
                     });
                     pushImage(serialized, repoTags);
@@ -372,7 +481,7 @@ function listImages(opts, callback) {
  * @param {Object} opts.app App instance
  * @param callback {Function} `function (err, img)`
  */
-function imgFromImgInfo(opts, callback) {
+function imgFromImgInfoV1(opts, callback) {
     assert.object(opts, 'opts');
     assert.object(opts.account, 'opts.account');
     assert.string(opts.indexName, 'opts.indexName');
@@ -399,109 +508,190 @@ function imgFromImgInfo(opts, callback) {
 }
 
 
-/**
- * Find the img (an 'Image' model object instance) for the named Docker
- * image (and for the given account).
- *
- * Given a name, e.g. 'cafe', that could be either a name or an id prefix,
- * Docker semantics say that *name* wins. That means we need to lookup by
- * name first, then fallback to imgId prefix.
- *
- * Ambiguity notes:
- * 1. One form of ambiguity is if an imgId prefix matches more than one imgId.
- *    For this case, this function returns no imgTag.
- * 2. There is another form. Because SDC's design of keeping Docker images from
- *    different registry hosts separate, even if they have the same imgId, we
- *    have a potential confusion for users and an *inherent ambiguity in
- *    referring to images by imgId*. E.g., the same busybox image pulled from
- *    docker.io and from quay.io will have the same imgId, but different
- *    imgUuid in SDC. For now, if such an ambiguity comes up we'll return
- *    an error here: `AmbiguousDockerImageIdError`.
- *
- * Theoretically, it is *sdc-docker's* data in moray that determines if a
- * particular image exists. However, the images are stored in IMGAPI and
- * can (whether by accident or not) be removed from IMGAPI without sdc-docker
- * knowing it. If the image is found in sdc-docker's database, but is not
- * in IMGAPI, then the sdc-docker DB entry will be removed to lazily clean up.
- *
- * Also, optionally (if `includeSmartos=true`), if a UUID for a SmartOS image
- * in the DC's IMGAPI is given, this returns a fake 'Image' model object
- * representing that IMGAPI image.
+/*
+ * Find the ImageV2 instance by name, config digest or config digest prefix.
  *
- * @param {Object} opts
- * @param {Object} opts.app App instance
- * @param {Object} opts.log Bunyan log instance
- * @param {String} opts.name An imgId, imgId prefix or image
- *      [REGHOST]NAME[:TAG] name.
- * @param {Object} opts.account
- * @param {Boolean} opts.index_name Optional. Used to avoid duplicate images.
- * @param {Boolean} opts.includeSmartos Optional. Default false. Set to true
- *      to include (faux) results
- * @param callback {Function} `function (err, img, imgTag)`
- *      `img` is an `Image` instance or will be undefined if no matching
- *      image or no *unambiguous* match was found.
- *      `imgTag` will be the `ImageTag` instance for `name` iff it was found
- *      by name. E.g. if `name` is an imgId, then `imgTag` will be undefined.
+ * Note: If a digest prefix matches more than one image, no image is returned.
  */
-function imgFromName(opts, callback) {
-    assert.object(opts.app, 'opts.app');
-    assert.object(opts.log, 'opts.log');
-    assert.string(opts.name, 'opts.name');
-    assert.object(opts.account, 'opts.account');
-    assert.optionalString(opts.index_name, 'opts.index_name');
-    assert.optionalBool(opts.includeSmartos, 'opts.includeSmartos');
-    var log = opts.log;
-
-    try {
-        var rat = drc.parseRepoAndTag(opts.name);
-    } catch (e) {
-        callback(new errors.DockerError(e, e.message));
-        return;
-    }
-    var name = rat.localName;
-    var tag = rat.tag;
-
-    var imgUuid;
+function _imgFromNameOrConfigDigest(opts, callback) {
     var imgTag;
     var img;
     var imgIsGone = false;
+    var log = opts.log;
+    var name = opts.rat.localName;
+    var nameIsDigest;
+    var tag = opts.rat.tag;
+
+    // When a digest is given by itself, like:
+    //  'docker inspect sha256:1234...'
+    // the parsed rat will be incorrect, as the rat.locaName will be 'sha256'.
+    // This problem is corrected here, a digest lookup can be made.
+    if (name === 'sha256' && tag && tag.match(/^[0-9a-f]+$/)) {
+        name = format('%s:%s', name, tag);
+        tag = '';
+    }
+
+    nameIsDigest = (name.indexOf(':') >= 0);
+
+    log.debug({localName: name, tag: tag, nameIsDigest: nameIsDigest},
+        '_imgFromNameV2');
 
     var imgapiOpts = common.objCopy(opts.app.config.imgapi);
     imgapiOpts.headers = { 'x-request-id': log.fields.req_id };
     var imgapi = new IMGAPI(imgapiOpts);
 
     vasync.pipeline({funcs: [
-        function findUuidInImgapi(_, next) {
-            if (!opts.includeSmartos || !common.isUUID(name)) {
+        function findByName(_, next) {
+            // Avoid doing the tag lookup when name is a digest, e.g.
+            // 'sha256:123', as repo names cannot have a ':' in them.
+            if (nameIsDigest) {
                 next();
                 return;
             }
 
-            var acct = opts.account.uuid;
-            var getOpts = {
-                os: 'smartos',
-                state: 'active'
-            };
-            imgapi.getImage(name, acct, getOpts, function (err, imgapiImg) {
+            var filter = [
+                {repo: name, owner_uuid: opts.account.uuid, tag: tag}
+            ];
+            ImageTagV2.list(opts.app, log, filter, function (err, imgTags) {
+                if (err) {
+                    next(err);
+                } else if (imgTags.length === 0) {
+                    next();
+                } else {
+                    assert(imgTags.length === 1, 'Must be only one image tag');
+                    imgTag = imgTags[0];
+                    log.debug({imgTag: imgTag},
+                        '_imgFromNameV2: found matching imgTag');
+                    next();
+                }
+            });
+        },
+
+        function findImage(_, next) {
+            var filter = [];
+            if (imgTag) {
+                // We've found an imgTag, get the `ImageV2` for it.
+                filter.push({
+                    config_digest: imgTag.config_digest,
+                    owner_uuid: opts.account.uuid
+                });
+            } else if (nameIsDigest) {
+                // A digest or partial digest, search for that.
+                filter.push({
+                    config_digest: name + '*',
+                    owner_uuid: opts.account.uuid
+                });
+            } else if (/^[0-9a-f]+$/.test(name)) {
+                // Else, could possibly be a docker Id, search for that.
+                filter.push({
+                    config_digest: 'sha256:' + name + '*',
+                    owner_uuid: opts.account.uuid
+                });
+            } else {
+                next();
+                return;
+            }
+
+            ImageV2.list(opts.app, log, filter, function (err, imgs) {
+                log.debug('imgs: ', imgs);
+                if (err || imgs.length === 0) {
+                    /*jsl:pass*/
+                } else if (imgs.length === 1) {
+                    img = imgs[0];
+                    log.debug({imgName: name, img: img},
+                        '_imgFromNameV2: findImage');
+                } else {
+                    // Docker gives a 404 if multiple images are matched.
+                    next(true);  /* early abort */
+                    return;
+                }
+                next(err);
+            });
+        },
+
+        function isImageInImgapi(_, next) {
+            if (!img) {
+                return next(true); // early abort
+            }
+
+            imgapi.getImage(img.image_uuid, function (err, imgapiImg) {
                 if (err) {
                     if (err.statusCode === 404) {
+                        imgIsGone = true;
                         next();
                     } else {
                         next(err);
                     }
-                    return;
+                } else {
+                    next(true); // early abort
                 }
-                log.debug({imgName: name, imgapiImg: imgapiImg},
-                    'imgFromName: findUuidInImgapi');
-                // A faux `Image` model object for this IMGAPI image.
-                img = {
-                    image_uuid: imgapiImg.uuid,
-                    os: imgapiImg.os
-                };
-                next(true);  /* early abort */
             });
         },
 
+        /*
+         * If we get here then we found an `img`, but it isn't in IMGAPI
+         * (`imgIsGone`). We need to clear these refs from the sdc-docker DB.
+         */
+        function delImgRef(_, next) {
+            assert.ok(img);
+            assert.ok(imgIsGone);
+
+            log.debug({imgIsGone: imgIsGone, img: img},
+                'imgFromName: deleting image due to missing IMGAPI layer');
+            ImageV2.del(opts.app, log, img, next);
+        },
+
+        function delImgTagRef(_, next) {
+            assert.ok(imgIsGone);
+            if (!imgTag) {
+                return next();
+            }
+
+            log.debug({imgIsGone: imgIsGone, imgTag: imgTag},
+                'imgFromName: deleting image tag due to missing IMGAPI layer');
+            ImageTagV2.del(opts.app, log, imgTag, next);
+        }
+
+    ]}, function (err) {
+        if (err === true) { /* the signal for an early abort */
+            err = null;
+        }
+        if (err) {
+            callback(err);
+        } else if (imgIsGone) {
+            callback(null);
+        } else {
+            callback(null, img, imgTag);
+        }
+    });
+}
+
+/**
+ * Ambiguity notes:
+ *
+ * 1. One form of ambiguity is if an imgId prefix matches more than one imgId.
+ *    For this case, this function returns no img - i.e. a 404.
+ * 2. There is another form. Because SDC's docker_images(_v1) design of keeping
+ *    Docker images from different registry hosts separate, even if they have
+ *    the same imgId, we have a potential confusion for users and an *inherent
+ *    ambiguity in referring to images by imgId*. E.g., the same busybox image
+ *    pulled from docker.io and from quay.io will have the same imgId, but
+ *    different imgUuid in SDC. For now, if such an ambiguity comes up we'll
+ *    return an error here: `AmbiguousDockerImageIdError`.
+ */
+function _imgFromNameV1(opts, callback) {
+    var imgTag;
+    var img;
+    var imgIsGone = false;
+    var log = opts.log;
+    var name = opts.rat.localName;
+    var tag = opts.rat.tag;
+
+    var imgapiOpts = common.objCopy(opts.app.config.imgapi);
+    imgapiOpts.headers = { 'x-request-id': log.fields.req_id };
+    var imgapi = new IMGAPI(imgapiOpts);
+
+    vasync.pipeline({funcs: [
         function findByName(_, next) {
             var filter = [
                 {repo: name, owner_uuid: opts.account.uuid, tag: tag}
@@ -516,13 +706,8 @@ function imgFromName(opts, callback) {
                     next();
                 } else {
                     imgTag = imgTags[0];
-                    // We can calculate the imgUuid from the ImageTag fields.
-                    imgUuid = imgmanifest.imgUuidFromDockerInfo({
-                        id: imgTag.docker_id,
-                        indexName: drc.parseRepo(imgTag.repo).index.name
-                    });
-                    log.debug({imgName: name, imgTag: imgTag, imgUuid: imgUuid},
-                        'imgFromName: findByName');
+                    log.debug({imgName: name, imgTag: imgTag},
+                        '_imgFromNameV1: findByName');
                     next();
                 }
             });
@@ -530,10 +715,10 @@ function imgFromName(opts, callback) {
 
         function findImage(_, next) {
             var filter = [];
-            if (imgUuid) {
+            if (imgTag) {
                 // We've found an imgTag, get the `Image` for it.
-                filter.push(
-                    {image_uuid: imgUuid, owner_uuid: opts.account.uuid});
+                filter.push({docker_id: imgTag.docker_id,
+                    owner_uuid: opts.account.uuid});
             } else if (/^[0-9a-f]+$/.test(name) && name.length <= 64) {
                 // Else, could possibly be an imgId, search for that.
                 if (name.length === 64) {
@@ -557,7 +742,7 @@ function imgFromName(opts, callback) {
                 } else if (imgs.length === 1) {
                     img = imgs[0];
                     log.debug({imgName: name, img: img},
-                        'imgFromName: findImage');
+                        '_imgFromNameV1: findImage');
                 } else {
                     var imgIds = {};
                     var indexNames = [];
@@ -608,7 +793,7 @@ function imgFromName(opts, callback) {
             assert.ok(imgIsGone);
 
             log.debug({imgIsGone: imgIsGone, img: img},
-                'imgFromName: delImgRef');
+                '_imgFromNameV1: deleting image due to missing IMGAPI layer');
             Image.del(opts.app, log, img, next);
         },
         function delImgTagRef(_, next) {
@@ -618,7 +803,7 @@ function imgFromName(opts, callback) {
             }
 
             log.debug({imgIsGone: imgIsGone, imgTag: imgTag},
-                'imgFromName: delImgTagRef');
+                '_imgFromNameV1: delImgTagRef');
             ImageTag.del(opts.app, log, imgTag, next);
         }
 
@@ -636,30 +821,182 @@ function imgFromName(opts, callback) {
     });
 }
 
-
 /**
- * Return the docker `Image` model for the given IMGAPI uuid.
+ * Find the img (an 'Image' or 'ImageV2' model object instance) for the named
+ * Docker image (and for the given account).
+ *
+ * Given a name, e.g. 'cafe', that could be either a name or an id prefix,
+ * Docker semantics say that *name* wins. That means we need to lookup by
+ * name first, then fallback to imgId prefix.
+ *
+ * Theoretically, it is *sdc-docker's* data in moray that determines if a
+ * particular image exists. However, the images (layers) are stored in IMGAPI
+ * and can (whether by accident or not) be removed from IMGAPI without
+ * sdc-docker knowing it. If the image is found in sdc-docker's database, but
+ * is not in IMGAPI, then the sdc-docker DB entry will be removed to lazily
+ * clean up.
+ *
+ * Also, optionally (if `includeSmartos=true`), if a UUID for a SmartOS image
+ * in the DC's IMGAPI is given, this returns a fake 'Image' model object
+ * representing that IMGAPI image.
+ *
+ * @param {Object} opts
+ * @param {Object} opts.app App instance
+ * @param {Object} opts.log Bunyan log instance
+ * @param {String} opts.name An imgId, imgId prefix or image
+ *      [REGHOST]NAME[:TAG] name.
+ * @param {Object} opts.account
+ * @param {Boolean} opts.index_name Optional. Used to avoid duplicate images.
+ * @param {Boolean} opts.includeSmartos Optional. Default false. Set to true
+ *      to include (faux) results
+ * @param callback {Function} `function (err, img, imgTag)`
+ *      `img` is an `Image` or `ImageV2` instance or will be undefined if no
+ *      matching image or no *unambiguous* match was found.
+ *      `imgTag` will be the `ImageTag` instance for `name` iff it was found
+ *      by name. E.g. if `name` is an imgId, then `imgTag` will be undefined.
+ */
+function imgFromName(opts, callback) {
+    assert.object(opts.app, 'opts.app');
+    assert.object(opts.log, 'opts.log');
+    assert.string(opts.name, 'opts.name');
+    assert.object(opts.account, 'opts.account');
+    assert.optionalString(opts.index_name, 'opts.index_name');
+    assert.optionalBool(opts.includeSmartos, 'opts.includeSmartos');
+    var log = opts.log;
+
+    try {
+        var rat = drc.parseRepoAndTag(opts.name);
+    } catch (e) {
+        callback(new errors.DockerError(e, e.message));
+        return;
+    }
+
+    var imgTag;
+    var img;
+    var name = rat.localName;
+
+    var imgapiOpts = common.objCopy(opts.app.config.imgapi);
+    imgapiOpts.headers = { 'x-request-id': log.fields.req_id };
+    var imgapi = new IMGAPI(imgapiOpts);
+
+    vasync.pipeline({funcs: [
+        function findUuidInImgapi(_, next) {
+            if (!opts.includeSmartos || !common.isUUID(name)) {
+                next();
+                return;
+            }
+
+            var acct = opts.account.uuid;
+            var getOpts = {
+                os: 'smartos',
+                state: 'active'
+            };
+            imgapi.getImage(name, acct, getOpts, function (err, imgapiImg) {
+                if (err) {
+                    if (err.statusCode === 404) {
+                        next();
+                    } else {
+                        next(err);
+                    }
+                    return;
+                }
+                log.debug({imgName: name, imgapiImg: imgapiImg},
+                    'imgFromName: findUuidInImgapi');
+                // A faux `Image` model object for this IMGAPI image.
+                img = {
+                    image_uuid: imgapiImg.uuid,
+                    os: imgapiImg.os
+                };
+                next(true);  /* early abort */
+            });
+        },
+
+        function findByManifestDigest(_, next) {
+            // Check if this a lookup by docker manifest digest.
+            if (!rat.digest) {
+                next();
+                return;
+            }
+            var dockerImageOpts = {
+                account: opts.account,
+                app: opts.app,
+                manifestDigest: rat.digest,
+                log: log
+            };
+            imgFromManifestDigest(dockerImageOpts,
+                function _imgFromDigestCb(err, _img) {
+                    if (_img && !err) {
+                        img = _img;
+                        next(true);  /* early abort */
+                        return;
+                    }
+                    next(err);
+                }
+            );
+        },
+
+        function findByNameV2(_, next) {
+            var v2Opts = common.objCopy(opts);
+            v2Opts.rat = rat;
+            v2Opts.imgapi = imgapi;
+            _imgFromNameOrConfigDigest(v2Opts, function (err, _img, _imgTag) {
+                img = _img;
+                imgTag = _imgTag;
+                if (img && !err) {
+                    next(true);  /* early abort */
+                    return;
+                }
+                next(err);
+            });
+        },
+
+        function findByNameV1(_, next) {
+            var v1Opts = common.objCopy(opts);
+            v1Opts.rat = rat;
+            v1Opts.imgapi = imgapi;
+            _imgFromNameV1(v1Opts, function (err, _img, _imgTag) {
+                img = _img;
+                imgTag = _imgTag;
+                next(err);
+            });
+        }
+    ]}, function (err) {
+        if (err === true) { /* the signal for an early abort */
+            err = null;
+        }
+        if (err) {
+            callback(err);
+        } else {
+            callback(null, img, imgTag);
+        }
+    });
+}
+
+
+/**
+ * Return the docker `ImageV2` model for the given docker manifest digest.
  *
- * @param {String} image_uuid The IMGAPI uuid.
  * @param {Object} opts
  * @param {Object} opts.account User account object
  * @param {Object} opts.app App instance
+ * @param {String} opts.manifestDigest The docker manifest digest.
  * @param {Object} opts.log Bunyan log instance
  *
  * @param callback {Function} `function (err, image)`
- *      On success: `err` is null, `image` is an Image model object.
+ *      On success: `err` is null, `image` is an ImageV2 model object.
  *      On error: `err` is an error object.
  */
-function getDockerImageForUuid(image_uuid, opts, callback) {
-    assert.string(image_uuid, 'image_uuid');
+function imgFromManifestDigest(opts, callback) {
     assert.object(opts, 'opts');
     assert.object(opts.account, 'opts.account');
     assert.object(opts.app, 'opts.app');
+    assert.string(opts.manifestDigest, 'opts.manifestDigest');
     assert.object(opts.log, 'opts.log');
 
     var img;
     var imgapi = opts.app.imgapi;
     var log = opts.log;
+    var manifestDigest = opts.manifestDigest;
 
     vasync.pipeline({arg: {}, funcs: [
         findImage,
@@ -675,25 +1012,28 @@ function getDockerImageForUuid(image_uuid, opts, callback) {
     // Find the image in the sdc-docker database.
     function findImage(_, next) {
         var filter = [
-            {image_uuid: image_uuid, owner_uuid: opts.account.uuid}
+            {manifest_digest: manifestDigest, owner_uuid: opts.account.uuid}
         ];
-        Image.list(opts.app, log, filter, function (err, imgs) {
+        ImageV2.list(opts.app, log, filter, function (err, imgs) {
             if (err) {
                 next(err);
                 return;
             }
             if (imgs.length === 0) {
                 next(new errors.ResourceNotFoundError(
-                    'No image with image_uuid: ' + image_uuid));
+                    'No image with manifest digest: ' + manifestDigest));
                 return;
             }
             if (imgs.length > 1) {
-                next(new errors.DockerError('Error - multiple images found '
-                    + 'with the same image_uuid: ' + image_uuid));
+                log.warn({imgs: imgs},
+                    'Multiple images found with same manifestDigest');
+                next(new errors.DockerError(
+                    'Error - multiple images with the same manifest digest: '
+                    + manifestDigest));
                 return;
             }
             img = imgs[0];
-            log.debug({img: img}, 'getDockerImageForUuid: findImage');
+            log.debug({img: img}, 'imgFromManifestDigest: found img');
             next(null, img);
         });
     }
@@ -701,11 +1041,11 @@ function getDockerImageForUuid(image_uuid, opts, callback) {
     // Check that the image is also in imgapi.
     function checkImageInImgapi(_, next) {
         assert.object(img, 'img');
-        imgapi.getImage(image_uuid, function (err, imgapiImg) {
+        imgapi.getImage(img.image_uuid, function (err) {
             if (err) {
                 if (err.statusCode === 404) {
                     next(new errors.ResourceNotFoundError(
-                        'No imgapi image with image_uuid: ' + image_uuid));
+                        'No imgapi image with image_uuid: ' + img.image_uuid));
                     return;
                 }
                 next(err);
@@ -718,9 +1058,80 @@ function getDockerImageForUuid(image_uuid, opts, callback) {
 
 
 /**
- * Return the history of the given image. This is an ordered array of
- * `Image` model instances starting from the given image, followed by its
- * parent, and so on.
+ * Return the docker `ImageV2` model for the given docker image digest.
+ *
+ * @param {Object} opts
+ * @param {Object} opts.account User account object
+ * @param {Object} opts.app App instance
+ * @param {String} opts.config_digest The docker image config_digest.
+ * @param {Object} opts.log Bunyan log instance
+ *
+ * @param callback {Function} `function (err, image)`
+ *      On success: `err` is null, `image` is an ImageV2 model object.
+ *      On error: `err` is an error object.
+ */
+function imgFromConfigDigest(opts, callback) {
+    assert.object(opts, 'opts');
+    assert.object(opts.account, 'opts.account');
+    assert.object(opts.app, 'opts.app');
+    assert.string(opts.config_digest, 'opts.config_digest');
+    assert.object(opts.log, 'opts.log');
+
+    var img;
+    var imgapi = opts.app.imgapi;
+    var log = opts.log;
+
+    vasync.pipeline({arg: {}, funcs: [
+        findImage,
+        checkImageInImgapi
+    ]}, function (err) {
+        if (err) {
+            callback(err);
+            return;
+        }
+        callback(null, img);
+    });
+
+    // Find the image in the sdc-docker database.
+    function findImage(_, next) {
+        var params = {
+            config_digest: opts.config_digest,
+            owner_uuid: opts.account.uuid
+        };
+        ImageV2.get(opts.app, log, params, function (err, img_) {
+            if (err) {
+                next(err);
+                return;
+            }
+            img = img_;
+            log.debug({img: img}, 'imgFromConfigDigest: found img');
+            next(null, img);
+        });
+    }
+
+    // Check that the image is also in imgapi.
+    function checkImageInImgapi(_, next) {
+        assert.object(img, 'img');
+        imgapi.getImage(img.image_uuid, function (err) {
+            if (err) {
+                if (err.statusCode === 404) {
+                    next(new errors.ResourceNotFoundError(
+                        'No imgapi image with image_uuid: ' + img.image_uuid));
+                    return;
+                }
+                next(err);
+                return;
+            }
+            next();
+        });
+    }
+}
+
+
+/**
+ * Return the ancestry of the given image. This is an ordered array of
+ * `Image|ImageV2` model instances starting from the given image, followed
+ * by its parent, and so on.
  *
  * @param {Object} opts
  * @param {Object} opts.app App instance
@@ -728,47 +1139,217 @@ function getDockerImageForUuid(image_uuid, opts, callback) {
  * @param {String} opts.img The `Image` instance for which to get the history,
  *      e.g. from `imgFromName`.
  * @param {Object} opts.account
- * @param callback {Function} `function (err, history)`
- *      On success: err is null, `history` is an array of image objects (as
- *      from `imgFromImgInfo`). On error: `err` is an error object and
- *      history is *the history determined up to the failure*.
+ * @param callback {Function} `function (err, ancestry, isPartialAncestry)`
+ *      On success: err is null, `history` is an array of image objects.
+ *      Note that it's possible that an image parent lookup may fail (we don't
+ *      have that parent image) at which point the image ancestry lookup will
+ *      stop and return the images is has up to that point, and
+ *      isPartialAncestry will be set to true.
  */
-function getImageHistory(opts, callback) {
+function getImageAncestry(opts, callback) {
     assert.object(opts, 'opts');
     assert.object(opts.app, 'opts.app');
     assert.object(opts.log, 'opts.log');
     assert.object(opts.img, 'opts.img');
     assert.object(opts.account, 'opts.account');
 
-    var history = [];
+    var ancestry = [];
+
+    function checkAndCallback(err, img) {
+        if (err) {
+            // It's okay if the parent does not exist, for these cases:
+            //  1. DOCKER-709: this may be an accidentally deleted, once
+            //     head image.
+            //  2. A docker v2.1 image, as the parent references may not exist,
+            //     since they could point to a synthetic layer id, which won't
+            //     exist for our docker_images_v2 (docker v2.2) image format.
+            if (err.restCode === 'ResourceNotFound' && (isV1Image(img)
+                || isV21Image(img))) {
+                assert.ok(ancestry.length >= 1, 'ancestry.length >= 1');
+                callback(null, ancestry, true);
+                return;
+            }
+            callback(err);
+            return;
+        }
+        callback(null, ancestry, false);
+    }
 
     function addAndGetNextItem(img) {
-        history.push(img);
+        ancestry.push(img);
 
         if (!img.parent) {
-            callback(null, history);
+            checkAndCallback(null);
             return;
         }
 
-        imgFromImgInfo({
-            app: opts.app,
-            log: opts.log,
-            account: opts.account,
-            indexName: img.index_name,
-            imgId: img.parent
-        }, function (err, parentImg) {
+        if (isV1Image(img)) {
+            imgFromImgInfoV1({
+                app: opts.app,
+                log: opts.log,
+                account: opts.account,
+                indexName: img.index_name,
+                imgId: img.parent
+            }, function (err, parentImg) {
+                if (err) {
+                    checkAndCallback(err, img);
+                } else {
+                    addAndGetNextItem(parentImg);
+                }
+            });
+            return;
+        }
+
+        var params = {
+            config_digest: img.parent,
+            owner_uuid: opts.account.uuid
+        };
+        ImageV2.get(opts.app, opts.log, params, function (err, parentImg) {
             if (err) {
-                callback(err, history);
+                checkAndCallback(err, img);
             } else {
                 addAndGetNextItem(parentImg);
             }
         });
+
     }
 
     addAndGetNextItem(opts.img);
 }
 
 
+/**
+ * Return the docker history of the given image. This is an ordered array of
+ * changes made to the image, with the first change being at the end of the
+ * array. Each history entry is an object containing these fields:
+ *   {
+ *       Id: <string>
+ *       Created: <timestamp>,
+ *       CreatedBy: <author string>,
+ *       Size: <number>
+ *   }
+ *
+ * @param {Object} opts
+ * @param {Object} opts.app App instance
+ * @param {Object} opts.log Bunyan log instance
+ * @param {String} opts.img The `Image` instance for which to get the history,
+ *      e.g. from `imgFromName`.
+ * @param {Object} opts.account
+ * @param callback {Function} `function (err, history)`
+ *      On success: err is null, `history` is an array of image objects (as
+ *      from `imgFromImgInfo`). On error: `err` is an error object and
+ *      history is *the history determined up to the failure*.
+ */
+function getImageHistory(opts, callback) {
+    assert.object(opts, 'opts');
+    assert.object(opts.account, 'opts.account');
+    assert.object(opts.app, 'opts.app');
+    assert.object(opts.img, 'opts.img');
+    assert.object(opts.log, 'opts.log');
+
+    var history = [];
+    var log = opts.log;
+
+    getImageAncestry(opts, function (err, ancestry) {
+        if (err) {
+            callback(err);
+            return;
+        }
+
+        // Get tags for the found images.
+        vasync.forEachPipeline({
+            inputs: ancestry,
+            func: function lookupAncestorTags(img, next) {
+                var createdBy = '';
+                if (img.container_config && img.container_config.Cmd) {
+                    createdBy = img.container_config.Cmd.join(' ');
+                }
+                var size = img.size;
+
+                // If this is an empty layer in a v2 image, then it has no size.
+                if (!isV1Image(img) && img.history
+                    && img.history[img.history.length - 1].empty_layer) {
+                    size = 0;
+                }
+
+                var entry = {
+                    Id: img.config_digest || img.docker_id,
+                    Created: img.created,
+                    CreatedBy: createdBy,
+                    Size: size
+                };
+                history.push(entry);
+                tagsForImage(img, opts, function (tagErr, imgTags) {
+                    if (imgTags) {
+                        entry.Tags = imgTags.map(function _imgTagsMap(it) {
+                            return it.repo + ':' + it.tag;
+                        });
+                    }
+                    next();
+                });
+            }
+        }, function (pipeErr) {
+            if (pipeErr) {
+                callback(pipeErr);
+                return;
+            }
+
+            if (isV1Image(opts.img)) {
+                callback(null, history);
+                return;
+            }
+
+            // To add size to the history listing, we use the size of the
+            // IMGAPI layer, which is usually a compressed size, whilst
+            // docker will use the size of the uncompressed layer.
+            var manifest;
+            try {
+                manifest = JSON.parse(opts.img.manifest_str);
+            } catch (e) {
+                log.error({img: opts.img},
+                    'Unable to parse image manifest_str');
+                callback(new errors.DockerError(e,
+                    format('Unable to parse image manifest_str for image %s',
+                    opts.img.config_digest)));
+                return;
+            }
+            var layerIdx = manifest.layers.length - 1;
+
+            // The V2 image has the full history on the ImageV2 instance, so use
+            // that history info to fill in any blanks (synthetic image layers).
+            var imgHist = opts.img.history;
+
+            if (imgHist.length > history.length) {
+                imgHist.slice(0, -(history.length)).reverse().map(function (h) {
+                    var size = 0;
+
+                    if (!h.empty_layer) {
+                        assert.ok(layerIdx >= 0, 'layerIdx >= 0');
+                        size = manifest.layers[layerIdx].size;
+                        layerIdx -= 1;
+                    }
+                    history.push({
+                        Id: '<missing>',
+                        Comment: h.comment || '',
+                        // Created needs to be epoch time in seconds, currenty:
+                        //   "2016-10-07T21:03:58.16783626Z"
+                        Created: Math.floor(
+                            (new Date(h.created)).getTime() / 1000),
+                        CreatedBy: h.created_by,
+                        Size: size,
+                        Tags: null
+                    });
+                });
+            }
+
+            assert.equal(history.length, imgHist.length,
+                'History length should be equal');
+            callback(null, history);
+        });
+    });
+}
+
+
 /**
  * Find the special scratch docker image and callback with the image details.
  *
@@ -788,26 +1369,34 @@ function getScratchImage(req, callback) {
     var log = req.log;
     var imageJsonPath = path.normalize(
         __dirname + '/../../../etc/scratch_image.json');
+    var imageManifestPath = path.normalize(
+        __dirname + '/../../../etc/scratch_image.manifest');
     var imageTarPath = path.normalize(
         __dirname + '/../../../etc/scratch_image.tar');
-    var imageJson = JSON.parse(fs.readFileSync(imageJsonPath, 'utf8'));
+    var imageStr = fs.readFileSync(imageJsonPath, 'utf8');
+    var imageJson = JSON.parse(imageStr);
+    var manifestStr = fs.readFileSync(imageManifestPath, 'utf8');
+    var manifest = JSON.parse(manifestStr);
     var req_id = req.getId();
 
     var rat = {
-        localName: '',
-        index: { name: 'docker.io' }
+        localName: 'triton/scratch'
     };
 
     // Determine if the scratch image has been imported into IMGAPI.
-    var imageUuid = imgmanifest.imgUuidFromDockerInfo({
-        id: imageJson.id,
-        indexName: rat.index.name
+    var size = 0;
+    var layerDigests = manifest.layers.map(function (layer) {
+        size += layer.size;
+        return layer.digest;
     });
+    var imageUuid = imgmanifest.imgUuidFromDockerDigests(layerDigests);
+    log.debug({uuid: imageUuid}, 'looking for existing scratch image');
 
     vasync.pipeline({arg: {}, funcs: [
         imgapiFindScratchImage,
         imgapiCreateScratchImage,
         imgapiImportScratchImage,
+        imgapiAddFileDigests,
         imgapiActivateScratchImage
     ]}, function (err) {
         if (err === true) { /* the signal for an early abort */
@@ -838,11 +1427,12 @@ function getScratchImage(req, callback) {
 
     function imgapiCreateScratchImage(ctx, next) {
         var opts = {
+            layerDigests: layerDigests,
             rat: rat,
             req: req
         };
         log.debug('getScratchImage: creating new scratch image in IMGAPI');
-        createImgapiDockerImage(imageJson, opts, function (err, imgapiImg) {
+        createImgapiDockerImage(imageJson, opts, function (err) {
             next(err);
         });
     }
@@ -855,7 +1445,21 @@ function getScratchImage(req, callback) {
             uuid: imageUuid
         };
         log.debug('getScratchImage: importing scratch image file into IMGAPI');
-        imgapi.addImageFile(opts, next);
+        imgapi.addImageFile(opts, function (err, layer) {
+            ctx.imgapiLayer = layer;
+            next(err);
+        });
+    }
+
+    function imgapiAddFileDigests(ctx, next) {
+        var updateData = {
+            files: [common.objCopy(ctx.imgapiLayer.files['0'])]
+        };
+        updateData.files[0].digest = manifest.layers[0].digest;
+        updateData.files[0].uncompressedDigest = 'sha256:'
+            + (new crypto.Hash('sha256')).digest('hex');
+        log.debug('getScratchImage: updating scratch image file in IMGAPI');
+        imgapi.updateImage(imageUuid, updateData, next);
     }
 
     function imgapiActivateScratchImage(ctx, next) {
@@ -867,14 +1471,15 @@ function getScratchImage(req, callback) {
     }
 
     function imageJsonToModel() {
+        var manifestDigest = 'sha256:' + (new crypto.Hash('sha256')).
+            update(manifestStr, 'binary').digest('hex');
         var modelOpts = {
+            config_digest: manifest.config.digest,
             head: true,
-            heads: [],
             image_uuid: imageUuid,
-            index_name: rat.index.name,
-            //owner_uuid: account_uuid,
-            size: 0,
-            virtual_size: 0
+            manifest_str: manifestStr,
+            manifest_digest: manifestDigest,
+            size: size
         };
         return dockerImageJsonToModel(imageJson, modelOpts);
     }
@@ -977,56 +1582,27 @@ FATA[0000] Error: failed to remove one or more images
  * - TODO: Support 'noprune' option.
  */
 /* END JSSTYLED */
-function deleteImage(opts, callback) {
-    assert.object(opts, 'opts');
-    assert.optionalObject(opts.app, 'opts.app');
-    assert.bool(opts.force, 'opts.force');
-    assert.optionalObject(opts.log, 'opts.log');
-    assert.string(opts.name, 'opts.name');
-    assert.string(opts.req_id, 'opts.req_id');
-    assert.object(opts.account, 'opts.account');
-
+function _deleteImageV1(opts, callback) {
     var DRY_RUN = false; // for development use only
     var app = opts.app;
     var dontDeleteImages = false; // Used when we just want to untag the image.
     var log = opts.log;
-    var vmapi = getVmapiClient(this.config.vmapi);
+    var vmapi = getVmapiClient(app.config.vmapi);
+
     var changes = [];
-    log.debug({imgName: opts.name}, 'deleteImage');
 
-    vasync.pipeline({arg: {}, funcs: [
-        getImg,
+    vasync.pipeline({arg: opts, funcs: [
         ensureIsHeadImage,
         getImgTags,
         checkTagReferences,
         verifyNotInUse,
-        getImgsToDelete,
-        getDatacenterRefcount,
-        untagHeads,
-        deleteImgs
-    ]}, function (err) {
-        callback(err, changes);
-    });
-
-
-    function getImg(ctx, cb) {
-        imgFromName(opts, function (err, img, imgTag) {
-            if (err) {
-                cb(err);
-            } else if (!img) {
-                cb(new errors.ResourceNotFoundError(
-                    'No such image: ' + opts.name));
-            } else {
-                log.debug({img: img, imgTag: imgTag}, 'deleteImage: getImg');
-                ctx.img = img;
-                if (imgTag) {
-                    // Only set if `name` was not an imgId.
-                    ctx.imgTag = imgTag;
-                }
-                cb();
-            }
-        });
-    }
+        getImgsToDelete,
+        getDatacenterRefcount,
+        untagHeads,
+        deleteImgs
+    ]}, function (err) {
+        callback(err, changes);
+    });
 
     function ensureIsHeadImage(ctx, cb) {
         if (ctx.img.head !== true) {
@@ -1050,11 +1626,8 @@ function deleteImage(opts, callback) {
          * Note: if there are tags from more than one repository, then we
          * should error out (see TODO above).
          */
-        var filter = {
-            docker_id: ctx.img.docker_id,
-            owner_uuid: opts.account.uuid
-        };
-        ImageTag.list(app, log, filter, function (err, imgTags) {
+        tagsForImage(ctx.img, {app: app, log: log, account: opts.account},
+                function (err, imgTags) {
             if (err) {
                 cb(err);
                 return;
@@ -1132,7 +1705,7 @@ function deleteImage(opts, callback) {
             var messageFormat;
             // If the vm is state=incomplete, we might not have
             // internal_metadata.
-            var sId = utils.vmUuidToShortDockerId(vms[0].uuid);
+            var vmShortId = utils.vmUuidToShortDockerId(vms[0].uuid);
             if (vms[0].state === 'running') {
                 messageFormat = 'Conflict, cannot %sdelete %s because '
                     + 'the running container %s is using it, stop it and '
@@ -1142,21 +1715,23 @@ function deleteImage(opts, callback) {
                     + 'the container %s is using it, use -f to force';
             }
             var message = format(messageFormat, forceStr,
-                opts.name, sId);
+                opts.name, vmShortId);
 
             cb(new errors.DockerError(message));
         });
     }
 
     function getImgsToDelete(ctx, cb) {
-        getImageHistory({
+        getImageAncestry({
             app: app,
             log: log,
             img: ctx.img,
             account: opts.account
-        }, function (err, history) {
+        }, function (err, history, isPartialHistory) {
             if (err) {
-                if (history && Array.isArray(history) && history.length > 0) {
+                cb(new errors.DockerError(err, 'could not delete image'));
+            } else {
+                if (isPartialHistory) {
                     /*
                      * If we got a partial history, then carry on with the
                      * delete. We don't want missing ancestry (e.g. due to
@@ -1173,35 +1748,410 @@ function deleteImage(opts, callback) {
                         opts.name, err) });
                     ctx.imgsToDelete = history;
                     cb();
-                } else {
-                    cb(new errors.DockerError(err, 'could not delete image'));
                 }
-            } else {
                 ctx.imgsToDelete = history;
                 cb();
             }
         });
     }
 
-    // Get all images that are ready to be deleted from IMGAPI.
-    function getDatacenterRefcount(ctx, cb) {
-        var params = {
-            index_name: ctx.img.index_name,
-            docker_id: ctx.img.docker_id,
-            limit: 1
-        };
-        Image.datacenterRefcount(app, log, params, function (err, count) {
+    // Get all images that are ready to be deleted from IMGAPI.
+    function getDatacenterRefcount(ctx, cb) {
+        var params = {
+            index_name: ctx.img.index_name,
+            docker_id: ctx.img.docker_id,
+            limit: 1
+        };
+        Image.datacenterRefcount(app, log, params, function (err, count) {
+            if (err) {
+                cb(new errors.DockerError(err, 'could not delete image'));
+                return;
+            }
+            ctx.dcRefcount = count;
+            cb();
+        });
+    }
+
+    function untagHeads(ctx, cb) {
+        log.debug({imgTags: ctx.imgTags}, 'deleteImage: untagHeads');
+
+        vasync.forEachPipeline({
+            inputs: ctx.imgTags,
+            func: function untagOne(imgTag, nextImgTag) {
+                if (DRY_RUN) {
+                    changes.push({ Untagged: imgTag.repo + ':' + imgTag.tag });
+                    nextImgTag();
+                    return;
+                }
+                ImageTag.del(app, log, imgTag, function (err) {
+                    if (err) {
+                        nextImgTag(err);
+                    } else {
+                        changes.push({
+                            Untagged: imgTag.repo + ':' + imgTag.tag });
+                        nextImgTag();
+                    }
+                });
+            }
+        }, cb);
+    }
+
+    function deleteImgs(ctx, cb) {
+        if (dontDeleteImages) {
+            cb();
+            return;
+        }
+
+        vasync.forEachPipeline({
+            inputs: ctx.imgsToDelete,
+            func: deleteOneImg
+        }, function (err) {
+            if (err) {
+                cb(new errors.DockerError(err, 'could not delete image'));
+                return;
+            }
+            cb();
+        });
+
+        /*
+         * `true` if we hit `ImageHasDependentImagesError` error from IMGAPI,
+         * in which case we'll not bother attempting to delete further b/c
+         * they'll hit the same error.
+         */
+        var hitImageHasDependentImagesError = false;
+
+        /*
+         * We only remove the image *ref* when it is no longer being
+         * used by the account. If this is the last usage of the image
+         * across the whole DC (dcRefcount===1), then actually delete
+         * from IMGAPI.
+         */
+        function deleteOneImg(img, nextImg) {
+            log.debug({imgId: img.docker_id, indexName: img.index_name},
+                'deleteImage: deleteOneImg');
+            if (DRY_RUN) {
+                changes.push({ Deleted: img.docker_id });
+                nextImg();
+                return;
+            }
+
+            if (img.refcount > 1) {
+                log.debug({imgId: img.docker_id, indexName: img.index_name},
+                    'deleteImage: remove %s from heads', ctx.img.docker_id);
+                var update = {
+                    owner_uuid: img.owner_uuid,
+                    index_name: img.index_name,
+                    docker_id: img.docker_id,
+                    // Update:
+                    heads: img.params.heads.filter(function (id) {
+                        return id !== ctx.img.docker_id;
+                    })
+                };
+                if (img.docker_id === ctx.img.docker_id) {
+                    /*
+                     * The Docker image being removed must no longer be
+                     * marked as a 'head', else it could be "deleted again"...
+                     * during which `dcRefcount` values are not valid. This
+                     * is DOCKER-709.
+                     */
+                    update.head = false;
+                }
+                Image.update(app, log, update, nextImg);
+            } else {
+                log.debug({imgId: img.docker_id, indexName: img.index_name},
+                    'deleteImage: delete image', ctx.img.docker_id);
+                Image.del(app, log, img, function (delErr) {
+                    if (delErr) {
+                        nextImg(delErr);
+                        return;
+                    }
+
+                    changes.push({ Deleted: img.docker_id });
+
+                    var isLastRef = (ctx.dcRefcount[img.docker_id]
+                                            !== undefined);
+                    if (!isLastRef || hitImageHasDependentImagesError) {
+                        nextImg();
+                        return;
+                    }
+
+                    log.debug({imgUuid: img.image_uuid},
+                        'deleteImage: delete imgapi image (last ref)');
+                    app.imgapi.deleteImage(img.image_uuid, {
+                        headers: {'x-request-id': opts.req_id}
+                    }, function (err) {
+                        if (err && err.restCode === 'ImageHasDependentImages') {
+                            hitImageHasDependentImagesError = true;
+                            log.info({imgUuid: img.image_uuid},
+                                'deleteImage: hit ImageHasDependentImages');
+                            err = null;
+                        }
+                        nextImg(err);
+                    });
+                });
+            }
+        }
+    }
+}
+
+
+/*
+ * The `docker rmi ...` implementation for v2 images.
+ *
+ * - TODO: Support 'noprune' option.
+ */
+function _deleteImageV2(opts, callback) {
+    assert.optionalObject(opts.imgTag, 'opts.imgTag');
+
+    var DRY_RUN = false; // for development use only
+    var app = opts.app;
+    var changes = [];
+    var dockerId = imgmanifest.dockerIdFromDigest(opts.img.config_digest);
+    var log = opts.log;
+    var shortId = imgmanifest.shortDockerId(dockerId);
+    var vmapi = getVmapiClient(app.config.vmapi);
+
+    // Helper to remove an image tag (used in pipeline below).
+    function removeImageTag(imgTag, cb) {
+        log.debug({imgTag: imgTag}, 'deleteImage: remove image tag');
+        if (DRY_RUN) {
+            changes.push({
+                Untagged: imgTag.repo + ':' + imgTag.tag });
+            cb();
+            return;
+        }
+        ImageTagV2.del(app, log, imgTag, function (err) {
+            if (err) {
+                cb(err);
+            } else {
+                changes.push({
+                    Untagged: imgTag.repo + ':' + imgTag.tag });
+                cb();
+            }
+        });
+    }
+
+    vasync.pipeline({arg: opts, funcs: [
+        getImgTags,
+        checkTagReferences,
+        checkJustUntagImage,
+        checkDependentImages,
+        verifyNotInUse,
+        getImgsToDelete,
+        deleteDockerTags,
+        deleteDockerImages,
+        deleteImgapiLayers
+    ]}, function (err) {
+        if (err === true) {
+            // Early abort marker.
+            err = null;
+        }
+        callback(err, changes);
+    });
+
+    function getImgTags(ctx, cb) {
+        tagsForImage(ctx.img, {app: app, log: log, account: opts.account},
+                function (err, imgTags) {
+            if (err) {
+                cb(err);
+                return;
+            }
+            ctx.imgTags = imgTags;
+            cb();
+        });
+    }
+
+    function checkTagReferences(ctx, cb) {
+        // If there are multiple tags for this image, and the image was found
+        // using the config_digest (or digest prefix), we can only remove
+        // the image if force is set to true.
+        //
+        // Note: ctx.imgTag is only set if the image was found using the name
+        // and not the config digest.
+        log.debug({givenName: opts.name, config_digest: ctx.img.config_digest,
+            imgTags: ctx.imgTags, imgTag: ctx.imgTag},
+            'deleteImage: checkTagReferences');
+        if (!ctx.imgTag && !opts.force && ctx.imgTags.length > 1) {
+            cb(new errors.DockerError(format('conflict: unable to delete '
+                + '%s (must be forced) - image is referenced in one or '
+                + 'more repositories', shortId)));
+            return;
+        }
+        cb();
+    }
+
+    function checkJustUntagImage(ctx, cb) {
+        // When a tag name is provided, if there are multiple tags for this
+        // image we just want to untag the given one and leave the image and
+        // other tags still there.
+        //
+        // Note: ctx.imgTag is only set if the image was found using the name
+        // and not the digest.
+        if (ctx.imgTag && ctx.imgTags.length > 1) {
+            removeImageTag(ctx.imgTag, function (err) {
+                // Early abort - nothing more to do here.
+                cb(err || true);
+            });
+            return;
+        }
+        cb();
+    }
+
+    function checkDependentImages(ctx, cb) {
+        // If another docker image references the target image, if so then
+        // don't allow the deletion.
+        var filter = [ {
+            parent: opts.img.config_digest,
+            owner_uuid: opts.account.uuid
+        } ];
+        ImageV2.list(opts.app, log, filter, function (err, dependentImgs) {
+            if (err) {
+                cb(err);
+                return;
+            }
+            if (dependentImgs.length > 0) {
+                cb(new errors.DockerError(format(
+                    'conflict: unable to delete %s (cannot be forced) - '
+                    + 'image has dependent child images',
+                    shortId)));
+                return;
+            }
+            cb();
+        });
+    }
+
+    function verifyNotInUse(ctx, cb) {
+        // When it comes to deleting images, and a container is still using
+        // it, docker follows these rules:
+        // -----------------------------------------------------------
+        // | id/name | vm state    | allowed | allow with force      |
+        // |---------------------------------------------------------|
+        // | id      | running     | no      | no                    |
+        // | id      | not running | no      | yes                   |
+        // | name    | running     | no      | yes (but just untags) |
+        // | name    | not running | no      | yes                   |
+        // -----------------------------------------------------------
+        var query = {
+            docker: true,
+            state: (opts.force ? 'running' : 'active'),
+            image_uuid: ctx.img.image_uuid,
+            owner_uuid: opts.account.uuid
+        };
+
+        vmapi.listVms(query, {
+            headers: {'x-request-id': opts.req_id}
+        }, function (vmapiErr, vms) {
+            if (vmapiErr) {
+                cb(errors.vmapiErrorWrap(vmapiErr,
+                    'could not delete image'));
+                return;
+            } else if (vms.length === 0) {
+                cb();
+                return;
+            }
+
+            vms.sort(function (a, b) {
+                if (a.state < b.state)
+                    return -1;
+                if (a.state > b.state)
+                    return 1;
+                return 0;
+            });
+
+            var vmShortId = utils.vmUuidToShortDockerId(vms[0].uuid);
+            var vmState = vms[0].state;
+
+            // Note the error message wording is different depending whether an
+            // image tag is used to lookup the image - good one docker!
+            if (!ctx.imgTag) {
+                if (vmState === 'running') {
+                    // Doesn't matter if forced or not, cannot delete a running
+                    // container by it's image id.
+                    cb(new errors.DockerError(format(
+                        'conflict: unable to delete %s (cannot be forced) - '
+                        + 'image is being used by running container %s',
+                        shortId, vmShortId)));
+                } else if (opts.force) {
+                    // Force of a stopped container is okay.
+                    cb();
+                } else {
+                    cb(new errors.DockerError(format(
+                        'conflict: unable to delete %s (must be forced) - '
+                        + 'image is being used by %s container %s',
+                        shortId, vmState, vmShortId)));
+                }
+            } else {
+                // Image was found using the repo/tag name.
+                if (vmState === 'running' && opts.force) {
+                    // Just untag the image.
+                    removeImageTag(ctx.imgTag, function (err) {
+                        // Early abort - nothing more to do here.
+                        cb(err || true);
+                    });
+                } else if (opts.force) {
+                    // Force of a stopped container is okay.
+                    cb();
+                } else {
+                    cb(new errors.DockerError(format(
+                        'conflict: unable to remove repository reference '
+                        + '"%s:%s" (must force) - container %s is using its '
+                        + 'referenced image %s',
+                        ctx.imgTag.repo, ctx.imgTag.tag, vmShortId,
+                        shortId)));
+                }
+            }
+        });
+    }
+
+    function getImgsToDelete(ctx, cb) {
+        function summaryFromImg(img) {
+            return {
+                config_digest: img.config_digest,
+                created: img.created,
+                head: img.head,
+                image_uuid: img.image_uuid,
+                owner_uuid: img.owner_uuid
+            };
+        }
+
+        getImageAncestry({
+            app: app,
+            log: log,
+            img: ctx.img,
+            account: opts.account
+        }, function (err, ancestry) {
             if (err) {
                 cb(new errors.DockerError(err, 'could not delete image'));
                 return;
             }
-            ctx.dcRefcount = count;
+
+            // Note: Don't delete an ancestor that is a head image.
+            var headFound = false;
+            ctx.imgsToDelete = [ancestry[0]].concat(ancestry.slice(1).
+                filter(function (ancestorImg) {
+                    headFound = headFound || ancestorImg.head;
+                    if (headFound) {
+                        if (log.debug()) {
+                            log.debug(
+                                {ancestorImg: summaryFromImg(ancestorImg)},
+                                'deleteImage: do not delete head ancestor');
+                        }
+                        return false;
+                    }
+                    return true;
+                }
+            ));
+
+            if (log.debug()) {
+                log.debug({imgsToDelete: ctx.imgsToDelete.map(summaryFromImg)},
+                    'deleteImage: imgsToDelete');
+            }
             cb();
         });
     }
 
-    function untagHeads(ctx, cb) {
-        log.debug({imgTags: ctx.imgTags}, 'deleteImage: untagHeads');
+    function deleteDockerTags(ctx, cb) {
+        log.debug({imgTags: ctx.imgTags}, 'deleteImage: deleteDockerTags');
 
         vasync.forEachPipeline({
             inputs: ctx.imgTags,
@@ -1211,7 +2161,7 @@ function deleteImage(opts, callback) {
                     nextImgTag();
                     return;
                 }
-                ImageTag.del(app, log, imgTag, function (err) {
+                ImageTagV2.del(app, log, imgTag, function (err) {
                     if (err) {
                         nextImgTag(err);
                     } else {
@@ -1224,12 +2174,7 @@ function deleteImage(opts, callback) {
         }, cb);
     }
 
-    function deleteImgs(ctx, cb) {
-        if (dontDeleteImages) {
-            cb();
-            return;
-        }
-
+    function deleteDockerImages(ctx, cb) {
         vasync.forEachPipeline({
             inputs: ctx.imgsToDelete,
             func: deleteOneImg
@@ -1241,82 +2186,191 @@ function deleteImage(opts, callback) {
             cb();
         });
 
-        /*
-         * `true` if we hit `ImageHasDependentImagesError` error from IMGAPI,
-         * in which case we'll not bother attempting to delete further b/c
-         * they'll hit the same error.
-         */
-        var hitImageHasDependentImagesError = false;
-
-        /*
-         * We only remove the image *ref* when it is no longer being
-         * used by the account. If this is the last usage of the image
-         * across the whole DC (dcRefcount===1), then actually delete
-         * from IMGAPI.
+        /**
+         * Delete up the ancestor chain.
          */
         function deleteOneImg(img, nextImg) {
-            log.debug({imgId: img.docker_id, indexName: img.index_name},
+            if (img.config_digest !== ctx.img.config_digest) {
+                assert.equal(img.head, false, 'img.head should be false');
+            }
+
+            log.debug({config_digest: img.config_digest},
                 'deleteImage: deleteOneImg');
             if (DRY_RUN) {
-                changes.push({ Deleted: img.docker_id });
+                changes.push({ Deleted: img.config_digest });
                 nextImg();
                 return;
             }
 
-            if (img.refcount > 1) {
-                log.debug({imgId: img.docker_id, indexName: img.index_name},
-                    'deleteImage: remove %s from heads', ctx.img.docker_id);
-                var update = {
-                    owner_uuid: img.owner_uuid,
-                    index_name: img.index_name,
-                    docker_id: img.docker_id,
-                    // Update:
-                    heads: img.params.heads.filter(function (id) {
-                        return id !== ctx.img.docker_id;
-                    })
+            ImageV2.del(app, log, img, function (delErr) {
+                if (delErr) {
+                    nextImg(delErr);
+                    return;
+                }
+
+                changes.push({ Deleted: img.config_digest });
+                nextImg();
+            });
+        }
+    }
+
+    function deleteImgapiLayers(ctx, cb) {
+        // Check the image layers in IMGAPI, if they are no longer referenced
+        // anywhere in the DC then the IMGAPI layer should be deleted.
+        var manifest;
+        try {
+            manifest = JSON.parse(ctx.img.manifest_str);
+        } catch (e) {
+            log.error({img: ctx.img}, 'Unable to parse image manifest_str');
+            cb(new errors.DockerError(e,
+                format('Unable to parse image manifest_str for image %s',
+                ctx.img.config_digest)));
+            return;
+        }
+
+        var hitImageHasDependentImagesError = false;
+        var diffIds = ctx.img.rootfs.diff_ids;
+        assert.equal(diffIds.length, manifest.layers.length,
+            'diff_ids length and manifest.layers length must be equal');
+
+        var layerDigests = [];
+        var layerInfos = manifest.layers.map(
+            function (layer, idx) {
+                layerDigests.push(layer.digest);
+                return {
+                    layerDigest: layer.digest,
+                    diffId: diffIds[idx],
+                    uuid: imgmanifest.imgUuidFromDockerDigests(layerDigests)
                 };
-                if (img.docker_id === ctx.img.docker_id) {
-                    /*
-                     * The Docker image being removed must no longer be
-                     * marked as a 'head', else it could be "deleted again"...
-                     * during which `dcRefcount` values are not valid. This
-                     * is DOCKER-709.
-                     */
-                    update.head = false;
+            }
+        );
+        log.debug({layerInfos: layerInfos}, 'deleteImage: deleteImgapiLayers');
+
+        /*
+         * According to the manifest-v2-2.md spec `manifest.layers` has the base
+         * layer first. We therefore process these in reverse order: the base
+         * layer must be deleted last.
+         */
+        vasync.forEachPipeline({
+            func: deleteLayer,
+            inputs: layerInfos.reverse()
+        }, cb);
+
+        function deleteLayer(layerInfo, nextLayer) {
+            if (hitImageHasDependentImagesError) {
+                nextLayer();
+                return;
+            }
+
+            var layerDigest = layerInfo.layerDigest;
+            var uuid = layerInfo.uuid;
+
+            // Ensure no other docker image uses this *layer* in the *DC*.
+            var filter = [ { image_uuid: uuid } ];
+            ImageV2.list(opts.app, log, filter, function (refErr, refImgs) {
+                if (refErr) {
+                    nextLayer(refErr);
+                    return;
                 }
-                Image.update(app, log, update, nextImg);
-            } else {
-                log.debug({imgId: img.docker_id, indexName: img.index_name},
-                    'deleteImage: delete image', ctx.img.docker_id);
-                Image.del(app, log, img, function (delErr) {
-                    if (delErr) {
-                        nextImg(delErr);
-                        return;
-                    }
-                    changes.push({ Deleted: img.docker_id });
 
-                    var isLastRef = (ctx.dcRefcount[img.docker_id]
-                                            !== undefined);
-                    if (!isLastRef || hitImageHasDependentImagesError) {
-                        nextImg();
-                        return;
-                    }
+                var layerRefCount = refImgs.length;
+                if (layerRefCount >= 1) {
+                    // This image is referenced by other docker image(s).
+                    log.debug({layerDigest: layerDigest,
+                        layerRefCount: layerRefCount, uuid: uuid},
+                        'deleteImage: deleteLayer: not deleting - '
+                        + 'layer is referenced by other images');
+                    // TODO: Should we add a 'Deleted' changes entry here? We
+                    // would need to check that these other referencing images
+                    // are not owned by this user.
+                    // [XXX A: Yes we should for compat. --Trent]
+                    hitImageHasDependentImagesError = true;
+                    nextLayer();
+                    return;
+                }
 
-                    log.debug({imgUuid: img.image_uuid},
-                        'deleteImage: delete imgapi image (last ref)');
-                    app.imgapi.deleteImage(img.image_uuid, {
-                        headers: {'x-request-id': opts.req_id}
-                    }, function (err) {
-                        if (err && err.restCode === 'ImageHasDependentImages') {
-                            hitImageHasDependentImagesError = true;
-                            log.info({imgUuid: img.image_uuid},
-                                'deleteImage: hit ImageHasDependentImages');
-                            err = null;
-                        }
-                        nextImg(err);
-                    });
+                // No other docker image references this layer - try and delete
+                // it from IMGAPI.
+                log.debug({layerDigest: layerDigest, uuid: uuid},
+                    'deleteImage: deleteLayer');
+                if (DRY_RUN) {
+                    changes.push({ Deleted: layerInfo.diffId });
+                    nextLayer();
+                    return;
+                }
+                app.imgapi.deleteImage(uuid, {
+                    headers: {'x-request-id': opts.req_id}
+                }, function (err) {
+                    if (err && err.restCode === 'ImageHasDependentImages') {
+                        // This origin is used by another IMGAPI image.
+                        hitImageHasDependentImagesError = true;
+                        log.info({layerDigest: layerDigest, uuid: uuid},
+                            'deleteImage: deleteLayer: hit '
+                            + 'ImageHasDependentImages');
+                        err = null;
+                    } else if (!err) {
+                        changes.push({ Deleted: layerInfo.diffId });
+                    }
+                    nextLayer(err);
                 });
+            });
+        }
+    }
+}
+
+
+function deleteImage(opts, callback) {
+    assert.object(opts, 'opts');
+    assert.optionalObject(opts.app, 'opts.app');
+    assert.bool(opts.force, 'opts.force');
+    assert.optionalObject(opts.log, 'opts.log');
+    assert.string(opts.name, 'opts.name');
+    assert.string(opts.req_id, 'opts.req_id');
+    assert.object(opts.account, 'opts.account');
+
+    var changes;
+    var log = opts.log;
+
+    log.debug({givenName: opts.name}, 'deleteImage');
+
+    vasync.pipeline({funcs: [
+        getImg,
+        doDeleteImage
+    ]}, function (err) {
+        callback(err, changes);
+    });
+
+
+    function getImg(_, cb) {
+        imgFromName(opts, function (err, img, imgTag) {
+            if (err) {
+                cb(err);
+            } else if (!img) {
+                cb(new errors.ResourceNotFoundError(
+                    'No such image: ' + opts.name));
+            } else {
+                log.debug({img: img, imgTag: imgTag}, 'deleteImage: getImg');
+                opts.img = img;
+                if (imgTag) {
+                    // Only set if `name` was not an imgId.
+                    opts.imgTag = imgTag;
+                }
+                cb();
             }
+        });
+    }
+
+    function doDeleteImage(_, cb) {
+        if (isV1Image(opts.img)) {
+            _deleteImageV1(opts, function (err, _changes) {
+                changes = _changes;
+                cb(err);
+            });
+        } else {
+            _deleteImageV2(opts, function (err, _changes) {
+                changes = _changes;
+                cb(err);
+            });
         }
     }
 }
@@ -1335,7 +2389,7 @@ function inspectImage(opts, callback) {
     assert.object(opts.account, 'opts.account');
     assert.string(opts.name, 'opts.name');
     assert.object(opts.log, 'opts.log');
-    assert.optionalString(opts.index_name, 'opts.index_name');
+    assert.optionalString(opts.index_name, 'opts.index_name'); // For ImageV1.
 
     imgFromName(opts, function (err, img) {
         if (err) {
@@ -1345,13 +2399,7 @@ function inspectImage(opts, callback) {
                 'No such image: ' + opts.name));
         } else {
             // Get tags and return inspect info.
-            var filter = [
-                {owner_uuid: opts.account.uuid, docker_id: img.docker_id}
-            ];
-            if (opts.index_name) {
-                filter[0].index_name = opts.index_name;
-            }
-            ImageTag.list(opts.app, opts.log, filter, function (err2, imgTags) {
+            tagsForImage(img, opts, function _getImgTagsCb(err2, imgTags) {
                 if (err2) {
                     callback(err2);
                     return;
@@ -1482,6 +2530,8 @@ function pullImage(opts, callback) {
         {
             errmsg = format('Timeout connecting to host %s',
                 opts.rat.index.name);
+        } else if (err.code === 'ImageFileTooBig') {
+            errmsg = format('Error downloading %s: %s', imgName, err.message);
         } else if (err.code === 'NotImplemented') {
             // E.g. OAuth auth to a Docker Registry before DOCKER-771.
             errmsg = format('Could not pull from registry %s: %s',
@@ -1561,7 +2611,7 @@ function pullImage(opts, callback) {
             regConfig: opts.req.headers['x-registry-config']
         };
 
-        opts.wfapi.createPullImageJob(jobOpts, function (err, juuid) {
+        opts.wfapi.createPullImageV2Job(jobOpts, function (err, juuid) {
             if (err) {
                 errorAndEnd(err);
                 next();
@@ -1599,11 +2649,13 @@ function pullImage(opts, callback) {
 function createImgapiDockerImage(imageJson, opts, callback) {
     assert.object(opts, 'opts');
     assert.optionalString(opts.account_uuid, 'opts.account_uuid');
+    assert.arrayOfString(opts.layerDigests, 'opts.layerDigests');
     assert.object(opts.rat, 'opts.rat');
     assert.object(opts.req, 'opts.req');
 
     opts.req.log.debug('opts.rat: ', opts.rat);
     var manifest = imgmanifest.imgManifestFromDockerInfo({
+        layerDigests: opts.layerDigests,
         imgJson: imageJson,
         owner: opts.account_uuid,
         public: false,
@@ -1626,163 +2678,73 @@ function createImgapiDockerImage(imageJson, opts, callback) {
 
 
 /**
- * Create new (unactivated) docker image - in imgapi and sdc-docker image model.
- *
- * @param opts {Object} Containing image payload information.
- * @param callback {Function} with signature fn(err, img).
- */
-function createImage(opts, callback) {
-    assert.object(opts, 'opts');
-    assert.object(opts.payload, 'opts.payload');
-    assert.object(opts.payload.image, 'opts.payload.image');
-    assert.optionalBool(opts.payload.head, 'opts.payload.head');
-    assert.optionalArrayOfString(opts.payload.heads, 'opts.payload.heads');
-    assert.number(opts.payload.size, 'opts.payload.size');
-    assert.optionalNumber(opts.payload.virtual_size,
-                        'opts.payload.virtual_size');
-    assert.optionalObject(opts.rat, 'opts.rat');
-    assert.object(opts.req, 'opts.req');
-
-    var rat = opts.rat;
-    var req = opts.req;
-    var account_uuid = req.account.uuid;
-    var imageJson = opts.payload.image;
-
-    if (!rat) {
-        // Empty repo/tag.
-        rat = {
-            localName: '',
-            index: { name: 'docker.io' }
-        };
-    }
-
-    vasync.pipeline({arg: {}, funcs: [
-        createImgapiImage,
-        createSdcDockerImageLayer
-    ]}, function _createImagePipelineCb(err, results) {
-        // Pass the sdc docker Image object back.
-        callback(err, results.successes[results.successes.length - 1]);
-    });
-
-    // Create imgapi image object.
-    function createImgapiImage(ctx, next) {
-        var imgOpts = {
-            account_uuid: account_uuid,
-            rat: rat,
-            req: req
-        };
-        createImgapiDockerImage(imageJson, imgOpts, function (err, imgapiImg) {
-            if (!err) {
-                ctx.image_uuid = imgapiImg.uuid;
-            }
-            next(err);
-        });
-    }
-
-    // Create sdc-docker image model.
-    function createSdcDockerImageLayer(ctx, next) {
-        var modelOpts = {
-            head: opts.payload.head,
-            heads: opts.payload.heads,
-            image_uuid: ctx.image_uuid,
-            index_name: rat.index.name,
-            owner_uuid: account_uuid,
-            size: opts.payload.size,
-            virtual_size: opts.payload.virtual_size
-        };
-        var img = dockerImageJsonToModel(imageJson, modelOpts);
-        req.log.debug('img: ', img);
-        Image.create(req.app, req.log, img, next);
-    }
-}
-
-
-/**
- * Update an image heads reference to include the given docker id.
- *
- * @param opts {Object} Containing image id, index_name and head information.
- * @param callback {Function} with signature fn(err, img).
- *
- * Warning: There is a race condition in which another call could modify the
- *          docker heads during the time between our fetch and update.
- */
-function addImageHeads(opts, callback) {
-    assert.object(opts, 'opts');
-    assert.arrayOfString(opts.heads, 'opts.heads');
-    assert.string(opts.id, 'opts.id');
-    assert.string(opts.index_name, 'opts.index_name');
-    assert.object(opts.req, 'opts.req');
-
-    var id = opts.id;
-    var req = opts.req;
-    var imageOpts = {
-        account: req.account,
-        app: req.app,
-        includeSmartos: false,
-        log: req.log,
-        index_name: opts.index_name,
-        name: id
-    };
-    req.backend.imgFromName(imageOpts, function (err, img) {
-        if (err) {
-            callback(err);
-        } else if (!img) {
-            callback(new errors.ResourceNotFoundError(
-                'No image found with id' + id));
-        } else {
-            var heads = img.heads || [];
-            opts.heads.forEach(function headForEach(headId) {
-                if (heads.indexOf(headId) === -1) {
-                    heads.push(headId);
-                }
-            });
-            Image.update(req.app, req.log, {
-                owner_uuid: img.owner_uuid,
-                index_name: img.index_name,
-                docker_id: img.docker_id,
-                // Update:
-                heads: heads
-            }, callback);
-        }
-    });
-}
-
-
-/**
- * Tags an image (given by docker_id) with the given name.
+ * Tags the given image digest with the given name.
  *
  * Accepted name examples:
  *   busybox
  *   toddw/mybusybox:latest
  *   my.registry.com:5000/ns/myname:head
  *
- * @param opts {Object} Contains image id and tag information.
+ * @param opts {Object} Contains image and tag information.
  * @param callback {Function} with signature fn(err, imgTag).
  */
 function tagImage(opts, callback) {
     assert.object(opts, 'opts');
-    assert.string(opts.docker_id, 'opts.docker_id');
     assert.string(opts.name, 'opts.name');
     assert.object(opts.req, 'opts.req');
+    assert.optionalString(opts.config_digest, 'opts.config_digest');
+    assert.optionalObject(opts.img, 'opts.img');
+    assert.optionalObject(opts.rat, 'opts.rat');
 
+    var config_digest = opts.config_digest;
+    var rat = opts.rat;
     var req = opts.req;
 
-    try {
-        var rat = drc.parseRepoAndTag(opts.name);
-    } catch (e) {
-        callback(new errors.DockerError(e, e.message));
-        return;
+    if (!rat) {
+        try {
+            rat = drc.parseRepoAndTag(opts.name);
+        } catch (e) {
+            callback(new errors.DockerError(e, e.message));
+            return;
+        }
+    }
+
+    if (!config_digest) {
+        assert.object(opts.img,
+            'opts.img or opts.config_digest must be provided');
+        if (isV1Image(opts.img)) {
+            callback(new errors.DockerError(
+                'This is a deprecated image which cannot be tagged '
+                + '- please repull or rebuild the image'));
+            return;
+        }
+        config_digest = opts.img.config_digest;
     }
 
     var params = {
-        docker_id: opts.docker_id,
-        index_name: rat.index.name,
+        config_digest: config_digest,
         owner_uuid: req.account.uuid,
         repo: rat.localName,
         tag: rat.tag
 
     };
-    ImageTag.create(req.app, req.log, params, callback);
+    ImageTagV2.create(req.app, req.log, params, callback);
+}
+
+
+/**
+ * Whether img is an instance of models.images.Image (aka v1 image).
+ */
+function isV1Image(img) {
+    return !img.hasOwnProperty('manifest_str');
+}
+
+
+/**
+ * Whether img came from a docker v2.1 image.
+ */
+function isV21Image(img) {
+    return img.dockerImageVersion === '2.1';
 }
 
 
@@ -1800,17 +2762,16 @@ function getImageCount(opts, callback) {
 // ---- exports
 
 module.exports = {
-    addImageHeads: addImageHeads,
-    createImage: createImage,
     deleteImage: deleteImage,
     dockerImageJsonToModel: dockerImageJsonToModel,
     getImageCount: getImageCount,
-    getDockerImageForUuid: getDockerImageForUuid,
     getImageHistory: getImageHistory,
     getScratchImage: getScratchImage,
+    isV1Image: isV1Image,
     listImages: listImages,
     inspectImage: inspectImage,
     pullImage: pullImage,
+    imgFromConfigDigest: imgFromConfigDigest,
     imgFromName: imgFromName,
     tagImage: tagImage
 };
diff --git a/lib/backends/sdc/index.js b/lib/backends/sdc/index.js
index 12efd46..c16182e 100644
--- a/lib/backends/sdc/index.js
+++ b/lib/backends/sdc/index.js
@@ -65,8 +65,6 @@ SdcBackend.prototype.containerArchiveStat =
     containers.containerArchiveStat;
 
 // images.js
-SdcBackend.prototype.addImageHeads = images.addImageHeads;
-SdcBackend.prototype.createImage = images.createImage;
 SdcBackend.prototype.deleteImage = images.deleteImage;
 SdcBackend.prototype.getImageCount = images.getImageCount;
 SdcBackend.prototype.getImageHistory = images.getImageHistory;
diff --git a/lib/backends/sdc/utils.js b/lib/backends/sdc/utils.js
index b69511e..9ba6fdc 100644
--- a/lib/backends/sdc/utils.js
+++ b/lib/backends/sdc/utils.js
@@ -16,7 +16,6 @@ var restify = require('restify');
 var triton_tags = require('triton-tags');
 
 var common = require('../../common');
-var constants = require('../../constants');
 var Link = require('../../models/link');
 
 
@@ -827,12 +826,10 @@ function vmobjToInspect(opts, obj, vmData, callback) {
     _addLinks();
 }
 
-function imgobjToInspect(obj, imgTags) {
-    assert.object(obj, 'obj');
+function imgobjToInspect(image, imgTags) {
+    assert.object(image, 'image');
     assert.optionalArrayOfObject(imgTags, 'imgTags');
 
-    var image = obj.serialize();
-
     var dockerImage = {
         Architecture: image.architecture || 'amd64',
         Author: image.author,
@@ -840,17 +837,17 @@ function imgobjToInspect(obj, imgTags) {
         Config: image.config,
         Container: '', // which container?
         ContainerConfig: image.container_config,
-        Created: new Date(image.created),
-        DockerVersion: constants.SERVER_VERSION,
+        Created: image.createdISOString,
+        DockerVersion: image.docker_version,
         GraphDriver: {
             Data: null,
             Name: 'sdc-docker'
         },
-        Id: image.docker_id,
+        Id: image.config_digest || image.docker_id,
         Os: 'Linux',
         Parent: image.parent || '',
         RepoTags: [],
-        RepoDigests: [], // ?
+        RepoDigests: [],
         Size: image.size,
         VirtualSize: image.virtual_size
     };
@@ -860,6 +857,19 @@ function imgobjToInspect(obj, imgTags) {
         dockerImage.RepoTags = imgTags.map(function (it) {
             return it.repo + ':' + it.tag;
         });
+        if (image.manifest_digest) {
+            dockerImage.RepoDigests = imgTags.map(function (it) {
+                return it.repo + '@' + image.manifest_digest;
+            });
+        }
+    }
+
+    if (image.rootfs) {
+        // This came from a v2.2 image manifest.
+        dockerImage.RootFS = {
+            Type: image.rootfs.type,
+            Layers: image.rootfs.diff_ids
+        };
     }
 
     return dockerImage;
diff --git a/lib/endpoints/admin/image-tags.js b/lib/endpoints/admin/image-tags-v2.js
similarity index 63%
rename from lib/endpoints/admin/image-tags.js
rename to lib/endpoints/admin/image-tags-v2.js
index 2250aab..d0b9959 100644
--- a/lib/endpoints/admin/image-tags.js
+++ b/lib/endpoints/admin/image-tags-v2.js
@@ -5,31 +5,31 @@
  */
 
 /*
- * Copyright (c) 2015, Joyent, Inc.
+ * Copyright (c) 2017, Joyent, Inc.
  */
 
 var restify = require('restify');
-var ImageTag = require('../../models/image-tag');
+var ImageTagV2 = require('../../models/image-tag-v2');
 
 var UNSET_OWNER_UUID = '00000000-0000-0000-0000-000000000000';
 
 
 /**
- * GET /admin/image_tags
+ * GET /admin/image_tags_v2
  */
-function adminListImageTags(req, res, next) {
+function adminListImageTagsV2(req, res, next) {
     var params = {};
     if (req.query.owner_uuid) {
         params.owner_uuid = req.query.owner_uuid;
     }
-    if (req.query.docker_id) {
-        params.docker_id = req.query.docker_id;
+    if (req.query.config_digest) {
+        params.config_digest = req.query.config_digest;
     }
     if (req.query.tag) {
         params.tag = req.query.tag;
     }
 
-    ImageTag.list(req.app, req.log, params, function (err, tags) {
+    ImageTagV2.list(req.app, req.log, params, function (err, tags) {
         if (err) {
             next(err);
             return;
@@ -47,15 +47,15 @@ function adminListImageTags(req, res, next) {
 
 
 /**
- * POST /admin/image_tags
+ * POST /admin/image_tags_v2
  */
-function adminCreateImageTag(req, res, next) {
+function adminCreateImageTagV2(req, res, next) {
     var params = req.body;
     if (!params.owner_uuid || params.owner_uuid === UNSET_OWNER_UUID) {
         params.owner_uuid = req.app.config.adminUuid;
     }
 
-    ImageTag.create(req.app, req.log, params, function (err, tag) {
+    ImageTagV2.create(req.app, req.log, params, function (err, tag) {
         if (err) {
             next(err);
             return;
@@ -71,10 +71,10 @@ function adminCreateImageTag(req, res, next) {
  * Register all endpoints with the restify server
  */
 function register(http, before) {
-    http.get({ path: '/admin/image_tags', name: 'AdminListImageTags' },
-        before, adminListImageTags);
-    http.post({ path: '/admin/image_tags', name: 'AdminCreateImageTag' },
-        before, adminCreateImageTag);
+    http.get({ path: '/admin/image_tags_v2', name: 'AdminListImageTagsV2' },
+        before, adminListImageTagsV2);
+    http.post({ path: '/admin/image_tags_v2', name: 'AdminCreateImageTagV2' },
+        before, adminCreateImageTagV2);
 }
 
 
diff --git a/lib/endpoints/admin/images.js b/lib/endpoints/admin/images-v2.js
similarity index 56%
rename from lib/endpoints/admin/images.js
rename to lib/endpoints/admin/images-v2.js
index 9c2a215..6e18bf3 100644
--- a/lib/endpoints/admin/images.js
+++ b/lib/endpoints/admin/images-v2.js
@@ -5,30 +5,27 @@
  */
 
 /*
- * Copyright (c) 2015, Joyent, Inc.
+ * Copyright (c) 2017, Joyent, Inc.
  */
 
-var Image = require('../../models/image');
+var ImageV2 = require('../../models/image-v2');
 
 var UNSET_OWNER_UUID = '00000000-0000-0000-0000-000000000000';
 
 
 /**
- * GET /admin/images
+ * GET /admin/images_v2
  */
-function adminListImages(req, res, next) {
+function adminListImagesV2(req, res, next) {
     var params = {};
     if (req.query.owner_uuid) {
         params.owner_uuid = req.query.owner_uuid;
     }
-    if (req.query.index_name) {
-        params.index_name = req.query.index_name;
-    }
-    if (req.query.docker_id) {
-        params.docker_id = req.query.docker_id;
+    if (req.query.config_digest) {
+        params.config_digest = req.query.config_digest;
     }
 
-    Image.list(req.app, req.log, params, function (err, images) {
+    ImageV2.list(req.app, req.log, params, function (err, images) {
         if (err) {
             next(err);
             return;
@@ -46,18 +43,15 @@ function adminListImages(req, res, next) {
 
 
 /**
- * POST /admin/images?action=create
- * POST /admin/images?action=update
+ * POST /admin/images_v2?action=create
  */
-function adminCreateImage(req, res, next) {
-    // XXX(trent): validate args
+function adminCreateImageV2(req, res, next) {
     var params = req.body;
     if (!params.owner_uuid || params.owner_uuid === UNSET_OWNER_UUID) {
         params.owner_uuid = req.app.config.adminUuid;
     }
 
-    var fn = (req.query.action === 'update' ? Image.update : Image.create);
-    fn.call(Image, req.app, req.log, params, function (err, img) {
+    ImageV2.create(req.app, req.log, params, function (err, img) {
         if (err) {
             next(err);
         } else {
@@ -72,10 +66,10 @@ function adminCreateImage(req, res, next) {
  * Register all endpoints with the restify server
  */
 function register(http, before) {
-    http.get({ path: '/admin/images', name: 'AdminListImages' },
-        before, adminListImages);
-    http.post({ path: '/admin/images', name: 'AdminCreateImage' },
-        before, adminCreateImage);
+    http.get({ path: '/admin/images_v2', name: 'AdminListImagesV2' },
+        before, adminListImagesV2);
+    http.post({ path: '/admin/images_v2', name: 'AdminCreateImageV2' },
+        before, adminCreateImageV2);
 }
 
 
diff --git a/lib/endpoints/admin/index.js b/lib/endpoints/admin/index.js
index 94852c5..1caf18d 100644
--- a/lib/endpoints/admin/index.js
+++ b/lib/endpoints/admin/index.js
@@ -17,8 +17,8 @@
 var toRegister = {
     '/admin/config': require('./config'),
     '/admin/progress': require('./progress'),
-    '/admin/images': require('./images'),
-    '/admin/image_tags': require('./image-tags')
+    '/admin/images_v2': require('./images-v2'),
+    '/admin/image_tags_v2': require('./image-tags-v2')
 };
 
 
diff --git a/lib/endpoints/commit.js b/lib/endpoints/commit.js
index c404a65..3223ae1 100644
--- a/lib/endpoints/commit.js
+++ b/lib/endpoints/commit.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2016, Joyent, Inc.
+ * Copyright (c) 2017, Joyent, Inc.
  */
 
 var restify = require('restify');
@@ -55,14 +55,13 @@ function commit(req, res, next) {
      */
     req.connection.setTimeout(10 * 60 * 1000);
 
-    req.backend.commitImage(req, commitOpts, function (err, imageId) {
+    req.backend.commitImage(req, commitOpts, function (err, digest) {
         if (err) {
             res.send(err);
         } else {
-            log.debug('docker commit finished successfully');
-            // Note: Docker returns sha256: {"Id":"sha256:93c3e0ca32...1453a"}
+            log.debug({digest: digest}, 'docker commit finished successfully');
             res.status(201);  // Okay - image was committed.
-            res.write(JSON.stringify({'Id': imageId}) + '\n');
+            res.write(JSON.stringify({'Id': digest}) + '\n');
         }
 
         res.end();
diff --git a/lib/endpoints/images.js b/lib/endpoints/images.js
index 5d3f081..e553ea3 100644
--- a/lib/endpoints/images.js
+++ b/lib/endpoints/images.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2015, Joyent, Inc.
+ * Copyright (c) 2017, Joyent, Inc.
  */
 
 var drc = require('docker-registry-client');
@@ -70,6 +70,13 @@ function imageCreate(req, res, next) {
 
     var log = req.log;
 
+    /*
+     * Node's default HTTP timeout is two minutes, add a little longer in case
+     * another component times out after 2 minutes - which should give enough
+     * time to report any timeout errors before closing the connection.
+     */
+    req.connection.setTimeout(150 * 1000);
+
     /*
      * docker pull -a foo     ->  fromImage=foo
      * docker pull foo        ->  fromImage=foo:latest
@@ -85,10 +92,6 @@ function imageCreate(req, res, next) {
         next(new errors.DockerError(e, e.toString()));
         return;
     }
-    if (rat.digest) {
-        next(new errors.NotImplementedError('"docker pull" by @DIGEST'));
-        return;
-    }
     // TODO(DOCKER-587): is this `all = ...` accurate with digest in play?
     var all = (!req.query.tag
         && rat.tag && rat.tag === 'latest'
@@ -98,7 +101,12 @@ function imageCreate(req, res, next) {
         return;
     }
     if (req.query.tag) {
-        rat.tag = req.query.tag;
+        if (req.query.tag.substr(0, 7) === 'sha256:') {
+            rat.digest = req.query.tag;
+            rat.tag = '';
+        } else {
+            rat.tag = req.query.tag;
+        }
     }
 
 
@@ -161,9 +169,7 @@ function imageHistory(req, res, next) {
             next(histErr);
             return;
         }
-        var historyItems = history.map(
-            function (i) { return i.toHistoryItem(); });
-        res.send(historyItems);
+        res.send(history);
         next();
     });
 }
@@ -197,23 +203,16 @@ function imageTag(req, res, next) {
         repoAndTag += ':' + req.query.tag;
     }
 
+    // Ensure the tag name is valid.
     try {
-        var rat = drc.parseRepoAndTag(repoAndTag);
+        drc.parseRepoAndTag(repoAndTag);
     } catch (e) {
         next(new errors.DockerError(e, e.message));
         return;
     }
 
-    // DOCKER-748: Ensure the tag and the image are in the same repository.
-    if (req.image.index_name !== rat.index.name) {
-        next(new errors.DockerError(format(
-            'Cannot create tag reference between different registries (%s, %s)',
-            req.image.index_name, rat.index.name)));
-        return;
-    }
-
     req.backend.tagImage({
-        docker_id: req.image.docker_id,
+        img: req.image,
         name: repoAndTag,
         req: req
     }, function (err, history) {
diff --git a/lib/models/image-tag-v2.js b/lib/models/image-tag-v2.js
new file mode 100644
index 0000000..576edd6
--- /dev/null
+++ b/lib/models/image-tag-v2.js
@@ -0,0 +1,198 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+
+/*
+ * Image tag v2 model - to be used with ImageV2 objects.
+ *
+ * This holds each tagged image for a given account (`owner_uuid`). IOW, this
+ * mapping:
+ *      (owner_uuid, repo, tag) => ImageV2.config_digest
+ */
+
+var assert = require('assert-plus');
+var drc = require('docker-registry-client');
+var fmt = require('util').format;
+var vasync = require('vasync');
+
+var moray = require('../moray');
+
+
+
+// --- Globals
+
+var BUCKET = {
+    desc: 'docker image tag v2',
+    name: 'docker_image_tags_v2',
+    schema: {
+        index: {
+            config_digest: { type: 'string' },
+            owner_uuid: { type: 'string' },
+            /*
+             * The "localName" for the Docker repo. See
+             * // JSSTYLED
+             * <https://github.com/joyent/node-docker-registry-client/tree/master#overview>
+             */
+            repo: { type: 'string' },
+            tag: { type: 'string' }
+        }
+    },
+    version: 1
+};
+
+
+
+// --- Helpers
+
+function objectKey(params) {
+    assert.uuid(params.owner_uuid, 'params.owner_uuid');
+    assert.string(params.repo, 'params.repo');
+    assert.string(params.tag, 'params.tag');
+
+    return fmt('%s,%s,%s', params.owner_uuid, params.repo, params.tag);
+}
+
+
+// --- ImageTag object
+
+/**
+ * ImageTag model constructor
+ */
+function ImageTag(params) {
+    assert.object(params, 'image tag params');
+    assert.string(params.config_digest, 'params.config_digest');
+    assert.string(params.owner_uuid, 'params.owner_uuid');
+    assert.string(params.repo, 'params.repo');
+    assert.string(params.tag, 'params.tag');
+
+    this.params = params;
+
+    this.__defineGetter__('owner_uuid', function () {
+        return this.params.owner_uuid;
+    });
+    this.__defineGetter__('repo', function () {
+        return this.params.repo;
+    });
+    this.__defineGetter__('tag', function () {
+        return this.params.tag;
+    });
+    this.__defineGetter__('config_digest', function () {
+        return this.params.config_digest;
+    });
+}
+
+
+/**
+ * Returns the raw form of the image tag suitable for storing in moray,
+ * which is the same as the serialized form
+ */
+ImageTag.prototype.toJSON =
+    ImageTag.prototype.raw =
+    ImageTag.prototype.serialize =
+    function ()
+{
+    return {
+        owner_uuid: this.params.owner_uuid,
+        repo: this.params.repo,
+        tag: this.params.tag,
+        config_digest: this.params.config_digest
+    };
+};
+
+
+
+// --- Exported functions
+
+/**
+ * Creates a image tag.
+ */
+function createImageTag(app, log, params, callback) {
+    log.debug({params: params}, 'createImageTagV2: entry');
+
+    var imgTag = new ImageTag(params);
+    var key = objectKey(params);
+    app.moray.putObject(BUCKET.name, key, imgTag.raw(), function (err) {
+        if (err) {
+            return callback(err);
+        }
+        return callback(null, imgTag);
+    });
+}
+
+
+/**
+ * Lists all image tags
+ */
+function listImageTags(app, log, params, callback) {
+    log.trace({params: params}, 'listImageTagsV2: entry');
+
+    if (!Object.keys(params).length) {
+        params = '(config_digest=*)';
+    }
+
+    moray.listObjs({
+        filter: params,
+        log: log,
+        bucket: BUCKET,
+        model: ImageTag,
+        moray: app.moray
+    }, callback);
+}
+
+/**
+ * Deletes an image tag
+ */
+function deleteImageTag(app, log, params, callback) {
+    log.debug({params: params}, 'deleteImageTagV2: entry');
+    var key = objectKey(params);
+    moray.delObj(app.moray, BUCKET, key, callback);
+}
+
+
+/**
+ * Every funtion should just take care of replacing the column with a new
+ * value, or just return if it doesn't apply. When an updated object needs
+ * to be written every function should push a new item to the batch array.
+ */
+var migrations = [
+];
+
+
+/**
+ * Initializes the image tags bucket
+ */
+function initImageTagsBucket(app, callback) {
+    moray.initBucket(app.moray, BUCKET, function (err, updated, fromBucket) {
+        if (err) {
+            callback(err);
+            return;
+        }
+
+        // Run migrations when the bucket needed to be updated
+        if (updated) {
+            moray.migrateObjects({
+                app: app,
+                bucket: BUCKET,
+                fromBucket: fromBucket,
+                migrations: migrations
+            }, callback);
+        } else {
+            callback();
+        }
+    });
+}
+
+
+module.exports = {
+    create: createImageTag,
+    del: deleteImageTag,
+    init: initImageTagsBucket,
+    list: listImageTags,
+    ImageTag: ImageTag
+};
diff --git a/lib/models/image-v2.js b/lib/models/image-v2.js
new file mode 100644
index 0000000..7e7ec25
--- /dev/null
+++ b/lib/models/image-v2.js
@@ -0,0 +1,354 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+
+/*
+ * Image model v2
+ *
+ * `config_digest` the sha256 of the 'image JSON' (aka metadata).
+ * `head` false if it's an intermediate build layer (non referencable layer)
+ * `image_uuid` reference to the underlying layer (bits) - stored in IMGAPI.
+ * `manifest_digest` the sha256 of the 'manifest JSON'.
+ * `parent` reference to the parent docker config_digest
+ */
+
+var assert = require('assert-plus');
+var format = require('util').format;
+
+var moray = require('../moray');
+
+
+
+// --- Globals
+
+var BUCKET = {
+    desc: 'docker image v2',
+    name: 'docker_images_v2',
+    schema: {
+        index: {
+            config_digest: { type: 'string' },
+            head: { type: 'boolean' },
+            image_uuid: { type: 'string' },
+            manifest_digest: { type: 'string' },
+            owner_uuid: { type: 'string' },
+            parent: { type: 'string' }
+        }
+    },
+    version: 2
+};
+
+// The default docker image version this model uses.
+var DEFAULT_DOCKER_IMAGE_VERSION = '2.2';
+
+
+// --- Helpers
+
+function objectKey(params) {
+    assert.string(params.config_digest, 'params.config_digest');
+    assert.string(params.owner_uuid, 'params.owner_uuid');
+
+    return format('%s,%s', params.owner_uuid, params.config_digest);
+}
+
+
+// --- ImageV2 object
+
+
+/**
+ * ImageV2 model constructor
+ */
+function ImageV2(params) {
+    assert.object(params, 'image params');
+    assert.string(params.config_digest, 'params.config_digest');
+    assert.bool(params.head, 'params.head');
+    assert.object(params.image, 'params.image');
+    assert.string(params.image_uuid, 'params.image_uuid');
+    assert.string(params.manifest_digest, 'params.manifest_digest');
+    assert.string(params.manifest_str, 'params.manifest_str');
+    assert.optionalString(params.parent, 'params.parent');
+    assert.string(params.owner_uuid, 'params.owner_uuid');
+    assert.number(params.size, 'params.size');
+    assert.optionalString(params.dockerImageVersion,
+        'params.dockerImageVersion');
+
+    // Check that the image is correct.
+    var image = params.image;
+    assert.object(image.config, 'image.config');
+    assert.string(image.created, 'image.created');
+    assert.object(image.history, 'image.history');
+    assert.object(image.rootfs, 'image.rootfs');
+    // Optionals
+    assert.optionalString(image.architecture, 'image.architecture');
+    assert.optionalString(image.author, 'image.author');
+    assert.optionalString(image.comment, 'image.comment');
+    assert.optionalString(image.container, 'image.container');
+    assert.optionalObject(image.container_config, 'image.container_config');
+    assert.optionalString(image.docker_version, 'image.docker_version');
+    assert.optionalString(image.id, 'image.id');
+    assert.optionalString(image.os, 'image.os');
+    assert.optionalString(image.parent, 'image.parent');
+
+    // Params.parent must be set in order to get indexing on parent.
+    if (!params.parent && params.image.parent) {
+        params.parent = params.image.parent;
+    } else if (params.parent) {
+        assert.equal(params.parent, params.image.parent,
+            'image.parent should equal params.parent');
+    }
+    // Cleanup parent to ensure it's a string (not null or undefined), this is
+    // so we can later search/filter against an empty parent string.
+    if (!params.parent) {
+        params.parent = '';
+    }
+
+    if (!params.dockerImageVersion) {
+        params.dockerImageVersion = DEFAULT_DOCKER_IMAGE_VERSION;
+    }
+
+    // Validate digests.
+    assert.ok(params.config_digest.indexOf(':') >= 0,
+        'config_digest must include a colon, got ' + params.parent);
+
+    this.params = params;
+
+    // image.created is an ISO timestamp string: "2016-10-07T21:03:58.16783626Z"
+    // but some of the docker APIs use a unix timestamp (seconds since 1970), so
+    // we create a separate unix timestamp entry from the given ISO timestamp
+    // string.
+    this.params.created = Math.floor(
+        (new Date(this.params.image.created).getTime()) / 1000);
+
+    // Accessor for computing the moray object key
+    this.__defineGetter__('key', function () {
+        return objectKey(this.params);
+    });
+    this.__defineGetter__('config_digest', function () {
+        return this.params.config_digest;
+    });
+    this.__defineGetter__('head', function () {
+        return this.params.head;
+    });
+    this.__defineGetter__('image', function () {
+        return this.params.image;
+    });
+    this.__defineGetter__('image_uuid', function () {
+        return this.params.image_uuid;
+    });
+    this.__defineGetter__('manifest_str', function () {
+        return this.params.manifest_str;
+    });
+    this.__defineGetter__('manifest_digest', function () {
+        return this.params.manifest_digest;
+    });
+    this.__defineGetter__('owner_uuid', function () {
+        return this.params.owner_uuid;
+    });
+    this.__defineGetter__('size', function () {
+        return this.params.size;
+    });
+    this.__defineGetter__('dockerImageVersion', function () {
+        return this.params.dockerImageVersion;
+    });
+
+    // Backwards compat for older image code.
+    this.__defineGetter__('author', function () {
+        return this.params.image.author;
+    });
+    this.__defineGetter__('architecture', function () {
+        return this.params.image.architecture;
+    });
+    this.__defineGetter__('comment', function () {
+        return this.params.image.comment;
+    });
+    this.__defineGetter__('config', function () {
+        // Warning: `config` can be null on base Docker images.
+        return this.params.image.config;
+    });
+    this.__defineGetter__('container_config', function () {
+        return this.params.image.container_config;
+    });
+    this.__defineGetter__('created', function () {
+        return this.params.created;
+    });
+    this.__defineGetter__('createdISOString', function () {
+        return this.params.image.created;
+    });
+    this.__defineGetter__('docker_version', function () {
+        return this.params.image.docker_version;
+    });
+    this.__defineGetter__('history', function () {
+        return this.params.image.history;
+    });
+    this.__defineGetter__('parent', function () {
+        return this.params.image.parent;
+    });
+    this.__defineGetter__('private', function () {
+        return false;
+    });
+    this.__defineGetter__('rootfs', function () {
+        return this.params.image.rootfs;
+    });
+}
+
+
+/**
+ * Returns the raw form of the image suitable for storing in moray,
+ * which is the same as the serialized form
+ */
+ImageV2.prototype.toJSON =
+    ImageV2.prototype.raw =
+    ImageV2.prototype.serialize =
+    function ()
+{
+    return {
+        config_digest: this.params.config_digest,
+        created: this.params.created,
+        head: this.params.head,
+        image: this.params.image,
+        image_uuid: this.params.image_uuid,
+        manifest_str: this.params.manifest_str,
+        manifest_digest: this.params.manifest_digest,
+        parent: this.params.parent,
+        owner_uuid: this.params.owner_uuid,
+        size: this.params.size,
+        dockerImageVersion: this.params.dockerImageVersion
+    };
+};
+
+
+
+// --- Exported functions
+
+/**
+ * Creates a image
+ */
+function createImage(app, log, params, callback) {
+    log.debug({ params: params }, 'createImageV2: entry');
+
+    var image = new ImageV2(params);
+    app.moray.putObject(BUCKET.name, image.key, image.raw(), function (err) {
+        if (err) {
+            return callback(err);
+        }
+
+        return callback(null, image);
+    });
+}
+
+
+/**
+ * Lists all images
+ */
+function listImages(app, log, params, callback) {
+    log.debug({params: params}, 'listImagesV2: entry');
+
+    if (!Object.keys(params).length) {
+        params = '(config_digest=*)';
+    }
+
+    moray.listObjs({
+        filter: params,
+        log: log,
+        bucket: BUCKET,
+        model: ImageV2,
+        moray: app.moray
+    }, callback);
+}
+
+
+/**
+ * Updates an image
+ */
+function updateImage(app, log, params, callback) {
+    log.debug({params: params}, 'updateImageV2: entry');
+    var key = objectKey(params);
+    moray.updateObj({
+        moray: app.moray,
+        bucket: BUCKET,
+        key: key,
+        val: params
+    }, function (err, rec) {
+        if (err) {
+            return callback(err);
+        }
+
+        return callback(null, new ImageV2(rec.value));
+    });
+}
+
+
+/**
+ * Deletes an image
+ */
+function deleteImage(app, log, params, callback) {
+    log.debug({params: params}, 'deleteImageV2: entry');
+    var key = objectKey(params);
+    moray.delObj(app.moray, BUCKET, key, callback);
+}
+
+
+/**
+ * Gets an image.
+ */
+function getImage(app, log, params, callback) {
+    log.debug({params: params}, 'getImage: entry');
+    var key = objectKey(params);
+    moray.getObj(app.moray, BUCKET, key, function (err, rawImg) {
+        if (err) {
+            callback(err);
+            return;
+        }
+        callback(null, new ImageV2(rawImg.value));
+    });
+}
+
+
+/**
+ * Every funtion should just take care of replacing the column with a new
+ * value, or just return if it doesn't apply. When an updated object needs
+ * to be written every function should push a new item to the batch array.
+ */
+var migrations = [
+];
+
+
+/**
+ * Initializes the images bucket.
+ */
+function initImagesBucket(app, callback) {
+    moray.initBucket(app.moray, BUCKET, function (err, updated, fromBucket) {
+        if (err) {
+            callback(err);
+            return;
+        }
+
+        // Run migrations when the bucket needs to be updated.
+        if (updated) {
+            moray.migrateObjects({
+                app: app,
+                bucket: BUCKET,
+                fromBucket: fromBucket,
+                migrations: migrations
+            }, callback);
+        } else {
+            callback();
+        }
+    });
+}
+
+
+module.exports = {
+    create: createImage,
+    del: deleteImage,
+    get: getImage,
+    init: initImagesBucket,
+    list: listImages,
+    ImageV2: ImageV2,
+    update: updateImage
+};
diff --git a/lib/models/image.js b/lib/models/image.js
index b0dab77..a707587 100644
--- a/lib/models/image.js
+++ b/lib/models/image.js
@@ -5,21 +5,20 @@
  */
 
 /*
- * Copyright (c) 2015, Joyent, Inc.
+ * Copyright (c) 2017, Joyent, Inc.
  */
 
 /*
- * image model
+ * The (old - v1) image model.
+ *
+ * Note that this model is deprecated, new images should use the
+ * ImageV2 model in './image-v2.js'.
  */
 
 var assert = require('assert-plus');
 var format = require('util').format;
-var imgmanifest = require('imgmanifest');
 var once = require('once');
-var util = require('util');
-var vasync = require('vasync');
 
-var ImageTag = require('./image-tag');
 var moray = require('../moray');
 
 
@@ -123,6 +122,9 @@ function Image(params) {
     this.__defineGetter__('created', function () {
         return this.params.created;
     });
+    this.__defineGetter__('createdISOString', function () {
+        return new Date(this.params.created * 1000).toISOString();
+    });
     this.__defineGetter__('docker_id', function () {
         return this.params.docker_id;
     });
@@ -186,21 +188,6 @@ Image.prototype.toJSON =
 };
 
 
-Image.prototype.toHistoryItem = function toHistoryItem() {
-    var createdBy = '';
-    if (this.container_config && this.container_config.Cmd) {
-        createdBy = this.container_config.Cmd.join(' ');
-    }
-    var created = Math.floor((new Date(this.created)).getTime() / 1000);
-    return {
-        Id: this.docker_id,
-        Created: created,
-        CreatedBy: createdBy,
-        Size: this.size
-    };
-};
-
-
 
 // --- Exported functions
 
@@ -385,103 +372,7 @@ function imageCount(app, log, params, callback) {
  * value, or just return if it doesn't apply. When an updated object needs
  * to be written every function should push a new item to the batch array.
  */
-var migrations = [
-    {
-        fn: _addIndexName,
-        version: 2
-    },
-    {
-        fn: _updateImageUuids,
-        version: 3
-    },
-    {
-        fn: _updateKeysPrivateRegistries,
-        version: 4
-    }
-];
-
-
-/*
- * This migration will populate the index_name column values. We cheat here
- * knowing that before this migration the only index_name from which
- * pulls were supported was 'docker.io' -- so use that value.
- */
-function _addIndexName(opts) {
-    assert.object(opts, 'opts');
-
-    var batch = opts.batch;
-    var key = opts.key;
-    var value = opts.value;
-
-    if (value.index_name !== undefined) {
-        return;
-    }
-
-    value.index_name = 'docker.io';
-    batch.push({
-        bucket: BUCKET.name,
-        key: key,
-        value: value
-    });
-}
-
-
-/*
- * This migration will update the image_uuid values on every docker_image
- *   with a new UUID computed from docker_id and index_name
- */
-function _updateImageUuids(opts) {
-    assert.object(opts, 'opts');
-
-    var batch = opts.batch;
-    var key = opts.key;
-    var value = opts.value;
-
-    var uuid = imgmanifest.imgUuidFromDockerInfo({
-        id: value.docker_id,
-        indexName: value.index_name
-    });
-    value.image_uuid = uuid;
-
-    batch.push({
-        bucket: BUCKET.name,
-        key: key,
-        value: value
-    });
-}
-
-
-/*
- * This migration will update all object keys from
- *   owner_uuid-docker_id to owner_uuid-index_name-docker_id
- */
-function _updateKeysPrivateRegistries(opts) {
-    assert.object(opts, 'opts');
-
-    var batch = opts.batch;
-    var key = opts.key;
-    var value = opts.value;
-
-    // Ignore every object that was already migrated.
-    if (key.split('-').length > 6) {
-        return;
-    }
-
-    // TODO Image.prototype.key
-    var newKey = format('%s-%s-%s', value.owner_uuid,
-        value.index_name, value.docker_id);
-
-    // Add new object and delete old one
-    batch.push({
-        bucket: BUCKET.name,
-        key: newKey,
-        value: value
-    }, {
-        bucket: BUCKET.name,
-        operation: 'delete',
-        key: key
-    });
-}
+var migrations = [];
 
 
 /**
diff --git a/lib/models/index.js b/lib/models/index.js
index a77e086..a03b0fb 100644
--- a/lib/models/index.js
+++ b/lib/models/index.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2014, Joyent, Inc.
+ * Copyright (c) 2017, Joyent, Inc.
  */
 
 /*
@@ -14,6 +14,8 @@
 
 var image = require('./image');
 var image_tag = require('./image-tag');
+var image_v2 = require('./image-v2');
+var image_tag_v2 = require('./image-tag-v2');
 var link = require('./link');
 var vasync = require('vasync');
 
@@ -31,6 +33,8 @@ function initializeModels(app, callback) {
         inputs: [
             image,
             image_tag,
+            image_v2,
+            image_tag_v2,
             link
         ],
         func: function _initModel(mod, cb) {
diff --git a/lib/wfapi/index.js b/lib/wfapi/index.js
index 480e960..c8a7767 100644
--- a/lib/wfapi/index.js
+++ b/lib/wfapi/index.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2014, Joyent, Inc.
+ * Copyright (c) 2017, Joyent, Inc.
  */
 
 /*
@@ -136,14 +136,13 @@ Wfapi.prototype.ping = function (callback) {
 };
 
 
-
 /*
- * Queues a pull-image job.
+ * Queues a pull-image-v2 job.
  *
  * @param options {Object} Required.
  * @param cb {Function} `function (err, jobUuid)`
  */
-Wfapi.prototype.createPullImageJob = function (options, cb) {
+Wfapi.prototype.createPullImageV2Job = function (options, cb) {
     var self = this;
     assert.object(options, 'options');
     assert.object(options.rat, 'options.rat');
@@ -153,8 +152,8 @@ Wfapi.prototype.createPullImageJob = function (options, cb) {
     assert.optionalString(options.regConfig, 'opts.regConfig');
 
     var params = {
-        task: 'pull-image',
-        target: format('/pull-image-%s', options.rat.canonicalName),
+        task: 'pull-image-v2',
+        target: format('/pull-image-v2-%s', options.rat.canonicalName),
         rat: options.rat,
         req_id: options.req_id,
         account_uuid: options.account.uuid,
@@ -168,7 +167,7 @@ Wfapi.prototype.createPullImageJob = function (options, cb) {
             return cb(err);
         }
         params.job_uuid = job.uuid;
-        self.log.debug(params, 'Pull image job params');
+        self.log.debug(params, 'Pull image v2 job params');
         return cb(null, job.uuid);
     });
 };
diff --git a/lib/wfapi/workflows/pull-image.js b/lib/wfapi/workflows/pull-image-v2.js
similarity index 60%
rename from lib/wfapi/workflows/pull-image.js
rename to lib/wfapi/workflows/pull-image-v2.js
index cbae6ba..1d17dcf 100644
--- a/lib/wfapi/workflows/pull-image.js
+++ b/lib/wfapi/workflows/pull-image-v2.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright 2016, Joyent, Inc.
+ * Copyright 2017, Joyent, Inc.
  */
 
 
@@ -20,9 +20,9 @@ var urlModule;
 var imgapiUrl;
 var dockerUrl;
 
-var VERSION = '1.4.3';
+var VERSION = '1.0.0';
 
-function pullImageLayers(job, cb) {
+function pullImageLayersV2(job, cb) {
     var queue = vasync.queue(processMessage, 5);
     var queueError;
 
@@ -34,10 +34,9 @@ function pullImageLayers(job, cb) {
         url: dockerAdminiUrl,
         headers: { 'x-request-id': job.params.req_id }
     });
+    var imageCreated = false;
     var imgapi = new sdcClients.IMGAPI({url: imgapiUrl});
 
-    var virtualSize = 0;
-
     function processMessage(data, next) {
         if (data.type == 'error') {
             /*
@@ -49,11 +48,8 @@ function pullImageLayers(job, cb) {
                 queueError.name = data.error.code;
             }
             next();
-        } else if (data.type === 'data') {
+        } else if (data.type === 'create-docker-image') {
             createDockerImage(data, next);
-        } else if (data.type === 'head') {
-            job.params.head = data.head;
-            next();
         } else {
             // type 'progress' or 'status'
             if (data.type == 'progress'
@@ -64,30 +60,20 @@ function pullImageLayers(job, cb) {
         }
     }
 
-    // Inside this function we verify if the layer was already refcounted
-    // by this head image before. The idea is that we want to track how
-    // many head images are have a reference to this layer and when there
-    // are no more references to it we can safely remove it from the bucket
-    // when `docker rmi` is called
     function createDockerImage(data, next) {
-        assert.object(data.imgJson, 'data.imgJson');
-        assert.object(data.image, 'data.image');
-        assert.bool(data.private, 'data.private');
-
-        var imgJson = data.imgJson;
-        var imgId = imgJson.id;
+        assert.string(data.config_digest, 'data.config_digest');
 
-        var size = imgJson.Size || 0;
-        virtualSize += size;
+        job.log.info('createDockerImage:: data: %s', JSON.stringify(data));
 
         var query = {
             owner_uuid: job.params.account_uuid,
-            index_name: job.params.rat.index.name,
-            docker_id: imgId
+            config_digest: data.config_digest
         };
+        // Remeber the digest for tagging.
+        job.params.config_digest = data.config_digest;
 
         dockerAdmin.get({
-            path: '/admin/images',
+            path: '/admin/images_v2',
             query: query
         }, function (err, req, res, images) {
             if (err) {
@@ -95,62 +81,36 @@ function pullImageLayers(job, cb) {
                 return;
             }
 
-            var action;
-            var heads;
-
-            if (images.length) {
-                // Layer already exists:
-                // 1) check if this pull is already refcounted and return
-                // 2) update the refcount for this image
-                var image = images[0];
-                if (image.heads.indexOf(job.params.head) !== -1) {
-                    next();
-                    return;
-                }
-
-                action = 'update';
-                image.heads.push(job.params.head);
-                heads = image.heads;
-            } else {
-                action = 'create';
-                heads = [ job.params.head ];
-            }
-
-            var layer = {
-                author: imgJson.author,
-                created: new Date(imgJson.created).getTime(),
-                docker_id: imgId,
-                heads: heads,
-                image_uuid: data.image.uuid,
-                index_name: job.params.rat.index.name,
-                owner_uuid: job.params.account_uuid,
-                size: size,
-                virtual_size: virtualSize,
-                private: data.private
-            };
-
-            if (imgJson.container_config) {
-                layer.container_config = imgJson.container_config;
-            }
-            if (imgJson.config) {
-                layer.config = imgJson.config;
-            }
-            if (imgJson.parent) {
-                layer.parent = imgJson.parent;
-            }
-            if (job.params.head === imgId) {
-                layer.head = true;
+            if (images && images.length > 0) {
+                // Image with this digest already exists - no need to update, if
+                // they have the same digest then they have the same content.
+                job.log.debug({config_digest: data.config_digest},
+                    'createDockerImage:: image already exists');
+                imageCreated = true;
+                next();
+                return;
             }
 
-            var path = '/admin/images?action=' + action;
-            dockerAdmin.post(path, layer, next);
+            var path = '/admin/images_v2?action=create';
+            data.owner_uuid = job.params.account_uuid;
+            dockerAdmin.post(path, data, function (adminErr) {
+                if (adminErr) {
+                    job.log.error({config_digest: data.config_digest},
+                        'createDockerImage:: error: %s', adminErr);
+                } else {
+                    imageCreated = true;
+                    job.log.debug({config_digest: data.config_digest},
+                        'createDockerImage:: image created');
+                }
+                next(err);
+            });
         });
     }
 
     var opts = {
         repo: job.params.rat.canonicalName,
         tag: job.params.rat.tag,
-        digest: job.params.rat.digest,
+        config_digest: job.params.rat.digest,
         regAuth: job.params.regAuth,
         regConfig: job.params.regConfig,
         /*
@@ -177,11 +137,8 @@ function pullImageLayers(job, cb) {
 
         lstream.on('readable', function () {
             var line;
-            while ((line = lstream.read()) != null) {
-                line = line.trim();
-
-                var data = JSON.parse(line);
-                queue.push(data);
+            while ((line = lstream.read()) !== null) {
+                queue.push(JSON.parse(line));
             }
         });
 
@@ -192,6 +149,11 @@ function pullImageLayers(job, cb) {
             queue.on('end', function () {
                 if (queueError) {
                     cb(queueError);
+                } else if (!imageCreated) {
+                    // If there was no error, yet there was no image created,
+                    // then there must have been a timeout (i.e. connection was
+                    // closed abruptly), so fire the callback with an error.
+                    cb(new Error('pullImageLayers failed - timeout'));
                 } else {
                     cb(null, 'pullImageLayers completed');
                 }
@@ -202,8 +164,7 @@ function pullImageLayers(job, cb) {
     });
 }
 
-function tagHeadImage(job, cb) {
-    // TODO(DOCKER-584): handle digest when supporting that.
+function tagImageV2(job, cb) {
     if (!job.params.rat.tag) {
         cb(null, 'No tag for head image');
         return;
@@ -218,13 +179,12 @@ function tagHeadImage(job, cb) {
 
     var data = {
         owner_uuid: job.params.account_uuid,
-        index_name: job.params.rat.index.name,
         repo: job.params.rat.localName,
         tag: job.params.rat.tag,
-        docker_id: job.params.head
+        config_digest: job.params.config_digest
     };
 
-    dockerAdmin.post('/admin/image_tags', data, function (createErr) {
+    dockerAdmin.post('/admin/image_tags_v2', data, function (createErr) {
         if (createErr) {
             cb(createErr);
             return;
@@ -236,13 +196,13 @@ function tagHeadImage(job, cb) {
 
 
 var workflow = module.exports = {
-    name: 'pull-image-' + VERSION,
+    name: 'pull-image-v2-' + VERSION,
     version: VERSION,
     chain: [ {
-        name: 'pull_image_layers',
+        name: 'pull_image_v2_layers',
         timeout: 3600,
         retry: 1,
-        body: pullImageLayers,
+        body: pullImageLayersV2,
         modules: {
             assert: 'assert-plus',
             LineStream: 'lstream',
@@ -252,10 +212,10 @@ var workflow = module.exports = {
             vasync: 'vasync'
         }
     }, {
-        name: 'tag_head_image',
+        name: 'tag_image_v2',
         timeout: 20,
         retry: 1,
-        body: tagHeadImage,
+        body: tagImageV2,
         modules: {
             restify: 'restify',
             urlModule: 'url'
diff --git a/package.json b/package.json
index 8d461e0..5e2c2f4 100644
--- a/package.json
+++ b/package.json
@@ -10,9 +10,10 @@
     "bunyan": "1.8.8",
     "effluent-logger": "git+https://github.com/joshwilsdon/effluent-logger.git#d662f161a07f94045ad2afb45442931511c40e51",
     "fwrule": "git+https://github.com/joyent/sdc-fwrule.git#d1174be",
-    "imgmanifest": "git+https://github.com/joyent/node-imgmanifest.git#91e5d80",
+    "imgmanifest": "git+https://github.com/joyent/node-imgmanifest.git#b2e47b96e588a811ad36725fb138530efc0e4ff4",
     "keyapi": "git+https://github.com/joyent/keyapi.git#e14b3d5",
     "libuuid": "0.2.1",
+    "jsprim": "1.3.1",
     "lru-cache": "2.5.0",
     "lstream": "0.0.4",
     "moray": "2.0.0",
diff --git a/sapi_manifests/docker/template b/sapi_manifests/docker/template
index 1bfa4b0..652cf95 100644
--- a/sapi_manifests/docker/template
+++ b/sapi_manifests/docker/template
@@ -54,7 +54,7 @@
     },
     "wfapi": {
         "forceMd5Check": true,
-        "workflows": ["pull-image"],
+        "workflows": ["pull-image-v2"],
         "url": "http://workflow.{{{datacenter_name}}}.{{{dns_domain}}}"
     },
 
diff --git a/test/integration/api-build.test.js b/test/integration/api-build.test.js
index 5ccd8d3..37241c0 100644
--- a/test/integration/api-build.test.js
+++ b/test/integration/api-build.test.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2016, Joyent, Inc.
+ * Copyright (c) 2017, Joyent, Inc.
  */
 
 /*
@@ -19,11 +19,13 @@
 var format = require('util').format;
 var path = require('path');
 
+var assert = require('assert-plus');
 var tar = require('tar-stream');
 var test = require('tape');
 var vasync = require('vasync');
 
 var h = require('./helpers');
+var imageV2 = require('../../lib/models/image-v2');
 
 var STATE = {
     log: require('../lib/log')
@@ -32,6 +34,8 @@ var STATE = {
 var ALICE;
 var DOCKER_ALICE; // Regular JSON restify client.
 var DOCKER_ALICE_HTTP; // For sending non-JSON payload
+var imgapiClient;
+var morayClient;
 
 
 function createTarStream(fileAndContents) {
@@ -59,6 +63,22 @@ test('setup', function (tt) {
         });
     });
 
+    tt.test('imgapi client init', function (t) {
+        h.createImgapiClient(function (err, client) {
+            t.ifErr(err, 'imgapi client init');
+            imgapiClient = client;
+            t.end();
+        });
+    });
+
+    tt.test('moray client init', function (t) {
+        h.createMorayClient(function (err, client) {
+            t.ifErr(err, 'moray client init');
+            morayClient = client;
+            t.end();
+        });
+    });
+
     tt.test('docker client init', function (t) {
         vasync.parallel({ funcs: [
             function createAliceHttp(done) {
@@ -292,7 +312,7 @@ test('api: build image conflicts', function (tt) {
 
 
 /**
- * DOCKER-748: Cannot build an image that references multiple registries.
+ * DOCKER-756: Ensure can build an image that references multiple registries.
  */
 test('api: build across multiple registries', function (tt) {
     var imageName = 'quay.io/joyent/triton_alpine_inherit_test:latest';
@@ -310,6 +330,7 @@ test('api: build across multiple registries', function (tt) {
     });
 
     tt.test('docker build from alpine image (cross registry)', function (t) {
+        var dockerImageId;
         var tarStream;
 
         vasync.waterfall([
@@ -335,13 +356,24 @@ test('api: build across multiple registries', function (tt) {
 
                 function onbuild(err, result) {
                     t.ifErr(err, 'build should not error on post');
-                    var msg = result.body;
-                    if (msg.indexOf('different registries') === -1) {
-                        t.fail('expected a "different registries" error '
-                            + 'message, got: "' + msg + '"');
+                    var output = result.body;
+
+                    var hasSuccess = output.indexOf('Successfully built') >= 0;
+                    t.ok(hasSuccess,
+                        'output should contain: Successfully built');
+                    if (hasSuccess) {
+                        var reg = new RegExp('Successfully built (\\w+)');
+                        dockerImageId = output.match(reg)[1];
+                    } else {
+                        t.fail('Output: ' + output);
                     }
                     next();
                 }
+            },
+
+            function removeBuiltImage(next) {
+                t.ok(dockerImageId, 'Got the docker image id');
+                DOCKER_ALICE.del('/images/' + dockerImageId, next);
             }
 
         ], function allDone(err) {
@@ -530,3 +562,209 @@ test('build with packagelabel', function (tt) {
         tt.end();
     });
 });
+
+
+/**
+ * This test ensures that `docker rmi` is working, by checking the underlying
+ * IMGAPI docker layer count and sdc-docker docker_images_v2 count before and
+ * after deletion.
+ */
+test('api: build and rmi', function (tt) {
+    // Ensure busybox image is pulled down.
+    tt.test('pull busybox image', function (t) {
+        h.ensureImage({
+            name: 'busybox',
+            user: ALICE
+        }, function (err) {
+            t.error(err, 'pulling busybox image');
+            t.end();
+        });
+    });
+
+    tt.test('docker build test image', function (t) {
+        var currentDockerImages;
+        var dockerImageCountBefore;
+        var dockerImageId = null;
+        var imgapiLayerCountBefore;
+        var tarStream;
+
+        // Count the number of IMGAPI docker layers.
+        function getImgapiDockerLayerCount(cb) {
+            assert.object(imgapiClient, 'imgapiClient');
+            // Note that there is no owner set here, as IMGAPI docker layers are
+            // all owned by the ADMIN user.
+            var filter = {
+                state: 'active',
+                type: 'docker'
+            };
+
+            imgapiClient.listImages(filter, function (err, layers) {
+                t.ifErr(err, 'check for imgapi listImages err');
+                cb(err, layers && layers.length || 0);
+            });
+        }
+
+        // Count the number of docker_images_v2 image models.
+        function getDockerImageCount(cb) {
+            assert.object(morayClient, 'morayClient');
+            var app = {
+                moray: morayClient
+            };
+            var filter = {
+                owner_uuid: ALICE.account.uuid
+            };
+
+            imageV2.list(app, STATE.log, filter, function (err, images) {
+                t.ifErr(err, 'check for imgapi listImages err');
+                currentDockerImages = images;
+                cb(err, images && images.length || 0);
+            });
+        }
+
+        vasync.pipeline({ funcs: [
+
+            function createTar(_, next) {
+                var fileAndContents = {
+                    'Dockerfile': 'FROM busybox\n'
+                                + 'LABEL rc1=true\n'
+                                + 'LABEL rc2=true\n'
+                                + 'ADD a.txt /\n'
+                                + 'LABEL rc3=true\n'
+                                + 'LABEL rc4=true\n',
+                    'a.txt': 'This is a.txt content'
+                };
+
+                tarStream = createTarStream(fileAndContents);
+                next();
+            },
+
+            function getImgapiLayerCountBefore(_, next) {
+                getImgapiDockerLayerCount(function (err, cnt) {
+                    // Remember the number of IMGAPI docker layers.
+                    imgapiLayerCountBefore = cnt;
+                    next(err);
+                });
+            },
+
+            function getDockerImageCountBefore(_, next) {
+                getDockerImageCount(function (err, cnt) {
+                    // Remember the number of docker images.
+                    dockerImageCountBefore = cnt;
+                    next(err);
+                });
+            },
+
+            function buildContainer(_, next) {
+                h.buildDockerContainer({
+                    dockerClient: DOCKER_ALICE_HTTP,
+                    params: {
+                        'nocache': 'true',
+                        'rm': 'true'  // Remove container after it's built.
+                    },
+                    test: t,
+                    tarball: tarStream
+                }, onbuild);
+
+                function onbuild(err, result) {
+                    t.ifError(err, 'check build err');
+                    if (!result || !result.body) {
+                        next(new Error('build generated no output!?'));
+                        return;
+                    }
+
+                    var output = result.body;
+                    var hasSuccess = output.indexOf('Successfully built') >= 0;
+
+                    t.ok(hasSuccess, 'output contains Successfully built');
+                    if (hasSuccess) {
+                        var reg = new RegExp('Successfully built (\\w+)');
+                        dockerImageId = output.match(reg)[1];
+                    } else {
+                        next(new Error('Unsuccessful build: ' + output));
+                        return;
+                    }
+
+                    next();
+                }
+            },
+
+            function getImgapiLayerCountAfterBuild(_, next) {
+                getImgapiDockerLayerCount(function (err, cnt) {
+                    t.equal(cnt, imgapiLayerCountBefore + 1,
+                        'check 1 new IMGAPI docker layer was created');
+                    next(err);
+                });
+            },
+
+            function getDockerImageCountAfterBuild(_, next) {
+                getDockerImageCount(function (err, cnt) {
+                    t.equal(cnt, dockerImageCountBefore + 5,
+                        'check 5 docker_images_v2 entries were created');
+                    next(err);
+                });
+            },
+
+            // Try removing the parent image of the just built image, there
+            // should be a failure as the built image depends on this image
+            // and won't let us delete it.
+            function checkRemoveDependentParentImage(_, next) {
+                t.ok(currentDockerImages, 'Have list of docker images');
+                var matchingImages = currentDockerImages.filter(function (img) {
+                    return img.config_digest.indexOf(dockerImageId) >= 0;
+                });
+                t.equal(matchingImages.length, 1, 'found built docker image');
+                var parentId = matchingImages[0].parent;
+                DOCKER_ALICE.del('/images/' + parentId, function (err) {
+                    t.ok(err, 'expect an error for docker rmi parentId');
+                    console.log('err:', err);
+                    console.log('err.message:', err.message);
+                    if (!err) {
+                        next(new Error('docker rmi parentId succeeded - '
+                            + 'when it should have failed'));
+                        return;
+                    }
+                    next();
+                });
+            },
+
+            function removeBuiltImage(_, next) {
+                DOCKER_ALICE.del('/images/' + dockerImageId,
+                    function (err) {
+                        t.ifErr(err, 'check for docker rmi error');
+                        next(err);
+                    });
+            },
+
+            function getImgapiLayerCountAfterRmi(_, next) {
+                getImgapiDockerLayerCount(function (err, cnt) {
+                    t.equal(cnt, imgapiLayerCountBefore,
+                        'check all built imgapi layers were deleted');
+                    next(err);
+                });
+            },
+
+            function getDockerImageCountAfterRmi(_, next) {
+                getDockerImageCount(function (err, cnt) {
+                    t.equal(cnt, dockerImageCountBefore,
+                        'check created docker_images_v2 entries are gone');
+                    next(err);
+                });
+            }
+
+        ]}, function allDone(err) {
+            t.ifErr(err);
+            t.end();
+        });
+    });
+});
+
+
+test('teardown', function (tt) {
+    if (imgapiClient) {
+        imgapiClient.close();
+    }
+    if (morayClient) {
+        morayClient.close();
+    }
+    tt.end();
+});
diff --git a/test/integration/api-images-v1-v2.test.js b/test/integration/api-images-v1-v2.test.js
new file mode 100644
index 0000000..dd4e527
--- /dev/null
+++ b/test/integration/api-images-v1-v2.test.js
@@ -0,0 +1,493 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+
+/*
+ * Test docker images that use v1, v2 or both v1/v2 docker image buckets.
+ */
+
+var path = require('path');
+var util = require('util');
+
+var assert = require('assert-plus');
+var drc = require('docker-registry-client');
+var imgmanifest = require('imgmanifest');
+var libuuid = require('libuuid');
+var test = require('tape');
+var vasync = require('vasync');
+
+var h = require('./helpers');
+var imageV1Model = require('../../lib/models/image');
+var imageV2Model = require('../../lib/models/image-v2');
+var imageTagV1Model = require('../../lib/models/image-tag');
+var log = require('../lib/log');
+
+
+// --- Globals
+
+var ALICE;
+var DOCKER_ALICE;
+var gInitSuccessful = false;
+var gV1Image;
+var gV1ImageName = 'joyentunsupported/busybox_with_label_test_v1';
+var gV2Image;
+var gV2ImageName = 'joyentunsupported/busybox_with_label_test';
+var imgapiClient;
+var morayClient;
+var STATE = {
+    log: log
+};
+
+
+// --- Tests
+
+
+test('setup', function (tt) {
+
+    tt.test('docker env', function (t) {
+        h.initDockerEnv(t, STATE, {}, function (err, accounts) {
+            t.ifErr(err);
+            ALICE = accounts.alice;
+            t.end();
+        });
+    });
+
+    tt.test('docker client init', function (t) {
+        h.createDockerRemoteClient({user: ALICE}, function (err, client) {
+            t.ifErr(err, 'docker client init');
+            DOCKER_ALICE = client;
+            t.end();
+        });
+    });
+
+    tt.test('imgapi client init', function (t) {
+        h.createImgapiClient(function (err, client) {
+            t.ifErr(err, 'imgapi client init');
+            imgapiClient = client;
+            t.end();
+        });
+    });
+
+    tt.test('moray client init', function (t) {
+        h.createMorayClient(function (err, client) {
+            t.ifErr(err, 'moray client init');
+            morayClient = client;
+            t.end();
+        });
+    });
+});
+
+
+/**
+ * Create v1 and v2 docker images.
+ *
+ * To test a v2 image, we simply docker pull it.
+ * To test a v1 image, we need to jump through some hoops:
+ *  - manually create the IMGAPI image/file
+ *  - manually create the v1 image model (docker_images bucket)
+ */
+test('init docker images', function (tt) {
+    var app = {
+        moray: morayClient
+    };
+
+    tt.test('pull v2 busybox_with_label_test image', function (t) {
+        h.ensureImage({
+            name: gV2ImageName,
+            user: ALICE
+        }, function (err) {
+            t.error(err, 'should be no error pulling image');
+            t.end();
+        });
+    });
+
+    tt.test('inspect v2 image', function (t) {
+        var url = '/images/' + encodeURIComponent(gV2ImageName) + '/json';
+        DOCKER_ALICE.get(url, function (err, req, res, img) {
+            t.error(err, 'get v2 image');
+            gV2Image = img;
+            t.end();
+        });
+    });
+
+    tt.test('create v1 test image', function (t) {
+        var imageUuid = libuuid.create();
+        var dockerId = (imageUuid + imageUuid).replace(/-/g, '');
+
+        // This is actual busybox config pulled from a working v1 manatee.
+        var v1ModelParams = {
+            author: '',
+            architecture: '',
+            comment: '',
+            created: 1497559350659,
+            config: {
+                Hostname: 'c673fc810c50',
+                Domainname: '',
+                User: '',
+                AttachStdin: false,
+                AttachStdout: false,
+                AttachStderr: false,
+                Tty: false,
+                OpenStdin: false,
+                StdinOnce: false,
+                Env: ['PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:'
+                    + '/usr/bin:/sbin:/bin'],
+                Cmd: ['sh'],
+                ArgsEscaped: true,
+                Image: '',
+                Volumes: null,
+                WorkingDir: '',
+                Entrypoint: null,
+                OnBuild: null,
+                Labels: {}
+            },
+            container_config: {
+                Hostname: 'c673fc810c50',
+                Domainname: '',
+                User: '',
+                AttachStdin: false,
+                AttachStdout: false,
+                AttachStderr: false,
+                Tty: false,
+                OpenStdin: false,
+                StdinOnce: false,
+                Env: ['PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:'
+                    + '/usr/bin:/sbin:/bin'],
+                Cmd: ['/bin/sh', '-c', '#(nop) ', 'CMD [\'sh\']'],
+                ArgsEscaped: true,
+                Image: '',
+                Volumes: null,
+                WorkingDir: '',
+                Entrypoint: null,
+                OnBuild: null,
+                Labels: {}
+            },
+            docker_id: dockerId,
+            head: true,
+            image_uuid: imageUuid,
+            index_name: 'docker.io',
+            os: 'linux',
+            owner_uuid: ALICE.account.uuid,
+            private: false,
+            heads: [dockerId],
+            size: 0,
+            virtual_size: 0
+        };
+
+        vasync.pipeline({arg: {}, funcs: [
+            sdcDockerGetV2ImageModel,
+            determineLayerImageUuid,
+            imgapiGetExistingImage,
+            imgapiGetExistingImageFileStream,
+            imgapiCreateImage,
+            imgapiImportImageFile,
+            imgapiActivateImage,
+            sdcDockerCreateV1Model,
+            sdcDockerCreateV1ModelTag
+        ]}, function (err) {
+            t.error(err, 'should be no error creating v1 IMGAPI image');
+            if (!err) {
+                gInitSuccessful = true;
+            }
+            t.end();
+        });
+
+        function sdcDockerGetV2ImageModel(ctx, next) {
+            var params = {
+                config_digest: gV2Image.Id,
+                owner_uuid: ALICE.account.uuid
+            };
+            imageV2Model.get(app, log, params, function (err, img) {
+                ctx.v2ModelInst = img;
+                next(err);
+            });
+        }
+
+        function determineLayerImageUuid(ctx, next) {
+            // Work out which layer of the v2 image has the file content. We
+            // look for the layer which has a size greater than 32, as 32 size
+            // means an empty layer.
+            assert.object(ctx.v2ModelInst);
+            assert.string(ctx.v2ModelInst.manifest_str);
+
+            var manifest = JSON.parse(ctx.v2ModelInst.manifest_str);
+            var layerIdx;
+            var contentLayers = manifest.layers.filter(function (layer, idx) {
+                if (layer.size > 32) {
+                    layerIdx = idx;
+                    return true;
+                }
+                return false;
+            });
+            if (contentLayers.length !== 1) {
+                next(new Error('Expected 1 layer with size > 32, got '
+                    + contentLayers.length));
+                return;
+            }
+            var digestChain = manifest.layers.slice(0, layerIdx).map(
+                function (layer) {
+                    return layer.digest;
+                }
+            );
+            ctx.layerImageUuid = imgmanifest.imgUuidFromDockerDigests(
+                digestChain);
+
+            next();
+        }
+
+        function imgapiGetExistingImage(ctx, next) {
+            log.debug('getting image from IMGAPI');
+            imgapiClient.getImage(ctx.layerImageUuid, function (err, img) {
+                ctx.imgapiImage = img;
+                next(err);
+            });
+        }
+
+        function imgapiGetExistingImageFileStream(ctx, next) {
+            log.debug('getting image file stream from IMGAPI');
+            imgapiClient.getImageFileStream(ctx.layerImageUuid,
+                function (err, stream) {
+                    // Stream has to be paused, for addImageFile call.
+                    if (stream) {
+                        stream.pause();
+                        ctx.layerStream = stream;
+                    }
+                    next(err);
+                }
+            );
+        }
+
+        function imgapiCreateImage(ctx, next) {
+            var rat = drc.parseRepoAndTag(gV1ImageName);
+            log.debug('creating image in IMGAPI');
+
+            var imgapiManifest = imgmanifest.imgManifestFromDockerInfo({
+                imgJson: v1ModelParams,
+                layerDigests: ['sha256:' + dockerId], // Just a placeholder.
+                owner: ALICE.account.uuid,
+                public: false,
+                repo: rat
+            });
+            imgapiManifest.uuid = imageUuid; // Keep image_uuid the same.
+            log.debug({imgapiManifest: imgapiManifest}, 'createImage manifest');
+            imgapiClient.adminImportImage(imgapiManifest, next);
+        }
+
+        function imgapiImportImageFile(ctx, next) {
+            assert.object(ctx.imgapiImage);
+            assert.arrayOfObject(ctx.imgapiImage.files);
+            assert.object(ctx.layerStream);
+
+            var file = ctx.imgapiImage.files[0];
+            var opts = {
+                compression: file.compression,
+                file: ctx.layerStream,
+                sha1: file.sha1,
+                size: file.size,
+                storage: 'local',
+                uuid: imageUuid
+            };
+            log.debug('importing image file into IMGAPI');
+            imgapiClient.addImageFile(opts, next);
+        }
+
+        function imgapiActivateImage(ctx, next) {
+            log.debug('imgapi.activateImage');
+            imgapiClient.activateImage(imageUuid, next);
+        }
+
+        function sdcDockerCreateV1Model(ctx, next) {
+            log.debug('sdcdocker.createV1Model');
+            v1ModelParams.image_uuid = imageUuid;
+            imageV1Model.create(app, log, v1ModelParams, function (err, img) {
+                gV1Image = img;
+                next(err);
+            });
+        }
+
+        function sdcDockerCreateV1ModelTag(ctx, next) {
+            log.debug('sdcdocker.createV1ModelTag');
+            var params = {
+                docker_id: gV1Image.docker_id,
+                index_name: 'docker.io',
+                owner_uuid: ALICE.account.uuid,
+                repo: gV1ImageName,
+                tag: 'latest'
+            };
+            imageTagV1Model.create(app, log, params, function (err) {
+                next(err);
+            });
+        }
+    });
+});
+
+
+// Ensure we can successful create and run a container that uses a v1 image.
+test('test docker v1/v2 images', function (tt) {
+    if (gInitSuccessful === false) {
+        tt.skip('image init failed');
+        tt.end();
+        return;
+    }
+
+    tt.test('create and run v1 image', function (t) {
+        assert.object(STATE.vmapi, 'STATE.vmapi');
+        log.debug('runV1Image');
+        h.createDockerContainer({
+            dockerClient: DOCKER_ALICE,
+            extra: {
+                Cmd: [ 'sh', '-c', 'sleep 86400' ]
+            },
+            imageName: gV1ImageName,
+            start: true,
+            test: t,
+            vmapiClient: STATE.vmapi
+        }, oncreate);
+
+        function oncreate(err, result) {
+            t.ifErr(err, 'Check for create/run container error');
+            t.ok(result.id, 'container should have an id');
+            t.equal(result.vm.state, 'running', 'Check container running');
+            DOCKER_ALICE.del('/containers/' + result.id + '?force=1', ondelete);
+        }
+
+        function ondelete(err) {
+            t.ifErr(err, 'delete v1 based container');
+            t.end();
+        }
+    });
+});
+
+
+// Ensure v1 and v2 images play nicely together.
+test('test docker v1/v2 images', function (tt) {
+    if (gInitSuccessful === false) {
+        tt.skip('image init failed');
+        tt.end();
+        return;
+    }
+
+    tt.test('list v1/v2 images', function (t) {
+        DOCKER_ALICE.get('/images/json',
+                function (err, req, res, images) {
+            t.error(err, 'should be no error retrieving images');
+            t.ok(images, 'images array');
+            t.ok(images.length >= 2, 'images length >= 2');
+
+            // Check that both the v1 and v2 images are listed.
+            var v1ImageExists = images.filter(function (img) {
+                return img.Id === gV1Image.docker_id;
+            }).length > 0;
+            t.ok(v1ImageExists, 'Expect list images to include v1 image');
+
+            var v2ImageExists = images.filter(function (img) {
+                return img.Id === gV2Image.Id;
+            }).length > 0;
+            t.ok(v2ImageExists, 'Expect list images to include v2 image');
+
+            t.end();
+        });
+    });
+
+    // Test when the v1 and v2 image have the same name.
+    tt.test('tag v2 image with v1 name', function (t) {
+        var url = util.format('/images/%s/tag?repo=%s&tag=latest',
+            gV2ImageName, gV1ImageName);
+        DOCKER_ALICE.post(url, onpost);
+        function onpost(err) {
+            t.error(err, 'should be no error tagging v2 image');
+            t.end();
+        }
+    });
+
+    tt.test('delete v2 image', function (t) {
+        DOCKER_ALICE.del('/images/' + encodeURIComponent(gV2ImageName), ondel);
+        function ondel(err) {
+            t.error(err, 'should be no error deleting v2 image');
+            t.end();
+        }
+    });
+
+    // Inspect the v1 image name (should give us the newly tagged v2 image).
+    tt.test('inspect v2 tagged image', function (t) {
+        var url = '/images/' + encodeURIComponent(gV1ImageName) + '/json';
+        DOCKER_ALICE.get(url, function (err, req, res, img) {
+            t.error(err, 'get v2 tagged image');
+            t.equal(img.Id, gV2Image.Id, 'inspect should give the v2 id');
+            t.end();
+        });
+    });
+
+    // Delete the v2 tagged image.
+    tt.test('delete v2 tagged image', function (t) {
+        DOCKER_ALICE.del('/images/' + encodeURIComponent(gV1ImageName), ondel);
+        function ondel(err) {
+            t.error(err, 'should be no error deleting v2 tagged image');
+            t.end();
+        }
+    });
+
+    tt.test('ensure v2 image is gone', function (t) {
+        DOCKER_ALICE.get('/images/json',
+                function (err, req, res, images) {
+            t.error(err, 'should be no error retrieving images');
+            t.ok(images, 'images array');
+            t.ok(images.length >= 1, 'images length >= 1');
+
+            // Check that both the v1 image exists and v2 image is gone.
+            var v1ImageExists = images.filter(function (img) {
+                return img.Id === gV1Image.docker_id;
+            }).length > 0;
+            t.ok(v1ImageExists, 'Expect list images to include v1 image');
+
+            var v2ImageExists = images.filter(function (img) {
+                return img.Id === gV2Image.Id;
+            }).length > 0;
+            t.notOk(v2ImageExists, 'Expect list images to exclude v2 image');
+
+            t.end();
+        });
+    });
+
+    tt.test('delete v1 image', function (t) {
+        DOCKER_ALICE.del('/images/' + encodeURIComponent(gV1ImageName), ondel);
+        function ondel(err) {
+            t.error(err, 'should be no error deleting v1 image');
+            t.end();
+        }
+    });
+
+    tt.test('ensure v1 and v2 images are gone', function (t) {
+        DOCKER_ALICE.get('/images/json',
+                function (err, req, res, images) {
+            t.error(err, 'should be no error retrieving images');
+            t.ok(images, 'images array');
+
+            // Check that both the v1 and v2 images are gone.
+            var v1ImageExists = images.filter(function (img) {
+                return img.Id === gV1Image.docker_id;
+            }).length > 0;
+            t.notOk(v1ImageExists, 'Expect list images to exclude v1 image');
+
+            var v2ImageExists = images.filter(function (img) {
+                return img.Id === gV2Image.Id;
+            }).length > 0;
+            t.notOk(v2ImageExists, 'Expect list images to exclude v2 image');
+
+            t.end();
+        });
+    });
+});
+
+
+test('teardown', function (tt) {
+    imgapiClient.close();
+    morayClient.close();
+    tt.end();
+});
diff --git a/test/integration/api-images.test.js b/test/integration/api-images.test.js
index a27aec1..2899b02 100644
--- a/test/integration/api-images.test.js
+++ b/test/integration/api-images.test.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2015, Joyent, Inc.
+ * Copyright (c) 2017, Joyent, Inc.
  */
 
 /*
@@ -68,6 +68,8 @@ test('setup', function (tt) {
 
 test('docker images', function (tt) {
 
+    var img;
+
     tt.test('list images', function (t) {
         DOCKER_ALICE.get('/images/json',
                 function (err, req, res, images) {
@@ -106,8 +108,9 @@ test('docker images', function (tt) {
     // Ensure an image can be inspected when the name is uri decoded/encoded.
     tt.test('inspect ubuntu image', function (t) {
         var url = '/images/ubuntu:latest/json';
-        DOCKER_ALICE.get(url, function (err, req, res) {
+        DOCKER_ALICE.get(url, function (err, req, res, _img) {
             t.error(err, 'get ubuntu:latest image');
+            img = _img;
             url = url.replace(':', '%3A');
             DOCKER_ALICE.get(url, function (err2, req2, res2) {
                 t.error(err2, 'get encoded ubuntu%3Alatest image');
@@ -117,6 +120,30 @@ test('docker images', function (tt) {
     });
 
 
+    // Ensure an image can be found using the config digest.
+    tt.test('inspect ubuntu image by config digest', function (t) {
+        t.equal(img.Id.substr(0, 7), 'sha256:', 'id should be a digest');
+        var url = '/images/' + img.Id + '/json';
+        DOCKER_ALICE.get(url, function (err, req, res, _img) {
+            t.error(err, 'get image by digest');
+            t.equal(img.Id, _img.Id, 'images should have same digest');
+            t.end();
+        });
+    });
+
+
+    // Ensure an image can be found using the repo (manifest) digest.
+    tt.test('inspect ubuntu image by repo digest', function (t) {
+        var repoDigest = img.RepoDigests[0];
+        var url = '/images/' + repoDigest + '/json';
+        DOCKER_ALICE.get(url, function (err, req, res, _img) {
+            t.error(err, 'get image by repo digest');
+            t.equal(img.Id, _img.Id, 'images should have same digest');
+            t.end();
+        });
+    });
+
+
     tt.test('delete image', function (t) {
         DOCKER_ALICE.del('/images/ubuntu', ondel);
         function ondel(err, req, res) {
@@ -158,5 +185,4 @@ test('docker images', function (tt) {
             t.end();
         });
     });
-
 });
diff --git a/test/integration/cli-attach.test.js b/test/integration/cli-attach.test.js
index ab76357..6624a86 100644
--- a/test/integration/cli-attach.test.js
+++ b/test/integration/cli-attach.test.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2016, Joyent, Inc.
+ * Copyright (c) 2017, Joyent, Inc.
  */
 
 /*
@@ -65,7 +65,7 @@ test('setup', function (tt) {
  */
 
 test('test status code on attach exiting with implicit 0', function (tt) {
-    removeTestContainers(tt);
+    cli.rmContainersWithNamePrefix(tt, CONTAINER_PREFIX);
     tt.test('create container ' + container, function (t) {
         t.plan(4);
         var cmd = 'sleep 20; echo done';
@@ -87,7 +87,7 @@ test('test status code on attach exiting with implicit 0', function (tt) {
 
 
 test('test status code on attach exiting with 2', function (tt) {
-    removeTestContainers(tt);
+    cli.rmContainersWithNamePrefix(tt, CONTAINER_PREFIX);
     tt.test('create container ' + container, function (t) {
         t.plan(5);
         var cmd = 'sleep 20; exit 2';
@@ -112,7 +112,7 @@ test('test status code on attach exiting with 2', function (tt) {
 
 test('test status code on exec exiting with implicit 0',
 function (tt) {
-    removeTestContainers(tt);
+    cli.rmContainersWithNamePrefix(tt, CONTAINER_PREFIX);
     tt.test('create container ' + container, function (t) {
         t.plan(4);
 
@@ -134,7 +134,7 @@ function (tt) {
 
 test('test status code on exec exiting with 2',
 function (tt) {
-    removeTestContainers(tt);
+    cli.rmContainersWithNamePrefix(tt, CONTAINER_PREFIX);
     tt.test('create container ' + container, function (t) {
         t.plan(5);
 
@@ -160,38 +160,5 @@ function (tt) {
  */
 
 test('container cleanup', function (tt) {
-    removeTestContainers(tt);
+    cli.rmContainersWithNamePrefix(tt, CONTAINER_PREFIX);
 });
-
-
-/**
- * Support functions
- */
-
-function removeTestContainers(tt) {
-    tt.test('remove old containers', function (t) {
-        cli.ps(t, {args: '-a'}, function (err, entries) {
-            t.ifErr(err, 'docker ps');
-
-            var oldContainers = entries.filter(function (entry) {
-                return (entry.names.substr(0, CONTAINER_PREFIX.length)
-                        === CONTAINER_PREFIX);
-            });
-
-            vasync.forEachParallel({
-                inputs: oldContainers,
-                func: function _delOne(entry, cb) {
-                    cli.rm(t, {args: '-f ' + entry.container_id},
-                            function (err2)
-                    {
-                        t.ifErr(err2, 'rm container ' + entry.container_id);
-                        cb();
-                    });
-                }
-            }, function (forEachErr) {
-                tt.ifErr(forEachErr);
-                t.end();
-            });
-        });
-    });
-}
diff --git a/test/integration/cli-copy.test.js b/test/integration/cli-copy.test.js
index 470ed3e..37ac311 100644
--- a/test/integration/cli-copy.test.js
+++ b/test/integration/cli-copy.test.js
@@ -144,7 +144,7 @@ test('setup', function (tt) {
 
 
 test('test initialization', function (tt) {
-    removeTestContainers(tt);
+    cli.rmContainersWithNamePrefix(tt, CONTAINER_PREFIX);
 
     vasync.forEachParallel({
         inputs: CONTAINERS_TO_CREATE,
@@ -564,7 +564,7 @@ test('copy a file into stopped container', function (tt) {
  * Cleanup.
  */
 test('copy container cleanup', function (tt) {
-    removeTestContainers(tt);
+    cli.rmContainersWithNamePrefix(tt, CONTAINER_PREFIX);
 });
 
 
@@ -589,34 +589,6 @@ function startContainer(tt, containerName, callback) {
 }
 
 
-function removeTestContainers(tt) {
-    tt.test('remove old containers', function (t) {
-        cli.ps(t, {args: '-a'}, function (err, entries) {
-            t.ifErr(err, 'docker ps');
-
-            var oldContainers = entries.filter(function (entry) {
-                return (entry.names.substr(0, CONTAINER_PREFIX.length)
-                        === CONTAINER_PREFIX);
-            });
-
-            vasync.forEachParallel({
-                inputs: oldContainers,
-                func: function _delOne(entry, cb) {
-                    cli.rm(t, {args: '-f ' + entry.container_id},
-                            function (err2)
-                    {
-                        t.ifErr(err2, 'rm container ' + entry.container_id);
-                        cb();
-                    });
-                }
-            }, function () {
-                t.end();
-            });
-        });
-    });
-}
-
-
 /**
  * Copy out test auxillary support functions
  */
diff --git a/test/integration/cli-filters.test.js b/test/integration/cli-filters.test.js
index 2caac65..665abd7 100644
--- a/test/integration/cli-filters.test.js
+++ b/test/integration/cli-filters.test.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2016, Joyent, Inc.
+ * Copyright (c) 2017, Joyent, Inc.
  */
 
 /*
@@ -18,6 +18,7 @@ var vasync = require('vasync');
 
 var cli = require('../lib/cli');
 var common = require('../lib/common');
+var sdcCommon = require('../../lib/common');
 var vm = require('../lib/vm');
 
 
@@ -27,6 +28,11 @@ var CLIENTS = {};
 var CONTAINER_PREFIX = 'sdcdockertest_filters_';
 var IMAGE_NAME = 'joyentunsupported/busybox_with_label_test';
 
+var cliVersion = process.env.DOCKER_CLI_VERSION;
+if (cliVersion) {
+    // The cliVersion must be in x.y format!
+    cliVersion = cliVersion.split('.')[0] + '.' + cliVersion.split('.')[1];
+}
 
 
 // --- Tests
@@ -148,8 +154,24 @@ test('image filters', function (tt) {
             function (err, images)
         {
             t.ifErr(err, 'docker images --filter');
-            t.equal(images.length, 1, 'Check one image returned');
-            t.equal(images[0].repository, IMAGE_NAME, 'Check image name');
+            // Older docker clients 1.11 and below will return *two* image
+            // entries for every tagged image (one with '<none>' as the tag
+            // name).
+            if (sdcCommon.apiVersionCmp(cliVersion, 1.12) >= 0) {
+                t.equal(images.length, 1, 'Check one image returned');
+                t.equal(images[0].repository, IMAGE_NAME, 'Check image name');
+                t.equal(images[0].tag, 'latest', 'Check image tag');
+            } else {
+                t.equal(images.length, 2, 'Check two images returned');
+                t.equal(images[0].repository, IMAGE_NAME, 'Check image name');
+                t.equal(images[1].repository, IMAGE_NAME, 'Check image name');
+                if (images[0].tag === 'latest') {
+                    t.equal(images[1].tag, '<none>', 'Check image tag');
+                } else {
+                    t.equal(images[0].tag, '<none>', 'Check image tag');
+                    t.equal(images[1].tag, 'latest', 'Check image tag');
+                }
+            }
             t.end();
         });
     });
diff --git a/test/integration/cli-image-rmi.test.js b/test/integration/cli-image-rmi.test.js
new file mode 100644
index 0000000..cf5975b
--- /dev/null
+++ b/test/integration/cli-image-rmi.test.js
@@ -0,0 +1,291 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+
+/*
+ * Integration tests for docker rmi.
+ */
+
+var imgmanifest = require('imgmanifest');
+var test = require('tape');
+var util = require('util');
+var vasync = require('vasync');
+
+var cli = require('../lib/cli');
+var common = require('../lib/common');
+var h = require('./helpers');
+
+// --- Globals
+
+var ALICE;
+var CONTAINER_PREFIX = 'sdcdockertest_rmi_';
+var TAG_PREFIX = 'sdcdockertest_rmi_';
+var IMAGE_NAME = 'joyentunsupported/test-nginx:1.0.0';
+
+// --- Tests
+
+
+test('setup', function (tt) {
+    tt.test('DockerEnv: alice init', function (t) {
+        cli.init(t, function (err, result) {
+            if (!err) {
+                ALICE = result.user;
+            }
+            // Note: cli.init() calls t.end()
+        });
+    });
+
+    // Pull down the docker image.
+    tt.test('pull ' + IMAGE_NAME, function (t) {
+        pullTestImage(function (err) {
+            t.ifErr(err, 'check pull ' + IMAGE_NAME);
+            t.end();
+        });
+    });
+
+    // Remove old containers.
+    cli.rmContainersWithNamePrefix(tt, CONTAINER_PREFIX);
+});
+
+
+test('docker rmi', function (tt) {
+
+    var altTagName = TAG_PREFIX + 'altbox';
+    var imageInspect;
+
+    // Get image details.
+    tt.test('inspect image', function (t) {
+        cli.inspect(t, {
+            id: IMAGE_NAME
+        }, function (err, img) {
+            t.ifErr(err, 'Inspect image');
+            imageInspect = img;
+            t.end();
+        });
+    });
+
+    // Tag with an alternative name.
+    tt.test('tag as altbox', function (t) {
+        cli.docker('tag ' + IMAGE_NAME + ' ' + altTagName, {}, onComplete);
+        function onComplete(err, stdout, stderr) {
+            t.ifErr(err);
+            t.end();
+        }
+    });
+
+    // Test two tags to the same image, should get a docker rmi warning when
+    // trying to delete using the image id.
+    tt.test('rmi using image id', function (t) {
+        var opts = {
+            args: imageInspect.Id,
+            expectedErr: new RegExp('conflict: unable to delete [0-9a-f]{12} '
+                + '\\(must be forced\\) - image is referenced in one or more '
+                + 'repositories')
+        };
+
+        cli.rmi(t, opts); // Err checking and t.end() is done in cli.rmi().
+    });
+
+    // Remove altbox image using it's repo/tag name.
+    tt.test('rmi altbox image', function (t) {
+        var opts = {args: altTagName};
+        cli.rmi(t, opts); // Err checking and t.end() is done in cli.rmi().
+    });
+
+    // Run container based on our test image.
+    tt.test('docker rmi for in-use image', function (t) {
+        var imageShortId = imgmanifest.shortDockerId(
+            imgmanifest.dockerIdFromDigest(imageInspect.Id));
+        var containerId;
+
+        function ensureInspect404(_, next) {
+            cli.inspect(t, {
+                id: imageInspect.Id,
+                expectedErr: new RegExp('Error: No such image')
+            }, function () {
+                // Ignore error - as it's handled by cli.inspect
+                next();
+            });
+        }
+
+        function repullTestImage(_, next) {
+            pullTestImage(function (err) {
+                t.ifErr(err, 'check pull ' + IMAGE_NAME);
+                next(err);
+            });
+        }
+
+        vasync.pipeline({ funcs: [
+            function runContainer(_, next) {
+                var opts = {
+                    args: util.format('-d --name %s %s sh -c "sleep 86400"',
+                        common.makeContainerName(CONTAINER_PREFIX), IMAGE_NAME)
+                };
+
+                cli.run(t, opts, function (err, id) {
+                    t.ifErr(err, 'check for docker run error');
+                    containerId = id;
+                    next(err);
+                });
+            },
+
+            // ---- Failure rmi cases ---- //
+
+            // Cannot remove image (by id) if a running container is using it.
+            function rmiById(_, next) {
+                var opts = {
+                    args: imageInspect.Id,
+                    expectedErr: new RegExp('conflict: unable to delete '
+                        + '[0-9a-f]{12} \\(cannot be forced\\) - image is '
+                        + 'being used by running container [0-9a-f]{12}')
+                };
+
+                cli.rmi(t, opts, function () {
+                    // Ignore err - as it's already checked in cli.rmi call.
+                    next();
+                });
+            },
+
+            // Cannot remove image (by name) if a running container is using it.
+            function rmiByName(_, next) {
+                var opts = {
+                    args: IMAGE_NAME,
+                    expectedErr: new RegExp('conflict: unable to remove '
+                        + 'repository reference "' + IMAGE_NAME + '" '
+                        + '\\(must force\\) - container [0-9a-f]{12} is using '
+                        + 'its referenced image ' + imageShortId)
+                };
+
+                cli.rmi(t, opts, function () {
+                    // Ignore err - as it's already checked in cli.rmi call.
+                    next();
+                });
+            },
+
+            // Cannot force remove image (by id) if a running container is
+            // using it.
+            function forcedRmiById(_, next) {
+                var opts = {
+                    args: '--force ' + imageInspect.Id,
+                    expectedErr: new RegExp('conflict: unable to delete '
+                        + '[0-9a-f]{12} \\(cannot be forced\\) - image is '
+                        + 'being used by running container [0-9a-f]{12}')
+                };
+
+                cli.rmi(t, opts, function (err) {
+                    // Ignore err - as it's already checked in cli.rmi call.
+                    next();
+                });
+            },
+
+            function stopContainer(_, next) {
+                cli.stop(t, {args: containerId}, next);
+            },
+
+            // Cannot remove image (by id) if a stopped container is using it.
+            function rmiByIdStoppedContainer(_, next) {
+                var opts = {
+                    args: imageInspect.Id,
+                    expectedErr: new RegExp('conflict: unable to delete '
+                        + '[0-9a-f]{12} \\(must be forced\\) - image is '
+                        + 'being used by stopped container [0-9a-f]{12}')
+                };
+
+                cli.rmi(t, opts, function () {
+                    // Ignore err - as it's already checked in cli.rmi call.
+                    next();
+                });
+            },
+
+            // Cannot remove image (by name) if a stopped container is using it.
+            function rmiByNameStoppedContainer(_, next) {
+                var opts = {
+                    args: IMAGE_NAME,
+                    expectedErr: new RegExp('conflict: unable to remove '
+                        + 'repository reference "' + IMAGE_NAME + '" '
+                        + '\\(must force\\) - container [0-9a-f]{12} is using '
+                        + 'its referenced image ' + imageShortId)
+                };
+
+                cli.rmi(t, opts, function () {
+                    // Ignore err - as it's already checked in cli.rmi call.
+                    next();
+                });
+            },
+
+            // ---- Successful rmi cases ---- //
+
+            // Can force remove image (by id) if stopped container is using it.
+            function forcedRmiByIdStoppedContainer(_, next) {
+                cli.rmi(t, {args: '--force ' + imageInspect.Id}, next);
+            },
+
+            ensureInspect404,
+            repullTestImage,
+
+            // Can force remove image (by name) if stopped container uses it.
+            function forcedRmiByNameStoppedContainer(_, next) {
+                cli.rmi(t, {args: '--force ' + IMAGE_NAME}, next);
+            },
+
+            ensureInspect404,
+            repullTestImage,
+
+            function restartContainer(_, next) {
+                cli.start(t, {args: containerId}, next);
+            },
+
+            // Can force remove image (by name) if a running container is using
+            // it, but it only untags the image!
+            function forcedRmiByName(_, next) {
+                cli.rmi(t, {args: '--force ' + IMAGE_NAME}, next);
+            },
+
+            function ensureInspectByIdSuccessful(_, next) {
+                cli.inspect(t, {
+                    id: imageInspect.Id
+                }, function (err, img) {
+                    t.ifErr(err, 'Inspect image');
+                    t.equal(img.Id, imageInspect.Id,
+                        'inspected image should have the correct id');
+                    next(err);
+                });
+            },
+
+            function ensureInspectByName404(_, next) {
+                cli.inspect(t, {
+                    id: IMAGE_NAME,
+                    expectedErr: new RegExp('Error: No such image')
+                }, function () {
+                    // Ignore error - as it's handled by cli.inspect
+                    next();
+                });
+            }
+
+        ]}, function (err) {
+            t.ifErr(err);
+            if (containerId) {
+                // Note: cli.rm will call t.end() when it's done.
+                cli.rm(t, {args: '-f ' + containerId});
+                return;
+            }
+            t.end();
+        });
+    });
+});
+
+
+// Helpers
+
+function pullTestImage(callback) {
+    h.ensureImage({
+        name: IMAGE_NAME,
+        user: ALICE
+    }, callback);
+}
diff --git a/test/integration/cli-image-tag.test.js b/test/integration/cli-image-tag.test.js
index a57f312..f95b3d8 100644
--- a/test/integration/cli-image-tag.test.js
+++ b/test/integration/cli-image-tag.test.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2016, Joyent, Inc.
+ * Copyright (c) 2017, Joyent, Inc.
  */
 
 /*
@@ -30,11 +30,12 @@ var IMAGE_NAME = 'busybox';
 
 function cleanupTags(tt) {
     tt.test('image tag cleanup', function (t) {
-        cli.docker('images | grep ' + TAG_PREFIX + ' | awk "{ print \\$1 }"',
+        cli.docker('images | grep ' + TAG_PREFIX
+            + ' | grep -v "<none>" | awk "{ print \\$1 }"',
             {}, onComplete);
         function onComplete(err, stdout, stderr) {
             t.ifErr(err);
-            var ids = stdout.split(/(\r?\n)/g).join(' ').trim();
+            var ids = stdout.split(/\r?\n/g).join(' ').trim();
             if (!ids) {
                 t.end();
                 return;
@@ -114,9 +115,9 @@ test('tag image', function (tt) {
 
 
 /**
- * DOCKER-748: Cannot build an image that references multiple registries.
+ * DOCKER-756: Check can tag an image that references multiple registries.
  */
-test('DOCKER-748: tag between different registries', function (tt) {
+test('DOCKER-756: tag between different registries', function (tt) {
 
     var tagName = 'quay.io/joyent/' + TAG_PREFIX + 'altbox';
 
@@ -128,12 +129,9 @@ test('DOCKER-748: tag between different registries', function (tt) {
 
     // Tag the image.
     tt.test('tag busybox image', function (t) {
-        cli.docker('tag busybox ' + tagName, {}, onComplete);
-        function onComplete(err, stdout, stderr) {
-            t.assert(err);
-            t.assert(String(err).indexOf('different registries') >= 0,
-                'should be a "different registries" error message');
+        cli.docker('tag busybox ' + tagName, {}, function onComplete(err) {
+            t.ifErr(err);
             t.end();
-        }
+        });
     });
 });
diff --git a/test/integration/helpers.js b/test/integration/helpers.js
index 24579b5..ff7faaa 100644
--- a/test/integration/helpers.js
+++ b/test/integration/helpers.js
@@ -13,10 +13,11 @@
  */
 
 var assert = require('assert-plus');
+var drc = require('docker-registry-client');
 var exec = require('child_process').exec;
 var fmt = require('util').format;
 var fs = require('fs');
-var mod_log = require('../lib/log');
+var moray = require('moray');
 var os = require('os');
 var path = require('path');
 var sdcClients = require('sdc-clients');
@@ -24,8 +25,10 @@ var restify = require('restify');
 var vasync = require('vasync');
 
 var common = require('../lib/common');
-var sdcCommon = require('../../lib/common');
+var configLoader = require('../../lib/config-loader.js');
 var constants = require('../../lib/constants');
+var mod_log = require('../lib/log');
+var sdcCommon = require('../../lib/common');
 
 
 // --- globals
@@ -1378,6 +1381,16 @@ function ensureImage(opts, callback) {
     var log;
     var name = opts.name;
 
+    // Check if the name includes a tag or digest.
+    try {
+        var rat = drc.parseRepoAndRef(name);
+    } catch (e) {
+        callback(new Error(fmt('Failed to parse image name %s: %s', name, e)));
+        return;
+    }
+
+    var encodedName = encodeURIComponent(rat.localName);
+
     vasync.pipeline({ arg: {}, funcs: [
         function getJsonClient(ctx, next) {
             // Get the json client.
@@ -1420,8 +1433,10 @@ function ensureImage(opts, callback) {
         // Image doesn't exist... pull it down.
         function pullImage(ctx, next) {
             log.debug({name: name}, 'ensureImage: pulling image');
-            var url = '/images/create?fromImage='
-                + encodeURIComponent(name);
+            var url = '/images/create?fromImage=' + encodedName;
+            if (rat.tag || rat.digest) {
+                url += '&tag=' + encodeURIComponent(rat.tag || rat.digest);
+            }
             ctx.httpClient.post(url, function _onPost(err, req) {
                 if (err) {
                     next(err);
@@ -1489,12 +1504,34 @@ function ensureImage(opts, callback) {
 
 
 /**
- * Create a nginx VM fixture
+ * Create a docker container.
+ *
+ * @param opts.dockerClient {Object} A docker client.
+ * @param opts.vmapiClient {Object} A vmapi client.
+ * @param opts.test {Object} The tape test object.
+ * @param opts.imageName {String} Optional image name to base the container on.
+ *        Defaults to nginx container.
+ * @param opts.start {Boolean} Optional. Use to start container after creation.
+ *
+ * @returns callback(err, result) Result contains these fields:
+ *          - id: The id of the created container.
+ *          - inspect: The docker inspect result for the container.
+ *          - uuid: The vm uuid for the container.
+ *          - vm: The vmobj for the container.
  */
 function createDockerContainer(opts, callback) {
     assert.object(opts, 'opts');
+    assert.optionalString(opts.apiVersion, 'opts.apiVersion');
+    assert.object(opts.dockerClient, 'opts.dockerClient');
+    assert.optionalObject(opts.extra, 'opts.extra');
+    assert.optionalString(opts.imageName, 'opts.imageName');
+    assert.optionalBool(opts.start, 'opts.start');
+    assert.object(opts.test, 'opts.test');
+    assert.object(opts.vmapiClient, 'opts.vmapiClient');
     assert.func(callback, 'callback');
 
+    var imageName = opts.imageName || 'nginx';
+
     var payload = {
         'Hostname': '',
         'Domainname': '',
@@ -1513,7 +1550,7 @@ function createDockerContainer(opts, callback) {
         'StdinOnce': false,
         'Env': [],
         'Cmd': null,
-        'Image': 'nginx',
+        'Image': imageName,
         'Volumes': {},
         'WorkingDir': '',
         'Entrypoint': null,
@@ -1566,10 +1603,10 @@ function createDockerContainer(opts, callback) {
 
     vasync.waterfall([
         function (next) {
-            // There is a dependency here, in order to create a nginx container,
-            // the nginx image must first be downloaded.
+            // There is a dependency here, in order to create a container,
+            // the image must first be downloaded.
             ensureImage({
-                name: 'nginx:latest',
+                name: imageName,
                 user: dockerClient.user
             }, next);
         },
@@ -1952,10 +1989,65 @@ function getSortedPackages(callback) {
 }
 
 
+function createMorayClient(callback) {
+    var log = mod_log;
+    var sdcDockerConfig = configLoader.loadConfigSync({log: log});
+
+    var morayConfig = {
+        host: sdcDockerConfig.moray.host,
+        noCache: true,
+        port: sdcDockerConfig.moray.port,
+        reconnect: true,
+        dns: {
+            resolvers: [sdcDockerConfig.binder.domain]
+        }
+    };
+
+    log.debug(morayConfig, 'Creating moray client');
+    morayConfig.log = log.child({
+        component: 'moray',
+        level: 'warn'
+    });
+    var client = moray.createClient(morayConfig);
+
+    function onMorayConnect() {
+        client.removeListener('error', onMorayError);
+        client.log.info('moray: connected');
+        callback(null, client);
+    }
+
+    function onMorayError(err) {
+        client.removeListener('connect', onMorayConnect);
+        client.log.error(err, 'moray: connection failed');
+        callback(err);
+    }
+
+    client.once('connect', onMorayConnect);
+    client.once('error', onMorayError);
+
+    return client;
+}
+
+
+function createImgapiClient(callback) {
+    var sdcDockerConfig = configLoader.loadConfigSync({log: mod_log});
+
+    var client = new sdcClients.IMGAPI({
+        agent: false,
+        log: mod_log,
+        url: sdcDockerConfig.imgapi.url,
+        userAgent: UA
+    });
+    callback(null, client);
+}
+
+
 // --- exports
 
 module.exports = {
     createDockerRemoteClient: createDockerRemoteClient,
+    createImgapiClient: createImgapiClient,
+    createMorayClient: createMorayClient,
     createSapiClient: createSapiClient,
     createFwapiClient: createFwapiClient,
     createPapiClient: createPapiClient,
diff --git a/test/lib/cli.js b/test/lib/cli.js
index f6945b7..dce0d87 100644
--- a/test/lib/cli.js
+++ b/test/lib/cli.js
@@ -79,15 +79,18 @@ function cliInspect(t, opts, callback) {
         var obj;
         var pe;
 
-        t.ifErr(err, 'docker inspect ' + opts.id);
-        t.equal(stderr, '', 'stderr should be empty');
-
-        // XXX: allow setting opts.expectedErr
         if (err) {
-            common.done(t, callback, err);
+            if (opts.expectedErr) {
+                common.expCliErr(t, stderr, opts.expectedErr, callback);
+            } else {
+                t.ifErr(err, 'docker inspect ' + opts.id);
+                common.done(t, callback, err);
+            }
             return;
         }
 
+        t.equal(stderr, '', 'stderr should be empty');
+
         if (!stdout) {
             var stdoutErr = new Error('no stdout!');
             t.ifErr(stdoutErr, 'no stdout found');
@@ -292,6 +295,36 @@ function cliRmAllCreated(t) {
 }
 
 
+/**
+ * Removes all docker VMs that have the given name prefix.
+ */
+function cliRmContainersWithNamePrefix(tt, prefix) {
+    tt.test('remove old containers', function (t) {
+        cliPs(t, {args: '-a'}, function (err, entries) {
+            t.ifErr(err, 'docker ps');
+
+            var containersToRemove = entries.filter(function (entry) {
+                return (entry.names.substr(0, prefix.length) === prefix);
+            });
+
+            vasync.forEachParallel({
+                inputs: containersToRemove,
+                func: function _delOne(entry, cb) {
+                    cliRm(t, {args: '-f ' + entry.container_id}, onRemove);
+                    function onRemove(err2) {
+                        t.ifErr(err2, 'rm container ' + entry.container_id);
+                        cb(err2);
+                    }
+                }
+            }, function (forEachErr) {
+                tt.ifErr(forEachErr);
+                t.end();
+            });
+        });
+    });
+}
+
+
 /**
  * `docker create <cmd>`
  */
@@ -460,7 +493,7 @@ function cliRm(t, opts, callback) {
         t.ifErr(err, 'docker rm ' + opts.args);
         t.equal(stderr, '', 'stderr');
 
-        callback(err);
+        common.done(t, callback, err);
     });
 }
 
@@ -474,9 +507,14 @@ function cliRmi(t, opts, callback) {
     assert.string(opts.args, 'opts.args');
 
     ALICE.docker('rmi ' + opts.args, function (err, stdout, stderr) {
+        if (opts.expectedErr) {
+            common.expCliErr(t, stderr, opts.expectedErr, callback);
+            return;
+        }
+
         t.ifErr(err, 'docker rmi ' + opts.args);
-        t.equal(stderr, '', 'stderr');
-        callback(err);
+        t.equal(stderr, '', 'docker rmi stderr should be empty');
+        common.done(t, callback, err);
     });
 }
 
@@ -591,6 +629,7 @@ module.exports = {
     rm: cliRm,
     rmi: cliRmi,
     rmAllCreated: cliRmAllCreated,
+    rmContainersWithNamePrefix: cliRmContainersWithNamePrefix,
     run: cliRun,
     stop: cliStop,
     start: cliStart,
diff --git a/test/lib/common.js b/test/lib/common.js
index 02d9fa1..c3be651 100644
--- a/test/lib/common.js
+++ b/test/lib/common.js
@@ -184,14 +184,14 @@ function expErr(t, err, expected, isCliErr, callback) {
 
     var expectedErrRe = (isCliErr ? ERR_CLI_RE : ERR_API_RE);
     var matches = message.match(expectedErrRe);
-    if (!matches) {
-        t.ok(matches, fmt('err message does not match %s: %j',
-            expectedErrRe, message));
-        done(t, callback, new Error('unexpected error output'));
-        return;
+    if (matches) {
+        t.ok(matches[3], 'error req id: ' + matches[3]);
+        errorString = matches[2];
+    } else {
+        // Some messages (e.g. `docker inspect`) don't match the RE, so leave
+        // the error as is.
+        errorString = message;
     }
-    t.ok(matches[3], 'error req id: ' + matches[3]);
-    errorString = matches[2];
 
     if (RegExp.prototype.isPrototypeOf(expected)) {
         t.ok(expected.test(errorString),
