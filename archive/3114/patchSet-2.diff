commit 25fb86ddbd0526c8d4ff9ff2f16fbeb901b38ae8 (refs/changes/14/3114/2)
Author: Brittany Wald <brittany.wald@joyent.com>
Date:   2017-12-15T21:28:41+00:00 (1 year, 10 months ago)
    
    MANTA-3476 read-only pnodes

diff --git a/lib/client.js b/lib/client.js
new file mode 100644
index 0000000..0741b3a
--- /dev/null
+++ b/lib/client.js
@@ -0,0 +1,90 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+
+var assert = require('assert-plus');
+var clone = require('clone');
+var fs = require('fs');
+var moray_client = require('moray'); // client
+var url = require('url');
+var verror = require('verror');
+
+/*
+ * Create moray clients in order to interact with moray instances.  Available
+ * moray clients are listed in the ring configuration in LevelDB, which we
+ * access in electric moray via node-fash.
+ */
+function createClient(options, callback) {
+    assert.object(options, 'options');
+    assert.object(options.log, 'options.log');
+    assert.object(options.ring, 'options.ring');
+    assert.object(options.morayOptions, 'options.morayOptions');
+    assert.func(callback, 'options.callback');
+
+    var log = options.log;
+
+    var clientMap = {};
+    var clientArray = [];
+
+    options.ring.getPnodes(function (err, pnodes) {
+        if (err) {
+            throw new verror.VError(err, 'unable to get pnodes');
+        }
+
+        assert.arrayOfString(pnodes, 'pnodes');
+        pnodes.forEach(function (pnode) {
+            var pnodeUrl = url.parse(pnode);
+            assert.string(pnodeUrl.port, 'pnodeUrl.port');
+            assert.string(pnodeUrl.hostname, 'pnodeUrl.hostname');
+
+            log.info({
+                url: pnodeUrl
+            }, 'creating moray client');
+            var morayargs = clone(options.morayOptions);
+            if (!morayargs.cueballOptions) {
+                morayargs.cueballOptions = {};
+            }
+            morayargs.unwrapErrors = true;
+            morayargs.srvDomain = pnodeUrl.hostname;
+            morayargs.cueballOptions.defaultPort = parseInt(pnodeUrl.port, 10);
+            morayargs.log = options.log.child({
+                component: 'moray-client-' + pnodeUrl.hostname
+            });
+
+            var client = moray_client.createClient(morayargs);
+            clientMap[pnode] = client;
+            clientArray.push(client);
+
+            if (clientArray.length === pnodes.length) {
+                // write ready cookie when clients have connected
+                log.info('all moray clients instantiated writing ready cookie');
+                try {
+                    fs.writeFileSync('/var/tmp/electric-moray-ready', null);
+                } catch (e) {
+                    throw new verror.VError(e, 'unable to write ready cookie');
+                }
+            }
+        });
+
+        if (clientArray.length <= 0) {
+            throw new verror.VError('No moray clients exist!');
+        }
+
+        return callback(null, {
+            map: clientMap,
+            array: clientArray
+        });
+    });
+}
+
+///--- Exports
+
+module.exports = {
+    createClient: createClient
+};
diff --git a/lib/errors.js b/lib/errors.js
index 101abd9..5d7e330 100644
--- a/lib/errors.js
+++ b/lib/errors.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2014, Joyent, Inc.
+ * Copyright (c) 2017, Joyent, Inc.
  */
 
 var fs = require('fs');
@@ -16,7 +16,6 @@ var verror = require('verror');
 
 
 
-
 ///--- Globals
 
 var WError = verror.WError;
@@ -56,9 +55,9 @@ util.inherits(InvocationError, VError);
 
 function ReadOnlyError(cause) {
         if (arguments.length === 0) {
-                cause = {};
+                cause = 'some vnodes are';
         }
-        WError.call(this, cause, 'some vnodes are in read-only mode');
+        WError.call(this, cause, '"%s" in read-only mode');
         this.name = this.constructor.name;
 }
 util.inherits(ReadOnlyError, WError);
diff --git a/lib/index.js b/lib/index.js
index 67c2c58..ba40df8 100644
--- a/lib/index.js
+++ b/lib/index.js
@@ -5,16 +5,18 @@
  */
 
 /*
- * Copyright (c) 2016, Joyent, Inc.
+ * Copyright (c) 2017, Joyent, Inc.
  */
 
 var server = require('./server');
+var status_server = require('./status_server');
 
 
 ///--- Exports
 
 module.exports = {
 
-    createServer: server.createServer
+    createServer: server.createServer,
+    createStatusServer: status_server.createStatusServer
 
 };
diff --git a/lib/server.js b/lib/server.js
index 2348b70..83eb265 100644
--- a/lib/server.js
+++ b/lib/server.js
@@ -121,8 +121,9 @@ var UO_ARGS_SCHEMA = [
 
 ///--- API
 
-function createServer(options) {
+function createServer(options, callback) {
     assert.object(options, 'options');
+    assert.func(callback, 'callback');
     assert.string(options.ringLocation, 'options.ringLocation');
 
     var log = options.log;
@@ -160,6 +161,7 @@ function createServer(options) {
             }
 
             opts.clients = clients;
+            opts.indexShards = options.ringCfg.indexShards;
 
             var collector = artedi.createCollector();
 
@@ -234,6 +236,10 @@ function createServer(options) {
 
             socket.on('listening', function () {
                 log.info('moray listening on %d', options.port);
+                callback(null, {
+                    ring: opts.ring,
+                    clientList: Object.keys(opts.clients.map)
+                });
             });
 
             socket.on('error', function (serr) {
@@ -303,11 +309,54 @@ function invalidArgs(rpc, argv, types) {
     return false;
 }
 
-//TODO; No bucket modification can occur whilst re-sharding.
+/*
+ * Checks if a moray client is set to read-only mode. 'ro' is an object that
+ * holds information about the moray client we are accessing in a given rpc, as
+ * well as a logger and the sapi_manifest's index shard map.
+ */
+function isReadOnlyPnode(ro, callback) {
+    assert.object(ro, 'ro');
+    assert.object(ro.log, 'ro.log');
+    assert.object(ro.indexShards, 'indexShards');
+    assert.string(ro.morayClient, 'morayClient');
+
+    ro.log.debug({
+        morayClient: ro.morayClient,
+        indexShards: ro.indexShards
+    }, 'isReadOnlyPnode: entered');
+
+    var readOnlyStatus = null;
+    for (var i = 0; i < ro.indexShards.length; i++) {
+        var shard = ro.indexShards[i];
+        if (shard.host === ro.morayClient) {
+            /*
+             * A shard in indexShards may not have a 'readOnly' field, which
+             * means it is not set to read-only mode.
+             */
+            readOnlyStatus = !!shard.readOnly;
+            return callback(null, readOnlyStatus);
+        }
+    }
+
+    /*
+     * If no shard's host field in indexShards matches the morayClient passed to
+     * this function, we are in an inconsistent state, and it is safer to assume
+     * that the morayClient is read-only than the alternative, which may result
+     * in writes in error.
+     */
+    ro.log.debug({
+        morayClient: ro.morayClient,
+        indexShards: ro.indexShards
+    }, 'isReadOnlyPnode: morayClient not found in indexShards');
+    return callback(null, true);
+}
+
+
 function createBucket(options) {
     assert.object(options, 'options');
     assert.object(options.log, 'options.log');
     assert.object(options.clients, 'options.clients');
+    assert.object(options.indexShards, 'options.indexShards');
 
     function _createBucket(rpc) {
         var argv = rpc.argv();
@@ -345,28 +394,48 @@ function createBucket(options) {
         var done = 0;
 
         options.clients.array.forEach(function (client) {
-            client.createBucket(name, cfg, opts, function (err2) {
-                log.debug({
-                    err: err2,
-                    client: client.host
-                }, 'createBucket: returned');
-
-                if (err2) {
-                    err.push(err2);
+            var readOnlyInfo = {
+                log: log,
+                morayClient: client.hostLabel,
+                indexShards: options.indexShards
+            };
+            isReadOnlyPnode(readOnlyInfo, function (roErr, readOnly) {
+                readOnlyInfo.log.debug({
+                    read_only: readOnly,
+                    read_only_type: typeof (readOnly)
+                }, 'read only status information');
+                if (roErr) {
+                    rpc.fail(roErr);
+                    return;
                 }
-
-                if (++done === options.clients.array.length) {
-                    var multiError = err[0] ? new verror.MultiError(err) : null;
+                if (readOnly) {
+                    rpc.fail(new ReadOnlyError(readOnlyInfo.morayClient));
+                    return;
+                }
+                client.createBucket(name, cfg, opts, function (err2) {
                     log.debug({
-                        err: multiError
-                    }, 'createBucket: finished all shards');
+                        err: err2,
+                        client: client.host
+                    }, 'createBucket: returned');
 
-                    if (multiError) {
-                        rpc.fail(multiError);
-                    } else {
-                        rpc.end();
+                    if (err2) {
+                        err.push(err2);
                     }
-                }
+
+                    if (++done === options.clients.array.length) {
+                        var multiError = err[0]
+                            ? new verror.MultiError(err) : null;
+                        log.debug({
+                            err: multiError
+                        }, 'createBucket: finished all shards');
+
+                        if (multiError) {
+                            rpc.fail(multiError);
+                        } else {
+                            rpc.end();
+                        }
+                    }
+                });
             });
         });
     }
@@ -493,27 +562,47 @@ function updateBucket(options) {
         var done = 0;
 
         options.clients.array.forEach(function (client) {
-            client.updateBucket(name, cfg, function (err2) {
-                log.debug({
-                    err: err2
-                }, 'updateBucket: returned');
-
-                if (err2) {
-                    err.push(err2);
+            var readOnlyInfo = {
+                log: log,
+                morayClient: client.hostLabel,
+                indexShards: options.indexShards
+            };
+            isReadOnlyPnode(readOnlyInfo, function (roErr, readOnly) {
+                readOnlyInfo.log.debug({
+                    read_only: readOnly,
+                    read_only_type: typeof (readOnly)
+                }, 'read only status information');
+                if (roErr) {
+                    rpc.fail(roErr);
+                    return;
                 }
-
-                if (++done === options.clients.array.length) {
-                    var multiError = err[0] ? new verror.MultiError(err) : null;
+                if (readOnly) {
+                    rpc.fail(new ReadOnlyError(readOnlyInfo.morayClient));
+                    return;
+                }
+                client.updateBucket(name, cfg, function (err2) {
                     log.debug({
-                        err: multiError
-                    }, 'updateBucket: finished all shards');
+                        err: err2
+                    }, 'updateBucket: returned');
 
-                    if (multiError) {
-                        rpc.fail(multiError);
-                    } else {
-                        rpc.end();
+                    if (err2) {
+                        err.push(err2);
                     }
-                }
+
+                    if (++done === options.clients.array.length) {
+                        var multiError = err[0] ?
+                            new verror.MultiError(err) : null;
+                        log.debug({
+                            err: multiError
+                        }, 'updateBucket: finished all shards');
+
+                        if (multiError) {
+                            rpc.fail(multiError);
+                        } else {
+                            rpc.end();
+                        }
+                    }
+                });
             });
         });
     }
@@ -560,27 +649,47 @@ function delBucket(options) {
         var done = 0;
 
         options.clients.array.forEach(function (client) {
-            client.delBucket(name, function (err2) {
-                log.debug({
-                    err: err2
-                }, 'delBucket: returned');
-
-                if (err2) {
-                    err.push(err2);
+            var readOnlyInfo = {
+                log: log,
+                morayClient: client.hostLabel,
+                indexShards: options.indexShards
+            };
+            isReadOnlyPnode(readOnlyInfo, function (roErr, readOnly) {
+                readOnlyInfo.log.debug({
+                    read_only: readOnly,
+                    read_only_type: typeof (readOnly)
+                }, 'read only status information');
+                if (roErr) {
+                    rpc.fail(roErr);
+                    return;
                 }
-
-                if (++done === options.clients.array.length) {
-                    var multiError = err[0] ? new verror.MultiError(err) : null;
+                if (readOnly) {
+                    rpc.fail(new ReadOnlyError(readOnlyInfo.morayClient));
+                    return;
+                }
+                client.delBucket(name, function (err2) {
                     log.debug({
-                        err: multiError
-                    }, 'delBucket: finished all shards');
+                        err: err2
+                    }, 'delBucket: returned');
 
-                    if (multiError) {
-                        rpc.fail(multiError);
-                    } else {
-                        rpc.end();
+                    if (err2) {
+                        err.push(err2);
                     }
-                }
+
+                    if (++done === options.clients.array.length) {
+                        var multiError = err[0] ?
+                            new verror.MultiError(err) : null;
+                        log.debug({
+                            err: multiError
+                        }, 'delBucket: finished all shards');
+
+                        if (multiError) {
+                            rpc.fail(multiError);
+                        } else {
+                            rpc.end();
+                        }
+                    }
+                });
             });
         });
     }
@@ -642,22 +751,43 @@ function putObject(options) {
             v.vnode = node.vnode;
             var pnode = node.pnode;
             var client = options.clients.map[pnode];
-            client.putObject(b, k, v, opts, function (pErr, meta) {
-                log.debug({
-                    err: pErr,
-                    meta: meta
-                }, 'putObject: returned');
 
-                dtrace['putobject-done'].fire(function () {
-                    return ([msgid]);
-                });
-
-                if (pErr) {
-                    rpc.fail(pErr);
-                } else {
-                    rpc.write(meta);
-                    rpc.end();
+            var readOnlyInfo = {
+                log: log,
+                morayClient: client.hostLabel,
+                indexShards: options.indexShards
+            };
+            isReadOnlyPnode(readOnlyInfo, function (roErr, readOnly) {
+                readOnlyInfo.log.debug({
+                    read_only: readOnly,
+                    read_only_type: typeof (readOnly)
+                }, 'read only status information');
+                if (roErr) {
+                    rpc.fail(roErr);
+                    return;
+                }
+                if (readOnly) {
+                    rpc.fail(new ReadOnlyError(readOnlyInfo.morayClient));
+                    return;
                 }
+
+                client.putObject(b, k, v, opts, function (pErr, meta) {
+                    log.debug({
+                        err: pErr,
+                        meta: meta
+                    }, 'putObject: returned');
+
+                    dtrace['putobject-done'].fire(function () {
+                        return ([msgid]);
+                    });
+
+                    if (pErr) {
+                        rpc.fail(pErr);
+                    } else {
+                        rpc.write(meta);
+                        rpc.end();
+                    }
+                });
             });
         });
     }
@@ -796,20 +926,40 @@ function delObject(options) {
                 return;
             }
             var client = options.clients.map[node.pnode];
-            client.delObject(b, k, opts, function (dErr) {
-                log.debug({
-                    err: dErr
-                }, 'delObject: returned');
+            var readOnlyInfo = {
+                log: log,
+                morayClient: client.hostLabel,
+                indexShards: options.indexShards
+            };
+            isReadOnlyPnode(readOnlyInfo, function (roErr, readOnly) {
+                readOnlyInfo.log.debug({
+                    read_only: readOnly,
+                    read_only_type: typeof (readOnly)
+                }, 'read only status information');
+                if (roErr) {
+                    rpc.fail(roErr);
+                    return;
+                }
+                if (readOnly) {
+                    rpc.fail(new ReadOnlyError(readOnlyInfo.morayClient));
+                    return;
+                }
 
-                dtrace['delobject-done'].fire(function () {
-                    return ([msgid]);
-                });
+                client.delObject(b, k, opts, function (dErr) {
+                    log.debug({
+                        err: dErr
+                    }, 'delObject: returned');
 
-                if (dErr) {
-                    rpc.fail(dErr);
-                } else {
-                    rpc.end();
-                }
+                    dtrace['delobject-done'].fire(function () {
+                        return ([msgid]);
+                    });
+
+                    if (dErr) {
+                        rpc.fail(dErr);
+                    } else {
+                        rpc.end();
+                    }
+                });
             });
         });
     }
@@ -950,6 +1100,7 @@ function findObjects(options) {
     return _findObjects;
 }
 
+// We don't currently support deleteMany operations
 function deleteMany(options) {
     assert.object(options, 'options');
     assert.object(options.log, 'options.log');
@@ -1138,20 +1289,40 @@ function sql(options) {
         });
 
         options.clients.array.forEach(function (client, index) {
-            barrier.start(index);
-            var req = client.sql(stmt, values, opts);
+            var readOnlyInfo = {
+                log: log,
+                morayClient: client.hostLabel,
+                indexShards: options.indexShards
+            };
+            isReadOnlyPnode(readOnlyInfo, function (roErr, readOnly) {
+                readOnlyInfo.log.debug({
+                    read_only: readOnly,
+                    read_only_type: typeof (readOnly)
+                }, 'read only status information');
+                if (roErr) {
+                    rpc.fail(roErr);
+                    return;
+                }
+                if (readOnly && !opts.readOnlyOverride) {
+                    rpc.fail(new ReadOnlyError(readOnlyInfo.morayClient));
+                    return;
+                }
 
-            req.on('record', function (rec) {
-                rpc.write(rec);
-            });
+                barrier.start(index);
+                var req = client.sql(stmt, values, opts);
 
-            req.on('error', function (err2) {
-                err.push(err2);
-                barrier.done(index);
-            });
+                req.on('record', function (rec) {
+                    rpc.write(rec);
+                });
 
-            req.on('end', function () {
-                barrier.done(index);
+                req.on('error', function (err2) {
+                    err.push(err2);
+                    barrier.done(index);
+                });
+
+                req.on('end', function () {
+                    barrier.done(index);
+                });
             });
         });
     }
@@ -1159,7 +1330,7 @@ function sql(options) {
     return _sql;
 }
 
-// we don't currently support update operations
+// We don't currently support update operations
 function updateObjects(options) {
     assert.object(options, 'options');
     assert.object(options.log, 'options.log');
@@ -1197,13 +1368,13 @@ function updateObjects(options) {
 
 
 /*
- * Batching is only supported in a very limited case: when all of the requests
- * have keys with the same value after transformation (if appropriate for their
- * bucket), which allows us to be sure that all of the values live on the same
- * shard.
+ * Batching is only supported in a very limited case: for modifications when all
+ * of the requests have keys with the same value after transformation (if
+ * appropriate for their bucket), which allows us to be sure that all of the
+ * values live on the same shard.
  *
- * Operations like 'update' and 'deleteMany' are not allowed since they cannot
- * be guaranteed to only affect values on a single shard.
+ * The operations 'update' and 'deleteMany' are not allowed since they cannot be
+ * guaranteed to only affect values on a single shard.
  */
 function batch(options) {
     assert.object(options, 'options');
@@ -1302,7 +1473,26 @@ function batch(options) {
             var pnode = node.pnode;
             var client = options.clients.map[pnode];
 
-            client.batch(requests, opts, done);
+            var readOnlyInfo = {
+                log: log,
+                morayClient: client.hostLabel,
+                indexShards: options.indexShards
+            };
+            isReadOnlyPnode(readOnlyInfo, function (roErr, readOnly) {
+                readOnlyInfo.log.debug({
+                    read_only: readOnly,
+                    read_only_type: typeof (readOnly)
+                }, 'read only status information');
+                if (roErr) {
+                    rpc.fail(roErr);
+                    return;
+                }
+                if (readOnly) {
+                    rpc.fail(new ReadOnlyError(readOnlyInfo.morayClient));
+                    return;
+                }
+                client.batch(requests, opts, done);
+            });
         });
     }
 
diff --git a/lib/status_server.js b/lib/status_server.js
new file mode 100644
index 0000000..64fb974
--- /dev/null
+++ b/lib/status_server.js
@@ -0,0 +1,87 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+
+var assert = require('assert-plus');
+var fash = require('fash');
+var fs = require('fs');
+var mod_restify = require('restify');
+var path = require('path');
+var ring = require('./ring');
+
+var Logger = require('bunyan');
+
+///--- GLOBALS
+
+var API_VERSION = 1;
+
+///--- API
+
+// This serves HTTP requests for electric-moray process state access.
+function createStatusServer(options, callback) {
+    assert.object(options, 'options');
+    assert.object(options.log, 'options.log');
+    assert.number(options.port, 'options.port');
+    assert.object(options.ring, 'options.ring');
+    assert.arrayOfString(options.clientList, 'options.clientList');
+    assert.func(callback, 'callback');
+
+    var opts = {
+        log: options.log,
+        startTime: (new Date()).toISOString(),
+        clientList: options.clientList,
+        indexShards: options.indexShards
+    };
+
+    /*
+     * REST API server to access the status of an electric-moray instance.
+     */
+    var server = mod_restify.createServer({
+        name: 'Status'
+    });
+
+    server.get('/status', createStatusHandler(opts));
+
+    server.on('error', function (__err) {
+        opts.log.error(__err, 'restify server error');
+        process.exit(1);
+    });
+
+    server.listen(options.port, function () {
+        opts.log.info('listening on port %d for status server', options.port);
+        callback();
+    });
+
+}
+
+///--- Exports
+
+module.exports = {
+    createStatusServer: createStatusServer
+};
+
+///--- Hash ring topology access
+
+/*
+ * Read state from svcs to find out what shard state is stored in each electric-
+ * moray process.
+ */
+function createStatusHandler(opts) {
+    return (function statusHandler(req, res, next) {
+        var body = {
+            smf_fmri: process.env.SMF_FMRI || null,
+            pid: process.pid,
+            start_time: opts.startTime,
+            client_list: opts.clientList,
+            index_shards: opts.indexShards
+        };
+
+        res.send(200, body);
+    });
+}
diff --git a/main.js b/main.js
index 29bbe3c..703b35d 100644
--- a/main.js
+++ b/main.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2016, Joyent, Inc.
+ * Copyright (c) 2017, Joyent, Inc.
  */
 
 var fs = require('fs');
@@ -181,7 +181,29 @@ function run(options) {
     opts.log = LOG;
     opts.name = NAME;
 
-    app.createServer(opts);
+    app.createServer(opts, function (err, res) {
+        if (err) {
+            LOG.fatal(err, 'startup failed');
+            process.exit(1);
+        }
+
+        assert.object(res, 'res');
+        assert.object(res.ring, 'res.ring');
+        assert.arrayOfString(res.clientList, 'res.clientList');
+
+        app.createStatusServer({
+            log: LOG.child({ component: 'statusServer' }),
+            ring: res.ring,
+            clientList: res.clientList,
+            indexShards: opts.ringCfg.indexShards,
+            port: opts.port + 2000 // Use different port number for this server.
+        }, function (err2) {
+            if (err2) {
+                LOG.fatal(err2, 'status server startup failed');
+                process.exit(1);
+            }
+        });
+    });
 }
 
 
diff --git a/package.json b/package.json
index 065e3bd..9e1c1d8 100644
--- a/package.json
+++ b/package.json
@@ -24,7 +24,7 @@
         "moray": "^3.4.0",
         "node-uuid": "1.4.0",
         "posix-getopt": "^1.0.0",
-        "restify": "5.2.0",
+        "restify": "6.3.1",
         "strsplit": "1.0.0",
         "vasync": "^1.4.3",
         "verror": "1.9.0",
diff --git a/sapi_manifests/electric-moray/template b/sapi_manifests/electric-moray/template
index 813eb65..89e7ade 100644
--- a/sapi_manifests/electric-moray/template
+++ b/sapi_manifests/electric-moray/template
@@ -24,6 +24,11 @@
             "createIfMissing": false,
             "keyEncoding": "utf8",
             "valueEncoding": "json"
-        }
+        },
+        {{! This formatting is necessary to communicate the structure of our indexShards JSON object.  For mustach, our templating engine (and hogan.js, which is mustach for javascript), we have to put the comma in an inverted section, surrounding it with "last" flags, which is a field we use to indicate that mustach/hogan.js should not render a trailing comma, which JSON disallows.}}
+        "indexShards": [ {{#INDEX_MORAY_SHARDS}}
+            { "host": "{{host}}"{{#readOnly}}, "readOnly": {{readOnly}}{{/readOnly}} }{{^last}},{{/last}}{{/INDEX_MORAY_SHARDS}}
+        ]
+
     }
 }
diff --git a/test/resharding/roBuckets.test.js b/test/resharding/roBuckets.test.js
index 73d0c45..70f3427 100644
--- a/test/resharding/roBuckets.test.js
+++ b/test/resharding/roBuckets.test.js
@@ -30,36 +30,6 @@ var after = helper.after;
 var before = helper.before;
 var test = helper.test;
 
-var FULL_CFG = {
-    index: {
-        str: {
-            type: 'string'
-        },
-        str_u: {
-            type: 'string',
-            unique: true
-        },
-        num: {
-            type: 'number'
-        },
-        num_u: {
-            type: 'number',
-            unique: true
-        },
-        bool: {
-            type: 'boolean'
-        },
-        bool_u: {
-            type: 'boolean',
-            unique: true
-        }
-    },
-    pre: [function onePre(req, cb) { cb(); }],
-    post: [function onePost(req, cb) { cb(); }],
-    options: {}
-};
-
-
 
 ///--- Helpers
 
@@ -88,8 +58,7 @@ function assertBucket(name, t, bucket, cfg) {
 }
 
 
-
-///--- tests
+///--- Tests
 
 before(function (cb) {
     this.bucket = 'moray_unit_test_' + uuid.v4().substr(0, 7);
