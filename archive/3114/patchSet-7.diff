From 9d3060db8e98c5b84114109ad9ab92e6f44f15c4 Mon Sep 17 00:00:00 2001
From: Brittany Wald <brittany.wald@joyent.com>
Date: Fri, 1 Dec 2017 02:28:03 +0000
Subject: [PATCH] MANTA-3476 read-only pnodes

---
 boot/setup.sh                          |   4 +
 lib/client.js                          |  92 +++++++++
 lib/errors.js                          |  46 +----
 lib/index.js                           |   6 +-
 lib/server.js                          | 271 ++++++++++++++++++-------
 lib/status_server.js                   |  81 ++++++++
 main.js                                |  36 +++-
 package.json                           |   2 +-
 sapi_manifests/electric-moray/template |  12 +-
 smf/manifests/electric-moray.xml.in    |   5 +-
 test/resharding/roBuckets.test.js      |  33 +--
 11 files changed, 431 insertions(+), 157 deletions(-)
 create mode 100644 lib/client.js
 create mode 100644 lib/status_server.js

diff --git a/boot/setup.sh b/boot/setup.sh
index 7bdcb46..1f2f2e0 100755
--- a/boot/setup.sh
+++ b/boot/setup.sh
@@ -143,9 +143,11 @@ function manta_setup_electric_moray {
     #Build the list of ports.  That'll be used for everything else.
     local ports
     local kangs
+    local statuses
     for (( i=1; i<=$ELECTRIC_MORAY_INSTANCES; i++ )); do
         ports[$i]=`expr 2020 + $i`
         kangs[$i]=`expr 3020 + $i`
+        statuses[$i]=`expr 4020 + $i`
     done
 
     #Regenerate the registrar config with the real ports included
@@ -184,10 +186,12 @@ function manta_setup_electric_moray {
     for (( i=1; i<=$ELECTRIC_MORAY_INSTANCES; i++ )); do
         local port=${ports[$i]}
         local kang=${kangs[$i]}
+        local status=${statuses[$i]}
         local electric_moray_instance="electric-moray-$port"
         local electric_moray_xml_out=$SVC_ROOT/smf/manifests/electric-moray-$port.xml
         sed -e "s#@@ELECTRIC-MORAY_PORT@@#$port#g" \
             -e "s#@@KANG_PORT@@#$kang#g" \
+            -e "s#@@STATUS_PORT@@#$status#g" \
             -e "s#@@ELECTRIC-MORAY_INSTANCE_NAME@@#$electric_moray_instance#g" \
             $electric_moray_xml_in  > $electric_moray_xml_out || \
             fatal "could not process $electric_moray_xml_in to $electric_moray_xml_out"
diff --git a/lib/client.js b/lib/client.js
new file mode 100644
index 0000000..4419711
--- /dev/null
+++ b/lib/client.js
@@ -0,0 +1,92 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+
+var assert = require('assert-plus');
+var clone = require('clone');
+var fs = require('fs');
+var moray = require('moray'); // client
+var url = require('url');
+var verror = require('verror');
+
+/*
+ * Create moray clients in order to interact with moray instances.  Available
+ * moray clients are listed in the ring configuration in LevelDB, which we
+ * access in electric moray via node-fash.
+ */
+function createClient(options, callback) {
+    assert.object(options, 'options');
+    assert.object(options.log, 'options.log');
+    assert.object(options.ring, 'options.ring');
+    assert.object(options.morayOptions, 'options.morayOptions');
+    assert.func(callback, 'options.callback');
+
+    var log = options.log;
+
+    var clientMap = {};
+    var clientArray = [];
+
+    options.ring.getPnodes(function (err, pnodes) {
+        if (err) {
+            throw new verror.VError(err, 'unable to get pnodes');
+        }
+
+        assert.arrayOfString(pnodes, 'pnodes');
+
+        pnodes.forEach(function (pnode) {
+            var pnodeUrl = url.parse(pnode);
+            assert.string(pnodeUrl.port, 'pnodeUrl.port');
+            assert.string(pnodeUrl.hostname, 'pnodeUrl.hostname');
+
+            log.info({
+                url: pnodeUrl
+            }, 'creating moray client');
+
+            var morayargs = clone(options.morayOptions);
+            if (!morayargs.cueballOptions) {
+                morayargs.cueballOptions = {};
+            }
+            morayargs.unwrapErrors = true;
+            morayargs.srvDomain = pnodeUrl.hostname;
+            morayargs.cueballOptions.defaultPort = parseInt(pnodeUrl.port, 10);
+            morayargs.log = options.log.child({
+                component: 'moray-client-' + pnodeUrl.hostname
+            });
+
+            var client = moray.createClient(morayargs);
+            clientMap[pnode] = client;
+            clientArray.push(client);
+
+            if (clientArray.length === pnodes.length) {
+                // write ready cookie when clients have connected
+                log.info('all moray clients instantiated writing ready cookie');
+                try {
+                    fs.writeFileSync('/var/tmp/electric-moray-ready', null);
+                } catch (e) {
+                    throw new verror.VError(e, 'unable to write ready cookie');
+                }
+            }
+        });
+
+        if (clientArray.length <= 0) {
+            throw new verror.VError('No moray clients exist!');
+        }
+
+        return callback(null, {
+            map: clientMap,
+            array: clientArray
+        });
+    });
+}
+
+///--- Exports
+
+module.exports = {
+    createClient: createClient
+};
diff --git a/lib/errors.js b/lib/errors.js
index 101abd9..78a7ac2 100644
--- a/lib/errors.js
+++ b/lib/errors.js
@@ -5,61 +5,37 @@
  */
 
 /*
- * Copyright (c) 2014, Joyent, Inc.
+ * Copyright (c) 2017, Joyent, Inc.
  */
 
-var fs = require('fs');
-var util = require('util');
-
 var assert = require('assert-plus');
+var util = require('util');
 var verror = require('verror');
 
 
 
-
 ///--- Globals
 
 var WError = verror.WError;
 var VError = verror.VError;
 
-var slice = Function.prototype.call.bind(Array.prototype.slice);
-
-
-
-///--- Helpers
-
-function ISODateString(d) {
-    function pad(n) {
-        return n < 10 ? '0' + n : n;
-    }
-
-    if (typeof (d) === 'string')
-        d = new Date(d);
-
-    return d.getUTCFullYear() + '-'
-        + pad(d.getUTCMonth()+1) + '-'
-        + pad(d.getUTCDate()) + 'T'
-        + pad(d.getUTCHours()) + ':'
-        + pad(d.getUTCMinutes()) + ':'
-        + pad(d.getUTCSeconds()) + 'Z';
-}
-
 
 
 ///--- Errors
 
 function InvocationError() {
-        VError.apply(this, arguments);
-        this.name = this.constructor.name;
+    VError.apply(this, arguments);
+    this.name = this.constructor.name;
 }
 util.inherits(InvocationError, VError);
 
-function ReadOnlyError(cause) {
-        if (arguments.length === 0) {
-                cause = {};
-        }
-        WError.call(this, cause, 'some vnodes are in read-only mode');
-        this.name = this.constructor.name;
+function ReadOnlyError(pnode) {
+    if (!pnode) {
+        WError.call(this, {}, 'some vnodes are in read-only mode');
+    } else {
+        WError.call(this, pnode, 'pnode "%s" is in read-only mode');
+    }
+    this.name = this.constructor.name;
 }
 util.inherits(ReadOnlyError, WError);
 
diff --git a/lib/index.js b/lib/index.js
index 67c2c58..ba40df8 100644
--- a/lib/index.js
+++ b/lib/index.js
@@ -5,16 +5,18 @@
  */
 
 /*
- * Copyright (c) 2016, Joyent, Inc.
+ * Copyright (c) 2017, Joyent, Inc.
  */
 
 var server = require('./server');
+var status_server = require('./status_server');
 
 
 ///--- Exports
 
 module.exports = {
 
-    createServer: server.createServer
+    createServer: server.createServer,
+    createStatusServer: status_server.createStatusServer
 
 };
diff --git a/lib/server.js b/lib/server.js
index 2348b70..133597f 100644
--- a/lib/server.js
+++ b/lib/server.js
@@ -10,20 +10,18 @@
 
 var assert = require('assert-plus');
 var artedi = require('artedi');
-var clone = require('clone');
 var fast = require('fast');
 var fs = require('fs');
 var kang = require('kang');
-var moray_client = require('moray'); // client
 var net = require('net');
 var os = require('os');
 var restify = require('restify');
 var uuid = require('node-uuid');
-var url = require('url');
 var util = require('util');
 var vasync = require('vasync');
 var verror = require('verror');
 
+var moray_client = require('./client');
 var dtrace = require('./dtrace');
 var errors = require('./errors');
 var schema = require('./schema');
@@ -121,8 +119,9 @@ var UO_ARGS_SCHEMA = [
 
 ///--- API
 
-function createServer(options) {
+function createServer(options, callback) {
     assert.object(options, 'options');
+    assert.func(callback, 'callback');
     assert.string(options.ringLocation, 'options.ringLocation');
 
     var log = options.log;
@@ -150,7 +149,7 @@ function createServer(options) {
         opts.ring = _ring;
 
         log.info('creating moray clients');
-        createClient({
+        moray_client.createClient({
             ring: opts.ring,
             morayOptions: options.morayOptions,
             log: options.log
@@ -160,6 +159,7 @@ function createServer(options) {
             }
 
             opts.clients = clients;
+            opts.indexShards = options.ringCfg.indexShards;
 
             var collector = artedi.createCollector();
 
@@ -234,6 +234,10 @@ function createServer(options) {
 
             socket.on('listening', function () {
                 log.info('moray listening on %d', options.port);
+                callback(null, {
+                    ring: opts.ring,
+                    clientList: Object.keys(opts.clients.map)
+                });
             });
 
             socket.on('error', function (serr) {
@@ -303,11 +307,98 @@ function invalidArgs(rpc, argv, types) {
     return false;
 }
 
-//TODO; No bucket modification can occur whilst re-sharding.
+/*
+ * Returns a list of pnodes that are not safe for write operations. 'ro' is an
+ * object that holds a logger and the sapi_manifest's index shard map.
+ */
+function listReadOnlyPnodes(ro) {
+    assert.object(ro, 'ro');
+    assert.object(ro.log, 'ro.log');
+    assert.arrayOfObject(ro.indexShards, 'indexShards');
+    assert.object(ro.morayClients, 'morayClients');
+
+    ro.log.debug({
+        morayClients: ro.morayClients,
+        indexShards: ro.indexShards
+    }, 'listReadOnlyPnodes: entered');
+
+    var readOnlyPnodes = [];
+    vasync.forEachParallel({
+        'func': (function (client) {
+            assert.string(client, 'client');
+            var clientLabel = client.split('tcp://')[1].split(':')[0];
+            ro.morayClient = clientLabel;
+            if (isReadOnlyPnode(ro)) {
+                readOnlyPnodes.push(ro.morayClient);
+            }
+        }),
+        'inputs': Object.keys(ro.morayClients.map)
+    }, function (err, results) {
+        if (err) {
+            ro.log.debug({
+                morayClients: ro.morayClients,
+                indexShards: ro.indexShards
+            }, 'listReadOnlyPnodes: error');
+            return;
+        }
+        ro.log.info({
+            results: results
+        }, 'listReadOnlyPnodes: results');
+    });
+
+    return readOnlyPnodes;
+}
+
+/*
+ * Checks if a moray client is set to read-only mode. 'ro' is an object that
+ * holds information about the moray client we are accessing in a given rpc, as
+ * well as a logger and the sapi_manifest's index shard map.
+ */
+function isReadOnlyPnode(ro) {
+    assert.object(ro, 'ro');
+    assert.object(ro.log, 'ro.log');
+    assert.arrayOfObject(ro.indexShards, 'indexShards');
+    assert.string(ro.morayClient, 'morayClient');
+
+    ro.log.debug({
+        morayClient: ro.morayClient,
+        indexShards: ro.indexShards
+    }, 'isReadOnlyPnode: entered');
+
+    var readOnlyStatus = null;
+    for (var i = 0; i < ro.indexShards.length; i++) {
+        var shard = ro.indexShards[i];
+        assert.string(shard.host, 'shard.host');
+        assert.optionalBool(shard.readOnly, 'shard.readOnly');
+        if (shard.host === ro.morayClient) {
+            /*
+             * A shard in indexShards may not have a 'readOnly' field, which
+             * means it is not set to read-only mode.
+             */
+            readOnlyStatus = !!shard.readOnly;
+            return readOnlyStatus;
+        }
+    }
+
+    /*
+     * If no shard's host field in indexShards matches the morayClient passed to
+     * this function, we are in an inconsistent state, and it is safer to assume
+     * that the morayClient is read-only than the alternative, which may result
+     * in writes in error.
+     */
+    ro.log.debug({
+        morayClient: ro.morayClient,
+        indexShards: ro.indexShards
+    }, 'isReadOnlyPnode: morayClient not found in indexShards');
+    return true;
+}
+
+
 function createBucket(options) {
     assert.object(options, 'options');
     assert.object(options.log, 'options.log');
     assert.object(options.clients, 'options.clients');
+    assert.object(options.indexShards, 'options.indexShards');
 
     function _createBucket(rpc) {
         var argv = rpc.argv();
@@ -344,6 +435,18 @@ function createBucket(options) {
         var err = [];
         var done = 0;
 
+        var readOnlyInfo = {
+            log: log,
+            morayClients: options.clients,
+            indexShards: options.indexShards
+        };
+
+        var readOnlyPnodes = listReadOnlyPnodes(readOnlyInfo);
+        if (readOnlyPnodes.length > 0) {
+            rpc.fail(new ReadOnlyError(readOnlyPnodes.join(', ')));
+            return;
+        }
+
         options.clients.array.forEach(function (client) {
             client.createBucket(name, cfg, opts, function (err2) {
                 log.debug({
@@ -356,7 +459,8 @@ function createBucket(options) {
                 }
 
                 if (++done === options.clients.array.length) {
-                    var multiError = err[0] ? new verror.MultiError(err) : null;
+                    var multiError = err[0]
+                        ? new verror.MultiError(err) : null;
                     log.debug({
                         err: multiError
                     }, 'createBucket: finished all shards');
@@ -492,6 +596,18 @@ function updateBucket(options) {
         var err = [];
         var done = 0;
 
+        var readOnlyInfo = {
+            log: log,
+            morayClients: options.clients,
+            indexShards: options.indexShards
+        };
+
+        var readOnlyPnodes = listReadOnlyPnodes(readOnlyInfo);
+        if (readOnlyPnodes.length > 0) {
+            rpc.fail(new ReadOnlyError(readOnlyPnodes.join(', ')));
+            return;
+        }
+
         options.clients.array.forEach(function (client) {
             client.updateBucket(name, cfg, function (err2) {
                 log.debug({
@@ -503,7 +619,8 @@ function updateBucket(options) {
                 }
 
                 if (++done === options.clients.array.length) {
-                    var multiError = err[0] ? new verror.MultiError(err) : null;
+                    var multiError = err[0] ?
+                        new verror.MultiError(err) : null;
                     log.debug({
                         err: multiError
                     }, 'updateBucket: finished all shards');
@@ -559,6 +676,18 @@ function delBucket(options) {
         var err = [];
         var done = 0;
 
+        var readOnlyInfo = {
+            log: log,
+            morayClients: options.clients,
+            indexShards: options.indexShards
+        };
+
+        var readOnlyPnodes = listReadOnlyPnodes(readOnlyInfo);
+        if (readOnlyPnodes.length > 0) {
+            rpc.fail(new ReadOnlyError(readOnlyPnodes.join(', ')));
+            return;
+        }
+
         options.clients.array.forEach(function (client) {
             client.delBucket(name, function (err2) {
                 log.debug({
@@ -570,7 +699,8 @@ function delBucket(options) {
                 }
 
                 if (++done === options.clients.array.length) {
-                    var multiError = err[0] ? new verror.MultiError(err) : null;
+                    var multiError = err[0] ?
+                        new verror.MultiError(err) : null;
                     log.debug({
                         err: multiError
                     }, 'delBucket: finished all shards');
@@ -642,6 +772,18 @@ function putObject(options) {
             v.vnode = node.vnode;
             var pnode = node.pnode;
             var client = options.clients.map[pnode];
+
+            var readOnlyInfo = {
+                log: log,
+                morayClient: client.hostLabel,
+                indexShards: options.indexShards
+            };
+
+            if (isReadOnlyPnode(readOnlyInfo)) {
+                rpc.fail(new ReadOnlyError(readOnlyInfo.morayClient));
+                return;
+            }
+
             client.putObject(b, k, v, opts, function (pErr, meta) {
                 log.debug({
                     err: pErr,
@@ -796,6 +938,17 @@ function delObject(options) {
                 return;
             }
             var client = options.clients.map[node.pnode];
+            var readOnlyInfo = {
+                log: log,
+                morayClient: client.hostLabel,
+                indexShards: options.indexShards
+            };
+
+            if (isReadOnlyPnode(readOnlyInfo)) {
+                rpc.fail(new ReadOnlyError(readOnlyInfo.morayClient));
+                return;
+            }
+
             client.delObject(b, k, opts, function (dErr) {
                 log.debug({
                     err: dErr
@@ -950,6 +1103,7 @@ function findObjects(options) {
     return _findObjects;
 }
 
+// We don't currently support deleteMany operations
 function deleteMany(options) {
     assert.object(options, 'options');
     assert.object(options.log, 'options.log');
@@ -1021,68 +1175,6 @@ function getTokens(options) {
     return _getTokens;
 }
 
-function createClient(options, callback) {
-    assert.object(options, 'options');
-    assert.object(options.log, 'options.log');
-    assert.object(options.ring, 'options.ring');
-    assert.object(options.morayOptions, 'options.morayOptions');
-    assert.func(callback, 'options.callback');
-
-    var log = options.log;
-
-    var clientMap = {};
-    var clientArray = [];
-
-    options.ring.getPnodes(function (err, pnodes) {
-        if (err) {
-            throw new verror.VError(err, 'unable to get pnodes');
-        }
-        pnodes.forEach(function (pnode) {
-            var pnodeUrl = url.parse(pnode);
-            assert.string(pnodeUrl.port, 'pnodeUrl.port');
-            assert.string(pnodeUrl.hostname, 'pnodeUrl.hostname');
-
-            log.info({
-                url: pnodeUrl
-            }, 'creating moray client');
-
-            var morayargs = clone(options.morayOptions);
-            if (!morayargs.cueballOptions) {
-                morayargs.cueballOptions = {};
-            }
-            morayargs.unwrapErrors = true;
-            morayargs.srvDomain = pnodeUrl.hostname;
-            morayargs.cueballOptions.defaultPort = parseInt(pnodeUrl.port, 10);
-            morayargs.log = options.log.child({
-                component: 'moray-client-' + pnodeUrl.hostname
-            });
-
-            var client = moray_client.createClient(morayargs);
-            clientMap[pnode] = client;
-            clientArray.push(client);
-
-            if (clientArray.length === pnodes.length) {
-                // write ready cookie when clients have connected
-                log.info('all moray clients instantiated writing ready cookie');
-                try {
-                    fs.writeFileSync('/var/tmp/electric-moray-ready', null);
-                } catch (e) {
-                    throw new verror.VError(e, 'unable to write ready cookie');
-                }
-            }
-        });
-
-        if (clientArray.length <= 0) {
-            throw new verror.VError('No moray clients exist!');
-        }
-
-        return callback(null, {
-            map: clientMap,
-            array: clientArray
-        });
-    });
-}
-
 function sql(options) {
     assert.object(options, 'options');
     assert.object(options.log, 'options.log');
@@ -1137,6 +1229,18 @@ function sql(options) {
             }
         });
 
+        var readOnlyInfo = {
+            log: log,
+            morayClients: options.clients,
+            indexShards: options.indexShards
+        };
+
+        var readOnlyPnodes = listReadOnlyPnodes(readOnlyInfo);
+        if (readOnlyPnodes.length > 0) {
+            rpc.fail(new ReadOnlyError(readOnlyPnodes.join(', ')));
+            return;
+        }
+
         options.clients.array.forEach(function (client, index) {
             barrier.start(index);
             var req = client.sql(stmt, values, opts);
@@ -1159,7 +1263,7 @@ function sql(options) {
     return _sql;
 }
 
-// we don't currently support update operations
+// We don't currently support update operations
 function updateObjects(options) {
     assert.object(options, 'options');
     assert.object(options.log, 'options.log');
@@ -1197,13 +1301,13 @@ function updateObjects(options) {
 
 
 /*
- * Batching is only supported in a very limited case: when all of the requests
- * have keys with the same value after transformation (if appropriate for their
- * bucket), which allows us to be sure that all of the values live on the same
- * shard.
+ * Batching is only supported in a very limited case: for modifications when all
+ * of the requests have keys with the same value after transformation (if
+ * appropriate for their bucket), which allows us to be sure that all of the
+ * values live on the same shard.
  *
- * Operations like 'update' and 'deleteMany' are not allowed since they cannot
- * be guaranteed to only affect values on a single shard.
+ * The operations 'update' and 'deleteMany' are not allowed since they cannot be
+ * guaranteed to only affect values on a single shard.
  */
 function batch(options) {
     assert.object(options, 'options');
@@ -1302,6 +1406,17 @@ function batch(options) {
             var pnode = node.pnode;
             var client = options.clients.map[pnode];
 
+            var readOnlyInfo = {
+                log: log,
+                morayClient: client.hostLabel,
+                indexShards: options.indexShards
+            };
+
+            if (isReadOnlyPnode(readOnlyInfo)) {
+                rpc.fail(new ReadOnlyError(readOnlyInfo.morayClient));
+                return;
+            }
+
             client.batch(requests, opts, done);
         });
     }
diff --git a/lib/status_server.js b/lib/status_server.js
new file mode 100644
index 0000000..2e8306a
--- /dev/null
+++ b/lib/status_server.js
@@ -0,0 +1,81 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+
+var assert = require('assert-plus');
+var mod_restify = require('restify');
+
+///--- GLOBALS
+
+var API_VERSION = 1;
+
+///--- API
+
+// This serves HTTP requests for electric-moray process state access.
+function createStatusServer(options, callback) {
+    assert.object(options, 'options');
+    assert.object(options.log, 'options.log');
+    assert.number(options.port, 'options.port');
+    assert.object(options.ring, 'options.ring');
+    assert.arrayOfString(options.clientList, 'options.clientList');
+    assert.func(callback, 'callback');
+
+    var opts = {
+        log: options.log,
+        startTime: (new Date()).toISOString(),
+        clientList: options.clientList,
+        indexShards: options.indexShards
+    };
+
+    /*
+     * REST API server to access the status of an electric-moray instance.
+     */
+    var server = mod_restify.createServer({
+        name: 'Status'
+    });
+
+    server.get('/status', createStatusHandler(opts));
+
+    server.on('error', function (__err) {
+        opts.log.error(__err, 'restify server error');
+        process.exit(1);
+    });
+
+    server.listen(options.port, function () {
+        opts.log.info('listening on port %d for status server', options.port);
+        callback();
+    });
+
+}
+
+///--- Exports
+
+module.exports = {
+    createStatusServer: createStatusServer
+};
+
+///--- Hash ring topology access
+
+/*
+ * Read state from svcs to find out what shard state is stored in each electric-
+ * moray process.
+ */
+function createStatusHandler(opts) {
+    return (function statusHandler(req, res, next) {
+        var body = {
+            smf_fmri: process.env.SMF_FMRI || null,
+            pid: process.pid,
+            start_time: opts.startTime,
+            client_list: opts.clientList,
+            index_shards: opts.indexShards
+        };
+
+        res.send(200, body);
+    });
+}
diff --git a/main.js b/main.js
index 29bbe3c..542479e 100644
--- a/main.js
+++ b/main.js
@@ -5,16 +5,14 @@
  */
 
 /*
- * Copyright (c) 2016, Joyent, Inc.
+ * Copyright (c) 2017, Joyent, Inc.
  */
 
-var fs = require('fs');
-var os = require('os');
-
 var assert = require('assert-plus');
 var bsyslog = require('bunyan-syslog');
 var bunyan = require('bunyan');
 var clone = require('clone');
+var fs = require('fs');
 var jsprim = require('jsprim');
 var getopt = require('posix-getopt');
 var VError = require('verror');
@@ -33,6 +31,7 @@ var DEFAULTS = {
     file: process.cwd() + '/etc/config.json',
     port: 2020,
     monitorPort: 3020,
+    statusPort: 4020,
     bindip: '0.0.0.0'
 };
 var NAME = 'electric-moray';
@@ -111,7 +110,7 @@ function parsePort(str) {
 function parseOptions() {
     var option;
     var opts = {};
-    var parser = new getopt.BasicParser('cvf:r:p:k:', process.argv);
+    var parser = new getopt.BasicParser('cvf:r:p:k:s:', process.argv);
 
     while ((option = parser.getopt()) !== undefined) {
         switch (option.option) {
@@ -130,6 +129,9 @@ function parseOptions() {
             case 'k':
                 opts.monitorPort = parsePort(option.optarg);
                 break;
+            case 's':
+                opts.statusPort = parsePort(option.optarg);
+                break;
             case 'v':
                 // Allows us to set -vvv -> this little hackery just ensures
                 // that we're never < TRACE
@@ -181,7 +183,29 @@ function run(options) {
     opts.log = LOG;
     opts.name = NAME;
 
-    app.createServer(opts);
+    app.createServer(opts, function (err, res) {
+        if (err) {
+            LOG.fatal(err, 'startup failed');
+            process.exit(1);
+        }
+
+        assert.object(res, 'res');
+        assert.object(res.ring, 'res.ring');
+        assert.arrayOfString(res.clientList, 'res.clientList');
+
+        app.createStatusServer({
+            log: LOG.child({ component: 'statusServer' }),
+            ring: res.ring,
+            clientList: res.clientList,
+            indexShards: opts.ringCfg.indexShards,
+            port: opts.statusPort
+        }, function (err2) {
+            if (err2) {
+                LOG.fatal(err2, 'status server startup failed');
+                process.exit(1);
+            }
+        });
+    });
 }
 
 
diff --git a/package.json b/package.json
index 065e3bd..9e1c1d8 100644
--- a/package.json
+++ b/package.json
@@ -24,7 +24,7 @@
         "moray": "^3.4.0",
         "node-uuid": "1.4.0",
         "posix-getopt": "^1.0.0",
-        "restify": "5.2.0",
+        "restify": "6.3.1",
         "strsplit": "1.0.0",
         "vasync": "^1.4.3",
         "verror": "1.9.0",
diff --git a/sapi_manifests/electric-moray/template b/sapi_manifests/electric-moray/template
index 813eb65..7d7a959 100644
--- a/sapi_manifests/electric-moray/template
+++ b/sapi_manifests/electric-moray/template
@@ -24,6 +24,16 @@
             "createIfMissing": false,
             "keyEncoding": "utf8",
             "valueEncoding": "json"
-        }
+        },
+        {{! This formatting is necessary to communicate the structure of our
+        indexShards JSON object.  For mustach, our templating engine (and
+        hogan.js, which is mustach for javascript), we have to put the comma in
+        an inverted section, surrounding it with "last" flags, which is a field
+        we use to indicate that mustach/hogan.js should not render a trailing
+        comma, which JSON disallows.}}
+        "indexShards": [ {{#INDEX_MORAY_SHARDS}}
+            { "host": "{{host}}"{{#readOnly}}, "readOnly": {{readOnly}}{{/readOnly}} }{{^last}},{{/last}}{{/INDEX_MORAY_SHARDS}}
+        ]
+
     }
 }
diff --git a/smf/manifests/electric-moray.xml.in b/smf/manifests/electric-moray.xml.in
index e810c3e..eb4ba8a 100644
--- a/smf/manifests/electric-moray.xml.in
+++ b/smf/manifests/electric-moray.xml.in
@@ -7,7 +7,7 @@
 -->
 
 <!--
-    Copyright (c) 2014, Joyent, Inc.
+    Copyright (c) 2017, Joyent, Inc.
 -->
 
 <service_bundle type="manifest" name="-electric-moray">
@@ -44,7 +44,7 @@
         <exec_method
             type="method"
             name="start"
-            exec="node --abort-on-uncaught-exception main.js -f etc/config.json -r %{electric-moray/ring-location} -p %{electric-moray/port} -k %{electric-moray/kang} &amp;"
+            exec="node --abort-on-uncaught-exception main.js -f etc/config.json -r %{electric-moray/ring-location} -p %{electric-moray/port} -k %{electric-moray/kang} -s %{electric-moray/status} &amp;"
             timeout_seconds="30">
             <method_context working_directory="/opt/smartdc/electric-moray">
                 <method_credential user="root" group="nobody" />
@@ -69,6 +69,7 @@
             <property_group name="electric-moray" type="application">
                 <propval name="port" type="astring" value="@@ELECTRIC-MORAY_PORT@@" />
                 <propval name="kang" type="astring" value="@@KANG_PORT@@" />
+                <propval name="status" type="astring" value="@@STATUS_PORT@@" />
                 <propval name="ring-location" type="astring" value="/electric-moray/chash/leveldb-@@ELECTRIC-MORAY_PORT@@" />
             </property_group>
         </instance>
diff --git a/test/resharding/roBuckets.test.js b/test/resharding/roBuckets.test.js
index 73d0c45..70f3427 100644
--- a/test/resharding/roBuckets.test.js
+++ b/test/resharding/roBuckets.test.js
@@ -30,36 +30,6 @@ var after = helper.after;
 var before = helper.before;
 var test = helper.test;
 
-var FULL_CFG = {
-    index: {
-        str: {
-            type: 'string'
-        },
-        str_u: {
-            type: 'string',
-            unique: true
-        },
-        num: {
-            type: 'number'
-        },
-        num_u: {
-            type: 'number',
-            unique: true
-        },
-        bool: {
-            type: 'boolean'
-        },
-        bool_u: {
-            type: 'boolean',
-            unique: true
-        }
-    },
-    pre: [function onePre(req, cb) { cb(); }],
-    post: [function onePost(req, cb) { cb(); }],
-    options: {}
-};
-
-
 
 ///--- Helpers
 
@@ -88,8 +58,7 @@ function assertBucket(name, t, bucket, cfg) {
 }
 
 
-
-///--- tests
+///--- Tests
 
 before(function (cb) {
     this.bucket = 'moray_unit_test_' + uuid.v4().substr(0, 7);
-- 
2.21.0

