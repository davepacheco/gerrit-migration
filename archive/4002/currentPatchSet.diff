commit 2072a5fbc8e07c4e4c554c87a0623930d7bfadd8 (refs/changes/02/4002/1)
Author: Mike Gerdts <mike.gerdts@joyent.com>
Date:   2018-05-22T20:52:25+00:00 (1 year, 5 months ago)
    
    OS-6717 bhyve brand boot should not succeed until bhyve allocates resources

diff --git a/usr/src/lib/brand/bhyve/zone/bootwait.c b/usr/src/lib/brand/bhyve/zone/bootwait.c
new file mode 100644
index 0000000000..5e88890213
--- /dev/null
+++ b/usr/src/lib/brand/bhyve/zone/bootwait.c
@@ -0,0 +1,140 @@
+/*
+ * This file and its contents are supplied under the terms of the
+ * Common Development and Distribution License ("CDDL"), version 1.0.
+ * You may only use this file in accordance with the terms of version
+ * 1.0 of the CDDL.
+ *
+ * A full copy of the text of the CDDL should have accompanied this
+ * source.  A copy of the CDDL is also available via the Internet at
+ * http://www.illumos.org/license/CDDL.
+ */
+
+/*
+ * Copyright (c) 2018, Joyent, Inc.
+ */
+
+/*
+ * Usage:
+ *
+ * bootwait zonename <setup|wait>
+ *
+ * This program enters the specified zone and creates a flag file (setup) or
+ * waits for its removal (wait).  "setup" is used in a preboot hook to create
+ * the file.  "wait" is used in a postboot hook to detect when the zone is ready
+ * to perform its duties.  Something in the zone (i.e. bhyve) is expected to
+ * remove the wait file when it considers the boot to be complete.
+ *
+ * This program returns 0 on success or non-zero on failure.
+ *
+ * In the event that the zone is halted (e.g. due to death of its init process),
+ * this process will be killed, resulting in a non-zero exit value.
+ */
+
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <stdio.h>
+#include <zone.h>
+
+#define	WAITFILE	"/var/run/bootwait"
+
+const char *prog;
+
+static void
+do_setup(void)
+{
+	int fd;
+
+	fd = open(WAITFILE, O_CREAT|O_EXCL|O_WRONLY, 0600);
+	if (fd == -1) {
+		(void) fprintf(stderr, "%s: cannot create %s: %s\n",
+		    prog, WAITFILE, strerror(errno));
+		exit(1);
+	}
+	exit(0);
+}
+
+static void
+do_wait(void)
+{
+	int portfd;
+	int fd;
+	struct file_obj fobj = { 0 };
+	port_event_t pev;
+	timespec_t timeout = { 0 };
+
+	fobj.fo_name = WAITFILE;
+
+	if ((portfd = port_create()) == -1) {
+		(void) fprintf(stderr, "%s: port_create: %s\n", prog,
+		    strerror(errno));
+		exit(1);
+	}
+
+	/* Start watching for removals */
+	if (port_associate(portfd, PORT_SOURCE_FILE, (uintptr_t)&fobj,
+	    FILE_DELETE, NULL) == -1) {
+		(void) fprintf(stderr, "%s: port_associate: %s\n", prog,
+		    strerror(errn0));
+		exit(1);
+	}
+
+	/* Make sure it is still there */
+	if ((fd = open(WAITFILE, O_RDONLY)) == -1) {
+		if (errno != ENOENT) {
+			(void) fprintf(stderr, "%s: %s: %s\n", prog,
+			    WAITFILE, strerror(errno));
+			exit(1);
+		}
+	} else {
+		(void) close(fd);
+	}
+
+	if (port_get(portfd, &pev, &timeout) == -1) {
+		(void) fprintf(stderr, "%s: port_get: %s\n", prog,
+		    strerror(errno));
+		exit(1);
+	}
+	exit(0);
+}
+
+int
+main(int argc, char **argv)
+{
+	zoneid_t zid;
+	const char *zonename;
+	const char *cmd;
+
+	prot = argv[0];
+
+	if (argc != 3) {
+		(void) fprintf(stderr, "Usage: %s zonename <setup|wait>\n",
+		    prog);
+		return (1);
+	}
+	zonename = argv[1];
+	cmd = argv[2];
+
+	if ((zid = getzoneidbyname(zonename)) == ZONE_ID_UNDEFINED) {
+		(void) fprintf(stderr, "%s: No zone id for zone '%s'\n",
+		    prog, zonename);
+		return (1);
+	}
+
+	if (zone_enter(zid) == -1) {
+		(void) fprintf(stderr, "%s: Unable to enter zone %s: %s\n",
+		    prog, zonename, strerror(errno));
+		return (1);
+	}
+
+	if (strcmp(cmd, "setup") == 0) {
+		do_setup();
+	}
+
+	if (strcmp(cmd, "wait") == 0) {
+		do_wait();
+	}
+
+	(void) fprintf(stderr, "%s: invalid subcommand '%s'\n", prog, cmd);
+	return (1);
+}
