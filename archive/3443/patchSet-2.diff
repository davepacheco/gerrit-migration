From dcd37c74bbb5ea87b86c8848f298a7a9f0c687f4 Mon Sep 17 00:00:00 2001
From: Patrick Mooney <pmooney@pfmooney.com>
Date: Thu, 19 Oct 2017 21:00:23 +0000
Subject: [PATCH] OS-6414 bhyve should be pbchk clean

---
 exception_lists/copyright                   | 65 ++++++++++++++
 exception_lists/cstyle                      | 65 ++++++++++++++
 exception_lists/hdrchk                      | 49 +++++++++++
 usr/src/cmd/bhyve/bhyve_sol_glue.c          |  7 +-
 usr/src/cmd/bhyve/pci_virtio_viona.c        |  2 +-
 usr/src/cmd/bhyveconsole/bhyveconsole.c     | 11 ++-
 usr/src/cmd/bhyveload-uefi/bhyveload-uefi.c | 17 ++--
 usr/src/lib/libvmmapi/common/mapfile-vers   | 97 +++++++++++----------
 usr/src/uts/i86pc/io/viona/viona.c          |  6 +-
 usr/src/uts/i86pc/io/vmm/vmm_sol_dev.c      | 40 ++++-----
 usr/src/uts/i86pc/io/vmm/vmm_sol_glue.c     | 29 +++---
 usr/src/uts/i86pc/io/vmm/vmm_sol_mem.c      |  6 +-
 usr/src/uts/i86pc/sys/viona_io.h            |  5 +-
 usr/src/uts/i86pc/sys/vmm_impl.h            |  2 +-
 14 files changed, 288 insertions(+), 113 deletions(-)

diff --git a/exception_lists/copyright b/exception_lists/copyright
index 703b86f29f..e2832bfc2c 100644
--- a/exception_lists/copyright
+++ b/exception_lists/copyright
@@ -484,3 +484,68 @@ usr/src/uts/common/sys/THIRDPARTYLICENSE.firmload
 usr/src/uts/common/sys/THIRDPARTYLICENSE.firmload.descrip
 usr/src/uts/common/sys/scsi/adapters/mpt_sas/mpi/*
 usr/src/uts/sparc/nsmb/ioc_check.ref
+
+# bhyve sources
+usr/src/cmd/bhyve/acpi.h
+usr/src/cmd/bhyve/ahci.h
+usr/src/cmd/bhyve/atkbdc.[ch]
+usr/src/cmd/bhyve/bhyvegc.[ch]
+usr/src/cmd/bhyve/bhyverun.[ch]
+usr/src/cmd/bhyve/block_if.[ch]
+usr/src/cmd/bhyve/console.[ch]
+usr/src/cmd/bhyve/consport.c
+usr/src/cmd/bhyve/dbgport.h
+usr/src/cmd/bhyve/inout.[ch]
+usr/src/cmd/bhyve/ioapic.[ch]
+usr/src/cmd/bhyve/mem.[ch]
+usr/src/cmd/bhyve/mptbl.[ch]
+usr/src/cmd/bhyve/pci_ahci.c
+usr/src/cmd/bhyve/pci_emul.[ch]
+usr/src/cmd/bhyve/pci_hostbridge.c
+usr/src/cmd/bhyve/pci_irq.[ch]
+usr/src/cmd/bhyve/pci_lpc.[ch]
+usr/src/cmd/bhyve/pci_virtio_block.c
+usr/src/cmd/bhyve/pci_virtio_net.c
+usr/src/cmd/bhyve/pm.c
+usr/src/cmd/bhyve/pmtmr.c
+usr/src/cmd/bhyve/post.c
+usr/src/cmd/bhyve/ps2kbd.[ch]
+usr/src/cmd/bhyve/ps2mouse.[ch]
+usr/src/cmd/bhyve/rfb.[ch]
+usr/src/cmd/bhyve/rtc.[ch]
+usr/src/cmd/bhyve/smbiostbl.[ch]
+usr/src/cmd/bhyve/spinup_ap.[ch]
+usr/src/cmd/bhyve/uart_emul.[ch]
+usr/src/cmd/bhyve/vga.[ch]
+usr/src/cmd/bhyve/virtio.[ch]
+usr/src/cmd/bhyve/xmsr.[ch]
+usr/src/cmd/bhyvectl/bhyvectl.c
+usr/src/compat/freebsd/*.h
+usr/src/compat/freebsd/*/*.h
+usr/src/compat/freebsd/amd64/machine/*.h
+usr/contrib/freebsd/*/*.h
+usr/contrib/freebsd/*/*/*.h
+usr/contrib/freebsd/lib/libutil/expand_number.c
+usr/src/head/bhyve.h
+usr/src/lib/libvmmapi/common/vmmapi.[ch]
+usr/src/uts/i86pc/io/vmm/amd/*.c
+usr/src/uts/i86pc/io/vmm/intel/*.[chs]
+usr/src/uts/i86pc/io/vmm/io/*.[ch]
+usr/src/uts/i86pc/io/vmm/vmm.c
+usr/src/uts/i86pc/io/vmm/vmm_host.[ch]
+usr/src/uts/i86pc/io/vmm/vmm_instruction_emul.c
+usr/src/uts/i86pc/io/vmm/vmm_ioport.[ch]
+usr/src/uts/i86pc/io/vmm/vmm_ipi.h
+usr/src/uts/i86pc/io/vmm/vmm_ktr.h
+usr/src/uts/i86pc/io/vmm/vmm_lapic.[ch]
+usr/src/uts/i86pc/io/vmm/vmm_mem.h
+usr/src/uts/i86pc/io/vmm/vmm_sol_dev.c
+usr/src/uts/i86pc/io/vmm/vmm_sol_glue.c
+usr/src/uts/i86pc/io/vmm/vmm_sol_mem.c
+usr/src/uts/i86pc/io/vmm/vmm_stat.h
+usr/src/uts/i86pc/io/vmm/vmm_util.[ch]
+usr/src/uts/i86pc/io/vmm/vmx_assym.s
+usr/src/uts/i86pc/io/vmm/x86.[ch]
+usr/src/uts/i86pc/sys/vmm.h
+usr/src/uts/i86pc/sys/vmm_dev.h
+usr/src/uts/i86pc/sys/vmm_instruction_emul.h
diff --git a/exception_lists/cstyle b/exception_lists/cstyle
index 634a0fc102..60712bf30e 100644
--- a/exception_lists/cstyle
+++ b/exception_lists/cstyle
@@ -1387,3 +1387,68 @@ usr/src/uts/intel/sys/acpi/platform/acos2.h
 usr/src/uts/intel/sys/acpi/platform/acsolaris.h
 usr/src/uts/intel/sys/acpi/platform/acwin.h
 usr/src/uts/intel/sys/acpi/platform/acwin64.h
+
+# bhyve sources
+syntax: glob
+usr/src/cmd/bhyve/acpi.h
+usr/src/cmd/bhyve/ahci.h
+usr/src/cmd/bhyve/atkbdc.[ch]
+usr/src/cmd/bhyve/bhyvegc.[ch]
+usr/src/cmd/bhyve/bhyverun.[ch]
+usr/src/cmd/bhyve/block_if.[ch]
+usr/src/cmd/bhyve/console.[ch]
+usr/src/cmd/bhyve/consport.c
+usr/src/cmd/bhyve/dbgport.h
+usr/src/cmd/bhyve/inout.[ch]
+usr/src/cmd/bhyve/ioapic.[ch]
+usr/src/cmd/bhyve/mem.[ch]
+usr/src/cmd/bhyve/mptbl.[ch]
+usr/src/cmd/bhyve/pci_ahci.c
+usr/src/cmd/bhyve/pci_emul.[ch]
+usr/src/cmd/bhyve/pci_hostbridge.c
+usr/src/cmd/bhyve/pci_irq.[ch]
+usr/src/cmd/bhyve/pci_lpc.[ch]
+usr/src/cmd/bhyve/pci_virtio_block.c
+usr/src/cmd/bhyve/pci_virtio_net.c
+usr/src/cmd/bhyve/pm.c
+usr/src/cmd/bhyve/pmtmr.c
+usr/src/cmd/bhyve/post.c
+usr/src/cmd/bhyve/ps2kbd.[ch]
+usr/src/cmd/bhyve/ps2mouse.[ch]
+usr/src/cmd/bhyve/rfb.[ch]
+usr/src/cmd/bhyve/rtc.[ch]
+usr/src/cmd/bhyve/smbiostbl.[ch]
+usr/src/cmd/bhyve/spinup_ap.[ch]
+usr/src/cmd/bhyve/uart_emul.[ch]
+usr/src/cmd/bhyve/vga.[ch]
+usr/src/cmd/bhyve/virtio.[ch]
+usr/src/cmd/bhyve/xmsr.[ch]
+usr/src/cmd/bhyveconsole/bhyveconsole.c
+usr/src/cmd/bhyvectl/bhyvectl.c
+usr/src/compat/freebsd/*.h
+usr/src/compat/freebsd/*/*.h
+usr/src/compat/freebsd/amd64/machine/*.h
+usr/contrib/freebsd/*/*.h
+usr/contrib/freebsd/*/*/*.h
+usr/contrib/freebsd/lib/libutil/expand_number.c
+usr/src/head/bhyve.h
+usr/src/lib/libvmmapi/common/vmmapi.[ch]
+usr/src/uts/i86pc/io/vmm/amd/*.c
+usr/src/uts/i86pc/io/vmm/intel/*.[chs]
+usr/src/uts/i86pc/io/vmm/io/*.[ch]
+usr/src/uts/i86pc/io/vmm/vmm.c
+usr/src/uts/i86pc/io/vmm/vmm_host.[ch]
+usr/src/uts/i86pc/io/vmm/vmm_instruction_emul.c
+usr/src/uts/i86pc/io/vmm/vmm_ioport.[ch]
+usr/src/uts/i86pc/io/vmm/vmm_ipi.h
+usr/src/uts/i86pc/io/vmm/vmm_ktr.h
+usr/src/uts/i86pc/io/vmm/vmm_lapic.[ch]
+usr/src/uts/i86pc/io/vmm/vmm_mem.h
+usr/src/uts/i86pc/io/vmm/vmm_sol_glue.c
+usr/src/uts/i86pc/io/vmm/vmm_stat.h
+usr/src/uts/i86pc/io/vmm/vmm_util.[ch]
+usr/src/uts/i86pc/io/vmm/vmx_assym.s
+usr/src/uts/i86pc/io/vmm/x86.[ch]
+usr/src/uts/i86pc/sys/vmm.h
+usr/src/uts/i86pc/sys/vmm_dev.h
+usr/src/uts/i86pc/sys/vmm_instruction_emul.h
diff --git a/exception_lists/hdrchk b/exception_lists/hdrchk
index c74253b0b7..43ed5c5a10 100644
--- a/exception_lists/hdrchk
+++ b/exception_lists/hdrchk
@@ -396,3 +396,52 @@ usr/src/uts/intel/sys/acpi/acresrc.h
 usr/src/uts/intel/sys/acpi/acstruct.h
 usr/src/uts/intel/sys/acpi/amlresrc.h
 usr/src/uts/intel/sys/acpi/platform/acwin64.h
+
+# bhyve sources
+syntax: glob
+usr/src/cmd/bhyve/acpi.h
+usr/src/cmd/bhyve/ahci.h
+usr/src/cmd/bhyve/atkbdc.h
+usr/src/cmd/bhyve/bhyvegc.h
+usr/src/cmd/bhyve/bhyverun.h
+usr/src/cmd/bhyve/block_if.h
+usr/src/cmd/bhyve/console.h
+usr/src/cmd/bhyve/dbgport.h
+usr/src/cmd/bhyve/inout.h
+usr/src/cmd/bhyve/ioapic.h
+usr/src/cmd/bhyve/mem.h
+usr/src/cmd/bhyve/mptbl.h
+usr/src/cmd/bhyve/pci_emul.h
+usr/src/cmd/bhyve/pci_irq.h
+usr/src/cmd/bhyve/pci_lpc.h
+usr/src/cmd/bhyve/ps2kbd.h
+usr/src/cmd/bhyve/ps2mouse.h
+usr/src/cmd/bhyve/rfb.h
+usr/src/cmd/bhyve/rtc.h
+usr/src/cmd/bhyve/smbiostbl.h
+usr/src/cmd/bhyve/spinup_ap.h
+usr/src/cmd/bhyve/uart_emul.h
+usr/src/cmd/bhyve/vga.h
+usr/src/cmd/bhyve/virtio.h
+usr/src/cmd/bhyve/xmsr.h
+usr/src/compat/freebsd/*.h
+usr/src/compat/freebsd/*/*.h
+usr/src/compat/freebsd/amd64/machine/*.h
+usr/contrib/freebsd/*/*.h
+usr/contrib/freebsd/*/*/*.h
+usr/src/head/bhyve.h
+usr/src/lib/libvmmapi/common/vmmapi.h
+usr/src/uts/i86pc/io/vmm/intel/*.h
+usr/src/uts/i86pc/io/vmm/io/*.h
+usr/src/uts/i86pc/io/vmm/vmm_host.h
+usr/src/uts/i86pc/io/vmm/vmm_ioport.h
+usr/src/uts/i86pc/io/vmm/vmm_ipi.h
+usr/src/uts/i86pc/io/vmm/vmm_ktr.h
+usr/src/uts/i86pc/io/vmm/vmm_lapic.h
+usr/src/uts/i86pc/io/vmm/vmm_mem.h
+usr/src/uts/i86pc/io/vmm/vmm_stat.h
+usr/src/uts/i86pc/io/vmm/vmm_util.h
+usr/src/uts/i86pc/io/vmm/x86.h
+usr/src/uts/i86pc/sys/vmm.h
+usr/src/uts/i86pc/sys/vmm_dev.h
+usr/src/uts/i86pc/sys/vmm_instruction_emul.h
diff --git a/usr/src/cmd/bhyve/bhyve_sol_glue.c b/usr/src/cmd/bhyve/bhyve_sol_glue.c
index 633faacc5f..47bc7a3999 100644
--- a/usr/src/cmd/bhyve/bhyve_sol_glue.c
+++ b/usr/src/cmd/bhyve/bhyve_sol_glue.c
@@ -11,6 +11,7 @@
 
 /*
  * Copyright 2013 Pluribus Networks Inc.
+ * Copyright 2017 Joyent, Inc.
  */
 
 #include <sys/uio.h>
@@ -25,10 +26,12 @@
 void
 cfmakeraw(struct termios *t)
 {
-	t->c_iflag &= ~(IMAXBEL|IXOFF|INPCK|BRKINT|PARMRK|ISTRIP|INLCR|IGNCR|ICRNL|IXON|IGNPAR);
+	t->c_iflag &= ~(IMAXBEL|IXOFF|INPCK|BRKINT|PARMRK|ISTRIP|INLCR|IGNCR|
+	    ICRNL|IXON|IGNPAR);
 	t->c_iflag |= IGNBRK;
 	t->c_oflag &= ~OPOST;
-	t->c_lflag &= ~(ECHO|ECHOE|ECHOK|ECHONL|ICANON|ISIG|IEXTEN|NOFLSH|TOSTOP |PENDIN);
+	t->c_lflag &= ~(ECHO|ECHOE|ECHOK|ECHONL|ICANON|ISIG|IEXTEN|NOFLSH|
+	    TOSTOP|PENDIN);
 	t->c_cflag &= ~(CSIZE|PARENB);
 	t->c_cflag |= CS8|CREAD;
 	t->c_cc[VMIN] = 1;
diff --git a/usr/src/cmd/bhyve/pci_virtio_viona.c b/usr/src/cmd/bhyve/pci_virtio_viona.c
index 4ce0896063..ddc9f0546a 100644
--- a/usr/src/cmd/bhyve/pci_virtio_viona.c
+++ b/usr/src/cmd/bhyve/pci_virtio_viona.c
@@ -500,7 +500,7 @@ viona_adjust_offset(struct pci_devinst *pi, uint64_t offset)
 
 static void
 pci_viona_write(struct vmctx *ctx, int vcpu, struct pci_devinst *pi,
-		int baridx, uint64_t offset, int size, uint64_t value)
+    int baridx, uint64_t offset, int size, uint64_t value)
 {
 	struct pci_viona_softc *sc = pi->pi_arg;
 	void *ptr;
diff --git a/usr/src/cmd/bhyveconsole/bhyveconsole.c b/usr/src/cmd/bhyveconsole/bhyveconsole.c
index baf6c98f7f..19cf472ee5 100644
--- a/usr/src/cmd/bhyveconsole/bhyveconsole.c
+++ b/usr/src/cmd/bhyveconsole/bhyveconsole.c
@@ -276,11 +276,12 @@ static void
 doio(void)
 {
 	struct pollfd pollfds[2];
+	const short read_ev = POLLIN | POLLRDNORM | POLLRDBAND | POLLPRI;
 	int res;
 
 	/* read from vm and write to stdout */
 	pollfds[0].fd = masterfd;
-	pollfds[0].events = POLLIN | POLLRDNORM | POLLRDBAND | POLLPRI;
+	pollfds[0].events = read_ev;
 
 	/* read from stdin and write to vm */
 	pollfds[1].fd = STDIN_FILENO;
@@ -312,11 +313,9 @@ doio(void)
 
 		/* event from user stdin side */
 		if (pollfds[1].revents) {
-			if (pollfds[1].revents &
-			    (POLLIN | POLLRDNORM | POLLRDBAND | POLLPRI)) {
-			  if (process_user_input(masterfd, STDIN_FILENO)
-				    != 0)
-					break;
+			if ((pollfds[1].revents & read_ev) != 0 &&
+			    process_user_input(masterfd, STDIN_FILENO) == 0) {
+				continue;
 			} else {
 				break;
 			}
diff --git a/usr/src/cmd/bhyveload-uefi/bhyveload-uefi.c b/usr/src/cmd/bhyveload-uefi/bhyveload-uefi.c
index 62a7ca5d0f..f3bc6630f6 100644
--- a/usr/src/cmd/bhyveload-uefi/bhyveload-uefi.c
+++ b/usr/src/cmd/bhyveload-uefi/bhyveload-uefi.c
@@ -11,6 +11,7 @@
 
 /*
  * Copyright 2013 Pluribus Networks Inc.
+ * Copyright 2017 Joyent, Inc.
  */
 
 #include <sys/types.h>
@@ -72,13 +73,13 @@ static void
 usage(void)
 {
 	printf("usage: %s "
-	       "[-c vcpus] [-m mem-size] [-b bootorder]"
-	       "<vmname>\n", progname);
+	    "[-c vcpus] [-m mem-size] [-b bootorder]"
+	    "<vmname>\n", progname);
 	exit(1);
 }
 
 int
-main(int argc, char** argv)
+main(int argc, char **argv)
 {
 	int opt, error, fd;
 	int guest_ncpus;
@@ -107,10 +108,10 @@ main(int argc, char** argv)
 			guest_bootorder = atoi(optarg);
 			if (guest_bootorder < 0 || guest_bootorder > 11) {
 				errx(EX_USAGE, "Invalid bootoption: %d\n"
-		 		    "\tBoot order code:\n"
- 				    "\t0 - EFI_CD_HD\n"
- 				    "\t1 - EFI_CD\n"
- 				    "\t2 - EFI_HD_CD\n"
+				    "\tBoot order code:\n"
+				    "\t0 - EFI_CD_HD\n"
+				    "\t1 - EFI_CD\n"
+				    "\t2 - EFI_HD_CD\n"
 				    "\t3 - EFI_HD\n"
 				    "\t4 - EFI_NET\n"
 				    "\t5 - EFI_NET_CD_HD\n"
@@ -119,7 +120,7 @@ main(int argc, char** argv)
 				    "\t8 - LEGACY_CD\n"
 				    "\t9 - LEGACY_HD_CD\n"
 				    "\t10 - LEGACY_HD\n"
- 				    "\t11 - EFI_SHELL\n", guest_bootorder);
+				    "\t11 - EFI_SHELL\n", guest_bootorder);
 				exit(1);
 			}
 			break;
diff --git a/usr/src/lib/libvmmapi/common/mapfile-vers b/usr/src/lib/libvmmapi/common/mapfile-vers
index 7a8443a2b8..07286f6907 100644
--- a/usr/src/lib/libvmmapi/common/mapfile-vers
+++ b/usr/src/lib/libvmmapi/common/mapfile-vers
@@ -11,6 +11,7 @@
 
 #
 # Copyright 2013 Pluribus Networks Inc.
+# Copyright 2017 Joyent, Inc.
 #
 
 #
@@ -27,51 +28,53 @@
 # MAPFILE HEADER END
 #
 
-SUNWprivate_1.0 {
-    global:
-	vcpu_reset;
-	vm_activate_cpu;
-	vm_apicid2vcpu;
-	vm_capability_name2type;
-	vm_capability_type2name;
-	vm_copy_setup;
-	vm_copy_teardown;
-	vm_copyin;
-	vm_copyout;
-	vm_create;
-	vm_destroy;
-	vm_get_capability;
-	vm_get_desc;
-	vm_get_highmem_size;
-	vm_get_lowmem_limit;
-	vm_get_lowmem_size;
-	vm_get_memory_seg;
-	vm_get_register;
-	vm_get_seg_desc;
-	vm_get_x2apic_state;
-	vm_gla2gpa;
-	vm_inject_exception;
-	vm_isa_assert_irq;
-	vm_isa_deassert_irq;
-	vm_isa_pulse_irq;
-	vm_isa_set_irq_trigger;
-	vm_ioapic_assert_irq;
-	vm_ioapic_deassert_irq;
-	vm_ioapic_pincount;
-	vm_ioapic_pulse_irq;
-	vm_lapic_irq;
-	vm_lapic_msi;
-	vm_map_gpa;
-	vm_open;
-	vm_parse_memsize;
-	vm_restart_instruction;
-	vm_run;
-	vm_set_capability;
-	vm_set_desc;
-	vm_set_register;
-	vm_set_x2apic_state;
-	vm_setup_memory;
-	vm_setup_rom;
-    local:
-        *;
+$mapfile_version 2
+
+SYMBOL_VERSION ILLUMOSprivate {
+	global:
+		vcpu_reset;
+		vm_activate_cpu;
+		vm_apicid2vcpu;
+		vm_capability_name2type;
+		vm_capability_type2name;
+		vm_copy_setup;
+		vm_copy_teardown;
+		vm_copyin;
+		vm_copyout;
+		vm_create;
+		vm_destroy;
+		vm_get_capability;
+		vm_get_desc;
+		vm_get_highmem_size;
+		vm_get_lowmem_limit;
+		vm_get_lowmem_size;
+		vm_get_memory_seg;
+		vm_get_register;
+		vm_get_seg_desc;
+		vm_get_x2apic_state;
+		vm_gla2gpa;
+		vm_inject_exception;
+		vm_isa_assert_irq;
+		vm_isa_deassert_irq;
+		vm_isa_pulse_irq;
+		vm_isa_set_irq_trigger;
+		vm_ioapic_assert_irq;
+		vm_ioapic_deassert_irq;
+		vm_ioapic_pincount;
+		vm_ioapic_pulse_irq;
+		vm_lapic_irq;
+		vm_lapic_msi;
+		vm_map_gpa;
+		vm_open;
+		vm_parse_memsize;
+		vm_restart_instruction;
+		vm_run;
+		vm_set_capability;
+		vm_set_desc;
+		vm_set_register;
+		vm_set_x2apic_state;
+		vm_setup_memory;
+		vm_setup_rom;
+	local:
+		*;
 };
diff --git a/usr/src/uts/i86pc/io/viona/viona.c b/usr/src/uts/i86pc/io/viona/viona.c
index 86666d4432..2371a2f3ae 100644
--- a/usr/src/uts/i86pc/io/viona/viona.c
+++ b/usr/src/uts/i86pc/io/viona/viona.c
@@ -195,8 +195,8 @@ static void			*viona_state;
 static dev_info_t		*viona_dip;
 static id_space_t		*viona_minor_ids;
 /*
- * copy tx mbufs from virtio ring to avoid necessitating a wait 
- * for packet transmission to free resources.
+ * copy tx mbufs from virtio ring to avoid necessitating a wait for packet
+ * transmission to free resources.
  */
 static boolean_t		copy_tx_mblks = B_TRUE;
 
@@ -915,7 +915,7 @@ viona_ioc_tx_intr_clear(viona_link_t *link)
 
 static int
 vq_popchain(viona_link_t *link, viona_vring_hqueue_t *hq, struct iovec *iov,
-int n_iov, uint16_t *cookie)
+    int n_iov, uint16_t *cookie)
 {
 	int			i;
 	int			ndesc, nindir;
diff --git a/usr/src/uts/i86pc/io/vmm/vmm_sol_dev.c b/usr/src/uts/i86pc/io/vmm/vmm_sol_dev.c
index 326af9bf51..3151e1d7ec 100644
--- a/usr/src/uts/i86pc/io/vmm/vmm_sol_dev.c
+++ b/usr/src/uts/i86pc/io/vmm/vmm_sol_dev.c
@@ -305,7 +305,7 @@ vmmdev_do_ioctl(struct vmm_softc *sc, int cmd, intptr_t arg, int mode,
 		break;
 	}
 
-	switch(cmd) {
+	switch (cmd) {
 	case VM_RUN:
 		if (ddi_copyin((void *)arg, &vmrun,
 		    sizeof (struct vm_run), mode)) {
@@ -355,7 +355,7 @@ vmmdev_do_ioctl(struct vmm_softc *sc, int cmd, intptr_t arg, int mode,
 		    sizeof (struct vm_ioapic_irq), mode)) {
 			return (EFAULT);
 		}
-		error = vioapic_assert_irq(sc->vm, ioapic_irq.irq);;
+		error = vioapic_assert_irq(sc->vm, ioapic_irq.irq);
 		if (ddi_copyout(&ioapic_irq, (void *)arg,
 		    sizeof (struct vm_ioapic_irq), mode)) {
 			return (EFAULT);
@@ -402,7 +402,6 @@ vmmdev_do_ioctl(struct vmm_softc *sc, int cmd, intptr_t arg, int mode,
 		if (ddi_copyout(&isa_irq, (void *)arg,
 		    sizeof (struct vm_isa_irq), mode)) {
 			return (EFAULT);
-		
 		}
 		break;
 	case VM_ISA_DEASSERT_IRQ:
@@ -417,7 +416,6 @@ vmmdev_do_ioctl(struct vmm_softc *sc, int cmd, intptr_t arg, int mode,
 		if (ddi_copyout(&isa_irq, (void *)arg,
 		    sizeof (struct vm_isa_irq), mode)) {
 			return (EFAULT);
-		
 		}
 		break;
 	case VM_ISA_PULSE_IRQ:
@@ -431,7 +429,6 @@ vmmdev_do_ioctl(struct vmm_softc *sc, int cmd, intptr_t arg, int mode,
 		if (ddi_copyout(&isa_irq, (void *)arg,
 		    sizeof (struct vm_isa_irq), mode)) {
 			return (EFAULT);
-		
 		}
 		break;
 	case VM_MAP_MEMORY:
@@ -447,7 +444,7 @@ vmmdev_do_ioctl(struct vmm_softc *sc, int cmd, intptr_t arg, int mode,
 			return (EFAULT);
 		}
 		seg.len = 0;
-		(void)vm_gpabase2memseg(sc->vm, seg.gpa, &seg);
+		(void) vm_gpabase2memseg(sc->vm, seg.gpa, &seg);
 		if (ddi_copyout(&seg, (void *)arg,
 		    sizeof (struct vm_memory_segment), mode)) {
 			return (EFAULT);
@@ -460,10 +457,10 @@ vmmdev_do_ioctl(struct vmm_softc *sc, int cmd, intptr_t arg, int mode,
 			return (EFAULT);
 		}
 		error = vm_get_register(sc->vm, vmreg.cpuid, vmreg.regnum,
-					&vmreg.regval);
+		    &vmreg.regval);
 		if (!error) {
 			if (ddi_copyout(&vmreg, (void *)arg,
-				 sizeof (struct vm_register), mode)) {
+			    sizeof (struct vm_register), mode)) {
 				return (EFAULT);
 			}
 		}
@@ -474,7 +471,7 @@ vmmdev_do_ioctl(struct vmm_softc *sc, int cmd, intptr_t arg, int mode,
 			return (EFAULT);
 		}
 		error = vm_set_register(sc->vm, vmreg.cpuid, vmreg.regnum,
-					vmreg.regval);
+		    vmreg.regval);
 		break;
 	case VM_SET_SEGMENT_DESCRIPTOR:
 		if (ddi_copyin((void *)arg, &vmsegdesc,
@@ -482,8 +479,7 @@ vmmdev_do_ioctl(struct vmm_softc *sc, int cmd, intptr_t arg, int mode,
 			return (EFAULT);
 		}
 		error = vm_set_seg_desc(sc->vm, vmsegdesc.cpuid,
-					vmsegdesc.regnum,
-					&vmsegdesc.desc);
+		    vmsegdesc.regnum, &vmsegdesc.desc);
 		break;
 	case VM_GET_SEGMENT_DESCRIPTOR:
 		if (ddi_copyin((void *)arg, &vmsegdesc,
@@ -491,8 +487,7 @@ vmmdev_do_ioctl(struct vmm_softc *sc, int cmd, intptr_t arg, int mode,
 			return (EFAULT);
 		}
 		error = vm_get_seg_desc(sc->vm, vmsegdesc.cpuid,
-					vmsegdesc.regnum,
-					&vmsegdesc.desc);
+		    vmsegdesc.regnum, &vmsegdesc.desc);
 		if (!error) {
 			if (ddi_copyout(&vmsegdesc, (void *)arg,
 			    sizeof (struct vm_seg_desc), mode)) {
@@ -506,8 +501,7 @@ vmmdev_do_ioctl(struct vmm_softc *sc, int cmd, intptr_t arg, int mode,
 			return (EFAULT);
 		}
 		error = vm_get_capability(sc->vm, vmcap.cpuid,
-					  vmcap.captype,
-					  &vmcap.capval);
+		    vmcap.captype, &vmcap.capval);
 		if (!error) {
 			if (ddi_copyout(&vmcap, (void *)arg,
 			    sizeof (struct vm_capability), mode)) {
@@ -521,24 +515,22 @@ vmmdev_do_ioctl(struct vmm_softc *sc, int cmd, intptr_t arg, int mode,
 			return (EFAULT);
 		}
 		error = vm_set_capability(sc->vm, vmcap.cpuid,
-					  vmcap.captype,
-					  vmcap.capval);
+		    vmcap.captype, vmcap.capval);
 		break;
 	case VM_SET_X2APIC_STATE:
 		if (ddi_copyin((void *)arg, &x2apic,
 		    sizeof (struct vm_x2apic), mode)) {
 			return (EFAULT);
 		}
-		error = vm_set_x2apic_state(sc->vm,
-					    x2apic.cpuid, x2apic.state);
+		error = vm_set_x2apic_state(sc->vm, x2apic.cpuid, x2apic.state);
 		break;
 	case VM_GET_X2APIC_STATE:
 		if (ddi_copyin((void *)arg, &x2apic,
 		    sizeof (struct vm_x2apic), mode)) {
 			return (EFAULT);
 		}
-		error = vm_get_x2apic_state(sc->vm,
-					    x2apic.cpuid, &x2apic.state);
+		error = vm_get_x2apic_state(sc->vm, x2apic.cpuid,
+		    &x2apic.state);
 		if (!error) {
 			if (ddi_copyout(&x2apic, (void *)arg,
 			    sizeof (struct vm_x2apic), mode)) {
@@ -550,6 +542,7 @@ vmmdev_do_ioctl(struct vmm_softc *sc, int cmd, intptr_t arg, int mode,
 		CTASSERT(PROT_READ == VM_PROT_READ);
 		CTASSERT(PROT_WRITE == VM_PROT_WRITE);
 		CTASSERT(PROT_EXEC == VM_PROT_EXECUTE);
+
 		if (ddi_copyin((void *)arg, &gg,
 		    sizeof (struct vm_gla2gpa), mode)) {
 			return (EFAULT);
@@ -592,8 +585,9 @@ vmmdev_do_ioctl(struct vmm_softc *sc, int cmd, intptr_t arg, int mode,
 	if (state_changed == 1) {
 		vcpu_set_state(sc->vm, vcpu, VCPU_IDLE, false);
 	} else if (state_changed == 2) {
-		for (vcpu = 0; vcpu < VM_MAXCPU; vcpu++)
+		for (vcpu = 0; vcpu < VM_MAXCPU; vcpu++) {
 			vcpu_set_state(sc->vm, vcpu, VCPU_IDLE, false);
+		}
 	}
 
 done:
@@ -892,7 +886,7 @@ vmm_mmap(dev_t dev, off_t off, int prot)
 
 static int
 vmm_segmap(dev_t dev, off_t off, struct as *as, caddr_t *addrp, off_t len,
-   unsigned int prot, unsigned int maxprot, unsigned int flags, cred_t *credp)
+    unsigned int prot, unsigned int maxprot, unsigned int flags, cred_t *credp)
 {
 	struct segdev_crargs	dev_a;
 	int			error;
diff --git a/usr/src/uts/i86pc/io/vmm/vmm_sol_glue.c b/usr/src/uts/i86pc/io/vmm/vmm_sol_glue.c
index 07b5f87345..584a4978cc 100644
--- a/usr/src/uts/i86pc/io/vmm/vmm_sol_glue.c
+++ b/usr/src/uts/i86pc/io/vmm/vmm_sol_glue.c
@@ -25,7 +25,7 @@
  *
  * $FreeBSD: head/sys/kern/subr_sleepqueue.c 261520 2014-02-05 18:13:27Z jhb $
  */
-/*-
+/*
  * Copyright (c) 2004 Poul-Henning Kamp
  * All rights reserved.
  *
@@ -111,15 +111,13 @@ cpusetobj_ffs(const cpuset_t *set)
 	}
 	return (cbit);
 #else
-	return(ffsl(*set));
+	return (ffsl(*set));
 #endif
 }
 
 void
-smp_rendezvous(void (* setup_func)(void *),
-	       void (* action_func)(void *),
-	       void (* teardown_func)(void *),
-	       void *arg)
+smp_rendezvous(void (* setup_func)(void *), void (* action_func)(void *),
+    void (* teardown_func)(void *), void *arg)
 {
 	cpuset_t cpuset;
 
@@ -149,9 +147,9 @@ malloc(unsigned long size, struct malloc_type *mtp, int flags)
 		kmem_flag = KM_NOSLEEP;
 
 	if (flags & M_ZERO) {
-		p = kmem_zalloc(size + sizeof(struct kmem_item), kmem_flag);
+		p = kmem_zalloc(size + sizeof (struct kmem_item), kmem_flag);
 	} else {
-		p = kmem_alloc(size + sizeof(struct kmem_item), kmem_flag);
+		p = kmem_alloc(size + sizeof (struct kmem_item), kmem_flag);
 	}
 
 	mutex_enter(&kmem_items_lock);
@@ -179,7 +177,7 @@ free(void *addr, struct malloc_type *mtp)
 	LIST_REMOVE(i, next);
 	mutex_exit(&kmem_items_lock);
 
-	kmem_free(addr, i->size + sizeof(struct kmem_item));
+	kmem_free(addr, i->size + sizeof (struct kmem_item));
 }
 
 void
@@ -324,7 +322,7 @@ free_unr(struct unrhdr *uh, u_int item)
 	unr = *unrp;
 	*unrp = unr->link;
 	mutex_exit(&uh->mtx->m);
-	kmem_free(unr, sizeof(struct unr));
+	kmem_free(unr, sizeof (struct unr));
 }
 
 
@@ -410,8 +408,7 @@ ipi_cpu(int cpu, u_int ipi)
 	cpuset_t	set;
 
 	CPUSET_ONLY(set, cpu);
-	xc_call_nowait(NULL, NULL, NULL, CPUSET2BV(set),
-		       ipi_cpu_justreturn);
+	xc_call_nowait(NULL, NULL, NULL, CPUSET2BV(set), ipi_cpu_justreturn);
 }
 
 #define	SC_TABLESIZE	256			/* Must be power of 2. */
@@ -464,7 +461,7 @@ init_sleepqueues(void)
         for (i = 0; i < SC_TABLESIZE; i++) {
 		LIST_INIT(&sleepq_chains[i].sc_queues);
 		mtx_init(&sleepq_chains[i].sc_lock, "sleepq chain", NULL,
-			 MTX_SPIN);
+		    MTX_SPIN);
 	}
 
 	vmm_sleepq_cache = kmem_cache_create("vmm_sleepq_cache",
@@ -534,7 +531,7 @@ sleepq_add(void *wchan)
 		sq->sq_wchan = wchan;
 	}
 
-        sq->sq_blockedcnt++;
+	sq->sq_blockedcnt++;
 
 	return (sq);
 }
@@ -575,7 +572,7 @@ wakeup(void *chan)
 	struct sleepqueue	*sq;
 
 	sleepq_lock(chan);
-        sq = sleepq_lookup(chan);
+	sq = sleepq_lookup(chan);
 	if (sq != NULL) {
 		cv_broadcast(&sq->sq_cv);
 	}
@@ -588,7 +585,7 @@ wakeup_one(void *chan)
 	struct sleepqueue	*sq;
 
 	sleepq_lock(chan);
-        sq = sleepq_lookup(chan);
+	sq = sleepq_lookup(chan);
 	if (sq != NULL) {
 		cv_signal(&sq->sq_cv);
 	}
diff --git a/usr/src/uts/i86pc/io/vmm/vmm_sol_mem.c b/usr/src/uts/i86pc/io/vmm/vmm_sol_mem.c
index 3bb5412d16..cb97db106b 100644
--- a/usr/src/uts/i86pc/io/vmm/vmm_sol_mem.c
+++ b/usr/src/uts/i86pc/io/vmm/vmm_sol_mem.c
@@ -1,4 +1,4 @@
-/*-
+/*
  * Copyright (c) 2011 NetApp, Inc.
  * All rights reserved.
  *
@@ -39,7 +39,6 @@
  */
 
 #include <sys/cdefs.h>
-__FBSDID("$FreeBSD: head/sys/amd64/vmm/vmm_mem.c 245678 2013-01-20 03:42:49Z neel $");
 
 #include <sys/param.h>
 #include <sys/lock.h>
@@ -92,7 +91,7 @@ vmm_mem_free(vm_paddr_t base, size_t length)
 
 	if (base & PAGE_MASK) {
 		panic("vmm_mem_free: base 0x%0lx must be aligned on a "
-		      "0x%0x boundary\n", base, PAGE_SIZE);
+		    "0x%0x boundary\n", base, PAGE_SIZE);
 	}
 
 	if (length != PAGE_SIZE) {
@@ -106,6 +105,5 @@ vmm_mem_free(vm_paddr_t base, size_t length)
 vm_paddr_t
 vmm_mem_maxaddr(void)
 {
-
 	return (ptob(physmax + 1));
 }
diff --git a/usr/src/uts/i86pc/sys/viona_io.h b/usr/src/uts/i86pc/sys/viona_io.h
index a4fb0f2527..a26cc00a55 100644
--- a/usr/src/uts/i86pc/sys/viona_io.h
+++ b/usr/src/uts/i86pc/sys/viona_io.h
@@ -11,6 +11,7 @@
 
 /*
  * Copyright 2013 Pluribus Networks Inc.
+ * Copyright 2017 Joyent, Inc.
  */
 
 #ifndef	_VIONA_IO_H_
@@ -27,8 +28,8 @@
 #define	VNA_IOC_TX_RING_KICK	(VNA_IOC | 8)
 #define	VNA_IOC_RX_INTR_CLR	(VNA_IOC | 9)
 #define	VNA_IOC_TX_INTR_CLR	(VNA_IOC | 10)
-#define VNA_IOC_SET_FEATURES	(VNA_IOC | 11)
-#define VNA_IOC_GET_FEATURES	(VNA_IOC | 12)
+#define	VNA_IOC_SET_FEATURES	(VNA_IOC | 11)
+#define	VNA_IOC_GET_FEATURES	(VNA_IOC | 12)
 
 typedef struct vioc_create {
 	datalink_id_t	c_linkid;
diff --git a/usr/src/uts/i86pc/sys/vmm_impl.h b/usr/src/uts/i86pc/sys/vmm_impl.h
index e8a342844c..0126993dc2 100644
--- a/usr/src/uts/i86pc/sys/vmm_impl.h
+++ b/usr/src/uts/i86pc/sys/vmm_impl.h
@@ -15,7 +15,7 @@
  */
 
 #ifndef _VMM_IMPL_H_
-#define _VMM_IMPL_H_
+#define	_VMM_IMPL_H_
 
 #include <sys/mutex.h>
 #include <sys/queue.h>
-- 
2.21.0

