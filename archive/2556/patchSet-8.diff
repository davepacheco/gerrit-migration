commit 7f1d8f2a2803aa70859cbc78b6c256c9c09c1bc2 (refs/changes/56/2556/8)
Author: Josh Wilsdon <josh@wilsdon.ca>
Date:   2017-09-21T00:11:51-07:00 (2 years, 1 month ago)
    
    PUBAPI-1420 Add ability to mount NFS volumes with CreateMachine endpoint

diff --git a/overlay/generic/lib/svc/method/mdata-fetch b/overlay/generic/lib/svc/method/mdata-fetch
index f0a1eab6..786f662a 100755
--- a/overlay/generic/lib/svc/method/mdata-fetch
+++ b/overlay/generic/lib/svc/method/mdata-fetch
@@ -21,7 +21,7 @@
 #
 # CDDL HEADER END
 #
-# Copyright (c) 2015, Joyent, Inc. All rights reserved.
+# Copyright (c) 2017, Joyent, Inc. All rights reserved.
 #
 
 export PS4='[\D{%FT%TZ}] ${BASH_SOURCE}:${LINENO}: ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
@@ -37,6 +37,13 @@ if [ ! -x /usr/sbin/mdata-get ]; then
   exit ${SMF_EXIT_ERR_FATAL}
 fi
 
+function fatal() {
+  if [[ -n $1 ]]; then
+      echo "FATAL: $*" >&2
+  fi
+  exit ${SMF_EXIT_ERR_FATAL}
+}
+
 # isAddr will test whether or not an IP address is valid. The first argument
 # is the method to call on the Node "net" module, and the second one is the
 # actual address to test.
@@ -96,8 +103,7 @@ fi
 
 if [[ ! -e /.zonecontrol/metadata.sock ]]; then
     # this is a bug since filewait should not have returned until file existed.
-    echo "missing /.zonecontrol/metadata.sock, Unable to start mdata:fetch"
-    exit ${SMF_EXIT_ERR_FATAL}
+    fatal "missing /.zonecontrol/metadata.sock, Unable to start mdata:fetch"
 fi
 
 # Update sysinfo to ensure values that come from metadata are populated.
@@ -191,6 +197,65 @@ if [[ $? == 0 && -n ${tmpfs} && -f /etc/vfstab ]]; then
   fi
 fi
 
+#
+# If we have NFS volumes, we'll add them to vfstab, and enable the nfs/client
+# service so that will mount the volumes for us.
+#
+echo "Retrieving volume metadata..."
+
+volumes_added=0
+while IFS="|" read -r nfsvolume mountpoint name mode type; do
+
+  cat >&2 <<EOF
+*** VOLUME ***
+NFSVOLUME: ${nfsvolume}
+MOUNTPOINT: ${mountpoint}
+MODE: ${mode}
+NAME: ${name}
+TYPE: ${type}
+EOF
+
+  if [[ -n ${type} && ${type} != "tritonnfs" ]]; then
+      fatal "unsupported volume type: ${type}"
+  fi
+
+  # if we don't have volume and mountpoint, we can't add vfstab lines
+  if [[ -z ${nfsvolume} || -z ${mountpoint} ]]; then
+      fatal "invalid volume specification (need both volume & mountpoint)"
+  fi
+
+  if ! grep "^${nfsvolume}[ 	]" /etc/vfstab; then
+      if [[ -z ${mode} ]]; then
+          mode="rw"
+      fi
+
+      if [[ ${mode} != "rw" && ${mode} != "ro" ]]; then
+          fatal "invalid volume mode: '${mode}'"
+      fi
+
+      line=$(printf "%s - %s nfs - yes %s\n" "${nfsvolume}" "${mountpoint}" "${mode}")
+      volumes_added=$((${volumes_added}+1))
+
+      mkdir -p ${mountpoint}
+      echo "${line}" >> /etc/vfstab
+  fi
+done < <(/usr/sbin/mdata-get sdc:volumes \
+    | /usr/bin/json \
+        -d '|' \
+        -a nfsvolume mountpoint name mode type)
+
+if [[ ${volumes_added} -gt 0 ]]; then
+    for svc in \
+        svc:/network/nfs/nlockmgr:default \
+        svc:/network/nfs/status:default \
+        svc:/network/rpc/bind:default \
+        svc:/network/nfs/client:default \
+        ; do
+
+        svcadm enable ${svc} || fatal "Unable to enable ${svc}"
+     done
+fi
+
 # We use the special sdc:nics value here though this is not an interface for
 # use elsewhere.  If this is changed please also update agent.js in the metadata
 # agent.
diff --git a/src/Makefile b/src/Makefile
index be456c64..1a0f5761 100644
--- a/src/Makefile
+++ b/src/Makefile
@@ -132,7 +132,8 @@ C_CHECK_TARGETS=\
 	sysevent.c \
 	dockerinit/src/dockerexec.c \
 	dockerinit/src/dockerinit.c \
-	dockerinit/src/docker-common.c
+	dockerinit/src/docker-common.c \
+	lx_hook_postnet/main.c
 
 #
 # Generic flags we apply by default to everything.
@@ -304,7 +305,7 @@ SMARTDC_LIB_TARGETS = \
 #
 # Subdirectory management
 #
-SUBDIRS = dockerinit routeinfo
+SUBDIRS = dockerinit routeinfo lx_hook_postnet
 
 SUBDIRS_ENV = \
 	CTFCONVERT=$(CTFCONVERT) \
@@ -413,6 +414,7 @@ install: all $(SUBDIRS)
 	mkdir -m 0755 -p $(DESTDIR)/usr/lib/sdc
 	cp -p net-boot-config $(DESTDIR)/usr/lib/sdc
 	cd routeinfo && $(MAKE) install $(SUBDIRS_ENV)
+	cd lx_hook_postnet && $(MAKE) install $(SUBDIRS_ENV)
 	mkdir -p $(SYSINFO_MOD_DIR)
 	rm -f $(SYSINFO_MOD_DIR)/sysinfo_mod.so
 	/usr/sbin/install -f $(SYSINFO_MOD_DIR) -m 0555 sysinfo_mod.so
diff --git a/src/dockerinit/src/docker-common.h b/src/dockerinit/src/docker-common.h
index 07ec4ad1..825c75e4 100644
--- a/src/dockerinit/src/docker-common.h
+++ b/src/dockerinit/src/docker-common.h
@@ -102,7 +102,8 @@ typedef enum {
     ERR_CONTRACT,
     ERR_MOUNT_DEVSHM,
     ERR_INVALID_NFS_VOLUMES,
-    ERR_MOUNT_NFS_VOLUME
+    ERR_MOUNT_NFS_VOLUME,
+    ERR_UNKNOWN_VOLUME_TYPE
 } dockerinit_err_t;
 
 typedef enum {
diff --git a/src/lx_hook_postnet/.gitignore b/src/lx_hook_postnet/.gitignore
new file mode 100644
index 00000000..0a203c29
--- /dev/null
+++ b/src/lx_hook_postnet/.gitignore
@@ -0,0 +1,2 @@
+*.o
+lx_hook_postnet
diff --git a/src/lx_hook_postnet/Makefile b/src/lx_hook_postnet/Makefile
new file mode 100644
index 00000000..8a007cdd
--- /dev/null
+++ b/src/lx_hook_postnet/Makefile
@@ -0,0 +1,135 @@
+#
+# This file and its contents are supplied under the terms of the
+# Common Development and Distribution License ("CDDL"), version 1.0.
+# You may only use this file in accordance with the terms of version
+# 1.0 of the CDDL.
+#
+# A full copy of the text of the CDDL should have accompanied this
+# source.  A copy of the CDDL is also available via the Internet at
+# http://www.illumos.org/license/CDDL.
+#
+
+#
+# Copyright (c) 2017, Joyent, Inc.
+#
+
+BASE :=		$(PWD)
+DESTDIR =	$(BASE)/../../proto
+NATIVEDIR =	$(BASE)/../../proto.strap
+
+PROGRAM =	lx_hook_postnet
+
+GCC =		$(NATIVEDIR)/usr/bin/gcc
+GXX =		$(NATIVEDIR)/usr/bin/g++
+
+SYSINCDIRS =	/usr/include
+SYSLIBDIRS =	/usr/lib /lib
+
+CFLAGS =	-std=gnu99 -Wall -Wextra -Werror -m32 -g \
+		-I$(DOCKER_DIR) \
+		-Wno-unused-parameter
+CPPFLAGS =	$(SYSINCDIRS:%=-isystem $(DESTDIR)/%)
+LDFLAGS =	$(SYSLIBDIRS:%=-L$(DESTDIR)/%) \
+		-Wl,-zassert-deflib -Wl,-zfatal-warnings
+
+STRINGS_DIR =	$(BASE)/../common/strings
+DOCKER_DIR =	$(BASE)/../dockerinit
+
+LXINIT_HOOK_OBJECTS = \
+		main.o
+
+MDATA_OBJECTS = \
+		dynstr.o \
+		proto.o \
+		common.o \
+		base64.o \
+		crc32.o \
+		reqid.o \
+		sunos.o \
+		unix_common.o
+
+custr.o :	CFLAGS += -I$(STRINGS_DIR)
+mdata_%.o :	CFLAGS += -I$(DOCKER_DIR)/mdata-client -D__HAVE_BOOLEAN_T
+main.o:	CFLAGS += -I$(STRINGS_DIR)
+docker_common.o:	CFLAGS += -I$(DOCKER_DIR)/src
+strlist.o:	CFLAGS += -I$(STRINGS_DIR)
+strpath.o:	CFLAGS += -I$(STRINGS_DIR)
+
+OBJECTS = \
+		$(MDATA_OBJECTS:%=mdata_%) \
+		custr.o \
+		docker_common.o \
+		json-nvlist.o \
+		main.o \
+		strlist.o \
+		strpath.o
+
+json-nvlist.o :	CFLAGS += -I$(DOCKER_DIR)/json-nvlist -I$(STRINGS_DIR)
+
+docker_common.o :	CFLAGS += -I$(DOCKER_DIR)/json-nvlist -I$(STRINGS_DIR)
+
+LIBS =		-lnvpair -lnsl -lsocket -lsmbios -lgen
+
+CTFCONVERT =	/usr/bin/true
+CTFMERGE =	/usr/bin/true
+
+CC=$(GCC)
+CFLAGS +=	-Wall -Wextra -Werror -D__HAVE_BOOLEAN_T -m32
+CSTYLE =	../../tools/cstyle
+
+COMPILE_C =	$(CC) $(CPPFLAGS) $(LDFLAGS) $(CFLAGS) -c -o $@ $<
+
+INSTALL_PROG =	mkdir -p $(@D) && rm -f $@ && cp $^ $@ && \
+		chmod 755 $@ && touch $@
+
+.PHONY: all
+all: $(PROGRAM)
+
+.PHONY: check
+check: $(LXINIT_HOOK_OBJECTS:%.o=%.check)
+
+%.check: %.c
+	$(CSTYLE) -cPp $<
+
+lint:
+	/usr/bin/true
+
+clean:
+	rm -f $(OBJECTS)
+	rm -f $(PROGRAM)
+
+#
+# Compilation and linking targets
+#
+$(PROGRAM): $(OBJECTS)
+	$(CC) $(CPPFLAGS) $(LDFLAGS) $(CFLAGS) -o $@ $(OBJECTS) $(LIBS)
+	$(CTFMERGE) -L VERSION -o $@ $(OBJECTS)
+
+%.o: $(STRINGS_DIR)/%.c
+	$(COMPILE_C)
+	$(CTFCONVERT) -L VERSION $@
+
+mdata_%.o: $(DOCKER_DIR)/mdata-client/%.c
+	$(COMPILE_C)
+	$(CTFCONVERT) -L VERSION $@
+
+mdata_%.o: $(DOCKER_DIR)/mdata-client/plat/%.c
+	$(COMPILE_C)
+	$(CTFCONVERT) -L VERSION $@
+
+docker_common.o: $(DOCKER_DIR)/src/docker-common.c
+	$(COMPILE_C)
+	$(CTFCONVERT) -L VERSION $@
+
+%.o: $(DOCKER_DIR)/json-nvlist/%.c
+	$(COMPILE_C)
+	$(CTFCONVERT) -L VERSION $@
+
+#
+# Installation
+#
+.PHONY: install
+install: $(DESTDIR)/usr/lib/brand/lx/$(PROGRAM)
+
+$(DESTDIR)/usr/lib/brand/lx/$(PROGRAM): $(PROGRAM)
+	$(INSTALL_PROG)
diff --git a/src/lx_hook_postnet/main.c b/src/lx_hook_postnet/main.c
new file mode 100644
index 00000000..4c55d914
--- /dev/null
+++ b/src/lx_hook_postnet/main.c
@@ -0,0 +1,222 @@
+/*
+ * This file and its contents are supplied under the terms of the
+ * Common Development and Distribution License ("CDDL"), version 1.0.
+ * You may only use this file in accordance with the terms of version
+ * 1.0 of the CDDL.
+ *
+ * A full copy of the text of the CDDL should have accompanied this
+ * source.  A copy of the CDDL is also available via the Internet at
+ * http://www.illumos.org/license/CDDL.
+ */
+
+/*
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+
+/*
+ * This program acts as a post-networking hook for lxinit on SmartOS.
+ *
+ * It assumes:
+ *
+ *  - this is an LX zone and networking is setup successfully
+ *  - messages written to stdout will eventually go to the console
+ *  - that if it exits non-zero the zone will not continue to boot
+ *
+ * It reads control parameters from the metadata service and then attempts to:
+ *
+ *   - mount any NFS Volumes that may have been found in sdc:volumes
+ *
+ * It will write an error message to stdout (should be the console when being
+ * run from lxinit) when there's an error in which case it will also exit
+ * non-zero.
+ *
+ */
+
+#include <err.h>
+#include <errno.h>
+#include <libgen.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <strings.h>
+#include <unistd.h>
+#include <zone.h>
+
+#include <sys/stat.h>
+#include <sys/mount.h>
+#include <sys/wait.h>
+
+#include <libnvpair.h>
+
+#include <json-nvlist/json-nvlist.h>
+#include <mdata-client/common.h>
+#include <mdata-client/dynstr.h>
+#include <mdata-client/plat.h>
+#include <mdata-client/proto.h>
+#include "../dockerinit/src/docker-common.h"
+#include "../common/strings/strlist.h"
+
+#define NFS_MOUNT "/usr/lib/fs/nfs/mount"
+#define SDC_VOLUMES_KEY "sdc:volumes"
+
+/* global metadata client bits */
+int initialized_proto = 0;
+mdata_proto_t *mdp;
+FILE *log_stream = stderr; // lxinit attaches our stderr to /dev/console
+
+/* not actually used, but needed for docker-common.c */
+char *hostname = NULL;
+struct passwd *pwd = NULL;
+struct group *grp = NULL;
+
+
+void
+makePath(const char *base, char *out, size_t outsz)
+{
+    const char *zroot = zone_get_nroot();
+
+    (void) snprintf(out, outsz, "%s%s", zroot != NULL ? zroot : "", base);
+}
+
+static void
+doNfsMount(const char *nfsvolume, const char *mountpoint, const char *mode)
+{
+    pid_t pid;
+    int status;
+    int ret;
+    char opts[MAX_MNTOPT_STR];
+
+    if (strlcpy(opts, "vers=3,sec=sys,", sizeof (opts)) >= sizeof (opts)) {
+        /* too long (something's busted. ERR_UNEXPECTED so we get a core) */
+        fatal(ERR_UNEXPECTED,
+            "internal error: strlcpy() opts not long enough");
+    }
+    if (strlcat(opts, mode, sizeof (opts)) >= sizeof (opts)) {
+        /* too long (something's busted. ERR_UNEXPECTED so we get a core) */
+        fatal(ERR_UNEXPECTED,
+            "internal error: strlcat() opts not long enough");
+    }
+
+    /* ensure the directory exists */
+    ret = mkdir(mountpoint, 0755);
+    if (ret == -1 && errno != EEXIST) {
+        fatal(ERR_MKDIR, "failed to mkdir(%s): (%d) %s\n", mountpoint,
+            errno, strerror(errno));
+    }
+
+    /* do the mount */
+
+    if ((pid = fork()) == -1) {
+        fatal(ERR_FORK_FAILED, "fork() failed: %s\n", strerror(errno));
+    }
+
+    if (pid == 0) {
+        /* child */
+        char cmd[MAXPATHLEN];
+        char *const argv[] = {
+            "mount",
+            "-o",
+            opts,
+            (char *)nfsvolume,
+            (char *)mountpoint,
+            NULL
+        };
+
+        makePath(NFS_MOUNT, cmd, sizeof (cmd));
+
+        execv(cmd, argv);
+        fatal(ERR_EXEC_FAILED, "execv(%s) failed: %s\n", cmd, strerror(errno));
+    }
+
+    /* parent */
+
+    while (wait(&status) != pid) {
+        /* EMPTY */;
+    }
+
+    if (WIFEXITED(status)) {
+        if (WEXITSTATUS(status) != 0) {
+            fatal(ERR_MOUNT_NFS_VOLUME, "mount[%d] exited non-zero (%d)\n",
+                (int)pid, WEXITSTATUS(status));
+        }
+    } else if (WIFSIGNALED(status)) {
+        fatal(ERR_EXEC_FAILED, "mount[%d] died on signal: %d\n",
+            (int)pid, WTERMSIG(status));
+    } else {
+        fatal(ERR_EXEC_FAILED, "mount[%d] failed in unknown way\n",
+            (int)pid);
+    }
+}
+
+static void
+mountNfsVolume(nvlist_t *data)
+{
+    char *mode = NULL;
+    char *mountpoint = NULL;
+    char *nfsvolume = NULL;
+    int ret;
+    char *type = NULL;
+
+    ret = nvlist_lookup_string(data, "type", &type);
+    if (ret == 0) {
+        if (strcmp(type, "tritonnfs") != 0) {
+            fatal(ERR_UNKNOWN_VOLUME_TYPE, "invalid volume type %s", type);
+        }
+        ret = nvlist_lookup_string(data, "nfsvolume", &nfsvolume);
+        if (ret == 0) {
+            ret = nvlist_lookup_string(data, "mountpoint", &mountpoint);
+            if (ret == 0) {
+                ret = nvlist_lookup_string(data, "mode", &mode);
+                if (ret != 0) {
+                    mode = "rw";
+                }
+                doNfsMount(nfsvolume, mountpoint, mode);
+                return;
+            }
+        }
+    }
+
+    fatal(ERR_INVALID_NFS_VOLUMES, "invalid nfsvolumes");
+}
+
+static void
+mountNfsVolumes()
+{
+    char *json;
+    nvlist_t *data, *nvl;
+    nvpair_t *pair;
+    int r;
+
+    if ((json = mdataGet(SDC_VOLUMES_KEY)) == NULL) {
+        /*
+         * No volumes, nothing to mount.
+         */
+        return;
+    }
+
+    r = nvlist_parse_json(json, strlen(json), &nvl, NVJSON_FORCE_INTEGER, NULL);
+    if (r != 0) {
+        fatal(ERR_PARSE_JSON, "failed to parse nvpair json"
+            " for %s: %s\n", SDC_VOLUMES_KEY, strerror(errno));
+    }
+    free(json);
+
+    for (pair = nvlist_next_nvpair(nvl, NULL); pair != NULL;
+      pair = nvlist_next_nvpair(nvl, pair)) {
+        if (nvpair_type(pair) == DATA_TYPE_NVLIST) {
+            if (nvpair_value_nvlist(pair, &data) != 0) {
+                fatal(ERR_PARSE_JSON, "failed to parse nvpair json"
+                    " for NFS volume: %s\n", strerror(errno));
+            }
+            mountNfsVolume(data);
+        }
+    }
+
+    nvlist_free(nvl);
+}
+
+int
+main(int argc, char *argv[])
+{
+    mountNfsVolumes();
+    return (EXIT_SUCCESS);
+}
diff --git a/src/manifest b/src/manifest
index 47fe91a8..287f6109 100644
--- a/src/manifest
+++ b/src/manifest
@@ -2,6 +2,7 @@ d usr/lib 0755 root bin
 d usr/lib/brand 0755 root bin
 d usr/lib/brand/lx 0755 root bin
 f usr/lib/brand/lx/lx_boot_zone_docker 0755 root root
+f usr/lib/brand/lx/lx_hook_postnet 0755 root root
 f usr/lib/brand/lx/routeinfo 0755 root root
 
 # automatically generated man.cf file
diff --git a/src/vm/lib/metadata/agent.js b/src/vm/lib/metadata/agent.js
index a4ef4232..e340892e 100644
--- a/src/vm/lib/metadata/agent.js
+++ b/src/vm/lib/metadata/agent.js
@@ -1372,6 +1372,18 @@ MetadataAgent.prototype.makeMetadataHandler = function (zone, socket) {
                             vmobj.internal_metadata['operator-script']);
                         return;
                     });
+                } else if (want === 'volumes') {
+                    addMetadata(function returnVolumes(err) {
+                        if (err) {
+                            returnit(new Error('Unable to load metadata: '
+                                + err.message));
+                            return;
+                        }
+
+                        returnit(null,
+                            vmobj.internal_metadata['sdc:volumes']);
+                        return;
+                    });
                 } else {
                     addTags(function (err) {
                         if (!err) {
