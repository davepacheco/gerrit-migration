From bcc6d54178771cc0fb8c48a2ca0260f5d8ba74b9 Mon Sep 17 00:00:00 2001
From: Josh Wilsdon <josh@wilsdon.ca>
Date: Thu, 14 Sep 2017 14:07:19 -0700
Subject: [PATCH] PUBAPI-1420 Add ability to mount NFS volumes with
 CreateMachine endpoint

---
 overlay/generic/lib/svc/method/mdata-fetch |  61 ++++++++-
 src/vm/lib/metadata/agent.js               |  12 ++
 src/volumeinfo/.gitignore                  |   2 +
 src/volumeinfo/Makefile                    | 122 +++++++++++++++++
 src/volumeinfo/main.c                      | 151 +++++++++++++++++++++
 5 files changed, 347 insertions(+), 1 deletion(-)
 create mode 100644 src/volumeinfo/.gitignore
 create mode 100644 src/volumeinfo/Makefile
 create mode 100644 src/volumeinfo/main.c

diff --git a/overlay/generic/lib/svc/method/mdata-fetch b/overlay/generic/lib/svc/method/mdata-fetch
index f0a1eab6..c03a0adc 100755
--- a/overlay/generic/lib/svc/method/mdata-fetch
+++ b/overlay/generic/lib/svc/method/mdata-fetch
@@ -21,7 +21,7 @@
 #
 # CDDL HEADER END
 #
-# Copyright (c) 2015, Joyent, Inc. All rights reserved.
+# Copyright (c) 2017, Joyent, Inc. All rights reserved.
 #
 
 export PS4='[\D{%FT%TZ}] ${BASH_SOURCE}:${LINENO}: ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
@@ -191,6 +191,65 @@ if [[ $? == 0 && -n ${tmpfs} && -f /etc/vfstab ]]; then
   fi
 fi
 
+#
+# If we have NFS volumes, we'll add them to vfstab, and enable the nfs/client
+# service so that will mount the volumes for us.
+#
+echo "Retrieving volume metadata..."
+
+volumes_added=0
+while IFS="|" read -r nfsvolume mountpoint name readonly type; do
+
+  cat >&2 <<EOF
+*** VOLUME ***
+NFSVOLUME: ${nfsvolume}
+MOUNTPOINT: ${mountpoint}
+NAME: ${name}
+READONLY: ${readonly}
+TYPE: ${type}
+EOF
+
+  if [[ -n ${type} && ${type} != "tritonnfs" ]]; then
+      echo "FATAL: unsupported volume type: ${type}" >&2
+      exit ${SMF_EXIT_ERR_FATAL}
+  fi
+
+  # if we don't have volume and mountpoint, we can't add vfstab lines
+  if [[ -z ${nfsvolume} || -z ${mountpoint} ]]; then
+      echo "FATAL: invalid volume specification" >&2
+      exit ${SMF_EXIT_ERR_FATAL}
+      continue
+  fi
+
+  if ! grep "^${nfsvolume}[ 	]" /etc/vfstab; then
+      if [[ ${readonly} == "true" ]]; then
+          mode="ro"
+      else
+          mode="rw"
+      fi
+      line=$(printf "%s - %s nfs - yes %s\n" "${nfsvolume}" "${mountpoint}" "${mode}")
+      volumes_added=$((${volumes_added}+1))
+
+      mkdir -p ${mountpoint}
+      echo "${line}" >> /etc/vfstab
+  fi
+done < <(/usr/sbin/mdata-get sdc:volumes \
+    | /usr/bin/json \
+        -d '|' \
+        -a nfsvolume mountpoint name readonly type)
+
+if [[ ${volumes_added} -gt 0 ]]; then
+    for svc in \
+        svc:/network/nfs/nlockmgr:default \
+        svc:/network/nfs/status:default \
+        svc:/network/rpc/bind:default \
+        svc:/network/nfs/client:default \
+        ; do
+
+        svcadm enable ${svc}
+     done
+fi
+
 # We use the special sdc:nics value here though this is not an interface for
 # use elsewhere.  If this is changed please also update agent.js in the metadata
 # agent.
diff --git a/src/vm/lib/metadata/agent.js b/src/vm/lib/metadata/agent.js
index a4ef4232..e340892e 100644
--- a/src/vm/lib/metadata/agent.js
+++ b/src/vm/lib/metadata/agent.js
@@ -1372,6 +1372,18 @@ MetadataAgent.prototype.makeMetadataHandler = function (zone, socket) {
                             vmobj.internal_metadata['operator-script']);
                         return;
                     });
+                } else if (want === 'volumes') {
+                    addMetadata(function returnVolumes(err) {
+                        if (err) {
+                            returnit(new Error('Unable to load metadata: '
+                                + err.message));
+                            return;
+                        }
+
+                        returnit(null,
+                            vmobj.internal_metadata['sdc:volumes']);
+                        return;
+                    });
                 } else {
                     addTags(function (err) {
                         if (!err) {
diff --git a/src/volumeinfo/.gitignore b/src/volumeinfo/.gitignore
new file mode 100644
index 00000000..fbfb16dc
--- /dev/null
+++ b/src/volumeinfo/.gitignore
@@ -0,0 +1,2 @@
+*.o
+volumeinfo
diff --git a/src/volumeinfo/Makefile b/src/volumeinfo/Makefile
new file mode 100644
index 00000000..2a4c6453
--- /dev/null
+++ b/src/volumeinfo/Makefile
@@ -0,0 +1,122 @@
+#
+# This file and its contents are supplied under the terms of the
+# Common Development and Distribution License ("CDDL"), version 1.0.
+# You may only use this file in accordance with the terms of version
+# 1.0 of the CDDL.
+#
+# A full copy of the text of the CDDL should have accompanied this
+# source.  A copy of the CDDL is also available via the Internet at
+# http://www.illumos.org/license/CDDL.
+#
+
+#
+# Copyright (c) 2017, Joyent, Inc.
+#
+
+BASE :=		$(PWD)
+DESTDIR =	$(BASE)/../../proto
+NATIVEDIR =	$(BASE)/../../proto.strap
+
+PROGRAM =	volumeinfo
+
+GCC =		$(NATIVEDIR)/usr/bin/gcc
+GXX =		$(NATIVEDIR)/usr/bin/g++
+
+SYSINCDIRS =	/usr/include
+SYSLIBDIRS =	/usr/lib /lib
+
+CFLAGS =	-std=gnu99 -Wall -Wextra -Werror -m32 -g \
+		-I$(DOCKER_DIR) \
+		-Wno-unused-parameter
+CPPFLAGS =	$(SYSINCDIRS:%=-isystem $(DESTDIR)/%)
+LDFLAGS =	$(SYSLIBDIRS:%=-L$(DESTDIR)/%) \
+		-Wl,-zassert-deflib -Wl,-zfatal-warnings
+
+STRINGS_DIR =	$(BASE)/../common/strings
+DOCKER_DIR =	$(BASE)/../dockerinit
+
+ROUTEINFO_OBJECTS = \
+		main.o
+
+MDATA_OBJECTS = \
+		dynstr.o \
+		proto.o \
+		common.o \
+		base64.o \
+		crc32.o \
+		reqid.o \
+		sunos.o \
+		unix_common.o
+
+custr.o :	CFLAGS += -I$(STRINGS_DIR)
+mdata_%.o :	CFLAGS += -I$(DOCKER_DIR)/mdata-client -D__HAVE_BOOLEAN_T
+
+OBJECTS = \
+		$(MDATA_OBJECTS:%=mdata_%) \
+		custr.o \
+		json-nvlist.o \
+		main.o
+
+json-nvlist.o :	CFLAGS += -I$(DOCKER_DIR)/json-nvlist -I$(STRINGS_DIR)
+
+LIBS =		-lnvpair -lnsl -lsocket -lsmbios
+
+CTFCONVERT =	/usr/bin/true
+CTFMERGE =	/usr/bin/true
+
+CC=$(GCC)
+CFLAGS +=	-Wall -Wextra -Werror -D__HAVE_BOOLEAN_T -m32
+CSTYLE =	../../tools/cstyle
+
+COMPILE_C =	$(CC) $(CPPFLAGS) $(LDFLAGS) $(CFLAGS) -c -o $@ $<
+
+INSTALL_PROG =	mkdir -p $(@D) && rm -f $@ && cp $^ $@ && \
+		chmod 755 $@ && touch $@
+
+.PHONY: all
+all: $(PROGRAM)
+
+.PHONY: check
+check: $(ROUTEINFO_OBJECTS:%.o=%.check)
+
+%.check: %.c
+	$(CSTYLE) -cPp $<
+
+lint:
+	/usr/bin/true
+
+clean:
+	rm -f $(OBJECTS)
+	rm -f $(PROGRAM)
+
+#
+# Compilation and linking targets
+#
+$(PROGRAM): $(OBJECTS)
+	$(CC) $(CPPFLAGS) $(LDFLAGS) $(CFLAGS) -o $@ $(OBJECTS) $(LIBS)
+	$(CTFMERGE) -L VERSION -o $@ $(OBJECTS)
+
+%.o: $(STRINGS_DIR)/%.c
+	$(COMPILE_C)
+	$(CTFCONVERT) -L VERSION $@
+
+mdata_%.o: $(DOCKER_DIR)/mdata-client/%.c
+	$(COMPILE_C)
+	$(CTFCONVERT) -L VERSION $@
+
+mdata_%.o: $(DOCKER_DIR)/mdata-client/plat/%.c
+	$(COMPILE_C)
+	$(CTFCONVERT) -L VERSION $@
+
+%.o: $(DOCKER_DIR)/json-nvlist/%.c
+	$(COMPILE_C)
+	$(CTFCONVERT) -L VERSION $@
+
+#
+# Installation
+#
+.PHONY: install
+install: $(DESTDIR)/usr/lib/brand/lx/$(PROGRAM)
+
+$(DESTDIR)/usr/lib/brand/lx/$(PROGRAM): $(PROGRAM)
+	$(INSTALL_PROG)
diff --git a/src/volumeinfo/main.c b/src/volumeinfo/main.c
new file mode 100644
index 00000000..dd74a000
--- /dev/null
+++ b/src/volumeinfo/main.c
@@ -0,0 +1,151 @@
+/*
+ * This file and its contents are supplied under the terms of the
+ * Common Development and Distribution License ("CDDL"), version 1.0.
+ * You may only use this file in accordance with the terms of version
+ * 1.0 of the CDDL.
+ *
+ * A full copy of the text of the CDDL should have accompanied this
+ * source.  A copy of the CDDL is also available via the Internet at
+ * http://www.illumos.org/license/CDDL.
+ */
+
+/*
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+
+/*
+ * This program forms a private interface between the LX brand in
+ * illumos-joyent and the volume configuration information stored by vmadm(1M)
+ * in SmartOS/SDC.
+ *
+ * When an LX branded zone boots, a special replacement for init(1M) is used,
+ * viz.  "/usr/lib/brand/lx/lxinit".  This program is responsible for
+ * configuring basic networking settings before starting the emulated Linux
+ * "init".  Some of these settings are stored in the zone configuration, but
+ * volumes are not; they are stored by vmadm(1M) in a form that requires
+ * some processing at runtime.   The volume configuration is, thus, accessed
+ * through the "sdc:volumes" metadata key from within the zone.
+ *
+ * This program, shipped as "/usr/lib/brand/lx/volumeinfo", is executed by
+ * "lxinit" to discover the current volume configuration.
+ */
+
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <strings.h>
+#include <err.h>
+
+#include <libnvpair.h>
+
+#include <json-nvlist/json-nvlist.h>
+#include <mdata-client/common.h>
+#include <mdata-client/dynstr.h>
+#include <mdata-client/plat.h>
+#include <mdata-client/proto.h>
+
+#define SDC_VOLUMES_KEY "sdc:volumes"
+
+int
+print_volumes(nvlist_t *nvl)
+{
+    uint32_t len;
+
+    /*
+     * The JSON stored in the volumes configuration is an array of
+     * objects.  Walk that array:
+     */
+    if (nvlist_lookup_uint32(nvl, "length", &len) != 0) {
+        fprintf(stderr, "ERROR: could not find \"length\" key\n");
+        return (-1);
+    }
+
+    for (uint32_t i = 0; i < len; i++) {
+        char idx[32];
+        nvlist_t *volume;
+        char *mode;
+        char *mountpoint;
+        char *name;
+        char *nfsvolume;
+        char *type;
+
+        (void) snprintf(idx, sizeof (idx), "%u", i);
+
+        if (nvlist_lookup_nvlist(nvl, idx, &volume) != 0) {
+            fprintf(stderr, "ERROR: could not find volume[%s]\n", idx);
+            return (-1);
+        }
+
+        if (nvlist_lookup_string(volume, "type", &type) != 0) {
+            fprintf(stderr, "ERROR: volume[%s] missing type\n", idx);
+            return (-1);
+        }
+
+        if (strcmp(type, "tritonnfs") != 0) {
+            fprintf(stderr, "ERROR: volume[%s] has unsupported type (%s)\n",
+                idx, type);
+            continue;
+        }
+
+        if (nvlist_lookup_string(volume, "mode", &mode) != 0) {
+            fprintf(stderr, "ERROR: volume[%s] missing mode\n", mode);
+            return (-1);
+        }
+
+        if (nvlist_lookup_string(volume, "mountpoint", &mountpoint) != 0) {
+            fprintf(stderr, "ERROR: volume[%s] missing mountpoint\n", idx);
+            return (-1);
+        }
+
+        if (nvlist_lookup_string(volume, "name", &name) != 0) {
+            fprintf(stderr, "ERROR: volume[%s] missing name\n", idx);
+            return (-1);
+        }
+
+        if (nvlist_lookup_string(volume, "nfsvolume", &nfsvolume) != 0) {
+            fprintf(stderr, "ERROR: volume[%s] missing nfsvolume\n", idx);
+            return (-1);
+        }
+
+        fprintf(stdout, "%s|%s|%s|%s|%s\n",
+            type, nfsvolume, mountpoint, name, mode);
+        fflush(stdout);
+    }
+
+    return (0);
+}
+
+int
+main(int argc, char *argv[])
+{
+    nvlist_t *nvl = NULL;
+    char *errmsg = NULL;
+    mdata_proto_t *mdp;
+    mdata_response_t mdr;
+    string_t *data;
+    nvlist_parse_json_error_t nje;
+
+    if (proto_init(&mdp, &errmsg) != 0) {
+        errx(EXIT_FAILURE, "could not initialise mdata: %s",
+            errmsg == NULL ?  "?" : errmsg);
+    }
+
+    if (proto_execute(mdp, "GET", SDC_VOLUMES_KEY, &mdr, &data) != 0) {
+        errx(EXIT_FAILURE, "could not get \"%s\" mdata",
+            SDC_VOLUMES_KEY);
+    }
+
+    if (nvlist_parse_json(dynstr_cstr(data), dynstr_len(data),
+        &nvl, 0, &nje) != 0) {
+        errx(EXIT_FAILURE, "could not parse \"%s\" mdata as JSON: %s",
+            SDC_VOLUMES_KEY, nje.nje_message);
+    }
+
+    if (print_volumes(nvl) != 0) {
+        errx(EXIT_FAILURE, "could not print volumes from \"%s\" mdata",
+            SDC_VOLUMES_KEY);
+    }
+
+    nvlist_free(nvl);
+    return (EXIT_SUCCESS);
+}
-- 
2.21.0

