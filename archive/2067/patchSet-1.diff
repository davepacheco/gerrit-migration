commit 8aeef8e1115bfec39d03898c25e7eedfc99401db (refs/changes/67/2067/1)
Author: Jared Morrow <jm@joyent.com>
Date:   2017-06-09T14:47:06+00:00 (2 years, 4 months ago)
    
    MANTA-2900 mlocate should not need to setupMantaBuckets

diff --git a/lib/moray.js b/lib/moray.js
index 3790927..32b96f9 100644
--- a/lib/moray.js
+++ b/lib/moray.js
@@ -202,7 +202,6 @@ function setupMantaBuckets(log, client, cb) {
  */
 function setupMantaTrigger(log, client, cb) {
     var readoptions, updatesql, funcsql;
-
     readoptions = { 'encoding': 'utf8' };
 
     return (vasync.waterfall([
@@ -482,6 +481,11 @@ function Moray(options) {
     this.log = options.log.child({ component: 'MorayIndexClient' }, true);
     this.morayOptions.log = this.log;
     this.morayOptions.unwrapErrors = true;
+    this.readOnly = false;
+
+    if (options.hasOwnProperty('readOnly') && options.readOnly === true) {
+        this.readOnly = true;
+    }
 
     /*
      * Configure the exponential backoff object we use to manage backoff during
@@ -559,30 +563,43 @@ Moray.prototype.initAttempt = function initAttempt() {
         'attempt': this.initAttempts
     }, 'libmanta.Moray.initAttempt: entered');
 
-    this.initPipeline = vasync.waterfall([
-        function initClient(callback) {
-            self.client = moray.createClient(self.morayOptions);
+    var vasync_steps = [];
 
-            var onErrorDuringConnect = function onErrDuringConnect(err) {
-                callback(new VError(err, 'moray client error'));
-            };
+    /*
+     * Define vasync waterfall steps such that we can
+     * conditionally decide which ones to add to the waterfall
+     */
+    function initClient(callback) {
+        self.client = moray.createClient(self.morayOptions);
 
-            self.client.on('error', onErrorDuringConnect);
-            self.client.once('connect', function onConnect() {
-                self.client.removeListener('error', onErrorDuringConnect);
-                self.client.on('error', self.onErrorDuringInit);
-                callback();
-            });
-        },
+        var onErrorDuringConnect = function onErrDuringConnect(err) {
+            callback(new VError(err, 'moray client error'));
+        };
 
-        function setupBuckets(callback) {
-            self.initBuckets = setupMantaBuckets(log, self.client, callback);
-        },
+        self.client.on('error', onErrorDuringConnect);
+        self.client.once('connect', function onConnect() {
+            self.client.removeListener('error', onErrorDuringConnect);
+            self.client.on('error', self.onErrorDuringInit);
+            callback();
+        });
+    }
 
-        function setupTrigger(callback) {
-            self.initTrigger = setupMantaTrigger(log, self.client, callback);
-        }
-    ], function (err) {
+    function setupBuckets(callback) {
+        self.initBuckets = setupMantaBuckets(log, self.client, callback);
+    }
+
+    function setupTrigger(callback) {
+        self.initTrigger = setupMantaTrigger(log, self.client, callback);
+    }
+
+    vasync_steps.push(initClient);
+    // If this is a readOnly client, do not do database setup tasks
+    if (!this.readOnly) {
+        vasync_steps.push(setupBuckets);
+        vasync_steps.push(setupTrigger);
+    }
+
+    this.initPipeline = vasync.waterfall(vasync_steps, function (err) {
         self.initPipeline = null;
         self.initBuckets = null;
         self.initTrigger = null;
@@ -597,17 +614,17 @@ Moray.prototype.initAttempt = function initAttempt() {
             self.initBackoff.backoff(err);
         } else {
             /*
-             * We could reset the "backoff" object in the success case, or even
-             * null it out since we're never going to use it again.  But it's
-             * not that large, and it may be useful for debugging, so we just
-             * leave it alone.
+             * We could reset the "backoff" object in the success case, or
+             * even null it out since we're never going to use it again.
+             * But it's not that large, and it may be useful for debugging,
+             * so we just leave it alone.
              */
             self.client.removeListener('error', self.onErrorDuringInit);
             self.client.on('error', self.onErrorPostInit);
             self.client.on('close', self.emit.bind(self, 'close'));
             self.client.on('connect', self.emit.bind(self, 'connect'));
             log.info({ 'attempt': self.initAttempts },
-                'libmanta.Moray.initAttempt: done');
+                     'libmanta.Moray.initAttempt: done');
             self.emit('connect');
         }
     });
@@ -619,6 +636,13 @@ Moray.prototype.putMetadata = function putMetadata(options, callback) {
     assert.string(options.key, 'options.key');
     assert.string(options.requestId, 'options.requestId');
     assert.func(callback, 'callback');
+    if (this.readOnly) {
+        throw new assert.AssertionError({
+            message: 'Operation putMetadata ' +
+                      'not supported in a read-only client'
+        });
+    }
+
     if (!options.upload) {
         assert.object(options, 'options.previousMetadata');
     } else {
@@ -681,6 +705,13 @@ function putFinalizingMetadata(options, callback) {
 
     callback = once(callback);
 
+    if (this.readOnly) {
+        throw new assert.AssertionError({
+            message: 'Operation putFinalizingMetadata ' +
+                      'not supported in a read-only client'
+        });
+    }
+
     if (!this.client) {
         setImmediate(function () {
             callback(new Error('not connected'));
@@ -978,7 +1009,6 @@ Moray.prototype.ping = function ping(opts, cb) {
 };
 
 
-
 ///--- Low level wrappers over the plain jane Moray Client
 
 Moray.prototype.search = function search(options) {
@@ -1030,7 +1060,6 @@ Moray.prototype.toString = function toString() {
 };
 
 
-
 ///--- Exports
 
 module.exports = {
diff --git a/test/moray.test.js b/test/moray.test.js
index 0847050..ec9b64c 100644
--- a/test/moray.test.js
+++ b/test/moray.test.js
@@ -9,6 +9,7 @@
  */
 
 var once = require('once');
+var net = require('net');
 var libuuid = require('libuuid');
 
 var libmanta = require('../lib');
@@ -25,6 +26,8 @@ var before = helper.before;
 var after = helper.after;
 var test = helper.test;
 
+// For put / get test and common options (uuid's)
+var gOpts = makeOpts({type: 'directory'});
 
 
 ///--- Helpers
@@ -70,8 +73,7 @@ function makeOpts(opts) {
 }
 
 
-
-///--- Tests
+///--- Setup
 
 before(function (cb) {
     cb = once(cb);
@@ -81,44 +83,24 @@ before(function (cb) {
         return;
     }
 
-    // Uncomment the lines below to test MANTA-1342,
-    // and make sure to change the "real" ring's "cb" to "_cb"
-    //
-    // var MAX = 5;
-    // var rings = [];
-
-    // var done = 0;
-    // var _err;
-    // function _cb(err) {
-    //         _err = err || _err;
-    //         if (++done === MAX+1) {
-    //                 rings.forEach(function (r) {
-    //                         r.close();
-    //                 });
-    //                 cb(_err);
-    //         }
-    // }
-
-    // for (var i = 0; i < 5; i++) {
-    //         var r = libmanta.createMorayClient({
-    //                 log: helper.createLogger(),
-    //                 host: process.env.ELECTRIC_MORAY,
-    //                 port: 2020
-    //         });
-    //         if (r) {
-    //                 rings.push(r);
-    //                 r.once('error', _cb);
-    //                 r.once('connect', _cb);
-    //         } else {
-    //                 process.nextTick(_cb);
-    //         }
-    // }
+    /*
+     * Support both proper hostname and IP for ELECTRIC_MORAY
+     * environment variable.
+     */
+    var eMorayType = {};
+    if (net.isIP(process.env.ELECTRIC_MORAY))  {
+        eMorayType = {
+            host: process.env.ELECTRIC_MORAY
+        };
+    } else {
+        eMorayType = {
+            srvDomain: process.env.ELECTRIC_MORAY
+        };
+    }
 
     this.ring = libmanta.createMorayClient({
         log: helper.createLogger(),
-        morayOptions: {
-            srvDomain: process.env.ELECTRIC_MORAY
-        }
+        morayOptions: eMorayType
     });
 
     this.ring.once('error', cb);
@@ -126,13 +108,18 @@ before(function (cb) {
 });
 
 
+///--- Teardown
+
 after(function (cb) {
-    if (this.ring)
+    if (this.ring) {
         this.ring.close();
+    }
     cb();
 });
 
 
+///--- Tests
+
 test('putMetadata (object) not root', function (t) {
     var opts = makeOpts();
     this.ring.putMetadata(opts, function (err, md) {
@@ -145,7 +132,6 @@ test('putMetadata (object) not root', function (t) {
     });
 });
 
-
 test('putMetadata (object) root', function (t) {
     var opts = makeOpts({path: ''});
     this.ring.putMetadata(opts, function (err, md) {
@@ -156,7 +142,6 @@ test('putMetadata (object) root', function (t) {
     });
 });
 
-
 test('putMetadata (link) not root', function (t) {
     var opts = makeOpts({type: 'link'});
     this.ring.putMetadata(opts, function (err, md) {
@@ -169,23 +154,25 @@ test('putMetadata (link) not root', function (t) {
     });
 });
 
-
 test('putMetadata (directory) root', function (t) {
-    var opts = makeOpts({type: 'directory'});
-    this.ring.putMetadata(opts, function (err, md) {
+    this.ring.putMetadata(gOpts, function (err, md) {
+        // Save this key for the moray read-only test
+        // later since the read-only test cannot
+        // write before read
+        process.env['TEST_GET_KEY'] = gOpts.key;
         t.ifError(err);
         t.ok(md);
-        t.equal(md.dirname, '/' + opts.owner + '/stor');
+        t.equal(md.dirname, '/' + gOpts.owner + '/stor');
         t.end();
     });
 });
 
-
-// Need resharding
-// test('add a node, and ensure we get an update', function (t) {
-//         this.ring.once('update', function (ring) {
-//                 t.ok(ring);
-//                 t.end();
-//         });
-//         this.ring.addShard('tcp://2.moray.' + LAB_HOST + '.joyent.us:2020');
-// });
+// Get back what we put in the putMetadata test above
+test('getMetadata (directory) root', function (t) {
+    this.ring.getMetadata(gOpts, function (err, md) {
+        t.ifError(err);
+        t.ok(md);
+        t.equal(md.key, '/' + gOpts.owner + '/stor/' + gOpts.objectId);
+        t.end();
+    });
+});
diff --git a/test/zmoray-ro.test.js b/test/zmoray-ro.test.js
new file mode 100644
index 0000000..9883c23
--- /dev/null
+++ b/test/zmoray-ro.test.js
@@ -0,0 +1,146 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+
+var once = require('once');
+var net = require('net');
+var libuuid = require('libuuid');
+
+var libmanta = require('../lib');
+
+if (require.cache[__dirname + '/helper.js'])
+    delete require.cache[__dirname + '/helper.js'];
+var helper = require('./helper.js');
+
+
+
+///--- Globals
+
+var before = helper.before;
+var after = helper.after;
+var test = helper.test;
+
+///--- Helpers
+
+function makeKey(customer, path) {
+    return ('/' + customer + '/stor' + (path || ''));
+}
+
+
+function makeOpts(opts) {
+    opts = opts || {};
+    var id = opts.objectId || libuuid.create();
+    var owner = opts.owner || libuuid.create();
+    var key = makeKey(owner, (opts.path || '/' + id));
+
+    var _opts = {
+        objectId: id,
+        owner: owner,
+        key: key,
+        requestId: libuuid.create(),
+        type: opts.type || 'object'
+    };
+
+    switch (_opts.type) {
+    case 'object':
+        _opts.contentLength = Math.floor(Math.random() * 1025);
+        _opts.contentMD5 = 'MHhkZWFkYmVlZg==';
+        _opts.contentType = 'text/plain';
+        _opts.sharks = [ {
+            manta_storage_id: '1.stor.ring.test'
+        } ];
+        break;
+
+    case 'link':
+        _opts.link = makeOpts();
+        break;
+
+    default:
+        break;
+    }
+
+    return (_opts);
+}
+
+
+
+///--- Tests of read-only client
+
+before(function (cb) {
+    cb = once(cb);
+
+    if (!process.env.ELECTRIC_MORAY) {
+        cb(new Error('ELECTRIC_MORAY must be specified'));
+        return;
+    }
+
+    if (!process.env.TEST_GET_KEY) {
+        cb(new Error('TEST_GET_KEY must be specified'));
+        return;
+    }
+
+    /*
+     * Support both proper hostname and IP for ELECTRIC_MORAY
+     * environment variable.
+     */
+    var eMorayType = {};
+    if (net.isIP(process.env.ELECTRIC_MORAY))  {
+        eMorayType = {
+            host: process.env.ELECTRIC_MORAY
+        };
+    } else {
+        eMorayType = {
+            srvDomain: process.env.ELECTRIC_MORAY
+        };
+    }
+
+    this.ring = libmanta.createMorayClient({
+        readOnly: true,
+        log: helper.createLogger(),
+        morayOptions: eMorayType
+    });
+
+    this.tKey = process.env.TEST_GET_KEY;
+
+    this.ring.once('error', cb);
+    this.ring.once('connect', cb);
+});
+
+
+after(function (cb) {
+    if (this.ring) {
+        this.ring.close();
+    }
+    cb();
+});
+
+test('negative test: putMetadata on read-only client', function (t) {
+    var opts = makeOpts();
+    t.throws(
+        function () {
+            this.ring.putMetadata(opts, function (err, md) {
+                t.ifError(err);
+                t.ok(md);
+            });
+        },
+        'Error: putMetadata should throw with a read-only client');
+    t.end();
+});
+
+test('getMetadata: read-only client', function (t) {
+    var opts = {
+        key: this.tKey,
+        requestId: libuuid.create()
+    };
+    this.ring.getMetadata(opts, function (err, md) {
+        t.ifError(err);
+        t.ok(md);
+        t.end();
+    });
+});
