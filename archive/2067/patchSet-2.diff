From a3f87bd58d0f4bdf1bfee31ca7402d93b51499d2 Mon Sep 17 00:00:00 2001
From: Jared Morrow <jm@joyent.com>
Date: Fri, 30 Jun 2017 23:07:41 +0000
Subject: [PATCH] MANTA-2900 mlocate should not need to setupMantaBuckets

---
 lib/moray.js          |  89 ++++++++++++------
 test/moray-ro.test.js | 205 ++++++++++++++++++++++++++++++++++++++++++
 test/moray.test.js    |  89 ++++++++----------
 3 files changed, 303 insertions(+), 80 deletions(-)
 create mode 100644 test/moray-ro.test.js

diff --git a/lib/moray.js b/lib/moray.js
index 3790927..50c52e3 100644
--- a/lib/moray.js
+++ b/lib/moray.js
@@ -464,6 +464,8 @@ function put(options, cb) {
 function Moray(options) {
     var self = this;
 
+    assert.optionalBool(options.readOnly, 'options.readOnly');
+
     EventEmitter.call(this);
 
     this.client = null;
@@ -482,6 +484,11 @@ function Moray(options) {
     this.log = options.log.child({ component: 'MorayIndexClient' }, true);
     this.morayOptions.log = this.log;
     this.morayOptions.unwrapErrors = true;
+    this.readOnly = false;
+
+    if (options.readOnly) {
+        this.readOnly = true;
+    }
 
     /*
      * Configure the exponential backoff object we use to manage backoff during
@@ -559,30 +566,43 @@ Moray.prototype.initAttempt = function initAttempt() {
         'attempt': this.initAttempts
     }, 'libmanta.Moray.initAttempt: entered');
 
-    this.initPipeline = vasync.waterfall([
-        function initClient(callback) {
-            self.client = moray.createClient(self.morayOptions);
+    var initFuncs = [];
 
-            var onErrorDuringConnect = function onErrDuringConnect(err) {
-                callback(new VError(err, 'moray client error'));
-            };
+    /*
+     * Define vasync waterfall steps such that we can
+     * conditionally decide which ones to add to the waterfall
+     */
+    function initClient(callback) {
+        self.client = moray.createClient(self.morayOptions);
 
-            self.client.on('error', onErrorDuringConnect);
-            self.client.once('connect', function onConnect() {
-                self.client.removeListener('error', onErrorDuringConnect);
-                self.client.on('error', self.onErrorDuringInit);
-                callback();
-            });
-        },
+        var onErrorDuringConnect = function onErrDuringConnect(err) {
+            callback(new VError(err, 'moray client error'));
+        };
 
-        function setupBuckets(callback) {
-            self.initBuckets = setupMantaBuckets(log, self.client, callback);
-        },
+        self.client.on('error', onErrorDuringConnect);
+        self.client.once('connect', function onConnect() {
+            self.client.removeListener('error', onErrorDuringConnect);
+            self.client.on('error', self.onErrorDuringInit);
+            callback();
+        });
+    }
 
-        function setupTrigger(callback) {
-            self.initTrigger = setupMantaTrigger(log, self.client, callback);
-        }
-    ], function (err) {
+    function setupBuckets(callback) {
+        self.initBuckets = setupMantaBuckets(log, self.client, callback);
+    }
+
+    function setupTrigger(callback) {
+        self.initTrigger = setupMantaTrigger(log, self.client, callback);
+    }
+
+    initFuncs.push(initClient);
+    // If this is a readOnly client, do not do database setup tasks
+    if (!this.readOnly) {
+        initFuncs.push(setupBuckets);
+        initFuncs.push(setupTrigger);
+    }
+
+    this.initPipeline = vasync.waterfall(initFuncs, function (err) {
         self.initPipeline = null;
         self.initBuckets = null;
         self.initTrigger = null;
@@ -597,17 +617,17 @@ Moray.prototype.initAttempt = function initAttempt() {
             self.initBackoff.backoff(err);
         } else {
             /*
-             * We could reset the "backoff" object in the success case, or even
-             * null it out since we're never going to use it again.  But it's
-             * not that large, and it may be useful for debugging, so we just
-             * leave it alone.
+             * We could reset the "backoff" object in the success case, or
+             * even null it out since we're never going to use it again.
+             * But it's not that large, and it may be useful for debugging,
+             * so we just leave it alone.
              */
             self.client.removeListener('error', self.onErrorDuringInit);
             self.client.on('error', self.onErrorPostInit);
             self.client.on('close', self.emit.bind(self, 'close'));
             self.client.on('connect', self.emit.bind(self, 'connect'));
             log.info({ 'attempt': self.initAttempts },
-                'libmanta.Moray.initAttempt: done');
+                     'libmanta.Moray.initAttempt: done');
             self.emit('connect');
         }
     });
@@ -618,7 +638,16 @@ Moray.prototype.putMetadata = function putMetadata(options, callback) {
     assert.object(options, 'options');
     assert.string(options.key, 'options.key');
     assert.string(options.requestId, 'options.requestId');
+    assert.optionalBool(this.readOnly, 'this.readOnly');
     assert.func(callback, 'callback');
+
+    if (this.readOnly) {
+        throw new assert.AssertionError({
+            message: 'Operation putMetadata ' +
+                      'not supported in a read-only client'
+        });
+    }
+
     if (!options.upload) {
         assert.object(options, 'options.previousMetadata');
     } else {
@@ -677,10 +706,18 @@ function putFinalizingMetadata(options, callback) {
     assert.string(options.md.requestId, 'options.md.requestId');
     assert.string(options.md.objectPath, 'options.md.objectPath');
     assert.string(options.md.objectId, 'options.md.objectId');
+    assert.optionalBool(this.readOnly, 'this.readOnly');
     assert.func(callback, 'callback');
 
     callback = once(callback);
 
+    if (this.readOnly) {
+        throw new assert.AssertionError({
+            message: 'Operation putFinalizingMetadata ' +
+                      'not supported in a read-only client'
+        });
+    }
+
     if (!this.client) {
         setImmediate(function () {
             callback(new Error('not connected'));
@@ -978,7 +1015,6 @@ Moray.prototype.ping = function ping(opts, cb) {
 };
 
 
-
 ///--- Low level wrappers over the plain jane Moray Client
 
 Moray.prototype.search = function search(options) {
@@ -1030,7 +1066,6 @@ Moray.prototype.toString = function toString() {
 };
 
 
-
 ///--- Exports
 
 module.exports = {
diff --git a/test/moray-ro.test.js b/test/moray-ro.test.js
new file mode 100644
index 0000000..958bb94
--- /dev/null
+++ b/test/moray-ro.test.js
@@ -0,0 +1,205 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+
+var once = require('once');
+var net = require('net');
+var libuuid = require('libuuid');
+var vasync = require('vasync');
+
+var libmanta = require('../lib');
+
+if (require.cache[__dirname + '/helper.js'])
+    delete require.cache[__dirname + '/helper.js'];
+var helper = require('./helper.js');
+
+
+
+///--- Globals
+
+var before = helper.before;
+var after = helper.after;
+var test = helper.test;
+
+///--- Helpers
+
+function makeKey(customer, path) {
+    return ('/' + customer + '/stor' + (path || ''));
+}
+
+
+function makeOpts(opts) {
+    opts = opts || {};
+    var id = opts.objectId || libuuid.create();
+    var owner = opts.owner || libuuid.create();
+    var key = makeKey(owner, (opts.path || '/' + id));
+
+    var _opts = {
+        objectId: id,
+        owner: owner,
+        key: key,
+        requestId: libuuid.create(),
+        type: opts.type || 'object'
+    };
+
+    switch (_opts.type) {
+    case 'object':
+        _opts.contentLength = Math.floor(Math.random() * 1025);
+        _opts.contentMD5 = 'MHhkZWFkYmVlZg==';
+        _opts.contentType = 'text/plain';
+        _opts.sharks = [ {
+            manta_storage_id: '1.stor.ring.test'
+        } ];
+        break;
+
+    case 'link':
+        _opts.link = makeOpts();
+        break;
+
+    default:
+        break;
+    }
+
+    return (_opts);
+}
+
+
+
+///--- Tests of read-only client
+
+before(function (cb) {
+    cb = once(cb);
+
+    if (!process.env.ELECTRIC_MORAY) {
+        cb(new Error('ELECTRIC_MORAY must be specified'));
+        return;
+    }
+
+    /*
+     * Support both proper hostname and IP for ELECTRIC_MORAY
+     * environment variable.
+     */
+    var eMorayType = {};
+    if (net.isIP(process.env.ELECTRIC_MORAY))  {
+        eMorayType = {
+            host: process.env.ELECTRIC_MORAY
+        };
+    } else {
+        eMorayType = {
+            srvDomain: process.env.ELECTRIC_MORAY
+        };
+    }
+
+    /*
+     * Create both a read-only and standard
+     * moray client.
+     */
+    var barrier = vasync.barrier();
+    var setupErr = null;
+
+    this.tKey = process.env.TEST_GET_KEY;
+
+    barrier.on('drain', function () {
+        if (setupErr) {
+            cb(setupErr);
+        }
+        cb();
+    });
+
+    barrier.start('read-only ring');
+    this.roRing = libmanta.createMorayClient({
+        readOnly: true,
+        log: helper.createLogger(),
+        morayOptions: eMorayType
+    });
+    this.roRing.once('connect', function () {
+        barrier.done('read-only ring');
+    });
+    this.roRing.once('error', function (err) {
+        setupErr = err;
+        barrier.done('read-only ring');
+    });
+
+
+    barrier.start('ring');
+    this.ring = libmanta.createMorayClient({
+        log: helper.createLogger(),
+        morayOptions: eMorayType
+    });
+    this.ring.once('connect', function () {
+        barrier.done('ring');
+    });
+    this.ring.once('error', function (err) {
+        setupErr = err;
+        barrier.done('ring');
+    });
+
+});
+
+
+after(function (cb) {
+    if (this.roRing) {
+        this.roRing.close();
+    }
+
+    if (this.ring) {
+        this.ring.close();
+    }
+    cb();
+});
+
+test('negative test: putMetadata on read-only client', function (t) {
+    var opts = makeOpts();
+    t.throws(
+        function () {
+            this.roRing.putMetadata(opts, function (err, md) {
+                t.ifError(err);
+                t.ok(md);
+            });
+        },
+        'Error: putMetadata should throw with a read-only client');
+    t.end();
+});
+
+test('negative test: putFinalizingMetadata on read-only client', function (t) {
+    var opts = makeOpts();
+    opts.md = new Object();
+    opts.md.uploadId = 'Some strings';
+    opts.md.finalizingType = 'that will';
+    opts.md.owner = 'bypass';
+    opts.md.requestId = 'all the';
+    opts.md.objectPath = 'standard options';
+    opts.md.objectId = 'of putFinalizingmetadata';
+    t.throws(
+        function () {
+            this.roRing.putFinalizingMetadata(opts, function (err, md) {
+                t.ifError(err);
+                t.ok(md);
+            });
+        },
+        'Error: putMetadata should throw with a read-only client');
+    t.end();
+});
+
+test('getMetadata: read-only client', function (t) {
+    // Use the read-write client to write an object we then read back
+    var pOpts = makeOpts({type: 'directory'});
+    var roRing = this.roRing;
+    this.ring.putMetadata(pOpts, function (err, md) {
+        var opts = {
+            key: pOpts.key,
+            requestId: libuuid.create()
+        };
+        roRing.getMetadata(opts, function (err2, md2) {
+            t.ifError(err2);
+            t.ok(md2);
+            t.end();
+        });
+    });
+});
diff --git a/test/moray.test.js b/test/moray.test.js
index 0847050..184d978 100644
--- a/test/moray.test.js
+++ b/test/moray.test.js
@@ -9,6 +9,7 @@
  */
 
 var once = require('once');
+var net = require('net');
 var libuuid = require('libuuid');
 
 var libmanta = require('../lib');
@@ -25,6 +26,8 @@ var before = helper.before;
 var after = helper.after;
 var test = helper.test;
 
+// For put / get test and common options (uuid's)
+var gOpts = makeOpts({type: 'directory'});
 
 
 ///--- Helpers
@@ -70,8 +73,7 @@ function makeOpts(opts) {
 }
 
 
-
-///--- Tests
+///--- Setup
 
 before(function (cb) {
     cb = once(cb);
@@ -81,44 +83,24 @@ before(function (cb) {
         return;
     }
 
-    // Uncomment the lines below to test MANTA-1342,
-    // and make sure to change the "real" ring's "cb" to "_cb"
-    //
-    // var MAX = 5;
-    // var rings = [];
-
-    // var done = 0;
-    // var _err;
-    // function _cb(err) {
-    //         _err = err || _err;
-    //         if (++done === MAX+1) {
-    //                 rings.forEach(function (r) {
-    //                         r.close();
-    //                 });
-    //                 cb(_err);
-    //         }
-    // }
-
-    // for (var i = 0; i < 5; i++) {
-    //         var r = libmanta.createMorayClient({
-    //                 log: helper.createLogger(),
-    //                 host: process.env.ELECTRIC_MORAY,
-    //                 port: 2020
-    //         });
-    //         if (r) {
-    //                 rings.push(r);
-    //                 r.once('error', _cb);
-    //                 r.once('connect', _cb);
-    //         } else {
-    //                 process.nextTick(_cb);
-    //         }
-    // }
+    /*
+     * Support both proper hostname and IP for ELECTRIC_MORAY
+     * environment variable.
+     */
+    var eMorayType = {};
+    if (net.isIP(process.env.ELECTRIC_MORAY))  {
+        eMorayType = {
+            host: process.env.ELECTRIC_MORAY
+        };
+    } else {
+        eMorayType = {
+            srvDomain: process.env.ELECTRIC_MORAY
+        };
+    }
 
     this.ring = libmanta.createMorayClient({
         log: helper.createLogger(),
-        morayOptions: {
-            srvDomain: process.env.ELECTRIC_MORAY
-        }
+        morayOptions: eMorayType
     });
 
     this.ring.once('error', cb);
@@ -126,13 +108,18 @@ before(function (cb) {
 });
 
 
+///--- Teardown
+
 after(function (cb) {
-    if (this.ring)
+    if (this.ring) {
         this.ring.close();
+    }
     cb();
 });
 
 
+///--- Tests
+
 test('putMetadata (object) not root', function (t) {
     var opts = makeOpts();
     this.ring.putMetadata(opts, function (err, md) {
@@ -145,7 +132,6 @@ test('putMetadata (object) not root', function (t) {
     });
 });
 
-
 test('putMetadata (object) root', function (t) {
     var opts = makeOpts({path: ''});
     this.ring.putMetadata(opts, function (err, md) {
@@ -156,7 +142,6 @@ test('putMetadata (object) root', function (t) {
     });
 });
 
-
 test('putMetadata (link) not root', function (t) {
     var opts = makeOpts({type: 'link'});
     this.ring.putMetadata(opts, function (err, md) {
@@ -169,23 +154,21 @@ test('putMetadata (link) not root', function (t) {
     });
 });
 
-
 test('putMetadata (directory) root', function (t) {
-    var opts = makeOpts({type: 'directory'});
-    this.ring.putMetadata(opts, function (err, md) {
+    this.ring.putMetadata(gOpts, function (err, md) {
         t.ifError(err);
         t.ok(md);
-        t.equal(md.dirname, '/' + opts.owner + '/stor');
+        t.equal(md.dirname, '/' + gOpts.owner + '/stor');
         t.end();
     });
 });
 
-
-// Need resharding
-// test('add a node, and ensure we get an update', function (t) {
-//         this.ring.once('update', function (ring) {
-//                 t.ok(ring);
-//                 t.end();
-//         });
-//         this.ring.addShard('tcp://2.moray.' + LAB_HOST + '.joyent.us:2020');
-// });
+// Get back what we put in the putMetadata test above
+test('getMetadata (directory) root', function (t) {
+    this.ring.getMetadata(gOpts, function (err, md) {
+        t.ifError(err);
+        t.ok(md);
+        t.equal(md.key, '/' + gOpts.owner + '/stor/' + gOpts.objectId);
+        t.end();
+    });
+});
-- 
2.21.0

