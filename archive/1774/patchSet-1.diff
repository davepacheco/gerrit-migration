From 7221c3e9f4681470a3b5344120925b3f91d99f3b Mon Sep 17 00:00:00 2001
From: Jerry Jelinek <jerry.jelinek@joyent.com>
Date: Mon, 10 Apr 2017 15:39:17 +0000
Subject: [PATCH] OS-6019 missing sysfs /sys/devices/system/cpu and relevant
 entries below

---
 .../uts/common/brand/lx/sysfs/lx_sysvnops.c   | 128 ++++++++++++++----
 1 file changed, 105 insertions(+), 23 deletions(-)

diff --git a/usr/src/uts/common/brand/lx/sysfs/lx_sysvnops.c b/usr/src/uts/common/brand/lx/sysfs/lx_sysvnops.c
index 3d545c7c28..e955564fd9 100644
--- a/usr/src/uts/common/brand/lx/sysfs/lx_sysvnops.c
+++ b/usr/src/uts/common/brand/lx/sysfs/lx_sysvnops.c
@@ -145,8 +145,10 @@ const fs_operation_def_t lxsys_vnodeops_template[] = {
  * - 0x0a: /sys/devices/zfs
  * - 0x0b: /sys/devices/system/cpu
  * - 0x0c: /sys/devices/system/cpu/kernel_max
- * - 0x0d: /sys/devices/system/node
- * - 0x0e: /sys/bus
+ * - 0x0d: /sys/devices/system/cpu/possible
+ * - 0x0e: /sys/devices/system/cpu/present
+ * - 0x0f: /sys/devices/system/node
+ * - 0x10: /sys/bus
  *
  * Dynamic /sys/class/net/<interface> symlinks will use an INSTANCE derived
  * from the corresonding ifindex.
@@ -161,8 +163,8 @@ const fs_operation_def_t lxsys_vnodeops_template[] = {
  * Dynamic /sys/devices/zfs/<dev> directories will use an INSTANCE derived from
  * the emulated minor number.
  *
- * Static/Dynamic /sys/devices/system/cpu contains a static kernel_max file
- * and a dynamic set of cpuN subdirectories.
+ * Static/Dynamic /sys/devices/system/cpu contains the static 'kernel_max',
+ * 'possible', and 'present' files, and a dynamic set of cpuN subdirectories.
  *
  * Static/Dynamic /sys/devices/system/node/node0 currently only contains a
  * static cpulist file, but will likely need future dynamic entries for cpuN
@@ -186,8 +188,10 @@ const fs_operation_def_t lxsys_vnodeops_template[] = {
 #define	LXSYS_INST_DEVICES_ZFSDIR		0xa
 #define	LXSYS_INST_DEVICES_SYSCPU		0xb
 #define	LXSYS_INST_DEV_SYSCPU_KMAX		0xc
-#define	LXSYS_INST_DEVICES_SYSNODE		0xd
-#define	LXSYS_INST_BUSDIR			0xe
+#define	LXSYS_INST_DEV_SYSCPU_POSSIBLE		0xd
+#define	LXSYS_INST_DEV_SYSCPU_PRESENT		0xe
+#define	LXSYS_INST_DEVICES_SYSNODE		0xf
+#define	LXSYS_INST_BUSDIR			0x10
 #define	LXSYS_INST_MAX				LXSYS_INST_BUSDIR /* limit */
 
 /*
@@ -208,6 +212,8 @@ static int dyn_ino_type [] = {
 	LXSYS_DEV_ZFS,			/* LXSYS_INST_DEVICES_ZFSDIR */
 	LXSYS_DEV_SYS_CPU,		/* LXSYS_INST_DEVICES_SYSCPU */
 	0,				/* LXSYS_INST_DEV_SYSCPU_KMAX */
+	0,				/* LXSYS_INST_DEV_SYSCPU_POSSIBLE */
+	0,				/* LXSYS_INST_DEV_SYSCPU_PRESENT */
 	LXSYS_DEV_SYS_NODE,		/* LXSYS_INST_DEV_SYSNODE */
 	0,				/* LXSYS_INST_BUSDIR */
 };
@@ -247,7 +253,7 @@ static lxsys_dirent_t dirlist_devices_virtual[] = {
  * becomes unstable due to the incorrect data from glibc.
  */
 static lxsys_dirent_t dirlist_devices_system[] = {
-	/* { LXSYS_INST_DEVICES_SYSCPU,	"cpu" }, */
+	{ LXSYS_INST_DEVICES_SYSCPU,	"cpu" },
 	{ LXSYS_INST_DEVICES_SYSNODE,	"node" }
 };
 
@@ -434,7 +440,19 @@ lxsys_ino_get_type(ino_t ino)
 			}
 			break;
 		case LXSYS_DEV_SYS_CPUINFO:
-			if (instance != 0) {
+			/*
+			 * The /sys/devices/system/cpu directory contains the
+			 * 'kernel_max', 'possible', and 'present' regular
+			 * files, but those are of static type with the proper
+			 * instance.
+			 *
+			 * The /sys/devices/system/cpu directory also contains a
+			 * subdirectory for each CPU. These have an instance
+			 * per CPU and currently the endpoint is 0 since there
+			 * is nothing underneath the cpuN subdirectories. Future
+			 * regular file entries are likely to be added there.
+			 */
+			if (endpoint != 0) {
 				return (VREG);
 			}
 			break;
@@ -884,6 +902,16 @@ lxsys_lookup_devices_syscpu(lxsys_node_t *ldp, char *comp)
 			    LXSYS_INST_DEV_SYSCPU_KMAX);
 			lnp->lxsys_vnode->v_type = VREG;
 			lnp->lxsys_mode = 0444;
+		} else if (strcmp(comp, "possible") == 0) {
+			lnp = lxsys_getnode_static(ldp->lxsys_vnode,
+			    LXSYS_INST_DEV_SYSCPU_POSSIBLE);
+			lnp->lxsys_vnode->v_type = VREG;
+			lnp->lxsys_mode = 0444;
+		} else if (strcmp(comp, "present") == 0) {
+			lnp = lxsys_getnode_static(ldp->lxsys_vnode,
+			    LXSYS_INST_DEV_SYSCPU_PRESENT);
+			lnp->lxsys_vnode->v_type = VREG;
+			lnp->lxsys_mode = 0444;
 		} else {
 			/* Else dynamic cpuN entry */
 			cpu_t *cp, *cpstart;
@@ -1096,11 +1124,44 @@ lxsys_read_static(lxsys_node_t *lnp, lxsys_uiobuf_t *luio)
 {
 	uint_t inst = lnp->lxsys_instance;
 
+	/*
+	 * For 'kernel_max', 'possible', and 'present', see the
+	 * Documentaion/cputopology.txt file in the  Linux src tree.
+	 */
 	if (inst == LXSYS_INST_DEV_SYSCPU_KMAX) {
 		lxsys_uiobuf_printf(luio, "%d\n", NCPU);
 		return (0);
 	}
 
+	if (inst == LXSYS_INST_DEV_SYSCPU_POSSIBLE ||
+	    inst == LXSYS_INST_DEV_SYSCPU_PRESENT) {
+		int pools_enabled, max = 0;
+		cpu_t *cp, *cpstart;
+
+		mutex_enter(&cpu_lock);
+		pools_enabled = pool_pset_enabled();
+
+		cp = cpstart = CPU->cpu_part->cp_cpulist;
+		do {
+			if (cp->cpu_seqid > max)
+				max = cp->cpu_seqid;
+			if (pools_enabled) {
+				cp = cp->cpu_next_part;
+			} else {
+				cp = cp->cpu_next;
+			}
+		} while (cp != cpstart);
+
+		mutex_exit(&cpu_lock);
+
+		if (max > 0) {
+			lxsys_uiobuf_printf(luio, "0-%d\n", max);
+		} else {
+			lxsys_uiobuf_printf(luio, "0\n");
+		}
+		return (0);
+	}
+
 	/* All other static nodes are directories */
 	return (EISDIR);
 }
@@ -1597,6 +1658,33 @@ lxsys_readdir_devices_zfsdir(lxsys_node_t *lnp, uio_t *uiop, int *eofp)
 	return (error);
 }
 
+static int
+lxsys_do_cpu_static(struct uio *uiop, ssize_t oresid, dirent64_t *dirent,
+    char *nm, int inst, int *errp)
+{
+	int reclen;
+	ssize_t uresid;
+
+	(void) strncpy(dirent->d_name, nm, LXSNSIZ);
+
+	dirent->d_ino = lxsys_inode(LXSYS_STATIC, inst, 0);
+	reclen = DIRENT64_RECLEN(strlen(dirent->d_name));
+
+	uresid = uiop->uio_resid;
+	if (reclen > uresid) {
+		if (uresid == oresid) {
+			/* Not enough space for one record */
+			*errp = EINVAL;
+		}
+		return (-1);
+	}
+	if ((*errp = lxsys_dirent_out(dirent, reclen, uiop)) != 0) {
+		return (-1);
+	}
+
+	return (0);
+}
+
 static int
 lxsys_readdir_cpu(lxsys_node_t *ldp, struct uio *uiop, int *eofp)
 {
@@ -1623,23 +1711,17 @@ lxsys_readdir_cpu(lxsys_node_t *ldp, struct uio *uiop, int *eofp)
 	if (skip > 0) {
 		skip--;
 	} else {
-		(void) strncpy(dirent->d_name, "kernel_max", LXSNSIZ);
-
-		dirent->d_ino = lxsys_inode(LXSYS_STATIC,
-		    LXSYS_INST_DEV_SYSCPU_KMAX, 0);
-		reclen = DIRENT64_RECLEN(strlen(dirent->d_name));
+		if (lxsys_do_cpu_static(uiop, oresid, dirent, "kernel_max",
+		    LXSYS_INST_DEV_SYSCPU_KMAX, &error) != 0)
+			goto done;
 
-		uresid = uiop->uio_resid;
-		if (reclen > uresid) {
-			if (uresid == oresid) {
-				/* Not enough space for one record */
-				error = EINVAL;
-			}
+		if (lxsys_do_cpu_static(uiop, oresid, dirent, "possible",
+		    LXSYS_INST_DEV_SYSCPU_POSSIBLE, &error) != 0)
 			goto done;
-		}
-		if ((error = lxsys_dirent_out(dirent, reclen, uiop)) != 0) {
+
+		if (lxsys_do_cpu_static(uiop, oresid, dirent, "present",
+		    LXSYS_INST_DEV_SYSCPU_PRESENT, &error) != 0)
 			goto done;
-		}
 	}
 
 	/* Collect a list of CPU info */
@@ -1674,7 +1756,7 @@ lxsys_readdir_cpu(lxsys_node_t *ldp, struct uio *uiop, int *eofp)
 		    cpu_info[i].cpu_seqid);
 		(void) strncpy(dirent->d_name, cpunm, LXSNSIZ);
 
-		dirent->d_ino = lxsys_inode(LXSYS_DEV_SYS_CPU,
+		dirent->d_ino = lxsys_inode(LXSYS_DEV_SYS_CPUINFO,
 		    cpu_info[i].cpu_id + 1, 0);
 		reclen = DIRENT64_RECLEN(strlen(dirent->d_name));
 
-- 
2.21.0

