From 28f2bface843503eaf0805a12d7c699e9d854bf5 Mon Sep 17 00:00:00 2001
From: David Pacheco <dap@joyent.com>
Date: Fri, 9 Feb 2018 21:49:36 +0000
Subject: [PATCH] joyent/mdb_v8#27 want streaming way to iterate array elements
 joyent/mdb_v8#100 jsprint shows more "hole" values than it should
 joyent/mdb_v8#101 test suite could use common mechanism for standalone tests
 joyent/mdb_v8#104 test suite should take more care to avoid GC during gcore
 Reviewed by: Julien Gilli <julien.gilli@joyent.com> Approved by: Julien Gilli
 <julien.gilli@joyent.com>

---
 .gitignore                                |   2 +
 CHANGES.md                                |   8 +-
 GNUmakefile                               |  23 +-
 docs/usage.md                             | 106 ++++
 package.json                              |  10 +
 src/mdb_v8.c                              | 244 +++++++--
 src/mdb_v8_array.c                        | 152 ++++++
 src/mdb_v8_dbg.h                          |  17 +-
 src/mdb_v8_function.c                     |  21 +-
 src/mdb_v8_impl.h                         |   5 +-
 src/mdb_v8_subr.c                         | 116 ++++-
 test/standalone/common.js                 | 293 ++++++++++-
 test/standalone/gcore_self.js             | 168 +++++++
 test/standalone/tst.arrays.js             | 574 ++++++++++++++++++++++
 test/standalone/tst.jsclosure.js          |  48 +-
 test/standalone/tst.postmortem_basic.js   |  90 +---
 test/standalone/tst.postmortem_details.js |  32 +-
 test/standalone/tst.postmortem_load.js    |  64 ---
 tools/mk/Makefile.node_modules.defs       |  68 +++
 tools/mk/Makefile.node_modules.targ       |  31 ++
 version                                   |   2 +-
 21 files changed, 1825 insertions(+), 249 deletions(-)
 create mode 100644 package.json
 create mode 100644 src/mdb_v8_array.c
 create mode 100644 test/standalone/gcore_self.js
 create mode 100644 test/standalone/tst.arrays.js
 delete mode 100644 test/standalone/tst.postmortem_load.js
 create mode 100644 tools/mk/Makefile.node_modules.defs
 create mode 100644 tools/mk/Makefile.node_modules.targ

diff --git a/.gitignore b/.gitignore
index 42130b4..8811ee4 100644
--- a/.gitignore
+++ b/.gitignore
@@ -1,2 +1,4 @@
 build
+node_modules
+make_stamps
 tools/mdbv8diff/node_modules
diff --git a/CHANGES.md b/CHANGES.md
index 933871c..3f4f470 100644
--- a/CHANGES.md
+++ b/CHANGES.md
@@ -5,7 +5,7 @@
 -->
 
 <!--
-    Copyright (c) 2017, Joyent, Inc.
+    Copyright (c) 2018, Joyent, Inc.
 -->
 
 # mdb_v8 changelog
@@ -14,6 +14,12 @@
 
 None.
 
+## v1.3.0 (2018-01)
+
+* #27 want streaming way to iterate array elements
+* #100 jsprint shows more "hole" values than it should
+* #101 test suite could use common mechanism for standalone tests
+
 ## v1.2.1 (2017-09-20)
 
 * #96 jsclosure crash on invalid context index
diff --git a/GNUmakefile b/GNUmakefile
index 21453d3..96d0d21 100644
--- a/GNUmakefile
+++ b/GNUmakefile
@@ -5,7 +5,7 @@
 #
 
 #
-# Copyright (c) 2015, Joyent, Inc.
+# Copyright (c) 2018, Joyent, Inc.
 #
 
 #
@@ -48,6 +48,7 @@ MDBV8_VERS_TAG	 = "dev"
 #
 MDBV8_SOURCES		 = \
     mdb_v8.c \
+    mdb_v8_array.c \
     mdb_v8_cfg.c \
     mdb_v8_function.c \
     mdb_v8_strbuf.c \
@@ -122,6 +123,18 @@ MAKESO	 	 = $(CC) -o $@ -shared $(SOFLAGS) $(LDFLAGS) $^
 GITDESCRIBE	 = $(shell git describe --all --long --dirty | \
     awk -F'-g' '{print $$NF}')
 
+#
+# Include eng.git Makefile for managing "node_modules" directory.  A number of
+# items that are normally provided by Makefile.defs are specified here directly.
+#
+TOP		  = $(shell pwd)
+NPM		  = npm
+MAKE_STAMPS_DIR	  = make_stamps
+CLEAN_FILES	 += $(MAKE_STAMPS_DIR)
+MAKE_STAMP_REMOVE = mkdir -p $(@D); rm -f $(@)
+MAKE_STAMP_CREATE = mkdir -p $(@D); touch $(@)
+include ./tools/mk/Makefile.node_modules.defs
+
 #
 # TARGETS
 #
@@ -137,7 +150,7 @@ check-cstyle:
 CLEAN_FILES += $(MDBV8_BUILD)
 
 .PHONY: test
-test: $(MDBV8_ALLTARGETS)
+test: $(MDBV8_ALLTARGETS) $(STAMP_NODE_MODULES)
 	$(CATEST) -a
 
 .PHONY: prepush
@@ -172,6 +185,8 @@ $(MDBV8_BUILD):
 	$(MKDIRP)
 
 #
-# Include common Joyent Makefile for JavaScript "check" targets.
+# Include common Joyent Makefile for JavaScript "check" targets and
+# "node_modules" management targets.
 #
-include Makefile.targ
+include ./Makefile.targ
+include ./tools/mk/Makefile.node_modules.targ
diff --git a/docs/usage.md b/docs/usage.md
index 498d811..7b0ddf9 100644
--- a/docs/usage.md
+++ b/docs/usage.md
@@ -617,6 +617,84 @@ Of course, you can use other commands to inspect these values further.
 
 See also: `jsfunction`
 
+### jsarray
+
+    addr::jsarray [-i]
+
+Given an address `addr` of an instance of the JavaScript "Array" class, print
+the contents of the array.  Each element of the array is printed on its own
+line.  With no options, the result can be piped to `::jsprint` to print each
+element.
+
+For example, take this snippet:
+
+    var x = [ 'one', 'two', 'three' ];
+
+With `::jsarray`, this prints three pointers, one for each string:
+
+    > 9d780985::jsarray
+    8bc27629
+    8bc27639
+    8bc27649
+
+We can pipe this to `::jsprint` to see the strings:
+
+    > 9d780985::jsarray | ::jsprint
+    "one"
+    "two"
+    "three"
+
+With "-i", each value is prefixed with its integer index in the array:
+
+    > 9d780985::jsarray -i
+    0 8bc27629
+    1 8bc27639
+    2 8bc27649
+
+Note that JavaScript arrays can contain holes, where there is no element for a
+particular index (not even "undefined").  These appear when an element was
+removed using the `delete` keyword or when an array was initialized with a
+specific length, but not all of the elements were filled in.
+
+When `::jsarray` encounters a hole, the hole is printed out using a special
+value that `::jsprint` shows indicates a hole.  For example, take this snippet:
+
+    var x = new Array(4);
+    x[0] = 'one';
+    x[1] = 'two';
+    x[2] = 'three';
+    delete (x[1]);
+
+This produces an array with two holes: one at index 1 (because it was deleted)
+and one at index 3 (because it was never initialized, but the length was
+initialized to include this index).  If you print this out with `console.log`,
+you'd see:
+
+    [ 'one', , 'three',  ]
+
+(Note the extra commas where there are holes.)
+
+`::jsarray` prints the holes, which may look like ordinary values:
+
+    > 81780a0d::jsarray
+    aba27661
+    b4d080c1
+    aba27681
+    b4d080c1
+
+but are recognized by `::jsprint` as special:
+
+    > 81780a0d::jsarray | ::jsprint
+    "one"
+    hole
+    "three"
+    hole
+
+The default behavior around the printing of hole values may change in the
+future.
+
+See also: `walk jselement`
+
 ### jsconstructor
 
     addr::jsconstructor [-v]
@@ -875,6 +953,34 @@ With "-f", show only frames for function `function`.  With "-p", show only
 With "-a", show all information about hidden frames, the frame pointer for each
 frame, and other native objects for each frame (e.g., JSFunction addresses).
 
+### walk jselement
+
+    addr::walk jselement
+
+Given a JavaScript array identified by `addr`, enumerates the elements of the
+array.  This behaves very similarly to `::jsarray`.  See the notes about holes
+under `::jsarray`.
+
+For example, the array created by this code:
+
+    var x = [ 'one', 'two', 'three' ]
+
+is enumerated in the debugger like this:
+
+    > 9d780985::walk jselement
+    0x8bc27629
+    0x8bc27639
+    0x8bc27649
+
+The results can be piped to `::jsprint` to print the actual values:
+
+    > 9d780985::walk jselement | ::jsprint
+    "one"
+    "two"
+    "three"
+
+See also: `jsarray`.
+
 ### walk jsframe
 
     ::walk jsframe
diff --git a/package.json b/package.json
new file mode 100644
index 0000000..dd2bd6d
--- /dev/null
+++ b/package.json
@@ -0,0 +1,10 @@
+{
+	"name": "mdb_v8_deps",
+	"version": "1.0.0",
+	"description": "package used only to install devDependencies for mdb_v8",
+	"private": true,
+	"devDependencies": {
+		"vasync": "^2.2.0",
+		"verror": "^1.10.0"
+	}
+}
diff --git a/src/mdb_v8.c b/src/mdb_v8.c
index 7a50fcb..a81dfa3 100644
--- a/src/mdb_v8.c
+++ b/src/mdb_v8.c
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2017, Joyent, Inc.
+ * Copyright (c) 2018, Joyent, Inc.
  */
 
 /*
@@ -2744,7 +2744,8 @@ jsobj_properties(uintptr_t addr,
 	 * of instance descriptors.
 	 */
 	for (ii = 0; ii < rndescs; ii++) {
-		intptr_t keyidx, validx, detidx, baseidx, propaddr, propidx;
+		intptr_t keyidx, validx, detidx, baseidx, propaddr;
+		intptr_t propidx, proparrayidx = -1;
 		char buf[1024];
 		intptr_t val;
 		size_t len = sizeof (buf);
@@ -2783,8 +2784,9 @@ jsobj_properties(uintptr_t addr,
 		 * (notably: transitions) that we don't care about (and these
 		 * are not errors).
 		 */
-		if (!V8_DESC_ISFIELD(content[detidx]))
+		if (!V8_DESC_ISFIELD(content[detidx])) {
 			continue;
+		}
 
 		if (keyidx >= ndescs) {
 			propinfo |= JPI_SKIPPED;
@@ -2840,6 +2842,14 @@ jsobj_properties(uintptr_t addr,
 				/* The property is stored inside the object. */
 				propaddr = addr + V8_OFF_HEAP(
 				    size - (ninprops - propidx) * ps);
+			} else {
+				/*
+				 * The property is stored in the "properties"
+				 * array.  This will be handled below.  The
+				 * index needs to be offset by the number of
+				 * in-object properties.
+				 */
+				proparrayidx = propidx - ninprops;
 			}
 		} else {
 			/*
@@ -2870,6 +2880,8 @@ jsobj_properties(uintptr_t addr,
 				 */
 				propaddr = addr +
 				    V8_OFF_HEAP(size + propidx * ps);
+			} else {
+				proparrayidx = propidx;
 			}
 		}
 
@@ -2887,9 +2899,9 @@ jsobj_properties(uintptr_t addr,
 			}
 
 			propinfo |= JPI_INOBJECT;
-		} else if (propidx >= 0 && propidx < nprops) {
+		} else if (proparrayidx >= 0 && proparrayidx < nprops) {
 			/* Valid "properties" array property found. */
-			ptr = props[propidx];
+			ptr = props[proparrayidx];
 			propinfo |= JPI_PROPS;
 		} else {
 			/*
@@ -3726,6 +3738,29 @@ jsobj_print_jsarray_member(uintptr_t addr, jsobj_print_t *jsop)
 	return (rv);
 }
 
+static int
+jsobj_print_jsarray_one(v8array_t *ap, unsigned int index,
+    uintptr_t value, void *uarg)
+{
+	jsobj_print_t *jsop = uarg;
+	char **bufp = jsop->jsop_bufp;
+	size_t *lenp = jsop->jsop_lenp;
+
+	if (v8array_length(ap) == 1) {
+		(void) jsobj_print(value, jsop);
+	} else {
+		if (*lenp <= 0) {
+			return (-1);
+		}
+
+		(void) bsnprintf(bufp, lenp, "%*s", jsop->jsop_indent, "");
+		(void) jsobj_print(value, jsop);
+		(void) bsnprintf(bufp, lenp, ",\n");
+	}
+
+	return (0);
+}
+
 static int
 jsobj_print_jsarray(uintptr_t addr, jsobj_print_t *jsop)
 {
@@ -3733,9 +3768,8 @@ jsobj_print_jsarray(uintptr_t addr, jsobj_print_t *jsop)
 	size_t *lenp = jsop->jsop_lenp;
 	int indent = jsop->jsop_indent;
 	jsobj_print_t descend;
-	uintptr_t ptr;
-	uintptr_t *elts;
-	size_t ii, len;
+	size_t len;
+	v8array_t *ap;
 
 	if (jsop->jsop_member != NULL)
 		return (jsobj_print_jsarray_member(addr, jsop));
@@ -3745,18 +3779,14 @@ jsobj_print_jsarray(uintptr_t addr, jsobj_print_t *jsop)
 		return (0);
 	}
 
-	if (read_heap_ptr(&ptr, addr, V8_OFF_JSOBJECT_ELEMENTS) != 0) {
-		(void) bsnprintf(bufp, lenp,
-		    "<array (failed to read elements)>");
-		return (-1);
-	}
-
-	if (read_heap_array(ptr, &elts, &len, UM_SLEEP | UM_GC) != 0) {
-		(void) bsnprintf(bufp, lenp, "<array (failed to read array)>");
+	ap = v8array_load(addr, UM_NOSLEEP);
+	if (ap == NULL) {
 		return (-1);
 	}
 
+	len = v8array_length(ap);
 	if (len == 0) {
+		v8array_free(ap);
 		(void) bsnprintf(bufp, lenp, "[]");
 		return (0);
 	}
@@ -3767,22 +3797,18 @@ jsobj_print_jsarray(uintptr_t addr, jsobj_print_t *jsop)
 
 	if (len == 1) {
 		(void) bsnprintf(bufp, lenp, "[ ");
-		(void) jsobj_print(elts[0], &descend);
+		(void) v8array_iter_elements(ap, jsobj_print_jsarray_one,
+		    &descend);
 		(void) bsnprintf(bufp, lenp, " ]");
+		v8array_free(ap);
 		return (0);
 	}
 
 	(void) bsnprintf(bufp, lenp, "[\n");
-
-	for (ii = 0; ii < len && *lenp > 0; ii++) {
-		(void) bsnprintf(bufp, lenp, "%*s", indent + 4, "");
-		(void) jsobj_print(elts[ii], &descend);
-		(void) bsnprintf(bufp, lenp, ",\n");
-	}
-
+	(void) v8array_iter_elements(ap, jsobj_print_jsarray_one, &descend);
 	(void) bsnprintf(bufp, lenp, "%*s", indent, "");
 	(void) bsnprintf(bufp, lenp, "]");
-
+	v8array_free(ap);
 	return (0);
 }
 
@@ -5959,6 +5985,44 @@ out:
 	return (rv);
 }
 
+static int
+jsarray_print_one(v8array_t *ap, unsigned int index, uintptr_t value,
+    void *uarg)
+{
+	boolean_t *opt_i = uarg;
+
+	if (*opt_i) {
+		mdb_printf("%d ", index);
+	}
+
+	mdb_printf("%p\n", value);
+	return (0);
+}
+
+/* ARGSUSED */
+static int
+dcmd_jsarray(uintptr_t addr, uint_t flags, int argc, const mdb_arg_t *argv)
+{
+	v8array_t *ap;
+	int memflags = UM_SLEEP | UM_GC;
+	boolean_t opt_i = B_FALSE;
+	int rv;
+
+	if (mdb_getopts(argc, argv, 'i', MDB_OPT_SETBITS, B_TRUE, &opt_i,
+	    NULL) != argc) {
+		return (DCMD_USAGE);
+	}
+
+	if ((ap = v8array_load(addr, memflags)) == NULL) {
+		mdb_warn("%p: failed to load JSArray\n", addr);
+		return (DCMD_ERR);
+	}
+
+	rv = v8array_iter_elements(ap, jsarray_print_one, &opt_i);
+	v8array_free(ap);
+	return (rv == 0 ? DCMD_OK : DCMD_ERR);
+}
+
 /* ARGSUSED */
 static int
 dcmd_jsclosure(uintptr_t addr, uint_t flags, int argc, const mdb_arg_t *argv)
@@ -6494,26 +6558,59 @@ dcmd_v8field(uintptr_t addr, uint_t flags, int argc, const mdb_arg_t *argv)
 	return (DCMD_OK);
 }
 
+/* ARGSUSED */
+static int
+v8array_print_one(v8fixedarray_t *arrayp, unsigned int i,
+    uintptr_t value, void *unused)
+{
+	mdb_printf("%p\n", value);
+	return (0);
+}
+
 /* ARGSUSED */
 static int
 dcmd_v8array(uintptr_t addr, uint_t flags, int argc, const mdb_arg_t *argv)
 {
 	v8fixedarray_t *arrayp;
-	uintptr_t *elts;
-	size_t i, len;
+	boolean_t immediate = B_FALSE;
+	int rv;
+
+	/*
+	 * The "immediate" option causes us to load the entire array into
+	 * memory.  This is likely only useful for testing.
+	 */
+	if (mdb_getopts(argc, argv,
+	    'i', MDB_OPT_SETBITS, B_TRUE, &immediate, NULL) != argc) {
+		return (DCMD_USAGE);
+	}
 
 	if ((arrayp = v8fixedarray_load(addr, UM_SLEEP | UM_GC)) == NULL) {
 		return (DCMD_ERR);
 	}
 
-	elts = v8fixedarray_elts(arrayp);
-	len = v8fixedarray_length(arrayp);
+	if (!immediate) {
+		rv = v8fixedarray_iter_elements(
+		    arrayp, v8array_print_one, NULL);
+	} else {
+		unsigned int i, len;
+		uintptr_t *immed;
 
-	for (i = 0; i < len; i++)
-		mdb_printf("%p\n", elts[i]);
+		len = v8fixedarray_length(arrayp);
+		immed = v8fixedarray_as_array(arrayp, UM_SLEEP | UM_GC);
+		if (immed == 0) {
+			rv = -1;
+		} else {
+			rv = 0;
+			for (i = 0; i < len; i++) {
+				mdb_printf("%p\n", immed[i]);
+			}
+			maybefree(immed, len * sizeof (immed[0]),
+			    UM_SLEEP | UM_GC);
+		}
+	}
 
 	v8fixedarray_free(arrayp);
-	return (DCMD_OK);
+	return (rv == 0 ? DCMD_OK : DCMD_ERR);
 }
 
 /* ARGSUSED */
@@ -6666,6 +6763,83 @@ dcmd_v8warnings(uintptr_t addr, uint_t flags, int argc, const mdb_arg_t *argv)
 	return (DCMD_OK);
 }
 
+typedef struct jselement_walk_data {
+	mdb_walk_state_t *jsew_wsp;
+	int		 jsew_memflags;
+	int		 jsew_last;
+	v8array_t	 *jsew_array;
+} jselement_walk_data_t;
+
+static int
+walk_jselement_init(mdb_walk_state_t *wsp)
+{
+	uintptr_t addr;
+	int memflags = UM_GC | UM_SLEEP;
+	jselement_walk_data_t *jsew;
+
+	if ((addr = wsp->walk_addr) == NULL) {
+		mdb_warn("'jselement' does not support global walks\n");
+		return (WALK_ERR);
+	}
+
+	jsew = mdb_zalloc(sizeof (*jsew), memflags);
+	assert(jsew != NULL); /* using UM_SLEEP */
+	jsew->jsew_wsp = wsp;
+	jsew->jsew_memflags = memflags;
+	jsew->jsew_last = WALK_DONE;
+	jsew->jsew_array = v8array_load(addr, memflags);
+
+	if (jsew->jsew_array == NULL) {
+		maybefree(jsew, sizeof (*jsew), memflags);
+		return (WALK_ERR);
+	}
+
+	wsp->walk_data = jsew;
+	return (WALK_NEXT);
+}
+
+/* ARGSUSED */
+static int
+walk_jsarray_iter_one(v8array_t *ap, unsigned int index, uintptr_t value,
+    void *uarg)
+{
+	jselement_walk_data_t *jsew = uarg;
+	mdb_walk_state_t *wsp = jsew->jsew_wsp;
+
+	jsew->jsew_last = wsp->walk_callback(value, NULL, wsp->walk_cbdata);
+	return (jsew->jsew_last == WALK_NEXT ? 0 : -1);
+}
+
+static int
+walk_jselement_step(mdb_walk_state_t *wsp)
+{
+	jselement_walk_data_t *jsew;
+	v8array_t *ap;
+	int rv;
+
+	jsew = wsp->walk_data;
+	assert(jsew->jsew_wsp == wsp);
+	ap = jsew->jsew_array;
+	rv = v8array_iter_elements(ap, walk_jsarray_iter_one, jsew);
+	return (rv == 0 ? WALK_DONE : jsew->jsew_last);
+}
+
+static void
+walk_jselement_fini(mdb_walk_state_t *wsp)
+{
+	jselement_walk_data_t *jsew;
+	v8array_t *ap;
+
+	assert(wsp->walk_data != NULL);
+	jsew = wsp->walk_data;
+	assert(jsew->jsew_wsp == wsp);
+	wsp->walk_data = NULL;
+
+	ap = jsew->jsew_array;
+	v8array_free(ap);
+	maybefree(jsew, sizeof (*jsew), jsew->jsew_memflags);
+}
+
 static int
 walk_jsframes_init(mdb_walk_state_t *wsp)
 {
@@ -6808,6 +6982,8 @@ static const mdb_dcmd_t v8_mdb_dcmds[] = {
 	/*
 	 * Commands to inspect JavaScript-level state
 	 */
+	{ "jsarray", ":[-i]", "print elements of a JavaScript array",
+		dcmd_jsarray },
 	{ "jsclosure", ":", "print variables referenced by a closure",
 		dcmd_jsclosure },
 	{ "jsconstructor", ":[-v]",
@@ -6833,7 +7009,7 @@ static const mdb_dcmd_t v8_mdb_dcmds[] = {
 	/*
 	 * Commands to inspect V8-level state
 	 */
-	{ "v8array", ":", "print elements of a V8 FixedArray",
+	{ "v8array", ":[-i]", "print elements of a V8 FixedArray",
 		dcmd_v8array },
 	{ "v8classes", NULL, "list known V8 heap object C++ classes",
 		dcmd_v8classes },
@@ -6868,6 +7044,8 @@ static const mdb_dcmd_t v8_mdb_dcmds[] = {
 };
 
 static const mdb_walker_t v8_mdb_walkers[] = {
+	{ "jselement", "walk elements of a JavaScript array",
+		walk_jselement_init, walk_jselement_step, walk_jselement_fini },
 	{ "jsframe", "walk V8 JavaScript stack frames",
 		walk_jsframes_init, walk_jsframes_step },
 	{ "jsprop", "walk property values for an object",
diff --git a/src/mdb_v8_array.c b/src/mdb_v8_array.c
new file mode 100644
index 0000000..ccd0913
--- /dev/null
+++ b/src/mdb_v8_array.c
@@ -0,0 +1,152 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2018, Joyent, Inc.
+ */
+
+/*
+ * mdb_v8_array.c: implementations of functions used for working with
+ * JavaScript arrays.  These are not to be confused with V8's internal
+ * FixedArray (upon which JavaScript arrays are built).
+ */
+
+#include <assert.h>
+
+#include "v8dbg.h"
+#include "mdb_v8_dbg.h"
+#include "mdb_v8_impl.h"
+
+/*
+ * See mdb_v8_dbg.h for details on what these various structures represent.
+ */
+struct v8array {
+	uintptr_t	v8array_addr;		/* address in target proc */
+	int		v8array_memflags;	/* allocation flags */
+	v8fixedarray_t	*v8array_elements;	/* elements array */
+	size_t		v8array_length;		/* length */
+};
+
+/*
+ * Private structure used for managing iteration over the array.
+ */
+typedef struct {
+	v8array_t	*v8ai_array;
+	int		(*v8ai_func)(v8array_t *,
+	    unsigned int, uintptr_t, void *);
+	void		*v8ai_uarg;
+	int		v8ai_rv;
+} v8array_iteration_t;
+
+
+/*
+ * Load a JSArray object.
+ * See the patterns in mdb_v8_dbg.h for interface details.
+ */
+v8array_t *
+v8array_load(uintptr_t addr, int memflags)
+{
+	uint8_t type;
+	uintptr_t length, elements;
+	v8array_t *ap;
+
+	if (!V8_IS_HEAPOBJECT(addr) || read_typebyte(&type, addr) != 0) {
+		v8_warn("%p: not a heap object\n", addr);
+		return (NULL);
+	}
+
+	if (type != V8_TYPE_JSARRAY) {
+		v8_warn("%p: not a JSArray\n", addr);
+		return (NULL);
+	}
+
+	if (read_heap_smi(&length, addr, V8_OFF_JSARRAY_LENGTH) != 0) {
+		v8_warn("%p: could not read JSArray length\n", addr);
+		return (NULL);
+	}
+
+	if (read_heap_ptr(&elements, addr, V8_OFF_JSOBJECT_ELEMENTS) != 0) {
+		v8_warn("%p: could not read JSArray elements\n", addr);
+		return (NULL);
+	}
+
+	if ((ap = mdb_zalloc(sizeof (*ap), memflags)) == NULL) {
+		return (NULL);
+	}
+
+	ap->v8array_addr = addr;
+	ap->v8array_length = length;
+	ap->v8array_memflags = memflags;
+
+	if (ap->v8array_length > 0) {
+		ap->v8array_elements = v8fixedarray_load(elements, memflags);
+		if (ap->v8array_elements == NULL) {
+			v8array_free(ap);
+			return (NULL);
+		}
+	}
+
+	return (ap);
+}
+
+/*
+ * See the patterns in mdb_v8_dbg.h for interface details.
+ */
+void
+v8array_free(v8array_t *ap)
+{
+	if (ap == NULL) {
+		return;
+	}
+
+	v8fixedarray_free(ap->v8array_elements);
+	maybefree(ap, sizeof (*ap), ap->v8array_memflags);
+}
+
+size_t
+v8array_length(v8array_t *ap)
+{
+	return (ap->v8array_length);
+}
+
+static int
+v8array_iter_one(v8fixedarray_t *arrayp, unsigned int index,
+    uintptr_t value, void *uarg)
+{
+	v8array_iteration_t *iterate_statep = uarg;
+
+	/*
+	 * The JSArray may have fewer elements than the underlying FixedArray
+	 * that's used to store its contents.  In that case, stop early.
+	 */
+	if (index >= iterate_statep->v8ai_array->v8array_length) {
+		return (-1);
+	}
+
+	iterate_statep->v8ai_rv = (iterate_statep->v8ai_func(
+	    iterate_statep->v8ai_array, index, value,
+	    iterate_statep->v8ai_uarg));
+	return (iterate_statep->v8ai_rv == 0 ? 0 : -1);
+}
+
+int
+v8array_iter_elements(v8array_t *ap,
+    int (*func)(v8array_t *, unsigned int, uintptr_t, void *), void *uarg)
+{
+	v8array_iteration_t iterate_state;
+
+	if (v8array_length(ap) == 0) {
+		return (0);
+	}
+
+	iterate_state.v8ai_array = ap;
+	iterate_state.v8ai_uarg = uarg;
+	iterate_state.v8ai_func = func;
+	iterate_state.v8ai_rv = 0;
+	(void) v8fixedarray_iter_elements(ap->v8array_elements,
+	    v8array_iter_one, &iterate_state);
+	return (iterate_state.v8ai_rv);
+}
diff --git a/src/mdb_v8_dbg.h b/src/mdb_v8_dbg.h
index dfae781..dbedbaa 100644
--- a/src/mdb_v8_dbg.h
+++ b/src/mdb_v8_dbg.h
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2017, Joyent, Inc.
+ * Copyright (c) 2018, Joyent, Inc.
  */
 
 /*
@@ -98,6 +98,7 @@ typedef struct {
 typedef struct v8fixedarray v8fixedarray_t;
 typedef struct v8string v8string_t;
 
+typedef struct v8array v8array_t;
 typedef struct v8function v8function_t;
 typedef struct v8boundfunction v8boundfunction_t;
 typedef struct v8code v8code_t;
@@ -155,6 +156,16 @@ const char *mdbv8_strbuf_tocstr(mdbv8_strbuf_t *);
 size_t mdbv8_strbuf_nbytesforchar(uint16_t, mdbv8_strappend_flags_t);
 
 
+/*
+ * Working with JavaScript arrays.
+ */
+v8array_t *v8array_load(uintptr_t, int);
+void v8array_free(v8array_t *);
+size_t v8array_length(v8array_t *);
+int v8array_iter_elements(v8array_t *,
+    int (*)(v8array_t *, unsigned int, uintptr_t, void *), void *);
+
+
 /*
  * Working with V8 FixedArrays.  These are plain arrays used within V8 for a
  * variety of higher-level structures.  Most of these structures apply their own
@@ -165,7 +176,9 @@ size_t mdbv8_strbuf_nbytesforchar(uint16_t, mdbv8_strappend_flags_t);
 v8fixedarray_t *v8fixedarray_load(uintptr_t, int);
 void v8fixedarray_free(v8fixedarray_t *);
 
-uintptr_t *v8fixedarray_elts(v8fixedarray_t *);
+int v8fixedarray_iter_elements(v8fixedarray_t *,
+    int (*)(v8fixedarray_t *, unsigned int, uintptr_t, void *), void *);
+uintptr_t *v8fixedarray_as_array(v8fixedarray_t *, int);
 size_t v8fixedarray_length(v8fixedarray_t *);
 
 
diff --git a/src/mdb_v8_function.c b/src/mdb_v8_function.c
index 05276a8..7d11284 100644
--- a/src/mdb_v8_function.c
+++ b/src/mdb_v8_function.c
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2017, Joyent, Inc.
+ * Copyright (c) 2018, Joyent, Inc.
  */
 
 /*
@@ -435,6 +435,7 @@ v8funcinfo_definition_location(v8funcinfo_t *fip, mdbv8_strbuf_t *strb,
 	uintptr_t tokpos, lower, upper, i;
 	uintptr_t *data;
 	v8fixedarray_t *arrayp;
+	int memflags;
 
 	/*
 	 * The "function" token position is an SMI, and has already been decoded
@@ -467,12 +468,24 @@ v8funcinfo_definition_location(v8funcinfo_t *fip, mdbv8_strbuf_t *strb,
 		return (0);
 	}
 
-	arrayp = v8fixedarray_load(fip->v8fi_line_endings, UM_NOSLEEP);
+	memflags = UM_NOSLEEP;
+	arrayp = v8fixedarray_load(fip->v8fi_line_endings, memflags);
 	if (arrayp == NULL) {
 		return (-1);
 	}
 
-	data = v8fixedarray_elts(arrayp);
+	if (v8fixedarray_length(arrayp) == 0) {
+		mdbv8_strbuf_sprintf(strb, "position out of range");
+		v8fixedarray_free(arrayp);
+		return (0);
+	}
+
+	data = v8fixedarray_as_array(arrayp, memflags);
+	if (data == NULL) {
+		v8fixedarray_free(arrayp);
+		return (-1);
+	}
+
 	lower = 0;
 	upper = v8fixedarray_length(arrayp) - 1;
 	if (tokpos > data[upper]) {
@@ -494,6 +507,8 @@ v8funcinfo_definition_location(v8funcinfo_t *fip, mdbv8_strbuf_t *strb,
 		mdbv8_strbuf_sprintf(strb, "line %d", i + 1);
 	}
 
+	maybefree(data, sizeof (data[0]) * v8fixedarray_length(arrayp),
+	    memflags);
 	v8fixedarray_free(arrayp);
 	return (0);
 }
diff --git a/src/mdb_v8_impl.h b/src/mdb_v8_impl.h
index b52bca9..ddb9de9 100644
--- a/src/mdb_v8_impl.h
+++ b/src/mdb_v8_impl.h
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2017, Joyent, Inc.
+ * Copyright (c) 2018, Joyent, Inc.
  */
 
 /*
@@ -51,6 +51,7 @@ boolean_t jsobj_is_undefined(uintptr_t);
  * We need to find a better way of exposing this information.  For now, these
  * represent all the metadata constants used by multiple C files.
  */
+extern intptr_t V8_TYPE_JSARRAY;
 extern intptr_t V8_TYPE_JSFUNCTION;
 extern intptr_t V8_TYPE_JSBOUNDFUNCTION;
 extern intptr_t V8_TYPE_FIXEDARRAY;
@@ -76,12 +77,14 @@ extern ssize_t V8_OFF_CONSSTRING_SECOND;
 extern ssize_t V8_OFF_EXTERNALSTRING_RESOURCE;
 extern ssize_t V8_OFF_FIXEDARRAY_DATA;
 extern ssize_t V8_OFF_FIXEDARRAY_LENGTH;
+extern ssize_t V8_OFF_JSARRAY_LENGTH;
 extern ssize_t V8_OFF_JSBOUNDFUNCTION_BOUND_ARGUMENTS;
 extern ssize_t V8_OFF_JSBOUNDFUNCTION_BOUND_TARGET_FUNCTION;
 extern ssize_t V8_OFF_JSBOUNDFUNCTION_BOUND_THIS;
 extern ssize_t V8_OFF_JSFUNCTION_CONTEXT;
 extern ssize_t V8_OFF_JSFUNCTION_LITERALS_OR_BINDINGS;
 extern ssize_t V8_OFF_JSFUNCTION_SHARED;
+extern ssize_t V8_OFF_JSOBJECT_ELEMENTS;
 extern ssize_t V8_OFF_SCRIPT_LINE_ENDS;
 extern ssize_t V8_OFF_SCRIPT_NAME;
 extern ssize_t V8_OFF_SEQASCIISTR_CHARS;
diff --git a/src/mdb_v8_subr.c b/src/mdb_v8_subr.c
index 721a985..d55e490 100644
--- a/src/mdb_v8_subr.c
+++ b/src/mdb_v8_subr.c
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2015, Joyent, Inc.
+ * Copyright (c) 2018, Joyent, Inc.
  */
 
 /*
@@ -13,6 +13,7 @@
  */
 
 #include <assert.h>
+#include <alloca.h>
 
 #include "v8dbg.h"
 #include "mdb_v8_dbg.h"
@@ -22,7 +23,7 @@ struct v8fixedarray {
 	uintptr_t	v8fa_addr;
 	int		v8fa_memflags;
 	unsigned long	v8fa_nelts;
-	uintptr_t	*v8fa_elts;
+	uintptr_t	v8fa_elements;
 };
 
 /*
@@ -34,8 +35,6 @@ v8fixedarray_load(uintptr_t addr, int memflags)
 {
 	uint8_t type;
 	uintptr_t nelts;
-	uintptr_t *elts;
-	size_t arraysz;
 	v8fixedarray_t *arrayp;
 
 	if (!V8_IS_HEAPOBJECT(addr) ||
@@ -48,23 +47,6 @@ v8fixedarray_load(uintptr_t addr, int memflags)
 	arrayp->v8fa_addr = addr;
 	arrayp->v8fa_memflags = memflags;
 	arrayp->v8fa_nelts = nelts;
-
-	if (arrayp->v8fa_nelts > 0) {
-		arraysz = nelts * sizeof (elts[0]);
-		elts = mdb_zalloc(arraysz, memflags);
-		if (elts == NULL) {
-			v8fixedarray_free(arrayp);
-			return (NULL);
-		}
-
-		arrayp->v8fa_elts = elts;
-		if (mdb_vread(elts, arraysz,
-		    addr + V8_OFF_FIXEDARRAY_DATA) == -1) {
-			v8fixedarray_free(arrayp);
-			return (NULL);
-		}
-	}
-
 	return (arrayp);
 }
 
@@ -79,20 +61,100 @@ v8fixedarray_free(v8fixedarray_t *arrayp)
 		return;
 	}
 
-	maybefree(arrayp->v8fa_elts,
-	    arrayp->v8fa_nelts * sizeof (arrayp->v8fa_elts[0]),
-	    arrayp->v8fa_memflags);
 	maybefree(arrayp, sizeof (*arrayp), arrayp->v8fa_memflags);
 }
 
+/*
+ * Iterate the elements of this fixed array.
+ *
+ * This implementation is careful to avoid needing memory proportional to the
+ * array size, as that makes it very difficult for end users to work with very
+ * large arrays.
+ */
+int
+v8fixedarray_iter_elements(v8fixedarray_t *arrayp,
+    int (*func)(v8fixedarray_t *, unsigned int, uintptr_t, void *),
+    void *uarg)
+{
+	int maxnpgelts = 1024;
+	int curnpgelts;
+	uintptr_t *buf;
+	uintptr_t addr;
+	unsigned int index, length, i;
+	size_t maxpgsz, curpgsz;
+	int rv = -1;
+
+	length = v8fixedarray_length(arrayp);
+	if (length == 0) {
+		return (0);
+	}
+
+	maxpgsz = maxnpgelts * sizeof (buf[0]);
+	buf = alloca(maxpgsz);
+
+	addr = arrayp->v8fa_addr + V8_OFF_FIXEDARRAY_DATA;
+	index = 0;
+
+	do {
+		curnpgelts = MIN(length - index, maxnpgelts);
+		curpgsz = curnpgelts * sizeof (buf[0]);
+		rv = mdb_vread(buf, curpgsz, addr);
+		if (rv == -1) {
+			v8_warn("failed to read array from index %d", index);
+			break;
+		}
+
+		for (i = 0; i < curnpgelts; i++) {
+			rv = func(arrayp, index + i, buf[i], uarg);
+			if (rv != 0) {
+				break;
+			}
+		}
+
+		index += i;
+		addr += curpgsz;
+	} while (rv == 0 && index < length - 1);
+
+	return (rv);
+}
+
 /*
  * Return a native array representing the contents of the FixedArray "arrayp".
- * The length of the array is given by v8fixedarray_length().
+ * NOTE: If possible, v8fixedarray_iter_elements() should be used instead of
+ * this function.  That function requires only a constant amount of memory
+ * regardless of the array size.  That can be a major performance improvement
+ * when available memory is limited, and it makes it possible to work with
+ * arbitrarily large arrays for which we can't necessarily allocate such a large
+ * block.
+ *
+ * The length of the returned array is given by v8fixedarray_length().  The
+ * caller must free this with "maybefree" using the same "memflags".
+ * TODO This should probably either be a separate type, or maybe we should hang
+ * it off the v8fixedarray_t (and keep it cached).
  */
 uintptr_t *
-v8fixedarray_elts(v8fixedarray_t *arrayp)
+v8fixedarray_as_array(v8fixedarray_t *arrayp, int memflags)
 {
-	return (arrayp->v8fa_elts);
+	uintptr_t *elts;
+	size_t arraysz;
+
+	if (arrayp->v8fa_nelts == 0) {
+		return (NULL);
+	}
+
+	arraysz = arrayp->v8fa_nelts * sizeof (elts[0]);
+	elts = mdb_zalloc(arraysz, memflags);
+	if (elts == NULL) {
+		return (NULL);
+	}
+
+	if (mdb_vread(elts, arraysz,
+	    arrayp->v8fa_addr + V8_OFF_FIXEDARRAY_DATA) == -1) {
+		maybefree(elts, arraysz, memflags);
+		return (NULL);
+	}
+
+	return (elts);
 }
 
 /*
diff --git a/test/standalone/common.js b/test/standalone/common.js
index 16cd9d6..c3fd776 100644
--- a/test/standalone/common.js
+++ b/test/standalone/common.js
@@ -5,17 +5,30 @@
  */
 
 /*
- * Copyright (c) 2015, Joyent, Inc.
+ * Copyright (c) 2018, Joyent, Inc.
  */
 
 /*
  * test/standalone/common.js: common functions for standalone JavaScript tests
  */
 
-var mod_path = require('path');
+var assert = require('assert');
+var childprocess = require('child_process');
+var events = require('events');
+var fs = require('fs');
+var path = require('path');
+var util = require('util');
+var vasync = require('vasync');
+var VError = require('verror');
+
+var gcoreSelf = require('./gcore_self');
 
 /* Public interface */
 exports.dmodpath = dmodpath;
+exports.createMdbSession = createMdbSession;
+exports.standaloneTest = standaloneTest;
+
+var MDB_SENTINEL = 'MDB_SENTINEL\n';
 
 /*
  * Returns the path to the built dmod, for loading into mdb during testing.
@@ -23,6 +36,280 @@ exports.dmodpath = dmodpath;
 function dmodpath()
 {
 	var arch = process.arch == 'x64' ? 'amd64' : 'ia32';
-	return (mod_path.join(
+	return (path.join(
 	    __dirname, '..', '..', 'build', arch, 'mdb_v8.so'));
 }
+
+function MdbSession()
+{
+	this.mdb_child = null;	/* child process handle */
+	this.mdb_target_name = null;	/* file name or pid */
+	this.mdb_args = [];	/* extra CLI arguments */
+	this.mdb_target_type = null;	/* "file" or "pid" */
+	this.mdb_remove_on_success = false;
+
+	/* information about current pending command */
+	this.mdb_pending_cmd = null;
+	this.mdb_pending_callback = null;
+
+	/* runtime state */
+	this.mdb_exited = false;
+	this.mdb_error = null;
+	this.mdb_output = '';	/* buffered output */
+	this.mdb_findleaks = null;
+}
+
+util.inherits(MdbSession, events.EventEmitter);
+
+MdbSession.prototype.runCmd = function (str, callback)
+{
+	assert.equal(typeof (str), 'string');
+	assert.equal(typeof (callback), 'function');
+	assert.strictEqual(this.mdb_pending_cmd, null,
+	    'command is already pending');
+	assert.strictEqual(this.mdb_error, null,
+	    'already experienced fatal error');
+	assert.strictEqual(this.mdb_exited, false,
+	    'mdb already exited');
+	assert.equal(str.charAt(str.length - 1), '\n',
+	    'command string must end in a newline');
+
+	assert.strictEqual(this.mdb_pending_callback, null);
+	this.mdb_pending_cmd = str;
+	this.mdb_pending_callback = callback;
+	process.stderr.write('> ' + str);
+	this.mdb_child.stdin.write(str);
+	this.mdb_child.stdin.write('!echo ' + MDB_SENTINEL);
+};
+
+MdbSession.prototype.onExit = function (code)
+{
+	this.mdb_exited = true;
+	if (code !== 0) {
+		this.mdb_error = new Error(
+		    'mdb exited unexpectedly with code ' + code);
+		this.emit('error', this.mdb_error);
+	}
+};
+
+MdbSession.prototype.doWork = function ()
+{
+	var i, chunk, callback;
+
+	i = this.mdb_output.indexOf(MDB_SENTINEL);
+	assert.ok(i >= 0);
+	chunk = this.mdb_output.substr(0, i);
+	this.mdb_output = this.mdb_output.substr(i + MDB_SENTINEL.length);
+	console.error(chunk);
+
+	assert.notStrictEqual(this.mdb_pending_cmd, null);
+	assert.notStrictEqual(this.mdb_pending_callback, null);
+	callback = this.mdb_pending_callback;
+	this.mdb_pending_callback = null;
+	this.mdb_pending_cmd = null;
+	callback(chunk);
+};
+
+MdbSession.prototype.finish = function (error)
+{
+	assert.strictEqual(this.mdb_error, null,
+	    'already experienced fatal error');
+	process.removeListener('exit', this.mdb_onprocexit);
+
+	if (!this.mdb_exited) {
+		this.mdb_child.stdin.end();
+	}
+
+	if (error) {
+		this.mdb_error = new VError(error, 'error running test');
+		return;
+	}
+
+	if (this.mdb_remove_on_success && this.mdb_target_type == 'file') {
+		fs.unlinkSync(this.mdb_target_name);
+	}
+};
+
+MdbSession.prototype.checkMdbLeaks = function (callback)
+{
+	var self = this;
+	var leakmdb;
+
+	/*
+	 * Attach another MDB session to MDB itself so that we can run
+	 * "findleaks" to look for leaks in "mdb" and "mdb_v8".  At this point,
+	 * we only print this information out, rather than trying to parse it
+	 * and take action.  We also rely on the underlying MdbSession's
+	 * transcript rather than explicitly printing out the output.
+	 */
+	assert.strictEqual(this.mdb_findleaks, null,
+	    'mdb leak check already pending');
+	leakmdb = this.mdb_findleaks = createMdbSession({
+	    'targetType': 'pid',
+	    'targetName': this.mdb_child.pid.toString(),
+	    'loadDmod': false,
+	    'removeOnSuccess': false
+	}, function (err) {
+		assert.equal(self.mdb_findleaks, leakmdb);
+
+		if (err) {
+			self.mdb_findleaks = null;
+			callback(new VError(err, 'attaching mdb to itself'));
+			return;
+		}
+
+		leakmdb.runCmd('::findleaks -d\n', function () {
+			assert.equal(self.mdb_findleaks, leakmdb);
+			self.mdb_findleaks = null;
+			leakmdb.finish();
+			callback();
+		});
+	});
+};
+
+/*
+ * Opens an MDB session.  Use runCmd() to invoke a command and get output.
+ */
+function createMdbSessionFile(filename, callback)
+{
+	return (createMdbSession({
+	    'targetType': 'file',
+	    'targetName': filename,
+	    'loadDmod': true,
+	    'removeOnSuccess': true
+	}, callback));
+}
+
+function createMdbSession(args, callback)
+{
+	var mdb, loaddmod;
+	var loaded = false;
+
+	assert.equal('object', typeof (args));
+	assert.equal('string', typeof (args.targetType));
+	assert.equal('string', typeof (args.targetName));
+	assert.equal('boolean', typeof (args.removeOnSuccess));
+	assert.equal('boolean', typeof (args.loadDmod));
+
+	assert.ok(args.targetType == 'file' || args.targetType == 'pid');
+	loaddmod = args.loadDmod;
+
+	mdb = new MdbSession();
+	mdb.mdb_target_name = args.targetName;
+	mdb.mdb_target_type = args.targetType;
+	mdb.mdb_remove_on_success = args.removeOnSuccess;
+
+	/* Use the "-S" flag to avoid interference from a user's .mdbrc file. */
+	mdb.mdb_args.push('-S');
+
+	if (process.env['MDB_LIBRARY_PATH'] &&
+	    process.env['MDB_LIBRARY_PATH'] != '') {
+		mdb.mdb_args.push('-L');
+		mdb.mdb_args.push(process.env['MDB_LIBRARY_PATH']);
+	}
+
+	if (args.targetType == 'file') {
+		mdb.mdb_args.push(args.targetName);
+	} else {
+		mdb.mdb_args.push('-p');
+		mdb.mdb_args.push(args.targetName);
+	}
+
+	mdb.mdb_child = childprocess.spawn('mdb',
+	    mdb.mdb_args, {
+		'stdio': 'pipe',
+		'env': {
+		    'TZ': 'utc',
+		    'UMEM_DEBUG': 'default',
+		    'UMEM_LOGGING': 'transaction=8M,fail'
+		}
+	    });
+
+	mdb.mdb_child.on('exit', function (code) {
+		mdb.onExit(code);
+	});
+
+	mdb.mdb_child.stdout.on('data', function (chunk) {
+		mdb.mdb_output += chunk;
+		while (mdb.mdb_output.indexOf(MDB_SENTINEL) != -1) {
+			mdb.doWork();
+		}
+	});
+
+	mdb.mdb_onprocexit = function (code) {
+		if (code === 0) {
+			throw (new Error('test exiting prematurely (' +
+			    'mdb session not finalized)'));
+		}
+	};
+	process.on('exit', mdb.mdb_onprocexit);
+
+	mdb.mdb_child.stderr.on('data', function (chunk) {
+		console.log('mdb: stderr: ' + chunk);
+		assert.ok(!loaddmod || loaded,
+		    'dmod emitted stderr before ::load was complete');
+	});
+
+	/*
+	 * The '1000$w' sets the terminal width to a large value to keep MDB
+	 * from inserting newlines at the default 80 columns.
+	 */
+	mdb.runCmd('1000$w\n', function () {
+		var cmdstr;
+		if (!loaddmod) {
+			callback(null, mdb);
+			return;
+		}
+
+		cmdstr = '::load ' + dmodpath() + '\n';
+		mdb.runCmd(cmdstr, function () {
+			loaded = true;
+			callback(null, mdb);
+		});
+	});
+
+	return (mdb);
+}
+
+/*
+ * Standalone test-cases do the following:
+ *
+ * - gcore the current process
+ * - start up MDB on the current process
+ * - invoke each of the specified functions as a vasync pipeline, with an
+ *   "MdbSession" as the sole initial argument
+ * - on success, clean up the core file that was created
+ */
+function standaloneTest(funcs, callback)
+{
+	var mdb;
+
+	vasync.waterfall([
+	    gcoreSelf,
+	    createMdbSessionFile,
+	    function runTestPipeline(mdbhdl, wfcallback) {
+		mdb = mdbhdl;
+		vasync.pipeline({
+		    'funcs': funcs,
+		    'arg': mdbhdl
+		}, wfcallback);
+	    }
+	], function (err) {
+		if (!err) {
+			mdb.finish();
+			callback();
+			return;
+		}
+
+		if (mdb) {
+			err = new VError(err,
+			    'test failed (keeping core file %s)',
+			    mdb.mdb_target_name);
+			mdb.finish(err);
+		} else {
+			err = new VError(err, 'test failed');
+		}
+
+		callback(err);
+	});
+}
diff --git a/test/standalone/gcore_self.js b/test/standalone/gcore_self.js
new file mode 100644
index 0000000..3518360
--- /dev/null
+++ b/test/standalone/gcore_self.js
@@ -0,0 +1,168 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2018, Joyent, Inc.
+ */
+
+/*
+ * test/standalone/gcore_self.js: utility function for creating a core file of
+ * the current process.
+ */
+
+var assert = require('assert');
+var childprocess = require('child_process');
+var fs = require('fs');
+var vasync = require('vasync');
+var VError = require('verror');
+
+/* Public interface */
+module.exports = gcoreSelf;
+
+var DSCRIPT_FILE_SENTINEL = '/mdb_v8/sentinel';
+var DSCRIPT_SENTINEL_BEGIN = 'mdb_v8: dtrace has started tracing';
+var DSCRIPT_SENTINEL_DONE = 'mdb_v8: gcore has finished';
+var DSCRIPT_SUFFIX = [
+    '/* This script was auto-generated by the mdb_v8 test suite. */',
+    '',
+    '#pragma D option destructive',
+    '#pragma D option quiet',
+    '',
+    'BEGIN',
+    '{',
+    '    printf("%s\\n", ' + JSON.stringify(DSCRIPT_SENTINEL_BEGIN) + ');',
+    '}',
+    '',
+    'syscall::stat:entry,',
+    'syscall::stat64:entry',
+    '/pid == TARGET_PID && copyinstr(arg0) == ' +
+	JSON.stringify(DSCRIPT_FILE_SENTINEL) + '/',
+    '{',
+    '    stop();',
+    '    system("gcore -o %s %d && echo %s; prun %d", COREBASE, TARGET_PID,',
+    '        ' + JSON.stringify(DSCRIPT_SENTINEL_DONE) + ', TARGET_PID);',
+    '    exit(0);',
+    '}'
+].join('\n');
+
+function makeDTraceArgs(corebase)
+{
+	var script;
+
+	script = [
+	    '#define COREBASE   ' + JSON.stringify(corebase),
+	    '#define TARGET_PID ' + process.pid,
+	    DSCRIPT_SUFFIX
+	].join('\n');
+
+	return ({
+	    'program': 'dtrace',
+	    'script': script,
+	    'argv': [ '-Cs', '/dev/stdin' ]
+	});
+}
+
+/*
+ * Utility function for saving a core file of the current process using
+ * gcore(1M).  This is used in a number of tests as the basis for exercising
+ * mdb_v8.  This function invokes "callback" upon completion with arguments:
+ *
+ * - err, if there was any error
+ * - filename, with the path to the specified file
+ *
+ * This implementation is a lot more complex than one might expect because it
+ * attempts to ensure that the core file is taken when GC is not running.
+ */
+function gcoreSelf(callback)
+{
+	var prefix, corefile, dtrace_args;
+	var dtrace, state, error, buffered;
+
+	prefix = '/var/tmp/node';
+	corefile = prefix + '.' + process.pid;
+	dtrace_args = makeDTraceArgs(prefix);
+	state = 'wait_for_trace';
+	error = null;
+
+	console.error('gcoreSelf: begin');
+	dtrace = childprocess.spawn(dtrace_args.program, dtrace_args.argv);
+	dtrace.stdin.end(dtrace_args.script);
+	dtrace.stderr.on('data', function (data) {
+		process.stderr.write('gcoreSelf: dtrace stderr: ' + data);
+	});
+
+	buffered = '';
+	dtrace.stdout.on('data', function (data) {
+		var sentinelExists;
+
+		process.stderr.write('gcoreSelf: dtrace stdout: ' + data);
+		buffered += data;
+
+		if (state == 'wait_for_trace') {
+			if (buffered.indexOf(DSCRIPT_SENTINEL_BEGIN) == -1) {
+				/* Wait for the sentinel. */
+				console.error('gcoreSelf: waiting extra');
+				return;
+			}
+
+			/*
+			 * We have to stat the file synchronously in order to
+			 * know for sure that this thread will not be running
+			 * GC.  We don't really care about the result, but we
+			 * check to be sure things haven't flown off the rails.
+			 */
+			console.error('gcoreSelf: dtrace is tracing');
+			state = 'wait_for_result';
+			try {
+				fs.statSync(DSCRIPT_FILE_SENTINEL);
+				sentinelExists = true;
+			} catch (err) {
+				assert.strictEqual(err.code, 'ENOENT');
+				sentinelExists = false;
+			}
+			assert.ok(sentinelExists === false,
+			    'statSync of sentinel unexpectedly succeeded!');
+
+			/*
+			 * It shouldn't be possible to see both the initial
+			 * sentinel and the final sentinel on the same tick
+			 * because we must take action in between these.
+			 */
+			assert.strictEqual(-1,
+			    buffered.indexOf(DSCRIPT_SENTINEL_DONE));
+			return;
+		}
+
+		if (state == 'wait_for_result') {
+			if (buffered.indexOf(DSCRIPT_SENTINEL_DONE) == -1) {
+				/* Wait for the second sentinel. */
+				console.error('gcoreSelf: waiting extra');
+				return;
+			}
+
+			/* Success! */
+			state = 'succeeded';
+			console.error('gcoreSelf: gcore completed');
+		}
+	});
+
+	dtrace.on('exit', function (code) {
+		if (code !== 0) {
+			error = new VError('dtrace exited unexpectedly with ' +
+			    'code %s', code.toString());
+		} else if (state != 'succeeded') {
+			error = new VError('dtrace exited successfully, but ' +
+			    'never received sentinel');
+		}
+
+		if (error) {
+			callback(error);
+		} else {
+			console.error('gcoreSelf: gcore created %s', corefile);
+			callback(null, corefile);
+		}
+	});
+}
diff --git a/test/standalone/tst.arrays.js b/test/standalone/tst.arrays.js
new file mode 100644
index 0000000..f5b5393
--- /dev/null
+++ b/test/standalone/tst.arrays.js
@@ -0,0 +1,574 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2018, Joyent, Inc.
+ */
+
+/*
+ * tst.arrays.js: This test case generates a number of arrays of various sizes,
+ * finds them with "findjsobjects", then prints them out with "jsprint",
+ * "jsarray", and "walk jsarray".  Then it does the same with some
+ * specially-crafted arrays.
+ *
+ * Like most of the standalone tests, this test works by creating a bunch of
+ * structures in memory, using gcore(1M) to save a core file of the current
+ * process, and then using an MDB session against the core file to pull out
+ * those structures and verify that the debugger interprets them correctly.
+ */
+
+var assert = require('assert');
+var util = require('util');
+
+var common = require('./common');
+
+/*
+ * Test cases will be automatically generated containing arrays of the following
+ * lengths.
+ */
+var testCaseLengths = [
+    0,		/* important special case */
+    1,		/* important special case */
+    3,		/* a few elements */
+
+    1023,	/* boundary cases in the code */
+    1024,
+    1025,
+
+    4095,	/* possible boundary case in the code */
+    4096,
+    4097,
+
+    100000	/* large array */
+];
+
+/*
+ * There are a few "ad hoc" test cases -- those with arrays defined explicitly
+ * in code below, rather than auto-generated to be a certain length.  For each
+ * test case, we initialize the array itself in main().  As part of the test, we
+ * invoke dcmds and a walker to dump the array and check the output against the
+ * expected elements defined below.
+ */
+var testCasesAdHoc = [ {
+    'name': 'predefined_length',
+    'expectedElements': [
+	'hole',
+	'"array_predefined_length_element_1"',
+	'"array_predefined_length_element_2"',
+	'"array_predefined_length_element_3"',
+	'"array_predefined_length_element_4"',
+	'"array_predefined_length_element_5"',
+	'hole',
+	'hole'
+    ]
+}, {
+    'name': 'with_hole',
+    'expectedElements': [
+	'"array_with_hole_element_0"',
+	'"array_with_hole_element_1"',
+	'"array_with_hole_element_2"',
+	'hole',
+	'"array_with_hole_element_4"',
+	'"array_with_hole_element_5"',
+	'"array_with_hole_element_6"'
+    ]
+}, {
+    'name': 'sliced',
+    'expectedElements': [
+	'"array_1023_element_700"',
+	'"array_1023_element_701"',
+	'"array_1023_element_702"'
+    ]
+} ];
+
+/*
+ * "testObject" is the root object from which we will hang the objects used for
+ * our test cases.  That way once we find it with "findjsobjects", we can easily
+ * find all of the test case objects.
+ */
+var testObject = {};
+
+/*
+ * Addresses found in the core file for "testObject" itself as well as the
+ * arrays hanging off of it.
+ */
+var testObjectAddr;
+var testArrayAddrs = {};
+
+function main()
+{
+	var arr, i;
+	var testFuncs;
+
+	testFuncs = [
+	    /* Initial phases locate addresses of interest in the core file. */
+	    findTestObjectAddr,
+	    findArrayAddrs,
+
+	    /* Next, we have special-case tests. */
+	    testNullAddr.bind(null, '::jsarray'),
+	    testNullAddr.bind(null, '::jsarray -i'),
+	    testNullAddr.bind(null, '::walk jselement'),
+	    testBadAddr.bind(null, '::jsarray'),
+	    testBadAddr.bind(null, '::jsarray -i'),
+	    testBadAddr.bind(null, '::walk jselement')
+
+	    /* The remaining test cases are generated below. */
+	];
+
+	/*
+	 * Generate actual test cases for the array lengths configured above.
+	 * Each test case consists of a single array stored into
+	 * testObject['array_N'], where N is the length of the array.  The
+	 * contents of the array are strings named for the array itself and
+	 * which element they are so that it's pretty clear which output belongs
+	 * to what.  (This test would use less memory and run faster if we just
+	 * used integers, but it's harder to know that the test is doing the
+	 * right thing.)
+	 */
+	testCaseLengths.forEach(function (targetLength) {
+		var key;
+
+		key = util.format('array_%d', targetLength);
+		assert.ok(!testObject.hasOwnProperty(key),
+		    'duplicate test for array of length ' + targetLength);
+		arr = testObject[key] = [];
+		for (i = 0; i < targetLength; i++) {
+			arr.push(eltvalue(key, i));
+		}
+
+		testFuncs.push(testArrayJsprint.bind(null, targetLength));
+		testFuncs.push(testArrayJsarray.bind(null, targetLength));
+		testFuncs.push(testArrayWalker.bind(null, targetLength));
+	});
+
+	/*
+	 * Generate tests for more ad hoc cases.  First, try an array with a
+	 * pre-defined length, where not all of the elements were specified.
+	 */
+	arr = testObject['array_predefined_length'] = new Array(8);
+	for (i = 1; i < 6; i++) {
+		arr[i] = eltvalue('array_predefined_length', i);
+	}
+
+	/*
+	 * Now, try an array with a hole in it.
+	 */
+	arr = testObject['array_with_hole'] = new Array(7);
+	for (i = 0; i < 7; i++) {
+		arr[i] = eltvalue('array_with_hole', i);
+	}
+	delete (arr[3]);
+
+	/*
+	 * Now, try an array that's a slice of a much larger one.
+	 */
+	testObject['array_sliced'] = testObject['array_1023'].slice(700, 703);
+
+	testCasesAdHoc.forEach(function (testcase) {
+		testFuncs.push(testArrayAdHoc.bind(null, {
+		    'testCase': testcase,
+		    'flavor': 'jsprint'
+		}));
+		testFuncs.push(testArrayAdHoc.bind(null, {
+		    'testCase': testcase,
+		    'flavor': 'jsarray'
+		}));
+		testFuncs.push(testArrayAdHoc.bind(null, {
+		    'testCase': testcase,
+		    'flavor': 'jselement'
+		}));
+	});
+
+	/*
+	 * Finally, create an array with which we can test the output of
+	 * "::jsarray -i".  It's much easier to do this with integer values,
+	 * which we can validate without piping the result to "::jsprint".  The
+	 * output comparison relies on the stable representation of small
+	 * integers, which differs between 32-bit and 64-bit, but it's a
+	 * reasonable tradeoff here.
+	 */
+	testFuncs.push(testJsprintIndexes.bind(null, 'array_0', []));
+
+	testObject['array_integers'] = [ 1, 2, 3, 5, 7, 11, 13 ];
+	testFuncs.push(testJsprintIndexes.bind(null, 'array_integers',
+	    process.arch == 'ia32' ?  [ '2', '4', '6', 'a', 'e', '16', '1a' ] :
+		[ '100000000', '200000000', '300000000', '500000000',
+		'700000000', 'b00000000', 'd00000000' ]));
+
+	testFuncs.push(function (mdb, callback) {
+		mdb.checkMdbLeaks(callback);
+	});
+
+	/*
+	 * This is a little cheesy, but we set this property to a boolean value
+	 * immediately before saving the core file to minimize the chance that
+	 * when we go look for this object that we'll find several other garbage
+	 * objects having the same property with the same value (because they've
+	 * been copied around by intervening GC operations).
+	 */
+	testObject['testObjectFinished'] = true;
+
+	common.standaloneTest(testFuncs, function (err) {
+		if (err) {
+			throw (err);
+		}
+
+		console.log('%s passed', process.argv[1]);
+	});
+}
+
+/*
+ * Given a test array's name and which element we're looking at, return the
+ * expected value of that element in that array.
+ */
+function eltvalue(name, i)
+{
+	assert.equal(typeof (name), 'string');
+	assert.equal(typeof (i), 'number');
+	return (util.format('%s_element_%d', name, i));
+}
+
+/*
+ * From the core file, finds the address of "testObject" for use in subsequent
+ * phases.
+ */
+function findTestObjectAddr(mdb, callback) {
+	var cmdstr;
+
+	cmdstr = '::findjsobjects -p testObjectFinished | ::findjsobjects | ' +
+	    '::jsprint -b testObjectFinished\n';
+	mdb.runCmd(cmdstr, function (output) {
+		var lines, li, parts;
+
+		lines = output.split('\n');
+		assert.strictEqual(lines[lines.length - 1].length, 0,
+		    'last line was not empty');
+
+		for (li = 0; li < lines.length - 1; li++) {
+			parts = lines[li].split(':');
+			if (parts.length == 2 && parts[1] == ' true') {
+				if (testObjectAddr !== undefined) {
+					/*
+					 * We've probably found a garbage object
+					 * that's convincing enough that we
+					 * can't tell that it's wrong.
+					 */
+					callback(new Error(
+					    'found more than one possible ' +
+					    'test object'));
+					return;
+				}
+
+				testObjectAddr = parts[0];
+			}
+		}
+
+		if (testObjectAddr === undefined) {
+			callback(new Error('did not find test object'));
+		} else {
+			console.error('test object: ', testObjectAddr);
+			callback();
+		}
+	});
+}
+
+/*
+ * From the core file, finds the addresses for each of the test arrays in
+ * "testObject" for use in subsequent phases.
+ */
+function findArrayAddrs(mdb, callback) {
+	var cmdstr;
+
+	assert.equal(typeof (testObjectAddr), 'string');
+	cmdstr = util.format('%s::jsprint -ad1\n', testObjectAddr);
+	mdb.runCmd(cmdstr, function (output) {
+		var lines, i, parts, key, ptr;
+
+		lines = output.split('\n');
+		assert.equal(lines[0].trim(), testObjectAddr + ': {');
+		assert.equal(lines[lines.length - 2].trim(), '}');
+		assert.strictEqual(lines[lines.length - 1].length, 0);
+
+		for (i = 1; i < lines.length - 2; i++) {
+			if (!/^    "array_/.test(lines[i])) {
+				continue;
+			}
+
+			parts = lines[i].trim().split(':');
+			assert.equal(parts.length, 3,
+			    'unexpected form of output');
+			key = parts[0].trim();
+			assert.equal(key.charAt(0), '"');
+			assert.equal(key.charAt(key.length - 1), '"');
+			key = key.substr(1, key.length - 2);
+			ptr = parts[1].trim();
+
+			console.error('address of %s: %s', key, ptr);
+			testArrayAddrs[key] = ptr;
+		}
+
+		callback();
+	});
+}
+
+/*
+ * Test the expected behavior of using "0" as the target address of the
+ * specified command.
+ */
+function testNullAddr(cmd, mdb, callback)
+{
+	var cmdstr;
+
+	cmdstr = util.format('0%s\n', cmd);
+	mdb.runCmd(cmdstr, function (output) {
+		/*
+		 * TODO we should really validate the stderr, but it will
+		 * suffice for now to ensure that mdb_v8 didn't crash.
+		 */
+		assert.equal(output, '');
+		callback();
+	});
+}
+
+/*
+ * Test the expected behavior of using a non-array pointer as the target address
+ * of the specified command.  We use the address of "testObject", which we know
+ * to be an object and not an array.
+ */
+function testBadAddr(cmd, mdb, callback)
+{
+	var cmdstr;
+
+	assert.equal(typeof (testObjectAddr), 'string');
+	cmdstr = util.format('%s%s\n', testObjectAddr, cmd);
+	mdb.runCmd(cmdstr, function (output) {
+		/*
+		 * TODO we should really validate the stderr, but it will
+		 * suffice for now to ensure that mdb_v8 didn't crash.
+		 */
+		assert.equal(output, '');
+		callback();
+	});
+
+}
+
+/*
+ * Invoked for each of the test cases generated from "testCaseLengths" to verify
+ * the "::jsprint" output for the array.  "::jsprint" output is not really
+ * intended for programmatic stability, so this test case may need to evolve in
+ * the future, but it's still worthwhile to verify that these various arrays are
+ * actually printed properly.
+ */
+function testArrayJsprint(targetLength, mdb, callback)
+{
+	var keyname, cmdstr;
+
+	keyname = util.format('array_%d', targetLength);
+	assert.equal(typeof (testObjectAddr), 'string');
+	assert.equal(typeof (testArrayAddrs[keyname]), 'string',
+	    'did not find address of array ' + keyname);
+	cmdstr = util.format('%s::jsprint\n', testArrayAddrs[keyname]);
+	mdb.runCmd(cmdstr, function (output) {
+		var lines, i, expected;
+
+		/*
+		 * Arrays of length 0 and 1 are printed more concisely, so we
+		 * check for those explicitly.
+		 */
+		if (targetLength === 0) {
+			assert.equal(output, '[]\n',
+			    'zero element array output');
+			callback();
+			return;
+		}
+
+		if (targetLength == 1) {
+			assert.equal(output,
+			    util.format('[ "%s" ]\n', eltvalue(keyname, 0)));
+			callback();
+			return;
+		}
+
+		lines = output.split('\n');
+		assert.equal(lines[0].trim(), '[',
+		    'unexpected first row of ::jsarray output on array');
+		assert.equal(lines[lines.length - 2].trim(), ']',
+		    'unexpected last row of ::jsarray output on array');
+		assert.equal(lines[lines.length - 1].length, 0,
+		    'last line was not empty');
+		assert.equal(lines.length, targetLength + 3,
+		    'unexpected number of array elements');
+
+		for (i = 0; i < targetLength; i++) {
+			expected = util.format('    "%s",',
+			    eltvalue(keyname, i));
+			assert.equal(lines[i + 1], expected);
+		}
+
+		callback();
+	});
+}
+
+/*
+ * Invoked for each of the test cases generated from "testCaseLengths" to verify
+ * the "::jsarray" output for the array.  "::jsarray" primarily exists to be a
+ * bare-bones array iterator, so this test case should not require significant
+ * changes over time.
+ */
+function testArrayJsarray(targetLength, mdb, callback)
+{
+	var keyname, cmdstr;
+
+	keyname = util.format('array_%d', targetLength);
+	assert.equal(typeof (testObjectAddr), 'string');
+	assert.equal(typeof (testArrayAddrs[keyname]), 'string',
+	    'did not find address of array ' + keyname);
+	cmdstr = util.format('%s::jsarray | ::jsprint\n',
+	    testArrayAddrs[keyname]);
+	mdb.runCmd(cmdstr, function (output) {
+		verifyOutputArray(keyname, targetLength, output);
+		callback();
+	});
+}
+
+/*
+ * Invoked for each of the test cases generated from "testCaseLengths" to verify
+ * the "::walk jselement" output for the array.
+ */
+function testArrayWalker(targetLength, mdb, callback)
+{
+	var keyname, cmdstr;
+
+	keyname = util.format('array_%d', targetLength);
+	assert.equal(typeof (testObjectAddr), 'string');
+	assert.equal(typeof (testArrayAddrs[keyname]), 'string',
+	    'did not find address of array ' + keyname);
+	cmdstr = util.format('%s::walk jselement | ::jsprint\n',
+	    testArrayAddrs[keyname]);
+	mdb.runCmd(cmdstr, function (output) {
+		verifyOutputArray(keyname, targetLength, output);
+		callback();
+	});
+}
+
+/*
+ * Common function for validating the output of "::walk jselement | ::jsprint"
+ * and "::jsarray | ::jsprint" for the auto-generated arrays.
+ */
+function verifyOutputArray(keyname, targetLength, output)
+{
+	var lines, i;
+
+	lines = output.split('\n');
+	assert.ok(lines.length > 0);
+	assert.strictEqual(lines[lines.length - 1].length, 0,
+	    'last line was not empty');
+	assert.strictEqual(lines.length, targetLength + 1,
+	    'unexpected number of lines');
+	for (i = 0; i < targetLength; i++) {
+		assert.equal(lines[i], '"' + eltvalue(keyname, i) + '"');
+	}
+}
+
+/*
+ * testArrayAdHoc executes a single dcmd for a specific one of the
+ * "testCasesAdHoc" defined above and compares the output against what's
+ * expected.  Named arguments:
+ *
+ *    testCase (object)         one of the elements of testCasesAdHoc, which
+ *                              should have:
+ *
+ *      name (string)           name of the test case.  There must be a
+ *                              corresponding array in testObject, named after
+ *                              this name in the same way as for the
+ *                              auto-generated test cases.  (See main() for
+ *                              where these arrays are defined.)
+ *
+ *     expectedElements (array) list of the elements expected in the array.
+ *                              These are specifically hardcoded separately from
+ *                              the definition of the array as a cross-check to
+ *                              make sure we've got what we expected.
+ *
+ *   flavor (string)		one of "jsprint", "jsarray", or "jselement",
+ *   				which indicates which dcmd to run.
+ */
+function testArrayAdHoc(args, mdb, callback)
+{
+	var keyname, cmdstr, flavor;
+	var expectedElements, expectedOutput;
+
+	assert.equal('object', typeof (args));
+	assert.equal('object', typeof (args.testCase));
+	assert.equal('string', typeof (args.testCase.name));
+	assert.equal('string', typeof (args.flavor));
+	assert.ok(Array.isArray(args.testCase.expectedElements));
+	assert.ok([ 'jsprint', 'jsarray', 'jselement' ].indexOf(
+	    args.flavor) != -1,
+	    'unrecognized test case flavor: ' + args.flavor);
+	assert.equal(typeof (testObjectAddr), 'string');
+
+	keyname = 'array_' + args.testCase.name;
+	assert.ok(testObject.hasOwnProperty(keyname),
+	    'ad-hoc test case "' + keyname + '" has no array defined');
+	assert.equal(typeof (testArrayAddrs[keyname]), 'string',
+	    'did not find address of array ' + keyname);
+
+	expectedElements = args.testCase.expectedElements;
+	cmdstr = testArrayAddrs[keyname];
+	flavor = args.flavor;
+
+	if (flavor == 'jsprint') {
+		/*
+		 * For "::jsprint", the expected output includes the leading
+		 * "[" and the trailing "]", and the elements in between are
+		 * indented and end with a comma.
+		 */
+		expectedOutput = util.format('[\n%s]\n',
+		    expectedElements.map(function (elt) {
+			return ('    ' + elt + ',\n');
+		    }).join(''));
+		cmdstr += '::jsprint\n';
+	} else {
+		/*
+		 * For both "::jsarray | ::jsprint" and "::walk jsarray |
+		 * ::jsprint", the output consists of the expected elements with
+		 * a newline after each line.
+		 */
+		expectedOutput = expectedElements.join('\n') + '\n';
+		if (flavor == 'jsarray') {
+			cmdstr += '::jsarray | ::jsprint\n';
+		} else {
+			cmdstr += '::walk jselement | ::jsprint\n';
+		}
+	}
+
+	mdb.runCmd(cmdstr, function (output) {
+		assert.equal(output, expectedOutput);
+		callback();
+	});
+}
+
+/*
+ * Tests the output of "::jsprint -i" on the given named array in "testObject".
+ */
+function testJsprintIndexes(arrayname, elements, mdb, callback)
+{
+	var cmdstr, addr;
+
+	assert.ok(testArrayAddrs.hasOwnProperty(arrayname),
+	    'test case references bogus array: "' + arrayname + '"');
+	addr = testArrayAddrs[arrayname];
+	cmdstr = util.format('%s::jsarray -i\n', addr);
+	mdb.runCmd(cmdstr, function (output) {
+		assert.equal(output, elements.map(function (e, i) {
+			return (util.format('%d %s\n', i, e));
+		}).join(''));
+		callback();
+	});
+}
+
+main();
diff --git a/test/standalone/tst.jsclosure.js b/test/standalone/tst.jsclosure.js
index da5ab26..eeb5326 100644
--- a/test/standalone/tst.jsclosure.js
+++ b/test/standalone/tst.jsclosure.js
@@ -5,20 +5,27 @@
  */
 
 /*
- * Copyright (c) 2017, Joyent, Inc.
+ * Copyright (c) 2018, Joyent, Inc.
  */
 
 var assert = require('assert');
+var childprocess = require('child_process');
 var os = require('os');
 var path = require('path');
 var util = require('util');
 
 var common = require('./common');
+
 var getRuntimeVersions = require('../lib/runtime-versions').getRuntimeVersions;
 var compareV8Versions = require('../lib/runtime-versions').compareV8Versions;
 
+var gcoreSelf = require('./gcore_self');
+
 var RUNTIME_VERSIONS = getRuntimeVersions();
 var V8_VERSION = RUNTIME_VERSIONS.V8;
+var to, passed, mdb;
+var output = '';
+var sentinel = 'SENTINEL\n';
 
 /*
  * We're going to look for this function in ::jsfunctions.
@@ -47,42 +54,25 @@ var bindObject = {
 };
 
 doStuff('hello world');
-process.stdout.write(util.format(bindObject).length > 0 ? '' : 'unused');
-
-/*
- * Now we're going to fork ourselves to gcore
- */
-var spawn = require('child_process').spawn;
-var prefix = '/var/tmp/node';
-var corefile = prefix + '.' + process.pid;
-var gcore = spawn('gcore', [ '-o', prefix, process.pid + '' ]);
-var output = '';
-var unlinkSync = require('fs').unlinkSync;
-var args = [ '-S', corefile ];
-var sentinel = 'SENTINEL\n';
-var mdb;
-var passed;
-var to;
 
 process.on('exit', function () {
 	assert.ok(passed);
 	console.error('test passed');
 });
 
-if (process.env.MDB_LIBRARY_PATH && process.env.MDB_LIBRARY_PATH != '')
-	args = args.concat([ '-L', process.env.MDB_LIBRARY_PATH ]);
+gcoreSelf(function onGcore(err, corefile) {
+	var unlinkSync = require('fs').unlinkSync;
+	var args = [ '-S', corefile ];
 
-gcore.stderr.on('data', function (data) {
-	console.log('gcore: ' + data);
-});
-
-gcore.on('exit', function (code) {
-	if (code != 0) {
-		console.error('gcore exited with code ' + code);
-		process.exit(code);
+	if (err) {
+		console.error('failed to gcore self: %s', err.message);
+		process.exit(1);
 	}
 
-	mdb = spawn('mdb', args, { stdio: 'pipe' });
+	if (process.env.MDB_LIBRARY_PATH && process.env.MDB_LIBRARY_PATH != '')
+		args = args.concat([ '-L', process.env.MDB_LIBRARY_PATH ]);
+
+	mdb = childprocess.spawn('mdb', args, { stdio: 'pipe' });
 
 	mdb.on('exit', function (code2) {
 		var retained = '; core retained as ' + corefile;
@@ -150,6 +140,8 @@ processors = [
 
     function gotClosurePointer(chunk) {
 	closure = chunk.trim();
+	assert.ok(closure.length > 0,
+	    'did not find expected closure "myClosure"');
 	doCmd(util.format('%s::jsclosure\n', closure));
     },
 
diff --git a/test/standalone/tst.postmortem_basic.js b/test/standalone/tst.postmortem_basic.js
index c34fa52..8868c88 100644
--- a/test/standalone/tst.postmortem_basic.js
+++ b/test/standalone/tst.postmortem_basic.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2016, Joyent, Inc.
+ * Copyright (c) 2018, Joyent, Inc.
  */
 
 /*
@@ -16,10 +16,8 @@
  */
 
 var common = require('./common');
+
 var assert = require('assert');
-var os = require('os');
-var path = require('path');
-var util = require('util');
 
 /*
  * This class sets a variety of properties that together use most of the kinds
@@ -118,44 +116,11 @@ function Zoo()
 var obj1 = new Menagerie();
 var obj2 = new Zoo();
 
-
-
-/*
- * Now we're going to fork ourselves to gcore
- */
-var spawn = require('child_process').spawn;
-var prefix = '/var/tmp/node';
-var corefile = prefix + '.' + process.pid;
-var gcore = spawn('gcore', [ '-o', prefix, process.pid + '' ]);
-var output = '';
-var unlinkSync = require('fs').unlinkSync;
-var args = [ '-S', corefile ];
-
-if (process.env.MDB_LIBRARY_PATH && process.env.MDB_LIBRARY_PATH != '')
-	args = args.concat([ '-L', process.env.MDB_LIBRARY_PATH ]);
-
-gcore.stderr.on('data', function (data) {
-	console.log('gcore: ' + data);
-});
-
-gcore.on('exit', function (code) {
-	if (code != 0) {
-		console.error('gcore exited with code ' + code);
-		process.exit(code);
-	}
-
-	var mdb = spawn('mdb', args, { stdio: 'pipe', 'env': { 'TZ': 'utc' } });
-
-	mdb.on('exit', function (code2) {
-		var retained = '; core retained as ' + corefile;
-
-		if (code2 != 0) {
-			console.error('mdb exited with code ' +
-			    util.inspect(code2) + retained);
-			process.exit(code2);
-		}
-
-		console.error(output);
+common.standaloneTest([
+    function testMenagerie(mdb, callback) {
+	mdb.runCmd('::findjsobjects -c Menagerie | ' +
+	    '::findjsobjects -p a_seqstring |' +
+	    '::findjsobjects | ::jsprint\n', function (output) {
 		assert.equal([
 		    '{',
 		    '    "a_seqstring": "my_string",',
@@ -188,6 +153,17 @@ gcore.on('exit', function (code) {
 		    '    "a_bool_true": true,',
 		    '    "a_bool_false": false,',
 		    '}',
+		    ''
+		].join('\n'), output);
+		callback();
+	});
+    },
+
+    function testZoo(mdb, callback) {
+	mdb.runCmd('::findjsobjects -c Zoo | ' +
+	    '::findjsobjects -p prop_01 |' +
+	    '::findjsobjects | ::jsprint\n', function (output) {
+		assert.equal([
 		    '{',
 		    '    "prop_00": "value_00",',
 		    '    "prop_01": "value_01",',
@@ -228,28 +204,14 @@ gcore.on('exit', function (code) {
 		    '    "prop_36": "value_36",',
 		    '}',
 		    ''
-		].join('\n'), output,
-		    'output mismatch' + retained);
-		unlinkSync(corefile);
-		process.exit(0);
-	});
-
-	mdb.stdout.on('data', function (data) {
-		output += data;
-	});
-
-	mdb.stderr.on('data', function (data) {
-		console.log('mdb stderr: ' + data);
+		].join('\n'), output);
+		callback();
 	});
+    }
+], function (err) {
+	if (err) {
+		throw (err);
+	}
 
-	var mod = util.format('::load %s ! cat > /dev/null\n',
-	    common.dmodpath());
-	mdb.stdin.write(mod);
-	mdb.stdin.write('::findjsobjects -c Menagerie | ');
-	mdb.stdin.write('::findjsobjects -p a_seqstring | ');
-	mdb.stdin.write('::findjsobjects | ::jsprint\n');
-	mdb.stdin.write('::findjsobjects -c Zoo | ');
-	mdb.stdin.write('::findjsobjects -p prop_01 |');
-	mdb.stdin.write('::findjsobjects | ::jsprint\n');
-	mdb.stdin.end();
+	console.log('%s passed', process.argv[1]);
 });
diff --git a/test/standalone/tst.postmortem_details.js b/test/standalone/tst.postmortem_details.js
index 18c4c2d..5adae3b 100644
--- a/test/standalone/tst.postmortem_details.js
+++ b/test/standalone/tst.postmortem_details.js
@@ -5,11 +5,12 @@
  */
 
 /*
- * Copyright (c) 2015, Joyent, Inc.
+ * Copyright (c) 2018, Joyent, Inc.
  */
 
 
 var assert = require('assert');
+var childprocess = require('child_process');
 var os = require('os');
 var path = require('path');
 var util = require('util');
@@ -22,6 +23,8 @@ var RUNTIME_VERSIONS = getRuntimeVersions();
 var V8_VERSION = RUNTIME_VERSIONS.V8;
 var NODE_VERSION = RUNTIME_VERSIONS.node;
 
+var gcoreSelf = require('./gcore_self');
+
 /*
  * We're going to look specifically for this function and buffer in the core
  * file.
@@ -53,29 +56,22 @@ var OBJECT_KINDS = ['dict', 'inobject', 'numeric', 'props'];
 /*
  * Now we're going to fork ourselves to gcore
  */
-var spawn = require('child_process').spawn;
-var prefix = '/var/tmp/node';
-var corefile = prefix + '.' + process.pid;
 var tmpfile = '/var/tmp/node-postmortem-func' + '.' + process.pid;
-var gcore = spawn('gcore', [ '-o', prefix, process.pid + '' ]);
 var output = '';
-var unlinkSync = require('fs').unlinkSync;
-var args = [ '-S', corefile ];
-
-if (process.env.MDB_LIBRARY_PATH && process.env.MDB_LIBRARY_PATH != '')
-	args = args.concat([ '-L', process.env.MDB_LIBRARY_PATH ]);
 
-gcore.stderr.on('data', function (data) {
-	console.log('gcore: ' + data);
-});
+gcoreSelf(function (err, corefile) {
+	var unlinkSync = require('fs').unlinkSync;
+	var args = [ '-S', corefile ];
 
-gcore.on('exit', function (code) {
-	if (code != 0) {
-		console.error('gcore exited with code ' + code);
-		process.exit(code);
+	if (err) {
+		console.error('failed to gcore self: %s', err.message);
+		process.exit(1);
 	}
 
-	var mdb = spawn('mdb', args, { stdio: 'pipe' });
+	if (process.env.MDB_LIBRARY_PATH && process.env.MDB_LIBRARY_PATH != '')
+		args = args.concat([ '-L', process.env.MDB_LIBRARY_PATH ]);
+
+	var mdb = childprocess.spawn('mdb', args, { stdio: 'pipe' });
 
 	mdb.on('exit', function (code2) {
 		unlinkSync(tmpfile);
diff --git a/test/standalone/tst.postmortem_load.js b/test/standalone/tst.postmortem_load.js
deleted file mode 100644
index 84e6578..0000000
--- a/test/standalone/tst.postmortem_load.js
+++ /dev/null
@@ -1,64 +0,0 @@
-/*
- * This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/.
- */
-
-/*
- * Copyright (c) 2015, Joyent, Inc.
- */
-
-var common = require('./common');
-var assert = require('assert');
-var os = require('os');
-var path = require('path');
-var util = require('util');
-
-/*
- * Now we're going to fork ourselves to gcore
- */
-var spawn = require('child_process').spawn;
-var prefix = '/var/tmp/node';
-var corefile = prefix + '.' + process.pid;
-var gcore = spawn('gcore', [ '-o', prefix, process.pid + '' ]);
-var output = '';
-var unlinkSync = require('fs').unlinkSync;
-var args = [ '-S', corefile ];
-
-if (process.env.MDB_LIBRARY_PATH && process.env.MDB_LIBRARY_PATH != '')
-	args = args.concat([ '-L', process.env.MDB_LIBRARY_PATH ]);
-
-gcore.stderr.on('data', function (data) {
-	console.log('gcore: ' + data);
-});
-
-gcore.on('exit', function (code) {
-	if (code != 0) {
-		console.error('gcore exited with code ' + code);
-		process.exit(code);
-	}
-
-	var mdb = spawn('mdb', args, { stdio: 'pipe' });
-
-	mdb.on('exit', function (code2) {
-		var retained = '; core retained as ' + corefile;
-
-		if (code2 != 0) {
-			console.error('mdb exited with code ' +
-			    util.inspect(code2) + retained);
-			process.exit(code2);
-		}
-
-		unlinkSync(corefile);
-		process.exit(0);
-	});
-
-	mdb.stderr.on('data', function (data) {
-		assert(false,
-		    'loading mdb_v8 should not generate any output on stderr');
-	});
-
-	var mod = util.format('::load %s\n', common.dmodpath());
-	mdb.stdin.write(mod);
-	mdb.stdin.end();
-});
diff --git a/tools/mk/Makefile.node_modules.defs b/tools/mk/Makefile.node_modules.defs
new file mode 100644
index 0000000..ec8cc8e
--- /dev/null
+++ b/tools/mk/Makefile.node_modules.defs
@@ -0,0 +1,68 @@
+#
+# This Source Code Form is subject to the terms of the Mozilla Public
+# License, v. 2.0. If a copy of the MPL was not distributed with this
+# file, You can obtain one at http://mozilla.org/MPL/2.0/.
+#
+
+#
+# Copyright (c) 2017, Joyent, Inc.
+#
+
+#
+# Makefile.node_modules.defs: Makefile for using NPM modules.
+#
+# NOTE: This makefile comes from the "eng" repo. It's designed to be dropped
+# into other repos as-is without requiring any modifications. If you find
+# yourself changing this file, you should instead update the original copy in
+# eng.git and then update your repo to use the new version.
+#
+
+#
+# This Makefile provides a target for building NPM modules from the dependency
+# information in the "package.json" file.  The "npm install" operation is
+# expensive and produces a complex (multi-file) result which is difficult for
+# make to use in dependency analysis.  As such, we use a "stamp" file to track
+# successful completion of module installation.
+#
+# This variable allows the consumer to influence the environment used to run
+# NPM commands.
+#
+#	NPM_ENV			This string should be set to a list of
+#				environment variables in the syntax used
+#				by bash; e.g.,
+#
+#					NPM_ENV =	TESTING=yes V=1
+#
+# Consumers should, for targets which depend on the installation of NPM
+# modules, depend on the stamp file using the $(STAMP_NODE_MODULES) variable,
+# e.g.:
+#
+#	.PHONY: all
+#	all: $(STAMP_NODE_MODULES)
+#
+# A phony target, "make stamp-node-modules", is also provided to allow the
+# engineer to manually perform NPM module installation without invoking other
+# targets.  Note that this target should _not_ be used as a dependency for
+# other targets in consuming Makefiles; using phony targets to represent
+# intermediate build stages can inhibit the ability of make to determine
+# when no additional actions are required.
+#
+
+TOP ?= $(error You must include Makefile.defs before this makefile)
+NPM ?= $(error You must include either Makefile.node.defs or \
+    Makefile.node_prebuilt.defs before this makefile)
+
+BUILD ?=		build
+
+#
+# Invoking "npm install" at the top-level will create a "node_modules"
+# directory into which NPM modules will be installed.
+#
+CLEAN_FILES +=		node_modules
+
+#
+# To avoid repeatedly reinstalling from NPM, we create a "stamp" file to track
+# successful runs of "npm install".  Note that MAKE_STAMPS_DIR is included
+# in CLEAN_FILES already.
+#
+STAMP_NODE_MODULES ?=	$(MAKE_STAMPS_DIR)/node-modules
diff --git a/tools/mk/Makefile.node_modules.targ b/tools/mk/Makefile.node_modules.targ
new file mode 100644
index 0000000..0156bce
--- /dev/null
+++ b/tools/mk/Makefile.node_modules.targ
@@ -0,0 +1,31 @@
+#
+# This Source Code Form is subject to the terms of the Mozilla Public
+# License, v. 2.0. If a copy of the MPL was not distributed with this
+# file, You can obtain one at http://mozilla.org/MPL/2.0/.
+#
+
+#
+# Copyright (c) 2017, Joyent, Inc.
+#
+
+#
+# Makefile.node_modules.targ: See comments in Makefile.node_modules.defs.
+#
+# NOTE: This makefile comes from the "eng" repo. It's designed to be dropped
+# into other repos as-is without requiring any modifications. If you find
+# yourself changing this file, you should instead update the original copy in
+# eng.git and then update your repo to use the new version.
+#
+
+STAMP_NODE_MODULES ?= $(error You must include Makefile.node_modules.defs \
+    before this file)
+
+#
+# If the "package.json" file changes, we need to rebuild the contents of
+# the "node_modules" directory.
+#
+$(STAMP_NODE_MODULES): package.json | $(NPM_EXEC)
+	$(MAKE_STAMP_REMOVE)
+	rm -rf node_modules
+	$(NPM_ENV) $(NPM) install
+	$(MAKE_STAMP_CREATE)
diff --git a/version b/version
index 0159247..cbbcbc6 100644
--- a/version
+++ b/version
@@ -8,4 +8,4 @@
 #
 # This value is also used by the "publish" target in the build process.
 #
-1.2.1
+1.3.0
-- 
2.21.0

