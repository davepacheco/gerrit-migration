From a6b041828d49e0426a3350b0e6218d163d341e45 Mon Sep 17 00:00:00 2001
From: Jan Wyszynski <jan.wyszynski@joyent.com>
Date: Wed, 8 Nov 2017 21:25:00 +0000
Subject: [PATCH] MANTA-3232 Undeploy without disruption - electric-moray

---
 lib/server.js                       | 83 +++++++++++++++++++++++++++++
 smf/manifests/electric-moray.xml.in |  4 +-
 2 files changed, 85 insertions(+), 2 deletions(-)

diff --git a/lib/server.js b/lib/server.js
index c37e52d..df3abe8 100644
--- a/lib/server.js
+++ b/lib/server.js
@@ -13,6 +13,7 @@ var artedi = require('artedi');
 var clone = require('clone');
 var fast = require('fast');
 var fs = require('fs');
+var jsprim = require('jsprim');
 var kang = require('kang');
 var moray_client = require('moray'); // client
 var net = require('net');
@@ -234,6 +235,16 @@ function createServer(options) {
 
             socket.on('listening', function () {
                 log.info('moray listening on %d', options.port);
+                process.on('SIGTERM', function () {
+                    var args = {
+                        server: server,
+                        socket: socket,
+                        monitor: monitorServer,
+                        log: log.child({ component: 'quiesce' }),
+                        options: options
+                    };
+                    quiesce(args);
+                });
             });
 
             socket.on('error', function (serr) {
@@ -257,6 +268,78 @@ module.exports = {
 
 ///--- Privates
 
+
+/*
+ * This function is called if the process has received a SIGTERM signal. In the
+ * current implementation, this signal is sent in electric-morays smf stop
+ * method, which means that it will be invoked whenever the zone is brought
+ * down or rebooted and whenever an operator uses smf tools to disable the
+ * electric-moray service. In order to properly execute a quiesce by disabling
+ * individual service, the operator must disable both registrar and
+ * electric-moray.
+ *
+ * Muskies "MorayConnectionPool," a wrapper around a node-cueball DNS resolver
+ * and connection set, is the other end of all node-fast connection state
+ * created by the FastServer here. In this function, electric-moray is waiting
+ * for that resolver to notice that this zone has dropped out of zookeeper and
+ * terminate any fast-connections it has to this zone. In the interim,
+ * electric-moray can happily serve any pending RPCs that were issued before
+ * Muskie noticed the DNS change. The MorayConnectionPool will take care of
+ * draining any requests that may have been in the pipe once cueball notices
+ * this electric-moray instance is no longer discoverable.
+ */
+function quiesce(args) {
+    assert.object(args.server, 'args.server');
+    assert.object(args.socket, 'args.socket');
+    assert.object(args.monitor, 'args.monitor');
+    assert.object(args.log, 'args.log');
+    assert.object(args.options, 'args.options');
+
+    var server = args.server;
+    var socket = args.socket;
+    var monitorServer = args.monitor;
+    var log = args.log;
+    var options = args.options;
+
+    log.info('moray-%d entering quiesce state', options.port);
+
+    function checkPendingRequests() {
+        if (!jsprim.isEmpty(server.fs_conns)) {
+            jsprim.forEachKey(server.fs_conns, function (connid, conn) {
+                log.info('moray-%d fast connection %s has %d pending ' +
+                    'requests left.', options.port, connid,
+                    Object.keys(conn.fc_pending).length);
+            });
+            setTimeout(checkPendingRequests, 100);
+            return;
+        }
+
+        log.info('moray-%d pending requests drained, open connections removed.',
+                options.port);
+
+        server.close();
+
+        monitorServer.close(function () {
+            log.info('moray-%d shut down monitorServer', options.port);
+            log.info('terminating moray-%d process', options.port);
+            process.exit();
+        });
+    }
+
+    /*
+     * Close the listening socket. To prevent new connections. The callback
+     * passed to close is only called with an err object if the socket was
+     * not opened to begin with. This should not happen.
+     */
+    socket.close(function (err) {
+        assert.ok(!err, 'err');
+    });
+
+    args.socket.on('close', function () {
+        setImmediate(checkPendingRequests);
+    });
+}
+
 function invalidArgs(rpc, argv, types) {
     var route = rpc.methodName();
     var len = types.length;
diff --git a/smf/manifests/electric-moray.xml.in b/smf/manifests/electric-moray.xml.in
index e810c3e..cdc682c 100644
--- a/smf/manifests/electric-moray.xml.in
+++ b/smf/manifests/electric-moray.xml.in
@@ -60,8 +60,8 @@
 
         <exec_method type="method"
             name="stop"
-            exec=":kill"
-            timeout_seconds="30" />
+            exec=":kill -TERM"
+            timeout_seconds="0" />
 
         <property_group name="application" type="application" />
 
-- 
2.21.0

