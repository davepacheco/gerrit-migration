commit cc65855967b940305728abeffeb312d239dd7b81 (refs/changes/51/3251/1)
Author: Julien Gilli <julien.gilli@joyent.com>
Date:   2018-01-22T19:01:02-08:00 (1 year, 9 months ago)
    
    TRITON-59 check that instances mounting NFS volumes are provisioned on networks on which volumes are reachable

diff --git a/lib/endpoints/vms.js b/lib/endpoints/vms.js
index eda81b0..aa38a35 100644
--- a/lib/endpoints/vms.js
+++ b/lib/endpoints/vms.js
@@ -1263,6 +1263,7 @@ function createVm(req, res, next) {
         arg: req,
         funcs: [
             validateCreateVmParams,
+            checkAllNfsVolumesReachable,
             preProvisionNics
         ]
     }, function (err, results) {
@@ -1297,6 +1298,107 @@ function createVm(req, res, next) {
     }
 
 
+    function checkAllNfsVolumesReachable(_, done) {
+        var volumes = req.params.volumes;
+        var networks = req.filteredNetworks.networks;
+
+        assert.optionalArrayOfObject(volumes, 'volumes');
+        assert.arrayOfObject(networks, 'networks');
+
+        req.log.debug('Checking volumes reachability');
+
+        if (!volumes || volumes.length === 0) {
+            req.log.debug('No volume to mount, skipping volumes reachability ' +
+                'checks');
+            done();
+            return;
+        }
+
+        vasync.forEachParallel({
+            func: function checkVolReachable(volume, checkReachableDone) {
+                var ownerUuid;
+                var volumeName;
+
+                assert.object(volume, 'volume');
+                volumeName = volume.name;
+
+                assert.uuid(req.params.owner_uuid, 'req.params.owner_uuid');
+                ownerUuid = req.params.owner_uuid;
+
+                req.log.debug({
+                    volume: volume,
+                    networks: networks
+                }, 'Checking reachability for volume');
+
+                req.app.volapi.listVolumes({
+                    name: volumeName,
+                    owner_uuid: ownerUuid
+                }, function onListVols(listVolsErr, vols) {
+                    var checkReachableErr;
+                    var foundVolNetwork = false;
+                    var idx;
+                    var network;
+
+                    if (listVolsErr) {
+                        checkReachableErr =
+                            new errors.VolumeNotReachableError('Could not ' +
+                                'check reachability for volume ' + volumeName);
+                        checkReachableDone(checkReachableErr);
+                        return;
+                    }
+
+                    if (!vols || vols.length === 0) {
+                        checkReachableDone();
+                        return;
+                    }
+
+                    if (vols.length > 1) {
+                        checkReachableErr =
+                            new errors.VolumeNotReachableError('Could not ' +
+                                'check reachability for volume ' + volumeName +
+                                ' more than one volume with that name');
+                        checkReachableDone(checkReachableErr);
+                        return;
+                    }
+
+                    for (idx = 0; idx < networks.length; ++idx) {
+                        network = networks[idx];
+                        assert.object(network, 'network');
+                        assert.uuid(network.ipv4_uuid, 'network.ipv4_uuid');
+
+                        if (vols[0].networks.indexOf(network.ipv4_uuid) !==
+                            -1) {
+                            foundVolNetwork = true;
+                            break;
+                        }
+                    }
+
+                    if (!foundVolNetwork) {
+                        checkReachableErr =
+                            new errors.VolumeNotReachableError('Volume ' +
+                                volumeName + ' not reachable on networks ' +
+                            networks.map(function getIpv4Uuid(net) {
+                                assert.object(net, 'net');
+                                return net.ipv4_uuid;
+                            }).join(', '));
+                    }
+
+                    checkReachableDone(checkReachableErr);
+                });
+            },
+            inputs: volumes
+        }, function onAllVolsChecked(checkVolErrs) {
+            var checkAllVolsErr;
+
+            if (checkVolErrs) {
+                checkAllVolsErr =
+                    new errors.VolumesNotReachableError(checkVolErrs.errors());
+            }
+
+            done(checkAllVolsErr);
+        });
+    }
+
 
     function createProvisionJob() {
         if (req.params.role_tags === undefined) {
@@ -1359,7 +1461,6 @@ function createVm(req, res, next) {
     }
 }
 
-
 /*
  * Returns either true or an error indicating why snapshots are not supported
  * for this VM.
diff --git a/lib/errors.js b/lib/errors.js
index 4622e1d..026adfa 100644
--- a/lib/errors.js
+++ b/lib/errors.js
@@ -307,4 +307,36 @@ function InvalidDataMigrationFileNamesError(fileNames) {
     this.message = 'Invalid data migration file name: ' + fileNames.join(',');
 }
 util.inherits(InvalidDataMigrationFileNamesError, Error);
-exports.InvalidDataMigrationFileNamesError = InvalidDataMigrationFileNamesError;
\ No newline at end of file
+exports.InvalidDataMigrationFileNamesError = InvalidDataMigrationFileNamesError;
+
+function VolumeNotReachableError(message) {
+    Error.call(this);
+
+    this.message = message;
+    this.code = 'VolumeNotReachableError';
+}
+util.inherits(VolumeNotReachableError, Error);
+exports.VolumeNotReachableError = VolumeNotReachableError;
+
+function VolumesNotReachableError(errors) {
+    assert.arrayOfObject(errors, 'errors');
+
+    var message = 'Volumes not reachable from VM';
+
+    restify.RestError.call(this, {
+        restCode: this.constructor.restCode,
+        statusCode: this.constructor.statusCode,
+        message: message,
+        body: {
+            code: this.constructor.restCode,
+            message: message,
+            errors: errors
+        }
+    });
+}
+
+util.inherits(VolumesNotReachableError, restify.RestError);
+exports.VolumesNotReachableError = VolumesNotReachableError;
+VolumesNotReachableError.prototype.name = 'VolumesNotReachableError';
+VolumesNotReachableError.restCode = 'VolumesNotReachable';
+VolumesNotReachableError.statusCode = 409;
\ No newline at end of file
diff --git a/lib/vmapi.js b/lib/vmapi.js
index 0e23575..4575fe8 100644
--- a/lib/vmapi.js
+++ b/lib/vmapi.js
@@ -76,6 +76,10 @@ function VmapiApp(options) {
         assert.optionalObject(options.apiClients.papi,
             'options.apiClients.papi');
         this.papi = options.apiClients.papi;
+
+        assert.optionalObject(options.apiClients.volapi,
+            'options.apiClients.volapi');
+        this.volapi = options.apiClients.volapi;
     }
 
     /*
diff --git a/server.js b/server.js
index d5baf41..820fd59 100644
--- a/server.js
+++ b/server.js
@@ -31,6 +31,7 @@ var CNAPI = require('./lib/apis/cnapi');
 var IMGAPI = require('./lib/apis/imgapi');
 var PAPI = require('./lib/apis/papi');
 var VmapiApp = require('./lib/vmapi');
+var VOLAPI = require('sdc-clients').VOLAPI;
 var WFAPI = require('./lib/apis/wfapi');
 
 var configLoader = require('./lib/config-loader');
@@ -109,6 +110,14 @@ function createApiClients(config, parentLog) {
     papiClientOpts.agent = agent;
     var papiClient = new PAPI(papiClientOpts);
 
+    assert.object(config.volapi, 'config.volapi');
+    var volapiClientOpts = jsprim.deepCopy(config.volapi);
+    var volapiClient = new VOLAPI({
+        agent: agent,
+        url: volapiClientOpts.url,
+        userAgent: 'sdc-vmapi'
+    });
+
     assert.object(config.wfapi, 'config.wfapi');
     var wfapiClientOpts = jsprim.deepCopy(config.wfapi);
     wfapiClientOpts.log = parentLog.child({ component: 'wfapi' }, true);
@@ -120,6 +129,7 @@ function createApiClients(config, parentLog) {
         imgapi: imgapiClient,
         napi: napiClient,
         papi: papiClient,
+        volapi: volapiClient,
         wfapi: wfapiClient
     };
 }
