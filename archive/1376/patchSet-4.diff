From 4c6feb372da55bee937754300b689a490eba5cea Mon Sep 17 00:00:00 2001
From: Jordan Hendricks <jordan.hendricks@joyent.com>
Date: Tue, 31 Jan 2017 01:52:29 +0000
Subject: [PATCH] MANTA-2169 Support multipart upload of a single file to Manta

---
 lib/moray.js | 292 +++++++++++++++++++++++++++++++++++++++++++--------
 1 file changed, 249 insertions(+), 43 deletions(-)

diff --git a/lib/moray.js b/lib/moray.js
index 43396de..f0961ea 100644
--- a/lib/moray.js
+++ b/lib/moray.js
@@ -78,6 +78,18 @@ var DIR_COUNT_SCHEMA = {
 var DIR_COUNT_VERSION = 1;
 
 
+var MANTA_UPLOADS_BUCKET = process.env.MANTA_UPLOADS_BUCKET ||
+    'manta_uploads';
+var MANTA_UPLOADS_SCHEMA = {
+    finalizingType: {
+        type: 'string'
+    },
+    uploadId: {
+        type: 'string'
+    }
+};
+var MANTA_UPLOADS_VERSION = 1;
+
 
 ///--- Internal Functions
 
@@ -98,6 +110,16 @@ function setupMantaBuckets(log, client, cb) {
                 }
             },
             log: log
+        }, {
+            client: client,
+            bucket: MANTA_UPLOADS_BUCKET,
+            opts: {
+                index: MANTA_UPLOADS_SCHEMA,
+                options: {
+                    version: MANTA_UPLOADS_VERSION
+                }
+            },
+            log: log
         }, {
             client: client,
             bucket: DELETE_LOG_BUCKET,
@@ -292,8 +314,6 @@ function recordDeleteLog(req, cb) {
 
 
 function createMetadata(options) {
-    assert.object(options, 'options');
-    assert.string(options.key, 'options.key');
     assert.string(options.owner, 'options.owner');
     assert.string(options.type, 'options.type');
     assert.optionalObject(options.headers, 'options.headers');
@@ -349,7 +369,9 @@ function createMetadata(options) {
         break;
 
     case 'directory':
-        // noop
+        if (options.upload) {
+            md.upload = options.upload;
+        }
         break;
 
     default:
@@ -377,6 +399,65 @@ function createBucket(opts, cb) {
 }
 
 
+// Helper that calls Moray's `putObject`.
+function put(options, cb) {
+    assert.object(options, 'options');
+    assert.number(options.attempts, 'options.number');
+    assert.ok(options.attempts >= 0);
+    assert.object(options.client, 'options.client');
+    assert.object(options.log, 'options.log');
+    assert.string(options.op, 'options.op');
+    assert.ok(options.op === 'putMetadata' ||
+        options.op === 'putFinalizingMetadata');
+    assert.string(options.bucket, 'options.bucket');
+    assert.string(options.key, 'options.key');
+    assert.object(options.md, 'options.md');
+    assert.object(options.putOptions, 'options.putOptions');
+    assert.func(cb, 'callback');
+
+    var attempts = options.attempts;
+    var client = options.client;
+    var log = options.log;
+    var op = options.op;
+    var bucket = options.bucket;
+    var key = options.key;
+    var md = options.md;
+    var opts = options.putOptions;
+
+    log.debug({
+        attempts: attempts,
+        key: key,
+        metadata: md,
+        etag: opts.etag,
+        requestId: opts.requestId,
+        headers: opts.headers
+    }, 'Moray.' + op + ': entered');
+
+    client.putObject(bucket, key, md, opts, function (err) {
+        if (err) {
+            log.debug({
+                err: err,
+                key: key,
+                requestId: opts.requestId
+            }, 'Moray.' + op + ': error writing metadata');
+
+            if ((err.name === 'EtagConflictError' ||
+                err.name === 'UniqueAttributeError') &&
+                opts.etag === undefined && ++attempts < 3) {
+                options.attempts++;
+                setImmediate(put, options, cb);
+            } else {
+                cb(err);
+            }
+        } else {
+            log.debug({
+                key: key,
+                requestId: opts.requestId
+            }, 'Moray.' + op + ': done');
+            cb(null, md);
+        }
+    });
+}
 
 ///--- API
 
@@ -532,12 +613,17 @@ Moray.prototype.initAttempt = function initAttempt() {
     });
 };
 
+
 Moray.prototype.putMetadata = function putMetadata(options, callback) {
     assert.object(options, 'options');
     assert.string(options.key, 'options.key');
     assert.string(options.requestId, 'options.requestId');
-    assert.object(options, 'options.previousMetadata');
     assert.func(callback, 'callback');
+    if (!options.upload) {
+        assert.object(options, 'options.previousMetadata');
+    } else {
+        assert.ok(!options.previousMetadata);
+    }
 
     callback = once(callback);
 
@@ -548,51 +634,75 @@ Moray.prototype.putMetadata = function putMetadata(options, callback) {
         return;
     }
 
-    var attempts = 0;
-    var client = this.client;
-    var key = options.key;
-    var log = this.log;
-    var md = createMetadata(options);
-    var opts = {
+    var putOptions = {
         req_id: options.requestId,
-        etag: options._etag,
-        headers: {
+        etag: options._etag
+    };
+
+    if (!options.upload) {
+        putOptions.headers = {
             'x-muskie-prev-metadata': options.previousMetadata
-        }
+        };
+    }
+
+    var opts = {
+        attempts: 0,
+        client: this.client,
+        log: this.log,
+        key: options.key,
+        op: 'putMetadata',
+        bucket: BUCKET,
+        md: createMetadata(options),
+        putOptions: putOptions
     };
 
-    log.debug({
-        key: key,
-        metadata: md,
-        etag: opts.etag,
-        requestId: opts.requestId,
-        headers: opts.headers
-    }, 'Moray.putMetadata: entered');
-    (function put() {
-        client.putObject(BUCKET, key, md, opts, function (err) {
-            if (err) {
-                log.debug({
-                    err: err,
-                    key: key,
-                    requestId: opts.requestId
-                }, 'Moray.putMetadata: error writing metadata');
+    put(opts, callback);
+};
 
-                if ((err.name === 'EtagConflictError' ||
-                     err.name === 'UniqueAttributeError') &&
-                    opts.etag === undefined && ++attempts < 3) {
-                    process.nextTick(put);
-                } else {
-                    callback(err);
-                }
-            } else {
-                log.debug({
-                    key: key,
-                    requestId: opts.requestId
-                }, 'Moray.putMetadata: done');
-                callback(null, md);
-            }
+
+/*
+ * Used by the multipart upload API, this function will store a
+ * finalizing record in the special multipart upload bucket.
+ */
+Moray.prototype.putFinalizingMetadata =
+function putFinalizingMetadata(options, callback) {
+    assert.object(options, 'options');
+    assert.string(options.key, 'options.key');
+    assert.object(options.md, 'options.md');
+    assert.string(options.md.uploadId, 'options.md.uploadId');
+    assert.string(options.md.finalizingType, 'options.md.finalizingType');
+    assert.string(options.md.owner, 'options.md.owner');
+    assert.string(options.md.requestId, 'options.md.requestId');
+    assert.string(options.md.objectPath, 'options.md.objectPath');
+    assert.string(options.md.objectId, 'options.md.objectId');
+    assert.func(callback, 'callback');
+
+    callback = once(callback);
+
+    if (!this.client) {
+        setImmediate(function () {
+            callback(new Error('not connected'));
         });
-    })();
+        return;
+    }
+
+    var putOptions = {
+        req_id: options.requestId,
+        etag: options._etag
+    };
+
+    var opts = {
+        attempts: 0,
+        client: this.client,
+        log: this.log,
+        key: options.key,
+        or: 'putFinalizingMetadata',
+        bucket: MANTA_UPLOADS_BUCKET,
+        md: options.md,
+        putOptions: putOptions
+    };
+
+    put(opts, callback);
 };
 
 
@@ -643,6 +753,57 @@ Moray.prototype.getMetadata = function getMetadata(options, callback) {
 };
 
 
+/*
+ * Used by the multipart upload API, this function will fetch a
+ * finalizing record from the special multipart upload bucket.
+ */
+Moray.prototype.getFinalizingMetadata =
+function getFinalizingMetadata(options, callback) {
+    assert.object(options, 'options');
+    assert.string(options.key, 'options.key');
+    assert.string(options.requestId, 'options.requestId');
+    assert.func(callback, 'callback');
+
+    if (!this.client) {
+        setImmediate(function () {
+            callback(new Error('not connected'));
+        });
+        return;
+    }
+
+    var client = this.client;
+    var key = options.key;
+    var log = this.log;
+    var opts = {
+        req_id: options.requestId,
+        noCache: true
+    };
+
+    log.debug({
+        key: key,
+        requestId: opts.requestId
+    }, 'Moray.getFinalizingMetadata: entered');
+
+    client.getObject(MANTA_UPLOADS_BUCKET, key, opts, function (err, md) {
+        if (err) {
+            log.debug({
+                err: err,
+                key: key,
+                requestId: opts.requestId
+            }, 'Moray.getFinalizingMetadata: error reading metadata');
+            callback(err);
+        } else {
+            log.debug({
+                key: key,
+                metadata: md.value,
+                requestId: opts.requestId
+            }, 'Moray.getFinalizingMetadata: done');
+            callback(null, md.value, md);
+        }
+    });
+};
+
+
 Moray.prototype.delMetadata = function delMetadata(options, callback) {
     assert.object(options, 'options');
     assert.string(options.key, 'options.key');
@@ -746,6 +907,51 @@ Moray.prototype.getDirectoryCount = function getDirectoryCount(options, cb) {
 };
 
 
+/*
+ * Commits a multipart upload by performing a Moray batch insertion of a
+ * finalizing record in the Manta multipart uploads bucket and an object record
+ * for the target object being committed.
+ */
+Moray.prototype.commitMPU = function commitMPU(options, cb) {
+    assert.object(options, 'options');
+    assert.arrayOfObject(options.requests, 'options.requests');
+    assert.ok(options.requests.length === 2);
+    assert.string(options.requestId, 'options.requestId');
+    assert.func(cb, 'callback');
+
+    cb = once(cb);
+
+    if (!this.client) {
+        setImmediate(function () {
+            cb(new Error('not connected'));
+        });
+        return;
+    }
+
+    var client = this.client;
+    var log = this.log;
+    var opts = {
+        req_id: options.requestId
+    };
+
+    log.debug({
+        requests: options.requests,
+        requestId: opts.requestId
+    }, 'Moray.commitMPU: entered');
+
+    client.batch(options.requests, opts, function (err, meta) {
+        if (err) {
+            cb(err);
+        } else {
+            log.debug({
+                requestId: opts.requestId
+            }, 'Moray.commitMPU: done');
+            cb(null, meta);
+        }
+    });
+};
+
+
 Moray.prototype.ping = function ping(opts, cb) {
     if (typeof (opts) === 'function') {
         cb = opts;
-- 
2.21.0

