From 51936b890f6ba3b2585437dbe83671a4398a4627 Mon Sep 17 00:00:00 2001
From: Julien Gilli <julien.gilli@joyent.com>
Date: Wed, 10 Jan 2018 15:51:54 -0800
Subject: [PATCH] VOLAPI-98 creating volumes fails in DCs with multiple
 headnodes

---
 lib/endpoints/volumes.js | 56 ++++++++++++++++++----------------------
 1 file changed, 25 insertions(+), 31 deletions(-)

diff --git a/lib/endpoints/volumes.js b/lib/endpoints/volumes.js
index aba4412..a6bf610 100644
--- a/lib/endpoints/volumes.js
+++ b/lib/endpoints/volumes.js
@@ -114,47 +114,41 @@ function _acquireVolumeTicket(ticketId, options, callback) {
     assert.func(callback, 'callback');
 
     var cnapiClient = options.cnapiClient;
+    var log = options.log;
     var ticketParams = {
         scope: VOLUME_TICKETS_SCOPE,
         id: ticketId,
         // 10 minutes
         expires_at: (new Date(Date.now() + 600 * 1000).toString())
     };
-    var log = options.log;
+    /*
+     * Volume tickets need to always be created on the same "server" so that
+     * volume tickets with a given ID are appended to the same queue and are
+     * activated sequentially and in the proper order. We could use the HN's
+     * server UUID for that, however some Triton DCs can have more than one HN,
+     * and so it would be challenging to make sure that all volume tickets use
+     * the same server UUID all the time. Nevertheless, CNAPI accepts the string
+     * 'default' as server UUID. We use that to our advantage so that, even when
+     * a DC has more than one headnode, we can create/wait on tickets that are
+     * always placed in the same queue, regardless of the servers' (including
+     * headnodes) lifecycle.
+     */
+    var WAITLIST_NAME = 'default';
 
     log.debug({ticketParams: ticketParams}, 'Acquiring volume ticket');
 
-    cnapiClient.listServers({
-        headnode: true
-    }, function onListHeadnode(listHeadnodeErr, servers) {
-        assert.optionalArrayOfObject(servers, 'servers');
-
-        if (!servers || servers.length === 0) {
-            callback(new Error('Headnode server not found in CNAPI'));
-            return;
-        }
-
-        if (servers.length > 1) {
-            callback(new Error('More than one headnode server found in CNAPI'));
-            return;
-        }
-
-        var headnodeUuid = servers[0].uuid;
-        assert.string(headnodeUuid, 'headnodeUuid');
-
-        cnapiClient.waitlistTicketCreate(headnodeUuid, ticketParams,
-            function onTicketCreated(ticketCreationErr, ticket) {
-                if (ticketCreationErr) {
-                    callback(ticketCreationErr);
-                    return;
-                }
+    cnapiClient.waitlistTicketCreate(WAITLIST_NAME, ticketParams,
+        function onTicketCreated(ticketCreationErr, ticket) {
+            if (ticketCreationErr) {
+                callback(ticketCreationErr);
+                return;
+            }
 
-                cnapiClient.waitlistTicketWait(ticket.uuid,
-                    function onTicketReleasedOrExpired(err) {
-                        cnapiClient.waitlistTicketGet(ticket.uuid, callback);
-                    });
-            });
-    });
+            cnapiClient.waitlistTicketWait(ticket.uuid,
+                function onTicketReleasedOrExpired(err) {
+                    cnapiClient.waitlistTicketGet(ticket.uuid, callback);
+                });
+        });
 }
 
 function _releaseVolumeTicket(ticket, options, callback) {
-- 
2.21.0

