commit 768e026f7b2c390fa12c08bf605fa1cd07e14a42 (refs/changes/92/3192/4)
Author: Julien Gilli <julien.gilli@joyent.com>
Date:   2018-01-11T01:38:55+00:00 (1 year, 9 months ago)
    
    VOLAPI-98 creating volumes fails in DCs with multiple headnodes
    Reviewed by: Orlando Vazquez <orlando@joyent.com>
    Approved by: Orlando Vazquez <orlando@joyent.com>

diff --git a/lib/endpoints/volumes.js b/lib/endpoints/volumes.js
index aba4412..a6bf610 100644
--- a/lib/endpoints/volumes.js
+++ b/lib/endpoints/volumes.js
@@ -114,47 +114,41 @@ function _acquireVolumeTicket(ticketId, options, callback) {
     assert.func(callback, 'callback');
 
     var cnapiClient = options.cnapiClient;
+    var log = options.log;
     var ticketParams = {
         scope: VOLUME_TICKETS_SCOPE,
         id: ticketId,
         // 10 minutes
         expires_at: (new Date(Date.now() + 600 * 1000).toString())
     };
-    var log = options.log;
+    /*
+     * Volume tickets need to always be created on the same "server" so that
+     * volume tickets with a given ID are appended to the same queue and are
+     * activated sequentially and in the proper order. We could use the HN's
+     * server UUID for that, however some Triton DCs can have more than one HN,
+     * and so it would be challenging to make sure that all volume tickets use
+     * the same server UUID all the time. Nevertheless, CNAPI accepts the string
+     * 'default' as server UUID. We use that to our advantage so that, even when
+     * a DC has more than one headnode, we can create/wait on tickets that are
+     * always placed in the same queue, regardless of the servers' (including
+     * headnodes) lifecycle.
+     */
+    var WAITLIST_NAME = 'default';
 
     log.debug({ticketParams: ticketParams}, 'Acquiring volume ticket');
 
-    cnapiClient.listServers({
-        headnode: true
-    }, function onListHeadnode(listHeadnodeErr, servers) {
-        assert.optionalArrayOfObject(servers, 'servers');
-
-        if (!servers || servers.length === 0) {
-            callback(new Error('Headnode server not found in CNAPI'));
-            return;
-        }
-
-        if (servers.length > 1) {
-            callback(new Error('More than one headnode server found in CNAPI'));
-            return;
-        }
-
-        var headnodeUuid = servers[0].uuid;
-        assert.string(headnodeUuid, 'headnodeUuid');
-
-        cnapiClient.waitlistTicketCreate(headnodeUuid, ticketParams,
-            function onTicketCreated(ticketCreationErr, ticket) {
-                if (ticketCreationErr) {
-                    callback(ticketCreationErr);
-                    return;
-                }
+    cnapiClient.waitlistTicketCreate(WAITLIST_NAME, ticketParams,
+        function onTicketCreated(ticketCreationErr, ticket) {
+            if (ticketCreationErr) {
+                callback(ticketCreationErr);
+                return;
+            }
 
-                cnapiClient.waitlistTicketWait(ticket.uuid,
-                    function onTicketReleasedOrExpired(err) {
-                        cnapiClient.waitlistTicketGet(ticket.uuid, callback);
-                    });
-            });
-    });
+            cnapiClient.waitlistTicketWait(ticket.uuid,
+                function onTicketReleasedOrExpired(err) {
+                    cnapiClient.waitlistTicketGet(ticket.uuid, callback);
+                });
+        });
 }
 
 function _releaseVolumeTicket(ticket, options, callback) {
