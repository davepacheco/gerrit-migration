From 10d4399a65575505d41c5302812cffece912aca6 Mon Sep 17 00:00:00 2001
From: Alex Wilson <alex.wilson@joyent.com>
Date: Fri, 3 Feb 2017 11:24:02 -0800
Subject: [PATCH] MORAY-396 update to cueball v2

---
 CHANGES.md   |  4 ++++
 lib/pool.js  | 58 ++++++++++++++++++++++++++++++++++++++++++++++------
 package.json |  6 +++---
 3 files changed, 59 insertions(+), 9 deletions(-)

diff --git a/CHANGES.md b/CHANGES.md
index f70d20a..905f8bc 100644
--- a/CHANGES.md
+++ b/CHANGES.md
@@ -1,5 +1,9 @@
 # Changelog
 
+## v3.1.1
+
+* [MORAY-396](http://smartos.org/bugview/MORAY-396) update to cueball v2
+
 ## v3.1.0
 
 * [MORAY-254](http://smartos.org/bugview/MORAY-254) moray tools need manual
diff --git a/lib/pool.js b/lib/pool.js
index e8bcf4c..7e0a622 100644
--- a/lib/pool.js
+++ b/lib/pool.js
@@ -34,16 +34,25 @@ var VError = require('verror');
 
 module.exports = MorayConnectionPool;
 
+/*
+ * Delay in ms to wait before applying removal of the final connection in the
+ * set. This is meant to allow the set to become empty in failure cases, while
+ * avoiding emptiness due to "flapping".
+ */
+var LAST_REMOVAL_DELAY = 5000;
+
 /*
  * This is a struct-like class that represents a single logical connection.  The
  * lifecycle and logic are managed by the MorayConnectionPool class.
  */
-function MorayConnection(key, conn, log) {
+function MorayConnection(key, conn, hdl, log) {
     assert.string(key, 'key');
     assert.object(conn, 'conn');
+    assert.object(hdl, 'hdl');
     assert.object(log, 'log');
     this.mc_key = key;      /* cueball identifier for this connection */
     this.mc_conn = conn;    /* object implementing Cueball "Connection" */
+    this.mc_hdl = hdl;      /* cueball handle to release after drain */
     this.mc_log = log;      /* bunyan-style logger */
     this.mc_nreqs = 0;      /* number of outstanding requests */
 }
@@ -95,8 +104,11 @@ function MorayConnectionPool(args) {
     this.mcp_nalloc_fail = 0;   /* failed allocations */
     this.mcp_nreleased = 0;     /* releases */
 
-    this.mcp_cueball_set.on('added', function onConnectionAdd(key, conn) {
-        self.connAdd(key, conn);
+    /* Timeout for removing the last connection. */
+    this.mcp_lastRemovalTimeout = undefined;
+
+    this.mcp_cueball_set.on('added', function onConnectionAdd(key, conn, hdl) {
+        self.connAdd(key, conn, hdl);
     });
 
     this.mcp_cueball_set.on('removed', function onConnectionRemoved(key) {
@@ -169,7 +181,7 @@ MorayConnectionPool.prototype.connRelease = function (aconn) {
  * [private] Invoked by cueball when a new connection has been established and
  * is ready for use.  Just add it to our set of available connections.
  */
-MorayConnectionPool.prototype.connAdd = function connAdd(key, conn) {
+MorayConnectionPool.prototype.connAdd = function connAdd(key, conn, hdl) {
     var mconn, extras;
 
     assert.ok(!this.mcp_conns.hasOwnProperty(key));
@@ -177,10 +189,23 @@ MorayConnectionPool.prototype.connAdd = function connAdd(key, conn) {
 
     extras = conn.socketAddrs();
     extras.key = key;
-    mconn = new MorayConnection(key, conn, this.mcp_log.child(extras, true));
+    mconn = new MorayConnection(key, conn, hdl,
+        this.mcp_log.child(extras, true));
     this.mcp_conns[key] = mconn;
     this.mcp_avail[key] = true;
     mconn.mc_log.info('new connection');
+
+    /*
+     * We must have an 'error' handler on the connection at all times to avoid
+     * crashing the program. Fast will handle propagating the error into all
+     * the outstanding requests, and cueball will handle emitting 'removed'
+     * to get connDrain called, so we just log a message.
+     */
+    function onConnErr(err) {
+        mconn.mc_log.info(err, 'emitted error');
+    }
+    conn.on('error', onConnErr);
+    mconn.mc_errHandler = onConnErr;
 };
 
 /*
@@ -195,6 +220,26 @@ MorayConnectionPool.prototype.connDrain = function connDrain(key) {
     assert.ok(this.mcp_conns.hasOwnProperty(key));
     assert.ok(this.mcp_avail.hasOwnProperty(key));
 
+    /*
+     * If we're being asked to drain the very last connection in the set,
+     * delay processing this instruction. This gives us a chance to make new
+     * connections in a case where we have "flapped" from one set of records to
+     * another (e.g. DNS servers are returning inconsistent results).
+     *
+     * It's very hard to protect against this failure mode fully, but this
+     * heuristic does seem to help prevent it from failing requests.
+     */
+    if (Object.keys(this.mcp_avail).length <= 1) {
+        if (this.mcp_lastRemovalTimeout === undefined) {
+            var self = this;
+            this.mcp_lastRemovalTimeout = setTimeout(function () {
+                self.connDrain(key);
+            }, LAST_REMOVAL_DELAY);
+            return;
+        }
+    }
+    this.mcp_lastRemovalTimeout = undefined;
+
     /*
      * Remove the connection from service for new requests.
      */
@@ -227,5 +272,6 @@ MorayConnectionPool.prototype.connDelete = function (key) {
     delete (this.mcp_conns[key]);
 
     mconn.mc_log.info('removed connection');
-    mconn.mc_conn.destroy();
+    mconn.mc_conn.removeListener('error', mconn.mc_errHandler);
+    mconn.mc_hdl.release();
 };
diff --git a/package.json b/package.json
index 615e0a6..a0e528a 100644
--- a/package.json
+++ b/package.json
@@ -1,7 +1,7 @@
 {
     "name": "moray",
     "description": "Moray client library",
-    "version": "3.1.0",
+    "version": "3.1.1",
     "author": "Joyent (joyent.com)",
     "keywords": [ "moray" ],
     "main": "./lib/index.js",
@@ -14,8 +14,8 @@
         "backoff": "^2.4.1",
         "bunyan": "^1.3.2",
         "cmdutil": "^1.1.0",
-        "cueball": "^1.0.3",
-	"extsprintf": "^1.3.0",
+        "cueball": "^2.1.1",
+        "extsprintf": "^1.3.0",
         "fast": "^2.1.0",
         "libuuid": "0.2.1",
         "jsprim": "^1.3.0",
-- 
2.21.0

