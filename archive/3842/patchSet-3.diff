From ee605c6db4cea5b91222e8e13b01323aa1d6cd47 Mon Sep 17 00:00:00 2001
From: Cody Peter Mello <cody.mello@joyent.com>
Date: Tue, 17 Apr 2018 21:34:32 +0000
Subject: [PATCH] TRITON-265 Allow networks to have "linklocal" routes
 TRITON-293 Validate address family of updated "resolvers" and "routes"

---
 lib/models/network.js       | 243 +++++++++++++++++++++---------------
 lib/models/nic/obj.js       |  12 +-
 lib/models/nic/provision.js |   5 +-
 lib/models/nic/update.js    |   2 +-
 lib/util/constants.js       |   2 +
 lib/util/ip.js              |  37 +++++-
 lib/util/subnet.js          |  73 -----------
 test/config.json            |   1 +
 test/unit/networks.test.js  | 192 ++++++++++++++++++++++------
 9 files changed, 351 insertions(+), 216 deletions(-)
 delete mode 100644 lib/util/subnet.js

diff --git a/lib/models/network.js b/lib/models/network.js
index 9c267a1..d6d63f5 100644
--- a/lib/models/network.js
+++ b/lib/models/network.js
@@ -27,7 +27,6 @@ var restify = require('restify');
 var util = require('util');
 var util_common = require('../util/common');
 var util_ip = require('../util/ip');
-var util_subnet = require('../util/subnet');
 var UUID = require('node-uuid');
 var validate = require('../util/validate');
 var vasync = require('vasync');
@@ -172,6 +171,7 @@ var CREATE_SCHEMA = {
     },
     after: [
         validateFabricOwner,
+        validateAddressFamily,
         validateProvisionRange,
         validateNicTagMTU
     ]
@@ -211,6 +211,7 @@ var UPDATE_SCHEMA = {
     },
     after: [
         validateImmutableFields,
+        validateAddressFamily,
         validateProvisionRangeUpdate,
         validateNicTagMTU
     ]
@@ -248,6 +249,16 @@ var GET_SCHEMA = {
 
 
 
+function getKind(a) {
+    if (typeof (a.kind) === 'function') {
+        return a.kind();
+    }
+
+    return a.address().kind();
+}
+
+
+
 /**
  * Given a NIC, return a UsedBy error description for a 'nic',
  * suitable for an InUseError.
@@ -650,6 +661,101 @@ function validateImmutableFields(opts, _original, parsed, cb) {
 }
 
 
+function validateAddressFamily(_opts, params, parsed, callback) {
+    var subnetType;
+
+    if (params.network) {
+        subnetType = params.network.params.subnet.address().kind();
+    } else if (parsed.subnet_start) {
+        assert.object(parsed.subnet_start, 'parsed.subnet_start');
+        assert.number(parsed.subnet_bits, 'parsed.subnet_bits');
+        subnetType = parsed.subnet_start.kind();
+    } else if (parsed.family) {
+        subnetType = parsed.family;
+    } else {
+        callback(new Error('unable to determine subnet'));
+        return;
+    }
+
+    var errs = [];
+    var badResolvers = [];
+    var badRoutes = [];
+    var gateway = parsed.gateway || null;
+    var provisionEnd = parsed.provision_end_ip || null;
+    var provisionStart = parsed.provision_start_ip || null;
+    var routes = parsed.routes || null;
+
+    /*
+     * Check that provisioning ranges match the subnet type. If they don't, then
+     * we set the variable to null and skip later checks until we return all
+     * validation problems.
+     */
+    if (provisionStart !== null && provisionStart.kind() !== subnetType) {
+        errs.push(errors.invalidParam('provision_start_ip',
+            constants.msg.PROV_START_TYPE_MISMATCH));
+        provisionStart = null;
+    }
+
+    if (provisionEnd !== null && provisionEnd.kind() !== subnetType) {
+        errs.push(errors.invalidParam('provision_end_ip',
+            constants.msg.PROV_END_TYPE_MISMATCH));
+        provisionEnd = null;
+    }
+
+    // check that provisioning ranges are same network type
+    if (provisionStart !== null && provisionEnd !== null &&
+        provisionStart.kind() !== provisionEnd.kind()) {
+        errs.push(errors.invalidParam('provision_start_ip, provision_end_ip',
+            constants.msg.PROV_TYPES_MISMATCH));
+        provisionStart = null;
+        provisionEnd = null;
+    }
+
+    // check if gateway is of same network type as the subnet
+    if (gateway && gateway.kind() !== subnetType) {
+        errs.push(errors.invalidParam('gateway',
+            util.format(constants.SUBNET_GATEWAY_MISMATCH, subnetType)));
+
+        gateway = null;
+    }
+
+    // check all resolvers for any of the wrong network type
+    if (parsed.hasOwnProperty('resolvers')) {
+        for (var rr in parsed.resolvers) {
+            var resolver = parsed.resolvers[rr];
+            if (resolver.kind() !== subnetType) {
+                badResolvers.push(resolver.toString());
+            }
+        }
+    }
+
+    if (badResolvers.length > 0) {
+        errs.push(errors.invalidParam('resolvers',
+            util.format(constants.SUBNET_RESOLVER_MISMATCH, subnetType),
+            { 'invalid': badResolvers }));
+    }
+
+    // check all of the routes for bad destinations and gateways
+    if (routes !== null) {
+        for (var route in routes) {
+            var net =
+                util_ip.toIPAddr(route) || util_ip.toSubnet(route);
+            if (getKind(net) !== subnetType) {
+                badRoutes.push(route);
+            }
+        }
+    }
+
+    if (badRoutes.length > 0) {
+        errs.push(errors.invalidParam('routes',
+            util.format(constants.SUBNET_ROUTE_DST_MISMATCH, subnetType),
+            { 'invalid': badRoutes }));
+    }
+
+    callback(errs.length === 0 ? null : errs);
+}
+
+
 /**
  * Validates that all provision range params are present in an update request,
  * and if so validates the provision range.
@@ -696,8 +802,6 @@ function validateProvisionRange(opts, _, parsedParams, callback) {
     }
 
     var errs = [];
-    var badResolvers = [];
-    var badRoutes = [];
     var gateway = parsedParams.gateway;
     var provisionEnd = parsedParams.provision_end_ip;
     var provisionStart = parsedParams.provision_start_ip;
@@ -709,32 +813,6 @@ function validateProvisionRange(opts, _, parsedParams, callback) {
     assert.ok(subnet, 'subnet');
     parsedParams.subnet = subnet.toString();
 
-    // check that provisioning ranges match subnet type
-    // if they don't match, set variable to null and skip later checks
-    if (provisionStart.kind() !== subnetType) {
-        errs.push(errors.invalidParam('provision_start_ip',
-            constants.msg.PROV_START_TYPE_MISMATCH));
-        provisionStart = null;
-        delete parsedParams.provision_start_ip;
-    }
-    if (provisionEnd.kind() !== subnetType) {
-        errs.push(errors.invalidParam('provision_end_ip',
-            constants.msg.PROV_END_TYPE_MISMATCH));
-        provisionEnd = null;
-        delete parsedParams.provision_end_ip;
-    }
-
-    // check that provisioning ranges are same network type
-    if (provisionStart !== null && provisionEnd !== null &&
-        provisionStart.kind() !== provisionEnd.kind()) {
-        errs.push(errors.invalidParam('provision_start_ip, provision_end_ip',
-            constants.msg.PROV_TYPES_MISMATCH));
-        provisionStart = null;
-        provisionEnd = null;
-        delete parsedParams.provision_start_ip;
-        delete parsedParams.provision_end_ip;
-    }
-
     // check if provision range is within the subnet
     if (provisionStart !== null && !subnet.contains(provisionStart)) {
         errs.push(errors.invalidParam('provision_start_ip',
@@ -751,15 +829,6 @@ function validateProvisionRange(opts, _, parsedParams, callback) {
         delete parsedParams.provision_end_ip;
     }
 
-    // check if gateway is of same network type as the subnet
-    if (gateway && gateway.kind() !== subnetType) {
-        errs.push(errors.invalidParam('gateway',
-            util.format(constants.SUBNET_GATEWAY_MISMATCH, subnetType)));
-
-        gateway = null;
-        delete parsedParams.gateway;
-    }
-
     // check if gateway is within the subnet
     if (gateway && !subnet.contains(gateway)) {
         errs.push(errors.invalidParam('gateway', constants.GATEWAY_SUBNET_MSG));
@@ -768,44 +837,6 @@ function validateProvisionRange(opts, _, parsedParams, callback) {
         delete parsedParams.gateway;
     }
 
-    // check all resolvers for any of the wrong network type
-    if (parsedParams.hasOwnProperty('resolvers')) {
-        for (var rr in parsedParams.resolvers) {
-            var resolver = parsedParams.resolvers[rr];
-            if (resolver.kind() !== subnetType) {
-                badResolvers.push(resolver.toString());
-            }
-        }
-    }
-
-    if (badResolvers.length > 0) {
-        errs.push(errors.invalidParam('resolvers',
-            util.format(constants.SUBNET_RESOLVER_MISMATCH, subnetType),
-            { 'invalid': badResolvers }));
-    }
-
-    // check all of the routes for bad destinations and gateways
-    if (parsedParams.hasOwnProperty('routes')) {
-        for (var route in parsedParams.routes) {
-            var net =
-                util_ip.toIPAddr(route) || util_subnet.toNumberArray(route)[0];
-            if (net.kind() !== subnetType) {
-                badRoutes.push(route);
-            }
-
-            var gw = util_ip.toIPAddr(parsedParams.routes[route]);
-            if (gw.kind() !== subnetType) {
-                badRoutes.push(gw.toString());
-            }
-        }
-    }
-
-    if (badRoutes.length > 0) {
-        errs.push(errors.invalidParam('routes',
-            util.format(constants.SUBNET_ROUTE_DST_MISMATCH, subnetType),
-            { 'invalid': badRoutes }));
-    }
-
     // IPv4-only checks - broadcast address is reserved
     if (provisionStart && provisionStart.kind() === 'ipv4' &&
         provisionStart.compare(subnet.broadcast()) === 0) {
@@ -926,9 +957,10 @@ function validateProvisionRange(opts, _, parsedParams, callback) {
 /**
  * Validate a routes object
  */
-function validateRoutes(_, name, val, callback) {
+function validateRoutes(opts, name, val, callback) {
     if (typeof (val) !== 'object' || util.isArray(val)) {
-        return callback(errors.invalidParam(name, constants.msg.OBJ));
+        callback(errors.invalidParam(name, constants.msg.OBJ));
+        return;
     }
 
     var invalid = [];
@@ -936,16 +968,25 @@ function validateRoutes(_, name, val, callback) {
 
     for (var r in val) {
         var badVals = [];
-        var ipAddr = util_ip.toIPAddr(r);
-        var key;
-        var subnet = util_subnet.toNumberArray(r);
+        var dst, key;
 
-        if (!ipAddr && !subnet) {
+        dst = util_ip.toSubnet(r);
+        if (dst === null) {
+            dst = util_ip.toIPAddr(r);
+        }
+
+        if (dst === null) {
             badVals.push(r);
         }
 
-        var gateway = util_ip.toIPAddr(val[r]);
-        if (!gateway) {
+        var gateway;
+        if (opts.app.config.allowLinklocal && val[r] === 'linklocal') {
+            gateway = val[r];
+        } else {
+            gateway = util_ip.toIPAddr(val[r]);
+        }
+
+        if (gateway === null) {
             badVals.push(val[r]);
         }
 
@@ -954,27 +995,29 @@ function validateRoutes(_, name, val, callback) {
             continue;
         }
 
-        key = ipAddr ? ipAddr.toString() :
-            fmt('%s/%d', subnet[0].toString(), subnet[1]);
+        if (gateway !== 'linklocal' && gateway.kind() !== getKind(dst)) {
+            callback(errors.invalidParam(name,
+                constants.SUBNET_ROUTE_DST_NEXTHOP_MISMATCH,
+                { invalid: [ dst.toString(), gateway.toString() ] }));
+            return;
+        }
+
+        key = dst.toString();
+
         routes[key] = gateway;
     }
 
     if (invalid.length !== 0) {
-        var err = errors.invalidParam(name,
-            fmt('invalid route%s', invalid.length === 1 ? '' : 's'));
-        err.invalid = [];
-        invalid.forEach(function (i) {
-            i.forEach(function (b) {
-                err.invalid.push(b);
-            });
-        });
-
-        return callback(err);
+        callback(errors.invalidParam(name,
+            fmt('invalid route%s', invalid.length === 1 ? '' : 's'),
+            { invalid: Array.prototype.concat.apply([], invalid) }));
+        return;
     }
 
     var toReturn = {};
     toReturn[name] = routes;
-    return callback(null, null, toReturn);
+
+    callback(null, null, toReturn);
 }
 
 
@@ -1143,13 +1186,15 @@ function Network(params) {
         for (var r in routes) {
             var key;
             if (r.toString().indexOf('/') >= 0) {
-                key = util_subnet.toNumberArray(r).join('/');
+                key = util_ip.toSubnet(r).toString();
             } else {
                 key = util_ip.toIPAddr(r).toString();
             }
 
             // Fixup old route gateways that didn't get serialized.
-            this.params.routes[key] = util_ip.fixupIPAddr(routes[r]);
+            this.params.routes[key] = routes[r] === 'linklocal'
+                ? routes[r]
+                : util_ip.fixupIPAddr(routes[r]);
         }
     }
 
diff --git a/lib/models/nic/obj.js b/lib/models/nic/obj.js
index 9cde128..729c2f5 100644
--- a/lib/models/nic/obj.js
+++ b/lib/models/nic/obj.js
@@ -19,6 +19,7 @@ var BUCKET = require('./bucket').BUCKET;
 var constants = require('../../util/constants');
 var errors = require('../../util/errors');
 var fmt = require('util').format;
+var mod_jsprim = require('jsprim');
 var mod_mac = require('macaddr');
 var mod_moray = require('../../apis/moray');
 var mod_portolan_moray = require('portolan-moray');
@@ -56,7 +57,6 @@ var NET_PARAMS = [
     'netmask',
     'nic_tag',
     'resolvers',
-    'routes',
     'vlan_id'
 ];
 
@@ -456,6 +456,16 @@ Nic.prototype.serialize = function nicSerialize() {
                 serialized[NET_PARAMS[p]] = netSer[NET_PARAMS[p]];
             }
         }
+        if (netSer.hasOwnProperty('routes')) {
+            serialized.routes = {};
+            mod_jsprim.forEachKey(netSer.routes, function (dst, gw) {
+                if (gw === 'linklocal') {
+                    serialized.routes[dst] = fmt('macs[%s]', serialized.mac);
+                } else {
+                    serialized.routes[dst] = gw;
+                }
+            });
+        }
         serialized.network_uuid = netSer.uuid;
     }
 
diff --git a/lib/models/nic/provision.js b/lib/models/nic/provision.js
index 0092b63..402b523 100644
--- a/lib/models/nic/provision.js
+++ b/lib/models/nic/provision.js
@@ -716,7 +716,10 @@ function nicAndIP(opts, callback) {
             return;
         }
 
-        opts.log.info({ params: params, obj: res.serialize() }, 'Created nic');
+        opts.log.info({
+            params: opts.params,
+            obj: res.serialize()
+        }, 'Created nic');
 
         callback(null, res);
     });
diff --git a/lib/models/nic/update.js b/lib/models/nic/update.js
index a45e7eb..c94b7e7 100644
--- a/lib/models/nic/update.js
+++ b/lib/models/nic/update.js
@@ -308,7 +308,7 @@ function update(opts, callback) {
 
         opts.log.info({
             before: opts.existingNic.serialize(),
-            params: opts.validated,
+            params: opts.params,
             after: opts.nic.serialize()
         }, 'Updated nic');
 
diff --git a/lib/util/constants.js b/lib/util/constants.js
index 8532ffd..a5b1131 100644
--- a/lib/util/constants.js
+++ b/lib/util/constants.js
@@ -184,6 +184,8 @@ module.exports = {
     SUBNET_RESOLVER_MISMATCH: 'resolvers should match subnet type (%s)',
     SUBNET_ROUTE_DST_MISMATCH:
         'addresses used for routing should match subnet type (%s)',
+    SUBNET_ROUTE_DST_NEXTHOP_MISMATCH:
+        'address family of route and next-hop address should match',
     SUBNET_MIN_IPV4: 8,
     SUBNET_MIN_IPV6: 8,
     VLAN_MSG: 'VLAN ID must be a number between 0 and 4094, and not 1',
diff --git a/lib/util/ip.js b/lib/util/ip.js
index d1e184b..ad86147 100644
--- a/lib/util/ip.js
+++ b/lib/util/ip.js
@@ -14,6 +14,7 @@
 
 'use strict';
 
+var constants = require('./constants');
 var ipaddr = require('ip6addr');
 var net = require('net');
 
@@ -208,6 +209,39 @@ function netmaskToBits(netmask) {
 }
 
 
+/*
+ * Convert a string into an ip6addr CIDR object. This function handles input
+ * in two different forms:
+ *
+ * - Normal CIDR notation, like "192.168.0.0/16"
+ * - A long representation of the IPv4 prefix, "168427520/18"
+ */
+function toSubnet(subnetTxt) {
+    var subnet = subnetTxt.split('/');
+
+    if (subnet.length !== 2) {
+        return null;
+    }
+
+    var startIP = toIPAddr(subnet[0]);
+    var bits = Number(subnet[1]);
+
+    if (startIP === null) {
+        return null;
+    }
+
+    var minBits = startIP.kind() === 'ipv4'
+        ? constants.SUBNET_MIN_IPV4
+        : constants.SUBNET_MIN_IPV6;
+
+    if (isNaN(bits) || (bits < minBits) || (bits > 32)) {
+        return null;
+    }
+
+    return ipaddr.createCIDR(startIP, bits);
+}
+
+
 module.exports = {
     addressToNumber: addressToNumber,
     aton: addressToNumber,
@@ -221,5 +255,6 @@ module.exports = {
     netmaskToBits: netmaskToBits,
     numberToAddress: numberToAddress,
     ntoa: numberToAddress,
-    toIPAddr: toIPAddr
+    toIPAddr: toIPAddr,
+    toSubnet: toSubnet
 };
diff --git a/lib/util/subnet.js b/lib/util/subnet.js
deleted file mode 100644
index 2987b4f..0000000
--- a/lib/util/subnet.js
+++ /dev/null
@@ -1,73 +0,0 @@
-/*
- * This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/.
- */
-
-/*
- * Copyright (c) 2014, Joyent, Inc.
- */
-
-/*
- * Subnet-related utilities
- */
-
-'use strict';
-
-var constants = require('./constants');
-var util = require('util');
-var util_ip = require('./ip');
-
-
-function fromNumberArray(subnetTxt) {
-    var subnet = subnetTxt.split('/');
-
-    if (subnet.length !== 2) {
-        return null;
-    }
-
-    var startIP = util_ip.ntoa(subnet[0]);
-    var bits = Number(subnet[1]);
-
-    if (startIP === null) {
-        return null;
-    }
-
-    if (isNaN(bits) || (bits < constants.SUBNET_MIN) || (bits > 32)) {
-        return null;
-    }
-
-    return util.format('%s/%d', startIP, bits);
-}
-
-
-function toNumberArray(subnetTxt) {
-    var subnet = subnetTxt.split('/');
-
-    if (subnet.length !== 2) {
-        return null;
-    }
-
-    var startIP = util_ip.toIPAddr(subnet[0]);
-    var bits = Number(subnet[1]);
-
-    if (startIP === null) {
-        return null;
-    }
-
-    var minBits = startIP.kind() === 'ipv4' ? constants.SUBNET_MIN_IPV4 :
-        constants.SUBNET_MIN_IPV6;
-
-    if (isNaN(bits) || (bits < minBits) || (bits > 32)) {
-        return null;
-    }
-
-    return [startIP, bits];
-}
-
-
-
-module.exports = {
-    fromNumberArray: fromNumberArray,
-    toNumberArray: toNumberArray
-};
diff --git a/test/config.json b/test/config.json
index 5c3bc7f..18a6a3e 100644
--- a/test/config.json
+++ b/test/config.json
@@ -1,6 +1,7 @@
 {
   "//": "minimal NAPI config needed for unit tests",
 
+  "allowLinklocal": true,
   "datacenter": "unit-test",
   "macOUI": "010203",
   "overlay": {
diff --git a/test/unit/networks.test.js b/test/unit/networks.test.js
index 3c7cb74..1b1f835 100644
--- a/test/unit/networks.test.js
+++ b/test/unit/networks.test.js
@@ -24,6 +24,7 @@ var mod_ip = require('../../lib/models/ip');
 var mod_jsprim = require('jsprim');
 var mod_moray = require('../lib/moray');
 var mod_net = require('../lib/net');
+var mod_nic = require('../lib/nic');
 var mod_server = require('../lib/server');
 var mod_test_err = require('../lib/err');
 var mod_uuid = require('node-uuid');
@@ -91,55 +92,82 @@ test('Initial setup', function (t) {
 
 
 test('Create network', function (t) {
+    var num = h.NET_NUM;
+    var network = null;
     var params = h.validNetworkParams({
-        gateway: '10.0.2.1',
+        gateway: util.format('10.0.%d.1', num),
+        provision_start_ip: util.format('10.0.%d.3', num),
         resolvers: ['8.8.8.8', '10.0.2.2'],
         routes: {
+            '10.0.5.0/24': 'linklocal',
             '10.0.1.0/24': '10.0.2.2',
             '10.0.3.1': '10.0.2.2'
         }
     });
 
-    NAPI.createNetwork(params, function (err, obj, req, res) {
-        if (h.ifErr(t, err, 'network create')) {
-            t.end();
-            return;
-        }
+    t.test('create network', function (t2) {
+        mod_net.createAndGet(t2, {
+            params: params,
+            exp: mod_jsprim.mergeObjects(params, {
+                family: 'ipv4',
+                netmask: '255.255.255.0',
+                vlan_id: 0
+            })
+        });
+    });
 
-        t.equal(res.statusCode, 200, 'status code');
+    t.test('check ips', function (t2) {
+        network = mod_net.lastCreated();
 
-        params.family = 'ipv4';
-        params.uuid = obj.uuid;
-        params.netmask = '255.255.255.0';
-        params.vlan_id = 0;
+        vasync.forEachParallel({
+            inputs: ['10.0.2.1', '10.0.2.2', '10.0.2.255'],
+            func: function _compareIP(ip, cb) {
+                NAPI.getIP(network.uuid, ip, function (gErr, res) {
+                    if (h.ifErr(t2, gErr, 'getIP() error')) {
+                        cb();
+                        return;
+                    }
 
-        t.deepEqual(obj, params, 'response: network ' + params.uuid);
+                    t2.deepEqual(res, {
+                        belongs_to_type: 'other',
+                        belongs_to_uuid: CONF.ufdsAdminUuid,
+                        free: false,
+                        ip: ip,
+                        network_uuid: network.uuid,
+                        owner_uuid: CONF.ufdsAdminUuid,
+                        reserved: true
+                    }, util.format('IP %s params', ip));
 
-        NAPI.getNetwork(obj.uuid, function (err2, obj2) {
-            t.ifError(err2);
+                    cb();
+                });
+            }
+        }, function () {
+            t2.end();
+        });
+    });
 
-            t.deepEqual(obj2, obj, 'get response');
-            vasync.forEachParallel({
-                inputs: ['10.0.2.1', '10.0.2.2', '10.0.2.255'],
-                func: function _compareIP(ip, cb) {
-                    NAPI.getIP(obj.uuid, ip, function (err3, res3) {
-                        t.ifError(err3);
-                        t.deepEqual(res3, {
-                            belongs_to_type: 'other',
-                            belongs_to_uuid: CONF.ufdsAdminUuid,
-                            free: false,
-                            ip: ip,
-                            network_uuid: obj.uuid,
-                            owner_uuid: CONF.ufdsAdminUuid,
-                            reserved: true
-                        }, util.format('IP %s params', ip));
-
-                        return cb();
-                    });
-                }
-            }, function () {
-                return t.end();
-            });
+    t.test('create nic on network', function (t2) {
+        var nicparams = {
+            belongs_to_uuid: network.uuid,
+            belongs_to_type: 'zone',
+            owner_uuid: CONF.ufdsAdminUuid,
+            network_uuid: network.uuid,
+            primary: true,
+            state: 'running'
+        };
+
+        mod_nic.create(t2, {
+            mac: '01:02:03:03:02:01',
+            params: nicparams,
+            exp: mod_net.addNetParams(network,
+                mod_jsprim.mergeObjects(nicparams, {
+                    ip: h.nextProvisionableIP(network),
+                    routes: {
+                        '10.0.5.0/24': 'macs[01:02:03:03:02:01]',
+                        '10.0.1.0/24': '10.0.2.2',
+                        '10.0.3.1': '10.0.2.2'
+                    }
+                }))
         });
     });
 });
@@ -396,15 +424,19 @@ test('Create network - mixed networks', function (t) {
         ['resolvers', ['2001:4860:4860::8888', '8.8.4.4'], ['8.8.4.4'],
             util.format(constants.SUBNET_RESOLVER_MISMATCH, 'ipv6')],
 
-        ['routes', { '10.0.1.0/24': bad_dst }, [ '10.0.1.0/24' ],
-            util.format(constants.SUBNET_ROUTE_DST_MISMATCH, 'ipv6')],
+        ['routes', { '10.0.1.0/24': bad_dst }, [ '10.0.1.0/24', bad_dst ],
+            constants.SUBNET_ROUTE_DST_NEXTHOP_MISMATCH],
 
-        ['routes', { '10.0.1.0/24': '10.0.0.2' }, [ '10.0.1.0/24', '10.0.0.2' ],
+        ['routes', { '10.0.1.0/24': '10.0.0.2' }, [ '10.0.1.0/24' ],
             util.format(constants.SUBNET_ROUTE_DST_MISMATCH, 'ipv6')],
 
-        ['routes', { '2001:db8::/32': '10.0.0.1' }, [ '10.0.0.1' ],
+        ['routes', { '10.0.1.0/24': 'linklocal' }, [ '10.0.1.0/24' ],
             util.format(constants.SUBNET_ROUTE_DST_MISMATCH, 'ipv6')],
 
+        ['routes', { '2001:db8::/32': '10.0.0.1' },
+            [ '2001:db8::/32', '10.0.0.1' ],
+            constants.SUBNET_ROUTE_DST_NEXTHOP_MISMATCH],
+
         ['provision_start_ip', '10.0.0.3',
             constants.msg.PROV_START_TYPE_MISMATCH ],
 
@@ -454,6 +486,84 @@ test('Create network - mixed networks', function (t) {
     });
 });
 
+test('Update IPv6 network - mixed address families', function (t) {
+    // NET_NUM will be the next network number used by h.validNetworkParams():
+    var num = h.NET_NUM.toString(16);
+    var params = h.validIPv6NetworkParams();
+    var network = null;
+    var bad_dst = util.format('fc00:%s::2', num);
+
+    var invalid = [
+        ['gateway', '10.0.0.1',
+            util.format(constants.SUBNET_GATEWAY_MISMATCH, 'ipv6')],
+
+        ['resolvers', ['8.8.8.8', '8.8.4.4'], ['8.8.8.8', '8.8.4.4'],
+            util.format(constants.SUBNET_RESOLVER_MISMATCH, 'ipv6')],
+
+        ['resolvers', ['2001:4860:4860::8888', '8.8.4.4'], ['8.8.4.4'],
+            util.format(constants.SUBNET_RESOLVER_MISMATCH, 'ipv6')],
+
+        ['routes', { '10.0.1.0/24': bad_dst }, [ '10.0.1.0/24', bad_dst ],
+            constants.SUBNET_ROUTE_DST_NEXTHOP_MISMATCH],
+
+        ['routes', { '10.0.1.0/24': '10.0.0.2' }, [ '10.0.1.0/24' ],
+            util.format(constants.SUBNET_ROUTE_DST_MISMATCH, 'ipv6')],
+
+        ['routes', { '10.0.1.0/24': 'linklocal' }, [ '10.0.1.0/24' ],
+            util.format(constants.SUBNET_ROUTE_DST_MISMATCH, 'ipv6')],
+
+        ['routes', { '2001:db8::/32': '10.0.0.1' },
+            [ '2001:db8::/32', '10.0.0.1' ],
+            constants.SUBNET_ROUTE_DST_NEXTHOP_MISMATCH],
+
+        ['provision_start_ip', '10.0.0.3',
+            constants.msg.PROV_START_TYPE_MISMATCH ],
+
+        ['provision_end_ip', '10.0.0.253',
+            constants.msg.PROV_END_TYPE_MISMATCH ]
+    ];
+
+    function attemptUpdate(data, cb) {
+        var invalidErr;
+
+        if (data.length === 3) {
+            invalidErr = mod_err.invalidParam(data[0], data[2]);
+        } else {
+            invalidErr = mod_err.invalidParam(data[0], data[3]);
+            invalidErr.invalid = data[2];
+        }
+
+        var toUpdate = { uuid: network.uuid };
+        toUpdate[data[0]] = data[1];
+
+        mod_net.update(t, {
+            params: toUpdate,
+            expCode: 422,
+            expErr: h.invalidParamErr({
+                errors: [ invalidErr ],
+                message: 'Invalid parameters'
+            })
+        }, function (_) {
+            cb();
+        });
+    }
+
+    NAPI.createNetwork(params, function (err, res) {
+        if (h.ifErr(t, err, 'createNetwork() error')) {
+            t.end();
+            return;
+        }
+
+        network = res;
+
+        vasync.forEachPipeline({
+            inputs: invalid,
+            func: attemptUpdate
+        }, function () {
+            t.end();
+        });
+    });
+});
 
 
 test('Create fabric network - automatic gateway assignment', function (t) {
@@ -1639,6 +1749,8 @@ test('Listing Network failures', function (t) {
 
 // --- Teardown
 
+test('delete nics', mod_nic.delAllCreated);
+
 test('delete networks', mod_net.delAllCreated);
 
 test('Stop server', mod_server.close);
-- 
2.21.0

