commit 3f96ef87c63247591cd8c4cccddf055378689fe9 (refs/changes/48/2848/1)
Author: Julien Gilli <julien.gilli@joyent.com>
Date:   2017-10-24T15:00:40-07:00 (1 year, 11 months ago)
    
    ZAPI-805 VM.internal_metadata field should be searchable

diff --git a/docs/index.md b/docs/index.md
index 18d7c2d..b8fa95b 100644
--- a/docs/index.md
+++ b/docs/index.md
@@ -428,22 +428,23 @@ will result in a request error.
 
 | Param            | Type                                             | Description                                     |
 | ---------------- | ------------------------------------------------ | ----------------------------------------------- |
-| uuid             | UUID                                             | VM uuid                                         |
-| owner_uuid       | UUID                                             | VM Owner                                        |
-| server_uuid      | UUID                                             | Server where the VM lives                       |
-| image_uuid       | UUID                                             | Image of the VM                                 |
+| alias            | String                                           | VM Alias|
 | billing_id       | UUID                                             | UUID of the package the VM was created with     |
 | brand            | String                                           | Brand of the VM (joyent, joyent-minimal or kvm) |
-| docker           | Boolean                                          | true if the VM is a docker VM, false otherwise  |
-| alias            | String                                           | VM Alias                                        |
-| state            | String                                           | running, stopped, active or destroyed           |
-| ram              | Number                                           | Amount of memory of the VM                      |
-| uuids            | String (comma-separated UUID values)             | List of VM UUIDs to match                       |
 | create_timestamp | Unix Time in milliseconds or UTC ISO Date String | VM creation timestamp                           |
+| docker           | Boolean                                          | true if the VM is a docker VM, false otherwise  |
+| fields           | String (comma-separated values)                  | Specify which VM fields to return, see below    |
+| image_uuid       | UUID                                             | Image of the VM                                 |
+| internal_metadata| String                                           | VM internal metadata, see below
+| owner_uuid       | UUID                                             | VM Owner                                        |
 | package_name     | String                                           | DEPRECATED: use billing_id                      |
 | package_version  | String                                           | DEPRECATED: use billing_id                      |
+| uuid             | UUID                                             | VM uuid                                         |
+| ram              | Number                                           | Amount of memory of the VM                      |
+| server_uuid      | UUID                                             | Server where the VM lives                       |
+| state            | String                                           | running, stopped, active or destroyed           |
+| uuids            | String (comma-separated UUID values)             | List of VM UUIDs to match                       |
 | tag.key          | String                                           | VM tags, see below                              |
-| fields           | String (comma-separated values)                  | Specify which VM fields to return, see below    |
 
 ### Specifying VM Fields to Return
 
@@ -678,6 +679,24 @@ result in a request error.
 
 VMs can also be searched by tags. Tags are key/value pairs that let us identify a vm by client-specific criteria. If a VM is tagged as 'role=master', then the search filter to be added to the request params should be 'tag.role=master'. When a tag value is '*', the search is performed for VMs that are tagged with any value of the specified key. Any number of tags can be specified. See the examples section for sample searches of VMs by tags.
 
+### Internal metadata
+
+VMs can be searched by internal metadata. Internal metadata is an object with
+keys and values that are always strings. There's no nested objects/properties.
+Matching needs to be exact, pattern matching is not available.
+
+For example, to search for VMs with a `docker:logdriver` internal metadata key
+with a value of `"json-file"`, one can send the following query:
+
+```
+GET /vms?internal_metadata.docker:logdriver=json-file
+```
+
+There's one limitation to keep in mind: it is currently not possible to match a
+string in a given internal metadata key that is larger than 100 characters. As a
+result, when trying to match such a string, one has to truncate it to its 100
+first characters beforehand.
+
 ### ListVms Responses
 
 | Code | Description | Response            |
diff --git a/lib/apis/moray.js b/lib/apis/moray.js
index c314a3d..f8179db 100644
--- a/lib/apis/moray.js
+++ b/lib/apis/moray.js
@@ -39,18 +39,17 @@ var verror = require('verror');
 var errors = require('../errors');
 var common = require('../common');
 
-var SELECT_ALL_FILTER = '(uuid=*)';
-var PARAM_FILTER = '(%s=%s)';
-var PARAM_FILTER_GE = '(%s>=%s)';
-var PARAM_FILTER_LE = '(%s<=%s)';
-var PARAM_FILTER_NE = '(!(%s=%s))';
-
 // Fields that are deprecated that we're going to remove from VMs as we put
 var DEPRECATED_VM_FIELDS = [
     'package_name',
     'package_version'
 ];
-
+var PARAM_FILTER = '(%s=%s)';
+var PARAM_FILTER_GE = '(%s>=%s)';
+var PARAM_FILTER_LE = '(%s<=%s)';
+var PARAM_FILTER_NE = '(!(%s=%s))';
+var SELECT_ALL_FILTER = '(uuid=*)';
+var VM_OBJECTS_DATA_VERSION = 1;
 
 /*
  * The constructor for the Moray class.
@@ -421,11 +420,44 @@ Moray.prototype._vmsListParams = function (params, cb) {
     }
 
     this._addTagsFilter(params, filter);
+    _addInternalMetadataFilter(params, filter);
 
     return cb(null, filter);
 };
 
+/*
+ * Augments the LDAP filter "filter" with a filter that represents any
+ * internal_metadata search parameter in "params". We consider that any
+ * validation on such parameters already took place, and thus we consider these
+ * parameters valid.
+ */
+function _addInternalMetadataFilter(params, filter) {
+    assert.object(params, 'params');
+    assert.arrayOfString(filter, 'filter');
 
+    var FILTER_KEY = 'internal_metadata_search_array';
+    var idx;
+    var metadataKey;
+    var metadataValue;
+    var paramNames = Object.keys(params);
+    var paramName;
+
+    for (idx = 0; idx < paramNames.length; ++idx) {
+        paramName = paramNames[idx];
+        if (paramName.indexOf('internal_metadata.') !== -1) {
+            /*
+             * At this point we already validated that the internal_metadata
+             * query string parameter is well formed, so it's fine to parse it
+             * without handling bad formats.
+             */
+            metadataKey = paramName.split('.')[1];
+            metadataValue = params[paramName];
+
+            filter.push(sprintf(PARAM_FILTER, FILTER_KEY,
+                metadataKey + '=' + metadataValue));
+        }
+    }
+}
 /*
  * This is a bit different to getVm.
  * For this one we need exactly the VM that has the provided UUID
@@ -745,7 +777,7 @@ Moray.prototype.putVm = function putVm(uuid, vm, oldVm, cb) {
     oldVm = common.translateVm(oldVm, false);
     vm = common.translateVm(vm, false);
 
-    self.log.debug({oldVm: oldVm, vm: vm}, 'putting VM');
+    self.log.debug({vmObject: vmObject, oldVm: oldVm, vm: vm}, 'putting VM');
 
     self._morayClient.putObject(self._VMS_BUCKET_NAME, uuid, vmObject,
         function onPutObj(putObjErr) {
@@ -1316,6 +1348,16 @@ Moray.prototype._toMorayVm = function (vm) {
         }
     }
 
+    /*
+     * Massage the internal_metadata object and write it to the indexed
+     * internal_metadadata_search_array field in a format that is searchable.
+     */
+    assert.optionalObject(vm.internal_metadata, 'vm.internal_metadata');
+    copy.internal_metadata_search_array =
+        common.internalMetadataToSearchArray(vm.internal_metadata);
+
+    copy.data_version = VM_OBJECTS_DATA_VERSION;
+
     return copy;
 };
 
@@ -1510,4 +1552,162 @@ Moray.prototype.reindexBuckets =
     });
 };
 
+/*
+ * Finds all VM records that need to be changed to be migrated to version
+ * "version".
+ *
+ * @param {Number} version: must be >= 1.
+ *
+ * @param {Object} options:
+ *   - log {Object}: the bunyan log instance to use to output log messages.
+ *
+ * @param {Function} callback: called with two parameters: (error, records)
+ *   where "error" is any error that occurred when trying to find those records,
+ *   and "records" is an array of objects representing VM objects that need to
+ *   be changed to be migrated to version "version".
+ */
+Moray.prototype.findVmRecordsToMigrate =
+function findVmRecordsToMigrate(version, options, callback) {
+    assert.number(version, 'version');
+    assert.ok(version >= 1, 'version >= 1');
+    assert.object(options, 'options');
+    assert.object(options.log, 'options.log');
+    assert.func(callback, 'callback');
+
+    var log = options.log;
+    var morayFilter;
+    var records = [];
+    var RETRY_DELAY_IN_MS = 10000;
+    var self = this;
+
+    /*
+     * !!!! WARNING !!!!
+     *
+     *  When updating these LDAP filters, make sure that they don't break the
+     * assumption below that an InvalidQueryError can be treated as a transient
+     * error.
+     *
+     * !!!! WARNING !!!!
+     */
+    if (version === 1) {
+        /*
+         * Version 1 is special, in the sense that there's no anterior version
+         * for which data_version has a value. Instead, the version before
+         * version 1 is represented by an absence of value for the data_version
+         * field.
+         */
+        morayFilter = '(!(data_version=*))';
+    } else {
+        /*
+         * For any migration whose version number is greater than one, they only
+         * migrate records at version N - 1. This is safe because:
+         *
+         * 1. all new records created are created at the latest version
+         *    supported by VMAPI
+         *
+         * 2. migrations are always done in sequence, starting from the
+         *    migration that migrates records without a data_version to records
+         *    with a data_version === 1.
+         */
+        morayFilter = util.format('(|(!(data_version=*))(data_version=%s))',
+            version - 1);
+    }
+
+    log.debug({filter: morayFilter, version: version},
+        'generated LDAP filter to find records at version less than given ' +
+            'version');
+
+    /*
+     * It would be useful to pass either the requireIndexes: true or
+     * requireOnlineReindexing: true options to findObjects here, as that would
+     * allow us to make sure that we can actually rely on the results from this
+     * query. However:
+     *
+     * 1. We don't want to rely on a specific version of the Moray server.
+     *    Support for these options is fairly new (see
+     *    http://smartos.org/bugview/MORAY-104 and
+     *    http://smartos.org/bugview/MORAY-428) and being able to perform data
+     *    migrations is a basic requirement of the service, so we don't want to
+     *    prevent that from happening if Moray was rolled back in a DC to a
+     *    version that doesn't support those flags. Moreover, at the time data
+     *    migrations were added, the latest version of the manta-moray image in
+     *    the "support" channel of updates.joyent.com did not include MORAY-104
+     *    or MORAY-428.
+     *
+     * 2. Since this filter uses only one field, Moray already has a mechanism
+     *    that will return an InvalidQueryError in case this field is not
+     *    indexed, which effectively acts similarly to those two different
+     *    options mentioned above.
+     */
+    var req = this._morayClient.findObjects(this._VMS_BUCKET_NAME, morayFilter);
+
+    req.once('error', function onRecordsNotAtVersionError(err) {
+        log.error({error: err}, 'Error when finding objects');
+
+        if (err && verror.hasCauseWithName(err, 'InvalidQueryError')) {
+            /*
+             * We treat InvalidQueryError here as a transient error and retry
+             * when it occurs because:
+             *
+             * 1. We know that the LDAP filter passed to the findObjects request
+             *    uses only one field, and that field was added with the same
+             *    code change than this code.
+             *
+             * 2. We know that data migrations are run *after* reindexing of all
+             *    buckets is completed and successful.
+             *
+             * As a result, we can rely on this field being indexed and
+             * searchable, and we know that an InvalidQueryError is returned by
+             * the Moray server only when the bucket cache of the Moray instance
+             * that responded has not been refreshed yet.
+             */
+            log.info('Scheduling retry in ' + RETRY_DELAY_IN_MS + ' ms');
+            setTimeout(function retry() {
+                log.info({version: version},
+                        'Retrying to find records at version less than');
+                self.findVmRecordsToMigrate(version, options, callback);
+            }, RETRY_DELAY_IN_MS);
+        }
+    });
+
+    req.on('record', function onRecord(record) {
+        records.push(record);
+    });
+
+    req.once('end', function onEnd() {
+        callback(null, records);
+    });
+};
+
+/*
+ * Generates a Moray batch request to PUT all objects in the array of objects
+ * "records", and call "callback" when it's done.
+ *
+ * @params {ArrayOfObjects} records
+ * @params {Function} callback(err)
+ */
+Moray.prototype.putVmsBatch = function putVmsBatch(records, callback) {
+    assert.arrayOfObject(records, 'records');
+    assert.func(callback, 'callback');
+
+    var self = this;
+
+    this._morayClient.batch(records.map(function generateVmPutBatch(record) {
+        return {
+            bucket: self._VMS_BUCKET_NAME,
+            operation: 'put',
+            key: record.value.uuid,
+            value: record.value,
+            etag: record._etag
+        };
+    }), function onBatch(batchErr, meta) {
+        /*
+         * We don't care about the data in "meta" for now (the list of etags
+         * resulting from writing all records), and adding it later would be
+         * backward compatible.
+         */
+        callback(batchErr);
+    });
+};
+
 module.exports = Moray;
diff --git a/lib/common/index.js b/lib/common/index.js
index 3ff088a..153aaf7 100644
--- a/lib/common/index.js
+++ b/lib/common/index.js
@@ -29,8 +29,9 @@ function mixinModule(modulePath) {
     }
 }
 
+mixinModule('./ldap-filter');
+mixinModule('./marker');
+mixinModule('./predicate');
 mixinModule('./util');
 mixinModule('./validation');
 mixinModule('./vm-common');
-mixinModule('./predicate');
-mixinModule('./marker');
diff --git a/lib/common/ldap-filter.js b/lib/common/ldap-filter.js
new file mode 100644
index 0000000..dcd7541
--- /dev/null
+++ b/lib/common/ldap-filter.js
@@ -0,0 +1,34 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2014, Joyent, Inc.
+ */
+
+var assert = require('assert-plus');
+
+/*
+ * Returns true if the LDAP filter string "ldapFilterString" represents an LDAP
+ * filter that filters on the field with name "fieldName".
+ */
+function ldapFilterFiltersOn(fieldName, ldapFilterString) {
+    var fieldPresentRegexp;
+
+    assert.string(fieldName, 'fieldName');
+    assert.optionalString(ldapFilterString, 'ldapFilterString');
+
+    if (ldapFilterString === undefined) {
+        return false;
+    }
+
+    fieldPresentRegexp = new RegExp('(' + fieldName + '=');
+
+    return fieldPresentRegexp.test(ldapFilterString);
+}
+
+module.exports = {
+    ldapFilterFiltersOn: ldapFilterFiltersOn
+};
\ No newline at end of file
diff --git a/lib/common/predicate.js b/lib/common/predicate.js
index b572fbd..544400c 100644
--- a/lib/common/predicate.js
+++ b/lib/common/predicate.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2014, Joyent, Inc.
+ * Copyright (c) 2017, Joyent, Inc.
  */
 
 /*
@@ -13,8 +13,10 @@
  * predicate object
  */
 
-var ASSERT = require('assert').ok;
+var assert = require('assert-plus');
+var krill = require('krill');
 var util = require('util');
+
 var format = util.format;
 
 /*
@@ -212,6 +214,9 @@ function ldapPrintRel(pred, key) {
             if (typeof (field) === 'string' &&
                 field.match(/tag\.(.*)/)) {
                 string = printTags(field, pred[key][1]);
+            } else if (typeof (field) === 'string' &&
+                field.match(/internal_metadata\.(.*)/)) {
+                string = printInternalMetadata(field, pred[key][1]);
             } else {
                 string = printKeyValue(key, field, pred[key][1]);
             }
@@ -254,6 +259,17 @@ function printTags(field, value) {
     }
 }
 
+function printInternalMetadata(field, value) {
+    assert.string(field, 'field');
+    assert.string(value, 'value');
+
+    var match = field.match(/internal_metadata\.(.*)/);
+    var metadataKey = match[1];
+
+    return format('internal_metadata_search_array=%s',
+        metadataKey + '=' + value);
+}
+
 function printKeyValue(key, k, v) {
     return k + printStrings[key] + v;
 }
@@ -303,12 +319,12 @@ function ldapPrintGen(pred)
     }
 
     if (keysFound != 1)
-        ASSERT(false, console.log('Expected only ' +
+        assert.ok(false, util.format('Expected only ' +
             'one key for the specified predicate. Found %d. Looking ' +
             'at predicate %j', keysFound, pred));
 
     if (!ldapPrintFuncs[key])
-        ASSERT(false, console.log('Missing print ' +
+        assert.ok(false, util.format('Missing print ' +
             'function for key %s. Looking at predicate %j', key,
             pred));
 
@@ -330,3 +346,52 @@ function toLdapQuery(pred)
 }
 
 exports.toLdapQuery = toLdapQuery;
+
+/*
+ * Returns true if the JSON predicate represented by "predicateString" filters
+ * on the field with name "fieldName".
+ *
+ * @params {String} fieldName
+ *
+ * @params {String} predicateString
+ *
+ * @params {ArrayOfString} polymorphicParams - an array of field names that
+ *   should be considered polymorphic. A polymorphic field name is a name that
+ *   that is used in the following form: "field_name.key=value", where the
+ *   string "key" is not static, and can change from one query to another.
+ */
+function jsonPredicateFiltersOn(fieldName, predicateString, polymorphicParams) {
+    assert.string(fieldName, 'fieldName');
+    assert.optionalString(predicateString, 'predicateString');
+    assert.optionalArrayOfString(polymorphicParams, 'polymorphicParams');
+
+    var idx;
+    var krillPred;
+    var predFields;
+    var parsedJSONPred;
+    var res = false;
+
+    try {
+        parsedJSONPred = JSON.parse(predicateString);
+    } catch (parseErr) {
+        return false;
+    }
+
+    krillPred = krill.createPredicate(parsedJSONPred);
+    predFields = krillPred.fields();
+
+    if (polymorphicParams && polymorphicParams.indexOf(fieldName) !== -1) {
+        for (idx = 0; idx < predFields.length; ++idx) {
+            if (predFields[idx].indexOf(fieldName + '.') === 0) {
+                res = true;
+                break;
+            }
+        }
+    } else {
+        res = predFields.indexOf(fieldName) !== -1;
+    }
+
+    return res;
+}
+
+exports.jsonPredicateFiltersOn = jsonPredicateFiltersOn;
\ No newline at end of file
diff --git a/lib/common/validation.js b/lib/common/validation.js
index 828e900..561c6e7 100644
--- a/lib/common/validation.js
+++ b/lib/common/validation.js
@@ -29,25 +29,23 @@ var markerUtils = require('./marker');
 var predicateUtils = require('./predicate');
 var sortValidation = require('../validation/sort');
 
-var UUID_RE = /^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$/;
 var ALIAS_RE = /^[a-zA-Z0-9][a-zA-Z0-9\_\.\-]*$/;
-var RAM_RE = /^0$|^([1-9][0-9]*$)/;
-var TRITON_TAG_ROOT_RE = /^triton\./;
 /* JSSTYLED */
 var DOCKER_TAG_DEFAULT_RE = /^(?:sdc_docker$|docker:label:triton\.|docker:label:(?:com|io|org)\.docker(?:project)?\.)/;
-
+var DOCKER_TAG_RE = DOCKER_TAG_DEFAULT_RE;
 // For now, using the more limited labels allowed by RFC1123. RFC2181 supercedes
 // 1123, but the broader range of characters can sometimes cause problems with
 // other systems (e.g. see the underscore in RFC5321).
 var DNS_NAME_RE = /^[a-z0-9][a-z0-9\-]{0,62}(?:\.[a-z0-9][a-z0-9\-]{0,62})*$/i;
-
+var INTERNAL_METADATA_SEARCH_KEY_RE = /^[a-z_]+\:[a-z_]+$/;
 /*JSSTYLED*/
 var IP_RE = /^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])$/;
+var MAX_LIST_VMS_LIMIT = 1000;
 var PW_SUFFIX = /^(.*)_pw$/;
+var RAM_RE = /^0$|^([1-9][0-9]*$)/;
+var TRITON_TAG_ROOT_RE = /^triton\./;
+var UUID_RE = /^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$/;
 
-var DOCKER_TAG_RE = DOCKER_TAG_DEFAULT_RE;
-
-var MAX_LIST_VMS_LIMIT = 1000;
 exports.MAX_LIST_VMS_LIMIT = MAX_LIST_VMS_LIMIT;
 
 var VALID_VM_BRANDS = [
@@ -697,21 +695,63 @@ function createValidateTimestampFn(field, options) {
     };
 }
 
-function createValidateTagFn(options) {
+function validateInternalMetadataValue(metadataKey, metadataValue) {
+    assert.optionalString(metadataKey, 'metadataKey');
+    assert.optionalString(metadataValue, 'metadataValue');
+
+    if (typeof (metadataKey) !== 'string' ||
+        !INTERNAL_METADATA_SEARCH_KEY_RE.test(metadataKey)) {
+        return errors.invalidParamErr('internal_metadata',
+            'Invalid internal_metadata key: ' + JSON.stringify(metadataKey));
+    }
+
+    if (typeof (metadataValue) !== 'string' || metadataValue.length === 0) {
+        return errors.invalidParamErr('internal_metadata',
+            'Invalid internal_metadata value: ' +
+                JSON.stringify(metadataValue));
+    }
+}
+
+function validateTagValue(tagName, tagValue) {
+    assert.optionalString(tagName, 'tagName');
+    assert.optionalString(tagValue, 'tagValue');
+
+    if (typeof (tagName) !== 'string' || tagName.length === 0) {
+        return errors.invalidParamErr('tag', 'Invalid tag name: ' + tagName);
+    }
+    if (typeof (tagValue) !== 'string' || tagValue.length === 0) {
+        return errors.invalidParamErr('tag', 'Invalid tag value: ' + tagValue);
+    }
+}
+
+function createValidatePolymorphicParamFn(options) {
     options = options || {};
     assert.object(options, 'options');
+    assert.string(options.paramName, options.paramName);
+    assert.func(options.validationFunc, 'options.validationFunc');
 
-    return function (params) {
-        var errs = [];
-        var paramName;
-        var tagValue;
+    var paramNameToTest = options.paramName;
+    var validationFunc = options.validationFunc;
 
-        for (paramName in params) {
-            if (validatorName(paramName) === 'tag') {
-                tagValue = params[paramName];
-                if (typeof (tagValue) !== 'string') {
-                    errs.push(errors.invalidParamErr(paramName,
-                        'Invalid tag: ' + tagValue));
+    return function validatePolymorphicParam(params) {
+        var errs = [];
+        var validationErr;
+        /*
+         * E.g 'tag.some_tag_name' or 'internal_metadata.docker:cmd'.
+         */
+        var fullyQualifiedPramName;
+        var paramKey;
+        var paramValue;
+
+        for (fullyQualifiedPramName in params) {
+            paramKey = polymorphicParamKey(fullyQualifiedPramName);
+
+            if (polymorphicParamName(fullyQualifiedPramName) ===
+                paramNameToTest) {
+                paramValue = params[fullyQualifiedPramName];
+                validationErr = validationFunc(paramKey, paramValue);
+                if (validationErr) {
+                    errs.push(validationErr);
                 }
             }
         }
@@ -1410,30 +1450,37 @@ function validateListVmsParams(params, callback) {
     async.series([
         function validateSingleParams(next) {
             var listVmValidators = {
-                owner_uuid: createValidateUUIDFn('owner_uuid'),
-                server_uuid: createValidateUUIDFn('server_uuid'),
-                uuid: createValidateUUIDFn('uuid'),
-                uuids: createValidateCSVFn('uuids', validUUID),
-                brand: createValidateStringsListFn('brand', VALID_VM_BRANDS),
                 alias: createValidateStringFn('alias', {re: ALIAS_RE}),
-                state: createValidateStringsListFn('state', VALID_VM_STATES),
-                ram: createValidateStringFn('ram', {re: RAM_RE}),
-                predicate: createValidateJSONPredicateFn('predicate'),
-                query: createValidateStringFn('query'),
-                docker: createValidateBooleanFn('docker'),
-                image_uuid: createValidateUUIDFn('image_uuid'),
                 billing_id: createValidateUUIDFn('billing_id'),
+                brand: createValidateStringsListFn('brand', VALID_VM_BRANDS),
                 create_timestamp: createValidateTimestampFn('create_timestamp'),
-                package_name: createValidateStringFn('package_name'),
-                package_version: createValidateStringFn('package_version'),
+                docker: createValidateBooleanFn('docker'),
                 fields: createValidateVmFieldsFn('fields'),
-                tag: createValidateTagFn(),
-                sort: createValidateSortFn('sort'),
+                image_uuid: createValidateUUIDFn('image_uuid'),
+                internal_metadata: createValidatePolymorphicParamFn({
+                    paramName: 'internal_metadata',
+                    validationFunc: validateInternalMetadataValue
+                }),
                 limit: createValidateNumberFn('limit',
                     {min: 1, max: MAX_LIST_VMS_LIMIT}),
-                offset: createValidateNumberFn('offset'),
                 marker: createValidateMarkerFn('marker',
-                    {sortParamName: 'sort'})
+                    {sortParamName: 'sort'}),
+                offset: createValidateNumberFn('offset'),
+                owner_uuid: createValidateUUIDFn('owner_uuid'),
+                package_name: createValidateStringFn('package_name'),
+                package_version: createValidateStringFn('package_version'),
+                predicate: createValidateJSONPredicateFn('predicate'),
+                query: createValidateStringFn('query'),
+                ram: createValidateStringFn('ram', {re: RAM_RE}),
+                server_uuid: createValidateUUIDFn('server_uuid'),
+                sort: createValidateSortFn('sort'),
+                state: createValidateStringsListFn('state', VALID_VM_STATES),
+                tag: createValidatePolymorphicParamFn({
+                    paramName: 'tag',
+                    validationFunc: validateTagValue
+                }),
+                uuid: createValidateUUIDFn('uuid'),
+                uuids: createValidateCSVFn('uuids', validUUID)
             };
 
             return validateParams(listVmValidators, params, {strict: true},
@@ -2337,7 +2384,7 @@ function validateParams(customValidators, params, options, callback) {
                 continue;
             }
 
-            customValidatorName = validatorName(paramName);
+            customValidatorName = polymorphicParamName(paramName);
             customValidator = customValidators[customValidatorName];
             if (!customValidator)
                 validationErrors.push(new errors.invalidParamErr(paramName));
@@ -2363,10 +2410,19 @@ function validateParams(customValidators, params, options, callback) {
  * that use a dot to separate the parameter name "tag" from the tag key will
  * return "tag", and not "tag.key".
  */
-function validatorName(paramName) {
-    assert.string(paramName, 'paramName');
+function polymorphicParamName(paramString) {
+    assert.string(paramString, 'paramString');
 
-    return paramName.split('.')[0];
+    return paramString.split('.')[0];
+}
+
+function polymorphicParamKey(paramString) {
+    assert.string(paramString, 'paramString');
+
+    var paramStringCompoments = paramString.split('.');
+    if (paramStringCompoments.length === 2) {
+        return paramStringCompoments[1];
+    }
 }
 
 function validVmField(field) {
@@ -2384,3 +2440,19 @@ function isSortOrderDescending(order) {
 }
 exports.isSortOrderDescending = isSortOrderDescending;
 exports.DEFAULT_SORT_ORDER = 'DESC';
+
+function hasPolymorphicParamWithName(fieldName, params) {
+    assert.string(fieldName, 'fieldName');
+    assert.object(params, 'params');
+
+    var paramName;
+    var polymorphicParamRegexp = new RegExp('^' + fieldName + '\..*');
+    for (paramName in params) {
+        if (polymorphicParamRegexp.test(paramName)) {
+            return true;
+        }
+    }
+
+    return false;
+}
+exports.hasPolymorphicParamWithName = hasPolymorphicParamWithName;
\ No newline at end of file
diff --git a/lib/common/vm-common.js b/lib/common/vm-common.js
index 427cd93..0af3d17 100644
--- a/lib/common/vm-common.js
+++ b/lib/common/vm-common.js
@@ -8,7 +8,7 @@
  * Copyright 2016 Joyent, Inc.
  */
 
-var assert = require('assert');
+var assert = require('assert-plus');
 var restify = require('restify');
 var strsplit = require('strsplit');
 
@@ -464,3 +464,78 @@ exports.getStatuses = function (vms) {
 
     return status;
 };
+
+function clampString(value, maxChars) {
+    assert.string(value, 'value');
+    assert.number(maxChars, 'maxChars');
+
+    if (value.length > maxChars) {
+        return value.substr(0, maxChars);
+    }
+
+    return value;
+}
+
+/*
+ * Generates an array of string that represents the data in the internal
+ * metadata object "internalMetadata" in a format that makes it storable in a
+ * moray indexed field that makes it searchable.
+ *
+ * There are a couple of things to keep in mind regarding that conversion:
+ *
+ * 1. We rely on the guarantee (see http://smartos.org/bugview/PROV-1113) that
+ *    internal metadata values are strings, and so there's no need to convert
+ *    some values to strings to make them searchable.
+ *
+ * 2. We intentionally truncate all values to make them fit under an arbitrary
+ *    length to avoid storing potentially huge values (e.g docker:env or
+ *    docker:cmd data) that would impact Moray performance negatively. As a
+ *    result the search facilities provided for internal metadata is best effort
+ *    only.
+ */
+exports.internalMetadataToSearchArray =
+function internalMetadataToSearchArray(internalMetadata) {
+    assert.optionalObject(internalMetadata, 'internalMetadata');
+
+    var MAX_METADATA_VALUE_LENGTH = 100;
+    var metadataKey;
+    var metadataValue;
+    /*
+     * Using filters on array indexes with null values is not supported in
+     * Moray (see https://smartos.org/bugview/MORAY-450), so we manually set
+     * the internal_metadata_search_array value to the empty array when the
+     * VM object has a no internal_metadata value.
+     */
+    var searchArray = [];
+
+    if (internalMetadata) {
+        for (metadataKey in internalMetadata) {
+            if (!internalMetadata.hasOwnProperty(metadataKey)) {
+                continue;
+            }
+
+            metadataValue = internalMetadata[metadataKey];
+            switch (typeof (metadataValue)) {
+                case 'string':
+                    metadataValue = clampString(metadataValue,
+                            MAX_METADATA_VALUE_LENGTH);
+                    break;
+                case 'number':
+                case 'boolean':
+                    metadataValue = metadataValue.toString();
+                    break;
+                case 'object':
+                    metadataValue = clampString(JSON.stringify(metadataValue),
+                        MAX_METADATA_VALUE_LENGTH);
+                    break;
+                default:
+                    metadataValue = '';
+                    break;
+            }
+
+            searchArray.push(metadataKey + '=' + metadataValue);
+        }
+    }
+
+    return searchArray;
+};
\ No newline at end of file
diff --git a/lib/data-migrations/controller.js b/lib/data-migrations/controller.js
new file mode 100644
index 0000000..73113af
--- /dev/null
+++ b/lib/data-migrations/controller.js
@@ -0,0 +1,260 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+
+var assert = require('assert-plus');
+var backoff = require('backoff');
+var EventEmitter = require('events');
+var util = require('util');
+var vasync = require('vasync');
+var VError = require('verror');
+
+var dataMigrations = require('./migrations');
+
+function DataMigrationsController(migrations, options) {
+    assert.arrayOfObject(migrations, 'migrations');
+    assert.object(options, 'options');
+    assert.object(options.log, 'options.log');
+    assert.object(options.moray, 'options.moray');
+
+    EventEmitter.call(this);
+
+    this.latestCompletedMigration = undefined;
+    this.log = options.log;
+    this.migrations = migrations;
+    this.moray = options.moray;
+
+    _validateMigrations(migrations);
+}
+util.inherits(DataMigrationsController, EventEmitter);
+
+/*
+ * Validates that all data migrations that need to be performed are valid. For
+ * instance, that their DATA_VERSION numbers are a proper sequence starting at
+ * 1, and that they export a function named "migrateRecord".
+ */
+function _validateMigrations(migrations) {
+    assert.arrayOfObject(migrations, 'migrations');
+
+    var idxMigration;
+    var expectedDataVersion = 1;
+
+    for (idxMigration = 0; idxMigration < migrations.length; ++idxMigration) {
+        assert.equal(migrations[idxMigration].DATA_VERSION, expectedDataVersion,
+            'Data version of migration ' + (idxMigration + 1) + ' should be ' +
+                expectedDataVersion);
+        assert.func(migrations[idxMigration].migrateRecord,
+                'MIGRATIONS[' + idxMigration + '].migrateRecord');
+        ++expectedDataVersion;
+    }
+}
+
+function dataMigrationErrorTransient(error) {
+    assert.object(error, 'error');
+
+    var idx;
+    var nonTransientErrors = [
+        /*
+         * For now, we consider a bucket not found to be a non-transient error
+         * because it's not clear how that error would resolve itself by
+         * retrying the data migrations process.
+         */
+        'BucketNotFoundError',
+        'InvalidIndexTypeError',
+        'InvalidQueryError',
+        'NoDatabasePeersError',
+        /*
+         * We consider NotIndexedError errors to be non-transient because data
+         * migrations happen *after any schema migration, including reindexing
+         * of all affected buckets* is considered to be complete. As a result,
+         * when data migrations start, the indexes that are present will not
+         * change, and so retrying on such an error would lead to the same error
+         * occurring.
+         */
+        'NotIndexedError',
+        /*
+         * Unless a specific data migration handles a UniqueAttributeError
+         * itself, we consider that retrying that migration would have the same
+         * result, so we treat it as a non-transient error.
+         */
+        'UniqueAttributeError'
+    ];
+
+    for (idx = 0; idx < nonTransientErrors.length; ++idx) {
+        if (VError.hasCauseWithName(error, nonTransientErrors[idx])) {
+            return false;
+        }
+    }
+
+    return true;
+}
+
+DataMigrationsController.prototype.start = function start() {
+    var dataMigrationsBackoff = backoff.exponential();
+    var self = this;
+
+    dataMigrationsBackoff.on('backoff',
+        function onDataMigrationBackoff(number, delay) {
+            self.log.info('Data migration backed off, will retry in ' + delay +
+                ' ms');
+        });
+
+    dataMigrationsBackoff.on('ready', function onMigrationReady(number, delay) {
+        self._runMigrations(function migrationsRan(dataMigrationErr) {
+            if (dataMigrationErr) {
+                self.log.error({err: dataMigrationErr},
+                    'Error when running data migrations');
+
+                if (dataMigrationErrorTransient(dataMigrationErr)) {
+                    self.log.info('Error is transient, backing off');
+                    dataMigrationsBackoff.backoff();
+                } else {
+                    self.log.error('Error is not transient, emitting ' +
+                        'error');
+                    self.emit('error', dataMigrationErr);
+                }
+            } else {
+                self.log.info('All data migrations ran successfully');
+                dataMigrationsBackoff.reset();
+                self.emit('done');
+            }
+        });
+    });
+
+    dataMigrationsBackoff.backoff();
+};
+
+DataMigrationsController.prototype._runMigrations =
+function _runMigrations(callback) {
+    assert.object(this.log, 'this.log');
+    assert.object(this.moray, 'this.moray');
+    assert.func(callback, 'callback');
+
+    var log = this.log;
+    var moray = this.moray;
+    var self = this;
+
+    log.info('Starting data migrations');
+    self.latestCompletedMigration = undefined;
+
+    vasync.forEachPipeline({
+        func: function runSingleMigration(migration, next) {
+            var migrateRecordFunc = migration.migrateRecord;
+
+            assert.func(migrateRecordFunc, 'migrateRecordFunc');
+            assert.number(migration.DATA_VERSION, 'migration.DATA_VERSION');
+            assert.ok(migration.DATA_VERSION >= 1,
+                    'migration.DATA_VERSION >= 1');
+
+            log.info('Running migration to data version: ' +
+                migration.DATA_VERSION);
+
+            _runSingleMigration(migration.DATA_VERSION, migrateRecordFunc, {
+                log: log,
+                moray: moray
+            }, function onMigration(migrationErr) {
+                if (migrationErr) {
+                    log.error({err: migrationErr},
+                        'Error when running migration to data version: ' +
+                            migration.DATA_VERSION);
+                } else {
+                    self.latestCompletedMigration = migration.DATA_VERSION;
+                    log.info('Data migration to data version: ' +
+                        migration.DATA_VERSION + ' ran successfully');
+                }
+
+                next(migrationErr);
+            });
+        },
+        inputs: self.migrations
+    }, function onAllMigrationsDone(migrationsErr, results) {
+        var err;
+
+        if (migrationsErr) {
+            err = new VError(migrationsErr, 'Failed to run data migrations');
+        }
+
+        callback(err);
+    });
+};
+
+function _runSingleMigration(version, migrateRecordFunc, options, callback) {
+    assert.number(version, 'version');
+    assert.ok(version >= 1, 'version >= 1');
+    assert.func(migrateRecordFunc, 'migrateRecordFunc');
+    assert.object(options, 'options');
+    assert.object(options.log, 'options.log');
+    assert.object(options.moray, 'options.moray');
+    assert.func(callback, 'callback');
+
+    var context = {};
+    var log = options.log;
+    var moray = options.moray;
+
+    function processNextChunk() {
+        vasync.pipeline({arg: context, funcs: [
+            function findRecordsToMigrate(ctx, next) {
+                moray.findVmRecordsToMigrate(version, {
+                    log: log
+                }, function onFindRecords(findErr, records) {
+                    if (findErr) {
+                        log.error({err: findErr},
+                            'Error when finding records not at version: ' +
+                                version);
+                    } else {
+                        log.info('Found ' + records.length + ' records');
+                        ctx.records = records;
+                    }
+
+                    next(findErr);
+                });
+            },
+            function migrateRecords(ctx, next) {
+                var migratedRecords;
+                var records = ctx.records;
+
+                assert.arrayOfObject(records, 'records');
+
+                if (records.length === 0) {
+                    next();
+                    return;
+                }
+
+                migratedRecords = records.map(migrateRecordFunc);
+                log.info({migratedRecords: migratedRecords},
+                        'Migrated records');
+
+                moray.putVmsBatch(migratedRecords, next);
+            }
+        ]}, function onChunkProcessed(chunkProcessingErr) {
+            var records = context.records;
+
+            if (chunkProcessingErr) {
+                log.error({err: chunkProcessingErr},
+                        'Error when processing chunk');
+                callback(chunkProcessingErr);
+                return;
+            }
+
+            if (!records || records.length === 0) {
+                log.info('No more records at version: ' + version +
+                    ', migration done');
+                callback();
+            } else {
+                log.info('Processed ' + records.length + ' records, ' +
+                    'scheduling processing of next chunk');
+                setImmediate(processNextChunk);
+            }
+        });
+    }
+
+    processNextChunk();
+}
+
+module.exports = DataMigrationsController;
\ No newline at end of file
diff --git a/lib/data-migrations/index.js b/lib/data-migrations/index.js
new file mode 100644
index 0000000..f9e39ef
--- /dev/null
+++ b/lib/data-migrations/index.js
@@ -0,0 +1,61 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+
+var assert = require('assert-plus');
+var fs = require('fs');
+var path = require('path');
+var vasync = require('vasync');
+
+var DataMigrationsController = require('./controller');
+
+var DEFAULT_MIGRATIONS_DIR = path.join(__dirname, 'migrations');
+
+function loadMigrations(migrationsDirPath, callback) {
+    var context = {};
+
+    if (typeof (migrationsDirPath) === 'function') {
+        callback = migrationsDirPath;
+        migrationsDirPath = undefined;
+    }
+
+    assert.optionalString(migrationsDirPath, 'migrationsDirPath');
+    assert.func(callback, 'callback');
+
+    if (migrationsDirPath === undefined) {
+        migrationsDirPath = DEFAULT_MIGRATIONS_DIR;
+    }
+
+    vasync.pipeline({arg: context, funcs: [
+        function readMigrationsDir(ctx, next) {
+            fs.readdir(migrationsDirPath,
+                function onDirRead(dirReadErr, migrationFiles) {
+                    ctx.migrationFiles = migrationFiles;
+                    next(dirReadErr);
+                });
+        },
+        function loadMigrationModules(ctx, next) {
+            assert.arrayOfString(ctx.migrationFiles, 'ctx.migrationFiles');
+
+            ctx.migrations =
+                ctx.migrationFiles.map(function loadModule(migrationFile) {
+                    return require(path.join(migrationsDirPath, migrationFile));
+                });
+
+            next();
+        }
+    ]}, function onMigrationsLoaded(err, results) {
+        callback(err, context.migrations);
+    });
+}
+
+module.exports = {
+    DataMigrationsController: DataMigrationsController,
+    loadMigrations: loadMigrations
+};
\ No newline at end of file
diff --git a/lib/data-migrations/migrations/internal-metadata-search.js b/lib/data-migrations/migrations/internal-metadata-search.js
new file mode 100644
index 0000000..0a3c42f
--- /dev/null
+++ b/lib/data-migrations/migrations/internal-metadata-search.js
@@ -0,0 +1,55 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+
+/*
+ * This data migration is used to allow searching on the internal_metadata
+ * property of VM objects. It reads the content of the internal_metadata
+ * property of each VM object, and writes it to an indexed
+ * "internal_metadata_search_array" property in a way that is searchable.
+ */
+
+var assert = require('assert-plus');
+var common = require('../../common');
+
+var DATA_VERSION = 1;
+
+function migrateRecord(record) {
+    var parsedInternalMetadata;
+    var recordValue;
+
+    assert.object(record, 'record');
+    assert.object(record.value, 'record.value');
+
+    recordValue = record.value;
+
+    if (recordValue.data_version !== undefined) {
+        return;
+    }
+
+    if (recordValue.internal_metadata !== null &&
+        recordValue.internal_metadata !== undefined) {
+        assert.string(record.value.internal_metadata,
+            'record.value.internal_metadata');
+
+        parsedInternalMetadata = JSON.parse(recordValue.internal_metadata);
+    }
+
+    recordValue.internal_metadata_search_array =
+        common.internalMetadataToSearchArray(parsedInternalMetadata);
+
+    recordValue.data_version = DATA_VERSION;
+
+    return record;
+}
+
+module.exports = {
+    migrateRecord: migrateRecord,
+    DATA_VERSION: DATA_VERSION
+};
\ No newline at end of file
diff --git a/lib/endpoints/vms.js b/lib/endpoints/vms.js
index 46b3257..7c59cfa 100644
--- a/lib/endpoints/vms.js
+++ b/lib/endpoints/vms.js
@@ -181,7 +181,6 @@ function preFilterVms(req, res, next) {
     });
 }
 
-
 /*
  * GET /vms
  *
@@ -190,6 +189,38 @@ function preFilterVms(req, res, next) {
 function listVms(req, res, next) {
     req.log.trace('ListVms start');
 
+    function checkInternalMetadataSearchAvailable(done) {
+        var err;
+        var INTERNAL_METADATA_SEARCH_DATA_VER = 1;
+        var internalMetadataSearchUsed;
+        var latestCompletedDataMigration =
+            req.app.getLatestCompletedDataMigration();
+        var LIST_VMS_POLYMORPHIC_PARAMS = ['internal_metadata', 'tags'];
+
+        internalMetadataSearchUsed =
+            common.hasPolymorphicParamWithName('internal_metadata',
+                req.params) ||
+            common.jsonPredicateFiltersOn('internal_metadata',
+                req.params.predicate, LIST_VMS_POLYMORPHIC_PARAMS) ||
+            common.ldapFilterFiltersOn('internal_metadata_search_array',
+                req.params.query);
+
+        req.log.debug({
+            latestCompletedDataMigration: latestCompletedDataMigration,
+            params: req.params
+        }, 'Checking if searching on internal_metadata is available');
+
+        if (internalMetadataSearchUsed &&
+            (latestCompletedDataMigration === undefined ||
+                latestCompletedDataMigration <
+                    INTERNAL_METADATA_SEARCH_DATA_VER)) {
+            err = new errors.DataVersionError(INTERNAL_METADATA_SEARCH_DATA_VER,
+                latestCompletedDataMigration, 'internal_metadata search');
+        }
+
+        done(err);
+    }
+
     function validateParams(done) {
         req.log.trace({params: req.params}, 'validating request params');
 
@@ -253,7 +284,11 @@ function listVms(req, res, next) {
         });
     }
 
-    async.series([validateParams, list], function allDone(err) {
+    async.series([
+        validateParams,
+        checkInternalMetadataSearchAvailable,
+        list
+    ], function allDone(err) {
         if (err)
             req.log.debug({err: err});
         return next(err);
diff --git a/lib/errors.js b/lib/errors.js
index 230c649..3308ac5 100644
--- a/lib/errors.js
+++ b/lib/errors.js
@@ -264,4 +264,31 @@ function InvalidIndexesRemovalError(indexes) {
     this.message = 'Invalid removal of indexes: ' + indexes.join(', ');
 }
 util.inherits(InvalidIndexesRemovalError, Error);
-exports.InvalidIndexesRemovalError = InvalidIndexesRemovalError;
\ No newline at end of file
+exports.InvalidIndexesRemovalError = InvalidIndexesRemovalError;
+
+function DataVersionError(requiredVersion, actualVersion, featureDesc) {
+    var message;
+
+    assert.number(requiredVersion, 'requiredVersion');
+    assert.optionalNumber(actualVersion, 'actualVersion');
+    assert.string(featureDesc, 'featureDesc');
+
+    message = 'Data not at required version ' + requiredVersion +
+        ' to support ' + featureDesc + '. Current data version is: ' +
+        actualVersion;
+
+    restify.ServiceUnavailableError.call(this, {
+        restCode: this.constructor.restCode,
+        statusCode: this.constructor.statusCode,
+        message: message,
+        body: {
+            code: this.constructor.restCode,
+            message: message
+        }
+    });
+}
+util.inherits(DataVersionError, Error);
+DataVersionError.prototype.name = 'DataVersionError';
+DataVersionError.restCode = 'DataVersion';
+DataVersionError.statusCode = 503;
+exports.DataVersionError = DataVersionError;
\ No newline at end of file
diff --git a/lib/moray/moray-buckets-config.js b/lib/moray/moray-buckets-config.js
index e17927d..5d3ad7a 100644
--- a/lib/moray/moray-buckets-config.js
+++ b/lib/moray/moray-buckets-config.js
@@ -25,10 +25,12 @@ var VMS_BUCKET_CONFIG = {
             alias: { type: 'string' },
             max_physical_memory: { type: 'number' },
             create_timestamp: { type: 'number' },
-            docker: { type: 'boolean' }
+            docker: { type: 'boolean' },
+            internal_metadata_search_array: { type: '[string]' },
+            data_version: { type: 'number' }
         },
         options: {
-            version: 1
+            version: 2
         }
     }
 };
diff --git a/lib/vmapi.js b/lib/vmapi.js
index 1083edb..f3544c9 100644
--- a/lib/vmapi.js
+++ b/lib/vmapi.js
@@ -117,6 +117,9 @@ function VmapiApp(options) {
 
     this.options = options;
 
+    assert.object(options.dataMigrationCtrl, 'options.dataMigrationCtrl');
+    this.dataMigrationCtrl = options.dataMigrationCtrl;
+
     validations.init(options);
     this._initApis(options);
 }
@@ -388,6 +391,14 @@ VmapiApp.prototype.listen = function (options, callback) {
     });
 };
 
+VmapiApp.prototype.getLatestCompletedDataMigration =
+function getLatestCompletedDataMigration() {
+    if (this.dataMigrationCtrl === undefined) {
+        return;
+    }
+
+    return this.dataMigrationCtrl.latestCompletedMigration;
+};
 
 
 /*
diff --git a/package.json b/package.json
index 565d77b..9ca7905 100644
--- a/package.json
+++ b/package.json
@@ -15,6 +15,7 @@
     "deep-diff": "0.3.3",
     "effluent-logger": "git+https://github.com/joshwilsdon/effluent-logger.git#d662f161a07f94045ad2afb45442931511c40e51",
     "jsprim": "^1.2.2",
+    "krill": "1.0.1",
     "ldap-filter": "0.3.3",
     "libuuid": "0.2.1",
     "moray": "3.1.1",
diff --git a/server.js b/server.js
index d999891..2b7ff15 100644
--- a/server.js
+++ b/server.js
@@ -33,8 +33,12 @@ var VmapiApp = require('./lib/vmapi');
 var WFAPI = require('./lib/apis/wfapi');
 
 var configLoader = require('./lib/config-loader');
+var dataMigrations = require('./lib/data-migrations');
 var morayInit = require('./lib/moray/moray-init.js');
 
+var DATA_MIGRATIONS;
+var DataMigrationsController = dataMigrations.DataMigrationsController;
+var dataMigrationCtrl;
 var morayBucketsInitializer;
 var morayClient;
 var moray;
@@ -152,6 +156,23 @@ function startVmapiService() {
                 next();
             });
         },
+        function loadDataMigrations(_, next) {
+            vmapiLog.info('Loading data migrations modules');
+
+            dataMigrations.loadMigrations(
+                function onMigrationsLoaded(migrationsLoadErr, migrations) {
+                    if (migrationsLoadErr) {
+                        vmapiLog.error({err: migrationsLoadErr},
+                                'Error when loading data migrations modules');
+                    } else {
+                        vmapiLog.info('Loaded data migrations modules ' +
+                            'successfully!');
+                    }
+
+                    DATA_MIGRATIONS = migrations;
+                    next(migrationsLoadErr);
+                });
+        },
         function initMorayApi(_, next) {
             assert.object(changefeedPublisher, 'changefeedPublisher');
 
@@ -181,6 +202,33 @@ function startVmapiService() {
              */
             next();
         },
+        function startDataMigrations(_, next) {
+            assert.arrayOfObject(DATA_MIGRATIONS, 'DATA_MIGRATIONS');
+
+            dataMigrationCtrl = new DataMigrationsController(DATA_MIGRATIONS, {
+                log: vmapiLog.child({
+                    component: 'migrations-controller'
+                }, true),
+                moray: moray
+            });
+
+            /*
+             * We purposedly start data migrations *only when all buckets are
+             * updated and reindexed*. Otherwise, if we we migrated records that
+             * have a value for a field for which a new index was just added,
+             * moray could discard that field when fetching the object using
+             * findObjects or getObject requests (See
+             * http://smartos.org/bugview/MORAY-104 and
+             * http://smartos.org/bugview/MORAY-428). We could thus migrate
+             * those records erroneously, and in the end write bogus data.
+             */
+            morayBucketsInitializer.on('done',
+                function onMorayBucketsInitialized() {
+                    dataMigrationCtrl.start();
+                });
+
+            next();
+        },
         function connectToWfApi(_, next) {
             apiClients.wfapi.connect();
             /*
@@ -201,17 +249,18 @@ function startVmapiService() {
             process.exitCode = 1;
         } else {
             var vmapiApp = new VmapiApp({
-                version: config.version,
-                log: vmapiLog.child({ component: 'http-api' }, true),
-                serverConfig: {
-                    bindPort: config.api.port
-                },
                 apiClients: apiClients,
                 changefeedPublisher: changefeedPublisher,
-                morayBucketsInitializer: morayBucketsInitializer,
+                dataMigrationCtrl: dataMigrationCtrl,
+                log: vmapiLog.child({ component: 'http-api' }, true),
                 moray: moray,
+                morayBucketsInitializer: morayBucketsInitializer,
                 overlay: config.overlay,
-                reserveKvmStorage: config.reserveKvmStorage
+                reserveKvmStorage: config.reserveKvmStorage,
+                serverConfig: {
+                    bindPort: config.api.port
+                },
+                version: config.version
             });
 
             vmapiApp.listen();
diff --git a/test/vms.list-filter-internal-metadata.test.js b/test/vms.list-filter-internal-metadata.test.js
new file mode 100644
index 0000000..d4241a8
--- /dev/null
+++ b/test/vms.list-filter-internal-metadata.test.js
@@ -0,0 +1,250 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+
+var assert = require('assert-plus');
+var async = require('async');
+var bunyan = require('bunyan');
+var Logger = require('bunyan');
+var restify = require('restify');
+var util = require('util');
+
+var changefeedUtils = require('../lib/changefeed');
+var common = require('./common');
+var morayInit = require('../lib/moray/moray-init');
+var validation = require('../lib/common/validation');
+var vmTest = require('./lib/vm');
+
+var longMetadataValue = Buffer.alloc(101, 'a');
+longMetadataValue.write('b', 100, 1);
+
+var client;
+var moray;
+var morayClient;
+
+var testLogger = bunyan.createLogger({
+    name: 'test-internal-metadata',
+    level: 'debug',
+    serializers: restify.bunyan.serializers
+});
+
+exports.setUp = function (callback) {
+    common.setUp(function (err, _client) {
+        assert.ifError(err);
+        assert.ok(_client, 'restify client');
+        client = _client;
+        callback();
+    });
+};
+
+exports.init_storage_layer = function (t) {
+    var morayBucketsInitializer;
+
+    var moraySetup = morayInit.startMorayInit({
+        morayConfig: common.config.moray,
+        maxBucketsReindexAttempts: 1,
+        maxBucketsSetupAttempts: 1,
+        changefeedPublisher: changefeedUtils.createNoopCfPublisher()
+    });
+
+    morayBucketsInitializer = moraySetup.morayBucketsInitializer;
+    morayClient = moraySetup.morayClient;
+    moray = moraySetup.moray;
+
+    morayBucketsInitializer.on('done', function onMorayStorageReady() {
+        t.done();
+    });
+};
+
+exports.cleanup_leftover_test_vms = function (t) {
+    vmTest.deleteTestVMs(moray, {}, function onTestVmsDeleted(delTestVmsErr) {
+        t.ifError(delTestVmsErr, 'Deleting test VMs should not error');
+        t.done();
+    });
+};
+
+exports.list_invalid_empty_metadata_key = function (t) {
+    var expectedError = {
+        code: 'ValidationFailed',
+        message: 'Invalid Parameters',
+        errors: [ {
+            field: 'internal_metadata',
+            code: 'Invalid',
+            message: 'Invalid internal_metadata key: ""'
+        } ]
+    };
+    var listVmsQuery = '/vms?internal_metadata.=foo';
+
+    client.get(listVmsQuery, function onListVms(err, req, res, body) {
+        t.ok(err,
+            'listing VMs using invalid internal_metadata key should error');
+        if (err) {
+            t.deepEqual(body, expectedError, 'Error should be equal to ' +
+                expectedError + ', got: ' + err);
+        }
+
+        t.done();
+    });
+};
+
+exports.list_invalid_metadata_key = function (t) {
+    var expectedError = {
+        code: 'ValidationFailed',
+        message: 'Invalid Parameters',
+        errors: [ {
+            field: 'internal_metadata',
+            code: 'Invalid',
+            message: 'Invalid internal_metadata key: "bar"'
+        } ]
+    };
+    var listVmsQuery = '/vms?internal_metadata.bar=foo';
+
+    client.get(listVmsQuery, function onListVms(err, req, res, body) {
+        t.ok(err,
+            'listing VMs using invalid internal_metadata key should error');
+        if (err) {
+            t.deepEqual(body, expectedError, 'Error should be equal to ' +
+                expectedError + ', got: ' + err);
+        }
+
+        t.done();
+    });
+};
+
+
+exports.list_invalid_metadata_value = function (t) {
+    var expectedError = {
+        code: 'ValidationFailed',
+        message: 'Invalid Parameters',
+        errors: [ {
+            field: 'internal_metadata',
+            code: 'Invalid',
+            message: 'Invalid internal_metadata value: ""'
+        } ]
+    };
+    var listVmsQuery = '/vms?internal_metadata.foo:bar=';
+
+    client.get(listVmsQuery, function onListVms(err, req, res, body) {
+        t.ok(err,
+            'listing VMs using invalid internal_metadata key should error');
+        if (err) {
+            t.deepEqual(body, expectedError, 'Error should be equal to ' +
+                expectedError + ', got: ' + err);
+        }
+
+        t.done();
+    });
+};
+
+exports.create_test_vm_records = function (t) {
+    vmTest.createTestVMs(1, moray,
+        {concurrency: 1, log: testLogger},
+        {internal_metadata: {'some:key': 'foo'}},
+            function fakeVmsCreated(err, vmUuids) {
+                t.ifError(err, 'Creating test VM should not error');
+                t.done();
+            });
+};
+
+exports.list_valid_internal_metadata = function (t) {
+    var listVmsQuery = '/vms?internal_metadata.some:key=foo';
+
+    client.get(listVmsQuery, function onListVms(err, req, res, body) {
+        t.ifError(err,
+            'Listing VMs using valid internal_metadata filter should not ' +
+                'error');
+        t.ok(body, 'response should not be empty');
+        if (body) {
+            t.equal(body.length, 1, 'Response should include just one VM');
+        }
+
+        t.done();
+    });
+};
+
+exports.list_valid_internal_metadata_with_predicate = function (t) {
+    var listVmsQuery;
+    var predicate = JSON.stringify({
+        eq: ['internal_metadata.some:key', 'foo']
+    });
+
+    listVmsQuery = '/vms?predicate=' + predicate;
+
+    client.get(listVmsQuery, function onListVms(err, req, res, body) {
+        t.ifError(err,
+            'Listing VMs using valid internal_metadata predicate should not ' +
+                'error');
+        t.ok(body, 'response should not be empty');
+        if (body) {
+            t.equal(body.length, 1, 'Response should include just one VM');
+        }
+
+        t.done();
+    });
+};
+
+exports.create_test_vm_records_with_long_metadata_value = function (t) {
+    vmTest.createTestVMs(1, moray,
+        {concurrency: 1, log: testLogger},
+        {internal_metadata: {'some:key': longMetadataValue.toString()}},
+            function fakeVmsCreated(err, vmUuids) {
+                t.ifError(err, 'Creating test VM should not error');
+                t.done();
+            });
+};
+
+exports.list_long_internal_metadata = function (t) {
+    var listVmsQuery;
+    var queryMetadataValue = longMetadataValue.toString();
+
+    listVmsQuery = '/vms?internal_metadata.some:key=' + queryMetadataValue;
+
+    client.get(listVmsQuery, function onListVms(err, req, res, body) {
+        t.ifError(err,
+            'Listing VMs using valid internal_metadata filter should not ' +
+                'error');
+        t.ok(body, 'response should not be empty');
+        if (body) {
+            t.equal(body.length, 0, 'Response should not include any VM');
+        }
+
+        t.done();
+    });
+};
+
+exports.list_long_internal_metadata_with_shorter_value = function (t) {
+    var clampedMetadataValue = longMetadataValue.slice(0, 100).toString();
+    var listVmsQuery = '/vms?internal_metadata.some:key=' +
+        clampedMetadataValue;
+
+    client.get(listVmsQuery, function onListVms(err, req, res, body) {
+        t.ifError(err,
+            'Listing VMs using valid internal_metadata filter should not ' +
+                'error');
+        t.ok(body, 'response should not be empty');
+        if (body) {
+            t.equal(body.length, 1, 'Response should include just one VM');
+        }
+
+        t.done();
+    });
+};
+
+exports.cleanup_test_vms = function (t) {
+    vmTest.deleteTestVMs(moray, {}, function onTestVmsDeleted(delTestVmsErr) {
+        t.ifError(delTestVmsErr, 'Deleting test VMs should not error');
+        t.done();
+    });
+};
+
+exports.close_clients = function (t) {
+    morayClient.close();
+    client.close();
+    t.done();
+};
\ No newline at end of file
diff --git a/tools/jsl.node.conf b/tools/jsl.node.conf
index 8bf9239..60a5944 100644
--- a/tools/jsl.node.conf
+++ b/tools/jsl.node.conf
@@ -119,6 +119,7 @@
 +define require
 +define setInterval
 +define setTimeout
++define setImmediate
 +define Buffer
 +define JSON
 +define Math
