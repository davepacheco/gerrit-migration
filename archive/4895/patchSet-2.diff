commit 54ba7b9764e4c125e90f62fed94699992b759548 (refs/changes/95/4895/2)
Author: Josh Wilsdon <josh@wilsdon.ca>
Date:   2018-10-10T21:10:23-07:00 (12 months ago)
    
    TRITON-805 node-vmadm should support dummy vminfod

diff --git a/lib/index.dummy.js b/lib/index.dummy.js
index eb3940b..e43cad2 100644
--- a/lib/index.dummy.js
+++ b/lib/index.dummy.js
@@ -239,10 +239,43 @@ DummyVmadm.prototype.create = function vmCreate(opts, callback) {
         payload.uuid = uuidv4();
     }
 
-    payload.state = 'running';
-    payload.autoboot = true;
+    if (!payload.hasOwnProperty('autoboot')) {
+        payload.autoboot = true;
+    }
+
+    if (payload.autoboot === true) {
+        payload.state = 'running';
+    } else {
+        payload.state = 'stopped';
+    }
+
     payload.create_timestamp = (new Date()).toISOString();
 
+    // Fill in some fields vmadm adds by default
+    if (!payload.hasOwnProperty('cpu_shares')) {
+        payload.cpu_shares = 100;
+    }
+    if (!payload.hasOwnProperty('max_lwps')) {
+        payload.max_lwps = 2000;
+    }
+    if (!payload.hasOwnProperty('max_physical_memory')) {
+        if (payload.hasOwnProperty('ram')) {
+            payload.max_physical_memory = payload.ram;
+        } else {
+            payload.max_physical_memory = 256;
+        }
+    }
+    if (!payload.hasOwnProperty('max_locked_memory')) {
+        payload.max_locked_memory = payload.max_physical_memory;
+    }
+    if (!payload.hasOwnProperty('max_swap')) {
+        payload.max_swap = payload.max_physical_memory;
+    }
+
+    if (['bhyve', 'kvm'].indexOf(payload.brand) === -1) {
+        delete payload.ram;
+    }
+
     // TODO:
     //
     //   strip out properties we don't care about, validate ones we do.
@@ -298,9 +331,24 @@ DummyVmadm.prototype.delete = function vmDelete(opts, callback) {
 
                     cb();
                 });
+            }, function _validateDelete(_, cb) {
+                // If self has a property deleteValidator, we expect that to be
+                // a function that will return after verifying that the delete
+                // has fully completed. This is used for the dummy vminfod for
+                // example, to ensure that a delete has been seen by the event
+                // watchers.
+                if (self._deleteValidator === undefined) {
+                    cb();
+                    return;
+                }
+
+                self._deleteValidator(opts.uuid, cb);
             }
         ]
     }, function _onDeleted(err) {
+        if (err && err.code === 'ENOENT') {
+            err.restCode = 'VmNotFound';
+        }
         self.log.info({err: err, uuid: opts.uuid}, 'delete VM');
         callback(err);
     });
@@ -309,7 +357,7 @@ DummyVmadm.prototype.delete = function vmDelete(opts, callback) {
 /**
  * Call `vmadm update`.
  *
- * @param opts {Object} VMADM update payload
+ * @param opts {Object} vmadm update payload
  *      - include_dni {Boolean} If true, update VMs that have do_not_inventory
  *        set. default: false.
  * @param callback {Function} `function (err)`
@@ -323,7 +371,6 @@ DummyVmadm.prototype.update = function vmUpdate(opts, callback) {
     var self = this;
     var payload = opts;
     var req_id = opts.req_id;
-    var routes;
 
     delete payload.log;
     delete payload.req_id;
@@ -340,10 +387,17 @@ DummyVmadm.prototype.update = function vmUpdate(opts, callback) {
     }, function _onLoad(err, vmobj) {
         var idx;
         var modified = false;
+        var routes;
         var SIMPLE_UPDATES = [
             'alias',
+            'autoboot',
+            'billing_id',
+            'image_uuid',
             'resolvers'
         ];
+        var snaptime;
+        var snapshots;
+        var tags;
 
         if (err) {
             callback(err);
@@ -354,6 +408,9 @@ DummyVmadm.prototype.update = function vmUpdate(opts, callback) {
          * For now we support updating:
          *
          *  - alias
+         *  - autoboot
+         *  - billing_id
+         *  - image_uuid
          *  - resolvers
          *
          *  - add_nics
@@ -363,6 +420,16 @@ DummyVmadm.prototype.update = function vmUpdate(opts, callback) {
          *  - set_routes
          *  - remove_routes
          *
+         *  - set_tags
+         *  - remove_tags
+         *
+         * These are not part of the node-vmadm interface normally, but are here
+         * as helpers for other internal functions:
+         *
+         *  - _add_snapshot      -- used by vmadm.create_snapshot
+         *  - _del_snapshot      -- used by vmadm.delete_snapshot
+         *  - _rollback_snapshot -- used by vmadm.rollback_snapshot
+         *
          */
 
         // These properties have the same name and we just swap for whatever's
@@ -404,10 +471,107 @@ DummyVmadm.prototype.update = function vmUpdate(opts, callback) {
             }
         }
 
+        if (payload.hasOwnProperty('set_tags')) {
+            tags = Object.keys(payload.set_tags);
+            if (!vmobj.hasOwnProperty('tags')) {
+                vmobj.tags = {};
+                modified = true;
+            }
+
+            for (idx = 0; idx < tags.length; idx++) {
+                vmobj.tags[tags[idx]] = payload.set_tags[tags[idx]];
+            }
+
+            if (idx > 0) {
+                modified = true;
+            }
+        }
+
+        if (payload.hasOwnProperty('remove_tags')) {
+            for (idx = 0; idx < payload.remove_tags; idx++) {
+                if (vmobj.tags.hasOwnProperty(payload.remove_tags[idx])) {
+                    delete vmobj.tags[payload.remove_tags[idx]];
+                    modified = true;
+                }
+            }
+        }
+
+        if (payload.hasOwnProperty('_add_snapshot')) {
+            if (!vmobj.hasOwnProperty('snapshots')) {
+                vmobj.snapshots = [];
+            }
+            vmobj.snapshots.push({
+                created_at: (new Date()).toISOString(),
+                name: payload._add_snapshot
+            });
+            modified = true;
+        }
+
+        if (payload.hasOwnProperty('_del_snapshot')) {
+            snapshots = vmobj.snapshots;
+            if (vmobj.hasOwnProperty('snapshots')) {
+                vmobj.snapshots = snapshots.filter(function _deleteSnap(snap) {
+                    if (snap.name === payload._del_snapshot) {
+                        modified = true;
+                        return false;
+                    }
+                    return true;
+                });
+            }
+
+            if (snapshots === undefined ||
+                vmobj.snapshots.length === snapshots.length) {
+
+                callback(missingSnapshotError(payload._del_snapshot,
+                    opts.uuid));
+                return;
+            }
+        }
+
+        //
+        // Rollback for us is basically just removing all snapshots newer than
+        // the target snapshot since that's what zfs does.
+        // DummyVmadm.rollback_snapshot will simulate stopping the VM first,
+        // then doing this update, then booting again.
+        //
+        if (payload.hasOwnProperty('_rollback_snapshot')) {
+            snapshots = vmobj.snapshots;
+            if (vmobj.hasOwnProperty('snapshots')) {
+                // First we need to find the snapshot we're rolling back to
+                snaptime = null;
+
+                for (idx = 0; snaptime === null &&
+                    idx < vmobj.snapshots.length; idx++) {
+
+                    if (vmobj.snapshots[idx].name ===
+                        payload._rollback_snapshot) {
+
+                        snaptime = vmobj.snapshots[idx].created_at;
+                    }
+                }
+
+                // Now actually remove any newer snapshots
+                if (snaptime) {
+                    vmobj.snapshots = vmobj.snapshots.filter(
+                        function _deleteNewer(snap) {
+                            if (snap.created_at > snaptime) {
+                                modified = true;
+                                return false;
+                            }
+                            return true;
+                        });
+                }
+            }
+
+            if (snapshots === undefined || snaptime === null) {
+                callback(missingSnapshotError(payload._rollback_snapshot,
+                    opts.uuid));
+                return;
+            }
+        }
+
         if (modified) {
-            self._writeVm(vmobj, {
-                atomicReplace: true
-            }, function _onWrite(writeErr) {
+            self._writeVm(vmobj, {}, function _onWrite(writeErr) {
                 callback(writeErr);
             });
         } else {
@@ -579,8 +743,10 @@ DummyVmadm.prototype.stop = function vmStop(opts, callback) {
     }, callback);
 };
 
-function loadVmMap(_self, callback) {
-    _self._loadVms({}, function _onLoadVms(err, loadedVms) {
+DummyVmadm.prototype._loadVmMap = function _loadVmMap(callback) {
+    var self = this;
+
+    self._loadVms({}, function _onLoadVms(err, loadedVms) {
         var idx;
         var vms = {};
 
@@ -592,7 +758,7 @@ function loadVmMap(_self, callback) {
 
         callback(err, vms);
     });
-}
+};
 
 /*
  * Wrapper around `vmadm events -jr [uuid]`
@@ -623,7 +789,6 @@ DummyVmadm.prototype.events = function vmEvents(_opts, handler, callback) {
     var vmdir = path.join(self.serverRoot, self.serverUuid, 'vms');
     var vmuuid;
 
-    self.loadingVms = {};
     self.vmCache = {};
 
     // We watch only the vmdir directory, and assume that any changes to files
@@ -631,9 +796,11 @@ DummyVmadm.prototype.events = function vmEvents(_opts, handler, callback) {
     self.vmdirWatch = fs.watch(vmdir, {}, function _onDirEvent(_evt) {
         // Called whenever the directory changes (files added/removed)
 
-        loadVmMap(self, function _onLoadVms(err, vms) {
+        self._loadVmMap(function _onLoadVms(err, vms) {
             assert.ifError(err);
 
+            var vmobj;
+
             vmdiff = diff(self.vmCache, vms);
 
             self.log.trace({diff: vmdiff}, 'vms diff');
@@ -678,20 +845,23 @@ DummyVmadm.prototype.events = function vmEvents(_opts, handler, callback) {
             }, 'diff of vm dir');
 
             for (idx = 0; idx < added.length; idx++) {
-                self.log.info({vmUuid: added[idx]}, 'new VM');
-                self._dispatchEvent('create', added[idx], {}, handler);
+                vmobj = vms[added[idx]];
+                self.log.trace({vmUuid: added[idx]}, 'new VM');
+                self._dispatchEvent('create', added[idx], vmobj, {}, handler);
             }
             for (idx = 0; idx < removed.length; idx++) {
-                self.log.info({vmUuid: removed[idx]}, 'deleted VM');
-                self._dispatchEvent('delete', removed[idx], {}, handler);
+                vmobj = {};
+                self.log.trace({vmUuid: removed[idx]}, 'deleted VM');
+                self._dispatchEvent('delete', removed[idx], vmobj, {}, handler);
             }
             for (idx = 0; idx < changed.length; idx++) {
-                changes = diff(self.vmCache[changed[idx]], vms[changed[idx]]);
-                self.log.info({
+                vmobj = vms[changed[idx]];
+                changes = diff(self.vmCache[changed[idx]], vmobj);
+                self.log.trace({
                     vmUuid: changed[idx],
                     changes: changes
                 }, 'changed VM');
-                self._dispatchEvent('modify', changed[idx], {
+                self._dispatchEvent('modify', changed[idx], vmobj, {
                     changes: changes
                 }, handler);
             }
@@ -710,7 +880,7 @@ DummyVmadm.prototype.events = function vmEvents(_opts, handler, callback) {
     // We do this with setImmediate because the node-vmadm callers depend on
     // getting the return value and using it before the callback runs.
     setImmediate(function _eventuallyCallCallback() {
-        loadVmMap(self, function _onLoadVms(err, vms) {
+        self._loadVmMap(function _onLoadVms(err, vms) {
             assert.ifError(err);
 
             self.vmCache = vms;
@@ -731,6 +901,237 @@ DummyVmadm.prototype.events = function vmEvents(_opts, handler, callback) {
     return new VmadmCLIEventStream();
 };
 
+
+/**
+ * Call `vmadm create-snapshot <uuid>`.
+ *
+ * @param opts {Object} Options
+ *      - uuid {String} UUID VM to snapshot
+ *      - snapshot_name {String} name to give the snapshot
+ *      - include_dni {Boolean} If true, snapshot VMs that have do_not_inventory
+ *        set. default: false.
+ * @param callback {Function} `function (err)`
+ */
+DummyVmadm.prototype.create_snapshot =
+function vmCreateSnapshot(opts, callback) {
+    var self = this;
+
+    assert.object(opts, 'opts');
+    assert.string(opts.snapshot_name, 'opts.snapshot_name');
+    assert.string(opts.uuid, 'opts.uuid');
+
+    // currently not used
+    assert.optionalBool(opts.include_dni, 'opts.include_dni');
+
+    self.update({
+        _add_snapshot: opts.snapshot_name,
+        uuid: opts.uuid
+    }, callback);
+};
+
+/**
+ * Call `vmadm rollback-snapshot <uuid>`.
+ *
+ * @param opts {Object} Options
+ *      - uuid {String} UUID of VM container snapshot to rollback
+ *      - snapshot_name {String} name of snapshot to rollback
+ *      - include_dni {Boolean} If true, rollback snapshots for VMs that have
+ *        do_not_inventory set. default: false.
+ * @param callback {Function} `function (err)`
+ */
+
+DummyVmadm.prototype.rollback_snapshot =
+function vmRollbackSnapshot(opts, callback) {
+    var self = this;
+
+    assert.object(opts, 'opts');
+    assert.string(opts.snapshot_name, 'opts.snapshot_name');
+    assert.string(opts.uuid, 'opts.uuid');
+
+    // currently not used
+    assert.optionalBool(opts.include_dni, 'opts.include_dni');
+
+    vasync.pipeline({
+        arg: {},
+        funcs: [
+            function _preloadVm(ctx, cb) {
+                self._loadVm({
+                    uuid: opts.uuid
+                }, function _onLoad(err, vmobj) {
+                    var idx;
+                    var foundSnapshot = false;
+                    var snaps;
+
+                    if (err) {
+                        cb(err);
+                        return;
+                    }
+
+                    ctx.vmobj = vmobj;
+
+                    if (vmobj.snapshots) {
+                        snaps = vmobj.snapshots;
+                        for (idx = 0; idx < snaps.length; idx++) {
+                            if (snaps[idx].name === opts.snapshot_name) {
+                                foundSnapshot = true;
+                            }
+                        }
+                    }
+
+                    if (!foundSnapshot) {
+                        cb(missingSnapshotError(opts.snapshot_name, opts.uuid));
+                        return;
+                    }
+
+                    cb();
+                });
+            }, function _stopIfRunning(ctx, cb) {
+                ctx.prevState = ctx.vmobj.state;
+                if (ctx.prevState !== 'running') {
+                    cb();
+                    return;
+                }
+
+                self.stop({
+                    uuid: opts.uuid
+                }, cb);
+            }, function _doRollback(_ctx, cb) {
+                self.update({
+                    _rollback_snapshot: opts.snapshot_name,
+                    uuid: opts.uuid
+                }, cb);
+            }, function _startIfWasRunning(ctx, cb) {
+                if (ctx.prevState !== 'running') {
+                    cb();
+                    return;
+                }
+
+                self.start({
+                    uuid: opts.uuid
+                }, cb);
+            }
+        ]
+    }, callback);
+};
+
+/**
+ * Call `vmadm delete-snapshot <uuid>`.
+ *
+ * @param opts {Object} Options
+ *      - uuid {String} UUID of VM container snapshot to delete
+ *      - snapshot_name {String} name of the snapshot to delete
+ *      - include_dni {Boolean} If true, delete snapshots for VMs that have
+ *        do_not_inventory set. default: false.
+ * @param callback {Function} `function (err)`
+ */
+
+DummyVmadm.prototype.delete_snapshot =
+function vmDeleteSnapshot(opts, callback) {
+    var self = this;
+
+    assert.object(opts, 'opts');
+    assert.string(opts.snapshot_name, 'opts.snapshot_name');
+    assert.string(opts.uuid, 'opts.uuid');
+
+    // currently not used
+    assert.optionalBool(opts.include_dni, 'opts.include_dni');
+
+    self.update({
+        _del_snapshot: opts.snapshot_name,
+        uuid: opts.uuid
+    }, callback);
+};
+
+
+
+/**
+ * Call `vmadm reprovision`.
+ *
+ * @param opts {Object} vmadm reprovision payload
+ *      - image_uuid {String} image_uuid of new image for this VM
+ *      - include_dni {Boolean} If true, reprovision VMs that have
+ *        do_not_inventory set. default: false.
+ *      - log {Logger object}
+ *      - uuid {String} uuid of vm to be reprovisioned
+ * @param callback {Function} `function (err)`
+ */
+
+DummyVmadm.prototype.reprovision = function vmReprovision(opts, callback) {
+    var self = this;
+
+    assert.object(opts, 'opts');
+    assert.optionalString(opts.req_id, 'opts.req_id');
+    assert.uuid(opts.uuid, 'opts.uuid');
+    assert.uuid(opts.image_uuid, 'opts.image_uuid');
+
+    // currently not used
+    assert.optionalBool(opts.include_dni, 'opts.include_dni');
+
+    var payload = opts;
+    delete payload.log;
+    delete payload.vmadmLogger;
+    delete payload.req_id;
+    delete payload.include_dni;
+
+    vasync.pipeline({
+        arg: {},
+        funcs: [
+            function _preloadVm(ctx, cb) {
+                self._loadVm({
+                    uuid: opts.uuid
+                }, function _onLoad(err, vmobj) {
+                    ctx.vmobj = vmobj;
+                    cb(err);
+                });
+            }, function _setStateProvisioning(ctx, cb) {
+                // ensure state = provisioning and zone_state is unchanged
+                ctx.prevState = ctx.vmobj.state;
+                self._updateVmState({
+                    state: 'provisioning',
+                    uuid: opts.uuid,
+                    zone_state: ctx.prevState
+                }, cb);
+            }, function _stopIfRunning(ctx, cb) {
+                // ensure zone_state = stopped
+                if (ctx.prevState !== 'running') {
+                    cb();
+                    return;
+                }
+
+                self._updateVmState({
+                    state: 'provisioning',
+                    uuid: opts.uuid,
+                    zone_state: 'stopped'
+                }, cb);
+            }, function _updateImageUuid(_ctx, cb) {
+                // update the image_uuid to the new one we were passed
+                self.update({
+                    image_uuid: opts.image_uuid,
+                    uuid: opts.uuid
+                }, cb);
+            }, function _startIfWasRunning(ctx, cb) {
+                // "start" the VM (zone_state) if we "stopped" it
+                if (ctx.prevState !== 'running') {
+                    cb();
+                    return;
+                }
+
+                self._updateVmState({
+                    state: 'provisioning',
+                    uuid: opts.uuid,
+                    zone_state: 'running'
+                }, cb);
+            }, function _unsetStateProvisioning(ctx, cb) {
+                // remove the "provisioning" state, go back to old state
+                self._updateVmState({
+                    state: ctx.prevState,
+                    uuid: opts.uuid
+                }, cb);
+            }
+        ]
+    }, callback);
+};
+
 // --- dummy helper methods
 
 DummyVmadm.prototype._deleteAllWatchers = function _deleteAllWatchers() {
@@ -742,9 +1143,10 @@ DummyVmadm.prototype._deleteAllWatchers = function _deleteAllWatchers() {
 };
 
 DummyVmadm.prototype._dispatchEvent =
-function _dispatchEvent(evtName, zonename, opts, handler) {
+function _dispatchEvent(evtName, zonename, vmobj, opts, handler) {
     assert.string(evtName, 'evtName');
-    assert.uuid(zonename, 'zonename');
+    assert.uuid(zonename, 'vmobj.zonename');
+    assert.object(vmobj, 'vmobj');
     assert.object(opts, 'opts');
     assert.func(handler, 'handler');
 
@@ -752,50 +1154,24 @@ function _dispatchEvent(evtName, zonename, opts, handler) {
         assert.arrayOfObject(opts.changes, 'opts.changes');
     }
 
-    var self = this;
-
-    if (self.loadingVms[zonename]) {
-        self.log.trace({zonename: zonename}, 'dispatchEvent skipping zone'
-            + ' which is already being loaded');
-        return;
-    }
-    self.loadingVms[zonename] = (new Date()).getTime();
-
-    self._loadVm({
-        uuid: zonename
-    }, function _onVmLoad(err, vmobj) {
-        var handlerObj;
-
-        delete self.loadingVms[zonename];
-
-        if (err && err.code === 'ENOENT') {
-            if (evtName === 'delete') {
-                handlerObj = {
-                    type: 'delete',
-                    vm: {},
-                    zonename: zonename
-                };
-                handler(handlerObj);
-            } else {
-                self.log.error({evtname: evtName, zonename: zonename},
-                    'VM unexpectedly disappeared while loading after event');
-            }
-            return;
-        }
-
-       if (err) {
-            self.log.error({err: err, zonename: zonename}, 'error loading VM');
-            return;
-        }
+    var handlerObj;
 
+    if (evtName === 'delete') {
+        handlerObj = {
+            type: 'delete',
+            vm: {},
+            zonename: zonename
+        };
+    } else {
         handlerObj = {
             changes: (evtName === 'modify') ? opts.changes : undefined,
             type: evtName,
             vm: vmobj,
             zonename: zonename
         };
-        handler(handlerObj);
-    });
+    }
+
+    handler(handlerObj);
 };
 
 DummyVmadm.prototype._addSystemProperties =
@@ -854,7 +1230,9 @@ function _addHardcodedProperties(arg, callback) {
     arg.vmobj.zonename = arg.vmobj.uuid;
 
     assert.string(arg.vmobj.state, 'arg.vmobj.state');
-    arg.vmobj.zone_state = arg.vmobj.state;
+    if (!arg.vmobj.hasOwnProperty('zone_state')) {
+        arg.vmobj.zone_state = arg.vmobj.state;
+    }
 
     assert.optionalNumber(arg.vmobj.pid, 'arg.vmobj.pid');
     if (arg.vmobj.pid !== undefined) {
@@ -921,13 +1299,18 @@ DummyVmadm.prototype._loadVm = function _loadVm(opts, callback) {
     var vmobj;
 
     fs.readFile(filename, function _onRead(err, data) {
+        var strData;
+
         if (err) {
             callback(err);
             return;
         }
 
+        strData = data.toString();
+        assert.ok(strData.length > 0, filename + ' should not be empty');
+
         try {
-            vmobj = JSON.parse(data.toString());
+            vmobj = JSON.parse(strData);
         } catch (parseErr) {
             // If the file disappeared, the VM was deleted while we were loading
             // it, so we'll return the stat exception so the caller can check
@@ -939,6 +1322,9 @@ DummyVmadm.prototype._loadVm = function _loadVm(opts, callback) {
                 callback(statErr);
                 return;
             }
+            if (parseErr) {
+                self.log.error({data: strData}, 'bad data parsing JSON');
+            }
             callback(parseErr);
             return;
         }
@@ -986,7 +1372,7 @@ DummyVmadm.prototype._loadVms = function loadVms(_opts, callback) {
             if (matches) {
                 toLoad.push(matches[1]);
             } else {
-                self.log.debug({filename: filename}, 'Ignoring non-zone file');
+                self.log.trace({filename: filename}, 'Ignoring non-zone file');
             }
         }
 
@@ -1020,7 +1406,6 @@ DummyVmadm.prototype._writeVm =
 function _writeVm(vmobj, opts, callback) {
     assert.object(vmobj, 'vmobj');
     assert.object(opts, 'opts');
-    assert.optionalBool(opts.atomicReplace, 'opts.atomicReplace');
     assert.func(callback);
 
     var self = this;
@@ -1030,12 +1415,8 @@ function _writeVm(vmobj, opts, callback) {
     var vmdir;
 
     vmdir = path.join(self.serverRoot, self.serverUuid, 'vms');
-    filename = path.join(vmdir, vmobj.uuid + '.json');
-
-    if (opts.atomicReplace) {
-        finalFilename = filename;
-        filename = filename + '.' + process.pid;
-    }
+    finalFilename = path.join(vmdir, vmobj.uuid + '.json');
+    filename = finalFilename + '.' + process.pid;
 
     vasync.pipeline({
         funcs: [
@@ -1062,12 +1443,19 @@ function _writeVm(vmobj, opts, callback) {
                     });
                 });
             }, function _atomicReplace(_, cb) {
-                if (!opts.atomicReplace) {
+                fs.rename(filename, finalFilename, cb);
+            }, function _validateWrite(_, cb) {
+                // If self has a property writeValidator, we expect that to be a
+                // function that will return after verifying that the write has
+                // fully completed. This is used for the dummy vminfod for
+                // example, to ensure that a write has been seen by the event
+                // watchers.
+                if (self._writeValidator === undefined) {
                     cb();
                     return;
                 }
 
-                fs.rename(filename, finalFilename, cb);
+                self._writeValidator(vmobj, cb);
             }
         ]
     }, function _onWroteVm(err) {
@@ -1078,9 +1466,10 @@ function _writeVm(vmobj, opts, callback) {
 
 DummyVmadm.prototype._updateVmState = function _updateVmState(opts, callback) {
     assert.object(opts, 'opts');
-    assert.uuid(opts.uuid, 'opts.uuid');
-    assert.string(opts.state, 'opts.state');
     assert.optionalBool(opts.autoboot, 'opts.autoboot');
+    assert.string(opts.state, 'opts.state');
+    assert.uuid(opts.uuid, 'opts.uuid');
+    assert.optionalString(opts.zone_state, 'opts.zone_state');
 
     var self = this;
 
@@ -1095,11 +1484,17 @@ DummyVmadm.prototype._updateVmState = function _updateVmState(opts, callback) {
         if (opts.hasOwnProperty('autoboot')) {
             vmobj.autoboot = opts.autoboot;
         }
+        if (opts.hasOwnProperty('zone_state')) {
+            vmobj.zone_state = opts.zone_state;
+        } else {
+            // When not explicitly set, we'll rely on _addHardcodedProperties
+            // to set zone_state to state.
+            delete vmobj.zone_state;
+        }
         vmobj.state = opts.state;
 
-        self._writeVm(vmobj, {
-            atomicReplace: true
-        }, function _onWrite(writeErr) {
+        self._writeVm(vmobj, {},
+            function _onWrite(writeErr) {
             callback(writeErr);
         });
     });
@@ -1116,6 +1511,15 @@ function assertSysinfo(sysinfo) {
 }
 
 
+function missingSnapshotError(snapName, vmUuid) {
+    var err;
+
+    err = new Error('No snapshot named "' + snapName + '" for ' + vmUuid);
+
+    return (err);
+}
+
+
 /*
  * Converts a dotted IPv4 address (eg: 1.2.3.4) to its integer value
  */
diff --git a/lib/index.dummy_vminfod.js b/lib/index.dummy_vminfod.js
new file mode 100644
index 0000000..cdf81e5
--- /dev/null
+++ b/lib/index.dummy_vminfod.js
@@ -0,0 +1,430 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2018, Joyent, Inc.
+ */
+
+/*
+ * A dummy version of node-vmadm that wraps index.dummy with calls to a
+ * vminfod-like service that handles:
+ *
+ *  - events
+ *  - loadVm
+ *  - loadVms
+ *
+ * and adds a hook to ensure that all clients using this module see a consistent
+ * view of the VMs on this CN.
+ *
+ */
+
+var path = require('path');
+var stream = require('stream');
+var util = require('util');
+
+var assert = require('assert-plus');
+var restify = require('restify');
+var watershed = require('watershed');
+
+var diff = require('./diff');
+var DummyVmadm = require('./index.dummy');
+
+var ws = new watershed.Watershed();
+
+// These fields aren't in the objects JSON that are written to disk, so we don't
+// include them when comparing to determine whether the VM has changed or not.
+var FIELDS_IGNORED_WHEN_COMPARING = [
+    'boot_timestamp',
+    'exit_status',
+    'exit_timestamp',
+    'last_modified',
+    'pid',
+    'zoneid',
+    'zone_state'
+];
+
+function DummyVminfodVmadm(opts) {
+    var self = this;
+
+    DummyVmadm.call(self, opts);
+
+    self.vminfodEventClient = restify.createClient({
+        url: 'http://127.0.0.1:9090'
+    });
+
+    self.vminfodJsonClient = restify.createJsonClient({
+        url: 'http://127.0.0.1:9090'
+    });
+
+}
+util.inherits(DummyVminfodVmadm, DummyVmadm);
+
+/*
+ * Wrapper around `vmadm events -jr [uuid]`
+ *
+ * @param opts {Object} Options
+ *      - uuid {String} UUID of VM to watch, if unset all VMs are watched
+ *      - name {String} Identifier string for debugging purposes, this will be
+ *      used to construct the user-agent sent to vminfod
+ * @param handler {Function} `function (ev)`
+ *      - called when an event is seen
+ * @param callback {Function} `function (err, obj)`
+ *      - called when the stream is ready, or failed to start
+ *      - err {Error} set if an error occured that means the stream cannot be
+ *      created
+ *      - stop {Function} function to stop the event stream
+ * @return vs {VmadmCLIEventStream}
+ *      - Can be used to listen for errors, ex: `vs.on('error', ...)`
+ */
+DummyVminfodVmadm.prototype.events =
+function vmEvents(_opts, handler, callback) {
+    var self = this;
+
+    var opts;
+    var shed;
+    var stop = false;
+    var wskey = ws.generateKey();
+
+    opts = {
+        agent: false,
+        headers: {
+            connection: 'upgrade',
+            upgrade: 'websocket',
+            'Sec-WebSocket-Key': wskey,
+            'Sec-WebSocket-Version': '13',
+            Server: self.serverUuid
+        }
+    };
+
+    function getEvents() {
+        self.log.debug({
+            Server: self.serverUuid
+        }, 'connecting to dummy vminfod');
+
+        self.vminfodEventClient.get(opts,
+            function _onGet(err, res) {
+
+            if (err) {
+                self.log.error({
+                    err: err
+                }, 'failed to get upgrade to dummy vminfod');
+                callback(err);
+                return;
+            }
+
+            res.once('upgradeResult',
+                function _onUpgrade(upErr, upRes, upSocket, upHead) {
+
+                if (upErr) {
+                    self.log.error({
+                        err: upErr
+                    }, 'got error upgrade result from dummy vminfod');
+                    callback(upErr);
+                    return;
+                }
+
+                shed = ws.connect(upRes, upSocket, upHead, wskey);
+
+                shed.on('text', function _onText(msg) {
+                    var obj = JSON.parse(msg);
+
+                    self.log.debug({
+                        obj: obj,
+                        Server: self.serverUuid
+                    }, 'saw event from dummy vminfod');
+
+                    if (obj.type !== 'info') {
+                        handler(obj);
+                    }
+                });
+
+                shed.on('end', function _onEnd() {
+                    self.log.debug({
+                        Server: self.serverUuid
+                    }, 'dummy vminfod connection closed');
+
+                    if (!stop) {
+                        setImmediate(getEvents);
+                    }
+                });
+            });
+        });
+    }
+
+    getEvents();
+
+    setImmediate(function _eventuallyCallCallback() {
+        self._loadVmMap(function _onLoadVms(err, vms) {
+            assert.ifError(err);
+
+            callback(null, {
+                ev: {
+                    date: (new Date()).toISOString(),
+                    type: 'ready',
+                    vms: vms
+                },
+                stop: function _stop() {
+                    stop = true;
+                    if (shed) {
+                        shed.end();
+                        shed = undefined;
+                    }
+                }
+            });
+        });
+    });
+
+    return new VmadmCLIEventStream();
+};
+
+
+// --- validators
+
+DummyVminfodVmadm.prototype._deleteValidator =
+function _deleteValidator(uuid, callback) {
+    var self = this;
+
+    self._waitForVmobj({}, {
+        timeout: 5000,
+        uuid: uuid
+    }, callback);
+};
+
+DummyVminfodVmadm.prototype._writeValidator =
+function _writeValidator(vmobj, callback) {
+    var self = this;
+
+    self._waitForVmobj(vmobj, {
+        timeout: 5000,
+        uuid: vmobj.uuid
+    }, callback);
+};
+
+// --- dummy helper methods
+
+DummyVminfodVmadm.prototype._loadVm = function _loadVm(opts, callback) {
+    assert.object(opts, 'opts');
+    assert.uuid(opts.uuid, 'opts.uuid');
+
+    var self = this;
+    var url;
+    var vmobj = {};
+
+    url = path.join('/servers', self.serverUuid, 'vms', opts.uuid);
+
+    self.vminfodJsonClient.get({
+        agent: false,
+        path: url
+    }, function _onGet(err, req, res, obj) {
+        var notFoundErr;
+
+        self.log.trace({
+            err: err,
+            obj: obj
+        }, 'loadVm response from dummy vminfod');
+
+        if (!err) {
+            vmobj = obj;
+        } else if ([
+            'ResourceNotFound',
+            'VmNotFound'
+        ].indexOf(err.restCode) !== -1) {
+            // NOTE: destroy depends on this matching ': No such zone'
+            notFoundErr = new Error('vmadm load ' + opts.uuid +
+                ' failed: No such zone');
+            notFoundErr.restCode = 'VmNotFound';
+
+            callback(notFoundErr);
+            return;
+        }
+
+        callback(err, vmobj);
+    });
+};
+
+DummyVminfodVmadm.prototype._loadVms =
+function loadVms(_opts, callback) {
+    var self = this;
+    var loadedVms = [];
+    var url = path.join('/servers', self.serverUuid, 'vms');
+
+    self.vminfodJsonClient.get(url, function _onGet(err, req, res, obj) {
+        self.log.trace({
+            err: err,
+            obj: obj
+        }, 'loadVms response from dummy vminfod');
+
+        if (!err) {
+            loadedVms = obj;
+        }
+        callback(err, loadedVms);
+    });
+};
+
+DummyVminfodVmadm.prototype._waitForVmobj =
+function _waitForVmobj(vmobj, opts, callback) {
+    assert.object(opts, 'opts');
+    assert.number(opts.timeout, 'opts.timeout');
+    assert.uuid(opts.uuid, 'opts.uuid');
+
+    var self = this;
+
+    var alreadyDone = false;
+    var stopEventWatcher;
+    var timeoutHandle;
+
+    function done(err) {
+        if (!alreadyDone) {
+            alreadyDone = true;
+            clearTimeout(timeoutHandle);
+            if (stopEventWatcher) {
+                stopEventWatcher();
+            }
+
+            callback(err);
+        } else {
+            self.log.warn({
+                stack: (new Error('')).stack
+            }, 'already done _waitForVmobj.done() called again');
+        }
+    }
+
+    function check(_vmobj) {
+        var expectVmobj;
+        var proposedVmobj;
+        var vmdiff;
+
+        expectVmobj = cleanVmobj(null, vmobj);
+        proposedVmobj = cleanVmobj(expectVmobj, _vmobj);
+        vmdiff = diff(expectVmobj, proposedVmobj);
+
+        self.log.trace({
+            diff: vmdiff,
+            expectVmobj: expectVmobj,
+            proposedVmobj: proposedVmobj,
+            uuid: opts.uuid
+        }, 'waitForVmobj checking for vmobj change');
+
+        if (vmdiff.length === 0) {
+            done();
+        }
+    }
+
+    function tryLoading(cb) {
+        // Now load the VM and check whether it already matches
+        self._loadVm({uuid: opts.uuid}, function _onLoad(err, obj) {
+            var loadedVmobj = {};
+
+            if (err) {
+                if (err.restCode === 'VmNotFound') {
+                    self.log.trace('VM not found yet');
+                } else {
+                    self.log.warn({
+                        err: err
+                    }, 'Error in _loadVm');
+                    cb(err);
+                    return;
+                }
+            } else {
+                loadedVmobj = obj;
+            }
+
+            self.log.debug({
+                vmobj: loadedVmobj
+            }, 'loaded VM');
+            cb(null, loadedVmobj);
+        });
+    }
+
+    // Set a timeout so we don't wait forever
+    timeoutHandle = setTimeout(function _timeoutWait() {
+        // one last load attempt.
+        tryLoading(function _onLoad(loadErr, loadObj) {
+            if (loadErr) {
+                // Still failed...
+                done(new Error('timeout waiting for VM change'));
+                return;
+            }
+            check(loadObj);
+        });
+    }, opts.timeout);
+
+    // Now watch for events so we catch if things change while or after we're
+    // loading.
+    self.events({
+        }, function _onEvent(evt) {
+            if (evt.vm) {
+                self.log.info('saw VM event (create/modify)');
+                check(evt.vm);
+            } else if (evt.type === 'delete') {
+                self.log.info('saw VM event (delete)');
+                check({});
+            } else {
+                self.log.error({
+                    evt: evt
+                }, 'unknown event ' + evt.type);
+            }
+        }, function _onReady(err, obj) {
+            if (err) {
+                done(err);
+                return;
+            }
+
+            assert.object(obj, 'obj');
+            assert.func(obj.stop, 'obj.stop');
+            stopEventWatcher = obj.stop;
+
+            tryLoading(function _onLoad(loadErr, loadObj) {
+                if (loadErr && loadErr.restCode !== 'VmNotFound') {
+                    done(loadErr);
+                    return;
+                }
+                check(loadObj);
+            });
+        }
+    );
+
+};
+
+//
+// Creates a new object using vmobj but removing any properties which have
+// property names that don't exist in the object 'target' or which have been
+// marked to be ignored when comparing. If 'target' is null, only properties
+// in FIELDS_IGNORED_WHEN_COMPARING will be removed.
+//
+function cleanVmobj(target, vmobj) {
+    var idx;
+    var field;
+    var keepFields;
+    var newObj = {};
+
+    keepFields = Object.keys(vmobj).filter(function _filterField(_field) {
+        if (FIELDS_IGNORED_WHEN_COMPARING.indexOf(_field) !== -1) {
+            return false;
+        }
+
+        if (!target || target.hasOwnProperty(_field)) {
+            return true;
+        }
+
+        return false;
+    });
+
+    for (idx = 0; idx < keepFields.length; idx++) {
+        field = keepFields[idx];
+        newObj[field] = vmobj[field];
+    }
+
+    return (newObj);
+}
+
+// This implementation detail is now exposed as of TRITON-571 so we have to do
+// this even though it makes no sense.
+function VmadmCLIEventStream(_opts) {
+}
+util.inherits(VmadmCLIEventStream, stream.Transform);
+
+module.exports = DummyVminfodVmadm;
diff --git a/package.json b/package.json
index 0f4fefe..5f283d4 100644
--- a/package.json
+++ b/package.json
@@ -1,6 +1,6 @@
 {
   "name": "vmadm",
-  "version": "1.2.0",
+  "version": "1.3.0",
   "description": "Node.js wrapper around SmartOS vmadm(1M)",
   "repository": {
     "type": "git",
diff --git a/test/unit/dummy.test.js b/test/unit/dummy.test.js
index 00500a7..17cf53b 100644
--- a/test/unit/dummy.test.js
+++ b/test/unit/dummy.test.js
@@ -17,6 +17,8 @@ const fse = require('fs-extra');
 const mockfs = require('mock-fs');
 const tap = require('tap');
 const uuidv1 = require('uuid/v1');
+const uuidv4 = require('uuid/v4');
+const vasync = require('vasync');
 
 const DummyVmadm = require('../../lib/index.dummy');
 const testutil = require('./testutil');
@@ -290,6 +292,185 @@ tap.test('DummyVmadm', function (suite) {
         });
     });
 
+    //
+    // This tests the snapshot functionality by:
+    //
+    //  * creating a VM
+    //  * creating 3 snapshots
+    //  * ensuring all 3 snapshots were created
+    //  * rolling back to the first snapshot
+    //  * ensuring snapshots 2 and 3 were deleted
+    //  * delete the remaining snapshot
+    //  * ensuring snapshots is now empty
+    //
+    suite.test('snapshots', function (t) {
+        mockfs({[path.join(SERVER_ROOT, SERVER_UUID, 'vms')]: {}});
+        const vmadm = testSubject(SERVER_ROOT);
+        t.plan(16);
+
+        function _createSnapshot(ctx, name, cb) {
+            vmadm.create_snapshot({
+                snapshot_name: name,
+                uuid: ctx.uuid
+            }, function onSnapCreate(err) {
+                t.error(err, 'should be no error creating "' + name + '"');
+                cb(err);
+            });
+        }
+
+        vasync.pipeline({
+            arg: {},
+            funcs: [
+                function _createVm(ctx, cb) {
+                    vmadm.create(payloads.web00, function onCreate(err, info) {
+                        t.error(err, 'create VM for snapshotting');
+                        ctx.uuid = info.uuid;
+                        cb(err);
+                    });
+                }, function _createSnapshot1(ctx, cb) {
+                    _createSnapshot(ctx, 'snapshot1', cb);
+                }, function _createSnapshot2(ctx, cb) {
+                    _createSnapshot(ctx, 'snapshot2', cb);
+                }, function _createSnapshot3(ctx, cb) {
+                    _createSnapshot(ctx, 'snapshot3', cb);
+                }, function _checkSnapshots(ctx, cb) {
+                    vmadm.load({
+                        uuid: ctx.uuid
+                    }, function onLoad(err, vmobj) {
+                        t.error(err, 'load after snapshotting');
+                        t.equal(vmobj.state, 'running', 'VM should be running');
+                        t.deepEqual(vmobj.snapshots.map(function _onlyName(s) {
+                            return (s.name);
+                        }).sort(), [
+                            'snapshot1',
+                            'snapshot2',
+                            'snapshot3'
+                        ], 'should see all 3 snapshots');
+                        cb(err);
+                    });
+                }, function _rollbackSnapshot(ctx, cb) {
+                    vmadm.rollback_snapshot({
+                        snapshot_name: 'snapshot1',
+                        uuid: ctx.uuid
+                    }, function onRollback(err) {
+                        t.error(err, 'rollback to snapshot1');
+                        cb(err);
+                    });
+                }, function _checkSnapshots(ctx, cb) {
+                    vmadm.load({
+                        uuid: ctx.uuid
+                    }, function onLoad(err, vmobj) {
+                        t.error(err, 'load after rollback');
+                        t.equal(vmobj.state, 'running', 'VM should be running');
+                        t.deepEqual(vmobj.snapshots.map(function _onlyName(s) {
+                            return (s.name);
+                        }).sort(), [
+                            'snapshot1'
+                        ], 'should see only 1 snapshot');
+                        cb(err);
+                    });
+                }, function _deleteSnapshot(ctx, cb) {
+                    vmadm.delete_snapshot({
+                        snapshot_name: 'snapshot1',
+                        uuid: ctx.uuid
+                    }, function onRollback(err) {
+                        t.error(err, 'delete snapshot1');
+                        cb(err);
+                    });
+                }, function _checkSnapshots(ctx, cb) {
+                    vmadm.load({
+                        uuid: ctx.uuid
+                    }, function onLoad(err, vmobj) {
+                        t.error(err, 'load after delete');
+                        t.equal(vmobj.state, 'running', 'VM should be running');
+                        t.deepEqual(vmobj.snapshots.map(function _onlyName(s) {
+                            return (s.name);
+                        }).sort(), [], 'should see 0 snapshots');
+                        cb(err);
+                    });
+                }
+            ]
+        }, function donePipeline(err) {
+            t.error(err, 'snapshot actions should all have succeeded');
+            t.end();
+        });
+    });
+
+    //
+    // This tests the vmadm.update functionality by:
+    //
+    //  * creating a VM
+    //  * loading the VM
+    //  * modifying some properties with a vmadm.update
+    //  * loading the VM again to ensure properties changed as expected
+    //
+    suite.test('update', function (t) {
+        mockfs({[path.join(SERVER_ROOT, SERVER_UUID, 'vms')]: {}});
+        var updatePayload = {
+            alias: 'robotic_dolphin',
+            autoboot: false, // default is true
+            image_uuid: uuidv4(),
+            billing_id: uuidv4(),
+            resolvers: '1.1.1.1,1.0.0.1'
+        };
+        const vmadm = testSubject(SERVER_ROOT);
+        t.plan(5 + (Object.keys(updatePayload).length * 2));
+
+        vasync.pipeline({
+            arg: {},
+            funcs: [
+                function _createVm(ctx, cb) {
+                    vmadm.create(payloads.web00, function onCreate(err, info) {
+                        t.error(err, 'create VM for updating');
+                        ctx.uuid = info.uuid;
+                        cb(err);
+                    });
+                }, function _loadInitialVm(ctx, cb) {
+                    vmadm.load({
+                        uuid: ctx.uuid
+                    }, function onLoad(err, vmobj) {
+                        t.error(err, 'load after creation');
+                        ctx.originalVmobj = vmobj;
+                        cb(err);
+                    });
+                }, function _doUpdates(ctx, cb) {
+                    updatePayload.uuid = ctx.uuid;
+                    vmadm.update(updatePayload, function onUpdate(err) {
+                        t.error(err, 'perform update');
+                        cb(err);
+                    });
+                }, function _loadFinalVm(ctx, cb) {
+                    vmadm.load({
+                        uuid: ctx.uuid
+                    }, function onLoad(err, vmobj) {
+                        var idx;
+                        var field;
+                        var fields = Object.keys(updatePayload);
+                        var origVm = ctx.originalVmobj;
+
+                        t.error(err, 'load after update');
+                        for (idx = 0; idx < fields.length; idx++) {
+                            field = fields[idx];
+                            if (field === 'uuid') {
+                                // This won't change.
+                                continue;
+                            }
+
+                            t.notEqual(origVm[field], vmobj[field],
+                                'expected ' + field + ' to change');
+                            t.equal(vmobj[field], updatePayload[field],
+                                'expected ' + field + ' to match update');
+                        }
+                        cb(err);
+                    });
+                }
+            ]
+        }, function donePipeline(err) {
+            t.error(err, 'update actions should all have succeeded');
+            t.end();
+        });
+    });
+
     suite.end();
 });
 
@@ -426,5 +607,183 @@ tap.test('DummyVmadmRealFs', function (suite) {
         }, vmadmEventsReady);
     });
 
+    //
+    // This tests the vmadm.reprovision functionality by:
+    //
+    //  * creating a VM
+    //  * watching for events from the VM
+    //  * reprovisioning the VM with a new image_uuid
+    //  * ensuring that:
+    //    - all expected events were seen, in order
+    //    - the resulting VM has correct state and image_uuid
+    //
+    suite.test('reprovision', function (t) {
+        var prevEvtCount = 0;
+        var state = {
+            evts: []
+        };
+        var watchingEvents = false;
+        const vmadm = testSubject(path.join(os.tmpdir(), SERVER_ROOT));
+
+        t.plan(11);
+
+        // This exists just to pause from returning from a write until a modify
+        // event has been seen.
+        vmadm._writeValidator = function _writeValidator(_vmobj, cb) {
+            if (!watchingEvents) {
+                cb();
+                return;
+            }
+
+            function waitForEvent() {
+                if (state.evts.length > prevEvtCount) {
+                    prevEvtCount = state.evts.length;
+                    cb();
+                    return;
+                }
+
+                // try again in 50ms
+                setTimeout(waitForEvent, 50);
+            }
+
+            waitForEvent();
+        };
+
+        vasync.pipeline({
+            arg: state,
+            funcs: [
+                function _createVm(ctx, cb) {
+                    vmadm.create(payloads.web00, function onCreate(err, info) {
+                        t.error(err, 'create victim VM');
+                        ctx.uuid = info.uuid;
+                        cb(err);
+                    });
+                }, function _startWatchingEvents(ctx, cb) {
+                    vmadm.events(
+                        { name: 'unit-test:reprovision' },
+                        function handler(evt) {
+                            if (evt.zonename === ctx.uuid &&
+                                evt.type === 'modify') {
+                                ctx.evts.push(evt);
+                            } else {
+                                t.ok(false, 'saw stray event: ' +
+                                    JSON.stringify(evt));
+                            }
+                        },
+                        function onReady(err, obj) {
+                            t.error(err, 'ready and watching events');
+                            watchingEvents = true;
+                            if (obj.stop) {
+                                ctx.eventStopper = obj.stop;
+                            }
+                            cb(err);
+                        });
+                }, function _loadInitialVm(ctx, cb) {
+                    vmadm.load({
+                        uuid: ctx.uuid
+                    }, function onLoad(err, vmobj) {
+                        t.error(err, 'load after creation');
+                        ctx.originalVmobj = vmobj;
+                        cb(err);
+                    });
+                }, function _doReprovision(ctx, cb) {
+                    ctx.newImageUuid = uuidv4();
+
+                    t.notEqual(ctx.originalVmobj.image_uuid, ctx.newImageUuid,
+                        'created new image_uuid');
+
+                    vmadm.reprovision({
+                        image_uuid: ctx.newImageUuid,
+                        uuid: ctx.uuid
+                    }, function onReprovision(err) {
+                        t.error(err, 'perform reprovision');
+                        cb(err);
+                    });
+                }, function _loadFinalVm(ctx, cb) {
+                    vmadm.load({
+                        uuid: ctx.uuid
+                    }, function onLoad(err, vmobj) {
+                        t.error(err, 'load after reprovision');
+
+                        t.equal(ctx.originalVmobj.state, vmobj.state,
+                            'state should match pre-reprovision');
+                        t.equal(ctx.originalVmobj.zone_state, vmobj.zone_state,
+                            'zone_state should match pre-reprovision');
+                        t.equal(ctx.newImageUuid, vmobj.image_uuid,
+                            'image_uuid should have changed');
+
+                        cb(err);
+                    });
+                }, function _checkEvents(ctx, cb) {
+                    var justChanges;
+
+                    watchingEvents = false;
+
+                    if (ctx.eventStopper) {
+                        ctx.eventStopper();
+                    }
+
+                    justChanges = ctx.evts.map(function _mapChanges(evt) {
+                        // Remove last_modified, pid, and zoneid changes (since
+                        // they're not interesting) and then remove the "path"
+                        // property since it's just a duplicate of prettyPath in
+                        // our case.
+                        return evt.changes.filter(
+                            function _removeLastModified(change) {
+                                if ([
+                                    'last_modified',
+                                    'pid',
+                                    'zoneid'
+                                ].indexOf(change.prettyPath) !== -1) {
+                                    return false;
+                                }
+                                return true;
+                            });
+                    });
+
+                    t.deepEqual(justChanges, [
+                        [{
+                            prettyPath: 'state',
+                            path: ['state'],
+                            action: 'changed',
+                            oldValue: 'running',
+                            newValue: 'provisioning'
+                        }], [{
+                            prettyPath: 'zone_state',
+                            path: ['zone_state'],
+                            action: 'changed',
+                            oldValue: 'running',
+                            newValue: 'stopped'
+                        }], [{
+                            prettyPath: 'image_uuid',
+                            path: ['image_uuid'],
+                            action: 'changed',
+                            oldValue: ctx.originalVmobj.image_uuid,
+                            newValue: ctx.newImageUuid
+                        }], [{
+                            prettyPath: 'zone_state',
+                            path: ['zone_state'],
+                            action: 'changed',
+                            oldValue: 'stopped',
+                            newValue: 'running'
+                        }], [{
+                            prettyPath: 'state',
+                            path: ['state'],
+                            action: 'changed',
+                            oldValue: 'provisioning',
+                            newValue: 'running'
+                        }]
+                    ], 'saw expected events');
+
+                    cb();
+                }
+            ]
+        }, function donePipeline(err) {
+            t.error(err, 'reprovision actions should all have succeeded');
+            t.end();
+        });
+    });
+
+
     suite.end();
 });
