commit 2ddf99c43c58c9ee9416ccc6e1ded39c05c30f42 (refs/changes/95/4895/1)
Author: Josh Wilsdon <josh@wilsdon.ca>
Date:   2018-09-28T13:34:33-07:00 (1 year ago)
    
    TRITON-805 node-vmadm should support dummy vminfod

diff --git a/lib/index.dummy.js b/lib/index.dummy.js
index eb3940b..b886da9 100644
--- a/lib/index.dummy.js
+++ b/lib/index.dummy.js
@@ -243,6 +243,31 @@ DummyVmadm.prototype.create = function vmCreate(opts, callback) {
     payload.autoboot = true;
     payload.create_timestamp = (new Date()).toISOString();
 
+    // Fill in some fields vmadm adds by default
+    if (!payload.hasOwnProperty('cpu_shares')) {
+        payload.cpu_shares = 100;
+    }
+    if (!payload.hasOwnProperty('max_lwps')) {
+        payload.max_lwps = 2000;
+    }
+    if (!payload.hasOwnProperty('max_physical_memory')) {
+        if (payload.hasOwnProperty('ram')) {
+            payload.max_physical_memory = payload.ram;
+        } else {
+            payload.max_physical_memory = 256;
+        }
+    }
+    if (!payload.hasOwnProperty('max_locked_memory')) {
+        payload.max_locked_memory = payload.max_physical_memory;
+    }
+    if (!payload.hasOwnProperty('max_swap')) {
+        payload.max_swap = payload.max_physical_memory;
+    }
+
+    if (['bhyve', 'kvm'].indexOf(payload.brand) === -1) {
+        delete payload.ram;
+    }
+
     // TODO:
     //
     //   strip out properties we don't care about, validate ones we do.
@@ -298,9 +323,24 @@ DummyVmadm.prototype.delete = function vmDelete(opts, callback) {
 
                     cb();
                 });
+            }, function _validateDelete(_, cb) {
+                // If self has a property deleteValidator, we expect that to be
+                // a function that will return after verifying that the delete
+                // has fully completed. This is used for the dummy vminfod for
+                // example, to ensure that a delete has been seen by the event
+                // watchers.
+                if (self._deleteValidator === undefined) {
+                    cb();
+                    return;
+                }
+
+                self._deleteValidator(opts.uuid, cb);
             }
         ]
     }, function _onDeleted(err) {
+        if (err.code === 'ENOENT') {
+            err.restCode = 'VmNotFound';
+        }
         self.log.info({err: err, uuid: opts.uuid}, 'delete VM');
         callback(err);
     });
@@ -405,9 +445,7 @@ DummyVmadm.prototype.update = function vmUpdate(opts, callback) {
         }
 
         if (modified) {
-            self._writeVm(vmobj, {
-                atomicReplace: true
-            }, function _onWrite(writeErr) {
+            self._writeVm(vmobj, {}, function _onWrite(writeErr) {
                 callback(writeErr);
             });
         } else {
@@ -579,8 +617,10 @@ DummyVmadm.prototype.stop = function vmStop(opts, callback) {
     }, callback);
 };
 
-function loadVmMap(_self, callback) {
-    _self._loadVms({}, function _onLoadVms(err, loadedVms) {
+DummyVmadm.prototype._loadVmMap = function _loadVmMap(callback) {
+    var self = this;
+
+    self._loadVms({}, function _onLoadVms(err, loadedVms) {
         var idx;
         var vms = {};
 
@@ -592,7 +632,7 @@ function loadVmMap(_self, callback) {
 
         callback(err, vms);
     });
-}
+};
 
 /*
  * Wrapper around `vmadm events -jr [uuid]`
@@ -631,7 +671,7 @@ DummyVmadm.prototype.events = function vmEvents(_opts, handler, callback) {
     self.vmdirWatch = fs.watch(vmdir, {}, function _onDirEvent(_evt) {
         // Called whenever the directory changes (files added/removed)
 
-        loadVmMap(self, function _onLoadVms(err, vms) {
+        self._loadVmMap(function _onLoadVms(err, vms) {
             assert.ifError(err);
 
             vmdiff = diff(self.vmCache, vms);
@@ -678,16 +718,16 @@ DummyVmadm.prototype.events = function vmEvents(_opts, handler, callback) {
             }, 'diff of vm dir');
 
             for (idx = 0; idx < added.length; idx++) {
-                self.log.info({vmUuid: added[idx]}, 'new VM');
+                self.log.trace({vmUuid: added[idx]}, 'new VM');
                 self._dispatchEvent('create', added[idx], {}, handler);
             }
             for (idx = 0; idx < removed.length; idx++) {
-                self.log.info({vmUuid: removed[idx]}, 'deleted VM');
+                self.log.trace({vmUuid: removed[idx]}, 'deleted VM');
                 self._dispatchEvent('delete', removed[idx], {}, handler);
             }
             for (idx = 0; idx < changed.length; idx++) {
                 changes = diff(self.vmCache[changed[idx]], vms[changed[idx]]);
-                self.log.info({
+                self.log.trace({
                     vmUuid: changed[idx],
                     changes: changes
                 }, 'changed VM');
@@ -710,7 +750,7 @@ DummyVmadm.prototype.events = function vmEvents(_opts, handler, callback) {
     // We do this with setImmediate because the node-vmadm callers depend on
     // getting the return value and using it before the callback runs.
     setImmediate(function _eventuallyCallCallback() {
-        loadVmMap(self, function _onLoadVms(err, vms) {
+        self._loadVmMap(function _onLoadVms(err, vms) {
             assert.ifError(err);
 
             self.vmCache = vms;
@@ -921,13 +961,18 @@ DummyVmadm.prototype._loadVm = function _loadVm(opts, callback) {
     var vmobj;
 
     fs.readFile(filename, function _onRead(err, data) {
+        var strData;
+
         if (err) {
             callback(err);
             return;
         }
 
+        strData = data.toString();
+        assert.ok(strData.length > 0, filename + ' should not be empty');
+
         try {
-            vmobj = JSON.parse(data.toString());
+            vmobj = JSON.parse(strData);
         } catch (parseErr) {
             // If the file disappeared, the VM was deleted while we were loading
             // it, so we'll return the stat exception so the caller can check
@@ -939,6 +984,9 @@ DummyVmadm.prototype._loadVm = function _loadVm(opts, callback) {
                 callback(statErr);
                 return;
             }
+            if (parseErr) {
+                self.log.error({data: strData}, 'bad data parsing JSON');
+            }
             callback(parseErr);
             return;
         }
@@ -986,7 +1034,7 @@ DummyVmadm.prototype._loadVms = function loadVms(_opts, callback) {
             if (matches) {
                 toLoad.push(matches[1]);
             } else {
-                self.log.debug({filename: filename}, 'Ignoring non-zone file');
+                self.log.trace({filename: filename}, 'Ignoring non-zone file');
             }
         }
 
@@ -1020,7 +1068,6 @@ DummyVmadm.prototype._writeVm =
 function _writeVm(vmobj, opts, callback) {
     assert.object(vmobj, 'vmobj');
     assert.object(opts, 'opts');
-    assert.optionalBool(opts.atomicReplace, 'opts.atomicReplace');
     assert.func(callback);
 
     var self = this;
@@ -1030,12 +1077,8 @@ function _writeVm(vmobj, opts, callback) {
     var vmdir;
 
     vmdir = path.join(self.serverRoot, self.serverUuid, 'vms');
-    filename = path.join(vmdir, vmobj.uuid + '.json');
-
-    if (opts.atomicReplace) {
-        finalFilename = filename;
-        filename = filename + '.' + process.pid;
-    }
+    finalFilename = path.join(vmdir, vmobj.uuid + '.json');
+    filename = finalFilename + '.' + process.pid;
 
     vasync.pipeline({
         funcs: [
@@ -1062,12 +1105,19 @@ function _writeVm(vmobj, opts, callback) {
                     });
                 });
             }, function _atomicReplace(_, cb) {
-                if (!opts.atomicReplace) {
+                fs.rename(filename, finalFilename, cb);
+            }, function _validateWrite(_, cb) {
+                // If self has a property writeValidator, we expect that to be a
+                // function that will return after verifying that the write has
+                // fully completed. This is used for the dummy vminfod for
+                // example, to ensure that a write has been seen by the event
+                // watchers.
+                if (self._writeValidator === undefined) {
                     cb();
                     return;
                 }
 
-                fs.rename(filename, finalFilename, cb);
+                self._writeValidator(vmobj, cb);
             }
         ]
     }, function _onWroteVm(err) {
@@ -1097,9 +1147,8 @@ DummyVmadm.prototype._updateVmState = function _updateVmState(opts, callback) {
         }
         vmobj.state = opts.state;
 
-        self._writeVm(vmobj, {
-            atomicReplace: true
-        }, function _onWrite(writeErr) {
+        self._writeVm(vmobj, {},
+            function _onWrite(writeErr) {
             callback(writeErr);
         });
     });
diff --git a/lib/index.dummy_vminfod.js b/lib/index.dummy_vminfod.js
new file mode 100644
index 0000000..57dc0da
--- /dev/null
+++ b/lib/index.dummy_vminfod.js
@@ -0,0 +1,421 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2018, Joyent, Inc.
+ */
+
+/*
+ * A dummy version of node-vmadm that wraps index.dummy with calls to a
+ * vminfod-like service that handles:
+ *
+ *  - events
+ *  - loadVm
+ *  - loadVms
+ *
+ * and adds a hook to ensure that all clients using this module see a consistent
+ * view of the VMs on this CN.
+ *
+ */
+
+var path = require('path');
+var stream = require('stream');
+var util = require('util');
+
+var assert = require('assert-plus');
+var restify = require('restify');
+var watershed = require('watershed');
+
+var diff = require('./diff');
+var DummyVmadm = require('./index.dummy');
+
+var ws = new watershed.Watershed();
+
+var FIELDS_IGNORED_WHEN_COMPARING = [
+    'last_modified',
+    'pid',
+    'zoneid'
+];
+
+function DummyVminfodVmadm(opts) {
+    var self = this;
+
+    DummyVmadm.call(self, opts);
+
+    self.vminfodEventClient = restify.createClient({
+        url: 'http://127.0.0.1:9090'
+    });
+
+    self.vminfodJsonClient = restify.createJsonClient({
+        url: 'http://127.0.0.1:9090'
+    });
+
+}
+util.inherits(DummyVminfodVmadm, DummyVmadm);
+
+/*
+ * Wrapper around `vmadm events -jr [uuid]`
+ *
+ * @param opts {Object} Options
+ *      - uuid {String} UUID of VM to watch, if unset all VMs are watched
+ *      - name {String} Identifier string for debugging purposes, this will be
+ *      used to construct the user-agent sent to vminfod
+ * @param handler {Function} `function (ev)`
+ *      - called when an event is seen
+ * @param callback {Function} `function (err, obj)`
+ *      - called when the stream is ready, or failed to start
+ *      - err {Error} set if an error occured that means the stream cannot be
+ *      created
+ *      - stop {Function} function to stop the event stream
+ * @return vs {VmadmCLIEventStream}
+ *      - Can be used to listen for errors, ex: `vs.on('error', ...)`
+ */
+DummyVminfodVmadm.prototype.events =
+function vmEvents(_opts, handler, callback) {
+    var self = this;
+
+    var opts;
+    var shed;
+    var stop = false;
+    var wskey = ws.generateKey();
+
+    opts = {
+        agent: false,
+        headers: {
+            connection: 'upgrade',
+            upgrade: 'websocket',
+            'Sec-WebSocket-Key': wskey,
+            'Sec-WebSocket-Version': '13',
+            Server: self.serverUuid
+        }
+    };
+
+    function getEvents() {
+        self.log.debug({
+            Server: self.serverUuid
+        }, 'connecting to dummy vminfod');
+
+        self.vminfodEventClient.get(opts,
+            function _onGet(err, res) {
+
+            if (err) {
+                self.log.error({
+                    err: err
+                }, 'failed to get upgrade to dummy vminfod');
+                callback(err);
+                return;
+            }
+
+            res.once('upgradeResult',
+                function _onUpgrade(upErr, upRes, upSocket, upHead) {
+
+                if (upErr) {
+                    self.log.error({
+                        err: upErr
+                    }, 'got error upgrade result from dummy vminfod');
+                    callback(upErr);
+                    return;
+                }
+
+                shed = ws.connect(upRes, upSocket, upHead, wskey);
+
+                shed.on('text', function _onText(msg) {
+                    var obj = JSON.parse(msg);
+
+                    self.log.debug({
+                        obj: obj,
+                        Server: self.serverUuid
+                    }, 'saw event from dummy vminfod');
+
+                    if (obj.type !== 'info') {
+                        handler(obj);
+                    }
+                });
+
+                shed.on('end', function _onEnd() {
+                    self.log.debug({
+                        Server: self.serverUuid
+                    }, 'dummy vminfod connection closed');
+
+                    if (!stop) {
+                        setImmediate(getEvents);
+                    }
+                });
+            });
+        });
+    }
+
+    getEvents();
+
+    setImmediate(function _eventuallyCallCallback() {
+        self._loadVmMap(function _onLoadVms(err, vms) {
+            assert.ifError(err);
+
+            callback(null, {
+                ev: {
+                    date: (new Date()).toISOString(),
+                    type: 'ready',
+                    vms: vms
+                },
+                stop: function _stop() {
+                    stop = true;
+                    if (shed) {
+                        shed.end();
+                        shed = undefined;
+                    }
+                }
+            });
+        });
+    });
+
+    return new VmadmCLIEventStream();
+};
+
+
+// --- validators
+
+DummyVminfodVmadm.prototype._deleteValidator =
+function _deleteValidator(uuid, callback) {
+    var self = this;
+
+    self._waitForVmobj({}, {
+        timeout: 5000,
+        uuid: uuid
+    }, callback);
+};
+
+DummyVminfodVmadm.prototype._writeValidator =
+function _writeValidator(vmobj, callback) {
+    var self = this;
+
+    self._waitForVmobj(vmobj, {
+        timeout: 5000,
+        uuid: vmobj.uuid
+    }, callback);
+};
+
+// --- dummy helper methods
+
+DummyVminfodVmadm.prototype._loadVm = function _loadVm(opts, callback) {
+    assert.object(opts, 'opts');
+    assert.uuid(opts.uuid, 'opts.uuid');
+
+    var self = this;
+    var url;
+    var vmobj = {};
+
+    url = path.join('/servers', self.serverUuid, 'vms', opts.uuid);
+
+    self.vminfodJsonClient.get({
+        agent: false,
+        path: url
+    }, function _onGet(err, req, res, obj) {
+        var notFoundErr;
+
+        self.log.trace({
+            err: err,
+            obj: obj
+        }, 'loadVm response from dummy vminfod');
+
+        if (!err) {
+            vmobj = obj;
+        } else if (err.restCode === 'ResourceNotFound') {
+            // NOTE: destroy depends on this matching ': No such zone'
+            notFoundErr = new Error('vmadm load ' + opts.uuid +
+                ' failed: No such zone');
+            notFoundErr.restCode = 'VmNotFound';
+
+            callback(notFoundErr);
+            return;
+        }
+
+        callback(err, vmobj);
+    });
+};
+
+DummyVminfodVmadm.prototype._loadVms =
+function loadVms(_opts, callback) {
+    var self = this;
+    var loadedVms = [];
+    var url = path.join('/servers', self.serverUuid, 'vms');
+
+    self.vminfodJsonClient.get(url, function _onGet(err, req, res, obj) {
+        self.log.trace({
+            err: err,
+            obj: obj
+        }, 'loadVms response from dummy vminfod');
+
+        if (!err) {
+            loadedVms = obj;
+        }
+        callback(err, loadedVms);
+    });
+};
+
+DummyVminfodVmadm.prototype._waitForVmobj =
+function _waitForVmobj(vmobj, opts, callback) {
+    assert.object(opts, 'opts');
+    assert.number(opts.timeout, 'opts.timeout');
+    assert.uuid(opts.uuid, 'opts.uuid');
+
+    var self = this;
+
+    var alreadyDone = false;
+    var stopEventWatcher;
+    var timeoutHandle;
+
+    function done(err) {
+        if (!alreadyDone) {
+            alreadyDone = true;
+            clearTimeout(timeoutHandle);
+            if (stopEventWatcher) {
+                stopEventWatcher();
+            }
+
+            callback(err);
+        } else {
+            self.log.warn({
+                stack: (new Error('')).stack
+            }, 'already done _waitForVmobj.done() called again');
+        }
+    }
+
+    function check(_vmobj) {
+        var expectVmobj;
+        var proposedVmobj;
+        var vmdiff;
+
+        expectVmobj = cleanVmobj(null, vmobj);
+        proposedVmobj = cleanVmobj(expectVmobj, _vmobj);
+        vmdiff = diff(expectVmobj, proposedVmobj);
+
+        self.log.trace({
+            diff: vmdiff,
+            expectVmobj: expectVmobj,
+            proposedVmobj: proposedVmobj,
+            uuid: opts.uuid
+        }, 'waitForVmobj checking for vmobj change');
+
+        if (vmdiff.length === 0) {
+            done();
+        }
+    }
+
+    function tryLoading(cb) {
+        // Now load the VM and check whether it already matches
+        self._loadVm({uuid: opts.uuid}, function _onLoad(err, obj) {
+            var loadedVmobj = {};
+
+            if (err) {
+                if (err.restCode === 'ResourceNotFound') {
+                    self.log.trace('VM not found yet');
+                } else {
+                    self.log.warn({
+                        err: err
+                    }, 'error in _loadVm');
+                    cb(err);
+                    return;
+                }
+            } else {
+                loadedVmobj = obj;
+            }
+
+            self.log.debug({
+                vmobj: loadedVmobj
+            }, 'loaded VM');
+            cb(null, loadedVmobj);
+        });
+    }
+
+    // Set a timeout so we don't wait forever
+    timeoutHandle = setTimeout(function _timeoutWait() {
+        // one last load attempt.
+        tryLoading(function _onLoad(loadErr, loadObj) {
+            if (loadErr) {
+                // Still failed...
+                done(new Error('timeout waiting for VM change'));
+                return;
+            }
+            check(loadObj);
+        });
+    }, opts.timeout);
+
+    // Now watch for events so we catch if things change while or after we're
+    // loading.
+    self.events({
+        }, function _onEvent(evt) {
+            if (evt.vm) {
+                self.log.info('saw VM event (create/modify)');
+                check(evt.vm);
+            } else if (evt.type === 'delete') {
+                self.log.info('saw VM event (delete)');
+                check({});
+            } else {
+                self.log.error({
+                    evt: evt
+                }, 'unknown event ' + evt.type);
+            }
+        }, function _onReady(err, obj) {
+            if (err) {
+                done(err);
+                return;
+            }
+
+            assert.object(obj, 'obj');
+            assert.func(obj.stop, 'obj.stop');
+            stopEventWatcher = obj.stop;
+
+            tryLoading(function _onLoad(loadErr, loadObj) {
+                if (loadErr && loadErr.restCode !== 'ResourceNotFound') {
+                    done(loadErr);
+                    return;
+                }
+                check(loadObj);
+            });
+        }
+    );
+
+};
+
+//
+// Creates a new object using vmobj but removing any properties which have
+// property names that don't exist in the object 'target' or which have been
+// marked to be ignored when comparing. If 'target' is null, only properties
+// in FIELDS_IGNORED_WHEN_COMPARING will be removed.
+//
+function cleanVmobj(target, vmobj) {
+    var idx;
+    var field;
+    var keepFields;
+    var newObj = {};
+
+    keepFields = Object.keys(vmobj).filter(function _filterField(_field) {
+        if (FIELDS_IGNORED_WHEN_COMPARING.indexOf(_field) !== -1) {
+            return false;
+        }
+
+        if (!target || target.hasOwnProperty(_field)) {
+            return true;
+        }
+
+        return false;
+    });
+
+    for (idx = 0; idx < keepFields.length; idx++) {
+        field = keepFields[idx];
+        newObj[field] = vmobj[field];
+    }
+
+    return (newObj);
+}
+
+// This implementation detail is now exposed as of TRITON-571 so we have to do
+// this even though it makes no sense.
+function VmadmCLIEventStream(_opts) {
+}
+util.inherits(VmadmCLIEventStream, stream.Transform);
+
+module.exports = DummyVminfodVmadm;
diff --git a/package.json b/package.json
index 0f4fefe..5f283d4 100644
--- a/package.json
+++ b/package.json
@@ -1,6 +1,6 @@
 {
   "name": "vmadm",
-  "version": "1.2.0",
+  "version": "1.3.0",
   "description": "Node.js wrapper around SmartOS vmadm(1M)",
   "repository": {
     "type": "git",
