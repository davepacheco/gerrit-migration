commit 0a0c7b176bda723f07e860239b69484056d30d63 (refs/changes/49/749/28)
Author: Orlando Vazquez <ovazquez@gmail.com>
Date:   2016-11-17T10:22:31-08:00 (2 years, 11 months ago)
    
    DOCKER-947 update to node v4
    Reviewed by: Trent Mick <trentm@gmail.com>
    Reviewed by: Josh Wilsdon <josh@wilsdon.ca>
    Approved by: Trent Mick <trentm@gmail.com>

diff --git a/Makefile b/Makefile
index 87381e6..ffe15f8 100644
--- a/Makefile
+++ b/Makefile
@@ -24,10 +24,11 @@ JSSTYLE_FLAGS	 = -f tools/jsstyle.conf
 SMF_MANIFESTS_IN = smf/manifests/docker.xml.in
 CLEAN_FILES += ./node_modules
 
-NODE_PREBUILT_VERSION=v0.10.48
+NODE_PREBUILT_VERSION=v4.6.1
 ifeq ($(shell uname -s),SunOS)
-	NODE_PREBUILT_TAG=zoneecdh
-	NODE_PREBUILT_IMAGE=de411e86-548d-11e4-a4b7-3bb60478632a
+	NODE_PREBUILT_TAG=zone
+	# Allow building on other than image sdc-minimal-multiarch-lts@15.4.1.
+	NODE_PREBUILT_IMAGE=18b094b0-eb01-11e5-80c1-175dac7ddf02
 endif
 
 
diff --git a/lib/auth.js b/lib/auth.js
index 584f5dd..e7a3422 100644
--- a/lib/auth.js
+++ b/lib/auth.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2015, Joyent, Inc.
+ * Copyright (c) 2016, Joyent, Inc.
  */
 
 /*
@@ -40,84 +40,32 @@ var errors = require('./errors');
 
 var fmt = util.format;
 
-/* Turn a potentially non-zero-padded hex string into a Buffer. */
-function fromHex(hex) {
-    /*
-     * Buffer() can't take a hex string unless it's zero-padded out to an
-     * even length.
-     */
-    if (hex.length % 2 !== 0)
-        hex = '0' + hex;
-    return (new Buffer(hex, 'hex'));
-}
 
-/*
- * This is a sample certificate as parsed by node TLS. We will authorize
- * the user by finding the corresponding UFDS user by their certificate CN
- * (login/username), compute the modulus and exponent of their SSH public
- * key to their parsed certificate's modulus and exponent.
- *
- * { subject:
- *    { C: 'CA',
- *      ST: 'BC',
- *      L: 'Vancouver',
- *      O: 'Joyent',
- *      CN: 'foo',
- *      emailAddress: 'foo@bar.com' },
- *   issuer:
- *    { C: 'CA',
- *      ST: 'BC',
- *      L: 'Vancouver',
- *      O: 'Joyent',
- *      CN: 'foo',
- *      emailAddress: 'foo@bar.com' },
- *   modulus: '1AB02CD03EF...',
- *   exponent: '10001',
- *   valid_from: 'Feb 11 19:31:38 2015 GMT',
- *   valid_to: 'Feb 11 19:31:38 2016 GMT',
- *   fingerprint: 'AA:BB:CC:DD:EE:FF' }
- *
- * Note that the "modulus" and "exponent" fields are completely undocumented
- * and not guaranteed to survive into new nodejs versions. As of node v0.12
- * the new field "raw" became available (and documented), containing the raw
- * DER certificate.
- *
+/**
+ * This function is responsible for authentication for the docker service. It
+ * parses the given key/fingerprints and compares them to what we have stored
+ * in UFDS for the user account, and if successful saves the account object
+ * onto the restify request object.
  */
+
 function authTls(req, res, next) {
     var log = req.log;
     var authCache = req.app.authCache;
     var ufds = req.app.ufds;
-    var cert = req.connection.getPeerCertificate();
 
-    /* We only support RSA keys for now until we have a newer node. */
-    if (!cert.subject || !cert.subject.CN || !cert.fingerprint
-        || !cert.modulus || !cert.exponent) {
+    var peerCert = req.connection.getPeerCertificate();
+    if (!peerCert || !peerCert.raw) {
         next(new errors.UnauthorizedError());
         return;
     }
 
-    var exponent = fromHex(cert.exponent);
-    var modulus = fromHex(cert.modulus);
-
-    /*
-     * This is an sshpk private API, so it could break if we upgrade our sshpk
-     * dep. We should keep an eye on this, and change to using the "raw" DER
-     * certificate instead of the exponent/modulus fields once we're on node
-     * 0.12 or later.
-     */
-    var peerKey = new sshpk.Key({
-        type: 'rsa',
-        parts: [
-            { name: 'e', data: sshpkUtils.mpNormalize(exponent) },
-            { name: 'n', data: sshpkUtils.mpNormalize(modulus) }
-        ]
-    });
-
+    var cert = sshpk.parseCertificate(peerCert.raw, 'x509');
+    var peerKey = cert.subjectKey;
     var peerKeyFp = peerKey.fingerprint('sha512').toString();
 
     var account;
     var ufdsKey;
-    var login = cert.subject.CN;
+    var login = cert.subjects[0].cn;
     var authFunctions = [ getMainAccount ];
 
     if (authCache.get(login) && authCache.get(login) === peerKeyFp) {
diff --git a/lib/backends/sdc/build.js b/lib/backends/sdc/build.js
index 37219e3..1b9c4cf 100644
--- a/lib/backends/sdc/build.js
+++ b/lib/backends/sdc/build.js
@@ -218,15 +218,23 @@ function buildImage(opts, callback) {
     function buildCnapiDockerBuild(_, cb) {
         var cnapi = req.app.cnapi;
         var cnapiBuildPayload = common.objCopy(dockerOpts);
+        var headers = {
+            'x-request-id': req_id
+        };
+
         var cnapiBuildOpts = {
-            headers: {
-                'x-request-id': req_id,
-                // Add the docker registry headers.
-                'x-registry-config': req.headers['x-registry-config'],
-                'x-registry-auth': req.headers['x-registry-auth']
-            }
+            headers: headers
         };
 
+        // Add the docker registry headers.
+        if (req.headers['x-registry-config'] !== undefined) {
+            headers['x-registry-config'] = req.headers['x-registry-config'];
+        }
+
+        if (req.headers['x-registry-auth'] !== undefined) {
+            headers['x-registry-auth'] = req.headers['x-registry-auth'];
+        }
+
         cnapiBuildPayload.account_uuid = req.account.uuid;
         cnapiBuildPayload.command = 'build';  // Command type.
         cnapiBuildPayload.imgapi_url = req.app.config.imgapi.url;
@@ -326,14 +334,49 @@ function buildImage(opts, callback) {
 
         buildEventStream = new LineStream();
         buildSocket.pipe(buildEventStream);
-        buildEventStream.on('line', function _buildLineCb(event) {
-            log.debug('build: got build event:', String(event));
-            try {
-                event = JSON.parse(event);
-            } catch (e) {
-                log.error('Build: invalid json: %s - ignoring', event);
-                return;
+
+        buildEventStream.on('readable', function _buildReadableCb() {
+            var line;
+            var event;
+
+            while ((line = buildEventStream.read()) != null) {
+                line = line.trim();
+
+                try {
+                    event = JSON.parse(line);
+                } catch (e) {
+                    log.error('Build: invalid json: %s - ignoring', event);
+                    continue;
+                }
+
+                onBuildEventStreamEvent(event);
             }
+        });
+
+        buildEventStream.on('close', function _eventStreamCloseCb() {
+            log.debug('build: buildEventStream.close - closing socket');
+        });
+        buildSocket.on('end', function _buildSocketEndCb() {
+            log.debug('build: buildSocket.end', buildError);
+            cb(buildError);
+        });
+        buildSocket.on('error', function _buildSocketErrorCb(socketErr) {
+            log.error('build: cnapi build socket error: %s', socketErr);
+            cb(new Error('Build socket error: %s', socketErr));
+        });
+        buildSocket.on('timeout', function _buildSocketTimeoutCb() {
+            log.error('build: cnapi build socket has timed out');
+            buildSocket.destroy();
+            cb(new Error('Build operation has timed out'));
+        });
+
+        res.socket.on('end', function _resSocketEndCb() {
+            log.debug('build got client res.end');
+            // TODO: Cleanup if early close.
+            // buildSocket.destroy();
+        });
+
+        function onBuildEventStreamEvent(event) {
             switch (event.type) {
                 case 'end':
                     if (event.error) {
@@ -422,32 +465,9 @@ function buildImage(opts, callback) {
                     log.error('Unhandled build event: %j', event);
                     break;
             }
-        });
-        buildEventStream.on('close', function _eventStreamCloseCb() {
-            log.debug('build: buildEventStream.close - closing socket');
-        });
-        buildSocket.on('end', function _buildSocketEndCb() {
-            log.debug('build: buildSocket.end', buildError);
-            cb(buildError);
-        });
-        buildSocket.on('error', function _buildSocketErrorCb(socketErr) {
-            log.error('build: cnapi build socket error: %s', socketErr);
-            cb(new Error('Build socket error: %s', socketErr));
-        });
-        buildSocket.on('timeout', function _buildSocketTimeoutCb() {
-            log.error('build: cnapi build socket has timed out');
-            buildSocket.destroy();
-            cb(new Error('Build operation has timed out'));
-        });
-
-        res.socket.on('end', function _resSocketEndCb() {
-            log.debug('build got client res.end');
-            // TODO: Cleanup if early close.
-            // buildSocket.destroy();
-        });
+        }
     }
 
-
     function buildCleanup(err, results) {
         log.debug('build: final callback, err: %j', err);
         cleanup(err || previousErr, function buildCleanupCb(cleanuperr) {
@@ -1010,15 +1030,22 @@ function commitImage(req, opts, callback) {
     function startCnapiDockerCommit(_, cb) {
         var cnapi = req.app.cnapi;
         var cnapiCommitPayload = common.objCopy(opts);
+        var headers = {
+            'x-request-id': req_id
+        };
         var cnapiCommitOpts = {
-            headers: {
-                'x-request-id': req_id,
-                // Add the docker registry headers.
-                'x-registry-config': req.headers['x-registry-config'],
-                'x-registry-auth': req.headers['x-registry-auth']
-            }
+            headers: headers
         };
 
+        // Add the docker registry headers.
+        if (req.headers['x-registry-config'] !== undefined) {
+            headers['x-registry-config'] = req.headers['x-registry-config'];
+        }
+
+        if (req.headers['x-registry-auth'] !== undefined) {
+            headers['x-registry-auth'] = req.headers['x-registry-auth'];
+        }
+
         cnapiCommitPayload.account_uuid = req.account.uuid;
         cnapiCommitPayload.command = 'commit';  // Command type.
         cnapiCommitPayload.fromImage = utils.imgobjToInspect(baseImg);
diff --git a/lib/backends/sdc/containers.js b/lib/backends/sdc/containers.js
index e3af48b..f0d04aa 100644
--- a/lib/backends/sdc/containers.js
+++ b/lib/backends/sdc/containers.js
@@ -3751,27 +3751,37 @@ function _createLinestreamParser(opts, toSocket) {
         opts.log.error({ err: err }, 'LineStream threw an error');
     });
 
-    lstream.on('line', function (line) {
-        line = line.trim();
-        if (!line) {
-            return;
-        }
-
-        var parsed = JSON.parse(line);
-
-        if (parsed.type === 'tty') {
-            toSocket.write(parsed.data);
-        } else if (parsed.type === 'end') {
-            opts.socketData.ExitCode = parsed.data.code;
-            if (!opts.noCloseOnSocketEnd) {
-                toSocket.end();
+    /**
+     * Ensure the lstream instance does not hit its high watermark and stop
+     * emitting 'line' events.
+     */
+    lstream.on('readable', function () {
+        var line;
+        while ((line = lstream.read()) != null) {
+            line = line.trim();
+            try {
+                var parsed = JSON.parse(line);
+            } catch (e) {
+                opts.log.error(
+                    '_createLinestreamParser: invalid json: %s - ignoring',
+                    data);
+                continue;
             }
-        } else { // else stderr or stdout
-            var data = parsed.data;
-            if (encodeData) {
-                data = _encodeToDockerRawStream(parsed.type, parsed.data);
+
+            if (parsed.type === 'tty') {
+                toSocket.write(parsed.data);
+            } else if (parsed.type === 'end') {
+                opts.socketData.ExitCode = parsed.data.code;
+                if (!opts.noCloseOnSocketEnd) {
+                    toSocket.end();
+                }
+            } else { // else stderr or stdout
+                var data = parsed.data;
+                if (encodeData) {
+                    data = _encodeToDockerRawStream(parsed.type, parsed.data);
+                }
+                toSocket.write(data);
             }
-            toSocket.write(data);
         }
     });
 
diff --git a/lib/docker.js b/lib/docker.js
index 2f25b34..8629fe3 100644
--- a/lib/docker.js
+++ b/lib/docker.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2015, Joyent, Inc.
+ * Copyright (c) 2016, Joyent, Inc.
  */
 
 /*
@@ -25,6 +25,7 @@ var sbs = require('sdc-bunyan-serializers');
 var os = require('os');
 var path = require('path');
 var restify = require('restify');
+var formatJSON = require('restify/lib/formatters/json');
 var UFDS = require('ufds');
 var vasync = require('vasync');
 var verror = require('verror');
@@ -42,7 +43,6 @@ var errors = require('./errors');
 var hijack = require('./hijack');
 var models = require('./models');
 var SocketManager = require('./socket-manager');
-var upgrade = require('./upgrade');
 var wfapi = require('./wfapi');
 var configLoader = require('./config-loader');
 
@@ -87,49 +87,19 @@ function App(opts) {
 
     var server = self.server = self.setupServer();
 
-    server.on('upgrade', function (oldreq, socket, body) {
-        self.log.info('Socket has been hijacked');
+    server.server.on('upgrade', function (oldreq, socket, body) {
+        self.log.info('Socket has been upgraded');
 
         // Unfortunately there's no way of detecting the docker client's
         // intentions at this point so we just have to override onread
         // on every upgrade (attach, exec) request. We make sure to do
         // this only on TLS requests
-        if (oldreq.hijacked && self.config.useTls) {
+        if (hijack.canHijack(oldreq) && self.config.useTls) {
+            self.log.info('setting half-close mode on upgraded client socket');
             hijack.setHalfClose(self.log, oldreq, socket);
         }
-
-        // New hijacks can make use of restify's handleUpgrades mechanism
-        if (hijack.isNewHijack(oldreq)) {
-            oldreq._upgradeRequest = true;
-
-            var res = upgrade.createResponse(oldreq, socket, body);
-            server._setupRequest(oldreq, res);
-            server._handle(oldreq, res);
-        } else {
-            socket.unshift(body);
-        }
     });
 
-    /*
-     * HACK: Monkey-patch restify's `http.ServerResponse.format` to default
-     * to text/plain for errors without breaking the default of
-     * application/json for successful responses. Restify doesn't currently
-     * provide a hook to do this.
-     *
-     * Warning: Restify only overrides http.ServerResponse after `createServer`
-     * is called because its "server.js" is lazily imported.
-     */
-    var Response = http.ServerResponse;
-    Response.prototype._old_format = Response.prototype.format;
-    Response.prototype.format = function _my_format(body, cb) {
-        var type = this.contentType || this.getHeader('Content-Type');
-        if (!type && body instanceof Error) {
-            this.contentType = 'text/plain';
-        }
-        return this._old_format(body, cb);
-    };
-
-
     server.use(function (req, res, next) {
         // Headers we want for all responses.
         res.on('header', function onHeader() {
@@ -287,13 +257,22 @@ App.prototype.setupServer = function () {
         log: self.log,
         name: 'sdc-docker',
         version: self.version,
+        handleUpgrades: true,
         formatters: {
             /*
              * `q=0.3` is the same q-value in restify's default formatters.
              * I.e. we want to change this formatter, not change preferred
              * ordering.
              */
-            'text/plain; q=0.3': errors.formatErrOrText
+            'text/plain; q=0.3': errors.formatErrOrText,
+            'application/json': function (req, res, body, cb) {
+                if (body instanceof Error) {
+                    res.setHeader('content-type', 'text/plain');
+                    return errors.formatErrOrText(req, res, body, cb);
+                } else {
+                    return formatJSON(req, res, body, cb);
+                }
+            }
         }
     };
 
@@ -307,31 +286,7 @@ App.prototype.setupServer = function () {
         serverOpts.httpsServerOptions = tlsOpts;
     }
 
-    var server = restify.createServer(serverOpts);
-
-    if (!self.config.useTls) {
-        server.on('connection', function (socket) {
-            hijack.hijack({
-                socket: socket,
-                log: self.log
-            });
-        });
-
-        return server;
-    }
-
-    /*
-     * TLS setup
-     */
-
-    server.on('secureConnection', function (cleartextStream) {
-        hijack.hijack({
-            socket: cleartextStream,
-            log: self.log
-        });
-    });
-
-    return server;
+    return restify.createServer(serverOpts);
 };
 
 App.prototype.setupAdminSever = function listen(callback) {
@@ -409,16 +364,10 @@ App.prototype.close = function close(callback) {
 App.prototype.createMorayClient = function createMorayClient() {
     var self = this;
     var conf = {
-        connectTimeout: 1000,
         host: self.config.moray.host,
         noCache: true,
         port: self.config.moray.port,
-        reconnect: true,
-        retry: {
-            retries: Infinity,
-            maxTimeout: 6000,
-            minTimeout: 100
-        }
+        reconnect: true
     };
 
     self.log.debug(conf, 'Creating moray client');
diff --git a/lib/endpoints/containers.js b/lib/endpoints/containers.js
index db2e09e..84ee714 100644
--- a/lib/endpoints/containers.js
+++ b/lib/endpoints/containers.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2015, Joyent, Inc.
+ * Copyright (c) 2016, Joyent, Inc.
  */
 
 var assert = require('assert-plus');
@@ -952,10 +952,20 @@ function register(http, before) {
         next();
     }
 
+    var queryParserOpts = {
+        mapParams: false,
+
+        // See: ZAPI-744:
+        allowDots: false,
+        plainObjects: false
+    };
+
+    var queryParser = restify.queryParser(queryParserOpts);
+
     // Match: '/:apiversion/containers/json'
     http.get({ path: /^(\/v[^\/]+)?\/containers\/json$/,
         name: 'ContainerList' }, before, getImages,
-        restify.queryParser({mapParams: false}), containerList);
+        queryParser, containerList);
 
     // Match: '/:apiversion/containers/create'
     http.post({ path: /^(\/v[^\/]+)?\/containers\/create$/,
@@ -965,7 +975,7 @@ function register(http, before) {
         validate.createContainer,
         common.checkApprovedForProvisioning,
         common.reqImageIncludeSmartos,
-        restify.queryParser({mapParams: false}),
+        queryParser,
         containerCreate);
 
     // Match: '/:apiversion/containers/:id/json'
@@ -977,17 +987,17 @@ function register(http, before) {
     // Match: '/:apiversion/containers/:id/top'
     http.get({ path: /^(\/v[^\/]+)?\/containers\/([^\/]+)\/top$/,
         name: 'ContainerTop' }, before, reqParamsId, getVm,
-        restify.queryParser({mapParams: false}), containerTop);
+        queryParser, containerTop);
 
     // Match: '/:apiversion/containers/:id/logs'
     http.get({ path: /^(\/v[^\/]+)?\/containers\/([^\/]+)\/logs$/,
         name: 'ContainerLogs' }, before, reqParamsId, getVm,
-        restify.queryParser({mapParams: false}), containerLogs);
+        queryParser, containerLogs);
 
     // Match: '/:apiversion/containers/:id/stats'
     http.get({ path: /^(\/v[^\/]+)?\/containers\/([^\/]+)\/stats$/,
         name: 'ContainerStats' }, before, reqParamsId, getVm,
-        restify.queryParser({mapParams: false}), containerStats);
+        queryParser, containerStats);
 
     // Match: '/:apiversion/containers/:id/changes'
     http.get({ path: /^(\/v[^\/]+)?\/containers\/([^\/]+)\/changes$/,
@@ -1001,7 +1011,7 @@ function register(http, before) {
     // Match: '/:apiversion/containers/:id/resize'
     http.post({ path: /^(\/v[^\/]+)?\/containers\/([^\/]+)\/resize$/,
         name: 'ContainerResize' }, before, reqParamsId, getVm,
-        restify.queryParser({mapParams: false}), containerResize);
+        queryParser, containerResize);
 
     // Match: '/:apiversion/containers/:id/start'
     http.post({ path: /^(\/v[^\/]+)?\/containers\/([^\/]+)\/start$/,
@@ -1010,7 +1020,7 @@ function register(http, before) {
     // Match: '/:apiversion/containers/:id/stop'
     http.post({ path: /^(\/v[^\/]+)?\/containers\/([^\/]+)\/stop$/,
         name: 'ContainerStop' }, before, reqParamsId, getVm,
-        restify.queryParser({mapParams: false}), containerStop);
+        queryParser, containerStop);
 
     // Match: '/:apiversion/containers/:id/restart'
     http.post({ path: /^(\/v[^\/]+)?\/containers\/([^\/]+)\/restart$/,
@@ -1033,7 +1043,7 @@ function register(http, before) {
     // Match: '/:apiversion/containers/:id/attach'
     http.post({ path: /^(\/v[^\/]+)?\/containers\/([^\/]+)\/attach$/,
         name: 'ContainerAttach' }, before, reqParamsId, getVm,
-        restify.queryParser({mapParams: false}), containerAttach);
+        queryParser, containerAttach);
 
     // Match: '/:apiversion/containers/:id/wait'
     http.post({ path: /^(\/v[^\/]+)?\/containers\/([^\/]+)\/wait$/,
@@ -1042,7 +1052,7 @@ function register(http, before) {
     // Match: '/:apiversion/containers/:id'
     http.del({ path: /^(\/v[^\/]+)?\/containers\/([^\/]+)$/,
         name: 'ContainerDelete' }, before, reqParamsId, getVm,
-        restify.queryParser({mapParams: false}), containerDelete);
+        queryParser, containerDelete);
 
     // Match: '/:apiversion/containers/:id/link'
     http.del({ path: /^(\/v[^\/]+)?\/containers\/([^\/]+)\/([^\/]+)$/,
@@ -1063,19 +1073,19 @@ function register(http, before) {
     // Match: '/:apiversion/containers/:id/archive'
     http.get({ path: /^(\/v[^\/]+)?\/containers\/([^\/]+)\/archive$/,
         name: 'ContainerReadArchive' }, before, reqParamsId, getVm,
-        restify.queryParser({mapParams: false}),
+        queryParser,
         validate.archiveReadStream, containerReadArchive);
 
     // Match: '/:apiversion/containers/:id/archive'
     http.put({ path: /^(\/v[^\/]+)?\/containers\/([^\/]+)\/archive$/,
         name: 'ContainerWriteArchive' }, before, reqParamsId, getVm,
-        restify.queryParser({mapParams: false}),
+        queryParser,
         validate.archiveWriteStream, containerWriteArchive);
 
     // Match: '/:apiversion/containers/:id/archive'
     http.head({ path: /^(\/v[^\/]+)?\/containers\/([^\/]+)\/archive$/,
         name: 'ContainerStatArchive' }, before, reqParamsId, getVm,
-        restify.queryParser({mapParams: false}),
+        queryParser,
         validate.archiveReadStream, containerStatArchive);
 
 
@@ -1087,7 +1097,7 @@ function register(http, before) {
     // Match: '/:apiversion/containers/:id/rename'
     http.post({ path: /^(\/v[^\/]+)?\/containers\/([^\/]+)\/rename$/,
         name: 'ContainerRename' }, before, reqParamsId, getVm,
-        restify.queryParser({mapParams: false}), containerRename);
+        queryParser, containerRename);
 }
 
 module.exports = {
diff --git a/lib/errors.js b/lib/errors.js
index 85450a3..6003ac4 100644
--- a/lib/errors.js
+++ b/lib/errors.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2015, Joyent, Inc.
+ * Copyright (c) 2016, Joyent, Inc.
  */
 
 /*
@@ -112,7 +112,7 @@ var RestError = restify.RestError;
  * Extend the default Restify 'text/plain' formatter to include the
  * `err.restCode` string in returned error messages.
  */
-function formatErrOrText(req, res, body) {
+function formatErrOrText(req, res, body, cb) {
     if (body instanceof Error) {
         res.statusCode = body.statusCode || 500;
         if (body.restCode && body.restCode !== 'DockerError') {
@@ -136,7 +136,7 @@ function formatErrOrText(req, res, body) {
         res.setHeader('Content-Length', Buffer.byteLength(body));
     }
 
-    return (body);
+    return cb(null, body);
 }
 
 
diff --git a/lib/hijack.js b/lib/hijack.js
index 5bde105..8bd5657 100644
--- a/lib/hijack.js
+++ b/lib/hijack.js
@@ -5,10 +5,11 @@
  */
 
 /*
- * Copyright (c) 2014, Joyent, Inc.
+ * Copyright (c) 2016, Joyent, Inc.
  */
 
 var assert = require('assert-plus');
+var uv = process.binding('uv');
 
 var HIJACK_ROUTES = {
     'POST': [
@@ -17,16 +18,15 @@ var HIJACK_ROUTES = {
     ]
 };
 
-function canHjiack(req) {
+function canHijack(req) {
     var hijackRoutes = HIJACK_ROUTES[req.method];
     if (!hijackRoutes) {
         return false;
     }
 
-    // Can't hijack new 1.17 requests since they are already handled by http.js
     if (req.upgrade === true) {
         req.hijacked = true;
-        return false;
+        return true;
     }
 
     // Should match only one route
@@ -41,45 +41,6 @@ function canHjiack(req) {
     return true;
 }
 
-function hijack(opts) {
-    assert.object(opts.socket, 'opts.socket');
-    assert.object(opts.log, 'opts.log');
-
-    var log = opts.log;
-    var socket = opts.socket;
-    var parser = socket.parser;
-
-    // Stash our original parser functions
-    var execute = parser.execute;
-
-    socket.on('close', function () {
-        log.trace('Client connection closed');
-    });
-
-    parser.execute = function (d, start, end) {
-        var ret = execute.call(this, d, start, end);
-
-        if (parser.incoming && canHjiack(parser.incoming)) {
-            parser.incoming.upgrade = true;
-            parser.incoming.hijacked = true;
-            return (ret instanceof Error) ? ret.bytesParsed : ret;
-        } else {
-            return ret;
-        }
-    };
-}
-
-/*
- * Newer hijack employs a regular connection: upgrade handshake
- */
-function isNewHijack(req) {
-    var connection = req.header('connection');
-    var upgrade = req.header('upgrade');
-
-    return (connection && connection.toLowerCase() === 'upgrade'
-        && upgrade && upgrade.toLowerCase() === 'tcp');
-}
-
 
 /*
  * Node doesn't really support half-close connections with tls, but
@@ -87,13 +48,13 @@ function isNewHijack(req) {
  * connections that have been hijacked
  */
 function setHalfClose(log, req, socket) {
-    var oldread = socket.socket._handle.onread;
-    socket.socket._handle.onread = halfCloseRead;
+    var oldread = socket._handle.onread;
+    socket._handle.onread = halfCloseRead;
 
-    function halfCloseRead(buf, offset, len) {
+    function halfCloseRead(nread, buf) {
         // cache the errno on the first pass and
         // use that cache value subsequently
-        if (!buf && process._errno === 'EOF') {
+        if (nread === uv.UV_EOF) {
             log.info('Entered half-close mode for %s', req.url);
         } else {
             oldread.apply(this, arguments);
@@ -103,8 +64,6 @@ function setHalfClose(log, req, socket) {
 
 
 module.exports = {
-    hijack: hijack,
-    canHjiack: canHjiack,
-    isNewHijack: isNewHijack,
+    canHijack: canHijack,
     setHalfClose: setHalfClose
 };
diff --git a/lib/upgrade.js b/lib/upgrade.js
deleted file mode 100644
index b0c8981..0000000
--- a/lib/upgrade.js
+++ /dev/null
@@ -1,186 +0,0 @@
-// Copyright (c) 2013, Joyent, Inc. All rights reserved.
-
-/**
- * Copied from
- * https://github.com/mcavage/node-restify/blob/master/lib/upgrade.js
- */
-
-var EventEmitter = require('events').EventEmitter;
-var util = require('util');
-var assert = require('assert-plus');
-
-function InvalidUpgradeStateError(msg) {
-    if (Error.captureStackTrace)
-        Error.captureStackTrace(this, InvalidUpgradeStateError);
-
-    this.message = msg;
-    this.name = 'InvalidUpgradeStateError';
-}
-util.inherits(InvalidUpgradeStateError, Error);
-
-//
-// The Node HTTP Server will, if we handle the 'upgrade' event, swallow any
-// Request with the 'Connection: upgrade' header set.  While doing this it
-// detaches from the 'data' events on the Socket and passes the socket to
-// us, so that we may take over handling for the connection.
-//
-// Unfortunately, the API does not presently provide a http.ServerResponse
-// for us to use in the event that we do not wish to upgrade the connection.
-// This factory method provides a skeletal implementation of a
-// restify-compatible response that is sufficient to allow the existing
-// request handling path to work, while allowing us to perform _at most_ one
-// of either:
-//
-//   - Return a basic HTTP Response with a provided Status Code and
-//     close the socket.
-//   - Upgrade the connection and stop further processing.
-//
-// To determine if an upgrade is requested, a route handler would check for
-// the 'claimUpgrade' method on the Response.  The object this method
-// returns will have the 'socket' and 'head' Buffer emitted with the
-// 'upgrade' event by the http.Server.  If the upgrade is not possible, such
-// as when the HTTP head (or a full request) has already been sent by some
-// other handler, this method will throw.
-//
-function createServerUpgradeResponse(req, socket, head) {
-    return (new ServerUpgradeResponse(socket, head));
-}
-
-function ServerUpgradeResponse(socket, head) {
-    assert.object(socket, 'socket');
-    assert.buffer(head, 'head');
-
-    EventEmitter.call(this);
-
-    this.sendDate = true;
-    this.statusCode = 400;
-
-    this._upgrade = {
-        socket: socket,
-        head: head
-    };
-
-    this._headWritten = false;
-    this._upgradeClaimed = false;
-}
-util.inherits(ServerUpgradeResponse, EventEmitter);
-
-function notImplemented(method) {
-    if (!method.throws) {
-        return function () {
-            return (method.returns);
-        };
-    } else {
-        return function () {
-            throw (new Error('Method ' + method.name + ' is not '
-                + 'implemented!'));
-        };
-    }
-}
-
-var NOT_IMPLEMENTED = [
-    { name: 'writeContinue', throws: true },
-    { name: 'setHeader', throws: false, returns: null },
-    { name: 'getHeader', throws: false, returns: null },
-    { name: 'getHeaders', throws: false, returns: {} },
-    { name: 'removeHeader', throws: false, returns: null },
-    { name: 'addTrailer', throws: false, returns: null },
-    { name: 'cache', throws: false, returns: 'public' },
-    { name: 'format', throws: true },
-    { name: 'set', throws: false, returns: null },
-    { name: 'get', throws: false, returns: null },
-    { name: 'headers', throws: false, returns: {} },
-    { name: 'header', throws: false, returns: null },
-    { name: 'json', throws: false, returns: null },
-    { name: 'link', throws: false, returns: null }
-];
-NOT_IMPLEMENTED.forEach(function (method) {
-    ServerUpgradeResponse.prototype[method.name] = notImplemented(method);
-});
-
-ServerUpgradeResponse.prototype._writeHeadImpl =
-    function _writeHeadImpl(statusCode, reason) {
-        if (this._headWritten)
-            return;
-        this._headWritten = true;
-
-        if (this._upgradeClaimed)
-            throw new InvalidUpgradeStateError('Upgrade already claimed!');
-
-        var head = [
-            'HTTP/1.1 ' + statusCode + ' ' + reason,
-            'Connection: close'
-        ];
-        if (this.sendDate)
-            head.push('Date: ' + new Date().toUTCString());
-
-        this._upgrade.socket.write(head.join('\r\n') + '\r\n');
-    };
-
-ServerUpgradeResponse.prototype.status = function status(code) {
-    assert.number(code, 'code');
-    this.statusCode = code;
-    return (code);
-};
-
-ServerUpgradeResponse.prototype.send = function send(code, body) {
-    if (typeof (code) === 'number')
-        this.statusCode = code;
-    else
-        body = code;
-
-    if (typeof (body) === 'object') {
-        if (typeof (body.statusCode) === 'number')
-            this.statusCode = body.statusCode;
-        if (typeof (body.message) === 'string')
-            this.statusReason = body.message;
-    }
-
-    return (this.end());
-};
-
-ServerUpgradeResponse.prototype.end = function end() {
-    this._writeHeadImpl(this.statusCode, 'Connection Not Upgraded');
-    this._upgrade.socket.end('\r\n');
-    return (true);
-};
-
-ServerUpgradeResponse.prototype.write = function write() {
-    this._writeHeadImpl(this.statusCode, 'Connection Not Upgraded');
-    return (true);
-};
-
-ServerUpgradeResponse.prototype.writeHead =
-    function writeHead(statusCode, reason) {
-        assert.number(statusCode, 'statusCode');
-        assert.optionalString(reason, 'reason');
-
-        this.statusCode = statusCode;
-        if (!reason)
-            reason = 'Connection Not Upgraded';
-
-        if (this._headWritten)
-            throw new Error('Head already written!');
-
-        return (this._writeHeadImpl(statusCode, reason));
-    };
-
-ServerUpgradeResponse.prototype.claimUpgrade = function claimUpgrade() {
-    if (this._upgradeClaimed)
-        throw new InvalidUpgradeStateError('Upgrade already claimed!');
-
-    if (this._headWritten)
-        throw new InvalidUpgradeStateError('Upgrade already aborted!');
-
-    this._upgradeClaimed = true;
-
-    return (this._upgrade);
-};
-
-module.exports = {
-    createResponse: createServerUpgradeResponse,
-
-    InvalidUpgradeStateError: InvalidUpgradeStateError
-};
-
-// vim: set et ts=8 sts=8 sw=8:
\ No newline at end of file
diff --git a/lib/wfapi/workflows/pull-image.js b/lib/wfapi/workflows/pull-image.js
index e84cc84..cbae6ba 100644
--- a/lib/wfapi/workflows/pull-image.js
+++ b/lib/wfapi/workflows/pull-image.js
@@ -175,14 +175,14 @@ function pullImageLayers(job, cb) {
             cb(lerr);
         });
 
-        lstream.on('line', function (line) {
-            line = line.trim();
-            if (!line) {
-                return;
-            }
+        lstream.on('readable', function () {
+            var line;
+            while ((line = lstream.read()) != null) {
+                line = line.trim();
 
-            var data = JSON.parse(line);
-            queue.push(data);
+                var data = JSON.parse(line);
+                queue.push(data);
+            }
         });
 
         res.on('end', function onEnd() {
diff --git a/package.json b/package.json
index ee3f6a3..4e1b72b 100644
--- a/package.json
+++ b/package.json
@@ -1,44 +1,43 @@
 {
   "name": "sdc-docker",
-  "version": "0.3.2",
+  "version": "0.4.0",
   "author": "Joyent (joyent.com)",
   "private": true,
   "dependencies": {
     "assert-plus": "1.0.0",
     "async": "0.9.0",
-    "bunyan": "1.3.2",
     "docker-registry-client": "3.2.4",
+    "bunyan": "1.8.5",
     "effluent-logger": "git+https://github.com/joshwilsdon/effluent-logger.git#d662f161a07f94045ad2afb45442931511c40e51",
     "fwrule": "git+https://github.com/joyent/sdc-fwrule.git#d1174be",
     "imgmanifest": "git+https://github.com/joyent/node-imgmanifest.git#91e5d80",
-    "keyapi": "git+https://github.com/joyent/keyapi.git#c30dd2710ad2175095dc0e96479686fa774b8063",
-    "libuuid": "0.1.3",
+    "keyapi": "git+https://github.com/joyent/keyapi.git#e14b3d5",
+    "libuuid": "0.2.1",
     "lru-cache": "2.5.0",
     "lstream": "0.0.4",
-    "moray": "git+https://github.com/joyent/node-moray.git#b84ef0e",
+    "moray": "2.0.0",
     "once": "1.3.1",
     "openssl-wrapper": "0.2.1",
-    "restify": "git+https://github.com/joyent/node-restify.git#fd5d5b5",
-    "sdc-bunyan-serializers": "git+https://github.com/joyent/sdc-bunyan-serializers.git#5454ae4",
+    "restify": "4.2.0",
+    "sdc-bunyan-serializers": "git+https://github.com/joyent/sdc-bunyan-serializers.git#a3e7780",
     "sdc-clients": "10.0.1",
     "sprintf": "0.1.5",
-    "sshpk": "1.8.3",
+    "sshpk": "1.10.0",
     "strsplit": "1.0.0",
     "tape": "^4.4.0",
     "trace-event": "1.2.0",
     "triton-tags": "1.0.0",
-    "ufds": "git+https://github.com/joyent/node-ufds.git#c7aa563",
+    "ufds": "1.2.0",
     "vasync": "1.6.3",
     "verror": "1.6.0",
-    "wf-client": "git+https://github.com/joyent/sdc-wf-client.git#946d33b",
+    "wf-client": "0.2.0",
     "xregexp": "3.1.0"
   },
   "devDependencies": {
     "deep-equal": "~0.2.0",
     "difflet": "0.2.6",
-    "manta": "1.4.5",
+    "manta": "3.1.2",
     "semver": "5.1.0",
-    "tape": "^4.4.0",
     "tar-stream": "1.3.1",
     "xtend": "^4.0.0"
   },
diff --git a/sapi_manifests/docker/template b/sapi_manifests/docker/template
index 6f3d7b1..a056637 100644
--- a/sapi_manifests/docker/template
+++ b/sapi_manifests/docker/template
@@ -29,12 +29,7 @@
     "moray": {
         "logLevel": "info",
         "host": "{{{MORAY_SERVICE}}}",
-        "port": 2020,
-        "connectTimeout": 200,
-        "retry": {
-            "retries": 2,
-            "minTimeout": 500
-        }
+        "port": 2020
     },
     "fwapi": {
         "url": "http://fwapi.{{{datacenter_name}}}.{{{dns_domain}}}"
diff --git a/test/integration/api-create.test.js b/test/integration/api-create.test.js
index f0c4890..97dfe07 100644
--- a/test/integration/api-create.test.js
+++ b/test/integration/api-create.test.js
@@ -111,7 +111,6 @@ test('setup', function (tt) {
             t.end();
         });
     });
-
 });
 
 test('api: create with non-string label values (DOCKER-737)', function (t) {
@@ -634,13 +633,3 @@ test('create with NetworkMode (docker run --net=)', function (tt) {
         }
     });
 });
-
-test('cleanup', function (tt) {
-    tt.test('delete nginx image', function (t) {
-        DOCKER_ALICE.del('/images/nginx', ondel);
-        function ondel(err, req, res) {
-            t.error(err, 'should be no error deleting nginx');
-            t.end();
-        }
-    });
-});
diff --git a/test/integration/cli-attach.test.js b/test/integration/cli-attach.test.js
index e82e88f..ab76357 100644
--- a/test/integration/cli-attach.test.js
+++ b/test/integration/cli-attach.test.js
@@ -16,6 +16,8 @@ var test = require('tape');
 var vasync = require('vasync');
 
 var cli = require('../lib/cli');
+var configLoader = require('../../lib/config-loader.js');
+var h = require('./helpers');
 
 
 // --- Globals
@@ -23,7 +25,10 @@ var cli = require('../lib/cli');
 var CONTAINER_PREFIX = 'sdcdockertest_';
 var container = CONTAINER_PREFIX + 'attach_test';
 
-var log = require('../lib/log');
+var STATE = {
+    log: require('../lib/log')
+};
+var ALICE;
 
 
 /**
@@ -31,7 +36,27 @@ var log = require('../lib/log');
  */
 
 test('setup', function (tt) {
+    tt.test('docker env', function (t) {
+        h.initDockerEnv(t, STATE, {}, function (err, accounts) {
+            t.ifErr(err);
+
+            ALICE = accounts.alice;
+
+            t.end();
+        });
+    });
+
     tt.test('DockerEnv: alice init', cli.init);
+
+    tt.test('pull nginx image', function (t) {
+        h.ensureImage({
+            name: 'nginx:latest',
+            user: ALICE
+        }, function (err) {
+            t.error(err, 'should be no error pulling image');
+            t.end();
+        });
+    });
 });
 
 
diff --git a/test/integration/cli-copy.test.js b/test/integration/cli-copy.test.js
index bc29516..7c19b48 100644
--- a/test/integration/cli-copy.test.js
+++ b/test/integration/cli-copy.test.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2015, Joyent, Inc.
+ * Copyright (c) 2016, Joyent, Inc.
  */
 
 /*
@@ -25,7 +25,12 @@ var util = require('util');
 var cli = require('../lib/cli');
 var h = require('./helpers');
 var vm = require('../lib/vm');
+var configLoader = require('../../lib/config-loader.js');
 
+var STATE = {
+    log: require('../lib/log')
+};
+var ALICE;
 
 /* BEGIN JSSTYLED */
 /**
@@ -107,8 +112,28 @@ var nginxName2 = CONTAINER_PREFIX + 'nginx2';
  */
 
 test('setup', function (tt) {
+    tt.test('docker env', function (t) {
+        h.initDockerEnv(t, STATE, {}, function (err, accounts) {
+            t.ifErr(err);
+
+            ALICE = accounts.alice;
+
+            t.end();
+        });
+    });
+
     tt.test('DockerEnv: alice init', cli.init);
     tt.test('vmapi client', vm.init);
+
+    tt.test('pull nginx image', function (t) {
+        h.ensureImage({
+            name: 'nginx:latest',
+            user: ALICE
+        }, function (err) {
+            t.error(err, 'should be no error pulling image');
+            t.end();
+        });
+    });
 });
 
 
diff --git a/test/integration/cli-pull.test.js b/test/integration/cli-pull.test.js
index ed53886..e9ddcda 100644
--- a/test/integration/cli-pull.test.js
+++ b/test/integration/cli-pull.test.js
@@ -31,7 +31,10 @@ test('docker pull', function (tt) {
      * Check for reasonable error messages for some 'docker pull' failures.
      * Some related issues: DOCKER-639, DOCKER-689
      */
-    tt.test('  docker pull no-such-repo (error message)', function (t) {
+    /*
+     * XXX: Skipped pending DOCKER-976.
+     */
+    tt.skip('  docker pull no-such-repo (error message)', function (t) {
         cli.docker('pull no-such-repo', function (err, stdout, stderr) {
             // JSSTYLED
             // I.e. this error message: https://github.com/docker/distribution/blob/master/registry/api/errcode/register.go#L40
@@ -54,7 +57,10 @@ test('docker pull', function (tt) {
         });
     });
 
-    tt.test('  docker pull quay.io/no-such-user (error message)', function (t) {
+    /*
+     * XXX: Skipped pending DOCKER-976.
+     */
+    tt.skip('  docker pull quay.io/no-such-user (error message)', function (t) {
         cli.docker('pull quay.io/no-such-user',
                 function (err, stdout, stderr) {
             var match;
diff --git a/test/unit/affinity.test.js b/test/unit/affinity.test.js
index f29488a..28c1662 100644
--- a/test/unit/affinity.test.js
+++ b/test/unit/affinity.test.js
@@ -26,7 +26,7 @@ var localityFromContainer = require('../../lib/backends/sdc/affinity')
 
 var log = bunyan.createLogger({
     name: 'affinity.test',
-    level: process.env.TRACE ? 'trace' : 'off',
+    level: process.env.TRACE ? 'trace' : bunyan.FATAL + 1 /* off */,
     req_id: '655b2da4-3165-9549-8626-531ef9336e1e'
 });
 
