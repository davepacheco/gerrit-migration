From dc922c9cf9b112bcb3e42ed9d744acb50d83228b Mon Sep 17 00:00:00 2001
From: Brittany Wald <brittany.wald@joyent.com>
Date: Thu, 24 Aug 2017 23:22:40 +0000
Subject: [PATCH] MANTA-3394 node-fash linter does not check some files

---
 lib/backend/in_memory.js | 265 ++++++++++++++++----------------
 lib/backend/leveldb.js   | 315 ++++++++++++++++++++-------------------
 lib/common.js            |   3 +-
 lib/dtrace.js            |  56 +++----
 lint.sh                  |   2 +-
 package.json             |   2 +-
 6 files changed, 329 insertions(+), 314 deletions(-)

diff --git a/lib/backend/in_memory.js b/lib/backend/in_memory.js
index 6e76bf0..6b9c231 100644
--- a/lib/backend/in_memory.js
+++ b/lib/backend/in_memory.js
@@ -48,7 +48,7 @@ var DATA_NULL = 1;
  *                 topology.
  */
 function ConsistentHash(options, callback) {
-    dtrace._fash_probes['new-start'].fire(function() { return([]); });
+    dtrace._fash_probes['new-start'].fire(function () { return ([]); });
     assert.object(options, 'options');
 
     this.log = options.log;
@@ -122,10 +122,10 @@ function ConsistentHash(options, callback) {
         self.pnodeToVnodeMap_ = topology.pnodeToVnodeMap;
         var pnodeKeys = Object.keys(self.pnodeToVnodeMap_);
 
-        pnodeKeys.forEach(function(pnode) {
+        pnodeKeys.forEach(function (pnode) {
             self.pnodes_.push(pnode);
             var vnodes = self.pnodeToVnodeMap_[pnode];
-            Object.keys(vnodes).forEach(function(vnode) {
+            Object.keys(vnodes).forEach(function (vnode) {
                 var data = vnodes[vnode];
                 self.vnodeToPnodeMap_[vnode] = {
                     pnode: pnode,
@@ -142,18 +142,18 @@ function ConsistentHash(options, callback) {
         self.pnodes_.sort();
 
         log.info('ConsistentHash.new: finished deserializing');
-        dtrace._fash_probes['new-done'].fire(function() {
+        dtrace._fash_probes['new-done'].fire(function () {
             return ([null, 'deserialize']);
         });
     } else {
         log.info('instantiating new ring from scratch.');
         // instantiate pnodeToVnodeMap_
-        self.pnodes_.forEach(function(pnode, index) {
+        self.pnodes_.forEach(function (pnode, index) {
             // make sure there are no duplicate keys in self.pnodes_
             if (pnodeMap[pnode]) {
                 var err = new verror.VError('Unable to instantiate ring, ' +
                     'duplicate pnodes in input');
-                dtrace._fash_probes['new-done'].fire(function() {
+                dtrace._fash_probes['new-done'].fire(function () {
                     return ([err ? err.message : null, 'createNewRing']);
                 });
                 if (callback) {
@@ -206,7 +206,7 @@ function ConsistentHash(options, callback) {
             }
         }
         allocateVnode();
-        dtrace._fash_probes['new-done'].fire(function() {
+        dtrace._fash_probes['new-done'].fire(function () {
             return ([null, 'createNewRing']);
         });
     }
@@ -237,8 +237,8 @@ module.exports = ConsistentHash;
  * @param {function} cb The optional callback f(err).
  */
 ConsistentHash.prototype.addData = function addData(vnode, data, cb) {
-    dtrace._fash_probes['adddata-start'].fire(function() {
-        return([vnode, data]);
+    dtrace._fash_probes['adddata-start'].fire(function () {
+        return ([vnode, data]);
     });
     var self = this;
     var log = self.log;
@@ -286,8 +286,8 @@ ConsistentHash.prototype.addData = function addData(vnode, data, cb) {
         data: data
     }, 'ConsistentHash.addData: exiting');
 
-    dtrace._fash_probes['adddata-done'].fire(function() {
-        return([null, vnode, data]);
+    dtrace._fash_probes['adddata-done'].fire(function () {
+        return ([null, vnode, data]);
     });
 
     if (cb) {
@@ -319,126 +319,134 @@ ConsistentHash.prototype.getDataVnodes = function getDataVnodes(cb) {
  *                                    previous pnode owner.
  * @param {function} cb The optional callback f(err).
  */
-ConsistentHash.prototype.remapVnode = function remapVnode(newPnode, vnodes, cb) {
-    dtrace._fash_probes['remapvnode-start'].fire(function() {
-        return ([newPnode, vnodes]);
-    });
-    var self = this;
-    var log = self.log;
-    log.info({
-        newNode: newPnode,
-        vnodes: vnodes
-    }, 'ConsistentHash.remapVnode: entering');
-    assert.string(newPnode, 'newPnode');
-    if (typeof(vnodes) === 'number') {
-        vnodes = [vnodes];
-    }
-    assert.optionalArrayOfNumber(vnodes, 'vnodes');
-    assert.optionalFunc(cb, 'callback');
-
-    /*
-     * assert the vnodes, ensuring that:
-     * 1) vnode actually exist.
-     * 2) vnode doesn't already belong to the newPnode.
-     * 3) vnodes are specified once and only once.
-     */
-    var vnodeMap = {};
-    if (vnodes) {
-        vnodes.forEach(function(v) {
-            var err;
-            if ((v > self.vnodeCount_) || (v < 0)) {
-                err = new verror.VError('vnode ' + v +
-                                        ' specified more than once');
-            } else if (vnodeMap[v]) {
-                err = new verror.VError('vnode ' + v +
-                                        ' specified more than once');
-            } else if (self.vnodeToPnodeMap_[v].pnode === newPnode) {
-                // check that the vnode doesn't already belong to the newPnode.
-                err = new verror.VError('vnode ' + v +
-                                        ' already belongs to pnode');
-            }
-            if (err) {
-                dtrace._fash_probes['remapvnode-done'].fire(function() {
-                    return ([err ? err.message : null, newPnode, oldPnode,
-                             vnode]);
-                });
-                if (cb) {
-                    return cb(err);
-                }
-
-                throw err;
-            }
-            vnodeMap[v] = true;
+ConsistentHash.prototype.remapVnode =
+    function remapVnode(newPnode, vnodes, cb) {
+        dtrace._fash_probes['remapvnode-start'].fire(function () {
+            return ([newPnode, vnodes]);
         });
-    }
-
-    // if this pnode doesn't exist, create it
-    if (!self.pnodeToVnodeMap_[newPnode]) {
-        self.pnodeToVnodeMap_[newPnode] = {};
-        self.pnodes_.push(newPnode);
-        self.pnodes_.sort();
-    }
-
-    // keeps track of which pnodes have changed {pnode->vnode}
-    var changedNodes = {};
-
-    // remove vnodes from the old pnode and add to new pnode
-    for (var i = 0; i < vnodes.length; i++) {
-        var vnode = parseInt(vnodes[i], 10);
-        var oldPnode = self.vnodeToPnodeMap_[vnode].pnode;
-        var vnodeData = self.vnodeToPnodeMap_[vnode].data;
+        var self = this;
+        var log = self.log;
         log.info({
-            vnode: vnode,
-            oldPnode: oldPnode,
-            newPnode: newPnode,
-            vnodeData: vnodeData
-        }, 'ConsistentHash.remapVnode: remopping vnode');
+            newNode: newPnode,
+            vnodes: vnodes
+        }, 'ConsistentHash.remapVnode: entering');
+        assert.string(newPnode, 'newPnode');
+        if (typeof (vnodes) === 'number') {
+            vnodes = [vnodes];
+        }
+        assert.optionalArrayOfNumber(vnodes, 'vnodes');
+        assert.optionalFunc(cb, 'callback');
 
         /*
-         * add vnode to new pnode
-         * 1) move the vnode object from the old pvmap to the new pvmap. Since
-         * we're just moving the vnode, there's no need to write any new values
+         * assert the vnodes, ensuring that:
+         * 1) vnode actually exist.
+         * 2) vnode doesn't already belong to the newPnode.
+         * 3) vnodes are specified once and only once.
          */
-        self.pnodeToVnodeMap_[newPnode][vnode] =
-            self.pnodeToVnodeMap_[oldPnode][vnode];
-        // 2) add a new pnode,data object to the vpmap for the current vnode.
-        self.vnodeToPnodeMap_[vnode] = {
-            pnode: newPnode,
-            data: vnodeData
-        };
+        var vnodeMap = {};
+        if (vnodes) {
+            vnodes.forEach(function (v) {
+                var err;
+                if ((v > self.vnodeCount_) || (v < 0)) {
+                    err = new verror.VError('vnode ' + v +
+                                            ' specified more than once');
+                } else if (vnodeMap[v]) {
+                    err = new verror.VError('vnode ' + v +
+                                            ' specified more than once');
+                } else if (self.vnodeToPnodeMap_[v].pnode === newPnode) {
+                    /*
+                     * check that the vnode doesn't already belong to the
+                     * newPnode.
+                     */
+                    err = new verror.VError('vnode ' + v +
+                                            ' already belongs to pnode');
+                }
+                if (err) {
+                    dtrace._fash_probes['remapvnode-done'].fire(function () {
+                        return ([err ? err.message : null, newPnode, oldPnode,
+                                 vnode]);
+                    });
+                    if (cb) {
+                        return cb(err);
+                    }
 
-        /*
-         * remove vnode from current pnode mapping. but first set the value to
-         * 1 -- otherwise the vnode gets removed from the new pnode mappings
-         * as well.
-         */
-        self.pnodeToVnodeMap_[oldPnode][vnode] = 1;
-        delete self.pnodeToVnodeMap_[oldPnode][vnode];
+                    throw err;
+                }
+                vnodeMap[v] = true;
+            });
+        }
 
-        // update which pnodes have changed
-        if (!changedNodes[oldPnode]) {
-            changedNodes[oldPnode] = [];
+        // if this pnode doesn't exist, create it
+        if (!self.pnodeToVnodeMap_[newPnode]) {
+            self.pnodeToVnodeMap_[newPnode] = {};
+            self.pnodes_.push(newPnode);
+            self.pnodes_.sort();
         }
-        changedNodes[oldPnode].push(vnode);
-    }
 
-    log.trace({
-        pnodeToVnodeMap: self.pnodeToVnodeMap_,
-        vnodeToPnodeMap: self.vnodeToPnodeMap_
-    }, 'ConsistentHash.remapVnode: updated');
+        // keeps track of which pnodes have changed {pnode->vnode}
+        var changedNodes = {};
+
+        // remove vnodes from the old pnode and add to new pnode
+        for (var i = 0; i < vnodes.length; i++) {
+            var vnode = parseInt(vnodes[i], 10);
+            var oldPnode = self.vnodeToPnodeMap_[vnode].pnode;
+            var vnodeData = self.vnodeToPnodeMap_[vnode].data;
+            log.info({
+                vnode: vnode,
+                oldPnode: oldPnode,
+                newPnode: newPnode,
+                vnodeData: vnodeData
+            }, 'ConsistentHash.remapVnode: remopping vnode');
+
+            /*
+             * add vnode to new pnode
+             * 1) move the vnode object from the old pvmap to the new pvmap
+             * since we're just moving the vnode, there's no need to write any
+             * new values.
+             */
+            self.pnodeToVnodeMap_[newPnode][vnode] =
+                self.pnodeToVnodeMap_[oldPnode][vnode];
+            /*
+             * 2) add a new pnode,data object to the vpmap for the current
+             * vnode
+             */
+            self.vnodeToPnodeMap_[vnode] = {
+                pnode: newPnode,
+                data: vnodeData
+            };
+
+            /*
+             * remove vnode from current pnode mapping. but first set the value
+             * to 1, otherwise the vnode gets removed from the new pnode
+             * mappings as well.
+             */
+            self.pnodeToVnodeMap_[oldPnode][vnode] = 1;
+            delete self.pnodeToVnodeMap_[oldPnode][vnode];
+
+            // update which pnodes have changed
+            if (!changedNodes[oldPnode]) {
+                changedNodes[oldPnode] = [];
+            }
+            changedNodes[oldPnode].push(vnode);
+        }
 
-    log.info({
-        newNode: newPnode,
-        vnodes: vnodes
-    }, 'ConsistentHash.remapVnode: exiting');
+        log.trace({
+            pnodeToVnodeMap: self.pnodeToVnodeMap_,
+            vnodeToPnodeMap: self.vnodeToPnodeMap_
+        }, 'ConsistentHash.remapVnode: updated');
 
-    dtrace._fash_probes['remapvnode-done'].fire(function() {
-        return ([null, newPnode, oldPnode, vnode]);
-    });
-    if (cb) {
-        return cb(null);
-    }
-    return (undefined);
+        log.info({
+            newNode: newPnode,
+            vnodes: vnodes
+        }, 'ConsistentHash.remapVnode: exiting');
+
+        dtrace._fash_probes['remapvnode-done'].fire(function () {
+            return ([null, newPnode, oldPnode, vnode]);
+        });
+        if (cb) {
+            return cb(null);
+        }
+        return (undefined);
 };
 
 /*
@@ -455,7 +463,7 @@ ConsistentHash.prototype.remapVnode = function remapVnode(newPnode, vnodes, cb)
  * have changed.
  */
 ConsistentHash.prototype.removePnode = function removePnode(pnode, cb) {
-    dtrace._fash_probes['removepnode-start'].fire(function() {
+    dtrace._fash_probes['removepnode-start'].fire(function () {
         return ([pnode]);
     });
     var self = this;
@@ -480,7 +488,7 @@ ConsistentHash.prototype.removePnode = function removePnode(pnode, cb) {
     }
 
     if (err) {
-        dtrace._fash_probes['removepnode-done'].fire(function() {
+        dtrace._fash_probes['removepnode-done'].fire(function () {
             return ([err ? err.message : null, pnode]);
         });
         if (cb) {
@@ -498,7 +506,7 @@ ConsistentHash.prototype.removePnode = function removePnode(pnode, cb) {
         pnode: pnode
     }, 'ConsistentHash.removePnode: exiting');
 
-    dtrace._fash_probes['removepnode-done'].fire(function() {
+    dtrace._fash_probes['removepnode-done'].fire(function () {
         return ([err ? err.message : null, pnode]);
     });
 
@@ -553,7 +561,7 @@ ConsistentHash.prototype.getVnodes = function getVnodes(pnode, cb) {
     }
 
     var vnodeArray = [];
-    Object.keys(vnodes).forEach(function(vnode) {
+    Object.keys(vnodes).forEach(function (vnode) {
         vnodeArray.push(parseInt(vnode, 10));
     });
     log.info({
@@ -575,17 +583,18 @@ ConsistentHash.prototype.getVnodes = function getVnodes(pnode, cb) {
  * @returns {pnode, vnode} node The pnode and vnode that the key maps to.
  */
 ConsistentHash.prototype.getNode = function getNode(key, cb) {
-    dtrace._fash_probes['getnode-start'].fire(function() {
+    dtrace._fash_probes['getnode-start'].fire(function () {
         return ([key]);
     });
     assert.optionalFunc(cb, 'callback');
-    var value = crypto.createHash(this.algorithm_.NAME).update(key).digest('hex');
+    var value = crypto.createHash(this.algorithm_.NAME)
+        .update(key).digest('hex');
     // find the node that corresponds to this hash.
     var vnode = this.findVnode(value);
     var pnode = this.vnodeToPnodeMap_[vnode].pnode;
     var data = this.pnodeToVnodeMap_[pnode][vnode];
-    dtrace._fash_probes['getnode-done'].fire(function() {
-        return([null, key, value, pnode, vnode, data]);
+    dtrace._fash_probes['getnode-done'].fire(function () {
+        return ([null, key, value, pnode, vnode, data]);
     });
     if (cb) {
         return cb(null, {pnode: pnode, vnode: vnode, data: data});
diff --git a/lib/backend/leveldb.js b/lib/backend/leveldb.js
index 7758343..c1821e6 100644
--- a/lib/backend/leveldb.js
+++ b/lib/backend/leveldb.js
@@ -25,7 +25,7 @@ var verror = require('verror');
 
 
 /*
- * level db keys.
+ * LevelDB keys.
  */
 var LKEY_VNODE_COUNT = 'VNODE_COUNT';
 var LKEY_VNODE_DATA = 'VNODE_DATA';
@@ -38,12 +38,12 @@ var LKEY_VERSION = 'VERSION';
 var LKEY_COMPLETE = 'COMPLETE';
 
 /*
- * leveldb values.
+ * LevelDB values.
  */
 var LVAL_NULL = 1;
 
 /*
- * leveldb default config
+ * LevelDB default configuration.
  */
 var LEVEL_CONFIG = {
     createIfMissing: true,
@@ -79,7 +79,7 @@ var LEVEL_CONFIG = {
  *                 topology.
  */
 function ConsistentHash(options, cb) {
-    dtrace._fash_probes['new-start'].fire(function() { return([]); });
+    dtrace._fash_probes['new-start'].fire(function () { return ([]); });
     assert.object(options, 'options');
     assert.optionalObject(options.leveldbCfg, 'options.leveldbCfg');
     assert.string(options.location, 'options.location');
@@ -166,7 +166,7 @@ function ConsistentHash(options, cb) {
         var tasks = [
             function openDb(_, _cb) {
                 _cb = once(_cb);
-                levelup(options.location, self.leveldbCfg_, function(err, db) {
+                levelup(options.location, self.leveldbCfg_, function (err, db) {
                     if (err) {
                         return _cb(new verror.VError(err));
                     }
@@ -182,7 +182,7 @@ function ConsistentHash(options, cb) {
             // step 1
             function putVnodeCount(_, _cb) {
                 _cb = once(_cb);
-                _.db.put(LKEY_VNODE_COUNT, self.vnodeCount_, function(err) {
+                _.db.put(LKEY_VNODE_COUNT, self.vnodeCount_, function (err) {
                     if (err) {
                         err = new verror.VError(err);
                     }
@@ -307,7 +307,7 @@ function ConsistentHash(options, cb) {
                     }, 'writing vnode list for pnode');
                     _.db.put(sprintf(LKEY_PNODE_P, pnode),
                              _.pnodeToVnodeMap[pnode],
-                            function(err)
+                            function (err)
                     {
                         if (err) {
                             err = new verror.VError(err);
@@ -315,7 +315,7 @@ function ConsistentHash(options, cb) {
                         return _cb(err);
                     });
                 }
-                 _.db.put(LKEY_PNODE, Object.keys(pnodeMap), function(err) {
+                 _.db.put(LKEY_PNODE, Object.keys(pnodeMap), function (err) {
                     if (err) {
                         err = new verror.VError(err);
                     }
@@ -324,7 +324,7 @@ function ConsistentHash(options, cb) {
             },
             function writeVnodeDataArray(_, _cb) {
                 _cb = once(_cb);
-                _.db.put(LKEY_VNODE_DATA, [], function(err) {
+                _.db.put(LKEY_VNODE_DATA, [], function (err) {
                     if (err) {
                         err = new verror.VError(err);
                     }
@@ -345,7 +345,7 @@ function ConsistentHash(options, cb) {
                 return _cb();
             },
             function commit(_, _cb) {
-                _.batch.write(function(err) {
+                _.batch.write(function (err) {
                     if (err) {
                         err = new verror.VError(err);
                     }
@@ -355,14 +355,14 @@ function ConsistentHash(options, cb) {
             }
         ];
 
-        vasync.pipeline({funcs: tasks, arg: {}}, function(err) {
+        vasync.pipeline({funcs: tasks, arg: {}}, function (err) {
             if (err) {
                 err = new verror.VError(err, 'unable to create ring');
             }
             log.info({
                 err: err
             }, 'finished instantiated new ring');
-            dtrace._fash_probes['new-done'].fire(function() {
+            dtrace._fash_probes['new-done'].fire(function () {
                 return ([err ? err.message : null, 'createNewRing']);
             });
             return callback(err, self);
@@ -384,7 +384,7 @@ function ConsistentHash(options, cb) {
                 log.info('ConsistentHash.new.deserialize: opening db');
                 //TODO: check to make sure there's nothing already at this
                 //location
-                levelup(options.location, self.leveldbCfg_, function(err, db) {
+                levelup(options.location, self.leveldbCfg_, function (err, db) {
                     if (err) {
                         return _cb(new verror.VError(err));
                     }
@@ -401,7 +401,7 @@ function ConsistentHash(options, cb) {
             // step 1
             function putVnodeCount(_, _cb) {
                 log.info('ConsistentHash.new.deserialize: put vnodeCount');
-                _.db.put(LKEY_VNODE_COUNT, topology.vnodes, function(err) {
+                _.db.put(LKEY_VNODE_COUNT, topology.vnodes, function (err) {
                     if (err) {
                         err = new verror.VError(err);
                     }
@@ -417,7 +417,7 @@ function ConsistentHash(options, cb) {
 
                 // /PNODE
                 var pnodes = Object.keys(pvMap);
-                _.db.put(LKEY_PNODE, pnodes, function(err) {
+                _.db.put(LKEY_PNODE, pnodes, function (err) {
                     if (err) {
                         err = new verror.VError(err);
                         return _cb(err);
@@ -426,12 +426,12 @@ function ConsistentHash(options, cb) {
 
                 // /VNODE/V, /PNODE/P, /P/P/V
                 var pcount = pnodes.length;
-                pnodes.forEach(function(pnode) {
+                pnodes.forEach(function (pnode) {
                     var vnodes = Object.keys(pvMap[pnode]);
                     var vcount = vnodes.length;
 
                     // write /P/P and /V/V. and /P/P/V
-                    vnodes.forEach(function(vnode, index) {
+                    vnodes.forEach(function (vnode, index) {
 
                         /*
                          * json serializes vnode into a string, we need to
@@ -441,7 +441,7 @@ function ConsistentHash(options, cb) {
 
                         // write /V/V
                         _.db.put(sprintf(LKEY_VNODE_V, vnode), pnode,
-                               function(err)
+                               function (err)
                         {
                             if (err) {
                                 err = new verror.VError(err);
@@ -452,13 +452,12 @@ function ConsistentHash(options, cb) {
                         _.db.put(
                             sprintf(LKEY_PNODE_P_V, pnode, vnode),
                             pvMap[pnode][vnode],
-                            function(err) {
+                            function (err) {
                                 if (err) {
                                     err = new verror.VError(err);
                                     return _cb(err);
                                 }
-                            }
-                        );
+                            });
 
                         /*
                          * put the vnode in the VNODE_DATA array if it contains
@@ -477,23 +476,23 @@ function ConsistentHash(options, cb) {
                             _.db.put(
                                 sprintf(LKEY_PNODE_P, pnode),
                                 vnodes,
-                                function(err) {
+                                function (err) {
                                     if (err) {
                                         err = new verror.VError(err);
                                         return _cb(err);
                                     }
-                                }
-                            );
+                                });
                         }
 
                         // write the VNODE_DATA array.
                         if (vcount === 0 && --pcount === 0) {
-                            _.db.put(LKEY_VNODE_DATA, vnodeData, function(err) {
-                                if (err) {
-                                    err = new verror.VError(err);
-                                }
-                                return _cb(err);
-                            });
+                            _.db.put(LKEY_VNODE_DATA, vnodeData,
+                                function (err) {
+                                    if (err) {
+                                        err = new verror.VError(err);
+                                    }
+                                    return _cb(err);
+                                });
                         }
                     });
                 });
@@ -511,21 +510,21 @@ function ConsistentHash(options, cb) {
                 batch.put(LKEY_ALGORITHM, algorithm).
                     put(LKEY_VERSION, fash.VERSION).
                     put(LKEY_COMPLETE, 1);
-                batch.write(function(err) {
+                batch.write(function (err) {
                     if (err) {
                         err = new verror.VError(err);
                     }
                     return _cb(err);
                 });
             }
-        ], arg: {}}, function(err) {
+        ], arg: {}}, function (err) {
             if (err) {
                 err = new verror.VError(err, 'unable to deserialize ring');
             }
             log.info({
                 err: err
             }, 'finished deserializing ring');
-            dtrace._fash_probes['new-done'].fire(function() {
+            dtrace._fash_probes['new-done'].fire(function () {
                 return ([err ? err.message : null, 'deserialize']);
             });
             return callback(err, self);
@@ -538,7 +537,7 @@ function ConsistentHash(options, cb) {
         self.leveldbCfg_.errorIfExists = false;
         vasync.pipeline({funcs: [
             function openDb(_, _cb) {
-                levelup(options.location, self.leveldbCfg_, function(err, db) {
+                levelup(options.location, self.leveldbCfg_, function (err, db) {
                     if (err) {
                         return _cb(new verror.VError(err));
                     }
@@ -551,7 +550,7 @@ function ConsistentHash(options, cb) {
                 });
             },
             function checkComplete(_, _cb) {
-                self.db_.get(LKEY_COMPLETE, function(err, value) {
+                self.db_.get(LKEY_COMPLETE, function (err, value) {
                     if (err) {
                         err = new verror.VError(err);
                     }
@@ -560,20 +559,20 @@ function ConsistentHash(options, cb) {
             },
             function checkVersion(_, _cb) {
                 _cb = once(_cb);
-                self.db_.get(LKEY_VERSION, function(err, version) {
+                self.db_.get(LKEY_VERSION, function (err, version) {
                     if (err) {
                         return _cb(new verror.VError(err));
                     }
                     try {
                         fash.assertVersion(version);
                         return _cb();
-                    } catch(e) {
+                    } catch (e) {
                         return _cb(new verror.VError(e));
                     }
                 });
             },
             function checkVnodes(_, _cb) {
-                self.db_.get(LKEY_VNODE_COUNT, function(err, vnodeCount) {
+                self.db_.get(LKEY_VNODE_COUNT, function (err, vnodeCount) {
                     if (err) {
                         err = new verror.VError(err);
                     }
@@ -585,7 +584,7 @@ function ConsistentHash(options, cb) {
             function checkSlashVnodeSlashN(_, _cb) {
                 // spot check /vnode/largestVnode
                 self.db_.get(sprintf(LKEY_VNODE_V, _.vnodeCount - 1),
-                             function(err, pnode) {
+                             function (err, pnode) {
                     if (err) {
                         err = new verror.VError(err);
                     }
@@ -593,8 +592,8 @@ function ConsistentHash(options, cb) {
                     return _cb(err);
                 });
             },
-            function getAlgorithm(_, _cb){
-                self.db_.get(LKEY_ALGORITHM, function(err, algorithm) {
+            function getAlgorithm(_, _cb) {
+                self.db_.get(LKEY_ALGORITHM, function (err, algorithm) {
                     if (err) {
                         err = new verror.VError(err);
                     }
@@ -604,11 +603,11 @@ function ConsistentHash(options, cb) {
                     return _cb(err);
                 });
             }
-        ], arg: {}}, function(err) {
+        ], arg: {}}, function (err) {
             if (err) {
                 err = new verror.VError(err, 'unable to load ring from db');
             }
-            dtrace._fash_probes['new-done'].fire(function() {
+            dtrace._fash_probes['new-done'].fire(function () {
                 return ([err ? err.message : null, 'loadFromDb']);
             });
             log.info({
@@ -639,32 +638,33 @@ module.exports = ConsistentHash;
  * @param {function} cb The callback f(err, {pnode, vnode, data}).
  */
 ConsistentHash.prototype.getNode = function getNode(key, callback) {
-    dtrace._fash_probes['getnode-start'].fire(function() {
+    dtrace._fash_probes['getnode-start'].fire(function () {
         return ([key]);
     });
     var self = this;
-    var value = crypto.createHash(this.algorithm_.NAME).update(key).digest('hex');
+    var value = crypto.createHash(this.algorithm_.NAME).update(key)
+                .digest('hex');
     // find the node that corresponds to this hash
     var vnode = common.findVnode({
         hash: value, vnodeHashInterval: self.algorithm_.VNODE_HASH_INTERVAL
     });
-    self.db_.get(sprintf(LKEY_VNODE_V, vnode), function(err, pnode) {
+    self.db_.get(sprintf(LKEY_VNODE_V, vnode), function (err, pnode) {
         if (err) {
             err = new verror.VError(err);
-            dtrace._fash_probes['getnode-done'].fire(function() {
-                return([err.message, key, value, null, vnode]);
+            dtrace._fash_probes['getnode-done'].fire(function () {
+                return ([err.message, key, value, null, vnode]);
             });
             return callback(err);
         }
         self.db_.get(sprintf(LKEY_PNODE_P_V, pnode, vnode),
-                     function(_err, data)
+                     function (_err, data)
         {
             if (_err) {
                 _err = new verror.VError(_err);
             }
 
-            dtrace._fash_probes['getnode-done'].fire(function() {
-                return([_err ? _err.message : null,
+            dtrace._fash_probes['getnode-done'].fire(function () {
+                return ([_err ? _err.message : null,
                        key, value, pnode, vnode, data]);
             });
             return callback(_err, {pnode: pnode, vnode: vnode, data: data});
@@ -685,8 +685,8 @@ ConsistentHash.prototype.getNode = function getNode(key, callback) {
  * @param {function} cb The callback f(err).
  */
 ConsistentHash.prototype.addData = function addData(vnode, data, cb) {
-    dtrace._fash_probes['adddata-start'].fire(function() {
-        return([vnode, data]);
+    dtrace._fash_probes['adddata-start'].fire(function () {
+        return ([vnode, data]);
     });
     var self = this;
     var log = self.log;
@@ -706,7 +706,7 @@ ConsistentHash.prototype.addData = function addData(vnode, data, cb) {
 
     vasync.pipeline({funcs: [
         function getPnode(_, _cb) {
-            db.get(sprintf(LKEY_VNODE_V, vnode), function(err, pnode) {
+            db.get(sprintf(LKEY_VNODE_V, vnode), function (err, pnode) {
                 if (err) {
                     return _cb(new verror.VError(err, 'unable to add data'));
                 }
@@ -720,7 +720,7 @@ ConsistentHash.prototype.addData = function addData(vnode, data, cb) {
             });
         },
         function getVnodeDataArray(_, _cb) {
-            db.get(LKEY_VNODE_DATA, function(err, vnodeData) {
+            db.get(LKEY_VNODE_DATA, function (err, vnodeData) {
                 if (err) {
                     return _cb(new verror.VError(err, 'unable to add data'));
                 }
@@ -756,7 +756,7 @@ ConsistentHash.prototype.addData = function addData(vnode, data, cb) {
             return _cb();
         },
         function commit(_, _cb) {
-            _.batch.write(function(err) {
+            _.batch.write(function (err) {
                 if (err) {
                     err = new verror.VError(err, 'addData: unable to commit');
                 }
@@ -765,9 +765,9 @@ ConsistentHash.prototype.addData = function addData(vnode, data, cb) {
             });
             console.log('{"%s":"%s"}', vnode, data);
         }
-    ], arg:{}}, function(err) {
-        dtrace._fash_probes['adddata-done'].fire(function() {
-            return([err ? err.message : null, vnode, data]);
+    ], arg: {}}, function (err) {
+        dtrace._fash_probes['adddata-done'].fire(function () {
+            return ([err ? err.message : null, vnode, data]);
         });
         return cb(err);
     });
@@ -779,56 +779,61 @@ ConsistentHash.prototype.addData = function addData(vnode, data, cb) {
  * @param {Number} vnode The vnode whose pnode and data we want to see.
  * @param {function} cb The callback f(err, String, String)
  */
-ConsistentHash.prototype.getVnodePnodeAndData = function getVnodePnodeAndData(vnode, cb) {
-    var self = this;
+ConsistentHash.prototype.getVnodePnodeAndData =
+    function getVnodePnodeAndData(vnode, cb) {
+        var self = this;
 
-    var log = self.log;
-    var db = self.db_;
+        var log = self.log;
+        var db = self.db_;
 
-    log.info({
-        vnode: vnode
-    },'ConsistentHash.getDataVnode: entering');
+        log.info({
+            vnode: vnode
+        }, 'ConsistentHash.getDataVnode: entering');
 
-    assert.number(vnode, 'vnode');
-    assert.func(cb, 'callback');
+        assert.number(vnode, 'vnode');
+        assert.func(cb, 'callback');
 
-    vasync.pipeline({funcs: [
-        function getVnodePnode(_, _cb) {
-            db.get(sprintf(LKEY_VNODE_V, vnode), function(err, vnodePnode) {
-                if (err) {
-                    return _cb(new verror.VError('cannot get pnode for vnode ' +
-                        vnode + ', vnode ' + vnode + ' or pnode ' +
-                        vnodePnode + ' may not exist.'));
-                }
-                _.pnode = vnodePnode;
-                return _cb();
-            });
-        },
-        function getVnodeData(_, _cb) {
-            db.get(sprintf(LKEY_PNODE_P_V, _.pnode, vnode), function(err, data)
-            {
-                if (err) {
-                    return _cb(new verror.VError('cannot get data for vnode ' + vnode +
-                        ' and pnode ' + _.pnode));
-                } else {
-                    _.vnodeData = data;
-                    return _cb(null, _);
-                }
-            });
-        }
-    ], arg: {}}, function(err, results) {
-        log.info({err: err}, 'ConsistentHash.getDataVnode: exiting');
-        if (err) {
-            console.error(new verror.VError(err));
-            return cb(err);
-        }
+        vasync.pipeline({funcs: [
+            function getVnodePnode(_, _cb) {
+                db.get(sprintf(LKEY_VNODE_V, vnode),
+                    function (err, vnodePnode) {
+                        if (err) {
+                            return _cb(new verror.VError(
+                                'cannot get pnode for vnode ' + vnode +
+                                ', vnode ' + vnode + ' or pnode ' +
+                                vnodePnode + ' may not exist.'));
+                        }
+                        _.pnode = vnodePnode;
+                        return _cb();
+                    });
+            },
+            function getVnodeData(_, _cb) {
+                db.get(sprintf(LKEY_PNODE_P_V, _.pnode, vnode),
+                    function (err, data) {
+                        if (err) {
+                            return _cb(new verror.VError(
+                                'cannot get data for vnode ' + vnode +
+                                ' and pnode ' + _.pnode));
+                        } else {
+                            _.vnodeData = data;
+                            return _cb(null, _);
+                        }
+                    });
+            }
+        ], arg: {}}, function (err, results) {
+            log.info({err: err}, 'ConsistentHash.getDataVnode: exiting');
+            if (err) {
+                console.error(new verror.VError(err));
+                return cb(err);
+            }
 
-        if (results.successes[1]) {
-            return cb(null, results.successes[1].pnode, results.successes[1].vnodeData);
-        }
+            if (results.successes[1]) {
+                return cb(null, results.successes[1].pnode,
+                    results.successes[1].vnodeData);
+            }
 
-        return cb();
-    });
+            return cb();
+        });
 };
 
 /*
@@ -845,7 +850,7 @@ ConsistentHash.prototype.getDataVnodes = function getDataVnodes(cb) {
     log.info('ConsistentHash.getDataVnodes: entering');
     assert.func(cb, 'callback');
 
-    db.get(LKEY_VNODE_DATA, function(err, vnodeArray) {
+    db.get(LKEY_VNODE_DATA, function (err, vnodeArray) {
         if (err) {
             err = new verror.VError(err);
         }
@@ -855,8 +860,8 @@ ConsistentHash.prototype.getDataVnodes = function getDataVnodes(cb) {
 };
 
 /*
- * Remaps a vnode on the hash ring. The node can be on an existing pnode, or a new
- * one.
+ * Remaps a vnode on the hash ring. The node can be on an existing pnode,
+ * or a new one.
  *
  * @param {String} node The name of the node.
  * @param {Number} The vnode to add to this pnode. Implicitly removes the
@@ -864,7 +869,7 @@ ConsistentHash.prototype.getDataVnodes = function getDataVnodes(cb) {
  * @param {function} cb The callback f(err).
  */
 ConsistentHash.prototype.remapVnode = function remapVnode(newPnode, vnode, cb) {
-    dtrace._fash_probes['remapvnode-start'].fire(function() {
+    dtrace._fash_probes['remapvnode-start'].fire(function () {
         return ([newPnode, vnode]);
     });
     var self = this;
@@ -904,7 +909,7 @@ ConsistentHash.prototype.remapVnode = function remapVnode(newPnode, vnode, cb) {
             return _cb();
         },
         function checkAndCreateNewPnode(_, _cb) {
-            db.get(sprintf(LKEY_PNODE_P, newPnode), function(err) {
+            db.get(sprintf(LKEY_PNODE_P, newPnode), function (err) {
                 if (err && err.name && err.name === 'NotFoundError') {
                     _.batch = _.batch.put(sprintf(LKEY_PNODE_P, newPnode), []);
                     _.isNew = true;
@@ -920,7 +925,7 @@ ConsistentHash.prototype.remapVnode = function remapVnode(newPnode, vnode, cb) {
         },
         function getOldVnodeMapping(_, _cb) {
             // get the previous vnode to pnode mapping
-            db.get(sprintf(LKEY_VNODE_V, vnode), function(err, pnode) {
+            db.get(sprintf(LKEY_VNODE_V, vnode), function (err, pnode) {
                 if (err) {
                     return _cb(new verror.VError(err));
                 }
@@ -936,7 +941,7 @@ ConsistentHash.prototype.remapVnode = function remapVnode(newPnode, vnode, cb) {
             });
         },
         function getVnodeData(_, _cb) {
-            db.get(sprintf(LKEY_PNODE_P_V, _.oldPnode, vnode), function(err, d)
+            db.get(sprintf(LKEY_PNODE_P_V, _.oldPnode, vnode), function (err, d)
             {
                 if (err) {
                     return _cb(err);
@@ -948,28 +953,29 @@ ConsistentHash.prototype.remapVnode = function remapVnode(newPnode, vnode, cb) {
         },
         function delOldMapping(_, _cb) {
             _.batch = _.batch.del(sprintf(LKEY_PNODE_P_V, _.oldPnode, vnode));
-            db.get(sprintf(LKEY_PNODE_P, _.oldPnode), function(err, oldVnodes) {
-                if (err) {
-                    return _cb(new verror.VError(err,
-                                                'couldn\'t get path /pnode/' +
-                                                 _.oldPnode));
-                }
-                var idx = oldVnodes.indexOf(vnode);
-                if (idx === -1) {
-                    return _cb(new verror.VError('vnode: ' + vnode +
-                                                ' does not ' +
-                                                'exist in old pnode: ' +
-                                                _.oldPnode));
-                }
-                oldVnodes.splice(idx, 1);
-                _.batch = _.batch
-                .put(sprintf(LKEY_PNODE_P, _.oldPnode), oldVnodes)
-                .del(sprintf(LKEY_PNODE_P_V, _.oldPnode, vnode));
-                return _cb();
-            });
+            db.get(sprintf(LKEY_PNODE_P, _.oldPnode),
+                function (err, oldVnodes) {
+                    if (err) {
+                        return _cb(new verror.VError(err,
+                                                    'couldn\'t get path' +
+                                                    '/pnode/' + _.oldPnode));
+                    }
+                    var idx = oldVnodes.indexOf(vnode);
+                    if (idx === -1) {
+                        return _cb(new verror.VError('vnode: ' + vnode +
+                                                    ' does not ' +
+                                                    'exist in old pnode: ' +
+                                                    _.oldPnode));
+                    }
+                    oldVnodes.splice(idx, 1);
+                    _.batch = _.batch
+                    .put(sprintf(LKEY_PNODE_P, _.oldPnode), oldVnodes)
+                    .del(sprintf(LKEY_PNODE_P_V, _.oldPnode, vnode));
+                    return _cb();
+                });
         },
         function addNewMapping(_, _cb) {
-            db.get(sprintf(LKEY_PNODE_P, newPnode), function(err, vnodes) {
+            db.get(sprintf(LKEY_PNODE_P, newPnode), function (err, vnodes) {
                 /*
                  * ignore NotFoundErrors if the pnode is new, since it hasn't
                  * been created yet
@@ -991,7 +997,7 @@ ConsistentHash.prototype.remapVnode = function remapVnode(newPnode, vnode, cb) {
             });
         },
         function addPnodeToPnodeArray(_, _cb) {
-            db.get(LKEY_PNODE, function(err, pnodes) {
+            db.get(LKEY_PNODE, function (err, pnodes) {
                 if (err) {
                     return _cb(new verror.VError(err));
                 }
@@ -1005,7 +1011,7 @@ ConsistentHash.prototype.remapVnode = function remapVnode(newPnode, vnode, cb) {
             });
         },
         function commit(_, _cb) {
-            _.batch.write(function(err) {
+            _.batch.write(function (err) {
                 if (err) {
                     return _cb(new verror.VError(err));
                 } else {
@@ -1014,9 +1020,9 @@ ConsistentHash.prototype.remapVnode = function remapVnode(newPnode, vnode, cb) {
             });
             console.log('{"%s":"%s"}', newPnode, vnode);
         }
-    ], arg: {}}, function(err) {
+    ], arg: {}}, function (err) {
         log.info({err: err}, 'ConsistentHash.remapVnode: exiting');
-        dtrace._fash_probes['remapvnode-done'].fire(function() {
+        dtrace._fash_probes['remapvnode-done'].fire(function () {
             return ([err ? err.message : null, newPnode, oldPnode, vnode]);
         });
         return cb(err);
@@ -1039,7 +1045,7 @@ ConsistentHash.prototype.getVnodes = function getVnodes(pnode, cb) {
     assert.func(cb, 'callback');
 
     // check that the pnode exists
-    db.get(sprintf(LKEY_PNODE_P, pnode), function(err, vnodes) {
+    db.get(sprintf(LKEY_PNODE_P, pnode), function (err, vnodes) {
         if (err) {
             return cb(new verror.VError(err, 'pnode is not in ring'));
         }
@@ -1064,7 +1070,7 @@ ConsistentHash.prototype.getPnodes = function getPnodes(cb) {
     log.info('ConsistentHash.getPnodes: entering');
 
     assert.func(cb, 'callback');
-    db.get(LKEY_PNODE, function(err, pnodes) {
+    db.get(LKEY_PNODE, function (err, pnodes) {
         if (err) {
             err = new verror.VError(err, 'unable to get Pnodes');
         }
@@ -1082,7 +1088,7 @@ ConsistentHash.prototype.getPnodes = function getPnodes(cb) {
  * @param {function} cb The callback f(err).
  */
 ConsistentHash.prototype.removePnode = function removePnode(pnode, cb) {
-    dtrace._fash_probes['removepnode-start'].fire(function() {
+    dtrace._fash_probes['removepnode-start'].fire(function () {
         return ([pnode]);
     });
     var self = this;
@@ -1097,8 +1103,8 @@ ConsistentHash.prototype.removePnode = function removePnode(pnode, cb) {
     assert.func(cb, 'callback');
     // check that the pnode exists
     vasync.pipeline({funcs: [
-        function checkPnodeExists(_, _cb){
-            db.get(sprintf(LKEY_PNODE_P, pnode), function(err, v) {
+        function checkPnodeExists(_, _cb) {
+            db.get(sprintf(LKEY_PNODE_P, pnode), function (err, v) {
                 if (err) {
                     return _cb(new verror.VError(err, 'pnode does not exist'));
                 }
@@ -1118,7 +1124,7 @@ ConsistentHash.prototype.removePnode = function removePnode(pnode, cb) {
             // remove /pnode/%s
             var batch = db.batch().del(sprintf(LKEY_PNODE_P, pnode));
             // get the pnode array
-            db.get(LKEY_PNODE, function(err, pnodes) {
+            db.get(LKEY_PNODE, function (err, pnodes) {
                 if (err) {
                     return _cb(new verror.VError(err));
                 }
@@ -1129,7 +1135,7 @@ ConsistentHash.prototype.removePnode = function removePnode(pnode, cb) {
                     return _cb(new verror.VError('pnode does not exist'));
                 }
                 pnodes.splice(pnodeIndex, 1);
-                batch.put(LKEY_PNODE, pnodes).write(function(_err) {
+                batch.put(LKEY_PNODE, pnodes).write(function (_err) {
                     if (_err) {
                         _err = new verror.VError(_err);
                     }
@@ -1142,8 +1148,8 @@ ConsistentHash.prototype.removePnode = function removePnode(pnode, cb) {
                 return (undefined);
             });
         }
-    ], arg: {}}, function(err) {
-        dtrace._fash_probes['removepnode-done'].fire(function() {
+    ], arg: {}}, function (err) {
+        dtrace._fash_probes['removepnode-done'].fire(function () {
             return ([err ? err.message : null, pnode]);
         });
         return cb(err);
@@ -1161,7 +1167,7 @@ ConsistentHash.prototype.removePnode = function removePnode(pnode, cb) {
  * @return {String} ring.version The version of the ring.
  */
 ConsistentHash.prototype.serialize = function serialize(callback) {
-    dtrace._fash_probes['serialize-start'].fire(function() {
+    dtrace._fash_probes['serialize-start'].fire(function () {
         return ([]);
     });
     var self = this;
@@ -1179,7 +1185,7 @@ ConsistentHash.prototype.serialize = function serialize(callback) {
 
     var tasks = [
         function getNumberOfVnodes(_, cb) {
-            db.get(LKEY_VNODE_COUNT, function(err, vnodes) {
+            db.get(LKEY_VNODE_COUNT, function (err, vnodes) {
                 serializedHash.vnodes = vnodes;
                 return cb(err);
             });
@@ -1189,14 +1195,14 @@ ConsistentHash.prototype.serialize = function serialize(callback) {
             var count = serializedHash.vnodes;
             for (var vnode = 0; vnode < serializedHash.vnodes; vnode++) {
                 db.get(sprintf(LKEY_VNODE_V, vnode),
-                       (function(v, err, pnode)
+                       (function (v, err, pnode)
                 {
                     if (err) {
                         return cb(new verror.VError(err));
                     }
                     serializedHash.pnodeToVnodeMap[pnode] = {};
                     db.get(sprintf(LKEY_PNODE_P_V, pnode, v),
-                           function(_err, data)
+                           function (_err, data)
                     {
                         if (_err) {
                             return cb(new verror.VError(_err));
@@ -1211,8 +1217,8 @@ ConsistentHash.prototype.serialize = function serialize(callback) {
                 }).bind(this, vnode));
             }
         },
-        function getAlgorithm(_, cb){
-            db.get(LKEY_ALGORITHM, function(err, algorithm) {
+        function getAlgorithm(_, cb) {
+            db.get(LKEY_ALGORITHM, function (err, algorithm) {
                 if (err) {
                     err = new verror.VError(err);
                 }
@@ -1220,8 +1226,8 @@ ConsistentHash.prototype.serialize = function serialize(callback) {
                 return cb(err);
             });
         },
-        function getVersion(_, cb){
-            db.get(LKEY_VERSION, function(err, version) {
+        function getVersion(_, cb) {
+            db.get(LKEY_VERSION, function (err, version) {
                 if (err) {
                     err = new verror.VError(err);
                 }
@@ -1231,7 +1237,7 @@ ConsistentHash.prototype.serialize = function serialize(callback) {
         }
     ];
 
-    vasync.pipeline({funcs: tasks, arg: {}}, function(err) {
+    vasync.pipeline({funcs: tasks, arg: {}}, function (err) {
         if (err) {
             err = new verror.VError(err, 'unable to serialize ring');
         }
@@ -1243,7 +1249,7 @@ ConsistentHash.prototype.serialize = function serialize(callback) {
         }
         log.info({err: err}, 'ConsistentHash.serialize: exiting');
 
-        dtrace._fash_probes['serialize-done'].fire(function() {
+        dtrace._fash_probes['serialize-done'].fire(function () {
             return ([err ? err.message : null]);
         });
         return callback(err, stringifiedHash);
@@ -1259,5 +1265,4 @@ module.exports.LKEY_PNODE_P = LKEY_PNODE_P;
 module.exports.LKEY_PNODE_P_V = LKEY_PNODE_P_V;
 module.exports.LKEY_VERSION = LKEY_VERSION;
 module.exports.LKEY_VNODE_COUNT = LKEY_VNODE_COUNT;
-module.exports.LKEY_VNODE_V = LKEY_VNODE_V;
-
+module.exports.LKEY_VNODE_V = LKEY_VNODE_V;
\ No newline at end of file
diff --git a/lib/common.js b/lib/common.js
index 055c1bb..02f89d7 100644
--- a/lib/common.js
+++ b/lib/common.js
@@ -64,7 +64,8 @@ function _findVnode(options) {
     assert.object(options, 'options');
     assert.object(options.vnodeHashInterval, 'options.vnodeHashinterval');
     assert.string(options.hash, 'options.hash');
-    return parseInt(bignum(options.hash, 16).div(options.vnodeHashInterval), 10);
+    return parseInt(bignum(options.hash, 16)
+    	.div(options.vnodeHashInterval), 10);
 }
 
 /*
diff --git a/lib/dtrace.js b/lib/dtrace.js
index e2b79ae..d443659 100644
--- a/lib/dtrace.js
+++ b/lib/dtrace.js
@@ -39,37 +39,37 @@ var PROVIDER;
 ///--- API
 
 module.exports = function exportStaticProvider() {
-  if (!PROVIDER) {
-    try {
-      var dtrace = require('dtrace-provider');
-      PROVIDER = dtrace.createDTraceProvider('node-fash');
-    } catch (e) {
-      PROVIDER = {
-        fire: function () {},
-        enable: function () {},
-        addProbe: function () {
-          var p = {
-            fire: function () {}
-          };
-          return (p);
-        },
-        removeProbe: function () {},
-        disable: function () {}
-      };
-    }
+    if (!PROVIDER) {
+        try {
+            var dtrace = require('dtrace-provider');
+            PROVIDER = dtrace.createDTraceProvider('node-fash');
+        } catch (e) {
+            PROVIDER = {
+                fire: function () {},
+                enable: function () {},
+                addProbe: function () {
+                    var p = {
+                        fire: function () {}
+                    };
+                    return (p);
+                },
+                removeProbe: function () {},
+                disable: function () {}
+            };
+        }
 
-    PROVIDER._fash_probes = {};
+        PROVIDER._fash_probes = {};
 
-    Object.keys(PROBES).forEach(function (p) {
-      var args = PROBES[p].splice(0);
-      args.unshift(p);
+        Object.keys(PROBES).forEach(function (p) {
+            var args = PROBES[p].splice(0);
+            args.unshift(p);
 
-      var probe = PROVIDER.addProbe.apply(PROVIDER, args);
-      PROVIDER._fash_probes[p] = probe;
-    });
+            var probe = PROVIDER.addProbe.apply(PROVIDER, args);
+            PROVIDER._fash_probes[p] = probe;
+        });
 
-    PROVIDER.enable();
-  }
+        PROVIDER.enable();
+    }
 
-  return (PROVIDER);
+    return (PROVIDER);
 }();
diff --git a/lint.sh b/lint.sh
index 27d550c..6f080fb 100755
--- a/lint.sh
+++ b/lint.sh
@@ -9,4 +9,4 @@ cd ../..
 ./deps/javascriptlint/build/install/jsl --conf ./tools/jsl.node.conf \
     ./lib/*.js ./lib/backend/*.js ./bin/*.js
 
-./deps/jsstyle/jsstyle -f ./tools/jsstyle.conf ./*.js ./bin/*.js ./test/*.js
+./deps/jsstyle/jsstyle -f ./tools/jsstyle.conf ./bin/*.js ./lib/*.js ./lib/backend/*.js ./test/*.js
diff --git a/package.json b/package.json
index 50a712b..eb43812 100644
--- a/package.json
+++ b/package.json
@@ -21,7 +21,7 @@
     "dynamo",
     "hash ring"
   ],
-  "version": "2.4.0",
+  "version": "2.4.1",
   "repository": {
     "type": "git",
     "url": "https://github.com/yunong/node-fash.git"
-- 
2.21.0

