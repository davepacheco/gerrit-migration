commit 16fa951f485e17585b6476c56293cf5a9a0d46d3 (refs/changes/98/1998/2)
Author: Josh Wilsdon <jwilsdon@joyent.com>
Date:   2017-05-25T22:53:33-07:00 (2 years, 4 months ago)
    
    VOLAPI-49 DELETE should delete

diff --git a/lib/endpoints/volumes.js b/lib/endpoints/volumes.js
index 0f56c3e..3d480c3 100644
--- a/lib/endpoints/volumes.js
+++ b/lib/endpoints/volumes.js
@@ -917,9 +917,8 @@ function deleteVolume(req, res, next) {
                 var volumeObject = req.loadedVolumeObject;
 
                 if (!ctx.storageVmNeedsDeletion) {
-                    volumeObject.value.state = 'deleted';
-                    volumesModel.updateVolumeWithRetry(volumeObject.value.uuid,
-                        volumeObject, done);
+                    volumesModel.deleteVolumeWithRetry(volumeObject.value.uuid,
+                        done);
                 } else {
                     done();
                 }
diff --git a/lib/models/volumes.js b/lib/models/volumes.js
index a1afb9b..7cb05ce 100644
--- a/lib/models/volumes.js
+++ b/lib/models/volumes.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2016, Joyent, Inc.
+ * Copyright (c) 2017, Joyent, Inc.
  */
 
 var path = require('path');
@@ -15,6 +15,7 @@ var assert = require('assert-plus');
 var libuuid = require('libuuid');
 var ldapFilter = require('ldap-filter');
 var vasync = require('vasync');
+var verror = require('verror');
 
 var volumes = require('../volumes');
 
@@ -233,6 +234,73 @@ function deleteVolume(volumeUuid, callback) {
     morayClient.deleteObject(VOLUMES_BUCKET_NAME, volumeUuid, callback);
 }
 
+//
+// Returns whether the error object "volumeDeleteError" represents a transient
+// volume deletion error. Whether such an error is transient is determined by
+// the list of non-transient deleteObject errors documented at
+//
+// /*JSSTYLED*/
+// https://github.com/joyent/moray/blob/52d7669f7134d2a57c35f97891d3e166d7f1cb76/docs/index.md#errors-8
+//
+// Note: the link doesn't refer to the master branch but to the current latest
+// commit on that branch, this way if the documentation changes, this link will
+// still point to the documentation at the time of the implementation of this
+// function.
+//
+function _isTransientVolumeDeleteError(volumeDeleteError) {
+    assert.object(volumeDeleteError, 'volumeDeleteError');
+
+    return [
+        'BucketNotFoundError',
+        'EtagConflictError',
+        'ObjectNotFoundError',
+        'NoDatabaseError'
+    ].indexOf(volumeDeleteError.name) === -1;
+}
+
+function deleteVolumeWithRetry(volumeUuid, callback) {
+    assert.uuid(volumeUuid, 'volumeUuid');
+    assert.func(callback, 'callback');
+
+    var MAX_NB_VOLUME_DELETE_TRIES = 10;
+    var nbVolumeDeleteTries = 0;
+    var RETRY_DELAY = 1000;
+
+    function doDeleteVolume() {
+        if (nbVolumeDeleteTries > MAX_NB_VOLUME_DELETE_TRIES) {
+            callback(new Error('max number of retries (' +
+                MAX_NB_VOLUME_DELETE_TRIES + ') reached when trying to ' +
+                'delete volume'));
+            return;
+        }
+
+        ++nbVolumeDeleteTries;
+
+        deleteVolume(volumeUuid, function onVolumeDeleted(volumeDeleteErr) {
+            if (volumeDeleteErr && verror.hasCauseWithName(volumeDeleteErr,
+                'ObjectNotFoundError')) {
+                // If we're trying to delete and the volume is already not
+                // found, don't treat that as an error.
+                callback();
+            } else if (volumeDeleteErr &&
+                _isTransientVolumeDeleteError(volumeDeleteErr)) {
+                /*
+                 * Deleting the volume from moray failed but could eventually
+                 * succeed if we retry, so we schedule a retry to happen later.
+                 */
+                log.error({error: volumeDeleteErr},
+                    'Got transient error when deleting volume object, ' +
+                        'retrying...');
+                setTimeout(RETRY_DELAY, doDeleteVolume);
+            } else {
+                callback(volumeDeleteErr);
+            }
+        });
+    }
+
+    doDeleteVolume();
+}
+
 function init(config, options, callback) {
     assert.object(config, 'config');
     assert.object(options, 'options');
@@ -266,5 +334,6 @@ module.exports = {
     updateVolumeWithRetry: updateVolumeWithRetry,
     loadVolume: loadVolume,
     listVolumes: listVolumes,
-    deleteVolume: deleteVolume
-};
\ No newline at end of file
+    deleteVolume: deleteVolume,
+    deleteVolumeWithRetry: deleteVolumeWithRetry
+};
diff --git a/lib/validation/volumes.js b/lib/validation/volumes.js
index 35b2071..37f487b 100644
--- a/lib/validation/volumes.js
+++ b/lib/validation/volumes.js
@@ -76,7 +76,7 @@ function validateVolumeState(state) {
     console.log('state: ', state);
 
     var VALID_STATES = [
-        'creating', 'ready', 'deleted', 'failed', 'rolling_back'
+        'creating', 'ready', 'failed', 'rolling_back'
     ];
     var err;
 
diff --git a/volapi-updater.js b/volapi-updater.js
index 86c93e6..42e98fd 100644
--- a/volapi-updater.js
+++ b/volapi-updater.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2016, Joyent, Inc.
+ * Copyright (c) 2017, Joyent, Inc.
  */
 
 /*
@@ -300,7 +300,20 @@ function updateVolumeFromStorageVm(volumeObject, storageVm, callback) {
             });
     }
 
-    updateVolume();
+    function deleteVolume() {
+        // When deleting we won't hit an Etag error, so we don't need to load
+        // and retry. We can just do the regular retries on transient moray
+        // errors.
+        volumeModels.deleteVolumeWithRetry(volumeObject.value.uuid, callback);
+    }
+
+    if (volumeObject.value.state === 'deleted') {
+        // Switching to 'deleted' means removing the entry rather than updating
+        // it in Moray.
+        deleteVolume();
+    } else {
+        updateVolume();
+    }
 }
 
 function updateVolumeFromVm(vm, log, callback) {
@@ -591,4 +604,4 @@ function main() {
     });
 }
 
-main();
\ No newline at end of file
+main();
