From 7cd22d59d84d71607b11364a0b9045c8c9cf6918 Mon Sep 17 00:00:00 2001
From: Alex Wilson <alex.wilson@joyent.com>
Date: Thu, 15 Jun 2017 13:21:35 -0700
Subject: [PATCH] joyent/node-zkstream#10 support for bunyan logger

---
 lib/client-fsm.js       | 120 +++++++++++++++++++++++++++++++++++-----
 package.json            |   3 +-
 test/basic.test.js      |  21 ++++++-
 test/multi-node.test.js |  12 ++++
 test/streams.test.js    |   6 ++
 5 files changed, 146 insertions(+), 16 deletions(-)

diff --git a/lib/client-fsm.js b/lib/client-fsm.js
index c8fb491..14f9fbf 100644
--- a/lib/client-fsm.js
+++ b/lib/client-fsm.js
@@ -18,10 +18,23 @@ const mod_jsbn = require('jsbn');
 const mod_events = require('events');
 const mod_zkstreams = require('./zk-streams');
 const mod_net = require('net');
+const mod_bunyan = require('bunyan');
 
 function ZKClientFSM(opts) {
 	mod_assert.object(opts, 'options');
 
+	mod_assert.optionalObject(opts.log, 'options.log');
+	if (opts.log == undefined) {
+		this.zs_log = mod_bunyan.createLogger({
+			name: 'zkstream',
+			component: 'ZKClientFSM'
+		});
+	} else {
+		this.zs_log = opts.log.child({
+			component: 'ZKClientFSM'
+		});
+	}
+
 	mod_assert.optionalArrayOfObject(opts.servers, 'options.servers');
 	if (opts.servers === undefined) {
 		mod_assert.string(opts.host, 'options.host');
@@ -89,6 +102,8 @@ ZKClientFSM.prototype.state_closed = function (S) {
 		S.gotoState('connecting');
 	});
 
+	this.zs_log.info('closing connection');
+
 	this.zs_encoder.end();
 	this.zs_encoder = undefined;
 	this.zs_socket.destroy();
@@ -104,7 +119,10 @@ ZKClientFSM.prototype.state_closed = function (S) {
 	this.zs_reqs = {};
 	this.zs_watchers = {};
 
-	this.emit('close');
+	var self = this;
+	S.immediate(function () {
+		self.emit('close');
+	});
 };
 
 ZKClientFSM.prototype.state_connecting = function (S) {
@@ -115,8 +133,16 @@ ZKClientFSM.prototype.state_connecting = function (S) {
 	this.zs_encoder = new mod_zkstreams.ZKEncodeStream({
 		fsm: this
 	});
+
 	this.zs_server = this.zs_servers.shift();
 	this.zs_servers.push(this.zs_server);
+
+	this.zs_log = this.zs_log.child({
+		zkHost: this.zs_server.host,
+		zkPort: this.zs_server.port
+	});
+	this.zs_log.trace('attempting new connection');
+
 	this.zs_socket = mod_net.connect({
 		host: this.zs_server.host,
 		port: this.zs_server.port,
@@ -144,26 +170,35 @@ ZKClientFSM.prototype.state_handshaking = function (S) {
 		if (pkt === null)
 			return;
 		if (self.zs_decoder.read() !== null) {
-			self.emit('error', new mod_errors.ZKProtocolError(
+			self.zs_lastError = new mod_errors.ZKProtocolError(
 			    'UNEXPECTED_PACKET', 'Received unexpected ' +
-			    'additional packet during connect phase'));
+			    'additional packet during connect phase');
 			S.gotoState('error');
 			return;
 		}
 		if (pkt.protocolVersion !== 0) {
-			self.emit('error', new mod_errors.ZKProtocolError(
+			self.zs_lastError = new mod_errors.ZKProtocolError(
 			    'VERSION_INCOMPAT', 'Server version is not ' +
-			    'compatible'));
+			    'compatible');
 			S.gotoState('error');
 			return;
 		}
 		if (pkt.sessionId.toString('hex') === '0000000000000000') {
-			self.emit('error', new mod_errors.ZKProtocolError(
+			self.zs_lastError = new mod_errors.ZKProtocolError(
 			    'SESSION_EXPIRED', 'Attempted to resume a ' +
-			    'session that had already expired'));
+			    'session that had already expired');
 			S.gotoState('closed');
 			return;
 		}
+		var verb = 'created';
+		if (self.zs_cr !== undefined) {
+			verb = 'resumed';
+		}
+		self.zs_log.info('%s zookeeper session %s with timeout %d ms',
+		    verb, pkt.sessionId.toString('hex'), pkt.timeOut);
+		self.zs_log = self.zs_log.child({
+			zkSessionId: pkt.sessionId.toString('hex')
+		});
 		self.zs_cr = pkt;
 		self.zs_lastPkt = new Date();
 		S.gotoState('connected');
@@ -188,6 +223,10 @@ ZKClientFSM.prototype.state_handshaking = function (S) {
 	});
 	this.zs_socket.pipe(this.zs_decoder);
 	this.zs_encoder.pipe(this.zs_socket);
+	if (this.zs_cr !== undefined) {
+		this.zs_log.trace('attempting to resume session %s',
+		    this.zs_cr.sessionId.toString('hex'));
+	}
 	this.zs_encoder.write({
 		protocolVersion: 0,
 		lastZxidSeen: this.zs_lastZxid,
@@ -219,6 +258,14 @@ ZKClientFSM.prototype.state_connected = function (S) {
 
 			if (pkt.opcode === 'NOTIFICATION') {
 				if (pkt.state !== 'SYNC_CONNECTED') {
+					self.zs_log.warn({
+						xid: pkt.xid,
+						errorCode: pkt.err,
+						state: pkt.state,
+						type: pkt.type,
+						zxid: pkt.zxid.toString('hex')
+					}, 'received notification with bad ' +
+					    'state %s', pkt.state);
 					continue;
 				}
 				var watcher = self.zs_watchers[pkt.path];
@@ -226,6 +273,13 @@ ZKClientFSM.prototype.state_connected = function (S) {
 				    replace(/_[a-z]/g, function (s) {
 					return (s.slice(1).toUpperCase());
 				    });
+				self.zs_log.trace({
+					xid: pkt.xid,
+					errorCode: pkt.err,
+					state: pkt.state,
+					zxid: pkt.zxid.toString('hex'),
+					type: pkt.type
+				}, 'notification %s for %s', evt, pkt.path);
 				if (watcher)
 					watcher.emit(evt);
 				continue;
@@ -238,6 +292,11 @@ ZKClientFSM.prototype.state_connected = function (S) {
 			}
 
 			var req = self.zs_reqs[pkt.xid];
+			self.zs_log.trace({
+				xid: pkt.xid,
+				opcode: req.packet.opcode,
+				errorCode: pkt.err
+			}, 'server replied to request');
 			if (req === undefined) {
 				self.emit('packet', pkt);
 			} else {
@@ -252,7 +311,9 @@ ZKClientFSM.prototype.state_connected = function (S) {
 		}
 	});
 	S.on(this.zs_decoder, 'end', function () {
-		S.gotoState('closed');
+		self.zs_lastError = new mod_errors.ZKProtocolError(
+		    'CONNECTION_LOSS', 'Connection closed unexpectedly.');
+		S.gotoState('error');
 	});
 	S.on(this.zs_decoder, 'error', function (err) {
 		self.zs_lastError = err;
@@ -266,6 +327,11 @@ ZKClientFSM.prototype.state_connected = function (S) {
 		self.zs_lastError = err;
 		S.gotoState('error');
 	});
+	S.on(this.zs_socket, 'close', function () {
+		self.zs_lastError = new mod_errors.ZKProtocolError(
+		    'CONNECTION_LOSS', 'Connection closed unexpectedly.');
+		S.gotoState('error');
+	});
 	S.on(this, 'closeAsserted', function () {
 		S.gotoState('closing');
 	});
@@ -275,7 +341,9 @@ ZKClientFSM.prototype.state_connected = function (S) {
 	});
 
 	this.resumeWatchers();
-	this.emit('connect');
+	S.immediate(function () {
+		self.emit('connect');
+	});
 };
 
 ZKClientFSM.prototype.state_closing = function (S) {
@@ -318,6 +386,7 @@ ZKClientFSM.prototype.state_closing = function (S) {
 		self.zs_lastError = err;
 		S.gotoState('closed');
 	});
+	this.zs_log.info({ xid: xid }, 'sent CLOSE_SESSION request');
 	this.zs_encoder.write({
 		opcode: 'CLOSE_SESSION',
 		xid: xid
@@ -327,6 +396,8 @@ ZKClientFSM.prototype.state_closing = function (S) {
 
 ZKClientFSM.prototype.state_error = function (S) {
 	var self = this;
+	this.zs_log.warn(this.zs_lastError, 'error communicating with ZK, ' +
+	    'cancelling all outstanding requests');
 	Object.keys(this.zs_reqs).forEach(function (xid) {
 		self.zs_reqs[xid].emit('error', self.zs_lastError);
 	});
@@ -335,11 +406,21 @@ ZKClientFSM.prototype.state_error = function (S) {
 		var now = new Date();
 		var delta = now.getTime() - this.zs_lastPkt.getTime();
 		if (delta < this.zs_cr.timeOut) {
+			this.zs_log.trace('has been %d ms since last ' +
+			    'session renewal, will retry (session timeout = ' +
+			    '%d ms)', delta, this.zs_cr.timeOut);
 			S.gotoState('connecting');
 			return;
 		}
 	}
-	this.emit('error', this.zs_lastError);
+	/*
+	 * Don't use S.immediate here, we always want to make sure this gets
+	 * emitted, even though we're leaving this state.
+	 */
+	setImmediate(function () {
+		this.emit('error', this.zs_lastError);
+	});
+
 	S.gotoState('closed');
 };
 
@@ -374,6 +455,7 @@ ZKClientFSM.prototype.ping = function (cb) {
 		delete (self.zs_reqs[pkt.xid]);
 		var t2 = new Date();
 		clearTimeout(timer);
+		self.zs_log.trace('ping ok in %d ms', (t2 - t1));
 		if (cb !== undefined)
 			cb(null, (t2 - t1));
 	}
@@ -421,6 +503,8 @@ ZKClientFSM.prototype.resumeWatchers = function () {
 	if (count < 1)
 		return;
 	var zxid = this.zs_lastZxid;
+	var hex = zxid.toString(16);
+	this.zs_log.info('re-arming %d node watchers at zxid %s', count, hex);
 	this.setWatches(events, zxid, function (err) {
 		if (err) {
 			self.emit('pingTimeout');
@@ -456,10 +540,6 @@ ZKClientFSM.prototype.setWatches = function (events, zxid, cb) {
 		delete (self.zs_reqs[pkt.xid]);
 		cb(null);
 	}
-	function onTimeout() {
-		req.removeListener('reply', onPacket);
-		self.emit('pingTimeout');
-	}
 	function onError(err) {
 		delete (self.zs_reqs[pkt.xid]);
 		cb(err);
@@ -477,12 +557,20 @@ ZKClientFSM.prototype.request = function (pkt) {
 	var self = this;
 	if (!this.isInState('connected'))
 		throw (new Error('Client must be connected to send packets'));
+
 	var req = new ZKRequest(pkt);
 	pkt.xid = this.nextXid();
 	this.zs_reqs[pkt.xid] = req;
 	req.once('reply', endRequest);
 	req.once('error', endRequest);
+
+	this.zs_log.trace({
+		xid: pkt.xid,
+		opcode: pkt.opcode
+	}, 'sent request to server');
+
 	this.zs_encoder.write(pkt);
+
 	return (req);
 
 	function endRequest() {
@@ -681,6 +769,10 @@ ZKWatcher.prototype.emit = function (evt) {
 				    onStateChanged);
 			}
 		}
+		this.zkw_client.zs_log.trace({
+			event: evt,
+			clientState: this.zkw_client.getState()
+		}, 'deferring watcher refresh until after reconnect');
 		this.zkw_client.on('stateChanged', onStateChanged);
 		return;
 	}
diff --git a/package.json b/package.json
index ed1a985..35b9e86 100644
--- a/package.json
+++ b/package.json
@@ -1,10 +1,11 @@
 {
   "name": "zkstream",
-  "version": "0.4.0",
+  "version": "0.5.0",
   "description": "",
   "main": "lib/index.js",
   "dependencies": {
     "assert-plus": "^1.0.0",
+    "bunyan": "^1.8.10",
     "jsbn": "^0.1.0",
     "mooremachine": "^2.0.0",
     "node-uuid": "^1.4.7",
diff --git a/test/basic.test.js b/test/basic.test.js
index cfca7fe..8a549e7 100644
--- a/test/basic.test.js
+++ b/test/basic.test.js
@@ -10,6 +10,12 @@ const mod_tape = require('tape');
 const mod_zk = require('./zkserver');
 const mod_zkc = require('../lib/index');
 const mod_net = require('net');
+const mod_bunyan = require('bunyan');
+
+var log = mod_bunyan.createLogger({
+	name: 'zkstream-test',
+	level: process.env.LOG_LEVEL || 'info'
+});
 
 var zk;
 
@@ -23,6 +29,7 @@ mod_tape.test('start zk server', function (t) {
 
 mod_tape.test('simple connect and ping', function (t) {
 	var zkc = new mod_zkc.Client({
+		log: log,
 		host: 'localhost',
 		port: 2181
 	});
@@ -49,6 +56,7 @@ mod_tape.test('set up test object', function (t) {
 
 mod_tape.test('find the test object', function (t) {
 	var zkc = new mod_zkc.Client({
+		log: log,
 		host: 'localhost',
 		port: 2181
 	});
@@ -85,6 +93,7 @@ mod_tape.test('find the test object', function (t) {
 
 mod_tape.test('delete the test object', function (t) {
 	var zkc = new mod_zkc.Client({
+		log: log,
 		host: 'localhost',
 		port: 2181
 	});
@@ -104,6 +113,7 @@ mod_tape.test('delete the test object', function (t) {
 
 mod_tape.test('ask for a non-existent node', function (t) {
 	var zkc = new mod_zkc.Client({
+		log: log,
 		host: 'localhost',
 		port: 2181
 	});
@@ -130,6 +140,7 @@ mod_tape.test('ask for a non-existent node', function (t) {
 
 mod_tape.test('create a new node', function (t) {
 	var zkc = new mod_zkc.Client({
+		log: log,
 		host: 'localhost',
 		port: 2181
 	});
@@ -156,6 +167,7 @@ mod_tape.test('create a new node', function (t) {
 
 mod_tape.test('data watcher', function (t) {
 	var zkc = new mod_zkc.Client({
+		log: log,
 		host: 'localhost',
 		port: 2181
 	});
@@ -187,6 +199,7 @@ mod_tape.test('data watcher', function (t) {
 
 mod_tape.test('delete it while watching', function (t) {
 	var zkc = new mod_zkc.Client({
+		log: log,
 		host: 'localhost',
 		port: 2181
 	});
@@ -219,6 +232,7 @@ mod_tape.test('set up test object', function (t) {
 
 mod_tape.test('delete it while watching data', function (t) {
 	var zkc = new mod_zkc.Client({
+		log: log,
 		host: 'localhost',
 		port: 2181
 	});
@@ -257,6 +271,7 @@ mod_tape.test('set up test object', function (t) {
 
 mod_tape.test('children watcher', function (t) {
 	var zkc = new mod_zkc.Client({
+		log: log,
 		host: 'localhost',
 		port: 2181
 	});
@@ -306,12 +321,14 @@ mod_tape.test('session resumption with watcher', function (t) {
 	var closed = 0;
 
 	var zkc1 = new mod_zkc.Client({
+		log: log,
 		host: 'localhost',
 		port: 2181
 	});
 	zkc1.connect();
 
 	var zkc2 = new mod_zkc.Client({
+		log: log,
 		host: 'localhost',
 		port: 2181
 	});
@@ -369,7 +386,9 @@ mod_tape.test('session resumption with watcher', function (t) {
 		zkc2.stat('/foo', function (err, stat) {
 			t.error(err);
 
-			zkc1.zs_socket.destroy();
+			var sock = zkc1.zs_socket;
+			sock.emit('error', new Error('I killed it'));
+			sock.destroy();
 
 			var data = new Buffer('hello again');
 			zkc2.set('/foo', data, stat.version, function (err2) {
diff --git a/test/multi-node.test.js b/test/multi-node.test.js
index 8461009..3473529 100644
--- a/test/multi-node.test.js
+++ b/test/multi-node.test.js
@@ -10,6 +10,12 @@ const mod_tape = require('tape');
 const mod_zk = require('./zkserver');
 const mod_zkc = require('../lib/index');
 const mod_net = require('net');
+const mod_bunyan = require('bunyan');
+
+var log = mod_bunyan.createLogger({
+	name: 'zkstream-test',
+	level: process.env.LOG_LEVEL || 'info'
+});
 
 var zk1, zk2, zk3;
 
@@ -61,6 +67,7 @@ mod_tape.test('start zk servers', function (t) {
 
 mod_tape.test('simple connect and ping #1', function (t) {
 	var zkc = new mod_zkc.Client({
+		log: log,
 		host: 'localhost',
 		port: zks['1'].clientPort
 	});
@@ -80,6 +87,7 @@ mod_tape.test('simple connect and ping #1', function (t) {
 
 mod_tape.test('simple connect and ping #3', function (t) {
 	var zkc = new mod_zkc.Client({
+		log: log,
 		host: 'localhost',
 		port: zks['3'].clientPort
 	});
@@ -101,11 +109,13 @@ mod_tape.test('write visibility', function (t) {
 	var connected = 0, closed = 0;
 
 	var zkc1 = new mod_zkc.Client({
+		log: log,
 		host: 'localhost',
 		port: zks['1'].clientPort
 	});
 	zkc1.connect();
 	var zkc2 = new mod_zkc.Client({
+		log: log,
 		host: 'localhost',
 		port: zks['2'].clientPort
 	});
@@ -158,11 +168,13 @@ mod_tape.test('cross-server data watch', function (t) {
 	var connected = 0, closed = 0;
 
 	var zkc1 = new mod_zkc.Client({
+		log: log,
 		host: 'localhost',
 		port: zks['1'].clientPort
 	});
 	zkc1.connect();
 	var zkc2 = new mod_zkc.Client({
+		log: log,
 		host: 'localhost',
 		port: zks['2'].clientPort
 	});
diff --git a/test/streams.test.js b/test/streams.test.js
index b76d239..ff0eef4 100644
--- a/test/streams.test.js
+++ b/test/streams.test.js
@@ -10,6 +10,12 @@ const mod_tape = require('tape');
 
 const mod_zkbuf = require('../lib/zk-buffer');
 const mod_zkstreams = require('../lib/zk-streams');
+const mod_bunyan = require('bunyan');
+
+var log = mod_bunyan.createLogger({
+	name: 'zkstream-test',
+	level: process.env.LOG_LEVEL || 'info'
+});
 
 /* An example packet capture of "zkCli ls /" */
 var CAPTURE1 = [
-- 
2.21.0

