commit 5614f41bac9be32990fc5373c37a1ffc5a4ffd29
Author: Tim Foster <tim.foster@joyent.com>
Date:   2019-06-21T16:01:55+01:00 (4 months ago)
    
    TOOLS-2143 mountain-gorilla should be retired

diff --git a/docs/developer-guide/mg-index.md b/docs/developer-guide/mg-index.md
new file mode 100644
index 0000000..0f34596
--- /dev/null
+++ b/docs/developer-guide/mg-index.md
@@ -0,0 +1,572 @@
+---
+title: Mountain Gorilla
+markdown2extras: tables, cuddled-lists
+apisections:
+---
+<!--
+    This Source Code Form is subject to the terms of the Mozilla Public
+    License, v. 2.0. If a copy of the MPL was not distributed with this
+    file, You can obtain one at http://mozilla.org/MPL/2.0/.
+-->
+
+<!--
+    Copyright (c) 2018, Joyent, Inc.
+-->
+
+# Mountain Gorilla
+
+A single repo to build all the parts of SDC and Manta. This is just a *build
+driver* repo, all the components are still in their respective repos.
+Ideally this repo isn't necessary. Instead we should move to eng.git holding
+shared tooling and each repo knowing fully how to build its own release bits.
+
+
+# tl;dr
+
+A new build of a SDC or Manta component typically works like this:
+
+    push to vmapi.git
+        -> triggers a <https://jenkins.joyent.us/job/vmapi> build in Jenkins
+        -> which uses **MG's `vmapi` Makefile target** to build and upload
+           new vmapi bits to `/Joyent_Dev/stor/builds/vmapi`
+        -> which triggers a <https://jenkins.joyent.us/job/usbheadnode> build
+        -> uses MG's `usbheadnode` target to build and upload to
+           `/Joyent_Dev/stor/builds/usbheadnode`
+
+Then you can reflash your headnode using usb-headnode.git/bin/reflash, which
+will grab the latest tarball from that builds area directory. Or you can
+used incremental upgrade tooling (soon to be `sdcadm update vmapi`) to get
+the new vmapi build.
+
+Roughly the same process happens in appropriate dep order for all other
+SDC repos. See <https://jenkins.joyent.us/>.
+
+
+# Overview
+
+SDC (SmartDataCenter) has lots of components: the platform, agents, the core
+zones like vmapi & napi, components that build both like amon and ca, and the
+usb-headnode.git build that puts together the final shipping products. MG is the
+meta-repo that knows how to fetch and build each of them.
+
+An MG build generally works as follows (see ./tools/jenkins-build for more
+details).
+
+1. Clone mountain-gorilla.git
+2. Configure to build one component. This pre-fetches the relevant repo(s)
+   and dependencies (pre-built bits, dependent SDC component bits, pkgsrc,
+   images).
+3. Build it.
+4. Upload its built "bits" to a structured layout of bits at
+   `/Joyent_Dev/stor/builds` in Manta.
+5. Publish a new image to updates.joyent.com.
+
+Using vmapi as an example (see "Prerequisites" section below):
+
+    git clone git@github.com:joyent/mountain-gorilla.git    # 1.
+    cd mountain-gorilla
+    ./configure -t vmapi -b master -d Joyent_Dev         # 2.
+    gmake vmapi                                          # 3.
+    MG_TARGET=vmapi gmake manta_upload_jenkins            # 4.
+        # New bits at /Joyent_Dev/stor/builds/vmapi/$branch-$timestamp/
+    MG_TARGET=vmapi gmake jenkins_publish_image           # 5.
+        # `updates-imgadm list name=vmapi` to see added VMAPI image.
+
+The full set of targets that MG supports is both in
+[targets.json](https://mo.joyent.com/mountain-gorilla/blob/master/targets.json)
+(nice and clean) and
+[Makefile](https://mo.joyent.com/mountain-gorilla/blob/master/Makefile)
+(ugly boilerplate that should be templatized away).
+
+
+
+# Prerequisites
+
+There are a lot of prerequisites to build the SDC components. For all
+but the platform you will need:
+
+- a SmartOS zone of the appropriate image. At the time of writing most
+  services are using 'sdc-smartos@1.6.3', and a few are using 'sdc-multiarch'.
+- python, gcc, gmake, et al from pkgsrc
+
+The easiest way to get the required components is to use the jenkins-agent-*
+builds from updates.joyent.com (experimental channel).
+
+
+# Branches
+
+99% of the time MG builds just use (and default to) the "master" branch
+and that'll be all you need to know. However, MG supports building branches
+other than just "master". This is used for our bi-weekly sprint release
+builds:
+
+    ./configure -t amon -b release-YYYYMMDD
+
+However, to get a build of a feature branch, typically you only have that
+branch in *your* repo and not in ancillary repos. For that reason, MG supports
+the idea of a "TRY_BRANCH" to mean: "try pulling from TRY_BRANCH first, else
+fallback to BRANCH". This allows you to get a feature branch build like so:
+
+    ./configure -t cnapi -B CNAPI-1234 -b master
+
+or using the UI in jenkins:
+
+    # https://jenkins.joyent.us/job/cnapi/build
+    BRANCH:     master
+    TRY_BRANCH: CNAPI-123
+
+# Gerrit integration
+
+Mountain Gorilla also supports building a particular patchset from the Joyent
+Gerrit instance http://cr.joyent.us/ with the `-g` option:
+
+    ./configure -t cnapi -g 5013/11
+
+or `MG_GERRIT_CR` in Jenkins.  This will translate from the given patchset
+version into the necessary refspec, and use it in the same manner as
+`TRY_BRANCH` above.  (As a consequence, this doesn't support building from
+multiple different Gerrit CRs.)
+
+# Bits directory structure
+
+MG uploads build bits to a controlled directory structure at
+`/Joyent_Dev/stor/builds` in Manta. The MG `./configure ...` step handles
+downloading pre-built dependencies from this structure. The usb-headnode and
+agents-installer builds also rely on this structure.
+
+    /Joyent_Dev/stor/builds/
+        $job/                   # Typically $job === MG $target name
+            $branch-latest      # File with path to latest ".../$branch-$timestamp"
+            ...
+            $branch-$timestamp/
+                $target/
+                    ...the target's built bits...
+                ...all dependent bits and MG configuration...
+
+For example:
+
+    /Joyent_Dev/stor/builds/
+        amon/
+            master-latest
+            master-20130208T215745Z/
+            ...
+            master-20130226T191921Z/
+                config.mk
+                md5sums.txt
+                amon/
+                    amon-agent-master-20130226T191921Z-g7cd3e28.tgz
+                    amon-pkg-master-20130226T191921Z-g7cd3e28.tar.bz2
+                    amon-relay-master-20130226T191921Z-g7cd3e28.tgz
+                    build.log
+        usbheadnode
+            master-latest
+            ...
+            master-20130301T004335Z/
+                config.mk
+                md5sums.txt
+                usbheadnode/
+                    boot-master-20130301T004335Z-gad6dfc4.tgz
+                    coal-master-20130301T004335Z-gad6dfc4.tgz
+                    usb-master-20130301T004335Z-gad6dfc4.tgz
+                    build.log
+                    build.spec.local
+
+All those "extra" pieces (build log, md5sums.txt, config.mk)
+are there to be able to debug and theoretically reproduce builds.
+The "md5sums.txt" is used by the usb-headnode build to ensure uncorrupted
+downloads.
+
+
+# Jenkins
+
+We use [Jenkins](https://jenkins.joyent.us)
+([docs](https://hub.joyent.com/wiki/display/dev/Jenkins)] for continuous
+builds of all of SDC. Almost every relevant git repo is setup to trigger
+a build of the relevant jobs in Jenkins. See the "tl;dr" above for
+what happens after a push to a repo.
+
+
+## How Jenkins builds an SDC zone image
+
+In the "Overview" above we showed the list of files generated by an amon build.
+This section will explain how we go from clicking the build button in Jenkins to
+having those files in Manta.
+
+Details on the Jenkins setup itself are available only within Joyent at:
+
+https://mo.joyent.com/docs/engdoc/master/jenkins/index.html
+
+but the rest of this section will explain what is done once a Jenkins agent is
+chosen.
+
+The determination of which agent we should send a job to happens based on
+"labels". Which you can see in the job configuration and the build agent
+configuration. The job will only build where the labels between the two
+match.
+
+Having selected a agent, Jenkins will send the job to the agent over the
+connection it holds open to the jenkins process running in the agent zone. What
+gets run is what's listed in the 'Execute Shell / Command' section of the job's
+configuration.
+
+Simplified, what most of our jobs do here is:
+
+    git clone git@github.com:joyent/mountain-gorilla.git   # aka "MG"
+    cd mountain-gorilla
+    ./configure -t <target>
+    gmake <target>
+    gmake manta_upload_jenkins  # which runs mountain-gorilla.git/tools/mantaput-bits
+    gmake jenkins_publish_image # which uploads to updates.joyent.com
+
+The `configure -t <target>` here usually clones the repo(s) required and pulls
+down dependencies from npm and Manta. This is mountain-gorilla.git/configure in
+case you need to look at it.
+
+With all the components downloaded `gmake <job>` builds all the bits that will
+end up in /opt/smartdc/$app in the zone. This is the part that's critical to
+be run on an ancient platform so that we know it will work on any HN/CN we want
+to deploy to in JPC. This generates a tarball.
+
+After building the tarball but still within `gmake <job>`, we call:
+`./tools/prep_dataset_in_jpc.sh` which is the newest component here and the one
+that includes many of the components that talk to Manta and JPC and are the
+ones that fail most often. What this does (again simplified) is:
+
+ - provision a new zone in JPC using the g3-standard-2-smartos
+ - wait for the zone to be ssh-loginable (this sometimes times out at 20m)
+ - use ssh to send over the tarball and unpack
+ - install packages listed in mountain-gorilla.git/targets.json
+ - if smartos-1.6.3: drop tools/clean-image.sh into /opt/local/bin/sm-prepare-image
+   (necessary for image creation to work on the old smartos-1.6.3 image)
+ - use sdc-createimagefrommachine to create image from the VM
+ - wait for the state of the image to be 'active' (or fail if it goes to failed)
+ - deletes the VM
+ - uses sdc-exportimage to send the image to Manta
+ - deletes the image
+ - downloads the manifest + image from Manta to push to updates.joyent.com
+ - modifies the manifest and pushes it back to Manta
+
+This is most of the new stuff over the previous build setup in BH1 and the
+primary place where problems have been occurring.
+
+
+# Automatic builds (post-receive hooks)
+
+We use Github webhooks (for Github-hosted repos) to trigger the appropriate
+project build for pushes to any repository.
+
+An example of the former is:
+
+    [git@083a9e4b-8e3a-44f1-9e79-2056b3569e9d ~]$ cat repositories/imgapi.git/hooks/post-receive
+    #!/bin/bash
+    read oldrev newrev refname
+    bash $HOME/bin/common-post-receive-v2 -m -d imgapi -J imgapi $oldrev $newrev $refname
+
+It is the "-J imgapi" switch that results in jenkins being called:
+
+    ...
+    payload="{\"before\":\"$oldrev\",\"after\":\"$newrev\",\"ref\":\"$refname\"}"
+    curl -g --max-time 5 -sSf -k -X POST \
+        https://automation:PASS@jenkins.joyent.us/job/$JENKINS_JOB/buildWithParameters?payload="$payload"
+
+"common-post-receive-v2" lives in "gitosis-admin.git". It currently includes
+passwords so cannot be included in MG (arguably a better place).
+
+
+An example of the latter is (where "PASS" is the password of the special
+"github" user in our Jenkins, actually a ldap.joyent.com account):
+
+    https://github:PASS@jenkins.joyent.us/job/platform/buildWithParameters
+    SSL verification disabled (jenkins.jo uses a self-signed cert)
+    Content-type: application/x-www-form-encoded (to allow jenkins to take 'payload' as a build param)
+
+For example: <https://github.com/joyent/smartos-live/settings/hooks/286660>
+
+
+The design of our post-receive hooks is that a 'payload' param with JSON
+content minimally with:
+
+    {"ref": "<pushed git ref, e.g. refs/heads/master>"}
+
+is passed. This is a subset of the Github webhook payload. Each [jenkins job
+build step](./tools/jenkins-build) is prefixed with some code that will set
+`BRANCH` and `TRY_BRANCH` for that ref.  It strictly uses "BRANCH=$branch" for
+release branches to ensure that a release branch is *just bits using that
+release branch*. For feature branches, it uses "TRY_BRANCH=$branch
+BRANCH=master" as a convenience to allow builds where only one or a subset of
+involved repos have that branch.
+
+
+
+# Versioning
+
+No excuses. The [JEG](https://mo.joyent.com/docs/eng/master/) makes this
+easy for you.
+
+Thou shalt name thy SDC constituent build bits as follows:
+
+    NAME-BRANCH-TIMESTAMP[-GITDESCRIBE].TGZ
+
+Where:
+
+- NAME is the package name, e.g. "smartlogin", "ca-pkg".
+- BRANCH is the git branch, e.g. "master", "release-20110714". Use:
+
+        BRANCH=$(shell git symbolic-ref HEAD | awk -F / '{print $$3}')  # Makefile
+        BRANCH=$(git symbolic-ref HEAD | awk -F / '{print $3}')         # Bash script
+
+- TIMESTAMP is an ISO timestamp like "20110729T063329Z". Use:
+
+        TIMESTAMP=$(shell TZ=UTC date "+%Y%m%dT%H%M%SZ")    # Makefile
+        TIMESTAMP=$(TZ=UTC date "+%Y%m%dT%H%M%SZ")          # Bash script
+
+  Good. A timestamp is helpful (and in this position in the package name)
+  because: (a) it often helps to know approx. when a package was built when
+  debugging; and (b) it ensures that simple lexographical sorting of
+  "NAME-BRANCH-*" packages in a directory (as done by agents-installer and
+  usb-headnode) will make choosing "the latest" possible.
+
+  Bad. A timestamp *sucks* because successive builds in a dev tree will get a
+  new timestamp: defeating Makefile dependency attempts to avoid rebuilding.
+  Note that the TIMESTAMP is only necessary for released/published packages,
+  so for projects that care (e.g. ca), the TIMESTAMP can just be added for
+  release.
+
+- GITDESCRIBE gives the git sha for the repo and whether the repo was dirty
+  (had local changes) when it was built, e.g. "gfa1afe1-dirty", "gbadf00d".
+  Use:
+
+        # Need GNU awk for multi-char arg to "-F".
+        AWK=$((which gawk 2>/dev/null | grep -v "^no ") || which awk)
+        # In Bash:
+        GITDESCRIBE=g$(git describe --all --long --dirty | ${AWK} -F'-g' '{print $NF}')
+        # In a Makefile:
+        GITDESCRIBE=g$(shell git describe --all --long --dirty | $(AWK) -F'-g' '{print $$NF}')
+
+  Notes: "--all" allows this to work on a repo with no tags. "--long"
+  ensures we always get the "sha" part even if on a tag. We strip off the
+  head/tag part because we don't reliably use release tags in all our
+  repos, so the results can be misleading in package names. E.g., this
+  was the smartlogin package for the Lime release:
+
+        smartlogin-release-20110714-20110714T170222Z-20110414-2-g07e9e4f.tgz
+
+  The "20110414" there is an old old tag because tags aren't being added
+  to smart-login.git anymore.
+
+  "GITDESCRIBE" is *optional*. However, the only reason I currently see to
+  exclude it is if the downstream user of the package cannot handle it in
+  the package name. The "--dirty" flag is *optional* (though strongly
+  suggested) to allow repos to deal with possibly intractable issues (e.g. a
+  git submodule that has local changes as part of the build that can't be
+  resolved, at least not resolved quickly).
+
+- TGZ is a catch-all for whatever the package format is. E.g.: ".tgz",
+  ".sh" (shar), ".md5sum", ".tar.bz2".
+
+
+# HOWTO: Cut an SDC bi-weekly sprint release
+
+The SmartDataCenter product currently does bi-weekly sprint release builds.
+This involves branching/tagging all relevant repositories, building them
+all, and "releasing/archiving" versions in our Jira issue tracker. This
+section documents how to perform a release.
+
+1. Branch/tag all the repos.
+   Run the following on a machine with good connectivity (you'll be cloning
+   all SDC's repos).
+
+        git clone git@github.com:joyent/mountain-gorilla.git
+        cd mountain-gorilla
+        RELDATE=$(date +%Y%m%d)
+        ./tools/check-repos-for-release -h    # grok what this does
+        ./tools/check-repos-for-release -a $RELDATE
+
+   If running this fails, it is safe to re-run to pick up where it left off.
+
+   This will trigger builds with "BRANCH=release-$RELDATE" for all components.
+   You can watch the build queue pile up at <https://jenkins.joyent.us/>.
+
+   *Release branch* builds are strict (see the section above on automatic
+   builds) in that they will fail if dependencies do not yet have a build for
+   that branch. Therefore we expect some builds (e.g. usbheadnode) to fail
+   until all components, in particular the slower "platform" build, have had
+   time to complete.
+
+2. Babysit builds in Jenkins. Currently our builds are not as reliable as
+   we'd like, so failures do occur. The best strategy is probably:
+
+    - Allow an initial pass of many of the builds to complete.
+    - Watch the agentsshar build (https://jenkins.joyent.us/job/agentsshar/)
+      (with BRANCH=release-$RELDATE) for failures. Check its console log
+      to see if failures are due to dependent agent builds not having
+      completed. If so, manually restart those builds.
+    - Watch the usbheadnode build (https://jenkins.joyent.us/job/usbheadnode/)
+      (with BRANCH=release-$RELDATE) for failures. Check its console log
+      to see if failures are due to dependent agent builds not having
+      completed. If so, manually restart those builds.
+    - Use `./tools/ls-missing-release-builds release-YYYYMMDD` to list
+      builds that are missing for this release. It provides URLs to the
+      Jenkins page to start the appropriate build.
+
+    That this babysitting is required is lame. We should attempt to fix
+    this (TODO).
+
+3. "Release" this sprint version in our Jira projects:
+
+        cd .../mountain-gorilla/tools/jira
+        ./releaseversion.sh 'YYYY-MM-DD NAME'
+        # E.g.: ./releaseversion.sh '2014-07-10 Skynet'
+
+4. "Archive" the *previous* sprint version in our Jira projects:
+
+        cd .../mountain-gorilla/tools/jira
+        ./archiveversion.sh 'YYYY-MM-DD NAME'
+        # E.g.: ./archiveversion.sh '2014-06-26 Robocop'
+
+5. When branches are cut, tell Keith that he can do the SmartOS build.
+   SmartOS does bi-weekly releases with the same timeline as SDC.
+
+6. (Eventually, the plan is to) Publish these release bits to the "staging"
+   channel of updates.joyent.com. Then, upgrade staging-1/2/3 to the latest
+   in the "staging" channel.
+
+
+There are some common failure pathologies:
+
+- "error: unexpected ref 'refs/tags/20140703': is not 'refs/heads'"
+  The webhook used on github-hosted repos will POST for both the *tag* push
+  and the *branch* push. We only build for branch pushes (i.e. where "ref"
+  startswith "refs/heads/"). IOW, this can be ignored.
+
+- "Read from remote host github.com: Connection timed out"
+  We hit git repos hard when everything starts building. Github often doesn't
+  like this. Short of us moving to not using github repos directly in our
+  "package.json" files, I don't know of a fix here.
+
+
+
+# HOWTO: Troubleshooting Jenkins build failures
+
+The first step in debugging build failures is to ensure that you understand how
+builds work. See the previous section for details. With that understanding in
+hand you should start looking at the "Console Output" in Jenkins for the failed
+build. Usually the end of the log will tell you why the build failed if you
+follow along in the code.
+
+The main sources of problems have been in the tools/prep_dataset_in_jpc.sh
+step from MG. This primarily has failed when provisioning to JPC or when talking
+to manta.
+
+
+
+# HOWTO: Add a new project/repo/job to MG
+
+*(Warning: This section is a little out of date.)*
+
+Add it as a top-lever property in targets.json, as an object with properties
+"repos" and "deps" minimally, both are arrays.
+
+- "repos" is an array of objects, with the property "url", pointing at a git url
+- "deps" is an array of strings, where the string is another top-level target in targets.json
+
+For example:
+
+    {
+      ...
+      mynewrepo: {
+        "repos": [ {"url": "git://github.com/joyent/mynewrepo.git" } ],
+        "deps": [ "platform" ]
+      },
+      ...
+    }
+
+Then you'll add the target to Makefile. MG's configure will automatically
+populate some Makefile values for you, noteably: xxx_BRANCH , xxx_SHA, but
+you will need to fill in the build stamp yourself. Configure will also git
+checkout your repo in build/
+
+    #---- MYNEWREPO
+
+    _mynewrepo_stamp=$(MYNEWREPO_BRANCH)-$(TIMESTAMP)-g$(MYNEWREPO_SHA)
+    MYNEWREPO_BITS=$(BITS_DIR)/mynewrepo/mynewrepo-pkg-$(_mynewrepo_stamp).tar.bz2
+
+    .PHONY: mynewrepo
+    mynewrepo: $(MYNEWREPO_BITS)
+
+    $(mynewrepo_BITS): build/mynewrepo
+      mkdir -p $(BITS_DIR)
+      (cd build/mynewrepo && TIMESTAMP=$(TIMESTAMP) BITS_DIR=$(BITS_DIR) gmake pkg release publish)
+      @echo "# Created mynewrepo bits (time `date -u +%Y%m%dT%H%M%SZ`):"
+      @ls -1 $(MYNEWREPO_BITS)
+      @echo ""
+
+    clean_mynewrepo:
+      rm -rf $(BITS_DIR)/mynewrepo
+      (cd build/mynewrepo && gmake clean)
+
+if you wish to build an application zone image, the process is roughly
+similar except you will need to add the "appliance":"true" property, the
+"pkgsrc" property and "dataset_uuid"
+
+    {
+      ...
+      "mynewrepo": {
+        "repos" : [ {"url":"git://github.com/joyent/mynewrepo.git"} ],
+        "appliance": "true",
+        "dataset_uuid": "01b2c898-945f-11e1-a523-af1afbe22822",
+        "pkgsrc": [
+          "sun-jre6-6.0.26",
+          "zookeeper-client-3.4.3",
+          "zookeeper-server-3.4.3"
+        ],
+        deps: []
+      },
+      ...
+    }
+
+where dataset\_uuid is the uuid of the source image you wish to build off
+pkgsrc is an array of strings of package names to install.
+
+Your Makefile target will look as above, with the addition of the xxx\_dataset target:
+
+
+    ...
+    MYNEWREPO_DATASET=$(BITS_DIR)/mynewrepo/mynewrepo-zfs-$(_mynewrepo_stamp).zfs.bz2
+
+    .PHONY: mynewrepo_dataset
+
+    mynewrepo_dataset: $(MYNEWREPO_DATASET)
+
+    $(MYNEWREPO_DATASET): $(MYNEWREPO_BITS)
+            @echo "# Build mynewrepo dataset: branch $(MYNEWREPO_BRANCH), sha $(MYNEWREPO_SHA), time `date -u +%Y%m%dT%H%M%SZ`"
+            ./tools/prep_dataset.sh -t $(MYNEWREPO_BITS) -o $(MYNEWREPO_DATASET) -p $(MYNEWREPO_PKGSRC)
+            @echo "# Created mynewrepo dataset (time `date -u +%Y%m%dT%H%M%SZ`):"
+            @ls -1 $(MYNEWREPO_DATASET)
+            @echo ""
+    ...
+
+prep\_dataset.sh is a script that generates images out of tarballs and lists
+of packages.
+
+It takes arguments of the form -t <tarball> where <tarball> is a .tar.gz
+file, containing a directory "root", which is unpacked to / -p "list of
+pkgsrc packages" where list of pkgsrc packages is a list of the pkgsrc
+packages to be installed in the zone.
+
+Configure will populate xxx\_DATASET and xxx\_PKGSRC based on targets.json.
+
+Additionally, you can set the dsadm URN for the target by adding the "urn"
+and "version" properties to targets.json, as properties of the target you
+wish to manipulate. These will show up as urn:version ( sdc:sdc:mynewrepo:0.1
+for instance ). To use them, configure will populate xxx\_URN and xxx\_VERSION
+for you in the Makefile.
+
+Note that these images can only be provisioned with the joyent-minimal brand.
+If one is provisioned with the joyent brand, that zone's networking may not be
+working.  Normally, the networking setup is done through zoneinit, but since
+that script has already run and had its effects undone (as part of the MG
+build), there's no mechanism to automatically bring that zone's VNIC up.  You
+can recover by manually enabling network/physical:default, but you should just
+be provisioning with the joyent-minimal brand instead.  See RELENG-337 for
+details.
diff --git a/docs/developer-guide/mg-readme.md b/docs/developer-guide/mg-readme.md
new file mode 100644
index 0000000..8d1eb87
--- /dev/null
+++ b/docs/developer-guide/mg-readme.md
@@ -0,0 +1,293 @@
+<!--
+    This Source Code Form is subject to the terms of the Mozilla Public
+    License, v. 2.0. If a copy of the MPL was not distributed with this
+    file, You can obtain one at http://mozilla.org/MPL/2.0/.
+-->
+
+<!--
+    Copyright (c) 2016, Joyent, Inc.
+-->
+
+# mountain-gorilla
+
+This repository is part of the Joyent Triton project. See the [contribution
+guidelines](https://github.com/joyent/triton/blob/master/CONTRIBUTING.md) --
+*Triton does not use GitHub PRs* -- and general documentation at the main
+[Triton project](https://github.com/joyent/triton) page.
+
+A single repo to build all the parts of Triton. This is just a *build driver*
+repo, all the components are still in their respective repos.
+See <https://mo.joyent.com/docs/mg> for a more complete introduction.
+
+
+# Quick start
+
+While MG theoretically knows how to "build the world", i.e all of Triton,
+the typical usage is to build one piece at a time. There is a make target
+(or targets) for each Triton component. So, for example, here is how you
+build VMAPI:
+
+    git clone --origin=cr https://cr.joyent.us/joyent/mountain-gorilla.git
+    cd mountain-gorilla
+    ./configure -t vmapi -d Joyent_Dev  # generates bits/config.mk and fetches repo and deps
+    make vmapi                          # builds in build/vmapi, bits in bits/...
+
+If that fails for you, you might be missing prerequisites. See
+<https://mo.joyent.com/docs/mg/master/#prerequisites>.
+
+
+If you'll actually be building, see "Prerequisites" section below first.
+
+
+The "bits/config.mk" contains all config information necessary to fully
+reproduce the build. There will be configure options to use some prebuilt
+bits (e.g. a prebuilt platform) -- so to fully reproduce in this scenario
+those pre-built bits will need to be available. The "configure" step might
+take a while because it needs to get/update all of the source repositories to
+get revision information (the git shas to be built are part of the created
+"config.mk" file)
+
+The end result is a "bits" directory with all the built components. Primarily
+this includes the release bits in "bits/usbheadnode": "coal-$VERSION.tgz",
+"usb-$VERSION.tgz", "boot-$VERSION.tgz" and "upgrade-$VERSION.tgz". However,
+also included are all the constituent built bits: agents, platform, ca, etc.
+
+The above configuration is to build the world from scratch. That
+takes around 2 hours. You can also build just the individual pieces, e.g.
+cloudapi:
+
+    ./configure -t cloudapi
+    make cloudapi
+
+Likewise for any target (`cat targets.json | json --keys`)
+
+To include ancillary closed repositories in a usb-headnode build (which the
+'usb-headnode' and 'usb-headnode-debug' targets will build), you need to pass
+the `-j` option to configure.  Note that this will cause your build to fail if
+you do not have access to the private ancillary repositories, so it should be
+used only when building Joyent products.
+
+
+# Prerequisites
+
+You need several components to build our images in Triton. The easiest way to
+get these is to use the (private repo) [jenkins-agent](https://github.com/joyent/jenkins-agent)
+builds but you can also manually install all the things from those images.
+
+You should now be able to build mountain-gorilla (MG): i.e. all of Triton.
+Let's try that:
+
+    git clone git@github.com:joyent/mountain-gorilla.git
+    cd mountain-gorilla
+    time (./configure && gmake) >build.log 2>&1 &; tail -f build.log
+
+
+# Adding a repository quickstart
+
+Add it as a top-lever property in targets.json, as an object with properties
+"repos" and "deps" minimally, both are arrays.
+
+- "repos" is an array of objects, with the property "url", pointing at a git url
+- "deps" is an array of strings, where the string is another top-level target in targets.json
+  (or optionally a "$branch/$target" to lock it to a branch, though the need for this
+  should be rare).
+
+For example:
+
+    {
+      ...
+      mynewrepo: {
+        "repos": [ {"url": "git://github.com/joyent/mynewrepo.git" } ],
+        "deps": [ "platform" ]
+      },
+      ...
+    }
+
+Then you'll add the target to Makefile. MG's configure will automatically
+populate some Makefile values for you, noteably: xxx_BRANCH , xxx_SHA, but
+you will need to fill in the build stamp yourself. Configure will also git
+checkout your repo in build/
+
+    #---- MYNEWREPO
+
+    _mynewrepo_stamp=$(MYNEWREPO_BRANCH)-$(TIMESTAMP)-g$(MYNEWREPO_SHA)
+    MYNEWREPO_BITS=$(BITS_DIR)/mynewrepo/mynewrepo-pkg-$(_mynewrepo_stamp).tar.bz2
+
+    .PHONY: mynewrepo
+    mynewrepo: $(MYNEWREPO_BITS)
+
+    $(mynewrepo_BITS): build/mynewrepo
+      mkdir -p $(BITS_DIR)
+      (cd build/mynewrepo && TIMESTAMP=$(TIMESTAMP) BITS_DIR=$(BITS_DIR) gmake pkg release publish)
+      @echo "# Created mynewrepo bits (time `date -u +%Y%m%dT%H%M%SZ`):"
+      @ls -1 $(MYNEWREPO_BITS)
+      @echo ""
+
+    clean_mynewrepo:
+      rm -rf $(BITS_DIR)/mynewrepo
+      (cd build/mynewrepo && gmake clean)
+
+if you wish to build an application zone image, the process is roughly
+similar except you will need to add the "appliance":"true" property, the
+"pkgsrc" property and "dataset_uuid"
+
+    {
+      ...
+      "mynewrepo": {
+        "repos" : [ {"url":"git://github.com/joyent/mynewrepo.git"} ],
+        "appliance": "true",
+        "dataset_uuid": "01b2c898-945f-11e1-a523-af1afbe22822",
+        "pkgsrc": [
+          "sun-jre6-6.0.26",
+          "zookeeper-client-3.4.3",
+          "zookeeper-server-3.4.3"
+        ],
+        deps: []
+      },
+      ...
+    }
+
+where dataset\_uuid is the uuid of the source image you wish to build off
+pkgsrc is an array of strings of package names to install.
+
+Your Makefile target will look as above, with the addition of the xxx\_dataset target:
+
+
+    ...
+    MYNEWREPO_DATASET=$(BITS_DIR)/mynewrepo/mynewrepo-zfs-$(_mynewrepo_stamp).zfs.bz2
+
+    .PHONY: mynewrepo_dataset
+
+    mynewrepo_dataset: $(MYNEWREPO_DATASET)
+
+    $(MYNEWREPO_DATASET): $(MYNEWREPO_BITS)
+            @echo "# Build mynewrepo dataset: branch $(MYNEWREPO_BRANCH), sha $(MYNEWREPO_SHA), time `date -u +%Y%m%dT%H%M%SZ`"
+            ./tools/prep_dataset.sh -t $(MYNEWREPO_BITS) -o $(MYNEWREPO_DATASET) -p $(MYNEWREPO_PKGSRC)
+            @echo "# Created mynewrepo dataset (time `date -u +%Y%m%dT%H%M%SZ`):"
+            @ls -1 $(MYNEWREPO_DATASET)
+            @echo ""
+    ...
+
+prep\_dataset.sh is a script that generates images out of tarballs and lists
+of packages.
+
+It takes arguments of the form -t <tarball> where <tarball> is a .tar.gz
+file, containing a directory "root", which is unpacked to / -p "list of
+pkgsrc packages" where list of pkgsrc packages is a list of the pkgsrc
+packages to be installed in the zone.
+
+Configure will populate xxx\_DATASET and xxx\_PKGSRC based on targets.json.
+
+Additionally, you can set the dsadm URN for the target by adding the "urn"
+and "version" properties to targets.json, as properties of the target you
+wish to manipulate. These will show up as urn:version ( sdc:sdc:mynewrepo:0.1
+for instance ). To use them, configure will populate xxx\_URN and xxx\_VERSION
+for you in the Makefile.
+
+Note that these images can only be provisioned with the joyent-minimal brand.
+If one is provisioned with the joyent brand, that zone's networking may not be
+working.  Normally, the networking setup is done through zoneinit, but since
+that script has already run and had its effects undone (as part of the MG
+build), there's no mechanism to automatically bring that zone's VNIC up.  You
+can recover by manually enabling network/physical:default, but you should just
+be provisioning with the joyent-minimal brand instead.  See RELENG-337 for
+details.
+
+
+
+# Package Versioning
+
+Thou shalt name thy Triton constituent build bits as follows:
+
+    NAME-BRANCH-TIMESTAMP[-GITDESCRIBE].TGZ
+
+where:
+
+- NAME is the package name, e.g. "smartlogin", "ca-pkg".
+- BRANCH is the git branch, e.g. "master", "release-20110714". Use:
+
+        BRANCH=$(shell git symbolic-ref HEAD | awk -F / '{print $$3}')  # Makefile
+        BRANCH=$(git symbolic-ref HEAD | awk -F / '{print $3}')         # Bash script
+
+- TIMESTAMP is an ISO timestamp like "20110729T063329Z". Use:
+
+        TIMESTAMP=$(shell TZ=UTC date "+%Y%m%dT%H%M%SZ")    # Makefile
+        TIMESTAMP=$(TZ=UTC date "+%Y%m%dT%H%M%SZ")          # Bash script
+
+  Good. A timestamp is helpful (and in this position in the package name)
+  because: (a) it often helps to know approx. when a package was built when
+  debugging; and (b) it ensures that simple lexographical sorting of
+  "NAME-BRANCH-*" packages in a directory (as done by agents-installer and
+  usb-headnode) will make choosing "the latest" possible.
+
+  Bad. A timestamp *sucks* because successive builds in a dev tree will get a
+  new timestamp: defeating Makefile dependency attempts to avoid rebuilding.
+  Note that the TIMESTAMP is only necessary for released/published packages,
+  so for projects that care (e.g. ca), the TIMESTAMP can just be added for
+  release.
+
+- GITDESCRIBE gives the git sha for the repo and whether the repo was dirty
+  (had local changes) when it was built, e.g. "gfa1afe1-dirty", "gbadf00d".
+  Use:
+
+        # Need GNU awk for multi-char arg to "-F".
+        AWK=$((which gawk 2>/dev/null | grep -v "^no ") || which awk)
+        # In Bash:
+        GITDESCRIBE=g$(git describe --all --long --dirty | ${AWK} -F'-g' '{print $NF}')
+        # In a Makefile:
+        GITDESCRIBE=g$(shell git describe --all --long --dirty | $(AWK) -F'-g' '{print $$NF}')
+
+  Notes: "--all" allows this to work on a repo with no tags. "--long"
+  ensures we always get the "sha" part even if on a tag. We strip off the
+  head/tag part because we don't reliably use release tags in all our
+  repos, so the results can be misleading in package names. E.g., this
+  was the smartlogin package for the Lime release:
+
+        smartlogin-release-20110714-20110714T170222Z-20110414-2-g07e9e4f.tgz
+
+  The "20110414" there is an old old tag because tags aren't being added
+  to smart-login.git anymore.
+
+  "GITDESCRIBE" is *optional*. However, the only reason I currently see to
+  exclude it is if the downstream user of the package cannot handle it in
+  the package name. The "--dirty" flag is *optional* (though strongly
+  suggested) to allow repos to deal with possibly intractable issues (e.g. a
+  git submodule that has local changes as part of the build that can't be
+  resolved, at least not resolved quickly).
+
+- TGZ is a catch-all for whatever the package format is. E.g.: ".tgz",
+  ".sh" (shar), ".md5sum", ".tar.bz2".
+
+
+## Exceptions
+
+The agents shar is a subtle exception:
+
+    agents-release-20110714-20110726T230725Z.sh
+
+That "release-20110714" really refers to the branch used to build the
+agent packages included in the shar. For typical release builds, however,
+the "agents-installer.git" repo is always also on a branch of the same
+name so there shouldn't be a mismatch.
+
+
+
+## Suggested Versioning Usage
+
+It is suggested that the Triton repos use something like this at the top of
+their Makefile to handle package naming (using the Joyent Engineering
+Guidelines, eng.git):
+
+    include ./Makefile.defs   # provides "STAMP"
+    ...
+    PKG_NAME=$(NAME)-$(STAMP).tgz
+
+
+Notes:
+- This gives the option of the TIMESTAMP being passed in. This is important
+  to allow an external driver -- e.g., moutain-gorilla, bamboo, CI -- to
+  predict the expected output files, and hence be able to raise errors if
+  expected files are not generated.
+- Consistency here will help avoid confusion, and surprises in things like
+  subtle differences in `awk` on Mac vs. SmartOS, various options to
+  `git describe`.
diff --git a/docs/developer-guide/release-engineering.md b/docs/developer-guide/release-engineering.md
new file mode 100644
index 0000000..94fc0c0
--- /dev/null
+++ b/docs/developer-guide/release-engineering.md
@@ -0,0 +1,166 @@
+<!--
+    This Source Code Form is subject to the terms of the Mozilla Public
+    License, v. 2.0. If a copy of the MPL was not distributed with this
+    file, You can obtain one at http://mozilla.org/MPL/2.0/.
+-->
+
+<!--
+    Copyright 2019 Joyent, Inc.
+-->
+
+# Release Engineering
+
+This document describes some of the details on the release engineering process
+for Triton and Manta. Over time, we expect to include more information here
+on how to produce a full release.
+
+Developer documentation on
+[building Manta and Triton is also available.](https://github.com/joyent/triton/blob/master/docs/developer-guide/building.md)
+
+
+# Bits directory structure
+
+Joyent engineering builds upload build bits to a controlled directory structure at
+`/Joyent_Dev/stor/builds` in Manta. The `sdc-headnode` and `agents-installer`
+rely on this structure, as do the Triton
+[release engineering scripts.](https://github.com/joyent/triton/blob/master/tools/releng)
+
+    /Joyent_Dev/stor/builds/
+        $job/                   # Typically $job === Jenking job name
+            $branch-latest      # File with path to latest ".../$branch-$timestamp"
+            ...
+            $branch-$timestamp/
+                $target/
+                    ...the target's built bits...
+                ...all dependent bits and MG configuration...
+
+For example:
+
+    /Joyent_Dev/stor/builds/
+        amon/
+            master-latest
+            master-20130208T215745Z/
+            ...
+            master-20130226T191921Z/
+                config.mk
+                md5sums.txt
+                amon/
+                    amon-agent-master-20130226T191921Z-g7cd3e28.tgz
+                    amon-pkg-master-20130226T191921Z-g7cd3e28.tar.bz2
+                    amon-relay-master-20130226T191921Z-g7cd3e28.tgz
+                    build.log
+        headnode
+            master-latest
+            ...
+            master-20130301T004335Z/
+                config.mk
+                md5sums.txt
+                headnode/
+                    boot-master-20130301T004335Z-gad6dfc4.tgz
+                    coal-master-20130301T004335Z-gad6dfc4.tgz
+                    usb-master-20130301T004335Z-gad6dfc4.tgz
+                    build.log
+                    build.spec.local
+
+All those "extra" pieces (build log, md5sums.txt, config.mk)
+are there to be able to debug and theoretically reproduce builds.
+The "md5sums.txt" is used by the headnode build to ensure uncorrupted
+downloads.
+
+
+## Package Versioning
+
+Thou shalt name thy Triton constituent build bits as follows:
+
+    NAME-BRANCH-TIMESTAMP[-GITDESCRIBE].TGZ
+
+where:
+
+- NAME is the package name, e.g. "smartlogin", "ca-pkg".
+- BRANCH is the git branch, e.g. "master", "release-20110714". Use:
+
+        BRANCH=$(shell git symbolic-ref HEAD | awk -F / '{print $$3}')  # Makefile
+        BRANCH=$(git symbolic-ref HEAD | awk -F / '{print $3}')         # Bash script
+
+- TIMESTAMP is an ISO timestamp like "20110729T063329Z". Use:
+
+        TIMESTAMP=$(shell TZ=UTC date "+%Y%m%dT%H%M%SZ")    # Makefile
+        TIMESTAMP=$(TZ=UTC date "+%Y%m%dT%H%M%SZ")          # Bash script
+
+  Good. A timestamp is helpful (and in this position in the package name)
+  because: (a) it often helps to know approx. when a package was built when
+  debugging; and (b) it ensures that simple lexographical sorting of
+  "NAME-BRANCH-*" packages in a directory (as done by agents-installer and
+  usb-headnode) will make choosing "the latest" possible.
+
+  Bad. A timestamp *sucks* because successive builds in a dev tree will get a
+  new timestamp: defeating Makefile dependency attempts to avoid rebuilding.
+  Note that the TIMESTAMP is only necessary for released/published packages,
+  so for projects that care (e.g. ca), the TIMESTAMP can just be added for
+  release.
+
+- GITDESCRIBE gives the git sha for the repo and whether the repo was dirty
+  (had local changes) when it was built, e.g. "gfa1afe1-dirty", "gbadf00d".
+  Use:
+
+        # Need GNU awk for multi-char arg to "-F".
+        AWK=$((which gawk 2>/dev/null | grep -v "^no ") || which awk)
+        # In Bash:
+        GITDESCRIBE=g$(git describe --all --long --dirty | ${AWK} -F'-g' '{print $NF}')
+        # In a Makefile:
+        GITDESCRIBE=g$(shell git describe --all --long --dirty | $(AWK) -F'-g' '{print $$NF}')
+
+  Notes: "--all" allows this to work on a repo with no tags. "--long"
+  ensures we always get the "sha" part even if on a tag. We strip off the
+  head/tag part because we don't reliably use release tags in all our
+  repos, so the results can be misleading in package names. E.g., this
+  was the smartlogin package for the Lime release:
+
+        smartlogin-release-20110714-20110714T170222Z-20110414-2-g07e9e4f.tgz
+
+  The "20110414" there is an old old tag because tags aren't being added
+  to smart-login.git anymore.
+
+  "GITDESCRIBE" is *optional*. However, the only reason I currently see to
+  exclude it is if the downstream user of the package cannot handle it in
+  the package name. The "--dirty" flag is *optional* (though strongly
+  suggested) to allow repos to deal with possibly intractable issues (e.g. a
+  git submodule that has local changes as part of the build that can't be
+  resolved, at least not resolved quickly).
+
+- TGZ is a catch-all for whatever the package format is. E.g.: ".tgz",
+  ".sh" (shar), ".md5sum", ".tar.bz2".
+
+
+## Exceptions
+
+The agents shar is a subtle exception:
+
+    agents-release-20110714-20110726T230725Z.sh
+
+That "release-20110714" really refers to the branch used to build the
+agent packages included in the shar. For typical release builds, however,
+the "agents-installer.git" repo is always also on a branch of the same
+name so there shouldn't be a mismatch.
+
+
+
+## Suggested Versioning Usage
+
+It is suggested that the Triton repos use something like this at the top of
+their Makefile to handle package naming (using the Joyent Engineering
+Guidelines, eng.git):
+
+    include ./deps/eng/tools/Makefile.defs   # provides "STAMP"
+    ...
+    PKG_NAME=$(NAME)-$(STAMP).tgz
+
+
+Notes:
+- This gives the option of the TIMESTAMP being passed in. This is important
+  to allow build tools -- e.g., eng.git, CI -- to
+  predict the expected output files, and hence be able to raise errors if
+  expected files are not generated.
+- Consistency here will help avoid confusion, and surprises in things like
+  subtle differences in `awk` on Mac vs. SmartOS, various options to
+  `git describe`.
diff --git a/tools/releng/check-repos-for-release b/tools/releng/check-repos-for-release
new file mode 100755
index 0000000..cf22318
--- /dev/null
+++ b/tools/releng/check-repos-for-release
@@ -0,0 +1,191 @@
+#!/bin/bash
+#
+# This Source Code Form is subject to the terms of the Mozilla Public
+# License, v. 2.0. If a copy of the MPL was not distributed with this
+# file, You can obtain one at http://mozilla.org/MPL/2.0/.
+#
+
+#
+# Copyright 2019 Joyent, Inc.
+#
+
+#
+# Check if the Triton repos are prepared (branched
+# as appropriate) for an Triton/SmartOS release build. Will also apply
+# missing branch with the '-a' flag.
+#
+#
+
+if [[ -n "$TRACE" ]]; then
+    export PS4='[\D{%FT%TZ}] ${BASH_SOURCE}:${LINENO}: ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
+    set -o xtrace
+fi
+
+set -o errexit
+set -o pipefail
+
+#---- globals, config
+
+TOP=$(cd $(dirname $0)/../; pwd)
+WORKDIR="$TOP/tmp/check-repos-for-release"
+
+
+#---- functions
+
+function usage() {
+    if [[ -n "$1" ]]; then
+        echo "error: $1"
+        echo ""
+    fi
+    echo "Usage:"
+    echo "  check-repos-for-release [<options>] [release-]YYYYMMDD"
+    echo ""
+    echo "Options:"
+    echo "  -c CREDS        Provide creds for mo.joyent.com. If not given"
+    echo "                  will use 'MOLYBDENUM_CREDENTIALS' envvar."
+    echo "  -a              Create branch (*A*pply) if it is missing"
+    echo "  -t TARGET       Just run for the given Jenkins target. If not given"
+    echo "                  then all targets in 'targets.json' are used. Can be"
+    echo "                  specified multiple times."
+    echo ""
+    echo "Examples:"
+    echo "  check-repos-for-release 20111020"
+    echo "  check-repos-for-release -t usbheadnode 20111020"
+    echo "  check-repos-for-release -a release-20111020"
+    exit 1
+}
+
+function get_repo_url_from_targ {
+  local targ=$1
+  if [[ -z "$targ" ]]; then
+    targ='*'
+  fi
+  local urls=$(jr list -H -l mg=$targ -o httpsCloneUrl)
+  local ret=""
+  for url in $urls; do
+   ret="$ret $(echo $url)"
+  done
+  echo $ret
+}
+
+function get_repo_name_from_url {
+  targ=$1
+  echo $targ | cut -d ':' -f2 | xargs -I {} basename {} .git
+}
+
+function apply_missing_to_repo {
+    local repo_url=$1
+    local branch=$2
+
+    echo "Branch repo $repo_url for release: branch '$branch'"
+    repo_name=$(get_repo_name_from_url $repo_url)
+    mkdir -p $WORKDIR
+    cd $WORKDIR
+    if [[ -d "$repo_name" ]]; then
+        (cd $repo_name && git checkout master && git pull --rebase origin master)
+    else
+        git clone $repo_url $repo_name;
+    fi
+    cd $repo_name
+    git checkout master
+    if [[ -n "$branch" ]]; then
+      git checkout -B $branch
+      git push -q origin $branch
+    fi
+    git checkout master   # go back to master branch for subsequent runs
+}
+
+function check_repo_url {
+    local repo_url=$1
+    local targ=$2   # optional
+
+    repo_name=$(get_repo_name_from_url $repo_url)
+    local hit
+    if [[ -d "$WORKDIR/$repo_name" ]]; then
+        hit=$(cd $WORKDIR/$repo_name && git branch -a | (grep remotes/origin/$BRANCH || true))
+    fi
+    if [[ -z "$hit" ]]; then
+        hit=$(curl -sS https://mo.joyent.com/api/repos/$repo_name/refs -u $CREDS \
+            | json branches \
+            | grep "\"$BRANCH\"" \
+            || true)
+    fi
+    if [[ -z "$hit" ]]; then
+      if [[ $APPLY -eq 1 ]]; then
+        echo "Repo $repo_url ('$targ' target): missing '$BRANCH' branch"
+        apply_missing_to_repo $repo_url "$BRANCH"
+      else
+        echo "Repo $repo_url ('$targ' target): FAIL (no '$BRANCH' branch, use -a to apply)"
+      fi
+    else
+      echo "Repo $repo_url ('$targ' target): OK"
+    fi
+}
+
+function check_targ {
+    local targ=$1
+    local repo_urls="$(get_repo_url_from_targ $targ)"
+    for repo_url in $repo_urls; do
+        check_repo_url $repo_url $targ
+    done
+}
+
+
+#---- mainline
+
+APPLY=0   # whether to apply a branch to repo
+CREDS=
+TARGETS=
+while getopts "hac:t:" c; do
+    case "$c" in
+    h)
+        usage
+        ;;
+    a)
+        APPLY=1
+        ;;
+    c)
+        CREDS=$OPTARG
+        ;;
+    t)
+        TARGETS="$TARGETS $OPTARG"
+        ;;
+    *)
+        usage "illegal option -- $OPTARG"
+        ;;
+    esac
+done
+shift $((OPTIND - 1))
+
+RELEASE=$1
+if [[ -z "$RELEASE" ]]; then
+    usage "no RELEASE given"
+fi
+if [[ -n "$(echo "$RELEASE" | grep '^[0-9]\{8\}$' || true)" ]]; then
+    # YYYYMMDD
+    BRANCH=release-$RELEASE
+elif [[ -n "$(echo "$RELEASE" | grep '^release-[0-9]\{8\}$' || true)" ]]; then
+    BRANCH=$RELEASE
+else
+    fatal "'$RELEASE' does not match '[release-]YYYYMMDD'"
+fi
+
+if [[ -z "$CREDS" ]]; then
+    CREDS=$MOLYBDENUM_CREDENTIALS
+fi
+if [[ -z "$CREDS" ]]; then
+    usage "no mo.joyent.com crendentials: use '-c CREDS' or set MOLYBDENUM_CREDENTIALS"
+fi
+
+if [[ -z "$TARGETS" ]]; then
+    # gets a list of the 'mg' label, which is the jenkins job name.
+    TARGETS=$(jr list -H -l mg='*' -o labels | json -ag mg | sort -u \
+        grep -v sdcsso)
+fi
+
+for targ in $TARGETS; do
+  if [[ $targ == 'all' ]]; then
+    continue
+  fi
+  check_targ $targ
+done
diff --git a/tools/releng/launch-build b/tools/releng/launch-build
new file mode 100755
index 0000000..7ae7380
--- /dev/null
+++ b/tools/releng/launch-build
@@ -0,0 +1,136 @@
+#!/bin/bash
+#
+# This Source Code Form is subject to the terms of the Mozilla Public
+# License, v. 2.0. If a copy of the MPL was not distributed with this
+# file, You can obtain one at http://mozilla.org/MPL/2.0/.
+#
+
+#
+# Copyright 2019 Joyent, Inc.
+#
+
+#
+# This script allows starting Jenkins builds from the command-line. To
+# use this, you will need to get an API token for a Jenkins user, and
+# provide it to the script through the JENKINS_AUTH environment variable
+# or the -u option, in the form <user>:<api token>.
+#
+
+if [[ -n "$TRACE" ]]; then
+	export PS4='[\D{%FT%TZ}] ${BASH_SOURCE}:${LINENO}: ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
+	set -o xtrace
+fi
+set -o errexit
+set -o pipefail
+
+PROGNAME=$0
+
+function usage() {
+	if [[ -n $1 ]]; then
+		printf "%s: %s\n" "$PROGNAME" "$1" >&2
+	fi
+	printf "usage:\n    $PROGNAME [-v] [-H url] [-b BRANCH] [-F PLAT_FLAVOR] [-u auth] project\n" >&2
+	exit 2
+}
+
+while getopts 'F:H:u:b:hv' opt; do
+	case $opt in
+	H) JENKINS_URL=$OPTARG;;
+	u) JENKINS_AUTH=$OPTARG;;
+	b) BRANCH=$OPTARG;;
+	v) VERBOSE=true;;
+	F) PLAT_FLAVOR=$OPTARG;;
+	h) usage;;
+	:) usage "-$OPTARG requires an argument";;
+	\?) usage "illegal option: -$OPTARG";;
+	esac
+done
+
+PROJECT=${@:$OPTIND:1}
+
+if [[ -n "$PLAT_FLAVOR" ]]; then
+	case $PROJECT in
+		"platform"|"platform-debug")
+			case "$PLAT_FLAVOR" in
+				"triton"|"smartos"|"triton-and-smartos")
+					;;
+				*)
+					echo "ERROR: unknown platform flavor, expecting one of:"
+					echo "    smartos"
+					echo "    triton"
+					echo "    triton-and-smartos"
+					exit 1
+					;;
+			esac
+		;;
+	*)
+		usage "-F should only be used for platform or platform-debug builds"
+		;;
+	esac
+fi
+
+if [[ -z $PROJECT ]]; then
+	usage "project to build must be specified"
+fi
+
+if [[ -z $JENKINS_URL ]]; then
+	JENKINS_URL=https://jenkins.joyent.us
+fi
+
+if [[ -z $JENKINS_AUTH ]]; then
+	usage "JENKINS_AUTH must be set to <user>:<api token> (get it here: ${JENKINS_URL}/me/configure)"
+fi
+
+if [[ -n $BRANCH ]]; then
+	printf "Building %s with BRANCH=%s\n" "$PROJECT" "$BRANCH"
+	BUILD_PARAM=`printf '{"name":"BRANCH", "value": "%s"}' $BRANCH`
+fi
+
+#
+# The platform build expects a set of parameters to specify which branches
+# should be built. It's unfortunate we need to pass this parameter at all,
+# but we can't default jenkins to using ${BRANCH} in its CONFIGURE_PROJECTS
+# parameter, because that'll take the long-form git branch and write those
+# into the 'configure-projects' file.
+#
+PLAT_REPOS='illumos-extra illumos local/kvm-cmd local/kvm local/mdata-client local/ur-agent'
+for repo in $PLAT_REPOS; do
+	if [[ -z "$PLAT_PROJECTS_TEMPLATE" ]]; then
+		PLAT_PROJECTS_TEMPLATE="$repo: BRANCH: origin\n"
+	else
+		PLAT_PROJECTS_TEMPLATE="${PLAT_PROJECTS_TEMPLATE}$repo: BRANCH: origin\n"
+	fi
+done
+
+case $PROJECT in
+	"platform"|"platform-debug")
+		if [[ -n "$BRANCH" ]]; then
+			PLAT_PROJECTS=$(echo "${PLAT_PROJECTS_TEMPLATE}" | \
+			    sed -e "s/BRANCH/${BRANCH}/g")
+			BUILD_PARAM="${BUILD_PARAM},$(printf '{"name": "CONFIGURE_PROJECTS", "value": "%s"}' "${PLAT_PROJECTS}")"
+		fi
+		if [[ -n "$PLAT_FLAVOR" ]]; then
+			BUILD_PARAM="${BUILD_PARAM},$(printf '{"name": "PLATFORM_BUILD_FLAVOR", "value": "%s"}' "${PLAT_FLAVOR}")"
+		fi
+		;;
+	"headnode"|"headnode-debug"|"headnode-joyent")
+		if [[ -n "$BRANCH" ]]; then
+			BUILD_PARAM="${BUILD_PARAM},$(printf '{"name": "CONFIGURE_BRANCHES", "value": "bits-branch: %s"}' "${BRANCH}")"
+		fi
+		;;
+esac
+
+if [[ -n $VERBOSE ]]; then
+	CURL_OPTS=(-i)
+else
+	CURL_OPTS=(-s)
+fi
+
+CRUMB_URL="$JENKINS_URL/crumbIssuer/api/xml?xpath=concat(//crumbRequestField,\":\",//crumb)"
+BUILD_URL="$JENKINS_URL/job/$PROJECT/build"
+
+# Fetch the CSRF token to send in our request's headers
+CRUMB=`curl ${CURL_OPTS[@]} --user "$JENKINS_AUTH" "$CRUMB_URL"`
+
+curl ${CURL_OPTS[@]} -X POST -H "$CRUMB" "$BUILD_URL" --user "$JENKINS_AUTH" \
+    --data-urlencode json="{\"parameter\":[$BUILD_PARAM]}"
diff --git a/tools/releng/listengprojects b/tools/releng/listengprojects
new file mode 100755
index 0000000..415a99b
--- /dev/null
+++ b/tools/releng/listengprojects
@@ -0,0 +1,47 @@
+#!/bin/bash
+#
+# This Source Code Form is subject to the terms of the Mozilla Public
+# License, v. 2.0. If a copy of the MPL was not distributed with this
+# file, You can obtain one at http://mozilla.org/MPL/2.0/.
+#
+
+#
+# Copyright (c) 2017, Joyent, Inc.
+#
+
+#
+# List the Joyent Engineering Jira projects. This is defined as the set of
+# Jira projects on which we want the bi-weekly engineering release versions.
+# E.g., these ones:
+#
+#    $ jirash versions HEAD
+#    ...
+#    17529  2016-07-07 Super Stretch        released  archived
+#    17591  2016-07-21 Tangent Man          released         -
+#    17646  2016-08-04 Uncle Jumbo                 -         -
+#    ...
+#
+# When adding a new Jira project for eng the process is:
+# - add it to jira
+# - add it to the whitelist here
+# - manually add the upcoming sprint versions (see ./addsprintversion.sh) to it
+#
+
+if [[ -n "$TRACE" ]]; then
+    export PS4='[\D{%FT%TZ}] ${BASH_SOURCE}:${LINENO}: ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
+    set -o xtrace
+fi
+set -o errexit
+set -o pipefail
+
+ENG_PROJECTS="ADMINUI
+MANATEE
+MANTA
+MORAY
+OS
+RICHMOND
+ROGUE
+TOOLS
+TRITON"
+
+echo "$ENG_PROJECTS"
diff --git a/tools/releng/ls-missing-release-builds b/tools/releng/ls-missing-release-builds
new file mode 100755
index 0000000..75f8937
--- /dev/null
+++ b/tools/releng/ls-missing-release-builds
@@ -0,0 +1,126 @@
+#!/bin/bash
+#
+# This Source Code Form is subject to the terms of the Mozilla Public
+# License, v. 2.0. If a copy of the MPL was not distributed with this
+# file, You can obtain one at http://mozilla.org/MPL/2.0/.
+#
+
+#
+# Copyright 2019 Joyent, Inc.
+#
+
+#
+# Quick hack script that looks in /Joyent_Dev/public/builds/...
+# for SDC components for which there is no "release-YYYYMMDD"
+# build. These are ones that you may need to manually kick
+# off in jenkins.
+#
+
+if [[ -n "$TRACE" ]]; then
+    export PS4='[\D{%FT%TZ}] ${BASH_SOURCE}:${LINENO}: ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
+    set -o xtrace
+fi
+
+function fatal {
+    echo "$(basename $0): error: $1"
+    exit 1
+}
+
+# sanity-check that we can run jr and json. Do this before setting up pipefail.
+# Look for the environment variable before invoking jr, which otherwise prints
+# different advice.
+if [[ -z "$JR_MANIFESTS" ]]; then
+    fatal "$(basename $0): error: \$JR_MANIFESTS should be set in the environment. \
+    Example value: \
+    JR_MANIFESTS=/Volumes/projects/triton.git/repos.json,/Volumes/projects/triton-dev.git/repos-manta.json,/Volumes/projects/triton-dev.git/repos-smartos.json"
+fi
+
+for command in jr json; do
+    $($command -h 2>&1 > /dev/null)
+    if [[ $? -ne 0 ]]; then
+        fatal "Unable to run $command, please check your \$PATH"
+    fi
+done
+
+set -o errexit
+set -o pipefail
+
+#---- globals
+
+TOP=$(cd $(dirname $0)/../; pwd)
+
+#---- support stuff
+
+function usage() {
+    if [[ -n "$1" ]]; then
+        echo "error: $1"
+        echo ""
+    fi
+    echo "usage:"
+    echo "  ls-missing-release-builds [-s] RELEASE [TARGETS...]"
+    echo "   -s     Do a smartos-only build"
+    echo "          (this influences how we launch the platform build)"
+    echo ""
+    echo "example:"
+    echo "  ls-missing-release-builds release-20140703"
+    exit 1
+}
+
+# Specify the type of platform build to do.
+PLATFORM_BUILD_FLAVOR='smartos-and-triton'
+
+#---- mainline
+
+while getopts 'sh' opt; do
+    case $opt in
+    s) PLATFORM_BUILD_FLAVOR=smartos;;
+    h) usage;;
+    :) usage "-$OPTARG requires an argument";;
+    \?) usage "illegal option: -$OPTARG";;
+    esac
+    shift
+done
+
+release=$1
+if [[ -z "$release" ]]; then
+    usage "missing 'RELEASE' argument given"
+fi
+if [[ -z "$(echo $release | grep '^release-[0-9]\{8\}$' || true)" ]]; then
+    usage "given RELEASE, '$release', doesn't match /release-\d{8}/"
+fi
+shift
+
+targets="$*"
+if [[ -z "$targets" ]]; then
+    targets=$(jr list -H -l mg='*' -o labels | json -ag mg public | sort -u \
+        | grep -v '^sdcsso' \
+        | grep -v '^headnode-debug' \
+        | grep -v '^headnode-joyent-debug')
+fi
+
+# Ensure mls is setup properly at all.
+mls /Joyent_Dev/public/builds >/dev/null \
+    || fatal "cannot list /Joyent_Dev/public/builds"
+
+echo "$targets" | while read target public; do
+    if [[ "$public" == "true" ]]; then
+        latest_mpath=/Joyent_Dev/public/builds/$target/$release-latest
+    else
+        latest_mpath=/Joyent_Dev/stor/builds/$target/$release-latest
+    fi
+
+    case $target in
+        "platform"|"platform-debug")
+            PLAT_FLAVOR_ARG="-F $PLATFORM_BUILD_FLAVOR"
+            ;;
+        *)
+            PLAT_FLAVOR_ARG=""
+            ;;
+    esac
+
+    latest=$(mls $latest_mpath 2>/dev/null || true)
+    if [[ -z "$latest" ]]; then
+        echo "# $target, '$latest_mpath' does not exist" >&2
+        echo "./tools/launch-build ${PLAT_FLAVOR_ARG} -b $release $target"
+    fi
+done
diff --git a/tools/releng/purge-builds-from-manta b/tools/releng/purge-builds-from-manta
new file mode 100755
index 0000000..8842966
--- /dev/null
+++ b/tools/releng/purge-builds-from-manta
@@ -0,0 +1,344 @@
+#!/bin/bash
+#
+# This Source Code Form is subject to the terms of the Mozilla Public
+# License, v. 2.0. If a copy of the MPL was not distributed with this
+# file, You can obtain one at http://mozilla.org/MPL/2.0/.
+#
+
+#
+# Copyright 2019 Joyent, Inc.
+#
+
+#
+# Purge Joyent eng builds from Manta.
+#
+# Usage:
+#       purge-builds-from-manta -h                              # help output
+#       purge-builds-from-manta /Joyent_Dev/public/builds       # dry-run by default
+#       purge-builds-from-manta -f /Joyent_Dev/public/builds    # '-f' to actually del
+#
+# Builds build up in Manta. They need to eventually be purged so they don't
+# take up ever increasing space. This script knows how to remove Joyent eng
+# builds from a given Manta dir. This script encodes retention policy for
+# Joyent builds per
+# [RFD 47](https://github.com/joyent/rfd/blob/master/rfd/0047/README.md#builds).
+#
+# Here "eng builds" means the typical build dir layout used by tooling in
+# eng.git (and some others) for Joyent engineering builds:
+#
+#                                   # Example:
+#   $basedir/                       #   /Joyent_Dev/public/builds/
+#       $name/                      #       imgapi/
+#           $branch-$timestamp/     #           master-20160720T031418Z
+#               ...
+#           $branch-latest          #           master-latest
+#
+# For example:
+#
+#   $ mls /Joyent_Dev/public/builds/imgapi
+#   ...
+#   HEAD-2308-20160719T063933Z/
+#   HEAD-2308-latest
+#   master-20140929T205512Z/
+#   ...
+#   master-20160720T033514Z/
+#   master-latest
+#   ...
+#   release-20160721-20160721T180146Z/
+#   release-20160721-latest
+#   release-20160804-20160804T172843Z/
+#   release-20160804-20160804T182751Z/
+#   release-20160804-latest
+#
+
+if [[ -n "$TRACE" ]]; then
+    if [[ -t 1 ]]; then
+        export PS4='\033[90m[\D{%FT%TZ}] ${BASH_SOURCE}:${LINENO}: ${FUNCNAME[0]:+${FUNCNAME[0]}(): }\033[39m'
+    else
+        export PS4='[\D{%FT%TZ}] ${BASH_SOURCE}:${LINENO}: ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
+    fi
+    set -o xtrace
+fi
+set -o errexit
+set -o pipefail
+
+
+#---- globals, config
+
+# Get `mls` et al on the PATH.
+TOP=$(cd $(dirname $0)/../ >/dev/null; pwd)
+export PATH=$TOP/node_modules/.bin:$PATH
+
+#
+# A mapping from build name to the number of days' builds to keep.
+#
+# TTL (Time To Live) values are from RFD 47
+# (https://github.com/joyent/rfd/blob/master/rfd/0047/README.md#builds).
+#
+# Deliberately excluded build names for now (and the reason why):
+#    agentsshar-upgrade             paranoia
+#    platform                       want to discuss with OS guys
+#    platform-debug                 want to discuss with OS guys
+#    sdcsso                         build story isn't clear, eng hands off here
+#
+# If the build name is in neither the exclude list, nor the list of specific
+# TTL values, ttl_from_name() uses `jr` to verify it's a Manta/Triton component
+# and if so, applies a 365 day retention policy, and otherwise excludes it
+# from the purge.
+#
+DEFAULT_TTL_DAYS=365
+
+EXCLUDE_FROM_PURGE='[
+    "agentsshar-upgrade",
+    "platform",
+    "platform-debug",
+    "sdcsso"
+    ]'
+
+TTL_DAYS_FROM_NAME='{
+    "headnode": 30,
+    "headnode-debug": 30,
+    "headnode-joyent": 30,
+    "headnode-joyent-debug": 30
+}'
+
+
+opt_dryrun=yes    # Dry-run by default.
+opt_quiet=no
+
+
+#---- functions
+
+function usage() {
+    if [[ -n "$1" ]]; then
+        echo "error: $1"
+        echo ""
+    fi
+    echo 'Usage:'
+    echo '  purge-builds-from-manta [<options>] MANTA-BUILDS-DIR [NAMES...]'
+    echo ''
+    echo 'Options:'
+    echo '  -h          Print this help and exit.'
+    echo '  -q          Quiet output.'
+    echo '  -n          Dry-run (the default!).'
+    echo '  -f          Force actually doing deletions.'
+    echo ''
+    echo 'Examples:'
+    echo '  purge-builds-from-manta /Joyent_Dev/public/builds     # dry-run by default'
+    echo '  purge-builds-from-manta -f /Joyent_Dev/public/builds  # -f to actually rm'
+    echo '  purge-builds-from-manta -f /Joyent_Dev/public/builds vmapi   # limit subdir'
+    if [[ -n "$1" ]]; then
+        exit 1
+    else
+        exit 0
+    fi
+}
+
+function fatal {
+    echo "$(basename $0): error: $1" >&2
+    exit 1
+}
+
+function errexit
+{
+    [[ $1 -ne 0 ]] || exit 0
+    fatal "error exit status $1"
+}
+
+function log
+{
+    if [[ "$opt_quiet" == "no" ]]; then
+        echo "$*"
+    fi
+}
+
+function ttl_days_from_name
+{
+    local name
+    local ttl_days
+    local exclude
+    local known_component
+
+    name=$1
+
+    # See whether we have a non-default TTL for this component.
+    ttl_days=$(echo "$TTL_DAYS_FROM_NAME" | json -- $name)
+    if [[ -n "$ttl_days" ]]; then
+        echo $ttl_days
+    fi
+
+    # See if it's in the exclude list. If json has not filtered any results,
+    # we get non-empty output, indicating $name was in the exclude list.
+    exclude=$(echo "$EXCLUDE_FROM_PURGE" |
+        json -ac "this.indexOf('$name') != -1")
+    if [[ -n "$exclude" ]]; then
+        echo ""
+    fi
+
+    # finally, check to see if this is a known manta/triton component, which
+    # gets our default retention policy. If json returns a non-empty string,
+    # that indicates that we know about this component.
+    known_component=$(jr list -j -l mg='*' |
+        json -ag -c "this.labels.mg === '$name'")
+    if [[ -n "$known_component" ]]; then
+        echo $DEFAULT_TTL_DAYS
+    else
+        echo ""
+    fi
+}
+
+function has_dir_expired
+{
+    local dir
+    local ttl_days
+    dir=$1
+    ttl_days=$2
+
+    echo "has_dir_expired $dir $ttl_days"
+}
+
+function purge_dir
+{
+    local dir
+    dir="$1"
+    log "mrm -r $dir"
+    if [[ "$opt_dryrun" == "no" ]]; then
+        if [[ -n "$TRACE" ]]; then
+            mrm -rv "$dir"
+        else
+            mrm -r "$dir"
+        fi
+    fi
+}
+
+function purge_file_if_exist
+{
+    local file
+    local exists
+
+    file="$1"
+
+    # TODO: would be nice to have an example in `man mls` on how to do exists
+    # TODO: would be nice to have mtest to have `mtest -f ...` etc.
+    set +o errexit
+    exists=$(mls $file 2>/dev/null)
+    set -o errexit
+
+    if [[ -n "$exists" ]]; then
+        log "mrm    $file"   # spacing to line up with purge_dir log line
+        if [[ "$opt_dryrun" == "no" ]]; then
+            mrm "$file"
+        fi
+    fi
+}
+
+function purge_mg_builds
+{
+    local builds_dir
+    local name
+    local ttl_days
+    local cutoff
+    local dir
+    local dirs
+    local branches
+    local branch_dirs
+    local purged_all_in_branch
+
+    builds_dir=$1
+    name=$2
+    ttl_days=$(ttl_days_from_name $name)
+
+    if [[ -z "$ttl_days" ]]; then
+        log "# skip $builds_dir/$name: do not have a TTL for '$name'"
+        return
+    fi
+
+    # The 'cutoff' is the current time minus the ttl_days number of days,
+    # in the same format as the datestamps in the build dirs: YYYYMMDDTHHMMSSZ.
+    cutoff=$(node -e "c=new Date();
+        c.setDate(c.getDate() - $ttl_days);
+        console.log(c.toISOString().replace(/-|:|\.\d{3}/g,''))")
+    dryrun_msg=
+    if [[ $opt_dryrun != "no" ]]; then
+        dryrun_msg=", dry-run"
+    fi
+    log "# purge-builds-from-manta in $builds_dir/$name older than $cutoff" \
+        "(ttl $ttl_days days$dryrun_msg)"
+    dir=$builds_dir/$name
+    dirs=$(mls --type d $dir | sed -E 's#/$##')
+    branches=$(echo "$dirs" | sed -E 's/-[0-9]{8}T[0-9]{6}Z$//' | sort | uniq)
+
+    for branch in $branches; do
+        branch_dirs=$(echo "$dirs" | (grep "^$branch-" || true))
+
+        # Determine which dirs for this branch that we will be purging.
+        branch_dirs_to_purge=
+        for branch_dir in $branch_dirs; do
+            if [[ "$branch_dir" < "$branch-$cutoff" ]]; then
+                #log "# $branch_dir has expired"
+                branch_dirs_to_purge="$branch_dirs_to_purge $branch_dir"
+            fi
+        done
+        branch_dirs_to_purge=$(echo "$branch_dirs_to_purge" | xargs -n1)
+
+        # The "master" branch is special: if we would end up purging *all*
+        # remaining master branch dirs, then save that latest one.
+        purge_all_in_branch=no
+        if [[ "$branch_dirs" == "$branch_dirs_to_purge" ]]; then
+            if [[ "$branch" == "master" ]]; then
+                log "#   retain last master branch build:" \
+                    $(echo "$branch_dirs_to_purge" | tail -1)
+                branch_dirs_to_purge=$(echo "$branch_dirs_to_purge" | sed '$ d')
+            else
+                purge_all_in_branch=yes
+            fi
+        fi
+
+        for branch_dir in $branch_dirs_to_purge; do
+            #log "# $branch_dir has expired"
+            purge_dir $dir/$branch_dir
+        done
+        if [[ $purge_all_in_branch == "yes" ]]; then
+            purge_file_if_exist $dir/$branch-latest
+        fi
+    done
+}
+
+
+#---- mainline
+
+trap 'errexit $?' EXIT
+
+while getopts "hqnf" ch; do
+    case "$ch" in
+    h)
+        usage
+        ;;
+    q)
+        opt_quiet=yes
+        ;;
+    n)
+        opt_dryrun=yes
+        ;;
+    f)
+        opt_dryrun=no
+        ;;
+    *)
+        usage "illegal option -- $OPTARG"
+        ;;
+    esac
+done
+shift $((OPTIND - 1))
+
+BUILDS_DIR=$1
+[[ -n "$BUILDS_DIR" ]] || fatal "MANTA-BUILDS-DIR argument not given"
+shift
+NAMES="$*"
+
+if [[ -z "$NAMES" ]]; then
+    NAMES=$(mls --type d $BUILDS_DIR | sed -e 's#/$##' | xargs)
+fi
+
+for name in $NAMES; do
+    purge_mg_builds "$BUILDS_DIR" "$name"
+done
