commit 5bba29fc171daae1b10df5747b9323b3bb6ec3e1
Author: Tim Foster <tim.foster@joyent.com>
Date:   2019-06-27T17:32:58+01:00 (3 months ago)
    
    TOOLS-2143 mountain-gorilla should be retired

diff --git a/docs/developer-guide/release-engineering.md b/docs/developer-guide/release-engineering.md
new file mode 100644
index 0000000..fa7c8cf
--- /dev/null
+++ b/docs/developer-guide/release-engineering.md
@@ -0,0 +1,167 @@
+<!--
+    This Source Code Form is subject to the terms of the Mozilla Public
+    License, v. 2.0. If a copy of the MPL was not distributed with this
+    file, You can obtain one at http://mozilla.org/MPL/2.0/.
+-->
+
+<!--
+    Copyright 2019 Joyent, Inc.
+-->
+
+# Release Engineering
+
+This document describes some of the details on the release engineering process
+for Triton and Manta. Over time, we expect to include more information here
+on how to produce a full release.
+
+Developer documentation on
+[building Manta and Triton is also available.](https://github.com/joyent/triton/blob/master/docs/developer-guide/building.md)
+
+
+# Bits directory structure
+
+Joyent engineering builds upload build bits to a controlled directory structure at
+`/Joyent_Dev/stor/builds` in Manta. The `sdc-headnode` and `agents-installer`
+rely on this structure, as do the Triton
+[release engineering scripts.](https://github.com/joyent/triton/blob/master/tools/releng)
+
+    /Joyent_Dev/stor/builds/
+        $job/                   # Typically $job === Jenkins job name
+            $branch-latest      # File with path to latest ".../$branch-$timestamp"
+            ...
+            $branch-$timestamp/
+                $target/
+                    ...the target's built bits...
+                ...all dependent bits and build configuration...
+
+For example:
+
+    /Joyent_Dev/stor/builds/
+        amon/
+            master-latest
+            master-20130208T215745Z/
+            ...
+            master-20130226T191921Z/
+                config.mk
+                md5sums.txt
+                amon/
+                    amon-agent-master-20130226T191921Z-g7cd3e28.tgz
+                    amon-pkg-master-20130226T191921Z-g7cd3e28.tar.bz2
+                    amon-relay-master-20130226T191921Z-g7cd3e28.tgz
+                    build.log
+        headnode
+            master-latest
+            ...
+            master-20130301T004335Z/
+                config.mk
+                md5sums.txt
+                headnode/
+                    boot-master-20130301T004335Z-gad6dfc4.tgz
+                    coal-master-20130301T004335Z-gad6dfc4.tgz
+                    usb-master-20130301T004335Z-gad6dfc4.tgz
+                    build.log
+                    build.spec.local
+
+All those "extra" pieces (build log, md5sums.txt, config.mk)
+are there to be able to debug and theoretically reproduce builds.
+The "md5sums.txt" is used by the headnode build to ensure uncorrupted
+downloads.
+
+
+## Package Versioning
+
+Thou shalt name thy Triton constituent build bits as follows:
+
+    NAME-BRANCH-TIMESTAMP[-GITDESCRIBE].TGZ
+
+where:
+
+- NAME is the package name, e.g. "smartlogin", "ca-pkg".
+- BRANCH is the git branch, e.g. "master", "release-20110714". Use:
+
+        BRANCH=$(shell git symbolic-ref HEAD | awk -F / '{print $$3}')  # Makefile
+        BRANCH=$(git symbolic-ref HEAD | awk -F / '{print $3}')         # Bash script
+
+- TIMESTAMP is an ISO timestamp like "20110729T063329Z". Use:
+
+        TIMESTAMP=$(shell TZ=UTC date "+%Y%m%dT%H%M%SZ")    # Makefile
+        TIMESTAMP=$(TZ=UTC date "+%Y%m%dT%H%M%SZ")          # Bash script
+
+  Good. A timestamp is helpful (and in this position in the package name)
+  because: (a) it often helps to know approx. when a package was built when
+  debugging; and (b) it ensures that simple lexographical sorting of
+  "NAME-BRANCH-*" packages in a directory (as done by agents-installer and
+  usb-headnode) will make choosing "the latest" possible.
+
+  Bad. A timestamp *sucks* because successive builds in a dev tree will get a
+  new timestamp: defeating Makefile dependency attempts to avoid rebuilding.
+  Note that the TIMESTAMP is only necessary for released/published packages,
+  so for projects that care (e.g. ca), the TIMESTAMP can just be added for
+  release.
+
+- GITDESCRIBE gives the git sha for the repo and whether the repo was dirty
+  (had local changes) when it was built, e.g. "gfa1afe1-dirty", "gbadf00d".
+  Use:
+
+        # Need GNU awk for multi-char arg to "-F".
+        AWK=$((which gawk 2>/dev/null | grep -v "^no ") || which awk)
+        # In Bash:
+        GITDESCRIBE=g$(git describe --all --long --dirty | ${AWK} -F'-g' '{print $NF}')
+        # In a Makefile:
+        GITDESCRIBE=g$(shell git describe --all --long --dirty | $(AWK) -F'-g' '{print $$NF}')
+
+  Notes: "--all" allows this to work on a repo with no tags. "--long"
+  ensures we always get the "sha" part even if on a tag. We strip off the
+  head/tag part because we don't reliably use release tags in all our
+  repos, so the results can be misleading in package names. E.g., this
+  was the smartlogin package for the Lime release:
+
+        smartlogin-release-20110714-20110714T170222Z-20110414-2-g07e9e4f.tgz
+
+  The "20110414" there is an old old tag because tags aren't being added
+  to smart-login.git anymore.
+
+  "GITDESCRIBE" is *optional*. However, the only reason I currently see to
+  exclude it is if the downstream user of the package cannot handle it in
+  the package name. The "--dirty" flag is *optional* (though strongly
+  suggested) to allow repos to deal with possibly intractable issues (e.g. a
+  git submodule that has local changes as part of the build that can't be
+  resolved, at least not resolved quickly).
+
+- TGZ is a catch-all for whatever the package format is. E.g.: ".tgz",
+  ".sh" (shar), ".md5sum", '"tar.gz", ".tar.bz2".
+
+
+## Exceptions
+
+The agents shar is a subtle exception:
+
+    agents-release-20110714-20110726T230725Z.sh
+
+That "release-20110714" really refers to the branch used to build the
+agent packages included in the shar. For typical release builds, however,
+the "agents-installer.git" repo is always also on a branch of the same
+name so there shouldn't be a mismatch.
+
+
+
+## Suggested Versioning Usage
+
+It is suggested that the Triton repos use something like this at the top of
+their Makefile to handle package naming (using the Joyent Engineering
+Guidelines, eng.git):
+
+    ENGBLD_REQUIRE := $(shell git submodule update --init deps/eng)
+    include ./deps/eng/tools/Makefile.defs   # provides "STAMP"
+    ...
+    RELEASE_TARBALL = $(NAME)-pkg-$(STAMP).tar.gz
+
+
+Notes:
+- This gives the option of the TIMESTAMP being passed in. This is important
+  to allow build tools -- e.g., eng.git, CI -- to
+  predict the expected output files, and hence be able to raise errors if
+  expected files are not generated.
+- Consistency here will help avoid confusion, and surprises in things like
+  subtle differences in `awk` on Mac vs. SmartOS, various options to
+  `git describe`.
diff --git a/tools/releng/check-repos-for-release b/tools/releng/check-repos-for-release
new file mode 100755
index 0000000..266276a
--- /dev/null
+++ b/tools/releng/check-repos-for-release
@@ -0,0 +1,209 @@
+#!/bin/bash
+#
+# This Source Code Form is subject to the terms of the Mozilla Public
+# License, v. 2.0. If a copy of the MPL was not distributed with this
+# file, You can obtain one at http://mozilla.org/MPL/2.0/.
+#
+
+#
+# Copyright 2019 Joyent, Inc.
+#
+
+#
+# Check if the Triton repos are prepared (branched
+# as appropriate) for a Triton/SmartOS release build. Will also apply
+# missing branch with the '-a' flag.
+#
+#
+
+if [[ -n "$TRACE" ]]; then
+    export PS4='[\D{%FT%TZ}] ${BASH_SOURCE}:${LINENO}: ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
+    set -o xtrace
+fi
+
+for command in jr json; do
+    $command -h 2>&1 > /dev/null
+    if [[ $? -ne 0 ]]; then
+        echo "Unable to run $command, please check your \$PATH"
+        exit 1
+    fi
+done
+
+set -o errexit
+set -o pipefail
+
+#---- globals, config
+
+TOP=$(cd $(dirname $0)/../; pwd)
+WORKDIR="$TOP/tmp/check-repos-for-release"
+
+
+#---- functions
+
+function usage() {
+    if [[ -n "$1" ]]; then
+        echo "error: $1"
+        echo ""
+    fi
+    echo "Usage:"
+    echo "  check-repos-for-release [<options>] [release-]YYYYMMDD"
+    echo ""
+    echo "Options:"
+    echo "  -c CREDS        Provide creds for mo.joyent.com. If not given"
+    echo "                  will use 'MOLYBDENUM_CREDENTIALS' envvar."
+    echo "  -a              Create branch (*A*pply) if it is missing"
+    echo "  -t TARGET       Just run for the given Jenkins target. If not given"
+    echo "                  then all 'jr' targets with 'mg' labels are used."
+    echo "                  Can be specified multiple times."
+    echo ""
+    echo "Examples:"
+    echo "  check-repos-for-release 20111020"
+    echo "  check-repos-for-release -t usbheadnode 20111020"
+    echo "  check-repos-for-release -a release-20111020"
+    exit 1
+}
+
+function get_repo_url_from_targ {
+    local targ=$1
+    if [[ -z "$targ" ]]; then
+        targ='*'
+    fi
+    local urls=$(jr list -H -l mg=$targ -o httpsCloneUrl)
+    local ret=""
+    for url in $urls; do
+        ret="$ret $(echo $url)"
+    done
+    echo $ret
+}
+
+function get_repo_name_from_url {
+    targ=$1
+    echo $targ | cut -d ':' -f2 | xargs -I {} basename {} .git
+}
+
+function apply_missing_to_repo {
+    local repo_url=$1
+    local branch=$2
+
+    echo "Branch repo $repo_url for release: branch '$branch'"
+    repo_name=$(get_repo_name_from_url $repo_url)
+    mkdir -p $WORKDIR
+    cd $WORKDIR
+    if [[ -d "$repo_name" ]]; then
+        (cd $repo_name && git checkout master && git pull --rebase origin master)
+    else
+        git clone $repo_url $repo_name;
+    fi
+    cd $repo_name
+    git checkout master
+    if [[ -n "$branch" ]]; then
+      git checkout -B $branch
+      git push -q origin $branch
+    fi
+    git checkout master   # go back to master branch for subsequent runs
+}
+
+function check_repo_url {
+    local repo_url=$1
+    local targ=$2   # optional
+
+    repo_name=$(get_repo_name_from_url $repo_url)
+    local hit
+    if [[ -d "$WORKDIR/$repo_name" ]]; then
+        hit=$(cd $WORKDIR/$repo_name && git branch -a | (grep remotes/origin/$BRANCH || true))
+    fi
+    if [[ -z "$hit" ]]; then
+        hit=$(curl -sS https://mo.joyent.com/api/repos/$repo_name/refs -u $CREDS \
+            | json branches \
+            | grep "\"$BRANCH\"" \
+            || true)
+    fi
+    if [[ -z "$hit" ]]; then
+      if [[ $APPLY -eq 1 ]]; then
+        echo "Repo $repo_url ('$targ' target): missing '$BRANCH' branch"
+        apply_missing_to_repo $repo_url "$BRANCH"
+      else
+        echo "Repo $repo_url ('$targ' target): FAIL (no '$BRANCH' branch, use -a to apply)"
+      fi
+    else
+      echo "Repo $repo_url ('$targ' target): OK"
+    fi
+}
+
+function check_targ {
+    local targ=$1
+    local repo_urls="$(get_repo_url_from_targ $targ)"
+    for repo_url in $repo_urls; do
+        check_repo_url $repo_url $targ
+    done
+}
+
+
+#---- mainline
+
+APPLY=0   # whether to apply a branch to repo
+CREDS=
+TARGETS=
+while getopts "hac:t:" c; do
+    case "$c" in
+    h)
+        usage
+        ;;
+    a)
+        APPLY=1
+        ;;
+    c)
+        CREDS=$OPTARG
+        ;;
+    t)
+        TARGETS="$TARGETS $OPTARG"
+        ;;
+    *)
+        usage "illegal option -- $OPTARG"
+        ;;
+    esac
+done
+shift $((OPTIND - 1))
+
+RELEASE=$1
+if [[ -z "$RELEASE" ]]; then
+    usage "no RELEASE given"
+fi
+if [[ -n "$(echo "$RELEASE" | grep '^[0-9]\{8\}$' || true)" ]]; then
+    # YYYYMMDD
+    BRANCH=release-$RELEASE
+elif [[ -n "$(echo "$RELEASE" | grep '^release-[0-9]\{8\}$' || true)" ]]; then
+    BRANCH=$RELEASE
+else
+    fatal "'$RELEASE' does not match '[release-]YYYYMMDD'"
+fi
+
+if [[ -z "$CREDS" ]]; then
+    CREDS=$MOLYBDENUM_CREDENTIALS
+fi
+if [[ -z "$CREDS" ]]; then
+    usage "no mo.joyent.com crendentials: use '-c CREDS' or set MOLYBDENUM_CREDENTIALS"
+fi
+
+# sanity-check that we can run jr and json. Do this before setting up pipefail.
+# Look for the environment variable before invoking jr, which otherwise prints
+# different advice.
+if [[ -z "$JR_MANIFESTS" ]]; then
+    fatal "$(basename $0): error: \$JR_MANIFESTS should be set in the environment. \
+    Example value: \
+    JR_MANIFESTS=/Volumes/projects/triton.git/tools/jr-manifest.json,/Volumes/projects/manta.git/tools/jr-manifest.json,/Volumes/projects/smartos-live.git/tools/jr-manifest.json"
+fi
+
+if [[ -z "$TARGETS" ]]; then
+    # gets a list of the 'mg' label, which is the jenkins job name.
+    TARGETS=$(jr list -H -l mg='*' -o labels | json -ag mg | sort -u | \
+        grep -v sdcsso | \
+        grep -v sdcboot)
+fi
+
+for targ in $TARGETS; do
+  if [[ $targ == 'all' ]]; then
+    continue
+  fi
+  check_targ $targ
+done
diff --git a/tools/releng/launch-build b/tools/releng/launch-build
new file mode 100755
index 0000000..7ae7380
--- /dev/null
+++ b/tools/releng/launch-build
@@ -0,0 +1,136 @@
+#!/bin/bash
+#
+# This Source Code Form is subject to the terms of the Mozilla Public
+# License, v. 2.0. If a copy of the MPL was not distributed with this
+# file, You can obtain one at http://mozilla.org/MPL/2.0/.
+#
+
+#
+# Copyright 2019 Joyent, Inc.
+#
+
+#
+# This script allows starting Jenkins builds from the command-line. To
+# use this, you will need to get an API token for a Jenkins user, and
+# provide it to the script through the JENKINS_AUTH environment variable
+# or the -u option, in the form <user>:<api token>.
+#
+
+if [[ -n "$TRACE" ]]; then
+	export PS4='[\D{%FT%TZ}] ${BASH_SOURCE}:${LINENO}: ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
+	set -o xtrace
+fi
+set -o errexit
+set -o pipefail
+
+PROGNAME=$0
+
+function usage() {
+	if [[ -n $1 ]]; then
+		printf "%s: %s\n" "$PROGNAME" "$1" >&2
+	fi
+	printf "usage:\n    $PROGNAME [-v] [-H url] [-b BRANCH] [-F PLAT_FLAVOR] [-u auth] project\n" >&2
+	exit 2
+}
+
+while getopts 'F:H:u:b:hv' opt; do
+	case $opt in
+	H) JENKINS_URL=$OPTARG;;
+	u) JENKINS_AUTH=$OPTARG;;
+	b) BRANCH=$OPTARG;;
+	v) VERBOSE=true;;
+	F) PLAT_FLAVOR=$OPTARG;;
+	h) usage;;
+	:) usage "-$OPTARG requires an argument";;
+	\?) usage "illegal option: -$OPTARG";;
+	esac
+done
+
+PROJECT=${@:$OPTIND:1}
+
+if [[ -n "$PLAT_FLAVOR" ]]; then
+	case $PROJECT in
+		"platform"|"platform-debug")
+			case "$PLAT_FLAVOR" in
+				"triton"|"smartos"|"triton-and-smartos")
+					;;
+				*)
+					echo "ERROR: unknown platform flavor, expecting one of:"
+					echo "    smartos"
+					echo "    triton"
+					echo "    triton-and-smartos"
+					exit 1
+					;;
+			esac
+		;;
+	*)
+		usage "-F should only be used for platform or platform-debug builds"
+		;;
+	esac
+fi
+
+if [[ -z $PROJECT ]]; then
+	usage "project to build must be specified"
+fi
+
+if [[ -z $JENKINS_URL ]]; then
+	JENKINS_URL=https://jenkins.joyent.us
+fi
+
+if [[ -z $JENKINS_AUTH ]]; then
+	usage "JENKINS_AUTH must be set to <user>:<api token> (get it here: ${JENKINS_URL}/me/configure)"
+fi
+
+if [[ -n $BRANCH ]]; then
+	printf "Building %s with BRANCH=%s\n" "$PROJECT" "$BRANCH"
+	BUILD_PARAM=`printf '{"name":"BRANCH", "value": "%s"}' $BRANCH`
+fi
+
+#
+# The platform build expects a set of parameters to specify which branches
+# should be built. It's unfortunate we need to pass this parameter at all,
+# but we can't default jenkins to using ${BRANCH} in its CONFIGURE_PROJECTS
+# parameter, because that'll take the long-form git branch and write those
+# into the 'configure-projects' file.
+#
+PLAT_REPOS='illumos-extra illumos local/kvm-cmd local/kvm local/mdata-client local/ur-agent'
+for repo in $PLAT_REPOS; do
+	if [[ -z "$PLAT_PROJECTS_TEMPLATE" ]]; then
+		PLAT_PROJECTS_TEMPLATE="$repo: BRANCH: origin\n"
+	else
+		PLAT_PROJECTS_TEMPLATE="${PLAT_PROJECTS_TEMPLATE}$repo: BRANCH: origin\n"
+	fi
+done
+
+case $PROJECT in
+	"platform"|"platform-debug")
+		if [[ -n "$BRANCH" ]]; then
+			PLAT_PROJECTS=$(echo "${PLAT_PROJECTS_TEMPLATE}" | \
+			    sed -e "s/BRANCH/${BRANCH}/g")
+			BUILD_PARAM="${BUILD_PARAM},$(printf '{"name": "CONFIGURE_PROJECTS", "value": "%s"}' "${PLAT_PROJECTS}")"
+		fi
+		if [[ -n "$PLAT_FLAVOR" ]]; then
+			BUILD_PARAM="${BUILD_PARAM},$(printf '{"name": "PLATFORM_BUILD_FLAVOR", "value": "%s"}' "${PLAT_FLAVOR}")"
+		fi
+		;;
+	"headnode"|"headnode-debug"|"headnode-joyent")
+		if [[ -n "$BRANCH" ]]; then
+			BUILD_PARAM="${BUILD_PARAM},$(printf '{"name": "CONFIGURE_BRANCHES", "value": "bits-branch: %s"}' "${BRANCH}")"
+		fi
+		;;
+esac
+
+if [[ -n $VERBOSE ]]; then
+	CURL_OPTS=(-i)
+else
+	CURL_OPTS=(-s)
+fi
+
+CRUMB_URL="$JENKINS_URL/crumbIssuer/api/xml?xpath=concat(//crumbRequestField,\":\",//crumb)"
+BUILD_URL="$JENKINS_URL/job/$PROJECT/build"
+
+# Fetch the CSRF token to send in our request's headers
+CRUMB=`curl ${CURL_OPTS[@]} --user "$JENKINS_AUTH" "$CRUMB_URL"`
+
+curl ${CURL_OPTS[@]} -X POST -H "$CRUMB" "$BUILD_URL" --user "$JENKINS_AUTH" \
+    --data-urlencode json="{\"parameter\":[$BUILD_PARAM]}"
diff --git a/tools/releng/listengprojects b/tools/releng/listengprojects
new file mode 100755
index 0000000..415a99b
--- /dev/null
+++ b/tools/releng/listengprojects
@@ -0,0 +1,47 @@
+#!/bin/bash
+#
+# This Source Code Form is subject to the terms of the Mozilla Public
+# License, v. 2.0. If a copy of the MPL was not distributed with this
+# file, You can obtain one at http://mozilla.org/MPL/2.0/.
+#
+
+#
+# Copyright (c) 2017, Joyent, Inc.
+#
+
+#
+# List the Joyent Engineering Jira projects. This is defined as the set of
+# Jira projects on which we want the bi-weekly engineering release versions.
+# E.g., these ones:
+#
+#    $ jirash versions HEAD
+#    ...
+#    17529  2016-07-07 Super Stretch        released  archived
+#    17591  2016-07-21 Tangent Man          released         -
+#    17646  2016-08-04 Uncle Jumbo                 -         -
+#    ...
+#
+# When adding a new Jira project for eng the process is:
+# - add it to jira
+# - add it to the whitelist here
+# - manually add the upcoming sprint versions (see ./addsprintversion.sh) to it
+#
+
+if [[ -n "$TRACE" ]]; then
+    export PS4='[\D{%FT%TZ}] ${BASH_SOURCE}:${LINENO}: ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
+    set -o xtrace
+fi
+set -o errexit
+set -o pipefail
+
+ENG_PROJECTS="ADMINUI
+MANATEE
+MANTA
+MORAY
+OS
+RICHMOND
+ROGUE
+TOOLS
+TRITON"
+
+echo "$ENG_PROJECTS"
diff --git a/tools/releng/ls-missing-release-builds b/tools/releng/ls-missing-release-builds
new file mode 100755
index 0000000..db4838e
--- /dev/null
+++ b/tools/releng/ls-missing-release-builds
@@ -0,0 +1,128 @@
+#!/bin/bash
+#
+# This Source Code Form is subject to the terms of the Mozilla Public
+# License, v. 2.0. If a copy of the MPL was not distributed with this
+# file, You can obtain one at http://mozilla.org/MPL/2.0/.
+#
+
+#
+# Copyright 2019 Joyent, Inc.
+#
+
+#
+# Quick hack script that looks in /Joyent_Dev/public/builds/...
+# for SDC components for which there is no "release-YYYYMMDD"
+# build. These are ones that you may need to manually kick
+# off in jenkins.
+#
+
+if [[ -n "$TRACE" ]]; then
+    export PS4='[\D{%FT%TZ}] ${BASH_SOURCE}:${LINENO}: ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
+    set -o xtrace
+fi
+
+for command in jr json; do
+    $command -h 2>&1 > /dev/null
+    if [[ $? -ne 0 ]]; then
+        echo "Unable to run $command, please check your \$PATH"
+        exit 1
+    fi
+done
+
+set -o errexit
+set -o pipefail
+
+#---- globals
+
+TOP=$(cd $(dirname $0)/../; pwd)
+
+#---- support stuff
+
+function fatal {
+    echo "$(basename $0): error: $1"
+    exit 1
+}
+
+function usage() {
+    if [[ -n "$1" ]]; then
+        echo "error: $1"
+        echo ""
+    fi
+    echo "usage:"
+    echo "  ls-missing-release-builds [-s] RELEASE [TARGETS...]"
+    echo "   -s     Do a smartos-only build"
+    echo "          (this influences how we launch the platform build)"
+    echo ""
+    echo "example:"
+    echo "  ls-missing-release-builds release-20140703"
+    exit 1
+}
+
+# Specify the type of platform build to do.
+PLATFORM_BUILD_FLAVOR='smartos-and-triton'
+
+#---- mainline
+
+while getopts 'sh' opt; do
+    case $opt in
+    s) PLATFORM_BUILD_FLAVOR=smartos;;
+    h) usage;;
+    :) usage "-$OPTARG requires an argument";;
+    \?) usage "illegal option: -$OPTARG";;
+    esac
+    shift
+done
+
+release=$1
+if [[ -z "$release" ]]; then
+    usage "missing 'RELEASE' argument given"
+fi
+if [[ -z "$(echo $release | grep '^release-[0-9]\{8\}$' || true)" ]]; then
+    usage "given RELEASE, '$release', doesn't match /release-\d{8}/"
+fi
+shift
+
+# sanity-check that we can run jr and json. Do this before setting up pipefail.
+# Look for the environment variable before invoking jr, which otherwise prints
+# different advice.
+if [[ -z "$JR_MANIFESTS" ]]; then
+    fatal "$(basename $0): error: \$JR_MANIFESTS should be set in the environment. \
+    Example value: \
+    JR_MANIFESTS=/Volumes/projects/triton.git/tools/jr-manifest.json,/Volumes/projects/manta.git/tools/jr-manifest.json,/Volumes/projects/smartos-live.git/tools/jr-manifest.json"
+fi
+
+targets="$*"
+if [[ -z "$targets" ]]; then
+    targets=$(jr list -H -l mg='*' -o labels | json -ag mg public | sort -u \
+        | grep -v '^sdcsso' \
+        | grep -v '^sdcboot' \
+        | grep -v '^headnode-debug' \
+        | grep -v '^headnode-joyent-debug')
+fi
+
+# Ensure mls is setup properly at all.
+mls /Joyent_Dev/public/builds >/dev/null \
+    || fatal "cannot list /Joyent_Dev/public/builds"
+
+echo "$targets" | while read target public; do
+    if [[ "$public" == "true" ]]; then
+        latest_mpath=/Joyent_Dev/public/builds/$target/$release-latest
+    else
+        latest_mpath=/Joyent_Dev/stor/builds/$target/$release-latest
+    fi
+
+    case $target in
+        "platform"|"platform-debug")
+            PLAT_FLAVOR_ARG="-F $PLATFORM_BUILD_FLAVOR"
+            ;;
+        *)
+            PLAT_FLAVOR_ARG=""
+            ;;
+    esac
+
+    latest=$(mls $latest_mpath 2>/dev/null || true)
+    if [[ -z "$latest" ]]; then
+        echo "# $target, '$latest_mpath' does not exist" >&2
+        echo "./tools/launch-build ${PLAT_FLAVOR_ARG} -b $release $target"
+    fi
+done
diff --git a/tools/releng/purge-builds-from-manta b/tools/releng/purge-builds-from-manta
new file mode 100755
index 0000000..8842966
--- /dev/null
+++ b/tools/releng/purge-builds-from-manta
@@ -0,0 +1,344 @@
+#!/bin/bash
+#
+# This Source Code Form is subject to the terms of the Mozilla Public
+# License, v. 2.0. If a copy of the MPL was not distributed with this
+# file, You can obtain one at http://mozilla.org/MPL/2.0/.
+#
+
+#
+# Copyright 2019 Joyent, Inc.
+#
+
+#
+# Purge Joyent eng builds from Manta.
+#
+# Usage:
+#       purge-builds-from-manta -h                              # help output
+#       purge-builds-from-manta /Joyent_Dev/public/builds       # dry-run by default
+#       purge-builds-from-manta -f /Joyent_Dev/public/builds    # '-f' to actually del
+#
+# Builds build up in Manta. They need to eventually be purged so they don't
+# take up ever increasing space. This script knows how to remove Joyent eng
+# builds from a given Manta dir. This script encodes retention policy for
+# Joyent builds per
+# [RFD 47](https://github.com/joyent/rfd/blob/master/rfd/0047/README.md#builds).
+#
+# Here "eng builds" means the typical build dir layout used by tooling in
+# eng.git (and some others) for Joyent engineering builds:
+#
+#                                   # Example:
+#   $basedir/                       #   /Joyent_Dev/public/builds/
+#       $name/                      #       imgapi/
+#           $branch-$timestamp/     #           master-20160720T031418Z
+#               ...
+#           $branch-latest          #           master-latest
+#
+# For example:
+#
+#   $ mls /Joyent_Dev/public/builds/imgapi
+#   ...
+#   HEAD-2308-20160719T063933Z/
+#   HEAD-2308-latest
+#   master-20140929T205512Z/
+#   ...
+#   master-20160720T033514Z/
+#   master-latest
+#   ...
+#   release-20160721-20160721T180146Z/
+#   release-20160721-latest
+#   release-20160804-20160804T172843Z/
+#   release-20160804-20160804T182751Z/
+#   release-20160804-latest
+#
+
+if [[ -n "$TRACE" ]]; then
+    if [[ -t 1 ]]; then
+        export PS4='\033[90m[\D{%FT%TZ}] ${BASH_SOURCE}:${LINENO}: ${FUNCNAME[0]:+${FUNCNAME[0]}(): }\033[39m'
+    else
+        export PS4='[\D{%FT%TZ}] ${BASH_SOURCE}:${LINENO}: ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
+    fi
+    set -o xtrace
+fi
+set -o errexit
+set -o pipefail
+
+
+#---- globals, config
+
+# Get `mls` et al on the PATH.
+TOP=$(cd $(dirname $0)/../ >/dev/null; pwd)
+export PATH=$TOP/node_modules/.bin:$PATH
+
+#
+# A mapping from build name to the number of days' builds to keep.
+#
+# TTL (Time To Live) values are from RFD 47
+# (https://github.com/joyent/rfd/blob/master/rfd/0047/README.md#builds).
+#
+# Deliberately excluded build names for now (and the reason why):
+#    agentsshar-upgrade             paranoia
+#    platform                       want to discuss with OS guys
+#    platform-debug                 want to discuss with OS guys
+#    sdcsso                         build story isn't clear, eng hands off here
+#
+# If the build name is in neither the exclude list, nor the list of specific
+# TTL values, ttl_from_name() uses `jr` to verify it's a Manta/Triton component
+# and if so, applies a 365 day retention policy, and otherwise excludes it
+# from the purge.
+#
+DEFAULT_TTL_DAYS=365
+
+EXCLUDE_FROM_PURGE='[
+    "agentsshar-upgrade",
+    "platform",
+    "platform-debug",
+    "sdcsso"
+    ]'
+
+TTL_DAYS_FROM_NAME='{
+    "headnode": 30,
+    "headnode-debug": 30,
+    "headnode-joyent": 30,
+    "headnode-joyent-debug": 30
+}'
+
+
+opt_dryrun=yes    # Dry-run by default.
+opt_quiet=no
+
+
+#---- functions
+
+function usage() {
+    if [[ -n "$1" ]]; then
+        echo "error: $1"
+        echo ""
+    fi
+    echo 'Usage:'
+    echo '  purge-builds-from-manta [<options>] MANTA-BUILDS-DIR [NAMES...]'
+    echo ''
+    echo 'Options:'
+    echo '  -h          Print this help and exit.'
+    echo '  -q          Quiet output.'
+    echo '  -n          Dry-run (the default!).'
+    echo '  -f          Force actually doing deletions.'
+    echo ''
+    echo 'Examples:'
+    echo '  purge-builds-from-manta /Joyent_Dev/public/builds     # dry-run by default'
+    echo '  purge-builds-from-manta -f /Joyent_Dev/public/builds  # -f to actually rm'
+    echo '  purge-builds-from-manta -f /Joyent_Dev/public/builds vmapi   # limit subdir'
+    if [[ -n "$1" ]]; then
+        exit 1
+    else
+        exit 0
+    fi
+}
+
+function fatal {
+    echo "$(basename $0): error: $1" >&2
+    exit 1
+}
+
+function errexit
+{
+    [[ $1 -ne 0 ]] || exit 0
+    fatal "error exit status $1"
+}
+
+function log
+{
+    if [[ "$opt_quiet" == "no" ]]; then
+        echo "$*"
+    fi
+}
+
+function ttl_days_from_name
+{
+    local name
+    local ttl_days
+    local exclude
+    local known_component
+
+    name=$1
+
+    # See whether we have a non-default TTL for this component.
+    ttl_days=$(echo "$TTL_DAYS_FROM_NAME" | json -- $name)
+    if [[ -n "$ttl_days" ]]; then
+        echo $ttl_days
+    fi
+
+    # See if it's in the exclude list. If json has not filtered any results,
+    # we get non-empty output, indicating $name was in the exclude list.
+    exclude=$(echo "$EXCLUDE_FROM_PURGE" |
+        json -ac "this.indexOf('$name') != -1")
+    if [[ -n "$exclude" ]]; then
+        echo ""
+    fi
+
+    # finally, check to see if this is a known manta/triton component, which
+    # gets our default retention policy. If json returns a non-empty string,
+    # that indicates that we know about this component.
+    known_component=$(jr list -j -l mg='*' |
+        json -ag -c "this.labels.mg === '$name'")
+    if [[ -n "$known_component" ]]; then
+        echo $DEFAULT_TTL_DAYS
+    else
+        echo ""
+    fi
+}
+
+function has_dir_expired
+{
+    local dir
+    local ttl_days
+    dir=$1
+    ttl_days=$2
+
+    echo "has_dir_expired $dir $ttl_days"
+}
+
+function purge_dir
+{
+    local dir
+    dir="$1"
+    log "mrm -r $dir"
+    if [[ "$opt_dryrun" == "no" ]]; then
+        if [[ -n "$TRACE" ]]; then
+            mrm -rv "$dir"
+        else
+            mrm -r "$dir"
+        fi
+    fi
+}
+
+function purge_file_if_exist
+{
+    local file
+    local exists
+
+    file="$1"
+
+    # TODO: would be nice to have an example in `man mls` on how to do exists
+    # TODO: would be nice to have mtest to have `mtest -f ...` etc.
+    set +o errexit
+    exists=$(mls $file 2>/dev/null)
+    set -o errexit
+
+    if [[ -n "$exists" ]]; then
+        log "mrm    $file"   # spacing to line up with purge_dir log line
+        if [[ "$opt_dryrun" == "no" ]]; then
+            mrm "$file"
+        fi
+    fi
+}
+
+function purge_mg_builds
+{
+    local builds_dir
+    local name
+    local ttl_days
+    local cutoff
+    local dir
+    local dirs
+    local branches
+    local branch_dirs
+    local purged_all_in_branch
+
+    builds_dir=$1
+    name=$2
+    ttl_days=$(ttl_days_from_name $name)
+
+    if [[ -z "$ttl_days" ]]; then
+        log "# skip $builds_dir/$name: do not have a TTL for '$name'"
+        return
+    fi
+
+    # The 'cutoff' is the current time minus the ttl_days number of days,
+    # in the same format as the datestamps in the build dirs: YYYYMMDDTHHMMSSZ.
+    cutoff=$(node -e "c=new Date();
+        c.setDate(c.getDate() - $ttl_days);
+        console.log(c.toISOString().replace(/-|:|\.\d{3}/g,''))")
+    dryrun_msg=
+    if [[ $opt_dryrun != "no" ]]; then
+        dryrun_msg=", dry-run"
+    fi
+    log "# purge-builds-from-manta in $builds_dir/$name older than $cutoff" \
+        "(ttl $ttl_days days$dryrun_msg)"
+    dir=$builds_dir/$name
+    dirs=$(mls --type d $dir | sed -E 's#/$##')
+    branches=$(echo "$dirs" | sed -E 's/-[0-9]{8}T[0-9]{6}Z$//' | sort | uniq)
+
+    for branch in $branches; do
+        branch_dirs=$(echo "$dirs" | (grep "^$branch-" || true))
+
+        # Determine which dirs for this branch that we will be purging.
+        branch_dirs_to_purge=
+        for branch_dir in $branch_dirs; do
+            if [[ "$branch_dir" < "$branch-$cutoff" ]]; then
+                #log "# $branch_dir has expired"
+                branch_dirs_to_purge="$branch_dirs_to_purge $branch_dir"
+            fi
+        done
+        branch_dirs_to_purge=$(echo "$branch_dirs_to_purge" | xargs -n1)
+
+        # The "master" branch is special: if we would end up purging *all*
+        # remaining master branch dirs, then save that latest one.
+        purge_all_in_branch=no
+        if [[ "$branch_dirs" == "$branch_dirs_to_purge" ]]; then
+            if [[ "$branch" == "master" ]]; then
+                log "#   retain last master branch build:" \
+                    $(echo "$branch_dirs_to_purge" | tail -1)
+                branch_dirs_to_purge=$(echo "$branch_dirs_to_purge" | sed '$ d')
+            else
+                purge_all_in_branch=yes
+            fi
+        fi
+
+        for branch_dir in $branch_dirs_to_purge; do
+            #log "# $branch_dir has expired"
+            purge_dir $dir/$branch_dir
+        done
+        if [[ $purge_all_in_branch == "yes" ]]; then
+            purge_file_if_exist $dir/$branch-latest
+        fi
+    done
+}
+
+
+#---- mainline
+
+trap 'errexit $?' EXIT
+
+while getopts "hqnf" ch; do
+    case "$ch" in
+    h)
+        usage
+        ;;
+    q)
+        opt_quiet=yes
+        ;;
+    n)
+        opt_dryrun=yes
+        ;;
+    f)
+        opt_dryrun=no
+        ;;
+    *)
+        usage "illegal option -- $OPTARG"
+        ;;
+    esac
+done
+shift $((OPTIND - 1))
+
+BUILDS_DIR=$1
+[[ -n "$BUILDS_DIR" ]] || fatal "MANTA-BUILDS-DIR argument not given"
+shift
+NAMES="$*"
+
+if [[ -z "$NAMES" ]]; then
+    NAMES=$(mls --type d $BUILDS_DIR | sed -e 's#/$##' | xargs)
+fi
+
+for name in $NAMES; do
+    purge_mg_builds "$BUILDS_DIR" "$name"
+done
