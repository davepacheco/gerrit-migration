commit 0a08049e35331ddef0252486b0f6051198161891 (refs/changes/49/249/12)
Author: Pedro P. Candel <pedro@joyent.com>
Date:   2016-09-15T18:20:43+02:00 (3 years, 1 month ago)
    
    TOOLS-1469 sdcadm tests improvements
    Reviewed by: Marsell Kukuljevic <marsell@joyent.com>

diff --git a/README.md b/README.md
index ae6ff9e..c29435b 100644
--- a/README.md
+++ b/README.md
@@ -219,6 +219,9 @@ This should only be done by developers, and only in dev or test environments.
 Tests will muck around with the sdc setup, doing terrible and unholy things to
 your data.
 
+Note that tests are expected to run on a fresh setup, since the test suite
+will go through all the `post-setup` subcommands.
+
 In order to run sdcadm tests, you'll first need to signal to the tests that
 you really do want them to run:
 
diff --git a/test/channel.test.js b/test/channel.test.js
index 2956cc2..6a3fdbc 100644
--- a/test/channel.test.js
+++ b/test/channel.test.js
@@ -5,13 +5,25 @@
  */
 
 /*
- * Copyright (c) 2015, Joyent, Inc.
+ * Copyright (c) 2016, Joyent, Inc.
  */
 
-
+var util = require('util');
 var test = require('tape').test;
 var exec = require('child_process').exec;
 
+var CURR_CHANNEL = null;
+
+test('setup', function (t) {
+    exec('sdcadm channel get', function (err, stdout, stderr) {
+        t.ifError(err);
+        t.equal(stderr, '');
+        if (stdout) {
+            CURR_CHANNEL = stdout.trim();
+        }
+        t.end();
+    });
+});
 
 test('sdcadm channel --help', function (t) {
     exec('sdcadm channel --help', function (err, stdout, stderr) {
@@ -45,7 +57,6 @@ test('sdcadm channel list', function (t) {
         var lines = stdout.split('\n');
         var titles = lines[0].split(/\s+/);
         t.deepEqual(titles, ['NAME', 'DEFAULT', 'DESCRIPTION']);
-
         t.end();
     });
 });
@@ -54,24 +65,26 @@ test('sdcadm channel list', function (t) {
 test('sdcadm channel set', function (t) {
     exec('sdcadm channel set release', function (err, stdout, stderr) {
         t.ifError(err);
-
         t.equal(stdout, 'Update channel has been successfully set to: ' +
-                        '\'release\'\n');
+                        '\'release\'');
         t.equal(stderr, '');
-
         t.end();
     });
 });
 
 
-test('sdcadm channel set', function (t) {
-    exec('sdcadm channel set dev', function (err, stdout, stderr) {
+test('sdcadm channel reset',  function (t) {
+    if (CURR_CHANNEL !== null) {
+        t.end();
+        return;
+    }
+    var cmd = util.format('sdcadm channel set %s', CURR_CHANNEL);
+    exec(cmd, function (err, stdout, stderr) {
         t.ifError(err);
 
         t.equal(stdout, 'Update channel has been successfully set to: ' +
-                        '\'dev\'\n');
+                        '\'' + CURR_CHANNEL + '\'');
         t.equal(stderr, '');
-
         t.end();
     });
 });
diff --git a/test/check-config.test.js b/test/check-config.test.js
index 739ef5f..ad73e2c 100644
--- a/test/check-config.test.js
+++ b/test/check-config.test.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2015, Joyent, Inc.
+ * Copyright 2016, Joyent, Inc.
  */
 
 
@@ -26,8 +26,6 @@ test('sdcadm check-config --help', function (t) {
 
 
 test('sdcadm check-config', function (t) {
-    // TODO: huge todo here; should intentionally break something and see if
-    // check-config picks it up
     exec('sdcadm check-config', function (err, stdout, stderr) {
         t.ifError(err);
 
@@ -36,4 +34,4 @@ test('sdcadm check-config', function (t) {
 
         t.end();
     });
-});
\ No newline at end of file
+});
diff --git a/test/check-health.test.js b/test/check-health.test.js
index 8c6c435..75e6f01 100644
--- a/test/check-health.test.js
+++ b/test/check-health.test.js
@@ -5,59 +5,79 @@
  */
 
 /*
- * Copyright (c) 2015, Joyent, Inc.
+ * Copyright 2016, Joyent, Inc.
  */
 
 
 var test = require('tape').test;
 var exec = require('child_process').exec;
-var common = require('./common');
+var util = require('util');
+
 
+var common = require('./common');
 
+var serverHostnamesFromUUID = {};
+var serviceNamesFromUUID = {};
 var HEALTH_TITLES = ['INSTANCE', 'SERVICE', 'HOSTNAME', 'ALIAS', 'HEALTHY'];
 var HEALTH_DETAILS = [];
 
+function checkHealthDetails(t, healthDetails) {
+    healthDetails = healthDetails.map(function (item) {
+        return ({
+            instance: item[0],
+            service: item[1],
+            hostname: item[2],
+            alias: item[3],
+            health: item[4]
+        });
+    });
 
-function parseHealthOutput(output) {
-    return common.parseTextOut(output).filter(function (r) {
-        // TODO: we should check everything, not just VMs
-        return r[3] !== '-';
+    common.checkInsts(t, {
+        inputs: healthDetails,
+        serviceNamesFromUUID: serviceNamesFromUUID,
+        serverHostnamesFromUUID: serverHostnamesFromUUID
+    }, function () {
+        t.end();
     });
 }
 
 
-// TODO: need to check if service and hostname are correct
-function checkHealthDetails(t, healthDetails) {
-    if (healthDetails.length === 0) {
-        return t.end();
-    }
-
-    var details = healthDetails.pop();
+// ---
 
-    var cmd = 'sdc-vmapi /vms/' + details[0] + ' | json -H';
+// Preload Servers and SAPI services
+test('setup', function (t) {
+    var cmd = 'sdc-sapi /services | json -H';
     exec(cmd, function (err, stdout, stderr) {
-        t.ifError(err);
+        t.ifError(err, 'No error preloading SAPI services');
 
-        var vmDetails = common.parseJsonOut(stdout);
-        if (!vmDetails) {
+        var svcs = common.parseJsonOut(stdout);
+        if (!svcs) {
             t.ok(false, 'failed to parse JSON for cmd ' + cmd);
             return t.end();
         }
-
-        t.equal(vmDetails.uuid,  details[0], 'uuid should match');  // sanity
-        t.equal(vmDetails.alias, details[3], 'alias should match');
-
-        checkHealthDetails(t, healthDetails);
+        svcs.forEach(function (svc) {
+            serviceNamesFromUUID[svc.uuid] = svc.name;
+        });
+        var cmd2 = 'sdc-cnapi /servers?setup=true|json -H';
+        exec(cmd2, function (err2, stdout2, stderr2) {
+            t.ifError(err2, 'No error preloading CNAPI servers');
+
+            var servers = common.parseJsonOut(stdout2);
+            if (!servers) {
+                t.ok(false, 'failed to parse JSON for cmd ' + cmd2);
+                return t.end();
+            }
+            servers.forEach(function (server) {
+                serverHostnamesFromUUID[server.uuid] = server.hostname;
+            });
+            t.end();
+        });
     });
-}
-
-
-// ---
-
+});
 
 test('sdcadm check-health --help', function (t) {
     exec('sdcadm check-health --help', function (err, stdout, stderr) {
-        t.ifError(err);
+        t.ifError(err, 'exec error');
 
         t.ok(stdout.indexOf('sdcadm check-health [<options>]') !== -1);
         t.equal(stderr, '');
@@ -69,15 +89,15 @@ test('sdcadm check-health --help', function (t) {
 
 test('sdcadm check-health', function (t) {
     exec('sdcadm check-health', function (err, stdout, stderr) {
-        t.ifError(err);
+        t.ifError(err, 'exec error');
         t.equal(stderr, '');
 
-        common.DEFAULT_SERVICES.forEach(function (svcName) {
+        common.DEFAULT_VM_SERVICES.forEach(function (svcName) {
             var found = stdout.indexOf(svcName) !== -1;
             t.ok(found, svcName + ' in instances output');
         });
 
-        var healthDetails = parseHealthOutput(stdout);
+        var healthDetails = common.parseTextOut(stdout);
 
         var titles = healthDetails.shift();
         t.deepEqual(titles, HEALTH_TITLES, 'check column titles');
@@ -88,7 +108,6 @@ test('sdcadm check-health', function (t) {
 
         // global, so other tests can compare against
         HEALTH_DETAILS = healthDetails;
-
         checkHealthDetails(t, common.deepCopy(healthDetails));
     });
 });
@@ -123,17 +142,24 @@ test('sdcadm check-health --json', function (t) {
         });
 
         HEALTH_DETAILS.forEach(function (oldDetails) {
-            var vmUuid = oldDetails[0];
-            var jsonDetails = healthDetails[vmUuid];
-            t.equal(jsonDetails.type,    'vm',           vmUuid + ' type');
-            t.equal(jsonDetails.service,  oldDetails[1], vmUuid + ' service');
-            t.equal(jsonDetails.hostname, oldDetails[2], vmUuid + ' hostname');
-            t.equal(jsonDetails.alias,    oldDetails[3], vmUuid + ' alias');
+            var id = oldDetails[0];
+            var jsonDetails = healthDetails[id];
+            if (jsonDetails.type === 'global') {
+                return;
+            }
+            t.equal(jsonDetails.type, (
+                (oldDetails[3] !== '-') ? 'vm' : 'agent'
+            ), id + ' type');
+            t.equal(jsonDetails.service,  oldDetails[1], id + ' service');
+            t.equal(jsonDetails.hostname, oldDetails[2], id + ' hostname');
+            if (oldDetails[3] !== '-') {
+                t.equal(jsonDetails.alias,    oldDetails[3], id + ' alias');
+            }
 
             var oldHealthy = oldDetails[4];
             t.notEqual(['true', 'false'].indexOf(oldHealthy), -1);
             oldHealthy = (oldHealthy === 'true' ? true : false);
-            t.equal(jsonDetails.healthy,  oldHealthy, vmUuid + ' hostname');
+            t.equal(jsonDetails.healthy,  oldHealthy, id + ' hostname');
         });
 
         t.end();
@@ -172,7 +198,8 @@ test('sdcadm check-health with disabled papi', function (t) {
         t.notEqual(stderr, 'Some instances appear unhealthy'.indexOf(stderr),
                    -1);
 
-        var unhealthyPapis = parseHealthOutput(stdout).filter(function (inst) {
+        var unhealthyPapis = common.parseTextOut(stdout).
+            filter(function (inst) {
             return inst[1] === 'papi' && inst[4] === 'false';
         });
 
@@ -194,4 +221,4 @@ test('enable papi after health check', function (t) {
         t.equal(stderr, '');
         t.end();
     });
-});
\ No newline at end of file
+});
diff --git a/test/common.js b/test/common.js
index 309704a..7c3e277 100644
--- a/test/common.js
+++ b/test/common.js
@@ -5,18 +5,31 @@
  */
 
 /*
- * Copyright (c) 2015, Joyent, Inc.
+ * Copyright 2016, Joyent, Inc.
  */
 
 var exec = require('child_process').exec;
+var util = require('util');
 
+var vasync = require('vasync');
 
-var DEFAULT_SERVICES = [
+var DEFAULT_VM_SERVICES = [
     'adminui', 'amon', 'amonredis', 'assets', 'binder', 'ca', 'cnapi', 'dhcpd',
     'fwapi', 'imgapi', 'mahi', 'manatee', 'moray', 'napi', 'papi', 'rabbitmq',
     'redis', 'sapi', 'sdc', 'ufds', 'vmapi', 'workflow'
 ];
 
+var ALL_VM_SERVICES = DEFAULT_VM_SERVICES.concat([
+    'portolan', 'cloudapi', 'docker', 'cns'
+]);
+
+var DEFAULT_AGENT_SERVICES = [
+    'amon-agent', 'amon-relay', 'cainstsvc', 'firewaller',
+    'cn-agent', 'vm-agent', 'net-agent', 'smartlogin',
+    'hagfish-watcher'
+];
+
+var ALL_AGENT_SERVICES = DEFAULT_AGENT_SERVICES.concat(['dockerlogger']);
 
 var UUID_RE = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/;
 
@@ -55,12 +68,116 @@ function checkHelp(t, subcommand, match) {
     });
 }
 
+/*
+ * This function checks expected output from `sdcadm insts` and
+ * `sdcadm health`, which share approximately eighty percent.
+ *
+ * The expected opts argument includes the output from those
+ * commands, server hostnames associated with server uuids and
+ * service names associated with service uuids.
+ */
+function checkInsts(t, opts, cb) {
+    var inputs = opts.inputs;
+    var serviceNamesFromUUID = opts.serviceNamesFromUUID;
+    var serverHostnamesFromUUID = opts.serverHostnamesFromUUID;
+
+    vasync.forEachPipeline({
+        func: function (item, next) {
+
+            if (item.service === 'global' || item.instance === '-') {
+                return next();
+            }
+
+            var description = (item.alias !== '-') ?
+                util.format('%s (%s)', item.alias, item.instance) :
+                util.format('%s (%s)', item.instance, item.service);
+            t.comment(util.format('checking %s in %s',
+                description, item.hostname));
+
+
+
+            var cmd2 = 'sdc-sapi /instances/' + item.instance + ' | json -H';
+            exec(cmd2, function (err2, stdout2, stderr2) {
+                t.ifError(err2, 'no SAPI error');
+                var instanceDetails = parseJsonOut(stdout2);
+                if (!instanceDetails) {
+                    t.ok(false, 'failed to parse JSON for cmd ' + cmd2);
+                    return next();
+                }
+
+                if (item.service !== 'assets') {
+                    t.equal(serviceNamesFromUUID[instanceDetails.service_uuid],
+                        item.service, 'service should match');
+                }
+
+                if (item.alias === '-') {
+                    return next();
+                }
+
+                var cmd = 'sdc-vmapi /vms/' + item.instance + ' | json -H';
+                exec(cmd, function (err, stdout, stderr) {
+                    t.ifError(err, 'no VMAPI error');
+
+                    var vmDetails = parseJsonOut(stdout);
+                    if (!vmDetails) {
+                        t.ok(false, 'failed to parse JSON for cmd ' + cmd);
+                        return next();
+                    }
+
+                    t.equal(vmDetails.uuid,  item.instance,
+                            'uuid should match');
+                    t.equal(vmDetails.alias, item.alias,
+                            'alias should match');
+
+                    t.equal(serverHostnamesFromUUID[vmDetails.server_uuid],
+                        item.hostname, 'server hostname should match');
+
+                    t.notEqual(vmDetails.state, 'failed',
+                            'check state for VM ' + item.instance);
+
+                    if (item.version) {
+                        var imgUuid = vmDetails.image_uuid;
+                        var cmd3 = 'sdc-imgapi /images/' + imgUuid +
+                            ' | json -H';
+
+                        exec(cmd3, function (err3, stdout3, stderr3) {
+                            t.ifError(err3, 'IMGAPI call error');
+
+                            var imgInfo = parseJsonOut(stdout3);
+                            if (!imgInfo) {
+                                t.ok(false, 'failed to parse JSON for cmd ' +
+                                        cmd3);
+                                return next();
+                            }
+
+                            t.equal(imgInfo.version, item.version,
+                                    'check version for VM ' + vmDetails.uuid);
+
+                            next();
+                        });
+                    } else {
+                        next();
+                    }
+                });
+            });
+        },
+        inputs: inputs
+    }, function (resErr) {
+        t.ifError(resErr);
+        cb();
+    });
+}
+
 
 module.exports = {
-    DEFAULT_SERVICES: DEFAULT_SERVICES,
+    DEFAULT_VM_SERVICES: DEFAULT_VM_SERVICES,
+    ALL_VM_SERVICES: ALL_VM_SERVICES,
+    DEFAULT_AGENT_SERVICES: DEFAULT_AGENT_SERVICES,
+    ALL_AGENT_SERVICES: ALL_AGENT_SERVICES,
     UUID_RE: UUID_RE,
     checkHelp: checkHelp,
     deepCopy: deepCopy,
     parseJsonOut: parseJsonOut,
-    parseTextOut: parseTextOut
-};
\ No newline at end of file
+    parseTextOut: parseTextOut,
+    checkInsts: checkInsts
+};
diff --git a/test/common.test.js b/test/common.test.js
index b90fc0c..9bd4de3 100644
--- a/test/common.test.js
+++ b/test/common.test.js
@@ -9,7 +9,7 @@
  */
 
 var test = require('tape').test;
-var common = require('/opt/smartdc/sdcadm/lib/common.js');
+var common = require('../lib/common.js');
 
 test('safeCycles', function (t) {
     var a = {
diff --git a/test/create.test.js b/test/create.test.js
index ca76f66..ad0ec54 100644
--- a/test/create.test.js
+++ b/test/create.test.js
@@ -5,16 +5,18 @@
  */
 
 /*
- * Copyright (c) 2015, Joyent, Inc.
+ * Copyright 2016, Joyent, Inc.
  */
 
 
 var test = require('tape').test;
 var exec = require('child_process').exec;
+var util = require('util');
 
 
 var HEADNODE_UUID = '';
-var NEW_NAPI_UUID = '';
+var NAPI_UUID = '';
+var NAPI_UUID_2 = '';
 var NUM_NAPI = 0;
 
 
@@ -26,22 +28,33 @@ function getNumNapi(cb) {
         }
 
         var lines = stdout.split('\n');
-        return cb(null, lines.length);
+        cb(null, lines.length);
     });
 }
 
 
+function getLatestImgAvail(cb) {
+    var cmd = 'updates-imgadm list name=napi --latest --json';
+    exec(cmd, function (err, stdout, stderr) {
+        if (err) {
+            return cb(err);
+        }
+
+        var latestImgUuid = JSON.parse(stdout.trim())[0].uuid;
+        cb(null, latestImgUuid);
+    });
+}
+
 test('setup', function (t) {
-    var cmd = 'sdc-cnapi /servers?alias=headnode | json -H';
+    var cmd = 'sysinfo | json UUID';
 
     exec(cmd, function (err, stdout, stderr) {
-        t.ifError(err);
-        t.equal(stderr, '');
-
-        HEADNODE_UUID = JSON.parse(stdout)[0].uuid;
+        t.ifError(err, 'CNAPI error');
+        t.equal(stderr, '', 'Empty stderr');
+        HEADNODE_UUID = stdout.trim();
 
         getNumNapi(function (err2, numNapi) {
-            t.ifError(err2);
+            t.ifError(err2, 'vmadm list error');
             t.ok(numNapi >= 1, 'at least one napi instance exists');
             NUM_NAPI = numNapi;
 
@@ -53,21 +66,21 @@ test('setup', function (t) {
 
 test('sdcadm create --help', function (t) {
     exec('sdcadm create --help', function (err, stdout, stderr) {
-        t.ifError(err);
+        t.ifError(err, 'Execution error');
 
         t.notEqual(stdout.indexOf('sdcadm create <svc>'), -1);
-        t.equal(stderr, '');
+        t.equal(stderr, '', 'Empty stderr');
 
         t.end();
     });
 });
 
 
+// Mandatory --server arg:
 test('sdcadm create napi', function (t) {
     exec('sdcadm create napi', function (err, stdout, stderr) {
-        t.ok(err);
+        t.ok(err, 'Execution error');
 
-        t.equal(stdout, '');
         t.notEqual(stderr.indexOf('Must specify server uuid'), -1);
 
         t.end();
@@ -75,13 +88,13 @@ test('sdcadm create napi', function (t) {
 });
 
 
+// Mandatory --skip-ha-check for non HA service:
 test('sdcadm create napi --dry-run --server', function (t) {
     var cmd = 'sdcadm create napi --dry-run --server=' + HEADNODE_UUID;
 
     exec(cmd, function (err, stdout, stderr) {
-        t.ok(err);
+        t.ok(err, 'Execution error');
 
-        t.equal(stdout, '');
         t.notEqual(stderr.indexOf('Must provide \'--skip-ha-check\''), -1);
 
         t.end();
@@ -89,15 +102,16 @@ test('sdcadm create napi --dry-run --server', function (t) {
 });
 
 
+// Test --dry-run:
 test('sdcadm create napi --dry-run --skip-ha-check -y --server', function (t) {
     var cmd = 'sdcadm create napi --dry-run --skip-ha-check --yes --server=' +
               HEADNODE_UUID;
 
     exec(cmd, function (err, stdout, stderr) {
-        t.ifError(err);
+        t.ifError(err, 'Execution error');
 
         t.notEqual(stdout.indexOf('Created successfully'), -1);
-        t.equal(stderr, '');
+        t.equal(stderr, '', 'Empty stderr');
 
         getNumNapi(function (err2, numNapi) {
             t.ifError(err2);
@@ -108,22 +122,23 @@ test('sdcadm create napi --dry-run --skip-ha-check -y --server', function (t) {
 });
 
 
+// Real create test:
 test('sdcadm create napi --skip-ha-check --yes --server', function (t) {
     var cmd = 'sdcadm create napi --skip-ha-check --yes --server=' +
               HEADNODE_UUID;
 
     exec(cmd, function (err, stdout, stderr) {
-        t.ifError(err);
-        t.equal(stderr, '');
+        t.ifError(err, 'Execution error');
+        t.equal(stderr, '', 'Empty stderr');
 
         t.notEqual(stdout.indexOf('Created successfully'), -1);
 
         getNumNapi(function (err2, numNapi) {
-            t.ifError(err2);
+            t.ifError(err2, 'vmadm list error');
 
             t.equal(numNapi, NUM_NAPI + 1);
             // JSSTYLED
-            NEW_NAPI_UUID = stdout.match(/Instance "(.+?)"/)[1];
+            NAPI_UUID = stdout.match(/Instance "(.+?)"/)[1];
 
             t.end();
         });
@@ -131,16 +146,45 @@ test('sdcadm create napi --skip-ha-check --yes --server', function (t) {
 });
 
 
-// TODO: --image
+// Create test with latest available image:
+test('sdcadm create napi --skip-ha-check -y -s --image', function (t) {
+    getLatestImgAvail(function (updatesErr, latestImageUuid) {
+        t.ifError(updatesErr, 'updates-imgadm list error');
+
+        var cmd = 'sdcadm create napi --skip-ha-check --yes --server=' +
+                  HEADNODE_UUID + ' --image=' + latestImageUuid;
+        exec(cmd, function (err, stdout, stderr) {
+            t.ifError(err, 'Execution error');
+            t.equal(stderr, '', 'Empty stderr');
 
+            t.notEqual(stdout.indexOf('Created successfully'), -1);
+
+            getNumNapi(function (err2, numNapi) {
+                t.ifError(err2, 'vmadm list error');
+
+                t.equal(numNapi, NUM_NAPI + 2);
+
+                // JSSTYLED
+                NAPI_UUID_2 = stdout.match(/Instance "(.+?)"/)[1];
+
+                t.end();
+            });
+        });
+    });
+});
 
 test('teardown', function (t) {
-    exec('vmadm destroy ' + NEW_NAPI_UUID, function (err, stdout, stderr) {
-        t.ifError(err);
+    var cmd = 'sdc-sapi /instances/%s -X DELETE';
 
-        t.equal(stdout, '');
-        t.notEqual(stderr.indexOf('Successfully deleted VM'), -1);
+    exec(util.format(cmd, NAPI_UUID), function (err, stdout, stderr) {
+        t.ifError(err, 'Execution error');
+        t.equal(stderr, '', 'Empty stderr');
 
-        t.end();
+        exec(util.format(cmd, NAPI_UUID_2), function (err2, stdout2, stderr2) {
+            t.ifError(err2, 'Execution error');
+            t.equal(stderr2, '', 'Empty stderr');
+
+            t.end();
+        });
     });
-});
\ No newline at end of file
+});
diff --git a/test/help.test.js b/test/help.test.js
index 8bf597e..3e01dbc 100644
--- a/test/help.test.js
+++ b/test/help.test.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2015, Joyent, Inc.
+ * Copyright 2016, Joyent, Inc.
  */
 
 
@@ -32,7 +32,7 @@ test('sdcadm help', function (t) {
 
 
 test('sdcadm help self-update', function (t) {
-    checkHelp(t, 'self-update', 'sdcadm self-update [<options>]');
+    checkHelp(t, 'self-update', 'sdcadm self-update --latest [<options>]');
 });
 
 
diff --git a/test/history.test.js b/test/history.test.js
index 9127d17..06258df 100644
--- a/test/history.test.js
+++ b/test/history.test.js
@@ -116,7 +116,7 @@ test('sdcadm history --json', function (t) {
             t.ok(entry.uuid.match(common.UUID_RE), entry.uuid + ' is a UUID');
             t.ok(Array.isArray(entry.changes), 'changes is an array');
             // TODO: no username?
-            t.ok(entry.username == 'root' || !entry.username);
+            t.ok(entry.username === 'root' || !entry.username);
             t.ok(new Date(entry.started));
             t.ok(new Date(entry.finished));
         });
@@ -235,4 +235,4 @@ test('sdcadm history --until', function (t) {
 
         t.end();
     });
-});
\ No newline at end of file
+});
diff --git a/test/instances.test.js b/test/instances.test.js
index 2576861..d8c4503 100644
--- a/test/instances.test.js
+++ b/test/instances.test.js
@@ -13,9 +13,12 @@ var test = require('tape').test;
 var exec = require('child_process').exec;
 var util = require('util');
 var format = util.format;
-var common = require('./common');
 
 
+var common = require('./common');
+
+var serverHostnamesFromUUID = {};
+var serviceNamesFromUUID = {};
 var INSTANCE_TITLES = ['INSTANCE', 'SERVICE', 'HOSTNAME', 'VERSION', 'ALIAS'];
 var INSTANCES_DETAILS = [];
 
@@ -40,66 +43,64 @@ function parseInstancesOutput(t, output, expectedTitles) {
     t.deepEqual(titles, expectedTitles || INSTANCE_TITLES,
                 'check column titles');
 
-    return instancesDetails.filter(function (r) {
-        // TODO: we should check everything, not just VMs
-        return r[4] !== '-';
-    });
+    return instancesDetails;
 }
 
 
-/*
- * Recursive function to check the existence of a VM, and its alias and version
- * are correct.
- */
 function checkInstancesDetails(t, instancesDetails) {
-    if (instancesDetails.length === 0) {
-        return t.end();
-    }
+    instancesDetails = instancesDetails.map(function (item) {
+        return ({
+            instance: item[0],
+            service: item[1],
+            hostname: item[2],
+            version: item[3],
+            alias: item[4]
+        });
+    });
+
+    common.checkInsts(t, {
+        inputs: instancesDetails,
+        serviceNamesFromUUID: serviceNamesFromUUID,
+        serverHostnamesFromUUID: serverHostnamesFromUUID
+    }, function () {
+        t.end();
+    });
+}
 
-    function recur() {
-        checkInstancesDetails(t, instancesDetails); // recursive call
-    }
 
-    var instanceDetails = instancesDetails.pop();
-    var vmUuid  = instanceDetails[0];
-    var version = instanceDetails[3];
-    var alias   = instanceDetails[4];
+// ---
 
-    var cmd = 'sdc-vmapi /vms/' + vmUuid + ' | json -H';
 
+// Preload Servers and SAPI services
+test('setup', function (t) {
+    var cmd = 'sdc-sapi /services | json -H';
     exec(cmd, function (err, stdout, stderr) {
-        t.ifError(err);
+        t.ifError(err, 'No error preloading SAPI services');
 
-        var vmInfo = common.parseJsonOut(stdout);
-        if (!vmInfo) {
+        var svcs = common.parseJsonOut(stdout);
+        if (!svcs) {
             t.ok(false, 'failed to parse JSON for cmd ' + cmd);
-            return recur();
+            return t.end();
         }
-
-        t.equal(vmInfo.alias, alias, 'check VM alias is ' + alias);
-        t.notEqual(vmInfo.state, 'failed', 'check state for VM ' + vmUuid);
-
-        var imgUuid = vmInfo.image_uuid;
-        var cmd2 = 'sdc-imgapi /images/' + imgUuid + ' | json -H';
-
+        svcs.forEach(function (svc) {
+            serviceNamesFromUUID[svc.uuid] = svc.name;
+        });
+        var cmd2 = 'sdc-cnapi /servers?setup=true|json -H';
         exec(cmd2, function (err2, stdout2, stderr2) {
-            t.ifError(err2);
+            t.ifError(err2, 'No error preloading CNAPI servers');
 
-            var imgInfo = common.parseJsonOut(stdout2);
-            if (!imgInfo) {
+            var servers = common.parseJsonOut(stdout2);
+            if (!servers) {
                 t.ok(false, 'failed to parse JSON for cmd ' + cmd2);
-                return recur();
+                return t.end();
             }
-
-            t.equal(imgInfo.version, version, 'check version for VM ' + vmUuid);
-
-            recur();
+            servers.forEach(function (server) {
+                serverHostnamesFromUUID[server.uuid] = server.hostname;
+            });
+            t.end();
         });
     });
-}
-
-
-// ---
+});
 
 test('sdcadm instances --help', function (t) {
     checkHelp(t, 'instances');
@@ -116,7 +117,7 @@ test('sdcadm instances', function (t) {
         t.ifError(err);
         t.equal(stderr, '');
 
-        common.DEFAULT_SERVICES.forEach(function (svcName) {
+        common.DEFAULT_VM_SERVICES.forEach(function (svcName) {
             var found = stdout.indexOf(svcName) !== -1;
             t.ok(found, svcName + ' in instances output');
         });
@@ -164,19 +165,27 @@ test('sdcadm instances --json', function (t) {
             return t.end();
         }
 
-        var vmsDetails = {};
-        details.forEach(function (vm) {
-            vmsDetails[vm.zonename] = vm;
+        var instDetails = {};
+        details.forEach(function (inst) {
+            instDetails[inst.instance] = inst;
         });
 
         INSTANCES_DETAILS.forEach(function (oldDetails) {
-            var vmUuid = oldDetails[0];
-            var jsonDetails = vmsDetails[vmUuid];
-            t.equal(jsonDetails.type,    'vm',           vmUuid + ' type');
-            t.equal(jsonDetails.service,  oldDetails[1], vmUuid + ' service');
-            t.equal(jsonDetails.hostname, oldDetails[2], vmUuid + ' hostname');
-            t.equal(jsonDetails.version,  oldDetails[3], vmUuid + ' version');
-            t.equal(jsonDetails.alias,    oldDetails[4], vmUuid + ' alias');
+            var id = oldDetails[0];
+            // No instance id
+            if (id === '-') {
+                return;
+            }
+            var jsonDetails = instDetails[id];
+            t.equal(jsonDetails.type, (
+                (oldDetails[4] !== '-') ? 'vm' : 'agent'
+            ), id + ' type');
+            t.equal(jsonDetails.service, oldDetails[1], id + ' service');
+            t.equal(jsonDetails.hostname, oldDetails[2], id + ' hostname');
+            t.equal(jsonDetails.version, oldDetails[3], id + ' version');
+            if (oldDetails[4] !== '-') {
+                t.equal(jsonDetails.alias, oldDetails[4], id + ' alias');
+            }
         });
 
         t.end();
@@ -193,18 +202,17 @@ test('sdcadm instances -o', function (t) {
         var expectedTitles = ['TYPE', 'INSTANCE', 'VERSION'];
         var data = parseInstancesOutput(t, stdout, expectedTitles);
 
-        // TODO: should check more than just vms
-        var vms = data.filter(function (r) {
-            return r[0] === 'vm';
+        var insts = data.filter(function (r) {
+            return true;
         }).map(function (r) {
             return [ r[1], r[2] ];
         });
 
-        var prevVms = INSTANCES_DETAILS.map(function (r) {
+        var prevInsts = INSTANCES_DETAILS.map(function (r) {
             return [ r[0], r[3] ];
         });
 
-        t.deepEqual(vms, prevVms);
+        t.deepEqual(insts, prevInsts);
 
         t.end();
     });
@@ -216,12 +224,14 @@ test('sdcadm instances -s', function (t) {
         t.ifError(err);
         t.equal(stderr, '');
 
-        var vms = parseInstancesOutput(t, stdout);
-        var sortedVms = common.deepCopy(vms).sort(function (a, b) {
+        var insts = parseInstancesOutput(t, stdout).filter(function (item) {
+            return item[0] !== '-';
+        });
+        var sortedInsts = common.deepCopy(insts).sort(function (a, b) {
             return (a[0] < b[0]) ? -1 : 1;
         });
 
-        t.deepEqual(vms, sortedVms);
+        t.deepEqual(insts, sortedInsts);
 
         t.end();
     });
diff --git a/test/platform.test.js b/test/platform.test.js
index a0bc2cb..7751181 100644
--- a/test/platform.test.js
+++ b/test/platform.test.js
@@ -5,17 +5,69 @@
  */
 
 /*
- * Copyright (c) 2015, Joyent, Inc.
+ * Copyright 2016, Joyent, Inc.
  */
 
 
 var test = require('tape').test;
+var vasync = require('vasync');
+
 var exec = require('child_process').exec;
+var util = require('util');
+
 var common = require('./common');
 
+var UUID_RE = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/;
+var ISO_DATE_RE = /\d{4}[01]\d[0-3]\dT[0-2]\d[0-5]\d[0-5]\dZ/;
+
+var LIST_TITLES = [
+    'VERSION', 'CURRENT_PLATFORM', 'BOOT_PLATFORM', 'LATEST', 'DEFAULT'
+];
+var AVAIL_TITLES = [
+    'VERSION', 'UUID', 'PUBLISHED_AT'
+];
+var USAGE_TITLES = [
+    'UUID', 'HOSTNAME', 'CURRENT_PLATFORM', 'BOOT_PLATFORM'
+];
+var CNAPI_PLATFORMS;
+var CNAPI_SERVERS;
+
+var LATEST_PLATFORM;
+
+var LATEST_AVAIL_PLATFORM;
+var AVAIL_PLATFORMS = [];
+
+var INSTALLED_PLATFORMS = [];
+
+test('setup', function (t) {
+    var cmd = 'sdc-cnapi /platforms | json -H';
+    exec(cmd, function (err2, stdout2, stderr2) {
+        t.ifError(err2);
+
+        var platformsInfo = common.parseJsonOut(stdout2);
+        if (!platformsInfo) {
+            t.ok(false, 'failed to parse /platforms JSON');
+            return t.end();
+        }
+
+        CNAPI_PLATFORMS = platformsInfo;
 
-var LIST_TITLES = ['VERSION', 'CURRENT_PLATFORM', 'BOOT_PLATFORM', 'LATEST'];
+        var cmd2 = 'sdc-cnapi /servers | json -H';
+        exec(cmd2, function (err3, stdout3, stderr3) {
+            t.ifError(err3);
 
+            var servers = common.parseJsonOut(stdout3);
+            if (!servers) {
+                t.ok(false, 'failed to parse /servers JSON');
+                return t.end();
+            }
+
+            CNAPI_SERVERS = servers;
+
+            t.end();
+        });
+    });
+});
 
 test('sdcadm platform --help', function (t) {
     exec('sdcadm platform --help', function (err, stdout, stderr) {
@@ -45,7 +97,7 @@ test('sdcadm platform list', function (t) {
             var numBootPlatform = +r[2];
             var latest = r[3];
 
-            t.ok(timestamp.match(/^201\d+T\d+Z$/), 'platform has timestamp');
+            t.ok(timestamp.match(ISO_DATE_RE), 'platform has timestamp');
             t.ok(!isNaN(numCurrPlatform), 'current_platform count is a number');
             t.ok(!isNaN(numBootPlatform), 'boot_platform count is a number');
             t.ok(latest === 'true' || latest === 'false', 'latest is boolean');
@@ -54,55 +106,389 @@ test('sdcadm platform list', function (t) {
 
             return {
                 timestamp: timestamp,
-                curr_platform: numCurrPlatform,
-                boot_platform: numBootPlatform,
+                num_curr_platform: numCurrPlatform,
+                num_boot_platform: numBootPlatform,
                 latest: latest
             };
         });
 
-        var cmd = 'sdc-cnapi /platforms | json -H';
-        exec(cmd, function (err2, stdout2, stderr2) {
-            t.ifError(err2);
 
-            var platformsInfo = common.parseJsonOut(stdout2);
-            if (!platformsInfo) {
-                t.ok(false, 'failed to parse /platforms JSON');
-                return t.end();
+        var platformNames = Object.keys(CNAPI_PLATFORMS);
+
+        t.equal(platformNames.length, platformsDetails.length,
+                'platform counts');
+
+        platformsDetails.forEach(function (platform) {
+            t.equal(platform.latest,
+                    (CNAPI_PLATFORMS[platform.timestamp].latest === true),
+                    'latest for platform ' + platform.timestamp);
+            var timestamp = platform.timestamp;
+
+            var timestampPlatforms = CNAPI_SERVERS.filter(function (server) {
+                return server.current_platform === timestamp;
+            });
+
+            t.equal(timestampPlatforms.length, platform.num_curr_platform);
+        });
+
+        t.end();
+
+    });
+});
+
+
+test('sdcadm platform list --json', function (t) {
+    exec('sdcadm platform list --json', function (err, stdout, stderr) {
+        if (err) {
+            t.ifError(err, 'Execution error');
+            t.end();
+            return;
+        }
+        t.equal(stderr, '');
+
+        var platforms = common.parseJsonOut(stdout);
+        t.ok(platforms.length >= 1);
+        platforms.forEach(function (p) {
+            t.ok(p.version, 'platform version');
+            t.ok(p.boot_platform, 'boot_platform');
+            t.ok(p.current_platform, 'current_platform');
+            t.ok(typeof (p.latest) === 'boolean', 'platform latest');
+            t.ok(typeof (p.default) === 'boolean', 'platform default');
+            t.ok(typeof (p.usb_key) === 'boolean', 'platform usb_key');
+            if (p.latest) {
+                LATEST_PLATFORM = p;
             }
+        });
+
+        t.end();
+    });
+});
+
+
+test('sdcadm platform avail -j', function (t) {
+    exec('sdcadm platform avail -j', function (err, stdout, stderr) {
+        t.ifError(err);
+        t.equal(stderr, '');
+
+        var platforms = common.parseJsonOut(stdout);
+
+        platforms.forEach(function (p) {
+            t.ok(p.version, 'available platform version');
+            t.ok(p.uuid, 'available platform uuid');
+            t.ok(p.published_at, 'available platform published_at');
+        });
+
+        if (platforms.length) {
+            LATEST_AVAIL_PLATFORM = platforms.pop();
+            AVAIL_PLATFORMS = platforms;
+        }
+
+        t.end();
+    });
+});
+
+
+test('sdcadm platform available', function (t) {
+    exec('sdcadm platform available', function (err, stdout, stderr) {
+        t.ifError(err);
+        t.equal(stderr, '');
+
+        var platformsDetails = common.parseTextOut(stdout);
+
+        var titles = platformsDetails.shift();
+        t.deepEqual(titles, AVAIL_TITLES, 'check column titles');
+
+        platformsDetails.forEach(function (p) {
+            t.ok(p[0].match(ISO_DATE_RE), 'platform has timestamp');
+            t.notOk(CNAPI_PLATFORMS[p[0]], 'platform not installed');
+        });
+
+        t.end();
+    });
+});
 
-            var platformNames = Object.keys(platformsInfo);
 
-            t.equal(platformNames.length, platformsDetails.length,
-                    'platform counts');
+test('sdcadm platform usage', function (t) {
+    exec('sdcadm platform usage', function (err, stdout, stderr) {
+        t.ok(err, 'usage error');
+        t.notEqual(stderr.indexOf('platform name is required'), -1);
+
+        t.end();
+    });
+});
+
+
+test('sdcadm platform usage VERSION', function (t) {
+    var cmd = util.format('sdcadm platform usage %s', LATEST_PLATFORM.version);
+    exec(cmd, function (err, stdout, stderr) {
+        t.ifError(err);
+        t.equal(stderr, '');
+
+        var usageDetails = common.parseTextOut(stdout);
+        if (!usageDetails || !usageDetails.length) {
+            // If latest platform is not used at all, we will not have any
+            // output so cannot check titles:
+            t.comment('Skipping usage checks (latest platform not used)');
+            t.end();
+            return;
+        }
 
-            platformsDetails.forEach(function (platform) {
-                t.equal(platform.latest,
-                        platformsInfo[platform.timestamp].latest,
-                        'latest for platform ' + platform.timestamp);
+        var titles = usageDetails.shift();
+        t.deepEqual(titles, USAGE_TITLES, 'check column titles');
+        usageDetails.forEach(function (d) {
+            t.ok(d[0].match(UUID_RE), 'server uuid');
+            t.ok(d[2].match(ISO_DATE_RE), 'current_platform has timestamp');
+            t.ok(d[3].match(ISO_DATE_RE), 'boot_platform has timestamp');
+        });
+        t.end();
+    });
+});
+
+
+test('sdcadm platform usage VERSION -j', function (t) {
+    var cmd = util.format('sdcadm platform usage %s -j',
+            LATEST_PLATFORM.version);
+    exec(cmd, function (err, stdout, stderr) {
+        t.ifError(err);
+        t.equal(stderr, '');
+
+        var usageDetails = common.parseJsonOut(stdout);
+        usageDetails.forEach(function (d) {
+            USAGE_TITLES.map(function (title) {
+                return title.toLowerCase();
+            }).forEach(function (prop) {
+                t.ok(d[prop], 'usage has property ' + prop);
             });
+        });
+        t.end();
+    });
+});
+
+
+test('sdcadm platform install', function (t) {
+    exec('sdcadm platform install', function (err, stdout, stderr) {
+        t.ok(err, 'Execution error');
+        t.notEqual(stderr.indexOf(
+                    'must specify Platform Image UUID or --latest'), -1);
+
+        t.end();
+    });
+});
+
+
+test('sdcadm platform install --latest', function (t) {
+    if (!LATEST_AVAIL_PLATFORM) {
+        t.end();
+        return;
+    }
+    exec('sdcadm platform install --latest', function (err, stdout, stderr) {
+        t.ifError(err, 'Execution error');
+        // Progress bar
+        t.notEqual(stderr, '', 'Empty stderr');
+        t.notEqual(stdout.indexOf(
+                    'Platform installer finished successfully'), -1);
+
+        INSTALLED_PLATFORMS.push(LATEST_AVAIL_PLATFORM);
+        t.end();
+    });
+});
+
 
-            var cmd2 = 'sdc-cnapi /servers | json -H';
-            exec(cmd2, function (err3, stdout3, stderr3) {
-                t.ifError(err3);
+test('sdcadm platform install UUID', function (t) {
+    if (AVAIL_PLATFORMS.length === 0) {
+        t.end();
+        return;
+    }
+    var cmd = util.format('sdcadm platform install %s',
+            AVAIL_PLATFORMS[0].uuid);
+    exec(cmd, function (err, stdout, stderr) {
+        t.ifError(err, 'Execution error');
+        // Progress bar
+        t.notEqual(stderr, '', 'Empty stderr');
 
-                var servers = common.parseJsonOut(stdout3);
-                if (!servers) {
-                    t.ok(false, 'failed to parse /servers JSON');
-                    return t.end();
-                }
+        t.notEqual(stdout.indexOf(
+                    'Platform installer finished successfully'), -1);
+        INSTALLED_PLATFORMS.push(AVAIL_PLATFORMS[0]);
+        t.end();
+    });
+});
 
-                platformsDetails.forEach(function (platform) {
-                    var timestamp = platform.timestamp;
 
-                    var timestampPlatforms = servers.filter(function (server) {
-                        return server.current_platform === timestamp;
-                    });
+test('sdcadm platform assign', function (t) {
+    if (!LATEST_AVAIL_PLATFORM) {
+        t.end();
+        return;
+    }
+    var _1stServer = CNAPI_SERVERS[0];
+    var currPlatform = _1stServer.boot_platform;
+    var cmd = util.format('sdcadm platform assign %s %s',
+            LATEST_AVAIL_PLATFORM.version, _1stServer.uuid);
+    var cnapiCmd = util.format('sdc-cnapi /servers/%s|json -H',
+                    _1stServer.uuid);
+
+
+    vasync.pipeline({
+        funcs: [
+            function assignPlatform(_, next) {
+                exec(cmd, function (err, stdout, stderr) {
+                    t.ifError(err, 'Execution error');
+                    t.equal(stderr, '', 'Empty stderr');
+
+                    t.notEqual(stdout.indexOf('updating ' +
+                        _1stServer.hostname +
+                        ' ' + _1stServer.uuid + ' to ' +
+                        LATEST_AVAIL_PLATFORM.version), -1);
+                    next();
+                });
+            },
+            function checkCnapiPlatform(_, next) {
+                exec(cnapiCmd, function (err2, stdout2, stderr2) {
+                    t.ifError(err2, 'CNAPI error');
+                    t.equal(stderr2, '', 'Empty stderr');
 
-                    t.equal(timestampPlatforms.length, platform.curr_platform);
+                    var server = common.parseJsonOut(stdout2);
+                    t.equal(server.boot_platform,
+                            LATEST_AVAIL_PLATFORM.version,
+                            'Platform assigned');
+                    next();
                 });
+            },
+            function reassignPlatform(_, next) {
+                var cmd2 = util.format('sdcadm platform assign %s %s',
+                    currPlatform, _1stServer.uuid);
+                exec(cmd2, function (err3, stdout3, stderr3) {
+                    t.ifError(err3, 'Execution error');
+                    t.equal(stderr3, '', 'Empty stderr');
 
-                t.end();
+
+                    t.notEqual(stdout3.indexOf('updating ' +
+                                _1stServer.hostname +
+                                ' ' + _1stServer.uuid + ' to ' +
+                                currPlatform), -1);
+                    next();
+                });
+            },
+            function reCheckCnapiPlatform(_, next) {
+                exec(cnapiCmd, function (err4, stdout4, stderr4) {
+                    t.ifError(err4, 'Execution error');
+                    t.equal(stderr4, '', 'Empty stderr');
+
+                    var server = common.parseJsonOut(stdout4);
+                    t.equal(server.boot_platform, currPlatform,
+                            'Platform assigned');
+                    next();
+                });
+            }
+        ]
+    }, function (pipeErr) {
+        t.end();
+    });
+
+});
+
+// Run twice, set it back to whatever the value it has before
+test('sdcadm platform set-default', function (t) {
+    if (!LATEST_AVAIL_PLATFORM) {
+        t.end();
+        return;
+    }
+
+    vasync.pipeline({
+        arg: {
+            cnapiCmd: 'sdc-cnapi /boot/default|json -H',
+            bootParams: null,
+            currPlatform: null
+        },
+        funcs: [
+            function getBootParams(ctx, next) {
+                exec(ctx.cnapiCmd, function (err, stdout, stderr) {
+                    t.ifError(err, 'CNAPI error');
+                    t.equal(stderr, '', 'Empty stderr');
+
+                    ctx.currPlatform = common.parseJsonOut(stdout).platform;
+                    next();
+                });
+            },
+            function changeBootParams(ctx, next) {
+                var cmd = 'sdcadm platform set-default ' +
+                    LATEST_AVAIL_PLATFORM.version;
+                exec(cmd, function (err2, stdout2, stderr2) {
+                    t.ifError(err2, 'Execution error');
+                    t.equal(stderr2, '', 'Empty stderr');
+
+                    t.notEqual(stdout2.indexOf('Successfully set default ' +
+                                'platform to ' +
+                                LATEST_AVAIL_PLATFORM.version), -1);
+                    next();
+                });
+            },
+            function getUpdatedBootParams(ctx, next) {
+                exec(ctx.cnapiCmd, function (err3, stdout3, stderr3) {
+                    t.ifError(err3, 'Execution error');
+                    t.equal(stderr3, '', 'Empty stderr');
+
+                    ctx.bootParams = common.parseJsonOut(stdout3);
+                    t.equal(ctx.bootParams.platform,
+                            LATEST_AVAIL_PLATFORM.version,
+                            'Set default platform');
+                    next();
+                });
+            },
+            function rollbackBootParams(ctx, next) {
+                var cmd = 'sdcadm platform set-default ' + ctx.currPlatform;
+
+                exec(cmd, function (err4, stdout4, stderr4) {
+                    t.ifError(err4, 'Execution error');
+                    t.equal(stderr4, '', 'Empty stderr');
+
+                    t.notEqual(stdout4.indexOf(
+                                'Successfully set default platform to ' +
+                                ctx.currPlatform), -1);
+                    next();
+
+                });
+            },
+            function verifyRolledBackBootParams(ctx, next) {
+                exec(ctx.cnapiCmd, function (err5, stdout5, stderr5) {
+                    t.ifError(err5, 'Execution error');
+                    t.equal(stderr5, '', 'Empty stderr');
+
+                    ctx.bootParams = common.parseJsonOut(stdout5);
+                    t.equal(ctx.bootParams.platform, ctx.currPlatform,
+                        'Reset default platform');
+                    next();
+                });
+            }
+        ]
+    }, function (pipeErr) {
+        t.end();
+    });
+
+});
+
+
+// Remove only if we installed something:
+test('sdcadm platform remove', function (t) {
+    if (INSTALLED_PLATFORMS.length === 0) {
+        t.end();
+        return;
+    }
+    vasync.forEachPipeline({
+        inputs: INSTALLED_PLATFORMS,
+        func: function (platform, next) {
+            var command = util.format(
+                    'sdcadm platform remove %s --cleanup-cache -y',
+                    platform.version);
+            exec(command, function (err, stdout, stderr) {
+                t.ifError(err, 'Execution error');
+                t.equal(stderr, '', 'Empty stderr');
+                t.notEqual(stdout.indexOf(
+                    'Removing platform ' + platform.version), -1);
+
+                next();
             });
-        });
+        }
+    }, function (_, results) {
+        t.end();
     });
 });
diff --git a/test/post-setup.test.js b/test/post-setup.test.js
index bb5930d..c0425b1 100644
--- a/test/post-setup.test.js
+++ b/test/post-setup.test.js
@@ -5,11 +5,22 @@
  */
 
 /*
- * Copyright (c) 2015, Joyent, Inc.
+ * Copyright 2016, Joyent, Inc.
+ */
+
+/*
+ * PENDING TESTS:
+ *
+ * - Complete ha-manatee setup
+ * - Complete ha-bider setup
+ * - post-setup fabrics
+ * - post-setup underlay-nics
  */
 
 
 var test = require('tape').test;
+var vasync = require('vasync');
+
 var exec = require('child_process').exec;
 var checkHelp = require('./common').checkHelp;
 
@@ -34,23 +45,28 @@ test('sdcadm post-setup common-external-nics', function (t) {
             t.ifError(err);
             t.equal(stderr, '');
 
-            var svcs = JSON.parse(stdout);
-
-            // TODO: change to work in HA environment
-            var external = svcs[0].nics.filter(function (nic) {
-                return nic.nic_tag === 'external';
-            });
+            var vms = JSON.parse(stdout);
 
-            t.equal(external.length, 1, svcName + ' missing external');
+            vasync.forEachPipeline({
+                func: function (vm, nextVm) {
+                    var external = vm.nics.filter(function (nic) {
+                        return nic.nic_tag === 'external';
+                    });
 
-            cb();
+                    t.equal(external.length, 1, svcName + ' missing external');
+                    nextVm();
+                },
+                inputs: vms
+            }, function (resErr) {
+                cb();
+            });
         });
     }
 
     exec('sdcadm post-setup common-external-nics',
          function (err, stdout, stderr) {
-        t.ifError(err);
-        t.equal(stderr, '');
+        t.ifError(err, 'Execution error');
+        t.equal(stderr, '', 'Empty stderr');
 
         t.ok(stdout.indexOf('Added external nic to adminui') !== 1 ||
              stdout.indexOf('AdminUI already has an external nic') !== 1);
@@ -96,6 +112,35 @@ test('sdcadm post-setup cloudapi', function (t) {
 });
 
 
+test('sdcadm post-setup help docker', function (t) {
+    checkHelp(t, 'post-setup docker',
+        'Create the docker service and the docker instance on the headnode.');
+});
+
+
+test('sdcadm post-setup docker', function (t) {
+    exec('sdcadm post-setup docker', function (err, stdout, stderr) {
+        t.ifError(err);
+        t.equal(stderr, '');
+
+        t.ok(stdout.indexOf('docker0 zone created') !== 1 ||
+             stdout.indexOf('Already have') !== 1);
+
+        var cmd = 'sdc-vmapi /vms?alias=docker | json -H';
+        exec(cmd, function (err2, stdout2, stderr2) {
+            t.ifError(err2);
+            t.equal(stderr2, '');
+
+            var svcs = JSON.parse(stdout2);
+
+            t.ok(svcs.length >= 1);
+
+            t.end();
+        });
+    });
+});
+
+
 test('sdcadm post-setup help cloudapi', function (t) {
     checkHelp(t, 'post-setup cloudapi', 'Create a first cloudapi instance.');
 });
@@ -177,8 +222,8 @@ test('sdcadm post-setup dev-sample-data', function (t) {
 
         var cmd = 'sdc-papi /packages/' + pkgUuid + ' | json -H';
         exec(cmd, function (err, stdout, stderr) {
-            t.ifError(err);
-            t.equal(stderr, '');
+            t.ifError(err, 'PAPI error');
+            t.equal(stderr, '', 'Empty stderr');
 
             var pkg = JSON.parse(stdout);
             t.equal(pkg.uuid, pkgUuid, 'PAPI has package ' + pkgUuid);
@@ -196,8 +241,8 @@ test('sdcadm post-setup dev-sample-data', function (t) {
 
         var cmd = 'sdc-imgapi /images/' + imgUuid + ' | json -H';
         exec(cmd, function (err, stdout, stderr) {
-            t.ifError(err);
-            t.equal(stderr, '');
+            t.ifError(err, 'IMGAPI error');
+            t.equal(stderr, '', 'Empty stderr');
 
             var img = JSON.parse(stdout);
             t.equal(img.uuid, imgUuid, 'imgapi has image ' + imgUuid);
@@ -207,8 +252,8 @@ test('sdcadm post-setup dev-sample-data', function (t) {
     }
 
     exec('sdcadm post-setup dev-sample-data', function (err, stdout, stderr) {
-        t.ifError(err);
-        t.equal(stderr, '');
+        t.ifError(err, 'Execution error');
+        t.equal(stderr, '', 'Empty stderr');
 
         var pkgUuids = packageNames.map(function (pkg) {
             var added_re = 'Added package ' + pkg + ' \\((.+?)\\)';
@@ -223,7 +268,6 @@ test('sdcadm post-setup dev-sample-data', function (t) {
         var imgUuids = imageNames.map(function (img) {
             var added_re = 'Imported image (.+?) \\(' + img;
             var exist_re = 'Already have image (.+?) \\(' + img;
-
             var match = stdout.match(added_re) || stdout.match(exist_re);
             t.ok(match, 'image added or exists: ' + img);
 
@@ -245,8 +289,8 @@ test('sdcadm post-setup help dev-sample-data', function (t) {
 });
 
 
-test('sdcadm post-setup zookeeper', function (t) {
-    exec('sdcadm post-setup zookeeper', function (err, stdout, stderr) {
+test('sdcadm post-setup ha-binder', function (t) {
+    exec('sdcadm post-setup ha-binder', function (err, stdout, stderr) {
         t.ok(err);
 
         t.equal(stdout, '');
@@ -257,8 +301,8 @@ test('sdcadm post-setup zookeeper', function (t) {
 });
 
 
-test('sdcadm post-setup zookeeper --members', function (t) {
-    exec('sdcadm post-setup zookeeper -m 4', function (err, stdout, stderr) {
+test('sdcadm post-setup ha-binder --members', function (t) {
+    exec('sdcadm post-setup ha-binder -m 4', function (err, stdout, stderr) {
         t.ok(err);
 
         t.equal(stdout, '');
@@ -269,10 +313,10 @@ test('sdcadm post-setup zookeeper --members', function (t) {
 });
 
 
-test('sdcadm post-setup zookeeper --servers', function (t) {
+test('sdcadm post-setup ha-binder --servers', function (t) {
     var serverUuids = '';
 
-    exec('sdcadm post-setup zookeeper -s ' + serverUuids,
+    exec('sdcadm post-setup ha-binder -s ' + serverUuids,
          function (err, stdout, stderr) {
         // TODO
         t.end();
@@ -280,9 +324,9 @@ test('sdcadm post-setup zookeeper --servers', function (t) {
 });
 
 
-test('sdcadm post-setup help zookeeper', function (t) {
-    checkHelp(t, 'post-setup zookeeper',
-              'Create a zookeeper cluster, known as an ensemble');
+test('sdcadm post-setup help ha-binder', function (t) {
+    checkHelp(t, 'post-setup ha-binder',
+        'HA setup for binder/zookeeper services using binder instances');
 });
 
 
diff --git a/test/rollback.test.js b/test/rollback.test.js
index 465ec4b..8dbaab9 100644
--- a/test/rollback.test.js
+++ b/test/rollback.test.js
@@ -5,31 +5,146 @@
  */
 
 /*
- * Copyright (c) 2015, Joyent, Inc.
+ * Copyright 2016, Joyent, Inc.
  */
 
 
 var test = require('tape').test;
+var vasync = require('vasync');
+
 var exec = require('child_process').exec;
 var readdirSync = require('fs').readdirSync;
+var util = require('util');
+
+var common = require('./common');
+
+var AVAILABLE_VERSION;
+var ORIGINAL_VERSION;
+
+var PAPI_SVC_UUID;
+var PAPI_INSTANCE_UUID;
+
+var SUCCESSFULLY_UPDATED = false;
 
 var PLAN_PATH = ''; // filled in by setup
 
+function getAvailableImage(cb) {
+    exec('sdcadm avail papi --json', function (err, stdout, stderr) {
+        if (err) {
+            cb(err);
+            return;
+        }
+
+        var jsonDetails = common.parseJsonOut(stdout);
+        if (!jsonDetails.length) {
+            cb(null);
+            return;
+        }
+
+        AVAILABLE_VERSION = jsonDetails[0].image;
+        cb(null);
+    });
+}
 
-// we do this to ensure we have a plan to work with
-test('setup', function (t) {
-    var cmd = 'sdcadm update papi --force-same-image --yes';
+function getPapiSvcUUID(cb) {
+    var cmd = 'sdc-sapi /services?name=papi|json -H';
+    exec(cmd, function (err, stdout, stderr) {
+        if (err) {
+            cb(err);
+            return;
+        }
+
+        PAPI_SVC_UUID = common.parseJsonOut(stdout)[0].uuid;
+        cb(null);
+    });
+}
 
+
+function getPapiInstanceUUID(cb) {
+    var cmd = util.format('sdc-sapi /instances?service_uuid=%s | json -H',
+            PAPI_SVC_UUID);
     exec(cmd, function (err, stdout, stderr) {
-        t.ifError(err);
+        if (err) {
+            cb(err);
+            return;
+        }
+
+        var jsonDetails = common.parseJsonOut(stdout);
+        PAPI_INSTANCE_UUID = jsonDetails[0].uuid;
+        cb(null);
+    });
+}
+
+
+function getPapiImageUUID(cb) {
+    var cmd = util.format('sdc-vmapi /vms/%s | json -H',
+            PAPI_INSTANCE_UUID);
+    exec(cmd, function (err, stdout, stderr) {
+        if (err) {
+            cb(err);
+            return;
+        }
+
+        var jsonDetails = common.parseJsonOut(stdout);
+        cb(null, jsonDetails.image_uuid);
+    });
+}
 
-        t.ok(stdout.match('Updated successfully'));
-        t.equal(stderr, '');
 
-        var update = readdirSync('/var/sdcadm/updates').pop();
-        t.ok(update);
-        PLAN_PATH = '/var/sdcadm/updates/' + update + '/plan.json';
+test('setup', function (t) {
+    vasync.pipeline({
+        funcs: [
+            function (_, next) {
+                getAvailableImage(function (err, availImg) {
+                    if (err) {
+                        next(err);
+                        return;
+                    }
+                    next();
+                });
+            },
+            function (_, next) {
+                getPapiSvcUUID(next);
+            },
+            function (_, next) {
+                getPapiInstanceUUID(next);
+            },
+            function (_, next) {
+                getPapiImageUUID(function (err, uuid) {
+                    if (err) {
+                        next(err);
+                        return;
+                    }
+
+                    ORIGINAL_VERSION = uuid;
+                    next();
+                });
+            },
+            function (_, next) {
+                if (!AVAILABLE_VERSION) {
+                    t.comment('No available image, skipping update');
+                    next();
+                    return;
+                }
+                var cmd = 'sdcadm update papi --yes';
+
+                exec(cmd, function (err, stdout, stderr) {
+                    t.ifError(err);
+
+                    t.ok(stdout.match('Updated successfully'));
+                    t.equal(stderr, '');
+
+                    var update = readdirSync('/var/sdcadm/updates').pop();
+                    t.ok(update);
+                    PLAN_PATH = '/var/sdcadm/updates/' + update + '/plan.json';
+                    SUCCESSFULLY_UPDATED = true;
+                    next();
+                });
 
+            }
+        ]
+    }, function (resErr) {
+        t.ifError(resErr);
         t.end();
     });
 });
@@ -60,6 +175,11 @@ test('sdcadm rollback', function (t) {
 
 
 test('sdcadm rollback -f', function (t) {
+    if (!SUCCESSFULLY_UPDATED) {
+        t.comment('Update did not happened. Skipping rollback');
+        t.end();
+        return;
+    }
     var cmd = 'sdcadm rollback -f ' + PLAN_PATH;
 
     exec(cmd, function (err, stdout, stderr) {
@@ -74,6 +194,11 @@ test('sdcadm rollback -f', function (t) {
 
 
 test('sdcadm rollback --dry-run -f', function (t) {
+    if (!SUCCESSFULLY_UPDATED) {
+        t.comment('Update did not happened. Skipping rollback');
+        t.end();
+        return;
+    }
     var cmd = 'sdcadm rollback --dry-run -f ' + PLAN_PATH;
 
     exec(cmd, function (err, stdout, stderr) {
@@ -88,6 +213,11 @@ test('sdcadm rollback --dry-run -f', function (t) {
 
 
 test('sdcadm rollback --dry-run --force --yes -f', function (t) {
+    if (!SUCCESSFULLY_UPDATED) {
+        t.comment('Update did not happened. Skipping rollback');
+        t.end();
+        return;
+    }
     var cmd = 'sdcadm rollback --dry-run --yes --force -f ' + PLAN_PATH;
 
     exec(cmd, function (err, stdout, stderr) {
@@ -103,8 +233,12 @@ test('sdcadm rollback --dry-run --force --yes -f', function (t) {
 });
 
 
-// TODO: check the vm was properly rolled back (somehow)
 test('sdcadm rollback --force --yes -f', function (t) {
+    if (!SUCCESSFULLY_UPDATED) {
+        t.comment('Update did not happened. Skipping rollback');
+        t.end();
+        return;
+    }
     var cmd = 'sdcadm rollback --force --yes -f ' + PLAN_PATH;
 
     exec(cmd, function (err, stdout, stderr) {
@@ -124,7 +258,26 @@ test('sdcadm rollback --force --yes -f', function (t) {
                 }
             });
 
-            t.end();
+            getPapiImageUUID(function (err3, uuid) {
+                t.ifError(err3);
+                t.equal(ORIGINAL_VERSION, uuid);
+
+                t.end();
+
+            });
         });
     });
 });
+
+
+test('teardown', function (t) {
+    var cmd = util.format('sdc-imgadm delete %s', AVAILABLE_VERSION);
+    exec(cmd, function (err, stdout, stderr) {
+        t.ifError(err, 'Execution error');
+        t.equal(stderr, '', 'Empty stderr');
+
+        var str = util.format('Deleted image %s', AVAILABLE_VERSION);
+        t.notEqual(stdout.indexOf(str), -1, 'check image deleted');
+        t.end();
+    });
+});
diff --git a/test/runtests b/test/runtests
index 53d5263..d88e0cd 100755
--- a/test/runtests
+++ b/test/runtests
@@ -6,7 +6,7 @@
 #
 
 #
-# Copyright (c) 2015, Joyent, Inc.
+# Copyright 2016, Joyent, Inc.
 #
 
 #
@@ -26,8 +26,6 @@ fi
 set -o errexit
 set -o pipefail
 
-
-
 #---- guard
 
 guard_file=/lib/sdc/.sdc-test-no-production-data
@@ -72,7 +70,6 @@ TOP=$(cd $(dirname $0)/../; pwd)
 NODE_INSTALL=$TOP/node
 OUTPUT_DIR=/var/tmp/sdcadmtest
 TAPE=$TOP/node_modules/.bin/tape
-FAILING_LIST=$OUTPUT_DIR/failing-tests.txt
 
 
 # Options.
@@ -99,10 +96,29 @@ do
 done
 
 
+if [[ "${TOP}" == '/opt/smartdc/sdcadm' ]]; then
+  echo "Copying test files to ${OUTPUT_DIR}"
+  DESTDIR=/var/tmp/sdcadmtest
+  rm -rf $OUTPUT_DIR
+  mkdir -p $OUTPUT_DIR
+  cp -PR \
+      $TOP/test \
+      $TOP/node_modules \
+      $TOP/node \
+      $TOP/lib \
+      $TOP/etc \
+      $TOP/package.json \
+      $OUTPUT_DIR
+  sh $DESTDIR/test/runtests "${@}"
+  exit $?
+fi
+
+RESULTS=$OUTPUT_DIR/results
 # Setup a clean output dir.
-echo "# Setup a clean output dir ($OUTPUT_DIR)."
-rm -rf $OUTPUT_DIR
-mkdir -p /$OUTPUT_DIR
+echo "# Setup a clean output dir ($RESULTS)."
+rm -rf $RESULTS
+mkdir -p /$RESULTS
+FAILING_LIST=$RESULTS/failing-tests.txt
 touch $FAILING_LIST
 
 cd $TOP
@@ -121,9 +137,9 @@ for file in $test_files; do
     test_file=$(basename $file)
     echo "# $test_file"
     PATH=$NODE_INSTALL/bin:$PATH $TAPE $file \
-        | tee $OUTPUT_DIR/$test_file.tap
+        | tee $RESULTS/$test_file.tap
     if [[ "$?" != "0" ]]; then
-        echo $file >> $OUTPUT_DIR/failing-tests.txt
+        echo $file >> $FAILING_LIST
         [[ -n "$opt_stop_on_failure" ]] && break
     fi
 done
@@ -131,8 +147,8 @@ done
 set -o errexit
 
 echo ""
-echo "# test output in $OUTPUT_DIR:"
-cd $OUTPUT_DIR
+echo "# test output in $RESULTS:"
+cd $RESULTS
 ls *.tap
 
 
@@ -143,8 +159,8 @@ echo "# test results:"
 end_time=$(date +%s)
 elapsed=$((${end_time} - ${start_time}))
 
-tests=$(grep "^# tests [0-9]" $OUTPUT_DIR/*.tap | cut -d ' ' -f3 | xargs | tr ' ' '+' | bc)
-passed=$(grep "^# pass  [0-9]" $OUTPUT_DIR/*.tap | tr -s ' ' | cut -d ' ' -f3 | xargs | tr ' ' '+' | bc)
+tests=$(grep "^# tests [0-9]" $RESULTS/*.tap | cut -d ' ' -f3 | xargs | tr ' ' '+' | bc)
+passed=$(grep "^# pass  [0-9]" $RESULTS/*.tap | tr -s ' ' | cut -d ' ' -f3 | xargs | tr ' ' '+' | bc)
 [[ -z ${tests} ]] && tests=0
 [[ -z ${passed} ]] && passed=0
 fail=$((${tests} - ${passed}))
diff --git a/test/sdcadm.test.js b/test/sdcadm.test.js
index 2d74af8..35cd336 100644
--- a/test/sdcadm.test.js
+++ b/test/sdcadm.test.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2015, Joyent, Inc.
+ * Copyright 2016, Joyent, Inc.
  */
 
 
@@ -15,7 +15,7 @@ var exec = require('child_process').exec;
 
 test('sdcadm', function (t) {
     exec('sdcadm', function (err, stdout, stderr) {
-        t.ok(err);
+        t.ok(err, 'usage error');
         t.equal(err.code, 1);
 
         t.ok(stdout.match('Usage'));
@@ -28,7 +28,7 @@ test('sdcadm', function (t) {
 
 test('sdcadm --help', function (t) {
     exec('sdcadm --help', function (err, stdout, stderr) {
-        t.ifError(err);
+        t.ifError(err, 'no help error');
 
         t.ok(stdout.match('Usage'));
         t.equal(stderr, '');
@@ -40,9 +40,8 @@ test('sdcadm --help', function (t) {
 
 test('sdcadm --version', function (t) {
     exec('sdcadm --version', function (err, stdout, stderr) {
-        t.ifError(err);
-
-        t.ok(stdout.match(/^sdcadm \d\.\d\.\d \(master-\d+T\d+Z-.+\)/));
+        t.ifError(err, 'no version error');
+        t.ok(stdout.match(/^sdcadm \d+\.\d+\.\d+ \(master-\d+T\d+Z-.+\)/));
         t.equal(stderr, '');
 
         t.end();
diff --git a/test/self-update.test.js b/test/self-update.test.js
index fdd3f5e..239880f 100644
--- a/test/self-update.test.js
+++ b/test/self-update.test.js
@@ -5,15 +5,24 @@
  */
 
 /*
- * Copyright (c) 2015, Joyent, Inc.
+ * Copyright 2016 Joyent, Inc.
  */
 
 
 var test = require('tape').test;
 var exec = require('child_process').exec;
+var fs = require('fs');
+var assert = require('assert-plus');
 
+var CURRENT_VERSION = null;
+var CURRENT_BUILDSTAMP = null;
+var LATEST_UUID = null;
+
+function checkUpdateResults(t, err, stdout, stderr, moreStrings) {
+    if (moreStrings) {
+        assert.arrayOfString(moreStrings, 'moreStrings');
+    }
 
-function checkUpdateResults(t, err, stdout, stderr) {
     t.ifError(err);
     t.equal(stderr, '');
 
@@ -28,40 +37,97 @@ function checkUpdateResults(t, err, stdout, stderr) {
         'Updated to sdcadm'
     ];
 
+    if (moreStrings) {
+        findStrings = findStrings.concat(moreStrings);
+    }
+
     findStrings.forEach(function (str) {
         t.ok(stdout.match(str), 'check update string present');
     });
 
-    return t.end();
+    t.end();
+}
+
+function getSdcadmBuildstampVersion(t, cb) {
+    fs.readFile('/opt/smartdc/sdcadm/etc/buildstamp', {
+        encoding: 'utf8'
+    }, function (err, data) {
+        t.ifError(err);
+        t.ok(data);
+        cb(data.trim());
+    });
 }
 
 
+test('setup', function (t) {
+    getSdcadmBuildstampVersion(t, function (data) {
+        CURRENT_BUILDSTAMP = data;
+        var updatesCmd = '/opt/smartdc/bin/updates-imgadm list ' +
+            'tag.buildstamp=' + data + ' --latest -o uuid -H';
+        exec(updatesCmd, function (err2, stdout, stderr) {
+            t.ifError(err2);
+            CURRENT_VERSION = stdout.trim();
+            t.ok(CURRENT_VERSION);
+            t.equal(stderr, '');
+            var updatesCmd2 = '/opt/smartdc/bin/updates-imgadm list ' +
+                'name=sdcadm --latest -o uuid -H';
+            exec(updatesCmd2, function (err3, stdout2, stderr2) {
+                t.ifError(err3);
+                LATEST_UUID = stdout.trim();
+                t.ok(LATEST_UUID);
+                t.equal(stderr, '');
+                t.end();
+            });
+        });
+    });
+});
+
 test('sdcadm self-update --help', function (t) {
     exec('sdcadm self-update --help', function (err, stdout, stderr) {
         t.ifError(err);
-
-        t.notEqual(stdout.indexOf('sdcadm self-update [<options>]'), -1);
+        t.notEqual(stdout.indexOf('sdcadm self-update --latest [<options>]'),
+            -1);
         t.equal(stderr, '');
-
         t.end();
     });
 });
 
 
-test('sdcadm self-update --dry-run', function (t) {
-    exec('sdcadm self-update --dry-run', function (err, stdout, stderr) {
+test('sdcadm self-update --latest --dry-run', function (t) {
+    exec('sdcadm self-update --latest --dry-run',
+        function (err, stdout, stderr) {
         checkUpdateResults(t, err, stdout, stderr);
     });
 });
 
 
-test('sdcadm self-update --allow-major-update --dry-run', function (t) {
-    exec('sdcadm self-update --allow-major-update --dry-run',
-         function (err, stdout, stderr) {
+test('sdcadm self-update --allow-major-update', function (t) {
+    exec('sdcadm self-update --allow-major-update --dry-run --latest',
+        function (err, stdout, stderr) {
         checkUpdateResults(t, err, stdout, stderr);
     });
 });
 
 
-// TODO: how do we fully run self-update without mucking with the sdcadm we're
-// testing?
\ No newline at end of file
+test('sdcadm self-update --latest --channel=staging', function (t) {
+    var cmd = 'sdcadm self-update --latest --channel=staging';
+    exec(cmd, function (err, stdout, stderr) {
+        checkUpdateResults(t, err, stdout, stderr, ['Using channel staging']);
+    });
+});
+
+
+test('sdcadm self-update --latest', function (t) {
+    var cmd = 'sdcadm self-update --latest';
+    exec(cmd, function (err, stdout, stderr) {
+        checkUpdateResults(t, err, stdout, stderr, ['Using channel dev']);
+    });
+});
+
+
+test('sdcadm self-update IMAGE_UUID', function (t) {
+    var cmd = 'sdcadm self-update ' + CURRENT_VERSION;
+    exec(cmd, function (err, stdout, stderr) {
+        checkUpdateResults(t, err, stdout, stderr, ['Using channel dev']);
+    });
+});
diff --git a/test/services.test.js b/test/services.test.js
index c19bc84..1c45566 100644
--- a/test/services.test.js
+++ b/test/services.test.js
@@ -5,12 +5,16 @@
  */
 
 /*
- * Copyright (c) 2015, Joyent, Inc.
+ * Copyright 2016, Joyent, Inc.
  */
 
 
 var test = require('tape').test;
 var exec = require('child_process').exec;
+var util = require('util');
+
+var vasync = require('vasync');
+
 var common = require('./common');
 
 
@@ -21,10 +25,11 @@ var SERVICES_DETAILS = [];
 
 function checkHelp(t, command) {
     exec('sdcadm ' + command + ' --help', function (err, stdout, stderr) {
-        t.ifError(err);
+        t.ifError(err, 'Execution error');
 
-        t.ok(stdout.indexOf('sdcadm services [<options>]') !== -1);
-        t.equal(stderr, '');
+        t.ok(stdout.indexOf('sdcadm services [<options>]') !== -1,
+            'Expected help');
+        t.equal(stderr, '', 'Empty stderr');
 
         t.end();
     });
@@ -33,125 +38,130 @@ function checkHelp(t, command) {
 
 function parseServicesOutput(t, output, expectedTitles) {
     var servicesDetails = common.parseTextOut(output);
-    t.ok(servicesDetails.length > 0);
+    t.ok(servicesDetails.length > 0, 'Have services');
 
     var titles = servicesDetails.shift();
     t.deepEqual(titles, expectedTitles || SERVICE_TITLES,
                 'check service titles present');
 
     return servicesDetails.filter(function (r) {
-        // TODO: we should check validity of non-sapi-registered entries as well
         return r[1] !== '-';
     });
 }
 
 
+function checkInstancesExist(t, instances, cb) {
+    vasync.forEachPipeline({
+        func: function (instance, next) {
+            var vmUuid = instance.uuid;
+            var cmd = 'sdc-vmapi /vms/' + vmUuid + ' | json -H';
+
+            exec(cmd, function (err, stdout, stderr) {
+                t.ifError(err, 'check service instance ' + vmUuid +
+                    ' actually exists');
+
+                var instanceDetails = common.parseJsonOut(stdout);
+                if (!instanceDetails) {
+                    t.ok(false, 'failed to parse JSON for cmd ' + cmd);
+                    return next();
+                }
+
+                t.equal(instanceDetails.uuid, instance.uuid,
+                    'Instance uuid');
+                next();
+            });
+        },
+        inputs: instances
+    }, function (resErr) {
+        cb(resErr);
+    });
+}
+
+
 /*
- * Recursive function to check the existence of a service, and its type, name,
+ * Function to check the existence of a service, and its type, name,
  * image, and instances count are correct.
  */
 function checkServicesDetails(t, servicesDetails) {
-    if (servicesDetails.length === 0) {
-        return t.end();
-    }
+    vasync.forEachPipeline({
+        func: function (serviceDetails, next) {
+            var type     = serviceDetails[0];
+            var svcUuid  = serviceDetails[1];
+            var name     = serviceDetails[2];
+            var imgUuid  = serviceDetails[3];
+            var numInsts = +serviceDetails[4];
+            t.comment(util.format('checking service %s (%s)', name, svcUuid));
+
+            t.notEqual(['vm', 'agent'].indexOf(type), -1,
+                svcUuid + ' service type');
+
+            if (svcUuid === '-') {
+                return next();
+            }
 
-    function recur() {
-        return checkServicesDetails(t, servicesDetails);
-    }
+            var svcInfo = SERVICES_INFO[svcUuid];
 
-    var serviceDetails = servicesDetails.pop();
-    var type     = serviceDetails[0];
-    var svcUuid  = serviceDetails[1];
-    var name     = serviceDetails[2];
-    var imgUuid  = serviceDetails[3];
-    var numInsts = +serviceDetails[4];
+            t.equal(svcInfo.type, type, svcUuid + ' service type matches');
+            t.equal(svcInfo.name, name, svcUuid + ' service name matches');
 
-    t.notEqual(['vm', 'agent'].indexOf(type), -1, svcUuid + ' service type');
+            if (imgUuid === '-') {
+                return next();
+            }
 
-    if (svcUuid === '-') {
-        return recur();
-    }
+            t.equal(svcInfo.params.image_uuid, imgUuid,
+                'service image matches');
 
-    var svcInfo = SERVICES_INFO[svcUuid];
+            var cmd = 'sdc-imgapi /images/' + imgUuid + ' | json -H';
 
-    t.equal(svcInfo.type, type, svcUuid + ' service type matches');
-    t.equal(svcInfo.name, name, svcUuid + ' service name matches');
+            exec(cmd, function (err, stdout, stderr) {
+                t.ifError(err, svcUuid + ' service image exists');
 
-    if (imgUuid === '-') {
-        return recur();
-    }
+                if (type !== 'vm') {
+                    return next();
+                }
 
-    t.equal(svcInfo.params.image_uuid, imgUuid);
+                var cmd2 = 'sdc-sapi /instances?service_uuid=' +
+                    svcUuid + ' | json -H';
 
-    var cmd = 'sdc-imgapi /images/' + imgUuid + ' | json -H';
+                exec(cmd2, function (err2, stdout2, stderr2) {
+                    t.ifError(err2, svcUuid + ' service instance fetch');
 
-    exec(cmd, function (err, stdout, stderr) {
-        t.ifError(err, svcUuid + ' service image exists');
+                    var instances = common.parseJsonOut(stdout2);
+                    if (!instances) {
+                        t.ok(false, 'failed to parse JSON for cmd ' + cmd2);
+                        return next();
+                    }
 
-        if (type !== 'vm') {
-            return recur();
-        }
+                    instances.forEach(function (inst) {
+                        t.equal(inst.service_uuid, svcUuid); // sanity check
+                    });
 
-        var cmd2 = 'sdc-sapi /instances?service_uuid=' + svcUuid + ' | json -H';
+                    t.equal(instances.length, numInsts,
+                        'Service instances');
+                    checkInstancesExist(t, instances, function (instErr) {
+                        t.ifError(instErr,
+                            'Error checking service instances');
+                        next();
+                    });
 
-        exec(cmd2, function (err2, stdout2, stderr2) {
-            t.ifError(err2, svcUuid + ' service instance fetch');
-
-            var instances = common.parseJsonOut(stdout2);
-            if (!instances) {
-                t.ok(false, 'failed to parse JSON for cmd ' + cmd2);
-                return recur();
-            }
-
-            instances.forEach(function (inst) {
-                t.equal(inst.service_uuid, svcUuid); // sanity check
+                });
             });
-
-            // garganuan hack: napi is abused in create.test.js, so the
-            // instances listed here won't match what's normal
-            if (name === 'napi') {
-                t.ok(instances.length >= numInsts);
-                return recur();
-            } else {
-                t.equal(instances.length, numInsts);
-                checkInstancesExist(t, instances, recur);
-            }
-        });
+        },
+        inputs: servicesDetails
+    }, function (resErr) {
+        t.ifError(resErr, 'Error checking services');
+        t.end();
     });
 }
 
 
-function checkInstancesExist(t, instances, cb) {
-    if (instances.length === 0) {
-        return cb();
-    }
-
-    var instance = instances.pop();
-    var vmUuid = instance.uuid;
-    var cmd = 'sdc-vmapi /vms/' + vmUuid + ' | json -H';
-
-    exec(cmd, function (err, stdout, stderr) {
-        t.ifError(err, 'check service instance ' + vmUuid + ' actually exists');
-
-        var instanceDetails = common.parseJsonOut(stdout);
-        if (!instanceDetails) {
-            t.ok(false, 'failed to parse JSON for cmd ' + cmd);
-            return checkInstancesExist(t, instances, cb);
-        }
-
-        t.equal(instanceDetails.uuid, instance.uuid); // sanity check
-
-        checkInstancesExist(t, instances, cb);
-    });
-}
-
 
 // ---
 
 
 test('setup', function (t) {
     exec('sdc-sapi /services | json -H', function (err, stdout, stderr) {
-        t.ifError(err);
+        t.ifError(err, 'SAPI error');
 
         var servicesInfo = common.parseJsonOut(stdout);
         if (!servicesInfo) {
@@ -180,10 +190,10 @@ test('sdcadm svcs --help', function (t) {
 
 test('sdcadm services', function (t) {
     exec('sdcadm services', function (err, stdout, stderr) {
-        t.ifError(err);
-        t.equal(stderr, '');
+        t.ifError(err, 'Execution error');
+        t.equal(stderr, '', 'Empty stderr');
 
-        common.DEFAULT_SERVICES.forEach(function (svcName) {
+        common.DEFAULT_VM_SERVICES.forEach(function (svcName) {
             var found = stdout.indexOf(svcName) !== -1;
             t.ok(found, svcName + ' in instances output');
         });
diff --git a/test/update.test.js b/test/update.test.js
index 556ed7d..9ef2305 100644
--- a/test/update.test.js
+++ b/test/update.test.js
@@ -5,18 +5,37 @@
  */
 
 /*
- * Copyright (c) 2015, Joyent, Inc.
+ * Copyright (c) 2016, Joyent, Inc.
  */
 
 
+/*
+ * PENDING TESTS:
+ *
+ * - Update more than one service at once
+ * - Test --exclude
+ * - Test channels
+ */
+
 var test = require('tape').test;
+
 var exec = require('child_process').exec;
+var readdirSync = require('fs').readdirSync;
+var util = require('util');
 
+var SUCCESSFULLY_UPDATED = false;
+
+// We'll try to restore the system to its original state once we're done
+// testing updates
+var PLAN_PATH;
+
+var PAPI_IMG_UUID;
 
 test('setup', function (t) {
-    exec('sdcadm post-setup common-external-nics',
-         function (err, stdout, stderr) {
-        t.ifError(err);
+    var cmd = 'sdcadm post-setup common-external-nics';
+    exec(cmd, function (err, stdout, stderr) {
+        t.ifError(err, 'Execution error');
+        t.equal(stderr, '', 'Empty stderr');
         t.end();
     });
 });
@@ -62,22 +81,24 @@ test('sdcadm update --just-images', function (t) {
         t.notEqual(stdout.indexOf('Finding candidate update images'), -1);
 
         if (stdout.indexOf('Up-to-date') !== -1) {
-            return t.end();
+            t.end();
+            return;
         }
 
         var findRegex = [
             'This update will make the following changes',
-            'Downloading image .+ \(papi',
-            'Imported image .+ \(papi',
+            'Downloading image .+\n.*papi',
+            'Imported image .+\n.*papi',
             'Updated successfully'
         ];
 
         findRegex.forEach(function (regex) {
-            t.ok(regex.match(stdout), 'check update regex present');
+            t.ok(stdout.match(regex), 'check update regex present');
         });
 
         // JSSTYLED
-        var imgUuid = stdout.match(/Imported image (.+?) \(/)[0];
+        var imgUuid = stdout.match(/Imported image (.+?)/)[0];
+        PAPI_IMG_UUID = imgUuid;
 
         var cmd = 'sdc-imgapi /images/' + imgUuid + ' | json -H';
         exec(cmd, function (err2, stdout2, stderr2) {
@@ -101,7 +122,8 @@ test('sdcadm update', function (t) {
         t.ok(stdout.match('Finding candidate update images .+ "papi"'));
 
         if (stdout.match('Up-to-date')) {
-            return t.end();
+            t.end();
+            return;
         }
 
         var findRegex = [
@@ -115,6 +137,11 @@ test('sdcadm update', function (t) {
             t.ok(stdout.match(regex), 'check update string present:' + regex);
         });
 
+        SUCCESSFULLY_UPDATED = true;
+        var update = readdirSync('/var/sdcadm/updates').pop();
+        t.ok(update);
+        PLAN_PATH = '/var/sdcadm/updates/' + update + '/plan.json';
+
         var papiUuid = stdout.match('papi instance (.+?) to come up')[1];
 
         var cmd = 'sdc-vmapi /vms/' + papiUuid + ' | json -H';
@@ -123,12 +150,8 @@ test('sdcadm update', function (t) {
             t.equal(stderr2, '');
 
             var papi = JSON.parse(stdout2);
-
-            // TODO: should be papi.state, but there's a bug (?) right now where
-            // vmapi gets the state wedged in 'provisioning', even if it's done
-            t.equal(papi.zone_state, 'running');
-
-            return t.end();
+            t.equal(papi.image_uuid, PAPI_IMG_UUID);
+            t.end();
         });
     });
 });
@@ -158,30 +181,45 @@ test('sdcadm update --force-same-image', function (t) {
             'Finding candidate update images for the "papi"',
             'update "papi" service to image',
             'Reprovisioning papi VM',
-            'Wait (60s) for papi instance',
+            'Waiting for papi instance',
             'Updated successfully'
         ];
 
         findStrings.forEach(function (str) {
-            t.notEqual(stdout.indexOf(str), -1, 'check update string present');
+            t.notEqual(stdout.indexOf(str), -1,
+                    util.format('check update string present %s', str));
         });
+        t.end();
 
-        var papiUuid = stdout.match('papi instance (.+?) to come up')[1];
+    });
+});
 
-        cmd = 'sdc-vmapi /vms/' + papiUuid + ' | json -H';
-        exec(cmd, function (err2, stdout2, stderr2) {
-            t.ifError(err2);
-            t.equal(stderr2, '');
 
-            var papi = JSON.parse(stdout2);
+// As part of teardown, we'll not only rollback the updates, but also remove
+// the images we imported, since this is the only way to test the whole
+// update process for real, despite of slowness:
+test('teardown', function (t) {
+    if (!PLAN_PATH) {
+        t.end();
+        return;
+    }
+
+    var cmd = 'sdcadm rollback --force --yes -f ' + PLAN_PATH;
+    exec(cmd, function (err, stdout, stderr) {
+        t.ifError(err);
 
-            // TODO: papi.state bug (see other TODO above)
-            t.equal(papi.zone_state, 'running');
+        t.ok(stdout.match('rollback "papi" service to image'));
+        t.ok(stdout.match('Rolledback successfully'));
+
+        t.equal(stderr, '');
+        cmd = util.format('sdc-imgadm delete %s', PAPI_IMG_UUID);
+        exec(cmd, function (err2, stdout2, stderr2) {
+            t.ifError(err2, 'Execution error');
+            t.equal(stderr2, '', 'Empty stderr');
 
-            return t.end();
+            var str = util.format('Deleted image %s', PAPI_IMG_UUID);
+            t.notEqual(stdout2.indexOf(str), -1, 'check image deleted');
+            t.end();
         });
     });
 });
-
-
-// TODO: channels
\ No newline at end of file
