commit dfb19d8efbb2d66af1afe7d224104b4b98882f36 (refs/changes/24/624/3)
Author: Alex Wilson <alex.wilson@joyent.com>
Date:   2016-10-10T19:30:02+00:00 (3 years ago)
    
    joyent/node-sshpk-agent#8 update to latest mooremachine
    Reviewed by: Cody Peter Mello <cody.mello@joyent.com>

diff --git a/lib/client-fsm.js b/lib/client-fsm.js
index 966cbab..f1095b3 100644
--- a/lib/client-fsm.js
+++ b/lib/client-fsm.js
@@ -44,8 +44,7 @@ util.inherits(RequestQueue, FSM);
  * STATE: idle
  * when there is a request on the rq_queue => STATE connect
  */
-RequestQueue.prototype.state_idle = function (on, once) {
-	var self = this;
+RequestQueue.prototype.state_idle = function (S) {
 	/*
 	 * Store the last request, if any, for a while, to make
 	 * debugging a little easier.
@@ -60,11 +59,11 @@ RequestQueue.prototype.state_idle = function (on, once) {
 	 * request on the rq_queue.
 	 */
 	if (this.rq_queue.length > 0) {
-		self.gotoState('connect');
+		S.gotoState('connect');
 	} else {
 		this.rq_client.unref();
-		once(this, 'nonEmptyAsserted', function () {
-			self.gotoState('connect');
+		S.on(this, 'nonEmptyAsserted', function () {
+			S.gotoState('connect');
 		});
 	}
 };
@@ -73,32 +72,37 @@ RequestQueue.prototype.state_idle = function (on, once) {
  * STATE: connect
  * when the client has connected => STATE req
  */
-RequestQueue.prototype.state_connect = function (on, once, timeout, onState) {
-	var self = this;
+RequestQueue.prototype.state_connect = function (S) {
 	/*
 	 * Transition out of the connect state when the client has
 	 * been connected successfully.
 	 */
-	onState(this.rq_client, 'connected', function () {
-		self.gotoState('req');
-	});
 	this.rq_client.ref();
-	this.rq_client.connect();
+	if (this.rq_client.isInState('connected')) {
+		S.gotoState('req');
+	} else {
+		S.on(this.rq_client, 'stateChanged', function (st) {
+			if (st === 'connected')
+				S.gotoState('req');
+		});
+		this.rq_client.connect();
+	}
 };
 
 /*
  * STATE: req
  * when the request reaches 'done' => STATE idle
  */
-RequestQueue.prototype.state_req = function (on, once, timeout, onState) {
-	var self = this;
+RequestQueue.prototype.state_req = function (S) {
 	assert.ok(this.rq_queue.length > 0);
 	this.rq_request = this.rq_queue.shift();
-	assert.strictEqual(this.rq_request.getState(), 'waiting');
+
+	assert.ok(this.rq_request.isInState('waiting'));
 
 	/* Transition to idle when the request is done. */
-	onState(this.rq_request, 'done', function () {
-		self.gotoState('idle');
+	S.on(this.rq_request, 'stateChanged', function (st) {
+		if (st === 'done')
+			S.gotoState('idle');
 	});
 	this.rq_request.ready();
 };
@@ -139,11 +143,10 @@ util.inherits(Request, FSM);
  * STATE: waiting
  * when ready is asserted => STATE sending
  */
-Request.prototype.state_waiting = function (on, once) {
-	var self = this;
+Request.prototype.state_waiting = function (S) {
 	/* Wait for the "ready" signal. */
-	once(this, 'readyAsserted', function () {
-		self.gotoState('sending');
+	S.on(this, 'readyAsserted', function () {
+		S.gotoState('sending');
 	});
 };
 
@@ -153,37 +156,37 @@ Request.prototype.state_waiting = function (on, once) {
  * when an error occurs on the client => STATE error
  * when a frame is received on the client => STATE error or STATE done
  */
-Request.prototype.state_sending = function (on, once, timeout, onState) {
+Request.prototype.state_sending = function (S) {
 	var self = this;
 	this.r_error = undefined;
 	this.r_reply = undefined;
 
 	/* Transitions out of sending are to either error or done. */
 
-	timeout(this.r_timeout, function () {
+	S.timeout(this.r_timeout, function () {
 		self.r_error = new Error('Timeout waiting for ' +
 		    'response from SSH agent (' + self.r_timeout +
 		    ' ms)');
 		self.r_client.disconnect();
-		self.gotoState('error');
+		S.gotoState('error');
 	});
 
-	once(this.r_client, 'error', function (err) {
+	S.on(this.r_client, 'error', function (err) {
 		self.r_error = err;
-		self.gotoState('error');
+		S.gotoState('error');
 	});
 
-	once(this.r_client, 'frame', function (frame) {
+	S.on(this.r_client, 'frame', function (frame) {
 		if (self.r_respTypes.indexOf(frame.type) === -1) {
 			self.r_error = new AgentProtocolError(frame,
 			    'Frame received from agent out of order. ' +
 			    'Got a ' + frame.type + ', expected a ' +
 			    self.r_respTypes.join(' or '));
-			self.gotoState('error');
+			S.gotoState('error');
 			return;
 		}
 		self.r_reply = frame;
-		self.gotoState('done');
+		S.gotoState('done');
 	});
 
 	this.r_client.sendFrame(this.r_sendFrame);
@@ -194,16 +197,20 @@ Request.prototype.state_sending = function (on, once, timeout, onState) {
  * when there are retries remaining => STATE sending
  * otherwise => STATE done
  */
-Request.prototype.state_error = function (on, once, timeout, onState) {
-	var self = this;
+Request.prototype.state_error = function (S) {
 	if (this.r_retries > 0) {
 		--this.r_retries;
-		onState(this.r_client, 'connected', function () {
-			self.gotoState('sending');
-		});
-		this.r_client.connect();
+		if (this.r_client.isInState('connected')) {
+			S.gotoState('sending');
+		} else {
+			S.on(this.r_client, 'stateChanged', function (st) {
+				if (st === 'connected')
+					S.gotoState('sending');
+			});
+			this.r_client.connect();
+		}
 	} else {
-		this.gotoState('done');
+		S.gotoState('done');
 	}
 };
 
@@ -254,10 +261,9 @@ util.inherits(ClientFSM, FSM);
  * STATE: disconnected
  * when connect asserted => STATE connecting
  */
-ClientFSM.prototype.state_disconnected = function (on, once) {
-	var self = this;
-	once(this, 'connectAsserted', function () {
-		self.gotoState('connecting');
+ClientFSM.prototype.state_disconnected = function (S) {
+	S.on(this, 'connectAsserted', function () {
+		S.gotoState('connecting');
 	});
 };
 
@@ -267,25 +273,25 @@ ClientFSM.prototype.state_disconnected = function (on, once) {
  * when timeout occurs => STATE connectError
  * when socket connects => STATE connected
  */
-ClientFSM.prototype.state_connecting = function (on, once, timeout) {
+ClientFSM.prototype.state_connecting = function (S) {
 	var self = this;
 
 	this.c_socket = net.connect(this.c_sockPath);
 
-	timeout(this.c_timeout, function () {
+	S.timeout(this.c_timeout, function () {
 		self.c_connectError = new Error('Timed out while ' +
 		    'connecting to socket: ' + self.c_sockPath + ' (' +
 		    self.c_timeout + ' ms)');
-		self.gotoState('connectError');
+		S.gotoState('connectError');
 	});
 
-	once(this.c_socket, 'error', function (err) {
+	S.on(this.c_socket, 'error', function (err) {
 		self.c_connectError = err;
-		self.gotoState('connectError');
+		S.gotoState('connectError');
 	});
 
-	once(this.c_socket, 'connect', function () {
-		self.gotoState('connected');
+	S.on(this.c_socket, 'connect', function () {
+		S.gotoState('connected');
 	});
 };
 
@@ -294,16 +300,19 @@ ClientFSM.prototype.state_connecting = function (on, once, timeout) {
  * when there are retries left => STATE connecting
  * otherwise => STATE disconnected
  */
-ClientFSM.prototype.state_connectError = function () {
+ClientFSM.prototype.state_connectError = function (S) {
+	var self = this;
 	this.c_socket.destroy();
 	this.c_socket = undefined;
 	if (this.c_connectRetries > 0) {
 		--this.c_connectRetries;
-		this.gotoState('connecting');
+		S.gotoState('connecting');
 	} else {
 		this.c_wantConnect = false;
-		this.emit('error', this.c_connectError);
-		this.gotoState('disconnected');
+		setImmediate(function () {
+			self.emit('error', this.c_connectError);
+		});
+		S.gotoState('disconnected');
 	}
 };
 
@@ -315,7 +324,7 @@ ClientFSM.prototype.state_connectError = function () {
  * if c_red asserted always => SUBSTATE busy
  * else always => SUBSTATE idle
  */
-ClientFSM.prototype.state_connected = function (on, once) {
+ClientFSM.prototype.state_connected = function (S) {
 	var self = this;
 
 	this.c_connectRetries = 3;
@@ -327,24 +336,23 @@ ClientFSM.prototype.state_connected = function (on, once) {
 	var errHandler = function (err) {
 		self.c_lastError = err;
 		self.emit('error', err);
-		self.gotoState('disconnecting');
+		S.gotoState('disconnecting');
 	};
 
-	once(this.c_socket, 'error', errHandler);
-	once(this.c_decodeStream, 'error', errHandler);
-	once(this.c_encodeStream, 'error', errHandler);
+	S.on(this.c_socket, 'error', errHandler);
+	S.on(this.c_decodeStream, 'error', errHandler);
+	S.on(this.c_encodeStream, 'error', errHandler);
 
-	once(this.c_socket, 'close', function () {
+	S.on(this.c_socket, 'close', function () {
 		if (self.c_ref) {
 			errHandler(new Error('Unexpectedly lost ' +
 			    'connection to SSH agent'));
 		} else {
-			self.gotoState('disconnecting');
+			S.gotoState('disconnecting');
 		}
 	});
 
-	on(this.c_decodeStream, 'readable',
-	    function () {
+	S.on(this.c_decodeStream, 'readable', function () {
 		var frame;
 		while (self.c_decodeStream &&
 		    (frame = self.c_decodeStream.read())) {
@@ -358,26 +366,25 @@ ClientFSM.prototype.state_connected = function (on, once) {
 		}
 	});
 
-	once(this, 'disconnectAsserted', function () {
-		self.gotoState('disconnecting');
+	S.on(this, 'disconnectAsserted', function () {
+		S.gotoState('disconnecting');
 	});
 
 	if (this.c_ref)
-		self.gotoState('connected.busy');
+		S.gotoState('connected.busy');
 	else
-		self.gotoState('connected.idle');
+		S.gotoState('connected.idle');
 };
 
 /*
  * STATE: connected.busy
  * when unref asserted => SUBSTATE idle
  */
-ClientFSM.prototype.state_connected.busy = function (on, once) {
-	var self = this;
+ClientFSM.prototype.state_connected.busy = function (S) {
 	if (this.c_socket.ref)
 		this.c_socket.ref();
-	once(this, 'unrefAsserted', function () {
-		self.gotoState('connected.idle');
+	S.on(this, 'unrefAsserted', function () {
+		S.gotoState('connected.idle');
 	});
 };
 
@@ -386,15 +393,14 @@ ClientFSM.prototype.state_connected.busy = function (on, once) {
  * if on node <= 0.8 => STATE disconnecting
  * when ref asserted => SUBSTATE busy
  */
-ClientFSM.prototype.state_connected.idle = function (on, once) {
-	var self = this;
+ClientFSM.prototype.state_connected.idle = function (S) {
 	if (this.c_socket.unref) {
 		this.c_socket.unref();
-		once(this, 'refAsserted', function () {
-			self.gotoState('connected.busy');
+		S.on(this, 'refAsserted', function () {
+			S.gotoState('connected.busy');
 		});
 	} else {
-		this.gotoState('disconnecting');
+		S.gotoState('disconnecting');
 	}
 };
 
@@ -402,14 +408,14 @@ ClientFSM.prototype.state_connected.idle = function (on, once) {
  * STATE: disconnecting
  * always => STATE disconnected
  */
-ClientFSM.prototype.state_disconnecting = function () {
+ClientFSM.prototype.state_disconnecting = function (S) {
 	this.c_socket.destroy();
 	this.c_socket = undefined;
 
 	this.c_encodeStream = undefined;
 	this.c_decodeStream = undefined;
 
-	this.gotoState('disconnected');
+	S.gotoState('disconnected');
 };
 
 ClientFSM.prototype.ref = function () {
@@ -428,8 +434,19 @@ ClientFSM.prototype.disconnect = function () {
 
 ClientFSM.prototype.connect = function (cb) {
 	assert.optionalFunc(cb, 'callback');
-	if (cb)
-		this.onState('connected', cb);
+	assert.ok(this.isInState('disconnected'),
+	    'client must be disconnected');
+	var self = this;
+	if (cb) {
+		function onStateChanged(st) {
+			if (st === 'connected') {
+				self.removeListener('stateChanged',
+				    onStateChanged);
+				cb();
+			}
+		}
+		this.on('stateChanged', onStateChanged);
+	}
 	this.emit('connectAsserted');
 };
 
diff --git a/package.json b/package.json
index ef7748e..0a32425 100644
--- a/package.json
+++ b/package.json
@@ -1,6 +1,6 @@
 {
   "name": "sshpk-agent",
-  "version": "1.4.1",
+  "version": "1.4.2",
   "description": "ssh-agent client for use with sshpk",
   "main": "lib/index.js",
   "scripts": {
@@ -27,9 +27,9 @@
   "homepage": "https://github.com/arekinath/node-sshpk-agent#readme",
   "dependencies": {
     "assert-plus": "^1.0.0",
-    "mooremachine": "^1.0.0",
+    "mooremachine": "^2.0.1",
     "readable-stream": "^2.1.4",
-    "sshpk": ">=1.9.1 < 1.10.0"
+    "sshpk": ">=1.9.1 < 1.11.0"
   },
   "devDependencies": {
     "tape": "^3.5.0",
diff --git a/tools/jsl.node.conf b/tools/jsl.node.conf
index 0b8ae95..25094e5 100644
--- a/tools/jsl.node.conf
+++ b/tools/jsl.node.conf
@@ -120,6 +120,7 @@
 +define require
 +define setInterval
 +define setTimeout
++define setImmediate
 +define Buffer
 +define JSON
 +define Math
