From a4b679b4e7ed9a73d2c1849606f9be5fe520eba2 Mon Sep 17 00:00:00 2001
From: Jared Morrow <jm@joyent.com>
Date: Thu, 14 Dec 2017 17:37:38 -0700
Subject: [PATCH] MANTA-3408 muppet stops watching for updates if it loses
 connection to zookeeper

---
 Makefile                               |   4 +-
 lib/index.js                           |   7 +-
 lib/lb_manager.js                      |  60 ++---
 lib/watch.js                           | 171 ++++++++------
 lib/zk.js                              |  45 ++++
 muppet.js                              | 296 ++++++++++++++-----------
 package.json                           |  10 +-
 sapi_manifests/muppet/manifest.json    |   2 +-
 sapi_manifests/muppet/template         |   1 -
 sapi_manifests/registrar/manifest.json |   2 +-
 sapi_manifests/ssl_cert/manifest.json  |   2 +-
 test/helper.js                         |  48 ++--
 12 files changed, 381 insertions(+), 267 deletions(-)
 create mode 100644 lib/zk.js

diff --git a/Makefile b/Makefile
index f1c47ab..64d1cec 100644
--- a/Makefile
+++ b/Makefile
@@ -46,8 +46,8 @@ SMF_MANIFESTS_IN = smf/manifests/$(MY_NAME).xml.in smf/manifests/haproxy.xml.in
 #
 
 NODE_PREBUILT_TAG	= zone
-NODE_PREBUILT_VERSION	:= v0.10.32
-NODE_PREBUILT_IMAGE	= de411e86-548d-11e4-a4b7-3bb60478632a
+NODE_PREBUILT_VERSION   := v4.6.1
+NODE_PREBUILT_IMAGE     = 18b094b0-eb01-11e5-80c1-175dac7ddf02
 
 include ./tools/mk/Makefile.defs
 include ./tools/mk/Makefile.haproxy.defs
diff --git a/lib/index.js b/lib/index.js
index c2015f1..16dcc09 100644
--- a/lib/index.js
+++ b/lib/index.js
@@ -8,15 +8,16 @@
  * Copyright (c) 2017, Joyent, Inc.
  */
 
-var lbm = require('./lb_manager');
-var Watch = require('./watch').Watch;
+const lbm = require('./lb_manager');
+const zkm = require('./zk.js');
+const Watch = require('./watch').Watch;
 
 
 ///--- Exports
 module.exports = {
-
     createWatch: function createWatch(options) {
         return (new Watch(options));
     },
+    createZKClient: zkm.createZKClient,
     restartLB: lbm.restart
 };
diff --git a/lib/lb_manager.js b/lib/lb_manager.js
index 5a810fa..f3f855b 100644
--- a/lib/lb_manager.js
+++ b/lib/lb_manager.js
@@ -8,35 +8,39 @@
  * Copyright (c) 2017, Joyent, Inc.
  */
 
-var execFile = require('child_process').execFile;
-var exec = require('child_process').exec;
-var fs = require('fs');
-var os = require('os');
-var path = require('path');
-var sprintf = require('util').format;
+/*jsl:ignore*/
+'use strict';
+/*jsl:end*/
 
-var assert = require('assert-plus');
-var once = require('once');
-var backoff = require('backoff');
-var vasync = require('vasync');
-var jsprim = require('jsprim');
+const execFile = require('child_process').execFile;
+const exec = require('child_process').exec;
+const fs = require('fs');
+const os = require('os');
+const path = require('path');
+const sprintf = require('util').format;
+
+const assert = require('assert-plus');
+const once = require('once');
+const backoff = require('backoff');
+const vasync = require('vasync');
+const jsprim = require('jsprim');
 
 
 
 ///--- Globals
 
-var CFG_FILE = path.resolve(__dirname, '../etc/haproxy.cfg');
-var CFG_FILE_TMP = path.resolve(__dirname, '../etc/haproxy.cfg.tmp');
-var CFG_IN = fs.readFileSync(path.resolve(__dirname, '../etc/haproxy.cfg.in'),
+const CFG_FILE = path.resolve(__dirname, '../etc/haproxy.cfg');
+const CFG_FILE_TMP = path.resolve(__dirname, '../etc/haproxy.cfg.tmp');
+const CFG_IN = fs.readFileSync(path.resolve(__dirname, '../etc/haproxy.cfg.in'),
                              'utf8');
-var RESTART = '/usr/sbin/svcadm restart haproxy';
+const RESTART = '/usr/sbin/svcadm restart haproxy';
 /* JSSTYLED */
-var CLEAR_SERVER_LINE = '        server be%d %s:81 check inter 30s slowstart 10s\n';
+const CLEAR_SERVER_LINE = '        server be%d %s:81 check inter 30s slowstart 10s\n';
 /* JSSTYLED */
-var SSL_SERVER_LINE =   '        server be%d %s:80 check inter 30s slowstart 10s\n';
-var INSECURE_FRONTEND =
+const SSL_SERVER_LINE =   '        server be%d %s:80 check inter 30s slowstart 10s\n';
+const INSECURE_FRONTEND =
     'frontend http_external\n        default_backend insecure_api\n';
-var INSECURE_BIND_LINE = '        bind %s:80\n';
+const INSECURE_BIND_LINE = '        bind %s:80\n';
 
 // Locks for single reset run
 var RESTART_RUNNING = false;
@@ -88,8 +92,8 @@ function writeHaproxyConfig(opts, cb) {
         });
     }
 
-    var _cfg_in = opts.configFileIn || CFG_IN;
-    var str = sprintf(_cfg_in,
+    const _cfg_in = opts.configFileIn || CFG_IN;
+    const str = sprintf(_cfg_in,
         os.hostname(),
         ssl,
         clear,
@@ -97,7 +101,7 @@ function writeHaproxyConfig(opts, cb) {
         opts.trustedIP,
         opts.trustedIP);
 
-    var configOut = opts.configFileOut || CFG_FILE;
+    const configOut = opts.configFileOut || CFG_FILE;
     opts.log.debug('Writing haproxy config file: %s', configOut);
     return (fs.writeFile(configOut, str, 'utf8', cb));
 }
@@ -107,10 +111,10 @@ function restartHaproxy(opts, cb) {
     assert.object(opts.log, 'options.log');
     assert.optionalString(opts.restart, 'options.restart');
 
-    var _restart = opts.restart || RESTART;
+    const _restart = opts.restart || RESTART;
     opts.log.debug('Restarting haproxy with: %s...', _restart);
 
-    var retry = backoff.call(exec, _restart, cb);
+    const retry = backoff.call(exec, _restart, cb);
     retry.failAfter(3);
     retry.setStrategy(new backoff.ExponentialStrategy({
         initialDelay: 1000
@@ -143,7 +147,7 @@ function getHaproxyExec(opts, cb) {
                 return (cb(error));
             } else {
                 // svccfg line returned, parse out the haproxy path
-                var m = stdout.match(/[\w/]+haproxy/);
+                const m = stdout.match(/[\w/]+haproxy/);
                 if (m !== null) {
                     haproxy_exec = m[0];
                 } else {
@@ -174,8 +178,8 @@ function renameHaproxyConfig(opts, cb) {
     assert.optionalString(opts.configFileOut, 'options.configFileOut');
 
     // Use default file names if not provided
-    var configIn = opts.configFileIn || CFG_FILE_TMP;
-    var configOut = opts.configFileOut || CFG_FILE;
+    const configIn = opts.configFileIn || CFG_FILE_TMP;
+    const configOut = opts.configFileOut || CFG_FILE;
 
     opts.log.debug('Renaming haproxy config file: %s to %s',
         configIn, configOut);
@@ -194,7 +198,7 @@ function checkHaproxyConfig(opts, cb) {
     assert.object(opts.log, 'options.log');
     assert.optionalString(opts.configFileOut, 'options.configFileOut');
 
-    var configOut = opts.configFileOut || CFG_FILE;
+    const configOut = opts.configFileOut || CFG_FILE;
 
     vasync.waterfall([
         function getExec(wfcb) {
diff --git a/lib/watch.js b/lib/watch.js
index 0337712..a362ee8 100644
--- a/lib/watch.js
+++ b/lib/watch.js
@@ -5,46 +5,42 @@
  */
 
 /*
- * Copyright (c) 2014, Joyent, Inc.
+ * Copyright (c) 2017, Joyent, Inc.
  */
 
-var EventEmitter = require('events').EventEmitter;
-var util = require('util');
-
-var assert = require('assert-plus');
-var once = require('once');
-var vasync = require('vasync');
-var jsprim = require('jsprim');
+/*jsl:ignore*/
+'use strict';
+/*jsl:end*/
 
+const EventEmitter = require('events').EventEmitter;
+const util = require('util');
+const assert = require('assert-plus');
+const once = require('once');
+const vasync = require('vasync');
+const jsprim = require('jsprim');
 
 
 ///--- Globals
 
-var sprintf = util.format;
-
-
+const sprintf = util.format;
 
 ///--- Private Functions
 
+// Turns something like manta.machine.joyent.com into com/joyent/machine/manta
 function domainToPath(domain) {
     return ('/' + domain.split('.').reverse().join('/'));
 }
 
 
-
 ///--- API
-
 function Watch(options) {
-    assert.ok(options);
-    assert.ok(options.domain);
-    assert.ok(options.log);
-    assert.ok(options.zk);
+    assert.object(options);
+    assert.string(options.domain);
+    assert.object(options.log);
+    assert.object(options.zk);
 
     EventEmitter.call(this);
 
-    // sometimes you suck, node:
-    // https://github.com/joyent/node/blob/v0.8.9-release/lib/events.js#L79
-    // ensure that this.emit('foo') generates a null deref.
     this.hosts = [];
     this.log = options.log.child({clazz: 'Watch'}, true);
     this.path = domainToPath(options.domain);
@@ -52,26 +48,47 @@ function Watch(options) {
 }
 util.inherits(Watch, EventEmitter);
 
-
 Watch.prototype.start = function start(callback) {
     callback = once(callback);
 
-    var log = this.log;
+    const log = this.log;
+    const zk = this.zk;
     var self = this;
     var tasks = [];
-    var zk = this.zk;
 
     log.debug({
         path: self.path
     }, 'start: entered');
 
-    tasks.push(function mkdir(_, cb) {
+    /*
+     * Setup tasks we need to accomplish on start
+     *  mkdirp - for ensuring the path in ZK exists
+     *  watch - for creating the ZK watcher on the above path
+     *  setup - for setting up watchers for hosts being added/removed/changed
+     *          in the above ZK path
+     */
+    tasks.push(function mkdirp(_, cb) {
         cb = once(cb);
 
         log.debug({
             path: self.path
-        }, 'start: ensuring directory exists');
-        zk.mkdirp(self.path, cb);
+        }, 'mkdirp: ensuring directory exists');
+        const nullBuffer = new Buffer('null', 'ascii');
+        zk.createWithEmptyParents(self.path, nullBuffer, {}, function (err) {
+            if (err && err.code === 'NODE_EXISTS') {
+                log.debug({
+                    path: self.path
+                }, 'mkdirp: directory already exists');
+                cb(null);
+            } else if (err) {
+                cb(err);
+            } else {
+                log.debug({
+                    path: self.path
+                }, 'mkdirp: directory created');
+                cb(null);
+            }
+        });
     });
 
     tasks.push(function watch(_, cb) {
@@ -79,45 +96,51 @@ Watch.prototype.start = function start(callback) {
 
         log.debug({
             path: self.path
-        }, 'start: setting watch');
-        var opts = {
-            initialData: true,
-            method: 'list'
-        };
-        zk.watch(self.path, opts, function (err, watcher) {
-            if (err) {
-                cb(err);
-            } else {
-                self.watcher = watcher;
-                cb();
-            }
-        });
+        }, 'watch: creating watcher');
+
+        self.watcher = zk.watcher(self.path);
+        cb(null);
     });
 
     tasks.push(function setup(_, cb) {
+        assert.object(self.watcher);
         cb = once(cb);
 
         log.debug({
             path: self.path
-        }, 'start: watch started; registering hooks');
+        }, 'setup: registering hooks');
 
         self.watcher.on('error', function onWatchError(watchErr) {
             log.error({
-                path: self.path,
-                err: watchErr
-            }, 'watcher: error from ZooKeeper');
+                err: watchErr,
+                path: self.path
+            }, 'onWatchError: error from ZooKeeper');
             self.emit('error', watchErr);
         });
 
-        self.watcher.on('children', function onChildren(children) {
+        self.watcher.on('childrenChanged', function onChildren(children) {
             log.debug({
                 path: self.path,
                 children: children
-            }, 'onChildren: watch fired');
-
-            function getChild(c, _cb) {
-                var p = self.path + '/' + c;
-                zk.get(p, function (err, obj) {
+            }, 'onChildrenChanged: watch fired');
+
+            /*
+             * Children are returned as a list of UUID's like:
+             *  children: [
+             *    "26ec0faf-740e-4b55-be1a-XXXX",
+             *    "a6a58d04-0099-4319-83dc-XXXX"
+             *  ]
+             *
+             * This function then fetches the object at the path
+             * corresponding to this entry, determining if it is a
+             * host we care about.
+             */
+            function getChild(child, _cb) {
+                const p = self.path + '/' + child;
+                // Get info about host out of ZK
+                zk.get(p, function (err, _obj) {
+                    // Object returned as binary data from get()
+                    const obj = JSON.parse(_obj.toString());
                     if (err) {
                         _cb(err);
                     } else if (obj.type !== 'host') {
@@ -133,13 +156,17 @@ Watch.prototype.start = function start(callback) {
                         log.debug({
                             path: self.path,
                             host: obj
-                        }, 'onChildren: host fetched');
+                        }, 'onChildrenChanged::getChild: host fetched');
                         _cb(null, obj.host.address);
                     }
                 });
             }
 
-            var opts = {
+            /*
+             * Process children array in parallel, calling getChild() on each
+             * entry
+             */
+            const opts = {
                 func: getChild,
                 inputs: children
             };
@@ -148,17 +175,18 @@ Watch.prototype.start = function start(callback) {
                     log.error({
                         path: self.path,
                         err: err
-                    }, 'watch: getChild failed');
+                    }, 'onChildrenChanged: get host information failed');
                     self.emit('error', err);
                 } else {
                     var hosts = [];
-                    // This little snippet just drops
-                    // nulls and duplicates
-                    res.successes.filter(function (h) {
-                        return (h);
-                    }).forEach(function (h) {
-                        if (hosts.indexOf(h) < 0)
+                    /*
+                     * This little snippet just drops
+                     * nulls and duplicates
+                     */
+                    res.successes.forEach(function uniqHost(h) {
+                        if (h && (hosts.indexOf(h) < 0)) {
                             hosts.push(h);
+                        }
                     });
                     hosts.sort();
 
@@ -167,23 +195,29 @@ Watch.prototype.start = function start(callback) {
                      * changed.
                      */
                     if (!jsprim.deepEqual(hosts, self.hosts)) {
+                        // Log the changes first
+                        log.debug({
+                            path: self.path,
+                            current: self.hosts,
+                            new: hosts
+                        }, 'onChildrenChanged: hosts differ, changing');
                         self.hosts = hosts;
                         log.info({
                             path: self.path,
                             hosts: self.hosts
-                        }, 'watch: hosts updated');
+                        }, 'onChildrenChanged: hosts updated');
+                        // Emit updated hosts list
                         self.emit('hosts', self.hosts);
                     } else {
                         log.info({
                             path: self.path,
-                            new: hosts,
                             current: self.hosts
-                        }, 'watch: got hosts, but no changes');
+                        }, 'onChildrenChanged: got hosts, but no changes');
                     }
                 }
             });
         });
-        cb();
+        cb(null);
     });
 
     // Kick off the mkdirp -> watch -> register pipeline
@@ -192,7 +226,7 @@ Watch.prototype.start = function start(callback) {
             log.error({
                 path: self.path,
                 err: err
-            }, 'start: ZK error');
+            }, 'Watch start: ZK error');
             if (typeof (callback) === 'function') {
                 callback(err);
             } else {
@@ -201,7 +235,7 @@ Watch.prototype.start = function start(callback) {
         } else {
             log.debug({
                 path: self.path
-            }, 'start: watching');
+            }, 'start: watching successful');
 
             if (typeof (callback) === 'function')
                 callback(null);
@@ -213,13 +247,13 @@ Watch.prototype.start = function start(callback) {
     });
 };
 
-
 Watch.prototype.stop = function stop() {
-    if (this.watcher)
-        this.watcher.stop();
+    if (this.watcher) {
+        // Call EventEmitter::removeAllListeners to stop watching
+        this.watcher.removeAllListeners('childrenChanged');
+    }
 };
 
-
 Watch.prototype.toString = function toString() {
     var str = '[object Watch <';
     str += sprintf('path=%s,', (this.path || 'null'));
@@ -229,7 +263,6 @@ Watch.prototype.toString = function toString() {
 };
 
 
-
 ///--- Exports
 
 module.exports = {
diff --git a/lib/zk.js b/lib/zk.js
new file mode 100644
index 0000000..1cfe314
--- /dev/null
+++ b/lib/zk.js
@@ -0,0 +1,45 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+const assert = require('assert-plus');
+const zkstream = require('zkstream');
+
+function createZKClient(cfg, cb) {
+    assert.object(cfg, 'cfg');
+    assert.object(cfg.log, 'cfg.log');
+    assert.arrayOfObject(cfg.zookeeper.servers, 'cfg.zookeeper.servers');
+    assert.number(cfg.zookeeper.timeout, 'cfg.zookeeper.timeout');
+    assert.func(cb, 'callback');
+
+    var opts = {
+        servers: [],
+        log: cfg.log,
+        sessionTimeout: cfg.zookeeper.timeout
+    };
+
+    cfg.zookeeper.servers.forEach(function (s) {
+        // Support old zk-plus (host) or new zkstream (address) configs
+        var _host = s.host || s.address;
+        opts.servers.push({ address: _host, port: s.port });
+    });
+
+    cfg.log.debug({
+        servers: opts.servers,
+        timeout: opts.sessionTimeout
+    }, 'Creating ZooKeeper client');
+
+    cb(null, new zkstream.Client(opts));
+}
+
+
+///--- API
+
+module.exports = {
+    createZKClient: createZKClient
+};
diff --git a/muppet.js b/muppet.js
index 47e2077..d3b37fa 100644
--- a/muppet.js
+++ b/muppet.js
@@ -8,50 +8,28 @@
  * Copyright (c) 2017, Joyent, Inc.
  */
 
-var fs = require('fs');
-
-var assert = require('assert-plus');
-var backoff = require('backoff');
-var bunyan = require('bunyan');
-var dashdash = require('dashdash');
-var forkexec = require('forkexec');
-var net = require('net');
-var once = require('once');
-var VError = require('verror');
-var zkplus = require('zkplus');
-
-var core = require('./lib');
-
-
-
-///--- Globals
+/*
+ * JSLint has a problem with 'use strict', but we want it on so
+ * const fails if reassignment is attempted. With strict off, const
+ * reassignments are silently dropped on the floor
+ */
+/*jsl:ignore*/
+'use strict';
+/*jsl:end*/
+
+const fs = require('fs');
+const assert = require('assert-plus');
+const backoff = require('backoff');
+const bunyan = require('bunyan');
+const dashdash = require('dashdash');
+const forkexec = require('forkexec');
+const net = require('net');
+const once = require('once');
+const VError = require('verror');
+const exec = require('child_process').exec;
+const zkstream = require('zkstream');
+const core = require('./lib');
 
-var LOG = bunyan.createLogger({
-    level: (process.env.LOG_LEVEL || 'info'),
-    name: 'muppet',
-    stream: process.stdout,
-    serializers: {
-        err: bunyan.stdSerializers.err
-    }
-});
-var OPTIONS = [
-    {
-        names: ['help', 'h'],
-        type: 'bool',
-        help: 'Print this help and exit.'
-    },
-    {
-        names: ['verbose', 'v'],
-        type: 'arrayOfBool',
-        help: 'Verbose output. Use multiple times for more verbose.'
-    },
-    {
-        names: ['file', 'f'],
-        type: 'string',
-        help: 'File to process',
-        helpArg: 'FILE'
-    }
-];
 
 ///--- Helper functions
 
@@ -64,32 +42,32 @@ function getUntrustedIPs(cfg, callback) {
 
     cfg.untrustedIPs = [];
 
-    var args = [ '/usr/sbin/mdata-get', 'sdc:nics' ];
-    LOG.info({ cmd: args }, 'Loading NIC information');
+    const args = [ '/usr/sbin/mdata-get', 'sdc:nics' ];
+    cfg.log.info({ cmd: args }, 'Loading NIC information');
     forkexec.forkExecWait({
         argv: args
     }, function (err, info) {
         if (err) {
-            LOG.error(info, 'Failed to load NIC information');
+            cfg.log.error(info, 'Failed to load NIC information');
             setImmediate(callback,
                 new VError(err, 'Fetching untrusted IPs failed'));
             return;
         }
 
-        var nics = JSON.parse(info.stdout);
+        const nics = JSON.parse(info.stdout);
         assert.array(nics, 'nics');
 
-        LOG.info({ nics: nics }, 'Looked up NICs');
+        cfg.log.info({ nics: nics }, 'Looked up NICs');
 
-        nics.forEach(function (nic) {
+        function addIPsFromNics(nic) {
             // Skip NICs on trusted networks.
             if (nic.nic_tag === 'admin' || nic.nic_tag === 'manta') {
                 return;
             }
 
             if (nic.hasOwnProperty('ips')) {
-                nic.ips.forEach(function (addr) {
-                    var ip = addr.split('/')[0];
+                nic.ips.forEach(function parseIP(addr) {
+                    const ip = addr.split('/')[0];
                     if (net.isIPv4(ip) || net.isIPv6(ip)) {
                         cfg.untrustedIPs.push(ip);
                     }
@@ -99,10 +77,11 @@ function getUntrustedIPs(cfg, callback) {
                     cfg.untrustedIPs.push(nic.ip);
                 }
             } else {
-                LOG.warn({ nic: nic }, 'NIC has no IP addresses');
+                cfg.log.warn({ nic: nic }, 'NIC has no IP addresses');
             }
-        });
+        }
 
+        nics.forEach(addIPsFromNics);
         callback();
     });
 }
@@ -111,26 +90,54 @@ function getUntrustedIPs(cfg, callback) {
 ///--- CLI Functions
 
 function configure() {
-    var cfg;
-    var opts;
-    var parser = new dashdash.Parser({options: OPTIONS});
+    const cli_options = [
+        {
+            names: ['help', 'h'],
+            type: 'bool',
+            help: 'Print this help and exit.'
+        },
+        {
+            names: ['verbose', 'v'],
+            type: 'arrayOfBool',
+            help: 'Verbose output. Use multiple times for more verbose.'
+        },
+        {
+            names: ['file', 'f'],
+            type: 'string',
+            help: 'File to process',
+            helpArg: 'FILE'
+        }
+    ];
+
+    const parser = new dashdash.Parser({options: cli_options});
+    var log = bunyan.createLogger({
+        level: (process.env.LOG_LEVEL || 'info'),
+        name: 'muppet',
+        stream: process.stdout,
+        serializers: {
+            err: bunyan.stdSerializers.err
+        }
+    });
 
+    var opts;
     try {
         opts = parser.parse(process.argv);
         assert.object(opts, 'options');
     } catch (e) {
-        LOG.fatal(e, 'invalid options');
+        log.fatal(e, 'invalid options');
         process.exit(1);
     }
 
-    if (opts.help)
+    if (opts.help) {
         usage();
+    }
 
+    var cfg;
     try {
-        var _f = opts.file || __dirname + '/etc/config.json';
+        const _f = opts.file || __dirname + '/etc/config.json';
         cfg = JSON.parse(fs.readFileSync(_f, 'utf8'));
     } catch (e) {
-        LOG.fatal(e, 'unable to parse %s', _f);
+        log.fatal(e, 'unable to parse %s', _f);
         process.exit(1);
     }
 
@@ -141,19 +148,19 @@ function configure() {
         'config.untrustedIPs');
 
     if (cfg.logLevel)
-        LOG.level(cfg.logLevel);
+        log.level(cfg.logLevel);
 
     if (opts.verbose) {
         opts.verbose.forEach(function () {
-            LOG.level(Math.max(bunyan.TRACE, (LOG.level() - 10)));
+            log.level(Math.max(bunyan.TRACE, (log.level() - 10)));
         });
     }
 
-    if (LOG.level() <= bunyan.DEBUG)
-        LOG = LOG.child({src: true});
+    if (log.level() <= bunyan.DEBUG)
+        log = log.child({src: true});
 
-    cfg.log = LOG;
-    cfg.zookeeper.log = LOG;
+    cfg.log = log;
+    cfg.zookeeper.log = log;
 
     return (cfg);
 }
@@ -173,10 +180,37 @@ function usage(msg) {
 
 ///--- Internal Functions
 
+/*
+ * For errors where we have no real way to recover without a complete
+ * bootstrap, it is sometimes easier to just restart
+ */
+function restartMuppet(log, cb) {
+    // SMF adds SMF_FMRI as a environment variable
+    // Fall back on a common name if it is not there for some reason
+    const smf_fmri = (process.env.SMF_FMRI || '/manta/muppet');
+    const restart = '/usr/sbin/svcadm restart ' + smf_fmri;
+    log.warn('Restarting muppet with: %s...', restart);
+
+    var retry = backoff.call(exec, restart, cb);
+    retry.failAfter(3);
+    retry.setStrategy(new backoff.ExponentialStrategy({
+        initialDelay: 1000
+    }));
+    retry.on('backoff', function (number, delay, err) {
+        log.debug({
+            attempt: number,
+            delay: delay,
+            err: err
+        }, 'Muppet restart attempted');
+    });
+    retry.start();
+}
+
+
 function startWatch(opts, cb) {
     assert.object(opts, 'options');
     assert.object(opts.config, 'options.config');
-    assert.object(opts.log, 'options.log');
+    assert.object(opts.config.log, 'options.config.log');
     assert.object(opts.zk, 'options.zk');
     assert.func(cb, 'callback');
 
@@ -185,10 +219,10 @@ function startWatch(opts, cb) {
     function _start(_, _cb) {
         _cb = once(_cb);
 
-        var cfg = opts.config;
-        var watch = new core.createWatch({
+        const cfg = opts.config;
+        const watch = new core.createWatch({
             domain: cfg.name,
-            log: opts.log,
+            log: cfg.log,
             zk: opts.zk
         });
         watch.start(function onStart(startErr) {
@@ -197,30 +231,34 @@ function startWatch(opts, cb) {
                 return;
             }
 
-            // ZooKeeper errors should redrive here.
+            // ZooKeeper errors will cause the Watcher to emit `error`
             watch.on('error', function (err) {
-                opts.log.error(err, 'watch failed; stopping watch.');
+                cfg.log.error(err, 'watch failed; restarting muppet.');
                 watch.stop();
+                // Restart the process with SMF for lack of a better
+                // option of recovery.
+                restartMuppet(cfg.log, _cb);
             });
 
+            // Watcher emits `hosts` on a change to hosts in ZK
             watch.on('hosts', function onHosts(hosts) {
-                var _opts = {
+                const _opts = {
                     trustedIP: cfg.trustedIP,
                     untrustedIPs: cfg.untrustedIPs,
                     hosts: hosts || [],
-                    log: opts.log.child({component: 'lb_manager'}),
+                    log: cfg.log.child({component: 'lb_manager'}),
                     restart: cfg.restart
                 };
                 core.restartLB(_opts, function (err) {
                     if (err) {
-                        opts.log.error({
+                        cfg.log.error({
                             hosts: hosts,
                             err: err
                         }, 'lb restart failed');
                         return;
                     }
 
-                    opts.log.info({
+                    cfg.log.info({
                         hosts: hosts
                     }, 'lb restarted');
                 });
@@ -231,100 +269,90 @@ function startWatch(opts, cb) {
     }
 
     function start() {
-        var retry = backoff.call(_start, {}, cb);
+        const retry = backoff.call(_start, {}, cb);
         retry.failAfter(Infinity);
         retry.setStrategy(new backoff.ExponentialStrategy());
 
         retry.on('backoff', function (num, delay, err) {
-            opts.log.warn({
+            opts.config.log.warn({
                 err: err,
                 num_attempts: num,
                 delay: delay
             }, 'failed to start ZooKeeper watch');
         });
-
         retry.start();
     }
 
     start();
 }
 
+function watcher(cfg, zk_client) {
+    startWatch({
+        config: cfg,
+        zk: zk_client
+    }, function (_dummy, watch) {
+        zk_client.on('failed', function onError(err) {
+            cfg.log.error(err, 'ZooKeeper: error');
+            if (watch) {
+                watch.stop();
+            }
+            zk_client.close();
+        });
+    });
+}
 
+function zookeeper(cfg) {
+    assert.object(cfg, 'cfg');
+    assert.object(cfg.log, 'cfg.log');
 
-///--- Mainline
-
-(function main() {
-    var cfg = configure();
-
-    function zookeeper() {
-        function _zk(_, cb) {
-            cb = once(cb);
-
-            var zk = zkplus.createClient(cfg.zookeeper);
-
-            zk.once('connect', function () {
-                zk.removeAllListeners('error');
-                LOG.info({
-                    zk: zk.toString()
-                }, 'ZooKeeper client acquired');
-
-                cb(null, zk);
-            });
-
-            zk.once('error', function (err) {
-                zk.removeAllListeners('connect');
-                cb(err);
-            });
-
-            zk.connect();
+    core.createZKClient(cfg, function (err, zk_client) {
+        if (err) {
+            cfg.log.error(err, 'unable to create ZooKeeper client');
+            process.exit(1);
         }
 
-        var retry = backoff.call(_zk, {}, function (_, zk) {
-            startWatch({
-                config: cfg,
-                log: LOG,
-                zk: zk
-            }, function (_dummy2, watcher) {
-                zk.on('error', function onError(err) {
-                    LOG.error(err, 'ZooKeeper: error');
-                    if (watcher)
-                        watcher.stop();
+        zk_client.on('session', function onSession() {
+            cfg.log.info('ZooKeeper session started');
+            watcher(cfg, zk_client);
+        });
 
-                    zk.close();
+        zk_client.on('connect', function onConnect() {
+            cfg.log.info('ZooKeeper successfully connected');
+        });
 
-                    zk.removeAllListeners('connect');
-                    zk.removeAllListeners('error');
+        zk_client.on('close', function onClose() {
+            cfg.log.warn('ZooKeeper connection closed');
+        });
 
-                    process.nextTick(zookeeper);
-                });
-            });
+        zk_client.on('expire', function onExpire() {
+            cfg.log.warn('ZooKeeper connection expired');
         });
-        retry.failAfter(Infinity);
-        retry.setStrategy(new backoff.ExponentialStrategy());
 
-        retry.on('backoff', function (num, delay, err) {
-            LOG.warn({
-                err: err,
-                num_attempts: num,
-                delay: delay
-            }, 'failed to create ZooKeeper client');
+        zk_client.on('failed', function onFailed(onerr) {
+            cfg.log.error(onerr, 'ZooKeeper: error');
+            process.exit(1);
         });
+    });
+}
 
-        retry.start();
-    }
+
+///--- Mainline
+
+(function main() {
+    var cfg = configure();
 
     getUntrustedIPs(cfg, function (err) {
         if (err) {
             // We failed to load our IPs: abort.
-            LOG.fatal(err, 'Failed to look up any IPs');
+            cfg.log.fatal(err, 'Failed to look up any IPs');
             process.exit(1);
         }
 
-        LOG.info({
+        cfg.log.info({
             trustedIP: cfg.trustedIP,
             untrustedIPs: cfg.untrustedIPs
         }, 'Selected IPs for untrusted networks');
 
-        zookeeper();
+        zookeeper(cfg);
     });
 })();
diff --git a/package.json b/package.json
index 558f979..b22cfa0 100644
--- a/package.json
+++ b/package.json
@@ -8,17 +8,17 @@
         "assert-plus": "1.0.0",
         "backoff": "2.3.0",
         "bunyan": "2.0.2",
-        "dashdash": "1.4.0",
+        "dashdash": "1.14.1",
         "forkexec": "1.1.0",
         "jsprim": "1.4.0",
         "node-uuid": "1.4.1",
-        "once": "1.3.0",
+        "once": "1.4.0",
         "vasync": "2.0.0",
-        "verror": "1.9.0",
-        "zkplus": "0.3.2-smartos-only"
+        "verror": "1.10.0",
+        "zkstream":"0.10.0"
     },
     "devDependencies": {
-        "nodeunit": "0.7.4"
+        "nodeunit": "0.11.2"
     },
     "scripts": {
         "start": "node ./muppet.js"
diff --git a/sapi_manifests/muppet/manifest.json b/sapi_manifests/muppet/manifest.json
index 0ed16a2..3c13611 100644
--- a/sapi_manifests/muppet/manifest.json
+++ b/sapi_manifests/muppet/manifest.json
@@ -1,5 +1,5 @@
 {
     "name": "muppet",
     "path": "/opt/smartdc/muppet/etc/config.json",
-	"master": true
+    "master": true
 }
diff --git a/sapi_manifests/muppet/template b/sapi_manifests/muppet/template
index 80ccab9..17c3478 100644
--- a/sapi_manifests/muppet/template
+++ b/sapi_manifests/muppet/template
@@ -2,7 +2,6 @@
   "name": "manta.{{REGION}}.{{DNS_DOMAIN}}",
   "trustedIP": "{{auto.MANTA_IP}}",
   "zookeeper": {
-    "connectTimeout": 1000,
     "servers": [
       {{#ZK_SERVERS}}
       {
diff --git a/sapi_manifests/registrar/manifest.json b/sapi_manifests/registrar/manifest.json
index a11d4ad..98cd3bb 100644
--- a/sapi_manifests/registrar/manifest.json
+++ b/sapi_manifests/registrar/manifest.json
@@ -1,5 +1,5 @@
 {
     "name": "registrar",
     "path": "/opt/smartdc/registrar/etc/config.json",
-	"master": true
+    "master": true
 }
diff --git a/sapi_manifests/ssl_cert/manifest.json b/sapi_manifests/ssl_cert/manifest.json
index 8014624..f8d1adc 100644
--- a/sapi_manifests/ssl_cert/manifest.json
+++ b/sapi_manifests/ssl_cert/manifest.json
@@ -1,5 +1,5 @@
 {
     "name": "ssl_cert",
     "path": "/opt/smartdc/muppet/etc/ssl.pem",
-	"master": true
+    "master": true
 }
diff --git a/test/helper.js b/test/helper.js
index 4af483e..23daeb6 100644
--- a/test/helper.js
+++ b/test/helper.js
@@ -1,14 +1,22 @@
-// Copyright 2012 Mark Cavage.  All rights reserved.
-//
-// Just a simple wrapper over nodeunit's exports syntax. Also exposes
-// a common logger for all tests.
-//
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
 
-var bunyan = require('bunyan');
-var vasync = require('vasync');
-var zkplus = require('zkplus');
+/*
+ * Copyright (c) 2017, Joyent, Inc.
+ */
 
-var core = require('../lib');
+/*jsl:ignore*/
+'use strict';
+/*jsl:end*/
+
+const bunyan = require('bunyan');
+const vasync = require('vasync');
+const zkstream = require('zkstream');
+
+const core = require('../lib');
 
 
 
@@ -29,29 +37,25 @@ function createLogger(name, stream) {
 
 
 function createZkClient(callback) {
-        var host = process.env.ZK_HOST || 'localhost';
+        const host = process.env.ZK_HOST || 'localhost';
         var log = createLogger();
-        var port = process.env.ZK_PORT || 2181;
+        const port = process.env.ZK_PORT || 2181;
 
-        var zk = zkplus.createClient({
+        core.createZKClient({
                 log: log,
                 servers: [ {
-                        host: host,
+                        address: host,
                         port: port
                 } ],
                 timeout: 100
-        });
-
-        zk.once('error', function (err) {
-                zk.removeAllListeners('connect');
+        }, function (_err, zk) {
+            zk.on('failed', function (err) {
                 callback(err);
-        });
-
-        zk.once('connect', function () {
-                zk.removeAllListeners('error');
+            });
+            zk.on('session', function () {
                 callback(null, zk);
+            });
         });
-        zk.connect();
 }
 
 
-- 
2.21.0

