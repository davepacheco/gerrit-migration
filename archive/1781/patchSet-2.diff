commit 21f76aeb26fc49894b36024bd36a646cabadf2d4 (refs/changes/81/1781/2)
Author: Joshua M. Clulow <jmc@joyent.com>
Date:   2017-05-03T02:49:38+00:00 (2 years, 5 months ago)
    
    OS-6050 improve platform live image build tool
    OS-6051 /var/log/manifest is almost certainly not what you wanted

diff --git a/Makefile b/Makefile
index 67f6f2bd..8b79c2f5 100644
--- a/Makefile
+++ b/Makefile
@@ -10,7 +10,7 @@
 #
 
 #
-# Copyright 2016 Joyent, Inc.
+# Copyright (c) 2017, Joyent, Inc.
 #
 
 ROOT =		$(PWD)
@@ -124,9 +124,8 @@ live: world manifest mancheck_conf boot sdcman $(TOOLS_TARGETS) $(MANCF_FILE)
 	@echo $(OVERLAY_MANIFESTS)
 	@echo $(SUBDIR_MANIFESTS)
 	mkdir -p ${ROOT}/log
-	(cd $(ROOT) && \
-	    pfexec ./tools/build_live $(ROOT)/$(MANIFEST) $(ROOT)/output \
-	    $(OVERLAYS) $(ROOT)/proto $(ROOT)/man/man)
+	./tools/build_live -m $(ROOT)/$(MANIFEST) -o $(ROOT)/output \
+	    $(OVERLAYS) $(ROOT)/proto $(ROOT)/man/man
 
 boot: $(BOOT_TARBALL)
 
diff --git a/README.md b/README.md
index 29311f1a..55676588 100644
--- a/README.md
+++ b/README.md
@@ -2,10 +2,15 @@
 
 ## Quickstart
 
-  * cp sample.configure.smartos configure.smartos
-  * ./configure
-  * gmake world
-  * gmake live
+```
+git clone https://github.com/joyent/smartos-live.git
+cd smartos-live
+cp sample.configure.smartos configure.smartos
+./configure
+gmake world
+gmake live
+ls output/
+```
 
 ## Overview
 
@@ -13,18 +18,18 @@ This is smartos-live, which builds a SmartOS platform image containing the
 illumos core OS components; a set of "extra" mostly third-party software
 required by illumos, by other SmartOS software, or for system management; a
 collection of utilities comprising SmartOS-specific functionality
-found in projects/local; and implementation-specific overlays that deliver
+found in `projects/local/`; and implementation-specific overlays that deliver
 additional files verbatim.
 
 The build process occurs in two phases; the first phase is a bootstrap phase.
 The bootstrap phase uses the pkgsrc delivered compiler to build the set of items
 required to build illumos, this includes the compiler and various other
 components.  This process is driven from the illumos-extra repository and
-delivered into a subdirectory of the smartos-live root named proto.strap.
+delivered into a subdirectory of the smartos-live root named `proto.strap/`.
 
 Next, the build process accumulates from those various components a set of
 objects into a subdirectory of the smartos-live root.  This subdirectory is
-known as the proto area and by default is named proto.  All objects that are
+known as the proto area and by default is named `proto/`.  All objects that are
 delivered by the platform are built against the contents of the proto area, such
 that they use the interfaces defined by the headers and libraries provided by
 the software being delivered rather than that installed on the build system.
@@ -43,10 +48,10 @@ This also means that symlinks in the proto area can be broken without
 obvious effects on the platform image, which is usually a bug and can result
 in silent (and not-so-silent) build problems.
 
-The manifests are aggregated and the resulting list of objects assembled
-into lofi filesystems created in /tmp, which in turn are assembled into the
-platform image itself.  This process is performed mainly by the
-tools/build_live script.
+The manifests are aggregated and the resulting list of objects assembled into
+lofi filesystems created in `/tmp`, which in turn are assembled into the
+platform image itself.  This process is performed mainly by the `make live`
+target, described below.
 
 ## Tools
 
@@ -56,104 +61,117 @@ libraries and for linting illumos.  Hopefully this dependency will be
 removed in the future.
 
 Additional build tools are required to be present on the build system;
-configure (see below) will install them if you are building in a SmartOS
-zone, which is the supported and recommended practice, see
-http://wiki.smartos.org/display/DOC/Building+SmartOS+on+SmartOS for zone
-setup instructions.
+`configure` (see below) will install them if you are building in a SmartOS
+zone, which is the supported and recommended practice, see [Building SmartOS on
+SmartOS](http://wiki.smartos.org/display/DOC/Building+SmartOS+on+SmartOS) in
+the wiki for zone setup instructions.
 
 ## Build Steps
 
-The configure script sets everything up for building including:
+The `configure` script sets everything up for building including:
 
-  * ensures system has required packages installed (and is running on illumos!)
-  * ensures SUNWspro is installed in `/opt/SUNWspro`
-  * ensures that `projects/illumos` exists and creates `illumos.sh` there
-  * ensures that `projects/illumos-extra` exists
-  * optional: set the environment variable MAX_JOBS to set build job concurrency (useful for small systems)
+* ensures system has required packages installed (and is running on illumos!)
 
-### The "make world" works as follows:
+* ensures SUNWspro is installed in `/opt/SUNWspro`
 
-  * The subset of illumos-extra required at build time to encode runtime
-    dependencies into illumos is built, starting with gcc 4.4.4, and
-    installed into the bootstrap proto area (by default, proto.strap).
+* ensures that `projects/illumos/` exists and creates `illumos.sh` there
 
-  * The illumos source in projects/illumos (can be a link) is built with the
-    aid of tools/build_illumos and installed into the proto area.  The
-    compiler used is the one built in the first phase.
+* ensures that `projects/illumos-extra/` exists
 
-  * All illumos-extra components are built and installed into the proto
-    area.
+* optional: set the environment variable `MAX_JOBS` to set build job
+  concurrency (useful for small systems)
 
-  * The local sources in the `src` subdirectory are built and installed into
-    the proto area.
+### The `make world` Target
 
-  * Any extra projects found in the directory projects/local, by default kvm and
-    kvm-cmd, are built and installed into the proto area.
+The operating system is built using the `make world` target.  This phase is the
+longest part of the build process, and performs at least the following actions:
 
-### The "make live" uses the tools/build_live script as follows:
+* The subset of illumos-extra required at build time to encode runtime
+  dependencies into illumos is built, starting with gcc 4.4.4, and
+  installed into the bootstrap proto area (by default, proto.strap).
 
-  * The manifest is used, directories and links are created and files are taken:
-      * from an overlay directory, in the order specified by the configure
-        fragment's `OVERLAY` variable; then
-      * from the proto area; finally
-      * from the `man/man` subdirectory
+* The illumos source in `projects/illumos/` (can be a link) is built with the
+  aid of `tools/build_illumos` and installed into the proto area.  The
+  compiler used is the one built in the first phase.
 
-  * Once the files are copied in, the tools/customize script is run which also
-    sources tools/customize.* if they exist
+* All illumos-extra components are built and installed into the proto
+  area.
 
-  * Then the image is packed up and put in output with an expanded directory and
-    a `platform-BUILDSTAMP.tgz`
+* The local sources in the `src` subdirectory are built and installed into
+  the proto area.
 
-  * A log of the live image creation is written into the `log` subdirectory
-    containing entries of the form:
+* Any extra projects found in the directory `projects/local/`, by default kvm and
+  kvm-cmd, are built and installed into the proto area.
 
-	FILE: [path/to/file][PERM][owner/uid][group/gid]: OK (/path/to/source)
-	LINK(symlink): source => target: OK
-	LINK: source => target: OK
-	DIR: [path/to/dir][PERM][owner/uid][group/gid]: OK
+### The `make live` Target
 
-    If the build fails during this step, check the log file for any entries
-    containing FAIL.  In most cases, this will be the result of a bug in the
-    build system (or an object that was not delivered to the proto area, in
-    which case the failure to stop that build at that point is also a build
-    system bug).
+The `make live` target constructs the bootable platform image from the operating
+system components built by `make world`.  The heavy lifting is mostly implemented
+in the `tools/build_live` script, which performs at least the following actions:
 
-## Creating additional build artifacts
+* The manifest is used, directories and links are created and files are taken:
+    * from an overlay directory, in the order specified by the configure
+      fragment's `OVERLAY` variable; then
+    * from the proto area; finally
+    * from the `man/man` subdirectory
 
-By default, the build only generates the `platform-BUILDSTAMP.tgz` file. This
-may also be transformed into a CD-ROM ISO image and a USB key image. To
-transform it into a CD-ROM ISO image, one may use the `./tools/build_iso`
-script. To transform it into a USB image, one should use the `./tools/build_usb`
-script.
+* Then the image is packed up and put in `output/` with an expanded directory and
+  a compressed tar archive, `platform-BUILDSTAMP.tgz`.
+
+* Various customisations to the base operating system are applied, including
+  the generation of `/etc/release`, `/etc/motd`, and so on, from templates.
+
+* A log of the live image creation is written into the `log` subdirectory
+  containing extensive trace output from the live image build process.  It
+  also includes log entries from the `builder` tool describing the files
+  packed into the image; e.g.,
+
+  ```
+  FILE: [path/to/file][PERM][owner/uid][group/gid]: OK (/path/to/source)
+  LINK(symlink): source => target: OK
+  LINK: source => target: OK
+  DIR: [path/to/dir][PERM][owner/uid][group/gid]: OK
+  ```
+
+  If the build fails during this step, `tools/build_live` attempts to emit
+  diagnostic output describing the problem.  If this output is not sufficient,
+  the trace log can often contain further leads to debugging the problem.
+
+## Creating Additional Build Artifacts
+
+By default, the build only generates the `platform-BUILDSTAMP.tgz` file.  This
+may also be transformed into a CD-ROM ISO image and a USB key image.  To
+transform it into a CD-ROM ISO image, one may use the `make iso` target.  To
+transform it into a USB image, one should use the `make usb` target.
 
 ## Known Issues
 
-  * There are still a small number of illumos-extra components that do not
-    use the unified makefile system, and are built against the build system's
-    headers and libraries. (TBD)
+* There are still a small number of illumos-extra components that do not
+  use the unified makefile system, and are built against the build system's
+  headers and libraries. (TBD)
 
-  * python should be part of illumos-extra, as there are a small number of
-    tools delivered that use it. (TBD)
+* python should be part of illumos-extra, as there are a small number of
+  tools delivered that use it. (TBD)
 
-  * While there should never be a delivered object with build environment
-    DT_RPATH leakage, there is currently no tool for checking this.
-    (OS-1122)
+* While there should never be a delivered object with build environment
+  DT_RPATH leakage, there is currently no tool for checking this.
+  ([OS-1122][OS-1122])
 
-  * There is also no tool for verifying that all objects delivered within
-    the platform have no dependencies outside the platform.  This includes
-    both runtime library linking and the execution of interpreters.
-    (OS-1122)
+* There is also no tool for verifying that all objects delivered within
+  the platform have no dependencies outside the platform.  This includes
+  both runtime library linking and the execution of interpreters.
+  ([OS-1122][OS-1122])
 
-  * illumos-extra recurses over all components even during an incremental
-    build.  This is time-consuming and usually pointless. (OS-1319)
+* illumos-extra recurses over all components even during an incremental
+  build.  This is time-consuming and usually pointless. ([OS-1319][OS-1319])
 
-  * The complete set of build-order dependencies within illumos-extra
-    probably has not been enumerated.  Doing so would allow for greater
-    parallelism in that portion of the build.  In addition, it is likely
-    that many of the components are actually unsafe to build in parallel
-    internally. (TBD)
+* The complete set of build-order dependencies within illumos-extra
+  probably has not been enumerated.  Doing so would allow for greater
+  parallelism in that portion of the build.  In addition, it is likely
+  that many of the components are actually unsafe to build in parallel
+  internally. (TBD)
 
-  * The illumos-extra unified makefile system is not documented.
+* The illumos-extra unified makefile system is not documented.
 
 ## Contributing
 
@@ -183,11 +201,21 @@ discuss the issue with other developers on one of the following:
 
 ## Other Notes
 
-  * The resulting image requires a 64-bit machine
-  * The BUILDSTAMP is available in the live image in /etc/joyent_buildstamp
-  * There is a manifest created:
+  * The resulting image requires a 64-bit x86 machine.
+
+  * The build stamp, as well as a summary of the repositories from which the
+    image was constructed, is available within the live image as `/etc/release`.
+
+  * There is a manifest of shipped files created in the output area; i.e.,
+
+    ```
+    output/platform-BUILDSTAMP/i86pc/amd64/boot_archive.manifest
+    ```
 
-	output/platform-BUILDSTAMP/i86pc/amd64/boot_archive.manifest
+    This file contains a list of all files, directories, and links in the
+    image, as well as the MD5 hash of the contents of all files.  The manifest
+    is also available in the live image itself as `/usr/share/smartos/manifest`.
 
-   which contains a list of all files/links in the image + md5sums of files and
-   is also available in the live image itself in /var/log/manifest
+<!-- References -->
+[OS-1122]: https://smartos.org/bugview/OS-1122
+[OS-1319]: https://smartos.org/bugview/OS-1319
diff --git a/overlay/generic/lib/svc/method/fs-joyent b/overlay/generic/lib/svc/method/fs-joyent
index e0ce91c4..2162bb89 100755
--- a/overlay/generic/lib/svc/method/fs-joyent
+++ b/overlay/generic/lib/svc/method/fs-joyent
@@ -1,25 +1,18 @@
 #!/bin/bash
 #
-# CDDL HEADER START
+# This file and its contents are supplied under the terms of the
+# Common Development and Distribution License ("CDDL"), version 1.0.
+# You may only use this file in accordance with the terms of version
+# 1.0 of the CDDL.
 #
-# The contents of this file are subject to the terms of the
-# Common Development and Distribution License, Version 1.0 only
-# (the "License").  You may not use this file except in compliance
-# with the License.
+# A full copy of the text of the CDDL should have accompanied this
+# source.  A copy of the CDDL is also available via the Internet at
+# http://www.illumos.org/license/CDDL.
 #
-# You can obtain a copy of the license at COPYING
-# See the License for the specific language governing permissions
-# and limitations under the License.
-#
-# When distributing Covered Code, include this CDDL HEADER in each
-# file and include the License file at COPYING.
-# If applicable, add the following below this CDDL HEADER, with the
-# fields enclosed by brackets "[]" replaced with your own identifying
-# information: Portions Copyright [yyyy] [name of copyright owner]
+
 #
-# CDDL HEADER END
+# Copyright (c) 2017, Joyent, Inc.
 #
-# Copyright 2014, Joyent, Inc. All rights reserved.
 
 set -o xtrace
 
@@ -134,6 +127,22 @@ if [ $? -ne 0 ]; then
         cp /tmp/SUNWdefault.xml /etc/zones/
         rm -f /tmp/SUNWdefault.xml
 
+        #
+        # We include a manifest of all files shipped in the platform image,
+        # along with an MD5 hash of their contents.  This was originally
+        # shipped as "/var/log/manifest", but once a machine is set up, "/var"
+        # now comes from the pool.  The upshot of this is that every SmartOS
+        # machine has the manifest from the platform at setup time stored in
+        # "/var/log/manifest".  Now that the manifest has moved to an
+        # accessible location, we should remove this file and replace it with a
+        # symbolic link.
+        #
+        if [[ -f '/var/log/manifest' && ! -L '/var/log/manifest' &&
+            ! -e '/var/log/manifest.original' ]]; then
+                mv '/var/log/manifest' '/var/log/manifest.original'
+                ln -s '../../usr/share/smartos/manifest' '/var/log/manifest'
+        fi
+
         if [[ -z $(/bin/bootparams | grep '^smartos=true') ]]; then
             mkdir -p /opt/smartdc/agents/smf
             mount -O -F lofs /var/svc/manifest/site /opt/smartdc/agents/smf
diff --git a/src/manifest b/src/manifest
index 9c6b3b2c..47fe91a8 100644
--- a/src/manifest
+++ b/src/manifest
@@ -848,3 +848,7 @@ d usr/share/man/man5 0755 root bin
 f usr/share/man/man5/openssl.5 0444 root bin
 f usr/share/man/man5/joyent.5 0444 root bin
 f usr/share/man/man5/fwrule.5 0444 root bin
+
+# compatibility symlink to new shipped file manifest location
+s var/log/manifest=../../usr/share/smartos/manifest
+
diff --git a/tools/build_etcrelease b/tools/build_etcrelease
index a0941da8..dc20a453 100755
--- a/tools/build_etcrelease
+++ b/tools/build_etcrelease
@@ -1,6 +1,5 @@
 #!/bin/bash
 #
-#
 # This file and its contents are supplied under the terms of the
 # Common Development and Distribution License ("CDDL"), version 1.0.
 # You may only use this file in accordance with the terms of version
@@ -12,20 +11,24 @@
 #
 
 #
-# Copyright (c) 2013, Joyent, Inc. All rights reserved.
+# Copyright (c) 2017, Joyent, Inc.
 #
-shopt -s xpg_echo
+
+set -o errexit
 set -o pipefail
 
 ber_arg0=$(basename $0)
-ber_wsroot=
-ber_nent=0
+ber_wsroot=$(cd "$(dirname "$0")/.." && pwd)
+ber_first=true
+ber_version=$1
+ber_template=$2
+ber_template_data=
 
 function fatal
 {
 	local msg="$*"
 	[[ -z "$msg" ]] && msg="failed"
-	echo "$ber_arg0: $msg" >&2
+	printf '%s: %s\n' "$ber_arg0" "$msg" >&2
 	exit 1
 }
 
@@ -33,65 +36,110 @@ function warn
 {
 	local msg="$*"
 	[[ -z "$msg" ]] && msg="failed"
-	echo "$ber_arg0: $msg" >&2
+	printf '%s: %s\n' "$ber_arg0" "$msg" >&2
 }
 
 function get_status
 {
 	local dir=$1 name=$2 cont=$3
-	local branch rev comdate name url
+	local branch rev comdate name url prevdir
 
 	[[ -z "$dir" ]] && fatal "missing directory argument"
 	[[ -z "$name" ]] && fatal "missing name"
 	[[ -d $dir ]] || fatal "asked to get status of non-existant directory"
-	cd $dir || fatal "failed to enter $dir"
-	((ber_nent++))
 
-	printf "\t"
-	[[ $ber_nent -gt 1 ]] && printf ", "
+	prevdir=$PWD
+	if ! cd "$dir"; then
+		fatal "failed to chdir to \"$dir\""
+	fi
+
+	if [[ $ber_first != true ]]; then
+		printf ',\n'
+	else
+		ber_first=false
+	fi
+	printf '  '
 
-	#
-	# This means that we have a local project that isn't a git directory.
-	# Yay team. In this case we just give them a date and move on with life.
-	#
 	if [[ ! -d .git ]]; then
-		comdate=$(date +%s)
-		[[ $? -eq 0 ]] || fatal "failed to get current date"
+		#
+		# This means that we have a local project that isn't a git
+		# directory.  Yay team. In this case we just give them a date
+		# and move on with life.
+		#
+		if ! comdate=$(date +%s); then
+			fatal "failed to get current date"
+		fi
 		warn "no git repository information available"
-		printf "%s%s\n" "{ \"repo\": \"$name\", \"date\": " \
-		    "\"$comdate\", \"warning\": \"no git metadata available\" }"
-		cd - >/dev/null
-		return 0
+
+		printf '  { "repo": "%s", "date": "%s",\n' \
+		    "$name" "$comdate"
+		printf '      "warning": "no git metadata available" }'
+	else
+		if ! url=$(git config remote.origin.url); then
+			fatal "failed to get git origin url"
+		fi
+		if ! branch=$(git branch | grep "^* " | cut -d ' ' -f2-); then
+			fatal "failed to get git branch"
+		fi
+		if ! rev=$(git rev-parse HEAD); then
+			fatal "failed to get current revision"
+		fi
+		if ! comdate=$(git log -n 1 --pretty=format:%ct HEAD); then
+			fatal "failed to get commit date"
+		fi
+
+		printf '  { "repo": "%s", "branch": "%s",\n' \
+		    "$name" "$branch"
+		printf '      "commit_date": "%s",\n' \
+		    "$comdate"
+		printf '      "rev": "%s",\n' \
+		    "$rev"
+		printf '      "url": "%s" }' \
+		    "$url"
 	fi
-	
-	url=$(git config remote.origin.url)
-	[[ $? -eq 0 ]] || fatal "failed to get git origin url"
-	branch=$(git branch | grep "^* " | cut -d ' ' -f2-)
-	[[ $? -eq 0 ]] || fatal "failed to get git branch"
-	rev=$(git rev-parse HEAD)
-	[[ $? -eq 0 ]] || fatal "failed to get current revision"
-	comdate=$(git log -n 1 --pretty=format:%ct HEAD)
-	[[ $? -eq 0 ]] || fatal "failed to get commit date"
-	printf "%s%s%s\n" "{ \"repo\": \"$name\", \"branch\": \"$branch\", " \
-	     "\"rev\": \"$rev\", \"commit_date\": \"$comdate\", \"url\": " \
-	     "\"$url\" }"
-	cd - >/dev/null
+
+	if ! cd "$prevdir"; then
+		fatal "failed to chdir back to \"$prevdir\""
+	fi
+
 	return 0
 }
 
-cd $(dirname $0)/../
-ber_wsroot=$PWD
+#
+# We support two modes of operation:
+#
+#	1. Generating the "/etc/release" file which starts with a header and
+#	   includes the JSON manifest underneath.  To use this mode, the
+#	   caller must provide a VERSION and a TEMPLATE_FILE argument.
+#
+#	2. Generating the bare JSON for the "boot_archive.gitstatus" file.
+#	   This mode is active when no arguments are passed.
+#
+if (( $# != 0 && $# != 2 )); then
+	fatal "usage: $ber_arg0 [ VERSION TEMPLATE_FILE ]"
+fi
+
+if [[ -n $ber_template ]]; then
+	if [[ ! -f $ber_template ]]; then
+		fatal "could not find template file \"$ber_template\""
+	fi
+
+	if ! ber_template_data=$(sed -e "s,%%VERSION%%,$ber_version,g" \
+	    "$ber_template"); then
+		fatal "could not load template file \"$ber_template\""
+	fi
 
-printf "[\n"
-get_status $ber_wsroot smartos-live
-get_status $ber_wsroot/projects/illumos illumos-joyent
-get_status $ber_wsroot/projects/illumos-extra illumos-extra
+	printf '%s\n\n' "$ber_template_data"
+fi
+
+printf '[\n'
+get_status "$ber_wsroot" smartos-live
+get_status "$ber_wsroot/projects/illumos" illumos-joyent
+get_status "$ber_wsroot/projects/illumos-extra" illumos-extra
 for d in $ber_wsroot/projects/local/*; do
 	get_status $d $(basename $d)
 done
 
-# if the smartos overlay exists and is in use, include it
-[[ -d $ber_wsroot/overlay/smartos ]] && \
-    grep -q $ber_wsroot/overlay/smartos $ber_wsroot/overlay/order && \
-    get_status $ber_wsroot/overlay/smartos smartos-overlay
-printf "]\n"
+printf '\n]\n'
+
+exit 0
diff --git a/tools/build_iso b/tools/build_iso
index cd44e782..c82d6ef4 100755
--- a/tools/build_iso
+++ b/tools/build_iso
@@ -11,12 +11,14 @@
 #
 
 #
-# Copyright 2015 Joyent, Inc.
+# Copyright (c) 2017, Joyent, Inc.
 #
 
 #
-# Automates the process of building iso and usb images of a smartos build.
-# It uses the latest platform file that's been built.
+# Automates the process of building ISO and USB images of a SmartOS build.  It
+# uses the latest platform file that's been built.  This program should be
+# invoked via the "make iso" and "make usb" targets of the top-level Makefile
+# in "smartos-live.git".
 #
 
 shopt -s xpg_echo
@@ -335,6 +337,8 @@ while getopts "kmo:nhc:" c $@; do
 	esac
 done
 
+bi_big_banner "Building \"$bi_type\" image"
+
 #
 # Get us to the root of the workspace
 #
diff --git a/tools/build_live b/tools/build_live
index e8c98150..f0c6602d 100755
--- a/tools/build_live
+++ b/tools/build_live
@@ -1,388 +1,829 @@
 #!/bin/bash
 #
-# CDDL HEADER START
-#
-# The contents of this file are subject to the terms of the
-# Common Development and Distribution License (the "License").
-# You may not use this file except in compliance with the License.
-#
-# You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
-# or http://www.opensolaris.org/os/licensing.
-# See the License for the specific language governing permissions
-# and limitations under the License.
-#
-# When distributing Covered Code, include this CDDL HEADER in each
-# file and include the License file at usr/src/OPENSOLARIS.LICENSE.
-# If applicable, add the following below this CDDL HEADER, with the
-# fields enclosed by brackets "[]" replaced with your own identifying
-# information: Portions Copyright [yyyy] [name of copyright owner]
-#
-# CDDL HEADER END
-#
-
-# Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
-# Use is subject to license terms.
-#
-# Copyright 2016 Joyent, Inc.
-
-ROOT=`pwd`
-CUSTOMIZE_SCRIPT=${ROOT}/tools/customize
-SMF_IMPORTER=${ROOT}/tools/smf_import
-SMF_SEEDS=${ROOT}/tools/build_seeds
-BUILDER=${ROOT}/tools/builder/builder
-SCANNER=${ROOT}/tools/scanner
-PWGEN=${ROOT}/tools/pwgen
-GET_STATUS=${ROOT}/tools/build_etcrelease
-MANCHECK="${ROOT}/tools/mancheck/mancheck"
-MANCHECK_CONF_D="${ROOT}/mancheck.conf.d"
-TZCHECK="${ROOT}/tools/tzcheck/tzcheck"
-
-BUILDSTAMP=$(cat ${ROOT}/proto/buildstamp)
-if [[ -z ${BUILDSTAMP} ]]; then
-    echo "Failed to get buildstamp from proto directory."
-    exit 1
-fi
-LOGFILE="${ROOT}/log/build_live.${BUILDSTAMP}.log"
-ERROR=0
-PLATFORM=i86pc
-ISA=i386
-ARCH64=amd64
-RSIZE=272000
-USIZE=448000
-KERNEL_64=platform/$PLATFORM/kernel/$ARCH64/unix
-if [[ -f ${ROOT}/configure-buildver ]]; then
-    BUILDVER=$(head -n1 ${ROOT}/configure-buildver)
-fi
-if [[ -n "${BUILDVER}" ]]; then
-    PREFIX=platform-${BUILDVER}-${BUILDSTAMP}
-else
-    PREFIX=platform-${BUILDSTAMP}
+# This file and its contents are supplied under the terms of the
+# Common Development and Distribution License ("CDDL"), version 1.0.
+# You may only use this file in accordance with the terms of version
+# 1.0 of the CDDL.
+#
+# A full copy of the text of the CDDL should have accompanied this
+# source.  A copy of the CDDL is also available via the Internet at
+# http://www.illumos.org/license/CDDL.
+#
+
+#
+# Copyright (c) 2017, Joyent, Inc.
+#
+
+#
+# Build the platform image (i.e., "boot_archive", "unix", etc) and the platform
+# tar archive.  This program should be invoked via the "make live" target of
+# the top-level Makefile in "smartos-live.git".
+#
+
+set -o pipefail
+set -o nounset
+
+if ! bi_wsroot=$(cd "$(dirname "$0")/.." && pwd) ||
+    ! bi_arg0=$(basename "$0"); then
+	printf 'failed to locate working directory\n' >&2
+	exit 1
 fi
-BOOT_ARCHIVE_64=${PREFIX}/$PLATFORM/$ARCH64/boot_archive
-OUT_KERNEL_64=${PREFIX}/$PLATFORM/kernel/$ARCH64/unix
+bi_type='live'
+bi_uid=
 
-if [ "$(id -u)" != "0" ]; then
-  echo "You must have euid 0 to run this tool."
-  exit 1
+if ! . "$bi_wsroot/tools/lib/build_common.sh"; then
+	printf 'failed to source "build_common.sh"\n' >&2
+	exit 1
 fi
 
-# Send a copy of stdout and stderr to LOGFILE
-exec > >(tee ${LOGFILE}) 2>&1
+bi_manifest=
+bi_out_dir=
+declare -a bi_in_dirs
 
-export PATH=/usr/sbin:/usr/bin:/sbin:/opt/local/bin
+#
+# These variables are populated by "bi_find_buildstamp()":
+#
+bi_buildstamp=
+bi_buildver=
+bi_prefix=
+
+bi_archive=
+bi_kernel=
 
-usage() {
-    echo "This tool is for building a live boot_archive amd64."
-    echo ""
-    echo "Usage: ${0##*/}: <manifest> <outdir> <dir> [<dir> <dir> ...]"
-    exit 1
+#
+# The "bi_create_ramdisk" function stashes the lofi device path for the
+# most recent ramdisk image in this variable:
+#
+bi_lofi_last=
+
+bi_lofi_root=
+bi_lofi_usr=
+
+bi_file_root=
+bi_file_usr=
+
+bi_mnt_root=
+bi_mnt_usr=
+
+bi_log=
+
+
+function usage
+{
+	cat <<-USAGE
+	Usage: $bi_arg0 -m MANIFEST_FILE -o OUTPUT_DIR { INPUT_DIR ... }
+	USAGE
+	exit 2
 }
 
-MANIFEST=$1
-shift
-OUT_DIR=$1
-shift
-IN_DIRS=$*
+function fail_cleanup
+{
+	if [[ -n ${NO_CLEANUP:-} ]]; then
+		printf 'WARNING: skipping cleaning; tmpdir = %s\n' \
+		    "$bi_tmpdir"
+		return
+	fi
+
+	#
+	# Try to make sure we aren't sitting in a directory that we wish
+	# to unmount or remove.
+	#
+	cd /tmp
+
+	if [[ -n $bi_mnt_usr ]]; then
+		pfexec umount -f "$bi_mnt_usr"
+	fi
+	if [[ -n $bi_mnt_root ]]; then
+		pfexec umount -f "$bi_mnt_root"
+	fi
+
+	if [[ -n $bi_lofi_usr ]]; then
+		pfexec lofiadm -d "$bi_lofi_usr"
+	fi
+	if [[ -n $bi_lofi_root ]]; then
+		pfexec lofiadm -d "$bi_lofi_root"
+	fi
+
+	if [[ -n $bi_tmpdir && -d $bi_tmpdir ]]; then
+		rm -rf "$bi_tmpdir"
+	fi
+}
 
-# We need the manifest file
-if [ -z "${MANIFEST}" ] || [ ! -f "${MANIFEST}" ]; then
-    echo "FATAL: <manifest> file required"
-    usage
-else
-    # translate to abs path
-    NEW_MANIFEST=$(cd $(dirname ${MANIFEST}) && pwd)/$(basename ${MANIFEST})
-    MANIFEST=${NEW_MANIFEST}
-fi
+function bi_find_buildstamp
+{
+	local bsfile="$bi_wsroot/proto/buildstamp"
+	local bvfile="$bi_wsroot/configure-buildver"
 
-if [ -z "${OUT_DIR}" ]; then
-    echo "FATAL: <outdir> required."
-    usage
-fi
+	if [[ ! -f $bsfile ]]; then
+		fail "build stamp file is missing: \"$bsfile\""
+	fi
 
-if [ -z "${IN_DIRS}" ]; then
-    echo "FATAL: at least one <dir> required."
-    usage
-fi
+	bi_buildstamp=$(<"$bsfile")
 
-if [ ! -d "${OUT_DIR}" ]; then
-    mkdir -p ${OUT_DIR}
-    if [ ! -d "${OUT_DIR}" ]; then
-        echo "FATAL: Tried to create OUT_DIR: ${OUT_DIR} but failed."
-        exit 1
-    fi
-fi
+	if [[ -z $bi_buildstamp ]]; then
+		fail "build stamp file is empty: \"$bsfile\""
+	fi
 
-num=0
-echo "=== Options/ ==="
-echo "BUILDSTAMP. ${BUILDSTAMP}"
-echo "MANIFEST .. ${MANIFEST}"
-echo "OUTPUT .... ${OUT_DIR}"
-for dir in ${IN_DIRS}; do
-  num=$((${num} + 1))
-  echo "DIR[$(printf '%02d' ${num})] ... ${dir}"
-done
-echo "=== /Options ==="
+	bi_emit_info 'Build Stamp' "$bi_buildstamp"
+
+	if [[ -f $bvfile ]]; then
+		if ! bi_buildver=$(/usr/bin/head -n1 "$bvfile"); then
+			fail "reading build version file \"$bvfile\""
+		fi
+	fi
 
+	if [[ -n $bi_buildver ]]; then
+		bi_emit_info 'Build Version' "$bi_buildver"
+		bi_prefix="platform-$bi_buildver-$bi_buildstamp"
+	else
+		bi_prefix="platform-$bi_buildstamp"
+	fi
+
+}
+
+function bi_run_mancheck
+{
+	local mancheck="$bi_wsroot/tools/mancheck/mancheck"
+	local mancheck_conf_dir="$bi_wsroot/mancheck.conf.d"
+	local -a mancheck_args
+
+	bi_emit_start 'Checking manual pages...'
+
+	for f in "$mancheck_conf_dir"/*.mancheck.conf; do
+		if [[ -f $f ]]; then
+			mancheck_args+=( "$f" )
+		fi
+	done
+
+	if ! bi_extra=$("$mancheck" -f "$bi_manifest" \
+	    -s "${mancheck_args[@]}" 2>&1); then
+		fail "not mancheck clean"
+	fi
+
+	bi_emit_done
+}
+
+function bi_run_tzcheck
+{
+	local tzcheck="$bi_wsroot/tools/tzcheck/tzcheck"
+
+	bi_emit_start 'Checking timezone files...'
+
+	if ! "$tzcheck" -f "$bi_manifest" -p "$bi_wsroot/proto"; then
+		fail "not tzcheck clean"
+	fi
+
+	bi_emit_done
+}
+
+#
+# Create a blank ramdisk image file, then attach it as a lofi device.
+#
+function bi_create_ramdisk
+{
+	local crd_size=$1
+	local crd_path=$2
+
+	if [[ -z $crd_size || -z $crd_path ]]; then
+		fail 'bi_create_ramdisk() requires both arguments'
+	fi
+
+	if [[ -f $crd_path ]]; then
+		fail "ramdisk \"$crd_path\" already exists"
+	fi
+
+	bi_emit_start "Creating ramdisk file \"$crd_path\""
+
+	if ! /usr/sbin/mkfile "${crd_size}k" "$crd_path"; then
+		fail "failed to make ramdisk file \"$crd_path\""
+	fi
+
+	if ! crd_lofi=$(pfexec /usr/sbin/lofiadm -a "$crd_path"); then
+		fail "failed to attach file \"$crd_path\" as lofi device"
+	fi
+
+	bi_lofi_last=$crd_lofi
+
+	bi_emit_done
+}
+
+function bi_create_ufs
+{
+	local cuf_inode_density=$1
+	local cuf_special=$2
+	local cuf_path=$3
+	local cuf_name=$4
+	local cuf_out=
+
+	if [[ -z $cuf_inode_density || -z $cuf_special ||
+	    -z $cuf_path ]]; then
+		fail 'bi_create_ufs() requires three arguments'
+	fi
+
+	if [[ ! -b $cuf_special ]]; then
+		fail "\"$cuf_special\" is not a block device"
+	fi
+
+	bi_emit_start "Creating UFS file system ($cuf_name)"
+
+	if ! cuf_out=$(pfexec /usr/sbin/newfs -o space -m 0 \
+	    -i "$cuf_inode_density" -b 4096 "$cuf_special" \
+	    </dev/null 2>&1); then
+		bi_emit_newline
+		fail "newfs failure for \"$cuf_special\": $cuf_out"
+	fi
+
+	if ! mkdir -p "$cuf_path"; then
+		fail "failed to mkdir \"$cuf_path\" for mount"
+	fi
+
+	if ! pfexec /usr/sbin/mount -F ufs -o nologging "$cuf_special" \
+	    "$cuf_path"; then
+		fail "failed to mount \"$cuf_special\" on \"$cuf_path\""
+	fi
+
+	bi_emit_done
+}
+
+function bi_copy_files
+{
+	local builder="$bi_wsroot/tools/builder/builder"
+	local builder_log="$bi_tmpdir/builder.output"
+
+	bi_emit_start 'Copying files from proto areas to image'
+
+	#
+	# A torrent of mostly uninteresting output pours forth from the
+	# "builder" program.  We'll keep it in a file just in case it's needed
+	# later.
+	#
+	if ! pfexec "$builder" "$bi_manifest" "$bi_mnt_root" \
+	    "${bi_in_dirs[@]}" 2>&1 | bi_log_tee >"$builder_log"; then
+		#bi_emit_newline
+		#printf 'Builder failures:\n' >&2
+		#/usr/bin/grep 'FAILED$' "$builder_log" >&2
+		bi_extra=$(/usr/bin/grep 'FAILED$' "$builder_log")
+		fail "\"builder\" failed to copy from proto area to image"
+	fi
+
+	bi_emit_done
+}
+
+function bi_gen_whatis
+{
+	local tools_proto="$bi_wsroot/projects/illumos/usr/src/tools/proto"
+	local tools_man="$tools_proto/root_i386-nd/opt/onbld/bin/i386/man"
+
+	bi_emit_start 'Generating whatis database'
+
+	if [[ ! -e "$tools_man" ]]; then
+		fail "could not find the illumos tools man at \"$tools_man\""
+	fi
+
+	if ! bi_extra=$(pfexec "$tools_man" -M \
+	    "$bi_mnt_root/usr/share/man:$bi_mnt_root/smartdc/man" -w \
+	    2>&1); then
+		fail "could not generate whatis database"
+	fi
+
+	#
+	# "man -w" will, at times, output diagnostic messages that are not
+	# fatal.
+	#
+	if [[ -n $bi_extra ]]; then
+		bi_emit_newline
+		printf "man -w output:\n"
+		sed -e 's/^/| /' <<< "$bi_extra"
+	fi
+
+	bi_emit_done
+}
 
-function cleanup
+function bi_smf_import
 {
-    umount -f "${rdmnt}/usr" 2>/dev/null
-    umount -f "${rdmnt}" 2>/dev/null
-    lofiadm -d "${rdfile}" 2>/dev/null
-    lofiadm -d "${usrfile}" 2>/dev/null
-    [ -n "${rddir}" ] && rm -fr "${rddir}" 2> /dev/null
+	local smf_importer="$bi_wsroot/tools/smf_import"
+
+	bi_emit_start 'Importing GZ SMF manifests'
+
+	if ! bi_extra=$(pfexec "$smf_importer" "$bi_mnt_root" 2>&1); then
+		fail "failed to import GZ SMF manifests"
+	fi
+
+	bi_emit_done
 }
-function gen_etcrelease
+
+function bi_smf_seeds
 {
-  rdmnt=$1
-  cat <<EOF > ${rdmnt}/etc/release
-                       SmartOS ${BUILDSTAMP} x86_64
-              Copyright 2010 Sun Microsystems, Inc.  All Rights Reserved.
-              Copyright 2010-2012 Joyent, Inc.  All Rights Reserved.
-                        Use is subject to license terms.
+	local smf_seeds="$bi_wsroot/tools/build_seeds"
 
-   Built with the following components:
+	bi_emit_start 'Building SMF seeds'
 
-EOF
-  (cd ${ROOT} && ${GET_STATUS}) >>  ${rdmnt}/etc/release
+	if ! bi_extra=$(pfexec "$smf_seeds" "$bi_mnt_root" 2>&1); then
+		fail "failed to build SMF seeds"
+	fi
+
+	bi_emit_done
+}
+
+function bi_create_password
+{
+	local pwgen="$bi_wsroot/tools/pwgen"
+	local cryptpass="$bi_wsroot/tools/cryptpass"
+	local cp_password
+	local cp_hash
+	local shadow="$bi_mnt_root/etc/shadow"
+	local stash="$bi_out_dir/$bi_prefix/root.password"
+
+	bi_emit_start 'Setting random "root" password'
+
+	#
+	# Generate a random root password.
+	#
+	if ! cp_password=$("$pwgen" -B -c -n 16 1) ||
+	    [[ -z $cp_password ]]; then
+		fail 'unable to generate root password.'
+	fi
+	bi_emit_info 'Password' "$cp_password"
+
+	#
+	# Hash the password for use in /etc/shadow.
+	#
+	if ! cp_hash=$("$cryptpass" "$cp_password") ||
+	    [[ -z $cp_hash ]]; then
+		fail 'unable to generate root password hash.'
+	fi
+
+	#
+	# Replace the existing "root" account row in the ramdisk /etc/shadow
+	# file.
+	#
+	if ! pfexec /usr/bin/nawk -v "cp_hash=$cp_hash" '
+	    BEGIN { FS=":"; OFS=":"; }
+	    $1 == "root" { $2 = cp_hash; } { print; }' "$shadow" \
+	    | pfexec /usr/bin/tee "$shadow.new" >/dev/null; then
+		pfexec /usr/bin/rm -f "$shadow.new"
+		fail 'unable to update ramdisk /etc/shadow'
+	fi
+	if ! pfexec /usr/bin/mv "$shadow.new" "$shadow" ||
+	    ! pfexec /usr/bin/chmod 400 "$shadow"; then
+		fail 'unable to update ramdisk /etc/shadow'
+	fi
+
+	#
+	# Stash the generated root password as a plain text build artefact
+	# so that we can find it later if we need it.
+	#
+	if ! printf '%s\n' "$cp_hash" >"$stash"; then
+		fail "unable to stash root password in \"$stash\""
+	fi
+
+	bi_emit_done
 }
-function create_ufs
+
+function bi_gen_etcrelease
 {
-    archive=$1
-    lofidev=$2
-    lofiusrdev=$3
-    usrfile=$4
-
-    newfs -o space -m 0 -i 12248 -b 4096 ${lofidev} < /dev/null 2> /dev/null
-    mkdir "${rdmnt}"
-    mount -F ufs -o nologging ${lofidev} "${rdmnt}"
-
-    newfs -o space -m 0 -i 14000 -b 4096 ${lofiusrdev} < /dev/null 2> /dev/null
-    mkdir "${rdmnt}/usr"
-    mount -F ufs -o nologging ${lofiusrdev} "${rdmnt}/usr"
-
-    # do the actual copy
-    ${BUILDER} ${MANIFEST} ${rdmnt} ${IN_DIRS}
-    if [ $? -ne 0 ]; then
-        echo "ERROR: copy onto the image failed"
-        echo "(may need to increase the size or manifest file not found)"
-        ERROR=1
-        echo "Failures:"
-            grep "FAILED$" ${LOGFILE}
-        return
-    fi
-    ${CUSTOMIZE_SCRIPT} ${rdmnt} ${BUILDSTAMP}
-    ROOT=${ROOT} ${SMF_IMPORTER} ${rdmnt}
-    echo ${SMF_SEEDS} ${rdmnt}
-    ${SMF_SEEDS} ${rdmnt}
-    if [ $? -ne 0 ]; then
-        echo "ERROR: setting up live image SMF repoistory failed"
-        ERROR=1
-        return
-    fi
-
-    echo "Setting root password..."
-    create_password "${rdmnt}"
-
-    echo "Adding git manifest..."
-    (cd ${ROOT} && ${GET_STATUS}) > ${archive}.gitstatus
-
-    echo "Writing md5sum manifest..."
-    (cd ${rdmnt} && find . -type f | sort | xargs md5sum) > ${rdmnt}/var/log/manifest
-    #INCLUDE_MD5SUM=1 ${SCANNER} ${rdmnt} . | tee ${rdmnt}/var/log/manifest >/dev/null
-    cp ${rdmnt}/var/log/manifest ${archive}.manifest
-
-    # make sure the kernel we copy over matches our boot archive by copying from there.
-    mkdir -p `dirname ${OUT_DIR}/${OUT_KERNEL_64}`
-    cp ${rdmnt}/${KERNEL_64} ${OUT_DIR}/${OUT_KERNEL_64}
-
-    # Set up the /usr files we need before /usr is mounted
-    echo "tmpdir $rddir/usr"
-    umount -f "$rdmnt/usr"
-    mkdir $rddir/usr
-    mount -F ufs -o nologging ${lofiusrdev} "${rddir}/usr"
-    (cd ${rddir}/usr && tar cbf 512 - \
-        bin/[ bin/cat bin/head bin/i86/ksh93 bin/ls kernel/sched/amd64/FSS \
-        lib/fm/libfmevent.so lib/fm/libfmevent.so.1 lib/fm/libtopo.so \
-        lib/fm/libtopo.so.1 lib/libast.so lib/libast.so.1 lib/libcmd.so \
-        lib/libcmd.so.1 lib/libdll.so lib/libdll.so.1 lib/libexacct.so \
-        lib/libexacct.so.1 lib/libfstyp.so lib/libfstyp.so.1 lib/libidmap.so \
-        lib/libidmap.so.1 lib/libipmi.so lib/libipmi.so.1 lib/libpkcs11.so \
-        lib/libpkcs11.so.1 lib/libpool.so lib/libpool.so.1 lib/libproject.so \
-        lib/libproject.so.1 lib/libshell.so lib/libshell.so.1 lib/libsmbios.so \
-        lib/libsmbios.so.1 lib/libsum.so lib/libsum.so.1 sbin/lofiadm) | \
-        (cd ${rdmnt}/usr; tar xbf 512 -)
-
-    umount -f "${rddir}/usr"
-
-    (cd $rdmnt/usr/bin && ln -s "i86/ksh93" $rdmnt/usr/bin/sh)
-
-    # Now lofi compress our /usr filesystem
-    echo "lofi compressing usr file system"
-    lofiadm -d "$lofiusrdev" 2>/dev/null
-    lofiadm -C $usrfile
-    mv $usrfile $rdmnt/usr.lgz
-
-    gen_etcrelease $rdmnt
-
-    umount -f "$rdmnt"
-    rmdir "$rdmnt"
-
-    mv "${rdfile}" "${archive}-new"
-    if [ $? -ne 0 ] ; then
-        rm -f "${archive}-new"
-        rm -f "${archive}.manifest"
-        rm -f "${archive}.gitstatus"
-    fi
+	local template="$bi_wsroot/tools/etc_release.template.txt"
+	local build_etcrelease="$bi_wsroot/tools/build_etcrelease"
+
+	bi_emit_start 'Building "/etc/release" file'
+
+	if ! "$build_etcrelease" "$bi_buildstamp" "$template" |
+	    pfexec /usr/bin/tee "$bi_mnt_root/etc/release" >/dev/null; then
+		fail 'failed to build "/etc/release" file'
+	fi
+
+	#
+	# We include the JSON-only version of the release information as a
+	# separate build artefact.  We ensure that this is correctly JSON
+	# formatted by passing it through json(1).
+	#
+	if ! "$build_etcrelease" | json -o 'json-4' \
+	    >"$bi_archive.gitstatus"; then
+		fail "could not generate gitstatus file"
+	fi
+
+	bi_emit_done
 }
 
-function create_archive
+function bi_ship_manifest
 {
-    archive=$1
-    lofidev=$2
-    lofiusrdev=$3
-    usrfile=$4
-
-    echo "creating ${archive} (${lofidev}) (${lofiusrdev})"
-    mkdir -p `dirname ${archive}`
-
-    create_ufs "$archive" "$lofidev" "$lofiusrdev" "$usrfile"
-    [ $ERROR -eq 1 ] && return
-
-
-    # sanity check the archive before moving it into place
-    #
-    ARCHIVE_SIZE=`ls -l "${archive}-new" 2> /dev/null | nawk '{ print $5 }'`
-    ls "${archive}-new" >/dev/null 2>&1
-
-    if [ $? -eq 1 -o "$ARCHIVE_SIZE" -lt 10000 ]
-    then
-        #
-        # Two of these functions may be run in parallel.  We
-        # need to allow the other to clean up, so we can't
-        # exit immediately.  Instead, we set a flag.
-        #
-        echo "update of $archive failed"
-        ERROR=1
-    else
-        lockfs -f "/$OUT_DIR" 2>/dev/null
-        mv "${archive}-new" "$archive"
-        lockfs -f "/$OUT_DIR" 2>/dev/null
-    fi
+	local fl_manifest="$bi_archive.manifest"
+	local fl_manifest_img="$bi_mnt_usr/share/smartos/manifest"
+
+	bi_emit_start 'Generating shipped file manifest'
+
+	#
+	# Generate a manifest including the MD5 hash of every file we ship.
+	# This is included in the output as a separate build artefact.
+	#
+	if ! (cd "$bi_mnt_root" && pfexec find . -type f | sort |
+	    pfexec xargs md5sum) >"$fl_manifest"; then
+		fail "could not generate manifest file"
+	fi
+
+	#
+	# We include the manifest in the image as well.  Make sure it has
+	# the correct ownership.
+	#
+	if ! pfexec /usr/bin/mkdir "$(dirname "$fl_manifest_img")" ||
+	    ! pfexec /usr/bin/cp "$fl_manifest" "$fl_manifest_img" ||
+	    ! pfexec /usr/bin/chown 0:0 "$fl_manifest_img"; then
+		fail "could not copy manifest file into image"
+	fi
+
+	bi_emit_done
 }
 
-function create_password
+function bi_fill_templates
 {
-    rdmnt=$1
-
-    password="$(${PWGEN} -B -c -n 16 1)"
-    if [[ -z ${password} ]]; then
-        fatal_error "Unable to generate password."
-    fi
-
-    # actually write password into ${rdmnt}/etc/shadow
-    enc_password="$(${ROOT}/tools/cryptpass "${password}")"
-    if [[ -z ${enc_password} ]]; then
-        fatal_error "Unable to generate encrypted password."
-    fi
-    gsed -i -e "s|^root:[^\:]*:|root:${enc_password}:|" ${rdmnt}/etc/shadow
-
-    # write in plaintext to platform so we can find it later if we need it
-    echo "${password}" > ${OUT_DIR}/${PREFIX}/root.password
+	bi_emit_start 'Filling in template files'
+
+	#
+	# The buildstamp needs to be included in various files in place of
+	# the template value of an all-zero date.
+	#
+	for f in etc/motd etc/issue; do
+		if ! pfexec gsed -i -e \
+		    "s/ [0-9]\{8\}T[0-9]\{6\}Z/ $bi_buildstamp/" \
+		    "$bi_mnt_root/$f"; then
+			fail "could not set buildstamp in \"$f\""
+		fi
+	done
+
+	bi_emit_done
 }
 
-function fatal_error
+function bi_file_fixups
 {
-    print -u2 $*
-    exit 1
+	local kernel_src="$bi_mnt_root/platform/i86pc/kernel/amd64/unix"
+
+	bi_emit_start 'Fixing shipped files'
+
+	if ! /usr/bin/mkdir -p "$(dirname "$bi_kernel")" ||
+	    ! /usr/bin/cp "$kernel_src" "$bi_kernel"; then
+		fail "could not copy the kernel"
+	fi
+
+	#
+	# Need to ensure that several files in the image are empty
+	#
+	for f in var/log/syslog var/adm/wtmpx; do
+		if ! pfexec /usr/bin/rm -f "$bi_mnt_root/$f" ||
+		    ! pfexec /usr/bin/touch "$bi_mnt_root/$f" ||
+		    ! pfexec /usr/bin/chown 0:0 "$bi_mnt_root/$f"; then
+			fail "could not create empty file \"$f\""
+		fi
+	done
+
+	if ! pfexec /usr/bin/chown 0:0 "$bi_mnt_root/"; then
+		fail "could not fix permissions on /"
+	fi
+
+	#
+	# The system needs certain files in early boot before /usr is mounted.
+	# We create a tar archive of these files, then unmount /usr and
+	# extract it into the /usr directory underneath.
+	#
+	local -a underfiles=(
+		"bin/["
+		"bin/cat"
+		"bin/head"
+		"bin/i86/ksh93"
+		"bin/ls"
+		"kernel/sched/amd64/FSS"
+		"lib/fm/libfmevent.so"
+		"lib/fm/libfmevent.so.1"
+		"lib/fm/libtopo.so"
+		"lib/fm/libtopo.so.1"
+		"lib/libast.so"
+		"lib/libast.so.1"
+		"lib/libcmd.so"
+		"lib/libcmd.so.1"
+		"lib/libdll.so"
+		"lib/libdll.so.1"
+		"lib/libexacct.so"
+		"lib/libexacct.so.1"
+		"lib/libfstyp.so"
+		"lib/libfstyp.so.1"
+		"lib/libidmap.so"
+		"lib/libidmap.so.1"
+		"lib/libipmi.so"
+		"lib/libipmi.so.1"
+		"lib/libpkcs11.so"
+		"lib/libpkcs11.so.1"
+		"lib/libpool.so"
+		"lib/libpool.so.1"
+		"lib/libproject.so"
+		"lib/libproject.so.1"
+		"lib/libshell.so"
+		"lib/libshell.so.1"
+		"lib/libsmbios.so"
+		"lib/libsmbios.so.1"
+		"lib/libsum.so"
+		"lib/libsum.so.1"
+		"sbin/lofiadm"
+	)
+	local fl_tarfile="$bi_tmpdir/usr_underfiles.tar"
+
+	if ! (cd "$bi_mnt_usr" && /usr/bin/tar cbf 512 "$fl_tarfile" \
+	    "${underfiles[@]}"); then
+		fail "could not copy files to put under /usr"
+	fi
+
+	#
+	# Now, unmount /usr
+	#
+	if ! pfexec /sbin/umount "$bi_mnt_usr"; then
+		fail "could not unmount /usr image"
+	fi
+	bi_mnt_usr=
+	if ! pfexec /usr/sbin/lofiadm -d "$bi_lofi_usr"; then
+		fail "could not detach /usr lofi device"
+	fi
+	bi_lofi_usr=
+
+	#
+	# Put the under files in place in the root image
+	#
+	if ! (cd "$bi_mnt_root/usr" && pfexec /usr/bin/tar xbf 512 \
+	    "$fl_tarfile"); then
+		fail "could not copy files under /usr in root image"
+	fi
+
+	#
+	# In our image, ksh93 is a hardlink to isaexec.  Rather than replicate
+	# that arrangement in the root file system, we just symlink to the
+	# 32-bit binary directly.
+	#
+	if ! pfexec /usr/bin/ln -s 'i86/ksh93' "$bi_mnt_root/usr/bin/sh"; then
+		fail "failed to create ksh93 symlink"
+	fi
+
+	bi_emit_done
 }
 
-function run_checks
+function bi_compress_usr
 {
-    mancheck_args=""
+	local usrlgz="$bi_mnt_root/usr.lgz"
+
+	bi_emit_start 'Compressing /usr image to include in root image'
 
-    for f in "${MANCHECK_CONF_D}"/*.mancheck.conf; do
-        if [[ -f "${f}" ]]; then
-            mancheck_args="${mancheck_args} -c ${f}"
-        fi
-    done
+	#
+	# The /usr image is included as a compressed file in the root image.
+	#
+	if ! pfexec /usr/sbin/lofiadm -C "$bi_file_usr"; then
+		fail "could not compress /usr image"
+	fi
 
-    if ! ${MANCHECK} -f ${MANIFEST} -s ${mancheck_args}; then
-        fatal_error "you are not mancheck -s clean"
-    fi
+	if ! pfexec /usr/bin/mv "$bi_file_usr" "$usrlgz" ||
+	    ! pfexec /usr/bin/chown 0:0 "$usrlgz"; then
+		fail "could not copy /usr image into root image"
+	fi
 
-    if ! ${TZCHECK} -f ${MANIFEST} -p "${ROOT}/proto"; then
-        fatal_error "tzcheck failed"
-    fi
+	bi_emit_done
 }
 
-function safe_update_symlink
+function bi_finish_archive
 {
-    if [[ -z "${1}" || -z "${2}" ]]; then
-        fatal_error "safe_update_symlink args: <source_file> <target>"
-    fi
-
-    if ! (cd "$(dirname "${2}")" && test -e "${1}"); then
-        fatal_error "symlink target \"${1}\" does not appear to exist"
-    fi
-
-    if [[ ! -L "${2}" ]]; then
-        if [[ -e "${2}" ]]; then
-            fatal_error "\"${2}\" exists, but is not a symlink"
-        fi
-    fi
-
-    if ! /usr/bin/rm -f "${2}" || ! /usr/bin/ln -s "${1}" "${2}"; then
-        fatal_error "failed to create symlink \"$2\" -> \"$1\""
-    fi
+	bi_emit_start 'Finishing boot_archive creation'
+
+	if ! pfexec /sbin/umount "$bi_mnt_root"; then
+		fail "could not unmount root image"
+	fi
+	bi_mnt_root=
+
+	if ! pfexec /usr/sbin/lofiadm -d "$bi_lofi_root"; then
+		fail "could not detach root lofi device"
+	fi
+	bi_lofi_root=
+
+	#
+	# Move the completed boot_archive into the output directory.
+	#
+	if ! /usr/bin/mv "$bi_file_root" "$bi_archive"; then
+		fail "could not move boot_archive into output directory"
+	fi
+
+	#
+	# Include the boot_archive hash in the build output.
+	#
+	if ! /usr/bin/digest -a sha1 "$bi_archive" > "$bi_archive.hash"; then
+		fail "could not store hash of boot_archive in output directory"
+	fi
+
+	if ! printf '%s\n' "$bi_buildstamp" >"$bi_out_dir/buildstamp"; then
+		fail "could not store buildstamp in output directory"
+	fi
+
+	bi_emit_done
 }
 
-# Create tmp dir to do the work in
-rddir="/tmp/create_ramdisk.$$.tmp"
-rm -rf "$rddir"
-mkdir "$rddir" || fatal_error "Could not create temporary directory $rddir"
+function bi_platform_tar
+{
+	bi_emit_start 'Creating platform tar archive'
+
+	if ! (cd "$bi_out_dir" && gtar -zcf "$bi_prefix.tgz" \
+	    "$bi_prefix"); then
+		fail "could not create platform tar archive"
+	fi
+
+	bi_emit_done
+}
+
+function bi_safe_update_symlink
+{
+	local source_file=$1
+	local target=$2
+
+	if [[ -z $source_file || -z $target ]]; then
+		fail 'bi_safe_update_symlink args: <source_file> <target>'
+	fi
+
+	if ! (cd "$(dirname "$target")" && test -e "$source_file"); then
+		fail "symlink target \"$source_file\" does not appear to exist"
+	fi
+
+	if [[ ! -L $target ]]; then
+		if [[ -e $target ]]; then
+			fail "\"$target\" exists, but is not a symlink"
+		fi
+	fi
+
+	#
+	# We use pfexec to remove the old symlink, in case there are latent
+	# file system permission issues from when this program used to run as
+	# root.
+	#
+	if ! pfexec /usr/bin/rm -f "$target" ||
+	    ! /usr/bin/ln -s "$source_file" "$target"; then
+		fail "failed to create symlink \"$target\" -> \"$source_file\""
+	fi
+
+	bi_emit_info 'Linked build output' \
+	    "$(basename "$target") -> $source_file"
+}
+
+
+#
+# Process options:
+#
+while getopts "m:o:" c $@; do
+	case "$c" in
+	m)
+		bi_manifest=$OPTARG
+		;;
+	o)
+		bi_out_dir=$OPTARG
+		;;
+	*)
+		usage
+		;;
+	esac
+done
+
+trap 'bi_early_exit' EXIT
+trap 'bi_interrupt' SIGINT SIGHUP
+
+if ! bi_uid=$(/usr/bin/id -u); then
+	fail 'could not determine user id'
+fi
+
+#
+# Gather the remaining positional arguments to form the list of input
+# directories.
+#
+shift "$(( OPTIND - 1 ))"
+
+while (( $# > 0 )); do
+	bi_in_dirs+=( "$1" )
+	shift
+done
+
+#
+# Check to make sure we have all of the arguments that we need:
+#
+if [[ -z $bi_manifest || -z $bi_out_dir ]]; then
+	fail '-m and -o are required'
+fi
+
+if (( ${#bi_in_dirs[@]} < 1 )); then
+	fail 'at least one input directory is required'
+fi
 
-# Clean up upon exit.
-trap 'cleanup' EXIT
+bi_big_banner 'Building platform image'
 
-echo "Running pre-flight checks"
-run_checks
+#
+# Get us to the root of the workspace:
+#
+if ! cd "$bi_wsroot"; then
+	fail "could not chdir to workspace root \"$bi_wsroot\""
+fi
 
-rdfile="$rddir/rd.file.32"
-rdmnt="$rddir/rd.mnt.32"
-usrfile="$rddir/usr.file"
+#
+# Ensure that the output directory exists, and belongs to the correct
+# user:
+#
+if [[ -d $bi_out_dir ]]; then
+	if ! pfexec /usr/bin/chown -R "$bi_uid" "$bi_out_dir"; then
+		fail "could not fix ownership on output directory"
+	fi
+else
+	if ! /usr/bin/mkdir -p "$bi_out_dir"; then
+		fail "could not create output directory \"$bi_out_dir\""
+	fi
+fi
 
-echo "Creating ${RSIZE}k ramdisk image: ${rdfile}"
-mkfile ${RSIZE}k "${rdfile}"
-chown ${USER} ${rdfile}
-echo "Creating ${USIZE}k usr image: ${usrfile}"
-mkfile ${USIZE}k "${usrfile}"
-chown ${USER} ${usrfile}
+#
+# Load the build stamp (and potentially a build version), and emit some
+# information about what we're going to do.
+#
+bi_find_buildstamp
+bi_emit_info 'Manifest File' "$bi_manifest"
+bi_emit_info 'Output Directory' "$bi_out_dir"
+for (( i = 0; i < ${#bi_in_dirs[@]}; i++ )); do
+	bi_emit_info "Input Directory[$i]" "${bi_in_dirs[$i]}"
+done
+printf '\n'
 
-lofidev32=`lofiadm -a "${rdfile}"`
-lofidevusr=`lofiadm -a "${usrfile}"`
+#
+# Set up trace logging into a log file:
+#
+if [[ -d "$bi_wsroot/log" ]]; then
+	if ! pfexec /usr/bin/chown -R "$bi_uid" "$bi_wsroot/log"; then
+		fail "could not fix ownership on log directory"
+	fi
+else
+	if ! /usr/bin/mkdir -p "$bi_wsroot/log"; then
+		fail "could not create log directory"
+	fi
+fi
+bi_log_setup "$bi_wsroot/log/build_live.$bi_buildstamp.$(date +%s).log"
 
-create_archive "${OUT_DIR}/${BOOT_ARCHIVE_64}" $lofidev32 $lofidevusr $usrfile
+#
+# Run pre-flight checks:
+#
+bi_run_mancheck
+bi_run_tzcheck
 
-lofiadm -d "$lofidev32" 2>/dev/null
+bi_setup_work_dir
 
-if [ $ERROR -eq 0 ]; then
-    chmod 0644 ${OUT_DIR}/${BOOT_ARCHIVE_64}
-    digest -a sha1 ${OUT_DIR}/${BOOT_ARCHIVE_64} \
-      > ${OUT_DIR}/${BOOT_ARCHIVE_64}.hash
-    echo "${BUILDSTAMP}" > ${OUT_DIR}/buildstamp
-    (cd ${OUT_DIR} && gtar -zcf ${PREFIX}.tgz ${PREFIX})
+#
+# Create and mount the "/" (root) ramdisk image:
+#
+bi_file_root="$bi_tmpdir/root.image"
+bi_create_ramdisk 272000 "$bi_file_root"
+bi_lofi_root="$bi_lofi_last"
+bi_mnt_root="$bi_tmpdir/a"
+bi_create_ufs 12248 "$bi_lofi_root" "$bi_mnt_root" "/"
 
-    #
-    # Maintain "latest" symlinks to whichever live image we just assembled.
-    #
-    safe_update_symlink "${PREFIX}" "${OUT_DIR}/platform-latest"
-    safe_update_symlink "${PREFIX}.tgz" "${OUT_DIR}/platform-latest.tgz"
+#
+# Create the /usr directory in the ramdisk:
+#
+bi_mnt_usr="$bi_mnt_root/usr"
+if ! pfexec mkdir "$bi_mnt_usr"; then
+	fail "could not mkdir \"$bi_mnt_usr\""
 fi
 
-if [ $ERROR -eq 1 ]; then
-    cleanup
-    exit 1
+#
+# Create and mount the "/usr" ramdisk image:
+#
+bi_file_usr="$bi_tmpdir/usr.image"
+bi_create_ramdisk 448000 "$bi_file_usr"
+bi_lofi_usr="$bi_lofi_last"
+bi_create_ufs 14000 "$bi_lofi_usr" "$bi_mnt_usr" "/usr"
+
+#
+# Set up the output locations where build artefacts will be stored:
+#
+bi_archive="$bi_out_dir/$bi_prefix/i86pc/amd64/boot_archive"
+bi_kernel="$bi_out_dir/$bi_prefix/i86pc/kernel/amd64/unix"
+
+if ! mkdir -p "$(dirname "$bi_archive")" "$(dirname "$bi_kernel")"; then
+	fail "could not create build output directories"
 fi
 
-exit 0
+#
+# Assemble the boot_archive:
+#
+bi_copy_files
+bi_gen_whatis
+bi_smf_import
+bi_smf_seeds
+bi_create_password
+bi_gen_etcrelease
+bi_ship_manifest
+bi_fill_templates
+bi_file_fixups
+bi_compress_usr
+bi_finish_archive
+bi_platform_tar
+
+#
+# Maintain "latest" symlinks to whichever live image we just assembled.
+#
+bi_safe_update_symlink "$bi_prefix" "$bi_out_dir/platform-latest"
+bi_safe_update_symlink "$bi_prefix.tgz" "$bi_out_dir/platform-latest.tgz"
+
+bi_cleanup_work_dir
+
+bi_exit 0
diff --git a/tools/customize b/tools/customize
deleted file mode 100755
index 4c628710..00000000
--- a/tools/customize
+++ /dev/null
@@ -1,62 +0,0 @@
-#!/bin/bash
-#
-# This file and its contents are supplied under the terms of the
-# Common Development and Distribution License ("CDDL"), version 1.0.
-# You may only use this file in accordance with the terms of version
-# 1.0 of the CDDL.
-#
-# A full copy of the text of the CDDL should have accompanied this
-# source.  A copy of the CDDL is also available via the Internet at
-# http://www.illumos.org/license/CDDL.
-#
-
-#
-# Copyright (c) 2015 Joyent Inc.
-#
-
-set -o errexit
-set -o pipefail
-
-ROOT=$PWD
-MAN=$ROOT/projects/illumos/usr/src/tools/proto/root_i386-nd/opt/onbld/bin/i386/man
-status=0
-
-BUILDSTAMP=$2
-if [[ -z "${BUILDSTAMP}" ]]; then
-	BUILDSTAMP=$(TZ=UTC date "+%Y%m%dT%H%M%SZ")
-fi
-
-rdmnt=$1
-if [[ -z "${rdmnt}" ]]; then
-	echo "Usage: $0 <rdmnt directory> [buildstamp]"
-	exit 1
-fi
-
-if [[ ! -f $MAN ]]; then
-	echo "Somehow you lost your illumos tools"
-	exit 1
-fi
-
-echo "Customizing ${rdmnt}"
-pfexec cp /dev/null ${rdmnt}/etc/mnttab
-pfexec cp /dev/null ${rdmnt}/var/log/syslog
-pfexec cp /dev/null ${rdmnt}/var/adm/wtmpx
-
-pfexec mount -F lofs /dev ${rdmnt}/dev
-# If we're in a GZ there will be a /devices we need to
-if [[ -d /devices ]]; then
-	pfexec mount -F lofs /devices ${rdmnt}/devices
-fi
-
-if [[ -d /devices ]]; then
-	pfexec umount ${rdmnt}/devices
-fi
-pfexec umount ${rdmnt}/dev
-
-pfexec chown root:root ${rdmnt}
-pfexec gsed -i -e "s/ [0-9]\{8\}T[0-9]\{6\}Z/ ${BUILDSTAMP}/" ${rdmnt}/etc/motd
-pfexec gsed -i -e "s/ [0-9]\{8\}T[0-9]\{6\}Z/ ${BUILDSTAMP}/" ${rdmnt}/etc/issue
-
-pfexec $MAN -M ${rdmnt}/usr/share/man:${rdmnt}/smartdc/man -w
-
-exit $status
diff --git a/tools/etc_release.template.txt b/tools/etc_release.template.txt
new file mode 100644
index 00000000..b4a22139
--- /dev/null
+++ b/tools/etc_release.template.txt
@@ -0,0 +1,4 @@
+                      SmartOS %%VERSION%% x86_64
+                    Copyright (c) 2010-2017, Joyent, Inc.
+
+   Built with the following components:
diff --git a/tools/lib/build_common.sh b/tools/lib/build_common.sh
index 425ce899..7be37f43 100755
--- a/tools/lib/build_common.sh
+++ b/tools/lib/build_common.sh
@@ -11,11 +11,11 @@
 #
 
 #
-# Copyright 2015 Joyent, Inc.
+# Copyright (c) 2017, Joyent, Inc.
 #
 
 case "${bi_type}" in
-usb|vmware|iso)
+usb|vmware|iso|live)
 	;;
 *)
 	printf 'ERROR: $bi_type set to invalid value: "%s"\n' "${bi_type}" >&2
@@ -40,11 +40,72 @@ if [[ ! -t 1 ]] || ! bi_columns=$(tput cols); then
 fi
 bi_emit_fmt="%-$((bi_columns - 20))s... "
 bi_last_start=
+bi_last_start_time=
+
+#
+# If this variable is populated on failure, we'll emit the contents after the
+# error message.  The variable will be cleared whenever you start a new
+# section with "bi_emit_start()".
+#
+bi_extra=
+
+bi_exit_reached=false
+
+function bi_early_exit
+{
+	if [[ $bi_exit_reached != true ]]; then
+		bi_exit_reached=true
+		fail 'unexpected early exit'
+	fi
+}
+
+function bi_exit
+{
+	bi_exit_reached=true
+	exit $1
+}
+
+function bi_interrupt
+{
+	bi_exit_reached=true
+	fail 'interrupted by signal'
+}
+
+function bi_stack_trace
+{
+	for (( i = 0; i < ${#FUNCNAME[@]}; i++ )); do
+		#
+		# Elide the stack trace printer from the stack trace:
+		#
+		if [[ ${FUNCNAME[i]} == "fail" ||
+		    ${FUNCNAME[i]} == "bi_stack_trace" ]]; then
+			continue
+		fi
+
+		printf '  [%3d] %s\n' "${i}" "${FUNCNAME[i]}" >&2
+		if (( i > 0 )); then
+			line="${BASH_LINENO[$((i - 1))]}"
+		else
+			line="${LINENO}"
+		fi
+		printf '        (file "%s" line %d)\n' "${BASH_SOURCE[i]}" \
+		    "${line}" >&2
+	done
+}
+
+function bi_big_banner
+{
+	printf '\n'
+	printf '### %s #########################################\n' "$*"
+	printf '\n'
+}
 
 function bi_emit_newline
 {
 	if [[ ${bi_dont_leave_me_hanging} = 1 ]]; then
-		printf '\n'
+		if [[ ! -t 0 || ! -t 1 ]]; then
+			printf '\n'
+		fi
 		bi_dont_leave_me_hanging=0
 	fi
 }
@@ -52,12 +113,19 @@ function bi_emit_newline
 function bi_emit_start
 {
 	printf "${bi_emit_fmt}" "$1"
+	if [[ -t 0 && -t 1 ]]; then
+		printf '\n'
+	fi
 	bi_dont_leave_me_hanging=1
 	bi_last_start="$1"
+	bi_last_start_time=$SECONDS
+	bi_extra=
 }
 
 function bi_emit_done
 {
+	local bi_delta=$(( SECONDS - $bi_last_start_time ))
+
 	if [[ ${bi_dont_leave_me_hanging} = 0 ]]; then
 		#
 		# Intervening output has occurred; refresh the user's memory.
@@ -65,7 +133,14 @@ function bi_emit_done
 		bi_emit_start "(cont.) ${bi_last_start}"
 	fi
 
-	printf 'done\n'
+	if [[ -t 0 && -t 1 ]]; then
+		printf '\e[A\e[%dG' "$((bi_columns - 15))"
+	fi
+	if (( bi_delta > 1 )); then
+		printf 'done (%ds)\n' "$bi_delta"
+	else
+		printf 'done\n'
+	fi
 	bi_dont_leave_me_hanging=0
 }
 
@@ -79,24 +154,53 @@ function bi_emit_info
 	printf '  * %s "%s"\n' "${msg}" "$*"
 }
 
+function bi_log_tee
+{
+	if [[ -n ${BASH_XTRACEFD:-} ]]; then
+		/usr/bin/tee -a "/dev/fd/$BASH_XTRACEFD" || true
+	else
+		/usr/bin/cat
+	fi
+}
+
+function bi_log_setup
+{
+	PS4=
+	PS4="${PS4}"'[\D{%FT%TZ}] ${BASH_SOURCE}:${LINENO}: '
+	PS4="${PS4}"'${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
+	exec 4>>"$1"
+	export BASH_XTRACEFD=4
+	set -o xtrace
+}
+
 function fail
 {
+	bi_exit_reached=true
 	bi_emit_newline
+	printf '\nBUILD FAILURE:\n' >&2
+	bi_stack_trace
+	printf '\n' >&2
 
 	#
 	# This cleanup function should be defined in the program, so that
 	# program-specific cleanup can be performed on exit.
 	#
-	if ! fail_cleanup; then
+	printf 'CLEANING UP ON FAILURE ...\n' >&2
+	if ! fail_cleanup 2>&1 | sed 's/^/| /'; then
 		printf 'ERROR: "fail_cleanup" function did not succeed\n' >&2
 	fi
+	printf '... DONE\n\n' >&2
 
 	#
 	# Print the final error message:
 	#
 	local msg="$*"
 	[[ -z "$msg" ]] && msg="failed"
-	printf '%s: ERROR: %s\n' "$bi_arg0" "$msg" >&2
+	printf '%s: ERROR: %s\n' "$bi_arg0" "$msg" | bi_log_tee >&2
+	if [[ -n $bi_extra ]]; then
+		printf '%s\n' "$bi_extra" | sed 's/^/  | /' |
+		    bi_log_tee >&2
+	fi
 	exit 1
 }
 
@@ -132,6 +236,7 @@ function bi_setup_work_dir
 	if ! mkdir $bi_tmpdir >/dev/null; then
 		fail "failed to make temporary directory"
 	fi
+	bi_emit_info 'Temporary Directory' "$bi_tmpdir"
 	bi_emit_done
 
 	if [[ $bi_type == usb ]]; then
@@ -141,7 +246,10 @@ function bi_setup_work_dir
 
 function bi_cleanup_work_dir
 {
-	[[ $bi_dont_clean -eq 1 ]] && return
+	if [[ ${bi_dont_clean:-} -eq 1 ]]; then
+		return 0
+	fi
+
 	bi_emit_start 'Removing temporary directory...'
 	[[ ! -d $bi_tmpdir ]] && return
 	rm -rf $bi_tmpdir/*
diff --git a/tools/smf_import b/tools/smf_import
index 228276f2..25737076 100755
--- a/tools/smf_import
+++ b/tools/smf_import
@@ -5,6 +5,8 @@
 
 set -e
 
+ROOT=$(cd "$(dirname "$0")/.." && pwd)
+
 SVCCFG="${ROOT}/projects/illumos/usr/src/cmd/svc/svccfg/svccfg-native"
 
 rdmnt=$1
@@ -14,11 +16,6 @@ if [ -z "${rdmnt}" ] || [ ! -d "${rdmnt}" ]; then
   exit 1
 fi
 
-if [ -z "${ROOT}" ]; then
-	echo "FATAL: ROOT not specified"
-	exit 1
-fi
-
 if [[ ! -x ${SVCCFG} ]]; then
 	echo "FATAL: Missing svccfg-native binary from illumos build looked in '${SVCCFG}'"
 	exit 1
