From aa5d43b69451aedb4412b860e113c8091d0ed854 Mon Sep 17 00:00:00 2001
From: Cody Peter Mello <cody.mello@joyent.com>
Date: Thu, 10 Aug 2017 20:34:04 +0000
Subject: [PATCH] joyent/node-macaddr#1 Want library for parsing MAC addresses
 Reviewed by: Patrick Mooney <patrick.mooney@joyent.com> Reviewed by: Tim
 Kordas <tim.kordas@joyent.com> Reviewed by: Robert Mustacchi <rm@joyent.com>

---
 README.md            |  39 ++++++++
 lib/macaddr.js       | 225 +++++++++++++++++++++++++++++++++++++++++++
 package.json         |   2 +-
 test/compare.test.js | 105 ++++++++++++++++++++
 test/constants.js    |  29 ++++++
 test/output.test.js  |  63 ++++++++++++
 test/parse.test.js   | 208 +++++++++++++++++++++++++++++++++++++++
 7 files changed, 670 insertions(+), 1 deletion(-)
 create mode 100644 test/compare.test.js
 create mode 100644 test/constants.js
 create mode 100644 test/output.test.js
 create mode 100644 test/parse.test.js

diff --git a/README.md b/README.md
index c69829e..fa3c5b2 100644
--- a/README.md
+++ b/README.md
@@ -8,6 +8,45 @@ macaddr is a library for parsing and manipulating MAC addresses in JavaScript.
 
 # API
 
+## `parse(input)`
+
+Parses a string representing and returns a `MAC` object representing the
+address. A MAC address may be in any of the following forms:
+
+- `01:02:03:04:05:06`
+- `01-02-03-04-05-06`
+- `010203040506`
+
+When using `:` or `-` as a separator, the leading zero in an octet can be
+dropped. For example:
+
+- `1:2:3:4:5:6`
+- `1-2-3-4-5-6`
+
+If `parse(input)` is called with a number, it is interpreted as a 48-bit
+integer representing the MAC address.
+
+## `MAC`
+
+### `MAC#toString([opts])`
+
+Returns the string representation of the MAC address. An optional options
+object allows for controlling the output, and takes the following fields:
+
+- `zeroPad` (default: `true`), whether to pad octets that could print as a
+  single character with a `0`.
+
+### `MAC#toLong()`
+
+Returns the 48-bit integer representation of the MAC address.
+
+### `MAC#compare(other)`
+
+Compares the MAC address to another `MAC` object, to determine if they
+represent the same value. If the other MAC address has a larger 48-bit
+representation, this method returns `-1`. If it has a smaller 48-bit
+representation, then it returns `1`. If the two addresses are equivalent,
+then the result is `0`.
 
 # License
 
diff --git a/lib/macaddr.js b/lib/macaddr.js
index eafcf9e..1451ce7 100644
--- a/lib/macaddr.js
+++ b/lib/macaddr.js
@@ -9,3 +9,228 @@
  */
 
 'use strict';
+
+var assert = require('assert-plus');
+var mod_jsprim = require('jsprim');
+
+var HEX_RE = /^[a-f0-9]$/;
+
+// --- Helpers
+
+function isxdigit(c) {
+    return HEX_RE.test(c);
+}
+
+
+var strDefaults = {
+    zeroPad: true // Pad with zeros when an octet would print as 1 char
+};
+
+
+function getStrOpt(opts, name) {
+    if (opts && opts.hasOwnProperty(name)) {
+        return opts[name];
+    } else {
+        return strDefaults[name];
+    }
+}
+
+
+// --- Main class
+
+/**
+ * The MAC class wraps a 48-bit integer, and provides several helper
+ * methods for manipulating it.
+ *
+ * It could wrap an array of 6 octets instead, but doing so complicates
+ * processing both numeric input and output, without improving string
+ * processing in a useful way. (We would be able to remove the bitwise
+ * arithmetic in .toString(), but it would just end up in parseLong()
+ * instead.)
+ *
+ * Since the initial motivation for this library was a program that
+ * stores MAC addresses as numbers in its database, making numeric
+ * processing easier made more sense.
+ */
+function MAC(value) {
+    assert.number(value, 'value');
+    this._value = value;
+}
+
+
+MAC.prototype.toString = function toString(opts) {
+    assert.optionalObject(opts, 'opts');
+    var zeroPad = getStrOpt(opts, 'zeroPad');
+
+    var result = '';
+    var fields = [
+        /*
+         * JavaScript converts numbers to 32-bit integers when doing bitwise
+         * arithmetic, so we have to handle the first two parts of the number
+         * differently.
+         */
+        (this._value / 0x010000000000) & 0xff,
+        (this._value / 0x000100000000) & 0xff,
+
+        (this._value >>> 24) & 0xff,
+        (this._value >>> 16) & 0xff,
+        (this._value >>> 8) & 0xff,
+        (this._value) & 0xff
+    ];
+
+    var octet;
+
+    for (var i = 0; i < fields.length; i++) {
+        if (i !== 0) {
+            result += ':';
+        }
+
+        octet = fields[i].toString(16);
+        if (zeroPad && octet.length === 1) {
+            result += '0';
+        }
+        result += octet;
+    }
+
+    return result;
+};
+
+
+MAC.prototype.toLong = function toLong() {
+    return this._value;
+};
+
+
+MAC.prototype.compare = function compare(other) {
+    assert.ok(other instanceof MAC, 'other is a MAC object');
+
+    if (this._value < other._value) {
+        return -1;
+    } else if (this._value > other._value) {
+        return 1;
+    } else {
+        return 0;
+    }
+};
+
+
+// --- Input parsing
+
+function parseString(input) {
+    assert.string(input);
+    input = input.toLowerCase();
+    var pos = 0;
+    var value = 0;
+    var octet = '';
+    var sep = null;
+    var chr, tmp;
+
+    /*
+     * Test if a character is a valid separator. If we haven't seen a
+     * separator yet, and it's one of the allowed separator characters,
+     * lock in to that character to prevent using a different value later.
+     */
+    function issep(s) {
+        if (sep !== null) {
+            return (s === sep);
+        }
+
+        if (s === ':' || s === '-') {
+            sep = s;
+            return true;
+        }
+
+        return false;
+    }
+
+    function process() {
+        if (octet.length === 0) {
+            throw new Error('expected to find a hexadecimal number before ' +
+                JSON.stringify(sep));
+        } else if (octet.length > 2) {
+            throw new Error(
+                'too many hexadecimal digits in ' + JSON.stringify(octet));
+        } else if (pos < 6) {
+            tmp = mod_jsprim.parseInteger(octet, { base: 16 });
+            if (tmp instanceof Error) {
+                throw tmp;
+            }
+            value *= 0x100;
+            value += tmp;
+            pos += 1;
+            octet = '';
+        } else {
+            throw new Error('too many octets in MAC address');
+        }
+    }
+
+    for (var i = 0; i < input.length; i++) {
+        chr = input[i];
+        if (issep(chr)) {
+            process();
+        } else if (isxdigit(chr)) {
+            octet += chr;
+        } else {
+            throw new Error('unrecognized character ' + JSON.stringify(chr));
+        }
+    }
+
+    if (issep(chr)) {
+        throw new Error('trailing ' + JSON.stringify(sep) + ' in MAC address');
+    }
+
+    if (pos === 0) {
+        if (octet.length !== 12) {
+            throw new Error('MAC address is too short');
+        }
+
+        value = mod_jsprim.parseInteger(octet, { base: 16 });
+        if (value instanceof Error) {
+            throw value;
+        }
+    } else {
+        process();
+
+        if (pos !== 6) {
+            throw new Error('too few octets in MAC address');
+        }
+    }
+
+    return new MAC(value);
+}
+
+
+function parseLong(input) {
+    assert.number(input);
+
+    if (input !== Math.floor(input)) {
+        throw new Error('Value must be an integer');
+    }
+
+    if (input < 0 || input > 0xffffffffffff) {
+        throw new Error('Value must be 48-bit');
+    }
+
+    return new MAC(input);
+}
+
+
+// --- Exports
+
+function macaddrParse(input) {
+    var type = typeof (input);
+
+    switch (type) {
+    case 'string':
+        return parseString(input);
+    case 'number':
+        return parseLong(input);
+    default:
+        throw new Error('expected string or integer, but got ' + type);
+    }
+}
+
+
+module.exports = {
+    parse: macaddrParse
+};
diff --git a/package.json b/package.json
index bf1ddd3..819307b 100644
--- a/package.json
+++ b/package.json
@@ -1,6 +1,6 @@
 {
   "name": "macaddr",
-  "version": "0.0.0",
+  "version": "0.0.1",
   "description": "MAC address parsing and manipulation",
   "keywords": [ "mac", "macaddr" ],
   "repository": {
diff --git a/test/compare.test.js b/test/compare.test.js
new file mode 100644
index 0000000..f901075
--- /dev/null
+++ b/test/compare.test.js
@@ -0,0 +1,105 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright 2017, Joyent, Inc.
+ */
+
+'use strict';
+
+var macaddr = require('../');
+var test = require('tape');
+
+test('addresses are the same', function (t) {
+    var addr = macaddr.parse('0a0b0c0d0e0f');
+
+    var others = [
+        '0a:0b:0c:0d:0e:0f',
+        'a:b:c:d:e:f',
+        '0a:b:c:d:e:0f',
+        '0a-0b-0c-0d-0e-0f',
+        'a-b-c-d-e-f',
+        'a-0b-c-d-0e-f'
+    ];
+
+    t.plan(others.length);
+
+    others.forEach(function (s) {
+        var other = macaddr.parse(s);
+        t.equal(addr.compare(other), 0, s);
+    });
+
+    t.end();
+});
+
+
+test('addresses are different', function (t) {
+    var addr = macaddr.parse('0a0b0c0d0e0f');
+
+    var others = [
+        '0a:0b:0c:0d:0e:0e',
+        '1:2:3:4:5:6',
+        'a:b:c:d0:e:f',
+        '0a-9b-0c-0d-0e-0f',
+        'a-b-c-d-e-1',
+        'a-b0-c-d-0e-f'
+    ];
+
+    t.plan(others.length);
+
+    others.forEach(function (s) {
+        var other = macaddr.parse(s);
+        t.notEqual(addr.compare(other), 0, s);
+    });
+
+    t.end();
+});
+
+
+test('address comes before compared addresses', function (t) {
+    var addr = macaddr.parse('00000c0d0e0f');
+
+    var others = [
+        '0a:0b:0c:0d:0e:0e',
+        '1:2:3:4:5:6',
+        'a:b:c:d0:e:f',
+        '0a-9b-0c-0d-0e-0f',
+        'a-b-c-d-e-1',
+        'a-b0-c-d-0e-f'
+    ];
+
+    t.plan(others.length);
+
+    others.forEach(function (s) {
+        var other = macaddr.parse(s);
+        t.equal(addr.compare(other), -1, s);
+    });
+
+    t.end();
+});
+
+
+test('address comes after compared addresses', function (t) {
+    var addr = macaddr.parse('1f002c0d0e0f');
+
+    var others = [
+        '0a:0b:0c:0d:0e:0e',
+        '1:2:3:4:5:6',
+        'a:b:c:d0:e:f',
+        '0a-9b-0c-0d-0e-0f',
+        'a-b-c-d-e-1',
+        'a-b0-c-d-0e-f'
+    ];
+
+    t.plan(others.length);
+
+    others.forEach(function (s) {
+        var other = macaddr.parse(s);
+        t.equal(addr.compare(other), 1, s);
+    });
+
+    t.end();
+});
diff --git a/test/constants.js b/test/constants.js
new file mode 100644
index 0000000..322e772
--- /dev/null
+++ b/test/constants.js
@@ -0,0 +1,29 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright 2017, Joyent, Inc.
+ */
+
+'use strict';
+
+module.exports = {
+    ADDR_NUM_PAIRS: [
+        [ '0a:0b:0c:0d:0e:0f', 0x0a0b0c0d0e0f ],
+        [ '1a:0b:30:0a:0e:00', 0x1a0b300a0e00 ],
+        [ 'ff:ff:ff:ff:ff:ff', 281474976710655 ],
+        [ 'ff:ff:ff:ff:ff:fe', 281474976710654 ],
+        [ 'ff:ff:ff:ff:ff:fd', 281474976710653 ],
+        [ '90:b8:d0:81:91:30', 159123446534448 ],
+        [ '0e:43:81:95:4b:6d', 15683099642733 ],
+        [ 'a6:50:61:c3:44:8f', 182864167781519 ],
+        [ 'fc:a4:8e:94:b0:11', 277783696945169 ],
+        [ '80:ab:eb:56:9c:d6', 141475876084950 ],
+        [ 'a2:6b:b0:2a:71:88', 178583400771976 ],
+        [ '7b:e5:b5:97:06:3c', 136226524300860 ],
+        [ '2e:91:aa:8d:c7:be', 51203166554046 ]
+    ]
+};
diff --git a/test/output.test.js b/test/output.test.js
new file mode 100644
index 0000000..a1b7ecc
--- /dev/null
+++ b/test/output.test.js
@@ -0,0 +1,63 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright 2017, Joyent, Inc.
+ */
+
+'use strict';
+
+var constants = require('./constants');
+var macaddr = require('../');
+var test = require('tape');
+
+test('output long', function (t) {
+    t.plan(constants.ADDR_NUM_PAIRS.length);
+
+    constants.ADDR_NUM_PAIRS.forEach(function (pair) {
+        t.equal(macaddr.parse(pair[0]).toLong(), pair[1],
+            pair[0] + ' => ' + pair[1]);
+    });
+
+    t.end();
+});
+
+test('output with leading zeros', function (t) {
+    var strs = [
+        [ 'a-b-c-d-e-f', '0a:0b:0c:0d:0e:0f' ],
+        [ '0-1-ef-9d-ae-f0', '00:01:ef:9d:ae:f0' ],
+        [ 'bc-10-ef-9d-ae-f0', 'bc:10:ef:9d:ae:f0' ]
+    ];
+
+    t.plan(strs.length * 2);
+
+    strs.forEach(function (str) {
+        var addr = macaddr.parse(str[0]);
+        t.equal(addr.toString(), str[1], str[0] + ' (with defaults)');
+        t.equal(addr.toString({ zeroPad: true }), str[1],
+            str[0] + ' (with zeroPad=true)');
+    });
+
+    t.end();
+});
+
+test('output without leading zeros', function (t) {
+    var strs = [
+        [ '0a-0b-0c-0d-0e-0f', 'a:b:c:d:e:f' ],
+        [ '00-01-ef-9d-ae-f0', '0:1:ef:9d:ae:f0' ],
+        [ 'bc-10-ef-9d-ae-f0', 'bc:10:ef:9d:ae:f0' ]
+    ];
+
+    t.plan(strs.length);
+
+    strs.forEach(function (str) {
+        var addr = macaddr.parse(str[0]);
+        t.equal(addr.toString({ zeroPad: false }), str[1],
+            str[0] + ' (with zeroPad=false)');
+    });
+
+    t.end();
+});
diff --git a/test/parse.test.js b/test/parse.test.js
new file mode 100644
index 0000000..214ec8d
--- /dev/null
+++ b/test/parse.test.js
@@ -0,0 +1,208 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright 2017, Joyent, Inc.
+ */
+
+'use strict';
+
+var constants = require('./constants');
+var macaddr = require('../');
+var test = require('tape');
+
+test('equivalent ways to write addresses', function (t) {
+    var strs = [
+        '0a0b0c0d0e0f',
+        '0a:0b:0c:0d:0e:0f',
+        'a:b:c:d:e:f',
+        '0a:b:c:d:e:0f',
+        '0a-0b-0c-0d-0e-0f',
+        'a-b-c-d-e-f',
+        'a-0b-c-d-0e-f'
+    ];
+    var v = 0x0a0b0c0d0e0f;
+
+    t.plan(strs.length * 2);
+
+    strs.forEach(function (lc) {
+        var uc = lc.toUpperCase();
+        t.equal(macaddr.parse(lc).toLong(), v, 'parse ' + lc);
+        t.equal(macaddr.parse(uc).toLong(), v, 'parse ' + uc);
+    });
+
+    t.end();
+});
+
+
+test('parse 48-bit integers', function (t) {
+    t.plan(constants.ADDR_NUM_PAIRS.length);
+
+    constants.ADDR_NUM_PAIRS.forEach(function (pair) {
+        t.equal(macaddr.parse(pair[1]).toString(), pair[0],
+            pair[1] + ' => ' + pair[0]);
+    });
+
+    t.end();
+});
+
+
+// --- Invalid MAC addresses
+
+test('Unknown characters', function (t) {
+    t.throws(function () {
+        macaddr.parse('a/b/c/d/e/f');
+    }, /unrecognized character "\/"$/);
+
+    t.throws(function () {
+        macaddr.parse('a:b:0:1:g:c');
+    }, /unrecognized character "g"$/);
+
+    t.throws(function () {
+        macaddr.parse('a:b:_:1:e:c');
+    }, /unrecognized character "_"$/);
+
+    t.end();
+});
+
+
+test('Mixed separators', function (t) {
+    t.throws(function () {
+        macaddr.parse('a:b-c:d-e:f');
+    }, /unrecognized character "-"$/);
+
+    t.throws(function () {
+        macaddr.parse('a-b:c-d:e-f');
+    }, /unrecognized character ":"$/);
+
+    t.end();
+});
+
+
+test('Bad numeric input', function (t) {
+    t.throws(function () {
+        macaddr.parse(1.2345);
+    }, /Value must be an integer$/, 'floating point number');
+
+    t.throws(function () {
+        macaddr.parse(Math.pow(2, 48));
+    }, /Value must be 48-bit$/, 'number is larger than 48 bits');
+
+    t.end();
+});
+
+
+test('non-string, non-integer input', function (t) {
+    t.throws(function () {
+        macaddr.parse({});
+    }, /expected string or integer, but got object$/, 'object input');
+
+    t.throws(function () {
+        macaddr.parse([]);
+    }, /expected string or integer, but got object$/, 'array input');
+
+    t.throws(function () {
+        macaddr.parse(true);
+    }, /expected string or integer, but got boolean$/, 'boolean input');
+
+    t.throws(function () {
+        macaddr.parse(false);
+    }, /expected string or integer, but got boolean$/, 'boolean input');
+
+    t.throws(function () {
+        macaddr.parse();
+    }, /expected string or integer, but got undefined$/, 'no input');
+
+    t.end();
+});
+
+
+test('Trailing separator', function (t) {
+    t.throws(function () {
+        macaddr.parse('a:b:c:d:e:f:');
+    }, /trailing ":" in MAC address$/);
+
+    t.throws(function () {
+        macaddr.parse('a-b-c-d-e-f-');
+    }, /trailing "-" in MAC address$/);
+
+    t.end();
+});
+
+
+test('Incomplete addresses', function (t) {
+    t.throws(function () {
+        macaddr.parse(':');
+    }, /expected to find a hexadecimal number before ":"$/);
+
+    t.throws(function () {
+        macaddr.parse('1::0:e:5:6');
+    }, /expected to find a hexadecimal number before ":"$/);
+
+    t.throws(function () {
+        macaddr.parse('1-2-3--5-6');
+    }, /expected to find a hexadecimal number before "-"$/);
+
+    t.throws(function () {
+        macaddr.parse('');
+    }, /MAC address is too short$/);
+
+    t.throws(function () {
+        macaddr.parse('a:b:c:d:e');
+    }, /too few octets in MAC address$/);
+
+    t.throws(function () {
+        macaddr.parse('a:b:c:0d:0e');
+    }, /too few octets in MAC address$/);
+
+    t.throws(function () {
+        macaddr.parse('0a0b0c0d0e');
+    }, /MAC address is too short$/);
+
+    t.end();
+});
+
+
+test('Extra characters in address', function (t) {
+    t.throws(function () {
+        macaddr.parse('1:e:39:d:e:f:0');
+    }, /too many octets in MAC address$/);
+
+    t.throws(function () {
+        macaddr.parse('a:b:c:d:e:f:0:0');
+    }, /too many octets in MAC address$/);
+
+    t.throws(function () {
+        macaddr.parse('a:b:c:00d:e:f');
+    }, /too many hexadecimal digits in "00d"$/);
+
+    t.end();
+});
+
+
+test('Whitespace characters', function (t) {
+    t.throws(function () {
+        macaddr.parse(' 90:b8:d0:81:91:30');
+    }, /unrecognized character " "$/, 'whitespace before address');
+
+    t.throws(function () {
+        macaddr.parse('90:b8:d0:81:91:30 ');
+    }, /unrecognized character " "$/, 'whitespace after address');
+
+    t.throws(function () {
+        macaddr.parse('90:b8: d0:81:91:30');
+    }, /unrecognized character " "$/, 'whitespace inside address');
+
+    t.throws(function () {
+        macaddr.parse('90:b8:\td0:81:91:30');
+    }, /unrecognized character "\\t"$/, 'whitespace inside address');
+
+    t.throws(function () {
+        macaddr.parse('90:b8:d0 :81:91:30');
+    }, /unrecognized character " "$/, 'whitespace inside address');
+
+    t.end();
+});
-- 
2.21.0

