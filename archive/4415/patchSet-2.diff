From f48867686146b6e707d2e5c2828f1a2f0c2dbe9b Mon Sep 17 00:00:00 2001
From: Cody Peter Mello <cody.mello@joyent.com>
Date: Fri, 15 Jun 2018 03:16:09 +0000
Subject: [PATCH] MORAY-477 Float values put into "number" fields get truncated
 to integers (relax validation) Reviewed by: Dan McDonald <danmcd@joyent.com>
 Approved by: Alex Wilson <alex.wilson@joyent.com>

---
 lib/objects/common.js | 53 +++++++++++++++++++++++++++++++------------
 1 file changed, 38 insertions(+), 15 deletions(-)

diff --git a/lib/objects/common.js b/lib/objects/common.js
index 20e953a..820922e 100644
--- a/lib/objects/common.js
+++ b/lib/objects/common.js
@@ -151,17 +151,18 @@ function parseISO8601(value) {
     return (new Date(value)).toISOString();
 }
 
+/*
+ * We don't do any error checking here, since some Moray consumers have
+ * ended up accidentally relying on the value getting turned into NaN
+ * here, and then NULL when sent to Postgres.
+ */
 function parseNumber(value) {
     var v = value;
 
-    if (typeof (v) === 'string') {
+    if (typeof (v) !== 'number') {
         v = parseFloat(value, 10);
     }
 
-    if (typeof (v) !== 'number' || Number.isNaN(v)) {
-        throw new VError('invalid number: %j', value);
-    }
-
     return v;
 }
 
@@ -193,6 +194,23 @@ function parseNumericRange(value) {
     }
 }
 
+function parseUUID(value) {
+    if (UUID_RE.test(value)) {
+        return value;
+    } else {
+        throw new VError('invalid uuid: %j', value);
+    }
+}
+
+function parseBoolean(value) {
+    var ret = value.toString().toUpperCase();
+    if (ret !== 'TRUE' && ret !== 'FALSE') {
+        throw new VError('invalid boolean: %j', value);
+    }
+
+    return ret;
+}
+
 function _parse(val, filter, type) {
     var array = TYPES[type].array;
     var value;
@@ -200,8 +218,8 @@ function _parse(val, filter, type) {
     switch (type) {
     case '[boolean]':
     case 'boolean':
-        filter.value = /^true$/i.test(val);
-        value = filter.value.toString().toUpperCase();
+        value = parseBoolean(val);
+        filter.value = (value === 'TRUE');
         break;
 
     case '[date]':
@@ -243,6 +261,11 @@ function _parse(val, filter, type) {
         value = filter.value.toString();
         break;
 
+    case '[uuid]':
+    case 'uuid':
+        value = parseUUID(val);
+        break;
+
     case '[string]':
     case 'string':
         value = val;
@@ -569,9 +592,10 @@ function _mapType(type, value, key, isArray) {
 
     switch (type) {
     case 'boolean':
-        ret = value.toString().toUpperCase();
-        if (ret !== 'TRUE' && ret !== 'FALSE') {
-            throw new InvalidIndexTypeError(key, type);
+        try {
+            ret = parseBoolean(value);
+        } catch (e) {
+            throw new InvalidIndexTypeError(e, key, type);
         }
         break;
 
@@ -645,10 +669,10 @@ function _mapType(type, value, key, isArray) {
         break;
 
     case 'uuid':
-        if (UUID_RE.test(value)) {
-            ret = value;
-        } else {
-            throw new InvalidIndexTypeError(key, type);
+        try {
+            ret = parseUUID(value);
+        } catch (e) {
+            throw new InvalidIndexTypeError(e, key, type);
         }
         break;
 
@@ -768,7 +792,6 @@ function _matchTypeIP(filter) {
     if (filter.type === 'ge' ||
         filter.type === 'le' ||
         filter.type === 'equal') {
-        filter.value = ip6addr.parse(filter.value);
         filter.matches = matchesIP.bind(filter);
     }
 }
-- 
2.21.0

