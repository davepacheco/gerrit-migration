From cd9bc999de833675ff504401454ed3ba05ac9fe5 Mon Sep 17 00:00:00 2001
From: John Levon <john.levon@joyent.com>
Date: Wed, 4 Apr 2018 13:43:46 +0000
Subject: [PATCH] OS-6760 bhyve passthru devices should use physical path

---
 usr/src/cmd/zoneadmd/vplat.c       |  10 ++-
 usr/src/cmd/zoneadmd/zoneadmd.c    | 103 ++++++++++++++++++++++++++---
 usr/src/cmd/zoneadmd/zoneadmd.h    |   6 ++
 usr/src/uts/common/os/modsysfile.c |  26 ++++++--
 4 files changed, 125 insertions(+), 20 deletions(-)

diff --git a/usr/src/cmd/zoneadmd/vplat.c b/usr/src/cmd/zoneadmd/vplat.c
index d67e8d824f..aef7076c1c 100644
--- a/usr/src/cmd/zoneadmd/vplat.c
+++ b/usr/src/cmd/zoneadmd/vplat.c
@@ -1198,9 +1198,15 @@ mount_one_dev(zlog_t *zlogp, char *devpath, zone_mnt_t mount_cmd)
 		goto cleanup;
 	}
 	while (zonecfg_getdevent(snap_hndl, &ztab) == Z_OK) {
-		if (di_prof_add_dev(prof, ztab.zone_dev_match)) {
+		char path[MAXPATHLEN];
+
+		if ((err = resolve_device_match(zlogp, &ztab,
+		    path, sizeof (path))) != Z_OK)
+			goto cleanup;
+
+		if (di_prof_add_dev(prof, path)) {
 			zerror(zlogp, B_TRUE, "failed to add "
-			    "user-specified device");
+			    "user-specified device '%s'", path);
 			goto cleanup;
 		}
 	}
diff --git a/usr/src/cmd/zoneadmd/zoneadmd.c b/usr/src/cmd/zoneadmd/zoneadmd.c
index 60af30d40b..a1a44ede1f 100644
--- a/usr/src/cmd/zoneadmd/zoneadmd.c
+++ b/usr/src/cmd/zoneadmd/zoneadmd.c
@@ -104,6 +104,7 @@
 #include <libdladm.h>
 #include <sys/dls_mgmt.h>
 #include <libscf.h>
+#include <glob.h>
 
 #include <libzonecfg.h>
 #include <zonestat_impl.h>
@@ -815,6 +816,84 @@ set_zonecfg_env(char *rsrc, char *attr, char *name, char *val)
 	(void) setenv(nm, val, 1);
 }
 
+/*
+ * Resolve a device:match value to a path.  This is only different for passthru
+ * devices, where we expect the match property to be a /devices/... path, and
+ * configured for PPT already.
+ */
+int
+resolve_device_match(zlog_t *zlogp, struct zone_devtab *dtab,
+    char *path, size_t len)
+{
+	struct zone_res_attrtab *rap;
+	char devpath[MAXPATHLEN];
+	char rpath[MAXPATHLEN];
+	glob_t gl;
+	char *c;
+	int res;
+
+	for (rap = dtab->zone_dev_attrp; rap != NULL;
+	    rap = rap->zone_res_attr_next) {
+		if (strcmp(rap->zone_res_attr_name, "model") == 0 &&
+		    strcmp(rap->zone_res_attr_value, "passthru") == 0)
+			break;
+	}
+
+	if (rap == NULL) {
+		if (strlcpy(path, dtab->zone_dev_match, len) >= len)
+			return (Z_INVAL);
+		return (Z_OK);
+	}
+
+	if (strncmp(dtab->zone_dev_match, "/devices",
+	    strlen("/devices")) != 0) {
+		zerror(zlogp, B_FALSE, "invalid passthru match value '%s'",
+		    dtab->zone_dev_match);
+		return (Z_INVAL);
+	}
+
+	(void) strlcpy(devpath, dtab->zone_dev_match, sizeof (devpath));
+
+	/*
+	 * Account for ":ppt" minor name.
+	 */
+	if ((c = strrchr(devpath, ':')) == NULL || strcmp(c, ":ppt") != 0)
+		(void) strlcat(devpath, ":ppt", sizeof (devpath));
+
+	if (glob("/dev/ppt*", GLOB_KEEPSTAT, NULL, &gl) != 0) {
+		zerror(zlogp, B_TRUE, "couldn't glob");
+		return (Z_INVAL);
+	}
+
+	for (size_t i = 0; i < gl.gl_pathc; i++) {
+		if (!S_ISLNK(gl.gl_statv[i]->st_mode))
+			continue;
+
+		if (realpath(gl.gl_pathv[i], rpath) == NULL) {
+			zerror(zlogp, B_TRUE, "couldn't resolve %s",
+			    gl.gl_pathv[i]);
+			res = Z_INVAL;
+			goto out;
+		}
+
+		if (strcmp(devpath, rpath) == 0) {
+			if (strlcpy(path, gl.gl_pathv[i], len) >= len)
+				res = Z_INVAL;
+			else
+				res = Z_OK;
+			goto out;
+		}
+	}
+
+	zerror(zlogp, B_FALSE, "couldn't find matching /dev/ppt* device for "
+	    "device path %s\n", dtab->zone_dev_match);
+	res = Z_NO_ENTRY;
+
+out:
+	globfree(&gl);
+	return (res);
+}
+
 /*
  * Export various zonecfg properties into environment for the boot and state
  * change hooks.
@@ -832,7 +911,7 @@ set_zonecfg_env(char *rsrc, char *attr, char *name, char *val)
  * SmartOS.
  */
 static int
-setup_subproc_env(boolean_t debug)
+setup_subproc_env(zlog_t *zlogp, boolean_t debug)
 {
 	int res;
 	struct zone_nwiftab ntab;
@@ -909,17 +988,13 @@ setup_subproc_env(boolean_t debug)
 
 	dev_resources[0] = '\0';
 	while (zonecfg_getdevent(snap_hndl, &dtab) == Z_OK) {
+		char *match = dtab.zone_dev_match;
 		struct zone_res_attrtab *rap;
-		char *match;
-
-		match = dtab.zone_dev_match;
+		char path[MAXPATHLEN];
 
-		/*
-		 * In the environment variable name, the value of match will be
-		 * mangled.  Thus, we store the value of match in a "path"
-		 * environment variable.
-		 */
-		set_zonecfg_env(RSRC_DEV, match, "path", match);
+		res = resolve_device_match(zlogp, &dtab, path, sizeof (path));
+		if (res != Z_OK)
+			goto done;
 
 		for (rap = dtab.zone_dev_attrp; rap != NULL;
 		    rap = rap->zone_res_attr_next) {
@@ -927,6 +1002,12 @@ setup_subproc_env(boolean_t debug)
 			    rap->zone_res_attr_name, rap->zone_res_attr_value);
 		}
 
+		/*
+		 * Even if not modified, the match path will be mangled in the
+		 * environment variable name, so we always store the value here.
+		 */
+		set_zonecfg_env(RSRC_DEV, match, "path", path);
+
 		/*
 		 * _ZONECFG_device_resources will contain a space separated list
 		 * of devices that have _ZONECFG_device_<device>* environment
@@ -1008,7 +1089,7 @@ do_subproc(zlog_t *zlogp, char *cmdbuf, char **retstr, boolean_t debug)
 		inbuf = buf;
 	}
 
-	if (setup_subproc_env(debug) != Z_OK) {
+	if (setup_subproc_env(zlogp, debug) != Z_OK) {
 		zerror(zlogp, B_FALSE, "failed to setup environment");
 		return (-1);
 	}
diff --git a/usr/src/cmd/zoneadmd/zoneadmd.h b/usr/src/cmd/zoneadmd/zoneadmd.h
index 0a347e9b82..25909a8441 100644
--- a/usr/src/cmd/zoneadmd/zoneadmd.h
+++ b/usr/src/cmd/zoneadmd/zoneadmd.h
@@ -175,6 +175,12 @@ extern int init_template(void);
  */
 extern int do_subproc(zlog_t *, char *, char **, boolean_t);
 
+/*
+ * Resource handling.
+ */
+extern int resolve_device_match(zlog_t *, struct zone_devtab *,
+    char *, size_t);
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/usr/src/uts/common/os/modsysfile.c b/usr/src/uts/common/os/modsysfile.c
index 8dca86880f..3e8a21718a 100644
--- a/usr/src/uts/common/os/modsysfile.c
+++ b/usr/src/uts/common/os/modsysfile.c
@@ -2136,25 +2136,22 @@ hwc_parse_now(char *fname, struct par_list **pl, ddi_prop_t **props)
 	return (0);	/* always return success */
 }
 
-void
-make_aliases(struct bind **bhash)
+static void
+parse_aliases(struct bind **bhash, struct _buf *file)
 {
 	enum {
 		AL_NEW, AL_DRVNAME, AL_DRVNAME_COMMA, AL_ALIAS, AL_ALIAS_COMMA
 	} state;
 
-	struct _buf *file;
 	char tokbuf[MAXPATHLEN];
 	char drvbuf[MAXPATHLEN];
 	token_t token;
 	major_t major;
 	int done = 0;
+	// FIXME:
 	static char dupwarn[] = "!Driver alias \"%s\" conflicts with "
 	    "an existing driver name or alias.";
 
-	if ((file = kobj_open_file(dafile)) == (struct _buf *)-1)
-		return;
-
 	state = AL_NEW;
 	major = DDI_MAJOR_T_NONE;
 	while (!done) {
@@ -2239,8 +2236,23 @@ make_aliases(struct bind **bhash)
 			kobj_file_err(CE_WARN, file, tok_err, tokbuf);
 		}
 	}
+}
 
-	kobj_close_file(file);
+void
+make_aliases(struct bind **bhash)
+{
+	char pptfile[] = "/etc/ppt_aliases";
+	struct _buf *file;
+
+	if ((file = kobj_open_file(pptfile)) != (struct _buf *)-1) {
+		parse_aliases(bhash, file);
+		kobj_close_file(file);
+	}
+
+	if ((file = kobj_open_file(dafile)) != (struct _buf *)-1) {
+		parse_aliases(bhash, file);
+		kobj_close_file(file);
+	}
 }
 
 
-- 
2.21.0

