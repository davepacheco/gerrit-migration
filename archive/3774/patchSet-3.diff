From 4e8c2a8b72a5428db284e09aede87d83c836ba2c Mon Sep 17 00:00:00 2001
From: John Levon <john.levon@joyent.com>
Date: Mon, 9 Apr 2018 15:50:46 +0000
Subject: [PATCH] OS-6760 bhyve passthru devices should use physical path

---
 exception_lists/packaging                     |  20 +-
 manifest                                      |  26 +-
 usr/src/Makefile.lint                         |   2 +
 usr/src/Makefile.master                       |   1 +
 usr/src/cmd/Makefile                          |   3 +-
 .../cmd/cmd-inet/usr.bin/netstat/netstat.c    |  97 ++-
 usr/src/cmd/cmd-inet/usr.bin/pppd/pppd.h      |  15 +-
 usr/src/cmd/cmd-inet/usr.bin/pppdump/zlib.c   |  14 +
 usr/src/cmd/cmd-inet/usr.bin/rdist/gram.y     |   2 +-
 usr/src/cmd/cmd-inet/usr.bin/rdist/server.c   |   3 +-
 .../cmd/cmd-inet/usr.lib/mdnsd/DNSCommon.c    |   4 +-
 .../cmd/cmd-inet/usr.lib/mdnsd/DNSDigest.c    |   7 +
 usr/src/cmd/cmd-inet/usr.lib/mdnsd/uDNS.c     |   3 +-
 .../cmd/fm/eversholt/eftinfo/common/eftinfo.c |   3 +-
 usr/src/cmd/fm/eversholt/esc/common/escmain.c |   3 +-
 .../cmd/fm/modules/common/eversholt/eval.c    |   1 +
 .../sensor-transport/sensor_transport.c       |  92 +-
 usr/src/cmd/fs.d/smbclnt/smbutil/Makefile     |  25 +-
 usr/src/cmd/fs.d/smbclnt/smbutil/common.h     |  13 +-
 usr/src/cmd/fs.d/smbclnt/smbutil/info.c       | 212 +++++
 usr/src/cmd/fs.d/smbclnt/smbutil/shares_rap.c | 143 ++++
 usr/src/cmd/fs.d/smbclnt/smbutil/shares_rpc.c |  83 ++
 usr/src/cmd/fs.d/smbclnt/smbutil/smbutil.c    |  14 +-
 usr/src/cmd/fs.d/smbclnt/smbutil/srvsvc1.ndl  | 177 ++++
 .../cmd/fs.d/smbclnt/smbutil/srvsvc1_clnt.c   | 138 +++
 .../cmd/fs.d/smbclnt/smbutil/srvsvc1_clnt.h   |  46 +
 usr/src/cmd/fs.d/smbclnt/smbutil/view.c       | 100 +--
 usr/src/cmd/ipf/tools/ip_fil.c                |   9 +-
 usr/src/cmd/ipf/tools/ipmon.c                 |  10 +-
 .../cmd/mdb/common/modules/genunix/memory.c   |  37 +-
 usr/src/cmd/mdb/common/modules/zfs/zfs.c      | 153 ++--
 usr/src/cmd/mdb/intel/amd64/Makefile          |   4 +-
 .../cmd/mdb/intel/amd64/vmm/amd64/Makefile    |  35 -
 usr/src/cmd/mdb/intel/amd64/vmm/vmm.c         | 237 ------
 usr/src/cmd/policykit/polkit-is-privileged.c  |   1 +
 usr/src/cmd/pools/poolstat/poolstat.c         |   2 +
 usr/src/cmd/pptadm/Makefile                   |  34 +
 usr/src/cmd/pptadm/pptadm.c                   | 218 +++++
 usr/src/cmd/refer/refer2.c                    |   4 +-
 usr/src/cmd/smbios/Makefile                   |   4 +
 usr/src/cmd/smbios/smbios.c                   |  26 +-
 usr/src/cmd/tbl/t4.c                          |   6 +-
 usr/src/cmd/tbl/t6.c                          |   4 +-
 usr/src/cmd/tbl/t7.c                          |   1 +
 usr/src/cmd/tbl/t8.c                          |   3 +-
 usr/src/cmd/tcpd/safe_finger.c                |  10 +-
 usr/src/cmd/tr/tr.c                           |   2 +-
 usr/src/cmd/tsol/updatehome/updatehome.c      |   1 +
 usr/src/cmd/ypcmd/ypupdated/openchild.c       |  29 +-
 usr/src/cmd/ypcmd/ypupdated/rpc.ypupdated.c   |  67 +-
 usr/src/cmd/zdb/zdb.c                         | 125 +--
 usr/src/cmd/zoneadmd/Makefile.com             |   2 +-
 usr/src/cmd/zoneadmd/vplat.c                  |  12 +-
 usr/src/cmd/zoneadmd/zoneadmd.c               |  75 +-
 usr/src/cmd/zoneadmd/zoneadmd.h               |   8 +-
 usr/src/cmd/ztest/ztest.c                     |   7 +
 usr/src/common/bzip2/decompress.c             |   1 +
 usr/src/common/smbsrv/smb_door_legacy.c       |   2 +-
 usr/src/common/smbsrv/smb_token_xdr.c         |   2 +-
 usr/src/common/zfs/zfeature_common.c          |   6 +
 usr/src/common/zfs/zfeature_common.h          |   1 +
 usr/src/head/regexp.h                         |   2 +
 usr/src/lib/Makefile                          |   8 +-
 usr/src/lib/brand/bhyve/zone/boot.c           | 107 ++-
 usr/src/lib/fm/topo/libtopo/common/libtopo.h  |   8 +
 .../lib/fm/topo/libtopo/common/topo_method.c  |  59 +-
 .../lib/fm/topo/libtopo/common/topo_method.h  |  12 +-
 ...yent-Compute-Platform-3301-hc-topology.xml | 251 ++++++
 ...pute-Platform-330x-chassis-hc-topology.xml |  43 +
 ...-Compute-Platform-330x-fan-hc-topology.xml | 127 +++
 .../Makefile                                  |  49 ++
 usr/src/lib/fm/topo/maps/Makefile             |   1 +
 .../common/fac_prov_ipmi/fac_prov_ipmi.c      | 216 ++++-
 usr/src/lib/libipmi/common/ipmi_sdr.c         |  52 +-
 usr/src/lib/libipmi/common/ipmi_sensor.c      |  29 +-
 usr/src/lib/libipmi/common/libipmi.h          |  25 +-
 usr/src/lib/libipmi/common/mapfile-vers       |   4 +-
 usr/src/lib/libmlrpc/Makefile                 |  65 ++
 .../lib/{smbsrv => }/libmlrpc/Makefile.com    |  41 +-
 .../sparcv9 => libmlrpc/amd64}/Makefile       |   6 +-
 .../{smbsrv => }/libmlrpc/common/libmlrpc.h   |  53 +-
 .../{smbsrv => }/libmlrpc/common/llib-lmlrpc  |   6 +-
 .../{smbsrv => }/libmlrpc/common/mapfile-vers |  89 +-
 usr/src/lib/libmlrpc/common/mlrpc_clh.c       | 578 +++++++++++++
 .../smbsrv => lib/libmlrpc/common}/ndr.h      |  15 +-
 .../{smbsrv => }/libmlrpc/common/ndr_client.c |  18 +-
 .../{smbsrv => }/libmlrpc/common/ndr_heap.c   |  83 +-
 .../libmlrpc/common/ndr_marshal.c             |   4 +-
 .../{smbsrv => }/libmlrpc/common/ndr_ops.c    |   3 +-
 .../libmlrpc/common/ndr_process.c             | 212 ++---
 .../{smbsrv => }/libmlrpc/common/ndr_server.c |  40 +-
 .../{smbsrv => }/libmlrpc/common/ndr_svc.c    |   3 +-
 usr/src/lib/libmlrpc/common/ndr_wchar.c       | 162 ++++
 usr/src/lib/libmlrpc/common/ndr_wchar.h       |  46 +
 .../ndl => lib/libmlrpc/common}/ndrtypes.ndl  |  43 +-
 .../ndl => lib/libmlrpc/common}/rpcpdu.ndl    |   0
 .../libmlrpc/sparc => libmlrpc/i386}/Makefile |   4 -
 .../libmlrpc/i386 => libmlrpc/sparc}/Makefile |   4 -
 .../amd64 => libmlrpc/sparcv9}/Makefile       |   6 +-
 usr/src/lib/libmvec/common/__vcos.c           |   1 +
 usr/src/lib/libmvec/common/__vsin.c           |   1 +
 usr/src/lib/libppt/Makefile                   |  44 +
 usr/src/lib/libppt/Makefile.com               |  46 +
 usr/src/lib/libppt/amd64/Makefile             |  19 +
 usr/src/lib/libppt/common/libppt.c            | 513 +++++++++++
 usr/src/lib/libppt/common/libppt.h            |  36 +
 usr/src/lib/libppt/common/llib-lppt           |  19 +
 usr/src/lib/libppt/common/mapfile-vers        |  40 +
 .../amd64/vmm => lib/libppt/i386}/Makefile    |   9 +-
 usr/src/lib/libppt/sparc/Makefile             |  18 +
 usr/src/lib/libppt/sparcv9/Makefile           |  19 +
 usr/src/lib/libsmbfs/Makefile.com             |   1 -
 .../lib/libsmbfs/netsmb/smb_netshareenum.h    |  18 -
 usr/src/lib/libsmbfs/netsmb/smbfs_api.h       |   4 +-
 usr/src/lib/libsmbfs/smb/file.c               |   4 +-
 usr/src/lib/libsmbfs/smb/llib-lsmbfs          |   1 -
 usr/src/lib/libsmbfs/smb/mapfile-vers         |   1 -
 usr/src/lib/libsmbfs/smb/netshareenum.c       | 378 ---------
 usr/src/lib/libxcurses/src/libc/xcurses/slk.c |  55 +-
 usr/src/lib/libzfs/common/libzfs_dataset.c    |  80 +-
 usr/src/lib/libzfs/common/libzfs_util.c       |  33 +-
 usr/src/lib/libzpool/common/llib-lzpool       |   1 +
 usr/src/lib/pam_modules/tsol_acct/tsol_acct.c |   6 +-
 usr/src/lib/smbsrv/Makefile                   |   4 +-
 usr/src/lib/smbsrv/Makefile.targ              |   7 +-
 usr/src/lib/smbsrv/libmlrpc/Makefile          |  30 -
 .../lib/smbsrv/libmlsvc/common/dssetup_clnt.c |   2 +-
 .../lib/smbsrv/libmlsvc/common/dssetup_svc.c  |   3 +-
 .../lib/smbsrv/libmlsvc/common/eventlog_svc.c |   3 +-
 usr/src/lib/smbsrv/libmlsvc/common/libmlsvc.h |  55 +-
 .../lib/smbsrv/libmlsvc/common/lsar_clnt.c    |  46 +-
 usr/src/lib/smbsrv/libmlsvc/common/lsar_svc.c |   2 +-
 usr/src/lib/smbsrv/libmlsvc/common/mlsvc.h    |   4 +-
 .../lib/smbsrv/libmlsvc/common/mlsvc_client.c | 534 ++----------
 .../lib/smbsrv/libmlsvc/common/mlsvc_init.c   |   2 +-
 .../lib/smbsrv/libmlsvc/common/mlsvc_util.c   |  40 +
 .../lib/smbsrv/libmlsvc/common/msgsvc_svc.c   |   3 +-
 .../lib/smbsrv/libmlsvc/common/netr_auth.c    |   9 +-
 .../lib/smbsrv/libmlsvc/common/netr_logon.c   |   2 +-
 .../lib/smbsrv/libmlsvc/common/samr_clnt.c    |   2 +-
 usr/src/lib/smbsrv/libmlsvc/common/samr_svc.c |   2 +-
 .../lib/smbsrv/libmlsvc/common/spoolss_svc.c  |   2 +-
 .../lib/smbsrv/libmlsvc/common/srvsvc_clnt.c  | 120 +--
 usr/src/lib/smbsrv/libsmb/common/libsmb.h     |   7 +-
 .../lib/smbsrv/libsmb/common/smb_doorclnt.c   |   2 +-
 usr/src/man/man1m/netstat.1m                  |  20 +-
 usr/src/man/man1m/smbios.1m                   |  16 +-
 usr/src/man/man1m/zfs.1m                      |  44 +-
 usr/src/man/man5/zpool-features.5             |  29 +-
 usr/src/man/man9e/mac.9e                      |  26 +-
 .../pkg/manifests/driver-storage-mpt_sas.mf   |  21 +-
 usr/src/pkg/manifests/driver-storage-nvme.mf  |   2 +-
 .../pkg/manifests/service-fault-management.mf |  12 +
 .../pkg/manifests/service-file-system-smb.mf  |   5 -
 usr/src/pkg/manifests/system-bhyve.mf         |  17 +-
 .../pkg/manifests/system-file-system-smb.mf   |   1 +
 usr/src/pkg/manifests/system-test-zfstest.mf  |   9 +
 usr/src/test/zfs-tests/runfiles/delphix.run   |   5 +-
 usr/src/test/zfs-tests/runfiles/omnios.run    |   5 +-
 .../test/zfs-tests/runfiles/openindiana.run   |   5 +-
 .../import_rewind_config_changed.ksh          |   7 +-
 .../checkpoint_discard_busy.ksh               |   6 +-
 .../reservation/reservation_019_pos.sh        |  65 ++
 .../reservation/reservation_020_pos.sh        |  66 ++
 .../reservation/reservation_021_neg.sh        |  74 ++
 .../reservation/reservation_022_pos.sh        |  84 ++
 .../tests/functional/slog/slog_014_pos.ksh    |  14 +-
 usr/src/tools/ndrgen/ndrgen.sh                | 126 ++-
 usr/src/tools/quick/make-smbclnt              | 304 +++++++
 usr/src/tools/quick/make-smbsrv               |   8 +-
 usr/src/tools/scripts/bldenv.sh               |   3 +
 usr/src/uts/common/avs/ns/rdc/rdc_diskq.c     |   6 +-
 usr/src/uts/common/c2/audit_start.c           |   2 +-
 usr/src/uts/common/fs/fdbuffer.c              |   3 +-
 usr/src/uts/common/fs/zfs/metaslab.c          | 570 +++++++++----
 usr/src/uts/common/fs/zfs/range_tree.c        |   2 +-
 usr/src/uts/common/fs/zfs/spa.c               |  37 +-
 usr/src/uts/common/fs/zfs/spa_checkpoint.c    |  50 +-
 usr/src/uts/common/fs/zfs/spa_misc.c          |  28 +-
 usr/src/uts/common/fs/zfs/space_map.c         | 796 +++++++++++++-----
 usr/src/uts/common/fs/zfs/sys/metaslab.h      |  18 +-
 usr/src/uts/common/fs/zfs/sys/metaslab_impl.h |  79 +-
 usr/src/uts/common/fs/zfs/sys/spa.h           |  12 +-
 usr/src/uts/common/fs/zfs/sys/spa_impl.h      |  12 +-
 usr/src/uts/common/fs/zfs/sys/space_map.h     | 114 ++-
 usr/src/uts/common/fs/zfs/sys/vdev_impl.h     |   3 +-
 usr/src/uts/common/fs/zfs/sys/zio.h           |   7 +-
 usr/src/uts/common/fs/zfs/vdev.c              |   6 +-
 usr/src/uts/common/fs/zfs/vdev_indirect.c     |   2 +-
 .../uts/common/fs/zfs/vdev_indirect_mapping.c |   9 +-
 usr/src/uts/common/fs/zfs/vdev_queue.c        |  11 +-
 usr/src/uts/common/fs/zfs/vdev_removal.c      |   9 +-
 usr/src/uts/common/fs/zfs/zil.c               |   8 +-
 usr/src/uts/common/fs/zfs/zio.c               |  86 +-
 usr/src/uts/common/inet/ip/ip.c               |  34 +-
 usr/src/uts/common/inet/ip/ip6.c              |   8 +-
 usr/src/uts/common/inet/ip/ip6_output.c       |  13 +-
 usr/src/uts/common/inet/ip/ip_output.c        |  10 +-
 usr/src/uts/common/inet/ipf/ip_log.c          |   9 +-
 .../uts/common/inet/ipf/netinet/ip_compat.h   |  13 +-
 usr/src/uts/common/inet/ipf/netinet/ip_fil.h  |   9 +-
 usr/src/uts/common/inet/ipf/netinet/ip_nat.h  |   9 +-
 .../uts/common/inet/ipf/netinet/ip_proxy.h    |  11 +-
 usr/src/uts/common/inet/ipf/opts.h            |   9 +-
 usr/src/uts/common/inet/sctp/sctp_conn.c      |   2 +-
 usr/src/uts/common/io/audio/impl/audio_sun.c  |   1 -
 usr/src/uts/common/io/ib/ibnex/ibnex_ioctl.c  |   4 +-
 usr/src/uts/common/io/mii/mii.c               |   4 +-
 usr/src/uts/common/io/nxge/npi/npi_mac.c      |   4 +-
 usr/src/uts/common/io/nxge/npi/npi_vir.c      |   3 +-
 usr/src/uts/common/io/nxge/nxge_zcp.c         |   3 +-
 usr/src/uts/common/io/qede/qede_gld.c         |  11 +-
 .../io/scsi/adapters/mpt_sas/mptsas_impl.c    |   4 +-
 usr/src/uts/common/os/modsysfile.c            |  27 +-
 usr/src/uts/common/smb/Makefile               |   4 +-
 usr/src/uts/common/{smbsrv => smb}/wintypes.h |  37 +-
 usr/src/uts/common/smbsrv/Makefile            |   6 +-
 usr/src/uts/common/smbsrv/ndl/dssetup.ndl     |   4 +-
 usr/src/uts/common/smbsrv/ndl/eventlog.ndl    |   4 +-
 usr/src/uts/common/smbsrv/ndl/llsrpc.ndl      |   4 +-
 usr/src/uts/common/smbsrv/ndl/lsarpc.ndl      |   3 +-
 usr/src/uts/common/smbsrv/ndl/msgsvc.ndl      |   4 +-
 usr/src/uts/common/smbsrv/ndl/netdfs.ndl      |   4 +-
 usr/src/uts/common/smbsrv/ndl/netlogon.ndl    |   2 +-
 usr/src/uts/common/smbsrv/ndl/samrpc.ndl      |   4 +-
 usr/src/uts/common/smbsrv/ndl/spoolss.ndl     |   3 +-
 usr/src/uts/common/smbsrv/ndl/srvsvc.ndl      |   4 +-
 usr/src/uts/common/smbsrv/ndl/svcctl.ndl      |   4 +-
 usr/src/uts/common/smbsrv/ndl/winreg.ndl      |   4 +-
 usr/src/uts/common/smbsrv/netrauth.h          |   2 +-
 usr/src/uts/common/smbsrv/smb_door.h          |   2 +-
 usr/src/uts/common/smbsrv/smb_privilege.h     |   2 +-
 usr/src/uts/common/smbsrv/smb_share.h         |   4 +-
 usr/src/uts/common/smbsrv/smb_sid.h           |   2 +-
 usr/src/uts/common/smbsrv/smb_xdr.h           |   3 +-
 usr/src/uts/common/sys/dlpi.h                 |   7 +-
 usr/src/uts/common/sys/pci.h                  |   1 +
 usr/src/uts/common/sys/pci_impl.h             |   2 +-
 .../adapters/mpt_sas/mpi/THIRDPARTYLICENSE    |   7 +-
 .../mpt_sas/mpi/THIRDPARTYLICENSE.descrip     |   2 +-
 usr/src/uts/common/sys/vnode.h                |   3 +-
 usr/src/uts/common/syscall/auditsys.c         |   1 +
 usr/src/uts/common/syscall/uadmin.c           |   3 +-
 usr/src/uts/common/vm/page_lock.c             |  10 +-
 usr/src/uts/common/vm/page_retire.c           |   7 +-
 usr/src/uts/common/vm/seg_kmem.c              |  83 +-
 usr/src/uts/common/vm/seg_kmem.h              |  18 +-
 usr/src/uts/i86pc/dboot/dboot_startkern.c     |   8 +-
 usr/src/uts/i86pc/io/viona/viona.c            |  43 +-
 usr/src/uts/i86pc/io/vmm/amd/svm.c            |  15 +-
 usr/src/uts/i86pc/io/vmm/intel/vmx.c          |  41 +
 usr/src/uts/i86pc/io/vmm/intel/vmx.h          |   3 +-
 usr/src/uts/i86pc/io/vmm/intel/vmx_support.s  |  21 +
 usr/src/uts/i86pc/io/vmm/io/ppt.c             |  53 +-
 usr/src/uts/i86pc/io/vmm/vm/vm_glue.h         |   6 +-
 usr/src/uts/i86pc/io/vmm/vmm.c                | 118 ++-
 usr/src/uts/i86pc/io/vmm/vmm_sol_dev.c        | 185 +---
 usr/src/uts/i86pc/io/vmm/vmm_sol_vm.c         |  40 +-
 usr/src/uts/i86pc/os/ddi_impl.c               |   5 +-
 usr/src/uts/i86pc/os/intr.c                   |  20 +-
 usr/src/uts/i86pc/os/pc_hvm.c                 |  12 +-
 usr/src/uts/i86pc/os/startup.c                | 213 ++---
 usr/src/uts/i86pc/sys/machparam.h             | 190 ++---
 usr/src/uts/i86pc/sys/vmm.h                   |   9 +
 usr/src/uts/i86pc/sys/vmm_dev.h               |   5 -
 usr/src/uts/i86pc/sys/vmm_impl.h              |  33 -
 usr/src/uts/i86pc/vm/seg_vmm.c                |   7 +-
 usr/src/uts/intel/io/dnet/dnet.c              |   1 +
 usr/src/uts/intel/io/pci/pci_boot.c           |  47 +-
 usr/src/uts/intel/io/pci/pci_pci.c            |  11 +-
 usr/src/uts/sun4/os/startup.c                 |   5 +-
 271 files changed, 7906 insertions(+), 3554 deletions(-)
 create mode 100644 usr/src/cmd/fs.d/smbclnt/smbutil/info.c
 create mode 100644 usr/src/cmd/fs.d/smbclnt/smbutil/shares_rap.c
 create mode 100644 usr/src/cmd/fs.d/smbclnt/smbutil/shares_rpc.c
 create mode 100644 usr/src/cmd/fs.d/smbclnt/smbutil/srvsvc1.ndl
 create mode 100644 usr/src/cmd/fs.d/smbclnt/smbutil/srvsvc1_clnt.c
 create mode 100644 usr/src/cmd/fs.d/smbclnt/smbutil/srvsvc1_clnt.h
 delete mode 100644 usr/src/cmd/mdb/intel/amd64/vmm/amd64/Makefile
 delete mode 100644 usr/src/cmd/mdb/intel/amd64/vmm/vmm.c
 create mode 100644 usr/src/cmd/pptadm/Makefile
 create mode 100644 usr/src/cmd/pptadm/pptadm.c
 create mode 100644 usr/src/lib/fm/topo/maps/Joyent,Joyent-Compute-Platform-330x/Joyent-Compute-Platform-3301-hc-topology.xml
 create mode 100644 usr/src/lib/fm/topo/maps/Joyent,Joyent-Compute-Platform-330x/Joyent-Compute-Platform-330x-chassis-hc-topology.xml
 create mode 100644 usr/src/lib/fm/topo/maps/Joyent,Joyent-Compute-Platform-330x/Joyent-Compute-Platform-330x-fan-hc-topology.xml
 create mode 100644 usr/src/lib/fm/topo/maps/Joyent,Joyent-Compute-Platform-330x/Makefile
 create mode 100644 usr/src/lib/libmlrpc/Makefile
 rename usr/src/lib/{smbsrv => }/libmlrpc/Makefile.com (65%)
 rename usr/src/lib/{smbsrv/libmlrpc/sparcv9 => libmlrpc/amd64}/Makefile (90%)
 rename usr/src/lib/{smbsrv => }/libmlrpc/common/libmlrpc.h (92%)
 rename usr/src/lib/{smbsrv => }/libmlrpc/common/llib-lmlrpc (91%)
 rename usr/src/lib/{smbsrv => }/libmlrpc/common/mapfile-vers (62%)
 create mode 100644 usr/src/lib/libmlrpc/common/mlrpc_clh.c
 rename usr/src/{uts/common/smbsrv => lib/libmlrpc/common}/ndr.h (97%)
 rename usr/src/lib/{smbsrv => }/libmlrpc/common/ndr_client.c (95%)
 rename usr/src/lib/{smbsrv => }/libmlrpc/common/ndr_heap.c (84%)
 rename usr/src/lib/{smbsrv => }/libmlrpc/common/ndr_marshal.c (99%)
 rename usr/src/lib/{smbsrv => }/libmlrpc/common/ndr_ops.c (99%)
 rename usr/src/lib/{smbsrv => }/libmlrpc/common/ndr_process.c (94%)
 rename usr/src/lib/{smbsrv => }/libmlrpc/common/ndr_server.c (95%)
 rename usr/src/lib/{smbsrv => }/libmlrpc/common/ndr_svc.c (99%)
 create mode 100644 usr/src/lib/libmlrpc/common/ndr_wchar.c
 create mode 100644 usr/src/lib/libmlrpc/common/ndr_wchar.h
 rename usr/src/{uts/common/smbsrv/ndl => lib/libmlrpc/common}/ndrtypes.ndl (93%)
 rename usr/src/{uts/common/smbsrv/ndl => lib/libmlrpc/common}/rpcpdu.ndl (100%)
 rename usr/src/lib/{smbsrv/libmlrpc/sparc => libmlrpc/i386}/Makefile (94%)
 rename usr/src/lib/{smbsrv/libmlrpc/i386 => libmlrpc/sparc}/Makefile (94%)
 rename usr/src/lib/{smbsrv/libmlrpc/amd64 => libmlrpc/sparcv9}/Makefile (90%)
 create mode 100644 usr/src/lib/libppt/Makefile
 create mode 100644 usr/src/lib/libppt/Makefile.com
 create mode 100644 usr/src/lib/libppt/amd64/Makefile
 create mode 100644 usr/src/lib/libppt/common/libppt.c
 create mode 100644 usr/src/lib/libppt/common/libppt.h
 create mode 100644 usr/src/lib/libppt/common/llib-lppt
 create mode 100644 usr/src/lib/libppt/common/mapfile-vers
 rename usr/src/{cmd/mdb/intel/amd64/vmm => lib/libppt/i386}/Makefile (66%)
 create mode 100644 usr/src/lib/libppt/sparc/Makefile
 create mode 100644 usr/src/lib/libppt/sparcv9/Makefile
 delete mode 100644 usr/src/lib/libsmbfs/netsmb/smb_netshareenum.h
 delete mode 100644 usr/src/lib/libsmbfs/smb/netshareenum.c
 delete mode 100644 usr/src/lib/smbsrv/libmlrpc/Makefile
 create mode 100644 usr/src/test/zfs-tests/tests/functional/reservation/reservation_019_pos.sh
 create mode 100644 usr/src/test/zfs-tests/tests/functional/reservation/reservation_020_pos.sh
 create mode 100644 usr/src/test/zfs-tests/tests/functional/reservation/reservation_021_neg.sh
 create mode 100644 usr/src/test/zfs-tests/tests/functional/reservation/reservation_022_pos.sh
 create mode 100755 usr/src/tools/quick/make-smbclnt
 rename usr/src/uts/common/{smbsrv => smb}/wintypes.h (75%)

diff --git a/exception_lists/packaging b/exception_lists/packaging
index e59ee2560c..db9af7d7b1 100644
--- a/exception_lists/packaging
+++ b/exception_lists/packaging
@@ -740,10 +740,11 @@ usr/lib/smbsrv/bind-helper
 usr/lib/smbsrv/fksmbd
 usr/lib/smbsrv/libfksmbsrv.so
 usr/lib/smbsrv/libfksmbsrv.so.1
+usr/lib/smbsrv/libmlsvc.so
+usr/lib/smbsrv/libsmb.so
+usr/lib/smbsrv/libsmbns.so
 usr/lib/smbsrv/llib-lfksmbsrv
 usr/lib/smbsrv/llib-lfksmbsrv.ln
-usr/lib/smbsrv/llib-lmlrpc
-usr/lib/smbsrv/llib-lmlrpc.ln
 usr/lib/smbsrv/llib-lmlsvc
 usr/lib/smbsrv/llib-lmlsvc.ln
 usr/lib/smbsrv/llib-lsmb
@@ -788,7 +789,20 @@ usr/platform/i86hvm						i386
 #
 usr/include/sys/sdcard
 #
-# libsmbfs is private
+# libmlrpc is private (SMB client and server)
+#
+usr/include/libmlrpc
+usr/lib/libmlrpc.so
+usr/lib/amd64/libmlrpc.so		i386
+usr/lib/amd64/libmlrpc.so.2		i386
+usr/lib/sparcv9/libmlrpc.so		sparc
+usr/lib/sparcv9/libmlrpc.so.2		sparc
+usr/lib/llib-lmlrpc
+usr/lib/llib-lmlrpc.ln
+usr/lib/amd64/llib-lmlrpc.ln		i386
+usr/lib/sparcv9/llib-lmlrpc.ln		sparc
+#
+# libsmbfs is private (SMB client and server)
 #
 usr/include/netsmb
 usr/lib/libsmbfs.so
diff --git a/manifest b/manifest
index 212ec0b7dd..0f82fff1bb 100644
--- a/manifest
+++ b/manifest
@@ -3311,7 +3311,6 @@ f usr/include/smbsrv/alloc.h 0644 root bin
 f usr/include/smbsrv/cp_unicode.h 0644 root bin
 f usr/include/smbsrv/cp_usascii.h 0644 root bin
 f usr/include/smbsrv/hash_table.h 0644 root bin
-f usr/include/smbsrv/libmlrpc.h 0644 root bin
 f usr/include/smbsrv/libmlsvc.h 0644 root bin
 f usr/include/smbsrv/libsmb.h 0644 root bin
 f usr/include/smbsrv/libsmbns.h 0644 root bin
@@ -3325,17 +3324,14 @@ f usr/include/smbsrv/ndl/eventlog.ndl 0644 root bin
 f usr/include/smbsrv/ndl/llsrpc.ndl 0644 root bin
 f usr/include/smbsrv/ndl/lsarpc.ndl 0644 root bin
 f usr/include/smbsrv/ndl/msgsvc.ndl 0644 root bin
-f usr/include/smbsrv/ndl/ndrtypes.ndl 0644 root bin
 f usr/include/smbsrv/ndl/netdfs.ndl 0644 root bin
 f usr/include/smbsrv/ndl/netlogon.ndl 0644 root bin
-f usr/include/smbsrv/ndl/rpcpdu.ndl 0644 root bin
 f usr/include/smbsrv/ndl/samrpc.ndl 0644 root bin
 f usr/include/smbsrv/ndl/security.ndl 0644 root bin
 f usr/include/smbsrv/ndl/spoolss.ndl 0644 root bin
 f usr/include/smbsrv/ndl/srvsvc.ndl 0644 root bin
 f usr/include/smbsrv/ndl/svcctl.ndl 0644 root bin
 f usr/include/smbsrv/ndl/winreg.ndl 0644 root bin
-f usr/include/smbsrv/ndr.h 0644 root bin
 f usr/include/smbsrv/netbios.h 0644 root bin
 f usr/include/smbsrv/netrauth.h 0644 root bin
 f usr/include/smbsrv/nmpipes.h 0644 root bin
@@ -3363,7 +3359,6 @@ f usr/include/smbsrv/string.h 0644 root bin
 f usr/include/smbsrv/svrapi.h 0644 root bin
 f usr/include/smbsrv/winioctl.h 0644 root bin
 f usr/include/smbsrv/winsvc.h 0644 root bin
-f usr/include/smbsrv/wintypes.h 0644 root bin
 f usr/include/smhbaapi.h 0644 root bin
 f usr/include/spawn.h 0644 root bin
 f usr/include/stack_unwind.h 0644 root bin
@@ -4931,6 +4926,8 @@ f usr/lib/amd64/libpool.so.1 0755 root bin
 s usr/lib/amd64/libpool.so=libpool.so.1
 s usr/lib/amd64/libposix4.so.1=../../../lib/amd64/librt.so.1
 s usr/lib/amd64/libposix4.so=../../../lib/amd64/librt.so.1
+f usr/lib/amd64/libppt.so.1 0755 root bin
+s usr/lib/amd64/libppt.so=libppt.so.1
 s usr/lib/amd64/libproc.so.1=../../../lib/amd64/libproc.so.1
 s usr/lib/amd64/libproc.so=../../../lib/amd64/libproc.so.1
 f usr/lib/amd64/libproject.so.1 0755 root bin
@@ -6333,6 +6330,7 @@ f usr/lib/libmenu.so.1 0755 root bin
 s usr/lib/libmenu.so=libmenu.so.1
 f usr/lib/libmilter.so.1 0755 root bin
 s usr/lib/libmilter.so=libmilter.so.1
+f usr/lib/libmlrpc.so.2 0755 root bin
 s usr/lib/libmp.so.1=../../lib/libmp.so.1
 s usr/lib/libmp.so.2=../../lib/libmp.so.2
 s usr/lib/libmp.so=../../lib/libmp.so.2
@@ -6381,6 +6379,8 @@ s usr/lib/libposix4.so.1=../../lib/librt.so.1
 s usr/lib/libposix4.so=../../lib/librt.so.1
 f usr/lib/libpp.so.1 0755 root bin
 s usr/lib/libpp.so=libpp.so.1
+f usr/lib/libppt.so.1 0755 root bin
+s usr/lib/libppt.so=libppt.so.1
 s usr/lib/libproc.so.1=../../lib/libproc.so.1
 s usr/lib/libproc.so=../../lib/libproc.so.1
 f usr/lib/libproject.so.1 0755 root bin
@@ -9610,7 +9610,6 @@ f usr/lib/mdb/kvm/amd64/sv.so 0555 root sys
 f usr/lib/mdb/kvm/amd64/ufs.so 0555 root sys
 f usr/lib/mdb/kvm/amd64/uhci.so 0555 root sys
 f usr/lib/mdb/kvm/amd64/usba.so 0555 root sys
-f usr/lib/mdb/kvm/amd64/vmm.so 0555 root sys
 f usr/lib/mdb/kvm/amd64/xhci.so 0555 root sys
 f usr/lib/mdb/kvm/amd64/zfs.so 0555 root sys
 d usr/lib/mdb/proc 0755 root sys
@@ -10001,8 +10000,6 @@ f usr/lib/smbfs/smbiod 0555 root bin
 f usr/lib/smbfs/smbiod-svc 0555 root bin
 d usr/lib/smbsrv 0755 root bin
 d usr/lib/smbsrv/amd64 0755 root bin
-f usr/lib/smbsrv/amd64/libmlrpc.so.1 0755 root bin
-s usr/lib/smbsrv/amd64/libmlrpc.so=libmlrpc.so.1
 f usr/lib/smbsrv/amd64/libmlsvc.so.1 0755 root bin
 s usr/lib/smbsrv/amd64/libmlsvc.so=libmlsvc.so.1
 f usr/lib/smbsrv/amd64/libsmb.so.1 0755 root bin
@@ -10017,14 +10014,8 @@ f usr/lib/smbsrv/dtrace/smbd-pipesvc.d 0555 root bin
 f usr/lib/smbsrv/dtrace/smbnode.d 0555 root bin
 f usr/lib/smbsrv/dtrace/smbsrv.d 0555 root bin
 f usr/lib/smbsrv/dtrace/smbvfs.d 0555 root bin
-f usr/lib/smbsrv/libmlrpc.so.1 0755 root bin
-s usr/lib/smbsrv/libmlrpc.so=libmlrpc.so.1
 f usr/lib/smbsrv/libmlsvc.so.1 0755 root bin
-s usr/lib/smbsrv/libmlsvc.so=libmlsvc.so.1
-f usr/lib/smbsrv/libsmb.so.1 0755 root bin
-s usr/lib/smbsrv/libsmb.so=libsmb.so.1
 f usr/lib/smbsrv/libsmbns.so.1 0755 root bin
-s usr/lib/smbsrv/libsmbns.so=libsmbns.so.1
 f usr/lib/smbsrv/smbd 0755 root bin
 d usr/lib/smedia 0755 root bin
 d usr/lib/smedia/amd64 0755 root bin
@@ -10170,7 +10161,11 @@ d usr/platform/i86pc/lib/fm/topo 0755 root sys
 d usr/platform/i86pc/lib/fm/topo/maps 0755 root sys
 f usr/platform/i86pc/lib/fm/topo/maps/Joyent-Compute-Platform-1101-disk-hc-topology.xml 0444 root sys
 s usr/platform/i86pc/lib/fm/topo/maps/Joyent-Compute-Platform-3101-hc-topology.xml=./SSG-2028R-ACR24L-hc-topology.xml
-s usr/platform/i86pc/lib/fm/topo/maps/Joyent-Compute-Platform-3102-hc-topology.xml=./SSG-2028R-ACR24L-hc-topology.xml 
+s usr/platform/i86pc/lib/fm/topo/maps/Joyent-Compute-Platform-3102-hc-topology.xml=./SSG-2028R-ACR24L-hc-topology.xml
+f usr/platform/i86pc/lib/fm/topo/maps/Joyent-Compute-Platform-3301-hc-topology.xml 0444 root sys
+s usr/platform/i86pc/lib/fm/topo/maps/Joyent-Compute-Platform-3302-hc-topology.xml=./Joyent-Compute-Platform-3301-hc-topology.xml
+f usr/platform/i86pc/lib/fm/topo/maps/Joyent-Compute-Platform-330x-chassis-hc-topology.xml 0444 root sys
+f usr/platform/i86pc/lib/fm/topo/maps/Joyent-Compute-Platform-330x-fan-hc-topology.xml 0444 root sys
 f usr/platform/i86pc/lib/fm/topo/maps/Joyent-Storage-Platform-7001-hc-topology.xml 0444 root sys
 f usr/platform/i86pc/lib/fm/topo/maps/Joyent-Storage-Platform-7001-chassis-hc-topology.xml 0444 root sys
 f usr/platform/i86pc/lib/fm/topo/maps/Joyent-Storage-Platform-7001-slot-hc-topology.xml 0444 root sys
@@ -10456,6 +10451,7 @@ f usr/sbin/poolbind 0555 root bin
 f usr/sbin/poolcfg 0555 root bin
 h usr/sbin/ports=usr/sbin/devfsadm
 h usr/sbin/poweroff=usr/sbin/halt
+f usr/sbin/pptadm 0555 root bin
 f usr/sbin/praudit 0555 root bin
 f usr/sbin/projadd 0555 root sys
 f usr/sbin/projdel 0555 root sys
diff --git a/usr/src/Makefile.lint b/usr/src/Makefile.lint
index b8c25c83da..2903e39596 100644
--- a/usr/src/Makefile.lint
+++ b/usr/src/Makefile.lint
@@ -24,6 +24,7 @@
 # Copyright (c) 2012 by Delphix. All rights reserved.
 # Copyright 2015 Garrett D'Amore <garrett@damore.org>
 # Copyright 2016 Nexenta Systems, Inc.
+# Copyright 2018 Joyent, Inc.
 #
 
 # include global definitions
@@ -409,6 +410,7 @@ COMMON_SUBDIRS = \
 	lib/libpicltree \
 	lib/libpkg \
 	lib/libpool \
+	lib/libppt \
 	lib/libproc \
 	lib/libpthread \
 	lib/libraidcfg \
diff --git a/usr/src/Makefile.master b/usr/src/Makefile.master
index 2e5fd4b51b..70faac9962 100644
--- a/usr/src/Makefile.master
+++ b/usr/src/Makefile.master
@@ -178,6 +178,7 @@ FLEX=		/usr/bin/flex
 YACC=		/usr/ccs/bin/yacc
 BISON=		/usr/bin/bison
 CPP=		/usr/lib/cpp
+ANSI_CPP=	$(GCC_ROOT)/bin/cpp
 JAVAC=		$(JAVA_ROOT)/bin/javac
 JAVAH=		$(JAVA_ROOT)/bin/javah
 JAVADOC=	$(JAVA_ROOT)/bin/javadoc
diff --git a/usr/src/cmd/Makefile b/usr/src/cmd/Makefile
index e69f940e11..c8ac9f27b4 100644
--- a/usr/src/cmd/Makefile
+++ b/usr/src/cmd/Makefile
@@ -21,7 +21,7 @@
 
 #
 # Copyright (c) 1989, 2010, Oracle and/or its affiliates. All rights reserved.
-# Copyright (c) 2017, Joyent, Inc.
+# Copyright (c) 2018, Joyent, Inc.
 # Copyright (c) 2012 by Delphix. All rights reserved.
 # Copyright (c) 2013 DEY Storage Systems, Inc. All rights reserved.
 # Copyright 2014 Garrett D'Amore <garrett@damore.org>
@@ -316,6 +316,7 @@ COMMON_SUBDIRS=		\
 	ppgsz		\
 	pg		\
 	plockstat	\
+	pptadm		\
 	pr		\
 	prctl		\
 	printf		\
diff --git a/usr/src/cmd/cmd-inet/usr.bin/netstat/netstat.c b/usr/src/cmd/cmd-inet/usr.bin/netstat/netstat.c
index 2607c5cde6..475e915b2e 100644
--- a/usr/src/cmd/cmd-inet/usr.bin/netstat/netstat.c
+++ b/usr/src/cmd/cmd-inet/usr.bin/netstat/netstat.c
@@ -23,7 +23,7 @@
  * Copyright (c) 1990  Mentat Inc.
  * netstat.c 2.2, last change 9/9/91
  * MROUTING Revision 3.5
- * Copyright (c) 2017, Joyent, Inc.
+ * Copyright 2018, Joyent, Inc.
  */
 
 /*
@@ -236,6 +236,7 @@ static void 		fatal(int errcode, char *str1, ...);
 
 
 static	boolean_t	Aflag = B_FALSE;	/* All sockets/ifs/rtng-tbls */
+static	boolean_t	CIDRflag = B_FALSE;	/* CIDR for IPv4 -i/-r addrs */
 static	boolean_t	Dflag = B_FALSE;	/* DCE info */
 static	boolean_t	Iflag = B_FALSE;	/* IP Traffic Interfaces */
 static	boolean_t	Mflag = B_FALSE;	/* STREAMS Memory Statistics */
@@ -446,12 +447,16 @@ main(int argc, char **argv)
 	(void) setlocale(LC_ALL, "");
 	(void) textdomain(TEXT_DOMAIN);
 
-	while ((c = getopt(argc, argv, "adimnrspMgvxf:P:I:DRT:")) != -1) {
+	while ((c = getopt(argc, argv, "acdimnrspMgvxf:P:I:DRT:")) != -1) {
 		switch ((char)c) {
 		case 'a':		/* all connections */
 			Aflag = B_TRUE;
 			break;
 
+		case 'c':
+			CIDRflag = B_TRUE;
+			break;
+
 		case 'd':		/* DCE info */
 			Dflag = B_TRUE;
 			IFLAGMOD(Iflag_only, 1, 0); /* see macro def'n */
@@ -3340,7 +3345,7 @@ if_report_ip4(mib2_ipAddrEntry_t *ap,
     boolean_t ksp_not_null)
 {
 
-	char abuf[MAXHOSTNAMELEN + 1];
+	char abuf[MAXHOSTNAMELEN + 4];	/* Include /<num> for CIDR-printing. */
 	char dstbuf[MAXHOSTNAMELEN + 1];
 
 	if (ksp_not_null) {
@@ -4439,7 +4444,7 @@ static boolean_t
 ire_report_item_v4(const mib2_ipRouteEntry_t *rp, boolean_t first,
     const sec_attr_list_t *attrs)
 {
-	char			dstbuf[MAXHOSTNAMELEN + 1];
+	char			dstbuf[MAXHOSTNAMELEN + 4]; /* + "/<num>" */
 	char			maskbuf[MAXHOSTNAMELEN + 1];
 	char			gwbuf[MAXHOSTNAMELEN + 1];
 	char			ifname[LIFNAMSIZ + 1];
@@ -5557,7 +5562,7 @@ mrt_report(mib_item_t *item)
 	struct mfcctl	*mfccp;
 	int		numvifs = 0;
 	int		nmfc = 0;
-	char		abuf[MAXHOSTNAMELEN + 1];
+	char		abuf[MAXHOSTNAMELEN + 4]; /* Include CIDR /<num>. */
 
 	if (!(family_selected(AF_INET)))
 		return;
@@ -5975,6 +5980,57 @@ pr_ap6(const in6_addr_t *addr, uint_t port, char *proto,
 	return (dst);
 }
 
+/*
+ * Returns -2 to indicate a discontiguous mask.  Otherwise returns between
+ * 0 and 32.
+ */
+static int
+v4_cidr_len(uint_t mask)
+{
+	int rc = 0;
+	int i;
+
+	for (i = 0; i < 32; i++) {
+		if (mask & 0x1)
+			rc++;
+		else if (rc > 0)
+			return (-2);	/* Discontiguous IPv4 netmask. */
+
+		mask >>= 1;
+	}
+
+	return (rc);
+}
+
+static void
+append_v4_cidr_len(char *dst, uint_t dstlen, int prefixlen)
+{
+	char *prefixptr;
+
+	/* 4 bytes leaves room for '/' 'N' 'N' '\0' */
+	if (strlen(dst) <= dstlen - 4) {
+		prefixptr = dst + strlen(dst);
+	} else {
+		/*
+		 * Cut off last 3 chars of very-long DNS name.  All callers
+		 * should give us enough room, but name services COULD give us
+		 * a way-too-big name (see above).
+		 */
+		prefixptr = dst + strlen(dst) - 3;
+	}
+	/* At this point "prefixptr" is guaranteed to point to 4 bytes. */
+
+	if (prefixlen >= 0) {
+		if (prefixlen > 32)	/* Shouldn't happen, but... */
+			prefixlen = 32;
+		(void) snprintf(prefixptr, 4, "/%d", prefixlen);
+	} else if (prefixlen == -2) {
+		/* "/NM" == Noncontiguous Mask. */
+		(void) strcat(prefixptr, "/NM");
+	}
+	/* Else print nothing extra. */
+}
+
 /*
  * Return the name of the network whose address is given. The address is
  * assumed to be that of a net or subnet, not a host.
@@ -5988,13 +6044,17 @@ pr_net(uint_t addr, uint_t mask, char *dst, uint_t dstlen)
 	uint_t		net;
 	int		subnetshift;
 	int		error_num;
+	int		prefixlen = -1;	/* -1 == Don't print prefix! */
+					/* -2 == Noncontiguous mask... */
 
 	if (addr == INADDR_ANY && mask == INADDR_ANY) {
-		(void) strncpy(dst, "default", dstlen);
-		dst[dstlen - 1] = 0;
+		(void) strlcpy(dst, "default", dstlen);
 		return (dst);
 	}
 
+	if (CIDRflag)
+		prefixlen = v4_cidr_len(ntohl(mask));
+
 	if (!Nflag && addr) {
 		if (mask == 0) {
 			if (IN_CLASSA(addr)) {
@@ -6016,6 +6076,8 @@ pr_net(uint_t addr, uint_t mask, char *dst, uint_t dstlen)
 			while (addr & ~mask)
 				/* compiler doesn't sign extend! */
 				mask = (mask | ((int)mask >> subnetshift));
+			if (CIDRflag)
+				prefixlen = v4_cidr_len(mask);
 		}
 		net = addr & mask;
 		while ((mask & 1) == 0)
@@ -6038,11 +6100,13 @@ pr_net(uint_t addr, uint_t mask, char *dst, uint_t dstlen)
 		}
 	}
 	if (cp != NULL) {
-		(void) strncpy(dst, cp, dstlen);
-		dst[dstlen - 1] = 0;
+		(void) strlcpy(dst, cp, dstlen);
 	} else {
 		(void) inet_ntop(AF_INET, (char *)&addr, dst, dstlen);
 	}
+
+	append_v4_cidr_len(dst, dstlen, prefixlen);
+
 	if (hp != NULL)
 		freehostent(hp);
 	return (dst);
@@ -6064,15 +6128,19 @@ pr_netaddr(uint_t addr, uint_t mask, char *dst, uint_t dstlen)
 	struct in_addr in;
 	int		error_num;
 	uint_t		nbo_addr = addr;	/* network byte order */
+	int		prefixlen = -1;	/* -1 == Don't print prefix! */
+					/* -2 == Noncontiguous mask... */
 
 	addr = ntohl(addr);
 	mask = ntohl(mask);
 	if (addr == INADDR_ANY && mask == INADDR_ANY) {
-		(void) strncpy(dst, "default", dstlen);
-		dst[dstlen - 1] = 0;
+		(void) strlcpy(dst, "default", dstlen);
 		return (dst);
 	}
 
+	if (CIDRflag)
+		prefixlen = v4_cidr_len(mask);
+
 	/* Figure out network portion of address (with host portion = 0) */
 	if (addr) {
 		/* Try figuring out mask if unknown (all 0s). */
@@ -6096,6 +6164,8 @@ pr_netaddr(uint_t addr, uint_t mask, char *dst, uint_t dstlen)
 			while (addr & ~mask)
 				/* compiler doesn't sign extend! */
 				mask = (mask | ((int)mask >> subnetshift));
+			if (CIDRflag)
+				prefixlen = v4_cidr_len(mask);
 		}
 		net = netshifted = addr & mask;
 		while ((mask & 1) == 0)
@@ -6124,8 +6194,8 @@ pr_netaddr(uint_t addr, uint_t mask, char *dst, uint_t dstlen)
 		}
 
 		if (cp != NULL) {
-			(void) strncpy(dst, cp, dstlen);
-			dst[dstlen - 1] = 0;
+			(void) strlcpy(dst, cp, dstlen);
+			append_v4_cidr_len(dst, dstlen, prefixlen);
 			if (hp != NULL)
 				freehostent(hp);
 			return (dst);
@@ -6138,6 +6208,7 @@ pr_netaddr(uint_t addr, uint_t mask, char *dst, uint_t dstlen)
 
 	in.s_addr = htonl(net);
 	(void) inet_ntop(AF_INET, (char *)&in, dst, dstlen);
+	append_v4_cidr_len(dst, dstlen, prefixlen);
 	if (hp != NULL)
 		freehostent(hp);
 	return (dst);
diff --git a/usr/src/cmd/cmd-inet/usr.bin/pppd/pppd.h b/usr/src/cmd/cmd-inet/usr.bin/pppd/pppd.h
index 8c14c1f6ad..6804a8c72d 100644
--- a/usr/src/cmd/cmd-inet/usr.bin/pppd/pppd.h
+++ b/usr/src/cmd/cmd-inet/usr.bin/pppd/pppd.h
@@ -82,15 +82,22 @@ extern "C" {
  * If this evaluates non-zero, then sifup() must be called before
  * sifaddr().
  */
-#define SIFUPFIRST \
- (defined(SVR4) && (defined(SNI) || defined(__USLC__)))
+#if (defined(SVR4) && (defined(SNI) || defined(__USLC__)))
+#define SIFUPFIRST (1)
+#else
+#define SIFUPFIRST (0)
+#endif
 
 /*
  * If this evaluates non-zero, then sif6up() must be called before
  * sif6addr().
  */
-#define SIF6UPFIRST \
- (defined(__linux__) || (defined(SVR4) && (defined(SNI) || defined(__USLC__))))
+#if (defined(__linux__) || \
+	(defined(SVR4) && (defined(SNI) || defined(__USLC__))))
+#define SIF6UPFIRST (1)
+#else
+#define SIF6UPFIRST (0)
+#endif
 
 /*
  * Option descriptor structure.
diff --git a/usr/src/cmd/cmd-inet/usr.bin/pppdump/zlib.c b/usr/src/cmd/cmd-inet/usr.bin/pppdump/zlib.c
index c3c68f65f8..eb369dad18 100644
--- a/usr/src/cmd/cmd-inet/usr.bin/pppdump/zlib.c
+++ b/usr/src/cmd/cmd-inet/usr.bin/pppdump/zlib.c
@@ -2884,6 +2884,7 @@ int f;
         break;
       }
       z->state->mode = FLAG;
+      /* FALLTHROUGH */
     case FLAG:
       NEEDBYTE
       if ((b = NEXTBYTE) & 0x20)
@@ -2902,6 +2903,7 @@ int f;
       }
       Trace((stderr, "inflate: zlib header ok\n"));
       z->state->mode = BLOCKS;
+      /* FALLTHROUGH */
     case BLOCKS:
       r = inflate_blocks(z->state->blocks, z, r);
       if (f == Z_PACKET_FLUSH && z->avail_in == 0 && z->avail_out != 0)
@@ -2922,18 +2924,22 @@ int f;
         break;
       }
       z->state->mode = CHECK4;
+      /* FALLTHROUGH */
     case CHECK4:
       NEEDBYTE
       z->state->sub.check.need = (uLong)NEXTBYTE << 24;
       z->state->mode = CHECK3;
+      /* FALLTHROUGH */
     case CHECK3:
       NEEDBYTE
       z->state->sub.check.need += (uLong)NEXTBYTE << 16;
       z->state->mode = CHECK2;
+      /* FALLTHROUGH */
     case CHECK2:
       NEEDBYTE
       z->state->sub.check.need += (uLong)NEXTBYTE << 8;
       z->state->mode = CHECK1;
+      /* FALLTHROUGH */
     case CHECK1:
       NEEDBYTE
       z->state->sub.check.need += (uLong)NEXTBYTE;
@@ -2947,6 +2953,7 @@ int f;
       }
       Trace((stderr, "inflate: zlib check ok\n"));
       z->state->mode = DONE;
+      /* FALLTHROUGH */
     case DONE:
       return Z_STREAM_END;
     case BAD:
@@ -3474,6 +3481,7 @@ int r;
         s->sub.decode.td = td;
       }
       s->mode = CODES;
+      /* FALLTHROUGH */
     case CODES:
       UPDATE
       if ((r = inflate_codes(s, z, r)) != Z_STREAM_END)
@@ -3499,11 +3507,13 @@ int r;
         p--;                    /* can always return one */
       }
       s->mode = DRY;
+      /* FALLTHROUGH */
     case DRY:
       FLUSH
       if (s->read != s->write)
         LEAVE
       s->mode = DONEB;
+      /* FALLTHROUGH */
     case DONEB:
       r = Z_STREAM_END;
       LEAVE
@@ -4180,6 +4190,7 @@ int r;
       c->sub.code.need = c->lbits;
       c->sub.code.tree = c->ltree;
       c->mode = LEN;
+      /* FALLTHROUGH */
     case LEN:           /* i: get length/literal/eob next */
       j = c->sub.code.need;
       NEEDBITS(j)
@@ -4227,6 +4238,7 @@ int r;
       c->sub.code.tree = c->dtree;
       Tracevv((stderr, "inflate:         length %u\n", c->len));
       c->mode = DIST;
+      /* FALLTHROUGH */
     case DIST:          /* i: get distance next */
       j = c->sub.code.need;
       NEEDBITS(j)
@@ -4257,6 +4269,7 @@ int r;
       DUMPBITS(j)
       Tracevv((stderr, "inflate:         distance %u\n", c->sub.copy.dist));
       c->mode = COPY;
+      /* FALLTHROUGH */
     case COPY:          /* o: copying bytes in window, waiting for space */
 #ifndef __TURBOC__ /* Turbo C bug for following expression */
       f = (uInt)(q - s->window) < c->sub.copy.dist ?
@@ -4287,6 +4300,7 @@ int r;
       if (s->read != s->write)
         LEAVE
       c->mode = END;
+      /* FALLTHROUGH */
     case END:
       r = Z_STREAM_END;
       LEAVE
diff --git a/usr/src/cmd/cmd-inet/usr.bin/rdist/gram.y b/usr/src/cmd/cmd-inet/usr.bin/rdist/gram.y
index 552c9d0813..160e9fd802 100644
--- a/usr/src/cmd/cmd-inet/usr.bin/rdist/gram.y
+++ b/usr/src/cmd/cmd-inet/usr.bin/rdist/gram.y
@@ -15,7 +15,6 @@
  * Copyright 2005 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
  */
-#pragma ident	"%Z%%M%	%I%	%E% SMI"
 
 #include "defs.h"
 
@@ -205,6 +204,7 @@ again:
 			;
 		if (c == EOF)
 			return(0);
+		/* FALLTHROUGH */
 	case '\n':
 		yylineno++;
 	case ' ':
diff --git a/usr/src/cmd/cmd-inet/usr.bin/rdist/server.c b/usr/src/cmd/cmd-inet/usr.bin/rdist/server.c
index 88fac286eb..dd319ed40a 100644
--- a/usr/src/cmd/cmd-inet/usr.bin/rdist/server.c
+++ b/usr/src/cmd/cmd-inet/usr.bin/rdist/server.c
@@ -218,6 +218,7 @@ server()
 
 		default:
 			error("server: unknown command '%s'\n", cp);
+			continue;
 		case '\0':
 			continue;
 		}
@@ -1619,7 +1620,7 @@ more:
 
 	default:
 		s--;
-		/* fall into... */
+		/* FALLTHROUGH */
 	case '\1':
 	case '\2':
 		nerrs++;
diff --git a/usr/src/cmd/cmd-inet/usr.lib/mdnsd/DNSCommon.c b/usr/src/cmd/cmd-inet/usr.lib/mdnsd/DNSCommon.c
index 607293e838..e75f734e22 100644
--- a/usr/src/cmd/cmd-inet/usr.lib/mdnsd/DNSCommon.c
+++ b/usr/src/cmd/cmd-inet/usr.lib/mdnsd/DNSCommon.c
@@ -1536,8 +1536,8 @@ mDNSexport mDNSu32 RDataHashValue(const ResourceRecord *const rr)
         sum = DomainNameHashValue((domainname *)rdb->data);
         ptr += dlen;
         len -= dlen;
-        /* FALLTHROUGH */
     }
+    /* FALLTHROUGH */
 
     default:
     {
@@ -4185,6 +4185,7 @@ decimal:    if (!F.havePrecision)
 
             case 'p':  F.havePrecision = F.lSize = 1;
                 F.precision = sizeof(void*) * 2;                // 8 characters on 32-bit; 16 characters on 64-bit
+		/* FALLTHROUGH */
             case 'X':  digits = "0123456789ABCDEF";
                 goto hexadecimal;
             case 'x':  digits = "0123456789abcdef";
@@ -4278,6 +4279,7 @@ hexadecimal: if (F.lSize) n = va_arg(arg, unsigned long);
 
             default:    s = mDNS_VACB;
                 i = mDNS_snprintf(mDNS_VACB, sizeof(mDNS_VACB), "<<UNKNOWN FORMAT CONVERSION CODE %%%c>>", c);
+		/* FALLTHROUGH */
 
             case '%':  *sbuffer++ = (char)c;
                 if (++nwritten >= buflen) goto exit;
diff --git a/usr/src/cmd/cmd-inet/usr.lib/mdnsd/DNSDigest.c b/usr/src/cmd/cmd-inet/usr.lib/mdnsd/DNSDigest.c
index e1aa82df11..6520ac6f6e 100644
--- a/usr/src/cmd/cmd-inet/usr.lib/mdnsd/DNSDigest.c
+++ b/usr/src/cmd/cmd-inet/usr.lib/mdnsd/DNSDigest.c
@@ -610,16 +610,21 @@ void md5_block_data_order (MD5_CTX *c, const void *p,int num);
 #define HOST_p_c2l(c,l,n)   {                   \
         switch (n) {                    \
         case 0: l =((unsigned long)(*((c)++)));     \
+	/* FALLTHROUGH */	\
         case 1: l|=((unsigned long)(*((c)++)))<< 8; \
+	/* FALLTHROUGH */	\
         case 2: l|=((unsigned long)(*((c)++)))<<16; \
+	/* FALLTHROUGH */	\
         case 3: l|=((unsigned long)(*((c)++)))<<24; \
         } }
 #define HOST_p_c2l_p(c,l,sc,len) {                  \
         switch (sc) {                   \
         case 0: l =((unsigned long)(*((c)++)));     \
             if (--len == 0) break;                                                 \
+	/* FALLTHROUGH */	\
         case 1: l|=((unsigned long)(*((c)++)))<< 8; \
             if (--len == 0) break;                                                 \
+	/* FALLTHROUGH */	\
         case 2: l|=((unsigned long)(*((c)++)))<<16; \
         } }
 /* NOTE the pointer is not incremented at the end of this */
@@ -627,7 +632,9 @@ void md5_block_data_order (MD5_CTX *c, const void *p,int num);
         l=0; (c)+=n;                    \
         switch (n) {                    \
         case 3: l =((unsigned long)(*(--(c))))<<16; \
+	/* FALLTHROUGH */	\
         case 2: l|=((unsigned long)(*(--(c))))<< 8; \
+	/* FALLTHROUGH */	\
         case 1: l|=((unsigned long)(*(--(c))));     \
         } }
 #define _HOST_l2c(l,c)  (*((c)++)=(unsigned char)(((l)    )&0xff),  \
diff --git a/usr/src/cmd/cmd-inet/usr.lib/mdnsd/uDNS.c b/usr/src/cmd/cmd-inet/usr.lib/mdnsd/uDNS.c
index 6ce0158b56..56aced0180 100644
--- a/usr/src/cmd/cmd-inet/usr.lib/mdnsd/uDNS.c
+++ b/usr/src/cmd/cmd-inet/usr.lib/mdnsd/uDNS.c
@@ -2310,7 +2310,8 @@ mDNSlocal void UpdateOneSRVRecord(mDNS *m, AuthRecord *rr)
 
     case regState_NATError:
         if (!NATChanged) return;
-    // if nat changed, register if we have a target (below)
+	// if nat changed, register if we have a target (below)
+	/* FALLTHROUGH */
 
     case regState_NoTarget:
         if (!newtarget->c[0])
diff --git a/usr/src/cmd/fm/eversholt/eftinfo/common/eftinfo.c b/usr/src/cmd/fm/eversholt/eftinfo/common/eftinfo.c
index 68332725d6..03f06dfae7 100644
--- a/usr/src/cmd/fm/eversholt/eftinfo/common/eftinfo.c
+++ b/usr/src/cmd/fm/eversholt/eftinfo/common/eftinfo.c
@@ -29,8 +29,6 @@
  * modules is driven by this file.
  */
 
-#pragma ident	"%Z%%M%	%I%	%E% SMI"
-
 #include <stdio.h>
 #include <string.h>
 #ifdef sun
@@ -161,6 +159,7 @@ main(int argc, char *argv[])
 			    VERSION_MAJOR, VERSION_MINOR);
 			out(O_DIE|O_USAGE, "%s\n%s", Usage, Help);
 			/*NOTREACHED*/
+			break;
 
 		case 'p':
 			pflag++;
diff --git a/usr/src/cmd/fm/eversholt/esc/common/escmain.c b/usr/src/cmd/fm/eversholt/esc/common/escmain.c
index eec47214ba..8b68098fc5 100644
--- a/usr/src/cmd/fm/eversholt/esc/common/escmain.c
+++ b/usr/src/cmd/fm/eversholt/esc/common/escmain.c
@@ -29,8 +29,6 @@
  * modules is driven by this file.
  */
 
-#pragma ident	"%Z%%M%	%I%	%E% SMI"
-
 #include <stdio.h>
 #include <string.h>
 #ifdef sun
@@ -165,6 +163,7 @@ main(int argc, char *argv[])
 			    VERSION_MAJOR, VERSION_MINOR);
 			out(O_DIE|O_USAGE, "%s\n%s", Usage, Help);
 			/*NOTREACHED*/
+			break;
 
 		case 'o':
 			outfile = optarg;
diff --git a/usr/src/cmd/fm/modules/common/eversholt/eval.c b/usr/src/cmd/fm/modules/common/eversholt/eval.c
index 8e05ae0bc1..a3c47f91dc 100644
--- a/usr/src/cmd/fm/modules/common/eversholt/eval.c
+++ b/usr/src/cmd/fm/modules/common/eversholt/eval.c
@@ -1698,6 +1698,7 @@ eval_expr(struct node *np, struct lut *ex, struct node *events[],
 		out(O_ALTFP|O_DIE, "eval_expr: wrong context for operation %s",
 		    ptree_nodetype2str(np->t));
 		/*NOTREACHED*/
+		break;
 
 	case T_NE:
 		if (!eval_expr(np->u.expr.left, ex, events, globals, croot,
diff --git a/usr/src/cmd/fm/modules/common/sensor-transport/sensor_transport.c b/usr/src/cmd/fm/modules/common/sensor-transport/sensor_transport.c
index 6bf4da305a..db8715ac01 100644
--- a/usr/src/cmd/fm/modules/common/sensor-transport/sensor_transport.c
+++ b/usr/src/cmd/fm/modules/common/sensor-transport/sensor_transport.c
@@ -20,6 +20,7 @@
  */
 /*
  * Copyright (c) 2009, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2018, Joyent, Inc.
  */
 
 #include <fm/fmd_api.h>
@@ -56,6 +57,7 @@ typedef struct sensor_transport {
 	 * we'll tolerate before sending an ereport.
 	 */
 	uint32_t	st_tolerance;
+	nvlist_t	*st_spoofs;
 } sensor_transport_t;
 
 typedef struct st_stats {
@@ -72,6 +74,7 @@ st_stats_t st_stats = {
 
 static int st_check_component_complaints;
 static int have_complained;
+static char *spoof_prop = NULL;
 
 static int
 st_check_component(topo_hdl_t *thp, tnode_t *node, void *arg)
@@ -83,7 +86,7 @@ st_check_component(topo_hdl_t *thp, tnode_t *node, void *arg)
 	char *fmri;
 	int err, ret;
 	int32_t last_source, source = -1;
-	boolean_t nonrecov, faulted, predictive, source_diff;
+	boolean_t nonrecov, faulted, predictive, source_diff, injected;
 	nvpair_t *nvp;
 	uint64_t ena;
 	nvlist_t *event;
@@ -117,7 +120,8 @@ st_check_component(topo_hdl_t *thp, tnode_t *node, void *arg)
 	}
 
 	if (topo_method_invoke(node, TOPO_METH_SENSOR_FAILURE,
-	    TOPO_METH_SENSOR_FAILURE_VERSION, NULL, &nvl, &err) != 0) {
+	    TOPO_METH_SENSOR_FAILURE_VERSION, stp->st_spoofs, &nvl, &err) !=
+	    0) {
 		if (err == ETOPO_METHOD_NOTSUP) {
 			st_check_component_complaints++;
 			if (!have_complained) {
@@ -131,7 +135,7 @@ st_check_component(topo_hdl_t *thp, tnode_t *node, void *arg)
 		nvl = NULL;
 	}
 
-	if (topo_node_fru(node, &fru, NULL, NULL) != 0) {
+	if (topo_node_fru(node, &fru, NULL, &err) != 0) {
 		st_stats.st_bad_fmri.fmds_value.ui64++;
 		nvlist_free(nvl);
 		nvlist_free(rsrc);
@@ -148,7 +152,7 @@ st_check_component(topo_hdl_t *thp, tnode_t *node, void *arg)
 
 	nvlist_free(fru);
 
-	faulted = nonrecov = source_diff = B_FALSE;
+	faulted = nonrecov = source_diff = injected = B_FALSE;
 	predictive = B_TRUE;
 	if (nvl != NULL)  {
 		nvp = NULL;
@@ -173,6 +177,9 @@ st_check_component(topo_hdl_t *thp, tnode_t *node, void *arg)
 			 *
 			 * 3) source will be set to unknown unless all facility
 			 *    nodes agree on the source
+			 *
+			 * 4) injected defaults to false, but will be set to
+			 *    true if any of the sensor states were injected.
 			 */
 			if (nonrecov == B_FALSE)
 				if (nvlist_lookup_boolean_value(props,
@@ -182,6 +189,8 @@ st_check_component(topo_hdl_t *thp, tnode_t *node, void *arg)
 				if (nvlist_lookup_boolean_value(props,
 				    "predictive", &predictive) != 0)
 					predictive = B_FALSE;
+			(void) nvlist_lookup_boolean_value(props,
+			    "injected", &injected);
 
 			last_source = source;
 			if (nvlist_lookup_uint32(props, "source",
@@ -260,7 +269,8 @@ st_check_component(topo_hdl_t *thp, tnode_t *node, void *arg)
 			(void) nvlist_add_uint64(event, FM_EREPORT_ENA, ena);
 			(void) nvlist_add_nvlist(event, FM_EREPORT_DETECTOR,
 			    rsrc);
-
+			(void) nvlist_add_boolean_value(event, "__injected",
+			    injected);
 			fmd_xprt_post(hdl, stp->st_xprt, event, 0);
 			fmd_hdl_debug(hdl, "posted ereport: %s",
 			    ST_EREPORT_CLASS);
@@ -351,9 +361,74 @@ st_timeout(fmd_hdl_t *hdl, id_t id, void *data)
 	stp->st_timer = fmd_timer_install(hdl, NULL, NULL, stp->st_interval);
 }
 
+/*
+ * Parse the value of the spoof-sensor-state module property and store the
+ * result in an nvlist of nvlists.  The format of the value is 3-tuple,
+ * delimited by colons, as follows:
+ *
+ * FMRIPATTERN:SENSORNAME:SENSORSTATE;...
+ *
+ * where FMRIPATTERN can be a string with wildcards that matches the FMRI
+ * of a node associated with the target sensor facility.
+ *
+ * where SENSORNAME is the node name of the target sensor facility
+ *
+ * where SENSORSTATE is the desired sensor state value to spoof.
+ *
+ * Multiple tuples can be specifed, delimited by semicolons.
+ *
+ * If any errors are encountered while parsing the value, all parsing is
+ * ceased and an ereport will be generated indicating a failure to parse
+ * the value.
+ */
+/*ARGSUSED*/
+static int
+parse_spoof_param(fmd_hdl_t *hdl, char *param, sensor_transport_t *stp)
+{
+	char *sensor, *last_sensor, *field, *last_field;
+	nvlist_t *spoof;
+
+	if (nvlist_alloc(&stp->st_spoofs, NV_UNIQUE_NAME, 0) != NULL) {
+		return (-1);
+	}
+
+	sensor = strtok_r(param, ";", &last_sensor);
+	while (sensor != NULL) {
+		if (nvlist_alloc(&spoof, NV_UNIQUE_NAME, 0) != 0)
+			goto err;
+
+		if ((field = strtok_r(sensor, ":", &last_field)) == NULL ||
+		    nvlist_add_string(spoof, ST_SPOOF_FMRI, field) != 0)
+			goto err;
+
+		if ((field = strtok_r(NULL, ":", &last_field)) == NULL ||
+		    nvlist_add_string(spoof, ST_SPOOF_SENSOR, field) != 0)
+			goto err;
+
+		if ((field = strtok_r(NULL, ":", &last_field)) == NULL ||
+		    nvlist_add_uint32(spoof, ST_SPOOF_STATE,
+		    strtol(field, NULL, 0)) != 0)
+			goto err;
+
+		if (nvlist_add_nvlist(stp->st_spoofs, sensor, spoof) != 0)
+			goto err;
+
+		spoof = NULL;
+		sensor = strtok_r(NULL, ";", &last_sensor);
+	}
+
+	return (0);
+err:
+	nvlist_free(spoof);
+	nvlist_free(stp->st_spoofs);
+	stp->st_spoofs = NULL;
+	return (-1);
+}
+
 static const fmd_prop_t fmd_props[] = {
 	{ "interval", FMD_TYPE_TIME, "1min" },
 	{ "tolerance", FMD_TYPE_UINT32, "1" },
+	{ "spoof_sensor_state", FMD_TYPE_STRING, NULL },
 	{ NULL, 0, NULL }
 };
 
@@ -397,6 +472,10 @@ _fmd_init(fmd_hdl_t *hdl)
 	stp = fmd_hdl_zalloc(hdl, sizeof (sensor_transport_t), FMD_SLEEP);
 	stp->st_interval = fmd_prop_get_int64(hdl, "interval");
 	stp->st_tolerance = fmd_prop_get_int32(hdl, "tolerance");
+	spoof_prop = fmd_prop_get_string(hdl, "spoof_sensor_state");
+
+	if (spoof_prop != NULL && parse_spoof_param(hdl, spoof_prop, stp) != 0)
+		fmd_hdl_error(hdl, "Error parsing config file");
 
 	fmd_hdl_setspecific(hdl, stp);
 
@@ -424,7 +503,8 @@ _fmd_fini(fmd_hdl_t *hdl)
 			fmd_hdl_strfree(hdl, sfp->sf_fru);
 			fmd_hdl_free(hdl, sfp, sizeof (sensor_fault_t));
 		}
-
+		nvlist_free(stp->st_spoofs);
 		fmd_hdl_free(hdl, stp, sizeof (sensor_transport_t));
 	}
+	fmd_prop_free_string(hdl, spoof_prop);
 }
diff --git a/usr/src/cmd/fs.d/smbclnt/smbutil/Makefile b/usr/src/cmd/fs.d/smbclnt/smbutil/Makefile
index 5b751cce22..e20054c772 100644
--- a/usr/src/cmd/fs.d/smbclnt/smbutil/Makefile
+++ b/usr/src/cmd/fs.d/smbclnt/smbutil/Makefile
@@ -23,6 +23,8 @@
 # Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
 # Use is subject to license terms.
 #
+# Copyright 2013 Nexenta Systems, Inc.  All rights reserved.
+#
 
 #
 # cmd/fs.d/smbclnt/smbutil/Makefile
@@ -30,18 +32,22 @@
 
 PROG=		smbutil
 
-include		$(SRC)/cmd/Makefile.cmd
-
-OBJS=   smbutil.o login.o lookup.o print.o status.o view.o
+OBJS=   smbutil.o info.o login.o lookup.o print.o status.o view.o \
+	shares_rap.o shares_rpc.o srvsvc1_clnt.o srvsvc1_ndr.o
 
 SRCS=	$(OBJS:%.o=%.c)
+
+include		$(SRC)/cmd/Makefile.cmd
+
 POFILE=	smbutil_all.po
 POFILES= $(OBJS:%.o=%.po)
+
+CLEANFILES +=  srvsvc1_ndr.c
 CLOBBERFILES+=  $(POFILE) $(POFILES)
 
 CSTD= $(CSTD_GNU99)
 
-LDLIBS += -lsmbfs -lnsl
+LDLIBS += -lmlrpc -lsmbfs -lnsl
 
 CPPFLAGS += -I$(SRC)/lib/libsmbfs \
 	-I$(SRC)/uts/common/smbclnt -I$(SRC)/uts/common
@@ -78,9 +84,12 @@ $(POFILE): $(POFILES)
 
 lint:	lint_SRCS
 
-clean :
-	$(RM) $(OBJS)
-
-.KEEP_STATE:
+clean:
+	$(RM) $(OBJS) $(CLEANFILES)
 
 include ../../../Makefile.targ
+
+srvsvc1_ndr.c : srvsvc1.ndl
+	$(NDRGEN) -Y $(ANSI_CPP) $(CPPFLAGS) srvsvc1.ndl
+
+.KEEP_STATE:
diff --git a/usr/src/cmd/fs.d/smbclnt/smbutil/common.h b/usr/src/cmd/fs.d/smbclnt/smbutil/common.h
index 24cb1436a0..aea093c0ea 100644
--- a/usr/src/cmd/fs.d/smbclnt/smbutil/common.h
+++ b/usr/src/cmd/fs.d/smbclnt/smbutil/common.h
@@ -30,6 +30,10 @@
  * SUCH DAMAGE.
  */
 
+/*
+ * Copyright 2013 Nexenta Systems, Inc.  All rights reserved.
+ */
+
 #ifndef _SMBUTIL_COMMON_H
 #define	_SMBUTIL_COMMON_H
 
@@ -42,6 +46,7 @@ extern "C" {
 
 int  cmd_crypt(int argc, char *argv[]);
 int  cmd_help(int argc, char *argv[]);
+int  cmd_info(int argc, char *argv[]);
 int  cmd_login(int argc, char *argv[]);
 int  cmd_logout(int argc, char *argv[]);
 int  cmd_logoutall(int argc, char *argv[]);
@@ -50,8 +55,9 @@ int  cmd_print(int argc, char *argv[]);
 int  cmd_status(int argc, char *argv[]);
 int  cmd_view(int argc, char *argv[]);
 
-/* No crypt_usage? */
+void crypt_usage(void);
 void help_usage(void);
+void info_usage(void);
 void login_usage(void);
 void logout_usage(void);
 void logoutall_usage(void);
@@ -60,7 +66,10 @@ void print_usage(void);
 void status_usage(void);
 void view_usage(void);
 
-extern int loadsmbvfs();
+/* See view.c */
+int share_enum_rap(struct smb_ctx *ctx);
+int share_enum_rpc(struct smb_ctx *ctx, char *server);
+void view_print_share(char *share, int type, char *comment);
 
 #ifdef __cplusplus
 }
diff --git a/usr/src/cmd/fs.d/smbclnt/smbutil/info.c b/usr/src/cmd/fs.d/smbclnt/smbutil/info.c
new file mode 100644
index 0000000000..600df1c1b9
--- /dev/null
+++ b/usr/src/cmd/fs.d/smbclnt/smbutil/info.c
@@ -0,0 +1,212 @@
+/*
+ * CDDL HEADER START
+ *
+ * The contents of this file are subject to the terms of the
+ * Common Development and Distribution License (the "License").
+ * You may not use this file except in compliance with the License.
+ *
+ * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
+ * or http://www.opensolaris.org/os/licensing.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * When distributing Covered Code, include this CDDL HEADER in each
+ * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
+ * If applicable, add the following below this CDDL HEADER, with the
+ * fields enclosed by brackets "[]" replaced with your own identifying
+ * information: Portions Copyright [yyyy] [name of copyright owner]
+ *
+ * CDDL HEADER END
+ */
+
+/*
+ * Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
+ * Use is subject to license terms.
+ *
+ * Copyright 2013 Nexenta Systems, Inc.  All rights reserved.
+ */
+
+/*
+ * Show information about the remote server, as offered by
+ * NetServerGetInfo with SERVER_INFO_101
+ */
+
+#include <sys/types.h>
+
+#include <errno.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <libintl.h>
+
+#include <libmlrpc/libmlrpc.h>
+#include <netsmb/smb_lib.h>
+#include "srvsvc1_clnt.h"
+#include "common.h"
+
+
+static int get_info(smb_ctx_t *);
+
+void
+info_usage(void)
+{
+	printf(gettext("usage: smbutil info [connection options] //"
+	    "[workgroup;][user[:password]@]server\n"));
+	exit(1);
+}
+
+int
+cmd_info(int argc, char *argv[])
+{
+	struct smb_ctx *ctx;
+	int error, err2, opt;
+
+	if (argc < 2)
+		info_usage();
+
+	error = smb_ctx_alloc(&ctx);
+	if (error)
+		return (error);
+
+	error = smb_ctx_scan_argv(ctx, argc, argv,
+	    SMBL_SERVER, SMBL_SERVER, USE_WILDCARD);
+	if (error)
+		goto out;
+
+	error = smb_ctx_readrc(ctx);
+	if (error)
+		goto out;
+
+	while ((opt = getopt(argc, argv, STDPARAM_OPT)) != EOF) {
+		if (opt == '?')
+			info_usage();
+		error = smb_ctx_opt(ctx, opt, optarg);
+		if (error)
+			goto out;
+	}
+
+	smb_ctx_setshare(ctx, "IPC$", USE_IPC);
+
+	/*
+	 * Resolve the server address,
+	 * setup derived defaults.
+	 */
+	error = smb_ctx_resolve(ctx);
+	if (error)
+		goto out;
+
+	/*
+	 * Have server, share, etc. from above:
+	 * smb_ctx_scan_argv, option settings.
+	 * Get the session and tree.
+	 */
+again:
+	error = smb_ctx_get_ssn(ctx);
+	if (error == EAUTH) {
+		err2 = smb_get_authentication(ctx);
+		if (err2 == 0)
+			goto again;
+	}
+	if (error) {
+		smb_error(gettext("//%s: login failed"),
+		    error, ctx->ct_fullserver);
+		goto out;
+	}
+
+	error = smb_ctx_get_tree(ctx);
+	if (error) {
+		smb_error(gettext("//%s/%s: tree connect failed"),
+		    error, ctx->ct_fullserver, ctx->ct_origshare);
+		goto out;
+	}
+
+	/*
+	 * Have IPC$ tcon.  Get the server info.
+	 */
+	error = get_info(ctx);
+	if (error)
+		smb_error("cannot get server info.", error);
+
+out:
+	smb_ctx_free(ctx);
+	return (error);
+}
+
+int
+get_info(smb_ctx_t *ctx)
+{
+	char pf_unk[32];
+	mlrpc_handle_t handle;
+	ndr_service_t *svc;
+	union mslm_NetServerGetInfo_ru res;
+	struct mslm_SERVER_INFO_101 *sv101;
+	char *platform_name;
+	int err;
+
+	/*
+	 * Create an RPC handle using the smb_ctx we already have.
+	 * Just local allocation and initialization.
+	 */
+	srvsvc1_initialize();
+	svc = ndr_svc_lookup_name("srvsvc");
+	if (svc == NULL)
+		return (ENOENT);
+
+	err = mlrpc_clh_create(&handle, ctx);
+	if (err)
+		return (err);
+
+	/*
+	 * Try to bind to the RPC service.  If it fails,
+	 * just return the error and the caller will
+	 * fall back to RAP.
+	 */
+	err = mlrpc_clh_bind(&handle, svc);
+	if (err)
+		goto out;
+
+	err = srvsvc_net_server_getinfo(&handle,
+	    ctx->ct_fullserver, 101, &res);
+	if (err)
+		goto out;
+
+	sv101 = res.info101;
+
+	switch (sv101->sv101_platform_id) {
+	case SV_PLATFORM_ID_DOS:
+		platform_name = "DOS";
+		break;
+	case SV_PLATFORM_ID_OS2:
+		platform_name = "OS2";
+		break;
+	case SV_PLATFORM_ID_NT:
+		platform_name = "NT";
+		break;
+	case SV_PLATFORM_ID_OSF:
+		platform_name = "OSF";
+		break;
+	case SV_PLATFORM_ID_VMS:
+		platform_name = "VMS";
+		break;
+	default:
+		platform_name = pf_unk;
+		snprintf(pf_unk, sizeof (pf_unk), "(%d)",
+		    sv101->sv101_platform_id);
+		break;
+	}
+
+	printf("server info:\n");
+	printf(" platform_id %s\n", platform_name);
+	printf(" vers.major  %d\n", sv101->sv101_version_major);
+	printf(" vers.minor  %d\n", sv101->sv101_version_minor);
+
+	if (smb_verbose)
+		printf(" type_flags  0x%x\n", sv101->sv101_type);
+
+	printf(" name    \"%s\"\n", sv101->sv101_name);
+	printf(" comment \"%s\"\n", sv101->sv101_comment);
+
+out:
+	(void) mlrpc_clh_free(&handle);
+	return (err);
+}
diff --git a/usr/src/cmd/fs.d/smbclnt/smbutil/shares_rap.c b/usr/src/cmd/fs.d/smbclnt/smbutil/shares_rap.c
new file mode 100644
index 0000000000..f2235e2880
--- /dev/null
+++ b/usr/src/cmd/fs.d/smbclnt/smbutil/shares_rap.c
@@ -0,0 +1,143 @@
+/*
+ * Copyright (c) 2000-2002, Boris Popov
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *    This product includes software developed by Boris Popov.
+ * 4. Neither the name of the author nor the names of any co-contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * from: Id: view.c,v 1.9 2002/02/20 09:26:42 bp Exp
+ */
+
+/*
+ * Copyright 2013 Nexenta Systems, Inc.  All rights reserved.
+ */
+
+#include <errno.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include <netsmb/mchain.h>	/* letohs, etc. */
+#include <netsmb/smb.h>
+#include <netsmb/smb_lib.h>
+#include <netsmb/smb_rap.h>
+
+#include "common.h"
+
+/*
+ * Enumerate shares using Remote Administration Protocol (RAP)
+ * Was in libsmbfs netshareenum.c
+ */
+
+struct smb_share_info_1 {
+	char		shi1_netname[13];
+	char		shi1_pad;
+	uint16_t	shi1_type;
+	uint32_t	shi1_remark;		/* char * */
+};
+
+static int
+smb_rap_NetShareEnum(struct smb_ctx *ctx, int sLevel, void *pbBuffer,
+	int *cbBuffer, int *pcEntriesRead, int *pcTotalAvail)
+{
+	struct smb_rap *rap;
+	long lval = -1;
+	int error;
+
+	error = smb_rap_create(0, "WrLeh", "B13BWz", &rap);
+	if (error)
+		return (error);
+	smb_rap_setNparam(rap, sLevel);		/* W - sLevel */
+	smb_rap_setPparam(rap, pbBuffer);	/* r - pbBuffer */
+	smb_rap_setNparam(rap, *cbBuffer);	/* L - cbBuffer */
+	error = smb_rap_request(rap, ctx);
+	if (error == 0) {
+		*pcEntriesRead = rap->r_entries;
+		error = smb_rap_getNparam(rap, &lval);
+		*pcTotalAvail = lval;
+		/* Copy the data length into the IN/OUT variable. */
+		*cbBuffer = rap->r_rcvbuflen;
+	}
+	error = smb_rap_error(rap, error);
+	smb_rap_done(rap);
+	return (error);
+}
+
+int
+share_enum_rap(smb_ctx_t *ctx)
+{
+	struct smb_share_info_1 *shi;
+	void *rpbuf;
+	char *cp;
+	int error, bufsize, i, rcnt, total;
+	int lbound, rbound;
+	uint16_t type;
+
+	bufsize = 0xffe0;	/* samba notes win2k bug for 65535 */
+	rpbuf = malloc(bufsize);
+	if (rpbuf == NULL)
+		return (errno);
+
+	error = smb_rap_NetShareEnum(ctx, 1, rpbuf, &bufsize, &rcnt, &total);
+	if (error &&
+	    error != (ERROR_MORE_DATA | SMB_RAP_ERROR))
+		goto out;
+
+	/*
+	 * Bounds for offsets to comments strings.
+	 * After the array, and before the end.
+	 */
+	lbound = rcnt * (sizeof (struct smb_share_info_1));
+	rbound = bufsize;
+
+	/* Print the header line. */
+	view_print_share(NULL, 0, NULL);
+
+	for (shi = rpbuf, i = 0; i < rcnt; i++, shi++) {
+		type = letohs(shi->shi1_type);
+
+		shi->shi1_pad = '\0'; /* ensure null termination */
+
+		/*
+		 * Offsets to comment strings can be trash.
+		 * Only print when the offset is valid.
+		 */
+		if (shi->shi1_remark >= lbound &&
+		    shi->shi1_remark < rbound) {
+			cp = (char *)rpbuf + shi->shi1_remark;
+		} else
+			cp = NULL;
+
+		/* Convert from OEM to local codeset? */
+		view_print_share(shi->shi1_netname, type, cp);
+	}
+	error = 0;
+
+out:
+	free(rpbuf);
+	return (error);
+}
diff --git a/usr/src/cmd/fs.d/smbclnt/smbutil/shares_rpc.c b/usr/src/cmd/fs.d/smbclnt/smbutil/shares_rpc.c
new file mode 100644
index 0000000000..221d6f077b
--- /dev/null
+++ b/usr/src/cmd/fs.d/smbclnt/smbutil/shares_rpc.c
@@ -0,0 +1,83 @@
+/*
+ * This file and its contents are supplied under the terms of the
+ * Common Development and Distribution License ("CDDL"), version 1.0.
+ * You may only use this file in accordance with the terms of version
+ * 1.0 of the CDDL.
+ *
+ * A full copy of the text of the CDDL should have accompanied this
+ * source.  A copy of the CDDL is also available via the Internet at
+ * http://www.illumos.org/license/CDDL.
+ */
+
+/*
+ * Copyright 2013 Nexenta Systems, Inc.  All rights reserved.
+ */
+
+/*
+ * Share enumeration using Remote Procedure Call (RPC)
+ */
+
+#include <sys/types.h>
+
+#include <errno.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include <libmlrpc/libmlrpc.h>
+#include <netsmb/smbfs_api.h>
+#include "srvsvc1_clnt.h"
+#include "common.h"
+
+int
+share_enum_rpc(struct smb_ctx *ctx, char *server)
+{
+	mlrpc_handle_t handle;
+	ndr_service_t *svc;
+	union mslm_NetShareEnum_ru res;
+	struct mslm_NetShareInfo_1 *nsi1;
+	int err, i, count;
+
+	/*
+	 * Create an RPC handle using the smb_ctx we already have.
+	 * Just local allocation and initialization.
+	 */
+	srvsvc1_initialize();
+	svc = ndr_svc_lookup_name("srvsvc");
+	if (svc == NULL)
+		return (ENOENT);
+
+	err = mlrpc_clh_create(&handle, ctx);
+	if (err)
+		return (err);
+
+	/*
+	 * Try to bind to the RPC service.  If it fails,
+	 * just return the error and the caller will
+	 * fall back to RAP.
+	 */
+	err = mlrpc_clh_bind(&handle, svc);
+	if (err)
+		goto out;
+
+	err = srvsvc_net_share_enum(&handle, server, 1, &res);
+	if (err)
+		goto out;
+
+	/* Print the header line. */
+	view_print_share(NULL, 0, NULL);
+
+	/* Print the share list. */
+	count = res.bufptr1->entriesread;
+	i = 0, nsi1 = res.bufptr1->entries;
+	while (i < count) {
+		/* Convert UTF-8 to local code set? */
+		view_print_share((char *)nsi1->shi1_netname,
+		    nsi1->shi1_type, (char *)nsi1->shi1_comment);
+		i++, nsi1++;
+	}
+
+out:
+	(void) mlrpc_clh_free(&handle);
+	return (err);
+}
diff --git a/usr/src/cmd/fs.d/smbclnt/smbutil/smbutil.c b/usr/src/cmd/fs.d/smbclnt/smbutil/smbutil.c
index 20cb3a2c86..9b09b87d64 100644
--- a/usr/src/cmd/fs.d/smbclnt/smbutil/smbutil.c
+++ b/usr/src/cmd/fs.d/smbclnt/smbutil/smbutil.c
@@ -33,6 +33,8 @@
 /*
  * Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
+ *
+ * Copyright 2013 Nexenta Systems, Inc.  All rights reserved.
  */
 
 #include <sys/param.h>
@@ -65,10 +67,11 @@ static struct commands {
 	const char	*name;
 	cmd_fn_t	*fn;
 	cmd_usage_t	*usage;
-	int 		flags;
+	int		flags;
 } commands[] = {
 	{"crypt",	cmd_crypt,	NULL, CMDFL_NO_KMOD},
 	{"help",	cmd_help,	help_usage, CMDFL_NO_KMOD},
+	{"info",	cmd_info,	info_usage, 0},
 	{"login",	cmd_login,	login_usage, 0},
 	{"logout",	cmd_logout,	logout_usage, 0},
 	{"logoutall",	cmd_logoutall,	logoutall_usage, 0},
@@ -187,13 +190,14 @@ help(void) {
 	printf(gettext("where subcommands are:\n"
 	" crypt		slightly obscure password\n"
 	" help		display help on specified subcommand\n"
-	/* " lc 		display active connections\n" */
+	/* " lc		display active connections\n" */
+	" info		display server type and version\n"
 	" login		login to specified host\n"
-	" logout 	logout from specified host\n"
+	" logout	logout from specified host\n"
 	" logoutall	logout all users (requires privilege)\n"
-	" lookup 	resolve NetBIOS name to IP address\n"
+	" lookup	resolve NetBIOS name to IP address\n"
 	" print		print file to the specified remote printer\n"
-	" status 	resolve IP address or DNS name to NetBIOS names\n"
+	" status	resolve IP address or DNS name to NetBIOS names\n"
 	" view		list resources on specified host\n"
 	"\n"));
 	exit(1);
diff --git a/usr/src/cmd/fs.d/smbclnt/smbutil/srvsvc1.ndl b/usr/src/cmd/fs.d/smbclnt/smbutil/srvsvc1.ndl
new file mode 100644
index 0000000000..6712f05020
--- /dev/null
+++ b/usr/src/cmd/fs.d/smbclnt/smbutil/srvsvc1.ndl
@@ -0,0 +1,177 @@
+/*
+ * CDDL HEADER START
+ *
+ * The contents of this file are subject to the terms of the
+ * Common Development and Distribution License (the "License").
+ * You may not use this file except in compliance with the License.
+ *
+ * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
+ * or http://www.opensolaris.org/os/licensing.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * When distributing Covered Code, include this CDDL HEADER in each
+ * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
+ * If applicable, add the following below this CDDL HEADER, with the
+ * fields enclosed by brackets "[]" replaced with your own identifying
+ * information: Portions Copyright [yyyy] [name of copyright owner]
+ *
+ * CDDL HEADER END
+ */
+
+/*
+ * Copyright 2013 Nexenta Systems, Inc.  All rights reserved.
+ */
+
+/*
+ * SRVSVC - Server Service (partial)
+ *
+ * This module needs only NetShareEnum (levels 0, 1)
+ * and NetServerGetInfo (levels 100, 101)
+ */
+
+#include <libmlrpc/ndrtypes.ndl>
+
+/*
+ * SRVSVC - Server Service
+ */
+
+#define SRVSVC_OPNUM_NetShareEnum                0x0f
+#define SRVSVC_OPNUM_NetServerGetInfo            0x15
+
+/*
+ * SRVSVC NetShareEnum (
+ *	IN  LPTSTR	servername,
+ *	IN  DWORD	level;
+ *	OUT union switch(level) {
+ *		case 0: struct {
+ *				DWORD entriesread;
+ *			     [size_is(entriesread)]
+ *				_SHARE_INFO_0 *entries;
+ *			} *bufptr0;
+ *		case 1: struct {
+ *				DWORD entriesread;
+ *			     [size_is(entriesread)]
+ *				_SHARE_INFO_1 *entries;
+ *			} *bufptr1;
+ *		...
+ *	    }		bufptr,
+ *	IN  DWORD	prefmaxlen,
+ *	OUT DWORD	totalentries,
+ *	IN OUT DWORD ?*	resume_handle,
+ *	OUT DWORD	status
+ *      )
+ */
+
+struct mslm_NetShareInfo_0 {
+	LPTSTR shi0_netname;
+};
+struct mslm_NetShareInfo_0_result {
+	DWORD	entriesread;
+	SIZE_IS(entriesread)
+	struct mslm_NetShareInfo_0 *entries;
+};
+
+struct mslm_NetShareInfo_1 {
+	LPTSTR	shi1_netname;
+	DWORD	shi1_type; /* type of resource such as IPC$ */
+	LPTSTR	shi1_comment;
+};
+struct mslm_NetShareInfo_1_result {
+	DWORD	entriesread;
+	SIZE_IS(entriesread)
+	struct mslm_NetShareInfo_1 *entries;
+};
+
+union mslm_NetShareEnum_ru {
+	CASE(0)		struct mslm_NetShareInfo_0_result *bufptr0;
+	CASE(1)		struct mslm_NetShareInfo_1_result *bufptr1;
+	DEFAULT		char *nullptr;
+};
+struct mslm_NetShareEnum_result {
+	DWORD	level;
+	SWITCH(level)
+	union mslm_NetShareEnum_ru ru;
+};
+
+
+OPERATION(SRVSVC_OPNUM_NetShareEnum)
+struct mslm_NetShareEnum {
+	IN		LPTSTR	servername;
+	INOUT		DWORD	level;
+	INOUT		struct mslm_NetShareEnum_result result;
+	IN		DWORD	prefmaxlen;
+	OUT		DWORD	totalentries;
+	INOUT		DWORD	*resume_handle;
+	OUT		DWORD	status;
+};
+
+
+/*
+ * SRVSVC NetServerGetInfo (
+ *	IN LPTSTR	servername,
+ *	IN DWORD	level,
+ *	OUT union switch(level) {
+ *		case 100: _SERVER_INFO_100 *	p100;
+ *		case 101: _SERVER_INFO_101 *	p101;
+ *		case 102: _SERVER_INFO_102 *	p102;
+ *	    }		bufptr,
+ *	OUT DWORD	status
+ *      )
+ */
+
+/* for svX_platform (note: decimal!) */
+#define	SV_PLATFORM_ID_DOS	300
+#define	SV_PLATFORM_ID_OS2	400
+#define	SV_PLATFORM_ID_NT	500
+#define	SV_PLATFORM_ID_OSF	600
+#define	SV_PLATFORM_ID_VMS	700
+
+struct mslm_SERVER_INFO_100 {
+	DWORD		sv100_platform_id;
+	LPTSTR		sv100_name;
+};
+
+struct mslm_SERVER_INFO_101 {
+	DWORD		sv101_platform_id;
+	LPTSTR		sv101_name;
+	DWORD		sv101_version_major;
+	DWORD		sv101_version_minor;
+	DWORD		sv101_type;
+	LPTSTR		sv101_comment;
+};
+
+union mslm_NetServerGetInfo_ru {
+	CASE(100)	struct mslm_SERVER_INFO_100 *info100;
+	CASE(101)	struct mslm_SERVER_INFO_101 *info101;
+	DEFAULT		char *nullptr;
+};
+
+struct mslm_NetServerGetInfo_result {
+	DWORD level;
+	SWITCH(level)
+	union mslm_NetServerGetInfo_ru ru;
+};
+
+
+OPERATION(SRVSVC_OPNUM_NetServerGetInfo)
+struct mslm_NetServerGetInfo {
+	IN  LPTSTR	servername;
+	IN  DWORD	level;
+	OUT struct mslm_NetServerGetInfo_result result;
+	OUT DWORD	status;
+};
+
+
+/*
+ * The SRVSVC interface
+ */
+INTERFACE(0)
+union srvsvc_interface {
+	CASE(SRVSVC_OPNUM_NetShareEnum)
+		struct mslm_NetShareEnum	NetShareEnum;
+	CASE(SRVSVC_OPNUM_NetServerGetInfo)
+		struct mslm_NetServerGetInfo	NetServerGetInfo;
+};
+typedef union srvsvc_interface	srvsvc_interface_t;
+EXTERNTYPEINFO(srvsvc_interface)
diff --git a/usr/src/cmd/fs.d/smbclnt/smbutil/srvsvc1_clnt.c b/usr/src/cmd/fs.d/smbclnt/smbutil/srvsvc1_clnt.c
new file mode 100644
index 0000000000..7ebe614ab6
--- /dev/null
+++ b/usr/src/cmd/fs.d/smbclnt/smbutil/srvsvc1_clnt.c
@@ -0,0 +1,138 @@
+/*
+ * CDDL HEADER START
+ *
+ * The contents of this file are subject to the terms of the
+ * Common Development and Distribution License (the "License").
+ * You may not use this file except in compliance with the License.
+ *
+ * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
+ * or http://www.opensolaris.org/os/licensing.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * When distributing Covered Code, include this CDDL HEADER in each
+ * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
+ * If applicable, add the following below this CDDL HEADER, with the
+ * fields enclosed by brackets "[]" replaced with your own identifying
+ * information: Portions Copyright [yyyy] [name of copyright owner]
+ *
+ * CDDL HEADER END
+ */
+
+/*
+ * Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
+ * Use is subject to license terms.
+ *
+ * Copyright 2013 Nexenta Systems, Inc.  All rights reserved.
+ */
+
+/*
+ * A few excerpts from lib/smbsrv/libmlsvc
+ * See longer comment in srvsvc1.ndl
+ */
+
+#include <sys/errno.h>
+#include <stdio.h>
+#include <time.h>
+#include <strings.h>
+#include <time.h>
+
+#include <libmlrpc/libmlrpc.h>
+#include "srvsvc1_clnt.h"
+
+static ndr_service_t srvsvc_service = {
+	"SRVSVC",			/* name */
+	"Server services",		/* desc */
+	"\\srvsvc",			/* endpoint */
+	"\\PIPE\\ntsvcs",		/* sec_addr_port */
+	"4b324fc8-1670-01d3-1278-5a47bf6ee188", 3,	/* abstract */
+	NDR_TRANSFER_SYNTAX_UUID,		2,	/* transfer */
+	0,				/* no bind_instance_size */
+	0,				/* no bind_req() */
+	0,				/* no unbind_and_close() */
+	0,				/* use generic_call_stub() */
+	&TYPEINFO(srvsvc_interface),	/* interface_ti */
+	NULL				/* stub_table */
+};
+
+/*
+ * srvsvc_initialize
+ *
+ * This function registers the SRVSVC RPC interface with the RPC runtime
+ * library. It must be called in order to use either the client side
+ * or the server side functions.
+ */
+void
+srvsvc1_initialize(void)
+{
+	static int init_done;
+	if (init_done)
+		return;
+	init_done = 1;
+	(void) ndr_svc_register(&srvsvc_service);
+}
+
+/*
+ * Client-side stub for NetServerGetInfo
+ */
+int
+srvsvc_net_server_getinfo(mlrpc_handle_t *handle, char *server,
+	int level, union mslm_NetServerGetInfo_ru *resp)
+{
+	struct mslm_NetServerGetInfo arg;
+	int len, opnum, rc;
+
+	opnum = SRVSVC_OPNUM_NetServerGetInfo;
+	bzero(&arg, sizeof (arg));
+
+	len = strlen(server) + 4;
+	arg.servername = ndr_rpc_malloc(handle, len);
+	if (arg.servername == NULL)
+		return (ENOMEM);
+
+	(void) snprintf((char *)arg.servername, len, "\\\\%s", server);
+	arg.level = level;
+
+	rc = ndr_rpc_call(handle, opnum, &arg);
+	if ((rc != 0) || (arg.status != 0))
+		return (EIO);
+
+	*resp = arg.result.ru;
+	return (0);
+}
+
+/*
+ * Client-side stub for NetShareEnum
+ */
+int
+srvsvc_net_share_enum(mlrpc_handle_t *handle, char *server,
+	int level, union mslm_NetShareEnum_ru *resp)
+{
+	/* Any enum result type is OK for nres. */
+	struct mslm_NetShareInfo_0_result nres;
+	struct mslm_NetShareEnum arg;
+	int len, opnum, rc;
+
+	opnum = SRVSVC_OPNUM_NetShareEnum;
+	bzero(&nres, sizeof (nres));
+	bzero(&arg, sizeof (arg));
+
+	len = strlen(server) + 4;
+	arg.servername = ndr_rpc_malloc(handle, len);
+	if (arg.servername == NULL)
+		return (ENOMEM);
+
+	(void) snprintf((char *)arg.servername, len, "\\\\%s", server);
+	arg.level = level;
+	arg.result.level = level;
+	arg.result.ru.bufptr0 = &nres;
+	arg.prefmaxlen = 0xFFFFFFFF;
+	arg.resume_handle = NULL;
+
+	rc = ndr_rpc_call(handle, opnum, &arg);
+	if ((rc != 0) || (arg.status != 0))
+		return (EIO);
+
+	*resp = arg.result.ru;
+	return (0);
+}
diff --git a/usr/src/cmd/fs.d/smbclnt/smbutil/srvsvc1_clnt.h b/usr/src/cmd/fs.d/smbclnt/smbutil/srvsvc1_clnt.h
new file mode 100644
index 0000000000..66e50a8ab5
--- /dev/null
+++ b/usr/src/cmd/fs.d/smbclnt/smbutil/srvsvc1_clnt.h
@@ -0,0 +1,46 @@
+/*
+ * CDDL HEADER START
+ *
+ * The contents of this file are subject to the terms of the
+ * Common Development and Distribution License (the "License").
+ * You may not use this file except in compliance with the License.
+ *
+ * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
+ * or http://www.opensolaris.org/os/licensing.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * When distributing Covered Code, include this CDDL HEADER in each
+ * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
+ * If applicable, add the following below this CDDL HEADER, with the
+ * fields enclosed by brackets "[]" replaced with your own identifying
+ * information: Portions Copyright [yyyy] [name of copyright owner]
+ *
+ * CDDL HEADER END
+ */
+
+/*
+ * Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
+ * Use is subject to license terms.
+ *
+ * Copyright 2013 Nexenta Systems, Inc.  All rights reserved.
+ */
+
+#ifndef _SRVSVC1_CLNT_H
+#define	_SRVSVC1_CLNT_H
+
+/*
+ * Excerpts from lib/smbsrv/libmlsvc
+ * Just enough for share enumeration.
+ */
+
+#include <libmlrpc/libmlrpc.h>
+#include "srvsvc1.ndl"
+
+void srvsvc1_initialize(void);
+int srvsvc_net_share_enum(mlrpc_handle_t *handle, char *server,
+	int level, union mslm_NetShareEnum_ru *resp);
+int srvsvc_net_server_getinfo(mlrpc_handle_t *handle, char *server,
+	int level, union mslm_NetServerGetInfo_ru *resp);
+
+#endif	/* _SRVSVC1_CLNT_H */
diff --git a/usr/src/cmd/fs.d/smbclnt/smbutil/view.c b/usr/src/cmd/fs.d/smbclnt/smbutil/view.c
index baad53b00c..8622fb14be 100644
--- a/usr/src/cmd/fs.d/smbclnt/smbutil/view.c
+++ b/usr/src/cmd/fs.d/smbclnt/smbutil/view.c
@@ -34,6 +34,7 @@
 
 /*
  * Copyright (c) 2008, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright 2013 Nexenta Systems, Inc.  All rights reserved.
  */
 
 #include <sys/types.h>
@@ -48,12 +49,9 @@
 
 #include <netsmb/smb.h>
 #include <netsmb/smb_lib.h>
-#include <netsmb/smb_netshareenum.h>
-
 #include "common.h"
 
-int enum_shares(smb_ctx_t *);
-void print_shares(int, int, struct share_info *);
+static int use_rap;
 
 void
 view_usage(void)
@@ -79,18 +77,27 @@ cmd_view(int argc, char *argv[])
 	error = smb_ctx_scan_argv(ctx, argc, argv,
 	    SMBL_SERVER, SMBL_SERVER, USE_WILDCARD);
 	if (error)
-		return (error);
+		goto out;
 
 	error = smb_ctx_readrc(ctx);
 	if (error)
-		return (error);
+		goto out;
 
 	while ((opt = getopt(argc, argv, STDPARAM_OPT)) != EOF) {
 		if (opt == '?')
 			view_usage();
+		/*
+		 * This is an undocumented option, just for testing.
+		 * Use the old LanMan Remote API Protocol (RAP) for
+		 * enumerating shares.
+		 */
+		if (opt == 'B') {
+			use_rap++;
+			continue;
+		}
 		error = smb_ctx_opt(ctx, opt, optarg);
 		if (error)
-			return (error);
+			goto out;
 	}
 
 	smb_ctx_setshare(ctx, "IPC$", USE_IPC);
@@ -101,7 +108,7 @@ cmd_view(int argc, char *argv[])
 	 */
 	error = smb_ctx_resolve(ctx);
 	if (error)
-		return (error);
+		goto out;
 
 	/*
 	 * Have server, share, etc. from above:
@@ -118,24 +125,26 @@ again:
 	if (error) {
 		smb_error(gettext("//%s: login failed"),
 		    error, ctx->ct_fullserver);
-		return (error);
+		goto out;
 	}
 
 	error = smb_ctx_get_tree(ctx);
 	if (error) {
 		smb_error(gettext("//%s/%s: tree connect failed"),
 		    error, ctx->ct_fullserver, ctx->ct_origshare);
-		return (error);
+		goto out;
 	}
 
 	/*
 	 * Have IPC$ tcon, now list shares.
-	 * This prints its own errors.
+	 * Try RPC; if that fails, do RAP.
 	 */
-	error = enum_shares(ctx);
-	if (error)
-		return (error);
+	if (!use_rap)
+		error = share_enum_rpc(ctx, ctx->ct_fullserver);
+	if (error || use_rap)
+		error = share_enum_rap(ctx);
 
+out:
 	smb_ctx_free(ctx);
 	return (0);
 }
@@ -145,7 +154,7 @@ static char *shtype[] = {
 	gettext("disk"),
 	gettext("printer"),
 	gettext("device"),	/* Communications device */
-	gettext("IPC"), 	/* Inter process communication */
+	gettext("IPC"),		/* Inter process communication */
 	gettext("unknown")
 };
 #else
@@ -153,53 +162,34 @@ static char *shtype[] = {
 	"disk",
 	"printer",
 	"device",		/* Communications device */
-	"IPC",  		/* IPC Inter process communication */
+	"IPC",			/* IPC Inter process communication */
 	"unknown"
 };
 #endif
 
-int
-enum_shares(smb_ctx_t *ctx)
+/*
+ * Print one line of the share list, or
+ * if SHARE is null, print the header line.
+ */
+void
+view_print_share(char *share, int type, char *comment)
 {
-	struct share_info *share_info;
-	int error, entries, total;
+	char *stname;
+	int stindex;
 
-	/*
-	 * XXX: Later, try RPC first,
-	 * then fall back to RAP...
-	 */
-	error = smb_netshareenum(ctx, &entries, &total, &share_info);
-	if (error) {
-		smb_error(gettext("//%s failed to list shares"),
-		    error, ctx->ct_fullserver);
-		return (error);
+	if (share == NULL) {
+		printf(gettext("Share        Type       Comment\n"));
+		printf("-------------------------------\n");
+		return;
 	}
-	print_shares(entries, total, share_info);
-	return (0);
-}
 
-void
-print_shares(int entries, int total,
-	struct share_info *share_info)
-{
-	struct share_info *ep;
-	int i;
-
-	printf(gettext("Share        Type       Comment\n"));
-	printf("-------------------------------\n");
-
-	for (ep = share_info, i = 0; i < entries; i++, ep++) {
-		int sti = ep->type & STYPE_MASK;
-		if (sti > STYPE_UNKNOWN)
-			sti = STYPE_UNKNOWN;
-		printf("%-12s %-10s %s\n", ep->netname,
-		    gettext(shtype[sti]),
-		    ep->remark ? ep->remark : "");
-		free(ep->netname);
-		free(ep->remark);
-	}
-	printf(gettext("\n%d shares listed from %d available\n"),
-	    entries, total);
+	stindex = type & STYPE_MASK;
+	if (stindex > STYPE_UNKNOWN)
+		stindex = STYPE_UNKNOWN;
+	stname = gettext(shtype[stindex]);
+
+	if (comment == NULL)
+		comment = "";
 
-	free(share_info);
+	printf("%-12s %-10s %s\n", share, stname, comment);
 }
diff --git a/usr/src/cmd/ipf/tools/ip_fil.c b/usr/src/cmd/ipf/tools/ip_fil.c
index 0736074059..7219d1de05 100644
--- a/usr/src/cmd/ipf/tools/ip_fil.c
+++ b/usr/src/cmd/ipf/tools/ip_fil.c
@@ -7,8 +7,13 @@
  * Use is subject to license terms.
  */
 
-#ifndef	SOLARIS
-#define	SOLARIS	(defined(sun) && (defined(__svr4__) || defined(__SVR4)))
+#ifdef SOLARIS
+#undef	SOLARIS
+#endif
+#if (defined(sun) && (defined(__svr4__) || defined(__SVR4)))
+#define	SOLARIS	(1)
+#else
+#define	SOLARIS	(0)
 #endif
 
 #include <sys/param.h>
diff --git a/usr/src/cmd/ipf/tools/ipmon.c b/usr/src/cmd/ipf/tools/ipmon.c
index 398730f08e..b6904f4cda 100644
--- a/usr/src/cmd/ipf/tools/ipmon.c
+++ b/usr/src/cmd/ipf/tools/ipmon.c
@@ -9,9 +9,13 @@
  * Copyright (c) 2014, Joyent, Inc.  All rights reserved.
  */
 
-
-#ifndef SOLARIS
-#define SOLARIS (defined(__SVR4) || defined(__svr4__)) && defined(sun)
+#ifdef SOLARIS
+#undef	SOLARIS
+#endif
+#if (defined(sun) && (defined(__svr4__) || defined(__SVR4)))
+#define	SOLARIS	(1)
+#else
+#define	SOLARIS	(0)
 #endif
 
 #include <sys/types.h>
diff --git a/usr/src/cmd/mdb/common/modules/genunix/memory.c b/usr/src/cmd/mdb/common/modules/genunix/memory.c
index fa4918b9b8..f127adb850 100644
--- a/usr/src/cmd/mdb/common/modules/genunix/memory.c
+++ b/usr/src/cmd/mdb/common/modules/genunix/memory.c
@@ -20,7 +20,7 @@
  */
 /*
  * Copyright (c) 2001, 2010, Oracle and/or its affiliates. All rights reserved.
- * Copyright 2017 Joyent, Inc.
+ * Copyright 2018 Joyent, Inc.
  */
 
 #include <mdb/mdb_param.h>
@@ -443,11 +443,11 @@ vn_get(vn_htable_t *hp, struct vnode *vp, uintptr_t ptr)
 
 /* Summary statistics of pages */
 typedef struct memstat {
-	struct vnode    *ms_kvp;	/* Cached address of kernel vnode */
 	struct vnode    *ms_unused_vp;	/* Unused pages vnode pointer	  */
-	struct vnode    *ms_zvp;	/* Cached address of zio vnode    */
+	struct vnode    *ms_kvps;	/* Cached address of vnode array  */
 	uint64_t	ms_kmem;	/* Pages of kernel memory	  */
 	uint64_t	ms_zfs_data;	/* Pages of zfs data		  */
+	uint64_t	ms_vmm_mem;	/* Pages of VMM mem		  */
 	uint64_t	ms_anon;	/* Pages of anonymous memory	  */
 	uint64_t	ms_vnode;	/* Pages of named (vnode) memory  */
 	uint64_t	ms_exec;	/* Pages of exec/library memory	  */
@@ -458,11 +458,8 @@ typedef struct memstat {
 	struct vnode	ms_vn;		/* vnode buffer			  */
 } memstat_t;
 
-#define	MS_PP_ISKAS(pp, stats)				\
-	((pp)->p_vnode == (stats)->ms_kvp)
-
-#define	MS_PP_ISZFS_DATA(pp, stats)			\
-	(((stats)->ms_zvp != NULL) && ((pp)->p_vnode == (stats)->ms_zvp))
+#define	MS_PP_ISTYPE(pp, stats, index) \
+	((pp)->p_vnode == &(stats->ms_kvps[index]))
 
 /*
  * Summarize pages by type and update stat information
@@ -478,10 +475,12 @@ memstat_callback(page_t *page, page_t *pp, memstat_t *stats)
 		stats->ms_bootpages++;
 	else if (pp->p_vnode == NULL || pp->p_vnode == stats->ms_unused_vp)
 		return (WALK_NEXT);
-	else if (MS_PP_ISKAS(pp, stats))
+	else if (MS_PP_ISTYPE(pp, stats, KV_KVP))
 		stats->ms_kmem++;
-	else if (MS_PP_ISZFS_DATA(pp, stats))
+	else if (MS_PP_ISTYPE(pp, stats, KV_ZVP))
 		stats->ms_zfs_data++;
+	else if (MS_PP_ISTYPE(pp, stats, KV_VVP))
+		stats->ms_vmm_mem++;
 	else if (PP_ISFREE(pp))
 		stats->ms_cachelist++;
 	else if (vn_get(stats->ms_vn_htable, vp, (uintptr_t)pp->p_vnode))
@@ -507,7 +506,6 @@ memstat(uintptr_t addr, uint_t flags, int argc, const mdb_arg_t *argv)
 	memstat_t stats;
 	GElf_Sym sym;
 	vn_htable_t ht;
-	struct vnode *kvps;
 	uintptr_t vn_size = 0;
 #if defined(__i386) || defined(__amd64)
 	bln_stats_t bln_stats;
@@ -548,16 +546,10 @@ memstat(uintptr_t addr, uint_t flags, int argc, const mdb_arg_t *argv)
 	/* read kernel vnode array pointer */
 	if (mdb_lookup_by_obj(MDB_OBJ_EXEC, "kvps",
 	    (GElf_Sym *)&sym) == -1) {
-		mdb_warn("unable to read kvps");
+		mdb_warn("unable to look up kvps");
 		return (DCMD_ERR);
 	}
-	kvps = (struct vnode *)(uintptr_t)sym.st_value;
-	stats.ms_kvp =  &kvps[KV_KVP];
-
-	/*
-	 * Read the zio vnode pointer.
-	 */
-	stats.ms_zvp = &kvps[KV_ZVP];
+	stats.ms_kvps = (struct vnode *)(uintptr_t)sym.st_value;
 
 	/*
 	 * If physmem != total_pages, then the administrator has limited the
@@ -605,6 +597,13 @@ memstat(uintptr_t addr, uint_t flags, int argc, const mdb_arg_t *argv)
 		    MS_PCT_TOTAL(stats.ms_zfs_data));
 	}
 
+	if (stats.ms_vmm_mem != 0) {
+		mdb_printf("VMM Memory       %16llu  %16llu  %3lu%%\n",
+		    stats.ms_vmm_mem,
+		    (uint64_t)stats.ms_vmm_mem * PAGESIZE / (1024 * 1024),
+		    MS_PCT_TOTAL(stats.ms_vmm_mem));
+	}
+
 	mdb_printf("Anon             %16llu  %16llu  %3lu%%\n",
 	    stats.ms_anon,
 	    (uint64_t)stats.ms_anon * PAGESIZE / (1024 * 1024),
diff --git a/usr/src/cmd/mdb/common/modules/zfs/zfs.c b/usr/src/cmd/mdb/common/modules/zfs/zfs.c
index 06ce396ef8..ad66d688ea 100644
--- a/usr/src/cmd/mdb/common/modules/zfs/zfs.c
+++ b/usr/src/cmd/mdb/common/modules/zfs/zfs.c
@@ -21,8 +21,8 @@
 /*
  * Copyright (c) 2005, 2010, Oracle and/or its affiliates. All rights reserved.
  * Copyright 2011 Nexenta Systems, Inc. All rights reserved.
+ * Copyright (c) 2011, 2018 by Delphix. All rights reserved.
  * Copyright (c) 2017, Joyent, Inc.  All rights reserved.
- * Copyright (c) 2011, 2017 by Delphix. All rights reserved.
  */
 
 /* Portions Copyright 2010 Robert Milkowski */
@@ -178,55 +178,110 @@ mdb_nicenum(uint64_t num, char *buf)
 	}
 }
 
-static int verbose;
-
+/*
+ * <addr>::sm_entries <buffer length in bytes>
+ *
+ * Treat the buffer specified by the given address as a buffer that contains
+ * space map entries. Iterate over the specified number of entries and print
+ * them in both encoded and decoded form.
+ */
+/* ARGSUSED */
 static int
-freelist_walk_init(mdb_walk_state_t *wsp)
+sm_entries(uintptr_t addr, uint_t flags, int argc, const mdb_arg_t *argv)
 {
-	if (wsp->walk_addr == NULL) {
-		mdb_warn("must supply starting address\n");
-		return (WALK_ERR);
+	uint64_t bufsz = 0;
+	boolean_t preview = B_FALSE;
+
+	if (!(flags & DCMD_ADDRSPEC))
+		return (DCMD_USAGE);
+
+	if (argc < 1) {
+		preview = B_TRUE;
+		bufsz = 2;
+	} else if (argc != 1) {
+		return (DCMD_USAGE);
+	} else {
+		switch (argv[0].a_type) {
+		case MDB_TYPE_STRING:
+			bufsz = mdb_strtoull(argv[0].a_un.a_str);
+			break;
+		case MDB_TYPE_IMMEDIATE:
+			bufsz = argv[0].a_un.a_val;
+			break;
+		default:
+			return (DCMD_USAGE);
+		}
 	}
 
-	wsp->walk_data = 0;  /* Index into the freelist */
-	return (WALK_NEXT);
-}
+	char *actions[] = { "ALLOC", "FREE", "INVALID" };
+	for (uintptr_t bufend = addr + bufsz; addr < bufend;
+	    addr += sizeof (uint64_t)) {
+		uint64_t nwords;
+		uint64_t start_addr = addr;
 
-static int
-freelist_walk_step(mdb_walk_state_t *wsp)
-{
-	uint64_t entry;
-	uintptr_t number = (uintptr_t)wsp->walk_data;
-	char *ddata[] = { "ALLOC", "FREE", "CONDENSE", "INVALID",
-			    "INVALID", "INVALID", "INVALID", "INVALID" };
-	int mapshift = SPA_MINBLOCKSHIFT;
+		uint64_t word = 0;
+		if (mdb_vread(&word, sizeof (word), addr) == -1) {
+			mdb_warn("failed to read space map entry %p", addr);
+			return (DCMD_ERR);
+		}
 
-	if (mdb_vread(&entry, sizeof (entry), wsp->walk_addr) == -1) {
-		mdb_warn("failed to read freelist entry %p", wsp->walk_addr);
-		return (WALK_DONE);
-	}
-	wsp->walk_addr += sizeof (entry);
-	wsp->walk_data = (void *)(number + 1);
+		if (SM_PREFIX_DECODE(word) == SM_DEBUG_PREFIX) {
+			(void) mdb_printf("\t    [%6llu] %s: txg %llu, "
+			    "pass %llu\n",
+			    (u_longlong_t)(addr),
+			    actions[SM_DEBUG_ACTION_DECODE(word)],
+			    (u_longlong_t)SM_DEBUG_TXG_DECODE(word),
+			    (u_longlong_t)SM_DEBUG_SYNCPASS_DECODE(word));
+			continue;
+		}
 
-	if (SM_DEBUG_DECODE(entry)) {
-		mdb_printf("DEBUG: %3u  %10s: txg=%llu  pass=%llu\n",
-		    number,
-		    ddata[SM_DEBUG_ACTION_DECODE(entry)],
-		    SM_DEBUG_TXG_DECODE(entry),
-		    SM_DEBUG_SYNCPASS_DECODE(entry));
-	} else {
-		mdb_printf("Entry: %3u  offsets=%08llx-%08llx  type=%c  "
-		    "size=%06llx", number,
-		    SM_OFFSET_DECODE(entry) << mapshift,
-		    (SM_OFFSET_DECODE(entry) + SM_RUN_DECODE(entry)) <<
-		    mapshift,
-		    SM_TYPE_DECODE(entry) == SM_ALLOC ? 'A' : 'F',
-		    SM_RUN_DECODE(entry) << mapshift);
-		if (verbose)
-			mdb_printf("      (raw=%012llx)\n", entry);
-		mdb_printf("\n");
+		char entry_type;
+		uint64_t raw_offset, raw_run, vdev_id = SM_NO_VDEVID;
+
+		if (SM_PREFIX_DECODE(word) != SM2_PREFIX) {
+			entry_type = (SM_TYPE_DECODE(word) == SM_ALLOC) ?
+			    'A' : 'F';
+			raw_offset = SM_OFFSET_DECODE(word);
+			raw_run = SM_RUN_DECODE(word);
+			nwords = 1;
+		} else {
+			ASSERT3U(SM_PREFIX_DECODE(word), ==, SM2_PREFIX);
+
+			raw_run = SM2_RUN_DECODE(word);
+			vdev_id = SM2_VDEV_DECODE(word);
+
+			/* it is a two-word entry so we read another word */
+			addr += sizeof (uint64_t);
+			if (addr >= bufend) {
+				mdb_warn("buffer ends in the middle of a two "
+				    "word entry\n", addr);
+				return (DCMD_ERR);
+			}
+
+			if (mdb_vread(&word, sizeof (word), addr) == -1) {
+				mdb_warn("failed to read space map entry %p",
+				    addr);
+				return (DCMD_ERR);
+			}
+
+			entry_type = (SM2_TYPE_DECODE(word) == SM_ALLOC) ?
+			    'A' : 'F';
+			raw_offset = SM2_OFFSET_DECODE(word);
+			nwords = 2;
+		}
+
+		(void) mdb_printf("\t    [%6llx]    %c  range:"
+		    " %010llx-%010llx  size: %06llx vdev: %06llu words: %llu\n",
+		    (u_longlong_t)start_addr,
+		    entry_type, (u_longlong_t)raw_offset,
+		    (u_longlong_t)(raw_offset + raw_run),
+		    (u_longlong_t)raw_run,
+		    (u_longlong_t)vdev_id, (u_longlong_t)nwords);
+
+		if (preview)
+			break;
 	}
-	return (WALK_NEXT);
+	return (DCMD_OK);
 }
 
 static int
@@ -1672,6 +1727,7 @@ typedef struct mdb_metaslab_alloc_trace {
 	uint64_t mat_weight;
 	uint64_t mat_offset;
 	uint32_t mat_dva_id;
+	int mat_allocator;
 } mdb_metaslab_alloc_trace_t;
 
 static void
@@ -1744,8 +1800,9 @@ metaslab_trace(uintptr_t addr, uint_t flags, int argc, const mdb_arg_t *argv)
 	}
 
 	if (!(flags & DCMD_PIPE_OUT) && DCMD_HDRSPEC(flags)) {
-		mdb_printf("%<u>%6s %6s %8s %11s %18s %18s%</u>\n",
-		    "MSID", "DVA", "ASIZE", "WEIGHT", "RESULT", "VDEV");
+		mdb_printf("%<u>%6s %6s %8s %11s %11s %18s %18s%</u>\n",
+		    "MSID", "DVA", "ASIZE", "ALLOCATOR", "WEIGHT", "RESULT",
+		    "VDEV");
 	}
 
 	if (mat.mat_msp != NULL) {
@@ -1760,7 +1817,8 @@ metaslab_trace(uintptr_t addr, uint_t flags, int argc, const mdb_arg_t *argv)
 		mdb_printf("%6s ", "-");
 	}
 
-	mdb_printf("%6d %8llx ", mat.mat_dva_id, mat.mat_size);
+	mdb_printf("%6d %8llx %11llx ", mat.mat_dva_id, mat.mat_size,
+	    mat.mat_allocator);
 
 	metaslab_print_weight(mat.mat_weight);
 
@@ -3974,6 +4032,9 @@ static const mdb_dcmd_t dcmds[] = {
 	    "\t-M display metaslab group statistic\n"
 	    "\t-h display histogram (requires -m or -M)\n",
 	    "given a spa_t, print vdev summary", spa_vdevs },
+	{ "sm_entries", "<buffer length in bytes>",
+	    "print out space map entries from a buffer decoded",
+	    sm_entries},
 	{ "vdev", ":[-remMh]\n"
 	    "\t-r display recursively\n"
 	    "\t-e display statistics\n"
@@ -4024,8 +4085,6 @@ static const mdb_dcmd_t dcmds[] = {
 };
 
 static const mdb_walker_t walkers[] = {
-	{ "zms_freelist", "walk ZFS metaslab freelist",
-	    freelist_walk_init, freelist_walk_step, NULL },
 	{ "txg_list", "given any txg_list_t *, walk all entries in all txgs",
 	    txg_list_walk_init, txg_list_walk_step, NULL },
 	{ "txg_list0", "given any txg_list_t *, walk all entries in txg 0",
diff --git a/usr/src/cmd/mdb/intel/amd64/Makefile b/usr/src/cmd/mdb/intel/amd64/Makefile
index 7749b75f37..f7bc890fb5 100644
--- a/usr/src/cmd/mdb/intel/amd64/Makefile
+++ b/usr/src/cmd/mdb/intel/amd64/Makefile
@@ -21,12 +21,12 @@
 #
 # Copyright 2010 Sun Microsystems, Inc.  All rights reserved.
 # Use is subject to license terms.
-# Copyright 2017 Joyent, Inc.
+# Copyright 2018 Joyent, Inc.
 #
 
 include ../../Makefile.common
 
-MODULES = $(COMMON_MODULES_PROC) $(COMMON_MODULES_KVM) uhci vmm
+MODULES = $(COMMON_MODULES_PROC) $(COMMON_MODULES_KVM) uhci
 
 SUBDIRS = mdb mdb_ks kmdb libstandctf libstand .WAIT $(MODULES)
 
diff --git a/usr/src/cmd/mdb/intel/amd64/vmm/amd64/Makefile b/usr/src/cmd/mdb/intel/amd64/vmm/amd64/Makefile
deleted file mode 100644
index e61be22d2a..0000000000
--- a/usr/src/cmd/mdb/intel/amd64/vmm/amd64/Makefile
+++ /dev/null
@@ -1,35 +0,0 @@
-#
-# This file and its contents are supplied under the terms of the
-# Common Development and Distribution License ("CDDL"), version 1.0.
-# You may only use this file in accordance with the terms of version
-# 1.0 of the CDDL.
-#
-# A full copy of the text of the CDDL should have accompanied this
-# source.  A copy of the CDDL is also available via the Internet at
-# http://www.illumos.org/license/CDDL.
-#
-
-#
-# Copyright 2013 Pluribus Networks Inc.
-#
-
-MODULE = vmm.so
-MDBTGT = kvm
-
-MODSRCS = vmm.c
-
-include ../../../../../Makefile.cmd
-include ../../../../../Makefile.cmd.64
-include ../../../Makefile.amd64
-include ../../../../Makefile.module
-
-CPPFLAGS = -D_KERNEL -D_MACHDEP
-CPPFLAGS += -I$(COMPAT)/freebsd -I$(COMPAT)/freebsd/amd64
-CPPFLAGS += -I$(CONTRIB)/freebsd -I$(CONTRIB)/freebsd/amd64
-CPPFLAGS += -I$(SRC)/uts/common -I$(SRC)/uts/i86pc
-CPPFLAGS += -I$(SRC)/cmd/mdb/common
-
-#CPPFLAGS += -_cc=-xdryrun
-
-LINTTAGS += -erroff=E_FUNC_ARG_UNUSED
-LINTTAGS += -erroff=E_STATIC_UNUSED
diff --git a/usr/src/cmd/mdb/intel/amd64/vmm/vmm.c b/usr/src/cmd/mdb/intel/amd64/vmm/vmm.c
deleted file mode 100644
index 74c4ebc6c0..0000000000
--- a/usr/src/cmd/mdb/intel/amd64/vmm/vmm.c
+++ /dev/null
@@ -1,237 +0,0 @@
-/*
- * This file and its contents are supplied under the terms of the
- * Common Development and Distribution License ("CDDL"), version 1.0.
- * You may only use this file in accordance with the terms of version
- * 1.0 of the CDDL.
- *
- * A full copy of the text of the CDDL should have accompanied this
- * source.  A copy of the CDDL is also available via the Internet at
- * http://www.illumos.org/license/CDDL.
- */
-
-/*
- * Copyright 2014 Pluribus Networks Inc.
- */
-
-#include <sys/param.h>
-
-#include <mdb/mdb_modapi.h>
-#include <sys/cpuvar.h>
-#include <sys/varargs.h>
-#include <sys/vmm.h>
-#include <sys/vmm_impl.h>
-
-/*
- * VMM trace debug walker/dcmd code
- */
-
-/*
- * Initialize the vmm_trace_dmsg_t walker by either using the given starting
- * address, or reading the value of the kernel's vmm_debug_rbuf pointer.
- * We also allocate a vmm_trace_dmsg_t for storage, and save this using the
- * walk_data pointer.
- */
-static int
-vmm_dmsg_walk_i(mdb_walk_state_t *wsp)
-{
-	uintptr_t rbuf_addr;
-	vmm_trace_rbuf_t rbuf;
-
-	if (wsp->walk_addr == NULL) {
-		if (mdb_readvar(&rbuf_addr, "vmm_debug_rbuf") == -1) {
-			mdb_warn("failed to read 'vmm_debug_rbuf'");
-			return (WALK_ERR);
-		}
-
-		if (mdb_vread(&rbuf, sizeof (vmm_trace_rbuf_t), rbuf_addr)
-		    == -1) {
-			mdb_warn("failed to read vmm_trace_rbuf_t at %p",
-			    rbuf_addr);
-			return (WALK_ERR);
-		}
-
-		wsp->walk_addr = (uintptr_t)(vmm_trace_dmsg_t *)rbuf.dmsgh;
-	}
-
-	/*
-	 * Save ptr to head of ring buffer to prevent looping.
-	 */
-	wsp->walk_arg = (void *)wsp->walk_addr;
-	wsp->walk_data = mdb_alloc(sizeof (vmm_trace_dmsg_t), UM_SLEEP);
-	return (WALK_NEXT);
-}
-
-/*
- * At each step, read a vmm_trace_dmsg_t into our private storage, and then
- * invoke the callback function.  We terminate when we reach a NULL next
- * pointer.
- */
-static int
-vmm_dmsg_walk_s(mdb_walk_state_t *wsp)
-{
-	int status;
-
-	if (wsp->walk_addr == NULL)
-		return (WALK_DONE);
-
-	if (mdb_vread(wsp->walk_data, sizeof (vmm_trace_dmsg_t),
-	    wsp->walk_addr) == -1) {
-		mdb_warn("failed to read vmm_trace_dmsg_t at %p",
-		    wsp->walk_addr);
-		return (WALK_ERR);
-	}
-
-	status = wsp->walk_callback(wsp->walk_addr, wsp->walk_data,
-	    wsp->walk_cbdata);
-
-	wsp->walk_addr =
-	    (uintptr_t)(((vmm_trace_dmsg_t *)wsp->walk_data)->next);
-
-	/*
-	 * If we've looped then we're done.
-	 */
-	if (wsp->walk_addr == (uintptr_t)wsp->walk_arg)
-		wsp->walk_addr = NULL;
-
-	return (status);
-}
-
-/*
- * The walker's fini function is invoked at the end of each walk.  Since we
- * dynamically allocated a vmm_trace_dmsg_t in vmm_dmsg_walk_i, we must
- * free it now.
- */
-static void
-vmm_dmsg_walk_f(mdb_walk_state_t *wsp)
-{
-	mdb_free(wsp->walk_data, sizeof (vmm_trace_dmsg_t));
-}
-
-/*
- * This routine is used by the vmm_dmsg_dump dcmd to dump content of
- * VMM trace ring buffer.
- */
-int
-vmm_dmsg_dump(vmm_trace_dmsg_t *addr, int print_pathname, uint_t *printed)
-{
-	vmm_trace_dmsg_t	dmsg, *dmsgh = addr;
-	char			merge[1024];
-
-	while (addr != NULL) {
-		if (mdb_vread(&dmsg, sizeof (dmsg), (uintptr_t)addr) !=
-		    sizeof (dmsg)) {
-			mdb_warn("failed to read message pointer in kernel");
-			return (DCMD_ERR);
-		}
-
-		(void) mdb_snprintf(merge, sizeof (merge),
-		    "[%Y:%03d:%03d:%03d] : %s",
-		    dmsg.timestamp.tv_sec,
-		    (int)dmsg.timestamp.tv_nsec/1000000,
-		    (int)(dmsg.timestamp.tv_nsec/1000)%1000,
-		    (int)dmsg.timestamp.tv_nsec%1000,
-		    dmsg.buf);
-
-		mdb_printf("%s", merge);
-
-		if (printed != NULL) {
-			(*printed)++;
-		}
-
-		if (((addr = dmsg.next) == NULL) || (dmsg.next == dmsgh)) {
-			break;
-		}
-	}
-
-	return (DCMD_OK);
-}
-
-/*
- * 1. Process flag passed to vmm_dmsg_dump dcmd.
- * 2. Obtain VMM trace ring buffer pointer.
- * 3. Pass VMM trace ring buffer pointer to vmm_dmsg_dump()
- *    to dump content of VMM trace ring buffer.
- */
-int
-vmm_rbuf_dump(uintptr_t addr, uint_t flags, int argc, const mdb_arg_t *argv)
-{
-	vmm_trace_rbuf_t	rbuf;
-	uint_t		printed = 0; /* have we printed anything? */
-	int		print_pathname = FALSE;
-	int		rval = DCMD_OK;
-
-	if (argc > 1) {
-		return (DCMD_USAGE);
-	}
-
-	if (mdb_getopts(argc, argv,
-	    'a', MDB_OPT_SETBITS, TRUE, &print_pathname) != argc) {
-		return (DCMD_USAGE);
-	}
-
-	/*
-	 * If ring buffer address not provided try to obtain
-	 * it using vmm_debug_rbuf global.
-	 */
-	if ((addr == NULL) || !(flags & DCMD_ADDRSPEC)) {
-		if (mdb_readvar(&addr, "vmm_debug_rbuf") == -1) {
-			mdb_warn("Failed to read 'vmm_debug_rbuf'.");
-			return (DCMD_ERR);
-		}
-	}
-
-	if (mdb_vread(&rbuf, sizeof (rbuf), addr) != sizeof (rbuf)) {
-		mdb_warn("Failed to read ring buffer in kernel.");
-		return (DCMD_ERR);
-	}
-
-	if (rbuf.dmsgh == NULL) {
-		mdb_printf("The vmm trace ring buffer is empty.\n");
-		return (DCMD_OK);
-	}
-
-	rval = vmm_dmsg_dump((vmm_trace_dmsg_t *)rbuf.dmsgh,
-	    print_pathname, &printed);
-
-	if (rval != DCMD_OK) {
-		return (rval);
-	}
-
-	if (printed == 0) {
-		mdb_warn("Failed to read vmm trace ring buffer.");
-		return (DCMD_ERR);
-	}
-
-	return (rval);
-}
-
-/*
- * MDB module linkage information:
- *
- * We declare a list of structures describing our dcmds, a list of structures
- * describing our walkers, and a function named _mdb_init to return a pointer
- * to our module information.
- */
-
-static const mdb_dcmd_t dcmds[] = {
-	{ "vmm_dmsg_dump", "[-a]", "Dump vmm trace debug messages",
-	    vmm_rbuf_dump },
-	{ NULL }
-};
-
-static const mdb_walker_t walkers[] = {
-	{ "vmm_dmsg",
-	    "walk ring buffer containing vmm trace debug messages",
-	    vmm_dmsg_walk_i, vmm_dmsg_walk_s, vmm_dmsg_walk_f },
-	{ NULL }
-};
-
-static const mdb_modinfo_t modinfo = {
-	MDB_API_VERSION, dcmds, walkers
-};
-
-const mdb_modinfo_t *
-_mdb_init(void)
-{
-	return (&modinfo);
-}
diff --git a/usr/src/cmd/policykit/polkit-is-privileged.c b/usr/src/cmd/policykit/polkit-is-privileged.c
index 85116cf3d0..b1a2006a95 100644
--- a/usr/src/cmd/policykit/polkit-is-privileged.c
+++ b/usr/src/cmd/policykit/polkit-is-privileged.c
@@ -181,6 +181,7 @@ main (int argc, char *argv[])
 
 	case LIBPOLKIT_RESULT_NOT_PRIVILEGED:
 		g_print ("Not privileged.\n");
+		goto out;
 
 	case LIBPOLKIT_RESULT_NO_SUCH_PRIVILEGE:
 		g_print ("No such privilege '%s'.\n", privilege);
diff --git a/usr/src/cmd/pools/poolstat/poolstat.c b/usr/src/cmd/pools/poolstat/poolstat.c
index b52b68427f..a809a7fd45 100644
--- a/usr/src/cmd/pools/poolstat/poolstat.c
+++ b/usr/src/cmd/pools/poolstat/poolstat.c
@@ -160,6 +160,8 @@ static void sa_update(statistic_bag_t *, int);
 /* statistics printing function	*/
 static void prt_pool_stats(poolstat_list_element_t *);
 
+static void usage(void) __NORETURN;
+
 static void
 usage(void)
 {
diff --git a/usr/src/cmd/pptadm/Makefile b/usr/src/cmd/pptadm/Makefile
new file mode 100644
index 0000000000..8ca198a702
--- /dev/null
+++ b/usr/src/cmd/pptadm/Makefile
@@ -0,0 +1,34 @@
+#
+# This file and its contents are supplied under the terms of the
+# Common Development and Distribution License ("CDDL"), version 1.0.
+# You may only use this file in accordance with the terms of version
+# 1.0 of the CDDL.
+#
+# A full copy of the text of the CDDL should have accompanied this
+# source.  A copy of the CDDL is also available via the Internet at
+# http://www.illumos.org/license/CDDL.
+#
+# Copyright 2018 Joyent, Inc.
+#
+
+PROG = pptadm
+SRCS = $(PROG).c
+
+include ../Makefile.cmd
+
+LDLIBS += -lofmt -lppt -lnvpair
+
+CSTD = $(CSTD_GNU99)
+C99LMODE = -Xc99=%all
+
+.KEEP_STATE:
+
+all: $(PROG)
+
+install: all $(ROOTUSRSBINPROG)
+
+clean:
+
+lint: lint_SRCS
+
+include ../Makefile.targ
diff --git a/usr/src/cmd/pptadm/pptadm.c b/usr/src/cmd/pptadm/pptadm.c
new file mode 100644
index 0000000000..b6b0842478
--- /dev/null
+++ b/usr/src/cmd/pptadm/pptadm.c
@@ -0,0 +1,218 @@
+/*
+ * This file and its contents are supplied under the terms of the
+ * Common Development and Distribution License ("CDDL"), version 1.0.
+ * You may only use this file in accordance with the terms of version
+ * 1.0 of the CDDL.
+ *
+ * A full copy of the text of the CDDL should have accompanied this
+ * source.  A copy of the CDDL is also available via the Internet at
+ * http://www.illumos.org/license/CDDL.
+ *
+ * Copyright 2018 Joyent, Inc.
+ */
+
+#include <stdlib.h>
+#include <stdarg.h>
+#include <getopt.h>
+#include <string.h>
+#include <ofmt.h>
+
+#include <libppt.h>
+
+typedef enum field {
+	PPT_DEV,
+	PPT_VENDOR,
+	PPT_DEVICE,
+	PPT_SUBVENDOR,
+	PPT_SUBDEVICE,
+	PPT_REV,
+	PPT_PATH,
+	PPT_LABEL
+} field_t;
+
+const char *valname[] = {
+	"dev",
+	"vendor-id",
+	"device-id",
+	"subsystem-vendor-id",
+	"subsystem-id",
+	"revision-id",
+	"path",
+	"label"
+};
+
+static ofmt_cb_t print_field;
+
+static ofmt_field_t fields[] = {
+/* name,	field width, index, callback */
+{ "DEV",	sizeof ("/dev/pptXX"), PPT_DEV, print_field },
+{ "VENDOR",	sizeof ("VENDOR"), PPT_VENDOR, print_field },
+{ "DEVICE",	sizeof ("DEVICE"), PPT_DEVICE, print_field },
+{ "SUBVENDOR",	sizeof ("SUBVENDOR"), PPT_SUBVENDOR, print_field },
+{ "SUBDEVICE",	sizeof ("SUBDEVICE"), PPT_SUBDEVICE, print_field },
+{ "REV",	sizeof ("REV"), PPT_REV, print_field },
+{ "PATH",	50, PPT_PATH, print_field },
+{ "LABEL",	60, PPT_LABEL, print_field },
+{ NULL,		0, 0, NULL },
+};
+
+static void
+usage(boolean_t is_err)
+{
+	(void) fprintf(is_err ? stderr : stdout,
+	    "Usage:\n"
+	    "pptadm list [ -j ]\n"
+	    "pptadm list [-ap] [-o fields]\n");
+	exit(is_err ? EXIT_FAILURE : EXIT_SUCCESS);
+}
+
+/* PRINTFLIKE1 */
+static void
+die(const char *fmt, ...)
+{
+	va_list alist;
+
+	(void) fprintf(stderr, "pptadm: ");
+
+	va_start(alist, fmt);
+	(void) vfprintf(stderr, fmt, alist);
+	va_end(alist);
+
+	(void) putc('\n', stderr);
+
+	exit(EXIT_FAILURE);
+}
+
+/* PRINTFLIKE1 */
+static void
+warn(const char *fmt, ...)
+{
+	va_list alist;
+
+	(void) fprintf(stderr, "pptadm: ");
+
+	va_start(alist, fmt);
+	(void) vfprintf(stderr, fmt, alist);
+	va_end(alist);
+
+	(void) putc('\n', stderr);
+}
+
+static boolean_t
+print_field(ofmt_arg_t *arg, char *buf, uint_t bufsize)
+{
+	nvlist_t *nvl = arg->ofmt_cbarg;
+	nvpair_t *nvp = NULL;
+
+	while ((nvp = nvlist_next_nvpair(nvl, nvp)) != NULL) {
+		const char *name = nvpair_name(nvp);
+		char *val;
+
+		(void) nvpair_value_string(nvp, &val);
+
+		if (strcmp(name, valname[arg->ofmt_id]) != 0)
+			continue;
+
+		(void) snprintf(buf, bufsize, "%s", val);
+		return (B_TRUE);
+	}
+
+	(void) snprintf(buf, bufsize, "--");
+	return (B_TRUE);
+}
+
+static int
+list(int argc, char *argv[])
+{
+	const char *fields_str = NULL;
+	boolean_t parsable = B_FALSE;
+	boolean_t json = B_FALSE;
+	boolean_t all = B_FALSE;
+	uint_t ofmtflags = 0;
+	ofmt_status_t oferr;
+	ofmt_handle_t ofmt;
+	int opt;
+
+	while ((opt = getopt(argc, argv, "ajo:p?")) != -1) {
+		switch (opt) {
+		case 'a':
+			all = B_TRUE;
+			break;
+		case 'j':
+			json = B_TRUE;
+			break;
+		case 'o':
+			fields_str = optarg;
+			break;
+		case 'p':
+			ofmtflags |= OFMT_PARSABLE;
+			parsable = B_TRUE;
+			break;
+		case '?':
+			usage(B_FALSE);
+			break;
+		default:
+			usage(B_TRUE);
+			break;
+		}
+	}
+
+	if (optind == (argc - 1))
+		usage(B_TRUE);
+
+	if (json && (parsable || fields_str != NULL))
+		usage(B_TRUE);
+
+	if (fields_str == NULL) {
+		if (parsable)
+			usage(B_TRUE);
+		fields_str = "dev,vendor,device,path";
+	}
+
+	oferr = ofmt_open(fields_str, fields, ofmtflags, 0, &ofmt);
+
+	ofmt_check(oferr, parsable, ofmt, die, warn);
+
+	nvlist_t *nvl = all ? ppt_list() : ppt_list_assigned();
+	nvpair_t *nvp = NULL;
+
+	if (json)
+		(void) printf("{\n\t\"devices\": [\n");
+
+	while ((nvp = nvlist_next_nvpair(nvl, nvp)) != NULL) {
+		nvlist_t *props;
+
+		(void) nvpair_value_nvlist(nvp, &props);
+
+		if (json) {
+			(void) printf("\t\t");
+			(void) nvlist_print_json(stdout, props);
+			if (nvlist_next_nvpair(nvl, nvp) != NULL)
+				(void) printf(",\n");
+		} else {
+			ofmt_print(ofmt, props);
+		}
+	}
+
+	if (json)
+		(void)  printf("\n\t]\n}\n");
+
+	nvlist_free(nvl);
+	ofmt_close(ofmt);
+	return (EXIT_SUCCESS);
+}
+
+int
+main(int argc, char *argv[])
+{
+	if (argc == 1)
+		return (list(argc - 1, argv));
+
+	if (strcmp(argv[1], "list") == 0) {
+		return (list(argc - 1, &argv[1]));
+	} else {
+		usage(B_TRUE);
+	}
+
+	return (EXIT_SUCCESS);
+}
diff --git a/usr/src/cmd/refer/refer2.c b/usr/src/cmd/refer/refer2.c
index f6fe088d3c..f8605e227b 100644
--- a/usr/src/cmd/refer/refer2.c
+++ b/usr/src/cmd/refer/refer2.c
@@ -12,8 +12,6 @@
  * specifies the terms and conditions for redistribution.
  */
 
-#pragma ident	"%Z%%M%	%I%	%E% SMI"
-
 #include "refer..c"
 #include <locale.h>
 #define	NFLD 30
@@ -137,6 +135,8 @@ again:
 			while (*p != '\n')
 				p++;
 			*++p = 0;
+			/* FALLTHROUGH */
+
 		case 1:
 			if (endpush)
 				if (nr = chkdup(answer)) {
diff --git a/usr/src/cmd/smbios/Makefile b/usr/src/cmd/smbios/Makefile
index f3d7803a78..eec224f524 100644
--- a/usr/src/cmd/smbios/Makefile
+++ b/usr/src/cmd/smbios/Makefile
@@ -22,6 +22,8 @@
 # Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
 # Use is subject to license terms.
 #
+# Copyright 2018 Joyent, Inc.
+#
 
 PROG = smbios
 OBJS = smbios.o
@@ -35,6 +37,8 @@ LDLIBS += -lsmbios
 FILEMODE = 0555
 STRIPFLAG =
 
+LINTFLAGS += -erroff=E_BAD_PTR_CAST_ALIGN
+
 .KEEP_STATE:
 
 all: $(PROG)
diff --git a/usr/src/cmd/smbios/smbios.c b/usr/src/cmd/smbios/smbios.c
index 2bac9156a5..f7c9ed1133 100644
--- a/usr/src/cmd/smbios/smbios.c
+++ b/usr/src/cmd/smbios/smbios.c
@@ -21,7 +21,7 @@
 
 /*
  * Copyright 2015 OmniTI Computer Consulting, Inc.  All rights reserved.
- * Copyright (c) 2017, Joyent, Inc.
+ * Copyright (c) 2018, Joyent, Inc.
  * Copyright 2010 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
  */
@@ -334,10 +334,30 @@ print_system(smbios_hdl_t *shp, FILE *fp)
 
 	(void) smbios_info_system(shp, &s);
 
+	/*
+	 * SMBIOS definition section 3.3.2.1 is clear that the first three
+	 * fields are little-endian, but this utility traditionally got this
+	 * wrong, and followed RFC 4122.  We keep this old behavior, but also
+	 * provide a corrected UUID.
+	 */
 	oprintf(fp, "  UUID: ");
-	for (i = 0; i < s.smbs_uuidlen; i++) {
+	oprintf(fp, "%02x%02x%02x%02x-%02x%02x-%02x%02x-",
+	    s.smbs_uuid[0], s.smbs_uuid[1], s.smbs_uuid[2], s.smbs_uuid[3],
+	    s.smbs_uuid[4], s.smbs_uuid[5], s.smbs_uuid[6], s.smbs_uuid[7]);
+	for (i = 8; i < s.smbs_uuidlen; i++) {
+		oprintf(fp, "%02x", s.smbs_uuid[i]);
+		if (i == 9)
+			oprintf(fp, "-");
+	}
+	oprintf(fp, "\n");
+
+	oprintf(fp, "  UUID (Endian-corrected): ");
+	oprintf(fp, "%08x-%04hx-%04hx-", *((uint_t *)&s.smbs_uuid[0]),
+	    *((ushort_t *)&s.smbs_uuid[4]),
+	    *((ushort_t *)&s.smbs_uuid[6]));
+	for (i = 8; i < s.smbs_uuidlen; i++) {
 		oprintf(fp, "%02x", s.smbs_uuid[i]);
-		if (i == 3 || i == 5 || i == 7 || i == 9)
+		if (i == 9)
 			oprintf(fp, "-");
 	}
 	oprintf(fp, "\n");
diff --git a/usr/src/cmd/tbl/t4.c b/usr/src/cmd/tbl/t4.c
index 262ff12ca2..e2cec8e533 100644
--- a/usr/src/cmd/tbl/t4.c
+++ b/usr/src/cmd/tbl/t4.c
@@ -13,8 +13,6 @@
  * specifies the terms and conditions for redistribution.
  */
   
-#pragma ident	"%Z%%M%	%I%	%E% SMI"
-
  /* t4.c: read table specification */
 # include "t..c"
 int oncol;
@@ -62,10 +60,12 @@ while (c=get1char())
 		default:
 			if (c != tab)
 			error(gettext("bad table specification character"));
+			/* FALLTHROUGH */
 		case ' ': /* note this is also case tab */
 			continue;
 		case '\n':
 			if(sawchar==0) continue;
+			/* FALLTHROUGH */
 		case ',':
 		case '.': /* end of table specification */
 			ncol = max(ncol, icol);
@@ -96,7 +96,9 @@ while (c=get1char())
 			continue;
 		case 'C': case 'S': case 'R': case 'N': case 'L':  case 'A':
 			c += ('a'-'A');
+			/* FALLTHROUGH */
 		case '_': if (c=='_') c= '-';
+			/* FALLTHROUGH */
 		case '=': case '-':
 		case '^':
 		case 'c': case 's': case 'n': case 'r': case 'l':  case 'a':
diff --git a/usr/src/cmd/tbl/t6.c b/usr/src/cmd/tbl/t6.c
index e862b71de1..db4d2ae3b3 100644
--- a/usr/src/cmd/tbl/t6.c
+++ b/usr/src/cmd/tbl/t6.c
@@ -13,8 +13,6 @@
  * specifies the terms and conditions for redistribution.
  */
      
-#pragma ident	"%Z%%M%	%I%	%E% SMI"
-
  /* t6.c: compute tab stops */
 # define tx(a) (a>(char *)0 && a<(char *)128)
 # include "t..c"
@@ -58,6 +56,7 @@ for(icol=0; icol <ncol; icol++)
 					doubled[icol]=1;
 					fprintf(tabout, ".if \\n(%c->\\n(%d .nr %d \\n(%c-\n",s,S2,S2,s);
 					}
+				/* FALLTHROUGH */
 			case 'n':
 				if (table[ilin][icol].rcol!=0)
 					{
@@ -78,6 +77,7 @@ for(icol=0; icol <ncol; icol++)
 						}
 					continue;
 					}
+				/* FALLTHROUGH */
 			case 'r':
 			case 'c':
 			case 'l':
diff --git a/usr/src/cmd/tbl/t7.c b/usr/src/cmd/tbl/t7.c
index 5cdd9fc316..d1327eb89f 100644
--- a/usr/src/cmd/tbl/t7.c
+++ b/usr/src/cmd/tbl/t7.c
@@ -62,6 +62,7 @@ for(c=0; c<ncol; c++)
 			if (table[ldata][c].rcol)
 			  if (lused[c]) /*Zero field width*/
 				fprintf(tabout, "\\n(%du ",c+CMID);
+			/* FALLTHROUGH */
 		case 'c':
 		case 'l':
 		case 'r':
diff --git a/usr/src/cmd/tbl/t8.c b/usr/src/cmd/tbl/t8.c
index 0b05b43b4f..8d859622e2 100644
--- a/usr/src/cmd/tbl/t8.c
+++ b/usr/src/cmd/tbl/t8.c
@@ -12,8 +12,6 @@
  * specifies the terms and conditions for redistribution.
  */
   
-#pragma ident	"%Z%%M%	%I%	%E% SMI"
-
  /* t8.c: write out one line of output table */
 # include "t..c"
 # include <locale.h>
@@ -173,6 +171,7 @@ for(c=0; c<ncol; c++)
 				form=1;
 				break;
 				}
+			/* FALLTHROUGH */
 		case 'c':
 			form=3; break;
 		case 'r':
diff --git a/usr/src/cmd/tcpd/safe_finger.c b/usr/src/cmd/tcpd/safe_finger.c
index be41d9bc0f..fcf4a22084 100644
--- a/usr/src/cmd/tcpd/safe_finger.c
+++ b/usr/src/cmd/tcpd/safe_finger.c
@@ -14,16 +14,13 @@
   * Author: Wietse Venema, Eindhoven University of Technology, The Netherlands.
   */
 
-#ifndef lint
-static char sccsid[] = "@(#) safe_finger.c 1.4 94/12/28 17:42:41";
-#endif
-
 /* System libraries */
 
 #include <sys/types.h>
 #include <sys/stat.h>
 #include <signal.h>
 #include <stdio.h>
+#include <stdlib.h>
 #include <ctype.h>
 #include <pwd.h>
 
@@ -40,6 +37,7 @@ char    path[] = "PATH=/bin:/usr/bin:/usr/ucb:/usr/bsd:/etc:/usr/etc:/usr/sbin";
 #define	UNPRIV_NAME	"nobody"	/* Preferred privilege level */
 #define	UNPRIV_UGID	32767		/* Default uid and gid */
 
+void    perror_exit(char *text) __NORETURN;
 int     finger_pid;
 
 void    cleanup(sig)
@@ -136,8 +134,8 @@ char  **argv;
 
 /* perror_exit - report system error text and terminate */
 
-void    perror_exit(text)
-char   *text;
+void
+perror_exit(char *text)
 {
     perror(text);
     exit(1);
diff --git a/usr/src/cmd/tr/tr.c b/usr/src/cmd/tr/tr.c
index 4627e590a6..49a8ccb1a8 100644
--- a/usr/src/cmd/tr/tr.c
+++ b/usr/src/cmd/tr/tr.c
@@ -52,7 +52,7 @@ STR s1 = { STRING1, NORMAL, 0, OOBCH, 0, { 0, OOBCH }, NULL, NULL };
 STR s2 = { STRING2, NORMAL, 0, OOBCH, 0, { 0, OOBCH }, NULL, NULL };
 
 static struct cset *setup(char *, STR *, int, int);
-static void usage(void);
+static void usage(void) __NORETURN;
 
 static wint_t
 cmap_lookup(struct cmap *cm, wint_t from)
diff --git a/usr/src/cmd/tsol/updatehome/updatehome.c b/usr/src/cmd/tsol/updatehome/updatehome.c
index 45225fc7e8..9cb43dce04 100644
--- a/usr/src/cmd/tsol/updatehome/updatehome.c
+++ b/usr/src/cmd/tsol/updatehome/updatehome.c
@@ -139,6 +139,7 @@ main(int argc, char **argv)
 		case '?':		/* switch error */
 			(void) fprintf(stderr, gettext("Bad option -%c.\n"),
 			    (char)optopt);
+			/* FALLTHROUGH */
 
 		default:
 			(void) fprintf(stderr, gettext("usage: %s [-cirs].\n"),
diff --git a/usr/src/cmd/ypcmd/ypupdated/openchild.c b/usr/src/cmd/ypcmd/ypupdated/openchild.c
index 38f9a49cb2..d8fecb7d48 100644
--- a/usr/src/cmd/ypcmd/ypupdated/openchild.c
+++ b/usr/src/cmd/ypcmd/ypupdated/openchild.c
@@ -32,12 +32,6 @@
  * under license from the Regents of the University of California.
  */
 
-#pragma ident	"%Z%%M%	%I%	%E% SMI"
-
-#if !defined(lint) && defined(SCCSIDS)
-static char sccsid[] = "%Z%%M%	%I%	%E% SMI";
-#endif
-
 /*
  * openchild.c
  *
@@ -46,29 +40,17 @@ static char sccsid[] = "%Z%%M%	%I%	%E% SMI";
  * interface, but for internal use only!
  */
 #include <stdio.h>
+#include <stdlib.h>
+#include <strings.h>
 
-extern void *malloc();
-extern char *strrchr();
-
-static char *basename();
+static char *basename(char *);
 static char SHELL[] = "/bin/sh";
 
-extern int close();
-extern int dup();
-extern int execl();
-extern void exit();
-extern long fork();
-extern int pipe();
-extern unsigned int strlen();
-
 /*
  * returns pid, or -1 for failure
  */
 int
-_openchild(command, fto, ffrom)
-	char *command;
-	FILE **fto;
-	FILE **ffrom;
+_openchild(char *command, FILE **fto, FILE **ffrom)
 {
 	int i;
 	int pid;
@@ -139,8 +121,7 @@ printf("openchild: error1");
 }
 
 static char *
-basename(path)
-	char *path;
+basename(char *path)
 {
 	char *p;
 
diff --git a/usr/src/cmd/ypcmd/ypupdated/rpc.ypupdated.c b/usr/src/cmd/ypcmd/ypupdated/rpc.ypupdated.c
index c38ad78523..0eed1a744b 100644
--- a/usr/src/cmd/ypcmd/ypupdated/rpc.ypupdated.c
+++ b/usr/src/cmd/ypcmd/ypupdated/rpc.ypupdated.c
@@ -32,6 +32,7 @@
 #include <sys/time.h>
 #include <sys/file.h>
 #include <ctype.h>
+#define	PORTMAP
 #include <rpc/rpc.h>
 #include <rpc/auth_des.h>
 #include <sys/socket.h>
@@ -54,20 +55,16 @@
 char YPDIR[] = "/var/yp";
 char UPDATEFILE[] = "updaters";
 
-void ypupdate_prog();
-void detachfromtty();
+void ypupdate_prog(struct svc_req *rqstp, SVCXPRT *transp);
+void detachfromtty(void);
 
 static int addr2netname(char *, SVCXPRT *);
-static int issock();
+static int issock(int);
 
 int insecure;
-extern SVCXPRT *svctcp_create(int, uint_t, uint_t);
-extern SVCXPRT *svcudp_create();
 
 int
-main(argc, argv)
-	int argc;
-	char *argv[];
+main(int argc, char *argv[])
 {
 	char *cmd;
 	int connmaxrec = RPC_MAXDATASIZE;
@@ -81,7 +78,7 @@ main(argc, argv)
 	 */
 	if (stat(NTOL_MAP_FILE, &filestat) != -1) {
 		fprintf(stderr, "rpc.updated not supported in NIS to LDAP "
-				"transition mode.");
+		    "transition mode.");
 		exit(1);
 	}
 
@@ -101,6 +98,7 @@ main(argc, argv)
 			insecure = 0;
 			break;
 		}
+		/* FALLTHROUGH */
 	default:
 		fprintf(stderr, "%s: warning -- options ignored\n", cmd);
 		break;
@@ -129,7 +127,7 @@ main(argc, argv)
 			exit(1);
 		}
 		if (!svc_register(transp, YPU_PROG, YPU_VERS, ypupdate_prog,
-				proto)) {
+		    proto)) {
 			fprintf(stderr, "%s: couldn't register service\n", cmd);
 			exit(1);
 		}
@@ -157,8 +155,7 @@ main(argc, argv)
  * Determine if a descriptor belongs to a socket or not
  */
 static int
-issock(fd)
-	int fd;
+issock(int fd)
 {
 	struct stat st;
 
@@ -170,7 +167,7 @@ issock(fd)
 
 
 void
-detachfromtty()
+detachfromtty(void)
 {
 	int tt;
 
@@ -197,9 +194,7 @@ detachfromtty()
 }
 
 void
-ypupdate_prog(rqstp, transp)
-	struct svc_req *rqstp;
-	SVCXPRT *transp;
+ypupdate_prog(struct svc_req *rqstp, SVCXPRT *transp)
 {
 	struct ypupdate_args args;
 	uint_t rslt;
@@ -208,6 +203,9 @@ ypupdate_prog(rqstp, transp)
 	char namebuf[MAXNETNAMELEN+1];
 	struct authunix_parms *aup;
 
+	CTASSERT(sizeof (struct authdes_cred) <= RQCRED_SIZE);
+	CTASSERT(sizeof (struct authunix_parms) <= RQCRED_SIZE);
+
 	switch (rqstp->rq_proc) {
 	case NULLPROC:
 		svc_sendreply(transp, xdr_void, NULL);
@@ -229,13 +227,10 @@ ypupdate_prog(rqstp, transp)
 		return;
 	}
 
-	CTASSERT(sizeof (struct authdes_cred) <= RQCRED_SIZE);
-	CTASSERT(sizeof (struct authunix_parms) <= RQCRED_SIZE);
-
 	switch (rqstp->rq_cred.oa_flavor) {
 	case AUTH_DES:
 		netname = ((struct authdes_cred *)
-			rqstp->rq_clntcred)->adc_fullname.name;
+		    rqstp->rq_clntcred)->adc_fullname.name;
 		break;
 	case AUTH_UNIX:
 		if (insecure) {
@@ -251,6 +246,7 @@ ypupdate_prog(rqstp, transp)
 			netname = namebuf;
 			break;
 		}
+		/* FALLTHROUGH */
 	default:
 		svcerr_weakauth(transp);
 		return;
@@ -261,8 +257,8 @@ ypupdate_prog(rqstp, transp)
 		return;
 	}
 	rslt = update(netname,
-		args.mapname, op, args.key.yp_buf_len, args.key.yp_buf_val,
-		args.datum.yp_buf_len, args.datum.yp_buf_val);
+	    args.mapname, op, args.key.yp_buf_len, args.key.yp_buf_val,
+	    args.datum.yp_buf_len, args.datum.yp_buf_val);
 	if (!svc_sendreply(transp, xdr_u_int, (const caddr_t)&rslt)) {
 		debug("svc_sendreply failed");
 	}
@@ -277,14 +273,8 @@ ypupdate_prog(rqstp, transp)
  * if there is no access violation.
  */
 int
-update(requester, mapname, op, keylen, key, datalen, data)
-	char *requester;
-	char *mapname;
-	uint_t op;
-	uint_t keylen;
-	char *key;
-	uint_t datalen;
-	char *data;
+update(char *requester, char *mapname, uint_t op, uint_t keylen, char *key,
+    uint_t datalen, char *data)
 {
 	char updater[MAXMAPNAMELEN + 40];
 	FILE *childargs;
@@ -306,7 +296,7 @@ update(requester, mapname, op, keylen, key, datalen, data)
 	/* check to see if we have a valid mapname */
 	strncpy(fake_key, "junk", 4);
 	err = yp_match(default_domain, mapname,
-			fake_key, strlen(fake_key), &outval, &outval_len);
+	    fake_key, strlen(fake_key), &outval, &outval_len);
 	switch (err) {
 		case 0:
 		case YPERR_KEY:
@@ -353,17 +343,15 @@ update(requester, mapname, op, keylen, key, datalen, data)
 }
 
 #if 0
-addr2netname(namebuf, addr)
-	char *namebuf;
-	struct sockaddr_in *addr;
+addr2netname(char *namebuf, struct sockaddr_in *addr)
 {
 	struct hostent *h;
 
 	h = gethostbyaddr((const char *) &addr->sin_addr,
-				sizeof (addr->sin_addr), AF_INET);
+	    sizeof (addr->sin_addr), AF_INET);
 	if (h == NULL) {
 		host2netname(namebuf, (const char *) inet_ntoa(addr->sin_addr),
-				NULL);
+		    NULL);
 	} else {
 		host2netname(namebuf, h->h_name, NULL);
 	}
@@ -372,9 +360,7 @@ addr2netname(namebuf, addr)
 
 
 static int
-addr2netname(namebuf, transp)
-	char *namebuf;
-	SVCXPRT *transp;
+addr2netname(char *namebuf, SVCXPRT *transp)
 {
 	struct nd_hostservlist *hostservs = NULL;
 	struct netconfig *nconf;
@@ -383,8 +369,7 @@ addr2netname(namebuf, transp)
 	who = svc_getrpccaller(transp);
 	if ((who == NULL) || (who->len == 0))
 		return (-1);
-	if ((nconf = getnetconfigent(transp->xp_netid))
-		== (struct netconfig *)NULL)
+	if ((nconf = getnetconfigent(transp->xp_netid)) == NULL)
 		return (-1);
 	if (netdir_getbyaddr(nconf, &hostservs, who) != 0) {
 		(void) freenetconfigent(nconf);
diff --git a/usr/src/cmd/zdb/zdb.c b/usr/src/cmd/zdb/zdb.c
index aafb0aa29f..6ce4263db8 100644
--- a/usr/src/cmd/zdb/zdb.c
+++ b/usr/src/cmd/zdb/zdb.c
@@ -774,7 +774,6 @@ verify_spacemap_refcounts(spa_t *spa)
 static void
 dump_spacemap(objset_t *os, space_map_t *sm)
 {
-	uint64_t alloc, offset, entry;
 	char *ddata[] = { "ALLOC", "FREE", "CONDENSE", "INVALID",
 	    "INVALID", "INVALID", "INVALID", "INVALID" };
 
@@ -791,41 +790,73 @@ dump_spacemap(objset_t *os, space_map_t *sm)
 	/*
 	 * Print out the freelist entries in both encoded and decoded form.
 	 */
-	alloc = 0;
-	for (offset = 0; offset < space_map_length(sm);
-	    offset += sizeof (entry)) {
-		uint8_t mapshift = sm->sm_shift;
+	uint8_t mapshift = sm->sm_shift;
+	int64_t alloc = 0;
+	uint64_t word;
+	for (uint64_t offset = 0; offset < space_map_length(sm);
+	    offset += sizeof (word)) {
 
 		VERIFY0(dmu_read(os, space_map_object(sm), offset,
-		    sizeof (entry), &entry, DMU_READ_PREFETCH));
-		if (SM_DEBUG_DECODE(entry)) {
+		    sizeof (word), &word, DMU_READ_PREFETCH));
 
+		if (sm_entry_is_debug(word)) {
 			(void) printf("\t    [%6llu] %s: txg %llu, pass %llu\n",
-			    (u_longlong_t)(offset / sizeof (entry)),
-			    ddata[SM_DEBUG_ACTION_DECODE(entry)],
-			    (u_longlong_t)SM_DEBUG_TXG_DECODE(entry),
-			    (u_longlong_t)SM_DEBUG_SYNCPASS_DECODE(entry));
+			    (u_longlong_t)(offset / sizeof (word)),
+			    ddata[SM_DEBUG_ACTION_DECODE(word)],
+			    (u_longlong_t)SM_DEBUG_TXG_DECODE(word),
+			    (u_longlong_t)SM_DEBUG_SYNCPASS_DECODE(word));
+			continue;
+		}
+
+		uint8_t words;
+		char entry_type;
+		uint64_t entry_off, entry_run, entry_vdev = SM_NO_VDEVID;
+
+		if (sm_entry_is_single_word(word)) {
+			entry_type = (SM_TYPE_DECODE(word) == SM_ALLOC) ?
+			    'A' : 'F';
+			entry_off = (SM_OFFSET_DECODE(word) << mapshift) +
+			    sm->sm_start;
+			entry_run = SM_RUN_DECODE(word) << mapshift;
+			words = 1;
 		} else {
-			(void) printf("\t    [%6llu]    %c  range:"
-			    " %010llx-%010llx  size: %06llx\n",
-			    (u_longlong_t)(offset / sizeof (entry)),
-			    SM_TYPE_DECODE(entry) == SM_ALLOC ? 'A' : 'F',
-			    (u_longlong_t)((SM_OFFSET_DECODE(entry) <<
-			    mapshift) + sm->sm_start),
-			    (u_longlong_t)((SM_OFFSET_DECODE(entry) <<
-			    mapshift) + sm->sm_start +
-			    (SM_RUN_DECODE(entry) << mapshift)),
-			    (u_longlong_t)(SM_RUN_DECODE(entry) << mapshift));
-			if (SM_TYPE_DECODE(entry) == SM_ALLOC)
-				alloc += SM_RUN_DECODE(entry) << mapshift;
-			else
-				alloc -= SM_RUN_DECODE(entry) << mapshift;
+			/* it is a two-word entry so we read another word */
+			ASSERT(sm_entry_is_double_word(word));
+
+			uint64_t extra_word;
+			offset += sizeof (extra_word);
+			VERIFY0(dmu_read(os, space_map_object(sm), offset,
+			    sizeof (extra_word), &extra_word,
+			    DMU_READ_PREFETCH));
+
+			ASSERT3U(offset, <=, space_map_length(sm));
+
+			entry_run = SM2_RUN_DECODE(word) << mapshift;
+			entry_vdev = SM2_VDEV_DECODE(word);
+			entry_type = (SM2_TYPE_DECODE(extra_word) == SM_ALLOC) ?
+			    'A' : 'F';
+			entry_off = (SM2_OFFSET_DECODE(extra_word) <<
+			    mapshift) + sm->sm_start;
+			words = 2;
 		}
+
+		(void) printf("\t    [%6llu]    %c  range:"
+		    " %010llx-%010llx  size: %06llx vdev: %06llu words: %u\n",
+		    (u_longlong_t)(offset / sizeof (word)),
+		    entry_type, (u_longlong_t)entry_off,
+		    (u_longlong_t)(entry_off + entry_run),
+		    (u_longlong_t)entry_run,
+		    (u_longlong_t)entry_vdev, words);
+
+		if (entry_type == 'A')
+			alloc += entry_run;
+		else
+			alloc -= entry_run;
 	}
-	if (alloc != space_map_allocated(sm)) {
-		(void) printf("space_map_object alloc (%llu) INCONSISTENT "
-		    "with space map summary (%llu)\n",
-		    (u_longlong_t)space_map_allocated(sm), (u_longlong_t)alloc);
+	if ((uint64_t)alloc != space_map_allocated(sm)) {
+		(void) printf("space_map_object alloc (%lld) INCONSISTENT "
+		    "with space map summary (%lld)\n",
+		    (longlong_t)space_map_allocated(sm), (longlong_t)alloc);
 	}
 }
 
@@ -1153,7 +1184,7 @@ dump_ddt(ddt_t *ddt, enum ddt_type type, enum ddt_class class)
 	while ((error = ddt_object_walk(ddt, type, class, &walk, &dde)) == 0)
 		dump_dde(ddt, &dde, walk);
 
-	ASSERT(error == ENOENT);
+	ASSERT3U(error, ==, ENOENT);
 
 	(void) printf("\n");
 }
@@ -3070,15 +3101,14 @@ typedef struct checkpoint_sm_exclude_entry_arg {
 } checkpoint_sm_exclude_entry_arg_t;
 
 static int
-checkpoint_sm_exclude_entry_cb(maptype_t type, uint64_t offset, uint64_t size,
-    void *arg)
+checkpoint_sm_exclude_entry_cb(space_map_entry_t *sme, void *arg)
 {
 	checkpoint_sm_exclude_entry_arg_t *cseea = arg;
 	vdev_t *vd = cseea->cseea_vd;
-	metaslab_t *ms = vd->vdev_ms[offset >> vd->vdev_ms_shift];
-	uint64_t end = offset + size;
+	metaslab_t *ms = vd->vdev_ms[sme->sme_offset >> vd->vdev_ms_shift];
+	uint64_t end = sme->sme_offset + sme->sme_run;
 
-	ASSERT(type == SM_FREE);
+	ASSERT(sme->sme_type == SM_FREE);
 
 	/*
 	 * Since the vdev_checkpoint_sm exists in the vdev level
@@ -3096,7 +3126,7 @@ checkpoint_sm_exclude_entry_cb(maptype_t type, uint64_t offset, uint64_t size,
 	 * metaslab boundaries. So if needed we could add code
 	 * that handles metaslab-crossing segments in the future.
 	 */
-	VERIFY3U(offset, >=, ms->ms_start);
+	VERIFY3U(sme->sme_offset, >=, ms->ms_start);
 	VERIFY3U(end, <=, ms->ms_start + ms->ms_size);
 
 	/*
@@ -3104,10 +3134,10 @@ checkpoint_sm_exclude_entry_cb(maptype_t type, uint64_t offset, uint64_t size,
 	 * also verify that the entry is there to begin with.
 	 */
 	mutex_enter(&ms->ms_lock);
-	range_tree_remove(ms->ms_allocatable, offset, size);
+	range_tree_remove(ms->ms_allocatable, sme->sme_offset, sme->sme_run);
 	mutex_exit(&ms->ms_lock);
 
-	cseea->cseea_checkpoint_size += size;
+	cseea->cseea_checkpoint_size += sme->sme_run;
 	return (0);
 }
 
@@ -4082,15 +4112,14 @@ typedef struct verify_checkpoint_sm_entry_cb_arg {
 #define	ENTRIES_PER_PROGRESS_UPDATE 10000
 
 static int
-verify_checkpoint_sm_entry_cb(maptype_t type, uint64_t offset, uint64_t size,
-    void *arg)
+verify_checkpoint_sm_entry_cb(space_map_entry_t *sme, void *arg)
 {
 	verify_checkpoint_sm_entry_cb_arg_t *vcsec = arg;
 	vdev_t *vd = vcsec->vcsec_vd;
-	metaslab_t *ms = vd->vdev_ms[offset >> vd->vdev_ms_shift];
-	uint64_t end = offset + size;
+	metaslab_t *ms = vd->vdev_ms[sme->sme_offset >> vd->vdev_ms_shift];
+	uint64_t end = sme->sme_offset + sme->sme_run;
 
-	ASSERT(type == SM_FREE);
+	ASSERT(sme->sme_type == SM_FREE);
 
 	if ((vcsec->vcsec_entryid % ENTRIES_PER_PROGRESS_UPDATE) == 0) {
 		(void) fprintf(stderr,
@@ -4104,7 +4133,7 @@ verify_checkpoint_sm_entry_cb(maptype_t type, uint64_t offset, uint64_t size,
 	/*
 	 * See comment in checkpoint_sm_exclude_entry_cb()
 	 */
-	VERIFY3U(offset, >=, ms->ms_start);
+	VERIFY3U(sme->sme_offset, >=, ms->ms_start);
 	VERIFY3U(end, <=, ms->ms_start + ms->ms_size);
 
 	/*
@@ -4113,7 +4142,7 @@ verify_checkpoint_sm_entry_cb(maptype_t type, uint64_t offset, uint64_t size,
 	 * their respective ms_allocateable trees should not contain them.
 	 */
 	mutex_enter(&ms->ms_lock);
-	range_tree_verify(ms->ms_allocatable, offset, size);
+	range_tree_verify(ms->ms_allocatable, sme->sme_offset, sme->sme_run);
 	mutex_exit(&ms->ms_lock);
 
 	return (0);
@@ -4359,7 +4388,7 @@ verify_checkpoint(spa_t *spa)
 	    DMU_POOL_ZPOOL_CHECKPOINT, sizeof (uint64_t),
 	    sizeof (uberblock_t) / sizeof (uint64_t), &checkpoint);
 
-	if (error == ENOENT) {
+	if (error == ENOENT && !dump_opt['L']) {
 		/*
 		 * If the feature is active but the uberblock is missing
 		 * then we must be in the middle of discarding the
@@ -4382,7 +4411,7 @@ verify_checkpoint(spa_t *spa)
 		error = 3;
 	}
 
-	if (error == 0)
+	if (error == 0 && !dump_opt['L'])
 		verify_checkpoint_blocks(spa);
 
 	return (error);
@@ -4488,7 +4517,7 @@ dump_zpool(spa_t *spa)
 	if (dump_opt['h'])
 		dump_history(spa);
 
-	if (rc == 0 && !dump_opt['L'])
+	if (rc == 0)
 		rc = verify_checkpoint(spa);
 
 	if (rc != 0) {
diff --git a/usr/src/cmd/zoneadmd/Makefile.com b/usr/src/cmd/zoneadmd/Makefile.com
index 75d7d82396..59233b3788 100644
--- a/usr/src/cmd/zoneadmd/Makefile.com
+++ b/usr/src/cmd/zoneadmd/Makefile.com
@@ -35,7 +35,7 @@ OBJS= zoneadmd.o zcons.o zfd.o vplat.o
 CFLAGS += $(CCVERBOSE)
 LDLIBS += -lsocket -lzonecfg -lnsl -ldevinfo -ldevice -lnvpair \
 	-lgen -lbsm -lcontract -lzfs -luuid -lbrand -ldladm -ltsnet -ltsol \
-	-linetutil -lproc -lscf
+	-linetutil -lproc -lscf -lppt
 
 CSTD= $(CSTD_GNU99)
 
diff --git a/usr/src/cmd/zoneadmd/vplat.c b/usr/src/cmd/zoneadmd/vplat.c
index d67e8d824f..f466836b96 100644
--- a/usr/src/cmd/zoneadmd/vplat.c
+++ b/usr/src/cmd/zoneadmd/vplat.c
@@ -21,7 +21,7 @@
 
 /*
  * Copyright (c) 2003, 2010, Oracle and/or its affiliates. All rights reserved.
- * Copyright 2017, Joyent Inc.
+ * Copyright 2018, Joyent Inc.
  * Copyright (c) 2015, 2016 by Delphix. All rights reserved.
  */
 
@@ -1198,9 +1198,15 @@ mount_one_dev(zlog_t *zlogp, char *devpath, zone_mnt_t mount_cmd)
 		goto cleanup;
 	}
 	while (zonecfg_getdevent(snap_hndl, &ztab) == Z_OK) {
-		if (di_prof_add_dev(prof, ztab.zone_dev_match)) {
+		char path[MAXPATHLEN];
+
+		if ((err = resolve_device_match(zlogp, &ztab,
+		    path, sizeof (path))) != Z_OK)
+			goto cleanup;
+
+		if (di_prof_add_dev(prof, path)) {
 			zerror(zlogp, B_TRUE, "failed to add "
-			    "user-specified device");
+			    "user-specified device '%s'", path);
 			goto cleanup;
 		}
 	}
diff --git a/usr/src/cmd/zoneadmd/zoneadmd.c b/usr/src/cmd/zoneadmd/zoneadmd.c
index 60af30d40b..aec5dce734 100644
--- a/usr/src/cmd/zoneadmd/zoneadmd.c
+++ b/usr/src/cmd/zoneadmd/zoneadmd.c
@@ -104,6 +104,9 @@
 #include <libdladm.h>
 #include <sys/dls_mgmt.h>
 #include <libscf.h>
+#include <uuid/uuid.h>
+#include <glob.h>
+#include <libppt.h>
 
 #include <libzonecfg.h>
 #include <zonestat_impl.h>
@@ -815,6 +818,46 @@ set_zonecfg_env(char *rsrc, char *attr, char *name, char *val)
 	(void) setenv(nm, val, 1);
 }
 
+/*
+ * Resolve a device:match value to a path.  This is only different for PPT
+ * devices, where we expect the match property to be a /devices/... path, and
+ * configured for PPT already.
+ */
+int
+resolve_device_match(zlog_t *zlogp, struct zone_devtab *dtab,
+    char *path, size_t len)
+{
+	struct zone_res_attrtab *rap;
+
+	for (rap = dtab->zone_dev_attrp; rap != NULL;
+	    rap = rap->zone_res_attr_next) {
+		if (strcmp(rap->zone_res_attr_name, "model") == 0 &&
+		    strcmp(rap->zone_res_attr_value, "passthru") == 0)
+			break;
+	}
+
+	if (rap == NULL) {
+		if (strlcpy(path, dtab->zone_dev_match, len) >= len)
+			return (Z_INVAL);
+		return (Z_OK);
+	}
+
+	if (strncmp(dtab->zone_dev_match, "/devices",
+	    strlen("/devices")) != 0) {
+		zerror(zlogp, B_FALSE, "invalid passthru match value '%s'",
+		    dtab->zone_dev_match);
+		return (Z_INVAL);
+	}
+
+	if (ppt_devpath_to_dev(dtab->zone_dev_match, path, len) != 0) {
+		zerror(zlogp, B_TRUE, "failed to resolve passthru device %s",
+		    dtab->zone_dev_match);
+		return (Z_INVAL);
+	}
+
+	return (Z_OK);
+}
+
 /*
  * Export various zonecfg properties into environment for the boot and state
  * change hooks.
@@ -832,7 +875,7 @@ set_zonecfg_env(char *rsrc, char *attr, char *name, char *val)
  * SmartOS.
  */
 static int
-setup_subproc_env(boolean_t debug)
+setup_subproc_env(zlog_t *zlogp, boolean_t debug)
 {
 	int res;
 	struct zone_nwiftab ntab;
@@ -841,11 +884,19 @@ setup_subproc_env(boolean_t debug)
 	char net_resources[MAXNAMELEN * 2];
 	char dev_resources[MAXNAMELEN * 2];
 	char didstr[16];
+	char uuidstr[UUID_PRINTABLE_STRING_LENGTH];
+	uuid_t uuid;
 
 	/* snap_hndl is null when called through the set_brand_env code path */
 	if (snap_hndl == NULL)
 		return (Z_OK);
 
+	if ((res = zonecfg_get_uuid(zone_name, uuid)) != Z_OK)
+		return (res);
+
+	uuid_unparse(uuid, uuidstr);
+	(void) setenv("_ZONECFG_uuid", uuidstr, 1);
+
 	(void) snprintf(didstr, sizeof (didstr), "%d", zone_did);
 	(void) setenv("_ZONECFG_did", didstr, 1);
 
@@ -909,17 +960,13 @@ setup_subproc_env(boolean_t debug)
 
 	dev_resources[0] = '\0';
 	while (zonecfg_getdevent(snap_hndl, &dtab) == Z_OK) {
+		char *match = dtab.zone_dev_match;
 		struct zone_res_attrtab *rap;
-		char *match;
+		char path[MAXPATHLEN];
 
-		match = dtab.zone_dev_match;
-
-		/*
-		 * In the environment variable name, the value of match will be
-		 * mangled.  Thus, we store the value of match in a "path"
-		 * environment variable.
-		 */
-		set_zonecfg_env(RSRC_DEV, match, "path", match);
+		res = resolve_device_match(zlogp, &dtab, path, sizeof (path));
+		if (res != Z_OK)
+			goto done;
 
 		for (rap = dtab.zone_dev_attrp; rap != NULL;
 		    rap = rap->zone_res_attr_next) {
@@ -927,6 +974,12 @@ setup_subproc_env(boolean_t debug)
 			    rap->zone_res_attr_name, rap->zone_res_attr_value);
 		}
 
+		/*
+		 * Even if not modified, the match path will be mangled in the
+		 * environment variable name, so we always store the value here.
+		 */
+		set_zonecfg_env(RSRC_DEV, match, "path", path);
+
 		/*
 		 * _ZONECFG_device_resources will contain a space separated list
 		 * of devices that have _ZONECFG_device_<device>* environment
@@ -1008,7 +1061,7 @@ do_subproc(zlog_t *zlogp, char *cmdbuf, char **retstr, boolean_t debug)
 		inbuf = buf;
 	}
 
-	if (setup_subproc_env(debug) != Z_OK) {
+	if (setup_subproc_env(zlogp, debug) != Z_OK) {
 		zerror(zlogp, B_FALSE, "failed to setup environment");
 		return (-1);
 	}
diff --git a/usr/src/cmd/zoneadmd/zoneadmd.h b/usr/src/cmd/zoneadmd/zoneadmd.h
index 0a347e9b82..c837431a8f 100644
--- a/usr/src/cmd/zoneadmd/zoneadmd.h
+++ b/usr/src/cmd/zoneadmd/zoneadmd.h
@@ -22,7 +22,7 @@
 /*
  * Copyright (c) 2003, 2010, Oracle and/or its affiliates. All rights reserved.
  * Copyright 2014 Nexenta Systems, Inc. All rights reserved.
- * Copyright 2017 Joyent, Inc.
+ * Copyright 2018 Joyent, Inc.
  */
 
 #ifndef	_ZONEADMD_H
@@ -175,6 +175,12 @@ extern int init_template(void);
  */
 extern int do_subproc(zlog_t *, char *, char **, boolean_t);
 
+/*
+ * Resource handling.
+ */
+extern int resolve_device_match(zlog_t *, struct zone_devtab *,
+    char *, size_t);
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/usr/src/cmd/ztest/ztest.c b/usr/src/cmd/ztest/ztest.c
index 1522c75485..ff45ab193e 100644
--- a/usr/src/cmd/ztest/ztest.c
+++ b/usr/src/cmd/ztest/ztest.c
@@ -193,6 +193,7 @@ extern uint64_t zfs_deadman_synctime_ms;
 extern int metaslab_preload_limit;
 extern boolean_t zfs_compressed_arc_enabled;
 extern boolean_t zfs_abd_scatter_enabled;
+extern boolean_t zfs_force_some_double_word_sm_entries;
 
 static ztest_shared_opts_t *ztest_shared_opts;
 static ztest_shared_opts_t ztest_opts;
@@ -6394,6 +6395,12 @@ main(int argc, char **argv)
 
 	dprintf_setup(&argc, argv);
 	zfs_deadman_synctime_ms = 300000;
+	/*
+	 * As two-word space map entries may not come up often (especially
+	 * if pool and vdev sizes are small) we want to force at least some
+	 * of them so the feature get tested.
+	 */
+	zfs_force_some_double_word_sm_entries = B_TRUE;
 
 	ztest_fd_rand = open("/dev/urandom", O_RDONLY);
 	ASSERT3S(ztest_fd_rand, >=, 0);
diff --git a/usr/src/common/bzip2/decompress.c b/usr/src/common/bzip2/decompress.c
index dd7eead372..d1da427b26 100644
--- a/usr/src/common/bzip2/decompress.c
+++ b/usr/src/common/bzip2/decompress.c
@@ -41,6 +41,7 @@ void makeMaps_d ( DState* s )
    { retVal = rrr; goto save_state_and_return; }
 
 #define GET_BITS(lll,vvv,nnn)                     \
+   /* FALLTHROUGH */                              \
    case lll: s->state = lll;                      \
    while (True) {                                 \
       if (s->bsLive >= nnn) {                     \
diff --git a/usr/src/common/smbsrv/smb_door_legacy.c b/usr/src/common/smbsrv/smb_door_legacy.c
index 985b83eb7a..ae1e557db8 100644
--- a/usr/src/common/smbsrv/smb_door_legacy.c
+++ b/usr/src/common/smbsrv/smb_door_legacy.c
@@ -39,7 +39,7 @@
 #include <sys/errno.h>
 #endif
 
-#include <smbsrv/wintypes.h>
+#include <smb/wintypes.h>
 #include <smbsrv/smb_share.h>
 #include <smbsrv/smb_door.h>
 #include <smbsrv/alloc.h>
diff --git a/usr/src/common/smbsrv/smb_token_xdr.c b/usr/src/common/smbsrv/smb_token_xdr.c
index fdad7ed5ca..b2f5a92352 100644
--- a/usr/src/common/smbsrv/smb_token_xdr.c
+++ b/usr/src/common/smbsrv/smb_token_xdr.c
@@ -32,7 +32,7 @@
 #if !defined(_KERNEL) && !defined(_FAKE_KERNEL)
 #include <stdlib.h>
 #endif /* !_KERNEL */
-#include <smbsrv/wintypes.h>
+#include <smb/wintypes.h>
 #include <smbsrv/smb_sid.h>
 #include <smbsrv/smb_xdr.h>
 #include <smbsrv/smb_token.h>
diff --git a/usr/src/common/zfs/zfeature_common.c b/usr/src/common/zfs/zfeature_common.c
index 74ed42b97d..1d56bb6e3f 100644
--- a/usr/src/common/zfs/zfeature_common.c
+++ b/usr/src/common/zfs/zfeature_common.c
@@ -245,6 +245,12 @@ zpool_feature_init(void)
 	    "Pool state can be checkpointed, allowing rewind later.",
 	    ZFEATURE_FLAG_READONLY_COMPAT, NULL);
 
+	zfeature_register(SPA_FEATURE_SPACEMAP_V2,
+	    "com.delphix:spacemap_v2", "spacemap_v2",
+	    "Space maps representing large segments are more efficient.",
+	    ZFEATURE_FLAG_READONLY_COMPAT | ZFEATURE_FLAG_ACTIVATE_ON_ENABLE,
+	    NULL);
+
 	static const spa_feature_t large_blocks_deps[] = {
 		SPA_FEATURE_EXTENSIBLE_DATASET,
 		SPA_FEATURE_NONE
diff --git a/usr/src/common/zfs/zfeature_common.h b/usr/src/common/zfs/zfeature_common.h
index 2b68c39c7b..a852f07018 100644
--- a/usr/src/common/zfs/zfeature_common.h
+++ b/usr/src/common/zfs/zfeature_common.h
@@ -59,6 +59,7 @@ typedef enum spa_feature {
 	SPA_FEATURE_DEVICE_REMOVAL,
 	SPA_FEATURE_OBSOLETE_COUNTS,
 	SPA_FEATURE_POOL_CHECKPOINT,
+	SPA_FEATURE_SPACEMAP_V2,
 	SPA_FEATURES
 } spa_feature_t;
 
diff --git a/usr/src/head/regexp.h b/usr/src/head/regexp.h
index 11a1105bc5..8dfa8ae528 100644
--- a/usr/src/head/regexp.h
+++ b/usr/src/head/regexp.h
@@ -289,7 +289,9 @@ compile(char *instring, char *ep, const char *endbuf, int seof)
 					*ep++ = (char)c;
 					continue;
 				}
+				/* FALLTHROUGH */
 			}
+			/* FALLTHROUGH */
 	/* Drop through to default to use \ to turn off special chars */
 
 		defchar:
diff --git a/usr/src/lib/Makefile b/usr/src/lib/Makefile
index 0054c41e6d..5c5dcc5ad4 100644
--- a/usr/src/lib/Makefile
+++ b/usr/src/lib/Makefile
@@ -166,6 +166,7 @@ SUBDIRS +=				\
 	libmapid	\
 	libmapmalloc	\
 	libmd5		\
+	libmlrpc	\
 	libmtmalloc	\
 	libmvec		\
 	libndmp		\
@@ -182,6 +183,7 @@ SUBDIRS +=				\
 	libpkg		\
 	libpool		\
 	libpp		\
+	libppt		\
 	libproc		\
 	libproject	\
 	libpthread	\
@@ -432,6 +434,7 @@ HDRSUBDIRS=				\
 	libmail		\
 	libmapid	\
 	libmd		\
+	libmlrpc	\
 	libmtmalloc	\
 	libndmp		\
 	libnsctl	\
@@ -446,6 +449,7 @@ HDRSUBDIRS=				\
 	libpicltree	\
 	libpool		\
 	libpp		\
+	libppt		\
 	libproc		\
 	libraidcfg	\
 	librcm		\
@@ -642,6 +646,7 @@ libkmf:		libcryptoutil pkcs11
 libkvm:		../cmd/sgs/libelf
 libldap5:	libsasl
 libmapid:	libresolv2 libscf
+libmlrpc:	libsmbfs libuuid
 libndmp:	libscf
 libnisdb:	libldap5
 libnwam:	libscf libbsm libdladm libipadm
@@ -650,6 +655,7 @@ libpctx:	libproc
 libpkg:		libscf libadm
 libpool:	libscf libexacct
 libpp:		libast
+libppt:		libpcidb libdevinfo libcmdutils
 libproc:	../cmd/sgs/librtld_db ../cmd/sgs/libelf libctf
 $(INTEL_BLD)libproc: libsaveargs
 libproject:	libpool libproc libsecdb
@@ -714,7 +720,7 @@ sasl_plugins:	pkcs11 libgss libsasl
 scsi:		libfru libumem libdevid libdevinfo
 smbsrv:		libxnet libpthread librt libshare libidmap pkcs11 libsqlite \
 		libcryptoutil libreparse libcmdutils libresolv2 libsmbfs \
-		libuuid libfakekernel libads libgss libldap5 krb5
+		libuuid libfakekernel libads libgss libldap5 krb5 libmlrpc
 storage:	libdevice libdevinfo libdevid
 sun_fc:		libdevinfo libsysevent
 sun_sas:	libdevinfo libsysevent libkstat libdevid
diff --git a/usr/src/lib/brand/bhyve/zone/boot.c b/usr/src/lib/brand/bhyve/zone/boot.c
index 1fd7208820..b8c4fa062b 100644
--- a/usr/src/lib/brand/bhyve/zone/boot.c
+++ b/usr/src/lib/brand/bhyve/zone/boot.c
@@ -28,6 +28,7 @@
 #include <string.h>
 #include <sys/stat.h>
 #include <sys/types.h>
+#include <sys/utsname.h>
 #include <unistd.h>
 #include <zone.h>
 
@@ -48,11 +49,13 @@ typedef enum {
 	PCI_SLOT_NICS
 } pci_slot_t;
 
-boolean_t debug;
+static boolean_t debug;
+static const char *zonename;
+static const char *zonepath;
 
 #define	dprintf(x) if (debug) (void)printf x
 
-char *
+static char *
 get_zcfg_var(const char *rsrc, const char *inst, const char *prop)
 {
 	char envvar[MAXNAMELEN];
@@ -77,7 +80,7 @@ get_zcfg_var(const char *rsrc, const char *inst, const char *prop)
 	return (ret);
 }
 
-boolean_t
+static boolean_t
 is_env_true(const char *rsrc, const char *inst, const char *prop)
 {
 	char *val = get_zcfg_var(rsrc, inst, prop);
@@ -85,8 +88,8 @@ is_env_true(const char *rsrc, const char *inst, const char *prop)
 	return (val != NULL && strcmp(val, "true") == 0);
 }
 
-int
-add_arg(int *argc, char **argv, char *val)
+static int
+add_arg(int *argc, char **argv, const char *val)
 {
 	if (*argc >= ZH_MAXARGS) {
 		(void) printf("Error: too many arguments\n");
@@ -99,7 +102,46 @@ add_arg(int *argc, char **argv, char *val)
 	return (0);
 }
 
-int
+static int
+add_smbios(int *argc, char **argv)
+{
+	char smbios[MAXPATHLEN];
+	struct utsname utsname;
+	const char *version;
+	const char *uuid;
+
+	/*
+	 * Look for something like joyent_20180329T120303Z.  A little mucky, but
+	 * it's exactly what sysinfo does.
+	 */
+	(void) uname(&utsname);
+	if (strncmp(utsname.version, "joyent_", strlen("joyent_")) == 0)
+		version = utsname.version + strlen("joyent_");
+	else
+		version = "?";
+
+	/*
+	 * This is based upon the SMBIOS values we expose to KVM guests.
+	 */
+	(void) snprintf(smbios, sizeof (smbios),
+	    "1,manufacturer=Joyent,product=SmartDC HVM,version=7.%s,"
+	    "serial=%s,sku=001,family=Virtual Machine",
+	    version, zonename);
+
+	if (add_arg(argc, argv, "-B") != 0 ||
+	    add_arg(argc, argv, smbios) != 0)
+		return (1);
+
+	if ((uuid = getenv("_ZONECFG_uuid")) != NULL) {
+		if (add_arg(argc, argv, "-U") != 0 ||
+		    add_arg(argc, argv, uuid) != 0)
+			return (1);
+	}
+
+	return (0);
+}
+
+static int
 add_cpu(int *argc, char **argv)
 {
 	char *val;
@@ -113,7 +155,7 @@ add_cpu(int *argc, char **argv)
 	return (0);
 }
 
-int
+static int
 add_ram(int *argc, char **argv)
 {
 	char *val;
@@ -127,7 +169,7 @@ add_ram(int *argc, char **argv)
 	return (0);
 }
 
-int
+static int
 add_disk(char *disk, char *path, char *slotconf, size_t slotconf_len)
 {
 	static char *boot = NULL;
@@ -165,7 +207,7 @@ add_disk(char *disk, char *path, char *slotconf, size_t slotconf_len)
 	return (0);
 }
 
-int
+static int
 add_ppt(int *argc, char **argv, char *ppt, char *path, char *slotconf,
     size_t slotconf_len)
 {
@@ -191,25 +233,26 @@ add_ppt(int *argc, char **argv, char *ppt, char *path, char *slotconf,
 		bus = 0;
 		break;
 	default:
-		(void) printf("Error: device %s has illegal PCI slot: %s\n",
+		(void) printf("Error: device %d has illegal PCI slot: %s\n",
 		    dev, pcislot);
 		return (-1);
 	}
 
 	if (bus > 255 || dev > 31 || func > 7) {
-		(void) printf("Error: device %s has illegal PCI slot: %s\n",
+		(void) printf("Error: device %d has illegal PCI slot: %s\n",
 		    dev, pcislot);
 		return (-1);
 	}
 
 	if (bus > 0) {
-		if (!acpi)
-			add_arg(argc, argv, "-A");
+		if (!acpi && add_arg(argc, argv, "-A") != 0)
+			return (-1);
 		acpi = B_TRUE;
 	}
 
-	if (!wired)
-		add_arg(argc, argv, "-S");
+	if (!wired && add_arg(argc, argv, "-S") != 0)
+		return (-1);
+
 	wired = B_TRUE;
 
 	if (snprintf(slotconf, slotconf_len, "%d:%d:%d,passthru,%s",
@@ -221,7 +264,7 @@ add_ppt(int *argc, char **argv, char *ppt, char *path, char *slotconf,
 	return (0);
 }
 
-int
+static int
 add_devices(int *argc, char **argv)
 {
 	char *devices;
@@ -277,7 +320,7 @@ add_devices(int *argc, char **argv)
 	return (0);
 }
 
-int
+static int
 add_nets(int *argc, char **argv)
 {
 	char *nets;
@@ -331,7 +374,7 @@ add_nets(int *argc, char **argv)
 	return (0);
 }
 
-int
+static int
 add_lpc(int *argc, char **argv)
 {
 	char *lpcdevs[] = { "bootrom", "com1", "com2", NULL };
@@ -378,7 +421,7 @@ add_lpc(int *argc, char **argv)
 	return (0);
 }
 
-int
+static int
 add_bhyve_extra_opts(int *argc, char **argv)
 {
 	char *val;
@@ -410,7 +453,7 @@ add_bhyve_extra_opts(int *argc, char **argv)
 }
 
 /* Must be called last */
-int
+static int
 add_vmname(int *argc, char **argv)
 {
 	char buf[32];				/* VM_MAX_NAMELEN */
@@ -433,7 +476,7 @@ add_vmname(int *argc, char **argv)
  * paranoid and call fdsync() at the end.  That's not really need for this use
  * case because it is being written to tmpfs.
  */
-int
+static int
 full_write(int fd, char *buf, size_t buflen)
 {
 	ssize_t nwritten;
@@ -455,7 +498,7 @@ full_write(int fd, char *buf, size_t buflen)
 	return (0);
 }
 
-void
+static void
 init_debug(void)
 {
 	char *val = getenv("_ZONEADMD_brand_debug");
@@ -464,7 +507,7 @@ init_debug(void)
 }
 
 static int
-setup_reboot(char *zonename)
+setup_reboot(void)
 {
 	zoneid_t	zoneid;
 
@@ -481,7 +524,7 @@ setup_reboot(char *zonename)
 
 	if (zone_setattr(zoneid, ZONE_ATTR_INITREBOOT, NULL, 0) < 0 ||
 	    zone_setattr(zoneid, ZONE_ATTR_INITRESTART0, NULL, 0) < 0) {
-		(void) printf("Error: bhyve zoneid %d setattr failed: %s\n",
+		(void) printf("Error: bhyve zoneid %ld setattr failed: %s\n",
 		    zoneid, strerror(errno));
 		return (-1);
 	}
@@ -496,16 +539,13 @@ main(int argc, char **argv)
 	char *zhargv[ZH_MAXARGS] = {
 		"zhyve",	/* Squats on argv[0] */
 		"-H",		/* vmexit on halt isns */
-		"-B", "1,product=SmartDC HVM",
 		NULL };
-	int zhargc;
+	int zhargc = 2;
 	nvlist_t *nvl;
 	char *nvbuf = NULL;
 	size_t nvbuflen = 0;
 	char zoneroot[MAXPATHLEN];
 	int zrfd;
-	char *zonename;
-	char *zonepath;
 
 	init_debug();
 
@@ -517,14 +557,11 @@ main(int argc, char **argv)
 	zonename = argv[1];
 	zonepath = argv[2];
 
-	if (setup_reboot(zonename) < 0)
+	if (setup_reboot() < 0)
 		return (1);
 
-	for (zhargc = 0; zhargv[zhargc] != NULL; zhargc++) {
-		dprintf(("def_arg: argv[%d]='%s'\n", zhargc, zhargv[zhargc]));
-	}
-
-	if (add_lpc(&zhargc, (char **)&zhargv) != 0 ||
+	if (add_smbios(&zhargc, (char **)&zhargv) != 0 ||
+	    add_lpc(&zhargc, (char **)&zhargv) != 0 ||
 	    add_cpu(&zhargc, (char **)&zhargv) != 0 ||
 	    add_ram(&zhargc, (char **)&zhargv) != 0 ||
 	    add_devices(&zhargc, (char **)&zhargv) != 0 ||
@@ -578,7 +615,7 @@ main(int argc, char **argv)
 	 */
 	if (mkdirat(zrfd, BHYVE_DIR, 0700) != 0 && errno != EEXIST) {
 		(void) printf("Error: failed to create directory %s "
-		    "in zone: %s\n" BHYVE_DIR, strerror(errno));
+		    "in zone: %s\n", BHYVE_DIR, strerror(errno));
 		return (1);
 	}
 
diff --git a/usr/src/lib/fm/topo/libtopo/common/libtopo.h b/usr/src/lib/fm/topo/libtopo/common/libtopo.h
index da6083a5be..822922294c 100644
--- a/usr/src/lib/fm/topo/libtopo/common/libtopo.h
+++ b/usr/src/lib/fm/topo/libtopo/common/libtopo.h
@@ -418,6 +418,14 @@ void topo_sensor_state_name(uint32_t sensor_type, uint8_t state, char *buf,
 #define	TOPO_SENSOR_UNITS	"units"
 #define	TOPO_LED_MODE		"mode"
 
+#define	TOPO_PROP_THRESHOLD_LNC		"threshold-lower-non-critical"
+#define	TOPO_PROP_THRESHOLD_LCR		"threshold-lower-critical"
+#define	TOPO_PROP_THRESHOLD_LNR		"threshold-lower-non-recoverable"
+
+#define	TOPO_PROP_THRESHOLD_UNC		"threshold-upper-non-critical"
+#define	TOPO_PROP_THRESHOLD_UCR		"threshold-upper-critical"
+#define	TOPO_PROP_THRESHOLD_UNR		"threshold-upper-non-recoverable"
+
 /*
  * Sensor Classes
  *
diff --git a/usr/src/lib/fm/topo/libtopo/common/topo_method.c b/usr/src/lib/fm/topo/libtopo/common/topo_method.c
index 8d36e96d9a..728d76ad82 100644
--- a/usr/src/lib/fm/topo/libtopo/common/topo_method.c
+++ b/usr/src/lib/fm/topo/libtopo/common/topo_method.c
@@ -22,11 +22,15 @@
  * Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
  */
+/*
+ * Copyright (c) 2018, Joyent, Inc.
+ */
 
 #include <pthread.h>
 #include <assert.h>
 #include <errno.h>
 #include <dirent.h>
+#include <fnmatch.h>
 #include <limits.h>
 #include <alloca.h>
 #include <unistd.h>
@@ -358,6 +362,44 @@ topo_sensor_failed(int32_t type, uint32_t state, struct sensor_errinfo *seinfo)
 	return (failed);
 }
 
+static boolean_t
+topo_spoof_apply(topo_hdl_t *thp, tnode_t *node, tnode_t *facnode,
+    nvlist_t *in, uint32_t *state)
+{
+	nvpair_t *elem = NULL;
+	nvlist_t *spoof, *rsrc = NULL;
+	char *fmrimatch, *fmri, *facmatch;
+	uint32_t spoof_state;
+	int err;
+
+	while ((elem = nvlist_next_nvpair(in, elem)) != NULL) {
+		if (nvpair_value_nvlist(elem, &spoof) != 0)
+			return (B_FALSE);
+
+		if (nvlist_lookup_string(spoof, ST_SPOOF_FMRI, &fmrimatch) !=
+		    0 || nvlist_lookup_string(spoof, ST_SPOOF_SENSOR,
+		    &facmatch) != 0 || nvlist_lookup_uint32(spoof,
+		    ST_SPOOF_STATE, &spoof_state) != 0)
+			continue;
+
+		if (topo_node_resource(node, &rsrc, &err) != 0 ||
+		    topo_fmri_nvl2str(thp, rsrc, &fmri, &err) != 0) {
+			nvlist_free(rsrc);
+			continue;
+		}
+		nvlist_free(rsrc);
+
+		if (fnmatch(fmrimatch, fmri, 0) == 0 &&
+		    strcmp(facmatch, topo_node_name(facnode)) == 0) {
+			*state = spoof_state;
+			topo_hdl_strfree(thp, fmri);
+			return (B_TRUE);
+		}
+		topo_hdl_strfree(thp, fmri);
+	}
+	return (B_FALSE);
+}
+
 /*
  * Determine whether there are any sensors indicating failure.  This function
  * is used internally to determine whether a given component is usable, as well
@@ -375,13 +417,16 @@ topo_sensor_failed(int32_t type, uint32_t state, struct sensor_errinfo *seinfo)
  * 		non-recoverable (the unit is out of service).  The default is
  * 		critical failure, which indicates a fault but the unit is still
  * 		operating.
+ *
+ *	injected
+ *
+ *		Boolean value indicating that the sensor state was injected.
  */
 /*ARGSUSED*/
 int
 topo_method_sensor_failure(topo_mod_t *mod, tnode_t *node,
     topo_version_t version, nvlist_t *in, nvlist_t **out)
 {
-	const char *name = topo_node_name(node);
 	topo_faclist_t faclist, *fp;
 	int err;
 	nvlist_t *nvl, *props, *propval, *tmp;
@@ -390,12 +435,9 @@ topo_method_sensor_failure(topo_mod_t *mod, tnode_t *node,
 	nvpair_t *elem;
 	double reading;
 	char *propname;
-	boolean_t has_reading;
+	boolean_t has_reading, is_spoofed = B_FALSE;
 	struct sensor_errinfo seinfo;
 
-	if (strcmp(name, PSU) != 0 && strcmp(name, FAN) != 0)
-		return (topo_mod_seterrno(mod, ETOPO_METHOD_NOTSUP));
-
 	if (topo_node_facility(mod->tm_hdl, node, TOPO_FAC_TYPE_SENSOR,
 	    TOPO_FAC_TYPE_ANY, &faclist, &err) != 0)
 		return (topo_mod_seterrno(mod, ETOPO_METHOD_NOTSUP));
@@ -441,6 +483,10 @@ topo_method_sensor_failure(topo_mod_t *mod, tnode_t *node,
 			}
 		}
 
+		if (in != NULL)
+			is_spoofed = topo_spoof_apply(mod->tm_hdl, node,
+			    fp->tf_node, in, &state);
+
 		if (topo_sensor_failed(type, state, &seinfo)) {
 			tmp = NULL;
 			if (topo_mod_nvalloc(mod, &tmp, NV_UNIQUE_NAME) != 0 ||
@@ -456,6 +502,8 @@ topo_method_sensor_failure(topo_mod_t *mod, tnode_t *node,
 			    "predictive", seinfo.se_predictive) != 0 ||
 			    nvlist_add_uint32(tmp, "source",
 			    seinfo.se_src) != 0 ||
+			    nvlist_add_boolean_value(nvl, "injected",
+			    is_spoofed) != 0 ||
 			    (has_reading && nvlist_add_double(tmp,
 			    TOPO_SENSOR_READING, reading) != 0) ||
 			    nvlist_add_nvlist(nvl, topo_node_name(fp->tf_node),
@@ -472,6 +520,7 @@ topo_method_sensor_failure(topo_mod_t *mod, tnode_t *node,
 		}
 
 		nvlist_free(props);
+		is_spoofed = B_FALSE;
 	}
 
 	*out = nvl;
diff --git a/usr/src/lib/fm/topo/libtopo/common/topo_method.h b/usr/src/lib/fm/topo/libtopo/common/topo_method.h
index ed0733375d..3cf14b92ec 100644
--- a/usr/src/lib/fm/topo/libtopo/common/topo_method.h
+++ b/usr/src/lib/fm/topo/libtopo/common/topo_method.h
@@ -23,7 +23,9 @@
  * Copyright 2008 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
  */
-
+/*
+ * Copyright (c) 2018, Joyent, Inc.
+ */
 #ifndef _TOPO_METHOD_H
 #define	_TOPO_METHOD_H
 
@@ -53,6 +55,14 @@ extern int topo_prop_method_version_register(tnode_t *, const char *,
     const char *, topo_type_t, const char *, topo_version_t, const nvlist_t *,
     int *);
 
+/*
+ * These are for the private consumption of the sensor-transport fmd plugin
+ * and topo_method_sensor_failure()
+ */
+#define	ST_SPOOF_FMRI		"spoof_resource_fmri"
+#define	ST_SPOOF_SENSOR		"spoof_sensor_name"
+#define	ST_SPOOF_STATE		"spoof_sensor_state"
+
 /*
  * FMRI methods
  */
diff --git a/usr/src/lib/fm/topo/maps/Joyent,Joyent-Compute-Platform-330x/Joyent-Compute-Platform-3301-hc-topology.xml b/usr/src/lib/fm/topo/maps/Joyent,Joyent-Compute-Platform-330x/Joyent-Compute-Platform-3301-hc-topology.xml
new file mode 100644
index 0000000000..000ed261a8
--- /dev/null
+++ b/usr/src/lib/fm/topo/maps/Joyent,Joyent-Compute-Platform-330x/Joyent-Compute-Platform-3301-hc-topology.xml
@@ -0,0 +1,251 @@
+<?xml version="1.0"?>
+<!DOCTYPE topology SYSTEM "/usr/share/lib/xml/dtd/topology.dtd.1">
+<!--
+ This file and its contents are supplied under the terms of the
+ Common Development and Distribution License ("CDDL"), version 1.0.
+ You may only use this file in accordance with the terms of version
+ 1.0 of the CDDL.
+
+ A full copy of the text of the CDDL should have accompanied this
+ source.  A copy of the CDDL is also available via the Internet at
+ http://www.illumos.org/license/CDDL.
+
+ Copyright (c) 2018, Joyent, Inc.
+-->
+
+<topology name='i86pc' scheme='hc'>
+
+  <range name='motherboard' min='0' max='0'>
+    <enum-method name='smbios' version='1' />
+    <node instance='0' static='true'>
+        <fac-enum provider='fac_prov_ipmi' />
+        <facility name='3.3V PG' type='sensor' provider='fac_prov_ipmi' >
+              <propgroup name='facility' version='1' name-stability='Private'
+                data-stability='Private' >
+                    <propval name='type' type='uint32' value='269' />
+                    <propval name='sensor-class' type='string' value='discrete' />
+                    <propval name='entity_ref' type='string_array' >
+                        <propitem value='3.3V PG' />
+                    </propval>
+                    <propmethod name='ipmi_sensor_state' version='0'
+                        propname='state' proptype='uint32' >
+                    </propmethod>
+              </propgroup>
+        </facility>
+        <facility name='5V AUX PG' type='sensor' provider='fac_prov_ipmi' >
+              <propgroup name='facility' version='1' name-stability='Private'
+                data-stability='Private' >
+                    <propval name='type' type='uint32' value='269' />
+                    <propval name='sensor-class' type='string' value='discrete' />
+                    <propval name='entity_ref' type='string_array' >
+                        <propitem value='5V AUX PG' />
+                    </propval>
+                    <propmethod name='ipmi_sensor_state' version='0'
+                        propname='state' proptype='uint32' >
+                    </propmethod>
+              </propgroup>
+        </facility>
+        <facility name='1.05V PG' type='sensor' provider='fac_prov_ipmi' >
+              <propgroup name='facility' version='1' name-stability='Private'
+                data-stability='Private' >
+                    <propval name='type' type='uint32' value='269' />
+                    <propval name='sensor-class' type='string' value='discrete' />
+                    <propval name='entity_ref' type='string_array' >
+                        <propitem value='1.05V PG' />
+                    </propval>
+                    <propmethod name='ipmi_sensor_state' version='0'
+                        propname='state' proptype='uint32' >
+                    </propmethod>
+              </propgroup>
+        </facility>
+        <facility name='BP0 5V PG' type='sensor' provider='fac_prov_ipmi' >
+              <propgroup name='facility' version='1' name-stability='Private'
+                data-stability='Private' >
+                    <propval name='type' type='uint32' value='269' />
+                    <propval name='sensor-class' type='string' value='discrete' />
+                    <propval name='entity_ref' type='string_array' >
+                        <propitem value='BP0 5V PG' />
+                    </propval>
+                    <propmethod name='ipmi_sensor_state' version='0'
+                        propname='state' proptype='uint32' >
+                    </propmethod>
+              </propgroup>
+        </facility>
+        <facility name='5V SWITCH PG' type='sensor' provider='fac_prov_ipmi' >
+              <propgroup name='facility' version='1' name-stability='Private'
+                data-stability='Private' >
+                    <propval name='type' type='uint32' value='269' />
+                    <propval name='sensor-class' type='string' value='discrete' />
+                    <propval name='entity_ref' type='string_array' >
+                        <propitem value='5V SWITCH PG' />
+                    </propval>
+                    <propmethod name='ipmi_sensor_state' version='0'
+                        propname='state' proptype='uint32' >
+                    </propmethod>
+              </propgroup>
+        </facility>
+        <facility name='VCCIO PG' type='sensor' provider='fac_prov_ipmi' >
+              <propgroup name='facility' version='1' name-stability='Private'
+                data-stability='Private' >
+                    <propval name='type' type='uint32' value='269' />
+                    <propval name='sensor-class' type='string' value='discrete' />
+                    <propval name='entity_ref' type='string_array' >
+                        <propitem value='VCCIO PG' />
+                    </propval>
+                    <propmethod name='ipmi_sensor_state' version='0'
+                        propname='state' proptype='uint32' >
+                    </propmethod>
+              </propgroup>
+        </facility>
+        <facility name='NDC PG' type='sensor' provider='fac_prov_ipmi' >
+              <propgroup name='facility' version='1' name-stability='Private'
+                data-stability='Private' >
+                    <propval name='type' type='uint32' value='269' />
+                    <propval name='sensor-class' type='string' value='discrete' />
+                    <propval name='entity_ref' type='string_array' >
+                        <propitem value='2.5V AUX PG' />
+                    </propval>
+                    <propmethod name='ipmi_sensor_state' version='0'
+                        propname='state' proptype='uint32' >
+                    </propmethod>
+              </propgroup>
+        </facility>
+        <facility name='1.5V PG' type='sensor' provider='fac_prov_ipmi' >
+              <propgroup name='facility' version='1' name-stability='Private'
+                data-stability='Private' >
+                    <propval name='type' type='uint32' value='269' />
+                    <propval name='sensor-class' type='string' value='discrete' />
+                    <propval name='entity_ref' type='string_array' >
+                        <propitem value='1.5V PG' />
+                    </propval>
+                    <propmethod name='ipmi_sensor_state' version='0'
+                        propname='state' proptype='uint32' >
+                    </propmethod>
+              </propgroup>
+        </facility>
+        <facility name='BP1 5V PG' type='sensor' provider='fac_prov_ipmi' >
+              <propgroup name='facility' version='1' name-stability='Private'
+                data-stability='Private' >
+                    <propval name='type' type='uint32' value='269' />
+                    <propval name='sensor-class' type='string' value='discrete' />
+                    <propval name='entity_ref' type='string_array' >
+                        <propitem value='BP1 5V PG' />
+                    </propval>
+                    <propmethod name='ipmi_sensor_state' version='0'
+                        propname='state' proptype='uint32' >
+                    </propmethod>
+              </propgroup>
+        </facility>
+        <facility name='BP2 5V PG' type='sensor' provider='fac_prov_ipmi' >
+              <propgroup name='facility' version='1' name-stability='Private'
+                data-stability='Private' >
+                    <propval name='type' type='uint32' value='269' />
+                    <propval name='sensor-class' type='string' value='discrete' />
+                    <propval name='entity_ref' type='string_array' >
+                        <propitem value='BP2 5V PG' />
+                    </propval>
+                    <propmethod name='ipmi_sensor_state' version='0'
+                        propname='state' proptype='uint32' >
+                    </propmethod>
+              </propgroup>
+        </facility>
+        <facility name='1.5V AUX PG' type='sensor' provider='fac_prov_ipmi' >
+              <propgroup name='facility' version='1' name-stability='Private'
+                data-stability='Private' >
+                    <propval name='type' type='uint32' value='269' />
+                    <propval name='sensor-class' type='string' value='discrete' />
+                    <propval name='entity_ref' type='string_array' >
+                        <propitem value='1.5V AUX PG' />
+                    </propval>
+                    <propmethod name='ipmi_sensor_state' version='0'
+                        propname='state' proptype='uint32' >
+                    </propmethod>
+              </propgroup>
+        </facility>
+        <facility name='1.05V PG' type='sensor' provider='fac_prov_ipmi' >
+              <propgroup name='facility' version='1' name-stability='Private'
+                data-stability='Private' >
+                    <propval name='type' type='uint32' value='269' />
+                    <propval name='sensor-class' type='string' value='discrete' />
+                    <propval name='entity_ref' type='string_array' >
+                        <propitem value='1.05V PG' />
+                    </propval>
+                    <propmethod name='ipmi_sensor_state' version='0'
+                        propname='state' proptype='uint32' >
+                    </propmethod>
+              </propgroup>
+        </facility>
+        <facility name='DIMM PG' type='sensor' provider='fac_prov_ipmi' >
+              <propgroup name='facility' version='1' name-stability='Private'
+                data-stability='Private' >
+                    <propval name='type' type='uint32' value='269' />
+                    <propval name='sensor-class' type='string' value='discrete' />
+                    <propval name='entity_ref' type='string_array' >
+                        <propitem value='DIMM PG' />
+                    </propval>
+                    <propmethod name='ipmi_sensor_state' version='0'
+                        propname='state' proptype='uint32' >
+                    </propmethod>
+              </propgroup>
+        </facility>
+        <propgroup name='protocol' version='1'
+            name-stability='Private' data-stability='Private' >
+            <propval name='label' type='string' value='MB' />
+        </propgroup>
+        <propgroup name='ipmi' version='1'
+            name-stability='Private' data-stability='Private' >
+            <propval name='entity-id' type='uint32' value='7' />
+            <propval name='entity-instance' type='uint32' value='1' />
+            <propval name='entity-list' type='string_array' >
+                <propitem value='CMOS Battery' />
+                <propitem value='Dedicated NIC' />
+                <propitem value='LCD Cable Pres' />
+                <propitem value='NDC PG' />
+                <propitem value='Riser Config Err' />
+                <propitem value='Riser 2 Presence' />
+                <propitem value='Riser 3 Presence' />
+                <propitem value='USB Cable Pres' />
+                <propitem value='VGA Cable Pres' />
+           </propval>
+        </propgroup>
+
+    </node> <!-- motherboard -->
+
+    <dependents grouping='children'>
+      <range name='chip' min='0' max='1'>
+        <enum-method name='chip' version='1' />
+      </range>
+      <range name='hostbridge' min='0' max='254'>
+        <enum-method name='hostbridge' version='1' />
+      </range>
+      <range name='sp' min='0' max='0'>
+        <enum-method name='ipmi' version='1' />
+      </range>
+      <range name='slot' min='0' max='23'>
+        <enum-method name='smbios' version='1' />
+      </range>
+    </dependents>
+
+  </range>
+
+  <range name='chassis' min='0' max='0'>
+    <propmap name='Joyent-Compute-Platform-330x-chassis' />
+
+    <dependents grouping='children'>
+
+       <range name='psu' min='0' max='1'>
+          <enum-method name='ipmi' version='1' />
+       </range>
+       <range name='fan' min='0' max='5'>
+          <propmap name='Joyent-Compute-Platform-330x-fan' />
+       </range>
+
+    </dependents>
+
+  </range>
+
+  <range name='ses-enclosure' min='0' max='1'>
+    <enum-method name='ses' version='1' />
+  </range>
+
+</topology>
diff --git a/usr/src/lib/fm/topo/maps/Joyent,Joyent-Compute-Platform-330x/Joyent-Compute-Platform-330x-chassis-hc-topology.xml b/usr/src/lib/fm/topo/maps/Joyent,Joyent-Compute-Platform-330x/Joyent-Compute-Platform-330x-chassis-hc-topology.xml
new file mode 100644
index 0000000000..20dbc301eb
--- /dev/null
+++ b/usr/src/lib/fm/topo/maps/Joyent,Joyent-Compute-Platform-330x/Joyent-Compute-Platform-330x-chassis-hc-topology.xml
@@ -0,0 +1,43 @@
+<?xml version="1.0"?>
+<!DOCTYPE topology SYSTEM "/usr/share/lib/xml/dtd/topology.dtd.1">
+<!--
+ This file and its contents are supplied under the terms of the
+ Common Development and Distribution License ("CDDL"), version 1.0.
+ You may only use this file in accordance with the terms of version
+ 1.0 of the CDDL.
+
+ A full copy of the text of the CDDL should have accompanied this
+ source.  A copy of the CDDL is also available via the Internet at
+ http://www.illumos.org/license/CDDL.
+
+ Copyright (c) 2018, Joyent, Inc.
+-->
+
+<topology name='chassis' scheme='hc'>
+  <range name='chassis' min='0' max='0'>
+    <node instance='0'>
+      <fac-enum provider='fac_prov_ipmi' />
+      <!--
+        chassis locate LED
+      -->
+      <facility name='locate' type='indicator' provider='fac_prov_ipmi' >
+          <propgroup name='facility' version='1' name-stability='Private'
+             data-stability='Private' >
+                <propval name='type' type='uint32' value='1' />
+                <propmethod name='chassis_ident_mode' version='0'
+                    propname='mode' proptype='uint32' mutable='1' >
+                </propmethod>
+          </propgroup>
+      </facility>
+      <propgroup name='ipmi' version='1'
+          name-stability='Private' data-stability='Private' >
+         <propval name='entity-list' type='string_array' >
+           <propitem value='Intrusion' />
+           <propitem value='Pwr Consumption' />
+           <propitem value='Inlet Temp' />
+           <propitem value='Exhaust Temp' />
+         </propval>
+      </propgroup>
+    </node>
+  </range>
+</topology>
diff --git a/usr/src/lib/fm/topo/maps/Joyent,Joyent-Compute-Platform-330x/Joyent-Compute-Platform-330x-fan-hc-topology.xml b/usr/src/lib/fm/topo/maps/Joyent,Joyent-Compute-Platform-330x/Joyent-Compute-Platform-330x-fan-hc-topology.xml
new file mode 100644
index 0000000000..5284971c19
--- /dev/null
+++ b/usr/src/lib/fm/topo/maps/Joyent,Joyent-Compute-Platform-330x/Joyent-Compute-Platform-330x-fan-hc-topology.xml
@@ -0,0 +1,127 @@
+<?xml version="1.0"?>
+<!DOCTYPE topology SYSTEM "/usr/share/lib/xml/dtd/topology.dtd.1">
+<!--
+ This file and its contents are supplied under the terms of the
+ Common Development and Distribution License ("CDDL"), version 1.0.
+ You may only use this file in accordance with the terms of version
+ 1.0 of the CDDL.
+
+ A full copy of the text of the CDDL should have accompanied this
+ source.  A copy of the CDDL is also available via the Internet at
+ http://www.illumos.org/license/CDDL.
+
+ Copyright (c) 2018, Joyent, Inc.
+-->
+
+<topology name='fan' scheme='hc'>
+  <range name='fan' min='0' max='5'>
+    <node instance='0'>
+      <fac-enum provider='fac_prov_ipmi' />
+      <propgroup name='protocol' version='1' name-stability='Private'
+          data-stability='Private'>
+          <propval name='label' type='string' value='FAN 1' />
+          <propmethod name='ipmi_fru_fmri' version='0' propname='FRU'
+            proptype='fmri'>
+            <argval name='entity' type='string' value='self' />
+          </propmethod>
+      </propgroup>
+      <propgroup name='ipmi' version='1'
+          name-stability='Private' data-stability='Private' >
+         <propval name='entity-list' type='string_array' >
+           <propitem value='Fan1' />
+         </propval>
+      </propgroup>
+      <enum-method name='ipmi' version='1' />
+    </node>
+    <node instance='1'>
+      <fac-enum provider='fac_prov_ipmi' />
+      <propgroup name='protocol' version='1' name-stability='Private'
+          data-stability='Private'>
+          <propval name='label' type='string' value='FAN 2' />
+          <propmethod name='ipmi_fru_fmri' version='0' propname='FRU'
+            proptype='fmri'>
+            <argval name='entity' type='string' value='self' />
+          </propmethod>
+      </propgroup>
+      <propgroup name='ipmi' version='1'
+          name-stability='Private' data-stability='Private' >
+         <propval name='entity-list' type='string_array' >
+           <propitem value='Fan2' />
+         </propval>
+      </propgroup>
+      <enum-method name='ipmi' version='1' />
+    </node>
+    <node instance='2'>
+      <fac-enum provider='fac_prov_ipmi' />
+      <propgroup name='protocol' version='1' name-stability='Private'
+          data-stability='Private'>
+          <propval name='label' type='string' value='FAN 3' />
+          <propmethod name='ipmi_fru_fmri' version='0' propname='FRU'
+            proptype='fmri'>
+            <argval name='entity' type='string' value='self' />
+          </propmethod>
+      </propgroup>
+      <propgroup name='ipmi' version='1'
+          name-stability='Private' data-stability='Private' >
+         <propval name='entity-list' type='string_array' >
+           <propitem value='Fan3' />
+         </propval>
+      </propgroup>
+      <enum-method name='ipmi' version='1' />
+    </node>
+    <node instance='3'>
+      <fac-enum provider='fac_prov_ipmi' />
+      <propgroup name='protocol' version='1' name-stability='Private'
+          data-stability='Private'>
+          <propval name='label' type='string' value='FAN 4' />
+          <propmethod name='ipmi_fru_fmri' version='0' propname='FRU'
+            proptype='fmri'>
+            <argval name='entity' type='string' value='self' />
+          </propmethod>
+      </propgroup>
+      <propgroup name='ipmi' version='1'
+          name-stability='Private' data-stability='Private' >
+         <propval name='entity-list' type='string_array' >
+           <propitem value='Fan4' />
+         </propval>
+      </propgroup>
+      <enum-method name='ipmi' version='1' />
+    </node>
+    <node instance='4'>
+      <fac-enum provider='fac_prov_ipmi' />
+      <propgroup name='protocol' version='1' name-stability='Private'
+          data-stability='Private'>
+          <propval name='label' type='string' value='FAN 5' />
+          <propmethod name='ipmi_fru_fmri' version='0' propname='FRU'
+            proptype='fmri'>
+            <argval name='entity' type='string' value='self' />
+          </propmethod>
+      </propgroup>
+      <propgroup name='ipmi' version='1'
+          name-stability='Private' data-stability='Private' >
+         <propval name='entity-list' type='string_array' >
+           <propitem value='Fan5' />
+         </propval>
+      </propgroup>
+      <enum-method name='ipmi' version='1' />
+    </node>
+    <node instance='5'>
+      <fac-enum provider='fac_prov_ipmi' />
+      <propgroup name='protocol' version='1' name-stability='Private'
+          data-stability='Private'>
+          <propval name='label' type='string' value='FAN 6' />
+          <propmethod name='ipmi_fru_fmri' version='0' propname='FRU'
+            proptype='fmri'>
+            <argval name='entity' type='string' value='self' />
+          </propmethod>
+      </propgroup>
+      <propgroup name='ipmi' version='1'
+          name-stability='Private' data-stability='Private' >
+         <propval name='entity-list' type='string_array' >
+           <propitem value='Fan6' />
+         </propval>
+      </propgroup>
+      <enum-method name='ipmi' version='1' />
+    </node>
+  </range>
+</topology>
diff --git a/usr/src/lib/fm/topo/maps/Joyent,Joyent-Compute-Platform-330x/Makefile b/usr/src/lib/fm/topo/maps/Joyent,Joyent-Compute-Platform-330x/Makefile
new file mode 100644
index 0000000000..677a099c43
--- /dev/null
+++ b/usr/src/lib/fm/topo/maps/Joyent,Joyent-Compute-Platform-330x/Makefile
@@ -0,0 +1,49 @@
+#
+# This file and its contents are supplied under the terms of the
+# Common Development and Distribution License ("CDDL"), version 1.0.
+# You may only use this file in accordance with the terms of version
+# 1.0 of the CDDL.
+#
+# A full copy of the text of the CDDL should have accompanied this
+# source.  A copy of the CDDL is also available via the Internet at
+# http://www.illumos.org/license/CDDL.
+#
+
+#
+# Copyright (c) 2018, Joyent, Inc.
+#
+
+ARCH = i86pc
+CLASS = arch
+DTDFILE = topology.dtd.1
+OTHER_VARIANTS = \
+	Joyent-Compute-Platform-3302-hc-topology.xml
+
+ROOTJOYENTMAPS = $(OTHER_VARIANTS:%=$(arch_ROOTTOPOROOT)/%)
+
+TOPOFILE = \
+	Joyent-Compute-Platform-3301-hc-topology.xml \
+	Joyent-Compute-Platform-330x-chassis-hc-topology.xml \
+	Joyent-Compute-Platform-330x-fan-hc-topology.xml
+
+SRCDIR = ../Joyent,Joyent-Compute-Platform-330x
+
+PLATFORM = Joyent-Compute-Platform-330x
+
+CLOBBERFILES +=	$(ROOTJOYENTMAPS)
+
+include ../Makefile.map
+
+install: $(ROOTJOYENTMAPS)
+
+#
+# The JCP-3301 and JCP-3302 are essentially the same underlying hardware.  The
+# only significant difference is the JCP-3302 uses SSDs internally instead of
+# traditional disks.  As such, the same platform topo map should work for
+# both platforms so we simply create a symlink from the JCP 3301 map for the
+# JCP 3302.
+#
+$(ROOTJOYENTMAPS): Joyent-Compute-Platform-3301-hc-topology.xml
+	$(RM) $@
+	$(SYMLINK) ./$? $@
+
diff --git a/usr/src/lib/fm/topo/maps/Makefile b/usr/src/lib/fm/topo/maps/Makefile
index 49b86186a1..f0e76ff531 100644
--- a/usr/src/lib/fm/topo/maps/Makefile
+++ b/usr/src/lib/fm/topo/maps/Makefile
@@ -51,6 +51,7 @@ i386_SUBDIRS = i86pc \
 		SUNW,Sun-Fire-X4540 \
 		SUNW,Sun-Fire-X4600-M2 \
 		Joyent,Joyent-Compute-Platform-1101 \
+		Joyent,Joyent-Compute-Platform-330x \
 		Joyent,Joyent-Storage-Platform-7001 \
 		SMCI,SSG-2028R-ACR24L
 
diff --git a/usr/src/lib/fm/topo/modules/common/fac_prov_ipmi/fac_prov_ipmi.c b/usr/src/lib/fm/topo/modules/common/fac_prov_ipmi/fac_prov_ipmi.c
index 5592f25cdd..434790fd65 100644
--- a/usr/src/lib/fm/topo/modules/common/fac_prov_ipmi/fac_prov_ipmi.c
+++ b/usr/src/lib/fm/topo/modules/common/fac_prov_ipmi/fac_prov_ipmi.c
@@ -23,7 +23,7 @@
  * Use is subject to license terms.
  */
 /*
- * Copyright (c) 2017, Joyent, Inc.
+ * Copyright (c) 2018, Joyent, Inc.
  */
 #include <unistd.h>
 #include <stdio.h>
@@ -113,6 +113,9 @@ static const topo_method_t ipmi_node_methods[] = {
 	{ "cs_ipmi_entity", TOPO_PROP_METH_DESC,
 	    TOPO_METH_DIMM_IPMI_ENTITY_VERSION,
 	    TOPO_STABILITY_INTERNAL, cs_ipmi_entity },
+	{ TOPO_METH_SENSOR_FAILURE, TOPO_METH_SENSOR_FAILURE_DESC,
+	    TOPO_METH_SENSOR_FAILURE_VERSION, TOPO_STABILITY_INTERNAL,
+	    topo_method_sensor_failure },
 	{ NULL }
 };
 
@@ -171,6 +174,7 @@ struct sensor_data {
 	uint32_t sd_stype;
 	uint32_t sd_rtype;
 	char *sd_class;
+	ipmi_sdr_full_sensor_t *sd_fs_sdr;
 };
 
 /*ARGSUSED*/
@@ -350,10 +354,12 @@ ipmi_sensor_state(topo_mod_t *mod, tnode_t *node, topo_version_t vers,
 	ipmi_handle_t *hdl;
 	int err, i;
 	uint8_t sensor_num;
+	uint32_t e_id, e_inst;
 	ipmi_sdr_full_sensor_t *fsensor;
 	ipmi_sdr_compact_sensor_t *csensor;
 	nvlist_t *nvl;
 	boolean_t found_sdr = B_FALSE;
+	tnode_t *pnode;
 
 	if (vers > TOPO_METH_IPMI_STATE_VERSION)
 		return (topo_mod_seterrno(mod, ETOPO_METHOD_VERNEW));
@@ -371,8 +377,18 @@ ipmi_sensor_state(topo_mod_t *mod, tnode_t *node, topo_version_t vers,
 		return (-1);
 	}
 
+	pnode = topo_node_parent(node);
+	if (topo_prop_get_uint32(pnode, TOPO_PGROUP_IPMI,
+	    TOPO_PROP_IPMI_ENTITY_ID, &e_id, &err) != 0 ||
+	    topo_prop_get_uint32(pnode, TOPO_PGROUP_IPMI,
+	    TOPO_PROP_IPMI_ENTITY_INST, &e_inst, &err) != 0) {
+		e_id = IPMI_ET_UNSPECIFIED;
+		e_inst = 0;
+	}
+
 	for (i = 0; i < nelems; i++) {
-		if ((sdr = ipmi_sdr_lookup(hdl, entity_refs[i])) != NULL) {
+		if ((sdr = ipmi_sdr_lookup_precise(hdl, entity_refs[i],
+		    (uint8_t)e_id, (uint8_t)e_inst)) != NULL) {
 			found_sdr = B_TRUE;
 			break;
 		} else
@@ -437,12 +453,16 @@ ipmi_sensor_reading(topo_mod_t *mod, tnode_t *node, topo_version_t vers,
 	char **entity_refs, reading_str[BUFSZ];
 	uint_t nelems;
 	int err = 0, i;
-	ipmi_sdr_full_sensor_t *sensor;
+	ipmi_sdr_t *sdr = NULL;
+	ipmi_sdr_full_sensor_t *fsensor;
 	ipmi_sensor_reading_t  *reading;
 	double conv_reading;
 	ipmi_handle_t *hdl;
 	nvlist_t *nvl;
 	boolean_t found_sdr = B_FALSE;
+	uint8_t sensor_num;
+	uint32_t e_id, e_inst;
+	tnode_t *pnode;
 
 	if (vers > TOPO_METH_IPMI_READING_VERSION)
 		return (topo_mod_seterrno(mod, ETOPO_METHOD_VERNEW));
@@ -460,9 +480,18 @@ ipmi_sensor_reading(topo_mod_t *mod, tnode_t *node, topo_version_t vers,
 		return (-1);
 	}
 
+	pnode = topo_node_parent(node);
+	if (topo_prop_get_uint32(pnode, TOPO_PGROUP_IPMI,
+	    TOPO_PROP_IPMI_ENTITY_ID, &e_id, &err) != 0 ||
+	    topo_prop_get_uint32(pnode, TOPO_PGROUP_IPMI,
+	    TOPO_PROP_IPMI_ENTITY_INST, &e_inst, &err) != 0) {
+		e_id = IPMI_ET_UNSPECIFIED;
+		e_inst = 0;
+	}
+
 	for (i = 0; i < nelems; i++) {
-		if ((sensor = ipmi_sdr_lookup_full_sensor(hdl, entity_refs[i]))
-		    != NULL) {
+		if ((sdr = ipmi_sdr_lookup_precise(hdl, entity_refs[i],
+		    (uint8_t)e_id, (uint8_t)e_inst)) != NULL) {
 			found_sdr = B_TRUE;
 			break;
 		} else
@@ -475,19 +504,30 @@ ipmi_sensor_reading(topo_mod_t *mod, tnode_t *node, topo_version_t vers,
 		topo_mod_ipmi_rele(mod);
 		return (-1);
 	}
+	switch (sdr->is_type) {
+		case IPMI_SDR_TYPE_FULL_SENSOR:
+			fsensor = (ipmi_sdr_full_sensor_t *)sdr->is_record;
+			sensor_num = fsensor->is_fs_number;
+			break;
+		default:
+			topo_mod_dprintf(mod, "%s does not refer to a full "
+			    "sensor SDR\n", entity_refs[i]);
+			topo_mod_ipmi_rele(mod);
+			strarr_free(mod, entity_refs, nelems);
+			return (-1);
+	}
 
-	if ((reading = ipmi_get_sensor_reading(hdl, sensor->is_fs_number))
-	    == NULL) {
+	if ((reading = ipmi_get_sensor_reading(hdl, sensor_num)) == NULL) {
 		topo_mod_dprintf(mod, "Failed to get sensor reading for sensor "
 		    "%s, sensor_num=%d (%s)\n", entity_refs[i],
-		    sensor->is_fs_number, ipmi_errmsg(hdl));
+		    sensor_num, ipmi_errmsg(hdl));
 		strarr_free(mod, entity_refs, nelems);
 		topo_mod_ipmi_rele(mod);
 		return (-1);
 	}
 	topo_mod_ipmi_rele(mod);
 
-	if (ipmi_sdr_conv_reading(sensor, reading->isr_reading, &conv_reading)
+	if (ipmi_sdr_conv_reading(fsensor, reading->isr_reading, &conv_reading)
 	    != 0) {
 		topo_mod_dprintf(mod, "Failed to convert sensor reading for "
 		    "sensor %s (%s)\n", entity_refs[i], ipmi_errmsg(hdl));
@@ -1349,14 +1389,66 @@ chassis_ident_mode(topo_mod_t *mod, tnode_t *node, topo_version_t vers,
 	return (0);
 }
 
+#define	ISBITSET(MASK, BIT)	((MASK & BIT) == BIT)
+
+struct sensor_thresh {
+	uint8_t	sthr_threshbit;
+	const char *sthr_propname;
+	uint8_t sthr_threshoff;
+};
+
+static const struct sensor_thresh threshset[] = {
+	{ IPMI_SENSOR_THRESHOLD_LOWER_NONCRIT, TOPO_PROP_THRESHOLD_LNC,
+	    offsetof(ipmi_sensor_thresholds_t, ithr_lower_noncrit) },
+	{ IPMI_SENSOR_THRESHOLD_LOWER_CRIT, TOPO_PROP_THRESHOLD_LCR,
+	    offsetof(ipmi_sensor_thresholds_t, ithr_lower_crit) },
+	{ IPMI_SENSOR_THRESHOLD_LOWER_NONRECOV, TOPO_PROP_THRESHOLD_LNR,
+	    offsetof(ipmi_sensor_thresholds_t, ithr_lower_nonrec) },
+	{ IPMI_SENSOR_THRESHOLD_UPPER_NONCRIT, TOPO_PROP_THRESHOLD_UNC,
+	    offsetof(ipmi_sensor_thresholds_t, ithr_upper_noncrit) },
+	{ IPMI_SENSOR_THRESHOLD_UPPER_CRIT, TOPO_PROP_THRESHOLD_UCR,
+	    offsetof(ipmi_sensor_thresholds_t, ithr_upper_crit) },
+	{ IPMI_SENSOR_THRESHOLD_UPPER_NONRECOV, TOPO_PROP_THRESHOLD_UNR,
+	    offsetof(ipmi_sensor_thresholds_t, ithr_upper_nonrec) }
+};
+
+static uint_t num_thresholds =
+    sizeof (threshset) / sizeof (struct sensor_thresh);
+
 static int
-make_sensor_node(topo_mod_t *mod, tnode_t *pnode, struct sensor_data *sd)
+set_thresh_prop(topo_mod_t *mod, tnode_t *fnode, ipmi_sdr_full_sensor_t *fs,
+    uint8_t raw_thresh, const struct sensor_thresh *thresh)
+{
+	int err;
+	double conv_thresh;
+
+	if (ipmi_sdr_conv_reading(fs, raw_thresh, &conv_thresh) != 0) {
+		topo_mod_dprintf(mod, "Failed to convert threshold %s on node "
+		    "%s", thresh->sthr_propname, topo_node_name(fnode));
+		return (topo_mod_seterrno(mod, EMOD_PARTIAL_ENUM));
+	}
+	if (topo_prop_set_double(fnode, TOPO_PGROUP_FACILITY,
+	    thresh->sthr_propname, TOPO_PROP_IMMUTABLE, conv_thresh, &err) !=
+	    0) {
+		topo_mod_dprintf(mod, "Failed to set property %s on node %s "
+		    "(%s)", thresh->sthr_propname, topo_node_name(fnode),
+		    topo_strerror(err));
+		return (topo_mod_seterrno(mod, err));
+	}
+	return (0);
+}
+
+static int
+make_sensor_node(topo_mod_t *mod, tnode_t *pnode, struct sensor_data *sd,
+    ipmi_handle_t *hdl)
 {
 	int err, ret, i;
 	tnode_t *fnode;
 	char *ftype = "sensor", facname[MAX_ID_LEN], **entity_refs;
 	topo_pgroup_info_t pgi;
 	nvlist_t *arg_nvl = NULL;
+	ipmi_sensor_thresholds_t thresh = { 0 };
+	uint8_t mask;
 
 	/*
 	 * Some platforms have '/' characters in the IPMI entity name, but '/'
@@ -1371,7 +1463,7 @@ make_sensor_node(topo_mod_t *mod, tnode_t *pnode, struct sensor_data *sd)
 	if ((fnode = topo_node_facbind(mod, pnode, facname, ftype)) == NULL) {
 		topo_mod_dprintf(mod, "Failed to bind facility node: %s\n",
 		    facname);
-		/* topo errno set */
+		/* errno set */
 		return (-1);
 	}
 
@@ -1384,23 +1476,20 @@ make_sensor_node(topo_mod_t *mod, tnode_t *pnode, struct sensor_data *sd)
 			topo_mod_dprintf(mod,  "pgroups create failure: %s\n",
 			    topo_strerror(err));
 			topo_node_unbind(fnode);
-			return (-1);
+			return (topo_mod_seterrno(mod, err));
 		}
 	}
 	if (topo_method_register(mod, fnode, ipmi_fac_methods) < 0) {
 		topo_mod_dprintf(mod, "make_fac_node: "
 		    "failed to register facility methods");
 		topo_node_unbind(fnode);
+		/* errno set */
 		return (-1);
 	}
 	/*
 	 * For both threshold and discrete sensors we set up a propmethod for
 	 * getting the sensor state and properties to hold the entity ref,
 	 * sensor class and sensor type.
-	 *
-	 * Additionally, for analog sensors we set up a property method for
-	 * getting the converted sensor reading and property for the base
-	 * unit type
 	 */
 	if ((entity_refs = topo_mod_alloc(mod, sizeof (char *))) == NULL)
 		return (topo_mod_seterrno(mod, EMOD_NOMEM));
@@ -1414,7 +1503,7 @@ make_sensor_node(topo_mod_t *mod, tnode_t *pnode, struct sensor_data *sd)
 		    "on node: %s=%d (%s)\n", __func__, topo_node_name(fnode),
 		    topo_node_instance(fnode), topo_strerror(err));
 		strarr_free(mod, entity_refs, 1);
-		return (-1);
+		return (topo_mod_seterrno(mod, err));
 	}
 	strarr_free(mod, entity_refs, 1);
 
@@ -1423,14 +1512,14 @@ make_sensor_node(topo_mod_t *mod, tnode_t *pnode, struct sensor_data *sd)
 		topo_mod_dprintf(mod, "Failed to set %s property on node: "
 		    "%s=%d (%s)\n", TOPO_SENSOR_CLASS, topo_node_name(fnode),
 		    topo_node_instance(fnode), topo_strerror(err));
-		return (-1);
+		return (topo_mod_seterrno(mod, err));
 	}
 	if (topo_prop_set_uint32(fnode, TOPO_PGROUP_FACILITY,
 	    TOPO_FACILITY_TYPE, TOPO_PROP_IMMUTABLE, sd->sd_stype, &err) != 0) {
 		topo_mod_dprintf(mod, "Failed to set %s property on node: "
 		    "%s=%d (%s)\n", TOPO_FACILITY_TYPE, topo_node_name(fnode),
 		    topo_node_instance(fnode), topo_strerror(err));
-		return (-1);
+		return (topo_mod_seterrno(mod, err));
 	}
 	if (topo_mod_nvalloc(mod, &arg_nvl, NV_UNIQUE_NAME) < 0) {
 		topo_node_unbind(fnode);
@@ -1442,7 +1531,7 @@ make_sensor_node(topo_mod_t *mod, tnode_t *pnode, struct sensor_data *sd)
 		topo_mod_dprintf(mod, "Failed build arg nvlist (%s)\n",
 		    strerror(ret));
 		nvlist_free(arg_nvl);
-		return (-1);
+		return (topo_mod_seterrno(mod, EMOD_NOMEM));
 	}
 
 	if (topo_prop_method_register(fnode, TOPO_PGROUP_FACILITY,
@@ -1452,30 +1541,75 @@ make_sensor_node(topo_mod_t *mod, tnode_t *pnode, struct sensor_data *sd)
 		    "node %s (%s)\n", TOPO_SENSOR_STATE, topo_node_name(fnode),
 		    topo_strerror(err));
 		nvlist_free(arg_nvl);
-		return (-1);
+		return (topo_mod_seterrno(mod, err));
 	}
 
-	if (strcmp(sd->sd_class, TOPO_SENSOR_CLASS_THRESHOLD) == 0) {
-		if (topo_prop_method_register(fnode, TOPO_PGROUP_FACILITY,
-		    TOPO_SENSOR_READING, TOPO_TYPE_DOUBLE,
-		    "ipmi_sensor_reading", arg_nvl, &err) != 0) {
-			topo_mod_dprintf(mod, "Failed to register %s propmeth "
-			    "on fac node %s (%s)\n", TOPO_SENSOR_READING,
-			    topo_node_name(fnode), topo_strerror(err));
-			nvlist_free(arg_nvl);
-			return (-1);
-		}
-		if (topo_prop_set_uint32(fnode, TOPO_PGROUP_FACILITY,
-		    TOPO_SENSOR_UNITS, TOPO_PROP_IMMUTABLE, sd->sd_units, &err)
-		    != 0) {
-			topo_mod_dprintf(mod, "Failed to set units property on "
-			    "node: %s (%s)\n", topo_node_name(fnode),
-			    topo_strerror(err));
-			nvlist_free(arg_nvl);
+	/*
+	 * If it's a discrete sensor then we're done.  For threshold sensors,
+	 * there are additional properties to set up.
+	 */
+	if (strcmp(sd->sd_class, TOPO_SENSOR_CLASS_THRESHOLD) != 0) {
+		nvlist_free(arg_nvl);
+		return (0);
+	}
+
+	/*
+	 * Create properties to expose the analog sensor reading, the unit
+	 * type and the upper and lower thresholds, if available.
+	 */
+	if (topo_prop_method_register(fnode, TOPO_PGROUP_FACILITY,
+	    TOPO_SENSOR_READING, TOPO_TYPE_DOUBLE, "ipmi_sensor_reading",
+	    arg_nvl, &err) != 0) {
+		topo_mod_dprintf(mod, "Failed to register %s propmeth on fac "
+		    "node %s (%s)\n", TOPO_SENSOR_READING,
+		    topo_node_name(fnode), topo_strerror(err));
+		nvlist_free(arg_nvl);
+		return (topo_mod_seterrno(mod, err));
+	}
+	if (topo_prop_set_uint32(fnode, TOPO_PGROUP_FACILITY,
+	    TOPO_SENSOR_UNITS, TOPO_PROP_IMMUTABLE, sd->sd_units, &err) != 0) {
+		topo_mod_dprintf(mod, "Failed to set units property on node "
+		    "%s (%s)\n", topo_node_name(fnode), topo_strerror(err));
+		nvlist_free(arg_nvl);
+		return (topo_mod_seterrno(mod, err));
+	}
+	nvlist_free(arg_nvl);
+
+	/*
+	 * It is possible (though unusual) for a compact sensor record to
+	 * represent a threshold sensor.  However, due to how
+	 * ipmi_sdr_conv_reading() is currently implemented, we only support
+	 * gathering threshold readings on sensors enumerated from Full Sensor
+	 * Records.
+	 */
+	if (sd->sd_fs_sdr == NULL)
+		return (0);
+
+	if (ipmi_get_sensor_thresholds(hdl, &thresh,
+	    sd->sd_fs_sdr->is_fs_number) != 0) {
+		topo_mod_dprintf(mod, "Failed to get sensor thresholds for "
+		    "node %s (%s)\n", topo_node_name(fnode), ipmi_errmsg(hdl));
+		return (topo_mod_seterrno(mod, EMOD_PARTIAL_ENUM));
+	}
+
+	/*
+	 * The IPMI Get Sensor Thresholds command returns a bitmask describing
+	 * which of the 3 upper and lower thresholds are readable.  Iterate
+	 * through those and create a topo property for each threshold that is
+	 * readable.
+	 */
+	mask = thresh.ithr_readable_mask;
+	for (i = 0; i < num_thresholds; i++) {
+		if (!ISBITSET(mask, threshset[i].sthr_threshbit))
+			continue;
+
+		if (set_thresh_prop(mod, fnode, sd->sd_fs_sdr,
+		    *(uint8_t *)((char *)&thresh +
+		    threshset[i].sthr_threshoff), &threshset[i]) != 0) {
+			/* errno set */
 			return (-1);
 		}
 	}
-	nvlist_free(arg_nvl);
 	return (0);
 }
 
@@ -1513,6 +1647,7 @@ sdr_callback(ipmi_handle_t *hdl, const char *id, ipmi_sdr_t *sdr, void *data)
 			sd.sd_units = f_sensor->is_fs_unit2;
 			sd.sd_stype = f_sensor->is_fs_type;
 			sd.sd_rtype = f_sensor->is_fs_reading_type;
+			sd.sd_fs_sdr = f_sensor;
 			break;
 		case IPMI_SDR_TYPE_COMPACT_SENSOR:
 			c_sensor =
@@ -1527,6 +1662,7 @@ sdr_callback(ipmi_handle_t *hdl, const char *id, ipmi_sdr_t *sdr, void *data)
 			sd.sd_units = c_sensor->is_cs_unit2;
 			sd.sd_stype = c_sensor->is_cs_type;
 			sd.sd_rtype = c_sensor->is_cs_reading_type;
+			sd.sd_fs_sdr = NULL;
 			break;
 		default:
 			return (0);
@@ -1546,7 +1682,7 @@ sdr_callback(ipmi_handle_t *hdl, const char *id, ipmi_sdr_t *sdr, void *data)
 	    ei->ei_list, ei->ei_listsz) == B_TRUE) ||
 	    (sensor_entity == ei->ei_id && sensor_inst == ei->ei_inst)) {
 
-		if (make_sensor_node(ei->ei_mod, ei->ei_node, &sd) != 0) {
+		if (make_sensor_node(ei->ei_mod, ei->ei_node, &sd, hdl) != 0) {
 			topo_mod_dprintf(ei->ei_mod, "Failed to create sensor "
 			    "node for %s\n", sd.sd_entity_ref);
 			if (topo_mod_errno(ei->ei_mod) != EMOD_NODE_DUP)
diff --git a/usr/src/lib/libipmi/common/ipmi_sdr.c b/usr/src/lib/libipmi/common/ipmi_sdr.c
index 2adab34f6c..14a5fbd8cc 100644
--- a/usr/src/lib/libipmi/common/ipmi_sdr.c
+++ b/usr/src/lib/libipmi/common/ipmi_sdr.c
@@ -23,6 +23,10 @@
  * Copyright 2010 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
  */
+/*
+ * Copyright (c) 2018, Joyent, Inc.
+ */
+
 
 #include <libipmi.h>
 #include <stddef.h>
@@ -83,6 +87,8 @@
 
 typedef struct ipmi_sdr_cache_ent {
 	char				*isc_name;
+	uint8_t				isc_entity_id;
+	uint8_t				isc_entity_inst;
 	struct ipmi_sdr			*isc_sdr;
 	ipmi_hash_link_t		isc_link;
 } ipmi_sdr_cache_ent_t;
@@ -184,7 +190,7 @@ ipmi_sdr_refresh(ipmi_handle_t *ihp)
 	ipmi_sdr_t *sdr;
 	ipmi_sdr_cache_ent_t *ent;
 	size_t namelen;
-	uint8_t type;
+	uint8_t type, e_id = 0, e_inst = 0;
 	char *name;
 	ipmi_sdr_info_t *sip;
 	uint32_t isi_add_ts, isi_erase_ts;
@@ -223,6 +229,8 @@ ipmi_sdr_refresh(ipmi_handle_t *ihp)
 				namelen = glp->is_gl_idlen;
 				type = glp->is_gl_idtype;
 				name = glp->is_gl_idstring;
+				e_id = glp->is_gl_entity;
+				e_inst = glp->is_gl_instance;
 				break;
 			}
 
@@ -234,6 +242,8 @@ ipmi_sdr_refresh(ipmi_handle_t *ihp)
 				namelen = flp->is_fl_idlen;
 				name = flp->is_fl_idstring;
 				type = flp->is_fl_idtype;
+				e_id = flp->is_fl_entity;
+				e_inst = flp->is_fl_instance;
 				break;
 			}
 
@@ -247,6 +257,8 @@ ipmi_sdr_refresh(ipmi_handle_t *ihp)
 				namelen = csp->is_cs_idlen;
 				type = csp->is_cs_idtype;
 				name = csp->is_cs_idstring;
+				e_id = csp->is_cs_entity_id;
+				e_inst = csp->is_cs_entity_instance;
 
 				tmp = LE_IN16(&csp->is_cs_assert_mask);
 				(void) memcpy(&csp->is_cs_assert_mask, &tmp,
@@ -272,6 +284,8 @@ ipmi_sdr_refresh(ipmi_handle_t *ihp)
 				namelen = fsp->is_fs_idlen;
 				type = fsp->is_fs_idtype;
 				name = fsp->is_fs_idstring;
+				e_id = fsp->is_fs_entity_id;
+				e_inst = fsp->is_fs_entity_instance;
 
 				tmp = LE_IN16(&fsp->is_fs_assert_mask);
 				(void) memcpy(&fsp->is_fs_assert_mask, &tmp,
@@ -295,6 +309,8 @@ ipmi_sdr_refresh(ipmi_handle_t *ihp)
 				namelen = esp->is_eo_idlen;
 				type = esp->is_eo_idtype;
 				name = esp->is_eo_idstring;
+				e_id = esp->is_eo_entity_id;
+				e_inst = esp->is_eo_entity_instance;
 				break;
 			}
 
@@ -306,6 +322,8 @@ ipmi_sdr_refresh(ipmi_handle_t *ihp)
 				namelen = msp->is_ml_idlen;
 				type = msp->is_ml_idtype;
 				name = msp->is_ml_idstring;
+				e_id = msp->is_ml_entity_id;
+				e_inst = msp->is_ml_entity_instance;
 				break;
 			}
 
@@ -334,6 +352,8 @@ ipmi_sdr_refresh(ipmi_handle_t *ihp)
 		}
 
 		ent->isc_sdr = sdr;
+		ent->isc_entity_id = e_id;
+		ent->isc_entity_inst = e_inst;
 
 		if (name != NULL) {
 			if ((ent->isc_name = ipmi_alloc(ihp, namelen + 1)) ==
@@ -407,18 +427,17 @@ ipmi_sdr_hash_compare(const void *a, const void *b)
 		return (-1);
 
 	/*
-	 * While it is strange for a service processor to report multiple
-	 * entries with the same name, we allow it by treating the (name, id)
-	 * as the unique identifier.  When looking up by name, the SDR pointer
-	 * is NULL, and we return the first matching name.
+	 * When looking up only by name we return the first matching name. For
+	 * a more precise match, callers can optionally specify an IPMI entity
+	 * ID and instance that must also match.
 	 */
-	if (ap->isc_sdr == NULL || bp->isc_sdr == NULL)
-		return (0);
-
-	if (ap->isc_sdr->is_id == bp->isc_sdr->is_id)
-		return (0);
-	else
-		return (-1);
+	if (ap->isc_entity_id != IPMI_ET_UNSPECIFIED &&
+	    bp->isc_entity_id != IPMI_ET_UNSPECIFIED) {
+		if (ap->isc_entity_id != bp->isc_entity_id ||
+		    ap->isc_entity_inst != bp->isc_entity_inst)
+			return (-1);
+	}
+	return (0);
 }
 
 int
@@ -563,6 +582,13 @@ ipmi_sdr_iter(ipmi_handle_t *ihp, int (*func)(ipmi_handle_t *,
 
 ipmi_sdr_t *
 ipmi_sdr_lookup(ipmi_handle_t *ihp, const char *idstr)
+{
+	return (ipmi_sdr_lookup_precise(ihp, idstr, IPMI_ET_UNSPECIFIED, 0));
+}
+
+ipmi_sdr_t *
+ipmi_sdr_lookup_precise(ipmi_handle_t *ihp, const char *idstr, uint8_t e_id,
+    uint8_t e_inst)
 {
 	ipmi_sdr_cache_ent_t *ent, search;
 
@@ -572,6 +598,8 @@ ipmi_sdr_lookup(ipmi_handle_t *ihp, const char *idstr)
 
 	search.isc_name = (char *)idstr;
 	search.isc_sdr = NULL;
+	search.isc_entity_id = e_id;
+	search.isc_entity_inst = e_inst;
 	if ((ent = ipmi_hash_lookup(ihp->ih_sdr_cache, &search)) == NULL) {
 		(void) ipmi_set_error(ihp, EIPMI_NOT_PRESENT, NULL);
 		return (NULL);
diff --git a/usr/src/lib/libipmi/common/ipmi_sensor.c b/usr/src/lib/libipmi/common/ipmi_sensor.c
index 0b035709a3..63a7999d56 100644
--- a/usr/src/lib/libipmi/common/ipmi_sensor.c
+++ b/usr/src/lib/libipmi/common/ipmi_sensor.c
@@ -22,8 +22,9 @@
  * Copyright 2008 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
  */
-
-#pragma ident	"%Z%%M%	%I%	%E% SMI"
+/*
+ * Copyright (c) 2018, Joyent, Inc.
+ */
 
 #include <libipmi.h>
 #include <string.h>
@@ -95,3 +96,27 @@ ipmi_set_sensor_reading(ipmi_handle_t *ihp, ipmi_set_sensor_reading_t *req)
 
 	return (0);
 }
+
+int
+ipmi_get_sensor_thresholds(ipmi_handle_t *ihp, ipmi_sensor_thresholds_t *thresh,
+    uint8_t id)
+{
+	ipmi_cmd_t cmd, *resp;
+
+	cmd.ic_netfn = IPMI_NETFN_SE;
+	cmd.ic_cmd = IPMI_CMD_GET_SENSOR_THRESHOLDS;
+	cmd.ic_lun = 0;
+	cmd.ic_data = &id;
+	cmd.ic_dlen = sizeof (id);
+
+	if ((resp = ipmi_send(ihp, &cmd)) == NULL)
+		return (-1);
+
+	if (resp->ic_dlen < sizeof (ipmi_sensor_thresholds_t)) {
+		return (ipmi_set_error(ihp, EIPMI_BAD_RESPONSE_LENGTH, NULL));
+	}
+
+	(void) memcpy(thresh, resp->ic_data, sizeof (ipmi_sensor_thresholds_t));
+
+	return (0);
+}
diff --git a/usr/src/lib/libipmi/common/libipmi.h b/usr/src/lib/libipmi/common/libipmi.h
index 01bf3cb546..c3605616ed 100644
--- a/usr/src/lib/libipmi/common/libipmi.h
+++ b/usr/src/lib/libipmi/common/libipmi.h
@@ -1534,10 +1534,13 @@ extern int ipmi_sdr_iter(ipmi_handle_t *,
     int (*)(ipmi_handle_t *, const char *, ipmi_sdr_t *, void *), void *);
 
 /*
- * Lookup the given sensor type by name.  These functions automatically read in
- * and cache the complete SDR repository.
+ * Lookup the given sensor type by name or a combination of name and entity
+ * ID/instance.  These functions automatically read in and cache the complete
+ * SDR repository.
  */
 extern ipmi_sdr_t *ipmi_sdr_lookup(ipmi_handle_t *, const char *);
+extern ipmi_sdr_t *ipmi_sdr_lookup_precise(ipmi_handle_t *, const char *,
+    uint8_t, uint8_t);
 extern ipmi_sdr_fru_locator_t *ipmi_sdr_lookup_fru(ipmi_handle_t *,
     const char *);
 extern ipmi_sdr_generic_locator_t *ipmi_sdr_lookup_generic(ipmi_handle_t *,
@@ -1605,6 +1608,24 @@ extern ipmi_sdr_full_sensor_t *ipmi_sdr_lookup_full_sensor(
 #define	IPMI_ET_FSB			0x34
 #define	IPMI_ET_RTC			0x35
 
+/*
+ * Get Sensor Threshold.  See section 35.9
+ */
+#define	IPMI_CMD_GET_SENSOR_THRESHOLDS	0x27
+
+typedef struct ipmi_sensor_thresholds {
+	uint8_t ithr_readable_mask;
+	uint8_t ithr_lower_noncrit;
+	uint8_t ithr_lower_crit;
+	uint8_t ithr_lower_nonrec;
+	uint8_t ithr_upper_noncrit;
+	uint8_t ithr_upper_crit;
+	uint8_t ithr_upper_nonrec;
+} ipmi_sensor_thresholds_t;
+
+extern int ipmi_get_sensor_thresholds(ipmi_handle_t *,
+    ipmi_sensor_thresholds_t *, uint8_t);
+
 /*
  * Get Sensor Reading.  See section 35.14.
  */
diff --git a/usr/src/lib/libipmi/common/mapfile-vers b/usr/src/lib/libipmi/common/mapfile-vers
index 85526ddd84..155fcbc471 100644
--- a/usr/src/lib/libipmi/common/mapfile-vers
+++ b/usr/src/lib/libipmi/common/mapfile-vers
@@ -23,7 +23,7 @@
 #
 
 #
-# Copyright (c) 2017, Joyent, Inc.
+# Copyright (c) 2018, Joyent, Inc.
 #
 
 #
@@ -66,6 +66,7 @@ SYMBOL_VERSION SUNWprivate_1.1 {
 	ipmi_get_channel_info;
 	ipmi_get_deviceid;
 	ipmi_get_sensor_reading;
+	ipmi_get_sensor_thresholds;
 	ipmi_is_sun_ilom;
 	ipmi_lan_get_config;
 	ipmi_lan_set_config;
@@ -79,6 +80,7 @@ SYMBOL_VERSION SUNWprivate_1.1 {
 	ipmi_sdr_lookup_full_sensor;
 	ipmi_sdr_lookup_fru;
 	ipmi_sdr_lookup_generic;
+	ipmi_sdr_lookup_precise;
 	ipmi_sdr_refresh;
 	ipmi_sel_get_entry;
 	ipmi_sel_get_info;
diff --git a/usr/src/lib/libmlrpc/Makefile b/usr/src/lib/libmlrpc/Makefile
new file mode 100644
index 0000000000..ae458ebc7a
--- /dev/null
+++ b/usr/src/lib/libmlrpc/Makefile
@@ -0,0 +1,65 @@
+#
+# CDDL HEADER START
+#
+# The contents of this file are subject to the terms of the
+# Common Development and Distribution License (the "License").
+# You may not use this file except in compliance with the License.
+#
+# You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
+# or http://www.opensolaris.org/os/licensing.
+# See the License for the specific language governing permissions
+# and limitations under the License.
+#
+# When distributing Covered Code, include this CDDL HEADER in each
+# file and include the License file at usr/src/OPENSOLARIS.LICENSE.
+# If applicable, add the following below this CDDL HEADER, with the
+# fields enclosed by brackets "[]" replaced with your own identifying
+# information: Portions Copyright [yyyy] [name of copyright owner]
+#
+# CDDL HEADER END
+#
+#
+# Copyright 2007 Sun Microsystems, Inc.  All rights reserved.
+# Use is subject to license terms.
+#
+# Copyright 2013 Nexenta Systems, Inc.  All rights reserved.
+#
+
+include $(SRC)/lib/Makefile.lib
+
+HDRS=		libmlrpc.h ndr.h ndrtypes.ndl rpcpdu.ndl
+HDRDIR=		common
+
+ROOTHDRDIR=	$(ROOT)/usr/include/libmlrpc
+ROOTHDRS= $(HDRS:%=$(ROOTHDRDIR)/%)
+
+# ISA targets
+SUBDIRS = $(MACH)
+$(BUILD64)SUBDIRS += $(MACH64)
+
+all :=		TARGET = all
+install :=	TARGET = install
+clean :=	TARGET = clean
+clobber :=	TARGET = clobber
+lint :=		TARGET = lint
+
+.KEEP_STATE:
+
+all install clean clobber lint: $(SUBDIRS)
+
+install_h: $(ROOTHDRDIR) $(ROOTHDRS)
+
+check: $(CHECKHDRS)
+
+$(ROOTHDRDIR)/%: %
+	$(INS.file)
+
+$(ROOTHDRDIR):
+	$(INS.dir)
+
+$(SUBDIRS): FRC
+	@cd $@; pwd; VERSION='$(VERSION)' $(MAKE) $(TARGET)
+
+FRC:
+
+include $(SRC)/lib/Makefile.targ
diff --git a/usr/src/lib/smbsrv/libmlrpc/Makefile.com b/usr/src/lib/libmlrpc/Makefile.com
similarity index 65%
rename from usr/src/lib/smbsrv/libmlrpc/Makefile.com
rename to usr/src/lib/libmlrpc/Makefile.com
index fa45211464..1a2ecb4ddd 100644
--- a/usr/src/lib/smbsrv/libmlrpc/Makefile.com
+++ b/usr/src/lib/libmlrpc/Makefile.com
@@ -18,39 +18,58 @@
 #
 # CDDL HEADER END
 #
+
 #
 # Copyright 2008 Sun Microsystems, Inc.  All rights reserved.
 # Use is subject to license terms.
 #
+# Copyright 2013 Nexenta Systems, Inc.  All rights reserved.
+#
 
 LIBRARY =	libmlrpc.a
-VERS =		.1
+VERS =		.2
 
-OBJS_COMMON = 			\
+OBJS_COMMON =			\
+	mlrpc_clh.o		\
 	ndr_client.o		\
 	ndr_heap.o		\
 	ndr_marshal.o		\
 	ndr_ops.o		\
 	ndr_process.o		\
 	ndr_server.o		\
-	ndr_svc.o
+	ndr_svc.o		\
+	ndr_wchar.o
 
 NDLLIST = rpcpdu
 
-OBJECTS=	$(OBJS_COMMON) $(OBJS_SHARED) $(NDLLIST:%=%_ndr.o)
+OBJECTS=	$(OBJS_COMMON) $(NDLLIST:%=%_ndr.o)
+CLEANFILES += $(NDLLIST:%=%_ndr.c)
 
-include ../../../Makefile.lib
 include ../../Makefile.lib
 
-INCS += -I$(SRC)/common/smbsrv
+LIBS=		$(DYNLIB) $(LINTLIB)
+
+LDLIBS +=	-lsmbfs -luuid -lc
+
+SRCDIR=		../common
+SRCS=   $(OBJS_COMMON:%.o=$(SRCDIR)/%.c)
+$(LINTLIB) := SRCS = $(SRCDIR)/$(LINTSRC)
 
-LDLIBS +=	$(MACH_LDLIBS)
-LDLIBS +=	-lsmb -luuid -lc
+NDLDIR =	$(SRCDIR)
 
+CFLAGS +=	$(CCVERBOSE)
+INCS = -I. -I$(SRCDIR)
 CPPFLAGS += $(INCS) -D_REENTRANT
 
-SRCS=   $(OBJS_COMMON:%.o=$(SRCDIR)/%.c)		\
-	$(OBJS_SHARED:%.o=$(SRC)/common/smbsrv/%.c)
+all:	$(LIBS)
+
+lint:	lintcheck
 
 include ../../Makefile.targ
-include ../../../Makefile.targ
+
+objs/%_ndr.o pics/%_ndr.o : %_ndr.c
+
+%_ndr.c : $(NDLDIR)/%.ndl
+	$(NDRGEN) -Y $(ANSI_CPP) $(CPPFLAGS) $<
+
+.KEEP_STATE:
diff --git a/usr/src/lib/smbsrv/libmlrpc/sparcv9/Makefile b/usr/src/lib/libmlrpc/amd64/Makefile
similarity index 90%
rename from usr/src/lib/smbsrv/libmlrpc/sparcv9/Makefile
rename to usr/src/lib/libmlrpc/amd64/Makefile
index b3c4916b0c..087f0e1107 100644
--- a/usr/src/lib/smbsrv/libmlrpc/sparcv9/Makefile
+++ b/usr/src/lib/libmlrpc/amd64/Makefile
@@ -22,14 +22,10 @@
 # Copyright 2007 Sun Microsystems, Inc.  All rights reserved.
 # Use is subject to license terms.
 #
-# ident	"%Z%%M%	%I%	%E% SMI"
-#
 
 MACH_LDLIBS +=	-L$(ROOT)/usr/lib/smbsrv/$(MACH64)
 
 include ../Makefile.com
-include ../../../Makefile.lib.64
-
-DYNFLAGS +=	-R/usr/lib/smbsrv/$(MACH64)
+include ../../Makefile.lib.64
 
 install: all $(ROOTLIBS64) $(ROOTLINKS64) $(ROOTLINT64)
diff --git a/usr/src/lib/smbsrv/libmlrpc/common/libmlrpc.h b/usr/src/lib/libmlrpc/common/libmlrpc.h
similarity index 92%
rename from usr/src/lib/smbsrv/libmlrpc/common/libmlrpc.h
rename to usr/src/lib/libmlrpc/common/libmlrpc.h
index 5b55ce4c54..d020532cbe 100644
--- a/usr/src/lib/smbsrv/libmlrpc/common/libmlrpc.h
+++ b/usr/src/lib/libmlrpc/common/libmlrpc.h
@@ -28,10 +28,9 @@
 
 #include <sys/types.h>
 #include <sys/uio.h>
-#include <smbsrv/wintypes.h>
-#include <smbsrv/ndr.h>
-#include <smbsrv/smb_sid.h>
-#include <smbsrv/smb_xdr.h>
+
+#include <smb/wintypes.h>
+#include <libmlrpc/ndr.h>
 
 #ifdef	__cplusplus
 extern "C" {
@@ -247,9 +246,9 @@ typedef struct ndr_binding {
 #define	NDR_N_BINDING_POOL	2
 
 typedef struct ndr_pipe {
-	void 			*np_listener;
+	void			*np_listener;
 	const char		*np_endpoint;
-	smb_netuserinfo_t	*np_user;
+	struct smb_netuserinfo	*np_user;
 	int			(*np_send)(struct ndr_pipe *, void *, size_t);
 	int			(*np_recv)(struct ndr_pipe *, void *, size_t);
 	int			np_fid;
@@ -402,12 +401,12 @@ typedef struct ndr_vcbuf {
 
 ndr_heap_t *ndr_heap_create(void);
 void ndr_heap_destroy(ndr_heap_t *);
+void *ndr_heap_dupmem(ndr_heap_t *, const void *, size_t);
 void *ndr_heap_malloc(ndr_heap_t *, unsigned);
 void *ndr_heap_strdup(ndr_heap_t *, const char *);
 int ndr_heap_mstring(ndr_heap_t *, const char *, ndr_mstring_t *);
 void ndr_heap_mkvcs(ndr_heap_t *, char *, ndr_vcstr_t *);
 void ndr_heap_mkvcb(ndr_heap_t *, uint8_t *, uint32_t, ndr_vcbuf_t *);
-smb_sid_t *ndr_heap_siddup(ndr_heap_t *, smb_sid_t *);
 int ndr_heap_used(ndr_heap_t *);
 int ndr_heap_avail(ndr_heap_t *);
 
@@ -416,7 +415,7 @@ int ndr_heap_avail(ndr_heap_t *);
 #define	NDR_NEWN(XA, T, N)	ndr_heap_malloc((XA)->heap, sizeof (T)*(N))
 #define	NDR_STRDUP(XA, S)	ndr_heap_strdup((XA)->heap, (S))
 #define	NDR_MSTRING(XA, S, OUT)	ndr_heap_mstring((XA)->heap, (S), (OUT))
-#define	NDR_SIDDUP(XA, S)	ndr_heap_siddup((XA)->heap, (S))
+#define	NDR_SIDDUP(XA, S)	ndr_heap_dupmem((XA)->heap, (S), smb_sid_len(S))
 
 typedef struct ndr_xa {
 	unsigned short		ptype;		/* high bits special */
@@ -488,7 +487,7 @@ void nds_destruct(ndr_stream_t *);
 void nds_show_state(ndr_stream_t *);
 
 /* ndr_client.c */
-int ndr_clnt_bind(ndr_client_t *, const char *, ndr_binding_t **);
+int ndr_clnt_bind(ndr_client_t *, ndr_service_t *, ndr_binding_t **);
 int ndr_clnt_call(ndr_binding_t *, int, void *);
 void ndr_clnt_free_heap(ndr_client_t *);
 
@@ -514,10 +513,6 @@ void ndr_pipe_worker(ndr_pipe_t *);
 
 int ndr_generic_call_stub(ndr_xa_t *);
 
-boolean_t ndr_is_admin(ndr_xa_t *);
-boolean_t ndr_is_poweruser(ndr_xa_t *);
-int32_t ndr_native_os(ndr_xa_t *);
-
 /* ndr_svc.c */
 ndr_stub_table_t *ndr_svc_find_stub(ndr_service_t *, int);
 ndr_service_t *ndr_svc_lookup_name(const char *);
@@ -538,6 +533,38 @@ void ndr_hdclose(ndr_pipe_t *);
 
 ssize_t ndr_uiomove(caddr_t, size_t, enum uio_rw, struct uio *);
 
+/*
+ * An ndr_client_t is created while binding a client connection to hold
+ * the context for calls made using that connection.
+ *
+ * Handles are RPC call specific and we use an inheritance mechanism to
+ * ensure that each handle has a pointer to the client_t.  When the top
+ * level (bind) handle is released, we close the connection.
+ *
+ * There are some places in libmlsvc where the code assumes that the
+ * handle member is first in this struct.  careful
+ */
+typedef struct mlrpc_handle {
+	ndr_hdid_t	handle;		/* keep first */
+	ndr_client_t	*clnt;
+} mlrpc_handle_t;
+
+int mlrpc_clh_create(mlrpc_handle_t *, void *);
+uint32_t mlrpc_clh_bind(mlrpc_handle_t *, ndr_service_t *);
+void mlrpc_clh_unbind(mlrpc_handle_t *);
+void *mlrpc_clh_free(mlrpc_handle_t *);
+
+int ndr_rpc_call(mlrpc_handle_t *, int, void *);
+int ndr_rpc_get_ssnkey(mlrpc_handle_t *, unsigned char *, size_t);
+void *ndr_rpc_malloc(mlrpc_handle_t *, size_t);
+ndr_heap_t *ndr_rpc_get_heap(mlrpc_handle_t *);
+void ndr_rpc_release(mlrpc_handle_t *);
+void ndr_rpc_set_nonull(mlrpc_handle_t *);
+
+boolean_t ndr_is_null_handle(mlrpc_handle_t *);
+boolean_t ndr_is_bind_handle(mlrpc_handle_t *);
+void ndr_inherit_handle(mlrpc_handle_t *, mlrpc_handle_t *);
+
 #ifdef	__cplusplus
 }
 #endif
diff --git a/usr/src/lib/smbsrv/libmlrpc/common/llib-lmlrpc b/usr/src/lib/libmlrpc/common/llib-lmlrpc
similarity index 91%
rename from usr/src/lib/smbsrv/libmlrpc/common/llib-lmlrpc
rename to usr/src/lib/libmlrpc/common/llib-lmlrpc
index 1621e3c2f6..3345e6129a 100644
--- a/usr/src/lib/smbsrv/libmlrpc/common/llib-lmlrpc
+++ b/usr/src/lib/libmlrpc/common/llib-lmlrpc
@@ -21,11 +21,11 @@
 /*
  * Copyright 2007 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
+ *
+ * Copyright 2013 Nexenta Systems, Inc.  All rights reserved.
  */
 
-#pragma ident	"%Z%%M%	%I%	%E% SMI"
-
 /*LINTLIBRARY*/
 /*PROTOLIB1*/
 
-#include <smbsrv/libmlrpc.h>
+#include <libmlrpc.h>
diff --git a/usr/src/lib/smbsrv/libmlrpc/common/mapfile-vers b/usr/src/lib/libmlrpc/common/mapfile-vers
similarity index 62%
rename from usr/src/lib/smbsrv/libmlrpc/common/mapfile-vers
rename to usr/src/lib/libmlrpc/common/mapfile-vers
index 5822d32711..241d8309d0 100644
--- a/usr/src/lib/smbsrv/libmlrpc/common/mapfile-vers
+++ b/usr/src/lib/libmlrpc/common/mapfile-vers
@@ -42,47 +42,74 @@ $mapfile_version 2
 
 SYMBOL_VERSION SUNWprivate {
     global:
-        ndr_buf_decode;
-        ndr_buf_fini;
-        ndr_buf_init;
-        ndr_clnt_bind;
-        ndr_clnt_call;
-        ndr_clnt_free_heap;
+	mlrpc_clh_bind;
+	mlrpc_clh_create;
+	mlrpc_clh_free;
+	mlrpc_clh_unbind;
+
+	# Allow debug/test programs to provide these.
+	ndo_printf		{ FLAGS = NODIRECT };
+	ndo_trace		{ FLAGS = NODIRECT };
+
+	ndr_buf_decode;
+	ndr_buf_fini;
+	ndr_buf_init;
+	ndr_clnt_bind;
+	ndr_clnt_call;
+	ndr_clnt_free_heap;
 	ndr_generic_call_stub;
-        ndr_heap_avail;
-        ndr_heap_create;
-        ndr_heap_destroy;
-        ndr_heap_malloc;
-        ndr_heap_mkvcb;
-        ndr_heap_mkvcs;
+	ndr_heap_avail;
+	ndr_heap_create;
+	ndr_heap_destroy;
+	ndr_heap_dupmem;
+	ndr_heap_malloc;
+	ndr_heap_mkvcb;
+	ndr_heap_mkvcs;
 	ndr_heap_mstring;
-	ndr_heap_siddup;
-        ndr_heap_strdup;
-        ndr_heap_used;
+	ndr_heap_strdup;
+	ndr_heap_used;
 	ndr_hdalloc;
+	ndr_hdclose;
 	ndr_hdfree;
 	ndr_hdlookup;
-        ndr_inner;
-	ndr_is_admin;
-	ndr_is_poweruser;
+	ndr_inherit_handle;
+	ndr_inner;
+	ndr_is_bind_handle;
+	ndr_is_null_handle;
 	ndr_mbstowcs;
-	ndr_mbtowc;
-	ndr_native_os;
-        ndr_params;
+	ndr_params;
 	ndr_pipe_worker;
-        ndr_svc_binding_pool_init;
+	ndr_rpc_call;
+	ndr_rpc_get_heap;
+	ndr_rpc_get_ssnkey;
+	ndr_rpc_malloc;
+	ndr_rpc_release;
+	ndr_rpc_set_nonull;
+	ndr_svc_binding_pool_init;
 	ndr_svc_lookup_name;
-        ndr_svc_register;
-        ndr_topmost;
+	ndr_svc_register;
+	ndr_topmost;
 	ndr_uuid_parse;
 	ndr_uuid_unparse;
-        nds_destruct;
-        nds_initialize;
-        ndt__char;
-        ndt_s_wchar;
-        ndt__uchar;
-        ndt__ulong;
-        ndt__ushort;
+
+	nds_destruct;
+	nds_initialize;
+
+	ndt__char;
+	ndt_s_char;
+	ndt__uchar;
+	ndt_s_uchar;
+	ndt__wchar;
+	ndt_s_wchar;
+	ndt__short;
+	ndt_s_short;
+	ndt__ushort;
+	ndt_s_ushort;
+	ndt__long;
+	ndt_s_long;
+	ndt__ulong;
+	ndt_s_ulong;
+
     local:
 	*;
 };
diff --git a/usr/src/lib/libmlrpc/common/mlrpc_clh.c b/usr/src/lib/libmlrpc/common/mlrpc_clh.c
new file mode 100644
index 0000000000..72c051d675
--- /dev/null
+++ b/usr/src/lib/libmlrpc/common/mlrpc_clh.c
@@ -0,0 +1,578 @@
+/*
+ * CDDL HEADER START
+ *
+ * The contents of this file are subject to the terms of the
+ * Common Development and Distribution License (the "License").
+ * You may not use this file except in compliance with the License.
+ *
+ * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
+ * or http://www.opensolaris.org/os/licensing.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * When distributing Covered Code, include this CDDL HEADER in each
+ * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
+ * If applicable, add the following below this CDDL HEADER, with the
+ * fields enclosed by brackets "[]" replaced with your own identifying
+ * information: Portions Copyright [yyyy] [name of copyright owner]
+ *
+ * CDDL HEADER END
+ */
+
+/*
+ * Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
+ * Use is subject to license terms.
+ *
+ * Copyright 2013 Nexenta Systems, Inc.  All rights reserved.
+ */
+
+/*
+ * ML-RPC Client handle interface and support functions.
+ */
+
+#include <sys/types.h>
+#include <sys/fcntl.h>
+#include <sys/poll.h>
+
+#include <errno.h>
+#include <strings.h>
+#include <unistd.h>
+
+#include <netsmb/smbfs_api.h>
+#include <smb/ntstatus.h>
+#include <libmlrpc.h>
+
+#include <assert.h>
+
+static int ndr_xa_init(ndr_client_t *, ndr_xa_t *);
+static int ndr_xa_exchange(ndr_client_t *, ndr_xa_t *);
+static int ndr_xa_read(ndr_client_t *, ndr_xa_t *);
+static void ndr_xa_preserve(ndr_client_t *, ndr_xa_t *);
+static void ndr_xa_destruct(ndr_client_t *, ndr_xa_t *);
+static void ndr_xa_release(ndr_client_t *);
+
+/* See notes in mlrpc_clh_bind */
+int rpc_pipe_open_retries = 10;
+
+/*
+ * Create an RPC client binding handle using the given smb_ctx.
+ * That context must already have a session and tree connected.
+ *
+ * Returns zero or an errno value.
+ */
+int
+mlrpc_clh_create(mlrpc_handle_t *handle, void *ctx)
+{
+	ndr_client_t	*clnt = NULL;
+
+	if (ctx == NULL)
+		return (EINVAL);
+
+	/*
+	 * Allocate...
+	 */
+	if ((clnt = malloc(sizeof (*clnt))) == NULL)
+		return (ENOMEM);
+	bzero(clnt, sizeof (*clnt));
+
+	clnt->xa_fd = -1;
+
+	/*
+	 * Setup the transport functions.
+	 * Always a named pipe (for now).
+	 */
+	clnt->xa_private = ctx;
+	clnt->xa_init = ndr_xa_init;
+	clnt->xa_exchange = ndr_xa_exchange;
+	clnt->xa_read = ndr_xa_read;
+	clnt->xa_preserve = ndr_xa_preserve;
+	clnt->xa_destruct = ndr_xa_destruct;
+	clnt->xa_release = ndr_xa_release;
+
+	/* See _is_bind_handle */
+	clnt->handle = &handle->handle;
+
+	ndr_svc_binding_pool_init(&clnt->binding_list,
+	    clnt->binding_pool, NDR_N_BINDING_POOL);
+
+	if ((clnt->heap = ndr_heap_create()) == NULL)
+		goto nomem;
+
+	/* success! */
+	bzero(handle, sizeof (*handle));
+	handle->clnt = clnt;
+	return (0);
+
+nomem:
+	free(clnt);
+	return (ENOMEM);
+}
+
+
+/*
+ * This call must be made to initialize an RPC client structure and bind
+ * to the remote service before any RPCs can be exchanged with that service.
+ *
+ * The mlrpc_handle_t is a wrapper that is used to associate an RPC handle
+ * with the client context for an instance of the interface.  The handle
+ * is zeroed to ensure that it doesn't look like a valid handle -
+ * handle content is provided by the remove service.
+ *
+ * The client points to this top-level handle so that we know when to
+ * unbind and teardown the connection.  As each handle is initialized it
+ * will inherit a reference to the client context.
+ *
+ *
+ * Similar to MSRPC RpcBindingBind()
+ *
+ * Returns 0 or an NT_STATUS:		(failed in...)
+ *
+ *	RPC_NT_SERVER_TOO_BUSY		(open pipe)
+ *	RPC_NT_SERVER_UNAVAILABLE	(open pipe)
+ *	NT_STATUS_ACCESS_DENIED		(open pipe)
+ *	NT_STATUS_INVALID_PARAMETER	(rpc bind)
+ *	NT_STATUS_INTERNAL_ERROR	(bad args etc)
+ *	NT_STATUS_NO_MEMORY
+ */
+uint32_t
+mlrpc_clh_bind(mlrpc_handle_t *handle, ndr_service_t *svc)
+{
+	ndr_client_t		*clnt = NULL;
+	struct smb_ctx		*ctx = NULL;
+	uint32_t		status = 0;
+	int			fd = -1;
+	int			rc, retries;
+
+	if ((clnt = handle->clnt) == NULL)
+		return (NT_STATUS_INTERNAL_ERROR);
+	if ((ctx = clnt->xa_private) == NULL)
+		return (NT_STATUS_INTERNAL_ERROR);
+	if (clnt->xa_fd != -1)
+		return (NT_STATUS_INTERNAL_ERROR);
+
+	/*
+	 * Open the named pipe.
+	 *
+	 * Sometimes a DC may return NT_STATUS_PIPE_NOT_AVAILABLE for
+	 * the first few seconds during service auto-start.  The client
+	 * translates that to EBUSY, so when we see that, wait a bit
+	 * and retry the open for up to rpc_pipe_open_retries.  If we
+	 * fail even after retries, return RPC_NT_SERVER_TOO_BUSY,
+	 * which is how callers of this layer expect that reported.
+	 * We try up to 10 times, with a 0.5 sec. wait after each
+	 * BUSY failure, giving a total wait here of 5 sec.
+	 */
+	retries = rpc_pipe_open_retries;
+retry_open:
+	fd = smb_fh_open(ctx, svc->endpoint, O_RDWR);
+	if (fd < 0) {
+		rc = errno;
+		switch (rc) {
+		case EBUSY:
+			if (--retries > 0) {
+				(void) poll(NULL, 0, 500);
+				goto retry_open;
+			}
+			status = RPC_NT_SERVER_TOO_BUSY;
+			break;
+		case EACCES:
+			status = NT_STATUS_ACCESS_DENIED;
+			break;
+		default:
+			status = RPC_NT_SERVER_UNAVAILABLE;
+			break;
+		}
+		return (status);
+	}
+
+	clnt->xa_fd = fd;
+
+	/* Paranoia, in case of re-bind. */
+	bzero(&handle->handle, sizeof (ndr_hdid_t));
+
+	/*
+	 * Do the OtW RPC bind.
+	 */
+	rc = ndr_clnt_bind(clnt, svc, &clnt->binding);
+	switch (rc) {
+	case NDR_DRC_FAULT_OUT_OF_MEMORY:
+		status = NT_STATUS_NO_MEMORY;
+		break;
+	case NDR_DRC_FAULT_API_SERVICE_INVALID:
+		/* svc->..._uuid parse errors */
+		status = NT_STATUS_INTERNAL_ERROR;
+		break;
+	default:
+		if (NDR_DRC_IS_FAULT(rc)) {
+			status = RPC_NT_PROTOCOL_ERROR;
+			break;
+		}
+		/* FALLTHROUGH */
+	case NDR_DRC_OK:
+		status = NT_STATUS_SUCCESS;
+	}
+
+	if (status != 0) {
+		if (fd != -1)
+			(void) smb_fh_close(fd);
+		clnt->xa_fd = -1;
+	}
+
+	return (status);
+}
+
+/*
+ * Unbind and close the pipe to an RPC service.
+ *
+ * Similar to MSRPC RpcBindingUnbind()
+ * This should be called after a dropped connection.
+ */
+void
+mlrpc_clh_unbind(mlrpc_handle_t *handle)
+{
+	ndr_client_t *clnt = handle->clnt;
+
+	if (clnt->xa_fd != -1) {
+		(void) smb_fh_close(clnt->xa_fd);
+		clnt->xa_fd = -1;
+	}
+}
+
+/*
+ * If the heap has been preserved we need to go through an xa release.
+ * The heap is preserved during an RPC call because that's where data
+ * returned from the server is stored.
+ *
+ * Otherwise we destroy the heap directly.
+ *
+ * Returns the xa_private pointer (if non-NULL) to inform the caller
+ * that it can now be destroyed.
+ */
+void *
+mlrpc_clh_free(mlrpc_handle_t *handle)
+{
+	ndr_client_t *clnt = handle->clnt;
+	void *private;
+
+	if (clnt == NULL)
+		return (NULL);
+
+	/*
+	 * Should never get an unbind on inherited handles.
+	 * Callers of ndr_inherit_handle() check handles
+	 * with ndr_is_bind_handle() before calling this.
+	 *
+	 * Maybe make this function more tolerant?
+	 */
+	assert(handle->clnt->handle == &handle->handle);
+
+	mlrpc_clh_unbind(handle);
+
+	if (clnt->heap_preserved)
+		ndr_clnt_free_heap(clnt); /* xa_release */
+	else
+		ndr_heap_destroy(clnt->heap);
+
+	/*
+	 * Note: Caller will free the smb_ctx stored in
+	 * clnt->xa_private (or possibly reuse it).
+	 */
+	private = clnt->xa_private;
+	free(clnt);
+	bzero(handle, sizeof (*handle));
+	return (private);
+}
+
+/*
+ * Call the RPC function identified by opnum.  The remote service is
+ * identified by the handle, which should have been initialized by
+ * ndr_rpc_bind.
+ *
+ * If the RPC call is successful (returns 0), the caller must call
+ * ndr_rpc_release to release the heap.  Otherwise, we release the
+ * heap here.
+ */
+int
+ndr_rpc_call(mlrpc_handle_t *handle, int opnum, void *params)
+{
+	ndr_client_t *clnt = handle->clnt;
+	int rc;
+
+	if (ndr_rpc_get_heap(handle) == NULL)
+		return (-1);
+
+	rc = ndr_clnt_call(clnt->binding, opnum, params);
+
+	/*
+	 * Always clear the nonull flag to ensure
+	 * it is not applied to subsequent calls.
+	 */
+	clnt->nonull = B_FALSE;
+
+	if (NDR_DRC_IS_FAULT(rc)) {
+		ndr_rpc_release(handle);
+		return (-1);
+	}
+
+	return (0);
+}
+
+/*
+ * Outgoing strings should not be null terminated.
+ */
+void
+ndr_rpc_set_nonull(mlrpc_handle_t *handle)
+{
+	handle->clnt->nonull = B_TRUE;
+}
+
+/*
+ * Get the session key from a bound RPC client handle.
+ *
+ * The key returned is the 16-byte "user session key"
+ * established by the underlying authentication protocol
+ * (either Kerberos or NTLM).  This key is needed for
+ * SAM RPC calls such as SamrSetInformationUser, etc.
+ * See [MS-SAMR] sections: 2.2.3.3, 2.2.7.21, 2.2.7.25.
+ *
+ * Returns zero (success) or an errno.
+ */
+int
+ndr_rpc_get_ssnkey(mlrpc_handle_t *handle, uchar_t *key, size_t len)
+{
+	ndr_client_t *clnt = handle->clnt;
+
+	if (clnt == NULL || clnt->xa_fd == -1)
+		return (EINVAL);
+
+	return (smb_fh_getssnkey(clnt->xa_fd, key, len));
+}
+
+void *
+ndr_rpc_malloc(mlrpc_handle_t *handle, size_t size)
+{
+	ndr_heap_t *heap;
+
+	if ((heap = ndr_rpc_get_heap(handle)) == NULL)
+		return (NULL);
+
+	return (ndr_heap_malloc(heap, size));
+}
+
+ndr_heap_t *
+ndr_rpc_get_heap(mlrpc_handle_t *handle)
+{
+	ndr_client_t *clnt = handle->clnt;
+
+	if (clnt->heap == NULL)
+		clnt->heap = ndr_heap_create();
+
+	return (clnt->heap);
+}
+
+/*
+ * Must be called by RPC clients to free the heap after a successful RPC
+ * call, i.e. ndr_rpc_call returned 0.  The caller should take a copy
+ * of any data returned by the RPC prior to calling this function because
+ * returned data is in the heap.
+ */
+void
+ndr_rpc_release(mlrpc_handle_t *handle)
+{
+	ndr_client_t *clnt = handle->clnt;
+
+	if (clnt->heap_preserved)
+		ndr_clnt_free_heap(clnt);
+	else
+		ndr_heap_destroy(clnt->heap);
+
+	clnt->heap = NULL;
+}
+
+/*
+ * Returns true if the handle is null.
+ * Otherwise returns false.
+ */
+boolean_t
+ndr_is_null_handle(mlrpc_handle_t *handle)
+{
+	static const ndr_hdid_t hdid0 = {0};
+
+	if (handle == NULL || handle->clnt == NULL)
+		return (B_TRUE);
+
+	if (!memcmp(&handle->handle, &hdid0, sizeof (hdid0)))
+		return (B_TRUE);
+
+	return (B_FALSE);
+}
+
+/*
+ * Returns true if the handle is the top level bind handle.
+ * Otherwise returns false.
+ */
+boolean_t
+ndr_is_bind_handle(mlrpc_handle_t *handle)
+{
+	return (handle->clnt->handle == &handle->handle);
+}
+
+/*
+ * Pass the client reference from parent to child.
+ */
+void
+ndr_inherit_handle(mlrpc_handle_t *child, mlrpc_handle_t *parent)
+{
+	child->clnt = parent->clnt;
+}
+
+/*
+ * ndr_rpc_status remains in libmlsvc mlsvc_client.c
+ */
+
+/*
+ * The following functions provide the client callback interface.
+ * If the caller hasn't provided a heap, create one here.
+ */
+static int
+ndr_xa_init(ndr_client_t *clnt, ndr_xa_t *mxa)
+{
+	ndr_stream_t *recv_nds = &mxa->recv_nds;
+	ndr_stream_t *send_nds = &mxa->send_nds;
+	ndr_heap_t *heap = clnt->heap;
+	int		rc;
+
+	if (heap == NULL) {
+		if ((heap = ndr_heap_create()) == NULL)
+			return (-1);
+
+		clnt->heap = heap;
+	}
+
+	mxa->heap = heap;
+
+	rc = nds_initialize(send_nds, 0, NDR_MODE_CALL_SEND, heap);
+	if (rc == 0)
+		rc = nds_initialize(recv_nds, NDR_PDU_SIZE_HINT_DEFAULT,
+		    NDR_MODE_RETURN_RECV, heap);
+
+	if (rc != 0) {
+		nds_destruct(&mxa->recv_nds);
+		nds_destruct(&mxa->send_nds);
+		ndr_heap_destroy(mxa->heap);
+		mxa->heap = NULL;
+		clnt->heap = NULL;
+		return (-1);
+	}
+
+	if (clnt->nonull)
+		NDS_SETF(send_nds, NDS_F_NONULL);
+
+	return (0);
+}
+
+/*
+ * This is the entry pointy for an RPC client call exchange with
+ * a server, which will result in an smbrdr SmbTransact request.
+ *
+ * SmbTransact should return the number of bytes received, which
+ * we record as the PDU size, or a negative error code.
+ */
+static int
+ndr_xa_exchange(ndr_client_t *clnt, ndr_xa_t *mxa)
+{
+	ndr_stream_t *recv_nds = &mxa->recv_nds;
+	ndr_stream_t *send_nds = &mxa->send_nds;
+	int err, more, nbytes;
+
+	nbytes = recv_nds->pdu_max_size;
+	err = smb_fh_xactnp(clnt->xa_fd,
+	    send_nds->pdu_size, (char *)send_nds->pdu_base_offset,
+	    &nbytes, (char *)recv_nds->pdu_base_offset, &more);
+	if (err) {
+		recv_nds->pdu_size = 0;
+		return (-1);
+	}
+
+	recv_nds->pdu_size = nbytes;
+	return (0);
+}
+
+/*
+ * This entry point will be invoked if the xa-exchange response contained
+ * only the first fragment of a multi-fragment response.  The RPC client
+ * code will then make repeated xa-read requests to obtain the remaining
+ * fragments, which will result in smbrdr SmbReadX requests.
+ *
+ * SmbReadX should return the number of bytes received, in which case we
+ * expand the PDU size to include the received data, or a negative error
+ * code.
+ */
+static int
+ndr_xa_read(ndr_client_t *clnt, ndr_xa_t *mxa)
+{
+	ndr_stream_t *nds = &mxa->recv_nds;
+	int len;
+	int nbytes;
+
+	if ((len = (nds->pdu_max_size - nds->pdu_size)) < 0)
+		return (-1);
+
+	nbytes = smb_fh_read(clnt->xa_fd, 0, len,
+	    (char *)nds->pdu_base_offset + nds->pdu_size);
+
+	if (nbytes < 0)
+		return (-1);
+
+	nds->pdu_size += nbytes;
+
+	if (nds->pdu_size > nds->pdu_max_size) {
+		nds->pdu_size = nds->pdu_max_size;
+		return (-1);
+	}
+
+	return (nbytes);
+}
+
+/*
+ * Preserve the heap so that the client application has access to data
+ * returned from the server after an RPC call.
+ */
+static void
+ndr_xa_preserve(ndr_client_t *clnt, ndr_xa_t *mxa)
+{
+	assert(clnt->heap == mxa->heap);
+
+	clnt->heap_preserved = B_TRUE;
+	mxa->heap = NULL;
+}
+
+/*
+ * Dispose of the transaction streams.  If the heap has not been
+ * preserved, we can destroy it here.
+ */
+static void
+ndr_xa_destruct(ndr_client_t *clnt, ndr_xa_t *mxa)
+{
+	nds_destruct(&mxa->recv_nds);
+	nds_destruct(&mxa->send_nds);
+
+	if (!clnt->heap_preserved) {
+		ndr_heap_destroy(mxa->heap);
+		mxa->heap = NULL;
+		clnt->heap = NULL;
+	}
+}
+
+/*
+ * Dispose of a preserved heap.
+ */
+static void
+ndr_xa_release(ndr_client_t *clnt)
+{
+	if (clnt->heap_preserved) {
+		ndr_heap_destroy(clnt->heap);
+		clnt->heap = NULL;
+		clnt->heap_preserved = B_FALSE;
+	}
+}
diff --git a/usr/src/uts/common/smbsrv/ndr.h b/usr/src/lib/libmlrpc/common/ndr.h
similarity index 97%
rename from usr/src/uts/common/smbsrv/ndr.h
rename to usr/src/lib/libmlrpc/common/ndr.h
index 584c0798e4..f6af9a22cf 100644
--- a/usr/src/uts/common/smbsrv/ndr.h
+++ b/usr/src/lib/libmlrpc/common/ndr.h
@@ -40,18 +40,14 @@
  * ogspecs@opengroup.org
  */
 
-#if defined(_KERNEL) || defined(_FAKE_KERNEL)
-#error "not used in kernel code"
-#else /* _KERNEL */
 #include <sys/types.h>
 #include <sys/uio.h>
-#include <syslog.h>
 #include <stdlib.h>
 #include <string.h>
-#include <smbsrv/wintypes.h>
-#include <smbsrv/ndl/rpcpdu.ndl>
-#include <smbsrv/string.h>
-#endif	/* _KERNEL */
+
+#include <smb/wintypes.h>
+#include <libmlrpc/ndrtypes.ndl>
+#include <libmlrpc/rpcpdu.ndl>
 
 #ifdef __cplusplus
 extern "C" {
@@ -455,8 +451,7 @@ int ndr_inner_pointer(ndr_ref_t *);
 int ndr_inner_reference(ndr_ref_t *);
 int ndr_inner_array(ndr_ref_t *);
 
-size_t ndr_mbstowcs(struct ndr_stream *, smb_wchar_t *, const char *, size_t);
-int ndr_mbtowc(struct ndr_stream *, smb_wchar_t *, const char *, size_t);
+size_t ndr_mbstowcs(struct ndr_stream *, ndr_wchar_t *, const char *, size_t);
 
 void nds_bswap(void *src, void *dst, size_t len);
 
diff --git a/usr/src/lib/smbsrv/libmlrpc/common/ndr_client.c b/usr/src/lib/libmlrpc/common/ndr_client.c
similarity index 95%
rename from usr/src/lib/smbsrv/libmlrpc/common/ndr_client.c
rename to usr/src/lib/libmlrpc/common/ndr_client.c
index 7aaa35e6b5..56cc1847ef 100644
--- a/usr/src/lib/smbsrv/libmlrpc/common/ndr_client.c
+++ b/usr/src/lib/libmlrpc/common/ndr_client.c
@@ -21,14 +21,15 @@
 /*
  * Copyright 2010 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
+ *
+ * Copyright 2013 Nexenta Systems, Inc.  All rights reserved.
  */
 
 #include <sys/errno.h>
 #include <string.h>
 #include <strings.h>
 
-#include <smbsrv/libsmb.h>
-#include <smbsrv/libmlrpc.h>
+#include <libmlrpc.h>
 
 #define	NDR_DEFAULT_FRAGSZ	8192
 #define	NDR_MULTI_FRAGSZ	(60 * 1024)
@@ -38,24 +39,19 @@ static int ndr_clnt_get_frags(ndr_client_t *, ndr_xa_t *);
 static int ndr_clnt_get_frag(ndr_client_t *, ndr_xa_t *, ndr_common_header_t *);
 
 int
-ndr_clnt_bind(ndr_client_t *clnt, const char *service_name,
+ndr_clnt_bind(ndr_client_t *clnt, ndr_service_t *msvc,
     ndr_binding_t **ret_binding_p)
 {
-	ndr_service_t		*msvc;
 	ndr_binding_t		*mbind;
 	ndr_xa_t		mxa;
 	ndr_bind_hdr_t		*bhdr;
-	ndr_p_cont_elem_t 	*pce;
+	ndr_p_cont_elem_t	*pce;
 	ndr_bind_ack_hdr_t	*bahdr;
 	ndr_p_result_t		*pre;
 	int			rc;
 
 	bzero(&mxa, sizeof (mxa));
 
-	msvc = ndr_svc_lookup_name(service_name);
-	if (msvc == NULL)
-		return (NDR_DRC_FAULT_API_SERVICE_INVALID);
-
 	mxa.binding_list = clnt->binding_list;
 	if ((mbind = ndr_svc_new_binding(&mxa)) == NULL)
 		return (NDR_DRC_FAULT_API_BIND_NO_SLOTS);
@@ -140,16 +136,12 @@ int
 ndr_clnt_call(ndr_binding_t *mbind, int opnum, void *params)
 {
 	ndr_client_t		*clnt = mbind->clnt;
-	ndr_service_t		*msvc = mbind->service;
 	ndr_xa_t		mxa;
 	ndr_request_hdr_t	*reqhdr;
 	ndr_common_header_t	*rsphdr;
 	unsigned long		recv_pdu_scan_offset;
 	int			rc;
 
-	if (ndr_svc_lookup_name(msvc->name) == NULL)
-		return (NDR_DRC_FAULT_API_SERVICE_INVALID);
-
 	bzero(&mxa, sizeof (mxa));
 	mxa.ptype = NDR_PTYPE_REQUEST;
 	mxa.opnum = opnum;
diff --git a/usr/src/lib/smbsrv/libmlrpc/common/ndr_heap.c b/usr/src/lib/libmlrpc/common/ndr_heap.c
similarity index 84%
rename from usr/src/lib/smbsrv/libmlrpc/common/ndr_heap.c
rename to usr/src/lib/libmlrpc/common/ndr_heap.c
index 73a453b00e..5ec8a5aa77 100644
--- a/usr/src/lib/smbsrv/libmlrpc/common/ndr_heap.c
+++ b/usr/src/lib/libmlrpc/common/ndr_heap.c
@@ -21,6 +21,8 @@
 /*
  * Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
+ *
+ * Copyright 2013 Nexenta Systems, Inc.  All rights reserved.
  */
 
 /*
@@ -46,9 +48,8 @@
 #include <strings.h>
 #include <sys/uio.h>
 
-#include <smbsrv/libsmb.h>
-#include <smbsrv/libmlrpc.h>
-#include <smbsrv/smb_sid.h>
+#include <libmlrpc.h>
+#include <ndr_wchar.h>
 
 /*
  * Allocate a heap structure and the first heap block.  For many RPC
@@ -153,6 +154,23 @@ ndr_heap_malloc(ndr_heap_t *heap, unsigned size)
 	return ((void *)p);
 }
 
+/*
+ * Convenience function to copy some memory into the heap.
+ */
+void *
+ndr_heap_dupmem(ndr_heap_t *heap, const void *mem, size_t len)
+{
+	void *p;
+
+	if (mem == NULL)
+		return (NULL);
+
+	if ((p = ndr_heap_malloc(heap, len)) != NULL)
+		(void) memcpy(p, mem, len);
+
+	return (p);
+}
+
 /*
  * Convenience function to do heap strdup.
  */
@@ -171,8 +189,7 @@ ndr_heap_strdup(ndr_heap_t *heap, const char *s)
 	if ((len = strlen(s)) == 0)
 		return ("");
 
-	if ((p = ndr_heap_malloc(heap, len+1)) != NULL)
-		(void) strcpy((char *)p, s);
+	p = ndr_heap_dupmem(heap, s, len+1);
 
 	return (p);
 }
@@ -183,11 +200,21 @@ ndr_heap_strdup(ndr_heap_t *heap, const char *s)
 int
 ndr_heap_mstring(ndr_heap_t *heap, const char *s, ndr_mstring_t *out)
 {
+	size_t slen;
+
 	if (s == NULL || out == NULL)
 		return (-1);
 
-	out->length = smb_wcequiv_strlen(s);
-	out->allosize = out->length + sizeof (smb_wchar_t);
+	/*
+	 * Determine the WC strlen of s
+	 * Was ndr__wcequiv_strlen(s)
+	 */
+	slen = ndr__mbstowcs(NULL, s, NDR_STRING_MAX);
+	if (slen == (size_t)-1)
+		return (-1);
+
+	out->length = slen * sizeof (ndr_wchar_t);
+	out->allosize = out->length + sizeof (ndr_wchar_t);
 
 	if ((out->str = ndr_heap_strdup(heap, s)) == NULL)
 		return (-1);
@@ -207,20 +234,31 @@ ndr_heap_mstring(ndr_heap_t *heap, const char *s, ndr_mstring_t *out)
 void
 ndr_heap_mkvcs(ndr_heap_t *heap, char *s, ndr_vcstr_t *vc)
 {
+	size_t slen;
 	int mlen;
 
-	vc->wclen = smb_wcequiv_strlen(s);
-	vc->wcsize = vc->wclen;
+	/*
+	 * Determine the WC strlen of s
+	 * Was ndr__wcequiv_strlen(s)
+	 */
+	slen = ndr__mbstowcs(NULL, s, NDR_STRING_MAX);
+	if (slen == (size_t)-1)
+		slen = 0;
 
-	mlen = sizeof (ndr_vcs_t) + vc->wcsize + sizeof (smb_wchar_t);
+	vc->wclen = slen * sizeof (ndr_wchar_t);
+	vc->wcsize = vc->wclen;
 
+	/*
+	 * alloc one extra wchar for a null
+	 * See slen + 1 arg for mbstowcs
+	 */
+	mlen = sizeof (ndr_vcs_t) + vc->wcsize + sizeof (ndr_wchar_t);
 	vc->vcs = ndr_heap_malloc(heap, mlen);
 
 	if (vc->vcs) {
 		vc->vcs->vc_first_is = 0;
-		vc->vcs->vc_length_is = vc->wclen / sizeof (smb_wchar_t);
-		(void) smb_mbstowcs((smb_wchar_t *)vc->vcs->buffer, s,
-		    vc->vcs->vc_length_is);
+		vc->vcs->vc_length_is = slen;
+		(void) ndr__mbstowcs(vc->vcs->buffer, s, slen + 1);
 	}
 }
 
@@ -250,25 +288,8 @@ ndr_heap_mkvcb(ndr_heap_t *heap, uint8_t *data, uint32_t datalen,
 }
 
 /*
- * Duplcate a SID in the heap.
+ * Removed ndr_heap_siddup(), now using ndr_heap_dupmem().
  */
-smb_sid_t *
-ndr_heap_siddup(ndr_heap_t *heap, smb_sid_t *sid)
-{
-	smb_sid_t *new_sid;
-	unsigned size;
-
-	if (sid == NULL)
-		return (NULL);
-
-	size = smb_sid_len(sid);
-
-	if ((new_sid = ndr_heap_malloc(heap, size)) == NULL)
-		return (NULL);
-
-	bcopy(sid, new_sid, size);
-	return (new_sid);
-}
 
 int
 ndr_heap_used(ndr_heap_t *heap)
diff --git a/usr/src/lib/smbsrv/libmlrpc/common/ndr_marshal.c b/usr/src/lib/libmlrpc/common/ndr_marshal.c
similarity index 99%
rename from usr/src/lib/smbsrv/libmlrpc/common/ndr_marshal.c
rename to usr/src/lib/libmlrpc/common/ndr_marshal.c
index a690dfb2e9..4d34030d2a 100644
--- a/usr/src/lib/smbsrv/libmlrpc/common/ndr_marshal.c
+++ b/usr/src/lib/libmlrpc/common/ndr_marshal.c
@@ -20,14 +20,14 @@
  */
 /*
  * Copyright (c) 2007, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright 2013 Nexenta Systems, Inc.  All rights reserved.
  */
 
 #include <assert.h>
 #include <strings.h>
 #include <sys/param.h>
 
-#include <smbsrv/libsmb.h>
-#include <smbsrv/libmlrpc.h>
+#include <libmlrpc.h>
 
 #ifdef _BIG_ENDIAN
 static const int ndr_native_byte_order = NDR_REPLAB_INTG_BIG_ENDIAN;
diff --git a/usr/src/lib/smbsrv/libmlrpc/common/ndr_ops.c b/usr/src/lib/libmlrpc/common/ndr_ops.c
similarity index 99%
rename from usr/src/lib/smbsrv/libmlrpc/common/ndr_ops.c
rename to usr/src/lib/libmlrpc/common/ndr_ops.c
index 0cbcdc6e90..4ca1cb6295 100644
--- a/usr/src/lib/smbsrv/libmlrpc/common/ndr_ops.c
+++ b/usr/src/lib/libmlrpc/common/ndr_ops.c
@@ -49,8 +49,7 @@
 #include <string.h>
 #include <assert.h>
 
-#include <smbsrv/libsmb.h>
-#include <smbsrv/libmlrpc.h>
+#include <libmlrpc.h>
 
 #define	NDOBUFSZ		128
 
diff --git a/usr/src/lib/smbsrv/libmlrpc/common/ndr_process.c b/usr/src/lib/libmlrpc/common/ndr_process.c
similarity index 94%
rename from usr/src/lib/smbsrv/libmlrpc/common/ndr_process.c
rename to usr/src/lib/libmlrpc/common/ndr_process.c
index 945b02e699..3188500a8b 100644
--- a/usr/src/lib/smbsrv/libmlrpc/common/ndr_process.c
+++ b/usr/src/lib/libmlrpc/common/ndr_process.c
@@ -22,6 +22,7 @@
  * Copyright 2010 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
  * Copyright 2012 Milan Jurik. All rights reserved.
+ * Copyright 2013 Nexenta Systems, Inc.  All rights reserved.
  */
 
 /*
@@ -34,13 +35,11 @@
 #include <strings.h>
 #include <assert.h>
 #include <string.h>
+#include <stdio.h>
 #include <stdlib.h>
 
-#include <smbsrv/libsmb.h>
-#include <smbsrv/string.h>
-#include <smbsrv/libmlrpc.h>
-
-#define	NDR_STRING_MAX		4096
+#include <libmlrpc.h>
+#include <ndr_wchar.h>
 
 #define	NDR_IS_UNION(T)	\
 	(((T)->type_flags & NDR_F_TYPEOP_MASK) == NDR_F_UNION)
@@ -1210,17 +1209,22 @@ ndr_outer_string(ndr_ref_t *outer_ref)
 			/*
 			 * size_is is the number of characters in the
 			 * (multibyte) string, including the null.
+			 * In other words, symbols, not bytes.
 			 */
-			size_is = smb_wcequiv_strlen(valp) /
-			    sizeof (smb_wchar_t);
-
-			if (!(nds->flags & NDS_F_NONULL))
-				++size_is;
-
-			if (size_is > NDR_STRING_MAX) {
+			size_t wlen;
+			wlen = ndr__mbstowcs(NULL, valp, NDR_STRING_MAX);
+			if (wlen == (size_t)-1) {
+				/* illegal sequence error? */
 				NDR_SET_ERROR(outer_ref, NDR_ERR_STRLEN);
 				return (0);
 			}
+			if ((nds->flags & NDS_F_NONULL) == 0)
+				wlen++;
+			if (wlen > NDR_STRING_MAX) {
+				NDR_SET_ERROR(outer_ref, NDR_ERR_STRLEN);
+				return (0);
+			}
+			size_is = wlen;
 		} else {
 			valp = outer_ref->datum;
 			n_zeroes = 0;
@@ -1288,7 +1292,7 @@ ndr_outer_string(ndr_ref_t *outer_ref)
 			 * be nice to use mbequiv_strlen but the string
 			 * may not be null terminated.
 			 */
-			n_alloc = (size_is + 1) * MTS_MB_CHAR_MAX;
+			n_alloc = (size_is + 1) * NDR_MB_CHAR_MAX;
 		} else {
 			n_alloc = (size_is + 1) * is_varlen;
 		}
@@ -1741,7 +1745,7 @@ ndr_inner_array(ndr_ref_t *encl_ref)
 	myref.inner_flags = NDR_F_NONE;
 
 	for (i = 0; i < n_elem; i++) {
-		(void) sprintf(name, "[%lu]", i);
+		(void) snprintf(name, sizeof (name), "[%lu]", i);
 		myref.name = name;
 		myref.pdu_offset = pdu_offset + i * ti->pdu_size_fixed_part;
 		myref.datum = encl_ref->datum + i * ti->c_size_fixed_part;
@@ -1796,20 +1800,20 @@ ndr_inner_array(ndr_ref_t *encl_ref)
 int ndr_basic_integer(ndr_ref_t *, unsigned);
 int ndr_string_basic_integer(ndr_ref_t *, ndr_typeinfo_t *);
 
+/* Comments to be nice to those searching for these types. */
+MAKE_BASIC_TYPE(_char, 1)	/* ndt__char,  ndt_s_char */
+MAKE_BASIC_TYPE(_uchar, 1)	/* ndt__uchar, ndt_s_uchar */
+MAKE_BASIC_TYPE(_short, 2)	/* ndt__short, ndt_s_short */
+MAKE_BASIC_TYPE(_ushort, 2)	/* ndt__ushort, ndt_s_ushort */
+MAKE_BASIC_TYPE(_long, 4)	/* ndt__long,  ndt_s_long */
+MAKE_BASIC_TYPE(_ulong, 4)	/* ndt__ulong, ndt_s_ulong */
 
-MAKE_BASIC_TYPE(_char, 1)
-MAKE_BASIC_TYPE(_uchar, 1)
-MAKE_BASIC_TYPE(_short, 2)
-MAKE_BASIC_TYPE(_ushort, 2)
-MAKE_BASIC_TYPE(_long, 4)
-MAKE_BASIC_TYPE(_ulong, 4)
-
-MAKE_BASIC_TYPE_BASE(_wchar, 2)
+MAKE_BASIC_TYPE_BASE(_wchar, 2)	/* ndt__wchar, ndt_s_wchar */
 
 int
 ndr_basic_integer(ndr_ref_t *ref, unsigned size)
 {
-	ndr_stream_t 	*nds = ref->stream;
+	ndr_stream_t	*nds = ref->stream;
 	char 		*valp = (char *)ref->datum;
 	int		rc;
 
@@ -1854,7 +1858,7 @@ ndr_string_basic_integer(ndr_ref_t *encl_ref, ndr_typeinfo_t *type_under)
 	myref.name = name;
 
 	for (i = 0; i < NDR_STRING_MAX; i++) {
-		(void) sprintf(name, "[%lu]", i);
+		(void) snprintf(name, sizeof (name), "[%lu]", i);
 		myref.pdu_offset = pdu_offset + i * size;
 		valp = encl_ref->datum + i * size;
 		myref.datum = valp;
@@ -1897,27 +1901,27 @@ ndr_typeinfo_t ndt_s_wchar = {
  * multi-byte to wide characters. During NDR_M_OP_UNMARSHALL, we
  * convert from wide characters to multi-byte.
  *
- * It appeared that NT would sometimes leave a spurious character
- * in the data stream before the null wide_char, which would get
- * included in the string decode because we processed until the
- * null character. It now looks like NT does not always terminate
- * RPC Unicode strings and the terminating null is a side effect
- * of field alignment. So now we rely on the strlen_is (set up in
- * ndr_outer_string) of the enclosing reference. This may or may
- * not include the null but it doesn't matter, the algorithm will
- * get it right.
+ * The most critical thing to get right in this function is to
+ * marshall or unmarshall _exactly_ the number of elements the
+ * OtW length specifies, as saved by the caller in: strlen_is.
+ * Doing otherwise would leave us positioned at the wrong place
+ * in the data stream for whatever follows this.  Note that the
+ * string data covered by strlen_is may or may not include any
+ * null termination, but the converted string provided by the
+ * caller or returned always has a null terminator.
  */
 int
 ndr_s_wchar(ndr_ref_t *encl_ref)
 {
 	ndr_stream_t		*nds = encl_ref->stream;
-	unsigned short		wide_char;
-	char 			*valp;
+	char			*valp = encl_ref->datum;
 	ndr_ref_t		myref;
-	unsigned long		i;
 	char			name[30];
-	int			count;
-	int			char_count = 0;
+	ndr_wchar_t		wcs[NDR_STRING_MAX+1];
+	size_t			i, slen, wlen;
+
+	/* This is enforced in ndr_outer_string() */
+	assert(encl_ref->strlen_is <= NDR_STRING_MAX);
 
 	if (nds->m_op == NDR_M_OP_UNMARSHALL) {
 		/*
@@ -1930,59 +1934,60 @@ ndr_s_wchar(ndr_ref_t *encl_ref)
 		}
 	}
 
+	/*
+	 * If we're marshalling, convert the given string
+	 * from UTF-8 into a local UCS-2 string.
+	 */
+	if (nds->m_op == NDR_M_OP_MARSHALL) {
+		wlen = ndr__mbstowcs(wcs, valp, NDR_STRING_MAX);
+		if (wlen == (size_t)-1)
+			return (0);
+		/*
+		 * Add a nulls to make strlen_is.
+		 * (always zero or one of them)
+		 * Then null terminate at wlen,
+		 * just for debug convenience.
+		 */
+		while (wlen < encl_ref->strlen_is)
+			wcs[wlen++] = 0;
+		wcs[wlen] = 0;
+	}
+
+	/*
+	 * Copy wire data to or from the local wc string.
+	 * Always exactly strlen_is elements.
+	 */
 	bzero(&myref, sizeof (myref));
 	myref.enclosing = encl_ref;
 	myref.stream = encl_ref->stream;
 	myref.packed_alignment = 0;
 	myref.ti = &ndt__wchar;
 	myref.inner_flags = NDR_F_NONE;
-	myref.datum = (char *)&wide_char;
 	myref.name = name;
 	myref.pdu_offset = encl_ref->pdu_offset;
+	myref.datum = (char *)wcs;
+	wlen = encl_ref->strlen_is;
 
-	valp = encl_ref->datum;
-	count = 0;
-
-	for (i = 0; i < NDR_STRING_MAX; i++) {
-		(void) sprintf(name, "[%lu]", i);
-
-		if (nds->m_op == NDR_M_OP_MARSHALL) {
-			count = smb_mbtowc((smb_wchar_t *)&wide_char, valp,
-			    MTS_MB_CHAR_MAX);
-			if (count < 0) {
-				return (0);
-			} else if (count == 0) {
-				if (encl_ref->strlen_is != encl_ref->size_is)
-					break;
-
-				/*
-				 * If the input char is 0, mbtowc
-				 * returns 0 without setting wide_char.
-				 * Set wide_char to 0 and a count of 1.
-				 */
-				wide_char = *valp;
-				count = 1;
-			}
-		}
-
+	for (i = 0; i < wlen; i++) {
+		(void) snprintf(name, sizeof (name), "[%lu]", i);
 		if (!ndr_inner(&myref))
 			return (0);
+		myref.pdu_offset += sizeof (ndr_wchar_t);
+		myref.datum	 += sizeof (ndr_wchar_t);
+	}
 
-		if (nds->m_op == NDR_M_OP_UNMARSHALL) {
-			count = smb_wctomb(valp, wide_char);
-
-			if ((++char_count) == encl_ref->strlen_is) {
-				valp += count;
-				*valp = '\0';
-				break;
-			}
-		}
-
-		if (!wide_char)
-			break;
-
-		myref.pdu_offset += sizeof (wide_char);
-		valp += count;
+	/*
+	 * If this is unmarshall, convert the local UCS-2 string
+	 * into a UTF-8 string in the caller's buffer.  The caller
+	 * previously determined the space required and provides a
+	 * buffer of sufficient size.
+	 */
+	if (nds->m_op == NDR_M_OP_UNMARSHALL) {
+		wcs[wlen] = 0;
+		slen = ndr__wcstombs(valp, wcs, wlen);
+		if (slen == (size_t)-1)
+			return (0);
+		valp[slen] = '\0';
 	}
 
 	return (1);
@@ -1997,51 +2002,20 @@ ndr_s_wchar(ndr_ref_t *encl_ref)
  * any terminating null wide character.  Returns -1 if an invalid
  * multibyte character is encountered.
  */
+/* ARGSUSED */
 size_t
-ndr_mbstowcs(ndr_stream_t *nds, smb_wchar_t *wcs, const char *mbs,
+ndr_mbstowcs(ndr_stream_t *nds, ndr_wchar_t *wcs, const char *mbs,
     size_t nwchars)
 {
-	smb_wchar_t *start = wcs;
-	int nbytes;
-
-	while (nwchars--) {
-		nbytes = ndr_mbtowc(nds, wcs, mbs, MTS_MB_CHAR_MAX);
-		if (nbytes < 0) {
-			*wcs = 0;
-			return ((size_t)-1);
-		}
-
-		if (*mbs == 0)
-			break;
-
-		++wcs;
-		mbs += nbytes;
-	}
-
-	return (wcs - start);
-}
-
-/*
- * Converts a multibyte character to a little-endian, wide-char, which
- * is stored in wcharp.  Up to nbytes bytes are examined.
- *
- * If mbchar is valid, returns the number of bytes processed in mbchar.
- * If mbchar is invalid, returns -1.  See also smb_mbtowc().
- */
-/*ARGSUSED*/
-int
-ndr_mbtowc(ndr_stream_t *nds, smb_wchar_t *wcharp, const char *mbchar,
-    size_t nbytes)
-{
-	int rc;
-
-	if ((rc = smb_mbtowc(wcharp, mbchar, nbytes)) < 0)
-		return (rc);
+	size_t len;
 
 #ifdef _BIG_ENDIAN
-	if (nds == NULL || NDR_MODE_MATCH(nds, NDR_MODE_RETURN_SEND))
-		*wcharp = BSWAP_16(*wcharp);
+	if (nds == NULL || NDR_MODE_MATCH(nds, NDR_MODE_RETURN_SEND)) {
+		/* Make WC string in LE order. */
+		len = ndr__mbstowcs_le(wcs, mbs, nwchars);
+	} else
 #endif
+		len = ndr__mbstowcs(wcs, mbs, nwchars);
 
-	return (rc);
+	return (len);
 }
diff --git a/usr/src/lib/smbsrv/libmlrpc/common/ndr_server.c b/usr/src/lib/libmlrpc/common/ndr_server.c
similarity index 95%
rename from usr/src/lib/smbsrv/libmlrpc/common/ndr_server.c
rename to usr/src/lib/libmlrpc/common/ndr_server.c
index 198daa7d55..4a1e2c177a 100644
--- a/usr/src/lib/smbsrv/libmlrpc/common/ndr_server.c
+++ b/usr/src/lib/libmlrpc/common/ndr_server.c
@@ -36,9 +36,7 @@
 #include <string.h>
 #include <thread.h>
 
-#include <smbsrv/libsmb.h>
-#include <smbsrv/libmlrpc.h>
-#include <smbsrv/ntaccess.h>
+#include <libmlrpc.h>
 
 #define	NDR_PIPE_SEND(np, buf, len) \
 	((np)->np_send)((np), (buf), (len))
@@ -131,42 +129,6 @@ out1:
 	return (rc);
 }
 
-/*
- * Check whether or not the specified user has administrator privileges,
- * i.e. is a member of Domain Admins or Administrators.
- * Returns true if the user is an administrator, otherwise returns false.
- */
-boolean_t
-ndr_is_admin(ndr_xa_t *xa)
-{
-	smb_netuserinfo_t *ctx = xa->pipe->np_user;
-
-	return (ctx->ui_flags & SMB_ATF_ADMIN);
-}
-
-/*
- * Check whether or not the specified user has power-user privileges,
- * i.e. is a member of Domain Admins, Administrators or Power Users.
- * This is typically required for operations such as managing shares.
- * Returns true if the user is a power user, otherwise returns false.
- */
-boolean_t
-ndr_is_poweruser(ndr_xa_t *xa)
-{
-	smb_netuserinfo_t *ctx = xa->pipe->np_user;
-
-	return ((ctx->ui_flags & SMB_ATF_ADMIN) ||
-	    (ctx->ui_flags & SMB_ATF_POWERUSER));
-}
-
-int32_t
-ndr_native_os(ndr_xa_t *xa)
-{
-	smb_netuserinfo_t *ctx = xa->pipe->np_user;
-
-	return (ctx->ui_native_os);
-}
-
 /*
  * Receive an entire RPC request (all fragments)
  * Returns zero or an NDR fault code.
diff --git a/usr/src/lib/smbsrv/libmlrpc/common/ndr_svc.c b/usr/src/lib/libmlrpc/common/ndr_svc.c
similarity index 99%
rename from usr/src/lib/smbsrv/libmlrpc/common/ndr_svc.c
rename to usr/src/lib/libmlrpc/common/ndr_svc.c
index d5c5f95f01..1e000a27f1 100644
--- a/usr/src/lib/smbsrv/libmlrpc/common/ndr_svc.c
+++ b/usr/src/lib/libmlrpc/common/ndr_svc.c
@@ -34,8 +34,7 @@
 #include <strings.h>
 #include <assert.h>
 
-#include <smbsrv/libsmb.h>
-#include <smbsrv/libmlrpc.h>
+#include <libmlrpc.h>
 
 
 /*
diff --git a/usr/src/lib/libmlrpc/common/ndr_wchar.c b/usr/src/lib/libmlrpc/common/ndr_wchar.c
new file mode 100644
index 0000000000..81886f3250
--- /dev/null
+++ b/usr/src/lib/libmlrpc/common/ndr_wchar.c
@@ -0,0 +1,162 @@
+/*
+ * CDDL HEADER START
+ *
+ * The contents of this file are subject to the terms of the
+ * Common Development and Distribution License (the "License").
+ * You may not use this file except in compliance with the License.
+ *
+ * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
+ * or http://www.opensolaris.org/os/licensing.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * When distributing Covered Code, include this CDDL HEADER in each
+ * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
+ * If applicable, add the following below this CDDL HEADER, with the
+ * fields enclosed by brackets "[]" replaced with your own identifying
+ * information: Portions Copyright [yyyy] [name of copyright owner]
+ *
+ * CDDL HEADER END
+ */
+
+/*
+ * Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
+ * Use is subject to license terms.
+ *
+ * Copyright 2013 Nexenta Systems, Inc.  All rights reserved.
+ */
+
+/*
+ * Some wchar support functions used by this library.
+ * Mostlly just wrappers that call sys/u8_textprep.h
+ * functions: uconv_u8tou16, uconv_u16tou8.
+ */
+
+#include <sys/types.h>
+#include <sys/u8_textprep.h>
+#include <string.h>
+
+#include "ndr_wchar.h"
+
+/*
+ * When we just want lengths, we need an output buffer to pass to the
+ * uconv_... functions.  Nothing ever reads this output, so we can
+ * use shared space for the unwanted output.
+ */
+static uint16_t junk_wcs[NDR_STRING_MAX];
+static char junk_mbs[NDR_MB_CUR_MAX * NDR_STRING_MAX];
+
+static size_t
+ndr__mbstowcs_x(uint16_t *, const char *, size_t, int);
+
+/*
+ * Like mbstowcs(3C), but with UCS-2 wchar_t
+ */
+size_t
+ndr__mbstowcs(uint16_t *wcs, const char *mbs, size_t nwchars)
+{
+	return (ndr__mbstowcs_x(wcs, mbs, nwchars,
+	    UCONV_OUT_SYSTEM_ENDIAN));
+}
+
+/*
+ * Like above, but put UCS-2 little-endian.
+ */
+size_t
+ndr__mbstowcs_le(uint16_t *wcs, const char *mbs, size_t nwchars)
+{
+	return (ndr__mbstowcs_x(wcs, mbs, nwchars,
+	    UCONV_OUT_LITTLE_ENDIAN));
+}
+
+/*
+ * Like mbstowcs(3C), but with UCS-2 wchar_t, and
+ * one extra arg for the byte order flags.
+ */
+static size_t
+ndr__mbstowcs_x(uint16_t *wcs, const char *mbs, size_t nwchars, int flags)
+{
+	size_t obytes, mbslen, wcslen;
+	int err;
+
+	/* NULL or empty input is allowed. */
+	if (mbs == NULL || *mbs == '\0') {
+		if (wcs != NULL && nwchars > 0)
+			*wcs = 0;
+		return (0);
+	}
+
+	/*
+	 * If wcs == NULL, caller just wants the length.
+	 * Convert into some throw-away space.
+	 */
+	obytes = nwchars * 2;
+	if (wcs == NULL) {
+		if (obytes > sizeof (junk_wcs))
+			return ((size_t)-1);
+		wcs = junk_wcs;
+	}
+
+	mbslen = strlen(mbs);
+	wcslen = nwchars;
+	err = uconv_u8tou16((const uchar_t *)mbs, &mbslen,
+	    wcs, &wcslen, flags);
+	if (err != 0)
+		return ((size_t)-1);
+
+	if (wcslen < nwchars)
+		wcs[wcslen] = 0;
+
+	return (wcslen);
+}
+
+/*
+ * Like wcstombs(3C), but with UCS-2 wchar_t.
+ */
+size_t
+ndr__wcstombs(char *mbs, const uint16_t *wcs, size_t nbytes)
+{
+	size_t mbslen, wcslen;
+	int err;
+
+	/* NULL or empty input is allowed. */
+	if (wcs == NULL || *wcs == 0) {
+		if (mbs != NULL && nbytes > 0)
+			*mbs = '\0';
+		return (0);
+	}
+
+	/*
+	 * If mbs == NULL, caller just wants the length.
+	 * Convert into some throw-away space.
+	 */
+	if (mbs == NULL) {
+		if (nbytes > sizeof (junk_mbs))
+			return ((size_t)-1);
+		mbs = junk_mbs;
+	}
+
+	wcslen = ndr__wcslen(wcs);
+	mbslen = nbytes;
+	err = uconv_u16tou8(wcs, &wcslen,
+	    (uchar_t *)mbs, &mbslen, UCONV_IN_SYSTEM_ENDIAN);
+	if (err != 0)
+		return ((size_t)-1);
+
+	if (mbslen < nbytes)
+		mbs[mbslen] = '\0';
+
+	return (mbslen);
+}
+
+/*
+ * Like wcslen(3C), but with UCS-2 wchar_t.
+ */
+size_t
+ndr__wcslen(const uint16_t *wc)
+{
+	size_t len = 0;
+	while (*wc++)
+		len++;
+	return (len);
+}
diff --git a/usr/src/lib/libmlrpc/common/ndr_wchar.h b/usr/src/lib/libmlrpc/common/ndr_wchar.h
new file mode 100644
index 0000000000..e5fe8a1054
--- /dev/null
+++ b/usr/src/lib/libmlrpc/common/ndr_wchar.h
@@ -0,0 +1,46 @@
+/*
+ * CDDL HEADER START
+ *
+ * The contents of this file are subject to the terms of the
+ * Common Development and Distribution License (the "License").
+ * You may not use this file except in compliance with the License.
+ *
+ * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
+ * or http://www.opensolaris.org/os/licensing.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * When distributing Covered Code, include this CDDL HEADER in each
+ * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
+ * If applicable, add the following below this CDDL HEADER, with the
+ * fields enclosed by brackets "[]" replaced with your own identifying
+ * information: Portions Copyright [yyyy] [name of copyright owner]
+ *
+ * CDDL HEADER END
+ */
+
+/*
+ * Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
+ * Use is subject to license terms.
+ *
+ * Copyright 2013 Nexenta Systems, Inc.  All rights reserved.
+ */
+
+#ifndef _NDR_WCHAR_H
+#define	_NDR_WCHAR_H
+
+/*
+ * Some ndr_wchar_t support stuff.
+ */
+
+#define	NDR_MB_CUR_MAX		3
+#define	NDR_MB_CHAR_MAX		NDR_MB_CUR_MAX
+#define	NDR_STRING_MAX		4096
+
+size_t ndr__mbstowcs(uint16_t *, const char *, size_t);
+size_t ndr__mbstowcs_le(uint16_t *, const char *, size_t);
+
+size_t ndr__wcslen(const uint16_t *);
+size_t ndr__wcstombs(char *, const uint16_t *, size_t);
+
+#endif /* _NDR_WCHAR_H */
diff --git a/usr/src/uts/common/smbsrv/ndl/ndrtypes.ndl b/usr/src/lib/libmlrpc/common/ndrtypes.ndl
similarity index 93%
rename from usr/src/uts/common/smbsrv/ndl/ndrtypes.ndl
rename to usr/src/lib/libmlrpc/common/ndrtypes.ndl
index 16bb4b8135..b7d5fdb716 100644
--- a/usr/src/uts/common/smbsrv/ndl/ndrtypes.ndl
+++ b/usr/src/lib/libmlrpc/common/ndrtypes.ndl
@@ -21,10 +21,17 @@
 /*
  * Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
+ *
+ * Copyright 2013 Nexenta Systems, Inc.  All rights reserved.
  */
 
-#ifndef _NDR_TYPES_NDL_
-#define _NDR_TYPES_NDL_
+#ifndef _NDRTYPES_NDL_
+#define _NDRTYPES_NDL_
+
+/*
+ * Type definitions (and related) used in NDL files and the
+ * NDL run-time support libraries.  See also: libmlrpc.h
+ */
 
 #define TYPEINFO(TYPE)  ndt__##TYPE
 
@@ -69,20 +76,6 @@
 #define LPWORD  ushort *
 #define LPDWORD ulong *
 
-/*
- * Opaque context handle.
- */
-#ifndef CONTEXT_HANDLE
-#define CONTEXT_HANDLE(NAME)	\
-	struct NAME {		\
-		DWORD data1;    \
-		DWORD data2;    \
-		WORD  data3[2]; \
-		BYTE  data4[8];	\
-	};			\
-	typedef struct NAME
-#endif /* CONTEXT_HANDLE */
-
 #define EXTERNTYPEINFO(TYPE)
 
 #else /* NDRGEN */
@@ -116,7 +109,7 @@
 /*
  * When not using ndrgen, get BYTE, WORD, DWORD definitions from wintypes.h.
  */
-#include <smbsrv/wintypes.h>
+#include <smb/wintypes.h>
 
 #define EXTERNTYPEINFO(TYPE)	extern struct ndr_typeinfo TYPEINFO(TYPE);
 
@@ -167,4 +160,18 @@
 #define UNION_INFO_ENT(N,NAME) CASE(N) struct NAME##N info##N
 #define UNION_INFO_PTR(N,NAME) CASE(N) struct NAME##N *info##N
 
-#endif /* _NDR_TYPES_NDL_ */
+/*
+ * Opaque context handle.
+ */
+#ifndef CONTEXT_HANDLE
+#define CONTEXT_HANDLE(NAME)	\
+	struct NAME {		\
+		DWORD data1;    \
+		DWORD data2;    \
+		WORD  data3[2]; \
+		BYTE  data4[8];	\
+	};			\
+	typedef struct NAME
+#endif /* CONTEXT_HANDLE */
+
+#endif /* _NDRTYPES_NDL_ */
diff --git a/usr/src/uts/common/smbsrv/ndl/rpcpdu.ndl b/usr/src/lib/libmlrpc/common/rpcpdu.ndl
similarity index 100%
rename from usr/src/uts/common/smbsrv/ndl/rpcpdu.ndl
rename to usr/src/lib/libmlrpc/common/rpcpdu.ndl
diff --git a/usr/src/lib/smbsrv/libmlrpc/sparc/Makefile b/usr/src/lib/libmlrpc/i386/Makefile
similarity index 94%
rename from usr/src/lib/smbsrv/libmlrpc/sparc/Makefile
rename to usr/src/lib/libmlrpc/i386/Makefile
index 710c9eb3dd..6589e9941a 100644
--- a/usr/src/lib/smbsrv/libmlrpc/sparc/Makefile
+++ b/usr/src/lib/libmlrpc/i386/Makefile
@@ -22,11 +22,7 @@
 # Copyright 2007 Sun Microsystems, Inc.  All rights reserved.
 # Use is subject to license terms.
 #
-# ident	"%Z%%M%	%I%	%E% SMI"
-#
 
 include ../Makefile.com
 
-DYNFLAGS +=	-R/usr/lib/smbsrv
-
 install: all $(ROOTLIBS) $(ROOTLINKS) $(ROOTLINT)
diff --git a/usr/src/lib/smbsrv/libmlrpc/i386/Makefile b/usr/src/lib/libmlrpc/sparc/Makefile
similarity index 94%
rename from usr/src/lib/smbsrv/libmlrpc/i386/Makefile
rename to usr/src/lib/libmlrpc/sparc/Makefile
index 710c9eb3dd..6589e9941a 100644
--- a/usr/src/lib/smbsrv/libmlrpc/i386/Makefile
+++ b/usr/src/lib/libmlrpc/sparc/Makefile
@@ -22,11 +22,7 @@
 # Copyright 2007 Sun Microsystems, Inc.  All rights reserved.
 # Use is subject to license terms.
 #
-# ident	"%Z%%M%	%I%	%E% SMI"
-#
 
 include ../Makefile.com
 
-DYNFLAGS +=	-R/usr/lib/smbsrv
-
 install: all $(ROOTLIBS) $(ROOTLINKS) $(ROOTLINT)
diff --git a/usr/src/lib/smbsrv/libmlrpc/amd64/Makefile b/usr/src/lib/libmlrpc/sparcv9/Makefile
similarity index 90%
rename from usr/src/lib/smbsrv/libmlrpc/amd64/Makefile
rename to usr/src/lib/libmlrpc/sparcv9/Makefile
index b3c4916b0c..087f0e1107 100644
--- a/usr/src/lib/smbsrv/libmlrpc/amd64/Makefile
+++ b/usr/src/lib/libmlrpc/sparcv9/Makefile
@@ -22,14 +22,10 @@
 # Copyright 2007 Sun Microsystems, Inc.  All rights reserved.
 # Use is subject to license terms.
 #
-# ident	"%Z%%M%	%I%	%E% SMI"
-#
 
 MACH_LDLIBS +=	-L$(ROOT)/usr/lib/smbsrv/$(MACH64)
 
 include ../Makefile.com
-include ../../../Makefile.lib.64
-
-DYNFLAGS +=	-R/usr/lib/smbsrv/$(MACH64)
+include ../../Makefile.lib.64
 
 install: all $(ROOTLIBS64) $(ROOTLINKS64) $(ROOTLINT64)
diff --git a/usr/src/lib/libmvec/common/__vcos.c b/usr/src/lib/libmvec/common/__vcos.c
index cf2b5fee55..8d27b1bcf7 100644
--- a/usr/src/lib/libmvec/common/__vcos.c
+++ b/usr/src/lib/libmvec/common/__vcos.c
@@ -110,6 +110,7 @@ __vcos(int n, double * restrict x, int stridex, double * restrict y,
 	sysave = stridey;
 	biguns = 0;
 
+	x0 = *x;	/* 'x0' may be used uninitialized */
 	do /* MAIN LOOP */
 	{
 		/* Gotos here so _break_ exits MAIN LOOP. */
diff --git a/usr/src/lib/libmvec/common/__vsin.c b/usr/src/lib/libmvec/common/__vsin.c
index 04e3c0a4a6..f679b8089d 100644
--- a/usr/src/lib/libmvec/common/__vsin.c
+++ b/usr/src/lib/libmvec/common/__vsin.c
@@ -90,6 +90,7 @@ __vsin(int n, double * restrict x, int stridex, double * restrict y,
 	sysave = stridey;
 	biguns = 0;
 
+	x0 = *x;	/* error: 'x0' may be used uninitialized */
 	do
 	{
 LOOP0:
diff --git a/usr/src/lib/libppt/Makefile b/usr/src/lib/libppt/Makefile
new file mode 100644
index 0000000000..21c26d447e
--- /dev/null
+++ b/usr/src/lib/libppt/Makefile
@@ -0,0 +1,44 @@
+#
+# This file and its contents are supplied under the terms of the
+# Common Development and Distribution License ("CDDL"), version 1.0.
+# You may only use this file in accordance with the terms of version
+# 1.0 of the CDDL.
+#
+# A full copy of the text of the CDDL should have accompanied this
+# source.  A copy of the CDDL is also available via the Internet at
+# http://www.illumos.org/license/CDDL.
+#
+
+#
+# Copyright 2018 Joyent, Inc.
+#
+
+include $(SRC)/lib/Makefile.lib
+
+SUBDIRS = $(MACH) $(BUILD64) $(MACH64)
+
+HDRS = libppt.h
+HDRDIR = common
+
+all :=		TARGET= all
+clean :=	TARGET= clean
+clobber :=	TARGET= clobber
+install :=	TARGET= install
+lint :=		TARGET= lint
+
+.KEEP_STATE:
+
+all clean clobber install lint: $(SUBDIRS)
+
+install_h: $(ROOTHDRS)
+
+all install: install_h
+
+check: $(CHECKHDRS)
+
+$(SUBDIRS): FRC
+	@cd $@; pwd; $(MAKE) $(TARGET)
+
+FRC:
+
+include	$(SRC)/lib/Makefile.targ
diff --git a/usr/src/lib/libppt/Makefile.com b/usr/src/lib/libppt/Makefile.com
new file mode 100644
index 0000000000..7b2ff4885f
--- /dev/null
+++ b/usr/src/lib/libppt/Makefile.com
@@ -0,0 +1,46 @@
+#
+# This file and its contents are supplied under the terms of the
+# Common Development and Distribution License ("CDDL"), version 1.0.
+# You may only use this file in accordance with the terms of version
+# 1.0 of the CDDL.
+#
+# A full copy of the text of the CDDL should have accompanied this
+# source.  A copy of the CDDL is also available via the Internet at
+# http://www.illumos.org/license/CDDL.
+#
+
+#
+# Copyright 2018 Joyent, Inc.
+#
+
+LIBRARY = libppt.a
+VERS = .1
+
+OBJECTS = libppt.o
+
+include $(SRC)/lib/Makefile.lib
+
+SRCDIR = ../common
+
+LIBS = $(DYNLIB) $(LINTLIB)
+SRCS =	$(SRCDIR)/libppt.c
+
+CSTD=	$(CSTD_GNU99)
+C99LMODE=	-Xc99=%all
+
+#
+# lint doesn't like %4s in sscanf().
+#
+LINTFLAGS += -erroff=E_BAD_FORMAT_ARG_TYPE2
+LINTFLAGS64 += -erroff=E_BAD_FORMAT_ARG_TYPE2
+
+$(LINTLIB) := SRCS = $(SRCDIR)/$(LINTSRC)
+LDLIBS += -lpcidb -ldevinfo -lcmdutils -lnvpair -lc
+
+.KEEP_STATE:
+
+all: $(LIBS)
+
+lint: lintcheck
+
+include $(SRC)/lib/Makefile.targ
diff --git a/usr/src/lib/libppt/amd64/Makefile b/usr/src/lib/libppt/amd64/Makefile
new file mode 100644
index 0000000000..5a304d7fe7
--- /dev/null
+++ b/usr/src/lib/libppt/amd64/Makefile
@@ -0,0 +1,19 @@
+#
+# This file and its contents are supplied under the terms of the
+# Common Development and Distribution License ("CDDL"), version 1.0.
+# You may only use this file in accordance with the terms of version
+# 1.0 of the CDDL.
+#
+# A full copy of the text of the CDDL should have accompanied this
+# source.  A copy of the CDDL is also available via the Internet at
+# http://www.illumos.org/license/CDDL.
+#
+
+#
+# Copyright 2018 Joyent, Inc.
+#
+
+include		../Makefile.com
+include		$(SRC)/lib/Makefile.lib.64
+
+install:	all $(ROOTLIBS64) $(ROOTLINKS64)
diff --git a/usr/src/lib/libppt/common/libppt.c b/usr/src/lib/libppt/common/libppt.c
new file mode 100644
index 0000000000..ff721033ad
--- /dev/null
+++ b/usr/src/lib/libppt/common/libppt.c
@@ -0,0 +1,513 @@
+/*
+ * This file and its contents are supplied under the terms of the
+ * Common Development and Distribution License ("CDDL"), version 1.0.
+ * You may only use this file in accordance with the terms of version
+ * 1.0 of the CDDL.
+ *
+ * A full copy of the text of the CDDL should have accompanied this
+ * source.  A copy of the CDDL is also available via the Internet at
+ * http://www.illumos.org/license/CDDL.
+ *
+ *
+ * Copyright 2018 Joyent, Inc.
+ *
+ * Convenience routines for identifying current or available devices that are
+ * suitable for PCI passthrough to a bhyve guest.
+ */
+
+#include <libdevinfo.h>
+#include <libppt.h>
+
+#include <sys/param.h>
+#include <sys/stat.h>
+#include <sys/list.h>
+#include <strings.h>
+#include <stddef.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <errno.h>
+#include <pcidb.h>
+#include <glob.h>
+
+typedef struct node_data {
+	pcidb_hdl_t *nd_db;
+	list_t nd_matches;
+	nvlist_t *nd_nvl;
+	int nd_err;
+} node_data_t;
+
+typedef struct ppt_match {
+	list_node_t pm_list;
+	char pm_path[MAXPATHLEN];
+	char pm_vendor[5];
+	char pm_device[5];
+} ppt_match_t;
+
+static boolean_t
+is_pci(di_node_t di_node)
+{
+	char *svals;
+
+	if (di_prop_lookup_strings(DDI_DEV_T_ANY, di_parent_node(di_node),
+	    "device_type", &svals) != 1)
+		return (B_FALSE);
+
+	return (strcmp(svals, "pci") == 0 || strcmp(svals, "pciex") == 0);
+}
+
+static int
+get_int_prop(di_node_t di_node, nvlist_t *nvl, const char *name, int *ival)
+{
+	char val[20];
+	int *ivals;
+	int err;
+
+	if (di_prop_lookup_ints(DDI_DEV_T_ANY, di_node, name, &ivals) != 1)
+		return (errno);
+
+	(void) snprintf(val, sizeof (val), "%x", ivals[0]);
+
+	err = nvlist_add_string(nvl, name, val);
+
+	if (err == 0 && ival != NULL)
+		*ival = ivals[0];
+
+	return (err);
+}
+
+static int
+dev_getlabel(pcidb_hdl_t *db, int vid, int did, char *buf, size_t buflen)
+{
+	pcidb_vendor_t *vend = NULL;
+	pcidb_device_t *dev = NULL;
+
+	if ((vend = pcidb_lookup_vendor(db, vid)) == NULL)
+		return (ENOENT);
+
+	if ((dev = pcidb_lookup_device_by_vendor(vend, did)) == NULL)
+		return (ENOENT);
+
+	(void) snprintf(buf, buflen, "%s %s", pcidb_vendor_name(vend),
+	    pcidb_device_name(dev));
+
+	return (0);
+}
+
+static nvlist_t *
+dev_getinfo(di_node_t di_node, pcidb_hdl_t *db,
+    const char *dev, const char *path)
+{
+	char label[MAXPATHLEN];
+	nvlist_t *nvl = NULL;
+	int vid, did;
+	int err;
+
+	if ((err = nvlist_alloc(&nvl, NV_UNIQUE_NAME, 0)) != 0)
+		goto out;
+
+	if (dev != NULL && (err = nvlist_add_string(nvl, "dev", dev)) != 0)
+		goto out;
+	if ((err = nvlist_add_string(nvl, "path", path)) != 0)
+		goto out;
+	if ((err = get_int_prop(di_node, nvl, "vendor-id", &vid)) != 0)
+		goto out;
+	if ((err = get_int_prop(di_node, nvl, "device-id", &did)) != 0)
+		goto out;
+	if ((err = get_int_prop(di_node, nvl,
+	    "subsystem-vendor-id", NULL)) != 0)
+		goto out;
+	if ((err = get_int_prop(di_node, nvl, "subsystem-id", NULL)) != 0)
+		goto out;
+	if ((err = get_int_prop(di_node, nvl, "revision-id", NULL)) != 0)
+		goto out;
+
+	err = dev_getlabel(db, vid, did, label, sizeof (label));
+
+	if (err == 0) {
+		err = nvlist_add_string(nvl, "label", label);
+	} else if (err == ENOENT) {
+		err = 0;
+	}
+
+out:
+	if (err) {
+		nvlist_free(nvl);
+		errno = err;
+		return (NULL);
+	}
+
+	return (nvl);
+}
+
+/*
+ * /devices/pci0@0/....@0,1:ppt -> /pci0@0/...@0,1
+ */
+static const char *
+fs_to_phys_path(char *fspath)
+{
+	char *c;
+
+	if ((c = strrchr(fspath, ':')) != NULL && strcmp(c, ":ppt") == 0)
+		*c = '\0';
+
+	c = fspath;
+
+	if (strncmp(c, "/devices", strlen("/devices")) == 0)
+		c += strlen("/devices");
+
+	return (c);
+}
+
+/*
+ * Return an nvlist representing the mappings of /dev/ppt* devices to physical
+ * devices.  Of the form:
+ *
+ * /pci@0,0/... {
+ *  dev: "/dev/ppt0"
+ *  path: "/pci@0,0/..."
+ *  vendor-id: "8086"
+ *  device-id: "1528"
+ *  subsystem-vendor-id: "8086"
+ *  subsystem-id: "1528"
+ *  revision-id: "1"
+ *  label: "Intel Corporation ..."
+ * },
+ * /dev/ppt1 ...
+ *
+ * The nvlist should be freed by the caller.
+ */
+nvlist_t *
+ppt_list_assigned(void)
+{
+	di_node_t di_root = DI_NODE_NIL;
+	pcidb_hdl_t *db = NULL;
+	nvlist_t *nvl = NULL;
+	glob_t gl;
+	int err;
+
+	if ((di_root = di_init("/", DINFOCACHE)) == DI_NODE_NIL)
+		return (NULL);
+
+	if ((db = pcidb_open(PCIDB_VERSION)) == NULL) {
+		err = errno;
+		goto out;
+	}
+
+	if ((err = nvlist_alloc(&nvl, NV_UNIQUE_NAME, 0)) != 0)
+		goto out;
+
+	bzero(&gl, sizeof (gl));
+
+	if (glob("/dev/ppt*", GLOB_KEEPSTAT, NULL, &gl) != 0) {
+		err = errno;
+		goto out;
+	}
+
+	for (size_t i = 0; i < gl.gl_pathc; i++) {
+		char fspath[MAXPATHLEN];
+		nvlist_t *info_nvl;
+		di_node_t di_node;
+		const char *path;
+
+		if (!S_ISLNK(gl.gl_statv[i]->st_mode))
+			continue;
+
+		if (realpath(gl.gl_pathv[i], fspath) == NULL) {
+			err = errno;
+			goto out;
+		}
+
+		path = fs_to_phys_path(fspath);
+
+		/*
+		 * path argument is treated as const.
+		 */
+		if ((di_node = di_lookup_node(di_root, (char *)path)) == NULL) {
+			err = errno;
+			goto out;
+		}
+
+		if (!is_pci(di_node))
+			continue;
+
+		info_nvl = dev_getinfo(di_node, db, gl.gl_pathv[i], path);
+
+		if (info_nvl == NULL) {
+			err = errno;
+			goto out;
+		}
+
+		err = nvlist_add_nvlist(nvl, path, info_nvl);
+		nvlist_free(info_nvl);
+
+		if (err)
+			goto out;
+	}
+
+out:
+	if (di_root != DI_NODE_NIL)
+		di_fini(di_root);
+
+	pcidb_close(db);
+	globfree(&gl);
+
+	if (err) {
+		nvlist_free(nvl);
+		errno = err;
+		return (NULL);
+	}
+
+	return (nvl);
+}
+
+/*
+ * Read in our list of potential PPT devices.  A boot-module provided file
+ * explicitly over-rides anything delivered.
+ */
+static int
+get_matches(list_t *listp)
+{
+	FILE *fp;
+	int err;
+
+	list_create(listp, sizeof (ppt_match_t),
+	    offsetof(ppt_match_t, pm_list));
+
+	if ((fp = fopen("/system/boot/etc/ppt_matches", "r")) == NULL) {
+		if (errno != ENOENT)
+			return (errno);
+
+		if ((fp = fopen("/etc/ppt_matches", "r")) == NULL) {
+			if (errno == ENOENT)
+				return (0);
+			return (errno);
+		}
+	}
+
+	for (;;) {
+		char *line = NULL;
+		ppt_match_t *pm;
+		size_t cap = 0;
+		ssize_t read;
+
+		if ((read = getline(&line, &cap, fp)) <= 0)
+			break;
+
+		if (line[read - 1] == '\n')
+			line[read - 1] = '\0';
+
+		if ((pm = malloc(sizeof (*pm))) == NULL) {
+			err = errno;
+			free(line);
+			goto out;
+		}
+
+		bzero(pm, sizeof (*pm));
+
+		if (sscanf(line, "pciex%4s,%4s", &pm->pm_vendor,
+		    &pm->pm_device) == 2 ||
+		    sscanf(line, "pci%4s,%4s", &pm->pm_vendor,
+		    &pm->pm_device) == 2 ||
+		    sscanf(line, "pciex%4s", &pm->pm_vendor) == 1 ||
+		    sscanf(line, "pci%4s", &pm->pm_vendor) == 1) {
+			list_insert_tail(listp, pm);
+		} else if (line[0] == '/') {
+			(void) strlcpy(pm->pm_path, line, sizeof (pm->pm_path));
+			list_insert_tail(listp, pm);
+		}
+
+		/*
+		 * Ignore any line we don't understand.
+		 */
+
+		free(line);
+	}
+
+	err = 0;
+
+out:
+	(void) fclose(fp);
+	return (err);
+}
+
+static boolean_t
+match_ppt(list_t *matches, nvlist_t *nvl)
+{
+	char *vendor;
+	char *device;
+	char *path;
+
+	if (nvlist_lookup_string(nvl, "path", &path) != 0 ||
+	    nvlist_lookup_string(nvl, "vendor-id", &vendor) != 0 ||
+	    nvlist_lookup_string(nvl, "device-id", &device) != 0)
+		return (B_FALSE);
+
+	for (ppt_match_t *pm = list_head(matches); pm != NULL;
+	    pm = list_next(matches, pm)) {
+		if (pm->pm_path[0] != '\0' && strcmp(pm->pm_path, path) == 0)
+			return (B_TRUE);
+
+		if (pm->pm_vendor[0] != '\0' &&
+		    strcmp(pm->pm_vendor, vendor) == 0) {
+			if (pm->pm_device[0] == '\0')
+				return (B_TRUE);
+			if (strcmp(pm->pm_device, device) == 0)
+				return (B_TRUE);
+		}
+	}
+
+	return (B_FALSE);
+}
+
+static int
+inspect_node(di_node_t di_node, void *arg)
+{
+	node_data_t *data = arg;
+	nvlist_t *info_nvl = NULL;
+	char *devname = NULL;
+	const char *driver;
+	char *path = NULL;
+
+	if (!is_pci(di_node))
+		return (DI_WALK_CONTINUE);
+
+	driver = di_driver_name(di_node);
+
+	if (driver != NULL && strcmp(driver, "ppt") == 0) {
+		if (asprintf(&devname, "/dev/ppt%d",
+		    di_instance(di_node)) < 0)
+			goto out;
+	}
+
+	if ((path = di_devfs_path(di_node)) == NULL) {
+		data->nd_err = ENOENT;
+		goto out;
+	}
+
+	info_nvl = dev_getinfo(di_node, data->nd_db, devname, path);
+
+	if (info_nvl == NULL)
+		goto out;
+
+	if (devname == NULL && !match_ppt(&data->nd_matches, info_nvl))
+		goto out;
+
+	data->nd_err = nvlist_add_nvlist(data->nd_nvl, path, info_nvl);
+
+out:
+	free(path);
+	free(devname);
+	nvlist_free(info_nvl);
+	return (data->nd_err ? DI_WALK_TERMINATE : DI_WALK_CONTINUE);
+}
+
+/*
+ * Like ppt_list_assigned() output, but includes all devices that could be used
+ * for passthrough, whether assigned or not.
+ */
+nvlist_t *
+ppt_list(void)
+{
+	node_data_t nd = { NULL, };
+	di_node_t di_root;
+	int err;
+
+	if ((di_root = di_init("/", DINFOCACHE)) == DI_NODE_NIL)
+		return (NULL);
+
+	if ((err = get_matches(&nd.nd_matches)) != 0)
+		goto out;
+
+	if ((nd.nd_db = pcidb_open(PCIDB_VERSION)) == NULL) {
+		err = errno;
+		goto out;
+	}
+
+	if ((err = nvlist_alloc(&nd.nd_nvl, NV_UNIQUE_NAME, 0)) != 0)
+		goto out;
+
+	if ((err = di_walk_node(di_root, DI_WALK_CLDFIRST,
+	    &nd, inspect_node)) != 0)
+		goto out;
+
+	err = nd.nd_err;
+
+out:
+	pcidb_close(nd.nd_db);
+
+	for (ppt_match_t *pm = list_head(&nd.nd_matches); pm != NULL; ) {
+		ppt_match_t *next = list_next(&nd.nd_matches, pm);
+		free(pm);
+		pm = next;
+	}
+
+	if (di_root != DI_NODE_NIL)
+		di_fini(di_root);
+
+	if (err) {
+		nvlist_free(nd.nd_nvl);
+		errno = err;
+		return (NULL);
+	}
+
+	return (nd.nd_nvl);
+}
+
+/*
+ * Given a physical path such as "/devices/pci0@0...", return the "/dev/pptX"
+ * that is bound to it, if any.  The "/devices/" prefix is optional.  The
+ * physical path may have the ":ppt" minor name suffix.
+ *
+ * Returns ENOENT if no such PPT device exists.
+ */
+int
+ppt_devpath_to_dev(const char *inpath, char *buf, size_t buflen)
+{
+	char fspath[MAXPATHLEN] = "";
+	nvpair_t *nvp = NULL;
+	const char *devpath;
+	nvlist_t *nvl;
+	int err;
+
+	if (strlcat(fspath, inpath, sizeof (fspath)) >= sizeof (fspath))
+		return (ENAMETOOLONG);
+
+	devpath = fs_to_phys_path(fspath);
+
+	if ((nvl = ppt_list_assigned()) == NULL)
+		return (errno);
+
+	while ((nvp = nvlist_next_nvpair(nvl, nvp)) != NULL) {
+		const char *ppt = nvpair_name(nvp);
+		nvpair_t *nvpp = NULL;
+		nvlist_t *props;
+
+		(void) nvpair_value_nvlist(nvp, &props);
+
+		while ((nvpp = nvlist_next_nvpair(props, nvpp)) != NULL) {
+			const char *name = nvpair_name(nvpp);
+			char *val;
+
+			(void) nvpair_value_string(nvpp, &val);
+
+			if (strcmp(name, "path") != 0)
+				continue;
+
+			if (strcmp(devpath, val) != 0)
+				break;
+
+			if (strlcpy(buf, ppt, buflen) >= buflen)
+				err = ENAMETOOLONG;
+			else
+				err = 0;
+
+			goto out;
+		}
+	}
+
+	err = ENOENT;
+
+out:
+	nvlist_free(nvl);
+	return (err);
+}
diff --git a/usr/src/lib/libppt/common/libppt.h b/usr/src/lib/libppt/common/libppt.h
new file mode 100644
index 0000000000..efbf2c7b8b
--- /dev/null
+++ b/usr/src/lib/libppt/common/libppt.h
@@ -0,0 +1,36 @@
+/*
+ * This file and its contents are supplied under the terms of the
+ * Common Development and Distribution License ("CDDL"), version 1.0.
+ * You may only use this file in accordance with the terms of version
+ * 1.0 of the CDDL.
+ *
+ * A full copy of the text of the CDDL should have accompanied this
+ * source.  A copy of the CDDL is also available via the Internet at
+ * http://www.illumos.org/license/CDDL.
+ *
+ *
+ * Copyright 2018 Joyent, Inc.
+ */
+
+#ifndef _LIBPPT_H
+#define	_LIBPPT_H
+
+#include <sys/types.h>
+
+#include <libnvpair.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+extern int ppt_devpath_to_dev(const char *, char *, size_t);
+
+extern nvlist_t *ppt_list_assigned(void);
+
+extern nvlist_t *ppt_list(void);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _LIBPPT_H */
diff --git a/usr/src/lib/libppt/common/llib-lppt b/usr/src/lib/libppt/common/llib-lppt
new file mode 100644
index 0000000000..dadd992a31
--- /dev/null
+++ b/usr/src/lib/libppt/common/llib-lppt
@@ -0,0 +1,19 @@
+/*
+ * This file and its contents are supplied under the terms of the
+ * Common Development and Distribution License ("CDDL"), version 1.0.
+ * You may only use this file in accordance with the terms of version
+ * 1.0 of the CDDL.
+ *
+ * A full copy of the text of the CDDL should have accompanied this
+ * source.  A copy of the CDDL is also available via the Internet at
+ * http://www.illumos.org/license/CDDL.
+ */
+
+/*
+ * Copyright 2018 Joyent, Inc.
+ */
+
+/* LINTLIBRARY */
+/* PROTOLIB1 */
+
+#include <libppt.h>
diff --git a/usr/src/lib/libppt/common/mapfile-vers b/usr/src/lib/libppt/common/mapfile-vers
new file mode 100644
index 0000000000..d9d882874b
--- /dev/null
+++ b/usr/src/lib/libppt/common/mapfile-vers
@@ -0,0 +1,40 @@
+#
+# This file and its contents are supplied under the terms of the
+# Common Development and Distribution License ("CDDL"), version 1.0.
+# You may only use this file in accordance with the terms of version
+# 1.0 of the CDDL.
+#
+# A full copy of the text of the CDDL should have accompanied this
+# source.  A copy of the CDDL is also available via the Internet at
+# http://www.illumos.org/license/CDDL.
+#
+
+#
+# Copyright 2018 Joyent, Inc.
+#
+
+#
+# MAPFILE HEADER START
+#
+# WARNING:  STOP NOW.  DO NOT MODIFY THIS FILE.
+# Object versioning must comply with the rules detailed in
+#
+#	usr/src/lib/README.mapfiles
+#
+# You should not be making modifications here until you've read the most current
+# copy of that file. If you need help, contact a gatekeeper for guidance.
+#
+# MAPFILE HEADER END
+#
+
+$mapfile_version 2
+
+SYMBOL_VERSION ILLUMOSprivate {
+    global:
+	ppt_devpath_to_dev;
+	ppt_list_assigned;
+	ppt_list;
+
+    local:
+	*;
+};
diff --git a/usr/src/cmd/mdb/intel/amd64/vmm/Makefile b/usr/src/lib/libppt/i386/Makefile
similarity index 66%
rename from usr/src/cmd/mdb/intel/amd64/vmm/Makefile
rename to usr/src/lib/libppt/i386/Makefile
index 0f2b977dfd..3f11e556d4 100644
--- a/usr/src/cmd/mdb/intel/amd64/vmm/Makefile
+++ b/usr/src/lib/libppt/i386/Makefile
@@ -10,12 +10,9 @@
 #
 
 #
-# Copyright 2014 Pluribus Networks Inc.
-# Copyright 2017 Joyent, Inc.
+# Copyright 2018 Joyent, Inc.
 #
 
-#MAKEVARS = CW_NO_SHADOW=true __GNUC=
+include		../Makefile.com
 
-include $(SRC)/Makefile.master
-$(BUILD64)SUBDIRS +=	$(MACH64)
-include ../../../Makefile.subdirs
+install:	all $(ROOTLIBS) $(ROOTLINKS) $(ROOTLINT)
diff --git a/usr/src/lib/libppt/sparc/Makefile b/usr/src/lib/libppt/sparc/Makefile
new file mode 100644
index 0000000000..3f11e556d4
--- /dev/null
+++ b/usr/src/lib/libppt/sparc/Makefile
@@ -0,0 +1,18 @@
+#
+# This file and its contents are supplied under the terms of the
+# Common Development and Distribution License ("CDDL"), version 1.0.
+# You may only use this file in accordance with the terms of version
+# 1.0 of the CDDL.
+#
+# A full copy of the text of the CDDL should have accompanied this
+# source.  A copy of the CDDL is also available via the Internet at
+# http://www.illumos.org/license/CDDL.
+#
+
+#
+# Copyright 2018 Joyent, Inc.
+#
+
+include		../Makefile.com
+
+install:	all $(ROOTLIBS) $(ROOTLINKS) $(ROOTLINT)
diff --git a/usr/src/lib/libppt/sparcv9/Makefile b/usr/src/lib/libppt/sparcv9/Makefile
new file mode 100644
index 0000000000..5a304d7fe7
--- /dev/null
+++ b/usr/src/lib/libppt/sparcv9/Makefile
@@ -0,0 +1,19 @@
+#
+# This file and its contents are supplied under the terms of the
+# Common Development and Distribution License ("CDDL"), version 1.0.
+# You may only use this file in accordance with the terms of version
+# 1.0 of the CDDL.
+#
+# A full copy of the text of the CDDL should have accompanied this
+# source.  A copy of the CDDL is also available via the Internet at
+# http://www.illumos.org/license/CDDL.
+#
+
+#
+# Copyright 2018 Joyent, Inc.
+#
+
+include		../Makefile.com
+include		$(SRC)/lib/Makefile.lib.64
+
+install:	all $(ROOTLIBS64) $(ROOTLINKS64)
diff --git a/usr/src/lib/libsmbfs/Makefile.com b/usr/src/lib/libsmbfs/Makefile.com
index 0521eba951..8f8b118128 100644
--- a/usr/src/lib/libsmbfs/Makefile.com
+++ b/usr/src/lib/libsmbfs/Makefile.com
@@ -59,7 +59,6 @@ OBJ_LIB=\
 	nb_ssn.o \
 	nbns_rq.o \
 	negprot.o \
-	netshareenum.o \
 	newvc.o \
 	nls.o \
 	ntlm.o \
diff --git a/usr/src/lib/libsmbfs/netsmb/smb_netshareenum.h b/usr/src/lib/libsmbfs/netsmb/smb_netshareenum.h
deleted file mode 100644
index 14f2594df7..0000000000
--- a/usr/src/lib/libsmbfs/netsmb/smb_netshareenum.h
+++ /dev/null
@@ -1,18 +0,0 @@
-
-#ifndef _NETSMB_SMB_NETSHAREENUM_H_
-#define	_NETSMB_SMB_NETSHAREENUM_H_
-
-#pragma ident	"%Z%%M%	%I%	%E% SMI"
-
-/* This is from Apple.  See ../smb/netshareenum.c */
-
-struct share_info {
-	uint16_t	type;
-	char		*netname;
-	char		*remark;
-};
-typedef struct share_info share_info_t;
-
-int  smb_netshareenum(struct smb_ctx *, int *, int *, struct share_info **);
-
-#endif /* _NETSMB_SMB_NETSHAREENUM_H_ */
diff --git a/usr/src/lib/libsmbfs/netsmb/smbfs_api.h b/usr/src/lib/libsmbfs/netsmb/smbfs_api.h
index 8436318b4c..b1f4b1e198 100644
--- a/usr/src/lib/libsmbfs/netsmb/smbfs_api.h
+++ b/usr/src/lib/libsmbfs/netsmb/smbfs_api.h
@@ -140,8 +140,8 @@ typedef void (*smb_ctx_close_hook_t)(struct smb_ctx *);
 void smb_ctx_set_close_hook(smb_ctx_close_hook_t);
 int  smb_fh_close(int);
 int  smb_fh_open(struct smb_ctx *ctx, const char *, int);
-int  smb_fh_read(int, off_t, size_t, char *);
-int  smb_fh_write(int, off_t, size_t, const char *);
+int  smb_fh_read(int, off64_t, size_t, char *);
+int  smb_fh_write(int, off64_t, size_t, const char *);
 int  smb_fh_xactnp(int, int, const char *,
 	int *, char *, int *);
 int  smb_fh_getssnkey(int, uchar_t *, size_t);
diff --git a/usr/src/lib/libsmbfs/smb/file.c b/usr/src/lib/libsmbfs/smb/file.c
index 1c09532d61..8ca9d2cee1 100644
--- a/usr/src/lib/libsmbfs/smb/file.c
+++ b/usr/src/lib/libsmbfs/smb/file.c
@@ -204,7 +204,7 @@ smb_fh_open(struct smb_ctx *ctx, const char *path, int oflag)
 }
 
 int
-smb_fh_read(int fd, off_t offset, size_t count,
+smb_fh_read(int fd, off64_t offset, size_t count,
 	char *dst)
 {
 	struct smbioc_rw rwrq;
@@ -221,7 +221,7 @@ smb_fh_read(int fd, off_t offset, size_t count,
 }
 
 int
-smb_fh_write(int fd, off_t offset, size_t count,
+smb_fh_write(int fd, off64_t offset, size_t count,
 	const char *src)
 {
 	struct smbioc_rw rwrq;
diff --git a/usr/src/lib/libsmbfs/smb/llib-lsmbfs b/usr/src/lib/libsmbfs/smb/llib-lsmbfs
index 1096482541..7459db63be 100644
--- a/usr/src/lib/libsmbfs/smb/llib-lsmbfs
+++ b/usr/src/lib/libsmbfs/smb/llib-lsmbfs
@@ -34,7 +34,6 @@
 
 #include <netsmb/smb_lib.h>
 #include <netsmb/smb_keychain.h>
-#include <netsmb/smb_netshareenum.h>
 #include <netsmb/smb_rap.h>
 #include <netsmb/spnego.h>
 
diff --git a/usr/src/lib/libsmbfs/smb/mapfile-vers b/usr/src/lib/libsmbfs/smb/mapfile-vers
index 24bffec63d..68b38f46ed 100644
--- a/usr/src/lib/libsmbfs/smb/mapfile-vers
+++ b/usr/src/lib/libsmbfs/smb/mapfile-vers
@@ -111,7 +111,6 @@ SYMBOL_VERSION SUNWprivate {
 	smb_iod_start;
 	smb_iod_work;
 	smb_lib_init;
-	smb_netshareenum;	# will move to libnetapi
 	smb_open_printer;
 	smb_open_rcfile;
 	smb_simplecrypt;
diff --git a/usr/src/lib/libsmbfs/smb/netshareenum.c b/usr/src/lib/libsmbfs/smb/netshareenum.c
deleted file mode 100644
index af5a0bb9bd..0000000000
--- a/usr/src/lib/libsmbfs/smb/netshareenum.c
+++ /dev/null
@@ -1,378 +0,0 @@
-/*
- * Copyright (c) 2004 Apple Computer, Inc. All rights reserved.
- *
- * @APPLE_LICENSE_HEADER_START@
- *
- * "Portions Copyright (c) 1999 Apple Computer, Inc.  All Rights
- * Reserved.  This file contains Original Code and/or Modifications of
- * Original Code as defined in and that are subject to the Apple Public
- * Source License Version 1.0 (the 'License').  You may not use this file
- * except in compliance with the License.  Please obtain a copy of the
- * License at http://www.apple.com/publicsource and read it before using
- * this file.
- *
- * The Original Code and all software distributed under the License are
- * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
- * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
- * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the
- * License for the specific language governing rights and limitations
- * under the License."
- *
- * @APPLE_LICENSE_HEADER_END@
- */
-
-/* BEGIN CSTYLED */
-/*
- *      @(#)ui.c      *
- *      (c) 2004   Apple Computer, Inc.  All Rights Reserved
- *
- *
- *      netshareenum.c -- Routines for getting a list of share information
- *			  from a server.
- *
- *      MODIFICATION HISTORY:
- *       27-Nov-2004     Guy Harris	New today
- */
-/* END CSTYLED */
-
-/*
- * Copyright (c) 2008, 2010, Oracle and/or its affiliates. All rights reserved.
- */
-
-#include <stdlib.h>
-#include <string.h>
-#include <stdio.h>
-#include <errno.h>
-
-#include <netsmb/mchain.h>
-#include <netsmb/smb.h>
-#include <netsmb/smb_lib.h>
-#include <netsmb/smb_rap.h>
-#include <netsmb/smb_netshareenum.h>
-#include <smb/charsets.h>
-
-#if 0 /* XXX see below */
-#include <dce/exc_handling.h>
-#include <rpc/attrb.h>
-#include "srvsvc.h"
-#endif
-
-/*
- * Don't want RPC client-side code in here.
- * It's good code; just doesn't belong here.
- *
- * The API provided by this library should be
- * just files and pipes (and not much more).
- * It MAY be useful to provide some of the
- * RAP (remote API) functions functions like
- * rap_netshareenum below...
- *
- * XXX: Not sure this file belongs here at all.
- * smb_rap.h looks like a reasonable API
- * for this library to export.
- */
-#if 0 /* XXX */
-
-static int
-rpc_netshareenum(struct smb_ctx *ctx, int *entriesp, int *totalp,
-    struct share_info **entries_listp)
-{
-	char ctx_string[2+16+1];	/* enough for 64-bit pointer, in hex */
-	unsigned_char_p_t binding;
-	unsigned32 binding_status;
-	rpc_binding_handle_t binding_h;
-	int error, i, entries;
-	char *addrstr, *srvnamestr;
-	unsigned short *usrvnamestr;
-	unsigned32 level;
-	SHARE_ENUM_STRUCT share_info;
-	SHARE_INFO_1_CONTAINER share_info_1_container;
-	SHARE_INFO_1 *shares, *share;
-	unsigned32 total_entries;
-	unsigned32 status, free_status;
-	struct share_info *entry_list, *elp;
-	static EXCEPTION rpc_x_connect_rejected;
-	static int exceptions_initialized;
-
-	sprintf(ctx_string, "%p", ctx);
-	rpc_string_binding_compose(NULL, "ncacn_np", ctx_string,
-	    "srvsvc", NULL, &binding, &binding_status);
-	if (binding_status != rpc_s_ok) {
-		smb_error(dgettext(TEXT_DOMAIN,
-		    "rpc_string_binding_compose failed with %d"),
-		    0, binding_status);
-		return (EINVAL);
-	}
-	rpc_binding_from_string_binding(binding, &binding_h, &status);
-	rpc_string_free(&binding, (unsigned32 *)&free_status);
-	if (binding_status != rpc_s_ok) {
-		smb_error(dgettext(TEXT_DOMAIN,
-		    "rpc_binding_from_string_binding failed with %d"), 0,
-		    binding_status);
-		return (EINVAL);
-	}
-	level = 1;
-	share_info.share_union.level = 1;
-	share_info.share_union.tagged_union.share1 = &share_info_1_container;
-	share_info_1_container.share_count = 0;
-	share_info_1_container.shares = NULL;
-	/*
-	 * Convert the server IP address to a string, and send that as
-	 * the "server name" - that's what Windows appears to do, and
-	 * that avoids problems with NetBIOS names containing
-	 * non-ASCII characters.
-	 */
-	addrstr = inet_ntoa(ctx->ct_srvinaddr.sin_addr);
-	srvnamestr = malloc(strlen(addrstr) + 3);
-	if (srvnamestr == NULL) {
-		status = errno;
-		smb_error(dgettext(TEXT_DOMAIN,
-		    "can't allocate string for server address"), status);
-		rpc_binding_free(&binding_h, &free_status);
-		return (status);
-	}
-	strcpy(srvnamestr, "\\\\");
-	strcat(srvnamestr, addrstr);
-	usrvnamestr = convert_utf8_to_leunicode(srvnamestr);
-	if (usrvnamestr == NULL) {
-		smb_error(dgettext(TEXT_DOMAIN,
-		    "can't convert string for server address to Unicode"), 0);
-		rpc_binding_free(&binding_h, &free_status);
-		free(srvnamestr);
-		return (EINVAL);
-	}
-	if (!exceptions_initialized) {
-		EXCEPTION_INIT(rpc_x_connect_rejected);
-		exc_set_status(&rpc_x_connect_rejected, rpc_s_connect_rejected);
-		exceptions_initialized = 1;
-	}
-	/* printf("Calling NetrShareEnum.."); XXX */
-	TRY
-		status = NetrShareEnum(binding_h, usrvnamestr, &level,
-		    &share_info, 4294967295U, &total_entries, NULL);
-		if (status != 0)
-			smb_error(dgettext(TEXT_DOMAIN,
-			    "error from NetrShareEnum call: status = 0x%08x"),
-			    0, status);
-	/*CSTYLED*/
-	CATCH (rpc_x_connect_rejected)
-		/*
-		 * This is what we get if we can't open the pipe.
-		 * That's a normal occurrence when we're talking
-		 * to a system that (presumably) doesn't support
-		 * DCE RPC on the server side, such as Windows 95/98/Me,
-		 * so we don't log an error.
-		 */
-		/*CSTYLED*/
-		status = ENOTSUP;
-	CATCH_ALL
-		/*
-		 * XXX - should we handle some exceptions differently,
-		 * returning different errors, and try RAP only for
-		 * ENOTSUP?
-		 */
-		smb_error(dgettext(TEXT_DOMAIN,
-		    "error from NetrShareEnum call: exception = %u"),
-		    0, THIS_CATCH->match.value);
-		status = ENOTSUP;
-	ENDTRY
-	rpc_binding_free(&binding_h, &free_status);
-	free(srvnamestr);
-	free(usrvnamestr);
-	if (status != 0)
-		return (ENOTSUP);
-
-	/*
-	 * XXX - if the IDL is correct, it's not clear whether the
-	 * unmarshalling code will properly handle the case where
-	 * a packet where "share_count" and the max count for the
-	 * array of shares don't match; a valid DCE RPC implementation
-	 * won't marshal something like that, but there's no guarantee
-	 * that the server we're talking to has a valid implementation
-	 * (which could be a *malicious* implementation!).
-	 */
-	entries = share_info.share_union.tagged_union.share1->share_count;
-	shares = share_info.share_union.tagged_union.share1->shares;
-	entry_list = calloc(entries, sizeof (struct share_info));
-	if (entry_list == NULL) {
-		error = errno;
-		goto cleanup_and_return;
-	}
-	for (share = shares, elp = entry_list, i = 0; i < entries;
-	    i++, share++) {
-		elp->type = share->shi1_type;
-		elp->netname = convert_unicode_to_utf8(share->shi1_share);
-		if (elp->netname == NULL)
-			goto fail;
-		elp->remark = convert_unicode_to_utf8(share->shi1_remark);
-		if (elp->remark == NULL)
-			goto fail;
-		elp++;
-	}
-	*entriesp = entries;
-	*totalp = total_entries;
-	*entries_listp = entry_list;
-	error = 0;
-	goto cleanup_and_return;
-
-fail:
-	error = errno;
-	for (elp = entry_list, i = 0; i < entries; i++, elp++) {
-		/*
-		 * elp->netname is set before elp->remark, so if
-		 * elp->netname is null, elp->remark is also null.
-		 * If either of them is null, we haven't done anything
-		 * to any entries after this one.
-		 */
-		if (elp->netname == NULL)
-			break;
-		free(elp->netname);
-		if (elp->remark == NULL)
-			break;
-		free(elp->remark);
-	}
-	free(entry_list);
-
-cleanup_and_return:
-	for (share = shares, i = 0; i < entries; i++, share++) {
-		free(share->shi1_share);
-		free(share->shi1_remark);
-	}
-	free(shares);
-	/*
-	 * XXX - "share1" should be a unique pointer, but we haven't
-	 * changed the marshalling code to support non-full pointers
-	 * in unions, so we leave it as a full pointer.
-	 *
-	 * That means that this might, or might not, be changed from
-	 * pointing to "share_info_1_container" to pointing to a
-	 * mallocated structure, according to the DCE RPC 1.1 IDL spec;
-	 * we free it only if it's changed.
-	 */
-	if (share_info.share_union.tagged_union.share1 !=
-	    &share_info_1_container)
-		free(share_info.share_union.tagged_union.share1);
-	return (error);
-}
-#endif /* XXX */
-
-/*
- * Enumerate shares using RAP
- */
-
-struct smb_share_info_1 {
-	char		shi1_netname[13];
-	char		shi1_pad;
-	uint16_t	shi1_type;
-	uint32_t	shi1_remark;		/* char * */
-};
-
-static int
-smb_rap_NetShareEnum(struct smb_ctx *ctx, int sLevel, void *pbBuffer,
-	int *cbBuffer, int *pcEntriesRead, int *pcTotalAvail)
-{
-	struct smb_rap *rap;
-	long lval = -1;
-	int error;
-
-	error = smb_rap_create(0, "WrLeh", "B13BWz", &rap);
-	if (error)
-		return (error);
-	(void) smb_rap_setNparam(rap, sLevel);		/* W - sLevel */
-	(void) smb_rap_setPparam(rap, pbBuffer);	/* r - pbBuffer */
-	(void) smb_rap_setNparam(rap, *cbBuffer);	/* L - cbBuffer */
-	error = smb_rap_request(rap, ctx);
-	if (error == 0) {
-		*pcEntriesRead = rap->r_entries;
-		error = smb_rap_getNparam(rap, &lval);
-		*pcTotalAvail = lval;
-		/* Copy the data length into the IN/OUT variable. */
-		*cbBuffer = rap->r_rcvbuflen;
-	}
-	error = smb_rap_error(rap, error);
-	smb_rap_done(rap);
-	return (error);
-}
-
-static int
-rap_netshareenum(struct smb_ctx *ctx, int *entriesp, int *totalp,
-    struct share_info **entries_listp)
-{
-	int error, bufsize, i, entries, total, nreturned;
-	struct smb_share_info_1 *rpbuf, *ep;
-	struct share_info *entry_list, *elp;
-	char *cp;
-	int lbound, rbound;
-
-	bufsize = 0xffe0;	/* samba notes win2k bug for 65535 */
-	rpbuf = malloc(bufsize);
-	if (rpbuf == NULL)
-		return (errno);
-
-	error = smb_rap_NetShareEnum(ctx, 1, rpbuf, &bufsize, &entries, &total);
-	if (error &&
-	    error != (ERROR_MORE_DATA | SMB_RAP_ERROR)) {
-		free(rpbuf);
-		return (error);
-	}
-	entry_list = malloc(entries * sizeof (struct share_info));
-	if (entry_list == NULL) {
-		error = errno;
-		free(rpbuf);
-		return (error);
-	}
-	lbound = entries * (sizeof (struct smb_share_info_1));
-	rbound = bufsize;
-	for (ep = rpbuf, elp = entry_list, i = 0, nreturned = 0; i < entries;
-	    i++, ep++) {
-		elp->type = letohs(ep->shi1_type);
-		ep->shi1_pad = '\0'; /* ensure null termination */
-		elp->netname = convert_wincs_to_utf8(ep->shi1_netname);
-		if (elp->netname == NULL)
-			continue;	/* punt on this entry */
-		/*
-		 * Check for validity of offset.
-		 */
-		if (ep->shi1_remark >= lbound && ep->shi1_remark < rbound) {
-			cp = (char *)rpbuf + ep->shi1_remark;
-			elp->remark = convert_wincs_to_utf8(cp);
-		} else
-			elp->remark = NULL;
-		elp++;
-		nreturned++;
-	}
-	*entriesp = nreturned;
-	*totalp = total;
-	*entries_listp = entry_list;
-	free(rpbuf);
-	return (0);
-}
-
-/*
- * First we try the RPC-based NetrShareEnum, and, if that fails, we fall
- * back on the RAP-based NetShareEnum.
- */
-int
-smb_netshareenum(struct smb_ctx *ctx, int *entriesp, int *totalp,
-    struct share_info **entry_listp)
-{
-	int error;
-
-#ifdef NOTYETDEFINED
-	/*
-	 * Try getting a list of shares with the SRVSVC RPC service.
-	 */
-	error = rpc_netshareenum(ctx, entriesp, totalp, entry_listp);
-	if (error == 0)
-		return (0);
-#endif
-
-	/*
-	 * OK, that didn't work - try RAP.
-	 * XXX - do so only if it failed because we couldn't open
-	 * the pipe?
-	 */
-	error = rap_netshareenum(ctx, entriesp, totalp, entry_listp);
-	return (error);
-}
diff --git a/usr/src/lib/libxcurses/src/libc/xcurses/slk.c b/usr/src/lib/libxcurses/src/libc/xcurses/slk.c
index a23188b064..c3b9cdaafc 100644
--- a/usr/src/lib/libxcurses/src/libc/xcurses/slk.c
+++ b/usr/src/lib/libxcurses/src/libc/xcurses/slk.c
@@ -24,8 +24,6 @@
  * All rights reserved.
  */
 
-#pragma ident	"%Z%%M%	%I%	%E% SMI"
-
 /*
  * slk.c
  * 
@@ -35,12 +33,6 @@
  *
  */
 
-#if M_RCSID
-#ifndef lint
-static char rcsID[] = "$Header: /rd/src/libc/xcurses/rcs/slk.c 1.1 1995/07/19 16:38:06 ant Exp $";
-#endif
-#endif
-
 #include <private.h>
 
 /*
@@ -72,7 +64,7 @@ slk_attron(const chtype at)
 	__m_trace("slk_attron(%lx)", at);
 #endif
 
-	if (__m_screen->_slk._w != (WINDOW *) 0)
+	if (__m_screen->_slk._w != NULL)
 		code = wattron(__m_screen->_slk._w, at);
 
 	return __m_return_code("slk_attron", code);
@@ -87,7 +79,7 @@ slk_attroff(const chtype at)
 	__m_trace("slk_attroff(%lx)", at);
 #endif
 
-	if (__m_screen->_slk._w != (WINDOW *) 0)
+	if (__m_screen->_slk._w != NULL)
 		code = wattroff(__m_screen->_slk._w, at);
 
 	return __m_return_code("slk_attroff", code);
@@ -102,7 +94,7 @@ slk_attrset(const chtype at)
 	__m_trace("slk_attrset(%lx)", at);
 #endif
 
-	if (__m_screen->_slk._w != (WINDOW *) 0)
+	if (__m_screen->_slk._w != NULL)
 		code = wattrset(__m_screen->_slk._w, at);
 
 	return __m_return_code("slk_attrset", code);
@@ -117,7 +109,7 @@ slk_attr_off(const attr_t at, void *opts)
 	__m_trace("slk_attr_off(%x, %p)", at, opts);
 #endif
 
-	if (__m_screen->_slk._w != (WINDOW *) 0)
+	if (__m_screen->_slk._w != NULL)
 		code = wattr_off(__m_screen->_slk._w, at, opts);
 
 	return __m_return_code("slk_attr_off", code);
@@ -132,7 +124,7 @@ slk_attr_on(const attr_t at, void *opts)
 	__m_trace("slk_attr_on(%x, %p)", at, opts);
 #endif
 
-	if (__m_screen->_slk._w != (WINDOW *) 0)
+	if (__m_screen->_slk._w != NULL)
 		code = wattr_on(__m_screen->_slk._w, at, opts);
 
 	return __m_return_code("slk_attr_on", code);
@@ -147,7 +139,7 @@ slk_attr_set(const attr_t at, short co, void *opts)
 	__m_trace("slk_attr_set(%x, %d, %p)", at, co, opts);
 #endif
 
-	if (__m_screen->_slk._w != (WINDOW *) 0)
+	if (__m_screen->_slk._w != NULL)
 		code = wattr_set(__m_screen->_slk._w, at, co, opts);
 
 	return __m_return_code("slk_attr_set", code);
@@ -162,8 +154,8 @@ slk_color(short co)
 	__m_trace("slk_color(%d)", co);
 #endif
 
-	if (__m_screen->_slk._w != (WINDOW *) 0)
-		code = wcolor_set(__m_screen->_slk._w, co, (void *) 0);
+	if (__m_screen->_slk._w != NULL)
+		code = wcolor_set(__m_screen->_slk._w, co, NULL);
 
 	return __m_return_code("slk_color", code);
 }
@@ -177,7 +169,7 @@ slk_touch()
 	__m_trace("slk_touch(void)");
 #endif
 
-	if (__m_screen->_slk._w != (WINDOW *) 0)
+	if (__m_screen->_slk._w != NULL)
 		code = wtouchln(__m_screen->_slk._w, 0, 1, 1);
 
 	return __m_return_code("slk_touch", code);
@@ -192,10 +184,10 @@ slk_clear()
 	__m_trace("slk_clear(void)");
 #endif
 
-	if (__m_screen->_slk._w != (WINDOW *) 0) {
+	if (__m_screen->_slk._w != NULL) {
 		if (werase(__m_screen->_slk._w) == OK)
 			code = wrefresh(__m_screen->_slk._w);
-	} else if (label_off != (char *) 0) {
+	} else if (label_off != NULL) {
 		(void) tputs(label_off, 1, __m_outc);
 		(void) fflush(__m_screen->_of);
 		code = OK;
@@ -213,9 +205,9 @@ slk_restore()
 	__m_trace("slk_clear(void)");
 #endif
 
-	if (__m_screen->_slk._w != (WINDOW *) 0) {
+	if (__m_screen->_slk._w != NULL) {
 		for (i = 0; i < 8; ++i) {
-			if (__m_screen->_slk._labels[i] != (char *) 0) {
+			if (__m_screen->_slk._labels[i] != NULL) {
 				(void) slk_set(
 					i, __m_screen->_slk._labels[i],
 					__m_screen->_slk._justify[i]
@@ -224,7 +216,7 @@ slk_restore()
 		}
 
 		code = slk_refresh();
-	} else if (label_on != (char *) 0) {
+	} else if (label_on != NULL) {
 		(void) tputs(label_on, 1, __m_outc);
 		(void) fflush(__m_screen->_of);
 		code = OK;
@@ -242,7 +234,7 @@ slk_noutrefresh()
 	__m_trace("slk_noutrefresh(void)");
 #endif
 
-	if (__m_screen->_slk._w != (WINDOW *) 0)
+	if (__m_screen->_slk._w != NULL)
 		code = wnoutrefresh(__m_screen->_slk._w);
 
 	return __m_return_code("slk_noutrefresh", code);
@@ -314,11 +306,11 @@ slk_wset(int index, const wchar_t *label, int justify)
 	if (index < 1 || 8 < index || justify < 0 || 2 < justify)
 		goto error1;
 
-	if (label == (wchar_t *) 0)
+	if (label == NULL)
 		label = M_MB_L("");
 
 	/* Copy the characters that fill the first 8 columns of the label. */
-	for (wp = wcs, width = 0; label != '\0'; label += i, wp += cc._n) {
+	for (wp = wcs, width = 0; *label != '\0'; label += i, wp += cc._n) {
 		if ((i = __m_wcs_cc(label, A_NORMAL, 0, &cc)) < 0)
 			goto error1;	
 
@@ -335,12 +327,12 @@ slk_wset(int index, const wchar_t *label, int justify)
 
 	/* Remember the new label. */
 	__m_screen->_slk._justify[index] = (short) justify;
-	if (__m_screen->_slk._labels[index] != (char *) 0)
+	if (__m_screen->_slk._labels[index] != NULL)
 		free(__m_screen->_slk._labels[index]);
-	if ((__m_screen->_slk._labels[index] = m_strdup(mbs)) == (char *) 0)
+	if ((__m_screen->_slk._labels[index] = m_strdup(mbs)) == NULL)
 		goto error1;
 	
-	if (__m_screen->_slk._w != (WINDOW *) 0) {
+	if (__m_screen->_slk._w != NULL) {
 		/* Write the justified label into the slk window. */
 		i = format[__m_slk_format][index];
 		(void) __m_cc_erase(__m_screen->_slk._w, 0, i, 0, i + 7);
@@ -357,19 +349,19 @@ slk_wset(int index, const wchar_t *label, int justify)
 		}
 
 		(void) mvwaddstr(__m_screen->_slk._w, 0, i, mbs);
-	} else if (plab_norm != (char *) 0) {
+	} else if (plab_norm != NULL) {
 		(void) tputs(
 			tparm(
 				plab_norm, (long) index, (long) mbs,
 				0L, 0L, 0L, 0L, 0L, 0L, 0L
 			), 1, __m_outc
 		);
-	} else if (pkey_plab != (char *) 0) {
+	} else if (pkey_plab != NULL) {
 		/* Lookup multibyte sequence for the function key. */
 		for (i = KEY_F(index), k = __m_keyindex; (*k)[1] != i; ++k)
 			;
 
-		if (cur_term->_str[**k] != (char *) 0) {
+		if (cur_term->_str[**k] != NULL) {
 			(void) tputs(
 				tparm(
 					pkey_plab, (long) index, 
@@ -384,4 +376,3 @@ slk_wset(int index, const wchar_t *label, int justify)
 error1:
 	return __m_return_code("slk_wset", code);
 }
-
diff --git a/usr/src/lib/libzfs/common/libzfs_dataset.c b/usr/src/lib/libzfs/common/libzfs_dataset.c
index 3a6d56add4..79df1aa994 100644
--- a/usr/src/lib/libzfs/common/libzfs_dataset.c
+++ b/usr/src/lib/libzfs/common/libzfs_dataset.c
@@ -21,7 +21,7 @@
 
 /*
  * Copyright (c) 2005, 2010, Oracle and/or its affiliates. All rights reserved.
- * Copyright (c) 2013, Joyent, Inc. All rights reserved.
+ * Copyright (c) 2018, Joyent, Inc. All rights reserved.
  * Copyright (c) 2011, 2016 by Delphix. All rights reserved.
  * Copyright (c) 2012 DEY Storage Systems, Inc.  All rights reserved.
  * Copyright (c) 2011-2012 Pawel Jakub Dawidek. All rights reserved.
@@ -1391,7 +1391,6 @@ badlabel:
 
 			switch (prop) {
 			case ZFS_PROP_RESERVATION:
-			case ZFS_PROP_REFRESERVATION:
 				if (intval > volsize) {
 					zfs_error_aux(hdl, dgettext(TEXT_DOMAIN,
 					    "'%s' is greater than current "
@@ -1402,6 +1401,17 @@ badlabel:
 				}
 				break;
 
+			case ZFS_PROP_REFRESERVATION:
+				if (intval > volsize && intval != UINT64_MAX) {
+					zfs_error_aux(hdl, dgettext(TEXT_DOMAIN,
+					    "'%s' is greater than current "
+					    "volume size"), propname);
+					(void) zfs_error(hdl, EZFS_BADPROP,
+					    errbuf);
+					goto error;
+				}
+				break;
+
 			case ZFS_PROP_VOLSIZE:
 				if (intval % blocksize != 0) {
 					zfs_nicenum(blocksize, buf,
@@ -1503,6 +1513,61 @@ zfs_add_synthetic_resv(zfs_handle_t *zhp, nvlist_t *nvl)
 	return (1);
 }
 
+/*
+ * Helper for 'zfs {set|clone} refreservation=auto'.  Must be called after
+ * zfs_valid_proplist(), as it is what sets the UINT64_MAX sentinal value.
+ * Return codes must match zfs_add_synthetic_resv().
+ */
+static int
+zfs_fix_auto_resv(zfs_handle_t *zhp, nvlist_t *nvl)
+{
+	uint64_t volsize;
+	uint64_t resvsize;
+	zfs_prop_t prop;
+	nvlist_t *props;
+
+	if (!ZFS_IS_VOLUME(zhp)) {
+		return (0);
+	}
+
+	if (zfs_which_resv_prop(zhp, &prop) != 0) {
+		return (-1);
+	}
+
+	if (prop != ZFS_PROP_REFRESERVATION) {
+		return (0);
+	}
+
+	if (nvlist_lookup_uint64(nvl, zfs_prop_to_name(prop), &resvsize) != 0) {
+		/* No value being set, so it can't be "auto" */
+		return (0);
+	}
+	if (resvsize != UINT64_MAX) {
+		/* Being set to a value other than "auto" */
+		return (0);
+	}
+
+	props = fnvlist_alloc();
+
+	fnvlist_add_uint64(props, zfs_prop_to_name(ZFS_PROP_VOLBLOCKSIZE),
+	    zfs_prop_get_int(zhp, ZFS_PROP_VOLBLOCKSIZE));
+
+	if (nvlist_lookup_uint64(nvl, zfs_prop_to_name(ZFS_PROP_VOLSIZE),
+	    &volsize) != 0) {
+		volsize = zfs_prop_get_int(zhp, ZFS_PROP_VOLSIZE);
+	}
+
+	resvsize = zvol_volsize_to_reservation(volsize, props);
+	fnvlist_free(props);
+
+	(void) nvlist_remove_all(nvl, zfs_prop_to_name(prop));
+	if (nvlist_add_uint64(nvl, zfs_prop_to_name(prop), resvsize) != 0) {
+		(void) no_memory(zhp->zfs_hdl);
+		return (-1);
+	}
+	return (1);
+}
+
 void
 zfs_setprop_error(libzfs_handle_t *hdl, zfs_prop_t prop, int err,
     char *errbuf)
@@ -1668,6 +1733,12 @@ zfs_prop_set_list(zfs_handle_t *zhp, nvlist_t *props)
 			goto error;
 		}
 	}
+
+	if (added_resv != 1 &&
+	    (added_resv = zfs_fix_auto_resv(zhp, nvl)) == -1) {
+		goto error;
+	}
+
 	/*
 	 * Check how many properties we're setting and allocate an array to
 	 * store changelist pointers for postfix().
@@ -3686,6 +3757,7 @@ zfs_clone(zfs_handle_t *zhp, const char *target, nvlist_t *props)
 
 	if (props) {
 		zfs_type_t type;
+
 		if (ZFS_IS_VOLUME(zhp)) {
 			type = ZFS_TYPE_VOLUME;
 		} else {
@@ -3694,6 +3766,10 @@ zfs_clone(zfs_handle_t *zhp, const char *target, nvlist_t *props)
 		if ((props = zfs_valid_proplist(hdl, type, props, zoned,
 		    zhp, zhp->zpool_hdl, errbuf)) == NULL)
 			return (-1);
+		if (zfs_fix_auto_resv(zhp, props) == -1) {
+			nvlist_free(props);
+			return (-1);
+		}
 	}
 
 	ret = lzc_clone(target, zhp->zfs_name, props);
diff --git a/usr/src/lib/libzfs/common/libzfs_util.c b/usr/src/lib/libzfs/common/libzfs_util.c
index ffaa9f984a..61f3127662 100644
--- a/usr/src/lib/libzfs/common/libzfs_util.c
+++ b/usr/src/lib/libzfs/common/libzfs_util.c
@@ -21,7 +21,7 @@
 
 /*
  * Copyright (c) 2005, 2010, Oracle and/or its affiliates. All rights reserved.
- * Copyright (c) 2013, Joyent, Inc. All rights reserved.
+ * Copyright (c) 2018 Joyent, Inc.
  * Copyright (c) 2011, 2017 by Delphix. All rights reserved.
  * Copyright 2016 Igor Kozhukhov <ikozhukhov@gmail.com>
  * Copyright (c) 2017 Datto Inc.
@@ -1224,6 +1224,7 @@ zprop_parse_value(libzfs_handle_t *hdl, nvpair_t *elem, int prop,
 	const char *propname;
 	char *value;
 	boolean_t isnone = B_FALSE;
+	boolean_t isauto = B_FALSE;
 
 	if (type == ZFS_TYPE_POOL) {
 		proptype = zpool_prop_get_type(prop);
@@ -1259,8 +1260,9 @@ zprop_parse_value(libzfs_handle_t *hdl, nvpair_t *elem, int prop,
 			(void) nvpair_value_string(elem, &value);
 			if (strcmp(value, "none") == 0) {
 				isnone = B_TRUE;
-			} else if (zfs_nicestrtonum(hdl, value, ivalp)
-			    != 0) {
+			} else if (strcmp(value, "auto") == 0) {
+				isauto = B_TRUE;
+			} else if (zfs_nicestrtonum(hdl, value, ivalp) != 0) {
 				goto error;
 			}
 		} else if (datatype == DATA_TYPE_UINT64) {
@@ -1290,6 +1292,31 @@ zprop_parse_value(libzfs_handle_t *hdl, nvpair_t *elem, int prop,
 		    prop == ZFS_PROP_SNAPSHOT_LIMIT)) {
 			*ivalp = UINT64_MAX;
 		}
+
+		/*
+		 * Special handling for setting 'refreservation' to 'auto'.  Use
+		 * UINT64_MAX to tell the caller to use zfs_fix_auto_resv().
+		 * 'auto' is only allowed on volumes.
+		 */
+		if (isauto) {
+			switch (prop) {
+			case ZFS_PROP_REFRESERVATION:
+				if ((type & ZFS_TYPE_VOLUME) == 0) {
+					zfs_error_aux(hdl, dgettext(TEXT_DOMAIN,
+					    "'%s=auto' only allowed on "
+					    "volumes"), nvpair_name(elem));
+					goto error;
+				}
+				*ivalp = UINT64_MAX;
+				break;
+			default:
+				zfs_error_aux(hdl, dgettext(TEXT_DOMAIN,
+				    "'auto' is invalid value for '%s'"),
+				    nvpair_name(elem));
+				goto error;
+			}
+		}
+
 		break;
 
 	case PROP_TYPE_INDEX:
diff --git a/usr/src/lib/libzpool/common/llib-lzpool b/usr/src/lib/libzpool/common/llib-lzpool
index 871facace3..7b58c21513 100644
--- a/usr/src/lib/libzpool/common/llib-lzpool
+++ b/usr/src/lib/libzpool/common/llib-lzpool
@@ -71,3 +71,4 @@ extern uint64_t zfs_deadman_synctime_ms;
 extern int metaslab_preload_limit;
 extern boolean_t zfs_compressed_arc_enabled;
 extern boolean_t zfs_abd_scatter_enabled;
+extern boolean_t zfs_force_some_double_word_sm_entries;
diff --git a/usr/src/lib/pam_modules/tsol_acct/tsol_acct.c b/usr/src/lib/pam_modules/tsol_acct/tsol_acct.c
index d9fabd9fc7..d4ef23c908 100644
--- a/usr/src/lib/pam_modules/tsol_acct/tsol_acct.c
+++ b/usr/src/lib/pam_modules/tsol_acct/tsol_acct.c
@@ -23,8 +23,6 @@
  * Use is subject to license terms.
  */
 
-#pragma ident	"%Z%%M%	%I%	%E% SMI"
-
 #include <libtsnet.h>
 #include <stdlib.h>
 #include <string.h>
@@ -89,9 +87,9 @@ pam_sm_acct_mgmt(pam_handle_t *pamh, int flags, int argc, const char **argv)
 		    "pam_tsol_account: allowed_unlabeled = %d, user %s, "
 		    "rhost %s",
 		    allow_unlabeled,
-		    (user == NULL) ? "NULL" : (user == '\0') ? "ZERO" :
+		    (user == NULL) ? "NULL" : (*user == '\0') ? "ZERO" :
 		    user,
-		    (rhost == NULL) ? "NULL" : (rhost == '\0') ? "ZERO" :
+		    (rhost == NULL) ? "NULL" : (*rhost == '\0') ? "ZERO" :
 		    rhost);
 	}
 	if (user == NULL || *user == '\0') {
diff --git a/usr/src/lib/smbsrv/Makefile b/usr/src/lib/smbsrv/Makefile
index 4213133a56..68353f10fe 100644
--- a/usr/src/lib/smbsrv/Makefile
+++ b/usr/src/lib/smbsrv/Makefile
@@ -29,14 +29,12 @@ include ../Makefile.lib
 SUBDIRS = \
 	libfksmbsrv \
 	libmlsvc \
-	libmlrpc \
 	libsmb \
 	libsmbns \
 	libsmbrp
 
 include ./Makefile.subdirs
 
-libmlrpc: libsmb
 libsmbns: libsmb
-libmlsvc: libsmb libmlrpc libsmbns
+libmlsvc: libsmb libsmbns
 libfksmbsrv: libsmb
diff --git a/usr/src/lib/smbsrv/Makefile.targ b/usr/src/lib/smbsrv/Makefile.targ
index 92a05ef243..9305212b3c 100644
--- a/usr/src/lib/smbsrv/Makefile.targ
+++ b/usr/src/lib/smbsrv/Makefile.targ
@@ -22,19 +22,22 @@
 # Copyright 2007 Sun Microsystems, Inc.  All rights reserved.
 # Use is subject to license terms.
 #
-#ident	"%Z%%M%	%I%	%E% SMI"
+# Copyright 2013 Nexenta Systems, Inc.  All rights reserved.
+#
 
 #
 # Common targets for smbsrv Makefiles
 #
 
 %_ndr.c: $(NDLDIR)/%.ndl
-	$(NDRGEN) -Y $(CC) $<
+	$(NDRGEN) -Y $(ANSI_CPP) $(CPPFLAGS) $<
 
 pics/%.o:	$(SRC)/common/smbsrv/%.c
 	$(COMPILE.c) -o $@ $<
 	$(POST_PROCESS_O)
 
+pics/%.o := CPPFLAGS += -I$(ROOTSMBHDRDIR)/ndl
+
 .KEEP_STATE:
 
 all: $(LIBS)
diff --git a/usr/src/lib/smbsrv/libmlrpc/Makefile b/usr/src/lib/smbsrv/libmlrpc/Makefile
deleted file mode 100644
index c5a61203cd..0000000000
--- a/usr/src/lib/smbsrv/libmlrpc/Makefile
+++ /dev/null
@@ -1,30 +0,0 @@
-#
-# CDDL HEADER START
-#
-# The contents of this file are subject to the terms of the
-# Common Development and Distribution License (the "License").
-# You may not use this file except in compliance with the License.
-#
-# You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
-# or http://www.opensolaris.org/os/licensing.
-# See the License for the specific language governing permissions
-# and limitations under the License.
-#
-# When distributing Covered Code, include this CDDL HEADER in each
-# file and include the License file at usr/src/OPENSOLARIS.LICENSE.
-# If applicable, add the following below this CDDL HEADER, with the
-# fields enclosed by brackets "[]" replaced with your own identifying
-# information: Portions Copyright [yyyy] [name of copyright owner]
-#
-# CDDL HEADER END
-#
-#
-# Copyright 2007 Sun Microsystems, Inc.  All rights reserved.
-# Use is subject to license terms.
-#
-# ident	"%Z%%M%	%I%	%E% SMI"
-#
-
-HDRS=	libmlrpc.h
-
-include ../Makefile.smbsrv
diff --git a/usr/src/lib/smbsrv/libmlsvc/common/dssetup_clnt.c b/usr/src/lib/smbsrv/libmlsvc/common/dssetup_clnt.c
index 02b57b9328..f77c0bdf01 100644
--- a/usr/src/lib/smbsrv/libmlsvc/common/dssetup_clnt.c
+++ b/usr/src/lib/smbsrv/libmlsvc/common/dssetup_clnt.c
@@ -29,7 +29,7 @@
 
 #include <string.h>
 #include <strings.h>
-#include <smbsrv/wintypes.h>
+#include <smb/wintypes.h>
 #include <smbsrv/libsmb.h>
 #include <smbsrv/ndl/dssetup.ndl>
 #include <smbsrv/libmlsvc.h>
diff --git a/usr/src/lib/smbsrv/libmlsvc/common/dssetup_svc.c b/usr/src/lib/smbsrv/libmlsvc/common/dssetup_svc.c
index 07986c2c93..24b999e7c3 100644
--- a/usr/src/lib/smbsrv/libmlsvc/common/dssetup_svc.c
+++ b/usr/src/lib/smbsrv/libmlsvc/common/dssetup_svc.c
@@ -21,6 +21,7 @@
 
 /*
  * Copyright (c) 2008, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright 2013 Nexenta Systems, Inc.  All rights reserved.
  */
 
 /*
@@ -32,8 +33,8 @@
 #include <stdlib.h>
 #include <netdb.h>
 
+#include <libmlrpc/libmlrpc.h>
 #include <smbsrv/libsmb.h>
-#include <smbsrv/libmlrpc.h>
 #include <smbsrv/libmlsvc.h>
 #include <smbsrv/ndl/dssetup.ndl>
 #include <smbsrv/smbinfo.h>
diff --git a/usr/src/lib/smbsrv/libmlsvc/common/eventlog_svc.c b/usr/src/lib/smbsrv/libmlsvc/common/eventlog_svc.c
index 34438c6cae..35f9c856e9 100644
--- a/usr/src/lib/smbsrv/libmlsvc/common/eventlog_svc.c
+++ b/usr/src/lib/smbsrv/libmlsvc/common/eventlog_svc.c
@@ -21,6 +21,7 @@
 
 /*
  * Copyright (c) 2009, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright 2013 Nexenta Systems, Inc.  All rights reserved.
  */
 
 /*
@@ -29,8 +30,8 @@
 #include <sys/utsname.h>
 #include <unistd.h>
 #include <strings.h>
+#include <libmlrpc/libmlrpc.h>
 #include <smbsrv/libsmb.h>
-#include <smbsrv/libmlrpc.h>
 #include <smbsrv/nmpipes.h>
 #include <smbsrv/libmlsvc.h>
 #include <smbsrv/ndl/eventlog.ndl>
diff --git a/usr/src/lib/smbsrv/libmlsvc/common/libmlsvc.h b/usr/src/lib/smbsrv/libmlsvc/common/libmlsvc.h
index 381a2ea98c..838353b8e9 100644
--- a/usr/src/lib/smbsrv/libmlsvc/common/libmlsvc.h
+++ b/usr/src/lib/smbsrv/libmlsvc/common/libmlsvc.h
@@ -26,17 +26,22 @@
 #ifndef	_LIBMLSVC_H
 #define	_LIBMLSVC_H
 
-#include <uuid/uuid.h>
 #include <sys/param.h>
 #include <sys/types.h>
 #include <sys/uio.h>
 #include <sys/ksynch.h>
+#include <uuid/uuid.h>
+
 #include <time.h>
 #include <stdio.h>
 #include <string.h>
+#include <syslog.h>
 #include <netdb.h>
 #include <libuutil.h>
-#include <smbsrv/wintypes.h>
+
+#include <smb/wintypes.h>
+#include <libmlrpc/libmlrpc.h>
+
 #include <smbsrv/hash_table.h>
 #include <smbsrv/smb_token.h>
 #include <smbsrv/smb_privilege.h>
@@ -44,8 +49,6 @@
 #include <smbsrv/smb_xdr.h>
 #include <smbsrv/smb_dfs.h>
 #include <smbsrv/libsmb.h>
-#include <smbsrv/libmlrpc.h>
-#include <smbsrv/ndl/lsarpc.ndl>
 
 #ifdef	__cplusplus
 extern "C" {
@@ -127,24 +130,6 @@ typedef struct ms_luid {
 	uint32_t high_part;
 } ms_luid_t;
 
-/*
- * Information about a server as reported by NetServerGetInfo.
- * The SV_PLATFORM and SV_TYPE definitions are in srvsvc.ndl.
- */
-typedef struct srvsvc_server_info {
-	uint32_t	sv_platform_id;
-	char		*sv_name;
-	uint32_t	sv_version_major;
-	uint32_t	sv_version_minor;
-	uint32_t	sv_type;
-	char		*sv_comment;
-	uint32_t	sv_os;
-} srvsvc_server_info_t;
-
-int srvsvc_net_server_getinfo(char *, char *, srvsvc_server_info_t *);
-int srvsvc_net_remote_tod(char *, char *, struct timeval *, struct tm *);
-
-
 /*
  * A client_t is created while binding a client connection to hold the
  * context for calls made using that connection.
@@ -153,29 +138,23 @@ int srvsvc_net_remote_tod(char *, char *, struct timeval *, struct tm *);
  * ensure that each handle has a pointer to the client_t.  When the top
  * level (bind) handle is released, we close the connection.
  */
-typedef struct mlsvc_handle {
-	ndr_hdid_t			handle;
-	ndr_client_t			*clnt;
-	srvsvc_server_info_t		svinfo;
-} mlsvc_handle_t;
+typedef struct mlrpc_handle mlsvc_handle_t;
 
+/* mlsvc_client.c */
 void ndr_rpc_init(void);
 void ndr_rpc_fini(void);
 uint32_t ndr_rpc_bind(mlsvc_handle_t *, char *, char *, char *, const char *);
 void ndr_rpc_unbind(mlsvc_handle_t *);
-int ndr_rpc_call(mlsvc_handle_t *, int, void *);
-void ndr_rpc_set_nonull(mlsvc_handle_t *);
-const srvsvc_server_info_t *ndr_rpc_server_info(mlsvc_handle_t *);
-uint32_t ndr_rpc_server_os(mlsvc_handle_t *);
-int ndr_rpc_get_ssnkey(mlsvc_handle_t *, unsigned char *, size_t);
-void *ndr_rpc_malloc(mlsvc_handle_t *, size_t);
-ndr_heap_t *ndr_rpc_get_heap(mlsvc_handle_t *);
-void ndr_rpc_release(mlsvc_handle_t *);
-boolean_t ndr_is_null_handle(mlsvc_handle_t *);
-boolean_t ndr_is_bind_handle(mlsvc_handle_t *);
-void ndr_inherit_handle(mlsvc_handle_t *, mlsvc_handle_t *);
 void ndr_rpc_status(mlsvc_handle_t *, int, uint32_t);
 
+/* These three get info about the connected client. */
+boolean_t ndr_is_admin(ndr_xa_t *);
+boolean_t ndr_is_poweruser(ndr_xa_t *);
+int32_t ndr_native_os(ndr_xa_t *);
+
+/* SRVSVC */
+int srvsvc_net_remote_tod(char *, char *, struct timeval *, struct tm *);
+
 /* SVCCTL service */
 /*
  * Calculate the wide-char equivalent string length required to
diff --git a/usr/src/lib/smbsrv/libmlsvc/common/lsar_clnt.c b/usr/src/lib/smbsrv/libmlsvc/common/lsar_clnt.c
index eeab7745f2..7524e2db55 100644
--- a/usr/src/lib/smbsrv/libmlsvc/common/lsar_clnt.c
+++ b/usr/src/lib/smbsrv/libmlsvc/common/lsar_clnt.c
@@ -383,7 +383,6 @@ lsar_lookup_names(mlsvc_handle_t *lsa_handle, char *name, smb_account_t *info)
 		lsar_lookup_names1
 	};
 
-	const srvsvc_server_info_t	*svinfo;
 	lsa_names_t	names;
 	char		*p;
 	uint32_t	length;
@@ -396,20 +395,15 @@ lsar_lookup_names(mlsvc_handle_t *lsa_handle, char *name, smb_account_t *info)
 
 	bzero(info, sizeof (smb_account_t));
 
-	svinfo = ndr_rpc_server_info(lsa_handle);
-	if (svinfo->sv_os == NATIVE_OS_WIN2000 &&
-	    svinfo->sv_version_major == 5 && svinfo->sv_version_minor == 0) {
-		/*
-		 * Windows 2000 doesn't like an LSA lookup for
-		 * DOMAIN\Administrator.
-		 */
-		if ((p = strchr(name, '\\')) != 0) {
-			++p;
-
-			if (strcasecmp(p, "administrator") == 0)
-				name = p;
-		}
+	/*
+	 * Windows 2000 (or later) doesn't like an LSA lookup for
+	 * DOMAIN\Administrator.
+	 */
+	if ((p = strchr(name, '\\')) != 0) {
+		++p;
 
+		if (strcasecmp(p, "administrator") == 0)
+			name = p;
 	}
 
 	length = smb_wcequiv_strlen(name);
@@ -418,17 +412,12 @@ lsar_lookup_names(mlsvc_handle_t *lsa_handle, char *name, smb_account_t *info)
 	names.name[0].str = (unsigned char *)name;
 	names.n_entry = 1;
 
-	if (ndr_rpc_server_os(lsa_handle) == NATIVE_OS_WIN2000) {
-		for (i = 0; i < n_op; ++i) {
-			ndr_rpc_set_nonull(lsa_handle);
-			status = (*ops[i])(lsa_handle, &names, info);
-
-			if (status != NT_STATUS_INVALID_PARAMETER)
-				break;
-		}
-	} else {
+	for (i = 0; i < n_op; ++i) {
 		ndr_rpc_set_nonull(lsa_handle);
-		status = lsar_lookup_names1(lsa_handle, &names, info);
+		status = (*ops[i])(lsa_handle, &names, info);
+
+		if (status != NT_STATUS_INVALID_PARAMETER)
+			break;
 	}
 
 	if (status == NT_STATUS_SUCCESS) {
@@ -726,10 +715,8 @@ lsar_lookup_sids(mlsvc_handle_t *lsa_handle, smb_sid_t *sid,
 	smb_sid_tostr(sid, sidbuf);
 	smb_tracef("%s", sidbuf);
 
-	if (ndr_rpc_server_os(lsa_handle) == NATIVE_OS_WIN2000)
-		status = lsar_lookup_sids2(lsa_handle, (lsa_sid_t *)sid,
-		    account);
-	else
+	status = lsar_lookup_sids2(lsa_handle, (lsa_sid_t *)sid, account);
+	if (status == RPC_NT_PROCNUM_OUT_OF_RANGE)
 		status = lsar_lookup_sids1(lsa_handle, (lsa_sid_t *)sid,
 		    account);
 
@@ -1167,8 +1154,7 @@ lsar_lookup_priv_value(mlsvc_handle_t *lsa_handle, char *name,
 	(void) memcpy(&arg.handle, lsa_handle, sizeof (mslsa_handle_t));
 
 	length = smb_wcequiv_strlen(name);
-	if (ndr_rpc_server_os(lsa_handle) == NATIVE_OS_WIN2000)
-		length += sizeof (smb_wchar_t);
+	length += sizeof (smb_wchar_t);
 
 	arg.name.length = length;
 	arg.name.allosize = length;
diff --git a/usr/src/lib/smbsrv/libmlsvc/common/lsar_svc.c b/usr/src/lib/smbsrv/libmlsvc/common/lsar_svc.c
index 3864260e2c..28d5e73948 100644
--- a/usr/src/lib/smbsrv/libmlsvc/common/lsar_svc.c
+++ b/usr/src/lib/smbsrv/libmlsvc/common/lsar_svc.c
@@ -33,8 +33,8 @@
 #include <pwd.h>
 #include <grp.h>
 
+#include <libmlrpc/libmlrpc.h>
 #include <smbsrv/libsmb.h>
-#include <smbsrv/libmlrpc.h>
 #include <smbsrv/libmlsvc.h>
 #include <smbsrv/ndl/lsarpc.ndl>
 #include <lsalib.h>
diff --git a/usr/src/lib/smbsrv/libmlsvc/common/mlsvc.h b/usr/src/lib/smbsrv/libmlsvc/common/mlsvc.h
index dcf2c5f0e7..2afc62a02d 100644
--- a/usr/src/lib/smbsrv/libmlsvc/common/mlsvc.h
+++ b/usr/src/lib/smbsrv/libmlsvc/common/mlsvc.h
@@ -46,7 +46,6 @@ void netr_initialize(void);
 void samr_initialize(void);
 void svcctl_initialize(void);
 void winreg_initialize(void);
-int srvsvc_gettime(unsigned long *);
 void msgsvcsend_initialize(void);
 void spoolss_initialize(void);
 void netdfs_initialize(void);
@@ -64,7 +63,8 @@ int netr_setup_authenticator(struct netr_info *, struct netr_authenticator *,
     struct netr_authenticator *);
 DWORD netr_validate_chain(struct netr_info *, struct netr_authenticator *);
 
-void ndr_srvsvc_timecheck(char *, char *);
+int srvsvc_gettime(unsigned long *);
+void srvsvc_timecheck(char *, char *);
 
 /* Generic functions to get/set windows Security Descriptors */
 uint32_t srvsvc_sd_get(smb_share_t *, uint8_t *, uint32_t *);
diff --git a/usr/src/lib/smbsrv/libmlsvc/common/mlsvc_client.c b/usr/src/lib/smbsrv/libmlsvc/common/mlsvc_client.c
index ef3ca34bcd..c8879837b1 100644
--- a/usr/src/lib/smbsrv/libmlsvc/common/mlsvc_client.c
+++ b/usr/src/lib/smbsrv/libmlsvc/common/mlsvc_client.c
@@ -31,32 +31,22 @@
 #include <sys/types.h>
 #include <sys/errno.h>
 #include <sys/fcntl.h>
-#include <sys/tzfile.h>
 #include <time.h>
 #include <strings.h>
 #include <assert.h>
 #include <errno.h>
 #include <thread.h>
-#include <unistd.h>
 #include <syslog.h>
 #include <synch.h>
 
+#include <libmlrpc/libmlrpc.h>
 #include <netsmb/smbfs_api.h>
+
 #include <smbsrv/libsmb.h>
-#include <smbsrv/libsmbns.h>
-#include <smbsrv/libmlrpc.h>
 #include <smbsrv/libmlsvc.h>
-#include <smbsrv/ndl/srvsvc.ndl>
 #include <libsmbrdr.h>
 #include <mlsvc.h>
 
-static int ndr_xa_init(ndr_client_t *, ndr_xa_t *);
-static int ndr_xa_exchange(ndr_client_t *, ndr_xa_t *);
-static int ndr_xa_read(ndr_client_t *, ndr_xa_t *);
-static void ndr_xa_preserve(ndr_client_t *, ndr_xa_t *);
-static void ndr_xa_destruct(ndr_client_t *, ndr_xa_t *);
-static void ndr_xa_release(ndr_client_t *);
-
 
 /*
  * This call must be made to initialize an RPC client structure and bind
@@ -71,13 +61,15 @@ static void ndr_xa_release(ndr_client_t *);
  * unbind and teardown the connection.  As each handle is initialized it
  * will inherit a reference to the client context.
  *
- * Returns 0 or an NT_STATUS:
+ * Returns 0 or an NT_STATUS:		(failed in...)
+ *
  *	NT_STATUS_BAD_NETWORK_PATH	(get server addr)
  *	NT_STATUS_NETWORK_ACCESS_DENIED	(connect, auth)
- *	NT_STATUS_BAD_NETWORK_NAME	(tcon, open)
+ *	NT_STATUS_BAD_NETWORK_NAME	(tcon)
+ *	RPC_NT_SERVER_TOO_BUSY		(open pipe)
+ *	RPC_NT_SERVER_UNAVAILABLE	(open pipe)
  *	NT_STATUS_ACCESS_DENIED		(open pipe)
  *	NT_STATUS_INVALID_PARAMETER	(rpc bind)
- *
  *	NT_STATUS_INTERNAL_ERROR	(bad args etc)
  *	NT_STATUS_NO_MEMORY
  */
@@ -86,11 +78,8 @@ ndr_rpc_bind(mlsvc_handle_t *handle, char *server, char *domain,
     char *username, const char *service)
 {
 	struct smb_ctx		*ctx = NULL;
-	ndr_client_t		*clnt = NULL;
 	ndr_service_t		*svc;
-	srvsvc_server_info_t	svinfo;
 	DWORD			status;
-	int			fd = -1;
 	int			rc;
 
 	if (handle == NULL || server == NULL || server[0] == '\0' ||
@@ -101,19 +90,6 @@ ndr_rpc_bind(mlsvc_handle_t *handle, char *server, char *domain,
 	if ((svc = ndr_svc_lookup_name(service)) == NULL)
 		return (NT_STATUS_INTERNAL_ERROR);
 
-	/*
-	 * Set the default based on the assumption that most
-	 * servers will be Windows 2000 or later.  This used to
-	 * try to get the actual server version, but that RPC
-	 * is not necessarily allowed anymore, so don't bother.
-	 */
-	bzero(&svinfo, sizeof (srvsvc_server_info_t));
-	svinfo.sv_platform_id = SV_PLATFORM_ID_NT;
-	svinfo.sv_version_major = 5;
-	svinfo.sv_version_minor = 0;
-	svinfo.sv_type = SV_TYPE_DEFAULT;
-	svinfo.sv_os = NATIVE_OS_WIN2000;
-
 	/*
 	 * Some callers pass this when they want a NULL session.
 	 * Todo: have callers pass an empty string for that.
@@ -136,296 +112,82 @@ ndr_rpc_bind(mlsvc_handle_t *handle, char *server, char *domain,
 		    "(Srv=%s Dom=%s User=%s), %s (0x%x)",
 		    server, domain, username,
 		    xlate_nt_status(status), status);
-		/* Tell the DC Locator this DC failed. */
-		smb_ddiscover_bad_dc(server);
-		goto errout;
-	}
-
-	/*
-	 * Open the named pipe.
-	 */
-	fd = smb_fh_open(ctx, svc->endpoint, O_RDWR);
-	if (fd < 0) {
-		rc = errno;
-		syslog(LOG_DEBUG, "ndr_rpc_bind: "
-		    "smb_fh_open (%s) err=%d",
-		    svc->endpoint, rc);
-		switch (rc) {
-		case EACCES:
-			status = NT_STATUS_ACCESS_DENIED;
-			break;
+		/*
+		 * If the error is one where changing to a new DC
+		 * might help, try looking for a different DC.
+		 */
+		switch (status) {
+		case NT_STATUS_BAD_NETWORK_PATH:
+		case NT_STATUS_BAD_NETWORK_NAME:
+			/* Look for a new DC */
+			smb_ddiscover_bad_dc(server);
 		default:
-			status = NT_STATUS_BAD_NETWORK_NAME;
 			break;
 		}
-		goto errout;
+		return (status);
 	}
 
 	/*
 	 * Setup the RPC client handle.
 	 */
-	if ((clnt = malloc(sizeof (ndr_client_t))) == NULL) {
-		status = NT_STATUS_NO_MEMORY;
-		goto errout;
-	}
-	bzero(clnt, sizeof (ndr_client_t));
-
-	clnt->handle = &handle->handle;
-	clnt->xa_init = ndr_xa_init;
-	clnt->xa_exchange = ndr_xa_exchange;
-	clnt->xa_read = ndr_xa_read;
-	clnt->xa_preserve = ndr_xa_preserve;
-	clnt->xa_destruct = ndr_xa_destruct;
-	clnt->xa_release = ndr_xa_release;
-	clnt->xa_private = ctx;
-	clnt->xa_fd = fd;
-
-	ndr_svc_binding_pool_init(&clnt->binding_list,
-	    clnt->binding_pool, NDR_N_BINDING_POOL);
-
-	if ((clnt->heap = ndr_heap_create()) == NULL) {
-		status = NT_STATUS_NO_MEMORY;
-		goto errout;
+	rc = mlrpc_clh_create(handle, ctx);
+	if (rc != 0) {
+		syslog(LOG_ERR, "ndr_rpc_bind: mlrpc_clh_create: rc=%d", rc);
+		smbrdr_ctx_free(ctx);
+		switch (rc) {
+		case ENOMEM:
+			return (NT_STATUS_NO_MEMORY);
+		case EINVAL:
+			return (NT_STATUS_INVALID_PARAMETER);
+		default:
+			return (NT_STATUS_INTERNAL_ERROR);
+		}
 	}
 
 	/*
-	 * Fill in the caller's handle.
+	 * This does the pipe open and OtW RPC bind.
+	 * Handles pipe open retries.
 	 */
-	bzero(&handle->handle, sizeof (ndr_hdid_t));
-	handle->clnt = clnt;
-	bcopy(&svinfo, &handle->svinfo, sizeof (srvsvc_server_info_t));
-
-	/*
-	 * Do the OtW RPC bind.
-	 */
-	rc = ndr_clnt_bind(clnt, service, &clnt->binding);
-	switch (rc) {
-	case NDR_DRC_FAULT_OUT_OF_MEMORY:
-		status = NT_STATUS_NO_MEMORY;
-		break;
-	case NDR_DRC_FAULT_API_SERVICE_INVALID:	/* not registered */
-		status = NT_STATUS_INTERNAL_ERROR;
-		break;
-	default:
-		if (NDR_DRC_IS_FAULT(rc)) {
-			status = NT_STATUS_INVALID_PARAMETER;
+	status = mlrpc_clh_bind(handle, svc);
+	if (status != 0) {
+		syslog(LOG_DEBUG, "ndr_rpc_bind: "
+		    "mlrpc_clh_bind, %s (0x%x)",
+		    xlate_nt_status(status), status);
+		switch (status) {
+		case RPC_NT_SERVER_TOO_BUSY:
+			/* Look for a new DC */
+			smb_ddiscover_bad_dc(server);
+			break;
+		default:
 			break;
 		}
-		/* FALLTHROUGH */
-	case NDR_DRC_OK:
-		return (NT_STATUS_SUCCESS);
-	}
-
-	syslog(LOG_DEBUG, "ndr_rpc_bind: "
-	    "ndr_clnt_bind, %s (0x%x)",
-	    xlate_nt_status(status), status);
-
-errout:
-	handle->clnt = NULL;
-	if (clnt != NULL) {
-		ndr_heap_destroy(clnt->heap);
-		free(clnt);
-	}
-	if (ctx != NULL) {
-		if (fd != -1)
-			(void) smb_fh_close(fd);
-		smbrdr_ctx_free(ctx);
+		ctx = mlrpc_clh_free(handle);
+		if (ctx != NULL) {
+			smbrdr_ctx_free(ctx);
+		}
 	}
 
 	return (status);
 }
 
 /*
- * Unbind and close the pipe to an RPC service.
- *
- * If the heap has been preserved we need to go through an xa release.
- * The heap is preserved during an RPC call because that's where data
- * returned from the server is stored.
+ * Unbind and close the pipe to an RPC service
+ * and cleanup the smb_ctx.
  *
- * Otherwise we destroy the heap directly.
+ * The heap may or may not be destroyed (see mlrpc_clh_free)
  */
 void
 ndr_rpc_unbind(mlsvc_handle_t *handle)
 {
-	ndr_client_t *clnt = handle->clnt;
-	struct smb_ctx *ctx = clnt->xa_private;
+	struct smb_ctx *ctx;
 
-	if (clnt->heap_preserved)
-		ndr_clnt_free_heap(clnt);
-	else
-		ndr_heap_destroy(clnt->heap);
+	ctx = mlrpc_clh_free(handle);
+	if (ctx != NULL)
+		smbrdr_ctx_free(ctx);
 
-	(void) smb_fh_close(clnt->xa_fd);
-	smbrdr_ctx_free(ctx);
-	free(clnt);
 	bzero(handle, sizeof (mlsvc_handle_t));
 }
 
-/*
- * Call the RPC function identified by opnum.  The remote service is
- * identified by the handle, which should have been initialized by
- * ndr_rpc_bind.
- *
- * If the RPC call is successful (returns 0), the caller must call
- * ndr_rpc_release to release the heap.  Otherwise, we release the
- * heap here.
- */
-int
-ndr_rpc_call(mlsvc_handle_t *handle, int opnum, void *params)
-{
-	ndr_client_t *clnt = handle->clnt;
-	int rc;
-
-	if (ndr_rpc_get_heap(handle) == NULL)
-		return (-1);
-
-	rc = ndr_clnt_call(clnt->binding, opnum, params);
-
-	/*
-	 * Always clear the nonull flag to ensure
-	 * it is not applied to subsequent calls.
-	 */
-	clnt->nonull = B_FALSE;
-
-	if (NDR_DRC_IS_FAULT(rc)) {
-		ndr_rpc_release(handle);
-		return (-1);
-	}
-
-	return (0);
-}
-
-/*
- * Outgoing strings should not be null terminated.
- */
-void
-ndr_rpc_set_nonull(mlsvc_handle_t *handle)
-{
-	handle->clnt->nonull = B_TRUE;
-}
-
-/*
- * Return a reference to the server info.
- */
-const srvsvc_server_info_t *
-ndr_rpc_server_info(mlsvc_handle_t *handle)
-{
-	return (&handle->svinfo);
-}
-
-/*
- * Return the RPC server OS level.
- */
-uint32_t
-ndr_rpc_server_os(mlsvc_handle_t *handle)
-{
-	return (handle->svinfo.sv_os);
-}
-
-/*
- * Get the session key from a bound RPC client handle.
- *
- * The key returned is the 16-byte "user session key"
- * established by the underlying authentication protocol
- * (either Kerberos or NTLM).  This key is needed for
- * SAM RPC calls such as SamrSetInformationUser, etc.
- * See [MS-SAMR] sections: 2.2.3.3, 2.2.7.21, 2.2.7.25.
- *
- * Returns zero (success) or an errno.
- */
-int
-ndr_rpc_get_ssnkey(mlsvc_handle_t *handle,
-	unsigned char *ssn_key, size_t len)
-{
-	ndr_client_t *clnt = handle->clnt;
-	int rc;
-
-	if (clnt == NULL)
-		return (EINVAL);
-
-	rc = smb_fh_getssnkey(clnt->xa_fd, ssn_key, len);
-	return (rc);
-}
-
-void *
-ndr_rpc_malloc(mlsvc_handle_t *handle, size_t size)
-{
-	ndr_heap_t *heap;
-
-	if ((heap = ndr_rpc_get_heap(handle)) == NULL)
-		return (NULL);
-
-	return (ndr_heap_malloc(heap, size));
-}
-
-ndr_heap_t *
-ndr_rpc_get_heap(mlsvc_handle_t *handle)
-{
-	ndr_client_t *clnt = handle->clnt;
-
-	if (clnt->heap == NULL)
-		clnt->heap = ndr_heap_create();
-
-	return (clnt->heap);
-}
-
-/*
- * Must be called by RPC clients to free the heap after a successful RPC
- * call, i.e. ndr_rpc_call returned 0.  The caller should take a copy
- * of any data returned by the RPC prior to calling this function because
- * returned data is in the heap.
- */
-void
-ndr_rpc_release(mlsvc_handle_t *handle)
-{
-	ndr_client_t *clnt = handle->clnt;
-
-	if (clnt->heap_preserved)
-		ndr_clnt_free_heap(clnt);
-	else
-		ndr_heap_destroy(clnt->heap);
-
-	clnt->heap = NULL;
-}
-
-/*
- * Returns true if the handle is null.
- * Otherwise returns false.
- */
-boolean_t
-ndr_is_null_handle(mlsvc_handle_t *handle)
-{
-	static ndr_hdid_t zero_handle;
-
-	if (handle == NULL || handle->clnt == NULL)
-		return (B_TRUE);
-
-	if (!memcmp(&handle->handle, &zero_handle, sizeof (ndr_hdid_t)))
-		return (B_TRUE);
-
-	return (B_FALSE);
-}
-
-/*
- * Returns true if the handle is the top level bind handle.
- * Otherwise returns false.
- */
-boolean_t
-ndr_is_bind_handle(mlsvc_handle_t *handle)
-{
-	return (handle->clnt->handle == &handle->handle);
-}
-
-/*
- * Pass the client reference from parent to child.
- */
-void
-ndr_inherit_handle(mlsvc_handle_t *child, mlsvc_handle_t *parent)
-{
-	child->clnt = parent->clnt;
-	bcopy(&parent->svinfo, &child->svinfo, sizeof (srvsvc_server_info_t));
-}
-
 void
 ndr_rpc_status(mlsvc_handle_t *handle, int opnum, DWORD status)
 {
@@ -456,193 +218,3 @@ ndr_rpc_status(mlsvc_handle_t *handle, int opnum, DWORD status)
 	smb_tracef("%s[0x%02x]: %s: %s (0x%08x)",
 	    name, opnum, s, xlate_nt_status(status), status);
 }
-
-/*
- * The following functions provide the client callback interface.
- * If the caller hasn't provided a heap, create one here.
- */
-static int
-ndr_xa_init(ndr_client_t *clnt, ndr_xa_t *mxa)
-{
-	ndr_stream_t	*recv_nds = &mxa->recv_nds;
-	ndr_stream_t	*send_nds = &mxa->send_nds;
-	ndr_heap_t	*heap = clnt->heap;
-	int		rc;
-
-	if (heap == NULL) {
-		if ((heap = ndr_heap_create()) == NULL)
-			return (-1);
-
-		clnt->heap = heap;
-	}
-
-	mxa->heap = heap;
-
-	rc = nds_initialize(send_nds, 0, NDR_MODE_CALL_SEND, heap);
-	if (rc == 0)
-		rc = nds_initialize(recv_nds, NDR_PDU_SIZE_HINT_DEFAULT,
-		    NDR_MODE_RETURN_RECV, heap);
-
-	if (rc != 0) {
-		nds_destruct(&mxa->recv_nds);
-		nds_destruct(&mxa->send_nds);
-		ndr_heap_destroy(mxa->heap);
-		mxa->heap = NULL;
-		clnt->heap = NULL;
-		return (-1);
-	}
-
-	if (clnt->nonull)
-		NDS_SETF(send_nds, NDS_F_NONULL);
-
-	return (0);
-}
-
-/*
- * This is the entry pointy for an RPC client call exchange with
- * a server, which will result in an smbrdr SmbTransact request.
- *
- * SmbTransact should return the number of bytes received, which
- * we record as the PDU size, or a negative error code.
- */
-static int
-ndr_xa_exchange(ndr_client_t *clnt, ndr_xa_t *mxa)
-{
-	ndr_stream_t *recv_nds = &mxa->recv_nds;
-	ndr_stream_t *send_nds = &mxa->send_nds;
-	int err, more, nbytes;
-
-	nbytes = recv_nds->pdu_max_size;
-	err = smb_fh_xactnp(clnt->xa_fd,
-	    send_nds->pdu_size, (char *)send_nds->pdu_base_offset,
-	    &nbytes, (char *)recv_nds->pdu_base_offset, &more);
-	if (err) {
-		recv_nds->pdu_size = 0;
-		return (-1);
-	}
-
-	recv_nds->pdu_size = nbytes;
-	return (0);
-}
-
-/*
- * This entry point will be invoked if the xa-exchange response contained
- * only the first fragment of a multi-fragment response.  The RPC client
- * code will then make repeated xa-read requests to obtain the remaining
- * fragments, which will result in smbrdr SmbReadX requests.
- *
- * SmbReadX should return the number of bytes received, in which case we
- * expand the PDU size to include the received data, or a negative error
- * code.
- */
-static int
-ndr_xa_read(ndr_client_t *clnt, ndr_xa_t *mxa)
-{
-	ndr_stream_t *nds = &mxa->recv_nds;
-	int len;
-	int nbytes;
-
-	if ((len = (nds->pdu_max_size - nds->pdu_size)) < 0)
-		return (-1);
-
-	nbytes = smb_fh_read(clnt->xa_fd, 0, len,
-	    (char *)nds->pdu_base_offset + nds->pdu_size);
-
-	if (nbytes < 0)
-		return (-1);
-
-	nds->pdu_size += nbytes;
-
-	if (nds->pdu_size > nds->pdu_max_size) {
-		nds->pdu_size = nds->pdu_max_size;
-		return (-1);
-	}
-
-	return (nbytes);
-}
-
-/*
- * Preserve the heap so that the client application has access to data
- * returned from the server after an RPC call.
- */
-static void
-ndr_xa_preserve(ndr_client_t *clnt, ndr_xa_t *mxa)
-{
-	assert(clnt->heap == mxa->heap);
-
-	clnt->heap_preserved = B_TRUE;
-	mxa->heap = NULL;
-}
-
-/*
- * Dispose of the transaction streams.  If the heap has not been
- * preserved, we can destroy it here.
- */
-static void
-ndr_xa_destruct(ndr_client_t *clnt, ndr_xa_t *mxa)
-{
-	nds_destruct(&mxa->recv_nds);
-	nds_destruct(&mxa->send_nds);
-
-	if (!clnt->heap_preserved) {
-		ndr_heap_destroy(mxa->heap);
-		mxa->heap = NULL;
-		clnt->heap = NULL;
-	}
-}
-
-/*
- * Dispose of a preserved heap.
- */
-static void
-ndr_xa_release(ndr_client_t *clnt)
-{
-	if (clnt->heap_preserved) {
-		ndr_heap_destroy(clnt->heap);
-		clnt->heap = NULL;
-		clnt->heap_preserved = B_FALSE;
-	}
-}
-
-
-/*
- * Compare the time here with the remote time on the server
- * and report clock skew.
- */
-void
-ndr_srvsvc_timecheck(char *server, char *domain)
-{
-	char			hostname[MAXHOSTNAMELEN];
-	struct timeval		dc_tv;
-	struct tm		dc_tm;
-	struct tm		*tm;
-	time_t			tnow;
-	time_t			tdiff;
-	int			priority;
-
-	if (srvsvc_net_remote_tod(server, domain, &dc_tv, &dc_tm) < 0) {
-		syslog(LOG_DEBUG, "srvsvc_net_remote_tod failed");
-		return;
-	}
-
-	tnow = time(NULL);
-
-	if (tnow > dc_tv.tv_sec)
-		tdiff = (tnow - dc_tv.tv_sec) / SECSPERMIN;
-	else
-		tdiff = (dc_tv.tv_sec - tnow) / SECSPERMIN;
-
-	if (tdiff != 0) {
-		(void) strlcpy(hostname, "localhost", MAXHOSTNAMELEN);
-		(void) gethostname(hostname, MAXHOSTNAMELEN);
-
-		priority = (tdiff > 2) ? LOG_NOTICE : LOG_DEBUG;
-		syslog(priority, "DC [%s] clock skew detected: %u minutes",
-		    server, tdiff);
-
-		tm = gmtime(&dc_tv.tv_sec);
-		syslog(priority, "%-8s  UTC: %s", server, asctime(tm));
-		tm = gmtime(&tnow);
-		syslog(priority, "%-8s  UTC: %s", hostname, asctime(tm));
-	}
-}
diff --git a/usr/src/lib/smbsrv/libmlsvc/common/mlsvc_init.c b/usr/src/lib/smbsrv/libmlsvc/common/mlsvc_init.c
index 794e6c9576..cdb6478f5b 100644
--- a/usr/src/lib/smbsrv/libmlsvc/common/mlsvc_init.c
+++ b/usr/src/lib/smbsrv/libmlsvc/common/mlsvc_init.c
@@ -111,7 +111,7 @@ mlsvc_timecheck(void *arg)
 		if (!smb_domain_getinfo(&di))
 			continue;
 
-		ndr_srvsvc_timecheck(di.d_dci.dc_name,
+		srvsvc_timecheck(di.d_dci.dc_name,
 		    di.d_primary.di_nbname);
 	}
 
diff --git a/usr/src/lib/smbsrv/libmlsvc/common/mlsvc_util.c b/usr/src/lib/smbsrv/libmlsvc/common/mlsvc_util.c
index ad3565699b..b46cf99f87 100644
--- a/usr/src/lib/smbsrv/libmlsvc/common/mlsvc_util.c
+++ b/usr/src/lib/smbsrv/libmlsvc/common/mlsvc_util.c
@@ -425,3 +425,43 @@ mlsvc_disconnect(const char *server)
 {
 	smbrdr_disconnect(server);
 }
+
+/*
+ * A few more helper functions for RPC services.
+ */
+
+/*
+ * Check whether or not the specified user has administrator privileges,
+ * i.e. is a member of Domain Admins or Administrators.
+ * Returns true if the user is an administrator, otherwise returns false.
+ */
+boolean_t
+ndr_is_admin(ndr_xa_t *xa)
+{
+	smb_netuserinfo_t *ctx = xa->pipe->np_user;
+
+	return (ctx->ui_flags & SMB_ATF_ADMIN);
+}
+
+/*
+ * Check whether or not the specified user has power-user privileges,
+ * i.e. is a member of Domain Admins, Administrators or Power Users.
+ * This is typically required for operations such as managing shares.
+ * Returns true if the user is a power user, otherwise returns false.
+ */
+boolean_t
+ndr_is_poweruser(ndr_xa_t *xa)
+{
+	smb_netuserinfo_t *ctx = xa->pipe->np_user;
+
+	return ((ctx->ui_flags & SMB_ATF_ADMIN) ||
+	    (ctx->ui_flags & SMB_ATF_POWERUSER));
+}
+
+int32_t
+ndr_native_os(ndr_xa_t *xa)
+{
+	smb_netuserinfo_t *ctx = xa->pipe->np_user;
+
+	return (ctx->ui_native_os);
+}
diff --git a/usr/src/lib/smbsrv/libmlsvc/common/msgsvc_svc.c b/usr/src/lib/smbsrv/libmlsvc/common/msgsvc_svc.c
index 78538e6291..b49a3946ad 100644
--- a/usr/src/lib/smbsrv/libmlsvc/common/msgsvc_svc.c
+++ b/usr/src/lib/smbsrv/libmlsvc/common/msgsvc_svc.c
@@ -21,6 +21,7 @@
 
 /*
  * Copyright (c) 2008, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright 2013 Nexenta Systems, Inc.  All rights reserved.
  */
 
 /*
@@ -30,8 +31,8 @@
 #include <syslog.h>
 #include <stdlib.h>
 
+#include <libmlrpc/libmlrpc.h>
 #include <smbsrv/libsmb.h>
-#include <smbsrv/libmlrpc.h>
 #include <smbsrv/libmlsvc.h>
 #include <smbsrv/ndl/msgsvc.ndl>
 #include <smbsrv/smbinfo.h>
diff --git a/usr/src/lib/smbsrv/libmlsvc/common/netr_auth.c b/usr/src/lib/smbsrv/libmlsvc/common/netr_auth.c
index ea31c935ed..2b22744304 100644
--- a/usr/src/lib/smbsrv/libmlsvc/common/netr_auth.c
+++ b/usr/src/lib/smbsrv/libmlsvc/common/netr_auth.c
@@ -191,6 +191,10 @@ netr_server_req_challenge(mlsvc_handle_t *netr_handle, netr_info_t *netr_info)
 	return (0);
 }
 
+uint32_t netr_server_auth2_flags =
+    NETR_NEGOTIATE_BASE_FLAGS |
+    NETR_NEGOTIATE_STRONGKEY_FLAG;
+
 /*
  * netr_server_authenticate2
  */
@@ -216,10 +220,9 @@ netr_server_authenticate2(mlsvc_handle_t *netr_handle, netr_info_t *netr_info)
 	arg.account_name = (unsigned char *)account_name;
 	arg.account_type = NETR_WKSTA_TRUST_ACCOUNT_TYPE;
 	arg.hostname = (unsigned char *)netr_info->hostname;
-	arg.negotiate_flags = NETR_NEGOTIATE_BASE_FLAGS;
+	arg.negotiate_flags = netr_server_auth2_flags;
 
-	if (ndr_rpc_server_os(netr_handle) == NATIVE_OS_WIN2000) {
-		arg.negotiate_flags |= NETR_NEGOTIATE_STRONGKEY_FLAG;
+	if (arg.negotiate_flags & NETR_NEGOTIATE_STRONGKEY_FLAG) {
 		if (netr_gen_skey128(netr_info) != SMBAUTH_SUCCESS)
 			return (-1);
 	} else {
diff --git a/usr/src/lib/smbsrv/libmlsvc/common/netr_logon.c b/usr/src/lib/smbsrv/libmlsvc/common/netr_logon.c
index ab99db75f8..6fdd3a9ca4 100644
--- a/usr/src/lib/smbsrv/libmlsvc/common/netr_logon.c
+++ b/usr/src/lib/smbsrv/libmlsvc/common/netr_logon.c
@@ -37,8 +37,8 @@
 #include <netdb.h>
 #include <thread.h>
 
+#include <libmlrpc/libmlrpc.h>
 #include <smbsrv/libsmb.h>
-#include <smbsrv/libmlrpc.h>
 #include <smbsrv/libmlsvc.h>
 #include <smbsrv/ndl/netlogon.ndl>
 #include <smbsrv/netrauth.h>
diff --git a/usr/src/lib/smbsrv/libmlsvc/common/samr_clnt.c b/usr/src/lib/smbsrv/libmlsvc/common/samr_clnt.c
index 289e8470cf..dd15469c15 100644
--- a/usr/src/lib/smbsrv/libmlsvc/common/samr_clnt.c
+++ b/usr/src/lib/smbsrv/libmlsvc/common/samr_clnt.c
@@ -44,8 +44,8 @@
 #include <netdb.h>
 #include <sys/param.h>
 
+#include <libmlrpc/libmlrpc.h>
 #include <smbsrv/libsmb.h>
-#include <smbsrv/libmlrpc.h>
 #include <smbsrv/libmlsvc.h>
 #include <smbsrv/smbinfo.h>
 #include <smbsrv/ntaccess.h>
diff --git a/usr/src/lib/smbsrv/libmlsvc/common/samr_svc.c b/usr/src/lib/smbsrv/libmlsvc/common/samr_svc.c
index 8835a8e00f..43ae0568e9 100644
--- a/usr/src/lib/smbsrv/libmlsvc/common/samr_svc.c
+++ b/usr/src/lib/smbsrv/libmlsvc/common/samr_svc.c
@@ -39,8 +39,8 @@
 #include <netdb.h>
 #include <assert.h>
 #include <grp.h>
+#include <libmlrpc/libmlrpc.h>
 #include <smbsrv/libsmb.h>
-#include <smbsrv/libmlrpc.h>
 #include <smbsrv/libmlsvc.h>
 #include <smbsrv/smbinfo.h>
 #include <smbsrv/nmpipes.h>
diff --git a/usr/src/lib/smbsrv/libmlsvc/common/spoolss_svc.c b/usr/src/lib/smbsrv/libmlsvc/common/spoolss_svc.c
index ba1c9caece..302c7fb278 100644
--- a/usr/src/lib/smbsrv/libmlsvc/common/spoolss_svc.c
+++ b/usr/src/lib/smbsrv/libmlsvc/common/spoolss_svc.c
@@ -35,8 +35,8 @@
 #include <strings.h>
 #include <fcntl.h>
 #include <errno.h>
+#include <libmlrpc/libmlrpc.h>
 #include <smbsrv/libsmb.h>
-#include <smbsrv/libmlrpc.h>
 #include <smbsrv/libmlsvc.h>
 #include <smbsrv/smb.h>
 #include <smbsrv/ndl/spoolss.ndl>
diff --git a/usr/src/lib/smbsrv/libmlsvc/common/srvsvc_clnt.c b/usr/src/lib/smbsrv/libmlsvc/common/srvsvc_clnt.c
index def8ced54a..c7e5d60a6b 100644
--- a/usr/src/lib/smbsrv/libmlsvc/common/srvsvc_clnt.c
+++ b/usr/src/lib/smbsrv/libmlsvc/common/srvsvc_clnt.c
@@ -34,9 +34,11 @@
  */
 
 #include <sys/errno.h>
+#include <sys/tzfile.h>
 #include <stdio.h>
 #include <time.h>
 #include <strings.h>
+#include <unistd.h>
 
 #include <smbsrv/libsmb.h>
 #include <smbsrv/libmlsvc.h>
@@ -348,65 +350,45 @@ srvsvc_net_connect_enum(char *server, char *domain, char *netname, int level)
 }
 
 /*
- * Windows 95+ and Windows NT4.0 both report the version as 4.0.
- * Windows 2000+ reports the version as 5.x.
+ * Compare the time here with the remote time on the server
+ * and report clock skew.
  */
-int
-srvsvc_net_server_getinfo(char *server, char *domain,
-    srvsvc_server_info_t *svinfo)
+void
+srvsvc_timecheck(char *server, char *domain)
 {
-	mlsvc_handle_t handle;
-	struct mslm_NetServerGetInfo arg;
-	struct mslm_SERVER_INFO_101 *sv101;
-	int len, opnum, rc;
-	char user[SMB_USERNAME_MAXLEN];
+	char			hostname[MAXHOSTNAMELEN];
+	struct timeval		dc_tv;
+	struct tm		dc_tm;
+	struct tm		*tm;
+	time_t			tnow;
+	time_t			tdiff;
+	int			priority;
+
+	if (srvsvc_net_remote_tod(server, domain, &dc_tv, &dc_tm) < 0) {
+		syslog(LOG_DEBUG, "srvsvc_net_remote_tod failed");
+		return;
+	}
 
-	smb_ipc_get_user(user, SMB_USERNAME_MAXLEN);
+	tnow = time(NULL);
 
-	if (srvsvc_open(server, domain, user, &handle) != 0)
-		return (-1);
+	if (tnow > dc_tv.tv_sec)
+		tdiff = (tnow - dc_tv.tv_sec) / SECSPERMIN;
+	else
+		tdiff = (dc_tv.tv_sec - tnow) / SECSPERMIN;
 
-	opnum = SRVSVC_OPNUM_NetServerGetInfo;
-	bzero(&arg, sizeof (arg));
+	if (tdiff != 0) {
+		(void) strlcpy(hostname, "localhost", MAXHOSTNAMELEN);
+		(void) gethostname(hostname, MAXHOSTNAMELEN);
 
-	len = strlen(server) + 4;
-	arg.servername = ndr_rpc_malloc(&handle, len);
-	if (arg.servername == NULL)
-		return (-1);
+		priority = (tdiff > 2) ? LOG_NOTICE : LOG_DEBUG;
+		syslog(priority, "DC [%s] clock skew detected: %u minutes",
+		    server, tdiff);
 
-	(void) snprintf((char *)arg.servername, len, "\\\\%s", server);
-	arg.level = 101;
-
-	rc = ndr_rpc_call(&handle, opnum, &arg);
-	if ((rc != 0) || (arg.status != 0)) {
-		srvsvc_close(&handle);
-		return (-1);
+		tm = gmtime(&dc_tv.tv_sec);
+		syslog(priority, "%-8s  UTC: %s", server, asctime(tm));
+		tm = gmtime(&tnow);
+		syslog(priority, "%-8s  UTC: %s", hostname, asctime(tm));
 	}
-
-	sv101 = arg.result.bufptr.bufptr101;
-
-	bzero(svinfo, sizeof (srvsvc_server_info_t));
-	svinfo->sv_platform_id = sv101->sv101_platform_id;
-	svinfo->sv_version_major = sv101->sv101_version_major;
-	svinfo->sv_version_minor = sv101->sv101_version_minor;
-	svinfo->sv_type = sv101->sv101_type;
-	if (sv101->sv101_name)
-		svinfo->sv_name = strdup((char *)sv101->sv101_name);
-	if (sv101->sv101_comment)
-		svinfo->sv_comment = strdup((char *)sv101->sv101_comment);
-
-	if (svinfo->sv_type & SV_TYPE_WFW)
-		svinfo->sv_os = NATIVE_OS_WIN95;
-	if (svinfo->sv_type & SV_TYPE_WINDOWS)
-		svinfo->sv_os = NATIVE_OS_WIN95;
-	if ((svinfo->sv_type & SV_TYPE_NT) ||
-	    (svinfo->sv_type & SV_TYPE_SERVER_NT))
-		svinfo->sv_os = NATIVE_OS_WINNT;
-	if (svinfo->sv_version_major > 4)
-		svinfo->sv_os = NATIVE_OS_WIN2000;
-
-	srvsvc_close(&handle);
-	return (0);
 }
 
 /*
@@ -544,39 +526,3 @@ srvsvc_net_remote_tod(char *server, char *domain, struct timeval *tv,
 	srvsvc_close(&handle);
 	return (0);
 }
-
-void
-srvsvc_net_test(char *server, char *domain, char *netname)
-{
-	smb_domainex_t di;
-	srvsvc_server_info_t svinfo;
-
-	(void) smb_tracef("%s %s %s", server, domain, netname);
-
-	if (smb_domain_getinfo(&di)) {
-		server = di.d_dci.dc_name;
-		domain = di.d_primary.di_nbname;
-	}
-
-	if (srvsvc_net_server_getinfo(server, domain, &svinfo) == 0) {
-		smb_tracef("NetServerGetInfo: %s %s (%d.%d) id=%d type=0x%08x",
-		    svinfo.sv_name ? svinfo.sv_name : "NULL",
-		    svinfo.sv_comment ? svinfo.sv_comment : "NULL",
-		    svinfo.sv_version_major, svinfo.sv_version_minor,
-		    svinfo.sv_platform_id, svinfo.sv_type);
-
-		free(svinfo.sv_name);
-		free(svinfo.sv_comment);
-	}
-
-	(void) srvsvc_net_share_get_info(server, domain, netname);
-#if 0
-	/*
-	 * The NetSessionEnum server-side definition was updated.
-	 * Disabled until the client-side has been updated.
-	 */
-	(void) srvsvc_net_session_enum(server, domain, netname);
-#endif
-	(void) srvsvc_net_connect_enum(server, domain, netname, 0);
-	(void) srvsvc_net_connect_enum(server, domain, netname, 1);
-}
diff --git a/usr/src/lib/smbsrv/libsmb/common/libsmb.h b/usr/src/lib/smbsrv/libsmb/common/libsmb.h
index fdda80dc2a..82d6bc1cc3 100644
--- a/usr/src/lib/smbsrv/libsmb/common/libsmb.h
+++ b/usr/src/lib/smbsrv/libsmb/common/libsmb.h
@@ -44,17 +44,18 @@ extern "C" {
 #include <synch.h>
 #include <stdarg.h>
 
+#include <smb/nterror.h>
+#include <smb/ntstatus.h>
+#include <smb/wintypes.h>
+
 #include <smbsrv/string.h>
 #include <smbsrv/smb_idmap.h>
 #include <smbsrv/netbios.h>
 #include <smbsrv/smb_share.h>
-#include <smb/nterror.h>
-#include <smb/ntstatus.h>
 #include <smbsrv/smb_door.h>
 #include <smbsrv/alloc.h>
 #include <smbsrv/hash_table.h>
 #include <smbsrv/msgbuf.h>
-#include <smbsrv/wintypes.h>
 #include <smbsrv/smb_xdr.h>
 #include <smbsrv/smbinfo.h>
 #include <smbsrv/ntifs.h>
diff --git a/usr/src/lib/smbsrv/libsmb/common/smb_doorclnt.c b/usr/src/lib/smbsrv/libsmb/common/smb_doorclnt.c
index e51f8bbca1..dfbbfd0483 100644
--- a/usr/src/lib/smbsrv/libsmb/common/smb_doorclnt.c
+++ b/usr/src/lib/smbsrv/libsmb/common/smb_doorclnt.c
@@ -33,8 +33,8 @@
 #include <unistd.h>
 #include <errno.h>
 #include <sys/mman.h>
+#include <smb/wintypes.h>
 #include <smbsrv/libsmb.h>
-#include <smbsrv/wintypes.h>
 #include <smbsrv/smb_door.h>
 
 static int smb_door_call(uint32_t, void *, xdrproc_t, void *, xdrproc_t);
diff --git a/usr/src/man/man1m/netstat.1m b/usr/src/man/man1m/netstat.1m
index fa8be7c4ed..5b119fbb43 100644
--- a/usr/src/man/man1m/netstat.1m
+++ b/usr/src/man/man1m/netstat.1m
@@ -1,4 +1,5 @@
 '\" te
+.\" Copyright 2018, Joyent, Inc.
 .\" Copyright (C) 2002, Sun Microsystems, Inc. All Rights Reserved
 .\" Copyright 1989 AT&T
 .\" Copyright (c) 1983 Regents of the University of California. All rights reserved. The Berkeley software License Agreement specifies the terms and conditions for redistribution.
@@ -34,18 +35,18 @@ netstat \- show network status
 
 .LP
 .nf
-\fBnetstat\fR \fB-i\fR [\fB-I\fR \fIinterface\fR] [\fB-an\fR] [\fB-f\fR \fIaddress_family\fR]
+\fBnetstat\fR \fB-i\fR [\fB-I\fR \fIinterface\fR] [\fB-acn\fR] [\fB-f\fR \fIaddress_family\fR]
      [\fB-T\fR u | d ] [\fIinterval\fR [\fIcount\fR]]
 .fi
 
 .LP
 .nf
-\fBnetstat\fR \fB-r\fR [\fB-anvR\fR] [\fB-f\fR \fIaddress_family\fR | \fIfilter\fR]
+\fBnetstat\fR \fB-r\fR [\fB-acnvR\fR] [\fB-f\fR \fIaddress_family\fR | \fIfilter\fR]
 .fi
 
 .LP
 .nf
-\fBnetstat\fR \fB-M\fR [\fB-ns\fR] [\fB-f\fR \fIaddress_family\fR]
+\fBnetstat\fR \fB-M\fR [\fB-cns\fR] [\fB-f\fR \fIaddress_family\fR]
 .fi
 
 .LP
@@ -124,6 +125,19 @@ are not shown. Under most conditions, only interface, host, network, and
 default routes are shown and only the status of physical interfaces is shown.
 .RE
 
+.sp
+.ne 2
+.na
+\fB\fB-c\fR\fR
+.ad
+.sp .6
+.RS 4n
+Print IPv4 networks using CIDR (x.y.z.a/NN) notation with the \fB-i\fR,
+\fB-r\fR, and \fB-M\fR options. IPv6 networks default to this, but due to
+backward compatibility, IPv4 ones do not without this flag.  A noncontiguous
+IPv4 netmask will print "/NM" if this flag is enabled.
+.RE
+
 .sp
 .ne 2
 .na
diff --git a/usr/src/man/man1m/smbios.1m b/usr/src/man/man1m/smbios.1m
index 8c71627966..813c317a43 100644
--- a/usr/src/man/man1m/smbios.1m
+++ b/usr/src/man/man1m/smbios.1m
@@ -1,9 +1,10 @@
 '\" te
 .\" Copyright (c) 2005, Sun Microsystems, Inc. All Rights Reserved.
+.\" Copyright 2018 Joyent, Inc.
 .\" The contents of this file are subject to the terms of the Common Development and Distribution License (the "License").  You may not use this file except in compliance with the License.
 .\" You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE or http://www.opensolaris.org/os/licensing.  See the License for the specific language governing permissions and limitations under the License.
 .\" When distributing Covered Code, include this CDDL HEADER in each file and include the License file at usr/src/OPENSOLARIS.LICENSE.  If applicable, add the following below this CDDL HEADER, with the fields enclosed by brackets "[]" replaced with your own identifying information: Portions Copyright [yyyy] [name of copyright owner]
-.TH SMBIOS 1M "Aug 31, 2005"
+.TH SMBIOS 1M "March 29, 2018"
 .SH NAME
 smbios \- display the contents of a System Management BIOS image
 .SH SYNOPSIS
@@ -13,7 +14,6 @@ smbios \- display the contents of a System Management BIOS image
 .fi
 
 .SH DESCRIPTION
-.sp
 .LP
 The \fBsmbios\fR utility displays the contents of the System Management BIOS
 (SMBIOS) image exported by the current system or stored in a file. SMBIOS is an
@@ -37,7 +37,6 @@ applied to the resulting file to display its content.
 readable fashion. If \fBsmbios\fR does not recognize a structure's type or
 content, the raw hexadecimal data for the structure is displayed.
 .SH OPTIONS
-.sp
 .LP
 The following options are supported:
 .sp
@@ -131,7 +130,6 @@ human-readable output for the selected structures.
 .RE
 
 .SH OPERANDS
-.sp
 .LP
 The following operands are supported:
 .sp
@@ -145,7 +143,6 @@ SMBIOS image.
 .RE
 
 .SH EXIT STATUS
-.sp
 .LP
 The following exit values are returned:
 .sp
@@ -178,7 +175,6 @@ Invalid command-line options were specified.
 .RE
 
 .SH FILES
-.sp
 .ne 2
 .na
 \fB\fB/dev/smbios\fR \fR
@@ -189,7 +185,6 @@ snapshot of the current system SMBIOS image.
 .RE
 
 .SH ATTRIBUTES
-.sp
 .LP
 See \fBattributes\fR(5) for descriptions of the following attributes:
 .sp
@@ -208,14 +203,12 @@ Interface Stability	See below.
 .LP
 The command-line options are Evolving. The human-readable output is Unstable.
 .SH SEE ALSO
-.sp
 .LP
 \fBprtdiag\fR(1M), \fBattributes\fR(5), \fBsmbios\fR(7D)
 .sp
 .LP
 \fISystem Management BIOS Reference Specification\fR (see http://www.dmtf.org)
 .SH NOTES
-.sp
 .LP
 The implementation of a System Management BIOS image is entirely at the
 discretion of the system and BIOS vendors. Not all systems export an SMBIOS.
@@ -223,3 +216,8 @@ The SMBIOS structure content varies widely between systems and BIOS vendors and
 frequently does not comply with the guidelines included in the specification.
 Some structure fields might not be filled in by the BIOS at all, and others
 might be filled inwith non-conforming values.
+.sp
+.LP
+This utility incorrectly interprets the first three fields of the system
+information UUID field as network-endian; the SMBIOS specification defines them
+as little-endian. The "UUID (Endian-corrected)" field has the correct value.
diff --git a/usr/src/man/man1m/zfs.1m b/usr/src/man/man1m/zfs.1m
index 70ae935ed9..8d913a9855 100644
--- a/usr/src/man/man1m/zfs.1m
+++ b/usr/src/man/man1m/zfs.1m
@@ -27,6 +27,7 @@
 .\" Copyright (c) 2014 by Adam Stevko. All rights reserved.
 .\" Copyright (c) 2014 Integros [integros.com]
 .\" Copyright 2017 Nexenta Systems, Inc.
+.\" Copyright 2018 Joyent, Inc.
 .\"
 .Dd December 6, 2017
 .Dt ZFS 1M
@@ -1345,7 +1346,7 @@ Limits the amount of space a dataset can consume.
 This property enforces a hard limit on the amount of space used.
 This hard limit does not include space used by descendents, including file
 systems and snapshots.
-.It Sy refreservation Ns = Ns Em size Ns | Ns Sy none
+.It Sy refreservation Ns = Ns Em size Ns | Ns Sy none Ns | Ns Sy auto
 The minimum amount of space guaranteed to a dataset, not including its
 descendents.
 When the amount of space used is below this value, the dataset is treated as if
@@ -1363,6 +1364,22 @@ this reservation to accommodate the current number of
 .Qq referenced
 bytes in the dataset.
 .Pp
+If
+.Sy refreservation
+is set to
+.Sy auto ,
+a volume is thick provisioned
+.Po or
+.Qq not sparse
+.Pc .
+.Sy refreservation Ns = Ns Sy auto
+is only supported on volumes.
+See
+.Sy volsize
+in the
+.Sx Native Properties
+section for more information about sparse volumes.
+.Pp
 This property can also be referred to by its shortened column name,
 .Sy refreserv .
 .It Sy reservation Ns = Ns Em size Ns | Ns Sy none
@@ -1577,22 +1594,39 @@ Extreme care should be used when adjusting the volume size.
 Though not recommended, a
 .Qq sparse volume
 .Po also known as
-.Qq thin provisioning
+.Qq thin provisioned
 .Pc
 can be created by specifying the
 .Fl s
 option to the
 .Nm zfs Cm create Fl V
-command, or by changing the reservation after the volume has been created.
+command, or by changing the value of the
+.Sy refreservation
+property
+.Po or
+.Sy reservation
+property on pool version 8 or earlier
+.Pc
+after the volume has been created.
 A
 .Qq sparse volume
-is a volume where the reservation is less then the volume size.
+is a volume where the value of
+.Sy refreservation
+is less than the size of the volume plus the space required to store its
+metadata.
 Consequently, writes to a sparse volume can fail with
 .Er ENOSPC
 when the pool is low on space.
 For a sparse volume, changes to
 .Sy volsize
-are not reflected in the reservation.
+are not reflected in the
+.Sy refreservation.
+A volume that is not sparse is said to be
+.Qq thick provisioned .
+A sparse volume can become thick provisioned by setting
+.Sy refreservation
+to
+.Sy auto .
 .It Sy vscan Ns = Ns Sy on Ns | Ns Sy off
 Controls whether regular files should be scanned for viruses when a file is
 opened and closed.
diff --git a/usr/src/man/man5/zpool-features.5 b/usr/src/man/man5/zpool-features.5
index 931fd8e69c..c97bb19e65 100644
--- a/usr/src/man/man5/zpool-features.5
+++ b/usr/src/man/man5/zpool-features.5
@@ -423,7 +423,6 @@ This feature becomes \fBactive\fR as soon as it is enabled and will
 never return to being \fBenabled\fR.
 
 .RE
-
 .sp
 .ne 2
 .na
@@ -488,6 +487,34 @@ This feature becomes \fBactive\fR when the "zpool checkpoint" command
 is used to checkpoint the pool.
 The feature will only return back to being \fBenabled\fR when the pool
 is rewound or the checkpoint has been discarded.
+
+.RE
+.sp
+.ne 2
+.na
+\fB\fBspacemap_v2\fR\fR
+.ad
+.RS 4n
+.TS
+l l .
+GUID	com.delphix:spacemap_v2
+READ\-ONLY COMPATIBLE	yes
+DEPENDENCIES	none
+.TE
+
+This feature enables the use of the new space map encoding which
+consists of two words (instead of one) whenever it is advantageous.
+The new encoding allows space maps to represent large regions of
+space more efficiently on-disk while also increasing their maximum
+addressable offset.
+
+This feature becomes \fBactive\fR once it is \fBenabled\fR, and never
+returns back to being \fBenabled\fR.
+
+.RE
+.sp
+.ne 2
+.na
 \fB\fBlarge_blocks\fR\fR
 .ad
 .RS 4n
diff --git a/usr/src/man/man9e/mac.9e b/usr/src/man/man9e/mac.9e
index 52984f9791..c22becc131 100644
--- a/usr/src/man/man9e/mac.9e
+++ b/usr/src/man/man9e/mac.9e
@@ -9,9 +9,9 @@
 .\" http://www.illumos.org/license/CDDL.
 .\"
 .\"
-.\" Copyright 2016 Joyent, Inc.
+.\" Copyright 2018 Joyent, Inc.
 .\"
-.Dd March 26, 2017
+.Dd March 23, 2018
 .Dt MAC 9E
 .Os
 .Sh NAME
@@ -550,24 +550,28 @@ The following set of flags may be combined through a bitwise inclusive OR:
 .Bl -tag -width Ds
 .It Sy HCKSUM_INET_PARTIAL
 This indicates that the hardware can calculate a partial checksum for
-both IPv4 and IPv6; however, it requires the pseudo-header checksum be
-calculated for it.
+both IPv4 and IPv6 UDP and TCP packets; however, it requires the pseudo-header
+checksum be calculated for it.
 The pseudo-header checksum will be available for the mblk_t when calling
 .Xr mac_hcksum_get 9F .
-Note this does not imply that the hardware is capable of calculating the
-IPv4 header checksum.
+Note this does not imply that the hardware is capable of calculating
+the partial checksum for other L4 protocols or the IPv4 header checksum.
 That should be indicated with the
 .Sy HCKSUM_IPHDRCKSUM flag.
 .It Sy HCKSUM_INET_FULL_V4
-This indicates that the hardware will fully calculate the L4 checksum
-for outgoing IPv4 packets and does not require a pseudo-header checksum.
+This indicates that the hardware will fully calculate the L4 checksum for
+outgoing IPv4 UDP or TCP packets only, and does not require a pseudo-header
+checksum.
 Note this does not imply that the hardware is capable of calculating the
-IPv4 header checksum.
+checksum for other L4 protocols or the IPv4 header checksum.
 That should be indicated with the
 .Sy HCKSUM_IPHDRCKSUM .
 .It Sy HCKSUM_INET_FULL_V6
-This indicates that the hardware will fully calculate the L4 checksum
-for outgoing IPv6 packets and does not require a pseudo-header checksum.
+This indicates that the hardware will fully calculate the L4 checksum for
+outgoing IPv6 UDP or TCP packets only, and does not require a pseudo-header
+checksum.
+Note this does not imply that the hardware is capable of calculating the
+checksum for any other L4 protocols.
 .It Sy HCKSUM_IPHDRCKSUM
 This indicates that the hardware supports calculating the checksum for
 the IPv4 header itself.
diff --git a/usr/src/pkg/manifests/driver-storage-mpt_sas.mf b/usr/src/pkg/manifests/driver-storage-mpt_sas.mf
index ae55dc9422..c0506e3307 100644
--- a/usr/src/pkg/manifests/driver-storage-mpt_sas.mf
+++ b/usr/src/pkg/manifests/driver-storage-mpt_sas.mf
@@ -71,8 +71,25 @@ driver name=mpt_sas class=scsi-self-identifying \
     alias=pciex1000,95 \
     alias=pciex1000,96 \
     alias=pciex1000,97 \
+    alias=pciex1000,aa \
+    alias=pciex1000,ab \
+    alias=pciex1000,ac \
+    alias=pciex1000,ad \
+    alias=pciex1000,ae \
+    alias=pciex1000,af \
+    alias=pciex1000,c0 \
+    alias=pciex1000,c1 \
+    alias=pciex1000,c2 \
+    alias=pciex1000,c3 \
     alias=pciex1000,c4 \
-    alias=pciex1000,c9
+    alias=pciex1000,c5 \
+    alias=pciex1000,c6 \
+    alias=pciex1000,c7 \
+    alias=pciex1000,c8 \
+    alias=pciex1000,c9 \
+    alias=pciex1000,d0 \
+    alias=pciex1000,d1 \
+    alias=pciex1000,d2
 file path=kernel/drv/$(ARCH64)/mpt_sas group=sys
 file path=kernel/drv/mpt_sas.conf group=sys \
     original_name=SUNWmptsas:kernel/drv/mpt_sas.conf preserve=true
@@ -81,3 +98,5 @@ legacy pkg=SUNWmptsas desc="LSI MPT SAS 2.0/2.5 Controller HBA Driver" \
     name="LSI MPT SAS 2.0/2.5 Controller HBA Driver"
 license cr_Sun license=cr_Sun
 license lic_CDDL license=lic_CDDL
+license usr/src/uts/common/sys/scsi/adapters/mpt_sas/mpi/THIRDPARTYLICENSE \
+    license=usr/src/uts/common/sys/scsi/adapters/mpt_sas/mpi/THIRDPARTYLICENSE
diff --git a/usr/src/pkg/manifests/driver-storage-nvme.mf b/usr/src/pkg/manifests/driver-storage-nvme.mf
index 98f9b8cc81..4c8d39cacb 100644
--- a/usr/src/pkg/manifests/driver-storage-nvme.mf
+++ b/usr/src/pkg/manifests/driver-storage-nvme.mf
@@ -25,7 +25,7 @@
 <include global_zone_only_component>
 set name=pkg.fmri value=pkg:/driver/storage/nvme@$(PKGVERS)
 set name=pkg.description \
-    value="Driver for Intel NVMe 1.1b compliant storage devices"
+    value="Driver for NVM Express compliant storage devices"
 set name=pkg.summary value="NVMe driver"
 set name=info.classification \
     value=org.opensolaris.category.2008:System/Hardware
diff --git a/usr/src/pkg/manifests/service-fault-management.mf b/usr/src/pkg/manifests/service-fault-management.mf
index 4bd1aebf44..081e2f4841 100644
--- a/usr/src/pkg/manifests/service-fault-management.mf
+++ b/usr/src/pkg/manifests/service-fault-management.mf
@@ -748,6 +748,18 @@ $(i386_ONLY)link \
 $(i386_ONLY)link \
     path=usr/platform/i86pc/lib/fm/topo/maps/Joyent-Compute-Platform-3102-hc-topology.xml \
     target=./SSG-2028R-ACR24L-hc-topology.xml
+$(i386_ONLY)file \
+    path=usr/platform/i86pc/lib/fm/topo/maps/Joyent-Compute-Platform-3301-hc-topology.xml \
+    mode=0444
+$(i386_ONLY)link \
+    path=usr/platform/i86pc/lib/fm/topo/maps/Joyent-Compute-Platform-3302-hc-topology.xml \
+    target=./Joyent-Compute-Platform-3301-hc-topology.xml
+$(i386_ONLY)file \
+    path=usr/platform/i86pc/lib/fm/topo/maps/Joyent-Compute-Platform-330x-chassis-hc-topology.xml \
+    mode=0444
+$(i386_ONLY)file \
+    path=usr/platform/i86pc/lib/fm/topo/maps/Joyent-Compute-Platform-330x-fan-hc-topology.xml \
+    mode=0444
 $(i386_ONLY)file \
     path=usr/platform/i86pc/lib/fm/topo/maps/SSG-2028R-ACR24L-chassis-hc-topology.xml \
     mode=0444
diff --git a/usr/src/pkg/manifests/service-file-system-smb.mf b/usr/src/pkg/manifests/service-file-system-smb.mf
index 4b349a26bc..ba5dedcd6d 100644
--- a/usr/src/pkg/manifests/service-file-system-smb.mf
+++ b/usr/src/pkg/manifests/service-file-system-smb.mf
@@ -83,7 +83,6 @@ file path=usr/lib/smbsrv/dtrace/smbd-pipesvc.d mode=0555
 file path=usr/lib/smbsrv/dtrace/smbnode.d mode=0555
 file path=usr/lib/smbsrv/dtrace/smbsrv.d mode=0555
 file path=usr/lib/smbsrv/dtrace/smbvfs.d mode=0555
-file path=usr/lib/smbsrv/libmlrpc.so.1
 file path=usr/lib/smbsrv/libmlsvc.so.1
 file path=usr/lib/smbsrv/libsmb.so.1
 file path=usr/lib/smbsrv/libsmbns.so.1
@@ -109,7 +108,3 @@ license cr_Sun license=cr_Sun
 license lic_CDDL license=lic_CDDL
 link path=usr/lib/reparse/libreparse_smb.so target=libreparse_smb.so.1
 link path=usr/lib/security/pam_smb_passwd.so target=pam_smb_passwd.so.1
-link path=usr/lib/smbsrv/libmlrpc.so target=libmlrpc.so.1
-link path=usr/lib/smbsrv/libmlsvc.so target=libmlsvc.so.1
-link path=usr/lib/smbsrv/libsmb.so target=libsmb.so.1
-link path=usr/lib/smbsrv/libsmbns.so target=libsmbns.so.1
diff --git a/usr/src/pkg/manifests/system-bhyve.mf b/usr/src/pkg/manifests/system-bhyve.mf
index 9ddbd1cb5f..464c2a80bf 100644
--- a/usr/src/pkg/manifests/system-bhyve.mf
+++ b/usr/src/pkg/manifests/system-bhyve.mf
@@ -30,31 +30,34 @@ set name=info.classification \
     value=org.opensolaris.category.2008:System/Virtualization
 set name=variant.arch value=i386
 dir path=kernel group=sys
-dir path=kernel/kmdb group=sys
-dir path=kernel/kmdb/$(ARCH64) group=sys
 dir path=lib group=bin
 dir path=lib/$(ARCH64) group=bin
 dir path=usr group=sys
 dir path=usr/kernel/drv group=sys
 dir path=usr/kernel/drv/$(ARCH64) group=sys
 dir path=usr/lib group=bin
-dir path=usr/lib/mdb group=sys
-dir path=usr/lib/mdb/kvm group=sys
-dir path=usr/lib/mdb/kvm/$(ARCH64) group=sys
 dir path=usr/sbin
 driver name=ppt
 driver name=viona
 driver name=vmm
-file path=kernel/kmdb/$(ARCH64)/vmm mode=0555
 file path=lib/$(ARCH64)/libvmmapi.so.1
+link path=lib/$(ARCH64)/libvmmapi.so target=./libvmmapi.so.1
 file path=usr/kernel/drv/$(ARCH64)/ppt
 file path=usr/kernel/drv/$(ARCH64)/viona
 file path=usr/kernel/drv/$(ARCH64)/vmm
 file path=usr/kernel/drv/ppt.conf
 file path=usr/kernel/drv/viona.conf
 file path=usr/kernel/drv/vmm.conf
+file path=usr/lib/libppt.so.1
+link path=usr/lib/libppt.so target=./libppt.so.1
+file path=usr/lib/llib-lppt
+file path=usr/lib/llib-lppt.ln
+file path=usr/lib/mdb/kvm/$(ARCH64)/vmm.so mode=0555
+file path=usr/lib/$(ARCH64)/libppt.so.1
+link path=usr/lib/$(ARCH64)/libppt.so target=./libppt.so.1
+file path=usr/lib/$(ARCH64)/llib-lppt.ln
 file path=usr/lib/mdb/kvm/$(ARCH64)/vmm.so mode=0555
 file path=usr/sbin/bhyve mode=0555
 file path=usr/sbin/bhyvectl mode=0555
+file path=usr/sbin/pptadm mode=0555
 license lic_CDDL license=lic_CDDL
-link path=lib/$(ARCH64)/libvmmapi.so target=./libvmmapi.so.1
diff --git a/usr/src/pkg/manifests/system-file-system-smb.mf b/usr/src/pkg/manifests/system-file-system-smb.mf
index b68191317a..b5ff30e5ad 100644
--- a/usr/src/pkg/manifests/system-file-system-smb.mf
+++ b/usr/src/pkg/manifests/system-file-system-smb.mf
@@ -79,6 +79,7 @@ file path=usr/lib/fs/smbfs/mount mode=4555
 file path=usr/lib/fs/smbfs/share mode=0555
 file path=usr/lib/fs/smbfs/umount mode=4555
 file path=usr/lib/fs/smbfs/unshare mode=0555
+file path=usr/lib/libmlrpc.so.2
 file path=usr/lib/libsmbfs.so.1
 file path=usr/lib/mdb/kvm/$(ARCH64)/nsmb.so mode=0555
 file path=usr/lib/mdb/kvm/$(ARCH64)/smbfs.so mode=0555
diff --git a/usr/src/pkg/manifests/system-test-zfstest.mf b/usr/src/pkg/manifests/system-test-zfstest.mf
index 87ed0ee18b..faf818c66f 100644
--- a/usr/src/pkg/manifests/system-test-zfstest.mf
+++ b/usr/src/pkg/manifests/system-test-zfstest.mf
@@ -13,6 +13,7 @@
 # Copyright (c) 2012, 2017 by Delphix. All rights reserved.
 # Copyright 2015, 2016 Nexenta Systems, Inc.  All rights reserved.
 # Copyright 2016, OmniTI Computer Consulting, Inc. All rights reserved.
+# Copyright 2018 Joyent, Inc.
 #
 
 set name=pkg.fmri value=pkg:/system/test/zfstest@$(PKGVERS)
@@ -2397,6 +2398,14 @@ file path=opt/zfs-tests/tests/functional/reservation/reservation_017_pos \
     mode=0555
 file path=opt/zfs-tests/tests/functional/reservation/reservation_018_pos \
     mode=0555
+file path=opt/zfs-tests/tests/functional/reservation/reservation_019_pos \
+    mode=0555
+file path=opt/zfs-tests/tests/functional/reservation/reservation_020_pos \
+    mode=0555
+file path=opt/zfs-tests/tests/functional/reservation/reservation_021_neg \
+    mode=0555
+file path=opt/zfs-tests/tests/functional/reservation/reservation_022_pos \
+    mode=0555
 file path=opt/zfs-tests/tests/functional/reservation/setup mode=0555
 file path=opt/zfs-tests/tests/functional/rootpool/cleanup mode=0555
 file path=opt/zfs-tests/tests/functional/rootpool/rootpool_002_neg mode=0555
diff --git a/usr/src/test/zfs-tests/runfiles/delphix.run b/usr/src/test/zfs-tests/runfiles/delphix.run
index ef84f99f68..ff77d8f1f2 100644
--- a/usr/src/test/zfs-tests/runfiles/delphix.run
+++ b/usr/src/test/zfs-tests/runfiles/delphix.run
@@ -12,6 +12,7 @@
 #
 # Copyright (c) 2012, 2018 by Delphix. All rights reserved.
 # Copyright 2016, OmniTI Computer Consulting, Inc. All rights reserved.
+# Copyright 2018 Joyent, Inc.
 #
 
 [DEFAULT]
@@ -515,7 +516,9 @@ tests = ['reservation_001_pos', 'reservation_002_pos', 'reservation_003_pos',
     'reservation_007_pos', 'reservation_008_pos', 'reservation_009_pos',
     'reservation_010_pos', 'reservation_011_pos', 'reservation_012_pos',
     'reservation_013_pos', 'reservation_014_pos', 'reservation_015_pos',
-    'reservation_016_pos', 'reservation_017_pos', 'reservation_018_pos']
+    'reservation_016_pos', 'reservation_017_pos', 'reservation_018_pos',
+    'reservation_019_pos', 'reservation_020_pos', 'reservation_021_neg',
+    'reservation_022_pos']
 
 [/opt/zfs-tests/tests/functional/rootpool]
 tests = ['rootpool_002_neg', 'rootpool_003_neg', 'rootpool_007_pos']
diff --git a/usr/src/test/zfs-tests/runfiles/omnios.run b/usr/src/test/zfs-tests/runfiles/omnios.run
index 030f4ffa54..ebf446f61a 100644
--- a/usr/src/test/zfs-tests/runfiles/omnios.run
+++ b/usr/src/test/zfs-tests/runfiles/omnios.run
@@ -12,6 +12,7 @@
 #
 # Copyright (c) 2013, 2017 by Delphix. All rights reserved.
 # Copyright 2016, OmniTI Computer Consulting, Inc. All rights reserved.
+# Copyright 2018 Joyent, Inc.
 #
 
 [DEFAULT]
@@ -484,7 +485,9 @@ tests = ['reservation_001_pos', 'reservation_002_pos', 'reservation_003_pos',
     'reservation_007_pos', 'reservation_008_pos', 'reservation_009_pos',
     'reservation_010_pos', 'reservation_011_pos', 'reservation_012_pos',
     'reservation_013_pos', 'reservation_014_pos', 'reservation_015_pos',
-    'reservation_016_pos', 'reservation_017_pos', 'reservation_018_pos']
+    'reservation_016_pos', 'reservation_017_pos', 'reservation_018_pos',
+    'reservation_019_pos', 'reservation_020_pos', 'reservation_021_neg',
+    'reservation_022_pos']
 
 [/opt/zfs-tests/tests/functional/rootpool]
 tests = ['rootpool_002_neg', 'rootpool_003_neg', 'rootpool_007_pos']
diff --git a/usr/src/test/zfs-tests/runfiles/openindiana.run b/usr/src/test/zfs-tests/runfiles/openindiana.run
index 40f5008319..2d8af0bf69 100644
--- a/usr/src/test/zfs-tests/runfiles/openindiana.run
+++ b/usr/src/test/zfs-tests/runfiles/openindiana.run
@@ -12,6 +12,7 @@
 #
 # Copyright (c) 2012, 2017 by Delphix. All rights reserved.
 # Copyright 2016, OmniTI Computer Consulting, Inc. All rights reserved.
+# Copyright 2018 Joyent, Inc.
 #
 
 [DEFAULT]
@@ -484,7 +485,9 @@ tests = ['reservation_001_pos', 'reservation_002_pos', 'reservation_003_pos',
     'reservation_007_pos', 'reservation_008_pos', 'reservation_009_pos',
     'reservation_010_pos', 'reservation_011_pos', 'reservation_012_pos',
     'reservation_013_pos', 'reservation_014_pos', 'reservation_015_pos',
-    'reservation_016_pos', 'reservation_017_pos', 'reservation_018_pos']
+    'reservation_016_pos', 'reservation_017_pos', 'reservation_018_pos',
+    'reservation_019_pos', 'reservation_020_pos', 'reservation_021_neg',
+    'reservation_022_pos']
 
 [/opt/zfs-tests/tests/functional/rootpool]
 tests = ['rootpool_002_neg', 'rootpool_003_neg', 'rootpool_007_pos']
diff --git a/usr/src/test/zfs-tests/tests/functional/cli_root/zpool_import/import_rewind_config_changed.ksh b/usr/src/test/zfs-tests/tests/functional/cli_root/zpool_import/import_rewind_config_changed.ksh
index 7b5870b8d6..1e86a66b7c 100644
--- a/usr/src/test/zfs-tests/tests/functional/cli_root/zpool_import/import_rewind_config_changed.ksh
+++ b/usr/src/test/zfs-tests/tests/functional/cli_root/zpool_import/import_rewind_config_changed.ksh
@@ -12,7 +12,7 @@
 #
 
 #
-# Copyright (c) 2017 by Delphix. All rights reserved.
+# Copyright (c) 2016, 2018 by Delphix. All rights reserved.
 #
 
 . $STF_SUITE/tests/functional/cli_root/zpool_import/zpool_import.kshlib
@@ -49,6 +49,7 @@ function custom_cleanup
 	set_vdev_validate_skip 0
 	cleanup
 	log_must mdb_ctf_set_int vdev_min_ms_count 0t16
+	log_must mdb_ctf_set_int spa_allocators 0t4
 }
 
 log_onexit custom_cleanup
@@ -207,6 +208,10 @@ increase_device_sizes $(( FILE_SIZE * 4 ))
 # reduce the chance of reusing a metaslab that holds old MOS metadata.
 log_must mdb_ctf_set_int vdev_min_ms_count 0t150
 
+# Decrease the number of allocators for pools created during this test,
+# to increase the odds that metadata survives from old txgs.
+log_must mdb_ctf_set_int spa_allocators 0t1
+
 # Part of the rewind test is to see how it reacts to path changes
 typeset pathstochange="$VDEV0 $VDEV1 $VDEV2 $VDEV3"
 
diff --git a/usr/src/test/zfs-tests/tests/functional/pool_checkpoint/checkpoint_discard_busy.ksh b/usr/src/test/zfs-tests/tests/functional/pool_checkpoint/checkpoint_discard_busy.ksh
index c819d664f8..e62124c475 100644
--- a/usr/src/test/zfs-tests/tests/functional/pool_checkpoint/checkpoint_discard_busy.ksh
+++ b/usr/src/test/zfs-tests/tests/functional/pool_checkpoint/checkpoint_discard_busy.ksh
@@ -19,7 +19,7 @@
 
 #
 # DESCRIPTION:
-# 	Discard checkpoint on a stressed pool. Ensure that we can
+#	Discard checkpoint on a stressed pool. Ensure that we can
 #	export and import the pool while discarding but not run any
 #	operations that have to do with the checkpoint or change the
 #	pool's config.
@@ -63,6 +63,10 @@ log_onexit test_cleanup
 # the current setup the checkpoint space maps should
 # have tens of thousands of entries.
 #
+# Note: If two-words entries are used in the space
+#	map, we should have even more time to
+#	verify this.
+#
 mdb_ctf_set_int zfs_spa_discard_memory_limit 0t128
 
 log_must zpool checkpoint $NESTEDPOOL
diff --git a/usr/src/test/zfs-tests/tests/functional/reservation/reservation_019_pos.sh b/usr/src/test/zfs-tests/tests/functional/reservation/reservation_019_pos.sh
new file mode 100644
index 0000000000..5c63d63a82
--- /dev/null
+++ b/usr/src/test/zfs-tests/tests/functional/reservation/reservation_019_pos.sh
@@ -0,0 +1,65 @@
+#!/usr/bin/bash -p
+#
+# This file and its contents are supplied under the terms of the
+# Common Development and Distribution License ("CDDL"), version 1.0.
+# You may only use this file in accordance with the terms of version
+# 1.0 of the CDDL.
+#
+# A full copy of the text of the CDDL should have accompanied this
+# source.  A copy of the CDDL is also available via the Internet at
+# http://www.illumos.org/license/CDDL.
+#
+
+#
+# Copyright 2018 Joyent, Inc.
+#
+
+. $STF_SUITE/include/libtest.shlib
+. $STF_SUITE/tests/functional/reservation/reservation.shlib
+
+#
+# DESCRIPTION:
+#
+# A thin provisioned volume can become thick provisioned with 'zfs set
+# refreservation=auto'.
+#
+# STRATEGY:
+# 1) Create a sparse value.
+# 2) Use zfs set refreservation=auto to make it thick provisioned.
+# 3) Verify that refreservation is now the size predicted by
+# volsize_to_reservation().
+#
+
+verify_runnable "global"
+
+function cleanup
+{
+	if datasetexists $TESTPOOL/$TESTVOL; then
+		log_must zfs destroy -f $TESTPOOL/$TESTVOL
+	fi
+}
+
+log_onexit cleanup
+
+log_assert "A thin provisioned volume can become thick provisioned with" \
+    "'zfs set refreservation=auto'."
+
+space_avail=$(get_prop available $TESTPOOL)
+(( vol_size = (space_avail / 2) & ~(1024 * 1024 - 1) ))
+
+vol=$TESTPOOL/$TESTVOL
+
+# Create sparse vol and verify
+log_must zfs create -V $vol_size -s $vol
+resv=$(get_prop refreservation $vol)
+log_must test $resv -eq 0
+
+# Set refreservation
+log_must zfs set refreservation=auto $vol
+
+# Verify
+resv=$(get_prop refreservation $vol)
+expected=$(volsize_to_reservation $vol $vol_size)
+log_must test $resv -eq $expected
+
+log_pass "Setting refreservation=auto set refreservation to expected value"
diff --git a/usr/src/test/zfs-tests/tests/functional/reservation/reservation_020_pos.sh b/usr/src/test/zfs-tests/tests/functional/reservation/reservation_020_pos.sh
new file mode 100644
index 0000000000..554f496b07
--- /dev/null
+++ b/usr/src/test/zfs-tests/tests/functional/reservation/reservation_020_pos.sh
@@ -0,0 +1,66 @@
+#!/usr/bin/bash -p
+#
+# This file and its contents are supplied under the terms of the
+# Common Development and Distribution License ("CDDL"), version 1.0.
+# You may only use this file in accordance with the terms of version
+# 1.0 of the CDDL.
+#
+# A full copy of the text of the CDDL should have accompanied this
+# source.  A copy of the CDDL is also available via the Internet at
+# http://www.illumos.org/license/CDDL.
+#
+
+#
+# Copyright 2018 Joyent, Inc.
+#
+
+. $STF_SUITE/include/libtest.shlib
+. $STF_SUITE/tests/functional/reservation/reservation.shlib
+
+#
+# DESCRIPTION:
+#
+# Cloning a thick provisioned volume results in a sparse volume
+#
+# STRATEGY:
+# 1) Create a thick provisioned volume.
+# 2) Snapshot and clone it.
+# 3) Verify that the clone is sparse.
+#
+
+verify_runnable "global"
+
+function cleanup
+{
+	if datasetexists $TESTPOOL/$TESTVOL; then
+		# Destroy first vol and descendants in one go.
+		log_must zfs destroy -Rf $TESTPOOL/$TESTVOL
+	fi
+}
+
+log_onexit cleanup
+
+log_assert "Cloning a thick provisioned volume results in a sparse volume"
+
+space_avail=$(get_prop available $TESTPOOL)
+(( vol_size = (space_avail / 4) & ~(1024 * 1024 - 1) ))
+
+vol=$TESTPOOL/$TESTVOL
+snap=$vol@clone
+vol2=$TESTPOOL/$TESTVOL2
+
+# Create sparse vol and verify
+log_must zfs create -V $vol_size $vol
+resv=$(get_prop refreservation $vol)
+expected=$(volsize_to_reservation $vol $vol_size)
+log_must test $resv -eq $expected
+
+# Clone it
+log_must zfs snapshot $snap
+log_must zfs clone $snap $vol2
+
+# Verify
+resv=$(get_prop refreservation $vol2)
+log_must test $resv -eq 0
+
+log_pass "Cloning a thick provisioned volume results in a sparse volume"
diff --git a/usr/src/test/zfs-tests/tests/functional/reservation/reservation_021_neg.sh b/usr/src/test/zfs-tests/tests/functional/reservation/reservation_021_neg.sh
new file mode 100644
index 0000000000..249cb6e2ae
--- /dev/null
+++ b/usr/src/test/zfs-tests/tests/functional/reservation/reservation_021_neg.sh
@@ -0,0 +1,74 @@
+#!/usr/bin/bash -p
+#
+# This file and its contents are supplied under the terms of the
+# Common Development and Distribution License ("CDDL"), version 1.0.
+# You may only use this file in accordance with the terms of version
+# 1.0 of the CDDL.
+#
+# A full copy of the text of the CDDL should have accompanied this
+# source.  A copy of the CDDL is also available via the Internet at
+# http://www.illumos.org/license/CDDL.
+#
+
+#
+# Copyright 2018 Joyent, Inc.
+#
+
+. $STF_SUITE/include/libtest.shlib
+. $STF_SUITE/tests/functional/reservation/reservation.shlib
+
+#
+# DESCRIPTION:
+#
+# The use of refreservation=auto on a filesystem does not change the
+# refreservation and results in an error.
+#
+# STRATEGY:
+# 1) Create a filesystem
+# 2) Verify that zfs set refreservation=auto fails without changing
+# refreservation from none.
+# 3) Set refreservation to a valid value.
+# 4) Verify that zfs set refreservation=auto fails without changing
+# refreservation from the previous value.
+#
+
+verify_runnable "both"
+
+fs=$TESTPOOL/$TESTFS/$(basename $0).$$
+
+function cleanup
+{
+	if datasetexists "$fs"; then
+		log_must zfs destroy -f "$fs"
+	fi
+}
+
+log_onexit cleanup
+
+log_assert "refreservation=auto on a filesystem generates an error without" \
+	"changing refreservation"
+
+space_avail=$(get_prop available $TESTPOOL)
+(( fs_size = space_avail / 4 ))
+
+# Create a filesystem with no refreservation
+log_must zfs create $fs
+resv=$(get_prop refreservation $fs)
+log_must test $resv -eq 0
+
+# Verify that refreservation=auto fails without altering refreservation
+log_mustnot zfs set refreservation=auto $fs
+resv=$(get_prop refreservation $fs)
+log_must test $resv -eq 0
+
+# Set refreservation and verify
+log_must zfs set refreservation=$fs_size $fs
+resv=$(get_prop refreservation $fs)
+log_must test $resv -eq $fs_size
+
+# Verify that refreservation=auto fails without altering refreservation
+log_mustnot zfs set refreservation=auto $fs
+resv=$(get_prop refreservation $fs)
+log_must test $resv -eq $fs_size
+
+log_pass "refreservation=auto does not work on filesystems, as expected"
diff --git a/usr/src/test/zfs-tests/tests/functional/reservation/reservation_022_pos.sh b/usr/src/test/zfs-tests/tests/functional/reservation/reservation_022_pos.sh
new file mode 100644
index 0000000000..7909d0e794
--- /dev/null
+++ b/usr/src/test/zfs-tests/tests/functional/reservation/reservation_022_pos.sh
@@ -0,0 +1,84 @@
+#!/usr/bin/bash -p
+#
+# This file and its contents are supplied under the terms of the
+# Common Development and Distribution License ("CDDL"), version 1.0.
+# You may only use this file in accordance with the terms of version
+# 1.0 of the CDDL.
+#
+# A full copy of the text of the CDDL should have accompanied this
+# source.  A copy of the CDDL is also available via the Internet at
+# http://www.illumos.org/license/CDDL.
+#
+
+#
+# Copyright 2018 Joyent, Inc.
+#
+
+. $STF_SUITE/include/libtest.shlib
+. $STF_SUITE/tests/functional/reservation/reservation.shlib
+
+#
+# DESCRIPTION:
+#
+# Cloning a volume with -o refreservation=auto creates a thick provisioned
+# volume
+#
+# STRATEGY:
+# 1) Create a sparse volume.
+# 2) Snapshot and clone it, using clone -o refreservation=auto.
+# 3) Verify that the clone has refreservation that matches the size predicted by
+#    volsize_to_reservation().
+# 4) Snapshot this second volume and clone it, using clone -o
+#    refreservation=auto.
+# 5) Verify that the second clone has refreservation that matches the size
+#    predicted by volsize_to_reservation().
+#
+
+verify_runnable "global"
+
+function cleanup
+{
+	if datasetexists $TESTPOOL/$TESTVOL; then
+		# Destroy first vol and descendants in one go.
+		log_must zfs destroy -Rf $TESTPOOL/$TESTVOL
+	fi
+}
+
+log_onexit cleanup
+
+log_assert "Cloning a volume with -o refreservation=auto creates a thick" \
+    "provisioned volume"
+
+space_avail=$(get_prop available $TESTPOOL)
+(( vol_size = (space_avail / 4) & ~(1024 * 1024 - 1) ))
+
+vol=$TESTPOOL/$TESTVOL
+vol2=$TESTPOOL/$TESTVOL2
+vol3=$TESTPOOL/$TESTVOL2-again
+
+# Create sparse vol and verify
+log_must zfs create -s -V $vol_size $vol
+resv=$(get_prop refreservation $vol)
+log_must test $resv -eq 0
+
+# Clone it
+snap=$vol@clone
+log_must zfs snapshot $snap
+log_must zfs clone -o refreservation=auto $snap $vol2
+
+# Verify it is thick provisioned
+resv=$(get_prop refreservation $vol2)
+expected=$(volsize_to_reservation $vol2 $vol_size)
+log_must test $resv -eq $expected
+
+# Clone the thick provisioned volume
+snap=$vol2@clone
+log_must zfs snapshot $snap
+log_must zfs clone -o refreservation=auto $snap $vol3
+
+# Verify new newest clone is also thick provisioned
+resv=$(get_prop refreservation $vol3)
+expected=$(volsize_to_reservation $vol3 $vol_size)
+log_must test $resv -eq $expected
+
+log_pass "Cloning a thick provisioned volume results in a sparse volume"
diff --git a/usr/src/test/zfs-tests/tests/functional/slog/slog_014_pos.ksh b/usr/src/test/zfs-tests/tests/functional/slog/slog_014_pos.ksh
index b9dbc6c97e..621ac23aa9 100644
--- a/usr/src/test/zfs-tests/tests/functional/slog/slog_014_pos.ksh
+++ b/usr/src/test/zfs-tests/tests/functional/slog/slog_014_pos.ksh
@@ -26,7 +26,7 @@
 #
 
 #
-# Copyright (c) 2013, 2016 by Delphix. All rights reserved.
+# Copyright (c) 2013, 2018 by Delphix. All rights reserved.
 #
 
 . $STF_SUITE/tests/functional/slog/slog.kshlib
@@ -52,9 +52,19 @@ do
 		log_must zpool create $TESTPOOL $type $VDEV $spare $SDEV \
 			log $LDEV
 
+                # Create a file to be corrupted
+                dd if=/dev/urandom of=/$TESTPOOL/filler bs=1024k count=50
+
+                #
+                # Ensure the file has been synced out before attempting to
+                # corrupt its contents.
+                #
+                sync
+
+		#
 		# Corrupt a pool device to make the pool DEGRADED
-		dd if=/dev/urandom of=/$TESTPOOL/filler bs=1024k count=50
 		# The oseek value below is to skip past the vdev label.
+		#
 		log_must dd if=/dev/urandom of=$VDIR/a bs=1024k oseek=4 \
 		    conv=notrunc count=50
 		log_must zpool scrub $TESTPOOL
diff --git a/usr/src/tools/ndrgen/ndrgen.sh b/usr/src/tools/ndrgen/ndrgen.sh
index c74253b6d2..19dbb9f8e5 100644
--- a/usr/src/tools/ndrgen/ndrgen.sh
+++ b/usr/src/tools/ndrgen/ndrgen.sh
@@ -19,16 +19,24 @@
 #
 # CDDL HEADER END
 #
+
 #
 # Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
 # Use is subject to license terms.
 #
+# Copyright 2013 Nexenta Systems, Inc.  All rights reserved.
+#
 
 # This is a wrapper script around the ndrgen compiler (ndrgen1).
-# CC must be defined in the environment or on the command line.
 
-NDRPROG="${0%/*}/ndrgen1"
-INCDIR=${ROOT}/usr/include/smbsrv
+NDRPROG="${0}1"
+
+# Note: most *.ndl files require an ANSI-compatible cpp,
+# so we can NOT use /usr/lib/cpp or /usr/ccs/lib/cpp
+# Wish there was an easier way to get an ANSI cpp.
+CPP="${CC} -E"
+CPPFLAGS="-DNDRGEN"
+V_FLAG=
 
 PROGNAME=`basename $0`
 
@@ -38,60 +46,61 @@ ndrgen_usage()
 		print "$PROGNAME: ERROR: $1"
 	fi
 
-	echo "usage: $PROGNAME [-Y cpp-path] file [file]..."
+	echo "usage: $PROGNAME [options] file.ndl [file.ndl]..."
+	echo "	options: -Y cc-path -Ddefine -Iinclude"
 	exit 1
 }
 
-# Copy header text from the input ndl file to the generated ndr C file.
-ndrgen_copy_header()
+# Process the input ndl file ($1) generating C code on stdout.
+process()
 {
-	ndl_file=$1
-	ndr_file=$2
 
+	# Put the standard top matter
+	#
+	# Want the include directive to have just
+	# include "file.ndl" (no path) so...
+	inc_ndl=`basename $1`
+	cat - << EOF
+/*
+ * Please do not edit this file.
+ * It was generated using ndrgen.
+ */
+
+#include <strings.h>
+#include <libmlrpc/ndr.h>
+#include "$inc_ndl"
+EOF
+
+	# Put optional custom top matter
 	nawk 'BEGIN { copy=0; }
 	/^\/\* NDRGEN_HEADER_BEGIN \*\// { copy=1; next; }
 	/^\/\* NDRGEN_HEADER_END \*\// { copy=0; next; }
-	/./ { if (copy==1) print; }' < $ndl_file > $ndr_file
+	/./ { if (copy==1) print; }' $1
+
+	# now the real ndrgen output
+	[ -n "$V_FLAG" ] &&
+	  echo "$CPP $CPPFLAGS $1 | $NDRPROG" >&2
+	$CPP $CPPFLAGS $1 | $NDRPROG
 }
 
-if [[ $# -lt 1 ]] ; then
-	ndrgen_usage
-fi
 
-while getopts "Y" FLAG $*; do
+while getopts "D:I:Y:V" FLAG
+do
 	case $FLAG in
-	Y)
-		CC_FLAG="y"
-		;;
-	*)
-		ndrgen_usage
-		;;
+	D|I)	CPPFLAGS="$CPPFLAGS -${FLAG}${OPTARG}";;
+	Y)	CPP="$OPTARG";;
+	V)	V_FLAG="V";;
+	*)	ndrgen_usage;;
 	esac
 done
+shift $(($OPTIND - 1))
 
-if [[ $CC_FLAG = "y" ]] ; then
-	shift $(($OPTIND - 1))
-
-	if [[ $# -lt 1 ]] ; then
-		ndrgen_usage "C pre-processor path is missing"
-	else
-		CC=$1
-		shift $(($OPTIND - 1))
-
-		# Check for cw being invoked with -_cc or -_gcc
-		if [[ $1 = "-_cc" || $1 = "-_gcc" ]] ; then
-			CC_ARG=$1
-			shift $(($OPTIND - 1))
-		fi
-	fi
-fi
-
-if [[ $CC = "" ]] ; then
-	ndrgen_usage "C pre-processor is not defined"
+if [[ $# -lt 1 ]] ; then
+	ndrgen_usage
 fi
 
-if [ ! -f $CC ] || [ ! -x $CC ] ; then
-	ndrgen_usage "cannot run $CC"
+if [ ! -x $CPP ] ; then
+	ndrgen_usage "cannot run $CPP"
 fi
 
 for i
@@ -101,36 +110,9 @@ do
 		exit 1
 	fi
 
-	BASENAME=`basename $i .ndl`
-	TMP_NAME=$BASENAME.ndl.c
-
-	cp $i $TMP_NAME
-
-	if $CC $CC_ARG -E  -D__a64 -D__EXTENSIONS__ -D_FILE_OFFSET_BITS=64 \
-		-I. -I${INCDIR} -I${INCDIR}/ndl -DNDRGEN $TMP_NAME | \
-		$NDRPROG > $BASENAME.raw
-	then
-		touch ${BASENAME}_ndr.c
-		ndrgen_copy_header $i ${BASENAME}_ndr.c
-
-		cat - << EOF >> ${BASENAME}_ndr.c
-/*
- * Please do not edit this file.
- * It was generated using ndrgen.
- */
-
-#include <strings.h>
-#include <smbsrv/ndr.h>
-#include <smbsrv/ndl/$BASENAME.ndl>
-EOF
-
-		cat $BASENAME.raw >> ${BASENAME}_ndr.c
-
-		rm -f $BASENAME.raw
-		rm -f $TMP_NAME
-	else
-		rm -f $BASENAME.raw
-		rm -f $TMP_NAME
-		exit 1
-	fi
+	base=`basename $i .ndl`
+	process $i > ${base}_ndr.c || {
+	  echo "ndrgen error";
+	  rm ${base}_ndr.c;
+	}
 done
diff --git a/usr/src/tools/quick/make-smbclnt b/usr/src/tools/quick/make-smbclnt
new file mode 100755
index 0000000000..1b65f50a71
--- /dev/null
+++ b/usr/src/tools/quick/make-smbclnt
@@ -0,0 +1,304 @@
+#!/bin/ksh
+#
+# This file and its contents are supplied under the terms of the
+# Common Development and Distribution License ("CDDL"), version 1.0.
+# You may only use this file in accordance with the terms of version
+# 1.0 of the CDDL.
+#
+# A full copy of the text of the CDDL should have accompanied this
+# source.  A copy of the CDDL is also available via the Internet at
+# http://www.illumos.org/license/CDDL.
+#
+
+#
+# Copyright 2014 Nexenta Systems, Inc.  All rights reserved.
+#
+
+# Use distributed make (dmake) by default.
+make=${MAKE:-dmake}
+
+CLOSED_IS_PRESENT=no
+export CLOSED_IS_PRESENT
+
+# Do this if you want to use dbx or gdb
+# export SOURCEDEBUG=yes
+
+[ -n "$SRC" ] || {
+  echo "SRC not set.  Run 'ws' or 'bldenv' first."
+  exit 1
+}
+
+cpu=`uname -p`
+case $cpu in
+i386)
+	x=intel
+	kmdb_arch="amd64"
+	mdb_arch="ia32 amd64"
+	arch64=amd64
+	;;
+sparc)
+	x=sparc
+	kmdb_arch=v9
+	mdb_arch="v7 v9"
+	arch64=sparcv9
+	;;
+*)  echo "Huh?" ; exit 1;;
+esac
+
+################################################################
+
+build_tools() {
+  test -f $SRC/tools/proto/root_i386-nd/opt/onbld/bin/genoffsets ||
+    (cd $SRC/tools && $make install)
+  (cd $SRC/common/mapfiles; $make install)
+}
+
+clobber_tools() {
+  (cd $SRC/tools && $make clobber)
+  (cd $SRC/common/mapfiles; $make clobber)
+}
+
+################################################################
+
+do_hdrs() {
+
+targ=$1
+if [ "$targ" = clobber ]
+then
+  (cd $SRC/uts && $make -k clobber_h)
+  (cd $SRC/head && $make clobber)
+fi
+
+if [ "$targ" = install ]
+then
+  targ=install_h
+
+  # Just the parts of "make sgs" we need, and
+  # skip them if they appear to be done.
+  # ... stuff under $SRC
+  test -f $SRC/uts/common/sys/priv_names.h ||
+    (cd $SRC/uts && $make -k all_h)
+
+  test -f $SRC/head/rpcsvc/nispasswd.h ||
+    (cd $SRC/head && $make -k install_h)
+
+  # ... stuff under $ROOT (proto area)
+  test -d $ROOT/usr/include/sys ||
+    (cd $SRC && $make rootdirs)
+  test -f $ROOT/usr/include/sys/types.h ||
+    (cd $SRC/uts && $make -k install_h)
+  test -f $ROOT/usr/include/rpcsvc/daemon_utils.h ||
+    (cd $SRC/head && $make install_h)
+
+  # always update the smb headers to be safe
+  (cd $SRC/uts/common/smb && $make -k install_h)
+
+fi
+
+# Need some library headers too...
+for lib in \
+  libcryptoutil \
+  libmlrpc \
+  libpam \
+  libsec \
+  libshare \
+  libsmbfs \
+  passwdutil
+do
+  (cd $SRC/lib/$lib && $make $targ)
+done
+}
+
+################################################################
+
+do_kern() {
+  case $1 in
+  lint) targ=modlintlib ;;
+  *) targ=$1 ;;
+  esac
+  ( unset SOURCEDEBUG ;
+  (cd $SRC/uts/$x/nsmb && $make $targ) ;
+  (cd $SRC/uts/$x/smbfs && $make $targ) )
+}
+
+################################################################
+
+# Note lib1 builds prerequisite libraries not delivered by the
+# tar file we create below.  To accelerate clean/install, we
+# skip these on clean (but still nuke them for clobber)
+
+do_lib1() {
+  :
+}
+
+# lib2 builds stuff we include in the tar file,
+# or that we don't mind rebuilding after clean.
+
+do_lib2() {
+
+(cd $SRC/lib/libsmbfs && $make $1)
+[ "$1" = install ] &&
+  (cd $SRC/lib/libsmbfs && $make _msg)
+(cd $SRC/lib/libmlrpc && $make $1)
+(cd $SRC/lib/libshare && $make $1 PLUGINS=smbfs)
+(cd $SRC/lib/passwdutil && $make $1)
+(cd $SRC/lib/pam_modules/smbfs && $make $1)
+
+}
+
+################################################################
+
+do_cmds() {
+
+case $1 in
+install)
+  # mount programs need fslib.o
+  (cd $SRC/cmd/fs.d && $make fslib.o)
+  (cd $SRC/cmd/fs.d/smbclnt && $make $1 catalog)
+  ;;
+clean|clobber)
+  (cd $SRC/cmd/fs.d/smbclnt && $make $1)
+  (cd $SRC/cmd/fs.d && $make ${1}_local)
+  ;;
+esac
+
+# Build the MDB modules, WITH the linktest
+(cd $SRC/cmd/mdb/tools && $make $1)
+
+# kmdb_arch is 64-bit only
+for a in $kmdb_arch
+do
+  case $1 in
+  install|lint)
+    (cd $SRC/cmd/mdb/$x/$a/kmdb &&
+	$make kmdb_modlinktest.o )
+    ;;
+  clean|clobber)
+    (cd $SRC/cmd/mdb/$x/$a/kmdb &&
+	$make -k $1 )
+    ;;
+  esac
+
+  (cd $SRC/cmd/mdb/$x/$a/nsmb &&
+	$make $1 KMDB_LINKTEST_ENABLE= )
+  (cd $SRC/cmd/mdb/$x/$a/smbfs &&
+	$make $1 KMDB_LINKTEST_ENABLE= )
+done
+}
+
+
+################################################################
+# This builds $SRC/TAGS (and cscope.files) in a helpful order.
+
+do_tags() {
+	(cd $SRC ;
+	find uts/common/sys -name '*.[ch]' -print |sort
+	find uts/common/net -name '*.[ch]' -print |sort
+	find uts/common/netinet -name '*.[ch]' -print |sort
+	find uts/common/smb -name '*.[ch]' -print |sort
+	find uts/common/netsmb -name '*.[ch]' -print |sort
+	find uts/common/fs/smbclnt -name '*.[ch]' -print |sort
+	find head -name '*.h' -print |sort
+	find lib/libsmbfs -name '*.[ch]' -print |sort
+	find cmd/fs.d/smbclnt -name '*.[ch]' -print |sort
+	find common/smbclnt -name '*.[ch]' -print |sort
+	) > $SRC/cscope.files
+
+	(cd $SRC ;
+	exctags -e --langmap=c:+.ndl -h ndl -L - < cscope.files
+	cscope -b )
+}
+
+################################################################
+# This creates a tarfile one can use to update a test machine.
+
+do_tar() {
+	git_rev=`git rev-parse --short=8 HEAD`
+	files="
+lib/svc/manifest/network/smb/client.xml
+lib/svc/method/smb-client
+opt/smbcl-tests/tests/srvenum
+opt/smbcl-tests/tests/srvinfo
+opt/smbcl-tests/tests/tconn
+usr/bin/smbutil
+usr/kernel/drv/$arch64/nsmb
+usr/kernel/fs/$arch64/smbfs
+usr/kernel/kmdb/$arch64/nsmb
+usr/kernel/kmdb/$arch64/smbfs
+usr/lib/$arch64/libsmbfs.so.1
+usr/lib/fs/smbfs/$arch64/libshare_smbfs.so.1
+usr/lib/fs/smbfs/chacl
+usr/lib/fs/smbfs/dfshares
+usr/lib/fs/smbfs/libshare_smbfs.so.1
+usr/lib/fs/smbfs/lsacl
+usr/lib/fs/smbfs/mount
+usr/lib/fs/smbfs/share
+usr/lib/fs/smbfs/umount
+usr/lib/fs/smbfs/unshare
+usr/lib/libmlrpc.so.2
+usr/lib/libsmbfs.so.1
+usr/lib/mdb/kvm/$arch64/nsmb.so
+usr/lib/mdb/kvm/$arch64/smbfs.so
+usr/lib/mdb/kvm/nsmb.so
+usr/lib/mdb/kvm/smbfs.so
+usr/lib/security/$arch64/pam_smbfs_login.so.1
+usr/lib/security/pam_smbfs_login.so.1
+usr/lib/smbfs/smbiod
+usr/lib/smbfs/smbiod-svc
+"
+
+	(cd $ROOT && tar cfj ../../smbclnt-${git_rev}.tar.bz2 $files)
+}
+
+################################################################
+
+if [ "$1" = "" ]; then
+  set '?' # force usage
+fi
+
+set -x
+
+for arg
+do
+  case "$arg" in
+  install)
+    build_tools
+    set -e
+    do_hdrs $arg
+    do_kern $arg
+    do_lib1 $arg
+    do_lib2 $arg
+    do_cmds $arg
+    ;;
+  lint)
+    do_kern $arg
+    do_lib1 $arg
+    do_lib2 $arg
+    do_cmds $arg
+    ;;
+  clean)
+    # intentionally skip: lib1, hdrs, tools
+    do_cmds $arg
+    do_lib2 $arg
+    do_kern $arg
+    ;;
+  clobber)
+    do_cmds $arg
+    do_lib2 $arg
+    do_lib1 $arg
+    do_kern $arg
+    do_hdrs $arg
+    clobber_tools
+    ;;
+  tags)
+    do_tags
+    ;;
+  tar)
+    do_tar
+    ;;
+  *)
+    echo "Usage: $0 {install|lint|clean|clobber|tags|tar}";
+    exit 1;
+    ;;
+  esac
+done
diff --git a/usr/src/tools/quick/make-smbsrv b/usr/src/tools/quick/make-smbsrv
index e808bffee2..18c1baddcf 100755
--- a/usr/src/tools/quick/make-smbsrv
+++ b/usr/src/tools/quick/make-smbsrv
@@ -107,8 +107,9 @@ for lib in \
   libdevid \
   libfakekernel	\
   libgss \
-  libkrb5 \
   libidmap \
+  libkrb5 \
+  libmlrpc \
   libpam \
   libsec \
   libscf \
@@ -164,7 +165,8 @@ do_lib2() {
 for lib in \
   libfakekernel \
   libads \
-  libsmbfs
+  libsmbfs \
+  libmlrpc
 do
   (cd $SRC/lib/$lib && $make $1)
 done
@@ -287,7 +289,7 @@ usr/lib/mdb/kvm/$arch64/smbsrv.so
 usr/lib/reparse/libreparse_smb.so.1
 usr/lib/security/pam_smb_passwd.so.1
 usr/lib/smbsrv/dtrace
-usr/lib/smbsrv/libmlrpc.so.1
+usr/lib/libmlrpc.so.2
 usr/lib/smbsrv/libmlsvc.so.1
 usr/lib/smbsrv/libsmb.so.1
 usr/lib/smbsrv/libsmbns.so.1
diff --git a/usr/src/tools/scripts/bldenv.sh b/usr/src/tools/scripts/bldenv.sh
index 71987a44b5..b9b71d908d 100644
--- a/usr/src/tools/scripts/bldenv.sh
+++ b/usr/src/tools/scripts/bldenv.sh
@@ -290,6 +290,9 @@ if "${flags.t}" ; then
 	export STABS="${TOOLS_PROTO}/opt/onbld/bin/${MACH}/stabs"
 	export CTFSTABS="${TOOLS_PROTO}/opt/onbld/bin/${MACH}/ctfstabs"
 	export GENOFFSETS="${TOOLS_PROTO}/opt/onbld/bin/genoffsets"
+	export CTFCONVERT="${TOOLS_PROTO}/opt/onbld/bin/${MACH}/ctfconvert"
+	export CTFMERGE="${TOOLS_PROTO}/opt/onbld/bin/${MACH}/ctfmerge"
+	export NDRGEN="${TOOLS_PROTO}/opt/onbld/bin/${MACH}/ndrgen"
 
 	PATH="${TOOLS_PROTO}/opt/onbld/bin/${MACH}:${PATH}"
 	PATH="${TOOLS_PROTO}/opt/onbld/bin:${PATH}"
diff --git a/usr/src/uts/common/avs/ns/rdc/rdc_diskq.c b/usr/src/uts/common/avs/ns/rdc/rdc_diskq.c
index 8b292989b9..b01866c9cc 100644
--- a/usr/src/uts/common/avs/ns/rdc/rdc_diskq.c
+++ b/usr/src/uts/common/avs/ns/rdc/rdc_diskq.c
@@ -192,7 +192,7 @@ rdc_open_diskq(rdc_k_info_t *krdc)
 
 	mutex_enter(&grp->diskqmutex);
 	mutexheld++;
-	if (&urdc->disk_queue[0] == '\0') {
+	if (urdc->disk_queue[0] == '\0') {
 		goto fail;
 	}
 
@@ -606,7 +606,7 @@ rdc_read_diskq_header(rdc_k_info_t *krdc)
 		(void) snprintf(buf, NSC_MAXPATH, "%s:%s", urdc->secondary.intf,
 		    &urdc->secondary.intf[0]);
 		cmn_err(CE_WARN, "!Disk Queue Header read failed for %s",
-		    &urdc->group_name[0] == '\0' ? buf:
+		    urdc->group_name[0] == '\0' ? buf:
 		    &urdc->group_name[0]);
 		return (-1);
 	}
@@ -626,7 +626,7 @@ rdc_read_diskq_header(rdc_k_info_t *krdc)
 		(void) snprintf(buf, NSC_MAXPATH, "%s:%s", urdc->secondary.intf,
 		    &urdc->secondary.file[0]);
 		cmn_err(CE_WARN, "!Disk Queue Header read failed(%d) for %s",
-		    rc, &urdc->group_name[0] == '\0' ? buf :
+		    rc, urdc->group_name[0] == '\0' ? buf :
 		    &urdc->group_name[0]);
 		return (-1);
 	}
diff --git a/usr/src/uts/common/c2/audit_start.c b/usr/src/uts/common/c2/audit_start.c
index f82bd21e58..1f31d7dec9 100644
--- a/usr/src/uts/common/c2/audit_start.c
+++ b/usr/src/uts/common/c2/audit_start.c
@@ -175,7 +175,7 @@ audit_start(
 
 	/* get basic event for system call */
 	tad->tad_event = audit_s2e[scid].au_event;
-	if (audit_s2e[scid].au_init != (au_event_t)AUE_NULL) {
+	if (audit_s2e[scid].au_init != (au_event_t (*)(au_event_t))NULL) {
 		/* get specific event */
 		tad->tad_event = (*audit_s2e[scid].au_init)(tad->tad_event);
 	}
diff --git a/usr/src/uts/common/fs/fdbuffer.c b/usr/src/uts/common/fs/fdbuffer.c
index 7260abe9f7..d90bbc89b0 100644
--- a/usr/src/uts/common/fs/fdbuffer.c
+++ b/usr/src/uts/common/fs/fdbuffer.c
@@ -25,8 +25,6 @@
  *
  */
 
-#pragma ident	"%Z%%M%	%I%	%E% SMI"
-
 #include <sys/types.h>
 #include <sys/cmn_err.h>
 #include <sys/kmem.h>
@@ -332,6 +330,7 @@ fdb_zero_holes(fdbuffer_t *fdb)
 			fdh = fdh->next_hole;
 			kmem_free(pfdh, sizeof (fdb_holes_t));
 		}
+		break;
 	default:
 		panic("fdb_zero_holes: Unknown fdb type.");
 		break;
diff --git a/usr/src/uts/common/fs/zfs/metaslab.c b/usr/src/uts/common/fs/zfs/metaslab.c
index 88d81c9540..1f5a7fbd26 100644
--- a/usr/src/uts/common/fs/zfs/metaslab.c
+++ b/usr/src/uts/common/fs/zfs/metaslab.c
@@ -20,7 +20,7 @@
  */
 /*
  * Copyright (c) 2005, 2010, Oracle and/or its affiliates. All rights reserved.
- * Copyright (c) 2011, 2015 by Delphix. All rights reserved.
+ * Copyright (c) 2011, 2018 by Delphix. All rights reserved.
  * Copyright (c) 2013 by Saso Kiselkov. All rights reserved.
  * Copyright (c) 2014 Integros [integros.com]
  */
@@ -217,6 +217,8 @@ static uint64_t metaslab_weight(metaslab_t *);
 static void metaslab_set_fragmentation(metaslab_t *);
 static void metaslab_free_impl(vdev_t *, uint64_t, uint64_t, boolean_t);
 static void metaslab_check_free_impl(vdev_t *, uint64_t, uint64_t);
+static void metaslab_passivate(metaslab_t *msp, uint64_t weight);
+static uint64_t metaslab_weight_from_range_tree(metaslab_t *msp);
 
 kmem_cache_t *metaslab_alloc_trace_cache;
 
@@ -236,7 +238,12 @@ metaslab_class_create(spa_t *spa, metaslab_ops_t *ops)
 	mc->mc_rotor = NULL;
 	mc->mc_ops = ops;
 	mutex_init(&mc->mc_lock, NULL, MUTEX_DEFAULT, NULL);
-	refcount_create_tracked(&mc->mc_alloc_slots);
+	mc->mc_alloc_slots = kmem_zalloc(spa->spa_alloc_count *
+	    sizeof (refcount_t), KM_SLEEP);
+	mc->mc_alloc_max_slots = kmem_zalloc(spa->spa_alloc_count *
+	    sizeof (uint64_t), KM_SLEEP);
+	for (int i = 0; i < spa->spa_alloc_count; i++)
+		refcount_create_tracked(&mc->mc_alloc_slots[i]);
 
 	return (mc);
 }
@@ -250,7 +257,12 @@ metaslab_class_destroy(metaslab_class_t *mc)
 	ASSERT(mc->mc_space == 0);
 	ASSERT(mc->mc_dspace == 0);
 
-	refcount_destroy(&mc->mc_alloc_slots);
+	for (int i = 0; i < mc->mc_spa->spa_alloc_count; i++)
+		refcount_destroy(&mc->mc_alloc_slots[i]);
+	kmem_free(mc->mc_alloc_slots, mc->mc_spa->spa_alloc_count *
+	    sizeof (refcount_t));
+	kmem_free(mc->mc_alloc_max_slots, mc->mc_spa->spa_alloc_count *
+	    sizeof (uint64_t));
 	mutex_destroy(&mc->mc_lock);
 	kmem_free(mc, sizeof (metaslab_class_t));
 }
@@ -447,6 +459,30 @@ metaslab_compare(const void *x1, const void *x2)
 	const metaslab_t *m1 = x1;
 	const metaslab_t *m2 = x2;
 
+	int sort1 = 0;
+	int sort2 = 0;
+	if (m1->ms_allocator != -1 && m1->ms_primary)
+		sort1 = 1;
+	else if (m1->ms_allocator != -1 && !m1->ms_primary)
+		sort1 = 2;
+	if (m2->ms_allocator != -1 && m2->ms_primary)
+		sort2 = 1;
+	else if (m2->ms_allocator != -1 && !m2->ms_primary)
+		sort2 = 2;
+
+	/*
+	 * Sort inactive metaslabs first, then primaries, then secondaries. When
+	 * selecting a metaslab to allocate from, an allocator first tries its
+	 * primary, then secondary active metaslab. If it doesn't have active
+	 * metaslabs, or can't allocate from them, it searches for an inactive
+	 * metaslab to activate. If it can't find a suitable one, it will steal
+	 * a primary or secondary metaslab from another allocator.
+	 */
+	if (sort1 < sort2)
+		return (-1);
+	if (sort1 > sort2)
+		return (1);
+
 	if (m1->ms_weight < m2->ms_weight)
 		return (1);
 	if (m1->ms_weight > m2->ms_weight)
@@ -598,12 +634,16 @@ metaslab_group_alloc_update(metaslab_group_t *mg)
 }
 
 metaslab_group_t *
-metaslab_group_create(metaslab_class_t *mc, vdev_t *vd)
+metaslab_group_create(metaslab_class_t *mc, vdev_t *vd, int allocators)
 {
 	metaslab_group_t *mg;
 
 	mg = kmem_zalloc(sizeof (metaslab_group_t), KM_SLEEP);
 	mutex_init(&mg->mg_lock, NULL, MUTEX_DEFAULT, NULL);
+	mg->mg_primaries = kmem_zalloc(allocators * sizeof (metaslab_t *),
+	    KM_SLEEP);
+	mg->mg_secondaries = kmem_zalloc(allocators * sizeof (metaslab_t *),
+	    KM_SLEEP);
 	avl_create(&mg->mg_metaslab_tree, metaslab_compare,
 	    sizeof (metaslab_t), offsetof(struct metaslab, ms_group_node));
 	mg->mg_vd = vd;
@@ -611,7 +651,16 @@ metaslab_group_create(metaslab_class_t *mc, vdev_t *vd)
 	mg->mg_activation_count = 0;
 	mg->mg_initialized = B_FALSE;
 	mg->mg_no_free_space = B_TRUE;
-	refcount_create_tracked(&mg->mg_alloc_queue_depth);
+	mg->mg_allocators = allocators;
+
+	mg->mg_alloc_queue_depth = kmem_zalloc(allocators * sizeof (refcount_t),
+	    KM_SLEEP);
+	mg->mg_cur_max_alloc_queue_depth = kmem_zalloc(allocators *
+	    sizeof (uint64_t), KM_SLEEP);
+	for (int i = 0; i < allocators; i++) {
+		refcount_create_tracked(&mg->mg_alloc_queue_depth[i]);
+		mg->mg_cur_max_alloc_queue_depth[i] = 0;
+	}
 
 	mg->mg_taskq = taskq_create("metaslab_group_taskq", metaslab_load_pct,
 	    minclsyspri, 10, INT_MAX, TASKQ_THREADS_CPU_PCT);
@@ -633,8 +682,20 @@ metaslab_group_destroy(metaslab_group_t *mg)
 
 	taskq_destroy(mg->mg_taskq);
 	avl_destroy(&mg->mg_metaslab_tree);
+	kmem_free(mg->mg_primaries, mg->mg_allocators * sizeof (metaslab_t *));
+	kmem_free(mg->mg_secondaries, mg->mg_allocators *
+	    sizeof (metaslab_t *));
 	mutex_destroy(&mg->mg_lock);
-	refcount_destroy(&mg->mg_alloc_queue_depth);
+
+	for (int i = 0; i < mg->mg_allocators; i++) {
+		refcount_destroy(&mg->mg_alloc_queue_depth[i]);
+		mg->mg_cur_max_alloc_queue_depth[i] = 0;
+	}
+	kmem_free(mg->mg_alloc_queue_depth, mg->mg_allocators *
+	    sizeof (refcount_t));
+	kmem_free(mg->mg_cur_max_alloc_queue_depth, mg->mg_allocators *
+	    sizeof (uint64_t));
+
 	kmem_free(mg, sizeof (metaslab_group_t));
 }
 
@@ -713,6 +774,22 @@ metaslab_group_passivate(metaslab_group_t *mg)
 	taskq_wait(mg->mg_taskq);
 	spa_config_enter(spa, locks & ~(SCL_ZIO - 1), spa, RW_WRITER);
 	metaslab_group_alloc_update(mg);
+	for (int i = 0; i < mg->mg_allocators; i++) {
+		metaslab_t *msp = mg->mg_primaries[i];
+		if (msp != NULL) {
+			mutex_enter(&msp->ms_lock);
+			metaslab_passivate(msp,
+			    metaslab_weight_from_range_tree(msp));
+			mutex_exit(&msp->ms_lock);
+		}
+		msp = mg->mg_secondaries[i];
+		if (msp != NULL) {
+			mutex_enter(&msp->ms_lock);
+			metaslab_passivate(msp,
+			    metaslab_weight_from_range_tree(msp));
+			mutex_exit(&msp->ms_lock);
+		}
+	}
 
 	mgprev = mg->mg_prev;
 	mgnext = mg->mg_next;
@@ -852,6 +929,17 @@ metaslab_group_remove(metaslab_group_t *mg, metaslab_t *msp)
 	mutex_exit(&mg->mg_lock);
 }
 
+static void
+metaslab_group_sort_impl(metaslab_group_t *mg, metaslab_t *msp, uint64_t weight)
+{
+	ASSERT(MUTEX_HELD(&mg->mg_lock));
+	ASSERT(msp->ms_group == mg);
+	avl_remove(&mg->mg_metaslab_tree, msp);
+	msp->ms_weight = weight;
+	avl_add(&mg->mg_metaslab_tree, msp);
+
+}
+
 static void
 metaslab_group_sort(metaslab_group_t *mg, metaslab_t *msp, uint64_t weight)
 {
@@ -863,10 +951,7 @@ metaslab_group_sort(metaslab_group_t *mg, metaslab_t *msp, uint64_t weight)
 	ASSERT(MUTEX_HELD(&msp->ms_lock));
 
 	mutex_enter(&mg->mg_lock);
-	ASSERT(msp->ms_group == mg);
-	avl_remove(&mg->mg_metaslab_tree, msp);
-	msp->ms_weight = weight;
-	avl_add(&mg->mg_metaslab_tree, msp);
+	metaslab_group_sort_impl(mg, msp, weight);
 	mutex_exit(&mg->mg_lock);
 }
 
@@ -914,7 +999,7 @@ metaslab_group_fragmentation(metaslab_group_t *mg)
  */
 static boolean_t
 metaslab_group_allocatable(metaslab_group_t *mg, metaslab_group_t *rotor,
-    uint64_t psize)
+    uint64_t psize, int allocator)
 {
 	spa_t *spa = mg->mg_vd->vdev_spa;
 	metaslab_class_t *mc = mg->mg_class;
@@ -943,7 +1028,7 @@ metaslab_group_allocatable(metaslab_group_t *mg, metaslab_group_t *rotor,
 	if (mg->mg_allocatable) {
 		metaslab_group_t *mgp;
 		int64_t qdepth;
-		uint64_t qmax = mg->mg_max_alloc_queue_depth;
+		uint64_t qmax = mg->mg_cur_max_alloc_queue_depth[allocator];
 
 		if (!mc->mc_alloc_throttle_enabled)
 			return (B_TRUE);
@@ -955,7 +1040,7 @@ metaslab_group_allocatable(metaslab_group_t *mg, metaslab_group_t *rotor,
 		if (mg->mg_no_free_space)
 			return (B_FALSE);
 
-		qdepth = refcount_count(&mg->mg_alloc_queue_depth);
+		qdepth = refcount_count(&mg->mg_alloc_queue_depth[allocator]);
 
 		/*
 		 * If this metaslab group is below its qmax or it's
@@ -974,9 +1059,10 @@ metaslab_group_allocatable(metaslab_group_t *mg, metaslab_group_t *rotor,
 		 * groups at the same time when we make this check.
 		 */
 		for (mgp = mg->mg_next; mgp != rotor; mgp = mgp->mg_next) {
-			qmax = mgp->mg_max_alloc_queue_depth;
+			qmax = mgp->mg_cur_max_alloc_queue_depth[allocator];
 
-			qdepth = refcount_count(&mgp->mg_alloc_queue_depth);
+			qdepth = refcount_count(
+			    &mgp->mg_alloc_queue_depth[allocator]);
 
 			/*
 			 * If there is another metaslab group that
@@ -1463,6 +1549,8 @@ metaslab_init(metaslab_group_t *mg, uint64_t id, uint64_t object, uint64_t txg,
 	ms->ms_id = id;
 	ms->ms_start = id << vd->vdev_ms_shift;
 	ms->ms_size = 1ULL << vd->vdev_ms_shift;
+	ms->ms_allocator = -1;
+	ms->ms_new = B_TRUE;
 
 	/*
 	 * We only open space map objects that already exist. All others
@@ -1558,6 +1646,7 @@ metaslab_fini(metaslab_t *msp)
 	cv_destroy(&msp->ms_load_cv);
 	mutex_destroy(&msp->ms_lock);
 	mutex_destroy(&msp->ms_sync_lock);
+	ASSERT3U(msp->ms_allocator, ==, -1);
 
 	kmem_free(msp, sizeof (metaslab_t));
 }
@@ -1954,19 +2043,59 @@ metaslab_weight(metaslab_t *msp)
 }
 
 static int
-metaslab_activate(metaslab_t *msp, uint64_t activation_weight)
+metaslab_activate_allocator(metaslab_group_t *mg, metaslab_t *msp,
+    int allocator, uint64_t activation_weight)
+{
+	/*
+	 * If we're activating for the claim code, we don't want to actually
+	 * set the metaslab up for a specific allocator.
+	 */
+	if (activation_weight == METASLAB_WEIGHT_CLAIM)
+		return (0);
+	metaslab_t **arr = (activation_weight == METASLAB_WEIGHT_PRIMARY ?
+	    mg->mg_primaries : mg->mg_secondaries);
+
+	ASSERT(MUTEX_HELD(&msp->ms_lock));
+	mutex_enter(&mg->mg_lock);
+	if (arr[allocator] != NULL) {
+		mutex_exit(&mg->mg_lock);
+		return (EEXIST);
+	}
+
+	arr[allocator] = msp;
+	ASSERT3S(msp->ms_allocator, ==, -1);
+	msp->ms_allocator = allocator;
+	msp->ms_primary = (activation_weight == METASLAB_WEIGHT_PRIMARY);
+	mutex_exit(&mg->mg_lock);
+
+	return (0);
+}
+
+static int
+metaslab_activate(metaslab_t *msp, int allocator, uint64_t activation_weight)
 {
 	ASSERT(MUTEX_HELD(&msp->ms_lock));
 
 	if ((msp->ms_weight & METASLAB_ACTIVE_MASK) == 0) {
+		int error = 0;
 		metaslab_load_wait(msp);
 		if (!msp->ms_loaded) {
-			int error = metaslab_load(msp);
-			if (error) {
+			if ((error = metaslab_load(msp)) != 0) {
 				metaslab_group_sort(msp->ms_group, msp, 0);
 				return (error);
 			}
 		}
+		if ((msp->ms_weight & METASLAB_ACTIVE_MASK) != 0) {
+			/*
+			 * The metaslab was activated for another allocator
+			 * while we were waiting, we should reselect.
+			 */
+			return (EBUSY);
+		}
+		if ((error = metaslab_activate_allocator(msp->ms_group, msp,
+		    allocator, activation_weight)) != 0) {
+			return (error);
+		}
 
 		msp->ms_activation_weight = msp->ms_weight;
 		metaslab_group_sort(msp->ms_group, msp,
@@ -1978,6 +2107,34 @@ metaslab_activate(metaslab_t *msp, uint64_t activation_weight)
 	return (0);
 }
 
+static void
+metaslab_passivate_allocator(metaslab_group_t *mg, metaslab_t *msp,
+    uint64_t weight)
+{
+	ASSERT(MUTEX_HELD(&msp->ms_lock));
+	if (msp->ms_weight & METASLAB_WEIGHT_CLAIM) {
+		metaslab_group_sort(mg, msp, weight);
+		return;
+	}
+
+	mutex_enter(&mg->mg_lock);
+	ASSERT3P(msp->ms_group, ==, mg);
+	if (msp->ms_primary) {
+		ASSERT3U(0, <=, msp->ms_allocator);
+		ASSERT3U(msp->ms_allocator, <, mg->mg_allocators);
+		ASSERT3P(mg->mg_primaries[msp->ms_allocator], ==, msp);
+		ASSERT(msp->ms_weight & METASLAB_WEIGHT_PRIMARY);
+		mg->mg_primaries[msp->ms_allocator] = NULL;
+	} else {
+		ASSERT(msp->ms_weight & METASLAB_WEIGHT_SECONDARY);
+		ASSERT3P(mg->mg_secondaries[msp->ms_allocator], ==, msp);
+		mg->mg_secondaries[msp->ms_allocator] = NULL;
+	}
+	msp->ms_allocator = -1;
+	metaslab_group_sort_impl(mg, msp, weight);
+	mutex_exit(&mg->mg_lock);
+}
+
 static void
 metaslab_passivate(metaslab_t *msp, uint64_t weight)
 {
@@ -1993,7 +2150,7 @@ metaslab_passivate(metaslab_t *msp, uint64_t weight)
 	ASSERT0(weight & METASLAB_ACTIVE_MASK);
 
 	msp->ms_activation_weight = 0;
-	metaslab_group_sort(msp->ms_group, msp, weight);
+	metaslab_passivate_allocator(msp->ms_group, msp, weight);
 	ASSERT((msp->ms_weight & METASLAB_ACTIVE_MASK) == 0);
 }
 
@@ -2096,17 +2253,6 @@ metaslab_group_preload(metaslab_group_t *mg)
  *
  * 3. The on-disk size of the space map should actually decrease.
  *
- * Checking the first condition is tricky since we don't want to walk
- * the entire AVL tree calculating the estimated on-disk size. Instead we
- * use the size-ordered range tree in the metaslab and calculate the
- * size required to write out the largest segment in our free tree. If the
- * size required to represent that segment on disk is larger than the space
- * map object then we avoid condensing this map.
- *
- * To determine the second criterion we use a best-case estimate and assume
- * each segment can be represented on-disk as a single 64-bit entry. We refer
- * to this best-case estimate as the space map's minimal form.
- *
  * Unfortunately, we cannot compute the on-disk size of the space map in this
  * context because we cannot accurately compute the effects of compression, etc.
  * Instead, we apply the heuristic described in the block comment for
@@ -2117,9 +2263,6 @@ static boolean_t
 metaslab_should_condense(metaslab_t *msp)
 {
 	space_map_t *sm = msp->ms_sm;
-	range_seg_t *rs;
-	uint64_t size, entries, segsz, object_size, optimal_size, record_size;
-	dmu_object_info_t doi;
 	vdev_t *vd = msp->ms_group->mg_vd;
 	uint64_t vdev_blocksize = 1 << vd->vdev_ashift;
 	uint64_t current_txg = spa_syncing_txg(vd->vdev_spa);
@@ -2148,34 +2291,22 @@ metaslab_should_condense(metaslab_t *msp)
 	msp->ms_condense_checked_txg = current_txg;
 
 	/*
-	 * Use the ms_allocatable_by_size range tree, which is ordered by
-	 * size, to obtain the largest segment in the free tree. We always
-	 * condense metaslabs that are empty and metaslabs for which a
-	 * condense request has been made.
+	 * We always condense metaslabs that are empty and metaslabs for
+	 * which a condense request has been made.
 	 */
-	rs = avl_last(&msp->ms_allocatable_by_size);
-	if (rs == NULL || msp->ms_condense_wanted)
+	if (avl_is_empty(&msp->ms_allocatable_by_size) ||
+	    msp->ms_condense_wanted)
 		return (B_TRUE);
 
-	/*
-	 * Calculate the number of 64-bit entries this segment would
-	 * require when written to disk. If this single segment would be
-	 * larger on-disk than the entire current on-disk structure, then
-	 * clearly condensing will increase the on-disk structure size.
-	 */
-	size = (rs->rs_end - rs->rs_start) >> sm->sm_shift;
-	entries = size / (MIN(size, SM_RUN_MAX));
-	segsz = entries * sizeof (uint64_t);
-
-	optimal_size =
-	    sizeof (uint64_t) * avl_numnodes(&msp->ms_allocatable->rt_root);
-	object_size = space_map_length(msp->ms_sm);
+	uint64_t object_size = space_map_length(msp->ms_sm);
+	uint64_t optimal_size = space_map_estimate_optimal_size(sm,
+	    msp->ms_allocatable, SM_NO_VDEVID);
 
+	dmu_object_info_t doi;
 	dmu_object_info_from_db(sm->sm_dbuf, &doi);
-	record_size = MAX(doi.doi_data_block_size, vdev_blocksize);
+	uint64_t record_size = MAX(doi.doi_data_block_size, vdev_blocksize);
 
-	return (segsz <= object_size &&
-	    object_size >= (optimal_size * zfs_condense_pct / 100) &&
+	return (object_size >= (optimal_size * zfs_condense_pct / 100) &&
 	    object_size > zfs_metaslab_condense_block_threshold * record_size);
 }
 
@@ -2250,11 +2381,11 @@ metaslab_condense(metaslab_t *msp, uint64_t txg, dmu_tx_t *tx)
 	 * optimal, this is typically close to optimal, and much cheaper to
 	 * compute.
 	 */
-	space_map_write(sm, condense_tree, SM_ALLOC, tx);
+	space_map_write(sm, condense_tree, SM_ALLOC, SM_NO_VDEVID, tx);
 	range_tree_vacate(condense_tree, NULL, NULL);
 	range_tree_destroy(condense_tree);
 
-	space_map_write(sm, msp->ms_allocatable, SM_FREE, tx);
+	space_map_write(sm, msp->ms_allocatable, SM_FREE, SM_NO_VDEVID, tx);
 	mutex_enter(&msp->ms_lock);
 	msp->ms_condensing = B_FALSE;
 }
@@ -2366,8 +2497,10 @@ metaslab_sync(metaslab_t *msp, uint64_t txg)
 		metaslab_condense(msp, txg, tx);
 	} else {
 		mutex_exit(&msp->ms_lock);
-		space_map_write(msp->ms_sm, alloctree, SM_ALLOC, tx);
-		space_map_write(msp->ms_sm, msp->ms_freeing, SM_FREE, tx);
+		space_map_write(msp->ms_sm, alloctree, SM_ALLOC,
+		    SM_NO_VDEVID, tx);
+		space_map_write(msp->ms_sm, msp->ms_freeing, SM_FREE,
+		    SM_NO_VDEVID, tx);
 		mutex_enter(&msp->ms_lock);
 	}
 
@@ -2382,7 +2515,7 @@ metaslab_sync(metaslab_t *msp, uint64_t txg)
 		 */
 		mutex_exit(&msp->ms_lock);
 		space_map_write(vd->vdev_checkpoint_sm,
-		    msp->ms_checkpointing, SM_FREE, tx);
+		    msp->ms_checkpointing, SM_FREE, SM_NO_VDEVID, tx);
 		mutex_enter(&msp->ms_lock);
 		space_map_update(vd->vdev_checkpoint_sm);
 
@@ -2574,11 +2707,18 @@ metaslab_sync_done(metaslab_t *msp, uint64_t txg)
 		vdev_dirty(vd, VDD_METASLAB, msp, txg + 1);
 	}
 
+	if (msp->ms_new) {
+		msp->ms_new = B_FALSE;
+		mutex_enter(&mg->mg_lock);
+		mg->mg_ms_ready++;
+		mutex_exit(&mg->mg_lock);
+	}
 	/*
 	 * Calculate the new weights before unloading any metaslabs.
 	 * This will give us the most accurate weighting.
 	 */
-	metaslab_group_sort(mg, msp, metaslab_weight(msp));
+	metaslab_group_sort(mg, msp, metaslab_weight(msp) |
+	    (msp->ms_weight & METASLAB_ACTIVE_MASK));
 
 	/*
 	 * If the metaslab is loaded and we've not tried to load or allocate
@@ -2590,6 +2730,10 @@ metaslab_sync_done(metaslab_t *msp, uint64_t txg)
 			VERIFY0(range_tree_space(
 			    msp->ms_allocating[(txg + t) & TXG_MASK]));
 		}
+		if (msp->ms_allocator != -1) {
+			metaslab_passivate(msp, msp->ms_weight &
+			    ~METASLAB_ACTIVE_MASK);
+		}
 
 		if (!metaslab_debug_unload)
 			metaslab_unload(msp);
@@ -2683,7 +2827,8 @@ metaslab_alloc_trace_fini(void)
  */
 static void
 metaslab_trace_add(zio_alloc_list_t *zal, metaslab_group_t *mg,
-    metaslab_t *msp, uint64_t psize, uint32_t dva_id, uint64_t offset)
+    metaslab_t *msp, uint64_t psize, uint32_t dva_id, uint64_t offset,
+    int allocator)
 {
 	if (!metaslab_trace_enabled)
 		return;
@@ -2716,6 +2861,7 @@ metaslab_trace_add(zio_alloc_list_t *zal, metaslab_group_t *mg,
 	mat->mat_dva_id = dva_id;
 	mat->mat_offset = offset;
 	mat->mat_weight = 0;
+	mat->mat_allocator = allocator;
 
 	if (msp != NULL)
 		mat->mat_weight = msp->ms_weight;
@@ -2756,35 +2902,56 @@ metaslab_trace_fini(zio_alloc_list_t *zal)
  */
 
 static void
-metaslab_group_alloc_increment(spa_t *spa, uint64_t vdev, void *tag, int flags)
+metaslab_group_alloc_increment(spa_t *spa, uint64_t vdev, void *tag, int flags,
+    int allocator)
 {
 	if (!(flags & METASLAB_ASYNC_ALLOC) ||
-	    flags & METASLAB_DONT_THROTTLE)
+	    (flags & METASLAB_DONT_THROTTLE))
 		return;
 
 	metaslab_group_t *mg = vdev_lookup_top(spa, vdev)->vdev_mg;
 	if (!mg->mg_class->mc_alloc_throttle_enabled)
 		return;
 
-	(void) refcount_add(&mg->mg_alloc_queue_depth, tag);
+	(void) refcount_add(&mg->mg_alloc_queue_depth[allocator], tag);
+}
+
+static void
+metaslab_group_increment_qdepth(metaslab_group_t *mg, int allocator)
+{
+	uint64_t max = mg->mg_max_alloc_queue_depth;
+	uint64_t cur = mg->mg_cur_max_alloc_queue_depth[allocator];
+	while (cur < max) {
+		if (atomic_cas_64(&mg->mg_cur_max_alloc_queue_depth[allocator],
+		    cur, cur + 1) == cur) {
+			atomic_inc_64(
+			    &mg->mg_class->mc_alloc_max_slots[allocator]);
+			return;
+		}
+		cur = mg->mg_cur_max_alloc_queue_depth[allocator];
+	}
 }
 
 void
-metaslab_group_alloc_decrement(spa_t *spa, uint64_t vdev, void *tag, int flags)
+metaslab_group_alloc_decrement(spa_t *spa, uint64_t vdev, void *tag, int flags,
+    int allocator, boolean_t io_complete)
 {
 	if (!(flags & METASLAB_ASYNC_ALLOC) ||
-	    flags & METASLAB_DONT_THROTTLE)
+	    (flags & METASLAB_DONT_THROTTLE))
 		return;
 
 	metaslab_group_t *mg = vdev_lookup_top(spa, vdev)->vdev_mg;
 	if (!mg->mg_class->mc_alloc_throttle_enabled)
 		return;
 
-	(void) refcount_remove(&mg->mg_alloc_queue_depth, tag);
+	(void) refcount_remove(&mg->mg_alloc_queue_depth[allocator], tag);
+	if (io_complete)
+		metaslab_group_increment_qdepth(mg, allocator);
 }
 
 void
-metaslab_group_alloc_verify(spa_t *spa, const blkptr_t *bp, void *tag)
+metaslab_group_alloc_verify(spa_t *spa, const blkptr_t *bp, void *tag,
+    int allocator)
 {
 #ifdef ZFS_DEBUG
 	const dva_t *dva = bp->blk_dva;
@@ -2793,7 +2960,8 @@ metaslab_group_alloc_verify(spa_t *spa, const blkptr_t *bp, void *tag)
 	for (int d = 0; d < ndvas; d++) {
 		uint64_t vdev = DVA_GET_VDEV(&dva[d]);
 		metaslab_group_t *mg = vdev_lookup_top(spa, vdev)->vdev_mg;
-		VERIFY(refcount_not_held(&mg->mg_alloc_queue_depth, tag));
+		VERIFY(refcount_not_held(&mg->mg_alloc_queue_depth[allocator],
+		    tag));
 	}
 #endif
 }
@@ -2835,91 +3003,146 @@ metaslab_block_alloc(metaslab_t *msp, uint64_t size, uint64_t txg)
 	return (start);
 }
 
+/*
+ * Find the metaslab with the highest weight that is less than what we've
+ * already tried.  In the common case, this means that we will examine each
+ * metaslab at most once. Note that concurrent callers could reorder metaslabs
+ * by activation/passivation once we have dropped the mg_lock. If a metaslab is
+ * activated by another thread, and we fail to allocate from the metaslab we
+ * have selected, we may not try the newly-activated metaslab, and instead
+ * activate another metaslab.  This is not optimal, but generally does not cause
+ * any problems (a possible exception being if every metaslab is completely full
+ * except for the the newly-activated metaslab which we fail to examine).
+ */
+static metaslab_t *
+find_valid_metaslab(metaslab_group_t *mg, uint64_t activation_weight,
+    dva_t *dva, int d, uint64_t min_distance, uint64_t asize, int allocator,
+    zio_alloc_list_t *zal, metaslab_t *search, boolean_t *was_active)
+{
+	avl_index_t idx;
+	avl_tree_t *t = &mg->mg_metaslab_tree;
+	metaslab_t *msp = avl_find(t, search, &idx);
+	if (msp == NULL)
+		msp = avl_nearest(t, idx, AVL_AFTER);
+
+	for (; msp != NULL; msp = AVL_NEXT(t, msp)) {
+		int i;
+		if (!metaslab_should_allocate(msp, asize)) {
+			metaslab_trace_add(zal, mg, msp, asize, d,
+			    TRACE_TOO_SMALL, allocator);
+			continue;
+		}
+
+		/*
+		 * If the selected metaslab is condensing, skip it.
+		 */
+		if (msp->ms_condensing)
+			continue;
+
+		*was_active = msp->ms_allocator != -1;
+		/*
+		 * If we're activating as primary, this is our first allocation
+		 * from this disk, so we don't need to check how close we are.
+		 * If the metaslab under consideration was already active,
+		 * we're getting desperate enough to steal another allocator's
+		 * metaslab, so we still don't care about distances.
+		 */
+		if (activation_weight == METASLAB_WEIGHT_PRIMARY || *was_active)
+			break;
+
+		uint64_t target_distance = min_distance
+		    + (space_map_allocated(msp->ms_sm) != 0 ? 0 :
+		    min_distance >> 1);
+
+		for (i = 0; i < d; i++) {
+			if (metaslab_distance(msp, &dva[i]) < target_distance)
+				break;
+		}
+		if (i == d)
+			break;
+	}
+
+	if (msp != NULL) {
+		search->ms_weight = msp->ms_weight;
+		search->ms_start = msp->ms_start + 1;
+		search->ms_allocator = msp->ms_allocator;
+		search->ms_primary = msp->ms_primary;
+	}
+	return (msp);
+}
+
+/* ARGSUSED */
 static uint64_t
 metaslab_group_alloc_normal(metaslab_group_t *mg, zio_alloc_list_t *zal,
-    uint64_t asize, uint64_t txg, uint64_t min_distance, dva_t *dva, int d)
+    uint64_t asize, uint64_t txg, uint64_t min_distance, dva_t *dva, int d,
+    int allocator)
 {
 	metaslab_t *msp = NULL;
 	uint64_t offset = -1ULL;
 	uint64_t activation_weight;
-	uint64_t target_distance;
-	int i;
+	boolean_t tertiary = B_FALSE;
 
 	activation_weight = METASLAB_WEIGHT_PRIMARY;
-	for (i = 0; i < d; i++) {
-		if (DVA_GET_VDEV(&dva[i]) == mg->mg_vd->vdev_id) {
+	for (int i = 0; i < d; i++) {
+		if (activation_weight == METASLAB_WEIGHT_PRIMARY &&
+		    DVA_GET_VDEV(&dva[i]) == mg->mg_vd->vdev_id) {
 			activation_weight = METASLAB_WEIGHT_SECONDARY;
+		} else if (activation_weight == METASLAB_WEIGHT_SECONDARY &&
+		    DVA_GET_VDEV(&dva[i]) == mg->mg_vd->vdev_id) {
+			tertiary = B_TRUE;
 			break;
 		}
 	}
 
+	/*
+	 * If we don't have enough metaslabs active to fill the entire array, we
+	 * just use the 0th slot.
+	 */
+	if (mg->mg_ms_ready < mg->mg_allocators * 2) {
+		tertiary = B_FALSE;
+		allocator = 0;
+	}
+
+	ASSERT3U(mg->mg_vd->vdev_ms_count, >=, 2);
+
 	metaslab_t *search = kmem_alloc(sizeof (*search), KM_SLEEP);
 	search->ms_weight = UINT64_MAX;
 	search->ms_start = 0;
+	/*
+	 * At the end of the metaslab tree are the already-active metaslabs,
+	 * first the primaries, then the secondaries. When we resume searching
+	 * through the tree, we need to consider ms_allocator and ms_primary so
+	 * we start in the location right after where we left off, and don't
+	 * accidentally loop forever considering the same metaslabs.
+	 */
+	search->ms_allocator = -1;
+	search->ms_primary = B_TRUE;
 	for (;;) {
-		boolean_t was_active;
-		avl_tree_t *t = &mg->mg_metaslab_tree;
-		avl_index_t idx;
+		boolean_t was_active = B_FALSE;
 
 		mutex_enter(&mg->mg_lock);
 
-		/*
-		 * Find the metaslab with the highest weight that is less
-		 * than what we've already tried.  In the common case, this
-		 * means that we will examine each metaslab at most once.
-		 * Note that concurrent callers could reorder metaslabs
-		 * by activation/passivation once we have dropped the mg_lock.
-		 * If a metaslab is activated by another thread, and we fail
-		 * to allocate from the metaslab we have selected, we may
-		 * not try the newly-activated metaslab, and instead activate
-		 * another metaslab.  This is not optimal, but generally
-		 * does not cause any problems (a possible exception being
-		 * if every metaslab is completely full except for the
-		 * the newly-activated metaslab which we fail to examine).
-		 */
-		msp = avl_find(t, search, &idx);
-		if (msp == NULL)
-			msp = avl_nearest(t, idx, AVL_AFTER);
-		for (; msp != NULL; msp = AVL_NEXT(t, msp)) {
-
-			if (!metaslab_should_allocate(msp, asize)) {
-				metaslab_trace_add(zal, mg, msp, asize, d,
-				    TRACE_TOO_SMALL);
-				continue;
-			}
-
-			/*
-			 * If the selected metaslab is condensing, skip it.
-			 */
-			if (msp->ms_condensing)
-				continue;
-
-			was_active = msp->ms_weight & METASLAB_ACTIVE_MASK;
-			if (activation_weight == METASLAB_WEIGHT_PRIMARY)
-				break;
-
-			target_distance = min_distance +
-			    (space_map_allocated(msp->ms_sm) != 0 ? 0 :
-			    min_distance >> 1);
-
-			for (i = 0; i < d; i++) {
-				if (metaslab_distance(msp, &dva[i]) <
-				    target_distance)
-					break;
-			}
-			if (i == d)
-				break;
+		if (activation_weight == METASLAB_WEIGHT_PRIMARY &&
+		    mg->mg_primaries[allocator] != NULL) {
+			msp = mg->mg_primaries[allocator];
+			was_active = B_TRUE;
+		} else if (activation_weight == METASLAB_WEIGHT_SECONDARY &&
+		    mg->mg_secondaries[allocator] != NULL && !tertiary) {
+			msp = mg->mg_secondaries[allocator];
+			was_active = B_TRUE;
+		} else {
+			msp = find_valid_metaslab(mg, activation_weight, dva, d,
+			    min_distance, asize, allocator, zal, search,
+			    &was_active);
 		}
+
 		mutex_exit(&mg->mg_lock);
 		if (msp == NULL) {
 			kmem_free(search, sizeof (*search));
 			return (-1ULL);
 		}
-		search->ms_weight = msp->ms_weight;
-		search->ms_start = msp->ms_start + 1;
 
 		mutex_enter(&msp->ms_lock);
-
 		/*
 		 * Ensure that the metaslab we have selected is still
 		 * capable of handling our request. It's possible that
@@ -2933,18 +3156,32 @@ metaslab_group_alloc_normal(metaslab_group_t *mg, zio_alloc_list_t *zal,
 			continue;
 		}
 
-		if ((msp->ms_weight & METASLAB_WEIGHT_SECONDARY) &&
-		    activation_weight == METASLAB_WEIGHT_PRIMARY) {
-			metaslab_passivate(msp,
-			    msp->ms_weight & ~METASLAB_ACTIVE_MASK);
+		/*
+		 * If the metaslab is freshly activated for an allocator that
+		 * isn't the one we're allocating from, or if it's a primary and
+		 * we're seeking a secondary (or vice versa), we go back and
+		 * select a new metaslab.
+		 */
+		if (!was_active && (msp->ms_weight & METASLAB_ACTIVE_MASK) &&
+		    (msp->ms_allocator != -1) &&
+		    (msp->ms_allocator != allocator || ((activation_weight ==
+		    METASLAB_WEIGHT_PRIMARY) != msp->ms_primary))) {
 			mutex_exit(&msp->ms_lock);
 			continue;
 		}
 
-		if (metaslab_activate(msp, activation_weight) != 0) {
+		if (msp->ms_weight & METASLAB_WEIGHT_CLAIM) {
+			metaslab_passivate(msp, msp->ms_weight &
+			    ~METASLAB_WEIGHT_CLAIM);
 			mutex_exit(&msp->ms_lock);
 			continue;
 		}
+
+		if (metaslab_activate(msp, allocator, activation_weight) != 0) {
+			mutex_exit(&msp->ms_lock);
+			continue;
+		}
+
 		msp->ms_selected_txg = txg;
 
 		/*
@@ -2957,7 +3194,7 @@ metaslab_group_alloc_normal(metaslab_group_t *mg, zio_alloc_list_t *zal,
 		if (!metaslab_should_allocate(msp, asize)) {
 			/* Passivate this metaslab and select a new one. */
 			metaslab_trace_add(zal, mg, msp, asize, d,
-			    TRACE_TOO_SMALL);
+			    TRACE_TOO_SMALL, allocator);
 			goto next;
 		}
 
@@ -2968,13 +3205,15 @@ metaslab_group_alloc_normal(metaslab_group_t *mg, zio_alloc_list_t *zal,
 		 */
 		if (msp->ms_condensing) {
 			metaslab_trace_add(zal, mg, msp, asize, d,
-			    TRACE_CONDENSING);
+			    TRACE_CONDENSING, allocator);
+			metaslab_passivate(msp, msp->ms_weight &
+			    ~METASLAB_ACTIVE_MASK);
 			mutex_exit(&msp->ms_lock);
 			continue;
 		}
 
 		offset = metaslab_block_alloc(msp, asize, txg);
-		metaslab_trace_add(zal, mg, msp, asize, d, offset);
+		metaslab_trace_add(zal, mg, msp, asize, d, offset, allocator);
 
 		if (offset != -1ULL) {
 			/* Proactively passivate the metaslab, if needed */
@@ -3030,19 +3269,20 @@ next:
 
 static uint64_t
 metaslab_group_alloc(metaslab_group_t *mg, zio_alloc_list_t *zal,
-    uint64_t asize, uint64_t txg, uint64_t min_distance, dva_t *dva, int d)
+    uint64_t asize, uint64_t txg, uint64_t min_distance, dva_t *dva, int d,
+    int allocator)
 {
 	uint64_t offset;
 	ASSERT(mg->mg_initialized);
 
 	offset = metaslab_group_alloc_normal(mg, zal, asize, txg,
-	    min_distance, dva, d);
+	    min_distance, dva, d, allocator);
 
 	mutex_enter(&mg->mg_lock);
 	if (offset == -1ULL) {
 		mg->mg_failed_allocations++;
 		metaslab_trace_add(zal, mg, NULL, asize, d,
-		    TRACE_GROUP_FAILURE);
+		    TRACE_GROUP_FAILURE, allocator);
 		if (asize == SPA_GANGBLOCKSIZE) {
 			/*
 			 * This metaslab group was unable to allocate
@@ -3077,7 +3317,7 @@ int ditto_same_vdev_distance_shift = 3;
 int
 metaslab_alloc_dva(spa_t *spa, metaslab_class_t *mc, uint64_t psize,
     dva_t *dva, int d, dva_t *hintdva, uint64_t txg, int flags,
-    zio_alloc_list_t *zal)
+    zio_alloc_list_t *zal, int allocator)
 {
 	metaslab_group_t *mg, *rotor;
 	vdev_t *vd;
@@ -3089,7 +3329,8 @@ metaslab_alloc_dva(spa_t *spa, metaslab_class_t *mc, uint64_t psize,
 	 * For testing, make some blocks above a certain size be gang blocks.
 	 */
 	if (psize >= metaslab_force_ganging && (ddi_get_lbolt() & 3) == 0) {
-		metaslab_trace_add(zal, NULL, NULL, psize, d, TRACE_FORCE_GANG);
+		metaslab_trace_add(zal, NULL, NULL, psize, d, TRACE_FORCE_GANG,
+		    allocator);
 		return (SET_ERROR(ENOSPC));
 	}
 
@@ -3175,12 +3416,12 @@ top:
 		 */
 		if (allocatable && !GANG_ALLOCATION(flags) && !try_hard) {
 			allocatable = metaslab_group_allocatable(mg, rotor,
-			    psize);
+			    psize, allocator);
 		}
 
 		if (!allocatable) {
 			metaslab_trace_add(zal, mg, NULL, psize, d,
-			    TRACE_NOT_ALLOCATABLE);
+			    TRACE_NOT_ALLOCATABLE, allocator);
 			goto next;
 		}
 
@@ -3195,7 +3436,7 @@ top:
 		    vd->vdev_state < VDEV_STATE_HEALTHY) &&
 		    d == 0 && !try_hard && vd->vdev_children == 0) {
 			metaslab_trace_add(zal, mg, NULL, psize, d,
-			    TRACE_VDEV_ERROR);
+			    TRACE_VDEV_ERROR, allocator);
 			goto next;
 		}
 
@@ -3219,7 +3460,7 @@ top:
 		ASSERT(P2PHASE(asize, 1ULL << vd->vdev_ashift) == 0);
 
 		uint64_t offset = metaslab_group_alloc(mg, zal, asize, txg,
-		    distance, dva, d);
+		    distance, dva, d, allocator);
 
 		if (offset != -1ULL) {
 			/*
@@ -3282,7 +3523,7 @@ next:
 
 	bzero(&dva[d], sizeof (dva_t));
 
-	metaslab_trace_add(zal, rotor, NULL, psize, d, TRACE_ENOSPC);
+	metaslab_trace_add(zal, rotor, NULL, psize, d, TRACE_ENOSPC, allocator);
 	return (SET_ERROR(ENOSPC));
 }
 
@@ -3583,18 +3824,20 @@ metaslab_free_dva(spa_t *spa, const dva_t *dva, boolean_t checkpoint)
  * the reservation.
  */
 boolean_t
-metaslab_class_throttle_reserve(metaslab_class_t *mc, int slots, zio_t *zio,
-    int flags)
+metaslab_class_throttle_reserve(metaslab_class_t *mc, int slots, int allocator,
+    zio_t *zio, int flags)
 {
 	uint64_t available_slots = 0;
 	boolean_t slot_reserved = B_FALSE;
+	uint64_t max = mc->mc_alloc_max_slots[allocator];
 
 	ASSERT(mc->mc_alloc_throttle_enabled);
 	mutex_enter(&mc->mc_lock);
 
-	uint64_t reserved_slots = refcount_count(&mc->mc_alloc_slots);
-	if (reserved_slots < mc->mc_alloc_max_slots)
-		available_slots = mc->mc_alloc_max_slots - reserved_slots;
+	uint64_t reserved_slots =
+	    refcount_count(&mc->mc_alloc_slots[allocator]);
+	if (reserved_slots < max)
+		available_slots = max - reserved_slots;
 
 	if (slots <= available_slots || GANG_ALLOCATION(flags)) {
 		/*
@@ -3602,7 +3845,9 @@ metaslab_class_throttle_reserve(metaslab_class_t *mc, int slots, zio_t *zio,
 		 * them individually when an I/O completes.
 		 */
 		for (int d = 0; d < slots; d++) {
-			reserved_slots = refcount_add(&mc->mc_alloc_slots, zio);
+			reserved_slots =
+			    refcount_add(&mc->mc_alloc_slots[allocator],
+			    zio);
 		}
 		zio->io_flags |= ZIO_FLAG_IO_ALLOCATING;
 		slot_reserved = B_TRUE;
@@ -3613,12 +3858,14 @@ metaslab_class_throttle_reserve(metaslab_class_t *mc, int slots, zio_t *zio,
 }
 
 void
-metaslab_class_throttle_unreserve(metaslab_class_t *mc, int slots, zio_t *zio)
+metaslab_class_throttle_unreserve(metaslab_class_t *mc, int slots,
+    int allocator, zio_t *zio)
 {
 	ASSERT(mc->mc_alloc_throttle_enabled);
 	mutex_enter(&mc->mc_lock);
 	for (int d = 0; d < slots; d++) {
-		(void) refcount_remove(&mc->mc_alloc_slots, zio);
+		(void) refcount_remove(&mc->mc_alloc_slots[allocator],
+		    zio);
 	}
 	mutex_exit(&mc->mc_lock);
 }
@@ -3640,7 +3887,13 @@ metaslab_claim_concrete(vdev_t *vd, uint64_t offset, uint64_t size,
 	mutex_enter(&msp->ms_lock);
 
 	if ((txg != 0 && spa_writeable(spa)) || !msp->ms_loaded)
-		error = metaslab_activate(msp, METASLAB_WEIGHT_SECONDARY);
+		error = metaslab_activate(msp, 0, METASLAB_WEIGHT_CLAIM);
+	/*
+	 * No need to fail in that case; someone else has activated the
+	 * metaslab, but that doesn't preclude us from using it.
+	 */
+	if (error == EBUSY)
+		error = 0;
 
 	if (error == 0 &&
 	    !range_tree_contains(msp->ms_allocatable, offset, size))
@@ -3745,7 +3998,7 @@ metaslab_claim_dva(spa_t *spa, const dva_t *dva, uint64_t txg)
 int
 metaslab_alloc(spa_t *spa, metaslab_class_t *mc, uint64_t psize, blkptr_t *bp,
     int ndvas, uint64_t txg, blkptr_t *hintbp, int flags,
-    zio_alloc_list_t *zal, zio_t *zio)
+    zio_alloc_list_t *zal, zio_t *zio, int allocator)
 {
 	dva_t *dva = bp->blk_dva;
 	dva_t *hintdva = hintbp->blk_dva;
@@ -3768,12 +4021,13 @@ metaslab_alloc(spa_t *spa, metaslab_class_t *mc, uint64_t psize, blkptr_t *bp,
 
 	for (int d = 0; d < ndvas; d++) {
 		error = metaslab_alloc_dva(spa, mc, psize, dva, d, hintdva,
-		    txg, flags, zal);
+		    txg, flags, zal, allocator);
 		if (error != 0) {
 			for (d--; d >= 0; d--) {
 				metaslab_unalloc_dva(spa, &dva[d], txg);
 				metaslab_group_alloc_decrement(spa,
-				    DVA_GET_VDEV(&dva[d]), zio, flags);
+				    DVA_GET_VDEV(&dva[d]), zio, flags,
+				    allocator, B_FALSE);
 				bzero(&dva[d], sizeof (dva_t));
 			}
 			spa_config_exit(spa, SCL_ALLOC, FTAG);
@@ -3784,7 +4038,7 @@ metaslab_alloc(spa_t *spa, metaslab_class_t *mc, uint64_t psize, blkptr_t *bp,
 			 * based on the newly allocated dva.
 			 */
 			metaslab_group_alloc_increment(spa,
-			    DVA_GET_VDEV(&dva[d]), zio, flags);
+			    DVA_GET_VDEV(&dva[d]), zio, flags, allocator);
 		}
 
 	}
diff --git a/usr/src/uts/common/fs/zfs/range_tree.c b/usr/src/uts/common/fs/zfs/range_tree.c
index f0bcaf5280..7c6ce90e18 100644
--- a/usr/src/uts/common/fs/zfs/range_tree.c
+++ b/usr/src/uts/common/fs/zfs/range_tree.c
@@ -179,7 +179,7 @@ range_tree_add(void *arg, uint64_t start, uint64_t size)
 	}
 
 	/* Make sure we don't overlap with either of our neighbors */
-	VERIFY(rs == NULL);
+	VERIFY3P(rs, ==, NULL);
 
 	rs_before = avl_nearest(&rt->rt_root, where, AVL_BEFORE);
 	rs_after = avl_nearest(&rt->rt_root, where, AVL_AFTER);
diff --git a/usr/src/uts/common/fs/zfs/spa.c b/usr/src/uts/common/fs/zfs/spa.c
index 064e4411db..163f5e054e 100644
--- a/usr/src/uts/common/fs/zfs/spa.c
+++ b/usr/src/uts/common/fs/zfs/spa.c
@@ -7398,9 +7398,11 @@ spa_sync(spa_t *spa, uint64_t txg)
 	spa->spa_syncing_txg = txg;
 	spa->spa_sync_pass = 0;
 
-	mutex_enter(&spa->spa_alloc_lock);
-	VERIFY0(avl_numnodes(&spa->spa_alloc_tree));
-	mutex_exit(&spa->spa_alloc_lock);
+	for (int i = 0; i < spa->spa_alloc_count; i++) {
+		mutex_enter(&spa->spa_alloc_locks[i]);
+		VERIFY0(avl_numnodes(&spa->spa_alloc_trees[i]));
+		mutex_exit(&spa->spa_alloc_locks[i]);
+	}
 
 	/*
 	 * If there are any pending vdev state changes, convert them
@@ -7459,7 +7461,7 @@ spa_sync(spa_t *spa, uint64_t txg)
 	 * The max queue depth will not change in the middle of syncing
 	 * out this txg.
 	 */
-	uint64_t queue_depth_total = 0;
+	uint64_t slots_per_allocator = 0;
 	for (int c = 0; c < rvd->vdev_children; c++) {
 		vdev_t *tvd = rvd->vdev_child[c];
 		metaslab_group_t *mg = tvd->vdev_mg;
@@ -7473,18 +7475,23 @@ spa_sync(spa_t *spa, uint64_t txg)
 		 * allocations look at mg_max_alloc_queue_depth, and async
 		 * allocations all happen from spa_sync().
 		 */
-		ASSERT0(refcount_count(&mg->mg_alloc_queue_depth));
+		for (int i = 0; i < spa->spa_alloc_count; i++)
+			ASSERT0(refcount_count(&(mg->mg_alloc_queue_depth[i])));
 		mg->mg_max_alloc_queue_depth = max_queue_depth;
-		queue_depth_total += mg->mg_max_alloc_queue_depth;
+
+		for (int i = 0; i < spa->spa_alloc_count; i++) {
+			mg->mg_cur_max_alloc_queue_depth[i] =
+			    zfs_vdev_def_queue_depth;
+		}
+		slots_per_allocator += zfs_vdev_def_queue_depth;
 	}
 	metaslab_class_t *mc = spa_normal_class(spa);
-	ASSERT0(refcount_count(&mc->mc_alloc_slots));
-	mc->mc_alloc_max_slots = queue_depth_total;
+	for (int i = 0; i < spa->spa_alloc_count; i++) {
+		ASSERT0(refcount_count(&mc->mc_alloc_slots[i]));
+		mc->mc_alloc_max_slots[i] = slots_per_allocator;
+	}
 	mc->mc_alloc_throttle_enabled = zio_dva_throttle_enabled;
 
-	ASSERT3U(mc->mc_alloc_max_slots, <=,
-	    max_queue_depth * rvd->vdev_children);
-
 	for (int c = 0; c < rvd->vdev_children; c++) {
 		vdev_t *vd = rvd->vdev_child[c];
 		vdev_indirect_state_sync_verify(vd);
@@ -7661,9 +7668,11 @@ spa_sync(spa_t *spa, uint64_t txg)
 
 	dsl_pool_sync_done(dp, txg);
 
-	mutex_enter(&spa->spa_alloc_lock);
-	VERIFY0(avl_numnodes(&spa->spa_alloc_tree));
-	mutex_exit(&spa->spa_alloc_lock);
+	for (int i = 0; i < spa->spa_alloc_count; i++) {
+		mutex_enter(&spa->spa_alloc_locks[i]);
+		VERIFY0(avl_numnodes(&spa->spa_alloc_trees[i]));
+		mutex_exit(&spa->spa_alloc_locks[i]);
+	}
 
 	/*
 	 * Update usable space statistics.
diff --git a/usr/src/uts/common/fs/zfs/spa_checkpoint.c b/usr/src/uts/common/fs/zfs/spa_checkpoint.c
index a4af48d8c5..db0d2caa61 100644
--- a/usr/src/uts/common/fs/zfs/spa_checkpoint.c
+++ b/usr/src/uts/common/fs/zfs/spa_checkpoint.c
@@ -203,13 +203,12 @@ typedef struct spa_checkpoint_discard_sync_callback_arg {
 } spa_checkpoint_discard_sync_callback_arg_t;
 
 static int
-spa_checkpoint_discard_sync_callback(maptype_t type, uint64_t offset,
-    uint64_t size, void *arg)
+spa_checkpoint_discard_sync_callback(space_map_entry_t *sme, void *arg)
 {
 	spa_checkpoint_discard_sync_callback_arg_t *sdc = arg;
 	vdev_t *vd = sdc->sdc_vd;
-	metaslab_t *ms = vd->vdev_ms[offset >> vd->vdev_ms_shift];
-	uint64_t end = offset + size;
+	metaslab_t *ms = vd->vdev_ms[sme->sme_offset >> vd->vdev_ms_shift];
+	uint64_t end = sme->sme_offset + sme->sme_run;
 
 	if (sdc->sdc_entry_limit == 0)
 		return (EINTR);
@@ -224,8 +223,8 @@ spa_checkpoint_discard_sync_callback(maptype_t type, uint64_t offset,
 	 * metaslab boundaries. So if needed we could add code
 	 * that handles metaslab-crossing segments in the future.
 	 */
-	VERIFY3U(type, ==, SM_FREE);
-	VERIFY3U(offset, >=, ms->ms_start);
+	VERIFY3U(sme->sme_type, ==, SM_FREE);
+	VERIFY3U(sme->sme_offset, >=, ms->ms_start);
 	VERIFY3U(end, <=, ms->ms_start + ms->ms_size);
 
 	/*
@@ -237,14 +236,15 @@ spa_checkpoint_discard_sync_callback(maptype_t type, uint64_t offset,
 	mutex_enter(&ms->ms_lock);
 	if (range_tree_is_empty(ms->ms_freeing))
 		vdev_dirty(vd, VDD_METASLAB, ms, sdc->sdc_txg);
-	range_tree_add(ms->ms_freeing, offset, size);
+	range_tree_add(ms->ms_freeing, sme->sme_offset, sme->sme_run);
 	mutex_exit(&ms->ms_lock);
 
-	ASSERT3U(vd->vdev_spa->spa_checkpoint_info.sci_dspace, >=, size);
-	ASSERT3U(vd->vdev_stat.vs_checkpoint_space, >=, size);
+	ASSERT3U(vd->vdev_spa->spa_checkpoint_info.sci_dspace, >=,
+	    sme->sme_run);
+	ASSERT3U(vd->vdev_stat.vs_checkpoint_space, >=, sme->sme_run);
 
-	vd->vdev_spa->spa_checkpoint_info.sci_dspace -= size;
-	vd->vdev_stat.vs_checkpoint_space -= size;
+	vd->vdev_spa->spa_checkpoint_info.sci_dspace -= sme->sme_run;
+	vd->vdev_stat.vs_checkpoint_space -= sme->sme_run;
 	sdc->sdc_entry_limit--;
 
 	return (0);
@@ -289,12 +289,13 @@ spa_checkpoint_discard_thread_sync(void *arg, dmu_tx_t *tx)
 	 * Thus, we set the maximum entries that the space map callback
 	 * will be applied to be half the entries that could fit in the
 	 * imposed memory limit.
+	 *
+	 * Note that since this is a conservative estimate we also
+	 * assume the worst case scenario in our computation where each
+	 * entry is two-word.
 	 */
 	uint64_t max_entry_limit =
-	    (zfs_spa_discard_memory_limit / sizeof (uint64_t)) >> 1;
-
-	uint64_t entries_in_sm =
-	    space_map_length(vd->vdev_checkpoint_sm) / sizeof (uint64_t);
+	    (zfs_spa_discard_memory_limit / (2 * sizeof (uint64_t))) >> 1;
 
 	/*
 	 * Iterate from the end of the space map towards the beginning,
@@ -318,14 +319,15 @@ spa_checkpoint_discard_thread_sync(void *arg, dmu_tx_t *tx)
 	spa_checkpoint_discard_sync_callback_arg_t sdc;
 	sdc.sdc_vd = vd;
 	sdc.sdc_txg = tx->tx_txg;
-	sdc.sdc_entry_limit = MIN(entries_in_sm, max_entry_limit);
+	sdc.sdc_entry_limit = max_entry_limit;
 
-	uint64_t entries_before = entries_in_sm;
+	uint64_t words_before =
+	    space_map_length(vd->vdev_checkpoint_sm) / sizeof (uint64_t);
 
 	error = space_map_incremental_destroy(vd->vdev_checkpoint_sm,
 	    spa_checkpoint_discard_sync_callback, &sdc, tx);
 
-	uint64_t entries_after =
+	uint64_t words_after =
 	    space_map_length(vd->vdev_checkpoint_sm) / sizeof (uint64_t);
 
 #ifdef DEBUG
@@ -333,9 +335,9 @@ spa_checkpoint_discard_thread_sync(void *arg, dmu_tx_t *tx)
 #endif
 
 	zfs_dbgmsg("discarding checkpoint: txg %llu, vdev id %d, "
-	    "deleted %llu entries - %llu entries are left",
-	    tx->tx_txg, vd->vdev_id, (entries_before - entries_after),
-	    entries_after);
+	    "deleted %llu words - %llu words are left",
+	    tx->tx_txg, vd->vdev_id, (words_before - words_after),
+	    words_after);
 
 	if (error != EINTR) {
 		if (error != 0) {
@@ -344,15 +346,15 @@ spa_checkpoint_discard_thread_sync(void *arg, dmu_tx_t *tx)
 			    "space map of vdev %llu\n",
 			    error, vd->vdev_id);
 		}
-		ASSERT0(entries_after);
+		ASSERT0(words_after);
 		ASSERT0(vd->vdev_checkpoint_sm->sm_alloc);
-		ASSERT0(vd->vdev_checkpoint_sm->sm_length);
+		ASSERT0(space_map_length(vd->vdev_checkpoint_sm));
 
 		space_map_free(vd->vdev_checkpoint_sm, tx);
 		space_map_close(vd->vdev_checkpoint_sm);
 		vd->vdev_checkpoint_sm = NULL;
 
-		VERIFY0(zap_remove(vd->vdev_spa->spa_meta_objset,
+		VERIFY0(zap_remove(spa_meta_objset(vd->vdev_spa),
 		    vd->vdev_top_zap, VDEV_TOP_ZAP_POOL_CHECKPOINT_SM, tx));
 	}
 }
diff --git a/usr/src/uts/common/fs/zfs/spa_misc.c b/usr/src/uts/common/fs/zfs/spa_misc.c
index efb4993c0a..fe0971a720 100644
--- a/usr/src/uts/common/fs/zfs/spa_misc.c
+++ b/usr/src/uts/common/fs/zfs/spa_misc.c
@@ -20,7 +20,7 @@
  */
 /*
  * Copyright (c) 2005, 2010, Oracle and/or its affiliates. All rights reserved.
- * Copyright (c) 2011, 2017 by Delphix. All rights reserved.
+ * Copyright (c) 2011, 2018 by Delphix. All rights reserved.
  * Copyright 2015 Nexenta Systems, Inc.  All rights reserved.
  * Copyright (c) 2014 Spectra Logic Corporation, All rights reserved.
  * Copyright 2013 Saso Kiselkov. All rights reserved.
@@ -357,6 +357,8 @@ int spa_asize_inflation = 24;
 int spa_slop_shift = 5;
 uint64_t spa_min_slop = 128 * 1024 * 1024;
 
+int spa_allocators = 4;
+
 /*PRINTFLIKE2*/
 void
 spa_load_failed(spa_t *spa, const char *fmt, ...)
@@ -607,7 +609,6 @@ spa_add(const char *name, nvlist_t *config, const char *altroot)
 	mutex_init(&spa->spa_suspend_lock, NULL, MUTEX_DEFAULT, NULL);
 	mutex_init(&spa->spa_vdev_top_lock, NULL, MUTEX_DEFAULT, NULL);
 	mutex_init(&spa->spa_iokstat_lock, NULL, MUTEX_DEFAULT, NULL);
-	mutex_init(&spa->spa_alloc_lock, NULL, MUTEX_DEFAULT, NULL);
 
 	cv_init(&spa->spa_async_cv, NULL, CV_DEFAULT, NULL);
 	cv_init(&spa->spa_evicting_os_cv, NULL, CV_DEFAULT, NULL);
@@ -658,8 +659,16 @@ spa_add(const char *name, nvlist_t *config, const char *altroot)
 		spa_active_count++;
 	}
 
-	avl_create(&spa->spa_alloc_tree, zio_bookmark_compare,
-	    sizeof (zio_t), offsetof(zio_t, io_alloc_node));
+	spa->spa_alloc_count = spa_allocators;
+	spa->spa_alloc_locks = kmem_zalloc(spa->spa_alloc_count *
+	    sizeof (kmutex_t), KM_SLEEP);
+	spa->spa_alloc_trees = kmem_zalloc(spa->spa_alloc_count *
+	    sizeof (avl_tree_t), KM_SLEEP);
+	for (int i = 0; i < spa->spa_alloc_count; i++) {
+		mutex_init(&spa->spa_alloc_locks[i], NULL, MUTEX_DEFAULT, NULL);
+		avl_create(&spa->spa_alloc_trees[i], zio_bookmark_compare,
+		    sizeof (zio_t), offsetof(zio_t, io_alloc_node));
+	}
 
 	/*
 	 * Every pool starts with the default cachefile
@@ -746,7 +755,15 @@ spa_remove(spa_t *spa)
 		kmem_free(dp, sizeof (spa_config_dirent_t));
 	}
 
-	avl_destroy(&spa->spa_alloc_tree);
+	for (int i = 0; i < spa->spa_alloc_count; i++) {
+		avl_destroy(&spa->spa_alloc_trees[i]);
+		mutex_destroy(&spa->spa_alloc_locks[i]);
+	}
+	kmem_free(spa->spa_alloc_locks, spa->spa_alloc_count *
+	    sizeof (kmutex_t));
+	kmem_free(spa->spa_alloc_trees, spa->spa_alloc_count *
+	    sizeof (avl_tree_t));
+
 	list_destroy(&spa->spa_config_list);
 
 	nvlist_free(spa->spa_label_features);
@@ -777,7 +794,6 @@ spa_remove(spa_t *spa)
 	cv_destroy(&spa->spa_scrub_io_cv);
 	cv_destroy(&spa->spa_suspend_cv);
 
-	mutex_destroy(&spa->spa_alloc_lock);
 	mutex_destroy(&spa->spa_async_lock);
 	mutex_destroy(&spa->spa_errlist_lock);
 	mutex_destroy(&spa->spa_errlog_lock);
diff --git a/usr/src/uts/common/fs/zfs/space_map.c b/usr/src/uts/common/fs/zfs/space_map.c
index 989daea941..b42d449c77 100644
--- a/usr/src/uts/common/fs/zfs/space_map.c
+++ b/usr/src/uts/common/fs/zfs/space_map.c
@@ -41,11 +41,36 @@
  * Note on space map block size:
  *
  * The data for a given space map can be kept on blocks of any size.
- * Larger blocks entail fewer i/o operations, but they also cause the
- * DMU to keep more data in-core, and also to waste more i/o bandwidth
+ * Larger blocks entail fewer I/O operations, but they also cause the
+ * DMU to keep more data in-core, and also to waste more I/O bandwidth
  * when only a few blocks have changed since the last transaction group.
  */
 
+/*
+ * Enabled whenever we want to stress test the use of double-word
+ * space map entries.
+ */
+boolean_t zfs_force_some_double_word_sm_entries = B_FALSE;
+
+boolean_t
+sm_entry_is_debug(uint64_t e)
+{
+	return (SM_PREFIX_DECODE(e) == SM_DEBUG_PREFIX);
+}
+
+boolean_t
+sm_entry_is_single_word(uint64_t e)
+{
+	uint8_t prefix = SM_PREFIX_DECODE(e);
+	return (prefix != SM_DEBUG_PREFIX && prefix != SM2_PREFIX);
+}
+
+boolean_t
+sm_entry_is_double_word(uint64_t e)
+{
+	return (SM_PREFIX_DECODE(e) == SM2_PREFIX);
+}
+
 /*
  * Iterate through the space map, invoking the callback on each (non-debug)
  * space map entry.
@@ -53,56 +78,157 @@
 int
 space_map_iterate(space_map_t *sm, sm_cb_t callback, void *arg)
 {
-	uint64_t *entry, *entry_map, *entry_map_end;
-	uint64_t bufsize, size, offset, end;
+	uint64_t sm_len = space_map_length(sm);
+	ASSERT3U(sm->sm_blksz, !=, 0);
+
+	dmu_prefetch(sm->sm_os, space_map_object(sm), 0, 0, sm_len,
+	    ZIO_PRIORITY_SYNC_READ);
+
+	uint64_t blksz = sm->sm_blksz;
 	int error = 0;
+	for (uint64_t block_base = 0; block_base < sm_len && error == 0;
+	    block_base += blksz) {
+		dmu_buf_t *db;
+		error = dmu_buf_hold(sm->sm_os, space_map_object(sm),
+		    block_base, FTAG, &db, DMU_READ_PREFETCH);
+		if (error != 0)
+			return (error);
 
-	end = space_map_length(sm);
+		uint64_t *block_start = db->db_data;
+		uint64_t block_length = MIN(sm_len - block_base, blksz);
+		uint64_t *block_end = block_start +
+		    (block_length / sizeof (uint64_t));
 
-	bufsize = MAX(sm->sm_blksz, SPA_MINBLOCKSIZE);
-	entry_map = zio_buf_alloc(bufsize);
+		VERIFY0(P2PHASE(block_length, sizeof (uint64_t)));
+		VERIFY3U(block_length, !=, 0);
+		ASSERT3U(blksz, ==, db->db_size);
 
-	if (end > bufsize) {
-		dmu_prefetch(sm->sm_os, space_map_object(sm), 0, bufsize,
-		    end - bufsize, ZIO_PRIORITY_SYNC_READ);
-	}
+		for (uint64_t *block_cursor = block_start;
+		    block_cursor < block_end && error == 0; block_cursor++) {
+			uint64_t e = *block_cursor;
 
-	for (offset = 0; offset < end && error == 0; offset += bufsize) {
-		size = MIN(end - offset, bufsize);
-		VERIFY(P2PHASE(size, sizeof (uint64_t)) == 0);
-		VERIFY(size != 0);
-		ASSERT3U(sm->sm_blksz, !=, 0);
+			if (sm_entry_is_debug(e)) /* Skip debug entries */
+				continue;
 
-		dprintf("object=%llu  offset=%llx  size=%llx\n",
-		    space_map_object(sm), offset, size);
+			uint64_t raw_offset, raw_run, vdev_id;
+			maptype_t type;
+			if (sm_entry_is_single_word(e)) {
+				type = SM_TYPE_DECODE(e);
+				vdev_id = SM_NO_VDEVID;
+				raw_offset = SM_OFFSET_DECODE(e);
+				raw_run = SM_RUN_DECODE(e);
+			} else {
+				/* it is a two-word entry */
+				ASSERT(sm_entry_is_double_word(e));
+				raw_run = SM2_RUN_DECODE(e);
+				vdev_id = SM2_VDEV_DECODE(e);
+
+				/* move on to the second word */
+				block_cursor++;
+				e = *block_cursor;
+				VERIFY3P(block_cursor, <=, block_end);
+
+				type = SM2_TYPE_DECODE(e);
+				raw_offset = SM2_OFFSET_DECODE(e);
+			}
 
-		error = dmu_read(sm->sm_os, space_map_object(sm), offset, size,
-		    entry_map, DMU_READ_PREFETCH);
-		if (error != 0)
-			break;
+			uint64_t entry_offset = (raw_offset << sm->sm_shift) +
+			    sm->sm_start;
+			uint64_t entry_run = raw_run << sm->sm_shift;
 
-		entry_map_end = entry_map + (size / sizeof (uint64_t));
-		for (entry = entry_map; entry < entry_map_end && error == 0;
-		    entry++) {
-			uint64_t e = *entry;
-			uint64_t offset, size;
+			VERIFY0(P2PHASE(entry_offset, 1ULL << sm->sm_shift));
+			VERIFY0(P2PHASE(entry_run, 1ULL << sm->sm_shift));
+			ASSERT3U(entry_offset, >=, sm->sm_start);
+			ASSERT3U(entry_offset, <, sm->sm_start + sm->sm_size);
+			ASSERT3U(entry_run, <=, sm->sm_size);
+			ASSERT3U(entry_offset + entry_run, <=,
+			    sm->sm_start + sm->sm_size);
 
-			if (SM_DEBUG_DECODE(e))	/* Skip debug entries */
-				continue;
+			space_map_entry_t sme = {
+			    .sme_type = type,
+			    .sme_vdev = vdev_id,
+			    .sme_offset = entry_offset,
+			    .sme_run = entry_run
+			};
+			error = callback(&sme, arg);
+		}
+		dmu_buf_rele(db, FTAG);
+	}
+	return (error);
+}
 
-			offset = (SM_OFFSET_DECODE(e) << sm->sm_shift) +
-			    sm->sm_start;
-			size = SM_RUN_DECODE(e) << sm->sm_shift;
+/*
+ * Reads the entries from the last block of the space map into
+ * buf in reverse order. Populates nwords with number of words
+ * in the last block.
+ *
+ * Refer to block comment within space_map_incremental_destroy()
+ * to understand why this function is needed.
+ */
+static int
+space_map_reversed_last_block_entries(space_map_t *sm, uint64_t *buf,
+    uint64_t bufsz, uint64_t *nwords)
+{
+	int error = 0;
+	dmu_buf_t *db;
 
-			VERIFY0(P2PHASE(offset, 1ULL << sm->sm_shift));
-			VERIFY0(P2PHASE(size, 1ULL << sm->sm_shift));
-			VERIFY3U(offset, >=, sm->sm_start);
-			VERIFY3U(offset + size, <=, sm->sm_start + sm->sm_size);
-			error = callback(SM_TYPE_DECODE(e), offset, size, arg);
+	/*
+	 * Find the offset of the last word in the space map and use
+	 * that to read the last block of the space map with
+	 * dmu_buf_hold().
+	 */
+	uint64_t last_word_offset =
+	    sm->sm_phys->smp_objsize - sizeof (uint64_t);
+	error = dmu_buf_hold(sm->sm_os, space_map_object(sm), last_word_offset,
+	    FTAG, &db, DMU_READ_NO_PREFETCH);
+	if (error != 0)
+		return (error);
+
+	ASSERT3U(sm->sm_object, ==, db->db_object);
+	ASSERT3U(sm->sm_blksz, ==, db->db_size);
+	ASSERT3U(bufsz, >=, db->db_size);
+	ASSERT(nwords != NULL);
+
+	uint64_t *words = db->db_data;
+	*nwords =
+	    (sm->sm_phys->smp_objsize - db->db_offset) / sizeof (uint64_t);
+
+	ASSERT3U(*nwords, <=, bufsz / sizeof (uint64_t));
+
+	uint64_t n = *nwords;
+	uint64_t j = n - 1;
+	for (uint64_t i = 0; i < n; i++) {
+		uint64_t entry = words[i];
+		if (sm_entry_is_double_word(entry)) {
+			/*
+			 * Since we are populating the buffer backwards
+			 * we have to be extra careful and add the two
+			 * words of the double-word entry in the right
+			 * order.
+			 */
+			ASSERT3U(j, >, 0);
+			buf[j - 1] = entry;
+
+			i++;
+			ASSERT3U(i, <, n);
+			entry = words[i];
+			buf[j] = entry;
+			j -= 2;
+		} else {
+			ASSERT(sm_entry_is_debug(entry) ||
+			    sm_entry_is_single_word(entry));
+			buf[j] = entry;
+			j--;
 		}
 	}
 
-	zio_buf_free(entry_map, bufsize);
+	/*
+	 * Assert that we wrote backwards all the
+	 * way to the beginning of the buffer.
+	 */
+	ASSERT3S(j, ==, -1);
+
+	dmu_buf_rele(db, FTAG);
 	return (error);
 }
 
@@ -116,124 +242,122 @@ int
 space_map_incremental_destroy(space_map_t *sm, sm_cb_t callback, void *arg,
     dmu_tx_t *tx)
 {
-	uint64_t bufsize, len;
-	uint64_t *entry_map;
-	int error = 0;
-
-	len = space_map_length(sm);
-	bufsize = MAX(sm->sm_blksz, SPA_MINBLOCKSIZE);
-	entry_map = zio_buf_alloc(bufsize);
+	uint64_t bufsz = MAX(sm->sm_blksz, SPA_MINBLOCKSIZE);
+	uint64_t *buf = zio_buf_alloc(bufsz);
 
 	dmu_buf_will_dirty(sm->sm_dbuf, tx);
 
 	/*
-	 * Since we can't move the starting offset of the space map
-	 * (e.g there are reference on-disk pointing to it), we destroy
-	 * its entries incrementally starting from the end.
+	 * Ideally we would want to iterate from the beginning of the
+	 * space map to the end in incremental steps. The issue with this
+	 * approach is that we don't have any field on-disk that points
+	 * us where to start between each step. We could try zeroing out
+	 * entries that we've destroyed, but this doesn't work either as
+	 * an entry that is 0 is a valid one (ALLOC for range [0x0:0x200]).
+	 *
+	 * As a result, we destroy its entries incrementally starting from
+	 * the end after applying the callback to each of them.
 	 *
-	 * The logic that follows is basically the same as the one used
-	 * in space_map_iterate() but it traverses the space map
-	 * backwards:
+	 * The problem with this approach is that we cannot literally
+	 * iterate through the words in the space map backwards as we
+	 * can't distinguish two-word space map entries from their second
+	 * word. Thus we do the following:
 	 *
-	 * 1] We figure out the size of the buffer that we want to use
-	 *    to read the on-disk space map entries.
-	 * 2] We figure out the offset at the end of the space map where
-	 *    we will start reading entries into our buffer.
-	 * 3] We read the on-disk entries into the buffer.
-	 * 4] We iterate over the entries from end to beginning calling
-	 *    the callback function on each one. As we move from entry
-	 *    to entry we decrease the size of the space map, deleting
-	 *    effectively each entry.
-	 * 5] If there are no more entries in the space map or the
-	 *    callback returns a value other than 0, we stop iterating
-	 *    over the space map. If there are entries remaining and
-	 *    the callback returned zero we go back to step [1].
+	 * 1] We get all the entries from the last block of the space map
+	 *    and put them into a buffer in reverse order. This way the
+	 *    last entry comes first in the buffer, the second to last is
+	 *    second, etc.
+	 * 2] We iterate through the entries in the buffer and we apply
+	 *    the callback to each one. As we move from entry to entry we
+	 *    we decrease the size of the space map, deleting effectively
+	 *    each entry.
+	 * 3] If there are no more entries in the space map or the callback
+	 *    returns a value other than 0, we stop iterating over the
+	 *    space map. If there are entries remaining and the callback
+	 *    returned 0, we go back to step [1].
 	 */
-	uint64_t offset = 0, size = 0;
-	while (len > 0 && error == 0) {
-		size = MIN(bufsize, len);
-
-		VERIFY(P2PHASE(size, sizeof (uint64_t)) == 0);
-		VERIFY3U(size, >, 0);
-		ASSERT3U(sm->sm_blksz, !=, 0);
-
-		offset = len - size;
-
-		IMPLY(bufsize > len, offset == 0);
-		IMPLY(bufsize == len, offset == 0);
-		IMPLY(bufsize < len, offset > 0);
-
-
-		EQUIV(size == len, offset == 0);
-		IMPLY(size < len, bufsize < len);
-
-		dprintf("object=%llu  offset=%llx  size=%llx\n",
-		    space_map_object(sm), offset, size);
-
-		error = dmu_read(sm->sm_os, space_map_object(sm),
-		    offset, size, entry_map, DMU_READ_PREFETCH);
+	int error = 0;
+	while (space_map_length(sm) > 0 && error == 0) {
+		uint64_t nwords = 0;
+		error = space_map_reversed_last_block_entries(sm, buf, bufsz,
+		    &nwords);
 		if (error != 0)
 			break;
 
-		uint64_t num_entries = size / sizeof (uint64_t);
-
-		ASSERT3U(num_entries, >, 0);
+		ASSERT3U(nwords, <=, bufsz / sizeof (uint64_t));
 
-		while (num_entries > 0) {
-			uint64_t e, entry_offset, entry_size;
-			maptype_t type;
+		for (uint64_t i = 0; i < nwords; i++) {
+			uint64_t e = buf[i];
 
-			e = entry_map[num_entries - 1];
-
-			ASSERT3U(num_entries, >, 0);
-			ASSERT0(error);
-
-			if (SM_DEBUG_DECODE(e)) {
+			if (sm_entry_is_debug(e)) {
 				sm->sm_phys->smp_objsize -= sizeof (uint64_t);
 				space_map_update(sm);
-				len -= sizeof (uint64_t);
-				num_entries--;
 				continue;
 			}
 
-			type = SM_TYPE_DECODE(e);
-			entry_offset = (SM_OFFSET_DECODE(e) << sm->sm_shift) +
-			    sm->sm_start;
-			entry_size = SM_RUN_DECODE(e) << sm->sm_shift;
+			int words = 1;
+			uint64_t raw_offset, raw_run, vdev_id;
+			maptype_t type;
+			if (sm_entry_is_single_word(e)) {
+				type = SM_TYPE_DECODE(e);
+				vdev_id = SM_NO_VDEVID;
+				raw_offset = SM_OFFSET_DECODE(e);
+				raw_run = SM_RUN_DECODE(e);
+			} else {
+				ASSERT(sm_entry_is_double_word(e));
+				words = 2;
+
+				raw_run = SM2_RUN_DECODE(e);
+				vdev_id = SM2_VDEV_DECODE(e);
+
+				/* move to the second word */
+				i++;
+				e = buf[i];
+
+				ASSERT3P(i, <=, nwords);
+
+				type = SM2_TYPE_DECODE(e);
+				raw_offset = SM2_OFFSET_DECODE(e);
+			}
+
+			uint64_t entry_offset =
+			    (raw_offset << sm->sm_shift) + sm->sm_start;
+			uint64_t entry_run = raw_run << sm->sm_shift;
 
 			VERIFY0(P2PHASE(entry_offset, 1ULL << sm->sm_shift));
-			VERIFY0(P2PHASE(entry_size, 1ULL << sm->sm_shift));
+			VERIFY0(P2PHASE(entry_run, 1ULL << sm->sm_shift));
 			VERIFY3U(entry_offset, >=, sm->sm_start);
-			VERIFY3U(entry_offset + entry_size, <=,
+			VERIFY3U(entry_offset, <, sm->sm_start + sm->sm_size);
+			VERIFY3U(entry_run, <=, sm->sm_size);
+			VERIFY3U(entry_offset + entry_run, <=,
 			    sm->sm_start + sm->sm_size);
 
-			error = callback(type, entry_offset, entry_size, arg);
+			space_map_entry_t sme = {
+			    .sme_type = type,
+			    .sme_vdev = vdev_id,
+			    .sme_offset = entry_offset,
+			    .sme_run = entry_run
+			};
+			error = callback(&sme, arg);
 			if (error != 0)
 				break;
 
 			if (type == SM_ALLOC)
-				sm->sm_phys->smp_alloc -= entry_size;
+				sm->sm_phys->smp_alloc -= entry_run;
 			else
-				sm->sm_phys->smp_alloc += entry_size;
-
-			sm->sm_phys->smp_objsize -= sizeof (uint64_t);
+				sm->sm_phys->smp_alloc += entry_run;
+			sm->sm_phys->smp_objsize -= words * sizeof (uint64_t);
 			space_map_update(sm);
-			len -= sizeof (uint64_t);
-			num_entries--;
 		}
-		IMPLY(error == 0, num_entries == 0);
-		EQUIV(offset == 0 && error == 0, len == 0 && num_entries == 0);
 	}
 
-	if (len == 0) {
+	if (space_map_length(sm) == 0) {
 		ASSERT0(error);
-		ASSERT0(offset);
-		ASSERT0(sm->sm_length);
 		ASSERT0(sm->sm_phys->smp_objsize);
 		ASSERT0(sm->sm_alloc);
 	}
 
-	zio_buf_free(entry_map, bufsize);
+	zio_buf_free(buf, bufsz);
 	return (error);
 }
 
@@ -244,16 +368,15 @@ typedef struct space_map_load_arg {
 } space_map_load_arg_t;
 
 static int
-space_map_load_callback(maptype_t type, uint64_t offset, uint64_t size,
-    void *arg)
+space_map_load_callback(space_map_entry_t *sme, void *arg)
 {
 	space_map_load_arg_t *smla = arg;
-	if (type == smla->smla_type) {
-		VERIFY3U(range_tree_space(smla->smla_rt) + size, <=,
+	if (sme->sme_type == smla->smla_type) {
+		VERIFY3U(range_tree_space(smla->smla_rt) + sme->sme_run, <=,
 		    smla->smla_sm->sm_size);
-		range_tree_add(smla->smla_rt, offset, size);
+		range_tree_add(smla->smla_rt, sme->sme_offset, sme->sme_run);
 	} else {
-		range_tree_remove(smla->smla_rt, offset, size);
+		range_tree_remove(smla->smla_rt, sme->sme_offset, sme->sme_run);
 	}
 
 	return (0);
@@ -365,43 +488,239 @@ space_map_histogram_add(space_map_t *sm, range_tree_t *rt, dmu_tx_t *tx)
 	}
 }
 
-uint64_t
-space_map_entries(space_map_t *sm, range_tree_t *rt)
+static void
+space_map_write_intro_debug(space_map_t *sm, maptype_t maptype, dmu_tx_t *tx)
 {
-	avl_tree_t *t = &rt->rt_root;
-	range_seg_t *rs;
-	uint64_t size, entries;
+	dmu_buf_will_dirty(sm->sm_dbuf, tx);
+
+	uint64_t dentry = SM_PREFIX_ENCODE(SM_DEBUG_PREFIX) |
+	    SM_DEBUG_ACTION_ENCODE(maptype) |
+	    SM_DEBUG_SYNCPASS_ENCODE(spa_sync_pass(tx->tx_pool->dp_spa)) |
+	    SM_DEBUG_TXG_ENCODE(dmu_tx_get_txg(tx));
+
+	dmu_write(sm->sm_os, space_map_object(sm), sm->sm_phys->smp_objsize,
+	    sizeof (dentry), &dentry, tx);
+
+	sm->sm_phys->smp_objsize += sizeof (dentry);
+}
+
+/*
+ * Writes one or more entries given a segment.
+ *
+ * Note: The function may release the dbuf from the pointer initially
+ * passed to it, and return a different dbuf. Also, the space map's
+ * dbuf must be dirty for the changes in sm_phys to take effect.
+ */
+static void
+space_map_write_seg(space_map_t *sm, range_seg_t *rs, maptype_t maptype,
+    uint64_t vdev_id, uint8_t words, dmu_buf_t **dbp, void *tag, dmu_tx_t *tx)
+{
+	ASSERT3U(words, !=, 0);
+	ASSERT3U(words, <=, 2);
+
+	/* ensure the vdev_id can be represented by the space map */
+	ASSERT3U(vdev_id, <=, SM_NO_VDEVID);
+
+	/*
+	 * if this is a single word entry, ensure that no vdev was
+	 * specified.
+	 */
+	IMPLY(words == 1, vdev_id == SM_NO_VDEVID);
+
+	dmu_buf_t *db = *dbp;
+	ASSERT3U(db->db_size, ==, sm->sm_blksz);
+
+	uint64_t *block_base = db->db_data;
+	uint64_t *block_end = block_base + (sm->sm_blksz / sizeof (uint64_t));
+	uint64_t *block_cursor = block_base +
+	    (sm->sm_phys->smp_objsize - db->db_offset) / sizeof (uint64_t);
+
+	ASSERT3P(block_cursor, <=, block_end);
+
+	uint64_t size = (rs->rs_end - rs->rs_start) >> sm->sm_shift;
+	uint64_t start = (rs->rs_start - sm->sm_start) >> sm->sm_shift;
+	uint64_t run_max = (words == 2) ? SM2_RUN_MAX : SM_RUN_MAX;
+
+	ASSERT3U(rs->rs_start, >=, sm->sm_start);
+	ASSERT3U(rs->rs_start, <, sm->sm_start + sm->sm_size);
+	ASSERT3U(rs->rs_end - rs->rs_start, <=, sm->sm_size);
+	ASSERT3U(rs->rs_end, <=, sm->sm_start + sm->sm_size);
+
+	while (size != 0) {
+		ASSERT3P(block_cursor, <=, block_end);
+
+		/*
+		 * If we are at the end of this block, flush it and start
+		 * writing again from the beginning.
+		 */
+		if (block_cursor == block_end) {
+			dmu_buf_rele(db, tag);
 
+			uint64_t next_word_offset = sm->sm_phys->smp_objsize;
+			VERIFY0(dmu_buf_hold(sm->sm_os,
+			    space_map_object(sm), next_word_offset,
+			    tag, &db, DMU_READ_PREFETCH));
+			dmu_buf_will_dirty(db, tx);
+
+			/* update caller's dbuf */
+			*dbp = db;
+
+			ASSERT3U(db->db_size, ==, sm->sm_blksz);
+
+			block_base = db->db_data;
+			block_cursor = block_base;
+			block_end = block_base +
+			    (db->db_size / sizeof (uint64_t));
+		}
+
+		/*
+		 * If we are writing a two-word entry and we only have one
+		 * word left on this block, just pad it with an empty debug
+		 * entry and write the two-word entry in the next block.
+		 */
+		uint64_t *next_entry = block_cursor + 1;
+		if (next_entry == block_end && words > 1) {
+			ASSERT3U(words, ==, 2);
+			*block_cursor = SM_PREFIX_ENCODE(SM_DEBUG_PREFIX) |
+			    SM_DEBUG_ACTION_ENCODE(0) |
+			    SM_DEBUG_SYNCPASS_ENCODE(0) |
+			    SM_DEBUG_TXG_ENCODE(0);
+			block_cursor++;
+			sm->sm_phys->smp_objsize += sizeof (uint64_t);
+			ASSERT3P(block_cursor, ==, block_end);
+			continue;
+		}
+
+		uint64_t run_len = MIN(size, run_max);
+		switch (words) {
+		case 1:
+			*block_cursor = SM_OFFSET_ENCODE(start) |
+			    SM_TYPE_ENCODE(maptype) |
+			    SM_RUN_ENCODE(run_len);
+			block_cursor++;
+			break;
+		case 2:
+			/* write the first word of the entry */
+			*block_cursor = SM_PREFIX_ENCODE(SM2_PREFIX) |
+			    SM2_RUN_ENCODE(run_len) |
+			    SM2_VDEV_ENCODE(vdev_id);
+			block_cursor++;
+
+			/* move on to the second word of the entry */
+			ASSERT3P(block_cursor, <, block_end);
+			*block_cursor = SM2_TYPE_ENCODE(maptype) |
+			    SM2_OFFSET_ENCODE(start);
+			block_cursor++;
+			break;
+		default:
+			panic("%d-word space map entries are not supported",
+			    words);
+			break;
+		}
+		sm->sm_phys->smp_objsize += words * sizeof (uint64_t);
+
+		start += run_len;
+		size -= run_len;
+	}
+	ASSERT0(size);
+
+}
+
+/*
+ * Note: The space map's dbuf must be dirty for the changes in sm_phys to
+ * take effect.
+ */
+static void
+space_map_write_impl(space_map_t *sm, range_tree_t *rt, maptype_t maptype,
+    uint64_t vdev_id, dmu_tx_t *tx)
+{
+	spa_t *spa = tx->tx_pool->dp_spa;
+	dmu_buf_t *db;
+
+	space_map_write_intro_debug(sm, maptype, tx);
+
+#ifdef DEBUG
 	/*
-	 * All space_maps always have a debug entry so account for it here.
+	 * We do this right after we write the intro debug entry
+	 * because the estimate does not take it into account.
 	 */
-	entries = 1;
+	uint64_t initial_objsize = sm->sm_phys->smp_objsize;
+	uint64_t estimated_growth =
+	    space_map_estimate_optimal_size(sm, rt, SM_NO_VDEVID);
+	uint64_t estimated_final_objsize = initial_objsize + estimated_growth;
+#endif
 
 	/*
-	 * Traverse the range tree and calculate the number of space map
-	 * entries that would be required to write out the range tree.
+	 * Find the offset right after the last word in the space map
+	 * and use that to get a hold of the last block, so we can
+	 * start appending to it.
 	 */
-	for (rs = avl_first(t); rs != NULL; rs = AVL_NEXT(t, rs)) {
-		size = (rs->rs_end - rs->rs_start) >> sm->sm_shift;
-		entries += howmany(size, SM_RUN_MAX);
+	uint64_t next_word_offset = sm->sm_phys->smp_objsize;
+	VERIFY0(dmu_buf_hold(sm->sm_os, space_map_object(sm),
+	    next_word_offset, FTAG, &db, DMU_READ_PREFETCH));
+	ASSERT3U(db->db_size, ==, sm->sm_blksz);
+
+	dmu_buf_will_dirty(db, tx);
+
+	avl_tree_t *t = &rt->rt_root;
+	for (range_seg_t *rs = avl_first(t); rs != NULL; rs = AVL_NEXT(t, rs)) {
+		uint64_t offset = (rs->rs_start - sm->sm_start) >> sm->sm_shift;
+		uint64_t length = (rs->rs_end - rs->rs_start) >> sm->sm_shift;
+		uint8_t words = 1;
+
+		/*
+		 * We only write two-word entries when both of the following
+		 * are true:
+		 *
+		 * [1] The feature is enabled.
+		 * [2] The offset or run is too big for a single-word entry,
+		 * 	or the vdev_id is set (meaning not equal to
+		 * 	SM_NO_VDEVID).
+		 *
+		 * Note that for purposes of testing we've added the case that
+		 * we write two-word entries occasionally when the feature is
+		 * enabled and zfs_force_some_double_word_sm_entries has been
+		 * set.
+		 */
+		if (spa_feature_is_active(spa, SPA_FEATURE_SPACEMAP_V2) &&
+		    (offset >= (1ULL << SM_OFFSET_BITS) ||
+		    length > SM_RUN_MAX ||
+		    vdev_id != SM_NO_VDEVID ||
+		    (zfs_force_some_double_word_sm_entries &&
+		    spa_get_random(100) == 0)))
+			words = 2;
+
+		space_map_write_seg(sm, rs, maptype, vdev_id, words,
+		    &db, FTAG, tx);
 	}
-	return (entries);
+
+	dmu_buf_rele(db, FTAG);
+
+#ifdef DEBUG
+	/*
+	 * We expect our estimation to be based on the worst case
+	 * scenario [see comment in space_map_estimate_optimal_size()].
+	 * Therefore we expect the actual objsize to be equal or less
+	 * than whatever we estimated it to be.
+	 */
+	ASSERT3U(estimated_final_objsize, >=, sm->sm_phys->smp_objsize);
+#endif
 }
 
+/*
+ * Note: This function manipulates the state of the given space map but
+ * does not hold any locks implicitly. Thus the caller is responsible
+ * for synchronizing writes to the space map.
+ */
 void
 space_map_write(space_map_t *sm, range_tree_t *rt, maptype_t maptype,
-    dmu_tx_t *tx)
+    uint64_t vdev_id, dmu_tx_t *tx)
 {
 	objset_t *os = sm->sm_os;
-	spa_t *spa = dmu_objset_spa(os);
-	avl_tree_t *t = &rt->rt_root;
-	range_seg_t *rs;
-	uint64_t size, total, rt_space, nodes;
-	uint64_t *entry, *entry_map, *entry_map_end;
-	uint64_t expected_entries, actual_entries = 1;
 
 	ASSERT(dsl_pool_sync_context(dmu_objset_pool(os)));
 	VERIFY3U(space_map_object(sm), !=, 0);
+
 	dmu_buf_will_dirty(sm->sm_dbuf, tx);
 
 	/*
@@ -421,58 +740,10 @@ space_map_write(space_map_t *sm, range_tree_t *rt, maptype_t maptype,
 	else
 		sm->sm_phys->smp_alloc -= range_tree_space(rt);
 
-	expected_entries = space_map_entries(sm, rt);
-
-	entry_map = zio_buf_alloc(sm->sm_blksz);
-	entry_map_end = entry_map + (sm->sm_blksz / sizeof (uint64_t));
-	entry = entry_map;
-
-	*entry++ = SM_DEBUG_ENCODE(1) |
-	    SM_DEBUG_ACTION_ENCODE(maptype) |
-	    SM_DEBUG_SYNCPASS_ENCODE(spa_sync_pass(spa)) |
-	    SM_DEBUG_TXG_ENCODE(dmu_tx_get_txg(tx));
-
-	total = 0;
-	nodes = avl_numnodes(&rt->rt_root);
-	rt_space = range_tree_space(rt);
-	for (rs = avl_first(t); rs != NULL; rs = AVL_NEXT(t, rs)) {
-		uint64_t start;
-
-		size = (rs->rs_end - rs->rs_start) >> sm->sm_shift;
-		start = (rs->rs_start - sm->sm_start) >> sm->sm_shift;
+	uint64_t nodes = avl_numnodes(&rt->rt_root);
+	uint64_t rt_space = range_tree_space(rt);
 
-		total += size << sm->sm_shift;
-
-		while (size != 0) {
-			uint64_t run_len;
-
-			run_len = MIN(size, SM_RUN_MAX);
-
-			if (entry == entry_map_end) {
-				dmu_write(os, space_map_object(sm),
-				    sm->sm_phys->smp_objsize, sm->sm_blksz,
-				    entry_map, tx);
-				sm->sm_phys->smp_objsize += sm->sm_blksz;
-				entry = entry_map;
-			}
-
-			*entry++ = SM_OFFSET_ENCODE(start) |
-			    SM_TYPE_ENCODE(maptype) |
-			    SM_RUN_ENCODE(run_len);
-
-			start += run_len;
-			size -= run_len;
-			actual_entries++;
-		}
-	}
-
-	if (entry != entry_map) {
-		size = (entry - entry_map) * sizeof (uint64_t);
-		dmu_write(os, space_map_object(sm), sm->sm_phys->smp_objsize,
-		    size, entry_map, tx);
-		sm->sm_phys->smp_objsize += size;
-	}
-	ASSERT3U(expected_entries, ==, actual_entries);
+	space_map_write_impl(sm, rt, maptype, vdev_id, tx);
 
 	/*
 	 * Ensure that the space_map's accounting wasn't changed
@@ -480,9 +751,6 @@ space_map_write(space_map_t *sm, range_tree_t *rt, maptype_t maptype,
 	 */
 	VERIFY3U(nodes, ==, avl_numnodes(&rt->rt_root));
 	VERIFY3U(range_tree_space(rt), ==, rt_space);
-	VERIFY3U(range_tree_space(rt), ==, total);
-
-	zio_buf_free(entry_map, sm->sm_blksz);
 }
 
 static int
@@ -524,7 +792,6 @@ space_map_open(space_map_t **smp, objset_t *os, uint64_t object,
 		space_map_close(sm);
 		return (error);
 	}
-
 	*smp = sm;
 
 	return (0);
@@ -656,6 +923,133 @@ space_map_free(space_map_t *sm, dmu_tx_t *tx)
 	sm->sm_object = 0;
 }
 
+/*
+ * Given a range tree, it makes a worst-case estimate of how much
+ * space would the tree's segments take if they were written to
+ * the given space map.
+ */
+uint64_t
+space_map_estimate_optimal_size(space_map_t *sm, range_tree_t *rt,
+    uint64_t vdev_id)
+{
+	spa_t *spa = dmu_objset_spa(sm->sm_os);
+	uint64_t shift = sm->sm_shift;
+	uint64_t *histogram = rt->rt_histogram;
+	uint64_t entries_for_seg = 0;
+
+	/*
+	 * In order to get a quick estimate of the optimal size that this
+	 * range tree would have on-disk as a space map, we iterate through
+	 * its histogram buckets instead of iterating through its nodes.
+	 *
+	 * Note that this is a highest-bound/worst-case estimate for the
+	 * following reasons:
+	 *
+	 * 1] We assume that we always add a debug padding for each block
+	 *    we write and we also assume that we start at the last word
+	 *    of a block attempting to write a two-word entry.
+	 * 2] Rounding up errors due to the way segments are distributed
+	 *    in the buckets of the range tree's histogram.
+	 * 3] The activation of zfs_force_some_double_word_sm_entries
+	 *    (tunable) when testing.
+	 *
+	 * = Math and Rounding Errors =
+	 *
+	 * rt_histogram[i] bucket of a range tree represents the number
+	 * of entries in [2^i, (2^(i+1))-1] of that range_tree. Given
+	 * that, we want to divide the buckets into groups: Buckets that
+	 * can be represented using a single-word entry, ones that can
+	 * be represented with a double-word entry, and ones that can
+	 * only be represented with multiple two-word entries.
+	 *
+	 * [Note that if the new encoding feature is not enabled there
+	 * are only two groups: single-word entry buckets and multiple
+	 * single-word entry buckets. The information below assumes
+	 * two-word entries enabled, but it can easily applied when
+	 * the feature is not enabled]
+	 *
+	 * To find the highest bucket that can be represented with a
+	 * single-word entry we look at the maximum run that such entry
+	 * can have, which is 2^(SM_RUN_BITS + sm_shift) [remember that
+	 * the run of a space map entry is shifted by sm_shift, thus we
+	 * add it to the exponent]. This way, excluding the value of the
+	 * maximum run that can be represented by a single-word entry,
+	 * all runs that are smaller exist in buckets 0 to
+	 * SM_RUN_BITS + shift - 1.
+	 *
+	 * To find the highest bucket that can be represented with a
+	 * double-word entry, we follow the same approach. Finally, any
+	 * bucket higher than that are represented with multiple two-word
+	 * entries. To be more specific, if the highest bucket whose
+	 * segments can be represented with a single two-word entry is X,
+	 * then bucket X+1 will need 2 two-word entries for each of its
+	 * segments, X+2 will need 4, X+3 will need 8, ...etc.
+	 *
+	 * With all of the above we make our estimation based on bucket
+	 * groups. There is a rounding error though. As we mentioned in
+	 * the example with the one-word entry, the maximum run that can
+	 * be represented in a one-word entry 2^(SM_RUN_BITS + shift) is
+	 * not part of bucket SM_RUN_BITS + shift - 1. Thus, segments of
+	 * that length fall into the next bucket (and bucket group) where
+	 * we start counting two-word entries and this is one more reason
+	 * why the estimated size may end up being bigger than the actual
+	 * size written.
+	 */
+	uint64_t size = 0;
+	uint64_t idx = 0;
+
+	if (!spa_feature_is_enabled(spa, SPA_FEATURE_SPACEMAP_V2) ||
+	    (vdev_id == SM_NO_VDEVID && sm->sm_size < SM_OFFSET_MAX)) {
+
+		/*
+		 * If we are trying to force some double word entries just
+		 * assume the worst-case of every single word entry being
+		 * written as a double word entry.
+		 */
+		uint64_t entry_size =
+		    (spa_feature_is_enabled(spa, SPA_FEATURE_SPACEMAP_V2) &&
+		    zfs_force_some_double_word_sm_entries) ?
+		    (2 * sizeof (uint64_t)) : sizeof (uint64_t);
+
+		uint64_t single_entry_max_bucket = SM_RUN_BITS + shift - 1;
+		for (; idx <= single_entry_max_bucket; idx++)
+			size += histogram[idx] * entry_size;
+
+		if (!spa_feature_is_enabled(spa, SPA_FEATURE_SPACEMAP_V2)) {
+			for (; idx < RANGE_TREE_HISTOGRAM_SIZE; idx++) {
+				ASSERT3U(idx, >=, single_entry_max_bucket);
+				entries_for_seg =
+				    1ULL << (idx - single_entry_max_bucket);
+				size += histogram[idx] *
+				    entries_for_seg * entry_size;
+			}
+			return (size);
+		}
+	}
+
+	ASSERT(spa_feature_is_enabled(spa, SPA_FEATURE_SPACEMAP_V2));
+
+	uint64_t double_entry_max_bucket = SM2_RUN_BITS + shift - 1;
+	for (; idx <= double_entry_max_bucket; idx++)
+		size += histogram[idx] * 2 * sizeof (uint64_t);
+
+	for (; idx < RANGE_TREE_HISTOGRAM_SIZE; idx++) {
+		ASSERT3U(idx, >=, double_entry_max_bucket);
+		entries_for_seg = 1ULL << (idx - double_entry_max_bucket);
+		size += histogram[idx] *
+		    entries_for_seg * 2 * sizeof (uint64_t);
+	}
+
+	/*
+	 * Assume the worst case where we start with the padding at the end
+	 * of the current block and we add an extra padding entry at the end
+	 * of all subsequent blocks.
+	 */
+	size += ((size / sm->sm_blksz) + 1) * sizeof (uint64_t);
+
+	return (size);
+}
+
 uint64_t
 space_map_object(space_map_t *sm)
 {
diff --git a/usr/src/uts/common/fs/zfs/sys/metaslab.h b/usr/src/uts/common/fs/zfs/sys/metaslab.h
index a76d344d21..32a19ca645 100644
--- a/usr/src/uts/common/fs/zfs/sys/metaslab.h
+++ b/usr/src/uts/common/fs/zfs/sys/metaslab.h
@@ -20,7 +20,7 @@
  */
 /*
  * Copyright (c) 2005, 2010, Oracle and/or its affiliates. All rights reserved.
- * Copyright (c) 2011, 2017 by Delphix. All rights reserved.
+ * Copyright (c) 2011, 2018 by Delphix. All rights reserved.
  */
 
 #ifndef _SYS_METASLAB_H
@@ -65,9 +65,10 @@ uint64_t metaslab_block_maxsize(metaslab_t *);
 #define	METASLAB_DONT_THROTTLE		0x10
 
 int metaslab_alloc(spa_t *, metaslab_class_t *, uint64_t,
-    blkptr_t *, int, uint64_t, blkptr_t *, int, zio_alloc_list_t *, zio_t *);
+    blkptr_t *, int, uint64_t, blkptr_t *, int, zio_alloc_list_t *, zio_t *,
+    int);
 int metaslab_alloc_dva(spa_t *, metaslab_class_t *, uint64_t,
-    dva_t *, int, dva_t *, uint64_t, int, zio_alloc_list_t *);
+    dva_t *, int, dva_t *, uint64_t, int, zio_alloc_list_t *, int);
 void metaslab_free(spa_t *, const blkptr_t *, uint64_t, boolean_t);
 void metaslab_free_concrete(vdev_t *, uint64_t, uint64_t, boolean_t);
 void metaslab_free_dva(spa_t *, const dva_t *, boolean_t);
@@ -88,9 +89,9 @@ int metaslab_class_validate(metaslab_class_t *);
 void metaslab_class_histogram_verify(metaslab_class_t *);
 uint64_t metaslab_class_fragmentation(metaslab_class_t *);
 uint64_t metaslab_class_expandable_space(metaslab_class_t *);
-boolean_t metaslab_class_throttle_reserve(metaslab_class_t *, int,
+boolean_t metaslab_class_throttle_reserve(metaslab_class_t *, int, int,
     zio_t *, int);
-void metaslab_class_throttle_unreserve(metaslab_class_t *, int, zio_t *);
+void metaslab_class_throttle_unreserve(metaslab_class_t *, int, int, zio_t *);
 
 void metaslab_class_space_update(metaslab_class_t *, int64_t, int64_t,
     int64_t, int64_t);
@@ -99,7 +100,7 @@ uint64_t metaslab_class_get_space(metaslab_class_t *);
 uint64_t metaslab_class_get_dspace(metaslab_class_t *);
 uint64_t metaslab_class_get_deferred(metaslab_class_t *);
 
-metaslab_group_t *metaslab_group_create(metaslab_class_t *, vdev_t *);
+metaslab_group_t *metaslab_group_create(metaslab_class_t *, vdev_t *, int);
 void metaslab_group_destroy(metaslab_group_t *);
 void metaslab_group_activate(metaslab_group_t *);
 void metaslab_group_passivate(metaslab_group_t *);
@@ -108,8 +109,9 @@ uint64_t metaslab_group_get_space(metaslab_group_t *);
 void metaslab_group_histogram_verify(metaslab_group_t *);
 uint64_t metaslab_group_fragmentation(metaslab_group_t *);
 void metaslab_group_histogram_remove(metaslab_group_t *, metaslab_t *);
-void metaslab_group_alloc_decrement(spa_t *, uint64_t, void *, int);
-void metaslab_group_alloc_verify(spa_t *, const blkptr_t *, void *);
+void metaslab_group_alloc_decrement(spa_t *, uint64_t, void *, int, int,
+    boolean_t);
+void metaslab_group_alloc_verify(spa_t *, const blkptr_t *, void *, int);
 
 #ifdef	__cplusplus
 }
diff --git a/usr/src/uts/common/fs/zfs/sys/metaslab_impl.h b/usr/src/uts/common/fs/zfs/sys/metaslab_impl.h
index a6673fbe06..6a02f7c800 100644
--- a/usr/src/uts/common/fs/zfs/sys/metaslab_impl.h
+++ b/usr/src/uts/common/fs/zfs/sys/metaslab_impl.h
@@ -24,7 +24,7 @@
  */
 
 /*
- * Copyright (c) 2011, 2017 by Delphix. All rights reserved.
+ * Copyright (c) 2011, 2018 by Delphix. All rights reserved.
  */
 
 #ifndef _SYS_METASLAB_IMPL_H
@@ -52,6 +52,7 @@ typedef struct metaslab_alloc_trace {
 	uint64_t			mat_weight;
 	uint32_t			mat_dva_id;
 	uint64_t			mat_offset;
+	int					mat_allocator;
 } metaslab_alloc_trace_t;
 
 /*
@@ -72,9 +73,11 @@ typedef enum trace_alloc_type {
 
 #define	METASLAB_WEIGHT_PRIMARY		(1ULL << 63)
 #define	METASLAB_WEIGHT_SECONDARY	(1ULL << 62)
-#define	METASLAB_WEIGHT_TYPE		(1ULL << 61)
+#define	METASLAB_WEIGHT_CLAIM		(1ULL << 61)
+#define	METASLAB_WEIGHT_TYPE		(1ULL << 60)
 #define	METASLAB_ACTIVE_MASK		\
-	(METASLAB_WEIGHT_PRIMARY | METASLAB_WEIGHT_SECONDARY)
+	(METASLAB_WEIGHT_PRIMARY | METASLAB_WEIGHT_SECONDARY | \
+	METASLAB_WEIGHT_CLAIM)
 
 /*
  * The metaslab weight is used to encode the amount of free space in a
@@ -97,37 +100,39 @@ typedef enum trace_alloc_type {
  *
  *      64      56      48      40      32      24      16      8       0
  *      +-------+-------+-------+-------+-------+-------+-------+-------+
- *      |PS1|                   weighted-free space                     |
+ *      |PSC1|                  weighted-free space                     |
  *      +-------+-------+-------+-------+-------+-------+-------+-------+
  *
  *	PS - indicates primary and secondary activation
+ *	C - indicates activation for claimed block zio
  *	space - the fragmentation-weighted space
  *
  * Segment-based weight:
  *
  *      64      56      48      40      32      24      16      8       0
  *      +-------+-------+-------+-------+-------+-------+-------+-------+
- *      |PS0| idx|             count of segments in region              |
+ *      |PSC0| idx|            count of segments in region              |
  *      +-------+-------+-------+-------+-------+-------+-------+-------+
  *
  *	PS - indicates primary and secondary activation
+ *	C - indicates activation for claimed block zio
  *	idx - index for the highest bucket in the histogram
  *	count - number of segments in the specified bucket
  */
-#define	WEIGHT_GET_ACTIVE(weight)		BF64_GET((weight), 62, 2)
-#define	WEIGHT_SET_ACTIVE(weight, x)		BF64_SET((weight), 62, 2, x)
+#define	WEIGHT_GET_ACTIVE(weight)		BF64_GET((weight), 61, 3)
+#define	WEIGHT_SET_ACTIVE(weight, x)		BF64_SET((weight), 61, 3, x)
 
 #define	WEIGHT_IS_SPACEBASED(weight)		\
-	((weight) == 0 || BF64_GET((weight), 61, 1))
-#define	WEIGHT_SET_SPACEBASED(weight)		BF64_SET((weight), 61, 1, 1)
+	((weight) == 0 || BF64_GET((weight), 60, 1))
+#define	WEIGHT_SET_SPACEBASED(weight)		BF64_SET((weight), 60, 1, 1)
 
 /*
  * These macros are only applicable to segment-based weighting.
  */
-#define	WEIGHT_GET_INDEX(weight)		BF64_GET((weight), 55, 6)
-#define	WEIGHT_SET_INDEX(weight, x)		BF64_SET((weight), 55, 6, x)
-#define	WEIGHT_GET_COUNT(weight)		BF64_GET((weight), 0, 55)
-#define	WEIGHT_SET_COUNT(weight, x)		BF64_SET((weight), 0, 55, x)
+#define	WEIGHT_GET_INDEX(weight)		BF64_GET((weight), 54, 6)
+#define	WEIGHT_SET_INDEX(weight, x)		BF64_SET((weight), 54, 6, x)
+#define	WEIGHT_GET_COUNT(weight)		BF64_GET((weight), 0, 54)
+#define	WEIGHT_SET_COUNT(weight, x)		BF64_SET((weight), 0, 54, x)
 
 /*
  * A metaslab class encompasses a category of allocatable top-level vdevs.
@@ -178,8 +183,8 @@ struct metaslab_class {
 	 * allowed to reserve slots even if we've reached the maximum
 	 * number of allocations allowed.
 	 */
-	uint64_t		mc_alloc_max_slots;
-	refcount_t		mc_alloc_slots;
+	uint64_t		*mc_alloc_max_slots;
+	refcount_t		*mc_alloc_slots;
 
 	uint64_t		mc_alloc_groups; /* # of allocatable groups */
 
@@ -201,9 +206,12 @@ struct metaslab_class {
  */
 struct metaslab_group {
 	kmutex_t		mg_lock;
+	metaslab_t		**mg_primaries;
+	metaslab_t		**mg_secondaries;
 	avl_tree_t		mg_metaslab_tree;
 	uint64_t		mg_aliquot;
 	boolean_t		mg_allocatable;		/* can we allocate? */
+	uint64_t		mg_ms_ready;
 
 	/*
 	 * A metaslab group is considered to be initialized only after
@@ -223,15 +231,33 @@ struct metaslab_group {
 	metaslab_group_t	*mg_next;
 
 	/*
-	 * Each metaslab group can handle mg_max_alloc_queue_depth allocations
-	 * which are tracked by mg_alloc_queue_depth. It's possible for a
-	 * metaslab group to handle more allocations than its max. This
-	 * can occur when gang blocks are required or when other groups
-	 * are unable to handle their share of allocations.
+	 * In order for the allocation throttle to function properly, we cannot
+	 * have too many IOs going to each disk by default; the throttle
+	 * operates by allocating more work to disks that finish quickly, so
+	 * allocating larger chunks to each disk reduces its effectiveness.
+	 * However, if the number of IOs going to each allocator is too small,
+	 * we will not perform proper aggregation at the vdev_queue layer,
+	 * also resulting in decreased performance. Therefore, we will use a
+	 * ramp-up strategy.
+	 *
+	 * Each allocator in each metaslab group has a current queue depth
+	 * (mg_alloc_queue_depth[allocator]) and a current max queue depth
+	 * (mg_cur_max_alloc_queue_depth[allocator]), and each metaslab group
+	 * has an absolute max queue depth (mg_max_alloc_queue_depth).  We
+	 * add IOs to an allocator until the mg_alloc_queue_depth for that
+	 * allocator hits the cur_max. Every time an IO completes for a given
+	 * allocator on a given metaslab group, we increment its cur_max until
+	 * it reaches mg_max_alloc_queue_depth. The cur_max resets every txg to
+	 * help protect against disks that decrease in performance over time.
+	 *
+	 * It's possible for an allocator to handle more allocations than
+	 * its max. This can occur when gang blocks are required or when other
+	 * groups are unable to handle their share of allocations.
 	 */
 	uint64_t		mg_max_alloc_queue_depth;
-	refcount_t		mg_alloc_queue_depth;
-
+	uint64_t		*mg_cur_max_alloc_queue_depth;
+	refcount_t		*mg_alloc_queue_depth;
+	int			mg_allocators;
 	/*
 	 * A metalab group that can no longer allocate the minimum block
 	 * size will set mg_no_free_space. Once a metaslab group is out
@@ -355,6 +381,13 @@ struct metaslab {
 	uint64_t	ms_alloc_txg;	/* last successful alloc (debug only) */
 	uint64_t	ms_max_size;	/* maximum allocatable size	*/
 
+	/*
+	 * -1 if it's not active in an allocator, otherwise set to the allocator
+	 * this metaslab is active for.
+	 */
+	int		ms_allocator;
+	boolean_t	ms_primary; /* Only valid if ms_allocator is not -1 */
+
 	/*
 	 * The metaslab block allocators can optionally use a size-ordered
 	 * range tree and/or an array of LBAs. Not all allocators use
@@ -369,6 +402,8 @@ struct metaslab {
 	metaslab_group_t *ms_group;	/* metaslab group		*/
 	avl_node_t	ms_group_node;	/* node in metaslab group tree	*/
 	txg_node_t	ms_txg_node;	/* per-txg dirty metaslab links	*/
+
+	boolean_t	ms_new;
 };
 
 #ifdef	__cplusplus
diff --git a/usr/src/uts/common/fs/zfs/sys/spa.h b/usr/src/uts/common/fs/zfs/sys/spa.h
index 936d805389..b2d85079d3 100644
--- a/usr/src/uts/common/fs/zfs/sys/spa.h
+++ b/usr/src/uts/common/fs/zfs/sys/spa.h
@@ -138,6 +138,7 @@ _NOTE(CONSTCOND) } while (0)
 #define	SPA_ASIZEBITS		24	/* ASIZE up to 64 times larger	*/
 
 #define	SPA_COMPRESSBITS	7
+#define	SPA_VDEVBITS		24
 
 /*
  * All SPA data is represented by 128-bit data virtual addresses (DVAs).
@@ -168,15 +169,15 @@ typedef struct zio_cksum_salt {
  *
  *	64	56	48	40	32	24	16	8	0
  *	+-------+-------+-------+-------+-------+-------+-------+-------+
- * 0	|		vdev1		| GRID  |	  ASIZE		|
+ * 0	|  pad  |	  vdev1         | GRID  |	  ASIZE		|
  *	+-------+-------+-------+-------+-------+-------+-------+-------+
  * 1	|G|			 offset1				|
  *	+-------+-------+-------+-------+-------+-------+-------+-------+
- * 2	|		vdev2		| GRID  |	  ASIZE		|
+ * 2	|  pad  |	  vdev2         | GRID  |	  ASIZE		|
  *	+-------+-------+-------+-------+-------+-------+-------+-------+
  * 3	|G|			 offset2				|
  *	+-------+-------+-------+-------+-------+-------+-------+-------+
- * 4	|		vdev3		| GRID  |	  ASIZE		|
+ * 4	|  pad  |	  vdev3         | GRID  |	  ASIZE		|
  *	+-------+-------+-------+-------+-------+-------+-------+-------+
  * 5	|G|			 offset3				|
  *	+-------+-------+-------+-------+-------+-------+-------+-------+
@@ -355,8 +356,9 @@ typedef struct blkptr {
 #define	DVA_GET_GRID(dva)	BF64_GET((dva)->dva_word[0], 24, 8)
 #define	DVA_SET_GRID(dva, x)	BF64_SET((dva)->dva_word[0], 24, 8, x)
 
-#define	DVA_GET_VDEV(dva)	BF64_GET((dva)->dva_word[0], 32, 32)
-#define	DVA_SET_VDEV(dva, x)	BF64_SET((dva)->dva_word[0], 32, 32, x)
+#define	DVA_GET_VDEV(dva)	BF64_GET((dva)->dva_word[0], 32, SPA_VDEVBITS)
+#define	DVA_SET_VDEV(dva, x)	\
+	BF64_SET((dva)->dva_word[0], 32, SPA_VDEVBITS, x)
 
 #define	DVA_GET_OFFSET(dva)	\
 	BF64_GET_SB((dva)->dva_word[1], 0, 63, SPA_MINBLOCKSHIFT, 0)
diff --git a/usr/src/uts/common/fs/zfs/sys/spa_impl.h b/usr/src/uts/common/fs/zfs/sys/spa_impl.h
index a23f9b8c4f..a6da04b67b 100644
--- a/usr/src/uts/common/fs/zfs/sys/spa_impl.h
+++ b/usr/src/uts/common/fs/zfs/sys/spa_impl.h
@@ -237,8 +237,16 @@ struct spa {
 	uint64_t	spa_last_synced_guid;	/* last synced guid */
 	list_t		spa_config_dirty_list;	/* vdevs with dirty config */
 	list_t		spa_state_dirty_list;	/* vdevs with dirty state */
-	kmutex_t	spa_alloc_lock;
-	avl_tree_t	spa_alloc_tree;
+	/*
+	 * spa_alloc_locks and spa_alloc_trees are arrays, whose lengths are
+	 * stored in spa_alloc_count. There is one tree and one lock for each
+	 * allocator, to help improve allocation performance in write-heavy
+	 * workloads.
+	 */
+	kmutex_t	*spa_alloc_locks;
+	avl_tree_t	*spa_alloc_trees;
+	int		spa_alloc_count;
+
 	spa_aux_vdev_t	spa_spares;		/* hot spares */
 	spa_aux_vdev_t	spa_l2cache;		/* L2ARC cache devices */
 	nvlist_t	*spa_label_features;	/* Features for reading MOS */
diff --git a/usr/src/uts/common/fs/zfs/sys/space_map.h b/usr/src/uts/common/fs/zfs/sys/space_map.h
index 98b87269cb..d3d852978a 100644
--- a/usr/src/uts/common/fs/zfs/sys/space_map.h
+++ b/usr/src/uts/common/fs/zfs/sys/space_map.h
@@ -93,50 +93,100 @@ typedef struct space_map {
 /*
  * debug entry
  *
- *    1      3         10                     50
- *  ,---+--------+------------+---------------------------------.
- *  | 1 | action |  syncpass  |        txg (lower bits)         |
- *  `---+--------+------------+---------------------------------'
- *   63  62    60 59        50 49                               0
+ *     2     2        10                     50
+ *  +-----+-----+------------+----------------------------------+
+ *  | 1 0 | act |  syncpass  |        txg (lower bits)          |
+ *  +-----+-----+------------+----------------------------------+
+ *   63 62 61 60 59        50 49                                0
  *
  *
- * non-debug entry
+ * one-word entry
  *
  *    1               47                   1           15
- *  ,-----------------------------------------------------------.
+ *  +-----------------------------------------------------------+
  *  | 0 |   offset (sm_shift units)    | type |       run       |
- *  `-----------------------------------------------------------'
- *   63  62                          17   16   15               0
+ *  +-----------------------------------------------------------+
+ *   63  62                          16   15   14               0
+ *
+ *
+ * two-word entry
+ *
+ *     2     2               36                      24
+ *  +-----+-----+---------------------------+-------------------+
+ *  | 1 1 | pad |            run            |       vdev        |
+ *  +-----+-----+---------------------------+-------------------+
+ *   63 62 61 60 59                       24 23                 0
+ *
+ *     1                            63
+ *  +------+----------------------------------------------------+
+ *  | type |                      offset                        |
+ *  +------+----------------------------------------------------+
+ *     63   62                                                  0
+ *
+ * Note that a two-word entry will not strandle a block boundary.
+ * If necessary, the last word of a block will be padded with a
+ * debug entry (with act = syncpass = txg = 0).
  */
 
-/* All this stuff takes and returns bytes */
-#define	SM_RUN_DECODE(x)	(BF64_DECODE(x, 0, 15) + 1)
-#define	SM_RUN_ENCODE(x)	BF64_ENCODE((x) - 1, 0, 15)
-#define	SM_TYPE_DECODE(x)	BF64_DECODE(x, 15, 1)
-#define	SM_TYPE_ENCODE(x)	BF64_ENCODE(x, 15, 1)
-#define	SM_OFFSET_DECODE(x)	BF64_DECODE(x, 16, 47)
-#define	SM_OFFSET_ENCODE(x)	BF64_ENCODE(x, 16, 47)
-#define	SM_DEBUG_DECODE(x)	BF64_DECODE(x, 63, 1)
-#define	SM_DEBUG_ENCODE(x)	BF64_ENCODE(x, 63, 1)
+typedef enum {
+	SM_ALLOC,
+	SM_FREE
+} maptype_t;
+
+typedef struct space_map_entry {
+	maptype_t sme_type;
+	uint32_t sme_vdev;	/* max is 2^24-1; SM_NO_VDEVID if not present */
+	uint64_t sme_offset;	/* max is 2^63-1; units of sm_shift */
+	uint64_t sme_run;	/* max is 2^36; units of sm_shift */
+} space_map_entry_t;
+
+#define	SM_NO_VDEVID	(1 << SPA_VDEVBITS)
 
-#define	SM_DEBUG_ACTION_DECODE(x)	BF64_DECODE(x, 60, 3)
-#define	SM_DEBUG_ACTION_ENCODE(x)	BF64_ENCODE(x, 60, 3)
+/* one-word entry constants */
+#define	SM_DEBUG_PREFIX	2
+#define	SM_OFFSET_BITS	47
+#define	SM_RUN_BITS	15
 
+/* two-word entry constants */
+#define	SM2_PREFIX	3
+#define	SM2_OFFSET_BITS	63
+#define	SM2_RUN_BITS	36
+
+#define	SM_PREFIX_DECODE(x)	BF64_DECODE(x, 62, 2)
+#define	SM_PREFIX_ENCODE(x)	BF64_ENCODE(x, 62, 2)
+
+#define	SM_DEBUG_ACTION_DECODE(x)	BF64_DECODE(x, 60, 2)
+#define	SM_DEBUG_ACTION_ENCODE(x)	BF64_ENCODE(x, 60, 2)
 #define	SM_DEBUG_SYNCPASS_DECODE(x)	BF64_DECODE(x, 50, 10)
 #define	SM_DEBUG_SYNCPASS_ENCODE(x)	BF64_ENCODE(x, 50, 10)
-
 #define	SM_DEBUG_TXG_DECODE(x)		BF64_DECODE(x, 0, 50)
 #define	SM_DEBUG_TXG_ENCODE(x)		BF64_ENCODE(x, 0, 50)
 
-#define	SM_RUN_MAX			SM_RUN_DECODE(~0ULL)
-
-typedef enum {
-	SM_ALLOC,
-	SM_FREE
-} maptype_t;
-
-typedef int (*sm_cb_t)(maptype_t type, uint64_t offset, uint64_t size,
-    void *arg);
+#define	SM_OFFSET_DECODE(x)	BF64_DECODE(x, 16, SM_OFFSET_BITS)
+#define	SM_OFFSET_ENCODE(x)	BF64_ENCODE(x, 16, SM_OFFSET_BITS)
+#define	SM_TYPE_DECODE(x)	BF64_DECODE(x, 15, 1)
+#define	SM_TYPE_ENCODE(x)	BF64_ENCODE(x, 15, 1)
+#define	SM_RUN_DECODE(x)	(BF64_DECODE(x, 0, SM_RUN_BITS) + 1)
+#define	SM_RUN_ENCODE(x)	BF64_ENCODE((x) - 1, 0, SM_RUN_BITS)
+#define	SM_RUN_MAX		SM_RUN_DECODE(~0ULL)
+#define	SM_OFFSET_MAX		SM_OFFSET_DECODE(~0ULL)
+
+#define	SM2_RUN_DECODE(x)	(BF64_DECODE(x, SPA_VDEVBITS, SM2_RUN_BITS) + 1)
+#define	SM2_RUN_ENCODE(x)	BF64_ENCODE((x) - 1, SPA_VDEVBITS, SM2_RUN_BITS)
+#define	SM2_VDEV_DECODE(x)	BF64_DECODE(x, 0, SPA_VDEVBITS)
+#define	SM2_VDEV_ENCODE(x)	BF64_ENCODE(x, 0, SPA_VDEVBITS)
+#define	SM2_TYPE_DECODE(x)	BF64_DECODE(x, SM2_OFFSET_BITS, 1)
+#define	SM2_TYPE_ENCODE(x)	BF64_ENCODE(x, SM2_OFFSET_BITS, 1)
+#define	SM2_OFFSET_DECODE(x)	BF64_DECODE(x, 0, SM2_OFFSET_BITS)
+#define	SM2_OFFSET_ENCODE(x)	BF64_ENCODE(x, 0, SM2_OFFSET_BITS)
+#define	SM2_RUN_MAX		SM2_RUN_DECODE(~0ULL)
+#define	SM2_OFFSET_MAX		SM2_OFFSET_DECODE(~0ULL)
+
+boolean_t sm_entry_is_debug(uint64_t e);
+boolean_t sm_entry_is_single_word(uint64_t e);
+boolean_t sm_entry_is_double_word(uint64_t e);
+
+typedef int (*sm_cb_t)(space_map_entry_t *sme, void *arg);
 
 int space_map_load(space_map_t *sm, range_tree_t *rt, maptype_t maptype);
 int space_map_iterate(space_map_t *sm, sm_cb_t callback, void *arg);
@@ -154,7 +204,9 @@ uint64_t space_map_allocated(space_map_t *sm);
 uint64_t space_map_length(space_map_t *sm);
 
 void space_map_write(space_map_t *sm, range_tree_t *rt, maptype_t maptype,
-    dmu_tx_t *tx);
+    uint64_t vdev_id, dmu_tx_t *tx);
+uint64_t space_map_estimate_optimal_size(space_map_t *sm, range_tree_t *rt,
+    uint64_t vdev_id);
 void space_map_truncate(space_map_t *sm, int blocksize, dmu_tx_t *tx);
 uint64_t space_map_alloc(objset_t *os, int blocksize, dmu_tx_t *tx);
 void space_map_free(space_map_t *sm, dmu_tx_t *tx);
diff --git a/usr/src/uts/common/fs/zfs/sys/vdev_impl.h b/usr/src/uts/common/fs/zfs/sys/vdev_impl.h
index 4327f61af9..252069c5a4 100644
--- a/usr/src/uts/common/fs/zfs/sys/vdev_impl.h
+++ b/usr/src/uts/common/fs/zfs/sys/vdev_impl.h
@@ -20,7 +20,7 @@
  */
 /*
  * Copyright (c) 2005, 2010, Oracle and/or its affiliates. All rights reserved.
- * Copyright (c) 2011, 2017 by Delphix. All rights reserved.
+ * Copyright (c) 2011, 2018 by Delphix. All rights reserved.
  */
 
 #ifndef _SYS_VDEV_IMPL_H
@@ -59,6 +59,7 @@ typedef struct vdev_cache_entry vdev_cache_entry_t;
 struct abd;
 
 extern int zfs_vdev_queue_depth_pct;
+extern int zfs_vdev_def_queue_depth;
 extern uint32_t zfs_vdev_async_write_max_active;
 
 /*
diff --git a/usr/src/uts/common/fs/zfs/sys/zio.h b/usr/src/uts/common/fs/zfs/sys/zio.h
index 1520216c8f..273e5fcb0b 100644
--- a/usr/src/uts/common/fs/zfs/sys/zio.h
+++ b/usr/src/uts/common/fs/zfs/sys/zio.h
@@ -22,7 +22,7 @@
 /*
  * Copyright (c) 2005, 2010, Oracle and/or its affiliates. All rights reserved.
  * Copyright 2011 Nexenta Systems, Inc.  All rights reserved.
- * Copyright (c) 2012, 2017 by Delphix. All rights reserved.
+ * Copyright (c) 2012, 2018 by Delphix. All rights reserved.
  * Copyright (c) 2013 by Saso Kiselkov. All rights reserved.
  * Copyright (c) 2013, Joyent, Inc. All rights reserved.
  * Copyright 2016 Toomas Soome <tsoome@me.com>
@@ -459,6 +459,7 @@ struct zio {
 	void		*io_waiter;
 	kmutex_t	io_lock;
 	kcondvar_t	io_cv;
+	int		io_allocator;
 
 	/* FMA state */
 	zio_cksum_report_t *io_cksum_report;
@@ -517,8 +518,8 @@ extern zio_t *zio_write_phys(zio_t *pio, vdev_t *vd, uint64_t offset,
 extern zio_t *zio_free_sync(zio_t *pio, spa_t *spa, uint64_t txg,
     const blkptr_t *bp, enum zio_flag flags);
 
-extern int zio_alloc_zil(spa_t *spa, uint64_t txg, blkptr_t *new_bp,
-    blkptr_t *old_bp, uint64_t size, boolean_t *slog);
+extern int zio_alloc_zil(spa_t *spa, uint64_t objset, uint64_t txg,
+    blkptr_t *new_bp, blkptr_t *old_bp, uint64_t size, boolean_t *slog);
 extern void zio_flush(zio_t *zio, vdev_t *vd);
 extern void zio_shrink(zio_t *zio, uint64_t size);
 
diff --git a/usr/src/uts/common/fs/zfs/vdev.c b/usr/src/uts/common/fs/zfs/vdev.c
index e23e4a01c1..e761ee4b39 100644
--- a/usr/src/uts/common/fs/zfs/vdev.c
+++ b/usr/src/uts/common/fs/zfs/vdev.c
@@ -644,7 +644,8 @@ vdev_alloc(spa_t *spa, vdev_t **vdp, nvlist_t *nv, vdev_t *parent, uint_t id,
 		    alloctype == VDEV_ALLOC_SPLIT ||
 		    alloctype == VDEV_ALLOC_ROOTPOOL);
 		vd->vdev_mg = metaslab_group_create(islog ?
-		    spa_log_class(spa) : spa_normal_class(spa), vd);
+		    spa_log_class(spa) : spa_normal_class(spa), vd,
+		    spa->spa_alloc_count);
 	}
 
 	if (vd->vdev_ops->vdev_op_leaf &&
@@ -1013,7 +1014,6 @@ vdev_metaslab_init(vdev_t *vd, uint64_t txg)
 
 	vd->vdev_ms = mspp;
 	vd->vdev_ms_count = newc;
-
 	for (m = oldc; m < newc; m++) {
 		uint64_t object = 0;
 
@@ -2459,7 +2459,7 @@ vdev_dtl_sync(vdev_t *vd, uint64_t txg)
 	mutex_exit(&vd->vdev_dtl_lock);
 
 	space_map_truncate(vd->vdev_dtl_sm, vdev_dtl_sm_blksz, tx);
-	space_map_write(vd->vdev_dtl_sm, rtsync, SM_ALLOC, tx);
+	space_map_write(vd->vdev_dtl_sm, rtsync, SM_ALLOC, SM_NO_VDEVID, tx);
 	range_tree_vacate(rtsync, NULL, NULL);
 
 	range_tree_destroy(rtsync);
diff --git a/usr/src/uts/common/fs/zfs/vdev_indirect.c b/usr/src/uts/common/fs/zfs/vdev_indirect.c
index 988e216871..304453aa94 100644
--- a/usr/src/uts/common/fs/zfs/vdev_indirect.c
+++ b/usr/src/uts/common/fs/zfs/vdev_indirect.c
@@ -728,7 +728,7 @@ vdev_indirect_sync_obsolete(vdev_t *vd, dmu_tx_t *tx)
 	    space_map_object(vd->vdev_obsolete_sm));
 
 	space_map_write(vd->vdev_obsolete_sm,
-	    vd->vdev_obsolete_segments, SM_ALLOC, tx);
+	    vd->vdev_obsolete_segments, SM_ALLOC, SM_NO_VDEVID, tx);
 	space_map_update(vd->vdev_obsolete_sm);
 	range_tree_vacate(vd->vdev_obsolete_segments, NULL, NULL);
 }
diff --git a/usr/src/uts/common/fs/zfs/vdev_indirect_mapping.c b/usr/src/uts/common/fs/zfs/vdev_indirect_mapping.c
index ea80fbc473..02999aae72 100644
--- a/usr/src/uts/common/fs/zfs/vdev_indirect_mapping.c
+++ b/usr/src/uts/common/fs/zfs/vdev_indirect_mapping.c
@@ -14,7 +14,7 @@
  */
 
 /*
- * Copyright (c) 2015 by Delphix. All rights reserved.
+ * Copyright (c) 2015, 2017 by Delphix. All rights reserved.
  */
 
 #include <sys/dmu_tx.h>
@@ -536,14 +536,13 @@ typedef struct load_obsolete_space_map_arg {
 } load_obsolete_space_map_arg_t;
 
 static int
-load_obsolete_sm_callback(maptype_t type, uint64_t offset, uint64_t size,
-    void *arg)
+load_obsolete_sm_callback(space_map_entry_t *sme, void *arg)
 {
 	load_obsolete_space_map_arg_t *losma = arg;
-	ASSERT3S(type, ==, SM_ALLOC);
+	ASSERT3S(sme->sme_type, ==, SM_ALLOC);
 
 	vdev_indirect_mapping_increment_obsolete_count(losma->losma_vim,
-	    offset, size, losma->losma_counts);
+	    sme->sme_offset, sme->sme_run, losma->losma_counts);
 
 	return (0);
 }
diff --git a/usr/src/uts/common/fs/zfs/vdev_queue.c b/usr/src/uts/common/fs/zfs/vdev_queue.c
index 3a6644a51f..9f962350db 100644
--- a/usr/src/uts/common/fs/zfs/vdev_queue.c
+++ b/usr/src/uts/common/fs/zfs/vdev_queue.c
@@ -25,7 +25,7 @@
  */
 
 /*
- * Copyright (c) 2012, 2017 by Delphix. All rights reserved.
+ * Copyright (c) 2012, 2018 by Delphix. All rights reserved.
  * Copyright (c) 2014 Integros [integros.com]
  */
 
@@ -189,6 +189,15 @@ int zfs_vdev_queue_depth_pct = 1000;
 int zfs_vdev_queue_depth_pct = 300;
 #endif
 
+/*
+ * When performing allocations for a given metaslab, we want to make sure that
+ * there are enough IOs to aggregate together to improve throughput. We want to
+ * ensure that there are at least 128k worth of IOs that can be aggregated, and
+ * we assume that the average allocation size is 4k, so we need the queue depth
+ * to be 32 per allocator to get good aggregation of sequential writes.
+ */
+int zfs_vdev_def_queue_depth = 32;
+
 
 int
 vdev_queue_offset_compare(const void *x1, const void *x2)
diff --git a/usr/src/uts/common/fs/zfs/vdev_removal.c b/usr/src/uts/common/fs/zfs/vdev_removal.c
index f8d149fc11..d00b5b35f7 100644
--- a/usr/src/uts/common/fs/zfs/vdev_removal.c
+++ b/usr/src/uts/common/fs/zfs/vdev_removal.c
@@ -806,8 +806,15 @@ spa_vdev_copy_segment(vdev_t *vd, uint64_t start, uint64_t size, uint64_t txg,
 
 	ASSERT3U(size, <=, SPA_MAXBLOCKSIZE);
 
+	/*
+	 * We use allocator 0 for this I/O because we don't expect device remap
+	 * to be the steady state of the system, so parallelizing is not as
+	 * critical as it is for other allocation types. We also want to ensure
+	 * that the IOs are allocated together as much as possible, to reduce
+	 * mapping sizes.
+	 */
 	int error = metaslab_alloc_dva(spa, mg->mg_class, size,
-	    &dst, 0, NULL, txg, 0, zal);
+	    &dst, 0, NULL, txg, 0, zal, 0);
 	if (error != 0)
 		return (error);
 
diff --git a/usr/src/uts/common/fs/zfs/zil.c b/usr/src/uts/common/fs/zfs/zil.c
index 4711c7150f..0e02377de5 100644
--- a/usr/src/uts/common/fs/zfs/zil.c
+++ b/usr/src/uts/common/fs/zfs/zil.c
@@ -21,7 +21,7 @@
 /*
  * Copyright (c) 2005, 2010, Oracle and/or its affiliates. All rights reserved.
  * Copyright (c) 2014, Joyent, Inc. All rights reserved.
- * Copyright (c) 2011, 2017 by Delphix. All rights reserved.
+ * Copyright (c) 2011, 2018 by Delphix. All rights reserved.
  * Copyright (c) 2014 Integros [integros.com]
  */
 
@@ -657,7 +657,8 @@ zil_create(zilog_t *zilog)
 			BP_ZERO(&blk);
 		}
 
-		error = zio_alloc_zil(zilog->zl_spa, txg, &blk, NULL,
+		error = zio_alloc_zil(zilog->zl_spa,
+		    zilog->zl_os->os_dsl_dataset->ds_object, txg, &blk, NULL,
 		    ZIL_MIN_BLKSZ, &slog);
 
 		if (error == 0)
@@ -1334,7 +1335,8 @@ zil_lwb_write_issue(zilog_t *zilog, lwb_t *lwb)
 	BP_ZERO(bp);
 
 	/* pass the old blkptr in order to spread log blocks across devs */
-	error = zio_alloc_zil(spa, txg, bp, &lwb->lwb_blk, zil_blksz, &slog);
+	error = zio_alloc_zil(spa, zilog->zl_os->os_dsl_dataset->ds_object,
+	    txg, bp, &lwb->lwb_blk, zil_blksz, &slog);
 	if (error == 0) {
 		ASSERT3U(bp->blk_birth, ==, txg);
 		bp->blk_cksum = lwb->lwb_blk.blk_cksum;
diff --git a/usr/src/uts/common/fs/zfs/zio.c b/usr/src/uts/common/fs/zfs/zio.c
index d43adabb5b..f2c511ef77 100644
--- a/usr/src/uts/common/fs/zfs/zio.c
+++ b/usr/src/uts/common/fs/zfs/zio.c
@@ -20,7 +20,7 @@
  */
 /*
  * Copyright (c) 2005, 2010, Oracle and/or its affiliates. All rights reserved.
- * Copyright (c) 2011, 2017 by Delphix. All rights reserved.
+ * Copyright (c) 2011, 2018 by Delphix. All rights reserved.
  * Copyright (c) 2011 Nexenta Systems, Inc. All rights reserved.
  * Copyright (c) 2013 by Saso Kiselkov. All rights reserved.
  * Copyright (c) 2014 Integros [integros.com]
@@ -44,6 +44,7 @@
 #include <sys/zfs_zone.h>
 #include <sys/metaslab_impl.h>
 #include <sys/abd.h>
+#include <sys/cityhash.h>
 
 /*
  * ==========================================================================
@@ -2235,7 +2236,8 @@ zio_write_gang_block(zio_t *pio)
 		ASSERT(!(pio->io_flags & ZIO_FLAG_NODATA));
 
 		flags |= METASLAB_ASYNC_ALLOC;
-		VERIFY(refcount_held(&mc->mc_alloc_slots, pio));
+		VERIFY(refcount_held(&mc->mc_alloc_slots[pio->io_allocator],
+		    pio));
 
 		/*
 		 * The logical zio has already placed a reservation for
@@ -2246,12 +2248,12 @@ zio_write_gang_block(zio_t *pio)
 		 * additional reservations for gang blocks.
 		 */
 		VERIFY(metaslab_class_throttle_reserve(mc, gbh_copies - copies,
-		    pio, flags));
+		    pio->io_allocator, pio, flags));
 	}
 
 	error = metaslab_alloc(spa, mc, SPA_GANGBLOCKSIZE,
 	    bp, gbh_copies, txg, pio == gio ? NULL : gio->io_bp, flags,
-	    &pio->io_alloc_list, pio);
+	    &pio->io_alloc_list, pio, pio->io_allocator);
 	if (error) {
 		if (pio->io_flags & ZIO_FLAG_IO_ALLOCATING) {
 			ASSERT(pio->io_priority == ZIO_PRIORITY_ASYNC_WRITE);
@@ -2265,7 +2267,7 @@ zio_write_gang_block(zio_t *pio)
 			 * stage.
 			 */
 			metaslab_class_throttle_unreserve(mc,
-			    gbh_copies - copies, pio);
+			    gbh_copies - copies, pio->io_allocator, pio);
 		}
 		pio->io_error = error;
 		return (ZIO_PIPELINE_CONTINUE);
@@ -2323,7 +2325,7 @@ zio_write_gang_block(zio_t *pio)
 			 * slot for them here.
 			 */
 			VERIFY(metaslab_class_throttle_reserve(mc,
-			    zp.zp_copies, cio, flags));
+			    zp.zp_copies, cio->io_allocator, cio, flags));
 		}
 		zio_nowait(cio);
 	}
@@ -2813,13 +2815,13 @@ zio_ddt_free(zio_t *zio)
  */
 
 static zio_t *
-zio_io_to_allocate(spa_t *spa)
+zio_io_to_allocate(spa_t *spa, int allocator)
 {
 	zio_t *zio;
 
-	ASSERT(MUTEX_HELD(&spa->spa_alloc_lock));
+	ASSERT(MUTEX_HELD(&spa->spa_alloc_locks[allocator]));
 
-	zio = avl_first(&spa->spa_alloc_tree);
+	zio = avl_first(&spa->spa_alloc_trees[allocator]);
 	if (zio == NULL)
 		return (NULL);
 
@@ -2829,12 +2831,13 @@ zio_io_to_allocate(spa_t *spa)
 	 * Try to place a reservation for this zio. If we're unable to
 	 * reserve then we throttle.
 	 */
+	ASSERT3U(zio->io_allocator, ==, allocator);
 	if (!metaslab_class_throttle_reserve(spa_normal_class(spa),
-	    zio->io_prop.zp_copies, zio, 0)) {
+	    zio->io_prop.zp_copies, zio->io_allocator, zio, 0)) {
 		return (NULL);
 	}
 
-	avl_remove(&spa->spa_alloc_tree, zio);
+	avl_remove(&spa->spa_alloc_trees[allocator], zio);
 	ASSERT3U(zio->io_stage, <, ZIO_STAGE_DVA_ALLOCATE);
 
 	return (zio);
@@ -2858,13 +2861,23 @@ zio_dva_throttle(zio_t *zio)
 	ASSERT3U(zio->io_queued_timestamp, >, 0);
 	ASSERT(zio->io_stage == ZIO_STAGE_DVA_THROTTLE);
 
-	mutex_enter(&spa->spa_alloc_lock);
+	zbookmark_phys_t *bm = &zio->io_bookmark;
+	/*
+	 * We want to try to use as many allocators as possible to help improve
+	 * performance, but we also want logically adjacent IOs to be physically
+	 * adjacent to improve sequential read performance. We chunk each object
+	 * into 2^20 block regions, and then hash based on the objset, object,
+	 * level, and region to accomplish both of these goals.
+	 */
+	zio->io_allocator = cityhash4(bm->zb_objset, bm->zb_object,
+	    bm->zb_level, bm->zb_blkid >> 20) % spa->spa_alloc_count;
+	mutex_enter(&spa->spa_alloc_locks[zio->io_allocator]);
 
 	ASSERT(zio->io_type == ZIO_TYPE_WRITE);
-	avl_add(&spa->spa_alloc_tree, zio);
+	avl_add(&spa->spa_alloc_trees[zio->io_allocator], zio);
 
-	nio = zio_io_to_allocate(zio->io_spa);
-	mutex_exit(&spa->spa_alloc_lock);
+	nio = zio_io_to_allocate(zio->io_spa, zio->io_allocator);
+	mutex_exit(&spa->spa_alloc_locks[zio->io_allocator]);
 
 	if (nio == zio)
 		return (ZIO_PIPELINE_CONTINUE);
@@ -2885,13 +2898,13 @@ zio_dva_throttle(zio_t *zio)
 }
 
 void
-zio_allocate_dispatch(spa_t *spa)
+zio_allocate_dispatch(spa_t *spa, int allocator)
 {
 	zio_t *zio;
 
-	mutex_enter(&spa->spa_alloc_lock);
-	zio = zio_io_to_allocate(spa);
-	mutex_exit(&spa->spa_alloc_lock);
+	mutex_enter(&spa->spa_alloc_locks[allocator]);
+	zio = zio_io_to_allocate(spa, allocator);
+	mutex_exit(&spa->spa_alloc_locks[allocator]);
 	if (zio == NULL)
 		return;
 
@@ -2932,7 +2945,7 @@ zio_dva_allocate(zio_t *zio)
 
 	error = metaslab_alloc(spa, mc, zio->io_size, bp,
 	    zio->io_prop.zp_copies, zio->io_txg, NULL, flags,
-	    &zio->io_alloc_list, zio);
+	    &zio->io_alloc_list, zio, zio->io_allocator);
 
 	if (error != 0) {
 		spa_dbgmsg(spa, "%s: metaslab allocation failure: zio %p, "
@@ -2992,8 +3005,8 @@ zio_dva_unallocate(zio_t *zio, zio_gang_node_t *gn, blkptr_t *bp)
  * Try to allocate an intent log block.  Return 0 on success, errno on failure.
  */
 int
-zio_alloc_zil(spa_t *spa, uint64_t txg, blkptr_t *new_bp, blkptr_t *old_bp,
-    uint64_t size, boolean_t *slog)
+zio_alloc_zil(spa_t *spa, uint64_t objset, uint64_t txg, blkptr_t *new_bp,
+    blkptr_t *old_bp, uint64_t size, boolean_t *slog)
 {
 	int error = 1;
 	zio_alloc_list_t io_alloc_list;
@@ -3001,14 +3014,22 @@ zio_alloc_zil(spa_t *spa, uint64_t txg, blkptr_t *new_bp, blkptr_t *old_bp,
 	ASSERT(txg > spa_syncing_txg(spa));
 
 	metaslab_trace_init(&io_alloc_list);
+	/*
+	 * When allocating a zil block, we don't have information about
+	 * the final destination of the block except the objset it's part
+	 * of, so we just hash the objset ID to pick the allocator to get
+	 * some parallelism.
+	 */
 	error = metaslab_alloc(spa, spa_log_class(spa), size, new_bp, 1,
-	    txg, old_bp, METASLAB_HINTBP_AVOID, &io_alloc_list, NULL);
+	    txg, old_bp, METASLAB_HINTBP_AVOID, &io_alloc_list, NULL,
+	    cityhash4(0, 0, 0, objset) % spa->spa_alloc_count);
 	if (error == 0) {
 		*slog = TRUE;
 	} else {
 		error = metaslab_alloc(spa, spa_normal_class(spa), size,
 		    new_bp, 1, txg, old_bp, METASLAB_HINTBP_AVOID,
-		    &io_alloc_list, NULL);
+		    &io_alloc_list, NULL, cityhash4(0, 0, 0, objset) %
+		    spa->spa_alloc_count);
 		if (error == 0)
 			*slog = FALSE;
 	}
@@ -3498,8 +3519,8 @@ zio_ready(zio_t *zio)
 			 */
 			metaslab_class_throttle_unreserve(
 			    spa_normal_class(zio->io_spa),
-			    zio->io_prop.zp_copies, zio);
-			zio_allocate_dispatch(zio->io_spa);
+			    zio->io_prop.zp_copies, zio->io_allocator, zio);
+			zio_allocate_dispatch(zio->io_spa, zio->io_allocator);
 		}
 	}
 
@@ -3582,18 +3603,19 @@ zio_dva_throttle_done(zio_t *zio)
 	ASSERT0(zio->io_flags & ZIO_FLAG_NOPWRITE);
 
 	mutex_enter(&pio->io_lock);
-	metaslab_group_alloc_decrement(zio->io_spa, vd->vdev_id, pio, flags);
+	metaslab_group_alloc_decrement(zio->io_spa, vd->vdev_id, pio, flags,
+	    pio->io_allocator, B_TRUE);
 	mutex_exit(&pio->io_lock);
 
 	metaslab_class_throttle_unreserve(spa_normal_class(zio->io_spa),
-	    1, pio);
+	    1, pio->io_allocator, pio);
 
 	/*
 	 * Call into the pipeline to see if there is more work that
 	 * needs to be done. If there is work to be done it will be
 	 * dispatched to another taskq thread.
 	 */
-	zio_allocate_dispatch(zio->io_spa);
+	zio_allocate_dispatch(zio->io_spa, pio->io_allocator);
 }
 
 static int
@@ -3636,8 +3658,10 @@ zio_done(zio_t *zio)
 		ASSERT(zio->io_type == ZIO_TYPE_WRITE);
 		ASSERT(zio->io_priority == ZIO_PRIORITY_ASYNC_WRITE);
 		ASSERT(bp != NULL);
-		metaslab_group_alloc_verify(spa, zio->io_bp, zio);
-		VERIFY(refcount_not_held(&mc->mc_alloc_slots, zio));
+		metaslab_group_alloc_verify(spa, zio->io_bp, zio,
+		    zio->io_allocator);
+		VERIFY(refcount_not_held(&mc->mc_alloc_slots[zio->io_allocator],
+		    zio));
 	}
 
 	for (int c = 0; c < ZIO_CHILD_TYPES; c++)
diff --git a/usr/src/uts/common/inet/ip/ip.c b/usr/src/uts/common/inet/ip/ip.c
index abc3ee0e60..aef71717b3 100644
--- a/usr/src/uts/common/inet/ip/ip.c
+++ b/usr/src/uts/common/inet/ip/ip.c
@@ -1655,7 +1655,7 @@ icmp_inbound_v4(mblk_t *mp, ip_recv_attr_t *ira)
 			/* Update DCE and adjust MTU is icmp header if needed */
 			icmp_inbound_too_big_v4(icmph, ira);
 		}
-		/* FALLTHRU */
+		/* FALLTHROUGH */
 	default:
 		icmp_inbound_error_fanout_v4(mp, icmph, ira);
 		break;
@@ -2283,8 +2283,8 @@ icmp_inbound_error_fanout_v4(mblk_t *mp, icmph_t *icmph, ip_recv_attr_t *ira)
 			return;
 		}
 		/* No self-encapsulated */
-		/* FALLTHRU */
 	}
+	/* FALLTHROUGH */
 	case IPPROTO_IPV6:
 		if ((connp = ipcl_iptun_classify_v4(&ripha.ipha_src,
 		    &ripha.ipha_dst, ipst)) != NULL) {
@@ -2298,7 +2298,7 @@ icmp_inbound_error_fanout_v4(mblk_t *mp, icmph_t *icmph, ip_recv_attr_t *ira)
 		 * No IP tunnel is interested, fallthrough and see
 		 * if a raw socket will want it.
 		 */
-		/* FALLTHRU */
+		/* FALLTHROUGH */
 	default:
 		ira->ira_flags |= IRAF_ICMP_ERROR;
 		ip_fanout_proto_v4(mp, &ripha, ira);
@@ -6326,7 +6326,7 @@ ip_opt_set_multicast_group(conn_t *connp, t_scalar_t name,
 	case IP_ADD_MEMBERSHIP:
 	case IPV6_JOIN_GROUP:
 		mcast_opt = B_FALSE;
-		/* FALLTHRU */
+		/* FALLTHROUGH */
 	case MCAST_JOIN_GROUP:
 		fmode = MODE_IS_EXCLUDE;
 		optfn = ip_opt_add_group;
@@ -6335,7 +6335,7 @@ ip_opt_set_multicast_group(conn_t *connp, t_scalar_t name,
 	case IP_DROP_MEMBERSHIP:
 	case IPV6_LEAVE_GROUP:
 		mcast_opt = B_FALSE;
-		/* FALLTHRU */
+		/* FALLTHROUGH */
 	case MCAST_LEAVE_GROUP:
 		fmode = MODE_IS_INCLUDE;
 		optfn = ip_opt_delete_group;
@@ -6440,7 +6440,7 @@ ip_opt_set_multicast_sources(conn_t *connp, t_scalar_t name,
 	switch (name) {
 	case IP_BLOCK_SOURCE:
 		mcast_opt = B_FALSE;
-		/* FALLTHRU */
+		/* FALLTHROUGH */
 	case MCAST_BLOCK_SOURCE:
 		fmode = MODE_IS_EXCLUDE;
 		optfn = ip_opt_add_group;
@@ -6448,7 +6448,7 @@ ip_opt_set_multicast_sources(conn_t *connp, t_scalar_t name,
 
 	case IP_UNBLOCK_SOURCE:
 		mcast_opt = B_FALSE;
-		/* FALLTHRU */
+		/* FALLTHROUGH */
 	case MCAST_UNBLOCK_SOURCE:
 		fmode = MODE_IS_EXCLUDE;
 		optfn = ip_opt_delete_group;
@@ -6456,7 +6456,7 @@ ip_opt_set_multicast_sources(conn_t *connp, t_scalar_t name,
 
 	case IP_ADD_SOURCE_MEMBERSHIP:
 		mcast_opt = B_FALSE;
-		/* FALLTHRU */
+		/* FALLTHROUGH */
 	case MCAST_JOIN_SOURCE_GROUP:
 		fmode = MODE_IS_INCLUDE;
 		optfn = ip_opt_add_group;
@@ -6464,7 +6464,7 @@ ip_opt_set_multicast_sources(conn_t *connp, t_scalar_t name,
 
 	case IP_DROP_SOURCE_MEMBERSHIP:
 		mcast_opt = B_FALSE;
-		/* FALLTHRU */
+		/* FALLTHROUGH */
 	case MCAST_LEAVE_SOURCE_GROUP:
 		fmode = MODE_IS_INCLUDE;
 		optfn = ip_opt_delete_group;
@@ -7963,7 +7963,7 @@ ip_rput_notdata(ill_t *ill, mblk_t *mp)
 			putnext(ill->ill_rq, mp);
 			return;
 		}
-		/* FALLTHRU */
+		/* FALLTHROUGH */
 	case M_ERROR:
 	case M_HANGUP:
 		mutex_enter(&ill->ill_lock);
@@ -7990,7 +7990,7 @@ ip_rput_notdata(ill_t *ill, mblk_t *mp)
 		default:
 			break;
 		}
-		/* FALLTHRU */
+		/* FALLTHROUGH */
 	default:
 		putnext(ill->ill_rq, mp);
 		return;
@@ -9095,7 +9095,7 @@ ip_forward_options(mblk_t *mp, ipha_t *ipha, ill_t *dst_ill,
 					/* Not for us */
 					break;
 				}
-				/* FALLTHRU */
+				/* FALLTHROUGH */
 			case IPOPT_TS_TSANDADDR:
 				off = IP_ADDR_LEN + IPOPT_TS_TIMELEN;
 				break;
@@ -9131,7 +9131,7 @@ ip_forward_options(mblk_t *mp, ipha_t *ipha, ill_t *dst_ill,
 				}
 				bcopy(&ifaddr, (char *)opt + off, IP_ADDR_LEN);
 				opt[IPOPT_OFFSET] += IP_ADDR_LEN;
-				/* FALLTHRU */
+				/* FALLTHROUGH */
 			case IPOPT_TS_TSONLY:
 				off = opt[IPOPT_OFFSET] - 1;
 				/* Compute # of milliseconds since midnight */
@@ -9322,7 +9322,7 @@ ip_input_local_options(mblk_t *mp, ipha_t *ipha, ip_recv_attr_t *ira)
 					/* Not for us */
 					break;
 				}
-				/* FALLTHRU */
+				/* FALLTHROUGH */
 			case IPOPT_TS_TSANDADDR:
 				off = IP_ADDR_LEN + IPOPT_TS_TIMELEN;
 				break;
@@ -9357,7 +9357,7 @@ ip_input_local_options(mblk_t *mp, ipha_t *ipha, ip_recv_attr_t *ira)
 				}
 				bcopy(&ifaddr, (char *)opt + off, IP_ADDR_LEN);
 				opt[IPOPT_OFFSET] += IP_ADDR_LEN;
-				/* FALLTHRU */
+				/* FALLTHROUGH */
 			case IPOPT_TS_TSONLY:
 				off = opt[IPOPT_OFFSET] - 1;
 				/* Compute # of milliseconds since midnight */
@@ -12010,7 +12010,7 @@ ip_output_local_options(ipha_t *ipha, ip_stack_t *ipst)
 					/* Not for us */
 					break;
 				}
-				/* FALLTHRU */
+				/* FALLTHROUGH */
 			case IPOPT_TS_TSANDADDR:
 				off = IP_ADDR_LEN + IPOPT_TS_TIMELEN;
 				break;
@@ -12039,7 +12039,7 @@ ip_output_local_options(ipha_t *ipha, ip_stack_t *ipst)
 				dst = htonl(INADDR_LOOPBACK);
 				bcopy(&dst, (char *)opt + off, IP_ADDR_LEN);
 				opt[IPOPT_OFFSET] += IP_ADDR_LEN;
-				/* FALLTHRU */
+				/* FALLTHROUGH */
 			case IPOPT_TS_TSONLY:
 				off = opt[IPOPT_OFFSET] - 1;
 				/* Compute # of milliseconds since midnight */
diff --git a/usr/src/uts/common/inet/ip/ip6.c b/usr/src/uts/common/inet/ip/ip6.c
index 3796690972..7f30aaa81d 100644
--- a/usr/src/uts/common/inet/ip/ip6.c
+++ b/usr/src/uts/common/inet/ip/ip6.c
@@ -414,7 +414,7 @@ icmp_inbound_v6(mblk_t *mp, ip_recv_attr_t *ira)
 	case ICMP6_PACKET_TOO_BIG:
 		/* Update DCE and adjust MTU is icmp header if needed */
 		icmp_inbound_too_big_v6(icmp6, ira);
-		/* FALLTHRU */
+		/* FALLTHROUGH */
 	default:
 		icmp_inbound_error_fanout_v6(mp, icmp6, ira);
 		break;
@@ -962,8 +962,8 @@ icmp_inbound_error_fanout_v6(mblk_t *mp, icmp6_t *icmp6, ip_recv_attr_t *ira)
 			icmp_inbound_error_fanout_v6(mp, icmp6, ira);
 			return;
 		}
-		/* FALLTHRU */
 	}
+	/* FALLTHROUGH */
 	case IPPROTO_ENCAP:
 		if ((connp = ipcl_iptun_classify_v6(&rip6h.ip6_src,
 		    &rip6h.ip6_dst, ipst)) != NULL) {
@@ -977,7 +977,7 @@ icmp_inbound_error_fanout_v6(mblk_t *mp, icmp6_t *icmp6, ip_recv_attr_t *ira)
 		 * No IP tunnel is interested, fallthrough and see
 		 * if a raw socket will want it.
 		 */
-		/* FALLTHRU */
+		/* FALLTHROUGH */
 	default:
 		ira->ira_flags |= IRAF_ICMP_ERROR;
 		ASSERT(ira->ira_protocol == nexthdr);
@@ -4072,7 +4072,7 @@ ip_source_routed_v6(ip6_t *ip6h, mblk_t *mp, ip_stack_t *ipst)
 				ip1dbg(("ip_source_routed_v6: Not local\n"));
 			}
 		}
-	/* FALLTHRU */
+	/* FALLTHROUGH */
 	default:
 		ip2dbg(("ip_source_routed_v6: Not source routed here\n"));
 		return (B_FALSE);
diff --git a/usr/src/uts/common/inet/ip/ip6_output.c b/usr/src/uts/common/inet/ip/ip6_output.c
index b023a2fe6a..dc074454e3 100644
--- a/usr/src/uts/common/inet/ip/ip6_output.c
+++ b/usr/src/uts/common/inet/ip/ip6_output.c
@@ -23,6 +23,7 @@
  * Copyright 2010 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
  * Copyright 2017 OmniTI Computer Consulting, Inc. All rights reserved.
+ * Copyright 2018 Joyent, Inc.
  */
 /* Copyright (c) 1990 Mentat Inc. */
 
@@ -866,8 +867,16 @@ ip_output_cksum_v6(iaflags_t ixaflags, mblk_t *mp, ip6_t *ip6h,
 		    ixa->ixa_raw_cksum_offset);
 		cksum = htons(protocol);
 	} else if (protocol == IPPROTO_ICMPV6) {
-		cksump = IPH_ICMPV6_CHECKSUMP(ip6h, ip_hdr_length);
-		cksum = IP_ICMPV6_CSUM_COMP;	/* Pseudo-header cksum */
+		/*
+		 * Currently we assume no HW support for ICMP checksum calc.
+		 *
+		 * When HW support is advertised for ICMP, we'll want the
+		 * following to be set:
+		 * cksump = IPH_ICMPV6_CHECKSUMP(ip6h, ip_hdr_length);
+		 * cksum = IP_ICMPV6_CSUM_COMP;		Pseudo-header cksum
+		 */
+
+		return (ip_output_sw_cksum_v6(mp, ip6h, ixa));
 	} else {
 	ip_hdr_cksum:
 		/* No IP header checksum for IPv6 */
diff --git a/usr/src/uts/common/inet/ip/ip_output.c b/usr/src/uts/common/inet/ip/ip_output.c
index 5caa043a35..169859707e 100644
--- a/usr/src/uts/common/inet/ip/ip_output.c
+++ b/usr/src/uts/common/inet/ip/ip_output.c
@@ -21,6 +21,7 @@
 
 /*
  * Copyright (c) 2009, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright 2018 Joyent, Inc.
  */
 /* Copyright (c) 1990 Mentat Inc. */
 
@@ -244,8 +245,8 @@ conn_ip_output(mblk_t *mp, ip_xmit_attr_t *ixa)
 
 				break;
 			}
-			/* FALLTHROUGH */
 		}
+		/* FALLTHROUGH */
 		default:
 			ip_drop_output("ipIfStatsOutDiscards - verify nce",
 			    mp, NULL);
@@ -1737,6 +1738,13 @@ ip_output_cksum_v4(iaflags_t ixaflags, mblk_t *mp, ipha_t *ipha,
 #endif
 			sctph->sh_chksum = sctp_cksum(mp, ip_hdr_length);
 		goto ip_hdr_cksum;
+	} else if (protocol == IPPROTO_ICMP) {
+		/*
+		 * Note that we always calculate a SW checksum for ICMP. In the
+		 * future, if HW support for ICMP is advertised, we can change
+		 * this.
+		 */
+		return (ip_output_sw_cksum_v4(mp, ipha, ixa));
 	} else {
 	ip_hdr_cksum:
 		/* Calculate IPv4 header checksum */
diff --git a/usr/src/uts/common/inet/ipf/ip_log.c b/usr/src/uts/common/inet/ipf/ip_log.c
index 193d9024b4..584ee42d9a 100644
--- a/usr/src/uts/common/inet/ipf/ip_log.c
+++ b/usr/src/uts/common/inet/ipf/ip_log.c
@@ -31,8 +31,13 @@
 #  include <osreldate.h>
 # endif
 #endif
-#ifndef SOLARIS
-# define SOLARIS (defined(sun) && (defined(__svr4__) || defined(__SVR4)))
+#ifdef SOLARIS
+#undef	SOLARIS
+#endif
+#if (defined(sun) && (defined(__svr4__) || defined(__SVR4)))
+#define	SOLARIS	(1)
+#else
+#define	SOLARIS	(0)
 #endif
 #include <sys/errno.h>
 #include <sys/types.h>
diff --git a/usr/src/uts/common/inet/ipf/netinet/ip_compat.h b/usr/src/uts/common/inet/ipf/netinet/ip_compat.h
index 2522c4031e..f624ffd953 100644
--- a/usr/src/uts/common/inet/ipf/netinet/ip_compat.h
+++ b/usr/src/uts/common/inet/ipf/netinet/ip_compat.h
@@ -28,14 +28,19 @@
 #if defined(_KERNEL) || defined(KERNEL) || defined(__KERNEL__)
 # undef	KERNEL
 # undef	_KERNEL
-# undef 	__KERNEL__
+# undef		__KERNEL__
 # define	KERNEL
 # define	_KERNEL
-# define 	__KERNEL__
+# define	__KERNEL__
 #endif
 
-#ifndef	SOLARIS
-#define	SOLARIS	(defined(sun) && (defined(__svr4__) || defined(__SVR4)))
+#ifdef	SOLARIS
+#undef	SOLARIS
+#endif
+#if (defined(sun) && (defined(__svr4__) || defined(__SVR4)))
+#define	SOLARIS	(1)
+#else
+#define	SOLARIS	(0)
 #endif
 #if SOLARIS2 >= 8
 # ifndef	USE_INET6
diff --git a/usr/src/uts/common/inet/ipf/netinet/ip_fil.h b/usr/src/uts/common/inet/ipf/netinet/ip_fil.h
index 2df1a0b115..90fc701ae1 100644
--- a/usr/src/uts/common/inet/ipf/netinet/ip_fil.h
+++ b/usr/src/uts/common/inet/ipf/netinet/ip_fil.h
@@ -17,8 +17,13 @@
 #include "netinet/ip_compat.h"
 #include <sys/zone.h>
 
-#ifndef	SOLARIS
-# define SOLARIS (defined(sun) && (defined(__svr4__) || defined(__SVR4)))
+#ifdef	SOLARIS
+#undef	SOLARIS
+#endif
+#if (defined(sun) && (defined(__svr4__) || defined(__SVR4)))
+#define	SOLARIS	(1)
+#else
+#define	SOLARIS	(0)
 #endif
 
 #ifndef	__P
diff --git a/usr/src/uts/common/inet/ipf/netinet/ip_nat.h b/usr/src/uts/common/inet/ipf/netinet/ip_nat.h
index 000ee90dce..d118cdf354 100644
--- a/usr/src/uts/common/inet/ipf/netinet/ip_nat.h
+++ b/usr/src/uts/common/inet/ipf/netinet/ip_nat.h
@@ -13,8 +13,13 @@
 #ifndef	__IP_NAT_H__
 #define	__IP_NAT_H__
 
-#ifndef SOLARIS
-#define	SOLARIS	(defined(sun) && (defined(__svr4__) || defined(__SVR4)))
+#ifdef	SOLARIS
+#undef	SOLARIS
+#endif
+#if (defined(sun) && (defined(__svr4__) || defined(__SVR4)))
+#define	SOLARIS	(1)
+#else
+#define	SOLARIS	(0)
 #endif
 
 #if defined(__STDC__) || defined(__GNUC__) || defined(_AIX51)
diff --git a/usr/src/uts/common/inet/ipf/netinet/ip_proxy.h b/usr/src/uts/common/inet/ipf/netinet/ip_proxy.h
index 7c490673e0..95b7eb56d2 100644
--- a/usr/src/uts/common/inet/ipf/netinet/ip_proxy.h
+++ b/usr/src/uts/common/inet/ipf/netinet/ip_proxy.h
@@ -9,13 +9,16 @@
  * Use is subject to license terms.
  */
 
-#pragma ident	"%Z%%M%	%I%	%E% SMI"
-
 #ifndef	__IP_PROXY_H__
 #define	__IP_PROXY_H__
 
-#ifndef SOLARIS
-#define SOLARIS (defined(sun) && (defined(__svr4__) || defined(__SVR4)))
+#ifdef	SOLARIS
+#undef	SOLARIS
+#endif
+#if (defined(sun) && (defined(__svr4__) || defined(__SVR4)))
+#define	SOLARIS	(1)
+#else
+#define	SOLARIS	(0)
 #endif
 
 #if defined(__STDC__) || defined(__GNUC__) || defined(_AIX51)
diff --git a/usr/src/uts/common/inet/ipf/opts.h b/usr/src/uts/common/inet/ipf/opts.h
index a3cec03aba..3579f9f8d0 100644
--- a/usr/src/uts/common/inet/ipf/opts.h
+++ b/usr/src/uts/common/inet/ipf/opts.h
@@ -12,8 +12,13 @@
 #ifndef	__OPTS_H__
 #define	__OPTS_H__
 
-#ifndef	SOLARIS
-#define	SOLARIS	(defined(sun) && (defined(__svr4__) || defined(__SVR4)))
+#ifdef	SOLARIS
+#undef	SOLARIS
+#endif
+#if (defined(sun) && (defined(__svr4__) || defined(__SVR4)))
+#define	SOLARIS	(1)
+#else
+#define	SOLARIS	(0)
 #endif
 #define	OPT_REMOVE	0x000001
 #define	OPT_DEBUG	0x000002
diff --git a/usr/src/uts/common/inet/sctp/sctp_conn.c b/usr/src/uts/common/inet/sctp/sctp_conn.c
index 3845f24c32..1306ed14db 100644
--- a/usr/src/uts/common/inet/sctp/sctp_conn.c
+++ b/usr/src/uts/common/inet/sctp/sctp_conn.c
@@ -493,8 +493,8 @@ sctp_connect(sctp_t *sctp, const struct sockaddr *dst, uint32_t addrlen,
 			return (err);
 		}
 		RUN_SCTP(sctp);
-		/* FALLTHRU */
 	}
+	/* FALLTHROUGH */
 
 	case SCTPS_BOUND:
 		ASSERT(sctp->sctp_nsaddrs > 0);
diff --git a/usr/src/uts/common/io/audio/impl/audio_sun.c b/usr/src/uts/common/io/audio/impl/audio_sun.c
index ec6e8aa5d9..cee3f6ace4 100644
--- a/usr/src/uts/common/io/audio/impl/audio_sun.c
+++ b/usr/src/uts/common/io/audio/impl/audio_sun.c
@@ -1250,7 +1250,6 @@ devaudioctl_wput(audio_client_t *c, mblk_t *mp)
 		/*
 		 * No audio data on control nodes!
 		 */
-		freemsg(mp);
 
 	default:
 		freemsg(mp);
diff --git a/usr/src/uts/common/io/ib/ibnex/ibnex_ioctl.c b/usr/src/uts/common/io/ib/ibnex/ibnex_ioctl.c
index c6b919de67..e78c3735ad 100644
--- a/usr/src/uts/common/io/ib/ibnex/ibnex_ioctl.c
+++ b/usr/src/uts/common/io/ib/ibnex/ibnex_ioctl.c
@@ -862,7 +862,7 @@ ibnex_devctl(dev_t dev, int cmd, intptr_t arg, int mode, cred_t *credp,
 			break;
 		}
 
-		if ((apid_n = ibnex_get_apid(dcp)) == '\0') {
+		if ((apid_n = ibnex_get_apid(dcp)) == NULL) {
 			IBTF_DPRINTF_L2("ibnex",
 			    "%s: ibnex_get_apid failed", msg);
 			rv = EIO;
@@ -970,7 +970,7 @@ ibnex_devctl(dev_t dev, int cmd, intptr_t arg, int mode, cred_t *credp,
 			break;
 		}
 
-		if ((apid_n = ibnex_get_apid(dcp)) == '\0') {
+		if ((apid_n = ibnex_get_apid(dcp)) == NULL) {
 			IBTF_DPRINTF_L2("ibnex",
 			    "%s: ibnex_get_apid failed", msg);
 			rv = EIO;
diff --git a/usr/src/uts/common/io/mii/mii.c b/usr/src/uts/common/io/mii/mii.c
index bfff2a52e8..b024899783 100644
--- a/usr/src/uts/common/io/mii/mii.c
+++ b/usr/src/uts/common/io/mii/mii.c
@@ -61,7 +61,7 @@ enum {
 	MII_ELOOP,
 };
 
-static const char *mii_errors[] = {
+static const char * const mii_errors[] = {
 	"",
 	"Failure resetting PHY.",
 	"Failure starting PHY.",
@@ -71,7 +71,7 @@ static const char *mii_errors[] = {
 };
 
 /* Indexed by XCVR_ type */
-static const const char *mii_xcvr_types[] = {
+static const char * const mii_xcvr_types[] = {
 	"Undefined",
 	"Unknown",
 	"10 Mbps",
diff --git a/usr/src/uts/common/io/nxge/npi/npi_mac.c b/usr/src/uts/common/io/nxge/npi/npi_mac.c
index d196bc80a3..8d808577f9 100644
--- a/usr/src/uts/common/io/nxge/npi/npi_mac.c
+++ b/usr/src/uts/common/io/nxge/npi/npi_mac.c
@@ -23,8 +23,6 @@
  * Use is subject to license terms.
  */
 
-#pragma ident	"%Z%%M%	%I%	%E% SMI"
-
 #include <npi_mac.h>
 
 #define	MIF_DELAY	500
@@ -1292,6 +1290,7 @@ npi_mac_port_attr(npi_handle_t handle, io_op_t op, uint8_t portn,
 			    " npi_mac_port_attr" "MAC_PORT_IPG:"
 			    "  Invalid Input: portn <%d>",
 			    portn));
+			/* FALLTHROUGH */
 		default:
 			return (NPI_FAILURE | NPI_MAC_PORT_INVALID(portn));
 		}
@@ -1390,6 +1389,7 @@ npi_mac_port_attr(npi_handle_t handle, io_op_t op, uint8_t portn,
 			    " MAC_PORT_IPG:"
 			    " Invalid Input: portn <%d>",
 			    portn));
+			/* FALLTHROUGH */
 		default:
 			return (NPI_FAILURE | NPI_MAC_PORT_INVALID(portn));
 		}
diff --git a/usr/src/uts/common/io/nxge/npi/npi_vir.c b/usr/src/uts/common/io/nxge/npi/npi_vir.c
index 017f64d108..6c20963309 100644
--- a/usr/src/uts/common/io/nxge/npi/npi_vir.c
+++ b/usr/src/uts/common/io/nxge/npi/npi_vir.c
@@ -23,8 +23,6 @@
  * Use is subject to license terms.
  */
 
-#pragma ident	"%Z%%M%	%I%	%E% SMI"
-
 #include <npi_vir.h>
 
 /* One register only */
@@ -1052,6 +1050,7 @@ npi_ldsv_ld_get(npi_handle_t handle, uint8_t ldg, uint8_t ld,
 
 	case VECTOR2:
 		offset = LDSV2_REG + LDSV_OFFSET(ldg);
+		break;
 
 	default:
 		NPI_ERROR_MSG((handle.function, NPI_ERR_CTL, "npi_ldsv_get"
diff --git a/usr/src/uts/common/io/nxge/nxge_zcp.c b/usr/src/uts/common/io/nxge/nxge_zcp.c
index 7fd9a3ad3c..a56efd7ea8 100644
--- a/usr/src/uts/common/io/nxge/nxge_zcp.c
+++ b/usr/src/uts/common/io/nxge/nxge_zcp.c
@@ -23,8 +23,6 @@
  * Use is subject to license terms.
  */
 
-#pragma ident	"%Z%%M%	%I%	%E% SMI"
-
 #include <nxge_impl.h>
 #include <nxge_zcp.h>
 #include <nxge_ipp.h>
@@ -358,6 +356,7 @@ nxge_zcp_inject_err(p_nxge_t nxgep, uint32_t err_id)
 				break;
 			}
 		}
+		/* FALLTHROUGH */
 
 	default:
 		if (err_id == NXGE_FM_EREPORT_ZCP_RRFIFO_OVERRUN)
diff --git a/usr/src/uts/common/io/qede/qede_gld.c b/usr/src/uts/common/io/qede/qede_gld.c
index 50a4013555..4098409c17 100644
--- a/usr/src/uts/common/io/qede/qede_gld.c
+++ b/usr/src/uts/common/io/qede/qede_gld.c
@@ -33,6 +33,9 @@
 * limitations under the License.
 */
 
+/*
+ * Copyright 2018 Joyent, Inc.
+ */
 
 #include "qede.h"
 
@@ -2009,12 +2012,10 @@ qede_mac_get_capability(void *arg,
 		}
 
 		/*
-		 * Hardware does not support ICMPv6 checksumming. Right now the
-		 * GLDv3 doesn't provide us a way to specify that we don't
-		 * support that. As such, we cannot indicate
-		 * HCKSUM_INET_FULL_V6.
+		 * Hardware does not support ICMPv6 checksumming, but
+		 * HCKSUM_INET_FULL_V4/6 only applies for UDP and TCP.
 		 */
-		*tx_flags = HCKSUM_INET_FULL_V4 |
+		*tx_flags = HCKSUM_INET_FULL_V4 | HCKSUM_INET_FULL_V6 |
 		    HCKSUM_IPHDRCKSUM;
 		ret = B_TRUE;
 		break;
diff --git a/usr/src/uts/common/io/scsi/adapters/mpt_sas/mptsas_impl.c b/usr/src/uts/common/io/scsi/adapters/mpt_sas/mptsas_impl.c
index 370c39ccc1..34014a5768 100644
--- a/usr/src/uts/common/io/scsi/adapters/mpt_sas/mptsas_impl.c
+++ b/usr/src/uts/common/io/scsi/adapters/mpt_sas/mptsas_impl.c
@@ -2143,7 +2143,7 @@ mptsas_get_sas_io_unit_page_hndshk(mptsas_t *mpt)
 				    "manufacturing information (%u). Driver "
 				    "will not attach. Please contact the "
 				    "firmware vendor about this.", num_phys,
-				    mpt->m_num_phys, mpt->m_num_phys);
+				    mpt->m_num_phys);
 				rval = DDI_FAILURE;
 				goto cleanup;
 			}
@@ -2243,7 +2243,7 @@ mptsas_get_sas_io_unit_page_hndshk(mptsas_t *mpt)
 				    "manufacturing information (%u). Driver "
 				    "will not attach. Please contact the "
 				    "firmware vendor about this.", num_phys,
-				    mpt->m_num_phys, mpt->m_num_phys);
+				    mpt->m_num_phys);
 				rval = DDI_FAILURE;
 				goto cleanup;
 			}
diff --git a/usr/src/uts/common/os/modsysfile.c b/usr/src/uts/common/os/modsysfile.c
index 8dca86880f..8ac8cb4534 100644
--- a/usr/src/uts/common/os/modsysfile.c
+++ b/usr/src/uts/common/os/modsysfile.c
@@ -23,6 +23,7 @@
  * Copyright 2008 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
  * Copyright 2016 Nexenta Systems, Inc.
+ * Copyright 2018 Joyent, Inc.
  */
 
 #include <sys/types.h>
@@ -2136,25 +2137,22 @@ hwc_parse_now(char *fname, struct par_list **pl, ddi_prop_t **props)
 	return (0);	/* always return success */
 }
 
-void
-make_aliases(struct bind **bhash)
+static void
+parse_aliases(struct bind **bhash, struct _buf *file)
 {
 	enum {
 		AL_NEW, AL_DRVNAME, AL_DRVNAME_COMMA, AL_ALIAS, AL_ALIAS_COMMA
 	} state;
 
-	struct _buf *file;
 	char tokbuf[MAXPATHLEN];
 	char drvbuf[MAXPATHLEN];
 	token_t token;
 	major_t major;
 	int done = 0;
+	// FIXME:
 	static char dupwarn[] = "!Driver alias \"%s\" conflicts with "
 	    "an existing driver name or alias.";
 
-	if ((file = kobj_open_file(dafile)) == (struct _buf *)-1)
-		return;
-
 	state = AL_NEW;
 	major = DDI_MAJOR_T_NONE;
 	while (!done) {
@@ -2239,8 +2237,23 @@ make_aliases(struct bind **bhash)
 			kobj_file_err(CE_WARN, file, tok_err, tokbuf);
 		}
 	}
+}
 
-	kobj_close_file(file);
+void
+make_aliases(struct bind **bhash)
+{
+	char pptfile[] = "/etc/ppt_aliases";
+	struct _buf *file;
+
+	if ((file = kobj_open_file(pptfile)) != (struct _buf *)-1) {
+		parse_aliases(bhash, file);
+		kobj_close_file(file);
+	}
+
+	if ((file = kobj_open_file(dafile)) != (struct _buf *)-1) {
+		parse_aliases(bhash, file);
+		kobj_close_file(file);
+	}
 }
 
 
diff --git a/usr/src/uts/common/smb/Makefile b/usr/src/uts/common/smb/Makefile
index 2efb11c19c..74ac618565 100644
--- a/usr/src/uts/common/smb/Makefile
+++ b/usr/src/uts/common/smb/Makefile
@@ -21,6 +21,7 @@
 
 #
 # Copyright (c) 2010, Oracle and/or its affiliates. All rights reserved.
+# Copyright 2013 Nexenta Systems, Inc.  All rights reserved.
 #
 
 include ../../../Makefile.master
@@ -29,7 +30,8 @@ HDRS=	\
 	doserror.h		\
 	lmerr.h			\
 	nterror.h		\
-	ntstatus.h
+	ntstatus.h		\
+	wintypes.h
 
 
 ROOTDIR= $(ROOT)/usr/include/smb
diff --git a/usr/src/uts/common/smbsrv/wintypes.h b/usr/src/uts/common/smb/wintypes.h
similarity index 75%
rename from usr/src/uts/common/smbsrv/wintypes.h
rename to usr/src/uts/common/smb/wintypes.h
index 1dc3e1515a..61e48016b4 100644
--- a/usr/src/uts/common/smbsrv/wintypes.h
+++ b/usr/src/uts/common/smb/wintypes.h
@@ -18,13 +18,16 @@
  *
  * CDDL HEADER END
  */
+
 /*
  * Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
+ *
+ * Copyright 2013 Nexenta Systems, Inc.  All rights reserved.
  */
 
-#ifndef _SMBSRV_WINTYPES_H
-#define	_SMBSRV_WINTYPES_H
+#ifndef _SMB_WINTYPES_H
+#define	_SMB_WINTYPES_H
 
 #include <sys/types.h>
 
@@ -42,36 +45,26 @@ extern "C" {
 typedef	uint8_t BYTE;
 typedef	uint16_t WORD;
 typedef	uint32_t DWORD;
-typedef	uint32_t ntstatus_t;
+typedef	DWORD ntstatus_t;
+
+/* pointers to those types */
+typedef	BYTE *LPBYTE;
+typedef	WORD *LPWORD;
+typedef	DWORD *LPDWORD;
+
+/* Note: Internally, this is always a UTF-8 string. */
 typedef	uint8_t *LPTSTR;
-typedef	uint8_t *LPBYTE;
-typedef	uint16_t *LPWORD;
-typedef	uint32_t *LPDWORD;
 
 #endif /* UNSIGNED_TYPES_DEFINED */
 
-
 #ifndef ANY_SIZE_ARRAY
 #define	ANY_SIZE_ARRAY  1
 #endif /* ANY_SIZE_ARRAY */
 
-/*
- * Opaque context handle.
- */
-#ifndef CONTEXT_HANDLE
-#define	CONTEXT_HANDLE(NAME)	\
-	struct NAME {		\
-		DWORD data1;    \
-		DWORD data2;    \
-		WORD  data3[2]; \
-		BYTE  data4[8];	\
-	};			\
-	typedef struct NAME
-#endif /* CONTEXT_HANDLE */
-
+/* CONTEXT_HANDLE now in ndrtypes.ndl */
 
 #ifdef __cplusplus
 }
 #endif
 
-#endif /* _SMBSRV_WINTYPES_H */
+#endif /* _SMB_WINTYPES_H */
diff --git a/usr/src/uts/common/smbsrv/Makefile b/usr/src/uts/common/smbsrv/Makefile
index f48dc89acb..4664c09cfb 100644
--- a/usr/src/uts/common/smbsrv/Makefile
+++ b/usr/src/uts/common/smbsrv/Makefile
@@ -33,7 +33,6 @@ HDRS=	alloc.h			\
 	mailslot.h		\
 	mbuf.h			\
 	msgbuf.h		\
-	ndr.h			\
 	netbios.h		\
 	netrauth.h		\
 	nmpipes.h		\
@@ -63,18 +62,15 @@ HDRS=	alloc.h			\
 	string.h		\
 	svrapi.h		\
 	winioctl.h		\
-	winsvc.h		\
-	wintypes.h
+	winsvc.h
 
 NDLHDRS= dssetup.ndl		\
 	eventlog.ndl		\
 	llsrpc.ndl		\
 	lsarpc.ndl		\
 	msgsvc.ndl		\
-	ndrtypes.ndl		\
 	netdfs.ndl		\
 	netlogon.ndl		\
-	rpcpdu.ndl		\
 	samrpc.ndl		\
 	security.ndl		\
 	spoolss.ndl		\
diff --git a/usr/src/uts/common/smbsrv/ndl/dssetup.ndl b/usr/src/uts/common/smbsrv/ndl/dssetup.ndl
index b70a81bb5e..8f1d718e94 100644
--- a/usr/src/uts/common/smbsrv/ndl/dssetup.ndl
+++ b/usr/src/uts/common/smbsrv/ndl/dssetup.ndl
@@ -21,6 +21,8 @@
 /*
  * Copyright 2008 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
+ *
+ * Copyright 2013 Nexenta Systems, Inc.  All rights reserved.
  */
 
 #ifndef _DSSETUP_NDL_
@@ -34,7 +36,7 @@
  * except DsRoleGetPrimaryDomainInfo have been deprecated (MS04-011).
  */
 
-#include "ndrtypes.ndl"
+#include <libmlrpc/ndrtypes.ndl>
 
 
 #define	DSSETUP_OPNUM_DsRoleGetPrimaryDomainInfo	0x00
diff --git a/usr/src/uts/common/smbsrv/ndl/eventlog.ndl b/usr/src/uts/common/smbsrv/ndl/eventlog.ndl
index df56f8837a..c0e579c4d6 100644
--- a/usr/src/uts/common/smbsrv/ndl/eventlog.ndl
+++ b/usr/src/uts/common/smbsrv/ndl/eventlog.ndl
@@ -21,6 +21,8 @@
 /*
  * Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
+ *
+ * Copyright 2013 Nexenta Systems, Inc.  All rights reserved.
  */
 
 #ifndef _MLSVC_LOGR_NDL_
@@ -34,7 +36,7 @@
  ***********************************************************************
  */
 
-#include "ndrtypes.ndl"
+#include <libmlrpc/ndrtypes.ndl>
 
 #define LOGR_OPNUM_EventLogClose		0x02
 #define LOGR_OPNUM_EventLogQueryCount		0x04
diff --git a/usr/src/uts/common/smbsrv/ndl/llsrpc.ndl b/usr/src/uts/common/smbsrv/ndl/llsrpc.ndl
index 3710b32e47..62c276873e 100644
--- a/usr/src/uts/common/smbsrv/ndl/llsrpc.ndl
+++ b/usr/src/uts/common/smbsrv/ndl/llsrpc.ndl
@@ -21,6 +21,8 @@
 /*
  * Copyright 2008 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
+ *
+ * Copyright 2013 Nexenta Systems, Inc.  All rights reserved.
  */
 
 #ifndef _MLSVC_LLSR_NDL_
@@ -41,7 +43,7 @@
  *	0x3b	closes the handle obtained via 0x3a
  */
 
-#include "ndrtypes.ndl"
+#include <libmlrpc/ndrtypes.ndl>
 
 #define LLSR_OPNUM_Open			0x00
 #define LLSR_OPNUM_Close		0x01
diff --git a/usr/src/uts/common/smbsrv/ndl/lsarpc.ndl b/usr/src/uts/common/smbsrv/ndl/lsarpc.ndl
index 2d89687a6a..e93324b419 100644
--- a/usr/src/uts/common/smbsrv/ndl/lsarpc.ndl
+++ b/usr/src/uts/common/smbsrv/ndl/lsarpc.ndl
@@ -20,6 +20,7 @@
  */
 /*
  * Copyright (c) 2007, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright 2013 Nexenta Systems, Inc.  All rights reserved.
  */
 
 #ifndef _MLSVC_LSA_NDL_
@@ -38,7 +39,7 @@
  * user principal name (UPN) form, such as john@example.com.
  */
 
-#include "ndrtypes.ndl"
+#include <libmlrpc/ndrtypes.ndl>
 
 
 #define	LSARPC_OPNUM_CloseHandle			0x00
diff --git a/usr/src/uts/common/smbsrv/ndl/msgsvc.ndl b/usr/src/uts/common/smbsrv/ndl/msgsvc.ndl
index 28ab3b6437..f804f32685 100644
--- a/usr/src/uts/common/smbsrv/ndl/msgsvc.ndl
+++ b/usr/src/uts/common/smbsrv/ndl/msgsvc.ndl
@@ -21,6 +21,8 @@
 /*
  * Copyright 2008 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
+ *
+ * Copyright 2013 Nexenta Systems, Inc.  All rights reserved.
  */
 
 #ifndef _MSGSVC_NDL_
@@ -30,7 +32,7 @@
  * Message Service
  */
 
-#include "ndrtypes.ndl"
+#include <libmlrpc/ndrtypes.ndl>
 
 #define	MSGSVCSEND_OPNUM_NetrSendMessage	0x00
 
diff --git a/usr/src/uts/common/smbsrv/ndl/netdfs.ndl b/usr/src/uts/common/smbsrv/ndl/netdfs.ndl
index afc4c88385..7e9a0a42d1 100644
--- a/usr/src/uts/common/smbsrv/ndl/netdfs.ndl
+++ b/usr/src/uts/common/smbsrv/ndl/netdfs.ndl
@@ -21,6 +21,8 @@
 /*
  * Copyright 2010 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
+ *
+ * Copyright 2013 Nexenta Systems, Inc.  All rights reserved.
  */
 
 #ifndef _NETDFS_NDL_
@@ -30,7 +32,7 @@
  * NT Distributed File Service (NETDFS) RPC interface definition.
  */
 
-#include "ndrtypes.ndl"
+#include <libmlrpc/ndrtypes.ndl>
 
 
 #define	NETDFS_ABSTRACT_UUID		"4fc742e0-4a10-11cf-8273-00aa004ae673"
diff --git a/usr/src/uts/common/smbsrv/ndl/netlogon.ndl b/usr/src/uts/common/smbsrv/ndl/netlogon.ndl
index 26df6a902a..907d52ec72 100644
--- a/usr/src/uts/common/smbsrv/ndl/netlogon.ndl
+++ b/usr/src/uts/common/smbsrv/ndl/netlogon.ndl
@@ -36,7 +36,7 @@
  ***********************************************************************
  */
 
-#include "ndrtypes.ndl"
+#include <libmlrpc/ndrtypes.ndl>
 
 
 #define NETR_OPNUM_UasLogon			0x00
diff --git a/usr/src/uts/common/smbsrv/ndl/samrpc.ndl b/usr/src/uts/common/smbsrv/ndl/samrpc.ndl
index f5ccfd75b8..ef47fff452 100644
--- a/usr/src/uts/common/smbsrv/ndl/samrpc.ndl
+++ b/usr/src/uts/common/smbsrv/ndl/samrpc.ndl
@@ -31,7 +31,7 @@
  * Security Accounts Manager RPC (SAMR) interface definition.
  */
 
-#include "ndrtypes.ndl"
+#include <libmlrpc/ndrtypes.ndl>
 
 /* Windows NT */
 #define SAMR_OPNUM_Connect			0x00	/* SamrConnect */
@@ -363,7 +363,7 @@ struct samr_logon_hours_all {
 #ifndef	NDRGEN
 #define SAMR_USER_PWLEN	256
 struct samr_user_password {
-	smb_wchar_t	Buffer[SAMR_USER_PWLEN];
+	ndr_wchar_t	Buffer[SAMR_USER_PWLEN];
 	DWORD Length;
 };
 #endif	/* NDRGEN */
diff --git a/usr/src/uts/common/smbsrv/ndl/spoolss.ndl b/usr/src/uts/common/smbsrv/ndl/spoolss.ndl
index a467b5638c..ef923797d4 100644
--- a/usr/src/uts/common/smbsrv/ndl/spoolss.ndl
+++ b/usr/src/uts/common/smbsrv/ndl/spoolss.ndl
@@ -20,12 +20,13 @@
  */
 /*
  * Copyright (c) 2007, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright 2013 Nexenta Systems, Inc.  All rights reserved.
  */
 
 #ifndef _SPOOLSS_NDL_
 #define	_SPOOLSS_NDL_
 
-#include "ndrtypes.ndl"
+#include <libmlrpc/ndrtypes.ndl>
 #include "security.ndl"
 
 #define TABLE_STRING 1
diff --git a/usr/src/uts/common/smbsrv/ndl/srvsvc.ndl b/usr/src/uts/common/smbsrv/ndl/srvsvc.ndl
index dbc42578d1..5e345a9585 100644
--- a/usr/src/uts/common/smbsrv/ndl/srvsvc.ndl
+++ b/usr/src/uts/common/smbsrv/ndl/srvsvc.ndl
@@ -21,6 +21,8 @@
 /*
  * Copyright 2010 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
+ *
+ * Copyright 2013 Nexenta Systems, Inc.  All rights reserved.
  */
 
 #ifndef _MLSVC_LANMAN_NDL_
@@ -30,7 +32,7 @@
  * LanMan RPC (WKSSVC and SRVSVC) interface definitions.
  */
 
-#include "ndrtypes.ndl"
+#include <libmlrpc/ndrtypes.ndl>
 
 /*
  * WARNING: The cpp(1) macros in this file are not understood by
diff --git a/usr/src/uts/common/smbsrv/ndl/svcctl.ndl b/usr/src/uts/common/smbsrv/ndl/svcctl.ndl
index 5a6a9d034e..2509f62b52 100644
--- a/usr/src/uts/common/smbsrv/ndl/svcctl.ndl
+++ b/usr/src/uts/common/smbsrv/ndl/svcctl.ndl
@@ -21,6 +21,8 @@
 /*
  * Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
+ *
+ * Copyright 2013 Nexenta Systems, Inc.  All rights reserved.
  */
 
 #ifndef _MLSVC_SVCCTL_NDL_
@@ -32,7 +34,7 @@
  * stop services.
  */
 
-#include "ndrtypes.ndl"
+#include <libmlrpc/ndrtypes.ndl>
 
 /* Windows NT */
 #define SVCCTL_OPNUM_Close			0x00
diff --git a/usr/src/uts/common/smbsrv/ndl/winreg.ndl b/usr/src/uts/common/smbsrv/ndl/winreg.ndl
index d09cc32ed2..5789a63e91 100644
--- a/usr/src/uts/common/smbsrv/ndl/winreg.ndl
+++ b/usr/src/uts/common/smbsrv/ndl/winreg.ndl
@@ -21,6 +21,8 @@
 /*
  * Copyright 2010 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
+ *
+ * Copyright 2013 Nexenta Systems, Inc.  All rights reserved.
  */
 
 #ifndef _MLSVC_WINREG_NDL_
@@ -43,7 +45,7 @@
  * HKEY_PERFORMANCE_NLS  (HKPN)	Runtime performance information.
  */
 
-#include "ndrtypes.ndl"
+#include <libmlrpc/ndrtypes.ndl>
 
 /* Windows NT */
 #define WINREG_OPNUM_OpenHKCR		0x00
diff --git a/usr/src/uts/common/smbsrv/netrauth.h b/usr/src/uts/common/smbsrv/netrauth.h
index bc11d81e8c..b621e2da1a 100644
--- a/usr/src/uts/common/smbsrv/netrauth.h
+++ b/usr/src/uts/common/smbsrv/netrauth.h
@@ -33,7 +33,7 @@
  */
 
 #include <sys/types.h>
-#include <smbsrv/wintypes.h>
+#include <smb/wintypes.h>
 #include <smbsrv/netbios.h>
 #include <smbsrv/smbinfo.h>
 #include <netdb.h>
diff --git a/usr/src/uts/common/smbsrv/smb_door.h b/usr/src/uts/common/smbsrv/smb_door.h
index 31d32794eb..a59040ecdf 100644
--- a/usr/src/uts/common/smbsrv/smb_door.h
+++ b/usr/src/uts/common/smbsrv/smb_door.h
@@ -27,7 +27,7 @@
 #define	_SMBSRV_SMB_DOOR_H
 
 #include <sys/door.h>
-#include <smbsrv/wintypes.h>
+#include <smb/wintypes.h>
 #include <smbsrv/smb_xdr.h>
 #include <smbsrv/smb_token.h>
 
diff --git a/usr/src/uts/common/smbsrv/smb_privilege.h b/usr/src/uts/common/smbsrv/smb_privilege.h
index 1a1ee196c1..cbca27107f 100644
--- a/usr/src/uts/common/smbsrv/smb_privilege.h
+++ b/usr/src/uts/common/smbsrv/smb_privilege.h
@@ -28,7 +28,7 @@
 #ifndef _SMB_PRIVILEGE_H
 #define	_SMB_PRIVILEGE_H
 
-#include <smbsrv/wintypes.h>
+#include <smb/wintypes.h>
 
 #ifdef __cplusplus
 extern "C" {
diff --git a/usr/src/uts/common/smbsrv/smb_share.h b/usr/src/uts/common/smbsrv/smb_share.h
index cfb7551dec..b8cfba779a 100644
--- a/usr/src/uts/common/smbsrv/smb_share.h
+++ b/usr/src/uts/common/smbsrv/smb_share.h
@@ -29,11 +29,11 @@
 #define	_SMB_SHARE_H
 
 #include <sys/param.h>
+#include <smb/lmerr.h>
+#include <smb/wintypes.h>
 #include <smbsrv/string.h>
 #include <smbsrv/smb_inet.h>
 #include <smbsrv/hash_table.h>
-#include <smbsrv/wintypes.h>
-#include <smb/lmerr.h>
 
 #if !defined(_KERNEL) && !defined(_FAKE_KERNEL)
 #include <libshare.h>
diff --git a/usr/src/uts/common/smbsrv/smb_sid.h b/usr/src/uts/common/smbsrv/smb_sid.h
index 5091f419a4..d6c749e8c1 100644
--- a/usr/src/uts/common/smbsrv/smb_sid.h
+++ b/usr/src/uts/common/smbsrv/smb_sid.h
@@ -29,7 +29,7 @@
 /*
  * Security Identifier (SID) interface definition.
  */
-#include <smbsrv/wintypes.h>
+#include <smb/wintypes.h>
 
 #ifdef __cplusplus
 extern "C" {
diff --git a/usr/src/uts/common/smbsrv/smb_xdr.h b/usr/src/uts/common/smbsrv/smb_xdr.h
index 51bf3b57e2..aaf0ff070f 100644
--- a/usr/src/uts/common/smbsrv/smb_xdr.h
+++ b/usr/src/uts/common/smbsrv/smb_xdr.h
@@ -34,14 +34,13 @@ extern "C" {
 #include <sys/param.h>
 #include <sys/avl.h>
 #include <sys/list.h>
-#include <smbsrv/wintypes.h>
+#include <smb/wintypes.h>
 #include <smbsrv/smb_sid.h>
 #include <smbsrv/smbinfo.h>
 #include <smbsrv/smb_ioctl.h>
 #include <smbsrv/smb_sid.h>
 #include <smbsrv/smb_share.h>
 #include <smbsrv/smb_dfs.h>
-#include <smbsrv/wintypes.h>
 
 #if defined(_KERNEL) || defined(_FAKE_KERNEL)
 #include <sys/sysmacros.h>
diff --git a/usr/src/uts/common/sys/dlpi.h b/usr/src/uts/common/sys/dlpi.h
index 34f1c17236..d76daffeb7 100644
--- a/usr/src/uts/common/sys/dlpi.h
+++ b/usr/src/uts/common/sys/dlpi.h
@@ -20,6 +20,7 @@
  */
 /*
  * Copyright (c) 1989, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright 2018 Joyent, Inc.
  */
 
 /*	Copyright (c) 1984, 1986, 1987, 1988, 1989 AT&T	*/
@@ -676,11 +677,11 @@ typedef struct {
 #define	HCKSUM_ENABLE		0x01	/* Set to enable hardware checksum */
 					/* capability */
 #define	HCKSUM_INET_PARTIAL	0x02	/* Partial 1's complement checksum */
-					/* ability */
+					/* ability for TCP/UDP packets. */
 #define	HCKSUM_INET_FULL_V4	0x04	/* Full 1's complement checksum */
-					/* ability for IPv4 packets. */
+					/* ability for IPv4 TCP/UDP packets. */
 #define	HCKSUM_INET_FULL_V6	0x08	/* Full 1's complement checksum */
-					/* ability for IPv6 packets. */
+					/* ability for IPv6 TCP/UDP packets. */
 #define	HCKSUM_IPHDRCKSUM	0x10	/* IPv4 Header checksum offload */
 					/* capability */
 #ifdef _KERNEL
diff --git a/usr/src/uts/common/sys/pci.h b/usr/src/uts/common/sys/pci.h
index 364fd0f37e..5ed82542c2 100644
--- a/usr/src/uts/common/sys/pci.h
+++ b/usr/src/uts/common/sys/pci.h
@@ -582,6 +582,7 @@ extern "C" {
 #define	PCI_BASE_TYPE_M		0x00000006  /* type indicator mask */
 #define	PCI_BASE_PREF_M		0x00000008  /* prefetch mask */
 #define	PCI_BASE_M_ADDR_M	0xfffffff0  /* memory address mask */
+#define	PCI_BASE_M_ADDR64_M	0xfffffffffffffff0ULL /* 64bit mem addr mask */
 #define	PCI_BASE_IO_ADDR_M	0xfffffffe  /* I/O address mask */
 
 #define	PCI_BASE_ROM_ADDR_M	0xfffff800  /* ROM address mask */
diff --git a/usr/src/uts/common/sys/pci_impl.h b/usr/src/uts/common/sys/pci_impl.h
index 429d6860bd..c998accbcb 100644
--- a/usr/src/uts/common/sys/pci_impl.h
+++ b/usr/src/uts/common/sys/pci_impl.h
@@ -107,7 +107,7 @@ struct pci_bus_resource {
 	boolean_t io_reprogram;	/* need io reprog on this bus */
 	boolean_t mem_reprogram;	/* need mem reprog on this bus */
 	boolean_t subtractive;	/* subtractive PPB */
-	uint_t mem_size;	/* existing children required MEM space size */
+	uint64_t mem_size;	/* existing children required MEM space size */
 	uint_t io_size;		/* existing children required I/O space size */
 };
 
diff --git a/usr/src/uts/common/sys/scsi/adapters/mpt_sas/mpi/THIRDPARTYLICENSE b/usr/src/uts/common/sys/scsi/adapters/mpt_sas/mpi/THIRDPARTYLICENSE
index f8cd22f7df..7741eb3a6b 100644
--- a/usr/src/uts/common/sys/scsi/adapters/mpt_sas/mpi/THIRDPARTYLICENSE
+++ b/usr/src/uts/common/sys/scsi/adapters/mpt_sas/mpi/THIRDPARTYLICENSE
@@ -1,6 +1,7 @@
-Copyright (c) 2013 LSI Corp.
+Copyright (c) 2012-2015 LSI Corp.
+Copyright (c) 2013-2016 Avago Technologies
 All rights reserved.
-
+                                                                           
 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions
 are met:
@@ -12,7 +13,7 @@ are met:
 3. Neither the name of the author nor the names of any co-contributors
    may be used to endorse or promote products derived from this software
    without specific prior written permission.
-
+                                                                           
 THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
diff --git a/usr/src/uts/common/sys/scsi/adapters/mpt_sas/mpi/THIRDPARTYLICENSE.descrip b/usr/src/uts/common/sys/scsi/adapters/mpt_sas/mpi/THIRDPARTYLICENSE.descrip
index 88aaf438dc..3d80aca794 100644
--- a/usr/src/uts/common/sys/scsi/adapters/mpt_sas/mpi/THIRDPARTYLICENSE.descrip
+++ b/usr/src/uts/common/sys/scsi/adapters/mpt_sas/mpi/THIRDPARTYLICENSE.descrip
@@ -1 +1 @@
-LSI Fusion-MPT MPI 2.0 / 2.5 Header Files
+LSI Fusion-MPT MPI 2.0 / 2.5 / 2.6 Header Files
diff --git a/usr/src/uts/common/sys/vnode.h b/usr/src/uts/common/sys/vnode.h
index 8dfd36353b..b527558895 100644
--- a/usr/src/uts/common/sys/vnode.h
+++ b/usr/src/uts/common/sys/vnode.h
@@ -21,7 +21,7 @@
 
 /*
  * Copyright (c) 1988, 2010, Oracle and/or its affiliates. All rights reserved.
- * Copyright (c) 2017, Joyent, Inc.
+ * Copyright (c) 2018, Joyent, Inc.
  * Copyright (c) 2011, 2017 by Delphix. All rights reserved.
  * Copyright 2017 RackTop Systems.
  */
@@ -1486,6 +1486,7 @@ extern struct vnode kvps[];
 typedef enum {
 	KV_KVP,		/* vnode for all segkmem pages */
 	KV_ZVP,		/* vnode for all ZFS pages */
+	KV_VVP,		/* vnode for all VMM pages */
 #if defined(__sparc)
 	KV_MPVP,	/* vnode for all page_t meta-pages */
 	KV_PROMVP,	/* vnode for all PROM pages */
diff --git a/usr/src/uts/common/syscall/auditsys.c b/usr/src/uts/common/syscall/auditsys.c
index 61116dffd2..d7cb94258f 100644
--- a/usr/src/uts/common/syscall/auditsys.c
+++ b/usr/src/uts/common/syscall/auditsys.c
@@ -79,6 +79,7 @@ auditsys(struct auditcalls *uap, rval_t *rvp)
 			result = auditdoor((int)uap->a1);
 			break;
 		}
+		/* FALLTHROUGH */
 	default:
 		if (audit_active == C2AUDIT_LOADED) {
 			result = EINVAL;
diff --git a/usr/src/uts/common/syscall/uadmin.c b/usr/src/uts/common/syscall/uadmin.c
index 7aac5b52a7..bf31c3dcd6 100644
--- a/usr/src/uts/common/syscall/uadmin.c
+++ b/usr/src/uts/common/syscall/uadmin.c
@@ -298,9 +298,8 @@ kadmin(int cmd, int fcn, void *mdep, cred_t *credp)
 		dump_messages();
 
 		invoke_cb = B_TRUE;
-
-		/* FALLTHROUGH */
 	}
+	/* FALLTHROUGH */
 
 	case A_REBOOT:
 		if ((mdep != NULL) && (*(char *)mdep == '/')) {
diff --git a/usr/src/uts/common/vm/page_lock.c b/usr/src/uts/common/vm/page_lock.c
index 7e48602189..7305c9c85a 100644
--- a/usr/src/uts/common/vm/page_lock.c
+++ b/usr/src/uts/common/vm/page_lock.c
@@ -20,6 +20,7 @@
  */
 /*
  * Copyright (c) 1991, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright 2018 Joyent, Inc.
  */
 
 
@@ -140,9 +141,8 @@ static pad_mutex_t	pszc_mutex[PSZC_MTX_TABLE_SIZE];
 	    & (VPH_TABLE_SIZE - 1))
 
 /*
- * Two slots after VPH_TABLE_SIZE are reserved in vph_mutex for kernel vnodes.
- * The lock for kvp is VPH_TABLE_SIZE + 0, and the lock for zvp is
- * VPH_TABLE_SIZE + 1.
+ * Two slots after VPH_TABLE_SIZE are reserved in vph_mutex for kernel vnodes,
+ * one for kvps[KV_ZVP], and one for other kvps[] users.
  */
 
 kmutex_t	vph_mutex[VPH_TABLE_SIZE + 2];
@@ -888,10 +888,10 @@ static int page_vnode_mutex_stress = 0;
 kmutex_t *
 page_vnode_mutex(vnode_t *vp)
 {
-	if (vp == &kvp)
+	if (vp == &kvp || vp == &kvps[KV_VVP])
 		return (&vph_mutex[VPH_TABLE_SIZE + 0]);
 
-	if (vp == &zvp)
+	if (vp == &kvps[KV_ZVP])
 		return (&vph_mutex[VPH_TABLE_SIZE + 1]);
 #ifdef DEBUG
 	if (page_vnode_mutex_stress != 0)
diff --git a/usr/src/uts/common/vm/page_retire.c b/usr/src/uts/common/vm/page_retire.c
index 76be970a45..f4e8d0737f 100644
--- a/usr/src/uts/common/vm/page_retire.c
+++ b/usr/src/uts/common/vm/page_retire.c
@@ -22,6 +22,7 @@
  * Copyright 2010 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
  * Copyright (c) 2016 by Delphix. All rights reserved.
+ * Copyright 2018 Joyent, Inc.
  */
 
 /*
@@ -851,9 +852,8 @@ page_retire_incr_pend_count(void *datap)
 {
 	PR_INCR_KSTAT(pr_pending);
 
-	if ((datap == &kvp) || (datap == &zvp)) {
+	if (datap == &kvp || datap == &kvps[KV_ZVP] || datap == &kvps[KV_VVP])
 		PR_INCR_KSTAT(pr_pending_kas);
-	}
 }
 
 void
@@ -861,9 +861,8 @@ page_retire_decr_pend_count(void *datap)
 {
 	PR_DECR_KSTAT(pr_pending);
 
-	if ((datap == &kvp) || (datap == &zvp)) {
+	if (datap == &kvp || datap == &kvps[KV_ZVP] || datap == &kvps[KV_VVP])
 		PR_DECR_KSTAT(pr_pending_kas);
-	}
 }
 
 /*
diff --git a/usr/src/uts/common/vm/seg_kmem.c b/usr/src/uts/common/vm/seg_kmem.c
index 439c859d96..0b116d6eba 100644
--- a/usr/src/uts/common/vm/seg_kmem.c
+++ b/usr/src/uts/common/vm/seg_kmem.c
@@ -20,7 +20,7 @@
  */
 /*
  * Copyright (c) 1998, 2010, Oracle and/or its affiliates. All rights reserved.
- * Copyright 2016 Joyent, Inc.
+ * Copyright 2018 Joyent, Inc.
  */
 
 #include <sys/types.h>
@@ -122,6 +122,11 @@ vmem_t *static_alloc_arena;	/* arena for allocating static memory */
 vmem_t *zio_arena = NULL;	/* arena for allocating zio memory */
 vmem_t *zio_alloc_arena = NULL;	/* arena for allocating zio memory */
 
+#if defined(__amd64)
+vmem_t *kvmm_arena;		/* arena for vmm VA */
+struct seg kvmmseg;		/* Segment for vmm memory */
+#endif
+
 /*
  * seg_kmem driver can map part of the kernel heap with large pages.
  * Currently this functionality is implemented for sparc platforms only.
@@ -440,7 +445,7 @@ segkmem_badop()
 /*ARGSUSED*/
 static faultcode_t
 segkmem_fault(struct hat *hat, struct seg *seg, caddr_t addr, size_t size,
-	enum fault_type type, enum seg_rw rw)
+    enum fault_type type, enum seg_rw rw)
 {
 	pgcnt_t npages;
 	spgcnt_t pg;
@@ -655,13 +660,19 @@ segkmem_dump(struct seg *seg)
 		    segkmem_dump_range, seg->s_as);
 		vmem_walk(heaptext_arena, VMEM_ALLOC | VMEM_REENTRANT,
 		    segkmem_dump_range, seg->s_as);
+	/*
+	 * We don't want to dump pages attached to kzioseg since they
+	 * contain file data from ZFS.  If this page's segment is
+	 * kzioseg return instead of writing it to the dump device.
+	 *
+	 * Same applies to VM memory allocations.
+	 */
 	} else if (seg == &kzioseg) {
-		/*
-		 * We don't want to dump pages attached to kzioseg since they
-		 * contain file data from ZFS.  If this page's segment is
-		 * kzioseg return instead of writing it to the dump device.
-		 */
 		return;
+#if defined(__amd64)
+	} else if (seg == &kvmmseg) {
+		return;
+#endif
 	} else {
 		segkmem_dump_range(seg->s_as, seg->s_base, seg->s_size);
 	}
@@ -677,7 +688,7 @@ segkmem_dump(struct seg *seg)
 /*ARGSUSED*/
 static int
 segkmem_pagelock(struct seg *seg, caddr_t addr, size_t len,
-	page_t ***ppp, enum lock_type type, enum seg_rw rw)
+    page_t ***ppp, enum lock_type type, enum seg_rw rw)
 {
 	page_t **pplist, *pp;
 	pgcnt_t npages;
@@ -801,22 +812,19 @@ struct seg_ops segkmem_ops = {
 	seg_inherit_notsup		/* inherit */
 };
 
-int
-segkmem_zio_create(struct seg *seg)
-{
-	ASSERT(seg->s_as == &kas && RW_WRITE_HELD(&kas.a_lock));
-	seg->s_ops = &segkmem_ops;
-	seg->s_data = &zvp;
-	kas.a_size += seg->s_size;
-	return (0);
-}
-
 int
 segkmem_create(struct seg *seg)
 {
 	ASSERT(seg->s_as == &kas && RW_WRITE_HELD(&kas.a_lock));
 	seg->s_ops = &segkmem_ops;
-	seg->s_data = &kvp;
+	if (seg == &kzioseg)
+		seg->s_data = &kvps[KV_ZVP];
+#if defined(__amd64)
+	else if (seg == &kvmmseg)
+		seg->s_data = &kvps[KV_VVP];
+#endif
+	else
+		seg->s_data = &kvps[KV_KVP];
 	kas.a_size += seg->s_size;
 	return (0);
 }
@@ -858,7 +866,7 @@ segkmem_page_create(void *addr, size_t size, int vmflag, void *arg)
  */
 void *
 segkmem_xalloc(vmem_t *vmp, void *inaddr, size_t size, int vmflag, uint_t attr,
-	page_t *(*page_create_func)(void *, size_t, int, void *), void *pcarg)
+    page_t *(*page_create_func)(void *, size_t, int, void *), void *pcarg)
 {
 	page_t *ppl;
 	caddr_t addr = inaddr;
@@ -968,10 +976,10 @@ segkmem_alloc(vmem_t *vmp, size_t size, int vmflag)
 	return (segkmem_alloc_vn(vmp, size, vmflag, &kvp));
 }
 
-void *
+static void *
 segkmem_zio_alloc(vmem_t *vmp, size_t size, int vmflag)
 {
-	return (segkmem_alloc_vn(vmp, size, vmflag, &zvp));
+	return (segkmem_alloc_vn(vmp, size, vmflag, &kvps[KV_ZVP]));
 }
 
 /*
@@ -980,8 +988,8 @@ segkmem_zio_alloc(vmem_t *vmp, size_t size, int vmflag)
  * we currently don't have a special kernel segment for non-paged
  * kernel memory that is exported by drivers to user space.
  */
-static void
-segkmem_free_vn(vmem_t *vmp, void *inaddr, size_t size, struct vnode *vp,
+void
+segkmem_xfree(vmem_t *vmp, void *inaddr, size_t size, struct vnode *vp,
     void (*func)(page_t *))
 {
 	page_t *pp;
@@ -1037,22 +1045,16 @@ segkmem_free_vn(vmem_t *vmp, void *inaddr, size_t size, struct vnode *vp,
 
 }
 
-void
-segkmem_xfree(vmem_t *vmp, void *inaddr, size_t size, void (*func)(page_t *))
-{
-	segkmem_free_vn(vmp, inaddr, size, &kvp, func);
-}
-
 void
 segkmem_free(vmem_t *vmp, void *inaddr, size_t size)
 {
-	segkmem_free_vn(vmp, inaddr, size, &kvp, NULL);
+	segkmem_xfree(vmp, inaddr, size, &kvp, NULL);
 }
 
-void
+static void
 segkmem_zio_free(vmem_t *vmp, void *inaddr, size_t size)
 {
-	segkmem_free_vn(vmp, inaddr, size, &zvp, NULL);
+	segkmem_xfree(vmp, inaddr, size, &kvps[KV_ZVP], NULL);
 }
 
 void
@@ -1534,8 +1536,21 @@ segkmem_zio_init(void *zio_mem_base, size_t zio_mem_size)
 	ASSERT(zio_alloc_arena != NULL);
 }
 
-#ifdef __sparc
+#if defined(__amd64)
+
+void
+segkmem_kvmm_init(void *base, size_t size)
+{
+	ASSERT(base != NULL);
+	ASSERT(size != 0);
+
+	kvmm_arena = vmem_create("kvmm_arena", base, size, 1024 * 1024,
+	    NULL, NULL, NULL, 0, VM_SLEEP);
+
+	ASSERT(kvmm_arena != NULL);
+}
 
+#elif defined(__sparc)
 
 static void *
 segkmem_alloc_ppa(vmem_t *vmp, size_t size, int vmflag)
diff --git a/usr/src/uts/common/vm/seg_kmem.h b/usr/src/uts/common/vm/seg_kmem.h
index 1db85826b1..9a20101670 100644
--- a/usr/src/uts/common/vm/seg_kmem.h
+++ b/usr/src/uts/common/vm/seg_kmem.h
@@ -21,7 +21,7 @@
 /*
  * Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
- * Copyright 2016 Joyent, Inc.
+ * Copyright 2018 Joyent, Inc.
  * Copyright 2017 RackTop Systems.
  */
 
@@ -65,12 +65,18 @@ extern vmem_t *static_arena;	/* arena for caches to import static memory */
 extern vmem_t *static_alloc_arena;	/* arena for allocating static memory */
 extern vmem_t *zio_arena;	/* arena for zio caches */
 extern vmem_t *zio_alloc_arena;	/* arena for zio caches */
+
+#if defined(__amd64)
+extern struct seg kvmmseg;	/* Segment for vmm mappings */
+extern vmem_t *kvmm_arena;	/* arena for vmm VA */
+extern void segkmem_kvmm_init(void *, size_t);
+#endif
+
 extern struct vnode kvps[];
 /*
- * segkmem page vnodes
+ * segkmem page vnodes (please don't add more defines here...)
  */
 #define	kvp		(kvps[KV_KVP])
-#define	zvp		(kvps[KV_ZVP])
 #if defined(__sparc)
 #define	mpvp		(kvps[KV_MPVP])
 #define	promvp		(kvps[KV_PROMVP])
@@ -83,16 +89,14 @@ extern void *segkmem_xalloc(vmem_t *, void *, size_t, int, uint_t,
 extern void *segkmem_alloc(vmem_t *, size_t, int);
 extern void *segkmem_alloc_permanent(vmem_t *, size_t, int);
 extern void segkmem_free(vmem_t *, void *, size_t);
-extern void segkmem_xfree(vmem_t *, void *, size_t, void (*)(page_t *));
+extern void segkmem_xfree(vmem_t *, void *, size_t,
+    struct vnode *, void (*)(page_t *));
 
 extern void *boot_alloc(void *, size_t, uint_t);
 extern void boot_mapin(caddr_t addr, size_t size);
 extern void kernelheap_init(void *, void *, char *, void *, void *);
 extern void segkmem_gc(void);
 
-extern void *segkmem_zio_alloc(vmem_t *, size_t, int);
-extern int segkmem_zio_create(struct seg *);
-extern void segkmem_zio_free(vmem_t *, void *, size_t);
 extern void segkmem_zio_init(void *, size_t);
 
 /*
diff --git a/usr/src/uts/i86pc/dboot/dboot_startkern.c b/usr/src/uts/i86pc/dboot/dboot_startkern.c
index 2eef2eb97a..b9c4bc9051 100644
--- a/usr/src/uts/i86pc/dboot/dboot_startkern.c
+++ b/usr/src/uts/i86pc/dboot/dboot_startkern.c
@@ -23,7 +23,7 @@
  * Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
  *
- * Copyright 2013 Joyent, Inc.  All rights reserved.
+ * Copyright 2018 Joyent, Inc.  All rights reserved.
  */
 
 
@@ -2314,11 +2314,7 @@ startup_kernel(void)
 	 * Need correct target_kernel_text value
 	 */
 #if defined(_BOOT_TARGET_amd64)
-	target_kernel_text = KERNEL_TEXT_amd64;
-#elif defined(__xpv)
-	target_kernel_text = KERNEL_TEXT_i386_xpv;
-#else
-	target_kernel_text = KERNEL_TEXT_i386;
+	target_kernel_text = KERNEL_TEXT;
 #endif
 	DBG(target_kernel_text);
 
diff --git a/usr/src/uts/i86pc/io/viona/viona.c b/usr/src/uts/i86pc/io/viona/viona.c
index 768a85f500..427a45cfad 100644
--- a/usr/src/uts/i86pc/io/viona/viona.c
+++ b/usr/src/uts/i86pc/io/viona/viona.c
@@ -56,6 +56,7 @@
 #include <sys/mac_provider.h>
 #include <sys/mac_client_priv.h>
 #include <sys/vlan.h>
+#include <inet/ip.h>
 
 #include <sys/vmm_drv.h>
 #include <sys/viona_io.h>
@@ -1934,6 +1935,28 @@ viona_desb_release(viona_desb_t *dp)
 	mutex_exit(&ring->vr_lock);
 }
 
+static int
+viona_mb_get_uint8(mblk_t *mp, off_t off, uint8_t *out)
+{
+	size_t mpsize;
+	uint8_t *bp;
+
+	mpsize = msgsize(mp);
+	if (off + sizeof (uint8_t) > mpsize)
+		return (-1);
+
+	mpsize = MBLKL(mp);
+	while (off >= mpsize) {
+		mp = mp->b_cont;
+		off -= mpsize;
+		mpsize = MBLKL(mp);
+	}
+
+	bp = mp->b_rptr + off;
+	*out = *bp;
+	return (0);
+}
+
 static boolean_t
 viona_tx_csum(viona_vring_t *ring, const struct virtio_net_hdr *hdr,
     mblk_t *mp, uint32_t len)
@@ -1942,6 +1965,7 @@ viona_tx_csum(viona_vring_t *ring, const struct virtio_net_hdr *hdr,
 	const struct ether_header *eth;
 	uint_t eth_len = sizeof (struct ether_header);
 	ushort_t ftype;
+	uint8_t ipproto = IPPROTO_NONE; /* NONE is not exactly right, but ok */
 
 	eth = (const struct ether_header *)mp->b_rptr;
 	if (MBLKL(mp) < sizeof (*eth)) {
@@ -1959,11 +1983,22 @@ viona_tx_csum(viona_vring_t *ring, const struct virtio_net_hdr *hdr,
 		ftype = ntohs(veth->ether_type);
 	}
 
+	if (ftype == ETHERTYPE_IP) {
+		const size_t off = offsetof(ipha_t, ipha_protocol) + eth_len;
+
+		(void) viona_mb_get_uint8(mp, off, &ipproto);
+	} else if (ftype == ETHERTYPE_IPV6) {
+		const size_t off = offsetof(ip6_t, ip6_nxt) + eth_len;
+
+		(void) viona_mb_get_uint8(mp, off, &ipproto);
+	}
+
 	/*
 	 * Partial checksum support from the NIC is ideal, since it most
 	 * closely maps to the interface defined by virtio.
 	 */
-	if ((link->l_cap_csum & HCKSUM_INET_PARTIAL) != 0) {
+	if ((link->l_cap_csum & HCKSUM_INET_PARTIAL) != 0 &&
+	    (ipproto == IPPROTO_TCP || ipproto == IPPROTO_UDP)) {
 		uint_t start, stuff, end;
 
 		/*
@@ -1984,7 +2019,8 @@ viona_tx_csum(viona_vring_t *ring, const struct virtio_net_hdr *hdr,
 	 * checksum will need to calculated inline.
 	 */
 	if (ftype == ETHERTYPE_IP) {
-		if ((link->l_cap_csum & HCKSUM_INET_FULL_V4) != 0) {
+		if ((link->l_cap_csum & HCKSUM_INET_FULL_V4) != 0 &&
+		    (ipproto == IPPROTO_TCP || ipproto == IPPROTO_UDP)) {
 			mac_hcksum_set(mp, 0, 0, 0, 0, HCK_FULLCKSUM);
 			return (B_TRUE);
 		}
@@ -1994,7 +2030,8 @@ viona_tx_csum(viona_vring_t *ring, const struct virtio_net_hdr *hdr,
 		VIONA_RING_STAT_INCR(ring, fail_hcksum);
 		return (B_FALSE);
 	} else if (ftype == ETHERTYPE_IPV6) {
-		if ((link->l_cap_csum & HCKSUM_INET_FULL_V6) != 0) {
+		if ((link->l_cap_csum & HCKSUM_INET_FULL_V6) != 0 &&
+		    (ipproto == IPPROTO_TCP || ipproto == IPPROTO_UDP)) {
 			mac_hcksum_set(mp, 0, 0, 0, 0, HCK_FULLCKSUM);
 			return (B_TRUE);
 		}
diff --git a/usr/src/uts/i86pc/io/vmm/amd/svm.c b/usr/src/uts/i86pc/io/vmm/amd/svm.c
index c6e3330779..8bf363faf5 100644
--- a/usr/src/uts/i86pc/io/vmm/amd/svm.c
+++ b/usr/src/uts/i86pc/io/vmm/amd/svm.c
@@ -24,6 +24,10 @@
  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+/*
+ * Copyright 2018 Joyent, Inc.
+ */
+
 #include <sys/cdefs.h>
 __FBSDID("$FreeBSD$");
 
@@ -2268,5 +2272,14 @@ struct vmm_ops vmm_ops_amd = {
 	svm_npt_alloc,
 	svm_npt_free,
 	svm_vlapic_init,
-	svm_vlapic_cleanup	
+	svm_vlapic_cleanup,
+
+#ifndef __FreeBSD__
+	/*
+	 * When SVM support is wired up and tested, it is likely to require
+	 * savectx/restorectx functions similar to VMX.
+	 */
+	NULL,
+	NULL,
+#endif
 };
diff --git a/usr/src/uts/i86pc/io/vmm/intel/vmx.c b/usr/src/uts/i86pc/io/vmm/intel/vmx.c
index 4bf335a7c5..c9a6a7a28b 100644
--- a/usr/src/uts/i86pc/io/vmm/intel/vmx.c
+++ b/usr/src/uts/i86pc/io/vmm/intel/vmx.c
@@ -2800,6 +2800,11 @@ vmx_run(void *arg, int vcpu, register_t rip, pmap_t pmap,
 
 	VMPTRLD(vmcs);
 
+#ifndef __FreeBSD__
+	VERIFY(!vmx->ctx_loaded[vcpu] && curthread->t_preempt != 0);
+	vmx->ctx_loaded[vcpu] = B_TRUE;
+#endif
+
 	/*
 	 * XXX
 	 * We do this every time because we may setup the virtual machine
@@ -2914,6 +2919,11 @@ vmx_run(void *arg, int vcpu, register_t rip, pmap_t pmap,
 	VMCLEAR(vmcs);
 	vmx_msr_guest_exit(vmx, vcpu);
 
+#ifndef __FreeBSD__
+	VERIFY(vmx->ctx_loaded[vcpu] && curthread->t_preempt != 0);
+	vmx->ctx_loaded[vcpu] = B_FALSE;
+#endif
+
 	return (0);
 }
 
@@ -3705,6 +3715,32 @@ vmx_vlapic_cleanup(void *arg, struct vlapic *vlapic)
 	free(vlapic, M_VLAPIC);
 }
 
+#ifndef __FreeBSD__
+static void
+vmx_savectx(void *arg, int vcpu)
+{
+	struct vmx *vmx = arg;
+	struct vmcs *vmcs = &vmx->vmcs[vcpu];
+
+	if (vmx->ctx_loaded[vcpu]) {
+		VERIFY3U(vmclear(vmcs), ==, 0);
+		vmx_msr_guest_exit(vmx, vcpu);
+	}
+}
+
+static void
+vmx_restorectx(void *arg, int vcpu)
+{
+	struct vmx *vmx = arg;
+	struct vmcs *vmcs = &vmx->vmcs[vcpu];
+
+	if (vmx->ctx_loaded[vcpu]) {
+		vmx_msr_guest_enter(vmx, vcpu);
+		VERIFY3U(vmptrld(vmcs), ==, 0);
+	}
+}
+#endif /* __FreeBSD__ */
+
 struct vmm_ops vmm_ops_intel = {
 	vmx_init,
 	vmx_cleanup,
@@ -3722,6 +3758,11 @@ struct vmm_ops vmm_ops_intel = {
 	ept_vmspace_free,
 	vmx_vlapic_init,
 	vmx_vlapic_cleanup,
+
+#ifndef __FreeBSD__
+	vmx_savectx,
+	vmx_restorectx,
+#endif
 };
 
 #ifndef __FreeBSD__
diff --git a/usr/src/uts/i86pc/io/vmm/intel/vmx.h b/usr/src/uts/i86pc/io/vmm/intel/vmx.h
index 04933eef80..a1576a106f 100644
--- a/usr/src/uts/i86pc/io/vmm/intel/vmx.h
+++ b/usr/src/uts/i86pc/io/vmm/intel/vmx.h
@@ -27,7 +27,7 @@
  */
 
 /*
- * Copyright 2017 Joyent, Inc.
+ * Copyright 2018 Joyent, Inc.
  */
 
 #ifndef _VMX_H_
@@ -123,6 +123,7 @@ struct vmx {
 #ifndef	__FreeBSD__
 	uint64_t	host_msrs[VM_MAXCPU][GUEST_MSR_NUM];
 	uint64_t	tsc_offset[VM_MAXCPU];
+	boolean_t	ctx_loaded[VM_MAXCPU];
 #endif
 	struct vmxctx	ctx[VM_MAXCPU];
 	struct vmxcap	cap[VM_MAXCPU];
diff --git a/usr/src/uts/i86pc/io/vmm/intel/vmx_support.s b/usr/src/uts/i86pc/io/vmm/intel/vmx_support.s
index b97df10b68..c7fc1e7a77 100644
--- a/usr/src/uts/i86pc/io/vmm/intel/vmx_support.s
+++ b/usr/src/uts/i86pc/io/vmm/intel/vmx_support.s
@@ -102,6 +102,21 @@ vmx_enter_guest(struct vmxctx *ctx, struct vmx *vmx, int launched)
 	movq	VMXCTX_GUEST_R15(%rdi),%r15;				\
 	movq	VMXCTX_GUEST_RDI(%rdi),%rdi; /* restore rdi the last */
 
+/*
+ * Flush scratch registers to avoid lingering guest state being used for
+ * Spectre v1 attacks when returning from guest entry.
+ */
+#define	VMX_GUEST_FLUSH_SCRATCH						\
+	xorl	%edi, %edi;						\
+	xorl	%esi, %esi;						\
+	xorl	%edx, %edx;						\
+	xorl	%ecx, %ecx;						\
+	xorl	%r8d, %r8d;						\
+	xorl	%r9d, %r9d;						\
+	xorl	%r10d, %r10d;						\
+	xorl	%r11d, %r11d;
+
+
 /* Stack layout (offset from %rsp) for vmx_enter_guest */
 #define	VMXSTK_TMPRDI	0x00	/* temp store %rdi on vmexit		*/
 #define	VMXSTK_R15	0x08	/* callee saved %r15			*/
@@ -223,6 +238,9 @@ inst_error:
 	movq	VMXSTK_R13(%rsp), %r13
 	movq	VMXSTK_R14(%rsp), %r14
 	movq	VMXSTK_R15(%rsp), %r15
+
+	VMX_GUEST_FLUSH_SCRATCH
+
 	addq	$VMXSTKSIZE, %rsp
 	popq	%rbp
 	ret
@@ -277,6 +295,9 @@ ALTENTRY(vmx_exit_guest)
 	movq	VMXSTK_R13(%rsp), %r13
 	movq	VMXSTK_R14(%rsp), %r14
 	movq	VMXSTK_R15(%rsp), %r15
+
+	VMX_GUEST_FLUSH_SCRATCH
+
 	addq	$VMXSTKSIZE, %rsp
 	popq	%rbp
 	ret
diff --git a/usr/src/uts/i86pc/io/vmm/io/ppt.c b/usr/src/uts/i86pc/io/vmm/io/ppt.c
index 777d4129e0..f40a5c73cc 100644
--- a/usr/src/uts/i86pc/io/vmm/io/ppt.c
+++ b/usr/src/uts/i86pc/io/vmm/io/ppt.c
@@ -385,6 +385,42 @@ ppt_bar_crawl(struct pptdev *ppt)
 	return (err);
 }
 
+static boolean_t
+ppt_bar_verify_mmio(struct pptdev *ppt, uint64_t base, uint64_t size)
+{
+	const uint64_t map_end = base + size;
+
+	/* Zero-length or overflow mappings are not valid */
+	if (map_end <= base) {
+		return (B_FALSE);
+	}
+	/* MMIO bounds should be page-aligned */
+	if ((base & PAGEOFFSET) != 0 || (size & PAGEOFFSET) != 0) {
+		return (B_FALSE);
+	}
+
+	for (uint_t i = 0; i < PCI_BASE_NUM; i++) {
+		const struct pptbar *bar = &ppt->pptd_bars[i];
+		const uint64_t bar_end = bar->base + bar->size;
+
+		/* Only memory BARs can be mapped */
+		if (bar->type != PCI_ADDR_MEM32 &&
+		    bar->type != PCI_ADDR_MEM64) {
+			continue;
+		}
+
+		/* Does the mapping fit within this BAR? */
+		if (base < bar->base || base >= bar_end ||
+		    map_end < bar->base || map_end > bar_end) {
+			continue;
+		}
+
+		/* This BAR satisfies the provided map */
+		return (B_TRUE);
+	}
+	return (B_FALSE);
+}
+
 static int
 ppt_ddi_attach(dev_info_t *dip, ddi_attach_cmd_t cmd)
 {
@@ -760,8 +796,8 @@ ppt_unmap_mmio(struct vm *vm, struct pptdev *ppt)
 		seg = &ppt->mmio[i];
 		if (seg->len == 0)
 			continue;
-		(void)vm_unmap_mmio(vm, seg->gpa, seg->len);
-		bzero(seg, sizeof(struct pptseg));
+		(void) vm_unmap_mmio(vm, seg->gpa, seg->len);
+		bzero(seg, sizeof (struct pptseg));
 	}
 }
 
@@ -1040,6 +1076,15 @@ ppt_map_mmio(struct vm *vm, int pptfd, vm_paddr_t gpa, size_t len,
 		goto done;
 	}
 
+	/*
+	 * Ensure that the host-physical range of the requested mapping fits
+	 * within one of the MMIO BARs of the device.
+	 */
+	if (!ppt_bar_verify_mmio(ppt, hpa, len)) {
+		err = EINVAL;
+		goto done;
+	}
+
 	for (uint_t i = 0; i < MAX_MMIOSEGS; i++) {
 		struct pptseg *seg = &ppt->mmio[i];
 
@@ -1222,9 +1267,9 @@ ppt_setup_msix(struct vm *vm, int vcpu, int pptfd, int idx, uint64_t addr,
 
 		ppt->msix.num_msgs = numvec;
 
-		ppt->msix.arg_sz = numvec * sizeof(ppt->msix.arg[0]);
+		ppt->msix.arg_sz = numvec * sizeof (ppt->msix.arg[0]);
 		ppt->msix.arg = kmem_zalloc(ppt->msix.arg_sz, KM_SLEEP);
-		ppt->msix.inth_sz = numvec * sizeof(ddi_intr_handle_t);
+		ppt->msix.inth_sz = numvec * sizeof (ddi_intr_handle_t);
 		ppt->msix.inth = kmem_zalloc(ppt->msix.inth_sz, KM_SLEEP);
 
 		if (ddi_intr_alloc(dip, ppt->msix.inth, DDI_INTR_TYPE_MSIX, 0,
diff --git a/usr/src/uts/i86pc/io/vmm/vm/vm_glue.h b/usr/src/uts/i86pc/io/vmm/vm/vm_glue.h
index cf1808c799..cb6d4c358e 100644
--- a/usr/src/uts/i86pc/io/vmm/vm/vm_glue.h
+++ b/usr/src/uts/i86pc/io/vmm/vm/vm_glue.h
@@ -10,7 +10,7 @@
  */
 
 /*
- * Copyright 2017 Joyent, Inc.
+ * Copyright 2018 Joyent, Inc.
  */
 
 #ifndef	_VM_GLUE_
@@ -71,10 +71,10 @@ struct vm_page {
 /* Illumos-specific functions for setup and operation */
 int vm_segmap_obj(struct vmspace *, vm_object_t, struct as *, caddr_t *,
     uint_t, uint_t, uint_t);
-int vm_segmap_space(struct vmspace *, off_t , struct as *, caddr_t *, off_t,
+int vm_segmap_space(struct vmspace *, off_t, struct as *, caddr_t *, off_t,
     uint_t, uint_t, uint_t);
 void *vmspace_find_kva(struct vmspace *, uintptr_t, size_t);
 void vmm_arena_init(void);
-boolean_t vmm_arena_fini(void);
+void vmm_arena_fini(void);
 
 #endif /* _VM_GLUE_ */
diff --git a/usr/src/uts/i86pc/io/vmm/vmm.c b/usr/src/uts/i86pc/io/vmm/vmm.c
index 6332a094d4..ffc9fdad8e 100644
--- a/usr/src/uts/i86pc/io/vmm/vmm.c
+++ b/usr/src/uts/i86pc/io/vmm/vmm.c
@@ -265,6 +265,16 @@ typedef struct vm_ioport_hook {
 	vmm_rmem_cb_t	vmih_rmem_cb;
 	vmm_wmem_cb_t	vmih_wmem_cb;
 } vm_ioport_hook_t;
+
+/* Flags for vtc_status */
+#define	VTCS_FPU_RESTORED	1 /* guest FPU restored, host FPU saved */
+#define	VTCS_FPU_CTX_CRITICAL	2 /* in ctx where FPU restore cannot be lazy */
+
+typedef struct vm_thread_ctx {
+	struct vm	*vtc_vm;
+	int		vtc_vcpuid;
+	uint_t		vtc_status;
+} vm_thread_ctx_t;
 #endif /* __FreeBSD__ */
 
 #ifdef KTR
@@ -459,7 +469,6 @@ vmm_mod_load()
 {
 	int	error;
 
-	vmmdev_init();
 	error = vmm_init();
 	if (error == 0)
 		vmm_initialized = 1;
@@ -472,7 +481,6 @@ vmm_mod_unload()
 {
 	int	error;
 
-	vmmdev_cleanup();
 	error = VMM_CLEANUP();
 	if (error)
 		return (error);
@@ -1779,6 +1787,61 @@ vm_localize_resources(struct vm *vm, struct vcpu *vcpu)
 
 	vcpu->lastloccpu = curcpu;
 }
+
+void
+vmm_savectx(void *arg)
+{
+	vm_thread_ctx_t *vtc = arg;
+	struct vm *vm = vtc->vtc_vm;
+	const int vcpuid = vtc->vtc_vcpuid;
+
+	if (ops->vmsavectx != NULL) {
+		ops->vmsavectx(vm->cookie, vcpuid);
+	}
+
+	/*
+	 * If the CPU holds the restored guest FPU state, save it and restore
+	 * the host FPU state before this thread goes off-cpu.
+	 */
+	if ((vtc->vtc_status & VTCS_FPU_RESTORED) != 0) {
+		struct vcpu *vcpu = &vm->vcpu[vcpuid];
+
+		save_guest_fpustate(vcpu);
+		vtc->vtc_status &= ~VTCS_FPU_RESTORED;
+	}
+}
+
+void
+vmm_restorectx(void *arg)
+{
+	vm_thread_ctx_t *vtc = arg;
+	struct vm *vm = vtc->vtc_vm;
+	const int vcpuid = vtc->vtc_vcpuid;
+
+	/*
+	 * When coming back on-cpu, only restore the guest FPU status if the
+	 * thread is in a context marked as requiring it.  This should be rare,
+	 * occurring only when a future logic error results in a voluntary
+	 * sleep during the VMRUN critical section.
+	 *
+	 * The common case will result in elision of the guest FPU state
+	 * restoration, deferring that action until it is clearly necessary
+	 * during vm_run.
+	 */
+	VERIFY((vtc->vtc_status & VTCS_FPU_RESTORED) == 0);
+	if ((vtc->vtc_status & VTCS_FPU_CTX_CRITICAL) != 0) {
+		struct vcpu *vcpu = &vm->vcpu[vcpuid];
+
+		restore_guest_fpustate(vcpu);
+		vtc->vtc_status |= VTCS_FPU_RESTORED;
+	}
+
+	if (ops->vmrestorectx != NULL) {
+		ops->vmrestorectx(vm->cookie, vcpuid);
+	}
+
+}
+
 #endif /* __FreeBSD */
 
 
@@ -1795,6 +1858,9 @@ vm_run(struct vm *vm, struct vm_run *vmrun)
 	struct vm_exit *vme;
 	bool retu, intr_disabled;
 	pmap_t pmap;
+#ifndef	__FreeBSD__
+	vm_thread_ctx_t vtc;
+#endif
 
 	vcpuid = vmrun->cpuid;
 
@@ -1813,6 +1879,16 @@ vm_run(struct vm *vm, struct vm_run *vmrun)
 	evinfo.rptr = &vm->rendezvous_func;
 	evinfo.sptr = &vm->suspend;
 	evinfo.iptr = &vcpu->reqidle;
+
+#ifndef	__FreeBSD__
+	vtc.vtc_vm = vm;
+	vtc.vtc_vcpuid = vcpuid;
+	vtc.vtc_status = 0;
+
+	installctx(curthread, &vtc, vmm_savectx, vmm_restorectx, NULL, NULL,
+	    NULL, NULL);
+#endif
+
 restart:
 #ifndef	__FreeBSD__
 	thread_affinity_set(curthread, CPU_CURRENT);
@@ -1842,21 +1918,27 @@ restart:
 	ttolwp(curthread)->lwp_pcb.pcb_rupdate = 1;
 #endif
 
-#ifndef	__FreeBSD__
-	installctx(curthread, vcpu, save_guest_fpustate,
-	    restore_guest_fpustate, NULL, NULL, NULL, NULL);
-#endif
+#ifdef	__FreeBSD__
 	restore_guest_fpustate(vcpu);
+#else
+	if ((vtc.vtc_status & VTCS_FPU_RESTORED) == 0) {
+		restore_guest_fpustate(vcpu);
+		vtc.vtc_status |= VTCS_FPU_RESTORED;
+	}
+	vtc.vtc_status |= VTCS_FPU_CTX_CRITICAL;
+#endif
 
 	vcpu_require_state(vm, vcpuid, VCPU_RUNNING);
 	error = VMRUN(vm->cookie, vcpuid, vcpu->nextrip, pmap, &evinfo);
 	vcpu_require_state(vm, vcpuid, VCPU_FROZEN);
 
+#ifdef	__FreeBSD__
 	save_guest_fpustate(vcpu);
-#ifndef	__FreeBSD__
-	removectx(curthread, vcpu, save_guest_fpustate,
-	    restore_guest_fpustate, NULL, NULL, NULL, NULL);
+#else
+	vtc.vtc_status &= ~VTCS_FPU_CTX_CRITICAL;
+#endif
 
+#ifndef	__FreeBSD__
 	/*
 	 * Once clear of the delicate contexts comprising the VM_RUN handler,
 	 * thread CPU affinity can be loosened while other processing occurs.
@@ -1913,6 +1995,24 @@ restart:
 	if (error == 0 && retu == false)
 		goto restart;
 
+#ifndef	__FreeBSD__
+	/*
+	 * Before returning to userspace, explicitly restore the host FPU state
+	 * (saving the guest state).  This is done with kpreempt disabled to
+	 * ensure it is not interrupted, potentially confusing the soon-to-be
+	 * removed savectx/restorectx handlers.
+	 */
+	kpreempt_disable();
+	if ((vtc.vtc_status & VTCS_FPU_RESTORED) != 0) {
+		save_guest_fpustate(vcpu);
+		vtc.vtc_status &= ~VTCS_FPU_RESTORED;
+	}
+	kpreempt_enable();
+
+	removectx(curthread, &vtc, vmm_savectx, vmm_restorectx, NULL, NULL,
+	    NULL, NULL);
+#endif
+
 	VCPU_CTR2(vm, vcpuid, "retu %d/%d", error, vme->exitcode);
 
 	/* copy the exit information */
diff --git a/usr/src/uts/i86pc/io/vmm/vmm_sol_dev.c b/usr/src/uts/i86pc/io/vmm/vmm_sol_dev.c
index b6f3e40e0a..12c343e467 100644
--- a/usr/src/uts/i86pc/io/vmm/vmm_sol_dev.c
+++ b/usr/src/uts/i86pc/io/vmm/vmm_sol_dev.c
@@ -77,18 +77,6 @@ static sdev_plugin_hdl_t vmm_sdev_hdl;
 /* From uts/i86pc/io/vmm/intel/vmx.c */
 extern int vmx_x86_supported(char **);
 
-/*
- * vmm trace ring
- */
-int	vmm_dmsg_ring_size = VMM_DMSG_RING_SIZE;
-static	vmm_trace_rbuf_t *vmm_debug_rbuf;
-static	vmm_trace_dmsg_t *vmm_trace_dmsg_alloc(void);
-static	void vmm_trace_dmsg_free(void);
-static	void vmm_trace_rbuf_alloc(void);
-#if notyet
-static	void vmm_trace_rbuf_free(void);
-#endif
-
 /* Holds and hooks from drivers external to vmm */
 struct vmm_hold {
 	list_node_t	vmh_node;
@@ -99,169 +87,6 @@ struct vmm_hold {
 
 static int vmm_drv_block_hook(vmm_softc_t *, boolean_t);
 
-/*
- * This routine is used to manage debug messages
- * on ring buffer.
- */
-static vmm_trace_dmsg_t *
-vmm_trace_dmsg_alloc(void)
-{
-	vmm_trace_dmsg_t *dmsg_alloc, *dmsg = vmm_debug_rbuf->dmsgp;
-
-	if (vmm_debug_rbuf->looped == TRUE) {
-		vmm_debug_rbuf->dmsgp = dmsg->next;
-		return (vmm_debug_rbuf->dmsgp);
-	}
-
-	/*
-	 * If we're looping for the first time,
-	 * connect the ring.
-	 */
-	if (((vmm_debug_rbuf->size + (sizeof (vmm_trace_dmsg_t))) >
-	    vmm_debug_rbuf->maxsize) && (vmm_debug_rbuf->dmsgh != NULL)) {
-		dmsg->next = vmm_debug_rbuf->dmsgh;
-		vmm_debug_rbuf->dmsgp = vmm_debug_rbuf->dmsgh;
-		vmm_debug_rbuf->looped = TRUE;
-		return (vmm_debug_rbuf->dmsgp);
-	}
-
-	/* If we've gotten this far then memory allocation is needed */
-	dmsg_alloc = kmem_zalloc(sizeof (vmm_trace_dmsg_t), KM_NOSLEEP);
-	if (dmsg_alloc == NULL) {
-		vmm_debug_rbuf->allocfailed++;
-		return (dmsg_alloc);
-	} else {
-		vmm_debug_rbuf->size += sizeof (vmm_trace_dmsg_t);
-	}
-
-	if (vmm_debug_rbuf->dmsgp != NULL) {
-		dmsg->next = dmsg_alloc;
-		vmm_debug_rbuf->dmsgp = dmsg->next;
-		return (vmm_debug_rbuf->dmsgp);
-	} else {
-		/*
-		 * We should only be here if we're initializing
-		 * the ring buffer.
-		 */
-		if (vmm_debug_rbuf->dmsgh == NULL) {
-			vmm_debug_rbuf->dmsgh = dmsg_alloc;
-		} else {
-			/* Something is wrong */
-			kmem_free(dmsg_alloc, sizeof (vmm_trace_dmsg_t));
-			return (NULL);
-		}
-
-		vmm_debug_rbuf->dmsgp = dmsg_alloc;
-		return (vmm_debug_rbuf->dmsgp);
-	}
-}
-
-/*
- * Free all messages on debug ring buffer.
- */
-static void
-vmm_trace_dmsg_free(void)
-{
-	vmm_trace_dmsg_t *dmsg_next, *dmsg = vmm_debug_rbuf->dmsgh;
-
-	while (dmsg != NULL) {
-		dmsg_next = dmsg->next;
-		kmem_free(dmsg, sizeof (vmm_trace_dmsg_t));
-
-		/*
-		 * If we've looped around the ring than we're done.
-		 */
-		if (dmsg_next == vmm_debug_rbuf->dmsgh) {
-			break;
-		} else {
-			dmsg = dmsg_next;
-		}
-	}
-}
-
-static void
-vmm_trace_rbuf_alloc(void)
-{
-	vmm_debug_rbuf = kmem_zalloc(sizeof (vmm_trace_rbuf_t), KM_SLEEP);
-
-	mutex_init(&vmm_debug_rbuf->lock, NULL, MUTEX_DRIVER, NULL);
-
-	if (vmm_dmsg_ring_size > 0) {
-		vmm_debug_rbuf->maxsize = vmm_dmsg_ring_size;
-	}
-}
-
-#if notyet
-static void
-vmm_trace_rbuf_free(void)
-{
-	vmm_trace_dmsg_free();
-	mutex_destroy(&vmm_debug_rbuf->lock);
-	kmem_free(vmm_debug_rbuf, sizeof (vmm_trace_rbuf_t));
-}
-#endif
-
-static void
-vmm_vtrace_log(const char *fmt, va_list ap)
-{
-	vmm_trace_dmsg_t *dmsg;
-
-	if (vmm_debug_rbuf == NULL) {
-		return;
-	}
-
-	/*
-	 * If max size of ring buffer is smaller than size
-	 * required for one debug message then just return
-	 * since we have no room for the debug message.
-	 */
-	if (vmm_debug_rbuf->maxsize < (sizeof (vmm_trace_dmsg_t))) {
-		return;
-	}
-
-	mutex_enter(&vmm_debug_rbuf->lock);
-
-	/* alloc or reuse on ring buffer */
-	dmsg = vmm_trace_dmsg_alloc();
-
-	if (dmsg == NULL) {
-		/* resource allocation failed */
-		mutex_exit(&vmm_debug_rbuf->lock);
-		return;
-	}
-
-	gethrestime(&dmsg->timestamp);
-
-	(void) vsnprintf(dmsg->buf, sizeof (dmsg->buf), fmt, ap);
-
-	mutex_exit(&vmm_debug_rbuf->lock);
-}
-
-void
-vmm_trace_log(const char *fmt, ...)
-{
-	va_list ap;
-
-	va_start(ap, fmt);
-	vmm_vtrace_log(fmt, ap);
-	va_end(ap);
-}
-
-void
-vmmdev_init(void)
-{
-	vmm_trace_rbuf_alloc();
-}
-
-int
-vmmdev_cleanup(void)
-{
-	VERIFY(list_is_empty(&vmmdev_list));
-
-	vmm_trace_dmsg_free();
-	return (0);
-}
-
 static int
 vmmdev_get_memseg(vmm_softc_t *sc, struct vm_memseg *mseg)
 {
@@ -1945,7 +1770,6 @@ vmm_attach(dev_info_t *dip, ddi_attach_cmd_t cmd)
 
 	ddi_report_dev(dip);
 
-	/* XXX: This needs updating */
 	vmm_arena_init();
 
 	vmmdev_load_failure = B_FALSE;
@@ -1986,19 +1810,14 @@ vmm_detach(dev_info_t *dip, ddi_detach_cmd_t cmd)
 		mutex_exit(&vmmdev_mtx);
 		return (DDI_FAILURE);
 	}
-
 	vmm_sdev_hdl = NULL;
 
-	/* XXX: This needs updating */
-	if (!vmm_arena_fini()) {
-		mutex_exit(&vmmdev_mtx);
-		return (DDI_FAILURE);
-	}
-
 	/* Remove the control node. */
 	ddi_remove_minor_node(dip, "ctl");
 	vmm_dip = NULL;
 	vmm_sol_glue_cleanup();
+	vmm_arena_fini();
+
 	mutex_exit(&vmmdev_mtx);
 
 	return (DDI_SUCCESS);
diff --git a/usr/src/uts/i86pc/io/vmm/vmm_sol_vm.c b/usr/src/uts/i86pc/io/vmm/vmm_sol_vm.c
index 1b074d2f92..d8a44ddf37 100644
--- a/usr/src/uts/i86pc/io/vmm/vmm_sol_vm.c
+++ b/usr/src/uts/i86pc/io/vmm/vmm_sol_vm.c
@@ -10,7 +10,7 @@
  */
 
 /*
- * Copyright 2017 Joyent, Inc.
+ * Copyright 2018 Joyent, Inc.
  */
 
 #include <sys/param.h>
@@ -141,28 +141,36 @@ static void vm_mapping_remove(struct vmspace *, vmspace_mapping_t *);
 static kmutex_t eptable_map_lock;
 static struct eptable_map *eptable_map_head = NULL;
 
-static vmem_t	*vmm_arena = NULL;
+static vmem_t *vmm_alloc_arena = NULL;
 
+static void *
+vmm_arena_alloc(vmem_t *vmp, size_t size, int vmflag)
+{
+	return (segkmem_xalloc(vmp, NULL, size, vmflag, 0,
+	    segkmem_page_create, &kvps[KV_VVP]));
+}
+
+static void
+vmm_arena_free(vmem_t *vmp, void *inaddr, size_t size)
+{
+	segkmem_xfree(vmp, inaddr, size, &kvps[KV_VVP], NULL);
+}
 
 void
 vmm_arena_init(void)
 {
-	/*
-	 * XXXJOY: Hahaha, this is terrible, pls fix, prototype only
-	 */
-	vmm_arena = vmem_create("vmm_arena", NULL, 0, PAGESIZE,
-	    segkmem_zio_alloc, segkmem_zio_free, zio_arena, 0, VM_SLEEP);
+	vmm_alloc_arena = vmem_create("vmm_alloc_arena", NULL, 0, 1024 * 1024,
+	    vmm_arena_alloc, vmm_arena_free, kvmm_arena, 0, VM_SLEEP);
+
+	ASSERT(vmm_alloc_arena != NULL);
 }
 
-boolean_t
+void
 vmm_arena_fini(void)
 {
-	if (vmem_size(vmm_arena, VMEM_ALLOC) != 0) {
-		return (B_FALSE);
-	}
-	vmem_destroy(vmm_arena);
-	vmm_arena = NULL;
-	return (B_TRUE);
+	VERIFY(vmem_size(vmm_alloc_arena, VMEM_ALLOC) == 0);
+	vmem_destroy(vmm_alloc_arena);
+	vmm_alloc_arena = NULL;
 }
 
 struct vmspace *
@@ -941,7 +949,7 @@ vm_object_allocate(objtype_t type, vm_pindex_t psize)
 	switch (type) {
 	case OBJT_DEFAULT: {
 		/* XXXJOY: opt-in to larger pages? */
-		vmo->vmo_data = vmem_alloc(vmm_arena, size, KM_NOSLEEP);
+		vmo->vmo_data = vmem_alloc(vmm_alloc_arena, size, KM_NOSLEEP);
 		if (vmo->vmo_data == NULL) {
 			mutex_destroy(&vmo->vmo_lock);
 			kmem_free(vmo, sizeof (*vmo));
@@ -1001,7 +1009,7 @@ vm_object_deallocate(vm_object_t vmo)
 
 	switch (vmo->vmo_type) {
 	case OBJT_DEFAULT:
-		vmem_free(vmm_arena, vmo->vmo_data, vmo->vmo_size);
+		vmem_free(vmm_alloc_arena, vmo->vmo_data, vmo->vmo_size);
 		break;
 	case OBJT_SG:
 		sglist_free((struct sglist *)vmo->vmo_data);
diff --git a/usr/src/uts/i86pc/os/ddi_impl.c b/usr/src/uts/i86pc/os/ddi_impl.c
index 0143b20922..b8d7ec952f 100644
--- a/usr/src/uts/i86pc/os/ddi_impl.c
+++ b/usr/src/uts/i86pc/os/ddi_impl.c
@@ -24,6 +24,7 @@
  * Copyright 2012 Garrett D'Amore <garrett@damore.org>
  * Copyright 2014 Pluribus Networks, Inc.
  * Copyright 2016 Nexenta Systems, Inc.
+ * Copyright 2018 Joyent, Inc.
  */
 
 /*
@@ -1009,10 +1010,10 @@ page_create_io_wrapper(void *addr, size_t len, int vmflag, void *arg)
 
 #ifdef __xpv
 static void
-segkmem_free_io(vmem_t *vmp, void * ptr, size_t size)
+segkmem_free_io(vmem_t *vmp, void *ptr, size_t size)
 {
 	extern void page_destroy_io(page_t *);
-	segkmem_xfree(vmp, ptr, size, page_destroy_io);
+	segkmem_xfree(vmp, ptr, size, &kvp, page_destroy_io);
 }
 #endif
 
diff --git a/usr/src/uts/i86pc/os/intr.c b/usr/src/uts/i86pc/os/intr.c
index 36ec2e4945..f66f0e69e8 100644
--- a/usr/src/uts/i86pc/os/intr.c
+++ b/usr/src/uts/i86pc/os/intr.c
@@ -473,17 +473,17 @@
 
 #if defined(__amd64) && !defined(__xpv)
 /* If this fails, then the padding numbers in machcpuvar.h are wrong. */
-CTASSERT((offsetof(cpu_t, cpu_m) + offsetof(struct machcpu, mcpu_pad))
-    < MMU_PAGESIZE);
-CTASSERT((offsetof(cpu_t, cpu_m) + offsetof(struct machcpu, mcpu_kpti))
-    >= MMU_PAGESIZE);
-CTASSERT((offsetof(cpu_t, cpu_m) + offsetof(struct machcpu, mcpu_kpti_dbg))
-    < 2 * MMU_PAGESIZE);
-CTASSERT((offsetof(cpu_t, cpu_m) + offsetof(struct machcpu, mcpu_pad2))
-    < 2 * MMU_PAGESIZE);
+CTASSERT((offsetof(cpu_t, cpu_m) + offsetof(struct machcpu, mcpu_pad)) <
+    MMU_PAGESIZE);
+CTASSERT((offsetof(cpu_t, cpu_m) + offsetof(struct machcpu, mcpu_kpti)) >=
+    MMU_PAGESIZE);
+CTASSERT((offsetof(cpu_t, cpu_m) + offsetof(struct machcpu, mcpu_kpti_dbg)) <
+    2 * MMU_PAGESIZE);
+CTASSERT((offsetof(cpu_t, cpu_m) + offsetof(struct machcpu, mcpu_pad2)) <
+    2 * MMU_PAGESIZE);
 CTASSERT(((sizeof (struct kpti_frame)) & 0xF) == 0);
-CTASSERT(((offsetof(cpu_t, cpu_m) + offsetof(struct machcpu, mcpu_kpti_dbg))
-    & 0xF) == 0);
+CTASSERT(((offsetof(cpu_t, cpu_m) +
+    offsetof(struct machcpu, mcpu_kpti_dbg)) & 0xF) == 0);
 CTASSERT((offsetof(struct kpti_frame, kf_tr_rsp) & 0xF) == 0);
 #endif
 
diff --git a/usr/src/uts/i86pc/os/pc_hvm.c b/usr/src/uts/i86pc/os/pc_hvm.c
index b74ceb17bf..60f8e8d3ca 100644
--- a/usr/src/uts/i86pc/os/pc_hvm.c
+++ b/usr/src/uts/i86pc/os/pc_hvm.c
@@ -10,9 +10,12 @@
  */
 
 /*
- * Copyright 2017 Joyent, Inc.
+ * Copyright 2018 Joyent, Inc.
  */
 
+#include <sys/cmn_err.h>
+#include <sys/ddi.h>
+#include <sys/sunddi.h>
 #include <sys/param.h>
 #include <sys/types.h>
 #include <sys/mutex.h>
@@ -35,12 +38,17 @@ static const char *hvm_excl_holder = NULL;
 boolean_t
 hvm_excl_hold(const char *consumer)
 {
-	boolean_t res = B_FALSE;
+	boolean_t res;
 
 	mutex_enter(&hvm_excl_lock);
 	if (hvm_excl_holder == NULL) {
 		hvm_excl_holder = consumer;
 		res = B_TRUE;
+	} else {
+		cmn_err(CE_WARN, "zone '%s' cannot take HVM exclusion lock as "
+		    "'%s': held by '%s'", curproc->p_zone->zone_name, consumer,
+		    hvm_excl_holder);
+		res = B_FALSE;
 	}
 	mutex_exit(&hvm_excl_lock);
 
diff --git a/usr/src/uts/i86pc/os/startup.c b/usr/src/uts/i86pc/os/startup.c
index a3026f0eb4..f63973f092 100644
--- a/usr/src/uts/i86pc/os/startup.c
+++ b/usr/src/uts/i86pc/os/startup.c
@@ -319,22 +319,16 @@ static struct seg *segmap = &kmapseg;	/* easier to use name for in here */
 
 struct seg *segkp = &kpseg;	/* Pageable kernel virtual memory segment */
 
-#if defined(__amd64)
 struct seg kvseg_core;		/* Segment used for the core heap */
 struct seg kpmseg;		/* Segment used for physical mapping */
 struct seg *segkpm = &kpmseg;	/* 64bit kernel physical mapping segment */
-#else
-struct seg *segkpm = NULL;	/* Unused on IA32 */
-#endif
 
 caddr_t segkp_base;		/* Base address of segkp */
 caddr_t segzio_base;		/* Base address of segzio */
-#if defined(__amd64)
 pgcnt_t segkpsize = btop(SEGKPDEFSIZE);	/* size of segkp segment in pages */
-#else
-pgcnt_t segkpsize = 0;
-#endif
-pgcnt_t segziosize = 0;		/* size of zio segment in pages */
+caddr_t segkvmm_base;
+pgcnt_t segkvmmsize;
+pgcnt_t segziosize;
 
 /*
  * A static DR page_t VA map is reserved that can map the page structures
@@ -455,23 +449,32 @@ static pgcnt_t kphysm_init(page_t *, pgcnt_t);
  * 0xFFFFFFFF.C0000000  |-----------------------|- core_base / ekernelheap
  *			|	 Kernel		|
  *			|	  heap		|
+ *			|			|
+ *			|			|
  * 0xFFFFFXXX.XXX00000  |-----------------------|- kernelheap (floating)
  *			|	 segmap		|
  * 0xFFFFFXXX.XXX00000  |-----------------------|- segmap_start (floating)
  *			|    device mappings	|
  * 0xFFFFFXXX.XXX00000  |-----------------------|- toxic_addr (floating)
- *			|	  segzio	|
+ *			|	 segzio		|
  * 0xFFFFFXXX.XXX00000  |-----------------------|- segzio_base (floating)
- *			|	  segkp		|
- * ---                  |-----------------------|- segkp_base (floating)
+ *			|        segkvmm	|
+ *			|			|
+ *			|			|
+ *			|			|
+ * 0xFFFFFXXX.XXX00000  |-----------------------|- segkvmm_base (floating)
+ *			|	 segkp		|
+ * 			|-----------------------|- segkp_base (floating)
  *			|   page_t structures	|  valloc_base + valloc_sz
  *			|   memsegs, memlists,	|
  *			|   page hash, etc.	|
- * 0xFFFFFF00.00000000  |-----------------------|- valloc_base (lower if >256GB)
+ * 0xFFFFFE00.00000000  |-----------------------|- valloc_base (lower if >256GB)
  *			|	 segkpm		|
- * 0xFFFFFE00.00000000  |-----------------------|
+ *			|			|
+ * 0xFFFFFD00.00000000  |-----------------------|- SEGKPM_BASE (lower if >256GB)
  *			|	Red Zone	|
- * 0xFFFFFD80.00000000  |-----------------------|- KERNELBASE (lower if >256GB)
+ * 0xFFFFFC80.00000000  |-----------------------|- KERNELBASE (lower if >256GB)
+ * 0xFFFFFC7F.FFE00000  |-----------------------|- USERLIMIT (lower if >256GB)
  *			|     User stack	|- User space memory
  *			|			|
  *			| shared objects, etc	|	(grows downwards)
@@ -1084,22 +1087,9 @@ startup_memlist(void)
 	PRM_DEBUG(memblocks);
 
 	/*
-	 * Compute maximum physical address for memory DR operations.
-	 * Memory DR operations are unsupported on xpv or 32bit OSes.
+	 * We no longer support any form of memory DR.
 	 */
-#ifdef	__amd64
-	if (plat_dr_support_memory()) {
-		if (plat_dr_physmax == 0) {
-			uint_t pabits = UINT_MAX;
-
-			cpuid_get_addrsize(CPU, &pabits, NULL);
-			plat_dr_physmax = btop(1ULL << pabits);
-		}
-		if (plat_dr_physmax > PHYSMEM_MAX64)
-			plat_dr_physmax = PHYSMEM_MAX64;
-	} else
-#endif
-		plat_dr_physmax = 0;
+	plat_dr_physmax = 0;
 
 	/*
 	 * Examine the bios reserved memory to find out:
@@ -1260,68 +1250,55 @@ startup_memlist(void)
 	pse_table_alloc_size = pse_table_size * sizeof (pad_mutex_t);
 	ADD_TO_ALLOCATIONS(pse_mutex, pse_table_alloc_size);
 
-#if defined(__amd64)
 	valloc_sz = ROUND_UP_LPAGE(valloc_sz);
 	valloc_base = VALLOC_BASE;
 
 	/*
-	 * The default values of VALLOC_BASE and SEGKPM_BASE should work
-	 * for values of physmax up to 256GB (1/4 TB). They need adjusting when
-	 * memory is at addresses above 256GB. When adjusted, segkpm_base must
-	 * be aligned on KERNEL_REDZONE_SIZE boundary (span of top level pte).
+	 * The signicant memory-sized regions are roughly sized as follows in
+	 * the default layout with max physmem:
+	 *  segkpm: 1x physmem allocated (but 1Tb room, below VALLOC_BASE)
+	 *  segzio: 1.5x physmem
+	 *  segkvmm: 4x physmem
+	 *  heap: whatever's left up to COREHEAP_BASE, at least 1.5x physmem
+	 *
+	 * The idea is that we leave enough room to avoid fragmentation issues,
+	 * so we would like the VA arenas to have some extra.
+	 *
+	 * Ignoring the loose change of segkp, valloc, and such, this means that
+	 * as COREHEAP_BASE-VALLOC_BASE=2Tb, we can accommodate a physmem up to
+	 * about (2Tb / 7.0), rounded down to 256Gb in the check below.
 	 *
-	 * In the general case (>256GB), we use (4 * physmem) for the
-	 * kernel's virtual addresses, which is divided approximately
-	 * as follows:
-	 *  - 1 * physmem for segkpm
-	 *  - 1.5 * physmem for segzio
-	 *  - 1.5 * physmem for heap
-	 * Total: 4.0 * physmem
+	 * Note that KPM lives below VALLOC_BASE, but we want to include it in
+	 * adjustments, hence the 8 below.
 	 *
-	 * Note that the segzio and heap sizes are more than physmem so that
-	 * VA fragmentation does not prevent either of them from being
-	 * able to use nearly all of physmem.  The value of 1.5x is determined
-	 * experimentally and may need to change if the workload changes.
+	 * Beyond 256Gb, we push segkpm_base (and hence kernelbase and
+	 * _userlimit) down to accommodate the VA requirements above.
 	 */
-	if (physmax + 1 > mmu_btop(TERABYTE / 4) ||
-	    plat_dr_physmax > mmu_btop(TERABYTE / 4)) {
-		uint64_t kpm_resv_amount = mmu_ptob(physmax + 1);
+	if (physmax + 1 > mmu_btop(TERABYTE / 4)) {
+		uint64_t physmem_bytes = mmu_ptob(physmax + 1);
+		uint64_t adjustment = 8 * (physmem_bytes - (TERABYTE / 4));
 
-		if (kpm_resv_amount < mmu_ptob(plat_dr_physmax)) {
-			kpm_resv_amount = mmu_ptob(plat_dr_physmax);
-		}
+		PRM_DEBUG(adjustment);
 
 		/*
-		 * This is what actually controls the KVA : UVA split.
-		 * The kernel uses high VA, and this is lowering the
-		 * boundary, thus increasing the amount of VA for the kernel.
-		 * This gives the kernel 4 * (amount of physical memory) VA.
-		 *
-		 * The maximum VA is UINT64_MAX and we are using
-		 * 64-bit 2's complement math, so e.g. if you have 512GB
-		 * of memory, segkpm_base = -(4 * 512GB) == -2TB ==
-		 * UINT64_MAX - 2TB (approximately).  So the kernel's
-		 * VA is [UINT64_MAX-2TB to UINT64_MAX].
+		 * segkpm_base is always aligned on a L3 PTE boundary.
 		 */
-		segkpm_base = -(P2ROUNDUP((4 * kpm_resv_amount),
-		    KERNEL_REDZONE_SIZE));
+		segkpm_base -= P2ROUNDUP(adjustment, KERNEL_REDZONE_SIZE);
 
-		/* make sure we leave some space for user apps above hole */
+		/*
+		 * But make sure we leave some space for user apps above hole.
+		 */
 		segkpm_base = MAX(segkpm_base, AMD64_VA_HOLE_END + TERABYTE);
-		if (segkpm_base > SEGKPM_BASE)
-			segkpm_base = SEGKPM_BASE;
-		PRM_DEBUG(segkpm_base);
 
-		valloc_base = segkpm_base + P2ROUNDUP(kpm_resv_amount, ONE_GIG);
+		ASSERT(segkpm_base <= SEGKPM_BASE);
+
+		valloc_base = segkpm_base + P2ROUNDUP(physmem_bytes, ONE_GIG);
 		if (valloc_base < segkpm_base)
 			panic("not enough kernel VA to support memory size");
-		PRM_DEBUG(valloc_base);
 	}
-#else	/* __i386 */
-	valloc_base = (uintptr_t)(MISC_VA_BASE - valloc_sz);
-	valloc_base = P2ALIGN(valloc_base, mmu.level_size[1]);
+
+	PRM_DEBUG(segkpm_base);
 	PRM_DEBUG(valloc_base);
-#endif	/* __i386 */
 
 	/*
 	 * do all the initial allocations
@@ -1909,73 +1886,70 @@ protect_boot_range(uintptr_t low, uintptr_t high, int setaside)
 }
 
 /*
- *
+ * Establish the final size of the kernel's heap, size of segmap, segkp, etc.
  */
 static void
 layout_kernel_va(void)
 {
-	PRM_POINT("layout_kernel_va() starting...");
-	/*
-	 * Establish the final size of the kernel's heap, size of segmap,
-	 * segkp, etc.
-	 */
+	const size_t physmem_size = mmu_ptob(physmem);
+	size_t size;
 
-#if defined(__amd64)
+	PRM_POINT("layout_kernel_va() starting...");
 
 	kpm_vbase = (caddr_t)segkpm_base;
-	if (physmax + 1 < plat_dr_physmax) {
-		kpm_size = ROUND_UP_LPAGE(mmu_ptob(plat_dr_physmax));
-	} else {
-		kpm_size = ROUND_UP_LPAGE(mmu_ptob(physmax + 1));
-	}
+	kpm_size = ROUND_UP_LPAGE(mmu_ptob(physmax + 1));
 	if ((uintptr_t)kpm_vbase + kpm_size > (uintptr_t)valloc_base)
 		panic("not enough room for kpm!");
 	PRM_DEBUG(kpm_size);
 	PRM_DEBUG(kpm_vbase);
 
-	/*
-	 * By default we create a seg_kp in 64 bit kernels, it's a little
-	 * faster to access than embedding it in the heap.
-	 */
 	segkp_base = (caddr_t)valloc_base + valloc_sz;
 	if (!segkp_fromheap) {
-		size_t sz = mmu_ptob(segkpsize);
+		size = mmu_ptob(segkpsize);
 
 		/*
 		 * determine size of segkp
 		 */
-		if (sz < SEGKPMINSIZE || sz > SEGKPMAXSIZE) {
-			sz = SEGKPDEFSIZE;
+		if (size < SEGKPMINSIZE || size > SEGKPMAXSIZE) {
+			size = SEGKPDEFSIZE;
 			cmn_err(CE_WARN, "!Illegal value for segkpsize. "
 			    "segkpsize has been reset to %ld pages",
-			    mmu_btop(sz));
+			    mmu_btop(size));
 		}
-		sz = MIN(sz, MAX(SEGKPMINSIZE, mmu_ptob(physmem)));
+		size = MIN(size, MAX(SEGKPMINSIZE, physmem_size));
 
-		segkpsize = mmu_btop(ROUND_UP_LPAGE(sz));
+		segkpsize = mmu_btop(ROUND_UP_LPAGE(size));
 	}
 	PRM_DEBUG(segkp_base);
 	PRM_DEBUG(segkpsize);
 
 	/*
-	 * segzio is used for ZFS cached data. It uses a distinct VA
-	 * segment (from kernel heap) so that we can easily tell not to
-	 * include it in kernel crash dumps on 64 bit kernels. The trick is
-	 * to give it lots of VA, but not constrain the kernel heap.
-	 * We can use 1.5x physmem for segzio, leaving approximately
-	 * another 1.5x physmem for heap.  See also the comment in
-	 * startup_memlist().
+	 * segkvmm: backing for vmm guest memory. Like segzio, we have a
+	 * separate segment for two reasons: it makes it easy to skip our pages
+	 * on kernel crash dumps, and it helps avoid fragmentation.  With this
+	 * segment, we're expecting significantly-sized allocations only; we'll
+	 * default to 4x the size of physmem.
+	 */
+	segkvmm_base = segkp_base + mmu_ptob(segkpsize);
+	size = segkvmmsize != 0 ? mmu_ptob(segkvmmsize) : (physmem_size * 4);
+
+	size = MAX(size, SEGVMMMINSIZE);
+	segkvmmsize = mmu_btop(ROUND_UP_LPAGE(size));
+
+	PRM_DEBUG(segkvmmsize);
+	PRM_DEBUG(segkvmm_base);
+
+	/*
+	 * segzio is used for ZFS cached data.  For segzio, we use 1.5x physmem.
 	 */
-	segzio_base = segkp_base + mmu_ptob(segkpsize);
+	segzio_base = segkvmm_base + mmu_ptob(segkvmmsize);
 	if (segzio_fromheap) {
 		segziosize = 0;
 	} else {
-		size_t physmem_size = mmu_ptob(physmem);
-		size_t size = (segziosize == 0) ?
-		    physmem_size * 3 / 2 : mmu_ptob(segziosize);
+		size = (segziosize != 0) ? mmu_ptob(segziosize) :
+		    (physmem_size * 3) / 2;
 
-		if (size < SEGZIOMINSIZE)
-			size = SEGZIOMINSIZE;
+		size = MAX(size, SEGZIOMINSIZE);
 		segziosize = mmu_btop(ROUND_UP_LPAGE(size));
 	}
 	PRM_DEBUG(segziosize);
@@ -1989,10 +1963,6 @@ layout_kernel_va(void)
 	    ROUND_UP_LPAGE((uintptr_t)segzio_base + mmu_ptob(segziosize));
 	PRM_DEBUG(toxic_addr);
 	segmap_start = ROUND_UP_LPAGE(toxic_addr + toxic_size);
-#else /* __i386 */
-	segmap_start = ROUND_UP_LPAGE(kernelbase);
-#endif /* __i386 */
-	PRM_DEBUG(segmap_start);
 
 	/*
 	 * Users can change segmapsize through eeprom. If the variable
@@ -2001,16 +1971,6 @@ layout_kernel_va(void)
 	 */
 	segmapsize = MAX(ROUND_UP_LPAGE(segmapsize), SEGMAPDEFAULT);
 
-#if defined(__i386)
-	/*
-	 * 32-bit systems don't have segkpm or segkp, so segmap appears at
-	 * the bottom of the kernel's address range.  Set aside space for a
-	 * small red zone just below the start of segmap.
-	 */
-	segmap_start += KERNEL_REDZONE_SIZE;
-	segmapsize -= KERNEL_REDZONE_SIZE;
-#endif
-
 	PRM_DEBUG(segmap_start);
 	PRM_DEBUG(segmapsize);
 	kernelheap = (caddr_t)ROUND_UP_LPAGE(segmap_start + segmapsize);
@@ -2799,11 +2759,16 @@ kvm_init(void)
 		(void) segkmem_create(&kvseg_core);
 	}
 
+	PRM_POINT("attaching segkvmm");
+	(void) seg_attach(&kas, segkvmm_base, mmu_ptob(segkvmmsize), &kvmmseg);
+	(void) segkmem_create(&kvmmseg);
+	segkmem_kvmm_init(segkvmm_base, mmu_ptob(segkvmmsize));
+
 	if (segziosize > 0) {
 		PRM_POINT("attaching segzio");
 		(void) seg_attach(&kas, segzio_base, mmu_ptob(segziosize),
 		    &kzioseg);
-		(void) segkmem_zio_create(&kzioseg);
+		(void) segkmem_create(&kzioseg);
 
 		/* create zio area covering new segment */
 		segkmem_zio_init(segzio_base, mmu_ptob(segziosize));
diff --git a/usr/src/uts/i86pc/sys/machparam.h b/usr/src/uts/i86pc/sys/machparam.h
index 51d7559483..3728f30ca6 100644
--- a/usr/src/uts/i86pc/sys/machparam.h
+++ b/usr/src/uts/i86pc/sys/machparam.h
@@ -31,14 +31,15 @@
 #ifndef _SYS_MACHPARAM_H
 #define	_SYS_MACHPARAM_H
 
-#if !defined(_ASM)
+#ifndef _ASM
+
 #include <sys/types.h>
 
 #if defined(__xpv)
 #include <sys/xpv_impl.h>
 #endif
 
-#endif
+#endif /* !_ASM */
 
 #ifdef	__cplusplus
 extern "C" {
@@ -54,17 +55,12 @@ extern "C" {
  * Machine dependent parameters and limits.
  */
 
-#if defined(__amd64)
 /*
  * If NCPU grows beyond 256, sizing for the x86 comm page will require
  * adjustment.
  */
 #define	NCPU	256
 #define	NCPU_LOG2	8
-#elif defined(__i386)
-#define	NCPU	32
-#define	NCPU_LOG2	5
-#endif
 
 /* NCPU_P2 is NCPU rounded to a power of 2 */
 #define	NCPU_P2	(1 << NCPU_LOG2)
@@ -116,11 +112,7 @@ extern "C" {
 /*
  * DEFAULT KERNEL THREAD stack size (in pages).
  */
-#if defined(__amd64)
 #define	DEFAULTSTKSZ_NPGS	5
-#elif defined(__i386)
-#define	DEFAULTSTKSZ_NPGS	3
-#endif
 
 #if !defined(_ASM)
 #define	DEFAULTSTKSZ	(DEFAULTSTKSZ_NPGS * PAGESIZE)
@@ -129,43 +121,42 @@ extern "C" {
 #endif	/* !_ASM */
 
 /*
- * KERNELBASE is the virtual address at which the kernel segments start in
- * all contexts.
- *
- * KERNELBASE is not fixed.  The value of KERNELBASE can change with
- * installed memory or on 32 bit systems the eprom variable 'eprom_kernelbase'.
- *
- * common/conf/param.c requires a compile time defined value for KERNELBASE.
- * This value is save in the variable _kernelbase.  _kernelbase may then be
- * modified with to a different value in i86pc/os/startup.c.
- *
- * Most code should be using kernelbase, which resolves to a reference to
- * _kernelbase.
+ * During intial boot we limit heap to the top 4Gig.
  */
-#define	KERNEL_TEXT_amd64	UINT64_C(0xfffffffffb800000)
-
-#ifdef __i386
-
-#define	KERNEL_TEXT_i386	ADDRESS_C(0xfe800000)
+#define	BOOT_KERNELHEAP_BASE	ADDRESS_C(0xffffffff00000000)
 
 /*
- * We don't use HYPERVISOR_VIRT_START, as we need both the PAE and non-PAE
- * versions in our code. We always compile based on the lower PAE address.
+ * VMWare works best if we don't use the top 64Meg of memory for amd64.
+ * Set KERNEL_TEXT to top_o_memory - 64Meg - 8 Meg for 8Meg of nucleus pages.
  */
-#define	KERNEL_TEXT_i386_xpv	\
-	(HYPERVISOR_VIRT_START_PAE - 3 * ADDRESS_C(0x400000))
-
-#endif /* __i386 */
+#define	PROMSTART	ADDRESS_C(0xffc00000)
 
-#if defined(__amd64)
+/*
+ * Virtual address range available to the debugger
+ */
+#define	SEGDEBUGBASE	ADDRESS_C(0xffffffffff800000)
+#define	SEGDEBUGSIZE	ADDRESS_C(0x400000)
 
-#define	KERNELBASE	ADDRESS_C(0xfffffd8000000000)
+#define	KERNEL_TEXT	UINT64_C(0xfffffffffb800000)
 
 /*
- * Size of the unmapped "red zone" at the very bottom of the kernel's
- * address space.  Corresponds to 1 slot in the toplevel pagetable.
+ * Reserve pages just below KERNEL_TEXT for the GDT, IDT, LDT, TSS and debug
+ * info.
+ *
+ * For now, DEBUG_INFO_VA must be first in this list for "xm" initiated dumps
+ * of solaris domUs to be usable with mdb. Relying on a fixed VA is not viable
+ * long term, but it's the best we've got for now.
  */
-#define	KERNEL_REDZONE_SIZE   ((uintptr_t)1 << 39)
+#if !defined(_ASM)
+#define	DEBUG_INFO_VA	(KERNEL_TEXT - MMU_PAGESIZE)
+#define	GDT_VA		(DEBUG_INFO_VA - MMU_PAGESIZE)
+#define	IDT_VA		(GDT_VA - MMU_PAGESIZE)
+#define	LDT_VA		(IDT_VA - (16 * MMU_PAGESIZE))
+#define	KTSS_VA		(IDT_VA - MMU_PAGESIZE)
+#define	DFTSS_VA	(KTSS_VA - MMU_PAGESIZE)
+#define	MISC_VA_BASE	(DFTSS_VA)
+#define	MISC_VA_SIZE	(KERNEL_TEXT - MISC_VA_BASE)
+#endif /* !_ASM */
 
 /*
  * Base of 'core' heap area, which is used for kernel and module text/data
@@ -173,53 +164,48 @@ extern "C" {
  */
 #define	COREHEAP_BASE	ADDRESS_C(0xffffffffc0000000)
 
-/*
- * Beginning of the segkpm window. A lower value than this is used if
- * physical addresses exceed 1TB. See i86pc/os/startup.c
- */
-#define	SEGKPM_BASE	ADDRESS_C(0xfffffe0000000000)
-
 /*
  * This is valloc_base, above seg_kpm, but below everything else.
  * A lower value than this may be used if SEGKPM_BASE is adjusted.
  * See i86pc/os/startup.c
  */
-#define	VALLOC_BASE	ADDRESS_C(0xffffff0000000000)
+#define	VALLOC_BASE	ADDRESS_C(0xfffffe0000000000)
+
+#define	SEGZIOMINSIZE	(400L * 1024 * 1024L)			/* 400M */
+#define	SEGVMMMINSIZE	(4096L * 1024 * 1024L)			/* 4G */
 
-/*
- * default and boundary sizes for segkp
- */
 #define	SEGKPDEFSIZE	(2L * 1024L * 1024L * 1024L)		/*   2G */
 #define	SEGKPMAXSIZE	(8L * 1024L * 1024L * 1024L)		/*   8G */
 #define	SEGKPMINSIZE	(200L * 1024 * 1024L)			/* 200M */
 
-/*
- * minimum size for segzio
- */
-#define	SEGZIOMINSIZE	(400L * 1024 * 1024L)			/* 400M */
-
-/*
- * During intial boot we limit heap to the top 4Gig.
- */
-#define	BOOT_KERNELHEAP_BASE	ADDRESS_C(0xffffffff00000000)
+#define	SEGKPM_BASE	ADDRESS_C(0xfffffd0000000000)
 
 /*
- * VMWare works best if we don't use the top 64Meg of memory for amd64.
- * Set KERNEL_TEXT to top_o_memory - 64Meg - 8 Meg for 8Meg of nucleus pages.
+ * KERNELBASE is the virtual address at which the kernel segments start in
+ * all contexts.
+ *
+ * KERNELBASE is not fixed.  The value of KERNELBASE can change with
+ * installed memory size.
+ *
+ * common/conf/param.c requires a compile time defined value for KERNELBASE.
+ * This value is save in the variable _kernelbase.  _kernelbase may then be
+ * modified with to a different value in i86pc/os/startup.c.
+ *
+ * Most code should be using kernelbase, which resolves to a reference to
+ * _kernelbase.
  */
-#define	PROMSTART	ADDRESS_C(0xffc00000)
-#define	KERNEL_TEXT	KERNEL_TEXT_amd64
+#define	KERNELBASE	ADDRESS_C(0xfffffc8000000000)
 
 /*
- * Virtual address range available to the debugger
+ * Size of the unmapped "red zone" at the very bottom of the kernel's
+ * address space.  Corresponds to 1 slot in the toplevel pagetable.
  */
-#define	SEGDEBUGBASE	ADDRESS_C(0xffffffffff800000)
-#define	SEGDEBUGSIZE	ADDRESS_C(0x400000)
+#define	KERNEL_REDZONE_SIZE   ((uintptr_t)1 << 39)
 
 /*
  * Define upper limit on user address space
  *
- * In amd64, the upper limit on a 64-bit user address space is 1 large page
+ * The upper limit on a 64-bit user address space is 1 large page
  * (2MB) below kernelbase.  The upper limit for a 32-bit user address space
  * is 1 small page (4KB) below the top of the 32-bit range.  The 64-bit
  * limit give dtrace the red zone it needs below kernelbase.  The 32-bit
@@ -232,7 +218,7 @@ extern "C" {
 #if defined(__xpv)
 #define	USERLIMIT	ADDRESS_C(0x00007fffffe00000)
 #else
-#define	USERLIMIT	ADDRESS_C(0xfffffd7fffe00000)
+#define	USERLIMIT	ADDRESS_C(0xfffffc7fffe00000)
 #endif
 
 #ifdef bug_5074717_is_fixed
@@ -241,76 +227,6 @@ extern "C" {
 #define	USERLIMIT32	ADDRESS_C(0xfefff000)
 #endif
 
-#elif defined(__i386)
-
-#ifdef DEBUG
-#define	KERNELBASE	ADDRESS_C(0xc8000000)
-#else
-#define	KERNELBASE	ADDRESS_C(0xd4000000)
-#endif
-
-#define	KERNELBASE_MAX	ADDRESS_C(0xe0000000)
-
-/*
- * The i386 ABI requires that the user address space be at least 3Gb
- * in size.  KERNELBASE_ABI_MIN is used as the default KERNELBASE for
- * physical memory configurations > 4gb.
- */
-#define	KERNELBASE_ABI_MIN	ADDRESS_C(0xc0000000)
-
-/*
- * Size of the unmapped "red zone" at the very bottom of the kernel's
- * address space.  Since segmap start immediately above the red zone, this
- * needs to be MAXBSIZE aligned.
- */
-#define	KERNEL_REDZONE_SIZE   MAXBSIZE
-
-/*
- * This is the last 4MB of the 4G address space. Some psm modules
- * need this region of virtual address space mapped 1-1
- * The top 64MB of the address space is reserved for the hypervisor.
- */
-#define	PROMSTART	ADDRESS_C(0xffc00000)
-#ifdef __xpv
-#define	KERNEL_TEXT	KERNEL_TEXT_i386_xpv
-#else
-#define	KERNEL_TEXT	KERNEL_TEXT_i386
-#endif
-
-/*
- * Virtual address range available to the debugger
- * We place it just above the kernel text (4M) and kernel data (4M).
- */
-#define	SEGDEBUGBASE	(KERNEL_TEXT + ADDRESS_C(0x800000))
-#define	SEGDEBUGSIZE	ADDRESS_C(0x400000)
-
-/*
- * Define upper limit on user address space
- */
-#define	USERLIMIT	KERNELBASE
-#define	USERLIMIT32	USERLIMIT
-
-#endif	/* __i386 */
-
-/*
- * Reserve pages just below KERNEL_TEXT for the GDT, IDT, LDT, TSS and debug
- * info.
- *
- * For now, DEBUG_INFO_VA must be first in this list for "xm" initiated dumps
- * of solaris domUs to be usable with mdb. Relying on a fixed VA is not viable
- * long term, but it's the best we've got for now.
- */
-#if !defined(_ASM)
-#define	DEBUG_INFO_VA	(KERNEL_TEXT - MMU_PAGESIZE)
-#define	GDT_VA		(DEBUG_INFO_VA - MMU_PAGESIZE)
-#define	IDT_VA		(GDT_VA - MMU_PAGESIZE)
-#define	LDT_VA		(IDT_VA - (16 * MMU_PAGESIZE))
-#define	KTSS_VA		(LDT_VA - MMU_PAGESIZE)
-#define	DFTSS_VA	(KTSS_VA - MMU_PAGESIZE)
-#define	MISC_VA_BASE	(DFTSS_VA)
-#define	MISC_VA_SIZE	(KERNEL_TEXT - MISC_VA_BASE)
-#endif /* !_ASM */
-
 #if !defined(_ASM) && !defined(_KMDB)
 extern uintptr_t kernelbase, segmap_start, segmapsize;
 #endif
diff --git a/usr/src/uts/i86pc/sys/vmm.h b/usr/src/uts/i86pc/sys/vmm.h
index 757dc7ce7f..4cff614f6a 100644
--- a/usr/src/uts/i86pc/sys/vmm.h
+++ b/usr/src/uts/i86pc/sys/vmm.h
@@ -160,6 +160,10 @@ typedef struct vmspace * (*vmi_vmspace_alloc)(vm_offset_t min, vm_offset_t max);
 typedef void	(*vmi_vmspace_free)(struct vmspace *vmspace);
 typedef struct vlapic * (*vmi_vlapic_init)(void *vmi, int vcpu);
 typedef void	(*vmi_vlapic_cleanup)(void *vmi, struct vlapic *vlapic);
+#ifndef __FreeBSD__
+typedef void	(*vmi_savectx)(void *vmi, int vcpu);
+typedef void	(*vmi_restorectx)(void *vmi, int vcpu);
+#endif
 
 struct vmm_ops {
 	vmm_init_func_t		init;		/* module wide initialization */
@@ -179,6 +183,11 @@ struct vmm_ops {
 	vmi_vmspace_free	vmspace_free;
 	vmi_vlapic_init		vlapic_init;
 	vmi_vlapic_cleanup	vlapic_cleanup;
+
+#ifndef __FreeBSD__
+	vmi_savectx		vmsavectx;
+	vmi_restorectx		vmrestorectx;
+#endif
 };
 
 extern struct vmm_ops vmm_ops_intel;
diff --git a/usr/src/uts/i86pc/sys/vmm_dev.h b/usr/src/uts/i86pc/sys/vmm_dev.h
index d9cb23ece9..e037089239 100644
--- a/usr/src/uts/i86pc/sys/vmm_dev.h
+++ b/usr/src/uts/i86pc/sys/vmm_dev.h
@@ -42,11 +42,6 @@
 #ifndef	_VMM_DEV_H_
 #define	_VMM_DEV_H_
 
-#ifdef _KERNEL
-void	vmmdev_init(void);
-int	vmmdev_cleanup(void);
-#endif
-
 struct vm_memmap {
 	vm_paddr_t	gpa;
 	int		segid;		/* memory segment */
diff --git a/usr/src/uts/i86pc/sys/vmm_impl.h b/usr/src/uts/i86pc/sys/vmm_impl.h
index 4d5708e48d..db2c4ab991 100644
--- a/usr/src/uts/i86pc/sys/vmm_impl.h
+++ b/usr/src/uts/i86pc/sys/vmm_impl.h
@@ -78,37 +78,4 @@ int vmm_do_vm_destroy(vmm_softc_t *, boolean_t);
 
 #endif /* _KERNEL */
 
-/*
- * VMM trace ring buffer constants
- */
-#define	VMM_DMSG_RING_SIZE		0x100000	/* 1MB */
-#define	VMM_DMSG_BUF_SIZE		256
-
-/*
- * VMM trace ring buffer content
- */
-typedef struct vmm_trace_dmsg {
-	timespec_t		timestamp;
-	char			buf[VMM_DMSG_BUF_SIZE];
-	struct vmm_trace_dmsg	*next;
-} vmm_trace_dmsg_t;
-
-/*
- * VMM trace ring buffer header
- */
-typedef struct vmm_trace_rbuf {
-	kmutex_t		lock;		/* lock to avoid clutter */
-	int			looped;		/* completed ring */
-	int			allocfailed;	/* dmsg mem alloc failed */
-	size_t			size;		/* current size */
-	size_t			maxsize;	/* max size */
-	vmm_trace_dmsg_t	*dmsgh;		/* messages head */
-	vmm_trace_dmsg_t	*dmsgp;		/* ptr to last message */
-} vmm_trace_rbuf_t;
-
-/*
- * VMM trace ring buffer interfaces
- */
-void vmm_trace_log(const char *fmt, ...);
-
 #endif	/* _VMM_IMPL_H_ */
diff --git a/usr/src/uts/i86pc/vm/seg_vmm.c b/usr/src/uts/i86pc/vm/seg_vmm.c
index faebf9ac36..beb5e81d53 100644
--- a/usr/src/uts/i86pc/vm/seg_vmm.c
+++ b/usr/src/uts/i86pc/vm/seg_vmm.c
@@ -14,12 +14,15 @@
  */
 
 /*
- * VM - Virtual-Machine-Memory segment
+ * segvmm - Virtual-Machine-Memory segment
  *
  * The vmm segment driver was designed for mapping regions of kernel memory
  * allocated to an HVM instance into userspace for manipulation there.  It
  * draws direct lineage from the umap segment driver, but meant for larger
  * mappings with fewer restrictions.
+ *
+ * seg*k*vmm, in contrast, has mappings for every VMM into kas.  We use its
+ * mappings here only to find the relevant PFNs in segvmm_fault_in().
  */
 
 
@@ -93,7 +96,7 @@ static struct seg_ops segvmm_ops = {
 
 
 /*
- * Create a kernel/user-mapped segment.
+ * Create a kernel/user-mapped segment.  ->kaddr is the segkvmm mapping.
  */
 int
 segvmm_create(struct seg **segpp, void *argsp)
diff --git a/usr/src/uts/intel/io/dnet/dnet.c b/usr/src/uts/intel/io/dnet/dnet.c
index a6badb9b4b..e1592ad902 100644
--- a/usr/src/uts/intel/io/dnet/dnet.c
+++ b/usr/src/uts/intel/io/dnet/dnet.c
@@ -3099,6 +3099,7 @@ check_srom_valid(uchar_t *vi)
 					crc ^= 7;
 				}
 			}
+		/* FALLTHROUGH */
 
 	default:
 		return (0);
diff --git a/usr/src/uts/intel/io/pci/pci_boot.c b/usr/src/uts/intel/io/pci/pci_boot.c
index 5e29a66d04..e7d131d25d 100644
--- a/usr/src/uts/intel/io/pci/pci_boot.c
+++ b/usr/src/uts/intel/io/pci/pci_boot.c
@@ -893,8 +893,9 @@ fix_ppb_res(uchar_t secbus, boolean_t prog_sub)
 {
 	uchar_t bus, dev, func;
 	uchar_t parbus, subbus;
-	uint_t io_base, io_limit, mem_base, mem_limit;
-	uint_t io_size, mem_size, io_align, mem_align;
+	uint_t io_base, io_limit, mem_base;
+	uint_t io_size, io_align;
+	uint64_t mem_size, mem_align, mem_limit;
 	uint64_t addr = 0;
 	int *regp = NULL;
 	uint_t reglen;
@@ -1049,9 +1050,9 @@ fix_ppb_res(uchar_t secbus, boolean_t prog_sub)
 				    pci_bus_res[parbus].io_reprogram;
 
 				cmn_err(CE_NOTE, "!add io-range on subtractive"
-				    " ppb[%x/%x/%x]: 0x%x ~ 0x%x\n",
-				    bus, dev, func, (uint32_t)addr,
-				    (uint32_t)addr + io_size - 1);
+				    " ppb[%x/%x/%x]: "
+				    "0x%"PRIx64" ~ 0x%"PRIx64"\n",
+				    bus, dev, func, addr, addr + io_size - 1);
 			}
 		}
 		/*
@@ -1066,9 +1067,10 @@ fix_ppb_res(uchar_t secbus, boolean_t prog_sub)
 				    pci_bus_res[parbus].mem_reprogram;
 
 				cmn_err(CE_NOTE, "!add mem-range on "
-				    "subtractive ppb[%x/%x/%x]: 0x%x ~ 0x%x\n",
-				    bus, dev, func, (uint32_t)addr,
-				    (uint32_t)addr + mem_size - 1);
+				    "subtractive ppb[%x/%x/%x]: "
+				    "0x%"PRIx64" ~ 0x%"PRIx64"\n",
+				    bus, dev, func,
+				    addr, addr + mem_size - 1);
 			}
 		}
 
@@ -1197,15 +1199,15 @@ fix_ppb_res(uchar_t secbus, boolean_t prog_sub)
 				if (is_vga(list, MEM))
 					continue;
 				if (mem_base == 0) {
-					mem_base = (uint_t)list->ml_address;
+					mem_base = list->ml_address;
 					mem_base = P2ALIGN(mem_base,
 					    PPB_MEM_ALIGNMENT);
-					mem_limit = (uint_t)(list->ml_address +
+					mem_limit = (list->ml_address +
 					    list->ml_size - 1);
 				} else {
 					if ((list->ml_address + list->ml_size) >
 					    mem_limit) {
-						mem_limit = (uint_t)
+						mem_limit =
 						    (list->ml_address +
 						    list->ml_size - 1);
 					}
@@ -1265,7 +1267,7 @@ fix_ppb_res(uchar_t secbus, boolean_t prog_sub)
 			add_ranges_prop(secbus, 1);
 
 			cmn_err(CE_NOTE, "!reprogram mem-range on"
-			    " ppb[%x/%x/%x]: 0x%x ~ 0x%x\n",
+			    " ppb[%x/%x/%x]: 0x%x ~ 0x%"PRIx64"\n",
 			    bus, dev, func, mem_base, mem_limit);
 		}
 	}
@@ -2360,7 +2362,8 @@ add_reg_props(dev_info_t *dip, uchar_t bus, uchar_t dev, uchar_t func,
 {
 	uchar_t baseclass, subclass, progclass, header;
 	ushort_t bar_sz;
-	uint_t value = 0, len, devloc;
+	uint64_t value = 0;
+	uint_t devloc;
 	uint_t base, base_hi, type;
 	ushort_t offset, end;
 	int max_basereg, j, reprogram = 0;
@@ -2444,6 +2447,7 @@ add_reg_props(dev_info_t *dip, uchar_t bus, uchar_t dev, uchar_t func,
 		/* construct phys hi,med.lo, size hi, lo */
 		if ((pciide && j < 4) || (base & PCI_BASE_SPACE_IO)) {
 			int hard_decode = 0;
+			uint_t len;
 
 			/* i/o space */
 			bar_sz = PCI_BAR_SZ_32;
@@ -2528,26 +2532,33 @@ add_reg_props(dev_info_t *dip, uchar_t bus, uchar_t dev, uchar_t func,
 			nreg++, nasgn++;
 
 		} else {
+			uint64_t len;
 			/* memory space */
 			if ((base & PCI_BASE_TYPE_M) == PCI_BASE_TYPE_ALL) {
 				bar_sz = PCI_BAR_SZ_64;
 				base_hi = pci_getl(bus, dev, func, offset + 4);
+				pci_putl(bus, dev, func, offset + 4, 0xffffffff);
+				value |= (uint64_t)pci_getl(bus, dev, func,
+				    offset + 4) << 32;
+				pci_putl(bus, dev, func, offset + 4, base_hi);
 				phys_hi = PCI_ADDR_MEM64;
+				value &= PCI_BASE_M_ADDR64_M;
 			} else {
 				bar_sz = PCI_BAR_SZ_32;
 				base_hi = 0;
 				phys_hi = PCI_ADDR_MEM32;
+				value &= PCI_BASE_M_ADDR_M;
 			}
 
 			/* skip base regs with size of 0 */
-			value &= PCI_BASE_M_ADDR_M;
-
 			if (value == 0)
 				continue;
 
 			len = ((value ^ (value-1)) + 1) >> 1;
 			regs[nreg].pci_size_low =
-			    assigned[nasgn].pci_size_low = len;
+			    assigned[nasgn].pci_size_low = len & 0xffffffff;
+			regs[nreg].pci_size_hi =
+			    assigned[nasgn].pci_size_hi = len >> 32;
 
 			phys_hi |= (devloc | offset);
 			if (base & PCI_BASE_PREF_M)
@@ -2644,7 +2655,7 @@ add_reg_props(dev_info_t *dip, uchar_t bus, uchar_t dev, uchar_t func,
 				} else
 					cmn_err(CE_WARN, "failed to program "
 					    "mem space [%d/%d/%d] BAR@0x%x"
-					    " length 0x%x",
+					    " length 0x%"PRIx64,
 					    bus, dev, func, offset, len);
 			}
 			assigned[nasgn].pci_phys_low = base;
@@ -2677,6 +2688,8 @@ add_reg_props(dev_info_t *dip, uchar_t bus, uchar_t dev, uchar_t func,
 		value = 0;
 
 	if (value != 0) {
+		uint_t len;
+
 		regs[nreg].pci_phys_hi = (PCI_ADDR_MEM32 | devloc) + offset;
 		assigned[nasgn].pci_phys_hi = (PCI_RELOCAT_B |
 		    PCI_ADDR_MEM32 | devloc) + offset;
diff --git a/usr/src/uts/intel/io/pci/pci_pci.c b/usr/src/uts/intel/io/pci/pci_pci.c
index 9f0ed4d67f..5d781e40b6 100644
--- a/usr/src/uts/intel/io/pci/pci_pci.c
+++ b/usr/src/uts/intel/io/pci/pci_pci.c
@@ -561,12 +561,21 @@ ppb_ctlops(dev_info_t *dip, dev_info_t *rdip,
 	if (ctlop == DDI_CTLOPS_NREGS)
 		*(int *)result = totreg;
 	else if (ctlop == DDI_CTLOPS_REGSIZE) {
+		uint64_t rs;
+
 		rn = *(int *)arg;
 		if (rn >= totreg) {
 			kmem_free(drv_regp, reglen);
 			return (DDI_FAILURE);
 		}
-		*(off_t *)result = drv_regp[rn].pci_size_low;
+
+		rs = drv_regp[rn].pci_size_low |
+		    ((uint64_t)drv_regp[rn].pci_size_hi << 32);
+		if (rs > OFF_MAX) {
+			kmem_free(drv_regp, reglen);
+			return (DDI_FAILURE);
+		}
+		*(off_t *)result = rs;
 	}
 
 	kmem_free(drv_regp, reglen);
diff --git a/usr/src/uts/sun4/os/startup.c b/usr/src/uts/sun4/os/startup.c
index 7cc7074c10..6ebb07412f 100644
--- a/usr/src/uts/sun4/os/startup.c
+++ b/usr/src/uts/sun4/os/startup.c
@@ -22,6 +22,7 @@
 /*
  * Copyright (c) 2003, 2010, Oracle and/or its affiliates. All rights reserved.
  * Copyright (c) 2016 by Delphix. All rights reserved.
+ * Copyright 2018 Joyent, Inc.
  */
 
 #include <sys/machsystm.h>
@@ -2054,7 +2055,7 @@ startup_vm(void)
 
 		(void) seg_attach(&kas, segzio_base, mmu_ptob(segziosize),
 		    &kzioseg);
-		(void) segkmem_zio_create(&kzioseg);
+		(void) segkmem_create(&kzioseg);
 
 		/* create zio area covering new segment */
 		segkmem_zio_init(segzio_base, mmu_ptob(segziosize));
@@ -2438,7 +2439,7 @@ memlist_new(uint64_t start, uint64_t len, struct memlist **memlistp)
  */
 static void
 memlist_add(uint64_t start, uint64_t len, struct memlist **memlistp,
-	struct memlist **curmemlistp)
+    struct memlist **curmemlistp)
 {
 	struct memlist *new = *memlistp;
 
-- 
2.21.0

