From b3aa3b0c58a5e64d611f985c8926c2006f8daeb9 Mon Sep 17 00:00:00 2001
From: Trent Mick <trentm@gmail.com>
Date: Mon, 3 Apr 2017 09:55:04 -0700
Subject: [PATCH] joyent/node-triton#195 test *kvm* image creation

---
 test/config.json.sample                       |  10 +
 test/integration/cli-image-create-kvm.test.js | 211 ++++++++++++++++++
 test/integration/helpers.js                   |  75 +++++++
 3 files changed, 296 insertions(+)
 create mode 100644 test/integration/cli-image-create-kvm.test.js

diff --git a/test/config.json.sample b/test/config.json.sample
index 8768ff9..8cfeb8e 100644
--- a/test/config.json.sample
+++ b/test/config.json.sample
@@ -22,9 +22,19 @@
     // to true.
     "skipAffinityTests": false,
 
+    // Optional. Set to 'true' to skip testing of KVM things. Some DCs might
+    // not support KVM (no KVM packages or images available).
+    "skipKvmTests": false,
+
     // The params used for test provisions. By default the tests use:
     // the smallest RAM package, the latest base* image.
     "package": "<package name or uuid>",
     "resizePackage": "<package name>",
     "image": "<image uuid, name or name@version>"
+
+    // The params used for test *KVM* provisions. By default the tests use:
+    // the smallest RAM package with "kvm" in the name, the latest
+    // ubuntu-certified image.
+    "kvmPackage": "<package name or uuid>",
+    "kvmImage": "<image uuid, name or name@version>"
 }
diff --git a/test/integration/cli-image-create-kvm.test.js b/test/integration/cli-image-create-kvm.test.js
new file mode 100644
index 0000000..00493cc
--- /dev/null
+++ b/test/integration/cli-image-create-kvm.test.js
@@ -0,0 +1,211 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright 2016, Joyent, Inc.
+ */
+
+/*
+ * Test image commands.
+ */
+
+var format = require('util').format;
+var os = require('os');
+var test = require('tape');
+var vasync = require('vasync');
+
+var common = require('../../lib/common');
+var h = require('./helpers');
+
+
+// --- globals
+
+var _namePrefix = 'nodetritontest-image-create-kvm-' + os.hostname();
+var ORIGIN_ALIAS = _namePrefix + '-origin';
+var IMAGE_DATA = {
+    name: _namePrefix + '-image',
+    version: '1.0.0'
+};
+var DERIVED_ALIAS = _namePrefix + '-derived';
+
+var testOpts = {
+    skip: !h.CONFIG.allowWriteActions || h.CONFIG.skipKvmTests
+};
+
+
+// --- Tests
+
+test('triton image ...', testOpts, function (tt) {
+    var imgNameVer = IMAGE_DATA.name + '@' + IMAGE_DATA.version;
+    var originInst;
+    var img;
+
+    tt.comment('Test config:');
+    Object.keys(h.CONFIG).forEach(function (key) {
+        var value = h.CONFIG[key];
+        tt.comment(format('- %s: %j', key, value));
+    });
+
+    // TODO: `triton rm -f` would be helpful for this
+    tt.test('  setup: rm existing origin inst ' + ORIGIN_ALIAS, function (t) {
+        h.triton(['inst', 'get', '-j', ORIGIN_ALIAS],
+                function (err, stdout, stderr) {
+            if (err) {
+                if (err.code === 3) {  // `triton` code for ResourceNotFound
+                    t.ok(true, 'no pre-existing inst ' + ORIGIN_ALIAS);
+                    t.end();
+                } else {
+                    t.ifErr(err, err);
+                    t.end();
+                }
+            } else {
+                var instToRm = JSON.parse(stdout);
+                h.safeTriton(t, ['inst', 'rm', '-w', instToRm.id], function () {
+                    t.ok(true, 'deleted inst ' + instToRm.id);
+                    t.end();
+                });
+            }
+        });
+    });
+
+    // TODO: `triton rm -f` would be helpful for this
+    tt.test('  setup: rm existing derived inst ' + DERIVED_ALIAS, function (t) {
+        h.triton(['inst', 'get', '-j', DERIVED_ALIAS],
+                function (err, stdout, stderr) {
+            if (err) {
+                if (err.code === 3) {  // `triton` code for ResourceNotFound
+                    t.ok(true, 'no pre-existing inst ' + DERIVED_ALIAS);
+                    t.end();
+                } else {
+                    t.ifErr(err, err);
+                    t.end();
+                }
+            } else {
+                var instToRm = JSON.parse(stdout);
+                h.safeTriton(t, ['inst', 'rm', '-w', instToRm.id], function () {
+                    t.ok(true, 'deleted inst ' + instToRm.id);
+                    t.end();
+                });
+            }
+        });
+    });
+
+    tt.test('  setup: rm existing img ' + imgNameVer, function (t) {
+        h.triton(['img', 'get', '-j', imgNameVer],
+                function (err, stdout, stderr) {
+            if (err) {
+                if (err.code === 3) {  // `triton` code for ResourceNotFound
+                    t.ok(true, 'no pre-existing img ' + imgNameVer);
+                    t.end();
+                } else {
+                    t.ifErr(err, err);
+                    t.end();
+                }
+            } else {
+                var imgToRm = JSON.parse(stdout);
+                h.safeTriton(t, ['image', 'rm', '-f', imgToRm.id], function () {
+                    t.ok(true, 'deleted img ' + imgToRm.id);
+                    t.end();
+                });
+            }
+        });
+    });
+
+    var originImgNameOrId;
+    tt.test('  setup: find origin image', function (t) {
+        h.getTestKvmImg(t, function (err, imgId) {
+            t.ifError(err, 'getTestImg' + (err ? ': ' + err : ''));
+            originImgNameOrId = imgId;
+            t.end();
+        });
+    });
+
+    var pkgId;
+    tt.test('  setup: find test package', function (t) {
+        h.getTestKvmPkg(t, function (err, pkgId_) {
+            t.ifError(err, 'getTestPkg' + (err ? ': ' + err : ''));
+            pkgId = pkgId_;
+            t.end();
+        });
+    });
+
+    var markerFile = '/nodetritontest-was-here.txt';
+    tt.test('  setup: triton create ... -n ' + ORIGIN_ALIAS, function (t) {
+        var argv = ['create', '-wj', '-n', ORIGIN_ALIAS,
+            '-m', 'user-script=touch ' + markerFile,
+            originImgNameOrId, pkgId];
+        h.safeTriton(t, argv, function (err, stdout) {
+            var lines = h.jsonStreamParse(stdout);
+            originInst = lines[1];
+            t.ok(originInst.id, 'originInst.id: ' + originInst.id);
+            t.equal(lines[1].state, 'running', 'originInst is running');
+            t.end();
+        });
+    });
+
+    // TODO: I'd like to use this 'triton ssh INST touch $markerFile' to
+    //      tweak the image. However, that current hangs when run via
+    //      tape (don't know why yet). Instead we'll use a user-script to
+    //      change the origin as our image change.
+    //
+    //tt.test('  setup: add marker to origin', function (t) {
+    //    var argv = ['ssh', originInst.id,
+    //        '-o', 'StrictHostKeyChecking=no',
+    //        '-o', 'UserKnownHostsFile=/dev/null',
+    //        'touch', markerFile];
+    //    h.safeTriton(t, argv, function (err, stdout) {
+    //        t.ifError(err, 'adding origin marker file, err=' + err);
+    //        t.end();
+    //    });
+    //});
+
+    tt.test('  triton image create ...', function (t) {
+        var argv = ['image', 'create', '-j', '-w', '-t', 'foo=bar',
+            originInst.id, IMAGE_DATA.name, IMAGE_DATA.version];
+        h.safeTriton(t, argv, function (err, stdout) {
+            var lines = h.jsonStreamParse(stdout);
+            img = lines[1];
+            t.ok(img, 'created image, id=' + img.id);
+            t.equal(img.name, IMAGE_DATA.name, 'img.name');
+            t.equal(img.version, IMAGE_DATA.version, 'img.version');
+            t.equal(img.public, false, 'img.public is false');
+            t.equal(img.state, 'active', 'img.state is active');
+            t.equal(img.origin, originInst.image, 'img.origin');
+            t.end();
+        });
+    });
+
+    var derivedInst;
+    tt.test('  triton create ... -n ' + DERIVED_ALIAS, function (t) {
+        var argv = ['create', '-wj', '-n', DERIVED_ALIAS, img.id, pkgId];
+        h.safeTriton(t, argv, function (err, stdout) {
+            var lines = h.jsonStreamParse(stdout);
+            derivedInst = lines[1];
+            t.ok(derivedInst.id, 'derivedInst.id: ' + derivedInst.id);
+            t.equal(lines[1].state, 'running', 'derivedInst is running');
+            t.end();
+        });
+    });
+
+    // TODO: Once have `triton ssh ...` working in test suite without hangs,
+    //      then want to check that the created VM has the markerFile.
+
+    // Remove instances. Add a test timeout, because '-w' on delete doesn't
+    // have a way to know if the attempt failed or if it is just taking a
+    // really long time.
+    tt.test('  cleanup: triton rm', {timeout: 10 * 60 * 1000}, function (t) {
+        h.safeTriton(t, ['rm', '-w', originInst.id, derivedInst.id],
+                function () {
+            t.end();
+        });
+    });
+
+    tt.test('  cleanup: triton image rm', function (t) {
+        h.safeTriton(t, ['image', 'rm', '-f', img.id], function () {
+            t.end();
+        });
+    });
+});
diff --git a/test/integration/helpers.js b/test/integration/helpers.js
index 8a573a6..48aca0c 100644
--- a/test/integration/helpers.js
+++ b/test/integration/helpers.js
@@ -206,6 +206,46 @@ function getTestImg(t, cb) {
 }
 
 
+/*
+ * Find and return an image that can be used for test *KVM* provisions.
+ *
+ * @param {Tape} t - tape test object
+ * @param {Function} cb - `function (err, imgId)`
+ *      where `imgId` is an image identifier (an image name, shortid, or id).
+ */
+function getTestKvmImg(t, cb) {
+    if (CONFIG.kvmImage) {
+        t.ok(CONFIG.kvmImage, 'kvmImage from config: ' + CONFIG.kvmImage);
+        cb(null, CONFIG.kvmImage);
+        return;
+    }
+
+    var candidateImageNames = {
+        'ubuntu-certified-16.04': true
+    };
+    safeTriton(t, ['img', 'ls', '-j'], function (err, stdout) {
+        var imgId;
+        var imgs = jsonStreamParse(stdout);
+        // Newest images first.
+        tabula.sortArrayOfObjects(imgs, ['-published_at']);
+        var imgRepr;
+        for (var i = 0; i < imgs.length; i++) {
+            var img = imgs[i];
+            if (candidateImageNames[img.name]) {
+                imgId = img.id;
+                imgRepr = f('%s@%s', img.name, img.version);
+                break;
+            }
+        }
+
+        t.ok(imgId,
+            f('latest KVM image (using subset of supported names): %s (%s)',
+            imgId, imgRepr));
+        cb(err, imgId);
+    });
+}
+
+
 /*
  * Find and return an package that can be used for test provisions.
  *
@@ -222,6 +262,10 @@ function getTestPkg(t, cb) {
 
     safeTriton(t, ['pkg', 'ls', '-j'], function (err, stdout) {
         var pkgs = jsonStreamParse(stdout);
+        // Filter out those with 'kvm' in the name.
+        pkgs = pkgs.filter(function (pkg) {
+            return pkg.name.indexOf('kvm') == -1;
+        });
         // Smallest RAM first.
         tabula.sortArrayOfObjects(pkgs, ['memory']);
         var pkgId = pkgs[0].id;
@@ -231,6 +275,35 @@ function getTestPkg(t, cb) {
     });
 }
 
+/*
+ * Find and return an package that can be used for *KVM* test provisions.
+ *
+ * @param {Tape} t - tape test object
+ * @param {Function} cb - `function (err, pkgId)`
+ *      where `pkgId` is an package identifier (a name, shortid, or id).
+ */
+function getTestKvmPkg(t, cb) {
+    if (CONFIG.kvmPackage) {
+        t.ok(CONFIG.kvmPackage, 'kvmPackage from config: ' + CONFIG.kvmPackage);
+        cb(null, CONFIG.kvmPackage);
+        return;
+    }
+
+    safeTriton(t, ['pkg', 'ls', '-j'], function (err, stdout) {
+        var pkgs = jsonStreamParse(stdout);
+        // Filter on those with 'kvm' in the name.
+        pkgs = pkgs.filter(function (pkg) {
+            return pkg.name.indexOf('kvm') !== -1;
+        });
+        // Smallest RAM first.
+        tabula.sortArrayOfObjects(pkgs, ['memory']);
+        var pkgId = pkgs[0].id;
+        t.ok(pkgId, f('smallest (RAM) available KVM package: %s (%s)',
+            pkgId, pkgs[0].name));
+        cb(null, pkgId);
+    });
+}
+
 /*
  * Find and return second smallest package name that can be used for
  * test provisions.
@@ -370,7 +443,9 @@ module.exports = {
     createTestInst: createTestInst,
     deleteTestInst: deleteTestInst,
     getTestImg: getTestImg,
+    getTestKvmImg: getTestKvmImg,
     getTestPkg: getTestPkg,
+    getTestKvmPkg: getTestKvmPkg,
     getResizeTestPkg: getResizeTestPkg,
     jsonStreamParse: jsonStreamParse,
     printConfig: printConfig,
-- 
2.21.0

