From 4947bc2af1341507d6ea13ea8c9744a81d1cd9f6 Mon Sep 17 00:00:00 2001
From: Tim Foster <tim.foster@joyent.com>
Date: Thu, 19 Sep 2019 09:28:18 +0100
Subject: [PATCH] MANTA-2769 manta-init should be channel aware MANTA-4159
 manta-init should have an option to specify an image version substring
 MANTA-3674 manta-adm should have a channel guard

---
 cmd/manta-adm.js            |  18 ++++++
 cmd/manta-init.js           |  75 +++++++++++++++++++---
 docs/man/man1/manta-adm.md  |  10 ++-
 docs/man/man1/manta-init.md |  18 +++++-
 lib/adm.js                  | 124 ++++++++++++++++++++++++++++++++++++
 lib/common.js               |  41 ++++++++++++
 6 files changed, 272 insertions(+), 14 deletions(-)

diff --git a/cmd/manta-adm.js b/cmd/manta-adm.js
index 98a9db3..aa613a4 100755
--- a/cmd/manta-adm.js
+++ b/cmd/manta-adm.js
@@ -876,6 +876,12 @@ MantaAdm.prototype.do_update = function (subcmd, opts, args, callback)
 		function fetchDeployed(_, stepcb) {
 			adm.fetchDeployed(stepcb);
 		},
+		function determineDefaultChannel(_, stepcb) {
+			if (opts.skip_verify_channel) {
+				return (stepcb());
+			}
+			adm.determineSdcChannel(stepcb);
+		},
 		function generatePlan(_, stepcb) {
 			adm.generatePlan({
 				service: service,
@@ -883,6 +889,11 @@ MantaAdm.prototype.do_update = function (subcmd, opts, args, callback)
 				experimental: opts.experimental
 			}, stepcb);
 		},
+		function verifyPlan(_, stepcb) {
+			adm.verifyPlan(
+			    {skip_verify_channel: opts.skip_verify_channel},
+			    stepcb);
+		},
 		function dumpPlan(_, stepcb) {
 			adm.execPlan(process.stdout, process.stderr,
 			    true, function (err, count) {
@@ -954,6 +965,13 @@ MantaAdm.prototype.do_update.options = [
     'names': [ 'experimental', 'X' ],
     'type':  'bool',
     'help': 'Allow deployment of experimental services'
+},
+{
+	'names': [ 'skip-verify-channel' ],
+	'type': 'bool',
+	'help': 'When provisioning an image, avoid verifying its channel ' +
+	'the default update channel for this datacenter',
+	'default': false
 } ];
 
 MantaAdm.prototype.do_zk = MantaAdmZk;
diff --git a/cmd/manta-init.js b/cmd/manta-init.js
index d6bd7cf..9f1f893 100755
--- a/cmd/manta-init.js
+++ b/cmd/manta-init.js
@@ -7,7 +7,7 @@
  */
 
 /*
- * Copyright (c) 2019, Joyent, Inc.
+ * Copyright 2019 Joyent, Inc.
  */
 
 /*
@@ -53,6 +53,15 @@ var CONCURRENCY = 10;
 optimist.usage('Usage:\tmanta-init -e <email>');
 
 var ARGV = optimist.options({
+	'B': {
+		alias: 'branch',
+		describe: 'the branch substring to use when looking for images',
+		default: ''
+	},
+	'C': {
+		alias: 'channel',
+		describe: 'the channel to use'
+	},
 	'c': {
 		alias: 'concurrent_downloads',
 		describe: 'number of concurrent image downloads (default: 10)'
@@ -217,17 +226,24 @@ function findLatestImage(service, cb) {
 	var log = self.log;
 
 	var image_name = services.serviceNameToImageName(service);
-	var version_substr = 'master';
+	var version_substr = ARGV.branch;
+	var channel = ARGV.channel;
 
-	log.info('finding image %s (version substr "%s") for service %s',
-	    image_name, version_substr, service);
+	log.info('finding image %s for service %s on channel "%s"',
+	    image_name, service, channel);
 
 	var onSearchFinish = function (err, image) {
 		if (err) {
 			log.error(err);
 			return (cb(err));
 		}
-
+		if (image === undefined) {
+			var msg = sprintf(
+			    'Unable to find image %s for %s on channel "%s"',
+			    image_name, service, channel);
+			log.error(msg);
+			return (cb(new Error(msg)));
+		}
 		log.info({ image: image }, 'found image %s for %s',
 		    image_name, service);
 
@@ -236,7 +252,7 @@ function findLatestImage(service, cb) {
 
 	/*
 	 * If -n is used, find the most recent image which is installed in
-	 * this datacenter's IMGAPI.
+	 * this datacenter's IMGAPI, assuming it matches our version_substr.
 	 */
 	if (ARGV.n) {
 		return (findLatestLocalImage(
@@ -245,7 +261,14 @@ function findLatestImage(service, cb) {
 
 	var filters = {};
 	filters.name = image_name;
-	filters.version = '~' + version_substr;
+	if (version_substr.length > 0) {
+		log.info('search restricted to version substring: %s',
+		    version_substr);
+		filters.version = '~' + version_substr;
+	}
+	if (channel.length > 0) {
+		filters.channel = channel;
+	}
 	log.info({ filters: filters }, 'search for images');
 
 	remote_imgapi.listImages(filters, function (err, images) {
@@ -263,12 +286,15 @@ function findLatestLocalImage(image_name, version_substr, cb) {
 	var imgapi = self.IMGAPI;
 	var log = self.log;
 
-	log.info('search for image %s (version substr "%s") restricted ' +
-	    'to local images', image_name, version_substr);
+	log.info('search for image %s restricted to local images', image_name);
 
 	var filters = {};
 	filters.name = image_name;
-	filters.version = '~' + version_substr;
+	if (version_substr.length > 0) {
+		log.info('search restricted to version substring: %s',
+		    version_substr);
+		filters.version = '~' + version_substr;
+	}
 
 	imgapi.listImages(filters, function (err, images) {
 		if (err) {
@@ -396,6 +422,15 @@ if (typeof (ARGV.c) == 'number' && ARGV.c > 0 && ARGV.c < 128 &&
 	usage('unsupported value for "-c" option ' +
 	    '(must be a positive integer less than 128)');
 }
+// let the user pass an empty string to indicate they do not want
+// version-filtering or do not want to restrict the image search
+// to any given channel.
+if (typeof (ARGV.branch) === 'boolean') {
+	ARGV.branch = '';
+}
+if (typeof (ARGV.channel) === 'boolean') {
+	ARGV.channel = '';
+}
 
 var pipelineFuncs = [
 	function verifyArgs(_, cb) {
@@ -698,6 +733,26 @@ var pipelineFuncs = [
 		});
 	},
 
+	function determineDefaultChannel(_, cb) {
+		var log = self.log;
+		// If the user passed a -C argument, then we're done
+		if (ARGV.channel !== undefined) {
+			return (cb(null));
+		}
+
+		log.info('determining update_channel from sapi');
+		common.getSdcChannel.call(self,
+			{}, function (err, channel) {
+			if (!err) {
+				ARGV.channel = channel;
+				return (cb(null));
+			}
+			log.error(
+			    err, 'failed to determine sdc update_channel');
+			return (cb(err));
+		});
+	},
+
 	function findLatestImages(ctx, cb) {
 		var log = self.log;
 
diff --git a/docs/man/man1/manta-adm.md b/docs/man/man1/manta-adm.md
index 5cf829d..080b82c 100644
--- a/docs/man/man1/manta-adm.md
+++ b/docs/man/man1/manta-adm.md
@@ -20,7 +20,7 @@ manta-adm - administer a Manta deployment
 
 `manta-adm show [-l LOG_FILE] [-js] SERVICE`
 
-`manta-adm update [-l LOG_FILE] [-n] [-y] [--no-reprovision] FILE [SERVICE]`
+`manta-adm update [-l LOG_FILE] [-n] [-y] [--no-reprovision] [--skip-verify-channel] FILE [SERVICE]`
 
 `manta-adm zk list [-l LOG_FILE] [-H] [-o FIELD...]`
 
@@ -790,6 +790,12 @@ options described above, plus:
   When upgrading a zone, always provision a new zone and deprovision the
   previous one, rather than reprovisioning the existing one.
 
+`--skip-verify-channel`
+  When upgrading, do not verify that the images being provisioned or
+  reprovisioned are present on the "remote" (usually https://updates.joyent.com)
+  imgapi channel that was set on the headnode using the `sdcadm channel`
+  command.
+
 If `SERVICE` is specified, then only instances of the named service are
 changed.
 
@@ -900,7 +906,7 @@ and `-y/--confirm` options described above.
 
 ## COPYRIGHT
 
-Copyright (c) 2019, Joyent Inc.
+Copyright 2019 Joyent, Inc.
 
 ## SEE ALSO
 
diff --git a/docs/man/man1/manta-init.md b/docs/man/man1/manta-init.md
index 82f82e9..8c31421 100644
--- a/docs/man/man1/manta-init.md
+++ b/docs/man/man1/manta-init.md
@@ -1,4 +1,4 @@
-# MANTA-INIT 1 "2016" Manta "Manta Operator Commands"
+# MANTA-INIT 1 "2019" Manta "Manta Operator Commands"
 
 ## NAME
 
@@ -24,6 +24,20 @@ run this command except as documented in the Manta Operator's Guide.**
 
 ## OPTIONS
 
+`-B, --branch BRANCH`
+  Specifies a substring which must be present in the version string of the
+  images to be downloaded. The default for this value is the empty string,
+  which means that the latest images on the given channel are used, regardless
+  of their branch.
+
+`-C, --channel CHANNEL`
+  Specifies the updates.joyent.com channel from which images should be
+  downloaded unless `-n` is used. By default, this value is set to the current
+  value of `update_channel` in this data-center, obtained from the `sdc`
+  application in SAPI. Use the `sdcadm channel` command to view or change
+  the default value. Using an empty string as the argument will cause
+  manta-init to search for images on any channel.
+
 `-c, --concurrent_downloads N`
   Specifies that no more than `N` zone images should be downloaded
   concurrently.
@@ -71,7 +85,7 @@ Non-zero
 
 ## COPYRIGHT
 
-Copyright (c) 2016 Joyent Inc.
+Copyright 2019 Joyent, Inc.
 
 ## SEE ALSO
 
diff --git a/lib/adm.js b/lib/adm.js
index 567ae56..97a5230 100644
--- a/lib/adm.js
+++ b/lib/adm.js
@@ -529,6 +529,11 @@ function maAdm(log)
 	 */
 	this.ma_gzinfo = null;
 
+	/*
+	 * The default image update channel configured for the datacenter.
+	 */
+	this.ma_channel = null;
+
 	/* Update information */
 	this.ma_plan = null;
 	this.ma_instances_wanted = null;
@@ -3864,6 +3869,25 @@ maAdm.prototype.readInstanceMetadataConfigRaw = function (contents)
 	return (null);
 };
 
+maAdm.prototype.determineSdcChannel = function (cb)
+{
+	var self = this;
+	var opts = {
+	    'sapi': self.ma_sdc.SAPI,
+	    'log': self.ma_log
+	};
+	common.getSdcChannel(opts, function (err, channel) {
+		if (err) {
+			self.ma_log.info('Unable to determine channel' + err);
+			cb(new VError(err));
+			return;
+		}
+		self.ma_channel = channel;
+		self.ma_log.info('SDC update channel is ' + self.ma_channel);
+		cb();
+	});
+};
+
 /*
  * Assuming we've already loaded the current deployed configuration and the
  * user-specified configuration, generate a plan to make reality match what the
@@ -4097,6 +4121,106 @@ maAdm.prototype.generatePlan = function (opts, callback)
 	setTimeout(callback, 0);
 };
 
+/*
+ * Determine whether the plan that was generated adheres to any restrictions
+ * that are in place.
+ * For now the only check implemented is to ensure that all images for
+ * deployment are available on the specific imgapi channel set by
+ * 'sdcadm channel set' on the 'remote_imgapi' set in etc/config.json.
+ *
+ * Options:
+ * - skip_verify_channel: if true, we avoid verifying that each image to be
+ *   provisioned is present on the defined SDC updates.joyent.com channel.
+ */
+maAdm.prototype.verifyPlan = function (opts, cb)
+{
+	assert.ok(this.ma_plan !== null);
+	assertplus.object(opts, 'opts');
+	assertplus.func(cb, 'cb');
+	assertplus.bool(opts.skip_verify_channel, 'opts.skip_verify_channel');
+
+	var self = this;
+
+	if (opts.skip_verify_channel) {
+		return (cb());
+	}
+	/*
+	 * If we're doing channel verification, go through our plan,
+	 * checking that each new image exists on that channel. To do this,
+	 * find the set of new image uuids per-service across all compute nodes
+	 * in the plan.
+	 */
+	// We don't have a Set() object, so instead use unique Object keys
+	var services_by_image = {};
+	for (var svcname in this.ma_plan) {
+		for (var cnid in this.ma_plan[svcname]) {
+			for (var i = 0;
+				    i < this.ma_plan[svcname][cnid].length;
+				    i++) {
+				var plan_op = this.ma_plan[svcname][cnid][i];
+				var new_image = null;
+				if (plan_op.action === 'provision') {
+					new_image = plan_op.IMAGE;
+				} else if (plan_op.action === 'reprovision') {
+					new_image = plan_op.new_image;
+				}
+				if (new_image) {
+					services_by_image[new_image] = svcname;
+				}
+			}
+		}
+	}
+
+	var imgapi_opts = {'channel': self.ma_channel};
+
+	// An array of strings, later used to form an error message.
+	var imagesNotInTheChannel = [];
+	// process each of the images in series
+    vasync.forEachParallel({
+	    inputs: Object.keys(services_by_image),
+	    func: function channelCheckOneImage(imageUuid, nextImage) {
+			self.ma_log.debug(
+			    sprintf(
+					'looking up image %s for service %s ' +
+					'on channel %s',
+					imageUuid, services_by_image[imageUuid],
+					self.ma_channel));
+			self.ma_sdc.REMOTE_IMGAPI.getImage(
+				imageUuid, imgapi_opts,
+			    function getImage(err, image) {
+				if (err) {
+					// note that we don't invoke the
+					// err callback since vasync will
+					// then report only
+					// 'the first of n errors'
+					var missing = sprintf('%s (%s)',
+					    imageUuid,
+					    services_by_image[imageUuid]);
+					self.ma_log.debug(
+					    'missing image ' + missing);
+					imagesNotInTheChannel.push(missing);
+					nextImage();
+				} else {
+					nextImage();
+				}
+			});
+		}
+	}, function finish(err) {
+		if (err) {
+			cb(err);
+		} else if (imagesNotInTheChannel.length > 0) {
+			cb(new VError(
+				'The following images were not found on ' +
+				'the \'' + self.ma_channel + '\' channel ' +
+				'and cannot be provisioned. ' +
+				'(Use --skip-verify-channel to override): ' +
+				imagesNotInTheChannel.join(', ')));
+		} else {
+			cb();
+		}
+	});
+};
+
 /*
  * [internal] Add a deployment step to the current execution plan.
  */
diff --git a/lib/common.js b/lib/common.js
index a2659ea..6a2c0bf 100644
--- a/lib/common.js
+++ b/lib/common.js
@@ -937,6 +937,46 @@ function getServerNicTags(cb) {
 	});
 }
 
+/*
+ * Query SAPI for the current update_channel. The callback function takes
+ * the form function(err, update_channel)
+ * This function can have a SAPI and bunyan log object passed as options,
+ * or will fallback to objects initialized by initSdcClients and self.log
+ * if those are not provided.
+ */
+function getSdcChannel(opts, cb) {
+	assert.object(opts, 'opts');
+	assert.optionalObject(opts.sapi, 'opts.sapi');
+	assert.optionalObject(opts.log, 'opts.log');
+	assert.func(cb, 'cb');
+
+	var sapi = opts.sapi;
+	var log = opts.log;
+	if (opts.sapi === undefined) {
+		sapi = this.SAPI;
+	}
+	if (opts.log === undefined) {
+		log = this.log;
+	}
+
+	var search = {};
+	search.name = 'sdc';
+	search.include_master = true;
+
+	sapi.listApplications(search, function (err, apps) {
+		if (err) {
+			log.error(err, 'failed to list applications');
+			return (cb(err));
+		}
+
+		log.debug('found sdc application');
+		assert.ok(apps.length <= 1);
+		assert.string(apps[0].metadata.update_channel);
+
+		return (cb(null, apps[0].metadata.update_channel));
+	});
+}
+
 exports.shuffle = shuffle;
 exports.domainToPath = domainToPath;
 exports.initSdcClients = initSdcClients;
@@ -953,3 +993,4 @@ exports.sortObjectsByProps = sortObjectsByProps;
 exports.fmtDuration = fmtDuration;
 exports.updateNetworkUsers = updateNetworkUsers;
 exports.getServerNicTags = getServerNicTags;
+exports.getSdcChannel = getSdcChannel;
-- 
2.21.0

