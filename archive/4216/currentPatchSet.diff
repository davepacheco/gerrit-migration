commit 67804a75480f1175111d5e5c0af21455c18c5b8c (refs/changes/16/4216/1)
Author: Jason King <jason.king@joyent.com>
Date:   2018-06-14T11:25:00-05:00 (1 year, 4 months ago)
    
    add drop probes

diff --git a/usr/src/uts/common/io/overlay/overlay_target.c b/usr/src/uts/common/io/overlay/overlay_target.c
index a368cb0d82..973aa77187 100644
--- a/usr/src/uts/common/io/overlay/overlay_target.c
+++ b/usr/src/uts/common/io/overlay/overlay_target.c
@@ -44,6 +44,9 @@
 #include <sys/overlay_impl.h>
 #include <sys/sdt.h>
 
+#define	OVERLAY_DROP(mp, reason) \
+    DTRACE_PROBE2(overlay__drop, mblk_t *, mp, char *, reason)
+
 /*
  * This is total straw man, but at least it's a prime number. Here we're
  * going to have to go through and do a lot of evaluation and understanding as
@@ -506,8 +509,10 @@ overlay_route(overlay_dev_t *odd, mblk_t *mp,
 		 * If this is relaxed in the future, we will need to allow for
 		 * insertion and removal of the vlan tag as appropriate here.
 		 */
-		if (ntohs(evh->ether_tpid) != ETHERTYPE_VLAN)
+		if (ntohs(evh->ether_tpid) != ETHERTYPE_VLAN) {
+			OVERLAY_DROP(mp, "not vlan tagged");
 			return (OVERLAY_TARGET_DROP);
+		}
 
 		tci &= ~(VLAN_ID_MASK);
 		tci |= route->otr_vlan;
@@ -519,25 +524,33 @@ overlay_route(overlay_dev_t *odd, mblk_t *mp,
 
 #if 1
 	/* Temporary until mblk helpers are integrated */
+	OVERLAY_DROP(mp, "ethernet header split between mblks");
 	return (OVERLAY_TARGET_DROP);
 #else
 	size_t off;
 
 	off = offsetof(struct ether_vlan_header, ether_tpid);
-	if (!mblk_read_uint16(mp, off, &tci))
+	if (!mblk_read_uint16(mp, off, &tci)) {
+		OVERLAY_DROP(mp, "cannot read tpid");
 		return (OVERLAY_TARGET_DROP);
+	}
 
 	tci = ntohs(evh->ether_tci);
 	tci &= ~(VLAN_ID_MASK);
 	tci |= route->otr_vlan;
 
-	if (!mblk_write_uint16(mp, off, tci))
+	if (!mblk_write_uint16(mp, off, tci)) {
+		OVERLAY_DROP(mp, "cannot set routed destination vlan");
 		return (OVERLAY_TARGET_DROP);
+	}
 
 	for (int i = 0; i < ETHERADDRL; i++) {
 		if (!mblk_write_uint8(mp, i, dst_msc->otm_mac[i]) ||
-		    !mblk_write_uint8(mp, i + ETHERADDRL, route->otr_srcmac[i]))
+		    !mblk_write_uint8(mp, i + ETHERADDRL,
+		    route->otr_srcmac[i])) {
+			OVERLAY_DROP(mp, "cannot set routed macs");
 			return (OVERLAY_TARGET_DROP);
+		}
 	}
 
 	return (OVERLAY_TARGET_OK);
@@ -551,8 +564,10 @@ overlay_target_try_queue(overlay_target_entry_t *entry, mblk_t *mp)
 
 	ASSERT(MUTEX_HELD(&entry->ote_lock));
 
-	if (mlen + entry->ote_mbsize > overlay_ent_size)
+	if (mlen + entry->ote_mbsize > overlay_ent_size) {
+		OVERLAY_DROP(mp, "target queue full");
 		return (OVERLAY_TARGET_DROP);
+	}
 
 	if (entry->ote_ctail != NULL) {
 		ASSERT(entry->ote_ctail->b_next == NULL);
@@ -594,12 +609,20 @@ overlay_route_lookup_vl2(overlay_target_t *ott, overlay_target_entry_t *vl3e,
 
 	mutex_enter(&vl2e->ote_lock);
 	if (vl2e->ote_flags & (OVERLAY_ENTRY_F_DROP | OVERLAY_ENTRY_F_ROUTER)) {
+		overlay_target_entry_flags_t flags = vl2e->ote_flags;
+
 		mutex_exit(&vl2e->ote_lock);
 
 		mutex_enter(&ott->ott_lock);
 		sarc_rele(ott->ott_u.ott_dyn.ott_dhash, vl2e);
 		mutex_exit(&ott->ott_lock);
 
+		if (flags & OVERLAY_ENTRY_F_DROP) {
+			OVERLAY_DROP(mp, "VL2 target marked drop");
+		} else {
+			OVERLAY_DROP(mp, "VL2 target is overlay router");
+		}
+
 		return (OVERLAY_TARGET_DROP);
 	}
 
@@ -691,8 +714,10 @@ overlay_route_lookup(overlay_dev_t *odd, mblk_t *mp, uint16_t vlan,
 
 	vl3.otvl3_src_vlan = vlan;
 	if ((ret = overlay_get_vl3_ips(mp, &vl3.otvl3_src, &vl3.otvl3_dst))
-	    != OVERLAY_TARGET_OK)
+	    != OVERLAY_TARGET_OK) {
+		OVERLAY_DROP(mp, "could not read VL3 src/dst IPs");
 		return (OVERLAY_TARGET_DROP);
+	}
 
 	mutex_enter(&ott->ott_lock);
 	entry = sarc_lookup(ott->ott_u.ott_dyn.ott_l3dhash, &vl3);
@@ -700,6 +725,7 @@ overlay_route_lookup(overlay_dev_t *odd, mblk_t *mp, uint16_t vlan,
 		if ((entry = kmem_cache_alloc(overlay_entry_cache,
 		    KM_NOSLEEP | KM_NORMALPRI)) == NULL) {
 			mutex_exit(&ott->ott_lock);
+			OVERLAY_DROP(mp, "failed VL3 target entry allocation");
 			return (OVERLAY_TARGET_DROP);
 		}
 
@@ -726,12 +752,14 @@ overlay_route_lookup(overlay_dev_t *odd, mblk_t *mp, uint16_t vlan,
 	ASSERT(entry->ote_flags & OVERLAY_ENTRY_F_VL3);
 
 	if (entry->ote_flags & OVERLAY_ENTRY_F_DROP) {
+		OVERLAY_DROP(mp, "VL3 target entry marked drop");
 		ret = OVERLAY_TARGET_DROP;
 	} else if (entry->ote_flags & OVERLAY_ENTRY_F_ROUTER) {
 		/*
 		 * XXX: A packet with a dst IP of an overlay router.
 		 * Maybe generate an ICMP reply?  For now, we drop.
 		 */
+		OVERLAY_DROP(mp, "VL3 target entry is router");
 		ret = OVERLAY_TARGET_DROP;
 	} else if ((entry->ote_flags & OVERLAY_ENTRY_F_VALID) == 0) {
 		ret = overlay_target_try_queue(entry, mp);
@@ -774,8 +802,10 @@ overlay_target_lookup(overlay_dev_t *odd, mblk_t *mp, struct sockaddr *sock,
 	 * about synchronization for them.
 	 */
 	ott = odd->odd_target;
-	if (ott->ott_dest != (OVERLAY_PLUGIN_D_IP | OVERLAY_PLUGIN_D_PORT))
+	if (ott->ott_dest != (OVERLAY_PLUGIN_D_IP | OVERLAY_PLUGIN_D_PORT)) {
+		OVERLAY_DROP(mp, "plugin doesn't support IP or port");
 		return (OVERLAY_TARGET_DROP);
+	}
 
 	v6 = (struct sockaddr_in6 *)sock;
 	bzero(v6, sizeof (struct sockaddr_in6));
@@ -794,8 +824,10 @@ overlay_target_lookup(overlay_dev_t *odd, mblk_t *mp, struct sockaddr *sock,
 
 	ASSERT(ott->ott_mode == OVERLAY_TARGET_DYNAMIC);
 
-	if (mac_vlan_header_info(odd->odd_mh, mp, &mhi) != 0)
+	if (mac_vlan_header_info(odd->odd_mh, mp, &mhi) != 0) {
+		OVERLAY_DROP(mp, "could not read vlan header");
 		return (OVERLAY_TARGET_DROP);
+	}
 
 	omac.otm_dcid = odd->odd_dcid;
 	bcopy(mhi.mhi_daddr, omac.otm_mac, ETHERADDRL);
@@ -809,6 +841,7 @@ overlay_target_lookup(overlay_dev_t *odd, mblk_t *mp, struct sockaddr *sock,
 		    KM_NOSLEEP | KM_NORMALPRI);
 		if (entry == NULL) {
 			mutex_exit(&ott->ott_lock);
+			OVERLAY_DROP(mp, "VL2 target entry allocation failed");
 			return (OVERLAY_TARGET_DROP);
 		}
 
@@ -836,6 +869,7 @@ overlay_target_lookup(overlay_dev_t *odd, mblk_t *mp, struct sockaddr *sock,
 
 	mutex_enter(&entry->ote_lock);
 	if (entry->ote_flags & OVERLAY_ENTRY_F_DROP) {
+		OVERLAY_DROP(mp, "VL2 target marked drop");
 		ret = OVERLAY_TARGET_DROP;
 	} else if (entry->ote_flags & OVERLAY_ENTRY_F_ROUTER) {
 		ret = overlay_route_lookup(odd, mp, VLAN_ID(mhi.mhi_tci), sock,
