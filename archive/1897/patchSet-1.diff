commit 4817db82856de526108bbb479c57f1e1acb9ba47 (refs/changes/97/1897/1)
Author: Pedro Palazon Candel <pedro@joyent.com>
Date:   2017-05-04T12:38:43+02:00 (2 years, 5 months ago)
    
    TOOLS-1643 sdcadm: use cueball Resolver for waitUntilZone[In|OutOf]DNS instead of system dig

diff --git a/lib/common.js b/lib/common.js
index 0c8f3e5..5e5248a 100644
--- a/lib/common.js
+++ b/lib/common.js
@@ -21,6 +21,7 @@ var util = require('util');
 var vasync = require('vasync');
 var backoff = require('backoff');
 var once = require('once');
+var cueball = require('cueball');
 
 var errors = require('./errors');
 var InternalError = errors.InternalError;
@@ -640,38 +641,66 @@ function getZoneIP(opts, cb) {
     });
 }
 
-function digDomain(opts, cb) {
-    assert.object(opts, 'opts');
-    assert.string(opts.domain, 'opts.domain');
-    assert.object(opts.log, 'opts.log');
-    assert.func(cb, 'cb');
-
-    var argv = [
-        '/usr/sbin/dig',
-        opts.domain,
-        '+short'
-    ];
-
-    execFilePlus({
-        argv: argv,
-        log: opts.log
-    }, function (err, stdout, stderr) {
-        if (err) {
-            return cb(err);
+/*
+ * Create an instance of cueball's resolver using binder for
+ * resolution of the given service. Optionally, can pass the
+ * port the service should be listening to (default to port 80)
+ */
+function resolverForService(options) {
+    assert.object(options, 'options');
+    assert.object(options.sdcadm, 'options.sdcadm');
+    assert.string(options.service, 'options.service');
+    assert.optionalNumber(options.defaultPort, 'options.defaultPort');
+
+    var sdcadm = options.sdcadm;
+    var host = format('%s.%s.%s',
+            options.service,
+            sdcadm.config.datacenter_name,
+            sdcadm.config.dns_domain);
+    var defPort = options.defaultPort || 80;
+
+    var resolver = cueball.resolverForIpOrDomain({
+        input: host,
+        resolverConfig: {
+            resolvers: [format('binder.%s.%s',
+                        sdcadm.config.datacenter_name,
+                        sdcadm.config.dns_domain)],
+            service: '_http._tcp',
+            defaultPort: defPort,
+            recovery: {
+                default: {
+                    timeout: 1000,
+                    retries: 1,
+                    delay: 1000,
+                    maxDelay: 1000
+                }
+            },
+            log: sdcadm.log
         }
-
-        var ips = stdout.trim().split('\n');
-        return cb(null, ips);
     });
+
+    return (resolver);
 }
 
 
+/*
+ * Wait until the given zone is out of DNS using the provided
+ * cueball's resolvers backends.
+ *
+ * Resolver will be created by procedure functions using the function
+ * resolverForService above.
+ *
+ * The backends object has a key/value format, where the keys are
+ * cueball's keys for each backend, and the values are the IPs
+ * associated with the domain we're looking for in DNS.
+ */
 function waitUntilZoneInDNS(opts, cb) {
     assert.object(opts, 'opts');
     assert.string(opts.uuid, 'opts.uuid');
     assert.string(opts.alias, 'opts.alias');
-    assert.string(opts.domain, 'opts.domain');
+    assert.string(opts.server, 'opts.server');
     assert.object(opts.log, 'opts.log');
+    assert.object(opts.backends, 'opts.backends');
     assert.func(cb, 'cb');
 
     getZoneIP({
@@ -680,47 +709,50 @@ function waitUntilZoneInDNS(opts, cb) {
         log: opts.log
     }, function (err, ip) {
         if (err) {
-            return cb(err);
+            cb(err);
+            return;
         }
+
         var counter = 0;
         var limit = 60;
 
         function _checkDNS() {
-            digDomain({
-                domain: opts.domain,
-                log: opts.log
-            }, function (err2, ips) {
-                if (err2) {
-                    return cb(err2);
-                }
+            var alreadyInDns = false;
 
-                if (ips.indexOf(ip) !== -1) {
-                    return cb(null);
+            Object.keys(opts.backends).forEach(function (k) {
+                if (opts.backends[k] === ip) {
+                    alreadyInDns = true;
                 }
+            });
 
-                counter += 1;
+            if (alreadyInDns) {
+                cb();
+                return;
+            }
 
-                if (counter < limit) {
-                    return setTimeout(_checkDNS, 5000);
-                } else {
-                    return cb(format(
-                        'New %s ($uuid) zone\'s IP %s did not ' +
-                        'enter DNS', opts.alias, ip));
-                }
-            });
+            counter += 1;
+
+            if (counter < limit) {
+                setTimeout(_checkDNS, 5000);
+            } else {
+                cb(format(
+                    'New %s ($uuid) zone\'s IP %s did not ' +
+                    'enter DNS', opts.alias, ip));
+            }
         }
 
-        return _checkDNS();
+        _checkDNS();
     });
-
 }
 
+
 function waitUntilZoneOutOfDNS(opts, cb) {
     assert.object(opts, 'opts');
     assert.string(opts.uuid, 'opts.uuid');
     assert.string(opts.alias, 'opts.alias');
-    assert.string(opts.domain, 'opts.domain');
+    assert.string(opts.server, 'opts.server');
     assert.object(opts.log, 'opts.log');
+    assert.object(opts.backends, 'opts.backends');
     assert.func(cb, 'cb');
 
     getZoneIP({
@@ -729,37 +761,34 @@ function waitUntilZoneOutOfDNS(opts, cb) {
         log: opts.log
     }, function (err, ip) {
         if (err) {
-            return cb(err);
+            cb(err);
+            return;
         }
         var counter = 0;
         var limit = 60;
 
         function _checkDNS() {
-            digDomain({
-                domain: opts.domain,
-                log: opts.log
-            }, function (err2, ips) {
-                if (err2) {
-                    return cb(err2);
-                }
+            var ips = Object.keys(opts.backends).map(function (k) {
+                return opts.backends[k];
+            });
 
-                if (ips.indexOf(ip) === -1) {
-                    return cb(null);
-                }
+            if (ips.indexOf(ip) === -1) {
+                cb();
+                return;
+            }
 
-                counter += 1;
+            counter += 1;
 
-                if (counter < limit) {
-                    return setTimeout(_checkDNS, 5000);
-                } else {
-                    return cb(format(
-                        'New %s ($uuid) zone\'s IP %s did not ' +
-                        'leave DNS', opts.alias, ip));
-                }
-            });
+            if (counter < limit) {
+                setTimeout(_checkDNS, 5000);
+            } else {
+                cb(format(
+                    'New %s ($uuid) zone\'s IP %s did not ' +
+                    'leave DNS', opts.alias, ip));
+            }
         }
 
-        return _checkDNS();
+        _checkDNS();
     });
 }
 
@@ -1664,7 +1693,7 @@ module.exports = {
     execPlus: execPlus,
     spawnRun: spawnRun,
     getZoneIP: getZoneIP,
-    digDomain: digDomain,
+    resolverForService: resolverForService,
     waitUntilZoneInDNS: waitUntilZoneInDNS,
     waitUntilZoneOutOfDNS: waitUntilZoneOutOfDNS,
     vmGetRemote: vmGetRemote,
diff --git a/lib/procedures/download-images.js b/lib/procedures/download-images.js
index 8a36175..d855cac 100644
--- a/lib/procedures/download-images.js
+++ b/lib/procedures/download-images.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2015, Joyent, Inc.
+ * Copyright (c) 2017, Joyent, Inc.
  */
 
 var p = console.log;
@@ -65,119 +65,288 @@ DownloadImages.prototype.execute = function diExecute(options, cb) {
         }
     }
 
+    /*
+     * Keep track of errors during parallel image imports
+     */
+    var errs = [];
 
-    var q = vasync.queuev({
-        concurrency: 4,
-        worker: function importUpdateImage(image, next) {
-            function deleteImage(_, nextStep) {
-                if (image.state !== 'unactivated') {
-                    return nextStep();
-                }
 
-                progress('Removing unactivated image %s\n(%s@%s)', image.uuid,
-                    image.name, image.version);
+    /*
+     * Given an array containing an array of images, this function will
+     * recursively call itself until we get the origins for all the images,
+     * storing these in arrays of the form:
+     * [..., [Arr of origins of level 2], [Arr of origins of level 1], [imgs]]
+     *
+     * The callback will be called with `f(err, collectionsOfImages)`
+     */
+    function getAncestorsForImages(colsToRetrieve, callback) {
+        var currCol = colsToRetrieve[0];
+        var newCol = [];
+        vasync.forEachParallel({
+            inputs: currCol,
+            func: function checkImgOrigin(img, nextImg) {
+                if (!img.origin) {
+                    nextImg();
+                    return;
+                }
 
-                sdcadm.imgapi.deleteImage(image.uuid, function (err) {
-                    if (err) {
-                        progress('Error removing unactivated image %s\n(%s@%s)',
-                                    image.uuid, image.name, image.version);
+                /*
+                 * If we find that the image origin has already been queued for
+                 * download, we need to move it up on the download queue, since
+                 * we want it downloaded before the image we're evaluating now.
+                 */
+                var found = false;
+                colsToRetrieve.forEach(function (aCol) {
+                    var pos;
+                    for (pos = 0; pos < aCol.length; pos += 1) {
+                        if (aCol[pos].uuid === img.origin) {
+                            newCol.push(aCol[pos]);
+                            delete (aCol[pos]);
+                            found = true;
+                        }
+                    }
+                });
+                if (found) {
+                    nextImg();
+                    return;
+                }
 
-                        var e = new errors.SDCClientError(err, 'imgapi');
-                        e.image = image.uuid;
-                        sdcadm.log.error({err: e}, 'Error removing image');
-                        nextStep(e);
-                    } else {
-                        nextStep();
+                var orig = img.origin;
+                sdcadm.imgapi.getImage(orig, function (err, local) {
+                    if (!err) {
+                        /*
+                         * Origin already imported but unactivated.
+                         */
+                        if (local.state === 'unactivated') {
+                            newCol.push(local);
+                        }
+                        nextImg();
+                        return;
+                    } else if (err) {
+                        if (err.body.code !== 'ResourceNotFound') {
+                            nextImg(new errors.SDCClientError(err, 'imgapi'));
+                            return;
+                        } else {
+                            /*
+                             * We need to fetch origin details from remote
+                             * (origin not imported).
+                             */
+                            sdcadm.updates.getImage(orig, function (er, rem) {
+                                if (er) {
+                                    nextImg(new errors.SDCClientError(er,
+                                        'updates'));
+                                    return;
+                                }
+                                newCol.push(rem);
+                                nextImg();
+                            });
+                        }
                     }
                 });
             }
+        }, function paraCb(paraErr) {
+            if (paraErr) {
+                callback(paraErr);
+                return;
+            }
+            if (newCol.length) {
+                var uuids = [];
+                newCol = newCol.filter(function (elm) {
+                    var isNew = (uuids.indexOf(elm.uuid) === -1);
+                    if (isNew) {
+                        uuids.push(elm.uuid);
+                    }
+                    return isNew;
+                });
+                colsToRetrieve.unshift(newCol);
+                getAncestorsForImages(colsToRetrieve, callback);
+            } else {
+                callback(null, colsToRetrieve);
+            }
+        });
+    }
+
+
+    function importCollectionOfImages(collection, nextCollection) {
+        var q = vasync.queuev({
+            concurrency: 4,
+            worker: function importUpdateImage(image, next) {
+                /*
+                 * Need to be verified here b/c there sdcadm parts other than
+                 * procedures index calling DownloadImages.
+                 */
+                function checkIfImageIsUnactivated(_, nextStep) {
+                    if (image.state === 'unactivated') {
+                        nextStep();
+                        return;
+                    }
+                    sdcadm.imgapi.getImage(image.uuid, function (err, local) {
+                        if (err && err.body.code === 'ResourceNotFound') {
+                            nextStep();
+                        } else if (err) {
+                            nextStep(new errors.SDCClientError(err, 'imgapi'));
+                        } else {
+                            if (local.state === 'unactivated') {
+                                // Let DownloadImages know that it has to
+                                // remove the image first:
+                                image.state = 'unactivated';
+                            }
+                            nextStep();
+                        }
+                    });
+                }
+
+                function deleteImage(_, nextStep) {
+                    if (image.state !== 'unactivated') {
+                        return nextStep();
+                    }
+
+                    progress('Removing unactivated image %s\n(%s@%s)',
+                        image.uuid, image.name, image.version);
 
-            function getImage(_, nextStep) {
-                progress('Downloading image %s\n    (%s@%s)',
-                    image.uuid, image.name, image.version);
-                sdcadm.imgapi.adminImportRemoteImageAndWait(
-                    image.uuid,
-                    source,
-                    {
-                        // TODO: Once IMGAPI-408 is sufficient deployed, then
-                        // drop this `skipOwnerCheck`.
-                        skipOwnerCheck: true,
-                        // Retry image import 5 times by default:
-                        retries: 5
-                    },
-                    function (err, img, res) {
+                    sdcadm.imgapi.deleteImage(image.uuid, function (err) {
                         if (err) {
-                            progress('Error importing image %s\n(%s@%s)',
+                            progress(
+                                'Error removing unactivated image %s\n(%s@%s)',
                                 image.uuid, image.name, image.version);
+
                             var e = new errors.SDCClientError(err, 'imgapi');
                             e.image = image.uuid;
+                            sdcadm.log.error({err: e}, 'Error removing image');
                             nextStep(e);
                         } else {
-                            progress('Imported image %s\n    (%s@%s)',
-                                image.uuid, image.name, image.version);
                             nextStep();
                         }
                     });
+                }
+
+                function getImage(_, nextStep) {
+                    progress('Downloading image %s\n    (%s@%s)',
+                        image.uuid, image.name, image.version);
+                    sdcadm.imgapi.adminImportRemoteImageAndWait(
+                        image.uuid,
+                        source,
+                        {
+                            // TODO: Once IMGAPI-408 is sufficient deployed,
+                            // then drop this `skipOwnerCheck`.
+                            skipOwnerCheck: true,
+                            // Retry image import 5 times by default:
+                            retries: 5
+                        },
+                        function (err, img, res) {
+                            if (err) {
+                                progress('Error importing image %s\n(%s@%s)',
+                                    image.uuid, image.name, image.version);
+                                var e = new errors.SDCClientError(err,
+                                    'imgapi');
+                                e.image = image.uuid;
+                                nextStep(e);
+                            } else {
+                                progress('Imported image %s\n    (%s@%s)',
+                                    image.uuid, image.name, image.version);
+                                nextStep();
+                            }
+                        });
+                }
+
+                vasync.pipeline({funcs: [
+                    checkIfImageIsUnactivated,
+                    deleteImage,
+                    getImage
+                ]}, next);
             }
+        });
 
-            vasync.pipeline({funcs: [deleteImage, getImage]}, next);
+        function onTaskComplete(err) {
+            if (err) {
+                errs.push(err);
+            }
         }
-    });
 
-    // TODO: For now we just collect import errors and return them. We
-    //       should do better with retries (either here or in the imgapi
-    //       client).
-    var errs = [];
-    function onTaskComplete(err) {
+        q.on('end', function done() {
+            nextCollection();
+        });
+
+        q.push(collection, onTaskComplete);
+        q.close();
+    }
+
+
+
+    /*
+     * TOOLS-1634: We need to make sure that all the origins for
+     * all our images are imported and active in local IMGAPI.
+     * Additionally, we cannot try to import origins and the images
+     * created from those origins in parallel, so we need to import
+     * the different level of images ancestors sequentially.
+     *
+     * We'll use an array of arrays, prepending collections to this array as
+     * we go deeper in image's origins. Every origin not already on the local
+     * IMGAPI or with a state of 'unactivated' will be imported. Once we have
+     * a collection of 'sibiling' origins, we'll normalize that collection
+     * (remove duplicates) and prepend to `collectionsToRetrieve`:
+     */
+    var collectionsToRetrieve = [];
+    /*
+     * We'll begin with the service images we want to retrieve first,
+     * then we'll continue with successive origins.
+     */
+    collectionsToRetrieve.unshift(self.images);
+
+    getAncestorsForImages(collectionsToRetrieve, function (err, collections) {
         if (err) {
-            errs.push(err);
+            cb(err);
+            return;
         }
-    }
 
-    q.on('end', function done() {
-        var er = (errs.length === 1) ? errs[0] :
-            new errors.MultiError(errs);
-
-        // Check if the problem is that external nics are missing.
-        if (errs.length) {
-            var remoteSourceErr = errs.some(function (e) {
-                return (e && e.we_cause &&
-                    e.we_cause.name === 'RemoteSourceError');
-            });
-
-            if (remoteSourceErr) {
-                options.sdcadm.checkMissingExternalNics({
-                    progress: options.progress
-                }, function (err, res) {
-                    if (err) {
-                        return cb(errs);
-                    }
+        vasync.forEachPipeline({
+            inputs: collections,
+            func: importCollectionOfImages
+        }, function pipeCb(pipeErr) {
+            if (pipeErr) {
+                cb(pipeErr);
+                return;
+            }
+            var er = (errs.length === 1) ? errs[0] :
+                new errors.MultiError(errs);
 
-                    var doimgapi = res.doimgapi;
-                    if (doimgapi) {
-                        p('');
-                        var msg = 'There is an error trying to download ' +
-                            'images because the imgapi zone has no ' +
-                            'external NIC.\nPlease run:\n\n' +
-                            '   sdcadm post-setup common-external-nics\n' +
-                            '\nand try again.\n';
-                        p(msg);
-                    }
-                    // we need to return the error anyway:
-                    return cb(er);
+            // Check if the problem is that external nics are missing.
+            if (errs.length) {
+                var remoteSourceErr = errs.some(function (e) {
+                    return (e && e.we_cause &&
+                        e.we_cause.name === 'RemoteSourceError');
                 });
+
+                if (remoteSourceErr) {
+                    sdcadm.checkMissingExternalNics({
+                        progress: progress
+                    }, function (nicsErr, res) {
+                        if (nicsErr) {
+                            return cb(errs);
+                        }
+
+                        var doimgapi = res.doimgapi;
+                        if (doimgapi) {
+                            p('');
+                            var msg = 'There is an error trying to download ' +
+                                'images because the imgapi zone has no ' +
+                                'external NIC.\nPlease run:\n\n' +
+                                '   sdcadm post-setup common-external-nics\n' +
+                                '\nand try again.\n';
+                            p(msg);
+                        }
+                        // we need to return the error anyway:
+                        cb(er);
+                        return;
+                    });
+                } else {
+                    cb(er);
+                }
             } else {
-                cb(er);
+                cb();
             }
-        } else {
-            cb();
-        }
+        });
     });
-
-    for (var i = 0; i < self.images.length; i++) {
-        q.push(self.images[i], onTaskComplete);
-    }
-    q.close();
 };
 
 //---- exports
diff --git a/lib/procedures/index.js b/lib/procedures/index.js
index d254287..b40e7d8 100644
--- a/lib/procedures/index.js
+++ b/lib/procedures/index.js
@@ -103,6 +103,7 @@ function coordinatePlan(opts, cb) {
     var log = opts.log;
     var progress = opts.progress || function () {};
     var sdcadm = opts.sdcadm;
+    var forceSameImage = opts.plan.forceSameImage;
     var instsFromSvcName = {};
     var insts = opts.plan.curr;
     for (var i = 0; i < insts.length; i++) {
@@ -217,7 +218,12 @@ function coordinatePlan(opts, cb) {
                             handle.push(change);
                         } else {
                             if (~HA_READY_SVCS.indexOf(change.service.name)) {
-                                change.insts = svcInsts;
+                                var chInsts = forceSameImage ? svcInsts :
+                                        svcInsts.filter(function (ins) {
+                                            return (ins.image !==
+                                                change.image.uuid);
+                                        });
+                                change.insts = chInsts;
                                 handle.push(change);
                             } else {
                                 log.debug({
@@ -382,7 +388,12 @@ function coordinatePlan(opts, cb) {
                 {
                     var svcInsts = instsFromSvcName[change.service.name] || [];
                     if (svcInsts.length && svcInsts.length > 1) {
-                        change.insts = svcInsts;
+                        var chInsts = forceSameImage ? svcInsts :
+                                svcInsts.filter(function (ins) {
+                                    return (ins.image !==
+                                        change.image.uuid);
+                                });
+                        change.insts = chInsts;
                     } else {
                         change.inst = svcInsts[0];
                     }
diff --git a/lib/procedures/shared.js b/lib/procedures/shared.js
index bc4f2a7..babbf0c 100644
--- a/lib/procedures/shared.js
+++ b/lib/procedures/shared.js
@@ -610,7 +610,7 @@ function waitUntilVMNotInDNS(arg, next) {
         uuid: zonename,
         server: server,
         alias: arg.alias,
-        domain: arg.domain,
+        backends: arg.backends,
         log: arg.log
     }, next);
 }
@@ -624,7 +624,7 @@ function waitUntilVmInDNS(arg, next) {
         uuid: zonename,
         server: server,
         alias: arg.alias,
-        domain: arg.domain,
+        backends: arg.backends,
         log: arg.log
     }, next);
 }
diff --git a/lib/procedures/update-binder-v2.js b/lib/procedures/update-binder-v2.js
index 4e130b8..4958d88 100644
--- a/lib/procedures/update-binder-v2.js
+++ b/lib/procedures/update-binder-v2.js
@@ -45,8 +45,14 @@ UpdateBinderV2.prototype.summarize = function ushiSummarize() {
     if (c0.insts) {
         out[0] += ':';
         out = out.concat(c0.insts.map(function (inst) {
-            return common.indent(sprintf('instance "%s" (%s) in server %s',
-                inst.zonename, inst.alias, inst.server));
+            if (inst.image === img.uuid) {
+                return common.indent(sprintf(
+                    'instance "%s" (%s) is already at version %s',
+                    inst.zonename, inst.alias, img.version));
+            } else {
+                return common.indent(sprintf('instance "%s" (%s) in server %s',
+                    inst.zonename, inst.alias, inst.server));
+            }
         }));
     }
     return out.join('\n');
@@ -247,6 +253,10 @@ UpdateBinderV2.prototype.execute = function ushiExecute(opts, cb) {
                 vasync.forEachPipeline({
                     inputs: followers,
                     func: function reprovFollower(inst, next_) {
+                        if (inst.image === change.image.uuid) {
+                            next_();
+                            return;
+                        }
                         s.reprovisionRemote({
                             server: inst.server,
                             img: change.image,
@@ -304,8 +314,9 @@ UpdateBinderV2.prototype.execute = function ushiExecute(opts, cb) {
             },
 
             function reprovisionLeader(_, next) {
-                if (!leader) {
-                    return next();
+                if (!leader || leader.image === change.image.uuid) {
+                    next();
+                    return;
                 }
                 progress('Updating ZK leader');
                 s.reprovisionRemote({
diff --git a/lib/procedures/update-moray-v2.js b/lib/procedures/update-moray-v2.js
index 980070e..6f7cee7 100644
--- a/lib/procedures/update-moray-v2.js
+++ b/lib/procedures/update-moray-v2.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright 2016 Joyent, Inc.
+ * Copyright 2017 Joyent, Inc.
  */
 
 var assert = require('assert-plus');
@@ -70,6 +70,7 @@ UpdateMorayV2.prototype.execute = function morayv2Execute(opts, cb) {
     assert.func(cb, 'cb');
 
     var self = this;
+    var sdcadm = opts.sdcadm;
     var progress = opts.progress;
     var rollback = opts.plan.rollback || false;
 
@@ -125,6 +126,29 @@ UpdateMorayV2.prototype.execute = function morayv2Execute(opts, cb) {
         }
 
         funcs.push(s.updateSapiSvc);
+        funcs.push(
+            /*
+             * Set ctx.resolver and ctx.backends needed by waitUntilVmInDNS and
+             * waitUntilVMNotInDNS
+             */
+            function createResolver(ctx, next) {
+                ctx.resolver = common.resolverForService({
+                    sdcadm: sdcadm,
+                    service: change.service.name
+                });
+                ctx.backends = {};
+                ctx.resolver.on('added', function (key, backend) {
+                    ctx.backends[key] = backend.address;
+                });
+
+                ctx.resolver.on('removed', function (key) {
+                    delete ctx.backends[key];
+                });
+
+                ctx.resolver.start();
+                next();
+            }
+        );
 
         if (arg.HA) {
             change.insts.forEach(function (ins) {
@@ -145,14 +169,14 @@ UpdateMorayV2.prototype.execute = function morayv2Execute(opts, cb) {
                             server: ins.server
                         }, next);
                     },
-                    function waitUntilInstNotInDNS(_, next) {
+                    function waitUntilInstNotInDNS(ctx, next) {
                         s.waitUntilVMNotInDNS({
                             log: opts.log,
                             progress: progress,
                             zonename: ins.zonename,
                             alias: ins.alias,
                             server: ins.server,
-                            domain: change.service.metadata.SERVICE_DOMAIN
+                            backends: ctx.backends
                         }, next);
                     },
                     function reprovisionInst(_, next) {
@@ -170,14 +194,14 @@ UpdateMorayV2.prototype.execute = function morayv2Execute(opts, cb) {
                             ins.service, ins.zonename);
                         setTimeout(next, 15 * 1000);
                     },
-                    function waitUntilInstInDNS(_, next) {
+                    function waitUntilInstInDNS(ctx, next) {
                         s.waitUntilVmInDNS({
                             log: opts.log,
                             progress: progress,
                             zonename: ins.zonename,
                             server: ins.server,
                             alias: ins.alias,
-                            domain: change.service.metadata.SERVICE_DOMAIN
+                            backends: ctx.backends
                         }, next);
                     }
                 ]);
@@ -204,14 +228,14 @@ UpdateMorayV2.prototype.execute = function morayv2Execute(opts, cb) {
                 s.waitForTmpInstToBeUp,
                 s.getTmpInstanceUUID,
                 s.checkIfTmpVMHasErrors,
-                function waitUntilTmpInDNS(_, next) {
+                function waitUntilTmpInDNS(ctx, next) {
                     return s.waitUntilVmInDNS({
                         log: opts.log,
                         progress: progress,
                         zonename: arg.tmpUUID,
                         alias: arg.tmpAlias,
                         server: inst.server,
-                        domain: change.service.metadata.SERVICE_DOMAIN
+                        backends: ctx.backends
                     }, next);
                 },
                 function disableVMRegistrar(_, next) {
@@ -221,26 +245,26 @@ UpdateMorayV2.prototype.execute = function morayv2Execute(opts, cb) {
                         zonename: inst.zonename
                     }, next);
                 },
-                function waitUntilVMNotInDNS(_, next) {
+                function waitUntilVMNotInDNS(ctx, next) {
                     s.waitUntilVMNotInDNS({
                         log: opts.log,
                         progress: progress,
                         zonename: inst.zonename,
                         server: inst.server,
                         alias: inst.alias,
-                        domain: change.service.metadata.SERVICE_DOMAIN
+                        backends: ctx.backends
                     }, next);
                 },
                 s.reprovision,
                 s.waitForInstToBeUp,
-                function waitUntilVmInDNS(_, next) {
+                function waitUntilVmInDNS(ctx, next) {
                     s.waitUntilVmInDNS({
                         log: opts.log,
                         progress: progress,
                         zonename: inst.zonename,
                         alias: inst.alias,
                         server: inst.server,
-                        domain: change.service.metadata.SERVICE_DOMAIN
+                        backends: ctx.backends
                     }, next);
                 },
                 function disableTmpVMRegistrar(_, next) {
@@ -250,14 +274,14 @@ UpdateMorayV2.prototype.execute = function morayv2Execute(opts, cb) {
                         zonename: arg.tmpUUID
                     }, next);
                 },
-                function waitUntilTmpVMNotInDNS(_, next) {
+                function waitUntilTmpVMNotInDNS(ctx, next) {
                     return s.waitUntilVMNotInDNS({
                         log: opts.log,
                         progress: progress,
                         zonename: arg.tmpUUID,
                         alias: arg.tmpAlias,
                         server: inst.server,
-                        domain: change.service.metadata.SERVICE_DOMAIN
+                        backends: ctx.backends
                     }, next);
                 },
                 s.stopTmpVm,
diff --git a/lib/procedures/update-single-hn-sapi-v1.js b/lib/procedures/update-single-hn-sapi-v1.js
index e9288df..af319cd 100644
--- a/lib/procedures/update-single-hn-sapi-v1.js
+++ b/lib/procedures/update-single-hn-sapi-v1.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2015, Joyent, Inc.
+ * Copyright (c) 2017, Joyent, Inc.
  */
 
 var assert = require('assert-plus');
@@ -171,6 +171,29 @@ UpdateSingleHNSapiV1.prototype.execute = function sapiv1Execute(opts, cb) {
                     return next();
                 });
             },
+
+            /*
+             * Set ctx.resolver and ctx.backends needed by waitUntilVmInDNS and
+             * waitUntilVMNotInDNS
+             */
+            function createResolver(ctx, next) {
+                ctx.resolver = common.resolverForService({
+                    sdcadm: sdcadm,
+                    service: change.service.name
+                });
+                ctx.backends = {};
+                ctx.resolver.on('added', function (key, backend) {
+                    ctx.backends[key] = backend.address;
+                });
+
+                ctx.resolver.on('removed', function (key) {
+                    delete ctx.backends[key];
+                });
+
+                ctx.resolver.start();
+                next();
+            },
+
             /**
              * Create a temporary "sapiXtmp" instance when no HA
              */
@@ -178,7 +201,7 @@ UpdateSingleHNSapiV1.prototype.execute = function sapiv1Execute(opts, cb) {
             s.waitForTmpInstToBeUp,
             s.getTmpInstanceUUID,
             s.checkIfTmpVMHasErrors,
-            function waitUntilTmpInDNS(_, next) {
+            function waitUntilTmpInDNS(ctx, next) {
                 if (arg.HA) {
                     return next();
                 }
@@ -188,7 +211,7 @@ UpdateSingleHNSapiV1.prototype.execute = function sapiv1Execute(opts, cb) {
                     zonename: arg.tmpUUID,
                     alias: arg.tmpAlias,
                     server: inst.server,
-                    domain: change.service.metadata.SERVICE_DOMAIN
+                    backends: ctx.backends
                 }, next);
             },
             // Common to both HA/no-HA
@@ -199,26 +222,26 @@ UpdateSingleHNSapiV1.prototype.execute = function sapiv1Execute(opts, cb) {
                     zonename: inst.zonename
                 }, next);
             },
-            function waitUntilVMNotInDNS(_, next) {
+            function waitUntilVMNotInDNS(ctx, next) {
                 s.waitUntilVMNotInDNS({
                     log: opts.log,
                     progress: progress,
                     zonename: inst.zonename,
                     alias: inst.alias,
                     server: inst.server,
-                    domain: change.service.metadata.SERVICE_DOMAIN
+                    backends: ctx.backends
                 }, next);
             },
             s.reprovision,
             s.waitForInstToBeUp,
-            function waitUntilVmInDNS(_, next) {
+            function waitUntilVmInDNS(ctx, next) {
                 s.waitUntilVmInDNS({
                     log: opts.log,
                     progress: progress,
                     zonename: inst.zonename,
                     alias: inst.alias,
                     server: inst.server,
-                    domain: change.service.metadata.SERVICE_DOMAIN
+                    backends: ctx.backends
                 }, next);
             },
             // And, again, no-HA only:,
@@ -233,7 +256,7 @@ UpdateSingleHNSapiV1.prototype.execute = function sapiv1Execute(opts, cb) {
                     zonename: arg.tmpUUID
                 }, next);
             },
-            function waitUntilTmpVMNotInDNS(_, next) {
+            function waitUntilTmpVMNotInDNS(ctx, next) {
                 if (arg.HA) {
                     return next();
                 }
@@ -243,11 +266,15 @@ UpdateSingleHNSapiV1.prototype.execute = function sapiv1Execute(opts, cb) {
                     zonename: arg.tmpUUID,
                     alias: arg.tmpAlias,
                     server: inst.server,
-                    domain: change.service.metadata.SERVICE_DOMAIN
+                    backends: ctx.backends
                 }, next);
             },
             s.stopTmpVm,
-            s.destroyTmpVM
+            s.destroyTmpVM,
+            function stopResolver(ctx, next) {
+                ctx.resolver.stop();
+                next();
+            }
         ]), arg: arg}, nextSvc);
     }
 
