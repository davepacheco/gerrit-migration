commit 26b5659c9b1f887ba12e5c1108218d068fd0b07c (refs/changes/46/2546/6)
Author: Cody Peter Mello <cody.mello@joyent.com>
Date:   2017-09-19T17:51:42+00:00 (2 years, 1 month ago)
    
    MORAY-431 Errors after query has timed out are emitted when there are no "error" listeners
    Reviewed by: Jan Wyszynski <jan.wyszynski@joyent.com>
    Reviewed by: David Pacheco <dap@joyent.com>
    Approved by: David Pacheco <dap@joyent.com>

diff --git a/lib/dtrace.js b/lib/dtrace.js
index c5cec2e..005acc5 100644
--- a/lib/dtrace.js
+++ b/lib/dtrace.js
@@ -79,6 +79,9 @@ var PROBES = {
     // reqid, sql, error message
     'query-error': ['char *', 'char *', 'char *'],
 
+    // reqid, sql
+    'query-timeout': ['char *', 'char *'],
+
     // reqid, sql
     'query-done': ['char *', 'char *', 'json'],
 
diff --git a/lib/pg.js b/lib/pg.js
index 41207de..2f2f2ef 100644
--- a/lib/pg.js
+++ b/lib/pg.js
@@ -53,21 +53,6 @@ var SERIALIZERS = {
 
 ///--- Postgres Client Wrapper Class
 
-function qCleanup(req, res) {
-    if (req) {
-        req.removeAllListeners('end');
-        req.removeAllListeners('error');
-        req.removeAllListeners('row');
-    }
-
-    if (res) {
-        res.removeAllListeners('end');
-        res.removeAllListeners('error');
-        res.removeAllListeners('row');
-    }
-}
-
-
 /*
  * This client wraps the node-postgres client to provide some useful helper
  * methods, and also to provide timeouts and DTrace probes inside the query
@@ -151,12 +136,15 @@ PGClient.prototype.query = function clientQuery(sql, args) {
     var self = this;
     var timer;
     var reqid = libuuid.create();
+    var aborted = false;
 
     function done(event, arg) {
-        res.emit(event, arg);
+        if (aborted) {
+            return;
+        }
 
+        res.emit(event, arg);
         clearTimeout(timer);
-        qCleanup(req, res);
     }
 
     req = new pg.Query(sql, args);
@@ -172,6 +160,10 @@ PGClient.prototype.query = function clientQuery(sql, args) {
             row: row
         }, 'query: row');
 
+        if (aborted) {
+            return;
+        }
+
         clearTimeout(timer);
         res.emit('row', row);
     });
@@ -206,12 +198,32 @@ PGClient.prototype.query = function clientQuery(sql, args) {
 
     if (this._queryTimeout > 0) {
         timer = setTimeout(function onRowTimeout() {
-            // Don't rollback, since it may or may not
-            // make it to the server; just force a connection
-            // close to happen once the conn is out of the
-            // pool
+            /*
+             * Don't ROLLBACK, since it may or may not make
+             * it to the server, and the query we just timed
+             * out may have placed things in a weird state;
+             * just force a connection close to happen once
+             * the connection is out of the pool.
+             */
             self._moray_had_err = true;
-            done('error', new QueryTimeoutError(sql));
+
+            dtrace['query-timeout'].fire(function () {
+                return ([reqid, sql]);
+            });
+
+            /*
+             * We're timing out the query inside Moray, but
+             * the Postgres query is still running. It may
+             * still return rows, return a SQL error, or end due
+             * to connection problems. We don't emit anything
+             * after this point, since we've already emitted an
+             * "error" and will have replied to the client. We
+             * do continue logging and firing DTrace probes for
+             * anyone who's observing the process, though.
+             */
+            aborted = true;
+
+            res.emit('error', new QueryTimeoutError(sql));
         }, this._queryTimeout);
     }
 
@@ -310,7 +322,23 @@ PGClient.prototype.rollback = function transactionRollback(cb) {
         }
     }
 
-    if (!self._moray_txn) {
+    /*
+     * If "_moray_had_err" has been set by the point we're running the
+     * .rollback() method, it's because one of the following has happened:
+     *
+     *   - We had a connection error
+     *   - We failed to run BEGIN TRANSACTION (in which case _moray_txn is
+     *     set to false)
+     *   - We've timed out a query, and returned a QueryTimeoutError
+     *
+     * We could try to optimistically send ROLLBACK for the last case, but
+     * given that we timed out the query, it's possible that there are either
+     * connection issues, or we're waiting on a long-running query. We'll
+     * continue to occupy a slot in the pool that we intend to abandon as soon
+     * as the ROLLBACK returns, so failing fast here and letting Postgres abort
+     * the transaction itself seems to be a better approach.
+     */
+    if (!self._moray_txn || self._moray_had_err) {
         _cb();
         return;
     }
