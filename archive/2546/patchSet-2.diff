From f57cc670f111d3b585babcc84a74c1940fc22735 Mon Sep 17 00:00:00 2001
From: Cody Peter Mello <cody.mello@joyent.com>
Date: Tue, 12 Sep 2017 02:42:54 +0000
Subject: [PATCH] MORAY-431 Errors after query has timed out are emitted when
 there are no "error" listeners

---
 lib/dtrace.js |  3 +++
 lib/pg.js     | 46 +++++++++++++++++++++++++++++++++++++++-------
 2 files changed, 42 insertions(+), 7 deletions(-)

diff --git a/lib/dtrace.js b/lib/dtrace.js
index c5cec2e..005acc5 100644
--- a/lib/dtrace.js
+++ b/lib/dtrace.js
@@ -79,6 +79,9 @@ var PROBES = {
     // reqid, sql, error message
     'query-error': ['char *', 'char *', 'char *'],
 
+    // reqid, sql
+    'query-timeout': ['char *', 'char *'],
+
     // reqid, sql
     'query-done': ['char *', 'char *', 'json'],
 
diff --git a/lib/pg.js b/lib/pg.js
index 41207de..7c145b0 100644
--- a/lib/pg.js
+++ b/lib/pg.js
@@ -151,12 +151,15 @@ PGClient.prototype.query = function clientQuery(sql, args) {
     var self = this;
     var timer;
     var reqid = libuuid.create();
+    var aborted = false;
 
     function done(event, arg) {
-        res.emit(event, arg);
+        if (aborted) {
+            return;
+        }
 
+        res.emit(event, arg);
         clearTimeout(timer);
-        qCleanup(req, res);
     }
 
     req = new pg.Query(sql, args);
@@ -172,6 +175,10 @@ PGClient.prototype.query = function clientQuery(sql, args) {
             row: row
         }, 'query: row');
 
+        if (aborted) {
+            return;
+        }
+
         clearTimeout(timer);
         res.emit('row', row);
     });
@@ -206,12 +213,32 @@ PGClient.prototype.query = function clientQuery(sql, args) {
 
     if (this._queryTimeout > 0) {
         timer = setTimeout(function onRowTimeout() {
-            // Don't rollback, since it may or may not
-            // make it to the server; just force a connection
-            // close to happen once the conn is out of the
-            // pool
+            /*
+             * Don't ROLLBACK, since it may or may not make
+             * it to the server, and the query we just timed
+             * out may have placed things in a weird state;
+             * just force a connection close to happen once
+             * the connection is out of the pool.
+             */
             self._moray_had_err = true;
-            done('error', new QueryTimeoutError(sql));
+
+            dtrace['query-timeout'].fire(function () {
+                return ([reqid, sql]);
+            });
+
+            /*
+             * We're timing out the query inside Moray, but
+             * the Postgres query is still running. It may
+             * still return rows, return a SQL error, or end due
+             * to connection problems. We don't emit anything
+             * after this point, since we've already emitted an
+             * "error" and will have replied to the client. We
+             * do continue logging and firing DTrace probes for
+             * anyone who's observing the process, though.
+             */
+            aborted = true;
+
+            res.emit('error', new QueryTimeoutError(sql));
         }, this._queryTimeout);
     }
 
@@ -315,6 +342,11 @@ PGClient.prototype.rollback = function transactionRollback(cb) {
         return;
     }
 
+    if (self._moray_had_err) {
+        _cb();
+        return;
+    }
+
     var q = self.query('ROLLBACK');
 
     q.once('error', function (err) {
-- 
2.21.0

