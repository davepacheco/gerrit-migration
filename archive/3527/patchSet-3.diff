From fc0e5a2f5b64b0f4afbc074d6de52082f93374a7 Mon Sep 17 00:00:00 2001
From: Jan Wyszynski <jan.wyszynski@joyent.com>
Date: Fri, 2 Mar 2018 01:03:29 +0000
Subject: [PATCH] MANTA-3591 muskie throttle doesn't enforce concurrency
 properly

---
 lib/server.js   |  15 ++++--
 lib/throttle.js | 141 +++++++++++++++++++++++++++++++++++++++++-------
 2 files changed, 132 insertions(+), 24 deletions(-)

diff --git a/lib/server.js b/lib/server.js
index df6a1d1..dc19f2a 100644
--- a/lib/server.js
+++ b/lib/server.js
@@ -167,6 +167,16 @@ function createServer(options, clients, name) {
         }
     });
 
+    if (options.throttle.enabled) {
+        options.throttle.log = options.log;
+        options.throttle.server = server;
+
+        var thrtl = throttle.createThrottle(options.throttle);
+        server.pre(throttle.getRestifyThrottleHandle(thrtl));
+
+        log.info('registered throttle handler');
+    }
+
     server.pre(function watchClose(req, res, next) {
         /*
          * In some cases, we proactively check for closed client connections.
@@ -246,11 +256,6 @@ function createServer(options, clients, name) {
         }
     });
 
-    if (options.throttle.enabled) {
-        options.throttle.log = options.log;
-        var throttleHandle = throttle.createThrottle(options.throttle);
-        server.use(throttle.throttleHandler(throttleHandle));
-    }
     server.use(auth.authenticationHandler({
         log: log,
         mahi: clients.mahi,
diff --git a/lib/throttle.js b/lib/throttle.js
index 82cd5b4..16cfd19 100644
--- a/lib/throttle.js
+++ b/lib/throttle.js
@@ -12,6 +12,7 @@ var assert = require('assert-plus');
 var bunyan = require('bunyan');
 var vasync = require('vasync');
 var uuid = require('node-uuid');
+var once = require('once');
 var util = require('util');
 var mod_url = require('url');
 var fs = require('fs');
@@ -91,8 +92,7 @@ require('./errors');
  * necessary.
  */
 
-// Used for nanosecond to second conversion
-const NANOSEC_PER_SEC = Math.pow(10, 9);
+var DEFAULT_REAP_INTERVAL_MS = 5000;
 
 /*
  * The throttle object maintains all the state used by the throttle. This state
@@ -108,8 +108,14 @@ function Throttle(options) {
     assert.ok(options.log, 'options.log');
     assert.number(options.queueTolerance, 'options.queueTolerance');
     assert.ok(options.queueTolerance > 0, 'queueTolerance must be positive');
+    assert.ok(options.server, 'restify server');
 
-    this.log = options.log.child({ component: 'throttle'}, true);
+    this.log = options.log.child({
+        component: 'Throttle'
+    });
+
+    this.server = options.server;
+    this.requestMap = {};
 
     this.dtp = dtrace.createDTraceProvider('muskie-throttle');
     this.throttle_probes = {
@@ -135,11 +141,93 @@ function Throttle(options) {
     this.requestQueue = vasync.queue(function (task, callback) {
         task(callback);
     }, this.concurrency);
+
+    var self = this;
+
+    function clearQueueSlot(req, _) {
+        var value = self.requestMap[req.getId()];
+        if (!value) {
+            self.log.warn({
+                reqid: req.getId()
+            }, 'found empty request map entry, ' +
+               'assuming it was reaped');
+            return;
+        }
+
+        assert.object(value.req, 'throttle req');
+        assert.object(value.res, 'throttle res');
+        assert.func(value.cb, 'throttle callback');
+
+        self.log.debug({
+            reqid: req.getId()
+        }, 'delete from throttle request map');
+
+        delete (self.requestMap[req.getId()]);
+
+        self.throttle_probes.request_handled.fire(function () {
+            return ([self.requestQueue.npending, self.requestQueue.length(),
+                req.url, req.method]);
+        });
+
+        value.cb();
+    }
+
+    /*
+     * Every restify request route end with exactly one of these events being
+     * emitted. Note that 'handleUncaughtExceptions' is deprecated as of 5.x.
+     */
+    this.server.on('after', clearQueueSlot);
+    this.server.on('uncaughtException', clearQueueSlot);
+
+    this.reapInterval = options.reapInterval || DEFAULT_REAP_INTERVAL_MS;
+    this._reapStaleRequests();
 }
 
+function hrtimeToMS(hrtime) {
+    return (hrtime[0]*1e3) + (hrtime[0]/1e6);
+}
+
+/*
+ * This is really bad. It's known that not all routes trigger the 'after'
+ * callback. To deal with this, we check whether requests that the throttle has
+ * marked as in flight have finished, if so, we call their callbacks.
+ */
+Throttle.prototype._reapStaleRequests = function reap() {
+    var self = this;
+
+    self.log.debug({
+        numreqs: Object.keys(self.requestMap).length
+    }, 'checking for stale requests');
+
+    Object.keys(self.requestMap).forEach(function (key) {
+        var value = self.requestMap[key];
+
+        var req = value.req;
+        var res = value.res;
+        var cb = value.cb;
+
+        if (res.finished) {
+            self.log.debug({
+                reqid: req.getId()
+            }, 'reaping stale request slot');
+
+            delete (self.requestMap[key]);
+
+            cb();
+        }
+    });
+
+    setTimeout(self._reapStaleRequests.bind(self), self.reapInterval);
+};
+
+
 Throttle.prototype.wait = function wait(req, res, next) {
     var self = this;
 
+    self.log.debug({
+        reqid: req.getId()
+    }, 'throttle wait');
+
     if (self.requestQueue.length() >= self.queueTolerance) {
         self.throttle_probes.request_throttled.fire(function () {
             return ([self.requestQueue.npending, self.requestQueue.length(),
@@ -160,29 +248,45 @@ Throttle.prototype.wait = function wait(req, res, next) {
             queueTolerance: self.queueTolerance,
             concurrency: self.concurrency
         };
-        next(new VError(new ThrottledError(), 'muskie throttled this ' +
-                    'request. observed: %j, configured with: %j', state,
-                    cfg));
+
+        self.log.debug({
+            reqid: req.getId(),
+            queued: self.requestQueue.npending,
+            inFlight: self.requestQueue.length(),
+            concurrency: self.concurrency,
+            queueTolerance: self.queueTolerance
+        }, 'request throttled');
+
+        next(new VError(new ThrottledError(), 'muskie throttled request %s.' +
+            'observed: %j, configured with: %j', req.getId(), state, cfg));
         return;
     }
 
-    var req_id = req.getId();
+    assert.ok(Object.keys(self.requestMap).length <= self.concurrency,
+            'fewer than concurrency callbacks');
 
     self.throttle_probes.queue_enter.fire(function () {
-        return ([req_id]);
+        return ([req.getId()]);
     });
 
     self.requestQueue.push(function (cb) {
+        assert.ok(!self.requestMap[req.getId()],
+            'throttle callback for ' + req.getId() + ' already registered');
+
+        self.requestMap[req.getId()] = {
+            req: req,
+            res: res,
+            cb: once(cb)
+        };
+
+        self.log.debug({
+            reqid: req.getId()
+        }, 'insert to throttle request map');
+
         self.throttle_probes.queue_leave.fire(function () {
-            return ([req_id]);
+            return ([req.getId()]);
         });
         next();
-        cb();
-    });
-
-    self.throttle_probes.request_handled.fire(function () {
-        return ([self.requestQueue.npending, self.requestQueue.length(),
-            req.url, req.method]);
     });
 };
 
@@ -195,11 +299,10 @@ module.exports = {
         return (new Throttle(options));
     },
 
-    throttleHandler: function (throttle) {
-        function throttleRequest(req, res, next) {
+    getRestifyThrottleHandle: function getHandle(throttle) {
+        function handle(req, res, next) {
             throttle.wait(req, res, next);
         }
-        return (throttleRequest);
+        return (handle);
     }
-
 };
-- 
2.21.0

