From 301f1fe348f0dd1cb96697e251596f94a8c865ff Mon Sep 17 00:00:00 2001
From: Jan Wyszynski <jan.wyszynski@joyent.com>
Date: Fri, 2 Mar 2018 01:03:29 +0000
Subject: [PATCH] MANTA-3591 muskie throttle doesn't enforce concurrency
 properly

---
 lib/server.js   |  8 ++++--
 lib/throttle.js | 74 +++++++++++++++++++++++++++++++++++++++----------
 2 files changed, 66 insertions(+), 16 deletions(-)

diff --git a/lib/server.js b/lib/server.js
index df6a1d1..7b25b83 100644
--- a/lib/server.js
+++ b/lib/server.js
@@ -248,8 +248,12 @@ function createServer(options, clients, name) {
 
     if (options.throttle.enabled) {
         options.throttle.log = options.log;
-        var throttleHandle = throttle.createThrottle(options.throttle);
-        server.use(throttle.throttleHandler(throttleHandle));
+        options.throttle.server = server;
+
+        var thrtl = throttle.createThrottle(options.throttle);
+        server.use(throttle.getRestifyThrottleHandle(thrtl));
+
+        log.info('registered throttle handler');
     }
     server.use(auth.authenticationHandler({
         log: log,
diff --git a/lib/throttle.js b/lib/throttle.js
index 82cd5b4..e7c44b1 100644
--- a/lib/throttle.js
+++ b/lib/throttle.js
@@ -108,8 +108,14 @@ function Throttle(options) {
     assert.ok(options.log, 'options.log');
     assert.number(options.queueTolerance, 'options.queueTolerance');
     assert.ok(options.queueTolerance > 0, 'queueTolerance must be positive');
+    assert.ok(options.server, 'restify server');
 
-    this.log = options.log.child({ component: 'throttle'}, true);
+    this.log = options.log.child({
+        component: 'Throttle'
+    });
+
+    this.server = options.server;
+    this.server.callbacks = {};
 
     this.dtp = dtrace.createDTraceProvider('muskie-throttle');
     this.throttle_probes = {
@@ -135,6 +141,34 @@ function Throttle(options) {
     this.requestQueue = vasync.queue(function (task, callback) {
         task(callback);
     }, this.concurrency);
+
+    var self = this;
+
+    function clearQueueSlot(req, _) {
+        var id = req.getId();
+        var cb = self.server.callbacks[id];
+
+        assert.func(cb, 'throttle callback');
+        delete (self.server.callbacks[id]);
+
+        self.log.debug({
+            reqid: id
+        }, 'removed callback for request');
+
+        self.throttle_probes.request_handled.fire(function () {
+            return ([self.requestQueue.npending, self.requestQueue.length(),
+                req.url, req.method]);
+        });
+
+        cb();
+    }
+
+    /*
+     * Every restify request route end with exactly one of these events being
+     * emitted. Note that 'handleUncaughtExceptions' is deprecated as of 5.x.
+     */
+    this.server.on('after', clearQueueSlot);
+    this.server.on('uncaughtException', clearQueueSlot);
 }
 
 Throttle.prototype.wait = function wait(req, res, next) {
@@ -160,12 +194,23 @@ Throttle.prototype.wait = function wait(req, res, next) {
             queueTolerance: self.queueTolerance,
             concurrency: self.concurrency
         };
-        next(new VError(new ThrottledError(), 'muskie throttled this ' +
-                    'request. observed: %j, configured with: %j', state,
-                    cfg));
+
+        self.log.debug({
+            reqid: req.getId(),
+            queued: self.requestQueue.npending,
+            inFlight: self.requestQueue.length(),
+            concurrency: self.concurrency,
+            queueTolerance: self.queueTolerance
+        }, 'request throttled');
+
+        next(new VError(new ThrottledError(), 'muskie throttled request %s.' +
+            'observed: %j, configured with: %j', req.getId(), state, cfg));
         return;
     }
 
+    assert.ok(Object.keys(self.server.callbacks).length <= self.concurrency,
+            'fewer than concurrency callbacks');
+
     var req_id = req.getId();
 
     self.throttle_probes.queue_enter.fire(function () {
@@ -173,16 +218,18 @@ Throttle.prototype.wait = function wait(req, res, next) {
     });
 
     self.requestQueue.push(function (cb) {
+        assert.ok(!self.server.callbacks[req_id],
+            'throttle callback for ' + req_id + ' already registered');
+        self.server.callbacks[req_id] = cb;
+
+        self.log.debug({
+            reqid: req_id
+        }, 'added callback for request');
+
         self.throttle_probes.queue_leave.fire(function () {
             return ([req_id]);
         });
         next();
-        cb();
-    });
-
-    self.throttle_probes.request_handled.fire(function () {
-        return ([self.requestQueue.npending, self.requestQueue.length(),
-            req.url, req.method]);
     });
 };
 
@@ -195,11 +242,10 @@ module.exports = {
         return (new Throttle(options));
     },
 
-    throttleHandler: function (throttle) {
-        function throttleRequest(req, res, next) {
+    getRestifyThrottleHandle: function getHandle(throttle) {
+        function handle(req, res, next) {
             throttle.wait(req, res, next);
         }
-        return (throttleRequest);
+        return (handle);
     }
-
 };
-- 
2.21.0

