commit 6afd3b08b2bd4482425be9e5e425348e0bacbcc2 (refs/changes/27/3527/1)
Author: Jan Wyszynski <jan.wyszynski@joyent.com>
Date:   2018-03-02T01:03:29+00:00 (1 year, 7 months ago)
    
    MANTA-3591 muskie throttle doesn't enforce concurrency properly

diff --git a/lib/server.js b/lib/server.js
index df6a1d1..7b25b83 100644
--- a/lib/server.js
+++ b/lib/server.js
@@ -248,8 +248,12 @@ function createServer(options, clients, name) {
 
     if (options.throttle.enabled) {
         options.throttle.log = options.log;
-        var throttleHandle = throttle.createThrottle(options.throttle);
-        server.use(throttle.throttleHandler(throttleHandle));
+        options.throttle.server = server;
+
+        var thrtl = throttle.createThrottle(options.throttle);
+        server.use(throttle.getRestifyThrottleHandle(thrtl));
+
+        log.info('registered throttle handler');
     }
     server.use(auth.authenticationHandler({
         log: log,
diff --git a/lib/throttle.js b/lib/throttle.js
index 82cd5b4..a1e8fd2 100644
--- a/lib/throttle.js
+++ b/lib/throttle.js
@@ -108,8 +108,14 @@ function Throttle(options) {
     assert.ok(options.log, 'options.log');
     assert.number(options.queueTolerance, 'options.queueTolerance');
     assert.ok(options.queueTolerance > 0, 'queueTolerance must be positive');
+    assert.ok(options.server, 'restify server');
 
-    this.log = options.log.child({ component: 'throttle'}, true);
+    this.log = options.log.child({
+        component: 'Throttle'
+    });
+
+    this.server = options.server;
+    this.server.callbacks = {};
 
     this.dtp = dtrace.createDTraceProvider('muskie-throttle');
     this.throttle_probes = {
@@ -135,6 +141,27 @@ function Throttle(options) {
     this.requestQueue = vasync.queue(function (task, callback) {
         task(callback);
     }, this.concurrency);
+
+    var self = this;
+
+    this.server.on('after', function (reqAfter) {
+        var id = reqAfter.getId();
+        var cb = self.server.callbacks[id];
+
+        assert.func(cb, 'throttle callback');
+        delete (self.server.callbacks[id]);
+
+        self.log.debug({
+            reqid: id
+        }, 'removed callback for request');
+
+        self.throttle_probes.request_handled.fire(function () {
+            return ([self.requestQueue.npending, self.requestQueue.length(),
+                reqAfter.url, reqAfter.method]);
+        });
+
+        cb();
+    });
 }
 
 Throttle.prototype.wait = function wait(req, res, next) {
@@ -160,12 +187,23 @@ Throttle.prototype.wait = function wait(req, res, next) {
             queueTolerance: self.queueTolerance,
             concurrency: self.concurrency
         };
-        next(new VError(new ThrottledError(), 'muskie throttled this ' +
-                    'request. observed: %j, configured with: %j', state,
-                    cfg));
+
+        self.log.debug({
+            reqid: req.getId(),
+            queued: self.requestQueue.npending,
+            inFlight: self.requestQueue.length(),
+            concurrency: self.concurrency,
+            queueTolerance: self.queueTolerance
+        }, 'request throttled');
+
+        next(new VError(new ThrottledError(), 'muskie throttled request %s.' +
+            'observed: %j, configured with: %j', req.getId(), state, cfg));
         return;
     }
 
+    assert.ok(Object.keys(self.server.callbacks).length <= self.concurrency,
+            'fewer than concurrency callbacks');
+
     var req_id = req.getId();
 
     self.throttle_probes.queue_enter.fire(function () {
@@ -173,16 +211,18 @@ Throttle.prototype.wait = function wait(req, res, next) {
     });
 
     self.requestQueue.push(function (cb) {
+        assert.ok(!self.server.callbacks[req_id],
+            'throttle callback for ' + req_id + ' already registered');
+        self.server.callbacks[req_id] = cb;
+
+        self.log.debug({
+            reqid: req_id
+        }, 'added callback for request');
+
         self.throttle_probes.queue_leave.fire(function () {
             return ([req_id]);
         });
         next();
-        cb();
-    });
-
-    self.throttle_probes.request_handled.fire(function () {
-        return ([self.requestQueue.npending, self.requestQueue.length(),
-            req.url, req.method]);
     });
 };
 
@@ -195,11 +235,10 @@ module.exports = {
         return (new Throttle(options));
     },
 
-    throttleHandler: function (throttle) {
-        function throttleRequest(req, res, next) {
+    getRestifyThrottleHandle: function getHandle(throttle) {
+        function handle(req, res, next) {
             throttle.wait(req, res, next);
         }
-        return (throttleRequest);
+        return (handle);
     }
-
 };
