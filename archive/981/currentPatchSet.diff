commit 0fc12c0d041ba827ff8bc2007abe8fbe49b78cb3 (refs/changes/81/981/1)
Author: Trent Mick <trentm@gmail.com>
Date:   2016-11-30T13:56:05-05:00 (2 years, 10 months ago)
    
    refactor to require separate '.init' and '.keyPair.unlock()' of the tritonapi; get 'triton package list' doing things

diff --git a/CHANGES.md b/CHANGES.md
index a67065a..24741ef 100644
--- a/CHANGES.md
+++ b/CHANGES.md
@@ -7,6 +7,61 @@ Known issues:
 
 ## not yet released
 
+- **BREAKING CHANGE for module usage of node-triton.**
+  To implement joyent/node-triton#108, the way a TritonApi client is
+  setup for use has changed from being sync to async. Therefore what
+  used to be:
+
+        var triton = require('triton');
+        var client = triton.createClient({      # No longer works.
+            profile: {
+                url: "<cloudapi url>",
+                account: "<account login for this cloud>",
+                keyId: "<ssh key fingerprint for one of account's keys>"
+            }
+        });
+
+  is now:
+
+        var triton = require('triton');
+        triton.createClient({
+            profile: {
+                url: "<cloudapi url>",
+                account: "<account login for this cloud>",
+                keyId: "<ssh key fingerprint for one of account's keys>"
+            }
+        }, function (initErr, client) {
+            if (initErr) boom(initErr);
+
+            triton.promptPassphraseUnlockKey({
+                tritonapi: client
+            }, function (unlockErr) {
+                if (unlockErr) boom(unlockErr);
+
+                // Use `client`...
+            });
+        });
+
+  First, the initialization done by `createClient` is async as it always should
+  have been, to find a matching SSH key for the given `keyId`. Second, in the
+  case where an encrypted SSH private key is specified (which isn't in an
+  ssh-agent), one needs to manually unlock it with its passphrase. The
+  new `triton.promptPassphraseUnlockKey` is a convenience function for this.
+  See full `TritonApi` setup details in the top comment in
+  [lib/tritonapi.js](lib/tritonapi.js).
+
+- joyent/node-triton#108 Support for passphrase-protected private keys.
+  Before this work, an encrypted private SSH key (i.e. protected by a
+  passphrase) would have to be loaded in an ssh-agent for the `triton`
+  CLI to use it. Now `triton` will prompt for the passphrase to unlock
+  the private key (in memory), if needed. For example:
+
+        $ triton package list
+        Enter passphrase for id_rsa:
+        SHORTID   NAME             MEMORY  SWAP  DISK  VCPUS
+        14ad9d54  g4-highcpu-128M    128M  512M    3G      -
+        14ae2634  g4-highcpu-256M    256M    1G    5G      -
+        ...
 - [joyent/node-triton#143] Fix duplicate output from 'triton rbac key ...'.
 
 ## 4.15.0
diff --git a/lib/cli.js b/lib/cli.js
index f9ecb68..900e05c 100644
--- a/lib/cli.js
+++ b/lib/cli.js
@@ -28,7 +28,7 @@ var getpass = require('getpass');
 var common = require('./common');
 var mod_config = require('./config');
 var errors = require('./errors');
-var tritonapi = require('./tritonapi');
+var lib_tritonapi = require('./tritonapi');
 
 
 
@@ -159,7 +159,7 @@ var OPTIONS = [
         help: 'A cloudapi API version, or semver range, to attempt to use. ' +
             'This is passed in the "Accept-Version" header. ' +
             'See `triton cloudapi /--ping` to list supported versions. ' +
-            'The default is "' + tritonapi.CLOUDAPI_ACCEPT_VERSION + '". ' +
+            'The default is "' + lib_tritonapi.CLOUDAPI_ACCEPT_VERSION + '". ' +
             '*This is intended for development use only. It could cause ' +
             '`triton` processing of responses to break.*',
         hidden: true
@@ -303,66 +303,45 @@ CLI.prototype.init = function (opts, args, callback) {
         return self._profile;
     });
 
-    this.__defineGetter__('tritonapi', function getTritonapi() {
-        if (self._tritonapiErr !== undefined) {
-            throw self._tritonapiErr;
-        }
-        return self._tritonapi;
-    });
-
     try {
-        var tc = tritonapi.createClient({
+        self.tritonapi = lib_tritonapi.createClient({
             log: self.log,
             profile: self.profile,
-            config: self.config,
-            getPassphrase: getpass.getPass
+            config: self.config
         });
-    } catch (err) {
-        self._tritonapiErr = err;
-        initBase();
+    } catch (createErr) {
+        callback(createErr);
         return;
     }
 
-    tc.init(function (err) {
-        if (err) {
-            self._tritonapiErr = err;
-            initBase();
-            return;
-        }
-        self._tritonapi = tc;
-        initBase();
-    });
-
-    function initBase() {
-        if (process.env.TRITON_COMPLETE) {
-            /*
-             * If `TRITON_COMPLETE=<type>` is set (typically only in the
-             * Triton CLI bash completion driver, see
-             * "etc/triton-bash-completion-types.sh"), then Bash completions are
-             * fetched and printed, instead of the usual subcommand handling.
-             *
-             * Completion results are typically cached (under "~/.triton/cache")
-             * to avoid hitting the server for data everytime.
-             *
-             * Example usage:
-             *      TRITON_COMPLETE=images triton -p my-profile create
-             */
-            self._emitCompletions(process.env.TRITON_COMPLETE, function (err) {
-                callback(err || false);
-            });
-        } else {
-            // Cmdln class handles `opts.help`.
-            Cmdln.prototype.init.call(self, opts, args, callback);
-        }
+    if (process.env.TRITON_COMPLETE) {
+        /*
+         * If `TRITON_COMPLETE=<type>` is set (typically only in the
+         * Triton CLI bash completion driver, see
+         * "etc/triton-bash-completion-types.sh"), then Bash completions are
+         * fetched and printed, instead of the usual subcommand handling.
+         *
+         * Completion results are typically cached (under "~/.triton/cache")
+         * to avoid hitting the server for data everytime.
+         *
+         * Example usage:
+         *      TRITON_COMPLETE=images triton -p my-profile create
+         */
+        self._emitCompletions(process.env.TRITON_COMPLETE, function (err) {
+            callback(err || false);
+        });
+    } else {
+        // Cmdln class handles `opts.help`.
+        Cmdln.prototype.init.call(self, opts, args, callback);
     }
 };
 
 
 CLI.prototype.fini = function fini(subcmd, err, cb) {
     this.log.trace({err: err, subcmd: subcmd}, 'cli fini');
-    if (this._tritonapi) {
-        this._tritonapi.close();
-        delete this._tritonapi;
+    if (this.tritonapi) {
+        this.tritonapi.close();
+        delete this.tritonapi;
     }
     cb();
 };
@@ -624,7 +603,7 @@ CLI.prototype.tritonapiFromProfileName =
             'tritonapiFromProfileName: loaded profile');
     }
 
-    return tritonapi.createClient({
+    return lib_tritonapi.createClient({
         log: this.log,
         profile: profile,
         config: this.config,
diff --git a/lib/cloudapi2.js b/lib/cloudapi2.js
index 7139f0a..4a5a9a5 100644
--- a/lib/cloudapi2.js
+++ b/lib/cloudapi2.js
@@ -180,55 +180,15 @@ CloudApi.prototype._getAuthHeaders =
             sign: this.principal.sign
         });
     } else if (this.principal.keyPair !== undefined) {
-        var kp = this.principal.keyPair;
-        /*
-         * This is a bit of a failure of abstraction. Historically we've
-         * assumed that everything to do with the cloudapi client other than
-         * making a request is purely sync, but prompting for a password is
-         * async. So without massive changes to all the commands, we have to
-         * handle unlocking keys at request time, here.
-         */
-        if (kp.isLocked() && this._getPassphrase !== undefined) {
-            if (this._asking !== undefined) {
-                this._asking.on('done', function () {
-                    self._getAuthHeaders(method, path, callback);
-                });
-                return;
-            }
-            var asking = (this._asking = new EventEmitter());
-            var opts = {};
-            opts.prompt = 'Passphrase to unlock ';
-            if (kp.source !== undefined) {
-                opts.prompt += kp.source;
-            } else if (kp.comment !== undefined && kp.comment.length > 1) {
-                opts.prompt += kp.getPublicKey().type.toUpperCase() +
-                    ' key for ' + kp.comment;
-            } else {
-                opts.prompt += kp.getPublicKey().type.toUpperCase() +
-                    ' key ' + kp.getKeyId();
-            }
-            this._getPassphrase(opts, tryPass);
-            function tryPass(err, pass) {
-                if (err) {
-                    callback(err);
-                    return;
-                }
-                try {
-                    kp.unlock(pass);
-                } catch (e) {
-                    self._getPassphrase(opts, tryPass);
-                    return;
-                }
-                delete (self._asking);
-                self._getAuthHeaders(method, path, callback);
-                asking.emit('done');
-            }
+        try {
+            rs = this.principal.keyPair.createRequestSigner({
+                user: this.principal.account,
+                subuser: this.principal.user
+            });
+        } catch (signerErr) {
+            callback(new errors.SigningError(signerErr));
             return;
         }
-        rs = this.principal.keyPair.createRequestSigner({
-            user: this.principal.account,
-            subuser: this.principal.user
-        });
     }
 
     rs.writeTarget(method, path);
diff --git a/lib/common.js b/lib/common.js
index 8f0d84a..3c259ae 100644
--- a/lib/common.js
+++ b/lib/common.js
@@ -12,6 +12,7 @@ var assert = require('assert-plus');
 var child_process = require('child_process');
 var crypto = require('crypto');
 var fs = require('fs');
+var getpass = require('getpass');
 var os = require('os');
 var path = require('path');
 var read = require('read');
@@ -678,6 +679,93 @@ function promptField(field, cb) {
 }
 
 
+/**
+ * A utility method to unlock a private key on a TritonApi client instance,
+ * if necessary.
+ *
+ * If the client's key is locked, this will prompt for the passphrase on the
+ * TTY (via the `getpass` module) and attempt to unlock.
+ *
+ * @param opts {Object}
+ *      - opts.tritonapi {Object} An `.init()`ialized TritonApi instance.
+ * @param cb {Function} `function (err)`
+ */
+function promptPassphraseUnlockKey(opts, cb) {
+    assert.object(opts.tritonapi, 'opts.tritonapi');
+
+    var kp = opts.tritonapi.keyPair;
+    if (!kp) {
+        cb(new errors.InternalError('TritonApi instance given to '
+            + 'promptPassphraseUnlockKey is not initialized'));
+        return;
+    }
+
+    if (!kp.isLocked()) {
+        cb();
+        return;
+    }
+
+    var keyDesc;
+    if (kp.source !== undefined) {
+        keyDesc = kp.source;
+    } else if (kp.comment !== undefined && kp.comment.length > 1) {
+        keyDesc = kp.getPublicKey().type.toUpperCase() +
+            ' key for ' + kp.comment;
+    } else {
+        keyDesc = kp.getPublicKey().type.toUpperCase() +
+            ' key ' + kp.getKeyId();
+    }
+    var getpassOpts = {
+        prompt: 'Enter passphrase for ' + keyDesc
+    };
+
+    var tryPass = function (err, pass) {
+        if (err) {
+            cb(err);
+            return;
+        }
+
+        try {
+            kp.unlock(pass);
+        } catch (unlockErr) {
+            getpassOpts.prompt = 'Bad passphrase, try again for ' + keyDesc;
+            getpass.getPass(getpassOpts, tryPass);
+            return;
+        }
+
+        cb(null);
+    }
+
+    getpass.getPass(getpassOpts, tryPass);
+}
+
+
+/*
+ * A utility for the `triton` CLI subcommands to `init()`ialize the CLI's
+ * `tritonapi` instance and ensure that the profile's key is unlocked
+ * (prompting on a TTY if necessary).
+ *
+ * @param opts.cli {Object}
+ * @param cb {Function} `function (err)`
+ */
+function cliSetupTritonApi(opts, cb) {
+    assert.object(opts.cli, 'opts.cli');
+
+    opts.cli.tritonapi.init(function (initErr) {
+        if (initErr) {
+            cb(initErr);
+            return;
+        }
+
+        promptPassphraseUnlockKey({
+            tritonapi: opts.cli.tritonapi
+        }, function (keyErr) {
+            cb(keyErr);
+        });
+    });
+}
+
+
 /**
  * Edit the given text in $EDITOR (defaulting to `vi`) and return the edited
  * text.
@@ -984,6 +1072,8 @@ module.exports = {
     promptYesNo: promptYesNo,
     promptEnter: promptEnter,
     promptField: promptField,
+    promptPassphraseUnlockKey: promptPassphraseUnlockKey,
+    cliSetupTritonApi: cliSetupTritonApi,
     editInEditor: editInEditor,
     ansiStylize: ansiStylize,
     indent: indent,
diff --git a/lib/do_package/do_list.js b/lib/do_package/do_list.js
index b7ba5a0..d9166ae 100644
--- a/lib/do_package/do_list.js
+++ b/lib/do_package/do_list.js
@@ -11,6 +11,7 @@
  */
 
 var tabula = require('tabula');
+var vasync = require('vasync');
 
 var common = require('../common');
 
@@ -68,73 +69,89 @@ function do_list(subcmd, opts, args, callback) {
         return;
     }
 
-    this.top.tritonapi.cloudapi.listPackages(listOpts, function (err, pkgs) {
-        if (err) {
-            callback(err);
-            return;
-        }
-        if (opts.json) {
-            common.jsonStream(pkgs);
-        } else {
-            for (i = 0; i < pkgs.length; i++) {
-                var pkg = pkgs[i];
-                pkg.shortid = pkg.id.split('-', 1)[0];
-
-                /*
-                 * We take a slightly "smarter" view of "group" for default
-                 * sorting, to accomodate usage in the JPC. More recent
-                 * common usage is for packages to have "foo-*" naming.
-                 * JPC includes package sets of yore *and* recent that don't
-                 * use the "group" field. We secondarily separate those
-                 * on a possible "foo-" prefix.
-                 */
-                pkg._groupPlus = (pkg.group || (pkg.name.indexOf('-') === -1
-                    ? '' : pkg.name.split('-', 1)[0]));
-
-                if (!opts.p) {
-                    pkg.memoryHuman = common.humanSizeFromBytes({
-                        precision: 1,
-                        narrow: true
-                    }, pkg.memory * 1024 * 1024);
-                    pkg.swapHuman = common.humanSizeFromBytes({
-                        precision: 1,
-                        narrow: true
-                    }, pkg.swap * 1024 * 1024);
-                    pkg.diskHuman = common.humanSizeFromBytes({
-                        precision: 1,
-                        narrow: true
-                    }, pkg.disk * 1024 * 1024);
-                    pkg.vcpusHuman = pkg.vcpus === 0 ? '-' : pkg.vcpus;
+    var context = {
+        cli: this.top
+    };
+    vasync.pipeline({arg: context, funcs: [
+        common.cliSetupTritonApi,
+
+        function getThem(arg, next) {
+            arg.cli.tritonapi.cloudapi.listPackages(listOpts,
+                function (err, pkgs) {
+                    if (err) {
+                        next(err);
+                        return;
+                    }
+                    arg.pkgs = pkgs;
+                    next();
                 }
-            }
-            if (!opts.p) {
-                columns = columns.map(function (c) {
-                    switch (c.lookup || c) {
-                    case 'memory':
-                        return {lookup: 'memoryHuman', name: 'MEMORY',
-                            align: 'right'};
-                    case 'swap':
-                        return {lookup: 'swapHuman', name: 'SWAP',
-                            align: 'right'};
-                    case 'disk':
-                        return {lookup: 'diskHuman', name: 'DISK',
-                            align: 'right'};
-                    case 'vcpus':
-                        return {lookup: 'vcpusHuman', name: 'VCPUS',
-                            align: 'right'};
-                    default:
-                        return c;
+            );
+        },
+
+        function display(arg, next) {
+            if (opts.json) {
+                common.jsonStream(arg.pkgs);
+            } else {
+                for (i = 0; i < arg.pkgs.length; i++) {
+                    var pkg = arg.pkgs[i];
+                    pkg.shortid = pkg.id.split('-', 1)[0];
+
+                    /*
+                     * We take a slightly "smarter" view of "group" for default
+                     * sorting, to accomodate usage in the JPC. More recent
+                     * common usage is for packages to have "foo-*" naming.
+                     * JPC includes package sets of yore *and* recent that don't
+                     * use the "group" field. We secondarily separate those
+                     * on a possible "foo-" prefix.
+                     */
+                    pkg._groupPlus = (pkg.group || (pkg.name.indexOf('-') === -1
+                        ? '' : pkg.name.split('-', 1)[0]));
+
+                    if (!opts.p) {
+                        pkg.memoryHuman = common.humanSizeFromBytes({
+                            precision: 1,
+                            narrow: true
+                        }, pkg.memory * 1024 * 1024);
+                        pkg.swapHuman = common.humanSizeFromBytes({
+                            precision: 1,
+                            narrow: true
+                        }, pkg.swap * 1024 * 1024);
+                        pkg.diskHuman = common.humanSizeFromBytes({
+                            precision: 1,
+                            narrow: true
+                        }, pkg.disk * 1024 * 1024);
+                        pkg.vcpusHuman = pkg.vcpus === 0 ? '-' : pkg.vcpus;
                     }
+                }
+                if (!opts.p) {
+                    columns = columns.map(function (c) {
+                        switch (c.lookup || c) {
+                        case 'memory':
+                            return {lookup: 'memoryHuman', name: 'MEMORY',
+                                align: 'right'};
+                        case 'swap':
+                            return {lookup: 'swapHuman', name: 'SWAP',
+                                align: 'right'};
+                        case 'disk':
+                            return {lookup: 'diskHuman', name: 'DISK',
+                                align: 'right'};
+                        case 'vcpus':
+                            return {lookup: 'vcpusHuman', name: 'VCPUS',
+                                align: 'right'};
+                        default:
+                            return c;
+                        }
+                    });
+                }
+                tabula(arg.pkgs, {
+                    skipHeader: opts.H,
+                    columns: columns,
+                    sort: sort
                 });
             }
-            tabula(pkgs, {
-                skipHeader: opts.H,
-                columns: columns,
-                sort: sort
-            });
+            next();
         }
-        callback();
-    });
+    ]}, callback);
 }
 
 do_list.options = [
diff --git a/lib/index.js b/lib/index.js
index c050222..6b80803 100644
--- a/lib/index.js
+++ b/lib/index.js
@@ -11,41 +11,75 @@
 var assert = require('assert-plus');
 
 var bunyannoop = require('./bunyannoop');
+var common = require('./common');
 var mod_config = require('./config');
 var tritonapi = require('./tritonapi');
 
 
 /**
- * A convenience wrapper around `tritonapi.createClient` to for simpler usage.
+ * A convenience wrapper around `tritonapi.createClient` for simpler usage.
+ * There are two steps: (1) create and init the TritonApi instance,
+ * (2) unlock the key used for authentication if necessary.
+ *
+ *
+ * # 1. Create and init the TritonApi client instance
  *
  * Minimally this only requires that one of `profileName` or `profile` be
  * specified. Examples:
  *
  *      var triton = require('triton');
- *      var client = triton.createClient({
+ *      triton.createClient({
  *          profile: {
  *              url: "<cloudapi url>",
  *              account: "<account login for this cloud>",
  *              keyId: "<ssh key fingerprint for one of account's keys>"
  *          }
- *      });
+ *      }, function (err, client) { ... });
  *      --
  *      // Loading a profile from the environment (the `TRITON_*` and/or
  *      // `SDC_*` environment variables).
- *      var client = triton.createClient({profileName: 'env'});
+ *      triton.createClient({profileName: 'env'},
+ *          function (err, client) { ... });
  *      --
- *      var client = triton.createClient({
+ *      triton.createClient({
  *          configDir: '~/.triton',     // use the CLI's config dir ...
  *          profileName: 'east1'        // ... to find named profiles
- *      });
+ *      }, function (err, client) { ... });
  *      --
  *      // The same thing using the underlying APIs.
- *      var client = triton.createClient({
- *          config: triton.loadConfig({configDir: '~/.triton'},
+ *      triton.createClient({
+ *          config: triton.loadConfig({configDir: '~/.triton'}),
  *          profile: triton.loadProfile({name: 'east1', configDir: '~/.triton'})
+ *      }, function (err, client) { ... });
+ *
+ * TODO: The story for an app wanting to specify some Triton config but NOT
+ * have to have a triton $configDir/config.json is poor.
+ *
+ *
+ * # 2. Unlock the auth key
+ *
+ * Triton uses HTTP-Signature auth, where an SSH private key is used to
+ * sign requests. The server-side authenticates by verifying that signature
+ * using the previous uploaded public key. For the client to sign a request
+ * it needs an unlocked private key: an SSH private key that (a) has no
+ * passphrase, (b) is loaded in an ssh-agent, or (c) a passphrase to unlock
+ * the key. This step is about case (c).
+ *
+ * The `triton` CLI uses the `mod_triton.promptPassphraseUnlockKey` convenience
+ * function to prompt on a TTY for the passphrase, if necessary. Effectively
+ * like this:
+ *
+ *      triton.promptPassphraseUnlockKey({
+ *          tritonapi: client
+ *      }, function (unlockErr) {
+ *          if (unlockErr) boom(unlockErr);
+ *
+ *          // Now you can finally make an API call.
+ *          // ...
  *      });
  *
- * A more complete example an app using triton internally might want:
+ *
+ * # A more complete example
  *
  *      var triton = require('triton');
  *      var bunyan = require('bunyan');
@@ -54,14 +88,22 @@ var tritonapi = require('./tritonapi');
  *          // However the app handles its config.
  *      };
  *      var log = bunyan.createLogger({name: 'myapp', component: 'triton'});
- *      var client = triton.createClient({
+ *
+ *      triton.createClient({
  *          log: log,
  *          profile: appConfig.tritonProfile
- *      });
+ *      }, function (initErr, client) {
+ *          if (initErr) boom(initErr);
  *
+ *          triton.promptPassphraseUnlockKey({
+ *              tritonapi: client
+ *          }, function (unlockErr) {
+ *              if (unlockErr) boom(unlockErr);
+ *
+ *              // ...
+ *          });
+ *      });
  *
- * TODO: The story for an app wanting to specify some Triton config but NOT
- * have to have a triton $configDir/config.json is poor.
  *
  * @param opts {Object}:
  *      - @param profile {Object} A *Triton profile* object that includes the
@@ -149,6 +191,7 @@ function createClient(opts) {
 
 module.exports = {
     createClient: createClient,
+    promptPassphraseUnlockKey: common.promptPassphraseUnlockKey,
 
     /**
      * `createClient` provides convenience parameters to not *have* to call
diff --git a/lib/tritonapi.js b/lib/tritonapi.js
index 2778793..36868a9 100644
--- a/lib/tritonapi.js
+++ b/lib/tritonapi.js
@@ -8,6 +8,41 @@
  * Copyright 2016 Joyent, Inc.
  *
  * Core TritonApi client driver class.
+ *
+ * Usage:
+ *      // 1. Create the TritonApi instance.
+ *      var tritonapi = lib_tritonapi.createClient({
+ *          log: self.log,
+ *          profile: self.profile,
+ *          config: self.config
+ *      });
+ *
+ *      // 2. Call `init` to setup the profile. This involves finding the SSH
+ *      //    key identified by the profiles keyId.
+ *      tritonapi.init(function (initErr) {
+ *          if (initErr) boom();
+ *
+ *          // 3a. If/when ready to make a signed request, it is up to the
+ *          //    caller to ensure the signing SSH key is unlocked. Either
+ *          //    like this:
+ *          if (tritonapi.keyPair.isLocked()) {
+ *              // This throws if the passphrase is incorrect.
+ *              tritonapi.keyPair.unlock(passphrase);
+ *          }
+ *
+ *          // 3b. Or via a provided helper that uses `getpass` to prompt
+ *          //    the user on a TTY:
+ *          lib_common.promptPassphraseUnlockKey({
+ *              tritonapi: tritonapi
+ *          }, function (unlockErr) {
+ *              if (unlockErr) boom(unlockErr);
+ *
+ *              // 4. Now you can finally make an API call. For example:
+ *              tritonapi.listImages(function (err, imgs) {
+ *                  // ...
+ *              });
+ *          });
+ *      });
  */
 
 var assert = require('assert-plus');
@@ -117,6 +152,14 @@ function _stepFwRuleId(arg, next) {
 /**
  * Create a TritonApi client.
  *
+ * Public properties (TODO: doc all of these):
+ *      - profile
+ *      - config
+ *      - log
+ *      - cacheDir (only available if configured with a configDir)
+ *      - keyPair (available after init)
+ *      - cloudapi (available after init)
+ *
  * @param opts {Object}
  *      - log {Bunyan Logger}
  *      ...
@@ -129,6 +172,7 @@ function TritonApi(opts) {
 
     this.profile = opts.profile;
     this.config = opts.config;
+    this.keyPair = null;
 
     assert.optionalFunc(opts.getPassphrase);
     this._getPassphrase = opts.getPassphrase;
@@ -156,8 +200,10 @@ function TritonApi(opts) {
 
 
 TritonApi.prototype.close = function close() {
-    this.cloudapi.close();
-    delete this.cloudapi;
+    if (this.cloudapi) {
+        this.cloudapi.close();
+        delete this.cloudapi;
+    }
 };
 
 
@@ -213,7 +259,7 @@ TritonApi.prototype._setupProfile = function _setupProfile(cb) {
 
     if (profile.privKey) {
         var key = sshpk.parsePrivateKey(profile.privKey);
-        opts.principal.keyPair = auth.KeyPair.fromPrivateKey(key);
+        this.keyPair = opts.principal.keyPair = auth.KeyPair.fromPrivateKey(key);
         this.cloudapi = cloudapi.createClient(opts);
         cb(null);
     } else {
@@ -224,7 +270,7 @@ TritonApi.prototype._setupProfile = function _setupProfile(cb) {
                 cb(err);
                 return;
             }
-            opts.principal.keyPair = kp;
+            self.keyPair = opts.principal.keyPair = kp;
             self.cloudapi = cloudapi.createClient(opts);
             cb(null);
         });
