From 6d0f79951d9be157d286990c3fbff323c635f53a Mon Sep 17 00:00:00 2001
From: Rob Johnston <rob.johnston@joyent.com>
Date: Mon, 12 Feb 2018 18:21:14 +0000
Subject: [PATCH] OS-6560 Extend smbios enumerator module to enumerate
 motherboard

---
 usr/src/lib/fm/topo/libtopo/common/topo_hc.h  |  11 +-
 ...yent-Storage-Platform-7001-hc-topology.xml |   3 +-
 .../SSG-2028R-ACR24L-hc-topology.xml          |   3 +-
 .../topo/modules/common/smbios/smbios_enum.c  | 142 +++++++++++++++++-
 usr/src/uts/common/sys/smbios.h               |   3 +-
 5 files changed, 155 insertions(+), 7 deletions(-)

diff --git a/usr/src/lib/fm/topo/libtopo/common/topo_hc.h b/usr/src/lib/fm/topo/libtopo/common/topo_hc.h
index 8a4df466a9..44dbe97c34 100644
--- a/usr/src/lib/fm/topo/libtopo/common/topo_hc.h
+++ b/usr/src/lib/fm/topo/libtopo/common/topo_hc.h
@@ -223,7 +223,8 @@ extern "C" {
 #define	TOPO_DIMM_SLOT_FORM_DIMM	"DIMM"
 #define	TOPO_DIMM_SLOT_FORM_SODIMM	"SODIMM"
 #define	TOPO_DIMM_SLOT_FORM_FBDIMM	"FBDIMM"
-
+ 
+#define	TOPO_PGROUP_DIMM_PROPS		"dimm-properties"
 #define	TOPO_PROP_DIMM_TYPE
 #define	TOPO_DIMM_TYPE_UNKNOWN		"UNKNOWN"
 #define	TOPO_DIMM_TYPE_DDR		"DDR"
@@ -235,6 +236,14 @@ extern "C" {
 #define	TOPO_DIMM_TYPE_LPDDR3		"LPDDR3"
 #define	TOPO_DIMM_TYPE_LPDDR4		"LPDDR4"
 
+#define TOPO_PGROUP_MOTHERBOARD		"motherboard-properties"
+#define	TOPO_PROP_MB_MANUFACTURER	"manufacturer"
+#define	TOPO_PROP_MB_PRODUCT		"product-id"
+#define	TOPO_PROP_MB_ASSET		"assert-tag"
+#define	TOPO_PROP_MB_FIRMWARE_VENDOR	"firmware-vendor"
+#define	TOPO_PROP_MB_FIRMWARE_REV	"firmware-revision"
+#define	TOPO_PROP_MB_FIRMWARE_RELDATE	"firmware-release-date"
+
 #ifdef	__cplusplus
 }
 #endif
diff --git a/usr/src/lib/fm/topo/maps/Joyent,Joyent-Storage-Platform-7001/Joyent-Storage-Platform-7001-hc-topology.xml b/usr/src/lib/fm/topo/maps/Joyent,Joyent-Storage-Platform-7001/Joyent-Storage-Platform-7001-hc-topology.xml
index c185c50792..915e3ccfb0 100644
--- a/usr/src/lib/fm/topo/maps/Joyent,Joyent-Storage-Platform-7001/Joyent-Storage-Platform-7001-hc-topology.xml
+++ b/usr/src/lib/fm/topo/maps/Joyent,Joyent-Storage-Platform-7001/Joyent-Storage-Platform-7001-hc-topology.xml
@@ -18,7 +18,8 @@
 <topology name='i86pc' scheme='hc'>
 
   <range name='motherboard' min='0' max='0'>
-    <node instance='0'>
+    <enum-method name='smbios' version='1' />
+    <node instance='0' static='true'>
         <fac-enum provider='fac_prov_ipmi' />
         <propgroup name='protocol' version='1'
             name-stability='Private' data-stability='Private' >
diff --git a/usr/src/lib/fm/topo/maps/SMCI,SSG-2028R-ACR24L/SSG-2028R-ACR24L-hc-topology.xml b/usr/src/lib/fm/topo/maps/SMCI,SSG-2028R-ACR24L/SSG-2028R-ACR24L-hc-topology.xml
index 83bc2e217b..8406db227d 100644
--- a/usr/src/lib/fm/topo/maps/SMCI,SSG-2028R-ACR24L/SSG-2028R-ACR24L-hc-topology.xml
+++ b/usr/src/lib/fm/topo/maps/SMCI,SSG-2028R-ACR24L/SSG-2028R-ACR24L-hc-topology.xml
@@ -27,7 +27,8 @@ Copyright (c) 2018, Joyent, Inc.
 <topology name='i86pc' scheme='hc'>
 
   <range name='motherboard' min='0' max='0'>
-    <node instance='0'>
+    <enum-method name='smbios' version='1' />
+    <node instance='0' static='true'>
         <fac-enum provider='fac_prov_ipmi' />
         <propgroup name='protocol' version='1'
             name-stability='Private' data-stability='Private' >
diff --git a/usr/src/lib/fm/topo/modules/common/smbios/smbios_enum.c b/usr/src/lib/fm/topo/modules/common/smbios/smbios_enum.c
index ecaa749bed..097bc2c09a 100644
--- a/usr/src/lib/fm/topo/modules/common/smbios/smbios_enum.c
+++ b/usr/src/lib/fm/topo/modules/common/smbios/smbios_enum.c
@@ -22,8 +22,6 @@
 #include <string.h>
 #include <unistd.h>
 
-#define	TOPO_PGROUP_DIMM_PROPS	"dimm-properties"
-
 typedef struct smb_enum_data {
 	topo_mod_t	*sme_mod;
 	tnode_t		*sme_pnode;
@@ -90,7 +88,7 @@ static boolean_t
 is_valid_string(const char *str)
 {
 	if (strcmp(str, SMB_DEFAULT1) != 0 && strcmp(str, SMB_DEFAULT2) != 0 &&
-	    strlen(str) > 0)
+	    strcmp(str, SMB_DEFAULT3) != 0 && strlen(str) > 0)
 		return (B_TRUE);
 
 	return (B_FALSE);
@@ -387,6 +385,140 @@ smbios_enum_memory(smbios_hdl_t *shp, const smbios_struct_t *sp, void *arg)
 	return (0);
 }
 
+static int
+smbios_enum_motherboard(smbios_hdl_t *shp, smb_enum_data_t *smed)
+{
+	smbios_struct_t sp;
+	smbios_bboard_t smb_mb;
+	smbios_bios_t smb_bios;
+	smbios_info_t smb_info;
+	const char *part = NULL, *rev = NULL, *serial = NULL;
+	char *manuf = NULL, *prod = NULL, *asset = NULL;
+	char *bios_vendor = NULL, *bios_rev = NULL, *bios_reldate = NULL;
+	nvlist_t *auth, *fmri;
+	topo_mod_t *mod = smed->sme_mod;
+	tnode_t *mbnode;
+	topo_pgroup_info_t pgi;
+	int rc = 0, err;
+
+	if (smbios_lookup_type(shp, SMB_TYPE_BASEBOARD, &sp) == 0 &&
+	    smbios_info_bboard(shp, sp.smbstr_id, &smb_mb) == 0 &&
+	    smbios_info_common(shp, sp.smbstr_id, &smb_info) == 0) {
+		if (is_valid_string(smb_info.smbi_part) == B_TRUE)
+			part = smb_info.smbi_part;
+		if (is_valid_string(smb_info.smbi_version) == B_TRUE)
+			rev = smb_info.smbi_version;
+		if (is_valid_string(smb_info.smbi_serial) == B_TRUE)
+			serial = smb_info.smbi_serial;
+		if (is_valid_string(smb_info.smbi_manufacturer) == B_TRUE)
+			manuf = topo_mod_clean_str(mod,
+			    smb_info.smbi_manufacturer);
+		if (is_valid_string(smb_info.smbi_product) == B_TRUE)
+			prod = topo_mod_clean_str(mod, smb_info.smbi_product);
+		if (is_valid_string(smb_info.smbi_asset) == B_TRUE)
+			asset = topo_mod_clean_str(mod, smb_info.smbi_asset);
+	}
+	if (smbios_lookup_type(shp, SMB_TYPE_BIOS, &sp) == 0 &&
+	    smbios_info_bios(shp, &smb_bios) == 0) {
+		if (is_valid_string(smb_bios.smbb_vendor) == B_TRUE)
+			bios_vendor = topo_mod_clean_str(mod,
+			    smb_bios.smbb_vendor);
+		if (is_valid_string(smb_bios.smbb_version) == B_TRUE)
+			bios_rev = topo_mod_clean_str(mod,
+			    smb_bios.smbb_version);
+		if (is_valid_string(smb_bios.smbb_reldate) == B_TRUE)
+			bios_reldate = topo_mod_clean_str(mod,
+			    smb_bios.smbb_reldate);
+	}
+	if ((auth = topo_mod_auth(mod, smed->sme_pnode)) == NULL) {
+		topo_mod_dprintf(mod, "topo_mod_auth() failed: %s",
+		    topo_mod_errmsg(mod));
+		/* errno set */
+		goto err;
+	}
+
+	if ((fmri = topo_mod_hcfmri(mod, NULL, FM_HC_SCHEME_VERSION,
+	    MOTHERBOARD, 0, NULL, auth, part, rev, serial)) ==
+	    NULL) {
+		nvlist_free(auth);
+		topo_mod_dprintf(mod, "topo_mod_hcfmri() failed: %s",
+		    topo_mod_errmsg(mod));
+		/* errno set */
+		goto err;
+	}
+	nvlist_free(auth);
+
+	if ((mbnode = topo_node_bind(mod, smed->sme_pnode, MOTHERBOARD, 0,
+	    fmri)) == NULL) {
+		nvlist_free(fmri);
+		topo_mod_dprintf(mod, "topo_node_bind() failed: %s",
+		    topo_mod_errmsg(mod));
+		/* errno set */
+		goto err;
+	}
+	if (topo_node_fru_set(mbnode, fmri, NULL, &err) != 0) {
+		topo_mod_dprintf(mod, "failed to set FRU on %s: %s",
+		    MOTHERBOARD, topo_strerror(err));
+		nvlist_free(fmri);
+		(void) topo_mod_seterrno(mod, err);
+		goto err;
+	}
+	nvlist_free(fmri);
+	fmri = NULL;
+
+	if (topo_node_label_set(mbnode, "MB", &err) != 0) {
+		topo_mod_dprintf(mod, "failed to set label on %s: %s",
+		    MOTHERBOARD, topo_strerror(err));
+		(void) topo_mod_seterrno(mod, err);
+		goto err;
+	}
+
+	pgi.tpi_name = TOPO_PGROUP_MOTHERBOARD;
+	pgi.tpi_namestab = TOPO_STABILITY_PRIVATE;
+	pgi.tpi_datastab = TOPO_STABILITY_PRIVATE;
+	pgi.tpi_version = TOPO_VERSION;
+	rc = topo_pgroup_create(mbnode, &pgi, &err);
+
+	if (rc == 0 && manuf != NULL)
+		rc += topo_prop_set_string(mbnode, TOPO_PGROUP_MOTHERBOARD,
+		    TOPO_PROP_MB_MANUFACTURER, TOPO_PROP_IMMUTABLE, manuf,
+		    &err);
+	if (rc == 0 && prod != NULL)
+		rc += topo_prop_set_string(mbnode, TOPO_PGROUP_MOTHERBOARD,
+		    TOPO_PROP_MB_PRODUCT, TOPO_PROP_IMMUTABLE, prod, &err);
+	if (rc == 0 && asset != NULL)
+		rc += topo_prop_set_string(mbnode, TOPO_PGROUP_MOTHERBOARD,
+		    TOPO_PROP_MB_ASSET, TOPO_PROP_IMMUTABLE, asset, &err);
+	if (rc == 0 && bios_vendor != NULL)
+		rc += topo_prop_set_string(mbnode, TOPO_PGROUP_MOTHERBOARD,
+		    TOPO_PROP_MB_FIRMWARE_VENDOR, TOPO_PROP_IMMUTABLE,
+		    bios_vendor, &err);
+	if (rc == 0 && bios_rev != NULL)
+		rc += topo_prop_set_string(mbnode, TOPO_PGROUP_MOTHERBOARD,
+		    TOPO_PROP_MB_FIRMWARE_REV, TOPO_PROP_IMMUTABLE,
+		    bios_rev, &err);
+	if (rc == 0 && bios_reldate != NULL)
+		rc += topo_prop_set_string(mbnode, TOPO_PGROUP_MOTHERBOARD,
+		    TOPO_PROP_MB_FIRMWARE_RELDATE, TOPO_PROP_IMMUTABLE,
+		    bios_reldate, &err);
+
+	if (rc != 0) {
+		topo_mod_dprintf(mod, "error setting properties on %s node",
+		    MOTHERBOARD);
+		(void) topo_mod_seterrno(mod, err);
+		goto err;
+	}
+err:
+	topo_mod_strfree(mod, manuf);
+	topo_mod_strfree(mod, prod);
+	topo_mod_strfree(mod, asset);
+	topo_mod_strfree(mod, bios_vendor);
+	topo_mod_strfree(mod, bios_rev);
+	topo_mod_strfree(mod, bios_reldate);
+
+	return (0);
+}
+
 /*
  * A system with a functional memory controller driver will have one  mc device
  * node per chip instance, starting at instance 0.  The driver provides an
@@ -445,6 +577,10 @@ smbios_enum(topo_mod_t *mod, tnode_t *rnode, const char *name,
 		if (smbios_iter(smbh, smbios_enum_memory, &smed) < 0)
 			/* errno set */
 			return (-1);
+	} else if (strcmp(name, MOTHERBOARD) == 0) {
+		if (smbios_enum_motherboard(smbh, &smed) < 0)
+			/* errno set */
+			return (-1);
 	} else {
 		topo_mod_dprintf(mod, "smbios_enum() invoked for unsupported "
 		    "node type: %s", name);
diff --git a/usr/src/uts/common/sys/smbios.h b/usr/src/uts/common/sys/smbios.h
index 84d925be78..fa43ad687a 100644
--- a/usr/src/uts/common/sys/smbios.h
+++ b/usr/src/uts/common/sys/smbios.h
@@ -21,7 +21,7 @@
 
 /*
  * Copyright 2015 OmniTI Computer Consulting, Inc. All rights reserved.
- * Copyright (c) 2017, Joyent, Inc.
+ * Copyright (c) 2018, Joyent, Inc.
  * Copyright 2010 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
  */
@@ -178,6 +178,7 @@ typedef union {
  */
 #define	SMB_DEFAULT1	"To Be Filled By O.E.M."
 #define	SMB_DEFAULT2	"Not Available"
+#define	SMB_DEFAULT3	"Default string"
 
 /*
  * SMBIOS Common Information.  These structures do not correspond to anything
-- 
2.21.0

