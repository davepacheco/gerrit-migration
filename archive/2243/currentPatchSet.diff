commit bbdc2146b4aa2599993616d868f2d408dd23c71d (refs/changes/43/2243/1)
Author: Ryan Zezeski <rpz@joyent.com>
Date:   2017-07-20T17:01:16-06:00 (2 years, 3 months ago)
    
    OS-6244 Want DLS bypass for VLAN VNIC

diff --git a/usr/src/uts/common/io/dld/dld_proto.c b/usr/src/uts/common/io/dld/dld_proto.c
index 661d8b2f4f..ec5eb7a5e9 100644
--- a/usr/src/uts/common/io/dld/dld_proto.c
+++ b/usr/src/uts/common/io/dld/dld_proto.c
@@ -1439,11 +1439,7 @@ dld_capab_poll_enable(dld_str_t *dsp, dld_capab_poll_t *poll)
 		return (ENOTSUP);
 
 	/*
-	 * Enable client polling if and only if DLS bypass is possible.
-	 * Special cases like VLANs need DLS processing in the Rx data path.
-	 * In such a case we can neither allow the client (IP) to directly
-	 * poll the softring (since DLS processing hasn't been done) nor can
-	 * we allow DLS bypass.
+	 * Enable client polling if DLS bypass is possible.
 	 */
 	if (!mac_rx_bypass_set(dsp->ds_mch, dsp->ds_rx, dsp->ds_rx_arg))
 		return (ENOTSUP);
@@ -1637,6 +1633,8 @@ proto_capability_advertise(dld_str_t *dsp, mblk_t *mp)
 	 * that for vnd we only allow the case where the media type is the
 	 * native media type so we know that there are no transformations that
 	 * would have to happen to the mac header that it receives.
+	 *
+	 * RPZ: Do I need to allow for ds_sap VLAN here?
 	 */
 	if ((dsp->ds_sap == ETHERTYPE_IP &&
 	    check_mod_above(dsp->ds_rq, "ip")) ||
diff --git a/usr/src/uts/common/io/mac/mac_client.c b/usr/src/uts/common/io/mac/mac_client.c
index 18a6613424..c6788a0b95 100644
--- a/usr/src/uts/common/io/mac/mac_client.c
+++ b/usr/src/uts/common/io/mac/mac_client.c
@@ -21,7 +21,7 @@
 
 /*
  * Copyright (c) 2008, 2010, Oracle and/or its affiliates. All rights reserved.
- * Copyright 2015, Joyent, Inc.
+ * Copyright 2017 Joyent, Inc.
  */
 
 /*
@@ -1549,11 +1549,10 @@ mac_rx_bypass_set(mac_client_handle_t mch, mac_direct_rx_t rx_fn, void *arg1)
 	ASSERT(MAC_PERIM_HELD((mac_handle_t)mip));
 
 	/*
-	 * If the mac_client is a VLAN, we should not do DLS bypass and
-	 * instead let the packets come up via mac_rx_deliver so the vlan
-	 * header can be stripped.
+	 * We cannot bypass DLS if the MAC client has more than one
+	 * VLAN or the client has disabled stripping.
 	 */
-	if (mcip->mci_nvids > 0)
+	if (mcip->mci_nvids > 1 || (mcip->mci_state_flags & MCIS_STRIP_DISABLE))
 		return (B_FALSE);
 
 	/*
diff --git a/usr/src/uts/common/io/mac/mac_sched.c b/usr/src/uts/common/io/mac/mac_sched.c
index 948594f849..fa6dc6027e 100644
--- a/usr/src/uts/common/io/mac/mac_sched.c
+++ b/usr/src/uts/common/io/mac/mac_sched.c
@@ -1523,10 +1523,10 @@ mac_rx_srs_proto_fanout(mac_soft_ring_set_t *mac_srs, mblk_t *head)
 	    mac_srs->srs_ring->mr_classify_type == MAC_HW_CLASSIFIER;
 
 	/*
-	 * Special clients (eg. VLAN, non ether, etc) need DLS
-	 * processing in the Rx path. SRST_DLS_BYPASS will be clear for
-	 * such SRSs. Another way of disabling bypass is to set the
-	 * MCIS_RX_BYPASS_DISABLE flag.
+	 * Special clients (eg. client with more than one VID,
+	 * non ether, etc) need DLS processing in the Rx path.
+	 * SRST_DLS_BYPASS will be clear for such SRSs. Another way of
+	 * disabling bypass is to set the MCIS_RX_BYPASS_DISABLE flag.
 	 */
 	dls_bypass = ((mac_srs->srs_type & SRST_DLS_BYPASS) != 0) &&
 	    ((mcip->mci_state_flags & MCIS_RX_BYPASS_DISABLE) == 0);
@@ -1932,10 +1932,10 @@ mac_rx_srs_fanout(mac_soft_ring_set_t *mac_srs, mblk_t *head)
 	    mac_srs->srs_ring->mr_classify_type == MAC_HW_CLASSIFIER;
 
 	/*
-	 * Special clients (eg. VLAN, non ether, etc) need DLS
-	 * processing in the Rx path. SRST_DLS_BYPASS will be clear for
-	 * such SRSs. Another way of disabling bypass is to set the
-	 * MCIS_RX_BYPASS_DISABLE flag.
+	 * Special clients (eg. client with more than one VID,
+	 * non ether, etc) need DLS processing in the Rx path.
+	 * SRST_DLS_BYPASS will be clear for such SRSs. Another way of
+	 * disabling bypass is to set the MCIS_RX_BYPASS_DISABLE flag.
 	 */
 	dls_bypass = ((mac_srs->srs_type & SRST_DLS_BYPASS) != 0) &&
 	    ((mcip->mci_state_flags & MCIS_RX_BYPASS_DISABLE) == 0);
@@ -4643,22 +4643,7 @@ mac_rx_deliver(void *arg1, mac_resource_handle_t mrh, mblk_t *mp_chain,
     mac_header_info_t *arg3)
 {
 	mac_client_impl_t *mcip = arg1;
-
-	if (mcip->mci_nvids == 1 &&
-	    !(mcip->mci_state_flags & MCIS_STRIP_DISABLE)) {
-		/*
-		 * If the client has exactly one VID associated with it
-		 * and striping of VLAN header is not disabled,
-		 * remove the VLAN tag from the packet before
-		 * passing it on to the client's receive callback.
-		 * Note that this needs to be done after we dispatch
-		 * the packet to the promiscuous listeners of the
-		 * client, since they expect to see the whole
-		 * frame including the VLAN headers.
-		 */
-		mp_chain = mac_strip_vlan_tag_chain(mp_chain);
-	}
-
+	MAC_STRIP_VLAN_TAG(mcip, mp_chain);
 	mcip->mci_rx_fn(mcip->mci_rx_arg, mrh, mp_chain, B_FALSE);
 }
 
@@ -4724,6 +4709,7 @@ mac_rx_soft_ring_process(mac_client_impl_t *mcip, mac_soft_ring_t *ringp,
 			 */
 			ASSERT(mp_chain->b_next == NULL);
 
+			MAC_STRIP_VLAN_TAG(mcip, mp_chain);
 			(*proc)(arg1, arg2, mp_chain, NULL);
 
 			ASSERT(MUTEX_NOT_HELD(&ringp->s_ring_lock));
diff --git a/usr/src/uts/common/io/mac/mac_soft_ring.c b/usr/src/uts/common/io/mac/mac_soft_ring.c
index 2e056c8a2e..ccf8a524cb 100644
--- a/usr/src/uts/common/io/mac/mac_soft_ring.c
+++ b/usr/src/uts/common/io/mac/mac_soft_ring.c
@@ -389,6 +389,7 @@ mac_rx_soft_ring_drain(mac_soft_ring_t *ringp)
 			tid = NULL;
 		}
 
+		MAC_STRIP_VLAN_TAG(ringp->s_ring_mcip, mp);
 		(*proc)(arg1, arg2, mp, NULL);
 
 		/*
diff --git a/usr/src/uts/common/sys/mac_impl.h b/usr/src/uts/common/sys/mac_impl.h
index 12937cea1b..273d83afc4 100644
--- a/usr/src/uts/common/sys/mac_impl.h
+++ b/usr/src/uts/common/sys/mac_impl.h
@@ -731,6 +731,20 @@ typedef struct mac_prop_info_state_s {
 
 typedef struct mac_client_impl_s mac_client_impl_t;
 
+/*
+ * If the MAC client has exactly one VID associated with it and
+ * striping of VLAN header is not disabled then remove the VLAN tag
+ * from the packet before passing it on to the client's receive
+ * callback. This needs to be done after we dispatch the packet to the
+ * promiscuous listeners of the client since they expect to see the
+ * whole frame including the VLAN headers.
+ */
+#define	MAC_STRIP_VLAN_TAG(mcip, mp_chain)			\
+if ((mcip)->mci_nvids == 1 &&					\
+	!((mcip)->mci_state_flags & MCIS_STRIP_DISABLE)) {	\
+	(mp_chain) = mac_strip_vlan_tag_chain((mp_chain));	\
+}
+
 extern void	mac_init(void);
 extern int	mac_fini(void);
 
