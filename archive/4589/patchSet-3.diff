From f7612cf66490221c3d62001761b3770e571be6f2 Mon Sep 17 00:00:00 2001
From: Alex Wilson <alex.wilson@joyent.com>
Date: Thu, 26 Jul 2018 16:02:38 -0700
Subject: [PATCH] joyent/node-cueball#130 limit connection expansion rate
 per-backend Reviewed by: Cody Peter Mello <cody.mello@joyent.com> Approved
 by: Cody Peter Mello <cody.mello@joyent.com>

---
 CHANGES.adoc          |  9 +++++
 docs/api.adoc         |  4 +++
 lib/connection-fsm.js |  4 +++
 lib/pool.js           | 57 ++++++++++++++++++++++++++++++
 package.json          |  2 +-
 test/pool.test.js     | 81 +++++++++++++++++++++++++++++++++++++++++++
 6 files changed, 156 insertions(+), 1 deletion(-)

diff --git a/CHANGES.adoc b/CHANGES.adoc
index 5fa31c6..1e9d2c1 100644
--- a/CHANGES.adoc
+++ b/CHANGES.adoc
@@ -6,6 +6,15 @@ toc::[]
 
 ## v2.x
 
+### v2.8.0
+
+New minor release, due to addition of new API.
+
+API Changes:
+
+ - The `Pool` constructor now accepts a new option, `maxChurnRate` to constrain
+   the maximum per-backend connection churn rate of the pool.
+
 ### v2.7.1
 
 Maintenance release.
diff --git a/docs/api.adoc b/docs/api.adoc
index 8d35dd9..aedc346 100644
--- a/docs/api.adoc
+++ b/docs/api.adoc
@@ -255,6 +255,10 @@ Parameters
   * `resolver` -- optional instance of an object meeting the Resolver interface
     below.  You would typically obtain this object by either creating your own
     Resolver directly or using the `resolverForIpOrDomain` function.
+  * `maxChurnRate` -- optional Number, maximum rate in connections per second
+    to limit connection churn to on a per-backend basis. If set, cueball will
+    never create or destroy connections to a given backend at a higher rate
+    than the one given.
 
 Do not confuse `resolvers` (the list of IP addresses for the DNS resolvers to
 contact) with `resolver` (a custom object meeting the Resolver interface below).
diff --git a/lib/connection-fsm.js b/lib/connection-fsm.js
index 263ed01..dda98e9 100644
--- a/lib/connection-fsm.js
+++ b/lib/connection-fsm.js
@@ -938,6 +938,10 @@ ConnectionSlotFSM.prototype.getSocketMgr = function () {
 	return (this.csf_smgr);
 };
 
+ConnectionSlotFSM.prototype.getBackend = function () {
+	return (this.csf_backend);
+};
+
 ConnectionSlotFSM.prototype.isRunningPing = function () {
 	return (this.isInState('busy') && this.csf_handle &&
 	    this.csf_handle.csf_pinger);
diff --git a/lib/pool.js b/lib/pool.js
index b024514..effa229 100644
--- a/lib/pool.js
+++ b/lib/pool.js
@@ -171,6 +171,15 @@ function CueBallConnectionPool(options) {
 	this.p_backends = {};
 	this.p_connections = {};
 	this.p_dead = {};
+	this.p_lastrate = {};
+
+	mod_assert.optionalNumber(options.maxChurnRate, 'options.maxChurnRate');
+	if (options.maxChurnRate !== null &&
+	    options.maxChurnRate !== undefined) {
+		this.p_maxrate = options.maxChurnRate;
+	} else {
+		this.p_maxrate = Infinity;
+	}
 
 	this.p_lastRebalance = undefined;
 	this.p_inRebalance = false;
@@ -236,6 +245,8 @@ function CueBallConnectionPool(options) {
 
 	this.p_lastRebalClamped = false;
 
+	this.p_rateDelayTimer = undefined;
+
 	this.p_lpTimer = setInterval(function () {
 		var conns = 0;
 		Object.keys(self.p_connections).forEach(function (k) {
@@ -578,7 +589,28 @@ CueBallConnectionPool.prototype._rebalance = function () {
 		    plan.remove.length, plan.add.length,
 		    busy, spares, target);
 	}
+	var now = Date.now() / 1000.0;
+	var rateDelay;
 	plan.remove.forEach(function (fsm) {
+		var k = fsm.getBackend().key;
+		var lastrate = self.p_lastrate[k];
+		var n = (self.p_connections[k] || []).length - 1;
+		if (lastrate) {
+			var tdelta = now - lastrate.time;
+			var ndelta = n - lastrate.count;
+			var rate = Math.abs(ndelta / tdelta);
+			if (rate > self.p_maxrate) {
+				var tnext = lastrate.time +
+				    Math.abs(ndelta) / self.p_maxrate;
+				var delay = tnext - now;
+				if (rateDelay === undefined ||
+				    delay < rateDelay)
+					rateDelay = delay;
+				return;
+			}
+		}
+		self.p_lastrate[k] = { time: now, count: n };
+
 		/* This slot is no longer wanted. */
 		fsm.setUnwanted();
 		/*
@@ -591,12 +623,37 @@ CueBallConnectionPool.prototype._rebalance = function () {
 		}
 	});
 	plan.add.forEach(function (k) {
+		var lastrate = self.p_lastrate[k];
+		var n = (self.p_connections[k] || []).length + 1;
+		if (lastrate) {
+			var tdelta = now - lastrate.time;
+			var ndelta = n - lastrate.count;
+			var rate = Math.abs(ndelta / tdelta);
+			if (rate > self.p_maxrate) {
+				var tnext = lastrate.time +
+				    Math.abs(ndelta) / self.p_maxrate;
+				var delay = tnext - now;
+				if (rateDelay === undefined ||
+				    delay < rateDelay)
+					rateDelay = delay;
+				return;
+			}
+		}
+		self.p_lastrate[k] = { time: now, count: n };
 		/* Make sure we *never* exceed our socket limit. */
 		if (++total > self.p_max)
 			return;
 		self.addConnection(k);
 	});
 
+	if (rateDelay !== undefined) {
+		if (this.p_rateDelayTimer !== undefined)
+			clearTimeout(this.p_rateDelayTimer);
+		this.p_rateDelayTimer = setTimeout(function () {
+			self.rebalance();
+		}, Math.round(rateDelay * 1000 + 10));
+	}
+
 	this.p_inRebalance = false;
 	this.p_lastRebalance = new Date();
 };
diff --git a/package.json b/package.json
index 74112d5..56de55b 100644
--- a/package.json
+++ b/package.json
@@ -1,6 +1,6 @@
 {
   "name": "cueball",
-  "version": "2.7.1",
+  "version": "2.8.0",
   "description": "manage a pool of connections to a multi-node service where nodes are listed in DNS",
   "main": "lib/index.js",
   "dependencies": {
diff --git a/test/pool.test.js b/test/pool.test.js
index b110706..d35ce63 100644
--- a/test/pool.test.js
+++ b/test/pool.test.js
@@ -1038,6 +1038,87 @@ mod_tape.test('backend failure/removal race (#144)', function (t) {
 	});
 });
 
+mod_tape.test('pool with churn rate limit', function (t) {
+	connections = [];
+	resolver = undefined;
+	var timer;
+
+	var pool = new mod_pool.ConnectionPool({
+		log: log,
+		domain: 'foobar',
+		spares: 4,
+		maximum: 4,
+		maxChurnRate: 4.0,
+		constructor: function (backend) {
+			return (new DummyConnection(backend));
+		},
+		recovery: recovery
+	});
+	t.ok(resolver);
+
+	pool.on('stateChanged', function (st) {
+		if (st === 'stopped') {
+			if (timer !== undefined)
+				clearTimeout(timer);
+			t.end();
+		}
+	});
+
+	resolver.emit('added', 'b1', {});
+	setImmediate(function () {
+		t.equal(connections.length, 1);
+		t.strictEqual(connections[0].backend, 'b1');
+		connections[0].connect();
+
+		setTimeout(function () {
+			t.equal(connections.length, 2);
+			summarize();
+			t.deepEqual(counts, { 'b1': 2 });
+			connections[1].connect();
+		}, 250+100);
+
+		setTimeout(function () {
+			t.equal(connections.length, 3);
+			summarize();
+			t.deepEqual(counts, { 'b1': 3 });
+			connections[2].connect();
+		}, 500+100);
+
+		setTimeout(function () {
+			t.equal(connections.length, 4);
+			summarize();
+			t.deepEqual(counts, { 'b1': 4 });
+			connections[3].connect();
+
+			resolver.emit('added', 'b2', {});
+		}, 750+100);
+
+		setTimeout(function () {
+			t.equal(connections.length, 4);
+			summarize();
+			t.deepEqual(counts, { 'b1': 4 });
+		}, 800+100);
+
+		setTimeout(function () {
+			t.equal(connections.length, 3);
+			summarize();
+			t.deepEqual(counts, { 'b1': 2, 'b2': 1 });
+			index.b2[0].connect();
+		}, 1000+100);
+
+		setTimeout(function () {
+			t.equal(connections.length, 4);
+			summarize();
+			t.deepEqual(counts, { 'b1': 2, 'b2': 2 });
+			index.b2[1].connect();
+
+			pool.stop();
+			/* Stop tape from giving up. */
+			timer = setTimeout(function () {},
+			    5000);
+		}, 1250+100);
+	});
+});
 
 mod_tape.test('cleanup sandbox', function (t) {
 	sandbox.restore();
-- 
2.21.0

