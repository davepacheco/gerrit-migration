From 473246ec2542c8e84750f591edc2925e74da6387 Mon Sep 17 00:00:00 2001
From: Julien Gilli <julien.gilli@joyent.com>
Date: Wed, 4 Oct 2017 16:27:32 -0700
Subject: [PATCH] PUBAPI-1448 refactor reusable parts of config and networks
 endpoints into separate modules

---
 lib/app.js                 |  10 +-
 lib/config.js              | 202 ++++------
 lib/endpoints/config.js    | 165 +++++++++
 lib/endpoints/networks.js  | 603 ++++++++++++++++++++++++++++++
 lib/middleware/networks.js | 139 +++++++
 lib/networks.js            | 737 ++++---------------------------------
 main.js                    |  63 +---
 7 files changed, 1071 insertions(+), 848 deletions(-)
 create mode 100644 lib/endpoints/config.js
 create mode 100644 lib/endpoints/networks.js
 create mode 100644 lib/middleware/networks.js

diff --git a/lib/app.js b/lib/app.js
index 49cd907..10065bf 100644
--- a/lib/app.js
+++ b/lib/app.js
@@ -35,6 +35,7 @@ var kang = require('kang');
 var account = require('./account');
 var analytics = require('./analytics');
 var auth = require('./auth');
+var configEndpoints = require('./endpoints/config');
 var datacenters = require('./datacenters');
 var datasets = require('./datasets');
 var docs = require('./docs');
@@ -48,7 +49,8 @@ var services = require('./services');
 var snapshots = require('./snapshots');
 var tags = require('./tags');
 var throttle = require('./throttle');
-var networks = require('./networks');
+var networkEndpoints = require('./endpoints/networks');
+var networkMiddleware = require('./middleware/networks');
 var audit = require('./audit');
 var auditLogger = require('./audit_logger');
 var rules = require('./rules');
@@ -519,7 +521,7 @@ module.exports = {
 
                 server.use(datasets.loadDatasets);
                 server.use(packages.loadPackages);
-                server.use(networks.loadNetworks);
+                server.use(networkMiddleware.loadNetworks);
                 server.use(machines.loadMachine);
 
                 server.use(resources.loadResource);
@@ -622,7 +624,7 @@ module.exports = {
                 datasets.mount(server,
                         userThrottle(config, 'datasets'), config);
                 packages.mount(server, userThrottle(config, 'packages'));
-                networks.mount(server, userThrottle(config, 'networks'),
+                networkEndpoints.mount(server, userThrottle(config, 'networks'),
                         plugins.preListNetworks);
 
                 // Wait for datasets and packages to mount everything else:
@@ -649,7 +651,7 @@ module.exports = {
                 roles.mount(server, userThrottle(config, 'roles'), config);
                 nics.mount(server, userThrottle(config, 'nics'),
                         plugins.preAddNic);
-                mod_config.mount(server, userThrottle(config, 'config'));
+                configEndpoints.mount(server, userThrottle(config, 'config'));
                 resources.mount(server, userThrottle(config, 'resources'),
                         config);
 
diff --git a/lib/config.js b/lib/config.js
index 5614faa..904d28b 100644
--- a/lib/config.js
+++ b/lib/config.js
@@ -13,28 +13,11 @@
  */
 
 var assert = require('assert-plus');
-var jsprim = require('jsprim');
-var restify = require('restify');
-var schemas = require('joyent-schemas').cloudapi;
-var util = require('util');
-
-
-// --- Helpers
-
-
-
-/**
- * Translate a UFDS error into a cloudapi-friendly error
- */
-function translateErr(err) {
-    if (err.name === 'ResourceNotFoundError') {
-        return new restify.ServiceUnavailableError(
-            'Error getting config');
-    }
-
-    return err;
-}
+var fs = require('fs');
+var http = require('http');
+var https = require('https');
 
+var DEFAULT_CFG = __dirname + '/../etc/cloudapi.cfg';
 
 /**
  * Translate the UFDS representation of a default network into a
@@ -46,113 +29,96 @@ function translateUfdsConf(conf) {
     };
 }
 
+function configure(options) {
+    assert.optionalObject(options, 'options');
+    options = options || {};
 
-/**
- * Validate request parameters and transform them into their UFDS format
- */
-function validateAndTranslate(inParams) {
-    var err;
-    var params = jsprim.deepCopy(inParams);
-    delete params.account;
-
-    err = jsprim.validateJsonObject(schemas.UpdateConfig, params);
-    if (err) {
-        if (err.message.match(/does not match the regex pattern/)) {
-            throw new restify.InvalidArgumentError(err,
-                    util.format('property "%s": must be a UUID',
-                    err.jsv_details.property));
-        }
-
-        throw new restify.InvalidArgumentError(err, err.message);
-    }
-
-    // Translate config object to its format in UFDS:
-    params.defaultnetwork = params.default_network;
-    delete params.default_network;
-
-    return params;
-}
-
+    assert.optionalObject(options.overrides, 'options.overrides');
+    assert.optionalString(options.configFilePath, 'options.configFilePath');
+    assert.optionalObject(options.log, 'log');
 
+    var config;
+    var log = options.log;
+    var configFilePath = options.configFilePath || DEFAULT_CFG;
 
-// --- Restify handlers
-
+    try {
+        config = JSON.parse(fs.readFileSync(configFilePath, 'utf8'));
 
+        if (config.certificate && config.key && !config.port) {
+            config.port = 443;
+        }
 
-function getConfig(req, res, next) {
-    getConfigFromUFDS(req, function _afterGetFromUFDS(err, conf) {
-        if (err) {
-            return next(err);
+        if (!config.port) {
+            config.port = 80;
         }
 
-        res.send(conf);
-        return next();
-    });
-}
+    } catch (e1) {
+        console.error('Unable to parse %s: %s', configFilePath, e1.message);
+        process.exit(1);
+    }
 
+    if (options.overrides) {
+        assert.optionalNumber(options.overrides.port, 'options.overrides.port');
 
-function updateConfig(req, res, next) {
-    var account = req.account.uuid;
-    var dc = req.config.datacenter_name;
-    var netUuids = req.networks.map(function (n) { return n.uuid; });
-    var params;
+        if (options.overrides.port !== undefined) {
+            config.port = options.overrides.port;
+        }
+    }
 
     try {
-        params = validateAndTranslate(req.params);
-    } catch (vErr) {
-        return next(vErr);
+        if (config.certificate) {
+            config.certificate = fs.readFileSync(config.certificate, 'utf8');
+        }
+    } catch (e2) {
+        console.error('Unable to load %s: %s', config.certificate, e2.message);
+        process.exit(1);
     }
 
-    if (netUuids.indexOf(params.defaultnetwork) === -1) {
-        return next(new restify.InvalidArgumentError('unknown network'));
+    try {
+        if (config.key) {
+            config.key = fs.readFileSync(config.key, 'utf8');
+        }
+    } catch (e3) {
+        console.error('Unable to load %s: %s', config.certificate, e3.message);
+        process.exit(1);
     }
 
-    return req.sdc.ufds.updateDcLocalConfig(account, dc, params,
-            function _afterConfUpdate(err, conf) {
-        if (err) {
-            /*
-             * If the dclocalconfig is missing, it's most likely due to a
-             * race with napi-ufds-watcher. The watcher usually takes several
-             * seconds after the creation of a user to create dclocalconfig.
-             */
-            if (err.name === 'MissingParameterError' &&
-                err.message.match('dclocalconfig')) {
-                return next(new restify.InternalError(
-                    'Config currently unavailable.'));
-            } else {
-                return next(translateErr(err));
-            }
-        }
+    if (typeof (config.maxHttpSockets) === 'number') {
+        log.info('Tuning max sockets to %d', config.maxHttpSockets);
+        http.globalAgent.maxSockets = config.maxHttpSockets;
+        https.globalAgent.maxSockets = config.maxHttpSockets;
+    }
 
-        res.send(translateUfdsConf(conf));
-        return next();
-    });
+    return config;
 }
 
+function getAccountDcConfigFromUFDS(ufdsClient, account, datacenterName,
+    options, cb) {
+    assert.object(ufdsClient, 'ufdsClient');
+    assert.object(account, 'account');
+    assert.string(datacenterName, 'datacenterName');
+    assert.object(options, 'options');
+    assert.object(options.log, 'options.log');
+    assert.func(cb, 'cb');
 
+    var accountUuid = account.uuid;
+    var log = options.log;
 
-///--- API
-
-
-function getConfigFromUFDS(req, callback) {
-    var account = req.account.uuid;
-    var dc = req.config.datacenter_name;
-
-    req.log.debug({ account: account, dc: dc }, 'Getting user config');
+    log.info({ accountUuid: accountUuid, dcName: datacenterName },
+        'Getting user config');
 
-    req.sdc.ufds.getDcLocalConfig(account, dc,
+    ufdsClient.getDcLocalConfig(accountUuid, datacenterName,
             function _afterConfGet(err, conf) {
         if (err) {
             if (err.name !== 'ResourceNotFoundError') {
-                return callback(translateErr(err));
+                cb(err);
+                return;
+            } else {
+                conf = {}; // treat an empty object as default
             }
-
-            conf = {}; // treat an empty object as default
         }
 
-        req.log.debug({ account: account, dc: dc, config: conf },
-            'Got user config');
-        return callback(null, translateUfdsConf(conf));
+        cb(null, conf);
     }, true); // disable caching
     /*
      * Fetching the config is an uncommon operation, and caching the value
@@ -164,34 +130,8 @@ function getConfigFromUFDS(req, callback) {
      */
 }
 
-
-function mountConfig(server, before) {
-    assert.object(server);
-    assert.ok(before);
-
-    var path = '/:account/config';
-
-    server.get({
-        path: path,
-        name: 'GetConfig'
-    }, before, getConfig);
-
-    server.head({
-        path: path,
-        name: 'HeadConfig'
-    }, before, getConfig);
-
-    server.put({
-        path: path,
-        name: 'UpdateConfig'
-    }, before, updateConfig);
-
-    return server;
-}
-
-
-
 module.exports = {
-    get: getConfigFromUFDS,
-    mount: mountConfig
-};
+    configure: configure,
+    getAccountDcConfigFromUFDS: getAccountDcConfigFromUFDS,
+    translateUfdsConf: translateUfdsConf
+};
\ No newline at end of file
diff --git a/lib/endpoints/config.js b/lib/endpoints/config.js
new file mode 100644
index 0000000..6087169
--- /dev/null
+++ b/lib/endpoints/config.js
@@ -0,0 +1,165 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+
+/*
+ * Endpoints for managing account configuration
+ */
+
+var assert = require('assert-plus');
+var jsprim = require('jsprim');
+var restify = require('restify');
+var schemas = require('joyent-schemas').cloudapi;
+var util = require('util');
+
+var modConfig = require('../config');
+
+
+// --- Helpers
+
+
+
+/**
+ * Translate a UFDS error into a cloudapi-friendly error
+ */
+function translateErr(err) {
+    if (err.name === 'ResourceNotFoundError') {
+        return new restify.ServiceUnavailableError(
+            'Error getting config');
+    }
+
+    return err;
+}
+
+
+
+/**
+ * Validate request parameters and transform them into their UFDS format
+ */
+function validateAndTranslate(inParams) {
+    var err;
+    var params = jsprim.deepCopy(inParams);
+    delete params.account;
+
+    err = jsprim.validateJsonObject(schemas.UpdateConfig, params);
+    if (err) {
+        if (err.message.match(/does not match the regex pattern/)) {
+            throw new restify.InvalidArgumentError(err,
+                    util.format('property "%s": must be a UUID',
+                    err.jsv_details.property));
+        }
+
+        throw new restify.InvalidArgumentError(err, err.message);
+    }
+
+    // Translate config object to its format in UFDS:
+    params.defaultnetwork = params.default_network;
+    delete params.default_network;
+
+    return params;
+}
+
+
+
+// --- Restify handlers
+
+
+
+function getConfig(req, res, next) {
+    req.log.info({dcName: req.config.datacenter_name, account: req.account},
+        'Getting configuration');
+
+    modConfig.getAccountDcConfigFromUFDS(req.sdc.ufds, req.account,
+        req.config.datacenter_name, {
+        log: req.log
+    }, function _afterGetFromUFDS(err, conf) {
+        if (err) {
+            return next(translateErr(err));
+        }
+
+        res.send(modConfig.translateUfdsConf(conf));
+        return next();
+    });
+}
+
+
+function updateConfig(req, res, next) {
+    var account = req.account.uuid;
+    var dc = req.config.datacenter_name;
+    var netUuids = req.networks.map(function (n) { return n.uuid; });
+    var params;
+
+    try {
+        params = validateAndTranslate(req.params);
+    } catch (vErr) {
+        return next(vErr);
+    }
+
+    req.log.info({netUuids: netUuids, params: params}, 'Updating config');
+
+    if (netUuids.indexOf(params.defaultnetwork) === -1) {
+        return next(new restify.InvalidArgumentError('unknown network'));
+    }
+
+    return req.sdc.ufds.updateDcLocalConfig(account, dc, params,
+            function _afterConfUpdate(err, conf) {
+        if (err) {
+            /*
+             * If the dclocalconfig is missing, it's most likely due to a
+             * race with napi-ufds-watcher. The watcher usually takes several
+             * seconds after the creation of a user to create dclocalconfig.
+             */
+            if (err.name === 'MissingParameterError' &&
+                err.message.match('dclocalconfig')) {
+                return next(new restify.InternalError(
+                    'Config currently unavailable.'));
+            } else {
+                return next(translateErr(err));
+            }
+        }
+
+        res.send(modConfig.translateUfdsConf(conf));
+        return next();
+    });
+}
+
+
+
+///--- API
+
+
+function mountConfig(server, before) {
+    assert.object(server);
+    assert.ok(before);
+
+    var path = '/:account/config';
+
+    server.get({
+        path: path,
+        name: 'GetConfig'
+    }, before, getConfig);
+
+    server.head({
+        path: path,
+        name: 'HeadConfig'
+    }, before, getConfig);
+
+    server.put({
+        path: path,
+        name: 'UpdateConfig'
+    }, before, updateConfig);
+
+    return server;
+}
+
+
+
+module.exports = {
+    mount: mountConfig
+};
diff --git a/lib/endpoints/networks.js b/lib/endpoints/networks.js
new file mode 100644
index 0000000..df124e3
--- /dev/null
+++ b/lib/endpoints/networks.js
@@ -0,0 +1,603 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+
+var assert = require('assert-plus');
+var jsprim = require('jsprim');
+var restify = require('restify');
+var schemas = require('joyent-schemas').cloudapi;
+var util = require('util');
+var vasync = require('vasync');
+
+var modNetworks = require('../networks');
+var resources = require('../resources');
+
+var InternalError = restify.InternalError;
+var InvalidArgumentError = restify.InvalidArgumentError;
+var ResourceNotFoundError = restify.ResourceNotFoundError;
+
+var FABRIC_VLAN_FIELDS = ['description', 'name', 'vlan_id'];
+var FABRIC_NETWORK_FIELDS = ['description', 'fabric', 'gateway',
+    'internet_nat', 'name', 'provision_end_ip', 'provision_start_ip',
+    'resolvers', 'routes', 'subnet', 'uuid', 'vlan_id'];
+// Fields that are IPv4 addresses:
+var IP_FIELDS = ['gateway', 'provision_end_ip', 'provision_start_ip',
+    'resolvers', 'resolvers[0]', 'resolvers[1]', 'resolvers[2]',
+    'resolvers[3]'];
+var MAX_RESOLVERS = 4;
+
+
+/*
+ * Return an error if fabrics are not enabled in this DC
+ */
+function ensureFabricsEnabled(req, res, next) {
+    if (!req.config.fabrics_enabled) {
+        return next(new restify.NotImplementedError(
+                'fabrics not enabled for this datacenter'));
+    }
+
+    return next();
+}
+
+
+/*
+ * Return request options suitable for making requests to other APIs
+ */
+function reqOpts(req) {
+    return { headers: { 'x-request-id': req.getId() } };
+}
+
+
+/*
+ * Validate req.params against the given schema, and transform any parameters
+ * as necessary.
+ */
+function schemaValidate(schema, req) {
+    var err;
+    var params = jsprim.deepCopy(req.params);
+
+    delete params.account;
+    err = jsprim.validateJsonObject(schema, params);
+    if (err) {
+        if (IP_FIELDS.indexOf(err.jsv_details.property) !== -1 &&
+                err.message.match(/does not match the regex pattern/)) {
+            throw new InvalidArgumentError(err,
+                    util.format('property "%s": must be an IPv4 address',
+                    err.jsv_details.property));
+        }
+
+        throw new InvalidArgumentError(err, err.message);
+    }
+
+    if (params.hasOwnProperty('vlan_id')) {
+        params.vlan_id = Number(params.vlan_id);
+    }
+
+    return params;
+}
+
+
+/**
+ * Translate a NAPI error to a cloudapi-style error
+ */
+function translateErr(err) {
+    var msg = err.message;
+
+    if (err.body && err.body.errors && err.body.errors.length !== 0) {
+        msg = err.body.errors.map(function (bErr) {
+            if (!bErr.field) {
+                return bErr.message;
+            }
+
+            return util.format('property "%s": %s', bErr.field, bErr.message);
+        }).join(', ');
+    }
+
+    if (err.statusCode === 404) {
+        return new ResourceNotFoundError(err, msg);
+    } else {
+        return new InvalidArgumentError(err, msg);
+    }
+}
+
+
+// Note here "net" can be a network, fabric network or network_pool from NAPI
+function translateNetwork(net) {
+    assert.object(net, 'net');
+
+    var obj = {
+        id: net.uuid,
+        name: net.name
+    };
+
+    var isPublic;
+    if (typeof (net['public']) !== 'undefined') {
+        isPublic = net['public'];
+    } else if (net.fabric) {
+        isPublic = false;
+    } else {
+        isPublic = (net.nic_tag === modNetworks.EXTERNAL_NIC_TAG);
+    }
+
+    obj['public'] = isPublic;
+
+    if (net.description) {
+        obj.description = net.description;
+    }
+
+    if (net.fabric) {
+        FABRIC_NETWORK_FIELDS.forEach(function (p) {
+            if (p === 'uuid') {
+                return;
+            }
+
+            if (net.hasOwnProperty(p)) {
+                obj[p] = net[p];
+            }
+        });
+    }
+
+    return (obj);
+}
+
+
+// --- Functions
+
+function listNetworks(req, res, next) {
+    if (req.accountMgmt) {
+        resources.getRoleTags(req, res);
+    }
+
+    var fabricsOnly = req.query && req.query.fabric;
+    var networks = req.networks;
+
+    // req.networks includes both networks and pools. We don't want to list
+    // individual networks if their pool in included.
+
+    var skipNetworkUuids = [];
+    networks.forEach(function (n) {
+        // if it's a network pool...
+        if (Array.isArray(n.networks)) {
+            skipNetworkUuids = skipNetworkUuids.concat(n.networks);
+        }
+    });
+
+    networks = networks.filter(function (n) {
+        if (fabricsOnly && !n.fabric) {
+            return false;
+        }
+
+        // assuming this list never gets too big
+        return skipNetworkUuids.indexOf(n.uuid) === -1;
+    }).map(function (pool) {
+        return translateNetwork(pool);
+    });
+
+    req.log.debug({
+        networks: networks,
+        account: req.account.login
+    }, 'ListNetworks done');
+
+    res.send(networks);
+    return next();
+}
+
+
+function getNetwork(req, res, next) {
+    var _n = req.params.network;
+    var net = req.networks.filter(function (n) {
+        return (n.uuid === _n);
+    });
+    var network;
+
+    if (!net.length) {
+        return next(new ResourceNotFoundError('%s not found', _n));
+    }
+
+    if (req.accountMgmt) {
+        resources.getRoleTags(req, res);
+    }
+
+    network = translateNetwork(net[0]);
+
+    req.log.debug({
+        network: network,
+        account: req.account.login
+    }, 'GetNetwork');
+
+    res.send(network);
+    return next();
+}
+
+
+function listFabricVLANs(req, res, next) {
+    assert.ok(req.account);
+    assert.ok(req.sdc.napi);
+
+    var params = {
+        fields: FABRIC_VLAN_FIELDS
+    };
+
+    return req.sdc.napi.listFabricVLANs(req.account.uuid, params, reqOpts(req),
+            function (err, vlans) {
+        if (err) {
+            return next(translateErr(err));
+        }
+
+        req.log.debug({
+            vlans: vlans,
+            account: req.account.login
+        }, 'ListFabricVLANs done');
+
+        res.send(vlans);
+        return next();
+    });
+}
+
+
+function createFabricVLAN(req, res, next) {
+    var params;
+
+    assert.ok(req.account);
+    assert.ok(req.sdc.napi);
+
+    try {
+        params = schemaValidate(schemas.CreateFabricVLAN, req);
+    } catch (schemaErr) {
+        return next(schemaErr);
+    }
+
+    params.fields = FABRIC_VLAN_FIELDS;
+
+    return req.sdc.napi.createFabricVLAN(req.account.uuid, params,
+            reqOpts(req), function (err, vlan) {
+        if (err) {
+            return next(translateErr(err));
+        }
+
+        res.send(201, vlan);
+        return next();
+    });
+}
+
+
+function updateFabricVLAN(req, res, next) {
+    var params;
+    var vlanID;
+
+    assert.ok(req.account);
+    assert.ok(req.sdc.napi);
+
+    try {
+        params = schemaValidate(schemas.UpdateFabricVLAN, req);
+    } catch (schemaErr) {
+        return next(schemaErr);
+    }
+
+    vlanID = params.vlan_id;
+    delete params.vlan_id;
+    params.fields = FABRIC_VLAN_FIELDS;
+
+    return req.sdc.napi.updateFabricVLAN(req.account.uuid, vlanID, params,
+            reqOpts(req), function (err, vlan) {
+        if (err) {
+            return next(translateErr(err));
+        }
+
+        res.send(202, vlan);
+        return next();
+    });
+}
+
+
+function getFabricVLAN(req, res, next) {
+    var params;
+
+    assert.ok(req.account);
+    assert.ok(req.sdc.napi);
+
+    try {
+        params = schemaValidate(schemas.GetFabricVLAN, req);
+    } catch (schemaErr) {
+        return next(schemaErr);
+    }
+
+    params.fields = FABRIC_VLAN_FIELDS;
+
+    return req.sdc.napi.getFabricVLAN(req.account.uuid, params.vlan_id, params,
+            reqOpts(req), function (err, vlan) {
+        if (err) {
+            return next(translateErr(err));
+        }
+        res.send(vlan);
+        return next();
+    });
+}
+
+
+function deleteFabricVLAN(req, res, next) {
+    var params;
+
+    assert.ok(req.account);
+    assert.ok(req.sdc.napi);
+
+    try {
+        params = schemaValidate(schemas.DeleteFabricVLAN, req);
+    } catch (schemaErr) {
+        return next(schemaErr);
+    }
+
+    return req.sdc.napi.deleteFabricVLAN(req.account.uuid, params.vlan_id, {},
+            reqOpts(req), function (err, ignored) {
+        if (err) {
+            return next(translateErr(err));
+        }
+        res.send(204);
+        return next();
+    });
+}
+
+
+function listFabricNetworks(req, res, next) {
+    var params;
+
+    assert.ok(req.account);
+    assert.ok(req.sdc.napi);
+
+    try {
+        params = schemaValidate(schemas.ListFabricNetworks, req);
+    } catch (schemaErr) {
+        return next(schemaErr);
+    }
+
+    return req.sdc.napi.listFabricNetworks(req.account.uuid, params.vlan_id, {},
+            reqOpts(req), function (err, networks) {
+        if (err) {
+            return next(translateErr(err));
+        }
+
+        res.send(networks.map(function _translateNetwork(network) {
+            assert.object(network, 'network');
+
+            return translateNetwork(network);
+        }));
+
+        return next();
+    });
+}
+
+
+function createFabricNetwork(req, res, next) {
+    var params;
+    var vlanID;
+
+    assert.ok(req.account);
+    assert.ok(req.sdc.napi);
+
+    try {
+        params = schemaValidate(schemas.CreateFabricNetwork, req);
+        if (params.resolvers && params.resolvers.length > MAX_RESOLVERS) {
+            throw new InvalidArgumentError(util.format(
+                    'property "resolvers": maximum of %d resolvers',
+                    MAX_RESOLVERS));
+        }
+    } catch (schemaErr) {
+        return next(schemaErr);
+    }
+
+    vlanID = params.vlan_id;
+    delete params.vlan_id;
+    params.fields = FABRIC_NETWORK_FIELDS;
+
+    return req.sdc.napi.createFabricNetwork(req.account.uuid, vlanID, params,
+            reqOpts(req), function (err, network) {
+        if (err) {
+            return next(translateErr(err));
+        }
+
+        res.send(201, translateNetwork(network));
+        return next();
+    });
+}
+
+
+function getFabricNetwork(req, res, next) {
+    var params;
+
+    assert.ok(req.account);
+    assert.ok(req.sdc.napi);
+
+    try {
+        params = schemaValidate(schemas.GetFabricNetwork, req);
+    } catch (schemaErr) {
+        return next(schemaErr);
+    }
+
+    return req.sdc.napi.getFabricNetwork(req.account.uuid, params.vlan_id,
+            params.id, { fields: FABRIC_NETWORK_FIELDS }, reqOpts(req),
+            function (err, network) {
+        if (err) {
+            return next(translateErr(err));
+        }
+
+        res.send(translateNetwork(network));
+        return next();
+    });
+}
+
+
+function deleteFabricNetwork(req, res, next) {
+    var params;
+
+    assert.ok(req.account);
+    assert.ok(req.sdc.napi);
+
+    try {
+        params = schemaValidate(schemas.DeleteFabricNetwork, req);
+    } catch (schemaErr) {
+        return next(schemaErr);
+    }
+
+    return modNetworks.getDefaultFabricNetworkForUser(req.sdc.ufds,
+        req.config.datacenter_name, req.account, {
+        log: req.log
+    }, function _afterGetConf(getFabricNetErr, defaultFabricNet) {
+        if (getFabricNetErr) {
+            return next(getFabricNetErr);
+        }
+
+        if (!defaultFabricNet) {
+            return next(new InternalError('Could not find default fabric ' +
+                'network ' + 'for user'));
+        }
+
+        req.log.info({
+            networkToDelete: params.id,
+            defaultNetwork: defaultFabricNet.uuid
+        }, 'Deleting default network?');
+
+        if (params.id === defaultFabricNet.uuid) {
+            return next(new InvalidArgumentError(
+                'cannot delete default network'));
+        }
+
+        return req.sdc.napi.deleteFabricNetwork(req.account.uuid,
+                params.vlan_id, params.id, {}, reqOpts(req), function (err) {
+            if (err) {
+                next(translateErr(err));
+                return;
+            }
+
+            res.send(204);
+            return next();
+        });
+    });
+}
+
+
+function mountNetworks(server, before, pre) {
+    assert.object(server, 'server');
+    assert.ok(before, 'before');
+    assert.optionalArrayOfFunc(pre, 'pre');
+
+    pre = pre || [];
+
+    // --- Fabric VLANs
+
+    server.get({
+        path: '/:account/fabrics/default/vlans',
+        name: 'ListFabricVLANs',
+        version: [ '7.3.0', '8.0.0' ]
+    }, before, ensureFabricsEnabled, pre, listFabricVLANs);
+
+    server.head({
+        path: '/:account/fabrics/default/vlans',
+        name: 'HeadFabricVLANs',
+        version: [ '7.3.0', '8.0.0' ]
+    }, before, ensureFabricsEnabled, pre, listFabricVLANs);
+
+    server.post({
+        path: '/:account/fabrics/default/vlans',
+        name: 'CreateFabricVLAN',
+        version: [ '7.3.0', '8.0.0' ]
+    }, before, ensureFabricsEnabled, pre, createFabricVLAN);
+
+    server.put({
+        path: '/:account/fabrics/default/vlans/:vlan_id',
+        name: 'UpdateFabricVLAN',
+        version: [ '7.3.0', '8.0.0' ]
+    }, before, ensureFabricsEnabled, pre, updateFabricVLAN);
+
+    server.get({
+        path: '/:account/fabrics/default/vlans/:vlan_id',
+        name: 'GetFabricVLAN',
+        version: [ '7.3.0', '8.0.0' ]
+    }, before, ensureFabricsEnabled, pre, getFabricVLAN);
+
+    server.head({
+        path: '/:account/fabrics/default/vlans/:vlan_id',
+        name: 'GetFabricVLAN',
+        version: [ '7.3.0', '8.0.0' ]
+    }, before, ensureFabricsEnabled, pre, getFabricVLAN);
+
+    server.del({
+        path: '/:account/fabrics/default/vlans/:vlan_id',
+        name: 'DeleteFabricVLAN',
+        version: [ '7.3.0', '8.0.0' ]
+    }, before, ensureFabricsEnabled, pre, deleteFabricVLAN);
+
+    // --- Fabric Networks
+
+    server.get({
+        path: '/:account/fabrics/default/vlans/:vlan_id/networks',
+        name: 'ListFabricNetworks',
+        version: [ '7.3.0', '8.0.0' ]
+    }, before, ensureFabricsEnabled, pre, listFabricNetworks);
+
+    server.head({
+        path: '/:account/fabrics/default/vlans/:vlan_id/networks',
+        name: 'HeadFabricNetworks',
+        version: [ '7.3.0', '8.0.0' ]
+    }, before, ensureFabricsEnabled, pre, listFabricNetworks);
+
+    server.post({
+        path: '/:account/fabrics/default/vlans/:vlan_id/networks',
+        name: 'CreateFabricNetwork',
+        version: [ '7.3.0', '8.0.0' ]
+    }, before, ensureFabricsEnabled, pre, createFabricNetwork);
+
+    server.get({
+        path: '/:account/fabrics/default/vlans/:vlan_id/networks/:id',
+        name: 'GetFabricNetwork',
+        version: [ '7.3.0', '8.0.0' ]
+    }, before, ensureFabricsEnabled, pre, getFabricNetwork);
+
+    server.head({
+        path: '/:account/fabrics/default/vlans/:vlan_id/networks/:id',
+        name: 'GetFabricNetwork',
+        version: [ '7.3.0', '8.0.0' ]
+    }, before, ensureFabricsEnabled, pre, getFabricNetwork);
+
+    server.del({
+        path: '/:account/fabrics/default/vlans/:vlan_id/networks/:id',
+        name: 'DeleteFabricNetwork',
+        version: [ '7.3.0', '8.0.0' ]
+    }, before, ensureFabricsEnabled, pre, deleteFabricNetwork);
+
+    // --- Networks (non-fabric)
+
+    server.get({
+        path: '/:account/networks',
+        name: 'ListNetworks'
+    }, before, pre, listNetworks);
+
+    server.head({
+        path: '/:account/networks',
+        name: 'HeadNetworks'
+    }, before, pre, listNetworks);
+
+    server.get({
+        path: '/:account/networks/:network',
+        name: 'GetNetwork'
+    }, before, pre, getNetwork);
+
+    server.head({
+        path: '/:account/networks/:network',
+        name: 'HeadNetwork'
+    }, before, pre, getNetwork);
+
+    return server;
+}
+
+
+// --- API
+
+module.exports = {
+    mount: mountNetworks
+};
diff --git a/lib/middleware/networks.js b/lib/middleware/networks.js
new file mode 100644
index 0000000..b298755
--- /dev/null
+++ b/lib/middleware/networks.js
@@ -0,0 +1,139 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+
+var assert = require('assert-plus');
+
+
+var modNetworks = require('../networks');
+
+
+function loadNetworks(req, res, next) {
+    var method = req.method.toUpperCase();
+    var pathname = req.getUrl().pathname;
+
+    var napi = req.sdc.napi;
+    assert.ok(napi);
+
+    if (pathname === '/--ping') {
+        return next();
+    }
+
+    assert.ok(req.account);
+    var accountUuid = req.account.uuid;
+    assert.ok(accountUuid);
+
+    var netFilterOpts = {
+        provisionable_by: accountUuid
+    };
+
+    if (req.query && req.query.fabric) {
+        netFilterOpts = {
+            fabric: true,
+            owner_uuid: accountUuid
+        };
+    }
+
+
+    // Skip network loading and filtering except for a few cases:
+    // network endpoints
+    if (!/\/networks/.test(pathname) &&
+        // machine creation or nic addition (some AddNic plugins use this)
+        !(method === 'POST' && /\/(?:machines|nics)$/.test(pathname)) &&
+        // updating user config (requires checking network existence)
+        !(method === 'PUT' && /\/config/.test(pathname))) {
+        return next();
+    }
+
+    return napi.listNetworkPools({
+        provisionable_by: accountUuid
+    }, {
+        'x-request-id': req.getId()
+    }, function (err, pools) {
+        if (err) {
+            return next(err);
+        }
+
+        var networks = [];
+        var externalNetworks = [];
+        var internalNetworks = [];
+        var networksInPools = {};
+
+        // Always skip admin network pools:
+        pools = pools.filter(function (pool) {
+            return (pool.nic_tag !== modNetworks.ADMIN_NIC_TAG);
+        });
+
+        pools.forEach(function (pool) {
+            var isFabric = false;
+            networks.push(pool);
+
+            pool.networks.forEach(function (net) {
+                networksInPools[net.uuid] = true;
+                if (net.fabric === true) {
+                    isFabric = true;
+                }
+            });
+
+            if (pool.nic_tag === modNetworks.EXTERNAL_NIC_TAG) {
+                externalNetworks.push(pool.uuid);
+            } else if (pool.nic_tag === modNetworks.INTERNAL_NIC_TAG ||
+                isFabric === true) {
+                internalNetworks.push(pool.uuid);
+            }
+        });
+
+        return napi.listNetworks(netFilterOpts, {
+            'x-request-id': req.getId()
+        }, function (err2, nets) {
+            if (err2) {
+                return next(err2);
+            }
+
+            // Always skip admin networks, and don't add networks which are
+            // already in contained pools:
+            nets = nets.filter(function (net) {
+                return net.nic_tag !== modNetworks.ADMIN_NIC_TAG &&
+                    !networksInPools[net.uuid];
+            });
+
+            networks = networks.concat(nets);
+
+            networks.forEach(function (net) {
+                if (net.nic_tag === modNetworks.EXTERNAL_NIC_TAG) {
+                    externalNetworks.push(net.uuid);
+                } else if (net.nic_tag === modNetworks.INTERNAL_NIC_TAG ||
+                    net.fabric === true) {
+                    internalNetworks.push(net.uuid);
+                }
+            });
+
+            // uuids of all publically-accessible networks accessible by user
+            req.external_nets = externalNetworks;
+
+            // uuids of all internally-accessible networks accessible by user
+            req.internal_nets = internalNetworks;
+
+            // objects of all networks accessible by user
+            req.networks = networks;
+
+            req.log.debug({
+                external: req.external_nets,
+                internal: req.internal_nets
+            }, 'networks loaded');
+
+            return next();
+        });
+    });
+}
+
+
+module.exports = {
+    loadNetworks: loadNetworks
+};
\ No newline at end of file
diff --git a/lib/networks.js b/lib/networks.js
index c59d9b7..16aa7bd 100644
--- a/lib/networks.js
+++ b/lib/networks.js
@@ -9,691 +9,116 @@
  */
 
 var assert = require('assert-plus');
-var util = require('util');
-var mod_config = require('./config');
-var restify = require('restify');
-var schemas = require('joyent-schemas').cloudapi;
-var jsprim = require('jsprim');
-var vasync = require('vasync');
 
-var resources = require('./resources');
-var ResourceNotFoundError = restify.ResourceNotFoundError;
-var InvalidArgumentError = restify.InvalidArgumentError;
+var mod_config = require('./config');
 
+var ADMIN_NIC_TAG = 'admin';
 var EXTERNAL_NIC_TAG = 'external';
 var INTERNAL_NIC_TAG = 'internal';
-var ADMIN_NIC_TAG    = 'admin';
-var FABRIC_VLAN_FIELDS = ['description', 'name', 'vlan_id'];
-var FABRIC_NETWORK_FIELDS = ['description', 'fabric', 'gateway',
-    'internet_nat', 'name', 'provision_end_ip', 'provision_start_ip',
-    'resolvers', 'routes', 'subnet', 'uuid', 'vlan_id'];
-// Fields that are IPv4 addresses:
-var IP_FIELDS = ['gateway', 'provision_end_ip', 'provision_start_ip',
-    'resolvers', 'resolvers[0]', 'resolvers[1]', 'resolvers[2]',
-    'resolvers[3]'];
-var MAX_RESOLVERS = 4;
-
-
-/*
- * Return an error if fabrics are not enabled in this DC
- */
-function ensureFabricsEnabled(req, res, next) {
-    if (!req.config.fabrics_enabled) {
-        return next(new restify.NotImplementedError(
-                'fabrics not enabled for this datacenter'));
-    }
-
-    return next();
-}
-
-
-/*
- * Return request options suitable for making requests to other APIs
- */
-function reqOpts(req) {
-    return { headers: { 'x-request-id': req.getId() } };
-}
-
-
-/*
- * Validate req.params against the given schema, and transform any parameters
- * as necessary.
- */
-function schemaValidate(schema, req) {
-    var err;
-    var params = jsprim.deepCopy(req.params);
-
-    delete params.account;
-    err = jsprim.validateJsonObject(schema, params);
-    if (err) {
-        if (IP_FIELDS.indexOf(err.jsv_details.property) !== -1 &&
-                err.message.match(/does not match the regex pattern/)) {
-            throw new InvalidArgumentError(err,
-                    util.format('property "%s": must be an IPv4 address',
-                    err.jsv_details.property));
-        }
-
-        throw new InvalidArgumentError(err, err.message);
-    }
-
-    if (params.hasOwnProperty('vlan_id')) {
-        params.vlan_id = Number(params.vlan_id);
-    }
-
-    return params;
-}
-
-
-/**
- * Translate a NAPI error to a cloudapi-style error
- */
-function translateErr(err) {
-    var msg = err.message;
-
-    if (err.body && err.body.errors && err.body.errors.length !== 0) {
-        msg = err.body.errors.map(function (bErr) {
-            if (!bErr.field) {
-                return bErr.message;
-            }
-
-            return util.format('property "%s": %s', bErr.field, bErr.message);
-        }).join(', ');
-    }
-
-    if (err.statusCode === 404) {
-        return new ResourceNotFoundError(err, msg);
-    } else {
-        return new InvalidArgumentError(err, msg);
-    }
-}
 
+function checkFabricNetworks(napiClient, networks, accountUuid, cb) {
+    assert.object(napiClient, 'napiClient');
+    assert.arrayOfUuid(networks, 'networks');
+    assert.uuid(accountUuid, 'accountUuid');
+    assert.func(cb, 'cb');
 
-// Note here "net" can be a network, fabric network or network_pool from NAPI
-function translateNetwork(net) {
-    assert.ok(net);
-
-    var obj = {
-        id: net.uuid,
-        name: net.name
+    var listNetworkParams = {
+        owner_uuid: accountUuid,
+        fabric: true
     };
 
-    var isPublic;
-    if (typeof (net['public']) !== 'undefined') {
-        isPublic = net['public'];
-    } else if (net.fabric) {
-        isPublic = false;
-    } else {
-        isPublic = (net.nic_tag === EXTERNAL_NIC_TAG);
+    /*
+     * We consider that, in an empty list of networks, all networks are fabric
+     * networks.
+     */
+    if (networks.length === 0) {
+        return cb(null, true);
     }
 
-    obj['public'] = isPublic;
+    return napiClient.listNetworks(listNetworkParams,
+        function onListFabricNetworks(listNetworksErr, actualFabricNetworks) {
+            var fabricNetworkUuids = [];
+            var i;
 
-    if (net.description) {
-        obj.description = net.description;
-    }
+            if (listNetworksErr) {
+                return cb(listNetworksErr, false);
 
-    if (net.fabric) {
-        FABRIC_NETWORK_FIELDS.forEach(function (p) {
-            if (p === 'uuid') {
-                return;
             }
 
-            if (net.hasOwnProperty(p)) {
-                obj[p] = net[p];
-            }
-        });
-    }
-
-    return (obj);
-}
-
-
-// --- Functions
-function preLoadNetworks(req, res, next) {
-    var method = req.method.toUpperCase();
-    var pathname = req.getUrl().pathname;
-
-    var napi = req.sdc.napi;
-    assert.ok(napi);
-
-    if (pathname === '/--ping') {
-        return next();
-    }
-
-    assert.ok(req.account);
-    var accountUuid = req.account.uuid;
-    assert.ok(accountUuid);
-
-    var netFilterOpts = {
-        provisionable_by: accountUuid
-    };
-
-    if (req.query && req.query.fabric) {
-        netFilterOpts = {
-            fabric: true,
-            owner_uuid: accountUuid
-        };
-    }
-
-    // Skip network loading and filtering except for a few cases:
-        // network endpoints
-    if (!/\/networks/.test(pathname) &&
-        // machine creation or nic addition (some AddNic plugins use this)
-        !(method === 'POST' && /\/(?:machines|nics)$/.test(pathname)) &&
-        // updating user config (requires checking network existence)
-        !(method === 'PUT' && /\/config/.test(pathname))) {
-        return next();
-    }
-
-    return napi.listNetworkPools({
-        provisionable_by: accountUuid
-    }, reqOpts(req), function (err, pools) {
-        if (err) {
-            return next(err);
-        }
-
-        var networks = [];
-        var externalNetworks = [];
-        var internalNetworks = [];
-        var networksInPools = {};
-
-        // Always skip admin network pools:
-        pools = pools.filter(function (pool) {
-            return (pool.nic_tag !== ADMIN_NIC_TAG);
-        });
-
-        pools.forEach(function (pool) {
-            var isFabric = false;
-            networks.push(pool);
-
-            pool.networks.forEach(function (net) {
-                networksInPools[net.uuid] = true;
-                if (net.fabric === true) {
-                    isFabric = true;
+            assert.arrayOfObject(actualFabricNetworks, 'actualFabricNetworks');
+
+            // pull out just the UUIDs, so fabricNetworkUuids will be an array
+            // of just uuids of the fabric networks.
+            fabricNetworkUuids = actualFabricNetworks.map(
+                function mapUuids(network) {
+                    return network.uuid;
+                });
+
+            //
+            // Loop through all networks, if the network is found in
+            // fabricNetworkUuids (meaning: it's a fabric network) keep going.
+            // If it's not a fabric network, call:
+            //
+            //     cb(null, false);
+            //
+            // to indicate that some networks passed were not fabric networks.
+            // If we get to the end of the list and haven't found any non-fabric
+            // networks, call:
+            //
+            //     cb(null, true);
+            //
+            for (i = 0; i < networks.length; ++i) {
+                if (fabricNetworkUuids.indexOf(networks[i]) === -1) {
+                    // networks[i] does not exist in fabricNetworkUuids, so
+                    // at least one of the networks passed was non-fabric.
+                    return cb(null, false);
                 }
-            });
-
-            if (pool.nic_tag === EXTERNAL_NIC_TAG) {
-                externalNetworks.push(pool.uuid);
-            } else if (pool.nic_tag === INTERNAL_NIC_TAG || isFabric === true) {
-                internalNetworks.push(pool.uuid);
             }
-        });
-
-        return napi.listNetworks(netFilterOpts, reqOpts(req),
-                function (err2, nets) {
-            if (err2) {
-                return next(err2);
-            }
-
-            // Always skip admin networks, and don't add networks which are
-            // already in contained pools:
-            nets = nets.filter(function (net) {
-                return net.nic_tag !== ADMIN_NIC_TAG &&
-                    !networksInPools[net.uuid];
-            });
-
-            networks = networks.concat(nets);
 
-            networks.forEach(function (net) {
-                if (net.nic_tag === EXTERNAL_NIC_TAG) {
-                    externalNetworks.push(net.uuid);
-                } else if (net.nic_tag === INTERNAL_NIC_TAG ||
-                    net.fabric === true) {
-                    internalNetworks.push(net.uuid);
-                }
-            });
-
-            // uuids of all publically-accessible networks accessible by user
-            req.external_nets = externalNetworks;
-
-            // uuids of all internally-accessible networks accessible by user
-            req.internal_nets = internalNetworks;
-
-            // objects of all networks accessible by user
-            req.networks = networks;
-
-            req.log.debug({
-                external: req.external_nets,
-                internal: req.internal_nets
-            }, 'networks loaded');
-
-            return next();
+            // All networks passed were fabric networks.
+            return cb(null, true);
         });
-    });
 }
 
-
-function listNetworks(req, res, next) {
-    if (req.accountMgmt) {
-        resources.getRoleTags(req, res);
-    }
-
-    var fabricsOnly = req.query && req.query.fabric;
-    var networks = req.networks;
-
-    // req.networks includes both networks and pools. We don't want to list
-    // individual networks if their pool in included.
-
-    var skipNetworkUuids = [];
-    networks.forEach(function (n) {
-        // if it's a network pool...
-        if (Array.isArray(n.networks)) {
-            skipNetworkUuids = skipNetworkUuids.concat(n.networks);
+function getDefaultFabricNetworkForUser(ufdsClient, dataCenterName, account,
+    options, cb) {
+    assert.object(ufdsClient, 'ufdsClient');
+    assert.string(dataCenterName, 'dataCenterName');
+    assert.object(account, 'account');
+    assert.object(options, 'options');
+    assert.object(options.log, 'options.log');
+    assert.func(cb, 'cb');
+
+    mod_config.getAccountDcConfigFromUFDS(ufdsClient, account, dataCenterName, {
+        log: options.log
+    },  function onGetDcLocalConfig(getDcLocalConfigErr, conf) {
+        if (getDcLocalConfigErr) {
+            cb(getDcLocalConfigErr);
+            return;
         }
-    });
+        options.log.info({conf: conf}, 'config');
 
-    networks = networks.filter(function (n) {
-        if (fabricsOnly && !n.fabric) {
-            return false;
+        if (!conf || !conf.defaultnetwork) {
+            cb(new Error('Could not get default network'));
+            return;
         }
 
-        // assuming this list never gets too big
-        return skipNetworkUuids.indexOf(n.uuid) === -1;
-    }).map(function (pool) {
-        return translateNetwork(pool);
+        cb(null, {uuid: conf.defaultnetwork});
     });
-
-    req.log.debug({
-        networks: networks,
-        account: req.account.login
-    }, 'ListNetworks done');
-
-    res.send(networks);
-    return next();
-}
-
-
-function getNetwork(req, res, next) {
-    var _n = req.params.network;
-    var net = req.networks.filter(function (n) {
-        return (n.uuid === _n);
-    });
-    var network;
-
-    if (!net.length) {
-        return next(new ResourceNotFoundError('%s not found', _n));
-    }
-
-    if (req.accountMgmt) {
-        resources.getRoleTags(req, res);
-    }
-
-    network = translateNetwork(net[0]);
-
-    req.log.debug({
-        network: network,
-        account: req.account.login
-    }, 'GetNetwork');
-
-    res.send(network);
-    return next();
 }
 
-
-function listFabricVLANs(req, res, next) {
-    assert.ok(req.account);
-    assert.ok(req.sdc.napi);
-
-    var params = {
-        fields: FABRIC_VLAN_FIELDS
+function getBuiltinNicTags() {
+    return {
+        admin: 'admin',
+        external: 'external',
+        internal: 'internal'
     };
-
-    return req.sdc.napi.listFabricVLANs(req.account.uuid, params, reqOpts(req),
-            function (err, vlans) {
-        if (err) {
-            return next(translateErr(err));
-        }
-
-        req.log.debug({
-            vlans: vlans,
-            account: req.account.login
-        }, 'ListFabricVLANs done');
-
-        res.send(vlans);
-        return next();
-    });
-}
-
-
-function createFabricVLAN(req, res, next) {
-    var params;
-
-    assert.ok(req.account);
-    assert.ok(req.sdc.napi);
-
-    try {
-        params = schemaValidate(schemas.CreateFabricVLAN, req);
-    } catch (schemaErr) {
-        return next(schemaErr);
-    }
-
-    params.fields = FABRIC_VLAN_FIELDS;
-
-    return req.sdc.napi.createFabricVLAN(req.account.uuid, params,
-            reqOpts(req), function (err, vlan) {
-        if (err) {
-            return next(translateErr(err));
-        }
-
-        res.send(201, vlan);
-        return next();
-    });
-}
-
-
-function updateFabricVLAN(req, res, next) {
-    var params;
-    var vlanID;
-
-    assert.ok(req.account);
-    assert.ok(req.sdc.napi);
-
-    try {
-        params = schemaValidate(schemas.UpdateFabricVLAN, req);
-    } catch (schemaErr) {
-        return next(schemaErr);
-    }
-
-    vlanID = params.vlan_id;
-    delete params.vlan_id;
-    params.fields = FABRIC_VLAN_FIELDS;
-
-    return req.sdc.napi.updateFabricVLAN(req.account.uuid, vlanID, params,
-            reqOpts(req), function (err, vlan) {
-        if (err) {
-            return next(translateErr(err));
-        }
-
-        res.send(202, vlan);
-        return next();
-    });
-}
-
-
-function getFabricVLAN(req, res, next) {
-    var params;
-
-    assert.ok(req.account);
-    assert.ok(req.sdc.napi);
-
-    try {
-        params = schemaValidate(schemas.GetFabricVLAN, req);
-    } catch (schemaErr) {
-        return next(schemaErr);
-    }
-
-    params.fields = FABRIC_VLAN_FIELDS;
-
-    return req.sdc.napi.getFabricVLAN(req.account.uuid, params.vlan_id, params,
-            reqOpts(req), function (err, vlan) {
-        if (err) {
-            return next(translateErr(err));
-        }
-        res.send(vlan);
-        return next();
-    });
-}
-
-
-function deleteFabricVLAN(req, res, next) {
-    var params;
-
-    assert.ok(req.account);
-    assert.ok(req.sdc.napi);
-
-    try {
-        params = schemaValidate(schemas.DeleteFabricVLAN, req);
-    } catch (schemaErr) {
-        return next(schemaErr);
-    }
-
-    return req.sdc.napi.deleteFabricVLAN(req.account.uuid, params.vlan_id, {},
-            reqOpts(req), function (err, ignored) {
-        if (err) {
-            return next(translateErr(err));
-        }
-        res.send(204);
-        return next();
-    });
-}
-
-
-function listFabricNetworks(req, res, next) {
-    var params;
-
-    assert.ok(req.account);
-    assert.ok(req.sdc.napi);
-
-    try {
-        params = schemaValidate(schemas.ListFabricNetworks, req);
-    } catch (schemaErr) {
-        return next(schemaErr);
-    }
-
-    return req.sdc.napi.listFabricNetworks(req.account.uuid, params.vlan_id, {},
-            reqOpts(req), function (err, networks) {
-        if (err) {
-            return next(translateErr(err));
-        }
-
-        res.send(networks.map(translateNetwork));
-        return next();
-    });
-}
-
-
-function createFabricNetwork(req, res, next) {
-    var params;
-    var vlanID;
-
-    assert.ok(req.account);
-    assert.ok(req.sdc.napi);
-
-    try {
-        params = schemaValidate(schemas.CreateFabricNetwork, req);
-        if (params.resolvers && params.resolvers.length > MAX_RESOLVERS) {
-            throw new InvalidArgumentError(util.format(
-                    'property "resolvers": maximum of %d resolvers',
-                    MAX_RESOLVERS));
-        }
-    } catch (schemaErr) {
-        return next(schemaErr);
-    }
-
-    vlanID = params.vlan_id;
-    delete params.vlan_id;
-    params.fields = FABRIC_NETWORK_FIELDS;
-
-    return req.sdc.napi.createFabricNetwork(req.account.uuid, vlanID, params,
-            reqOpts(req), function (err, network) {
-        if (err) {
-            return next(translateErr(err));
-        }
-
-        res.send(201, translateNetwork(network));
-        return next();
-    });
-}
-
-
-function getFabricNetwork(req, res, next) {
-    var params;
-
-    assert.ok(req.account);
-    assert.ok(req.sdc.napi);
-
-    try {
-        params = schemaValidate(schemas.GetFabricNetwork, req);
-    } catch (schemaErr) {
-        return next(schemaErr);
-    }
-
-    return req.sdc.napi.getFabricNetwork(req.account.uuid, params.vlan_id,
-            params.id, { fields: FABRIC_NETWORK_FIELDS }, reqOpts(req),
-            function (err, network) {
-        if (err) {
-            return next(translateErr(err));
-        }
-
-        res.send(translateNetwork(network));
-        return next();
-    });
-}
-
-
-function deleteFabricNetwork(req, res, next) {
-    var params;
-
-    assert.ok(req.account);
-    assert.ok(req.sdc.napi);
-
-    try {
-        params = schemaValidate(schemas.DeleteFabricNetwork, req);
-    } catch (schemaErr) {
-        return next(schemaErr);
-    }
-
-    return mod_config.get(req, function _afterGetConf(confErr, conf) {
-        if (confErr) {
-            return next(confErr);
-        }
-
-        if (params.id === conf.default_network) {
-            return next(new InvalidArgumentError(
-                    'cannot delete default network'));
-        }
-
-        return req.sdc.napi.deleteFabricNetwork(req.account.uuid,
-                params.vlan_id, params.id, {}, reqOpts(req), function (err) {
-            if (err) {
-                return next(translateErr(err));
-            }
-
-            res.send(204);
-            return next();
-        });
-    });
 }
 
-
-function mountNetworks(server, before, pre) {
-    assert.object(server, 'server');
-    assert.ok(before, 'before');
-
-    pre = pre || [];
-
-    // --- Fabric VLANs
-
-    server.get({
-        path: '/:account/fabrics/default/vlans',
-        name: 'ListFabricVLANs',
-        version: [ '7.3.0', '8.0.0' ]
-    }, before, ensureFabricsEnabled, pre, listFabricVLANs);
-
-    server.head({
-        path: '/:account/fabrics/default/vlans',
-        name: 'HeadFabricVLANs',
-        version: [ '7.3.0', '8.0.0' ]
-    }, before, ensureFabricsEnabled, pre, listFabricVLANs);
-
-    server.post({
-        path: '/:account/fabrics/default/vlans',
-        name: 'CreateFabricVLAN',
-        version: [ '7.3.0', '8.0.0' ]
-    }, before, ensureFabricsEnabled, pre, createFabricVLAN);
-
-    server.put({
-        path: '/:account/fabrics/default/vlans/:vlan_id',
-        name: 'UpdateFabricVLAN',
-        version: [ '7.3.0', '8.0.0' ]
-    }, before, ensureFabricsEnabled, pre, updateFabricVLAN);
-
-    server.get({
-        path: '/:account/fabrics/default/vlans/:vlan_id',
-        name: 'GetFabricVLAN',
-        version: [ '7.3.0', '8.0.0' ]
-    }, before, ensureFabricsEnabled, pre, getFabricVLAN);
-
-    server.head({
-        path: '/:account/fabrics/default/vlans/:vlan_id',
-        name: 'GetFabricVLAN',
-        version: [ '7.3.0', '8.0.0' ]
-    }, before, ensureFabricsEnabled, pre, getFabricVLAN);
-
-    server.del({
-        path: '/:account/fabrics/default/vlans/:vlan_id',
-        name: 'DeleteFabricVLAN',
-        version: [ '7.3.0', '8.0.0' ]
-    }, before, ensureFabricsEnabled, pre, deleteFabricVLAN);
-
-    // --- Fabric Networks
-
-    server.get({
-        path: '/:account/fabrics/default/vlans/:vlan_id/networks',
-        name: 'ListFabricNetworks',
-        version: [ '7.3.0', '8.0.0' ]
-    }, before, ensureFabricsEnabled, pre, listFabricNetworks);
-
-    server.head({
-        path: '/:account/fabrics/default/vlans/:vlan_id/networks',
-        name: 'HeadFabricNetworks',
-        version: [ '7.3.0', '8.0.0' ]
-    }, before, ensureFabricsEnabled, pre, listFabricNetworks);
-
-    server.post({
-        path: '/:account/fabrics/default/vlans/:vlan_id/networks',
-        name: 'CreateFabricNetwork',
-        version: [ '7.3.0', '8.0.0' ]
-    }, before, ensureFabricsEnabled, pre, createFabricNetwork);
-
-    server.get({
-        path: '/:account/fabrics/default/vlans/:vlan_id/networks/:id',
-        name: 'GetFabricNetwork',
-        version: [ '7.3.0', '8.0.0' ]
-    }, before, ensureFabricsEnabled, pre, getFabricNetwork);
-
-    server.head({
-        path: '/:account/fabrics/default/vlans/:vlan_id/networks/:id',
-        name: 'GetFabricNetwork',
-        version: [ '7.3.0', '8.0.0' ]
-    }, before, ensureFabricsEnabled, pre, getFabricNetwork);
-
-    server.del({
-        path: '/:account/fabrics/default/vlans/:vlan_id/networks/:id',
-        name: 'DeleteFabricNetwork',
-        version: [ '7.3.0', '8.0.0' ]
-    }, before, ensureFabricsEnabled, pre, deleteFabricNetwork);
-
-    // --- Networks (non-fabric)
-
-    server.get({
-        path: '/:account/networks',
-        name: 'ListNetworks'
-    }, before, pre, listNetworks);
-
-    server.head({
-        path: '/:account/networks',
-        name: 'HeadNetworks'
-    }, before, pre, listNetworks);
-
-    server.get({
-        path: '/:account/networks/:network',
-        name: 'GetNetwork'
-    }, before, pre, getNetwork);
-
-    server.head({
-        path: '/:account/networks/:network',
-        name: 'HeadNetwork'
-    }, before, pre, getNetwork);
-
-    return server;
-}
-
-
-// --- API
-
 module.exports = {
-    loadNetworks: preLoadNetworks,
-    mount: mountNetworks
+    ADMIN_NIC_TAG: ADMIN_NIC_TAG,
+    checkFabricNetworks: checkFabricNetworks,
+    EXTERNAL_NIC_TAG: EXTERNAL_NIC_TAG,
+    getDefaultFabricNetworkForUser: getDefaultFabricNetworkForUser,
+    INTERNAL_NIC_TAG: INTERNAL_NIC_TAG
 };
diff --git a/main.js b/main.js
index 2c61546..d110bbf 100644
--- a/main.js
+++ b/main.js
@@ -28,12 +28,11 @@ var auditLogger = require('./lib/audit_logger');
 var RequestCaptureStream = restify.bunyan.RequestCaptureStream;
 
 var app = require('./lib').app;
-
+var mod_config = require('./lib/config.js');
 
 
 // --- Globals
 
-var DEFAULT_CFG = __dirname + '/etc/cloudapi.config.json';
 var LOG;
 var PARSED;
 
@@ -108,60 +107,6 @@ function usage(code, message) {
 }
 
 
-function configure(file, options, log) {
-    assert.string(file, 'file');
-    assert.object(options, 'options');
-    assert.object(log, 'log');
-    var config;
-
-    try {
-        config = JSON.parse(fs.readFileSync(file, 'utf8'));
-
-        if (config.certificate && config.key && !config.port) {
-            config.port = 443;
-        }
-
-        if (!config.port) {
-            config.port = 80;
-        }
-
-    } catch (e1) {
-        console.error('Unable to parse %s: %s', file, e1.message);
-        process.exit(1);
-    }
-
-    if (options.port) {
-        config.port = options.port;
-    }
-
-    try {
-        if (config.certificate) {
-            config.certificate = fs.readFileSync(config.certificate, 'utf8');
-        }
-    } catch (e2) {
-        console.error('Unable to load %s: %s', config.certificate, e2.message);
-        process.exit(1);
-    }
-
-    try {
-        if (config.key) {
-            config.key = fs.readFileSync(config.key, 'utf8');
-        }
-    } catch (e3) {
-        console.error('Unable to load %s: %s', config.certificate, e3.message);
-        process.exit(1);
-    }
-
-    if (typeof (config.maxHttpSockets) === 'number') {
-        log.info('Tuning max sockets to %d', config.maxHttpSockets);
-        http.globalAgent.maxSockets = config.maxHttpSockets;
-        https.globalAgent.maxSockets = config.maxHttpSockets;
-    }
-
-    return config;
-}
-
-
 // Create a temporary server which simply returns 500 to all requests
 function createBootstrapServer(port, log, cb) {
     var bootstrapServer = restify.createServer({ log: log });
@@ -202,7 +147,11 @@ function run() {
         serializers: restify.bunyan.serializers
     });
 
-    var config = configure(PARSED.file || DEFAULT_CFG, PARSED, LOG);
+    var config = mod_config.configure({
+        configFilePath: PARSED.file,
+        overrides: PARSED,
+        log: LOG
+    });
 
     setupLogger(config);
     config.log = LOG;
-- 
2.21.0

