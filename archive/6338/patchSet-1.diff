From 950704fa122a1959af4c67c427f881d6a3ab3282 Mon Sep 17 00:00:00 2001
From: Pedro Palazon Candel <pedro@joyent.com>
Date: Tue, 21 May 2019 21:24:50 +0200
Subject: [PATCH] TRITON-1681 PAPI should use node-eslint-plugin-joyent for
 linting

---
 .eslintrc                                     |  46 +++
 Makefile                                      |   5 +-
 lib/backend.js                                |  77 +++--
 .../migration-001-remove-stale-attributes.js  |  13 +-
 lib/papi.js                                   | 304 +++++++++++-------
 lib/tools.js                                  |  19 +-
 lib/validations.js                            |  69 ++--
 package.json                                  |   6 +-
 server.js                                     |   4 +-
 9 files changed, 342 insertions(+), 201 deletions(-)
 create mode 100644 .eslintrc

diff --git a/.eslintrc b/.eslintrc
new file mode 100644
index 0000000..d3af698
--- /dev/null
+++ b/.eslintrc
@@ -0,0 +1,46 @@
+{
+    "plugins": [ "joyent" ],
+    "extends": [
+        "eslint:recommended",
+        "plugin:joyent/style",
+        "plugin:joyent/lint"
+    ],
+    "parserOptions": {
+        "ecmaVersion": 6,
+        "sourceType": "script",
+        "ecmaFeatures": {
+        }
+    },
+    "env": {
+        "node": true,
+        "es6": true
+    },
+    "rules": {
+        // Local rule configuration
+        "no-unused-vars": [
+            "error",
+            {
+                // Track all unused identifiers
+                "vars": "all",
+                "args": "all",
+                "caughtErrors": "all",
+                // Don't warn on args that start with _, res or req.
+                // Added stdout and stderr to the standard joyent set.
+                "argsIgnorePattern": "^(_|res|req|stdout|stderr)",
+                // Don't warn on catch or var identifiers that start with _
+                "caughtIgnorePattern": "^_",
+                "varsIgnorePattern": "^_"
+            }
+        ],
+        "max-len": [
+            "error",
+            80,
+            {
+                "tabWidth": 8,
+                "ignoreComments": false,
+                "ignoreTrailingComments": false,
+                "ignoreUrls": true
+            }
+        ],
+    }
+}
diff --git a/Makefile b/Makefile
index e6920cf..44370a7 100644
--- a/Makefile
+++ b/Makefile
@@ -5,7 +5,7 @@
 #
 
 #
-# Copyright (c) 2019, Joyent, Inc.
+# Copyright 2019 Joyent, Inc.
 #
 
 #
@@ -34,9 +34,8 @@ DOC_FILES	 = index.md
 RESTDOWN_FLAGS   = --brand-dir=deps/restdown-brand-remora
 EXTRA_DOC_DEPS += deps/restdown-brand-remora/.git
 JS_FILES	:= $(shell ls *.js) $(shell find lib test -name '*.js')
+ESLINT_FILES	= $(JS_FILES)
 JSON_FILES	 = package.json
-JSL_CONF_NODE	 = tools/jsl.node.conf
-JSL_FILES_NODE	 = $(JS_FILES)
 JSSTYLE_FILES	 = $(JS_FILES)
 JSSTYLE_FLAGS	 = -f tools/jsstyle.conf
 SMF_MANIFESTS_IN = smf/manifests/papi.xml.in
diff --git a/lib/backend.js b/lib/backend.js
index 0fe0f21..9de6a93 100644
--- a/lib/backend.js
+++ b/lib/backend.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2017, Joyent, Inc.
+ * Copyright 2019 Joyent, Inc.
  */
 
 /*
@@ -13,7 +13,7 @@
  * or modify packages stored therein.
  */
 
-var moray  = require('moray');
+var moray = require('moray');
 var assert = require('assert');
 var jsprim = require('jsprim');
 var VError = require('verror');
@@ -34,11 +34,11 @@ function (opts) {
     assert.ok(opts.bucket);
     assert.ok(opts.schema);
 
-    this.opts    = opts;
-    this.log     = opts.log;
-    this.bucket  = opts.bucket;
+    this.opts = opts;
+    this.log = opts.log;
+    this.bucket = opts.bucket;
     this.backend = null;
-    this.schema  = opts.schema;
+    this.schema = opts.schema;
     this.indices = schema2MorayIndex(opts.schema, opts.log);
 };
 
@@ -52,10 +52,10 @@ Backend.prototype.init =
 function (cb) {
     var self = this;
 
-    var log     = self.log;
+    var log = self.log;
     var indices = self.indices;
-    var bucket  = self.bucket;
-    var opts    = self.opts;
+    var bucket = self.bucket;
+    var opts = self.opts;
 
     var backend = createMorayClient(self.opts);
     self.backend = backend;
@@ -111,8 +111,9 @@ function (cb) {
             pre: [ function timestamps(req, callback) {
                 var date = new Date().getTime();
 
-                if (!req.value.created_at)
+                if (!req.value.created_at) {
                     req.value.created_at = date;
+                }
 
                 req.value.updated_at = date;
 
@@ -221,8 +222,9 @@ function (filter, meta, cb) {
     req.on('record', function (obj) {
         results.push(decode(obj.value, self.schema));
 
-        if (count === 0)
+        if (count === 0) {
             count = obj._count;
+        }
     });
 
     req.once('end', function () {
@@ -248,9 +250,9 @@ function (uuid, params, meta, cb) {
     var pkg = encode(params, self.schema);
 
     // Lookup first, we want to create new objects, not to update:
-    var bucket  = self.bucket;
+    var bucket = self.bucket;
     var backend = self.backend;
-    backend.getObject(bucket, uuid, function (err, obj) {
+    backend.getObject(bucket, uuid, function (err, _obj) {
         if (VError.hasCauseWithName(err, 'ObjectNotFoundError')) {
             backend.putObject(bucket, uuid, pkg, meta, cb);
         } else {
@@ -269,12 +271,14 @@ Backend.prototype.getPkg =
 function (uuid, meta, cb) {
     var self = this;
 
-    return self.backend.getObject(self.bucket, uuid, meta, function (err, obj) {
-        if (err)
-            return cb(err);
+    self.backend.getObject(self.bucket, uuid, meta, function (err, obj) {
+        if (err) {
+            cb(err);
+            return;
+        }
 
         var pkg = decode(obj.value, self.schema, self.log);
-        return cb(null, pkg);
+        cb(null, pkg);
     });
 };
 
@@ -286,12 +290,12 @@ function (uuid, meta, cb) {
  */
 
 Backend.prototype.updatePkg =
-function (uuid, params, meta, cb) {
+function (_uuid, params, meta, cb) {
     var self = this;
 
     var pkg = encode(params, self.schema);
 
-    return self.backend.putObject(self.bucket, params.uuid, pkg, meta, cb);
+    self.backend.putObject(self.bucket, params.uuid, pkg, meta, cb);
 };
 
 
@@ -307,7 +311,7 @@ Backend.prototype.deletePkg =
 function (uuid, meta, cb) {
     var self = this;
 
-    return self.backend.delObject(self.bucket, uuid, meta, cb);
+    self.backend.delObject(self.bucket, uuid, meta, cb);
 };
 
 
@@ -320,7 +324,7 @@ function createMorayClient(options) {
     assert.ok(options);
     var morayOptions = jsprim.deepCopy(options.moray);
     morayOptions.log = options.log.child({ component: 'moray' });
-    return moray.createClient(morayOptions);
+    moray.createClient(morayOptions);
 }
 
 
@@ -343,7 +347,6 @@ function schema2MorayIndex(schema, log) {
                 // cannot index hashes in moray (yet)
                 log.fatal({ attr: attr }, 'Cannot index object');
                 process.exit(1);
-
             } else if (type === 'double') {
                 type = 'string';
             } else if (type === 'date') {
@@ -356,8 +359,9 @@ function schema2MorayIndex(schema, log) {
 
             var index = { type: type };
 
-            if (attr.unique)
+            if (attr.unique) {
                 index.unique = true;
+            }
 
             indices[k] = index;
         }
@@ -380,7 +384,7 @@ function schema2MorayIndex(schema, log) {
  * suitable for JSONification.
  */
 
-function decode(pkg, schema, log) {
+function decode(pkg, schema, _log) {
     // Some names cannot be used as PG indexes, so we save them under slightly
     // different names
     for (var i = 0; i !== DB_RESERVED_NAMES.length; i++) {
@@ -399,16 +403,19 @@ function decode(pkg, schema, log) {
         var type = schema[name].type;
         var value = pkg[name];
 
-        if (!value)
+        if (!value) {
             continue;
+        }
 
         // for now we serialize doubles as strings, since moray doesn't
         // support floats yet
-        if (type === 'double')
+        if (type === 'double') {
             pkg[name] = +value;
+        }
 
-        if (type === 'date')
+        if (type === 'date') {
             pkg[name] = new Date(value).toISOString();
+        }
     }
 
     return (pkg);
@@ -430,12 +437,13 @@ function encode(pkg, schema) {
 
         if (typeof (attr) === 'object') {
             if (Array.isArray(attr)) {
-                if (attr.length === 0)
+                if (attr.length === 0) {
                     delete pkg[p];
+                }
             } else {
-                if (Object.keys(attr).length === 0)
+                if (Object.keys(attr).length === 0) {
                     delete pkg[p];
-
+                }
             }
         }
     }
@@ -458,16 +466,19 @@ function encode(pkg, schema) {
         var type = schema[name].type;
         var value = pkg[name];
 
-        if (!value)
+        if (!value) {
             continue;
+        }
 
         // for now we serialize doubles as strings, since moray doesn't
         // support floats yet
-        if (type === 'double')
+        if (type === 'double') {
             pkg[name] = '' + value;
+        }
 
-        if (type === 'date' && typeof (value) === 'string')
+        if (type === 'date' && typeof (value) === 'string') {
             pkg[name] = +new Date(value);
+        }
     }
 
     return (pkg);
diff --git a/lib/migrations/migration-001-remove-stale-attributes.js b/lib/migrations/migration-001-remove-stale-attributes.js
index b6c91ba..e67845e 100644
--- a/lib/migrations/migration-001-remove-stale-attributes.js
+++ b/lib/migrations/migration-001-remove-stale-attributes.js
@@ -6,7 +6,7 @@
  */
 
 /*
- * Copyright (c) 2016, Joyent, Inc.
+ * Copyright 2019 Joyent, Inc.
  */
 
 /*
@@ -24,17 +24,17 @@ var path = require('path');
 var vasync = require('vasync');
 
 
-//---- globals
+// --- globals
 
 
 var CONFIG_PATH = path.resolve(__dirname, '..', '..', 'etc', 'config.json');
 var CONFIG = JSON.parse(fs.readFileSync(CONFIG_PATH));
 var BUCKET = CONFIG.bucket;
 var SCHEMA = CONFIG.schema;
-var CLIENT = null;  // set in `main`
+var CLIENT = null; // set in `main`
 
 
-//---- functions
+// --- functions
 
 
 function getMorayClient(opts, cb) {
@@ -83,8 +83,9 @@ function updatePackage(obj, cb) {
     var etag = obj._etag;
 
     var deleteAttrs = Object.keys(pkg).filter(function (key) {
-        if (key[0] === '_')
+        if (key[0] === '_') {
             key = key.slice(1);
+        }
 
         return !SCHEMA[key];
     });
@@ -127,7 +128,7 @@ function updatePackages(cb) {
 }
 
 
-//---- main
+// ---- main
 
 
 function main() {
diff --git a/lib/papi.js b/lib/papi.js
index a772a0b..e945855 100644
--- a/lib/papi.js
+++ b/lib/papi.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2017, Joyent, Inc.
+ * Copyright 2019 Joyent, Inc.
  */
 
 /*
@@ -14,7 +14,6 @@
  */
 
 var fs = require('fs');
-var util = require('util');
 var http = require('http');
 var https = require('https');
 var restify = require('restify');
@@ -116,10 +115,11 @@ function createServer(options, callback) {
     config.version = [version()];
     config.acceptable = ['application/json'];
 
-    if (!config.port && !config.path)
+    if (!config.port && !config.path) {
         config.path = '/tmp/' + uuid();
+    }
 
-    var server  = restify.createServer(config);
+    var server = restify.createServer(config);
     var backend = new Backend(config);
     server.backend = backend;
 
@@ -134,7 +134,7 @@ function createServer(options, callback) {
     server.use(restify.fullResponse());
     server.use(function setup(req, res, next) {
         req.backend = backend;
-        req.config  = config;
+        req.config = config;
         return next();
     });
 
@@ -191,14 +191,15 @@ function createServer(options, callback) {
                         getMetadata,
                         updateMetadata
                     ],
-                    arg:  {
+                    arg: {
                         log: log,
                         url: config.sapi.url,
                         backend: backend
                     }
                 }, function (err, results) {
-                    if (!err)
+                    if (!err) {
                         log.info({ results: results }, 'first_boot');
+                    }
 
                     return callback(err, server);
                 });
@@ -233,18 +234,25 @@ function validationError(message, errs) {
 
 function loadPkg(req, res, next) {
     var pkgUuid = req.params.uuid;
-    if (!pkgUuid)
-        return next();
+    if (!pkgUuid) {
+        next();
+        return;
+    }
 
     // If Request-Id hasn't been set, we'll set it to pkg UUID:
-    if (!req.headers['request-id'])
-        res.header('request-id',  req.params.uuid);
+    if (!req.headers['request-id']) {
+        res.header('request-id', req.params.uuid);
+    }
 
-    return req.backend.getPkg(pkgUuid, { req_id: req.id }, function (err, pkg) {
-        if (pkg)
+    req.backend.getPkg(pkgUuid, { req_id: req.id }, function (err, pkg) {
+        if (err) {
+            req.log.debug({err: err, pkg_uuid: pkgUuid}, 'Package not found');
+        }
+        if (pkg) {
             req.pkg = pkg;
+        }
 
-        return next();
+        next();
     });
 }
 
@@ -262,14 +270,15 @@ function listPkgs(req, res, next) {
 
     var meta = {
         offset: params.offset || 0,
-        limit:  params.limit || 0
+        limit: params.limit || 0
     };
 
     if (params.order) {
         var order = params.order.toUpperCase();
 
-        if (order !== 'ASC' && order !== 'DESC')
+        if (order !== 'ASC' && order !== 'DESC') {
             order = 'ASC';
+        }
 
         params.order = order;
     }
@@ -277,10 +286,10 @@ function listPkgs(req, res, next) {
     if (params.sort) {
         meta.sort = {
             attribute: params.sort,
-            order:     params.order || 'ASC'
+            order: params.order || 'ASC'
         };
     } else {
-        meta.sort =  {
+        meta.sort = {
             attribute: '_id',
             order: 'ASC'
         };
@@ -322,7 +331,7 @@ function listPkgs(req, res, next) {
             packages[i].v = PKG_VERSION;
         }
 
-        res.header('x-resource-count',  r.total);
+        res.header('x-resource-count', r.total);
         res.send(200, packages);
 
         next();
@@ -340,66 +349,78 @@ function listPkgs(req, res, next) {
 
 function postPkg(req, res, next) {
     if (req.pkg) {
-        return next(new restify.ConflictError(
+        next(new restify.ConflictError(
             'A package with the given UUID already exists'));
+        return;
     }
 
     var params = req.params;
     var schema = req.config.schema;
-    var keys   = Object.keys(schema);
+    var keys = Object.keys(schema);
 
     // Up to the user if want to identify the pkg with cooked uuid
     var pkg = {};
     keys.forEach(function (p) {
-        if (params[p] !== undefined)
+        if (params[p] !== undefined) {
             pkg[p] = params[p];
+        }
     });
 
     // If uuid is not set, it's our turn to set it here:
-    if (!pkg.uuid)
+    if (!pkg.uuid) {
         pkg.uuid = uuid();
+    }
 
     // if invalid params, called function invokes next with errors
-    if (unrecognisedParams(params, schema, next))
-        return null;
+    if (unrecognisedParams(params, schema, next)) {
+        return;
+    }
 
     if (!params.skip_validation) {
         var errs = validations.validate(pkg, schema);
-        if (errs)
-            return next(validationError('Package is invalid', errs));
+        if (errs) {
+            next(validationError('Package is invalid', errs));
+            return;
+        }
     }
 
     var reqId = req.headers['request-id'];
     var meta = { req_id: reqId ? reqId : pkg.uuid };
 
-    return req.backend.createPkg(pkg.uuid, pkg, meta, function (err) {
+    req.backend.createPkg(pkg.uuid, pkg, meta, function (err) {
         if (err) {
             if (err === 'ObjectAlreadyExistsError') {
-                return next(new restify.ConflictError(
-                            'A package with the given UUID already exists'));
+                next(new restify.ConflictError(
+                    'A package with the given UUID already exists'));
+                return;
             } else if (err === 'UniqueAttributeError' ||
                 VError.hasCauseWithName(err, 'UniqueAttributeError')) {
-                return next(new restify.ConflictError(
-                            'A package with the same URN already exists'));
+                next(new restify.ConflictError(
+                    'A package with the same URN already exists'));
+                return;
             }
 
-            return next(new restify.ConflictError(err));
+            next(new restify.ConflictError(err));
+            return;
         }
 
         res.header('Location', req.path() + '/' + pkg.uuid);
 
         // If Request-Id hasn't been set, we'll set it to pkg UUID:
-        if (!reqId)
-            res.header('request-id',  pkg.uuid);
+        if (!reqId) {
+            res.header('request-id', pkg.uuid);
+        }
 
-        return req.backend.getPkg(pkg.uuid, meta, function (er1, p) {
-            if (er1)
-                return next(new restify.InternalError(er1));
+        req.backend.getPkg(pkg.uuid, meta, function (er1, p) {
+            if (er1) {
+                next(new restify.InternalError(er1));
+                return;
+            }
 
             p.v = PKG_VERSION;
 
             res.send(201, p);
-            return next();
+            next();
         });
     });
 }
@@ -414,8 +435,9 @@ function postPkg(req, res, next) {
 
 function getPkg(req, res, next) {
     if (!req.pkg) {
-        return next(new restify.ResourceNotFoundError('Package ' +
-                    req.params.uuid + ' does not exist'));
+        next(new restify.ResourceNotFoundError('Package ' +
+                req.params.uuid + ' does not exist'));
+        return;
     }
 
     function send() {
@@ -428,28 +450,36 @@ function getPkg(req, res, next) {
     var reqOwners = req.params.owner_uuids;
     var pkgOwners = req.pkg.owner_uuids;
 
-    if (!(reqOwners && pkgOwners))
-        return send();
+    if (!(reqOwners && pkgOwners)) {
+        send();
+        return;
+    }
 
     try {
         reqOwners = JSON.parse(reqOwners);
-    } catch (e) {}  // keep original value
+    } catch (e) {
+        req.log.debug({err: e}, 'JSON Parse error');
+    } // keep original value
 
     // check whether this package has an owner UUID in common with the request
     if (Array.isArray(reqOwners)) {
         for (var i = 0; i !== reqOwners.length; i++) {
             var owner = reqOwners[i];
 
-            if (pkgOwners.indexOf(owner) !== -1)
-                return send();
+            if (pkgOwners.indexOf(owner) !== -1) {
+                send();
+                return;
+            }
         }
     } else {
-        if (pkgOwners.indexOf(reqOwners) !== -1)
-            return send();
+        if (pkgOwners.indexOf(reqOwners) !== -1) {
+            send();
+            return;
+        }
     }
 
-    return next(new restify.ResourceNotFoundError('Package ' + req.params.uuid +
-                ' does not exist'));
+    next(new restify.ResourceNotFoundError('Package ' + req.params.uuid +
+        ' does not exist'));
 }
 
 
@@ -468,20 +498,23 @@ function updatePkg(req, res, next) {
     var errs;
 
     if (!pkg) {
-        return next(new restify.ResourceNotFoundError('Package ' + params.uuid +
-                                                      ' does not exist'));
+        next(new restify.ResourceNotFoundError(
+            'Package ' + params.uuid + ' does not exist'));
+        return;
     }
 
     // If Request-Id hasn't been set, we'll set it to pkg UUID:
-    if (!req.headers['request-id'])
+    if (!req.headers['request-id']) {
         res.header('request-id', params.uuid);
+    }
 
     var schema = req.config.schema;
     var entries = Object.keys(schema);
 
     // if invalid params, called function invokes next with errors
-    if (unrecognisedParams(params, schema, next))
-        return null;
+    if (unrecognisedParams(params, schema, next)) {
+        return;
+    }
 
     // prevent immutable attributes from being modified
     if (!params.force) {
@@ -491,20 +524,24 @@ function updatePkg(req, res, next) {
         }).sort();
 
         immutable.forEach(function (k) {
-            if (params[k] !== undefined && params[k] !== pkg[k])
+            if (params[k] !== undefined && params[k] !== pkg[k]) {
                 validations.describeErr(k, 'Invalid', 'is immutable', errs);
+            }
         });
 
-        if (errs.length > 0)
-            return next(validationError('Attempt to update immutables', errs));
+        if (errs.length > 0) {
+            next(validationError('Attempt to update immutables', errs));
+            return;
+        }
     }
 
     // copy over new entries in params which are recognised by the schema to pkg
     entries.forEach(function (p) {
         var value = params[p];
 
-        if (value === undefined || p === 'uuid')
+        if (value === undefined || p === 'uuid') {
             return;
+        }
 
         if (value !== null) {
             pkg[p] = params[p];
@@ -521,8 +558,10 @@ function updatePkg(req, res, next) {
 
     if (!params.skip_validation) {
         errs = validations.validate(pkg, schema);
-        if (errs)
-            return next(validationError('Updated package is invalid', errs));
+        if (errs) {
+            next(validationError('Updated package is invalid', errs));
+            return;
+        }
     }
 
     var backend = req.backend;
@@ -530,18 +569,22 @@ function updatePkg(req, res, next) {
     var meta = { req_id: req.id };
 
 
-    return backend.updatePkg(pkgUuid, pkg, meta, function (err) {
-        if (err)
-            return next(new restify.ConflictError(err));
+    backend.updatePkg(pkgUuid, pkg, meta, function (err) {
+        if (err) {
+            next(new restify.ConflictError(err));
+            return;
+        }
 
-        return backend.getPkg(pkgUuid, meta, function (err2, savedPkg) {
-            if (err2)
-                return next(new restify.InternalError(err2));
+        backend.getPkg(pkgUuid, meta, function (err2, savedPkg) {
+            if (err2) {
+                next(new restify.InternalError(err2));
+                return;
+            }
 
             savedPkg.v = PKG_VERSION;
 
             res.send(200, savedPkg);
-            return next();
+            next();
         });
     });
 }
@@ -560,22 +603,28 @@ function deletePkg(req, res, next) {
 
     if (!req.pkg) {
         var errMsg = 'Package ' + pkgUuid + ' does not exist';
-        return next(new restify.ResourceNotFoundError(errMsg));
+        next(new restify.ResourceNotFoundError(errMsg));
+        return;
     }
 
     // If Request-Id hasn't been set, we'll set it to pkg UUID:
-    if (!req.headers['request-id'])
+    if (!req.headers['request-id']) {
         res.header('request-id', pkgUuid);
+    }
 
-    if (!req.params.force)
-        return next(new restify.BadMethodError('Packages cannot be deleted'));
+    if (!req.params.force) {
+        next(new restify.BadMethodError('Packages cannot be deleted'));
+        return;
+    }
 
-    return req.backend.deletePkg(pkgUuid, { req_id: req.id }, function (err) {
-        if (err)
-            return next(new restify.InternalError(err));
+    req.backend.deletePkg(pkgUuid, { req_id: req.id }, function (err) {
+        if (err) {
+            next(new restify.InternalError(err));
+            return;
+        }
 
         res.send(204);
-        return next();
+        next();
     });
 }
 
@@ -586,7 +635,7 @@ function deletePkg(req, res, next) {
  */
 
 function ping(req, res, next) {
-    return req.backend.ping(function (err) {
+    req.backend.ping(function (err) {
         var data = { pid: process.pid };
 
         if (err) {
@@ -597,7 +646,7 @@ function ping(req, res, next) {
         }
 
         res.send(data);
-        return next();
+        next();
     });
 }
 
@@ -610,8 +659,10 @@ function ping(req, res, next) {
 
 function createSDCPackages(args, next) {
     tools.defaultPackages(function (err, pkgs) {
-        if (err)
-            return next(err);
+        if (err) {
+            next(err);
+            return;
+        }
 
         var backend = args.backend;
 
@@ -619,14 +670,17 @@ function createSDCPackages(args, next) {
             backend.createPkg(pkg.uuid, pkg, {
                 req_id: pkg.uuid
             }, function (err2) {
-                if (!err2 || err2 === 'ObjectAlreadyExistsError')
-                    return cb();
+                if (!err2 || err2 === 'ObjectAlreadyExistsError') {
+                    cb();
+                    return;
+                }
 
-                return cb(err2);
+                cb(err2);
+                return;
             });
         }
 
-        return vasync.forEachParallel({
+        vasync.forEachParallel({
             func: function createSDCPackage(pkg, cb) {
                 var call = backoff.call(addPkg, pkg, cb);
                 call.failAfter(MAX_CREATE_PKG_TRIES);
@@ -635,7 +689,7 @@ function createSDCPackages(args, next) {
             inputs: pkgs
         }, function (er, res) {
             args.log.debug({ sdc_packages: res }, 'SDC Packages');
-            return next(er, JSON.stringify(res));
+            next(er, JSON.stringify(res));
         });
     });
 }
@@ -650,16 +704,20 @@ function getMetadata(args, next) {
     SAPI = new sapi({ url: args.url, log: args.log });
 
     SAPI.listServices({ name: 'papi' }, function (err, services) {
-        if (err)
-            return next(err);
+        if (err) {
+            next(err);
+            return;
+        }
 
-        if (!services.length)
-            return next('papi service not found');
+        if (!services.length) {
+            next('papi service not found');
+            return;
+        }
 
         SERVICE_UUID = services[0].uuid;
         METADATA = services[0].metadata;
 
-        return next(null, JSON.stringify(METADATA));
+        next(null, JSON.stringify(METADATA));
     });
 }
 
@@ -672,19 +730,21 @@ function getMetadata(args, next) {
  */
 
 function updateMetadata(args, next) {
-    if (typeof (SAPI) === 'undefined' || typeof (METADATA) === 'undefined')
-        return next('Skipping updateMetadata because getMetadata failed');
+    if (typeof (SAPI) === 'undefined' || typeof (METADATA) === 'undefined') {
+        next('Skipping updateMetadata because getMetadata failed');
+        return;
+    }
 
     METADATA.SERVICE_IS_FIRST_BOOT = false;
 
-    return SAPI.updateService(SERVICE_UUID, {
+    SAPI.updateService(SERVICE_UUID, {
         action: 'update',
         metadata: METADATA
     }, function (err, service) {
         args.log.debug({ service: service }, 'updateMetadata');
         // We are done with SAPI, no need to keep the connection around
         SAPI.client.close();
-        return next(err, JSON.stringify(service));
+        next(err, JSON.stringify(service));
     });
 }
 
@@ -696,12 +756,14 @@ function updateMetadata(args, next) {
 
 function displayHttpQueues(log) {
     var requests = http.globalAgent.requests;
-    if (requests && requests.length > 0)
+    if (requests && requests.length > 0) {
         log.warn('http.globalAgent queueing, depth=%d', requests.length);
+    }
 
     requests = https.globalAgent.requests;
-    if (requests && requests.length > 0)
+    if (requests && requests.length > 0) {
         log.warn('https.globalAgent queueing, depth=%d', requests.length);
+    }
 }
 
 
@@ -717,12 +779,14 @@ function unrecognisedParams(params, schema, next) {
 
     // warn if there are unrecognised params
     Object.keys(params).forEach(function (p) {
-        if (p === 'force' || p === 'skip_validation' || p === 'v')
+        if (p === 'force' || p === 'skip_validation' || p === 'v') {
             return;
+        }
 
-        if (!schema[p])
-            validations.describeErr(p, 'Invalid', 'is an unsupported attribute',
-                                    errs);
+        if (!schema[p]) {
+            validations.describeErr(
+                p, 'Invalid', 'is an unsupported attribute', errs);
+        }
     });
 
     if (errs.length > 0) {
@@ -769,21 +833,26 @@ function searchFilter(params, schema) {
 
     Object.keys(params).forEach(function (name) {
         var column = schema[name];
-        if (column === undefined)
+        if (column === undefined) {
             return;
+        }
 
         searchedOnIndex = true;
 
-        if (column.type === 'object')
+        if (column.type === 'object') {
             return;
+        }
 
         var value = params[name];
-        if (value === undefined)
+        if (value === undefined) {
             return;
+        }
 
         try {
             value = JSON.parse(value);
-        } catch (e) {}  // leave value as is
+        } catch (_e) {
+            // leave value as is
+        }
 
         // TODO: update to use DB_RESERVED_NAMES in backend.js
         if (name === 'group') {
@@ -801,8 +870,9 @@ function searchFilter(params, schema) {
                 chunks.push('(' + name + '=' + esc(value[i]) + ')');
             }
 
-            if (name === 'owner_uuids')
+            if (name === 'owner_uuids') {
                 chunks.push('(!(owner_uuids=*))');
+            }
 
             if (chunks.length > 1) {
                 constraint = '(|' + chunks.join('') + ')';
@@ -818,12 +888,14 @@ function searchFilter(params, schema) {
             }
         }
 
-        if (constraint !== undefined)
+        if (constraint !== undefined) {
             constraints.push(constraint);
+        }
     });
 
-    if (!constraints.length && !searchedOnIndex)
+    if (!constraints.length && !searchedOnIndex) {
         constraints.push('(uuid=*)');
+    }
 
     var filter;
     if (constraints.length > 1) {
@@ -843,22 +915,24 @@ function searchFilter(params, schema) {
  */
 
 function esc(val, type) {
-    if (type === 'date')
+    if (type === 'date') {
         return +new Date(val);
+    }
 
-    if (typeof (val) !== 'string')
+    if (typeof (val) !== 'string') {
         return val;
+    }
 
     // first replace converts \ to {\5c}, except when that \ is a part of
     // an existing LDIF escape sequence (e.g. the string already contains an
     // escaped * as {\2a})
-    return val.replace(/\\(?![0-9a-f][0-9a-f]})/gi, '{\\5c}').
-               replace(/\//g, '{\\2f}').
-               replace(/\(/g, '{\\28}').
-               replace(/\)/g, '{\\29}').
+    return val.replace(/\\(?![0-9a-f][0-9a-f]})/gi, '{\\5c}')
+               .replace(/\//g, '{\\2f}')
+               .replace(/\(/g, '{\\28}')
+               .replace(/\)/g, '{\\29}')
                /* BEGIN JSSTYLED */
-               replace(/\=/g, '{\\3d}').
-               replace(/,/g,  '{\\2c}');
+               .replace(/=/g, '{\\3d}')
+               .replace(/,/g, '{\\2c}');
                /* END JSSTYLED */
 }
 
diff --git a/lib/tools.js b/lib/tools.js
index 9a0e933..57fba83 100644
--- a/lib/tools.js
+++ b/lib/tools.js
@@ -5,14 +5,13 @@
  */
 
 /*
- * Copyright (c) 2014, Joyent, Inc.
+ * Copyright 2019 Joyent, Inc.
  */
 
 /*
  * Random grab-bag of functions.
  */
 
-var util = require('util');
 var fs = require('fs');
 var path = require('path');
 var http = require('http');
@@ -28,22 +27,25 @@ var assert = require('assert');
 function defaultPackages(cb) {
     var filepath = path.resolve(__dirname, '../etc/packages.json');
     fs.readFile(filepath, 'utf8', function (err, data) {
-        if (err)
-            return cb(err);
+        if (err) {
+            cb(err);
+            return;
+        }
 
         try {
             var packages = JSON.parse(data);
 
             packages.forEach(function (pkg) {
-                if (pkg.owner_uuid)
+                if (pkg.owner_uuid) {
                     pkg.owner_uuids = [pkg.owner_uuid];
+                }
 
                 delete pkg.owner_uuid;
             });
 
-            return cb(null, packages);
+            cb(null, packages);
         } catch (e) {
-            return cb(e);
+            cb(e);
         }
     });
 }
@@ -66,8 +68,9 @@ function configure(file, options, log) {
         process.exit(1);
     }
 
-    if (options.port)
+    if (options.port) {
         config.port = options.port;
+    }
 
     if (typeof (config.maxHttpSockets) === 'number') {
         log.info('Tuning max sockets to %d', config.maxHttpSockets);
diff --git a/lib/validations.js b/lib/validations.js
index 1988378..34d5e11 100644
--- a/lib/validations.js
+++ b/lib/validations.js
@@ -5,15 +5,15 @@
  */
 
 /*
- * Copyright (c) 2018, Joyent, Inc.
+ * Copyright 2019 Joyent, Inc.
  */
 
 /*
  * Validations run on each package.
  */
 
-var BAD_NAME_RE = /[\_\-\.][\_\-\.]/;
-var NAME_RE = /^[a-zA-Z0-9]([a-zA-Z0-9\_\-\.]+)?[a-zA-Z0-9]$/;
+var BAD_NAME_RE = /[_\-.][_\-.]/;
+var NAME_RE = /^[a-zA-Z0-9]([a-zA-Z0-9_\-.]+)?[a-zA-Z0-9]$/;
 var UUID_RE = /^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$/;
 var VALID_BRANDS = ['bhyve', 'joyent', 'joyent-minimal', 'kvm', 'lx'];
 var VALID_SPREADS = ['min-ram', 'random', 'min-owner'];
@@ -27,12 +27,14 @@ function validUUID(uuid) {
 
 
 function validNumber(attr, min, max) {
-    if (!min)
+    if (!min) {
         min = 0;
+    }
 
     // hack that works because required attrs have already been checked present
-    if (attr === undefined)
+    if (attr === undefined) {
         return true;
+    }
 
     var number = Number(attr);
 
@@ -89,68 +91,63 @@ function validate(pkg, schema) {
 
     // check types match up with what's in the schema
     Object.keys(schema).sort().forEach(function (name) {
-        var val  = pkg[name];
+        var val = pkg[name];
         var info = schema[name];
         var actualType = typeof (pkg[name]);
 
         if (info.required) {
-            if (actualType === 'undefined')
+            if (actualType === 'undefined') {
                 return missing(name, 'is missing');
+            }
 
-            if (actualType === 'string' && val.length === 0)
+            if (actualType === 'string' && val.length === 0) {
                 return missing(name, 'is empty');
+            }
         }
 
-        if (actualType === 'undefined')
+        if (actualType === 'undefined') {
             return null;
+        }
 
         var expectedType = info.type;
 
         if (expectedType === 'string' && actualType !== 'string') {
             invalid(name, 'must be string');
-
         } else if (expectedType === 'boolean' && actualType !== 'boolean') {
             invalid(name, 'must be boolean');
-
         } else if (expectedType === 'uuid' && !validUUID(val)) {
             invalid(name, 'must be UUID');
-
         } else if (expectedType === 'number' && actualType !== 'number') {
             invalid(name, 'must be integer');
-
         } else if (expectedType === 'double' && actualType !== 'number') {
             invalid(name, 'must be float');
-
         } else if (expectedType === '[string]') {
             if (!Array.isArray(val)) {
                 invalid(name, 'must be an array');
-
             } else {
                 var nonStrings = val.filter(function (i) {
                     return typeof (i) !== 'string';
                 });
 
-                if (nonStrings.length > 0)
+                if (nonStrings.length > 0) {
                     invalid(name, 'must only contain strings');
+                }
             }
-
         } else if (expectedType === '[uuid]') {
             if (!Array.isArray(val)) {
                 invalid(name, 'must be an array');
-
             } else {
                 var nonUUIDs = val.filter(function (i) {
                     return !validUUID(i);
                 });
 
-                if (nonUUIDs.length > 0)
+                if (nonUUIDs.length > 0) {
                     invalid(name, 'must only contain UUIDs');
+                }
             }
-
         } else if (expectedType === '[object]') {
             if (!Array.isArray(val)) {
                 invalid(name, 'must be an array');
-
             } else if (name === 'disks') {
                 var nonObjects = val.filter(function filterNonObject(i) {
                     return (Object.keys(i).some(function someInvalidKey(k) {
@@ -161,24 +158,25 @@ function validate(pkg, schema) {
                         }));
                 });
 
-                if (nonObjects.length > 0)
+                if (nonObjects.length > 0) {
                     invalid(name, 'must only contain Objects with ' +
                         '"size" property');
+                }
             }
-
         } else if (expectedType === 'object' &&
                    (actualType !== 'object' || Array.isArray(val))) {
             invalid(name, 'must be a hash');
         }
 
-        return null;  // keep jslint happy
+        return null; // keep jslint happy
     });
 
     // check there aren't any unrecognised entries (something not in the schema)
     // in the package
     Object.keys(pkg).sort().forEach(function (name) {
-        if (!schema[name])
+        if (!schema[name]) {
             invalid(name, 'is not a supported attribute');
+        }
     });
 
     // hardcoded checks
@@ -204,23 +202,29 @@ function validate(pkg, schema) {
             + ' contain repeated \'-\', \'_\' or \'.\' characters');
     }
 
-    if (!validNumber(pkg.max_swap, MIN_SWAP))
+    if (!validNumber(pkg.max_swap, MIN_SWAP)) {
         invalid('max_swap', 'must be greater or equal to ' + MIN_SWAP);
+    }
 
-    if (parseInt(pkg.max_swap, 10) < parseInt(pkg.max_physical_memory, 10))
+    if (parseInt(pkg.max_swap, 10) < parseInt(pkg.max_physical_memory, 10)) {
         invalid('max_swap', 'cannot be less than max_physical_memory');
+    }
 
-    if (!validNumber(pkg.quota, MIN_DISK))
+    if (!validNumber(pkg.quota, MIN_DISK)) {
         invalid('quota', 'must be greater or equal to ' + MIN_DISK);
+    }
 
-    if (pkg.quota && pkg.quota % 1024 !== 0)
+    if (pkg.quota && pkg.quota % 1024 !== 0) {
         invalid('quota', 'must be a multiple of 1024');
+    }
 
-    if (pkg.cpu_cap && !validNumber(pkg.cpu_cap, MIN_CPUCAP))
+    if (pkg.cpu_cap && !validNumber(pkg.cpu_cap, MIN_CPUCAP)) {
         invalid('cpu_cap', 'must be greater or equal to ' + MIN_CPUCAP);
+    }
 
-    if (!validNumber(pkg.max_lwps, MIN_LWPS))
+    if (!validNumber(pkg.max_lwps, MIN_LWPS)) {
         invalid('max_lwps', 'must be greater or equal to ' + MIN_LWPS);
+    }
 
     if (!validNumber(pkg.zfs_io_priority, 0, MAX_ZFSIO)) {
         invalid('zfs_io_priority', 'must be greater or equal to 0, and ' +
@@ -237,8 +241,9 @@ function validate(pkg, schema) {
             'disks can be specified only for flexible_disk packages');
     }
 
-    if (errors.length)
+    if (errors.length) {
         return errors;
+    }
 
     return null;
 }
diff --git a/package.json b/package.json
index 2d80cd4..276896b 100644
--- a/package.json
+++ b/package.json
@@ -1,7 +1,7 @@
 {
   "name": "sdc-papi",
   "description": "Packages API",
-  "version": "7.2.1",
+  "version": "7.2.2",
   "author": "Joyent (joyent.com)",
   "private": true,
   "repository": {
@@ -21,7 +21,9 @@
     "jsprim": "^1.3.1"
   },
   "devDependencies": {
-    "@smaller/tap": "11.1.4-1.0.0"
+    "@smaller/tap": "11.1.4-1.0.0",
+    "eslint": "4.13.1",
+    "eslint-plugin-joyent": "~2.0.0"
   },
   "scripts": {
     "start": "node ./server.js",
diff --git a/server.js b/server.js
index 4b9639b..24a02f6 100644
--- a/server.js
+++ b/server.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2014, Joyent, Inc.
+ * Copyright 2019 Joyent, Inc.
  */
 
 /*
@@ -86,7 +86,7 @@ function run() {
     });
 }
 
-///--- Mainline
+// --- Mainline
 
 PARSED = nopt(opts, shortOpts, process.argv, 2);
 if (PARSED.help) {
-- 
2.21.0

