commit 90a0b27c825ac612287c25b627d003e58c26f1e2 (refs/changes/75/1475/2)
Author: Alex Wilson <alex.wilson@joyent.com>
Date:   2017-02-08T18:48:01-08:00 (2 years, 8 months ago)
    
    joyent/node-cueball#92 ConnectionSet emits 'removed' for connection it never 'added'

diff --git a/lib/set.js b/lib/set.js
index bbb2d0c..2a8014e 100644
--- a/lib/set.js
+++ b/lib/set.js
@@ -70,8 +70,6 @@ function CueBallConnectionSet(options) {
 	this.cs_fsm = {};
 	/* Map of backend key => bool, if true the backend is declared dead. */
 	this.cs_dead = {};
-	/* Map of backend key => claim handle. */
-	this.cs_handles = {};
 
 	/*
 	 * Map of backend key => integer, latest serial number for connections
@@ -86,9 +84,9 @@ function CueBallConnectionSet(options) {
 	this.cs_connections = {};
 	/* Map of backend key => Array of connection keys. */
 	this.cs_connectionKeys = {};
+	/* Map of ckey => LogicalConnection. */
+	this.cs_lconns = {};
 
-	/* Map of connection key => bool, if true 'removed' has been emitted. */
-	this.cs_emitted = {};
 
 	/* For debugging, track when we last rebalanced. */
 	this.cs_lastRebalance = undefined;
@@ -153,12 +151,9 @@ CueBallConnectionSet.prototype.on_resolver_removed = function (k) {
 
 	var cks = this.cs_connectionKeys[k];
 	(cks || []).forEach(function (ck) {
-		var conn = self.cs_connections[ck];
-		var hdl = self.cs_handles[ck];
-		if (self.cs_emitted[ck] !== true) {
-			self.cs_emitted[ck] = true;
-			self.assertEmit('removed', ck, conn, hdl);
-		}
+		var lconn = self.cs_lconns[ck];
+		if (!lconn.isInState('stopped'))
+			lconn.drain();
 	});
 };
 
@@ -294,12 +289,16 @@ CueBallConnectionSet.prototype.state_stopping = function (S) {
 		});
 		fsm.setUnwanted();
 		cks.forEach(function (ck) {
-			var conn = self.cs_connections[ck];
-			var hdl = self.cs_handles[ck];
-			if (self.cs_emitted[ck] !== true) {
-				self.cs_emitted[ck] = true;
-				self.assertEmit('removed', ck, conn, hdl);
-			}
+			/*
+			 * Do this async, to avoid problems of state machine
+			 * loops if .stop() was called from an 'added' handler.
+			 */
+			var lconn = self.cs_lconns[ck];
+			setImmediate(function () {
+				if (!lconn.isInState('stopped')) {
+					lconn.drain();
+				}
+			});
 		});
 	}
 };
@@ -373,11 +372,15 @@ CueBallConnectionSet.prototype._rebalance = function () {
 
 	var conns = {};
 	var total = 0;
+	var busy = 0;
 	this.cs_keys.forEach(function (k) {
 		conns[k] = [];
-		if (self.cs_fsm[k] !== undefined)
+		if (self.cs_fsm[k] !== undefined) {
 			conns[k].push(self.cs_fsm[k]);
-		total += conns[k].length;
+			if (self.cs_fsm[k].isInState('busy'))
+				++busy;
+			++total;
+		}
 	});
 
 	var plan = mod_utils.planRebalance(
@@ -391,11 +394,11 @@ CueBallConnectionSet.prototype._rebalance = function () {
 	}
 	plan.remove.forEach(function (fsm) {
 		/*
-		 * Never deliberately remove our last connection. We should wait
-		 * for another connection to be up and running first and then
-		 * remove this one.
+		 * Never deliberately remove our last working connection. We
+		 * should wait for another connection to be up and running first
+		 * and then remove this one.
 		 */
-		if (total <= 1)
+		if (busy <= 1)
 			return;
 
 		var k = fsm.csf_backend.key;
@@ -404,22 +407,16 @@ CueBallConnectionSet.prototype._rebalance = function () {
 		 * setting the closeAfterRelease flag to avoid them retrying),
 		 * emit 'removed' so our consumer will close them.
 		 */
-		var cks = Object.keys(self.cs_connections).filter(
-		    function (ck) {
-			return (ck.indexOf(k + '.') === 0);
-		});
+		var cks = self.cs_connectionKeys[k];
 		fsm.setUnwanted();
 		if (fsm.isInState('stopped') || fsm.isInState('failed')) {
 			delete (self.cs_fsm[k]);
 			--total;
 		}
 		cks.forEach(function (ck) {
-			var conn = self.cs_connections[ck];
-			var hdl = self.cs_handles[ck];
-			if (self.cs_emitted[ck] !== true) {
-				self.cs_emitted[ck] = true;
-				self.assertEmit('removed', ck, conn, hdl);
-			}
+			var lconn = self.cs_lconns[ck];
+			if (!lconn.isInState('stopped'))
+				lconn.drain();
 		});
 	});
 	plan.add.forEach(function (k) {
@@ -447,28 +444,61 @@ CueBallConnectionSet.prototype.assertEmit = function () {
 	return (this.emit.apply(this, args));
 };
 
-function forceClaim(handle, fsm) {
-	handle.on('stateChanged', hdlStateListener);
+CueBallConnectionSet.prototype.createLogiConn = function (key) {
+	var fsm = this.cs_fsm[key];
+	if (this.cs_serials[key] === undefined)
+		this.cs_serials[key] = 1;
+	if (this.cs_connectionKeys[key] === undefined)
+		this.cs_connectionKeys[key] = [];
 
-	function hdlStateListener(st) {
-		if (st === 'waiting' && handle.isInState('waiting')) {
-			if (fsm.isInState('idle')) {
-				handle.try(fsm);
-			} else {
-				fsm.on('stateChanged', fsmStateListener);
-			}
-		}
-	}
+	var serial = this.cs_serials[key]++;
+	var ckey = key + '.' + serial;
+	this.cs_connectionKeys[key].push(ckey);
 
-	function fsmStateListener(st) {
-		if (st === 'idle' && fsm.isInState('idle')) {
-			fsm.removeListener('stateChanged', fsmStateListener);
-			if (handle.isInState('waiting')) {
-				handle.try(fsm);
-			}
+	var lconn = new LogicalConnection({
+		set: this,
+		log: this.cs_log,
+		key: key,
+		ckey: ckey,
+		fsm: fsm
+	});
+	this.cs_lconns[ckey] = lconn;
+
+	var self = this;
+	lconn.on('stateChanged', function (st) {
+		if (st === 'stopped') {
+			/*
+			 * Once the Logical Connection has stopped, clean up all
+			 * the entries we had about it.
+			 */
+			delete (self.cs_lconns[ckey]);
+			var cks = self.cs_connectionKeys[key];
+			var idx = cks.indexOf(ckey);
+			mod_assert.notStrictEqual(idx, -1);
+			cks.splice(idx, 1);
+
+			/*
+			 * Now, if this FSM is planning to contribute another
+			 * connection back to the Set, we want to make a new
+			 * Logical Connection for the next serial number.
+			 */
+
+			/*
+			 * If the backend is gone from the resolver, we
+			 * definitely aren't going to get a new connection
+			 * out of this backend.
+			 */
+			if (self.cs_backends[key] === undefined)
+				return;
+
+			/* If the FSM has failed or stopped, likewise. */
+			if (fsm.isInState('failed') || fsm.isInState('stopped'))
+				return;
+
+			self.createLogiConn(key);
 		}
-	}
-}
+	});
+};
 
 CueBallConnectionSet.prototype.addConnection = function (key) {
 	if (this.isInState('stopping') || this.isInState('stopped'))
@@ -485,60 +515,25 @@ CueBallConnectionSet.prototype.addConnection = function (key) {
 		recovery: this.cs_recovery,
 		monitor: (this.cs_dead[key] === true)
 	});
-	if (this.cs_serials[key] === undefined)
-		this.cs_serials[key] = 1;
-	if (this.cs_connectionKeys[key] === undefined)
-		this.cs_connectionKeys[key] = [];
 	mod_assert.strictEqual(this.cs_fsm[key], undefined);
 	this.cs_fsm[key] = fsm;
-	var serial;
-	var ckey;
-	var smgr = fsm.getSocketMgr();
-
-	var self = this;
-	fsm.on('stateChanged', function (newState) {
-		if (newState === 'busy' && fsm.isInState('busy')) {
-			mod_assert.notStrictEqual(ckey, undefined);
-			mod_assert.notStrictEqual(self.cs_connections[ckey],
-			    undefined);
-			return;
-		}
-
-		/*
-		 * If we already have a ckey set for this FSM, and it exists in
-		 * cs_connections, then we previously got a connection and
-		 * claimed it. Any state transition (other than to "busy",
-		 * which was excluded above) now means this connection's
-		 * claim handle has been released/closed and we must clean up
-		 * the associated entries.
-		 */
-		if (ckey !== undefined &&
-		    self.cs_connections[ckey] !== undefined) {
-			mod_assert.ok(self.cs_emitted[ckey]);
-
-			delete (self.cs_connections[ckey]);
-			delete (self.cs_emitted[ckey]);
-			delete (self.cs_handles[ckey]);
 
-			var cks = self.cs_connectionKeys[key];
-			var ckIdx = cks.indexOf(ckey);
-			mod_assert.notStrictEqual(ckIdx, -1);
-			cks.splice(ckIdx, 1);
+	this.createLogiConn(key);
 
-			ckey = undefined;
-		}
+	var self = this;
 
-		if (newState === 'idle' && fsm.isInState('idle')) {
-			/*
-			 * If the backend has been removed from the resolver,
-			 * stop now.
-			 */
-			if (self.cs_backends[key] === undefined) {
-				fsm.setUnwanted();
-				return;
-			}
+	/*
+	 * We want to rebalance when an FSM either reaches idle or leaves it.
+	 * These are the points at which we can meaningfully change what we're
+	 * planning to do (rebalancing at other times is fine, but wasted
+	 * effort).
+	 */
+	var wasIdle = false;
 
-			if (serial === undefined) {
+	fsm.on('stateChanged', function (newState) {
+		if (newState === 'idle') {
+			if (self.cs_serials[key] === undefined ||
+			    self.cs_serials[key] === 2) {
 				self.emit('connectedToBackend', key, fsm);
 			}
 
@@ -547,40 +542,16 @@ CueBallConnectionSet.prototype.addConnection = function (key) {
 				delete (self.cs_dead[key]);
 			}
 
-			serial = self.cs_serials[key]++;
-			ckey = key + '.' + serial;
-			fsm.cs_serial = serial;
-
-			var hdlOpts = {
-				pool: self,
-				claimStack: 'Error\n' +
-				    ' at claim\n' +
-				    ' at CueBallConnectionSet.addConnection\n' +
-				    ' at CueBallConnectionSet.addConnection',
-				callback: afterClaim,
-				log: self.cs_log,
-				claimTimeout: Infinity
-			};
-			var handle = new CueBallClaimHandle(hdlOpts);
-
-			self.cs_handles[ckey] = handle;
-			forceClaim(handle, fsm);
-
-			function afterClaim(err, hdl, conn) {
-				mod_assert.ok(!err);
-
-				conn.cs_serial = serial;
-				conn.cs_backendKey = key;
-				self.cs_connections[ckey] = conn;
-				self.cs_connectionKeys[key].push(ckey);
-
-				self.assertEmit('added', ckey, conn, hdl);
-
-				self.rebalance();
-			}
+			self.rebalance();
+			wasIdle = true;
 			return;
 		}
 
+		if (wasIdle) {
+			wasIdle = false;
+			self.rebalance();
+		}
+
 		if (newState === 'failed') {
 			/*
 			 * Set the dead flag, but not on a backend that's no
@@ -594,26 +565,6 @@ CueBallConnectionSet.prototype.addConnection = function (key) {
 		if (newState === 'stopped' || newState === 'failed') {
 			delete (self.cs_fsm[key]);
 			self.emit('closedBackend', fsm);
-			self.rebalance();
-			return;
-		}
-	});
-
-	smgr.on('stateChanged', function (newState) {
-		if (!fsm.isInState('busy'))
-			return;
-		if (newState === 'connected')
-			return;
-		/*
-		 * A transition out of 'connected' while the slot is still
-		 * 'busy' indicates that we lost the connection. We should
-		 * emit 'removed' for our clients.
-		 */
-		mod_assert.string(ckey);
-		if (self.cs_emitted[ckey] !== true) {
-			self.cs_emitted[ckey] = true;
-			self.assertEmit('removed', ckey,
-			    self.cs_connections[ckey], self.cs_handles[ckey]);
 		}
 	});
 
@@ -637,3 +588,188 @@ CueBallConnectionSet.prototype._incrCounter = function (counter) {
 		this.cs_counters[counter] = 0;
 	++this.cs_counters[counter];
 };
+
+/*
+ * The LogicalConnection FSM is used to track the state of a "connection" in
+ * a Set. It represents one "connection key", as it progresses from being
+ * set up, to being advertised to the end-user ('added' emitted), to being
+ * drained ('removed') and torn down.
+ *
+ * This FSM replaces a bunch of flags that used to exist to note down whether
+ * 'added' and 'removed' had been emitted yet for each ckey. The FSM emits
+ * events on the Set on its behalf now, as well as managing the ClaimHandles
+ * and callbacks.
+ *
+ *        +
+ *        |
+ *        |
+ *        |
+ *        v
+ *    +--------+
+ *    |        | .drain()
+ *    |  init  +-----------------------------+
+ *    |        |                             |
+ *    +---+----+                             |
+ *        | handle                           |
+ *        | claimed                          |
+ *        |                                  |
+ *        |                                  |
+ *        v                                  |
+ * +--------------+                          |
+ * |              | hdl closed               |
+ * |  advertised  +------------------------->|
+ * |              |                          |
+ * +------+-------+                          |
+ *        | .drain() ||                      |
+ *        | smgr !connected                  |
+ *        |                                  |
+ *        |                                  |
+ *        |                                  |
+ *        v                                  v
+ *  +------------+                     +-----------+
+ *  |            |                     |           |
+ *  |  draining  +-------------------> |  stopped  |
+ *  |            | hdl rel./closed     |           |
+ *  +------------+                     +-----------+
+ *
+ */
+function LogicalConnection(options) {
+	mod_assert.object(options, 'options');
+	mod_assert.object(options.set, 'options.set');
+	mod_assert.string(options.key, 'options.key');
+	mod_assert.string(options.ckey, 'options.ckey');
+	mod_assert.object(options.fsm, 'options.fsm');
+	mod_assert.object(options.log, 'options.log');
+
+	this.lc_set = options.set;
+	this.lc_key = options.key;
+	this.lc_fsm = options.fsm;
+	this.lc_smgr = options.fsm.getSocketMgr();
+	this.lc_conn = undefined;
+	this.lc_ckey = options.ckey;
+	this.lc_hdl = undefined;
+	this.lc_log = options.log;
+
+	FSM.call(this, 'init');
+}
+mod_util.inherits(LogicalConnection, FSM);
+LogicalConnection.prototype.drain = function () {
+	mod_assert.ok(!this.isInState('stopped'));
+	this.emit('drainAsserted');
+};
+LogicalConnection.prototype.state_init = function (S) {
+	S.validTransitions(['advertised', 'stopped']);
+	var self = this;
+
+	var hdlOpts = {
+		pool: this.lc_set,
+		claimStack: 'Error\n' +
+		    ' at claim\n' +
+		    ' at CueBallConnectionSet.addConnection\n' +
+		    ' at CueBallConnectionSet.addConnection',
+		callback: S.callback(onClaimed),
+		log: this.lc_log,
+		claimTimeout: Infinity
+	};
+	this.lc_hdl = new CueBallClaimHandle(hdlOpts);
+
+	function onClaimed(err, hdl, conn) {
+		mod_assert.ok(!err);
+		mod_assert.strictEqual(hdl, self.lc_hdl);
+		self.lc_conn = conn;
+		S.gotoState('advertised');
+	}
+
+	/*
+	 * Keep trying this FSM again and again until we get a claim. It's fine
+	 * to attempt multiple times while in this state, because we never
+	 * emitted 'added' for this ckey yet.
+	 */
+	S.on(this.lc_hdl, 'stateChanged', function (st) {
+		if (st === 'waiting' && self.lc_hdl.isInState('waiting')) {
+			if (self.lc_fsm.isInState('idle')) {
+				self.lc_hdl.try(self.lc_fsm);
+			}
+		}
+	});
+
+	S.on(this.lc_fsm, 'stateChanged', function (st) {
+		if (st === 'idle' && self.lc_fsm.isInState('idle')) {
+			if (self.lc_hdl.isInState('waiting')) {
+				self.lc_hdl.try(self.lc_fsm);
+			}
+		}
+	});
+
+	/*
+	 * If the Set calls .drain(), we go straight to stopped. We're no longer
+	 * wanted, and we never advertised this connection to the user.
+	 */
+	S.on(this, 'drainAsserted', function () {
+		S.gotoState('stopped');
+	});
+};
+LogicalConnection.prototype.state_advertised = function (S) {
+	S.validTransitions(['draining', 'stopped']);
+
+	/*
+	 * According to the API docs, the user can call .close() on the handle
+	 * at any time, but .release() only *after* we emit 'removed'.
+	 */
+	S.on(this.lc_hdl, 'stateChanged', function (st) {
+		if (st === 'closed') {
+			S.gotoState('stopped');
+		}
+		if (st === 'released') {
+			throw (new Error('The .release() method may not be ' +
+			    'called on a ConnectionSet handle before ' +
+			    '"removed" has been emitted'));
+		}
+	});
+
+	/*
+	 * If the socket disconnects, then move to 'draining' to emit 'removed'.
+	 */
+	S.on(this.lc_smgr, 'stateChanged', function (st) {
+		if (st !== 'connected') {
+			S.gotoState('draining');
+		}
+	});
+
+	/* And also if the Set's rebalancer decided it doesn't want us. */
+	S.on(this, 'drainAsserted', function () {
+		S.gotoState('draining');
+	});
+
+	this.lc_set.assertEmit('added', this.lc_ckey, this.lc_conn,
+	    this.lc_hdl);
+};
+LogicalConnection.prototype.state_draining = function (S) {
+	S.validTransitions(['stopped']);
+
+	/*
+	 * The only way out of 'draining' is when the user tells us the
+	 * connection has drained. This means the handle has to transition.
+	 */
+	S.on(this.lc_hdl, 'stateChanged', function (st) {
+		if (st === 'closed' || st === 'released' || st === 'cancelled')
+			S.gotoState('stopped');
+	});
+
+	/*
+	 * It's fine to call emit directly here, because the only transition
+	 * out of this state is via a 'stateChanged' which is always emitted
+	 * async -- i.e. we can't loop back into ourselves.
+	 */
+	this.lc_set.assertEmit('removed', this.lc_ckey, this.lc_conn,
+	    this.lc_hdl);
+};
+LogicalConnection.prototype.state_stopped = function (S) {
+	S.validTransitions([]);
+
+	/* Cancel the handle if we got here from init. */
+	if (this.lc_hdl.isInState('waiting') ||
+	    this.lc_hdl.isInState('claiming')) {
+		this.lc_hdl.cancel();
+	}
+};
diff --git a/package.json b/package.json
index 22b086c..9820e3c 100644
--- a/package.json
+++ b/package.json
@@ -1,6 +1,6 @@
 {
   "name": "cueball",
-  "version": "2.1.0",
+  "version": "2.1.1",
   "description": "manage a pool of connections to a multi-node service where nodes are listed in DNS",
   "main": "lib/index.js",
   "dependencies": {
diff --git a/test/cset.test.js b/test/cset.test.js
index 175ff78..834d63e 100644
--- a/test/cset.test.js
+++ b/test/cset.test.js
@@ -491,3 +491,63 @@ mod_tape.test('cset with error', function (t) {
 		connections.forEach(function (c) { c.connect(); });
 	});
 });
+
+mod_tape.test('cset connect-reject (#92)', function (t) {
+	connections = [];
+	var inset = [];
+	resolver = new DummyResolver();
+
+	var cset = new mod_cset.ConnectionSet({
+		log: log,
+		constructor: function (backend) {
+			return (new DummyConnection(backend));
+		},
+		recovery: {
+			default: {
+				timeout: 1000,
+				retries: 0,
+				delay: 0
+			}
+		},
+		target: 2,
+		maximum: 4,
+		resolver: resolver
+	});
+
+	cset.on('stateChanged', function (st) {
+		if (st === 'failed')
+			cset.stop();
+		if (st === 'stopped')
+			t.end();
+	});
+
+	cset.on('added', function (key, conn) {
+		inset.push(key);
+	});
+
+	cset.on('removed', function (key, conn, hdl) {
+		var idx = inset.indexOf(key);
+		t.notStrictEqual(idx, -1);
+		inset.splice(idx, 1);
+
+		t.ok(conn);
+		t.ok(hdl);
+		t.ok(conn.dead);
+		conn.seen = true;
+		hdl.release();
+	});
+
+	resolver.start();
+	t.strictEqual(connections.length, 0);
+
+	resolver.emit('added', 'b1', {});
+
+	setImmediate(function () {
+		connections.forEach(function (c) {
+			c.connect();
+			setImmediate(function () {
+				c.destroy();
+			});
+		});
+	});
+});
