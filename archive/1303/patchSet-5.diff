From ebd671d827c07774df691d56f6b61b7ab9e7945b Mon Sep 17 00:00:00 2001
From: Cody Peter Mello <cody.mello@joyent.com>
Date: Thu, 19 Jan 2017 22:18:34 +0000
Subject: [PATCH] FWAPI-271 Invalid subnets in firewall rules should be
 rejected Reviewed by: Alex Wilson <alex.wilson@joyent.com>

---
 lib/index.js         | 20 +++++----------
 lib/parser.js        |  4 +--
 lib/validators.js    | 50 ++++++++++++++++++++++--------------
 package.json         |  3 ++-
 src/fwrule.jison     |  4 +--
 test/invalid.test.js | 24 ++++++++++++------
 test/parser.test.js  | 60 ++++++++++++++++++++++++++++++++++++++++++++
 7 files changed, 120 insertions(+), 45 deletions(-)

diff --git a/lib/index.js b/lib/index.js
index f42f6a9..fa88a66 100644
--- a/lib/index.js
+++ b/lib/index.js
@@ -20,7 +20,7 @@
  *
  * CDDL HEADER END
  *
- * Copyright (c) 2016, Joyent, Inc. All rights reserved.
+ * Copyright 2017, Joyent, Inc. All rights reserved.
  *
  *
  * firewall rule parser: entry point
@@ -93,14 +93,6 @@ parser.yy.validateIPv4address = function validateIPv4address(ip) {
 };
 
 
-parser.yy.validateIPv4subnet = function validateIPv4subnet(subnet) {
-    if (!validators.validateIPv4subnet(subnet)) {
-        throw new validators.InvalidParamError('rule',
-            'Subnet "%s" is invalid (must be in CIDR format)', subnet);
-    }
-};
-
-
 parser.yy.validateIPv6address = function validateIPv6address(ip) {
     if (!mod_net.isIPv6(ip)) {
         throw new validators.InvalidParamError('rule',
@@ -109,11 +101,8 @@ parser.yy.validateIPv6address = function validateIPv6address(ip) {
 };
 
 
-parser.yy.validateIPv6subnet = function validateIPv6subnet(subnet) {
-    if (!validators.validateIPv6subnet(subnet)) {
-        throw new validators.InvalidParamError('rule',
-            'Subnet "%s" is invalid (must be in CIDR format)', subnet);
-    }
+parser.yy.validateSubnet = function validateSubnet(input) {
+    validators.validateSubnet('rule', input, parser.yy.enforceSubnetMask);
 };
 
 
@@ -231,6 +220,9 @@ function parse(input, opts) {
     // If a version hasn't been specified, use most recent
     parser.yy.maxVersion = opts.maxVersion || CURR_VERSION;
 
+    // Whether we should check if CIDRs have bits set past mask
+    parser.yy.enforceSubnetMask = !!opts.enforceSubnetMask;
+
     return parser.parse(input);
 }
 
diff --git a/lib/parser.js b/lib/parser.js
index 23f64d3..d9c6e5a 100644
--- a/lib/parser.js
+++ b/lib/parser.js
@@ -55,7 +55,7 @@ break;
 case 18: yy.validateIPv4address($$[$0]);
           this.$ = [ ['ip', $$[$0]] ]; 
 break;
-case 19: yy.validateIPv4subnet($$[$0-1] + $$[$0]);
+case 19: yy.validateSubnet($$[$0-1] + $$[$0]);
             this.$ = [ ['subnet', $$[$0-1] + $$[$0]] ]; 
 break;
 case 20: yy.validateOKVersion(3, 'IPv6');
@@ -63,7 +63,7 @@ case 20: yy.validateOKVersion(3, 'IPv6');
           this.$ = [ ['ip', $$[$0]] ]; 
 break;
 case 21: yy.validateOKVersion(3, 'IPv6');
-          yy.validateIPv6subnet($$[$0-1] + $$[$0]);
+          yy.validateSubnet($$[$0-1] + $$[$0]);
             this.$ = [ ['subnet', $$[$0-1] + $$[$0]] ]; 
 break;
 case 22: this.$ = [ ['vm', $$[$0]] ]; 
diff --git a/lib/validators.js b/lib/validators.js
index 651df74..4238cc9 100644
--- a/lib/validators.js
+++ b/lib/validators.js
@@ -30,6 +30,7 @@
 
 'use strict';
 
+var ipaddr = require('ip6addr');
 var net = require('net');
 var util = require('util');
 var VError = require('verror').VError;
@@ -92,24 +93,6 @@ function validateIPv4subnet(subnet) {
 }
 
 
-/**
- * Returns true if subnet is a valid IPv6 CIDR range
- */
-function validateIPv6subnet(subnet) {
-    var parts = subnet.split('/');
-    var plen = Number(parts[1]);
-    if (!net.isIPv6(parts[0])) {
-        return false;
-    }
-
-    if (!plen || (plen < 1) || (plen > 128)) {
-        return false;
-    }
-
-    return true;
-}
-
-
 /**
  * Returns true if port is a valid port number
  */
@@ -201,6 +184,35 @@ function validateString(name, str) {
 }
 
 
+/**
+ * Throws an InvalidParamError if the subnet is invalid
+ */
+function validateSubnet(name, input, enforceSubnetMask) {
+    var parts = input.split('/');
+    var addr, plen, subnet;
+
+    try {
+        addr = ipaddr.parse(parts[0]);
+        plen = Number(parts[1]);
+    } catch (_) {
+        throw new InvalidParamError(name,
+            'Subnet "%s" is invalid (bad address component)', input);
+    }
+
+    try {
+        subnet = ipaddr.createCIDR(addr, plen);
+    } catch (_) {
+        throw new InvalidParamError(name,
+            'Subnet "%s" is invalid (bad prefix length)', input);
+    }
+
+    if (enforceSubnetMask && subnet.address().compare(addr) !== 0) {
+        throw new InvalidParamError(name,
+            'Subnet "%s" is invalid (bits set to right of mask)', input);
+    }
+}
+
+
 /**
  * Returns true if uuid is a valid UUID
  */
@@ -215,7 +227,7 @@ module.exports = {
     validateAction: validateAction,
     validateIPv4address: validateIPv4address,
     validateIPv4subnet: validateIPv4subnet,
-    validateIPv6subnet: validateIPv6subnet,
+    validateSubnet: validateSubnet,
     validatePort: validatePort,
     validatePortOrAll: validatePortOrAll,
     validateProtocol: validateProtocol,
diff --git a/package.json b/package.json
index e3660f4..47bc495 100644
--- a/package.json
+++ b/package.json
@@ -1,7 +1,7 @@
 {
   "name": "fwrule",
   "description": "Parser for Joyent firewall rules",
-  "version": "1.3.1",
+  "version": "1.4.0",
   "author": "Joyent (joyent.com)",
   "keywords": [ "smartos", "triton" ],
   "repository": {
@@ -9,6 +9,7 @@
     "url": "git://github.com/joyent/sdc-fwrule.git"
   },
   "dependencies": {
+    "ip6addr": "0.2.2",
     "node-uuid": "1.2.0",
     "extsprintf": "1.0.1",
     "verror": "1.3.4"
diff --git a/src/fwrule.jison b/src/fwrule.jison
index 0f48785..096946e 100644
--- a/src/fwrule.jison
+++ b/src/fwrule.jison
@@ -153,7 +153,7 @@ ipv4
 
 ipv4_subnet
     : SUBNET IPV4ADDR CIDRSUFFIX
-        { yy.validateIPv4subnet($2 + $3);
+        { yy.validateSubnet($2 + $3);
             $$ = [ ['subnet', $2 + $3] ]; }
     ;
 
@@ -167,7 +167,7 @@ ipv6
 ipv6_subnet
     : SUBNET IPV6ADDR CIDRSUFFIX
         { yy.validateOKVersion(3, 'IPv6');
-          yy.validateIPv6subnet($2 + $3);
+          yy.validateSubnet($2 + $3);
             $$ = [ ['subnet', $2 + $3] ]; }
     ;
 
diff --git a/test/invalid.test.js b/test/invalid.test.js
index 379899c..5fde866 100644
--- a/test/invalid.test.js
+++ b/test/invalid.test.js
@@ -20,7 +20,7 @@
  *
  * CDDL HEADER END
  *
- * Copyright (c) 2016, Joyent, Inc. All rights reserved.
+ * Copyright 2017, Joyent, Inc. All rights reserved.
  *
  *
  * Negative unit tests for the firewall rule object
@@ -108,19 +108,27 @@ var INVALID = [
 
     [ 'invalid IPv4 subnet: bad address component',
         { rule: 'FROM tag foo TO subnet 10.350.0.0/24 ALLOW udp port 53' },
-        'rule', 'Subnet "10.350.0.0/24" is invalid (must be in CIDR format)' ],
+        'rule', 'Subnet "10.350.0.0/24" is invalid (bad address component)' ],
 
     [ 'invalid IPv4 subnet: bad prefix length',
         { rule: 'FROM tag foo TO subnet 10.8.0.0/33 ALLOW udp port 53' },
-        'rule', 'Subnet "10.8.0.0/33" is invalid (must be in CIDR format)' ],
+        'rule', 'Subnet "10.8.0.0/33" is invalid (bad prefix length)' ],
+
+    [ 'invalid IPv4 subnet: bits set past mask',
+        { rule: 'FROM tag foo TO subnet 10.8.0.0/5 ALLOW udp port 53' },
+        'rule', 'Subnet "10.8.0.0/5" is invalid (bits set to right of mask)' ],
 
     [ 'invalid IPv6 subnet: bad address component',
         { rule: 'FROM tag foo TO subnet fd005::/64 ALLOW udp port 53' },
-        'rule', 'Subnet "fd005::/64" is invalid (must be in CIDR format)' ],
+        'rule', 'Subnet "fd005::/64" is invalid (bad address component)' ],
 
     [ 'invalid IPv6 subnet: bad prefix length',
         { rule: 'FROM tag foo TO subnet fd00::/130 ALLOW udp port 53' },
-        'rule', 'Subnet "fd00::/130" is invalid (must be in CIDR format)' ],
+        'rule', 'Subnet "fd00::/130" is invalid (bad prefix length)' ],
+
+    [ 'invalid IPv6 subnet: bits set past mask',
+        { rule: 'FROM tag foo TO subnet fd00::/2 ALLOW udp port 53' },
+        'rule', 'Subnet "fd00::/2" is invalid (bits set to right of mask)' ],
 
     [ 'invalid port: too small',
         { rule: 'FROM tag foo TO subnet 10.8.0.0/24 ALLOW udp port 0' },
@@ -339,12 +347,14 @@ test('Invalid rules', function (t) {
         var testName = data[0];
         var expMsg = data[3];
         var field = data[2];
-        var opts;
+        var opts = { enforceSubnetMask: true };
         var rule = data[1];
         var thrown = false;
 
         try {
-            opts = (field === 'global' ? { enforceGlobal: true } : {});
+            if (field === 'global') {
+                opts.enforceGlobal = true;
+            }
             fwrule.create(rule, opts);
         } catch (err) {
             thrown = true;
diff --git a/test/parser.test.js b/test/parser.test.js
index b278691..ff90235 100644
--- a/test/parser.test.js
+++ b/test/parser.test.js
@@ -390,6 +390,66 @@ test('Parser option: maxVersion', function (t) {
 });
 
 
+test('Parser option: enforceSubnetMask', function (t) {
+    var errFmt = 'Subnet "%s" is invalid (bits set to right of mask)';
+    var txtFmt = 'FROM subnet %s TO TAG foo ALLOW TCP PORTS 80';
+    function parsed(cidr) {
+        return {
+            from: [ [ 'subnet', cidr ] ],
+            to: [ [ 'tag', 'foo' ] ],
+            action: 'allow',
+            protocol: {
+                name: 'tcp',
+                targets: [ 80 ]
+            }
+        };
+    }
+
+    var v4sub = '1.2.3.4/24';
+    var v4rule = util.format(txtFmt, v4sub);
+    var v4parsed = parsed(v4sub);
+
+    var v6sub = 'fd00::1/8';
+    var v6rule = util.format(txtFmt, v6sub);
+    var v6parsed = parsed(v6sub);
+
+    var disabled = { enforceSubnetMask: false };
+    var enabled = { enforceSubnetMask: true };
+    var unspecified = { };
+
+    [
+        [ v4rule, enabled, util.format(errFmt, v4sub) ],
+        [ v6rule, enabled, util.format(errFmt, v6sub) ]
+    ].forEach(function (cfg) {
+        var desc = util.format('opts=%j, rule=%s', cfg[1], cfg[0]);
+        try {
+            parser.parse(cfg[0], cfg[1]);
+            t.fail(desc);
+        } catch (err) {
+            t.equal(err.message, cfg[2], desc);
+        }
+    });
+
+    [
+        [ v4rule, undefined, v4parsed ],
+        [ v4rule, disabled, v4parsed ],
+        [ v4rule, unspecified, v4parsed ],
+        [ v6rule, undefined, v6parsed ],
+        [ v6rule, disabled, v6parsed ],
+        [ v6rule, unspecified, v6parsed ]
+    ].forEach(function (cfg) {
+        var desc = util.format('opts=%j, rule=%s', cfg[1], cfg[0]);
+        try {
+            t.deepEqual(parser.parse(cfg[0], cfg[1]), cfg[2], desc);
+        } catch (err) {
+            t.ifError(err, desc);
+        }
+    });
+
+    t.end();
+});
+
+
 test('icmp with code', function (t) {
     var vm = 'b0b92cd9-1fe7-4636-8477-81d2742566c2';
     var ruleTxt = util.format('FROM ip 10.0.0.2 TO vm %s ALLOW icmp type 8 '
-- 
2.21.0

