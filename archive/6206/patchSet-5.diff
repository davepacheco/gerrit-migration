commit 69a7e94497cc313852a1020d572e1dcb79c4b7e8
Author: Robert Bogart <robert.bogart@joyent.com>
Date:   2019-05-07T20:16:15+00:00 (5 months ago)
    
    MANTA-4252 Accelerated garbage collection should index manta_fastdelete_queue offset by shard

diff --git a/lib/moray_delete_record_cleaner.js b/lib/moray_delete_record_cleaner.js
index 9c10337..6b8ced5 100644
--- a/lib/moray_delete_record_cleaner.js
+++ b/lib/moray_delete_record_cleaner.js
@@ -256,7 +256,7 @@ _batch_delete(done)
 			 * it can update its current offset within the table
 			 * based on this information.
 			 */
-			self.emit('delete', keys.length);
+			self.emit('delete', self.mc_shard, keys.length);
 		}
 
 		for (var i = 0; i < keys.length; i++) {
diff --git a/lib/moray_delete_record_reader.js b/lib/moray_delete_record_reader.js
index e08ee7c..2261fdf 100644
--- a/lib/moray_delete_record_reader.js
+++ b/lib/moray_delete_record_reader.js
@@ -98,8 +98,8 @@ MorayDeleteRecordReader(opts)
 	 */
 	self.mr_moray_listener = opts.listener.mt_moray_listener;
 
-	self.mr_moray_listener.on('delete', function (num_entries) {
-		self._decr_offset(num_entries);
+	self.mr_moray_listener.on('delete', function (shard, num_entries) {
+		self._decr_offset(shard, num_entries);
 	});
 
 	mod_fsm.FSM.call(self, 'running');
@@ -125,25 +125,51 @@ _get_tunables_ref()
 };
 
 
+/*
+ * Get bucket info for a specified shard.
+ */
 MorayDeleteRecordReader.prototype._get_bucket_ref = function
-_get_bucket_ref()
+_get_bucket_ref(shard)
 {
 	var self = this;
 	var buckets = self.mr_ctx.ctx_cfg.buckets;
-	var bucket_ref = undefined;
+	var bucket = null;
 
 	for (var i = 0; i < buckets.length; i++) {
-		var bucket = buckets[i];
-		if (bucket.name === self.mr_bucket) {
-			bucket_ref = bucket;
+		if (buckets[i].name === self.mr_bucket) {
+			bucket = buckets[i];
+			break;
 		}
 	}
 
-	if (bucket_ref.record_read_offset === undefined) {
-		bucket_ref.record_read_offset = 0;
+	/*
+	 * The caller should not ever end up asking for a bucket that does not
+	 * exist in our list of buckets.  If `bucket' is null at this point,
+	 * it is a sign of something more systemic.
+	 */
+	mod_assertplus.object(bucket, 'bucket');
+
+	/*
+	 * It's ok if the list of shards for this bucket is empty.  Initialize
+	 * it now.  The first shard (of what is likely to be seceral) will be
+	 * added to it next.
+	 */
+	if (!bucket.shards)
+		bucket.shards = [];
+
+	/*
+	 * If the shard does not exist then this must be a shard that we have
+	 * not had any interaction with (yet).  Initialize the table offset to
+	 * 0.  If we add other members to this structure in the future, it may
+	 * be worth implementing a separate initialization routine for it.
+	 */
+	if (!bucket.shards[shard]) {
+		bucket.shards[shard] = {
+			record_read_offset: 0
+		};
 	}
 
-	return (bucket_ref);
+	return (bucket.shards[shard]);
 };
 
 
@@ -162,28 +188,28 @@ _get_delay()
 
 
 MorayDeleteRecordReader.prototype._get_offset = function
-_get_offset()
+_get_offset(shard)
 {
-	return (this._get_bucket_ref().record_read_offset);
+	return (this._get_bucket_ref(shard).record_read_offset);
 };
 
 
 MorayDeleteRecordReader.prototype._incr_offset = function
-_incr_offset(delta)
+_incr_offset(shard, delta)
 {
-	this._get_bucket_ref().record_read_offset += delta;
+	this._get_bucket_ref(shard).record_read_offset += delta;
 };
 
 
 MorayDeleteRecordReader.prototype._decr_offset = function
-_decr_offset(delta)
+_decr_offset(shard, delta)
 {
-	var offset = this._get_bucket_ref().record_read_offset;
+	var offset = this._get_bucket_ref(shard).record_read_offset;
 
 	this.mr_log.debug('Reducing table offset from %d to %d.',
 	    offset, offset - delta);
 
-	this._get_bucket_ref().record_read_offset -= delta;
+	this._get_bucket_ref(shard).record_read_offset -= delta;
 };
 
 
@@ -263,7 +289,7 @@ _find_objects() {
 	mod_assertplus.object(moray_client, 'moray_client');
 
 	var batch = self._get_batch_size();
-	var offset = self._get_offset();
+	var offset = self._get_offset(self.mr_shard);
 
 	var find_objects_opts = {
 		limit: batch,
@@ -276,6 +302,7 @@ _find_objects() {
 
 	self.mr_log.debug({
 		bucket: self.mr_bucket,
+		shard: self.mr_shard,
 		offset: offset,
 		limit: batch,
 		opts: find_objects_opts
@@ -380,13 +407,13 @@ state_running(S)
 			 * Increment our current offset by the number of
 			 * records we just received.
 			 */
-			self._incr_offset(num_seen);
+			self._incr_offset(self.mr_shard, num_seen);
 
-			self.mr_log.info({
+			self.mr_log.debug({
 				bucket: self.mr_bucket,
 				shard: self.mr_shard,
 				num: num_seen,
-				offset: self._get_offset()
+				offset: self._get_offset(self.mr_shard)
 			}, 'Received records.');
 
 			/*
@@ -465,7 +492,7 @@ state_waiting(S)
 		self.mr_log.debug({
 			bucket: self.mr_bucket,
 			shard: self.mr_shard,
-			offset: self._get_offset(),
+			offset: self._get_offset(self.mr_shard),
 			last_received: self.mr_prev_records_received
 		}, 'Reader waiting %d milliseconds before ' +
 			'next findObjects.', self._get_delay() +
