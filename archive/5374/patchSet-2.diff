From 86450612ca79af88f093f366a3d7d085d50575e1 Mon Sep 17 00:00:00 2001
From: Jerry Jelinek <jerry.jelinek@joyent.com>
Date: Fri, 11 Jan 2019 15:36:52 +0000
Subject: [PATCH] OS-XXXX newboot OS-7364 fs_joyent.sh test needs quotes
 OS-7309 UEFI build_image should work in a NGZ

---
 .gitignore                                  |   2 +
 Makefile                                    |  38 +-
 TODO                                        |  36 ++
 configure                                   |   1 +
 overlay/generic/boot/forth/menu.rc          | 116 ++++++
 overlay/generic/lib/sdc/config.sh           |  21 +-
 overlay/generic/lib/sdc/usb-key.sh          | 245 ++++++++++++
 overlay/generic/lib/svc/method/fs-joyent    |  80 +---
 overlay/generic/lib/svc/method/smartdc-init | 268 +------------
 overlay/generic/manifest                    |   3 +
 src/nictagadm                               |  31 +-
 tools/build_boot_image                      | 422 ++++++++++++++++++++
 tools/build_iso                             | 392 ------------------
 tools/build_live                            |   9 +
 tools/build_usb                             |   1 -
 tools/format_image/Makefile                 |  39 ++
 tools/format_image/format_image.c           | 406 +++++++++++++++++++
 tools/images/1gb.fdisk                      |   6 -
 tools/images/2gb.fdisk                      |   6 -
 tools/images/4gb.fdisk                      |   6 -
 tools/images/8gb.fdisk                      |   6 -
 tools/images/make_image                     | 263 ------------
 tools/usb_fdisk_table                       |  52 ---
 23 files changed, 1326 insertions(+), 1123 deletions(-)
 create mode 100644 TODO
 create mode 100644 overlay/generic/boot/forth/menu.rc
 create mode 100644 overlay/generic/lib/sdc/usb-key.sh
 create mode 100755 tools/build_boot_image
 delete mode 100755 tools/build_iso
 delete mode 120000 tools/build_usb
 create mode 100644 tools/format_image/Makefile
 create mode 100644 tools/format_image/format_image.c
 delete mode 100644 tools/images/1gb.fdisk
 delete mode 100644 tools/images/2gb.fdisk
 delete mode 100644 tools/images/4gb.fdisk
 delete mode 100644 tools/images/8gb.fdisk
 delete mode 100755 tools/images/make_image
 delete mode 100644 tools/usb_fdisk_table

diff --git a/.gitignore b/.gitignore
index 67122a07..6ed93817 100644
--- a/.gitignore
+++ b/.gitignore
@@ -44,6 +44,8 @@
 /tools/builder/users.c
 /tools/builder/users.c.tmp
 /tools/cryptpass
+/tools/format_image/*.o
+/tools/format_image/format_image
 /tools/pwgen
 /tools/pwgen-2.06/configure
 /tools/javascriptlint/build
diff --git a/Makefile b/Makefile
index 2fd6b1ca..dae07a5d 100644
--- a/Makefile
+++ b/Makefile
@@ -10,7 +10,7 @@
 #
 
 #
-# Copyright 2018 Joyent, Inc.
+# Copyright (c) 2018, Joyent, Inc.
 #
 
 #
@@ -118,8 +118,6 @@ IMAGES_VERSION :=	images-$(shell [[ -f $(ROOT)/configure-buildver ]] && \
     echo $$(head -n1 $(ROOT)/configure-buildver)-)$(shell head -n1 $(STAMPFILE))
 IMAGES_TARBALL :=	output/$(IMAGES_VERSION).tgz
 
-IMAGES_SIZES_GB :=	1 2 4 8
-
 TOOLS_TARGETS = \
 	$(MANCHECK) \
 	$(MANCF) \
@@ -147,32 +145,27 @@ pkgsrc:
 
 $(BOOT_TARBALL): world manifest
 	pfexec rm -rf $(BOOT_PROTO)
-	mkdir -p $(BOOT_PROTO)
+	mkdir -p $(BOOT_PROTO)/etc/version/
 	mkdir -p $(ROOT)/output
 	pfexec ./tools/builder/builder $(ROOT)/$(BOOT_MANIFEST) \
-	    $(BOOT_PROTO) $(ROOT)/proto
+	    $(BOOT_PROTO) $(OVERLAYS) $(ROOT)/proto
+	cp $(STAMPFILE) $(BOOT_PROTO)/etc/version/boot
 	(cd $(BOOT_PROTO) && pfexec gtar czf $(ROOT)/$@ .)
 
 #
-# Create proforma images for use in assembling bootable USB device images.
-# These images are assembled into a sparse tar file which takes up hardly any
-# space, despite the large size of the (mostly blank) images.  This tar file is
-# used by "make coal" and "make usb" in "sdc-headnode.git" to create Triton
-# boot and installation media.
+# Create proforma images for use in assembling bootable USB device images.  The
+# images tar file is by used by "make coal" and "make usb" in "sdc-headnode.git"
+# to create Triton boot and installation media.
 #
-images: $(IMAGES_SIZES_GB:%=$(IMAGES_PROTO)/%gb.img)
-
-$(IMAGES_PROTO)/%.img: boot tools/images/%.fdisk tools/images/make_image
+$(IMAGES_PROTO)/4gb.img: boot
 	rm -f $@
 	mkdir -p $(IMAGES_PROTO)
-	./tools/images/make_image -s $* -G $(ROOT)/proto \
-	    -F tools/images/$*.fdisk $@
+	./tools/build_boot_image -p 4 -r $(ROOT)
 
-images-tar: $(IMAGES_TARBALL)
+$(IMAGES_TARBALL): $(IMAGES_PROTO)/4gb.img
+	cd $(IMAGES_PROTO) && gtar -Scvz --owner=0 --group=0 -f $(ROOT)/$@ *
 
-$(IMAGES_TARBALL): images
-	cd $(IMAGES_PROTO) && gtar -Scvz --owner=0 --group=0 -f $(ROOT)/$@ \
-	    $(IMAGES_SIZES_GB:%=%gb.img)
+images-tar: $(IMAGES_TARBALL)
 
 #
 # Manifest construction.  There are 5 sources for manifests we need to collect
@@ -344,6 +337,7 @@ strap-cache:
 
 0-tools-stamp: 0-pwgen-stamp
 	(cd $(ROOT)/tools/builder && gmake builder)
+	(cd $(ROOT)/tools/format_image && gmake)
 	touch $@
 
 0-pwgen-stamp:
@@ -409,6 +403,8 @@ clean:
 	(cd $(ROOT) && mkdir -p $(PROTO) $(STRAP_PROTO) $(BOOT_PROTO) \
 	    $(IMAGES_PROTO))
 	rm -f tools/cryptpass
+	(cd tools/builder && gmake clean)
+	(cd tools/format_image && gmake clean)
 	(cd tools/mancheck && gmake clean)
 	(cd tools/mancf && gmake clean)
 	(cd tools/tzcheck && gmake clean)
@@ -419,10 +415,10 @@ clobber: clean
 	pfexec rm -rf output/* output-iso/* output-usb/*
  
 iso: live
-	./tools/build_iso
+	./tools/build_boot_image -I -r $(ROOT)
 
 usb: live
-	./tools/build_usb
+	./tools/build_boot_image -r $(ROOT)
 
 FRC:
 
diff --git a/TODO b/TODO
new file mode 100644
index 00000000..38d79721
--- /dev/null
+++ b/TODO
@@ -0,0 +1,36 @@
+
+This is just a convenient temporary TODO list...
+
+ - remove sdc-booter pxegrub?
+ - actually remove scripts/mount-usb.sh?
+ - Triton doc changes
+ - can we remove TOOLS-1000 changes?
+ - archive sdcboot on github
+ - sync ipxe into kvm-cmd
+ - should we bzip usb image?
+ - update copyrights?
+ - "enable-disaster-recovery" support missing
+
+Repos with changes
+------------------
+
+	illumos-joyent
+	smartos-live
+	sdc-headnode
+	mountain-gorilla
+	triton
+	sdcboot
+	sdc-booter
+	ipxe
+	kvm-cmd?
+
+Later
+
+ - sdc-usbkey
+   - add subcommand to dump boot component version JSON blob
+ - need to run loader install for headnode not just CNs
+ - would be nice if autoboot showed what it was going boot
+ - would be nice to show the default console device again
+ - usb key conversion tool
+ - replace screen-rows/cols name with ncols name? avoid problems?
+ - Add Joyent/SmartOS image/branding for VGA console?
diff --git a/configure b/configure
index baec0161..14e15d8c 100755
--- a/configure
+++ b/configure
@@ -320,6 +320,7 @@ FLEX=/opt/local/bin/flex;			export FLEX
 GNUXGETTEXT=/opt/local/bin/xgettext;		export GNUXGETTEXT
 PYTHON=/opt/local/bin/python2.7;		export PYTHON
 BUILDPY3='#';					export BUILDPY3
+BUILDPY3TOOLS='#';				export BUILDPY3TOOLS
 #
 # Note that this isn't the strap perl: that only really exists for the benefit
 # of projects/illumos-extra/openssl
diff --git a/overlay/generic/boot/forth/menu.rc b/overlay/generic/boot/forth/menu.rc
new file mode 100644
index 00000000..b9978f24
--- /dev/null
+++ b/overlay/generic/boot/forth/menu.rc
@@ -0,0 +1,116 @@
+\ Menu.rc
+\
+\ Load required Forth modules
+include /boot/forth/version.4th
+include /boot/forth/brand.4th
+include /boot/forth/menu.4th
+include /boot/forth/menu-commands.4th
+include /boot/forth/shortcuts.4th
+
+\ Screen prep
+clear         \ clear the screen (see `screen.4th')
+print_version \ print version string (bottom-right; see `version.4th')
+draw-beastie  \ draw freebsd mascot (on right; see `beastie.4th')
+draw-brand    \ draw the FreeBSD title (top-left; see `brand.4th')
+menu-init     \ initialize the menu area (see `menu.4th')
+
+\ Initialize main menu constructs (see `menu.4th')
+\ NOTE: To use `non-ansi' variants, add `loader_color=0' to loader.conf(5)
+\ NOTE: ANSI variants can use `^' in place of literal `Esc' (ASCII 27)
+
+\
+\ MAIN MENU
+\
+
+set menuset_name1="main"
+
+set mainmenu_init[1]="init_boot"
+
+set mainmenu_caption[1]="Boot SmartOS [Enter]"
+set mainansi_caption[1]="^[1mB^[moot SmartOS ^[1m[Enter]^[m"
+set mainmenu_command[1]="boot"
+\ keycode set by init_boot
+
+set mainmenu_caption[2]="[Esc]ape to loader prompt"
+set mainmenu_command[2]="goto_prompt"
+set mainmenu_keycode[2]=27
+set mainansi_caption[2]="^[1mEsc^[mape to loader prompt"
+
+\ Enable built-in "Reboot" trailing menuitem
+\ NOTE: appears before menu_options if configured
+\
+set mainmenu_reboot
+
+\ Enable "Options:" separator. When set to a numerical value (1-8), a visual
+\ separator is inserted before that menuitem number.
+\
+set mainmenu_options=4
+
+set mainmenu_caption[4]="Configure Boot [O]ptions..."
+set mainmenu_command[4]="2 goto_menu"
+set mainmenu_keycode[4]=111
+set mainansi_caption[4]="Configure Boot ^[1mO^[mptions..."
+
+\
+\ BOOT OPTIONS MENU
+\
+
+set menuset_name2="options"
+
+set optionsmenu_caption[1]="Back to Main Menu [Backspace]"
+set optionsmenu_command[1]="1 goto_menu"
+set optionsmenu_keycode[1]=8
+set optionsansi_caption[1]="Back to Main Menu ^[1m[Backspace]^[m"
+
+set optionsmenu_options=2
+set optionsmenu_optionstext="Boot Options:"
+
+set optionsmenu_osconsole=2
+set optionsmenu_command[2]="cycle_osconsole"
+set optionsmenu_keycode[2]=99
+
+set optionsmenu_init[3]="init_verbose"
+set optionsmenu_caption[3]="[V]erbose............. Off"
+set optionstoggled_text[3]="[V]erbose............. On"
+set optionsmenu_command[3]="toggle_verbose"
+set optionsmenu_keycode[3]=118
+set optionsansi_caption[3]="^[1mV^[merbose............... ^[34;1mOff^[m"
+set optionstoggled_ansi[3]="^[1mV^[merbose............... ^[32;7mOn^[m"
+
+set optionsmenu_init[4]="init_kmdb"
+set optionsmenu_caption[4]="k[m]db................ Off"
+set optionstoggled_text[4]="k[m]db................ On"
+set optionsmenu_command[4]="toggle_kmdb"
+set optionsmenu_keycode[4]=109
+set optionsansi_caption[4]="k^[1mm^[mdb.................. ^[34;1mOff^[m"
+set optionstoggled_ansi[4]="k^[1mm^[mdb.................. ^[32;7mOn^[m"
+
+set optionsmenu_init[5]="init_debug"
+set optionsmenu_caption[5]="[D]ebug............... Off"
+set optionstoggled_text[5]="[D]ebug............... On"
+set optionsmenu_command[5]="toggle_debug"
+set optionsmenu_keycode[5]=100
+set optionsansi_caption[5]="^[1mD^[mebug................. ^[34;1mOff^[m"
+set optionstoggled_ansi[5]="^[1mD^[mebug................. ^[32;7mOn^[m"
+
+set optionsmenu_init[6]="init_dr"
+set optionsmenu_caption[6]="Disaster [R]ecovery... Off"
+set optionstoggled_text[6]="Disaster [R]ecovery... On"
+set optionsmenu_command[6]="toggle_dr"
+set optionsmenu_keycode[6]=114
+set optionsansi_caption[6]="Disaster ^[1mR^[mecovery..... ^[34;1mOff^[m"
+set optionstoggled_ansi[6]="Disaster ^[1mR^[mecovery..... ^[32;7mOn^[m"
+
+\ Enable automatic booting (add ``autoboot_delay=N'' to loader.conf(5) to
+\ customize the timeout; default is 10-seconds)
+\
+set menu_timeout_command="boot"
+
+\ Include optional elements defined in a local file
+\
+try-include /boot/menu.rc.local
+
+\ Display the main menu (see `menu.4th')
+set menuset_initial=1
+menuset-loadinitial
+menu-display
diff --git a/overlay/generic/lib/sdc/config.sh b/overlay/generic/lib/sdc/config.sh
index 0c8e5621..21b504bb 100644
--- a/overlay/generic/lib/sdc/config.sh
+++ b/overlay/generic/lib/sdc/config.sh
@@ -7,7 +7,7 @@
 #
 # bash config.sh -json
 #
-# Copyright 2016 Joyent Inc.
+# Copyright 2018 Joyent Inc.
 #
 
 CACHE_FILE_JSON="/tmp/.config.json"
@@ -70,7 +70,20 @@ function load_sdc_sysinfo {
     prefix=$1
     [[ -z ${prefix} ]] && prefix="SYSINFO_"
 
-    eval $(/usr/bin/sysinfo -p | sed -e "s/^/${prefix}/")
+    #
+    # We've seen cases where Loader will set boot parameters that have a '#'
+    # character in the name.  Not surprisingly, bash won't let you have a '#'
+    # character in a shell variable name, so we strip any out of the lvalue
+    # as we process the sysinfo output.
+    #
+    tmpfile=$(mktemp -p /tmp)
+    /usr/bin/sysinfo -p | while read -r entry; do
+        lval=$(echo $entry | awk -F\= '{ print $1}' | sed -e 's/#//g')
+	rval=$(echo $entry | awk -F\= '{ print $2 }')
+	echo ${prefix}${lval}=${rval} >> $tmpfile
+    done
+    eval $(cat $tmpfile)
+    rm -f $tmpfile
 }
 
 # Sets SDC_CONFIG_FILENAME with the location of the config file. This can
@@ -187,7 +200,7 @@ function load_sdc_bootparams {
     [[ -z ${prefix} ]] && prefix="BOOT_"
     for line in $(/bin/bootparams); do
         fields=(${line//=/ })
-        key=$(echo ${fields[0]} | sed -e "s/-/_/g")
+        key=$(echo ${fields[0]} | sed -e "s/-/_/g;s/#//g")
         eval "${prefix}${key}=\"${fields[1]}\""
     done
 }
@@ -198,7 +211,7 @@ function sdc_bootparams_keys {
     #keys=$(cat /tmp/bootparams | sed -e "s/=.*//")
     for line in $(/bin/bootparams); do
         fields=(${line//=/ })
-        key=$(echo ${fields[0]} | sed -e "s/=.*//")
+        key=$(echo ${fields[0]} | sed -e "s/=.*//;s/#//g")
         echo ${key}
     done
 }
diff --git a/overlay/generic/lib/sdc/usb-key.sh b/overlay/generic/lib/sdc/usb-key.sh
new file mode 100644
index 00000000..66d0024f
--- /dev/null
+++ b/overlay/generic/lib/sdc/usb-key.sh
@@ -0,0 +1,245 @@
+#!/usr/bin/bash
+#
+# Utilities for dealing with the USB key. In general, sdc-usbkey should be used.
+# These routines are for use prior to sdc-usbkey being installed.
+#
+# Copyright (c) 2019, Joyent, Inc.
+#
+
+#
+# Identify the version of this USB key (if it is indeed a USB key).
+#
+# We do this by sniffing fixed offset within the MBR. If we have a (legacy)
+# grub MBR, then we can look at offset 0x3e for COMPAT_VERSION_MAJOR and
+# COMPAT_VERSION_MINOR (and we'll presume 3.2 as a minimum).
+#
+# If we're talking about a loader-based key, we'll peek at 0xfa AKA
+# STAGE1_MBR_VERSION for format_image's IMAGE_MAJOR, which we expect to be 2.
+#
+# Unfortunately there's no standard way to find a version for other MBRs such as
+# grub2's. In these cases we'll end up with a potentially random version here,
+# so this key should not be trusted as ours until mounted and the path
+# .joyusbkey is found.
+#
+function usb_key_version()
+{
+	local readonly devpath=$1
+	local readonly mbr_sig_offset=0x1fe
+	local readonly mbr_grub_offset=0x3e
+	local readonly mbr_stage1_offset=0xfa
+	local readonly mbr_grub_version=0203
+	local readonly mbr_sig=aa55
+
+	sig=$(echo $(/usr/bin/od -t x2 \
+	    -j $mbr_sig_offset -A n -N 2 $devpath) )
+
+	if [[ "$sig" != $mbr_sig ]]; then
+		echo "unknown"
+		return
+	fi
+
+	grub_val=$(echo $(/usr/bin/od -t x2 \
+	    -j $mbr_grub_offset -A n -N 2 $devpath) )
+	loader_major=$(echo $(/usr/bin/od -t x1 \
+	    -j $mbr_stage1_offset -A n -N 1 $devpath) )
+
+	if [[ "$grub_val" = $mbr_grub_version ]]; then
+		echo "1"
+		return
+	fi
+
+	echo $(( 0x$loader_major ))
+}
+
+#
+# Mount the usbkey at the standard mount location (or whatever is specified).
+#
+function mount_usb_key()
+{
+	local readonly mnt=$1
+
+	if [[ -z "$mnt" ]]; then
+		mnt=/mnt/$(svcprop -p "joyentfs/usb_mountpoint" \
+		    "svc:/system/filesystem/smartdc:default")
+	fi
+
+	if [[ -f "$mnt/.joyliveusb" ]]; then
+		echo $mnt
+		return 0
+	fi
+
+	if ! mkdir -p $mnt; then
+		echo "failed to mkdir $mnt" 2>&1
+		return 1
+	fi
+
+	readonly alldisks=$(/usr/bin/disklist -a)
+
+	for disk in $alldisks; do
+		version=$(usb_key_version "/dev/dsk/${disk}p0")
+
+		case $version in
+		1) devpath="/dev/dsk/${disk}p1" ;;
+		2) devpath="/dev/dsk/${disk}s2" ;;
+		*) continue ;;
+		esac
+
+		if [[ "$(/usr/sbin/fstyp $devpath 2>/dev/null)" != "pcfs" ]]; then
+			continue
+		fi
+
+		/usr/sbin/mount -F pcfs -o foldcase,noatime $devpath $mnt \
+		    2>/dev/null
+
+		if [[ $? -ne 0 ]]; then
+			continue
+		fi
+
+		if [[ -f $mnt/.joyliveusb ]]; then
+			echo $mnt
+			return 0
+		fi
+
+		if ! /usr/sbin/umount $mnt; then
+			echo "Failed to unmount $mnt" >&2
+			return 1
+		fi
+	done
+
+	echo "Couldn't find USB key" >&2
+	return 1
+}
+
+function unmount_usb_key()
+{
+	local readonly mnt=$1
+
+	if [[ -z "$mnt" ]]; then
+		mnt=/mnt/$(svcprop -p "joyentfs/usb_mountpoint" \
+		    "svc:/system/filesystem/smartdc:default")
+	fi
+
+	typ=$(awk -v "mnt=$mnt" '$2 == mnt { print $3 }' /etc/mnttab)
+
+	[[ -z $typ ]] && return 0
+
+	if [[ ! -f "$mnt/.joyliveusb" ]]; then
+		echo "$mnt does not contain a USB key" >&2
+		return 1
+	fi
+
+	umount "$mnt"
+}
+
+#
+# Mount the EFI system partition, if there is one.  Note that since we need to
+# peek at .joyliveusb to be sure, the only way to find a USB key is to mount its
+# root first...
+#
+function mount_usb_key_esp()
+{
+	local readonly rootmnt=$(mount_usb_key)
+
+	if [[ $? -ne 0 ]]; then
+		return 1
+	fi
+
+	dev=$(mount | nawk "\$0~\"^$rootmnt\" { print \$3 ; }")
+	dsk=${dev%[ps]?}
+
+	mnt=/tmp/mnt.$$
+
+	if ! mkdir -p $mnt; then
+		echo "failed to mkdir $mnt" 2>&1
+		return 1
+	fi
+
+	version=$(usb_key_version ${dsk}p0)
+
+	#
+	# If this key is still grub, then we don't have an ESP, but we shouldn't
+	# report an error.
+	#
+	if [[ "$version" = "1" ]]; then
+		rmdir $mnt
+		return 0
+	fi
+
+	/usr/sbin/mount -F pcfs -o foldcase,noatime ${dsk}s0 $mnt
+
+	if [[ $? -ne 0 ]]; then
+		rmdir $mnt
+		return 1
+	fi
+
+	echo $mnt
+	return 0
+}
+
+# replace a loader conf value
+function edit_param
+{
+	local readonly file="$1"
+	local readonly key="$2"
+	local readonly value="$3"
+	if ! /usr/bin/grep "^\s*$key\s*=\s*" $file >/dev/null; then
+		echo "$key=\"$value\"" >>$file
+		return
+	fi
+
+	/usr/bin/sed -i '' "s+^\s*$key\s*=.*+$key=\"$value\"+" $file
+}
+
+#
+# Presumes a mounted USB key.
+#
+function usb_key_disable_ipxe()
+{
+	local readonly mnt=/mnt/$(svcprop -p "joyentfs/usb_mountpoint" \
+	    "svc:/system/filesystem/smartdc:default")
+	local readonly dev=$(mount | nawk "\$0~\"^$mnt\" { print \$3 ; }")
+	local readonly dsk=${dev%[ps]?}
+	local readonly version=$(usb_key_version ${dsk}p0)
+
+	case $version in
+	1)
+		sed -i '' "s/^default.*/default 1/" $mnt/boot/grub/menu.lst.tmpl
+		if [[ -f $mnt/boot/grub/menu.lst ]]; then
+			sed -i '' "s/^default.*/default 1/" \
+			    $mnt/boot/grub/menu.lst
+		fi
+		;;
+	2)
+		edit_param $mnt/boot/loader.conf ipxe "false"
+		;;
+	*) echo "unknown USB key version $version" >&2; return 1 ;;
+	esac
+}
+
+#
+# This only sets os_console. Presumes a mounted USB key.
+#
+function usb_key_set_console()
+{
+	local readonly mnt=/mnt/$(svcprop -p "joyentfs/usb_mountpoint" \
+	    "svc:/system/filesystem/smartdc:default")
+	local readonly dev=$(mount | nawk "\$0~\"^$mnt\" { print \$3 ; }")
+	local readonly dsk=${dev%[ps]?}
+	local readonly version=$(usb_key_version ${dsk}p0)
+	local readonly console=$1
+
+	case $version in
+	1)
+		sed -i '' "s/^variable os_console.*/variable os_console ${console}/" \
+		    $mnt/boot/grub/menu.lst.tmpl
+		if [[ -f $mnt/boot/grub/menu.lst ]]; then
+			sed -i '' "s/^variable os_console.*/variable os_console ${console}/" \
+			    $mnt/boot/grub/menu.lst
+		fi
+		;;
+	2)
+		edit_param $mnt/boot/loader.conf os_console "$console"
+		;;
+	*) echo "unknown USB key version $version" >&2; return 1 ;;
+	esac
+}
diff --git a/overlay/generic/lib/svc/method/fs-joyent b/overlay/generic/lib/svc/method/fs-joyent
index 11df1d5e..9082f22e 100755
--- a/overlay/generic/lib/svc/method/fs-joyent
+++ b/overlay/generic/lib/svc/method/fs-joyent
@@ -24,6 +24,7 @@ fatal()
 
 . /lib/svc/share/smf_include.sh
 . /lib/svc/share/fs_include.sh
+. /lib/sdc/usb-key.sh
 
 # first of all, if we aren't the global zone this doesn't make any sense to run
 
@@ -107,7 +108,7 @@ if [ $? -ne 0 ]; then
     # A machine is reset to its original unsetup state (i.e. a 'factory reset')
     # when the smartdc:factoryreset ZFS user property is set on the var dataset.
     reset=$(zfs get -H -o value smartdc:factoryreset ${SYS_ZPOOL}/var)
-    if [ ${reset} == "yes" ]; then
+    if [ "${reset}" == "yes" ]; then
         destroy_zpools
     fi
 
@@ -218,12 +219,9 @@ if [ -d /var/upgrade_in_progress ]; then
     exit $SMF_EXIT_ERR_FATAL
 fi
 
-USBMOUNTPOINT=/mnt/`svcprop -p "joyentfs/usb_mountpoint" ${SMF_FMRI}`
 COPYINPOINT=`svcprop -p "joyentfs/usb_copy_path" ${SMF_FMRI}`
 DEBUG=`svcprop -p "joyentfs/debug" ${SMF_FMRI}`
 
-mount_usb_msg=""
-
 if [[ -d /mnt ]]; then
     chown root:root /mnt
     chmod 700 /mnt
@@ -260,7 +258,7 @@ function make_usb_copy_if_possible
     mkdir ${COPYINPOINT}
     mount_zfs ${USBDATASET} ${COPYINPOINT}
 
-    $(cd ${USBMOUNTPOINT}; rsync -av --log-file=/dev/console --exclude private --exclude os * ${COPYINPOINT})
+    (cd ${USBMOUNTPOINT}; rsync -av --log-file=/dev/console --exclude private --exclude os * ${COPYINPOINT})
     if [[ -d ${USBMOUNTPOINT}/os ]]; then
         (cd ${USBMOUNTPOINT}/os ; \
             for dir in $(ls -d *); do
@@ -281,72 +279,10 @@ function make_usb_copy_if_possible
     return 0
 }
 
-mkdir -p ${USBMOUNTPOINT}
-
-if [[ -f "${USBMOUNTPOINT}/.joyliveusb" ]]; then
-    mount_usb_msg="already mounted"
-    make_usb_copy_if_possible
-    exit $?
-fi
-
-# First thing to do is to mount the USB key / VMWare disk
-USBKEYS=`/usr/bin/disklist -a`
-for key in ${USBKEYS}; do
-    if [[ `/usr/sbin/fstyp /dev/dsk/${key}p0:1` == 'pcfs' ]]; then
-        /usr/sbin/mount -F pcfs -o foldcase,noatime /dev/dsk/${key}p0:1 \
-            ${USBMOUNTPOINT};
-        if [[ $? == "0" ]]; then
-            if [[ ! -f ${USBMOUNTPOINT}/.joyliveusb ]]; then
-                if [[ ${DEBUG} == "true" ]]; then
-                    mount_usb_msg="${mount_usb_msg}\n[debug] didn't find ${USBMOUNTPOINT}/.joyliveusb on pcfs /dev/dsk/${key}p0:1"
-                fi
-                /usr/sbin/umount ${USBMOUNTPOINT};
-            else
-                if [[ ${DEBUG} == "true" ]]; then
-                    mount_usb_msg="${mount_usb_msg}\n[debug] found ${USBMOUNTPOINT}/.joyliveusb on pcfs /dev/dsk/${key}p0:1"
-                fi
-                break;
-            fi
-        elif [[ ${DEBUG} == "true" ]]; then
-            mount_usb_msg="${mount_usb_msg}\n[debug] mount failed for pcfs /dev/dsk/${key}p0:1"
-        fi
-    elif [[ ${DEBUG} == "true" ]]; then
-        mount_usb_msg="${mount_usb_msg}\n[debug] /dev/dsk/${key}p0:1 is not pcfs"
-    fi
-done
-
-if [[ ! -f "${USBMOUNTPOINT}/.joyliveusb" ]]; then
-    # we're probably VMWare, so we're looking at a non-USB disk.
-    for disk in `/usr/bin/disklist -a`; do
-        if [[ `/usr/sbin/fstyp /dev/dsk/${disk}p1` == 'pcfs' ]]; then
-            /usr/sbin/mount -F pcfs -o foldcase,noatime /dev/dsk/${disk}p1 \
-                ${USBMOUNTPOINT};
-            if [[ $? == "0" ]]; then
-                if [[ ! -f ${USBMOUNTPOINT}/.joyliveusb ]]; then
-                    if [[ ${DEBUG} == "true" ]]; then
-                        mount_usb_msg="${mount_usb_msg}\n[debug] didn't find ${USBMOUNTPOINT}/.joyliveusb on pcfs /dev/dsk/${disk}p1"
-                    fi
-                    /usr/sbin/umount ${USBMOUNTPOINT};
-                else
-                    if [[ ${DEBUG} == "true" ]]; then
-                        mount_usb_msg="${mount_usb_msg}\n[debug] found ${USBMOUNTPOINT}/.joyliveusb on pcfs /dev/dsk/${disk}p1"
-                    fi
-                    break;
-                fi
-            elif [[ ${DEBUG} == "true" ]]; then
-                mount_usb_msg="${mount_usb_msg}\n[debug] unable to mount /dev/dsk/${disk}p1"
-            fi
-        elif [[ ${DEBUG} == "true" ]]; then
-            mount_usb_msg="${mount_usb_msg}\n[debug] /dev/dsk/${disk}p1 is not pcfs"
-        fi
-    done
-fi
-
-if [[ -f "${USBMOUNTPOINT}/.joyliveusb" ]]; then
-    mount_usb_msg="success"
-    make_usb_copy_if_possible
-    exit $?
+USBMOUNTPOINT=$(mount_usb_key "")
+if [[ $? -ne 0 ]]; then
+    fatal "couldn't mount USB key"
 fi
 
-mount_usb_msg="${mount_usb_msg}\n[FATAL] mount_usb(): could not find USB Key"
-exit 1;
+make_usb_copy_if_possible
+exit $?
diff --git a/overlay/generic/lib/svc/method/smartdc-init b/overlay/generic/lib/svc/method/smartdc-init
index 81b6b526..1b2a5500 100755
--- a/overlay/generic/lib/svc/method/smartdc-init
+++ b/overlay/generic/lib/svc/method/smartdc-init
@@ -11,7 +11,7 @@
 #
 
 #
-# Copyright 2016 Joyent, Inc.
+# Copyright (c) 2018, Joyent, Inc.
 #
 
 export PS4='[\D{%FT%TZ}] ${BASH_SOURCE}:${LINENO}: ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
@@ -42,26 +42,6 @@ wait_and_clear()
     done
 }
 
-create_setup_status()
-{
-    [[ -e /var/lib/setup.json ]] && rm -f /var/lib/setup.json
-    echo "{" \
-	"\"node_type\": \"computenode\"," \
-	"\"start_time\": \"$(date "+%Y-%m-%dT%H:%M:%SZ")\"," \
-	"\"current_state\": \"setup_complete\"," \
-	"\"seen_states\": [" \
-	"\"zpool_created\"," \
-	"\"filesystems_setup\"," \
-	"\"agents_installed\"," \
-	"\"upgrade_complete\"," \
-	"\"setup_complete\"" \
-	"]," \
-	"\"complete\": true," \
-	"\"last_updated\": \"$(date "+%Y-%m-%dT%H:%M:%SZ")\"" \
-	"}" >/var/lib/setup.json
-    chmod 400 /var/lib/setup.json
-}
-
 # Sets the default firewall rules for a node (unless they're already set)
 set_default_fw_rules() {
     local fw_default_v
@@ -111,107 +91,6 @@ RULES
     fi
 }
 
-# This process is execessively complex but if not done carefully we can wedge
-# with svcs in maintenance.  We start by removing all but the agents_core.
-# Sometimes this leaves one or more agents still installed, so we do it again.
-# Finally we remove the agents_core (which should be the only thing left) and
-# then clean up the dirs so new agents will install into a fresh environment.
-# The wait_and_clear function is used to watch for svcs goint into maintenance
-# during this process and clear them so that the agent uninstall can continue.
-uninstall_agents6()
-{
-    echo "Removing the old agents..." > /dev/console
-
-    local AGENTS_DIR=/opt/smartdc/agents
-
-    local agent=
-    local TOREMOVE=`/opt/smartdc/agents/bin/agents-npm --no-registry \
-        ls installed 2>/dev/null | nawk '{print $1}'`
-    for agent in $TOREMOVE
-    do
-        (echo "$agent" | egrep -s '^atropos@') && continue
-        # We have to do agents_core after the others
-        (echo "$agent" | egrep -s '^agents_core@') && continue
-
-        # Supress possible npm warning removing CA (See AGENT-392)
-        if (echo "$agent" | egrep -s '^cainstsvc'); then
-            [ -e $AGENTS_DIR/smf/cainstsvc-default.xml ] && \
-                touch $AGENTS_DIR/smf/cainstsvc.xml
-        fi
-
-        echo "Uninstall: $agent"
-        /opt/smartdc/agents/bin/agents-npm uninstall $agent &
-        wait_and_clear
-    done
-
-    TOREMOVE=`/opt/smartdc/agents/bin/agents-npm --no-registry ls installed \
-        2>/dev/null | nawk '{print $1}'`
-    for agent in $TOREMOVE
-    do
-        (echo "$agent" | egrep -s '^atropos@') && continue
-        # We have to do agents_core after the others
-        (echo "$agent" | egrep -s '^agents_core@') && continue
-
-        echo "Uninstall: $agent"
-        /opt/smartdc/agents/bin/agents-npm uninstall $agent &
-        wait_and_clear
-    done
-
-    TOREMOVE=`/opt/smartdc/agents/bin/agents-npm --no-registry ls installed \
-        2>/dev/null | nawk '{print $1}'`
-    for agent in $TOREMOVE
-    do
-        (echo "$agent" | egrep -s '^atropos@') && continue
-
-        echo "Uninstall: $agent"
-        /opt/smartdc/agents/bin/agents-npm uninstall $agent &
-        wait_and_clear
-    done
-
-    for dir in $(ls "$AGENTS_DIR"); do
-        case "$dir" in
-        db|smf) continue ;;
-        *)      rm -fr $AGENTS_DIR/$dir ;;
-        esac
-    done
-
-    rm -rf $AGENTS_DIR/smf/*
-}
-
-install_agents7()
-{
-    echo "Installing the new agents..." > /dev/console
-
-    # Note: the preceeding call to install_config has called load_sdc_config
-
-    rm -f /var/tmp/agents_latest.sh
-    curl -k -o /var/tmp/agents_latest.sh \
-        -s "http://${CONFIG_assets_admin_ip}/extra/agents/latest"
-
-    [[ ! -f /var/tmp/agents_latest.sh ]] && return 1
-    (cd /var/tmp; bash /var/tmp/agents_latest.sh)
-    rm -f /var/tmp/agents_latest.sh
-    return 0
-}
-
-configure_imgadm()
-{
-    if [[ ! -f /var/imgadm/imgadm.conf ]]; then
-        mkdir -p /var/imgadm
-        echo '{}' > /var/imgadm/imgadm.conf
-    fi
-    if [[ -z "$(json -f /var/imgadm/imgadm.conf sources)" ]]; then
-        # re-load config
-        load_sdc_config
-
-        imgadm sources -f -a http://$CONFIG_imgapi_domain
-        # remove the default
-        imgadm sources -f -d https://images.joyent.com
-    fi
-
-    imgadm update
-}
-
 configure_fwadm()
 {
     if [[ ! -d /var/log/fw/logs ]]; then
@@ -304,96 +183,6 @@ install_config()
     fi
 }
 
-# If the CN has a local USB key, make sure its setup for universal booting
-update_local_key()
-{
-    local key=`diskinfo -H | nawk -F\t '{
-        if ($1 == "USB" && $6 == "yes" && $7 == "no") print $2}'`
-    local nkeys=`echo $key | wc -w`
-    [ $nkeys -ne 1 ] && return
-
-    curl -k -o /var/tmp/cnkey.tgz -f -s \
-        "http://${CONFIG_assets_admin_ip}/extra/usbkey/cnkey.tgz"
-    [ ! -f /var/tmp/cnkey.tgz ] && return
-
-    local console=$(bootparams | grep ^console= | cut -d= -f2)
-    [ -z "$console" ] && console=text
-
-    local kmnt=/mnt/usbkey
-    mkdir -p $kmnt
-    mount -F pcfs -o noatime /dev/dsk/${key}p0:1 $kmnt
-    if [[ $? == 0 ]]; then
-        if [[ -d $kmnt/dos && -f $kmnt/boot/grub/menu.lst &&
-            -f $kmnt/boot/ipxe.lkrn ]]; then
-            # already setup
-
-            # Ensure grub timeout is 5 secs for CNs and console is correct
-            sed -e "s/^variable os_console.*/variable os_console ${console}/" \
-                -e "s/^timeout.*/timeout 5/" \
-                < $kmnt/boot/grub/menu.lst > $kmnt/boot/grub/menu.lst.$$
-            mv -f $kmnt/boot/grub/menu.lst.$$ $kmnt/boot/grub/menu.lst
-
-            umount $kmnt
-            rm -f /var/tmp/cnkey.tgz
-            return
-        fi
-        # cleanup in preparation for new image
-        rm -rf $kmnt/* $kmnt/.[a-zA_Z]
-    else
-        # Key in an unknown state, clear it and set it up
-
-        # First clear label since fdisk -g fails on a labeled disk
-        dd if=/dev/zero of=/dev/rdsk/${key}p0 count=2
-
-        nsect=`fdisk -g /dev/rdsk/${key}p0 | nawk '{
-            if ($1 == "*") next; print $1 * $5 * $6 }'`
-        printf "12 128 0 0 0 0 0 0 4096 %d\n" $nsect >/tmp/fdisk.in
-        fdisk -F /tmp/fdisk.in /dev/rdsk/${key}p0
-
-        # Need temp copy of files for grub stage1
-        mkdir /var/tmp/key$$
-        (cd /var/tmp/key$$; gzcat /var/tmp/cnkey.tgz | tar xf -)
-
-        echo "y" | mkfs -F pcfs \
-            -o B=/var/tmp/key$$/boot/grub/stage1,fat=32 /dev/rdsk/${key}p0:c
-        mount -F pcfs -o noatime /dev/dsk/${key}p0:c $kmnt
-        if [[ $? != 0 ]]; then
-            rm -f /var/tmp/cnkey.tgz
-            rm -rf /var/tmp/key$$
-            return
-        fi
-        rm -rf /var/tmp/key$$
-    fi
-
-    # install new files
-    (cd $kmnt; gzcat /var/tmp/cnkey.tgz | tar xf -)
-    rm -f /var/tmp/cnkey.tgz
-
-    # setup CN boot menu
-    cat <<-MENU_DONE >$kmnt/boot/grub/menu.lst
-	default 0
-	timeout 5
-	min_mem64 1024
-	serial --speed=115200 --unit=1 --word=8 --parity=no --stop=1
-	terminal composite
-	variable os_console $console
-
-	title Compute Node (PXE)
-	kernel /boot/ipxe.lkrn
-
-	title Legacy Firmware Upgrade Mode
-	kernel$ /boot/memdisk console=\${os_console}
-	module /boot/freedos.img raw
-	MENU_DONE
-
-    umount $kmnt
-
-    # Always install stage1.5 since we don't know if key was bootable
-    printf "(hd0) %s\n" /dev/dsk/${key}p0 >/tmp/grub.map
-    printf "root (hd0,0)\nsetup (hd0)\n" | \
-        TERM=xterm grub --device-map=/tmp/grub.map
-}
-
 case "$1" in
 'start')
 
@@ -435,61 +224,6 @@ case "$1" in
         set_default_fw_rules
     else
 	install_config
-
-        # If this CN was running 6.5.x and has now been booted onto 7.0, we
-        # need to uninstall the old 6.5.x agents and install the new 7.0 agents.
-        if [[ -d /opt/smartdc/agents/modules && \
-            ! -d  /opt/smartdc/agents/lib ]]; then
-
-	    # During upgrade (or even before) we know the config file should
-	    # have been upgraded to include the imgapi_domain entry. If that
-	    # didn't happen, fail now.
-	    egrep -s imgapi_domain /opt/smartdc/config/node.config
-	    if [ $? -ne 0 ]; then
-                echo "ERROR: the local config file was not updated for upgrade."
-                exit $SMF_EXIT_ERR_FATAL
-	    fi
-
-            # Enable new ZFS features. The pool will no longer be usable on 6.5
-            zpool set feature@async_destroy=enabled zones
-            zpool set feature@empty_bpobj=enabled zones
-            zpool set feature@lz4_compress=enabled zones
-
-            # Convert to 7.0-style cores datasets
-            zfs destroy -r zones/cores
-            zfs create -o compression=lz4 -o mountpoint=none zones/cores
-            for i in `zoneadm list -c`
-            do
-                zfs destroy -rf zones/$i/cores
-                zfs create -o quota=100g -o mountpoint=/zones/$i/cores \
-                    zones/cores/$i
-            done
-
-            echo "Upgrading the system's agents" > /dev/console
-
-	    # disable the smartdc agent svcs
-	    echo "stopping svcs"
-	    for i in `svcs -a | nawk '/smartdc\/agent/{print $3}'`
-	    do
-		[[ "$i" == "svc:/smartdc/agent/ur:default" || \
-		   "$i" == "svc:/smartdc/agent/metadata:default" ]] && \
-		    continue
-		svcadm disable $i
-	    done
-
-            uninstall_agents6
-            install_agents7
-
-            create_setup_status
-            sysinfo -u
-            rm -f /tmp/.ur-startup
-            svcadm restart ur
-
-            update_local_key
-            configure_imgadm
-
-            echo "Upgrade done" > /dev/console
-        fi
     fi
 
     configure_fwadm
diff --git a/overlay/generic/manifest b/overlay/generic/manifest
index ebc1a35c..2bf722f6 100644
--- a/overlay/generic/manifest
+++ b/overlay/generic/manifest
@@ -1,4 +1,6 @@
 f .smartdc_version 0444 root root
+d boot/forth 0755 root root
+f boot/forth/menu.rc 0444 root root
 d etc/bash 0755 root sys
 f etc/bash/bash_completion 0644 root sys
 d etc/bash/bash_completion.d 0755 root sys
@@ -64,6 +66,7 @@ f kernel/drv/mpt_sas.conf 0644 root sys
 f kernel/drv/sd.conf 0644 root sys
 d lib/sdc 0755 root bin
 f lib/sdc/config.sh 0444 root bin
+f lib/sdc/usb-key.sh 0444 root bin
 f lib/sdc/network.sh 0444 root bin
 f lib/sdc/zone.sh 0444 root bin
 d lib/svc 0755 root bin
diff --git a/src/nictagadm b/src/nictagadm
index 92a626ed..8c2e9d91 100755
--- a/src/nictagadm
+++ b/src/nictagadm
@@ -11,7 +11,7 @@
 #
 
 #
-# Copyright (c) 2016 Joyent, Inc. All rights reserved.
+# Copyright (c) 2018, Joyent, Inc.
 #
 
 #
@@ -20,6 +20,7 @@
 
 PATH=/usr/bin:/usr/sbin
 . /lib/sdc/config.sh
+. /lib/sdc/usb-key.sh
 
 CMD=
 CONF=
@@ -309,25 +310,7 @@ function mount_usb()
         return 0
     fi
 
-    USBKEYS=$(disklist -a)
-    for key in $USBKEYS; do
-        if [[ $(fstyp "/dev/dsk/${key}p0:1") == 'pcfs' ]]; then
-            mount -F pcfs -o foldcase,noatime "/dev/dsk/${key}p0:1" "$USB_MNT"
-            if (( $? == 0 )); then
-                if [[ ! -f $USB_MNT/.joyliveusb ]]; then
-                    umount "$USB_MNT"
-                else
-                    break
-                fi
-            fi
-        fi
-    done
-
-    typ=$(awk -v "mnt=$USB_MNT" '$2 == mnt { print $3 }' /etc/mnttab)
-    if [[ -z $typ ]]; then
-        verbose "Could not mount $USB_MNT"
-        return 0
-    fi
+    mount_usb_key || fatal 'failed to mount USB key'
 
     if [[ ! -f $USB_CONFIG ]]; then
         verbose "$USB_CONFIG does not exist"
@@ -354,13 +337,7 @@ function umount_usb()
         return 0
     fi
 
-    typ=$(awk -v "mnt=$USB_MNT" '$2 == mnt { print $3 }' /etc/mnttab)
-    if [[ -z $typ ]]; then
-        verbose "USB key no longer mounted: not unmounting"
-        return 0
-    fi
-
-    umount "$USB_MNT"
+    unmount_usb_key || fatal 'failed to unmount USB key'
 }
 
 
diff --git a/tools/build_boot_image b/tools/build_boot_image
new file mode 100755
index 00000000..b1189d9c
--- /dev/null
+++ b/tools/build_boot_image
@@ -0,0 +1,422 @@
+#!/bin/bash
+#
+# This file and its contents are supplied under the terms of the
+# Common Development and Distribution License ("CDDL"), version 1.0.
+# You may only use this file in accordance with the terms of version
+# 1.0 of the CDDL.
+#
+# A full copy of the text of the CDDL should have accompanied this
+# source.  A copy of the CDDL is also available via the Internet at
+# http://www.illumos.org/license/CDDL.
+#
+
+#
+# Copyright (c) 2018, Joyent, Inc.
+#
+
+#
+# This script automates the process of building ISO and USB images of a SmartOS
+# build.  It can also be used to produce the proforma disk images used by the
+# tools in sdc-headnode.git to produce Triton USB and COAL images.  When
+# building SmartOS media, it uses the latest platform file that's been built.
+# This program can be invoked standalone via the "gmake iso", "gmake usb" and
+# "gmake images" targets of the top-level Makefile in "smartos-live.git".
+#
+# This script needs to be run either as root or as a user that is granted the
+# "Primary Administrator" profile.  When run in a non-global zone, it must be
+# configured with "fs_allowed=ufs,pcfs".
+#
+# Things are complicated here by the fact that we would like to run inside a
+# non-global zone with older kernels.  Most of our partitioning tools such as
+# format do not run well inside a non-global zone, and labeled lofi doesn't
+# have sufficient support either.  So we delegate the tricky bits to
+# format_image.
+#
+# Equally, we can no longer directly mount the root partition for populating:
+# pcfs has no logic of its own for parsing GPT partitions.  So we have to play
+# games using dd(1) to copy the root FS image into the right place based on
+# its partition offset.  We also place the partition layout into the images
+# tarball, so sdc-headnode can do the same.  (As it is, the offset is actually
+# fixed, but that seems like a bad thing to rely on.)
+#
+
+bi_console="text"
+bi_make_iso=0
+bi_proforma_only=0
+bi_ufs_root=0
+bi_nocleanup=0
+bi_imgsz_gb="2"
+bi_imgsz=$(( $bi_imgsz_gb * 1000000000 ))
+bi_wsroot=
+lofi_blkdev=
+lofi_rawdev=
+esp_blkdev=
+usb_image_name=
+rootdir=
+efimnt=
+tmpdir=
+
+function detach_lofi()
+{
+	local readonly dev=$1
+
+	if [[ -z "$dev" ]]; then
+		return
+	fi
+
+	if pfexec lofiadm $dev 2>/dev/null; then
+		print "Detaching LOFI device $dev ... \c"
+		pfexec lofiadm -d $dev
+		print "done"
+	fi
+}
+
+function cleanup()
+{
+	[[ $bi_nocleanup == 1 ]] && return
+
+	print "Cleaning up"
+
+	if mount | grep $efimnt >/dev/null; then
+		pfexec umount $efimnt
+	fi
+
+	if mount | grep $rootdir >/dev/null; then
+		pfexec umount $rootdir
+	fi
+
+	detach_lofi "$lofi_blkdev"
+	detach_lofi "$esp_blkdev"
+
+	pfexec rm -f $tmpdir/esp.img
+	pfexec rm -f $tmpdir/rootfs.img
+	pfexec rm -f $tmpdir/smartos.usb
+	pfexec rm -f $tmpdir/partition.map
+	pfexec rm -rf $tmpdir/mnt
+	pfexec rmdir $tmpdir
+}
+
+function fail()
+{
+        printf "$0: %s\n" "$1" 1>&2
+        exit 1
+}
+
+function usage()
+{
+	[[ ! -z $1 ]] && printf "%s\n\n" "$1" 1>&2
+
+	print -u2 "Usage: $0 [-U] [-I] [-x] [-c console] " \
+	    "[-p <size>] -r <smartos-live repo>"
+	print -u2 "\n -U\tcreate UFS filesystem on root partition (default: PCFS)"
+	print -u2 " -I\tbuild SmartOS ISO image (default: USB image)"
+	print -u2 " -c\tspecify primary console (e.g. ttyb)"
+	print -u2 " -p\tbuild proforma USB image for Triton (e.g. 1gb)"
+	print -u2 " -x\tdon't cleanup on exit (for debugging use)\n"
+	exit 2
+}
+
+function pfrun()
+{
+	pfexec $*
+	local status=$?
+
+	if [[ $status != 0 ]]; then
+		print -u2 "\nCommand failed: $*\nExit status: $status"
+		exit 1
+	fi
+}
+
+#
+# Construct the EFI System Partition (ESP) image,  We size it at 256 MB, which
+# is intentionally much larger than what we need currently, in order to leave
+# headroom for future projects which may need to store data in the ESP.
+#
+function create_esp()
+{
+	local readonly tmpdir=$1
+	local readonly efimnt=$2
+	local readonly esp_size=256 # MiB
+	local readonly esp_sects=$(( $esp_size * 1024 * 1024 / 512 ))
+
+	pfrun mkfile -n ${esp_size}m $tmpdir/esp.img
+	esp_blkdev=$(pfexec lofiadm -a $tmpdir/esp.img)
+	[[ $? == 0 ]] || fail "Failed to create ESP lofi device"
+	readonly esp_rawdev=${esp_blkdev/lofi/rlofi}
+
+	pfrun mkfs -F pcfs -o b=system,size=$esp_sects,nofdisk,fat=32 \
+	    $esp_rawdev </dev/null
+
+	pfrun mkdir -p $efimnt
+	pfrun mount -F pcfs -o foldcase $esp_blkdev $efimnt
+	pfrun mkdir -p $efimnt/efi/boot
+	pfrun cp $bi_wsroot/proto.boot/boot/loader64.efi \
+	    $efimnt/efi/boot/bootx64.efi
+	pfrun umount $efimnt
+	pfrun lofiadm -d $esp_blkdev
+}
+
+#
+# Populate the root filesystem with all the SmartOS bits, as well as the loader
+# used in legacy boot mode.
+#
+function populate_root()
+{
+	local readonly dir=$1
+
+	print "Installing boot tarball onto root partition ... \c"
+	pfexec cp -r $bi_wsroot/proto.boot/* $dir/
+	print "done"
+
+	print "Customizing boot loader configuration ... \c"
+	readonly shadow="'\$5\$2HOHRnK3\$NvLlm.1KQBbB0WjoP7xcIwGnllhzp2HnT.mDO7DpxYA'"
+
+	case "$bi_console" in
+	text)	console="text" ;;
+	tty*)	console="$bi_console,text" ;;
+	*)	echo "unknown console $bi_console" 2>&1
+		exit 1 ;;
+	esac
+
+	pfrun touch $dir/boot/loader.conf
+	pfrun chmod 644 $dir/boot/loader.conf
+	pfrun cat <<EOF >$dir/boot/loader.conf
+console="$console"
+os_console="$bi_console"
+ttya-mode="115200,8,n,1,-"
+ttyb-mode="115200,8,n,1,-"
+ttyc-mode="115200,8,n,1,-"
+ttyd-mode="115200,8,n,1,-"
+loader_logo="smartos"
+loader_brand="smartos"
+root_shadow="${shadow}"
+smartos="true"
+EOF
+	print "done"
+
+	print "Copying platform image to root partition" \
+	    "(this will take a while) ... \c"
+
+	pfexec cp -r $bi_wsroot/output/platform-latest/ $dir/platform
+
+	print "done"
+}
+
+#
+# Build our actual ISO image
+#
+function create_iso()
+{
+	local readonly tmpdir=$1
+	local readonly iso=$2
+	local readonly espimg=$3
+
+	pfrun mkdir -p $bi_wsroot/output-iso
+	pfrun mkdir -p $rootdir
+
+	populate_root $rootdir
+
+	pfrun cp $bi_wsroot/proto/boot/cdboot $rootdir/boot/cdboot
+	pfrun cp $espimg $rootdir/boot/efiboot.img
+
+	pfrun mkisofs -quiet -R \
+	    -eltorito-boot boot/cdboot -no-emul-boot -boot-info-table \
+	    -eltorito-alt-boot -eltorito-platform efi \
+	    -eltorito-boot boot/efiboot.img -no-emul-boot \
+	    -o $iso $rootdir
+
+	print "Successfully created $iso"
+}
+
+#
+# Assemble all our boot parts into the disk image (the root partition is copied
+# over later).
+#
+function create_image()
+{
+	local readonly tmpdir=$1
+	local readonly size=$2
+	local readonly file=$3
+
+	pfrun mkfile -n $size $file
+
+	lofi_blkdev=$(pfexec lofiadm -a $file)
+	[[ $? == 0 ]] || fail "Failed to create lofi device"
+
+	pfrun $bi_wsroot/tools/format_image/format_image \
+	    -m $bi_wsroot/proto.boot/boot/pmbr \
+	    -b $bi_wsroot/proto.boot/boot/gptzfsboot -e $tmpdir/esp.img \
+	    -o ${lofi_blkdev/lofi/rlofi} >$tmpdir/partition.map
+
+	pfrun lofiadm -d $lofi_blkdev
+}
+
+#
+# Create the blank root filesystem.
+#
+function create_root()
+{
+	local readonly dev=$1
+	local readonly image=$2
+	local readonly offset=$3
+	local readonly sects=$(( $4 / 512 ))
+
+	if [[ $bi_ufs_root == 1 ]]; then
+		print "Creating UFS filesystem in root partition ... \c"
+		pfexec newfs $dev </dev/null
+	else
+		print "Creating PCFS filesystem in root partition ... \c"
+		pfrun mkfs -F pcfs -o b=SMARTOSBOOT,size=$sects,nofdisk,fat=32 \
+		    $dev </dev/null
+	fi
+
+	print "done"
+
+	if [[ $bi_proforma_only == 1 ]]; then
+		return
+	fi
+}
+
+#
+# Copy the root filesystem image into the correct place inside the image.
+#
+function copy_root()
+{
+	local readonly dev=$1
+	local readonly image=$2
+	local readonly offset=$3
+	local readonly bs=1048576
+
+	print "Copying root filesystem ..."
+	pfrun /usr/bin/dd bs=$bs conv=notrunc if=$dev of=$image \
+	    oseek=$(( $offset / $bs )) >/dev/null
+	print "done"
+}
+
+#
+#
+function mount_root()
+{
+	local readonly dev=$1
+	local readonly rootmnt=$2
+	local mntopts="-F pcfs"
+
+	if [[ $bi_ufs_root == 1 ]]; then
+		mntopts="-o nologging"
+	fi
+
+	print "Mounting root partition at $rootmnt ... \c"
+	pfrun mkdir -p $rootmnt
+	pfrun mount $mntopts $dev $rootmnt 2>/dev/null
+	print "done"
+}
+
+function copy_results()
+{
+	local readonly outdir=$1
+	local readonly outfile=$2
+	local readonly prefix=$3
+	local readonly uid=$(id -u)
+	local readonly gid=$(id -g)
+
+	mkdir -p $outdir
+	pfrun mv $tmpdir/smartos.usb $outdir/$outfile
+	pfrun chmod 644 $outdir/$outfile
+	pfrun chown ${uid}:${gid} $outdir/$outfile
+	pfrun cp $tmpdir/partition.map $outdir/${prefix}partition.map
+	pfrun chown ${uid}:${gid} $outdir/${prefix}partition.map
+	print "Successfully created $outdir/$outfile"
+}
+
+export PATH=/usr/bin/:/usr/sbin/:/opt/local/bin
+
+while getopts "IUc:p:r:x" c $@; do
+	case "$c" in
+	I)	bi_make_iso=1 ;;
+	U)	bi_ufs_root=1 ;;
+	c)	bi_console=${OPTARG} ;;
+	p)	bi_proforma_only=1
+		bi_imgsz_gb=${OPTARG%gb}
+		bi_imgsz=$(( $bi_imgsz_gb * 1000000000 )) ;;
+	r)	bi_wsroot=$(readlink -f $OPTARG) ;;
+	x)	bi_nocleanup=1 ;;
+	:)	usage ;;
+	*)	usage ;;
+	esac
+done
+
+set -eou pipefail
+export SHELLOPTS
+unalias -a
+
+[[ -z "$bi_wsroot" ]] && usage "-r is required"
+
+[[ $bi_proforma_only == 1 ]] && [[ $bi_ufs_root == 1 ]] && \
+    usage "-p and -U are mutually exclusive"
+
+[[ $bi_proforma_only == 1 ]] && [[ $bi_make_iso == 1 ]] && \
+    usage "-p and -I are mutually exclusive"
+
+[[ -e $bi_wsroot/output/platform-latest ]] || \
+    fail "No platform image found in $bi_wsroot/output"
+
+
+tmpdir=$(mktemp -d -p /var/tmp) || fail "mktemp failed!"
+
+trap cleanup EXIT
+
+efimnt=$tmpdir/mnt/efi
+rootdir=$tmpdir/mnt/root
+usb_image_name=$(readlink -f $bi_wsroot/output/platform-latest)
+usb_image_name=$(basename $usb_image_name)
+iso_image_name="$bi_wsroot/output-iso/${usb_image_name}.iso"
+usb_image_name="${usb_image_name}.usb"
+
+print "Creating EFI System Partition image ... \c"
+create_esp $tmpdir $efimnt
+print "done"
+
+if [[  $bi_make_iso == 1 ]]; then
+	create_iso $tmpdir $iso_image_name $tmpdir/esp.img
+	exit 0
+fi
+
+print "Creating $bi_imgsz_gb GB image at $tmpdir/smartos.usb ... \c"
+create_image $tmpdir $bi_imgsz $tmpdir/smartos.usb
+print "done"
+
+echo "partition.map:"
+cat $tmpdir/partition.map
+
+rootoff=$(nawk '$1 == "root" { print $3 }' <$tmpdir/partition.map)
+rootsize=$(nawk '$1 == "root" { print $4 }' <$tmpdir/partition.map)
+
+pfrun mkfile -n $rootsize $tmpdir/rootfs.img
+
+lofi_blkdev=$(pfexec lofiadm -a $tmpdir/rootfs.img)
+[[ $? == 0 ]] || fail "Failed to create lofi device"
+
+lofi_rawdev=${lofi_blkdev/lofi/rlofi}
+
+create_root $lofi_rawdev $tmpdir/smartos.usb $rootoff $rootsize
+
+#
+# The proforma image's root partition is populated by sdc-headnode, not us.
+#
+if [[ $bi_proforma_only != 1 ]]; then
+	mount_root $lofi_blkdev $rootdir
+	populate_root $rootdir
+	pfrun umount $rootdir
+fi
+
+copy_root $lofi_rawdev $tmpdir/smartos.usb $rootoff
+
+pfrun lofiadm -d $lofi_blkdev
+
+if [[ $bi_proforma_only == 1 ]]; then
+	copy_results $bi_wsroot/proto.images ${bi_imgsz_gb}gb.img ${bi_imgsz_gb}gb.
+else
+	copy_results $bi_wsroot/output-usb $usb_image_name ""
+fi
+
+exit 0
diff --git a/tools/build_iso b/tools/build_iso
deleted file mode 100755
index da8e5c56..00000000
--- a/tools/build_iso
+++ /dev/null
@@ -1,392 +0,0 @@
-#!/bin/bash
-#
-# This file and its contents are supplied under the terms of the
-# Common Development and Distribution License ("CDDL"), version 1.0.
-# You may only use this file in accordance with the terms of version
-# 1.0 of the CDDL.
-#
-# A full copy of the text of the CDDL should have accompanied this
-# source.  A copy of the CDDL is also available via the Internet at
-# http://www.illumos.org/license/CDDL.
-#
-
-#
-# Copyright (c) 2017, Joyent, Inc.
-#
-
-#
-# Automates the process of building ISO and USB images of a SmartOS build.  It
-# uses the latest platform file that's been built.  This program should be
-# invoked via the "make iso" and "make usb" targets of the top-level Makefile
-# in "smartos-live.git".
-#
-
-shopt -s xpg_echo
-set -o pipefail
-export PATH=/usr/bin:/opt/local/bin:/usr/sbin
-
-bi_wsroot=$(cd $(dirname $0)/../; pwd)
-bi_arg0=$(basename $0)
-bi_type=${bi_arg0/build_/}
-
-. "${bi_wsroot}/tools/lib/build_common.sh"
-
-bi_grub_dir="proto/boot/grub"
-bi_output_grub_dir="$bi_tmpdir/boot/grub"
-bi_grub_files="stage1 stage2 stage2_eltorito"
-bi_archive_path="i86pc/amd64/boot_archive"
-bi_unix_path="i86pc/kernel/amd64/unix"
-bi_usb_size=2000000000
-bi_grub_optstr=
-bi_console=vga
-bi_grub_unit=
-bi_dont_clean=0
-bi_no_smartos=0
-bi_do_kmdb=
-bi_usbpath=
-bi_tmpusbpath=
-bi_lofidev=
-
-
-function usage
-{
-	local msg="$*"
-	[[ -z "$msg" ]] && echo "$msg"
-	cat <<USAGE >&2
-Usage: $bi_arg0 [ -o options ] [-c dev] [ -k ] [ -m ]
-
-Generate a bootable $bi_type image from the proto area and newest platform directory.
-
-	-o options	Append all the options to every GRUB menu.lst entry
-	-c dev		Set default console to be dev (tty{a,b,c,d} or vga)
-	-k		Don't delete temporary files
-	-m		Default to kmdb
-	-n		Don't build for SmartOS
-	-h		Display this message
-
-USAGE
-	exit 2
-}
-
-function fail_cleanup
-{
-	if [[ x"$bi_lofidev" != x ]]; then
-		#(unmount and) cleanup the lofi device
-		pfexec umount -f ${bi_lofidev}:c
-		pfexec lofiadm -d $bi_lofidev
-	fi
-	# an uncompressed usb file is probably incomplete.  remove it
-	[[ -f $bi_tmpusbpath ]] && rm -f $bi_tmpusbpath
-	[[ -f $bi_usbpath ]] && rm -f $bi_usbpath
-	local msg="$*"
-	[[ -z "$msg" ]] && msg="failed"
-	echo "$bi_arg0: $msg" >&2
-	exit 1
-}
-
-function bi_verif_mkisofs
-{
-	bi_emit_start 'Checking for mkisofs'
-	which mkisofs >/dev/null
-	[[ $? -eq 0 ]] || fail "missing mkisofs"
-	bi_emit_done
-}
-
-function bi_get_build
-{
-	#
-	# The build process updates a "platform-latest" symlink to the
-	# most recently built platform directory.  We use that symlink
-	# to decide which platform to bundle into the ISO or USB image.
-	#
-	bi_emit_start 'Determining platform'
-	if [[ ! -L "${bi_platform_dir}/platform-latest" ]]; then
-		fail '"platform-latest" symlink does not exist'
-	fi
-
-	if ! bi_platform_name=$(/usr/bin/readlink \
-	    "${bi_platform_dir}/platform-latest"); then
-		fail 'failed to read "platform-latest" symlink'
-	fi
-
-	bi_platform="${bi_platform_dir}${bi_platform_name}"
-	if [[ -z "${bi_platform_name}" || ! -d "${bi_platform}" ]]; then
-		fail '"platform-latest" symlink does not point to directory'
-	fi
-
-	bi_emit_done
-	bi_emit_info 'Using platform' "${bi_platform_name}"
-}
-
-#
-# Check to make sure the 64-bit kernel is actually there as a brief sanity check
-#
-function bi_verif_platform
-{
-	bi_emit_start 'Verifying platform'
-	[[ -d $bi_platform ]] || fail "invalid platform directory"
-	[[ -f $bi_platform/$bi_archive_path ]] || fail "missing boot archive"
-	[[ -f $bi_platform/$bi_unix_path ]] || fail "missing kernel image"
-	bi_emit_done
-}
-
-function bi_verif_grub
-{
-	bi_emit_start 'Verifying grub files'
-	if [[ ! -d $bi_grub_dir ]]; then
-		fail "missing /boot/grub from proto area"
-	fi
-	for file in $bi_grub_files; do
-		if [[ ! -f $bi_grub_dir/$file ]]; then
-			fail "file missing from grub proto area: $file"
-		fi
-	done
-	bi_emit_done
-}
-
-function bi_verif_console
-{
-	bi_emit_start 'Verifying console selection'
-	case "$bi_console" in
-	text|graphics|vga)
-		bi_console=vga
-		bi_grub_unit=1,0,2,3
-		;;
-	ttya)
-		bi_grub_unit=0,1,2,3
-		;;
-	ttyb)
-		bi_grub_unit=1,0,2,3
-		;;
-	ttyc)
-		bi_grub_unit=2,1,0,3
-		;;
-	ttyd)
-		bi_grub_unit=3,1,0,2
-		;;
-	*)
-		fail "Invalid console device $bi_console"
-		;;
-	esac
-	bi_emit_done
-}
-
-function bi_generate_usb_file
-{
-	local tmp_free
-
-	if [[ ! -d $bi_output_dir ]]; then
-		mkdir -p $bi_output_dir > /dev/null
-		[[ $? -eq 0 ]] || fail "failed to make output directory"
-	fi
-
-	bi_emit_start 'Generating usb image file'
-	bi_usbpath="$bi_output_dir/$bi_platform_name.usb"
-	bi_tmpusbpath=$bi_usbpath
-
-	tmp_free=$(stat -f -c '%S * %f' $bi_tmpdir | xargs expr)
-	if ((tmp_free >= bi_usb_size + 10000)); then
-		bi_tmpusbpath="$bi_tmpdir/$bi_platform_name.usb"
-	fi
-
-	rm -f $bi_tmpusbpath
-	if ! mkfile -n $bi_usb_size $bi_tmpusbpath; then
-		fail "failed to generate usb file"
-	fi
-	if ! bi_lofidev=$(pfexec lofiadm -a $bi_tmpusbpath); then
-		fail "failed to create lofi device"
-	fi
-	if ! pfexec fdisk -F "$(dirname $0)/usb_fdisk_table" \
-	    "${bi_lofidev/lofi/rlofi}"; then
-		fail "failed to partition ${bi_lofidev/lofi/rlofi}"
-	fi
-	echo "y" | pfexec mkfs -F pcfs -o b=SMARTOSBOOT,fat=32 ${bi_lofidev/lofi/rlofi}:c
-	[[ $? -eq 0 ]] || fail "failed to format the usb image"
-	bi_emit_done
-
-	bi_emit_start 'Mounting usb image file'
-	if ! pfexec mount -F pcfs "${bi_lofidev}:c" "$bi_tmpdir"; then
-		fail "failed to mount usb image"
-	fi
-	bi_emit_done
-}
-
-function bi_copy_contents
-{
-	bi_emit_start 'Copying platform directory'
-	if ! cp -r $bi_platform $bi_tmpdir/platform >/dev/null; then
-		fail "failed to copy platform file"
-	fi
-	bi_emit_done
-
-	bi_emit_start 'Copying grub components'
-	if ! mkdir -p $bi_output_grub_dir; then
-		fail "failed to iso9960 grub output directory"
-	fi
-	for file in $bi_grub_files; do
-		if ! cp $bi_grub_dir/$file $bi_output_grub_dir >/dev/null; then
-			fail "failed to copy grub file: $file"
-		fi
-	done
-	bi_emit_done
-}
-
-function bi_generate_grub_conf
-{
-	if [[ $bi_no_smartos != 1 ]]; then
-		bi_grub_optstr="${bi_grub_optstr},smartos=true"
-	fi
-	local console_settings='console=${os_console},${os_console}-mode="115200,8,n,1,-"'
-	# keep passord and shadow in sync, please
-	local password='root'
-	local shadow='$5$2HOHRnK3$NvLlm.1KQBbB0WjoP7xcIwGnllhzp2HnT.mDO7DpxYA'
-	local default=0
-	[[ -n "$bi_do_kmdb" ]] && default=2
-	bi_emit_start 'Generating grub menu.lst'
-	cat > $bi_output_grub_dir/menu.lst <<EOF
-default=$default
-timeout=10
-min_mem64 1024
-serial --speed=115200 --unit=$bi_grub_unit --word=8 --parity=no --stop=1
-terminal composite
-variable os_console $bi_console
-
-title SmartOS
-   kernel$ /platform/i86pc/kernel/amd64/unix -B $console_settings,root_shadow='$shadow'$bi_grub_optstr
-   module /platform/i86pc/amd64/boot_archive
-
-title SmartOS noinstall/recovery (login/pw: root/$password)
-   kernel$ /platform/i86pc/kernel/amd64/unix -B $console_settings,root_shadow='$shadow',standalone=true,noimport=true
-   module /platform/i86pc/amd64/boot_archive
-
-title SmartOS +kmdb
-   kernel$ /platform/i86pc/kernel/amd64/unix -kd -B $console_settings,root_shadow='$shadow'$bi_grub_optstr
-   module /platform/i86pc/amd64/boot_archive
-EOF
-	[[ $? -eq 0 ]] || fail "failed to create menu.lst"
-	bi_emit_done
-}
-
-function bi_generate_iso
-{
-	local isopath
-
-	if [[ ! -d $bi_output_dir ]]; then
-		if ! mkdir $bi_output_dir > /dev/null; then
-			fail "failed to make output directory"
-		fi
-	fi
-	bi_emit_start 'Generating iso...'
-	isopath="$bi_output_dir/$bi_platform_name.iso"
-	LC_ALL=C mkisofs -R -b 		\
-	    boot/grub/stage2_eltorito	\
-	    -no-emul-boot 		\
-	    -boot-load-size 4		\
-	    -boot-info-table		\
-	    -quiet			\
-	    -o 	$isopath		\
-	    $bi_tmpdir/ >/dev/null
-	[[ $? -eq 0 ]] || fail "Failed to create iso"
-	bi_emit_done
-	bi_emit_info 'ISO output' "$(pwd)/$isopath"
-}
-
-
-function bi_generate_usb
-{
-	# The image file in $bi_tmpdir is hidden by the mounted image contents,
-	# so we have to make it visible again by umounting before grub can be
-	# installed.
-	if ! pfexec umount "${bi_lofidev}:c"; then
-		fail "failed to unmount ${bi_lofidev}:c"
-	fi
-	if ! pfexec lofiadm -d $bi_lofidev; then
-		fail "failed to remove lofi device $bi_lofidev"
-	fi
-	bi_lofidev= #unset that variable so fail won't try to clean it up again
-
-	bi_emit_start 'Installing grub'
-	bi_emit_newline
-	grub --batch <<____ENDOFGRUBCOMMANDS
-device (hd0) $bi_tmpusbpath
-root (hd0,0)
-setup (hd0)
-quit
-____ENDOFGRUBCOMMANDS
-	[[ $? -eq 0 ]] || fail "failed to install grub"
-	bi_emit_done
-
-	bi_emit_start 'Compressing usb image'
-	[[ -f ${bi_usbpath}.bz2 ]] && rm ${bi_usbpath}.bz2
-	if ! pbzip2 -c $bi_tmpusbpath > ${bi_usbpath}.bz2; then
-		fail "failed to compress $bi_usbpath"
-	fi
-	rm -f $bi_tmpusbpath
-	bi_emit_done
-	bi_emit_info 'USB Output' "$(pwd)/${bi_usbpath}.bz2"
-}
-
-while getopts "kmo:nhc:" c $@; do
-	case "$c" in
-	o)
-		bi_emit_info \
-		    "Building $bi_type image with additional options:" \
-		    "$OPTARG"
-		bi_grub_optstr=",$OPTARG"
-		;;
-	c)
-		bi_console="$OPTARG"
-		;;
-	k)
-		bi_dont_clean=1
-		;;
-	m)
-		bi_do_kmdb=1
-		;;
-	n)
-		bi_no_smartos=1
-		;;
-	h)
-		usage
-		;;
-	:)
-		usage "missing required argument -- $OPTARG"
-		;;
-	*)
-		usage "invalid option: $OPTARG"
-		;;
-	esac
-done
-
-bi_big_banner "Building \"$bi_type\" image"
-
-#
-# Get us to the root of the workspace
-#
-if ! cd ${bi_wsroot}; then
-	fail "could not chdir to workspace root \"${bi_wsroot}\""
-fi
-
-case "$bi_type" in
-	iso)
-		bi_verif_mkisofs
-		;;
-	usb)
-		;;
-esac
-bi_verif_grub
-bi_verif_console
-bi_get_build
-bi_verif_platform
-bi_setup_work_dir
-bi_copy_contents
-bi_generate_grub_conf
-case "$bi_type" in
-	iso)
-		bi_generate_iso
-		;;
-	usb)
-		bi_generate_usb
-		;;
-esac
-bi_cleanup_work_dir
diff --git a/tools/build_live b/tools/build_live
index 022d134c..816c3a6b 100755
--- a/tools/build_live
+++ b/tools/build_live
@@ -732,6 +732,15 @@ function bi_finish_archive
 		fail "could not store hash of boot_archive in output directory"
 	fi
 
+	version_dir="$bi_out_dir/$bi_prefix/etc/version"
+	if ! /usr/bin/mkdir -p "$version_dir"; then
+		fail "could not create \"$version_dir\""
+	fi
+
+	if ! printf '%s\n' "$bi_buildstamp" >"$version_dir/platform"; then
+		fail "could not store buildstamp in platform tarball"
+	fi
+
 	if ! printf '%s\n' "$bi_buildstamp" >"$bi_out_dir/buildstamp"; then
 		fail "could not store buildstamp in output directory"
 	fi
diff --git a/tools/build_usb b/tools/build_usb
deleted file mode 120000
index a3116dfa..00000000
--- a/tools/build_usb
+++ /dev/null
@@ -1 +0,0 @@
-build_iso
\ No newline at end of file
diff --git a/tools/format_image/Makefile b/tools/format_image/Makefile
new file mode 100644
index 00000000..87ba40e7
--- /dev/null
+++ b/tools/format_image/Makefile
@@ -0,0 +1,39 @@
+#
+# Copyright (c) 2019, Joyent, Inc.
+#
+
+CC=gcc
+SRC_ROOT=$(PWD)/../..
+
+CFLAGS=-std=gnu99 -Wall -W -Werror -Wno-sign-compare
+
+TARGETS=format_image
+LIBS=-lsmbios -luuid
+
+#
+# Yes, we're directly pulling in a local copy of libefi source: see do_ioctl()
+# there for why.
+#
+# There is an obvious risk of trying to use illumos-joyent code directly on the
+# build platform.  However, this code is pretty self-contained, and its ioctl()
+# usage fairly stable. The biggest risk here is probably the libsmbios usage:
+# but even there, we don't actually care about any H/W workarounds in that code.
+#
+# Having said that, roll on the day when our minimum build platform has a lofi
+# driver such that we can avoid doing this hack.
+#
+OBJS=format_image.o rdwr_efi.o crc32_efi.o
+
+all: $(TARGETS)
+
+format_image: $(OBJS)
+	$(CC) $(CFLAGS) -o $@ $(OBJS) $(LIBS)
+
+%.o: %.c
+	$(CC) -c $(CFLAGS) -o $@ $<
+
+%.o: $(SRC_ROOT)/projects/illumos/usr/src/lib/libefi/common/%.c
+	$(CC) -c $(CFLAGS) -o $@ $<
+
+clean:
+	rm $(TARGETS) $(OBJS)
diff --git a/tools/format_image/format_image.c b/tools/format_image/format_image.c
new file mode 100644
index 00000000..086b9461
--- /dev/null
+++ b/tools/format_image/format_image.c
@@ -0,0 +1,406 @@
+/*
+ * This file and its contents are supplied under the terms of the
+ * Common Development and Distribution License ("CDDL"), version 1.0.
+ * You may only use this file in accordance with the terms of version
+ * 1.0 of the CDDL.
+ *
+ * A full copy of the text of the CDDL should have accompanied this
+ * source.  A copy of the CDDL is also available via the Internet at
+ * http://www.illumos.org/license/CDDL.
+ *
+ * Copyright (c) 2018, Joyent, Inc.
+ */
+
+/*
+ * As the build runs in a non-global zone, we don't have the luxury of tools
+ * such as labeled lofi, format, etc. in order to create the USB image.  We are
+ * looking to create an image of the following form:
+ *
+ * Part Tag      First Sector Size     Type
+ * -    mbr/GPT  0            1MB      MBR+EFI GPT (-m option plus libefi)
+ * 0    system   2048         256MB    EFI System Partition (-e option)
+ * 1    boot     526336       1MB      Legacy BIOS boot partition (-b option)
+ * 2    root     528384       3.46GB   pcfs or ufs root
+ * 8    reserved 7796083      8MB      V_RESERVED / devid (not really used)
+ *
+ * This boots under BIOS as follows:
+ *
+ * 1. BIOS loads the MBR, which jumps to stage2_sector (see pmbr.s)
+ * 2. stage2 is a modified gptzfsboot, in partition 1 above
+ * 3. despite the name, this can also load pcfs/ufs - partition 2 above.
+ *    To find the partition, there is a weirdo fake multiboot header embedded
+ *    that we need to update with the starting LBA of partition 2.
+ * 4. This then boots into loader
+ * 5. which finally will load the kernel
+ *
+ * On a UEFI system:
+ *
+ * 1. BIOS finds the ESP at partition 0, and loads /EFI/BOOT/BOOTX64.EFI
+ *    as defined by the EFI spec. This is "loader"
+ * 2. loader loads kernel from the pcfs/ufs root from partition 2
+ * 3. kernel takes control
+ *
+ * So this tool needs to fix up then write a modified MBR, populate the GPT
+ * header and partition tables, and write out the ESP and biosboot images.
+ * It is sort of an unholy merger of zpool_label_disk(ZPOOL_CREATE_BOOT_LABEL)
+ * and installboot(1m).
+ *
+ * We only currently support 512 block size, and the code isn't endian-vetted.
+ *
+ * The "root" partition is populated later, not by this tool. This is the main
+ * reason we megabyte-align the partitions: it's much faster if we can dd with
+ * a larger block size.
+ */
+
+#include <uuid/uuid.h>
+#include <strings.h>
+#include <string.h>
+#include <assert.h>
+#include <unistd.h>
+#include <stdarg.h>
+#include <stdlib.h>
+#include <libgen.h>
+#include <fcntl.h>
+#include <stdio.h>
+#include <errno.h>
+#include <err.h>
+
+#include <sys/efi_partition.h>
+#include <sys/dktp/fdisk.h>
+#include <sys/sysmacros.h>
+#include <sys/types.h>
+#include <sys/vtoc.h>
+#include <sys/stat.h>
+
+#define	EXIT_USAGE (2)
+
+/*
+ * From installboot.h, these are a set of offsets into the MBR.
+ */
+#define	SECTOR_SIZE (512)
+#define	STAGE1_STAGE2_SIZE (0xfc)  /* 16bits */
+#define	STAGE1_STAGE2_LBA (0xfe)  /* 64bits */
+#define	STAGE1_STAGE2_UUID (0x106) /* 128bits */
+#define	STAGE1_MBR_VERSION (0xfa) /* 2 bytes, major/minor */
+#define	STAGE1_BPB_OFFSET (0x3)   /* technically BPB starts at 0xb */
+#define	STAGE1_BPB_SIZE (0x3b)
+#define	STAGE1_MAGIC (0x1fe) /* 0xAA55 */
+
+/*
+ * From multiboot.h
+ */
+#define	MB_HEADER_MAGIC		 0x1BADB002	/* magic */
+
+#define	LBSIZE (SECTOR_SIZE)
+#define	MB_BLOCKS (2048) /* 1Mb in blocks */
+#define	PART_ALIGN (MB_BLOCKS * SECTOR_SIZE)
+#define	LEGACY_BOOTPART_BLOCKS (MB_BLOCKS) /* in LBSIZE */
+#define	LEGACY_BOOTPART_SIZE (LEGACY_BOOTPART_BLOCKS * LBSIZE)
+
+/*
+ * Space for MBR+GPT prior to first partition, aligned up to the first MB.
+ */
+#define	START_SECT (MB_BLOCKS)
+
+/*
+ * These define the basic layout of a USB key image, and are sniffed by
+ * /lib/sdc/usb-key.sh (and potentially elsewhere).  The legacy grub key is
+ * implicitly version 1.  A revision of IMAGE_MAJOR implies that old code cannot
+ * successfully mount the root of the USB key image in the expected place (that
+ * is, slice 2).
+ */
+#define	IMAGE_MAJOR (2)
+#define	IMAGE_MINOR (0)
+
+typedef struct multiboot_header {
+	uint32_t	magic;
+	uint32_t	flags;
+	uint32_t	checksum;
+	caddr32_t	header_addr;
+	caddr32_t	load_addr;
+	caddr32_t	load_end_addr;
+	caddr32_t	bss_end_addr;
+	caddr32_t	entry_addr;
+} multiboot_header_t;
+
+static const char *progname;
+static size_t biosboot_start;
+static int outfile;
+
+static void
+usage(const char *fmt, ...)
+{
+	if (fmt != NULL) {
+		va_list ap;
+
+		va_start(ap, fmt);
+		vwarnx(fmt, ap);
+		va_end(ap);
+	}
+
+	(void) fprintf(stderr,
+	    "Usage: %s -o image.usb -m mbr -e efifs -b biosboot\n"
+	    "\n"
+	    "Format a USB/ISO image for booting SmartOS or Triton.\n"
+	    "\n"
+	    "\t-o  output file\n"
+	    "\t-m  MBR image\n"
+	    "\t-e  EFI system partition (ESP) pcfs image\n"
+	    "\t-b  Legacy BIOS stage2 boot program (gptzfsboot)\n",
+	    progname);
+
+	exit(fmt == NULL ? EXIT_SUCCESS : EXIT_USAGE);
+}
+
+static char *
+read_file(const char *path, size_t size, size_t *lenp)
+{
+	struct stat st;
+	ssize_t ret;
+	size_t left;
+	char *buf;
+	char *pos;
+	int fd;
+
+	if ((fd = open(path, O_RDONLY)) == -1)
+		err(EXIT_FAILURE, "couldn't open %s", path);
+
+	if (fstat(fd, &st) != 0)
+		err(EXIT_FAILURE, "couldn't state %s", path);
+
+	if (size != 0 && st.st_size > size) {
+		errx(EXIT_FAILURE, "file %s exceeds maximum %lu bytes",
+		    path, size);
+	}
+
+	if (size == 0)
+		size = st.st_size;
+
+	if ((buf = calloc(1, size)) == NULL)
+		err(EXIT_FAILURE, "couldn't alloc buf for %s", path);
+
+	for (left = st.st_size, pos = buf; left; pos += ret, left -=ret) {
+		ret = read(fd, pos, left);
+
+		if (ret < 0)
+			err(EXIT_FAILURE, "couldn't read from %s", path);
+	}
+
+	if (lenp != NULL)
+		*lenp = st.st_size;
+	return (buf);
+}
+
+static void
+write_mbr(char *mbr, size_t esplen, size_t biosbootlen)
+{
+	uint64_t *stage2_lbap = (uint64_t *)(mbr + STAGE1_STAGE2_LBA);
+	uint16_t *stage2_sizep = (uint16_t *)(mbr + STAGE1_STAGE2_SIZE);
+	uint8_t *stage1_major = (uint8_t *)(mbr + STAGE1_MBR_VERSION);
+	uint8_t *stage1_minor = (uint8_t *)(mbr + STAGE1_MBR_VERSION + 1);
+	uchar_t *uuidp = (uchar_t *)(mbr + STAGE1_STAGE2_UUID);
+
+	*stage2_lbap = START_SECT + esplen / LBSIZE;
+	*stage2_sizep = biosbootlen / LBSIZE;
+	*stage1_major = IMAGE_MAJOR;
+	*stage1_minor = IMAGE_MINOR;
+
+	/*
+	 * This is all "nops" in the MBR image: let's clear it out like
+	 * installboot(1M) does.
+	 */
+	bzero(mbr + STAGE1_BPB_OFFSET, STAGE1_BPB_SIZE);
+
+	uuid_generate(uuidp);
+
+	if (pwrite(outfile, mbr, SECTOR_SIZE, 0) != SECTOR_SIZE)
+		err(EXIT_FAILURE, "failed to write MBR");
+}
+
+static void
+set_part(struct dk_part *part, diskaddr_t start, diskaddr_t size,
+    const char *name, ushort_t tag)
+{
+	if (tag != V_RESERVED) {
+		assert((start % MB_BLOCKS) == 0);
+		assert((size % MB_BLOCKS) == 0);
+	}
+
+	printf("%s %d %llu %llu\n", name, tag, start * LBSIZE, size * LBSIZE);
+
+	part->p_start = start;
+	part->p_size = size;
+	if (strlcpy(part->p_name, name, sizeof (part->p_name)) >=
+	    sizeof (part->p_name))
+		errx(EXIT_FAILURE, "partition name %s is too long", name);
+
+	part->p_tag = tag;
+}
+
+static void
+write_efi(size_t esplen)
+{
+	struct dk_gpt *vtoc;
+	diskaddr_t start = START_SECT;
+	diskaddr_t size;
+	int ret;
+
+	if (efi_alloc_and_init(outfile, EFI_NUMPAR, &vtoc) != 0)
+		err(EXIT_FAILURE, "failed to init EFI");
+
+	set_part(&vtoc->efi_parts[0], start, esplen / LBSIZE,
+	    "loader", V_SYSTEM);
+
+	start += esplen / LBSIZE;
+	biosboot_start = start;
+
+	set_part(&vtoc->efi_parts[1], start, LEGACY_BOOTPART_BLOCKS,
+	    "boot", V_BOOT);
+
+	start += LEGACY_BOOTPART_BLOCKS;
+
+	size = vtoc->efi_last_u_lba + 1 - (EFI_MIN_RESV_SIZE + start);
+	size = P2ALIGN(size, MB_BLOCKS);
+
+	set_part(&vtoc->efi_parts[2], start, size, "root", V_ROOT);
+
+	start = vtoc->efi_last_u_lba + 1 - EFI_MIN_RESV_SIZE;
+
+	set_part(&vtoc->efi_parts[8], start, EFI_MIN_RESV_SIZE,
+	    "reserved", V_RESERVED);
+
+	/*
+	 * This also updates the PMBR for the protective partition.
+	 */
+	if ((ret = efi_write(outfile, vtoc)) != 0)
+		errx(EXIT_FAILURE, "failed to write EFI with %d", ret);
+
+	efi_free(vtoc);
+}
+
+static void
+write_esp(char *esp, size_t esplen)
+{
+	if (pwrite(outfile, esp, esplen, START_SECT * LBSIZE) != esplen)
+		err(EXIT_FAILURE, "failed to write ESP");
+}
+
+static multiboot_header_t *
+find_multiboot(char *biosboot, size_t biosbootlen)
+{
+	for (size_t off = 0; off < biosbootlen; off +=4) {
+		multiboot_header_t *mb = (multiboot_header_t *)(biosboot + off);
+
+		if (mb->magic != MB_HEADER_MAGIC)
+			continue;
+
+		if (-(mb->flags + mb->magic) != mb->checksum)
+			continue;
+
+		return (mb);
+	}
+
+	return (NULL);
+}
+
+/*
+ * Before we can write out gptzfsboot we need to update its embedded
+ * multiboot_header_t: the ->bss_end_addr offset is examined to figure out the
+ * root partition's start sector (see sys/boot/common/multiboot.S).  Whoever
+ * said booting was pleasant?
+ */
+static void
+write_biosboot(char *biosboot, size_t biosbootlen)
+{
+	/* in sectors */
+	multiboot_header_t *multiboot;
+	uint64_t *ptr;
+
+	if ((multiboot = find_multiboot(biosboot, biosbootlen)) == NULL)
+		errx(EXIT_FAILURE, "couldn't find fake multiboot header");
+
+	ptr = (uint64_t *)&multiboot->bss_end_addr;
+	*ptr = biosboot_start + LEGACY_BOOTPART_BLOCKS;
+
+	if (pwrite(outfile, biosboot, LEGACY_BOOTPART_SIZE,
+	    biosboot_start * LBSIZE) != LEGACY_BOOTPART_SIZE)
+		err(EXIT_FAILURE, "failed to write biosboot");
+}
+
+int
+main(int argc, char *argv[])
+{
+	const char *biosbootpath = NULL;
+	const char *esppath = NULL;
+	const char *mbrpath = NULL;
+	const char *outpath = NULL;
+	size_t biosbootlen;
+	char *biosboot;
+	size_t esplen;
+	char *esp;
+	char *mbr;
+	int c;
+
+	progname = basename(argv[0]);
+
+	while ((c = getopt(argc, argv, ":b:e:hm:o:")) != -1) {
+		switch (c) {
+		case 'b':
+			biosbootpath = optarg;
+			break;
+		case 'e':
+			esppath = optarg;
+			break;
+		case 'o':
+			outpath = optarg;
+			break;
+		case 'm':
+			mbrpath = optarg;
+			break;
+		case 'h':
+			usage(NULL);
+			break;
+		case ':':
+			usage("Option -%c requires an operand\n", optopt);
+			break;
+		case '?':
+			usage("Unrecognised option: -%c\n", optopt);
+			break;
+		}
+	}
+
+	if (biosbootpath == NULL || esppath == NULL || mbrpath == NULL ||
+	    outpath == NULL)
+		usage("missing argument\n");
+
+	if (optind != argc)
+		usage("too many arguments\n");
+
+	if ((outfile = open(outpath, O_RDWR)) == -1)
+		err(EXIT_FAILURE, "failed to open %s for writing", outpath);
+
+	mbr = read_file(mbrpath, SECTOR_SIZE, NULL);
+
+	if (((struct mboot *)mbr)->signature != MBB_MAGIC) {
+		errx(EXIT_FAILURE, "MBR has incorrect magic %hlx",
+		    ((struct mboot *)mbr)->signature);
+	}
+
+	esp = read_file(esppath, 0, &esplen);
+
+	if (esplen % PART_ALIGN) {
+		errx(EXIT_FAILURE, "ESP image is not %lu-byte aligned",
+		    PART_ALIGN);
+	}
+
+	biosboot = read_file(biosbootpath, LEGACY_BOOTPART_SIZE, &biosbootlen);
+
+	write_mbr(mbr, esplen, biosbootlen);
+	write_efi(esplen);
+	write_esp(esp, esplen);
+	write_biosboot(biosboot, biosbootlen);
+
+	(void) close(outfile);
+
+	return (EXIT_SUCCESS);
+}
diff --git a/tools/images/1gb.fdisk b/tools/images/1gb.fdisk
deleted file mode 100644
index 3f7f8993..00000000
--- a/tools/images/1gb.fdisk
+++ /dev/null
@@ -1,6 +0,0 @@
-*   12: FDISK_EXT_WIN
-* Id    Act  Bhead  Bsect  Bcyl    Ehead  Esect  Ecyl    Rsect      Numsect
-  12    128  9      34     0       144    63     121     600        1952400
-  0     0    0      0      0       0      0      0       0          0
-  0     0    0      0      0       0      0      0       0          0
-  0     0    0      0      0       0      0      0       0          0
diff --git a/tools/images/2gb.fdisk b/tools/images/2gb.fdisk
deleted file mode 100644
index abb72f0e..00000000
--- a/tools/images/2gb.fdisk
+++ /dev/null
@@ -1,6 +0,0 @@
-*   12: FDISK_EXT_WIN
-* Id    Act  Bhead  Bsect  Bcyl    Ehead  Esect  Ecyl    Rsect      Numsect
-  12    128  9      34     0       34     63     243     600        3905400
-  0     0    0      0      0       0      0      0       0          0
-  0     0    0      0      0       0      0      0       0          0
-  0     0    0      0      0       0      0      0       0          0
diff --git a/tools/images/4gb.fdisk b/tools/images/4gb.fdisk
deleted file mode 100644
index f9663cec..00000000
--- a/tools/images/4gb.fdisk
+++ /dev/null
@@ -1,6 +0,0 @@
-*   12: FDISK_EXT_WIN
-* Id    Act  Bhead  Bsect  Bcyl    Ehead  Esect  Ecyl    Rsect      Numsect
-  12    128  9      34     0       69     63     486     600        7811400
-  0     0    0      0      0       0      0      0       0          0
-  0     0    0      0      0       0      0      0       0          0
-  0     0    0      0      0       0      0      0       0          0
diff --git a/tools/images/8gb.fdisk b/tools/images/8gb.fdisk
deleted file mode 100644
index 67505973..00000000
--- a/tools/images/8gb.fdisk
+++ /dev/null
@@ -1,6 +0,0 @@
-*   12: FDISK_EXT_WIN
-* Id    Act  Bhead  Bsect  Bcyl    Ehead  Esect  Ecyl    Rsect      Numsect
-  12    128  9      34     0       149    33     972     600        15624000
-  0     0    0      0      0       0      0      0       0          0
-  0     0    0      0      0       0      0      0       0          0
-  0     0    0      0      0       0      0      0       0          0
diff --git a/tools/images/make_image b/tools/images/make_image
deleted file mode 100755
index 658fa484..00000000
--- a/tools/images/make_image
+++ /dev/null
@@ -1,263 +0,0 @@
-#!/bin/bash
-#
-# This file and its contents are supplied under the terms of the
-# Common Development and Distribution License ("CDDL"), version 1.0.
-# You may only use this file in accordance with the terms of version
-# 1.0 of the CDDL.
-#
-# A full copy of the text of the CDDL should have accompanied this
-# source.  A copy of the CDDL is also available via the Internet at
-# http://www.illumos.org/license/CDDL.
-#
-
-#
-# Copyright 2016 Joyent, Inc.
-#
-
-#
-# This script has been written to be correct without either the "errexit" or
-# "pipefail" shell options.  The exit status of all operations is explicitly
-# checked, with appropriate handling of errors.
-#
-
-PFEXEC=/bin/pfexec
-GRUB_FILES=(
-	fat_stage1_5
-	iso9660_stage1_5
-	stage1
-	stage2
-	stage2_eltorito
-	ufs_stage1_5
-	zfs_stage1_5
-)
-
-g_size=
-g_fdisk_file=
-g_grub_dir=
-g_image_file=
-g_lofi_device=
-g_lofi_raw=
-g_mount_point=
-g_tmp_dir=
-
-function warn
-{
-	local msg="$0: WARNING: $1\\n"
-	shift
-
-	printf "$msg" "$@" 2>&1
-}
-
-function cleanup
-{
-	if [[ -n $g_mount_point ]]; then
-		if ! $PFEXEC /sbin/umount "$g_mount_point"; then
-			warn 'could not unmount %s' "$g_mount_point"
-		fi
-	fi
-
-	if [[ -n $g_lofi_device ]]; then
-		if ! $PFEXEC /usr/sbin/lofiadm -d "$g_lofi_device"; then
-			warn 'could not remove lofi device %s' \
-			    "$g_lofi_device"
-		fi
-	fi
-
-	if [[ -n $g_tmp_dir ]]; then
-		rm -rf "$g_tmp_dir"
-	fi
-	if [[ -n $g_image_file ]]; then
-		rm -f "$g_image_file"
-	fi
-}
-
-function fatal
-{
-	local msg="$0: ERROR: $1\\n"
-	shift
-
-	printf "$msg" "$@" 2>&1
-
-	cleanup
-	exit 1
-}
-
-#
-# Option parsing:
-#
-while getopts 's:F:G:' a; do
-	case $a in
-	s)
-		case $OPTARG in
-		1gb|2gb|4gb|8gb)
-			g_size=${OPTARG%gb}
-			;;
-		*)
-			fatal 'unknown size (-s): %s' "$OPTARG"
-			;;
-		esac
-		;;
-	F)
-		if [[ ! -f $OPTARG ]]; then
-			fatal 'fdisk table file not found: %s' "$OPTARG"
-		fi
-		g_fdisk_file=$OPTARG
-		;;
-	G)
-		if [[ ! -d $OPTARG ]]; then
-			fatal 'grub directory not found: %s' "$OPTARG"
-		fi
-		g_grub_dir=$OPTARG
-		;;
-	*)
-		fatal 'usage error'
-		exit 1
-		;;
-	esac
-done
-
-shift $(( $OPTIND - 1 ))
-if (( $# != 1 )); then
-	fatal 'must specify an image file'
-	exit 1
-fi
-g_image_file=$1
-
-if [[ -z $g_image_file || -z $g_size || -z $g_fdisk_file ||
-    -z $g_grub_dir ]]; then
-	fatal 'usage error: must provide all of -s, -F, and -G'
-fi
-
-if [[ -f $g_image_file ]]; then
-	printf 'image file exists already\n' >&2
-	exit 1
-fi
-
-printf '== create proforma image ========================================\n\n'
-printf '  output file:     %s\n' "$g_image_file"
-printf '  image size:      %d GB\n' "$g_size"
-printf '  fdisk template:  %s\n' "$g_fdisk_file"
-printf '  grub directory:  %s\n' "$g_grub_dir"
-
-#
-# Create a sparse file of the appropriate size.  This size must match that
-# which was used to create the fdisk(1M) template, and must be the same size or
-# smaller than the target USB drive.
-#
-printf 'create sparse image file\n'
-if ! /usr/sbin/mkfile -n $(( g_size * 1000000000 )) "$g_image_file"; then
-	fatal 'could not mkfile'
-fi
-
-#
-# Attach the blank image file to the system as a lofi(7D) device.
-#
-printf 'attach image file as lofi(7D) device\n'
-if ! g_lofi_device=$($PFEXEC /usr/sbin/lofiadm -a "$g_image_file"); then
-	fatal 'could not attach image as lofi(7D) device'
-fi
-
-#
-# The lofi(7D) device path is for the emulated block device.  We also need the
-# path to the emulated character device.
-#
-g_lofi_raw=${g_lofi_device/#\/dev\/lofi\//\/dev\/rlofi\/}
-printf '  lofi device:     %s\n' "$g_lofi_device"
-printf '  lofi raw device: %s\n' "$g_lofi_raw"
-
-if [[ ! -b $g_lofi_device || ! -c $g_lofi_raw ]]; then
-	fatal 'could not locate lofi(7D) device paths'
-fi
-
-printf 'create partition table\n'
-if ! $PFEXEC /sbin/fdisk -F "$g_fdisk_file" "$g_lofi_raw"; then
-	fatal 'could not make partition table'
-fi
-
-#
-# Create a FAT32 file system on the first partition of the image.  The volume
-# label is set to "HEADNODE".
-#
-printf 'format FAT32 file system\n'
-if ! $PFEXEC /usr/sbin/mkfs -F pcfs -o 'b=HEADNODE,fat=32' "$g_lofi_raw:c" \
-    </dev/null; then
-	fatal 'could not format FAT32 file system'
-fi
-
-#
-# Create a temporary directory in which to mount the image to avoid conflicting
-# with any other processes.
-#
-if ! g_tmp_dir=$(mktemp -d); then
-	fatal 'could not create temporary directory'
-fi
-
-g_mount_point=$g_tmp_dir/mnt
-if ! mkdir "$g_mount_point"; then
-	fatal 'could not create mount point directory: %s' "$g_mount_point"
-fi
-
-#
-# Mount the FAT32 file system from the image with the appropriate mount options.
-#
-printf 'mount FAT32 file system\n'
-if ! $PFEXEC /sbin/mount -F pcfs -o 'foldcase,noatime,hidden,clamptime,rw' \
-    "$g_lofi_device:c" "$g_mount_point"; then
-	fatal 'could not mount file system'
-fi
-
-#
-# Create the grub directory within the image.
-#
-if ! mkdir -p "$g_mount_point/boot/grub"; then
-	fatal 'could not create grub directory within image'
-fi
-
-#
-# Copy each grub file from the build area to the image, and create an empty
-# grub menu file in the appropriate location.
-#
-printf 'copying files:\n'
-for grub_file in ${GRUB_FILES[@]}; do
-	p=boot/grub/$grub_file
-	printf '      copy: %s\n' "$p"
-	if ! /bin/cp "$g_grub_dir/$p" "$g_mount_point/$p"; then
-		fatal 'could not copy %s' "$p"
-	fi
-done
-touch "$g_mount_point/boot/grub/menu.lst"
-
-#
-# Unmount the image now, so that we can use the grub shell without upsetting
-# the kernel.  Unset the "g_mount_point" variable so that cleanup does not try
-# to unmount a second time.
-#
-printf 'unmounting image\n'
-if ! $PFEXEC /sbin/umount "$g_mount_point"; then
-	fatal 'could not unmount image file system'
-fi
-unset g_mount_point
-
-#
-# Now that the file system is unmounted, use the grub command to install the
-# boot block within the MBR and embed the appropriate stage1_5.
-#
-printf 'installing grub\n'
-$PFEXEC "$g_grub_dir/boot/grub/bin/grub" --batch <<EOFGRUB
-device (hd0) $g_lofi_raw
-root (hd0,0)
-setup (hd0)
-quit
-EOFGRUB
-if [[ $? -ne 0 ]]; then
-	fatal 'failed to install grub'
-fi
-
-#
-# The image was successfully created.  Clean up all of our resources,
-# but make sure we do not delete the successfully created image file.
-#
-unset g_image_file
-cleanup
-printf '\n'
-exit 0
diff --git a/tools/usb_fdisk_table b/tools/usb_fdisk_table
deleted file mode 100644
index 4506355d..00000000
--- a/tools/usb_fdisk_table
+++ /dev/null
@@ -1,52 +0,0 @@
-
-* /dev/rlofi/2 default fdisk table
-* Dimensions:
-*    512 bytes/sector
-*    600 sectors/track
-*      1 tracks/cylinder
-*   6510 cylinders
-*
-* systid:
-*    1: DOSOS12
-*    2: PCIXOS
-*    4: DOSOS16
-*    5: EXTDOS
-*    6: DOSBIG
-*    7: FDISK_IFS
-*    8: FDISK_AIXBOOT
-*    9: FDISK_AIXDATA
-*   10: FDISK_0S2BOOT
-*   11: FDISK_WINDOWS
-*   12: FDISK_EXT_WIN
-*   14: FDISK_FAT95
-*   15: FDISK_EXTLBA
-*   18: DIAGPART
-*   65: FDISK_LINUX
-*   82: FDISK_CPM
-*   86: DOSDATA
-*   98: OTHEROS
-*   99: UNIXOS
-*  100: FDISK_NOVELL2
-*  101: FDISK_NOVELL3
-*  119: FDISK_QNX4
-*  120: FDISK_QNX42
-*  121: FDISK_QNX43
-*  130: SUNIXOS
-*  131: FDISK_LINUXNAT
-*  134: FDISK_NTFSVOL1
-*  135: FDISK_NTFSVOL2
-*  165: FDISK_BSD
-*  167: FDISK_NEXTSTEP
-*  183: FDISK_BSDIFS
-*  184: FDISK_BSDISWAP
-*  190: X86BOOT
-*  191: SUNIXOS2
-*  238: EFI_PMBR
-*  239: EFI_FS
-*
-
-* Id    Act  Bhead  Bsect  Bcyl    Ehead  Esect  Ecyl    Rsect      Numsect
-  12    128  9      34     0       34     63     243     600        3905400   
-  0     0    0      0      0       0      0      0       0          0         
-  0     0    0      0      0       0      0      0       0          0         
-  0     0    0      0      0       0      0      0       0          0         
-- 
2.21.0

