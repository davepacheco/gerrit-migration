From 654d1d01cec4601e13f73fe9b7d44edf6ee61b20 Mon Sep 17 00:00:00 2001
From: John Levon <john.levon@joyent.com>
Date: Mon, 18 Feb 2019 17:44:11 +0000
Subject: [PATCH] OS-7260 SmartOS should support booting with loader OS-7271
 proto.boot should include loader instead of grub OS-7309 build tools should
 support loader-based boot images OS-7364 fs_joyent.sh test needs quotes

---
 .gitignore                                  |   2 +
 Makefile                                    |  40 +-
 configure                                   |  33 +-
 overlay/generic/boot/forth/menu.rc          | 116 ++++++
 overlay/generic/kernel/drv/amd64/bnx        | Bin 629152 -> 0 bytes
 overlay/generic/lib/sdc/config.sh           |  21 +-
 overlay/generic/lib/sdc/usb-key.sh          | 208 ++++++++++
 overlay/generic/lib/svc/method/fs-joyent    |  80 +---
 overlay/generic/lib/svc/method/smartdc-init | 268 +------------
 overlay/generic/manifest                    |   3 +
 pkgsrc/dmake/prefix                         |   2 +-
 src/Makefile                                |  96 ++---
 src/Makefile.defs                           |  72 ++--
 src/Makefile.targ                           |  26 +-
 src/common/strings/Makefile                 |  67 +---
 src/dockerinit/Makefile                     |  91 +----
 src/fw/Makefile                             |   4 +-
 src/lx_hook_postnet/Makefile                | 110 +-----
 src/nictagadm                               |  31 +-
 src/node_modules/disklayout.js              |   2 +-
 src/routeinfo/Makefile                      |  97 +----
 src/test/disklayout/16.di.w16.z3.out        |   1 -
 src/test/disklayout/36.0s.w17.z3.out        | 262 +++++++++++++
 src/test/disklayout/36.di                   |  37 ++
 src/test/disklayout/36.di.0s.out            | 284 ++++++++++++++
 src/test/disklayout/36.di.1s.out            |   1 +
 src/test/disklayout/36.di.out               | 276 +++++++++++++
 src/test/disklayout/60.di.w21.z3.out        |   1 +
 src/test/disklayout/run                     |  11 +-
 src/test/disklayout/s16.di.z3-0.out         | 123 +++++-
 src/vm/node_modules/vminfod/vminfod.js      |   2 +-
 src/vm/package.json                         |   2 +-
 src/vmunbundle.c                            |  10 +-
 tools/build_boot_image                      | 412 ++++++++++++++++++++
 tools/build_illumos                         |   8 +
 tools/build_iso                             | 392 -------------------
 tools/build_live                            |   9 +
 tools/build_usb                             |   1 -
 tools/clobber_illumos                       |  65 +--
 tools/format_image/Makefile                 |  40 ++
 tools/format_image/format_image.c           | 406 +++++++++++++++++++
 tools/images/1gb.fdisk                      |   6 -
 tools/images/2gb.fdisk                      |   6 -
 tools/images/4gb.fdisk                      |   6 -
 tools/images/8gb.fdisk                      |   6 -
 tools/images/make_image                     | 263 -------------
 tools/usb_fdisk_table                       |  52 ---
 47 files changed, 2458 insertions(+), 1593 deletions(-)
 create mode 100644 overlay/generic/boot/forth/menu.rc
 delete mode 100755 overlay/generic/kernel/drv/amd64/bnx
 create mode 100644 overlay/generic/lib/sdc/usb-key.sh
 delete mode 100644 src/test/disklayout/16.di.w16.z3.out
 create mode 100644 src/test/disklayout/36.0s.w17.z3.out
 create mode 100644 src/test/disklayout/36.di
 create mode 100644 src/test/disklayout/36.di.0s.out
 create mode 100644 src/test/disklayout/36.di.1s.out
 create mode 100644 src/test/disklayout/36.di.out
 create mode 100644 src/test/disklayout/60.di.w21.z3.out
 create mode 100755 tools/build_boot_image
 delete mode 100755 tools/build_iso
 delete mode 120000 tools/build_usb
 create mode 100644 tools/format_image/Makefile
 create mode 100644 tools/format_image/format_image.c
 delete mode 100644 tools/images/1gb.fdisk
 delete mode 100644 tools/images/2gb.fdisk
 delete mode 100644 tools/images/4gb.fdisk
 delete mode 100644 tools/images/8gb.fdisk
 delete mode 100755 tools/images/make_image
 delete mode 100644 tools/usb_fdisk_table

diff --git a/.gitignore b/.gitignore
index 67122a07..6ed93817 100644
--- a/.gitignore
+++ b/.gitignore
@@ -44,6 +44,8 @@
 /tools/builder/users.c
 /tools/builder/users.c.tmp
 /tools/cryptpass
+/tools/format_image/*.o
+/tools/format_image/format_image
 /tools/pwgen
 /tools/pwgen-2.06/configure
 /tools/javascriptlint/build
diff --git a/Makefile b/Makefile
index d4374038..d680746b 100644
--- a/Makefile
+++ b/Makefile
@@ -10,7 +10,7 @@
 #
 
 #
-# Copyright 2018 Joyent, Inc.
+# Copyright (c) 2019, Joyent, Inc.
 #
 
 #
@@ -118,8 +118,6 @@ IMAGES_VERSION :=	images-$(shell [[ -f $(ROOT)/configure-buildver ]] && \
     echo $$(head -n1 $(ROOT)/configure-buildver)-)$(shell head -n1 $(STAMPFILE))
 IMAGES_TARBALL :=	output/$(IMAGES_VERSION).tgz
 
-IMAGES_SIZES_GB :=	1 2 4 8
-
 TOOLS_TARGETS = \
 	$(MANCHECK) \
 	$(MANCF) \
@@ -147,32 +145,27 @@ pkgsrc:
 
 $(BOOT_TARBALL): world manifest
 	pfexec rm -rf $(BOOT_PROTO)
-	mkdir -p $(BOOT_PROTO)
+	mkdir -p $(BOOT_PROTO)/etc/version/
 	mkdir -p $(ROOT)/output
 	pfexec ./tools/builder/builder $(ROOT)/$(BOOT_MANIFEST) \
-	    $(BOOT_PROTO) $(ROOT)/proto
+	    $(BOOT_PROTO) $(OVERLAYS) $(ROOT)/proto
+	cp $(STAMPFILE) $(BOOT_PROTO)/etc/version/boot
 	(cd $(BOOT_PROTO) && pfexec gtar czf $(ROOT)/$@ .)
 
 #
-# Create proforma images for use in assembling bootable USB device images.
-# These images are assembled into a sparse tar file which takes up hardly any
-# space, despite the large size of the (mostly blank) images.  This tar file is
-# used by "make coal" and "make usb" in "sdc-headnode.git" to create Triton
-# boot and installation media.
+# Create proforma images for use in assembling bootable USB device images.  The
+# images tar file is used by "make coal" and "make usb" in "sdc-headnode.git"
+# to create Triton boot and installation media.
 #
-images: $(IMAGES_SIZES_GB:%=$(IMAGES_PROTO)/%gb.img)
-
-$(IMAGES_PROTO)/%.img: boot tools/images/%.fdisk tools/images/make_image
+$(IMAGES_PROTO)/4gb.img: boot
 	rm -f $@
 	mkdir -p $(IMAGES_PROTO)
-	./tools/images/make_image -s $* -G $(ROOT)/proto \
-	    -F tools/images/$*.fdisk $@
+	./tools/build_boot_image -p 4 -r $(ROOT)
 
-images-tar: $(IMAGES_TARBALL)
+$(IMAGES_TARBALL): $(IMAGES_PROTO)/4gb.img
+	cd $(IMAGES_PROTO) && gtar -Scvz --owner=0 --group=0 -f $(ROOT)/$@ *
 
-$(IMAGES_TARBALL): images
-	cd $(IMAGES_PROTO) && gtar -Scvz --owner=0 --group=0 -f $(ROOT)/$@ \
-	    $(IMAGES_SIZES_GB:%=%gb.img)
+images-tar: $(IMAGES_TARBALL)
 
 #
 # Manifest construction.  There are 5 sources for manifests we need to collect
@@ -287,6 +280,7 @@ update-base:
 	touch $@
 
 0-subdir-%-stamp: 0-illumos-stamp
+	@echo "========== building $* =========="
 	cd "$(ROOT)/projects/local/$*" && \
 	    if [[ -f Makefile.joyent ]]; then \
 		gmake -f Makefile.joyent $(SUBDIR_DEFS) DESTDIR=$(PROTO) \
@@ -332,6 +326,7 @@ strap-cache:
 	touch $@
 
 0-livesrc-stamp: 0-illumos-stamp 0-strap-stamp 0-extra-stamp
+	@echo "========== building src =========="
 	(cd $(ROOT)/src && \
 	    gmake -j$(MAX_JOBS) NATIVEDIR=$(STRAP_PROTO) \
 	    DESTDIR=$(PROTO) && \
@@ -344,6 +339,7 @@ strap-cache:
 
 0-tools-stamp: 0-pwgen-stamp
 	(cd $(ROOT)/tools/builder && gmake builder)
+	(cd $(ROOT)/tools/format_image && gmake)
 	touch $@
 
 0-pwgen-stamp:
@@ -409,6 +405,8 @@ clean:
 	(cd $(ROOT) && mkdir -p $(PROTO) $(STRAP_PROTO) $(BOOT_PROTO) \
 	    $(IMAGES_PROTO))
 	rm -f tools/cryptpass
+	(cd tools/builder && gmake clean)
+	(cd tools/format_image && gmake clean)
 	(cd tools/mancheck && gmake clean)
 	(cd tools/mancf && gmake clean)
 	(cd tools/tzcheck && gmake clean)
@@ -419,10 +417,10 @@ clobber: clean
 	pfexec rm -rf output/* output-iso/* output-usb/*
  
 iso: live
-	./tools/build_iso
+	./tools/build_boot_image -I -r $(ROOT)
 
 usb: live
-	./tools/build_usb
+	./tools/build_boot_image -r $(ROOT)
 
 FRC:
 
diff --git a/configure b/configure
index ddb60449..75bff507 100755
--- a/configure
+++ b/configure
@@ -90,7 +90,7 @@ function install_pkgin
 	pkglist="$pkglist flex libxslt openjdk7 nodejs"
 	pkglist="$pkglist p5-XML-Parser gettext python27 py27-expat"
 	pkglist="$pkglist coreutils gsed pkg_alternatives cdrtools"
-	pkglist="$pkglist py27-sqlite3 nasm"
+	pkglist="$pkglist py27-sqlite3 nasm pigz"
 
 	for pkg in $pkglist; do
 		if ! pkg_info -qe $pkg; then
@@ -242,8 +242,6 @@ function generate_env
 	local nopts="-CimMNnt"
 	local lprefix
 
-	[[ "$ILLUMOS_LINT" = "yes" ]] && nopts="${nopts}l"
-
 	case $ILLUMOS_ENABLE_DEBUG in
 	exclusive)
 		nopts="${nopts}DF" ;;
@@ -315,7 +313,7 @@ PKGPUBLISHER_REDIST="${PUBLISHER}";		export PKGPUBLISHER_REDIST
 MAKEFLAGS=k;					export MAKEFLAGS
 UT_NO_USAGE_TRACKING="1";			export UT_NO_USAGE_TRACKING
 MULTI_PROTO="no";				export MULTI_PROTO
-BUILD_TOOLS="\${CODEMGR_WS}/usr/src/tools/proto/root_\${MACH}-nd/opt";
+BUILD_TOOLS="\$SRC/tools/proto/root_\${MACH}-nd/opt";
 						export BUILD_TOOLS
 SPRO_ROOT=/opt/SUNWspro;			export SPRO_ROOT
 SPRO_VROOT=\$SPRO_ROOT;				export SPRO_VROOT
@@ -348,7 +346,13 @@ NM=/usr/bin/nm;					export NM
 STRIP=/usr/bin/strip;				export STRIP
 TSORT=/usr/bin/tsort;				export TSORT
 AR=/usr/bin/ar;					export AR
-MAKE="$conf_root/proto.strap/usr/bin/dmake";	export MAKE
+#
+# We override $MAKE in ./tools/build_illumos so we can properly
+# bootstrap the tools build.
+#
+if [[ -z "\$MAKE" ]]; then
+MAKE="\$SRC/tools/proto/root_i386-nd/opt/onbld/bin/i386/dmake";	export MAKE
+fi
 LEX=/opt/local/bin/lex;				export LEX
 YACC=/opt/local/bin/yacc;			export YACC
 BISON=/opt/local/bin/bison;			export BISON
@@ -430,19 +434,17 @@ read -r -d '' usage <<EOF
 		build Illumos in DEBUG mode only [default: no]
 	-h
 		this message
-	-l
-		run lint pass on Illumos [default: no]
 	-p gcc4
 		primary compiler version [default: gcc4]
 	-r
 		full strap build (no cache) [default: no]
-	-s gcc6,gcc7
-		shadow compilers [default: none]
+	-s gcc7
+		shadow compilers, comma delimited (gcc7,gcc#) [default: none]
 EOF
 
 source_vars
 
-while getopts "cdhlp:rs:" arg; do
+while getopts "cdhp:rs:" arg; do
 	case $arg in
 	c)
 		ILLUMOS_CLOBBER=yes ;;
@@ -458,8 +460,6 @@ while getopts "cdhlp:rs:" arg; do
 	h)
 		echo "$usage"
 		exit 0 ;;
-	l)
-		ILLUMOS_LINT=yes ;;
 	p)
 		PRIMARY_COMPILER=$OPTARG
 		FORCE_STRAP_REBUILD=yes ;;
@@ -474,14 +474,6 @@ while getopts "cdhlp:rs:" arg; do
 	esac
 done
 
-if [[ -n "$ILLUMOS_LINT" ]]; then
-	if [[ -z "$ILLUMOS_ENABLE_DEBUG" ]]; then
-		ILLUMOS_ENABLE_DEBUG=yes
-	fi
-else
-	ILLUMOS_LINT=no
-fi
-
 [[ -n "$ILLUMOS_ENABLE_DEBUG" ]] || ILLUMOS_ENABLE_DEBUG=no
 [[ -n "$ILLUMOS_CLOBBER" ]] || ILLUMOS_CLOBBER=no
 [[ -n "$PRIMARY_COMPILER" ]] || PRIMARY_COMPILER=gcc4
@@ -492,7 +484,6 @@ cat >build.env <<EOF
 FORCE_STRAP_REBUILD=$FORCE_STRAP_REBUILD
 ILLUMOS_CLOBBER=$ILLUMOS_CLOBBER
 ILLUMOS_ENABLE_DEBUG=$ILLUMOS_ENABLE_DEBUG
-ILLUMOS_LINT=$ILLUMOS_LINT
 PRIMARY_COMPILER=$PRIMARY_COMPILER
 PRIMARY_COMPILER_VER=$PRIMARY_COMPILER_VER
 SHADOW_COMPILERS=$SHADOW_COMPILERS
diff --git a/overlay/generic/boot/forth/menu.rc b/overlay/generic/boot/forth/menu.rc
new file mode 100644
index 00000000..38f3b9b5
--- /dev/null
+++ b/overlay/generic/boot/forth/menu.rc
@@ -0,0 +1,116 @@
+\ Menu.rc
+\
+\ Load required Forth modules
+include /boot/forth/version.4th
+include /boot/forth/brand.4th
+include /boot/forth/menu.4th
+include /boot/forth/menu-commands.4th
+include /boot/forth/shortcuts.4th
+
+\ Screen prep
+clear         \ clear the screen (see `screen.4th')
+print_version \ print version string (bottom-right; see `version.4th')
+draw-beastie  \ draw freebsd mascot (on right; see `beastie.4th')
+draw-brand    \ draw the FreeBSD title (top-left; see `brand.4th')
+menu-init     \ initialize the menu area (see `menu.4th')
+
+\ Initialize main menu constructs (see `menu.4th')
+\ NOTE: To use `non-ansi' variants, add `loader_color=0' to loader.conf(5)
+\ NOTE: ANSI variants can use `^' in place of literal `Esc' (ASCII 27)
+
+\
+\ MAIN MENU
+\
+
+set menuset_name1="main"
+
+set mainmenu_init[1]="init_boot"
+
+set mainmenu_caption[1]="Boot SmartOS [Enter]"
+set mainansi_caption[1]="^[1mB^[moot SmartOS ^[1m[Enter]^[m"
+set mainmenu_command[1]="boot"
+\ keycode set by init_boot
+
+set mainmenu_caption[2]="[Esc]ape to loader prompt"
+set mainmenu_command[2]="goto_prompt"
+set mainmenu_keycode[2]=27
+set mainansi_caption[2]="^[1mEsc^[mape to loader prompt"
+
+\ Enable built-in "Reboot" trailing menuitem
+\ NOTE: appears before menu_options if configured
+\
+set mainmenu_reboot
+
+\ Enable "Options:" separator. When set to a numerical value (1-8), a visual
+\ separator is inserted before that menuitem number.
+\
+set mainmenu_options=4
+
+set mainmenu_caption[4]="Configure Boot [O]ptions..."
+set mainmenu_command[4]="2 goto_menu"
+set mainmenu_keycode[4]=111
+set mainansi_caption[4]="Configure Boot ^[1mO^[mptions..."
+
+\
+\ BOOT OPTIONS MENU
+\
+
+set menuset_name2="options"
+
+set optionsmenu_caption[1]="Back to Main Menu [Backspace]"
+set optionsmenu_command[1]="1 goto_menu"
+set optionsmenu_keycode[1]=8
+set optionsansi_caption[1]="Back to Main Menu ^[1m[Backspace]^[m"
+
+set optionsmenu_options=2
+set optionsmenu_optionstext="Boot Options:"
+
+set optionsmenu_osconsole=2
+set optionsmenu_command[2]="cycle_osconsole"
+set optionsmenu_keycode[2]=99
+
+set optionsmenu_init[3]="init_verbose"
+set optionsmenu_caption[3]="[V]erbose............. Off"
+set optionstoggled_text[3]="[V]erbose............. On"
+set optionsmenu_command[3]="toggle_verbose"
+set optionsmenu_keycode[3]=118
+set optionsansi_caption[3]="^[1mV^[merbose............... ^[34;1mOff^[m"
+set optionstoggled_ansi[3]="^[1mV^[merbose............... ^[32;7mOn^[m"
+
+set optionsmenu_init[4]="init_kmdb"
+set optionsmenu_caption[4]="k[m]db................ Off"
+set optionstoggled_text[4]="k[m]db................ On"
+set optionsmenu_command[4]="toggle_kmdb"
+set optionsmenu_keycode[4]=109
+set optionsansi_caption[4]="k^[1mm^[mdb.................. ^[34;1mOff^[m"
+set optionstoggled_ansi[4]="k^[1mm^[mdb.................. ^[32;7mOn^[m"
+
+set optionsmenu_init[5]="init_debug"
+set optionsmenu_caption[5]="[D]ebug............... Off"
+set optionstoggled_text[5]="[D]ebug............... On"
+set optionsmenu_command[5]="toggle_debug"
+set optionsmenu_keycode[5]=100
+set optionsansi_caption[5]="^[1mD^[mebug................. ^[34;1mOff^[m"
+set optionstoggled_ansi[5]="^[1mD^[mebug................. ^[32;7mOn^[m"
+
+set optionsmenu_init[6]="init_rescue"
+set optionsmenu_caption[6]="[R]escue Mode......... Off"
+set optionstoggled_text[6]="[R]escue Mode......... On"
+set optionsmenu_command[6]="toggle_rescue"
+set optionsmenu_keycode[6]=114
+set optionsansi_caption[6]="^[1mR^[mescue Mode........... ^[34;1mOff^[m"
+set optionstoggled_ansi[6]="^[1mR^[mescue Mode........... ^[32;7mOn^[m"
+
+\ Enable automatic booting (add ``autoboot_delay=N'' to loader.conf(5) to
+\ customize the timeout; default is 10-seconds)
+\
+set menu_timeout_command="boot"
+
+\ Include optional elements defined in a local file
+\
+try-include /boot/menu.rc.local
+
+\ Display the main menu (see `menu.4th')
+set menuset_initial=1
+menuset-loadinitial
+menu-display
diff --git a/overlay/generic/kernel/drv/amd64/bnx b/overlay/generic/kernel/drv/amd64/bnx
deleted file mode 100755
index 24b0db56..00000000
Binary files a/overlay/generic/kernel/drv/amd64/bnx and /dev/null differ
diff --git a/overlay/generic/lib/sdc/config.sh b/overlay/generic/lib/sdc/config.sh
index 0c8e5621..19cc15a2 100644
--- a/overlay/generic/lib/sdc/config.sh
+++ b/overlay/generic/lib/sdc/config.sh
@@ -7,7 +7,7 @@
 #
 # bash config.sh -json
 #
-# Copyright 2016 Joyent Inc.
+# Copyright 2018 Joyent Inc.
 #
 
 CACHE_FILE_JSON="/tmp/.config.json"
@@ -70,7 +70,20 @@ function load_sdc_sysinfo {
     prefix=$1
     [[ -z ${prefix} ]] && prefix="SYSINFO_"
 
-    eval $(/usr/bin/sysinfo -p | sed -e "s/^/${prefix}/")
+    #
+    # We've seen cases where Loader will set boot parameters that have a '#'
+    # character in the name.  Not surprisingly, bash won't let you have a '#'
+    # character in a shell variable name, so we strip any out of the lvalue
+    # as we process the sysinfo output.
+    #
+    tmpfile=$(mktemp -p /tmp)
+    /usr/bin/sysinfo -p | while read -r entry; do
+        lval=$(echo $entry | cut -d= -f 1 | sed -e 's/#//g')
+        rval=$(echo $entry | cut -d= -f 2-)
+        echo ${prefix}${lval}=${rval} >> $tmpfile
+    done
+    eval $(cat $tmpfile)
+    rm -f $tmpfile
 }
 
 # Sets SDC_CONFIG_FILENAME with the location of the config file. This can
@@ -187,7 +200,7 @@ function load_sdc_bootparams {
     [[ -z ${prefix} ]] && prefix="BOOT_"
     for line in $(/bin/bootparams); do
         fields=(${line//=/ })
-        key=$(echo ${fields[0]} | sed -e "s/-/_/g")
+        key=$(echo ${fields[0]} | sed -e "s/-/_/g;s/#//g")
         eval "${prefix}${key}=\"${fields[1]}\""
     done
 }
@@ -198,7 +211,7 @@ function sdc_bootparams_keys {
     #keys=$(cat /tmp/bootparams | sed -e "s/=.*//")
     for line in $(/bin/bootparams); do
         fields=(${line//=/ })
-        key=$(echo ${fields[0]} | sed -e "s/=.*//")
+        key=$(echo ${fields[0]} | sed -e "s/=.*//;s/#//g")
         echo ${key}
     done
 }
diff --git a/overlay/generic/lib/sdc/usb-key.sh b/overlay/generic/lib/sdc/usb-key.sh
new file mode 100644
index 00000000..b0a8e988
--- /dev/null
+++ b/overlay/generic/lib/sdc/usb-key.sh
@@ -0,0 +1,208 @@
+#!/usr/bin/bash
+#
+# Utilities for dealing with the USB key. In general, sdc-usbkey should be used.
+# These routines are for use prior to sdc-usbkey being installed.
+#
+# Copyright (c) 2019, Joyent, Inc.
+#
+
+#
+# Identify the version of this USB key (if it is indeed a USB key).
+#
+# We do this by sniffing fixed offset within the MBR. If we have a (legacy)
+# grub MBR, then we can look at offset 0x3e for COMPAT_VERSION_MAJOR and
+# COMPAT_VERSION_MINOR (and we'll presume 3.2 as a minimum).
+#
+# If we're talking about a loader-based key, we'll peek at 0xfa AKA
+# STAGE1_MBR_VERSION for format_image's IMAGE_MAJOR, which we expect to be 2.
+#
+# Unfortunately there's no standard way to find a version for other MBRs such as
+# grub2's. In these cases we'll end up with a potentially random version here,
+# so this key should not be trusted as ours until mounted and the path
+# .joyusbkey is found.
+#
+function usb_key_version()
+{
+	local readonly devpath=$1
+	local readonly mbr_sig_offset=0x1fe
+	local readonly mbr_grub_offset=0x3e
+	local readonly mbr_stage1_offset=0xfa
+	local readonly mbr_grub_version=0203
+	local readonly mbr_sig=aa55
+
+	sig=$(echo $(/usr/bin/od -t x2 \
+	    -j $mbr_sig_offset -A n -N 2 $devpath) )
+
+	if [[ "$sig" != $mbr_sig ]]; then
+		echo "unknown"
+		return
+	fi
+
+	grub_val=$(echo $(/usr/bin/od -t x2 \
+	    -j $mbr_grub_offset -A n -N 2 $devpath) )
+	loader_major=$(echo $(/usr/bin/od -t x1 \
+	    -j $mbr_stage1_offset -A n -N 1 $devpath) )
+
+	if [[ "$grub_val" = $mbr_grub_version ]]; then
+		echo "1"
+		return
+	fi
+
+	echo $(( 0x$loader_major ))
+}
+
+#
+# Mount the usbkey at the standard mount location (or whatever is specified).
+#
+function mount_usb_key()
+{
+	local mnt=$1
+
+	if [[ -z "$mnt" ]]; then
+		mnt=/mnt/$(svcprop -p "joyentfs/usb_mountpoint" \
+		    "svc:/system/filesystem/smartdc:default")
+	fi
+
+	if [[ -f "$mnt/.joyliveusb" ]]; then
+		echo $mnt
+		return 0
+	fi
+
+	if ! mkdir -p $mnt; then
+		echo "failed to mkdir $mnt" >&2
+		return 1
+	fi
+
+	readonly alldisks=$(/usr/bin/disklist -a)
+
+	for disk in $alldisks; do
+		version=$(usb_key_version "/dev/dsk/${disk}p0")
+
+		case $version in
+		1) devpath="/dev/dsk/${disk}p1" ;;
+		2) devpath="/dev/dsk/${disk}s2" ;;
+		*) continue ;;
+		esac
+
+		fstyp="$(/usr/sbin/fstyp $devpath 2>/dev/null)"
+
+		if [[ "$fstyp" != "pcfs" ]]; then
+			continue
+		fi
+
+		/usr/sbin/mount -F pcfs -o foldcase,noatime $devpath $mnt \
+		    2>/dev/null
+
+		if [[ $? -ne 0 ]]; then
+			continue
+		fi
+
+		if [[ -f $mnt/.joyliveusb ]]; then
+			echo $mnt
+			return 0
+		fi
+
+		if ! /usr/sbin/umount $mnt; then
+			echo "Failed to unmount $mnt" >&2
+			return 1
+		fi
+	done
+
+	echo "Couldn't find USB key" >&2
+	return 1
+}
+
+function unmount_usb_key()
+{
+	local mnt=$1
+
+	if [[ -z "$mnt" ]]; then
+		mnt=/mnt/$(svcprop -p "joyentfs/usb_mountpoint" \
+		    "svc:/system/filesystem/smartdc:default")
+	fi
+
+	typ=$(awk -v "mnt=$mnt" '$2 == mnt { print $3 }' /etc/mnttab)
+
+	[[ -z $typ ]] && return 0
+
+	if [[ ! -f "$mnt/.joyliveusb" ]]; then
+		echo "$mnt does not contain a USB key" >&2
+		return 1
+	fi
+
+	umount "$mnt"
+}
+
+# replace a loader conf value
+function edit_param
+{
+	local readonly file="$1"
+	local readonly key="$2"
+	local readonly value="$3"
+	if ! /usr/bin/grep "^\s*$key\s*=\s*" $file >/dev/null; then
+		echo "$key=\"$value\"" >>$file
+		return
+	fi
+
+	/usr/bin/sed -i '' "s+^\s*$key\s*=.*+$key=\"$value\"+" $file
+}
+
+#
+# Presumes a mounted USB key.
+#
+function usb_key_disable_ipxe()
+{
+	local readonly mnt=/mnt/$(svcprop -p "joyentfs/usb_mountpoint" \
+	    "svc:/system/filesystem/smartdc:default")
+	local readonly dev=$(mount | nawk "\$0~\"^$mnt\" { print \$3 ; }")
+	local readonly dsk=${dev%[ps]?}
+	local readonly version=$(usb_key_version ${dsk}p0)
+
+	case $version in
+	1)
+		sed -i '' "s/^default.*/default 1/" $mnt/boot/grub/menu.lst.tmpl
+		if [[ -f $mnt/boot/grub/menu.lst ]]; then
+			sed -i '' "s/^default.*/default 1/" \
+			    $mnt/boot/grub/menu.lst
+		fi
+		;;
+	2)
+		edit_param $mnt/boot/loader.conf ipxe "false"
+		;;
+	*)
+		echo "unknown USB key version $version" >&2
+		return 1
+		;;
+	esac
+}
+
+#
+# This only sets os_console. Presumes a mounted USB key.
+#
+function usb_key_set_console()
+{
+	local readonly mnt=/mnt/$(svcprop -p "joyentfs/usb_mountpoint" \
+	    "svc:/system/filesystem/smartdc:default")
+	local readonly dev=$(mount | nawk "\$0~\"^$mnt\" { print \$3 ; }")
+	local readonly dsk=${dev%[ps]?}
+	local readonly version=$(usb_key_version ${dsk}p0)
+	local readonly console=$1
+
+	case $version in
+	1)
+		sed -i '' "s/^variable os_console.*/variable os_console ${console}/" \
+		    $mnt/boot/grub/menu.lst.tmpl
+		if [[ -f $mnt/boot/grub/menu.lst ]]; then
+			sed -i '' "s/^variable os_console.*/variable os_console ${console}/" \
+			    $mnt/boot/grub/menu.lst
+		fi
+		;;
+	2)
+		edit_param $mnt/boot/loader.conf os_console "$console"
+		;;
+	*)
+		echo "unknown USB key version $version" >&2
+		return 1
+		;;
+	esac
+}
diff --git a/overlay/generic/lib/svc/method/fs-joyent b/overlay/generic/lib/svc/method/fs-joyent
index 11df1d5e..9082f22e 100755
--- a/overlay/generic/lib/svc/method/fs-joyent
+++ b/overlay/generic/lib/svc/method/fs-joyent
@@ -24,6 +24,7 @@ fatal()
 
 . /lib/svc/share/smf_include.sh
 . /lib/svc/share/fs_include.sh
+. /lib/sdc/usb-key.sh
 
 # first of all, if we aren't the global zone this doesn't make any sense to run
 
@@ -107,7 +108,7 @@ if [ $? -ne 0 ]; then
     # A machine is reset to its original unsetup state (i.e. a 'factory reset')
     # when the smartdc:factoryreset ZFS user property is set on the var dataset.
     reset=$(zfs get -H -o value smartdc:factoryreset ${SYS_ZPOOL}/var)
-    if [ ${reset} == "yes" ]; then
+    if [ "${reset}" == "yes" ]; then
         destroy_zpools
     fi
 
@@ -218,12 +219,9 @@ if [ -d /var/upgrade_in_progress ]; then
     exit $SMF_EXIT_ERR_FATAL
 fi
 
-USBMOUNTPOINT=/mnt/`svcprop -p "joyentfs/usb_mountpoint" ${SMF_FMRI}`
 COPYINPOINT=`svcprop -p "joyentfs/usb_copy_path" ${SMF_FMRI}`
 DEBUG=`svcprop -p "joyentfs/debug" ${SMF_FMRI}`
 
-mount_usb_msg=""
-
 if [[ -d /mnt ]]; then
     chown root:root /mnt
     chmod 700 /mnt
@@ -260,7 +258,7 @@ function make_usb_copy_if_possible
     mkdir ${COPYINPOINT}
     mount_zfs ${USBDATASET} ${COPYINPOINT}
 
-    $(cd ${USBMOUNTPOINT}; rsync -av --log-file=/dev/console --exclude private --exclude os * ${COPYINPOINT})
+    (cd ${USBMOUNTPOINT}; rsync -av --log-file=/dev/console --exclude private --exclude os * ${COPYINPOINT})
     if [[ -d ${USBMOUNTPOINT}/os ]]; then
         (cd ${USBMOUNTPOINT}/os ; \
             for dir in $(ls -d *); do
@@ -281,72 +279,10 @@ function make_usb_copy_if_possible
     return 0
 }
 
-mkdir -p ${USBMOUNTPOINT}
-
-if [[ -f "${USBMOUNTPOINT}/.joyliveusb" ]]; then
-    mount_usb_msg="already mounted"
-    make_usb_copy_if_possible
-    exit $?
-fi
-
-# First thing to do is to mount the USB key / VMWare disk
-USBKEYS=`/usr/bin/disklist -a`
-for key in ${USBKEYS}; do
-    if [[ `/usr/sbin/fstyp /dev/dsk/${key}p0:1` == 'pcfs' ]]; then
-        /usr/sbin/mount -F pcfs -o foldcase,noatime /dev/dsk/${key}p0:1 \
-            ${USBMOUNTPOINT};
-        if [[ $? == "0" ]]; then
-            if [[ ! -f ${USBMOUNTPOINT}/.joyliveusb ]]; then
-                if [[ ${DEBUG} == "true" ]]; then
-                    mount_usb_msg="${mount_usb_msg}\n[debug] didn't find ${USBMOUNTPOINT}/.joyliveusb on pcfs /dev/dsk/${key}p0:1"
-                fi
-                /usr/sbin/umount ${USBMOUNTPOINT};
-            else
-                if [[ ${DEBUG} == "true" ]]; then
-                    mount_usb_msg="${mount_usb_msg}\n[debug] found ${USBMOUNTPOINT}/.joyliveusb on pcfs /dev/dsk/${key}p0:1"
-                fi
-                break;
-            fi
-        elif [[ ${DEBUG} == "true" ]]; then
-            mount_usb_msg="${mount_usb_msg}\n[debug] mount failed for pcfs /dev/dsk/${key}p0:1"
-        fi
-    elif [[ ${DEBUG} == "true" ]]; then
-        mount_usb_msg="${mount_usb_msg}\n[debug] /dev/dsk/${key}p0:1 is not pcfs"
-    fi
-done
-
-if [[ ! -f "${USBMOUNTPOINT}/.joyliveusb" ]]; then
-    # we're probably VMWare, so we're looking at a non-USB disk.
-    for disk in `/usr/bin/disklist -a`; do
-        if [[ `/usr/sbin/fstyp /dev/dsk/${disk}p1` == 'pcfs' ]]; then
-            /usr/sbin/mount -F pcfs -o foldcase,noatime /dev/dsk/${disk}p1 \
-                ${USBMOUNTPOINT};
-            if [[ $? == "0" ]]; then
-                if [[ ! -f ${USBMOUNTPOINT}/.joyliveusb ]]; then
-                    if [[ ${DEBUG} == "true" ]]; then
-                        mount_usb_msg="${mount_usb_msg}\n[debug] didn't find ${USBMOUNTPOINT}/.joyliveusb on pcfs /dev/dsk/${disk}p1"
-                    fi
-                    /usr/sbin/umount ${USBMOUNTPOINT};
-                else
-                    if [[ ${DEBUG} == "true" ]]; then
-                        mount_usb_msg="${mount_usb_msg}\n[debug] found ${USBMOUNTPOINT}/.joyliveusb on pcfs /dev/dsk/${disk}p1"
-                    fi
-                    break;
-                fi
-            elif [[ ${DEBUG} == "true" ]]; then
-                mount_usb_msg="${mount_usb_msg}\n[debug] unable to mount /dev/dsk/${disk}p1"
-            fi
-        elif [[ ${DEBUG} == "true" ]]; then
-            mount_usb_msg="${mount_usb_msg}\n[debug] /dev/dsk/${disk}p1 is not pcfs"
-        fi
-    done
-fi
-
-if [[ -f "${USBMOUNTPOINT}/.joyliveusb" ]]; then
-    mount_usb_msg="success"
-    make_usb_copy_if_possible
-    exit $?
+USBMOUNTPOINT=$(mount_usb_key "")
+if [[ $? -ne 0 ]]; then
+    fatal "couldn't mount USB key"
 fi
 
-mount_usb_msg="${mount_usb_msg}\n[FATAL] mount_usb(): could not find USB Key"
-exit 1;
+make_usb_copy_if_possible
+exit $?
diff --git a/overlay/generic/lib/svc/method/smartdc-init b/overlay/generic/lib/svc/method/smartdc-init
index 81b6b526..1b2a5500 100755
--- a/overlay/generic/lib/svc/method/smartdc-init
+++ b/overlay/generic/lib/svc/method/smartdc-init
@@ -11,7 +11,7 @@
 #
 
 #
-# Copyright 2016 Joyent, Inc.
+# Copyright (c) 2018, Joyent, Inc.
 #
 
 export PS4='[\D{%FT%TZ}] ${BASH_SOURCE}:${LINENO}: ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
@@ -42,26 +42,6 @@ wait_and_clear()
     done
 }
 
-create_setup_status()
-{
-    [[ -e /var/lib/setup.json ]] && rm -f /var/lib/setup.json
-    echo "{" \
-	"\"node_type\": \"computenode\"," \
-	"\"start_time\": \"$(date "+%Y-%m-%dT%H:%M:%SZ")\"," \
-	"\"current_state\": \"setup_complete\"," \
-	"\"seen_states\": [" \
-	"\"zpool_created\"," \
-	"\"filesystems_setup\"," \
-	"\"agents_installed\"," \
-	"\"upgrade_complete\"," \
-	"\"setup_complete\"" \
-	"]," \
-	"\"complete\": true," \
-	"\"last_updated\": \"$(date "+%Y-%m-%dT%H:%M:%SZ")\"" \
-	"}" >/var/lib/setup.json
-    chmod 400 /var/lib/setup.json
-}
-
 # Sets the default firewall rules for a node (unless they're already set)
 set_default_fw_rules() {
     local fw_default_v
@@ -111,107 +91,6 @@ RULES
     fi
 }
 
-# This process is execessively complex but if not done carefully we can wedge
-# with svcs in maintenance.  We start by removing all but the agents_core.
-# Sometimes this leaves one or more agents still installed, so we do it again.
-# Finally we remove the agents_core (which should be the only thing left) and
-# then clean up the dirs so new agents will install into a fresh environment.
-# The wait_and_clear function is used to watch for svcs goint into maintenance
-# during this process and clear them so that the agent uninstall can continue.
-uninstall_agents6()
-{
-    echo "Removing the old agents..." > /dev/console
-
-    local AGENTS_DIR=/opt/smartdc/agents
-
-    local agent=
-    local TOREMOVE=`/opt/smartdc/agents/bin/agents-npm --no-registry \
-        ls installed 2>/dev/null | nawk '{print $1}'`
-    for agent in $TOREMOVE
-    do
-        (echo "$agent" | egrep -s '^atropos@') && continue
-        # We have to do agents_core after the others
-        (echo "$agent" | egrep -s '^agents_core@') && continue
-
-        # Supress possible npm warning removing CA (See AGENT-392)
-        if (echo "$agent" | egrep -s '^cainstsvc'); then
-            [ -e $AGENTS_DIR/smf/cainstsvc-default.xml ] && \
-                touch $AGENTS_DIR/smf/cainstsvc.xml
-        fi
-
-        echo "Uninstall: $agent"
-        /opt/smartdc/agents/bin/agents-npm uninstall $agent &
-        wait_and_clear
-    done
-
-    TOREMOVE=`/opt/smartdc/agents/bin/agents-npm --no-registry ls installed \
-        2>/dev/null | nawk '{print $1}'`
-    for agent in $TOREMOVE
-    do
-        (echo "$agent" | egrep -s '^atropos@') && continue
-        # We have to do agents_core after the others
-        (echo "$agent" | egrep -s '^agents_core@') && continue
-
-        echo "Uninstall: $agent"
-        /opt/smartdc/agents/bin/agents-npm uninstall $agent &
-        wait_and_clear
-    done
-
-    TOREMOVE=`/opt/smartdc/agents/bin/agents-npm --no-registry ls installed \
-        2>/dev/null | nawk '{print $1}'`
-    for agent in $TOREMOVE
-    do
-        (echo "$agent" | egrep -s '^atropos@') && continue
-
-        echo "Uninstall: $agent"
-        /opt/smartdc/agents/bin/agents-npm uninstall $agent &
-        wait_and_clear
-    done
-
-    for dir in $(ls "$AGENTS_DIR"); do
-        case "$dir" in
-        db|smf) continue ;;
-        *)      rm -fr $AGENTS_DIR/$dir ;;
-        esac
-    done
-
-    rm -rf $AGENTS_DIR/smf/*
-}
-
-install_agents7()
-{
-    echo "Installing the new agents..." > /dev/console
-
-    # Note: the preceeding call to install_config has called load_sdc_config
-
-    rm -f /var/tmp/agents_latest.sh
-    curl -k -o /var/tmp/agents_latest.sh \
-        -s "http://${CONFIG_assets_admin_ip}/extra/agents/latest"
-
-    [[ ! -f /var/tmp/agents_latest.sh ]] && return 1
-    (cd /var/tmp; bash /var/tmp/agents_latest.sh)
-    rm -f /var/tmp/agents_latest.sh
-    return 0
-}
-
-configure_imgadm()
-{
-    if [[ ! -f /var/imgadm/imgadm.conf ]]; then
-        mkdir -p /var/imgadm
-        echo '{}' > /var/imgadm/imgadm.conf
-    fi
-    if [[ -z "$(json -f /var/imgadm/imgadm.conf sources)" ]]; then
-        # re-load config
-        load_sdc_config
-
-        imgadm sources -f -a http://$CONFIG_imgapi_domain
-        # remove the default
-        imgadm sources -f -d https://images.joyent.com
-    fi
-
-    imgadm update
-}
-
 configure_fwadm()
 {
     if [[ ! -d /var/log/fw/logs ]]; then
@@ -304,96 +183,6 @@ install_config()
     fi
 }
 
-# If the CN has a local USB key, make sure its setup for universal booting
-update_local_key()
-{
-    local key=`diskinfo -H | nawk -F\t '{
-        if ($1 == "USB" && $6 == "yes" && $7 == "no") print $2}'`
-    local nkeys=`echo $key | wc -w`
-    [ $nkeys -ne 1 ] && return
-
-    curl -k -o /var/tmp/cnkey.tgz -f -s \
-        "http://${CONFIG_assets_admin_ip}/extra/usbkey/cnkey.tgz"
-    [ ! -f /var/tmp/cnkey.tgz ] && return
-
-    local console=$(bootparams | grep ^console= | cut -d= -f2)
-    [ -z "$console" ] && console=text
-
-    local kmnt=/mnt/usbkey
-    mkdir -p $kmnt
-    mount -F pcfs -o noatime /dev/dsk/${key}p0:1 $kmnt
-    if [[ $? == 0 ]]; then
-        if [[ -d $kmnt/dos && -f $kmnt/boot/grub/menu.lst &&
-            -f $kmnt/boot/ipxe.lkrn ]]; then
-            # already setup
-
-            # Ensure grub timeout is 5 secs for CNs and console is correct
-            sed -e "s/^variable os_console.*/variable os_console ${console}/" \
-                -e "s/^timeout.*/timeout 5/" \
-                < $kmnt/boot/grub/menu.lst > $kmnt/boot/grub/menu.lst.$$
-            mv -f $kmnt/boot/grub/menu.lst.$$ $kmnt/boot/grub/menu.lst
-
-            umount $kmnt
-            rm -f /var/tmp/cnkey.tgz
-            return
-        fi
-        # cleanup in preparation for new image
-        rm -rf $kmnt/* $kmnt/.[a-zA_Z]
-    else
-        # Key in an unknown state, clear it and set it up
-
-        # First clear label since fdisk -g fails on a labeled disk
-        dd if=/dev/zero of=/dev/rdsk/${key}p0 count=2
-
-        nsect=`fdisk -g /dev/rdsk/${key}p0 | nawk '{
-            if ($1 == "*") next; print $1 * $5 * $6 }'`
-        printf "12 128 0 0 0 0 0 0 4096 %d\n" $nsect >/tmp/fdisk.in
-        fdisk -F /tmp/fdisk.in /dev/rdsk/${key}p0
-
-        # Need temp copy of files for grub stage1
-        mkdir /var/tmp/key$$
-        (cd /var/tmp/key$$; gzcat /var/tmp/cnkey.tgz | tar xf -)
-
-        echo "y" | mkfs -F pcfs \
-            -o B=/var/tmp/key$$/boot/grub/stage1,fat=32 /dev/rdsk/${key}p0:c
-        mount -F pcfs -o noatime /dev/dsk/${key}p0:c $kmnt
-        if [[ $? != 0 ]]; then
-            rm -f /var/tmp/cnkey.tgz
-            rm -rf /var/tmp/key$$
-            return
-        fi
-        rm -rf /var/tmp/key$$
-    fi
-
-    # install new files
-    (cd $kmnt; gzcat /var/tmp/cnkey.tgz | tar xf -)
-    rm -f /var/tmp/cnkey.tgz
-
-    # setup CN boot menu
-    cat <<-MENU_DONE >$kmnt/boot/grub/menu.lst
-	default 0
-	timeout 5
-	min_mem64 1024
-	serial --speed=115200 --unit=1 --word=8 --parity=no --stop=1
-	terminal composite
-	variable os_console $console
-
-	title Compute Node (PXE)
-	kernel /boot/ipxe.lkrn
-
-	title Legacy Firmware Upgrade Mode
-	kernel$ /boot/memdisk console=\${os_console}
-	module /boot/freedos.img raw
-	MENU_DONE
-
-    umount $kmnt
-
-    # Always install stage1.5 since we don't know if key was bootable
-    printf "(hd0) %s\n" /dev/dsk/${key}p0 >/tmp/grub.map
-    printf "root (hd0,0)\nsetup (hd0)\n" | \
-        TERM=xterm grub --device-map=/tmp/grub.map
-}
-
 case "$1" in
 'start')
 
@@ -435,61 +224,6 @@ case "$1" in
         set_default_fw_rules
     else
 	install_config
-
-        # If this CN was running 6.5.x and has now been booted onto 7.0, we
-        # need to uninstall the old 6.5.x agents and install the new 7.0 agents.
-        if [[ -d /opt/smartdc/agents/modules && \
-            ! -d  /opt/smartdc/agents/lib ]]; then
-
-	    # During upgrade (or even before) we know the config file should
-	    # have been upgraded to include the imgapi_domain entry. If that
-	    # didn't happen, fail now.
-	    egrep -s imgapi_domain /opt/smartdc/config/node.config
-	    if [ $? -ne 0 ]; then
-                echo "ERROR: the local config file was not updated for upgrade."
-                exit $SMF_EXIT_ERR_FATAL
-	    fi
-
-            # Enable new ZFS features. The pool will no longer be usable on 6.5
-            zpool set feature@async_destroy=enabled zones
-            zpool set feature@empty_bpobj=enabled zones
-            zpool set feature@lz4_compress=enabled zones
-
-            # Convert to 7.0-style cores datasets
-            zfs destroy -r zones/cores
-            zfs create -o compression=lz4 -o mountpoint=none zones/cores
-            for i in `zoneadm list -c`
-            do
-                zfs destroy -rf zones/$i/cores
-                zfs create -o quota=100g -o mountpoint=/zones/$i/cores \
-                    zones/cores/$i
-            done
-
-            echo "Upgrading the system's agents" > /dev/console
-
-	    # disable the smartdc agent svcs
-	    echo "stopping svcs"
-	    for i in `svcs -a | nawk '/smartdc\/agent/{print $3}'`
-	    do
-		[[ "$i" == "svc:/smartdc/agent/ur:default" || \
-		   "$i" == "svc:/smartdc/agent/metadata:default" ]] && \
-		    continue
-		svcadm disable $i
-	    done
-
-            uninstall_agents6
-            install_agents7
-
-            create_setup_status
-            sysinfo -u
-            rm -f /tmp/.ur-startup
-            svcadm restart ur
-
-            update_local_key
-            configure_imgadm
-
-            echo "Upgrade done" > /dev/console
-        fi
     fi
 
     configure_fwadm
diff --git a/overlay/generic/manifest b/overlay/generic/manifest
index ebc1a35c..2bf722f6 100644
--- a/overlay/generic/manifest
+++ b/overlay/generic/manifest
@@ -1,4 +1,6 @@
 f .smartdc_version 0444 root root
+d boot/forth 0755 root root
+f boot/forth/menu.rc 0444 root root
 d etc/bash 0755 root sys
 f etc/bash/bash_completion 0644 root sys
 d etc/bash/bash_completion.d 0755 root sys
@@ -64,6 +66,7 @@ f kernel/drv/mpt_sas.conf 0644 root sys
 f kernel/drv/sd.conf 0644 root sys
 d lib/sdc 0755 root bin
 f lib/sdc/config.sh 0444 root bin
+f lib/sdc/usb-key.sh 0444 root bin
 f lib/sdc/network.sh 0444 root bin
 f lib/sdc/zone.sh 0444 root bin
 d lib/svc 0755 root bin
diff --git a/pkgsrc/dmake/prefix b/pkgsrc/dmake/prefix
index db51a98c..74e4e23b 100644
--- a/pkgsrc/dmake/prefix
+++ b/pkgsrc/dmake/prefix
@@ -1 +1 @@
-/opt/local
+/usr
diff --git a/src/Makefile b/src/Makefile
index 0961e82f..47d8846e 100644
--- a/src/Makefile
+++ b/src/Makefile
@@ -13,15 +13,16 @@
 # Copyright (c) 2019, Joyent, Inc.
 #
 
+BASE =		$(CURDIR)
+
 include Makefile.defs
 
 #
 # ROOT is used only when building and running the below tools.
 #
-ROOT =		$(PWD)/..
+ROOT =		$(BASE)/..
 JSSTYLE =	$(ROOT)/tools/jsstyle/jsstyle
 JSLINT =	$(ROOT)/tools/javascriptlint/build/install/jsl
-CSTYLE =	$(ROOT)/tools/cstyle
 
 #
 # Tool options
@@ -67,10 +68,9 @@ fswatcher :	LIBS +=		-lthread -lnvpair -lavl
 zfs_recv :	LIBS +=		-lsocket
 zfs_send :	LIBS +=		-lsocket
 vmbundle :	CPPFLAGS +=	-D_LARGEFILE_SOURCE -D_FILE_OFFSET_BITS=64
-sdc-on-tty :	CFLAGS +=	$(OPT_FLAG)
 sysevent :	LIBS +=		-lnvpair -lsysevent
 sysinfo_mod.so : CPPFLAGS +=	-D_REENTRANT
-sysinfo_mod.so : CFLAGS +=	-fpic -Wno-unused-parameter
+sysinfo_mod.so : CFLAGS +=	-fpic -Wno-unused-parameter $(DEBUG_FLAGS)
 sysinfo_mod.so : LDFLAGS +=	-shared -Wl,-ztext
 
 SYSINFO_MOD_DIR = $(DESTDIR)/usr/lib/sysevent/modules
@@ -159,17 +159,7 @@ C_CHECK_TARGETS=\
 	zfs_send.c \
 	sdc-on-tty.c \
 	sysinfo_mod.c \
-	sysevent.c \
-	dockerinit/src/dockerexec.c \
-	dockerinit/src/dockerinit.c \
-	dockerinit/src/docker-common.c \
-	lx_hook_postnet/main.c
-
-#
-# Generic flags we apply by default to everything.
-#
-CFLAGS +=	$(WARN_FLAGS)
-CXXFLAGS =	$(CFLAGS)
+	sysevent.c
 
 #
 # Node native add-on patterns.  For add-ons with a single source file in the
@@ -183,7 +173,7 @@ EXPAT.NODE =	$(EXPAT_OBJDIR)/node-expat.node
 
 $(EXPAT.NODE) :	WARN_FLAGS +=	-Wno-unused
 $(EXPAT.NODE) :	CPPFLAGS +=	$(NODE_CPPFLAGS)
-$(EXPAT.NODE) :	CXXFLAGS +=	$(NODE_CFLAGS)
+$(EXPAT.NODE) :	CXXFLAGS +=	$(NODE_CXXFLAGS)
 $(EXPAT.NODE) :	LDFLAGS +=	$(NODE_LDFLAGS)
 $(EXPAT.NODE) :	LIBS +=		-lexpat
 
@@ -195,7 +185,7 @@ KSTAT.NODE =	$(KSTAT_OBJDIR)/kstat.node
 
 $(KSTAT.NODE) :	WARN_FLAGS +=	-Wno-unused -Wno-write-strings -Wno-sign-compare
 $(KSTAT.NODE) :	CPPFLAGS +=	$(NODE_CPPFLAGS)
-$(KSTAT.NODE) :	CXXFLAGS +=	$(NODE_CFLAGS)
+$(KSTAT.NODE) :	CXXFLAGS +=	$(NODE_CXXFLAGS)
 $(KSTAT.NODE) :	LDFLAGS +=	$(NODE_LDFLAGS)
 $(KSTAT.NODE) :	LIBS +=		-lkstat
 
@@ -208,6 +198,7 @@ V8PLUS_SUBDIR_ENV = \
 			CXX=$(GXX) \
 			PREFIX_NODE=$(PREFIX_NODE) \
 			NODE_EXEC=$(NODE_EXEC) \
+			OPT_FLAGS="$(OPT_FLAGS)" \
 			CTFCONVERT=$(CTFCONVERT) \
 			CTFMERGE=$(CTFMERGE)
 
@@ -257,7 +248,7 @@ $(DTRACE_PROVIDER.NODE) :	CFLAGS +=	$(NODE_CFLAGS)
 $(DTRACE_PROVIDER.NODE) :	CPPFLAGS +=	\
 					$(NODE_CPPFLAGS) \
 					-Inode-dtrace-provider/libusdt
-$(DTRACE_PROVIDER.NODE) :	CXXFLAGS +=	$(NODE_CFLAGS)
+$(DTRACE_PROVIDER.NODE) :	CXXFLAGS +=	$(NODE_CXXFLAGS)
 $(DTRACE_PROVIDER.NODE) :	LDFLAGS +=	$(NODE_LDFLAGS)
 
 CLEANFILES +=	$(DTRACE_PROVIDER.NODE) $(DTRACE_PROVIDER_OBJS)
@@ -271,7 +262,7 @@ UUID.NODE =	$(UUID_OBJDIR)/uuid.node
 
 $(UUID.NODE) :	WARN_FLAGS +=	-Wno-unused -Wno-write-strings -Wno-sign-compare
 $(UUID.NODE) :	CPPFLAGS +=	$(NODE_CPPFLAGS)
-$(UUID.NODE) :	CXXFLAGS +=	$(NODE_CFLAGS)
+$(UUID.NODE) :	CXXFLAGS +=	$(NODE_CXXFLAGS)
 $(UUID.NODE) :	LDFLAGS +=	$(NODE_LDFLAGS)
 $(UUID.NODE) :	LIBS +=		-luuid
 
@@ -282,9 +273,12 @@ NOMKNOD_SRC =		nomknod.c
 NOMKNOD_SO =		nomknod.so
 NOMKNOD_32 =		$(NOMKNOD_SO).32
 NOMKNOD_64 =		$(NOMKNOD_SO).64
-NOMKNOD_32_FLAGS =	-m32
-NOMKNOD_64_FLAGS =	-m64
-NOMKNOD_FLAGS =		-nostdlib $(PIC_FLAGS) $(SHARED_FLAGS)
+
+NOMKNOD_FLAGS =		-nostdlib $(PIC_FLAGS) $(SHARED_FLAGS) \
+			-Wno-unused-parameter
+
+$(NOMKNOD_32) :		CFLAGS += -m32 $(NOMKNOD_FLAGS)
+$(NOMKNOD_64) :		CFLAGS += -m64 $(NOMKNOD_FLAGS)
 NOMKNOD_TARGS =		$(NOMKNOD_32) $(NOMKNOD_64)
 NOMKNOD_ROOT =		$(DESTDIR)/usr/img/lib
 NOMKNOD_ROOT64 =	$(DESTDIR)/usr/img/lib/amd64
@@ -337,21 +331,16 @@ SMARTDC_LIB_TARGETS = \
 #
 SUBDIRS = dockerinit routeinfo lx_hook_postnet
 
-SUBDIRS_ENV = \
-	CTFCONVERT=$(CTFCONVERT) \
-	CTFMERGE=$(CTFMERGE) \
-	DESTDIR=$(DESTDIR)
-
 all : TARGET = all
 clean : TARGET = clean
 install : TARGET = install
-check : TARGET = lint
+check : TARGET = check
 
 all: $(TARGETS) $(USR_LIB_TARGETS) sysinfo nictagadm sysevent \
 	$(SMARTDC_TARGETS) $(SMARTDC_LIB_TARGETS) $(SUBDIRS)
 
 $(SUBDIRS): FRC
-	@cd $@; pwd; $(MAKE) $(SUBDIRS_ENV) $(TARGET)
+	@cd $@; pwd; $(MAKE) $(TARGET)
 
 install: all $(SUBDIRS)
 	mkdir -p $(DESTDIR)/usr/bin
@@ -447,8 +436,8 @@ install: all $(SUBDIRS)
 	    > $(DESTDIR)/usr/fw/node_modules/bunyan.js
 	mkdir -m 0755 -p $(DESTDIR)/usr/lib/sdc
 	cp -p net-boot-config $(DESTDIR)/usr/lib/sdc
-	cd routeinfo && $(MAKE) install $(SUBDIRS_ENV)
-	cd lx_hook_postnet && $(MAKE) install $(SUBDIRS_ENV)
+	cd routeinfo && $(MAKE) install
+	cd lx_hook_postnet && $(MAKE) install
 	mkdir -p $(SYSINFO_MOD_DIR)
 	rm -f $(SYSINFO_MOD_DIR)/sysinfo_mod.so
 	/usr/sbin/install -f $(SYSINFO_MOD_DIR) -m 0555 sysinfo_mod.so
@@ -465,7 +454,7 @@ check: $(JSLINT) $(SUBDIRS)
 	@echo "==> Running cstyle..."
 	@# cstyle doesn't echo as it goes so we add an echo to each line below
 	@(for file in $(C_CHECK_TARGETS); do \
-		echo $(PWD)/$$file; \
+		echo $(BASE)/$$file; \
 		$(CSTYLE) $$file; \
 		[[ $$? == "0" ]] || exit 1; \
 	done)
@@ -476,12 +465,12 @@ check: $(JSLINT) $(SUBDIRS)
 	@printf "\n==> Running jsstyle...\n"
 	@# jsstyle doesn't echo as it goes so we add an echo to each line below
 	(for file in $(JS_CHECK_TARGETS); do \
-		echo $(PWD)/$$file; \
+		echo $(BASE)/$$file; \
 		$(JSSTYLE) $(JSSTYLE_OPTS) $$file; \
 		[[ $$? == "0" ]] || exit 1; \
 	done)
 	(for file in $(JS_CHECK_OLDSKOOL_TARGETS); do \
-		echo $(PWD)/$$file; \
+		echo $(BASE)/$$file; \
 		$(JSSTYLE) $(JSSTYLE_OLDSKOOL_OPTS) $$file; \
 		[[ $$? == "0" ]] || exit 1; \
 	done)
@@ -556,8 +545,8 @@ vm/node_modules/props.js: vm/node_modules/proptable.js vm/node_modules/expander.
 # add-on and see the comment and definitions for EXPAT.NODE above as well.
 #
 $(EXPAT.NODE): node-expat/node-expat.cc
-	@mkdir -p $(EXPAT_OBJDIR)
-	$(GXX) $(CPPFLAGS) $(CXXFLAGS) $(LDFLAGS) -o $@ $< $(LIBS)
+	@mkdir -p $(@D)
+	$(LINK.cc) $^ $(LIBS)
 
 #
 # node-lockfd and node-zonename are built using the v8plus-based Makefile
@@ -570,14 +559,14 @@ $(LOCKFD_BINDING.NODE): FRC
 	LD_OPTIONS=-lc \
 	$(MAKE) \
 		$(V8PLUS_SUBDIR_ENV) \
-		V8PLUS=$(PWD)/$(LOCKFD_V8PLUS_DIR)
+		V8PLUS=$(BASE)/$(LOCKFD_V8PLUS_DIR)
 
 $(ZONENAME_BINDING.NODE): FRC
 	cd $(ZONENAME_SRC_DIR) && \
 	LD_OPTIONS=-lc \
 	$(MAKE) \
 		$(V8PLUS_SUBDIR_ENV) \
-		V8PLUS=$(PWD)/$(ZONENAME_V8PLUS_DIR)
+		V8PLUS=$(BASE)/$(ZONENAME_V8PLUS_DIR)
 
 #
 # The next two are used to build libusdt files into
@@ -585,37 +574,34 @@ $(ZONENAME_BINDING.NODE): FRC
 #
 $(DTRACE_PROVIDER_OBJDIR)/%.o: $(DTRACE_PROVIDER_SRCDIR)/%.c \
 	    $(DTRACE_PROVIDER_HDRS)
-	@mkdir -p $(DTRACE_PROVIDER_OBJDIR)/libusdt
-	$(GCC) $(CPPFLAGS) $(CFLAGS) -o $@ -c $<
+	@mkdir -p $(@D)
+	$(COMPILE.c) $<
 
 $(DTRACE_PROVIDER_OBJDIR)/%.o: $(DTRACE_PROVIDER_SRCDIR)/%.s
-	@mkdir -p $(DTRACE_PROVIDER_OBJDIR)/libusdt
-	$(GCC) $(CPPFLAGS) $(CFLAGS) -o $@ -c $<
+	@mkdir -p $(@D)
+	$(COMPILE.c) $^
 
 $(DTRACE_PROVIDER_OBJDIR)/%.o: $(DTRACE_PROVIDER_SRCDIR)/%.cc \
 	    $(DTRACE_PROVIDER_HDRS)
-	@mkdir -p $(DTRACE_PROVIDER_OBJDIR)
-	$(GXX) $(CPPFLAGS) $(CXXFLAGS) $(LDFLAGS) -o $@ -c $<
+	@mkdir -p $(@D)
+	$(COMPILE.cc) $<
 
 $(DTRACE_PROVIDER.NODE): $(DTRACE_PROVIDER_OBJS)
-	@mkdir -p $(DTRACE_PROVIDER_OBJDIR)
-	$(GXX) $(CPPFLAGS) $(CXXFLAGS) $(LDFLAGS) -o $@ $(DTRACE_PROVIDER_OBJS) $(LIBS)
+	@mkdir -p $(@D)
+	$(LINK.cc) $^ $(LIBS)
 
 $(KSTAT.NODE): node-kstat/kstat.cc
-	@mkdir -p $(KSTAT_OBJDIR)
-	$(GXX) $(CPPFLAGS) $(CXXFLAGS) $(LDFLAGS) -o $@ $< $(LIBS)
+	@mkdir -p $(@D)
+	$(LINK.cc) $^ $(LIBS)
 
 $(UUID.NODE): $(UUID_SRCDIR)/uuid.cc
-	@mkdir -p $(UUID_OBJDIR)
-	$(GXX) $(CPPFLAGS) $(CXXFLAGS) $(LDFLAGS) -o $@ $< $(LIBS)
+	@mkdir -p $(@D)
+	$(LINK.cc) $^ $(LIBS)
 
 $(NOMKNOD_32):	$(NOMKNOD_SRC)
-	$(GCC) $(NOMKNOD_FLAGS) $(NOMKNOD_32_FLAGS) -o $@ $<
+	$(LINK.c) $^
 
 $(NOMKNOD_64):	$(NOMKNOD_SRC)
-	$(GCC) $(NOMKNOD_FLAGS) $(NOMKNOD_64_FLAGS) -o $@ $<
-
-$(SYSINFO_MOD): $(SYSINFO_MOD_SRC)
-	$(GCC) $(CPPFLAGS) $(CFLAGS) -o $@ -c $<
+	$(LINK.c) $^
 
 FRC:
diff --git a/src/Makefile.defs b/src/Makefile.defs
index 4b3559e1..42cd5c55 100644
--- a/src/Makefile.defs
+++ b/src/Makefile.defs
@@ -18,14 +18,24 @@
 #
 # CDDL HEADER END
 #
-# Copyright 2015, Joyent, Inc.
+# Copyright (c) 2019, Joyent, Inc.
 #
 
-BASE =		$(PWD)
+#
+# MG runs make check prior to ./configure, so allow build.env not to exist.
+#
+ifeq ($(MAKECMDGOALS),check)
+-include	$(BASE)/../build.env
+else
+include		$(BASE)/../build.env
+endif
+
 DESTDIR =	$(BASE)/../proto
 NATIVEDIR =	$(BASE)/../proto.strap
 ILLUMOS_SRC =	$(BASE)/../projects/illumos/usr/src
 
+BUILDSTAMP =	$(shell cat $(BASE)/../proto/buildstamp)
+
 ifeq ($(shell uname -s),Darwin)
 MAKE =		make
 PATH =		$(DESTDIR)/usr/bin:/bin:/usr/bin:/usr/sbin:/sbin:/opt/local/bin:/usr/local/bin
@@ -36,13 +46,13 @@ endif
 
 MAX_JOBS =	128
 PARALLEL =	-j$(MAX_JOBS)
+CSTYLE =	$(BASE)/../tools/cstyle
 GCC =		$(NATIVEDIR)/usr/bin/gcc
 GXX =		$(NATIVEDIR)/usr/bin/g++
 
 CTFBINDIR =	$(ILLUMOS_SRC)/tools/proto/root_i386-nd/opt/onbld/bin/i386
 CTFMERGE =	$(CTFBINDIR)/ctfmerge
 CTFCONVERT =	$(CTFBINDIR)/ctfconvert
-ALTCTFCONV =	$(CTFBINDIR)/ctfconvert
 
 SYSINCDIRS =	/usr/include
 SYSLIBDIRS =	/usr/lib /lib
@@ -57,9 +67,21 @@ NODE_EXEC =	$(NATIVEDIR)/usr/node/0.10/bin/node
 DEBUG_FLAGS =	-g
 WARN_FLAGS =	-Wall -Wextra -Werror
 PIC_FLAGS =	-fPIC
-OPT_FLAGS =	-O2
 
-NODE_CFLAGS =	$(DEBUG_FLAGS) $(WARN_FLAGS) $(PIC_FLAGS) $(OPT_FLAGS)
+OPT_FLAGS = -O2
+
+#
+# Avoid GCC's overly aggressive optimizations. We don't know of any specific
+# instances this causes problems, so this is just in case.
+#
+ifneq ($(PRIMARY_COMPILER_VER),4)
+OPT_FLAGS += -fno-aggressive-loop-optimizations
+endif
+
+CFLAGS =	-std=gnu99 $(WARN_FLAGS) $(OPT_FLAGS)
+CXXFLAGS =	$(WARN_FLAGS) $(OPT_FLAGS)
+NODE_CFLAGS =	$(DEBUG_FLAGS) $(PIC_FLAGS)
+NODE_CXXFLAGS =	$(DEBUG_FLAGS) $(PIC_FLAGS)
 
 STD_DEFS =	-D_GNU_SOURCE
 NODE_DEFS =	-DBUILDING_NODE_EXTENSION
@@ -75,23 +97,23 @@ NODE_LIBDIR =	-L$(PREFIX_NODE)/lib
 
 NODE_LDFLAGS =	$(SHARED_FLAGS) $(ZTEXT) $(NODE_LIBDIR)
 
-SUBDIR_CC =		CC="$(GCC)"
-SUBDIR_CXX =		CXX="$(GXX)"
-SUBDIR_CPPFLAGS =	CPPFLAGS="$(CPPFLAGS)"
-SUBDIR_CFLAGS =		CFLAGS="$(CFLAGS)"
-SUBDIR_CXXFLAGS =	CXXFLAGS="$(CXXFLAGS)"
-SUBDIR_LDFLAGS =	LDFLAGS="$(LDFLAGS)"
-SUBDIR_LIBS =		LIBS="$(LIBS)"
-SUBDIR_MAKE =		MAKE="$(MAKE)"
-SUBDIR_DESTDIR =	DESTDIR="$(DESTDIR)"
-
-SUBDIR_ENV = \
-	$(SUBDIR_CC) \
-	$(SUBDIR_CXX) \
-	$(SUBDIR_CPPFLAGS) \
-	$(SUBDIR_CFLAGS) \
-	$(SUBDIR_CXXFLAGS) \
-	$(SUBDIR_LDFLAGS) \
-	$(SUBDIR_LIBS) \
-	$(SUBDIR_MAKE) \
-	$(SUBDIR_DESTDIR)
+STRINGS_DIR =	$(BASE)/common/strings
+DOCKER_DIR =	$(BASE)/dockerinit
+
+INSTALL_PROG =	mkdir -p $(@D) && rm -f $@ && cp $^ $@ && \
+		chmod 755 $@ && touch $@
+
+COMPILE.c =	$(GCC) $(CPPFLAGS) $(CFLAGS) -o $@ -c
+LINK.c =	$(GCC) $(CPPFLAGS) $(CFLAGS) $(LDFLAGS) -o $@
+COMPILE.cc =	$(GXX) $(CPPFLAGS) $(CXXFLAGS) -o $@ -c
+LINK.cc =	$(GXX) $(CPPFLAGS) $(CXXFLAGS) $(LDFLAGS) -o $@
+
+MDATA_OBJS = \
+		mdata_dynstr.o \
+		mdata_proto.o \
+		mdata_common.o \
+		mdata_base64.o \
+		mdata_crc32.o \
+		mdata_reqid.o \
+		mdata_sunos.o \
+		mdata_unix_common.o
diff --git a/src/Makefile.targ b/src/Makefile.targ
index f220388e..b53d5926 100644
--- a/src/Makefile.targ
+++ b/src/Makefile.targ
@@ -10,12 +10,30 @@
 #
 
 #
-# Copyright 2015 Joyent, Inc.
+# Copyright (c) 2019, Joyent, Inc.
 #
 
 %: %.c
-	$(GCC) $(CPPFLAGS) $(CFLAGS) $(LDFLAGS) -o $@ $< $(LIBS)
+	$(LINK.c) $< $(LIBS)
 
 %.so: %.c
-	$(GCC) $(CPPFLAGS) $(CFLAGS) $(LDFLAGS) -o $@ $< $(LIBS)
-	$(ALTCTFCONV) -L VERSION -i $@
+	$(LINK.c) $< $(LIBS)
+	$(CTFCONVERT) -l $(BUILDSTAMP) $@
+
+%.o: src/%.c
+	$(COMPILE.c) $<
+
+mdata_%.o: $(DOCKER_DIR)/mdata-client/%.c
+	$(COMPILE.c) $^
+
+mdata_%.o: $(DOCKER_DIR)/mdata-client/plat/%.c
+	$(COMPILE.c) $^
+
+%.o: $(STRINGS_DIR)/%.c
+	$(COMPILE.c) $^
+
+%.o: $(DOCKER_DIR)/src/%.c
+	$(COMPILE.c) $^
+
+%.o: $(DOCKER_DIR)/json-nvlist/%.c
+	$(COMPILE.c) $^
diff --git a/src/common/strings/Makefile b/src/common/strings/Makefile
index 5c5d36aa..e6875a30 100644
--- a/src/common/strings/Makefile
+++ b/src/common/strings/Makefile
@@ -10,7 +10,7 @@
 #
 
 #
-# Copyright (c) 2017, Joyent, Inc.
+# Copyright (c) 2019, Joyent, Inc.
 #
 
 #
@@ -20,18 +20,14 @@
 # objects from this source in their own Makefile.
 #
 
-BASE :=		$(PWD)
-DESTDIR =	$(BASE)/../../../proto
-NATIVEDIR =	$(BASE)/../../../proto.strap
+BASE =		$(CURDIR)/../../
 
-GCC =		$(NATIVEDIR)/usr/bin/gcc
-GXX =		$(NATIVEDIR)/usr/bin/g++
+include $(BASE)/Makefile.defs
 
 .SUFFIXES:
 .SECONDARY:
 
-CFLAGS =	-std=gnu99 -Wall -Wextra -Werror -m32 -g \
-		-Wno-unused-parameter -I$(BASE)
+CFLAGS +=	$(DEBUG_FLAGS) -m32 -Wno-unused-parameter -I.
 
 TEST_PROGRAMS = \
 		test0 \
@@ -41,70 +37,39 @@ TEST_PROGRAMS = \
 		test4 \
 		testpath
 
-TEST_BINS =	$(TEST_PROGRAMS:%=obj/%)
-
-STRINGS_OBJECTS = \
+OBJS = 		\
 		custr.o \
 		strlist.o \
 		strpath.o
 
-OBJECTS = \
-		$(STRINGS_OBJECTS:%=obj/%)
-
-CTFCONVERT =	/usr/bin/true
-CTFMERGE =	/usr/bin/true
-
-CC =		$(GCC)
-CSTYLE =	../../../tools/cstyle
-
 LIBS =		-lumem
 
-COMPILE_C =	$(CC) $(CPPFLAGS) $(LDFLAGS) $(CFLAGS) -c -o $@ $< $(LIBS)
-
-INSTALL_PROG =	mkdir -p $(@D) && rm -f $@ && cp $^ $@ && \
-		chmod 755 $@ && touch $@
-
 .PHONY: all
-all: $(TEST_BINS)
+all: $(TEST_PROGRAMS)
 
 .PHONY: check
-check: $(STRINGS_OBJECTS:%.o=%.check)
-
-%.check: %.c
-	$(CSTYLE) -cPp $<
-
-lint:
-	/usr/bin/true
+check: $(OBJS:%.o=%.check)
 
 clean:
-	rm -f $(OBJECTS) $(TEST_BINS:%=%.o)
-	rm -f $(TEST_BINS)
-	rmdir obj/
+	rm -f $(OBJS) $(TEST_PROGRAMS:%=%.o)
+	rm -f $(TEST_PROGRAMS)
 
 .PHONY: test
 test: all $(TEST_PROGRAMS:%=%.runtest)
 
-%.runtest: obj/%
+%.runtest: %
 	@echo RUNNING TEST $^ ...
 	@./$^
 	@echo OK
 	@echo ""
 
-#
-# Compilation and linking targets
-#
-obj/test%: obj/test%.o $(OBJECTS)
-	$(CC) $(CPPFLAGS) $(LDFLAGS) $(CFLAGS) -o $@ $^ $(LIBS) \
-	    tests/force_umem_debug.c
-	$(CTFMERGE) -L VERSION -o $@ $(OBJECTS)
-
-obj/test%.o: tests/test%.c
+test%: test%.o $(OBJS) tests/force_umem_debug.c
 	@mkdir -p $(@D)
-	$(COMPILE_C)
-	$(CTFCONVERT) -L VERSION $@
+	$(LINK.c) $^ $(LIBS)
+	$(CTFCONVERT) -l $(BUILDSTAMP) $@
 
-obj/%.o: %.c
+test%.o: tests/test%.c
 	@mkdir -p $(@D)
-	$(COMPILE_C)
-	$(CTFCONVERT) -L VERSION $@
+	$(COMPILE.c) $^
 
+include $(BASE)/Makefile.targ
diff --git a/src/dockerinit/Makefile b/src/dockerinit/Makefile
index 55ac3730..2388d092 100644
--- a/src/dockerinit/Makefile
+++ b/src/dockerinit/Makefile
@@ -10,40 +10,21 @@
 #
 
 #
-# Copyright (c) 2017, Joyent, Inc.
+# Copyright (c) 2019, Joyent, Inc.
 #
 
-BASE :=		$(PWD)
-DESTDIR =	$(BASE)/../../proto
-NATIVEDIR =	$(BASE)/../../proto.strap
+BASE :=		$(CURDIR)/../
+
+include		$(BASE)/Makefile.defs
 
 PROGRAMS =	dockerinit dockerexec
 
 .SUFFIXES:
 .SECONDARY:
 
-GCC =		$(NATIVEDIR)/usr/bin/gcc
-GXX =		$(NATIVEDIR)/usr/bin/g++
-
-SYSINCDIRS =	/usr/include
-SYSLIBDIRS =	/usr/lib /lib
-
-CPPFLAGS =	$(SYSINCDIRS:%=-isystem $(DESTDIR)/%)
-LDFLAGS =	$(SYSLIBDIRS:%=-L$(DESTDIR)/%) \
-		-Wl,-zassert-deflib -Wl,-zfatal-warnings
-
 JSON_OBJS =	json-nvlist.o
 JSON_LIBS =	-lnvpair
 
-MDATA_OBJS = \
-		mdata-client/dynstr.o \
-		mdata-client/proto.o \
-		mdata-client/common.o \
-		mdata-client/base64.o \
-		mdata-client/crc32.o \
-		mdata-client/reqid.o \
-		mdata-client/plat/sunos.o \
-		mdata-client/plat/unix_common.o
 MDATA_LIBS =	-lnsl -lsocket -lsmbios
 
 NET_LIBS =	-lipadm -linetutil -lnsl -lsocket
@@ -53,75 +34,37 @@ STRINGS_OBJS =	custr.o strlist.o strpath.o
 DOCKER_OBJS =	docker-common.o
 
 BUILD :=	build
-OBJDIR :=	obj
 
 BUILD_PROGS =	$(PROGRAMS:%=$(BUILD)/%)
 
 LIBS =		$(JSON_LIBS) $(MDATA_LIBS) $(NET_LIBS) -lgen -lcontract
 
-OBJS =		$(JSON_OBJS:%=obj/%) \
+OBJS =		$(JSON_OBJS) \
 		$(MDATA_OBJS) \
-		$(STRINGS_OBJS:%=obj/%) \
-		$(DOCKER_OBJS:%=obj/%)
-
-CTFCONVERT =	/usr/bin/true
-CTFMERGE =	/usr/bin/true
+		$(STRINGS_OBJS) \
+		$(DOCKER_OBJS)
 
-CC =		$(GCC)
-CFLAGS =	-std=gnu99 -Wall -Wextra -Werror -D__HAVE_BOOLEAN_T -m32 -g \
-		-I$(BASE)/../common/strings
-
-COMPILE_C =	$(CC) $(CPPFLAGS) $(LDFLAGS) -c $(CFLAGS) -o $@ $<
-
-CSTYLE =	../../tools/cstyle
+CFLAGS +=	$(DEBUG_FLAGS) -D__HAVE_BOOLEAN_T -m32 -I$(STRINGS_DIR) \
+		-I$(DOCKER_DIR)/mdata-client
 
 all: $(BUILD_PROGS)
 
 install: all
 
-#
-# Compilation and Linking Targets
-#
-
-$(BUILD)/%: obj/%.o $(OBJS) | $(BUILD)
-	$(CC) $(CPPFLAGS) $(LDFLAGS) $(CFLAGS) -o $@ $^ $(LIBS)
-	$(CTFMERGE) -L VERSION -o $@ $(OBJS)
+$(BUILD)/%: %.o $(OBJS) | $(BUILD)
+	$(LINK.c) $^ $(LIBS)
+	$(CTFCONVERT) -l $(BUILDSTAMP) $@
 
-mdata-client/plat/%.o: mdata-client/plat/%.c
-	(cd mdata-client && $(MAKE) plat/$(@F))
-
-mdata-client/%.o: mdata-client/%.c
-	(cd mdata-client && $(MAKE) $(@F))
-
-$(OBJDIR)/%.o: json-nvlist/%.c | $(OBJDIR)
-	$(COMPILE_C)
-	$(CTFCONVERT) -L VERSION $@
-
-$(OBJDIR)/%.o: src/%.c | $(OBJDIR)
-	$(COMPILE_C)
-	$(CTFCONVERT) -L VERSION $@
-
-$(OBJDIR)/%.o: $(BASE)/../common/strings/%.c | $(OBJDIR)
-	$(COMPILE_C)
-	$(CTFCONVERT) -L VERSION $@
-
-$(OBJDIR) $(BUILD):
+$(BUILD):
 	mkdir -p $@
 
-#
-# Check, Lint and Clean Targets
-#
-
 check: src/*.c
-	@echo $(PWD)/$^
-	@$(CSTYLE) $^
-
-lint:
-	/usr/bin/true
+	$(CSTYLE) -P $^
 
 clean:
 	rm -f $(BUILD_PROGS)
-	rm -f $(PROGRAMS:%=obj/%.o)
+	rm -f $(PROGRAMS:%=%.o)
 	rm -f $(OBJS)
 	if test -d $(BUILD); then rmdir $(BUILD); fi
-	if test -d $(OBJDIR); then rmdir $(OBJDIR); fi
+
+include $(BASE)/Makefile.targ
diff --git a/src/fw/Makefile b/src/fw/Makefile
index d4248596..025c264c 100644
--- a/src/fw/Makefile
+++ b/src/fw/Makefile
@@ -1,12 +1,12 @@
 #
-# Copyright (c) 2014, Joyent, Inc. All rights reserved.
+# Copyright (c) 2019, Joyent, Inc. All rights reserved.
 #
 
 
 #
 # Directories
 #
-ROOT = $(PWD)/../..
+ROOT = $(CURDIR)/../..
 TOP := $(shell pwd)
 NM := node_modules
 NM_ORIG := node_modules.orig
diff --git a/src/lx_hook_postnet/Makefile b/src/lx_hook_postnet/Makefile
index 8a007cdd..3d7a5ea1 100644
--- a/src/lx_hook_postnet/Makefile
+++ b/src/lx_hook_postnet/Makefile
@@ -10,120 +10,50 @@
 #
 
 #
-# Copyright (c) 2017, Joyent, Inc.
+# Copyright (c) 2019, Joyent, Inc.
 #
 
-BASE :=		$(PWD)
-DESTDIR =	$(BASE)/../../proto
-NATIVEDIR =	$(BASE)/../../proto.strap
+BASE :=		$(CURDIR)/../
 
-PROGRAM =	lx_hook_postnet
-
-GCC =		$(NATIVEDIR)/usr/bin/gcc
-GXX =		$(NATIVEDIR)/usr/bin/g++
-
-SYSINCDIRS =	/usr/include
-SYSLIBDIRS =	/usr/lib /lib
+include		$(BASE)/Makefile.defs
 
-CFLAGS =	-std=gnu99 -Wall -Wextra -Werror -m32 -g \
-		-I$(DOCKER_DIR) \
-		-Wno-unused-parameter
-CPPFLAGS =	$(SYSINCDIRS:%=-isystem $(DESTDIR)/%)
-LDFLAGS =	$(SYSLIBDIRS:%=-L$(DESTDIR)/%) \
-		-Wl,-zassert-deflib -Wl,-zfatal-warnings
+PROGRAM =	lx_hook_postnet
 
-STRINGS_DIR =	$(BASE)/../common/strings
-DOCKER_DIR =	$(BASE)/../dockerinit
+CFLAGS +=	$(DEBUG_FLAGS) -m32 -I$(DOCKER_DIR) -I$(STRINGS_DIR) \
+		-I$(DOCKER_DIR)/mdata-client -I$(DOCKER_DIR)/src \
+		-I$(DOCKER_DIR)/json-nvlist \
+		 -Wno-unused-parameter -D__HAVE_BOOLEAN_T
 
-LXINIT_HOOK_OBJECTS = \
+LXINIT_HOOK_OBJS = \
 		main.o
 
-MDATA_OBJECTS = \
-		dynstr.o \
-		proto.o \
-		common.o \
-		base64.o \
-		crc32.o \
-		reqid.o \
-		sunos.o \
-		unix_common.o
-
-custr.o :	CFLAGS += -I$(STRINGS_DIR)
-mdata_%.o :	CFLAGS += -I$(DOCKER_DIR)/mdata-client -D__HAVE_BOOLEAN_T
-main.o:	CFLAGS += -I$(STRINGS_DIR)
-docker_common.o:	CFLAGS += -I$(DOCKER_DIR)/src
-strlist.o:	CFLAGS += -I$(STRINGS_DIR)
-strpath.o:	CFLAGS += -I$(STRINGS_DIR)
-
-OBJECTS = \
-		$(MDATA_OBJECTS:%=mdata_%) \
+OBJS = \
+		$(MDATA_OBJS) \
+		$(LXINIT_HOOK_OBJS) \
 		custr.o \
-		docker_common.o \
+		docker-common.o \
 		json-nvlist.o \
-		main.o \
 		strlist.o \
 		strpath.o
 
-json-nvlist.o :	CFLAGS += -I$(DOCKER_DIR)/json-nvlist -I$(STRINGS_DIR)
-
-docker_common.o :	CFLAGS += -I$(DOCKER_DIR)/json-nvlist -I$(STRINGS_DIR)
-
 LIBS =		-lnvpair -lnsl -lsocket -lsmbios -lgen
 
-CTFCONVERT =	/usr/bin/true
-CTFMERGE =	/usr/bin/true
-
-CC=$(GCC)
-CFLAGS +=	-Wall -Wextra -Werror -D__HAVE_BOOLEAN_T -m32
-CSTYLE =	../../tools/cstyle
-
-COMPILE_C =	$(CC) $(CPPFLAGS) $(LDFLAGS) $(CFLAGS) -c -o $@ $<
-
-INSTALL_PROG =	mkdir -p $(@D) && rm -f $@ && cp $^ $@ && \
-		chmod 755 $@ && touch $@
-
 .PHONY: all
 all: $(PROGRAM)
 
 .PHONY: check
-check: $(LXINIT_HOOK_OBJECTS:%.o=%.check)
+check: $(LXINIT_HOOK_OBJS:%.o=%.check)
 
 %.check: %.c
-	$(CSTYLE) -cPp $<
-
-lint:
-	/usr/bin/true
+	$(CSTYLE) -P $<
 
 clean:
-	rm -f $(OBJECTS)
+	rm -f $(OBJS)
 	rm -f $(PROGRAM)
 
-#
-# Compilation and linking targets
-#
-$(PROGRAM): $(OBJECTS)
-	$(CC) $(CPPFLAGS) $(LDFLAGS) $(CFLAGS) -o $@ $(OBJECTS) $(LIBS)
-	$(CTFMERGE) -L VERSION -o $@ $(OBJECTS)
-
-%.o: $(STRINGS_DIR)/%.c
-	$(COMPILE_C)
-	$(CTFCONVERT) -L VERSION $@
-
-mdata_%.o: $(DOCKER_DIR)/mdata-client/%.c
-	$(COMPILE_C)
-	$(CTFCONVERT) -L VERSION $@
-
-mdata_%.o: $(DOCKER_DIR)/mdata-client/plat/%.c
-	$(COMPILE_C)
-	$(CTFCONVERT) -L VERSION $@
-
-docker_common.o: $(DOCKER_DIR)/src/docker-common.c
-	$(COMPILE_C)
-	$(CTFCONVERT) -L VERSION $@
-
-%.o: $(DOCKER_DIR)/json-nvlist/%.c
-	$(COMPILE_C)
-	$(CTFCONVERT) -L VERSION $@
+$(PROGRAM): $(OBJS)
+	$(LINK.c) $^ $(LIBS)
+	$(CTFCONVERT) -l $(BUILDSTAMP) $@
 
 #
 # Installation
@@ -133,3 +63,5 @@ install: $(DESTDIR)/usr/lib/brand/lx/$(PROGRAM)
 
 $(DESTDIR)/usr/lib/brand/lx/$(PROGRAM): $(PROGRAM)
 	$(INSTALL_PROG)
+
+include		$(BASE)/Makefile.targ
diff --git a/src/nictagadm b/src/nictagadm
index 92a626ed..8c2e9d91 100755
--- a/src/nictagadm
+++ b/src/nictagadm
@@ -11,7 +11,7 @@
 #
 
 #
-# Copyright (c) 2016 Joyent, Inc. All rights reserved.
+# Copyright (c) 2018, Joyent, Inc.
 #
 
 #
@@ -20,6 +20,7 @@
 
 PATH=/usr/bin:/usr/sbin
 . /lib/sdc/config.sh
+. /lib/sdc/usb-key.sh
 
 CMD=
 CONF=
@@ -309,25 +310,7 @@ function mount_usb()
         return 0
     fi
 
-    USBKEYS=$(disklist -a)
-    for key in $USBKEYS; do
-        if [[ $(fstyp "/dev/dsk/${key}p0:1") == 'pcfs' ]]; then
-            mount -F pcfs -o foldcase,noatime "/dev/dsk/${key}p0:1" "$USB_MNT"
-            if (( $? == 0 )); then
-                if [[ ! -f $USB_MNT/.joyliveusb ]]; then
-                    umount "$USB_MNT"
-                else
-                    break
-                fi
-            fi
-        fi
-    done
-
-    typ=$(awk -v "mnt=$USB_MNT" '$2 == mnt { print $3 }' /etc/mnttab)
-    if [[ -z $typ ]]; then
-        verbose "Could not mount $USB_MNT"
-        return 0
-    fi
+    mount_usb_key || fatal 'failed to mount USB key'
 
     if [[ ! -f $USB_CONFIG ]]; then
         verbose "$USB_CONFIG does not exist"
@@ -354,13 +337,7 @@ function umount_usb()
         return 0
     fi
 
-    typ=$(awk -v "mnt=$USB_MNT" '$2 == mnt { print $3 }' /etc/mnttab)
-    if [[ -z $typ ]]; then
-        verbose "USB key no longer mounted: not unmounting"
-        return 0
-    fi
-
-    umount "$USB_MNT"
+    unmount_usb_key || fatal 'failed to unmount USB key'
 }
 
 
diff --git a/src/node_modules/disklayout.js b/src/node_modules/disklayout.js
index c2f5ea93..234967d0 100644
--- a/src/node_modules/disklayout.js
+++ b/src/node_modules/disklayout.js
@@ -14,7 +14,7 @@ var Z1_MAX = 6;
 var Z2_MIN = 7;
 var Z2_MAX = 12;
 var Z3_MIN = 9;
-var Z3_MAX = 15;
+var Z3_MAX = 20;
 
 /*
  * Returns the rounded-off capacity in GB.  The purpose of this is to
diff --git a/src/routeinfo/Makefile b/src/routeinfo/Makefile
index 39c3bc83..178d22c2 100644
--- a/src/routeinfo/Makefile
+++ b/src/routeinfo/Makefile
@@ -10,107 +10,46 @@
 #
 
 #
-# Copyright (c) 2017, Joyent, Inc.
+# Copyright (c) 2019, Joyent, Inc.
 #
 
-BASE :=		$(PWD)
-DESTDIR =	$(BASE)/../../proto
-NATIVEDIR =	$(BASE)/../../proto.strap
+BASE :=		$(CURDIR)/../
 
-PROGRAM =	routeinfo
-
-GCC =		$(NATIVEDIR)/usr/bin/gcc
-GXX =		$(NATIVEDIR)/usr/bin/g++
-
-SYSINCDIRS =	/usr/include
-SYSLIBDIRS =	/usr/lib /lib
+include		$(BASE)/Makefile.defs
 
-CFLAGS =	-std=gnu99 -Wall -Wextra -Werror -m32 -g \
-		-I$(DOCKER_DIR) \
-		-Wno-unused-parameter
-CPPFLAGS =	$(SYSINCDIRS:%=-isystem $(DESTDIR)/%)
-LDFLAGS =	$(SYSLIBDIRS:%=-L$(DESTDIR)/%) \
-		-Wl,-zassert-deflib -Wl,-zfatal-warnings
+PROGRAM =	routeinfo
 
-STRINGS_DIR =	$(BASE)/../common/strings
-DOCKER_DIR =	$(BASE)/../dockerinit
+CFLAGS +=	$(DEBUG_FLAGS) -m32 -I$(DOCKER_DIR) -I$(STRINGS_DIR) \
+		-I$(DOCKER_DIR)/mdata-client -I$(DOCKER_DIR)/json-nvlist \
+		 -Wno-unused-parameter -D__HAVE_BOOLEAN_T
 
-ROUTEINFO_OBJECTS = \
+ROUTEINFO_OBJS = \
 		main.o
 
-MDATA_OBJECTS = \
-		dynstr.o \
-		proto.o \
-		common.o \
-		base64.o \
-		crc32.o \
-		reqid.o \
-		sunos.o \
-		unix_common.o
-
-custr.o :	CFLAGS += -I$(STRINGS_DIR)
-mdata_%.o :	CFLAGS += -I$(DOCKER_DIR)/mdata-client -D__HAVE_BOOLEAN_T
-
-OBJECTS = \
-		$(MDATA_OBJECTS:%=mdata_%) \
+OBJS = \
+		$(MDATA_OBJS) \
+		$(ROUTEINFO_OBJS) \
 		custr.o \
-		json-nvlist.o \
-		main.o
-
-json-nvlist.o :	CFLAGS += -I$(DOCKER_DIR)/json-nvlist -I$(STRINGS_DIR)
+		json-nvlist.o
 
 LIBS =		-lnvpair -lnsl -lsocket -lsmbios
 
-CTFCONVERT =	/usr/bin/true
-CTFMERGE =	/usr/bin/true
-
-CC=$(GCC)
-CFLAGS +=	-Wall -Wextra -Werror -D__HAVE_BOOLEAN_T -m32
-CSTYLE =	../../tools/cstyle
-
-COMPILE_C =	$(CC) $(CPPFLAGS) $(LDFLAGS) $(CFLAGS) -c -o $@ $<
-
-INSTALL_PROG =	mkdir -p $(@D) && rm -f $@ && cp $^ $@ && \
-		chmod 755 $@ && touch $@
-
 .PHONY: all
 all: $(PROGRAM)
 
 .PHONY: check
-check: $(ROUTEINFO_OBJECTS:%.o=%.check)
+check: $(ROUTEINFO_OBJS:%.o=%.check)
 
 %.check: %.c
 	$(CSTYLE) -cPp $<
 
-lint:
-	/usr/bin/true
-
 clean:
-	rm -f $(OBJECTS)
+	rm -f $(OBJS)
 	rm -f $(PROGRAM)
 
-#
-# Compilation and linking targets
-#
-$(PROGRAM): $(OBJECTS)
-	$(CC) $(CPPFLAGS) $(LDFLAGS) $(CFLAGS) -o $@ $(OBJECTS) $(LIBS)
-	$(CTFMERGE) -L VERSION -o $@ $(OBJECTS)
-
-%.o: $(STRINGS_DIR)/%.c
-	$(COMPILE_C)
-	$(CTFCONVERT) -L VERSION $@
-
-mdata_%.o: $(DOCKER_DIR)/mdata-client/%.c
-	$(COMPILE_C)
-	$(CTFCONVERT) -L VERSION $@
-
-mdata_%.o: $(DOCKER_DIR)/mdata-client/plat/%.c
-	$(COMPILE_C)
-	$(CTFCONVERT) -L VERSION $@
-
-%.o: $(DOCKER_DIR)/json-nvlist/%.c
-	$(COMPILE_C)
-	$(CTFCONVERT) -L VERSION $@
+$(PROGRAM): $(OBJS)
+	$(LINK.c) $^ $(LIBS)
+	$(CTFCONVERT) -l $(BUILDSTAMP) $@
 
 #
 # Installation
@@ -120,3 +59,5 @@ install: $(DESTDIR)/usr/lib/brand/lx/$(PROGRAM)
 
 $(DESTDIR)/usr/lib/brand/lx/$(PROGRAM): $(PROGRAM)
 	$(INSTALL_PROG)
+
+include		$(BASE)/Makefile.targ
diff --git a/src/test/disklayout/16.di.w16.z3.out b/src/test/disklayout/16.di.w16.z3.out
deleted file mode 100644
index 8ddb70af..00000000
--- a/src/test/disklayout/16.di.w16.z3.out
+++ /dev/null
@@ -1 +0,0 @@
-fatal error: 16 is an invalid width for raidz3 and 16 disks (min: 9, max: 15)
diff --git a/src/test/disklayout/36.0s.w17.z3.out b/src/test/disklayout/36.0s.w17.z3.out
new file mode 100644
index 00000000..fac9cbfd
--- /dev/null
+++ b/src/test/disklayout/36.0s.w17.z3.out
@@ -0,0 +1,262 @@
+{
+	"vdevs": [
+		{
+			"type": "raidz3",
+			"devices": [
+				{
+					"name": "disk00",
+					"vid": "MFG",
+					"pid": "DISK",
+					"size": "600127266816",
+					"solid_state": false
+				},
+				{
+					"name": "disk01",
+					"vid": "MFG",
+					"pid": "DISK",
+					"size": "600127266816",
+					"solid_state": false
+				},
+				{
+					"name": "disk02",
+					"vid": "MFG",
+					"pid": "DISK",
+					"size": "600127266816",
+					"solid_state": false
+				},
+				{
+					"name": "disk03",
+					"vid": "MFG",
+					"pid": "DISK",
+					"size": "600127266816",
+					"solid_state": false
+				},
+				{
+					"name": "disk04",
+					"vid": "MFG",
+					"pid": "DISK",
+					"size": "600127266816",
+					"solid_state": false
+				},
+				{
+					"name": "disk05",
+					"vid": "MFG",
+					"pid": "DISK",
+					"size": "600127266816",
+					"solid_state": false
+				},
+				{
+					"name": "disk06",
+					"vid": "MFG",
+					"pid": "DISK",
+					"size": "600127266816",
+					"solid_state": false
+				},
+				{
+					"name": "disk07",
+					"vid": "MFG",
+					"pid": "DISK",
+					"size": "600127266816",
+					"solid_state": false
+				},
+				{
+					"name": "disk08",
+					"vid": "MFG",
+					"pid": "DISK",
+					"size": "600127266816",
+					"solid_state": false
+				},
+				{
+					"name": "disk09",
+					"vid": "MFG",
+					"pid": "DISK",
+					"size": "600127266816",
+					"solid_state": false
+				},
+				{
+					"name": "disk0a",
+					"vid": "MFG",
+					"pid": "DISK",
+					"size": "600127266816",
+					"solid_state": false
+				},
+				{
+					"name": "disk0b",
+					"vid": "MFG",
+					"pid": "DISK",
+					"size": "600127266816",
+					"solid_state": false
+				},
+				{
+					"name": "disk0c",
+					"vid": "MFG",
+					"pid": "DISK",
+					"size": "600127266816",
+					"solid_state": false
+				},
+				{
+					"name": "disk0d",
+					"vid": "MFG",
+					"pid": "DISK",
+					"size": "600127266816",
+					"solid_state": false
+				},
+				{
+					"name": "disk0e",
+					"vid": "MFG",
+					"pid": "DISK",
+					"size": "600127266816",
+					"solid_state": false
+				},
+				{
+					"name": "disk0f",
+					"vid": "MFG",
+					"pid": "DISK",
+					"size": "600127266816",
+					"solid_state": false
+				},
+				{
+					"name": "disk10",
+					"vid": "MFG",
+					"pid": "DISK",
+					"size": "600127266816",
+					"solid_state": false
+				}
+			]
+		},
+		{
+			"type": "raidz3",
+			"devices": [
+				{
+					"name": "disk11",
+					"vid": "MFG",
+					"pid": "DISK",
+					"size": "600127266816",
+					"solid_state": false
+				},
+				{
+					"name": "disk12",
+					"vid": "MFG",
+					"pid": "DISK",
+					"size": "600127266816",
+					"solid_state": false
+				},
+				{
+					"name": "disk13",
+					"vid": "MFG",
+					"pid": "DISK",
+					"size": "600127266816",
+					"solid_state": false
+				},
+				{
+					"name": "disk14",
+					"vid": "MFG",
+					"pid": "DISK",
+					"size": "600127266816",
+					"solid_state": false
+				},
+				{
+					"name": "disk15",
+					"vid": "MFG",
+					"pid": "DISK",
+					"size": "600127266816",
+					"solid_state": false
+				},
+				{
+					"name": "disk16",
+					"vid": "MFG",
+					"pid": "DISK",
+					"size": "600127266816",
+					"solid_state": false
+				},
+				{
+					"name": "disk17",
+					"vid": "MFG",
+					"pid": "DISK",
+					"size": "600127266816",
+					"solid_state": false
+				},
+				{
+					"name": "disk18",
+					"vid": "MFG",
+					"pid": "DISK",
+					"size": "600127266816",
+					"solid_state": false
+				},
+				{
+					"name": "disk19",
+					"vid": "MFG",
+					"pid": "DISK",
+					"size": "600127266816",
+					"solid_state": false
+				},
+				{
+					"name": "disk1a",
+					"vid": "MFG",
+					"pid": "DISK",
+					"size": "600127266816",
+					"solid_state": false
+				},
+				{
+					"name": "disk1b",
+					"vid": "MFG",
+					"pid": "DISK",
+					"size": "600127266816",
+					"solid_state": false
+				},
+				{
+					"name": "disk1c",
+					"vid": "MFG",
+					"pid": "DISK",
+					"size": "600127266816",
+					"solid_state": false
+				},
+				{
+					"name": "disk1d",
+					"vid": "MFG",
+					"pid": "DISK",
+					"size": "600127266816",
+					"solid_state": false
+				},
+				{
+					"name": "disk1e",
+					"vid": "MFG",
+					"pid": "DISK",
+					"size": "600127266816",
+					"solid_state": false
+				},
+				{
+					"name": "disk1f",
+					"vid": "MFG",
+					"pid": "DISK",
+					"size": "600127266816",
+					"solid_state": false
+				},
+				{
+					"name": "disk20",
+					"vid": "MFG",
+					"pid": "DISK",
+					"size": "600127266816",
+					"solid_state": false
+				},
+				{
+					"name": "disk21",
+					"vid": "MFG",
+					"pid": "DISK",
+					"size": "600127266816",
+					"solid_state": false
+				}
+			]
+		}
+	],
+	"capacity": 16803563470848,
+	"logs": [
+		{
+			"name": "disk23",
+			"vid": "MFG",
+			"pid": "DISK",
+			"size": "600127266816",
+			"solid_state": true
+		}
+	]
+}
diff --git a/src/test/disklayout/36.di b/src/test/disklayout/36.di
new file mode 100644
index 00000000..9a8714d0
--- /dev/null
+++ b/src/test/disklayout/36.di
@@ -0,0 +1,37 @@
+SCSI	disk00	MFG	DISK	600127266816	no	no
+SCSI	disk01	MFG	DISK	600127266816	no	no
+SCSI	disk02	MFG	DISK	600127266816	no	no
+SCSI	disk03	MFG	DISK	600127266816	no	no
+SCSI	disk04	MFG	DISK	600127266816	no	no
+SCSI	disk05	MFG	DISK	600127266816	no	no
+SCSI	disk06	MFG	DISK	600127266816	no	no
+SCSI	disk07	MFG	DISK	600127266816	no	no
+SCSI	disk08	MFG	DISK	600127266816	no	no
+SCSI	disk09	MFG	DISK	600127266816	no	no
+SCSI	disk0a	MFG	DISK	600127266816	no	no
+SCSI	disk0b	MFG	DISK	600127266816	no	no
+SCSI	disk0c	MFG	DISK	600127266816	no	no
+SCSI	disk0d	MFG	DISK	600127266816	no	no
+SCSI	disk0e	MFG	DISK	600127266816	no	no
+SCSI	disk0f	MFG	DISK	600127266816	no	no
+SCSI	disk10	MFG	DISK	600127266816	no	no
+SCSI	disk11	MFG	DISK	600127266816	no	no
+SCSI	disk12	MFG	DISK	600127266816	no	no
+SCSI	disk13	MFG	DISK	600127266816	no	no
+SCSI	disk14	MFG	DISK	600127266816	no	no
+SCSI	disk15	MFG	DISK	600127266816	no	no
+SCSI	disk16	MFG	DISK	600127266816	no	no
+SCSI	disk17	MFG	DISK	600127266816	no	no
+SCSI	disk18	MFG	DISK	600127266816	no	no
+SCSI	disk19	MFG	DISK	600127266816	no	no
+SCSI	disk1a	MFG	DISK	600127266816	no	no
+SCSI	disk1b	MFG	DISK	600127266816	no	no
+SCSI	disk1c	MFG	DISK	600127266816	no	no
+SCSI	disk1d	MFG	DISK	600127266816	no	no
+SCSI	disk1e	MFG	DISK	600127266816	no	no
+SCSI	disk1f	MFG	DISK	600127266816	no	no
+SCSI	disk20	MFG	DISK	600127266816	no	no
+SCSI	disk21	MFG	DISK	600127266816	no	no
+SCSI	disk22	MFG	DISK	600127266816	no	no
+SCSI	disk23	MFG	DISK	600127266816	no	yes
+USB	key0	USBMFG	USB Key	15737028608	yes	no
diff --git a/src/test/disklayout/36.di.0s.out b/src/test/disklayout/36.di.0s.out
new file mode 100644
index 00000000..cc8dc127
--- /dev/null
+++ b/src/test/disklayout/36.di.0s.out
@@ -0,0 +1,284 @@
+{
+	"vdevs": [
+		{
+			"type": "raidz2",
+			"devices": [
+				{
+					"name": "disk00",
+					"vid": "MFG",
+					"pid": "DISK",
+					"size": "600127266816",
+					"solid_state": false
+				},
+				{
+					"name": "disk01",
+					"vid": "MFG",
+					"pid": "DISK",
+					"size": "600127266816",
+					"solid_state": false
+				},
+				{
+					"name": "disk02",
+					"vid": "MFG",
+					"pid": "DISK",
+					"size": "600127266816",
+					"solid_state": false
+				},
+				{
+					"name": "disk03",
+					"vid": "MFG",
+					"pid": "DISK",
+					"size": "600127266816",
+					"solid_state": false
+				},
+				{
+					"name": "disk04",
+					"vid": "MFG",
+					"pid": "DISK",
+					"size": "600127266816",
+					"solid_state": false
+				},
+				{
+					"name": "disk05",
+					"vid": "MFG",
+					"pid": "DISK",
+					"size": "600127266816",
+					"solid_state": false
+				},
+				{
+					"name": "disk06",
+					"vid": "MFG",
+					"pid": "DISK",
+					"size": "600127266816",
+					"solid_state": false
+				}
+			]
+		},
+		{
+			"type": "raidz2",
+			"devices": [
+				{
+					"name": "disk07",
+					"vid": "MFG",
+					"pid": "DISK",
+					"size": "600127266816",
+					"solid_state": false
+				},
+				{
+					"name": "disk08",
+					"vid": "MFG",
+					"pid": "DISK",
+					"size": "600127266816",
+					"solid_state": false
+				},
+				{
+					"name": "disk09",
+					"vid": "MFG",
+					"pid": "DISK",
+					"size": "600127266816",
+					"solid_state": false
+				},
+				{
+					"name": "disk0a",
+					"vid": "MFG",
+					"pid": "DISK",
+					"size": "600127266816",
+					"solid_state": false
+				},
+				{
+					"name": "disk0b",
+					"vid": "MFG",
+					"pid": "DISK",
+					"size": "600127266816",
+					"solid_state": false
+				},
+				{
+					"name": "disk0c",
+					"vid": "MFG",
+					"pid": "DISK",
+					"size": "600127266816",
+					"solid_state": false
+				},
+				{
+					"name": "disk0d",
+					"vid": "MFG",
+					"pid": "DISK",
+					"size": "600127266816",
+					"solid_state": false
+				}
+			]
+		},
+		{
+			"type": "raidz2",
+			"devices": [
+				{
+					"name": "disk0e",
+					"vid": "MFG",
+					"pid": "DISK",
+					"size": "600127266816",
+					"solid_state": false
+				},
+				{
+					"name": "disk0f",
+					"vid": "MFG",
+					"pid": "DISK",
+					"size": "600127266816",
+					"solid_state": false
+				},
+				{
+					"name": "disk10",
+					"vid": "MFG",
+					"pid": "DISK",
+					"size": "600127266816",
+					"solid_state": false
+				},
+				{
+					"name": "disk11",
+					"vid": "MFG",
+					"pid": "DISK",
+					"size": "600127266816",
+					"solid_state": false
+				},
+				{
+					"name": "disk12",
+					"vid": "MFG",
+					"pid": "DISK",
+					"size": "600127266816",
+					"solid_state": false
+				},
+				{
+					"name": "disk13",
+					"vid": "MFG",
+					"pid": "DISK",
+					"size": "600127266816",
+					"solid_state": false
+				},
+				{
+					"name": "disk14",
+					"vid": "MFG",
+					"pid": "DISK",
+					"size": "600127266816",
+					"solid_state": false
+				}
+			]
+		},
+		{
+			"type": "raidz2",
+			"devices": [
+				{
+					"name": "disk15",
+					"vid": "MFG",
+					"pid": "DISK",
+					"size": "600127266816",
+					"solid_state": false
+				},
+				{
+					"name": "disk16",
+					"vid": "MFG",
+					"pid": "DISK",
+					"size": "600127266816",
+					"solid_state": false
+				},
+				{
+					"name": "disk17",
+					"vid": "MFG",
+					"pid": "DISK",
+					"size": "600127266816",
+					"solid_state": false
+				},
+				{
+					"name": "disk18",
+					"vid": "MFG",
+					"pid": "DISK",
+					"size": "600127266816",
+					"solid_state": false
+				},
+				{
+					"name": "disk19",
+					"vid": "MFG",
+					"pid": "DISK",
+					"size": "600127266816",
+					"solid_state": false
+				},
+				{
+					"name": "disk1a",
+					"vid": "MFG",
+					"pid": "DISK",
+					"size": "600127266816",
+					"solid_state": false
+				},
+				{
+					"name": "disk1b",
+					"vid": "MFG",
+					"pid": "DISK",
+					"size": "600127266816",
+					"solid_state": false
+				}
+			]
+		},
+		{
+			"type": "raidz2",
+			"devices": [
+				{
+					"name": "disk1c",
+					"vid": "MFG",
+					"pid": "DISK",
+					"size": "600127266816",
+					"solid_state": false
+				},
+				{
+					"name": "disk1d",
+					"vid": "MFG",
+					"pid": "DISK",
+					"size": "600127266816",
+					"solid_state": false
+				},
+				{
+					"name": "disk1e",
+					"vid": "MFG",
+					"pid": "DISK",
+					"size": "600127266816",
+					"solid_state": false
+				},
+				{
+					"name": "disk1f",
+					"vid": "MFG",
+					"pid": "DISK",
+					"size": "600127266816",
+					"solid_state": false
+				},
+				{
+					"name": "disk20",
+					"vid": "MFG",
+					"pid": "DISK",
+					"size": "600127266816",
+					"solid_state": false
+				},
+				{
+					"name": "disk21",
+					"vid": "MFG",
+					"pid": "DISK",
+					"size": "600127266816",
+					"solid_state": false
+				},
+				{
+					"name": "disk22",
+					"vid": "MFG",
+					"pid": "DISK",
+					"size": "600127266816",
+					"solid_state": false
+				}
+			]
+		}
+	],
+	"capacity": 15003181670400,
+	"logs": [
+		{
+			"name": "disk23",
+			"vid": "MFG",
+			"pid": "DISK",
+			"size": "600127266816",
+			"solid_state": true
+		}
+	]
+}
diff --git a/src/test/disklayout/36.di.1s.out b/src/test/disklayout/36.di.1s.out
new file mode 100644
index 00000000..be1bda46
--- /dev/null
+++ b/src/test/disklayout/36.di.1s.out
@@ -0,0 +1 @@
+fatal error: no acceptable raidz layout is possible with 35 disks and 1 spare
diff --git a/src/test/disklayout/36.di.out b/src/test/disklayout/36.di.out
new file mode 100644
index 00000000..29080f72
--- /dev/null
+++ b/src/test/disklayout/36.di.out
@@ -0,0 +1,276 @@
+{
+	"spares": [
+		{
+			"name": "disk21",
+			"vid": "MFG",
+			"pid": "DISK",
+			"size": "600127266816",
+			"solid_state": false
+		},
+		{
+			"name": "disk22",
+			"vid": "MFG",
+			"pid": "DISK",
+			"size": "600127266816",
+			"solid_state": false
+		}
+	],
+	"vdevs": [
+		{
+			"type": "raidz2",
+			"devices": [
+				{
+					"name": "disk00",
+					"vid": "MFG",
+					"pid": "DISK",
+					"size": "600127266816",
+					"solid_state": false
+				},
+				{
+					"name": "disk01",
+					"vid": "MFG",
+					"pid": "DISK",
+					"size": "600127266816",
+					"solid_state": false
+				},
+				{
+					"name": "disk02",
+					"vid": "MFG",
+					"pid": "DISK",
+					"size": "600127266816",
+					"solid_state": false
+				},
+				{
+					"name": "disk03",
+					"vid": "MFG",
+					"pid": "DISK",
+					"size": "600127266816",
+					"solid_state": false
+				},
+				{
+					"name": "disk04",
+					"vid": "MFG",
+					"pid": "DISK",
+					"size": "600127266816",
+					"solid_state": false
+				},
+				{
+					"name": "disk05",
+					"vid": "MFG",
+					"pid": "DISK",
+					"size": "600127266816",
+					"solid_state": false
+				},
+				{
+					"name": "disk06",
+					"vid": "MFG",
+					"pid": "DISK",
+					"size": "600127266816",
+					"solid_state": false
+				},
+				{
+					"name": "disk07",
+					"vid": "MFG",
+					"pid": "DISK",
+					"size": "600127266816",
+					"solid_state": false
+				},
+				{
+					"name": "disk08",
+					"vid": "MFG",
+					"pid": "DISK",
+					"size": "600127266816",
+					"solid_state": false
+				},
+				{
+					"name": "disk09",
+					"vid": "MFG",
+					"pid": "DISK",
+					"size": "600127266816",
+					"solid_state": false
+				},
+				{
+					"name": "disk0a",
+					"vid": "MFG",
+					"pid": "DISK",
+					"size": "600127266816",
+					"solid_state": false
+				}
+			]
+		},
+		{
+			"type": "raidz2",
+			"devices": [
+				{
+					"name": "disk0b",
+					"vid": "MFG",
+					"pid": "DISK",
+					"size": "600127266816",
+					"solid_state": false
+				},
+				{
+					"name": "disk0c",
+					"vid": "MFG",
+					"pid": "DISK",
+					"size": "600127266816",
+					"solid_state": false
+				},
+				{
+					"name": "disk0d",
+					"vid": "MFG",
+					"pid": "DISK",
+					"size": "600127266816",
+					"solid_state": false
+				},
+				{
+					"name": "disk0e",
+					"vid": "MFG",
+					"pid": "DISK",
+					"size": "600127266816",
+					"solid_state": false
+				},
+				{
+					"name": "disk0f",
+					"vid": "MFG",
+					"pid": "DISK",
+					"size": "600127266816",
+					"solid_state": false
+				},
+				{
+					"name": "disk10",
+					"vid": "MFG",
+					"pid": "DISK",
+					"size": "600127266816",
+					"solid_state": false
+				},
+				{
+					"name": "disk11",
+					"vid": "MFG",
+					"pid": "DISK",
+					"size": "600127266816",
+					"solid_state": false
+				},
+				{
+					"name": "disk12",
+					"vid": "MFG",
+					"pid": "DISK",
+					"size": "600127266816",
+					"solid_state": false
+				},
+				{
+					"name": "disk13",
+					"vid": "MFG",
+					"pid": "DISK",
+					"size": "600127266816",
+					"solid_state": false
+				},
+				{
+					"name": "disk14",
+					"vid": "MFG",
+					"pid": "DISK",
+					"size": "600127266816",
+					"solid_state": false
+				},
+				{
+					"name": "disk15",
+					"vid": "MFG",
+					"pid": "DISK",
+					"size": "600127266816",
+					"solid_state": false
+				}
+			]
+		},
+		{
+			"type": "raidz2",
+			"devices": [
+				{
+					"name": "disk16",
+					"vid": "MFG",
+					"pid": "DISK",
+					"size": "600127266816",
+					"solid_state": false
+				},
+				{
+					"name": "disk17",
+					"vid": "MFG",
+					"pid": "DISK",
+					"size": "600127266816",
+					"solid_state": false
+				},
+				{
+					"name": "disk18",
+					"vid": "MFG",
+					"pid": "DISK",
+					"size": "600127266816",
+					"solid_state": false
+				},
+				{
+					"name": "disk19",
+					"vid": "MFG",
+					"pid": "DISK",
+					"size": "600127266816",
+					"solid_state": false
+				},
+				{
+					"name": "disk1a",
+					"vid": "MFG",
+					"pid": "DISK",
+					"size": "600127266816",
+					"solid_state": false
+				},
+				{
+					"name": "disk1b",
+					"vid": "MFG",
+					"pid": "DISK",
+					"size": "600127266816",
+					"solid_state": false
+				},
+				{
+					"name": "disk1c",
+					"vid": "MFG",
+					"pid": "DISK",
+					"size": "600127266816",
+					"solid_state": false
+				},
+				{
+					"name": "disk1d",
+					"vid": "MFG",
+					"pid": "DISK",
+					"size": "600127266816",
+					"solid_state": false
+				},
+				{
+					"name": "disk1e",
+					"vid": "MFG",
+					"pid": "DISK",
+					"size": "600127266816",
+					"solid_state": false
+				},
+				{
+					"name": "disk1f",
+					"vid": "MFG",
+					"pid": "DISK",
+					"size": "600127266816",
+					"solid_state": false
+				},
+				{
+					"name": "disk20",
+					"vid": "MFG",
+					"pid": "DISK",
+					"size": "600127266816",
+					"solid_state": false
+				}
+			]
+		}
+	],
+	"capacity": 16203436204032,
+	"logs": [
+		{
+			"name": "disk23",
+			"vid": "MFG",
+			"pid": "DISK",
+			"size": "600127266816",
+			"solid_state": true
+		}
+	]
+}
diff --git a/src/test/disklayout/60.di.w21.z3.out b/src/test/disklayout/60.di.w21.z3.out
new file mode 100644
index 00000000..d7380175
--- /dev/null
+++ b/src/test/disklayout/60.di.w21.z3.out
@@ -0,0 +1 @@
+fatal error: 21 is an invalid width for raidz3 and 60 disks (min: 9, max: 20)
diff --git a/src/test/disklayout/run b/src/test/disklayout/run
index de82aca2..70a7e278 100755
--- a/src/test/disklayout/run
+++ b/src/test/disklayout/run
@@ -136,6 +136,11 @@ printf "%-16s " 60.0s.w15.out
 diff -u 60.di.0s.w15.z3.out /var/tmp/s60.out
 rm -f /var/tmp/s60.out
 
+disklayout -s 0 -w 17 -f 36.di > /var/tmp/s34.out
+printf "%-16s " 36.0s.w17.z3.out
+diff -u 36.0s.w17.z3.out /var/tmp/s34.out
+rm -f /var/tmp/s34.out
+
 disklayout -w 15 -f s16.di > /var/tmp/s16.out
 printf "%-16s " 16.w15.out
 diff -u s16.di.w15.out /var/tmp/s16.out
@@ -181,9 +186,9 @@ printf "%-16s " 7.w6.z2.out
 diff -u 7.di.w6.z2.out /var/tmp/err.out
 rm -f /var/tmp/err.out
 
-disklayout -w 16 -f s16.di raidz3 > /var/tmp/err.out
-printf "%-16s " 16.w16.z3.out
-diff -u 16.di.w16.z3.out /var/tmp/err.out
+disklayout -w 21 -f 60.di raidz3 > /var/tmp/err.out
+printf "%-16s " 60.di.w21.z3.out
+diff -u 60.di.w21.z3.out /var/tmp/err.out
 rm -f /var/tmp/err.out
 
 disklayout -w 15 -s 2 -f s16.di raidz3 > /var/tmp/err.out
diff --git a/src/test/disklayout/s16.di.z3-0.out b/src/test/disklayout/s16.di.z3-0.out
index 1da168bd..7c164576 100644
--- a/src/test/disklayout/s16.di.z3-0.out
+++ b/src/test/disklayout/s16.di.z3-0.out
@@ -1 +1,122 @@
-fatal error: no acceptable raidz3 layout is possible with 16 disks and 0 spares
+{
+	"vdevs": [
+		{
+			"type": "raidz3",
+			"devices": [
+				{
+					"name": "disk0",
+					"vid": "ATA",
+					"pid": "INTEL SSDSC2BX01",
+					"size": "1600321314816",
+					"solid_state": true
+				},
+				{
+					"name": "disk1",
+					"vid": "ATA",
+					"pid": "INTEL SSDSC2BX01",
+					"size": "1600321314816",
+					"solid_state": true
+				},
+				{
+					"name": "disk2",
+					"vid": "ATA",
+					"pid": "INTEL SSDSC2BX01",
+					"size": "1600321314816",
+					"solid_state": true
+				},
+				{
+					"name": "disk3",
+					"vid": "ATA",
+					"pid": "INTEL SSDSC2BX01",
+					"size": "1600321314816",
+					"solid_state": true
+				},
+				{
+					"name": "disk4",
+					"vid": "ATA",
+					"pid": "INTEL SSDSC2BX01",
+					"size": "1600321314816",
+					"solid_state": true
+				},
+				{
+					"name": "disk5",
+					"vid": "ATA",
+					"pid": "INTEL SSDSC2BX01",
+					"size": "1600321314816",
+					"solid_state": true
+				},
+				{
+					"name": "disk6",
+					"vid": "ATA",
+					"pid": "INTEL SSDSC2BX01",
+					"size": "1600321314816",
+					"solid_state": true
+				},
+				{
+					"name": "disk7",
+					"vid": "ATA",
+					"pid": "INTEL SSDSC2BX01",
+					"size": "1600321314816",
+					"solid_state": true
+				},
+				{
+					"name": "disk8",
+					"vid": "ATA",
+					"pid": "INTEL SSDSC2BX01",
+					"size": "1600321314816",
+					"solid_state": true
+				},
+				{
+					"name": "disk9",
+					"vid": "ATA",
+					"pid": "INTEL SSDSC2BX01",
+					"size": "1600321314816",
+					"solid_state": true
+				},
+				{
+					"name": "diska",
+					"vid": "ATA",
+					"pid": "INTEL SSDSC2BX01",
+					"size": "1600321314816",
+					"solid_state": true
+				},
+				{
+					"name": "diskb",
+					"vid": "ATA",
+					"pid": "INTEL SSDSC2BX01",
+					"size": "1600321314816",
+					"solid_state": true
+				},
+				{
+					"name": "diskc",
+					"vid": "ATA",
+					"pid": "INTEL SSDSC2BX01",
+					"size": "1600321314816",
+					"solid_state": true
+				},
+				{
+					"name": "diskd",
+					"vid": "ATA",
+					"pid": "INTEL SSDSC2BX01",
+					"size": "1600321314816",
+					"solid_state": true
+				},
+				{
+					"name": "diske",
+					"vid": "ATA",
+					"pid": "INTEL SSDSC2BX01",
+					"size": "1600321314816",
+					"solid_state": true
+				},
+				{
+					"name": "diskf",
+					"vid": "ATA",
+					"pid": "INTEL SSDSC2BX01",
+					"size": "1600321314816",
+					"solid_state": true
+				}
+			]
+		}
+	],
+	"capacity": 20804177092608
+}
diff --git a/src/vm/node_modules/vminfod/vminfod.js b/src/vm/node_modules/vminfod/vminfod.js
index b5131232..2039f4c9 100644
--- a/src/vm/node_modules/vminfod/vminfod.js
+++ b/src/vm/node_modules/vminfod/vminfod.js
@@ -736,7 +736,7 @@ Vminfod.prototype.startWatchers = function startWatchers(callback) {
 
     vasync.pipeline({funcs: [
         function startFsWatcher(_, cb) {
-            self.fsw = new FsWatcher({log: self.log, dedup: true});
+            self.fsw = new FsWatcher({log: self.log});
 
             self.fsw.on('event', function fswOnEvent(obj) {
                 self.handleFsEvent(obj);
diff --git a/src/vm/package.json b/src/vm/package.json
index 648002c3..866a6685 100644
--- a/src/vm/package.json
+++ b/src/vm/package.json
@@ -1,7 +1,7 @@
 {
   "name": "vmadm",
   "description": "administrative tool(s) for managing VMs",
-  "version": "1.0.2",
+  "version": "1.0.3",
   "author": "Joyent (joyent.com)",
   "private": true,
   "devDependencies": {
diff --git a/src/vmunbundle.c b/src/vmunbundle.c
index 86f181f5..53350389 100644
--- a/src/vmunbundle.c
+++ b/src/vmunbundle.c
@@ -1,3 +1,7 @@
+/*
+ * Copyright (c) 2019, Joyent, Inc.
+ */
+
 #include <errno.h>
 #include <signal.h>
 #include <stdio.h>
@@ -36,7 +40,7 @@ size_t zfs_receive(int fd, const char * snapshot);
 ssize_t
 write_bytes(int fd, const void *buf, size_t bytes)
 {
-    ssize_t numwritten;
+    ssize_t numwritten = 0;
     void * ptr;
     size_t remain;
 
@@ -61,7 +65,7 @@ ssize_t
 read_bytes(int fd, char *data, size_t bytes)
 {
     size_t remain;
-    ssize_t numread;
+    ssize_t numread = 0;
     ssize_t total_read = 0;
     char *ptr;
 
@@ -314,7 +318,7 @@ main(int argc, char *argv[])
 {
     header_t header;
     char * json = NULL;
-    enum {JSON = 0, DATASET} mode;
+    enum {JSON = 0, DATASET} mode = JSON;
     int res;
 
     progname = argv[0];
diff --git a/tools/build_boot_image b/tools/build_boot_image
new file mode 100755
index 00000000..82d68738
--- /dev/null
+++ b/tools/build_boot_image
@@ -0,0 +1,412 @@
+#!/bin/bash
+#
+# This file and its contents are supplied under the terms of the
+# Common Development and Distribution License ("CDDL"), version 1.0.
+# You may only use this file in accordance with the terms of version
+# 1.0 of the CDDL.
+#
+# A full copy of the text of the CDDL should have accompanied this
+# source.  A copy of the CDDL is also available via the Internet at
+# http://www.illumos.org/license/CDDL.
+#
+
+#
+# Copyright (c) 2019, Joyent, Inc.
+#
+
+#
+# This script automates the process of building ISO and USB images of a SmartOS
+# build.  It can also be used to produce the proforma disk images used by the
+# tools in sdc-headnode.git to produce Triton USB and COAL images.  When
+# building SmartOS media, it uses the latest platform file that's been built.
+# This program can be invoked standalone via the "gmake iso", "gmake usb" and
+# "gmake images" targets of the top-level Makefile in "smartos-live.git".
+#
+# This script needs to be run either as root or as a user that is granted the
+# "Primary Administrator" profile.  When run in a non-global zone, it must be
+# configured with "fs_allowed=ufs,pcfs".
+#
+# Things are complicated here by the fact that we would like to run inside a
+# non-global zone with older kernels.  Most of our partitioning tools such as
+# format do not run well inside a non-global zone, and labeled lofi doesn't
+# have sufficient support either.  So we delegate the tricky bits to
+# format_image.
+#
+# Equally, we can no longer directly mount the root partition for populating:
+# pcfs has no logic of its own for parsing GPT partitions.  So we have to play
+# games using dd(1) to copy the root FS image into the right place based on
+# its partition offset.  We also place the partition layout into the images
+# tarball, so sdc-headnode can do the same.  (As it is, the offset is actually
+# fixed, but that seems like a bad thing to rely on.)
+#
+
+bi_console="text"
+bi_make_iso=0
+bi_proforma_only=0
+bi_nocleanup=0
+bi_imgsz_gb="2"
+bi_imgsz=$(( $bi_imgsz_gb * 1000000000 ))
+bi_wsroot=
+bi_lofi_blkdev=
+bi_lofi_rawdev=
+bi_esp_blkdev=
+bi_usb_image_name=
+bi_rootdir=
+bi_efimnt=
+bi_tmpdir=
+
+function detach_lofi()
+{
+	local readonly dev=$1
+
+	if [[ -z "$dev" ]]; then
+		return
+	fi
+
+	if pfexec lofiadm $dev 2>/dev/null; then
+		print "Detaching LOFI device $dev ... \c"
+		pfexec lofiadm -d $dev
+		print "done"
+	fi
+}
+
+function cleanup()
+{
+	[[ $bi_nocleanup == 1 ]] && return
+
+	print "Cleaning up"
+
+	if mount | grep $bi_efimnt >/dev/null; then
+		pfexec umount $bi_efimnt
+	fi
+
+	if mount | grep $bi_rootdir >/dev/null; then
+		pfexec umount $bi_rootdir
+	fi
+
+	detach_lofi "$bi_lofi_blkdev"
+	detach_lofi "$bi_esp_blkdev"
+
+	pfexec rm -f $bi_tmpdir/esp.img
+	pfexec rm -f $bi_tmpdir/rootfs.img
+	pfexec rm -f $bi_tmpdir/smartos.usb
+	pfexec rm -f $bi_tmpdir/partition.map
+	pfexec rm -f $bi_tmpdir/loader.conf
+	pfexec rm -rf $bi_tmpdir/mnt
+	pfexec rmdir $bi_tmpdir
+}
+
+function fail()
+{
+        printf "$(basename $0): %s\n" "$1" 1>&2
+        exit 1
+}
+
+function usage()
+{
+	[[ ! -z $1 ]] && printf "%s\n\n" "$1" 1>&2
+
+	print -u2 "Usage: $(basename $0) [-I] [-x] [-c console] " \
+	    "[-p <size>] -r <smartos-live repo>"
+	print -u2 " -I\tbuild SmartOS ISO image (default: USB image)"
+	print -u2 " -c\tspecify primary console (e.g. ttyb)"
+	print -u2 " -p\tbuild proforma USB image for Triton (e.g. 1gb)"
+	print -u2 " -x\tdon't cleanup on exit (for debugging use)\n"
+	exit 2
+}
+
+function pfrun()
+{
+	pfexec $*
+	local status=$?
+
+	if [[ $status != 0 ]]; then
+		print -u2 "\nCommand failed: $*\nExit status: $status"
+		exit 1
+	fi
+}
+
+#
+# Construct the EFI System Partition (ESP) image,  We size it at 256 MB, which
+# is intentionally much larger than what we need currently, in order to leave
+# headroom for future projects which may need to store data in the ESP.
+#
+function create_esp()
+{
+	local readonly tmpdir=$1
+	local readonly efimnt=$2
+	local readonly esp_size=256 # MiB
+	local readonly esp_sects=$(( $esp_size * 1024 * 1024 / 512 ))
+
+	pfrun mkfile -n ${esp_size}m $tmpdir/esp.img
+	bi_esp_blkdev=$(pfexec lofiadm -a $tmpdir/esp.img)
+	[[ $? == 0 ]] || fail "Failed to create ESP lofi device"
+	readonly esp_rawdev=${bi_esp_blkdev/lofi/rlofi}
+
+	pfrun mkfs -F pcfs -o b=system,size=$esp_sects,nofdisk,fat=32 \
+	    $esp_rawdev </dev/null
+
+	pfrun mkdir -p $efimnt
+	pfrun mount -F pcfs -o foldcase $bi_esp_blkdev $efimnt
+	pfrun mkdir -p $efimnt/efi/boot
+	pfrun cp $bi_wsroot/proto.boot/boot/loader64.efi \
+	    $efimnt/efi/boot/bootx64.efi
+	pfrun umount $efimnt
+	pfrun lofiadm -d $bi_esp_blkdev
+}
+
+#
+# Populate the root filesystem with all the SmartOS bits, as well as the loader
+# used in legacy boot mode.
+#
+function populate_root()
+{
+	local readonly dir=$1
+
+	print "Installing boot tarball onto root partition ... \c"
+	pfexec cp -r $bi_wsroot/proto.boot/* $dir/
+	print "done"
+
+	print "Customizing boot loader configuration ... \c"
+	readonly shadow=\'\$5\$2HOHRnK3\$NvLlm.1KQBbB0WjoP7xcIwGnllhzp2HnT.mDO7DpxYA\'
+
+	case "$bi_console" in
+	text)	console="text" ;;
+	tty*)	console="$bi_console,text" ;;
+	*)	echo "unknown console $bi_console" 2>&1
+		exit 1 ;;
+	esac
+
+	cat <<EOF >$bi_tmpdir/loader.conf
+console="$console"
+os_console="$bi_console"
+ttya-mode="115200,8,n,1,-"
+ttyb-mode="115200,8,n,1,-"
+ttyc-mode="115200,8,n,1,-"
+ttyd-mode="115200,8,n,1,-"
+loader_logo="smartos"
+loader_brand="smartos"
+root_shadow=${shadow}
+smartos="true"
+EOF
+	pfrun mv $bi_tmpdir/loader.conf $dir/boot/loader.conf
+	pfrun chmod 644 $dir/boot/loader.conf
+	print "done"
+
+	print "Copying platform image to root partition" \
+	    "(this will take a while) ... \c"
+
+	pfexec cp -r $bi_wsroot/output/platform-latest/ $dir/platform
+
+	print "done"
+}
+
+#
+# Build our actual ISO image
+#
+function create_iso()
+{
+	local readonly tmpdir=$1
+	local readonly iso=$2
+	local readonly espimg=$3
+        local readonly uid=$(id -u)
+        local readonly gid=$(id -g)
+
+	pfrun mkdir -p $bi_wsroot/output-iso
+	pfrun mkdir -p $bi_rootdir
+
+	populate_root $bi_rootdir
+
+	pfrun cp $bi_wsroot/proto/boot/cdboot $bi_rootdir/boot/cdboot
+	pfrun cp $espimg $bi_rootdir/boot/efiboot.img
+
+	pfrun mkisofs -quiet -R \
+	    -eltorito-boot boot/cdboot -no-emul-boot -boot-info-table \
+	    -eltorito-alt-boot -eltorito-platform efi \
+	    -eltorito-boot boot/efiboot.img -no-emul-boot \
+	    -o $iso $bi_rootdir
+
+	pfrun chown -R ${uid}:${gid} $bi_wsroot/output-iso
+
+	print "Successfully created $iso"
+}
+
+#
+# Assemble all our boot parts into the disk image (the root partition is copied
+# over later).
+#
+function create_image()
+{
+	local readonly tmpdir=$1
+	local readonly size=$2
+	local readonly file=$3
+
+	pfrun mkfile -n $size $file
+
+	bi_lofi_blkdev=$(pfexec lofiadm -a $file)
+	[[ $? == 0 ]] || fail "Failed to create lofi device"
+
+	pfrun $bi_wsroot/tools/format_image/format_image \
+	    -m $bi_wsroot/proto.boot/boot/pmbr \
+	    -b $bi_wsroot/proto.boot/boot/gptzfsboot -e $tmpdir/esp.img \
+	    -o ${bi_lofi_blkdev/lofi/rlofi} >$tmpdir/partition.map
+
+	pfrun lofiadm -d $bi_lofi_blkdev
+}
+
+#
+# Create the blank root filesystem.
+#
+function create_root()
+{
+	local readonly dev=$1
+	local readonly image=$2
+	local readonly offset=$3
+	local readonly sects=$(( $4 / 512 ))
+
+	print "Creating PCFS filesystem in root partition ... \c"
+	pfrun mkfs -F pcfs -o b=SMARTOSBOOT,size=$sects,nofdisk,fat=32 \
+	    $dev </dev/null
+
+	print "done"
+
+	if [[ $bi_proforma_only == 1 ]]; then
+		return
+	fi
+}
+
+#
+# Copy the root filesystem image into the correct place inside the image.
+#
+function copy_root()
+{
+	local readonly dev=$1
+	local readonly image=$2
+	local readonly offset=$3
+	local readonly bs=1048576
+
+	print "Copying root filesystem ..."
+	pfrun /usr/bin/dd bs=$bs conv=notrunc if=$dev of=$image \
+	    oseek=$(( $offset / $bs )) >/dev/null
+	print "done"
+}
+
+function mount_root()
+{
+	local readonly dev=$1
+	local readonly rootmnt=$2
+	local mntopts="-F pcfs"
+
+	print "Mounting root partition at $rootmnt ... \c"
+	pfrun mkdir -p $rootmnt
+	pfrun mount $mntopts $dev $rootmnt 2>/dev/null
+	print "done"
+}
+
+function copy_results()
+{
+	local readonly outdir=$1
+	local readonly outfile=$2
+	local readonly prefix=$3
+	local readonly uid=$(id -u)
+	local readonly gid=$(id -g)
+
+	mkdir -p $outdir
+	pfrun mv $bi_tmpdir/smartos.usb* $outdir/$outfile
+	pfrun chmod 644 $outdir/$outfile
+	pfrun chown ${uid}:${gid} $outdir/$outfile
+	pfrun cp $bi_tmpdir/partition.map $outdir/${prefix}partition.map
+	pfrun chown ${uid}:${gid} $outdir/${prefix}partition.map
+	print "Successfully created $outdir/$outfile"
+}
+
+export PATH=/usr/bin/:/usr/sbin/:/opt/local/bin
+
+while getopts "Ic:p:r:x" c $@; do
+	case "$c" in
+	I)	bi_make_iso=1 ;;
+	c)	bi_console=${OPTARG} ;;
+	p)	bi_proforma_only=1
+		bi_imgsz_gb=${OPTARG%gb}
+		bi_imgsz=$(( $bi_imgsz_gb * 1000000000 )) ;;
+	r)	bi_wsroot=$(readlink -f $OPTARG) ;;
+	x)	bi_nocleanup=1 ;;
+	:)	usage ;;
+	*)	usage ;;
+	esac
+done
+
+set -eou pipefail
+export SHELLOPTS
+unalias -a
+
+[[ -z "$bi_wsroot" ]] && usage "-r is required"
+
+[[ $bi_proforma_only == 1 ]] && [[ $bi_make_iso == 1 ]] && \
+    usage "-p and -I are mutually exclusive"
+
+[[ -e $bi_wsroot/output/platform-latest ]] || \
+    fail "No platform image found in $bi_wsroot/output"
+
+
+bi_tmpdir=$(mktemp -d -p /var/tmp) || fail "mktemp failed!"
+
+trap cleanup EXIT
+
+bi_efimnt=$bi_tmpdir/mnt/efi
+bi_rootdir=$bi_tmpdir/mnt/root
+bi_usb_image_name=$(readlink -f $bi_wsroot/output/platform-latest)
+bi_usb_image_name=$(basename $bi_usb_image_name)
+iso_image_name="$bi_wsroot/output-iso/${bi_usb_image_name}.iso"
+bi_usb_image_name="${bi_usb_image_name}.usb.gz"
+
+print "Creating EFI System Partition image ... \c"
+create_esp $bi_tmpdir $bi_efimnt
+print "done"
+
+if [[  $bi_make_iso == 1 ]]; then
+	create_iso $bi_tmpdir $iso_image_name $bi_tmpdir/esp.img
+	exit 0
+fi
+
+print "Creating $bi_imgsz_gb GB image at $bi_tmpdir/smartos.usb ... \c"
+create_image $bi_tmpdir $bi_imgsz $bi_tmpdir/smartos.usb
+print "done"
+
+echo "partition.map:"
+cat $bi_tmpdir/partition.map
+
+rootoff=$(nawk '$1 == "root" { print $3 }' <$bi_tmpdir/partition.map)
+rootsize=$(nawk '$1 == "root" { print $4 }' <$bi_tmpdir/partition.map)
+
+pfrun mkfile -n $rootsize $bi_tmpdir/rootfs.img
+
+bi_lofi_blkdev=$(pfexec lofiadm -a $bi_tmpdir/rootfs.img)
+[[ $? == 0 ]] || fail "Failed to create lofi device"
+
+bi_lofi_rawdev=${bi_lofi_blkdev/lofi/rlofi}
+
+create_root $bi_lofi_rawdev $bi_tmpdir/smartos.usb $rootoff $rootsize
+
+#
+# The proforma image's root partition is populated by sdc-headnode, not us.
+#
+if [[ $bi_proforma_only != 1 ]]; then
+	mount_root $bi_lofi_blkdev $bi_rootdir
+	populate_root $bi_rootdir
+	pfrun umount $bi_rootdir
+fi
+
+copy_root $bi_lofi_rawdev $bi_tmpdir/smartos.usb $rootoff
+
+pfrun lofiadm -d $bi_lofi_blkdev
+
+if [[ $bi_proforma_only == 1 ]]; then
+	copy_results $bi_wsroot/proto.images ${bi_imgsz_gb}gb.img ${bi_imgsz_gb}gb.
+else
+	print "Compressing USB image ..."
+	pfrun /opt/local/bin/pigz $bi_tmpdir/smartos.usb
+	copy_results $bi_wsroot/output-usb $bi_usb_image_name ""
+fi
+
+exit 0
diff --git a/tools/build_illumos b/tools/build_illumos
index 7f493080..060a28e7 100755
--- a/tools/build_illumos
+++ b/tools/build_illumos
@@ -52,9 +52,17 @@ else
 fi
 gsed -i -e "s|^MAX_JOBS=.*$|MAX_JOBS=${MJ}; export MAX_JOBS|" illumos.sh
 
+#
+# illumos.sh sets the value of $MAKE by default, which is used by bldenv
+# and nightly. By setting MAKE below to the bootstrap dmake, illumos.sh
+# will honor the one in the environment and let us solve the chicken and
+# egg problem that we have.
+#
+export MAKE=/opt/local/bin/dmake
 ksh93 ./usr/src/tools/scripts/bldenv.sh illumos.sh \
     'cd $CODEMGR_WS/usr/src && export PATH="$PATH:/opt/local/bin" && \
     dmake setup && cd tools && dmake install'
+export -n MAKE
 
 printf "\nRunning illumos nightly(1).\n"
 printf "This will take a while.\n"
diff --git a/tools/build_iso b/tools/build_iso
deleted file mode 100755
index da8e5c56..00000000
--- a/tools/build_iso
+++ /dev/null
@@ -1,392 +0,0 @@
-#!/bin/bash
-#
-# This file and its contents are supplied under the terms of the
-# Common Development and Distribution License ("CDDL"), version 1.0.
-# You may only use this file in accordance with the terms of version
-# 1.0 of the CDDL.
-#
-# A full copy of the text of the CDDL should have accompanied this
-# source.  A copy of the CDDL is also available via the Internet at
-# http://www.illumos.org/license/CDDL.
-#
-
-#
-# Copyright (c) 2017, Joyent, Inc.
-#
-
-#
-# Automates the process of building ISO and USB images of a SmartOS build.  It
-# uses the latest platform file that's been built.  This program should be
-# invoked via the "make iso" and "make usb" targets of the top-level Makefile
-# in "smartos-live.git".
-#
-
-shopt -s xpg_echo
-set -o pipefail
-export PATH=/usr/bin:/opt/local/bin:/usr/sbin
-
-bi_wsroot=$(cd $(dirname $0)/../; pwd)
-bi_arg0=$(basename $0)
-bi_type=${bi_arg0/build_/}
-
-. "${bi_wsroot}/tools/lib/build_common.sh"
-
-bi_grub_dir="proto/boot/grub"
-bi_output_grub_dir="$bi_tmpdir/boot/grub"
-bi_grub_files="stage1 stage2 stage2_eltorito"
-bi_archive_path="i86pc/amd64/boot_archive"
-bi_unix_path="i86pc/kernel/amd64/unix"
-bi_usb_size=2000000000
-bi_grub_optstr=
-bi_console=vga
-bi_grub_unit=
-bi_dont_clean=0
-bi_no_smartos=0
-bi_do_kmdb=
-bi_usbpath=
-bi_tmpusbpath=
-bi_lofidev=
-
-
-function usage
-{
-	local msg="$*"
-	[[ -z "$msg" ]] && echo "$msg"
-	cat <<USAGE >&2
-Usage: $bi_arg0 [ -o options ] [-c dev] [ -k ] [ -m ]
-
-Generate a bootable $bi_type image from the proto area and newest platform directory.
-
-	-o options	Append all the options to every GRUB menu.lst entry
-	-c dev		Set default console to be dev (tty{a,b,c,d} or vga)
-	-k		Don't delete temporary files
-	-m		Default to kmdb
-	-n		Don't build for SmartOS
-	-h		Display this message
-
-USAGE
-	exit 2
-}
-
-function fail_cleanup
-{
-	if [[ x"$bi_lofidev" != x ]]; then
-		#(unmount and) cleanup the lofi device
-		pfexec umount -f ${bi_lofidev}:c
-		pfexec lofiadm -d $bi_lofidev
-	fi
-	# an uncompressed usb file is probably incomplete.  remove it
-	[[ -f $bi_tmpusbpath ]] && rm -f $bi_tmpusbpath
-	[[ -f $bi_usbpath ]] && rm -f $bi_usbpath
-	local msg="$*"
-	[[ -z "$msg" ]] && msg="failed"
-	echo "$bi_arg0: $msg" >&2
-	exit 1
-}
-
-function bi_verif_mkisofs
-{
-	bi_emit_start 'Checking for mkisofs'
-	which mkisofs >/dev/null
-	[[ $? -eq 0 ]] || fail "missing mkisofs"
-	bi_emit_done
-}
-
-function bi_get_build
-{
-	#
-	# The build process updates a "platform-latest" symlink to the
-	# most recently built platform directory.  We use that symlink
-	# to decide which platform to bundle into the ISO or USB image.
-	#
-	bi_emit_start 'Determining platform'
-	if [[ ! -L "${bi_platform_dir}/platform-latest" ]]; then
-		fail '"platform-latest" symlink does not exist'
-	fi
-
-	if ! bi_platform_name=$(/usr/bin/readlink \
-	    "${bi_platform_dir}/platform-latest"); then
-		fail 'failed to read "platform-latest" symlink'
-	fi
-
-	bi_platform="${bi_platform_dir}${bi_platform_name}"
-	if [[ -z "${bi_platform_name}" || ! -d "${bi_platform}" ]]; then
-		fail '"platform-latest" symlink does not point to directory'
-	fi
-
-	bi_emit_done
-	bi_emit_info 'Using platform' "${bi_platform_name}"
-}
-
-#
-# Check to make sure the 64-bit kernel is actually there as a brief sanity check
-#
-function bi_verif_platform
-{
-	bi_emit_start 'Verifying platform'
-	[[ -d $bi_platform ]] || fail "invalid platform directory"
-	[[ -f $bi_platform/$bi_archive_path ]] || fail "missing boot archive"
-	[[ -f $bi_platform/$bi_unix_path ]] || fail "missing kernel image"
-	bi_emit_done
-}
-
-function bi_verif_grub
-{
-	bi_emit_start 'Verifying grub files'
-	if [[ ! -d $bi_grub_dir ]]; then
-		fail "missing /boot/grub from proto area"
-	fi
-	for file in $bi_grub_files; do
-		if [[ ! -f $bi_grub_dir/$file ]]; then
-			fail "file missing from grub proto area: $file"
-		fi
-	done
-	bi_emit_done
-}
-
-function bi_verif_console
-{
-	bi_emit_start 'Verifying console selection'
-	case "$bi_console" in
-	text|graphics|vga)
-		bi_console=vga
-		bi_grub_unit=1,0,2,3
-		;;
-	ttya)
-		bi_grub_unit=0,1,2,3
-		;;
-	ttyb)
-		bi_grub_unit=1,0,2,3
-		;;
-	ttyc)
-		bi_grub_unit=2,1,0,3
-		;;
-	ttyd)
-		bi_grub_unit=3,1,0,2
-		;;
-	*)
-		fail "Invalid console device $bi_console"
-		;;
-	esac
-	bi_emit_done
-}
-
-function bi_generate_usb_file
-{
-	local tmp_free
-
-	if [[ ! -d $bi_output_dir ]]; then
-		mkdir -p $bi_output_dir > /dev/null
-		[[ $? -eq 0 ]] || fail "failed to make output directory"
-	fi
-
-	bi_emit_start 'Generating usb image file'
-	bi_usbpath="$bi_output_dir/$bi_platform_name.usb"
-	bi_tmpusbpath=$bi_usbpath
-
-	tmp_free=$(stat -f -c '%S * %f' $bi_tmpdir | xargs expr)
-	if ((tmp_free >= bi_usb_size + 10000)); then
-		bi_tmpusbpath="$bi_tmpdir/$bi_platform_name.usb"
-	fi
-
-	rm -f $bi_tmpusbpath
-	if ! mkfile -n $bi_usb_size $bi_tmpusbpath; then
-		fail "failed to generate usb file"
-	fi
-	if ! bi_lofidev=$(pfexec lofiadm -a $bi_tmpusbpath); then
-		fail "failed to create lofi device"
-	fi
-	if ! pfexec fdisk -F "$(dirname $0)/usb_fdisk_table" \
-	    "${bi_lofidev/lofi/rlofi}"; then
-		fail "failed to partition ${bi_lofidev/lofi/rlofi}"
-	fi
-	echo "y" | pfexec mkfs -F pcfs -o b=SMARTOSBOOT,fat=32 ${bi_lofidev/lofi/rlofi}:c
-	[[ $? -eq 0 ]] || fail "failed to format the usb image"
-	bi_emit_done
-
-	bi_emit_start 'Mounting usb image file'
-	if ! pfexec mount -F pcfs "${bi_lofidev}:c" "$bi_tmpdir"; then
-		fail "failed to mount usb image"
-	fi
-	bi_emit_done
-}
-
-function bi_copy_contents
-{
-	bi_emit_start 'Copying platform directory'
-	if ! cp -r $bi_platform $bi_tmpdir/platform >/dev/null; then
-		fail "failed to copy platform file"
-	fi
-	bi_emit_done
-
-	bi_emit_start 'Copying grub components'
-	if ! mkdir -p $bi_output_grub_dir; then
-		fail "failed to iso9960 grub output directory"
-	fi
-	for file in $bi_grub_files; do
-		if ! cp $bi_grub_dir/$file $bi_output_grub_dir >/dev/null; then
-			fail "failed to copy grub file: $file"
-		fi
-	done
-	bi_emit_done
-}
-
-function bi_generate_grub_conf
-{
-	if [[ $bi_no_smartos != 1 ]]; then
-		bi_grub_optstr="${bi_grub_optstr},smartos=true"
-	fi
-	local console_settings='console=${os_console},${os_console}-mode="115200,8,n,1,-"'
-	# keep passord and shadow in sync, please
-	local password='root'
-	local shadow='$5$2HOHRnK3$NvLlm.1KQBbB0WjoP7xcIwGnllhzp2HnT.mDO7DpxYA'
-	local default=0
-	[[ -n "$bi_do_kmdb" ]] && default=2
-	bi_emit_start 'Generating grub menu.lst'
-	cat > $bi_output_grub_dir/menu.lst <<EOF
-default=$default
-timeout=10
-min_mem64 1024
-serial --speed=115200 --unit=$bi_grub_unit --word=8 --parity=no --stop=1
-terminal composite
-variable os_console $bi_console
-
-title SmartOS
-   kernel$ /platform/i86pc/kernel/amd64/unix -B $console_settings,root_shadow='$shadow'$bi_grub_optstr
-   module /platform/i86pc/amd64/boot_archive
-
-title SmartOS noinstall/recovery (login/pw: root/$password)
-   kernel$ /platform/i86pc/kernel/amd64/unix -B $console_settings,root_shadow='$shadow',standalone=true,noimport=true
-   module /platform/i86pc/amd64/boot_archive
-
-title SmartOS +kmdb
-   kernel$ /platform/i86pc/kernel/amd64/unix -kd -B $console_settings,root_shadow='$shadow'$bi_grub_optstr
-   module /platform/i86pc/amd64/boot_archive
-EOF
-	[[ $? -eq 0 ]] || fail "failed to create menu.lst"
-	bi_emit_done
-}
-
-function bi_generate_iso
-{
-	local isopath
-
-	if [[ ! -d $bi_output_dir ]]; then
-		if ! mkdir $bi_output_dir > /dev/null; then
-			fail "failed to make output directory"
-		fi
-	fi
-	bi_emit_start 'Generating iso...'
-	isopath="$bi_output_dir/$bi_platform_name.iso"
-	LC_ALL=C mkisofs -R -b 		\
-	    boot/grub/stage2_eltorito	\
-	    -no-emul-boot 		\
-	    -boot-load-size 4		\
-	    -boot-info-table		\
-	    -quiet			\
-	    -o 	$isopath		\
-	    $bi_tmpdir/ >/dev/null
-	[[ $? -eq 0 ]] || fail "Failed to create iso"
-	bi_emit_done
-	bi_emit_info 'ISO output' "$(pwd)/$isopath"
-}
-
-
-function bi_generate_usb
-{
-	# The image file in $bi_tmpdir is hidden by the mounted image contents,
-	# so we have to make it visible again by umounting before grub can be
-	# installed.
-	if ! pfexec umount "${bi_lofidev}:c"; then
-		fail "failed to unmount ${bi_lofidev}:c"
-	fi
-	if ! pfexec lofiadm -d $bi_lofidev; then
-		fail "failed to remove lofi device $bi_lofidev"
-	fi
-	bi_lofidev= #unset that variable so fail won't try to clean it up again
-
-	bi_emit_start 'Installing grub'
-	bi_emit_newline
-	grub --batch <<____ENDOFGRUBCOMMANDS
-device (hd0) $bi_tmpusbpath
-root (hd0,0)
-setup (hd0)
-quit
-____ENDOFGRUBCOMMANDS
-	[[ $? -eq 0 ]] || fail "failed to install grub"
-	bi_emit_done
-
-	bi_emit_start 'Compressing usb image'
-	[[ -f ${bi_usbpath}.bz2 ]] && rm ${bi_usbpath}.bz2
-	if ! pbzip2 -c $bi_tmpusbpath > ${bi_usbpath}.bz2; then
-		fail "failed to compress $bi_usbpath"
-	fi
-	rm -f $bi_tmpusbpath
-	bi_emit_done
-	bi_emit_info 'USB Output' "$(pwd)/${bi_usbpath}.bz2"
-}
-
-while getopts "kmo:nhc:" c $@; do
-	case "$c" in
-	o)
-		bi_emit_info \
-		    "Building $bi_type image with additional options:" \
-		    "$OPTARG"
-		bi_grub_optstr=",$OPTARG"
-		;;
-	c)
-		bi_console="$OPTARG"
-		;;
-	k)
-		bi_dont_clean=1
-		;;
-	m)
-		bi_do_kmdb=1
-		;;
-	n)
-		bi_no_smartos=1
-		;;
-	h)
-		usage
-		;;
-	:)
-		usage "missing required argument -- $OPTARG"
-		;;
-	*)
-		usage "invalid option: $OPTARG"
-		;;
-	esac
-done
-
-bi_big_banner "Building \"$bi_type\" image"
-
-#
-# Get us to the root of the workspace
-#
-if ! cd ${bi_wsroot}; then
-	fail "could not chdir to workspace root \"${bi_wsroot}\""
-fi
-
-case "$bi_type" in
-	iso)
-		bi_verif_mkisofs
-		;;
-	usb)
-		;;
-esac
-bi_verif_grub
-bi_verif_console
-bi_get_build
-bi_verif_platform
-bi_setup_work_dir
-bi_copy_contents
-bi_generate_grub_conf
-case "$bi_type" in
-	iso)
-		bi_generate_iso
-		;;
-	usb)
-		bi_generate_usb
-		;;
-esac
-bi_cleanup_work_dir
diff --git a/tools/build_live b/tools/build_live
index 022d134c..816c3a6b 100755
--- a/tools/build_live
+++ b/tools/build_live
@@ -732,6 +732,15 @@ function bi_finish_archive
 		fail "could not store hash of boot_archive in output directory"
 	fi
 
+	version_dir="$bi_out_dir/$bi_prefix/etc/version"
+	if ! /usr/bin/mkdir -p "$version_dir"; then
+		fail "could not create \"$version_dir\""
+	fi
+
+	if ! printf '%s\n' "$bi_buildstamp" >"$version_dir/platform"; then
+		fail "could not store buildstamp in platform tarball"
+	fi
+
 	if ! printf '%s\n' "$bi_buildstamp" >"$bi_out_dir/buildstamp"; then
 		fail "could not store buildstamp in output directory"
 	fi
diff --git a/tools/build_usb b/tools/build_usb
deleted file mode 120000
index a3116dfa..00000000
--- a/tools/build_usb
+++ /dev/null
@@ -1 +0,0 @@
-build_iso
\ No newline at end of file
diff --git a/tools/clobber_illumos b/tools/clobber_illumos
index 1d2c2670..3b89f59f 100755
--- a/tools/clobber_illumos
+++ b/tools/clobber_illumos
@@ -15,27 +15,16 @@
 #
 
 #
-# Attempt to clobber an illumos build. We need to make sure that we have
-# a dmake available. The one that's in -extra is the one that we
-# generally need. As a heuristic, we use its presence for determining
-# whether or not we need it. This isn't perfect. Ideally we'd ship a set
-# of onbld tools to always use this. However, this should work for most
-# folks. You can't build illumos without the 0-extra-stramp. Therefore
-# if the dmake from proto.strap is missing, illumos likely hasn't been
-# built.
-#
-# This does mean that a user that manually removes things in proto.strap
-# and then calls gmake clobber at the top level will result in build
-# failures; however, we can at least let folks know about that. Ideally,
-# this will be a rare case.
+# Attempt to clobber an illumos build. We override $MAKE in the
+# environment to explicitly point at the bootstrap dmake that we install
+# as part of ./configure.
 #
 set -o pipefail
 
 ci_wsroot=$(cd $(dirname $0)/../; pwd)
 ci_arg0=$(basename $0)
-ci_dmake=$ci_wsroot/proto.strap/usr/bin/dmake
-ci_stamp=$ci_wsroot/0-illumos-stamp
-ci_illumos=$ci_wsroot/projects/illumos/usr/src
+ci_illumos="$ci_wsroot/projects/illumos/usr/src"
+ci_dmake="/opt/local/bin/dmake"
 
 export PATH=/usr/bin:/usr/sbin:/opt/local/bin:/opt/local/sbin
 
@@ -60,48 +49,6 @@ function ci_verify_root
 	    "file sample.configure.smartos"
 }
 
-#
-# Verify if we have dmake available. If dmake hasn't been built, we
-# won't consider clobbering illumos, but will inform the user. If,
-# however, the 0-illumos-stamp file is present, that indicates that
-# the workspace is in a bad state and the user will have to manually
-# clobber illumos. We'll give them instructions on what to do, but exit
-# 1.
-#
-function ci_check_dmake
-{
-	[[ -f $ci_dmake && -x $ci_dmake ]] && return
-
-	if [[ ! -f $ci_stamp ]]; then
-		cat >&2 << EOF
-dmake not found and 0-illumos-stamp is not present. Assuming that
-illumos has never been built and skipping the clobber.
-EOF
-		exit 0
-	fi
-
-	#
-	# So we have a stamp file, but no dmake. We're not certain about
-	# the state of this workspace, so advise the user on what to do.
-	#
-	cat >&2 << EOF
-Warning: repository is in a state where an automated clobber cannot be
-performed. You will need to manually clobber illumos or rebuild the
-initial part of illumos-extra. To rebuild illumos-extra, run:
-
-$ rm -f 0-extra-stamp
-$ gmake 0-extra-stamp
-
-At this point, it should be safe to run gmake clean / clobber again. If
-you still have problems, please reach out to the SmartOS community by
-either asking in #smartos on irc.freenode.net, e-mailing the
-smartos-discuss mailng list, or filing a bug on
-https://github.com/joyent/smartos-live/issues.
-EOF
-
-	exit 1
-}
-
 #
 # Do the hard work of actually running dmake clobber. We purposefully
 # allow its exit status to propagate out of here.
@@ -109,10 +56,10 @@ EOF
 function ci_do_clobber
 {
 	echo "Clobbering $ci_wsroot/projects/illumos"
+	export MAKE="$ci_dmake"
 	ksh93 $ci_illumos/tools/scripts/bldenv.sh $ci_illumos/../../illumos.sh \
 	    'cd $CODEMGR_WS/usr/src && dmake clobber'
 }
 
 ci_verify_root
-ci_check_dmake
 ci_do_clobber
diff --git a/tools/format_image/Makefile b/tools/format_image/Makefile
new file mode 100644
index 00000000..9ba19826
--- /dev/null
+++ b/tools/format_image/Makefile
@@ -0,0 +1,40 @@
+#
+# Copyright (c) 2019, Joyent, Inc.
+#
+
+CC=gcc
+ILLUMOS_SRC=$(PWD)/../../projects/illumos/usr/src
+
+CFLAGS=-std=gnu99 -Wall -W -Werror -Wno-sign-compare
+CPPFLAGS += -isystem $(PWD)/../../proto/usr/include
+
+TARGETS=format_image
+LIBS=-lsmbios -luuid
+
+#
+# Yes, we're directly pulling in a local copy of libefi source: see do_ioctl()
+# there for why.
+#
+# There is an obvious risk of trying to use illumos-joyent code directly on the
+# build platform.  However, this code is pretty self-contained, and its ioctl()
+# usage fairly stable. The biggest risk here is probably the libsmbios usage:
+# but even there, we don't actually care about any H/W workarounds in that code.
+#
+# Having said that, roll on the day when our minimum build platform has a lofi
+# driver such that we can avoid doing this hack.
+#
+OBJS=format_image.o rdwr_efi.o crc32_efi.o
+
+all: $(TARGETS)
+
+format_image: $(OBJS)
+	$(CC) $(CFLAGS) -o $@ $(OBJS) $(LIBS)
+
+%.o: %.c
+	$(CC) -c $(CFLAGS) $(CPPFLAGS) -o $@ $<
+
+%.o: $(ILLUMOS_SRC)/lib/libefi/common/%.c
+	$(CC) -c $(CFLAGS) $(CPPFLAGS) -o $@ $<
+
+clean:
+	rm $(TARGETS) $(OBJS)
diff --git a/tools/format_image/format_image.c b/tools/format_image/format_image.c
new file mode 100644
index 00000000..fc188a3e
--- /dev/null
+++ b/tools/format_image/format_image.c
@@ -0,0 +1,406 @@
+/*
+ * This file and its contents are supplied under the terms of the
+ * Common Development and Distribution License ("CDDL"), version 1.0.
+ * You may only use this file in accordance with the terms of version
+ * 1.0 of the CDDL.
+ *
+ * A full copy of the text of the CDDL should have accompanied this
+ * source.  A copy of the CDDL is also available via the Internet at
+ * http://www.illumos.org/license/CDDL.
+ *
+ * Copyright (c) 2018, Joyent, Inc.
+ */
+
+/*
+ * As the build runs in a non-global zone, we don't have the luxury of tools
+ * such as labeled lofi, format, etc. in order to create the USB image.  We are
+ * looking to create an image of the following form:
+ *
+ * Part Tag      First Sector Size     Type
+ * -    mbr/GPT  0            1MB      MBR+EFI GPT (-m option plus libefi)
+ * 0    system   2048         256MB    EFI System Partition (-e option)
+ * 1    boot     526336       1MB      Legacy BIOS boot partition (-b option)
+ * 2    root     528384       3.46GB   pcfs or ufs root
+ * 8    reserved 7796083      8MB      V_RESERVED / devid (not really used)
+ *
+ * This boots under BIOS as follows:
+ *
+ * 1. BIOS loads the MBR, which jumps to stage2_sector (see pmbr.s)
+ * 2. stage2 is a modified gptzfsboot, in partition 1 above
+ * 3. despite the name, this can also load pcfs/ufs - partition 2 above.
+ *    To find the partition, there is a weirdo fake multiboot header embedded
+ *    that we need to update with the starting LBA of partition 2.
+ * 4. This then boots into loader
+ * 5. which finally will load the kernel
+ *
+ * On a UEFI system:
+ *
+ * 1. BIOS finds the ESP at partition 0, and loads /EFI/BOOT/BOOTX64.EFI
+ *    as defined by the EFI spec. This is "loader"
+ * 2. loader loads kernel from the pcfs/ufs root from partition 2
+ * 3. kernel takes control
+ *
+ * So this tool needs to fix up then write a modified MBR, populate the GPT
+ * header and partition tables, and write out the ESP and biosboot images.
+ * It is sort of an unholy merger of zpool_label_disk(ZPOOL_CREATE_BOOT_LABEL)
+ * and installboot(1m).
+ *
+ * We only currently support 512 block size, and the code isn't endian-vetted.
+ *
+ * The "root" partition is populated later, not by this tool. This is the main
+ * reason we megabyte-align the partitions: it's much faster if we can dd with
+ * a larger block size.
+ */
+
+#include <uuid/uuid.h>
+#include <strings.h>
+#include <string.h>
+#include <assert.h>
+#include <unistd.h>
+#include <stdarg.h>
+#include <stdlib.h>
+#include <libgen.h>
+#include <fcntl.h>
+#include <stdio.h>
+#include <errno.h>
+#include <err.h>
+
+#include <sys/efi_partition.h>
+#include <sys/dktp/fdisk.h>
+#include <sys/sysmacros.h>
+#include <sys/types.h>
+#include <sys/vtoc.h>
+#include <sys/stat.h>
+
+#define	EXIT_USAGE (2)
+
+/*
+ * From installboot.h, these are a set of offsets into the MBR.
+ */
+#define	SECTOR_SIZE (512)
+#define	STAGE1_STAGE2_SIZE (0xfc)  /* 16bits */
+#define	STAGE1_STAGE2_LBA (0xfe)  /* 64bits */
+#define	STAGE1_STAGE2_UUID (0x106) /* 128bits */
+#define	STAGE1_MBR_VERSION (0xfa) /* 2 bytes, major/minor */
+#define	STAGE1_BPB_OFFSET (0x3)   /* technically BPB starts at 0xb */
+#define	STAGE1_BPB_SIZE (0x3b)
+#define	STAGE1_MAGIC (0x1fe) /* 0xAA55 */
+
+/*
+ * From multiboot.h
+ */
+#define	MB_HEADER_MAGIC		 0x1BADB002	/* magic */
+
+#define	LBSIZE (SECTOR_SIZE)
+#define	MB_BLOCKS (2048) /* 1Mb in blocks */
+#define	PART_ALIGN (MB_BLOCKS * SECTOR_SIZE)
+#define	LEGACY_BOOTPART_BLOCKS (MB_BLOCKS) /* in LBSIZE */
+#define	LEGACY_BOOTPART_SIZE (LEGACY_BOOTPART_BLOCKS * LBSIZE)
+
+/*
+ * Space for MBR+GPT prior to first partition, aligned up to the first MB.
+ */
+#define	START_SECT (MB_BLOCKS)
+
+/*
+ * These define the basic layout of a USB key image, and are sniffed by
+ * /lib/sdc/usb-key.sh (and potentially elsewhere).  The legacy grub key is
+ * implicitly version 1.  A revision of IMAGE_MAJOR implies that old code cannot
+ * successfully mount the root of the USB key image in the expected place (that
+ * is, slice 2).
+ */
+#define	IMAGE_MAJOR (2)
+#define	IMAGE_MINOR (0)
+
+typedef struct multiboot_header {
+	uint32_t	magic;
+	uint32_t	flags;
+	uint32_t	checksum;
+	caddr32_t	header_addr;
+	caddr32_t	load_addr;
+	caddr32_t	load_end_addr;
+	caddr32_t	bss_end_addr;
+	caddr32_t	entry_addr;
+} multiboot_header_t;
+
+static const char *progname;
+static size_t biosboot_start;
+static int outfile;
+
+static void
+usage(const char *fmt, ...)
+{
+	if (fmt != NULL) {
+		va_list ap;
+
+		va_start(ap, fmt);
+		vwarnx(fmt, ap);
+		va_end(ap);
+	}
+
+	(void) fprintf(stderr,
+	    "Usage: %s -o image.usb -m mbr -e efifs -b biosboot\n"
+	    "\n"
+	    "Format a USB/ISO image for booting SmartOS or Triton.\n"
+	    "\n"
+	    "\t-o  output file\n"
+	    "\t-m  MBR image\n"
+	    "\t-e  EFI system partition (ESP) pcfs image\n"
+	    "\t-b  Legacy BIOS stage2 boot program (gptzfsboot)\n",
+	    progname);
+
+	exit(fmt == NULL ? EXIT_SUCCESS : EXIT_USAGE);
+}
+
+static char *
+read_file(const char *path, size_t size, size_t *lenp)
+{
+	struct stat st;
+	ssize_t ret;
+	size_t left;
+	char *buf;
+	char *pos;
+	int fd;
+
+	if ((fd = open(path, O_RDONLY)) == -1)
+		err(EXIT_FAILURE, "couldn't open %s", path);
+
+	if (fstat(fd, &st) != 0)
+		err(EXIT_FAILURE, "couldn't stat %s", path);
+
+	if (size != 0 && st.st_size > size) {
+		errx(EXIT_FAILURE, "file %s exceeds maximum %lu bytes",
+		    path, size);
+	}
+
+	if (size == 0)
+		size = st.st_size;
+
+	if ((buf = calloc(1, size)) == NULL)
+		err(EXIT_FAILURE, "couldn't alloc buf for %s", path);
+
+	for (left = st.st_size, pos = buf; left; pos += ret, left -=ret) {
+		ret = read(fd, pos, left);
+
+		if (ret < 0)
+			err(EXIT_FAILURE, "couldn't read from %s", path);
+	}
+
+	if (lenp != NULL)
+		*lenp = st.st_size;
+	return (buf);
+}
+
+static void
+write_mbr(char *mbr, size_t esplen, size_t biosbootlen)
+{
+	uint64_t *stage2_lbap = (uint64_t *)(mbr + STAGE1_STAGE2_LBA);
+	uint16_t *stage2_sizep = (uint16_t *)(mbr + STAGE1_STAGE2_SIZE);
+	uint8_t *stage1_major = (uint8_t *)(mbr + STAGE1_MBR_VERSION);
+	uint8_t *stage1_minor = (uint8_t *)(mbr + STAGE1_MBR_VERSION + 1);
+	uchar_t *uuidp = (uchar_t *)(mbr + STAGE1_STAGE2_UUID);
+
+	*stage2_lbap = START_SECT + esplen / LBSIZE;
+	*stage2_sizep = biosbootlen / LBSIZE;
+	*stage1_major = IMAGE_MAJOR;
+	*stage1_minor = IMAGE_MINOR;
+
+	/*
+	 * This is all "nops" in the MBR image: let's clear it out like
+	 * installboot(1M) does.
+	 */
+	bzero(mbr + STAGE1_BPB_OFFSET, STAGE1_BPB_SIZE);
+
+	uuid_generate(uuidp);
+
+	if (pwrite(outfile, mbr, SECTOR_SIZE, 0) != SECTOR_SIZE)
+		err(EXIT_FAILURE, "failed to write MBR");
+}
+
+static void
+set_part(struct dk_part *part, diskaddr_t start, diskaddr_t size,
+    const char *name, ushort_t tag)
+{
+	if (tag != V_RESERVED) {
+		assert((start % MB_BLOCKS) == 0);
+		assert((size % MB_BLOCKS) == 0);
+	}
+
+	printf("%s %d %llu %llu\n", name, tag, start * LBSIZE, size * LBSIZE);
+
+	part->p_start = start;
+	part->p_size = size;
+	if (strlcpy(part->p_name, name, sizeof (part->p_name)) >=
+	    sizeof (part->p_name))
+		errx(EXIT_FAILURE, "partition name %s is too long", name);
+
+	part->p_tag = tag;
+}
+
+static void
+write_efi(size_t esplen)
+{
+	struct dk_gpt *vtoc;
+	diskaddr_t start = START_SECT;
+	diskaddr_t size;
+	int ret;
+
+	if (efi_alloc_and_init(outfile, EFI_NUMPAR, &vtoc) != 0)
+		err(EXIT_FAILURE, "failed to init EFI");
+
+	set_part(&vtoc->efi_parts[0], start, esplen / LBSIZE,
+	    "loader", V_SYSTEM);
+
+	start += esplen / LBSIZE;
+	biosboot_start = start;
+
+	set_part(&vtoc->efi_parts[1], start, LEGACY_BOOTPART_BLOCKS,
+	    "boot", V_BOOT);
+
+	start += LEGACY_BOOTPART_BLOCKS;
+
+	size = vtoc->efi_last_u_lba + 1 - (EFI_MIN_RESV_SIZE + start);
+	size = P2ALIGN(size, MB_BLOCKS);
+
+	set_part(&vtoc->efi_parts[2], start, size, "root", V_ROOT);
+
+	start = vtoc->efi_last_u_lba + 1 - EFI_MIN_RESV_SIZE;
+
+	set_part(&vtoc->efi_parts[8], start, EFI_MIN_RESV_SIZE,
+	    "reserved", V_RESERVED);
+
+	/*
+	 * This also updates the PMBR for the protective partition.
+	 */
+	if ((ret = efi_write(outfile, vtoc)) != 0)
+		errx(EXIT_FAILURE, "failed to write EFI with %d", ret);
+
+	efi_free(vtoc);
+}
+
+static void
+write_esp(char *esp, size_t esplen)
+{
+	if (pwrite(outfile, esp, esplen, START_SECT * LBSIZE) != esplen)
+		err(EXIT_FAILURE, "failed to write ESP");
+}
+
+static multiboot_header_t *
+find_multiboot(char *biosboot, size_t biosbootlen)
+{
+	for (size_t off = 0; off < biosbootlen; off +=4) {
+		multiboot_header_t *mb = (multiboot_header_t *)(biosboot + off);
+
+		if (mb->magic != MB_HEADER_MAGIC)
+			continue;
+
+		if (-(mb->flags + mb->magic) != mb->checksum)
+			continue;
+
+		return (mb);
+	}
+
+	return (NULL);
+}
+
+/*
+ * Before we can write out gptzfsboot we need to update its embedded
+ * multiboot_header_t: the ->bss_end_addr offset is examined to figure out the
+ * root partition's start sector (see sys/boot/common/multiboot.S).  Whoever
+ * said booting was pleasant?
+ */
+static void
+write_biosboot(char *biosboot, size_t biosbootlen)
+{
+	/* in sectors */
+	multiboot_header_t *multiboot;
+	uint64_t *ptr;
+
+	if ((multiboot = find_multiboot(biosboot, biosbootlen)) == NULL)
+		errx(EXIT_FAILURE, "couldn't find fake multiboot header");
+
+	ptr = (uint64_t *)&multiboot->bss_end_addr;
+	*ptr = biosboot_start + LEGACY_BOOTPART_BLOCKS;
+
+	if (pwrite(outfile, biosboot, LEGACY_BOOTPART_SIZE,
+	    biosboot_start * LBSIZE) != LEGACY_BOOTPART_SIZE)
+		err(EXIT_FAILURE, "failed to write biosboot");
+}
+
+int
+main(int argc, char *argv[])
+{
+	const char *biosbootpath = NULL;
+	const char *esppath = NULL;
+	const char *mbrpath = NULL;
+	const char *outpath = NULL;
+	size_t biosbootlen;
+	char *biosboot;
+	size_t esplen;
+	char *esp;
+	char *mbr;
+	int c;
+
+	progname = basename(argv[0]);
+
+	while ((c = getopt(argc, argv, ":b:e:hm:o:")) != -1) {
+		switch (c) {
+		case 'b':
+			biosbootpath = optarg;
+			break;
+		case 'e':
+			esppath = optarg;
+			break;
+		case 'o':
+			outpath = optarg;
+			break;
+		case 'm':
+			mbrpath = optarg;
+			break;
+		case 'h':
+			usage(NULL);
+			break;
+		case ':':
+			usage("Option -%c requires an operand\n", optopt);
+			break;
+		case '?':
+			usage("Unrecognised option: -%c\n", optopt);
+			break;
+		}
+	}
+
+	if (biosbootpath == NULL || esppath == NULL || mbrpath == NULL ||
+	    outpath == NULL)
+		usage("missing argument\n");
+
+	if (optind != argc)
+		usage("too many arguments\n");
+
+	if ((outfile = open(outpath, O_RDWR)) == -1)
+		err(EXIT_FAILURE, "failed to open %s for writing", outpath);
+
+	mbr = read_file(mbrpath, SECTOR_SIZE, NULL);
+
+	if (((struct mboot *)mbr)->signature != MBB_MAGIC) {
+		errx(EXIT_FAILURE, "MBR has incorrect magic %hlx",
+		    ((struct mboot *)mbr)->signature);
+	}
+
+	esp = read_file(esppath, 0, &esplen);
+
+	if (esplen % PART_ALIGN) {
+		errx(EXIT_FAILURE, "ESP image is not %lu-byte aligned",
+		    PART_ALIGN);
+	}
+
+	biosboot = read_file(biosbootpath, LEGACY_BOOTPART_SIZE, &biosbootlen);
+
+	write_mbr(mbr, esplen, biosbootlen);
+	write_efi(esplen);
+	write_esp(esp, esplen);
+	write_biosboot(biosboot, biosbootlen);
+
+	(void) close(outfile);
+
+	return (EXIT_SUCCESS);
+}
diff --git a/tools/images/1gb.fdisk b/tools/images/1gb.fdisk
deleted file mode 100644
index 3f7f8993..00000000
--- a/tools/images/1gb.fdisk
+++ /dev/null
@@ -1,6 +0,0 @@
-*   12: FDISK_EXT_WIN
-* Id    Act  Bhead  Bsect  Bcyl    Ehead  Esect  Ecyl    Rsect      Numsect
-  12    128  9      34     0       144    63     121     600        1952400
-  0     0    0      0      0       0      0      0       0          0
-  0     0    0      0      0       0      0      0       0          0
-  0     0    0      0      0       0      0      0       0          0
diff --git a/tools/images/2gb.fdisk b/tools/images/2gb.fdisk
deleted file mode 100644
index abb72f0e..00000000
--- a/tools/images/2gb.fdisk
+++ /dev/null
@@ -1,6 +0,0 @@
-*   12: FDISK_EXT_WIN
-* Id    Act  Bhead  Bsect  Bcyl    Ehead  Esect  Ecyl    Rsect      Numsect
-  12    128  9      34     0       34     63     243     600        3905400
-  0     0    0      0      0       0      0      0       0          0
-  0     0    0      0      0       0      0      0       0          0
-  0     0    0      0      0       0      0      0       0          0
diff --git a/tools/images/4gb.fdisk b/tools/images/4gb.fdisk
deleted file mode 100644
index f9663cec..00000000
--- a/tools/images/4gb.fdisk
+++ /dev/null
@@ -1,6 +0,0 @@
-*   12: FDISK_EXT_WIN
-* Id    Act  Bhead  Bsect  Bcyl    Ehead  Esect  Ecyl    Rsect      Numsect
-  12    128  9      34     0       69     63     486     600        7811400
-  0     0    0      0      0       0      0      0       0          0
-  0     0    0      0      0       0      0      0       0          0
-  0     0    0      0      0       0      0      0       0          0
diff --git a/tools/images/8gb.fdisk b/tools/images/8gb.fdisk
deleted file mode 100644
index 67505973..00000000
--- a/tools/images/8gb.fdisk
+++ /dev/null
@@ -1,6 +0,0 @@
-*   12: FDISK_EXT_WIN
-* Id    Act  Bhead  Bsect  Bcyl    Ehead  Esect  Ecyl    Rsect      Numsect
-  12    128  9      34     0       149    33     972     600        15624000
-  0     0    0      0      0       0      0      0       0          0
-  0     0    0      0      0       0      0      0       0          0
-  0     0    0      0      0       0      0      0       0          0
diff --git a/tools/images/make_image b/tools/images/make_image
deleted file mode 100755
index 658fa484..00000000
--- a/tools/images/make_image
+++ /dev/null
@@ -1,263 +0,0 @@
-#!/bin/bash
-#
-# This file and its contents are supplied under the terms of the
-# Common Development and Distribution License ("CDDL"), version 1.0.
-# You may only use this file in accordance with the terms of version
-# 1.0 of the CDDL.
-#
-# A full copy of the text of the CDDL should have accompanied this
-# source.  A copy of the CDDL is also available via the Internet at
-# http://www.illumos.org/license/CDDL.
-#
-
-#
-# Copyright 2016 Joyent, Inc.
-#
-
-#
-# This script has been written to be correct without either the "errexit" or
-# "pipefail" shell options.  The exit status of all operations is explicitly
-# checked, with appropriate handling of errors.
-#
-
-PFEXEC=/bin/pfexec
-GRUB_FILES=(
-	fat_stage1_5
-	iso9660_stage1_5
-	stage1
-	stage2
-	stage2_eltorito
-	ufs_stage1_5
-	zfs_stage1_5
-)
-
-g_size=
-g_fdisk_file=
-g_grub_dir=
-g_image_file=
-g_lofi_device=
-g_lofi_raw=
-g_mount_point=
-g_tmp_dir=
-
-function warn
-{
-	local msg="$0: WARNING: $1\\n"
-	shift
-
-	printf "$msg" "$@" 2>&1
-}
-
-function cleanup
-{
-	if [[ -n $g_mount_point ]]; then
-		if ! $PFEXEC /sbin/umount "$g_mount_point"; then
-			warn 'could not unmount %s' "$g_mount_point"
-		fi
-	fi
-
-	if [[ -n $g_lofi_device ]]; then
-		if ! $PFEXEC /usr/sbin/lofiadm -d "$g_lofi_device"; then
-			warn 'could not remove lofi device %s' \
-			    "$g_lofi_device"
-		fi
-	fi
-
-	if [[ -n $g_tmp_dir ]]; then
-		rm -rf "$g_tmp_dir"
-	fi
-	if [[ -n $g_image_file ]]; then
-		rm -f "$g_image_file"
-	fi
-}
-
-function fatal
-{
-	local msg="$0: ERROR: $1\\n"
-	shift
-
-	printf "$msg" "$@" 2>&1
-
-	cleanup
-	exit 1
-}
-
-#
-# Option parsing:
-#
-while getopts 's:F:G:' a; do
-	case $a in
-	s)
-		case $OPTARG in
-		1gb|2gb|4gb|8gb)
-			g_size=${OPTARG%gb}
-			;;
-		*)
-			fatal 'unknown size (-s): %s' "$OPTARG"
-			;;
-		esac
-		;;
-	F)
-		if [[ ! -f $OPTARG ]]; then
-			fatal 'fdisk table file not found: %s' "$OPTARG"
-		fi
-		g_fdisk_file=$OPTARG
-		;;
-	G)
-		if [[ ! -d $OPTARG ]]; then
-			fatal 'grub directory not found: %s' "$OPTARG"
-		fi
-		g_grub_dir=$OPTARG
-		;;
-	*)
-		fatal 'usage error'
-		exit 1
-		;;
-	esac
-done
-
-shift $(( $OPTIND - 1 ))
-if (( $# != 1 )); then
-	fatal 'must specify an image file'
-	exit 1
-fi
-g_image_file=$1
-
-if [[ -z $g_image_file || -z $g_size || -z $g_fdisk_file ||
-    -z $g_grub_dir ]]; then
-	fatal 'usage error: must provide all of -s, -F, and -G'
-fi
-
-if [[ -f $g_image_file ]]; then
-	printf 'image file exists already\n' >&2
-	exit 1
-fi
-
-printf '== create proforma image ========================================\n\n'
-printf '  output file:     %s\n' "$g_image_file"
-printf '  image size:      %d GB\n' "$g_size"
-printf '  fdisk template:  %s\n' "$g_fdisk_file"
-printf '  grub directory:  %s\n' "$g_grub_dir"
-
-#
-# Create a sparse file of the appropriate size.  This size must match that
-# which was used to create the fdisk(1M) template, and must be the same size or
-# smaller than the target USB drive.
-#
-printf 'create sparse image file\n'
-if ! /usr/sbin/mkfile -n $(( g_size * 1000000000 )) "$g_image_file"; then
-	fatal 'could not mkfile'
-fi
-
-#
-# Attach the blank image file to the system as a lofi(7D) device.
-#
-printf 'attach image file as lofi(7D) device\n'
-if ! g_lofi_device=$($PFEXEC /usr/sbin/lofiadm -a "$g_image_file"); then
-	fatal 'could not attach image as lofi(7D) device'
-fi
-
-#
-# The lofi(7D) device path is for the emulated block device.  We also need the
-# path to the emulated character device.
-#
-g_lofi_raw=${g_lofi_device/#\/dev\/lofi\//\/dev\/rlofi\/}
-printf '  lofi device:     %s\n' "$g_lofi_device"
-printf '  lofi raw device: %s\n' "$g_lofi_raw"
-
-if [[ ! -b $g_lofi_device || ! -c $g_lofi_raw ]]; then
-	fatal 'could not locate lofi(7D) device paths'
-fi
-
-printf 'create partition table\n'
-if ! $PFEXEC /sbin/fdisk -F "$g_fdisk_file" "$g_lofi_raw"; then
-	fatal 'could not make partition table'
-fi
-
-#
-# Create a FAT32 file system on the first partition of the image.  The volume
-# label is set to "HEADNODE".
-#
-printf 'format FAT32 file system\n'
-if ! $PFEXEC /usr/sbin/mkfs -F pcfs -o 'b=HEADNODE,fat=32' "$g_lofi_raw:c" \
-    </dev/null; then
-	fatal 'could not format FAT32 file system'
-fi
-
-#
-# Create a temporary directory in which to mount the image to avoid conflicting
-# with any other processes.
-#
-if ! g_tmp_dir=$(mktemp -d); then
-	fatal 'could not create temporary directory'
-fi
-
-g_mount_point=$g_tmp_dir/mnt
-if ! mkdir "$g_mount_point"; then
-	fatal 'could not create mount point directory: %s' "$g_mount_point"
-fi
-
-#
-# Mount the FAT32 file system from the image with the appropriate mount options.
-#
-printf 'mount FAT32 file system\n'
-if ! $PFEXEC /sbin/mount -F pcfs -o 'foldcase,noatime,hidden,clamptime,rw' \
-    "$g_lofi_device:c" "$g_mount_point"; then
-	fatal 'could not mount file system'
-fi
-
-#
-# Create the grub directory within the image.
-#
-if ! mkdir -p "$g_mount_point/boot/grub"; then
-	fatal 'could not create grub directory within image'
-fi
-
-#
-# Copy each grub file from the build area to the image, and create an empty
-# grub menu file in the appropriate location.
-#
-printf 'copying files:\n'
-for grub_file in ${GRUB_FILES[@]}; do
-	p=boot/grub/$grub_file
-	printf '      copy: %s\n' "$p"
-	if ! /bin/cp "$g_grub_dir/$p" "$g_mount_point/$p"; then
-		fatal 'could not copy %s' "$p"
-	fi
-done
-touch "$g_mount_point/boot/grub/menu.lst"
-
-#
-# Unmount the image now, so that we can use the grub shell without upsetting
-# the kernel.  Unset the "g_mount_point" variable so that cleanup does not try
-# to unmount a second time.
-#
-printf 'unmounting image\n'
-if ! $PFEXEC /sbin/umount "$g_mount_point"; then
-	fatal 'could not unmount image file system'
-fi
-unset g_mount_point
-
-#
-# Now that the file system is unmounted, use the grub command to install the
-# boot block within the MBR and embed the appropriate stage1_5.
-#
-printf 'installing grub\n'
-$PFEXEC "$g_grub_dir/boot/grub/bin/grub" --batch <<EOFGRUB
-device (hd0) $g_lofi_raw
-root (hd0,0)
-setup (hd0)
-quit
-EOFGRUB
-if [[ $? -ne 0 ]]; then
-	fatal 'failed to install grub'
-fi
-
-#
-# The image was successfully created.  Clean up all of our resources,
-# but make sure we do not delete the successfully created image file.
-#
-unset g_image_file
-cleanup
-printf '\n'
-exit 0
diff --git a/tools/usb_fdisk_table b/tools/usb_fdisk_table
deleted file mode 100644
index 4506355d..00000000
--- a/tools/usb_fdisk_table
+++ /dev/null
@@ -1,52 +0,0 @@
-
-* /dev/rlofi/2 default fdisk table
-* Dimensions:
-*    512 bytes/sector
-*    600 sectors/track
-*      1 tracks/cylinder
-*   6510 cylinders
-*
-* systid:
-*    1: DOSOS12
-*    2: PCIXOS
-*    4: DOSOS16
-*    5: EXTDOS
-*    6: DOSBIG
-*    7: FDISK_IFS
-*    8: FDISK_AIXBOOT
-*    9: FDISK_AIXDATA
-*   10: FDISK_0S2BOOT
-*   11: FDISK_WINDOWS
-*   12: FDISK_EXT_WIN
-*   14: FDISK_FAT95
-*   15: FDISK_EXTLBA
-*   18: DIAGPART
-*   65: FDISK_LINUX
-*   82: FDISK_CPM
-*   86: DOSDATA
-*   98: OTHEROS
-*   99: UNIXOS
-*  100: FDISK_NOVELL2
-*  101: FDISK_NOVELL3
-*  119: FDISK_QNX4
-*  120: FDISK_QNX42
-*  121: FDISK_QNX43
-*  130: SUNIXOS
-*  131: FDISK_LINUXNAT
-*  134: FDISK_NTFSVOL1
-*  135: FDISK_NTFSVOL2
-*  165: FDISK_BSD
-*  167: FDISK_NEXTSTEP
-*  183: FDISK_BSDIFS
-*  184: FDISK_BSDISWAP
-*  190: X86BOOT
-*  191: SUNIXOS2
-*  238: EFI_PMBR
-*  239: EFI_FS
-*
-
-* Id    Act  Bhead  Bsect  Bcyl    Ehead  Esect  Ecyl    Rsect      Numsect
-  12    128  9      34     0       34     63     243     600        3905400   
-  0     0    0      0      0       0      0      0       0          0         
-  0     0    0      0      0       0      0      0       0          0         
-  0     0    0      0      0       0      0      0       0          0         
-- 
2.21.0

