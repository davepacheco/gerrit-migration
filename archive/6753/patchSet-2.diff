commit d26d48f7d7ae367e6e765a923e278f237e00a973
Author: Kelly McLaughlin <kelly.mclaughlin@joyent.com>
Date:   2019-08-07T11:39:51-06:00 (9 weeks ago)
    
    MANTA-4472 Refactor common request handler code to reduce duplication

diff --git a/src/bucket.rs b/src/bucket.rs
index 509cca8..b73a071 100644
--- a/src/bucket.rs
+++ b/src/bucket.rs
@@ -6,7 +6,7 @@ use serde_json::Value;
 use uuid::Uuid;
 
 use crate::error::{BorayError, BorayErrorType};
-use crate::util::Rows;
+use crate::types::{HasRequestId, Rows};
 
 pub mod create;
 pub mod delete;
@@ -23,6 +23,12 @@ pub struct GetBucketPayload {
     pub request_id: Uuid,
 }
 
+impl HasRequestId for GetBucketPayload {
+    fn request_id(&self) -> Uuid {
+        self.request_id
+    }
+}
+
 pub type DeleteBucketPayload = GetBucketPayload;
 
 #[derive(Clone, Debug, Deserialize, PartialEq, Serialize)]
diff --git a/src/bucket/create.rs b/src/bucket/create.rs
index 3178cae..75a9530 100644
--- a/src/bucket/create.rs
+++ b/src/bucket/create.rs
@@ -1,8 +1,9 @@
 // Copyright 2019 Joyent, Inc.
 
 use serde_derive::{Deserialize, Serialize};
+use serde_json::Error as SerdeError;
 use serde_json::{json, Value};
-use slog::{debug, error, o, warn, Logger};
+use slog::{debug, error, Logger};
 use uuid::Uuid;
 
 use cueball_postgres_connection::PostgresConnection;
@@ -10,9 +11,8 @@ use rust_fast::protocol::{FastMessage, FastMessageData};
 
 use crate::bucket::{bucket_already_exists, response, to_json, BucketResponse};
 use crate::sql;
-use crate::util::{array_wrap, other_error, HandlerError, HandlerResponse};
-
-const METHOD: &str = "createbucket";
+use crate::types::{HandlerResponse, HasRequestId};
+use crate::util::array_wrap;
 
 #[derive(Clone, Debug, Deserialize, PartialEq, Serialize)]
 pub struct CreateBucketPayload {
@@ -22,68 +22,55 @@ pub struct CreateBucketPayload {
     pub request_id: Uuid,
 }
 
-pub(crate) fn handler(
+impl HasRequestId for CreateBucketPayload {
+    fn request_id(&self) -> Uuid {
+        self.request_id
+    }
+}
+
+pub(crate) fn decode_msg(value: &Value) -> Result<Vec<CreateBucketPayload>, SerdeError> {
+    serde_json::from_value::<Vec<CreateBucketPayload>>(value.clone())
+}
+
+pub(crate) fn action(
     msg_id: u32,
-    data: &Value,
-    mut conn: &mut PostgresConnection,
+    method: &str,
     log: &Logger,
-) -> Result<HandlerResponse, HandlerError> {
-    let mut log_child = log.clone();
-
-    debug!(log_child, "handling {} function request", &METHOD);
-
-    serde_json::from_value::<Vec<CreateBucketPayload>>(data.clone())
-        .map_err(|e| e.to_string())
-        .and_then(|mut arr| {
-            // Remove outer JSON array required by Fast
-            if !arr.is_empty() {
-                Ok(arr.remove(0))
-            } else {
-                let err_msg = "Failed to parse JSON data as payload for \
-                               createbucket function";
-                warn!(log_child, "{}: {}", err_msg, data);
-                Err(err_msg.to_string())
-            }
+    payload: CreateBucketPayload,
+    conn: &mut PostgresConnection,
+) -> Result<HandlerResponse, String> {
+    // Make database request
+    do_create(method, payload, conn)
+        .and_then(|maybe_resp| {
+            // Handle the successful database response
+            debug!(log, "{} operation was successful", &method);
+            let value = match maybe_resp {
+                Some(resp) => to_json(resp),
+                None => bucket_already_exists(),
+            };
+            let msg_data = FastMessageData::new(method.into(), array_wrap(value));
+            let msg: HandlerResponse = FastMessage::data(msg_id, msg_data).into();
+            Ok(msg)
         })
-        .and_then(|payload| {
-            // Make database request
-            let req_id = payload.request_id;
-            log_child = log_child.new(o!("req_id" => req_id.to_string()));
-
-            debug!(log_child, "parsed CreateBucketPayload");
-
-            create(payload, &mut conn)
-                .and_then(|maybe_resp| {
-                    // Handle the successful database response
-                    debug!(log_child, "{} operation was successful", &METHOD);
-                    let value = match maybe_resp {
-                        Some(resp) => to_json(resp),
-                        None => bucket_already_exists(),
-                    };
-                    let msg_data = FastMessageData::new(METHOD.into(), array_wrap(value));
-                    let msg: HandlerResponse = FastMessage::data(msg_id, msg_data).into();
-                    Ok(msg)
-                })
-                .or_else(|e| {
-                    // Handle database error response
-                    error!(log_child, "{} operation failed: {}", &METHOD, &e);
-
-                    // Database errors are returned to as regular Fast messages
-                    // to be handled by the calling application
-                    let value = array_wrap(json!({
-                        "name": "PostgresError",
-                        "message": e
-                    }));
-
-                    let msg_data = FastMessageData::new(METHOD.into(), value);
-                    let msg: HandlerResponse = FastMessage::data(msg_id, msg_data).into();
-                    Ok(msg)
-                })
+        .or_else(|e| {
+            // Handle database error response
+            error!(log, "{} operation failed: {}", &method, &e);
+
+            // Database errors are returned to as regular Fast messages
+            // to be handled by the calling application
+            let value = array_wrap(json!({
+                "name": "PostgresError",
+                "message": e
+            }));
+
+            let msg_data = FastMessageData::new(method.into(), value);
+            let msg: HandlerResponse = FastMessage::data(msg_id, msg_data).into();
+            Ok(msg)
         })
-        .map_err(|e| HandlerError::IO(other_error(&e)))
 }
 
-fn create(
+fn do_create(
+    method: &str,
     payload: CreateBucketPayload,
     conn: &mut PostgresConnection,
 ) -> Result<Option<BucketResponse>, String> {
@@ -101,7 +88,7 @@ fn create(
         Ok(rows)
     })
     .map_err(|e| e.to_string())
-    .and_then(|rows| response(METHOD, rows))
+    .and_then(|rows| response(method, rows))
 }
 
 fn create_sql(vnode: u64) -> String {
diff --git a/src/bucket/delete.rs b/src/bucket/delete.rs
index 76d87ac..c7c4ab2 100644
--- a/src/bucket/delete.rs
+++ b/src/bucket/delete.rs
@@ -1,86 +1,67 @@
 // Copyright 2019 Joyent, Inc.
 
+use serde_json::Error as SerdeError;
 use serde_json::{json, Value};
-use slog::{debug, error, o, warn, Logger};
+use slog::{debug, error, Logger};
 
 use cueball_postgres_connection::PostgresConnection;
 use rust_fast::protocol::{FastMessage, FastMessageData};
 
 use crate::bucket::{bucket_not_found, DeleteBucketPayload};
 use crate::sql;
-use crate::util::{array_wrap, other_error, HandlerError, HandlerResponse};
+use crate::types::HandlerResponse;
+use crate::util::array_wrap;
 
-const METHOD: &str = "deletebucket";
+pub(crate) fn decode_msg(value: &Value) -> Result<Vec<DeleteBucketPayload>, SerdeError> {
+    serde_json::from_value::<Vec<DeleteBucketPayload>>(value.clone())
+}
 
-pub(crate) fn handler(
+pub(crate) fn action(
     msg_id: u32,
-    data: &Value,
-    mut conn: &mut PostgresConnection,
+    method: &str,
     log: &Logger,
-) -> Result<HandlerResponse, HandlerError> {
-    let mut log_child = log.clone();
-    debug!(log_child, "handling {} function request", &METHOD);
-
-    serde_json::from_value::<Vec<DeleteBucketPayload>>(data.clone())
-        .map_err(|e| e.to_string())
-        .and_then(|mut arr| {
-            // Remove outer JSON array required by Fast
-            if !arr.is_empty() {
-                Ok(arr.remove(0))
+    payload: DeleteBucketPayload,
+    conn: &mut PostgresConnection,
+) -> Result<HandlerResponse, String> {
+    // Make database request
+    do_delete(payload, conn)
+        .and_then(|affected_rows| {
+            // Handle the successful database response
+            debug!(log, "deletebucket operation was successful");
+            let value = if affected_rows > 0 {
+                // This conversion can fail if the implementation of
+                // Serialize decides to fail, or if the type
+                // contains a map with non-string keys. There is no
+                // reason for the former to occur and the latter
+                // reason for failure is not a concern here since
+                // the type of `affected_rows` is u64.
+                serde_json::to_value(affected_rows).unwrap()
             } else {
-                let err_msg = "Failed to parse JSON data as payload for \
-                               deletebucket function";
-                warn!(log_child, "{}: {}", err_msg, data);
-                Err(err_msg.to_string())
-            }
-        })
-        .and_then(|payload| {
-            // Make database request
-            let req_id = payload.request_id;
-            log_child = log_child.new(o!("req_id" => req_id.to_string()));
+                bucket_not_found()
+            };
 
-            debug!(log_child, "parsed DeleteBucketPayload");
-
-            delete(payload, &mut conn)
-                .and_then(|affected_rows| {
-                    // Handle the successful database response
-                    debug!(log_child, "deletebucket operation was successful");
-                    let value = if affected_rows > 0 {
-                        // This conversion can fail if the implementation of
-                        // Serialize decides to fail, or if the type
-                        // contains a map with non-string keys. There is no
-                        // reason for the former to occur and the latter
-                        // reason for failure is not a concern here since
-                        // the type of `affected_rows` is u64.
-                        serde_json::to_value(affected_rows).unwrap()
-                    } else {
-                        bucket_not_found()
-                    };
-
-                    let msg_data = FastMessageData::new(METHOD.into(), array_wrap(value));
-                    let msg: HandlerResponse = FastMessage::data(msg_id, msg_data).into();
-                    Ok(msg)
-                })
-                .or_else(|e| {
-                    // Handle database error response
-                    error!(log_child, "{} operation failed: {}", &METHOD, &e);
+            let msg_data = FastMessageData::new(method.into(), array_wrap(value));
+            let msg: HandlerResponse = FastMessage::data(msg_id, msg_data).into();
+            Ok(msg)
+        })
+        .or_else(|e| {
+            // Handle database error response
+            error!(log, "{} operation failed: {}", &method, &e);
 
-                    // Database errors are returned to as regular Fast messages
-                    // to be handled by the calling application
-                    let value = array_wrap(json!({
-                        "name": "PostgresError",
-                        "message": e
-                    }));
+            // Database errors are returned to as regular Fast messages
+            // to be handled by the calling application
+            let value = array_wrap(json!({
+                "name": "PostgresError",
+                "message": e
+            }));
 
-                    let msg_data = FastMessageData::new(METHOD.into(), value);
-                    let msg: HandlerResponse = FastMessage::data(msg_id, msg_data).into();
-                    Ok(msg)
-                })
+            let msg_data = FastMessageData::new(method.into(), value);
+            let msg: HandlerResponse = FastMessage::data(msg_id, msg_data).into();
+            Ok(msg)
         })
-        .map_err(|e| HandlerError::IO(other_error(&e)))
 }
 
-fn delete(payload: DeleteBucketPayload, conn: &mut PostgresConnection) -> Result<u64, String> {
+fn do_delete(payload: DeleteBucketPayload, conn: &mut PostgresConnection) -> Result<u64, String> {
     let mut txn = (*conn).transaction().map_err(|e| e.to_string())?;
     let move_sql = insert_delete_table_sql(payload.vnode);
     let delete_sql = delete_sql(payload.vnode);
diff --git a/src/bucket/get.rs b/src/bucket/get.rs
index d5beada..cf12779 100644
--- a/src/bucket/get.rs
+++ b/src/bucket/get.rs
@@ -1,78 +1,60 @@
 // Copyright 2019 Joyent, Inc.
 
+use serde_json::Error as SerdeError;
 use serde_json::{json, Value};
-use slog::{debug, error, o, warn, Logger};
+use slog::{debug, error, Logger};
 
 use cueball_postgres_connection::PostgresConnection;
 use rust_fast::protocol::{FastMessage, FastMessageData};
 
 use crate::bucket::{bucket_not_found, response, to_json, BucketResponse, GetBucketPayload};
 use crate::sql;
-use crate::util::{array_wrap, other_error, HandlerError, HandlerResponse};
+use crate::types::HandlerResponse;
+use crate::util::array_wrap;
 
-const METHOD: &str = "getbucket";
+pub(crate) fn decode_msg(value: &Value) -> Result<Vec<GetBucketPayload>, SerdeError> {
+    serde_json::from_value::<Vec<GetBucketPayload>>(value.clone())
+}
 
-pub(crate) fn handler(
+pub(crate) fn action(
     msg_id: u32,
-    data: &Value,
-    mut conn: &mut PostgresConnection,
+    method: &str,
     log: &Logger,
-) -> Result<HandlerResponse, HandlerError> {
-    let mut log_child = log.clone();
-    debug!(log_child, "handling {} function request", &METHOD);
-
-    serde_json::from_value::<Vec<GetBucketPayload>>(data.clone())
-        .map_err(|e| e.to_string())
-        .and_then(|mut arr| {
-            // Remove outer JSON array required by Fast
-            if !arr.is_empty() {
-                Ok(arr.remove(0))
-            } else {
-                let err_msg = "Failed to parse JSON data as payload for \
-                               getbucket function";
-                warn!(log_child, "{}: {}", err_msg, data);
-                Err(err_msg.to_string())
-            }
+    payload: GetBucketPayload,
+    conn: &mut PostgresConnection,
+) -> Result<HandlerResponse, String> {
+    // Make database request
+    do_get(method, payload, conn)
+        .and_then(|maybe_resp| {
+            // Handle the successful database response
+            debug!(log, "{} operation was successful", &method);
+            let value = match maybe_resp {
+                Some(resp) => to_json(resp),
+                None => bucket_not_found(),
+            };
+            let msg_data = FastMessageData::new(method.into(), array_wrap(value));
+            let msg: HandlerResponse = FastMessage::data(msg_id, msg_data).into();
+            Ok(msg)
         })
-        .and_then(|payload| {
-            // Make database request
-            let req_id = payload.request_id;
-            log_child = log_child.new(o!("req_id" => req_id.to_string()));
-
-            debug!(log_child, "parsed GetBucketPayload");
-
-            get(payload, &mut conn)
-                .and_then(|maybe_resp| {
-                    // Handle the successful database response
-                    debug!(log_child, "{} operation was successful", &METHOD);
-                    let value = match maybe_resp {
-                        Some(resp) => to_json(resp),
-                        None => bucket_not_found(),
-                    };
-                    let msg_data = FastMessageData::new(METHOD.into(), array_wrap(value));
-                    let msg: HandlerResponse = FastMessage::data(msg_id, msg_data).into();
-                    Ok(msg)
-                })
-                .or_else(|e| {
-                    // Handle database error response
-                    error!(log_child, "{} operation failed: {}", &METHOD, &e);
+        .or_else(|e| {
+            // Handle database error response
+            error!(log, "{} operation failed: {}", &method, &e);
 
-                    // Database errors are returned to as regular Fast messages
-                    // to be handled by the calling application
-                    let value = array_wrap(json!({
-                        "name": "PostgresError",
-                        "message": e
-                    }));
+            // Database errors are returned to as regular Fast messages
+            // to be handled by the calling application
+            let value = array_wrap(json!({
+                "name": "PostgresError",
+                "message": e
+            }));
 
-                    let msg_data = FastMessageData::new(METHOD.into(), value);
-                    let msg: HandlerResponse = FastMessage::data(msg_id, msg_data).into();
-                    Ok(msg)
-                })
+            let msg_data = FastMessageData::new(method.into(), value);
+            let msg: HandlerResponse = FastMessage::data(msg_id, msg_data).into();
+            Ok(msg)
         })
-        .map_err(|e| HandlerError::IO(other_error(&e)))
 }
 
-fn get(
+fn do_get(
+    method: &str,
     payload: GetBucketPayload,
     mut conn: &mut PostgresConnection,
 ) -> Result<Option<BucketResponse>, String> {
@@ -85,7 +67,7 @@ fn get(
         &[&payload.owner, &payload.name],
     )
     .map_err(|e| e.to_string())
-    .and_then(|rows| response(METHOD, rows))
+    .and_then(|rows| response(method, rows))
 }
 
 fn get_sql(vnode: u64) -> String {
diff --git a/src/bucket/list.rs b/src/bucket/list.rs
index 4413eca..9c4641f 100644
--- a/src/bucket/list.rs
+++ b/src/bucket/list.rs
@@ -1,8 +1,9 @@
 // Copyright 2019 Joyent, Inc.
 
 use serde_derive::{Deserialize, Serialize};
+use serde_json::Error as SerdeError;
 use serde_json::{json, Value};
-use slog::{debug, error, o, warn, Logger};
+use slog::{debug, error, Logger};
 use uuid::Uuid;
 
 use cueball_postgres_connection::PostgresConnection;
@@ -10,9 +11,8 @@ use rust_fast::protocol::{FastMessage, FastMessageData};
 
 use crate::bucket::{to_json, BucketResponse};
 use crate::sql;
-use crate::util::{array_wrap, other_error, HandlerError, HandlerResponse};
-
-const METHOD: &str = "listbuckets";
+use crate::types::{HandlerResponse, HasRequestId};
+use crate::util::array_wrap;
 
 #[derive(Clone, Debug, Deserialize, PartialEq, Serialize)]
 pub struct ListBucketsPayload {
@@ -24,79 +24,66 @@ pub struct ListBucketsPayload {
     pub request_id: Uuid,
 }
 
-pub(crate) fn handler(
-    msg_id: u32,
-    data: &Value,
-    mut conn: &mut PostgresConnection,
-    log: &Logger,
-) -> Result<HandlerResponse, HandlerError> {
-    let mut log_child = log.clone();
-    debug!(log_child, "handling {} function request", &METHOD);
-
-    serde_json::from_value::<Vec<ListBucketsPayload>>(data.clone())
-        .map_err(|e| e.to_string())
-        .and_then(|mut arr| {
-            // Remove outer JSON array required by Fast
-            if !arr.is_empty() {
-                Ok(arr.remove(0))
-            } else {
-                let err_msg = "Failed to parse JSON data as payload for \
-                               getbucket function";
-                warn!(log_child, "{}: {}", err_msg, data);
-                Err(err_msg.to_string())
-            }
-        })
-        .and_then(|payload| {
-            // Make database request
-            let req_id = payload.request_id;
-            log_child = log_child.new(o!("req_id" => req_id.to_string()));
+impl HasRequestId for ListBucketsPayload {
+    fn request_id(&self) -> Uuid {
+        self.request_id
+    }
+}
 
-            debug!(log_child, "parsed ListBucketsPayload");
+pub(crate) fn decode_msg(value: &Value) -> Result<Vec<ListBucketsPayload>, SerdeError> {
+    serde_json::from_value::<Vec<ListBucketsPayload>>(value.clone())
+}
 
-            if payload.limit > 0 && payload.limit <= 1024 {
-                list(msg_id, payload, &mut conn)
-                    .and_then(|resp| {
-                        // Handle the successful database response
-                        debug!(log_child, "{} operation was successful", &METHOD);
-                        Ok(HandlerResponse::from(resp))
-                    })
-                    .or_else(|e| {
-                        // Handle database error response
-                        error!(log_child, "{} operation failed: {}", &METHOD, &e);
+pub(crate) fn action(
+    msg_id: u32,
+    method: &str,
+    log: &Logger,
+    payload: ListBucketsPayload,
+    conn: &mut PostgresConnection,
+) -> Result<HandlerResponse, String> {
+    // Make database request
+    if payload.limit > 0 && payload.limit <= 1024 {
+        do_list(msg_id, method, payload, conn)
+            .and_then(|resp| {
+                // Handle the successful database response
+                debug!(log, "{} operation was successful", &method);
+                Ok(HandlerResponse::from(resp))
+            })
+            .or_else(|e| {
+                // Handle database error response
+                error!(log, "{} operation failed: {}", &method, &e);
 
-                        // Database errors are returned to as regular Fast messages
-                        // to be handled by the calling application
-                        let value = array_wrap(json!({
-                            "name": "PostgresError",
-                            "message": e
-                        }));
-                        let msg_data = FastMessageData::new(METHOD.into(), value);
-                        let msg: HandlerResponse = FastMessage::data(msg_id, msg_data).into();
-                        Ok(msg)
-                    })
-            } else {
-                // Limit constraint violations are returned to as regular
-                // Fast messages to be handled by the calling application
-                let e = format!(
-                    "the {} limit option must be a value between 1 \
-                     and 1024. the requested limit was {}, req_id: \
-                     {}",
-                    &METHOD, &payload.limit, &req_id
-                );
+                // Database errors are returned to as regular Fast messages
+                // to be handled by the calling application
                 let value = array_wrap(json!({
-                    "name": "LimitConstraintError",
+                    "name": "PostgresError",
                     "message": e
                 }));
-                let msg_data = FastMessageData::new(METHOD.into(), value);
+                let msg_data = FastMessageData::new(method.into(), value);
                 let msg: HandlerResponse = FastMessage::data(msg_id, msg_data).into();
                 Ok(msg)
-            }
-        })
-        .map_err(|e| HandlerError::IO(other_error(&e)))
+            })
+    } else {
+        // Limit constraint violations are returned to as regular
+        // Fast messages to be handled by the calling application
+        let e = format!(
+            "the {} limit option must be a value between 1 \
+             and 1024. the requested limit was {}",
+            &method, &payload.limit
+        );
+        let value = array_wrap(json!({
+            "name": "LimitConstraintError",
+            "message": e
+        }));
+        let msg_data = FastMessageData::new(method.into(), value);
+        let msg: HandlerResponse = FastMessage::data(msg_id, msg_data).into();
+        Ok(msg)
+    }
 }
 
-fn list(
+fn do_list(
     msg_id: u32,
+    method: &str,
     payload: ListBucketsPayload,
     mut conn: &mut PostgresConnection,
 ) -> Result<Vec<FastMessage>, String> {
@@ -153,7 +140,7 @@ fn list(
             };
 
             let value = to_json(resp);
-            let msg_data = FastMessageData::new(METHOD.into(), array_wrap(value));
+            let msg_data = FastMessageData::new(method.into(), array_wrap(value));
             let msg = FastMessage::data(msg_id, msg_data);
 
             msgs.push(msg);
diff --git a/src/lib.rs b/src/lib.rs
index 4254029..bfe257e 100644
--- a/src/lib.rs
+++ b/src/lib.rs
@@ -8,15 +8,13 @@ pub mod opts;
 pub mod sql;
 
 pub mod util {
-    use std::collections::HashMap;
     use std::io::Error as IOError;
     use std::io::ErrorKind;
     use std::time::{Duration, Instant};
 
-    use postgres::error::Error as PGError;
-    use postgres::row::Row;
+    use serde_json::Error as SerdeError;
     use serde_json::{json, Value};
-    use slog::{error, warn, Logger};
+    use slog::{debug, error, o, warn, Logger};
 
     use cueball::backend::Backend;
     use cueball::connection_pool::ConnectionPool;
@@ -28,35 +26,9 @@ pub mod util {
     use crate::bucket;
     use crate::metrics;
     use crate::object;
+    use crate::types::{HandlerError, HandlerResponse, HasRequestId};
 
-    pub type Rows = Vec<Row>;
-    pub type PostgresResult<T> = Result<T, PGError>;
-    pub type Hstore = HashMap<String, Option<String>>;
-    pub type Timestamptz = chrono::DateTime<chrono::Utc>;
-
-    pub(crate) enum HandlerError {
-        Cueball(CueballError),
-        IO(IOError),
-    }
-
-    pub(crate) enum HandlerResponse {
-        Message(FastMessage),
-        Messages(Vec<FastMessage>),
-    }
-
-    impl From<FastMessage> for HandlerResponse {
-        fn from(fm: FastMessage) -> Self {
-            HandlerResponse::Message(fm)
-        }
-    }
-
-    impl From<Vec<FastMessage>> for HandlerResponse {
-        fn from(fms: Vec<FastMessage>) -> Self {
-            HandlerResponse::Messages(fms)
-        }
-    }
-
-    pub fn msg_handler(
+    pub fn handle_msg(
         msg: &FastMessage,
         pool: &ConnectionPool<
             PostgresConnection,
@@ -76,17 +48,80 @@ pub mod util {
         pool.claim()
             .map_err(HandlerError::Cueball)
             .and_then(|mut conn| {
-                // Dispatch the request to the proper handler
+                // Dispatch the request
                 match method {
-                    "getobject" => object::get::handler(msg.id, &msg.data.d, &mut conn, &log),
-                    "createobject" => object::create::handler(msg.id, &msg.data.d, &mut conn, &log),
-                    "updateobject" => object::update::handler(msg.id, &msg.data.d, &mut conn, &log),
-                    "deleteobject" => object::delete::handler(msg.id, &msg.data.d, &mut conn, &log),
-                    "listobjects" => object::list::handler(msg.id, &msg.data.d, &mut conn, &log),
-                    "getbucket" => bucket::get::handler(msg.id, &msg.data.d, &mut conn, &log),
-                    "createbucket" => bucket::create::handler(msg.id, &msg.data.d, &mut conn, &log),
-                    "deletebucket" => bucket::delete::handler(msg.id, &msg.data.d, &mut conn, &log),
-                    "listbuckets" => bucket::list::handler(msg.id, &msg.data.d, &mut conn, &log),
+                    "getobject" => handle_request(
+                        msg.id,
+                        method,
+                        object::get::decode_msg(&msg.data.d),
+                        &mut conn,
+                        &object::get::action,
+                        &log,
+                    ),
+                    "createobject" => handle_request(
+                        msg.id,
+                        method,
+                        object::create::decode_msg(&msg.data.d),
+                        &mut conn,
+                        &object::create::action,
+                        &log,
+                    ),
+                    "updateobject" => handle_request(
+                        msg.id,
+                        method,
+                        object::update::decode_msg(&msg.data.d),
+                        &mut conn,
+                        &object::update::action,
+                        &log,
+                    ),
+                    "deleteobject" => handle_request(
+                        msg.id,
+                        method,
+                        object::delete::decode_msg(&msg.data.d),
+                        &mut conn,
+                        &object::delete::action,
+                        &log,
+                    ),
+                    "listobjects" => handle_request(
+                        msg.id,
+                        method,
+                        object::list::decode_msg(&msg.data.d),
+                        &mut conn,
+                        &object::list::action,
+                        &log,
+                    ),
+                    "getbucket" => handle_request(
+                        msg.id,
+                        method,
+                        bucket::get::decode_msg(&msg.data.d),
+                        &mut conn,
+                        &bucket::get::action,
+                        &log,
+                    ),
+                    "createbucket" => handle_request(
+                        msg.id,
+                        method,
+                        bucket::create::decode_msg(&msg.data.d),
+                        &mut conn,
+                        &bucket::create::action,
+                        &log,
+                    ),
+                    "deletebucket" => handle_request(
+                        msg.id,
+                        method,
+                        bucket::delete::decode_msg(&msg.data.d),
+                        &mut conn,
+                        &bucket::delete::action,
+                        &log,
+                    ),
+                    "listbuckets" => handle_request(
+                        msg.id,
+                        method,
+                        bucket::list::decode_msg(&msg.data.d),
+                        &mut conn,
+                        &bucket::list::action,
+                        &log,
+                    ),
                     _ => {
                         let err_msg = format!("Unsupported functon: {}", method);
                         Err(HandlerError::IO(other_error(&err_msg)))
@@ -177,7 +212,107 @@ pub mod util {
         Value::Array(vec![v])
     }
 
+    pub(crate) fn unwrap_fast_message<T>(
+        operation: &str,
+        log: &Logger,
+        mut arr: Vec<T>,
+    ) -> Result<T, String>
+    where
+        T: for<'de> serde::Deserialize<'de>,
+    {
+        // Remove outer JSON array required by Fast
+        if !arr.is_empty() {
+            Ok(arr.remove(0))
+        } else {
+            let err_msg = format!(
+                "Failed to parse JSON data as payload for \
+                 {} function",
+                operation
+            );
+            warn!(log, "{}", err_msg);
+            Err(err_msg.to_string())
+        }
+    }
+
     pub(crate) fn other_error(msg: &str) -> IOError {
         IOError::new(ErrorKind::Other, String::from(msg))
     }
+
+    pub(crate) fn handle_request<X>(
+        msg_id: u32,
+        method: &str,
+        data: Result<Vec<X>, SerdeError>,
+        conn: &mut PostgresConnection,
+        action: &Fn(
+            u32,
+            &str,
+            &Logger,
+            X,
+            &mut PostgresConnection,
+        ) -> Result<HandlerResponse, String>,
+        log: &Logger,
+    ) -> Result<HandlerResponse, HandlerError>
+    where
+        X: for<'de> serde::Deserialize<'de> + HasRequestId,
+    {
+        let mut log_child = log.clone();
+        debug!(log_child, "handling {} function request", &method);
+
+        data.map_err(|e| e.to_string())
+            .and_then(|arr| unwrap_fast_message(&method, &log_child, arr))
+            .and_then(|payload| {
+                // Add the request id to the log output
+                let req_id = payload.request_id();
+                log_child = log_child.new(o!("req_id" => req_id.to_string()));
+
+                debug!(log_child, "parsed {} payload", &method);
+
+                // Perform the action indicated by the request
+                action(msg_id, &method, &log_child, payload, conn)
+            })
+            .map_err(|e| HandlerError::IO(other_error(&e)))
+    }
+}
+
+pub mod types {
+    use std::collections::HashMap;
+    use std::io::Error as IOError;
+
+    use postgres::error::Error as PGError;
+    use postgres::row::Row;
+    use uuid::Uuid;
+
+    use cueball::error::Error as CueballError;
+    use rust_fast::protocol::FastMessage;
+
+    pub type Rows = Vec<Row>;
+    pub type PostgresResult<T> = Result<T, PGError>;
+    pub type Hstore = HashMap<String, Option<String>>;
+    pub type Timestamptz = chrono::DateTime<chrono::Utc>;
+
+    pub(crate) enum HandlerError {
+        Cueball(CueballError),
+        IO(IOError),
+    }
+
+    pub(crate) enum HandlerResponse {
+        Message(FastMessage),
+        Messages(Vec<FastMessage>),
+    }
+
+    impl From<FastMessage> for HandlerResponse {
+        fn from(fm: FastMessage) -> Self {
+            HandlerResponse::Message(fm)
+        }
+    }
+
+    impl From<Vec<FastMessage>> for HandlerResponse {
+        fn from(fms: Vec<FastMessage>) -> Self {
+            HandlerResponse::Messages(fms)
+        }
+    }
+
+    pub(crate) trait HasRequestId {
+        fn request_id(&self) -> Uuid;
+    }
 }
diff --git a/src/main.rs b/src/main.rs
index 4680cef..4add3c8 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -107,7 +107,7 @@ fn main() {
             let pool_clone = pool.clone();
             let task = server::make_task(
                 socket,
-                move |a, c| boray::util::msg_handler(a, &pool_clone, c),
+                move |a, c| boray::util::handle_msg(a, &pool_clone, c),
                 &process_log,
             );
             tokio::spawn(task);
diff --git a/src/object.rs b/src/object.rs
index cb0a3ec..0aab986 100644
--- a/src/object.rs
+++ b/src/object.rs
@@ -11,7 +11,7 @@ use tokio_postgres::{accepts, to_sql_checked};
 use uuid::Uuid;
 
 use crate::error::{BorayError, BorayErrorType};
-use crate::util::{Hstore, Rows, Timestamptz};
+use crate::types::{HasRequestId, Hstore, Rows, Timestamptz};
 
 pub mod create;
 pub mod delete;
@@ -28,6 +28,12 @@ pub struct GetObjectPayload {
     pub request_id: Uuid,
 }
 
+impl HasRequestId for GetObjectPayload {
+    fn request_id(&self) -> Uuid {
+        self.request_id
+    }
+}
+
 type DeleteObjectPayload = GetObjectPayload;
 
 /// A type that represents the information about the datacenter and storage node
diff --git a/src/object/create.rs b/src/object/create.rs
index e3394f7..ea18f5f 100644
--- a/src/object/create.rs
+++ b/src/object/create.rs
@@ -4,8 +4,9 @@ use std::vec::Vec;
 
 use base64;
 use serde_derive::{Deserialize, Serialize};
+use serde_json::Error as SerdeError;
 use serde_json::{json, Value};
-use slog::{debug, error, o, warn, Logger};
+use slog::{debug, error, Logger};
 use uuid::Uuid;
 
 use cueball_postgres_connection::PostgresConnection;
@@ -15,9 +16,8 @@ use crate::object::{
     insert_delete_table_sql, response, to_json, ObjectResponse, StorageNodeIdentifier,
 };
 use crate::sql;
-use crate::util::{array_wrap, other_error, HandlerError, HandlerResponse, Hstore};
-
-const METHOD: &str = "createobject";
+use crate::types::{HandlerResponse, HasRequestId, Hstore};
+use crate::util::array_wrap;
 
 #[derive(Clone, Debug, Deserialize, PartialEq, Serialize)]
 pub struct CreateObjectPayload {
@@ -35,74 +35,62 @@ pub struct CreateObjectPayload {
     pub request_id: Uuid,
 }
 
-pub(crate) fn handler(
+impl HasRequestId for CreateObjectPayload {
+    fn request_id(&self) -> Uuid {
+        self.request_id
+    }
+}
+
+pub(crate) fn decode_msg(value: &Value) -> Result<Vec<CreateObjectPayload>, SerdeError> {
+    serde_json::from_value::<Vec<CreateObjectPayload>>(value.clone())
+}
+
+pub(crate) fn action(
     msg_id: u32,
-    data: &Value,
-    mut conn: &mut PostgresConnection,
+    method: &str,
     log: &Logger,
-) -> Result<HandlerResponse, HandlerError> {
-    let mut log_child = log.clone();
-    debug!(log_child, "handling {} function request", &METHOD);
-
-    serde_json::from_value::<Vec<CreateObjectPayload>>(data.clone())
-        .map_err(|e| e.to_string())
-        .and_then(|mut arr| {
-            // Remove outer JSON array required by Fast
-            if !arr.is_empty() {
-                Ok(arr.remove(0))
-            } else {
-                let err_msg = "Failed to parse JSON data as payload for \
-                               createobject function";
-                warn!(log_child, "{}: {}", err_msg, data);
-                Err(err_msg.to_string())
-            }
+    payload: CreateObjectPayload,
+    conn: &mut PostgresConnection,
+) -> Result<HandlerResponse, String> {
+    // Make database request
+    do_create(method, payload, conn)
+        .and_then(|maybe_resp| {
+            // Handle the successful database response
+            debug!(log, "{} operation was successful", &method);
+            // The `None` branch of the following match statement should
+            // never be reached. If `maybe_resp` was `None` this would
+            // mean that the SQL INSERT for the object was successful
+            // and the transaction committed, but no results were
+            // returned from the RETURNING clause. This should not be
+            // possible, but for completeleness we include a check for
+            // the condition.
+            let value = match maybe_resp {
+                Some(resp) => to_json(resp),
+                None => object_create_failed(),
+            };
+            let msg_data = FastMessageData::new(method.into(), array_wrap(value));
+            let msg: HandlerResponse = FastMessage::data(msg_id, msg_data).into();
+            Ok(msg)
         })
-        .and_then(|payload| {
-            // Make database request
-            let req_id = payload.request_id;
-            log_child = log_child.new(o!("req_id" => req_id.to_string()));
-
-            debug!(log_child, "parsed CreateObjectPayload");
-
-            create(payload, &mut conn)
-                .and_then(|maybe_resp| {
-                    // Handle the successful database response
-                    debug!(log_child, "{} operation was successful", &METHOD);
-                    // The `None` branch of the following match statement should
-                    // never be reached. If `maybe_resp` was `None` this would
-                    // mean that the SQL INSERT for the object was successful
-                    // and the transaction committed, but no results were
-                    // returned from the RETURNING clause. This should not be
-                    // possible, but for completeleness we include a check for
-                    // the condition.
-                    let value = match maybe_resp {
-                        Some(resp) => to_json(resp),
-                        None => object_create_failed(),
-                    };
-                    let msg_data = FastMessageData::new(METHOD.into(), array_wrap(value));
-                    let msg: HandlerResponse = FastMessage::data(msg_id, msg_data).into();
-                    Ok(msg)
-                })
-                .or_else(|e| {
-                    // Handle database error response
-                    error!(log_child, "{} operation failed: {}", &METHOD, &e);
+        .or_else(|e| {
+            // Handle database error response
+            error!(log, "{} operation failed: {}", &method, &e);
 
-                    // Database errors are returned to as regular Fast messages
-                    // to be handled by the calling application
-                    let value = array_wrap(json!({
-                        "name": "PostgresError",
-                        "message": e
-                    }));
+            // Database errors are returned to as regular Fast messages
+            // to be handled by the calling application
+            let value = array_wrap(json!({
+                "name": "PostgresError",
+                "message": e
+            }));
 
-                    let msg_data = FastMessageData::new(METHOD.into(), value);
-                    let msg: HandlerResponse = FastMessage::data(msg_id, msg_data).into();
-                    Ok(msg)
-                })
+            let msg_data = FastMessageData::new(method.into(), value);
+            let msg: HandlerResponse = FastMessage::data(msg_id, msg_data).into();
+            Ok(msg)
         })
-        .map_err(|e| HandlerError::IO(other_error(&e)))
 }
 
-fn create(
+fn do_create(
+    method: &str,
     payload: CreateObjectPayload,
     conn: &mut PostgresConnection,
 ) -> Result<Option<ObjectResponse>, String> {
@@ -146,7 +134,7 @@ fn create(
         Ok(rows)
     })
     .map_err(|e| e.to_string())
-    .and_then(|rows| response(METHOD, rows))
+    .and_then(|rows| response(method, rows))
 }
 
 fn create_sql(vnode: u64) -> String {
diff --git a/src/object/delete.rs b/src/object/delete.rs
index 0ce5e00..6c4de6e 100644
--- a/src/object/delete.rs
+++ b/src/object/delete.rs
@@ -2,87 +2,68 @@
 
 use std::vec::Vec;
 
+use serde_json::Error as SerdeError;
 use serde_json::{json, Value};
-use slog::{debug, error, o, warn, Logger};
+use slog::{debug, error, Logger};
 
 use cueball_postgres_connection::PostgresConnection;
 use rust_fast::protocol::{FastMessage, FastMessageData};
 
 use crate::object::{insert_delete_table_sql, object_not_found, DeleteObjectPayload};
 use crate::sql;
-use crate::util::{array_wrap, other_error, HandlerError, HandlerResponse};
+use crate::types::HandlerResponse;
+use crate::util::array_wrap;
 
-const METHOD: &str = "deleteobject";
+pub(crate) fn decode_msg(value: &Value) -> Result<Vec<DeleteObjectPayload>, SerdeError> {
+    serde_json::from_value::<Vec<DeleteObjectPayload>>(value.clone())
+}
 
-pub(crate) fn handler(
+pub(crate) fn action(
     msg_id: u32,
-    data: &Value,
-    mut conn: &mut PostgresConnection,
+    method: &str,
     log: &Logger,
-) -> Result<HandlerResponse, HandlerError> {
-    let mut log_child = log.clone();
-    debug!(log_child, "handling {} function request", &METHOD);
-
-    serde_json::from_value::<Vec<DeleteObjectPayload>>(data.clone())
-        .map_err(|e| e.to_string())
-        .and_then(|mut arr| {
-            // Remove outer JSON array required by Fast
-            if !arr.is_empty() {
-                Ok(arr.remove(0))
+    payload: DeleteObjectPayload,
+    conn: &mut PostgresConnection,
+) -> Result<HandlerResponse, String> {
+    // Make database request
+    do_delete(payload, conn)
+        .and_then(|affected_rows| {
+            // Handle the successful database response
+            debug!(log, "{} operation was successful", &method);
+            let value = if affected_rows > 0 {
+                // This conversion can fail if the implementation of
+                // Serialize decides to fail, or if the type
+                // contains a map with non-string keys. There is no
+                // reason for the former to occur and the latter
+                // reason for failure is not a concern here since
+                // the type of `affected_rows` is u64.
+                serde_json::to_value(affected_rows).unwrap()
             } else {
-                let err_msg = "Failed to parse JSON data as payload for \
-                               deleteobject function";
-                warn!(log_child, "{}: {}", err_msg, data);
-                Err(err_msg.to_string())
-            }
-        })
-        .and_then(|payload| {
-            // Make database request
-            let req_id = payload.request_id;
-            log_child = log_child.new(o!("req_id" => req_id.to_string()));
+                object_not_found()
+            };
 
-            debug!(log_child, "parsed DeleteObjectPayload");
-
-            delete(payload, &mut conn)
-                .and_then(|affected_rows| {
-                    // Handle the successful database response
-                    debug!(log_child, "{} operation was successful", &METHOD);
-                    let value = if affected_rows > 0 {
-                        // This conversion can fail if the implementation of
-                        // Serialize decides to fail, or if the type
-                        // contains a map with non-string keys. There is no
-                        // reason for the former to occur and the latter
-                        // reason for failure is not a concern here since
-                        // the type of `affected_rows` is u64.
-                        serde_json::to_value(affected_rows).unwrap()
-                    } else {
-                        object_not_found()
-                    };
-
-                    let msg_data = FastMessageData::new(METHOD.into(), array_wrap(value));
-                    let msg: HandlerResponse = FastMessage::data(msg_id, msg_data).into();
-                    Ok(msg)
-                })
-                .or_else(|e| {
-                    // Handle database error response
-                    error!(log_child, "{} operation failed: {}", &METHOD, &e);
+            let msg_data = FastMessageData::new(method.into(), array_wrap(value));
+            let msg: HandlerResponse = FastMessage::data(msg_id, msg_data).into();
+            Ok(msg)
+        })
+        .or_else(|e| {
+            // Handle database error response
+            error!(log, "{} operation failed: {}", &method, &e);
 
-                    // Database errors are returned to as regular Fast messages
-                    // to be handled by the calling application
-                    let value = array_wrap(json!({
-                        "name": "PostgresError",
-                        "message": e
-                    }));
+            // Database errors are returned to as regular Fast messages
+            // to be handled by the calling application
+            let value = array_wrap(json!({
+                "name": "PostgresError",
+                "message": e
+            }));
 
-                    let msg_data = FastMessageData::new(METHOD.into(), value);
-                    let msg: HandlerResponse = FastMessage::data(msg_id, msg_data).into();
-                    Ok(msg)
-                })
+            let msg_data = FastMessageData::new(method.into(), value);
+            let msg: HandlerResponse = FastMessage::data(msg_id, msg_data).into();
+            Ok(msg)
         })
-        .map_err(|e| HandlerError::IO(other_error(&e)))
 }
 
-fn delete(payload: DeleteObjectPayload, conn: &mut PostgresConnection) -> Result<u64, String> {
+fn do_delete(payload: DeleteObjectPayload, conn: &mut PostgresConnection) -> Result<u64, String> {
     let mut txn = (*conn).transaction().map_err(|e| e.to_string())?;
     let move_sql = insert_delete_table_sql(payload.vnode);
     let delete_sql = delete_sql(payload.vnode);
diff --git a/src/object/get.rs b/src/object/get.rs
index 2f9df12..bcfe781 100644
--- a/src/object/get.rs
+++ b/src/object/get.rs
@@ -2,79 +2,61 @@
 
 use std::vec::Vec;
 
+use serde_json::Error as SerdeError;
 use serde_json::{json, Value};
-use slog::{debug, error, o, warn, Logger};
+use slog::{debug, error, Logger};
 
 use cueball_postgres_connection::PostgresConnection;
 use rust_fast::protocol::{FastMessage, FastMessageData};
 
 use crate::object::{object_not_found, response, to_json, GetObjectPayload, ObjectResponse};
 use crate::sql;
-use crate::util::{array_wrap, other_error, HandlerError, HandlerResponse};
+use crate::types::HandlerResponse;
+use crate::util::array_wrap;
 
-const METHOD: &str = "getobject";
+pub(crate) fn decode_msg(value: &Value) -> Result<Vec<GetObjectPayload>, SerdeError> {
+    serde_json::from_value::<Vec<GetObjectPayload>>(value.clone())
+}
 
-pub(crate) fn handler(
+pub(crate) fn action(
     msg_id: u32,
-    data: &Value,
-    mut conn: &mut PostgresConnection,
+    method: &str,
     log: &Logger,
-) -> Result<HandlerResponse, HandlerError> {
-    let mut log_child = log.clone();
-    debug!(log_child, "handling getobject function request");
-
-    serde_json::from_value::<Vec<GetObjectPayload>>(data.clone())
-        .map_err(|e| e.to_string())
-        .and_then(|mut arr| {
-            // Remove outer JSON array required by Fast
-            if !arr.is_empty() {
-                Ok(arr.remove(0))
-            } else {
-                let err_msg = "Failed to parse JSON data as payload for \
-                               getobject function";
-                warn!(log_child, "{}: {}", err_msg, data);
-                Err(err_msg.to_string())
-            }
+    payload: GetObjectPayload,
+    conn: &mut PostgresConnection,
+) -> Result<HandlerResponse, String> {
+    // Make database request
+    do_get(method, payload, conn)
+        .and_then(|maybe_resp| {
+            // Handle the successful database response
+            debug!(log, "getobject operation was successful");
+            let value = match maybe_resp {
+                Some(resp) => array_wrap(to_json(resp)),
+                None => array_wrap(object_not_found()),
+            };
+            let msg_data = FastMessageData::new(method.into(), value);
+            let msg: HandlerResponse = FastMessage::data(msg_id, msg_data).into();
+            Ok(msg)
         })
-        .and_then(|payload| {
-            // Make database request
-            let req_id = payload.request_id;
-            log_child = log_child.new(o!("req_id" => req_id.to_string()));
-
-            debug!(log_child, "parsed GetObjectPayload");
-
-            get(payload, &mut conn)
-                .and_then(|maybe_resp| {
-                    // Handle the successful database response
-                    debug!(log_child, "getobject operation was successful");
-                    let value = match maybe_resp {
-                        Some(resp) => array_wrap(to_json(resp)),
-                        None => array_wrap(object_not_found()),
-                    };
-                    let msg_data = FastMessageData::new(METHOD.into(), value);
-                    let msg: HandlerResponse = FastMessage::data(msg_id, msg_data).into();
-                    Ok(msg)
-                })
-                .or_else(|e| {
-                    // Handle database error response
-                    error!(log_child, "getobject operation failed: {}", &e);
+        .or_else(|e| {
+            // Handle database error response
+            error!(log, "getobject operation failed: {}", &e);
 
-                    // Database errors are returned to as regular Fast messages
-                    // to be handled by the calling application
-                    let value = array_wrap(json!({
-                        "name": "PostgresError",
-                        "message": e
-                    }));
+            // Database errors are returned to as regular Fast messages
+            // to be handled by the calling application
+            let value = array_wrap(json!({
+                "name": "PostgresError",
+                "message": e
+            }));
 
-                    let msg_data = FastMessageData::new(METHOD.into(), value);
-                    let msg: HandlerResponse = FastMessage::data(msg_id, msg_data).into();
-                    Ok(msg)
-                })
+            let msg_data = FastMessageData::new(method.into(), value);
+            let msg: HandlerResponse = FastMessage::data(msg_id, msg_data).into();
+            Ok(msg)
         })
-        .map_err(|e| HandlerError::IO(other_error(&e)))
 }
 
-fn get(
+fn do_get(
+    method: &str,
     payload: GetObjectPayload,
     mut conn: &mut PostgresConnection,
 ) -> Result<Option<ObjectResponse>, String> {
@@ -87,7 +69,7 @@ fn get(
         &[&payload.owner, &payload.bucket_id, &payload.name],
     )
     .map_err(|e| e.to_string())
-    .and_then(|rows| response(METHOD, rows))
+    .and_then(|rows| response(method, rows))
 }
 
 fn get_sql(vnode: u64) -> String {
diff --git a/src/object/list.rs b/src/object/list.rs
index f46c84b..a5eb70b 100644
--- a/src/object/list.rs
+++ b/src/object/list.rs
@@ -4,8 +4,9 @@ use std::vec::Vec;
 
 use base64;
 use serde_derive::{Deserialize, Serialize};
+use serde_json::Error as SerdeError;
 use serde_json::{json, Value};
-use slog::{debug, error, o, warn, Logger};
+use slog::{debug, error, Logger};
 use uuid::Uuid;
 
 use cueball_postgres_connection::PostgresConnection;
@@ -13,9 +14,8 @@ use rust_fast::protocol::{FastMessage, FastMessageData};
 
 use crate::object::{to_json, ObjectResponse};
 use crate::sql;
-use crate::util::{array_wrap, other_error, HandlerError, HandlerResponse};
-
-const METHOD: &str = "listobjects";
+use crate::types::{HandlerResponse, HasRequestId};
+use crate::util::array_wrap;
 
 #[derive(Clone, Debug, Deserialize, PartialEq, Serialize)]
 pub struct ListObjectsPayload {
@@ -28,79 +28,66 @@ pub struct ListObjectsPayload {
     pub request_id: Uuid,
 }
 
-pub(crate) fn handler(
-    msg_id: u32,
-    data: &Value,
-    mut conn: &mut PostgresConnection,
-    log: &Logger,
-) -> Result<HandlerResponse, HandlerError> {
-    let mut log_child = log.clone();
-    debug!(log_child, "handling {} function request", &METHOD);
-
-    serde_json::from_value::<Vec<ListObjectsPayload>>(data.clone())
-        .map_err(|e| e.to_string())
-        .and_then(|mut arr| {
-            // Remove outer JSON array required by Fast
-            if !arr.is_empty() {
-                Ok(arr.remove(0))
-            } else {
-                let err_msg = "Failed to parse JSON data as payload for \
-                               getobject function";
-                warn!(log_child, "{}: {}", err_msg, data);
-                Err(err_msg.to_string())
-            }
-        })
-        .and_then(|payload| {
-            // Make database request
-            let req_id = payload.request_id;
-            log_child = log_child.new(o!("req_id" => req_id.to_string()));
+impl HasRequestId for ListObjectsPayload {
+    fn request_id(&self) -> Uuid {
+        self.request_id
+    }
+}
 
-            debug!(log_child, "parsed ListObjectsPayload");
+pub(crate) fn decode_msg(value: &Value) -> Result<Vec<ListObjectsPayload>, SerdeError> {
+    serde_json::from_value::<Vec<ListObjectsPayload>>(value.clone())
+}
 
-            if payload.limit > 0 && payload.limit <= 1024 {
-                list(msg_id, payload, &mut conn)
-                    .and_then(|resp| {
-                        // Handle the successful database response
-                        debug!(log_child, "{} operation was successful", &METHOD);
-                        Ok(HandlerResponse::from(resp))
-                    })
-                    .or_else(|e| {
-                        // Handle database error response
-                        error!(log_child, "{} operation failed: {}", &METHOD, &e);
+pub(crate) fn action(
+    msg_id: u32,
+    method: &str,
+    log: &Logger,
+    payload: ListObjectsPayload,
+    conn: &mut PostgresConnection,
+) -> Result<HandlerResponse, String> {
+    // Make database request
+    if payload.limit > 0 && payload.limit <= 1024 {
+        do_list(msg_id, method, payload, conn)
+            .and_then(|resp| {
+                // Handle the successful database response
+                debug!(log, "{} operation was successful", &method);
+                Ok(HandlerResponse::from(resp))
+            })
+            .or_else(|e| {
+                // Handle database error response
+                error!(log, "{} operation failed: {}", &method, &e);
 
-                        // Database errors are returned to as regular Fast messages
-                        // to be handled by the calling application
-                        let value = array_wrap(json!({
-                            "name": "PostgresError",
-                            "message": e
-                        }));
-                        let msg_data = FastMessageData::new(METHOD.into(), value);
-                        let msg: HandlerResponse = FastMessage::data(msg_id, msg_data).into();
-                        Ok(msg)
-                    })
-            } else {
-                // Limit constraint violations are returned to as regular
-                // Fast messages to be handled by the calling application
-                let e = format!(
-                    "the {} limit option must be a value between 1 \
-                     and 1024. the requested limit was {}, req_id: \
-                     {}",
-                    &METHOD, &payload.limit, &req_id
-                );
+                // Database errors are returned to as regular Fast messages
+                // to be handled by the calling application
                 let value = array_wrap(json!({
-                    "name": "LimitConstraintError",
+                    "name": "PostgresError",
                     "message": e
                 }));
-                let msg_data = FastMessageData::new(METHOD.into(), value);
+                let msg_data = FastMessageData::new(method.into(), value);
                 let msg: HandlerResponse = FastMessage::data(msg_id, msg_data).into();
                 Ok(msg)
-            }
-        })
-        .map_err(|e| HandlerError::IO(other_error(&e)))
+            })
+    } else {
+        // Limit constraint violations are returned to as regular
+        // Fast messages to be handled by the calling application
+        let e = format!(
+            "the {} limit option must be a value between 1 \
+             and 1024. the requested limit was {}",
+            &method, &payload.limit
+        );
+        let value = array_wrap(json!({
+            "name": "LimitConstraintError",
+            "message": e
+        }));
+        let msg_data = FastMessageData::new(method.into(), value);
+        let msg: HandlerResponse = FastMessage::data(msg_id, msg_data).into();
+        Ok(msg)
+    }
 }
 
-fn list(
+fn do_list(
     msg_id: u32,
+    method: &str,
     payload: ListObjectsPayload,
     mut conn: &mut PostgresConnection,
 ) -> Result<Vec<FastMessage>, String> {
@@ -167,7 +154,7 @@ fn list(
             };
 
             let value = to_json(resp);
-            let msg_data = FastMessageData::new(METHOD.into(), array_wrap(value));
+            let msg_data = FastMessageData::new(method.into(), array_wrap(value));
             let msg = FastMessage::data(msg_id, msg_data);
 
             msgs.push(msg);
diff --git a/src/object/update.rs b/src/object/update.rs
index 7cb8910..0d6246e 100644
--- a/src/object/update.rs
+++ b/src/object/update.rs
@@ -3,8 +3,9 @@
 use std::vec::Vec;
 
 use serde_derive::{Deserialize, Serialize};
+use serde_json::Error as SerdeError;
 use serde_json::{json, Value};
-use slog::{debug, error, o, warn, Logger};
+use slog::{debug, error, Logger};
 use uuid::Uuid;
 
 use cueball_postgres_connection::PostgresConnection;
@@ -12,9 +13,8 @@ use rust_fast::protocol::{FastMessage, FastMessageData};
 
 use crate::object::{object_not_found, response, to_json, ObjectResponse};
 use crate::sql;
-use crate::util::{array_wrap, other_error, HandlerError, HandlerResponse, Hstore};
-
-const METHOD: &str = "updateobject";
+use crate::types::{HandlerResponse, HasRequestId, Hstore};
+use crate::util::array_wrap;
 
 #[derive(Clone, Debug, Deserialize, PartialEq, Serialize)]
 pub struct UpdateObjectPayload {
@@ -29,67 +29,55 @@ pub struct UpdateObjectPayload {
     pub request_id: Uuid,
 }
 
-pub(crate) fn handler(
+impl HasRequestId for UpdateObjectPayload {
+    fn request_id(&self) -> Uuid {
+        self.request_id
+    }
+}
+
+pub(crate) fn decode_msg(value: &Value) -> Result<Vec<UpdateObjectPayload>, SerdeError> {
+    serde_json::from_value::<Vec<UpdateObjectPayload>>(value.clone())
+}
+
+pub(crate) fn action(
     msg_id: u32,
-    data: &Value,
-    mut conn: &mut PostgresConnection,
+    method: &str,
     log: &Logger,
-) -> Result<HandlerResponse, HandlerError> {
-    let mut log_child = log.clone();
-    debug!(log_child, "handling {} function request", &METHOD);
-
-    serde_json::from_value::<Vec<UpdateObjectPayload>>(data.clone())
-        .map_err(|e| e.to_string())
-        .and_then(|mut arr| {
-            // Remove outer JSON array required by Fast
-            if !arr.is_empty() {
-                Ok(arr.remove(0))
-            } else {
-                let err_msg = "Failed to parse JSON data as payload for \
-                               updateobject function";
-                warn!(log_child, "{}: {}", err_msg, data);
-                Err(err_msg.to_string())
-            }
+    payload: UpdateObjectPayload,
+    conn: &mut PostgresConnection,
+) -> Result<HandlerResponse, String> {
+    // Make database request
+    do_update(method, payload, conn)
+        .and_then(|maybe_resp| {
+            // Handle the successful database response
+            debug!(log, "{} operation was successful", &method);
+            let value = match maybe_resp {
+                Some(resp) => to_json(resp),
+                None => object_not_found(),
+            };
+            let msg_data = FastMessageData::new(method.into(), array_wrap(value));
+            let msg: HandlerResponse = FastMessage::data(msg_id, msg_data).into();
+            Ok(msg)
         })
-        .and_then(|payload| {
-            // Make database request
-            let req_id = payload.request_id;
-            log_child = log_child.new(o!("req_id" => req_id.to_string()));
-
-            debug!(log_child, "parsed UpdateObjectPayload");
-
-            update(payload, &mut conn)
-                .and_then(|maybe_resp| {
-                    // Handle the successful database response
-                    debug!(log_child, "{} operation was successful", &METHOD);
-                    let value = match maybe_resp {
-                        Some(resp) => to_json(resp),
-                        None => object_not_found(),
-                    };
-                    let msg_data = FastMessageData::new(METHOD.into(), array_wrap(value));
-                    let msg: HandlerResponse = FastMessage::data(msg_id, msg_data).into();
-                    Ok(msg)
-                })
-                .or_else(|e| {
-                    // Handle database error response
-                    error!(log_child, "{} operation failed: {}", &METHOD, &e);
-
-                    // Database errors are returned to as regular Fast messages
-                    // to be handled by the calling application
-                    let value = array_wrap(json!({
-                        "name": "PostgresError",
-                        "message": e
-                    }));
-
-                    let msg_data = FastMessageData::new(METHOD.into(), value);
-                    let msg: HandlerResponse = FastMessage::data(msg_id, msg_data).into();
-                    Ok(msg)
-                })
+        .or_else(|e| {
+            // Handle database error response
+            error!(log, "{} operation failed: {}", &method, &e);
+
+            // Database errors are returned to as regular Fast messages
+            // to be handled by the calling application
+            let value = array_wrap(json!({
+                "name": "PostgresError",
+                "message": e
+            }));
+
+            let msg_data = FastMessageData::new(method.into(), value);
+            let msg: HandlerResponse = FastMessage::data(msg_id, msg_data).into();
+            Ok(msg)
         })
-        .map_err(|e| HandlerError::IO(other_error(&e)))
 }
 
-fn update(
+fn do_update(
+    method: &str,
     payload: UpdateObjectPayload,
     conn: &mut PostgresConnection,
 ) -> Result<Option<ObjectResponse>, String> {
@@ -114,7 +102,7 @@ fn update(
         Ok(rows)
     })
     .map_err(|e| e.to_string())
-    .and_then(|rows| response(METHOD, rows))
+    .and_then(|rows| response(method, rows))
 }
 
 fn update_sql(vnode: u64) -> String {
diff --git a/tests/rpc_handlers.rs b/tests/rpc_handlers.rs
index f28b959..539384e 100644
--- a/tests/rpc_handlers.rs
+++ b/tests/rpc_handlers.rs
@@ -111,7 +111,7 @@ fn verify_rpc_handlers() {
     let get_bucket_json = serde_json::to_value(vec![get_bucket_payload]).unwrap();
     let get_bucket_fast_msg_data = FastMessageData::new("getbucket".into(), get_bucket_json);
     let get_bucket_fast_msg = FastMessage::data(msg_id, get_bucket_fast_msg_data);
-    let mut get_bucket_result = util::msg_handler(&get_bucket_fast_msg, &pool, &log);
+    let mut get_bucket_result = util::handle_msg(&get_bucket_fast_msg, &pool, &log);
 
     assert!(get_bucket_result.is_ok());
     let get_bucket_response = get_bucket_result.unwrap();
@@ -137,7 +137,7 @@ fn verify_rpc_handlers() {
     let create_bucket_fast_msg_data =
         FastMessageData::new("createbucket".into(), create_bucket_json);
     let create_bucket_fast_msg = FastMessage::data(msg_id, create_bucket_fast_msg_data);
-    let mut create_bucket_result = util::msg_handler(&create_bucket_fast_msg, &pool, &log);
+    let mut create_bucket_result = util::handle_msg(&create_bucket_fast_msg, &pool, &log);
 
     assert!(create_bucket_result.is_ok());
     let create_bucket_response = create_bucket_result.unwrap();
@@ -149,7 +149,7 @@ fn verify_rpc_handlers() {
     assert_eq!(create_bucket_response_result.unwrap().name, bucket);
 
     // Read bucket again and make sure the resonse is returned successfully
-    get_bucket_result = util::msg_handler(&get_bucket_fast_msg, &pool, &log);
+    get_bucket_result = util::handle_msg(&get_bucket_fast_msg, &pool, &log);
 
     assert!(get_bucket_result.is_ok());
     let get_bucket_response = get_bucket_result.unwrap();
@@ -162,7 +162,7 @@ fn verify_rpc_handlers() {
 
     // Try to create same bucket again and verify a BucketAlreadyExists error is
     // returned
-    create_bucket_result = util::msg_handler(&create_bucket_fast_msg, &pool, &log);
+    create_bucket_result = util::handle_msg(&create_bucket_fast_msg, &pool, &log);
 
     assert!(create_bucket_result.is_ok());
     let create_bucket_response = create_bucket_result.unwrap();
@@ -188,7 +188,7 @@ fn verify_rpc_handlers() {
     let delete_bucket_fast_msg_data =
         FastMessageData::new("deletebucket".into(), delete_bucket_json);
     let delete_bucket_fast_msg = FastMessage::data(msg_id, delete_bucket_fast_msg_data);
-    let mut delete_bucket_result = util::msg_handler(&delete_bucket_fast_msg, &pool, &log);
+    let mut delete_bucket_result = util::handle_msg(&delete_bucket_fast_msg, &pool, &log);
 
     assert!(delete_bucket_result.is_ok());
     let delete_bucket_response = delete_bucket_result.unwrap();
@@ -200,7 +200,7 @@ fn verify_rpc_handlers() {
     assert_eq!(delete_bucket_response_result.unwrap(), 1);
 
     // Read bucket again and verify it's gone
-    get_bucket_result = util::msg_handler(&get_bucket_fast_msg, &pool, &log);
+    get_bucket_result = util::handle_msg(&get_bucket_fast_msg, &pool, &log);
 
     assert!(get_bucket_result.is_ok());
     let get_bucket_response = get_bucket_result.unwrap();
@@ -215,7 +215,7 @@ fn verify_rpc_handlers() {
     );
 
     // Attempt to delete a nonexistent bucket and verify an error is returned
-    delete_bucket_result = util::msg_handler(&delete_bucket_fast_msg, &pool, &log);
+    delete_bucket_result = util::handle_msg(&delete_bucket_fast_msg, &pool, &log);
 
     assert!(delete_bucket_result.is_ok());
     let delete_bucket_response = delete_bucket_result.unwrap();
@@ -243,7 +243,7 @@ fn verify_rpc_handlers() {
     let get_object_json = serde_json::to_value(vec![&get_object_payload]).unwrap();
     let get_object_fast_msg_data = FastMessageData::new("getobject".into(), get_object_json);
     let get_object_fast_msg = FastMessage::data(msg_id, get_object_fast_msg_data);
-    let mut get_object_result = util::msg_handler(&get_object_fast_msg, &pool, &log);
+    let mut get_object_result = util::handle_msg(&get_object_fast_msg, &pool, &log);
 
     assert!(get_object_result.is_ok());
     let get_object_response = get_object_result.unwrap();
@@ -286,7 +286,7 @@ fn verify_rpc_handlers() {
     let update_object_fast_msg_data =
         FastMessageData::new("updateobject".into(), update_object_json);
     let update_object_fast_msg = FastMessage::data(msg_id, update_object_fast_msg_data);
-    let mut update_object_result = util::msg_handler(&update_object_fast_msg, &pool, &log);
+    let mut update_object_result = util::handle_msg(&update_object_fast_msg, &pool, &log);
 
     assert!(update_object_result.is_ok());
     let mut update_object_response = update_object_result.unwrap();
@@ -329,7 +329,7 @@ fn verify_rpc_handlers() {
     let create_object_fast_msg_data =
         FastMessageData::new("createobject".into(), create_object_json);
     let create_object_fast_msg = FastMessage::data(msg_id, create_object_fast_msg_data);
-    let mut create_object_result = util::msg_handler(&create_object_fast_msg, &pool, &log);
+    let mut create_object_result = util::handle_msg(&create_object_fast_msg, &pool, &log);
 
     assert!(create_object_result.is_ok());
     let create_object_response = create_object_result.unwrap();
@@ -341,7 +341,7 @@ fn verify_rpc_handlers() {
     assert_eq!(create_object_response_result.unwrap().name, object);
 
     // Read object again and verify a successful response is returned
-    get_object_result = util::msg_handler(&get_object_fast_msg, &pool, &log);
+    get_object_result = util::handle_msg(&get_object_fast_msg, &pool, &log);
 
     assert!(get_object_result.is_ok());
     let get_object_response = get_object_result.unwrap();
@@ -355,7 +355,7 @@ fn verify_rpc_handlers() {
     assert_eq!(&get_object_unwrapped_result.content_type, "text/plain");
 
     // Update the object's metadata and verify it is successful
-    update_object_result = util::msg_handler(&update_object_fast_msg, &pool, &log);
+    update_object_result = util::handle_msg(&update_object_fast_msg, &pool, &log);
 
     assert!(update_object_result.is_ok());
     update_object_response = update_object_result.unwrap();
@@ -369,7 +369,7 @@ fn verify_rpc_handlers() {
     assert_eq!(&update_object_unwrapped_result.content_type, "text/html");
 
     // Read object again and verify the metadata update
-    get_object_result = util::msg_handler(&get_object_fast_msg, &pool, &log);
+    get_object_result = util::handle_msg(&get_object_fast_msg, &pool, &log);
     assert!(get_object_result.is_ok());
     let get_object_response = get_object_result.unwrap();
     assert_eq!(get_object_response.len(), 1);
@@ -389,7 +389,7 @@ fn verify_rpc_handlers() {
     let delete_object_fast_msg_data =
         FastMessageData::new("deleteobject".into(), delete_object_json);
     let delete_object_fast_msg = FastMessage::data(msg_id, delete_object_fast_msg_data);
-    let mut delete_object_result = util::msg_handler(&delete_object_fast_msg, &pool, &log);
+    let mut delete_object_result = util::handle_msg(&delete_object_fast_msg, &pool, &log);
 
     assert!(delete_object_result.is_ok());
     let delete_object_response = delete_object_result.unwrap();
@@ -401,7 +401,7 @@ fn verify_rpc_handlers() {
     assert_eq!(delete_object_response_result.unwrap(), 1);
 
     // Read object again and verify it is not found
-    get_object_result = util::msg_handler(&get_object_fast_msg, &pool, &log);
+    get_object_result = util::handle_msg(&get_object_fast_msg, &pool, &log);
 
     assert!(get_object_result.is_ok());
     let get_object_response = get_object_result.unwrap();
@@ -416,7 +416,7 @@ fn verify_rpc_handlers() {
     );
 
     // Delete the object again and verify it is not found
-    delete_object_result = util::msg_handler(&delete_object_fast_msg, &pool, &log);
+    delete_object_result = util::handle_msg(&delete_object_fast_msg, &pool, &log);
 
     assert!(delete_object_result.is_ok());
     let delete_object_response = delete_object_result.unwrap();
@@ -444,14 +444,14 @@ fn verify_rpc_handlers() {
     let list_buckets_json = serde_json::to_value(vec![list_buckets_payload]).unwrap();
     let list_buckets_fast_msg_data = FastMessageData::new("listbuckets".into(), list_buckets_json);
     let list_buckets_fast_msg = FastMessage::data(msg_id, list_buckets_fast_msg_data);
-    let mut list_buckets_result = util::msg_handler(&list_buckets_fast_msg, &pool, &log);
+    let mut list_buckets_result = util::handle_msg(&list_buckets_fast_msg, &pool, &log);
 
     assert!(list_buckets_result.is_ok());
     let list_buckets_response = list_buckets_result.unwrap();
     assert_eq!(list_buckets_response.len(), 0);
 
     // Create a bucket and list buckets again
-    create_bucket_result = util::msg_handler(&create_bucket_fast_msg, &pool, &log);
+    create_bucket_result = util::handle_msg(&create_bucket_fast_msg, &pool, &log);
 
     assert!(create_bucket_result.is_ok());
     let create_bucket_response = create_bucket_result.unwrap();
@@ -462,7 +462,7 @@ fn verify_rpc_handlers() {
     assert!(create_bucket_response_result.is_ok());
     assert_eq!(create_bucket_response_result.unwrap().name, bucket);
 
-    list_buckets_result = util::msg_handler(&list_buckets_fast_msg, &pool, &log);
+    list_buckets_result = util::handle_msg(&list_buckets_fast_msg, &pool, &log);
 
     assert!(list_buckets_result.is_ok());
     let list_buckets_response = list_buckets_result.unwrap();
@@ -483,14 +483,14 @@ fn verify_rpc_handlers() {
     let list_objects_json = serde_json::to_value(vec![list_objects_payload]).unwrap();
     let list_objects_fast_msg_data = FastMessageData::new("listobjects".into(), list_objects_json);
     let list_objects_fast_msg = FastMessage::data(msg_id, list_objects_fast_msg_data);
-    let mut list_objects_result = util::msg_handler(&list_objects_fast_msg, &pool, &log);
+    let mut list_objects_result = util::handle_msg(&list_objects_fast_msg, &pool, &log);
 
     assert!(list_objects_result.is_ok());
     let list_objects_response = list_objects_result.unwrap();
     assert_eq!(list_objects_response.len(), 0);
 
     // Create an object and list objects again
-    create_object_result = util::msg_handler(&create_object_fast_msg, &pool, &log);
+    create_object_result = util::handle_msg(&create_object_fast_msg, &pool, &log);
 
     assert!(create_object_result.is_ok());
     let create_object_response = create_object_result.unwrap();
@@ -501,7 +501,7 @@ fn verify_rpc_handlers() {
     assert!(create_object_response_result.is_ok());
     assert_eq!(create_object_response_result.unwrap().name, object);
 
-    list_objects_result = util::msg_handler(&list_objects_fast_msg, &pool, &log);
+    list_objects_result = util::handle_msg(&list_objects_fast_msg, &pool, &log);
 
     assert!(list_objects_result.is_ok());
     let list_objects_response = list_objects_result.unwrap();
