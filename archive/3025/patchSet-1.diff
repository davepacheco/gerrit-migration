commit dd1e75a3d4243d73e95d50c931cda74ade9f55ed (refs/changes/25/3025/1)
Author: Dave Eddy <dave@daveeddy.com>
Date:   2017-12-01T12:50:09-05:00 (1 year, 10 months ago)
    
    OS-6481 upgrade vasync for whilst and filter functions

diff --git a/src/manifest b/src/manifest
index a4cbede8..e8d151a3 100644
--- a/src/manifest
+++ b/src/manifest
@@ -520,6 +520,14 @@ d usr/vm/node_modules/vasync/node_modules/verror 0755 root root
 d usr/vm/node_modules/vasync/node_modules/verror/lib 0755 root root
 f usr/vm/node_modules/vasync/node_modules/verror/lib/verror.js 0755 root root
 d usr/vm/node_modules/vasync/node_modules/verror/node_modules 0755 root root
+d usr/vm/node_modules/vasync/node_modules/verror/node_modules/assert-plus 0755 root root
+f usr/vm/node_modules/vasync/node_modules/verror/node_modules/assert-plus/package.json 0644 root root
+f usr/vm/node_modules/vasync/node_modules/verror/node_modules/assert-plus/assert.js 0644 root root
+d usr/vm/node_modules/vasync/node_modules/verror/node_modules/core-util-is 0755 root root
+f usr/vm/node_modules/vasync/node_modules/verror/node_modules/core-util-is/package.json 0644 root root
+f usr/vm/node_modules/vasync/node_modules/verror/node_modules/core-util-is/LICENSE 0644 root root
+d usr/vm/node_modules/vasync/node_modules/verror/node_modules/core-util-is/lib 0755 root root
+f usr/vm/node_modules/vasync/node_modules/verror/node_modules/core-util-is/lib/util.js 0644 root root
 d usr/vm/node_modules/vasync/node_modules/verror/node_modules/extsprintf 0755 root root
 d usr/vm/node_modules/vasync/node_modules/verror/node_modules/extsprintf/lib 0755 root root
 f usr/vm/node_modules/vasync/node_modules/verror/node_modules/extsprintf/lib/extsprintf.js 0644 root root
diff --git a/src/vm/node_modules/VM.js b/src/vm/node_modules/VM.js
index 3f1e0bd4..49210509 100644
--- a/src/vm/node_modules/VM.js
+++ b/src/vm/node_modules/VM.js
@@ -20,7 +20,7 @@
  *
  * CDDL HEADER END
  *
- * Copyright 2017 Joyent, Inc.
+ * Copyright (c) 2017, Joyent, Inc.
  *
  * Experimental functions, expect these interfaces to be unstable and
  * potentially go away entirely:
@@ -2403,7 +2403,7 @@ function copyFilesystemData(payload, filesystem, log, callback)
     existing = path.join(zonepath, '/root/' + target);
     test_path = existing;
 
-    async.whilst(function () {
+    vasync.whilst(function () {
         if ((test_path.length > (zonepath + '/root').length) && !skip_copy) {
             return (true);
         }
@@ -6662,7 +6662,7 @@ exports.markVMFailure = function (vmobj, options, callback)
                     startpos = 0;
                 }
 
-                async.whilst(function () {
+                vasync.whilst(function () {
                     return ((stats.size - startpos) > 0);
                 }, function (cb) {
                     fs.read(fd, buffer, 0, 4096, startpos,
@@ -8881,7 +8881,7 @@ exports.receive = function (target, options, callback)
             log.info('Receiving VM ' + result.uuid);
             log.debug('now looking for datasets');
 
-            async.whilst(
+            vasync.whilst(
                 function () { return !eof; },
                 function (cb) {
                     receiveStdinChunk('DATASET', log, function (err, res) {
diff --git a/src/vm/node_modules/vasync/lib/vasync.js b/src/vm/node_modules/vasync/lib/vasync.js
index dc262ce6..1b7b5646 100644
--- a/src/vm/node_modules/vasync/lib/vasync.js
+++ b/src/vm/node_modules/vasync/lib/vasync.js
@@ -13,7 +13,12 @@ var mod_verror = require('verror');
 exports.parallel = parallel;
 exports.forEachParallel = forEachParallel;
 exports.pipeline = pipeline;
+exports.tryEach = tryEach;
 exports.forEachPipeline = forEachPipeline;
+exports.filter = filter;
+exports.filterLimit = filterLimit;
+exports.filterSeries = filterSeries;
+exports.whilst = whilst;
 exports.queue = queue;
 exports.queuev = queuev;
 exports.barrier = barrier;
@@ -149,107 +154,254 @@ function forEachParallel(args, callback)
  */
 function pipeline(args, callback)
 {
-	var funcs, uarg, rv, next;
-
 	mod_assert.equal(typeof (args), 'object', '"args" must be an object');
 	mod_assert.ok(Array.isArray(args['funcs']),
 	    '"args.funcs" must be specified and must be an array');
 
-	funcs = args['funcs'].slice(0);
-	uarg = args['arg'];
+	var opts = {
+	    'funcs': args['funcs'].slice(0),
+	    'callback': callback,
+	    'args': { impl: 'pipeline', uarg: args['arg'] },
+	    'stop_when': 'error',
+	    'res_type': 'rv'
+	};
+	return (waterfall_impl(opts));
+}
 
-	rv = {
-	    'operations': funcs.map(function (func) {
-		return ({
-		    'func': func,
-		    'funcname': func.name || '(anon)',
-		    'status': 'waiting'
-		});
-	    }),
-	    'successes': [],
-	    'ndone': 0,
-	    'nerrors': 0
+function tryEach(funcs, callback)
+{
+	mod_assert.ok(Array.isArray(funcs),
+	    '"funcs" must be specified and must be an array');
+	mod_assert.ok(arguments.length == 1 || typeof (callback) == 'function',
+	    '"callback" must be a function');
+	var opts = {
+	    'funcs': funcs.slice(0),
+	    'callback': callback,
+	    'args': { impl: 'tryEach' },
+	    'stop_when': 'success',
+	    'res_type': 'array'
 	};
+	return (waterfall_impl(opts));
+}
 
-	if (funcs.length === 0) {
-		setImmediate(function () { callback(null, rv); });
-		return (rv);
-	}
+/*
+ * Exactly like pipeline, except that the input is specified as a single
+ * function to invoke on N different inputs (rather than N functions).  "args"
+ * must have the following fields:
+ *
+ *	func		asynchronous function to invoke on each input value
+ *
+ *	inputs		array of input values
+ */
+function forEachPipeline(args, callback) {
+	mod_assert.equal(typeof (args), 'object', '"args" must be an object');
+	mod_assert.equal(typeof (args['func']), 'function',
+	    '"args.func" must be specified and must be a function');
+	mod_assert.ok(Array.isArray(args['inputs']),
+	    '"args.inputs" must be specified and must be an array');
+	mod_assert.equal(typeof (callback), 'function',
+	    'callback argument must be specified and must be a function');
 
-	next = function (err, result) {
-		if (rv['nerrors'] > 0 ||
-		    rv['ndone'] >= rv['operations'].length) {
-			throw new mod_verror.VError('pipeline callback ' +
-			    'invoked after the pipeline has already ' +
-			    'completed (%j)', rv);
-		}
+	var func = args['func'];
 
-		var entry = rv['operations'][rv['ndone']++];
+	var funcs = args['inputs'].map(function (input) {
+		return (function (_, subcallback) {
+				return (func(input, subcallback));
+			});
+	});
 
-		mod_assert.equal(entry['status'], 'pending');
+	return (pipeline({'funcs': funcs}, callback));
+}
 
-		entry['status'] = err ? 'fail' : 'ok';
-		entry['err'] = err;
-		entry['result'] = result;
+/*
+ * async.js compatible filter, filterLimit, and filterSeries.  Takes an input
+ * array, optionally a limit, and a single function to filter an array and will
+ * callback with a new filtered array. This is effectively an asynchronous
+ * version of Array.prototype.filter.
+ */
+function filter(inputs, filterFunc, callback) {
+	return (filterLimit(inputs, Infinity, filterFunc, callback));
+}
 
-		if (err)
-			rv['nerrors']++;
-		else
-			rv['successes'].push(result);
+function filterSeries(inputs, filterFunc, callback) {
+	return (filterLimit(inputs, 1, filterFunc, callback));
+}
 
-		if (err || rv['ndone'] == funcs.length) {
-			callback(err, rv);
-		} else {
-			var nextent = rv['operations'][rv['ndone']];
-			nextent['status'] = 'pending';
+function filterLimit(inputs, limit, filterFunc, callback) {
+	mod_assert.ok(Array.isArray(inputs),
+	    '"inputs" must be specified and must be an array');
+	mod_assert.equal(typeof (limit), 'number',
+	    '"limit" must be a number');
+	mod_assert.equal(isNaN(limit), false,
+	    '"limit" must be a number');
+	mod_assert.equal(typeof (filterFunc), 'function',
+	    '"filterFunc" must be specified and must be a function');
+	mod_assert.equal(typeof (callback), 'function',
+	    '"callback" argument must be specified as a function');
 
+	var errors = [];
+	var q = queue(processInput, limit);
+	var results = [];
+
+	function processInput(input, cb) {
+		/*
+		 * If the errors array has any members, an error was
+		 * encountered in a previous invocation of filterFunc, so all
+		 * future filtering will be skipped.
+		 */
+		if (errors.length > 0) {
+			cb();
+			return;
+		}
+
+		filterFunc(input.elem, function inputFiltered(err, ans) {
 			/*
-			 * We invoke the next function on the next tick so that
-			 * the caller (stage N) need not worry about the case
-			 * that the next stage (stage N + 1) runs in its own
-			 * context.
+			 * We ensure here that a filterFunc callback is only
+			 * ever invoked once.
 			 */
-			setImmediate(function () {
-				nextent['func'](uarg, next);
-			});
+			if (results.hasOwnProperty(input.idx)) {
+				throw (new mod_verror.VError(
+				    'vasync.filter*: filterFunc idx %d ' +
+				    'invoked its callback twice', input.idx));
+			}
+
+			/*
+			 * The original element, as well as the answer "ans"
+			 * (truth value) is stored to later be filtered when
+			 * all outstanding jobs are finished.
+			 */
+			results[input.idx] = {
+				elem: input.elem,
+				ans: !!ans
+			};
+
+			/*
+			 * Any error encountered while filtering will result in
+			 * all future operations being skipped, and the error
+			 * object being returned in the users callback.
+			 */
+			if (err) {
+				errors.push(err);
+				cb();
+				return;
+			}
+
+			cb();
+		});
+	}
+
+	q.once('end', function queueDrained() {
+		if (errors.length > 0) {
+			callback(mod_verror.errorFromList(errors));
+			return;
 		}
-	};
 
-	rv['operations'][0]['status'] = 'pending';
-	funcs[0](uarg, next);
+		/*
+		 * results is now an array of objects in the same order of the
+		 * inputs array, where each object looks like:
+		 *
+		 * {
+		 *     "ans": <true|false>,
+		 *     "elem": <original input element>
+		 * }
+		 *
+		 * we filter out elements that have a false "ans" value, and
+		 * then map the array to contain only the input elements.
+		 */
+		results = results.filter(function filterFalseInputs(input) {
+			return (input.ans);
+		}).map(function mapInputElements(input) {
+			return (input.elem);
+		});
+		callback(null, results);
+	});
 
-	return (rv);
+	inputs.forEach(function iterateInput(elem, idx) {
+		/*
+		 * We retain the array index to ensure that order is
+		 * maintained.
+		 */
+		q.push({
+			elem: elem,
+			idx: idx
+		});
+	});
+
+	q.close();
+
+	return (q);
 }
 
 /*
- * Exactly like pipeline, except that the input is specified as a single
- * function to invoke on N different inputs (rather than N functions).  "args"
- * must have the following fields:
+ * async-compatible "whilst" function, with a few notable exceptions/addons.
  *
- *	func		asynchronous function to invoke on each input value
- *
- *	inputs		array of input values
+ * 1. More strict typing of arguments (functions *must* be supplied).
+ * 2. A callback function is required, not optional.
+ * 3. An object is returned, not undefined.
  */
-function forEachPipeline(args, callback) {
-    mod_assert.equal(typeof (args), 'object', '"args" must be an object');
-    mod_assert.equal(typeof (args['func']), 'function',
-		'"args.func" must be specified and must be a function');
-    mod_assert.ok(Array.isArray(args['inputs']),
-		'"args.inputs" must be specified and must be an array');
-    mod_assert.equal(typeof (callback), 'function',
-		'callback argument must be specified and must be a function');
+function whilst(testFunc, iterateFunc, callback) {
+	mod_assert.equal(typeof (testFunc), 'function',
+	    '"testFunc" must be specified and must be a function');
+	mod_assert.equal(typeof (iterateFunc), 'function',
+	    '"iterateFunc" must be specified and must be a function');
+	mod_assert.equal(typeof (callback), 'function',
+	    '"callback" argument must be specified as a function');
 
-    var func = args['func'];
+	/*
+	 * The object returned to the caller that provides a read-only
+	 * interface to introspect this specific invocation of "whilst".
+	 */
+	var o = {
+	    'finished': false,
+	    'iterations': 0
+	};
 
-    var funcs = args['inputs'].map(function (input) {
-		return (function (_, subcallback) {
-			return (func(input, subcallback));
+	/*
+	 * Store the last set of arguments from the final call to "iterateFunc".
+	 * The arguments will be passed to the final callback when an error is
+	 * encountered or when the testFunc returns false.
+	 */
+	var args = [];
+
+	function iterate() {
+		var shouldContinue = testFunc();
+
+		if (!shouldContinue) {
+			/*
+			 * The test condition is false - break out of the loop.
+			 */
+			done();
+			return;
+		}
+
+		/* Bump iterations after testFunc but before iterateFunc. */
+		o.iterations++;
+
+		iterateFunc(function whilstIteration(err) {
+			/* Store the latest set of arguments seen. */
+			args = Array.prototype.slice.call(arguments);
+
+			/* Any error with iterateFunc will break the loop. */
+			if (err) {
+				done();
+				return;
+			}
+
+			/* Try again. */
+			setImmediate(iterate);
 		});
-    });
+	}
 
-    return (pipeline({'funcs': funcs}, callback));
-}
+	function done() {
+		mod_assert.ok(!o.finished, 'whilst already finished');
+		o.finished = true;
+		callback.apply(this, args);
+	}
 
+	setImmediate(iterate);
+
+	return (o);
+}
 
 /*
  * async-compatible "queue" function.
@@ -535,11 +687,78 @@ Barrier.prototype.done = function (name)
  */
 function waterfall(funcs, callback)
 {
-	var rv, current, next;
+	mod_assert.ok(Array.isArray(funcs),
+	    '"funcs" must be specified and must be an array');
+	mod_assert.ok(arguments.length == 1 || typeof (callback) == 'function',
+	    '"callback" must be a function');
+	var opts = {
+	    'funcs': funcs.slice(0),
+	    'callback': callback,
+	    'args': { impl: 'waterfall' },
+	    'stop_when': 'error',
+	    'res_type': 'values'
+	};
+	return (waterfall_impl(opts));
+}
 
-	mod_assert.ok(Array.isArray(funcs));
-	mod_assert.ok(arguments.length == 1 || callback instanceof Function);
-	funcs = funcs.slice(0);
+/*
+ * This function is used to implement vasync-functions that need to execute a
+ * list of functions in a sequence, but differ in how they make use of the
+ * intermediate callbacks and finall callback, as well as under what conditions
+ * they stop executing the functions in the list. Examples of such functions
+ * are `pipeline`, `waterfall`, and `tryEach`. See the documentation for those
+ * functions to see how they operate.
+ *
+ * This function's behavior is influenced via the `opts` object that we pass
+ * in. This object has the following layout:
+ *
+ * 	{
+ * 		'funcs': array of functions
+ * 		'callback': the final callback
+ * 		'args': {
+ * 			'impl': 'pipeline' or 'tryEach' or 'waterfall'
+ * 			'uarg': the arg passed to each func for 'pipeline'
+ * 			}
+ * 		'stop_when': 'error' or 'success'
+ * 		'res_type': 'values' or 'arrays' or 'rv'
+ * 	}
+ *
+ * In the object, 'res_type' is used to indicate what the type of the result
+ * values(s) is that we pass to the final callback. We secondarily use
+ * 'args.impl' to adjust this behavior in an implementation-specific way. For
+ * example, 'tryEach' only returns an array if it has more than 1 result passed
+ * to the final callback. Otherwise, it passes a solitary value to the final
+ * callback.
+ *
+ * In case it's not clear, 'rv' in the `res_type` member, is just the
+ * result-value that we also return. This is the convention in functions that
+ * originated in `vasync` (pipeline), but not in functions that originated in
+ * `async` (waterfall, tryEach).
+ */
+function waterfall_impl(opts)
+{
+	mod_assert.ok(typeof (opts) === 'object');
+	var rv, current, next;
+	var funcs = opts.funcs;
+	var callback = opts.callback;
+
+	mod_assert.ok(Array.isArray(funcs),
+	    '"opts.funcs" must be specified and must be an array');
+	mod_assert.ok(arguments.length == 1,
+	    'Function "waterfall_impl" must take only 1 arg');
+	mod_assert.ok(opts.res_type === 'values' ||
+	    opts.res_type === 'array' || opts.res_type == 'rv',
+	    '"opts.res_type" must either be "values", "array", or "rv"');
+	mod_assert.ok(opts.stop_when === 'error' ||
+	    opts.stop_when === 'success',
+	    '"opts.stop_when" must either be "error" or "success"');
+	mod_assert.ok(opts.args.impl === 'pipeline' ||
+	    opts.args.impl === 'waterfall' || opts.args.impl === 'tryEach',
+	    '"opts.args.impl" must be "pipeline", "waterfall", or "tryEach"');
+	if (opts.args.impl === 'pipeline') {
+		mod_assert.ok(typeof (opts.args.uarg) !== undefined,
+		    '"opts.args.uarg" should be defined when pipeline is used');
+	}
 
 	rv = {
 	    'operations': funcs.map(function (func) {
@@ -556,12 +775,22 @@ function waterfall(funcs, callback)
 
 	if (funcs.length === 0) {
 		if (callback)
-			setImmediate(function () { callback(null, rv); });
+			setImmediate(function () {
+				var res = (opts.args.impl === 'pipeline') ? rv
+				    : undefined;
+				callback(null, res);
+			});
 		return (rv);
 	}
 
 	next = function (idx, err) {
-		var args, entry, nextentry;
+		/*
+		 * Note that nfunc_args contains the args we will pass to the
+		 * next func in the func-list the user gave us. Except for
+		 * 'tryEach', which passes cb's. However, it will pass
+		 * 'nfunc_args' to its final callback -- see below.
+		 */
+		var res_key, nfunc_args, entry, nextentry;
 
 		if (err === undefined)
 			err = null;
@@ -573,38 +802,90 @@ function waterfall(funcs, callback)
 			    rv['operations'][idx].funcname));
 		}
 
-		mod_assert.equal(idx, rv['ndone']);
+		mod_assert.equal(idx, rv['ndone'],
+		    'idx should be equal to ndone');
 		entry = rv['operations'][rv['ndone']++];
-		args = Array.prototype.slice.call(arguments, 2);
+		if (opts.args.impl === 'tryEach' ||
+		    opts.args.impl === 'waterfall') {
+			nfunc_args = Array.prototype.slice.call(arguments, 2);
+			res_key = 'results';
+			entry['results'] = nfunc_args;
+		} else if (opts.args.impl === 'pipeline') {
+			nfunc_args = [ opts.args.uarg ];
+			res_key = 'result';
+			entry['result'] = arguments[2];
+		}
 
-		mod_assert.equal(entry['status'], 'pending');
+		mod_assert.equal(entry['status'], 'pending',
+		    'status should be pending');
 		entry['status'] = err ? 'fail' : 'ok';
 		entry['err'] = err;
-		entry['results'] = args;
 
-		if (err)
+		if (err) {
 			rv['nerrors']++;
-		else
-			rv['successes'].push(args);
+		} else {
+			rv['successes'].push(entry[res_key]);
+		}
 
-		if (err || rv['ndone'] == funcs.length) {
+		if ((opts.stop_when === 'error' && err) ||
+		    (opts.stop_when === 'success' &&
+		    rv['successes'].length > 0) ||
+		    rv['ndone'] == funcs.length) {
 			if (callback) {
-				args.unshift(err);
-				callback.apply(null, args);
+				if (opts.res_type === 'values' ||
+				    (opts.res_type === 'array' &&
+				     nfunc_args.length <= 1)) {
+					nfunc_args.unshift(err);
+					callback.apply(null, nfunc_args);
+				} else if (opts.res_type === 'array') {
+					callback(err, nfunc_args);
+				} else if (opts.res_type === 'rv') {
+					callback(err, rv);
+				}
 			}
 		} else {
 			nextentry = rv['operations'][rv['ndone']];
 			nextentry['status'] = 'pending';
 			current++;
-			args.push(next.bind(null, current));
+			nfunc_args.push(next.bind(null, current));
 			setImmediate(function () {
-				nextentry['func'].apply(null, args);
+				var nfunc = nextentry['func'];
+				/*
+				 * At first glance it may seem like this branch
+				 * is superflous with the code above that
+				 * branches on `opts.args.impl`. It may also
+				 * seem like calling `nfunc.apply` is
+				 * sufficient for both cases (after all we
+				 * pushed `next.bind(null, current)` to the
+				 * `nfunc_args` array), before we call
+				 * `setImmediate()`. However, this is not the
+				 * case, because the interface exposed by
+				 * tryEach is different from the others. The
+				 * others pass argument(s) from task to task.
+				 * tryEach passes nothing but a callback
+				 * (`next.bind` below). However, the callback
+				 * itself _can_ be called with one or more
+				 * results, which we collect into `nfunc_args`
+				 * using the aformentioned `opts.args.impl`
+				 * branch above, and which we pass to the
+				 * callback via the `opts.res_type` branch
+				 * above (where res_type is set to 'array').
+				 */
+				if (opts.args.impl !== 'tryEach') {
+					nfunc.apply(null, nfunc_args);
+				} else {
+					nfunc(next.bind(null, current));
+				}
 			});
 		}
 	};
 
 	rv['operations'][0]['status'] = 'pending';
 	current = 0;
-	funcs[0](next.bind(null, current));
+	if (opts.args.impl !== 'pipeline') {
+		funcs[0](next.bind(null, current));
+	} else {
+		funcs[0](opts.args.uarg, next.bind(null, current));
+	}
 	return (rv);
 }
diff --git a/src/vm/node_modules/vasync/node_modules/verror/LICENSE b/src/vm/node_modules/vasync/node_modules/verror/LICENSE
index cbc0bb3b..82a5cb86 100644
--- a/src/vm/node_modules/vasync/node_modules/verror/LICENSE
+++ b/src/vm/node_modules/vasync/node_modules/verror/LICENSE
@@ -1,4 +1,4 @@
-Copyright (c) 2012, Joyent, Inc. All rights reserved.
+Copyright (c) 2016, Joyent, Inc. All rights reserved.
 
 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
diff --git a/src/vm/node_modules/vasync/node_modules/verror/lib/verror.js b/src/vm/node_modules/vasync/node_modules/verror/lib/verror.js
index 26e84b9b..8663ddea 100644
--- a/src/vm/node_modules/vasync/node_modules/verror/lib/verror.js
+++ b/src/vm/node_modules/vasync/node_modules/verror/lib/verror.js
@@ -2,10 +2,12 @@
  * verror.js: richer JavaScript errors
  */
 
-var mod_assert = require('assert');
+var mod_assertplus = require('assert-plus');
 var mod_util = require('util');
 
 var mod_extsprintf = require('extsprintf');
+var mod_isError = require('core-util-is').isError;
+var sprintf = mod_extsprintf.sprintf;
 
 /*
  * Public interface
@@ -21,43 +23,66 @@ VError.WError = WError;
 VError.MultiError = MultiError;
 
 /*
- * VError([cause], fmt[, arg...]): Like JavaScript's built-in Error class, but
- * supports a "cause" argument (another error) and a printf-style message.  The
- * cause argument can be null or omitted entirely.
+ * Common function used to parse constructor arguments for VError, WError, and
+ * SError.  Named arguments to this function:
  *
- * Examples:
+ *     strict		force strict interpretation of sprintf arguments, even
+ *     			if the options in "argv" don't say so
  *
- * CODE                                    MESSAGE
- * new VError('something bad happened')    "something bad happened"
- * new VError('missing file: "%s"', file)  "missing file: "/etc/passwd"
- *   with file = '/etc/passwd'
- * new VError(err, 'open failed')          "open failed: file not found"
- *   with err.message = 'file not found'
+ *     argv		error's constructor arguments, which are to be
+ *     			interpreted as described in README.md.  For quick
+ *     			reference, "argv" has one of the following forms:
+ *
+ *          [ sprintf_args... ]           (argv[0] is a string)
+ *          [ cause, sprintf_args... ]    (argv[0] is an Error)
+ *          [ options, sprintf_args... ]  (argv[0] is an object)
+ *
+ * This function normalizes these forms, producing an object with the following
+ * properties:
+ *
+ *    options           equivalent to "options" in third form.  This will never
+ *    			be a direct reference to what the caller passed in
+ *    			(i.e., it may be a shallow copy), so it can be freely
+ *    			modified.
+ *
+ *    shortmessage      result of sprintf(sprintf_args), taking options.strict
+ *    			into account as described in README.md.
  */
-function VError(options)
+function parseConstructorArguments(args)
 {
-	var args, obj, causedBy, ctor, tailmsg;
+	var argv, options, sprintf_args, shortmessage, k;
+
+	mod_assertplus.object(args, 'args');
+	mod_assertplus.bool(args.strict, 'args.strict');
+	mod_assertplus.array(args.argv, 'args.argv');
+	argv = args.argv;
 
 	/*
-	 * This is a regrettable pattern, but JavaScript's built-in Error class
-	 * is defined to work this way, so we allow the constructor to be called
-	 * without "new".
+	 * First, figure out which form of invocation we've been given.
 	 */
-	if (!(this instanceof VError)) {
-		args = Array.prototype.slice.call(arguments, 0);
-		obj = Object.create(VError.prototype);
-		VError.apply(obj, arguments);
-		return (obj);
-	}
-
-	if (options instanceof Error || typeof (options) === 'object') {
-		args = Array.prototype.slice.call(arguments, 1);
+	if (argv.length === 0) {
+		options = {};
+		sprintf_args = [];
+	} else if (mod_isError(argv[0])) {
+		options = { 'cause': argv[0] };
+		sprintf_args = argv.slice(1);
+	} else if (typeof (argv[0]) === 'object') {
+		options = {};
+		for (k in argv[0]) {
+			options[k] = argv[0][k];
+		}
+		sprintf_args = argv.slice(1);
 	} else {
-		args = Array.prototype.slice.call(arguments, 0);
-		options = undefined;
+		mod_assertplus.string(argv[0],
+		    'first argument to VError, SError, or WError ' +
+		    'constructor must be a string, object, or Error');
+		options = {};
+		sprintf_args = argv;
 	}
 
 	/*
+	 * Now construct the error's message.
+	 *
 	 * extsprintf (which we invoke here with our caller's arguments in order
 	 * to construct this Error's message) is strict in its interpretation of
 	 * values to be processed by the "%s" specifier.  The value passed to
@@ -81,36 +106,104 @@ function VError(options)
 	 * desiring the strict behavior can use the SError class or pass the
 	 * "strict" option to the VError constructor.
 	 */
-	if (!options || !options.strict) {
-		args = args.map(function (a) {
+	mod_assertplus.object(options);
+	if (!options.strict && !args.strict) {
+		sprintf_args = sprintf_args.map(function (a) {
 			return (a === null ? 'null' :
 			    a === undefined ? 'undefined' : a);
 		});
 	}
 
-	tailmsg = args.length > 0 ?
-	    mod_extsprintf.sprintf.apply(null, args) : '';
-	this.jse_shortmsg = tailmsg;
-	this.jse_summary = tailmsg;
+	if (sprintf_args.length === 0) {
+		shortmessage = '';
+	} else {
+		shortmessage = sprintf.apply(null, sprintf_args);
+	}
+
+	return ({
+	    'options': options,
+	    'shortmessage': shortmessage
+	});
+}
+
+/*
+ * See README.md for reference documentation.
+ */
+function VError()
+{
+	var args, obj, parsed, cause, ctor, message, k;
+
+	args = Array.prototype.slice.call(arguments, 0);
+
+	/*
+	 * This is a regrettable pattern, but JavaScript's built-in Error class
+	 * is defined to work this way, so we allow the constructor to be called
+	 * without "new".
+	 */
+	if (!(this instanceof VError)) {
+		obj = Object.create(VError.prototype);
+		VError.apply(obj, arguments);
+		return (obj);
+	}
+
+	/*
+	 * For convenience and backwards compatibility, we support several
+	 * different calling forms.  Normalize them here.
+	 */
+	parsed = parseConstructorArguments({
+	    'argv': args,
+	    'strict': false
+	});
+
+	/*
+	 * If we've been given a name, apply it now.
+	 */
+	if (parsed.options.name) {
+		mod_assertplus.string(parsed.options.name,
+		    'error\'s "name" must be a string');
+		this.name = parsed.options.name;
+	}
+
+	/*
+	 * For debugging, we keep track of the original short message (attached
+	 * this Error particularly) separately from the complete message (which
+	 * includes the messages of our cause chain).
+	 */
+	this.jse_shortmsg = parsed.shortmessage;
+	message = parsed.shortmessage;
 
-	if (options) {
-		causedBy = options.cause;
+	/*
+	 * If we've been given a cause, record a reference to it and update our
+	 * message appropriately.
+	 */
+	cause = parsed.options.cause;
+	if (cause) {
+		mod_assertplus.ok(mod_isError(cause), 'cause is not an Error');
+		this.jse_cause = cause;
 
-		if (!causedBy || !(options.cause instanceof Error))
-			causedBy = options;
+		if (!parsed.options.skipCauseMessage) {
+			message += ': ' + cause.message;
+		}
+	}
 
-		if (causedBy && (causedBy instanceof Error)) {
-			this.jse_cause = causedBy;
-			this.jse_summary += ': ' + causedBy.message;
+	/*
+	 * If we've been given an object with properties, shallow-copy that
+	 * here.  We don't want to use a deep copy in case there are non-plain
+	 * objects here, but we don't want to use the original object in case
+	 * the caller modifies it later.
+	 */
+	this.jse_info = {};
+	if (parsed.options.info) {
+		for (k in parsed.options.info) {
+			this.jse_info[k] = parsed.options.info[k];
 		}
 	}
 
-	this.message = this.jse_summary;
-	Error.call(this, this.jse_summary);
+	this.message = message;
+	Error.call(this, message);
 
 	if (Error.captureStackTrace) {
-		ctor = options ? options.constructorOpt : undefined;
-		ctor = ctor || arguments.callee;
+		ctor = parsed.options.constructorOpt || this.constructor;
 		Error.captureStackTrace(this, ctor);
 	}
 
@@ -130,41 +223,151 @@ VError.prototype.toString = function ve_toString()
 	return (str);
 };
 
+/*
+ * This method is provided for compatibility.  New callers should use
+ * VError.cause() instead.  That method also uses the saner `null` return value
+ * when there is no cause.
+ */
 VError.prototype.cause = function ve_cause()
 {
-	return (this.jse_cause);
+	var cause = VError.cause(this);
+	return (cause === null ? undefined : cause);
+};
+
+/*
+ * Static methods
+ *
+ * These class-level methods are provided so that callers can use them on
+ * instances of Errors that are not VErrors.  New interfaces should be provided
+ * only using static methods to eliminate the class of programming mistake where
+ * people fail to check whether the Error object has the corresponding methods.
+ */
+
+VError.cause = function (err)
+{
+	mod_assertplus.ok(mod_isError(err), 'err must be an Error');
+	return (mod_isError(err.jse_cause) ? err.jse_cause : null);
+};
+
+VError.info = function (err)
+{
+	var rv, cause, k;
+
+	mod_assertplus.ok(mod_isError(err), 'err must be an Error');
+	cause = VError.cause(err);
+	if (cause !== null) {
+		rv = VError.info(cause);
+	} else {
+		rv = {};
+	}
+
+	if (typeof (err.jse_info) == 'object' && err.jse_info !== null) {
+		for (k in err.jse_info) {
+			rv[k] = err.jse_info[k];
+		}
+	}
+
+	return (rv);
+};
+
+VError.findCauseByName = function (err, name)
+{
+	var cause;
+
+	mod_assertplus.ok(mod_isError(err), 'err must be an Error');
+	mod_assertplus.string(name, 'name');
+	mod_assertplus.ok(name.length > 0, 'name cannot be empty');
+
+	for (cause = err; cause !== null; cause = VError.cause(cause)) {
+		mod_assertplus.ok(mod_isError(cause));
+		if (cause.name == name) {
+			return (cause);
+		}
+	}
+
+	return (null);
+};
+
+VError.hasCauseWithName = function (err, name)
+{
+	return (VError.findCauseByName(err, name) !== null);
+};
+
+VError.fullStack = function (err)
+{
+	mod_assertplus.ok(mod_isError(err), 'err must be an Error');
+
+	var cause = VError.cause(err);
+
+	if (cause) {
+		return (err.stack + '\ncaused by: ' + VError.fullStack(cause));
+	}
+
+	return (err.stack);
+};
+
+VError.errorFromList = function (errors)
+{
+	mod_assertplus.arrayOfObject(errors, 'errors');
+
+	if (errors.length === 0) {
+		return (null);
+	}
+
+	errors.forEach(function (e) {
+		mod_assertplus.ok(mod_isError(e));
+	});
+
+	if (errors.length == 1) {
+		return (errors[0]);
+	}
+
+	return (new MultiError(errors));
+};
+
+VError.errorForEach = function (err, func)
+{
+	mod_assertplus.ok(mod_isError(err), 'err must be an Error');
+	mod_assertplus.func(func, 'func');
+
+	if (err instanceof MultiError) {
+		err.errors().forEach(function iterError(e) { func(e); });
+	} else {
+		func(err);
+	}
 };
 
 
 /*
  * SError is like VError, but stricter about types.  You cannot pass "null" or
- * "undefined" as string arguments to the formatter.  Since SError is only a
- * different function, not really a different class, we don't set
- * SError.prototype.name.
+ * "undefined" as string arguments to the formatter.
  */
 function SError()
 {
-	var fmtargs, opts, key, args;
-
-	opts = {};
-	opts.constructorOpt = SError;
+	var args, obj, parsed, options;
 
-	if (arguments[0] instanceof Error) {
-		opts.cause = arguments[0];
-		fmtargs = Array.prototype.slice.call(arguments, 1);
-	} else if (typeof (arguments[0]) == 'object') {
-		for (key in arguments[0])
-			opts[key] = arguments[0][key];
-		fmtargs = Array.prototype.slice.call(arguments, 1);
-	} else {
-		fmtargs = Array.prototype.slice.call(arguments, 0);
+	args = Array.prototype.slice.call(arguments, 0);
+	if (!(this instanceof SError)) {
+		obj = Object.create(SError.prototype);
+		SError.apply(obj, arguments);
+		return (obj);
 	}
 
-	opts.strict = true;
-	args = [ opts ].concat(fmtargs);
-	VError.apply(this, args);
+	parsed = parseConstructorArguments({
+	    'argv': args,
+	    'strict': true
+	});
+
+	options = parsed.options;
+	VError.call(this, options, '%s', parsed.shortmessage);
+
+	return (this);
 }
 
+/*
+ * We don't bother setting SError.prototype.name because once constructed,
+ * SErrors are just like VErrors.
+ */
 mod_util.inherits(SError, VError);
 
 
@@ -176,74 +379,73 @@ mod_util.inherits(SError, VError);
  */
 function MultiError(errors)
 {
-	mod_assert.ok(errors.length > 0);
+	mod_assertplus.array(errors, 'list of errors');
+	mod_assertplus.ok(errors.length > 0, 'must be at least one error');
 	this.ase_errors = errors;
 
-	VError.call(this, errors[0], 'first of %d error%s',
-	    errors.length, errors.length == 1 ? '' : 's');
+	VError.call(this, {
+	    'cause': errors[0]
+	}, 'first of %d error%s', errors.length, errors.length == 1 ? '' : 's');
 }
 
 mod_util.inherits(MultiError, VError);
+MultiError.prototype.name = 'MultiError';
+
+MultiError.prototype.errors = function me_errors()
+{
+	return (this.ase_errors.slice(0));
+};
 
 
 /*
- * Like JavaScript's built-in Error class, but supports a "cause" argument which
- * is wrapped, not "folded in" as with VError.	Accepts a printf-style message.
- * The cause argument can be null.
+ * See README.md for reference details.
  */
-function WError(options)
+function WError()
 {
-	Error.call(this);
+	var args, obj, parsed, options;
 
-	var args, cause, ctor;
-	if (typeof (options) === 'object') {
-		args = Array.prototype.slice.call(arguments, 1);
-	} else {
-		args = Array.prototype.slice.call(arguments, 0);
-		options = undefined;
-	}
-
-	if (args.length > 0) {
-		this.message = mod_extsprintf.sprintf.apply(null, args);
-	} else {
-		this.message = '';
+	args = Array.prototype.slice.call(arguments, 0);
+	if (!(this instanceof WError)) {
+		obj = Object.create(WError.prototype);
+		WError.apply(obj, args);
+		return (obj);
 	}
 
-	if (options) {
-		if (options instanceof Error) {
-			cause = options;
-		} else {
-			cause = options.cause;
-			ctor = options.constructorOpt;
-		}
-	}
+	parsed = parseConstructorArguments({
+	    'argv': args,
+	    'strict': false
+	});
 
-	Error.captureStackTrace(this, ctor || this.constructor);
-	if (cause)
-		this.cause(cause);
+	options = parsed.options;
+	options['skipCauseMessage'] = true;
+	VError.call(this, options, '%s', parsed.shortmessage);
 
+	return (this);
 }
 
-mod_util.inherits(WError, Error);
+mod_util.inherits(WError, VError);
 WError.prototype.name = 'WError';
 
-
 WError.prototype.toString = function we_toString()
 {
 	var str = (this.hasOwnProperty('name') && this.name ||
 		this.constructor.name || this.constructor.prototype.name);
 	if (this.message)
 		str += ': ' + this.message;
-	if (this.we_cause && this.we_cause.message)
-		str += '; caused by ' + this.we_cause.toString();
+	if (this.jse_cause && this.jse_cause.message)
+		str += '; caused by ' + this.jse_cause.toString();
 
 	return (str);
 };
 
+/*
+ * For purely historical reasons, WError's cause() function allows you to set
+ * the cause.
+ */
 WError.prototype.cause = function we_cause(c)
 {
-	if (c instanceof Error)
-		this.we_cause = c;
+	if (mod_isError(c))
+		this.jse_cause = c;
 
-	return (this.we_cause);
+	return (this.jse_cause);
 };
diff --git a/src/vm/node_modules/vasync/node_modules/verror/node_modules/assert-plus/assert.js b/src/vm/node_modules/vasync/node_modules/verror/node_modules/assert-plus/assert.js
new file mode 100644
index 00000000..26f944ee
--- /dev/null
+++ b/src/vm/node_modules/vasync/node_modules/verror/node_modules/assert-plus/assert.js
@@ -0,0 +1,211 @@
+// Copyright (c) 2012, Mark Cavage. All rights reserved.
+// Copyright 2015 Joyent, Inc.
+
+var assert = require('assert');
+var Stream = require('stream').Stream;
+var util = require('util');
+
+
+///--- Globals
+
+/* JSSTYLED */
+var UUID_REGEXP = /^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/;
+
+
+///--- Internal
+
+function _capitalize(str) {
+    return (str.charAt(0).toUpperCase() + str.slice(1));
+}
+
+function _toss(name, expected, oper, arg, actual) {
+    throw new assert.AssertionError({
+        message: util.format('%s (%s) is required', name, expected),
+        actual: (actual === undefined) ? typeof (arg) : actual(arg),
+        expected: expected,
+        operator: oper || '===',
+        stackStartFunction: _toss.caller
+    });
+}
+
+function _getClass(arg) {
+    return (Object.prototype.toString.call(arg).slice(8, -1));
+}
+
+function noop() {
+    // Why even bother with asserts?
+}
+
+
+///--- Exports
+
+var types = {
+    bool: {
+        check: function (arg) { return typeof (arg) === 'boolean'; }
+    },
+    func: {
+        check: function (arg) { return typeof (arg) === 'function'; }
+    },
+    string: {
+        check: function (arg) { return typeof (arg) === 'string'; }
+    },
+    object: {
+        check: function (arg) {
+            return typeof (arg) === 'object' && arg !== null;
+        }
+    },
+    number: {
+        check: function (arg) {
+            return typeof (arg) === 'number' && !isNaN(arg);
+        }
+    },
+    finite: {
+        check: function (arg) {
+            return typeof (arg) === 'number' && !isNaN(arg) && isFinite(arg);
+        }
+    },
+    buffer: {
+        check: function (arg) { return Buffer.isBuffer(arg); },
+        operator: 'Buffer.isBuffer'
+    },
+    array: {
+        check: function (arg) { return Array.isArray(arg); },
+        operator: 'Array.isArray'
+    },
+    stream: {
+        check: function (arg) { return arg instanceof Stream; },
+        operator: 'instanceof',
+        actual: _getClass
+    },
+    date: {
+        check: function (arg) { return arg instanceof Date; },
+        operator: 'instanceof',
+        actual: _getClass
+    },
+    regexp: {
+        check: function (arg) { return arg instanceof RegExp; },
+        operator: 'instanceof',
+        actual: _getClass
+    },
+    uuid: {
+        check: function (arg) {
+            return typeof (arg) === 'string' && UUID_REGEXP.test(arg);
+        },
+        operator: 'isUUID'
+    }
+};
+
+function _setExports(ndebug) {
+    var keys = Object.keys(types);
+    var out;
+
+    /* re-export standard assert */
+    if (process.env.NODE_NDEBUG) {
+        out = noop;
+    } else {
+        out = function (arg, msg) {
+            if (!arg) {
+                _toss(msg, 'true', arg);
+            }
+        };
+    }
+
+    /* standard checks */
+    keys.forEach(function (k) {
+        if (ndebug) {
+            out[k] = noop;
+            return;
+        }
+        var type = types[k];
+        out[k] = function (arg, msg) {
+            if (!type.check(arg)) {
+                _toss(msg, k, type.operator, arg, type.actual);
+            }
+        };
+    });
+
+    /* optional checks */
+    keys.forEach(function (k) {
+        var name = 'optional' + _capitalize(k);
+        if (ndebug) {
+            out[name] = noop;
+            return;
+        }
+        var type = types[k];
+        out[name] = function (arg, msg) {
+            if (arg === undefined || arg === null) {
+                return;
+            }
+            if (!type.check(arg)) {
+                _toss(msg, k, type.operator, arg, type.actual);
+            }
+        };
+    });
+
+    /* arrayOf checks */
+    keys.forEach(function (k) {
+        var name = 'arrayOf' + _capitalize(k);
+        if (ndebug) {
+            out[name] = noop;
+            return;
+        }
+        var type = types[k];
+        var expected = '[' + k + ']';
+        out[name] = function (arg, msg) {
+            if (!Array.isArray(arg)) {
+                _toss(msg, expected, type.operator, arg, type.actual);
+            }
+            var i;
+            for (i = 0; i < arg.length; i++) {
+                if (!type.check(arg[i])) {
+                    _toss(msg, expected, type.operator, arg, type.actual);
+                }
+            }
+        };
+    });
+
+    /* optionalArrayOf checks */
+    keys.forEach(function (k) {
+        var name = 'optionalArrayOf' + _capitalize(k);
+        if (ndebug) {
+            out[name] = noop;
+            return;
+        }
+        var type = types[k];
+        var expected = '[' + k + ']';
+        out[name] = function (arg, msg) {
+            if (arg === undefined || arg === null) {
+                return;
+            }
+            if (!Array.isArray(arg)) {
+                _toss(msg, expected, type.operator, arg, type.actual);
+            }
+            var i;
+            for (i = 0; i < arg.length; i++) {
+                if (!type.check(arg[i])) {
+                    _toss(msg, expected, type.operator, arg, type.actual);
+                }
+            }
+        };
+    });
+
+    /* re-export built-in assertions */
+    Object.keys(assert).forEach(function (k) {
+        if (k === 'AssertionError') {
+            out[k] = assert[k];
+            return;
+        }
+        if (ndebug) {
+            out[k] = noop;
+            return;
+        }
+        out[k] = assert[k];
+    });
+
+    /* export ourselves (for unit tests _only_) */
+    out._setExports = _setExports;
+
+    return out;
+}
+
+module.exports = _setExports(process.env.NODE_NDEBUG);
diff --git a/src/vm/node_modules/vasync/node_modules/verror/node_modules/assert-plus/package.json b/src/vm/node_modules/vasync/node_modules/verror/node_modules/assert-plus/package.json
new file mode 100644
index 00000000..f199fff6
--- /dev/null
+++ b/src/vm/node_modules/vasync/node_modules/verror/node_modules/assert-plus/package.json
@@ -0,0 +1,83 @@
+{
+  "author": {
+    "name": "Mark Cavage",
+    "email": "mcavage@gmail.com"
+  },
+  "name": "assert-plus",
+  "description": "Extra assertions on top of node's assert module",
+  "version": "1.0.0",
+  "license": "MIT",
+  "main": "./assert.js",
+  "devDependencies": {
+    "tape": "4.2.2",
+    "faucet": "0.0.1"
+  },
+  "optionalDependencies": {},
+  "scripts": {
+    "test": "tape tests/*.js | ./node_modules/.bin/faucet"
+  },
+  "repository": {
+    "type": "git",
+    "url": "git+https://github.com/mcavage/node-assert-plus.git"
+  },
+  "engines": {
+    "node": ">=0.8"
+  },
+  "contributors": [
+    {
+      "name": "Dave Eddy",
+      "email": "dave@daveeddy.com"
+    },
+    {
+      "name": "Fred Kuo",
+      "email": "fred.kuo@joyent.com"
+    },
+    {
+      "name": "Lars-Magnus Skog",
+      "email": "ralphtheninja@riseup.net"
+    },
+    {
+      "name": "Mark Cavage",
+      "email": "mcavage@gmail.com"
+    },
+    {
+      "name": "Patrick Mooney",
+      "email": "pmooney@pfmooney.com"
+    },
+    {
+      "name": "Rob Gulewich",
+      "email": "robert.gulewich@joyent.com"
+    }
+  ],
+  "bugs": {
+    "url": "https://github.com/mcavage/node-assert-plus/issues"
+  },
+  "homepage": "https://github.com/mcavage/node-assert-plus#readme",
+  "dependencies": {},
+  "_id": "assert-plus@1.0.0",
+  "_shasum": "f12e0f3c5d77b0b1cdd9146942e4e96c1e4dd525",
+  "_resolved": "http://10.0.1.33:8354/assert-plus/-/assert-plus-1.0.0.tgz",
+  "_from": "assert-plus@>=1.0.0 <2.0.0",
+  "_npmVersion": "3.3.9",
+  "_nodeVersion": "0.10.40",
+  "_npmUser": {
+    "name": "pfmooney",
+    "email": "patrick.f.mooney@gmail.com"
+  },
+  "maintainers": [
+    {
+      "name": "mcavage",
+      "email": "mcavage@gmail.com"
+    },
+    {
+      "name": "pfmooney",
+      "email": "patrick.f.mooney@gmail.com"
+    }
+  ],
+  "dist": {
+    "shasum": "f12e0f3c5d77b0b1cdd9146942e4e96c1e4dd525",
+    "tarball": "http://10.0.1.33:8354/assert-plus/-/assert-plus-1.0.0.tgz"
+  },
+  "directories": {},
+  "readme": "ERROR: No README data found!"
+}
diff --git a/src/vm/node_modules/vasync/node_modules/verror/node_modules/core-util-is/LICENSE b/src/vm/node_modules/vasync/node_modules/verror/node_modules/core-util-is/LICENSE
new file mode 100644
index 00000000..d8d7f943
--- /dev/null
+++ b/src/vm/node_modules/vasync/node_modules/verror/node_modules/core-util-is/LICENSE
@@ -0,0 +1,19 @@
+Copyright Node.js contributors. All rights reserved.
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to
+deal in the Software without restriction, including without limitation the
+rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+sell copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+IN THE SOFTWARE.
diff --git a/src/vm/node_modules/vasync/node_modules/verror/node_modules/core-util-is/lib/util.js b/src/vm/node_modules/vasync/node_modules/verror/node_modules/core-util-is/lib/util.js
new file mode 100644
index 00000000..ff4c851c
--- /dev/null
+++ b/src/vm/node_modules/vasync/node_modules/verror/node_modules/core-util-is/lib/util.js
@@ -0,0 +1,107 @@
+// Copyright Joyent, Inc. and other Node contributors.
+//
+// Permission is hereby granted, free of charge, to any person obtaining a
+// copy of this software and associated documentation files (the
+// "Software"), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to permit
+// persons to whom the Software is furnished to do so, subject to the
+// following conditions:
+//
+// The above copyright notice and this permission notice shall be included
+// in all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
+// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
+// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
+// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
+// USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+// NOTE: These type checking functions intentionally don't use `instanceof`
+// because it is fragile and can be easily faked with `Object.create()`.
+
+function isArray(arg) {
+  if (Array.isArray) {
+    return Array.isArray(arg);
+  }
+  return objectToString(arg) === '[object Array]';
+}
+exports.isArray = isArray;
+
+function isBoolean(arg) {
+  return typeof arg === 'boolean';
+}
+exports.isBoolean = isBoolean;
+
+function isNull(arg) {
+  return arg === null;
+}
+exports.isNull = isNull;
+
+function isNullOrUndefined(arg) {
+  return arg == null;
+}
+exports.isNullOrUndefined = isNullOrUndefined;
+
+function isNumber(arg) {
+  return typeof arg === 'number';
+}
+exports.isNumber = isNumber;
+
+function isString(arg) {
+  return typeof arg === 'string';
+}
+exports.isString = isString;
+
+function isSymbol(arg) {
+  return typeof arg === 'symbol';
+}
+exports.isSymbol = isSymbol;
+
+function isUndefined(arg) {
+  return arg === void 0;
+}
+exports.isUndefined = isUndefined;
+
+function isRegExp(re) {
+  return objectToString(re) === '[object RegExp]';
+}
+exports.isRegExp = isRegExp;
+
+function isObject(arg) {
+  return typeof arg === 'object' && arg !== null;
+}
+exports.isObject = isObject;
+
+function isDate(d) {
+  return objectToString(d) === '[object Date]';
+}
+exports.isDate = isDate;
+
+function isError(e) {
+  return (objectToString(e) === '[object Error]' || e instanceof Error);
+}
+exports.isError = isError;
+
+function isFunction(arg) {
+  return typeof arg === 'function';
+}
+exports.isFunction = isFunction;
+
+function isPrimitive(arg) {
+  return arg === null ||
+         typeof arg === 'boolean' ||
+         typeof arg === 'number' ||
+         typeof arg === 'string' ||
+         typeof arg === 'symbol' ||  // ES6 symbol
+         typeof arg === 'undefined';
+}
+exports.isPrimitive = isPrimitive;
+
+exports.isBuffer = Buffer.isBuffer;
+
+function objectToString(o) {
+  return Object.prototype.toString.call(o);
+}
diff --git a/src/vm/node_modules/vasync/node_modules/verror/node_modules/core-util-is/package.json b/src/vm/node_modules/vasync/node_modules/verror/node_modules/core-util-is/package.json
new file mode 100644
index 00000000..e0da971f
--- /dev/null
+++ b/src/vm/node_modules/vasync/node_modules/verror/node_modules/core-util-is/package.json
@@ -0,0 +1,59 @@
+{
+  "name": "core-util-is",
+  "version": "1.0.2",
+  "description": "The `util.is*` functions introduced in Node v0.12.",
+  "main": "lib/util.js",
+  "repository": {
+    "type": "git",
+    "url": "git://github.com/isaacs/core-util-is.git"
+  },
+  "keywords": [
+    "util",
+    "isBuffer",
+    "isArray",
+    "isNumber",
+    "isString",
+    "isRegExp",
+    "isThis",
+    "isThat",
+    "polyfill"
+  ],
+  "author": {
+    "name": "Isaac Z. Schlueter",
+    "email": "i@izs.me",
+    "url": "http://blog.izs.me/"
+  },
+  "license": "MIT",
+  "bugs": {
+    "url": "https://github.com/isaacs/core-util-is/issues"
+  },
+  "scripts": {
+    "test": "tap test.js"
+  },
+  "devDependencies": {
+    "tap": "^2.3.0"
+  },
+  "gitHead": "a177da234df5638b363ddc15fa324619a38577c8",
+  "homepage": "https://github.com/isaacs/core-util-is#readme",
+  "_id": "core-util-is@1.0.2",
+  "_shasum": "b5fd54220aa2bc5ab57aab7140c940754503c1a7",
+  "_from": "core-util-is@1.0.2",
+  "_npmVersion": "3.3.2",
+  "_nodeVersion": "4.0.0",
+  "_npmUser": {
+    "name": "isaacs",
+    "email": "i@izs.me"
+  },
+  "dist": {
+    "shasum": "b5fd54220aa2bc5ab57aab7140c940754503c1a7",
+    "tarball": "http://10.0.1.33:8354/core-util-is/-/core-util-is-1.0.2.tgz"
+  },
+  "maintainers": [
+    {
+      "name": "isaacs",
+      "email": "i@izs.me"
+    }
+  ],
+  "directories": {},
+  "_resolved": "http://10.0.1.33:8354/core-util-is/-/core-util-is-1.0.2.tgz"
+}
diff --git a/src/vm/node_modules/vasync/node_modules/verror/node_modules/extsprintf/lib/extsprintf.js b/src/vm/node_modules/vasync/node_modules/verror/node_modules/extsprintf/lib/extsprintf.js
index b9ab2ebe..d5d8ad93 100644
--- a/src/vm/node_modules/vasync/node_modules/verror/node_modules/extsprintf/lib/extsprintf.js
+++ b/src/vm/node_modules/vasync/node_modules/verror/node_modules/extsprintf/lib/extsprintf.js
@@ -10,6 +10,7 @@ var mod_util = require('util');
  */
 exports.sprintf = jsSprintf;
 exports.printf = jsPrintf;
+exports.fprintf = jsFprintf;
 
 /*
  * Stripped down version of s[n]printf(3c).  We make a best effort to throw an
@@ -29,7 +30,7 @@ exports.printf = jsPrintf;
  * Everything else is currently unsupported, most notably precision, unsigned
  * numbers, non-decimal numbers, and characters.
  */
-function jsSprintf(fmt)
+function jsSprintf(ofmt)
 {
 	var regex = [
 	    '([^%]*)',				/* normal text */
@@ -42,18 +43,43 @@ function jsSprintf(fmt)
 	].join('');
 
 	var re = new RegExp(regex);
+
+	/* variadic arguments used to fill in conversion specifiers */
 	var args = Array.prototype.slice.call(arguments, 1);
+	/* remaining format string */
+	var fmt = ofmt;
+
+	/* components of the current conversion specifier */
 	var flags, width, precision, conversion;
 	var left, pad, sign, arg, match;
+
+	/* return value */
 	var ret = '';
+
+	/* current variadic argument (1-based) */
 	var argn = 1;
+	/* 0-based position in the format string that we've read */
+	var posn = 0;
+	/* 1-based position in the format string of the current conversion */
+	var convposn;
+	/* current conversion specifier */
+	var curconv;
 
-	mod_assert.equal('string', typeof (fmt));
+	mod_assert.equal('string', typeof (fmt),
+	    'first argument must be a format string');
 
 	while ((match = re.exec(fmt)) !== null) {
 		ret += match[1];
 		fmt = fmt.substring(match[0].length);
 
+		/*
+		 * Update flags related to the current conversion specifier's
+		 * position so that we can report clear error messages.
+		 */
+		curconv = match[0].substring(match[1].length);
+		convposn = posn + match[1].length + 1;
+		posn += match[0].length;
+
 		flags = match[2] || '';
 		width = match[3] || 0;
 		precision = match[4] || '';
@@ -67,19 +93,24 @@ function jsSprintf(fmt)
 			continue;
 		}
 
-		if (args.length === 0)
-			throw (new Error('too few args to sprintf'));
+		if (args.length === 0) {
+			throw (jsError(ofmt, convposn, curconv,
+			    'has no matching argument ' +
+			    '(too few arguments passed)'));
+		}
 
 		arg = args.shift();
 		argn++;
 
-		if (flags.match(/[\' #]/))
-			throw (new Error(
-			    'unsupported flags: ' + flags));
+		if (flags.match(/[\' #]/)) {
+			throw (jsError(ofmt, convposn, curconv,
+			    'uses unsupported flags'));
+		}
 
-		if (precision.length > 0)
-			throw (new Error(
-			    'non-zero precision not supported'));
+		if (precision.length > 0) {
+			throw (jsError(ofmt, convposn, curconv,
+			    'uses non-zero precision (not supported)'));
+		}
 
 		if (flags.match(/-/))
 			left = true;
@@ -92,10 +123,12 @@ function jsSprintf(fmt)
 
 		switch (conversion) {
 		case 's':
-			if (arg === undefined || arg === null)
-				throw (new Error('argument ' + argn +
-				    ': attempted to print undefined or null ' +
-				    'as a string'));
+			if (arg === undefined || arg === null) {
+				throw (jsError(ofmt, convposn, curconv,
+				    'attempted to print undefined or null ' +
+				    'as a string (argument ' + argn + ' to ' +
+				    'sprintf)'));
+			}
 			ret += doPad(pad, width, left, arg.toString());
 			break;
 
@@ -123,8 +156,8 @@ function jsSprintf(fmt)
 			break;
 
 		default:
-			throw (new Error('unsupported conversion: ' +
-			    conversion));
+			throw (jsError(ofmt, convposn, curconv,
+			    'is not supported'));
 		}
 	}
 
@@ -132,8 +165,25 @@ function jsSprintf(fmt)
 	return (ret);
 }
 
+function jsError(fmtstr, convposn, curconv, reason) {
+	mod_assert.equal(typeof (fmtstr), 'string');
+	mod_assert.equal(typeof (curconv), 'string');
+	mod_assert.equal(typeof (convposn), 'number');
+	mod_assert.equal(typeof (reason), 'string');
+	return (new Error('format string "' + fmtstr +
+	    '": conversion specifier "' + curconv + '" at character ' +
+	    convposn + ' ' + reason));
+}
+
 function jsPrintf() {
-	process.stdout.write(jsSprintf.apply(this, arguments));
+	var args = Array.prototype.slice.call(arguments);
+	args.unshift(process.stdout);
+	jsFprintf.apply(null, args);
+}
+
+function jsFprintf(stream) {
+	var args = Array.prototype.slice.call(arguments, 1);
+	return (stream.write(jsSprintf.apply(this, args)));
 }
 
 function doPad(chr, width, left, str)
diff --git a/src/vm/node_modules/vasync/node_modules/verror/node_modules/extsprintf/package.json b/src/vm/node_modules/vasync/node_modules/verror/node_modules/extsprintf/package.json
index 0313b914..b21de724 100644
--- a/src/vm/node_modules/vasync/node_modules/verror/node_modules/extsprintf/package.json
+++ b/src/vm/node_modules/vasync/node_modules/verror/node_modules/extsprintf/package.json
@@ -1,6 +1,6 @@
 {
   "name": "extsprintf",
-  "version": "1.2.0",
+  "version": "1.4.0",
   "description": "extended POSIX-style sprintf",
   "main": "./lib/extsprintf.js",
   "repository": {
@@ -11,12 +11,36 @@
     "node >=0.6.0"
   ],
   "license": "MIT",
-  "readme": "# extsprintf: extended POSIX-style sprintf\n\nStripped down version of s[n]printf(3c).  We make a best effort to throw an\nexception when given a format string we don't understand, rather than ignoring\nit, so that we won't break existing programs if/when we go implement the rest\nof this.\n\nThis implementation currently supports specifying\n\n* field alignment ('-' flag),\n* zero-pad ('0' flag)\n* always show numeric sign ('+' flag),\n* field width\n* conversions for strings, decimal integers, and floats (numbers).\n* argument size specifiers.  These are all accepted but ignored, since\n  Javascript has no notion of the physical size of an argument.\n\nEverything else is currently unsupported, most notably: precision, unsigned\nnumbers, non-decimal numbers, and characters.\n\nBesides the usual POSIX conversions, this implementation supports:\n\n* `%j`: pretty-print a JSON object (using node's \"inspect\")\n* `%r`: pretty-print an Error object\n\n# Example\n\nFirst, install it:\n\n    # npm install extsprintf\n\nNow, use it:\n\n    var mod_extsprintf = require('extsprintf');\n    console.log(mod_extsprintf.sprintf('hello %25s', 'world'));\n\noutputs:\n\n    hello                     world\n",
-  "readmeFilename": "README.md",
+  "gitHead": "26f360d1588a2d4106f3061bfd757f6ecdee37dc",
   "bugs": {
     "url": "https://github.com/davepacheco/node-extsprintf/issues"
   },
-  "homepage": "https://github.com/davepacheco/node-extsprintf",
-  "_id": "extsprintf@1.2.0",
-  "_from": "extsprintf@1.2.0"
+  "homepage": "https://github.com/davepacheco/node-extsprintf#readme",
+  "_id": "extsprintf@1.4.0",
+  "scripts": {},
+  "_shasum": "e2689f8f356fad62cca65a3a91c5df5f9551692f",
+  "_from": "extsprintf@>=1.2.0 <2.0.0",
+  "_npmVersion": "2.15.1",
+  "_nodeVersion": "0.10.45",
+  "_npmUser": {
+    "name": "dap",
+    "email": "dap@cs.brown.edu"
+  },
+  "maintainers": [
+    {
+      "name": "dap",
+      "email": "dap@cs.brown.edu"
+    }
+  ],
+  "dist": {
+    "shasum": "e2689f8f356fad62cca65a3a91c5df5f9551692f",
+    "tarball": "http://10.0.1.33:8354/extsprintf/-/extsprintf-1.4.0.tgz"
+  },
+  "_npmOperationalInternal": {
+    "host": "s3://npm-registry-packages",
+    "tmp": "tmp/extsprintf-1.4.0.tgz_1512077204279_0.1054401712026447"
+  },
+  "directories": {},
+  "_resolved": "http://10.0.1.33:8354/extsprintf/-/extsprintf-1.4.0.tgz",
+  "readme": "ERROR: No README data found!"
 }
diff --git a/src/vm/node_modules/vasync/node_modules/verror/package.json b/src/vm/node_modules/vasync/node_modules/verror/package.json
index b0b3243d..1bb51aa9 100644
--- a/src/vm/node_modules/vasync/node_modules/verror/package.json
+++ b/src/vm/node_modules/vasync/node_modules/verror/package.json
@@ -1,6 +1,6 @@
 {
   "name": "verror",
-  "version": "1.6.0",
+  "version": "1.10.0",
   "description": "richer JavaScript errors",
   "main": "./lib/verror.js",
   "repository": {
@@ -8,7 +8,9 @@
     "url": "git://github.com/davepacheco/node-verror.git"
   },
   "dependencies": {
-    "extsprintf": "1.2.0"
+    "assert-plus": "^1.0.0",
+    "core-util-is": "1.0.2",
+    "extsprintf": "^1.2.0"
   },
   "engines": [
     "node >=0.6.0"
@@ -17,16 +19,32 @@
     "test": "make test"
   },
   "license": "MIT",
-  "readme": "# verror: richer JavaScript errors\n\nThis module provides two classes:\n\n* VError, for combining errors while preserving each one's error message, and\n* WError, for wrapping errors.\n\nBoth support printf-style error messages using\n[extsprintf](https://github.com/davepacheco/node-extsprintf).\n\n## printf-style Error constructor\n\nAt the most basic level, VError is just like JavaScript's Error class, but with\nprintf-style arguments:\n\n```javascript\nvar VError = require('verror');\n\nvar filename = '/etc/passwd';\nvar err = new VError('missing file: \"%s\"', filename);\nconsole.log(err.message);\n```\n\nThis prints:\n\n    missing file: \"/etc/passwd\"\n\n`err.stack` works the same as for built-in errors:\n\n```javascript\nconsole.log(err.stack);\n```\n\nThis prints:\n\n    missing file: \"/etc/passwd\"\n        at Object.<anonymous> (/Users/dap/node-verror/examples/varargs.js:4:11)\n        at Module._compile (module.js:449:26)\n        at Object.Module._extensions..js (module.js:467:10)\n        at Module.load (module.js:356:32)\n        at Function.Module._load (module.js:312:12)\n        at Module.runMain (module.js:492:10)\n        at process.startup.processNextTick.process._tickCallback (node.js:244:9)\n\n\n## Causes\n\nYou can also pass a `cause` argument, which is another Error.  For example:\n\n```javascript\nvar fs = require('fs');\nvar VError = require('verror');\n\nvar filename = '/nonexistent';\nfs.stat(filename, function (err1) {\n\tvar err2 = new VError(err1, 'stat \"%s\" failed', filename);\n\tconsole.error(err2.message);\n});\n```\n\nThis prints out:\n\n    stat \"/nonexistent\" failed: ENOENT, stat '/nonexistent'\n\nwhich resembles how Unix programs typically report errors:\n\n    $ sort /nonexistent\n    sort: open failed: /nonexistent: No such file or directory\n\nTo match the Unixy feel, just prepend the program's name to the VError's\n`message`.\n\nYou can also get the next-level Error using `err.cause()`:\n\n```javascript\nconsole.error(err2.cause().message);\n```\n\nprints:\n\n    ENOENT, stat '/nonexistent'\n\nOf course, you can nest these as many times as you want:\n\n```javascript\nvar VError = require('verror');\nvar err1 = new Error('No such file or directory');\nvar err2 = new VError(err1, 'failed to stat \"%s\"', '/junk');\nvar err3 = new VError(err2, 'request failed');\nconsole.error(err3.message);\n```\n\nThis prints:\n\n    request failed: failed to stat \"/junk\": No such file or directory\n\nThe idea is that each layer in the stack annotates the error with a description\nof what it was doing (with a printf-like format string) and the result is a\nmessage that explains what happened at every level.\n\n\n## WError: wrap layered errors\n\nSometimes you don't want an Error's \"message\" field to include the details of\nall of the low-level errors, but you still want to be able to get at them\nprogrammatically.  For example, in an HTTP server, you probably don't want to\nspew all of the low-level errors back to the client, but you do want to include\nthem in the audit log entry for the request.  In that case, you can use a\nWError, which is created exactly like VError (and also supports both\nprintf-style arguments and an optional cause), but the resulting \"message\" only\ncontains the top-level error.  It's also more verbose, including the class\nassociated with each error in the cause chain.  Using the same example above,\nbut replacing `err3`'s VError with WError, we get this output:\n\n    request failed\n\nThat's what we wanted -- just a high-level summary for the client.  But we can\nget the object's toString() for the full details:\n\n    WError: request failed; caused by WError: failed to stat \"/nonexistent\";\n    caused by Error: No such file or directory\n\n# Contributing\n\nContributions welcome.  Code should be \"make check\" clean.  To run \"make check\",\nyou'll need these tools:\n\n* https://github.com/davepacheco/jsstyle\n* https://github.com/davepacheco/javascriptlint\n\nIf you're changing something non-trivial or user-facing, you may want to submit\nan issue first.\n",
-  "readmeFilename": "README.md",
   "bugs": {
     "url": "https://github.com/davepacheco/node-verror/issues"
   },
   "homepage": "https://github.com/davepacheco/node-verror",
-  "_id": "verror@1.6.0",
+  "_id": "verror@1.10.0",
+  "_shasum": "3a105ca17053af55d6e270c1f8288682e18da400",
+  "_from": "verror@1.10.0",
+  "_npmVersion": "1.4.9",
+  "_npmUser": {
+    "name": "dap",
+    "email": "dap@cs.brown.edu"
+  },
+  "maintainers": [
+    {
+      "name": "dap",
+      "email": "dap@cs.brown.edu"
+    }
+  ],
   "dist": {
-    "shasum": "e68155752889642d5f1541346b2ca7596cbbdc90"
+    "shasum": "3a105ca17053af55d6e270c1f8288682e18da400",
+    "tarball": "http://10.0.1.33:8354/verror/-/verror-1.10.0.tgz"
+  },
+  "_npmOperationalInternal": {
+    "host": "packages-12-west.internal.npmjs.com",
+    "tmp": "tmp/verror-1.10.0.tgz_1493743247437_0.7535550429020077"
   },
-  "_from": "verror@1.6.0",
-  "_resolved": "http://registry.npmjs.org/verror/-/verror-1.6.0.tgz"
+  "directories": {},
+  "_resolved": "http://10.0.1.33:8354/verror/-/verror-1.10.0.tgz"
 }
diff --git a/src/vm/node_modules/vasync/package.json b/src/vm/node_modules/vasync/package.json
index 470e6002..3fb51250 100644
--- a/src/vm/node_modules/vasync/package.json
+++ b/src/vm/node_modules/vasync/package.json
@@ -1,6 +1,6 @@
 {
   "name": "vasync",
-  "version": "1.6.3",
+  "version": "2.2.0",
   "description": "utilities for observable asynchronous control flow",
   "main": "./lib/vasync.js",
   "repository": {
@@ -8,25 +8,28 @@
     "url": "git://github.com/davepacheco/node-vasync.git"
   },
   "scripts": {
-    "test": "tap tests/ && ./node_modules/.bin/nodeunit tests/compat.js"
+    "test": "tap --stdout tests/ && ./node_modules/.bin/nodeunit tests/compat.js && ./node_modules/.bin/nodeunit tests/compat_tryEach.js"
   },
   "devDependencies": {
     "tap": "~0.4.8",
     "nodeunit": "0.8.7"
   },
   "dependencies": {
-    "verror": "1.6.0"
+    "verror": "1.10.0"
   },
   "engines": [
     "node >=0.6.0"
   ],
   "license": "MIT",
-  "readme": "# vasync: observable asynchronous control flow\n\nThis module provides several functions for asynchronous control flow.  There are\nmany modules that do this already (notably async.js).  This one's claim to fame\nis improved debuggability.\n\n\n## Observability is important\n\nWorking with Node's asynchronous, callback-based model is much easier with a\nhandful of simple control-flow abstractions, like:\n\n* waterfalls and pipelines (which invoke a list of asynchronous callbacks\n  sequentially)\n* parallel pipelines (which invoke a list of asynchronous callbacks in parallel\n  and invoke a top-level callback when the last one completes).\n* queues\n* barriers\n\nBut these structures also introduce new types of programming errors: failing to\ninvoke the callback can cause the program to hang, and inadvertently invoking it\ntwice can cause all kinds of mayhem that's very difficult to debug.\n\nThe functions in this module keep track of what's going on so that you can\nfigure out what happened when your program goes wrong.  They generally return an\nobject describing details of the current state.  If your program goes wrong, you\nhave several ways of getting at this state:\n\n* On illumos-based systems, use MDB to [find the status object](http://dtrace.org/blogs/bmc/2012/05/05/debugging-node-js-memory-leaks/)\n  and then [print it out](http://dtrace.org/blogs/dap/2012/01/13/playing-with-nodev8-postmortem-debugging/).\n* Provide an HTTP API (or AMQP, or whatever) that returns these pending status\n  objects as JSON (see [kang](https://github.com/davepacheco/kang)).\n* Incorporate a REPL into your program and print out the status object.\n* Use the Node debugger to print out the status object.\n\n## Functions\n\n* [parallel](#parallel-invoke-n-functions-in-parallel): invoke N functions in\n  parallel (and merge the results)\n* [forEachParallel](#foreachparallel-invoke-the-same-function-on-n-inputs-in-parallel):\n  invoke the same function on N inputs in parallel\n* [pipeline](#pipeline-invoke-n-functions-in-series-and-stop-on-failure): invoke\n  N functions in series (and stop on failure)\n* [forEachPipeline](#foreachpipeline-invoke-the-same-function-on-n-inputs-in-series-and-stop-on-failure):\n  invoke the same function on N inputs in series (and stop on failure)\n* [waterfall](#waterfall-invoke-n-functions-in-series-stop-on-failure-and-propagate-results):\n  like pipeline, but propagating results between stages\n* [barrier](#barrier-coordinate-multiple-concurrent-operations): coordinate\n  multiple concurrent operations\n* [queue/queuev](#queuequeuev-fixed-size-worker-queue): fixed-size worker queue\n\n### parallel: invoke N functions in parallel\n\nSynopsis: `parallel(args, callback)`\n\nThis function takes a list of input functions (specified by the \"funcs\" property\nof \"args\") and runs them all.  These input functions are expected to be\nasynchronous: they get a \"callback\" argument and should invoke it as\n`callback(err, result)`.  The error and result will be saved and made available\nto the original caller when all of these functions complete.\n\nThis function returns the same \"result\" object it passes to the callback, and\nyou can use the fields in this object to debug or observe progress:\n\n* `operations`: array corresponding to the input functions, with\n    * `func`: input function,\n    * `status`: \"pending\", \"ok\", or \"fail\",\n    * `err`: returned \"err\" value, if any, and\n    * `result`: returned \"result\" value, if any\n* `successes`: \"result\" field for each of \"operations\" where\n  \"status\" == \"ok\" (in no particular order)\n* `ndone`: number of input operations that have completed\n* `nerrors`: number of input operations that have failed\n\nThis status object lets you see in a debugger exactly which functions have\ncompleted, what they returned, and which ones are outstanding.\n\nAll errors are combined into a single \"err\" parameter to the final callback (see\nbelow).\n\nExample usage:\n\n```js\nconsole.log(mod_vasync.parallel({\n    'funcs': [\n        function f1 (callback) { mod_dns.resolve('joyent.com', callback); },\n        function f2 (callback) { mod_dns.resolve('github.com', callback); },\n        function f3 (callback) { mod_dns.resolve('asdfaqsdfj.com', callback); }\n    ]\n}, function (err, results) {\n        console.log('error: %s', err.message);\n        console.log('results: %s', mod_util.inspect(results, null, 3));\n}));\n```\n\nIn the first tick, this outputs:\n\n```js\nstatus: { operations:\n   [ { func: [Function: f1], status: 'pending' },\n     { func: [Function: f2], status: 'pending' },\n     { func: [Function: f3], status: 'pending' } ],\n  successes: [],\n  ndone: 0,\n  nerrors: 0 }\n```\n\nshowing that there are three operations pending and none has yet been started.\nWhen the program finishes, it outputs this error:\n\n    error: first of 1 error: queryA ENOTFOUND\n\nwhich encapsulates all of the intermediate failures.  This model allows you to\nwrite the final callback like you normally would:\n\n```js\nif (err)\n  return (callback(err));\n```\n\nand still propagate useful information to callers that don't deal with multiple\nerrors (i.e. most callers).\n\nThe example also prints out the detailed final status, including all of the\nerrors and return values:\n\n```js\nresults: { operations:\n   [ { func: [Function: f1],\n       funcname: 'f1',\n       status: 'ok',\n       err: null,\n       result: [ '165.225.132.33' ] },\n     { func: [Function: f2],\n       funcname: 'f2',\n       status: 'ok',\n       err: null,\n       result: [ '207.97.227.239' ] },\n     { func: [Function: f3],\n       funcname: 'f3',\n       status: 'fail',\n       err: { [Error: queryA ENOTFOUND] code: 'ENOTFOUND',\n          errno: 'ENOTFOUND', syscall: 'queryA' },\n       result: undefined } ],\n  successes: [ [ '165.225.132.33' ], [ '207.97.227.239' ] ],\n  ndone: 3,\n  nerrors: 1 }\n```\n\nYou can use this if you want to handle all of the errors individually or to get\nat all of the individual return values.\n\nNote that \"successes\" is provided as a convenience and the order of items in\nthat array may not correspond to the order of the inputs.  To consume output in\nan ordered manner, you should iterate over \"operations\" and pick out the result\nfrom each item.\n\n\n### forEachParallel: invoke the same function on N inputs in parallel\n\nSynopsis: `forEachParallel(args, callback)`\n\nThis function is exactly like `parallel`, except that the input is specified as\na *single* function (\"func\") and a list of inputs (\"inputs\").  The function is\ninvoked on each input in parallel.\n\nThis example is exactly equivalent to the one above:\n\n```js\nconsole.log(mod_vasync.forEachParallel({\n    'func': mod_dns.resolve,\n    'inputs': [ 'joyent.com', 'github.com', 'asdfaqsdfj.com' ]\n}, function (err, results) {\n    console.log('error: %s', err.message);\n    console.log('results: %s', mod_util.inspect(results, null, 3));\n}));\n```\n\n### pipeline: invoke N functions in series (and stop on failure)\n\nSynopsis: `pipeline(args, callback)`\n\nThe named arguments (that go inside `args`) are:\n\n* `funcs`: input functions, to be invoked in series\n* `arg`: arbitrary argument that will be passed to each function\n\nThe functions are invoked in order as `func(arg, callback)`, where \"arg\" is the\nuser-supplied argument from \"args\" and \"callback\" should be invoked in the usual\nway.  If any function emits an error, the whole pipeline stops.\n\nThe return value and the arguments to the final callback are exactly the same as\nfor `parallel`.  The error object for the final callback is just the error\nreturned by whatever pipeline function failed (if any).\n\nThis example is similar to the one above, except that it runs the steps in\nsequence and stops early because `pipeline` stops on the first error:\n\n```js\nconsole.log(mod_vasync.pipeline({\n    'funcs': [\n        function f1 (_, callback) { mod_fs.stat('/tmp', callback); },\n        function f2 (_, callback) { mod_fs.stat('/noexist', callback); },\n        function f3 (_, callback) { mod_fs.stat('/var', callback); }\n    ]\n}, function (err, results) {\n        console.log('error: %s', err.message);\n        console.log('results: %s', mod_util.inspect(results, null, 3));\n}));\n```\n\nAs a result, the status after the first tick looks like this:\n\n```js\n{ operations:\n   [ { func: [Function: f1], status: 'pending' },\n     { func: [Function: f2], status: 'waiting' },\n     { func: [Function: f3], status: 'waiting' } ],\n  successes: [],\n  ndone: 0,\n  nerrors: 0 }\n```\n\nNote that the second and third stages are now \"waiting\", rather than \"pending\"\nin the `parallel` case.  The error and complete result look just like the\nparallel case.\n\n\n### forEachPipeline: invoke the same function on N inputs in series (and stop on failure)\n\nSynopsis: `forEachPipeline(args, callback)`\n\nThis function is exactly like `pipeline`, except that the input is specified as\na *single* function (\"func\") and a list of inputs (\"inputs\").  The function is\ninvoked on each input in series.\n\nThis example is exactly equivalent to the one above:\n\n```js\nconsole.log(mod_vasync.forEachPipeline({\n    'func': mod_dns.resolve,\n    'inputs': [ 'joyent.com', 'github.com', 'asdfaqsdfj.com' ]\n}, function (err, results) {\n    console.log('error: %s', err.message);\n    console.log('results: %s', mod_util.inspect(results, null, 3));\n}));\n```\n\n### waterfall: invoke N functions in series, stop on failure, and propagate results\n\nSynopsis: `waterfall(funcs, callback)`\n\nThis function works like `pipeline` except for argument passing.\n\nEach function is passed any values emitted by the previous function (none for\nthe first function), followed by the callback to invoke upon completion.  This\ncallback must be invoked exactly once, regardless of success or failure.  As\nconventional in Node, the first argument to the callback indicates an error (if\nnon-null).  Subsequent arguments are passed to the next function in the \"funcs\"\nchain.\n\nIf any function fails (i.e., calls its callback with an Error), then the\nremaining functions are not invoked and \"callback\" is invoked with the error.\n\nThe only difference between waterfall() and pipeline() are the arguments passed\nto each function in the chain.  pipeline() always passes the same argument\nfollowed by the callback, while waterfall() passes whatever values were emitted\nby the previous function followed by the callback.\n\nHere's an example:\n\n```js\nmod_vasync.waterfall([\n    function func1(callback) {\n \tsetImmediate(function () {\n\t\tcallback(null, 37);\n\t});\n    },\n    function func2(extra, callback) {\n\tconsole.log('func2 got \"%s\" from func1', extra);\n\tcallback();\n    }\n], function () {\n\tconsole.log('done');\n});\n```\n\nThis prints:\n\n```\nfunc2 got \"37\" from func1\nbetter stop early\n```\n\n### barrier: coordinate multiple concurrent operations\n\nSynopsis: `barrier([args])`\n\nReturns a new barrier object.  Like `parallel`, barriers are useful for\ncoordinating several concurrent operations, but instead of specifying a list of\nfunctions to invoke, you just say how many (and optionally which ones) are\noutstanding, and this object emits `'drain'` when they've all completed.  This\nis syntactically lighter-weight, and more flexible.\n\n* Methods:\n\n    * start(name): Indicates that the named operation began.  The name must not\n      match an operation which is already ongoing.\n    * done(name): Indicates that the named operation ended.\n\n\n* Read-only public properties (for debugging):\n\n    * pending: Set of pending operations.  Keys are names passed to \"start\", and\n      values are timestamps when the operation began.\n    * recent: Array of recent completed operations.  Each element is an object\n      with a \"name\", \"start\", and \"done\" field.  By default, 10 operations are\n      remembered.\n\n\n* Options:\n\n    * nrecent: number of recent operations to remember (for debugging)\n\nExample: printing sizes of files in a directory\n\n```js\nvar mod_fs = require('fs');\nvar mod_path = require('path');\nvar mod_vasync = require('../lib/vasync');\n\nvar barrier = mod_vasync.barrier();\n\nbarrier.on('drain', function () {\n  console.log('all files checked');\n});\n\nbarrier.start('readdir');\n\nmod_fs.readdir(__dirname, function (err, files) {\n  barrier.done('readdir');\n\n  if (err)\n    throw (err);\n\n  files.forEach(function (file) {\n    barrier.start('stat ' + file);\n\n    var path = mod_path.join(__dirname, file);\n\n    mod_fs.stat(path, function (err2, stat) {\n      barrier.done('stat ' + file);\n      console.log('%s: %d bytes', file, stat['size']);\n    });\n  });\n});\n```\n\nThis emits:\n\n    barrier-readdir.js: 602 bytes\n    foreach-parallel.js: 358 bytes\n    barrier-basic.js: 552 bytes\n    nofail.js: 384 bytes\n    pipeline.js: 490 bytes\n    parallel.js: 481 bytes\n    queue-serializer.js: 441 bytes\n    queue-stat.js: 529 bytes\n    all files checked\n\n\n### queue/queuev: fixed-size worker queue\n\nSynopsis: `queue(worker, concurrency)`\n\nSynopsis: `queuev(args)`\n\nThis function returns an object that allows up to a fixed number of tasks to be\ndispatched at any given time.  The interface is compatible with that provided\nby the \"async\" Node library, except that the returned object's fields represent\na public interface you can use to introspect what's going on.\n\n* Arguments\n\n    * worker: a function invoked as `worker(task, callback)`, where `task` is a\n      task dispatched to this queue and `callback` should be invoked when the\n      task completes.\n    * concurrency: a positive integer indicating the maximum number of tasks\n      that may be dispatched at any time.  With concurrency = 1, the queue\n      serializes all operations.\n\n\n* Methods\n\n    * push(task, [callback]): add a task (or array of tasks) to the queue, with\n      an optional callback to be invoked when each task completes.  If a list of\n      tasks are added, the callback is invoked for each one.\n    * length(): for compatibility with node-async.\n    * close(): signal that no more tasks will be enqueued.  Further attempts to\n      enqueue tasks to this queue will throw.  Once all pending and queued\n      tasks are completed the object will emit the \"end\" event.  The \"end\"\n      event is the last event the queue will emit, and it will be emitted even\n      if no tasks were ever enqueued.\n    * kill(): clear enqueued tasks and implicitly close the queue.  Several\n      caveats apply when kill() is called:\n        * The completion callback will _not_ be called for items purged from\n          the queue.\n        * The drain handler is cleared (for node-async compatibility)\n        * Subsequent calls to kill() or close() are no-ops.\n        * As with close(), it is not legal to call push() after kill().\n\n\n* Read-only public properties (for debugging):\n\n    * concurrency: for compatibility with node-async\n    * worker: worker function, as passed into \"queue\"/\"queuev\"\n    * worker\\_name: worker function's \"name\" field\n    * npending: the number of tasks currently being processed\n    * pending: an object (*not* an array) describing the tasks currently being\n      processed\n    * queued: array of tasks currently queued for processing\n    * closed: true when close() has been called on the queue\n    * ended: true when all tasks have completed processing, and no more\n      processing will occur\n    * killed: true when kill() has been called on the queue\n\n\n* Hooks (for compatibility with node-async):\n\n    * saturated\n    * empty\n    * drain\n\n* Events\n\n    * 'end': see close()\n\nIf the tasks are themselves simple objects, then the entire queue may be\nserialized (as via JSON.stringify) for debugging and monitoring tools.  Using\nthe above fields, you can see what this queue is doing (worker\\_name), which\ntasks are queued, which tasks are being processed, and so on.\n\n### Example 1: Stat several files\n\nHere's an example demonstrating the queue:\n\n```js\nvar mod_fs = require('fs');\nvar mod_vasync = require('../lib/vasync');\n\nvar queue;\n\nfunction doneOne()\n{\n  console.log('task completed; queue state:\\n%s\\n',\n      JSON.stringify(queue, null, 4));\n}\n\nqueue = mod_vasync.queue(mod_fs.stat, 2);\n\nconsole.log('initial queue state:\\n%s\\n', JSON.stringify(queue, null, 4));\n\nqueue.push('/tmp/file1', doneOne);\nqueue.push('/tmp/file2', doneOne);\nqueue.push('/tmp/file3', doneOne);\nqueue.push('/tmp/file4', doneOne);\n\nconsole.log('all tasks dispatched:\\n%s\\n', JSON.stringify(queue, null, 4));\n```\n\nThe initial queue state looks like this:\n\n```js\ninitial queue state:\n{\n    \"nextid\": 0,\n    \"worker_name\": \"anon\",\n    \"npending\": 0,\n    \"pending\": {},\n    \"queued\": [],\n    \"concurrency\": 2\n}\n```\nAfter four tasks have been pushed, we see that two of them have been dispatched\nand the remaining two are queued up:\n\n```js\nall tasks pushed:\n{\n    \"nextid\": 4,\n    \"worker_name\": \"anon\",\n    \"npending\": 2,\n    \"pending\": {\n        \"1\": {\n            \"id\": 1,\n            \"task\": \"/tmp/file1\"\n        },\n        \"2\": {\n            \"id\": 2,\n            \"task\": \"/tmp/file2\"\n        }\n    },\n    \"queued\": [\n        {\n            \"id\": 3,\n            \"task\": \"/tmp/file3\"\n        },\n        {\n            \"id\": 4,\n            \"task\": \"/tmp/file4\"\n        }\n    ],\n    \"concurrency\": 2\n}\n```\n\nAs they complete, we see tasks moving from \"queued\" to \"pending\", and completed\ntasks disappear:\n\n```js\ntask completed; queue state:\n{\n    \"nextid\": 4,\n    \"worker_name\": \"anon\",\n    \"npending\": 1,\n    \"pending\": {\n        \"3\": {\n            \"id\": 3,\n            \"task\": \"/tmp/file3\"\n        }\n    },\n    \"queued\": [\n        {\n            \"id\": 4,\n            \"task\": \"/tmp/file4\"\n        }\n    ],\n    \"concurrency\": 2\n}\n```\n\nWhen all tasks have completed, the queue state looks like it started:\n\n```js\ntask completed; queue state:\n{\n    \"nextid\": 4,\n    \"worker_name\": \"anon\",\n    \"npending\": 0,\n    \"pending\": {},\n    \"queued\": [],\n    \"concurrency\": 2\n}\n```\n\n\n### Example 2: A simple serializer\n\nYou can use a queue with concurrency 1 and where the tasks are themselves\nfunctions to ensure that an arbitrary asynchronous function never runs\nconcurrently with another one, no matter what each one does.  Since the tasks\nare the actual functions to be invoked, the worker function just invokes each\none:\n\n```js\nvar mod_vasync = require('../lib/vasync');\n\nvar queue = mod_vasync.queue(\n    function (task, callback) { task(callback); }, 1);\n\nqueue.push(function (callback) {\n  console.log('first task begins');\n  setTimeout(function () {\n    console.log('first task ends');\n    callback();\n  }, 500);\n});\n\nqueue.push(function (callback) {\n  console.log('second task begins');\n  process.nextTick(function () {\n    console.log('second task ends');\n    callback();\n  });\n});\n```\n\nThis example outputs:\n\n    $ node examples/queue-serializer.js\n    first task begins\n    first task ends\n    second task begins\n    second task ends\n",
+  "gitHead": "b267712029d0b7e3e5fe30a8426400027076dfe0",
+  "readme": "# vasync: observable asynchronous control flow\n\nThis module provides several functions for asynchronous control flow.  There are\nmany modules that do this already (notably async.js).  This one's claim to fame\nis improved debuggability.\n\n\n## Observability is important\n\nWorking with Node's asynchronous, callback-based model is much easier with a\nhandful of simple control-flow abstractions, like:\n\n* waterfalls and pipelines (which invoke a list of asynchronous callbacks\n  sequentially)\n* parallel pipelines (which invoke a list of asynchronous callbacks in parallel\n  and invoke a top-level callback when the last one completes).\n* queues\n* barriers\n\nBut these structures also introduce new types of programming errors: failing to\ninvoke the callback can cause the program to hang, and inadvertently invoking it\ntwice can cause all kinds of mayhem that's very difficult to debug.\n\nThe functions in this module keep track of what's going on so that you can\nfigure out what happened when your program goes wrong.  They generally return an\nobject describing details of the current state.  If your program goes wrong, you\nhave several ways of getting at this state:\n\n* On illumos-based systems, use MDB to [find the status object](http://dtrace.org/blogs/bmc/2012/05/05/debugging-node-js-memory-leaks/)\n  and then [print it out](http://dtrace.org/blogs/dap/2012/01/13/playing-with-nodev8-postmortem-debugging/).\n* Provide an HTTP API (or AMQP, or whatever) that returns these pending status\n  objects as JSON (see [kang](https://github.com/davepacheco/kang)).\n* Incorporate a REPL into your program and print out the status object.\n* Use the Node debugger to print out the status object.\n\n## Functions\n\n* [parallel](#parallel-invoke-n-functions-in-parallel): invoke N functions in\n  parallel (and merge the results)\n* [forEachParallel](#foreachparallel-invoke-the-same-function-on-n-inputs-in-parallel):\n  invoke the same function on N inputs in parallel\n* [pipeline](#pipeline-invoke-n-functions-in-series-and-stop-on-failure): invoke\n  N functions in series (and stop on failure)\n* [tryEach](#tryeach-invoke-n-functions-in-series-and-stop-on-success): invoke\n  N functions in series (and stop on success)\n* [forEachPipeline](#foreachpipeline-invoke-the-same-function-on-n-inputs-in-series-and-stop-on-failure):\n  invoke the same function on N inputs in series (and stop on failure)\n* [filter/filterSeries/filterLimit](#filterfilterlimitfilterseries-filter-n-inputs-serially-or-concurrently):\n  filter N inputs serially or concurrently\n* [whilst](#whilst-invoke-a-function-repeatedly-until-a-stopping-condition-is-met):\n  invoke a function repeatedly until a stopping condition is met\n* [waterfall](#waterfall-invoke-n-functions-in-series-stop-on-failure-and-propagate-results):\n  like pipeline, but propagating results between stages\n* [barrier](#barrier-coordinate-multiple-concurrent-operations): coordinate\n  multiple concurrent operations\n* [queue/queuev](#queuequeuev-fixed-size-worker-queue): fixed-size worker queue\n\n### parallel: invoke N functions in parallel\n\nSynopsis: `parallel(args, callback)`\n\nThis function takes a list of input functions (specified by the \"funcs\" property\nof \"args\") and runs them all.  These input functions are expected to be\nasynchronous: they get a \"callback\" argument and should invoke it as\n`callback(err, result)`.  The error and result will be saved and made available\nto the original caller when all of these functions complete.\n\nThis function returns the same \"result\" object it passes to the callback, and\nyou can use the fields in this object to debug or observe progress:\n\n* `operations`: array corresponding to the input functions, with\n    * `func`: input function,\n    * `status`: \"pending\", \"ok\", or \"fail\",\n    * `err`: returned \"err\" value, if any, and\n    * `result`: returned \"result\" value, if any\n* `successes`: \"result\" field for each of \"operations\" where\n  \"status\" == \"ok\" (in no particular order)\n* `ndone`: number of input operations that have completed\n* `nerrors`: number of input operations that have failed\n\nThis status object lets you see in a debugger exactly which functions have\ncompleted, what they returned, and which ones are outstanding.\n\nAll errors are combined into a single \"err\" parameter to the final callback (see\nbelow).\n\nExample usage:\n\n```js\nconsole.log(mod_vasync.parallel({\n    'funcs': [\n        function f1 (callback) { mod_dns.resolve('joyent.com', callback); },\n        function f2 (callback) { mod_dns.resolve('github.com', callback); },\n        function f3 (callback) { mod_dns.resolve('asdfaqsdfj.com', callback); }\n    ]\n}, function (err, results) {\n        console.log('error: %s', err.message);\n        console.log('results: %s', mod_util.inspect(results, null, 3));\n}));\n```\n\nIn the first tick, this outputs:\n\n```js\nstatus: { operations:\n   [ { func: [Function: f1], status: 'pending' },\n     { func: [Function: f2], status: 'pending' },\n     { func: [Function: f3], status: 'pending' } ],\n  successes: [],\n  ndone: 0,\n  nerrors: 0 }\n```\n\nshowing that there are three operations pending and none has yet been started.\nWhen the program finishes, it outputs this error:\n\n    error: first of 1 error: queryA ENOTFOUND\n\nwhich encapsulates all of the intermediate failures.  This model allows you to\nwrite the final callback like you normally would:\n\n```js\nif (err)\n  return (callback(err));\n```\n\nand still propagate useful information to callers that don't deal with multiple\nerrors (i.e. most callers).\n\nThe example also prints out the detailed final status, including all of the\nerrors and return values:\n\n```js\nresults: { operations:\n   [ { func: [Function: f1],\n       funcname: 'f1',\n       status: 'ok',\n       err: null,\n       result: [ '165.225.132.33' ] },\n     { func: [Function: f2],\n       funcname: 'f2',\n       status: 'ok',\n       err: null,\n       result: [ '207.97.227.239' ] },\n     { func: [Function: f3],\n       funcname: 'f3',\n       status: 'fail',\n       err: { [Error: queryA ENOTFOUND] code: 'ENOTFOUND',\n          errno: 'ENOTFOUND', syscall: 'queryA' },\n       result: undefined } ],\n  successes: [ [ '165.225.132.33' ], [ '207.97.227.239' ] ],\n  ndone: 3,\n  nerrors: 1 }\n```\n\nYou can use this if you want to handle all of the errors individually or to get\nat all of the individual return values.\n\nNote that \"successes\" is provided as a convenience and the order of items in\nthat array may not correspond to the order of the inputs.  To consume output in\nan ordered manner, you should iterate over \"operations\" and pick out the result\nfrom each item.\n\n\n### forEachParallel: invoke the same function on N inputs in parallel\n\nSynopsis: `forEachParallel(args, callback)`\n\nThis function is exactly like `parallel`, except that the input is specified as\na *single* function (\"func\") and a list of inputs (\"inputs\").  The function is\ninvoked on each input in parallel.\n\nThis example is exactly equivalent to the one above:\n\n```js\nconsole.log(mod_vasync.forEachParallel({\n    'func': mod_dns.resolve,\n    'inputs': [ 'joyent.com', 'github.com', 'asdfaqsdfj.com' ]\n}, function (err, results) {\n    console.log('error: %s', err.message);\n    console.log('results: %s', mod_util.inspect(results, null, 3));\n}));\n```\n\n### pipeline: invoke N functions in series (and stop on failure)\n\nSynopsis: `pipeline(args, callback)`\n\nThe named arguments (that go inside `args`) are:\n\n* `funcs`: input functions, to be invoked in series\n* `arg`: arbitrary argument that will be passed to each function\n\nThe functions are invoked in order as `func(arg, callback)`, where \"arg\" is the\nuser-supplied argument from \"args\" and \"callback\" should be invoked in the usual\nway.  If any function emits an error, the whole pipeline stops.\n\nThe return value and the arguments to the final callback are exactly the same as\nfor `parallel`.  The error object for the final callback is just the error\nreturned by whatever pipeline function failed (if any).\n\nThis example is similar to the one above, except that it runs the steps in\nsequence and stops early because `pipeline` stops on the first error:\n\n```js\nconsole.log(mod_vasync.pipeline({\n    'funcs': [\n        function f1 (_, callback) { mod_fs.stat('/tmp', callback); },\n        function f2 (_, callback) { mod_fs.stat('/noexist', callback); },\n        function f3 (_, callback) { mod_fs.stat('/var', callback); }\n    ]\n}, function (err, results) {\n        console.log('error: %s', err.message);\n        console.log('results: %s', mod_util.inspect(results, null, 3));\n}));\n```\n\nAs a result, the status after the first tick looks like this:\n\n```js\n{ operations:\n   [ { func: [Function: f1], status: 'pending' },\n     { func: [Function: f2], status: 'waiting' },\n     { func: [Function: f3], status: 'waiting' } ],\n  successes: [],\n  ndone: 0,\n  nerrors: 0 }\n```\n\nNote that the second and third stages are now \"waiting\", rather than \"pending\"\nin the `parallel` case.  The error and complete result look just like the\nparallel case.\n\n### tryEach: invoke N functions in series (and stop on success)\n\nSynopsis: `tryEach(funcs, callback)`\n\nThe `tryEach` function invokes each of the asynchronous functions in `funcs`\nserially. Each function takes a single argument: an interstitial-callback.\n`tryEach` will keep calling the functions until one of them succeeds (or they\nall fail).  At the end, the terminating-callback is invoked with the error\nand/or results provided by the last function that was called (either the last\none that failed or the first one that succeeded).\n\nThis example is similar to the one above, except that it runs the steps in\nsequence and stops early because `tryEach` stops on the first success:\n\n```js\nconsole.log(mod_vasync.tryEach([\n        function f1 (callback) { mod_fs.stat('/notreal', callback); },\n        function f2 (callback) { mod_fs.stat('/noexist', callback); },\n        function f3 (callback) { mod_fs.stat('/var', callback); },\n        function f4 (callback) { mod_fs.stat('/noexist', callback); }\n    ],\n    function (err, results) {\n            console.log('error: %s', err);\n            console.log('results: %s', mod_util.inspect(results));\n}));\n\n```\n\nThe above code will stop when it finishes f3, and we will only print a single\nresult and no errors:\n\n```js\nerror: null\nresults: { dev: 65760,\n  mode: 16877,\n  nlink: 41,\n  uid: 0,\n  gid: 3,\n  rdev: -1,\n  blksize: 2560,\n  ino: 11,\n  size: 41,\n  blocks: 7,\n  atime: Thu May 28 2015 16:21:25 GMT+0000 (UTC),\n  mtime: Thu Jan 21 2016 22:08:50 GMT+0000 (UTC),\n  ctime: Thu Jan 21 2016 22:08:50 GMT+0000 (UTC) }\n```\n\nIf we comment out `f3`, we get the following output:\n\n```js\nerror: Error: ENOENT, stat '/noexist'\nresults: undefined\n```\n\nNote that: there is a mismatch (inherited from `async`) between the semantics\nof the interstitial callback and the sematics of the terminating callback. See\nthe following example:\n\n```js\nconsole.log(mod_vasync.tryEach([\n        function f1 (callback) { callback(new Error()); },\n        function f2 (callback) { callback(new Error()); },\n        function f3 (callback) { callback(null, 1, 2, 3); },\n        function f4 (callback) { callback(null, 1); }\n    ],\n    function (err, results) {\n            console.log('error: %s', err);\n            console.log('results: %s', mod_util.inspect(results));\n}));\n\n```\n\nWe pass one or more results to the terminating-callback via the\ninterstitial-callback's arglist -- `(err, res1, res2, ...)`. From the\ncallback-implementor's perspective, the results get wrapped up in an array\n`(err, [res1, res2, ...])` -- unless there is only one result, which simply\ngets passed through as the terminating callback's second argument. This means\nthat when we call the callback in `f3` above, the terminating callback receives\nthe list `[1, 2, 3]` as its second argument. If, we comment out `f3`, we will\nend up calling the callback in `f4` which will end up invoking the terminating\ncallback with a single result: `1`, instead of `[1]`.\n\n\nIn short, be mindful that there is not always a 1:1 correspondence between the\nterminating callback that you define, and the interstitial callback that gets\ncalled from the function.\n\n\n\n### forEachPipeline: invoke the same function on N inputs in series (and stop on failure)\n\nSynopsis: `forEachPipeline(args, callback)`\n\nThis function is exactly like `pipeline`, except that the input is specified as\na *single* function (\"func\") and a list of inputs (\"inputs\").  The function is\ninvoked on each input in series.\n\nThis example is exactly equivalent to the one above:\n\n```js\nconsole.log(mod_vasync.forEachPipeline({\n    'func': mod_dns.resolve,\n    'inputs': [ 'joyent.com', 'github.com', 'asdfaqsdfj.com' ]\n}, function (err, results) {\n    console.log('error: %s', err.message);\n    console.log('results: %s', mod_util.inspect(results, null, 3));\n}));\n```\n\n### waterfall: invoke N functions in series, stop on failure, and propagate results\n\nSynopsis: `waterfall(funcs, callback)`\n\nThis function works like `pipeline` except for argument passing.\n\nEach function is passed any values emitted by the previous function (none for\nthe first function), followed by the callback to invoke upon completion.  This\ncallback must be invoked exactly once, regardless of success or failure.  As\nconventional in Node, the first argument to the callback indicates an error (if\nnon-null).  Subsequent arguments are passed to the next function in the \"funcs\"\nchain.\n\nIf any function fails (i.e., calls its callback with an Error), then the\nremaining functions are not invoked and \"callback\" is invoked with the error.\n\nThe only difference between waterfall() and pipeline() are the arguments passed\nto each function in the chain.  pipeline() always passes the same argument\nfollowed by the callback, while waterfall() passes whatever values were emitted\nby the previous function followed by the callback.\n\nHere's an example:\n\n```js\nmod_vasync.waterfall([\n    function func1(callback) {\n \tsetImmediate(function () {\n\t\tcallback(null, 37);\n\t});\n    },\n    function func2(extra, callback) {\n\tconsole.log('func2 got \"%s\" from func1', extra);\n\tcallback();\n    }\n], function () {\n\tconsole.log('done');\n});\n```\n\nThis prints:\n\n```\nfunc2 got \"37\" from func1\nbetter stop early\n```\n\n### filter/filterLimit/filterSeries: filter N inputs serially or concurrently\n\nSynopsis: `filter(inputs, filterFunc, callback)`\n\nSynopsis: `filterSeries(inputs, filterFunc, callback)`\n\nSynopsis: `filterLimit(inputs, limit, filterFunc, callback)`\n\nThese functions take an array (of anything) and a function to call on each\nelement of the array.  The function must callback with a true or false value as\nthe second argument or an error object as the first argument.  False values\nwill result in the element being filtered out of the results array.  An error\nobject passed as the first argument will cause the filter function to stop\nprocessing new elements and callback to the caller with the error immediately.\nOriginal input array order is maintained.\n\n`filter` and `filterSeries` are analogous to calling `filterLimit` with\na limit of `Infinity` and `1` respectively.\n\n\n```js\nvar inputs = [\n    'joyent.com',\n    'github.com',\n    'asdfaqsdfj.com'\n];\nfunction filterFunc(input, cb) {\n    mod_dns.resolve(input, function (err, results) {\n        if (err) {\n            cb(null, false);\n        } else {\n            cb(null, true);\n        }\n    }\n}\nmod_vasync.filter(inputs, filterFunc, function (err, results) {\n    // err => undefined\n    // results => ['joyent.com', 'github.com']\n});\n```\n\n### whilst: invoke a function repeatedly until a stopping condition is met\n\nSynopsis: `whilst(testFunc, iterateFunc, callback)`\n\nRepeatedly invoke `iterateFunc` while `testFunc` returns a true value.\n`iterateFunc` is an asychronous function that must call its callback (the first\nand only argument given to it) when it is finished with an optional error\nobject as the first argument, and any other arbitrary arguments.  If an error\nobject is given as the first argument, `whilst` will finish and call `callback`\nwith the error object.  `testFunc` is a synchronous function that must return\na value - if the value resolves to true `whilst` will invoke `iterateFunc`, if\nit resolves to false `whilst` will finish and invoke `callback` with the last\nset of arguments `iterateFunc` called back with.\n\n`whilst` also returns an object suitable for introspecting the current state of\nthe specific `whilst` invocation which contains the following properties:\n\n* `finished`: boolean if this invocation has finished or is in progress\n* `iterations`: number of iterations performed (calls to `iterateFunc`)\n\nCompatible with `async.whilst`\n\n```js\nvar n = 0;\n\nvar w = mod_vasync.whilst(\n    function testFunc() {\n        return (n < 5);\n    },\n    function iterateFunc(cb) {\n        n++;\n        cb(null, {n: n});\n    },\n    function whilstDone(err, arg) {\n        // err => undefined\n        // arg => {n: 5}\n        // w => {finished: true, iterations: 5}\n    }\n);\n\n// w => {finished: false, iterations: 0}\n```\n\n### barrier: coordinate multiple concurrent operations\n\nSynopsis: `barrier([args])`\n\nReturns a new barrier object.  Like `parallel`, barriers are useful for\ncoordinating several concurrent operations, but instead of specifying a list of\nfunctions to invoke, you just say how many (and optionally which ones) are\noutstanding, and this object emits `'drain'` when they've all completed.  This\nis syntactically lighter-weight, and more flexible.\n\n* Methods:\n\n    * start(name): Indicates that the named operation began.  The name must not\n      match an operation which is already ongoing.\n    * done(name): Indicates that the named operation ended.\n\n\n* Read-only public properties (for debugging):\n\n    * pending: Set of pending operations.  Keys are names passed to \"start\", and\n      values are timestamps when the operation began.\n    * recent: Array of recent completed operations.  Each element is an object\n      with a \"name\", \"start\", and \"done\" field.  By default, 10 operations are\n      remembered.\n\n\n* Options:\n\n    * nrecent: number of recent operations to remember (for debugging)\n\nExample: printing sizes of files in a directory\n\n```js\nvar mod_fs = require('fs');\nvar mod_path = require('path');\nvar mod_vasync = require('../lib/vasync');\n\nvar barrier = mod_vasync.barrier();\n\nbarrier.on('drain', function () {\n  console.log('all files checked');\n});\n\nbarrier.start('readdir');\n\nmod_fs.readdir(__dirname, function (err, files) {\n  barrier.done('readdir');\n\n  if (err)\n    throw (err);\n\n  files.forEach(function (file) {\n    barrier.start('stat ' + file);\n\n    var path = mod_path.join(__dirname, file);\n\n    mod_fs.stat(path, function (err2, stat) {\n      barrier.done('stat ' + file);\n      console.log('%s: %d bytes', file, stat['size']);\n    });\n  });\n});\n```\n\nThis emits:\n\n    barrier-readdir.js: 602 bytes\n    foreach-parallel.js: 358 bytes\n    barrier-basic.js: 552 bytes\n    nofail.js: 384 bytes\n    pipeline.js: 490 bytes\n    parallel.js: 481 bytes\n    queue-serializer.js: 441 bytes\n    queue-stat.js: 529 bytes\n    all files checked\n\n\n### queue/queuev: fixed-size worker queue\n\nSynopsis: `queue(worker, concurrency)`\n\nSynopsis: `queuev(args)`\n\nThis function returns an object that allows up to a fixed number of tasks to be\ndispatched at any given time.  The interface is compatible with that provided\nby the \"async\" Node library, except that the returned object's fields represent\na public interface you can use to introspect what's going on.\n\n* Arguments\n\n    * worker: a function invoked as `worker(task, callback)`, where `task` is a\n      task dispatched to this queue and `callback` should be invoked when the\n      task completes.\n    * concurrency: a positive integer indicating the maximum number of tasks\n      that may be dispatched at any time.  With concurrency = 1, the queue\n      serializes all operations.\n\n\n* Methods\n\n    * push(task, [callback]): add a task (or array of tasks) to the queue, with\n      an optional callback to be invoked when each task completes.  If a list of\n      tasks are added, the callback is invoked for each one.\n    * length(): for compatibility with node-async.\n    * close(): signal that no more tasks will be enqueued.  Further attempts to\n      enqueue tasks to this queue will throw.  Once all pending and queued\n      tasks are completed the object will emit the \"end\" event.  The \"end\"\n      event is the last event the queue will emit, and it will be emitted even\n      if no tasks were ever enqueued.\n    * kill(): clear enqueued tasks and implicitly close the queue.  Several\n      caveats apply when kill() is called:\n        * The completion callback will _not_ be called for items purged from\n          the queue.\n        * The drain handler is cleared (for node-async compatibility)\n        * Subsequent calls to kill() or close() are no-ops.\n        * As with close(), it is not legal to call push() after kill().\n\n\n* Read-only public properties (for debugging):\n\n    * concurrency: for compatibility with node-async\n    * worker: worker function, as passed into \"queue\"/\"queuev\"\n    * worker\\_name: worker function's \"name\" field\n    * npending: the number of tasks currently being processed\n    * pending: an object (*not* an array) describing the tasks currently being\n      processed\n    * queued: array of tasks currently queued for processing\n    * closed: true when close() has been called on the queue\n    * ended: true when all tasks have completed processing, and no more\n      processing will occur\n    * killed: true when kill() has been called on the queue\n\n\n* Hooks (for compatibility with node-async):\n\n    * saturated\n    * empty\n    * drain\n\n* Events\n\n    * 'end': see close()\n\nIf the tasks are themselves simple objects, then the entire queue may be\nserialized (as via JSON.stringify) for debugging and monitoring tools.  Using\nthe above fields, you can see what this queue is doing (worker\\_name), which\ntasks are queued, which tasks are being processed, and so on.\n\n### Example 1: Stat several files\n\nHere's an example demonstrating the queue:\n\n```js\nvar mod_fs = require('fs');\nvar mod_vasync = require('../lib/vasync');\n\nvar queue;\n\nfunction doneOne()\n{\n  console.log('task completed; queue state:\\n%s\\n',\n      JSON.stringify(queue, null, 4));\n}\n\nqueue = mod_vasync.queue(mod_fs.stat, 2);\n\nconsole.log('initial queue state:\\n%s\\n', JSON.stringify(queue, null, 4));\n\nqueue.push('/tmp/file1', doneOne);\nqueue.push('/tmp/file2', doneOne);\nqueue.push('/tmp/file3', doneOne);\nqueue.push('/tmp/file4', doneOne);\n\nconsole.log('all tasks dispatched:\\n%s\\n', JSON.stringify(queue, null, 4));\n```\n\nThe initial queue state looks like this:\n\n```js\ninitial queue state:\n{\n    \"nextid\": 0,\n    \"worker_name\": \"anon\",\n    \"npending\": 0,\n    \"pending\": {},\n    \"queued\": [],\n    \"concurrency\": 2\n}\n```\nAfter four tasks have been pushed, we see that two of them have been dispatched\nand the remaining two are queued up:\n\n```js\nall tasks pushed:\n{\n    \"nextid\": 4,\n    \"worker_name\": \"anon\",\n    \"npending\": 2,\n    \"pending\": {\n        \"1\": {\n            \"id\": 1,\n            \"task\": \"/tmp/file1\"\n        },\n        \"2\": {\n            \"id\": 2,\n            \"task\": \"/tmp/file2\"\n        }\n    },\n    \"queued\": [\n        {\n            \"id\": 3,\n            \"task\": \"/tmp/file3\"\n        },\n        {\n            \"id\": 4,\n            \"task\": \"/tmp/file4\"\n        }\n    ],\n    \"concurrency\": 2\n}\n```\n\nAs they complete, we see tasks moving from \"queued\" to \"pending\", and completed\ntasks disappear:\n\n```js\ntask completed; queue state:\n{\n    \"nextid\": 4,\n    \"worker_name\": \"anon\",\n    \"npending\": 1,\n    \"pending\": {\n        \"3\": {\n            \"id\": 3,\n            \"task\": \"/tmp/file3\"\n        }\n    },\n    \"queued\": [\n        {\n            \"id\": 4,\n            \"task\": \"/tmp/file4\"\n        }\n    ],\n    \"concurrency\": 2\n}\n```\n\nWhen all tasks have completed, the queue state looks like it started:\n\n```js\ntask completed; queue state:\n{\n    \"nextid\": 4,\n    \"worker_name\": \"anon\",\n    \"npending\": 0,\n    \"pending\": {},\n    \"queued\": [],\n    \"concurrency\": 2\n}\n```\n\n\n### Example 2: A simple serializer\n\nYou can use a queue with concurrency 1 and where the tasks are themselves\nfunctions to ensure that an arbitrary asynchronous function never runs\nconcurrently with another one, no matter what each one does.  Since the tasks\nare the actual functions to be invoked, the worker function just invokes each\none:\n\n```js\nvar mod_vasync = require('../lib/vasync');\n\nvar queue = mod_vasync.queue(\n    function (task, callback) { task(callback); }, 1);\n\nqueue.push(function (callback) {\n  console.log('first task begins');\n  setTimeout(function () {\n    console.log('first task ends');\n    callback();\n  }, 500);\n});\n\nqueue.push(function (callback) {\n  console.log('second task begins');\n  process.nextTick(function () {\n    console.log('second task ends');\n    callback();\n  });\n});\n```\n\nThis example outputs:\n\n    $ node examples/queue-serializer.js\n    first task begins\n    first task ends\n    second task begins\n    second task ends\n",
   "readmeFilename": "README.md",
   "bugs": {
     "url": "https://github.com/davepacheco/node-vasync/issues"
   },
   "homepage": "https://github.com/davepacheco/node-vasync",
-  "_id": "vasync@1.6.3",
-  "_from": "vasync@"
+  "_id": "vasync@2.2.0",
+  "_shasum": "e954b29f3da731929b43e5de172345b747ab8ef9",
+  "_from": "git://github.com/joyent/node-vasync.git",
+  "_resolved": "git://github.com/joyent/node-vasync.git#b267712029d0b7e3e5fe30a8426400027076dfe0"
 }
diff --git a/src/vm/tests/test-50-creates.js b/src/vm/tests/test-50-creates.js
index 0817ad6e..608893b2 100644
--- a/src/vm/tests/test-50-creates.js
+++ b/src/vm/tests/test-50-creates.js
@@ -1,12 +1,34 @@
-// Copyright 2015 Joyent, Inc.  All rights reserved.
-//
-// These tests ensure that default values don't change accidentally.
-//
+/*
+ * CDDL HEADER START
+ *
+ * The contents of this file are subject to the terms of the
+ * Common Development and Distribution License, Version 1.0 only
+ * (the "License").  You may not use this file except in compliance
+ * with the License.
+ *
+ * You can obtain a copy of the license at http://smartos.org/CDDL
+ *
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * When distributing Covered Code, include this CDDL HEADER in each
+ * file.
+ *
+ * If applicable, add the following below this CDDL HEADER, with the
+ * fields enclosed by brackets "[]" replaced with your own identifying
+ * information: Portions Copyright [yyyy] [name of copyright owner]
+ *
+ * CDDL HEADER END
+ *
+ * Copyright (c) 2017, Joyent, Inc.
+ *
+ * These tests ensure that default values don't change accidentally.
+ */
 
-var async = require('/usr/node/node_modules/async');
+var fs = require('fs');
 var VM = require('/usr/vm/node_modules/VM');
+var vasync = require('/usr/vm/node_modules/vasync');
 var vmtest = require('../common/vmtest.js');
-var fs = require('fs');
 
 // this puts test stuff in global, so we need to tell jsl about that:
 /* jsl:import ../node_modules/nodeunit-plus/index.js */
@@ -17,10 +39,9 @@ VM.loglevel = 'DEBUG';
 var image_uuid = vmtest.CURRENT_SMARTOS_UUID;
 
 test('create and destroy 50 zones', function(t) {
-    var i;
+    var i = 0;
 
-    i = 0;
-    async.whilst(
+    vasync.whilst(
         function () {
             return i < 50;
         },
diff --git a/src/vm/tests/test-delete.js b/src/vm/tests/test-delete.js
index ee472d6c..c030b91d 100644
--- a/src/vm/tests/test-delete.js
+++ b/src/vm/tests/test-delete.js
@@ -1,11 +1,33 @@
-// Copyright 2017 Joyent, Inc.
-//
-// These tests ensure that delete behaves correctly.
-//
+/*
+ * CDDL HEADER START
+ *
+ * The contents of this file are subject to the terms of the
+ * Common Development and Distribution License, Version 1.0 only
+ * (the "License").  You may not use this file except in compliance
+ * with the License.
+ *
+ * You can obtain a copy of the license at http://smartos.org/CDDL
+ *
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * When distributing Covered Code, include this CDDL HEADER in each
+ * file.
+ *
+ * If applicable, add the following below this CDDL HEADER, with the
+ * fields enclosed by brackets "[]" replaced with your own identifying
+ * information: Portions Copyright [yyyy] [name of copyright owner]
+ *
+ * CDDL HEADER END
+ *
+ * Copyright (c) 2017, Joyent, Inc.
+ *
+ * These tests ensure that delete behaves correctly.
+ */
 
-var async = require('/usr/node/node_modules/async');
 var libuuid = require('/usr/node/node_modules/uuid');
 var VM = require('/usr/vm/node_modules/VM');
+var vasync = require('/usr/vm/node_modules/vasync');
 
 // this puts test stuff in global, so we need to tell jsl about that:
 /* jsl:import ../node_modules/nodeunit-plus/index.js */
@@ -17,7 +39,7 @@ VM.loglevel = 'DEBUG';
 // haven't regressed.
 test('test deleting nonexistent VM', function(t) {
     var i = 0;
-    async.whilst(
+    vasync.whilst(
         function () {
             return i < 50;
         },
diff --git a/src/vm/tests/test-snapshots.js b/src/vm/tests/test-snapshots.js
index 087f684d..b718026f 100644
--- a/src/vm/tests/test-snapshots.js
+++ b/src/vm/tests/test-snapshots.js
@@ -1,12 +1,36 @@
-// Copyright 2015 Joyent, Inc.  All rights reserved.
+/*
+ * CDDL HEADER START
+ *
+ * The contents of this file are subject to the terms of the
+ * Common Development and Distribution License, Version 1.0 only
+ * (the "License").  You may not use this file except in compliance
+ * with the License.
+ *
+ * You can obtain a copy of the license at http://smartos.org/CDDL
+ *
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * When distributing Covered Code, include this CDDL HEADER in each
+ * file.
+ *
+ * If applicable, add the following below this CDDL HEADER, with the
+ * fields enclosed by brackets "[]" replaced with your own identifying
+ * information: Portions Copyright [yyyy] [name of copyright owner]
+ *
+ * CDDL HEADER END
+ *
+ * Copyright (c) 2017, Joyent, Inc.
+ *
+ */
 
-var async = require('/usr/node/node_modules/async');
 var cp = require('child_process');
 var execFile = cp.execFile;
 var fs = require('fs');
 var net = require('net');
 var path = require('path');
 var VM = require('/usr/vm/node_modules/VM');
+var vasync = require('/usr/vm/node_modules/vasync');
 var vmtest = require('../common/vmtest.js');
 
 // this puts test stuff in global, so we need to tell jsl about that:
@@ -324,7 +348,10 @@ test('create snapshot with bad name', function (t) {
         createBadSnapshot(t, vmobj.uuid, name, cb);
     }
 
-    async.forEach(bad_names, caller, function (err) {
+    vasync.forEachParallel({
+        inputs: bad_names,
+        func: caller
+    }, function (err) {
         t.ok(!err, 'no extra errors from creating all the bad snapshots');
         t.end();
     });
@@ -659,7 +686,7 @@ function createXSnapshots(t, x, callback)
 
     var creates = 0;
 
-    async.whilst(
+    vasync.whilst(
     function () { return (!abort && creates < x); },
     function (cb) {
         var snapname;
@@ -705,7 +732,7 @@ test('delete 50 snapshots on joyent-minimal', function (t) {
 
     var deletes = 49;
 
-    async.whilst(
+    vasync.whilst(
     function () { return (!abort && deletes >= 0); },
     function (callback) {
         var snapname;
@@ -744,8 +771,8 @@ function (t) {
         return;
     }
 
-    async.series([
-        function (cb) {
+    vasync.pipeline({funcs: [
+        function (_, cb) {
             VM.load(vmobj.uuid, function (err, obj) {
                 t.ok(!err, 'loading VM before last_modified snapshot');
                 if (!err) {
@@ -753,14 +780,14 @@ function (t) {
                 }
                 cb(err);
             });
-        }, function (cb) {
+        }, function (_, cb) {
             setTimeout(function () {
                 createSnapshot(t, vmobj.uuid, 'modifyme', 1, function (err) {
                     t.ok(!err, 'created snapshot for last_modified test');
                     cb(err);
                 });
             }, 1000);
-        }, function (cb) {
+        }, function (_, cb) {
             VM.load(vmobj.uuid, function (err, obj) {
                 t.ok(!err, 'loaded VM after snapshot');
                 if (!err) {
@@ -768,14 +795,14 @@ function (t) {
                 }
                 cb(err);
             });
-        }, function (cb) {
+        }, function (_, cb) {
             setTimeout(function () {
                 deleteSnapshot(t, vmobj.uuid, 'modifyme', 0, function (err) {
                     t.ok(!err, 'deleted snapshot for last_modified test');
                     cb(err);
                 });
             }, 1000);
-        }, function (cb) {
+        }, function (_, cb) {
             VM.load(vmobj.uuid, function (err, obj) {
                 t.ok(!err, 'loaded VM after delete snapshot');
                 if (!err) {
@@ -784,7 +811,7 @@ function (t) {
                 cb(err);
             });
         }
-    ], function (err) {
+    ]}, function (err) {
         if (!err) {
             t.ok((Date.parse(pre_snap_timestamp)
                 < Date.parse(post_snap_timestamp)),
@@ -811,15 +838,15 @@ test('create/delete joyent-minimal snapshot should handle mounting '
         return;
     }
 
-    async.series([
-        function (cb) {
+    vasync.pipeline({funcs: [
+        function (_, cb) {
             createSnapshot(t, vmobj.uuid, snapname, vmobj.snapshots.length + 1,
                 function (err) {
                     t.ok(!err, 'created snapshot for last_modified test');
                     cb(err);
                 }
             );
-        }, function (cb) {
+        }, function (_, cb) {
             var passwd_file = path.join(checkpoint_dir + '/etc/passwd');
 
             fs.exists(passwd_file, function (exists) {
@@ -831,13 +858,13 @@ test('create/delete joyent-minimal snapshot should handle mounting '
                 }
                 cb(err);
             });
-        }, function (cb) {
+        }, function (_, cb) {
             deleteSnapshot(t, vmobj.uuid, snapname, 0, function (err) {
                 t.ok(!err, 'deleted ' + snapname + ' snapshot for '
                     + vmobj.uuid);
                 cb(err);
             });
-        }, function (cb) {
+        }, function (_, cb) {
 
             fs.exists(checkpoint_dir, function (exists) {
                 var err;
@@ -849,7 +876,7 @@ test('create/delete joyent-minimal snapshot should handle mounting '
                 cb(err);
             });
         }
-    ], function (err) {
+    ]}, function (err) {
         t.ok(!err, 'testing /checkpoints: ' + (err ? err.message : 'success'));
         t.end();
     });
