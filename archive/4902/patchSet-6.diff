commit 7daa1bbb8a1730bf008411ff743d98bb7ca698eb (refs/changes/02/4902/6)
Author: Tim Foster <tim.foster@joyent.com>
Date:   2018-11-02T16:43:42+00:00 (11 months ago)
    
    TRITON-774 imgapi should allow admin-only add-file from URLs

diff --git a/CHANGES.md b/CHANGES.md
index 24f7bfd..c54e93c 100644
--- a/CHANGES.md
+++ b/CHANGES.md
@@ -1,5 +1,10 @@
 # IMGAPI changelog
 
+## 4.6.0
+
+- TRITON-774 imgapi should allow admin-only file-add from URLs, adds a new
+  AddImageFileFromUrl endpoint /images/:uuid/file/from-url (POST).
+
 ## 4.5.2
 
 - TRITON-682 imgapi support for requirements.bootrom
diff --git a/docs/index.md b/docs/index.md
index e03368e..1687805 100644
--- a/docs/index.md
+++ b/docs/index.md
@@ -108,6 +108,7 @@ A summary of fields (details are provided below):
 | [requirements.max_ram](#manifest-requirementsmax_ram)           | Integer | No                            | Yes      | Maximum RAM (in MiB) this image may be provisioned with.                                                                                                                                        |
 | [requirements.min_platform](#manifest-requirementsmin_platform) | Object  | No                            | Yes      | Minimum platform requirement for provisioning with this image.                                                                                                                                  |
 | [requirements.max_platform](#manifest-requirementsmax_platform) | Object  | No                            | Yes      | Maximum platform requirement for provisioning with this image.                                                                                                                                  |
+| [requirements.bootrom](#manifest-requirementsbootrom)           | String  | No                            | Yes      | Bootrom image to use with this image.                                                                                                                                  |
 | [users](#manifest-users)                                        | Array   | No                            | Yes      | A list of users for which passwords should be generated for provisioning. This may only make sense for some images. Example: `[{"name": "root"}, {"name": "admin"}]`                            |
 | [billing_tags](#manifest-billing_tags)                          | Array   | No                            | Yes      | A list of tags that can be used by operators for additional billing processing.                                                                                                                 |
 | [traits](#manifest-traits)                                      | Object  | No                            | Yes      | An object that defines a collection of properties that is used by other APIs to evaluate where should customer VMs be placed.                                                                   |
@@ -513,6 +514,12 @@ then:
    *allow* in the face of ambiguity.
 
 
+## Manifest: requirements.bootrom
+
+Optional. `bootrom` defines the boot ROM image to use. May take values `"bios"`
+or `"uefi"`. Only valid when `brand` is `bhyve`.
+
+
 ## Manifest: users
 
 Optional. `users` is a list of users for which passwords should be generated
@@ -615,26 +622,27 @@ and relevant for images in an IMGAPI server that uses [channels](#channels).
 | [DeleteImage](#DeleteImage)                       | DELETE /images/:uuid                                       | Delete an image (and its file).                                               |
 | [CreateImage](#CreateImage)                       | POST /images                                               | Create a new (unactivated) image from a manifest.                             |
 | [AddImageFile](#AddImageFile)                     | PUT /images/:uuid/file                                     | Upload the image file.                                                        |
+| [AddImageFileFromUrl](#AddImageFileFromUrl)       | POST /images/:uuid/file/from-url                           | Upload the image file using a URL source.                                     |
 | [ActivateImage](#ActivateImage)                   | POST /images/:uuid?action=activate                         | Activate the image.                                                           |
 | [UpdateImage](#UpdateImage)                       | POST /images/:uuid?action=update                           | Update image manifest fields. This is limited. Some fields are immutable.     |
 | [DisableImage](#DisableImage)                     | POST /images/:uuid?action=disable                          | Disable the image.                                                            |
 | [EnableImage](#EnableImage)                       | POST /images/:uuid?action=enable                           | Enable the image.                                                             |
 | [AddImageAcl](#AddImageAcl)                       | POST /images/:uuid/acl?action=add                          | Add account UUIDs to the image ACL.                                           |
 | [RemoveImageAcl](#RemoveImageAcl)                 | POST /images/:uuid/acl?action=remove                       | Remove account UUIDs from the image ACL.                                      |
-| [CloneImage](#CloneImage)                         | POST /images/:uuid/clone                                   | Clone this image.
+| [CloneImage](#CloneImage)                         | POST /images/:uuid/clone                                   | Clone this image.                                                             |
 | [AddImageIcon](#AddImageIcon)                     | POST /images/:uuid/icon                                    | Add the image icon.                                                           |
 | [GetImageIcon](#GetImageIcon)                     | GET /images/:uuid/icon                                     | Get the image icon file.                                                      |
 | [DeleteImageIcon](#DeleteImageIcon)               | DELETE /images/:uuid/icon                                  | Remove the image icon.                                                        |
 | [CreateImageFromVm](#CreateImageFromVm)           | POST /images?action=create-from-vm                         | Create a new (activated) image from an existing VM.                           |
 | [ExportImage](#ExportImage)                       | POST /images/:uuid?action=export                           | Exports an image to the specified Manta path.                                 |
-| [ImportFromDatacenter](#ImportFromDatacenter)     | POST /images/$uuid?action=import-from-datacenter&datacenter=us-west-1  | Copy one's own image from another datacenter in the same cloud.  |
+| [ImportFromDatacenter](#ImportFromDatacenter)     | POST /images/$uuid?action=import-from-datacenter&datacenter=us-west-1  | Copy one's own image from another datacenter in the same cloud.   |
 | [AdminImportRemoteImage](#AdminImportRemoteImage) | POST /images/$uuid?action=import-remote&source=$imgapi-url | Import an image from another IMGAPI                                           |
 | [AdminImportImage](#AdminImportImage)             | POST /images/$uuid?action=import                           | Only for operators to import an image and maintain `uuid` and `published_at`. |
 | [AdminGetState](#AdminGetState)                   | GET /state                                                 | Dump internal server state (for dev/debugging)                                |
 | [ListChannels](#ListChannels)                     | GET /channels                                              | List image channels (if the server uses channels).                            |
 | [ChannelAddImage](#ChannelAddImage)               | POST /images/:uuid?action=channel-all                      | Add an existing image to another channel.                                     |
 | [Ping](#Ping)                                     | GET /ping                                                  | Ping if the server is up.                                                     |
-| [AdminReloadAuthKeys](#AdminReloadAuthKeys)       | POST /authkeys/reload                                          | (Added in v2.3.0.) Tell server to reload its auth keys. This is only relevant for servers using HTTP Signature auth. |
+| [AdminReloadAuthKeys](#AdminReloadAuthKeys)       | POST /authkeys/reload                                      | (Added in v2.3.0.) Tell server to reload its auth keys. This is only relevant for servers using HTTP Signature auth. |
 
 
 
@@ -1439,6 +1447,95 @@ CLI tool:
     Added file "file.bz2" to image 25ab9ddf-96e8-4157-899d-1dc8be7b9810
 
 
+## AddImageFileFromUrl (POST /images/:uuid/file/from-url)
+
+Almost identical to the AddImageFile PUT method, this POST method allows users
+to specify a URL from which the imgapi instance should retrieve the image file.
+
+HTTPS is the only scheme supported by this method. Note that as URLs are
+typically quite long, the URL is passed in the body of the POST.
+
+If the image already has a file, it will be overwritten. A file can only
+be added to an image that has not yet been activated. The typical process
+is to call this after [CreateImage](#CreateImage), and then subsequently
+call [ActivateImage](#ActivateImage) to make the image available
+for provisioning, `state == "active"`.
+
+### Inputs
+
+| Field                          | Type       | Required? | Notes                                                                                                                                                                                                                                                                                                                                              |
+| ------------------------------ | ---------- | --------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
+| account (query param)          | UUID       | No        | The account UUID on behalf of whom this request is being made. If given and if relevant, authorization will be done for this account. It is expected that all calls originating from a user (e.g. from cloudapi) will provide this parameter.                                                                                                      |
+| channel (query param)          | String     | No        | The image channel to use. (Only relevant for servers using [channels](#channels).)                                                                                                                                                                                                                                                                 |
+| storage                        | String     | No        | The type of storage preferred for this image file. Storage can only be specified if the request is being made by an operator. The only two possible values for storage are **local** and **manta**. When the request is made on behalf of a customer then IMGAPI will try to use manta as the storage backend, otherwise default to local storage. |
+| [compression](#manifest-files) | UUID       | Yes       | The type of compression used for the file content. One of 'none', 'gzip' or 'bzip2'.                                                                                                                                                                                                                                                               |
+| [sha1](#manifest-files)        | SHA-1 Hash | No        | SHA-1 of the uploaded file to allow the server to check for data corruption.                                                                                                                                                                                                                                                                       |
+| dataset_guid                   | GUID       | No        | The ZFS internal unique identifier for this dataset's snapshot (available via `zfs get guid SNAPSHOT`, e.g. `zfs get guid zones/f669428c-a939-11e2-a485-b790efc0f0c1@final`). If available, this is used to ensure a common base snapshot for incremental images (via `imgadm create -i`) and VM migrations (via `vmadm send/receive`).            |
+| file_url (body)                | String     | Yes       | A URL to the image file. HTTPS is the only supported URL scheme, and the HTTPS server must not use self-signed certificates.                                                                                                                                                                                                                       |
+
+### Returns
+
+The updated image object.
+
+### Errors
+
+See [Errors](#errors) section above.
+
+### Example
+
+Raw API tool (against an SDC's IMGAPI).
+
+    $ sdc-imgapi '/images/2d74d0fb-8402-4e10-a145-86864b14bca7/file/from-url?compression=gzip&sha1=e6a828afa242ecad289f3114e6e2856ef2404a48' -X POST \
+    -d '{"file_url": "https://us-east.manta.joyent.com/timf/public/builds/assets/master-20180925T100358Z-g3f3d1b8/assets/assets-zfs-master-20180925T100358Z-g3f3d1b8.zfs.gz"}'
+    HTTP/1.1 200 OK
+    Etag: 824d644a739bb659b86c24316864d7f56438d696
+    Content-Type: application/json
+    Content-Length: 646
+    Date: Mon, 01 Oct 2018 11:09:47 GMT
+    Server: imgapi/4.6.0
+    x-request-id: 4fc4c29f-b568-408e-8019-54f0393b9025
+    x-response-time: 162167
+    x-server-name: 9b76732a-a75b-4ca5-b1a5-732974733639
+    Connection: keep-alive
+
+    {
+      "v": 2,
+      "uuid": "2d74d0fb-8402-4e10-a145-86864b14bca7",
+      "owner": "930896af-bf8c-48d4-885c-6573a94b1853",
+      "name": "assets",
+      "version": "master-20180925T100358Z-g3f3d1b8",
+      "state": "unactivated",
+      "disabled": false,
+      "public": false,
+      "type": "zone-dataset",
+      "os": "smartos",
+      "files": [
+        {
+          "sha1": "e6a828afa242ecad289f3114e6e2856ef2404a48",
+          "size": 69223039,
+          "compression": "gzip"
+        }
+      ],
+      "description": "SDC Assets",
+      "requirements": {
+        "min_platform": {
+          "7.0": "20180830T001556Z"
+        }
+      },
+      "origin": "04a48d7d-6bb5-4e83-8c3b-e60a99e0f48f",
+      "tags": {
+        "smartdc_service": true
+      }
+    }
+
+CLI tool:
+
+    $ sdc-imgadm add-file -s e6a828afa242ecad289f3114e6e2856ef2404a48 --url \
+        -f https://us-east.manta.joyent.com//timf/public/builds/assets/master-20180925T100358Z-g3f3d1b8/assets/assets-zfs-master-20180925T100358Z-g3f3d1b8.zfs.gz \
+        2d74d0fb-8402-4e10-a145-86864b14bca7
+    Added file from url "https://us-east.manta.joyent.com//timf/public/builds/assets/master-20180925T100358Z-g3f3d1b8/assets/assets-zfs-master-20180925T100358Z-g3f3d1b8.zfs.gz" (compression "auto detected") to image 2d74d0fb-8402-4e10-a145-86864b14bca7
+
+
 ## AddImageIcon (PUT /images/:uuid/icon)
 
 Add the image icon. If the image already has an icon file, it will be overwritten.
@@ -2140,7 +2237,6 @@ CLI tool:
     Imported image 84cb7edc-3f22-11e2-8a2a-3f2a7b148699 (base, 1.8.4, state=active)
 
 
-
 ## AdminImportDockerImage (POST /images?action=import-docker-image)
 
 Import an image from a *Docker* repository. This endpoint maintains an open
diff --git a/lib/images.js b/lib/images.js
index 87d0600..c0a7f3a 100644
--- a/lib/images.js
+++ b/lib/images.js
@@ -22,6 +22,7 @@ var path = require('path');
 
 var assert = require('assert-plus');
 var async = require('async');
+var https = require('https');
 var imgmanifest = require('imgmanifest');
 var lib_uuid = require('uuid');
 var once = require('once');
@@ -1311,7 +1312,6 @@ Image.filter = function filterImages(app, options, log, callback) {
 };
 
 
-
 //---- API controllers
 
 /**
@@ -2861,8 +2861,8 @@ function apiAddImageFile(req, res, next) {
                 'image file size exceeds the maximum allowed size, %s',
                 constants.MAX_IMAGE_SIZE_STR)));
         }
-        shasum.update(chunk, 'binary');
-        md5sum.update(chunk, 'binary');
+        shasum.update(chunk);
+        md5sum.update(chunk);
     });
     req.on('end', function () {
         req.log.trace('req "end" event');
@@ -3076,8 +3076,8 @@ function apiAddImageFileFromSource(req, res, next) {
                         'image file size exceeds the maximum allowed size, %s',
                         constants.MAX_IMAGE_SIZE_STR)));
                 }
-                shasum.update(chunk, 'binary');
-                md5sum.update(chunk, 'binary');
+                shasum.update(chunk);
+                md5sum.update(chunk);
             });
             stream.on('end', function () {
                 req.log.trace('req "end" event');
@@ -3106,6 +3106,186 @@ function apiAddImageFileFromSource(req, res, next) {
 }
 
 
+function apiAddImageFileFromUrl(req, res, next) {
+
+    req.log.debug({image: req._image}, 'apiAddImageFileFromUrl: start');
+
+    // Can't change files on an activated image.
+    if (req._image.activated) {
+        return next(new errors.ImageFilesImmutableError(req._image.uuid));
+    }
+
+    var sha1, expectedSha1;
+    if (req.query.sha1) {
+        expectedSha1 = req.query.sha1;
+    }
+    var compression = req.query.compression;
+
+    if (!compression) {
+        return next(new errors.InvalidParameterError('missing "compression"',
+            [ { field: 'compression', code: 'Missing' } ]));
+    } else if (constants.VALID_FILE_COMPRESSIONS.indexOf(compression) === -1) {
+        return next(new errors.InvalidParameterError(
+            format('invalid compression "%s" (must be one of %s)',
+                compression, constants.VALID_FILE_COMPRESSIONS.join(', ')),
+            [ { field: 'compression', code: 'Invalid' } ]));
+    }
+
+    var fileUrl = req.body.file_url;
+    if (fileUrl === undefined) {
+        return next(new errors.InvalidParameterError(
+            'missing "file_url" field from request body',
+            [ {field: 'file_url', code: 'Missing'} ]));
+    }
+
+    if (fileUrl.indexOf('https:') !== 0) {
+        return next(new errors.InvalidParameterError(
+            'Only URLs using the https: scheme are supported',
+            [ {field: 'file_url', code: 'Invalid'} ]));
+    }
+
+    /*
+     * Node's default HTTP timeout is two minutes, and this request can take
+     * longer than that to complete.  Set this connection's timeout to an hour
+     * to avoid an abrupt close after two minutes.
+     */
+    req.connection.setTimeout(60 * 60 * 1000);
+
+    // Validate requested storage. Only admin requests are allowed to specify.
+    var preferredStorage = req.query.storage;
+    if (preferredStorage && req.query.account) {
+        var error = {
+            field: 'storage',
+            code: 'NotAllowed',
+            message: 'Parameter cannot be specified by non-operators'
+        };
+        return next(new errors.InvalidParameterError(
+            format('invalid storage "%s"', preferredStorage), [error]));
+    } else if (preferredStorage) {
+        if (constants.VALID_STORAGES.indexOf(preferredStorage) === -1) {
+            return next(new errors.InvalidParameterError(
+                format('invalid storage "%s" (must be one of %s)',
+                    preferredStorage, constants.VALID_STORAGES.join(', ')),
+                [ { field: 'storage', code: 'Invalid' } ]));
+        }
+    }
+
+    var size = 0;
+    var stor;  // the storage class
+    function finish_(err, tmpFilename, filename) {
+        if (err) {
+            req.log.info('Error during image file addition', err);
+            return next(err);
+        }
+
+        if (size === 0) {
+            return next(new errors.DownloadError(
+                'image file size is 0 bytes, empty files are not allowed'));
+        }
+        if (size > constants.MAX_IMAGE_SIZE) {
+            return next(new errors.DownloadError(format(
+                'image file size, %s, exceeds the maximum allowed file ' +
+                'size, %s', size, constants.MAX_IMAGE_SIZE_STR)));
+        }
+
+        sha1 = shasum.digest('hex');
+        if (expectedSha1 && expectedSha1 !== sha1) {
+            return next(new errors.DownloadError(format(
+                'expected sha1 hash, %s, does not match the uploaded ' +
+                'file sha1 hash, %s', expectedSha1, sha1)));
+        }
+
+        var file = {
+            sha1: sha1,
+            size: size,
+            contentMD5: md5sum.digest('base64'),
+            mtime: (new Date()).toISOString(),
+            stor: stor.type,
+            compression: compression
+        };
+        if (req.query.dataset_guid) {
+            file.dataset_guid = req.query.dataset_guid;
+        }
+
+        // Passing some vars onto `finishMoveImageFile`.
+        req.file = file;
+        req.storage = stor.type;
+        req.tmpFilename = tmpFilename;
+        req.filename = filename;
+
+        return next();
+    }
+    var finish = once(finish_);
+
+    size = 0;
+    var shasum = crypto.createHash('sha1');
+    var md5sum = crypto.createHash('md5');
+    // Add a user-agent header. For for node 4.x, that means parsing the URL
+    // and adding its constituents to an options object since we can't pass
+    // the URL and then add additional options to the request.
+    var parsedUrl = url.parse(fileUrl);
+    var getOptions = {
+        headers: {
+            'User-Agent': req._app.serverName
+        },
+        hostname: parsedUrl.hostname,
+        path: parsedUrl.path,
+        port: parsedUrl.port,
+        protocol: parsedUrl.protocol
+    };
+
+    https.get(getOptions, function getRemoteImageFile(response) {
+
+        // stor.storeFileFromStream requires a paused stream
+        response.pause();
+
+        // Limitation: we don't support HTTP 30x redirects yet.
+        if (response.statusCode !== 200) {
+            return next(new errors.DownloadError(
+                format(
+                    'HTTP %s error attempting to download image',
+                    response.statusCode)));
+        }
+
+        response.on('data', function (chunk) {
+            size += chunk.length;
+            if (size > constants.MAX_IMAGE_SIZE) {
+                finish(new errors.UploadError(format(
+                    'image file size exceeds the maximum allowed size, %s',
+                    constants.MAX_IMAGE_SIZE_STR)));
+            }
+            shasum.update(chunk);
+            md5sum.update(chunk);
+        });
+        response.on('end', function () {
+            req.log.trace('req "end" event');
+        });
+        response.on('close', function () {
+            req.log.trace('req "close" event');
+        });
+
+        stor = req._app.chooseStor(req._image, preferredStorage);
+        stor.storeFileFromStream({
+            image: req._image,
+            stream: response,
+            reqId: req.id(),
+            filename: 'file0'
+        }, function (sErr, tmpFilename, filename) {
+            if (sErr) {
+                req.log.error(sErr, 'error storing image file');
+                finish(errors.parseErrorFromStorage(
+                    sErr, 'error receiving image file'));
+            } else {
+                finish(null, tmpFilename, filename);
+            }
+        });
+    }).on('error', function (e) {
+        return next(new errors.DownloadError(
+            'Error getting image: ' + e));
+    });
+}
+
+
 /**
  * Complete the AddImageFile[FromSource] endpoint by moving the image file
  * into its final (non-tmp) place.
@@ -3336,8 +3516,8 @@ function apiAddImageIcon(req, res, next) {
                 'icon size exceeds the maximum allowed size, %s',
                 constants.MAX_ICON_SIZE_STR)));
         }
-        shasum.update(chunk, 'binary');
-        md5sum.update(chunk, 'binary');
+        shasum.update(chunk);
+        md5sum.update(chunk);
     });
     req.on('end', function () {
         req.log.trace('req "end" event');
@@ -4646,6 +4826,17 @@ function mountApi(server, app, reqAuth, reqPassiveAuth) {
         apiAddImageFileFromSource,
         reqGetImage,    // reload the image after a long running function
         finishMoveImageFile);
+    server.post(
+        {path: '/images/:uuid/file/from-url', name: 'AddImageFileFromUrl'},
+        reqAuth,
+        reqValidUuid,
+        channels.reqChannel,
+        reqGetImage,    // add `req._image`, ensure access
+        reqEnsureAccountIsImageOwner,
+        restify.bodyParser({mapParams: false}),
+        apiAddImageFileFromUrl,
+        reqGetImage,    // reload the image after a long running function
+        finishMoveImageFile);
     server.get(
         {path: '/images/:uuid/file', name: 'GetImageFile'},
         reqValidUuid,
diff --git a/package.json b/package.json
index 2a427e8..97dd340 100644
--- a/package.json
+++ b/package.json
@@ -1,7 +1,7 @@
 {
   "name": "imgapi",
-  "description": "Image API to manage images for SDC 7",
-  "version": "4.5.2",
+  "description": "Image API to manage images for Triton Data Center",
+  "version": "4.6.0",
   "author": "Joyent (joyent.com)",
   "private": true,
   "dependencies": {
