From ca6103382908127225e2daaf3783fa8b5f69a9a1 Mon Sep 17 00:00:00 2001
From: Tim Foster <tim.foster@joyent.com>
Date: Mon, 5 Nov 2018 09:56:29 -0800
Subject: [PATCH] TRITON-774 imgapi should allow admin-only add-file from URLs

---
 CHANGES.md                                |   5 +
 docs/index.md                             | 104 +++++++++-
 docs/operator-guide.md                    |  27 ++-
 lib/images.js                             | 221 +++++++++++++++++++++-
 package.json                              |   4 +-
 tools/prepare-image/windows-prepare-image | 153 +++++++++++++++
 6 files changed, 500 insertions(+), 14 deletions(-)
 create mode 100644 tools/prepare-image/windows-prepare-image

diff --git a/CHANGES.md b/CHANGES.md
index 24f7bfd..c54e93c 100644
--- a/CHANGES.md
+++ b/CHANGES.md
@@ -1,5 +1,10 @@
 # IMGAPI changelog
 
+## 4.6.0
+
+- TRITON-774 imgapi should allow admin-only file-add from URLs, adds a new
+  AddImageFileFromUrl endpoint /images/:uuid/file/from-url (POST).
+
 ## 4.5.2
 
 - TRITON-682 imgapi support for requirements.bootrom
diff --git a/docs/index.md b/docs/index.md
index e03368e..1687805 100644
--- a/docs/index.md
+++ b/docs/index.md
@@ -108,6 +108,7 @@ A summary of fields (details are provided below):
 | [requirements.max_ram](#manifest-requirementsmax_ram)           | Integer | No                            | Yes      | Maximum RAM (in MiB) this image may be provisioned with.                                                                                                                                        |
 | [requirements.min_platform](#manifest-requirementsmin_platform) | Object  | No                            | Yes      | Minimum platform requirement for provisioning with this image.                                                                                                                                  |
 | [requirements.max_platform](#manifest-requirementsmax_platform) | Object  | No                            | Yes      | Maximum platform requirement for provisioning with this image.                                                                                                                                  |
+| [requirements.bootrom](#manifest-requirementsbootrom)           | String  | No                            | Yes      | Bootrom image to use with this image.                                                                                                                                  |
 | [users](#manifest-users)                                        | Array   | No                            | Yes      | A list of users for which passwords should be generated for provisioning. This may only make sense for some images. Example: `[{"name": "root"}, {"name": "admin"}]`                            |
 | [billing_tags](#manifest-billing_tags)                          | Array   | No                            | Yes      | A list of tags that can be used by operators for additional billing processing.                                                                                                                 |
 | [traits](#manifest-traits)                                      | Object  | No                            | Yes      | An object that defines a collection of properties that is used by other APIs to evaluate where should customer VMs be placed.                                                                   |
@@ -513,6 +514,12 @@ then:
    *allow* in the face of ambiguity.
 
 
+## Manifest: requirements.bootrom
+
+Optional. `bootrom` defines the boot ROM image to use. May take values `"bios"`
+or `"uefi"`. Only valid when `brand` is `bhyve`.
+
+
 ## Manifest: users
 
 Optional. `users` is a list of users for which passwords should be generated
@@ -615,26 +622,27 @@ and relevant for images in an IMGAPI server that uses [channels](#channels).
 | [DeleteImage](#DeleteImage)                       | DELETE /images/:uuid                                       | Delete an image (and its file).                                               |
 | [CreateImage](#CreateImage)                       | POST /images                                               | Create a new (unactivated) image from a manifest.                             |
 | [AddImageFile](#AddImageFile)                     | PUT /images/:uuid/file                                     | Upload the image file.                                                        |
+| [AddImageFileFromUrl](#AddImageFileFromUrl)       | POST /images/:uuid/file/from-url                           | Upload the image file using a URL source.                                     |
 | [ActivateImage](#ActivateImage)                   | POST /images/:uuid?action=activate                         | Activate the image.                                                           |
 | [UpdateImage](#UpdateImage)                       | POST /images/:uuid?action=update                           | Update image manifest fields. This is limited. Some fields are immutable.     |
 | [DisableImage](#DisableImage)                     | POST /images/:uuid?action=disable                          | Disable the image.                                                            |
 | [EnableImage](#EnableImage)                       | POST /images/:uuid?action=enable                           | Enable the image.                                                             |
 | [AddImageAcl](#AddImageAcl)                       | POST /images/:uuid/acl?action=add                          | Add account UUIDs to the image ACL.                                           |
 | [RemoveImageAcl](#RemoveImageAcl)                 | POST /images/:uuid/acl?action=remove                       | Remove account UUIDs from the image ACL.                                      |
-| [CloneImage](#CloneImage)                         | POST /images/:uuid/clone                                   | Clone this image.
+| [CloneImage](#CloneImage)                         | POST /images/:uuid/clone                                   | Clone this image.                                                             |
 | [AddImageIcon](#AddImageIcon)                     | POST /images/:uuid/icon                                    | Add the image icon.                                                           |
 | [GetImageIcon](#GetImageIcon)                     | GET /images/:uuid/icon                                     | Get the image icon file.                                                      |
 | [DeleteImageIcon](#DeleteImageIcon)               | DELETE /images/:uuid/icon                                  | Remove the image icon.                                                        |
 | [CreateImageFromVm](#CreateImageFromVm)           | POST /images?action=create-from-vm                         | Create a new (activated) image from an existing VM.                           |
 | [ExportImage](#ExportImage)                       | POST /images/:uuid?action=export                           | Exports an image to the specified Manta path.                                 |
-| [ImportFromDatacenter](#ImportFromDatacenter)     | POST /images/$uuid?action=import-from-datacenter&datacenter=us-west-1  | Copy one's own image from another datacenter in the same cloud.  |
+| [ImportFromDatacenter](#ImportFromDatacenter)     | POST /images/$uuid?action=import-from-datacenter&datacenter=us-west-1  | Copy one's own image from another datacenter in the same cloud.   |
 | [AdminImportRemoteImage](#AdminImportRemoteImage) | POST /images/$uuid?action=import-remote&source=$imgapi-url | Import an image from another IMGAPI                                           |
 | [AdminImportImage](#AdminImportImage)             | POST /images/$uuid?action=import                           | Only for operators to import an image and maintain `uuid` and `published_at`. |
 | [AdminGetState](#AdminGetState)                   | GET /state                                                 | Dump internal server state (for dev/debugging)                                |
 | [ListChannels](#ListChannels)                     | GET /channels                                              | List image channels (if the server uses channels).                            |
 | [ChannelAddImage](#ChannelAddImage)               | POST /images/:uuid?action=channel-all                      | Add an existing image to another channel.                                     |
 | [Ping](#Ping)                                     | GET /ping                                                  | Ping if the server is up.                                                     |
-| [AdminReloadAuthKeys](#AdminReloadAuthKeys)       | POST /authkeys/reload                                          | (Added in v2.3.0.) Tell server to reload its auth keys. This is only relevant for servers using HTTP Signature auth. |
+| [AdminReloadAuthKeys](#AdminReloadAuthKeys)       | POST /authkeys/reload                                      | (Added in v2.3.0.) Tell server to reload its auth keys. This is only relevant for servers using HTTP Signature auth. |
 
 
 
@@ -1439,6 +1447,95 @@ CLI tool:
     Added file "file.bz2" to image 25ab9ddf-96e8-4157-899d-1dc8be7b9810
 
 
+## AddImageFileFromUrl (POST /images/:uuid/file/from-url)
+
+Almost identical to the AddImageFile PUT method, this POST method allows users
+to specify a URL from which the imgapi instance should retrieve the image file.
+
+HTTPS is the only scheme supported by this method. Note that as URLs are
+typically quite long, the URL is passed in the body of the POST.
+
+If the image already has a file, it will be overwritten. A file can only
+be added to an image that has not yet been activated. The typical process
+is to call this after [CreateImage](#CreateImage), and then subsequently
+call [ActivateImage](#ActivateImage) to make the image available
+for provisioning, `state == "active"`.
+
+### Inputs
+
+| Field                          | Type       | Required? | Notes                                                                                                                                                                                                                                                                                                                                              |
+| ------------------------------ | ---------- | --------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
+| account (query param)          | UUID       | No        | The account UUID on behalf of whom this request is being made. If given and if relevant, authorization will be done for this account. It is expected that all calls originating from a user (e.g. from cloudapi) will provide this parameter.                                                                                                      |
+| channel (query param)          | String     | No        | The image channel to use. (Only relevant for servers using [channels](#channels).)                                                                                                                                                                                                                                                                 |
+| storage                        | String     | No        | The type of storage preferred for this image file. Storage can only be specified if the request is being made by an operator. The only two possible values for storage are **local** and **manta**. When the request is made on behalf of a customer then IMGAPI will try to use manta as the storage backend, otherwise default to local storage. |
+| [compression](#manifest-files) | UUID       | Yes       | The type of compression used for the file content. One of 'none', 'gzip' or 'bzip2'.                                                                                                                                                                                                                                                               |
+| [sha1](#manifest-files)        | SHA-1 Hash | No        | SHA-1 of the uploaded file to allow the server to check for data corruption.                                                                                                                                                                                                                                                                       |
+| dataset_guid                   | GUID       | No        | The ZFS internal unique identifier for this dataset's snapshot (available via `zfs get guid SNAPSHOT`, e.g. `zfs get guid zones/f669428c-a939-11e2-a485-b790efc0f0c1@final`). If available, this is used to ensure a common base snapshot for incremental images (via `imgadm create -i`) and VM migrations (via `vmadm send/receive`).            |
+| file_url (body)                | String     | Yes       | A URL to the image file. HTTPS is the only supported URL scheme, and the HTTPS server must not use self-signed certificates.                                                                                                                                                                                                                       |
+
+### Returns
+
+The updated image object.
+
+### Errors
+
+See [Errors](#errors) section above.
+
+### Example
+
+Raw API tool (against an SDC's IMGAPI).
+
+    $ sdc-imgapi '/images/2d74d0fb-8402-4e10-a145-86864b14bca7/file/from-url?compression=gzip&sha1=e6a828afa242ecad289f3114e6e2856ef2404a48' -X POST \
+    -d '{"file_url": "https://us-east.manta.joyent.com/timf/public/builds/assets/master-20180925T100358Z-g3f3d1b8/assets/assets-zfs-master-20180925T100358Z-g3f3d1b8.zfs.gz"}'
+    HTTP/1.1 200 OK
+    Etag: 824d644a739bb659b86c24316864d7f56438d696
+    Content-Type: application/json
+    Content-Length: 646
+    Date: Mon, 01 Oct 2018 11:09:47 GMT
+    Server: imgapi/4.6.0
+    x-request-id: 4fc4c29f-b568-408e-8019-54f0393b9025
+    x-response-time: 162167
+    x-server-name: 9b76732a-a75b-4ca5-b1a5-732974733639
+    Connection: keep-alive
+
+    {
+      "v": 2,
+      "uuid": "2d74d0fb-8402-4e10-a145-86864b14bca7",
+      "owner": "930896af-bf8c-48d4-885c-6573a94b1853",
+      "name": "assets",
+      "version": "master-20180925T100358Z-g3f3d1b8",
+      "state": "unactivated",
+      "disabled": false,
+      "public": false,
+      "type": "zone-dataset",
+      "os": "smartos",
+      "files": [
+        {
+          "sha1": "e6a828afa242ecad289f3114e6e2856ef2404a48",
+          "size": 69223039,
+          "compression": "gzip"
+        }
+      ],
+      "description": "SDC Assets",
+      "requirements": {
+        "min_platform": {
+          "7.0": "20180830T001556Z"
+        }
+      },
+      "origin": "04a48d7d-6bb5-4e83-8c3b-e60a99e0f48f",
+      "tags": {
+        "smartdc_service": true
+      }
+    }
+
+CLI tool:
+
+    $ sdc-imgadm add-file -s e6a828afa242ecad289f3114e6e2856ef2404a48 --url \
+        -f https://us-east.manta.joyent.com//timf/public/builds/assets/master-20180925T100358Z-g3f3d1b8/assets/assets-zfs-master-20180925T100358Z-g3f3d1b8.zfs.gz \
+        2d74d0fb-8402-4e10-a145-86864b14bca7
+    Added file from url "https://us-east.manta.joyent.com//timf/public/builds/assets/master-20180925T100358Z-g3f3d1b8/assets/assets-zfs-master-20180925T100358Z-g3f3d1b8.zfs.gz" (compression "auto detected") to image 2d74d0fb-8402-4e10-a145-86864b14bca7
+
+
 ## AddImageIcon (PUT /images/:uuid/icon)
 
 Add the image icon. If the image already has an icon file, it will be overwritten.
@@ -2140,7 +2237,6 @@ CLI tool:
     Imported image 84cb7edc-3f22-11e2-8a2a-3f2a7b148699 (base, 1.8.4, state=active)
 
 
-
 ## AdminImportDockerImage (POST /images?action=import-docker-image)
 
 Import an image from a *Docker* repository. This endpoint maintains an open
diff --git a/docs/operator-guide.md b/docs/operator-guide.md
index 429ba85..be5c7d8 100644
--- a/docs/operator-guide.md
+++ b/docs/operator-guide.md
@@ -472,6 +472,7 @@ For example: if providing `manta`, one must provide the whole `manta` object.
 | wfapi.url                    | String        | -                 | The Workflow API URL. |
 | wfapi.workflows              | String        | -                 | Array of workflows to load. |
 | wfapi.forceReplace           | Boolean       | -                 | Whether to replace all workflows loaded every time the IMGAPI service is started. Ideal for development environments |
+| imgapiUrlFromDatacenter      | Object        | -                 | The mapping of short dc name to the imgapi admin url, which an image in this imgapi can be copied to. This can also be set using [SAPI Configuration](#sapi-configuration). |
 
 For operational scripts, development, and debugging, one can look at the full
 merged and computed config by calling "lib/config.js" as a script. This should
@@ -509,7 +510,7 @@ authoritative details.
 | IMGAPI_MANTA_\*                         | various | -       | These are typically setup by the `imgapi[-external]-manta-setup` scripts. See the [DC-mode setup: connect to Manta](#dc-mode-setup-connect-to-manta) section |
 | docker_registry_insecure                | Boolean | false   | See <https://github.com/joyent/triton/blob/master/docs/operator-guide/configuration.md#sdc-application-configuration> |
 | http_proxy                              | String  | -       | See <https://github.com/joyent/triton/blob/master/docs/operator-guide/configuration.md#sdc-application-configuration> |
-
+| IMGAPI_URL_FROM_DATACENTER              | Object  | -       | See [x-DC Image Copying](#x-dc-image-copying) description. |
 
 ## Standalone Setup Configuration
 
@@ -529,6 +530,30 @@ These are called "setup config vars". At time of writing they are (see
 | mantaBaseDir | manta.baseDir |
 | channels     | channels; This may also by the special value `standard`, which will be substituted by the "standard" channels (a set of channels used by updates.joyent.com). |
 
+## x-DC Image Copying
+
+It is possible to configure IMGAPI to allow users to copy images from one
+datacenter to another.
+
+To be able to use x-DC image copying, each datacenter must have SAPI
+configuration, which will specify the IMGAPI endpoints that a datacenter is
+allowed to copy into.
+
+The configuration will be a JSON object, which contains a mapping of the dc
+short name or the IMGAPI **admin** url where IMGAPI is listening. Note that the
+short dc name should match what is shown via:
+[CloudAPI ListDatacenters](https://apidocs.joyent.com/cloudapi/#ListDatacenters).
+
+For example, to allow us-east-1 to copy images into both us-sw-1 and us-west-1
+you would run the following SAPI configuration command:
+
+    $ login to us-east-1 headnode
+    $ SAPI_IMGAPI_UUID=$(sdc-sapi /services?name=imgapi | json -Hga uuid)
+    $ echo '{ "metadata": { "IMGAPI_URL_FROM_DATACENTER": { "us-sw-1": "http://10.2.15.22", "us-west-1": "http://10.2.18.8" }}}' | \
+        sapiadm update "$SAPI_IMGAPI_UUID"
+
+Then restart config-agent in the imgapi zone (or wait until imgapi notices the
+config has changed, at which point imgapi will then restart itself).
 
 # Storage
 
diff --git a/lib/images.js b/lib/images.js
index 87d0600..15c1b0c 100644
--- a/lib/images.js
+++ b/lib/images.js
@@ -22,6 +22,7 @@ var path = require('path');
 
 var assert = require('assert-plus');
 var async = require('async');
+var https = require('https');
 var imgmanifest = require('imgmanifest');
 var lib_uuid = require('uuid');
 var once = require('once');
@@ -51,6 +52,8 @@ var TOP = path.resolve(__dirname, '..');
 var UUID_RE = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/;
 var ICON_CONTENT_TYPES = ['image/jpeg', 'image/gif', 'image/png'];
 
+// new images cannot be created from KVM windows origins older than this date
+var MIN_AGE_KVM_WIND_IMG = '2018-10-15';
 
 //---- Image model
 
@@ -1311,7 +1314,6 @@ Image.filter = function filterImages(app, options, log, callback) {
 };
 
 
-
 //---- API controllers
 
 /**
@@ -2025,7 +2027,21 @@ function apiCreateImageFromVm(req, res, callback) {
                 if (getErr) {
                     return next(getErr);
                 }
+
                 var os = protoImage.os;
+                var brand = protoImage.requirements &&
+                    protoImage.requirements.brand;
+                var published = protoImage.published_at &&
+                    protoImage.published_at.toISOString();
+
+                if (brand === 'kvm' && os === 'windows' && published &&
+                    published < MIN_AGE_KVM_WIND_IMG) {
+                    return next(new errors.NotAvailableError(format(
+                        'image creation for OS "windows" is not supported ' +
+                        'for KVM images older than %s (VM %s, origin image %s)',
+                        MIN_AGE_KVM_WIND_IMG, vm.uuid, protoImageUuid)));
+                }
+
                 var prepareImagePath = path.join(TOP, 'tools', 'prepare-image',
                     os + '-prepare-image');
                 fs.exists(prepareImagePath, function (exists) {
@@ -2861,8 +2877,8 @@ function apiAddImageFile(req, res, next) {
                 'image file size exceeds the maximum allowed size, %s',
                 constants.MAX_IMAGE_SIZE_STR)));
         }
-        shasum.update(chunk, 'binary');
-        md5sum.update(chunk, 'binary');
+        shasum.update(chunk);
+        md5sum.update(chunk);
     });
     req.on('end', function () {
         req.log.trace('req "end" event');
@@ -3076,8 +3092,8 @@ function apiAddImageFileFromSource(req, res, next) {
                         'image file size exceeds the maximum allowed size, %s',
                         constants.MAX_IMAGE_SIZE_STR)));
                 }
-                shasum.update(chunk, 'binary');
-                md5sum.update(chunk, 'binary');
+                shasum.update(chunk);
+                md5sum.update(chunk);
             });
             stream.on('end', function () {
                 req.log.trace('req "end" event');
@@ -3106,6 +3122,186 @@ function apiAddImageFileFromSource(req, res, next) {
 }
 
 
+function apiAddImageFileFromUrl(req, res, next) {
+
+    req.log.debug({image: req._image}, 'apiAddImageFileFromUrl: start');
+
+    // Can't change files on an activated image.
+    if (req._image.activated) {
+        return next(new errors.ImageFilesImmutableError(req._image.uuid));
+    }
+
+    var sha1, expectedSha1;
+    if (req.query.sha1) {
+        expectedSha1 = req.query.sha1;
+    }
+    var compression = req.query.compression;
+
+    if (!compression) {
+        return next(new errors.InvalidParameterError('missing "compression"',
+            [ { field: 'compression', code: 'Missing' } ]));
+    } else if (constants.VALID_FILE_COMPRESSIONS.indexOf(compression) === -1) {
+        return next(new errors.InvalidParameterError(
+            format('invalid compression "%s" (must be one of %s)',
+                compression, constants.VALID_FILE_COMPRESSIONS.join(', ')),
+            [ { field: 'compression', code: 'Invalid' } ]));
+    }
+
+    var fileUrl = req.body.file_url;
+    if (fileUrl === undefined) {
+        return next(new errors.InvalidParameterError(
+            'missing "file_url" field from request body',
+            [ {field: 'file_url', code: 'Missing'} ]));
+    }
+
+    if (fileUrl.indexOf('https:') !== 0) {
+        return next(new errors.InvalidParameterError(
+            'Only URLs using the https: scheme are supported',
+            [ {field: 'file_url', code: 'Invalid'} ]));
+    }
+
+    /*
+     * Node's default HTTP timeout is two minutes, and this request can take
+     * longer than that to complete.  Set this connection's timeout to an hour
+     * to avoid an abrupt close after two minutes.
+     */
+    req.connection.setTimeout(60 * 60 * 1000);
+
+    // Validate requested storage. Only admin requests are allowed to specify.
+    var preferredStorage = req.query.storage;
+    if (preferredStorage && req.query.account) {
+        var error = {
+            field: 'storage',
+            code: 'NotAllowed',
+            message: 'Parameter cannot be specified by non-operators'
+        };
+        return next(new errors.InvalidParameterError(
+            format('invalid storage "%s"', preferredStorage), [error]));
+    } else if (preferredStorage) {
+        if (constants.VALID_STORAGES.indexOf(preferredStorage) === -1) {
+            return next(new errors.InvalidParameterError(
+                format('invalid storage "%s" (must be one of %s)',
+                    preferredStorage, constants.VALID_STORAGES.join(', ')),
+                [ { field: 'storage', code: 'Invalid' } ]));
+        }
+    }
+
+    var size = 0;
+    var stor;  // the storage class
+    function finish_(err, tmpFilename, filename) {
+        if (err) {
+            req.log.info('Error during image file addition', err);
+            return next(err);
+        }
+
+        if (size === 0) {
+            return next(new errors.DownloadError(
+                'image file size is 0 bytes, empty files are not allowed'));
+        }
+        if (size > constants.MAX_IMAGE_SIZE) {
+            return next(new errors.DownloadError(format(
+                'image file size, %s, exceeds the maximum allowed file ' +
+                'size, %s', size, constants.MAX_IMAGE_SIZE_STR)));
+        }
+
+        sha1 = shasum.digest('hex');
+        if (expectedSha1 && expectedSha1 !== sha1) {
+            return next(new errors.DownloadError(format(
+                'expected sha1 hash, %s, does not match the uploaded ' +
+                'file sha1 hash, %s', expectedSha1, sha1)));
+        }
+
+        var file = {
+            sha1: sha1,
+            size: size,
+            contentMD5: md5sum.digest('base64'),
+            mtime: (new Date()).toISOString(),
+            stor: stor.type,
+            compression: compression
+        };
+        if (req.query.dataset_guid) {
+            file.dataset_guid = req.query.dataset_guid;
+        }
+
+        // Passing some vars onto `finishMoveImageFile`.
+        req.file = file;
+        req.storage = stor.type;
+        req.tmpFilename = tmpFilename;
+        req.filename = filename;
+
+        return next();
+    }
+    var finish = once(finish_);
+
+    size = 0;
+    var shasum = crypto.createHash('sha1');
+    var md5sum = crypto.createHash('md5');
+    // Add a user-agent header. For for node 4.x, that means parsing the URL
+    // and adding its constituents to an options object since we can't pass
+    // the URL and then add additional options to the request.
+    var parsedUrl = url.parse(fileUrl);
+    var getOptions = {
+        headers: {
+            'User-Agent': req._app.serverName
+        },
+        hostname: parsedUrl.hostname,
+        path: parsedUrl.path,
+        port: parsedUrl.port,
+        protocol: parsedUrl.protocol
+    };
+
+    https.get(getOptions, function getRemoteImageFile(response) {
+
+        // stor.storeFileFromStream requires a paused stream
+        response.pause();
+
+        // Limitation: we don't support HTTP 30x redirects yet.
+        if (response.statusCode !== 200) {
+            return next(new errors.DownloadError(
+                format(
+                    'HTTP %s error attempting to download image',
+                    response.statusCode)));
+        }
+
+        response.on('data', function (chunk) {
+            size += chunk.length;
+            if (size > constants.MAX_IMAGE_SIZE) {
+                finish(new errors.UploadError(format(
+                    'image file size exceeds the maximum allowed size, %s',
+                    constants.MAX_IMAGE_SIZE_STR)));
+            }
+            shasum.update(chunk);
+            md5sum.update(chunk);
+        });
+        response.on('end', function () {
+            req.log.trace('req "end" event');
+        });
+        response.on('close', function () {
+            req.log.trace('req "close" event');
+        });
+
+        stor = req._app.chooseStor(req._image, preferredStorage);
+        stor.storeFileFromStream({
+            image: req._image,
+            stream: response,
+            reqId: req.id(),
+            filename: 'file0'
+        }, function (sErr, tmpFilename, filename) {
+            if (sErr) {
+                req.log.error(sErr, 'error storing image file');
+                finish(errors.parseErrorFromStorage(
+                    sErr, 'error receiving image file'));
+            } else {
+                finish(null, tmpFilename, filename);
+            }
+        });
+    }).on('error', function (e) {
+        return next(new errors.DownloadError(
+            'Error getting image: ' + e));
+    });
+}
+
+
 /**
  * Complete the AddImageFile[FromSource] endpoint by moving the image file
  * into its final (non-tmp) place.
@@ -3336,8 +3532,8 @@ function apiAddImageIcon(req, res, next) {
                 'icon size exceeds the maximum allowed size, %s',
                 constants.MAX_ICON_SIZE_STR)));
         }
-        shasum.update(chunk, 'binary');
-        md5sum.update(chunk, 'binary');
+        shasum.update(chunk);
+        md5sum.update(chunk);
     });
     req.on('end', function () {
         req.log.trace('req "end" event');
@@ -4646,6 +4842,17 @@ function mountApi(server, app, reqAuth, reqPassiveAuth) {
         apiAddImageFileFromSource,
         reqGetImage,    // reload the image after a long running function
         finishMoveImageFile);
+    server.post(
+        {path: '/images/:uuid/file/from-url', name: 'AddImageFileFromUrl'},
+        reqAuth,
+        reqValidUuid,
+        channels.reqChannel,
+        reqGetImage,    // add `req._image`, ensure access
+        reqEnsureAccountIsImageOwner,
+        restify.bodyParser({mapParams: false}),
+        apiAddImageFileFromUrl,
+        reqGetImage,    // reload the image after a long running function
+        finishMoveImageFile);
     server.get(
         {path: '/images/:uuid/file', name: 'GetImageFile'},
         reqValidUuid,
diff --git a/package.json b/package.json
index 2a427e8..97dd340 100644
--- a/package.json
+++ b/package.json
@@ -1,7 +1,7 @@
 {
   "name": "imgapi",
-  "description": "Image API to manage images for SDC 7",
-  "version": "4.5.2",
+  "description": "Image API to manage images for Triton Data Center",
+  "version": "4.6.0",
   "author": "Joyent (joyent.com)",
   "private": true,
   "dependencies": {
diff --git a/tools/prepare-image/windows-prepare-image b/tools/prepare-image/windows-prepare-image
new file mode 100644
index 0000000..ba689c6
--- /dev/null
+++ b/tools/prepare-image/windows-prepare-image
@@ -0,0 +1,153 @@
+# This Source Code Form is subject to the terms of the Mozilla Public
+# License, v. 2.0. If a copy of the MPL was not distributed with this
+# file, You can obtain one at http://mozilla.org/MPL/2.0/.
+#
+# Copyright (c) 2018, Joyent, Inc.
+#
+# Set Window's cleanmgr to (nearly) max, and run it. This cleans up most
+# temporary (files, cache) and unneeded data (outdated installation data).
+#
+# In order for this script to work, a Windows image needs to have mdata-get.exe,
+# mdata-put.exe and prepare_image_runner.ps1 installed in C:\smartdc\bin, and
+# prepare_image_runner.ps1 should be run by Windows on every boot. Upon boot,
+# prepare_image_runner.ps1 will then check if "sdc:operator-script" metadata
+# (seen as internal_metadata."operator-script" in "vmadm get" output) is present
+# over COM2, and run it. If it's not present, booting continues as normal.
+#
+# Apparently, the only way to get cleanmgr to run without displaying a final
+# information dialog -- thus hanging image creation -- is through the /autoclean
+# flag. We abuse this by setting all available cleanup options in the registry
+# to be run by autoclean. Since the VM will be rolled back after image creation,
+# this change is not a problem.
+#
+# There are also a couple very expensive cleanmgr checks that increase
+# cleanmgr's run time up to 5x, which we cannot afford with the 5m time limit
+# imposed on image creation between prepare-script 'running' and
+# final 'error'/'success' calls. The only way to disable these checks outright
+# is to temporarily move their registry keys, which we do as well.
+#
+# After that, cleanmgr is run, then moving the expensive registry keys back.
+#
+# Unfortunately, cleanmgr /autoclean appears to contain its own logic about when
+# it will clean up something. As a result, we also empty recycle bins and clear
+# most temp and log directories manually.
+
+$parent_path = 'HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\VolumeCaches'
+$tmp_parent_path = 'HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer'
+$expensive_cleanups = 'Update Cleanup', 'System error memory dump files'
+$clean_dirs = 'c:\Windows\Temp\*', 'c:\Windows\Logs\*', 'c:\Windows\Minidump\*',
+    'C:\PerfLogs\*', 'C:\Windows\Downloaded Program Files\*',
+    'C:\Windows\*.log', 'C:\Users\*\AppData\Local\Temp\*'
+
+
+function mput($key, $val) {
+    c:\smartdc\bin\mdata-put.exe prepare-image:$key $val
+}
+
+function setting_path($id) {
+    "$parent_path\$id"
+}
+
+function tmp_path($id) {
+    "$tmp_parent_path\$id"
+}
+
+function error($msg) {
+    echo "ERROR"
+    echo $msg
+    mput 'state' 'error'
+    mput 'error' $msg
+    exit
+}
+
+
+echo 'Starting run...'
+mput 'state' 'running'
+
+echo "Disabling particularly expensive cleanmgr operations"
+foreach ($cleanup in $expensive_cleanups) {
+    try {
+        Move-Item -LiteralPath (setting_path $cleanup) `
+            -Destination (tmp_path $cleanup) -ErrorAction Stop
+    } catch [System.Management.Automation.PSInvalidOperationException] {}
+}
+
+echo 'Marking all other checks for /autoclean'
+try {
+    $cleanups = (Get-Item -LiteralPath $parent_path).GetSubKeyNames()
+} catch {
+    error 'Unknown hive'
+}
+
+$add_auto_paths = @()
+try {
+    foreach ($cleanup in $cleanups) {
+        $path = setting_path $cleanup
+        $node = Get-Item -LiteralPath $path
+        if ($node.GetValue('Autorun') -ne 1) {
+            $add_auto_paths = $add_auto_paths + $path
+        }
+    }
+} catch {
+    error 'Bad Get-Item'
+}
+
+try {
+    foreach ($path in $add_auto_paths) {
+        Set-ItemProperty -LiteralPath $path -Name 'Autorun' `
+            -Type Dword -Value 1 -ErrorAction Stop
+    }
+} catch {
+    error 'Bad Set-Item'
+}
+
+echo 'Running cleanmgr...'
+try {
+    # Out-Null needed to block script until cleanmgr completes
+    c:\windows\system32\cleanmgr.exe /autoclean | Out-Null
+} catch [System.Management.Automation.CommandNotFoundException] {
+    # Ignore, in case we are dealing with a 2012r2 instance without
+    # Desktop Experience installed
+} catch {
+    error 'Bad cleanmgr'
+}
+
+echo 'Unmarking other checks /autoclean'
+try {
+    foreach ($path in $add_auto_paths) {
+        Set-ItemProperty -LiteralPath $path -Name 'Autorun' `
+            -Type Dword -Value 0 -ErrorAction Stop
+    }
+} catch {
+    error 'Bad auto undo'
+}
+
+echo 'Reenabling expensive cleanmgr operations'
+foreach ($cleanup in $expensive_cleanups) {
+    try {
+        Move-Item -LiteralPath (tmp_path $cleanup) `
+            -Destination (setting_path $cleanup) -ErrorAction Stop
+    } catch [System.Management.Automation.PSInvalidOperationException] {}
+}
+
+echo 'Empty Recycle Bins'
+try {
+     Clear-RecycleBin -Confirm:$false -ErrorAction Stop
+} catch [System.ComponentModel.Win32Exception],
+        [System.Management.Automation.CommandNotFoundException] {
+    # Ignore, in case we are dealing with a Powershell older than 5.1 on 2012r2.
+    # By default, 2012r2 has Powershell 4.0, but updates can increase it to 5.1
+} catch {
+    error 'Bad empty recycle'
+}
+
+echo 'Clear out temp and log directories'
+foreach ($path in $clean_dirs) {
+    try {
+        Remove-Item -Path $path -Recurse -Force -ErrorAction Stop
+    } catch {}
+}
+
+
+mput 'state' 'success'
+echo 'Done!'
-- 
2.21.0

