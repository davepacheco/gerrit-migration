commit 3e4040b1e717d5cc2e180d2b01a4606e03a32c39
Author: Todd Whiteman <todd.whiteman@joyent.com>
Date:   2019-04-09T08:37:05-07:00 (6 months ago)
    
    TRITON-897 RFD 34 Triton instance migration

diff --git a/docs/index.md b/docs/index.md
index 4a5cff9..83f4729 100644
--- a/docs/index.md
+++ b/docs/index.md
@@ -2248,6 +2248,308 @@ Returns a job with the specified UUID.
       ]
     }
 
+# VM Migration
+
+It is possible to migrate (move a VM) to another CN using these APIs.
+
+VM migration operates in three distinct phases, the *begin* phase creates a
+hidden target placeholder vm for which to migrate into, the *sync* phase will
+synchronize the underlying filesystems and the *switch* phase will shutdown
+the original source vm, perform a final filesystem synchronization, hide the
+original source VM and then enable and restart the target VM.
+
+A migration can be set to run all of these phases in one (automatic migration)
+or these phases can each be run manually (on demand migration).
+
+For any migration action (e.g. begin, sync, switch or abort) you can use the
+migration watch endpoint to show progress information for the running migration
+action.
+
+## VmMigrateList (GET /migrations)
+
+Returns the list of [Migration Objects](#migration-objects).
+
+### Optional Inputs
+
+Param      | Type     | Description
+---------- | -------- | -----------
+format     | String   | Can be set to 'raw' to receive the raw (full) migration objects.
+owner_uuid | UUID     | VM Owner
+state      | String   | Query for migrations in a certain state. Can be one of the defined [Migration States](#migration-states), or "active". The "active" query will return all migrations in one of the states "running", "paused" or "failed".
+
+### VmMigrateList Examples
+
+    GET /migrations
+    GET /migrations?owner_uuid=77118fd1-b0f0-4e72-9d1d-aea57fe8b47c
+    GET /migrations?state=active&format=raw
+
+### Responses
+
+Code | Description   | Response
+---- | ------------- | ------------------
+200  | Successful    | JSON array of [Migration Objects](#migration-objects).
+
+## VmMigrateGet (GET /migrations:uuid)
+
+Returns the list of [Migration Objects](#migration-objects).
+
+### Optional Inputs
+
+Param      | Type     | Description
+---------- | -------- | -----------
+format     | String   | Can be set to 'raw' to receive the raw (full) migration object.
+owner_uuid | UUID     | VM Owner
+
+### VmMigrateGet Examples
+
+    GET /migrations/5ad11be4-605c-4f64-b673-e0920ac0ac64
+    GET /migrations/5ad11be4-605c-4f64-b673-e0920ac0ac64?format=raw&owner_uuid=77118fd1-b0f0-4e72-9d1d-aea57fe8b47c
+
+### Responses
+
+Code | Description   | Response
+---- | ------------- | ------------------
+200  | Successful    | A JSON [Migration Object](#migration-objects).
+
+## VmMigrateEstimate (POST /vms/:uuid?action=migrate&migration_action=estimate)
+
+Get an estimate for how long a migration would take to complete.
+
+### Optional Inputs
+
+Param                | Type     | Description
+-------------------- | -------- | -----------
+owner_uuid           | UUID     | VM Owner
+
+### Responses
+
+Code     | Description                                                                  | Response
+-------- | ---------------------------------------------------------------------------- | ------------------
+200      | OK - estimate was completed.                                                 | [Migration Estimate Object](#migration-estimate-object)
+404      | VM Not Found. VM does not exist or VM does not belong to the specified owner | Error object
+
+#### Migration Estimate Object
+
+Migration objects store the state of a migration operation.
+
+Field                   | Type     | Description
+----------------------- | -------- | ---------------
+size                    | Number   | Number of filesystem bytes that will need to be migrated.
+eta\_ms                 | Number   | Estimate of the number of milliseconds until the task is completed.
+transfer\_bytes\_second | Number   | Estimate for the number of bytes that would be sent per second between the source and target instances during the "sync" phase.
+
+Example:
+
+    {
+      "eta_ms": "3600142",
+      "size": "484302896",
+      "transfer_bytes_second": "10000000"
+    }
+
+## VmMigrate (POST /vms/:uuid?action=migrate&migration_action=ACTION)
+
+Starts the specified migration action.
+
+### Inputs
+
+Param            | Type     | Description
+---------------- | -------- | -----------
+migration_action | String   | One of "begin", "sync", "switch", "pause" or "abort".
+
+### Optional Inputs
+
+Param                | Type     | Description
+-------------------- | -------- | -----------
+migration_automatic  | Boolean  | Use to enable full automatic migration. A full migration will perform begin, multiple syncs and switch.
+owner_uuid           | UUID     | VM Owner
+override_server_uuid | UUID     | Migration target will be provisioned to this server.
+
+### Migrate Begin
+
+The "begin" action starts a workflow job that will create (provision) a target
+vm instance on a different CN that will be used to perform the migration. Once
+a begin job is completed successfully, you can then run the migration sync
+action.
+
+The begin phase will utilize the existing Triton provisioning and allocation
+APIs to ensure proper placement of the migrated VM.
+
+### Migrate Sync
+
+The "sync" action starts a workflow job that will synchronize the filesystems
+between the source and target VMs.
+
+This phase can be run multiple times, with each subsequent sync operation only
+transferring the filesystem differences since the last sync. When two or more
+sync jobs have completed successfully, you can then run migration switch.
+
+### Migrate Switch
+
+The "switch" action starts a workflow job that will switch over control to the
+target (migrated) vm and hide the original source vm.
+
+This phase will shutdown the source vm, perform a final sync, deactivate the
+source vm, then activate the target vm and finally start up the target vm (if
+the source vm was originally running).
+
+### Migrate Pause
+
+This action is only actionable when migration sync is running. It is used to
+stop the migration sync operation and place the migration into a paused state.
+
+### Migrate Abort
+
+This action is only actionable when the migration is paused or failed. It is
+used to abort the migration, removing the target placeholder vm and ensuring the
+source vm is returned to it's original state.
+
+### VmMigrate Response
+
+On a successful response, a [Migration Job Response Object](#migration-job-response-object) is
+returned in the response body and you can use the migration watch endpoint to
+follow the progress of the migration.
+
+Code     | Description                                                                  | Response
+-------- | ---------------------------------------------------------------------------- | ------------------
+202      | New job created                                                              | VM job response object
+404      | VM Not Found. VM does not exist or VM does not belong to the specified owner | Error object
+409      | VM failed to validate.                                                       | Error object
+
+#### Example
+
+    POST /vms/e9bd0ed1-7de3-4c66-a649-d675dbce6e83?action=migrate&migration_action=begin
+
+    HTTP/1.1 202 Accepted
+    Connection: close
+    workflow-api: http://workflow.coal.joyent.us
+    Content-Type: application/json
+    Content-Length: 100
+    Content-MD5: as77tkERx4gj7igpE83PyQ==
+    Date: Mon, 24 Apr 2017 22:30:44 GMT
+    Server: VMAPI
+    x-request-id: d169bbdf-a54c-4f71-a543-8928cda5b152
+    x-response-time: 170
+    x-server-name: d6334b70-2e19-4af4-85ba-53776ef82820
+
+    {
+      "job_uuid": "56aca67a-5374-4117-9817-6ac77060697e",
+      "migration": {
+        ... see (Migration Object)
+      }
+    }
+
+### Migration Job Response Object
+
+Most migration actions on a VM will result in a new Job being created on the
+backend. The job uuid will be returned, along with the migration record itself
+in the response object.
+
+Example:
+
+    {
+      "job_uuid": "6ad3a288-31cf-44e0-8d18-9b3f2a031067",
+      "migration": {
+        "automatic": false,
+        "created_timestamp": "2019-04-02T23:34:30.135Z",
+        "phase": "begin",
+        "state": "running",
+        "vm_uuid": "658e2899-5c9a-4e24-f768-f0d44aed5902",
+        "progress_history": []
+      }
+    }
+
+## Migration Objects
+
+Migration objects store the state of a migration operation.
+
+Field                | Type     | Description
+-------------------- | -------- | ---------------
+vm_uuid              | UUID     | Instance UUID of the instance being migrated.
+automatic            | Boolean  | Whether this migration will run all phases without any user intervention.
+created\_timestamp   | String   | ISO timestamp for the creation of the migration request.
+phase                | String   | Current migration phase - see [Migration Phases](#migration-phases).
+state                | String   | Current migration state - see [Migration States](#migration-states).
+progress\_history    | Array    | An Array of completed JSON progress events - see [Migration Progress Events](#migration-progress-events).
+error                | String   | If a migration fails - this is the error message of why it failed.
+
+### Migration States
+
+The state the migration operation is currently in. It can be one of the
+following states:
+
+State         | Description
+------------- | ----------------
+running       | Migration running, see also `progress_history`.
+paused        | The "begin" phase (and possibly "sync" phase) has been run - now waiting for a call to "sync" or the final call to "switch".
+aborted       | User or operator aborted the migration attempt.
+failed        | Migration operation could not complete, see migration "error" field.
+successful    | Migration was successfully completed.
+
+### Migration Phases
+
+The workflow stage that the migration is currently running, one of:
+
+Phase      | Description
+---------- | ------------
+begin      | This phase starts the migration process, creates a new migration database entry and provisions the target instance.
+sync       | This phase synchronizes the zfs datasets of the source instance with the zfs datasets in the target instance (without stopping the instance).
+switch     | This phase stops the instance from running, synchronizes the zfs datasets of the source instance with the zfs datasets in the target instance, moves the NICs from the source to the target instance, moves control to the target instance and then restarts the target instance.
+abort      | This phase is used when aborting a migration.
+
+## VmMigrateWatch (GET /migrations/:uuid/watch)
+
+Receive progress for an existing migration.
+
+### Optional Inputs
+
+Param                | Type     | Description
+-------------------- | -------- | -----------
+owner_uuid           | UUID     | VM Owner
+
+### VmMigrateWatch Response
+
+On success, you will receive a newline delimited JSON stream of
+[Migration Progress Events](#migration-progress-events), which will continue
+whilst the migration is running. At the end of the migration action (or if no
+action was running) a final [Migration End Event](#migration-end-event) will be
+sent and the connection will be closed.
+
+Code     | Description                                                                  | Response
+-------- | ---------------------------------------------------------------------------- | ------------------
+200      | OK - watching migration.                                                     | [Migration Progress Events](#migration-progress-events)
+404      | VM Not Found. VM does not exist or VM does not belong to the specified owner | Error object
+
+### Migration Progress Events
+
+The migration watch endpoint will send progress events to inform what is
+occurring during the migration. There are actually two styles of progress
+events - one for major events (and/or warnings) and one to show the sync
+progress (`bandwidth` and `eta`).
+
+Field                    | Type               | Description
+------------------------ | ------------------ | -----------------
+type                     | String             | Type is "progress".
+phase                    | String             | Current phase. See [Migration Phases](#migration-phases).
+state                    | String             | State is "running". See [Migration States](#migration-states).
+current\_progress        | Number             | This is how much progress has been made. For the sync phase, this is the number of bytes that have been sent to the target.
+total\_progress          | Number             | This is total possible progress. For the sync phase, this is the number of bytes that will need to be sent to the target.
+message                  | String (optional)  | Additional description message for this task.
+error                    | String (optional)  | Error occurred in this task - this is the description for that error.
+started\_timestamp       | String (optional)  | The ISO timestamp when the phase was started.
+duration\_ms             | Number (optional)  | The number of milliseconds the phase has taken.
+eta\_ms                  | Number (optional)  | Estimate of the number of milliseconds until the task is completed.
+transfer\_bytes\_second  | Number (optional)  | The number of bytes being sent per second between the source and target instances during the "sync" phase.
+
+### Migration End Event
+
+At the end of a migration watch a final end event is sent containing these
+fields:
+
+Field                    | Type               | Description
+------------------------ | ------------------ | -----------------
+type                     | String             | Type is "end".
+phase                    | String             | Phase that just ended. See [Migration Phases](#migration-phases).
+state                    | String             | State, one of "paused", "failed", "aborted" or "successful". See [Migration States](#migration-states).
 
 # Running Status for VMs
 
diff --git a/lib/apis/cnapi.js b/lib/apis/cnapi.js
index c6fb1bf..a10e794 100644
--- a/lib/apis/cnapi.js
+++ b/lib/apis/cnapi.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2017, Joyent, Inc.
+ * Copyright (c) 2019, Joyent, Inc.
  */
 
 /*
@@ -148,4 +148,34 @@ Cnapi.prototype.capacity = function (server, callback) {
 };
 
 
+/*
+ * Wait for a task to complete or a timeout to be fired.
+ */
+Cnapi.prototype.waitTask = function (id, options, callback) {
+    if (!id) {
+        callback(new Error('task id is required'));
+        return;
+    }
+
+    if (typeof (options) === 'function') {
+        callback = options;
+        options = undefined;
+    }
+
+    var path = '/tasks/' + encodeURIComponent(id) + '/wait';
+
+    if (options.timeout) {
+        path += '?timeout=' + options.timeout;
+    }
+
+    var opts = { path: path };
+
+    if (options && options.headers) {
+        opts.headers = options.headers;
+    }
+
+    this.client.get(opts, callback);
+};
+
+
 module.exports = Cnapi;
diff --git a/lib/apis/moray.js b/lib/apis/moray.js
index 34c3a77..a823f98 100644
--- a/lib/apis/moray.js
+++ b/lib/apis/moray.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2018, Joyent, Inc.
+ * Copyright (c) 2019, Joyent, Inc.
  */
 
 /*
@@ -51,6 +51,7 @@ var PARAM_FILTER_LE = '(%s<=%s)';
 var PARAM_FILTER_NE = '(!(%s=%s))';
 var SELECT_ALL_FILTER = '(uuid=*)';
 var VM_OBJECTS_DATA_VERSION = 1;
+var VM_MIGRATE_OBJECTS_DATA_VERSION = 1;
 
 /*
  * The constructor for the Moray class.
@@ -102,15 +103,16 @@ function Moray(options) {
 
 /*
  * Validates that the buckets config "bucketsConfig" is sound, which currently
- * only means that there is some data for all three models that the application
- * uses (vms, server_vms and vm_role_tags). The rest of validation is delegated
- * to Moray when actually setting up the buckets in "bucketsConfig".
+ * only means that there is some data for all models that the application uses.
+ * The rest of validation is delegated to Moray when actually setting up the
+ * buckets in "bucketsConfig".
  */
 function _validateBucketsConfig(bucketsConfig) {
     assert.object(bucketsConfig, 'bucketsConfig');
     assert.object(bucketsConfig.vms, 'bucketsConfig.vms');
     assert.object(bucketsConfig.server_vms, 'bucketsConfig.server_vms');
     assert.object(bucketsConfig.vm_role_tags, 'bucketsConfig.vm_role_tags');
+    assert.object(bucketsConfig.vm_migrations, 'bucketsConfig.vm_migrations');
 }
 
 /*
@@ -253,6 +255,7 @@ Moray.prototype.setupBuckets = function setupBuckets(callback) {
 
     self._VMS_BUCKET_NAME = self._bucketsConfig.vms.name;
     self._VM_ROLE_TAGS_BUCKET_NAME = self._bucketsConfig.vm_role_tags.name;
+    self._VM_MIGRATIONS_BUCKET_NAME = self._bucketsConfig.vm_migrations.name;
 
     for (bucketConfig in self._bucketsConfig) {
         bucketsList.push(self._bucketsConfig[bucketConfig]);
@@ -1556,6 +1559,262 @@ Moray.prototype.delVmRoleTags = function (uuid, cb) {
 
 
 
+/**
+ * VM Migrations
+ */
+
+
+/*
+ * Get all vm migrations that match the given criteria (an array). Returns a
+ * list of vm migration objects. Note that the array of migrations will be
+ * returned in descending created_timestamp order.
+ */
+Moray.prototype.getVmMigrations = function (params, cb) {
+    assert.object(params, 'params');
+    assert.func(cb, 'cb');
+
+    var filter = '';
+    var findOptions = {
+        sort: {
+            order: 'DESC',
+            attribute: 'created_timestamp'
+        }
+    };
+    var migrations = [];
+    var req;
+    var self = this;
+
+    if (!self.bucketsSetup()) {
+        cb(new Error(self._createMorayBucketsNotSetupErrMsg()));
+        return;
+    }
+
+    Object.keys(params).forEach(function (param) {
+        var schemaIndex = self._bucketsConfig.vm_migrations.schema.index;
+        if (!schemaIndex.hasOwnProperty(param)) {
+            self._log.trace('vm migration schema has no indexed field: "%s"',
+                param);
+            return;
+        }
+        if (param === 'state' && params[param] === 'active') {
+            // Active is considering 'running', 'paused' or 'failed'.
+            filter += '(|(state=running)(state=paused)(state=failed))';
+        } else if (param === 'source_server_uuid') {
+            // Match to the current source_server_uuid or in the case of a
+            // finished migration, match the target_server_uuid.
+            filter += sprintf('(|%s(&%s(state=successful)))',
+                sprintf(PARAM_FILTER, param, params[param]),
+                sprintf(PARAM_FILTER, 'target_server_uuid', params[param]));
+        } else {
+            filter += sprintf(PARAM_FILTER, param, params[param]);
+        }
+    });
+
+    if (filter) {
+        filter = '(&' + filter + ')';
+    } else {
+        filter = '(id=*)';
+    }
+
+    self._log.info({filter: filter}, 'getVmMigrations');
+
+    req = self._morayClient.findObjects(self._VM_MIGRATIONS_BUCKET_NAME,
+        filter, findOptions);
+
+    req.once('error', function (err) {
+        return cb(err);
+    });
+
+    req.on('record', function (object) {
+        migrations.push(object.value);
+    });
+
+    req.once('end', function () {
+        return cb(null, migrations);
+    });
+};
+
+
+/*
+ * Get the active vm migration for the provideded params.
+ */
+Moray.prototype.getVmMigrationByParams = function (params, cb) {
+    this.getVmMigrations(params, function _getVmMigrationsCb(err, migrations) {
+        if (err) {
+            cb(err);
+            return;
+        }
+
+        if (!migrations || migrations.length === 0) {
+            cb(new restify.ResourceNotFoundError('migration not found'));
+            return;
+        }
+
+        // Return the first entry - as that is the most recent migration
+        // record, note that getVmMigrations returns migrations sorted by
+        // created_timestamp in *descending* order.
+        cb(null, migrations[0]);
+    });
+};
+
+
+/*
+ * Get the vm migration for this vm uuid.
+ */
+Moray.prototype.getVmMigrationByVmUuid = function (vm_uuid, cb) {
+    assert.uuid(vm_uuid, 'vm_uuid');
+
+    var params = {
+        vm_uuid: vm_uuid
+    };
+
+    this.getVmMigrationByParams(params, cb);
+};
+
+
+/*
+ * Get the vm migration for this migration id.
+ */
+Moray.prototype.getVmMigrationById = function (id, cb) {
+    assert.uuid(id, 'id');
+
+    var params = {
+        id: id
+    };
+
+    this.getVmMigrationByParams(params, cb);
+};
+
+
+/*
+ * Converts to a moray VM migration record.
+ */
+Moray.prototype._toMorayVmMigrationRecord = function (migration) {
+    assert.object(migration, 'migration');
+    assert.uuid(migration.vm_uuid, 'migration.vm_uuid');
+    assert.uuid(migration.source_server_uuid, 'migration.source_server_uuid');
+
+    var copy = jsprim.deepCopy(migration);
+    var entry;
+    var i;
+    var max;
+
+    // Add durations to any progress history event that is finished.
+    if (Array.isArray(copy.progress_history)) {
+        max = copy.progress_history.length;
+        for (i = 0; i < max; i++) {
+            entry = copy.progress_history[i];
+            if (!entry.duration_ms && entry.started_timestamp &&
+                    entry.finished_timestamp) {
+                entry.duration_ms = new Date(entry.finished_timestamp) -
+                    new Date(entry.started_timestamp);
+            }
+        }
+    }
+
+    copy.data_version = VM_MIGRATE_OBJECTS_DATA_VERSION;
+
+    return copy;
+};
+
+
+/*
+ * Validates the moray VM migration record.
+ *
+ * Returns null on success, error on failure.
+ */
+Moray.prototype._validateVmMigrationRecord =
+function _validateVmMigrationRecord(record) {
+    assert.object(record, 'migration');
+
+    // Moray itself will validate the indexed fields - we validate the other
+    // properties here.
+    var errs = [];
+
+    var OPTIONAL_FIELDS = {
+        action: 'string',
+        automatic: 'boolean',
+        duration_ms: 'number',
+        finished_timestamp: 'string',
+        num_sync_phases: 'number',
+        phase: 'string',
+        target_vm_uuid: 'string'
+    };
+
+    Object.keys(OPTIONAL_FIELDS).forEach(function _optionalRecordField(field) {
+        var expectedType = OPTIONAL_FIELDS[field];
+        if (record.hasOwnProperty(field) &&
+                typeof (record[field]) !== expectedType) {
+            errs.push('invalid field "' + field + '"');
+        }
+    });
+
+    if (errs.length > 0) {
+        return new Error('Invalid migration record: ' + errs.join(','));
+    }
+
+    return null;
+};
+
+/*
+ * Puts a VM migration. If it doesn't exist it gets created, if it does exist
+ * it gets updated.
+ */
+Moray.prototype.putVmMigration = function putVmMigration(migration, cb) {
+    assert.object(migration, 'migration');
+    assert.uuid(migration.id, 'migration.id');
+    assert.func(cb, 'cb');
+
+    var self = this;
+    var record = self._toMorayVmMigrationRecord(migration);
+    var validationError = self._validateVmMigrationRecord(record);
+
+    if (validationError) {
+        cb(validationError);
+        return;
+    }
+
+    if (!self.bucketsSetup()) {
+        cb(new Error(self._createMorayBucketsNotSetupErrMsg()));
+        return;
+    }
+
+    self._log.debug({record: record}, 'putting VM migration record');
+
+    self._morayClient.putObject(self._VM_MIGRATIONS_BUCKET_NAME, record.id,
+            record, function onPutMigrationObj(putErr, obj) {
+        if (putErr) {
+            self._log.error({err: putErr},
+                'error when putting VM migration record to moray');
+        } else {
+            self._log.debug('VM migration record successfully put to moray');
+        }
+        cb(putErr, obj);
+    });
+};
+
+
+/*
+ * Deletes one vm migration record.
+ */
+Moray.prototype.delVmMigration = function (id, cb) {
+    if (!this.bucketsSetup()) {
+        cb(new Error(this._createMorayBucketsNotSetupErrMsg()));
+        return;
+    }
+
+    this._morayClient.delObject(this._VM_MIGRATIONS_BUCKET_NAME, id,
+        function onDeleteMigrationObj(err) {
+            if (!err ||
+                (err && verror.hasCauseWithName(err, 'ObjectNotFoundError'))) {
+                cb(null);
+            } else {
+                cb(err);
+            }
+        });
+};
+
+
 /*
  * Reindexes all objects in the bucket with name "bucketName" and calls the
  * function "callback" when it's done.
diff --git a/lib/apis/wfapi.js b/lib/apis/wfapi.js
index c07024d..bbcebc4 100644
--- a/lib/apis/wfapi.js
+++ b/lib/apis/wfapi.js
@@ -780,6 +780,62 @@ Wfapi.prototype.createDeleteSnapshotJob = function (req, cb) {
 
 
 
+/*
+ * Queues a migration job.
+ */
+Wfapi.prototype.createMigrateJob = function _createMigrateJobFn(req, cb) {
+    assert.object(req, 'req');
+    assert.object(req.migrationTask, 'req.migrationTask');
+    assert.string(req.migrationTask.action, 'req.migrationTask.action');
+    assert.optionalObject(req.migrationTask.record, 'req.migrationTask.record');
+    assert.object(req.vm, 'req.vm');
+    assert.string(req.vm.server_uuid, 'req.vm.server_uuid');
+    assert.string(req.vm.uuid, 'req.vm.uuid');
+    assert.optionalString(req.params.is_migration_subtask,
+        'req.params.is_migration_subtask');
+    assert.optionalString(req.params.override_alias,
+        'req.params.override_alias');
+    assert.object(req.filteredNetworks, 'req.vm.filteredNetworks');
+    assert.func(cb, 'cb');
+
+    var action = req.migrationTask.action;
+    var options = { headers: { 'x-request-id': req.getId() } };
+    var self = this;
+    var vm_uuid = req.vm.uuid;
+    var workflowTask = 'migrate-' + action;
+
+    var params = {
+        image: req.vm.image,
+        filteredNetworks: req.filteredNetworks,
+        is_final_sync: Boolean(req.params.is_final_sync),
+        is_migration_subtask: Boolean(req.params.is_migration_subtask),
+        migrationTask: req.migrationTask,
+        override_alias: req.params.override_alias,
+        server_uuid: req.vm.server_uuid, // Used by the acquireVMTicket calls.
+        target: '/migrate-' + vm_uuid,
+        task: workflowTask,
+        vm: req.vm,
+        vm_uuid: vm_uuid,
+        'x-request-id': req.getId()
+    };
+
+    setContext(req, params);
+
+    self.client.createJob(workflowTask, params, options,
+            function (err, job) {
+        if (err) {
+            cb(err);
+            return;
+        }
+
+        self.log.debug('Migration job ' + job.uuid + ' queued for VM ' +
+            vm_uuid);
+        cb(null, job.uuid);
+    });
+};
+
+
+
 /*
  * Retrieves a job from WFAPI.
  */
diff --git a/lib/common/validation.js b/lib/common/validation.js
index 608edc5..270b0e5 100644
--- a/lib/common/validation.js
+++ b/lib/common/validation.js
@@ -1048,9 +1048,9 @@ function safeBrandName(brandName) {
 exports._safeBrandName = safeBrandName;
 
 /*
- * Reused by Create/Update for checking package values and populating the
- * request params when some values are not present. This function should only
- * be called when a request contains billing_id
+ * Reused by Create/Update/Migrate for checking package values and populating
+ * the request params when some values are not present. This function should
+ * only be called when a request contains billing_id
  */
 function validatePackageValues(papi, params, errs, callback) {
     var packageFields = ['cpu_cap', 'max_lwps', 'max_physical_memory',
@@ -1134,7 +1134,7 @@ function validatePackageValues(papi, params, errs, callback) {
     });
 }
 // export for tests
-exports._validatePackageValues = validatePackageValues;
+exports.validatePackageValues = validatePackageValues;
 
 /*
  * Validates CreateVm parameters
@@ -1194,6 +1194,10 @@ exports.validateCreateVmParams = function (vmapi, params, callback) {
     }
 
     function validateUniqueUuid(next) {
+        if (params.do_not_inventory && params.vm_migration_target) {
+            next();
+            return;
+        }
         vmapi.moray.getVm({ uuid: params.uuid }, function onGetVm(err, vm) {
             if (err) {
                 return next(err);
@@ -1207,6 +1211,10 @@ exports.validateCreateVmParams = function (vmapi, params, callback) {
     }
 
     function validateAlias(next) {
+        if (params.do_not_inventory && params.vm_migration_target) {
+            next();
+            return;
+        }
         validateUniqueAlias(vmapi.moray, params, function (err, errorObj) {
             if (err) {
                 return next(err);
diff --git a/lib/endpoints/vms.js b/lib/endpoints/vms.js
index ddf9301..6fcfbdf 100644
--- a/lib/endpoints/vms.js
+++ b/lib/endpoints/vms.js
@@ -24,6 +24,7 @@ var jsprim = require('jsprim');
 var common = require('../common');
 var errors = require('../errors');
 var interceptors = require('../interceptors');
+var mod_migrate = require('../vm-migration/migrate');
 
 // First Platform Image supporting Bhyve VMs snapshots:
 const MIN_BHYVE_SNAPSHOT_PLATFORM = '20181119T131511Z';
@@ -43,7 +44,8 @@ var VALID_VM_ACTIONS = [
     'delete_snapshot',
     'create_disk',
     'resize_disk',
-    'delete_disk'
+    'delete_disk',
+    'migrate'
 ];
 
 
@@ -477,6 +479,9 @@ function updateVm(req, res, next) {
         case 'delete_disk':
             method = deleteDisk;
             break;
+        case 'migrate':
+            method = mod_migrate.migrateVm;
+            break;
         default:
             error = [ errors.invalidParamErr('action') ];
             return next(new errors.ValidationFailedError('Invalid Parameters',
@@ -1749,14 +1754,24 @@ function allocateServer(req, callback) {
     }
 
     function putVmInMoray(_, next) {
+        var vmuuid = params.uuid;
+
+        // For a VM with do_not_inventory, don't write the moray record at all.
+        if (params.do_not_inventory) {
+            req.log.debug({vm_uuid: vmuuid}, 'Provisioning VM %s - not ' +
+                'writing moray record as do_not_inventory is set', vmuuid);
+            next();
+            return;
+        }
+
         var vmparams = jsprim.deepCopy(params);
-        var vmuuid = vmparams.uuid;
 
         vmparams.state = 'provisioning';
         vmparams.create_timestamp = (new Date());
         vmparams.server_uuid = req.vm.server_uuid;
 
         var vm = common.translateVm(vmparams);
+
         req.app.moray.putVm(vmuuid, vm, {}, function (err) {
             if (err) {
                 // When provision has been queued and moray fails putobject
@@ -2617,6 +2632,7 @@ function mount(server) {
     server.post({ path: '/vms/:uuid', name: 'UpdateVm' },
         interceptors.checkWfapi,
         interceptors.loadVm,
+        mod_migrate.preloadNetworkParams,
         preFilterNetworks,
         updateVm);
 
@@ -2629,7 +2645,35 @@ function mount(server) {
         interceptors.checkWfapi,
         _loadVms,
         putVms);
-}
+
+    server.get({ path: '/migrations', name: 'ListMigrations' },
+        mod_migrate.listVmMigrations);
+
+    server.get({ path: '/migrations/:uuid', name: 'GetMigration' },
+        _loadVm,
+        mod_migrate.loadVmMigration,
+        mod_migrate.getVmMigration);
+
+    server.get({ path: '/migrations/:uuid/watch', name: 'WatchMigration' },
+        _loadVm,
+        mod_migrate.loadVmMigration,
+        mod_migrate.watchVmMigration);
+
+    server.post({path: '/migrations/:uuid/store', name: 'StoreMigrationRecord'},
+        // Do not call _loadVm here - this is intentionally lightweight/fast.
+        mod_migrate.storeMigrationRecord);
+
+    server.post({path: '/migrations/:uuid/progress', name: 'MigrationProgress'},
+        // Do not call _loadVm here - this is intentionally lightweight/fast.
+        mod_migrate.onProgress);
+
+    server.post({path: '/migrations/:uuid/updateVmServerUuid',
+        name: 'MigrationUpdateVmServerUuid'},
+        // Do not call _loadVm here - this is intentionally lightweight/fast.
+        _loadVm,
+        mod_migrate.updateVmServerUuid,
+        putVm);
+    }
 
 
 // --- Exports
diff --git a/lib/moray/moray-buckets-config.js b/lib/moray/moray-buckets-config.js
index 9178853..ba6195e 100644
--- a/lib/moray/moray-buckets-config.js
+++ b/lib/moray/moray-buckets-config.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2017, Joyent, Inc.
+ * Copyright (c) 2019, Joyent, Inc.
  */
 
 /*
@@ -72,8 +72,28 @@ var VM_ROLE_TAGS_BUCKET_CONFIG = {
     }
 };
 
+var VM_MIGRATIONS_BUCKET_CONFIG = {
+    name: 'vmapi_vm_migrations',
+    schema: {
+        index: {
+            id:  { type: 'string', unique: true },
+            created_timestamp: { type: 'string' },
+            vm_uuid: { type: 'string' },
+            owner_uuid: { type: 'string' },
+            source_server_uuid: { type: 'string' },
+            target_server_uuid: { type: 'string' },
+            state: { type: 'string' },
+            data_version: { type: 'number' }
+        },
+        options: {
+            version: 2
+        }
+    }
+};
+
 module.exports = {
     vms: VMS_BUCKET_CONFIG,
     server_vms: SERVER_VMS_BUCKET_CONFIG,
-    vm_role_tags: VM_ROLE_TAGS_BUCKET_CONFIG
+    vm_role_tags: VM_ROLE_TAGS_BUCKET_CONFIG,
+    vm_migrations: VM_MIGRATIONS_BUCKET_CONFIG
 };
diff --git a/lib/vm-migration/migrate.js b/lib/vm-migration/migrate.js
new file mode 100644
index 0000000..db92d27
--- /dev/null
+++ b/lib/vm-migration/migrate.js
@@ -0,0 +1,1010 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2019, Joyent, Inc.
+ */
+
+/*
+ * This contains the code to handle vm migrations.
+ */
+
+var fs = require('fs');
+var util = require('util');
+
+var assert = require('assert-plus');
+var libuuid = require('libuuid');
+var restify = require('restify');
+var vasync = require('vasync');
+var common = require('../common');
+
+var errors = require('../errors');
+
+var format = util.format;
+
+
+var MIGRATION_PROGRESS_FOR_VM_UUID = {};
+var MIGRATION_RECORD_FOR_VM_UUID = {};
+
+var VALID_MIGRATION_ACTIONS = [
+    'abort',
+    'begin',
+    'estimate',
+    'pause',
+    'switch',
+    'sync'
+];
+
+
+function validateMigrationBegin(vm, ctx, callback) {
+    assert.object(vm, 'vm');
+    assert.optionalObject(vm.tags, 'vm.tags');
+    assert.object(ctx, 'ctx');
+    assert.optionalObject(ctx.migrationRecord, 'ctx.migrationRecord');
+    assert.func(callback, 'callback');
+
+    // Check if there is an existing unfinished migration.
+    if (ctx.migrationRecord) {
+        // Allow a migration that started the begin phase, but did not yet
+        // allocate the target instance.
+        var disallowRetry = true;
+        var history = ctx.migrationRecord.progress_history;
+        if (ctx.migrationRecord.phase === 'begin' &&
+                ctx.migrationRecord.state === 'failed' &&
+                Array.isArray(history) && history.length > 0 &&
+                history[history.length-1].phase === 'begin' &&
+                !history[history.length-1].disallowRetry) {
+            disallowRetry = false;
+        }
+
+        if (ctx.migrationRecord.state !== 'successful' &&
+                ctx.migrationRecord.state !== 'aborted' &&
+                disallowRetry) {
+            callback(new restify.errors.PreconditionFailedError(
+                'An active migration already exists for this instance'));
+            return;
+        }
+
+        if (disallowRetry) {
+            // This is not a retry, clear the migration record so that we will
+            // create a new migration record.
+            delete ctx.migrationRecord;
+        }
+    }
+
+    // Cannot migrate a core Triton instance.
+    if (vm.tags && vm.tags.smartdc_type === 'core') {
+        callback(new restify.errors.PreconditionFailedError(
+            'Cannot migrate a core instance'));
+        return;
+    }
+
+    // Cannot migrate a Triton nat instance.
+    if (vm.tags && vm.tags.smartdc_role === 'nat') {
+        callback(new restify.errors.PreconditionFailedError(
+            'Cannot migrate a NAT instance'));
+        return;
+    }
+
+    callback();
+}
+
+function migrationEstimate(req, callback) {
+    assert.object(req, 'req');
+    assert.object(req.vm, 'req.vm');
+    assert.object(req.app.cnapi, 'req.app.cnapi');
+    assert.object(req.app.cnapi.client, 'req.app.cnapi.client');
+    assert.func(callback, 'callback');
+
+    var errMsg = 'Migration estimate failed';
+    var headers = {'x-request-id': req.getId()};
+    var timeout = 15 * 60 * 1000; // 15 minutes
+    var vm = req.vm;
+
+    var payload = {
+        action: 'estimate',
+        migrationTask: {
+            action: 'estimate',
+            record: {}
+        },
+        vm: vm
+    };
+    var postOpts = {
+        headers: headers,
+        path: '/servers/' + vm.server_uuid + '/vms/' +
+            vm.uuid + '/migrate'
+    };
+
+    req.app.cnapi.client.post(postOpts, payload,
+            function _estimateCb(err, cnReq, cnRes, body) {
+        if (err) {
+            callback(err);
+            return;
+        }
+
+        // Should get back a cnapi task id.
+        if (!body || !body.id) {
+            callback(new restify.errors.InternalError(
+                errMsg + ': invalid cnapi response'));
+            return;
+        }
+
+        // Wait for the cnapi task to finish.
+        req.app.cnapi.waitTask(body.id, {timeout: timeout},
+                function (waitErr, waitReq, waitRes, task) {
+            if (waitErr) {
+                callback(waitErr);
+                return;
+            }
+
+            if (!task) {
+                callback(new restify.errors.InternalError(
+                    errMsg + ': no cnapi task'));
+                return;
+            }
+
+            if (task.status !== 'complete') {
+                var errEntries;
+                if (Array.isArray(task.history) && task.history.length > 0) {
+                    errEntries = task.history.filter(function _histFilt(h) {
+                        return h.name === 'error';
+                    });
+                }
+                if (errEntries && errEntries.length > 0) {
+                    errMsg += ': ' + errEntries.map(function _errMap(e) {
+                        if (e.event && e.event.error) {
+                            return e.event.error.message ||
+                                String(e.event.error);
+                        }
+                        return String(e);
+                    }).join(', ');
+                } else {
+                    errMsg += ' (task id ' + body.id + ')';
+                }
+                callback(new restify.errors.InternalError(errMsg));
+                return;
+            }
+
+            if (!Array.isArray(task.history) ||
+                    task.history.length === 0 ||
+                    task.history.slice(-1)[0].name !== 'finish' ||
+                    !task.history.slice(-1)[0].event) {
+                callback(new restify.errors.InternalError(
+                    errMsg + ': no cnapi task finish event'));
+                return;
+            }
+
+            // TODO: Get the average speed of the last N migrate operations:
+            // * average begin time
+            // * average sync speed
+            // * average switch time
+            // and use these to create a more accurate estimation.
+            callback(null, task.history.slice(-1)[0].event);
+        });
+    });
+}
+
+/**
+ * For migration, we must convert the existing vm nics into network objects,
+ * which is then stored into req.params.networks. The reason for this is that
+ * the vms.preFilterNetworks function will then be used to load all network
+ * information. This is required later during server allocation (in determining
+ * nic tag requirements).
+ */
+function preloadNetworkParams(req, res, next) {
+    if (req.params.action !== 'migrate' ||
+            req.params.migration_action !== 'begin' ||
+            !req.vm ||
+            !req.vm.nics) {
+        next();
+        return;
+    }
+
+    // Convert nics into network params.
+    req.params.networks = req.vm.nics.map(function _nicToMac(nic) {
+        var netObj = {
+            mac: nic.mac,
+            uuid: nic.network_uuid
+        };
+        if (nic.primary) {
+            netObj.primary = nic.primary;
+        }
+        return netObj;
+    });
+
+    next();
+}
+
+/*
+ * Migrates a vm with ?action=migrate
+ */
+function migrateVm(req, res, next) {
+    assert.object(req, 'req');
+    assert.object(req.params, 'req.params');
+    assert.optionalString(req.params.migration_action,
+        'req.params.migration_action');
+    assert.object(req.vm, 'req.vm');
+    assert.object(res, 'res');
+    assert.object(req.filteredNetworks, 'req.filteredNetworks');
+    assert.func(next, 'next');
+
+    var OK_EARLY_ABORT = true;
+    var log = req.log;
+    var vm = req.vm;
+
+    log.trace({vm_uuid: req.params.uuid, action: req.params.action},
+        'MigrateVm handler started');
+
+    var action = req.params.migration_action;
+    var automatic = false;
+    if (req.params.migration_automatic === 'true' ||
+            req.params.migration_automatic === true) {
+        automatic = true;
+    }
+
+    if (!action || VALID_MIGRATION_ACTIONS.indexOf(action) === -1) {
+        next(new restify.errors.InvalidArgumentError(
+            'Invalid migration action'));
+        return;
+    }
+
+    vasync.pipeline({arg: {}, funcs: [
+        function load_migration_record(ctx, cb) {
+            var lookupParams = {
+                source_server_uuid: vm.server_uuid,
+                vm_uuid: vm.uuid
+            };
+            req.app.moray.getVmMigrationByParams(lookupParams,
+                function _loadMigration(err, record) {
+                    if (err) {
+                        if (err.statusCode === 404 &&
+                                (action === 'begin' || action === 'estimate')) {
+                            // Not found error - which is only allowed when
+                            // starting a new migration.
+                            cb();
+                            return;
+                        }
+                        cb(err);
+                        return;
+                    }
+                    ctx.migrationRecord = record;
+                    log.debug({
+                            uuid: vm.vm_uuid,
+                            phase: record.phase,
+                            state: record.state
+                        },
+                        'Found existing migration record');
+                    cb();
+                });
+        },
+
+        function validate(ctx, cb) {
+            if (action === 'begin' || action === 'estimate') {
+                validateMigrationBegin(vm, ctx, cb);
+                return;
+            }
+
+            assert.object(ctx.migrationRecord, 'ctx.migrationRecord');
+
+            log.debug({migrationRecord: ctx.migrationRecord},
+                'Current migration record');
+
+            var phase = ctx.migrationRecord.phase;
+            var state = ctx.migrationRecord.state;
+
+            switch (action) {
+                case 'abort':
+                    if (state === 'running' || state === 'successful') {
+                        cb(new restify.errors.PreconditionFailedError(
+                            'Abort cannot work on a ' + state + ' migration'));
+                        return;
+                    }
+                    break;
+                case 'pause':
+                    if (phase !== 'sync' || state !== 'running') {
+                        cb(new restify.errors.PreconditionFailedError(
+                            'Pause requires a running migration sync action'));
+                        return;
+                    }
+                    break;
+                case 'switch':
+                    if (phase !== 'begin' && phase !== 'sync') {
+                        cb(new restify.errors.PreconditionFailedError(
+                            'Cannot switch in migration phase: ' + phase));
+                        return;
+                    }
+                    if (state !== 'paused' && state !== 'failed') {
+                        // Allow migration switch to run from state 'running'
+                        // when it is a migration subtask.
+                        if (state !== 'running' ||
+                                !req.params.is_migration_subtask) {
+                            cb(new restify.errors.PreconditionFailedError(
+                                'Cannot switch in migration state: ' + state));
+                            return;
+                        }
+                    }
+                    // Ensure that at least one successful sync operation has
+                    // been run.
+                    if (!ctx.migrationRecord.num_sync_phases) {
+                        cb(new restify.errors.PreconditionFailedError(
+                            'You must perform at least one ' +
+                            '"migration sync" operation before switching'));
+                        return;
+                    }
+                    break;
+                case 'sync':
+                    if (state !== 'paused' && state !== 'failed') {
+                        // Allow migration sync to run from state 'running'
+                        // when it is a migration subtask.
+                        if (state !== 'running' ||
+                                !req.params.is_migration_subtask) {
+                            cb(new restify.errors.PreconditionFailedError(
+                                'Cannot sync in migration state: ' + state));
+                            return;
+                        }
+                    }
+                    if (phase === 'begin' && state === 'paused') {
+                        cb();
+                        return;
+                    }
+                    if (phase === 'sync' && (state === 'paused' ||
+                            state === 'failed')) {
+                        cb();
+                        return;
+                    }
+                    if (state === 'running' &&
+                            req.params.is_migration_subtask) {
+                        cb();
+                        return;
+                    }
+
+                    cb(new restify.errors.PreconditionFailedError(
+                        'Cannot sync when in migration phase: ' + phase));
+                    return;
+                default:
+                    assert.fail(format('Unvalidated vm migration action: %s',
+                        action));
+                    break;
+            }
+
+            cb();
+        },
+
+        function do_migration_estimate(ctx, cb) {
+            if (action !== 'estimate') {
+                cb();
+                return;
+            }
+
+            migrationEstimate(req, function _getEstimate(err, result) {
+                if (err) {
+                    cb(err);
+                    return;
+                }
+
+                res.send(200, result);
+                cb(OK_EARLY_ABORT);
+            });
+        },
+
+        function do_get_image(ctx, cb) {
+            assert.notEqual(action, 'estimate');
+
+            if (action !== 'begin') {
+                cb();
+                return;
+            }
+
+            var img_uuid = vm.image_uuid || vm.disks[0].image_uuid;
+
+            req.app.imgapi.getImage(img_uuid, function (err, image) {
+                if (err) {
+                    cb(err);
+                    return;
+                }
+
+                // XXX what should we do in the case of an image that is not
+                // 'active'?
+                vm.image = image;
+                cb();
+            });
+        },
+
+        function do_get_package(ctx, cb) {
+            assert.notEqual(action, 'estimate');
+
+            if (action !== 'begin') {
+                cb();
+                return;
+            }
+
+            var errs = [];
+            common.validatePackageValues(req.app.papi, vm, errs, function () {
+                if (errs.length > 0) {
+                    cb(new errors.ValidationFailedError('Invalid VM parameters',
+                        errs));
+                    return;
+                }
+                cb();
+            });
+        },
+
+        function start_create_new_record(ctx, cb) {
+            assert.notEqual(action, 'estimate');
+
+            if (action !== 'begin') {
+                cb();
+                return;
+            }
+
+            // Keep the same record when a migration record already exists. This
+            // is here to stop duplicate Moray records in the case where we are
+            // retrying the 'begin' phase.
+            var record = ctx.migrationRecord;
+            if (!record) {
+                record = {
+                    action: action,
+                    automatic: automatic,
+                    created_timestamp: (new Date()).toISOString(),
+                    id: libuuid.create(),
+                    num_sync_phases: 0,
+                    owner_uuid: req.params.owner_uuid,
+                    phase: 'begin',
+                    progress_history: [],
+                    source_server_uuid: vm.server_uuid,
+                    state: 'running',
+                    target_vm_uuid: vm.uuid,
+                    vm_uuid: vm.uuid
+                };
+            }
+
+            // Allow overriding of the target server.
+            if (req.params.override_server_uuid) {
+                assert.uuid(req.params.override_server_uuid,
+                    'req.params.override_server_uuid');
+                record.target_server_uuid = req.params.override_server_uuid;
+            }
+
+            // The target vm uuid should be the same as the vm uuid, except in
+            // the case of testing, where we allow a different uuid to in order
+            // to support migration to the same CN (e.g. migration in COAL).
+            if (req.params.override_uuid) {
+                assert.uuid(req.params.override_uuid,
+                    'req.params.override_uuid');
+
+                if (!fs.existsSync('/lib/sdc/.sdc-test-no-production-data')) {
+                    cb(new Error('Cannot override vm uuid - no ' +
+                        '/lib/sdc/.sdc-test-no-production-data file exists'));
+                    return;
+                }
+
+                record.target_vm_uuid = req.params.override_uuid;
+            }
+
+            ctx.migrationRecord = record;
+
+            req.app.moray.putVmMigration(record, cb);
+        },
+
+        function start_migration_workflow(ctx, cb) {
+            assert.notEqual(action, 'estimate');
+
+            req.migrationTask = {
+                action: action,
+                record: ctx.migrationRecord
+            };
+            req.app.wfapi.createMigrateJob(req, function (jobErr, jobUuid) {
+                if (jobErr) {
+                    cb(jobErr);
+                    return;
+                }
+
+                var migrationRecord = translateVmMigration(ctx.migrationRecord);
+                // Since the update of the record does not occur until the
+                // workflow is up and running (it just started), we have to
+                // tweak some parameters of the migration record.
+                migrationRecord.phase = action;
+                migrationRecord.state = 'running';
+
+                res.header('workflow-api', req.app.wfapi.url);
+                res.send(202, {
+                    job_uuid: jobUuid,
+                    migration: migrationRecord
+                });
+                cb();
+            });
+        }
+    ]}, function _pipelineCb(err) {
+        if (err && err !== OK_EARLY_ABORT) {
+            next(err);
+            return;
+        }
+
+        // Keep a record of the running (or soon to be running) phase.
+        if (action === 'begin' || action === 'sync' || action === 'switch' ||
+                action === 'abort') {
+            req.migrationTask.record.state = 'running';
+            MIGRATION_RECORD_FOR_VM_UUID[vm.uuid] = req.migrationTask.record;
+            // Clear old progress events.
+            delete MIGRATION_PROGRESS_FOR_VM_UUID[vm.uuid];
+        }
+
+        next();
+    });
+}
+
+
+function loadVmMigration(req, res, next) {
+    assert.object(req, 'req');
+    assert.object(req.app, 'req.app');
+    assert.object(req.app.moray, 'req.app.moray');
+    assert.object(req.log, 'req.log');
+    assert.optionalObject(req.vm, 'req.vm');
+    assert.func(next, 'next');
+
+    var log = req.log;
+
+    if (!req.vm || !req.vm.uuid || !req.vm.server_uuid) {
+        log.error({vm_uuid: req.params.uuid}, 'loadVmMigration:: invalid vm');
+        next(new restify.errors.PreconditionFailedError('Invalid vm instance'));
+        return;
+    }
+
+    var lookupParams = {
+        source_server_uuid: req.vm.server_uuid,
+        vm_uuid: req.vm.uuid
+    };
+    req.app.moray.getVmMigrationByParams(lookupParams, onLoadMigration);
+
+    function onLoadMigration(err, migration) {
+        if (err) {
+            next(err);
+            return;
+        }
+
+        req.vmMigration = migration;
+
+        log.trace({
+            id: migration.id,
+            phase: migration.phase,
+            state: migration.state,
+            vm_uuid: migration.vm_uuid
+        },
+        'Found migration record');
+
+        next();
+    }
+}
+
+
+function translateProgressEntry(entry) {
+    var field;
+    var i;
+    var result = {
+        type: 'progress'
+    };
+    var exposedFields = [
+        'current_progress',
+        'duration_ms',
+        'finished_timestamp',
+        'error',
+        'message',
+        'phase',
+        'state',
+        'started_timestamp',
+        'total_progress',
+        'type'
+    ];
+
+    for (i = 0; i < exposedFields.length; i++) {
+        field = exposedFields[i];
+        if (entry.hasOwnProperty(field)) {
+            result[field] = entry[field];
+        }
+    }
+
+    // Add duration_ms field.
+    if (!entry.hasOwnProperty('duration_ms')) {
+        if (entry.finished_timestamp) {
+            result.duration_ms = new Date(entry.finished_timestamp) -
+                new Date(entry.started_timestamp);
+        } else {
+            result.duration_ms = new Date() - new Date(entry.started_timestamp);
+        }
+    }
+
+    return result;
+}
+
+function translateVmMigration(migration) {
+    var field;
+    var i;
+    var result = {};
+    var exposedFields = [
+        'automatic',
+        'created_timestamp',
+        'duration_ms',
+        'error',
+        'finished_timestamp',
+        'phase',
+        'started_timestamp',
+        'state',
+        'vm_uuid'
+    ];
+
+    for (i = 0; i < exposedFields.length; i++) {
+        field = exposedFields[i];
+        if (migration.hasOwnProperty(field)) {
+            result[field] = migration[field];
+        }
+    }
+
+    if (Array.isArray(migration.progress_history)) {
+        result.progress_history = migration.progress_history.map(
+            translateProgressEntry);
+    }
+
+    if (!migration.hasOwnProperty('duration_ms')) {
+        migration.duration_ms = (migration.progress_history || []).reduce(
+            function accumulate_total(total, entry) {
+                return total + entry.duration_ms;
+            }, 0);
+    }
+
+    return result;
+}
+
+
+function addDuration(migration) {
+    // Get the total duration from all of the actions.
+    if (!migration.hasOwnProperty('duration_ms')) {
+        migration.duration_ms = (migration.progress_history || []).reduce(
+            function accumulate_total(total, entry) {
+                if (!entry.hasOwnProperty('duration_ms')) {
+                    if (entry.finished_timestamp) {
+                        entry.duration_ms = new Date(entry.finished_timestamp) -
+                            new Date(entry.started_timestamp);
+                    } else {
+                        entry.duration_ms = new Date() -
+                            new Date(entry.started_timestamp);
+                    }
+                }
+                return total + entry.duration_ms;
+            }, 0);
+    }
+
+    return migration;
+}
+
+
+function getVmMigration(req, res, next) {
+    assert.object(req.vmMigration, 'req.vmMigration');
+
+    if (req.params.format === 'raw') {
+        res.send(200, addDuration(req.vmMigration));
+    } else {
+        res.send(200, translateVmMigration(req.vmMigration));
+    }
+
+    next();
+}
+
+
+function listVmMigrations(req, res, next) {
+    var log = req.log;
+
+    req.app.moray.getVmMigrations(req.params, onLoadMigrations);
+
+    function onLoadMigrations(err, migrations) {
+        if (err) {
+            next(err);
+            return;
+        }
+
+        log.trace('Found %d migration records', migrations.length);
+
+        if (req.params.format === 'raw') {
+            res.send(200, migrations.map(addDuration));
+        } else {
+            res.send(200, migrations.map(translateVmMigration));
+        }
+
+        next();
+    }
+}
+
+
+function storeMigrationRecord(req, res, next) {
+    // TODO: Check etag?
+    var record = req.body;
+
+    req.app.moray.putVmMigration(record, function _putMigrationCb(err, etag) {
+        if (err) {
+            next(err);
+            return;
+        }
+
+        MIGRATION_RECORD_FOR_VM_UUID[record.vm_uuid] = record;
+
+        res.send(200);
+        next();
+    });
+}
+
+
+function watchVmMigration(req, res, next) {
+    assert.object(req, 'req');
+    assert.object(req.log, 'req.log');
+    assert.object(req.vmMigration, 'req.vmMigration');
+    assert.object(res, 'res');
+    assert.func(next, 'next');
+
+    var history = req.vmMigration.progress_history;
+    var lastEvent;
+    var nextProgressIdx = 0;
+    var lastRecord;
+    var lastSend = 0;
+    var getMigrationErrCount = 0;
+    var log = req.log;
+    var ONE_MINUTE_SECS = 60;
+    var ONE_SECOND_MS = 1000;
+    var progressAttemptCounter = 0;
+    var socketClosed = false;
+    var sourceServerUuid = req.vmMigration.source_server_uuid;
+    var vmUuid = req.vmMigration.vm_uuid;
+    var watchEnded = false;
+    var watchErrorMsg;
+
+    if (!Array.isArray(history)) {
+        log.error({migration: req.vmMigration}, 'Invalid migration record');
+        next(new restify.errors.PreconditionFailedError(
+            'Migration record is invalid'));
+        return;
+    }
+
+    // Watch for the client to close it's connection.
+    req.on('close', function _watchDetectReqClose() {
+        watchEnded = true;
+        socketClosed = true;
+        log.debug('watchVmMigration:: watch request closed');
+    });
+
+    // Watch for the response to end.
+    res.on('end', function _watchDetectResEnd() {
+        watchEnded = true;
+        socketClosed = true;
+        log.debug('watchVmMigration:: watch response ended');
+    });
+
+    // Watch for timeout.
+    res.on('timeout', function _watchDetectResTimeout() {
+        log.debug('watchVmMigration:: watch response timeout');
+    });
+
+    res.writeHead(200, {'Content-Type': 'application/x-json-stream'});
+
+    if (history.length > 0) {
+        if (history[history.length - 1].state === 'running') {
+            // Write out the last progress_history event.
+            res.write(JSON.stringify(translateProgressEntry(
+                history[history.length - 1])) + '\n');
+        }
+        nextProgressIdx = history.length;
+    }
+
+    if (req.vmMigration.state !== 'running') {
+        // Allow for a just recently started action (i.e. when the workflow has
+        // not yet started and has not yet updated the migration record state to
+        // running).
+        if (!MIGRATION_RECORD_FOR_VM_UUID[vmUuid] ||
+                MIGRATION_RECORD_FOR_VM_UUID[vmUuid].state !== 'running') {
+            res.write(JSON.stringify(
+                {
+                    type: 'end',
+                    phase: req.vmMigration.phase,
+                    state: req.vmMigration.state,
+                    message: req.vmMigration.error
+                }) + '\n');
+            res.end();
+            next();
+            return;
+        }
+    }
+
+
+    function connectedAndRunning() {
+        return !watchEnded;
+    }
+
+    function sendProgress(callback) {
+        var event = MIGRATION_PROGRESS_FOR_VM_UUID[vmUuid];
+        var record = MIGRATION_RECORD_FOR_VM_UUID[vmUuid];
+
+        function attemptDone(progressSent) {
+            if (progressSent) {
+                progressAttemptCounter = 0;
+                setTimeout(callback, ONE_SECOND_MS);
+                return;
+            }
+
+            // When 10 progress attempts have been made and there has been no
+            // progress sent, go and load the record from moray.
+
+            progressAttemptCounter += 1;
+            if (progressAttemptCounter < 10) {
+                setTimeout(callback, ONE_SECOND_MS);
+                return;
+            }
+
+            progressAttemptCounter = 0;
+
+            function onGetMigration(err, migration) {
+                if (err) {
+                    getMigrationErrCount += 1;
+
+                    if (getMigrationErrCount >= 6) {
+                        watchEnded = true;
+                        watchErrorMsg =
+                            'Watch error: unable to load the migration record.';
+                    }
+                    setTimeout(callback, ONE_SECOND_MS);
+                }
+
+                getMigrationErrCount = 0;
+                MIGRATION_RECORD_FOR_VM_UUID[vmUuid] = migration;
+                setTimeout(callback, ONE_SECOND_MS);
+            }
+
+            var lookupParams = {
+                source_server_uuid: sourceServerUuid,
+                vm_uuid: vmUuid
+            };
+            req.app.moray.getVmMigrationByParams(lookupParams, onGetMigration);
+        }
+
+        if (!event && !record) {
+            attemptDone(false);
+            return;
+        }
+
+        if (!watchEnded && event === lastEvent && record === lastRecord &&
+                (process.hrtime()[0] - lastSend) < ONE_MINUTE_SECS) {
+            // Nothing has changed or we sent an event less than a minute ago.
+            attemptDone(false);
+            return;
+        }
+
+        lastSend = process.hrtime()[0];
+
+        // Write new progress_history entries.
+        if (record && record !== lastRecord) {
+            lastRecord = record;
+
+            if (record.progress_history &&
+                    record.progress_history.length > nextProgressIdx) {
+                for (var idx = nextProgressIdx;
+                        idx < record.progress_history.length; idx++) {
+                    res.write(JSON.stringify(
+                        translateProgressEntry(record.progress_history[idx])) +
+                        '\n');
+                }
+                nextProgressIdx = record.progress_history.length;
+            }
+
+            if (record.state !== 'running') {
+                log.trace({state: record.state},
+                    'migration watch record no longer running');
+                watchEnded = true;
+                watchErrorMsg = record.state !== 'successful' && record.error;
+            }
+        }
+
+        // Write progress entry.
+        if (event && event !== lastEvent) {
+            lastEvent = event;
+            res.write(JSON.stringify(event) + '\n');
+        }
+
+        // Delay the next progress send (to avoid burning CPU).
+        attemptDone(true);
+    }
+
+    vasync.whilst(connectedAndRunning, sendProgress,
+            function _onWatchWhilstCb(err) {
+
+        var record = MIGRATION_RECORD_FOR_VM_UUID[vmUuid];
+        var phase = record && record.phase || req.vmMigration.phase;
+
+        log.debug({err: err, socketClosed: socketClosed},
+            'watchVmMigration:: vasync.whilst finished');
+
+        if (socketClosed) {
+            return;
+        }
+
+        if (err) {
+            res.write(JSON.stringify({
+                type: 'end',
+                phase: phase,
+                state: 'failed',
+                message: err.message || String(err)
+            }) + '\n');
+        } else if (watchErrorMsg) {
+            res.write(JSON.stringify({
+                type: 'end',
+                phase: phase,
+                state: 'failed',
+                message: watchErrorMsg
+            }) + '\n');
+        } else if (record) {
+            res.write(JSON.stringify({
+                type: 'end',
+                phase: phase,
+                state: record.state,
+                message: record.error
+            }) + '\n');
+        } else {
+            res.write(JSON.stringify({
+                type: 'end',
+                phase: phase,
+                state: 'unknown'
+            }) + '\n');
+        }
+
+        res.end();
+    });
+
+    next();
+}
+
+
+function onProgress(req, res, next) {
+    assert.object(req, 'req');
+    assert.object(req.log, 'req.log');
+    assert.object(res, 'res');
+    assert.func(next, 'next');
+
+    if (!req.params.uuid) {
+        next(new restify.errors.InternalError('No vm uuid provided'));
+        return;
+    }
+
+    if (!req.body || !req.body.type || req.body.type !== 'progress') {
+        next(new restify.errors.InternalError('No progress event provided'));
+        return;
+    }
+
+    MIGRATION_PROGRESS_FOR_VM_UUID[req.params.uuid] = req.body;
+
+    res.send(200);
+    next();
+}
+
+
+function updateVmServerUuid(req, res, next) {
+    assert.object(req, 'req');
+    assert.object(req.params, 'req.params');
+    assert.uuid(req.params.server_uuid, 'req.params.server_uuid');
+    assert.object(req.vm, 'req.vm');
+    assert.object(res, 'res');
+    assert.func(next, 'next');
+
+    req.vm.server_uuid = req.params.server_uuid;
+    next();
+}
+
+
+module.exports = {
+    getVmMigration: getVmMigration,
+    loadVmMigration: loadVmMigration,
+    listVmMigrations: listVmMigrations,
+    migrateVm: migrateVm,
+    onProgress: onProgress,
+    preloadNetworkParams: preloadNetworkParams,
+    storeMigrationRecord: storeMigrationRecord,
+    updateVmServerUuid: updateVmServerUuid,
+    watchVmMigration: watchVmMigration
+};
diff --git a/lib/workflows/job-common.js b/lib/workflows/job-common.js
index 8df7f20..89df227 100644
--- a/lib/workflows/job-common.js
+++ b/lib/workflows/job-common.js
@@ -12,9 +12,12 @@
  * A brief overview of this source file: what is its purpose.
  */
 
+var assert = require('assert-plus');
 var restify = require('restify');
 var async = require('async');
-var papiUrl;
+var cnapiUrl;
+var vmapiUrl;
+var wfapiUrl;
 
 
 /*
@@ -150,6 +153,9 @@ function waitTask(job, cb) {
                 job.log.debug({vm_uuid: job.finished_vm.uuid},
                     'finish() returned VM');
             }
+            if (job.store_task_result_in_attribute) {
+                job[job.store_task_result_in_attribute] = task;
+            }
 
             cb(null, 'Job succeeded!');
         } else {
@@ -301,6 +307,78 @@ function pollTask(job, cb) {
     }
 }
 
+
+/*
+ * Poll a job until it reaches either the succeeded or failed state.
+ */
+function waitForWorkflowJob(job, cb) {
+    assert.string(wfapiUrl, 'wfapiUrl');
+    assert.optionalString(job.workflow_job_uuid, 'job.workflow_job_uuid');
+
+    if (!job.workflow_job_uuid) {
+        cb(null, 'OK - no workflow job uuid to wait for');
+        return;
+    }
+
+    var attempts = 0;
+    var attemptLimit = 10 * 60; // 10 minutes
+    var errors = 0;
+    var interval = 1000; // 1 second
+    var jobUuid = job.workflow_job_uuid;
+
+    var wfapi = restify.createJsonClient({
+        url: wfapiUrl,
+        headers: {'x-request-id': job.params['x-request-id']}
+    });
+
+    function pollJob() {
+        wfapi.get('/jobs/' + jobUuid, function (err, req, res, theJob) {
+            attempts++;
+
+            if (err) {
+                errors++;
+                if (errors >= 5) {
+                    cb(err);
+                    return;
+                }
+
+                setTimeout(pollJob, interval);
+                return;
+            }
+
+            if (theJob.execution === 'succeeded') {
+                cb(null, 'OK - job ' + jobUuid + ' ran successfully');
+                return;
+            }
+
+            if (theJob.execution === 'canceled') {
+                cb('Job ' + jobUuid + ' was canceled');
+                return;
+            }
+
+            if (theJob.execution === 'failed') {
+                var result = theJob.chain_results.pop();
+                if (result.error) {
+                    cb(result.error.message || String(result.error));
+                    return;
+                }
+                cb('Job ' + jobUuid + ' failed');
+                return;
+            }
+
+            if (attempts > attemptLimit) {
+                cb('Timed out waiting for job ' + jobUuid);
+                return;
+            }
+
+            setTimeout(pollJob, interval);
+        });
+    }
+
+    pollJob();
+}
+
+
 function putVm(job, cb) {
     var vmapi;
 
@@ -1072,6 +1150,79 @@ function releaseVMTicket(job, cb) {
 }
 
 
+function releaseVMTicketIgnoringErr(job, cb) {
+    if (!job.ticket) {
+        cb();
+        return;
+    }
+    var cnapi = new sdcClients.CNAPI({
+        url: cnapiUrl,
+        headers: { 'x-request-id': job.params['x-request-id'] }
+    });
+    cnapi.waitlistTicketRelease(job.ticket.uuid, function (err) {
+        if (err) {
+            cb(null, 'OK - ignoring CNAPI ticket release error: ' + err);
+            return;
+        }
+        cb(null, 'OK - CNAPI ticket released successfully');
+    });
+}
+
+
+function acquireAllocationTicket(job, cb) {
+    var cnapi = new sdcClients.CNAPI({
+        url: cnapiUrl,
+        headers: { 'x-request-id': job.params['x-request-id'] }
+    });
+
+    var newTicket = {
+        scope: 'vm-allocate',
+        id: 'global',
+        expires_at: (new Date(
+            Date.now() + 60 * 1000).toISOString()),
+        action: 'allocate',
+        workflow_job_uuid: job.uuid
+    };
+
+    cnapi.waitlistTicketCreate('default', newTicket, onCreate);
+
+
+    function onCreate(err, ticket) {
+        if (err) {
+            cb(err);
+            return;
+        }
+
+        cnapi.waitlistTicketGet(
+            ticket.uuid, function (geterr, getticket)
+        {
+            if (geterr) {
+                cb(geterr);
+                return;
+            }
+            job.allocationTicket = getticket;
+            cb();
+        });
+    }
+}
+
+
+function waitOnAllocationTicket(job, cb) {
+    var cnapi = new sdcClients.CNAPI({
+        url: cnapiUrl,
+        headers: { 'x-request-id': job.params['x-request-id'] }
+    });
+
+    var allocationTicket = job.allocationTicket;
+
+    if (allocationTicket.status === 'active') {
+        return cb();
+    }
+
+    cnapi.waitlistTicketWait(allocationTicket.uuid, cb);
+}
+
+
 function releaseAllocationTicket(job, cb) {
     var ticket = job.allocationTicket;
 
@@ -1111,6 +1262,120 @@ module.exports = {
     acquireVMTicket: acquireVMTicket,
     waitOnVMTicket: waitOnVMTicket,
     releaseVMTicket: releaseVMTicket,
+    releaseVMTicketIgnoringErr: releaseVMTicketIgnoringErr,
+    acquireAllocationTicket: acquireAllocationTicket,
+    waitOnAllocationTicket: waitOnAllocationTicket,
     releaseAllocationTicket: releaseAllocationTicket,
-    clearSkipZoneAction: clearSkipZoneAction
+    clearSkipZoneAction: clearSkipZoneAction,
+
+    tasks: {
+        validateForZoneAction: {
+            name: 'common.validate_params',
+            timeout: 20,
+            retry: 1,
+            body: validateForZoneAction,
+            modules: {}
+        },
+        zoneAction: {
+            name: 'common.zoneAction',
+            timeout: 300,
+            retry: 1,
+            body: zoneAction,
+            modules: {
+                restify: 'restify'
+            }
+        },
+        waitTask: {
+            name: 'common.wait_task',
+            timeout: 300,
+            retry: 1,
+            body: waitTask,
+            modules: {
+                sdcClients: 'sdc-clients'
+            }
+        },
+        waitForWorkflowJob: {
+            name: 'common.waitForWorkflowJob',
+            timeout: 300,
+            retry: 1,
+            body: waitForWorkflowJob,
+            modules: {
+                assert: 'assert-plus',
+                restify: 'restify'
+            }
+        },
+        waitForSync: {
+            name: 'common.waitForSync',
+            timeout: 6 * 60 * 60, // 6 hours
+            retry: 1,
+            body: waitForWorkflowJob,
+            modules: {
+                assert: 'assert-plus',
+                restify: 'restify'
+            }
+        },
+        acquireAllocationTicket: {
+            name: 'dapi.acquire_allocation_ticket',
+            timeout: 60,
+            retry: 1,
+            body: acquireAllocationTicket,
+            modules: {
+                sdcClients: 'sdc-clients'
+            }
+        },
+        acquireVMTicket: {
+            name: 'cnapi.acquire_vm_ticket',
+            timeout: 60,
+            retry: 1,
+            body: acquireVMTicket,
+            modules: {
+                sdcClients: 'sdc-clients'
+            }
+        },
+        waitOnAllocationTicket: {
+            name: 'dapi.wait_on_allocation_ticket',
+            timeout: 180,
+            retry: 1,
+            body: waitOnAllocationTicket,
+            modules: {
+                sdcClients: 'sdc-clients'
+            }
+        },
+        waitOnVMTicket: {
+            name: 'cnapi.wait_on_vm_ticket',
+            timeout: 180,
+            retry: 1,
+            body: waitOnVMTicket,
+            modules: {
+                sdcClients: 'sdc-clients'
+            }
+        },
+        releaseAllocationTicket: {
+            name: 'dapi.release_allocation_ticket',
+            timeout: 60,
+            retry: 1,
+            body: releaseAllocationTicket,
+            modules: {
+                sdcClients: 'sdc-clients'
+            }
+        },
+        releaseVMTicket: {
+            name: 'cnapi.release_vm_ticket',
+            timeout: 60,
+            retry: 1,
+            body: releaseVMTicket,
+            modules: {
+                sdcClients: 'sdc-clients'
+            }
+        },
+        releaseVMTicketIgnoringErr: {
+            name: 'cnapi.release_vm_ticket_ignore_err',
+            timeout: 60,
+            retry: 1,
+            body: releaseVMTicketIgnoringErr,
+            modules: {
+                sdcClients: 'sdc-clients'
+            }
+        }
+    }
 };
diff --git a/lib/workflows/migrate-abort.js b/lib/workflows/migrate-abort.js
new file mode 100644
index 0000000..44579ab
--- /dev/null
+++ b/lib/workflows/migrate-abort.js
@@ -0,0 +1,78 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2019, Joyent, Inc.
+ */
+
+/*
+ * Used to abort a migration.
+ *
+ * Preconditions:
+ *  - migration state can only be 'paused' or 'failed'
+ *  - the target instance must still have DNI set
+ */
+
+var abort = require('./vm-migration/abort');
+var common = require('./job-common');
+var migrationCommon = require('./vm-migration/common');
+var modSwitch = require('./vm-migration/switch');
+
+var VERSION = '1.0.0';
+
+var workflow = module.exports = {
+    name: 'migrate-abort-' + VERSION,
+    version: VERSION,
+    timeout: 15 * 60, // 15 minutes
+
+    chain: [
+        common.tasks.validateForZoneAction,
+
+        migrationCommon.tasks.validate,
+
+        common.tasks.acquireVMTicket,
+        common.tasks.waitOnVMTicket,
+
+        migrationCommon.tasks.storeInitialRecord,
+
+        abort.tasks.ensureTargetVmHasDni,
+
+        modSwitch.tasks.unreserveNetworkIps,
+        // Do we know if it was migration that stopped the VM?
+        // modSwitch.tasks.startSourceVm,
+
+        // From this point on we cannot allow a retry of any commands.
+        migrationCommon.tasks.disallowRetry,
+
+        /* Destroy the target vm. */
+        abort.tasks.deleteTargetDniVm,
+        common.tasks.waitTask,
+
+        /* Destroy any leftover sync snapshots */
+        modSwitch.tasks.removeSourceSnapshots,
+        common.tasks.waitTask,
+
+        /* All done - record final details and store as successful */
+        // modSwitch.tasks.recordServerDetails,
+        migrationCommon.tasks.storeSuccess,
+
+        common.tasks.releaseVMTicket
+    ],
+
+    onerror: [
+        // TODO: Mark original vm as the main vm.
+        migrationCommon.tasks.storeFailure,
+        modSwitch.tasks.unreserveNetworkIps,
+        common.tasks.releaseVMTicketIgnoringErr
+    ],
+
+    oncancel: [
+        // TODO: Mark original vm as the main vm.
+        migrationCommon.tasks.storeFailure,
+        modSwitch.tasks.unreserveNetworkIps,
+        common.tasks.releaseVMTicketIgnoringErr
+    ]
+};
diff --git a/lib/workflows/migrate-begin.js b/lib/workflows/migrate-begin.js
new file mode 100644
index 0000000..870116f
--- /dev/null
+++ b/lib/workflows/migrate-begin.js
@@ -0,0 +1,69 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2019, Joyent, Inc.
+ */
+
+/*
+ * Used to migrate an instance, run via this workflow job.
+ */
+
+var common = require('./job-common');
+var migrationBegin = require('./vm-migration/begin');
+var migrationCommon = require('./vm-migration/common');
+
+var VERSION = '1.0.0';
+
+
+var workflow = module.exports = {
+    name: 'migrate-begin-' + VERSION,
+    version: VERSION,
+    timeout: 1200,
+
+    chain: [
+        common.tasks.validateForZoneAction,
+
+        migrationCommon.tasks.validate,
+
+        migrationBegin.tasks.createProvisionPayload,
+
+        common.tasks.acquireAllocationTicket,
+        common.tasks.waitOnAllocationTicket,
+
+        migrationBegin.tasks.allocateServer,
+
+        common.tasks.releaseAllocationTicket,
+
+        common.tasks.acquireVMTicket,
+        common.tasks.waitOnVMTicket,
+
+        migrationCommon.tasks.storeInitialRecord,
+
+        migrationCommon.tasks.disallowRetry,
+
+        /* Other vm actions are allowed now. */
+        common.tasks.releaseVMTicket,
+
+        migrationBegin.tasks.provisionVm,
+
+        migrationCommon.tasks.storeSuccess,
+
+        migrationBegin.tasks.startSyncWhenAutomatic
+    ],
+
+    onerror: [
+        migrationCommon.tasks.storeFailure,
+        common.tasks.releaseAllocationTicket,
+        common.tasks.releaseVMTicketIgnoringErr
+    ],
+
+    oncancel: [
+        migrationCommon.tasks.storeFailure,
+        common.tasks.releaseAllocationTicket,
+        common.tasks.releaseVMTicketIgnoringErr
+    ]
+};
diff --git a/lib/workflows/migrate-pause.js b/lib/workflows/migrate-pause.js
new file mode 100644
index 0000000..9cf1465
--- /dev/null
+++ b/lib/workflows/migrate-pause.js
@@ -0,0 +1,63 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2019, Joyent, Inc.
+ */
+
+/*
+ * Used to migrate an instance, run via this workflow job.
+ */
+
+var common = require('./job-common');
+var cleanupSource = require('./vm-migration/cleanup_source');
+var cleanupTarget = require('./vm-migration/cleanup_target');
+var migrationCommon = require('./vm-migration/common');
+var pause = require('./vm-migration/pause');
+
+var VERSION = '1.0.0';
+
+var workflow = module.exports = {
+    name: 'migrate-pause-' + VERSION,
+    version: VERSION,
+    timeout: 1800,
+
+    chain: [
+        common.tasks.validateForZoneAction,
+
+        migrationCommon.tasks.validate,
+
+        common.tasks.acquireVMTicket,
+        common.tasks.waitOnVMTicket,
+
+        pause.tasks.validateSyncIsRunning,
+
+        pause.tasks.cancelSyncWorkflow,
+
+        /* Stop any old migration processes that are still running. */
+        cleanupSource,
+        cleanupTarget,
+
+        pause.tasks.markSyncPaused,
+        migrationCommon.tasks.storeRecord,
+
+        common.tasks.releaseVMTicket
+    ],
+
+    onerror: [
+        cleanupSource,
+        cleanupTarget,
+        migrationCommon.tasks.storeFailure,
+        common.tasks.releaseVMTicketIgnoringErr
+    ],
+
+    oncancel: [
+        cleanupSource,
+        cleanupTarget,
+        migrationCommon.tasks.storeFailure,
+        common.tasks.releaseVMTicketIgnoringErr
+    ]
+};
diff --git a/lib/workflows/migrate-switch.js b/lib/workflows/migrate-switch.js
new file mode 100644
index 0000000..1409856
--- /dev/null
+++ b/lib/workflows/migrate-switch.js
@@ -0,0 +1,122 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2019, Joyent, Inc.
+ */
+
+/*
+ * Used to migrate an instance, run via this workflow job.
+ */
+
+var common = require('./job-common');
+var migrationCommon = require('./vm-migration/common');
+var modSwitch = require('./vm-migration/switch');
+
+var VERSION = '1.0.0';
+
+var workflow = module.exports = {
+    name: 'migrate-switch-' + VERSION,
+    version: VERSION,
+    timeout: 7 * 60 * 60, // 7 hours
+
+    chain: [
+        common.tasks.validateForZoneAction,
+
+        migrationCommon.tasks.validate,
+
+        common.tasks.acquireVMTicket,
+        common.tasks.waitOnVMTicket,
+        migrationCommon.tasks.setRecordStateRunning,
+        common.tasks.releaseVMTicket,
+
+        /* Stop the vm */
+        modSwitch.tasks.stopVm,
+        common.tasks.waitForWorkflowJob,
+
+        /* Run the final sync */
+        modSwitch.tasks.startFinalSync,
+        common.tasks.waitForSync,
+
+        common.tasks.acquireVMTicket,
+        common.tasks.waitOnVMTicket,
+
+        /* Update and then write the 'switch' migration record. */
+        modSwitch.tasks.getRecord,
+        migrationCommon.tasks.storeInitialRecord,
+
+        modSwitch.tasks.ensureVmStopped,
+
+        /* Switch over instances. */
+        modSwitch.tasks.reserveNetworkIps,
+        modSwitch.tasks.storeReservedNetworkIps,
+
+        modSwitch.tasks.setupTargetFilesystem,
+        common.tasks.waitTask,
+
+        modSwitch.tasks.setTargetVmAutoboot,
+        common.tasks.waitTask,
+
+        // From this point on we cannot allow a retry of the switch.
+        migrationCommon.tasks.disallowRetry,
+
+        modSwitch.tasks.setSourceDoNotInventory,
+        common.tasks.waitTask,
+
+        // Dev note: brief window here where the vm could appear to have
+        // been destroyed (i.e. both have 'do_not_inventory' set).
+
+        modSwitch.tasks.updateVmServerUuid,
+
+        modSwitch.tasks.removeTargetDoNotInventory,
+        common.tasks.waitTask,
+
+        /* Destroy any leftover sync snapshots */
+        modSwitch.tasks.removeSourceSnapshots,
+        common.tasks.waitTask,
+        modSwitch.tasks.removeTargetSnapshots,
+        common.tasks.waitTask,
+
+        /* All done - record final details and store as successful */
+        // modSwitch.tasks.recordServerDetails,
+        migrationCommon.tasks.storeSuccess,
+
+        common.tasks.releaseVMTicket,
+
+        /* Restart the vm */
+        modSwitch.tasks.startTargetVm,
+        common.tasks.waitForWorkflowJob
+    ],
+
+    onerror: [
+        // TODO: Mark original vm as the main vm.
+        migrationCommon.tasks.storeFailure,
+        modSwitch.tasks.unreserveNetworkIps,
+        modSwitch.tasks.startSourceVm,
+
+        {
+            name: 'on_error.release_vm_ticket',
+            modules: {
+                sdcClients: 'sdc-clients'
+            },
+            body: common.releaseVMTicketIgnoringErr
+        }
+    ],
+
+    oncancel: [
+        // TODO: Mark original vm as the main vm.
+        migrationCommon.tasks.storeFailure,
+        modSwitch.tasks.unreserveNetworkIps,
+        modSwitch.tasks.startSourceVm,
+        {
+            name: 'on_cancel.release_vm_ticket',
+            modules: {
+                sdcClients: 'sdc-clients'
+            },
+            body: common.releaseVMTicketIgnoringErr
+        }
+    ]
+};
diff --git a/lib/workflows/migrate-sync.js b/lib/workflows/migrate-sync.js
new file mode 100644
index 0000000..1a0355a
--- /dev/null
+++ b/lib/workflows/migrate-sync.js
@@ -0,0 +1,76 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2019, Joyent, Inc.
+ */
+
+/*
+ * Used to migrate an instance, run via this workflow job.
+ */
+
+var common = require('./job-common');
+var cleanupSource = require('./vm-migration/cleanup_source');
+var cleanupTarget = require('./vm-migration/cleanup_target');
+var migrationCommon = require('./vm-migration/common');
+var migrationSync = require('./vm-migration/sync');
+
+var VERSION = '1.0.0';
+
+var workflow = module.exports = {
+    name: 'migrate-sync-' + VERSION,
+    version: VERSION,
+    timeout: 60 * 60 * 24, // 1 day
+
+    chain: [
+        common.tasks.validateForZoneAction,
+
+        migrationCommon.tasks.validate,
+
+        common.tasks.acquireVMTicket,
+        common.tasks.waitOnVMTicket,
+
+        /* Stop any old migration processes that are still running. */
+        cleanupSource,
+        cleanupTarget,
+
+        migrationCommon.tasks.storeInitialRecord,
+
+        /* Other vm actions are allowed now. */
+        common.tasks.releaseVMTicket,
+
+        /* Start source migration listener process. */
+        migrationCommon.tasks.setupCnapiSource,
+        common.tasks.waitTask,
+
+        /* Start target migration listener process. */
+        migrationCommon.tasks.setupCnapiTarget,
+        common.tasks.waitTask,
+
+        migrationCommon.tasks.storeProcessDetails,
+
+        /* Do the sync */
+        migrationSync.tasks.sync,
+
+        migrationCommon.tasks.storeSuccess,
+
+        migrationSync.tasks.startSyncOrSwitchWhenAutomatic
+    ],
+
+    onerror: [
+        cleanupSource,
+        cleanupTarget,
+        migrationCommon.tasks.storeFailure,
+        common.tasks.releaseVMTicketIgnoringErr
+    ],
+
+    oncancel: [
+        cleanupSource,
+        cleanupTarget,
+        migrationCommon.tasks.storeFailure,
+        common.tasks.releaseVMTicketIgnoringErr
+    ]
+};
diff --git a/lib/workflows/provision.js b/lib/workflows/provision.js
index 19aae13..aea964b 100644
--- a/lib/workflows/provision.js
+++ b/lib/workflows/provision.js
@@ -150,9 +150,10 @@ function preparePayload(job, cb) {
         params['brand'] = 'lx';
     }
 
-    var keys = [ 'alias', 'autoboot', 'billing_id', 'brand', 'cpu_cap',
-        'cpu_shares', 'customer_metadata', 'delegate_dataset', 'dns_domain',
-        'docker', 'firewall_enabled', 'firewall_rules', 'fs_allowed',
+    var keys = [ 'alias', 'autoboot', 'billing_id', 'brand',
+        'cpu_cap', 'cpu_shares', 'customer_metadata',
+        'delegate_dataset', 'dns_domain', 'docker', 'do_not_inventory',
+        'firewall_enabled', 'firewall_rules', 'fs_allowed',
         'hostname', 'indestructible_zoneroot', 'indestructible_delegated',
         'init_name', 'internal_metadata', 'kernel_version', 'limit_priv',
         'maintain_resolvers', 'max_locked_memory', 'max_lwps', 'max_msg_ids',
diff --git a/lib/workflows/vm-migration/abort.js b/lib/workflows/vm-migration/abort.js
new file mode 100644
index 0000000..afc362c
--- /dev/null
+++ b/lib/workflows/vm-migration/abort.js
@@ -0,0 +1,127 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2019, Joyent, Inc.
+ */
+
+
+var assert = require('assert-plus');
+var restify = require('restify');
+
+
+function ensureTargetVmHasDni(job, cb) {
+    var record = job.params.migrationTask.record;
+
+    assert.uuid(record.target_vm_uuid, 'record.target_vm_uuid');
+    assert.uuid(record.target_server_uuid, 'record.target_server_uuid');
+
+    var cnapi = restify.createJsonClient({
+        url: cnapiUrl,
+        headers: {'x-request-id': job.params['x-request-id']}
+    });
+
+    var url = '/servers/' +
+        record.target_server_uuid + '/vms/' +
+        record.target_vm_uuid + '?include_dni=true';
+    job.store_task_result_in_attribute = 'targetVm';
+
+    cnapi.get(url, function _cnapiGetTargetDniVmCb(err, req, res, vm) {
+        if (err) {
+            if (err.statusCode === 404) {
+                // Vm not found - okay that makes our job easier.
+                cb(null, 'OK - target instance does not exist');
+                return;
+            }
+            cb(err);
+            return;
+        }
+
+        if (!vm.do_not_inventory) {
+            cb('Target instance does not have the do_not_inventory flag');
+            return;
+        }
+
+        cb(null, 'OK - target instance exists and has do_not_inventory flag');
+    });
+}
+
+
+function deleteTargetDniVm(job, cb) {
+    var record = job.params.migrationTask.record;
+
+    assert.uuid(record.target_vm_uuid, 'record.target_vm_uuid');
+    assert.uuid(record.target_server_uuid, 'record.target_server_uuid');
+
+    // Send a progress event.
+    var rawVmapi = restify.createJsonClient({
+        log: job.log,
+        headers: {'x-request-id': job.params['x-request-id']},
+        url: vmapiUrl
+    });
+    var progressUrl = '/migrations/' + job.params.vm_uuid + '/progress';
+    var event = {
+        current_progress: 70,
+        message: 'removing the reserved instance',
+        phase: 'abort',
+        state: 'running',
+        total_progress: 100,
+        type: 'progress'
+    };
+    rawVmapi.post(progressUrl, event, function _onNotifyProgressCb(err) {
+        if (err) {
+            job.log.warn({err: err, event: event},
+                'Unable to notify progress event: ' + err);
+        }
+        // Intentially no callback here (fire and forget).
+    });
+
+    // Remove the target vm.
+    var cnapi = restify.createJsonClient({
+        url: cnapiUrl,
+        headers: {'x-request-id': job.params['x-request-id']}
+    });
+
+    var url = '/servers/' +
+        record.target_server_uuid + '/vms/' +
+        record.target_vm_uuid + '?include_dni=true';
+
+    cnapi.del(url, function _cnapiDelTargetDniVmCb(err, req, res, task) {
+        if (err) {
+            cb(err);
+            return;
+        }
+
+        job.taskId = task.id;
+        cb(null, 'OK - task id: ' + task.id + ' queued to CNAPI!');
+    });
+}
+
+
+module.exports = {
+    tasks: {
+        deleteTargetDniVm: {
+            name: 'migration.abort.deleteTargetDniVm',
+            timeout: 180,
+            // retry: 1,
+            body: deleteTargetDniVm,
+            modules: {
+                assert: 'assert-plus',
+                restify: 'restify'
+            }
+        },
+        ensureTargetVmHasDni: {
+            name: 'migration.abort.ensureTargetVmHasDni',
+            timeout: 180,
+            // retry: 1,
+            body: ensureTargetVmHasDni,
+            modules: {
+                assert: 'assert-plus',
+                restify: 'restify'
+            }
+        }
+    }
+};
diff --git a/lib/workflows/vm-migration/begin.js b/lib/workflows/vm-migration/begin.js
new file mode 100644
index 0000000..bd8b0ea
--- /dev/null
+++ b/lib/workflows/vm-migration/begin.js
@@ -0,0 +1,354 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2019, Joyent, Inc.
+ */
+
+
+var restify = require('restify');
+var sdcClients = require('sdc-clients');
+
+
+function createProvisionPayload(job, cb) {
+    var record = job.params.migrationTask.record;
+
+    // Shallow clone for an object.
+    function clone(theObj) {
+        if (null === theObj || 'object' != typeof (theObj)) {
+            return theObj;
+        }
+
+        var copy = theObj.constructor();
+
+        for (var attr in theObj) {
+            if (theObj.hasOwnProperty(attr)) {
+                copy[attr] = theObj[attr];
+            }
+        }
+        return copy;
+    }
+
+
+    var vmPayload = job.vmPayload = clone(job.params.vm);
+
+    // Mark as a migrating instance.
+    vmPayload.do_not_inventory = true;
+    vmPayload.vm_migration_target = true;
+
+    // Allow overriding the UUID and alias (which would be maintained
+    // otherwise) for testing.
+    vmPayload.uuid = record.target_vm_uuid;
+    if (job.params.override_alias) {
+        vmPayload.alias = job.params.override_alias;
+    }
+
+    vmPayload.autoboot = false;
+
+    delete vmPayload.server_uuid;
+    delete vmPayload.state;
+    delete vmPayload.zone_state;
+    delete vmPayload.pid;
+    delete vmPayload.tmpfs;
+
+    // Docker - filter out filesystems that are added through the docker
+    // provisioning process.
+    if (vmPayload.brand === 'lx' && vmPayload.docker === true &&
+            Array.isArray(vmPayload.filesystems)) {
+        vmPayload.filesystems = vmPayload.filesystems.filter(
+            function _filterFilesystems(entry) {
+                if (entry.type === 'lofs' &&
+                        (entry.target === '/etc/resolv.conf' ||
+                        entry.target === '/etc/hosts' ||
+                        entry.target === '/etc/hostname')) {
+                    return false;
+                }
+                return true;
+            });
+    }
+
+    // Convert nics into networks.
+    vmPayload.networks = [];
+    if (vmPayload.nics) {
+        vmPayload.networks = vmPayload.nics.map(function _nicToMac(nic) {
+            var netObj = {
+                mac: nic.mac,
+                uuid: nic.network_uuid
+            };
+            if (nic.primary) {
+                netObj.primary = nic.primary;
+            }
+            return netObj;
+        });
+
+        delete vmPayload.nics;
+    }
+
+    // Convert disks.
+    if (vmPayload.disks) {
+        vmPayload.disks.forEach(function (disk) {
+            // If image_uuid is defined - you cannot also define disk size
+            // properties. The disk size properties will be set from the image
+            // during provisioning.
+            if (disk.image_uuid) {
+                delete disk.size;
+                delete disk.block_size;
+                delete disk.refreservation;
+            }
+
+            // You cannot specify a path for a disk unless you set nocreate=true
+            if (disk.path && !disk.nocreate) {
+                // XXX: TODO: Could this cause a change to the resulting disk
+                // path?
+                delete disk.path;
+            }
+
+            // Cannot specify zfs_filesystem.
+            delete disk.zfs_filesystem;
+        });
+    }
+
+    // BHYVE hack - set cpu_type to 'host' when it's not set, otherwise the
+    // provision will fail.
+    if (vmPayload.brand === 'bhyve' && vmPayload.cpu_type === null) {
+        if (vmPayload.image && vmPayload.image.cpu_type) {
+            vmPayload.cpu_type = vmPayload.image.cpu_type;
+        } else {
+            vmPayload.cpu_type = 'host';
+        }
+        job.log.info({cpu_type: vmPayload.cpu_type}, 'setting cpu_type');
+    }
+
+    cb(null, 'created vm migrate target payload');
+}
+
+/*
+ * Selects a server for the VM. This function will send VM, image, package and
+ * NIC tag requirements to DAPI, and let it figure out which server best fits
+ * the requirements.
+ *
+ * Note that if you pass params['server_uuid'], this function will terminate
+ * early, because you have already specified the server you want to provision.
+ */
+function allocateServer(job, cb) {
+    var pkg = job.params.package;
+    var img = job.params.image;
+    var filteredNetworks = job.params.filteredNetworks;
+    var record = job.params.migrationTask.record;
+
+    if (!filteredNetworks) {
+        cb('filteredNetworks param must be present');
+        return;
+    }
+
+    if (!img) {
+        cb('Image is required');
+        return;
+    }
+
+    if (record.target_server_uuid) {
+        job.vmPayload.server_uuid = record.target_server_uuid;
+        cb(null, 'Server UUID present, no need to get allocation from DAPI');
+        return;
+    }
+
+    // There is no sdc-client for CNAPI's DAPI yet
+    var cnapi = restify.createJsonClient({
+        url: cnapiUrl,
+        headers: { 'x-request-id': job.params['x-request-id'] }
+    });
+
+    /*
+     * Determine the nic tag requirements from the loaded network objects.
+     */
+    var nicTagReqs = [];
+
+    filteredNetworks.netInfo.forEach(function (net) {
+        if (net.nic_tags_present) {
+            nicTagReqs.push(net.nic_tags_present);
+        } else {
+            nicTagReqs.push([ net.nic_tag ]);
+        }
+    });
+
+    /*
+     * In case we're talking to an older DAPI from before heterogeneous pools
+     * were supported, we select the first tag from each list of alternatives.
+     */
+    var nicTags = nicTagReqs.map(function extractFirstTag(arr) {
+        return arr[0];
+    });
+
+
+    // Make sure our VM is placed on a CN away from the old VM.
+    job.vmPayload.locality = {
+        far: job.vmPayload.server_uuid
+    };
+
+    // The vmPayload must use vm.vm_uuid (not sure why it's different), anyway,
+    // copy it across.
+    job.vmPayload.vm_uuid = job.vmPayload.uuid;
+
+    var payload = {
+        vm: job.vmPayload,
+        image: img,
+        package: pkg,
+        nic_tags: nicTags,
+        nic_tag_requirements: nicTagReqs
+    };
+
+    job.log.info({ dapiPayload: payload }, 'Payload sent to DAPI');
+
+    cnapi.post('/allocate', payload, function finish(err, req, res, body) {
+        if (err) {
+            cb(err.message || err);
+            return;
+        }
+
+        var server_uuid = body.server.uuid;
+
+        // Ensure the allocated server is different. The only case we allow the
+        // same server is for testing in COAL, where we are also changing the
+        // target vm uuid.
+        if (server_uuid === record.source_server_uuid &&
+                record.vm_uuid === record.target_vm_uuid) {
+            cb('Failed to allocate the instance to a different server');
+            return;
+        }
+
+        job.vmPayload.server_uuid = server_uuid;
+
+        cb(null, 'VM allocated to Server ' + server_uuid);
+    });
+}
+
+
+function provisionVm(job, cb) {
+    var vmapi = new sdcClients.VMAPI({
+        log: job.log,
+        headers: { 'x-request-id': job.params['x-request-id'] },
+        url: vmapiUrl
+    });
+    job.log.info({vm_payload: job.vmPayload}, 'creating vm migration target');
+    vmapi.createVmAndWait(job.vmPayload, function _onCreateVmCb(vmErr, vmJob) {
+        var errorMsg;
+        var record = job.params.migrationTask.record;
+        var target_server_uuid;
+
+        var progressEntry = record.progress_history[
+            job.params.migrationTask.progressIdx];
+
+        if (vmErr) {
+            errorMsg = String(vmErr.message || vmErr).trim();
+
+            // Sometimes we get back a huge vmadm error string, so we try and
+            // do the best and just grab the first line from such a string.
+            // Note that the vmadm string can come back escaped (e.g. '\\n').
+            if (errorMsg && errorMsg.indexOf('\n') > 1) {
+                progressEntry.errorDetail = errorMsg;
+                errorMsg = errorMsg.split('\n')[0];
+            } else if (errorMsg && errorMsg.indexOf('\\n') > 1) {
+                progressEntry.errorDetail = errorMsg;
+                errorMsg = errorMsg.split('\\n')[0];
+            }
+
+            progressEntry.message = 'reserving instance failed - ' + errorMsg;
+            cb(errorMsg);
+            return;
+        }
+
+        // Record where the server landed.
+        if (!vmJob || !vmJob.server_uuid) {
+            cb('ERROR - create vm job missing server_uuid field');
+            return;
+        }
+
+        target_server_uuid = vmJob.server_uuid;
+        record.target_server_uuid = target_server_uuid;
+        progressEntry.provision_job_uuid = vmJob.uuid;
+
+        cb(null, 'OK - reservation provisioned successfully to server ' +
+            target_server_uuid + ', in job: ' + vmJob.uuid);
+    });
+}
+
+
+function startSyncWhenAutomatic(job, cb) {
+    var record = job.params.migrationTask.record;
+
+    if (!record.automatic) {
+        cb(null, 'OK - ignoring since this is not an automatic migration');
+        return;
+    }
+
+    var rawVmapi = restify.createJsonClient({
+        log: job.log,
+        headers: {'x-request-id': job.params['x-request-id']},
+        url: vmapiUrl
+    });
+
+    var url = '/vms/' + job.params.vm_uuid +
+        '?action=migrate' +
+        '&migration_action=sync' +
+        '&is_migration_subtask=true'; // Keep record in the 'running' state.
+    rawVmapi.post(url, function (err, req, res, body) {
+        if (err) {
+            cb(err);
+            return;
+        }
+
+        if (!body.job_uuid) {
+            cb(new Error('No job_uuid returned in migration sync call'));
+            return;
+        }
+
+        cb(null, 'OK - sync started, job: ' + body.job_uuid);
+    });
+}
+
+
+module.exports = {
+    tasks: {
+        createProvisionPayload: {
+            name: 'migration.createProvisionPayload',
+            timeout: 60,
+            retry: 1,
+            body: createProvisionPayload,
+            modules: {
+                restify: 'restify',
+                sdcClients: 'sdc-clients'
+            }
+        },
+        allocateServer: {
+            name: 'migration.dapi.allocateServer',
+            timeout: 300,
+            retry: 1,
+            body: allocateServer,
+            modules: {
+                restify: 'restify'
+            }
+        },
+        provisionVm: {
+            name: 'migration.provisionVm',
+            timeout: 900,
+            retry: 1,
+            body: provisionVm,
+            modules: {
+                restify: 'restify',
+                sdcClients: 'sdc-clients'
+            }
+        },
+        startSyncWhenAutomatic: {
+            name: 'migration.startSyncWhenAutomatic',
+            timeout: 120,
+            retry: 1,
+            body: startSyncWhenAutomatic,
+            modules: {
+                restify: 'restify'
+            }
+        }
+    }
+};
diff --git a/lib/workflows/vm-migration/cleanup_source.js b/lib/workflows/vm-migration/cleanup_source.js
new file mode 100644
index 0000000..e1d8d66
--- /dev/null
+++ b/lib/workflows/vm-migration/cleanup_source.js
@@ -0,0 +1,211 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2019, Joyent, Inc.
+ */
+
+
+var net = require('net');
+
+var assert = require('assert-plus');
+var restify = require('restify');
+var vasync = require('vasync');
+
+
+function migration_cleanup_old_source_processes(job, cb) {
+    var action = job.params.migrationTask.action;
+    var record = job.params.migrationTask.record;
+    var cbMsg = null;
+    var log = job.log;
+
+    if (!record || !record.source_process_details ||
+            record.source_process_details.pid === -1) {
+        cb(null, 'OK - no source_process_details in the migration record');
+        return;
+    }
+
+    if (action !== 'sync' && action !== 'pause') {
+        cb(null, 'OK - not applicable for action ' + action);
+        return;
+    }
+
+    assert.object(record.source_process_details,
+        'record.source_process_details');
+    assert.string(record.source_process_details.host,
+        'record.source_process_details.host');
+    assert.number(record.source_process_details.pid,
+        'record.source_process_details.pid');
+    assert.number(record.source_process_details.port,
+        'record.source_process_details.port');
+
+    vasync.pipeline({arg: {}, funcs: [
+        // Connect to the source host:port and ask nicely for it to stop.
+        function _nicelyStopSourceProcesses(ctx, next) {
+            var data = '';
+            var endedSuccessfully = false;
+            var errMsg = null;
+            var host = record.source_process_details.host;
+            var port = record.source_process_details.port;
+
+            var sock = new net.Socket();
+
+            sock.setTimeout(2 * 60 * 1000);  // 2 minutes
+
+            log.debug({source_process_details: record.source_process_details},
+                'migration_cleanup: connecting to cn-agent process');
+
+            sock.on('error', function _onSocketError(err) {
+                if (err.code === 'ECONNREFUSED') {
+                    // This is normal - the process probably isn't running.
+                    log.info('migration_cleanup: socket not listening');
+                    next();
+                    return;
+                }
+                log.warn('migration_cleanup: socket error:', err);
+                // Continue to the next vasync pipeline function.
+                sock.destroy();
+                next();
+            });
+
+            sock.on('timeout', function _onSocketTimeout() {
+                log.warn('migration_cleanup: socket timeout');
+                // Continue to the next vasync pipeline function.
+                sock.destroy();
+                next();
+            });
+
+            sock.on('readable', function _onSockReadable() {
+                var chunk;
+                while (null !== (chunk = sock.read())) {
+                    data += String(chunk);
+                }
+            });
+
+            function processResponse() {
+                var event;
+
+                try {
+                    event = JSON.parse(data);
+                } catch (ex) {
+                    log.warn('Ignoring bad JSON data:', data);
+                    return;
+                }
+
+                assert.string(event.type, 'event.type');
+
+                if (event.type === 'error') {
+                    log.error({event: event},
+                        'received "error" event from cn-agent source process');
+                    errMsg = event.message;
+                    sock.destroy();
+                    return;
+                }
+
+                assert.equal(event.type, 'response');
+
+                switch (event.command) {
+                    case 'end':
+                        log.info('received "end" from cn-agent source process');
+                        endedSuccessfully = true;
+                        sock.destroy();
+                        break;
+                    case 'stop':
+                        log.info('received "stop" from target process');
+                        sock.destroy();
+                        break;
+                    default:
+                        log.warn({event: event},
+                            'Ignoring unknown JSON event:', data);
+                        break;
+                }
+            }
+
+            sock.on('end', function _onSockEnd() {
+                processResponse();
+
+                log.info({endedSuccessfully: endedSuccessfully, errMsg: errMsg},
+                    'migration_cleanup: sock ended');
+
+                if (errMsg) {
+                    next(new Error(errMsg));
+                    return;
+                }
+
+                if (!endedSuccessfully) {
+                    next(new Error('No "end" event from cn-agent process'));
+                    return;
+                }
+
+                ctx.endedSuccessfully = true;
+                cbMsg = 'OK - source process ended successfully';
+                next(null);
+            });
+
+            function sendSockEvent(event) {
+                event.type = 'request';
+                sock.write(JSON.stringify(event) + '\n');
+            }
+
+            function onSockConnect() {
+                log.debug(
+                    'migration_cleanup: cn-agent process socket connected');
+                sendSockEvent({command: 'stop'});
+            }
+
+            sock.connect({host: host, port: port}, onSockConnect);
+        },
+
+        // If nice didn't work - go an kill it.
+        function _killSourceProcesses(ctx, next) {
+            var pid = record.source_process_details.pid;
+
+            if (ctx.endedSuccessfully || pid === -1) {
+                next();
+                return;
+            }
+
+            var cnapi = restify.createJsonClient({
+                url: cnapiUrl,
+                headers: { 'x-request-id': job.params['x-request-id'] }
+            });
+            var url = '/servers/' +
+                job.params['server_uuid'] + '/vms/' +
+                job.params['vm_uuid'] + '/migrate';
+            var payload = {
+                action: 'kill_migration_process',
+                migrationTask: {
+                    action: action,
+                    record: record
+                },
+                pid: pid,
+                vm_uuid: job.params.vm_uuid
+            };
+
+            cnapi.post(url, payload, next);
+        }
+    ]}, function _pipelineCb(err) {
+        if (err) {
+            cb(err);
+            return;
+        }
+        cb(null, cbMsg || 'OK - source process is ended');
+    });
+}
+
+
+module.exports = {
+    name: 'migration_cleanup_old_source_processes',
+    timeout: 180,
+    retry: 2,
+    body: migration_cleanup_old_source_processes,
+    modules: {
+        assert: 'assert-plus',
+        net: 'net',
+        restify: 'restify',
+        vasync: 'vasync'
+    }
+};
diff --git a/lib/workflows/vm-migration/cleanup_target.js b/lib/workflows/vm-migration/cleanup_target.js
new file mode 100644
index 0000000..ad25583
--- /dev/null
+++ b/lib/workflows/vm-migration/cleanup_target.js
@@ -0,0 +1,211 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2019, Joyent, Inc.
+ */
+
+
+var net = require('net');
+
+var assert = require('assert-plus');
+var restify = require('restify');
+var vasync = require('vasync');
+
+
+function migration_cleanup_old_target_processes(job, cb) {
+    var action = job.params.migrationTask.action;
+    var record = job.params.migrationTask.record;
+    var cbMsg = null;
+    var log = job.log;
+
+    if (!record || !record.target_process_details ||
+            record.target_process_details.pid === -1) {
+        cb(null, 'OK - no target_process_details in the migration record');
+        return;
+    }
+
+    if (action !== 'sync' && action !== 'pause') {
+        cb(null, 'OK - not applicable for action ' + action);
+        return;
+    }
+
+    assert.object(record.target_process_details,
+        'record.target_process_details');
+    assert.string(record.target_process_details.host,
+        'record.target_process_details.host');
+    assert.number(record.target_process_details.pid,
+        'record.target_process_details.pid');
+    assert.number(record.target_process_details.port,
+        'record.target_process_details.port');
+
+    vasync.pipeline({arg: {}, funcs: [
+        // Connect to the target host:port and ask nicely for it to stop.
+        function _nicelyStopTargetProcesses(ctx, next) {
+            var data = '';
+            var endedSuccessfully = false;
+            var errMsg = null;
+            var host = record.target_process_details.host;
+            var port = record.target_process_details.port;
+
+            var sock = new net.Socket();
+
+            sock.setTimeout(2 * 60 * 1000);  // 2 minutes
+
+            log.debug({target_process_details: record.target_process_details},
+                'migration_cleanup: connecting to cn-agent process');
+
+            sock.on('error', function _onSocketError(err) {
+                if (err.code === 'ECONNREFUSED') {
+                    // This is normal - the process probably isn't running.
+                    log.info('migration_cleanup: socket not listening');
+                    next();
+                    return;
+                }
+                log.warn('migration_cleanup: socket error:', err);
+                // Continue to the next vasync pipeline function.
+                sock.destroy();
+                next();
+            });
+
+            sock.on('timeout', function _onSocketTimeout() {
+                log.warn('migration_cleanup: socket timeout');
+                // Continue to the next vasync pipeline function.
+                sock.destroy();
+                next();
+            });
+
+            sock.on('readable', function _onSockReadable() {
+                var chunk;
+                while (null !== (chunk = sock.read())) {
+                    data += String(chunk);
+                }
+            });
+
+            function processResponse() {
+                var event;
+
+                try {
+                    event = JSON.parse(data);
+                } catch (ex) {
+                    log.warn('Ignoring bad JSON data:', data);
+                    return;
+                }
+
+                assert.string(event.type, 'event.type');
+
+                if (event.type === 'error') {
+                    log.error({event: event},
+                        'received "error" event from cn-agent target process');
+                    errMsg = event.message;
+                    sock.destroy();
+                    return;
+                }
+
+                assert.equal(event.type, 'response');
+
+                switch (event.command) {
+                    case 'end':
+                        log.info('received "end" from cn-agent target process');
+                        endedSuccessfully = true;
+                        sock.destroy();
+                        break;
+                    case 'stop':
+                        log.info('received "stop" from target process');
+                        sock.destroy();
+                        break;
+                    default:
+                        log.warn({event: event},
+                            'Ignoring unknown JSON event:', data);
+                        break;
+                }
+            }
+
+            sock.on('end', function _onSockEnd() {
+                processResponse();
+
+                log.info({endedSuccessfully: endedSuccessfully, errMsg: errMsg},
+                    'migration_cleanup: sock ended');
+
+                if (errMsg) {
+                    next(new Error(errMsg));
+                    return;
+                }
+
+                if (!endedSuccessfully) {
+                    next(new Error('No "end" event from cn-agent process'));
+                    return;
+                }
+
+                ctx.endedSuccessfully = true;
+                cbMsg = 'OK - target process ended successfully';
+                next(null);
+            });
+
+            function sendSockEvent(event) {
+                event.type = 'request';
+                sock.write(JSON.stringify(event) + '\n');
+            }
+
+            function onSockConnect() {
+                log.debug(
+                    'migration_cleanup: cn-agent process socket connected');
+                sendSockEvent({command: 'stop'});
+            }
+
+            sock.connect({host: host, port: port}, onSockConnect);
+        },
+
+        // If nice didn't work - go an kill it.
+        function _killSourceProcesses(ctx, next) {
+            var pid = record.target_process_details.pid;
+
+            if (ctx.endedSuccessfully || pid === -1) {
+                next();
+                return;
+            }
+
+            var cnapi = restify.createJsonClient({
+                url: cnapiUrl,
+                headers: { 'x-request-id': job.params['x-request-id'] }
+            });
+            var url = '/servers/' +
+                record.target_server_uuid + '/vms/' +
+                job.params['vm_uuid'] + '/migrate';
+            var payload = {
+                action: 'kill_migration_process',
+                migrationTask: {
+                    action: action,
+                    record: record
+                },
+                pid: pid,
+                vm_uuid: job.params.vm_uuid
+            };
+
+            cnapi.post(url, payload, next);
+        }
+    ]}, function _pipelineCb(err) {
+        if (err) {
+            cb(err);
+            return;
+        }
+        cb(null, cbMsg || 'OK - source process is ended');
+    });
+}
+
+
+module.exports = {
+    name: 'migration_cleanup_old_target_processes',
+    timeout: 180,
+    retry: 2,
+    body: migration_cleanup_old_target_processes,
+    modules: {
+        assert: 'assert-plus',
+        net: 'net',
+        restify: 'restify',
+        vasync: 'vasync'
+    }
+};
diff --git a/lib/workflows/vm-migration/common.js b/lib/workflows/vm-migration/common.js
new file mode 100644
index 0000000..c8af75b
--- /dev/null
+++ b/lib/workflows/vm-migration/common.js
@@ -0,0 +1,690 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2019, Joyent, Inc.
+ */
+
+
+var assert = require('assert-plus');
+var restify = require('restify');
+
+
+function validate(job, cb) {
+    assert.object(job.params.vm, 'job.params.vm');
+    assert.string(job.params.vm_uuid, 'job.params.vm_uuid');
+
+    if (typeof (job.params.migrationTask) !== 'object') {
+        cb('Error - no migrationTask object defined');
+        return;
+    }
+
+    if (!job.params.migrationTask.action) {
+        cb('Error - no migrationTask.action defined');
+        return;
+    }
+
+    if (typeof (job.params.migrationTask.record) !== 'object') {
+        cb('Error - no migrationTask.record object defined');
+        return;
+    }
+
+    var action = job.params.migrationTask.action;
+    var record = job.params.migrationTask.record;
+
+    // Keep a running history of the record (for debugging purposes).
+    job.migrationRecordHistory = [record];
+
+    var VALID_MIGRATION_ACTIONS = [
+        'abort',
+        'pause',
+        'begin',
+        'switch',
+        'sync'
+    ];
+
+    if (VALID_MIGRATION_ACTIONS.indexOf(action) === -1) {
+        cb('Error - invalid migration action: ' + action);
+        return;
+    }
+
+    var EXPECTED_FIELDS = [
+        'created_timestamp',
+        'id',
+        'phase',
+        'source_server_uuid',
+        'state',
+        'vm_uuid'
+    ];
+    var missingFields = EXPECTED_FIELDS.filter(function fieldFilter(field) {
+        return (!record[field]);
+    });
+    if (missingFields.length > 0) {
+        cb('Error - invalid migration record, missing: ' + missingFields);
+        return;
+    }
+
+    // For switch actions, validate that at least one successful sync operation
+    // has been performed.
+    if (action === 'switch' && !record.num_sync_phases) {
+        cb('Error - must perform one "sync" operation before switching');
+        return;
+    }
+
+    // Put the action in the job (provides info for cnapi ticket allocation).
+    if (!job.action) {
+        job.action = 'migration-' + action;
+    }
+
+    cb(null, 'OK - migration action "' + action + '" is valid, ' +
+        'migration id: ' + record.id);
+}
+
+
+function disallowRetry(job, cb) {
+    job.migrationDisallowRetry = true;
+    cb(null, 'OK - disallowing retry of this phase');
+}
+
+/*
+ * Sets up the cnapi source process.
+ *
+ * Take a look at common.zoneAction. Here you can set parameters such as:
+ * - request endpoint (usually the VM endpoint)
+ * - jobid (so CNAPI can post status updates back to the job info object)
+ * - requestMethod
+ * - expects (if you want to check a specific running status of the machine)
+ */
+function setupCnapiSource(job, cb) {
+    var action = job.params.migrationTask.action;
+    var record = job.params.migrationTask.record;
+
+    job.endpoint = '/servers/' +
+                   record.source_server_uuid + '/vms/' +
+                   record.vm_uuid + '/migrate';
+    job.params.action = action;
+    job.params.jobid = job.uuid;
+    job.expects = 'running';
+    job.action = 'migrate';
+    job.server_uuid = job.params['server_uuid'];
+
+    // Used to keep the task result around.
+    job.store_task_result_in_attribute = 'source_cn_result';
+
+    // Not using sdc-clients to allow calling generic POST actions without
+    // explicitly saying: startVm, stopVm, etc
+    var cnapi = restify.createJsonClient({
+        url: cnapiUrl,
+        headers: {'x-request-id': job.params['x-request-id']}
+    });
+
+    function callback(err, req, res, task) {
+        if (err) {
+            cb(err);
+            return;
+        }
+
+        job.taskId = task.id;
+        cb(null, 'Migration source task id: ' + task.id + ' queued to CNAPI!');
+    }
+
+    cnapi.post(job.endpoint, job.params, callback);
+}
+
+
+/*
+ * Set up the cnapi receiver process on the target server.
+ *
+ * Take a look at common.zoneAction. Here you can set parameters such as:
+ * - request endpoint (usually the VM endpoint)
+ * - jobid (so CNAPI can post status updates back to the job info object)
+ * - requestMethod
+ * - expects (if you want to check a specific running status of the machine)
+ */
+function setupCnapiTarget(job, cb) {
+    var action = job.params.migrationTask.action;
+    var record = job.params.migrationTask.record;
+
+    if (action === 'begin') {
+        cb(null, 'OK - not applicable for action ' + action);
+        return;
+    }
+
+    assert.string(record.target_server_uuid, 'record.target_server_uuid');
+
+    job.endpoint = '/servers/' +
+                   record.target_server_uuid + '/vms/' +
+                   record.target_vm_uuid + '/migrate';
+    job.action = 'migrate';
+    job.params.action = 'receive';
+
+    // Used to keep the task result around.
+    job.store_task_result_in_attribute = 'target_cn_result';
+
+    // Not using sdc-clients to allow calling generic POST actions without
+    // explicitly saying: startVm, stopVm, etc
+    var cnapi = restify.createJsonClient({
+        url: cnapiUrl,
+        headers: {'x-request-id': job.params['x-request-id']}
+    });
+
+    function callback(err, req, res, task) {
+        if (err) {
+            cb(err);
+            return;
+        }
+
+        job.taskId = task.id;
+        cb(null, 'Migration target task id: ' + task.id + ' queued to CNAPI!');
+    }
+
+    cnapi.post(job.endpoint, job.params, callback);
+}
+
+
+/**
+ * Set the record state to 'running'.
+ */
+function setRecordStateRunning(job, cb) {
+    var record = job.params.migrationTask.record;
+    delete record.error;
+
+    record.state = 'running';
+
+    // There is no progress entry yet.
+    job.params.migrationTask.progressIdx = -1;
+
+    // Keep a running history of the record (debugging purposes).
+    job.migrationRecordHistory.push(record);
+
+    // Store the migration record.
+    var rawVmapi = restify.createJsonClient({
+        log: job.log,
+        headers: { 'x-request-id': job.params['x-request-id'] },
+        url: vmapiUrl
+    });
+    var url = '/migrations/' + job.params.vm_uuid + '/store';
+
+    rawVmapi.post(url, record,
+            function _createMigrationRecordCb(err, req, res) {
+        if (err) {
+            cb(err);
+            return;
+        }
+
+        // TODO: Store ETag?
+        job.params.migrationTask.record = record;
+
+        cb(null, 'OK - stored migration record, id ' + record.id);
+    });
+}
+
+
+/**
+ * Create a new progress entry, add it to the record and then save the record.
+ */
+function storeInitialRecord(job, cb) {
+    var action = job.params.migrationTask.action;
+    var message;
+    var phase = action;
+    var progressEntry;
+    var progressHistory;
+    var record;
+    var startedTimestamp = (new Date()).toISOString();
+
+    // Add record to the existing progress array.
+    record = job.params.migrationTask.record;
+    progressHistory = record.progress_history;
+    if (!progressHistory) {
+        progressHistory = [];
+        record.progress_history = progressHistory;
+    }
+    delete record.error;
+
+    // There are no running cn-agent processes to start with.
+    record.source_process_details = {
+        pid: -1,
+        host: '',
+        port: -1
+    };
+    record.target_process_details = {
+        pid: -1,
+        host: '',
+        port: -1
+    };
+
+    // Create a progress entry.
+    switch (action) {
+        case 'begin':
+            phase = 'begin';
+            message = 'reserving instance';
+            break;
+        case 'abort':
+            message = 'aborting migration';
+            break;
+        case 'pause':
+            message = 'pausing migration';
+            break;
+        case 'sync':
+            message = 'syncing data';
+            break;
+        case 'switch':
+            message = 'switching instances';
+            break;
+        default:
+            message = 'unhandled migration action ' + action;
+            break;
+    }
+
+    record.state = 'running';
+    record.phase = phase;
+
+    progressEntry = {
+        type: 'progress',
+        message: message,
+        phase: phase,
+        state: 'running',
+        started_timestamp: startedTimestamp,
+        current_progress: 1,
+        total_progress: 100,
+        job_uuid: job.uuid
+    };
+
+    job.params.migrationTask.progressIdx = progressHistory.length;
+    progressHistory.push(progressEntry);
+    // Keep a running history of the record (debugging purposes).
+    job.migrationRecordHistory.push(record);
+
+    // Store the migration record.
+    var rawVmapi = restify.createJsonClient({
+        log: job.log,
+        headers: { 'x-request-id': job.params['x-request-id'] },
+        url: vmapiUrl
+    });
+    var url = '/migrations/' + job.params.vm_uuid + '/store';
+
+    rawVmapi.post(url, record,
+            function _createMigrationRecordCb(err, req, res) {
+        if (err) {
+            cb(err);
+            return;
+        }
+
+        // TODO: Store ETag?
+        job.params.migrationTask.record = record;
+
+        cb(null, 'OK - stored migration record, id ' + record.id);
+    });
+}
+
+
+function storeProcessDetails(job, cb) {
+    var action = job.params.migrationTask.action;
+
+    if (action === 'begin') {
+        cb(null, 'OK - not applicable for action ' + action);
+        return;
+    }
+
+    var record = job.params.migrationTask.record;
+    var progressHistory = record.progress_history;
+    var progressEntry = progressHistory[job.params.migrationTask.progressIdx];
+    var task_event;
+
+    /* Store source CN process. */
+    if (job.source_cn_result && job.source_cn_result.history &&
+            job.source_cn_result.history.length > 0 &&
+            job.source_cn_result.history[0].name === 'finish' &&
+            job.source_cn_result.history[0].event) {
+
+        task_event = job.source_cn_result.history[0].event;
+        record.source_process_details = {
+            pid: task_event.pid,
+            host: task_event.host,
+            port: task_event.port
+        };
+    }
+
+    /* Store target CN process. */
+    if (job.target_cn_result && job.target_cn_result.history &&
+            job.target_cn_result.history.length > 0 &&
+            job.target_cn_result.history[0].name === 'finish' &&
+            job.target_cn_result.history[0].event) {
+
+        task_event = job.target_cn_result.history[0].event;
+        record.target_process_details = {
+            pid: task_event.pid,
+            host: task_event.host,
+            port: task_event.port
+        };
+    }
+
+    // Update progress entry.
+    progressEntry.current_progress = 10;
+
+    // Keep a running history of the record (debugging purposes).
+    job.migrationRecordHistory.push(record);
+
+    var rawVmapi = restify.createJsonClient({
+        log: job.log,
+        headers: { 'x-request-id': job.params['x-request-id'] },
+        url: vmapiUrl
+    });
+    var url = '/migrations/' + job.params.vm_uuid + '/store';
+
+    rawVmapi.post(url, record, function _storeMigrationRecordCb(err, req, res) {
+        if (err) {
+            job.log.error({err: err}, 'Unable to store migration record: ' +
+                err);
+            cb(err);
+            return;
+        }
+
+        // TODO: Store ETag?
+        job.params.migrationTask.record = record;
+
+        if (record.source_process_details.pid === -1) {
+            job.log.error('No source CN PID, last task result: %j',
+                job.source_cn_result);
+            cb('Error - no source CN process PID returned from cnapi task');
+            return;
+        }
+
+        if (record.target_process_details.pid === -1) {
+            job.log.error('No target CN PID, last task result: %j',
+                job.target_cn_result);
+            cb('Error - no target CN process PID returned from cnapi task');
+            return;
+        }
+
+        cb(null, 'OK - stored the process details in the migration record');
+    });
+}
+
+
+/**
+ * Save the current migration record as is.
+ */
+function storeRecord(job, cb) {
+    var record = job.params.migrationTask.record;
+
+    // Keep a running history of the record (debugging purposes).
+    job.migrationRecordHistory.push(record);
+
+    var rawVmapi = restify.createJsonClient({
+        log: job.log,
+        headers: { 'x-request-id': job.params['x-request-id'] },
+        url: vmapiUrl
+    });
+    var url = '/migrations/' + job.params.vm_uuid + '/store';
+
+    rawVmapi.post(url, record,
+            function _createMigrationRecordCb(err, req, res) {
+        if (err) {
+            cb(err);
+            return;
+        }
+
+        // TODO: Store ETag?
+        job.params.migrationTask.record = record;
+
+        cb(null, 'OK - stored migration record, id ' + record.id);
+    });
+}
+
+
+function storeSuccess(job, cb) {
+    var action = job.params.migrationTask.action;
+    var record = job.params.migrationTask.record;
+    var progressHistory = record.progress_history;
+    var progressEntry = progressHistory[job.params.migrationTask.progressIdx];
+    var finishedTimestamp = (new Date()).toISOString();
+
+    // Update progress entry.
+    progressEntry.current_progress = progressEntry.total_progress;
+    progressEntry.finished_timestamp = finishedTimestamp;
+    progressEntry.state = 'successful';
+
+    // Update record.
+    record.finished_timestamp = finishedTimestamp;
+    if (action === 'sync') {
+        assert.number(record.num_sync_phases, 'record.num_sync_phases');
+        record.num_sync_phases += 1;
+    }
+
+    if (action === 'abort') {
+        record.state = 'aborted';
+    } else if (action === 'switch') {
+        record.state = 'successful';
+    } else if (record.automatic && (action === 'begin' || action === 'sync')) {
+        record.state = 'running';
+    } else if (job.params.is_migration_subtask) {
+        record.state = 'running';
+    } else {
+        record.state = 'paused';
+    }
+
+    // Clear out the cn-agent process details.
+    record.source_process_details = {
+        pid: -1,
+        host: '',
+        port: -1
+    };
+    record.target_process_details = {
+        pid: -1,
+        host: '',
+        port: -1
+    };
+
+    // Keep a running history of the record (debugging purposes).
+    job.migrationRecordHistory.push(record);
+
+    var rawVmapi = restify.createJsonClient({
+        log: job.log,
+        headers: { 'x-request-id': job.params['x-request-id'] },
+        url: vmapiUrl
+    });
+    var url = '/migrations/' + job.params.vm_uuid + '/store';
+
+    rawVmapi.post(url, record, function _storeRecordCb(err, req, res) {
+        if (err) {
+            job.log.error({err: err}, 'Unable to store migration record: ' +
+                err);
+            cb(err);
+            return;
+        }
+
+        // TODO: Store ETag?
+        job.params.migrationTask.record = record;
+
+        cb(null, 'OK - stored the finished migration record');
+    });
+}
+
+
+/*
+ * Post back to vmapi that the migration failed. It will be up to vmapi to
+ * go and clean up any associated items (provisioned vms, running processes,
+ * etc...)
+ */
+function storeFailure(job, cb) {
+    var action = job.params.migrationTask.action;
+    var record = job.params.migrationTask.record;
+
+    if (!record) {
+        cb(null, 'OK - No migration record to store');
+        return;
+    }
+
+    var progressHistory = record.progress_history;
+    var progressEntry = progressHistory[job.params.migrationTask.progressIdx];
+
+    var finishedTimestamp = (new Date()).toISOString();
+    var taskErrorMsg;
+
+    if (job.chain_results && job.chain_results.length > 0) {
+        var lastTask = job.chain_results.slice(-1)[0];
+        if (lastTask.error) {
+            taskErrorMsg = lastTask.error;
+        }
+    }
+
+    // Update record.
+    record.state = 'failed';
+    record.finished_timestamp = finishedTimestamp;
+    record.error = 'failed to ' + action + ' migration instance';
+    if (taskErrorMsg) {
+        record.error += ' - ' + taskErrorMsg;
+    }
+
+    // Update progress entry.
+    if (!progressEntry) {
+        progressEntry =  {
+            type: 'progress',
+            phase: action,
+            state: 'failed',
+            started_timestamp: new Date(job.started).toISOString(),
+            current_progress: 2,
+            total_progress: 100,
+            job_uuid: job.uuid
+        };
+        progressHistory.push(progressEntry);
+    }
+    progressEntry.finished_timestamp = finishedTimestamp;
+    progressEntry.state = 'failed';
+    if (taskErrorMsg) {
+        progressEntry.error = taskErrorMsg;
+    }
+
+    if (job.migrationDisallowRetry) {
+        progressEntry.disallowRetry = true;
+    } else if (record.phase === 'switch') {
+        // Rollback to state 'sync' - this will allow another attempt at the
+        // switch phase.
+        record.phase = 'sync';
+    }
+
+    // Keep a running history of the record (debugging purposes).
+    if (!Array.isArray(job.migrationRecordHistory)) {
+        job.migrationRecordHistory = [];
+    }
+    job.migrationRecordHistory.push(record);
+
+    var rawVmapi = restify.createJsonClient({
+        log: job.log,
+        headers: { 'x-request-id': job.params['x-request-id'] },
+        url: vmapiUrl
+    });
+    var url = '/migrations/' + job.params.vm_uuid + '/store';
+
+    rawVmapi.post(url, record, function _createMigrationRecordCb(err) {
+        if (err) {
+            job.log.error({err: err}, 'Unable to store migration record: ' +
+                err);
+            cb(null, 'OK - but could not store the migration record');
+            return;
+        }
+
+        cb(null, 'OK - stored record for failed migration action');
+    });
+}
+
+
+module.exports = {
+    tasks: {
+        disallowRetry: {
+            name: 'migration.disallowRetry',
+            timeout: 30,
+            retry: 1,
+            body: disallowRetry,
+            modules: {}
+        },
+        setupCnapiSource: {
+            name: 'migration.setupCnapiSource',
+            timeout: 300,
+            retry: 1,
+            body: setupCnapiSource,
+            modules: {
+                assert: 'assert-plus',
+                restify: 'restify'
+            }
+        },
+        setRecordStateRunning: {
+            name: 'migration.setRecordStateRunning',
+            timeout: 300,
+            retry: 1,
+            body: setRecordStateRunning,
+            modules: {
+                restify: 'restify'
+            }
+        },
+        setupCnapiTarget: {
+            name: 'migration.setupCnapiTarget',
+            timeout: 300,
+            retry: 1,
+            body: setupCnapiTarget,
+            modules: {
+                assert: 'assert-plus',
+                restify: 'restify'
+            }
+        },
+        storeFailure: {
+            name: 'migration.storeFailure',
+            timeout: 180,
+            retry: 1,
+            body: storeFailure,
+            modules: {
+                restify: 'restify'
+            }
+        },
+        storeInitialRecord: {
+            name: 'migration.storeInitialRecord',
+            timeout: 180,
+            retry: 1,
+            body: storeInitialRecord,
+            modules: {
+                restify: 'restify'
+            }
+        },
+        storeProcessDetails: {
+            name: 'migration.storeProcessDetails',
+            timeout: 180,
+            retry: 1,
+            body: storeProcessDetails,
+            modules: {
+                restify: 'restify'
+            }
+        },
+        storeRecord: {
+            name: 'migration.storeRecord',
+            timeout: 180,
+            retry: 1,
+            body: storeRecord,
+            modules: {
+                restify: 'restify'
+            }
+        },
+        storeSuccess: {
+            name: 'migration.storeSuccess',
+            timeout: 180,
+            retry: 1,
+            body: storeSuccess,
+            modules: {
+                assert: 'assert-plus',
+                restify: 'restify'
+            }
+        },
+        validate: {
+            name: 'migration.validate',
+            timeout: 20,
+            retry: 1,
+            body: validate,
+            modules: {
+                assert: 'assert-plus'
+            }
+        }
+    }
+};
diff --git a/lib/workflows/vm-migration/pause.js b/lib/workflows/vm-migration/pause.js
new file mode 100644
index 0000000..d888439
--- /dev/null
+++ b/lib/workflows/vm-migration/pause.js
@@ -0,0 +1,142 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2019, Joyent, Inc.
+ */
+
+
+var restify = require('restify');
+
+var wfapiUrl;
+
+
+function validateSyncIsRunning(job, cb) {
+    var rawVmapi = restify.createJsonClient({
+        log: job.log,
+        headers: { 'x-request-id': job.params['x-request-id'] },
+        url: vmapiUrl
+    });
+    var url = '/migrations/' + job.params.vm_uuid + '?format=raw';
+
+    rawVmapi.get(url, function _getRecordCb(err, req, res, record) {
+        if (err) {
+            job.log.error({err: err}, 'Unable to retrieve migration record: ' +
+                err);
+            cb(err);
+            return;
+        }
+
+        var progressHistory = record.progress_history;
+        var progressEntries = progressHistory.filter(function _filtSync(entry) {
+            return entry.state === 'running' && entry.phase === 'sync';
+        });
+
+        if (progressEntries.length === 0) {
+            cb(new Error('No migration sync phase is currently running'));
+            return;
+        }
+
+        if (progressEntries.length > 1) {
+            cb(new Error('Multiple migration sync phases are running'));
+            return;
+        }
+
+        job.params.migrationTask.record = record;
+        job.params.migrationTask.progressIdx =
+            progressHistory.indexOf(progressEntries[0]);
+
+        cb(null, 'OK - migration sync is currently running');
+    });
+}
+
+
+function cancelSyncWorkflow(job, cb) {
+    var record = job.params.migrationTask.record;
+
+    var progressEntry = record.progress_history[
+        job.params.migrationTask.progressIdx];
+    var jobUuid = progressEntry.job_uuid;
+
+    var wfapi = restify.createJsonClient({
+        url: wfapiUrl,
+        headers: {'x-request-id': job.params['x-request-id']}
+    });
+
+    wfapi.post('/jobs/' + jobUuid + '/cancel', function (err, req, res) {
+        if (err) {
+            job.log.error({err: err}, 'Unable to cancel migration sync job: ' +
+                err);
+            cb(err);
+            return;
+        }
+
+        cb(null, 'OK - migration sync workflow job was canceled');
+    });
+}
+
+
+function markSyncPaused(job, cb) {
+    var record = job.params.migrationTask.record;
+
+    var progressEntry = record.progress_history[
+        job.params.migrationTask.progressIdx];
+
+    // Update progress entry.
+    progressEntry.error = '';
+    progressEntry.state = 'paused';
+    progressEntry.finished_timestamp = (new Date()).toISOString();
+
+    // Update record.
+    record.error = '';
+    record.state = 'paused';
+
+    // Clear out the cn-agent process details.
+    record.source_process_details = {
+        pid: -1,
+        host: '',
+        port: -1
+    };
+    record.target_process_details = {
+        pid: -1,
+        host: '',
+        port: -1
+    };
+
+    cb(null, 'OK - changed migration record to paused state');
+}
+
+
+module.exports = {
+    tasks: {
+        validateSyncIsRunning: {
+            name: 'migration.validateSyncIsRunning',
+            timeout: 180,
+            retry: 1,
+            body: validateSyncIsRunning,
+            modules: {
+                restify: 'restify'
+            }
+        },
+        cancelSyncWorkflow: {
+            name: 'migration.cancelSyncWorkflow',
+            timeout: 600,
+            retry: 1,
+            body: cancelSyncWorkflow,
+            modules: {
+                restify: 'restify'
+            }
+        },
+        markSyncPaused: {
+            name: 'migration.dapi.markSyncPaused',
+            timeout: 30,
+            retry: 1,
+            body: markSyncPaused,
+            modules: {
+            }
+        }
+    }
+};
diff --git a/lib/workflows/vm-migration/switch.js b/lib/workflows/vm-migration/switch.js
new file mode 100644
index 0000000..084285f
--- /dev/null
+++ b/lib/workflows/vm-migration/switch.js
@@ -0,0 +1,963 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2019, Joyent, Inc.
+ */
+
+
+var assert = require('assert-plus');
+var restify = require('restify');
+var sdcClients = require('sdc-clients');
+var vasync = require('vasync');
+
+
+function stopVm(job, cb) {
+    if (job.params.vm.state === 'stopped') {
+        job.workflow_job_uuid = null;
+        cb(null, 'OK - vm is stopped already');
+        return;
+    }
+
+    // Send a progress event.
+    var rawVmapi = restify.createJsonClient({
+        log: job.log,
+        headers: {'x-request-id': job.params['x-request-id']},
+        url: vmapiUrl
+    });
+    var vmapi = new sdcClients.VMAPI({
+        log: job.log,
+        headers: {'x-request-id': job.params['x-request-id']},
+        url: vmapiUrl
+    });
+
+    var progressUrl = '/migrations/' + job.params.vm_uuid + '/progress';
+    var event = {
+        current_progress: 3,
+        message: 'stopping the instance',
+        phase: 'switch',
+        state: 'running',
+        total_progress: 100,
+        type: 'progress'
+    };
+
+    rawVmapi.post(progressUrl, event, function _onNotifyProgressCb(err) {
+        if (err) {
+            job.log.warn({err: err, event: event},
+                'Unable to notify progress event: ' + err);
+        }
+        // Intentially no callback here (fire and forget).
+    });
+
+    vmapi.stopVm({uuid: job.vm_uuid}, function (err, body) {
+        if (err) {
+            cb(err);
+            return;
+        }
+
+        // Set the workflow job uuid for the waitForWorkflowJob step.
+        job.workflow_job_uuid = body.job_uuid;
+        assert.uuid(job.workflow_job_uuid, 'job.workflow_job_uuid');
+
+        cb(null, 'OK - vm stop called, job uuid: ' + body.job_uuid);
+    });
+}
+
+
+function ensureVmStopped(job, cb) {
+    var vmapi = new sdcClients.VMAPI({
+        headers: {'x-request-id': job.params['x-request-id']},
+        url: vmapiUrl
+    });
+
+    vmapi.getVm({uuid: job.vm_uuid}, function (err, vm) {
+        if (err) {
+            cb(err);
+            return;
+        }
+
+        if (vm.state !== 'stopped') {
+            cb(new Error('Vm is no longer stopped - state: ' + vm.state));
+            return;
+        }
+
+        job.vmStopped = vm;
+        cb(null, 'OK - vm is stopped');
+    });
+}
+
+
+function startFinalSync(job, cb) {
+    var rawVmapi = restify.createJsonClient({
+        log: job.log,
+        headers: {'x-request-id': job.params['x-request-id']},
+        url: vmapiUrl
+    });
+
+    var url = '/vms/' + job.params.vm_uuid +
+        '?action=migrate' +
+        '&migration_action=sync' +
+        '&is_final_sync=true' +
+        '&is_migration_subtask=true'; // Keep record in the 'running' state.
+    rawVmapi.post(url, function (err, req, res, body) {
+        if (err) {
+            cb(err);
+            return;
+        }
+
+        if (!body.job_uuid) {
+            cb(new Error('No job_uuid returned in migration sync call'));
+            return;
+        }
+
+        // Set the workflow job uuid for the waitForWorkflowJob step.
+        job.workflow_job_uuid = body.job_uuid;
+        cb(null, 'OK - final migration sync started, job: ' + body.job_uuid);
+    });
+}
+
+
+function getRecord(job, cb) {
+    // Send a progress event.
+    var rawVmapi = restify.createJsonClient({
+        log: job.log,
+        headers: {'x-request-id': job.params['x-request-id']},
+        url: vmapiUrl
+    });
+    var progressUrl = '/migrations/' + job.params.vm_uuid + '/progress';
+    var event = {
+        current_progress: 55,
+        message: 'filesytem sync finished, switching instances',
+        phase: 'switch',
+        state: 'running',
+        total_progress: 100,
+        type: 'progress'
+    };
+    rawVmapi.post(progressUrl, event, function _onNotifyProgressCb(err) {
+        if (err) {
+            job.log.warn({err: err, event: event},
+                'Unable to notify progress event: ' + err);
+        }
+        // Intentially no callback here (fire and forget).
+    });
+
+    // Get the *raw* migration record.
+    var url = '/migrations/' + job.params.vm_uuid + '?format=raw';
+
+    rawVmapi.get(url, function _getRecordCb(err, req, res, record) {
+        if (err) {
+            job.log.error({err: err}, 'Unable to retrieve migration record: ' +
+                err);
+            cb(err);
+            return;
+        }
+
+        job.params.migrationTask.record = record;
+
+        cb(null, 'OK - got the latest migration record');
+    });
+}
+
+
+function reserveNetworkIps(job, cb) {
+    // Send a progress event.
+    var rawVmapi = restify.createJsonClient({
+        log: job.log,
+        headers: {'x-request-id': job.params['x-request-id']},
+        url: vmapiUrl
+    });
+    var progressUrl = '/migrations/' + job.params.vm_uuid + '/progress';
+    var event = {
+        current_progress: 60,
+        message: 'reserving the IP addresses for the instance',
+        phase: 'switch',
+        state: 'running',
+        total_progress: 100,
+        type: 'progress'
+    };
+    rawVmapi.post(progressUrl, event, function _onNotifyProgressCb(err) {
+        if (err) {
+            job.log.warn({err: err, event: event},
+                'Unable to notify progress event: ' + err);
+        }
+        // Intentially no callback here (fire and forget).
+    });
+
+    // Reserve the IPs
+
+    var napi = new sdcClients.NAPI({
+        headers: {'x-request-id': job.params['x-request-id']},
+        url: napiUrl
+    });
+
+    job.migration_reserved_nics = [];
+
+    function reserveNicIP(nic, callback) {
+        // TODO: Can we have multiple ip per nic?
+        var ip = nic.ip;
+        var mac = nic.mac;
+        var network_uuid = nic.network_uuid;
+
+        if (!mac) {
+            callback(new Error('No mac for nic: ' + nic));
+            return;
+        }
+
+        vasync.pipeline({arg: {}, funcs: [
+            function getNetworkUuid(ctx, next) {
+                if (ip && network_uuid) {
+                    next();
+                    return;
+                }
+                napi.getNic(mac, function _onGetNic(err, nicDetails) {
+                    if (err) {
+                        next(err);
+                        return;
+                    }
+                    ip = nicDetails.ip;
+                    network_uuid = nicDetails.network_uuid;
+                });
+            },
+
+            function reserveIP(ctx, next) {
+                if (!ip || !network_uuid) {
+                    next(new Error('No ip or no network_uuid for nic: ' + nic));
+                    return;
+                }
+
+                // Check if the IP is already reserved.
+                napi.getIP(network_uuid, ip, function _onGetIpCb(err, ipObj) {
+                    if (err) {
+                        next(err);
+                        return;
+                    }
+                    if (ipObj.reserved) {
+                        next();
+                        return;
+                    }
+
+                    // Reserve the IP address.
+                    napi.updateIP(network_uuid, ip, {reserved: true},
+                            function _onReserveIpCb(updateErr) {
+                        if (updateErr) {
+                            next(updateErr);
+                            return;
+                        }
+                        // Keep a record of the ip that were reserved.
+                        job.migration_reserved_nics.push(
+                            {network_uuid: network_uuid, ip: ip});
+                        next();
+                    });
+                });
+            }
+        ]}, callback);
+    }
+
+    vasync.forEachParallel({inputs: job.vmStopped.nics, func: reserveNicIP},
+            function _reserveAllNicIPsCb(err) {
+        if (err) {
+            cb(err);
+            return;
+        }
+
+        cb(null, 'OK - reserved ' + job.vmStopped.nics.length + ' ips');
+    });
+}
+
+
+function storeReservedNetworkIps(job, cb) {
+    if (job.migration_reserved_nics.length === 0) {
+        cb(null, 'OK - no reserved IPS');
+        return;
+    }
+
+    var record = job.params.migrationTask.record;
+
+    // Keep an entry in the record.
+    record.reserved_nics = job.migration_reserved_nics;
+
+    // Keep a running history of the record (for debugging purposes).
+    job.migrationRecordHistory.push(record);
+
+    var rawVmapi = restify.createJsonClient({
+        log: job.log,
+        headers: {'x-request-id': job.params['x-request-id']},
+        url: vmapiUrl
+    });
+    var url = '/migrations/' + job.params.vm_uuid + '/store';
+
+    rawVmapi.post(url, record, function _storeRecordCb(err, req, res) {
+        if (err) {
+            job.log.error({err: err}, 'Unable to store migration record: ' +
+                err);
+            cb(err);
+            return;
+        }
+
+        // TODO: Store ETag?
+        job.params.migrationTask.record = record;
+
+        cb(null, 'OK - added the reserved IP addresses to migration record');
+    });
+}
+
+
+function unreserveNetworkIps(job, cb) {
+    if (!Array.isArray(job.migration_reserved_nics) ||
+            job.migration_reserved_nics.length === 0) {
+        cb(null, 'OK - no reserved NICs');
+        return;
+    }
+
+    var napi = new sdcClients.NAPI({
+        headers: {'x-request-id': job.params['x-request-id']},
+        url: napiUrl
+    });
+
+    // Unreserve the IP address.
+    function unreserveNicIp(entry, callback) {
+        var ip = entry.ip;
+        var network_uuid = entry.network_uuid;
+
+        napi.updateIP(network_uuid, ip, {reserved: false}, callback);
+    }
+
+    vasync.forEachParallel({inputs: job.migration_reserved_nics,
+            func: unreserveNicIp},
+            function _unreserveAllNicIpsCb(err) {
+        // TODO: This would be better as a warning, and allowed to continue on?
+        if (err) {
+            cb(err);
+            return;
+        }
+
+        cb(null, 'OK - unreserved ' + job.migration_reserved_nics.length +
+            ' ips');
+    });
+}
+
+
+function setupTargetFilesystem(job, cb) {
+    var record = job.params.migrationTask.record;
+
+    assert.uuid(record.target_vm_uuid, 'record.target_vm_uuid');
+    assert.uuid(record.target_server_uuid, 'record.target_server_uuid');
+
+    // Send a progress event.
+    var rawVmapi = restify.createJsonClient({
+        log: job.log,
+        headers: {'x-request-id': job.params['x-request-id']},
+        url: vmapiUrl
+    });
+    var progressUrl = '/migrations/' + job.params.vm_uuid + '/progress';
+    var event = {
+        current_progress: 65,
+        message: 'setting up the target filesystem',
+        phase: 'switch',
+        state: 'running',
+        total_progress: 100,
+        type: 'progress'
+    };
+    rawVmapi.post(progressUrl, event, function _onNotifyProgressCb(err) {
+        if (err) {
+            job.log.warn({err: err, event: event},
+                'Unable to notify progress event: ' + err);
+        }
+        // Intentially no callback here (fire and forget).
+    });
+
+    var cnapi = restify.createJsonClient({
+        url: cnapiUrl,
+        headers: { 'x-request-id': job.params['x-request-id'] }
+    });
+
+    var url = '/servers/' +
+        record.target_server_uuid + '/vms/' +
+        record.target_vm_uuid + '/migrate';
+    var payload = {
+        action: 'setup-filesystem',
+        migrationTask: job.params.migrationTask,
+        vm: job.params.vm,
+        vm_uuid: record.target_vm_uuid
+    };
+
+    cnapi.post(url, payload, function _addSupportDsCb(err, req, res, task) {
+        if (err) {
+            cb(err);
+            return;
+        }
+
+        job.taskId = task.id;
+        cb(null, 'OK - task id: ' + task.id + ' queued to CNAPI!');
+    });
+}
+
+
+function setTargetVmAutoboot(job, cb) {
+    var record = job.params.migrationTask.record;
+
+    assert.uuid(record.target_server_uuid, 'record.target_server_uuid');
+    assert.uuid(record.target_vm_uuid, 'record.target_vm_uuid');
+
+    var cnapi = restify.createJsonClient({
+        url: cnapiUrl,
+        headers: { 'x-request-id': job.params['x-request-id'] }
+    });
+
+    var url = '/servers/' +
+        record.target_server_uuid + '/vms/' +
+        record.target_vm_uuid + '/migrate';
+    var payload = {
+        action: 'set-autoboot',
+        migrationTask: job.params.migrationTask,
+        vm_uuid: record.target_vm_uuid,
+        value: (job.params.vm.autoboot ? 'true' : 'false')
+    };
+
+    cnapi.post(url, payload, function _setAutobootCb(err, req, res, task) {
+        if (err) {
+            cb(err);
+            return;
+        }
+
+        job.taskId = task.id;
+        cb(null, 'OK - task id: ' + task.id + ' queued to CNAPI!');
+    });
+}
+
+
+function setSourceDoNotInventory(job, cb) {
+    var record = job.params.migrationTask.record;
+
+    assert.uuid(record.source_server_uuid, 'record.source_server_uuid');
+    assert.uuid(record.vm_uuid, 'record.vm_uuid');
+
+    // Send a progress event.
+    var rawVmapi = restify.createJsonClient({
+        log: job.log,
+        headers: {'x-request-id': job.params['x-request-id']},
+        url: vmapiUrl
+    });
+    var progressUrl = '/migrations/' + job.params.vm_uuid + '/progress';
+    var event = {
+        current_progress: 75,
+        message: 'hiding the original instance',
+        phase: 'switch',
+        state: 'running',
+        total_progress: 100,
+        type: 'progress'
+    };
+    rawVmapi.post(progressUrl, event, function _onNotifyProgressCb(err) {
+        if (err) {
+            job.log.warn({err: err, event: event},
+                'Unable to notify progress event: ' + err);
+        }
+        // Intentially no callback here (fire and forget).
+    });
+
+    // Set DNI flag on the source instance.
+    var cnapi = restify.createJsonClient({
+        url: cnapiUrl,
+        headers: { 'x-request-id': job.params['x-request-id'] }
+    });
+    var url = '/servers/' +
+        record.source_server_uuid + '/vms/' +
+        record.vm_uuid + '/migrate';
+    var payload = {
+        action: 'set-do-not-inventory',
+        migrationTask: job.params.migrationTask,
+        vm_uuid: job.params.vm_uuid,
+        value: 'true'
+    };
+
+    cnapi.post(url, payload, function _setDoNotInventory(err, req, res, task) {
+        if (err) {
+            cb(err);
+            return;
+        }
+
+        job.taskId = task.id;
+        cb(null, 'OK - task id: ' + task.id + ' queued to CNAPI!');
+    });
+}
+
+
+function updateVmServerUuid(job, cb) {
+    var record = job.params.migrationTask.record;
+
+    assert.uuid(record.target_server_uuid, 'record.target_server_uuid');
+    assert.uuid(record.target_vm_uuid, 'record.target_vm_uuid');
+    assert.uuid(record.vm_uuid, 'record.vm_uuid');
+
+    // Don't need to do this if the vm uuid is different.
+    if (record.vm_uuid !== record.target_vm_uuid) {
+        cb(null, 'OK - vm_uuid is different on target server - skip');
+        return;
+    }
+
+    var rawVmapi = restify.createJsonClient({
+        log: job.log,
+        headers: {'x-request-id': job.params['x-request-id']},
+        url: vmapiUrl
+    });
+    var url = '/migrations/' + job.params.vm_uuid + '/updateVmServerUuid';
+    var data = {
+        server_uuid: record.target_server_uuid
+    };
+
+    rawVmapi.post(url, data, function _updateVmServerUuidCb(err) {
+        if (err) {
+            job.log.error({err: err},
+                'Unable to switch vm server_uuid: ' + err);
+            cb(err);
+            return;
+        }
+
+        cb(null, 'OK - sent reserverd network IP progress event');
+    });
+}
+
+
+function removeTargetDoNotInventory(job, cb) {
+    // Send a progress event.
+    var rawVmapi = restify.createJsonClient({
+        log: job.log,
+        headers: {'x-request-id': job.params['x-request-id']},
+        url: vmapiUrl
+    });
+    var progressUrl = '/migrations/' + job.params.vm_uuid + '/progress';
+    var event = {
+        current_progress: 85,
+        message: 'promoting the migrated instance',
+        phase: 'switch',
+        state: 'running',
+        total_progress: 100,
+        type: 'progress'
+    };
+    rawVmapi.post(progressUrl, event, function _onNotifyProgressCb(err) {
+        if (err) {
+            job.log.warn({err: err, event: event},
+                'Unable to notify progress event: ' + err);
+        }
+        // Intentially no callback here (fire and forget).
+    });
+
+    // Remove do-not-inventory status.
+    var record = job.params.migrationTask.record;
+
+    assert.uuid(record.target_server_uuid, 'record.target_server_uuid');
+    assert.uuid(record.target_vm_uuid, 'record.target_vm_uuid');
+
+    var cnapi = restify.createJsonClient({
+        url: cnapiUrl,
+        headers: { 'x-request-id': job.params['x-request-id'] }
+    });
+    var vmUuid = record.target_vm_uuid;
+
+    var url = '/servers/' + record.target_server_uuid + '/vms/' + vmUuid +
+        '/migrate';
+    var payload = {
+        action: 'set-do-not-inventory',
+        migrationTask: job.params.migrationTask,
+        vm_uuid: vmUuid,
+        value: 'false'
+    };
+
+    cnapi.post(url, payload, function _remDoNotInventory(err, req, res, task) {
+        if (err) {
+            cb(err);
+            return;
+        }
+
+        job.taskId = task.id;
+        cb(null, 'OK - task id: ' + task.id + ' queued to CNAPI!');
+    });
+}
+
+
+function removeSourceSnapshots(job, cb) {
+    // Send a progress event.
+    var rawVmapi = restify.createJsonClient({
+        log: job.log,
+        headers: {'x-request-id': job.params['x-request-id']},
+        url: vmapiUrl
+    });
+    var progressUrl = '/migrations/' + job.params.vm_uuid + '/progress';
+    var event = {
+        current_progress: 90,
+        message: 'removing sync snapshots',
+        phase: 'switch',
+        state: 'running',
+        total_progress: 100,
+        type: 'progress'
+    };
+    rawVmapi.post(progressUrl, event, function _onNotifyProgressCb(err) {
+        if (err) {
+            job.log.warn({err: err, event: event},
+                'Unable to notify progress event: ' + err);
+        }
+        // Intentially no callback here (fire and forget).
+    });
+
+    // Remove sync snapshots.
+    var record = job.params.migrationTask.record;
+
+    assert.uuid(record.source_server_uuid, 'record.source_server_uuid');
+    assert.uuid(record.vm_uuid, 'record.vm_uuid');
+
+    var cnapi = restify.createJsonClient({
+        url: cnapiUrl,
+        headers: { 'x-request-id': job.params['x-request-id'] }
+    });
+    var vmUuid = record.vm_uuid;
+
+    var url = '/servers/' + record.source_server_uuid + '/vms/' + vmUuid +
+        '/migrate';
+    var payload = {
+        action: 'remove-sync-snapshots',
+        migrationTask: job.params.migrationTask,
+        vm: job.params.vm,
+        vm_uuid: vmUuid
+    };
+
+    cnapi.post(url, payload, function _remDoNotInventory(err, req, res, task) {
+        if (err) {
+            cb(err);
+            return;
+        }
+
+        job.taskId = task.id;
+        cb(null, 'OK - task id: ' + task.id + ' queued to CNAPI!');
+    });
+}
+
+
+function removeTargetSnapshots(job, cb) {
+    var record = job.params.migrationTask.record;
+
+    assert.uuid(record.target_server_uuid, 'record.target_server_uuid');
+    assert.uuid(record.target_vm_uuid, 'record.target_vm_uuid');
+
+    var cnapi = restify.createJsonClient({
+        url: cnapiUrl,
+        headers: { 'x-request-id': job.params['x-request-id'] }
+    });
+    var vmUuid = record.target_vm_uuid;
+
+    var url = '/servers/' + record.target_server_uuid + '/vms/' + vmUuid +
+        '/migrate';
+    var payload = {
+        action: 'remove-sync-snapshots',
+        migrationTask: job.params.migrationTask,
+        vm: job.params.vm,
+        vm_uuid: vmUuid
+    };
+
+    cnapi.post(url, payload, function _remDoNotInventory(err, req, res, task) {
+        if (err) {
+            cb(err);
+            return;
+        }
+
+        job.taskId = task.id;
+        cb(null, 'OK - task id: ' + task.id + ' queued to CNAPI!');
+    });
+}
+
+
+function recordServerDetails(job, cb) {
+    var record = job.params.migrationTask.record;
+
+    // Record where the migration source now resides.
+    record.original_source_server_uuid = record.source_server_uuid;
+    record.source_server_uuid = record.target_server_uuid;
+
+    cb(null, 'OK - instance now on server: ' + record.source_server_uuid);
+}
+
+
+function startTargetVm(job, cb) {
+    // Send a progress event.
+    var rawVmapi = restify.createJsonClient({
+        log: job.log,
+        headers: {'x-request-id': job.params['x-request-id']},
+        url: vmapiUrl
+    });
+    var progressUrl = '/migrations/' + job.params.vm_uuid + '/progress';
+    var event = {
+        current_progress: 95,
+        message: 'starting the migrated instance',
+        phase: 'switch',
+        state: 'running',
+        total_progress: 100,
+        type: 'progress'
+    };
+    rawVmapi.post(progressUrl, event, function _onNotifyProgressCb(err) {
+        if (err) {
+            job.log.warn({err: err, event: event},
+                'Unable to notify progress event: ' + err);
+        }
+        // Intentially no callback here (fire and forget).
+    });
+
+    // Start the VM.
+    var record = job.params.migrationTask.record;
+
+    assert.uuid(record.target_vm_uuid, 'record.target_vm_uuid');
+
+    var vmapi = new sdcClients.VMAPI({
+        headers: {'x-request-id': job.params['x-request-id']},
+        url: vmapiUrl
+    });
+
+    // Ensure that the initial state was running.
+    if (job.params.vm.state !== 'running') {
+        cb(null, 'OK - initial vm state was not running, state: ' +
+            job.params.vm.state);
+        return;
+    }
+
+    vmapi.startVm({uuid: record.target_vm_uuid}, function (err, body) {
+        if (err) {
+            cb(err);
+            return;
+        }
+
+        // Set the workflow job uuid for the waitForWorkflowJob step.
+        job.workflow_job_uuid = body.job_uuid;
+
+        cb(null, 'OK - vm start workflow running, job uuid: ' + body.job_uuid);
+    });
+}
+
+
+function startSourceVm(job, cb) {
+    // Send a progress event.
+    var rawVmapi = restify.createJsonClient({
+        log: job.log,
+        headers: {'x-request-id': job.params['x-request-id']},
+        url: vmapiUrl
+    });
+    var progressUrl = '/migrations/' + job.params.vm_uuid + '/progress';
+    var event = {
+        current_progress: 95,
+        message: 'starting the original instance',
+        phase: 'switch',
+        state: 'running',
+        total_progress: 100,
+        type: 'progress'
+    };
+    rawVmapi.post(progressUrl, event, function _onNotifyProgressCb(err) {
+        if (err) {
+            job.log.warn({err: err, event: event},
+                'Unable to notify progress event: ' + err);
+        }
+        // Intentially no callback here (fire and forget).
+    });
+
+    // Start the source VM.
+    var record = job.params.migrationTask.record;
+
+    assert.uuid(record.vm_uuid, 'record.vm_uuid');
+
+    var vmapi = new sdcClients.VMAPI({
+        headers: {'x-request-id': job.params['x-request-id']},
+        url: vmapiUrl
+    });
+
+    // Ensure that the initial state was running.
+    if (job.params.vm.state !== 'running') {
+        cb(null, 'OK - initial vm state was not running, state: ' +
+            job.params.vm.state);
+        return;
+    }
+
+    vmapi.startVm({uuid: record.vm_uuid}, function (err, body) {
+        if (err) {
+            cb(err);
+            return;
+        }
+
+        // Set the workflow job uuid for the waitForWorkflowJob step.
+        job.workflow_job_uuid = body.job_uuid;
+
+        cb(null, 'OK - vm start workflow running, job uuid: ' + body.job_uuid);
+    });
+}
+
+
+module.exports = {
+    tasks: {
+        ensureVmStopped: {
+            name: 'migration.switch.ensureVmStopped',
+            timeout: 180,
+            // retry: 1,
+            body: ensureVmStopped,
+            modules: {
+                sdcClients: 'sdc-clients'
+            }
+        },
+        getRecord: {
+            name: 'migration.switch.getRecord',
+            timeout: 180,
+            // retry: 1,
+            body: getRecord,
+            modules: {
+                restify: 'restify'
+            }
+        },
+        recordServerDetails: {
+            name: 'migration.switch.recordServerDetails',
+            timeout: 60,
+            retry: 1,
+            body: recordServerDetails,
+            modules: {
+            }
+        },
+        removeSourceSnapshots: {
+            name: 'migration.switch.removeSourceSnapshots',
+            timeout: 300,
+            // retry: 1,
+            body: removeSourceSnapshots,
+            modules: {
+                assert: 'assert-plus',
+                restify: 'restify'
+            }
+        },
+        removeTargetDoNotInventory: {
+            name: 'migration.switch.removeTargetDoNotInventory',
+            timeout: 300,
+            // retry: 1,
+            body: removeTargetDoNotInventory,
+            modules: {
+                assert: 'assert-plus',
+                restify: 'restify'
+            }
+        },
+        removeTargetSnapshots: {
+            name: 'migration.switch.removeTargetSnapshots',
+            timeout: 300,
+            // retry: 1,
+            body: removeTargetSnapshots,
+            modules: {
+                assert: 'assert-plus',
+                restify: 'restify'
+            }
+        },
+        reserveNetworkIps: {
+            name: 'migration.switch.reserveNetworkIps',
+            timeout: 300,
+            // retry: 1,
+            body: reserveNetworkIps,
+            modules: {
+                restify: 'restify',
+                sdcClients: 'sdc-clients',
+                vasync: 'vasync'
+            }
+        },
+        setSourceDoNotInventory: {
+            name: 'migration.switch.setSourceDoNotInventory',
+            timeout: 300,
+            // retry: 1,
+            body: setSourceDoNotInventory,
+            modules: {
+                assert: 'assert-plus',
+                restify: 'restify'
+            }
+        },
+        setupTargetFilesystem: {
+            name: 'migration.switch.setupTargetFilesystem',
+            timeout: 300,
+            // retry: 1,
+            body: setupTargetFilesystem,
+            modules: {
+                assert: 'assert-plus',
+                restify: 'restify'
+            }
+        },
+        setTargetVmAutoboot: {
+            name: 'migration.switch.setTargetVmAutoboot',
+            timeout: 300,
+            // retry: 1,
+            body: setTargetVmAutoboot,
+            modules: {
+                assert: 'assert-plus',
+                restify: 'restify'
+            }
+        },
+        startFinalSync: {
+            name: 'migration.switch.startFinalSync',
+            timeout: 300,
+            // retry: 1,
+            body: startFinalSync,
+            modules: {
+                restify: 'restify'
+            }
+        },
+        startSourceVm: {
+            name: 'migration.switch.startSourceVm',
+            timeout: 300,
+            // retry: 1,
+            body: startSourceVm,
+            modules: {
+                assert: 'assert-plus',
+                restify: 'restify',
+                sdcClients: 'sdc-clients'
+            }
+        },
+        startTargetVm: {
+            name: 'migration.switch.startTargetVm',
+            timeout: 300,
+            // retry: 1,
+            body: startTargetVm,
+            modules: {
+                assert: 'assert-plus',
+                restify: 'restify',
+                sdcClients: 'sdc-clients'
+            }
+        },
+        stopVm: {
+            name: 'migration.switch.stopVm',
+            timeout: 300,
+            // retry: 1,
+            body: stopVm,
+            modules: {
+                assert: 'assert-plus',
+                restify: 'restify',
+                sdcClients: 'sdc-clients'
+            }
+        },
+        storeReservedNetworkIps: {
+            name: 'migration.switch.storeReservedNetworkIps',
+            timeout: 180,
+            retry: 1,
+            body: storeReservedNetworkIps,
+            modules: {
+                restify: 'restify'
+            }
+        },
+        unreserveNetworkIps: {
+            name: 'migration.switch.unreserveNetworkIps',
+            timeout: 300,
+            // retry: 1,
+            body: unreserveNetworkIps,
+            modules: {
+               sdcClients: 'sdc-clients',
+                vasync: 'vasync'
+            }
+        },
+        updateVmServerUuid: {
+            name: 'migration.switch.updateVmServerUuid',
+            timeout: 300,
+            // retry: 1,
+            body: updateVmServerUuid,
+            modules: {
+                assert: 'assert-plus',
+                restify: 'restify'
+            }
+        }
+    }
+};
diff --git a/lib/workflows/vm-migration/sync.js b/lib/workflows/vm-migration/sync.js
new file mode 100644
index 0000000..138e58b
--- /dev/null
+++ b/lib/workflows/vm-migration/sync.js
@@ -0,0 +1,468 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2019, Joyent, Inc.
+ */
+
+
+var buffer = require('buffer');
+var net = require('net');
+var stream = require('stream');
+var timers = require('timers');
+var util = require('util');
+
+var assert = require('assert-plus');
+var restify = require('restify');
+var vasync = require('vasync');
+
+
+function migration_sync(job, cb) {
+
+    // // // // // // // // //
+//   node-byline START  //
+// // // // // // // // //
+
+// license: MIT
+// module: https://github.com/jahewson/node-byline/
+//
+// Copyright (C) 2011-2015 John Hewson
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to
+// deal in the Software without restriction, including without limitation the
+// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+// sell copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+// IN THE SOFTWARE.
+//
+// Using the new node v0.10 "streams2" API:
+//
+    function LineStream(options) {
+        stream.Transform.call(this, options);
+        options = options || {};
+
+        // use objectMode to stop the output from being buffered
+        // which re-concatanates the lines, just without newlines.
+        this._readableState.objectMode = true;
+        this._lineBuffer = [];
+        this._keepEmptyLines = options.keepEmptyLines || false;
+        this._lastChunkEndedWithCR = false;
+
+        // take the source's encoding if we don't have one
+        var self = this;
+        this.on('pipe', function LS_onPipe(src) {
+            if (!self.encoding) {
+                // but we can't do this for old-style streams
+                if (src instanceof stream.Readable) {
+                    self.encoding = src._readableState.encoding;
+                }
+            }
+        });
+    }
+    util.inherits(LineStream, stream.Transform);
+
+    LineStream.prototype._transform = function LS_Trans(chunk, encoding, done) {
+        // decode binary chunks as UTF-8
+        encoding = encoding || 'utf8';
+
+        if (buffer.Buffer.isBuffer(chunk)) {
+            if (encoding == 'buffer') {
+                chunk = chunk.toString(); // utf8
+                encoding = 'utf8';
+            } else {
+                chunk = chunk.toString(encoding);
+            }
+        }
+        this._chunkEncoding = encoding;
+
+        // see: http://www.unicode.org/reports/tr18/#Line_Boundaries
+        var lines = chunk.split(/\r\n|[\n\v\f\r\x85\u2028\u2029]/g);
+
+        // don't split CRLF which spans chunks
+        if (this._lastChunkEndedWithCR && chunk[0] == '\n') {
+            lines.shift();
+        }
+
+        if (this._lineBuffer.length > 0) {
+            this._lineBuffer[this._lineBuffer.length - 1] += lines[0];
+            lines.shift();
+        }
+
+        this._lastChunkEndedWithCR = chunk[chunk.length - 1] == '\r';
+        this._lineBuffer = this._lineBuffer.concat(lines);
+        this._pushBuffer(encoding, 1, done);
+    };
+
+    LineStream.prototype._pushBuffer = function LS_pushB(encoding, keep, done) {
+        // always buffer the last (possibly partial) line
+        while (this._lineBuffer.length > keep) {
+            var line = this._lineBuffer.shift();
+            // skip empty lines
+            if (this._keepEmptyLines || line.length > 0) {
+                if (!this.push(line)) {
+                    // when the high-water mark is reached, defer pushes until
+                    // the next tick
+                    var self = this;
+                    timers.setImmediate(function LS_setImmPushB() {
+                        self._pushBuffer(encoding, keep, done);
+                    });
+                    return;
+                }
+            }
+        }
+        done();
+    };
+
+    LineStream.prototype._flush = function LS_flush(done) {
+        this._pushBuffer(this._chunkEncoding, 0, done);
+    };
+
+// // // // // // // // //
+//    node-byline END   //
+// // // // // // // // //
+
+    var record = job.params.migrationTask.record;
+    var progressIdx = job.params.migrationTask.progressIdx;
+
+    // Ensure a valid cn-agent source process.
+    assert.object(record.source_process_details,
+        'record.source_process_details');
+    assert.string(record.source_process_details.host,
+        'record.source_process_details.host');
+    assert.number(record.source_process_details.pid,
+        'record.source_process_details.pid');
+    assert.number(record.source_process_details.port,
+        'record.source_process_details.port');
+
+    // Ensure a valid cn-agent target process.
+    assert.object(record.target_process_details,
+        'record.target_process_details');
+    assert.string(record.target_process_details.host,
+        'record.target_process_details.host');
+    assert.number(record.target_process_details.pid,
+        'record.target_process_details.pid');
+    assert.number(record.target_process_details.port,
+        'record.target_process_details.port');
+
+    assert.number(progressIdx, 'progressIdx');
+    assert.ok(progressIdx >= 0, 'progressIdx >= 0');
+    assert.arrayOfObject(record.progress_history, 'record.progress_history');
+    assert.ok(record.progress_history.length > progressIdx,
+        'record.progress_history.length > progressIdx');
+
+    var callbackFired = false;
+    var endedSuccessfully = false;
+    var eventId = 1;
+    var pendingCallbacks = {};
+    var log = job.log;
+    var host = record.source_process_details.host;
+    var port = record.source_process_details.port;
+    var progressEntry = record.progress_history[progressIdx];
+    var progressPending = false;
+
+    var sock = net.createConnection({ host: host, port: port });
+
+    sock.setTimeout(5 * 60 * 1000);  // 5 minutes
+
+    log.debug({source_process_details: record.source_process_details},
+        'migration_sync: connecting to cn-agent process');
+
+    sock.on('error', function _onSocketError(err) {
+        log.warn('migration_sync: socket error:', err);
+        if (callbackFired) {
+            return;
+        }
+        callbackFired = true;
+        cb(err);
+    });
+
+    sock.on('timeout', function _onSocketTimeout() {
+        log.warn('migration_sync: socket timeout');
+        if (callbackFired) {
+            return;
+        }
+        callbackFired = true;
+        cb(new Error('watch socket timeout'));
+    });
+
+    sock.on('connect', function _onSocketConnect() {
+        log.debug('migration_sync: cn-agent process socket connected');
+
+        startLineReader();
+        runSync();
+    });
+
+    function onProgress(event) {
+        assert.number(event.current_progress, 'event.current_progress');
+        assert.number(event.total_progress, 'event.total_progress');
+
+        progressEntry.current_progress = event.current_progress;
+        progressEntry.total_progress = event.total_progress;
+
+        if (progressPending) {
+            // Whilst there is a pending progress notification, just ignore
+            // these events. Eventually this will free up, or we'll receive a
+            // finish event.
+            log.trace('Already a pending progress event - ignoring this event');
+            return;
+        }
+
+        progressPending = true;
+
+        log.trace({event: event}, 'onProgress: %d%%',
+            Math.round(event.current_progress / event.total_progress * 100));
+
+        var rawVmapi = restify.createJsonClient({
+            connectTimeout: 10 * 1000, // 10 seconds
+            requestTimeout: 30 * 1000, // 30 seconds
+            headers: { 'x-request-id': job.params['x-request-id'] },
+            log: log,
+            retry: false,
+            url: vmapiUrl
+        });
+        var url = '/migrations/' + job.params.vm_uuid + '/progress';
+
+        rawVmapi.post(url, event, function _onNotifyProgressCb(err) {
+            progressPending = false;
+            if (err) {
+                log.warn({err: err, event: event},
+                    'Error in vmapi notify progress request: ' + err);
+            }
+            // Intentially no callback here.
+        });
+    }
+
+    function runSync() {
+        // Start the requested action in the cn-agent process.
+        vasync.pipeline({arg: {}, funcs: [
+
+            function _sendMigrationRecord(ctx, next) {
+                log.info('runSync:: set migration record');
+                var event = {
+                    command: 'set-record',
+                    record: record
+                };
+                sendSockEvent(event, next);
+            },
+
+            function _runZfsSync(ctx, next) {
+                log.info('runSync:: sync');
+                var event = {
+                    command: 'sync',
+                    host: record.target_process_details.host,
+                    port: record.target_process_details.port
+                };
+                sendSockEvent(event, function _startSyncCb(err) {
+                    if (err) {
+                        next(err);
+                        return;
+                    }
+                    next();
+                });
+            },
+
+            function _sendEnd(ctx, next) {
+                log.info('runSync:: send end');
+                sendSockEvent({command: 'end'},
+                        function _endCb(err) {
+                    if (err) {
+                        next(err);
+                        return;
+                    }
+                    endedSuccessfully = true;
+                    next();
+                });
+            }
+        ]}, function _syncPipelineCb(err) {
+            if (callbackFired) {
+                log.warn({err: err},
+                    'Sync pipeline error - callback already fired - ignoring');
+                return;
+            }
+            callbackFired = true;
+            if (err) {
+                log.error({err: err}, 'Sync pipeline error - ending wf');
+                sendSockEvent({command: 'stop'}, function _onStopCb(stopErr) {
+                    // Ignore any return callback errors.
+                    log.info('Got stop callback, stopErr: ', stopErr);
+                    sock.destroy();
+                });
+                cb('Error - ' + err);
+                return;
+            }
+            cb(null, 'OK - sync was successful');
+        });
+    }
+
+    function sendSockEvent(event, callback) {
+        assert.object(event, 'event');
+        assert.string(event.command, 'event.command');
+        assert.func(callback, 'callback');
+
+        pendingCallbacks[eventId] = callback;
+        event.type = 'request';
+        event.eventId = eventId;
+        eventId += 1;
+        sock.write(JSON.stringify(event) + '\n');
+    }
+
+    function startLineReader() {
+        var lstream = new LineStream(LineStream);
+
+        lstream.on('end', function _onLstreamEnd() {
+            log.info({endedSuccessfully: endedSuccessfully},
+                'migration_sync: lstream ended');
+            if (!endedSuccessfully) {
+                log.warn('cn-agent process did not send "end" event');
+                if (callbackFired) {
+                    log.warn('Sync pipeline error - callback already fired ' +
+                        '- ignoring');
+                    return;
+                }
+                callbackFired = true;
+                cb('Error - cn-agent process did not send "end" event');
+                return;
+            }
+        });
+
+        lstream.on('readable', function _readLines() {
+            var line;
+            while (null !== (line = lstream.read())) {
+                processOneResponse(line);
+            }
+        });
+
+        sock.pipe(lstream);
+    }
+
+    function processOneResponse(line) {
+        var event;
+
+        log.trace('processOneResponse:: line: %s', line);
+
+        try {
+            event = JSON.parse(line);
+        } catch (ex) {
+            log.warn('Ignoring bad JSON line:', line);
+            return;
+        }
+
+        assert.string(event.type, 'event.type');
+
+        if (event.type === 'progress') {
+            onProgress(event);
+            return;
+        }
+
+        assert.number(event.eventId, 'event.eventId');
+        assert.func(pendingCallbacks[event.eventId],
+            'pendingCallbacks[event.eventId]');
+
+        var callback = pendingCallbacks[event.eventId];
+        delete pendingCallbacks[event.eventId];
+
+        assert.func(callback, 'pendingCallbacks[event.eventId]');
+
+        if (event.type === 'error') {
+            log.error({event: event},
+                'received "error" event from cn-agent source process');
+            callback(new Error(event.message));
+            return;
+        }
+
+        assert.equal(event.type, 'response');
+
+        callback(null, event);
+    }
+}
+
+
+function startSyncOrSwitchWhenAutomatic(job, cb) {
+    var record = job.params.migrationTask.record;
+
+    if (!record.automatic) {
+        cb(null, 'OK - ignoring since this is not an automatic migration');
+        return;
+    }
+
+    if (job.params.is_final_sync) {
+        cb(null, 'OK - ignoring since this started from migration switch');
+        return;
+    }
+
+    var rawVmapi = restify.createJsonClient({
+        log: job.log,
+        headers: {'x-request-id': job.params['x-request-id']},
+        url: vmapiUrl
+    });
+
+    // TODO: Create a more deterministic way for choosing when to switch:
+    // JSSTYLED
+    // https://github.com/joyent/rfd/blob/master/rfd/0034/README.md#re-sync-algorithm
+
+    var nextaction = (record.num_sync_phases || 0) < 2 ? 'sync' : 'switch';
+    var url = '/vms/' + job.params.vm_uuid +
+        '?action=migrate' +
+        '&migration_action=' + nextaction +
+        '&is_migration_subtask=true'; // Keep record in the 'running' state.
+
+    rawVmapi.post(url, function (err, req, res, body) {
+        if (err) {
+            cb(err);
+            return;
+        }
+
+        if (!body.job_uuid) {
+            cb(new Error('No job_uuid returned for migration ' + nextaction +
+                ' call'));
+            return;
+        }
+
+        cb(null, 'OK - ' + nextaction + ' started, job: ' + body.job_uuid);
+    });
+}
+
+
+module.exports = {
+    tasks: {
+        startSyncOrSwitchWhenAutomatic: {
+            name: 'migration.startSyncOrSwitchWhenAutomatic',
+            timeout: 120,
+            retry: 1,
+            body: startSyncOrSwitchWhenAutomatic,
+            modules: {
+                restify: 'restify'
+            }
+        },
+        sync: {
+            name: 'migration_sync',
+            timeout: 60 * 60 * 24, // 1 day
+            // retry: 1,
+            body: migration_sync,
+            modules: {
+                assert: 'assert-plus',
+                buffer: 'buffer',
+                net: 'net',
+                restify: 'restify',
+                stream: 'stream',
+                timers: 'timers',
+                util: 'util',
+                vasync: 'vasync'
+            }
+        }
+    }
+};
diff --git a/package.json b/package.json
index 95cfd35..c9ad27f 100644
--- a/package.json
+++ b/package.json
@@ -1,7 +1,7 @@
 {
   "name": "vmapi",
   "description": "VMs API",
-  "version": "9.7.3",
+  "version": "9.8.0",
   "author": "Joyent (joyent.com)",
   "private": true,
   "dependencies": {
@@ -19,7 +19,6 @@
     "ldap-filter": "0.3.3",
     "libuuid": "0.2.1",
     "moray": "3.1.1",
-    "nodeunit": "0.9.1",
     "once": "^1.3.3",
     "restify": "4.3.0",
     "sdc-clients": "11.3.1",
@@ -37,6 +36,8 @@
     "vm-agent": ">=1.5.0"
   },
   "devDependencies": {
+    "byline": "5.0.0",
+    "nodeunit": "0.11.3",
     "tap": "*"
   },
   "scripts": {
diff --git a/sapi_manifests/vmapi/template b/sapi_manifests/vmapi/template
index 20bd8e5..139ea48 100644
--- a/sapi_manifests/vmapi/template
+++ b/sapi_manifests/vmapi/template
@@ -43,7 +43,12 @@
             "delete-snapshot",
             "add-nics",
             "update-nics",
-            "remove-nics"
+            "remove-nics",
+            "migrate-abort",
+            "migrate-begin",
+            "migrate-pause",
+            "migrate-sync",
+            "migrate-switch"
         ],
         "url": "http://{{{WORKFLOW_SERVICE}}}"
     },
diff --git a/test/common.js b/test/common.js
index 268dbe7..35bcb2c 100644
--- a/test/common.js
+++ b/test/common.js
@@ -231,6 +231,7 @@ function waitForValue(url, key, value, options, callback) {
     assert.object(options, 'options');
     assert.object(options.client, 'options.client');
     assert.optionalNumber(options.timeout, 'options.timeout');
+    assert.optionalBool(options.waitUntilNotEqual, 'options.waitUntilNotEqual');
     assert.func(callback, 'callback');
 
     var client = options.client;
@@ -270,6 +271,56 @@ function waitForValue(url, key, value, options, callback) {
     performCheck();
 }
 
+/*
+ * Wait for the vmapi workflow job to change execution state away from 'queued'
+ * and 'running'.
+ *
+ * callback(err, executionValue, job)
+ */
+function waitForJob(options, callback) {
+    assert.object(options, 'options');
+    assert.uuid(options.job_uuid, 'options.job_uuid');
+    assert.object(options.client, 'options.client');
+    assert.optionalNumber(options.timeout, 'options.timeout');
+    assert.func(callback, 'callback');
+
+    var client = options.client;
+    var runSeconds = 0;
+    var timeout = 120;
+    var url = '/jobs/' + options.job_uuid;
+
+    if (options.timeout !== undefined) {
+        timeout = options.timeout;
+    }
+
+    function waitUntilWorkflowStateChanges() {
+        client.get(url, function (err, req, res, job) {
+            if (err) {
+                callback(err);
+                return;
+            }
+
+            var execution = job && job['execution'] || '(No execution)';
+
+            if (execution === 'queued' || execution === 'running') {
+                runSeconds++;
+
+                if (runSeconds >= timeout) {
+                    callback(new Error('Timeout waiting on ' + url));
+                } else {
+                    setTimeout(function () {
+                        waitUntilWorkflowStateChanges();
+                    }, 1000);
+                }
+            } else {
+                callback(null, execution, job);
+            }
+        });
+    }
+
+    waitUntilWorkflowStateChanges();
+}
+
 /*
  * Given an array of networks (most likely returned from napi GET /networks),
  * find the admin and external network and return them as an object.  This
@@ -295,6 +346,30 @@ function extractAdminAndExternalNetwork(networks) {
     return ret;
 }
 
+function findHeadnode(t, client, callback) {
+    client.cnapi.get({
+        path: '/servers',
+        query: {
+            headnode: true
+        }
+    }, function (err, req, res, servers) {
+        if (err) {
+            callback(err);
+            return;
+        }
+        t.equal(res.statusCode, 200, '200 OK');
+        t.ok(servers, 'servers is set');
+        t.ok(Array.isArray(servers), 'servers is Array');
+        for (var i = 0; i < servers.length; i++) {
+            if (servers[i].status === 'running') {
+                callback(null, servers[i]);
+                return;
+            }
+        }
+        callback(new Error('No running headnode server was found'));
+    });
+}
+
 module.exports = {
     setUp: setUp,
     checkHeaders: checkHeaders,
@@ -304,5 +379,7 @@ module.exports = {
     ifError: ifError,
     VMS_LIST_ENDPOINT: VMS_LIST_ENDPOINT,
     waitForValue: waitForValue,
-    extractAdminAndExternalNetwork: extractAdminAndExternalNetwork
+    waitForJob: waitForJob,
+    extractAdminAndExternalNetwork: extractAdminAndExternalNetwork,
+    findHeadnode: findHeadnode
 };
diff --git a/test/lib/migration.js b/test/lib/migration.js
new file mode 100644
index 0000000..a90c1c2
--- /dev/null
+++ b/test/lib/migration.js
@@ -0,0 +1,1350 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2019, Joyent, Inc.
+ */
+
+var stream = require('stream');
+var util = require('util');
+
+var assert = require('assert-plus');
+var byline = require('byline');
+var restify = require('restify');
+var vasync = require('vasync');
+
+var common = require('../common');
+
+var format = util.format;
+var waitForValue = common.waitForValue;
+var waitForJob = common.waitForJob;
+
+
+/* Helper functions */
+
+function getJobError(job) {
+    if (job && job.chain_results && job.chain_results.length > 0) {
+        // Get the error from the last task in the job.
+        return JSON.stringify(job.chain_results.slice(-1)[0].error);
+    }
+    return null;
+}
+
+function MigrationWatcher(client, vm_uuid) {
+    this.client = client;
+    this.vm_uuid = vm_uuid;
+    this.ended = false;
+    this.events = [];
+    this.error = null;
+
+    var options = {};
+    stream.Transform.call(this, options);
+}
+util.inherits(MigrationWatcher, stream.Transform);
+
+MigrationWatcher.prototype._transform =
+function _migWatchTransform(chunk, encoding, callback) {
+    try {
+        this.events.push(JSON.parse(chunk));
+    } catch (ex) {
+        console.log('# WARNING: Unable to parse watch event: ', String(chunk));
+        if (!this.error) {
+            this.error = new Error('Unable to parse event:', String(chunk));
+        }
+    }
+    callback();
+};
+
+MigrationWatcher.prototype.start = function _migWatchStart() {
+    var self = this;
+    var requestPath = format('/migrations/%s/watch', self.vm_uuid);
+
+    self.ended = false;
+
+    var httpVmapi = restify.createHttpClient({url: self.client.url.href});
+
+    httpVmapi.get(requestPath, function onMigrateWatchPost(postErr, req) {
+        if (postErr) {
+            console.log('# ERROR: ', postErr);
+            self.ended = true;
+            self.error = postErr;
+            return;
+        }
+
+        req.on('result', function onMigrateWatchResult(err, res) {
+            if (err) {
+                console.log('# ERROR: ', err);
+                self.ended = true;
+                self.error = err;
+                return;
+            }
+
+            res.on('end', function _watcherResEnd() {
+                self.ended = true;
+            });
+
+            var lineStream = new byline.LineStream();
+            res.pipe(lineStream).pipe(self);
+        });
+
+        req.end();
+    });
+};
+
+
+/* Tests */
+
+function TestMigrationCfg(test, cfg) {
+    var client;
+    var VM_UUID;
+
+    var mig = {
+        vms: {}, // vmobject by their vm_uuid
+        dni_vm_uuids: []
+    };
+
+    // Helpers
+    function createMigrationWatcher(vm_uuid) {
+        mig.watcher = new MigrationWatcher(client, vm_uuid);
+        mig.watcher.start();
+    }
+    function destroyMigrationWatcher() {
+        delete mig.watcher;
+    }
+
+    test.setUp = function (callback) {
+        if (client) {
+            callback();
+            return;
+        }
+        common.setUp(function (err, _client) {
+            assert.ifError(err);
+            assert.ok(_client, 'restify client');
+            client = _client;
+            callback();
+        });
+    };
+
+    test.create_vm = function (t) {
+        vasync.pipeline({arg: {}, funcs: [
+
+            function createVm(ctx, next) {
+                client.post({
+                    path: '/vms'
+                }, cfg.vm, function onVmCreated(err, req, res, body) {
+                    var expectedResStatusCode = 202;
+
+                    common.ifError(t, err, 'VM creation should not error');
+                    t.equal(res.statusCode, expectedResStatusCode,
+                        'HTTP status code should be ' +
+                            expectedResStatusCode);
+
+                    if (err) {
+                        next(err);
+                        return;
+                    }
+
+                    if (!body || !body.vm_uuid || !body.job_uuid) {
+                        next(new Error('No body vm_uuid or job_uuid returned'));
+                        return;
+                    }
+
+                    ctx.jobUuid = body.job_uuid;
+                    VM_UUID = body.vm_uuid;
+                    mig.vms[VM_UUID] = body;
+
+                    t.ok(VM_UUID, 'got a vm uuid: ' + VM_UUID);
+
+                    next();
+                });
+            },
+
+            function waitForProvisioningJob(ctx, next) {
+                waitForValue('/jobs/' + ctx.jobUuid, 'execution', 'succeeded',
+                    { client: client, timeout: 10 * 60 },
+                    function onVmProvisioned(err) {
+                        common.ifError(t, err,
+                            'VM should provision successfully');
+                        next();
+                    });
+            },
+            function getVmServer(ctx, next) {
+                client.get('/vms/' + VM_UUID, function (err, req, res, body) {
+                    common.ifError(t, err, 'VM should appear in vmapi');
+                    next();
+                });
+            }
+        ]}, function _provisionPipelineCb(err) {
+            common.ifError(t, err, 'no provision pipeline err');
+            t.done();
+        });
+    };
+
+
+    test.bad_migrate_no_action = function (t) {
+        // No action.
+        client.post({
+            path: format('/vms/%s?action=migrate', VM_UUID)
+        }, function onMigrateNoAction(err) {
+            t.ok(err, 'expect an error when no migration action supplied');
+            if (err) {
+                t.equal(err.statusCode, 409,
+                    format('err.statusCode === 409, got %s', err.statusCode));
+            }
+            t.done();
+        });
+    };
+
+    test.bad_migrate_unknown_action = function (t) {
+        // Unknown migration action.
+        client.post({
+            path: format('/vms/%s?action=migrate&migration_action=unknown',
+                VM_UUID)
+        }, function onMigrateNoAction(err) {
+            t.ok(err, 'expect an error for an unknown migration action');
+            if (err) {
+                t.equal(err.statusCode, 409,
+                    format('err.statusCode === 409, got %s', err.statusCode));
+            }
+            t.done();
+        });
+    };
+
+    [
+        'abort',
+        'pause',
+        'switch',
+        'sync'
+    ].forEach(function _testNoMigrateForEach(action) {
+        test['bad_migrate_' + action + '_when_no_migration'] = function (t) {
+            // Try to run a migration action when no migration has been started.
+            client.post({
+                path: format('/vms/%s?action=migrate&migration_action=%s',
+                    VM_UUID, action)
+            }, function onMigrateNoMigrationDataCb(err) {
+                t.ok(err, 'expect an error when there is no migration entry');
+                if (err) {
+                    t.equal(err.statusCode, 404,
+                        format('err.statusCode === 404, got %s',
+                            err.statusCode));
+                }
+                t.done();
+            });
+        };
+    });
+
+    test.bad_migrate_core_zone = function (t) {
+        // Should not be able to migrate a triton core zone.
+        vasync.pipeline({arg: {}, funcs: [
+            function findCoreZone(ctx, next) {
+                client.get({
+                    path: '/vms?tag.smartdc_type=core&state=active&limit=1'
+                }, function onFindCoreZone(err, req, res, body) {
+                    if (err) {
+                        t.ok(false, 'unable to query vmapi for core zone: ' +
+                            err);
+                        next(true);
+                        return;
+                    }
+                    if (!body || !body[0] || !body[0].uuid) {
+                        t.ok(false, 'no core zone found');
+                        next(true);
+                        return;
+                    }
+                    ctx.vm = body[0];
+                    next();
+                });
+            },
+
+            function migrateCoreZone(ctx, next) {
+                client.post({
+                    path: format(
+                        '/vms/%s?action=migrate&migration_action=begin',
+                        ctx.vm.uuid)
+                }, function onMigrateCoreZoneCb(err) {
+                    t.ok(err, 'expect an error for migration of a core zone');
+                    if (err) {
+                        t.equal(err.statusCode, 412,
+                            format('err.statusCode === 412, got %s',
+                                err.statusCode));
+                    }
+                    next();
+                });
+            }
+        ]}, function _pipelineCb() {
+            t.done();
+        });
+    };
+
+    test.bad_migrate_nat_zone = function (t) {
+        // Should not be able to migrate a triton NAT zone.
+        vasync.pipeline({arg: {}, funcs: [
+            function findNatZone(ctx, next) {
+                client.get({
+                    path: '/vms?tag.smartdc_role=nat&state=active&limit=1'
+                }, function onFindNatZone(err, req, res, body) {
+                    if (err) {
+                        t.ok(false, 'unable to query vmapi for nat zone: ' +
+                            err);
+                        next(true);
+                        return;
+                    }
+                    if (!body || !body[0] || !body[0].uuid) {
+                        t.ok(false, 'no nat zone found');
+                        next(true);
+                        return;
+                    }
+                    ctx.vm = body[0];
+                    next();
+                });
+            },
+
+            function migrateNatZone(ctx, next) {
+                client.post({
+                    path: format(
+                        '/vms/%s?action=migrate&migration_action=begin',
+                        ctx.vm.uuid)
+                }, function onMigrateNatZoneCb(err) {
+                    t.ok(err, 'expect an error for migration of a nat zone');
+                    if (err) {
+                        t.equal(err.statusCode, 412,
+                            format('err.statusCode === 412, got %s',
+                                err.statusCode));
+                    }
+                    next();
+                });
+            }
+        ]}, function _pipelineCb() {
+            t.done();
+        });
+    };
+
+    test.migration_estimate = function test_migration_estimate(t) {
+        if (!VM_UUID) {
+            t.ok(false, 'Original VM was not created successfully');
+            t.done();
+            return;
+        }
+
+        client.post(
+            {path: format('/vms/%s?action=migrate&migration_action=estimate',
+                    VM_UUID)},
+            onMigrateEstimateCb);
+
+        function onMigrateEstimateCb(err, req, res, body) {
+            common.ifError(t, err, 'no error when estimating the migration');
+            if (err) {
+                t.done();
+                return;
+            }
+
+            t.ok(res, 'estimate: got a restify response object');
+            if (res) {
+                t.equal(res.statusCode, 200,
+                    format('err.statusCode === 200, got %s', res.statusCode));
+                t.ok(res.body, 'estimate: got a restify response body object');
+            }
+
+            t.ok(body, 'estimate: got a response body');
+            if (!body) {
+                t.done();
+                return;
+            }
+
+            t.ok(body.size, 'estimate: got body.size estimate');
+            t.ok(body.size > 0, 'estimate: got body.size >= 0: ' + body.size);
+            t.done();
+        }
+    };
+
+    test.migration_begin_for_abort = function test_migration_begin_abort(t) {
+        if (!VM_UUID) {
+            t.ok(false, 'Original VM was not created successfully');
+            t.done();
+            return;
+        }
+
+        // XXX: Testing - tweak the uuid to allow on the same CN.
+        // TODO: Check server list to see if this is needed (i.e. when there is
+        // just one CN).
+        var override_uuid = VM_UUID.slice(0, -6) + 'ab0ab0';
+        var override_alias = cfg.vm.alias + '-abort';
+
+        // Trying to run a migration action when a migration has not started.
+        client.post(
+                {path: format('/vms/%s?action=migrate&migration_action=begin',
+                    VM_UUID)},
+                {override_uuid: override_uuid, override_alias: override_alias},
+                function onMigrateBeginAbortCb(err, req, res, body) {
+            common.ifError(t, err, 'no error when beginning the migration');
+            if (!err) {
+                t.ok(res, 'should get a restify response object');
+                if (res) {
+                    t.equal(res.statusCode, 202,
+                        format('err.statusCode === 202, got %s',
+                            res.statusCode));
+                    t.ok(res.body, 'should get a restify response body object');
+                }
+                if (body) {
+                    t.ok(body.job_uuid, 'got a job uuid: ' + body.job_uuid);
+                    t.ok(body.migration, 'got a migration record');
+                    if (body.migration) {
+                        t.equal(body.migration.phase, 'begin');
+                        t.equal(body.migration.state, 'running');
+                    }
+
+                    var waitParams = {
+                        client: client,
+                        job_uuid: body.job_uuid,
+                        timeout: 15 * 60
+                    };
+
+                    waitForJob(waitParams, function onMigrationJobCb(jerr,
+                            state, job) {
+                        common.ifError(t, jerr, 'begin should be successful');
+                        if (!jerr) {
+                            mig.started = (state === 'succeeded');
+                            t.equal(state, 'succeeded',
+                                'Migration begin job should succeed - ' +
+                                (mig.started ? 'ok' : getJobError(job)));
+                        }
+                        t.done();
+                    });
+                    return;
+                }
+            }
+            t.done();
+        });
+    };
+
+    test.migration_abort = function test_migration_abort(t) {
+        if (!mig.started) {
+            t.ok(false, 'VM migration did not begin successfully');
+            t.done();
+            return;
+        }
+
+        client.post(
+                {path: format('/vms/%s?action=migrate&migration_action=abort',
+                    VM_UUID)},
+                {},
+                function onMigrateBeginAbortCb(err, req, res, body) {
+            common.ifError(t, err, 'no error when aborting the migration');
+            if (!err) {
+                t.ok(res, 'should get a restify response object');
+                if (res) {
+                    t.equal(res.statusCode, 202,
+                        format('err.statusCode === 202, got %s',
+                            res.statusCode));
+                    t.ok(res.body, 'should get a restify response body object');
+                }
+                if (body) {
+                    t.ok(body.job_uuid, 'got a job uuid: ' + body.job_uuid);
+                    t.ok(body.migration, 'got a migration record');
+                    if (body.migration) {
+                        t.equal(body.migration.phase, 'abort');
+                        t.equal(body.migration.state, 'running');
+                    }
+
+                    var waitParams = {
+                        client: client,
+                        job_uuid: body.job_uuid,
+                        timeout: 15 * 60
+                    };
+
+                    waitForJob(waitParams, function onMigrationJobCb(jerr,
+                            state, job) {
+                        common.ifError(t, jerr, 'abort should be successful');
+                        if (!jerr) {
+                            mig.started = (state === 'succeeded');
+                            t.equal(state, 'succeeded',
+                                'Migration abort job should succeed - ' +
+                                (mig.started ? 'ok' : getJobError(job)));
+                        }
+                        t.done();
+                    });
+                    return;
+                }
+            }
+            t.done();
+        });
+    };
+
+    test.migration_begin = function test_migration_begin(t) {
+        if (!VM_UUID) {
+            t.ok(false, 'Original VM was not created successfully');
+            t.done();
+            return;
+        }
+
+        mig.started = false;
+
+        // XXX: Testing - tweak the uuid to allow on the same CN.
+        // TODO: Check server list to see if this is needed (i.e. when there is
+        // just one CN).
+        var override_uuid = VM_UUID.slice(0, -6) + 'aaaaaa';
+        var override_alias = cfg.vm.alias + '-aaaaaa';
+
+        // Trying to run a migration action when a migration has not started.
+        client.post(
+            { path:
+                format('/vms/%s?action=migrate&migration_action=begin',
+                    VM_UUID) },
+            { override_uuid: override_uuid, override_alias: override_alias },
+            function onMigrateBeginCb(err, req, res, body) {
+            common.ifError(t, err, 'no error when beginning the migration');
+            if (!err) {
+                t.ok(res, 'should get a restify response object');
+                if (res) {
+                    t.equal(res.statusCode, 202,
+                        format('err.statusCode === 202, got %s',
+                            res.statusCode));
+                    t.ok(res.body, 'should get a restify response body object');
+                }
+                if (body) {
+                    t.ok(body.job_uuid, 'got a job uuid: ' + body.job_uuid);
+                    t.ok(body.migration, 'got a migration record');
+                    if (body.migration) {
+                        t.equal(body.migration.phase, 'begin');
+                        t.equal(body.migration.state, 'running');
+                    }
+
+                    // Watch for migration events.
+                    createMigrationWatcher(VM_UUID);
+
+                    var waitParams = {
+                        client: client,
+                        job_uuid: body.job_uuid,
+                        timeout: 15 * 60
+                    };
+
+                    waitForJob(waitParams, function onMigrationJobCb(jerr,
+                            state, job) {
+                        common.ifError(t, jerr, 'begin should be successful');
+                        if (!jerr) {
+                            mig.started = (state === 'succeeded');
+                            t.equal(state, 'succeeded',
+                                'Migration begin job should succeed - ' +
+                                (mig.started ? 'ok' : getJobError(job)));
+                        }
+                        t.done();
+                    });
+                    return;
+                }
+            }
+            t.done();
+        });
+    };
+
+    test.check_watch_entries = function check_watch_entries(t) {
+
+        t.ok(mig.watcher, 'mig.watcher exists');
+        if (!mig.watcher) {
+            t.done();
+            return;
+        }
+
+        var loopCount = 0;
+        var timeoutSeconds = 2 * 60; // 2 minutes
+
+        function waitForWatcherEnd() {
+            loopCount += 1;
+            if (!mig.watcher.ended) {
+                if (loopCount > timeoutSeconds) {
+                    t.ok(false, 'Timed out waiting for the watcher to end');
+                    t.done();
+                    return;
+                }
+                setTimeout(waitForWatcherEnd, 1000);
+                return;
+            }
+
+            // Check the events.
+            t.ok(mig.watcher.events.length > 0, 'Should be events seen');
+
+            var beginEvents = mig.watcher.events.filter(function _filtB(event) {
+                return event.type === 'progress' && event.phase === 'begin';
+            });
+            t.ok(beginEvents.length > 0, 'Should have begin events');
+            if (beginEvents.length > 0) {
+                beginEvents.map(function (event) {
+                    t.ok(event.state === 'running' ||
+                        event.state === 'successful',
+                        'event state running or successful');
+                    t.ok(event.current_progress > 0, 'current_progress > 0');
+                    t.equal(event.total_progress, 100, 'total_progress == 100');
+                });
+            }
+
+            var endEvent = mig.watcher.events.filter(function _filtEnd(event) {
+                return event.type === 'end';
+            }).slice(-1)[0];
+            t.ok(endEvent, 'Should have an end event');
+            if (endEvent) {
+                t.equal(endEvent.phase, 'begin', 'end event phase is "begin"');
+                t.equal(endEvent.state, 'paused', 'end event state "paused"');
+            }
+
+            destroyMigrationWatcher();
+
+            t.done();
+        }
+
+        waitForWatcherEnd();
+    };
+
+    test.bad_migrate_cannot_begin_from_begin_phase = function (t) {
+        // Invalid action according to the current migration phase.
+        if (!mig.started) {
+            t.ok(false, 'VM migration did not begin successfully');
+            t.done();
+            return;
+        }
+
+        client.post({
+            path: format('/vms/%s?action=migrate&migration_action=begin',
+                    VM_UUID)
+        }, function onMigrateNoAction(err) {
+            t.ok(err, 'expect an error when the migration already started');
+            if (err) {
+                t.equal(err.statusCode, 412,
+                    format('err.statusCode === 412, got %s', err.statusCode));
+            }
+            t.done();
+        });
+    };
+
+    test.bad_migrate_cannot_pause_from_paused_state = function (t) {
+        // Invalid action according to the current migration state.
+        if (!mig.started) {
+            t.ok(false, 'VM migration did not begin successfully');
+            t.done();
+            return;
+        }
+
+        client.post({
+            path: format('/vms/%s?action=migrate&migration_action=pause',
+                    VM_UUID)
+        }, function onMigrateNoAction(err) {
+            t.ok(err, 'expect an error when the migration is already paused');
+            if (err) {
+                t.equal(err.statusCode, 412,
+                    format('err.statusCode === 412, got %s', err.statusCode));
+            }
+            t.done();
+        });
+    };
+
+    test.migration_list = function test_migration_list(t) {
+        if (!mig.started) {
+            t.ok(false, 'VM migration did not begin successfully');
+            t.done();
+            return;
+        }
+
+        client.get({
+            path: '/migrations'
+        }, function onMigrateListCb(err, req, res, body) {
+            common.ifError(t, err, 'no error expected when listing migrations');
+            if (err) {
+                t.done();
+                return;
+            }
+
+            t.ok(res, 'should get a restify response object');
+            if (!res) {
+                t.done();
+                return;
+            }
+            t.equal(res.statusCode, 200,
+                format('err.statusCode === 200, got %s', res.statusCode));
+            t.ok(Array.isArray(body), 'body response should be an array');
+            if (!Array.isArray(body)) {
+                t.done();
+                return;
+            }
+
+            t.ok(body.length >= 1, 'should be at least one migration');
+            if (body.length === 0) {
+                t.done();
+                return;
+            }
+
+            var migrations = body.filter(function _filtMig(entry) {
+                return entry.vm_uuid === VM_UUID;
+            });
+            t.ok(migrations.length >= 1, 'should be at least vm match');
+            if (migrations.length === 0) {
+                t.done();
+                return;
+            }
+
+            var migration = migrations[0];
+            t.equal(migration.automatic, false, 'automatic should be false');
+            t.equal(migration.phase, 'begin', 'phase should be "begin"');
+            t.equal(migration.state, 'paused', 'state should be "paused"');
+            t.equal(migration.vm_uuid, VM_UUID, 'vm_uuid should be the same');
+
+            t.ok(Array.isArray(migration.progress_history) &&
+                    migration.progress_history.length >= 1,
+                'migration should have at least one progress entry');
+            if (!Array.isArray(migration.progress_history) ||
+                    migration.progress_history.length === 0) {
+                t.done();
+                return;
+            }
+
+            var lastProgress = migration.progress_history.slice(-1)[0];
+            t.equal(lastProgress.current_progress, 100,
+                'current_progress should be 100');
+            t.equal(lastProgress.total_progress, 100,
+                'total_progress should be 100');
+            t.equal(lastProgress.phase, 'begin', 'phase should be "begin"');
+            t.equal(lastProgress.state, 'successful', 'state is "successful"');
+
+            t.done();
+        });
+    };
+
+    test.migration_sync = function test_migration_sync(t) {
+        // Start the migration sync phase.
+        if (!mig.started) {
+            t.ok(false, 'VM migration did not begin successfully');
+            t.done();
+            return;
+        }
+
+        client.post({
+            path: format('/vms/%s?action=migrate&migration_action=sync',
+                VM_UUID)
+        }, function onMigrateSyncCb(err, req, res, body) {
+            common.ifError(t, err, 'no error when syncing the migration');
+            if (!err) {
+                t.ok(res, 'should get a restify response object');
+                if (res) {
+                    t.equal(res.statusCode, 202,
+                        format('err.statusCode === 202, got %s',
+                            res.statusCode));
+                    t.ok(res.body, 'should get a restify response body object');
+                }
+                if (body) {
+                    t.ok(body.job_uuid, 'got a job uuid: ' + body.job_uuid);
+                    t.ok(body.migration, 'got a migration record');
+                    if (body.migration) {
+                        t.equal(body.migration.phase, 'sync');
+                        t.equal(body.migration.state, 'running');
+                    }
+
+                    // Watch for migration events.
+                    createMigrationWatcher(VM_UUID);
+
+                    var waitParams = {
+                        client: client,
+                        job_uuid: body.job_uuid,
+                        timeout: 1 * 60 * 60 // 1 hour
+                    };
+
+                    waitForJob(waitParams, function onMigrationJobCb(jerr,
+                            state,
+                            job) {
+                        common.ifError(t, jerr,
+                            'Migration (' + body.job_uuid
+                            + ') sync should be successful');
+                        if (!jerr) {
+                            t.equal(state, 'succeeded',
+                                'Migration sync job should succeed - ' +
+                                (state === 'succeeded' ? 'ok' :
+                                    getJobError(job)));
+                        }
+                        mig.synced = (state === 'succeeded');
+                        t.done();
+                    });
+                    return;
+                }
+            }
+            t.done();
+        });
+    };
+
+    test.check_watch_entries_after_sync =
+    function check_watch_entries_after_sync(t) {
+
+        t.ok(mig.watcher, 'mig.watcher exists');
+        if (!mig.watcher) {
+            t.done();
+            return;
+        }
+
+        var loopCount = 0;
+        var timeoutSeconds = 5 * 60; // 5 minutes
+
+        function waitForWatcherEnd() {
+            loopCount += 1;
+            if (!mig.watcher.ended) {
+                if (loopCount > timeoutSeconds) {
+                    t.ok(false, 'Timed out waiting for the watcher to end');
+                    t.done();
+                    return;
+                }
+                setTimeout(waitForWatcherEnd, 1000);
+                return;
+            }
+
+            // Check the events.
+            t.ok(mig.watcher.events.length > 0, 'Should be events seen');
+
+            var syncEvents = mig.watcher.events.filter(function _filtS(event) {
+                return event.type === 'progress' && event.phase === 'sync';
+            });
+            t.ok(syncEvents.length > 0, 'Should have sync events');
+            if (syncEvents.length > 0) {
+                var sawBandwidthEvent = false;
+                syncEvents.map(function (event) {
+                    t.ok(event.state === 'running' ||
+                        event.state === 'successful',
+                        'event state running or successful');
+                    t.ok(event.current_progress, 'event has current_progress');
+                    t.ok(event.total_progress, 'event has a total_progress');
+                    if (event.transfer_bytes_second) {
+                        t.ok(event.hasOwnProperty('eta_ms'),
+                            'event has a eta_ms');
+                        sawBandwidthEvent = true;
+                    }
+                });
+                t.ok(sawBandwidthEvent, 'a bandwidth progress event was seen');
+            }
+
+            var endEvent = mig.watcher.events.filter(function _filtEnd(event) {
+                return event.type === 'end';
+            }).slice(-1)[0];
+            t.ok(endEvent, 'Should have an end event');
+            if (endEvent) {
+                t.equal(endEvent.phase, 'sync', 'end event phase is "sync"');
+                t.equal(endEvent.state, 'paused', 'end event state "paused"');
+            }
+
+            destroyMigrationWatcher();
+
+            t.done();
+        }
+
+        waitForWatcherEnd();
+    };
+
+    test.migration_sync_incremental = function test_migration_sync_inc(t) {
+        // Start the migration sync phase again - should do an incremental sync.
+        if (!mig.synced) {
+            t.ok(false, 'VM migration did not sync successfully');
+            t.done();
+            return;
+        }
+
+        client.post({
+            path: format('/vms/%s?action=migrate&migration_action=sync',
+                VM_UUID)
+        }, function onMigrateSyncCb(err, req, res, body) {
+            common.ifError(t, err, 'no error when syncing the migration');
+            if (!err) {
+                t.ok(res, 'should get a restify response object');
+                if (res) {
+                    t.equal(res.statusCode, 202,
+                        format('err.statusCode === 202, got %s',
+                            res.statusCode));
+                    t.ok(res.body, 'should get a restify response body object');
+                }
+                if (body) {
+                    t.ok(body.job_uuid, 'got a job uuid: ' + body.job_uuid);
+                    t.ok(body.migration, 'got a migration record');
+                    if (body.migration) {
+                        t.equal(body.migration.phase, 'sync');
+                        t.equal(body.migration.state, 'running');
+                    }
+
+                    var waitParams = {
+                        client: client,
+                        job_uuid: body.job_uuid,
+                        timeout: 1 * 60 * 60 // 1 hour
+                    };
+
+                    waitForJob(waitParams, function onMigrationJobCb(jerr,
+                            state,
+                            job) {
+                        common.ifError(t, jerr, 'sync should be successful');
+                        if (!jerr) {
+                            t.equal(state, 'succeeded',
+                                'Migration sync job should succeed - ' +
+                                (state === 'succeeded' ? 'ok' :
+                                    getJobError(job)));
+                        }
+                        mig.synced = (state === 'succeeded');
+                        t.done();
+                    });
+                    return;
+                }
+            }
+            t.done();
+        });
+    };
+
+    test.migration_switch = function test_migration_switch(t) {
+        // Start the migration switch phase.
+        if (!mig.started) {
+            t.ok(false, 'VM migration did not begin successfully');
+            t.done();
+            return;
+        }
+
+        if (!mig.synced) {
+            t.ok(false, 'VM migration did not sync successfully');
+            t.done();
+            return;
+        }
+
+        client.post({
+            path: format('/vms/%s?action=migrate&migration_action=switch',
+                VM_UUID)
+        }, function onMigrateSwitchCb(err, req, res, body) {
+            common.ifError(t, err, 'no error from migration switch call');
+            if (!err) {
+                t.ok(res, 'should get a restify response object');
+                if (res) {
+                    t.equal(res.statusCode, 202,
+                        format('err.statusCode === 202, got %s',
+                        res.statusCode));
+                    t.ok(res.body, 'should get a restify response body object');
+                }
+                if (body) {
+                    t.ok(body.job_uuid, 'got a job uuid: ' + body.job_uuid);
+                    t.ok(body.migration, 'got a migration record');
+                    if (body.migration) {
+                        t.equal(body.migration.phase, 'switch');
+                        t.equal(body.migration.state, 'running');
+                    }
+
+                    // Watch for migration events.
+                    createMigrationWatcher(VM_UUID);
+
+                    var waitParams = {
+                        client: client,
+                        job_uuid: body.job_uuid,
+                        timeout: 15 * 60 // 15 minutes
+                    };
+
+                    waitForJob(waitParams, function onMigrationJobCb(jerr,
+                            state,
+                            job) {
+                        common.ifError(t, jerr, 'switch should be successful');
+                        if (!jerr) {
+                            t.equal(state, 'succeeded',
+                                'Migration switch job should succeed - ' +
+                                (state === 'succeeded' ? 'ok' :
+                                    getJobError(job)));
+                        }
+                        mig.switched = (state === 'succeeded');
+                        mig.dni_vm_uuids.push(VM_UUID);
+                        t.done();
+                    });
+                    return;
+                }
+            }
+            t.done();
+        });
+    };
+
+    test.migration_switched_list = function test_migration_switched_list(t) {
+        if (!mig.switched) {
+            t.ok(false, 'VM migration did not switch successfully');
+            t.done();
+            return;
+        }
+
+        client.get({
+            path: '/migrations'
+        }, function onMigrateListCb(err, req, res, body) {
+            common.ifError(t, err, 'no error expected when listing migrations');
+            if (err) {
+                t.done();
+                return;
+            }
+
+            t.ok(res, 'should get a restify response object');
+            if (!res) {
+                t.done();
+                return;
+            }
+            t.equal(res.statusCode, 200,
+                format('err.statusCode === 200, got %s', res.statusCode));
+            t.ok(Array.isArray(body), 'body response should be an array');
+            if (!Array.isArray(body)) {
+                t.done();
+                return;
+            }
+
+            t.ok(body.length >= 1, 'should be at least one migration');
+            if (body.length === 0) {
+                t.done();
+                return;
+            }
+
+            var migrations = body.filter(function _filtMig(entry) {
+                return entry.vm_uuid === VM_UUID;
+            });
+            t.ok(migrations.length >= 1, 'should be at least vm match');
+            if (migrations.length === 0) {
+                t.done();
+                return;
+            }
+
+            var migration = migrations[0];
+            t.equal(migration.automatic, false, 'automatic should be false');
+            t.equal(migration.phase, 'switch', 'phase should be "switch"');
+            t.equal(migration.state, 'successful',
+                'state should be "successful"');
+            t.equal(migration.vm_uuid, VM_UUID, 'vm_uuid should be the same');
+
+            t.ok(Array.isArray(migration.progress_history) &&
+                    migration.progress_history.length >= 5,
+                'migration should have at least five progress entries');
+            if (!Array.isArray(migration.progress_history) ||
+                    migration.progress_history.length < 5) {
+                t.done();
+                return;
+            }
+
+            function checkProgressEntry(entry, phase) {
+                t.equal(entry.phase, phase, 'phase should be "' + phase + '"');
+                t.equal(entry.state, 'successful',
+                    'progress state is "successful"');
+
+                if (phase === 'sync') {
+                    t.equal(entry.current_progress, entry.total_progress,
+                        'current_progress should equal total_progress');
+                } else {
+                    t.equal(entry.current_progress, 100,
+                        'current_progress is 100');
+                    t.equal(entry.total_progress, 100, 'total_progress is 100');
+                }
+            }
+
+            checkProgressEntry(migration.progress_history[0], 'begin');
+            checkProgressEntry(migration.progress_history[1], 'sync');
+            checkProgressEntry(migration.progress_history[2], 'sync');
+            checkProgressEntry(migration.progress_history[3], 'sync');
+            checkProgressEntry(migration.progress_history[4], 'switch');
+
+            t.done();
+        });
+    };
+
+    test.check_vmapi_state = function test_check_vmapi_state(t) {
+        if (!VM_UUID) {
+            t.ok(false, 'Original VM was not created successfully');
+            t.done();
+            return;
+        }
+
+        // The original vm should no longer be visible in vmapi. We use
+        // 'sync=true' to ensure vmapi (via cnapi) will use the most
+        // up-to-date information.
+        client.get({path: format('/vms/%s?sync=true', VM_UUID)},
+            onGetOrigVm);
+
+        function onGetOrigVm(err, req, res, vm) {
+            t.ifError(err, 'should not get an error fetching original vm');
+            if (res) {
+                t.equal(res.statusCode, 200,
+                    format('err.statusCode === 200, got %s', res.statusCode));
+            }
+            t.ok(vm, 'should get a vm object');
+            if (vm) {
+                t.equal(vm.state, 'destroyed', 'original vm should be gone');
+                mig.vms[vm.uuid] = vm;
+                if (mig.dni_vm_uuids.indexOf(vm.uuid) === -1) {
+                    mig.dni_vm_uuids.push(vm.uuid);
+                }
+            }
+
+            checkMigratedVm();
+        }
+
+        // The migrated vm *should* be visible through vmapi.
+        function checkMigratedVm() {
+            var migrated_uuid = VM_UUID.slice(0, -6) + 'aaaaaa';
+            client.get({path: format('/vms/%s?sync=true', migrated_uuid)},
+                onGetMigratedVm);
+        }
+
+        var loopCount = 0;
+
+        function onGetMigratedVm(err, req, res, vm) {
+            common.ifError(t, err, 'should be no error fetching migrated vm');
+            if (vm) {
+                // When the migration is complete - it will be a while before
+                // the zone has fully started up.
+                if (vm.state !== 'running' && loopCount < 30) {
+                    loopCount += 1;
+                    setTimeout(checkMigratedVm, 2000);
+                    return;
+                }
+
+                t.equal(vm.state, 'running', 'vm state should be "running"');
+                mig.vms[vm.uuid] = vm;
+            }
+            t.done();
+        }
+    };
+
+    test.migration_full = function test_migration_full(t) {
+        if (!mig.switched) {
+            t.ok(false, 'VM migration did not switch successfully');
+            t.done();
+            return;
+        }
+
+        // TODO: Check server list to see if this is needed (i.e. when there is
+        // just one CN).
+        var switched_uuid = VM_UUID.slice(0, -6) + 'aaaaaa';
+        var override_uuid = VM_UUID.slice(0, -6) + 'bbbbbb';
+        var override_alias = cfg.vm.alias + '-bbbbbb';
+
+        // Trying to run a migration action when a migration has not started.
+        var params = {
+            action: 'migrate',
+            migration_action: 'begin',
+            migration_automatic: 'true',
+            override_uuid: override_uuid,
+            override_alias: override_alias
+        };
+        client.post({path: format('/vms/%s', switched_uuid)},
+            params,
+            onMigrateFullCb);
+
+        function onMigrateFullCb(err, req, res, body) {
+            common.ifError(t, err, 'no error when starting migration full');
+            if (!err) {
+                t.ok(res, 'should get a restify response object');
+                if (res) {
+                    t.equal(res.statusCode, 202,
+                        format('statusCode === 202, got %s', res.statusCode));
+                    t.ok(res.body, 'should get a restify response body object');
+                }
+                if (body) {
+                    t.ok(body.job_uuid, 'got a job uuid: ' + body.job_uuid);
+                    t.ok(body.migration, 'got a migration record');
+                    if (body.migration) {
+                        t.equal(body.migration.phase, 'begin');
+                        t.equal(body.migration.state, 'running');
+                    }
+
+                    // Watch for migration events.
+                    createMigrationWatcher(switched_uuid);
+                }
+            }
+            t.done();
+        }
+    };
+
+    test.check_full_watch_entries = function check_full_watch_entries(t) {
+
+        t.ok(mig.watcher, 'mig.watcher exists');
+        if (!mig.watcher) {
+            t.done();
+            return;
+        }
+
+        var loopCount = 0;
+        var timeoutSeconds = 15 * 60; // 15 minutes
+
+        function waitForWatcherEnd() {
+            loopCount += 1;
+            if (!mig.watcher.ended) {
+                if (loopCount > timeoutSeconds) {
+                    t.ok(false, 'Timed out waiting for the watcher to end');
+                    t.done();
+                    return;
+                }
+                setTimeout(waitForWatcherEnd, 1000);
+                return;
+            }
+
+            // Check the events.
+            t.ok(mig.watcher.events.length > 0, 'Should be events seen');
+
+            var beginEvents = mig.watcher.events.filter(function _filtB(event) {
+                return event.type === 'progress' && event.phase === 'begin';
+            });
+            t.ok(beginEvents.length > 0, 'Should have begin events');
+            if (beginEvents.length > 0) {
+                beginEvents.map(function (event) {
+                    t.ok(event.state === 'running' ||
+                        event.state === 'successful',
+                        'event state running or successful');
+                    t.ok(event.current_progress > 0, 'current_progress > 0');
+                    t.equal(event.total_progress, 100, 'total_progress == 100');
+                });
+            }
+
+            var syncEvents = mig.watcher.events.filter(function _filt(event) {
+                return event.type === 'progress' && event.phase === 'sync';
+            });
+            t.ok(syncEvents.length > 0, 'Should have sync events');
+            if (syncEvents.length > 0) {
+                // There should be at least three distinct sync phases.
+                var syncStartEvents = syncEvents.filter(function _filtS(event) {
+                    return event.message === 'syncing data';
+                });
+                t.ok(syncStartEvents.length >= 3, 'Should have at least 3 ' +
+                    'different sync events');
+                var sawBandwidthEvent = false;
+                syncEvents.map(function (event) {
+                    // All sync events should have state 'running'
+                    t.ok(event.state === 'running', 'event state is "running"');
+                    t.ok(event.current_progress, 'event has current_progress');
+                    t.ok(event.total_progress, 'event has a total_progress');
+                    if (event.transfer_bytes_second) {
+                        t.ok(event.hasOwnProperty('eta_ms'),
+                            'event has a eta_ms');
+                        sawBandwidthEvent = true;
+                    }
+                });
+                t.ok(sawBandwidthEvent, 'a bandwidth progress event was seen');
+            }
+
+            var endEvent = mig.watcher.events.filter(function _filtEnd(event) {
+                return event.type === 'end';
+            }).slice(-1)[0];
+            t.ok(endEvent, 'Should have an end event');
+            if (endEvent) {
+                t.equal(endEvent.phase, 'switch',
+                    'end event phase is "switch"');
+                t.equal(endEvent.state, 'successful',
+                    'end event state is "successful"');
+                if (endEvent.state === 'successful') {
+                    mig.dni_vm_uuids.push(mig.watcher.vm_uuid);
+                }
+            }
+
+            destroyMigrationWatcher();
+
+            t.done();
+        }
+
+        waitForWatcherEnd();
+    };
+
+    test.check_vmapi_state_2 = function test_check_vmapi_state_2(t) {
+        if (mig.dni_vm_uuids.length < 2) {
+            t.ok(false, 'Vms were not migrated successfully');
+            t.done();
+            return;
+        }
+
+        // The original vm should no longer be visible in vmapi. We use
+        // 'sync=true' to ensure vmapi (via cnapi) will use the most
+        // up-to-date information.
+        client.get({path: format('/vms/%s?sync=true',
+            mig.dni_vm_uuids.slice(-1)[0])},
+            onGetOrigVm);
+
+        function onGetOrigVm(err, req, res, vm) {
+            common.ifError(t, err, 'should not error fetching original vm');
+            if (res) {
+                t.equal(res.statusCode, 200,
+                    format('err.statusCode === 200, got %s', res.statusCode));
+            }
+            t.ok(vm, 'should get a vm object');
+            if (vm) {
+                t.equal(vm.state, 'destroyed', 'original vm should be gone');
+                mig.vms[vm.uuid] = vm;
+                if (mig.dni_vm_uuids.indexOf(vm.uuid) === -1) {
+                    mig.dni_vm_uuids.push(vm.uuid);
+                }
+            }
+
+            checkMigratedVm();
+        }
+
+        // The migrated vm *should* be visible through vmapi.
+        function checkMigratedVm() {
+            var migrated_uuid = VM_UUID.slice(0, -6) + 'bbbbbb';
+            client.get({path: format('/vms/%s?sync=true', migrated_uuid)},
+                onGetMigratedVm);
+        }
+
+        var loopCount = 0;
+
+        function onGetMigratedVm(err, req, res, vm) {
+            common.ifError(t, err, 'should be no error fetching migrated vm');
+            if (vm) {
+                // When the migration is complete - it will be a while before
+                // the zone has fully started up.
+                if (vm.state !== 'running' && loopCount < 30) {
+                    loopCount += 1;
+                    setTimeout(checkMigratedVm, 2000);
+                    return;
+                }
+
+                t.equal(vm.state, 'running', 'vm state should be "running"');
+                mig.vms[vm.uuid] = vm;
+            }
+            t.done();
+        }
+    };
+
+    test.cleanup = function test_cleanup(t) {
+        if (!VM_UUID) {
+            t.ok(false, 'VM_UUID not found, cannot delete VM');
+            t.done();
+            return;
+        }
+
+        vasync.forEachParallel({
+            inputs: Object.keys(mig.vms),
+            func: deleteOneVm
+        }, function onDeleteVmsCb(err) {
+            common.ifError(t, err, 'should be no error deleting vms');
+            t.done();
+        });
+
+        function deleteOneVm(vm_uuid, callback) {
+            if (mig.dni_vm_uuids.indexOf(vm_uuid) >= 0) {
+                deleteDniVm(vm_uuid, callback);
+                return;
+            }
+
+            client.del({path: format('/vms/%s', vm_uuid)}, callback);
+        }
+
+        // To delete a hidden (DNI) vm, we execute a 'vmadm delete' on the
+        // server in question.
+        function deleteDniVm(vm_uuid, callback) {
+            t.ok(mig.vms[vm_uuid], 'mig.vms entry exists for vm ' + vm_uuid);
+            if (!mig.vms[vm_uuid]) {
+                callback(new Error('No mig.vms entry for ' + vm_uuid));
+                return;
+            }
+            var server_uuid = mig.vms[vm_uuid].server_uuid;
+            var params = {
+                script: format('#!/bin/bash\nvmadm delete %s', vm_uuid),
+                server_uuid: server_uuid
+            };
+            client.cnapi.post({path: format('/servers/%s/execute',
+                    server_uuid)},
+                params,
+                onServerExecuteCb);
+
+            function onServerExecuteCb(err) {
+                common.ifError(t, err, 'error running vmadm delete on server');
+                callback(err);
+            }
+        }
+    };
+}
+
+
+module.exports = {
+    TestMigrationCfg: TestMigrationCfg
+};
diff --git a/test/runtests b/test/runtests
index d9145c0..00a0d31 100755
--- a/test/runtests
+++ b/test/runtests
@@ -152,6 +152,15 @@ mkdir -p $OUTPUT_DIR
 
 CFG_FILE=$TOP/config.json
 
+# Install necessary images (for instance migration tests).
+# Image 7b5981c4-1889-11e7-b4c5-3f3bdfc9b88b (lx, ubuntu-16.04, 20170403)
+sdc-imgadm get 7b5981c4-1889-11e7-b4c5-3f3bdfc9b88b >/dev/null 2>/dev/null \
+    || sdc-imgadm import 7b5981c4-1889-11e7-b4c5-3f3bdfc9b88b  -S https://images.joyent.com
+# Image 2d4068a1-d3da-4f93-bcda-db872bc7ded7 (HVM, ubuntu-certified-16.04, 20190212)
+sdc-imgadm get 2d4068a1-d3da-4f93-bcda-db872bc7ded7 >/dev/null 2>/dev/null \
+    || sdc-imgadm import 2d4068a1-d3da-4f93-bcda-db872bc7ded7  -S https://images.joyent.com
+
+
 # Setup VMAPI tests to run on either local or SDC mode
 if [[ -n "$opt_local" ]]; then
     export VMAPI_URL=http://localhost:$(json api.port <$CFG_FILE)
diff --git a/test/vms.migrate.test.js b/test/vms.migrate.test.js
new file mode 100644
index 0000000..6a158cc
--- /dev/null
+++ b/test/vms.migrate.test.js
@@ -0,0 +1,257 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright 2019 Joyent, Inc.
+ */
+
+/*
+ * Migration test plan overview:
+ *  test bad actions (no migration, ...)
+ *  provision test vm (which will later be migrated)
+ *    test bad actions
+ *  migrate begin
+ *    test bad actions (starting migrate again...)
+ *    abort (destroys the provisioned vm from begin)
+ *  migrate begin
+ *    test migrate watch
+ *    migrate sync
+ *      test migrate watch
+ *    migrate sync again
+ *    migrate switch
+ *      test migrate watch
+ *  migrate full (begin, sync, switch)
+ *    test migrate watch
+ *    migrate cleanup (delete original vm)
+ *  test cleanup
+ */
+
+var assert = require('assert-plus');
+var vasync = require('vasync');
+
+var common = require('./common');
+var testUuid = require('./lib/uuid');
+var testMigration = require('./lib/migration');
+
+
+/* Globals */
+
+var ADMIN_USER_UUID = common.config.ufdsAdminUuid;
+var PROVISION_NETWORKS = [];
+var client;
+
+var configurations = [
+    {
+        type: 'smartos',
+        imageName: 'triton-origin-multiarch-15.4.1',
+        packageName: 'sdc_64',
+        vm: {
+            alias: 'vmapitest-migrate-' + testUuid.generateShortUuid(),
+            brand: 'joyent-minimal',
+            owner_uuid: ADMIN_USER_UUID,
+            tags: {
+                'triton.placement.exclude_virtual_servers': true
+            }
+        }
+    },
+    {
+        type: 'lx',
+        imageName: 'ubuntu-16.04',
+        packageName: 'sample-256M',
+        vm: {
+            alias: 'vmapitest-migrate-' + testUuid.generateShortUuid(),
+            brand: 'lx',
+            owner_uuid: ADMIN_USER_UUID,
+            tags: {
+                'triton.placement.exclude_virtual_servers': true
+            }
+        }
+    },
+    {
+        type: 'docker',
+        // Note that this is not a true docker image, but it's close enough
+        // for testing purposes.
+        imageName: 'ubuntu-16.04',
+        packageName: 'sample-256M',
+        vm: {
+            alias: 'vmapitest-migrate-' + testUuid.generateShortUuid(),
+            brand: 'lx',
+            docker: true,
+            kernel_version: '3.13.0',
+            internal_metadata: {
+                'docker:cmd': '["sh","-c","sleep 86400"]',
+                'docker:env': '["PATH=/usr/local/sbin:/usr/local/bin:' +
+                    '/usr/sbin:/usr/bin:/sbin:/bin"]'
+            },
+            owner_uuid: ADMIN_USER_UUID,
+            tags: {
+                'sdc-docker': true
+            }
+        }
+    },
+    // BHYVE testing is disabled due to failing snapshot (out of space).
+    // {
+    //     type: 'bhyve',
+    //     imageName: 'ubuntu-certified-16.04',
+    //     packageName: 'sample-kvm-2G',
+    //     vm: {
+    //         alias: 'vmapitest-migrate-' + testUuid.generateShortUuid(),
+    //         brand: 'bhyve',
+    //         owner_uuid: ADMIN_USER_UUID,
+    //         tags: {
+    //             'triton.placement.exclude_virtual_servers': true
+    //         }
+    //     }
+    // },
+    {
+        type: 'kvm',
+        imageName: 'ubuntu-certified-16.04',
+        packageName: 'sample-kvm-2G',
+        vm: {
+            alias: 'vmapitest-migrate-' + testUuid.generateShortUuid(),
+            brand: 'kvm',
+            owner_uuid: ADMIN_USER_UUID,
+            tags: {
+                'triton.placement.exclude_virtual_servers': true
+            }
+        }
+    }
+];
+
+exports.setUp = function (callback) {
+    if (client) {
+        callback();
+        return;
+    }
+    common.setUp(function (err, _client) {
+        assert.ifError(err);
+        assert.ok(_client, 'restify client');
+        client = _client;
+        callback();
+    });
+};
+
+/* Tests */
+
+exports.get_admin_fabric_network = function (t) {
+    client.napi.get('/fabrics/' + ADMIN_USER_UUID + '/vlans',
+            function (err, req, res, vlans) {
+        if (err) {
+            // When fabrics are disabled, we get a PreconditionRequiredError.
+            if (err.restCode === 'PreconditionRequiredError') {
+                t.ok(true, 'Fabric networking is not enabled');
+            } else {
+                t.ok(false, 'Error listing fabric vlans: ' + err);
+            }
+
+            t.done();
+            return;
+        }
+
+        lookupFabricNetwork();
+    });
+
+    function lookupFabricNetwork() {
+        client.napi.get('/networks?owner_uuid=' + ADMIN_USER_UUID +
+            '&fabric=true',
+                function (err, req, res, networks) {
+            // console.dir(networks);
+            common.ifError(t, err, 'lookup admin fabric network');
+            t.equal(res.statusCode, 200, '200 OK');
+            t.ok(networks, 'networks is set');
+            t.ok(Array.isArray(networks), 'networks is Array');
+            t.ok(networks.length === 1, '1 network found');
+
+            t.ok(networks[0], 'Admin fabric network should be found');
+            if (Array.isArray(networks) && networks.length >= 1) {
+                PROVISION_NETWORKS = {uuid: networks[0].uuid};
+            }
+
+            t.done();
+        });
+    }
+};
+
+
+exports.config_setup = function configSetup(t) {
+    var packages;
+
+    vasync.forEachPipeline({
+        inputs: configurations,
+        func: function _setupOneConfig(cfg, cb) {
+            t.ok('setup one config', 'setup one config');
+            assert.object(cfg, 'cfg');
+            assert.string(cfg.type, 'cfg.type');
+            assert.string(cfg.packageName, 'cfg.packageName');
+            assert.object(cfg.vm, 'cfg.vm');
+
+            cfg.vm.networks = [PROVISION_NETWORKS];
+
+            vasync.pipeline({funcs: [
+                function loadPackages(_, next) {
+                    if (packages) {
+                        next();
+                        return;
+                    }
+                    client.papi.get('/packages',
+                            function getPackages(err, req, res, packages_) {
+                        common.ifError(t, err, 'getting packages');
+                        packages = packages_;
+                        next();
+                    });
+                },
+                function lookupPackage(_, next) {
+                    var packageMatches = packages.filter(function (p) {
+                        return p.name === cfg.packageName;
+                    });
+                    t.ok(packageMatches.length > 0,
+                        'should find package named: ' + cfg.packageName);
+                    if (packageMatches.length > 0) {
+                        cfg.vm.billing_id = packageMatches[0].uuid;
+                    }
+                    next();
+                    return;
+                },
+                function lookupImage(_, next) {
+                    if (!cfg.imageName) {
+                        next();
+                        return;
+                    }
+                    client.imgapi.get('/images?name=' + cfg.imageName +
+                        '&state=active',
+                            function getImg(err, req, res, imgs) {
+                        common.ifError(t, err, 'err');
+                        t.ok(imgs.length, 'imgs.length');
+
+                        var newestImg = imgs.sort(function byDate(a, b) {
+                            return a.published_at < b.published_at ? 1 : -1;
+                        })[0];
+
+                        if (['kvm', 'bhyve'].indexOf(cfg.type) >= 0) {
+                            cfg.vm.disks = [ {
+                                boot: true,
+                                image_uuid: newestImg.uuid,
+                                model: 'virtio'
+                            } ];
+                        } else {
+                            cfg.vm.image_uuid = newestImg.uuid;
+                        }
+                        next();
+                    });
+                }
+            ]}, cb);
+        }
+    }, function _onConfigSetup(err) {
+        common.ifError(t, err, 'config setup');
+        t.done();
+    });
+};
+
+configurations.forEach(function _forEachConfig(cfg) {
+    var suite = exports[cfg.type] = {};
+
+    testMigration.TestMigrationCfg(suite, cfg);
+});
diff --git a/tools/rsync-to b/tools/rsync-to
index 4e5818f..0de0288 100755
--- a/tools/rsync-to
+++ b/tools/rsync-to
@@ -25,7 +25,7 @@ TOP=$(cd $(dirname $0)/../; pwd)
 NODE="root@$1"
 
 if [[ -z "$VMAPI_ZONE" ]]; then
-    VMAPI_ZONE=$(ssh $NODE "vmadm lookup -1 alias=~^vmapi" 2>/dev/null)
+    VMAPI_ZONE=$(ssh $NODE "vmadm lookup -1 alias=~^vmapi[0-9]+" 2>/dev/null)
 fi
 echo "VMAPI_ZONE: $VMAPI_ZONE"
 
@@ -41,6 +41,7 @@ rsync -av ${TOP}/ \
     $NODE:/zones/$VMAPI_ZONE/root/opt/smartdc/vmapi/ \
     $extraOpts \
     --exclude .git/ \
+    --exclude .history/ \
     --exclude /boot/ \
     --exclude /config.json \
     --exclude /deps/ \
