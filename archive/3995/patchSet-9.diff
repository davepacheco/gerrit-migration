From 89f41401d7517e5e636b991dce472e329c719c47 Mon Sep 17 00:00:00 2001
From: Robert Bogart <robert.bogart@joyent.com>
Date: Wed, 23 May 2018 22:37:10 +0000
Subject: [PATCH] MANTA-3596 binder could export metrics via artedi

---
 lib/client.js     | 44 +++++++++++++++++++++++++++++++++++++++++++-
 lib/zk-session.js | 16 ++++++++++++++++
 package.json      |  3 ++-
 3 files changed, 61 insertions(+), 2 deletions(-)

diff --git a/lib/client.js b/lib/client.js
index d0d1b91..959b3f6 100644
--- a/lib/client.js
+++ b/lib/client.js
@@ -10,6 +10,7 @@ module.exports = { Client: ZKClient };
 
 const mod_fsm = require('mooremachine');
 const mod_assert = require('assert-plus');
+const mod_artedi = require('artedi');
 const mod_consts = require('./zk-consts');
 const mod_util = require('util');
 const mod_stream = require('stream');
@@ -25,6 +26,11 @@ const mod_verror = require('verror');
 const mod_vasync = require('vasync');
 const mod_cfsm = require('./connection-fsm');
 
+var METRIC_ZK_CONNECT_COUNTER = 'zookeeper_connection_events';
+var METRIC_ZK_SESSION_COUNTER = 'zookeeper_session_events';
+var METRIC_ZK_FAILED_COUNTER = 'zookeeper_failed_events';
+var METRIC_ZK_EVENT_COUNTER = 'zookeeper_events';
+
 function ZKClient(opts) {
 	mod_assert.object(opts, 'options');
 
@@ -40,6 +46,23 @@ function ZKClient(opts) {
 		});
 	}
 
+	/*
+	 * If the caller did not supply a collector for tracking metrics, then
+	 * create one internally.  At least for now, it is not a requirement
+	 * for all consumers to provide one.
+	 */
+	mod_assert.optionalObject(opts.collector);
+	if (opts.collector === undefined || opts.collector === null) {
+		this.zc_collector = mod_artedi.createCollector();
+	} else {
+		this.zc_collector = opts.collector;
+	}
+
+	this.zc_collector.counter({
+		name: METRIC_ZK_EVENT_COUNTER,
+		help: 'Total number of zookeeper events'
+	});
+
 	mod_assert.optionalArrayOfObject(opts.servers, 'options.servers');
 	if (opts.servers === undefined || opts.servers === null) {
 		mod_assert.string(opts.address, 'options.address');
@@ -168,7 +191,8 @@ ZKClient.prototype._newSession = function () {
 		return;
 	var s = new mod_zks.ZKSession({
 		timeout: this.zc_sessionTimeout,
-		log: this.zc_log
+		log: this.zc_log,
+		collector: this.zc_collector
 	});
 	this.zc_session = s;
 	function initialHandler(st) {
@@ -196,6 +220,21 @@ ZKClient.prototype.isConnected = function () {
 	return (conn !== undefined && conn.isInState('connected'));
 };
 
+ZKClient.prototype._eventTrack = function (evt) {
+	var self = this;
+	var counter;
+
+	/*
+	 * For now, we are maintaining counts for session, connect and failure
+	 * related events.
+	 */
+	if (evt != 'session' && evt != 'connect' && evt != 'failed')
+		return;
+
+	counter = self.zc_collector.getCollector(METRIC_ZK_EVENT_COUNTER);
+	counter.increment({evtype: evt});
+};
+
 ZKClient.prototype._emitAfterConnected = function (evt) {
 	/*
 	 * We don't want to emit 'connect' until someone can safely call
@@ -207,6 +246,7 @@ ZKClient.prototype._emitAfterConnected = function (evt) {
 	var c = this.currentConnection();
 	if (c.isInState('connected')) {
 		setImmediate(function () {
+			self._eventTrack(evt);
 			self.emit(evt);
 		});
 	} else {
@@ -215,6 +255,7 @@ ZKClient.prototype._emitAfterConnected = function (evt) {
 			if (cst === 'connected') {
 				c.removeListener(
 				    'stateChanged', onConnCh);
+				self._eventTrack(evt);
 				self.emit(evt);
 			}
 		}
@@ -251,6 +292,7 @@ ZKClient.prototype._onSetStateChanged = function (st) {
 	var self = this;
 	if (st === 'failed') {
 		setImmediate(function () {
+			self._eventTrack('failed');
 			self.emit('failed', new Error('Failed to connect to ' +
 			    'ZK (exhausted initial retry policy)'));
 		});
diff --git a/lib/zk-session.js b/lib/zk-session.js
index a3489d5..75c4472 100644
--- a/lib/zk-session.js
+++ b/lib/zk-session.js
@@ -22,10 +22,13 @@ const mod_events = require('events');
 const mod_bunyan = require('bunyan');
 const mod_verror = require('verror');
 
+var METRIC_ZK_NOTIFICATION_COUNTER = 'zookeeper_notifications';
+
 function ZKSession(opts) {
 	mod_assert.object(opts, 'options');
 	mod_assert.number(opts.timeout, 'options.timeout');
 	mod_assert.object(opts.log, 'options.log');
+	mod_assert.object(opts.collector, 'options.collector');
 
 	this.zs_conn = undefined;
 	this.zs_oldConn = undefined;
@@ -37,11 +40,18 @@ function ZKSession(opts) {
 	this.zs_log = opts.log.child({
 		component: 'ZKSession'
 	});
+	this.zs_collector = opts.collector;
 
 	this.zs_lastZxid = new mod_jsbn.BigInteger('0');
 	this.zs_sessionId = new mod_jsbn.BigInteger('0');
 	this.zs_passwd = new Buffer(8).fill(0);
 
+	/* Create a counter for tracking ZooKeeper notifications. */
+	this.zs_collector.counter({
+		name: METRIC_ZK_NOTIFICATION_COUNTER,
+		help: 'Notifications received from ZooKeeper'
+	});
+
 	mod_fsm.FSM.call(this, 'detached');
 }
 mod_util.inherits(ZKSession, mod_fsm.FSM);
@@ -158,6 +168,7 @@ ZKSession.prototype.state_attaching = function (S) {
 		self.zs_sessionId = sid;
 		self.zs_passwd = pkt.passwd;
 		self.resetExpiryTimer();
+
 		S.gotoState('attached');
 	});
 
@@ -351,6 +362,11 @@ ZKSession.prototype.processNotification = function (pkt) {
 		zxid: pkt.zxid.toString('hex'),
 		type: pkt.type
 	}, 'notification %s for %s', evt, pkt.path);
+
+	var notifications = this.zs_collector.getCollector(
+	    METRIC_ZK_NOTIFICATION_COUNTER);
+	notifications.increment({event: evt});
+
 	if (watcher)
 		watcher.emit(evt);
 };
diff --git a/package.json b/package.json
index 23daeef..bc72a66 100644
--- a/package.json
+++ b/package.json
@@ -1,6 +1,6 @@
 {
   "name": "zkstream",
-  "version": "0.10.1",
+  "version": "0.11.0",
   "description": "",
   "repository": {
     "type": "git",
@@ -8,6 +8,7 @@
   },
   "main": "lib/index.js",
   "dependencies": {
+    "artedi": "1.3.0",
     "assert-plus": "^1.0.0",
     "bunyan": "^1.8.10",
     "cueball": "^2.2.7",
-- 
2.21.0

