From 7210df18daa40a57a8b58b52781c6c3152558648 Mon Sep 17 00:00:00 2001
From: Cody Peter Mello <cody.mello@joyent.com>
Date: Wed, 6 Dec 2017 01:29:44 +0000
Subject: [PATCH] OS-5186 DHCP Client Identifiers should be permitted in VMs
 using DHCP

---
 .../generic/usr/lib/brand/jcommon/statechange |  19 ++-
 src/vm/man/vmadm.1m.md                        |  17 +-
 src/vm/node_modules/VM.js                     | 159 +++++++++++++-----
 src/vm/node_modules/proptable.js              |  13 ++
 src/vm/node_modules/utils.js                  |   6 +
 src/vm/tests/test-spoof-opts.js               | 126 +++++++++++++-
 6 files changed, 291 insertions(+), 49 deletions(-)

diff --git a/overlay/generic/usr/lib/brand/jcommon/statechange b/overlay/generic/usr/lib/brand/jcommon/statechange
index c332716f..2f9cbbc2 100644
--- a/overlay/generic/usr/lib/brand/jcommon/statechange
+++ b/overlay/generic/usr/lib/brand/jcommon/statechange
@@ -215,6 +215,7 @@ setup_net()
 		allow_unfiltered_promisc=$(get_boolean_nic_property ${nic} \
 		    allow_unfiltered_promisc)
 		allowed_ips=$(eval echo \$_ZONECFG_net_${nic}_allowed_ips)
+		allowed_dhcp_cids=$(eval echo \$_ZONECFG_net_${nic}_allowed_dhcp_cids)
 		vrid=$(eval echo \$_ZONECFG_net_${nic}_vrrp_vrid)
 		vrrp_primary_ip=$(eval \
 		    echo \$_ZONECFG_net_${nic}_vrrp_primary_ip)
@@ -521,11 +522,25 @@ setup_net()
 			if [[ -n ${allowed_ip_list} ]] &&
 			    ! dladm set-linkprop -t -z $ZONENAME \
 			    -p "allowed-ips=${allowed_ip_list}" ${nic}; then
-				log_and_exit
+				log_and_exit \
 				    "error setting VNIC allowed-ips $nic $allowed_ip_list"
 			fi
 		fi
 
+		if [[ "$enable_dhcp" != "true" ]] && [[ -n "$allowed_dhcp_cids" ]] &&
+		    ! dladm set-linkprop -p "allowed-dhcp-cids=${allowed_dhcp_cids}" \
+		    -t -z $ZONENAME $nic; then
+			log_and_exit \
+			    "error setting VNIC allowed-dhcp-cids $nic $allowed_dhcp_cids"
+		fi
+
+		if [[ "$enable_dhcp" != "true" ]] && [[ -z "$allowed_dhcp_cids" ]] &&
+		    [[ "$zone_ips" == *dhcp* || "$zone_ips" == *addrconf* ]] &&
+		    ! dladm set-linkprop -p "allow-all-dhcp-cids=true" \
+		    -t -z $ZONENAME $nic; then
+			log_and_exit "error setting VNIC allow-all-dhcp-cids $nic"
+		fi
+
 		if [[ -n "$jst_ufpromisc" && ${allow_unfiltered_promisc} == "true" ]]; then
 			dladm set-linkprop -t -z $ZONENAME -p "promisc-filtered=off" ${nic}
 		fi
@@ -537,7 +552,7 @@ setup_net()
 				# br='block remote'.  Flow names should be < 31
 				# chars in length so that they get unique
 				# kstats.
-			 	# Use the VNIC mac addr. to generate a unique
+				# Use the VNIC mac addr. to generate a unique
 				# name.
 				mac_addr=`dladm show-vnic -z $ZONENAME -p \
 				    -o MACADDRESS $nic | tr ':' '_'`
diff --git a/src/vm/man/vmadm.1m.md b/src/vm/man/vmadm.1m.md
index 9f255dc2..4691fca6 100644
--- a/src/vm/man/vmadm.1m.md
+++ b/src/vm/man/vmadm.1m.md
@@ -1363,7 +1363,7 @@ tab-complete UUIDs rather than having to type them out for every command.
     nics.*.allowed_ips:
 
         This sets additional IP addresses from which this nic is allowed to
-        send traffic, in addition to the IPs in the ip and vrrp_primary_ip
+        send traffic, in addition to the IPs in the ips and vrrp_primary_ip
         properties (if set). Values may be single IPv4 or IPv6 addresses
         or IPv4 and IPv6 CIDR ranges. The following are all valid
         examples of allowed_ips: '10.169.0.0/16', '10.99.99.7',
@@ -1375,6 +1375,21 @@ tab-complete UUIDs rather than having to type them out for every command.
         create: yes
         update: yes
 
+    nics.*.allowed_dhcp_cids:
+
+        This specifies which DHCP Client Identifiers outbound DHCP packets are
+        allowed to use. By default, when no Client Identifiers are listed, and
+        nics.*.ips includes "dhcp" or "addrconf", all DHCP Client Identifiers
+        are permitted. Client Identifiers are specified as a string of pairs of
+        hexadecimal characters beginning with the prefix "0x". Up to 32 Client
+        Identifiers can be listed.
+
+        type: array (of even-lengthed hexadecimal strings beginning with "0x")
+        vmtype: OS,LX,KVM
+        listable: yes (see above)
+        create: yes
+        update: yes
+
     nics.*.dhcp_server:
 
         With this property set to true, this VM will be able to operate as a
diff --git a/src/vm/node_modules/VM.js b/src/vm/node_modules/VM.js
index 32a0cafe..87b87179 100644
--- a/src/vm/node_modules/VM.js
+++ b/src/vm/node_modules/VM.js
@@ -4966,6 +4966,14 @@ function checkPayloadProperties(payload, vmobj, log, callback)
                         }
                     }
 
+                    if (n.hasOwnProperty('allowed_dhcp_cids')
+                        && n.allowed_dhcp_cids.length > 32) {
+                        callback(new Error(
+                            'nics.*.allowed_dhcp_cids contains '
+                            + n.allowed_dhcp_cids.length
+                            + ' Client Identifiers, but is limited to 32'));
+                        return;
+                    }
                 }
             }
         }
@@ -5753,6 +5761,13 @@ function buildNicZonecfg(vmobj, payload, log)
                 + nic.allowed_ips.join(',') + '")\n';
         }
 
+        if (nic.hasOwnProperty('allowed_dhcp_cids')
+            && nic.allowed_dhcp_cids.length > 0) {
+            zcfg = zcfg
+                + 'add property (name=allowed_dhcp_cids, value="'
+                + nic.allowed_dhcp_cids.join(',') + '")\n';
+        }
+
         for (var prop in nicProperties) {
             prop = nicProperties[prop];
             if (nic.hasOwnProperty(prop)) {
@@ -12550,6 +12565,60 @@ function resizeDisks(disks, updates, log, callback)
     });
 }
 
+function updateVnicAllowedCIDs(uuid, nic, log, callback) {
+    var tracers_obj;
+
+    assert(log, 'no logger passed to updateVnicAllowedCIDs()');
+
+    if (process.env.EXPERIMENTAL_VMJS_TRACING) {
+        tracers_obj = traceUntilCallback('update-vnic-allowed-ips', log,
+            callback);
+        callback = tracers_obj.callback;
+        log = tracers_obj.log;
+    }
+
+    if (!uuid || !nic.interface) {
+        callback();
+        return;
+    }
+
+    var allow_dhcp_spoofing =
+        nic.hasOwnProperty('allow_dhcp_spoofing') && nic.allow_dhcp_spoofing;
+    var dhcp_server = nic.hasOwnProperty('dhcp_server') && nic.dhcp_server;
+    var cids = nic.hasOwnProperty('allowed_dhcp_cids') ?
+        nic.allowed_dhcp_cids : [];
+
+    if (allow_dhcp_spoofing || dhcp_server || cids.length === 0) {
+        vasync.pipeline({
+            'funcs': [
+                function (_, cb) {
+                    dladm.resetLinkProp(uuid, nic.interface,
+                        'allowed-dhcp-cids', log, cb);
+                },
+                function (_, cb) {
+                    dladm.setLinkProp(uuid, nic.interface,
+                        'allow-all-dhcp-cids', true, log, cb);
+                }
+            ]
+        }, callback);
+        return;
+    } else {
+        vasync.pipeline({
+            'funcs': [
+                function (_, cb) {
+                    dladm.setLinkProp(uuid, nic.interface,
+                        'allowed-dhcp-cids', cids, log, cb);
+                },
+                function (_, cb) {
+                    dladm.resetLinkProp(uuid, nic.interface,
+                        'allow-all-dhcp-cids', log, cb);
+                }
+            ]
+        }, callback);
+        return;
+    }
+}
+
 function updateVnicAllowedIPs(uuid, nic, log, callback)
 {
     var ips = {};
@@ -12634,6 +12703,7 @@ function updateVnicProperties(uuid, vmobj, payload, log, callback)
         var opt;
         var needsUpdate = false;
         var needsIPupdate = false;
+        var needsCIDupdate = false;
         var spoof_opts = {
             'allow_ip_spoofing': 'ip-nospoof',
             'allow_mac_spoofing': 'mac-nospoof',
@@ -12651,12 +12721,20 @@ function updateVnicProperties(uuid, vmobj, payload, log, callback)
             }
         }
 
+        if (nic.hasOwnProperty('dhcp_server')) {
+            needsUpdate = true;
+        }
+
         if (nic.hasOwnProperty('vrrp_primary_ip')
             || nic.hasOwnProperty('allowed_ips')
             || nic.hasOwnProperty('allow_ip_spoofing')) {
             needsIPupdate = true;
         }
 
+        if (nic.hasOwnProperty('allowed_dhcp_cids')) {
+            needsCIDupdate = true;
+        }
+
         for (vm_nic in vmobj.nics) {
             vm_nic = vmobj.nics[vm_nic];
             if (vm_nic.mac == nic.mac) {
@@ -12669,17 +12747,6 @@ function updateVnicProperties(uuid, vmobj, payload, log, callback)
             return;
         }
 
-        if (!needsUpdate) {
-            log.debug('No spoofing / allowed IP opts updated for nic "'
-                + nic.mac + '": not updating');
-            if (needsIPupdate) {
-                updateVnicAllowedIPs(uuid, vm_nic, log, cb);
-            } else {
-                cb(null);
-            }
-            return;
-        }
-
         // Using the updated nic object, figure out what spoofing opts to set
         for (opt in spoof_opts) {
             if (vm_nic.hasOwnProperty(opt) && fixBoolean(vm_nic[opt])) {
@@ -12693,45 +12760,47 @@ function updateVnicProperties(uuid, vmobj, payload, log, callback)
             delete spoof_opts.allow_ip_spoofing;
         }
 
-        if (Object.keys(spoof_opts).length === 0) {
-            dladm.resetLinkProp(uuid, vm_nic.interface, 'protection', log,
-                function (err) {
-                    if (err) {
-                        cb(err);
-                        return;
-                    }
-                    if (needsIPupdate) {
-                        updateVnicAllowedIPs(uuid, vm_nic, log, cb);
+        vasync.pipeline({
+            'funcs': [
+                function (_, cont) {
+                    if (!needsUpdate) {
+                        log.debug('No spoofing opts updated for nic "'
+                            + nic.mac + '": not updating');
+                        cont();
                         return;
                     }
-                    cb();
-                    return;
-                });
-        } else {
-            dladm.setLinkProp(uuid, vm_nic.interface, 'protection',
-                    Object.keys(spoof_opts).map(function (k) {
-                        return spoof_opts[k];
-                    }), log,
-                function (err) {
-                    if (err) {
-                        cb(err);
-                        return;
+
+                    if (Object.keys(spoof_opts).length === 0) {
+                        dladm.resetLinkProp(uuid, vm_nic.interface,
+                            'protection', log, cont);
+                    } else {
+                        dladm.setLinkProp(uuid, vm_nic.interface, 'protection',
+                                Object.keys(spoof_opts).map(function (k) {
+                                    return spoof_opts[k];
+                                }), log, cont);
                     }
+                },
+                function (_, cont) {
                     if (needsIPupdate) {
-                        updateVnicAllowedIPs(uuid, vm_nic, log, cb);
-                        return;
+                        updateVnicAllowedIPs(uuid, vm_nic, log, cont);
+                    } else {
+                        log.debug('No allowed IPs updated for nic "'
+                            + nic.mac + '": not updating');
+                        cont();
+                    }
+                },
+                function (_, cont) {
+                    if (needsCIDupdate) {
+                        updateVnicAllowedCIDs(uuid, vm_nic, log, cont);
+                    } else {
+                        log.debug('No allowed DHCP CIDs updated for nic "'
+                            + nic.mac + '": not updating');
+                        cont();
                     }
-                    cb();
-                    return;
-                });
-        }
-    }, function (err) {
-        if (err) {
-            callback(err);
-        } else {
-            callback(null);
-        }
-    });
+                }
+            ]
+        }, cb);
+    }, callback);
 }
 
 // Ensure that we're logging to the fwadm logs
diff --git a/src/vm/node_modules/proptable.js b/src/vm/node_modules/proptable.js
index 935da0ae..ef8ec240 100644
--- a/src/vm/node_modules/proptable.js
+++ b/src/vm/node_modules/proptable.js
@@ -1195,6 +1195,19 @@ exports.properties = {
             type: 'list'
         },
         zonexml: 'zone.network.net-attr.allowed_ips'
+    }, 'nics.*.allowed_dhcp_cids': {
+        loadValueTranslator: 'utils.separateCommas',
+        payload: {
+            allowed: {
+                'joyent': ['add', 'update'],
+                'joyent-minimal': ['add', 'update'],
+                'kvm': ['add', 'update'],
+                'lx': ['add', 'update']
+            },
+            type: 'list',
+            valueValidator: 'utils.validCID'
+        },
+        zonexml: 'zone.network.net-attr.allowed_dhcp_cids'
     }, 'nics.*.blocked_outgoing_ports': {
         loadValueTranslator: 'utils.separateCommasAndNumberify',
         payload: {
diff --git a/src/vm/node_modules/utils.js b/src/vm/node_modules/utils.js
index 157b96bb..36733a5c 100644
--- a/src/vm/node_modules/utils.js
+++ b/src/vm/node_modules/utils.js
@@ -252,6 +252,11 @@ function validMacAddress(str)
     return /^[0-9a-fA-F:]+$/.test(str);
 }
 
+function validCID(cid)
+{
+    return /^0x[0-9a-fA-F]+$/.test(cid) && (cid.length % 2) === 0;
+}
+
 function ltrim(str, chars)
 {
     chars = chars || '\\s';
@@ -327,6 +332,7 @@ module.exports = {
     unbase64: unbase64,
     unmangleMem: unmangleMem,
     validAttrValue: validAttrValue,
+    validCID: validCID,
     validResolver: validResolver,
     validMacAddress: validMacAddress,
     vrrpMAC: vrrpMAC
diff --git a/src/vm/tests/test-spoof-opts.js b/src/vm/tests/test-spoof-opts.js
index e1de9801..b62d44ba 100644
--- a/src/vm/tests/test-spoof-opts.js
+++ b/src/vm/tests/test-spoof-opts.js
@@ -33,6 +33,14 @@ function nic_link_props(opts, callback) {
 
         opts.t.deepEqual(props.protection.sort(), opts.props,
             opts.nic + ': antispoof options ' + opts.desc);
+        opts.t.deepEqual(props['allow-all-dhcp-cids'],
+            (opts.allowed_dhcp_cids[0] === '*').toString(),
+            opts.nic + ': all client identifiers allowed ' + opts.desc);
+        opts.t.deepEqual(props['allowed-dhcp-cids'].sort(),
+            opts.allowed_dhcp_cids.map(function (cid) {
+                return (cid === '*' ? '--' : cid);
+            }),
+            opts.nic + ': allowed client identifiers ' + opts.desc);
         opts.t.deepEqual(props['allowed-ips'].sort(),
             opts.allowed_ips.map(function (ip) {
                 if (ip == '--') {
@@ -103,6 +111,9 @@ function brand_test(brand, image, t) {
                 allow_dhcp_spoofing: true,
                 allow_mac_spoofing: true,
                 allowed_ips: [ '10.6.0.201', '10.6.0.202', '10.6.0.0/25' ]
+            }, {
+                nic_tag: 'admin',
+                ips: [ 'addrconf' ]
             }
         ]
     };
@@ -133,6 +144,7 @@ function brand_test(brand, image, t) {
                     allow_dhcp_spoofing: true,
                     allow_mac_spoofing: true
                 });
+                nic_antispoof_props(t, obj.nics[4], 'net4', {});
 
                 t.deepEqual(obj.nics[3].allowed_ips,
                     [ '10.6.0.201', '10.6.0.202', '10.6.0.0/25' ],
@@ -148,12 +160,28 @@ function brand_test(brand, image, t) {
                     uuid: state.uuid,
                     nic: 'net' + i,
                     t: t,
+                    allowed_dhcp_cids: [ '--' ],
                     props: [ 'dhcp-nospoof', 'ip-nospoof', 'mac-nospoof',
                         'restricted' ],
                     allowed_ips: [ ips[i] ]
                 }, cb2);
             }, cb);
 
+        }, function (cb) {
+            nic_link_props({
+                desc: 'after provision',
+                uuid: state.uuid,
+                nic: 'net4',
+                t: t,
+                allowed_dhcp_cids: [ '*' ],
+                props: [
+                    'dhcp-nospoof', 'ip-nospoof',
+                    'mac-nospoof', 'restricted'
+                ],
+                dynamic_methods: [ 'dhcpv6', 'slaac' ],
+                allowed_ips: [ '--' ]
+            }, cb);
+
         }, function (cb) {
             // Updating a nic to have more than 13 allowed_ips should fail
             VM.update(state.uuid, { update_nics: [ {
@@ -174,11 +202,67 @@ function brand_test(brand, image, t) {
                 return cb();
             });
 
+        }, function (cb) {
+            // Updating a nic to have more than 32 allowed_dhcp_cids should fail
+            VM.update(state.uuid, { update_nics: [ {
+                mac: state.nics[2].mac,
+                allowed_dhcp_cids: [
+                    '0x01', '0x02', '0x03', '0x04', '0x05', '0x06', '0x07',
+                    '0x08', '0x09', '0x0a', '0x0b', '0x0c', '0x0d', '0x0e',
+                    '0x0f', '0x10', '0x11', '0x12', '0x13', '0x14', '0x15',
+                    '0x16', '0x17', '0x18', '0x19', '0x1a', '0x1b', '0x1c',
+                    '0x1d', '0x1e', '0x1f', '0x20', '0x21'
+                ]
+            } ]}, function (e) {
+                t.ok(e, 'error returned');
+                if (e) {
+                    t.equal(e.message, 'nics.*.allowed_dhcp_cids contains '
+                        + '33 Client Identifiers, but is limited to 32',
+                        'allowed_dhcp_cids error message');
+                }
+
+                cb();
+            });
+
+        }, function (cb) {
+            // allowed_dhcp_cids must start with "0x"
+            VM.update(state.uuid, { update_nics: [ {
+                mac: state.nics[2].mac,
+                allowed_dhcp_cids: [ '1234' ]
+            } ]}, function (e) {
+                t.ok(e, 'error returned');
+                if (e) {
+                    t.equal(e.message,
+                        'Invalid value(s) for: nics.*.allowed_dhcp_cids',
+                        'allowed_dhcp_cids error message');
+                }
+
+                cb();
+            });
+
+        }, function (cb) {
+            // allowed_dhcp_cids must be hex
+            VM.update(state.uuid, { update_nics: [ {
+                mac: state.nics[2].mac,
+                allowed_dhcp_cids: [ '0xqz' ]
+            } ]}, function (e) {
+                t.ok(e, 'error returned');
+                if (e) {
+                    t.equal(e.message,
+                        'Invalid value(s) for: nics.*.allowed_dhcp_cids',
+                        'allowed_dhcp_cids error message');
+                }
+
+                cb();
+            });
+
         }, function (cb) {
             // update nics:
             //   net0: set ip and mac spoofing
             //   net1: allow all spoofing
-            //   net1: change allowed_ips only
+            //   net2: change allowed_ips only
+            //   net3: no changes, should remain the same
+            //   net3: add allowed Client Identifier 0x1234
             VM.update(state.uuid, { update_nics: [
                 {
                     mac: state.nics[0].mac,
@@ -195,6 +279,10 @@ function brand_test(brand, image, t) {
                 {
                     mac: state.nics[2].mac,
                     allowed_ips: [ '10.5.0.201', '10.5.0.202' ]
+                },
+                {
+                    mac: state.nics[4].mac,
+                    allowed_dhcp_cids: [ '0x4321' ]
                 }
             ]}, function (e) {
 
@@ -228,6 +316,18 @@ function brand_test(brand, image, t) {
                         allowed_ips: true
                     });
 
+                    // net3
+                    nic_antispoof_props(t, obj.nics[3], 'net3', {
+                        allowed_ips: true,
+                        allow_dhcp_spoofing: true,
+                        allow_mac_spoofing: true
+                    });
+
+                    // net4
+                    nic_antispoof_props(t, obj.nics[4], 'net4', {
+                        allowed_dhcp_cids: [ '0x4321' ]
+                    });
+
                     t.deepEqual(obj.nics[2].allowed_ips,
                         [ '10.5.0.201', '10.5.0.202' ],
                         'net2: allowed_ips set correctly');
@@ -243,6 +343,7 @@ function brand_test(brand, image, t) {
                 uuid: state.uuid,
                 nic: 'net0',
                 t: t,
+                allowed_dhcp_cids: [ '--' ],
                 props: [ 'dhcp-nospoof', 'restricted' ],
                 allowed_ips: [ '--' ]
             }, cb);
@@ -254,6 +355,7 @@ function brand_test(brand, image, t) {
                 uuid: state.uuid,
                 nic: 'net1',
                 t: t,
+                allowed_dhcp_cids: [ '--' ],
                 props: [ '--' ],
                 allowed_ips: [ '--' ]
             }, cb);
@@ -265,11 +367,27 @@ function brand_test(brand, image, t) {
                 uuid: state.uuid,
                 nic: 'net2',
                 t: t,
+                allowed_dhcp_cids: [ '--' ],
                 props: [ 'dhcp-nospoof', 'ip-nospoof', 'mac-nospoof',
                     'restricted' ],
                 allowed_ips: [ips[2], '10.5.0.201', '10.5.0.202']
             }, cb);
 
+        }, function (cb) {
+            // Check net4's link props
+            nic_link_props({
+                desc: 'after first update',
+                uuid: state.uuid,
+                nic: 'net4',
+                t: t,
+                allowed_dhcp_cids: [ '0x4321' ],
+                props: [
+                    'dhcp-nospoof', 'ip-nospoof',
+                    'mac-nospoof', 'restricted'
+                ],
+                allowed_ips: [ '--' ]
+            }, cb);
+
         }, function (cb) {
             // update net1 to disable dhcp spoofing
             VM.update(state.uuid, {update_nics: [ {
@@ -318,6 +436,7 @@ function brand_test(brand, image, t) {
                 uuid: state.uuid,
                 nic: 'net0',
                 t: t,
+                allowed_dhcp_cids: [ '--' ],
                 props: [ 'dhcp-nospoof', 'restricted' ],
                 allowed_ips: [ '--' ]
             }, cb);
@@ -329,6 +448,7 @@ function brand_test(brand, image, t) {
                 uuid: state.uuid,
                 nic: 'net1',
                 t: t,
+                allowed_dhcp_cids: [ '--' ],
                 props: [ 'dhcp-nospoof' ],
                 allowed_ips: [ '--' ]
             }, cb);
@@ -340,6 +460,7 @@ function brand_test(brand, image, t) {
                 uuid: state.uuid,
                 nic: 'net2',
                 t: t,
+                allowed_dhcp_cids: [ '--' ],
                 props: [ 'dhcp-nospoof', 'ip-nospoof', 'mac-nospoof',
                     'restricted' ],
                 allowed_ips: [ips[2], '10.5.0.201', '10.5.0.202']
@@ -393,6 +514,7 @@ function brand_test(brand, image, t) {
                 uuid: state.uuid,
                 nic: 'net0',
                 t: t,
+                allowed_dhcp_cids: [ '--' ],
                 props: [ 'dhcp-nospoof', 'restricted' ],
                 allowed_ips: [ '--' ]
             }, cb);
@@ -403,6 +525,7 @@ function brand_test(brand, image, t) {
                 uuid: state.uuid,
                 nic: 'net1',
                 t: t,
+                allowed_dhcp_cids: [ '--' ],
                 props: [ 'dhcp-nospoof' ],
                 allowed_ips: [ '--' ]
             }, cb);
@@ -413,6 +536,7 @@ function brand_test(brand, image, t) {
                 uuid: state.uuid,
                 nic: 'net2',
                 t: t,
+                allowed_dhcp_cids: [ '--' ],
                 props: [ 'dhcp-nospoof', 'ip-nospoof', 'mac-nospoof',
                     'restricted' ],
                 allowed_ips: [ips[2], '10.5.0.201', '10.5.0.202']
-- 
2.21.0

