From 9e866652adc65a3207d94a6a7eaf83998d6d180d Mon Sep 17 00:00:00 2001
From: Tim Kordas <tim.kordas@joyent.com>
Date: Tue, 8 Aug 2017 16:04:58 -0700
Subject: [PATCH] MANTA-3311 mako_gc carefully checks lock file but barrels on
 if it can't create one

---
 bin/mako_gc.sh | 78 ++++++++++++++++++++++++++++++++++++++++----------
 1 file changed, 63 insertions(+), 15 deletions(-)

diff --git a/bin/mako_gc.sh b/bin/mako_gc.sh
index 3e4dfa6..e308209 100755
--- a/bin/mako_gc.sh
+++ b/bin/mako_gc.sh
@@ -22,8 +22,6 @@
 
 export PATH=/opt/local/bin:$PATH
 
-
-
 ## Global vars
 
 # Immutables
@@ -42,7 +40,8 @@ MPATH=/manta_gc/mako/$MANTA_STORAGE_ID
 PID=$$
 SCRIPT=$(basename $0)
 TMP_DIR=/tmp/mako_gc
-PID_FILE=/tmp/mako_gc.pid
+GC_LOCKFILE=/tmp/mako_gc_lock
+HOLDING_LOCK=false
 TOMB_DATE=$(date "+%Y-%m-%d")
 TOMB_ROOT=/manta/tombstone
 TOMB_DIR=$TOMB_ROOT/$TOMB_DATE
@@ -84,6 +83,7 @@ function fatal {
     updatelnow
     echo "$LNOW: $SCRIPT ($PID): fatal error: $*" >&2
     audit
+    [[ HOLDING_LOCK = "true" ]] && rm -f $GC_LOCKFILE
     exit 1
 }
 
@@ -179,25 +179,73 @@ function manta_delete() {
         || fatal "unable to delete $1"
 }
 
+# Check to make sure we're the only one running
+# https://github.com/joyent/manta-scripts/blob/master/backup.sh#L74
+# $1 -> lockfile to create
+# $$ pid of this script
+function create_lockfile() {
+    # Creating the tempfile can race, but
+    # ln(1) is atomic, so that's the true locking
+    # operation
+    TEMPFILE="$1.$$"
+    LOCKFILE="$1.lock"
+    if ! echo $$ > $TEMPFILE 2>/dev/null; then
+        echo "Unable to write to directory: $(dirname $TEMPFILE)" >&2
+        return 1
+    fi
+
+    # Create lock, remove TEMPFILE
+    #
+    # Use ln(1) to move the temporary file into place because,
+    # unlike mv(1), it will fail if the destination existed
+    # already.
+    if /usr/bin/ln "$TEMPFILE" "$LOCKFILE" 2>/dev/null; then
+        /usr/bin/rm -f "$TEMPFILE"
+        HOLDING_LOCK=true
+        return 0
+    fi
+
+    STALE_PID=$(< $LOCKFILE)
+    if [[ ! "$STALE_PID" -gt "0" ]]; then
+        /usr/bin/rm -f "$TEMPFILE"
+        return 1
+    fi
+
+    # Test if PID from lockfile is running
+    # If it is still running, the function will return here
+    if /usr/bin/kill -0 "$STALE_PID" 2>/dev/null; then
+        /usr/bin/rm -f "$TEMPFILE"
+        return 1
+    fi
+
+    # PID was stale, remove it, then attempt to create lockfile
+    # again
+    if /usr/bin/rm "$LOCKFILE" 2>/dev/null; then
+        echo "Removed stale lock file of process $STALE_PID"
+    fi
+
+    if /usr/bin/ln "$TEMPFILE" "$LOCKFILE" 2>/dev/null; then
+        /usr/bin/rm -f "$TEMPFILE"
+        HOLDING_LOCK=true
+        return 0
+    fi
 
+    # Creating lockfile failed, cleanup and error out
+    /usr/bin/rm -f "$TEMPFILE"
+    return 1
+}
 
 ## Main
 
 : ${MANTA_STORAGE_ID:?"Manta storage id must be set."}
 
-# Check the last pid to see if a previous cron is still running...
-LAST_PID=$(cat $PID_FILE 2>/dev/null)
 
-if [[ -n "$LAST_PID" ]]; then
-    ps -p $LAST_PID >/dev/null
-    if [[ $? -eq 0 ]]; then
-        echo "$0 process still running.  Exiting..."
-        exit 1
-    fi
+# Do not run if this script is being run already
+if ! create_lockfile $GC_LOCKFILE; then
+    RPID=$(< $GC_LOCKFILE)
+    fatal "mako_gc is already running on pid: $RPID"
 fi
 
-echo -n $PID >$PID_FILE
-
 # Ok, we're good to start gc
 log "starting gc"
 
@@ -288,7 +336,7 @@ done
 ERROR="false"
 audit
 
-# Clean up the last pid file...
-rm $PID_FILE
+# Clean up our lock
+rm -f $GC_LOCKFILE
 
 exit 0;
-- 
2.21.0

