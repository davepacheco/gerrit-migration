commit e7f31c890404c40cbfdc2778abf16d2347ff5fa3 (refs/changes/24/2124/1)
Author: Alex Wilson <alex.wilson@joyent.com>
Date:   2017-06-16T19:29:23-07:00 (2 years, 4 months ago)
    
    wip: rewrite binder zk client

diff --git a/lib/index.js b/lib/index.js
index 10b5344..f67446f 100644
--- a/lib/index.js
+++ b/lib/index.js
@@ -12,8 +12,6 @@ var recursion = require('./recursion');
 var server = require('./server');
 var zk = require('./zk');
 
-
-
 ///--- Exports
 
 module.exports = {
diff --git a/lib/recursion.js b/lib/recursion.js
index 48a6e67..7ca33b0 100644
--- a/lib/recursion.js
+++ b/lib/recursion.js
@@ -50,8 +50,7 @@ function Recursion(opts) {
         assert.string(opts.datacenterName, 'opts.datacenterName');
         assert.string(opts.dnsDomain, 'opts.dnsDomain');
         assert.object(opts.ufds, 'opts.ufds');
-        assert.func(opts.zkClient, 'opts.zkClient');
-        assert.object(opts.cache, 'opts.cache');
+        assert.object(opts.zkCache, 'opts.zkCache');
 
         var self = this;
         self.log = opts.log;
@@ -59,8 +58,7 @@ function Recursion(opts) {
         self.datacenterName = opts.datacenterName;
         self.dnsDomain = opts.dnsDomain;
         self.ufdsConfig = opts.ufds;
-        self.zkClient = opts.zkClient;
-        self.cache = opts.cache;
+        self.zkCache = opts.zkCache;
 
         //Init will set these up
         self.interval = null;
@@ -88,40 +86,27 @@ function init() {
 
         //Since we are dns, we need to resolve ufds "manually"
         function resolveUfds(_, subcb) {
-                if (!self.zkClient()) {
+                if (!self.zkCache.isReady()) {
                         return (subcb(new Error('Recursion: ZK is not yet ' +
                                                 'available')));
                 }
                 var domain = self.ufdsConfig.url.replace('ldaps://', '');
-                var query = new function () {
-                        this.name = function () {
-                                return (domain);
-                        };
-                };
-                var req = {
-                        cache: self.cache,
-                        log: self.log,
-                        query: query,
-                        zkClient: self.zkClient()
-                };
-                zk.resolveName(req, function (err, record) {
-                        if (err) {
-                                return (subcb(err));
-                        }
-                        if (!record || !record.children ||
-                            record.children.length < 1) {
-                                return (subcb(new Error(
-                                        'Recursion: not yet able to resolve ' +
-                                                'ufds')));
-                        }
-                        var c = record.children[0];
-                        var addr = c[c.type].address;
-                        _.ufdsConfig = xtend({}, self.ufdsConfig);
-                        _.ufdsConfig.url = 'ldaps://' + addr;
-                        log.debug(_.ufdsConfig,
-                                 'Recursion: resolved ufds config');
-                        return (subcb());
-                });
+
+                var node = self.zkCache.lookup(domain);
+
+                if (!node || !node.data || node.data.type !== 'service' ||
+                    !node.children[0]) {
+                        return (subcb(new Error(
+                            'Recursion: not yet able to resolve ufds')));
+                }
+
+                var kid = node.children[0];
+                var addr = kid.data[kid.data.type].address;
+
+                _.ufdsConfig = xtend({}, self.ufdsConfig);
+                _.ufdsConfig.url = 'ldaps://' + addr;
+                log.debug(_.ufdsConfig, 'Recursion: resolved ufds config');
+                return (subcb());
         }
 
         function initUfds(_, subcb) {
@@ -263,8 +248,7 @@ function lookup(query, hosts, prot, cb) {
                 question: question,
                 server: { address: host, port: port, type: prot },
                 timeout: 3000,
-                try_edns: true,
-                cache: self.cache
+                try_edns: true
         });
 
         var error;
@@ -318,7 +302,7 @@ Recursion.prototype.resolve = function (query, cb) {
         function respond() {
                 if (answers.length === 0) {
                         //See comment in server.js
-                        query.setError('eserver');
+                        query.setError('refused');
                 } else {
                         answers.map(function (a) {
                                 query.addAnswer(domain,
diff --git a/lib/server.js b/lib/server.js
index 249796a..a54fc8a 100644
--- a/lib/server.js
+++ b/lib/server.js
@@ -13,9 +13,6 @@ var dns = require('dns');
 var url = require('url');
 
 var mname = require('mname');
-var nzk = require('node-zookeeper-client');
-
-var zk = require('./zk');
 
 
 ///--- Globals
@@ -65,7 +62,7 @@ function resolve(options, query, cb) {
             (query.type() === 'ANY' && srvmatch)) {
                 if (!srvmatch || srvmatch[3].length < 1) {
                         query._log.debug('not a valid SRV lookup domain');
-                        query.setError('eserver');
+                        query.setError('refused');
                         query.respond();
                         cb();
                         return;
@@ -81,7 +78,7 @@ function resolve(options, query, cb) {
                         stripped = stripSuffix('.' + options.dnsDomain, domain);
                 } else {
                         query._log.trace('not within dns domain suffix');
-                        query.setError('eserver');
+                        query.setError('refused');
                         query.respond();
                         cb();
                         return;
@@ -90,7 +87,7 @@ function resolve(options, query, cb) {
                 if (isSuffix(options.dnsDomain, stripped) ||
                     isSuffix(dcsuff, stripped)) {
                         query._log.trace('doubled-up dns domain suffix');
-                        query.setError('eserver');
+                        query.setError('refused');
                         query.respond();
                         cb();
                         return;
@@ -105,7 +102,7 @@ function resolve(options, query, cb) {
                 }
         }, true);
 
-        if (!options.zkClient()) {
+        if (!options.zkCache.isReady()) {
                 query._log.error('no ZooKeeper client');
                 query.setError('eserver');
                 query.respond();
@@ -113,18 +110,14 @@ function resolve(options, query, cb) {
                 return;
         }
 
-        var req = {
-                cache: options.cache,
-                log: query._log,
-                query: query,
-                stamp: query._stamp,
-                zkClient: options.zkClient()
-        };
+        var log = query._log;
+        var stamp = query._stamp;
+        var zk = options.zkCache;
 
         if (domain.length < 1) {
-                req.log.debug('request for an empty name: this client is ' +
+                log.debug('request for an empty name: this client is ' +
                     'probably misbehaving');
-                query.setError('eserver');
+                query.setError('refused');
                 query.respond();
                 cb();
                 return;
@@ -132,217 +125,209 @@ function resolve(options, query, cb) {
 
         domain = domain.toLowerCase();
         if (/[^a-z0-9_.-]/.test(domain)) {
-                req.log.debug('request for an invalid name: this client is ' +
+                log.debug('request for an invalid name: this client is ' +
                     'probably misbehaving');
-                query.setError('eserver');
+                query.setError('refused');
                 query.respond();
                 cb();
                 return;
         }
 
-        req.domain = domain;
-        zk.resolveName(req, function (err, record) {
-                if (err && (typeof (err.getCode) !== 'function' ||
-                        err.getCode() !== nzk.Exception.NO_NODE)) {
-
-                        req.log.error(err, 'error talking to ZK');
-                        query.setError('eserver');
-                } else if (err && err.getCode() === nzk.Exception.NO_NODE) {
-                        req.log.trace(err, 'node not found in ZK');
-                        //Recursion will take care of answering the query.
-                        if (options.recursion) {
-                                options.recursion.resolve(query, cb);
-                                return;
-                        }
+        var node = zk.lookup(domain);
+
+        if (!node) {
+                log.trace('node not found in ZK cache');
+                /*
+                 * You might expect we would return an NXDOMAIN or
+                 * NODATA response here.
+                 *
+                 * Many of our resolvers use binder as a recursive
+                 * nameserver, higher up their priority list than public
+                 * DNS. This means that if we serve them such a response
+                 * here for a name we don't handle, they will
+                 * immediately return an error to their users and not
+                 * try public DNS.
+                 *
+                 * If we return SERVFAIL or REFUSED though, they will
+                 * try the next server, which is the behaviour we want
+                 * (even though as a result we're not RFC compliant).
+                 */
+                query.setError('refused');
+                stamp('pre-resp');
+                query.respond();
+                cb();
+                return;
+        }
+
+        var record = node.data;
+
+        if (!record || typeof (record.type) !== 'string' ||
+            record[record.type] === null ||
+            typeof (record[record.type]) !== 'object') {
+                log.error({ record: record }, 'invalid ZK record');
+                query.setError('servfail');
+                stamp('pre-resp');
+                query.respond();
+                cb();
+                return;
+        }
+
+        /*
+         * Default the TTL to 30 seconds (the default ZK
+         * session timeout). If the record has an explicit TTL,
+         * it may be written on the root object, or on the
+         * type-specific sub-object (record[record.type]).
+         * This is all an historical mess, but we take the TTL
+         * from the deepest object.
+         */
+        var ttl = 30;
+        if (record.ttl !== undefined)
+                ttl = record.ttl;
+        if (record[record.type].ttl !== undefined)
+                ttl = record[record.type].ttl;
+
+        if (service !== undefined && record.type !== 'service') {
+                /*
+                 * The user asked for an SRV record on something
+                 * that isn't a valid service (e.g. it's a
+                 * specific instance of it). We know we own this
+                 * name, so we can safely return a NODATA
+                 * response.
+                 */
+                query.setError('noerror');
+                stamp('build_response');
+                query.respond();
+                cb();
+                return;
+        }
+
+        var addr;
+        switch (record.type) {
+        case 'database':
+                var _u = url.parse(record.database.primary);
+                addr = _u.hostname;
+                query.addAnswer(domain, new ARecord(addr), ttl);
+                break;
+
+        case 'db_host':
+        case 'host':
+        case 'load_balancer':
+        case 'moray_host':
+        case 'redis_host':
+                addr = record[record.type].address;
+                query.addAnswer(domain, new ARecord(addr), ttl);
+                break;
+
+        case 'service':
+                var s = record.service.service;
+                if (!s || typeof (s) !== 'object') {
+                        log.error({
+                                record: record
+                        }, 'invalid ZK service record');
+                        query.setError('servfail');
+                        break;
+                }
+                /*
+                 * For service-type records, the TTL may also
+                 * be written on record.service.service.
+                 */
+                if (s.ttl !== undefined)
+                        ttl = s.ttl;
+
+                if (service !== undefined &&
+                    (service !== s.srvce || protocol !== s.proto)) {
                         /*
-                         * You might expect we would return an NXDOMAIN or
-                         * NODATA response here.
-                         *
-                         * Many of our resolvers use binder as a recursive
-                         * nameserver, higher up their priority list than public
-                         * DNS. This means that if we serve them such a response
-                         * here for a name we don't handle, they will
-                         * immediately return an error to their users and not
-                         * try public DNS.
-                         *
-                         * If we return SERVFAIL though, they will try the next
-                         * server, which is the behaviour we want (even though
-                         * as a result we're not RFC compliant).
+                         * The user asked for a SRV record for
+                         * a service/protocol name that didn't
+                         * match the one registered. We know
+                         * we own this name, though, so serve
+                         * them an NXDOMAIN.
                          */
-                        query.setError('servfail');
-                } else {
-                        if (typeof (record.type) !== 'string' ||
-                            record[record.type] === undefined ||
-                            record[record.type] === null ||
-                            typeof (record[record.type]) !== 'object') {
-                                req.log.error({
+                        query.setError('nxdomain');
+                        break;
+                }
+                /*
+                 * Make sure we set noerror here, otherwise we
+                 * would respond with NOTIMP to a query about
+                 * a service with no children.
+                 */
+                query.setError('noerror');
+                var kids = node.children.filter(
+                    function (sub) {
+                        return (sub.data.type === 'load_balancer' ||
+                            sub.data.type === 'moray_host' ||
+                            sub.data.type === 'ops_host' ||
+                            sub.data.type === 'rr_host' ||
+                            sub.data.type === 'redis_host');
+                });
+                kids = shuffle(kids);
+                for (var i = 0; i < kids.length; ++i) {
+                        var knode = kids[i];
+                        var krec = knode.data;
+
+                        if (!krec || typeof (krec.type) !== 'string' ||
+                            krec[krec.type] === null ||
+                            typeof (krec[krec.type]) !== 'object') {
+                                //500 this request...
+                                query.setError('eserver');
+                                log.error({
+                                        query: query,
                                         record: record
-                                }, 'invalid ZK service record');
-                                query.setError('servfail');
-                                req.stamp('pre-resp');
-                                query.respond();
-                                cb();
-                                return;
+                                }, 'bad zk info');
+                                break;
                         }
 
-                        var addr;
-
-                        /*
-                         * Default the TTL to 30 seconds (the default ZK
-                         * session timeout). If the record has an explicit TTL,
-                         * it may be written on the root object, or on the
-                         * type-specific sub-object (record[record.type]).
-                         * This is all an historical mess, but we take the TTL
-                         * from the deepest object.
-                         */
-                        var ttl = 30;
-                        if (record.ttl !== undefined)
-                            ttl = record.ttl;
-                        if (record[record.type].ttl !== undefined)
-                            ttl = record[record.type].ttl;
-
-                        if (service !== undefined &&
-                            record.type !== 'service') {
-                                /*
-                                 * The user asked for an SRV record on something
-                                 * that isn't a valid service (e.g. it's a
-                                 * specific instance of it). We know we own this
-                                 * name, so we can safely return a NODATA
-                                 * response.
-                                 */
-                                query.setError('noerror');
-                                req.stamp('build_response');
-                                query.respond();
-                                cb();
-                                return;
+                        var a = krec[krec.type].address;
+                        if (a === null) {
+                                continue;
                         }
-                        switch (record.type) {
-                        case 'database':
-                                var _u = url.parse(record.database.primary);
-                                addr = _u.hostname;
-                                query.addAnswer(domain, new ARecord(addr), ttl);
-                                break;
 
-                        case 'db_host':
-                        case 'host':
-                        case 'load_balancer':
-                        case 'moray_host':
-                        case 'redis_host':
-                                addr = record[record.type].address;
-                                query.addAnswer(domain, new ARecord(addr), ttl);
-                                break;
+                        var ports = krec[krec.type].ports;
+                        if (ports === undefined || ports.length < 1)
+                                ports = [s.port];
 
-                        case 'service':
-                                var s = record.service.service;
-                                if (!s || typeof (s) !== 'object') {
-                                        req.log.error({
-                                                record: record
-                                        }, 'invalid ZK service record');
-                                        query.setError('servfail');
-                                        break;
-                                }
-                                /*
-                                 * For service-type records, the TTL may also
-                                 * be written on record.service.service.
-                                 */
-                                if (s.ttl !== undefined)
-                                    ttl = s.ttl;
-
-                                if (service !== undefined &&
-                                    (service !== s.srvce ||
-                                    protocol !== s.proto)) {
-                                        /*
-                                         * The user asked for a SRV record for
-                                         * a service/protocol name that didn't
-                                         * match the one registered. We know
-                                         * we own this name, though, so serve
-                                         * them an NXDOMAIN.
-                                         */
-                                        query.setError('nxdomain');
-                                        break;
-                                }
+                        var ar, sr, nm;
+
+                        var rttl = 30;
+                        if (krec.ttl !== undefined)
+                                rttl = krec.ttl;
+                        if (krec[krec.type].ttl !== undefined)
+                                rttl = krec[krec.type].ttl;
+
+                        if (service !== undefined) {
+                                nm = knode.name + '.' + domain;
+                                ports.forEach(function (p) {
+                                        sr = new SRVRecord(nm, p);
+                                        query.addAnswer(query.name(), sr, ttl);
+                                });
+                                ar = new ARecord(a);
+                                query.addAdditional(nm, ar, rttl);
+                        } else {
                                 /*
-                                 * Make sure we set noerror here, otherwise we
-                                 * would respond with NOTIMP to a query about
-                                 * a service with no children.
+                                 * If we're serving plain A records for a
+                                 * service, they represent both the list of
+                                 * who's in the service AND what IP they have.
+                                 * So we need to use the smallest of the two
+                                 * TTLs.
                                  */
-                                query.setError('noerror');
-                                var recs = record.children.filter(
-                                    function (sub) {
-                                        return (sub.type === 'load_balancer' ||
-                                                sub.type === 'moray_host' ||
-                                                sub.type === 'ops_host' ||
-                                                sub.type === 'rr_host' ||
-                                                sub.type === 'redis_host');
-                                });
-                                recs = shuffle(recs);
-                                for (var i = 0; i < recs.length; ++i) {
-                                        var host = recs[i];
-                                        if (!host[host.type]) {
-                                                //500 this request...
-                                                query.setError('eserver');
-                                                req.log.error({
-                                                        query: query,
-                                                        record: record
-                                                }, 'bad zk info');
-                                                break;
-                                        }
-                                        var a = host[host.type].address;
-                                        if (a === null) {
-                                                continue;
-                                        }
-                                        var ports = host[host.type].ports;
-                                        if (ports === undefined ||
-                                            ports.length < 1)
-                                                ports = [s.port];
-                                        var ar, sr, nm;
-                                        var rttl = 30;
-                                        if (host.ttl !== undefined)
-                                            rttl = host.ttl;
-                                        if (host[host.type].ttl !== undefined)
-                                            rttl = host[host.type].ttl;
-                                        if (service !== undefined) {
-                                                nm = host.name + '.' + domain;
-                                                ports.forEach(function (p) {
-                                                        sr = new SRVRecord(
-                                                            nm, p);
-                                                        query.addAnswer(
-                                                            query.name(), sr,
-                                                            ttl);
-                                                });
-                                                ar = new ARecord(a);
-                                                query.addAdditional(nm, ar,
-                                                    rttl);
-                                        } else {
-                                                /*
-                                                 * If we're serving plain A
-                                                 * records for a service, they
-                                                 * represent both the list of
-                                                 * who's in the service AND
-                                                 * what IP they have. So we
-                                                 * need to use the smallest
-                                                 * of the two TTLs.
-                                                 */
-                                                if (ttl < rttl)
-                                                        rttl = ttl;
-                                                ar = new ARecord(a);
-                                                query.addAnswer(domain, ar,
-                                                    rttl);
-                                        }
-                                }
-                                break;
-
-                        default:
-                                req.log.error({
-                                        record: record
-                                }, 'record type in ZK is unknown');
-                                break;
+                                if (ttl < rttl)
+                                        rttl = ttl;
+                                ar = new ARecord(a);
+                                query.addAnswer(domain, ar, rttl);
                         }
                 }
-                req.stamp('pre-resp');
-                query.respond();
-                cb();
-        });
+                break;
+
+        default:
+                log.error({
+                        record: record
+                }, 'record type in ZK is unknown');
+                break;
+        }
+
+        stamp('pre-resp');
+        query.respond();
+        cb();
 }
 
 
@@ -353,6 +338,7 @@ function createServer(options) {
         assert.object(options, 'options');
         assert.object(options.log, 'options.log');
         assert.optionalObject(options.recursion, 'options.recursion');
+        assert.string(options.dnsDomain, 'options.dnsDomain');
 
         var server = mname.createServer({
                 name: options.name || 'binder',
diff --git a/lib/zk.js b/lib/zk.js
index 83aeb31..610144b 100644
--- a/lib/zk.js
+++ b/lib/zk.js
@@ -8,256 +8,252 @@
  * Copyright (c) 2017, Joyent, Inc.
  */
 
-var assert = require('assert');
-var path = require('path');
+var mod_assert = require('assert-plus');
+var mod_path = require('path');
+
+var mod_vasync = require('vasync');
+var mod_verror = require('verror');
+var mod_zkstream = require('zkstream');
+var mod_fsm = require('mooremachine');
+var mod_util = require('util');
+
+function ZKClient(options) {
+        mod_assert.object(options, 'options');
+        mod_assert.object(options.log, 'options.log');
+        this.zc_client = undefined;
+        this.zc_log = options.log.child({
+                component: 'ZKClient'
+        });
+        this.zc_timeout = 30000;
+        this.zc_minDelay = 1000;
+        this.zc_maxDelay = 10000;
+        this.zc_delay = this.zc_minDelay;
+        mod_fsm.FSM.call(this, 'init');
+}
+mod_util.inherits(ZKClient, mod_fsm.FSM);
 
-var vasync = require('vasync');
-var nzk = require('node-zookeeper-client');
+ZKClient.prototype.state_init = function (S) {
+        var self = this;
 
+        this.zc_client = new mod_zkstream.Client({
+                host: process.env.ZK_HOST || '127.0.0.1',
+                port: 2181,
+                log: this.zc_log,
+                timeout: this.zc_timeout
+        });
 
-///--- API
+        S.on(this.zc_client, 'connect', function () {
+                S.gotoState('connected');
+        });
 
-// domainToPath(1.moray.sds.joyent.com) => /com/joyent/sds/moray/1
-function domainToPath(domain) {
-        assert.ok(domain);
-        return ('/' + domain.toLowerCase().split('.').reverse().join('/'));
-}
+        S.on(this.zc_client, 'error', function (err) {
+                self.zc_lastError = err;
+        });
 
+        S.on(this.zc_client, 'close', function (err) {
+                S.gotoState('errorDelay');
+        });
 
-/**
- * Returns the 'typeof' record associated with this DNS name.
- *
- * The returned object is guaranteed to have a 'type' field, and after that
- * it's effectively a UNION depending on what type was.  For details, see the
- * "ZooKeeper data reference" in the Registrar README.
- */
-function getNameRecord(opts, callback) {
-        assert.ok(opts);
-        assert.ok(callback);
+        this.zc_client.connect();
+};
 
-        var cache = opts.cache;
-        var log = opts.log;
-        var p = opts.path;
-        var record, res;
-        var t;
-        var zk = opts.zk;
+ZKClient.prototype.state_connected = function (S) {
+        var self = this;
 
-        if ((res = cache.get(p))) {
-                log.debug({
-                        path: p,
-                        record: res.value
-                }, 'getNameRecord: cache hit');
-                callback(res.err, res.value);
-                return;
-        }
+        S.on(this.zc_client, 'error', function (err) {
+                self.zc_lastError = err;
+        });
 
-        var _done = false;
-        function done(err) {
-                clearTimeout(t);
-                if (_done)
-                        return;
+        S.on(this.zc_client, 'close', function (err) {
+                S.gotoState('errorDelay');
+        });
+};
 
-                _done = true;
+ZKClient.prototype.state_errorDelay = function (S) {
+        this.zc_client = undefined;
+        this.zc_log.warn(this.zc_lastError, 'lost ZK session, ' +
+            'sleeping for %d ms', this.zc_delay);
 
-                log.debug({
-                        path: p,
-                        err: err,
-                        record: record
-                }, 'getNameRecord: zk.get %s', err ? 'failed' : 'done');
-                callback(err, record);
-        }
+        S.timeout(this.zc_delay, function () {
+                S.gotoState('init');
+        });
 
-        log.debug({
-                path: p
-        }, 'getNameRecord: entered (not cached)');
+        this.zc_delay *= 2;
+        if (this.zc_delay > this.zc_maxDelay)
+                this.zc_delay = this.zc_maxDelay;
+};
 
-        t = setTimeout(function () {
-                done(new Error('ZK timeout'));
+ZKClient.prototype.get = function (cb) {
+        var self = this;
+        if (this.isInState('connected') &&
+            this.zc_client.isInState('connected')) {
                 process.nextTick(function () {
-                        // Since the zk client removes all error listeners on
-                        // close, we check our own zk.closeCalled
-                        if (zk.getState() !== 'connected' && !zk.closeCalled) {
-                                var e = new Error('ZooKeeper not connected');
-                                zk.emit('error', e);
-                        }
+                        cb(null, self.zc_client);
                 });
-        }, 1000);
-        zk.getData(p, function (err, data) {
-                if (err) {
-                        log.debug({
-                                path: p,
-                                err: err
-                        }, 'getNameRecord: zk.get failed');
-                        if (typeof (err.getCode) === 'function' &&
-                            err.getCode() === nzk.Exception.NO_NODE)
-                                cache.set(p, {err: err});
-                        done(err);
-                        return;
+                return;
+        }
+        if (!this.isInState('connected')) {
+                function onStateChanged(st) {
+                        if (st === 'connected') {
+                                self.removeListener('stateChanged',
+                                    onStateChanged);
+                                self.get(cb);
+                        }
                 }
-
-                var obj = JSON.parse(data.toString('utf-8'));
-                record = obj;
-                log.debug({
-                        path: p,
-                        record: record
-                }, 'getNameRecord: record found');
-                cache.set(p, {err: null, value: record});
-                done(null);
-        });
-}
-
-
-/**
- * Returns all load-balancers and hosts associated with a "Service".  Note that
- * a service in our world is defined as an M LBs, advertised via DNS RR,
- * fronting N hosts.  The structure in ZK looks like:
- *
- * /com/joyent/foo/<host|lb>
- *
- * Where foo is the 'service' record, as defined in getNameRecord, and there are
- * any number of ephemeral nodes underneath it, where their type is defined in
- * the node itself as a host or load_balancer.
- *
- * For details, see the Registrar README.
- */
-function loadService(opts, callback) {
-        assert.ok(opts);
-        assert.ok(callback);
-
-        var cache = opts.cache;
-        var log = opts.log;
-        var p = opts.path;
-        var svc, res;
-        var zk = opts.zk;
-
-        if ((res = cache.get(p + '__service'))) {
-                log.trace({
-                        path: p,
-                        service: res.value
-                }, 'loadService: cache hit');
-                return (callback(res.err, res.value));
+                this.on('stateChanged', onStateChanged);
+                return;
         }
-
-        zk.getChildren(p, function (err, children) {
-                if (err) {
-                        log.debug({
-                                err: err,
-                                path: p
-                        }, 'loadService: zk.readdir failed');
-                        if (typeof (err.getCode) === 'function' &&
-                            err.getCode() === nzk.Exception.NO_NODE)
-                                cache.set(p + '__service', {err: err});
-                        return (callback(err));
+        function onClStChanged(st) {
+                if (st === 'closed' || st === 'connected') {
+                        self.zc_client.removeListener('stateChanged',
+                            onClStChanged);
+                        self.get(cb);
                 }
+        }
+        this.zc_client.on('stateChanged', onClStChanged);
+};
 
-                var args = {
-                        func: function getServiceSubEntry(c, cb) {
-                                zk.getData(path.normalize(p + '/' + c),
-                                        function (err2, data) {
+function ZKCache(options) {
+        mod_assert.object(options, 'options');
+        mod_assert.object(options.log, 'options.log');
+        mod_assert.string(options.domain, 'options.domain');
 
-                                        if (err2) {
-                                                cb(err2);
-                                                return;
-                                        }
-                                        var obj = JSON.parse(
-                                                data.toString('utf-8'));
-                                        obj.name = c;
-                                        cb(null, obj);
-                                });
-                        },
-                        inputs: children
-                };
-                vasync.forEachParallel(args, function (err2, results) {
-                        if (err2) {
-                                log.debug({
-                                        err: err2,
-                                        children: children,
-                                        path: p
-                                }, 'loadService: zk.get failed');
-                                if (typeof (err2.getCode) === 'function' &&
-                                    err2.getCode() === nzk.Exception.NO_NODE)
-                                        cache.set(p + '__service', {err: err2});
-                                return (callback(err2));
-                        }
-
-                        svc =  results.successes;
-                        cache.set(p + '__service', {err: null, value: svc});
-                        log.debug({
-                                path: p,
-                                service: svc
-                        }, 'loadService: done');
-                        return (callback(null, svc));
-                });
+        this.ca_treeNodes = {};
+        this.ca_zk = new ZKClient(options);
+        this.ca_domain = options.domain;
+        this.ca_log = options.log;
 
-                return (undefined);
+        var self = this;
+        this.ca_zk.on('stateChanged', function (st) {
+                if (st === 'connected') {
+                        self.rebuildCache();
+                }
         });
-
-        return (undefined);
 }
-
-
-function resolveName(options, callback) {
-        assert.ok(options);
-        assert.ok(callback);
-
-        var log = options.log;
-        var opts = {
-                cache: options.cache,
-                log: options.log,
-                path: domainToPath(options.domain || options.query.name()),
-                zk: options.zkClient
-        };
-
-        getNameRecord(opts, function nrCallback(err, record) {
-                if (options.stamp)
-                        options.stamp('zk.getNameRecord');
+ZKCache.prototype.isReady = function () {
+        var tn = this.ca_treeNodes[this.ca_domain];
+        return (tn !== undefined);
+};
+ZKCache.prototype.getClient = function (cb) {
+        this.ca_zk.get(cb);
+};
+ZKCache.prototype.lookup = function (domain) {
+        return (this.ca_treeNodes[domain]);
+};
+ZKCache.prototype.rebuildCache = function () {
+        var tn = this.ca_treeNodes[this.ca_domain];
+        if (tn === undefined) {
+                var parts = this.ca_domain.split('.');
+                tn = new TreeNode(this,
+                    parts.slice(1, parts.length).join('.'), parts[0]);
+        }
+        this.ca_zk.get(function (err, zk) {
                 if (err) {
-                        return (callback(err));
+                        throw (err);
                 }
+                tn.rebind(zk);
+        });
+};
 
-                if (!record) {
-                        var m = 'no error and no record returned from ' +
-                                'getNameRecord';
-                        log.error(err, m);
-                        return (callback(new Error(m)));
-                }
-
-                switch (record.type) {
-                case 'service':
-                        loadService(opts, function svcCallback(err2, svc) {
-                                if (options.stamp)
-                                        options.stamp('zk.loadService');
-                                if (err2)
-                                        return (callback(err2));
-
-                                record.children = svc;
-                                log.trace({
-                                        record: record
-                                }, 'resolveName: svc record -- done');
-                                return (callback(null, record));
-                        });
-
-                        break;
-
+function TreeNode(cache, pDomain, name) {
+        this.tn_name = name.toLowerCase();
+        this.tn_domain = name;
+        if (pDomain.length > 0)
+                this.tn_domain += '.' + pDomain;
+
+        this.tn_cache = cache;
+        this.tn_path = domainToPath(this.tn_domain);
+        this.tn_kids = {};
+        this.tn_data = null;
+        this.tn_log = cache.ca_log.child({
+                component: 'ZKTreeNode',
+                domain: this.tn_domain
+        });
+        this.tn_log.trace('using zk path "%s"', this.tn_path);
 
-                default: // covers host/LB/DB/...
-                        log.trace({
-                                record: record
-                        }, 'resolveName: host record -- done');
-                        return (callback(null, record));
+        this.tn_cache.ca_treeNodes[this.tn_domain] = this;
+}
+Object.defineProperty(TreeNode.prototype, 'name', {
+        get: function () {
+                return (this.tn_name);
+        }
+});
+Object.defineProperty(TreeNode.prototype, 'children', {
+        get: function () {
+                var self = this;
+                return (Object.keys(this.tn_kids).
+                    map(function (k) { return (self.tn_kids[k]); }));
+        }
+});
+Object.defineProperty(TreeNode.prototype, 'data', {
+        get: function () {
+                return (this.tn_data);
+        }
+});
+TreeNode.prototype.onChildrenChanged = function (zk, kids, stat) {
+        var self = this;
+
+        var newKids = {};
+        kids.forEach(function (kid) {
+                if (self.tn_kids[kid] !== undefined) {
+                        newKids[kid] = self.tn_kids[kid];
+                        delete (self.tn_kids[kid]);
+                } else {
+                        newKids[kid] = new TreeNode(self.tn_cache,
+                            self.tn_domain, kid);
+                        newKids[kid].rebind(zk);
                 }
-
-                return (undefined);
         });
-}
+        Object.keys(this.tn_kids).forEach(function (oldKid) {
+                self.tn_kids[oldKid].unbind();
+        });
+        this.tn_kids = newKids;
+};
+TreeNode.prototype.onDataChanged = function (zk, data, stat) {
+        var parsedData;
+        try {
+                var str = data.toString('utf-8');
+                parsedData = JSON.parse(str);
+        } catch (e) {
+                /* Ignore data in a node that we can't parse */
+        }
+        if (typeof (parsedData) !== 'object')
+                return;
+        this.tn_data = parsedData;
+};
+TreeNode.prototype.unbind = function () {
+        var self = this;
+        if (this.tn_watcher) {
+                this.tn_watcher.removeAllListeners('childrenChanged');
+                this.tn_watcher.removeAllListeners('dataChanged');
+        }
+        Object.keys(this.tn_kids).forEach(function (k) {
+                self.tn_kids[k].unbind();
+        });
+};
+TreeNode.prototype.rebind = function (zk) {
+        var self = this;
+        if (this.tn_watcher) {
+                this.tn_watcher.removeAllListeners('childrenChanged');
+                this.tn_watcher.removeAllListeners('dataChanged');
+        }
+        this.tn_watcher = zk.watcher(this.tn_path);
+        this.tn_watcher.on('childrenChanged',
+            this.onChildrenChanged.bind(this, zk));
+        this.tn_watcher.on('dataChanged',
+            this.onDataChanged.bind(this, zk));
+        Object.keys(this.tn_kids).forEach(function (k) {
+                self.tn_kids[k].rebind(zk);
+        });
+};
 
+function domainToPath(domain) {
+        mod_assert.ok(domain);
+        return ('/' + domain.toLowerCase().split('.').reverse().join('/'));
+}
 
 ///--- API
 
 module.exports = {
-
-        getNameRecord: getNameRecord,
-        loadService: loadService,
-        resolveName: resolveName
-
+        ZKCache: ZKCache
 };
diff --git a/main.js b/main.js
index 022b1da..eea1c9e 100644
--- a/main.js
+++ b/main.js
@@ -21,12 +21,9 @@ var mname = require('mname');
 var getopt = require('posix-getopt');
 var vasync = require('vasync');
 var xtend = require('xtend');
-var nzk = require('node-zookeeper-client');
 
 var core = require('./lib');
 
-
-
 ///--- Globals
 
 var ARecord = mname.ARecord;
@@ -41,72 +38,13 @@ var NAME = 'binder';
 var LOG = bunyan.createLogger({
         name: NAME,
         level: (process.env.LOG_LEVEL || 'info'),
-        stream: process.stderr,
         serializers: {
                 err: bunyan.stdSerializers.err
         }
 });
-var ZK;
-
-
 
 ///--- Internal Functions
 
-function createZkClient(cb) {
-        //We want to continue on with init even if ZK isn't available, but we
-        // still want to come up cleanly if we can.
-        var calledback = false;
-        function onFirst() {
-                if (!calledback && cb) {
-                        calledback = true;
-                        return (cb());
-                }
-        }
-
-        function onConnect() {
-                zk.removeListener('error', onError);
-                LOG.debug('ZK client ready');
-
-                // Since there may be multiple outstanding DNS requests
-                // holding a reference to ZK, we can't 'once' the error.
-                zk.on('error', function (err) {
-                        LOG.error(err, 'ZooKeeper client error');
-                        if (!zk.closeCalled) {
-                                zk.close();
-                                zk.closeCalled = true;
-                        }
-                        if (ZK === zk) {
-                                ZK = null;
-                        }
-                });
-                zk.once('disconnected', createZkClient);
-                ZK = zk;
-                onFirst();
-        }
-
-        function onError(err) {
-                LOG.error(err, 'unable to connect to ZK');
-                zk.removeListener('connected', onConnect);
-                zk.close();
-                zk.closeCalled = true;
-                setTimeout(createZkClient, 2000);
-                onFirst();
-        }
-
-        var zk = nzk.createClient(process.env.ZK_HOST || '127.0.0.1', {
-                spinDelay: 1000,
-                sessionTimeout: 30000
-        });
-        // Unfortunately, the zk client does a "removeAllListeners" on close,
-        // so we keep track of when we call close.
-        zk.closeCalled = false;
-        zk.once('error', onError);
-        zk.once('connected', onConnect);
-
-        zk.connect();
-}
-
-
 function parseOptions() {
         var option;
         var opts = {};
@@ -179,38 +117,30 @@ function run(opts) {
         vasync.pipeline({
                 'arg': {},
                 'funcs': [
-                        function initCache(_, subcb) {
-                                _.cache = new LRU({
-                                        max: opts.size,
-                                        maxAge: opts.expiry
+                        function initZk(_, subcb) {
+                                _.zkCache = new core.ZKCache({
+                                        log: LOG,
+                                        domain: opts.dnsDomain
                                 });
                                 subcb();
                         },
-                        function initZk(_, subcb) {
-                                _.zkClient = function () {
-                                        return (ZK);
-                                };
-                                createZkClient(subcb);
-                        },
                         function initRecursion(_, subcb) {
                                 if (!opts.recursion) {
                                         return (subcb());
                                 }
                                 opts.recursion.log = LOG;
-                                opts.recursion.zkClient = _.zkClient;
-                                opts.recursion.cache = _.cache;
+                                opts.recursion.zkCache = _.zkCache;
                                 _.recursion = new core.Recursion(
                                         opts.recursion);
                                 _.recursion.on('ready', subcb);
                         },
                         function initServer(_, subcb) {
                                 _.server = core.createServer({
-                                        cache: _.cache,
                                         name: NAME,
                                         log: LOG,
                                         port: opts.port,
                                         recursion: _.recursion,
-                                        zkClient: _.zkClient,
+                                        zkCache: _.zkCache,
                                         dnsDomain: opts.dnsDomain,
                                         datacenterName: opts.datacenterName
                                 });
diff --git a/package.json b/package.json
index 1ef5479..5b0b46b 100644
--- a/package.json
+++ b/package.json
@@ -1,31 +1,33 @@
 {
-        "name": "binder",
-        "description": "SmartDataService DNS Service",
-        "version": "1.1.0",
-        "author": "Joyent (joyent.com)",
-        "license": "MPL-2.0",
-        "private": true,
-        "dependencies": {
-                "assert-plus": "0.1.5",
-                "bunyan": "1.5.1",
-                "clone": "0.1.1",
-                "lru-cache": "2.7.0",
-                "mname": "1.3.3",
-                "native-dns": "0.7.0",
-                "posix-getopt": "1.0.0",
-                "sdc-clients": "9.0.3",
-                "vasync": "1.6.3",
-                "xtend": "1.0.3",
-                "node-zookeeper-client": "0.2.2"
-        },
-        "engines": {
-                "node": ">=0.8"
-        },
-        "devDependencies": {
-                "expiring-lru-cache": "2.1.0",
-                "nodeunit": "0.9.0"
-        },
-        "scripts": {
-                "start": "node ./main.js"
-        }
+  "name": "binder",
+  "description": "SmartDataService DNS Service",
+  "version": "1.1.0",
+  "author": "Joyent (joyent.com)",
+  "license": "MPL-2.0",
+  "private": true,
+  "dependencies": {
+    "assert-plus": "0.1.5",
+    "bunyan": "1.5.1",
+    "clone": "0.1.1",
+    "lru-cache": "2.7.0",
+    "mname": "1.3.5",
+    "mooremachine": "^2.1.0",
+    "native-dns": "0.7.0",
+    "posix-getopt": "1.0.0",
+    "sdc-clients": "9.0.3",
+    "vasync": "1.6.3",
+    "verror": "^1.10.0",
+    "xtend": "1.0.3",
+    "zkstream": "0.6.3"
+  },
+  "engines": {
+    "node": ">=0.8"
+  },
+  "devDependencies": {
+    "expiring-lru-cache": "2.1.0",
+    "nodeunit": "0.9.0"
+  },
+  "scripts": {
+    "start": "node ./main.js"
+  }
 }
diff --git a/test/database.test.js b/test/database.test.js
index ad118d4..0d8cdba 100644
--- a/test/database.test.js
+++ b/test/database.test.js
@@ -9,7 +9,7 @@
  */
 
 var vasync = require('vasync');
-var nzk = require('node-zookeeper-client');
+var mod_zkstream = require('zkstream');
 
 var core = require('../lib');
 
diff --git a/test/helper.js b/test/helper.js
index a5d11aa..e284076 100644
--- a/test/helper.js
+++ b/test/helper.js
@@ -55,13 +55,21 @@ function createServer(callback) {
                 function connectToZK(_, cb) {
                         var host = process.env.ZK_HOST || 'localhost';
                         var port = process.env.ZK_PORT || 2181;
-                        zk = nzk.createClient(host + ':' + port, {
-                                sessionTimeout: 1000
+                        zk = new mod_zkstream.Client({
+                                host: host,
+                                port: port,
+                                timeout: 10000
                         });
-                        zk.once('connected', cb);
+                        zk.once('connect', cb);
                         zk.connect();
                 },
 
+                function makeZkCache(_, cb) {
+                        var zkCache = new core.ZKCache({
+                                domain: 'foo.com'
+                        })
+                }
+
                 function newServer(_, cb) {
                         server = core.createServer({
                                 cache: createCache(),
