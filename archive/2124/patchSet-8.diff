From 5f1f017df42723bb990c28a8895d0d2df1488295 Mon Sep 17 00:00:00 2001
From: Alex Wilson <alex.wilson@joyent.com>
Date: Fri, 16 Jun 2017 19:01:11 -0700
Subject: [PATCH] MANTA-3318 binder should cache zk data and use watchers to
 update it MANTA-3342 binder should return REFUSED for unknown names

---
 lib/index.js          |   2 -
 lib/recursion.js      |  58 +++---
 lib/server.js         | 410 +++++++++++++++++++++---------------------
 lib/zk.js             | 385 +++++++++++++++------------------------
 main.js               |  83 +--------
 package.json          |  60 ++++---
 test/database.test.js |  18 +-
 test/helper.js        |  84 ++++++---
 test/host.test.js     |  17 +-
 test/service.test.js  |  22 +--
 10 files changed, 500 insertions(+), 639 deletions(-)

diff --git a/lib/index.js b/lib/index.js
index 10b5344..f67446f 100644
--- a/lib/index.js
+++ b/lib/index.js
@@ -12,8 +12,6 @@ var recursion = require('./recursion');
 var server = require('./server');
 var zk = require('./zk');
 
-
-
 ///--- Exports
 
 module.exports = {
diff --git a/lib/recursion.js b/lib/recursion.js
index 48a6e67..7ca33b0 100644
--- a/lib/recursion.js
+++ b/lib/recursion.js
@@ -50,8 +50,7 @@ function Recursion(opts) {
         assert.string(opts.datacenterName, 'opts.datacenterName');
         assert.string(opts.dnsDomain, 'opts.dnsDomain');
         assert.object(opts.ufds, 'opts.ufds');
-        assert.func(opts.zkClient, 'opts.zkClient');
-        assert.object(opts.cache, 'opts.cache');
+        assert.object(opts.zkCache, 'opts.zkCache');
 
         var self = this;
         self.log = opts.log;
@@ -59,8 +58,7 @@ function Recursion(opts) {
         self.datacenterName = opts.datacenterName;
         self.dnsDomain = opts.dnsDomain;
         self.ufdsConfig = opts.ufds;
-        self.zkClient = opts.zkClient;
-        self.cache = opts.cache;
+        self.zkCache = opts.zkCache;
 
         //Init will set these up
         self.interval = null;
@@ -88,40 +86,27 @@ function init() {
 
         //Since we are dns, we need to resolve ufds "manually"
         function resolveUfds(_, subcb) {
-                if (!self.zkClient()) {
+                if (!self.zkCache.isReady()) {
                         return (subcb(new Error('Recursion: ZK is not yet ' +
                                                 'available')));
                 }
                 var domain = self.ufdsConfig.url.replace('ldaps://', '');
-                var query = new function () {
-                        this.name = function () {
-                                return (domain);
-                        };
-                };
-                var req = {
-                        cache: self.cache,
-                        log: self.log,
-                        query: query,
-                        zkClient: self.zkClient()
-                };
-                zk.resolveName(req, function (err, record) {
-                        if (err) {
-                                return (subcb(err));
-                        }
-                        if (!record || !record.children ||
-                            record.children.length < 1) {
-                                return (subcb(new Error(
-                                        'Recursion: not yet able to resolve ' +
-                                                'ufds')));
-                        }
-                        var c = record.children[0];
-                        var addr = c[c.type].address;
-                        _.ufdsConfig = xtend({}, self.ufdsConfig);
-                        _.ufdsConfig.url = 'ldaps://' + addr;
-                        log.debug(_.ufdsConfig,
-                                 'Recursion: resolved ufds config');
-                        return (subcb());
-                });
+
+                var node = self.zkCache.lookup(domain);
+
+                if (!node || !node.data || node.data.type !== 'service' ||
+                    !node.children[0]) {
+                        return (subcb(new Error(
+                            'Recursion: not yet able to resolve ufds')));
+                }
+
+                var kid = node.children[0];
+                var addr = kid.data[kid.data.type].address;
+
+                _.ufdsConfig = xtend({}, self.ufdsConfig);
+                _.ufdsConfig.url = 'ldaps://' + addr;
+                log.debug(_.ufdsConfig, 'Recursion: resolved ufds config');
+                return (subcb());
         }
 
         function initUfds(_, subcb) {
@@ -263,8 +248,7 @@ function lookup(query, hosts, prot, cb) {
                 question: question,
                 server: { address: host, port: port, type: prot },
                 timeout: 3000,
-                try_edns: true,
-                cache: self.cache
+                try_edns: true
         });
 
         var error;
@@ -318,7 +302,7 @@ Recursion.prototype.resolve = function (query, cb) {
         function respond() {
                 if (answers.length === 0) {
                         //See comment in server.js
-                        query.setError('eserver');
+                        query.setError('refused');
                 } else {
                         answers.map(function (a) {
                                 query.addAnswer(domain,
diff --git a/lib/server.js b/lib/server.js
index 249796a..45c846e 100644
--- a/lib/server.js
+++ b/lib/server.js
@@ -13,9 +13,6 @@ var dns = require('dns');
 var url = require('url');
 
 var mname = require('mname');
-var nzk = require('node-zookeeper-client');
-
-var zk = require('./zk');
 
 
 ///--- Globals
@@ -65,7 +62,7 @@ function resolve(options, query, cb) {
             (query.type() === 'ANY' && srvmatch)) {
                 if (!srvmatch || srvmatch[3].length < 1) {
                         query._log.debug('not a valid SRV lookup domain');
-                        query.setError('eserver');
+                        query.setError('refused');
                         query.respond();
                         cb();
                         return;
@@ -81,7 +78,7 @@ function resolve(options, query, cb) {
                         stripped = stripSuffix('.' + options.dnsDomain, domain);
                 } else {
                         query._log.trace('not within dns domain suffix');
-                        query.setError('eserver');
+                        query.setError('refused');
                         query.respond();
                         cb();
                         return;
@@ -90,7 +87,7 @@ function resolve(options, query, cb) {
                 if (isSuffix(options.dnsDomain, stripped) ||
                     isSuffix(dcsuff, stripped)) {
                         query._log.trace('doubled-up dns domain suffix');
-                        query.setError('eserver');
+                        query.setError('refused');
                         query.respond();
                         cb();
                         return;
@@ -105,7 +102,7 @@ function resolve(options, query, cb) {
                 }
         }, true);
 
-        if (!options.zkClient()) {
+        if (!options.zkCache.isReady()) {
                 query._log.error('no ZooKeeper client');
                 query.setError('eserver');
                 query.respond();
@@ -113,18 +110,14 @@ function resolve(options, query, cb) {
                 return;
         }
 
-        var req = {
-                cache: options.cache,
-                log: query._log,
-                query: query,
-                stamp: query._stamp,
-                zkClient: options.zkClient()
-        };
+        var log = query._log;
+        var stamp = query._stamp;
+        var zk = options.zkCache;
 
         if (domain.length < 1) {
-                req.log.debug('request for an empty name: this client is ' +
+                log.debug('request for an empty name: this client is ' +
                     'probably misbehaving');
-                query.setError('eserver');
+                query.setError('refused');
                 query.respond();
                 cb();
                 return;
@@ -132,217 +125,215 @@ function resolve(options, query, cb) {
 
         domain = domain.toLowerCase();
         if (/[^a-z0-9_.-]/.test(domain)) {
-                req.log.debug('request for an invalid name: this client is ' +
+                log.debug('request for an invalid name: this client is ' +
                     'probably misbehaving');
-                query.setError('eserver');
+                query.setError('refused');
                 query.respond();
                 cb();
                 return;
         }
 
-        req.domain = domain;
-        zk.resolveName(req, function (err, record) {
-                if (err && (typeof (err.getCode) !== 'function' ||
-                        err.getCode() !== nzk.Exception.NO_NODE)) {
-
-                        req.log.error(err, 'error talking to ZK');
-                        query.setError('eserver');
-                } else if (err && err.getCode() === nzk.Exception.NO_NODE) {
-                        req.log.trace(err, 'node not found in ZK');
-                        //Recursion will take care of answering the query.
-                        if (options.recursion) {
-                                options.recursion.resolve(query, cb);
-                                return;
-                        }
-                        /*
-                         * You might expect we would return an NXDOMAIN or
-                         * NODATA response here.
-                         *
-                         * Many of our resolvers use binder as a recursive
-                         * nameserver, higher up their priority list than public
-                         * DNS. This means that if we serve them such a response
-                         * here for a name we don't handle, they will
-                         * immediately return an error to their users and not
-                         * try public DNS.
-                         *
-                         * If we return SERVFAIL though, they will try the next
-                         * server, which is the behaviour we want (even though
-                         * as a result we're not RFC compliant).
-                         */
+        var node = zk.lookup(domain);
+
+        if (!node) {
+                log.trace('node not found in ZK cache');
+                /*
+                 * You might expect we would return an NXDOMAIN or
+                 * NODATA response here.
+                 *
+                 * Many of our resolvers use binder as a recursive
+                 * nameserver, higher up their priority list than public
+                 * DNS. This means that if we serve them such a response
+                 * here for a name we don't handle, they will
+                 * immediately return an error to their users and not
+                 * try public DNS.
+                 *
+                 * If we return SERVFAIL or REFUSED though, they will
+                 * try the next server, which is the behaviour we want
+                 * (even though as a result we're not RFC compliant).
+                 */
+                query.setError('refused');
+                stamp('pre-resp');
+                query.respond();
+                cb();
+                return;
+        }
+
+        var record = node.data;
+
+        if (!record || typeof (record.type) !== 'string' ||
+            record[record.type] === null ||
+            typeof (record[record.type]) !== 'object') {
+                log.error({ record: record }, 'invalid ZK record');
+                query.setError('servfail');
+                stamp('pre-resp');
+                query.respond();
+                cb();
+                return;
+        }
+
+        /*
+         * Default the TTL to 30 seconds (the default ZK
+         * session timeout). If the record has an explicit TTL,
+         * it may be written on the root object, or on the
+         * type-specific sub-object (record[record.type]).
+         * This is all an historical mess, but we take the TTL
+         * from the deepest object.
+         */
+        var ttl = 30;
+        if (record.ttl !== undefined)
+                ttl = record.ttl;
+        if (record[record.type].ttl !== undefined)
+                ttl = record[record.type].ttl;
+
+        if (service !== undefined && record.type !== 'service') {
+                /*
+                 * The user asked for an SRV record on something
+                 * that isn't a valid service (e.g. it's a
+                 * specific instance of it). We know we own this
+                 * name, so we can safely return a NODATA
+                 * response.
+                 */
+                query.setError('noerror');
+                stamp('build_response');
+                query.respond();
+                cb();
+                return;
+        }
+
+        var addr;
+        switch (record.type) {
+        case 'database':
+                var _u = url.parse(record.database.primary);
+                addr = _u.hostname;
+                query.addAnswer(domain, new ARecord(addr), ttl);
+                break;
+
+        case 'db_host':
+        case 'host':
+        case 'load_balancer':
+        case 'moray_host':
+        case 'redis_host':
+                addr = record[record.type].address;
+                query.addAnswer(domain, new ARecord(addr), ttl);
+                break;
+
+        case 'service':
+                var s = record.service;
+
+                if (!s || typeof (s) !== 'object') {
+                        log.error({
+                                record: record
+                        }, 'invalid ZK service record');
                         query.setError('servfail');
-                } else {
-                        if (typeof (record.type) !== 'string' ||
-                            record[record.type] === undefined ||
-                            record[record.type] === null ||
-                            typeof (record[record.type]) !== 'object') {
-                                req.log.error({
-                                        record: record
-                                }, 'invalid ZK service record');
-                                query.setError('servfail');
-                                req.stamp('pre-resp');
-                                query.respond();
-                                cb();
-                                return;
-                        }
+                        break;
+                }
 
-                        var addr;
+                if (typeof (s.service) === 'object')
+                        s = s.service;
 
+                /*
+                 * For service-type records, the TTL may also
+                 * be written on record.service.service.
+                 */
+                if (s.ttl !== undefined)
+                        ttl = s.ttl;
+
+                if (service !== undefined &&
+                    (service !== s.srvce || protocol !== s.proto)) {
                         /*
-                         * Default the TTL to 30 seconds (the default ZK
-                         * session timeout). If the record has an explicit TTL,
-                         * it may be written on the root object, or on the
-                         * type-specific sub-object (record[record.type]).
-                         * This is all an historical mess, but we take the TTL
-                         * from the deepest object.
+                         * The user asked for a SRV record for
+                         * a service/protocol name that didn't
+                         * match the one registered. We know
+                         * we own this name, though, so serve
+                         * them an NXDOMAIN.
                          */
-                        var ttl = 30;
-                        if (record.ttl !== undefined)
-                            ttl = record.ttl;
-                        if (record[record.type].ttl !== undefined)
-                            ttl = record[record.type].ttl;
-
-                        if (service !== undefined &&
-                            record.type !== 'service') {
-                                /*
-                                 * The user asked for an SRV record on something
-                                 * that isn't a valid service (e.g. it's a
-                                 * specific instance of it). We know we own this
-                                 * name, so we can safely return a NODATA
-                                 * response.
-                                 */
-                                query.setError('noerror');
-                                req.stamp('build_response');
-                                query.respond();
-                                cb();
-                                return;
-                        }
-                        switch (record.type) {
-                        case 'database':
-                                var _u = url.parse(record.database.primary);
-                                addr = _u.hostname;
-                                query.addAnswer(domain, new ARecord(addr), ttl);
+                        query.setError('nxdomain');
+                        break;
+                }
+                /*
+                 * Make sure we set noerror here, otherwise we
+                 * would respond with NOTIMP to a query about
+                 * a service with no children.
+                 */
+                query.setError('noerror');
+                var kids = node.children.filter(
+                    function (sub) {
+                        return (sub.data && (
+                            sub.data.type === 'load_balancer' ||
+                            sub.data.type === 'moray_host' ||
+                            sub.data.type === 'ops_host' ||
+                            sub.data.type === 'rr_host' ||
+                            sub.data.type === 'redis_host'));
+                });
+                kids = shuffle(kids);
+                for (var i = 0; i < kids.length; ++i) {
+                        var knode = kids[i];
+                        var krec = knode.data;
+
+                        if (!krec || typeof (krec.type) !== 'string' ||
+                            krec[krec.type] === null ||
+                            typeof (krec[krec.type]) !== 'object') {
+                                //500 this request...
+                                query.setError('eserver');
+                                log.error({
+                                        query: query,
+                                        record: record
+                                }, 'bad zk info');
                                 break;
+                        }
 
-                        case 'db_host':
-                        case 'host':
-                        case 'load_balancer':
-                        case 'moray_host':
-                        case 'redis_host':
-                                addr = record[record.type].address;
-                                query.addAnswer(domain, new ARecord(addr), ttl);
-                                break;
+                        var a = krec[krec.type].address;
+                        if (a === null) {
+                                continue;
+                        }
 
-                        case 'service':
-                                var s = record.service.service;
-                                if (!s || typeof (s) !== 'object') {
-                                        req.log.error({
-                                                record: record
-                                        }, 'invalid ZK service record');
-                                        query.setError('servfail');
-                                        break;
-                                }
-                                /*
-                                 * For service-type records, the TTL may also
-                                 * be written on record.service.service.
-                                 */
-                                if (s.ttl !== undefined)
-                                    ttl = s.ttl;
-
-                                if (service !== undefined &&
-                                    (service !== s.srvce ||
-                                    protocol !== s.proto)) {
-                                        /*
-                                         * The user asked for a SRV record for
-                                         * a service/protocol name that didn't
-                                         * match the one registered. We know
-                                         * we own this name, though, so serve
-                                         * them an NXDOMAIN.
-                                         */
-                                        query.setError('nxdomain');
-                                        break;
-                                }
+                        var ports = krec[krec.type].ports;
+                        if (ports === undefined || ports.length < 1)
+                                ports = [s.port];
+
+                        var ar, sr, nm;
+
+                        var rttl = ttl;
+                        if (krec.ttl !== undefined)
+                                rttl = krec.ttl;
+                        if (krec[krec.type].ttl !== undefined)
+                                rttl = krec[krec.type].ttl;
+
+                        if (service !== undefined) {
+                                nm = knode.name + '.' + domain;
+                                ports.forEach(function (p) {
+                                        sr = new SRVRecord(nm, p);
+                                        query.addAnswer(query.name(), sr, ttl);
+                                });
+                                ar = new ARecord(a);
+                                query.addAdditional(nm, ar, rttl);
+                        } else {
                                 /*
-                                 * Make sure we set noerror here, otherwise we
-                                 * would respond with NOTIMP to a query about
-                                 * a service with no children.
+                                 * If we're serving plain A records for a
+                                 * service, they represent both the list of
+                                 * who's in the service AND what IP they have.
+                                 * So we need to use the smallest of the two
+                                 * TTLs.
                                  */
-                                query.setError('noerror');
-                                var recs = record.children.filter(
-                                    function (sub) {
-                                        return (sub.type === 'load_balancer' ||
-                                                sub.type === 'moray_host' ||
-                                                sub.type === 'ops_host' ||
-                                                sub.type === 'rr_host' ||
-                                                sub.type === 'redis_host');
-                                });
-                                recs = shuffle(recs);
-                                for (var i = 0; i < recs.length; ++i) {
-                                        var host = recs[i];
-                                        if (!host[host.type]) {
-                                                //500 this request...
-                                                query.setError('eserver');
-                                                req.log.error({
-                                                        query: query,
-                                                        record: record
-                                                }, 'bad zk info');
-                                                break;
-                                        }
-                                        var a = host[host.type].address;
-                                        if (a === null) {
-                                                continue;
-                                        }
-                                        var ports = host[host.type].ports;
-                                        if (ports === undefined ||
-                                            ports.length < 1)
-                                                ports = [s.port];
-                                        var ar, sr, nm;
-                                        var rttl = 30;
-                                        if (host.ttl !== undefined)
-                                            rttl = host.ttl;
-                                        if (host[host.type].ttl !== undefined)
-                                            rttl = host[host.type].ttl;
-                                        if (service !== undefined) {
-                                                nm = host.name + '.' + domain;
-                                                ports.forEach(function (p) {
-                                                        sr = new SRVRecord(
-                                                            nm, p);
-                                                        query.addAnswer(
-                                                            query.name(), sr,
-                                                            ttl);
-                                                });
-                                                ar = new ARecord(a);
-                                                query.addAdditional(nm, ar,
-                                                    rttl);
-                                        } else {
-                                                /*
-                                                 * If we're serving plain A
-                                                 * records for a service, they
-                                                 * represent both the list of
-                                                 * who's in the service AND
-                                                 * what IP they have. So we
-                                                 * need to use the smallest
-                                                 * of the two TTLs.
-                                                 */
-                                                if (ttl < rttl)
-                                                        rttl = ttl;
-                                                ar = new ARecord(a);
-                                                query.addAnswer(domain, ar,
-                                                    rttl);
-                                        }
-                                }
-                                break;
-
-                        default:
-                                req.log.error({
-                                        record: record
-                                }, 'record type in ZK is unknown');
-                                break;
+                                if (ttl < rttl)
+                                        rttl = ttl;
+                                ar = new ARecord(a);
+                                query.addAnswer(domain, ar, rttl);
                         }
                 }
-                req.stamp('pre-resp');
-                query.respond();
-                cb();
-        });
+                break;
+
+        default:
+                log.error({
+                        record: record
+                }, 'record type in ZK is unknown');
+                break;
+        }
+
+        stamp('pre-resp');
+        query.respond();
+        cb();
 }
 
 
@@ -353,6 +344,7 @@ function createServer(options) {
         assert.object(options, 'options');
         assert.object(options.log, 'options.log');
         assert.optionalObject(options.recursion, 'options.recursion');
+        assert.string(options.dnsDomain, 'options.dnsDomain');
 
         var server = mname.createServer({
                 name: options.name || 'binder',
diff --git a/lib/zk.js b/lib/zk.js
index 83aeb31..c88a0ea 100644
--- a/lib/zk.js
+++ b/lib/zk.js
@@ -8,256 +8,169 @@
  * Copyright (c) 2017, Joyent, Inc.
  */
 
-var assert = require('assert');
-var path = require('path');
-
-var vasync = require('vasync');
-var nzk = require('node-zookeeper-client');
-
-
-///--- API
+var mod_assert = require('assert-plus');
+var mod_path = require('path');
+
+var mod_vasync = require('vasync');
+var mod_verror = require('verror');
+var mod_zkstream = require('zkstream');
+var mod_util = require('util');
+
+function ZKCache(options) {
+        mod_assert.object(options, 'options');
+        mod_assert.object(options.log, 'options.log');
+        mod_assert.string(options.domain, 'options.domain');
+
+        this.ca_treeNodes = {};
+        this.ca_zk = new mod_zkstream.Client({
+                address: process.env.ZK_HOST || '127.0.0.1',
+                port: 2181,
+                log: options.log,
+                timeout: 30000
+        });
+        this.ca_domain = options.domain;
+        this.ca_log = options.log;
 
-// domainToPath(1.moray.sds.joyent.com) => /com/joyent/sds/moray/1
-function domainToPath(domain) {
-        assert.ok(domain);
-        return ('/' + domain.toLowerCase().split('.').reverse().join('/'));
+        var self = this;
+        this.ca_zk.on('session', function () {
+                self.rebuildCache();
+        });
 }
-
-
-/**
- * Returns the 'typeof' record associated with this DNS name.
- *
- * The returned object is guaranteed to have a 'type' field, and after that
- * it's effectively a UNION depending on what type was.  For details, see the
- * "ZooKeeper data reference" in the Registrar README.
- */
-function getNameRecord(opts, callback) {
-        assert.ok(opts);
-        assert.ok(callback);
-
-        var cache = opts.cache;
-        var log = opts.log;
-        var p = opts.path;
-        var record, res;
-        var t;
-        var zk = opts.zk;
-
-        if ((res = cache.get(p))) {
-                log.debug({
-                        path: p,
-                        record: res.value
-                }, 'getNameRecord: cache hit');
-                callback(res.err, res.value);
-                return;
+ZKCache.prototype.stop = function (cb) {
+        if (cb) {
+                this.ca_zk.on('close', cb);
         }
-
-        var _done = false;
-        function done(err) {
-                clearTimeout(t);
-                if (_done)
-                        return;
-
-                _done = true;
-
-                log.debug({
-                        path: p,
-                        err: err,
-                        record: record
-                }, 'getNameRecord: zk.get %s', err ? 'failed' : 'done');
-                callback(err, record);
+        this.ca_zk.close();
+};
+ZKCache.prototype.isReady = function () {
+        var tn = this.ca_treeNodes[this.ca_domain];
+        return (tn !== undefined);
+};
+ZKCache.prototype.getClient = function (cb) {
+        this.ca_zk.get(cb);
+};
+ZKCache.prototype.lookup = function (domain) {
+        return (this.ca_treeNodes[domain]);
+};
+ZKCache.prototype.rebuildCache = function () {
+        var tn = this.ca_treeNodes[this.ca_domain];
+        if (tn === undefined) {
+                var parts = this.ca_domain.split('.');
+                tn = new TreeNode(this,
+                    parts.slice(1, parts.length).join('.'), parts[0]);
         }
+        tn.rebind(this.ca_zk);
+};
 
-        log.debug({
-                path: p
-        }, 'getNameRecord: entered (not cached)');
-
-        t = setTimeout(function () {
-                done(new Error('ZK timeout'));
-                process.nextTick(function () {
-                        // Since the zk client removes all error listeners on
-                        // close, we check our own zk.closeCalled
-                        if (zk.getState() !== 'connected' && !zk.closeCalled) {
-                                var e = new Error('ZooKeeper not connected');
-                                zk.emit('error', e);
-                        }
-                });
-        }, 1000);
-        zk.getData(p, function (err, data) {
-                if (err) {
-                        log.debug({
-                                path: p,
-                                err: err
-                        }, 'getNameRecord: zk.get failed');
-                        if (typeof (err.getCode) === 'function' &&
-                            err.getCode() === nzk.Exception.NO_NODE)
-                                cache.set(p, {err: err});
-                        done(err);
-                        return;
-                }
-
-                var obj = JSON.parse(data.toString('utf-8'));
-                record = obj;
-                log.debug({
-                        path: p,
-                        record: record
-                }, 'getNameRecord: record found');
-                cache.set(p, {err: null, value: record});
-                done(null);
+function TreeNode(cache, pDomain, name) {
+        this.tn_name = name;
+        this.tn_domain = name;
+        if (pDomain.length > 0)
+                this.tn_domain += '.' + pDomain;
+        this.tn_path = domainToPath(this.tn_domain);
+        this.tn_domain = this.tn_domain.toLowerCase();
+
+        this.tn_cache = cache;
+        this.tn_kids = {};
+        this.tn_data = null;
+        this.tn_log = cache.ca_log.child({
+                component: 'ZKTreeNode',
+                domain: this.tn_domain
         });
-}
-
+        this.tn_log.trace('adding node to cache at "%s"', this.tn_path);
 
-/**
- * Returns all load-balancers and hosts associated with a "Service".  Note that
- * a service in our world is defined as an M LBs, advertised via DNS RR,
- * fronting N hosts.  The structure in ZK looks like:
- *
- * /com/joyent/foo/<host|lb>
- *
- * Where foo is the 'service' record, as defined in getNameRecord, and there are
- * any number of ephemeral nodes underneath it, where their type is defined in
- * the node itself as a host or load_balancer.
- *
- * For details, see the Registrar README.
- */
-function loadService(opts, callback) {
-        assert.ok(opts);
-        assert.ok(callback);
-
-        var cache = opts.cache;
-        var log = opts.log;
-        var p = opts.path;
-        var svc, res;
-        var zk = opts.zk;
-
-        if ((res = cache.get(p + '__service'))) {
-                log.trace({
-                        path: p,
-                        service: res.value
-                }, 'loadService: cache hit');
-                return (callback(res.err, res.value));
+        this.tn_cache.ca_treeNodes[this.tn_domain] = this;
+}
+Object.defineProperty(TreeNode.prototype, 'name', {
+        get: function () {
+                return (this.tn_name);
         }
-
-        zk.getChildren(p, function (err, children) {
-                if (err) {
-                        log.debug({
-                                err: err,
-                                path: p
-                        }, 'loadService: zk.readdir failed');
-                        if (typeof (err.getCode) === 'function' &&
-                            err.getCode() === nzk.Exception.NO_NODE)
-                                cache.set(p + '__service', {err: err});
-                        return (callback(err));
+});
+Object.defineProperty(TreeNode.prototype, 'children', {
+        get: function () {
+                var self = this;
+                return (Object.keys(this.tn_kids).
+                    map(function (k) { return (self.tn_kids[k]); }));
+        }
+});
+Object.defineProperty(TreeNode.prototype, 'data', {
+        get: function () {
+                return (this.tn_data);
+        }
+});
+TreeNode.prototype.onChildrenChanged = function (zk, kids, stat) {
+        var self = this;
+
+        var newKids = {};
+        kids.forEach(function (kid) {
+                if (self.tn_kids[kid] !== undefined) {
+                        newKids[kid] = self.tn_kids[kid];
+                        delete (self.tn_kids[kid]);
+                } else {
+                        newKids[kid] = new TreeNode(self.tn_cache,
+                            self.tn_domain, kid);
+                        newKids[kid].rebind(zk);
                 }
-
-                var args = {
-                        func: function getServiceSubEntry(c, cb) {
-                                zk.getData(path.normalize(p + '/' + c),
-                                        function (err2, data) {
-
-                                        if (err2) {
-                                                cb(err2);
-                                                return;
-                                        }
-                                        var obj = JSON.parse(
-                                                data.toString('utf-8'));
-                                        obj.name = c;
-                                        cb(null, obj);
-                                });
-                        },
-                        inputs: children
-                };
-                vasync.forEachParallel(args, function (err2, results) {
-                        if (err2) {
-                                log.debug({
-                                        err: err2,
-                                        children: children,
-                                        path: p
-                                }, 'loadService: zk.get failed');
-                                if (typeof (err2.getCode) === 'function' &&
-                                    err2.getCode() === nzk.Exception.NO_NODE)
-                                        cache.set(p + '__service', {err: err2});
-                                return (callback(err2));
-                        }
-
-                        svc =  results.successes;
-                        cache.set(p + '__service', {err: null, value: svc});
-                        log.debug({
-                                path: p,
-                                service: svc
-                        }, 'loadService: done');
-                        return (callback(null, svc));
-                });
-
-                return (undefined);
         });
-
-        return (undefined);
-}
-
-
-function resolveName(options, callback) {
-        assert.ok(options);
-        assert.ok(callback);
-
-        var log = options.log;
-        var opts = {
-                cache: options.cache,
-                log: options.log,
-                path: domainToPath(options.domain || options.query.name()),
-                zk: options.zkClient
-        };
-
-        getNameRecord(opts, function nrCallback(err, record) {
-                if (options.stamp)
-                        options.stamp('zk.getNameRecord');
-                if (err) {
-                        return (callback(err));
-                }
-
-                if (!record) {
-                        var m = 'no error and no record returned from ' +
-                                'getNameRecord';
-                        log.error(err, m);
-                        return (callback(new Error(m)));
-                }
-
-                switch (record.type) {
-                case 'service':
-                        loadService(opts, function svcCallback(err2, svc) {
-                                if (options.stamp)
-                                        options.stamp('zk.loadService');
-                                if (err2)
-                                        return (callback(err2));
-
-                                record.children = svc;
-                                log.trace({
-                                        record: record
-                                }, 'resolveName: svc record -- done');
-                                return (callback(null, record));
-                        });
-
-                        break;
-
-
-                default: // covers host/LB/DB/...
-                        log.trace({
-                                record: record
-                        }, 'resolveName: host record -- done');
-                        return (callback(null, record));
-                }
-
-                return (undefined);
+        Object.keys(this.tn_kids).forEach(function (oldKid) {
+                self.tn_kids[oldKid].unbind();
         });
-}
+        this.tn_kids = newKids;
+};
+TreeNode.prototype.onDataChanged = function (zk, data, stat) {
+        var parsedData;
+        try {
+                var str = data.toString('utf-8');
+                parsedData = JSON.parse(str);
+        } catch (e) {
+                /* Ignore data in a node that we can't parse */
+                this.tn_log.warn(e, 'ignoring node %s: failed to parse data',
+                    this.tn_path);
+        }
+        if (typeof (parsedData) !== 'object') {
+                var er = new Error('Parsed JSON data is not an object');
+                this.tn_log.warn(er, 'ignoring node %s: failed to parse data',
+                    this.tn_path);
+                return;
+        }
+        this.tn_data = parsedData;
+};
+TreeNode.prototype.unbind = function () {
+        var self = this;
+        if (this.tn_watcher) {
+                this.tn_watcher.removeAllListeners('childrenChanged');
+                this.tn_watcher.removeAllListeners('dataChanged');
+        }
+        Object.keys(this.tn_kids).forEach(function (k) {
+                self.tn_kids[k].unbind();
+        });
+        if (this.tn_cache.ca_treeNodes[this.tn_domain] === this) {
+                delete (this.tn_cache.ca_treeNodes[this.tn_domain]);
+        }
+};
+TreeNode.prototype.rebind = function (zk) {
+        var self = this;
+        if (this.tn_watcher) {
+                this.tn_watcher.removeAllListeners('childrenChanged');
+                this.tn_watcher.removeAllListeners('dataChanged');
+        }
+        this.tn_watcher = zk.watcher(this.tn_path);
+        this.tn_watcher.on('childrenChanged',
+            this.onChildrenChanged.bind(this, zk));
+        this.tn_watcher.on('dataChanged',
+            this.onDataChanged.bind(this, zk));
+        Object.keys(this.tn_kids).forEach(function (k) {
+                self.tn_kids[k].rebind(zk);
+        });
+};
 
+function domainToPath(domain) {
+        mod_assert.ok(domain);
+        return ('/' + domain.split('.').reverse().join('/'));
+}
 
 ///--- API
 
 module.exports = {
-
-        getNameRecord: getNameRecord,
-        loadService: loadService,
-        resolveName: resolveName
-
+        ZKCache: ZKCache
 };
diff --git a/main.js b/main.js
index 022b1da..10d1c36 100644
--- a/main.js
+++ b/main.js
@@ -21,12 +21,9 @@ var mname = require('mname');
 var getopt = require('posix-getopt');
 var vasync = require('vasync');
 var xtend = require('xtend');
-var nzk = require('node-zookeeper-client');
 
 var core = require('./lib');
 
-
-
 ///--- Globals
 
 var ARecord = mname.ARecord;
@@ -41,72 +38,14 @@ var NAME = 'binder';
 var LOG = bunyan.createLogger({
         name: NAME,
         level: (process.env.LOG_LEVEL || 'info'),
-        stream: process.stderr,
+        stream: process.stdout,
         serializers: {
                 err: bunyan.stdSerializers.err
         }
 });
-var ZK;
-
-
 
 ///--- Internal Functions
 
-function createZkClient(cb) {
-        //We want to continue on with init even if ZK isn't available, but we
-        // still want to come up cleanly if we can.
-        var calledback = false;
-        function onFirst() {
-                if (!calledback && cb) {
-                        calledback = true;
-                        return (cb());
-                }
-        }
-
-        function onConnect() {
-                zk.removeListener('error', onError);
-                LOG.debug('ZK client ready');
-
-                // Since there may be multiple outstanding DNS requests
-                // holding a reference to ZK, we can't 'once' the error.
-                zk.on('error', function (err) {
-                        LOG.error(err, 'ZooKeeper client error');
-                        if (!zk.closeCalled) {
-                                zk.close();
-                                zk.closeCalled = true;
-                        }
-                        if (ZK === zk) {
-                                ZK = null;
-                        }
-                });
-                zk.once('disconnected', createZkClient);
-                ZK = zk;
-                onFirst();
-        }
-
-        function onError(err) {
-                LOG.error(err, 'unable to connect to ZK');
-                zk.removeListener('connected', onConnect);
-                zk.close();
-                zk.closeCalled = true;
-                setTimeout(createZkClient, 2000);
-                onFirst();
-        }
-
-        var zk = nzk.createClient(process.env.ZK_HOST || '127.0.0.1', {
-                spinDelay: 1000,
-                sessionTimeout: 30000
-        });
-        // Unfortunately, the zk client does a "removeAllListeners" on close,
-        // so we keep track of when we call close.
-        zk.closeCalled = false;
-        zk.once('error', onError);
-        zk.once('connected', onConnect);
-
-        zk.connect();
-}
-
-
 function parseOptions() {
         var option;
         var opts = {};
@@ -179,38 +118,30 @@ function run(opts) {
         vasync.pipeline({
                 'arg': {},
                 'funcs': [
-                        function initCache(_, subcb) {
-                                _.cache = new LRU({
-                                        max: opts.size,
-                                        maxAge: opts.expiry
+                        function initZk(_, subcb) {
+                                _.zkCache = new core.ZKCache({
+                                        log: LOG,
+                                        domain: opts.dnsDomain
                                 });
                                 subcb();
                         },
-                        function initZk(_, subcb) {
-                                _.zkClient = function () {
-                                        return (ZK);
-                                };
-                                createZkClient(subcb);
-                        },
                         function initRecursion(_, subcb) {
                                 if (!opts.recursion) {
                                         return (subcb());
                                 }
                                 opts.recursion.log = LOG;
-                                opts.recursion.zkClient = _.zkClient;
-                                opts.recursion.cache = _.cache;
+                                opts.recursion.zkCache = _.zkCache;
                                 _.recursion = new core.Recursion(
                                         opts.recursion);
                                 _.recursion.on('ready', subcb);
                         },
                         function initServer(_, subcb) {
                                 _.server = core.createServer({
-                                        cache: _.cache,
                                         name: NAME,
                                         log: LOG,
                                         port: opts.port,
                                         recursion: _.recursion,
-                                        zkClient: _.zkClient,
+                                        zkCache: _.zkCache,
                                         dnsDomain: opts.dnsDomain,
                                         datacenterName: opts.datacenterName
                                 });
diff --git a/package.json b/package.json
index 1ef5479..b689def 100644
--- a/package.json
+++ b/package.json
@@ -1,31 +1,33 @@
 {
-        "name": "binder",
-        "description": "SmartDataService DNS Service",
-        "version": "1.1.0",
-        "author": "Joyent (joyent.com)",
-        "license": "MPL-2.0",
-        "private": true,
-        "dependencies": {
-                "assert-plus": "0.1.5",
-                "bunyan": "1.5.1",
-                "clone": "0.1.1",
-                "lru-cache": "2.7.0",
-                "mname": "1.3.3",
-                "native-dns": "0.7.0",
-                "posix-getopt": "1.0.0",
-                "sdc-clients": "9.0.3",
-                "vasync": "1.6.3",
-                "xtend": "1.0.3",
-                "node-zookeeper-client": "0.2.2"
-        },
-        "engines": {
-                "node": ">=0.8"
-        },
-        "devDependencies": {
-                "expiring-lru-cache": "2.1.0",
-                "nodeunit": "0.9.0"
-        },
-        "scripts": {
-                "start": "node ./main.js"
-        }
+  "name": "binder",
+  "description": "SmartDataService DNS Service",
+  "version": "1.1.0",
+  "author": "Joyent (joyent.com)",
+  "license": "MPL-2.0",
+  "private": true,
+  "dependencies": {
+    "assert-plus": "0.1.5",
+    "bunyan": "1.5.1",
+    "clone": "0.1.1",
+    "lru-cache": "2.7.0",
+    "mname": "1.3.5",
+    "mooremachine": "^2.1.0",
+    "native-dns": "0.7.0",
+    "posix-getopt": "1.0.0",
+    "sdc-clients": "9.0.3",
+    "vasync": "1.6.3",
+    "verror": "^1.10.0",
+    "xtend": "1.0.3",
+    "zkstream": "0.9.0"
+  },
+  "engines": {
+    "node": ">=0.8"
+  },
+  "devDependencies": {
+    "expiring-lru-cache": "2.1.0",
+    "nodeunit": "0.9.0"
+  },
+  "scripts": {
+    "start": "node ./main.js"
+  }
 }
diff --git a/test/database.test.js b/test/database.test.js
index ad118d4..9f7542a 100644
--- a/test/database.test.js
+++ b/test/database.test.js
@@ -9,7 +9,7 @@
  */
 
 var vasync = require('vasync');
-var nzk = require('node-zookeeper-client');
+var mod_zkstream = require('zkstream');
 
 var core = require('../lib');
 
@@ -52,22 +52,21 @@ before(function (callback) {
                                 } else {
                                         self.server = res.server;
                                         self.zk = res.zk;
+                                        self.zkCache = res.zkCache;
                                         cb();
                                 }
                         });
                 },
 
                 function mkdir(_, cb) {
-                        self.zk.mkdirp(PATH, cb);
+                        helper.zkMkdirP.call(self.zk, PATH, cb);
                 },
 
                 function setRecord(_, cb) {
                         var data = new Buffer(JSON.stringify(RECORD));
-                        self.zk.create(PATH, data, function (err) {
-                                if (err && err.getCode() ===
-                                        nzk.Exception.NODE_EXISTS) {
-
-                                        self.zk.setData(PATH, data, cb);
+                        self.zk.create(PATH, data, {}, function (err) {
+                                if (err && err.code === 'NODE_EXISTS') {
+                                        self.zk.set(PATH, data, -1, cb);
                                 } else {
                                         cb();
                                 }
@@ -89,9 +88,10 @@ before(function (callback) {
 after(function (callback) {
         var self = this;
         helper.zkRmr.call(this.zk, '/com', function (err) {
-                self.zk.on('disconnected', function () {
+                self.zk.on('close', function () {
                         self.server.stop(callback);
                 });
+                self.zkCache.stop();
                 self.zk.close();
         });
 });
@@ -105,7 +105,7 @@ test('resolve record ok', function (t) {
                 t.equal(results.answers.length, 1);
                 t.deepEqual(results.answers[0], {
                         name: DOMAIN,
-                        ttl: 5,
+                        ttl: 30,
                         type: 'A',
                         target: '192.168.0.1'
                 });
diff --git a/test/helper.js b/test/helper.js
index a5d11aa..4f7bd09 100644
--- a/test/helper.js
+++ b/test/helper.js
@@ -17,12 +17,11 @@ var mname = require('mname');
 var vasync = require('vasync');
 var nzk = require('node-zookeeper-client');
 var path = require('path');
+var mod_zkstream = require('zkstream');
 
 var core = require('../lib');
 var dig = require('./dig');
 
-
-
 ///--- Helpers
 
 function createCache(name) {
@@ -36,7 +35,7 @@ function createCache(name) {
 
 function createLogger(name, stream) {
         var log = bunyan.createLogger({
-                level: (process.env.LOG_LEVEL || 'warn'),
+                level: (process.env.LOG_LEVEL || 'info'),
                 name: name || process.argv[1],
                 stream: stream || process.stdout,
                 src: true,
@@ -48,48 +47,90 @@ function createLogger(name, stream) {
 
 function createServer(callback) {
         var log = createLogger();
-        var zk;
-        var server;
+        var arg = {};
 
         var funcs = [
                 function connectToZK(_, cb) {
-                        var host = process.env.ZK_HOST || 'localhost';
+                        var host = process.env.ZK_HOST || '127.0.0.1';
                         var port = process.env.ZK_PORT || 2181;
-                        zk = nzk.createClient(host + ':' + port, {
-                                sessionTimeout: 1000
+                        _.zk = new mod_zkstream.Client({
+                                address: host,
+                                port: port,
+                                timeout: 10000
+                        });
+                        _.zk.once('connect', cb);
+                },
+
+                function makeZkCache(_, cb) {
+                        _.zkCache = new core.ZKCache({
+                                domain: 'foo.com',
+                                log: log
                         });
-                        zk.once('connected', cb);
-                        zk.connect();
+                        cb();
                 },
 
                 function newServer(_, cb) {
-                        server = core.createServer({
-                                cache: createCache(),
+                        _.server = core.createServer({
                                 host: '::1',
                                 log: log,
                                 name: process.argv[1],
                                 port: 1053,
-                                zkClient: function () {
-                                        return (zk);
-                                }
+                                dnsDomain: 'foo.com',
+                                zkCache: _.zkCache
                         });
-                        server.start(cb);
+                        _.server.start(cb);
                 }
 
         ];
 
-        vasync.pipeline({funcs: funcs}, function (err) {
+        vasync.pipeline({
+                funcs: funcs,
+                arg: arg
+        }, function (err) {
                 if (err) {
                         callback(err);
                 } else {
-                        callback(null, {server: server, zk: zk});
+                        callback(null, arg);
                 }
         });
 }
 
+function zkMkdirP(dpath, cb) {
+        var zk = this;
+        var sofar = '';
+        var parts = [];
+        dpath.split('/').forEach(function (part) {
+                if (part !== '') {
+                        sofar += '/' + part;
+                        parts.push(sofar);
+                }
+        });
+        var b = new Buffer('null', 'utf-8');
+        vasync.forEachPipeline({
+                func: function (dir, ccb) {
+                        if (dir === '/') {
+                                ccb();
+                                return;
+                        }
+                        zk.create(dir, b, {}, function (err) {
+                                if (err && err.code === 'NODE_EXISTS') {
+                                        ccb();
+                                        return;
+                                }
+                                if (err) {
+                                        ccb(err);
+                                        return;
+                                }
+                                ccb();
+                        });
+                },
+                inputs: parts
+        }, cb);
+}
+
 function zkRmr(ppath, cb) {
         var self = this;
-        self.getChildren(ppath, function (err, kids) {
+        self.list(ppath, function (err, kids) {
                 if (err) {
                         cb(err);
                         return;
@@ -113,7 +154,7 @@ function zkRmr(ppath, cb) {
                 }
 
                 function done() {
-                        self.remove(ppath, function (err2) {
+                        self.delete(ppath, -1, function (err2) {
                                 if (err2) {
                                         cb(err2);
                                         return;
@@ -174,6 +215,7 @@ module.exports = {
         createCache: createCache,
         createLogger: createLogger,
         createServer: createServer,
-        zkRmr: zkRmr
+        zkRmr: zkRmr,
+        zkMkdirP: zkMkdirP
 
 };
diff --git a/test/host.test.js b/test/host.test.js
index 918f416..bcc0cba 100644
--- a/test/host.test.js
+++ b/test/host.test.js
@@ -9,7 +9,6 @@
  */
 
 var vasync = require('vasync');
-var nzk = require('node-zookeeper-client');
 
 var core = require('../lib');
 
@@ -45,13 +44,14 @@ before(function (callback) {
                                 } else {
                                         self.server = res.server;
                                         self.zk = res.zk;
+                                        self.zkCache = res.zkCache;
                                         cb();
                                 }
                         });
                 },
 
                 function mkdir(_, cb) {
-                        self.zk.mkdirp(PATH, cb);
+                        helper.zkMkdirP.call(self.zk, PATH, cb);
                 },
 
                 function setRecord(_, cb) {
@@ -62,11 +62,9 @@ before(function (callback) {
                                 }
                         };
                         var data = new Buffer(JSON.stringify(record));
-                        self.zk.create(PATH, data, function (err) {
-                                if (err && err.getCode() ===
-                                        nzk.Exception.NODE_EXISTS) {
-
-                                        self.zk.setData(PATH, data, cb);
+                        self.zk.create(PATH, data, {}, function (err) {
+                                if (err && err.code === 'NODE_EXISTS') {
+                                        self.zk.set(PATH, data, -1, cb);
                                 } else {
                                         cb();
                                 }
@@ -88,9 +86,10 @@ before(function (callback) {
 after(function (callback) {
         var self = this;
         helper.zkRmr.call(this.zk, '/com', function (err) {
-                self.zk.on('disconnected', function () {
+                self.zk.on('close', function () {
                         self.server.stop(callback);
                 });
+                self.zkCache.stop();
                 self.zk.close();
         });
 });
@@ -104,7 +103,7 @@ test('resolve record ok', function (t) {
                 t.equal(results.answers.length, 1);
                 t.deepEqual(results.answers[0], {
                         name: RECORD,
-                        ttl: 5,
+                        ttl: 30,
                         type: 'A',
                         target: ADDR
                 });
diff --git a/test/service.test.js b/test/service.test.js
index 95b9c16..f3fb2e4 100644
--- a/test/service.test.js
+++ b/test/service.test.js
@@ -9,7 +9,7 @@
  */
 
 var vasync = require('vasync');
-var nzk = require('node-zookeeper-client');
+var mod_zkstream = require('zkstream');
 
 var core = require('../lib');
 
@@ -35,8 +35,8 @@ var LBS = {
         'lbA': '10.0.1.2',
         'lbB': '10.0.1.3'
 };
-var PATH = '/com/joyent/foo';
-var SVC = 'foo.joyent.com';
+var PATH = '/com/foo/bar';
+var SVC = 'bar.foo.com';
 var SVC_VALUE = {
         type: 'service',
         service: {
@@ -56,11 +56,9 @@ before(function (callback) {
 
         function zkPut(path, obj, cb) {
                 var data = new Buffer(JSON.stringify(obj));
-                self.zk.create(path, data, function (err) {
-                        if (err && err.getCode() ===
-                                nzk.Exception.NODE_EXISTS) {
-
-                                self.zk.setData(path, data, cb);
+                self.zk.create(path, data, {}, function (err) {
+                        if (err && err.code === 'NODE_EXISTS') {
+                                self.zk.set(path, data, -1, cb);
                         } else {
                                 cb(err);
                         }
@@ -75,13 +73,14 @@ before(function (callback) {
                                 } else {
                                         self.server = res.server;
                                         self.zk = res.zk;
+                                        self.zkCache = res.zkCache;
                                         cb();
                                 }
                         });
                 },
 
                 function mkdir(_, cb) {
-                        self.zk.mkdirp(PATH, cb);
+                        helper.zkMkdirP.call(self.zk, PATH, cb);
                 },
 
                 function setServiceRecord(_, cb) {
@@ -127,7 +126,7 @@ before(function (callback) {
                         process.exit(1);
                 }
 
-                callback();
+                setTimeout(callback, 500);
         });
 });
 
@@ -135,9 +134,10 @@ before(function (callback) {
 after(function (callback) {
         var self = this;
         helper.zkRmr.call(this.zk, '/com', function (err) {
-                self.zk.on('disconnected', function () {
+                self.zk.on('close', function () {
                         self.server.stop(callback);
                 });
+                self.zkCache.stop();
                 self.zk.close();
         });
 });
-- 
2.21.0

