commit 67ec1ff142e4cd3992eaef1a0b094752c121a5d6 (refs/changes/87/4787/3)
Author: Pedro Palazon Candel <pedro@joyent.com>
Date:   2018-09-06T16:58:31+02:00 (1 year, 1 month ago)
    
    TRITON-725 sdcadm check-config fails after post-setup fabrics
    Reviewed by: Rui <rui@joyent.com>
    Approved by: Rui <rui@joyent.com>

diff --git a/.eslintrc b/.eslintrc
index 65c08ff..d3af698 100644
--- a/.eslintrc
+++ b/.eslintrc
@@ -12,7 +12,8 @@
         }
     },
     "env": {
-        "node": true
+        "node": true,
+        "es6": true
     },
     "rules": {
         // Local rule configuration
diff --git a/lib/cli/do_check_config.js b/lib/cli/do_check_config.js
index 182c6c5..3e8c218 100644
--- a/lib/cli/do_check_config.js
+++ b/lib/cli/do_check_config.js
@@ -8,12 +8,68 @@
  * Copyright (c) 2018, Joyent, Inc.
  */
 
+var child_process = require('child_process'),
+    execFile = child_process.execFile;
+
 var assert = require('assert-plus');
 var sprintf = require('extsprintf').sprintf;
 var vasync = require('vasync');
 
 var errors = require('../errors');
 
+const SVCS_IN_CFG_FILE = [
+    'binder',
+    'manatee',
+    'moray',
+    'ufds',
+    'workflow',
+    'imgapi',
+    'cnapi',
+    'fwapi',
+    'vmapi',
+    'sdc',
+    'papi',
+    'ca',
+    'adminui',
+    'mahi',
+    'amon',
+    'amonredis',
+    'assets',
+    'dhcpd',
+    'rabbitmq',
+    'napi',
+    'sapi'
+];
+
+/*
+ * Try to load and return usbkey config from the system, or the appropriate
+ * error message on failure
+ */
+function loadUsbConfig(cb) {
+    execFile('/bin/bash', ['/lib/sdc/config.sh', '-json'],
+        function loadUsbConfigCb(err, stdout, stderr) {
+            if (err) {
+                cb(new errors.InternalError({
+                    cause: err,
+                    message: 'Cannot load usbkey config: ' + stderr
+                }));
+                return;
+            }
+
+            var parseErr, config;
+
+            try {
+                config = JSON.parse(stdout);
+            } catch (e) {
+                parseErr = new errors.InternalError({
+                    cause: e,
+                    message: 'Cannot parse usbkey config'
+                });
+            }
+
+            cb(parseErr, config);
+    });
+}
 
 function CheckConfig(opts) {
     assert.object(opts, 'opts');
@@ -39,23 +95,26 @@ CheckConfig.prototype.execute = function cExecute(opts, args, cb) {
     assert.object(args, 'args');
     assert.func(cb, 'cb');
 
-    var self = this;
-
-
+    const self = this;
     // SAPI values for sdc application:
-    var sdc = self.sdcadm.sdcApp.metadata;
-    // Name of SAPI services for VMs:
-    var services;
-    // Headnode sysinfo:
-    var sysinfo;
-    // External and admin networks:
-    var admin;
-    var external;
+    const sdc = self.sdcadm.sdcApp.metadata;
     // Shortcut:
-    var cfg = self.sdcadm.config;
+    const cfg = self.sdcadm.config;
 
+    // Headnode sysinfo:
+    let sysinfo;
+    // External and admin networks:
+    let admin;
+    let external;
     // Errors:
-    var errs = [];
+    let errs = [];
+    // Context object to pass to vasync pipeline functions:
+    let context = {
+        // Admin IPs for the different service instances:
+        // (Using a map to avoid bothering with hasOwnProperty)
+        adminIps: new Map()
+    };
+
 
     function getSysinfo(_, next) {
         self.sdcadm.cnapi.listServers({
@@ -251,88 +310,124 @@ CheckConfig.prototype.execute = function cExecute(opts, args, cb) {
         });
     }
 
-    // PEDRO: Shall we really care about core zone Admin IP addresses here?:
-    // (Ignoring for now)
-    function getVmsIps(_, next) {
-        var filters = {
-            query: sprintf('(&(tags=*-smartdc_type=core-*)' +
-                   '(|(state=running)(state=provisioning)(state=stopped))' +
-                   '(owner_uuid=%s))', cfg.ufds_admin_uuid)
-        };
-        self.sdcadm.vmapi.listVms(filters, next);
 
+    function getSapiSvcs(ctx, next) {
+        self.sdcadm.getServices({
+            type: 'vm'
+        }, function getSvcsCb(svcsErr, svcs) {
+            if (svcsErr) {
+                next(svcsErr);
+                return;
+            }
+            ctx.services = svcs;
+            next();
+        });
     }
 
-    self.sdcadm.sapi.listServices({
-        application_uuid: sdc.uuid
-    }, function listSvcsCb(err, res) {
-        if (err) {
-            cb(err);
-            return;
+    function getCoreVmInsts(ctx, next) {
+        self.sdcadm.listInsts({
+            types: ['vm']
+        }, function listInstCb(listErr, insts) {
+            if (listErr) {
+                next(listErr);
+                return;
+            }
+            ctx.insts = insts;
+            next();
+        });
+    }
+
+    function adminIpsBySvc(ctx, next) {
+        for (let i = 0; i < ctx.services.length; i += 1) {
+            const svcInsts = ctx.insts.filter(function findSvcInst(inst) {
+                return (inst.service === ctx.services[i].name);
+            });
+
+            ctx.adminIps.set(ctx.services[i].name,
+                svcInsts.map(function inst2ip(inst) {
+                    return inst.ip;
+                }));
         }
-        if (!res.length) {
-            cb('Cannot find SDC services in SAPI');
+        next();
+    }
+
+
+    // Check '$SERVICE_admin_ips' against our admin_ips
+    // Check '$SERVICE_client_url' when existing points to the admin IP
+    // of an existing service admin ip
+    // Perform these checks for both, usbkey config file and sapi's sdc app
+
+    vasync.pipeline({
+        funcs: [
+            getSysinfo,
+            getNetworks,
+            getDcFromUfds,
+            getUfdsAdmin,
+            getSapiSvcs,
+            getCoreVmInsts,
+            adminIpsBySvc,
+            function loadConfigFromFile(ctx, next) {
+                loadUsbConfig(function loadCfgErr(cfgErr, usbCfg) {
+                    if (cfgErr) {
+                        next(cfgErr);
+                        return;
+                    }
+                    ctx.usbCfg = usbCfg;
+                    next();
+                });
+            }
+        ],
+        arg: context
+    }, function pipelineCb(err2, _res) {
+        if (err2) {
+            cb(err2);
             return;
         }
 
-        services = res.filter(function (s) {
-            return (s.type === 'vm');
-        }).map(function (s) {
-            return (s.name);
-        });
 
-        vasync.pipeline({
-            funcs: [
-                getSysinfo,
-                getNetworks,
-                getDcFromUfds,
-                getUfdsAdmin,
-                getVmsIps
-            ]
-        }, function (err2, _res) {
-            if (err2) {
-                cb(err2);
-                return;
+
+        SVCS_IN_CFG_FILE.forEach(function checkSvcCfgVars(s) {
+            if (!sdc[s + '_admin_ips']) {
+                errs.push(sprintf('Missing %s_admin_ips in SAPI', s));
             }
 
-            // PEDRO: Note the exceptions listed below. I bet we could
-            // remove most of these variables anyway, and left a single
-            // value for *_pw.
-            services.forEach(function checkSvcCfgVars(s) {
-                if (s === 'cns' || s === 'portolan' || s === 'docker' ||
-                    s === 'cmon' || s === 'volapi' || s === 'assets') {
-                    return;
+            if (s !== 'manatee' && s !== 'binder' && s !== 'assets') {
+                if (!sdc[s + '_domain']) {
+                    errs.push(sprintf('Missing %s_domain in SAPI', s));
                 }
-                if (!sdc[s + '_root_pw'] && s !== 'manta' && s !== 'sapi') {
-                    errs.push(sprintf('Missing %s_root_pw in SAPI', s));
+                if (!sdc[s.toUpperCase() + '_SERVICE']) {
+                    errs.push(sprintf('Missing %s_SERVICE in SAPI',
+                            s.toUpperCase()));
                 }
+            }
+        });
 
-                if (!sdc[s + '_admin_ips'] && s !== 'cloudapi' &&
-                    s !== 'manta' && s !== 'sdcsso') {
-                    errs.push(sprintf('Missing %s_admin_ips in SAPI', s));
-                }
+        for (let [svc, ips] of context.adminIps) {
+            const ipsToString = ips.join(',');
+            const keyName = svc + '_admin_ips';
+            if (sdc[keyName] && sdc[keyName] !== ipsToString) {
+                errs.push(sprintf('Value for %s in SAPI does not ' +
+                    'match real instance(s) Admin Ips', svc));
+            }
 
-                if (s !== 'manatee' && s !== 'binder' &&
-                    s !== 'manta' && s !== 'cloudapi') {
-                    if (!sdc[s + '_domain']) {
-                        errs.push(sprintf('Missing %s_domain in SAPI', s));
-                    }
-                    if (!sdc[s.toUpperCase() + '_SERVICE']) {
-                        errs.push(sprintf('Missing %s_SERVICE in SAPI',
-                                s.toUpperCase()));
-                    }
-                }
-            });
-            // Check that ufds_remote_ip is present if this is not master:
-            if (!sdc.ufds_is_master || sdc.ufds_is_master === 'false') {
-                if (!sdc.ufds_remote_ip) {
-                    errs.push('Missing SAPI variable "ufds_remote_ip"');
-                }
+            if (context.usbCfg[keyName] &&
+                context.usbCfg[keyName] !== ipsToString) {
+                errs.push(sprintf('Value for %s in USB Config file does not ' +
+                    'match real instance(s) Admin Ips', svc));
             }
-            self.sdcadm.ufds.close(function (_err3) {
-                cb(null, errs);
-            });
+        }
+
+        // Check that ufds_remote_ip is present if this is not master:
+        if (!sdc.ufds_is_master || sdc.ufds_is_master === 'false') {
+            if (!sdc.ufds_remote_ip) {
+                errs.push('Missing SAPI variable "ufds_remote_ip"');
+            }
+        }
+
+        self.sdcadm.ufds.close(function (_err3) {
+            cb(null, errs);
         });
+
     });
 };
 
