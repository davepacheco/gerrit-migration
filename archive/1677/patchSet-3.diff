From 6e266c8cdb6a8979d932b5296790a00b47f4806a Mon Sep 17 00:00:00 2001
From: Alex Wilson <alex.wilson@joyent.com>
Date: Thu, 16 Mar 2017 15:57:04 -0700
Subject: [PATCH] joyent/node-cueball#103 pinger running should not trigger
 creation of more connections Reviewed by: David Pacheco <dap@joyent.com>

---
 CHANGES.adoc          |  1 +
 lib/connection-fsm.js |  6 +++++
 lib/pool.js           |  4 +++-
 test/pool.test.js     | 55 ++++++++++++++++++++++++++++++++++++++++++-
 4 files changed, 64 insertions(+), 2 deletions(-)

diff --git a/CHANGES.adoc b/CHANGES.adoc
index 82c8f93..85d0c9f 100644
--- a/CHANGES.adoc
+++ b/CHANGES.adoc
@@ -14,6 +14,7 @@ Bugs fixed:
 
  - #102 HTTP Agent pinger hangs. HttpAgent's "ping" option has been broken
    since 2.0.0.
+ - #103 pinger running should not trigger creation of more connections
 
 ### v2.2.0
 
diff --git a/lib/connection-fsm.js b/lib/connection-fsm.js
index db22d37..0ed4d8e 100644
--- a/lib/connection-fsm.js
+++ b/lib/connection-fsm.js
@@ -908,6 +908,11 @@ ConnectionSlotFSM.prototype.getSocketMgr = function () {
 	return (this.csf_smgr);
 };
 
+ConnectionSlotFSM.prototype.isRunningPing = function () {
+	return (this.isInState('busy') && this.csf_handle &&
+	    this.csf_handle.csf_pinger);
+};
+
 ConnectionSlotFSM.prototype.state_init = function (S) {
 	S.on(this, 'startAsserted', function () {
 		S.gotoState('connecting');
@@ -1055,6 +1060,7 @@ function doPingCheck(fsm, checker) {
 		claimTimeout: Infinity
 	};
 	var handle = new CueBallClaimHandle(hdlOpts);
+	handle.csf_pinger = true;
 	/*
 	 * Don't bother handling a return to "waiting" state here: if we
 	 * fail, it's fine, just let go of this handle entirely.
diff --git a/lib/pool.js b/lib/pool.js
index 93db771..528c077 100644
--- a/lib/pool.js
+++ b/lib/pool.js
@@ -647,8 +647,10 @@ CueBallConnectionPool.prototype.addConnection = function (key) {
 		 * Connections that are doing a health check get put on the
 		 * initq so they don't get counted as "busy".
 		 */
-		if (newState === 'ping' && !fsm.p_initq_node)
+		if (newState === 'busy' && fsm.isRunningPing() &&
+		    !fsm.p_initq_node) {
 			fsm.p_initq_node = self.p_initq.push(fsm);
+		}
 
 		if (newState === 'failed') {
 			self.p_dead[key] = true;
diff --git a/test/pool.test.js b/test/pool.test.js
index de7543a..ce47c0a 100644
--- a/test/pool.test.js
+++ b/test/pool.test.js
@@ -650,7 +650,7 @@ mod_tape.test('pool ping checker', function (t) {
 			setTimeout(function () {
 				verifyCheck();
 				hdl.release();
-			}, 300);
+			}, 1000);
 		});
 
 		function verifyCheck() {
@@ -665,6 +665,59 @@ mod_tape.test('pool ping checker', function (t) {
 	});
 });
 
+mod_tape.test('pool ping checker no expand', function (t) {
+	connections = [];
+	resolver = undefined;
+
+	var pool = new mod_pool.ConnectionPool({
+		log: log,
+		domain: 'foobar',
+		spares: 2,
+		maximum: 10,
+		constructor: function (backend) {
+			return (new DummyConnection(backend));
+		},
+		checkTimeout: 100,
+		checker: doCheck,
+		recovery: recovery
+	});
+	t.ok(resolver);
+
+	pool.on('stateChanged', function (st) {
+		if (st === 'stopped')
+			t.end();
+	});
+
+	function doCheck(hdl, conn) {
+		conn.checked = true;
+		hdl.release();
+	}
+
+	resolver.emit('added', 'b1', {});
+	setImmediate(function () {
+		t.equal(connections.length, 2);
+		t.strictEqual(connections[0].backend, 'b1');
+		t.strictEqual(connections[1].backend, 'b1');
+
+		connections.forEach(function (c) {
+			t.strictEqual(c.refd, true);
+			c.connect();
+		});
+
+		setTimeout(verifyCheck, 300);
+
+		function verifyCheck() {
+			var cs = connections.map(function (c) {
+				return (c.checked);
+			});
+			cs.sort();
+			t.deepEqual(cs, [true, true]);
+
+			pool.stop();
+		}
+	});
+});
+
 mod_tape.test('claim cancellation', function (t) {
 	connections = [];
 	resolver = undefined;
-- 
2.21.0

