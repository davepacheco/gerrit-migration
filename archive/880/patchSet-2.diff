commit c24235a3ae07102ac024e0714f17ff3e49d43bbe (refs/changes/80/880/2)
Author: YangYong3 <yy1111.yang@samsung.com>
Date:   2017-02-07T17:19:41+09:00 (2 years, 8 months ago)
    
    joyent/node-triton#129 triton reboot --wait INST' doesn't wait

diff --git a/lib/do_instance/gen_do_ACTION.js b/lib/do_instance/gen_do_ACTION.js
index d39f254..32b5959 100644
--- a/lib/do_instance/gen_do_ACTION.js
+++ b/lib/do_instance/gen_do_ACTION.js
@@ -124,82 +124,31 @@ function _doTheAction(action, subcmd, opts, args, callback) {
 
 function _doOnEachInstance(self, action, command, state, instances,
                            opts, callback) {
-    var now = Date.now();
     vasync.forEachParallel({
         func: function (arg, cb) {
-            var alias, uuid;
-            if (common.isUUID(arg)) {
-                uuid = arg;
-                done();
-            } else {
-                self.top.tritonapi.getInstance(arg, function (err, inst) {
-                    if (err) {
-                        perror(err);
-                        cb(err);
-                        return;
-                    }
-                    alias = arg;
-                    uuid = inst.id;
-                    done();
-                });
-            }
-
-            // called when "uuid" is set
-            function done() {
-                var cOpts = uuid;
-                if (command === 'startMachineFromSnapshot') {
-                    cOpts = { id: uuid, name: opts.snapshot };
+            var now = Date.now();
+            var uuid = arg;
+
+            self.top.tritonapi.gen_do_Action({
+                id: uuid,
+                action: action,
+                command: command,
+                state: state,
+                snapshot: opts.snapshot,
+                wait: opts.wait,
+                time: now
+            }, function (err) {
+                if (err) {
+                   callback(err);
+                   return;
                 }
+                console.log('%s instance %s', common.capitalize(action), uuid);
+                callback();
+            });
 
-                self.top.tritonapi.cloudapi[command](cOpts,
-                    function (err, body, res) {
-
-                    if (err) {
-                        perror(err);
-                        cb(err);
-                        return;
-                    }
-
-                    if (!opts.wait) {
-                        if (alias)
-                            console.log('%s (async) instance %s (%s)',
-                                common.capitalize(action), alias, uuid);
-                        else
-                            console.log('%s (async) instance %s',
-                                common.capitalize(action), uuid);
-                        cb();
-                        return;
-                    }
-
-                    self.top.tritonapi.cloudapi.waitForMachineStates({
-                        id: uuid,
-                        states: [state]
-                    }, function (err2, inst2, res2) {
-                        if (action === 'delete' &&
-                            res2 && res2.statusCode === 410) {
-                            // This is success, fall through to bottom.
-                            /* jsl:pass */
-                        } else if (err2) {
-                            perror(err2);
-                            cb(err2);
-                            return;
-                        }
-
-                        var dur = common.humanDurationFromMs(Date.now() - now);
-                        if (alias)
-                            console.log('%s instance %s (%s, %s)',
-                                common.capitalize(action), alias, uuid, dur);
-                        else
-                            console.log('%s instance %s (%s)',
-                                common.capitalize(action), uuid, dur);
-
-                        cb();
-                    });
-                });
-            }
-        },
-        inputs: instances
-    }, function (err, results) {
+         },
+         inputs: instances
+     }, function (err, results) {
         var e = err ? (new Error('command failure')) : null;
         callback(e);
     });
diff --git a/lib/tritonapi.js b/lib/tritonapi.js
index 9065bc5..0137d42 100644
--- a/lib/tritonapi.js
+++ b/lib/tritonapi.js
@@ -2371,6 +2371,130 @@ function _waitForInstanceRename(opts, cb) {
     setImmediate(poll);
 };
 
+/**
+ * start, stop, reboot, delete a machine by id.
+ *
+ * @param {Object} opts
+ *      - {String} id: Required. The instance name, short id, or id (a UUID).
+ *      - {String} action: Required. {startMachine, stopMachine,
+ *        rebootMachine, deleteMachine}.
+ *      - {String} command: Required. { start, stop, reboot, delete}.
+ *      - {String} state: Required. {running, stopped, delete}
+ *      - {String} snapshot: machine snapshot.
+ *      - {String} time: Required. time at start function.
+ *      - {Boolean} wait: Wait (via polling) until the rename is complete.
+ *        Warning: A concurrent rename of the same instance can result in this
+ *        polling being unable to notice the change. Use `waitTimeout` to
+ *        put an upper bound.
+ * @param {Function} callback of the form `function (err, _, res)`
+ */
+TritonApi.prototype.gen_do_Action = function gen_do_Action(opts, cb) {
+    assert.string(opts.id, 'opts.id');
+    assert.string(opts.action, 'opts.action');
+    assert.string(opts.command, 'opts.command');
+    assert.string(opts.state, 'opts.state');
+    assert.optionalString(opts.snapshot, 'opts.snapshot');
+    assert.number(opts.time, 'opts.time');
+    assert.optionalBool(opts.wait, 'opts.wait');
+    assert.func(cb, 'cb');
+
+    var self = this;
+    var res;
+
+    vasync.pipeline({arg: {client: self, id: opts.id}, funcs: [
+        _stepInstId,
+
+        function renameMachine(arg, next) {
+            var cOpts = arg.instId;
+            if (opts.command === 'startMachineFromSnapshot') {
+                cOpts = { id: arg.instId, name: opts.snapshot };
+            }
+
+            self.cloudapi[opts.command](cOpts,
+                function (err, _, _res) {
+                    res = _res;
+                    next(err);
+            });
+        },
+
+        function waitForNameChanges(arg, next) {
+            if (!opts.wait) {
+                next();
+                return;
+            }
+            if (opts.action !== 'reboot') {
+                self.cloudapi.waitForMachineStates({
+                    id: arg.instId,
+                    states: [opts.state]
+                }, function (err2, inst2, res2) {
+                    if (opts.action === 'delete' &&
+                        res2 && res2.statusCode === 410) {
+                        // This is success, fall through to bottom.
+                        /* jsl:pass */
+                    } else if (err2) {
+                        next(err2);
+                    }
+                    next();
+                });
+
+            } else {
+                self._waitForInstanceReboot({
+                    id: arg.instId,
+                    time: opts.time
+                }, next);
+            }
+        }
+    ]}, function (err) {
+        cb(err, null, res);
+    });
+};
+
+/**
+ * Shared implementation for any methods to instance reboot.
+ *
+ * @param {Object} opts
+ *      - {String} id: The instance ID Required.
+ *      - {Number} time: The number of milliseconds start time.
+ * @param {Function} cb: `function (err)`
+ */
+TritonApi.prototype._waitForInstanceReboot =
+function _waitForInstanceReboot(opts, cb) {
+    var self = this;
+    assert.object(opts, 'opts');
+    assert.uuid(opts.id, 'opts.id');
+    assert.number(opts.time, 'opts.time');
+    assert.func(cb, 'cb');
+
+    /*
+     * Hardcoded 2s poll interval for now. Not yet configurable, being mindful
+     * of avoiding lots of clients naively swamping a CloudAPI and hitting
+     * throttling.
+     */
+    var POLL_INTERVAL = 2 * 1000;
+
+    var poll = function () {
+        self.cloudapi.machineAudit(opts.id, function (err, audit) {
+            if (err) {
+                cb(err);
+                return;
+            }
+            var auditAction = audit[0].action;
+            var auditTime = audit[0].time;
+            var auditSuccess = audit[0].success;
+            if (auditAction === 'reboot' && auditSuccess === 'yes' &&
+                (opts.time < Date.parse(auditTime))) {
+                cb();
+                return;
+
+            } else {
+                setTimeout(poll, POLL_INTERVAL);
+            }
+        });
+    };
+
+    setImmediate(poll);
+};
+
 //---- exports
 
 module.exports = {
