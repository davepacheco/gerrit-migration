commit cef6604e3687fab11f621684dd80a61d59ded366 (refs/changes/36/5336/1)
Author: Mike Gerdts <mike.gerdts@joyent.com>
Date:   2019-01-09T16:01:04+00:00 (9 months ago)
    
    OS-6721 vmadm info doesn't work with bhyve

diff --git a/src/Makefile b/src/Makefile
index 852e7bf8..6ba8fab4 100644
--- a/src/Makefile
+++ b/src/Makefile
@@ -10,7 +10,7 @@
 #
 
 #
-# Copyright (c) 2018, Joyent, Inc.
+# Copyright (c) 2019, Joyent, Inc.
 #
 
 include Makefile.defs
@@ -117,6 +117,7 @@ JS_CHECK_TARGETS=\
 	vm/tests/test-hrtime.js \
 	vm/tests/test-indestructible.js \
 	vm/tests/test-internal_metadata_namespaces.js \
+	vm/tests/test-info.js \
 	vm/tests/test-lastexited.js \
 	vm/tests/test-openonerrlogger.js \
 	vm/tests/test-queue.js \
diff --git a/src/vm/node_modules/VM.js b/src/vm/node_modules/VM.js
index a9f863ee..29aaae59 100644
--- a/src/vm/node_modules/VM.js
+++ b/src/vm/node_modules/VM.js
@@ -20,7 +20,7 @@
  *
  * CDDL HEADER END
  *
- * Copyright (c) 2018, Joyent, Inc.
+ * Copyright (c) 2019, Joyent, Inc.
  *
  * Experimental functions, expect these interfaces to be unstable and
  * potentially go away entirely:
@@ -56,7 +56,6 @@
  *
  * logname - you can set this to a string [a-zA-Z_] to use as log name
  * logger - you can set this to a node-bunyan log stream to capture the logs
- * INFO_TYPES - list of supported types for the info command
  * SYSRQ_TYPES - list of supported requests for sysrq
  *
  * IMPORTANT: Per OS-2427, this file is for the exlusive use of vmadmd and
@@ -278,20 +277,6 @@ exports.VGA_TYPES = [
     'xenfb'
 ];
 
-exports.INFO_TYPES = [
-    'all',
-    'block',
-    'blockstats',
-    'chardev',
-    'cpus',
-    'kvm',
-    'pci',
-    'spice',
-    'status',
-    'version',
-    'vnc'
-];
-
 exports.SYSRQ_TYPES = {
     // all: is used when we're just validating at vmadm, for fail fast
     all: [
@@ -17627,7 +17612,7 @@ exports.stop = function (uuid, options, callback)
     });
 };
 
-// sends several query-* commands to QMP to get details for a VM
+// Makes an info request to vmadmd
 exports.info = function (uuid, types, options, callback)
 {
     var load_fields;
@@ -17659,22 +17644,13 @@ exports.info = function (uuid, types, options, callback)
         'uuid'
     ];
 
-    // load to ensure we're a VM
+    // Load the vmobj and GET info from vmadmd
     VM.load(uuid, {fields: load_fields, log: log}, function (err, vmobj) {
-        var type;
-
         if (err) {
             callback(err);
             return;
         }
 
-        if (!BRAND_OPTIONS[vmobj.brand].features.runtime_info) {
-            //  XXX if support is added to other brands, update this message.
-            callback(new Error('the info command is only supported for KVM '
-                + 'VMs'));
-            return;
-        }
-
         if (vmobj.state !== 'running' && vmobj.state !== 'stopping') {
             callback(new Error('Unable to get info for vm from state "'
                 + vmobj.state + '", must be "running" or "stopping".'));
@@ -17685,12 +17661,11 @@ exports.info = function (uuid, types, options, callback)
             types = ['all'];
         }
 
-        for (type in types) {
-            type = types[type];
-            if (VM.INFO_TYPES.indexOf(type) === -1) {
-                callback(new Error('unknown info type: ' + type));
-                return;
-            }
+        try {
+            VM.checkInfoTypes(vmobj, types);
+        } catch (_err) {
+            callback(_err);
+            return;
         }
 
         http.get({ host: '127.0.0.1', port: 8080, path: '/vm/' + uuid + '/info'
@@ -17717,6 +17692,26 @@ exports.info = function (uuid, types, options, callback)
     });
 };
 
+exports.checkInfoTypes = function checkInfoTypes(vmobj, types)
+{
+    assert.object(vmobj);
+    assert.arrayOfString(types);
+    var type;
+
+    if (!BRAND_OPTIONS[vmobj.brand].features.runtime_info) {
+        throw new Error('no info types supported for brand ' + vmobj.brand);
+    }
+    var btypes = BRAND_OPTIONS[vmobj.brand].features.runtime_info;
+
+    for (type in types) {
+        type = types[type];
+        if (btypes.indexOf(type) === -1) {
+            throw new Error('unknown info type ' + type);
+        }
+    }
+};
+
+
 function reset(uuid, log, callback)
 {
     var load_fields;
diff --git a/src/vm/node_modules/proptable.js b/src/vm/node_modules/proptable.js
index b4d191d1..17a44ed9 100644
--- a/src/vm/node_modules/proptable.js
+++ b/src/vm/node_modules/proptable.js
@@ -20,7 +20,7 @@
  *
  * CDDL HEADER END
  *
- * Copyright (c) 2018, Joyent, Inc.
+ * Copyright (c) 2019, Joyent, Inc.
  *
  */
 
@@ -2197,7 +2197,7 @@ exports.properties = {
  *                    mdata:fetch service to update properties in the zone
  * 'min_memory_overhead' -- (integer) minimum delta between ram + max_physical
  * 'model_required' -- (boolean) whether a .model is required on nics and disks
- * 'runtime_info' -- (boolean) whether this zone supports the 'info' command
+ * 'runtime_info' -- (array) types of info returned by VM.info()
  * 'serial_console' -- (boolean) whether this zone uses serial console
  * 'type' -- the type of the VM (OS or KVM), all brands should include this
  * 'update_mdata_exec_timeout' (boolean) whether to update mdata:exec timeout
@@ -2221,6 +2221,7 @@ exports.brand_options = {
                 '-proc_fork', '-proc_info', '-proc_session'],
             'min_memory_overhead': BHYVE_MIN_MEM_OVERHEAD,
             'model_required': true,
+            'runtime_info': ['all', 'vnc'],
             'zlogin_console': true,
             'type': 'BHYVE',
             'var_svc_provisioning': true,
@@ -2266,7 +2267,8 @@ exports.brand_options = {
                 '-proc_fork', '-proc_info', '-proc_session'],
             'min_memory_overhead': KVM_MIN_MEM_OVERHEAD,
             'model_required': true,
-            'runtime_info': true,
+            'runtime_info': ['all', 'block', 'blockstats', 'chardev', 'cpus',
+                'kvm', 'pci', 'spice', 'status', 'version', 'vnc'],
             'serial_console': true,
             'type': 'KVM',
             'use_vm_autoboot': true,
diff --git a/src/vm/sbin/vmadm.js b/src/vm/sbin/vmadm.js
index 4df266d5..294d0d4c 100755
--- a/src/vm/sbin/vmadm.js
+++ b/src/vm/sbin/vmadm.js
@@ -21,7 +21,7 @@
  *
  * CDDL HEADER END
  *
- * Copyright (c) 2018, Joyent, Inc.
+ * Copyright (c) 2019, Joyent, Inc.
  *
  */
 
@@ -358,19 +358,12 @@ function parseStartArgs(args)
 function parseInfoArgs(args)
 {
     var arg;
-    var type;
     var types = [];
 
     for (arg in args) {
         types = types.concat(args[arg].split(','));
     }
 
-    for (type in types) {
-        if (VM.INFO_TYPES.indexOf(types[type]) === -1) {
-            usage('Invalid info type: ' + types[type]);
-        }
-    }
-
     if (types.length === 0) {
         types.push('all');
     }
diff --git a/src/vm/sbin/vmadmd.js b/src/vm/sbin/vmadmd.js
index 0e47ed93..12bdb1d7 100755
--- a/src/vm/sbin/vmadmd.js
+++ b/src/vm/sbin/vmadmd.js
@@ -21,7 +21,7 @@
  *
  * CDDL HEADER END
  *
- * Copyright (c) 2018, Joyent, Inc.
+ * Copyright (c) 2019, Joyent, Inc.
  *
  */
 
@@ -1457,6 +1457,7 @@ function infoVM(uuid, types, callback)
         'query-pci',
         'query-kvm'
     ];
+    var loadCbs = {};
 
     log.debug('LOADING: ' + uuid);
 
@@ -1467,19 +1468,16 @@ function infoVM(uuid, types, callback)
         'zonepath'
     ];
 
-    VM.load(uuid, {fields: load_fields}, function (err, vmobj) {
-        var q;
-        var socket;
-        var type;
-
+    VM.load(uuid, {fileds: load_fields}, function (err, vmobj) {
         if (err) {
-            callback('Unable to load vm: ' + JSON.stringify(err));
+            callback(new Error('Unable to load vm: ' + JSON.stringify(err)));
             return;
         }
 
-        if (vmobj.brand !== 'kvm') {
-            callback(new Error('vmadmd only handles "info" for kvm ('
-                + 'your brand is: ' + vmobj.brand + ')'));
+        if (!loadCbs.hasOwnProperty(vmobj.brand)) {
+            callback(new Error('vmadmd only handles "info" for: "'
+                + vmobj.keys.join('", "') + '".  Your brand is: "'
+                + vmobj.brand + '".'));
             return;
         }
 
@@ -1489,20 +1487,29 @@ function infoVM(uuid, types, callback)
             return;
         }
 
-        q = new Qmp(log);
-
         if (!types) {
             types = ['all'];
         }
 
-        for (type in types) {
-            type = types[type];
-            if (VM.INFO_TYPES.indexOf(type) === -1) {
-                callback(new Error('unknown info type: ' + type));
-                return;
-            }
+        try {
+            VM.checkInfoTypes(vmobj, types);
+        } catch (_err) {
+            callback(_err);
+            return;
         }
 
+        loadCbs[vmobj.brand](vmobj);
+    });
+
+    loadCbs.kvm = function loadKvmCb(vmobj) {
+        assert.object(vmobj);
+        assert.uuid(vmobj.uuid);
+
+        var q;
+        var socket;
+
+        q = new Qmp(log);
+
         socket = vmobj.zonepath + '/root/tmp/vm.qmp';
 
         q.connect(socket, function (error) {
@@ -1540,19 +1547,7 @@ function infoVM(uuid, types, callback)
                     if ((types.indexOf('all') !== -1)
                         || (types.indexOf('vnc') !== -1)) {
 
-                        res.vnc = {};
-                        if (VNC.hasOwnProperty(vmobj.uuid)) {
-                            res.vnc.host = VNC[vmobj.uuid].host;
-                            res.vnc.port = VNC[vmobj.uuid].port;
-                            if (VNC[vmobj.uuid].hasOwnProperty('display')) {
-                                res.vnc.display = VNC[vmobj.uuid].display;
-                            }
-                            if (VNC[vmobj.uuid].hasOwnProperty('password')
-                                && VNC[vmobj.uuid].password.length > 0) {
-
-                                res.vnc.password = VNC[vmobj.uuid].password;
-                            }
-                        }
+                        infoVNC();
                     }
                     if ((types.indexOf('all') !== -1)
                         || (types.indexOf('spice') !== -1)) {
@@ -1578,7 +1573,33 @@ function infoVM(uuid, types, callback)
                 }
             });
         });
-    });
+    };
+
+    loadCbs.bhyve = function loadBhyveCb(vmobj) {
+        assert.object(vmobj);
+        assert.uuid(vmobj.uuid);
+
+        if (types.indexOf('all') !== -1 || types.indexOf('vnc') !== -1) {
+            infoVNC();
+        }
+        callback(null, res);
+    };
+
+    function infoVNC() {
+        res.vnc = {};
+        if (VNC.hasOwnProperty(uuid)) {
+            res.vnc.host = VNC[uuid].host;
+            res.vnc.port = VNC[uuid].port;
+            if (VNC[uuid].hasOwnProperty('display')) {
+                res.vnc.display = VNC[uuid].display;
+            }
+            if (VNC[uuid].hasOwnProperty('password')
+                && VNC[uuid].password.length > 0) {
+
+                res.vnc.password = VNC[uuid].password;
+            }
+        }
+    }
 }
 
 function resetVM(uuid, callback)
diff --git a/src/vm/tests/test-info.js b/src/vm/tests/test-info.js
new file mode 100644
index 00000000..a1b2b1e1
--- /dev/null
+++ b/src/vm/tests/test-info.js
@@ -0,0 +1,213 @@
+/*
+ * CDDL HEADER START
+ *
+ * The contents of this file are subject to the terms of the
+ * Common Development and Distribution License, Version 1.0 only
+ * (the "License").  You may not use this file except in compliance
+ * with the License.
+ *
+ * You can obtain a copy of the license at http://smartos.org/CDDL
+ *
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * When distributing Covered Code, include this CDDL HEADER in each
+ * file.
+ *
+ * If applicable, add the following below this CDDL HEADER, with the
+ * fields enclosed by brackets "[]" replaced with your own identifying
+ * information: Portions Copyright [yyyy] [name of copyright owner]
+ *
+ * CDDL HEADER END
+ *
+ * Copyright (c) 2019, Joyent, Inc.
+ *
+ */
+
+var assert = require('/usr/node/node_modules/assert-plus');
+var jsprim = require('/usr/vm/node_modules/jsprim');
+var properties = require('/usr/vm/node_modules/props');
+var sprintf = require('/usr/node/node_modules/sprintf').sprintf;
+var vasync = require('/usr/vm/node_modules/vasync');
+var VM = require('/usr/vm/node_modules/VM');
+var vmtest = require('../common/vmtest.js');
+
+// this puts test stuff in global, so we need to tell jsl about that:
+/* jsl:import ../node_modules/nodeunit-plus/index.js */
+require('nodeunit-plus');
+
+VM.loglevel = 'DEBUG';
+
+/*
+ * nodeuninit-plus executes the callback specified by before() before each test
+ * is run and executes the callback specified by after() after each test is run.
+ * These callbacks ensure that vmobj is initialized to undefined prior to each
+ * test and that any VM that was created by the test is deleted after the test
+ * completes.
+ *
+ * Tests that create a VM should be setting vmobj so that the after() hook can
+ * clean up the VM when the test finishes or gives up.  If a test uses vmobj
+ * then deletes the VM on its own, it should set vmobj to undefined.
+ */
+var vmobj;
+
+before(function _before(cb) {
+    assert.func(cb, 'cb');
+    vmobj = undefined;
+    cb();
+});
+
+after(function _after(cb) {
+    assert.func(cb, 'cb');
+    if (!vmobj) {
+        cb();
+        return;
+    }
+    VM.delete(vmobj.uuid, {}, function _delete_cb(err) {
+        if (err) {
+            console.log(sprintf('Could not delete vm %s: %s', vmobj.uuid,
+                err.message));
+        }
+        vmobj = undefined;
+        cb();
+    });
+});
+
+function createVM(t, payload, next)
+{
+    VM.create(payload, function _create_cb(err, obj) {
+        if (err) {
+            t.ok(false, 'error creating VM: ' + err);
+        } else {
+            t.ok(true, 'VM created with uuid ' + obj.uuid);
+        }
+        vmobj = obj;
+        next(err, t);
+    });
+}
+
+function loadVM(t, next)
+{
+    VM.load(vmobj.uuid, function _load_cb(err, obj) {
+        if (err) {
+            t.ok(false, 'error loading VM: ' + err);
+        } else {
+            t.ok(true, 'VM loaded uuid ' + obj.uuid);
+            vmobj = obj;
+        }
+        next(err, t);
+    });
+}
+
+function checkRunning(t, next)
+{
+    t.equal(vmobj.state, 'running', 'VM is running');
+    if (vmobj.state !== 'running') {
+        next(new Error('VM is in state "%s", not "running"', vmobj.state));
+        return;
+    }
+    next(null, t);
+}
+
+function checkInfoPos(t, why, types, expect, next)
+{
+    VM.info(vmobj.uuid, types, function _check_info(err, obj) {
+        if (err) {
+            t.ok(false, sprintf('unable to get info for types %s: %s',
+                types.join(', '), err.message));
+            next(null, t);
+            return;
+        }
+        t.deepEqual(Object.keys(obj).sort(), expect.sort(),
+            why + ' returns expected keys: ' + expect.join(', '));
+        next(null, t);
+    });
+}
+
+function checkInfoNoType(t, types, next)
+{
+    var exp = 'unknown info type';
+
+    VM.info(vmobj.uuid, types, function _check_info_neg(err, obj) {
+        if (err) {
+            t.ok(jsprim.startsWith(err.message, exp), types.join(', ')
+                + ': expected error "' + exp + '", got error: ' + err.message);
+            next(null, t);
+            return;
+        }
+        t.ok(false, types.join(', ') + 'exected error "' + exp
+            + '", got success: ' + JSON.stringify(obj));
+        next(null, t);
+    });
+}
+
+/*
+ * Common tests for brands that support info.
+ */
+function testPos(t, brand, all, some, none) {
+    var payload = {
+        alias: sprintf('test-info-%s-%d', brand, process.pid),
+        brand: brand,
+        do_not_inventory: true,
+        autoboot: true,
+        ram: 256,
+        vcpus: 1,
+        disks: [
+            {
+                image_uuid: vmtest.CURRENT_BHYVE_CENTOS_UUID,
+                boot: true,
+                model: 'virtio'
+            }
+        ]
+    };
+    var runtime_info = properties.BRAND_OPTIONS[brand].features.runtime_info;
+
+    t.deepEqual(all.concat(['all']).sort(), runtime_info.sort(),
+        'test matches BRAND_INFO runtime_info');
+
+    vasync.waterfall([
+        function _create(next) {
+            createVM(t, payload, next);
+        },
+        loadVM,
+        checkRunning,
+        function _check_all1(_t, next) {
+            checkInfoPos(_t, 'all1', ['all'], all, next);
+        }, function _check_all2(_t, next) {
+            checkInfoPos(_t, 'all2', all, all, next);
+        }, function _check_all3(_t, next) {
+            checkInfoPos(_t, 'all3', all.concat(['all']), all, next);
+        }, function _check_some(_t, next) {
+            checkInfoPos(_t, 'some', some, some, next);
+        }, function _check_none(_t, next) {
+            checkInfoNoType(_t, none, next);
+        }, function _check_neg_bogus(_t, next) {
+            checkInfoNoType(_t, ['bogus'], next);
+        }], function _done() {
+            t.end();
+        });
+}
+
+/*
+ * Tests, finally!
+ *
+ * Remember that the functions passed by before() and after() are called before
+ * and after each test.
+ */
+
+test('bhyve info', function bhyve_info(t) {
+    var all = ['vnc'];
+    var some = ['vnc'];
+    var none = ['spice'];
+
+    testPos(t, 'bhyve', all, some, none);
+});
+
+test('kvm info', function kvm_info(t) {
+    var all = ['block', 'blockstats', 'chardev', 'cpus', 'kvm', 'pci', 'spice',
+        'status', 'version', 'vnc'];
+    var some = ['block', 'blockstats', 'chardev'];
+    var none = ['blurp'];
+
+    testPos(t, 'kvm', all, some, none);
+});
